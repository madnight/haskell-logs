00:00:12 <dolio> It doesn't work, apparently, but it's stopped using inappropriate indices.
00:05:45 <Vq^> @localtime rahaskella
00:05:45 <rahaskella> I live on the internet, do you expect me to have a local time?
00:22:01 <schem> g'day #haskell
00:24:35 <dmwit> Hiya, schem.
00:26:39 <schem> Heya dmwit!
00:26:44 <schem> another beautiful day!
00:26:50 <dmwit> Yes indeedy!
00:27:08 <dmwit> Lovely weather for a touch of the 'skell.
00:27:40 <schem> Hmm... gonna go through another chapter in this here real world haskell.. Can't wait 'til I get to the monad bit. :)
00:27:49 <schem> Then maybe finally the ghci will make some sense (:
00:32:01 <schem> One thing I find a bit hmm.. of a pain in the arse is the amount of stuff you need to take in before using haskell.
00:32:15 <glguy> For example?
00:32:37 <sjanssen> is the Performance: MD5 thread on -cafe worth reading?
00:32:59 <olsner> (otoh, if it was just the same as other languages, there'd be no point in learning it :P)
00:33:21 <schem> Well hmm.. with C you just need to read the K&R book, and for lisp you just need to know the difference between "syntax" for calling a function, and "syntax" for getting a value. With haskell it seems to be types, classes, monads, etc.
00:33:45 <schem> olsner: That is very much true.
00:33:54 <dmwit> "Just read the K&R book"?
00:34:06 <dmwit> If your threshold is that high, Haskell should be no problem at all.
00:34:17 <schem> I'm not really having a problem with it, no.
00:34:42 <schem> Just some minor things while reading this book here. But it's "beta" so what to expect :)
00:35:08 <schem> (eg. what on earth $ was) :)
00:35:18 <dmwit> Oh!
00:35:27 <dmwit> For that kind of thing, you should definitely leave them some feedback.
00:35:41 <dmwit> (Once you have the answer by asking here, of course. ;-)
00:35:41 <schem> I think quite a few people already did.
00:55:28 <trez> > 2.0 `mod` 5.0
00:55:30 <rahaskella>  Add a type signature
00:55:58 <dmwit> :t mod
00:56:02 <rahaskella> forall a. (Integral a) => a -> a -> a
00:56:16 <dmwit> Float/Double/Rational are not likely to be instances of Integral.
00:57:43 <trez> what should I use instead?
00:58:02 <dmwit> > let floatMod x y = y - ((x*) . fromIntegral . floor $ (y / x)) in floatMod 2.0 5.0
00:58:04 <rahaskella>  1.0
00:58:33 <dmwit> > let floatMod x y = x - ((y*) . fromIntegral . floor $ (x / y)) in floatMod 2.0 5.0
00:58:36 <rahaskella>  2.0
00:58:45 <dmwit> > let floatMod x y = x - ((y*) . fromIntegral . floor $ (x / y)) in floatMod pi 5
00:58:48 <rahaskella>  3.141592653589793
00:58:53 <dmwit> > let floatMod x y = x - ((y*) . fromIntegral . floor $ (x / y)) in floatMod pi 2
00:58:55 <rahaskella>  1.1415926535897931
00:59:11 <dmwit> > let floatMod x y = x - ((y*) . fromIntegral . floor $ (x / y)) in floatMod (-3) 5
00:59:13 <rahaskella>  2.0
00:59:20 <dmwit> I'd use something like that.
00:59:36 <trez> thank you :)
01:01:31 <dolio> > pi `mod'` 2
01:01:33 <rahaskella>  1.1415926535897931
01:01:39 <dolio> I'd use something like that.
01:01:44 <dmwit> ?index mod'
01:01:45 <rahaskella> bzzt
01:01:46 <dolio> :)
01:01:48 <dmwit> ;-)
01:01:54 <dolio> @hoogle mod'
01:01:55 <rahaskella> Data.Fixed.mod' :: Real a => a -> a -> a
01:01:55 <rahaskella> Data.Fixed.divMod' :: (Real a, Integral b) => a -> a -> (b, a)
01:02:05 <dmwit> Data.Fixed?
01:02:45 <dmwit> ?instances-importing Data.Fixed HasResolution
01:02:47 <rahaskella> E12, E6
01:03:26 <dmwit> um
01:03:39 <dmwit> Data.Fixed exports a pretty small number of things.
01:04:24 <dmwit> ?src mod'
01:04:24 <rahaskella> Source not found. Sorry about this, I know it's a bit silly.
01:04:28 <dmwit> ?source Data.Fixed
01:04:29 <rahaskella> Data.Fixed not available
01:04:33 <dolio> Yeah, I don't know when it got introduced.
01:04:48 <dolio> mod' is nice, though.
01:05:11 <dmwit> It's basically what I wrote, too.
01:05:47 <dmwit> Although they do some intermediate translation to Rational, for some reason.
01:06:00 <dmwit> Scared of rounding errors, maybe?
01:07:05 <dmwit> Oh, I think I understand what's going on in this module.
01:07:08 <dmwit> Interesting!
01:08:32 <dmwit> Bummer... it has a Show instance, but no Read instance.
01:09:04 <dmwit> This would have saved me a bunch of work just two weeks ago.
01:09:37 <dmwit> I decided to implement my own "money" type (really just Integer, just like they did here), and I'm still hunting down bugs in my money parser two weeks later. =/
01:10:16 <dmwit> (And in my money shower, too.)
01:13:05 * dmwit finds some of this code highly suspect.
01:27:36 <vixey> ?brain
01:27:37 <rahaskella> I think so, Brain, but Lederhosen won't stretch that far.
01:27:39 <vixey> ?brain
01:27:40 <rahaskella> Yeah, but I thought Madonna already had a steady bloke!
01:27:51 <vixey> @xeal
01:27:51 <rahaskella> i aint running that on my puter
01:28:03 <dmwit> ?keal
01:28:04 <rahaskella> i use an 8088
01:28:05 <dmwit> ?keal
01:28:05 <rahaskella> can GMP support KealDigit? I invent KealDigit
01:28:07 <dmwit> ?keal
01:28:07 <rahaskella> i try make program called Glyph to do it but my script lang called T too slow. i invent T
01:28:16 <vixey> lol @ KealDigit
01:28:21 <dmwit> I invent KealDigit
01:28:46 <vixey> ?seal
01:28:47 <rahaskella> how bout i say ick no unicorn and daisy loving girl mathematician will ever enjoy this
01:30:46 <Adamant> @(elite . keal)
01:30:46 <rahaskella> . Kea1)
01:31:06 <vixey> @@ @elite @keal
01:31:06 <rahaskella>  AN+IPaR5I/\/\oNy w3R3 100% (oRr3(t...
01:31:11 <vixey> @@ @elite @keal
01:31:12 <rahaskella>  OBVIOUs|y u N3VER H3ARd oph tIER. 7HEorETi(alLY It w0u|d wORx uSiNg naN0b0T5
01:31:27 <Adamant> I am going to make that mistake until the end of time
01:31:30 <vixey> 7HEorETi(alLY It w0u|d wORx uSiNg naN0b0T5 :D
01:31:44 <slarba> :D
01:32:28 <vixey> @protontorpedo
01:32:28 <rahaskella> is haskell more powerful than any jedii?
01:32:30 <Adamant> @hst
01:32:31 <rahaskella> Maybe you meant: ask ft let list msg what
01:32:41 <vixey> @protontorpedo
01:32:42 <rahaskella> whats a module?
01:32:43 <vixey> @protontorpedo
01:32:43 <Adamant> @fear
01:32:43 <rahaskella> cmon Im asking cool questions
01:32:44 <rahaskella> Maybe you meant: faq keal learn read
01:32:49 <vixey> hahahaha
01:32:51 <vixey> so true
01:32:56 <vixey> @protontorpedo
01:32:56 <rahaskella> wat is lazy evaluation?
01:32:58 <vixey> @protontorpedo
01:32:59 <rahaskella> so this java guy I know says that java is the best when things get really complex and u need your apps do do real work
01:41:35 <halberd> suppose you are storing data in nested maps
01:42:06 <halberd> then whenever you add data to a leaf of the nested map, you have to make sure that all of the intermediate nodes are already initialized
01:43:06 <halberd> one way around it, you could specify with every update operation that it must check that intermediate notes are not null, and if they are null it initializes them to empty maps first
01:43:21 <halberd> but this is a bit wasteful
01:43:23 <quicksilver> why would you use a nested map
01:43:29 <quicksilver> and not a single map on a composite key?
01:44:10 <halberd> good point, suppose though that there can be data at every interior node too
01:44:28 <halberd> so that you aren't only interested in the leaves, you may also be interested in data associated with a parent of the leaf
01:44:40 <quicksilver> just design your composite keys correctly.
01:44:59 <quicksilver> you could have a Map [String]  String
01:45:07 <quicksilver> then ["foo","bar"] can hold data
01:45:14 <quicksilver> and so can ["foo","bar","baz"]
01:46:36 <halberd> for example you want to find "Carl's third finger" so you look in the people map for Carl and then in the finger map for the third one, but maybe you also want "Carl's last name" so you look in the people map for Carl and then the last name field
01:47:11 <halberd> the last name of Carl is data associated with the interior Carl node
01:47:20 <quicksilver> ["Carl"]
01:47:30 <quicksilver> ["Carl","fingers","three"]
01:47:36 <quicksilver> ["Carl","surname"]
01:48:01 <halberd> oh, I see
01:48:16 <quicksilver> Of course you've got no type information here
01:48:19 <quicksilver> all the values are strings
01:48:30 <quicksilver> if you want dependent types then it's more fiddly
01:48:44 <quicksilver> but in principle I'm not sure a nested map is ever better than a well-designed single map.
01:48:56 <quicksilver> remember you can use a custom type for the key if you want
01:49:37 <halberd> but not for the value
01:50:04 <halberd> unless you make a special union type for just that purpose
01:50:29 <quicksilver> right. if you want values of different types you do need to think a bit harder.
01:50:45 <halberd> anyway though I guess that's a good solution
01:50:45 <quicksilver> you can wrap your map in something more strongly typed.
01:50:55 <quicksilver> with convenience accessors which get the right things
01:51:00 <quicksilver> getFinger :: Name -> Int -> Finger
01:51:50 <halberd> well
01:53:09 <halberd> except it would be hard to define the keys properly so people aren't talking about Carl's spaceship or pterodactyl when that's not intended
01:53:46 <quicksilver> halberd: well maybe.
01:53:55 <quicksilver> halberd: frankly I haven't got the faintest idea what you're talking about though :)
01:54:11 <halberd> so people aren't asking about ["Carl", "Spaceship"]
01:54:16 <quicksilver> certainly the interface between semi-structured data and strongly typed data can potentially be tricky.
01:54:28 <quicksilver> but it's possible to get something pretty sensible for most concrete problems.
01:54:50 <halberd> i.e. I want to be able to say that Carl has a map of fingers and he has a surname, and nothing else
01:55:38 <halberd> that kind of type information is important because declaring it says what you're going to use the map for
01:56:51 <dmwit> data Key = Person Name | FullyQualified Name Surname | Finger Name Int | ...
01:57:05 <dmwit> What you want is possible (though potentially annoying).
01:59:20 <BeelsebobWork> @hoogle (Monad m,Functor c) => (a -> m b) -> c a -> m (c b)
01:59:21 <rahaskella> Prelude.($) :: (a -> b) -> a -> b
01:59:21 <rahaskella> Prelude.($!) :: (a -> b) -> a -> b
01:59:21 <rahaskella> Data.Function.($) :: (a -> b) -> a -> b
01:59:30 <quicksilver> or alternatively data Person = Name Name (Map Int Finger)
01:59:38 <quicksilver> plus Map Name Person
01:59:45 <quicksilver> there is definitely more than one way to do it.
02:00:41 <halberd> but then let's say you have a House map and it has residents such as Carl, identified by their height
02:01:26 <halberd> in order to add that new capability with your data declaration you'd have to add stuff like "| House Height Person Name"
02:01:55 <halberd> for each valid query of your Person map
02:03:02 * BeelsebobWork can't rememeber -- how does one import Data.Traversable (mapM) and hide the prelude version?
02:03:12 <dmwit> I don't get it.  Why would you be surprised if changing the specs leads to changes in the code?
02:03:25 <quicksilver> BeelsebobWork: import Prelude hiding (mapM)
02:03:27 <dmwit> BeelsebobWork: -fno-implicit-prelude
02:03:43 <BeelsebobWork> cheers
02:04:09 <halberd> because you'd want to be able to say something like "| House Height Person" and get automatically from that the ability to go House  to Height to Person to Int  to Finger
02:08:03 <halberd> if nested hash maps with interior data are used to represent a tree with labeled nodes, then if you add a new node to the top it should be a simple step
02:08:19 <heavensrevenge> hello
02:08:51 <halberd> but if you represent the tree as a single hash with tuples for keys, in order to add a new layer at the top you have to list every path to a leaf
02:09:10 <heavensrevenge> how does threading work?
02:10:11 <mauke> http://en.wikipedia.org/wiki/Thread_%28computer_science%29
02:10:17 <heavensrevenge> to thread, is code split based of the function, and calculated seperately and then combined after?
02:10:52 <dmwit> That's one popular approach.
02:11:12 <dmwit> It is a very nice one, when it's possible.
02:11:20 <dmwit> But sometimes there's a need for threads to communicate.
02:11:47 <heavensrevenge> like to thread the sum from 1..20, is the code split into 2 seperate, from 1..10 then 11-20, summed seperately, then combined  afterwards?
02:12:08 <mauke> that depends on how you do it
02:12:34 <heavensrevenge> so i can conrol its method of threading?
02:12:43 <dmwit> Of course.
02:13:05 <heavensrevenge> aka, start thread, shift 20, start next thread, etc, until none is left
02:13:19 <heavensrevenge> all based on what im trying to do
02:13:27 <mauke> what does all this have to do with haskell?
02:13:48 <heavensrevenge> is this possible in haskell?
02:14:04 <mauke> yes
02:14:23 <heavensrevenge> can i specify this, to break a process into threads as i see fit, then combine later to get the result later
02:14:32 <mauke> yes
02:14:51 <dmwit> ?go beautiful concurrency
02:14:53 <rahaskella> http://research.microsoft.com/~simonpj/papers/stm/beautiful.pdf
02:14:58 <dmwit> ?docs Control.Parallel
02:14:58 <rahaskella> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Parallel.html
02:15:05 <heavensrevenge> ooo
02:15:19 <heavensrevenge> :)
02:15:56 <mauke> 404
02:16:09 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
02:16:25 <heavensrevenge> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
02:16:31 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/parallel/Control-Parallel.html
02:16:34 <heavensrevenge> ha yea, i was going to mention that
02:17:29 <dmwit> heavensrevenge: To get answers faster in the future, consider asking "How do I ..." rather than "Can I ...". ;-)
02:18:16 <heavensrevenge> i indeed will, but im just newby for coding, and ive decided to start my programming adventure with haskell as the functional language i was attracted to
02:19:06 <heavensrevenge> and i was watching a talk, about haskell and multi* and concurreny, and wanted to know if threading was controllable
02:19:27 <mauke> sure
02:19:38 <mauke> :t forkIO
02:19:43 <rahaskella> Not in scope: `forkIO'
02:19:47 <mauke> :/
02:20:11 <dmwit> Threading is controllable.  Lambdabot... not so much.
02:23:07 <heavensrevenge> forkOnIO seems to look quite nice
02:28:27 <heavensrevenge> well thanks for the info
02:29:10 <heavensrevenge> ill surely ask for more info as soon as i can more specifically have a problem needing solved, but youve kept my confidence for choosing haskell as my 1st language :)
02:29:25 <mauke> heh
02:29:42 <mauke> you're going to have to learn programming first, then
02:30:27 <heavensrevenge> the best ove done is to go through a few many language examples, and 1st courses to determine what id like to comit to
02:31:51 <heavensrevenge> ive done many Ada, c, c++, python, ruby, and lastly erlang tutorials, got finally captivated by lambda calculus and functional programmign through erlang, and got drawn to haskell
02:32:10 <dmwit> And yet you consider it your first language?
02:32:18 * dmwit is jealous
02:32:51 <heavensrevenge> haha indeed, ive only learnt how they work, and how to use, but havent actually done anything further by building my own system
02:33:46 <heavensrevenge> and so far, ive just started learning haskell, and decided i want to further it to actually program what i want to do with it
02:33:50 <Botje> other languages have hello world, haskell has language interpreters :)
02:34:28 <heavensrevenge> im also a big fan of XML and XQuery if its relevant
02:36:25 <heavensrevenge> ive got motivation of what i want to code, but i needed to find a language that would let me get to the solution as quickly as possible
02:37:07 <heavensrevenge> i do try to listen to what the big experienced guys say :P
02:37:42 <solrize_> anyone know why Chan doesn't have a way to limit the size of the channel?
02:37:55 <solrize_> i mean is there something antifunctional about that?
02:38:37 <siti> I don't think there's a way to do it
02:39:07 <siti> I don't think there's anything anti functional about it... since it's monadic code
02:40:12 <solrize_> so it's just a missing feature
02:41:53 <quicksilver> I think it might be mildly incompatible with the ability to 'dup' chans
02:42:59 <sjanssen> solrize_: limiting the size of the Chan can cause deadlock
02:46:02 <solrize_> if the readers aren't reading stuff, i suppose
02:46:35 <sjanssen> right
02:46:50 <solrize_> is that so bad?
02:47:02 <sjanssen> I should say that it adds another situation where deadlock can occur, as deadlock is already possible with MVars and such
02:47:09 <solrize_> i mean the readers are already wedged, it's not really worse if the writer is also wedged
02:47:11 <sjanssen> solrize_: deadlock is bad
02:47:31 <sjanssen> depends on the definition of "wedged"
02:47:38 <solrize_> running out of memory is also bad
02:48:12 <sjanssen> I think there is a good reason for Chan and BoundedChan to be separate types
02:48:23 <solrize_> there doesn't seem to be a way to even tell the length of a chan
02:48:28 <solrize_> oh there's boundedchan?  sec
02:48:49 <solrize_> i don't see it in the docs
02:49:00 <sjanssen> and quicksilver is right that size bounds are incompatible with duplicating the channel
02:49:06 <solrize_> anyway if boundedchan exists then "use boundedchan" is a perfectly good answer
02:49:10 <sjanssen> solrize_: no, but you could write it in an hour (probably less)
02:49:25 <solrize_> wht's the issue with dup'ing chans?
02:49:42 <sjanssen> do you understand the semantics of dupChan?
02:49:51 <sjanssen> it creates a new "read end"
02:50:02 <solrize_> and i thought the idea of a library was to -not- have to spend an hour on something like that
02:50:06 <solrize_> lemme check dupchan
02:50:21 <sjanssen> meaning that each read end will have a different number of items queued
02:50:53 <solrize_> oh no i didn't understand about dupchan, it makes any new item go on both channels
02:52:13 <solrize_> anyway it's ok for chan to block if it causes an overflow to a duplicate chan
02:52:35 <sjanssen> are you sure it's okay?
02:52:48 <solrize_> hmm
02:52:48 <sjanssen> IMO, the semantics you propose are no good
02:53:04 <solrize_> dupchan itself seems kind of weird
02:53:09 <solrize_> why have it?
02:53:14 <sjanssen> because it is useful
02:54:08 <solrize_> why not have it return two new chans, instead of changing the functionality of the original chan?
02:54:20 <solrize_> it creates a weird side effect
02:54:25 <sjanssen> for example, an IRC channel could be one Chan, with a bunch of clients dupChan'ed and writing each message back to different clients
02:54:42 <sjanssen> solrize_: it doesn't change anything about the original chan
02:56:32 <solrize_> that irc example shows the problem, what if some of the clients go offline for a while, their chans get an unbounded backlog
02:57:14 <sjanssen> not in any sane implementation
02:57:23 <solrize_> better to have a thread doing that multiplexing
02:57:35 <solrize_> sane implementation of Chan?  it says right in the docs that it's unbounded
02:57:49 <solrize_> and doesn't give a way to tell the length
02:57:50 <sjanssen> when the client goes offline, the server will receive EOF or some such on the socket, and the client loop will exit
02:57:58 <sjanssen> allowing it's copy of the chan to be garbage collected
02:58:06 <sjanssen> solrize_: sane implementation of an IRC server
02:58:10 <solrize_> oh
02:58:17 <quicksilver> both bounded and unbounded channels are useful.
02:58:30 <quicksilver> (I think this is so obvious it would be stupid to argue about)
02:58:33 <solrize_> well, maybe the client is just taking characters very very slowly and someone does a huge flood
02:58:48 <solrize_> quicksilver, ok, but why aren't there bounded channels in the lib?
02:58:55 <quicksilver> because you haven't written one yet.
02:58:58 <quicksilver> We look forward to it.
02:59:04 <matthew_-> but think about how you would
02:59:12 <matthew_-> without crippling the amount of parallelism available
02:59:22 <matthew_-> how are you going to maintain a counter of length?
02:59:31 <quicksilver> Is MVar (Data.Sequence) a reasonable bounded buffer implementation?
02:59:37 <matthew_-> no
02:59:39 <sjanssen> you can do better
02:59:39 <matthew_-> imho
02:59:48 <quicksilver> I said reasonable not perfect :P
02:59:57 <matthew_-> they're the same to me ;)
03:00:01 <sjanssen> quicksilver: that has bad concurrency properties
03:00:11 <sjanssen> writer blocks a reader more than necessary
03:00:15 <quicksilver> depending what kind of concurrency you expect, yes.
03:00:22 <matthew_-> I'd actually be tempted to use a TVar for the counter alone
03:00:47 <sjanssen> as a first implementation, I'd just write a wrapper around TChan
03:00:49 <solrize_> the obvious implementation of chan is a pair of lists
03:01:38 <sjanssen> why a pair of lists?
03:01:53 <solrize_> functional queue
03:01:56 <mauke> it's a functional queue with amortized O(1)
03:02:18 * sjanssen prefers GHC's implementation that is O(1) all the time
03:02:24 <solrize_> intmap?
03:02:35 <solrize_> that's ok too i guess
03:02:55 <sjanssen> plus, any functional implementation will block other threads more often than necessary
03:03:29 <sjanssen> in the current implementation, as long as there is a bit of space between the reader and writer, they can run entirely independently
03:04:13 <solrize_> hmm
03:04:29 <solrize_> i may ask more about that later, i'm realizing i absolutely have to go to bed like right away:)
03:04:29 <gio123> does somebody know reader to open ps files?
03:04:35 <solrize_> thanks for the info
03:04:38 <solrize_> nite :)
03:04:46 <matthew_-> gio123: are you thinking of gv?
03:04:50 <EvilTerran> @go gsview
03:04:52 <rahaskella> http://pages.cs.wisc.edu/~ghost/gsview/
03:04:52 <rahaskella> Title: GSview
03:05:08 <gio123> EvilTerran: do u know something else? i hate gv
03:05:14 <matthew_-> oh! you can open PS files under windows?
03:05:28 <matthew_-> I didn't think it had caught up to that extent yet
03:05:59 <EvilTerran> matthew_-, er, wut? if you couldn't, someone would've done it ASAP
03:06:29 <EvilTerran> gio123, no, i don't.
03:06:34 <quicksilver> sjanssen: well the dual list with two mvars only blocks at rebalance time, I guess.
03:06:34 <gio123>  gsv49w32.exe
03:06:38 <gio123> error
03:06:41 <cnwdup> good morning
03:06:43 <gio123> to download instalational file
03:06:49 <quicksilver> ghostscript is essentially the only free postcript interpreter.
03:07:02 <quicksilver> although there are a couple of frontends they all use it afaik.
03:07:04 <sjanssen> quicksilver: yes, I suppose that is true
03:07:29 <gio123> but i cant download it
03:07:44 <quicksilver> sjanssen: but I would not personally be too worried about O(1) amounts of blocking :)
03:07:55 <quicksilver> sjanssen: obviously it depends on volume and scaling and so on.
03:08:02 <quicksilver> but it would work quite well within limits.
03:08:13 <gio123> can somebody check whether link is working?
03:08:20 <sjanssen> quicksilver: O(1) amounts of blocking?  In proportion to what?
03:09:20 <BeelsebobWork> @src Data.Traversable.mapM
03:09:21 <rahaskella> Source not found. My brain just exploded
03:09:29 <BeelsebobWork> @src mapM
03:09:30 <rahaskella> mapM f as = sequence (map f as)
03:09:56 <quicksilver> sjanssen: the queue size.
03:10:10 <quicksilver> sjanssen: I just mean that cons and uncons are pretty fast for seqs.
03:10:29 <gio123> can somebody give me another link to obtain ghoscript?
03:10:34 <sjanssen> actually, how would this actually work?  How does one block when there are no elements in the queue?
03:10:59 <EvilTerran> gio123, you could try asking in #ghostscript, if you're trying to install their software
03:13:05 <quicksilver> sjanssen: hmm, good question. It may be you need an MVar () too.
03:13:10 <quicksilver> sjanssen: I didn't think it through :)
03:14:28 <sjanssen> anyway, the current implementation rocks
03:27:42 <araujo> morning
03:54:54 <ndm> @seen Igloo
03:54:55 <rahaskella> Igloo is in #haskell. I don't know when Igloo last spoke.
03:55:32 <ndm> Igloo: i want a flag in GHC that does both -hidir and -odir - think of it as -crapdir (where to put the crap i really don't care about)
03:55:32 <rahaskella> ndm: You have 1 new message. '/msg rahaskella @messages' to read it.
03:55:36 <ndm> @messages
03:55:36 <rahaskella> dcoutts said 13h 16m 58s ago: the captcha on your blog is borked, the picture does not appear, it's a 404 link.
03:55:49 <dcoutts> @arr!
03:55:50 <rahaskella> Aye
03:55:51 <ndm> dcoutts, doh - a google thing though, i think
03:56:01 <ndm> not sure if i can do anything about it...
03:56:09 <ndm> blogger is rather bad, it must be said
03:56:11 <Igloo> ndm: Can you file a feature request please?
03:56:32 <mbz> hiya
03:56:35 <ndm> Igloo: i was asking you first, as the Linuxy person, if it is common in linux to have such a flag, or what it might be called
03:56:52 <ndm> before making a feature request with no unix knowledge :)
03:57:11 <Igloo> I can't think of anything similar OTTOMH
03:57:19 <ndm> ok, will file away
03:57:26 <Igloo> -ohidir is one option that springs to mind
03:57:50 <dcoutts> Igloo: oh, I'd like advice on http://hackage.haskell.org/trac/hackage/ticket/280
03:57:52 <Igloo> although a more general name would be better...but I can't think of a good one
03:58:38 <dcoutts> Igloo: do you think ghc should look in the -i dirs for .hs-boot files or should it look only in the dir where the .hs file was found.
03:58:39 <Igloo> dcoutts: what sort of advice?
03:59:04 <Igloo> Ah...this is ghc --make, right?
03:59:15 <dcoutts> Igloo: ie should I file a ghc feature request or try and make cabal copy .hs-boot files for all pre-processors that generate .hs files
03:59:19 <quicksilver> ndm: personally I'd kind of expect -odir to do boht.
03:59:25 <quicksilver> ndm: I think of them both as object files.
03:59:33 <quicksilver> ndm: obviously that's not qwr uite what the GHC team though :)
03:59:55 <ndm> quicksilver: i kind of agree
04:00:03 <Igloo> dcoutts: It sounds reasonable to me that the .hs-boot should need to be in the same place as the .hs; after all, you really do need the actual same module
04:00:28 <dcoutts> Igloo: yeah, it's ghc --make, we have dist/build/ with generated .hs files and users obviously put their .hs-boot files in src/ whatever
04:01:31 <Igloo> dcoutts: I think you should copy all sources into dist/ anyway, to minimise the chances of any implementation leaving droppings in .
04:03:33 <dcoutts> Igloo: mm, I don't really like the idea, not sure exactly why
04:03:46 <dcoutts> Igloo: I think we can avoid droppings in . anyway
04:04:03 <mm_freak_work> hi people…  i'm trying to write an RC4 implementation (again), this time using mutable array, but what should my 'RC4' type look like?  should it contain an immutable array?
04:06:26 <mm_freak_work> or in other words, should i use an immutable array for holding the data, and use a mutable array only for modifying it?
04:07:17 <Eelis> Igloo: what are the prospects for http://hackage.haskell.org/trac/ghc/ticket/2038 ?
04:08:05 <Igloo> Eelis: We intend to fix it
04:08:12 <Eelis> Igloo: great :) thanks.
04:14:25 <mbz> what is the right way for swapping arguments? g f a b = f b a?
04:14:38 <Botje> yup
04:14:43 <Botje> @src flip
04:14:44 <rahaskella> flip f x y = f y x
04:14:50 <mbz> thanks
04:15:26 <vixey> yugk
04:15:32 <vixey> I really detest that
04:15:32 <trez> @src (.)
04:15:33 <rahaskella> (f . g) x = f (g x)
04:15:40 <vixey> flip f y x = f x y -- better definition
04:18:15 <mbz> is there an arrow for doing something like flip?
04:18:52 <mbz> I'm learning haskell now.. so sorry for dummy questions
04:20:10 <vixey> :t swap
04:20:16 <rahaskella> Not in scope: `swap'
04:23:23 <mauke> :t snd &&& fst
04:23:27 <rahaskella> forall a b. (a, b) -> (b, a)
04:23:31 <vixey> 7HEorETi(alLY It w0u|d wORx uSiNg naN0b0T5
04:23:39 <xerox> ?type (. curry (snd &&& fst)) . ((.) . uncurry)
04:23:42 <rahaskella> forall a b c. (a -> b -> c) -> b -> a -> c
04:23:48 <xerox> more or less.
04:26:40 <mauke> :t ap ((.) . ap) (const const)
04:26:43 <rahaskella> forall b a b1. (b1 -> a -> b) -> a -> b1 -> b
04:27:19 <vixey> :t ((.) . ap)
04:27:23 <rahaskella> forall (f :: * -> *) (m :: * -> *) a b. (Monad m, Functor f) => m (a -> b) -> f (m a) -> f (m b)
04:27:43 <vixey> how on earth ...
04:28:04 <vixey> :t (const const)
04:28:07 <rahaskella> forall a b b1. b1 -> a -> b -> a
04:28:46 <mauke> it's just standard abstraction elimination
04:30:14 <trez> @pl \x -> x + 1
04:30:15 <rahaskella> (1 +)
05:16:02 <boegel> did lambdabot die?
05:16:07 <boegel> @messages?
05:16:07 <rahaskella> Sorry, no messages today.
05:17:09 <mauke> preflex: seen lambdabot
05:17:09 <preflex>  lambdabot was last seen on #haskell 1 day, 12 hours, 27 minutes and 20 seconds ago, saying: forall (m :: * -> *) a. (Monad m) => String -> m a
05:17:29 <ehird> preflex: seen preflex
05:17:29 <preflex>  Sorry, I haven't seen preflex
05:17:41 <ehird> preflex: seen ehird
05:17:41 <preflex>  ehird was last seen on #haskell 3 seconds ago, saying: preflex: seen preflex
05:17:41 <ehird> hah
05:17:43 <ehird> preflex: be poppavic
05:17:43 <preflex>  as a virgin, it's better to learn the C concept of true/false - and see the libc interfaces for pass/fail, true/false - and wonder "why?"
05:18:00 <ehird> mauke: i don't believe that those are unmodified quotes
05:18:03 <ehird> my brain rejects it
05:18:09 <mauke> they are :|
05:18:43 <ehird> mauke: he has op on ##c, doesn't he? how on earth?
05:18:45 <mauke> ok, I chopped off "nick: ", but otherwise it's straight copy/paste
05:18:50 <mauke> no
05:19:04 <ehird> mauke: ok, then why is he still there? :P
05:19:17 <mauke> uncaring ops
05:19:49 <ehird> -preflex- if I get the chance to shit on yer nose, will you tolerate the procedure or react? Wwhen do you react? why? whose "timeslice"?
05:19:57 * ehird shits on someone's nose
05:21:33 <Philippa> ehird: wow, I didn't realise you were quite that flexible - want something to help clean that off yourself?
05:22:11 <mauke> autokopromorphism
05:22:36 <ehird`> Philippa: haha
05:25:25 <mauke> http://blogs.microsoft.co.il/blogs/tamir/archive/2008/04/28/computer-languages-and-facial-hair-take-two.aspx
05:28:36 <boegel> mauke: yeah, probably the best blog post ever :)
05:31:07 <ehird{> preflex: be ehird
05:31:07 <preflex>  no quotes found for ehird
05:31:10 <ehird{> :(
05:31:13 <ehird{> preflex: be prefkex
05:31:13 <preflex>  no quotes found for prefkex
05:31:19 <ehird{> preflex: be preflex
05:31:19 <preflex>  no quotes found for preflex
05:31:21 <ehird{> bh
05:31:22 <ehird{> *bah
05:32:34 <boegel> preflex: be boegel
05:32:34 <preflex>  no quotes found for boegel
05:32:44 <boegel> preflex: you suck
05:32:53 <boegel> yeah, shut up and take it in!
05:33:36 <ehird{> preflex: list
05:33:36 <preflex>  Cdecl: [cdecl]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma]; Nickometer: [nickometer]; Seen: [seen]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]
05:33:45 <ehird{> -- preflex
05:33:50 <ehird{> preflex: -- preflex
05:33:56 <ehird{> Lame.
05:33:59 <ehird{> preflex: preflex--
05:34:04 <ehird{> preflex-
05:34:06 <ehird{> er
05:34:06 <ehird{> preflex--
05:34:12 <ehird{> preflex: karma preflex
05:34:12 <preflex>  karma for preflex: -33
05:34:17 <ehird{> ... hah
05:50:39 <ddarius> preflex: help cdecl
05:50:39 <preflex>  cdecl DECLARATION - explain a C declaration
05:50:46 <litb> > foldl (+) x [1, 2, 3, 4, 5]
05:50:50 <rahaskella>  x + 1 + 2 + 3 + 4 + 5
05:51:02 <litb> oh hello all
05:51:07 <litb> rahaskella: u a bot?
05:51:18 <litb> how can i see the (   ) ?
05:51:22 <litb> > foldr (+) x [1, 2, 3, 4, 5]
05:51:26 <rahaskella>  1 + (2 + (3 + (4 + (5 + x))))
05:51:30 <litb> oh i see
05:52:11 <litb> > foldl (+) 5 [1, 2, 3, 4, 5]
05:52:15 <rahaskella>  20
05:52:37 <litb> how  can i explicitely show the ( with it?
05:53:08 <dcoutts_> > foldl (+) 5 [1, 2, 3, 4, 5] :: Exp
05:53:10 <rahaskella>   Not in scope: type constructor or class `Exp'
05:53:15 <ddarius> You can't.
05:53:18 <dcoutts_> bah
05:53:26 <ari> What the
05:53:32 <dcoutts_> I thought someone added something like that
05:53:36 <ddarius> Expr
05:53:39 <ari> > x + y
05:53:39 <dcoutts_> > foldl (+) 5 [1, 2, 3, 4, 5] :: Expr
05:53:42 <rahaskella>  x + y
05:53:42 <rahaskella>  5 + 1 + 2 + 3 + 4 + 5
05:53:45 <ari> How does *that* work?
05:53:53 <dcoutts_> magic typeclasses :-)
05:54:01 <ari> :o
05:54:22 <ddarius> Another instance of Num that doesn't satisfy the expected laws.
05:54:53 <dcoutts_> ari: Expr is made an instance of various classes like Num and it's Show instance prints the expression structure
05:54:59 <matthew_-> why is there no Enum instance though?
05:55:05 <matthew_-> > [a .. d]
05:55:07 <rahaskella>  Exception: not a number
05:55:17 <ddarius> matthew_-: Because you haven't written one yet and it would be hard to stop...
05:55:23 * matthew_- salutes rahaskella 
05:55:42 <ddarius> > [a..]
05:55:43 <rahaskella>  [Exception: not a number
05:55:47 <ddarius> > succ a
05:55:49 <rahaskella>  succ a
05:55:53 <ddarius> There you go.
05:55:53 <matthew_-> ahh!
05:56:06 <ddarius> > maxBound :: Expr
05:56:08 <rahaskella>  maxBound
05:56:10 <Apocalisp> bah, go succ an a!
05:56:22 * ari is suitably impressed
05:57:00 <ddarius> > toConstr a
05:57:01 <rahaskella>   Not in scope: `toConstr'
05:57:10 <ddarius> > Data.Generics.toConstr a
05:57:12 <rahaskella>  Expr
05:57:29 <ddarius> Wrong one.
05:58:47 <Apocalisp> Wait, who's rahaskella?
05:59:39 <ddarius> > Data.Generics.dataTypeOf a
05:59:42 <rahaskella>  DataType {tycon = "SimpleReflect.Expr", datarep = AlgRep [Expr]}
06:00:21 <ddarius> > Data.Generics.dataTypeOf (Just 3)
06:00:23 <rahaskella>  DataType {tycon = "Prelude.Maybe", datarep = AlgRep [Nothing,Just]}
06:00:40 <ddarius> :t Expr
06:00:42 <rahaskella> Not in scope: data constructor `Expr'
06:00:50 <ddarius> :t SimpleReflect.Expr
06:00:55 <rahaskella>     Not in scope: data constructor `SimpleReflect.Expr'
06:02:45 <ari> Apocalisp: lambdabot went down and Cale doesn't have access to his account on code.haskell.org due to the Debian SSH debacle... I happened to have rahaskella running so I brought it in to tide us over
06:02:53 <ehird{> :t f
06:02:57 <rahaskella> forall a. (SimpleReflect.FromExpr a) => a
06:03:04 <ehird{> :t x
06:03:08 <rahaskella> Expr
06:03:12 <ehird{> Huh.
06:04:29 <ddarius> > gshow (a + b)
06:04:31 <rahaskella>   Not in scope: `gshow'
06:04:36 <ddarius> > Data.Generics.Text.gshow (a + b)
06:04:37 <rahaskella>   Not in scope: `Data.Generics.Text.gshow'
06:04:49 <ddarius> > Data.Generics.gshow (a + b)
06:04:51 <rahaskella>  "(Expr (Exception: toConstr
06:04:52 <litb> hm, we're looking at grammars now
06:05:04 <litb> associativity stuff oO
06:06:11 <litb> oh neat ari
06:08:19 <matthew_-> hmm. We actually want to do TH style splicing, but inverted, to force Expr to be eval'd in certain cases
06:08:57 <litb> hmm
06:09:01 <matthew_-> like > 2 + [| 3 * 4 |] ==> 2 + 12
06:09:23 <ddarius> matthew_-: All you'd need to do is implement a "simplify" or "evaluate" function for it.
06:09:31 <matthew_-> so then > [| succ a |] ==> b
06:09:44 * matthew_- ducks
06:09:52 <Saizan> Expr ~ Expr -> String or similar iirc
06:10:35 <litb> you guyz are crazy oO
06:11:18 <litb> please someone show off some cool haskell stuff now oO
06:11:25 * matthew_- unzips
06:11:29 <litb> lolz
06:11:45 <litb> unzip your codebin
06:12:27 <ehird{> You know what I want. I want an implementation of dependent types in hs.
06:12:45 <matthew_-> yeah, I'll second that
06:12:55 <ToRA> > 2 + (fromIntegral $ (3 * 4) :: Int) :: Expr
06:12:56 <rahaskella>  Couldn't match expected type `Expr' against inferred type `Int'
06:13:08 <ToRA> > 2 + (fromIntegral $ ((3 * 4) :: Int)) :: Expr
06:13:09 <rahaskella>  2 + 12
06:13:21 <matthew_-> ok, so now get the second one to work
06:13:26 <matthew_-> I want succ a to give b
06:13:37 <matthew_-> but only if b is free
06:14:31 <ToRA> > succ 'a'
06:14:34 <rahaskella>  'b'
06:14:39 <litb> > pred 'b'
06:14:41 <rahaskella>  'a'
06:14:47 <ToRA> magic quasi-quoting ;)
06:14:56 <litb> uh
06:14:58 * matthew_- wishes he was op-able
06:15:10 <litb> oO
06:15:14 <litb> gimme op plz
06:15:22 <orbitz> goood morning vietskell
06:15:23 <osfameron> 1 `litb` 2
06:15:31 <BeelsebobWork> Hmm, I was under the impression that ghc had unicode support now, am I mistaken?
06:16:23 <ToRA> BeelsebobWork: no, it does.  Source language can be in full utf8.  If you turn on -XUnicode you can use → and a few other things instead of the normal syntax connectives
06:16:35 <ToRA> (sadly λ is a variable and not a replacement for \)
06:16:39 <orbitz> is that fround upon?
06:16:49 <orbitz> frowned
06:16:52 <BeelsebobWork> does Char remain an 8-bit char even after that?
06:16:53 <orbitz> source code in unicode scares me
06:17:02 <ToRA> Char isn't an 8 bit char
06:17:06 <ToRA> haskell is not java
06:17:17 <ToRA> hmm
06:17:25 <mar77a> java? more like C
06:17:25 <ToRA> wrong choice of second language
06:17:26 <matthew_-> thanks for clearing that up there, ToRA
06:17:32 <BeelsebobWork> so why after turning on Unicode, do strings containing μ have all the μs replaced with ??
06:17:42 <ToRA> eh?
06:17:43 <matthew_-> because Show sucks
06:17:54 <matthew_-> and doesn't necessarily understand that your output terminal is UTF-8
06:17:58 <ToRA> oh, the stdlib don't have good output routines
06:18:04 <BeelsebobWork> matthew_-: nothing's going through Show
06:18:20 <BeelsebobWork> putStrLn "μ" results in "?" being printed
06:18:25 <matthew_-> ok, I may be blaming the wrong thing, but the reason is correct
06:18:29 <litb> what was the zipWith trickery with the fibonacci numbers again?
06:18:44 <BeelsebobWork> is there any way to get round this and actually get unicode output?
06:18:49 <ToRA> you need to grab utf8-string from hackage
06:19:03 <dcoutts_> BeelsebobWork: you can convert into the encoding your terminal expects
06:19:06 <matthew_-> or any of the three or so packages that provide the same functionality
06:19:09 <ToRA> and use http://hackage.haskell.org/packages/archive/utf8-string/0.3.1/doc/html/System-IO-UTF8.html
06:19:17 <BeelsebobWork> dcoutts_: my terminal expects UTF-8
06:19:30 <BeelsebobWork> which I was under the impression was what ghc-produced binaries output into
06:19:32 <matthew_-> dcoutts_: is it utf-16 internally which is being output?
06:19:39 <orbitz> can anyone get into hackage or does it require a certain level of conformance?
06:19:48 <dcoutts_> BeelsebobWork: and currently putStr and all the other IO assume the encoding is latin1
06:19:55 <BeelsebobWork> dcoutts_: ah, okay
06:19:57 <matthew_-> orbitz: the clue's in the name. ;)
06:20:05 <matthew_-> orbitz: i.e. anyone can get in
06:20:12 <matthew_-> but you have to have an account
06:20:29 <sclv> oh, and it needs to have a well-formed cabal file
06:20:43 <matthew_-> dcoutts_: latin1? So what format are unicode chars held, internally?
06:20:59 <orbitz> matthew_-: is that good or bad?
06:21:05 <dcoutts_> matthew_-: a Char is a Unicode code point
06:21:21 <matthew_-> ahh. ok.
06:21:23 <litb> > let fib n = zipWith (+) n (tail n) in fib [1..]
06:21:26 <rahaskella>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
06:21:36 <matthew_-> orbitz: depends on who you ask
06:21:42 <litb> hm
06:21:51 <Japsu> @oeis 3 5 7 9
06:21:51 <rahaskella> The odd numbers: a(n) = 2n+1.
06:21:51 <rahaskella> [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
06:21:55 <Japsu> oops
06:21:57 <Japsu> nvm
06:22:09 <litb> lol
06:22:20 <litb> i wanted to generate the fib numbers
06:22:22 <litb> but i failed :D
06:22:38 <Japsu> I also failed.
06:22:40 <Japsu> ;D
06:22:58 <profmakx> @oeis  1 1 2 3 5 8
06:22:59 <rahaskella> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
06:22:59 <rahaskella> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
06:23:03 <mm_freak_work> > let fib = unfoldr (\(a,b) -> Just (a, (b, a+b))) (0,1) in fib
06:23:05 <rahaskella>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
06:23:08 <mar77a> > 0 ** 0
06:23:11 <rahaskella>  1.0
06:23:12 <litb> lol
06:23:15 <mar77a> WHAT
06:23:17 <ToRA> > fix ((1:) . (1:) . zipWith (+) `ap` tail)
06:23:19 <rahaskella>      precedence parsing error
06:23:19 <rahaskella>         cannot mix `(.)' [infixr 9] and `ap' [i...
06:23:25 <ToRA> > fix ((1:) . (1:) . (zipWith (+) `ap` tail))
06:23:26 <mar77a> i thought haskell had a mathematical approach :(
06:23:27 <rahaskella>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
06:23:29 <profmakx> i like the ziWith version better
06:23:39 <Japsu> > let fibs = zipWith (+) [1..] (tail fibs) in take 20 fibs
06:23:54 <rahaskella>  thread killed
06:24:05 <profmakx> O.o
06:24:06 <Japsu> hmm
06:24:13 <Deewiant> you need at least two values
06:24:18 <Deewiant> oh, right, wait
06:24:20 <Japsu> > let fibs = zipWith (+) 1:[1..] (tail fibs) in take 20 fibs
06:24:22 <rahaskella>  Couldn't match expected type `t -> [[a] -> [a]]'
06:24:22 <boegel> Japsu: you killed at treat, nice!
06:24:27 <boegel> oh, wait...
06:24:28 <Deewiant> no, you need two values
06:24:28 <boegel> :P
06:24:28 <Japsu> > let fibs = zipWith (+) (1:[1..]) (tail fibs) in take 20 fibs
06:24:33 <Deewiant> so that the tail gives something
06:24:34 <litb> oO
06:24:34 <tromp> > let f = 0:scanl(+)1 f in f
06:24:36 <rahaskella>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
06:24:42 <Japsu> bah
06:24:44 <rahaskella>  thread killed
06:24:45 <ari> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
06:24:45 <rahaskella>  Parse error at end of input
06:24:45 <Japsu> scanl
06:24:48 <ari> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
06:24:49 <Deewiant> Japsu: it can't evaluate the tail until it's evaluated both arguments of the zipWith at least a bit
06:24:50 <rahaskella>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
06:25:04 <Japsu> that's what I was golfing for
06:25:06 <Deewiant> so you need to give an initial cell as above.
06:25:13 <litb> oh i see Deewiant
06:25:20 <litb> yeah that makes much sense
06:25:28 <mm_freak_work> > filter (\n -> null . filter ((== 0) . rem n)) [2..]
06:25:31 <rahaskella>  Couldn't match expected type `Bool'
06:25:47 <mm_freak_work> > filter (\n -> null . filter ((== 0) . rem n) [2..n-1]) [2..]
06:25:48 <rahaskella>  Couldn't match expected type `Bool' against inferred type `[Bool]'
06:25:48 <Deewiant> @pl fibs = 0:1:zipWith (+) fibs (tail fibs)
06:25:49 <rahaskella> fibs = fix ((0 :) . (1 :) . ap (zipWith (+)) tail)
06:25:56 <mm_freak_work> > filter (\n -> null . filter ((== 0) . rem n) $ [2..n-1]) [2..]
06:25:59 <rahaskella>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
06:26:03 <litb> this is brainfucking lol
06:26:38 <litb> oh what numbers are that mm_freak_work ?
06:26:55 <mm_freak_work> @oeis 2 3 5 7 11 13
06:26:55 <rahaskella> The prime numbers.
06:26:55 <rahaskella> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,1...
06:26:59 <ehird{> <litb> this is brainfucking lol
06:27:00 <ehird{> no
06:27:02 <ehird{> this is brainfucking:
06:27:07 <ehird{> ... meh, too lazy to code one up
06:27:19 <ehird{> hi Deewiant!
06:27:23 <litb> oh i see rahaskella
06:27:32 <litb> damit i'm dumb
06:27:49 <mbz> ehird{: mmm, don't be lazy
06:27:59 <litb> ehird{: yeah code one up plz :D
06:28:15 <ari> (@bf doesn't work on rahaskella due to http://hackage.haskell.org/trac/ghc/ticket/2038 )
06:28:17 <ehird{> brainfuck is trivial
06:28:18 <ehird{> :-P
06:28:52 <litb> what is this algorithm called again where you can check whether a number is prime or not fully deterministical and polymonially ?
06:28:56 <litb> AKS or something.. i believe
06:29:11 <litb> is it easy to code in haskell?
06:29:55 <mm_freak_work> > [ x | x <- [2..], null [ y | y <- [2..x-1], rem x y == 0 ] ]
06:29:57 <rahaskella>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
06:30:24 <litb> mm_freak_work: is that the one?
06:30:25 <mm_freak_work> litb: AKS is one
06:30:27 <litb> great
06:30:29 <litb> oh i see
06:30:30 <mm_freak_work> ECPP is another one
06:30:40 <litb> is ECPP better?
06:31:04 <mm_freak_work> and if the generalized riemann hypothesis is true, then miller-rabin can be turned into one, too
06:31:12 <mm_freak_work> i don't know…  haven't benchmarked
06:31:37 <mm_freak_work> i like the lucas-lehmer test for mersenne numbers =)
06:31:47 <litb> oh
06:31:52 <litb> i dunno about most of them i'm afraid
06:31:58 <mm_freak_work> you can implement it very beautifully in haskell
06:32:07 <litb> mm_freak_work: oh can you show it?
06:32:18 <mm_freak_work> uhm, gimme a second
06:32:26 <litb> =)
06:34:11 <ivanm> is there any particular reason that its now more than 24 hrs since lambdabot graced this channel?
06:34:18 <roderyk> Looking to kill some time at work? My first attempt with gtk2hs, comments and criticisms most welcome :)  http://pithyless.com/blog/2008/05/18/hback-haskell-n-back-memory-game/
06:34:21 <ehird{> ivanm: crashed
06:34:25 <ehird{> cale can't login to code.h.o
06:34:30 <ehird{> rahaskella is a \bot
06:34:31 <ivanm> :o
06:34:45 <ivanm> who's bot?
06:34:51 <Deewiant> @bot
06:34:51 <rahaskella> :)
06:34:52 <ehird{> ivanm: avis
06:35:19 <litb> lol
06:35:19 <ivanm> next question... who's avis? :p
06:35:20 <litb> @bot
06:35:21 <rahaskella> :)
06:35:22 <ehird{> avi
06:35:23 <ivanm> don't recognise the nick
06:35:25 <ehird{> avi: you are avi
06:35:31 <litb> @bot
06:35:31 <rahaskella> :)
06:35:32 <ehird{> er
06:35:32 <ehird{> ari
06:35:41 <ehird{> > drop 1 [1,2,3,4]
06:35:42 <ivanm> ari /= avi /= avis :p
06:35:42 <rahaskella>  [2,3,4]
06:35:45 <mm_freak_work> > let lucasLehmer p = llSeq (2^p - 1) !! (p-2) == 0  where llSeq n = unfoldr (\x -> Just (x, mod (x^2 - 2) n)) 4
06:35:46 <rahaskella>  Parse error at end of input
06:35:46 <ehird{> bleh
06:35:51 <ehird{> ??? 1 [1,2,3,4] => [1,2,3]?
06:35:54 <ivanm> avis is a rental car company, IIRC... :p
06:36:06 <ehird{> fill for ??
06:36:19 <mm_freak_work> > let llSeq n = unfoldr (\x -> Just (x, mod (x^2 - 2) n)) 4; lucasLehmer p = llSeq (2^p - 1) !! (p-2) == 0
06:36:19 <rahaskella>  Parse error at end of input
06:36:30 <xerox> :t iterate last
06:36:31 <mm_freak_work> > let llSeq n = unfoldr (\x -> Just (x, mod (x^2 - 2) n)) 4; lucasLehmer p = llSeq (2^p - 1) !! (p-2) == 0 in lucasLehmer 7
06:36:35 <rahaskella>  True
06:36:35 <rahaskella>     Occurs check: cannot construct the infinite type: a = [a]
06:36:35 <rahaskella>       Expected type: [a] -> [a]
06:36:35 <rahaskella>       Inferred type: [a] -> a
06:36:50 <BMeph> litb: Wikipedia (en) has a good article on it: http://en.wikipedia.org/wiki/Lucas%E2%80%93Lehmer_test_for_Mersenne_numbers
06:36:57 <mm_freak_work> > let llSeq n = unfoldr (\x -> Just (x, mod (x^2 - 2) n)) 4; lucasLehmer p = llSeq (2^p - 1) !! (p-2) == 0 in lucasLehmer 11
06:36:59 <rahaskella>  False
06:37:11 <xerox> :t \n -> (!!n) . iterate init
06:37:15 <rahaskella> forall a. Int -> [a] -> [a]
06:37:37 <mm_freak_work> oh, litb is already gone
06:37:39 <Deewiant> inits !! n?
06:38:03 <xerox> right, bad function though.
06:38:25 <BMeph> Bad function! No run-time! ;p
06:38:28 <ehird{> anyone?
06:40:07 <Deewiant> ehird{: (\n -> reverse . drop n . reverse)
06:40:16 <Deewiant> ... I think
06:40:30 <ehird{> > let zock n = reverse . drop n . reverse in zock 1 [1,2,3]
06:40:32 <rahaskella>  [1,2]
06:40:36 <ehird{> > let zock n = reverse . drop n . reverse in zock 2 [1,2,3]
06:40:38 <rahaskella>  [1]
06:40:39 <ehird{> Yep.
06:40:52 <BMeph> Yeah - I call it "chop".
06:40:56 <Deewiant> alternately, (\n s -> take (length s - n) s)
06:41:07 <Deewiant> which might be faster
06:41:10 <Deewiant> or more lazy
06:41:10 <BMeph> And of course, "genericChop" for the more general form. ;p
06:41:11 <Deewiant> or something
06:41:34 <kristofer> morning!
06:41:37 <ehird{> > product
06:41:39 <rahaskella>  <[Integer] -> Integer>
06:41:47 <ehird{> > let chop n = reverse . drop n . reverse; facts = 1 : 1 : factsOn facts; factsOn xs = product xs : factsOn xs in facts
06:41:49 <rahaskella>  [1,1,Exception: stack overflow
06:41:52 <ehird{> knew it
06:41:55 <ehird{> hrmmm
06:42:01 <ehird{> > let chop n = reverse . drop n . reverse; facts = 1 : 1 : factsOn facts; factsOn xs = product (chop 1 xs) : factsOn xs in facts
06:42:08 <rahaskella>  [1,1,Exception: Time limit exceeded
06:42:13 <ehird{> humph
06:42:18 <Deewiant> heh
06:43:21 <ehird{> Deewiant: I just want a facts like fibs. :P
06:43:48 <Deewiant> > scanr1 (*) [1..]
06:43:54 <rahaskella>  [Exception: stack overflow
06:43:56 <Deewiant> > scanl1 (*) [1..]
06:43:58 <rahaskella>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
06:44:26 <Deewiant> ehird{: that'll have to do. :-P
06:44:50 <ehird{> Deewiant: Bah.
06:45:11 <ehird{> > scanl1 (*) [1..] !! 1000
06:45:13 <rahaskella>  4027896473371708673172461363569269897050942390749253471763437103403684509110...
06:46:52 <ehird{> > scanl1 (*) [1..] !! 10000
06:46:55 <rahaskella>  2846544306885146224358303853441080877037066206842969510717259412273838781137...
06:47:00 <ehird{> Impressive.
06:47:01 <ehird{> > scanl1 (*) [1..] !! 100000
06:47:09 <rahaskella> Terminated
06:47:32 <Deewiant> > length . show $ scanl1 (*) [1..] !! 10000
06:47:34 <rahaskella>  35664
06:47:47 <ehird{> > length . show $ scanl1 (*) [1..] !! 100000
06:47:55 <rahaskella> Terminated
06:49:13 <Deewiant> > length . show $ scanl1 (*) [1..] !! 10001
06:49:15 <rahaskella>  35668
06:49:24 <ehird{> > length . show $ scanl1 (*) [1..] !! 10002
06:49:26 <rahaskella>  35672
06:49:32 <ehird{> Cool! A pattern
06:49:36 <Deewiant> heh
06:50:04 * matthew_- wonders how many hard discs he is about to purge
06:51:28 <mm_freak_work> foldl (*) [1..100000]
06:51:31 <mm_freak_work> > foldl (*) [1..100000]
06:51:32 <rahaskella>   add an instance declaration for (Num [t])
06:51:34 <mm_freak_work> > foldl (*) 1 [1..100000]
06:51:41 <rahaskella> Terminated
06:52:01 <Deewiant> > foldl' (*) 1 [1..100000]
06:52:09 <rahaskella> Terminated
06:52:21 <ehird{> um
06:52:24 <ehird{> foldl (*) = product
06:52:26 <ehird{> err
06:52:29 <ehird{> foldl (*) 1 = product
06:52:33 <Deewiant> quite
06:52:34 <ehird{> so... that's just standard fact
06:52:34 <ehird{> :D
06:53:23 <mm_freak_work> main = print $ product [1..100000]
06:53:28 <mm_freak_work> takes 7 seconds here
06:53:55 <mm_freak_work> and it will run a little faster for [2..100000] =)
06:55:27 <Deewiant> not much, though :-P
06:57:17 <mm_freak_work> hehe yeah, but i'm a former C and assembler programmer =P
06:59:35 <Arnar> @djinn a -> (b,c) -> (a,b,c)
06:59:35 <rahaskella> f a (b, c) = (a, b, c)
07:00:33 <PeakerWork> given a list of keys and a map, how do I generate a new map without those keys?
07:00:36 <trontonic> the #pypy channel has a bot that informs people about commits, is that an idea for rahaskella as well?
07:01:19 <Zao> trontonic: Just track cvs-ghc?
07:02:17 <SamB> mm_freak: so since when does skipping the cheapest of 100000 iterations ever buy you anything?
07:03:04 <matthew_-> 1956
07:03:28 <matthew_-> when it gained you the same as the price of a Wall's Ice Cream
07:03:42 <ari> @type foldr Data.Map.delete
07:03:45 <rahaskella> forall a a1. (Ord a) => M.Map a a1 -> [a] -> M.Map a a1
07:03:49 <lilac> PeakerWork: how performant do you want it?
07:04:14 <lilac> @type Data.Map.filter (notElem [1..5])
07:04:15 <Arnar> @hoogle uncurry3
07:04:17 <rahaskella> forall t k. (Ord k, Enum t, Num t) => M.Map k [[t]] -> M.Map k [[t]]
07:04:18 <rahaskella> No matches found
07:04:30 <Arnar> @hoogle (a -> b -> c -> d) -> (a,b,c) -> d
07:04:32 <rahaskella> No matches, try a more general search
07:04:43 <Arnar> @djinn (a -> b -> c -> d) -> (a,b,c) -> d
07:04:43 <rahaskella> f a (b, c, d) = a b c d
07:04:45 <lilac> @type Data.Map.filterWithKey (\k v -> k `notElem` [1..5])
07:04:49 <rahaskella> forall k a. (Ord k, Enum k, Num k) => M.Map k a -> M.Map k a
07:05:28 <PeakerWork> lilac, I want to filter by keys, not by value
07:05:38 <lilac> > Data.Map.filterWithKey (\k v -> even k) (Data.Map.fromAscList [(1,'a'),(2,'b'),(3,'c')])
07:05:39 <rahaskella>   Not in scope: `Data.Map.fromAscList'
07:06:05 <lilac> > Data.Map.filterWithKey (\k v -> even k) (Data.Map.fromList [(1,'a'),(2,'b'),(3,'c')])
07:06:06 <rahaskella>   Not in scope: `Data.Map.fromList'
07:06:14 <ari> Maybe foldl' (flip Data.Map.delete)? AFAICT you'd want this to be strict...
07:06:16 <PeakerWork> is pasting 3 lines ok?
07:06:43 <ari> PeakerWork: If you aren't sure, use hpaste
07:06:44 <lilac> PeakerWork: filterWithKey would be simplest, i think
07:07:21 <PeakerWork> http://hpaste.org/7748 <- anything prettier than this?
07:08:01 <PeakerWork> (well, making the types generic, ofcourse :-)
07:09:16 <mm_freak_work> SamB: that was a joke ;)
07:11:33 <PeakerWork> Map's alter :: (Ord k) => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
07:11:45 <PeakerWork> was about to ask a question but now I understand :)
07:18:14 <PeakerWork> How would one use assertions in a lazy language like Haskell?
07:18:18 <PeakerWork> for example, I want to have something like Map's insert but that asserts that the key wasn't already in there
07:18:27 <PeakerWork> but why would my assertion be evaluated?
07:19:26 <PeakerWork> I guess I could use:  if (assertion) then error "..." else real-code
07:20:07 <Arnar> should I use Data.List.isPrefixOf on Strings, or is there something optimized/more efficient?
07:20:15 <Arnar> perhaps it is just taken care of by polymorphism
07:21:21 <TSC> PeakerWork: That is probably the way to do it, and wrap the assertion part in a function
07:21:41 <TSC> So that you can write "assert condition realExpression"
07:21:46 <orbitz> Arnar: String is a list of Char's
07:21:47 <PeakerWork> TSC, thanks
07:22:21 <matthew_-> or just delete from the map before inserting
07:22:35 <Arnar> orbitz: and always represented that way internally?
07:22:56 <orbitz> Arnar: haskell doesn't pull fast ones
07:22:57 <Apocalisp> can you use bytestring?
07:23:19 <Arnar> Apocalisp: I can yes.. but my case is not that critical
07:23:51 <ehird{> sclv: How's that hvac tutorial goin'?
07:24:05 <ehird{> Peaker: here
07:24:11 <ehird{> assert :: Bool -> a -> a
07:24:19 <ehird{> assert c a | c = a
07:24:34 <ehird{>            | otherwise = error "Assertation failed"
07:26:31 <PeakerWork> ehird{, thanks, is that in a stdlib somewhere too, or am I the only one asserting stuff? :)
07:26:38 <Deewiant> @hoogle assert
07:26:38 <rahaskella> Control.Exception.assert :: Bool -> a -> a
07:26:38 <rahaskella> Control.Exception.assertions :: Exception -> Maybe String
07:26:38 <rahaskella> Control.Exception.AssertionFailed :: String -> Exception
07:26:43 <Deewiant> @src assert
07:26:43 <rahaskella> Source not found. My mind is going. I can feel it.
07:26:51 <ehird{> Control.Exception.assert :: Bool -> a -> a
07:26:53 <ehird{> seems about right
07:26:54 <PeakerWork> ah, great
07:26:58 <ehird{> @src Control.Exception.assert
07:26:59 <rahaskella> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:27:14 <ehird{> > Control.Exception.assert False 2
07:27:16 <rahaskella>   Not in scope: `Control.Exception.assert'
07:27:18 <ehird{> :<
07:30:47 <ehird{> @help
07:30:47 <rahaskella> help <command>. Ask for help for <command>. Try 'list' for all commands
07:30:49 <ehird{> @list
07:30:50 <rahaskella> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
07:30:59 <ehird{> request changing it to
07:31:07 <ehird{> help <command>. Ask for help for <command>. help <command>. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS lists the commands.
07:33:11 <bringert> kosmikus: lhs2TeX --newcode seems to replace bird tracks (>) with spaces, which is invalid Haskell
07:33:57 <kosmikus> why's that invalid?
07:36:16 <malcolmw> to quote the H'98 report: "The program text is recovered by taking only those lines beginning with ">", and replacing the leading ">" with a space."
07:36:28 <bringert> oh
07:36:50 <bringert> ah, my problem is that I'm mixing {code} blocks and bird tracks
07:37:14 <bringert> then --newcode will produce mixed indentation for the top-level code
07:37:25 <bringert> kosmikus: sorry about blaming lhs2TeX
07:38:26 <kosmikus> yes, that's true. the both styles don't mix well. you can indent the code in {code} blocks though.
07:39:39 <bringert> kosmikus: oh, right. perhaps that could be noted in section 3 of the lhs2TeX manual, where it says "(Note that lhs2TeX does not care if both styles of a literate program are mixed in one file. In this sense, it is more liberal than Haskell.) "
07:40:13 <kosmikus> bringert: yes, you're probably right.
07:43:33 <mm_freak_work> from the Data.Bits documentation for (bit :: Bits a => Int -> a): bit i is a value with the ith bit set
07:43:54 <mm_freak_work> does this mean that i can't count on (bit x == 2^x) ?
07:45:05 <Botje> i think you can
07:46:40 <trontonic> Zao: "Just track cvs-ghc?" does not have the social effect that the bot in #pypy has, amongst other things. It's not an answer to my original question/idea-toss.
07:47:45 <xerox> what's a simple way to parallelize a search (filter pred) in a cartesian product of lists [(x,..,z) | x <- xs, ..., z <- zs]?
07:49:24 <xerox> maybe there is some direct translation into parallel arrays?
07:49:34 <matthew_-> xerox: I would suggest using session types, but then I would
07:50:13 <matthew_-> in fact, the Queens.hs example that comes with the session types package contains communication patterns very very similar to what you need
07:52:07 <xerox> hmm
07:52:10 <kosmikus> bringert: changed in the docs in svn
07:52:23 <bringert> kosmikus: great, thanks for your help
07:52:56 <ehird{> trontonic: cia.vc
07:59:20 <ehird{> So.
08:00:16 <qwertyface> Hey, I've got a little problem, that maybe someone could help me with.  Its to do with the derived instance of Ord for a list.
08:00:38 <earthy> hm?
08:00:52 <qwertyface> Code is here: http://hpaste.org/7749
08:01:46 <qwertyface> The problem is this:  I can say "C Ten Spades < C Nine Hearts" in GHCi and it returns True as expected
08:02:03 <ehird{> preflex: be poppa vic
08:02:03 <preflex>  no quotes found for poppa vic
08:02:05 <ehird{> preflex: be poppavic
08:02:05 <preflex>  yer back to the lovely "Mine is bigger than yours" issue, and the idiots still ain't learned a damn thing about shit under shit "underwear"
08:02:18 <qwertyface> But if I say [C Ten Spades] < [C Nine Hearts] I get a stack overflow.
08:02:24 <qwertyface> Any ideas?
08:02:49 <ehird{> qwertyface: Odd
08:02:52 <pjdelport> qwertyface: the way Ord is defined, (<=) is actually the "base" comparison
08:03:05 <pjdelport> you need to define either (<=) or compare
08:03:17 * earthy nods
08:04:03 <qwertyface> pjdelport: And now it works.  Awesome.
08:04:05 <pjdelport> (the default (<=) is defined in terms of compare, and vice versa)
08:04:14 <qwertyface> pjdelport: Thanks very much
08:04:14 <pjdelport> (and the rest all in terms of compare)
08:04:43 <qwertyface> I wonder why it didn't complain that I was defining (<) instead of (<=)
08:04:50 <ehird{> @src Ord
08:04:51 <rahaskella> class  (Eq a) => Ord a  where
08:04:51 <rahaskella>     compare      :: a -> a -> Ordering
08:04:51 <rahaskella>     (<), (<=), (>), (>=) :: a -> a -> Bool
08:04:51 <rahaskella>     max, min         :: a -> a -> a
08:04:54 <pjdelport> it's a bit surprising, yeah
08:04:59 <earthy> *Main> C Ten Spades < C Nine Hearts
08:04:59 <earthy> False
08:05:06 <ehird{> qwertyface: Because all are in there. It should have told you that you didn't provide some stuff, though :|
08:05:26 <ehird{> qwertyface: I would personally define compare. It's cleaner
08:05:30 <pjdelport> ehird{: but that's what inheritance is for :)
08:05:56 <ehird{> pjdelport: :-P
08:06:17 <ehird{> pjdelport: You could implement Eq with compare ... if ghc liked recursive, twisty things like that
08:08:22 <earthy> *Main> [C Nine Spades] < [C Ten Hearts]
08:08:22 <earthy> True
08:08:32 <earthy> just implement compare
08:09:00 <twobitwork> I'm working on a program to help keep inventory of collectable cards... such as Magic: the Gathering, or Baseball cards, etc... and I"m having a hard time figuring out my data model... I want to use hs-plugins to allow for different card types, but I don't know how to make my core stuff flexible enough
08:09:23 <earthy> look at Scrap Your Boilerplate :)
08:09:34 <pjdelport> qwertyface: why are you writing the Ord instance for Card, actually?
08:10:02 <pjdelport> is it specifically so that cards of same value but different suit are equal?
08:11:18 <twobitwork> pjdelport: well... I want a gui which can list the cards in a table with their attributes, but I'm not sure how to make functions which will accept, i.e., tuple with different lengths and types...
08:11:44 <twobitwork> just as one example of where I'm having a hard time wrapping my head about the strict typing model
08:12:24 <shepheb> @brain
08:12:24 <rahaskella> I think so, Brain, but don't you need a swimming pool to play Marco Polo?
08:12:33 <twobitwork> for example, Magic cards have name, color, casting cost, type, text...
08:12:44 <pjdelport> twobitwork: sounds like a type class
08:12:55 <shepheb> can some in control of \bot's sister there get her to /j #xmonad?
08:13:13 <twobitwork> pjdelport: right, but how do I get that info out of a data structure without knowing beforehand what elements it has?
08:13:37 <ehird{> Network.X or Network.Protocols.X?
08:14:53 <BeelsebobWork> gah, what's the unicode extension called again?
08:14:58 <BeelsebobWork> -XUnicode?
08:15:17 <twobitwork> ehird{: talking to me?
08:15:50 <pjdelport> twobitwork: well, each instance of the type class is responsible for providing the implementations
08:16:44 <twobitwork> pjdelport: right, but the gui part should be generic, no? so the gui part would call a method on it, and the method would return what? a tuple wouldn't work because I wouldn't be able to pattern match it unless I know beforehand
08:17:00 <ehird{> twobitsprite: No.
08:17:01 <ehird{> err
08:17:03 <ehird{> twobitwork
08:17:09 <twobitwork> ehird{: ok :)
08:17:14 <ehird{> {: ok :)
08:17:15 <ehird{> cute
08:17:28 <twobitwork> yeah, I just noticed that.... mismatched braces!! :P
08:17:42 <pjdelport> twobitwork: well, the name method would probably return a String, for example
08:18:04 <twobitwork> pjdelport: right... but not all types of cards have say, a casting cost...
08:18:16 <twobitwork> baseball cards sure don't
08:18:17 <pjdelport> subclass :)
08:18:35 <twobitwork> again, how will the generic gui implementation know about it?
08:18:52 <twobitwork> sorry, I'm not trying to be difficult, I'm just honestly trying to figure this out...
08:19:11 <ehird{> @hoogle (@)
08:19:12 <rahaskella> No matches found
08:19:26 <pjdelport> twobitwork: think of Ord
08:19:41 <twobitwork> the class?
08:19:45 <pjdelport> yeah
08:19:51 <twobitwork> @hoogle Ord
08:19:51 <rahaskella> Data.Ord :: module
08:19:52 <rahaskella> Prelude.Ord :: class Eq a => Ord a
08:19:52 <rahaskella> Data.Ord.Ord :: class Eq a => Ord a
08:19:52 <pjdelport> you have the generic Eq class, which only has (==) and (/=)
08:20:06 <twobitwork> right
08:20:15 <pjdelport> and then you have Ord, which adds compare and all the rest
08:20:30 <pjdelport> same with the number hierarchy
08:21:17 <twobitwork> right... so my main code has the GUI code in it... I load a plugin which defines some other class... how does my gui code know about the other methods provided by the class in the plugin?
08:21:19 <pjdelport> so you could start with a most-generic Card class, and then have something like CastableCard
08:21:38 <twobitwork> I want my main code to be agnostic about that stuff
08:21:53 <twobitwork> so as to be as flexible as possible
08:22:17 <pjdelport> okay, so you just want to treat them as arbitrary information fields?
08:22:32 <twobitwork> something like that... for the sake of display yes
08:22:38 <pjdelport> you might just want a Map or something, then
08:22:50 <twobitwork> as in a functor?
08:23:16 <pjdelport> no, just some name/value pairs for various bits of information
08:23:26 <pjdelport> or something along those lines
08:23:40 <twobitwork> a list of pairs you mean? why didn't I think of that? :)
08:23:52 <twobitwork> like an association list
08:24:01 <pjdelport> yeah, that could work :)
08:24:07 <twobitwork> perfect :)
08:24:09 <twobitwork> thanks
08:24:49 <pjdelport> so yeah, that's about the least coupled you can get
08:25:21 <twobitwork> and I just iterate over it and get my field names for the columns in the table
08:25:29 <twobitwork> so simple, can't believe I didn't think of it :)
08:26:04 <ehird{> \
08:26:05 <ehird{> Hmm
08:26:10 <ehird{> Is there a Processing-alike for Haskell?
08:26:14 <ehird{> If not .... :DD
08:27:19 <MarcWeber> Is there a shorter way writing   maybe_file_content <- maybe (return Nothing) ( fmap Just . readFile) (f :: Maybe FilePath)
08:28:21 <saml> do you know when "All about Monads" by Jeff Newbern were written?
08:29:12 <MarcWeber> Something having the type Maybe a -> ( a -> m b) ->  m (Maybe b) ? (read the file if the filename was given else return Nothing) ?
08:29:22 <ehird{> @hoogle Maybe a -> ( a -> m b) ->  m (Maybe b)
08:29:23 <rahaskella> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
08:29:23 <rahaskella> Data.Maybe.maybe :: b -> (a -> b) -> Maybe a -> b
08:29:27 <dolio> @type Data.Traversable.sequence . fmap readFile
08:29:31 <rahaskella> forall (f :: * -> *). (Data.Traversable.Traversable f) => f FilePath -> IO (f String)
08:29:36 <ehird{> MarcWeber: 'maybe'
08:29:45 <ehird{> Well, otnot exactly
08:29:46 <ehird{> but close
08:29:50 <ehird{> oh
08:29:51 <ehird{> wait
08:29:52 <ehird{> that is maybe
08:29:52 <ehird{> hahaha
08:30:16 <MarcWeber> ehird{: I guess you've seemn my implementation using maybe above? How would yours differ?
08:30:17 <dolio> @type Data.Traversable.sequence . fmap readFile :: Maybe FilePath -> IO (Maybe String)
08:30:20 <rahaskella> Maybe FilePath -> IO (Maybe String)
08:30:44 <ehird{> MarcWeber: Hmm
08:30:50 <ehird{> Something with the maybe monad?
08:31:39 <ehird{> PLUGIN Help      -- does LB process this pre-compilation? yikes!
08:36:30 <pjdelport> MarcWeber, ehird{: what dolio said
08:36:52 <ehird{> pjdelport: zoop
08:36:57 <MarcWeber> pjdelport I'm currently trying to undertstand why this works :)
08:37:57 <jdrake> Does ghc take unicode input?
08:38:21 <ehird{> jdavis: yes
08:39:13 <jdrake> Does it use the BOM to identify them?
08:39:42 <Deewiant> does GHC take anything other than UTF-8?
08:43:50 <Zao> Erm, this rmrf package, it sounds a bit scary.
08:44:16 <ohub> read mail very fast package?
08:44:27 <ohub> sorry, s/very/really/
08:44:57 <MarcWeber> maybe rm -rf package ? (removeAllRecursievely) - I haven't heard about that package yet
08:45:09 <Zao> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rmrf-2008.5.19.1
08:45:16 <Zao> The source is rather elegant.
08:48:30 <PeakerWork> @hoogle upcase
08:48:31 <rahaskella> No matches found
08:48:32 <matthew_-> I'm not sure I'd call it elegant
08:48:40 <PeakerWork> @hoogle upper
08:48:40 <rahaskella> Text.ParserCombinators.Parsec.Char.upper :: CharParser st Char
08:48:40 <rahaskella> Data.Char.UppercaseLetter :: GeneralCategory
08:48:40 <rahaskella> Data.Char.isUpper :: Char -> Bool
08:48:45 <dolio> @type toUpper
08:48:48 <rahaskella> Char -> Char
08:48:50 <sclv_> zounds. what a proof of concept.
08:48:50 <PeakerWork> thanks
08:48:55 <pjdelport> MarcWeber: Data.Traversable.sequence is like the normal sequence, but generalized to any Traversable instead of just []
08:49:15 <matthew_-> Zao: the point is to rather force discussion on whether there should be some level of QA or signing or *something* to offer some sort of safety
08:49:31 <matthew_-> some cabal devels have been known to script download and compile everything off hackage
08:49:36 <Zao> matthew_-: Ah. Interest awoken.
08:49:45 <matthew_-> which is insane without any sort sanity checks
08:49:53 * sanity checks
08:49:58 <matthew_-> ta
08:50:01 <ehird{> haha
08:50:07 <matthew_-> let me know if you find anything
08:50:11 <kristofer> it doesn't compare hashes or anything?
08:50:11 <sanity> will do
08:50:21 <ehird{>                   ; putStrLn $ "I will delete your home directory (" ++ home ++ ") in 10 seconds. Kill me."
08:50:21 <ehird{>                   ; countDown "Counting down to the end of your home directory" 10
08:50:21 <ehird{>                   ; putStrLn "Seriously, I won't lie again. You have just 300 more seconds. KILL ME."
08:50:41 <ehird{> matthew_-: ftw
08:50:41 <ehird{> wtf
08:50:44 <dcoutts_> matthew_-: yep, I have
08:50:44 <ehird{> you commented it out
08:50:45 <ehird{> --                  ; removeDirectoryRecursive home
08:50:46 <ehird{> loser
08:50:57 <dons> matthew_-: drop by #ghc
08:51:12 <matthew_-> ehird{: I'm actually not malicious
08:51:36 <ehird{> matthew_-: :(
08:51:42 <ehird{> Oooh... idea...
08:51:52 <ehird{> Compile.Time.Bot.Net
08:51:59 <ehird{> Installs a botnet rootkit at compile time
08:52:00 <ehird{> :D
08:52:29 <sclv_> it also raises the question of just what privs cabal & co should be allowed to run under...
08:52:51 <dcoutts_> sclv_: or what random code you choose to download off the net and run
08:52:52 <ehird{> sclv: it raises the question of TH's sanity
08:53:01 <ehird{> i mean come on, why do they allow anything in IO?
08:53:05 <ehird{> can't they just have a funky TH monad?
08:53:12 <chessguy> what in the world are you guys doing?
08:53:19 <sclv_> dcoutts_: well, sure, but package poisoning is an issue even with a relatively secure hackage infrastructure...
08:53:23 <ehird{> chessguy: removing home directories. At compile time.
08:53:30 <sclv_> and as it stands now, we don't even have that infrastructure.
08:53:39 <ehird{> sclv: I could, right now, replace a popular package - say happs - with rmrf.
08:53:42 <ehird{> Without the commented out.
08:53:45 <ehird{> *Right now*
08:54:23 <dons> and you'd lose your privs to do pretty much anything, if you did.
08:54:26 <dcoutts_> ehird{: not quite
08:54:26 <sclv_> so ideally you'd want to sandbox compilation and setup scripts from the deployment aspect.
08:54:40 <ehird{> dons: But of course. That's why I'm not going to.
08:54:47 <ehird{> I'm stating the concern.
08:54:54 <dcoutts_> ehird{: and that's mostly why it doesn't happen
08:55:09 <ehird{> dcoutts: Trust-based security systems don't work.
08:55:16 <dcoutts_> sclv_: if you don't trust a package you should not be installing it at all
08:55:35 <mauke> ehird{: how does CPAN do it?
08:55:46 <ehird{> mauke: People can't upload new versions of others packages.
08:55:47 <ehird{> :3
08:55:54 <ehird{> Revolutionary, I know.
08:56:01 <mauke> really?
08:56:08 <ehird{> mauke: um, yeah
08:56:10 <ehird{> its pretty obvious ...
08:56:11 <mauke> I'm tempted to try it
08:56:52 <mauke> IIRC someone once uploaded a package called "perl", which confused cpan into thinking it was a new version of perl itself
08:56:55 <sclv_> dcoutts_: i guess you have a point... even if i can avoid malicious compile-time behavior, then the code itself could still be evil when linked in at runtime
08:56:59 <psnively> Testing
08:57:21 <ehird{> psnively: Failed
08:57:23 <dcoutts_> sclv_: when run at runtime, yes :-)
08:57:26 <psnively> sclv_: Not necessarily. This is what Proof-Carrying Code is about.
08:58:04 <sclv_> psnively: right. but we're talking about hackage infrastructure in haskell.
08:58:20 <psnively> Perhaps hackage should be PCC-based?
08:59:22 <sclv_> I still think sandboxing cabal builds vs. cabal deployment under different privs is probably a sane idea, just as a nice extra measure though... we're not only talking maliciousness, but maybe just a seriously accidentally borked Setup.hs, remember...
08:59:41 <dcoutts_> sclv_: sure, it's just rather tricky to do portably
08:59:57 <dcoutts_> sclv_: hackage itself does it, but it's all tricky linux-specific chroot'ery
09:00:28 <ehird{> <mauke> IIRC someone once uploaded a package called "perl", which confused cpan into thinking it was a new version of perl itself
09:00:29 <ehird{> what did it do?
09:00:57 <sclv_> oh... that makes sense... working with os x and linux i always forget about the ugliness that is windows...
09:01:10 <mauke> ehird{: no idea
09:01:28 <ehird{> preflex: be poppavic
09:01:28 <preflex>  you know what? I don't get paid enough to save ##C or the knobs - and I've a thick skin.
09:01:31 <ehird{> preflex: be poppavic
09:01:31 <preflex>  remember - C is compiled, not assembled.
09:01:32 <ehird{> preflex: be poppavic
09:01:32 <preflex>  yer back to that Ultimate Interface. I don't control it. And terms are bandied about all over where you need to ask and research.
09:01:42 <ehird{> these bits of wisdom will help us sandbox cabal.
09:07:43 <Aviator> Hs has unicode support?
09:13:52 <ehird{> Aviator: yes
09:17:12 <twobitwork> do Data.Maps retain order?
09:17:57 <Saizan> of insertion? no
09:17:57 <Cale> They exploit the ordering provided by the instance of Ord to store the data in an efficient manner.
09:18:23 <twobitwork> ok
09:19:20 <mauke> > M.toList . M.fromList $ zip (words "how do I shot web ?") [1 ..]
09:19:22 <rahaskella>  [("?",6),("I",3),("do",2),("how",1),("shot",4),("web",5)]
09:32:28 <twobitwork> where's that site which converts functions into point-free notation?
09:32:45 <twobitwork> @faq point-free
09:32:45 <rahaskella> The answer is: Yes! Haskell can do that.
09:32:52 <sclv_> ?pl \x -> x * x * x
09:32:52 <rahaskella> (*) =<< join (*)
09:32:59 <twobitwork> ahh
09:33:00 <sclv_> this be the site
09:33:25 <sclv_> but if you want to do it a whole bunch or play around, use privmsgs
09:33:55 <twobitwork> ?pl item `notElem` xs = not . (`elem` xs) $ item
09:33:55 <rahaskella> (line 1, column 19):
09:33:55 <rahaskella> unexpected "="
09:33:55 <rahaskella> expecting variable, "(", "`", "!!", ".", operator or end of input
09:34:09 <Baughn> ..rahaskella still hasn't identified, though, so you have to turn on unfiltering for that
09:34:24 <twobitwork> Baughn: how do I do that?
09:34:28 <ehird{> sclv: how's hvac tutorial going?
09:34:46 <Baughn> twobitwork: /msg nickserv set unfiltered on
09:35:14 <twobitwork> so, does the bot only accept lambda notation?
09:35:29 <Baughn> For pl, yes. Just rewrite it.
09:36:03 <poucet> Hi
09:36:10 <Baughn> @leave #haskell
09:36:11 <rahaskella> Not enough privileges
09:36:16 <poucet> @leave #haskell
09:36:17 <rahaskella> Not enough privileges
09:36:26 <MyCatVerbs> @leave me alone, infernal voices!
09:36:27 <rahaskella> Not enough privileges
09:36:41 <MyCatVerbs> Well, buggery.
09:36:52 <xerox> ?pl f x = x
09:36:52 <rahaskella> f = id
09:37:03 <vincenz> @leave #haskell
09:37:03 <rahaskella> Not enough privileges
09:37:05 <vincenz> odd
09:37:10 <Baughn> Whose bot is that?
09:37:13 <nolrai_> @pl f g h a = g (a h) (f g h a)
09:37:13 <rahaskella> f = fix (ap (ap . (ap .) . (. flip id) . (.)))
09:37:33 <ehird{> Baughn: ari
09:37:34 <vincenz> anyways, while installing ghc.6.8.2, it complains about the lack of libgmp.so.3, while this file exists, anyone know a fix to this problem?
09:37:44 * vincenz is on a 64 bit system (ubuntu)
09:37:58 <Baughn> vincenz: Where does it exist, exactly?
09:38:03 <vincenz> Baughn: /usr/lib
09:38:14 <vincenz> checking for path to top of build tree... utils/pwd/pwd: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory
09:38:28 <Baughn> vincenz: That's odd. Check if it's a broken symlink?
09:38:33 <Baughn> vincenz: Or sudo ldconfig, just in case
09:38:38 <Botje> vincenz: are you sure it's not a dependency of libgmp.so.3 that's broken?
09:39:01 <Botje> what does "ldd utils/pwd/pwd" say?
09:39:10 <Baughn> libgmp doesn't /have/ any dependencies, though
09:39:12 <vincenz> Botje: not found
09:39:19 <vincenz>         libgmp.so.3 => not found
09:39:23 <MyCatVerbs> /usr/local/lib. You will never find a more wretched hive of scum and villainy.
09:39:29 <Botje> weird.
09:39:34 <Baughn> vincenz: Did you try sudo ldconfig yet?
09:39:42 <Baughn> vincenz: Also, what does ldd /usr/lib/libgmp.so.3 say?
09:39:59 <MyCatVerbs> (Barring /opt, of course, but everyone there is just unreasonably sick and screwy. So we don't talk 'bout 'dem much.)
09:40:34 <vincenz> Baughn: that seems fine, and yes I did try that, it didn't do much
09:41:36 <Botje> vincenz: how about LD_DEBUG=all utils/pwd/pwd
09:41:52 <Baughn> I was going to suggest strace, but yeah, go with that. ;)
09:41:55 <vincenz> Botje: where do I type that?
09:42:06 <Baughn> vincenz: It's a shell command
09:42:06 <Botje> in a shell, in the root of your ghc install dir, i guess
09:42:16 <Botje> or maybe start with LD_DEBUG=libs utils/pwd/pwd
09:42:24 <Botje> then you should get a nice trace of where it's looking
09:42:39 <shepheb> what's the shortest path to displaying an arbitrary bitmap (trying to show hot-cold colours from a matrix of numbers) in X? GTK+Cairo?
09:42:54 <vincenz> ah, it tries to look in /usr/lib64
09:42:56 <ehird{> SCLpING
09:42:59 <ehird{> sclv: ping
09:43:20 <dcoutts_> shepheb: what format is the input in? raw memory array of colours? .png file?
09:43:50 <EvilTerran> shepheb, if you just want to throw an image up on the screen, i think even HGL would be sufficient
09:43:53 <shepheb> dcoutts_: comma-separated ASCII file, decimal numbers. I want to convert to an image for visualization purposes
09:44:01 <vincenz> http://hpaste.org/7750
09:44:34 <dcoutts_> shepheb: how about converting to a pnm or some other similar very simple text format?
09:44:34 <EvilTerran> altho it'd probably be nicer to do in, say, gtk2hs+OpenGL
09:44:45 <Baughn> vincenz: Well, it was apparently compiled for a different system
09:44:53 <EvilTerran> yeah, my first thought would be to just make a bitmap file of it
09:44:59 <vincenz> Baughn: doh
09:45:01 <shepheb> dcoutts_: that may be the best plan. let me read that format spec again.
09:45:04 <EvilTerran> (but i figured you wanted realtime or something)
09:45:07 <Baughn> vincenz: let's see..
09:45:36 <EvilTerran> actually, my first thought was postscript, but that's just because i'm crazy like that.
09:45:37 <Baughn> vincenz: export LD_LIBRARY_PATH=/usr/lib should allow it to work
09:45:58 <vincenz> Baughn: don't I risk crahsing it since it's built for 32bit?
09:45:58 <shepheb> no, this is a static matrix.
09:46:25 <Baughn> vincenz: ..it's what, now? Then why.. hang on.
09:46:30 <litb> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in fib
09:46:32 <rahaskella>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:46:42 <Baughn> vincenz: Are you running a 32 or 64-bit os? Are you installing a 32 or 64=bit ghc?
09:46:55 <dcoutts_> shepheb: if you want to have your haskell prog display it then check out the fastdraw demo from gtk2hs
09:47:17 <Baughn> vincenz: As for its crashing, how would that hurt you? Couldn't you just /try/?
09:47:19 <ddarius> > fix((0:).(1:).ap(zipWith(+))tail) -- names are for the weak litb
09:47:22 <rahaskella>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:47:24 <shepheb> dcoutts_: nah, viewing it with another viewer is fine.
09:47:27 <litb> > tail [1..10]
09:47:28 <rahaskella>  [2,3,4,5,6,7,8,9,10]
09:47:40 <vincenz> Baughn: true, though that export doesn't seem to have any effect
09:47:59 <vincenz>       4444:       trying file=/usr/lib/libgmp.so.3
09:48:06 <vincenz> apparently it doesn't like it :)
09:48:55 <Baughn> vincenz: Actually, why don't you just apt-get install ghc
09:48:57 <Baughn> ?
09:49:02 <vincenz> that'll give me 6.6 :(
09:49:08 <Botje> vincenz: not on hardy
09:49:08 <litb> > (0:) [10, 80, 70, 12, 3, 4]
09:49:10 <rahaskella>  [0,10,80,70,12,3,4]
09:49:15 <Baughn> vincenz: Which can compile 6.8 just fine
09:49:25 <Botje> Version: 6.8.2-2ubuntu1
09:49:37 * vincenz is on dapper
09:49:44 <Botje> dapper?
09:49:48 <Botje> you are a brave brave man :)
09:49:49 <vincenz> ubuntu dapper
09:50:22 <Botje> but i'll have to agree with baugn
09:50:24 <Baughn> vincenz: So you compile ghc 6.8, uninstall 6.6, install 6.8, and everything just works
09:50:26 <vincenz> make that 6.4.
09:50:27 <vincenz> .1
09:50:44 <litb> ddarius: too bad
09:50:45 <vincenz> Baughn: how can I compile 6.8 if it still comlpains about libgmp during ./confugre
09:50:51 <vincenz> configure
09:51:04 <Baughn> vincenz: ..that's the /binary/ version
09:51:11 <Baughn> vincenz: Get the source package. It won't.
09:51:18 <vincenz> ah
09:51:22 <Botje> vincenz: have you tried symlinking /usr/lib/libgmp to /usr/lib64 ?
09:51:39 <Botje> (full filenames of course, but bleh)
09:52:20 <vincenz> Botje: there is no 64bit version of libgmp
09:52:40 <Botje> just symlink it?
09:52:43 <Botje> you never know :)
09:52:57 <mm_freak> litb: you were asking for the lucas-lehmer primality test for mersenne numbers
09:53:00 <vincenz> I'd rather not screw up my system too much (:
09:53:03 <mm_freak> > let llSeq n = unfoldr (\x -> Just (x, mod (x^2 - 2) n)) 4; lucasLehmer p = llSeq (2^p - 1) !! (p-2) == 0 in lucasLehmer 7
09:53:06 <rahaskella>  True
09:53:09 <Botje> it's just one file
09:53:26 <Baughn> vincenz: There isn't?
09:53:32 <Baughn> vincenz: Right. You're seriously due for an upgrade.
09:53:32 <Botje> or just go with the source install of 6.8
09:54:35 <mm_freak> litb: you can speedup (lucasLehmer p) by checking, whether p is prime, first…  if p is composite, then 2^p - 1 is also composite
09:55:00 <vincenz> Baughn: no can't do
09:56:31 <Baughn> vincenz: Well, a source compile will still work, but this kind of thing will just get worse. Open-source OSs do tend to assume that you'll keep things up to date.
09:56:38 * vincenz nods
09:56:53 <vincenz> ok, thanks for the help (:
10:04:50 <Zao> Oh dear, I've got a space leak that took at least two hours to eat my stack.
10:04:54 <Zao> That'll be fun to debug.
10:05:00 <Zao> s/hours/weeks/
10:07:12 <Baughn> Zao: Eat your /stack/? Not heap?
10:07:59 <Zao> Baughn: I'm leaning towards an recursion which accumulates gunk along the way.
10:08:37 <matthew_-> a very slow non-tail call recursion?
10:08:47 <Zao> Baughn: "Stack space overflow: current size 8388608 bytes."
10:09:20 <Zao> matthew_-: Slow is correct, since it's most likely the accept-response loop for the http thread.
10:09:28 <ehird{> let aaagh xs = xs ++ aagh (aagh [1..10000000]) ++ aagh (aagh [1..10000000]) ++ xs
10:09:30 <ehird{> :D
10:09:51 <Baughn> }} -- now that's just uncalled for
10:10:03 <ehird{> Baughn: is my unbalanced { bothering you
10:10:10 <Baughn> Yes. }}.
10:10:16 <ehird{> Baughn:
10:10:16 <ehird{> Baughn:
10:10:16 <ehird{> Baughn:
10:10:24 * Baughn starts crying
10:10:40 * ehird{ pats Baughn. }}}}
10:10:40 <twobitwork> what's the syntax for using classes within type definitions... i.e. something like: type Foo = Foo { MyClass mc => elem :: mc }
10:11:14 <Baughn> twobitwork: You don't. type statements are just aliases; you're looking for data or newtype.
10:11:19 <Zao> http://hpaste.org/7751
10:11:22 <twobitwork> ohhh no, my question went out of scope! :P
10:11:47 <twobitwork> Baughn: damn, I've been avoiding learning newtypes...
10:12:08 <cnwdup> Can't I make a type member of a class?
10:12:22 <Baughn> twobitwork: It's more or less just a limited data, though there is newtype deriving and such as well. So just use data.
10:12:27 <Cale> cnwdup: Sure, you write an instance
10:12:33 <Zao> I need to stop using so many lambda functions :)
10:12:43 <twobitwork> Zao: why? they're so fun
10:12:43 <ehird{> {{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{
10:12:51 <cnwdup> cale: Ok, then I have to try harder figuring out the error. (-: Thanks.
10:12:57 <Zao> Does anything about that thread function look fishy?
10:12:59 <Baughn> ehird{: Syntax error: nesting too deep.
10:13:03 <Cale> cnwdup: Which type and which class?
10:13:07 <ehird{> Baughn: shit parser.
10:13:11 <ehird{> :-P
10:13:25 <cnwdup> cale: Both custom type and class.
10:13:32 <Cale> Oh, okay
10:13:57 <ehird{> cnwdup: Aah.
10:14:01 <ehird{> cnwdup: Do you mean a type synonym?
10:14:04 <ehird{> like type A = ...
10:14:06 <EvilTerran> you can't make a "type" type-alias an instance of a class in h98
10:14:08 <ehird{> If so, no, no you can't.
10:14:13 <ehird{> It would be confusing.
10:14:17 <ehird{> You could do all kinds of stuff
10:14:24 <EvilTerran> you can in ghc, with an extension
10:14:38 <cnwdup> Ok, so I should declare it as data?
10:14:42 <matthew_-> there's little you can't do in GHC with an extension...
10:14:45 <EvilTerran> as long as the type synonym is fully applied in the instance decleration
10:15:15 <Baughn> cnwdup: GHC expands type synonyms before doing anything else. If you say "type Foo = IO Bar", then whenever you say Foo it sees (IO Bar), period.
10:15:17 <ehird{> EvilTerran: yes, well.
10:15:21 <pcc1> what's this "error" about? (configuring hs-plugins for ghc-6.8) "Setup.lhs: plugins.cabal:22: 'Executable' stanza starting with field 'library\nexposed-modules'" (the \n is actual newline)
10:15:25 <EvilTerran> so "type Foo a = (a,a); instance Bar Foo" isn't ok, but "type Foo = Maybe; instance Bar Foo" is
10:15:35 <ehird{> EvilTerran: Curried type synonyms would be tons of fun :-D
10:15:36 <EvilTerran> ... and "type Foo a = Maybe a; instance Bar Foo" is wrong again
10:15:38 <dcoutts_> pcc1: your cabal is too old
10:15:42 <ehird{> EvilTerran: For example.
10:15:44 <ehird{> type Id a = a
10:15:47 <ehird{> instance Monad I
10:15:48 <ehird{> d
10:15:59 <ehird{> (>>=) :: a -> (a -> b) -> b
10:16:00 <jfredett> conal: your post on derivatives was excellent, but _I must know how it ends!_
10:16:00 <EvilTerran> zomg stealth overlapping instances
10:16:01 <ehird{> return :: a -> a
10:16:02 <ehird{> :-P
10:16:20 <jfredett> conal: cliffhangers make for mean blogposts... :/
10:16:20 <dcoutts_> pcc1: at least that's my guess, what version of cabal are you using?
10:16:39 <pcc1> whichever version came with 6.8.2
10:17:06 <conal> jfredett: :) :)  thanks.  hopefully today for part 3.
10:17:11 <pcc1> which was 1.2.3.0
10:18:49 <dancor> @pl \ f xs -> (f (head xs)):(tail xs)
10:18:49 <rahaskella> (`ap` tail) . ((:) .) . (. head)
10:18:58 <EvilTerran> maybe not
10:19:22 <EvilTerran> > (f . head &&& tail) [x,y,z]
10:19:24 <rahaskella>  Add a type signature
10:19:29 <EvilTerran> > (f . head &&& tail) [x,y,z] :: [Expr]
10:19:31 <rahaskella>  Couldn't match expected type `[Expr]'
10:19:34 <EvilTerran> bah
10:19:38 <EvilTerran> oh, yeag
10:19:40 <conal> dancor: @pl \ f -> liftA2 f head tail
10:19:44 <conal> @pl \ f -> liftA2 f head tail
10:19:44 <rahaskella> flip (flip liftA2 head) tail
10:19:52 <EvilTerran> > liftA2 (:) (f . head) tail [x,y,z] :: [Expr]
10:19:55 <rahaskella>  [f x,y,z]
10:19:55 <conal> oops -- missed the (:)
10:19:56 <pcc1> apparently the latest version, anyone have anty other ideas?
10:20:52 <EvilTerran> if we had a list deconstructor like "maybe" and "either", it'd just be "list id ((:).f)"
10:21:04 <EvilTerran> er, list [] ((:).f), even
10:21:17 <EvilTerran> (where list e f [] = e; list e f (x:xs) = f x xs)
10:21:22 <coffeemug> hello
10:21:30 <EvilTerran> c|_|
10:21:53 <EvilTerran> ?type ((:).)
10:21:58 <rahaskella> forall a (f :: * -> *). (Functor f) => f a -> f ([a] -> [a])
10:22:06 <EvilTerran> o blarghy
10:22:11 <EvilTerran> ?type ((P.:)P..)
10:22:16 <rahaskella> Couldn't find qualified module.
10:22:23 <EvilTerran> ?type ((:)Prelude..) -- grr
10:22:27 <rahaskella> forall b a. (a -> b) -> a -> [b] -> [b]
10:22:36 * EvilTerran wanders off
10:22:47 <coffeemug> I remember seeing some library a while back that used some sort of generic programming approach to generate UIs for Haskell data structures
10:22:52 <pcc1> pcc1: stupid "maintenance" system here downgraded the package to 6.6.... grr... thanks anyway
10:22:55 <coffeemug> does anyone remember something like this?
10:22:57 <EvilTerran> ?where frp
10:22:58 <rahaskella> I know nothing about frp.
10:23:06 <EvilTerran> ?go functional-reactive-programming
10:23:08 <rahaskella> http://www.haskell.org/frp/
10:23:08 <rahaskella> Title: Functional Reactive Programming Research
10:23:19 <EvilTerran> ?where+ FRP http://www.haskell.org/frp
10:23:19 <rahaskella> Done.
10:23:35 <EvilTerran> coffeemug, that may've been what you were thinking of
10:23:48 <coffeemug> hmm, no I don't think it was FRP
10:24:03 <ehird{> Prelude..
10:24:03 <ehird{> hah
10:24:03 <nolrai_> can Arrays have zero size?
10:24:05 <conal> coffeemug: could be iData
10:24:09 <ehird{> > fmap id id
10:24:11 <rahaskella>  Add a type signature
10:24:19 <ehird{> :t (.)
10:24:25 <rahaskella> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:24:27 <ehird{> :t fmap
10:24:28 <Baughn> nolrai_: Don't see why not
10:24:31 <rahaskella> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:24:49 <ehird{> Hmm.
10:24:56 <ehird{> I don't like how fmap involves a function.
10:24:56 <ehird{> :P
10:25:45 <conal> coffeemug: there's something else, i'm trying to track down by dutch folks
10:25:49 <Baughn> nolrai_: "array (2,1) []", for example
10:26:29 <coffeemug> conal: yeah, it's not iData. I think it might have been Phoeey
10:26:32 <nolrai_> ok then i can use that insted of Nothing.
10:26:32 <coffeemug> Phooey
10:27:00 <Baughn> nolrai_: If you like, but the Maybe monad can be quite convenient. I'm not sure why you'd want to.
10:27:12 <conal> coffeemug: oh!  i though maybe #5 here: http://www.cs.ru.nl/A.vanWeelden/index.php?p=publications
10:27:39 <conal> coffeemug: could also be TV, which strongly relates types and GUIs
10:27:43 <conal> @wiki TV
10:27:43 <rahaskella> http://www.haskell.org/haskellwiki/TV
10:27:47 <conal> @wiki Phooey
10:27:47 <rahaskella> http://www.haskell.org/haskellwiki/Phooey
10:28:33 <nolrai_> weel instead of Maybe (Array i e) i can use just use Array i e and most of my things will just work. (the zero size will cause noops).
10:28:35 <coffeemug> conal: hmm, that looks right actually
10:28:38 <coffeemug> thanks for that paper!
10:28:51 <conal> :)
10:29:07 <Baughn> nolrai_: *shrug*
10:29:52 <dejones> how do you uninstall a package that was installed by "cabal install"  ?
10:30:13 <dcoutts_> dejones: using rm and good judgement :-)
10:30:22 <Baughn> dejones: Manually. ghc-pkg unregister and rm -r, I imagine.
10:30:35 <dejones> dcoutts_: lol, thanks.  Baughn: thank you too.
10:30:53 <dcoutts_> dejones: if you'd like to implement something better for us, there's a ticket with the info...
10:31:29 <dcoutts_> currently my #1 cabal-install priority is the dreaded diamond dependency problem
10:31:39 <dcoutts_> which I think I've nearly cracked
10:31:45 <dejones> dcoutts_: Maybe.  ;)  I gotta get the Parallel Profiling Tools for GHC done first, since that is my Master's thesis.
10:31:58 <Baughn> dcoutts_: Er? Why is that a problem?
10:32:26 <dcoutts_> @google dreaded diamond dependency problem
10:32:27 <rahaskella> No Result Found.
10:32:30 <dcoutts_> bah!
10:32:38 <dcoutts_> http://blog.well-typed.com/2008/04/the-dreaded-diamond-dependency-problem/
10:32:39 <ehird{> so
10:32:47 <dcoutts_> Baughn: ^^
10:33:04 <Baughn> dcoutts_: Thankee. Oh and hey, new haskell blog for me to read
10:33:16 <dolio> dcoutts_: Incidentally, is there a way to get cabal-install to build profiling binaries and haddock for the stuff it installs?
10:33:20 <dcoutts_> Baughn: it's syndicated on planet.haskell
10:34:12 <Baughn> dcoutts_: ..no fair. I /needed/ that copious spare time.
10:34:22 <dcoutts_> dolio: profiling is easy, docs see http://hackage.haskell.org/trac/hackage/ticket/206
10:34:26 <coffeemug> conal: Tangible Values work is yours?
10:35:12 <nolrai_> is there a function to apply a fuction too both members of an pair?
10:35:16 <dcoutts_> dolio: cabal install takes all the configure flags, and in particular --enable-library-profiling and --enable-executable-profiling
10:35:22 <conal> coffeemug: yeah
10:35:25 <dolio> Ah, okay.
10:37:39 <coffeemug> that's some interesting work
10:38:56 <pjdelport> > join (***) show (2,3)
10:38:58 <rahaskella>  ("2","3")
10:39:23 <nolrai_> :t join (***)
10:39:25 <ehird{> sclv: sclv_ ping
10:39:26 <rahaskella> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
10:39:44 <nolrai_> nice
10:40:20 <nolrai_> I can almost read arrow types now.
10:40:27 <nolrai_> :t join
10:40:31 <rahaskella> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:40:38 <pjdelport> nolrai_: just read a as ->
10:40:42 <twobitwork> does haskell have exceptions? I don't see anything in the wikibook about them
10:40:56 <pjdelport> > 1 / 0
10:40:56 <rahaskella>  Infinity
10:41:00 <pjdelport> d'oh
10:41:14 <pjdelport> > read ""
10:41:16 <rahaskella>  Exception: Prelude.read: no parse
10:41:31 <ehird{> infix types ftw:
10:41:53 <ehird{> join (***) :: (Arrow (~>)) => (b ~> c) -> ((b, b) ~> (c, c))
10:42:00 <dejones> uh oh: cabal upgrade
10:42:00 <dejones> cabal: Error Parsing: file ".cabal" doesn't exist. Cannot continue.
10:42:05 <pjdelport> twobitwork: that's probably not what you want, though
10:42:05 <Baughn> > read "12"
10:42:08 <rahaskella>  Exception: Prelude.read: no parse
10:42:14 <dejones> I have the .cabal file in my home directory.... any ideas?
10:42:20 <twobitwork> pjdelport: ok, cool... how do I raise exceptions?
10:42:21 <dcoutts_> dejones: ah yes
10:42:27 <Baughn> > read "\"a\""
10:42:27 <dcoutts_> dejones: I fixed that the other day
10:42:29 <rahaskella>  Exception: Prelude.read: no parse
10:42:38 <dejones> dcoutts_: enlighten me!  :)
10:42:39 <twobitwork> or better yet, where is the documentation for them?
10:42:43 <nolrai_> twobitwork: look at Control.Monad.Error, and Control.Exception in the libs
10:42:52 <twobitwork> ok, thanks
10:43:00 <dcoutts_> dejones: the upgrade code was using the wrong level of entry point for installing
10:43:17 <dcoutts_> dejones: when there was nothing that needed upgrading it would call the install code with []
10:43:22 <pjdelport> > error "pants exploded"
10:43:23 <dejones> hmm
10:43:24 <rahaskella>  Exception: pants exploded
10:43:42 <dejones> dcoutts_: Yah, I think that is my fault bc I unregistered and rm'd the package it was trying to upgrade.  ;)
10:43:44 <dcoutts_> dejones: and cabal install with no args means install the local thing, ie the unpackage project in the current dir, so it looks for a .cabal file etc
10:44:05 <pjdelport> twobitwork: error is not for structured exception handling, though;  it's for basically crashing
10:44:08 <dcoutts_> dejones: oh, well that might be a different issue
10:44:38 <nolrai_> but Error is somthing difrent.
10:44:41 <dcoutts_> dejones: if you get the problem with the latest version of cabal-install and you still think it's wrong then report it
10:44:49 <pjdelport> twobitwork: in most cases, you really just need to return the appropiate value
10:44:55 <pjdelport> for example,
10:44:55 <pjdelport> :t lookup
10:44:59 <rahaskella> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
10:45:59 <dejones> dcoutts_: hmm, well, if I ghc-pkg unregister the package, then rm the directory for it in .cabal, I'm assuming that is what confused it and now cabal upgrade thinks my .cabal is missing.
10:46:19 <dejones> dcoutts_: It will let me cabal install the package again though...
10:46:44 <Baughn> dcoutts_: I tend to agree with your dependency solution, with the caveat that cabal upgrade should also recompile packages against the newest version of whatever so you can get rid of the old ones
10:46:52 <dcoutts_> dejones: are you sure there is anything to actually upgrade?
10:47:43 <dcoutts_> Baughn: hmm? you mean if I install foo-2.0 then everything else that was built against foo-1.0 should be rebuilt against foo-2.0?
10:47:51 <ehird{> > read "pants" :: Expr
10:47:53 <rahaskella>   add an instance declaration for (Read Expr)
10:47:53 <rahaskella>     In the expression: read "pa...
10:48:00 <ehird{> > read "pants"
10:48:03 <rahaskella>  Exception: Prelude.read: no parse
10:48:34 <dejones> dcoutts_: I am not sure.  The package I removed could have been the only package that needed to be upgraded.
10:48:53 <Baughn> dcoutts_: No, I mean if you install foo-2.0 as part of a cabal upgrade (or even if it was already installed), they should be. Possibly as a flag to upgrade, since that can be quite a lot of work
10:48:57 <dejones> dcoutts_: how did you handle when there was nothign else to upgrade?
10:49:20 <dcoutts_> dejones: that's just my point, so it was triggering the silly bug we had when there was nothing to upgrade
10:49:33 <dejones> dcoutts_: yah, is there a fix to the bug?
10:49:45 <dcoutts_> dejones: yeah, it's in the latest darcs version
10:49:50 <twobitwork> pjdelport: ok, so maybe just using an Either would be best?
10:49:56 <dejones> dcoutts_: hehe, ok, thanks. :)
10:50:12 <pjdelport> twobitwork: quite probably
10:51:04 <dcoutts_> Baughn: I'm not sure I know exactly what you're saying, can you be more specific or give a specific example?
10:51:45 <Baughn> dcoutts_: Really, I'm just saying there should be some way to force it to recompile everything that's compiled against an older version
10:52:53 <dcoutts_> Baughn: so if foo-1.0 is currently built against bar-1.0, but bar-2.0 is also installed then cabal upgrade should rebuild foo-1.0 against foo-2.0?
10:53:16 <dcoutts_> Baughn: ie, no upgrade to foo itself, just rebuilding it against a later version of one of its dependencies
10:53:23 <dcoutts_> is that what you're suggesting?
10:53:58 <Baughn> That's the idea. upgrade-all, perhaps, but there's no particular reason you'd /want/ all that old code to stick around
10:54:04 <nolrai_> twobitwork: thats what Control.Monad.Error does (use Either that is).
10:54:28 <dcoutts_> Baughn: ok. It's a complex topic, you have to be specific :-)
10:54:38 <orbitz> Baughn: hi
10:55:27 <Baughn> orbitz: Howdy
10:55:40 <orbitz> Baughn: i can haz cheezbuger?
10:55:55 <Baughn> orbitz: No. Those are unhealthy.
10:56:07 <orbitz> ok
10:56:23 * orbitz is flopping around in jboss, blargh java i no fun
10:56:52 <dcoutts_> orbitz: start a haskell consultancy instead :-)
10:57:17 <orbitz> maybe i will!
10:58:29 * dcoutts_ encourages the competition
10:59:13 <orbitz> JBoss chose its name quite well.  Much like a Boss, it is large, ineffective, and slow
10:59:26 <dcoutts_> heh heh heh
10:59:40 * dcoutts_ doesn't even know what it does
10:59:45 <Philippa> but makes you jump through the same ludicrous moves over and over again?
10:59:51 <dcoutts_> it's a java thing for doing stuff right?
11:00:00 <dcoutts_> erm I mean
11:00:02 <orbitz> it's an app server
11:00:03 <dcoutts_> it's a java thing for doing stuff, right?
11:00:05 <orbitz> yeah java
11:00:14 <dcoutts_> not "doing stuff right"
11:00:21 <dcoutts_> important distinction
11:00:29 <dons> ?yow
11:00:29 <rahaskella> My CODE of ETHICS is vacationing at famed SCHROON LAKE in upstate New York!!
11:00:47 <dcoutts_> mm, that's a weird one
11:00:58 <thetallguy> Wow, been a while since I've heard of Schroon Lake.
11:01:13 <dons> Cale: how's the bot?
11:01:27 <Cale> cale@zaphod:~$ ssh code
11:01:28 <Cale> Password:
11:01:34 <Cale> that's how :)
11:01:44 <dons> ah
11:01:44 <dons> fixing
11:02:34 <twobitwork> uhhh ohh... ghci just segfaulted
11:02:59 <twobitwork> Prelude Database.HDBC Database.HDBC.Sqlite3> a <- connectSqlite3 "/etc/foo"
11:02:59 <twobitwork> Segmentation fault
11:03:21 <dons> cool. i wonder if there's a bug in the binding.
11:03:27 <twobitwork> that's what it sounds like
11:03:34 <dons> can you reproduce it? and then see if it also fails for compiled code
11:03:35 <nolrai_> "/ect/foo"!?
11:03:50 <twobitwork> I was testing to see how it would complain about permissions problems
11:04:17 <Baughn> I suppose "no error checking" can be called a bug, yeah
11:05:32 <twobitwork> http://hpaste.org/7752
11:05:36 <twobitwork> reproduced
11:05:51 <dons> so that's a bug report for the library author
11:06:03 <Cale> @bot
11:06:04 <rahaskella> :)
11:06:09 <lambdabot> :)
11:06:25 <Cale> rahaskella: @part #haskell
11:06:41 <dejones> Cale: so we can kick the bot out? ;)
11:06:53 <Cale> hm?
11:07:02 <dejones> rahaskella: @part #haskell
11:07:02 <dejones> <-- rahaskella (n=rahaskel@dyn3-82-128-187-116.psoas.suomi.net) has left #haskell
11:07:15 <pjdelport> Haskell, where smiles come in stereo too
11:07:16 <dejones> can only you tell the bot to part?  :)
11:07:21 <Cale> Yeah. If you have privileges.
11:07:29 <dejones> Ahh.
11:08:42 <Baughn> I'd like to see cheiron used for lb replacements when possible.. mostly because rahaskell wasn't IDed, which leads to trouble with privmsgs
11:10:57 <twobitwork> dons: reproduced in compiled code: http://hpaste.org/7753
11:12:09 <ehird{> we should put 100 lambdabots in #lambdabot
11:12:12 <ehird{> and make them do ascii art
11:12:22 <nolrai_> > (1,2) - (2, 3)
11:12:23 <lambdabot>   add an instance declaration for (Num (t, t1))
11:12:54 <geezusfreeek> gwern: you around? i need a vocabulary nut :)
11:13:25 <dmwit> > uncurry (***) (((-) *** (-)) (1, 2)) (2, 3)
11:13:26 <lambdabot>  (-1,-1)
11:13:29 <dmwit> gross!
11:14:04 <geezusfreeek> dmwit: doesn't look too gross to me
11:14:09 <nolrai_> man all i want is nice way to take a difrence of points
11:14:15 <dmwit> yeah
11:14:25 <dmwit> > zipWith (-) [1, 2] [2, 3]
11:14:26 <lambdabot>  [-1,-1]
11:14:33 <dmwit> geezusfreeek: compare ;-)
11:14:34 <nolrai_> (-) (+) need to be refactored out of num.
11:14:47 <geezusfreeek> dmwit: of course :P
11:15:04 <geezusfreeek> nolrai_: so does the requirement for Eq and Show
11:15:20 <tromp> :t (*)
11:15:22 <nolrai_> yeah.
11:15:23 <lambdabot> forall a. (Num a) => a -> a -> a
11:16:01 <tromp> @instances Num
11:16:01 <lambdabot> Double, Float, Int, Integer
11:17:35 <tromp> :t (***)
11:17:37 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:17:59 <geezusfreeek> anybody here who can think of a good word for something that is... possibly impossible?
11:18:03 <ehird{> (Arrow (~>)) => (b ~> c) -> (b' ~> c') -> ((b, b') ~> (c, c'))
11:18:03 <ehird{> :-P
11:18:29 <dmwit> geezusfreeek: Difficult?
11:18:40 <ehird{> geezusfreeek: Embarrasing.
11:18:45 <geezusfreeek> dmwit: ;) not quite the kind of thing i'm looking for
11:19:04 <ehird{> geezusfreeek: Undecided?
11:19:07 <ehird{> Ambigious?
11:19:11 <ehird{> Hmm.
11:19:13 <ehird{> Transpossibility?
11:19:41 <geezusfreeek> this is for a type similar to Maybe, except it's "Nothing" means "can never be under any circumstances" instead of just "not there"
11:19:53 <dmwit> Incomplete
11:19:56 <geezusfreeek> (it has a different constructor for "not there"
11:20:00 <ehird{> geezusfreeek: Inconceivable
11:20:03 <ToRA> No
11:20:03 <ehird{> I win.
11:20:14 <ehird{> Or: Unpossible
11:20:21 <dmwit> geezusfreeek: s/it's/its/ ;-)
11:20:27 <ehird{> data Perhaps a = Inconceivable | Its a | Nope
11:20:28 <geezusfreeek> dmwit: yes
11:20:36 <ehird{> data Perhaps a = Unpossible | Its a | Nope
11:20:37 <ehird{> Compare.
11:20:42 <geezusfreeek> my fingers move too quickly. i don't normally make that mistake ;)
11:20:57 <geezusfreeek> ehird{: wow
11:21:05 <ehird{> geezusfreeek: what
11:21:07 <allbery_b> Its a | Unknown | Unknowable
11:21:25 <ehird{> Watermelon a | Turnip | GardenFurniture
11:21:27 <ehird{> solved by dada.
11:21:45 <geezusfreeek> ehird{: so the word would be "Perhaps"?
11:22:02 <geezusfreeek> doesn't seem to quite fit to me
11:22:09 <geezusfreeek> sounds too much like Maybe
11:22:11 <ehird{> data Fungi a = Watermelon a | Turnip | GardenFurniture
11:22:17 <ehird{> SOLVED.
11:22:17 <geezusfreeek> that works
11:22:20 <geezusfreeek> i'll go with Fungi
11:22:24 <ehird{> great!
11:22:25 <ehird{> glad to help
11:22:30 * geezusfreeek shakes his head
11:22:43 <geezusfreeek> back to the dictionary/thesarus i guess
11:23:00 <dmwit> geezusfreeek: Have you considered just using Maybe?
11:23:16 <dmwit> I mean, Nothing has no real meaning except what you give to it.
11:23:26 <geezusfreeek> dmwit: except i need two kinds of Nothing
11:23:39 <dmwit> ah
11:23:54 <ehird{> fromFungi :: Fungi a -> Maybe a
11:23:58 <geezusfreeek> dmwit: one means "not yet" and the other mean "never"
11:24:00 <ehird{> fromFungi (Watermelon a) = Just a
11:24:05 <ehird{> fromFungi Turnip = Nothing
11:24:08 * Baughn is quite annoyed that ghci/opengl works perfectly on linux
11:24:14 <dmwit> geezusfreeek: Maybe (Sometime a)
11:24:15 <ehird{> fromFungi GardenFurniture = error "HOLY F*CKING SH*T!!! TIGERS!!!"
11:24:19 <pjdelport> geezusfreeek: Maybe (Maybe a) ?
11:24:24 <ehird{> See? Fungi is a useful resource.
11:24:30 <tchakkazulu> type Fungi = Maybe (Maybe a). fromFungi = join.
11:24:30 <ToRA> data Foo a = Never | NotYet | Now a
11:24:36 <geezusfreeek> it's not the structure i need. it's the name for it
11:24:38 <ehird{> tchakkazulu: Shaddup.
11:25:01 <dmwit> geezusfreeek: Don't name it; just use Maybe . Sometime.
11:25:07 <dmwit> I think that's a pretty good name, really.
11:25:07 <pjdelport> geezusfreeek: Maybe Maybe is a name :)
11:25:17 <tchakkazulu> Sowwy :P
11:25:18 <pjdelport> Nothing versus Maybe Nothing
11:25:30 <geezusfreeek> i'm actually half truthing. this is a type class, and Maybe, List, and my own type Future are all instances of it
11:25:35 <ehird{> pjdelport: Just Nothing actually
11:25:43 <pjdelport> err, right
11:25:47 <geezusfreeek> where Future is the one that has the extra "Nothing"-like constructor
11:25:48 <ehird{> geezusfreeek: 9/11 half truther. "The government did half of 9/11!"
11:26:05 <geezusfreeek> and the functions in the type class are "never" and "possible", both returning booleans
11:27:04 <orbitz> ehird{: but which half?!
11:27:10 <geezusfreeek> although perhaps renaming "never" to "impossible" may make more sense
11:27:15 <dmwit> geezusfreeek: Sounds like modal logic.
11:27:16 <gwern> geezusfreeek: yes?
11:27:26 <nolrai_> how about MaybeImpossible ?
11:27:26 <dmwit> geezusfreeek: Maybe use a term from their lexicon?
11:27:42 <orbitz> nolrai_: MissionImpossible?
11:27:43 <ehird{> orbitz: Half of both halves.
11:27:43 <mib_xaf27x> i am try to use the utf-8 @ sign in my program and it is not working with ghc 6.8.2, it worked with 6.4, what is the problem ?
11:27:44 <geezusfreeek> nolrai_: that is the most descriptive so far :\
11:27:55 <pjdelport> geezusfreeek: Possibility work
11:27:58 <pjdelport> works, even
11:28:03 <geezusfreeek> gwern: a word for something that might be, but isn't necessarily, impossible?
11:28:03 <dmwit> geezusfreeek: "World" or something like that.
11:28:19 <gwern> mib_xaf27x: I think there's a UnicodeSyntax extension to enable
11:28:21 <geezusfreeek> pjdelport: i like Possibility
11:28:47 <gwern> geezusfreeek: as in, it's not logically impossible, but might be contingently impossible?
11:28:52 <mib_xaf27x> gwern how do u enable it?
11:28:52 <gwern> we're talking metaphysics here?
11:29:12 <geezusfreeek> gwern: nah, just in a general sense
11:29:22 <gwern> mib_xaf27x: check the manual, but I guess it'd be someething like {-# LANGUAGE UnicodeSyntax #-}
11:29:37 <geezusfreeek> gwern: i think "possibility" will work though
11:29:54 <gwern> geezusfreeek: hm. if it isn't logically impossible, just practically, I think I'd at first blush use 'infeasible'
11:30:08 <lilac> why are fst and snd not class methods?
11:30:25 <geezusfreeek> gwern: hmm... actually "feasible" might work
11:30:51 <dmwit> lilac: Because you're supposed to use real data types instead of bigger tuples?
11:30:57 <geezusfreeek> okay thanks everybody, i will just use one of "possible" or "feasible" (or some other synonym, now that i found a couple)
11:31:15 <lilac> dmwit: sure, but three-tuples aren't that uncommon, are they?
11:31:24 <dmwit> I think I've used them once.
11:31:32 <geezusfreeek> *possibility
11:31:55 <orbitz> people don't pernounce it two-ple fo rnothign
11:32:08 <dmwit> You sound really knowledgeable.
11:32:15 <dmwit> Do you have a magazine I could sign up for?
11:32:29 <mauke> SHEE-PLE
11:32:36 <code4> hi
11:32:36 <code4> hi
11:32:36 <code4> hi
11:32:36 <code4> hi
11:32:36 <code4> hi
11:32:36 <code4> hi
11:32:44 <geezusfreeek> hi
11:32:46 <geezusfreeek> :P
11:32:57 <lilac> dmwit: i've used them a few times, and i've been learning haskell for less than a month. i guess those two facts are positively correlated?
11:33:01 <code4> hello!
11:33:41 <ehird{> <dmwit> You sound really knowledgeable.
11:33:41 <ehird{> <dmwit> Do you have a magazine I could sign up for?
11:33:44 <lilac> code4: hello?
11:33:47 <ehird{> you had a meme oppertunity there
11:34:09 <dmwit> 1. I am eminently aware of that.
11:34:17 <dmwit> 2. I do not think "meme" means what you think it means.
11:34:47 <TSC> 3. ???
11:34:51 <dmwit> 3. It is possible that "eminently" does not mean what I think it means.
11:34:52 <lilac> PROFIT!
11:34:57 <Arnar> damn.. beat me to it
11:35:16 <Arnar> @define eminently
11:35:17 <lambdabot> Undefined.
11:35:23 <dmwit> heh
11:35:31 <Arnar> is that what you thought it meant? ;)
11:36:38 <gwern> dmwit: your ideas intrigue me. I would like to subscribe to your newletter.
11:37:01 <ehird{> gwern: Many minuets later ...
11:37:26 <dmwit> I like my mutation better.
11:37:37 <ehird{> by the way
11:37:39 <gwern> ehird{: if I don't educate dmwit, who will?
11:37:41 <dmwit> That's why I used it. ;-)
11:37:49 <ehird{> #2 = I apply the same to you!
11:37:55 <dmwit> gwern: I am educated well enough, thanks.
11:37:58 <ehird{> gwern: Your ideas intrigue me. I would like to subscribe to your newletter.
11:40:45 <gwern> dmwit: no you're not. you've been educated dumb, my man!
11:41:23 <BMeph> Hmm - so when you say "eminently," do you mean that, or more like "imminently," or "immanently"
11:41:24 <ehird{> gwern: Nature's four day harmonious rotation!
11:41:32 * dcoutts suggests less heat
11:41:49 <gwern> ehird{: the MAN is trying to hide the square nature of time from us!
11:41:55 <dmwit> lern2spel, pixels, i love corm, no u, wake up sheeple, etc. etc.
11:42:02 <gwern> BMeph: eminently means 'very appropriate'
11:42:02 <dmwit> I know my fair share of stupid memes.
11:42:12 <Arnar> BMeph: I think he meant "eminently"
11:42:17 * gwern is eminently suited to instruct people about english gocab
11:42:18 <gwern> *vocab
11:42:20 <ehird{> dmwit: xtian pretard!
11:42:34 <bos> guys, could you take all the collective dumb and enjoy it in #haskell-blah, please?
11:42:42 <dmwit> Good idea.
11:42:47 <Arnar> *shutting up*
11:42:49 * dcoutts agrees with bos 
11:44:38 <dcoutts> ... and for a moment there was silence, save for the sound of a hundred haskell hackers hacking a hundred haskell programs
11:44:56 <Arnar> do you guys know of any tools that do source-to-source translations on haskell code (via adts)?
11:45:11 <Arnar> sorry.. asts..
11:45:18 <dons> Arnar: template haskell
11:45:21 <dcoutts> Arnar: Language.Haskell.*
11:45:22 <dons> HARE is another one
11:45:26 <Arnar> oh..
11:45:29 <Arnar> @where hare
11:45:30 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/
11:45:35 <Arnar> @where template haskell
11:45:35 <lambdabot> I know nothing about template.
11:45:42 <dons> there's a haskell parser and pretty printer in the standard libraries
11:45:55 <Arnar> is that Language.Haskell.* ?
11:46:11 <dons> dcoutts: http://reddit.com/info/6jz9m/comments/  describes the nested CPR analysis we need to do to get unboxed returns working
11:46:21 <dons> looks not too hard to add to ghc, i must say
11:46:32 <dcoutts> dons: I saw SPJ's comment
11:46:56 <dons> poking around in cprAnal i'm inclined to have a go at it.
11:47:06 <dcoutts> cool :-)
11:47:10 <dons> the paper describes what needs to be done, just that "it is unknown if it is worthwhile"
11:47:10 <ehird{> dons: cpranal - sounds painful
11:47:27 <dons> i've pinged rl about it. see what he says
11:47:47 <dons> strictAnal is worse
11:47:53 <ehird{> dons: ow
11:48:03 <BMeph> Don't poke there, PLEASE! ;p
11:48:15 <ehird{> haskell ast pron
11:50:21 <ehird{> Zoop.
11:52:17 <ehird{> Um.
11:52:19 <ehird{> @help
11:52:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:52:21 <ehird{> Oh good.
11:52:25 <ehird{> My connection didn't die.
11:58:35 <pcc1> is there anything which might cause a ptr returned to a C program to be trimmed to 32 bits on a 64 bit system?
11:58:55 <dons> using the wrong ffi type
11:58:56 <dons> perhaps
11:59:06 <mauke> yeah, could be a declaration mismatch
11:59:36 <pcc1> hmm, this only started happening in 6.8 (was 6.6)
12:01:51 <pcc1> and I am casting between a native pointer type and HsPtr
12:02:49 <twobitwork> can you invoke do notation with an 'else' branch? i.e. f = do {a <- something; if test a then return a else do {b <- something else; return b}
12:02:59 <twobitwork> er, within
12:03:46 <MyCatVerbs> twobitsprite: yeah, that's perfectly kosher.
12:04:16 <MyCatVerbs> twobitsprite: I have code that does exactly that in two or three different places.
12:10:08 <twobitwork> MyCatVerbs: is that the usual way to branch in a do?>
12:10:16 <twobitwork> or is there a better way?
12:11:07 <MyCatVerbs> twobitwork: that's pretty normal, all told.
12:11:47 <MyCatVerbs> twobitwork: only other thing you'd likely do would be to do case x of { True -> do ...; False -> do ...; } which even I think is a little bit twisted. :)
12:12:13 <twobitwork> right... cool, well thanks
12:23:42 <MyCatVerbs> Is anyone capable of explaining the concept of a free algebra in three sentences or less that probably won't give me a headache, please? ;)
12:24:15 <trez> > map (+1) [a,b,c]
12:24:16 <lambdabot>  [a + 1,b + 1,c + 1]
12:25:51 <nolrai_> What are comonads, and why would i use one?
12:27:38 <dolio> Comonads are the categorical dual of monads.
12:28:31 <orbitz> holy cow
12:28:38 <dolio> So, instead of an m, a (>>=) :: m a -> (a -> m b) -> m b, and a return :: a -> m a...
12:28:42 <orbitz> i'm trying to juggle a full bottle of water, an empty bottle of water, and a ball
12:28:45 <orbitz> so hard!
12:29:06 <dolio> You have a w, a (=>>) :: w a -> (w a -> b) -> w b and a coreturn :: w a -> a.
12:29:08 <MyCatVerbs> dolio: oh bloody Hell, adjointness. :(
12:29:47 <MyCatVerbs> dolio: hang on a second. That's a datatype you can escape from, but not necessarily get into? :D
12:30:07 <dolio> More or less.
12:30:12 <hellige> MyCatVerbs: adjointness is the royal road to free constructions...
12:30:52 <sclv_> ok am i off base if i say that a free algebra is a group of stuff that can be stuck together, repeatedly, the operation for sticking them together, and optionally a rule that some chains of stuck stuff are the same as other chains of stuck stuff?
12:30:57 <hellige> and i only found adjoints incomprehensible the first few times. ;)
12:31:26 <nolrai_> so whats like an eqivalint of [] or State, ie a useful comonad?
12:31:32 <MyCatVerbs> hellige: by the way, any ideas on a good book on category theory?
12:31:49 <dolio> One way to think about some comonads is that 'w a' is an 'a' with some context, so coreturn gets the value from the context, and (=>>) takes an a in a context, a function that gets a b from an a in a context, and returns a b in a context.
12:31:56 <sclv_> nolrai_: the reader comonad is an obvious one.
12:31:57 <MyCatVerbs> hellige: last one I tried hurt my head lots and lots. Possibly because I don't know enough of, well, the rest of mathematics to comprehend it.
12:32:19 <hellige> MyCatVerbs: pierce's "for computer scientists" book is a good place to start.
12:32:55 <hellige> i couldn't get through it the first time, but a few years later, i found it really clear and helpful. i'm not sure what changed...
12:33:15 <MyCatVerbs> hellige: like I got introduced to the notion of abstract algebras in the middle of a chapter where actually the author was concentrating on developing the idea of categories themselves. (Algebras and term substitutions forming a category being one of the examples.)
12:33:22 <dolio> @go comonad celular automata
12:33:24 <lambdabot> http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html
12:33:24 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic
12:33:33 <dolio> nolrai_: ^^
12:33:33 <MyCatVerbs> hellige: That, um, didn't help, and really increased my head-explodey coefficient. :)
12:34:12 <dolio> nolrai_: edwardk's revamped category extras has several comonads, too: http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/
12:34:13 <lambdabot> http://tinyurl.com/58ftkr
12:34:22 <hellige> MyCatVerbs: ah yeah, that can be hard. even the pierce book has some of that stuff.
12:34:42 <nolrai_> thanks!
12:34:43 <hellige> i think part of the key for me was just getting familiar with more of the material used in the examples, in other contexts.
12:35:08 <dolio> hellige: I returned to Pierce's book recently, and thought I could understand a fair ammount of it, but I think it's only from picking up bits and pieces of category theory from Haskell papers and the like.
12:35:18 <hellige> yeah, i think that helped me a lot, too.
12:35:21 <dolio> I'm not sure it's that good for learning from scratch.
12:35:42 <hellige> sure. like i said, i found it impossible the first time i tried to read it.
12:36:00 <MyCatVerbs> dolio: bah! The site's called comonad.com, of course it's selling them for the low, low price of only aleph-null installments of just (USD undefined) paid every time someone proves another problem to be NP-complete.
12:36:02 <dolio> I still have no intuition for equalizers and coequalisers.
12:36:37 * MyCatVerbs 's brain melted trying to understand cocones, with the result that adjointness completely passed him by.
12:36:39 <hellige> no, my knowledge is also quite shallow.
12:37:10 <mauke> educational and/or coeducational
12:37:21 <hellige> cones and cocones aren't so bad, informally.
12:37:24 <orbitz> mauke: hai
12:37:31 <hellige> formalizing the notion gets a little confusing.
12:37:54 <dolio> I did finally get why initial algebras and fixed points are related from that book though, so I'll give it that.
12:38:20 <MyCatVerbs> hellige: I got *completely* lost at the formalization stage.
12:39:03 <hellige> yeah, well, the formalization isn't essential, at that point.
12:39:27 <MyCatVerbs> hellige: also what annoyed me was that the textbook I was using kept insisting "no, really, these have practical uses, they model the operations that have to be performed in order to manipulate names in programming languages"... which sounds great, except that they didn't think to actually explain how.
12:39:36 <hellige> getting the idea that a limit is a universal cone is the most important part.
12:39:58 <MyCatVerbs> hellige: given that I had a neural meltdown when the formalization came, I wasn't capable of working out how from first principles on my own. :P
12:40:39 <hellige> yeah, it helps to develop some ability to enjoy the material on its own...
12:40:42 <twobitwork> I think HDBC.Sqlite3 is broken... either that or I'm a complete idiot and can't figure out how to use it
12:40:50 <dolio> One amusement I got from wikipedia that I didn't see introduced in the book so far is that diagrams are actually well defined structures within category theory.
12:40:51 <hellige> practical applications tend to come later.
12:40:54 <dolio> Not just pretty pictures.
12:41:49 <dolio> Of course, he introduces diagrams well before functors, so I guess he couldn't give a formal definition of diagrams (since it involves functors, as I recall).
12:44:29 <MyCatVerbs> hellige: oh sure, I enjoy the theory on its own.
12:44:42 <MyCatVerbs> hellige: it's just that if you're going to promise practical outcomes, please don't tease.
12:45:10 <vincenz> @seen tibbe
12:45:10 <lambdabot> I saw tibbe leaving #haskell-soc, #xmonad, #ghc and #haskell 12d 1h 35m 53s ago, and .
12:45:28 <vincenz> Baughn: ping
12:45:52 <vincenz> Baughn: compiling the 6.8.2 resulted in a bunch of "undeined ..._64" stuf, I'm thinking it was for instructions or some low level IR code
12:46:06 <hellige> MyCatVerbs: agreed
12:46:38 <dolio> He gives the simple functional language example pretty early.
12:46:46 <dolio> With types as objects and functions as arrows.
12:46:58 <dolio> But that doesn't really explain why category theory is very interesting for the subject.
12:48:41 <pcc1> how do I "specify that explicitly" ref: http://tuukka.iki.fi/tmp/haskell-2007-12-16.html#02:17:10
12:48:42 <lambdabot> Title: haskell-2007-12-16
12:58:46 <vixey> > zen
12:58:56 <lambdabot>   Not in scope: `zen'
12:59:15 <dejones> anyone see this page on the haskell wiki: http://www.haskell.org/haskellwiki/Real_World#haskell  --- lol
12:59:16 <lambdabot> Title: Real World - HaskellWiki
12:59:41 <dejones> dons: you'd probably find that page amusing.  :)
12:59:55 <dejones> I did.
12:59:55 <dejones> hehe
13:00:43 <orbitz> dejones: this is what i think of th epage
13:00:44 <orbitz> http://a1.vox.com/6a00e398aeb836000400fad68807510005-pi
13:00:47 <dolio> Chapter 18 is out of date!
13:01:14 <dejones> orbitz: lol, I wish they came with the book.  ;)  that would certainly be a best-seller!!
13:01:42 <Baughn> vincenz: Try pasting it, I'll see if anything looks familiar
13:01:50 <orbitz> dejones: i'd buy 2 copies!
13:02:02 <dejones> orbitz: haha, don't get greedy  :P
13:02:42 <orbitz> greed makes the world go round
13:03:03 <dejones> hehe
13:04:45 <vincenz> Baughn: sorry, no longer @ office
13:04:50 <dejones> http://www.cs.uu.nl/wiki/Techno/ProgrammingLanguageTheoryTextsOnline -- Some good links to free online texts about programming languages.
13:04:53 <lambdabot> http://tinyurl.com/37xq5g
13:06:08 <vixey> ty dejones
13:06:12 <saml> how would you parse nested matching ()'s without using parsec
13:06:27 <dejones> vixey: you're welcome.  I wish I had time to read SPJ's: The Implementation of Functional Programming Languages
13:06:30 <vixey> saml: use a stack
13:06:32 <Baughn> saml: With a counter.
13:06:40 <mauke> with perl!
13:06:44 <vixey> oh Baughn wis
13:06:45 <vixey> wise
13:07:00 <mauke>  "this is (content (more content))." =~ /(\([^()]*+(?:(?1)[^()]*+)*+\))/ or die; "got [$1]"
13:07:18 <vixey> when you don't have elements to store a stack becomes a single integer
13:07:18 <saml> i mean, is this a one liner with fold ?
13:07:18 <Baughn> ..that's write-only code if I've ever seen any
13:07:32 <vixey>  mauke o_o
13:07:35 <Baughn> saml: It could be. How long lines are you comfortable with?
13:07:42 <vixey> what's ?1 and ?: ?
13:07:48 <mauke> perldoc perlre
13:07:56 <vixey> `:(((((
13:09:03 <vixey> saml: exactly what result do you want?
13:10:05 <saml> i was just wondering if it's something obvious that i was missing.
13:10:18 <vixey> ?
13:10:38 <vixey> parse "(())" ~> True, or Par [Par []] or.. ?
13:10:45 <saml> i think i can do it a long version
13:13:36 <Baughn> saml: fold threads a state variable through a list parser of some kind - any will do, so long as it doesn't need lookahead/backtracking. This one doesn't, so..
13:14:01 <vixey> still
13:14:02 <Baughn> saml: Obviously fold will work. Whether it's a good idea is a different matter - it's probably superior to explicit recursion, but that's not saying much.
13:14:05 <vixey> what are you doing?
13:14:25 <vixey> there's a big difference depedning on the output ....
13:15:51 <saml> i am trying to write joy interpreter in this lisp like language i implemented in haskell
13:16:23 <saml> my language doesn't have parser combinator. but it has fold. that's why i asked :)
13:16:38 <vixey> saml
13:16:44 <vixey> do you want parse "(())" ~> True, or Par [Par []] or.. ?
13:17:59 <saml> i want tp parse "( ( ) )" as "( ( ) )"  . no ADT. so i need to store everything back as string.
13:18:21 <saml> no, actually, "(  (   ) )"  as "(  )"  peeling one top layer
13:18:28 <saml> ah this is easier!
13:18:47 <saml> well. not really if I want to verify parens match.
13:19:13 <vixey> then just count '(' == count ')' and that there is '(' befor any ')'
13:19:18 <Baughn> saml: That's one thing, but what do you want to happen if someone enters ")("?
13:19:33 <saml> _|_ yay
13:19:41 <stevan> use a stack. push every "(" and then pop at ")".
13:20:00 <Baughn> Use a counter, I say. Keep it to constant space usage
13:20:10 <Baughn> (Or, okay, logarithmic)
13:20:42 <twobitwork> man, I hate SQL...
13:20:56 <Baughn> twobitwork: Look on the bright side..
13:21:13 <twobitwork> is there some kind of database library (C or Haskell) which has a straight forward interface other than just passing strings or SQL code?
13:21:24 <twobitwork> Baughn: where's that?
13:21:30 <Baughn> twobitwork: I'm thinking
13:21:33 <twobitwork> lol
13:21:45 <Vq^> twobitwork: yes
13:21:46 <Baughn> At least it isn't object-relational?
13:21:59 <twobitwork> Baughn: what is that even supposed to mean, and how is it a good thing
13:22:00 <twobitwork> ?"
13:22:00 <lambdabot> Maybe you meant: . ? @ v
13:22:07 <twobitwork> lambdabot: shutup
13:22:17 <Vq^> Baughn: yeah, we better switch to ZODB :)
13:22:38 <Baughn> twobitwork: Every object-relational mapping I've yet seen gets only the intersection of SQL and OO's features. It's a small intersection.
13:23:09 <Baughn> A proper relational database can be a work of art. ORM.. not so much
13:23:15 <Vq^> one bright side might be advanced optimization for complex queries, but it really could do with a better interface :/
13:24:09 <Baughn> Vq^: That'd only be a bright side if I didn't spend more time tweaking the queries to make them optimize well than I'd spend on writing the query program directly
13:24:51 <Vq^> Baughn: what implementation do you use?
13:25:02 <Baughn> Vq^: Oracle, mostly
13:25:15 <Vq^> Baughn: ok, never used that myself
13:25:50 <Baughn> Vq^: The others are more predictable mostly because they do less optimization. Given that sometimes it's pessimization instead, I'm not so sure I wouldn't prefer that
13:26:04 <Baughn> Vq^: But we need to enforce db integrity, so..
13:26:08 <Vq^> Baughn: the others being?
13:26:21 <Baughn> So far, only tried postgresql and mysql
13:26:54 <Vq^> oh yeah, mysql is a sql these days :)
13:27:31 <Baughn> I'm still waiting for a relational database. ;)
13:29:10 <Vq^> postgres does quite interesting query planning
13:31:04 <Vq^> it uses some genetic algorithm for optimizing the query when doing more complex queries
13:31:44 <vixey> Baughn what's a relational database
13:32:06 <geezusfreeek> vixey: perhaps something more like datalog?
13:32:15 <Baughn> vixey: One that allows me to specify arbitrary relations between any two facts
13:32:31 <vixey> Baughn, in haskell, or otherwise?
13:32:36 <Baughn> vixey: Irrelevant
13:32:51 <geezusfreeek> Baughn: is datalog along the lines of what you want?
13:32:53 <vixey> Baughn, have you seen kanren?
13:33:13 <Vq^> Baughn: like some sort of extended prolog?
13:33:34 <Baughn> geezusfreeek: Hm. Yes.
13:34:03 <geezusfreeek> Vq^: datalog :) well, it's more of a subset than a superset, but yeah
13:34:18 <Baughn> vixey: No
13:34:29 <Vq^> geezusfreeek: never heard of it
13:35:14 <geezusfreeek> if you know prolog you know datalog
13:35:25 <geezusfreeek> essentially, anyway
13:39:31 <vixey> Baughn, it might suit not sure
13:40:25 <ptolomy2> Anyone how StablePtr compares to IORef, performance-wise?
13:41:37 <Lemmih> ptolomy2: Are StablePtr's related to IORef's?
13:42:08 <ptolomy2> Both are ways of handling reference semantics, but StablePtr doesn't get GCed or moved around.
13:43:11 <dcoutts> ptolomy2: I think you're confused about their purposes
13:43:17 <Lemmih> ptolomy2: An IORef is a mutable cell. A StablePtr is a stable referrence to an object.
13:43:25 <ptolomy2> Ah.
13:43:26 <dcoutts> I can't think of any case where the two might be interchangeable
13:43:26 <ptolomy2> Right.
13:43:41 <dcoutts> ptolomy2: StablePtr is for passing to foreign code
13:43:43 <ptolomy2> Of course.
13:43:43 <twobitwork> Vq^: you said "yes" earlier... where you saying there are database engines that don't use sql?
13:44:18 <dcoutts> and being able to still get back the reference to the (movable) Haskell object later when the C code passes the StablePtr back to us
13:44:28 <Vq^> twobitwork: thats exactly what i meant
13:44:33 <twobitwork> Vq^: what are they?
13:45:23 <Vq^> twobitwork: ZODB and axiom is the only ones i have worked with
13:45:30 * twobitwork googles
13:46:04 <Vq^> twobitwork: http://divmod.org/trac/wiki/DivmodAxiom <- probably harder than zodb to google ;)
13:46:06 <lambdabot> Title: DivmodAxiom - Divmod - Trac
13:47:28 <twobitwork> lol... potatoe programming :P
13:47:40 <sclv_> there are also db engines for xml, and for time-streaming data that use different languages...
13:47:47 <twobitwork> anyways, they're both python-centric... any idea how they would be useful from haskell?>
13:51:28 <twobitwork> the problem is that all of the sqlite bindings I've found for haskell are either fairly broken, or I don't know how to use them
13:51:38 <twobitwork> and I just really hate sql
13:55:35 <dons> twobitwork: so one had a bug that looked easy to fix.
13:55:42 <dons> twobitwork: do you know sqlite3?
13:55:58 <dons> you could use the galois binding, which is a pretty thin veneer over sqlite's api, if you know it.
13:56:16 <dons> otherwise, i'd suggest feeding back  your results to the authors
13:57:06 <twobitwork> dons: its not just that bug... but it seems as though the documented feature of parameterized queries doesn't work
13:57:21 <dons> did you raise it with the author?
13:57:32 <dons> ask on the mailing list, please. haskell-cafe@haskell.org
13:57:42 <dons> since unless this issues are resolved, forward progress stalls
13:57:58 <twobitwork> in other words: st <- prepare db "select * from table where id = '?'" ["foo"] -- doesn't work even though it seems like it should
13:58:10 <twobitwork> ok, I'll do that
13:58:30 <twobitwork> can you look at the docs and tell me if I'm just misunderstanding it first though?
13:58:54 <twobitwork> http://hackage.haskell.org/packages/archive/HDBC/1.1.4/doc/html/Database-HDBC.html#v%3Aprepare
13:58:55 <lambdabot> http://tinyurl.com/5ro4vd
14:00:29 <dons> http://reddit.com/info/6jzyc/comments/ interesting.
14:00:51 <dons> cool. talk to the HDBC author. you can reach them via haskell-cafe@.
14:01:06 <nolrai_> Arrrggg drawPixBuf has 2 extra Int args, that the docs dont describe at all. What do they do? why are they there?
14:01:23 <dmwit> twobitwork: That looks ill-typed.
14:01:42 <dmwit> twobitwork: (i.e. like it doesn't even compile, let alone run)
14:02:09 <dmwit> twobitwork: I think (from the docs) that the extra ["foo"] parameter should get sent to "execute", not "prepare".
14:02:43 <ndm> @seen dcoutts
14:02:44 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #haskell-blah, #ghc and #haskell. I last heard dcoutts speak 2m 23s ago.
14:03:08 <ndm> dcoutts, i disagree with your comment on the security thing - "As for users downloading bad packages, perhaps we should ask why they  might be more likely to download and run an unknown package from hackage..."
14:03:31 <ndm> the answer is because Haskell users promote it, the tools work with it, and its promoted as a feature of haskell
14:03:32 <dons> what can we do about it, ndm?
14:03:45 <dons> it affects every package system in existence.
14:03:55 <ndm> dons: i didn't say i had a solution, merely that we have to accept that being on hackage _does_ imply some level of trust
14:04:03 <dons> some level, yeah.
14:04:12 <dons> we remove things for example. and a real person was involved
14:04:15 <ndm> i think that level of trust is fairly high
14:04:48 <ndm> the fact that at the moment anyone can upload rmrf and call it "uniplate" is seriously bad
14:05:05 <ndm> but even once that is patched, there will still be some trust
14:05:36 <twobitwork> dmwit: sorry, I actually have prepare db "select * from table where id = '?'" [toSql "foo"]
14:05:53 <dmwit> twobitwork: Does it compile?
14:06:02 <dmwit> twobitwork: If so, those docs are out of date.
14:06:06 <twobitwork> it doesn't give me type errors in ghci...
14:06:17 <twobitwork> gives me: *** Exception: (unknown)
14:06:29 <ndm> dons: we could apply the lambdabot checks to validate some things automatically - i wonder how many things would go through...
14:06:32 <Heffalump> twobitwork: use `catchSql` (fail . show) to print out those errors, if this is HSQL
14:06:53 <twobitwork> this is HDBC
14:06:57 <Heffalump> ok, well it might still work
14:07:04 <Heffalump> dynamic exceptions in general are a pain like that
14:07:13 <Heffalump> you might need to find an equivalent of `catchSql` for HDBC
14:07:22 <Heffalump> or use a catchJust and find out what type you need to catch
14:07:55 <dmwit> twobitwork: Can you try :t prepare in ghci and see if it matches what's in the docs?
14:08:37 <christastrophe> is there a standard way to convert a list of
14:08:37 <christastrophe> a
14:08:44 <christastrophe> to a tuple of as
14:08:50 <twobitwork> heh... no it doesn't, but again I'm misrepresenting... its the execute step which accepts the parameters and that's what I'm doing
14:08:56 <dmwit> christastrophe: Only if you know, a priori, the length of the list.
14:09:25 <christastrophe> dmwit: and if you do have the length?
14:09:25 <twobitwork> here is what I have in my ghci window, to be precise: quickQuery db "select * from cards where name = '?'" [toSql "asdf"]
14:09:45 <dmwit> christastrophe: Something like (\[a, b, c] -> (a, b, c)) should work.
14:09:58 <dons> ndm, hmm. a linter for safe things. interesting
14:10:15 <dons> ndm, we could do this by trying to type check the src in a constrained environment
14:10:17 <ndm> dons: just thinking what of mine it would succeed on, sadly i think the answer is virtually nothing...
14:10:18 <christastrophe> oh so you have to bind every list element to an argument in the converting function....
14:10:18 <twobitwork> here's what I get when I catchError: *** Exception: user error (SqlError {seState = "", seNativeError = -1, seErrorMsg = "In HDBC execute, received [SqlString \"asdf\"] but expected 0 args."})
14:10:23 <christastrophe> thats not what I was hoping for
14:10:39 <twobitwork> shouldn't it expect 1 arg because I have 1 question mark?
14:11:25 <dmwit> You quoted the question mark.
14:11:28 <dmwit> That makes it a string.
14:11:32 <dmwit> ;-)
14:11:42 <twobitwork> doh!
14:11:45 <ndm> we could have a "this user has also uploaded n other packages" - if a user is going to root the system, they are unlikely to first write several libraries
14:12:03 <twobitwork> something as simple as that.... *sigh*
14:22:15 <sw17ch> i'm trying to build the sqlite package in windows, but i'm having some issues.. any one available to help?
14:27:00 <twobitwork> sw17ch: I had no problems in linux using cabal... but I've never built haskell packages in windows...
14:28:11 <sw17ch> twobitwork: yeah, i can make it work fine in linux
14:28:33 <sw17ch> i want to use it as a demo for application development at work, but if i can't get the packages to go together... :)
14:30:04 <sw17ch> well, perhaps it would help to figure out why it's asking me for the sh command
14:30:35 <sw17ch> C:\Users\John\Downloads\sqlite-0.4.1>runhaskell Setup.hs configure
14:30:35 <sw17ch> Configuring sqlite-0.4.1...
14:30:35 <sw17ch> Setup.hs: Cannot find: sh
14:31:26 <dons> dcoutts: using strict maybe in Lazy.readInt shaves 20% off the runtime of the sum-file benchmark
14:31:53 <dolio> Impressive.
14:35:45 <dons> i think i can see how to match clean here now.
14:36:12 <dons> ah, and 6.9 does a better job again
14:36:31 <dons> yeah, another 10% faster in 6.9
14:36:33 * Botje was wondering if the fromString method can be used to typecheck printf-like functions
14:36:37 <dons> so down from 1.3s to 0.8
14:37:15 <dmwit> You know, if things keep getting faster by 10-15% on each compiler release, ...
14:37:32 <Botje> things will start taking negative time in 2050!
14:37:47 <Botje> underheating will become a big problem!
14:37:49 <dmwit> dons: Also: 1.3s to 0.8s... isn't that more like 40% drop than a 10% drop?
14:38:02 <dmwit> Botje: Yikes!
14:38:13 <dmwit> I'll start a fire RIGHT NOW!
14:38:19 <Saizan> sw17ch: well, it's simple, it uses a configure script to find the C sqlite libraries to bind to, you probably want to install msys
14:38:24 <Botje> :)
14:38:27 <mauke> > (1.3 - 0.8) / 1.3
14:38:32 <sw17ch> ah, finally got sqlite to build in windows...
14:38:37 <lambdabot>  0.3846153846153846
14:38:40 <sw17ch> i didn't realize the sqlite sources were necessary
14:38:48 <mauke> > (1.3 - 0.8) / 1.3 :: Rational
14:38:49 <lambdabot>  5%13
14:38:51 <sw17ch> err, the sqlite hackage package
14:40:11 <saml> can I define multiple modules in a file?
14:40:49 <dejones> dons: how to match Clean?
14:40:51 <Baughn> > 3.14 :: Rational
14:40:53 <lambdabot>  157%50
14:41:29 <ziman> > (sqrt 2) :: Rational
14:41:30 <lambdabot>   add an instance declaration for (Floating Rational)
14:41:30 <lambdabot>     In the expression: ...
14:42:11 <vixey> > map (%) . iterate (\(x,y)->(y,x+y)) $ (0,1)
14:42:17 <lambdabot>   add an instance declaration for (Integral (t, t))
14:42:39 <vixey> > map (realToFrac . uncurry (%)) . iterate (\(x,y)->(y,x+y)) $ (0,1)
14:42:40 <lambdabot>  [0.0,1.0,0.5,0.6666666666666666,0.6,0.625,0.6153846153846154,0.6190476190476...
14:45:52 <zoq> @src (%)
14:45:52 <lambdabot> x % y = reduce (x * signum y) (abs y)
14:46:36 <gwern> Botje: how does things getting faster by 10% ever result in a negative timing? :)
14:46:57 <zoq> @src reduce
14:46:57 <lambdabot> reduce _ 0 = undefined
14:46:57 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
14:46:57 <lambdabot>     where d = gcd x y
14:47:01 <gwern> dmwit: if things keep getting faster by 10%, at some point we'll no longer care by amdahl's law
14:47:04 <Botje> i'm surprised it took this long for someone to say it.
14:47:49 <gwern> Botje: maybe I'm the only one who pays attention to you
14:48:00 <dmwit> Botje: Everybody else got the joke. ;-)
14:48:05 <Botje> let us dismiss this observation as pure fiction :)
14:48:30 <dmwit> Oh, *zing*!  gwern, you just got BURNT!
14:49:20 <gwern> dmwit: I believe Botje is more crispy than I
14:49:39 <gwern> rolled as he is in the kernel's 11 secret spices
14:50:24 <ziman> where is (%) ?
14:50:31 <dmwit> Data.Ratio
14:50:37 <ziman> thanks
14:50:38 <gwern> @hoogle (%)
14:50:38 <dmwit> Also:
14:50:38 <lambdabot> Data.Ratio.(%) :: Integral a => a -> a -> Ratio a
14:50:40 <dmwit> ?index (%)
14:50:40 <lambdabot> Data.Ratio
14:53:00 * Botje is crispier than a freshly baked lambda
14:53:07 <dejones> im hungry
14:53:52 <gwern> so am I, which is why I was thinking of crispy spices
14:54:20 * dejones needs to go to the gym before eating dinner...
14:56:18 <dejones> I am having issues with Control.Parallel, ghc can't find it, but I have the parallel-1.0.0 module exposed from my ghc-pkg list
14:56:21 <dejones> any ideas?
14:56:46 <dejones> Control.Parallel is imported in my module, but ghc doesn't find it, so the compilation fails...
14:57:57 <gwern> dejones: using -make?
14:58:35 <dejones> gwern: just ghc -o Main Main.hs
14:59:52 <ziman> an interesting comic: http://www.lisperati.com/landoflisp/ ;) (~64 panels)
15:00:04 <vincenz> ziman: old story
15:00:07 <dejones> gwern: Main.hs:11:0:
15:00:07 <dejones>     Failed to load interface for `Control.Parallel':
15:00:07 <dejones>       locations searched:
15:00:07 <dejones>         Control/Parallel.hi
15:00:07 <dejones>         Control/Parallel.hi-boot
15:00:09 <gwern> dejones: I'd try throwing in a -make to see if it helps
15:00:24 <dejones> gwern: any idea why it is looking for the *.hi file? and not the *.hs?
15:00:44 <gwern> not really
15:01:17 <vincenz> dejones: that's how it works
15:01:22 <vincenz> dejones: it looks for compiled dependencies
15:01:24 <dejones> gwern: same error with --make
15:01:43 <vincenz> dejones: 1) do you have it compiled (Control.Parallel)
15:01:49 <vincenz> dejones: 2) are yo trying to build a profiled version?
15:01:59 <dejones> vincenz: oh yah...  Control.Parallel is not compiled, I don't think
15:02:09 <int-e> dejones: parallel is not a core library in ghc anymore, it's an extra library
15:02:18 <vincenz> dejones: might want to do that
15:02:22 <gwern> well, trying to build parallel would make the error 'Control/Parallel.hi_p' or somethinig I think
15:02:28 <int-e> so it's possible that it wasn't installed / compiled / whatever.
15:02:31 <vincenz> gwern: true
15:02:34 <gwern> *build with profiling
15:02:38 <dejones> int-e: yah, I did darcs get to get all of ghc, then downloaded parallel-1.0.0 separate
15:02:51 <dejones> ty
15:07:52 <roconnor> @src <$>
15:07:53 <lambdabot> f <$> a = fmap f a
15:08:57 <roconnor> @vixen welcome back
15:08:57 <lambdabot> Beer, it's so much more than just a breakfast drink!
15:12:52 <ehird{> Hm.
15:12:59 <ehird{> Is it easy to write a shared library for haskell?
15:13:04 <ehird{> Like, I have some functions used in multiple binaries.
15:13:10 <ehird{> Should I make a shared library?
15:13:13 <Baughn> Hm
15:13:17 <chessguy> 'evening, #haskellers
15:13:19 <Baughn> Not so much.. "not easy", as "impossible"
15:14:04 <ehird{> Baughn: Okay. How should I do it?
15:14:10 <ehird{> including these functions in each binary would be wasteful
15:14:14 <nomeata> gwern: ping
15:14:30 <Baughn> ehird{: True, but we're only talking a few megabytes at most here
15:14:42 <chessguy> @type do g <- get; (x, g') <- return $ random g; put g'; return x
15:14:46 <lambdabot> forall t (m :: * -> *) a. (RandomGen t, Random a, MonadState t m) => m a
15:14:46 <ehird{> Baughn: Hahaha.
15:14:49 <Baughn> ehird{: Someone is working on shared library support, somewhere. Until then, stick to linking statically.
15:15:16 <Baughn> ehird{: (I think ghc 6.10 is supposed to have that feature. Or maybe it'll be 6.12)
15:15:22 <ehird{> Baughn: Hehehe. Okay then
15:15:29 <chessguy> @undo do g <- get; (x, g') <- return $ random g; put g'; return x
15:15:29 <lambdabot> get >>= \ g -> return $ random g >>= \ (x, g') -> put g' >> return x
15:15:30 <Baughn> ehird{: Also, you can do something similar with hs-plugins, but that's not really stable yet
15:17:32 <Baughn> ehird{: 6.10, I'd say - I see some shared-library support in ghc head already.
15:20:34 <dcoutts> dons: you know e `seq` does nothing
15:20:49 <dons> oh, did that slip in.
15:21:07 * dons wants strict pairs for bytestring.
15:21:17 <dons> all these lazy pairs/ lazy maybes mess up things
15:21:27 <chessguy> @undo do foo <- bar;
15:21:27 <lambdabot>  Parse error at end of input
15:21:38 <chessguy> @undo do foo <- bar; return foo
15:21:38 <lambdabot> bar >>= \ foo -> return foo
15:21:56 <Baughn> > undefined `seq` 2
15:21:58 <lambdabot>  Exception: Prelude.undefined
15:22:18 <dcoutts> dons: I do wonder sometimes what you think -funbox-strict-fields apples to in bytestring
15:22:34 <tchakkazulu> @. pl undo do foo
15:22:34 <lambdabot> foo
15:22:39 <dcoutts> dons: try comparing the core with it on and off. I bet it makes no difference.
15:22:40 <dons> we use UNPACK don't we.
15:22:43 <tchakkazulu> @. pl undo do foo <- bar; return foo
15:22:44 <lambdabot> bar
15:22:49 <dcoutts> dons: exactly
15:22:55 <dons> right. if we're using UNPACK consistently, then it does nothing.
15:23:28 <dcoutts> dons: why do we use -fcpr-off ?
15:23:31 <dons> it is useful when i play around with micro optimisations (like returning local monomorphic strict pairs), since i usually forget UNPACK
15:23:42 <dons> so ndp does that. i'm waiting to hear back from rl about it.
15:23:48 <dons> i suspect it should actually be on...
15:23:53 <Baughn> tchakkazulu: That one follows from a monad law. It isn't necessarily always true.. though if it isn't, you have valid reason to yell at the author.
15:24:14 <dcoutts> dons: aye
15:24:32 <dons> but i want to find out why rl disables it. intuitively, i'd have thought we really need it
15:24:49 <kencausey> I'm trying to use haskell-mode in xemacs and I wonder if I'm missing a dependency for 'run-with-idle-timer and 'cancel-timer
15:25:07 <dons> dcoutts: -optc-O2 makes sense though
15:25:15 <dcoutts> dons: sure
15:25:26 <dons> however, i'm concentrating on uvector for the heavy optimisation stuff for now
15:25:30 <dons> bytestring is a bit too complex.
15:25:46 <dcoutts> :-)
15:25:59 <dcoutts> we still need to convert it to streams some time
15:26:04 <dons> yep
15:26:19 <chessguy> kencausey: what problem are you having?
15:26:52 <kencausey> chessguy: Well, I'm trying to figure out how to use haskell-doc-mode for example and getting errors about unknown function cancel-timer
15:27:11 <chessguy> kencausey: oh, hm. i haven't tried that one
15:27:24 <chessguy> kencausey: what's it bound to? i'll try it here
15:27:44 <kencausey> chessguy: which 'it' do you mean?
15:27:45 <Baughn> kencausey: It's a base function -provided by emacs itself.
15:27:56 <dons> dcoutts: its surprising that Pair (I# i) (I# j) doesn't get the CPR atm, due to being nested
15:27:58 <kencausey> I can't find it in the lispref manual
15:28:03 <dons> you'd think they'd want to solve that.
15:28:09 <Baughn> kencausey: http://www.delorie.com/gnu/docs/elisp-manual-21/elisp_690.html <-- Here you go
15:28:11 <lambdabot> Title: GNU Emacs Lisp Reference Manual
15:28:13 <kencausey> And as I say, Xemacs 21.4.21 doesn't like it
15:28:17 <dons> but it explains why Pair {-# UNPACK #-} !Int .. works
15:28:23 <Baughn> Oh, xemacs...
15:28:30 <chessguy> kencausey: invoking the haskell-docs-mode
15:28:44 <dcoutts> dons: as SPJ said, it's about general function calls inside the product fields
15:28:49 <dons> yeah.
15:28:56 <Baughn> kencausey: http://github.com/hober/erc/tree/master%2Ferc-compat.el?raw=true <-- This might be useful
15:28:57 <dons> i'd be happy with explict constructors, as SPJ says
15:29:00 <dons> i think that's enough
15:29:01 <Baughn> kencausey: But you really want to use emacs, not xemacs
15:29:20 <dcoutts> dons: though since we know the thing is used in one place and in a strict context then the transform should be ok
15:29:26 <kencausey> OK
15:29:51 <dcoutts> dons: and of course in this case both args are explicit constructors anyway
15:34:38 <dcoutts> Cale: are you back into community.h.o? I note there are a lot of defuct processes that look like they belonged to lambdabot
15:35:01 <dcoutts> like ~30
15:35:19 * Baughn wonders why they're called "defunct" and not "zombies". Political correctness?
15:36:01 <dcoutts> heh
15:36:20 <dcoutts> Baughn: defunct processes don't eat your brains
15:36:53 <Baughn> dcoutts: Perhaps not, but they do eat my core
15:37:35 <dmwit> Bah, \bot!
15:37:38 <dmwit> Why did you leave?
15:37:56 <vixey> hi dmwit
15:38:05 <dmwit> Hi, vixey.
15:38:10 <vixey> ?where ?where
15:38:10 <mauke> Cheiron: @part #haskell
15:38:10 <Cheiron> ?where ?where
15:38:15 <vixey> eheh
15:38:16 <lambdabot> ?where ?where
15:38:22 <dmwit> vixey: Too slow. =)
15:38:23 <lambdabot> ?where ?where
15:38:39 <Cale> lambdabot left because I was killing off the dead version and nuked the live one while I was at it
15:38:50 <ehird{> LAMBDABOT
15:38:50 <ehird{> OMFG
15:38:54 <ehird{> :DDDDDDDDDDDDDDDDDDDDDDDDDDDDD
15:38:54 <vixey> hey Cale
15:38:55 <ehird{> @botsnack
15:38:58 <Cale> hi
15:38:59 <ehird{> ...
15:39:00 <ehird{> @botsnack
15:39:01 <dcoutts> Cale: thanks :-)
15:39:04 <ehird{> @bot
15:39:05 <lambdabot> :)
15:39:10 <Cale> np
15:39:11 <lambdabot> :)
15:39:14 <ehird{> np
15:39:18 <ehird{> oh
15:39:18 <ehird{> heh
15:39:21 <Baughn> I can't help but notice that lambda's even worse lagged than usual
15:39:21 <ehird{> slow lambdabot is slarba
15:39:22 <ehird{> err
15:39:23 <ehird{> hahhah
15:39:26 <lambdabot> Plugin `dummy' failed with: thread killed
15:39:52 <vixey> Cale: do you think it would be fun to have @cata data Maybe a = Nothing | Just a print out the type and catamorphism for that type
15:40:03 <Cale> sure
15:40:18 <gwern> hm. wonder what nomeata wanted while I was having dinner
15:40:35 <vixey> I got simple algebraic types done
15:40:52 <vixey> I don't think it's correct for mutually recursive types and some other complexities though
15:42:43 <vixey> then again
15:43:03 <vixey> data Spam = A | B | C | D | ... | Z would take up lots of lines
15:47:13 <nolrai_> Set should be a monad, right?
15:47:41 <Cale> It's a monad on a subcategory of Haskell types
15:48:14 <nolrai_> er imean the type constructor not the catagory.
15:48:37 <Cale> Yeah, I mean the type constructor too.
15:49:00 <Cale> The type constructor Set is a monad on not the full category of Haskell types, but the subcategory of types that are in Ord.
15:49:13 <nolrai_> oh read your "a" as a "the"
15:49:19 <nolrai_> oh, right.
15:49:46 <Cale> (which is the reason that it can't be made an instance of Monad)
15:50:47 <nolrai_> hmm.  thats annoying.  I want to use do notation for Set.
15:51:54 <Cale> The problem is that the type of bind, if it were admitted, wouldn't prevent you from trying to construct sets of elements not in Ord
15:52:21 <Cale> For example...
15:52:44 <nolrai_> Yeah, and that *IS* a real problem. like (return id)
15:53:00 <Cale> Sure, or liftM const
15:53:10 <vincenz> :t return id
15:53:15 <vincenz> :t lftM const
15:53:19 <dmwit> nolrai_: You can make a list monad with a "prune" action.
15:53:25 <lambdabot> thread killed
15:53:28 <vixey> what does prune do?
15:53:30 <dmwit> prune = nub
15:53:31 <lambdabot> thread killed
15:53:31 <vixey> Hi augustss
15:53:35 <augustss> hi
15:53:40 <vincenz> @bot
15:53:40 <lambdabot> :)
15:53:44 <lilac> :t id
15:53:45 <vixey> @let prune = nub
15:53:47 <lambdabot> <local>:1:8:     Ambiguous type variable `a' in the constraint:       `Eq a' ...
15:53:47 <lambdabot> forall a. a -> a
15:53:51 <vincenz> :t return id
15:53:52 <vixey> :(
15:53:53 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> a)
15:53:53 <tessier_> Has anyone in the Haskell/Erlang world looked back at the old Connection Machines computers and thought about what sort of things might be possible with something like a bunch of Arm A-9 cores on the same amount of silicon as a modern Xeon/Opteron quad core cpu uses?
15:53:53 <vincenz> @undef
15:53:54 <lambdabot> Undefined.
15:53:57 <vincenz> @unlet
15:53:58 <lambdabot> Defined.
15:54:45 <nolrai_> that might work better, cause i can make the prune smart. or maybe not
15:54:47 <augustss> tessier: such thought were popular in the 80s
15:54:56 <Cale> If I was going to do something serious with nondeterminism, I'd probably use the LogicT in Hackage at this point.
15:55:19 <roconnor> what's a good infix mathmatical symbol for map?
15:55:24 <vixey> Cale have you ever implemented typed logical variables?
15:55:29 <lilac> would it be possible to define a restricted monad typeclass (with a restriction on the monad's contained type, like Ord)
15:55:29 <dmwit> roconnor: <$>
15:55:31 <Cale> tessier_: Have you seen the new Reduceron stuff? I don't know much about the CM architecture.
15:55:32 <vixey> roconnor: How about . ?
15:55:34 <roconnor> er fmap
15:55:40 <dibblego> I use |> then ||> for liftM2, etc.
15:55:46 <dmwit> roconnor: Or, yeah, (.) is nice.
15:56:04 <roconnor> I think midcircle is too confusing
15:56:24 <Saizan> lilac: see e.g. rmonad on hackage for one of the ways
15:56:27 <vincenz> midcircle?
15:56:33 <roconnor> vincenz: ring
15:56:39 <Cale> lilac: Sure, you can define an OrdMonad class, for instance.
15:56:40 <roconnor> whatever people call composition
15:56:43 <vincenz> dot
15:56:47 <Cale> \circ
15:56:49 <roconnor> it's not a do
15:56:49 <Cale> ;)
15:56:51 <roconnor> dot
15:56:54 <ehird{> spot
15:56:58 <vincenz> point
15:57:00 <Cale> blotch
15:57:02 <ehird{> but then I call @ whirlpool
15:57:03 <ehird{> intercal!
15:57:07 <roconnor> and I think <$> is silly.
15:57:13 <roconnor> I already use @ for ap
15:57:17 <vincenz> roconnor: syntax is silly
15:57:20 <nolrai_> I just want to find all the end points of a graph connected to the point i have (endpoints = vertex with one edge)
15:57:41 <Cale> nolrai_: You can always go via the list monad.
15:57:41 <roconnor> vincenz: yep, but we gotta communicate.  Don't worry,  it is defined in a macro so we can change it anytime.
15:57:52 <tessier_> Cale: Reduceron? No. Got a link? The CM architecture was quite cool. I've been reading about it lately. http://www.longnow.org/views/essays/articles/ArtFeynman.php talks about it. As does the book "The Connection Machine" which I just bought a used copy of.
15:57:53 <lambdabot> Title: Long Now: Views: Essays
15:57:57 <tessier_> Tons of links on the net about it.
15:58:10 <Cale> http://www-users.cs.york.ac.uk/~mfn/reduceron2/ -- the paper
15:58:10 <lambdabot> Title: The Reduceron
15:58:35 <Cale> http://video.google.ca/videoplay?docid=-1518197558546337776&q=Reduceron&ei=CAYySJjTIpLw-gHntujmCQ
15:58:36 <lambdabot> Title: reduceron.mov, http://tinyurl.com/64pavs
15:58:37 <Cale> a talk
15:59:05 <tessier_> Cale: Cool, I'll check them out.
15:59:18 <tessier_> I wish it were possible to get VLSI type performance out of FPGA.
15:59:59 <dmwit> > let x >>=' y = 3 in 'h' >>=' 'i'
15:59:59 <lambdabot>  Improperly terminated character constant at "'" (column 10)
16:00:06 <dmwit> too bad
16:00:32 <roconnor> ♂ is vaugely tempting
16:00:56 <augustss> tessier: with an FPGA you pay to have a digital abstraction.  With ASIC and even more custom design you have to do a lot of analog stuff.
16:00:58 <vixey> > let x >>>= y = 3 in 'h' >>>= 'i'
16:01:01 <lambdabot>  3
16:01:06 <vixey> whoosh
16:03:04 <nolrai_> hmm i think the set thing was just a distraction.  It wouldn't solve what i wanted it too any way.
16:05:51 <chessguy> @pl \p c -> j (P (t c) p) c
16:05:51 <lambdabot> join . (j .) . flip (P . t)
16:05:55 <chessguy> lovely
16:06:14 <vixey> what doseethis mean?
16:06:15 <vixey> Setup: At least the following dependencies are missing:
16:06:16 <vixey>     arrows -any, plugins >=1.0, oeis -any, numbers -any
16:06:16 <vixey> [~/Code/Haskell/lambdabot] % cabal install arrows
16:06:16 <vixey> All requested packages already installed. Nothing to do.
16:07:33 <vixey> oh
16:07:35 <dcoutts> vixey: Setup use --global by default
16:07:39 <Cale> vixey: I'm not really sure, but cabal has an annoying habit of treating locally installed and globally installed packages separately.
16:07:44 <vixey> sorry, nevermind, cabal install lambdabot worked fine
16:07:55 <dcoutts> cabal-install now uses --user by default
16:08:03 <dcoutts> Cale: that's ghc really, not Cabal
16:08:08 <Cale> ah, okay
16:08:08 <vixey> hmmm
16:08:20 <vixey> How do I edit the code though if I compiled something with cabal?
16:08:22 <Cale> Is there any plan to fix it so that it always looks everywhere?
16:08:41 <dcoutts> Cale: the only thing we can do is default to per-user installations or global
16:08:46 <vixey> ty that works too
16:08:59 <dcoutts> Cale: it's not possible to look in the user db if you're going to install globally
16:09:43 <dcoutts> Cale: and the old default was global installs. That's why we changed it for cabal-install, to make it more convenient, user installs by default, no permissions problems etc.
16:09:47 <Cale> Is that because packages might be needed for more than compilation?
16:10:08 <dcoutts> Cale: well, I guess it'd be possible for binaries, but it's not possible for libraries
16:10:30 <jmei> i have ghc6.8.2 installed via a deb, i dont have cabal. any ideas?
16:10:30 <halberd> in my very first programming courses in high school there was some emphasis on writing "dummy loops" that went through the control structure but didn't do anything
16:10:37 <halberd> as a way of organizing your program
16:10:46 <halberd> does this have any analogue in functional programming?
16:10:53 <nolrai_> fmap
16:10:54 <vixey> halberd: yes very important one infact
16:10:59 <ivanm> wtf? why would you do that?
16:10:59 <nolrai_> maybe?
16:11:06 <vixey> ivanm: think about folds
16:11:07 <dcoutts> Cale: if we install globally that means registering into the global package database, but if we built and depended on some package that was only in the user package db, then registering into the global one would fail because it'd be missing the dependency.
16:11:23 <ivanm> vixey: why would you want a loop that did nothing?
16:11:34 <dcoutts> jmei: the cabal program is separate, it's still somewhat experimental.
16:11:43 <halberd> like for a point of sale program
16:11:44 <vixey> halberd: Do you know the list datatype and a bit of haskell syntax?
16:11:59 <Cale> dcoutts: yeah.
16:12:04 <halberd> yes I've learned the basics of haskell
16:12:12 <dcoutts> jmei: if you're comfortable building development versions of stuff from darcs then you can have a go with cabal-install.
16:12:29 <halberd> I know what fmap does
16:12:42 <dcoutts> Cale: so hopefully the new default for cabal-install will make things more intuitive.
16:12:50 <halberd> but I'm not sure it's the same kind of thing you would use a "dummy loop" for
16:13:10 <dcoutts> Cale: once it's properly released we really do want to move to the 'cabal' binary being the primary UI
16:13:18 <roconnor> oh right, I used f with an overbar for (map f) in my previous paper.
16:13:26 <roconnor> that wasn't so bad
16:13:38 <halberd> basically the purpose of the dummy control structure was to set up the general scheme of how the parts of the program interacted
16:13:46 <halberd> without actually making them interact yet
16:14:19 <nolrai_> so basicly just stubing things?
16:14:24 <halberd> yeah
16:14:53 * ivanm still doesn't get why you'd do that
16:14:59 <nolrai_> I dont see how thats dependant on language at all.
16:15:46 <halberd> well then maybe I'm simply not certain how that would translate into Haskell
16:15:59 <halberd> what do you use for stubs, in Haskell?
16:16:01 <nolrai_> (or rather any language that breaks up things into routiens/funtions or files/modluels)
16:16:22 <Cale> halberd: You can use undefined
16:16:40 <Cale> Any attempt to evaluate undefined will terminate the program immediately.
16:16:57 <Cale> But its type is incredibly general, so you can stick it anywhere.
16:17:02 <halberd> but the functions could still call each other
16:17:02 <Cale> :t undefined
16:17:04 <nolrai_> I use error "stub".
16:17:04 <lambdabot> forall a. a
16:17:05 <halberd> and go through the motions
16:17:21 <halberd> discarding each other's results
16:17:39 <Cale> If you want an IO action which does nothing,  return ()  tends to work well.
16:18:35 <Cale> But the whole point of functional programs it to transform values into other values. So 'doing nothing' doesn't really mean a whole lot.
16:18:51 <nolrai_> I think the equivalent thing in haskell would be geting the types to mach up.
16:19:00 <chessguy> @pl \a b c -> f c && g b
16:19:01 <lambdabot> const (flip ((&&) . f) . g)
16:20:14 <chessguy> @pl \a b c -> g b && f c
16:20:15 <lambdabot> const ((. f) . (&&) . g)
16:21:42 <dmwit> You do realize that you're not using 'a', right?
16:22:32 <dmwit> :t curry (uncurry (&&) . ((f . fst) &&& (g . snd)))
16:22:39 <lambdabot>     No instance for (SimpleReflect.FromExpr Bool)
16:22:39 <lambdabot>       arising from a use of `f' at <interactive>:1:24
16:22:39 <lambdabot>     Possible fix:
16:22:52 <dmwit> :t \f g -> curry (uncurry (&&) . ((f . fst) &&& (g . snd)))
16:22:54 <lambdabot> forall a b. (a -> Bool) -> (b -> Bool) -> a -> b -> Bool
16:24:00 <dmwit> :t \f g -> curry (uncurry (&&) . (f *** g))
16:24:01 <lambdabot> forall a b. (a -> Bool) -> (b -> Bool) -> a -> b -> Bool
16:24:51 <dmwit> :t \f g -> ((&&) .) . (curry $ f *** g)
16:24:53 <lambdabot>     Couldn't match expected type `Bool' against inferred type `(c, c')'
16:24:53 <lambdabot>       Expected type: a -> b -> Bool
16:24:53 <lambdabot>       Inferred type: a -> b -> (c, c')
16:25:00 <dmwit> heh
16:25:15 <dmwit> :t on
16:25:17 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
16:25:18 <chessguy> dmwit: it's ok :)
16:26:51 <chessguy> @type foldr
16:26:53 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:28:39 <vixey> how do you turn off warnings?
16:28:49 <vixey> {-# is there something like this to do it?
16:30:22 <nolrai_> why do you want to turn off warnings? they're very useful.
16:30:32 <vixey> ok
16:30:53 <Saizan> vixey: -w
16:31:01 <Saizan> http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
16:31:01 <lambdabot> Title: 5.17. Flag reference, http://tinyurl.com/ydk2e6
16:34:17 <lilac> @hoogle Monad m => a -> m b -> m a
16:34:20 <lambdabot> Prelude.const :: a -> b -> a
16:34:21 <lambdabot> Prelude.asTypeOf :: a -> a -> a
16:34:21 <lambdabot> Prelude.seq :: a -> b -> b
16:34:57 <dons> win 25
16:35:43 <chessguy> @pl \h -> s . h . c
16:35:43 <lambdabot> (s .) . (. c)
16:35:50 <chessguy> ha
16:36:33 <lilac> @pl \a b -> a >> return b
16:36:34 <lambdabot> (. return) . (>>)
16:37:15 <lilac> @hoogle Monad m => m b -> a -> m a
16:37:16 <lambdabot> Prelude.const :: a -> b -> a
16:37:16 <lambdabot> Prelude.asTypeOf :: a -> a -> a
16:37:16 <lambdabot> Prelude.seq :: a -> b -> b
16:38:18 <nolrai_> whats the diffrence between StateT a List b and ListT (State a) b?
16:38:31 <Bonus> what is YHC
16:39:45 <cjb> Bonus: an alternative Haskell compiler
16:39:51 <cjb> ?where yhc
16:39:51 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
16:40:18 <Bonus> ah
16:40:37 <lilac> nolrai_: the difference is which one you need to "lift" to use
16:41:06 <tchakkazulu> Also: The first is a -> [(b,a)], the second is a -> ([b],a)
16:43:40 <EvilTerran> the distinction tchakkazulu mentions is probably more important
16:44:04 <EvilTerran> ?unmtl StateT s [] a
16:44:04 <lambdabot> s -> [(a, s)]
16:44:15 <EvilTerran> ?unmtl ListT (State s) a
16:44:16 <lambdabot> s -> ([a], s)
16:44:38 <lilac> nolrai_: you probably want the second one
16:45:06 <EvilTerran> what this means is that the former one has independent state for each "branch" of the nondeterminism, and the latter has one state global across all "branches"
16:46:03 <saml> is : a data constructor or a function?
16:46:04 <lilac> out of interest, what's the use case?
16:46:33 <vixey> saml: both
16:46:35 <tchakkazulu> saml: data constructors are functions, so both.
16:47:10 <chessguy> my brain hurts. can someone tell me what i'm missing here?
16:47:11 <chessguy> http://hpaste.org/7756
16:47:50 <vixey> chessguy, just wondering .. should f 'q' = g (\x -> x{bk=True}) be f 'q' = g (\x -> x{bq=True})
16:48:01 <saml> ah, thanks
16:48:30 <vixey> (not actually the bug you were talking about though)
16:48:35 <chessguy> vixey: yeah, but doesn't matter syntactically
16:48:36 <dcoutts> EvilTerran: if you know about logic monads, can you advise me about one with backtracking and cut?
16:48:56 <chessguy> vixey: thanks for pointing that out
16:49:01 <vixey> dcoutts: why do you want cut rather than fairness/once and ifte?
16:49:09 <vixey> (just curious.. cut is a very odd thing)
16:49:28 <dcoutts> vixey: I'm doing a search algorithm and I only want local depth bounded search
16:49:47 <dcoutts> cut isn't the only way I suppose
16:50:05 <dcoutts> my search is mostly heuristic without backtracking
16:50:20 <dcoutts> but I want to do a depth 1 local search
16:50:59 <vixey> hmm,
16:51:23 <dcoutts> now I could code the level one search myself explicitly
16:51:25 <vixey> if you made a lazy list of all solutions, sols, then wouldn't head sols just compute the first and be equivalent to cutting?
16:52:21 <vincenz> vixey: you mean "take 1"
16:52:26 <nolrai_> So ListT (State a) b has one common state?
16:52:27 <vincenz> vixey: since you still want a list of solutions, and head can fail
16:52:42 <vixey> oh good point vincenz
16:53:53 <dcoutts> vixey: I suppose what I want to do is pick the first solution if there is one or inspect all the failures to produce an overall failure (with an explanation)
16:54:32 <vixey> oh.. this is tricky, we usually just print "no" :)
16:54:37 <dcoutts> heh
16:55:10 <dcoutts> vixey: $ cabal install yi
16:55:11 <dcoutts> "no".
16:55:14 <dcoutts> :-)
16:55:20 <dcoutts> I don't think we'd be pleased
16:55:24 <vixey> :P
16:55:54 <dcoutts> yeah, half the algorithm is in collecting and remembering constraints
16:55:54 <vixey> perhaps using State.. I'm not really sure a good way
16:55:59 <dcoutts> and the reasons for those constraints
16:56:20 <dcoutts> so that when we get conflicts we can explain what gave rise to the conflicting constraints
16:57:39 <dcoutts> maybe I should rethink, perhaps I should lazily construct the exponential search space in one phase
16:57:59 <dcoutts> and then explore it doing the heuristic stuff and local search
16:58:00 <EvilTerran> dcoutts, i'm afraid i'm not that familiar with logic monads. i know ListT is broken (and vaguely why), and i've written a "Foldr monad" out of morbid curiosity, but that's as far as my knowledge goes, really
16:58:32 <dcoutts> EvilTerran: ok, that's slightly more than I know about ListT :-)
17:00:10 <EvilTerran> (data Foldr a = Foldr (forall b. (a -> b -> b) -> b -> b); and representing lists of possibilities by their church encoding, basically)
17:00:13 <vixey> cut makes most sense in a stack based Prolog
17:00:20 <vixey> it's really a pretty primitive hack
17:00:28 <vixey> anyway, the monadic versions don't generally implement it
17:00:42 <vixey> (Seres et al, LogicT .. don't)
17:00:59 <chessguy> wow, i've actually got such bad code that ghci is hanging while trying to interpret it
17:01:01 <dcoutts> vixey: do they have anything equivalent to commit to a choice and drop backtracking admin?
17:01:05 <vincenz> the problem is that cut on a List logic system would be very different
17:01:16 <vincenz> yodu' onl y cut at the current depth of the hierarchy, not higher up
17:01:38 <lilac> if i have a multi-argument type constructor, can i derive a type class instance from a specific member of it?
17:02:01 <EvilTerran> not explicitly, no
17:02:12 * chessguy wonders if that should be reported to someone
17:02:23 <tchakkazulu> Interesting, EvilTerran. I've only been able to do something with Applicative.
17:02:27 <lilac> EvilTerran: implicitly, somehow?
17:02:35 <EvilTerran> lilac, the rules for derived instances are described in the report
17:02:52 <lilac> EvilTerran: I'm more thinking a ghc extension of some kind.
17:03:03 <EvilTerran> in theory, just "... deriving (whatever)" should DWYM in the majority of cases
17:03:16 <EvilTerran> aha. perhaps with Derive, or similar?
17:03:19 <EvilTerran> ?where derive
17:03:20 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
17:03:35 <EvilTerran> you could definitely write a Template Haskell macro to do such a thing
17:03:53 <tchakkazulu> Though that was with "data ListAlg a b where LA :: (a -> c -> c) -> c -> (c -> b) -> ListAlg a b"
17:05:49 <lilac> EvilTerran: that's overkill for now. i was hoping for some easy way, like data A = A { a :: Int, b :: String } deriving (Eq(a), Ord(b))
17:06:33 <EvilTerran> fraid not
17:08:24 <chessguy> little help here?
17:08:36 <ddarius> dcoutts: You may be interested in looking at Oleg's logic monad; I forget what it is called.
17:08:48 <dcoutts> ddarius: ta, where might I find it?
17:08:50 * EvilTerran also wants to be able to say "newtype Mod23 = Mod23 Integer deriving (Num via (`mod` 23))" or whatever
17:09:05 <ddarius> dcoutts: Give me a sec.
17:09:26 <ehird{> EvilTerran: that's insane
17:09:28 <ehird{> :-)
17:09:34 <vincenz> not to mention bokrrked
17:09:37 <vincenz> what if 23 is not a prime?
17:09:39 <EvilTerran> basically so, for newtype-derivings, un-constructor-wrapped values are passed through the "via" function before being put back in the constructor
17:09:42 <dcoutts> I'll also think about the pure search tree style, generate the exponential tree and then do a heuristic walk through a polynomial part of it
17:09:50 <ehird{> <vincenz> what if 23 is not a prime?
17:09:51 <ehird{> we all die.
17:09:59 <vincenz> }}}}
17:10:00 <ddarius> dcoutts: I think this is the one: http://okmij.org/ftp/Computation/monads.html#LogicT
17:10:00 <lambdabot> Title: Monads
17:10:02 <chessguy> ....or just ignore me completely, that works too
17:10:04 <dcoutts> ddarius: ta
17:10:10 <ehird{> vincenz: bahahahaa. It doesn't just bother Baughn!
17:10:14 <ehird{> take
17:10:14 <ehird{> this
17:10:15 <ehird{> vincenz:
17:10:17 <ehird{> :D
17:10:27 * EvilTerran looks back and forth between ehird{ and vincenz
17:11:11 <ehird{> {{{
17:11:17 <ehird{> C-c-c-combo ... starter
17:11:20 <vincenz> Anyways, my point was, what if the number supplied wasn't prime?
17:11:22 <EvilTerran> ?bot
17:11:22 <lambdabot> :)
17:11:28 <EvilTerran> yay
17:11:33 <orbitz> vincenz: hai
17:12:07 <vixey> vincenz: shouldn't it be an natural exponent of a prime or something
17:12:36 <EvilTerran> > close "all those damn braces"
17:12:38 <lambdabot>  }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}...
17:13:03 <EvilTerran> vincenz, what's the problem with it not being prime?
17:13:39 <ehird{> > close "WTF HOW DOES THAT WORK"
17:13:41 <lambdabot>  But I don't know how to close that!
17:13:45 <ehird{> ...
17:13:50 <ehird{> EvilTerran: Did you just do that over /msg? :P
17:14:27 <vincenz> EvilTerran: it's no longer a gorup
17:14:29 <vincenz> group
17:14:39 <dmwit> > let close "all those damn braces" = fun . repeat $ '}'; close xs = fun "But, but!" in close "all those damn braces"
17:14:39 <lambdabot>  Add a type signature
17:14:43 <ehird{> > close "all those damn braces"
17:14:44 <lambdabot>  }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}...
17:14:51 <ehird{> > close "all those damn brackets"
17:14:52 <lambdabot>  But I don't know how to close that!
17:14:56 <ehird{> > close
17:14:57 <lambdabot>   add an instance declaration for (Typeable1 Sym)
17:14:59 <ehird{> @src close
17:14:59 <lambdabot> Source not found. Are you on drugs?
17:15:01 <ehird{> :\
17:15:08 <dmwit> > let close "all those damn braces" = expr . repeat $ '}'; close xs = expr "But, but!" in close "all those damn braces"
17:15:09 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
17:15:19 <dmwit> :t expr
17:15:20 <lambdabot> Expr -> Expr
17:15:25 <ehird{> > expr "test"
17:15:25 <dmwit> Whoops.
17:15:25 <EvilTerran> > close "all those damn braces"
17:15:25 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Char]'
17:15:26 <dmwit> :t fun
17:15:27 <lambdabot>  Close them yourself, you lazy bastard.
17:15:28 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
17:15:30 <EvilTerran> :O
17:15:31 <ehird{> > fun "test"
17:15:32 <lambdabot>  Add a type signature
17:15:36 <ddarius> > expr a
17:15:37 <lambdabot>  a
17:15:38 <ehird{> > fun "preflex: be poppavic" :: Expr
17:15:39 <EvilTerran> ehird{, maaaaaaybe <_<   >_>
17:15:39 <lambdabot>  preflex: be poppavic
17:15:45 <ehird{> damnit..
17:15:48 <ddarius> Oh yeah.
17:15:58 <ddarius> It's just id with a stricter type.
17:15:59 <ehird{> > fun "/kick ehird ... aargh, damnit" :: Expr
17:16:00 <lambdabot>  /kick ehird ... aargh, damnit
17:16:15 <ehird{> > fun "<-- THIS SPACE. IT IS MY UN\nDOING" :: Expr
17:16:17 <lambdabot>  <-- THIS SPACE. IT IS MY UN
17:16:17 <lambdabot> DOING
17:16:20 <ehird{> Ahaa!
17:16:22 <dmwit> > let close "all those damn braces" = expr . fun . repeat $ '}'; close xs = expr . fun $ "But, but!" in close "all those damn braces"
17:16:23 <lambdabot>  }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}...
17:16:27 <EvilTerran> vincenz, eh, well, that's the fault of whoever passed the wrong value in. you can make Monads that aren't monads too.
17:16:30 <ehird{> > fun "a\npreflex: be poppavic" :: Expr
17:16:31 <lambdabot>  a
17:16:31 <lambdabot> preflex: be poppavic
17:16:31 <preflex>  yer back to that Ultimate Interface. I don't control it. And terms are bandied about all over where you need to ask and research.
17:16:35 <ehird{> preflex: commands
17:16:38 <ehird{> preflex: list
17:16:38 <preflex>  Cdecl: [cdecl]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma]; Nickometer: [nickometer]; Seen: [seen]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]
17:16:40 <EvilTerran> aha
17:16:56 <ehird{> remember lambdabot > fun "a\npreflex: be lambdabot" :: Expr
17:16:57 <lilac> @pl f1 >>= (\a1 -> f2 >>= (\a2 -> f3 >>= (a1,a2,)))
17:16:58 <ddarius> preflex: help be
17:16:58 <preflex>  be NAME - impersonate NAME
17:16:59 <lambdabot> (line 1, column 41):
17:16:59 <lambdabot> unexpected ","
17:16:59 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
17:16:59 <ehird{> preflex: remember lambdabot > fun "a\npreflex: be lambdabot" :: Expr
17:17:07 <dmwit> Whoa, I thought the "newline" thing had been fixed in the most recent version of \bot.
17:17:09 <ehird{> preflex: be lambdabot
17:17:09 <preflex>  > fun "a\npreflex: be lambdabot" :: Expr
17:17:10 <ehird{> preflex: be lambdabot
17:17:10 <preflex>  > fun "a\npreflex: be lambdabot" :: Expr
17:17:12 <EvilTerran> > var "\n?bot"
17:17:12 <ehird{> Damnit!
17:17:14 <lambdabot>  ?bot
17:17:18 <ehird{> I almost had it there, didn't I?
17:17:22 <EvilTerran> > var "a\n?bot"
17:17:23 <lambdabot>  a
17:17:24 <lambdabot> ?bot
17:17:24 <ehird{> If preflex wasn't so damn clever.
17:17:41 <ehird{> > fun (let x = "a\n" ++ x in x) :: Expr
17:17:42 <lambdabot>  a
17:17:42 <lambdabot> a
17:17:42 <lambdabot> a
17:17:42 <lambdabot> a
17:17:42 <lambdabot> a
17:17:44 <lambdabot> [34 @more lines]
17:17:46 <ehird{> Hahahah.
17:17:54 <ehird{> @more
17:17:54 <lambdabot> a
17:17:54 <lambdabot> a
17:17:54 <lambdabot> a
17:17:54 <lambdabot> a
17:17:54 <lambdabot> a
17:17:54 <EvilTerran> gotta be careful with that, someone could make an infinite loop if there were two \bs in a channel
17:17:56 <lambdabot> [29 @more lines]
17:17:59 <glguy> Even though you are *trying* to flood the channel
17:18:00 <ehird{> EvilTerran: Yeah, 'xactly.
17:18:01 --- mode: ChanServ set +o vincenz
17:18:02 <glguy> you are still flooding the channel
17:18:05 <Trinithis> what exactly does the >>= do for the (->) e monad?
17:18:07 --- kick: lambdabot was kicked by vincenz (vincenz)
17:18:18 <ehird{> is that the first time \bot has been kicked?
17:18:22 <glguy> lets be fair about this
17:18:26 <EvilTerran> dmwit, i guess SimpleReflect re-opened an old security hole
17:18:28 --- mode: ChanServ set +o glguy
17:18:28 --- mode: ChanServ set -o glguy
17:18:32 <Trinithis> like a sequenced join?
17:18:33 <orbitz> what did he ever do to you?!
17:18:40 * vincenz sent an @join
17:18:42 <dmwit> EvilTerran: No, I mean, I thought SimpleReflect had been patched, too.
17:18:47 <EvilTerran> ah
17:18:52 <EvilTerran> should be a fairly quick fix, i imagine
17:18:53 <vincenz> ehicut the spam, next time it's you
17:19:11 <tchakkazulu> Tryinithis: (>>=) for (-> e) has type (e -> a) -> (a -> e -> b) -> e -> b
17:19:14 <ehird{> i didn't flood.
17:19:15 <ehird{> :-P
17:19:19 <dmwit> vincenz: Tell him again, he just rejoined.
17:19:22 <EvilTerran> vincenz, failure to tab-complete when someone's not here? ;)
17:19:23 <tchakkazulu> Can you guess what it does from that type?
17:19:23 <Trinithis> > flip ($) 4 $ id >>= (*) >>= (+) >>= (*)
17:19:24 <lambdabot>  80
17:19:49 --- mode: vincenz set -o vincenz
17:19:54 <awarring> Hi all. I've been messing with Data.ByteString.Lazy, and attempted to get a string from stdin by calling the following: name <- Data.ByteString.getContents. This works fine on OSX, but fails on windows with the error: <stdin> hGetBufNonBlocking: resource exhausted (Not enough space)   Using GHC 6.8.1
17:19:56 <vincenz> EvilTerran: ssh-lag to irrsi
17:20:02 <EvilTerran> k
17:20:29 <awarring> Is there something I'm not setting up properly?
17:20:31 <vincenz> More than a second at times.
17:20:35 <lilac> tchakkazulu: isn't there only one strict function with that type?
17:20:48 <ehird{> vincenz Still hasn't repeated whatever it was, dmwit :P
17:20:57 <lilac> @djinn (e -> a) -> (a -> e -> b) -> e -> b
17:20:59 <EvilTerran> awarring, er... if you're using BS.Lazy, wouldn't the thing to use be BS.Lazy.getContents rather than BS.getContents? not that that should be causing that problem, but still...
17:21:00 <lambdabot> f a b c = b (a c) c
17:21:02 <vincenz> EvilTerran: cut the spam
17:21:06 <vincenz> grr
17:21:11 <vincenz> ehird{: cut the spam
17:21:14 * EvilTerran blinks at vincenz
17:21:16 <tchakkazulu> Aye. So that's what it does :)
17:21:24 <awarring> EvilTerran: Sorry, i didn't paste it from source direct, since I qualified it in source as BS
17:21:25 <vincenz> EvilTerran: wrong tab-complete
17:21:30 <vincenz> EvilTerran: sorry
17:21:42 <awarring> EvilTerran: only wanted to show one line of code :P
17:21:44 <tchakkazulu> It passes the environment to the first function, and uses the same environment, and the previous result, in the second function to get at the final result.
17:21:56 <Trinithis> tchakkazulu: for bind?
17:22:02 <dmwit> > expr . fun $ "\3\&5green?"
17:22:04 <lambdabot>  green?
17:22:08 <tchakkazulu> Yeah. Bind for ((->) e).
17:22:11 * EvilTerran pops open a tin of processed meat and starts slicing it thinly - does that make you happy, vincenz?
17:22:14 <EvilTerran> :P
17:22:36 <Botje> EvilTerran++ # carnivore approach to spam reduction
17:22:47 <tchakkazulu> And I should learn again to highlight Trinithis in busy channels like this. Yeah. Bind for ((->) e).
17:22:56 <dons> dcoutts: -fcpr panics on type families :)
17:23:09 * EvilTerran notes that the channel has been incredibly hectic for the last few minutes, so wanders off for a bit 'til things calm down
17:24:01 <tchakkazulu> So in do {a <- b}, 'a' will be bound to the value of 'b', if were passed the environment.
17:24:11 <dcoutts> dons: ahh, so not a problem for uvector
17:24:23 <dons> well, uvector uses only associated data types
17:24:27 <dons> so all ok.
17:25:03 <dons> optimisation-related flags should have comments
17:25:06 <dons> in .cabal files :)
17:25:13 <EvilTerran> > (do foo <- f; bar <- g; return (foo, bar)) x :: (Expr,Expr)
17:25:15 <lambdabot>  (f x,g x)
17:25:24 <dcoutts> dons: :-)
17:25:30 <EvilTerran> tchakkazulu, pretty much, yeah
17:25:57 <Trinithis> :t Expr
17:25:59 <lambdabot> Not in scope: data constructor `Expr'
17:26:10 <EvilTerran> Expr is a bit of SimpleReflect
17:26:13 <EvilTerran> ?type x
17:26:15 <lambdabot> Expr
17:26:16 <EvilTerran> > x
17:26:18 <lambdabot>  x
17:26:32 <EvilTerran> > f x :: Expr
17:26:33 <lambdabot>  f x
17:26:35 <Trinithis> EvilTerran: lambda bot only syntax? or also valid in haskell?
17:26:38 <ehird{> > f x x :: Expr
17:26:39 <lambdabot>  f x x
17:26:44 <ehird{> > f f :: Expr
17:26:44 <lambdabot>  Add a type signature
17:26:47 <EvilTerran> ?where simplereflect
17:26:48 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
17:26:56 <ddarius> Trinithis: SimpleReflect is a simple library.
17:27:09 <ehird{> > let bbbb y = bbbb (y x) in bbbb f :: Expr
17:27:10 <lambdabot>      Occurs check: cannot construct the infinite type: t = Expr -> t
17:27:10 <lambdabot>       Ex...
17:27:10 <EvilTerran> it's magic :D
17:27:14 <ehird{> d'aww
17:27:36 <Trinithis> :D my haskell folder is overflowing! need to organize it soon
17:30:24 <Trinithis> tchakkazulu: Ah, thanks. I see it now
17:30:50 <gwern> Trinithis: use a left folder then
17:31:00 <halberd> how do I kill a single window?
17:31:06 <Trinithis> gwern whats a left folder?
17:31:09 <halberd> without using C-x 1 to kill all but 1
17:31:11 <Trinithis> foldl?
17:31:15 <halberd> oh whops
17:31:19 <halberd> this isn't emacs
17:31:35 <ehird{> halberd: Hhahaha
17:31:39 <gwern> sure. foldl' might be even better if you;re getting stack overflows
17:32:02 <Cale> (though with -O2 they might do the same thing)
17:32:03 <halberd> it's C-x 0 fyi
17:32:14 <gwern> halberd: do you often ask your emacs how to do things?
17:32:30 <halberd> i've been awake for about 30 hours
17:32:44 <edwardk> @seen dolio
17:32:45 <lambdabot> dolio is in #haskell and #haskell-blah. I don't know when dolio last spoke.
17:32:51 <edwardk> lambdabot lives
17:32:55 * edwardk hugs lambdabot.
17:33:07 <dolio> What up, homeslice?
17:33:35 <gwern> 'emacs, how do I paste in a rectangle from a register? emacs? Emacs? ANSWER ME EMACS I INSTALLED YOU AND SO HELP ME DOG I CAN UNINSTALL YOU'
17:33:39 <edwardk> dolio: wanted to point to http://comonad.com/reader/2008/elgot-coalgebras/ regarding the elgot algebra stuff from the other day
17:33:40 <lambdabot> Title: The Comonad.Reader  Elgot (Co)Algebras
17:35:43 <chessguy> can someone do me a favor and 'darcs get darcs get http://code.haskell.org/ChessLibrary', and see if ghci can load up Chessboard.hs ?
17:35:50 <chessguy> it's doing weird things to mine
17:36:34 <Trinithis> > (foldr ($) 4 $ (($4) .flip) . [(*), (+), (*)]) == (id >>= (*) >>= (+) >>= (*)) 4
17:36:35 <lambdabot>  True
17:36:48 <ari> Ok, modules loaded: ChessDefinitions, Chessboard.
17:36:55 <chessguy> huh.
17:37:00 <dcoutts> @seen dbueno
17:37:00 <lambdabot> dbueno is in #haskell. I don't know when dbueno last spoke.
17:37:00 <gwern> seems fine here
17:37:11 <dbueno> dcoutts: I'm here.
17:37:20 <dcoutts> dbueno: just sent you some more details
17:37:33 <dbueno> dcoutts, Thanks, just began reading. =]
17:37:42 <vixey> @keal
17:37:43 <lambdabot> it is very easy to go off topic
17:37:46 <vixey> @keal
17:37:46 <lambdabot> nsa has all the profiling info you need to come up with the correct survey answers
17:37:48 <vixey> @keal
17:37:48 <lambdabot> what are epsilons?
17:38:14 <Trinithis> > (foldl' (flip ($)) 4 $ (($4) .flip) . [(*), (+), (^)]) == (id >>= (*) >>= (+) >>= (^)) 4
17:38:15 <lambdabot>  True
17:38:16 <dcoutts> dbueno: nominolo is also a good person to ask about configurations
17:38:26 <chessguy> ari: gwern  thanks. very strange. i get this:
17:38:27 <chessguy> [1 of 2] Compiling ChessDefinitions ( ChessDefinitions.hs, interpreted )
17:38:27 <chessguy> [2 of 2] Compiling Chessboard       ( /Users/awagner/Desktop/chess_checkout/ChessLibrary/Chessboard.hs, interpreted )
17:38:40 <chessguy> and then it hangs
17:38:48 <vixey> @keal
17:38:49 <lambdabot> they dumbified you
17:38:50 <dbueno> dcoutts: Oh, so flags can actually be considered *variables*, too.
17:38:51 <dcoutts> dbueno: in the mean time I've been hacking on a intrim solver that is hopefully less stupid than the current one
17:38:57 <dcoutts> dbueno: oh yes :-)
17:39:12 <dbueno> dcoutts: Oh, what's the approach of that solver?
17:39:27 <dbueno> I'll keep nominolo in mind, too, thanks.
17:39:31 <tchakkazulu> :type (.)
17:39:41 <dcoutts> dbueno: the syntax for flags makes them look like the semantics are one directional
17:39:46 <vixey> :t (.)
17:39:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:39:56 <vixey> tchakkazulu
17:40:00 <tchakkazulu> Thanks.
17:40:09 <tchakkazulu> I was wondering why it worked on a list.
17:40:11 <dcoutts> dbueno: but really they're declarative, and we can and do read them backwards
17:40:16 <dbueno> dcoutts: Yeah, I thought they had to be fixed by, i-dunno, configure time, or something.  I thought they were became constants early on.
17:40:17 * tchakkazulu thought function composition.
17:40:27 <vixey> tchakkazulu: In Haskell Prelude it's just function composition
17:40:34 <dcoutts> dbueno: yeah it makes it much more interesting :-)
17:40:37 <vixey> tchakkazulu: Lambdabot has generalized it a bit
17:40:49 <tchakkazulu> Ah, yes.
17:40:57 <vixey> tchakkazulu: so when used with functions, it's composition, but when used with lists it's map
17:40:58 <tchakkazulu> Because fmap for ((->) e) is composition.
17:41:00 <dbueno> dcoutts: Is there a way to specify "conflicts-with"?
17:41:02 <vixey> @src (.)
17:41:02 <lambdabot> (f . g) x = f (g x)
17:41:02 <lambdabot> -- In lambdabot, it's been generalised to:
17:41:02 <lambdabot> (.) = fmap
17:41:03 <vixey> exactly
17:41:14 <dcoutts> dbueno: no, fortunately :-0
17:41:21 <vixey> there's another possible generalization too
17:41:27 <vixey> something in Control.Category
17:41:39 <tchakkazulu> Hehe, yeah. I read some of that stuff that's recently been blogged.
17:41:49 <dcoutts> dbueno: conflicts with makes sense for distro packages where they can install conflicting files, but we can always avoid that.
17:41:49 <vixey> can never remember exactly what though
17:41:51 <dolio> edwardk: I briefly wondered yesterday if you could replace the Either a with some other monad and get something that made sense.
17:41:53 <dibblego> > (+2) . [1..5]
17:41:55 <lambdabot>  [3,4,5,6,7]
17:42:05 <dolio> Although I think I came to the conclusion that you couldn't.
17:42:07 <tchakkazulu> I'm not a /complete/ noob at category theory, but very close to.
17:42:18 <edwardk> dolio: yeah
17:42:28 <edwardk> dolio: i use (,)a in the dual, but of course that is to be expected
17:42:32 <Trinithis> vixey: what function does it generalze to in control.category?
17:42:37 <dolio> Right.
17:42:43 <dcoutts> dbueno: as for my new solver, it's a top down non-backtracking heuristic search guided by gathering constraints
17:42:55 <dbueno> dcoutts: Hm, but don't you need negations to get a full boolean base?
17:43:00 <vixey> Trinithis: I can't remember
17:43:16 <edwardk> hrmm my server seems to have gone down (or i lost a route to it) bah
17:43:50 <tchakkazulu> vixey, Trinithis: to "flip (>>>)" perhaps?
17:43:54 <edwardk> i was quite pleased though that I could use the dual construction i came up with to rederive paramorphism though =)
17:44:01 <vixey> oh
17:44:04 <vixey> :t (<<<)
17:44:06 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> a b c -> a b d
17:44:08 <dcoutts> dbueno: as far as I can see, and from my experience with other systems, avoiding a conflicts with style dependency is a good thing.
17:44:10 <tchakkazulu> Though that'd break the whole Functor part :-/
17:44:21 <dbueno> dcoutts: are you sure the problem is still NP-complete?
17:44:57 <dcoutts> dbueno: of course it doesn't mean you don't get conflicts when trying to solve. Since we still want to have only one version for each dependency.
17:45:25 <tchakkazulu> vixey: Hmm, not really. No way you can fill in the [] there and still make it work.
17:45:27 <Trinithis> thanks. gotta eat
17:45:38 <edwardk> yeah, btw you can derive the (.) = fmap and the control.category version at the same time
17:45:43 <dbueno> dcoutts, Right.  So the implicit constraints give you negation.  "If this version is chosen for installation, all other ones *are not*."
17:46:16 <dcoutts> dbueno: I think it's NP complete even without the guarded dependencies
17:46:21 <edwardk> well, you can with a little work anyways
17:46:54 <dbueno> dcoutts: Guarded deps are the variable things you mentioned in the eail?
17:47:10 <dcoutts> dbueno: yep
17:47:15 <tchakkazulu> Heh, this category stuff, as interesting as it is, still blows my mind.
17:47:20 <dcoutts> dblog: aka configuration flags
17:47:25 <dcoutts> dbueno: I think the main thing that makes it hard is that saying foo >= 1.0 && < 2.0, looks like it's specifying any of a bunch of similar things, but they're all discrete and each of the possible choices could in theory have completely unrelated dependencies.
17:47:35 <tchakkazulu> I just got around to understanding how monad transformers are (or should be) a natural transformation.
17:47:38 <tchakkazulu> And with that, sleep.
17:48:46 <edwardk> hrmm can anyone else see comonad.com? i'm trying to figure out if I just have no route or if the site is down
17:49:04 <dcoutts> dbueno: there's a paper by a debian developer which has a reduction from 3SAT, you can check that to see what the exact requirements of the package dep language have to be.
17:49:08 <dmwit> Seems to time out here.
17:49:14 <dbueno> dcoutts: If there is unresolved dep on a package with version v, and another unresolved dep requires specifically another version of v, that should be unsatisfiable, correct?
17:49:15 <edwardk> dmwit: crud
17:49:37 <dbueno> dcoutts: Yeah, I've read that paper, though have since forgotten exactly the reduction.
17:49:38 <tchakkazzzzz> The irony. http://downforeveryoneorjustme.com/ is down <_<
17:49:39 <lambdabot> Title: Down for everyone or just me?
17:49:44 <dcoutts> dbueno: as we've currently specified it, yes.
17:50:26 <int-e> Grr. I want negative number literals.
17:50:35 <int-e> > (-128) :: Safe Int8
17:50:36 <int-e> Safe *** Exception: Overflow in fromInteger
17:50:36 <lambdabot>   Not in scope: type constructor or class `Safe'
17:50:46 <dcoutts> dbueno: we could have a slightly looser (but more complex) requirement and say that we only require them to be the same version if they have a common reverse dependency.
17:51:03 <dmwit> > (-1) :: Safe Int8
17:51:03 <lambdabot>   Not in scope: type constructor or class `Safe'
17:51:28 <int-e> dmwit: that was a ghci prompt, I shouldn't have pasted it like that.
17:51:40 <dmwit> > -128 :: Word8 -- int-e, you can't have negative literals?
17:51:41 <lambdabot>  128
17:51:51 <dmwit> Okay, bad example, Word8 is unsigned. =P
17:51:58 <int-e> > -128 :: Int8 -- find the overflow :)
17:51:59 <lambdabot>  -128
17:52:00 <dcoutts> dbueno: for example, the current definition says that if A `dependsOn` C-1.0, B `dependsOn` C-1.1, then that's a conflict.
17:52:00 <dmwit> > -128 :: Int8
17:52:01 <lambdabot>  -128
17:52:18 <int-e> (there are two. one in converting 128 to Int8 and one in the negation)
17:52:31 <dbueno> dcoutts: But a looser def. would allow one to install both, if they're not needed for the same package.  I see.
17:52:37 <dmwit> int-e: ...oh =/
17:52:59 <dbueno> dcoutts: More support from cabal is required to get such multiple-versions-of-same-package-safely working?
17:53:09 <dbueno> dcoutts: or just a smarter dep. resolution?
17:53:11 <dcoutts> dbueno: right, we're trying to avoid any single package having in the transitive closure of its dependencies two versions of the same package.
17:53:47 <dcoutts> dbueno: no, ghc can and does support having any number of versions of the same package installed simultaneously
17:53:57 <dcoutts> @google dreaded diamond dependency problem
17:53:58 <lambdabot> No Result Found.
17:54:00 <dcoutts> grrr
17:54:14 <dcoutts> why does it work for me when I google for it, but not for lambdabot?
17:54:28 <dbueno> dcoutts, Oh hey, is that you?
17:54:40 <dcoutts> http://blog.well-typed.com/2008/04/the-dreaded-diamond-dependency-problem/
17:54:43 <lambdabot> Title: blog.well-typed.com  Blog Archive  The dreaded diamond dependency problem, http://tinyurl.com/6hbfwv
17:54:49 <dcoutts> dbueno: ^^ that? yeah, that's me.
17:55:02 <dbueno> dcoutts: Sorry, yes, the blog entry.
17:55:30 <dcoutts> dbueno: so yes, the problem is not simultaneous installs but type errors :-)
17:55:59 <dcoutts> dbueno: if we had private build-depends where types were not re-exported from a package then we would have more freedom
17:56:13 <dcoutts> but as it is, we have to make a conservative approximation
17:56:30 <int-e> > abs (-128 :: Int8)
17:56:31 <lambdabot>  -128
17:56:43 <int-e> dmwit: another variation on the theme :)
17:56:44 <dcoutts> dbueno: private build-depends would translate into using different variable names in a SAT solver I guess
17:57:13 <dmwit> int-e: Well, that's not fair, that really should be an overflow.
17:57:15 <dcoutts> dbueno: then they'd not be constrained to be the same value for all mentions of the variable
17:57:30 <dmwit> int-e: I mean, it's not Haskell's fault that doing that is an overflow.
17:58:18 <dcoutts> dbueno: anyway, it's late here, I should sleep.
17:58:19 <dbueno> dcoutts:  Right.  As soon as I get an encoding of the install problem as a SAT problem, such things will be easier to see.. =]
17:58:37 <dbueno> dcoutts:  Night.  Thanks for the information.
17:58:42 <dcoutts> np, g'night
18:00:16 * EvilTerran looks askance at the retreating figure of [ai]hate
18:00:52 <vixey> @trotonportedo
18:00:52 <lambdabot> Unknown command, try @list
18:01:04 <vixey> @protontorpedo
18:01:04 <lambdabot> or does it become a mishmash of code?
18:01:07 <vixey> @protontorpedo
18:01:07 <lambdabot> on the haskell site they compare haskell to a spreadsheet
18:01:10 <vixey> @protontorpedo
18:01:11 <lambdabot> so haskell is new and improved c?
18:02:18 <EvilTerran> actually, there's nothing much wrong with comparing haskell to spreadsheets. spreadsheet formulae are generally written in a pure language, albeit one where all the variables are called [a-z]+[0-9]+
18:02:47 * EvilTerran once tried to hack lambdas into excel via VBA macros, but failed spectacularly
18:03:35 <EvilTerran> actually, thinking about it, i think i first heard the "spreadsheet formulae are a functional language" schpiel in a talk SPJ did a few years back
18:06:01 <int-e> > fromEnum (2^64) :: Integer
18:06:16 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
18:06:19 <int-e> > fromEnum (2^64 :: Integer)
18:06:22 <lambdabot>  0
18:15:18 <augur> greetings haskellians
18:16:58 <augur> i has a question about haskell's lazy evaluation
18:17:26 <sjanssen> fire away
18:17:48 <dibblego> !Question
18:18:57 <augur> with lazy evaluation, you dont evaluate until the value is needed, but if the value is required in multiple places in a function, then i presume the first evaluation is just stored and substituted?
18:18:59 <augur> like, say
18:19:21 <augur> if you have foo x = x + x * 2, say
18:19:22 <vincenz> augur: yes it is
18:19:23 <augur> and you do
18:19:26 <augur> ok
18:19:34 <augur> so heres my real question, now that i know thats true
18:19:51 <augur> what if you did foo (fac 5)?
18:19:57 <vixey> augur: I think a very important thing to clarify lazy evalution is the notion of 'weak head normal form'
18:20:00 <vincenz> augur: basically you have a thunk that is evaluated when the value is required, and then the thunk is overwritten by the value
18:20:04 <augur> would that substitute into (fac 5) + (fac 5) * 2?
18:20:14 <dmwit> augur: Actually, the language itself makes no requirements about how many times it is evaluated.
18:20:20 <augur> ok
18:20:29 <dmwit> augur: It turns out that most implementations will only evaluate it once, though.
18:20:30 <geezusfreeek> conal: ping
18:20:33 <vixey> augur: we should look at data and values (including functions) as different things
18:20:46 <augur> hm
18:20:51 <conal> geezusfreeek: 'sup?
18:21:03 <geezusfreeek> conal: http://github.com/geezusfreeek/simple-haskell-game/tree/master/src/Data
18:21:04 <lambdabot> Title: geezusfreeek's simple-haskell-game at master &mdash; GitHub, http://tinyurl.com/5k6njv
18:21:15 <geezusfreeek> it's not tested yet, but it's pretty
18:21:19 <augur> but most implementations will not evaluat (fac 5) more than once in the evaluation of foo (fac 5)?
18:21:26 <sjanssen> augur: correct
18:21:28 <dmwit> augur: right
18:21:47 <sjanssen> augur: if you want to play around a bit with this, check out Debug.Trace
18:21:55 <augur> does that work across all instances of (fac 5) even outside of any given evalution?
18:22:03 <sjanssen> augur: no
18:22:06 <augur> ok.
18:22:11 <conal> geezusfreeek: i'll check it out!
18:22:11 <geezusfreeek> conal: in particular, you will want to see what i ended up doing for the implementation of Future
18:22:16 <geezusfreeek> basically nothing :D
18:22:37 <augur> is this because of the possibility of the "function" not returning the same value?
18:22:40 <sjanssen> augur: a Haskell implementation is allowed to do that, but practically none of them do
18:22:57 <augur> wouldn't that provide efficiency benefits tho?
18:23:02 <sjanssen> augur: nah, it's more about practical matters like memory use, etc.
18:23:10 <augur> ah
18:23:13 <conal> geezusfreeek: wonderful.  :)  comments later.  i'm head down in derivative stuff.
18:23:19 <geezusfreeek> conal: have fun
18:23:31 <conal> thx
18:23:40 <augur> cool. thanks guys.
18:23:53 <sjanssen> augur: what happens when I write map fac [1 .. 10^9], and then never use fac again? (hint: massive memory leak)
18:24:36 <dibblego> hmm, that hint is not very revealing
18:25:14 <augur> mm. good point
18:25:39 <ddarius> conal: I await the rest of the series.
18:25:53 <conal> ddarius: :)
18:26:40 * edwardk goes stir crazy. home sick, and my server with my code and blog is down ;)
18:27:10 <ddarius> "home sick"?
18:27:27 * edwardk hacks and coughs in ddarius' general direction ;)
18:27:48 <edwardk> more appropriately 'at home sick' ;)
18:27:53 <ddarius> edwardk: You're in Massachusetts, no?
18:27:57 <edwardk> yeah
18:28:02 <edwardk> long way for that to carry
18:28:13 <ddarius> Okay, that would be southwesterly then and, yes, I feel quite safe.
18:34:00 <proq> edwardk: that's why I carry around a zaurus
18:34:56 <Cale> augur: Haskell is defined as having nonstrict semantics, but lazy evaluation is what most implementations mostly do.
18:35:03 <edwardk> the PDA? so i can sneak up on him while on channel and he'll never know?
18:35:43 <Cale> augur: Lazy evaluation is just outermost-first evaluation with the extra provision that if a parameter to a function occurs multiple times in the body of that function, the result of evaluating the parameter is shared between the copies (if it ever gets evaluated at all)
18:36:03 <proq> edwardk: no, so I can still do some hacking when I'm away from home
18:36:30 <augur> ok.
18:36:51 <augur> and i presume that if a function definition repeats something, it's just evaled twice
18:36:54 <edwardk> proq: yeah. usually i'd keep the code on my laptop, but I haven't been able to bring myself to carry one for me and one for work at the same time.
18:36:59 <Cale> augur: So it would look something like foo (fac 5) ---> let x = fac 5 in x + x * 2
18:37:12 <augur> like if foo x = (fac x) * (fac x), each factorial would be evaled separately
18:37:18 <Cale> yes
18:37:25 <augur> ok.
18:37:48 <Cale> whereas if you write  foo x = let y = fac x in y * y, it'll only be evaluated once
18:37:59 <augur> mhm
18:38:06 <augur> ok. that makes sens
18:38:08 <augur> e
18:38:54 <Cale> Haskell implementations aren't required to do only lazy evaluation though. They're allowed to do anything which gets the same results and termination behaviour as lazy evaluation (though possibly not the same time/space)
18:39:37 <Cale> But if you keep lazy evaluation in mind, it's a pretty decent approximation to what's actually going on in most cases.
18:42:25 <mwc> Cale: hmm, is that the exact wording of some authoritative source?
18:42:43 <Cale> No, it's my own words about what the Report says.
18:42:44 <augur> does haskell have any native logic programming built in?
18:42:53 <vixey> augur: no
18:42:55 <mwc> If so, we'd better reword the Haskell' equivalent to "no worse than" lazy evaluation
18:42:59 <mwc> Cale: ah, fair enough
18:43:17 <vixey> what's the point in Haskell' ?
18:43:17 <augur> hm. i wonder what haskellian logic programming would look like
18:43:33 <vixey> augur: there's Curry
18:43:42 <mwc> vixey: the current draft of the next Haskell standard
18:43:47 <Cale> augur: The logict package on Hackage provides a nice monad for nondeterminism.
18:43:51 <geezusfreeek> LogicT
18:43:58 <geezusfreeek> oh beat me
18:44:01 <Cale> There's also the list monad.
18:44:16 <vixey> What are people using LogicT for?
18:44:19 <augur> with prolog-ish logic programming?
18:44:19 <Cale> Which is simpler and more naive, but covers a wide range of practical cases.
18:44:21 <vixey> I'd love to see more examples
18:44:36 <vixey> augur: curry has logic vars
18:44:38 <Cale> Not quite prologish...
18:45:27 <Cale> Basically it lets you say "pick the value of this variable from these options", and gives you various nice ways of combining sets of options.
18:46:01 <Cale> It's not entirely relational, but it's nondeterminism.
18:46:12 <vixey> augur: I found a WAM in GHC the other day
18:46:21 <augur> a wha? 0.0
18:46:22 <Cale> In the list monad, for instance, we can write things like:
18:46:30 <vixey> oh nevermind then
18:46:36 <augur> lol
18:46:46 <Cale> > do x <- [1..20]; y <- [x..20]; z <- [y..20]; guard (x^2 + y^2 == z^2); return (x,y,z)
18:46:56 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
18:47:18 <augur> im not terribly familiar with the whole haskell world, i just know bits and pieces
18:47:34 <Cale> If you already know about list comprehensions, this is exactly the same as:
18:47:48 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
18:47:49 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
18:47:58 <augur> i dont know what "WAM" means. lol
18:48:07 <vixey> augur: what sort of logic programming have you done, and want to do in haskell?
18:48:18 <augur> oh, none. im just curious.
18:48:21 <Cale> augur: I don't know either.
18:48:24 <vixey> ahh ok
18:48:27 <augur> :)
18:48:33 <augur> i just like knowing.
18:48:55 <Cale> http://okmij.org/ftp/papers/LogicT.pdf -- this is the paper that LogicT is based on.
18:48:56 <augur> cale, why would i do the former instead of the latter?
18:49:27 <Cale> augur: Well, the former is making use of a more general setting. Because lists form a monad, you get all kinds of general monad operations which work on them.
18:50:18 <Cale> For example, sequence, which in general takes a list of actions to be run in a monad, and runs each in turn, giving a list of the results, in the list monad, selects an element from each of a list of lists in all possible ways:
18:50:24 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
18:50:25 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
18:50:49 <augur> ah.
18:51:10 <Cale> replicateM is a combination of sequence and replicate:
18:51:16 <Cale> > replicateM 3 [0,1]
18:51:17 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
18:52:03 <Cale> filterM is a kind of generalisation of filter to a general monad
18:52:06 <Cale> :t filterM
18:52:08 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
18:52:33 <augur> lambdabot is cool, btw. lol
18:52:37 <chessguy> can someone with ghc 6.8.2 do a 'darcs get http://code.haskell.org/ChessLibrary', and see if they can successfully 'ghci Chessboard.hs'
18:52:39 <Cale> In the list monad, this provides us the ability to give a list of decisions as to whether each element will be taken or not
18:52:52 <Cale> (and it will try all possibilities)
18:53:02 <Cale> > filterM (\k -> [True, False]) [1,2,3]
18:53:04 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
18:53:35 <geezusfreeek> chessguy: interesting, it hangs
18:53:38 <Cale> So that says "for each element of the list, take it, or drop it, in all possible ways"
18:54:05 <Cale> If we were sure that we wanted to keep the odd elements, say, we could write:
18:54:19 <chessguy> geezusfreeek: yeah, i don't get it, it interprets it, but then has trouble after that
18:54:20 <Cale> > filterM (\k -> if odd k then [True] else [True, False]) [1,2,3]
18:54:21 <lambdabot>  [[1,2,3],[1,3]]
18:54:30 <Cale> > filterM (\k -> if odd k then [True] else [True, False]) [1,2,3,4]
18:54:32 <lambdabot>  [[1,2,3,4],[1,2,3],[1,3,4],[1,3]]
18:55:21 <Cale> So the various monadic control structures have useful specialisations in the list case. :)
18:55:37 <geezusfreeek> chessguy: i can't seem to compile it either
18:56:22 <geezusfreeek> if i had 6.9 installed i'd try it, but i don't
18:58:14 <geezusfreeek> chessguy: if you set setCastleStatusChar to undefined it works
18:58:25 <geezusfreeek> chessguy: well, it throws a compilation error anyway, but it terminates at least
18:58:45 <ecks> hello, i have a problem with my code @ hpaste.org/7757
18:59:00 <dejones>  Could not find module `Control.Parallel':
18:59:00 <dejones>       Perhaps you haven't installed the profiling libraries for package parallel-1.0.0.0?
18:59:06 <dejones> are there separate libraries for profiling?
18:59:13 <dejones> * profiling with GHC
18:59:14 <ecks> the problem is at line 42, the function run
18:59:57 <ecks> i get an error "Couldn't match expected type 'ReaderT Bot IO t' against inferred type 'IO String'"
19:00:17 <Cale> ecks: Right,  "atomically $ readTChan chan" isn't a Net action
19:00:21 <Cale> (it's an IO action)
19:00:46 <Cale> So to turn it into a Net action, you need to use liftIO on it.
19:00:59 <ecks> Cale: oh, i thought it only matters what you return
19:01:00 <gwern> dejones: did parallel come with ghc? most distros build ghc with profiling because other wise you can't profile at all almost
19:01:05 <ddarius> Warren's Abstract Machine
19:01:13 <chessguy> geezusfreeek: it appears to have something to do with parseCS or setCastleStatusChar
19:01:16 <gwern> if you installed parallel yourself, then it's your fault you didn't configure/build with profiling :)
19:01:26 <dejones> gwern, no parallel is a library now... so I have to build it with profiling?
19:01:37 <dejones> gwern, gotcha.  :)
19:01:42 <ecks> Cale: i still think of monads like an imperative program
19:01:57 <Cale> ecks: All the actions in a do block have to be in the same monad (language)
19:02:02 <augur> hm.
19:02:02 <geezusfreeek> chessguy: not parseCS. it still fails even if i remove it completely
19:02:18 <gwern> dejones: configure -p iirc
19:02:19 * gwern likes how that rhymes
19:02:21 <SamB> gwern: I blame cabal for not having adequate support for profiling
19:02:23 <chessguy> @bot
19:02:23 <dejones> gwern: the error message is confusing though.. "Perhaps you haven't installed the profiling libraries for package..." doesn't imply to me that I need to configure/build the package with profiling support, but instead that I need to install something else.
19:02:24 <lambdabot> :)
19:02:34 <dejones> gwern: thanks.  :)
19:02:50 <dmwit> augur: What's up?
19:02:52 <SamB> namely, that it isn't able to go back and build the profiling versions of libraries later on
19:02:59 <gwern> SamB: what? it has plenty of profiling support, what do you mean?
19:03:00 <augur> nothin. :p
19:03:06 <augur> ok i gotta go. see ya guys. :)
19:03:11 <gwern> it doesn't profile by default, maybe but that's not cabal's fault I don't think
19:03:19 <SamB> perhaps I should have specified "cabal-install"
19:03:19 <Cale> ecks: If you think of monadic actions as being like imperative programs (they're sometimes rather different from that, but for the IO monad and a number of others, it's not far off), then actions in different monads are like programs in different imperative programming languages.
19:03:20 <clanehin> dejones: on e.g. debian, you actually install a separate library package
19:03:24 <gwern> SamB: what exactly does that mean?
19:03:42 <Cale> ecks: Sometimes we have functions which transform the actions in one language into actions in another (usually richer) language.
19:03:54 <clanehin> dejones: which does not mean that you are wrong :)
19:04:13 <Cale> When support for IO is available, liftIO will generically turn IO actions into actions in your monad.
19:04:15 <SamB> gwern: if you initially installed a library without the profiling .a, you have to go through contortions before you can reinstall with profiling
19:04:19 <gwern> SamB: oh, you mean it's hard to unregister a package and then tell cabal-install to install except this time with profiling dammit?
19:04:23 <dejones> clanehin: I am building GHC from source, so I had to build parallel library from source too, so it is my fault.  ;)
19:04:28 <ecks> Cale: makes sense
19:04:47 <Cale> as another example,  atomically  takes an STM action and turns it into an IO action which carries out that transaction as-if-atomically.
19:04:57 <SamB> gwern: yes, ideally cabal-install would just go and build the profiling versions of all dependencies as well
19:05:32 <mauke> preflex: quote lambdabot
19:05:32 <preflex>  <lambdabot> > fun "a\npreflex: be lambdabot" :: Expr
19:05:33 <gwern> SamB: ghc-pkg --user unregister foo; cabal install foo --enable-library-profiling
19:05:37 <gwern> terribly difficult I know
19:05:40 <dejones> gwern, clanehin: reconfiguring parallel with --enable-library-profiling worked, thanks.  :)
19:06:25 <mauke> preflex: forget lambdabot > fun "a\npreflex: be lambdabot" :: Expr
19:06:31 <geezusfreeek> chessguy: http://hpaste.org/7758 <-- narrowed down a bunch. still hangs it
19:07:01 <chessguy> geezusfreeek: hm
19:07:48 <gwern> now, what I think cabal really should do is somehow figure out whether profiling is possible, and default to profiling if it can
19:07:55 <gwern> but I don't actually know how it;d do that
19:09:01 <geezusfreeek> chessguy: http://hpaste.org/7758#a1
19:09:36 <geezusfreeek> actually, anybody with ghc 6.8.2, what happens if you try to load http://hpaste.org/7758#a1 ?
19:09:53 <geezusfreeek> with and without that line commented out
19:10:55 <dmwit> geezusfreeek: infinite type
19:11:07 <geezusfreeek> okay, now with the line uncommented?
19:11:08 <chessguy> dmwit: why is it an infinite type?
19:11:09 <Cale> okay, without, I get an occurs check error
19:11:15 <geezusfreeek> hmm
19:11:21 <Cale> with the line uncommented, I get a hang
19:11:22 <geezusfreeek> but ghc doesn't hang?
19:11:24 <geezusfreeek> h
19:11:24 <dmwit> *blink*
19:11:28 <geezusfreeek> oh okay
19:11:34 <geezusfreeek> yeah
19:11:38 <dibblego> is it possible to get lambdabot running yet?
19:11:39 <dmwit> Yup, GHC seems to be having quite a bit of trouble with that.
19:11:52 <dmwit> ?botsnack
19:11:52 <lambdabot> :)
19:11:59 <chessguy> Cale, dmwit is there something actually wrong with the code?
19:12:00 <dmwit> dibblego: She's already going, isn't she?
19:12:21 <dibblego> dmwit, no, I mean your own instance, from source; it was so painful (impossible?) last time I tried
19:12:25 <Cale> chessguy: well, with geezusfreeek's code? Yes.
19:12:28 <geezusfreeek> chessguy: the code is quite wrong (it may have been better in your original version, but this trimmed down version is certainly wrong)
19:12:34 <chessguy> Cale: it's my code :)
19:12:47 <dmwit> Yes, there's several things wrong with it.
19:12:48 <Cale> chessguy: I haven't seen your original code.
19:12:52 <geezusfreeek> whether it's right or wrong shouldn't affect whether or not ghc terminates properly though ;)
19:12:57 <dmwit> right
19:13:05 <Cale> oh, there it is
19:13:32 <Cale> It's the one on hpaste from 2 hours ago?
19:13:41 <chessguy> mm, no
19:13:44 <dmwit> setCastleStatusChar _ = id -- this is one thing that should be changed
19:13:53 <SamB> geezusfreeek: as long as it doesn't create a non-confluent rewrite system with RULES, sure ;-)
19:13:57 <geezusfreeek> Cale: a few minutes ago he requested a darcs pull from anybody willing. lucky i already had a local one :)
19:14:06 <Leimy> anyone here well versed in concurrency support in Haskell?
19:14:19 <Cale> Leimy: Reasonably so?
19:14:20 <SamB> or actually I should say non-strongly-normalizing
19:14:34 <SamB> confluence isn't important for termination, after all
19:14:39 <Cale> Leimy: ask away, and if I can help I will :)
19:14:42 <EvilTerran> Leimy, probably. do you have a problem, or are you just idly wondering? :P
19:14:49 <Leimy> I'm kind of idly wondering
19:14:50 <noecksit> hey, do u guys know if there is a program that pastes to hpaste from the cli?
19:14:56 <noecksit> would be really convenient
19:15:00 <dmwit> setCSC ... = modifyCS f -- this is applied to too few parameters, too
19:15:09 <SamB> noecksit: there aren't any raw links on hpaste?
19:15:11 <Leimy> I've been doing more and more with Erlang, and just a little with Haskell including the par and pseq stuff.
19:15:15 <SamB> oh, wait, you said *to*
19:15:19 <Leimy> But then I ran into this STM stuff too.
19:15:31 <Leimy> and I'm wondering how they could work together or if that even makes sense.
19:15:38 <SamB> noecksit: hmm, well, hpaste has such a tiny size limit anyway...
19:15:40 <EvilTerran> noecksit, it should be fairly easy to knock something together to put together the appropriate POST thing
19:15:43 <mauke> noecksit: http://rafb.net/p/6UzOyg65.html
19:15:44 <lambdabot> Title: Nopaste - No description
19:15:54 <chessguy> Cale: here's the whole current thing: http://hpaste.org/7759
19:16:08 <Leimy> So I guess I'm looking for a bit of documentation on the state of the art for concurrency in Haskell and maybe I already found it :-)
19:16:20 <chessguy> ugh, except it got truncated
19:16:23 <Cale> Leimy: Well, STM is for concurrent thread communication, whereas par is aimed at pure parallelism without concurrency
19:16:52 <geezusfreeek> i'm filing a bug report
19:16:57 <Leimy> I gathered that par was about data parallelism
19:17:05 <Leimy> where you have one of those somewhat embarassingly parallel algorithms
19:17:13 <SamB> Leimy: were you after concurrency (a style in which to write programs) or parallel processing?
19:17:20 <chessguy> geezusfreeek: it's apparently fixed in HEAD
19:17:30 <geezusfreeek> chessguy: oh
19:17:31 <chessguy> Cale: now it's all there
19:17:59 <chessguy> dmwit: ^^
19:18:03 <Cale> Leimy: well, actually for proper data parallelism, there's a new system which is almost but not quite ready
19:18:07 <Leimy> SamB: I'm interested in both.  However, the more practical stuff I've been doing lately has been something along the lines of CSP like communication for program organization.... so I guess a more concurrent style :-)
19:18:16 <geezusfreeek> i'm not very familiar with GHC's dev cycle. are all the changes in HEAD likely to hit 6.8.3 or is there some other branch for it?
19:18:17 <dmwit> chessguy: Gotta run, sorry.
19:18:20 <Cale> Leimy: Perhaps it'll be out in 6.10 (at least, I'm hoping that it is)
19:18:22 <geezusfreeek> (do i still need to report this?)
19:18:26 <chessguy> dmwit: thanks anyway
19:18:32 <Leimy> Cale: that sounds pretty good :-)
19:19:18 <Leimy> I actually liked programming in Plan 9 with typed data channels
19:19:24 <Cale> http://www.londonhug.net/2007/09/25/nested-data-parallelism-video-returns/
19:19:25 <lambdabot> Title: λondon HUG  Blog Archive  Nested Data Parallelism Video Returns!, http://tinyurl.com/2pw275
19:19:26 <Leimy> or Inferno using Limbo's support :-)
19:19:31 <Cale> There's a talk about it :)
19:19:39 <Leimy> Oh cool
19:19:48 <SamB> (parallel processing being any way of taking advantage of SMP or similar tech)
19:20:26 * geezusfreeek moves his pointer to the close box on the window with the bug report form
19:20:26 <SamB> Cale: Parallal arrays aren't anything like Limbo
19:20:43 <Cale> SamB: Is that aimed at Leimy perhaps?
19:21:02 <Leimy> heh
19:21:08 <SamB> I dunno
19:21:38 <SamB> I think I was trying to suggest that you not be overly enthusiastic-sounding about NDP
19:22:03 <EvilTerran> ... as i understand it, the HEAD is the testing ground for what might end up in the next 6.<even>
19:22:20 <geezusfreeek> well shoot, i already closed the window now
19:22:39 <Leimy> Well I've heard of STM before but never really thought about it deeply.  It looks like the STM orElse stuff in GHC could be used to implement something like "alt" in limbo.
19:22:44 <chessguy> geezusfreeek: does the latest code i dumped look wrong?
19:23:00 <Cale> I made my comments without regard to what Leimy said about plan9 stuff :)
19:23:25 <EvilTerran> altho i imagine bug fixes in HEAD may drift into 6.8.*
19:23:26 <SamB> geezusfreeek: HEAD changes that fix bugs that existed in the last stable release are ideally merged into the stable branch one way or another
19:23:38 <geezusfreeek> SamB: okay
19:23:42 <SamB> probably not new features
19:23:46 <petekaz> What's up with the Real World Haskell blog?
19:23:52 <petekaz> It's been down all day long.
19:23:54 <geezusfreeek> chessguy: if you set the definition of that bad function to undefined the compilation still fails, so there are errors somewhere
19:23:59 <geezusfreeek> i don't remember the error now though
19:24:06 <SamB> certainly not the invasive kind...
19:24:08 <petekaz> http://www.realworldhaskell.org/blog/
19:24:13 <EvilTerran> Leimy, Control.Concurrent may even be enough for your purposes. Control.Concurrent.Chans would be enough to do pretty much everything CSP-y, really.
19:24:21 <SamB> petekaz: you could read it on Google Reader
19:24:35 <SamB> Google Reader still has the RSS feed from yesterday (or whenever)
19:25:17 <Leimy> EvilTerran: that sounds pretty sweet
19:25:20 <chessguy> geezusfreeek: something about an infinite type
19:25:23 <Leimy> I just ran into http://research.microsoft.com/Users/simonpj/papers/stm/beautiful.pdf too
19:25:25 <lambdabot> http://tinyurl.com/2hyrxp
19:25:29 <geezusfreeek> chessguy: yup
19:25:32 <Leimy> I think I might get that Beautiful Code book.
19:25:51 <geezusfreeek> chessguy: you can probably get around this ghc bug by writing that one function in a different way though
19:26:02 <chessguy> geezusfreeek: oh?
19:26:06 <geezusfreeek> and then it might be business as usual
19:26:17 <geezusfreeek> chessguy: yeah, just try some alternative styles of writing it
19:26:27 <chessguy> geezusfreeek: which?
19:26:34 <geezusfreeek> chessguy: my suspicion is that it is the parser crapping out
19:27:14 <geezusfreeek> chessguy: i would try using guards instead of patterns first. failing that, try a case. failing that… i hate to say it, but maybe nested ifs
19:27:22 <geezusfreeek> chessguy: and so on
19:27:46 <geezusfreeek> chessguy: also experiment with not using records
19:27:55 <geezusfreeek> chessguy: i think some combination of those should work
19:28:41 <geezusfreeek> *actually i just pulled that suspicion completely out of the air
19:29:02 <chessguy> or...i could just fix the bug
19:29:05 * chessguy sighs
19:29:09 <geezusfreeek> chessguy: its ghc's bug
19:29:14 <chessguy> @pl \c -> f c c
19:29:15 <lambdabot> join f
19:29:24 <chessguy> geezusfreeek: no, there's a bug in my code too
19:29:36 <geezusfreeek> chessguy: right, but you can't fix it until you know it will compile in the first place
19:29:51 <geezusfreeek> chessguy: get it to where you can at least see some compiler errors instead of just nothing
19:29:52 <chessguy> geezusfreeek: except that i just did :)
19:30:10 <geezusfreeek> chessguy: right. once you get that error straitened out then move on to rewriting that other function
19:30:15 <geezusfreeek> *straightened
19:30:24 <SamB> see, this is why we should write our Haskell compilers in Agda ;-P
19:30:33 <geezusfreeek> SamB: :)
19:30:54 <vixey> if only it wasn't so hard
19:31:00 <SamB> yeah
19:32:31 * vixey tries to specify lazy evaluation
19:33:02 <SamB> vixey: oh, I just meant so that they would terminate or turn orange
19:39:31 <dancor> what do you do if compiling lambdabot says e.g. Lib/Parser.hs:8021:4: Not in scope: `pling_name'
19:39:48 <dancor> Lib/Parser.hs does have import Language.Haskell.Syntax
19:39:53 <dancor> and it's ghc 6.8.2
19:40:14 <Cale> Leimy: If you haven't seen the original paper documenting STM, I recommend that as well :)
19:40:31 <chessguy> @pl s x c = f c c
19:40:31 <lambdabot> s = const (join f)
19:40:59 <chessguy> @pl s x c = f x c c
19:40:59 <lambdabot> s = join . f
19:41:56 <dmwit> Terminate... or turn orange?
19:42:38 <chessguy> @pl s 'k' c = m f c c
19:42:38 <lambdabot> (line 1, column 9):
19:42:38 <lambdabot> unexpected "="
19:42:38 <lambdabot> expecting variable, "(", operator or end of input
19:42:39 <SamB> dmwit: Agda code turns orange when Agda can't see why it would terminate
19:43:02 <chessguy> whatever
19:43:07 <dmwit> oh
19:43:10 <chessguy> conal: ping?
19:43:16 <EvilTerran> SamB, that's cool. i've gotta try Agda sometime
19:43:23 <dmwit> chessguy: Pattern matching can't be pl-ed in the general case.
19:44:06 <cpst> Cale: you mean this paper? http://citeseer.ist.psu.edu/shavit95software.html
19:44:07 <lambdabot> Title: Software Transactional Memory - Shavit, Touitou (ResearchIndex)
19:44:36 <Cale> cpst: Perhaps I should have said the original STM in Haskell paper :)
19:44:52 <cpst> ah, because the original one isn't very well written ;-)
19:47:30 <dejones> Any ideas why GHC might respond with "<command line>: unknown package: concurrent" ??  Control.Concurrent is in base... so I am confused why this might happen.
19:50:42 <dejones> Anyone else ever get that error?  (not necessarily with the package concurrent)
19:56:15 <Cale> http://www.haskell.org/~simonmar/papers/stm.pdf  in case anyone's still wondering :)
19:56:46 <Cale> http://haskell.org/haskellwiki/Research_papers/Parallelism_and_concurrency has a lot of the relevant papers for concurrency and parallelism in Haskell.
19:56:46 <lambdabot> Title: Research papers/Parallelism and concurrency - HaskellWiki, http://tinyurl.com/t83sk
20:02:30 <povman> thinking about data syntax
20:02:39 <povman> http://hpaste.org/7760
20:03:18 <vixey> povman: can't you use (<)?
20:03:45 <povman> i dunno :p i wasn't sure if that would conflict with the existing <
20:04:21 <dmwit> povman: What are you trying to do / what's your question?
20:04:45 <povman> the interesting bit is the definitions of boolOrd and boolOrdBack
20:05:17 <dmwit> povman: You haven't gotten the syntax right, I think.
20:05:31 <povman> that's a syntax proposal :)
20:05:36 <dmwit> Oh!
20:05:48 <dmwit> I don't like it. =)
20:05:49 <povman> currently the only way you can do that nicely is to use a where or something
20:06:10 <povman> underneath
20:06:24 <vixey> povman: Are you working on a parser for your now syntax?
20:06:31 <dmwit> When I see "boolOrd = Ord2 where" I immediately stop parsing and think of "boolOrd" as a function "boolOrd :: (a -> a -> Bool) -> Ord2 a".
20:07:21 <dmwit> It seems like an odd irregularity to add to the language.
20:07:29 <dmwit> povman: Out of curiosity, why do you want it?
20:07:31 <povman> i thought about it for about 15 seconds
20:07:33 <roconnor> are ML applicative functors related to Haskell applicative functors?
20:08:25 <povman> there are times when type clases aren't enough
20:08:34 <povman> eg when you want two definitions of Ord for some type
20:08:35 <dmwit> povman: Also, the second and third lines scare me, since they don't specify the name of a constructor at all.
20:08:44 <dmwit> povman: So use newtype.
20:08:51 <povman> the constructor there is implicit
20:09:09 <dmwit> newtype BackwardsBool = BackwardsBool Bool deriving (Eq, Show, Enum)
20:09:16 <dmwit> instance Ord BackwardsBool where ...
20:10:16 <mxc> are there any ex-vimmers using YI full time?
20:10:31 <povman> i see...
20:10:41 <dolio> roconnor: It would appear not.
20:11:03 <roconnor> ah darn
20:12:03 <povman> dmwit :) thanks
20:12:03 <roconnor> @type map
20:12:09 <roconnor> @type fmap
20:12:09 <dolio> roconnor: Apparently, by applicative, ML people mean that a = b ==> F a = F b for types a and b and functor F.
20:12:19 <lambdabot> thread killed
20:12:24 <lambdabot> thread killed
20:12:29 <Cale> @undef
20:12:34 <roconnor> dolio: isn't that a logical validity?
20:12:38 <roconnor> @type fmap
20:12:43 <Cale> oh...
20:12:45 <lambdabot> thread killed
20:12:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:13:06 <Cale> code.h.o is just running very slowly at the moment
20:13:07 <dolio> Whereas applicative functors in haskell are about using decorated functions like normal function application.
20:13:16 <cpst> roconnor: no, in Standard ML, functors are generative, meaning they create new structures every time they are applied
20:13:32 <dolio> roconnor: Apparently in some (old?) ML implementations, those two types wouldn't be interchangeable.
20:14:00 <cpst> it's undecidable, even for the simple module language, to decide whether any two functor applications are actually the same functor application, which makes these definitions tricky
20:14:01 <roconnor> so F a may not equal F a?
20:14:09 <roconnor> @type (.)
20:14:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:14:15 <cpst> roconnor: yes
20:14:25 <roconnor> ugh,
20:14:28 <cpst> roconnor: let's say you made two symbol tables from the same functor
20:14:34 <cpst> roconnor: you don't want them to mix ;-)
20:14:47 <dons> roconnor: did you get bit by Cale's generalised composition?
20:14:56 <roconnor> cpst: oh because data structurs can have refs in them?
20:15:08 <roconnor> nah, I was ughing the ML functors
20:15:19 <roconnor> @type (Prelude..)
20:15:21 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:15:40 <dmwit> ?type Prelude.(.)
20:15:42 <lambdabot> Not in scope: data constructor `Prelude'
20:15:54 <cpst> roconnor: yeah, generative functors tend to be more useful for modules with side-effects, whereas applicative functors make more sense for pure modules
20:15:57 <roconnor> I'm contemplating using ♂ for fmap in my paper
20:16:04 <roconnor> cause it kinda looks like compose
20:16:11 <roconnor> and it is asymetric
20:16:20 <roconnor> and it sort of has a lifting feel to it.
20:16:50 <glguy> You'd need a catchy paper title if you did
20:17:10 <roconnor> glguy: why?
20:18:19 <dolio> How about superscript-black-dot?
20:18:28 <dolio> I think that's what the Bananas... paper uses.
20:18:40 <roconnor> @where bananas
20:18:40 <lambdabot> I know nothing about bananas.
20:18:54 <dolio> @hoogle bananas lenses barbed-wire
20:18:55 <dmwit> ?go bananas barbed wire lenses
20:18:56 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-wire'
20:18:57 <lambdabot> http://citeseer.ist.psu.edu/meijer91functional.html
20:18:57 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
20:19:04 <dolio> Oops, wrong plugin.
20:19:17 <dmwit> Everybody always forgets the envelopes part.
20:19:19 <roconnor> dolio: seems kinda symetric for my liking, but I'll have a look
20:19:40 <dolio> Well, it's more like it's applied to the function you're mapping.
20:19:56 <dolio> So if f :: a -> b, f* :: F a -> F b.
20:20:05 <roconnor> oh
20:20:11 <roconnor> so it is attached to the f
20:20:13 <roconnor> right
20:20:25 <roconnor> I used a horizontal bar over f in one paper
20:20:33 <roconnor> and a carrot for unit
20:20:35 <dolio> Oh, my bad, superscript black dot is the constant function.
20:20:43 <roconnor> and a chevron for bind
20:20:57 <roconnor> but I'm using @ for app
20:20:59 <dolio> Asterisk is map.
20:21:00 <dejones> g'night everyone.
20:21:00 <dejones> :)
20:21:02 <roconnor> so I kinda want an infix for map
20:22:02 <vixey> why not . ?
20:22:13 <vixey> ambiguous?
20:22:37 <roconnor> vixey: . is used in math like $
20:22:41 <roconnor> means bracket to the end
20:22:51 <Cale> uh, it is?
20:22:52 <roconnor> although it is usually only seen with forall and exists
20:22:58 <vixey> oh right
20:23:02 <Cale> Oh, like an actual period?
20:23:02 <vixey> well ?
20:23:08 <vixey> is what I really meant
20:23:10 <EvilTerran> isn't the normal one for composition in math an empty bullet?
20:23:20 <roconnor> vixey: I just see ?
20:23:29 <roconnor> vixey: do you mean middot
20:23:29 <vixey> yes hence me using . before
20:23:32 <Cale> \cdot might make a good map
20:23:33 <roconnor> or do you mean ring?
20:23:33 <vixey> yse
20:23:40 <vixey> no not ring
20:23:45 <vixey> I'd keep ring for function composition
20:23:52 <roconnor> middot is used for group actions
20:24:00 <roconnor> or monoid actions
20:24:00 <vixey> what like multiplication
20:24:12 <dmwit> Since when was overloading something math papers avoided?
20:24:17 * EvilTerran usually sees ring for function composition, and middot for function composition
20:24:18 <roconnor> although you might be able to confince me that map is an action
20:24:27 <vixey> > (return.(+1)) =<< [1,2,3]
20:24:29 <roconnor> convince
20:24:30 <lambdabot>  [2,3,4]
20:24:43 <EvilTerran> er, what
20:24:47 <dmwit> EvilTerran: You see both of them used for function composition?
20:25:00 <EvilTerran> *middot for multiplication and whatnot
20:25:43 <EvilTerran> dmwit, er, well, i've had ~4 hours of sleep in the last ~40. my brain is not at 100%.
20:25:51 <dmwit> Oh... I'm sorry.
20:26:00 <dmwit> I hope you get some good quality sleep soon.
20:26:21 <EvilTerran> no need to apologise, it's entirely my fault. and, yes, i'll probably get some good quality sleep any minute nzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
20:26:33 <vixey> hehe
20:27:34 <roconnor> dolio: they use * for map where * is the functor
20:27:52 <roconnor> Not so unreasonable
20:28:07 <dolio> Yeah. It's almost like category theory, only backwards.
20:28:52 <roconnor> I'd still like something infix, so it looks nice with @ (ap)
20:29:25 <dolio> Just make sure you use left/right-accented-pi. :)
20:30:08 <roconnor> dolio: that's nicer than pi1 and pi2 that I've used
20:30:21 <roconnor> although everyone knows what pi1 and pi2 are.
20:30:49 * EvilTerran has taken to writing 1/pi as an upside-down pi when doing math with lots of pis on the bottom of otherwise straightforward fractions
20:31:12 <roconnor> :)
20:31:35 <roconnor> I'm still leaning to ♂
20:31:42 <roconnor> I'll suggest it to my advisor
20:31:58 * EvilTerran figures wandering bedwards would be prudent at this point
20:32:00 <EvilTerran> > g'night
20:32:02 <lambdabot>  Sleep well!
20:32:40 <dolio> Are you going to have the female symbol for something?
20:32:45 <dolio> You wouldn't want to be accused of bias.
20:32:53 <roconnor> dolio: not planing
20:34:00 <dolio> You could name functors with them.
20:34:13 <roconnor> maybe I should use ♁
20:34:16 <dolio> Then have ⚤ for their composition.
20:34:21 <roconnor> but it is symmetric
20:35:08 * dmwit sighs
20:35:20 <dmwit> Unicode really has a character for that?
20:35:37 <dolio> It has a whole bunch, apparently.
20:35:58 <roconnor> dmwit: ♁ means earth
20:36:18 <dmwit> I was mostly complaining about having a character that combines the male and female symbol.
20:36:22 <roconnor> they have one for every major planet
20:36:28 <roconnor> oh
20:36:37 <roconnor> I couldn't see dolio's for some reason
20:36:38 <dolio> ♂ ♀ ☿ ⚥ ⚧ ⚢ ⚣ ⚤ ⚦ ⚨ ⚩ ⚪ ⚲
20:36:49 <roconnor> :/
20:36:59 <dolio> Did any of those work?
20:37:01 <roconnor> I just see mars venus and mercury
20:37:09 <dmwit> dolio: I can see them all.
20:37:15 <dolio> Ah, okay.
20:37:24 <roconnor> must be my font
20:37:49 <cjs> http://haskell.org/papers/modular-interpreters.ps
20:38:28 <cjs> So in section 5.1 of that guy there, are "unitInj" and "bindPrj" just the return and >>= operators, or am I missing something?
20:41:02 <Cale> I see all of them.
20:46:52 <thetallguy> ?seen conal
20:46:53 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 2h 20m 59s ago.
20:47:59 <conal> thetallguy: i'm here
20:48:18 <Cale> conal: Your derivative post is surprisingly controversial: 101 up, 58 down
20:48:30 <conal> oh?
20:48:41 <cjs> Which post?
20:48:46 <Cale> http://reddit.com/r/programming/info/6jw8w/details
20:48:58 * conal looking at comments
20:49:02 <thetallguy> Heh.  Do you suppose it's his use of westish and southish in place of westerly and southerly?
20:49:22 <Cale> It's not for any good reason I think. There's a lot of anti-intellectualism on programming reddit now.
20:49:36 <conal> thetallguy: i started with the -ly terms, but then i remembered that they're sometimes used to mean the opposite of what i had in mind
20:49:50 <thetallguy> 'cause after all, programming is a working man's job.
20:50:21 <thetallguy> conal: only with winds, I think.
20:50:30 <conal> thetallguy: odd
20:50:45 <thetallguy> conal: but I dig.  Anyway, mostly I just found it amusing.
20:50:45 <conal> Cale: thanks much for adding explanations about why derivatives are are linear transformations (calculus on manifolds).
20:51:06 <Cale> no problem :)
20:51:31 <thetallguy> conal: westish and southish sound like purveyors of plum pudding and other fine British cuisine.
20:52:34 <thetallguy> Also, I think that's the first description of partial derivatives I've ever read that didn't mention an ant on a hot plate.
20:53:24 <Korollary> Cale: pretty much any article gets about -30 or -40 on reddit
20:55:24 <thetallguy> There's a job placement service that only hosts jobs over $100K/yr. They have an ad showing a game of tennis with zillions of bad tennis players, saying see what happens when you let everyone in?
20:55:57 <thetallguy> Maybe someone needs to do slashdot/reddit with restrictions.
20:56:23 <roconnor> there is the smart subreddit
20:56:31 <roconnor> joelthelion is the gatekeeper
20:56:57 <sclv> I've never read about an ant on a hot plate ever.
20:57:10 <sclv> maybe I don't understand math at all... :-(
20:57:14 <dmwit> roconnor: Wow!
20:57:21 <dmwit> bookmark'd
20:57:22 <roconnor> dmwit: what?
20:57:55 <roconnor> dmwit: feel free to ask to join.
20:58:10 <dmwit> The benefits of joining are that you can submit?
20:58:15 <Cale> I can imagine what a description of partial derivatives which involved an ant on a hot plate might involve, but I've never seen that description myself.
20:58:23 <vixey> I don't really get the reddit facination
20:58:59 <roconnor> vixey: I find it is kinda like a usenet facination
20:59:48 <dmwit> roconnor: Oh, is commenting moderated, too?
20:59:52 <dmwit> roconnor: Maybe I will ask to join.
20:59:58 <thetallguy> Maybe I just felt so sorry for the poor ant that I never forgot it.
21:00:05 <sclv> Reddit is the worst high-traffic forum out there except for all the other high-traffic forums.
21:00:16 <thetallguy> roconnor: thanks for the info on reddit/smart
21:00:21 <roconnor> dmwit: I think so.  Not entirely sure how the moderating works.  I asked to join near the beginning.
21:00:49 <thetallguy> roconnor: also, going back to the chunk problem, I tried your unfold, but it was half the speed of my solution
21:01:03 <thetallguy> roconnor: haven't tried to sort out why, yet.
21:01:48 <dolio> Cale: It's all the small variable names. They make it so hard to read!
21:02:33 <cpst> descriptive variable names ftw
21:02:55 <cpst> the guy who made that post reviews a lot of the code I write
21:03:12 <cpst> and yes, if I did that it would automatically fail review
21:03:52 <Cale> heh
21:04:21 <dolio> That complaint's been showing up a lot lately.
21:05:09 <cpst> dolio: if you work on a million line codebase, you'll develop the same complaint
21:05:29 <cpst> or, to be more fair, you wouldn't be surprised to develop it ;-)
21:05:55 <dolio> Yeah, I don't doubt it for large software systems.
21:06:12 <dolio> But not for stuff like 'map f (x:xs) = f x : map f xs'.
21:06:15 <Cale> limit Euclidean_Norm(offset) -> 0 of Euclidean_Norm(the_function(the_point + offset) - the_function(the_point) - the_derivative(offset))/Euclidean_Norm(offset) = 0
21:06:24 <cpst> the Jane Street blog just had a post about their convention regarding arguments to functions in modules
21:06:39 <Cale> We need enterprisey mathematics for an enterprisey world!
21:06:41 <cpst> they made the convention be that the argument of the type of the module is always first
21:06:49 <cpst> even for map
21:07:20 <cpst> just for consistency, so you never have to think about it ever
21:07:27 <dolio> So it's 'map t f'?
21:07:34 <cpst> yes
21:07:35 <gwern> jane street has a blog?
21:07:47 <cpst> but you have labelled arguments in OCaml, so you can curry the parameter you want still
21:07:56 <dolio> Ah.
21:08:13 <cpst> gwern: http://ocaml.janestcapital.com/
21:08:14 <lambdabot> Title: ocaml.janestcapital.com
21:08:17 <gwern> http://ocaml.janestcapital.com/ ?
21:08:18 <lambdabot> Title: ocaml.janestcapital.com
21:08:33 <roconnor> thetallguy: really, half the speed.  -O2?
21:10:30 * roconnor reviews the difference between code in http://hpaste.org/7670
21:10:49 <dogbite> I just posted yet another introduction to monads to my blog.  I'd welcome any feedback on it.  I wrote it largely to help myself, but I'd still appreciate feedback.
21:10:53 <dogbite> http://techguyinmidtown.com/2008/05/20/monads-demystified/
21:10:54 <lambdabot> Title: Monads Demystified  tech guy in midtown
21:10:58 <roconnor> thetallguy: I assume you caught the minor error in my code.
21:11:20 <dolio> Heh, I haven't seen a new monad tutorial in a while.
21:11:40 <dogbite> dolio: 24 hours?
21:11:56 <cpst> has anyone written a monad tutorial tutorial?
21:12:09 <leimy> a meta tutorial?
21:12:15 <ivanm> dammit, I was about to say that!
21:12:18 <dogbite> cpst: the thought occurred to me
21:12:22 <roconnor> cpst: I've often thought about it.
21:12:34 <dogbite> cpst: i wasn't smart enough to do it
21:12:35 <cpst> you could get really meta and express it using monads
21:12:39 <thetallguy> roconnor: there was a small error, don't remember what it was.  missing argument or something
21:12:55 <roconnor> cpst: I went to look for a tutorial on how to write monad tutorial tutorials, but didn't find any advice.
21:13:10 <roconnor> thetallguy: right, the l argument should be dropped.
21:13:20 <thetallguy> roconnor: yes, -O2
21:13:21 <roconnor> or added to the RHS
21:13:36 <leimy> can
21:13:38 <Cale> I sort of intended "Monads as Computation" as a monad tutorial tutorial, since a lot of monad tutorials I'd seen had completely missed some fundamental points (like why the hell do we bother making the abstraction)
21:13:38 <leimy> er
21:13:42 <dolio> I think the tutorial tutorial is "1. Don't write monad tutorials."
21:13:45 <leimy> can't recall runtime SMP options :/
21:14:03 <roconnor> thetallguy: this is totally unfair I'm calling splitAt  and you are calling both take and drop
21:14:20 <dmwit> ?src splitAt
21:14:20 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
21:14:22 <dmwit> ;-)
21:14:25 <roconnor> thetallguy: your's ought to be slow.
21:14:28 <leimy> dons' blog to the rescue!
21:14:47 <dogbite> Cale: yeah, that's one of the things that made monads as computation nice
21:15:04 <roconnor> dmwit: :P
21:16:02 <thetallguy> roconnor: that's what I expected.
21:16:05 <roconnor> @src unfoldr
21:16:05 <lambdabot> unfoldr f b  = case f b of
21:16:05 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
21:16:05 <lambdabot>    Nothing        -> []
21:16:24 <dons> do people follow the janest blog?
21:16:38 <dolio> We need the leet stream fusion for lists to go in.
21:16:43 <roconnor> thetallguy: I want a second opinion. :)
21:16:47 <cpst> dons: I read it
21:16:58 <thetallguy> roconnor: I'll put the code back in place and paste it.
21:16:59 <dons> there's a bit of a movement to start a galois blog with similar themes -- building stuff, high assurnace et al. i need to talk to the web people some more
21:17:29 <dons> dolio: you know where the stream-fusion package is :)
21:18:19 <solrize> i look at janest now and then, but i'm not an ocaml'er.  a galois blog would be great.
21:18:20 <dolio> That's not going to help thetallguy. :)
21:19:13 <cpst> the best things on the Jane Street blog are the little tricks they post
21:19:43 <cpst> or situations they've run into writing large applications
21:19:54 <cpst> I think most posts on the blog mention modules in some form ;-)
21:20:26 * sclv wonders if the constructors/pattern matching on unfoldr are what slows it down
21:21:01 <dmwit> thetallguy, roconnor: I debated putting this up, but: http://hpaste.org/7670#a2
21:21:07 <sclv> and if so if there isn't some pointer tagging hack for very simple adts...
21:21:18 <roconnor> sclv: oh, the pairing depairing
21:21:47 <roconnor> sclv: actually that could be very bad for splitAt
21:22:08 * roconnor tries to imagine the source for splitAt
21:22:12 <sclv> actually I was thinking of the Just/Nothing stuff...
21:22:16 <vixey> @src splitAt
21:22:17 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
21:23:04 <roconnor> dmwit: cute
21:23:13 <leimy> So GHC parallelism is interesting as all heck.
21:23:48 <sclv> the real splitAt: http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-List.html#splitAt
21:23:48 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/23ncyu
21:24:02 <roconnor> dmwit: although not the function I'd call ensure
21:24:15 <dmwit> roconnor: What would you name that function?
21:24:21 <roconnor> dmwit: not sure
21:24:33 <dmwit> It's pretty handy.
21:24:43 <roconnor> I would call ensure :: (a -> Bool) -> m a -> m a
21:24:50 <roconnor> hmm
21:24:54 <roconnor> but maybe yours is better
21:25:37 <dmwit> I've never actually wanted that.
21:25:49 <roconnor> which is probably why yours is better
21:25:50 <roconnor> :)
21:25:53 <dmwit> heh
21:27:59 <roconnor> oh
21:28:07 <roconnor> I think my function is filter.
21:28:39 <sclv> hmmm... I wonder if splitAt can be written with unboxed tuples...
21:29:05 <roconnor> sclv: or CPS?
21:29:15 <sclv> unboxed tuples probably wouldn't work...
21:29:35 <vixey> @src splitAt
21:29:35 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
21:29:47 <sclv> vixey: see above.
21:29:56 <sclv> the real splitAt is fancier.
21:30:02 <roconnor> splitAt : Int -> [a] -> ([a] -> [a] -> r) -> r
21:31:24 <sclv> take and drop also get fusion rules, while splitAt doesn't (can't ?)
21:31:29 <vixey> how would you write chunks using that tuple?
21:31:34 <vixey> I mean ... that CPS versionn
21:31:38 <thetallguy> The times aren't so clear any more
21:31:59 <sclv> well, take gets fusion... drop doesn't.
21:32:45 <thetallguy> dolio: I didn't get the joke.
21:32:49 <dons> splitAt has some interesting sharing, iirc
21:33:06 <dons> oh, its stream fusible, i note.
21:33:18 <thetallguy> dmwit: I added yours as chunk3
21:33:19 <dons> but not perfectly, only as a consumer
21:33:20 <dons> splitAt :: Int -> Stream a -> ([a], [a])
21:33:24 <dons> which makes sense
21:33:40 <roconnor> vixey: oh right, you need tuples for unfoldr
21:33:50 <roconnor> vixey: but internally maybe it could use CPS?
21:34:40 <roconnor> current implemenation of splitAt: http://hpaste.org/7762
21:34:53 <dons> new monad tutorial, http://techguyinmidtown.com/2008/05/20/monads-demystified/
21:34:53 <lambdabot> Title: Monads Demystified  tech guy in midtown
21:34:55 <roconnor> it seems like it would do a lot of tuple creation and destruction
21:35:06 <roconnor> I don't know if GHC optimizes that away.
21:35:34 <roconnor> but given my experiences with the mtl
21:35:39 <dons> hmm
21:35:44 <roconnor> I don't have a lot of faith in GHC 6.6
21:36:01 <dons> roconnor: its not even remotely similar to the inlining stuff in mtl
21:36:03 <sclv> you can't unbox the tuples because you need to keep their contents polymorphic, i think...
21:36:19 <roconnor> sclv: why not CPS?
21:36:32 <sclv> no reason, i'm just thinking on a different track...
21:36:33 <roconnor> dons: how is it dissimilar?
21:36:51 <roconnor> sclv, oh right, you are talking about unboxed tuples
21:37:01 <roconnor> sclv, yeah, polymorphism ...
21:37:11 <dons> version in http://hpaste.org/7762#a1
21:37:51 <dons> oh, that looks like CPR , doesn't it?
21:38:06 <dons> it immediately takes apart the pair, so shouldn't be needed.
21:38:23 <roconnor> dons: CPR?
21:38:31 <sclv> hmm.. it might be able to be a fold/build consumer too...
21:39:00 <dons> the pairs are translated to unboxed tuples
21:39:07 <dons> so the pointers live in registers (or on the stack)
21:39:12 <dons> and the actual pair isn't created
21:39:21 <roconnor> dons: oh good.
21:39:26 <roconnor> how do you know this?
21:39:33 <dons> wsplitAt' :: Int# -> [a] -> (# [a], [a] #)
21:39:34 <cpst> look at the Core
21:39:35 <cpst> sheesh
21:39:48 <cpst> haven't you been following Reddit? ;-)
21:39:48 <mxc> :t mapM
21:39:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
21:39:55 <roconnor> cpst: :)
21:40:11 <dons> people are too pessimistic about what ghc does.
21:40:33 <dons> well, roconnor is anyway
21:40:35 <dons> :)
21:40:43 <roconnor> dons: but what about what ddarius says on the CPS for monad transformers
21:40:44 <dons> others are too optimistic. cough
21:40:56 <cpst> it'll cure cancer
21:41:03 <cpst> if it inlines one more function, it'll be like -fmlton
21:41:09 <dons> so my theory with mtl is that its just over some inlining threshold. but no one sent me an example to look at.
21:42:04 <dons> cpst: here's a lib designed to be entirely inlined, http://code.haskell.org/~dons/code/uvector/Data/Array/Vector/Stream.hs :)
21:42:05 <lambdabot> http://tinyurl.com/58efs2
21:42:36 <dons> so with a little bit of care, you can do some funky whole program things
21:42:39 <thoughtpolice> yes, it emits some very nice core output :)
21:42:40 <dolio> dons: Have you looked at any of my sorting stuff?
21:42:57 <dolio> You're the performance guru, after all.
21:43:07 <dons> dolio: not yet. was there something i should look at?
21:43:41 <dolio> Not especially. I have a lot of different sorts, but I may be at my limit for a bit with how fast they're going to get.
21:43:48 <dons> hmm, so the current splitAt really is unboxed. how odd
21:44:11 <roconnor> dons: can it do that because the lists protect the polymorphism?
21:44:25 <dolio> I've been looking at GNU's STL implementation, but I can't immediately tell why their stuff is so much faster than mine. :)
21:44:27 <dons> roconnor: the pairsS? yeah.
21:44:46 <cpst> dons: well, it is good you can force it to inline things
21:45:03 <cpst> the syntax could be a bit better, but that's like choosing the colour of icing on your birthday cake
21:45:51 <sclv> but like I said.. in a chunks implementation the issue is probably the Just and Nothing constructors, no?
21:47:37 <roconnor> I wonder what the core for tallguy vs mine, vs dmwit is.
21:47:43 <roconnor> for chunks
21:47:45 <thetallguy> lets find out
21:49:36 <roconnor> it's probably all the same :P
21:50:35 <dons> splitAt fuses as a good stream consumer, the core story, http://hpaste.org/7762#a2
21:50:51 <vixey> > let chunk n list = split' n list (chunk n) where split' 0 l k = k l ; split' n (x:xs) k = x : split' (n-1) xs k in chunk 3 [1..27]
21:50:53 <lambdabot>   Non-exhaustive patterns in function split'
21:53:06 <sclv> http://hpaste.org/7762#a3 -- chunks and inGroupsOf core
21:53:15 <thetallguy> http://hpaste.org/7761#a2
21:54:03 <dibblego> dons, has lambdabot got any easier to install?
21:54:18 <vixey> lambdabot is very easy to install
21:54:22 <dons> sclv: that doesn't look like -O2 output?
21:54:40 <dons> oh maybe. hmm. it looks a little weird.
21:54:46 <dmwit> > let chunk n list = split' n list (chunk n) where split' 0 l k = k l; split' n [] k = [[]]; split' n (x:xs) k = onHead (x:) (split' (n-1) xs k); onHead f (x:xs) = f x : xs in chunk 3 [1..27]
21:54:47 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]]
21:56:23 <dibblego> "If you're *not* using ghc 6.6, build the Data.ByteString library..." -- what about GHC 6.8.2?
21:56:23 <roconnor> well, the drop take and splitAt are still there.
21:56:23 <dmwit> > let chunk n list = split' n list (chunk n) where split' 0 l k = [] : k l; split' n [] k = [[]]; split' n (x:xs) k = onHead (x:) (split' (n-1) xs k); onHead f (x:xs) = f x : xs in chunk 3 [1..27]
21:56:23 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,...
21:56:23 <sclv> ghc --make -O2 spl.hs -ddump-simpl -- is this wrong?
21:56:23 <dmwit> vixey: But that has a subtle bug, I think.
21:56:23 <dmwit> > let chunk n list = split' n list (chunk n) where split' 0 l k = [] : k l; split' n [] k = [[]]; split' n (x:xs) k = onHead (x:) (split' (n-1) xs k); onHead f (x:xs) = f x : xs in chunk 3 []
21:56:24 <lambdabot>  [[]]
21:56:29 <dmwit> > let chunk n list = split' n list (chunk n) where split' 0 l k = [] : k l; split' n [] k = [[]]; split' n (x:xs) k = onHead (x:) (split' (n-1) xs k); onHead f (x:xs) = f x : xs in chunk 3 [1]
21:56:30 <lambdabot>  [[1]]
21:56:35 <dmwit> > let chunk n list = split' n list (chunk n) where split' 0 l k = [] : k l; split' n [] k = [[]]; split' n (x:xs) k = onHead (x:) (split' (n-1) xs k); onHead f (x:xs) = f x : xs in chunk 3 [1,2,3]
21:56:37 <lambdabot>  [[1,2,3],[]]
21:56:59 <dmwit> I wonder if that's as easy as changing the one case.
21:57:08 <dmwit> > let chunk n list = split' n list (chunk n) where split' 0 l k = [] : k l; split' n [] k = []; split' n (x:xs) k = onHead (x:) (split' (n-1) xs k); onHead f (x:xs) = f x : xs in chunk 3 [1,2,3]
21:57:10 <lambdabot>  [[1,2,3]]
21:58:22 <dmwit> Cool!
21:58:50 <dmwit> vixey: Of course, "onHead" still pattern matches. =P
21:59:23 * dancor is trying to install \bot right now, multiple versions of bytestring make things superfun
21:59:40 <ivanm> lol
21:59:55 <dancor> streamfunsion
22:00:30 <dibblego> vixey, lambdabot requires zlib, which doesn't even have a README and seems to require compiling C; I'm only just getting started and I'm already hosed - it's not easy
22:01:10 <dancor> dibblego: zlib was standard cabal build for me
22:01:12 <dmwit> Your distribution doesn't have zlib?
22:01:23 <dmwit> Or are you installing it somewhere you don't have root...
22:01:30 <vixey> dibblego :(
22:01:39 <dibblego> I installed zlib in my distribution
22:01:42 <dons> hehe awesome
22:01:43 <dons>  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/checked-0.1.0.0
22:01:44 <lambdabot> http://tinyurl.com/6kg6kk
22:01:45 <vixey> dibblego, I just did cabal install and that worked fine
22:01:52 <saml> how can I concat [Set k v] -> Set k v
22:02:12 <dmwit> :t S.union
22:02:15 <lambdabot> forall a. (Ord a) => S.Set a -> S.Set a -> S.Set a
22:02:17 <dmwit> :t S.unionAll
22:02:19 <lambdabot> Couldn't find qualified module.
22:02:21 <vixey> dibblego, I had to add --user to the build script thugh
22:02:34 <dmwit> saml: Uh... Set has kind * -> *, maybe you mean Map?
22:02:38 <saml> :t S.unions -- thanks dmwit
22:02:40 <lambdabot> forall a. (Ord a) => [S.Set a] -> S.Set a
22:02:45 <dibblego> vixey, I'm getting compile errors since GHC can't find zlib.h
22:03:13 <dancor> dibblego: does that file exist anywhere
22:04:21 <dibblego> dancor, looking; but I apt-get install zlib
22:04:52 <dibblego> er zlibc
22:05:10 <dmwit> apt-get install zlibc-dev # ??
22:05:49 <sclv> oh, cool on that checked stuff..
22:05:54 <dibblego> no such package (or similar one)
22:06:02 <sclv> lower level than I expected though...
22:07:02 <dibblego> I take it back; zlib1g-dev or zlib1g-dbg seems to have done the job
22:07:08 <dancor> dibblego: if you don't have e.g. /usr/include/zlib.h you need something else, maybe zlib1g-dev.  yes
22:07:09 <dmwit> dibblego: zlib1g-dev is what it's called here
22:07:16 <dmwit> Oops, you already found it. =P
22:07:19 <dibblego> sorry about that
22:07:30 * dibblego next hurdle
22:09:23 <dolio> sclv: It's not really low level. It's just that it's written in C preprocessor macros.
22:10:54 <sclv> you say tomato...
22:11:01 <sclv> :-)
22:11:23 <dolio> :)
22:11:36 <dolio> The macros generate pretty ordinary haskell code.
22:12:05 <dolio> 'newtype Int = I Int deriving (... lots of generalized newtype deriving)'
22:12:37 <dolio> And then tests against min/maxBound.
22:12:50 <dolio> And so on.
22:13:19 <vixey> @pl \ p q -> p [] : q
22:13:19 <lambdabot> (:) . ($ [])
22:13:24 <dolio> Clearly he/she should have used template haskell, though. :)
22:17:27 <cpst> use m4
22:18:28 <vixey> chunk n list = ch' list n id n
22:18:29 <vixey> ch' [] _ k n = [k []]
22:18:29 <vixey> ch' ys 0 k n = ((:) . ($ [])) k (ch' ys n id n)
22:18:29 <vixey> ch' (y:ys) (c+1) k n = ch' ys c (k . (y:)) n
22:19:36 <Level1Tech> Yeah this channel has to be buzzing...wow...haskell, yeah baby
22:19:59 <vixey> Level1Tech: yeah!
22:20:04 <Level1Tech> Im crying tears of blood just thinking about haskell
22:20:06 <Level1Tech> wooot
22:20:47 * vixey gives Level1Tech some lambda coated catacake
22:20:48 <thetallguy> vixey: that's fast
22:20:48 <Level1Tech> Yo vixey...how has haskell improved your live
22:21:32 <dmwit> I have more friends now.
22:21:33 <thetallguy> vixey: what let you to that implementation?
22:21:37 <vixey> Level1Tech: http://www.flippac.org/talks/aspie.pdf
22:21:46 <Level1Tech> whoa now...slow down there, that one was way over my head.... be careful or Ill send over some zeta tau cat poop coffee...
22:21:53 <vixey> thetallguy: I was thiking about CPS style
22:21:57 <vixey> as roconnor suggested
22:22:30 <Level1Tech> I prefer doggy style, but hey, thats just me
22:22:37 <thetallguy> Oh, right, I remember his post about that.
22:22:40 <vixey> Level1Tech, lol .. I think I'll pass on that one
22:23:49 <vixey> thetallguy: how does it compare?
22:23:58 <vixey> to the others
22:24:06 <thetallguy> time ./ChunkTiming 4 10 100000000
22:24:06 <thetallguy> 10000000
22:24:06 <thetallguy> real	0m4.417s
22:24:08 <Level1Tech> hey, seriously though, Im looking at that powerpoint, and my soon to be brother in law has aspergers
22:24:28 <thetallguy> time ./ChunkTiming 1 10 100000000
22:24:29 <thetallguy> 10000000
22:24:29 <thetallguy> real	0m5.152s
22:24:39 <vixey> is mine 4??
22:24:42 <thetallguy> Yes
22:24:45 <vixey> :D
22:25:06 <thetallguy> There's something screwy going on, though.  Those tests were >10s last time
22:26:20 <vixey> Level1Tech, so are you interested in using Haskell at all or just surveying the lambdascape
22:26:47 <gruelly> I like the term 'lambdascape'
22:26:57 <Level1Tech> you know, I dont get the lambda jokes..
22:27:02 <Level1Tech> lol...
22:27:10 <Level1Tech> do you have aspergers?
22:27:16 <vixey> Level1Tech, I'm a bit sleep deprived you'll have to excuse me
22:27:24 <vixey> Level1Tech, yeah
22:27:24 <Level1Tech> same here....zombie mode
22:27:51 <vixey> Level1Tech, I didn't write that talk though
22:27:56 <Level1Tech> what is the hardest thing that you have to deal with
22:28:09 <vixey> the typechecker :P
22:28:17 <thetallguy> vixey: New code and timings posted
22:28:22 <thetallguy> http://hpaste.org/7764
22:29:10 <sclv> vixeys should be really nice and clean, I think... the asm output was nearly readable for it...
22:29:35 <lament> that guy ought to be banned
22:31:52 <vixey> @pl \ p -> (p [] :)
22:31:52 <lambdabot> (:) . ($ [])
22:31:56 <vixey> darn
22:32:39 <vixey> oh!
22:32:40 <solrize> yuccch!!!!  (chunk4, the fastest of them)
22:32:44 <vixey> my middle line was silly
22:32:45 <vixey> ch' ys 0 k n = k [] : (ch' ys n id n)
22:32:49 <vixey> this is much simpler
22:32:52 <dibblego> where do I get the fps package from?
22:32:59 <thetallguy> vixey: I wondered about that.
22:33:03 <sclv> thetallguy: maybe you should be giving them type signatures to specialize them to int?
22:33:25 <vixey> thetallguy: serves me right for listening to @pl
22:33:27 <thetallguy> dibblego: it's now known as bytestring
22:33:48 <dibblego> thetallguy, thanks
22:34:01 <thetallguy> dibblego: has been for some time.  Now comes with compiler (6.8)
22:34:14 <dmwit> Wow, unfoldr is slow!
22:34:24 <dibblego> thetallguy, I am using 6.8.2 to compile lambdabot and its cabal complains about missing fps
22:34:34 <dmwit> dibblego: You may be using the wrong cabal file.
22:34:36 <sclv> w-wait, is that an n+k pattern I see!??
22:34:37 <thetallguy> dibblego: hmm..
22:34:44 <thetallguy> sclv: yup
22:34:46 <sclv> yipes
22:34:55 <dibblego> thetallguy, I am expecting this attempt to fail; lambdabot is the worst thing to install in the world
22:35:08 <dmwit> dibblego: (Somebody else was recently complaining about that and turned out to be using an old cabal file.)
22:35:15 <thetallguy> dibblego: didn't someone just say it was easy?
22:35:23 <dibblego> thetallguy, they are liars
22:35:46 * vixey just did cabal install it worked immediately for her...
22:35:49 <thetallguy> vixey did
22:35:55 <vixey> honestly
22:35:58 <dibblego> after install bytestring 0.9.1.0 I get fps >=0.7 missing
22:36:17 <vixey> chunk n list = ch' list n id where
22:36:17 <vixey>  ch' [] _ k = k [] : []
22:36:17 <vixey>  ch' ys 0 k = k [] : ch' ys n id
22:36:17 <vixey>  ch' (y:ys) (c+1) k = ch' ys c (k . (y:))
22:36:34 <vixey> (maybe faster if I close over n?, but more importantly can you erase id?)
22:37:08 <dibblego> vixey, sorry, but every time I have tried, I have hit brick walls, like this *new* one
22:37:36 <dibblego> vixey, did you use GHC 6.6 or 6.8?
22:37:49 <vixey> dibblego: what exactly happens with `cabal install lambdabot`, and I am using GHCi, version 6.8.2
22:38:14 <dibblego> when did cabal become an executable?
22:38:38 <vixey> % cabal --version
22:38:38 <vixey> cabal-install version 0.4.3
22:38:38 <vixey> using version 1.3.5 of the Cabal library
22:38:51 <vixey> I guess I renamed it somehow...
22:39:08 <dibblego> $ cabal
22:39:08 <dibblego> -bash: cabal: command not found
22:39:21 <thetallguy> dibblego: well there's your problem...
22:39:33 <dibblego> I install cabal
22:39:54 <dibblego> *installed
22:39:56 <vixey> solrize: yeah I'd stick with chunk1 as a specification I think
22:40:03 <dibblego> $ sudo runhaskell Setup.lhs install
22:40:03 <dibblego> Installing: /usr/local/lib/Cabal-1.2.3.0/ghc-6.8.2
22:40:06 <vixey> I invent cabal :P
22:40:15 <vixey> @keal
22:40:15 <lambdabot> the [nsa] even make light green both ways once
22:40:46 <thetallguy> dibblego: path?
22:40:56 <dibblego> $ sudo runhaskell Setup.lhs install
22:40:57 <dibblego> Installing: /usr/local/lib/Cabal-1.2.3.0/ghc-6.8.2
22:40:57 <dibblego> oops
22:41:02 <dmwit> dibblego: There's a cabal-install package on hackage that you need to get.
22:41:02 <dibblego> $ echo $PATH
22:41:02 <dibblego> /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
22:41:06 <vixey> dibblego: In that case, what happens with `cabal-install install lambdabot` or whichever command it should be?
22:41:09 <dibblego> dmwit, I got it and installed exactly that
22:41:24 <thetallguy> cabal install lambdabot
22:41:25 <dibblego> vixey, there is no command prefixed with "cabal"
22:41:37 <dmwit> huh
22:41:41 <dibblego> $ cabal install lambdabot
22:41:41 <dibblego> -bash: cabal: command not found
22:41:49 <vixey> try
22:41:52 <thetallguy> dibblego, that sudo runhaskell doesn't look like the install of cabal-install
22:41:53 <vixey> cabal-install
22:42:00 <thetallguy> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
22:42:02 <lambdabot> http://tinyurl.com/2sj7lw
22:42:13 <dibblego> er cabal-install is another package, one sec
22:42:15 <thetallguy> cabal-install is the package name, not the command name.
22:42:19 <dibblego> sorry
22:42:48 <thetallguy> the reverse of debian, where apt-get is the command and apt is the package
22:43:54 <thetallguy> vixey: that code is making me cross-eyed, I'll have to look at it in the morning
22:43:56 <dibblego> compiler errors now *sigh*
22:44:09 <vixey> thetallguy, hehe
22:44:30 <thetallguy> dibblego: your environment is out of whack, Ithink.
22:44:34 <dibblego> vixey, did you do cabal-install lambdabot from a fresh GHC 6.8.2? did you install the extra-libs? or any other libs?
22:44:50 <sclv> vixey: closing over n is easy and seems helpful, but I can't see erasing id without going back to onHead...
22:45:01 <dibblego> thetallguy, I am doing this in a VMWare image fully expecting it to fail, so I can try again
22:45:13 <sclv> or I guess you could, by splitting ch' into two versions...
22:45:23 <vixey> dibblego: I just installed lambdabot, and that managed to build the binary
22:45:48 <dibblego> vixey, OK, I'll try again from a fresh 6.8.2 installation, thanks
22:46:35 <vixey> thetallguy:
22:46:36 <vixey> chunk 3 [1,2,3,4,5,6]
22:46:36 <vixey>           ((1:) . (2:) . (3:) . ) `joinWith` chunk 3 [4,5,6]
22:46:36 <vixey>   where joinWith k e = k [] : e
22:47:58 <sclv> http://hpaste.org/7764#a1
22:49:36 <vixey> http://hpaste.org/7764#a2
22:59:32 <dibblego> is cabal-install supposed to download all the dependencies?
22:59:50 <dmwit> I believe so.
23:00:03 <dibblego> cabal: The program happy is required but it could not be found
23:00:38 <dibblego> http://hpaste.org/7765
23:00:39 <TSC> Perhaps it gets library dependencies but not programs?
23:00:41 <dmwit> Mmm, program dependencies may be an exception.
23:00:57 <dibblego> so you suggest I install happy off hackage then?
23:01:09 <dmwit> So, happy, alex, greencard, ...
23:01:11 <dmwit> dibblego: yeah
23:01:24 <dmwit> dibblego: Or try cabal install happy =)
23:01:34 <dibblego> I'll just keep running cabal install lambdabot until it works
23:01:48 <vixey> I think it'll install all dependancies it can
23:01:54 <vixey> but you might have to install some things manually
23:02:06 <dibblego> dmwit, well that worked (then why can't it do it automatically?)
23:02:19 <vixey>  vaguely remember installing happy manually
23:02:23 <dmwit> dibblego: I don't know, maybe file a bug?
23:02:33 <dibblego> oh wait, cabal install lambdabot still looks for happy
23:04:46 <dibblego> well something is working; dunno if I'll get a lambdabot at the end of it though :)
23:15:04 <leimy> Hmmm wrote a prime sieve with lots of sparks and typed channels
23:15:18 <leimy> and my code is junk but I'm impressed with how easy this is.
23:16:12 <dibblego> vixey, you still about? after cabal install lambdabot, how do you configure/run?
23:16:30 <leimy> http://hpaste.org/7766?
23:24:28 <dibblego> > 2 + 2
23:24:29 <lambdabot>  4
23:24:30 <vixey> dibblego: ~/.cabal/bin/lambdabot should open a ghci like thing
23:24:35 <vixey> oh you got it :)
23:24:41 <dibblego> yes!! :)
23:24:47 <lambdabotx>  setResourceLimit: invalid argument (Invalid argument)
23:24:48 <dibblego> well, except 2 + 2 is not answering
23:24:55 <dibblego> oh yay
23:26:21 <vixey> leimy: that's mad
23:26:21 <vixey> is it fast?
23:26:21 <leimy> not particularly :-)
23:26:22 <leimy> but it does go faster if built with -threaded
23:26:22 <leimy> and run with approximately the same number of cores on ghc 6.8.2 :-)
23:26:41 <leimy> it's a good way to stress out sparks :-)
23:28:18 <leimy> now if one could get STM Channels to work in a distributed manner... :-)
23:28:26 <dibblego> > 1 + 1 -- can anyone offer any clues about why this is screwed?
23:28:27 <lambdabotx>  setResourceLimit: invalid argument (Invalid argument)
23:28:28 <lambdabot>  2
23:30:06 <vixey> > 1 + 1
23:30:06 <lambdabotx>  fd:8: hClose: resource vanished (Broken pipe)
23:30:07 <catabot>  0:
23:30:07 <catabot>     Failed to load interface for `L':
23:30:07 <catabot>       Use -v to see a list of the f...
23:30:08 <lambdabot>  2
23:30:37 <vixey> strange ..
23:30:51 <dibblego> vixey, looks like a bug (#2038) against GHC 6.8.2
23:31:03 <vixey> catabot: @cata data Maybe a = Nothing | Just a
23:31:03 <catabot> cataMaybe :: (z -> ((a -> z) -> ((Maybe a) -> z)))
23:31:03 <catabot> cataMaybe a _ (Nothing) = a
23:31:03 <catabot> cataMaybe _ g (Just k) = g k
23:31:18 <vixey> (that's why I was trying lambabot)
23:31:21 <dibblego> nice, who wrote @cata?
23:31:25 <vixey> I did
23:31:32 <dibblego> that looks very handy! :)
23:31:49 <dibblego> @cata data X a b = Y a | Z b
23:31:49 <catabot> cataX :: ((a -> z) -> ((b -> z) -> (((X a) b) -> z)))
23:31:49 <catabot> cataX f _ (Y k) = f k
23:31:49 <catabot> cataX _ g (Z k) = g k
23:31:49 <lambdabotx> Unknown command, try @list
23:31:49 <lambdabot> Unknown command, try @list
23:31:53 <dmwit> vixey: Pretty cool!
23:31:58 <vixey> thanks
23:32:21 <dmwit> vixey: It would be even cooler if it was just slightly smarter about parentheses. =P
23:32:27 <dmwit> vixey: But that's icing.
23:32:39 <dmwit> vixey: Will you be submitting a patch to the \bot repo?
23:32:45 <vixey> dmwit: yes, I think I should do more things symbolicly than stringy
23:33:18 <vixey> dmwit: I don't think so but maybe I was able to make it a bit more advanced
23:33:29 <vixey> (I think there's probably still bugs in it)
23:33:53 <dibblego> > 1 + 1
23:33:53 <catabot>  0:
23:33:53 <catabot>     Failed to load interface for `L':
23:33:53 <catabot>       Use -v to see a list of the f...
23:33:54 <lambdabotx>  setResourceLimit: invalid argument (Invalid argument)
23:33:55 <lambdabot>  2
23:34:42 <dobblego> > 1 + 1
23:34:42 <lambdabotx>  setResourceLimit: invalid argument (Invalid argument)
23:34:43 <lambdabot>  2
23:35:08 <dmwit> Did you think you could fake it out with a different screen name? O_o
23:35:20 <dibblego> it seemed to give a different response for vixey
23:35:36 <dibblego> <vixey> > 1 + 1
23:35:36 <dibblego> <lambdabotx>  fd:8: hClose: resource vanished (Broken pipe)
23:35:42 <dmwit> Huh, so it did.
23:35:46 <vixey> > (+) 1 1
23:35:47 <lambdabotx>  setResourceLimit: invalid argument (Invalid argument)
23:35:48 <lambdabot>  2
23:41:01 <dmwit> dibblego: Are you on a 64-bit machine?
23:41:12 <dibblego> dmwit, no
23:41:19 <dmwit> dibblego: (Anyway, newsham is talking about your problem in -blah.)
