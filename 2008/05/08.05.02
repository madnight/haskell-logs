00:19:24 <xah_lee_> when a parser generates a syntax tree, does this mean it actually create some type of nested paren string, or is the tree in the sense of abstract data structure, as in linked objects?
00:19:31 <vegai> hmm, multifarious's perpublat site seems to be broken
00:19:41 <vegai> e.g. http://mult.ifario.us/p/perpubplat-0-9-you-re-looking-at-it
00:20:35 <allbery_b> xah_lee_ usually the latter, although I have occasionally seen the former (which is really the latter + a serialization step)
00:20:53 <xah_lee_> allbery_b: i see. thanks a lot!
00:50:26 <ski> dolio : still around ?
01:34:48 <asmanian> hi all
01:35:08 <xah_lee_> does anyone know, howcome the spec of xml isn't some type of BNF or machine readible BNF, but instead pages of pages rather lose description?
01:35:16 <asmanian> I'm still new to haskell and trying to write something like filter for a IO-Monadic test function
01:35:35 <xah_lee_> it seems to me, xml in BNF type of lang can be just few lines
01:35:59 <asmanian> ie filterM :: (a -> IO Bool) -> [a] -> IO [a]
01:36:20 <asmanian> I'm a bit lost so I would be thankful for every hint
01:36:47 <int-e> @type filterM
01:36:48 <lambdabot56> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
01:36:52 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
01:37:49 <dancor> @src filterM
01:37:49 <lambdabot> Source not found. Where did you learn to type?
01:37:49 <lambdabot56> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
01:38:22 <dancor> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Monad.html#filterM
01:38:23 <lambdabot> http://tinyurl.com/2c5ecq
01:38:24 <lambdabot56> Title: Haskell Code by HsColour, http://tinyurl.com/2c5ecq
01:38:25 <lambdabot56> Title: Haskell Code by HsColour
01:44:05 <povman> does anyone know of a haskell implementation of DPLL?
01:47:40 <asmanian> thnx
01:57:15 <mib_ijim87ym> Hi!
01:59:37 <mib_ijim87ym> Hello?
01:59:38 <povman> i've implemented it fairly quickly: 128 vars, 272 clauses length 3 solves in about 0.16 seconds
01:59:47 <povman> hi mib_ijim87ym
01:59:58 <mib_ijim87ym> :)
02:00:20 <povman> my problem now is trying to make it work with 273 clauses :p it just doesn't ever complete
02:01:11 <mib_ijim87ym> I don't know if I'm in the right place but I'm really new to haskell and have a little error that's causing me major headaches
02:02:08 <povman> this is the everything haskell channel, including newbies
02:02:34 <povman> my guess is that everyone on here is a newbie compared to someone else
02:02:44 <mib_ijim87ym> Great :)
02:02:59 <johnnowak> that's logically absurd!
02:03:21 <vegai> who is the single person who is not a newbie? ;)
02:03:35 * johnnowak points arbitrarily
02:03:51 <ziman> i guess the someone else needn't be on this channel :)
02:03:56 <vegai> oh, her.
02:04:42 <vegai> except it cannot be a woman, since Simon is a man's name. Sorry ;/
02:05:21 <vegai> mib_ijim87ym: anyway, what's the problem?
02:05:50 <mib_ijim87ym> Shall I pastebin some code and ask the question?
02:06:00 <int-e> lambdabot: @paste
02:06:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:06:25 <int-e> (does anybody know whose bot lambdabot56 is?)
02:07:24 <mib_ijim87ym> I http://hpaste.org/7318#a0
02:07:39 <vegai> 10:06 -!- mopemope [n=mopemope@client.abby.co.jp] has joined #haskell
02:07:48 <vegai> that guy has the same dns at least
02:07:56 <vegai> not here now, though
02:08:08 <Beelsebob> Anyone know where I can get the concurrent package used by Yampa?
02:08:37 <int-e> mib_ijim87ym: how do you justify the  | x /= head(xs) = False   line?
02:08:51 <mib_ijim87ym> woops wrong one
02:09:05 <mib_ijim87ym> That was an earlier one, brb
02:09:14 <povman> vegai: it's only partially ordered
02:09:30 <povman> (newbieness)
02:10:28 <mib_ijim87ym> Ok, this is the latest, not much different actually
02:10:31 <mib_ijim87ym> http://hpaste.org/7319?lines=true#a0
02:10:59 <povman> you put brackets in the wrong place
02:11:20 <mib_ijim87ym> the tail ones?
02:11:22 <povman> (tail xs) is correct
02:11:41 <povman> and (head xs), but there you don't need them at all because of the ==
02:12:32 <mib_ijim87ym> sorry I don't quite follow
02:12:56 <ziman> mib_ijim87ym, it's not a good idea to write C-style function "calls": function(args, ..); in Haskell, you have function application, which is denoted just by whitespace: function arg arg
02:13:22 <int-e> mib_ijim87ym: function application in Haskell is written as  f x, not f(x). Parentheses, if any, go around the whole application.
02:13:26 <ziman> mib_ijim87ym, whereas in C you would write f(g(x), h(y)), in haskell that would be (f (g x) (h y))
02:14:10 <mib_ijim87ym> Thanks, I've just started coding it today so am at a real noob stage
02:14:45 <mib_ijim87ym> and it probably doesn't help that I've only done Java before :o
02:19:22 <mib_ijim87ym> with all specified brackets removed I still get and error at line 5: Syntax error in declaration (unexpected `}', possibly due to bad layout
02:19:46 <quicksilver> mib_ijim87ym: the |s have to line up
02:19:51 <quicksilver> I think.
02:19:58 <quicksilver> and you're missing an =
02:20:02 <quicksilver> (after otherwise)
02:20:31 <quicksilver> I'm not sure if the |s do have to line up actually
02:21:15 <povman> i have a really odd bug
02:21:25 <Beelsebob> @where report
02:21:25 <lambdabot> http://www.haskell.org/onlinereport/
02:21:25 <lambdabot56> http://www.haskell.org/onlinereport/
02:21:26 <lambdabot> Title: The Haskell 98 Language Report
02:21:28 <lambdabot56> Title: The Haskell 98 Language Report
02:21:44 <nipuL> how does one leave the IO monad?
02:21:58 <mib_ijim87ym> hmmmm now I'm getting another error, is it ok to paste error messages or should I pastebin them?
02:22:06 <povman> nipuL: you can't, or you could use unsafePerformIO :)
02:22:16 <nipuL> that doesn't sound safe
02:22:31 <povman> escaping IO isn't safe
02:22:44 <quicksilver> mib_ijim87ym: if it's only one line you can paste it here
02:22:59 <quicksilver> mib_ijim87ym: it may be hard to answer without seeing the code too, in which case hpaste t
02:23:03 <quicksilver> nipuL: you don't have to leave the IO monad
02:23:07 <povman> nipuL: do you like harry potter?
02:23:14 <quicksilver> nipuL: you can run pure code inside it
02:23:26 <Beelsebob> can anyone tell me exactly what the characters that may occur after a -- and still make a line a comment are?
02:23:43 <nipuL> povman: no, anime
02:23:49 <povman> ah :p
02:23:53 <Beelsebob> the report says anything which doesn't make a valid lexeme, which is a PitA to figure out
02:24:07 <mib_ijim87ym> it's a few lines so... http://hpaste.org/7321#a0
02:25:02 <quicksilver> mib_ijim87ym: I imagine you mean "member x (tail xs)"
02:26:03 <quicksilver> mib_ijim87ym: the way you've written it, member has three parameters
02:26:42 <quicksilver> x, tail, and xs
02:42:03 <quicksilver> whereas actually member only takes two parameters
02:42:26 <mib_ijim87ym> oh yup I changed it, I'll post what I had when I get that error
02:42:30 <quicksilver> Beelsebob: just put a space after it?
02:42:30 <quicksilver> Beelsebob: basically it's the 'symbol' charaters you can't put there.
02:42:30 <Beelsebob> quicksilver: no, I need an accurate list -- it's for a syntax highighting scheme
02:42:30 <quicksilver> Beelsebob: anythign which would make it a valid operator.
02:42:45 <quicksilver> Beelsebob: I think you want 'ascSymbol' from the report, then
02:42:45 <mib_ijim87ym> This is what I had when I got the lastest error http://hpaste.org/7322
02:42:45 <mib_ijim87ym> *latest
02:42:45 <Beelsebob> ah, okay
02:42:46 <Beelsebob> quicksilver: no, that can't be right
02:42:48 <quicksilver> mib_ijim87ym: as I said, you want member x (tail xs)
02:42:49 <Beelsebob> that includes |, which starts a haddoc comment
02:42:49 <povman> mib_ijim87ym: because tail xs is a single function call, place it in brackets
02:42:49 <quicksilver> mib_ijim87ym: because member takes two parameters not three.
02:42:49 <quicksilver> Beelsebob: haddock is not haskell.
02:42:49 <mib_ijim87ym> Sorry!
02:42:49 <quicksilver> Beelsebob: unfortunately :(
02:42:51 <Beelsebob> yes, but a haddoc comment is considered by Haskell to be a comment
02:42:51 <mib_ijim87ym> I forgot to change it
02:42:51 <quicksilver> Beelsebob: not by haskell98 it isn't.
02:42:51 <Beelsebob> really?
02:42:51 <mib_ijim87ym> Thanks heaps for your help :)
02:42:52 <Beelsebob> --| is an operator in H98?
02:42:53 <Beelsebob> and not a comment start
02:43:16 <quicksilver> Beelsebob: that's my understanding, yes.
02:43:16 <Beelsebob> hmm, okay then
02:43:16 <Beelsebob> I think I'll make the syntax highlighter ignore that bit of the spec
02:43:16 <quicksilver> hmm
02:43:16 <quicksilver> however, I could be wrong.
02:43:16 <Beelsebob> I would have been seriously surprised if SimonM had overridden part of the spec, just for haddoc
02:43:16 <Beelsebob> instead of using one of the variety of symbols that doesn't start a comment
02:43:17 <Beelsebob> come to think of it, actually, he must have
02:43:17 <Beelsebob> because --^ is deffinately an operator in H98
02:43:17 <Beelsebob> but still used by haddoc
02:43:17 <quicksilver> > let a (---) b = a+b in 1 --- 3
02:43:17 <lambdabot56> Unbalanced parentheses
02:43:17 <lambdabot> Unbalanced parentheses
02:43:17 <quicksilver> erm
02:43:18 <Beelsebob> erm indeed
02:43:18 <quicksilver> how many lambdabots do we need? :)
02:43:18 <povman> is -- ^ used by haddoc?
02:43:18 <maltem> mib_ijim87ym, I would prefer shortening lines 4/5 to something like member x (y:ys) = x == y || member x ys
02:43:19 <Beelsebob> oh course -- haddoc inserts a space doesn't it
02:43:19 <Beelsebob> it's not --|, it's -- |
02:43:19 <Beelsebob> so that listing probably is the one I want
02:43:19 <povman> maltem: member = elem
02:43:21 <Beelsebob> cool thanks quicksilver, sorry for the confusion
02:43:21 <Beelsebob> povman: yes, it's used to indicate that the comment is about the line above, not the line below
02:43:21 <maltem> povman, right, but I guess that's not the point of the exercise
02:43:21 <povman> :)
02:43:21 <ski> lambdabot: > let a --- b = a + b in 1 --- 3
02:43:21 <mib_ijim87ym> Thanks maltem, I'll look at that
02:43:21 <ski> lambdabot: @run let a --- b = a + b in 1 --- 3
02:43:21 <lambdabot>  Parse error at end of input
02:43:21 <quicksilver> Beelsebob: ah, good.
02:43:21 <Beelsebob> so you can do data Jam = Jam Int -- ^ Indicates that you have n pots of Jam
02:43:21 <quicksilver> Beelsebob: I thought I was going mad :)
02:43:21 <ski> lambdabot: @run let (---) a b = a + b in 1 --- 3
02:43:21 <lambdabot> Unbalanced parentheses
02:43:21 <Beelsebob> quicksilver: ditto
02:43:21 <quicksilver> ski: LB's pre-parser breaking it?
02:43:22 <ski> `pre-parser' ?
02:43:22 <Beelsebob> I think probably lambdabot is seeing "let (<comment>"
02:43:22 <ski> *nod*
02:43:22 <Beelsebob> > let (--^) a b = a + b in 1 --^ 3
02:43:22 <lambdabot> Unbalanced parentheses
02:43:22 <lambdabot56> Unbalanced parentheses
02:43:22 <Beelsebob> lambdabot: @run let (^--) a b = a + b in 1 ^-- 3
02:43:22 <lambdabot>  4
02:43:22 <Beelsebob> interesting
02:43:22 <Beelsebob> so it gets the operators right, as long as the symbol doesn't start with --
02:43:25 <mib_ijim87ym> maltem what's the || do?
02:43:25 <maltem> mib, it's a logical OR
02:43:25 <maltem> @src (||)
02:43:25 <lambdabot> True  || _ =  True
02:43:25 <lambdabot> False || x =  x
02:43:25 <lambdabot56> True  || _ =  True
02:43:25 <lambdabot56> False || x =  x
02:43:25 <maltem> huh?
02:43:25 <ski> `||' means : logical (boolean) `or'
02:43:25 <mib_ijim87ym> ahh just the usual OR, I jst got confused not seeing a "True"
02:43:25 <mib_ijim87ym> Cool, thanks, that makes sense now
02:43:25 <maltem> :)
02:43:25 <czShadoW> lambdabot: @src or
02:43:25 <lambdabot> or    =  foldr (||) False
02:43:25 <Beelsebob> @hoogle ZeroVector
02:43:25 <lambdabot> No matches found
02:43:25 <lambdabot56> No matches found
02:43:25 <quicksilver> ski: LB parses the haskell once before handing it off to GHC
02:43:25 <quicksilver> ski: this first stage parse is not perfect.
02:44:48 <Beelsebob> @hoogle newIORef
02:44:49 <lambdabot> Data.IORef.newIORef :: a -> IO (IORef a)
02:44:49 <lambdabot56> Data.IORef.newIORef :: a -> IO (IORef a)
02:59:03 <ski> ok
02:59:04 <quicksilver> shall I kick lambdabot56 ?
02:59:05 --- mode: ChanServ set +o quicksilver
02:59:05 <quicksilver> lambdabot56: part
02:59:05 <quicksilver> lambdabot56: leave
02:59:06 --- kick: lambdabot56 was kicked by quicksilver (quicksilver)
02:59:06 <quicksilver> > 5 + 1
02:59:06 <lambdabot>  6
02:59:06 --- mode: quicksilver set -o quicksilver
02:59:06 <ski> isn't the `@' still required for "directed" commands ?
02:59:06 <ski> lambdabot: arr
02:59:06 <ski> lambdabot: @arr
02:59:06 <lambdabot> Yo ho ho, and a bottle of rum!
02:59:37 <quicksilver> ski: you're probably right, but I probably wasn't an op.
02:59:50 <quicksilver> ski: arguably it ought to respect any channel op but I don't believe it does.
03:00:14 <allbery_b> no, it doesn't know the concept of ops
03:03:28 <therp> commercial academic publishing must die.
03:03:37 <therp> I can not even access paper from the year 1936 for free.
03:13:09 <dcoutts> ndm: fixed the hackage password plain text thing you complained about
03:13:26 <dcoutts> ndm: so now you get the artificial feeling of security :-)
03:13:44 <ndm> dcoutts: yay, now i can sleep easy :)
03:13:44 <lambdabot> ndm: You have 2 new messages. '/msg lambdabot @messages' to read them.
03:13:51 <ndm> @messages
03:13:51 <lambdabot> byorgey said 14h 41m 59s ago: it would be nice if Hoogle 4 stripped explicit foralls off the front of types, so that, e.g. something like @. hoogle type flip mapM_ worked with lambdabot
03:13:51 <lambdabot> gbacon said 14h 40m 29s ago: it would also be nice if Hoogle 4 were able to search for functions with the same type as some expression so, for example, hoogle same-type flip mapM_ would yield forM_
03:13:57 <ndm> @seen malcolmw
03:13:57 <lambdabot> malcolmw is in #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell. I don't know when malcolmw last spoke.
03:14:33 <ndm> @tell byorgey Hoogle 4 already does that
03:14:33 <lambdabot> Consider it noted.
03:14:41 <malcolmw> ndm: pong
03:14:52 <ndm> @tell gbacon would be lovely, but requires a type checker in Hoogle with unification and what-not, so is a bit more difficult
03:14:52 <lambdabot> Consider it noted.
03:15:07 <ndm> malcolmw: what do i pass to cabal to install things in /grp/haskell?
03:15:24 <ndm> its something like --installpath=/grp/haskell - but i can't remember if we need to pass more than that
03:15:29 <malcolmw> ndm: dunno.  --prefix==/grp/haskell perhaps?
03:15:41 <malcolmw> ask a cabal expert
03:15:49 <dcoutts> yeah, --prefix=
03:16:10 <dcoutts> ndm: check --help :-)
03:16:40 <ndm> dcoutts:  i'm more asking for what hte path should be so i don't screw up /grp/haskell at york :)
03:17:39 <ndm> hmm, York is still on 6.6, so cabal old, and not supporting configurations :(
03:18:55 <int-e> so install a newer cabal?
03:19:11 <ndm> int-e: my darcs pull has already started :)
03:19:20 <ndm> (see you in a few hours...)
03:20:56 <ndm> is darcs.haskell.org dead?
03:21:08 <ndm> my darcs pull hasn't even figured out if there are new patches or not...
03:22:49 <ndm> its got there now, but snappy it is not!
03:25:33 <byorgey> ndm: awesome =)
03:25:34 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
03:26:56 <ToRA> ndm: outta interest, do you have any feel for how used/busy hoogle is?  reqs/minute kinda thing?
03:27:15 <ndm> ToRA: 100's a day, i think - i can just get some updated stats...
03:30:16 <ndm> 1300 hits per day
03:31:43 <ToRA> is that a lot?
03:32:08 <ndm> about 900 searches per day
03:32:11 <ndm> sounds quite a lot!
03:32:14 <dmwit> It's more than my site gets. =)
03:32:28 <ndm> 400 are looking at the front page
03:32:30 <popcorn> I found a WAM in Haskell
03:32:41 <dmwit> ndm: ...and then leaving? O_o
03:32:42 <ndm> hoogle 4 will have continuously updated stats on this kind of thing
03:32:43 <popcorn> it's partly written in C though :/
03:32:56 <sjanssen> @src init
03:32:56 <lambdabot> init [x]    = []
03:32:56 <lambdabot> init (x:xs) = x : init xs
03:32:56 <lambdabot> init []     = undefined
03:32:58 <ToRA> ah that'd be cool
03:32:59 <sjanssen> hmm
03:33:05 <ndm> dmwit: no idea, i don't track users
03:33:28 <dmwit> popcorn: What's a WAM?
03:33:37 <ndm> warren abstract machine?
03:33:43 <popcorn> yes
03:33:50 <popcorn> wait
03:33:53 <popcorn> I'll get the link
03:34:02 <popcorn> if I can find it again
03:34:02 <dmwit> Google has your back. ;-)
03:34:21 <ndm> and are now sponsoring further Hoogle development...
03:34:56 <popcorn> http://www.cs.mu.oz.au/~gjd/haskellchr/
03:34:59 <lambdabot> Title: HaskellCHR -- a simple CHR implementation for Haskell (GHC)!
03:35:12 <dmwit> So what does Google get out of SoC?  Good PR, and some leads on self-driven college-age developers?
03:36:12 <popcorn> here it is
03:36:20 <ndm> dmwit: and another reason to claim lower levels of evil
03:36:39 <ndm> malcolmw: *** Exception: /grp/haskell/share/doc/Cabal-1.5.1: createDirectory: permission denied (Permission denied)
03:36:43 <ndm> malcolmw: when upgrading cabal
03:37:33 <quicksilver> dmwit: souls.
03:37:51 <dmwit> =O
03:39:37 <malcolmw> ndm: I've made those dirs group-writable now.
03:40:11 <malcolmw> ndm: you might like to do the same for share/alex-2.1.0 and share/haddock-0.8
03:40:40 <ndm> malcolmw: thanks - what command line should i type and where?
03:41:24 <malcolmw> ndm: chmod -R g+w /grp/haskell/share/... on venice
03:46:15 <ndm> malcolmw: its giving me errors about no space left on the device in /grp/haskell....
03:49:38 <popcorn> what would be the way to write CHR programs in HaskellL
03:49:39 <popcorn> ?
03:54:41 <povman> is there something faster than IntMap for holding only a few values (100ish) when doing a lot of modifications on old versions?
03:59:59 <quicksilver> povman: I doubt it.
04:00:16 <povman> bugger
04:00:18 <dmwit> Well, there's HashMap... =/
04:00:35 <dmwit> I don't even know if that's in the libs any more, though.
04:00:41 <povman> dmwit: my keys and values are both Int anyway
04:01:01 <quicksilver> dmwit: the hashtable doesn't give you old versions which povman wants.
04:01:09 <dmwit> oh
04:01:11 <dmwit> quite
04:01:22 <povman> quicksilver: do you mean you actually can't access old versions?
04:01:28 <povman> in a hashtable?
04:01:33 <dmwit> povman: Yeah, it's destructive update.
04:01:53 <povman> that doesn't sound referrentially transparent
04:01:59 <dmwit> Nope, it lives in IO.
04:02:02 <povman> ah
04:03:32 <povman> in the worst case I need to do around 1267650600228229401496703205376 updates on this thing recursively :p
04:18:56 <ndm> mib_20zic9: medium sized programs - 10,000 lines is fine including all libraries
04:19:12 <mib_20zic9> that pretty good
04:19:14 <ndm> mib_20zic9: its just not mature enough for use, there is nothing fundamental stopping it
04:19:32 <mib_20zic9> what happens on large amounts of code?
04:20:05 <mib_20zic9> too slow?
04:21:25 <ndm> yeah, mainly
04:21:44 <mib_20zic9> hmm thats not bad at all
04:22:09 <mib_20zic9> ghc is only about 100000 lines only 10 times more
04:22:27 <ndm> more like 100 times the size, including libraries and all stuff
04:22:36 <ndm> but still not massively more
04:22:53 <ndm> and i have a good idea how to massively improve the speed of supero, so its not all bad
04:23:34 <mib_20zic9> has anyone offered to help?
04:23:41 <mib_20zic9> or is it closed source
04:24:00 <quicksilver> ndm plans to mortgage it and buy google
04:24:03 <quicksilver> then he'll rule the world.
04:24:13 <mib_20zic9> lol
04:24:41 <ndm> its all open source
04:24:54 <ndm> i don't really need help, other than money to buy food while i work on it :)
04:25:03 <mib_20zic9> so can i download it now a fiddle with it :)
04:25:26 <ndm> mib_20zic9: i wouldn't recommend it, while open source, its still incredibly complex to figure out how to run it
04:25:36 <mib_20zic9> oh :(
04:25:53 <ndm> i intend to go back and tackle that at some point
04:26:24 <ndm> for the moment i set parameters by tweaking source code, and it does quirky stuff like sending stuff to my department server to speed up compile times
04:26:40 <ndm> i don't think it would work unless you were running with my private SSH key
04:26:52 <mib_20zic9> lol ok forget it then :)
04:27:07 <ndm> but i do want to release it, and make it vaguely usable in the next few months
04:27:15 <mib_20zic9> what sort of speed increase to get?
04:27:23 <mib_20zic9> sounds good
04:27:47 <ndm> really depends on the program
04:27:51 <ndm> could be up to double
04:27:59 <ndm> in one particular application, i get about 5x faster
04:28:07 <mib_20zic9> thats excellent
04:28:12 <ndm> probably typically ~20%
04:28:28 <mib_20zic9> 20% is still very good
04:28:29 <ndm> but there are plenty more places to improve the optimisation
04:28:55 <mib_20zic9> does it output haskell code?
04:29:54 <ndm> yes
04:29:57 <ndm> that you then recompile with GHC
04:30:46 <mib_20zic9> i wander why something like supero was never come up with before?
04:30:56 <mib_20zic9> haskell has been around for ages
04:31:18 <ndm> supercompilation has been around way before haskell
04:31:20 <ndm> 1970 at least
04:31:33 <ndm> it just requires a lot of thought and effort to get it going
04:32:56 <mib_20zic9> well i have to go but i wish you luck and look forward to updates
04:34:04 <ndm> cool, i will blog about it some point soon
04:34:16 <ndm> so if you are subscribed to that, or planet.haskell.org, you will see
04:35:15 <osfameron> did normal compilation exist before the 70s ?
04:35:28 <osfameron> or are you just saying that the concept was born more or less at the same time?
04:36:30 <ndm> osfameron: i mean supercompilation was invented in the 1970's by Turchin in Russia
04:38:14 <osfameron> ndm: shiny, thanks
04:38:31 <quicksilver> Turchin++ # Shiny
04:38:45 <osfameron> hmmm, ok, I'm just plain wrong.  Compilers were around since 1950s
04:39:41 <geocalc> better to optimze the runtime execution time
05:07:41 <pjd_> Turchin++ indeed
05:12:16 <quicksilver> dons: my word that's an ugly font :P
05:33:23 <xah_lee_> what's a example of non context-free language?
05:33:40 <tromp> a^n b^n c^n
05:33:59 <tromp> is the classical example
05:34:11 <xah_lee_> tromp: umm? ... don't quite unstand that
05:34:29 <xah_lee_> is that exponential in math?
05:34:39 <Syzygy-> xah_lee_: A context-free automaton can not recognize strings on the form aaaabbbbcccc.
05:34:46 <tromp> it means n a's followed by n b's followed by n c's
05:35:06 <sbahra> xah_lee_: Google "context-sensitive languages"
05:35:09 <tromp> for any number n
05:38:11 <Bonus_> a non context free language is C++
05:38:13 <Bonus_> for example
05:38:20 <xah_lee_> are there any actual computer language that's not context free grammar?
05:38:39 <Bonus_> for instance
05:38:44 <Bonus_> AA BB(CC); in c++
05:38:56 <Bonus_> can be either an object definition or a function declaration
05:38:56 <xah_lee_> Bonus_: you kidding me right?
05:39:00 <Bonus_> depends on the context
05:39:02 <Bonus_> er i hope not
05:39:44 <Bonus_> read here: http://yosefk.com/c++fqa/defective.html#defect-2
05:39:45 <lambdabot> Title: C++ FQA Lite: Defective C++
05:40:34 <xah_lee_> Bonus_: interesting link... i'll have to read for a while.
05:40:53 <ziman> say, `a * b' might mean `a times b' or `b is a pointer to a'
05:41:11 <ziman> both are valid statements
05:41:13 <ziman> in C++
05:41:35 <quicksilver> C++ syntax is HORRENDOUS.
05:42:03 <Bonus_> i'm of the opinion that C++ in general is horrendous
05:42:06 <Bonus_> but to each his own i guess
05:42:53 <mux> C++ has lived its time
05:43:37 <quicksilver> there are loads of nice things about C++.
05:43:42 <quicksilver> and loads of nasty things.
05:43:42 <johnnowak> i'm quite sure mccarthy took care of this whole syntax thing in 1960
05:43:54 <quicksilver> I've written perfectly pleasant programs in C++.
05:44:05 <quicksilver> (and I've written som ehorrible ones in haskell, for that matter)
05:44:14 <quicksilver> but it's certainly harder to stay pleasant in C++ ;)
05:44:19 <Bonus_> hehe yeah
05:44:26 <Bonus_> it depends how easy the language makes it for you
05:45:11 <xah_lee_> wait a sec folks. the terms context-free/senstive-grammar are about the possible strings that are valid. Not about semantics.
05:45:24 <Bonus_> oh
05:45:29 <Bonus_> then we misunderstood each other i guess
05:45:33 <xah_lee_> so, C++, even perl, are context-free langs.
05:45:43 <xah_lee_> this is standard computer science.
05:46:33 <xah_lee_> not sure who wrote that C++ page but at least on this section he's making a fool of himself
05:47:07 <Bonus_> he may have used the wrong term then, yeah
05:47:11 <Bonus_> but i think his point still stands
05:49:23 <quicksilver> C++ is ambiguous for parsing.
05:49:46 <quicksilver> To create a parse which not only recognises, but also assigns meaning (such as generating an AST) requires context.
05:50:01 <quicksilver> very distant context, in general.
05:50:53 <zeno_> yay 4 unbrickd router
05:51:25 <xah_lee_> quicksilver: yes but _context-free/sensitive-grammar_ is a standarized term in CS, which is about certain properties of the rules that generates the language. _language_, as in what kind of sequence of strings constitute a valid source code.
05:51:39 <quicksilver> I was not disagreeing with you
05:52:01 <quicksilver> However, in practice we like to design our grammars so that the nonterminals correspond to semantic units.
05:52:16 <quicksilver> that is what we cannot do with C++ and remain context-free.
05:52:27 <EvilTerran> such things as fixity declerations in haskell render it context-sensitive
05:52:41 <quicksilver> so you either parse a weaker language, which is context-free, but your non-terminals are generic.
05:52:55 <quicksilver> and don't translate directly to semantic notions.
05:52:56 <EvilTerran> however, i believe you can get quite far in the parsing (stopping before fixity resolution) context-freely
05:53:11 <EvilTerran> layout aside
05:53:32 <quicksilver> so it's not so much that a CFG doesn't exist
05:53:35 <quicksilver> because it does
05:53:40 <quicksilver> it's that the CFG isn't the grammar we want
05:53:45 <quicksilver> because we are choosy :)
05:55:42 <xah_lee_> quicksilver: ok. ...
05:55:57 <luqui> although in formal CS there is still a concept of an ambiguous grammar
05:56:09 <luqui> which C++'s (and Haskell's) is
05:56:17 * xah_lee_ am still wondering if there's a computer language that's so-called context-sensitive grammar
05:56:58 * luqui guesses not, since there is not an efficient context-sensitive parsing algorithm (afaik)
05:57:09 <ndm> luqui: yes there is
05:57:29 <ndm> luqui: its O(n^2.6), but O(n) in practice
05:58:20 <quicksilver> even with genuine context sensitivity there is always a context-free superlanguage you can parse
05:58:23 <quicksilver> (i.e. accept too much)
05:58:40 <quicksilver> and that's what we do anyway, with C++
05:58:40 <luqui> ndm, wikipedia disagrees
05:58:41 <quicksilver> because of the "other kind" of context sensitivity
05:58:47 * quicksilver would back ndm over wikipedia every single time.
05:58:59 <xah_lee_> quicksilver: ndm?
05:59:06 * quicksilver points at ndm
05:59:10 <luqui> lol
05:59:13 <xah_lee_> oh. lol
05:59:24 * ndm thinks he may be wrong actually
05:59:31 * quicksilver loses the bet.
05:59:43 <ndm> i think i might have been thinking context free but not LALR (or any other restricted class)
05:59:44 <quicksilver> that's actually rather a good page, the defective C++ one
05:59:51 <xah_lee_> quicksilver: is there a CS term for what you might call context-free/sensitive over semantics? i.e. perl would be context sensitive.
06:00:02 <xah_lee_> or C++.
06:00:20 <ndm> xah_lee_: perl is not context sensitive, the perl grammar is compuationally complete
06:00:45 <nornagon> quicksilver: the FQA one?
06:00:50 <quicksilver> nornagon: yeah
06:00:51 <nornagon> i think it's a bit bollocks
06:01:00 <quicksilver> do you ? which bit do you think is bollocks?
06:01:07 <nornagon> i didn't read the whole thing
06:01:16 <quicksilver> xah_lee_: I think most people happily mis-use the phrase context sensitive
06:01:21 <quicksilver> and don't worry about it :)
06:01:27 <Bonus_> yeah like me hehe
06:01:32 <nornagon> but the first bit about the lack of compile-time encapsulation is kind of silly
06:01:36 <Bonus_> i just checked the term out on wikipedia and was like woah
06:01:46 <luqui> xah_lee_, context-sensitive just means you can have multiple nonterminals on the left of the ::=
06:01:56 <xah_lee_> ndm: we meant context sensitivity with regards to semantics changing over a unit of source code, based on neighboring source code... someting like that
06:01:58 <nornagon> recompiling objects is surely not a big deal, and if you really care you can just store a pointer internally
06:02:33 <quicksilver> nornagon: yeah, that certainly not the strongest point
06:02:39 <ndm> it was a _very_ long time since i did parsing stuff...
06:02:40 <nornagon> all the complaints are for cases where you're specifically trying to break C++
06:02:43 <luqui> xah_lee_, well every language that doesn't have referential transparency has that :-)
06:02:48 <quicksilver> nornagon: but they do acknowledge that not everyone considers all those points important.
06:02:58 <quicksilver> nornagon: the actually type of Map String String is great :)
06:03:06 <nornagon> yeah
06:03:14 <nornagon> i've been doing some stuff with std::map recently
06:03:18 <nornagon> the error messages are gr8
06:03:21 <luqui> (for an appropriately Haskell-centric definition of "semantics" :-)
06:03:28 <nornagon> but gcc's getting better at folding them up
06:03:50 <nornagon> i mean, it's not really an issue with C++ itself
06:04:20 <quicksilver> xah_lee_: I *think*, and I"m not quite sure I have this right, that what people mean is:
06:04:29 <quicksilver> The natural grammar (the BNF) is not context-free.
06:04:42 <quicksilver> So it may be a context-free language, but that is an unnatural grammar.
06:04:47 <quicksilver> it's the natural grammar we carea bout.
06:05:08 * xah_lee_ got confused
06:05:14 <quicksilver> so when we say Haskell has a context-sensitive grammar, we mean that the grammar in the haskell report is context-sensitive.
06:05:33 <quicksilver> even though there may well also exist a context-free grammar which recognises exactly the right language
06:05:39 <quicksilver> because that's not the one we want.
06:05:54 <quicksilver> similarly, I daresay there is a context-free grammar for perl.
06:06:03 <quicksilver> but assigning semantics to it would be computationally complete.
06:06:11 <quicksilver> (even limited semantics like "bytecode")
06:06:26 <nornagon> you mean there's a context-free grammar that describes a superset of perl, yes?
06:07:04 <quicksilver> no.
06:07:17 <quicksilver> I mean there is a context-free grammar that describes precisely perl.
06:07:23 <quicksilver> I'm not sure if it's true, by the way.
06:07:25 <quicksilver> I'm just guessing.
06:07:33 <EvilTerran> it's not, if you use prototypes
06:07:42 <xah_lee_> Wikipedia: «A formal grammar G = (N, Σ, P, S) is context-sensitive if all rules in P are of the form αAβ → αγβ , where...». Not sure in what context we are using the word “grammar” here...
06:07:56 <quicksilver> in that sense, xah_lee_
06:08:00 <quicksilver> EvilTerran: prove it?
06:08:10 <quicksilver> EvilTerran: I believe that is probably not true.
06:08:21 <quicksilver> I am only guessing, because these things are fiendishly hard to prove
06:08:23 <EvilTerran> BEGIN { *foo = rand > 0.5 ? sub () { } : sub { } }; foo / 2 # /
06:08:29 <quicksilver> (easy to find counter examples)
06:08:35 <EvilTerran> can parse in different ways each time you run it
06:08:37 <quicksilver> EvilTerran: it's trivial to find a CFG that recognises that
06:08:40 <quicksilver> THATS NOT THE POINT
06:08:44 <quicksilver> excsue the caps
06:08:47 <EvilTerran> calm down, dear
06:08:49 <quicksilver> but please listen to the conversation.
06:08:54 <EvilTerran> i just wandered in, sorry
06:09:02 <quicksilver> the point is that the grammer you want to use, the sensible one, is context sensitive.
06:09:13 <quicksilver> because it cares what foo is.
06:09:30 <quicksilver> but that doesn't mean that another simpler grammar doesn't recognise all perl programs a no non-perl programs.
06:09:34 <EvilTerran> ok, what about Lingua::Romana::Perligata?
06:09:46 <quicksilver> well I am only guessing :)
06:09:50 <EvilTerran> you can completely change the parsing of a file with a use statement or a BEGIN block
06:10:03 <quicksilver> no. You can completely change the semantics.
06:10:08 <EvilTerran> the parsing as well
06:10:08 <quicksilver> which is the way perl parses it.
06:10:13 <EvilTerran> http://www.csse.monash.edu.au/~damian/papers/HTML/Perligata.html
06:10:19 <lambdabot> Title: Lingua::Romana::Perligata -- Perl for the XXIimum Century
06:10:22 <quicksilver> it doesn't mean that there doesn't exist a language definition grammar which gets it right.
06:10:31 <quicksilver> Yes, I'm familiar with it and other such code :)
06:10:35 <quicksilver> and I"m certainly not sure.
06:10:38 <EvilTerran> i'm afraid i don't follow
06:10:56 <quicksilver> ok, let's do the C++ example because it's simpler.
06:10:59 <quicksilver> a b(c);
06:11:08 <EvilTerran> if you can replace the perl parser with arbitrary perl code, and perl is turing complete, surely there's no CFG that can parse perl?
06:11:13 <quicksilver> could be a fun declaration, could be an object initialisation.
06:11:27 <quicksilver> to know which, you need to be a C++ compiler.
06:11:30 <quicksilver> you need all the context.
06:11:36 <quicksilver> (you need to know what a and c are, I think)
06:11:53 <EvilTerran> (that is, you can do the replacement from within your perl code)
06:11:53 <quicksilver> the point is a simple grammar can still recognise that.
06:11:58 <quicksilver> it doesn't care which it is.
06:12:15 <quicksilver> if it recognises it, and it doesn't recognise invalid C++ then it's still a grammar which recognises C++.
06:12:28 <quicksilver> it doesn't matter if it gets the semantics wrong.
06:12:35 <quicksilver> because, mathematically, grammars don't have any semantics
06:12:39 <quicksilver> so there is nothing to get wrong
06:12:48 <quicksilver> they just accept a language or reject it.
06:12:59 <EvilTerran> ok, that works for C++. it doesn't work for perl, tho, seeing as you can change the parser completely (if you like, to a language that *cannot* be valid perl, by design) with a BEGIN{} block
06:13:04 <mauke> is BEGIN { die } a syntax error?
06:13:14 <EvilTerran> mauke, well, it's a compile-time error
06:13:20 <quicksilver> I think mauke has the key point here.
06:13:35 <quicksilver> I would argue that is a perl program which happens to die.
06:13:38 <quicksilver> not a syntax error.
06:13:58 <quicksilver> but I think deciding your opinion on that resolves this debate one way or the other.
06:14:01 <mauke> how is that different from foo);,?
06:14:16 <mauke> it's also a perl program that dies
06:14:35 <quicksilver> the difference, I suppose is that in one case perl calls it a syntax error
06:14:38 <byorgey> EvilTerran: so you could write a perl program like this:  BEGIN { weird parsing code here }  ##$//%%%%...35   which would be valid (assuming that gobbledygook is parsed by your parsing code)?
06:14:42 <quicksilver> and in the other case, perl just said 'dies'
06:14:50 <EvilTerran> mauke, because one causes a syntax error, and the other causes a "BEGIN block failed" error
06:14:50 <quicksilver> 'Died' rathr
06:14:52 <EvilTerran> byorgey, exactly
06:15:00 <byorgey> in that case I agree with EvilTerran.
06:15:23 <EvilTerran> i think the only way you could have a CFG that accepted all perl programs would be to have it accept everything, and say that the "parsing" is semantics rather than parsing proper :P
06:15:34 <EvilTerran> "not my job" kinda thing
06:16:13 <EvilTerran> byorgey, the module i linked above is an example of this - it replaces the syntax completely with something derived from latin
06:16:21 <mauke> quicksilver: perl also calls 'sub foo ($); foo;' a parse error
06:16:54 <quicksilver> hmm. so it does.
06:17:05 <EvilTerran> indeed, it'd be pretty straightworward to have a module so you could write "use BF; +++[-etcetc"
06:17:09 <nipuL> how do i use functions like length on an IO [a]?
06:17:26 <quicksilver> nipuL: do { x <- iothing; return (length x) }
06:17:40 <quicksilver> nipuL: basically you use "<-" in a do block to 'run' the IO action and get the result out.
06:17:44 <Bonus_> nipuL: liftM length x
06:17:48 <Bonus_> where x is your IO [a]
06:17:54 <EvilTerran> fmap! (<$>)!
06:17:56 <EvilTerran> (.)!
06:18:01 <quicksilver> EvilTerran, mauke: I think this all comes down to thinking that it's not really even clear what a perl grammar should be :)
06:18:05 <mauke> liftA
06:18:15 <quicksilver> whereas, it is clear what people 'want' the C++ grammar to be.
06:18:19 <quicksilver> so I guess that's the difference.
06:18:37 <Vq^> perl got a grammar?
06:18:44 <quicksilver> well, that's what we're discussing :)
06:18:47 <EvilTerran> quicksilver, indeed. as i just said, you could say "everything's valid perl, what you'd intuitively think of as parsing is a job for the interpreting stage, as it can involve running arbitrary perl"
06:18:55 <mauke> Vq^: yes, a yacc grammar
06:18:58 <edward1> a perl grammar is a full perl interpreter obviously ;)
06:19:09 <Vq^> i thought perl was just awk with shred(1) applied
06:19:12 <EvilTerran> edward1, indeed.
06:19:23 <mauke> Vq^: since when does awk do closures?
06:19:36 <EvilTerran> BEGIN { look ma, running arbitrary code in the middle of the parsing stage } ...
06:20:27 <Vq^> mauke: no idea
06:22:17 <mauke> sub { goto &{$_[0]} }->(sub { goto &{$_[0]} })
06:23:28 <luqui> yum, explicit tail calls
06:24:37 <luqui> sub { $_[0]->($_[0]) }->(sub { $_[0]->($_[0]) })
06:25:29 <mauke> luqui: have you seen http://mauke.ath.cx/stuff/perl/add.pl ? :-)
06:25:58 <luqui> church numerals?
06:26:15 <mauke> no, it uses normal numbers
06:26:19 <mauke> hmm
06:26:23 <mauke> "good" idea!
06:26:55 <mauke> but where do I get bitwise ops for church numerals?
06:28:00 <luqui> this just appears to be silly rather than insane obfuscation
06:28:18 * luqui is a much bigger fan of insanity
06:28:19 <edwardk> mauke convert them to a binary church numeral representation then do bitwise ops
06:29:33 <luqui> mauke, I take that back, it's doing some stuff I don't understand
06:29:48 <mauke> phew
06:30:32 <luqui> on the surface it just looked like a lot of useless closures, but enabling the commented-out print statement revealed otherwise :-)
06:40:32 <Lewk> Is anyone free to give a little advice?
06:40:46 <lilac> don't take candy from strangers
06:40:57 <Lewk> haskell related ;)
06:41:10 <Lewk> but I'll take that too
06:41:11 <Bonus_> don't take monads from strangers
06:41:15 <lilac> f :: Stranger Candy -> Maybe Candy
06:41:17 <lilac> f = Nothing
06:41:33 <Bonus_> haha
06:41:50 <Lewk> rephrase: Is anyone able to help me with a haskell problem?
06:42:01 <mauke> Lewk: not unless you ask a question
06:42:41 <Lewk> Ok first the code ... http://hpaste.org/7324?lines=true#a0
06:42:49 <funktio> lilac: shouldn't that be 'const Nothing'?
06:43:11 <lilac> funktio: yep. i realised one keystroke too late
06:43:50 <Bonus_> hmmm why are you wrapping a list into a stack data type?
06:44:05 <quicksilver> because it's an interesting exercise
06:44:12 <quicksilver> reducing the operations you can do on it
06:44:18 <Bonus_> hmm, ah
06:44:24 <Lewk> That's what we were given
06:44:30 <Bonus_> aha
06:44:41 <mauke> isEmptyStack has the wrong type, though
06:44:42 <quicksilver> Lewk: the type for dfssearch is wronf
06:44:43 <Lewk> Sorry, I should have mentioned it's homework
06:44:59 <quicksilver> Lewk: dfssearch has a type which suggests it works on lists
06:45:01 <quicksilver> but it doesn't
06:45:03 <quicksilver> it works on stacks
06:45:19 <mauke> quicksilver: are you sure?
06:45:33 <quicksilver> well, put it this way.
06:45:34 <mauke> it seems to use stacks internally
06:45:41 <quicksilver> it looks to mee like dfssearch was intended to work on stacks.
06:45:48 <Lewk> But aren't the stacks just lists
06:45:57 <quicksilver> ah maybe not.
06:46:01 <quicksilver> Lewk: yes and no.
06:46:06 <quicksilver> Lewk: yes, they are lists inside.
06:46:09 <quicksilver> but they are no *just* lists
06:46:14 <quicksilver> that's the whole point of the newtype
06:46:14 <lilac> Lewk: ok, so what's the question
06:46:19 <quicksilver> to tell the compiler they are different.
06:46:29 <Lewk> oh
06:46:35 <MyCatVerbs> You can use lists as an efficient way of representing stacks. They're certainly not the *only* efficient way of representing stacks.
06:47:44 <Lewk> So to fix this error http://hpaste.org/7325#a0
06:48:02 <mauke> Lewk: emptyStack is not a function
06:48:06 <mauke> you can't call it
06:48:32 <Lewk> crap :(
06:48:41 <red75> replace quard to isEmptyStack
06:48:49 <red75> *guard
06:49:29 <lilac> ?hoogle (Eq a) => a -> [a] -> Bool
06:49:31 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
06:49:31 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
06:49:31 <lambdabot> Data.List.elem :: Eq a => a -> [a] -> Bool
06:49:38 <Lewk> can I do | isEmpty St st list = list
06:49:43 <Taggnostr> assuming that I don't know haskell and I'd like to translate a single line of code written python, will someone help me?
06:49:45 <Lewk> oh no
06:49:55 <Bonus_> Taggnostr: sure, which line?
06:49:56 <Lewk> that returns a Bool
06:50:01 <Taggnostr> http://dpaste.com/47897/ line 36 :)
06:50:01 <mauke> Taggnostr: depends on how long the line is
06:50:03 <lilac> Lewk: member == Prelude.elem
06:50:26 <Lewk> Sorry, you've lost me with that one
06:50:28 <Bonus_> ah let's see then
06:51:06 <Bonus_> Taggnostr: what does that do , like, generally?
06:51:09 <ziman> why does Data.List redefine many functions from the Prelude?
06:51:16 <mauke> ziman: it doesn't
06:51:17 <quicksilver> it doesn't redefine them.
06:51:19 <quicksilver> it defines them.
06:51:26 <quicksilver> the prelude imports then and then re-exports them.
06:51:31 <ziman> oh
06:51:45 <ziman> i see :) thanks :)
06:51:48 <Bonus_> as for the translation, just a sec :)
06:51:57 <red75> Lewk: dfs' should be dfs' stack list | isEmptyStack stack = list
06:51:59 <Taggnostr> it takes 5 digits of num every time ('73167', '31671', '16717 and so on), multiplies them and create a list of numbers, then it find out the max
06:52:01 <Beelsebob> where does one get the SimpleGfx package from?
06:52:11 <funktio> Taggnostr: is that Project Euler #8?
06:52:15 <Taggnostr> yep
06:52:22 <Beelsebob> or rather, why does it work in ghci, but not in ghc
06:52:41 <quicksilver> Beelsebob: did you forget to compile with --make?
06:52:52 <Bonus_> aha
06:53:05 <Beelsebob> >.<
06:53:06 <funktio> Taggnostr: there are some solutions in the forum
06:53:07 <Beelsebob> thanks quicksilver
06:53:21 <Beelsebob> having a noob day today
06:53:24 <mauke> :t unfoldr
06:53:31 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
06:53:33 <Lewk> Aha! Thanks red75
06:54:01 <Lewk> I haven't quite worked out why but it compiled so I'll go look over it now
06:54:45 <mauke> > unfoldr (\s -> case splitAt 5 s of ("","") -> Nothing; x -> Just x) ['a' .. 'z']
06:54:46 <lambdabot>  ["abcde","fghij","klmno","pqrst","uvwxy","z"]
06:55:15 <Taggnostr> I'd like to see how is it converted in haskell
06:56:02 <Bonus_> you mean like translated literally? or just a haskell program that solves that problem?
06:56:09 <funktio> > filter ((== 5) . length) $ map (take 5) $ tails "12345678987654321"
06:56:13 <lambdabot>  ["12345","23456","34567","45678","56789","67898","78987","89876","98765","87...
06:56:24 <Taggnostr> literally
06:56:32 <mauke> > maximum . map (product . map digitToInt) . unfoldr (\s -> case splitAt 5 s of ("","") -> Nothing; x -> Just x) $ "12345678987654321"
06:56:33 <lambdabot>  24192
06:56:43 <mauke> Taggnostr: like that?
06:56:54 <ziman> > maximum [1..10]
06:56:55 <lambdabot>  10
06:56:57 <Taggnostr> maybe
06:57:01 <int-e> mauke: no, map (take 5) . tails  it is.
06:57:13 <mauke> oh
06:57:23 <Taggnostr> let me play with ghci to see if I understand how it works
06:57:25 <lilac> Taggnostr: here's a literal translation: let num = "123456789" in (foldr1 max) [ foldr (\x y -> (read [x])*y) 1 (take 5 (drop x num)) | x <- [0..length num - 5] ]
06:57:27 <mauke> I see
06:57:53 <mauke> isn't reduce foldl1?
06:58:10 <lilac> mauke: max is associative
06:58:10 <quicksilver> since max is commutative it won't matter, will it?
06:58:14 <quicksilver> and that.
06:58:19 <mauke> eh?
06:58:23 <int-e> foldr1 max === maximum
06:58:25 <mauke> what does that have to do with max?
06:58:45 <mauke> reduce(lambda x,y: int(x)*int(y),num[x:x+5])
06:59:08 <mauke> foldl1 (\x y -> digitToInt x * y) (take 5 (drop x num))
06:59:11 <Taggnostr> reduce takes a function and a sequence and replace the first two number of the sequence with the result
06:59:58 <int-e> mauke: foldl1 won't work for haskell here - because the types of the accumulator and the list elements don't match
07:00:16 <Taggnostr> lambda x,y: int(x)*int(y) is the function that multiplies two numbers, num[x:x+5] is a 5-digit long slice of the number
07:00:17 <mauke> d'oh
07:00:31 <mauke> you're right, of course
07:00:37 <visof> f >>= g , the mean of this : apply f then give the result of f to g as argument ??
07:02:01 <lilac> visof: not quite. it means more like, create a new monadic action by sequencing g after f, with g taking f's result.
07:02:33 <visof> i cam't understand
07:02:34 <funktio> visof: f . g  is normal function composition
07:02:38 <visof> can't*
07:02:46 <funktio> (f . g) x === f (g x)
07:02:56 <visof> yep , i know this
07:03:22 <visof> is >>== equivalent to . ?
07:03:30 <Saizan> no
07:03:31 <visof> composition ?
07:03:42 <visof> what is the difference?
07:03:48 <int-e> @type (.)
07:03:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:03:52 <int-e> @type (>>=)
07:03:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:04:30 <int-e> In the identity monad, >>= is basically function composition (flipped).
07:04:39 <visof> i can't understand monad
07:04:45 <vegai> " apply f then give the result of f to g as argument" is probably correct if you're in the IO monad
07:04:50 <Saizan> int-e: function application you mean?
07:05:03 <int-e> sorry, Saizan is right
07:05:10 <red75> f and g have different types. f is a monadic action, and g is a function which produces monadic action given f's result
07:05:14 <visof> vegai what do you mean?
07:05:34 <vegai> I'm afraid he pretty much understood what >>= meant before he asked us ;/
07:05:40 <visof> red75 what is the mean monadic action ?
07:05:53 <red75> whatever you define it to be
07:06:06 <Saizan> visof: in general m >>= f is like applying f to m, but you've to manage to unwrap/rewrap the monad container
07:07:28 <int-e> visof: in which context have you encountered (>>=)?
07:07:44 <visof> http://en.wikibooks.org/wiki/Haskell/Understanding_monads
07:08:31 <pitseleh> hello
07:08:47 <vegai> by the way, does ghc do any clever magic when it sees an IO monad
07:08:54 <red75> look at the monadic action (m a) as to something which gives the value of type a to right operand of >>=
07:08:58 <pitseleh> i'm having some trouble understanding IO variables
07:09:01 <quicksilver> visof: your intuition about it being like composition is good intuition.
07:09:08 <quicksilver> visof: it is *like* composition.
07:09:13 <quicksilver> it's not the same, though.
07:09:24 <pitseleh> i have a type called track, and when I run a function to input the details of a track i get IO Track back
07:09:32 <quicksilver> because it also arranges for the side-effects to occur in a particular order.
07:09:38 <fourbissime> hi there. I'm trying to generate a sine wave and pipe its floating point binary representation to stdout. up to now, I get a lazy bytestring containing the right thing. but I can't find how to write it down to the stdout ... in Data.ByteString, hPut needs a ByteString rather than a lazy bytestring, or so it seems ...
07:09:50 <pitseleh> then when I want to use it in something that is Track -> Foo, it doesn't work
07:09:53 * pitseleh is stupid
07:09:53 <quicksilver> fourbissime: you need the other hPut :)
07:10:05 * visof is stupid too
07:10:10 <quicksilver> fourbissime: you need to import Data.Bytestring.Lazy's hPut.
07:10:17 <fourbissime> hm okay
07:10:21 <quicksilver> pitseleh: indeed. Use a do block to extract it.
07:10:35 <quicksilver> do { foo <- thingThatGivesIOtrack; }
07:10:47 <quicksilver> pitseleh: then you can call your ordinary Track -> Bar function on foo.
07:11:00 <pitseleh> quicksilver, ah, thank you, that makes sense
07:11:29 <visof> doesn't anyone understand monads so far ?
07:12:00 <fourbissime> quicksilver: nice :) thanks
07:12:24 <dolio> @seen ski
07:12:24 <lambdabot> ski is in #haskell.hr, ##logic and #haskell. I last heard ski speak 4h 15m 42s ago.
07:12:33 <quicksilver> visof: yes, of course.
07:12:37 <quicksilver> visof: everyone understand monads.
07:12:40 <quicksilver> except you.
07:12:42 <quicksilver> :)
07:12:46 <quicksilver> visof: I'm joking.
07:12:48 <visof> oh my God
07:12:49 <int-e> @quote ghc
07:12:49 <lambdabot> ghc says: Splices are not allowed in hs-boot files
07:12:54 <visof> haha
07:13:02 <quicksilver> Most people find monads fairly difficult to start with.
07:13:02 <idnar> @quote understand
07:13:02 <lambdabot> adept says: I think I need cobrain to understand coeffects
07:13:12 <idnar> @quote monad
07:13:12 <quicksilver> Fortunately there are lots of tutorials.
07:13:13 <lambdabot> monochrom says: If you come across "monads are fun!" it's probably Wadler.  If you come across "continuations are fun!" it's probably Appel.
07:13:15 <int-e> quicksilver: right. ask three haskell coders what monads are, and you'll get five different opinions :)
07:13:23 <quicksilver> Heck, there are even tutorials on how to write monad tutorials.
07:13:44 <quicksilver> there is not, yet, a monad-tutorial-writing-tutorial tutorial.
07:13:49 <quicksilver> perhaps you could write the firs.t
07:14:06 <visof> quicksilver how long did you spend to be familiar with Monads?
07:14:06 <idnar> I think you have too many tutorials there
07:14:28 <Bonus_> i'm new to haskell, i finally got what monads are about a week or two ago
07:14:39 <Bonus_> i just read up on a bunch of the tutorials
07:14:45 <Bonus_> and then through osmosis something finally clicked
07:14:49 <dolio> @quote category.of.endofunctors
07:14:49 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
07:15:05 <quicksilver> I was already rather familiar with the notion of pure computation + side effects
07:15:09 <quicksilver> when I learn about monads
07:15:10 <red75> visof: good thing to begin with is to look at impementation and application of monad instances.
07:15:21 <quicksilver> when you come from that approach they really are rather natural.
07:15:41 <quicksilver> I had written lots of ML and cursed the uncontrolled side-effects liberally.
07:15:54 <osfameron> interesting
07:15:55 <fourbissime> ah, silly me. I'm trying to write my lazy bytestring to stdout. but I guess if I don't say "hey, evaluate the damn thing !" anywhere in my program, nothing will happen, right ?
07:15:57 <Bonus_> yeah it's good to start with the IO
07:16:11 <conal> i suggest starting anywhere *but* IO, for understanding monads, to avoid conflating the general notion with the specific.
07:16:12 <osfameron> I've been trying to write non-side-effecty Perl for some time, and don't think that helped me understand monads at all
07:16:21 <Bonus_> hmm
07:16:28 <quicksilver> fourbissime: incorrect.
07:16:30 <Bonus_> but IO without the do notation
07:16:37 <quicksilver> fourbissime: writing a lazy bs to stdout should definitely work.
07:16:42 <int-e> visof: the part that makes monads monads is really just the ability to sequence the various actions (with the next action possibly depending on the previous ones).
07:16:44 <quicksilver> fourbissime: writing lazy things is supposed to force them :)
07:16:58 <saml> what's a good book/tutorial...etc to learn category theory for someone without much math background? I know basic definitions. but i'm not sure how objects and functors can be applied to in programming languages ..etc
07:16:58 <quicksilver> I disagree with conal.
07:17:10 <fourbissime> ok. so I'm messing around somewhere else.
07:17:11 <quicksilver> Or, rather, I think both approaches can be defended.
07:17:23 <quicksilver> Some people like to learn specific first and then extrapolate general.
07:17:31 <quicksilver> some people prefer to learn general and then examine specific.
07:17:39 <quicksilver> Both approaches can work.
07:17:41 <conal> quicksilver: different issue.  i didn't say start general.
07:17:51 <conal> quicksilver: start with a different specific.
07:17:51 <Bonus_> the thing is that the IO monad is pretty simple I think. the only thing that forces you into a monad is that you don't have an IO value constructor
07:17:59 <quicksilver> For an imperative programmer, I would be included to work with simple imperative style IO programs
07:18:06 <int-e> visof: you really need to become familiar with concrete monads to get any use out of them. the state monad is a nice one, the list monad is good as an example for a notion of sequencing that doesn't mean sequential execution.
07:18:06 <Bonus_> so you can just think if you have an IO String and you put it throught >>=, it chops the IO part off
07:18:09 <quicksilver> like do { putStrLn "hello" ; putStrLn "world" }
07:18:12 <quicksilver> and play with the types a bit
07:18:23 <Bonus_> and you can use it on the right side, provided you promise you'll give it back packed up in IO
07:18:29 <quicksilver> saml: I'm not sure there are any such good books.
07:18:30 <red75> quicksilver: i think for "imperative programmer" it's better to look at specifics first.
07:18:36 <int-e> visof: you won't get around the IO monad, but it's really a bad example for understanding monads as such.
07:18:49 <quicksilver> saml: I've not found any particularly enlightening one.
07:19:01 <int-e> visof: (all imho. other people may differ)
07:19:04 <quicksilver> saml: categories for computer science is recommended by some people I know though.
07:19:07 <Bonus_> cehck up on a few of these link imho: http://del.icio.us/Alisic/monads
07:19:08 <lambdabot> Title: Alisic's bookmarks tagged with "monads" on del.icio.us
07:19:45 <quicksilver> erm, s/for/and/
07:19:50 <saml> http://www.amazon.com/Conceptual-Mathematics-First-Introduction-Categories/dp/0521478170  some say this is the easiest
07:19:52 <lambdabot> http://tinyurl.com/2xn93k
07:19:57 <quicksilver> red75: that is my feeling too.
07:20:07 <dolio> saml: That book is pretty easy.
07:20:16 <conal> a problem with the IO monad is that its denotation isn't really comprehensible.  if you start with Maybe and [], you can see exactly what's going on behind the common interface.
07:20:24 <quicksilver> saml: that will tell you nothing about how it is relevant to computer science, I don't think.
07:20:26 <dolio> I've leafed through at a bookstore.
07:20:33 <quicksilver> saml: it's not a bad book, Lawvere is a good author.
07:20:42 <quicksilver> saml: but it's categories for mathematicians, AFAIK.
07:21:03 <dolio> Yeah, I don't think it has applications to computer science. Learning what it does for mathematics might not be a bad way to start, though.
07:21:34 <quicksilver> or it might be. If you learn categories in a totally abstract context you risk falling into the trap of tinking they are nothing but abstract nonsense.
07:21:50 <quicksilver> A phrase I was once castigated for using by a senior CT researcher :P
07:22:08 <dolio> Well, I don't think that book's totally abstract.
07:22:35 <dolio> It gives lots of concrete examples. Just not computer science examples.
07:23:49 * quicksilver nods
07:24:02 <dolio> The one I remember is about determining bills by types of plates at a Chinese restaurant.
07:24:07 <quicksilver> oh really?
07:24:10 <quicksilver> that is quite good.
07:24:19 <dolio> I forget exactly what that was an example of.
07:24:30 <quicksilver> lawvere++ # Category Theory for Chinese Restaurateurs
07:25:04 <fourbissime> quicksilver: oh. when I call Data.Binary.encode sine (sine being a [Float] stream), nothing is printed. it's like encode is waiting for the end of the stream (which is infinite) before spitting anything out
07:25:27 <quicksilver> fourbissime: yes it will.
07:25:30 <dolio> Perhaps commutation of diagrams or something.
07:25:33 <quicksilver> fourbissime: it writes a length byte first.
07:25:38 <quicksilver> length word
07:25:39 <quicksilver> whatever :)
07:26:13 <dolio> Where you could determine the bill via two different methods, but both were supposed to be the same.
07:26:15 <fourbissime> quicksilver: dmanit ! so it is *not* the function I should use to encode my data ...
07:27:02 <quicksilver> fourbissime: you could use Binary for the individual Floats
07:27:06 <quicksilver> just not the whole array.
07:27:46 <fourbissime> but if i encode float by float, will it put the length word before each ?
07:27:53 <cpoucet> re
07:28:04 <Lewk> Does anyone know where I might find some example haskell code for a DFS for graphs?
07:28:05 <quicksilver> no
07:28:14 <quicksilver> fourbissime: the length word is part of the List encoding
07:28:21 <quicksilver> fourbissime: not the float encoding
07:29:30 <fourbissime> good. but then I will get a [ByteString] output, so I should change some stuff to concat all this.
07:30:30 <red75> Lewk: Maybe Data.Graph.Inductive.Query.DFS. Not sure, though.
07:30:35 <Saizan> mapM encode sine?
07:30:53 <mercury^> erm
07:30:57 <quicksilver> I'm sure using Data.Graph.Inductive will make Lewk's homework project much harder than just implementing the algorithm :)
07:31:10 <Lewk> Thanks, I've been trying to do this one bloody question for around 8 hours straight!
07:31:13 <Lewk> :(
07:31:17 <mercury^> what is the difference between (a . b) =<< c and (a $ b =<< c)?
07:31:22 <quicksilver> I also suspect that Lewk will not learn too much from trying to read the DGI source at the current stage of his haskell learning.
07:31:36 <quicksilver> mercury^: the latter means a (b =<< c)
07:31:40 <wjt> @ty \a b c -> (a . b) =<< c
07:31:42 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => (a -> m b) -> (a1 -> a) -> m a1 -> m b
07:31:43 <Lewk> :)
07:31:46 <wjt> @ty \a b c -> (a $ b =<< c)
07:31:48 <lambdabot> forall b a (m :: * -> *) b1. (Monad m) => (m b1 -> b) -> (a -> m b1) -> m a -> b
07:31:54 <quicksilver> mercury^: that is "the function a, applied to the value b =<< c)
07:31:57 <Bonus_> c >>= a . b = c >>= \t -> a (b t)
07:32:01 <red75> well, yes.
07:32:19 <mercury^> oh, nvm
07:34:09 <Lewk> I work something out and begin to think I could really like Haskell, then get stuck for hours on little things and go back to hating it, right now I'm hating on it
07:34:45 <conal> Lewk: then let's get you unstuck!
07:35:55 <Lewk> I'd love to but think I've confused myself and have just been hacking away trying to get anything to compile
07:38:09 <fourbissime> quicksilver: great ! it works ! :)
07:38:29 <red75> So, you, probably, should pay more attention on type system. There's no type specifications in your code, and it seems you trying to use type inference as something granted.
07:39:15 <fourbissime> the only problem is that the sound is continous for 2 sec and after it feels like listening to a streaming on a 56k :D
07:40:58 <Bonus_> hmm
07:41:27 <Bonus_> i've never actually taken up on solving the project euler problems
07:41:30 <Bonus_> mine as well start now
07:42:02 <Bonus_> what's the most memory efficient fibbonaci sequence implementation?
07:42:16 <fourbissime> and also, I see the memory consumption climbing ... seems like realtime synthesis in pure functional code is not for today ;)
07:42:17 <Bonus_> is it fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
07:43:01 <int-e> Bonus_: if you need all fibonacci numbers up to a certain point, that should do fairly well.
07:43:20 <Bonus_> yeah i need
07:43:22 <int-e> Bonus_: if you just need, say, the 10000th fibonacci number, you can do much better.
07:43:22 <Bonus_> Find the sum of all the even-valued terms in the sequence which do not exceed four million.
07:43:28 <Bonus_> and i tried
07:43:40 <Bonus_> filter (<= 4000000) . filter even $ fibs
07:43:44 <Bonus_> but it runs out of memory : ((
07:43:50 <Bonus_> i mean
07:43:59 <Bonus_> sum . filter (<= 4000000) . filter even $ fibs
07:44:37 <int-e> Bonus_: of course. try takeWhile (<= 4000000), exploiting the fact that the fibonacci numbers are increasing
07:44:40 <dolio> takeWhile (<= 4000000)
07:44:45 <Bonus_> ah
07:44:47 <Bonus_> of course
07:44:48 <Bonus_> doh!
07:45:07 <dolio> filter never completes. :)
07:45:10 <Bonus_> yeah lol
07:45:13 <Bonus_> how silly of me
07:46:38 <red75> fourbissime: maybe it's better to put generation in IO monad. it can be more memory efficient. AFAIK
07:50:13 <red75> i mean something like: gen = do { s<-nextSample ; outputSample ; gen }
07:53:41 <sioraiocht> dcoutts_: ping
07:53:46 <dcoutts_> sioraiocht: pong
07:54:03 <fourbissime> red75: To be memory efficient, I would probably need some kind of sample buffer yes ...
07:54:15 <dcoutts_> sioraiocht: good latency there I think :-)
07:54:23 <sioraiocht> teehee
08:09:30 <MyCatVerbs> > fmap (+) 1 2
08:09:33 <lambdabot>   add an instance declaration for (Num (t -> a))
08:09:49 <Deewiant> > fmap (+) (Just 1) (Just 2)
08:09:50 <lambdabot>  Couldn't match expected type `Maybe t1 -> t'
08:10:02 <MyCatVerbs> Whoops, duh.
08:10:06 <MyCatVerbs> > fmap (+1) 1
08:10:06 <lambdabot>   add an instance declaration for (Num (f a))
08:10:24 <Deewiant> > fmap (+) (Just 1) 2
08:10:25 <lambdabot>  Couldn't match expected type `t1 -> t'
08:10:28 <Deewiant> >_<
08:10:31 <Deewiant> @ty fmap (+) (Just 1)
08:10:33 <lambdabot> forall a. (Num a) => Maybe (a -> a)
08:10:38 <Deewiant> duh
08:11:05 <dolio> > fmap (+) (Just 1) `ap` Just 2
08:11:06 <lambdabot>  Just 3
08:11:06 <MyCatVerbs> Deewiant: just wondering, 'cuz \bot seems to be returning types including Functor a => a foo where one would expect to see just foo.
08:11:14 <Deewiant> > ap (fmap (+) (Just 1)) (Just 2)
08:11:15 <lambdabot>  Just 3
08:11:32 <Deewiant> dolio: hey, no rushing. :-P
08:11:54 <Deewiant> MyCatVerbs: like where?
08:11:56 <Deewiant> @ty (.)
08:11:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:12:03 <MyCatVerbs> Deewiant: like that.
08:12:09 <Deewiant> that's Caleskell
08:12:19 <dolio> > succ . Just 1
08:12:21 <lambdabot>  Just 2
08:12:36 <MyCatVerbs> Caleskell? :)
08:12:37 <Deewiant> Cale and probably some others are of the opinion that some things in the Prelude have too specific types
08:12:57 <MyCatVerbs> "06:12:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b" "06:12:16 <Deewiant> it's not, but in Caleskell map == (.) == fmap" <-- ahhh.
08:12:58 <Deewiant> hence (.) and map are both fmap in lambdabot, and (++) is generalized to Monoids (I believe it's mappend?)
08:13:08 <MyCatVerbs> @ty (++)
08:13:10 <lambdabot> forall m. (Monoid m) => m -> m -> m
08:13:13 <Deewiant> @ty mappend
08:13:15 <lambdabot> forall a. (Monoid a) => a -> a -> a
08:13:20 <Deewiant> yeah, probably that.
08:13:46 <MyCatVerbs> @ty concat
08:13:48 <lambdabot> forall a. [[a]] -> [a]
08:14:09 <MyCatVerbs> Looks like \bot's concat isn't defined in terms of \bot's (++).
08:14:16 <Deewiant> @src concat
08:14:17 <lambdabot> concat = foldr (++) []
08:14:20 <Deewiant> @ty foldr (++) []
08:14:22 <lambdabot> forall a. [[a]] -> [a]
08:14:29 <Deewiant> Oh, right.
08:14:32 <Deewiant> @ty foldr (++) mempty
08:14:34 <lambdabot> forall a. (Monoid a) => [a] -> a
08:14:52 <dolio> @type mconcat
08:14:54 <lambdabot> forall a. (Monoid a) => [a] -> a
08:14:58 <MyCatVerbs> > let concat = foldr mappend mempty in getSum (concat . map Sum $ [1.100])
08:14:59 <lambdabot>  1.1
08:15:14 * MyCatVerbs snickers at that typo.
08:15:18 <MyCatVerbs> > let concat = foldr mappend mempty in getSum (concat . map Sum $ [1..100])
08:15:19 <lambdabot>  5050
08:15:26 <MyCatVerbs> Makes sense.
08:15:35 <dolio> That's too specific, too. :)
08:15:36 <Duddle> is it me, or is it kinda hard to generate a random number in haskell? I've found alot of solutions, but either they just generate a list of numbers that is always the same, or it has "IO Int" as output, and I'm too inexperienced to use that
08:15:37 <dolio> @type fold
08:15:39 <lambdabot> Not in scope: `fold'
08:15:44 <dolio> @type Foldable.fold
08:15:45 <lambdabot> Couldn't find qualified module.
08:15:47 <MyCatVerbs> Also, while we're at it, could we get rid of the distinction between MonadPlus m and (Monad m, Monoid m) ? :)
08:15:49 <dolio> @type Data.Foldable.fold
08:15:50 <lambdabot> forall (t :: * -> *) m. (Monoid m, Data.Foldable.Foldable t) => t m -> m
08:15:55 <dolio> That's the right type. :)
08:17:10 <pitseleh> i've got a data type that has an Int within it
08:17:25 <pitseleh> now, when i want to take user input and add it to a list of that data type
08:17:53 <Bonus_> > head [a*b | a <- [999,998..100], b <- [999,998..100], (a*b) == (read . show . reverse $ a*b)::Integer]
08:17:54 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Bool'
08:17:57 <pitseleh> i get IO type errors and i'm confused as to how I can get the input of an int for general purpose use
08:18:05 <Bonus_> > head [a*b | a <- [999,998..100], b <- [999,998..100], (a*b) == ((read . show . reverse $ a*b)::Integer)]
08:18:05 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Integer'
08:18:07 <Bonus_> ugh
08:18:43 <MyCatVerbs> pitseleh: do { line <- getLine; let number = read line; let listofnumbers = [1..100]; print (map (+number) listofnumbers); }
08:18:52 <MyCatVerbs> pitseleh: is that something like what you're after?
08:19:18 <pitseleh> MyCatVerbs, i'll try it now, thanks for the help :)
08:19:30 <Bonus_> > head [a*b | a <- [999,998..100], b <- [999,998..100], (a*b == ((read . reverse . show $ (a*b))::Int)]
08:19:30 <lambdabot> Unbalanced parentheses
08:19:42 <Bonus_> > head [a*b | a <- [999,998..100], b <- [999,998..100], (a*b) == ((read . reverse . show $ (a*b))::Int)]
08:19:43 <lambdabot>  580085
08:19:44 <Bonus_> ok this should work
08:19:46 <Bonus_> anyway
08:19:54 <Bonus_> that's my solution to http://projecteuler.net/index.php?section=problems&id=4
08:19:55 <lambdabot> Title: Problem 4 - Project Euler
08:19:58 <Bonus_> only it says it's wrong :(((
08:20:16 <Bonus_> anyone know what's up with that
08:20:57 <Deewiant> Duddle: well, the 'IO' just means that it won't return the same output each time, which means you can't use it wherever you want like normal functions.
08:21:15 <laz0r> Duddle: i kind of had the same experience, you can only generate random numbers while in IO i think
08:21:47 <Deewiant> Duddle: the solutions that generate lists are the ones you can use wherever you want, but yes, they're the same for a given list (you can change the seed value at compile time).
08:22:05 <pitseleh> MyCatVerbs, that allows the int to be used as useful output
08:22:09 <dolio> Bonus_: That tests all (999*b) first before trying (998*b).
08:22:19 <mapreduce> Bonus_: Yours would stop if 999*100 was a palindrome, but 998*998 might be.
08:22:31 <Bonus_> hmmm
08:22:32 <dolio> Bonus_: You need breadth-first search, or to do maximum instead of head.
08:22:34 <pitseleh> MyCatVerbs, but how might i use it in a type that includes an Int
08:22:36 <Bonus_> aha
08:22:39 <Bonus_> i see
08:23:04 <Duddle> laz0r, Deewiant: thanks ... I will look into generating unique seeds
08:23:07 <pitseleh> MyCatVerb, i'm using it in a type called CommonTrackDetails = (String, Int)
08:23:17 <dolio> Someone apparently uploaded a breadth-first search monad to hackage just recently.
08:23:19 <Bonus_> thanks!
08:23:39 <dolio> @hackage control-monad-omega
08:23:39 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/control-monad-omega
08:23:39 <pitseleh> MyCatVerb, to store an increasing list during the run of a program
08:23:40 <laz0r> Duddle, Deewiant: if i remember correctly, there is a function that not only generates a random number, but also a new random number generator, which then can be used to generate more random numbers, which can be usefull if you want to genrate a sequence of random numbers
08:23:58 <Baughn> Duddle: Or you could read in the seed at runtime and pass it to the otherwise purely functional function. Oh, by the way - IO actions don't just siometimes return different values - they're anything not purely functional, maybe perhaps they affect the environment. putStr, obviously, always returns the same value, but it's still in IO
08:24:26 <dolio> > maximum [a*b | a <- [999,998..100], b <- [999,998..100], (a*b) == ((read . reverse . show $ (a*b))::Int)]
08:24:34 <lambdabot>  Exception: Time limit exceeded
08:24:35 <Baughn> laz0r: There is. Doesn't work too well, IIRC, but it's probably okay for anything not statistical or cryptographic
08:24:36 <Has_newb> Hi, I currently use perl to parse and perform analyses on numbers in a text file and subsequently use gnuplot to output the results to graphs.. Can I use haskell for this?
08:24:43 <Bonus_> cool that worked with the maximum!
08:25:04 <Baughn> @faq Can has_newb use haskell for that?
08:25:04 <lambdabot> The answer is: Yes! Haskell can do that.
08:25:04 <Deewiant> @faq Will Haskell solve Has_newb's problem?
08:25:05 <lambdabot> The answer is: Yes! Haskell can do that.
08:25:18 <MyCatVerbs> pitseleh: you'd need to call the function that uses the int you read in with the int you just read.
08:25:50 <pitseleh> MyCatVerbs, can that function be a constructor?
08:26:03 <Baughn> Has_newb: Though the program might (if it's very small) get longer - Haskell isn't very well designed for effective program compression of the line-noise kind, but that's really a good thing. ;)
08:26:05 <lispy> ?faq Can Haskell create a problem that Haskell can't solve?
08:26:05 <MyCatVerbs> pitseleh: sure, of course.
08:26:05 <lambdabot> The answer is: Yes! Haskell can do that.
08:26:19 <MyCatVerbs> @faq Is Feta cheese delicious?
08:26:20 <lambdabot> The answer is: Yes! Haskell can do that.
08:26:41 <MyCatVerbs> Haskell can do feta cheese! Yaaay!
08:27:22 <Has_newb> At the moment, my programs are getting pretty big and hard to maintain. Hence, I'm considering Haskell but I don't know much about it other than its a functional language
08:28:06 <Baughn> Has_newb: It's probably _the_ most advanced language that is mature enough to be used for such things. (Of course,now I expect people to bite my heads off, but hey)
08:28:27 <lispy> Has_newb: learning Haskell would increase your presective about programming and hopefully make you a better programmer overall.  But, I would say you probably just need to learn what is wrong with maintaining your current program and learn how to fix those problems.
08:28:28 <dcoutts_> Has_newb: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Chart
08:28:32 <Deewiant> Baughn: we're on #haskell so I guess you can say that safely. ;-)
08:28:37 <Baughn> Has_newb: Still, it does have a lot of advanced features. And a several-year learning curve, of course. ;)
08:28:53 <Baughn> Deewiant: No, the "mature" part. THat is sometimes considered an insult.
08:29:20 <Deewiant> shrug
08:29:27 <Has_newb> is that several years until mastery? Or, until "hello world"?
08:29:36 <Baughn> Mastery
08:29:50 <dcoutts_> main = print "hello world"
08:30:06 <dcoutts_> Has_newb: the other bit is easy :-)
08:30:08 <Baughn> It's not like any other language you'll have used, so you've got a lot of work to do. Of course you'll be a better programmer for it, so go right ahead and start. :)
08:30:39 <Has_newb> Thanks for the nfo
08:30:53 <Baughn> @type interact
08:30:55 <lambdabot> (String -> String) -> IO ()
08:31:00 <sclv_> parsing and numeric transforms are actually two haskell strong points, btw, so your task is an easy one to get up and running with.
08:31:10 <Deewiant> main = interact id -- oh look, we just wrote 'cat'
08:31:31 <Baughn> Deewiant: No we didn't. You're missing the /meaning of the name/. :P
08:31:35 <Baughn> "concatenate"
08:31:42 <Deewiant> Shh! ;-)
08:32:11 <Baughn> main = interact (unlines . sort . lines) -- Look, we just wrote sort. For real, this time
08:32:29 <Deewiant> main = interact (unlines . nub . lines) -- uniq!
08:32:44 <Botje> main = undefined -- windows!
08:32:50 <Deewiant> xD
08:32:56 <tromp> :-)
08:33:14 <fxr> haskell.org down?
08:34:35 <Baughn> Has_newb: I should add.. Haskell does IO just as well as any other language (er.. kinda sorta, in principle, getting there at least..), but doing it well is kinda.. advanced coding practices. What I'm trying to say is, if your program is mostly I/O, then you can't expect haskell to be a good match for it unless you're /very good/ at haskell, at which point it beats most things for most things
08:38:26 <Has_newb> Hmm.. Are there examples out there for reading comma or tab-delimited text files?
08:38:44 <Baughn> @src words
08:38:44 <lambdabot> words s = case dropWhile isSpace s of
08:38:44 <lambdabot>     "" -> []
08:38:44 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
08:38:59 <Baughn> ..I still say that should be reduced to "splitBy isSpace"
08:39:35 <Baughn> Has_newb: But yeah, that code - appropriately altered - should be about all you get to parse the files. Or you could use parsec, if you want a full-featured parser.
08:40:51 <Has_newb> Thanks!
08:41:06 <sioraiocht> @seen bos
08:41:06 <lambdabot> I saw bos leaving #ghc and #haskell 7m 47s ago, and .
08:41:13 <Baughn> Has_newb: I would suggest parametrizing it on the isSpace equivalent. Why the standard libs don't, I'll never know.
08:41:16 <sioraiocht> @seen tibbe
08:41:16 <lambdabot> I saw tibbe leaving #haskell-soc, #darcs, #xmonad, #ghc and #haskell 9d 4h 13m 28s ago, and .
08:42:15 <sclv_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/csv-0.1.1
08:42:17 <lambdabot> http://tinyurl.com/2yw6hp
08:42:26 <Has_newb> Is lambdabot written in Haskell?
08:42:29 * sclv_ opposes wheel reinventing
08:42:33 <vixey> ?where lambdabot
08:42:33 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
08:42:40 <vixey> yes, there is the code ^
08:42:45 <Baughn> @version
08:42:45 <lambdabot> lambdabot 4p629, GHC 6.8.2 (Linux i686 2.40GHz)
08:42:45 <lambdabot> darcs get http://code.haskell.org/lambdabot
08:46:48 <mercury^> Hmm, still having some problems with the monadic combinators: I have a function f :: m a -> m a and two functions g, h :: a -> m a. I want to bind g and h a number of times in sequence, with f applied "in between".
08:47:16 <vixey> like what
08:47:22 <red75> :( cannot get good looking parsec expression for T ::= NUMBER | ('-' | NUMBER '*')? 'x' ('^' PNUMBER)?
08:47:23 <sclv_> @hoogle (>=>)
08:47:24 <lambdabot> Control.Monad.(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
08:47:24 <mercury^> When I write (f . g) <=< (f . h) it has some weird effect
08:47:25 <vixey> g . f . h
08:47:48 <int-e> mercury^: re: your program for euler problem 189 - you have a genuine bug in your glue function
08:47:56 <mercury^> yeah, I fixed that
08:47:59 <mercury^> :)
08:48:06 <mercury^> was too tired yesterday I guess
08:48:16 <quicksilver> mercury^: are you sure f :: m a -> m a
08:48:20 <Cale> mercury^: Do you have a starting computation or value?
08:48:20 <mercury^> yes
08:48:24 <quicksilver> mercury^: that's a rather unusual type.
08:48:34 <mercury^> I'll upload the program so you can see
08:48:37 <Cale> quicksilver: It's probably less polymorphic
08:48:51 * quicksilver nods
08:49:04 <quicksilver> mercury^: well you can compose f and g (say) just with a normal .
08:49:06 <quicksilver> f . g
08:49:36 <quicksilver> (f . g) >>= (f . h) >>= (f . g)...
08:49:49 <mercury^> http://rohanlean.de/hidden/189_2.hs
08:49:50 <int-e> :t (>>= ?f . ?g)
08:49:52 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m, ?g::a -> a1, ?f::a1 -> m b) => m a -> m b
08:50:11 <int-e> :t (>>= (?f . ?g))
08:50:13 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m, ?g::a -> a1, ?f::a1 -> m b) => m a -> m b
08:50:47 <int-e> oops. a1 = m c, of course.
08:51:21 <quicksilver> mercury^: (compact . steps) >>= (compact . step) should type check
08:51:24 <quicksilver> mercury^: I think.
08:52:05 <int-e> \x -> (compact . steps) x >>= (compact . step)
08:52:16 <quicksilver> yes, I meant >=> in fact
08:52:22 <int-e> yeah.
08:52:24 <quicksilver> which is the same as what int-e wrote.
08:52:28 <mercury^> but can you explain why it currently behaves so weird?
08:53:31 <mercury^> *Main> length $ runStateT ( step =<< step [Red]) 3
08:53:31 <mercury^> 176
08:53:31 <mercury^> *Main> length $ runStateT (compact $ step =<< step [Red]) 3
08:53:31 <mercury^> 27
08:54:46 <quicksilver> is StateT [] a monad?
08:55:02 <quicksilver> @unmtl StateT Integer [] a
08:55:02 <lambdabot> Integer -> [(a, Integer)]
08:55:10 <quicksilver> looks like one to me.
08:55:38 <byorgey> are there any monads m for which StateT s m is not a monad?
08:56:44 <quicksilver> I don't think it's an obvious theorem that they must be
08:56:57 <quicksilver> I think you prove it case by case.
08:56:59 <Cale> Huh?
08:57:04 <Cale> No, there's a theorem.
08:57:19 <quicksilver> Cale: for StateT? cool.
08:57:22 <quicksilver> Cale: is it obvious?
08:57:25 <Cale> In fact, I'm pretty sure it's a relatively easy exercise.
08:58:15 <quicksilver> I thought it wasn't obvious because StateT is a strange transform
08:58:17 <Cale> You just check each of the monad laws, using the fact that m is a monad and the definitions of bind and return for StateT
08:58:40 <Cale> Oh, it doesn't follow from something like the existence of a distributive law, but it should still be pretty direct.
08:58:55 <quicksilver> maybe that's what I'm thinking of
09:00:01 <byorgey> I had always assumed that all the monad transformers in the mtl produce monads from monads.
09:00:07 <mercury^> When I substitute it with compact . (lift . fill =<< ) . compact . lift . mirror, length $ runStateT ( step =<< step [Red]) 3
09:00:11 <mercury^> gives 115
09:00:13 <byorgey> maybe that's an incorrect assumption. =)
09:00:47 <Cale> byorgey: It's just ListT which is broken.
09:02:20 <agcorona> I finally extract the minimal code needed to force a strict evaluation of all the members in a list: http://hpaste.org/7326
09:02:45 <agcorona> maybe this is interesting for someone
09:03:56 <int-e> mercury^: step =<< step [Red]  runs compact once for each element of step [Red] -- with compact $ step =<< step [Red]  you compact the whole result list.
09:03:59 <agcorona> i extracted it from Control.Parallel.Strategies
09:04:59 <mercury^> ah, compact is run before the concatenation?
09:07:19 <int-e> mercury^: btw I don't understand why you work with that StateT instead of a plain [([Colour],Integer)]
09:07:54 <mercury^> I thought it would simplify things :S
09:08:06 <mercury^> and now I want to stick with it to learn something
09:09:36 <int-e> Also, groupAll begs for an Ord instance of Colour, so you can use groupBy ... . sortBy ...
09:11:24 <tromp> wldnt that imply a rather arbitrary ordering of Colours?
09:11:50 <mercury^> doesn't matter
09:12:15 <dcoutts_> Igloo, kolmodin: as distro package people you may like to review http://haskell.org/haskellwiki/Packaging
09:14:01 <Igloo> Hmm, haskell.org doesn't want to talk to me
09:15:21 <quicksilver> tromp: arbitrary orderings are very useful.
09:15:42 <quicksilver> tromp: you get all kinds of good complexity operatons and data structures, given an arbitrary ordering
09:16:34 * Igloo restarts apache and all magically works again. Hmm.
09:18:31 <tromp> maybe alphabetically by name is least arbitrary...
09:19:24 <mercury^> for a datatype with n elements, Z_n is quite nice
09:19:55 <dcoutts_> Igloo: we've had that a lot recently, some client hogging connections and holding them open preventing other clients connecting
09:20:29 <dcoutts_> Igloo: I'd like to configure apache to limit the number of simultanious connections from the same ip and then re-enable keep-alive / persistent connections
09:21:19 <dcoutts_> though if we enable keep-alive we may also want to increase the max number of connections
09:21:26 <Igloo> dcoutts_: For Debian, I don't think we'll keep haddock 0.9 around once we move to haddock 2
09:21:59 <Igloo> And note that you need haddock 2 if you want to know what hackage will do to your docs
09:22:04 <dcoutts_> Igloo: sure, once we move but if you look at the current situation, lots of packages don't work with haddock 2
09:22:25 <dcoutts_> Igloo: hackage doesn't use haddock 2 yet
09:22:31 <Igloo> Are you sure?
09:22:33 <dcoutts_> afaik
09:23:09 <Igloo> According to http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=464364 it is
09:23:11 <lambdabot> Title: #464364 - New upstream version available - Debian Bug report logs
09:23:42 <dcoutts_> hmm
09:23:47 <dcoutts_> gwern: do you know?
09:23:54 <Igloo> How can I find out for sure?
09:24:12 <dcoutts_> Igloo: look at one of the binary .haddock files
09:25:10 <dcoutts_> Igloo: or just the html, it says at the bottom
09:25:23 <dcoutts_> but you need to find a recently uploaded one
09:25:29 <dcoutts_> older ones are haddock 0.8 or .9
09:26:14 <dcoutts_> Igloo: ok, it's using haddock 2.1.0
09:26:26 * Igloo can't find a recent one with docs
09:26:39 <dcoutts_> Igloo: see category-extras
09:27:25 <Igloo> OK, right
09:28:02 <dcoutts_> it'd be interesting to know what proportion of packages docs build with the different versions
09:28:14 <dcoutts_> I should be able to use cabal-install to find out...
09:31:00 <Igloo> Unless it breaks the build I expect to upgrade to 2 soonish, anyway
09:32:44 <dcoutts_> Igloo: you mean if you can build all the debial haskell libs using haddock-2.x
09:32:52 <dcoutts_> debial/debian
09:33:52 <Igloo> Yeah
09:36:45 <dcoutts_> I think we upgraded haddock on hackage too soon personally
09:37:42 <dcoutts_> there was pressure from the authors of packages who were running into the limitations of haddock 0.x but I'm sure a greater number of packages break than start to work with the initial change
09:38:38 <dcoutts_> in future we'll be able to test it
09:38:51 <dcoutts_> just test it with the whole archive
09:46:29 <visof> @paste
09:46:29 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:47:14 <mercury^> int-e: I think I have it working as wanted now: http://rohanlean.de/hidden/189_2.hs
09:47:18 <visof> http://hpaste.org/7327
09:47:34 <dcoutts_> bos: did you get a chance to look at http://haskell.org/haskellwiki/Packaging
09:47:46 <visof> i want do simple program to copy what you type and the number of character
09:47:52 <bos> dcoutts_: nope, sorry.
09:48:15 <dcoutts_> bos: no rush, just trying to seek a consensus
09:48:21 <bos> dcoutts_: will look now.
09:49:02 <quicksilver> visof: it's all going quite well until your last putStrLn
09:49:09 <bos> dcoutts_: the haddock 0.9 vs 2.0 thing is a bit sticky.
09:49:10 <quicksilver> visof: then you trail off with an open " string
09:49:16 <dcoutts_> bos: yes
09:49:20 <bos> dcoutts_: we already package only haddock 2.x for fedora.
09:49:23 <dcoutts_> bos: Igloo said that too
09:49:26 <dcoutts_> bos: oh, right
09:49:38 <bos> dcoutts_: so going backwards to haddock 0.9 would be possible, but annoying.
09:49:43 <visof> quicksilver correct it please
09:49:46 <dcoutts_> bos: yes, I see
09:49:59 <dcoutts_> bos: and you've found that things are working with 2.x
09:50:02 <quicksilver> visof: I choose not to.
09:50:03 <bos> particularly given the amount of time i have for such things :-)
09:50:08 <dcoutts_> bos: I masked it on gentoo because too much broke
09:50:10 <quicksilver> visof: I choose to explain your problem and let you try to fix it.
09:50:14 <mercury^> (.text+0x352f): undefined reference to `__stginit_mtlzm1zi1zi0zi0_ControlziMonadziState_'
09:50:17 <mercury^> collect2: ld returned 1 exit status
09:50:17 <bos> dcoutts_: well, if anything's broken, i haven't had time to notice
09:50:34 <int-e> mercury^: compile with ghc --make
09:50:36 <visof> quicksilver okay
09:50:41 <dcoutts_> bos: I wrote that figureing that 0.x was kind of the same software generation as ghc-6.8.2
09:50:44 <int-e> mercury^: or with -package mtl
09:50:57 <dcoutts_> bos: but given your and Igloo's comments I think we'll have to relax that one
09:50:59 <mercury^> ah
09:51:41 <dcoutts_> bos: mind you I wasn't just looking at the other core libs, but more like 150+ other haskell packages in gentoo
09:51:43 <visof> quicksilver i can't understand , what should i do?
09:52:01 <bos> dcoutts_: yeah
09:52:18 <bos> dcoutts_: we package almost no extra libraries for fedora, for want of time
09:52:30 <bos> just gtk2hs and ... maybe that's it, in fact.
09:53:37 <dcoutts_> bos: how well does fedora cope with multiple versions of the same package being installed at once?
09:53:55 <bos> dcoutts_: you have to name them separately.
09:54:16 <dcoutts_> bos: so basically it's a pita then?
09:54:23 <bos> dcoutts_: yes
09:54:27 <dcoutts_> sigh
09:54:34 <bos> dcoutts_: e.g. there's autoconf and autoconf213
09:54:46 <bos> so in the haddock case, there would be haddock and haddock09
09:54:54 <dcoutts_> bos: I dunno how we can manage these kind of transitions better
09:54:57 <bos> assuming i found the time and energy to package 0.9 again
09:55:18 <dcoutts_> bos: though establishing a common baseline between distros probably helps for future transitions
09:55:23 <bos> dcoutts_: regular beatings
09:55:28 <dcoutts_> heh
09:55:42 <quicksilver> visof: you open a strin gwitha " and you don't close it
09:55:47 <quicksilver> visof: do you not see that?
09:55:57 <quicksilver> visof: the syntax highlighting of that pastebin makes it rather clear
09:55:58 <visof> ah
09:57:31 <bos> i love this. 55 new comments on the book since i went to bed at 1am.
09:57:47 <visof> quicksilver i have: foo.hs:4:14: parse error on input `>>='
09:58:30 <quicksilver> visof: I would not recommend explicit use of >> and >>= as a beginner in the IO monad
09:58:36 <quicksilver> I think do notation is much cleaner
09:59:15 <visof> quicksilver do you know what is the problem ?
09:59:39 <quicksilver> I've pasted a do notation translation
09:59:51 <Bonus_> i don't know, using >>= with the IO monad really helped me understand them
10:00:11 <byorgey> visof: that should be \xs ->  instead of  \xs >>=  .  But quicksilver is right, using do notation is probably better for now.
10:00:17 <dcoutts_> heh, XSLT is turning into a typed functional programming language
10:00:21 <dcoutts_> http://www.ibm.com/developerworks/xml/library/x-schemaxslt.html?ca=dgr-btw03x-schemaxslt&S_TACT=105AGX59&S_CMP=GRsitebtw03
10:00:24 <lambdabot> Title: Schema-aware processing with XSLT 2.0, http://tinyurl.com/6mssgc
10:00:40 <visof> okay
10:01:56 <visof> byorgey i change >>= to -> and i have error too
10:02:21 <arnar_> hey folks..
10:02:30 <arnar_> what is the lambdabot command to "prove" equivalence of functions?
10:02:41 <vixey> arnar_: There isn't one
10:02:45 <arnar_> vixey: hmm..
10:02:49 <Saizan>   @check ?
10:02:53 <arnar_> ?help check
10:02:54 <lambdabot> check <expr>
10:02:54 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
10:03:01 <vixey> why did you quote "prove"?
10:03:14 <quicksilver> @check \l m -> m == reverse (reverse (m :: [Int]))
10:03:16 <lambdabot>  OK, passed 500 tests.
10:03:17 <arnar_> vixey: cause I couldn't remember the word "check" :)
10:03:17 <Saizan> because it's more like testing
10:03:23 <arnar_> oh.. ok
10:03:27 <vixey> ok
10:03:40 <vixey> all you can prove with that is functions aren't equal
10:03:50 <quicksilver> I think "prove" in scare quotes is a decent word for what quickcheck does.
10:04:00 <vixey> if it says passed 500 tests you don't really know anything
10:04:48 <quicksilver> that's not true.
10:04:52 <arnar_> ?check \xs ys -> [(x,y) | x <- xs, y <- ys] == \xs ys -> do { x <- xs; y <- ys; return (x,y) }
10:04:53 <lambdabot>      The lambda expression `\ xs ys -> ...' has two arguments,     but its ty...
10:04:59 <quicksilver> you know that it is true for 500 randomly generated lists.
10:05:05 <quicksilver> that's a whole lot more than knowing nothing.
10:05:34 <arnar_> yes.. that was another reason for the quotes. proving is undecidable in the general case
10:05:43 <vixey> > let foo xs ys = xs >>= \x -> ys >>= \y -> return (x,y) in foo "abc" "xyz"
10:05:44 <lambdabot>  [('a','x'),('a','y'),('a','z'),('b','x'),('b','y'),('b','z'),('c','x'),('c',...
10:06:08 <vixey> proving also means you have a proof, not just data
10:06:17 <quicksilver> some proofs involve data.
10:06:22 <quicksilver> there are proofs by model checking.
10:06:55 <arnar_> ?check \xs ys -> [(x,y) | x <- xs, y <- ys] == \xs ys -> do { x <- xs; y <- ys; return (x,y) } :: [a]
10:06:55 <vixey> @undo [(x,y) | x <- xs, y <- ys]
10:06:56 <lambdabot>      The lambda expression `\ xs ys -> ...' has two arguments,     but its ty...
10:06:56 <lambdabot> concatMap (\ x -> concatMap (\ y -> [(x, y)]) ys) xs
10:07:07 <vixey> (>>=) = flip concatMap
10:07:11 <vixey> return = (:[])
10:07:16 <vixey> @redo concatMap (\ x -> concatMap (\ y -> [(x, y)]) ys) xs
10:07:16 <lambdabot> concatMap (\ x -> concatMap (\ y -> [(x, y)]) ys) xs
10:07:21 <vixey> :/
10:07:41 <vixey> @redo (=<<) (\ x -> (=<<) (\ y -> return (x, y)) ys) xs
10:07:41 <lambdabot> (=<<) (\ x -> (=<<) (\ y -> return (x, y)) ys) xs
10:07:53 <vixey> how do you use redo?
10:08:19 <arnar_> ?check \xs::[a] ys::[a] -> [(x,y) | x <- xs, y <- ys] == \xs::[a] ys::[a] -> do { x <- xs; y <- ys; return (x,y) } :: [a]
10:08:20 <lambdabot>  Parse error at "::[a]" (column 4)
10:08:40 <dolio> @redo m >>= \a -> n >>= \b -> return (f a b)
10:08:41 <lambdabot> do { a <- m; b <- n; return (f a b)}
10:08:49 <arnar_> ?check \(xs::[a]) (ys::[a]) -> [(x,y) | x <- xs, y <- ys] == \(xs::[a]) (ys::[a]) -> do { x <- xs; y <- ys; return (x,y) } :: [a]
10:08:49 <lambdabot>  Parse error in pattern at "(ys::..." (column 12)
10:09:00 <arnar_> nm then..
10:09:35 <visof> choose :: [a] -> a
10:09:36 <visof> choose xs = ...
10:09:42 <visof> is this right function ?
10:09:57 <arnar_> vixey: right for what?
10:12:28 <lispy> implementing the axiom of choice?
10:12:54 <vixey> choose = id
10:12:59 <vixey> use it in the list monad
10:13:37 <vixey> > let choose = id in head (do x <- choose [1,2,3] ; y <- choose [1,2,3] ; guard (x * y == 6) ; return (x,y))
10:13:38 <lambdabot>  (2,3)
10:16:06 <Arnar_> > do { x <- id [1,2,3] ; y <- id [1,2,3] ; return (x,y) }
10:16:08 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
10:16:32 <Arnar_> do { x <- [1,2,3] ; y <- [1,2,3] ; return (x,y) }
10:16:35 <Arnar_> > do { x <- [1,2,3] ; y <- [1,2,3] ; return (x,y) }
10:16:37 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
10:17:57 <Arnar_> > [1,2,3] >>= \x -> [1,2,3] >>= \y -> [(x,y)]
10:17:58 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
10:18:27 <Arnar_> lesson learned: don't start with the list monad when explaining monads
10:19:17 <Arnar_> :t guard
10:19:23 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
10:27:49 <psnively> Testing.
10:28:07 <vixey> test failed.
10:29:29 <Elly> danger! monads!
10:30:00 <red75> @src [] >>=
10:30:01 <lambdabot> Source not found. Are you on drugs?
10:30:17 <gbacon> @src ([]) >>=
10:30:18 <lambdabot> Source not found. Are you on drugs?
10:30:19 <sauxdado> <3 \b
10:30:25 <gbacon> @src >>= ([])
10:30:25 <lambdabot> Source not found.
10:30:39 <gbacon> I can never remember the sequence
10:30:41 <vixey> (>>=) = flip concatMap
10:30:45 <vixey> return = (:[])
10:32:52 <byorgey> @src [] (>>=)
10:32:52 <lambdabot> xs >>= f     = concatMap f xs
10:33:16 <sclv_> whee! my db dsl is looking nice: http://hpaste.org/7168#a1
10:34:01 <elliottt> sclv_: cool!
10:34:08 <sauxdado> whre :D
10:34:16 <sclv_> where is a keyword :-(
10:34:16 <dons> ?yow
10:34:17 <lambdabot> Yow!  And then we could sit on the hoods of cars at stop lights!
10:35:27 <dcoutts_> g'afternoon dons
10:35:51 <byorgey> sclv_: nice!
10:36:28 <dons> heya dcoutts_
10:36:33 <Deewiant> sclv_: I'd prefer something like where' instead of whre, the latter is tricky to pronounce ;-)
10:36:54 <Bonus_> what does a | mean in class declarations?
10:37:20 <sclv_> Deewiant: yeah, I suppose, but then its supposed to be infix so you get `where'` which is ugly.
10:37:47 <dolio> It separates the class parameters from the functional dependencies.
10:38:02 <Bonus_> aha
10:38:03 <Bonus_> for instance
10:38:04 <Bonus_> class (Monad m) => MonadError e m | m -> e where
10:38:17 <sclv_> I guess you'd pronounce whre as whirr, or whur with a southern accent.
10:38:39 <Bonus_> what does that m -> e stand for
10:38:56 <dolio> e is functionally dependent on m.
10:39:01 <sclv_> for each and every m there is only one e.
10:39:10 <Bonus_> aha
10:39:28 <sclv_> it tells the type inferencer that if it knows m, it knows e as well.
10:39:45 <tromp> m implies e
10:39:50 <sclv_> (but, in this case, if it knows e, there could still be many ms)
10:40:40 <tromp> @instances Monad
10:40:41 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
10:41:36 <sclv_> i love how much i can do with this dsl, but it relies on that ridiculous trick i used for generic functional references
10:42:36 <twobitwork> hello
10:42:53 <twobitwork> is someone willing ti explain to me why 'let' is used in the toplevel instead of the normal notation?
10:42:59 <twobitwork> to*
10:43:06 <vixey> it's not
10:43:17 <dcoutts_> twobitwork: do you mean within ghci?
10:43:22 <twobitwork> yes :)
10:43:25 <vixey> wait do you mean in GHCi?
10:43:29 <dons> twobitwork: ghci is inside a do-block
10:43:31 <dcoutts_> twobitwork: within ghci you're not really at the top level
10:43:32 <sclv_> @quote fugue
10:43:32 <lambdabot> monochron says:  "Welcome to #haskell, where your questions are answered in contrapuntal fugues."
10:43:37 <dons> since you're typing in statements sequentially
10:43:49 <dcoutts_> twobitwork: as don says, you're in a do block in the IO monad
10:43:54 <twobitwork> I see
10:43:58 <twobitwork> (I think)
10:44:09 <dons> so the usual haskell ability to write declarations in any order, or mutually recursive falls down -- we have to impose some sequencing.
10:44:19 <dcoutts_> twobitwork: within a do block you say, let foo = bar, not just foo = bar
10:44:25 <dons> then again, hbi allowed top level bindings, but i suspect imposed restrictions
10:44:30 <twobitwork> right... I get it
10:45:03 <twobitwork> ok, yeah, that makes sense :)
10:45:06 <dcoutts_> dons: I bet it really did the same thing as ghci but with different syntax
10:45:20 <dons> maybe.
10:45:25 <dons> i wonder how we could test this.
10:45:38 <dons> you can also define types in hbi
10:45:41 <dcoutts_> oh, ok
10:45:56 <dcoutts_> well, try a module binding group using two functions
10:46:01 <dons> porting the hbi interactive environment to ghc-api would be fun
10:46:12 <twobitwork> I thought you did, e.g., "main = do {x <- 4}" ... I don't remember 'let' being used
10:46:22 <dons>     <topdecl> ;
10:46:22 <dons> 	Any top level declaration except <decl>.
10:46:32 <dons>     { <topdecl>; ... } ;
10:46:33 <dons> 	As previous, but more than one mutually recursive declarations.
10:46:35 <dons> dcoutts_: ^
10:47:23 <Deewiant> do {x <- return 4} is equivalent to do {let x = 4}
10:47:32 <twobitwork> ahh
10:47:48 <twobitwork> it's been a while
10:48:04 <dcoutts_> dons: so it did deal with recursive groups of functions
10:48:16 <Arnar_> anyone here familiar with stm invariants?
10:48:17 <dcoutts_> Deewiant: well, hopefully
10:48:30 <dcoutts_> but the desigaring for let in a do block does not use return
10:48:33 <dcoutts_> it uses... let :-)
10:49:00 <Deewiant> can there be a monad satisfying the laws where those two aren't the same?
10:49:28 <dcoutts_> the difference is that let allows polymorphism
10:49:38 <dcoutts_> <- bindings are always monomorphic
10:50:02 <Deewiant> going from return to let should always be the same, though, assuming the former compiled?
10:50:18 <dcoutts_> yes, if the monad satisfies the laws
10:52:16 <EvilTerran> fail changes things
10:52:35 <EvilTerran> do x:xs <- return ys; ... is different from do let { x:xs = ys }; ...
10:52:53 <Deewiant> well, pattern matching is another thing
10:53:11 <EvilTerran> i'd actually quite like it if the in-less let in do blocks had fail semantics
10:53:28 <EvilTerran> but no.
10:54:01 <EvilTerran> well, insofar as i like fail semantics at all.
11:02:04 <twobitwork> hmm... [4, 4.5] gives [4.0, 4.5] ... I thought haskell wasn't supposed to do any automatic type casting?
11:02:16 <Zao> twobitwork: Lists are homogenous.
11:02:24 <conal> twobitwork: 4 is overloaded
11:02:24 <sauxdado> twobitwork: what's the type of [4, 4.5] ?
11:02:37 <vixey> > 4 == 4.0
11:02:38 <lambdabot>  True
11:02:40 <sclv_> :t 4
11:02:42 <lambdabot> forall t. (Num t) => t
11:02:51 <vixey> these are just symbols which denote (the same) number(s)
11:03:04 <tromp> :t [4, 4.5]
11:03:06 <lambdabot> forall t. (Fractional t) => [t]
11:03:08 <vixey> :t [4, 4.5]
11:03:09 <lambdabot> forall t. (Fractional t) => [t]
11:03:18 <twobitwork> ok... but 4.5 isn't a floating point is it?
11:03:19 <sauxdado> 4 and 4.0 don't denote the same object.
11:03:20 <conal> twobitwork: '4' means 'fromIntegral 4' (but not recursively)
11:03:23 <vixey> > (2*3)gcd(3)
11:03:24 <lambdabot>        add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
11:03:30 <sauxdado> twobitwork: 4.5 is fractionaly.
11:03:31 <Deewiant> :t [4.0, 4.5]
11:03:31 <vixey> > gcd (2*3) (3)
11:03:32 <sauxdado> -y.
11:03:34 <lambdabot>  3
11:03:34 <lambdabot> forall t. (Fractional t) => [t]
11:03:50 <vixey> twobitwork: what's the gcd
11:03:51 <conal> sauxdado: 4 and 4.0 might denote the same object, depending on context.
11:04:14 <tromp> @src gcd
11:04:15 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
11:04:15 <lambdabot> gcd x y = gcd' (abs x) (abs y)
11:04:15 <lambdabot>    where gcd' a 0  =  a
11:04:15 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
11:04:32 <sauxdado> well, in general they don't
11:04:50 <Saizan> :t 4.0
11:04:53 <lambdabot> forall t. (Fractional t) => t
11:04:56 <Botje> anyone got a decent paper about compiling pattern matching?
11:05:02 <Saizan> :t 4
11:05:05 <lambdabot> forall t. (Num t) => t
11:05:12 <vixey> gcd Num Fractional = Fractional
11:05:20 <Deewiant> > map (`approxRational` 0.1) [4, 4.5]
11:05:22 <lambdabot>  [4%1,9%2]
11:05:57 <jamesjb> does anyone know offhand if there's a relatively complete d-bus binding for haskell?
11:06:06 <twobitwork> ok... but are fractionals implemented as floating points? i.e., do I have to worry about rounding errors?
11:06:19 <tromp> > approxRational 3.1415 0.01
11:06:20 <jamesjb> i saw one package that looked like it may not be finished
11:06:20 <Deewiant> @instances Fractional
11:06:20 <byorgey> twobitwork: 4.5 can be any fractional type, which includes floating point as well as rational
11:06:21 <lambdabot>  22%7
11:06:21 <lambdabot> Double, Float
11:06:29 <byorgey> > 4.5 :: Double
11:06:30 <lambdabot>  4.5
11:06:30 <tromp> @src approxRational
11:06:31 <lambdabot> Source not found.
11:06:35 <byorgey> > 4.5 :: Rational
11:06:35 <tromp> > approxRational 3.1415 0.001
11:06:36 <lambdabot>  9%2
11:06:37 <lambdabot>  201%64
11:06:52 <tromp> > approxRational 3.1415 0.0001
11:06:52 <Deewiant> > realToFrac 3.1415 :: Rational
11:06:54 <lambdabot>  311%99
11:06:55 <lambdabot>  7074029114692207%2251799813685248
11:07:01 <byorgey> twobitwork: if you use Rationals (import Data.Ratio), you won't have to worry about rounding error.
11:07:35 <Deewiant> Rationals are also in the Prelude
11:07:41 <tromp> > approxRational 3.1415 0.00001
11:07:42 <twobitwork> ok... so importing that module is all I have to do to get 4.5 to be read as a rational?
11:07:42 <lambdabot>  333%106
11:07:45 <Deewiant> although the functions to deal with them aren't.
11:07:49 <byorgey> twobitwork: right.
11:07:55 <twobitwork> cool
11:08:05 <Deewiant> byorgey: O_o are you sure?
11:08:10 <tromp> > approxRational 3.1415 0.000001
11:08:12 <lambdabot>  2975%947
11:08:16 <Deewiant> Ratio a isn't an instance of Fractional, the type of 4.5
11:08:20 <byorgey> twobitwork: oh, wait, sorry, I misread your question =)
11:08:28 <twobitwork> :)
11:08:30 <vixey> > pi :: Rational
11:08:31 <byorgey> twobitwork: you also have to make sure that 4.5 has the type Rational.
11:08:31 <lambdabot>   add an instance declaration for (Floating Rational)
11:08:31 <lambdabot>     In the expression: ...
11:08:49 <Deewiant> > 4.5 :: Rational
11:08:50 <lambdabot>  9%2
11:08:55 <byorgey> twobitwork: i.e. if it is part of a list which has to have type [Rational], or if it gets passed to a function which takes Rational arguments, etc.
11:09:05 <Gilly> twobitwork: [2,3,4.5] :: [Rational] would work
11:09:24 <twobitwork> ok
11:10:22 <twobitwork> so if I say "f :: [Rational] -> [Rational]" and then "f [2,3,4.5]" 4.5 will be read as a rational
11:10:28 <byorgey> twobitwork: yup.
11:11:32 <byorgey> Deewiant: Ratio a may not be an instance of Fractional, but Rational (= Ratio Integer) is
11:12:01 <vixey> :t undefined :: Ratio Complex
11:12:03 <lambdabot>     `Complex' is not applied to enough type arguments
11:12:03 <lambdabot>     Expected kind `*', but `Complex' has kind `* -> *'
11:12:03 <lambdabot>     In the type `Ratio Complex'
11:12:42 <vixey> :t undefined :: Ratio (Complex Rational)
11:12:44 <lambdabot> Ratio (Complex Rational)
11:12:51 <vixey> types within types within types within types within types :)
11:12:52 <Saizan> Integral a => Fractional (Ratio a)
11:13:04 <Deewiant> byorgey: ah, handy.
11:13:25 <Deewiant> byorgey: wonder why @instances doesn't know about it, though.
11:13:33 <byorgey> hm, no idea
11:13:38 <Deewiant> @instances-importing Data.Ratio Fractional
11:13:39 <lambdabot> Double, Float, Ratio a
11:13:42 <Deewiant> O_o
11:14:07 <Saizan> the instances-* printer elides contexts
11:14:20 <byorgey> hm, that's unfortunate
11:14:43 <byorgey> quite confusing not to have the contexts
11:15:31 <byorgey> @instances-importing Data.Monoid Monoid
11:15:31 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:15:46 <byorgey> for example, that says Maybe a but it's really (Monoid a) => Maybe a
11:16:17 <visof> > choose xs = ... in [1,2,3]
11:16:19 <lambdabot>  Parse error at "=" (column 11)
11:19:42 <vixey> visof: choose = id
11:19:57 <vixey>  choose xs = xs
11:20:01 <visof> ah
11:20:08 <visof> thanks vixey
11:20:23 <vixey> visof: here is an example of using it:
11:20:24 <vixey> > let choose = id in head (do x <- choose [1,2,3] ; y <- choose [1,2,3] ; guard (x * y == 6) ; return (x,y))
11:20:25 <lambdabot>  (2,3)
11:21:49 <visof> vixey file:///media/hda5/visof/visof/Haskell/Monads/monads-in-15-minutes.htm
11:22:01 <vixey> ummmmmmmmmmmmmmmmmm,
11:22:37 <visof> choose :: [a] -> a
11:22:52 <visof> is this right?
11:22:59 <visof> if it id
11:23:03 <visof> should be
11:23:14 <visof> choose : [a] ->[a]
11:23:15 <visof> ??
11:23:31 <vixey> I like choose = id
11:23:40 <vixey> did you see my example?
11:23:45 <vixey> of using choose
11:23:49 <visof> yes
11:24:27 <Deewiant> choose = drop . length
11:25:00 <vixey> > let choose = drop . length in choose [1,2,3]
11:25:01 <lambdabot>  Add a type signature
11:25:18 <visof> drop work for [a] right ?
11:25:22 <Deewiant> @ty drop . length
11:25:24 <lambdabot> forall a a1. [a1] -> [a] -> [a]
11:25:33 <Deewiant> hm
11:25:36 <visof> length [a] is Int
11:25:38 <Deewiant> oh, right
11:25:54 <Deewiant> > let choose = drop =<< length in choose [1,2,3]
11:25:55 <lambdabot>  []
11:26:27 <visof> oh
11:26:35 <visof> what is "=<<" ?
11:26:39 <bos> flip >>=
11:26:45 <visof> i hust start with monads this day
11:26:47 <vixey> (=<<) = concatMap
11:26:50 <visof> just*
11:26:56 <vixey> visof:
11:27:09 <Deewiant> that's the (->) monad
11:27:11 <Arnar_> I recommend the monad chapters from real-world haskell
11:27:15 <vixey> > concat . map (\x -> [x + 1, x - 1]) $ [1,2,3]
11:27:17 <bos> so do i!
11:27:17 <lambdabot>  [2,0,3,1,4,2]
11:27:27 <vixey> > (\x -> [x + 1, x - 1]) =<< [1,2,3]
11:27:28 <lambdabot>  [2,0,3,1,4,2]
11:27:47 <ziman> is (->) a monad?
11:27:51 * visof need to focus
11:27:52 <Deewiant> @instances Monad
11:27:53 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
11:27:56 <Arnar_> visof: if you just started looking at monads.. I'd recommend staying away from the list monad for starters
11:28:13 <vixey> Arnar: I'd recommend list first
11:28:17 <visof> Arnar_ what should i read ?
11:28:20 <vixey> It's so simple
11:28:20 <Deewiant> I'd recommend Maybe first
11:28:24 <Deewiant> but that's just me
11:28:27 <Arnar_> visof: check out real-world haskell (the beta is online)
11:28:28 <visof> oh my God
11:28:36 <Arnar_> visof: book.realworldhaskell.org
11:28:41 <vixey> viso? lol
11:28:43 <Arnar_> I'd begin with Maybe
11:29:00 <visof> i'm confused
11:29:09 <Arnar_> visof: the list monad may be simple.. but it is very confusing and counterintuitive at times
11:29:58 <Vulpyne> Where's the if' that lambdabot has come from?
11:30:05 <Deewiant> @src if'
11:30:06 <lambdabot> Source not found. There are some things that I just don't know.
11:30:07 <Arnar_> sorry.. I meant vixey  and not visof in my last msg
11:30:08 <Vulpyne> Not that it wouldn't be easy to write.
11:30:10 <Deewiant> d'oh
11:30:24 <Deewiant> > if' True 1 0
11:30:25 <lambdabot>   Not in scope: `if''
11:30:28 <Vulpyne> I tried to @pl a thing with if and it came back with if'
11:30:33 <Deewiant> I guess it's @pl's own thang
11:30:39 <Vulpyne> Interesting.
11:30:39 <lilac> > do { x <- [1..10]; y <- [1..10]; if x `mod` y == 0 then return (x,y) else fail "" }
11:30:41 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,3),(4,1),(4,2),(4,4),(5,1),(5,5),(6,1),(6,2),(6,...
11:30:55 <vixey> if' c t e = if c then t else e
11:31:27 <Vulpyne> I know. :) I just wondered.
11:32:03 <lilac> @src guard
11:32:03 <lambdabot> guard True  =  return ()
11:32:03 <lambdabot> guard False =  mzero
11:32:34 <visof> is real world haskell for free ?
11:32:47 <augustss> @src approxRational
11:32:48 <lambdabot> Source not found. stty: unknown mode: doofus
11:32:51 <lilac> @src IO mzero
11:32:52 <lambdabot> mzero       = ioError (userError "mzero")
11:32:55 <Vulpyne> Reading the draft version is free at least.
11:32:56 <Arnar_> augustss: no, but there is a public beta online
11:34:09 <augustss> i know
11:34:28 <Torment> @src when
11:34:28 <lambdabot> when p s = if p then s else return ()
11:34:43 <vixey> @src unless
11:34:43 <lambdabot> unless p s = if p then return () else s
11:35:15 <sm> hpaste announcements seem to be not working
11:35:16 <augustss> @pl \p s -> when (not p) s
11:35:17 <lambdabot> when . not
11:35:43 <vixey> unless
11:35:47 <sclv_> hpaste bot has been down for 20-odd days now.
11:35:49 <Deewiant> unless = flip if' $ return ()
11:35:57 <sm> I have a non-exhaustive pattern error in darcs-monitor.hs, any insight welcome - http://hpaste.org/7328
11:36:04 <Arnar_> augustss: the real thing is available for pre-order, $49.99 on amazon
11:36:24 <sm> hmm, maybe we could get the announce checkbox hidden at hpaste.org
11:36:32 <augustss> Arnar_: that's good, but why are you telling me? :)
11:36:37 <edwardk> arnor: dpo you mean visof?
11:36:49 <edwardk> augustss: probably because you said something right after visof asked =)
11:36:57 <visof> why isn't the whole book available ?
11:37:06 <edwardk> visof: coz its not all written yet =)
11:37:07 <sclv_> where is glgu'
11:37:12 <augustss> visof: because it has not been written yet
11:37:14 <sclv_> erm, glguy's new-hpaste?
11:37:42 <Arnar_> augustss: ah.. sorry, second time I do that -- visof asked if it was free, and next msg down was from you -- just got my lines mixed up
11:37:59 <visof> np
11:38:03 * sm sees, it doesn't handle an empty second argument
11:38:04 <augustss> Arnar_: np
11:38:06 <lilac> sm: you don't handle an empty list as the 2nd arg
11:38:14 <sclv_> drat -- beat me to it.
11:38:15 <sm> thanks!
11:47:58 <quicksilver> conal: did you ever get far enough with hopengl to try offscreen rendering?
11:48:09 <quicksilver> (or anyone else? ;)
11:49:45 <conal> quicksilver: do you mean for reuse?
11:50:02 <quicksilver> conal: I mean rendering to a texture
11:50:09 <conal> quicksilver: yes, i did do that.
11:50:13 <quicksilver> I'm doing it using glCopyTexImage2D
11:50:18 <quicksilver> but people tell me I should be using FBOs
11:50:25 <quicksilver> I can't see an HOpenGL binding to FBOs
11:50:30 * conal looks at code ...
11:50:32 <quicksilver> but I'm not sure if I'm looking in the wrong place
11:50:46 <quicksilver> (it is working with glCopy, btw, it's just supposed to be faster the other way)
11:51:44 <conal> quicksilver: yeah.  i used textureBinding and then rendered.
11:51:59 <quicksilver> ehm?
11:52:02 <quicksilver> that's how you render from a texture
11:52:08 <quicksilver> not how you render *to* a texture...
11:52:20 <conal> quicksilver: oh.  okay.  looking through some old code.
11:52:28 <quicksilver> well depending what you mean by "and then rendered" ;)
11:52:39 <quicksilver> is it publically available? browsing through exampes can be useful.
11:53:03 <conal> quicksilver: i was thinking the same thing.  i think it's on a public repo.  looking ...
11:53:52 <conal> quicksilver: http://darcs.haskell.org/packages/piq/
11:53:53 <lambdabot> Title: Index of /packages/piq
11:54:21 <quicksilver> conal: many thanks.
11:55:25 <conal> quicksilver: it's an unfinished, was-partly-working project.  my goal is to cache infinite-extent, infinite/multi-resolution images, specified functionally.
11:55:56 <conal> my big disappointment was that i couldn't get the textures to be gc'd promptly.
11:57:44 <conal> quicksilver: hence my haskell-cafe note http://www.nabble.com/GC'ing-file-handles-and-other-resources-td16713470.html
11:57:46 <lambdabot> Title: Nabble - Haskell - Haskell-Cafe - GC'ing file handles and other resources, http://tinyurl.com/6jludn
11:58:18 <quicksilver> conal: I noticed your comment in the source file.
11:58:48 <quicksilver> conal: that's not off-screen rendering in the sense I meant, I'm afraid.
11:58:56 <quicksilver> of course, it *is* offscreen, obviously :)
11:59:12 <conal> quicksilver: oh?  please tell me more about what you want to do.
11:59:13 <quicksilver> but it's conal's procedural magic generating pixel values
11:59:17 <quicksilver> which then get sent over to opengl
11:59:29 <quicksilver> I want to use *opengl* to render an opengl scen to a texture
11:59:35 <quicksilver> which then gets mapped into another scene.
11:59:49 <conal> quicksilver: oh, duh.  now i get the difference.
11:59:55 <quicksilver> so offscreen openl to texture to be part of an onscreen opengl
12:00:09 <conal> quicksilver: i'll want to do that also in a functional 3D library i'm working on.
12:00:52 <conal> quicksilver: is your challenge opengl or hopengl?
12:01:03 <quicksilver> conal: hopengl
12:01:21 <quicksilver> http://damien.porquet.free.fr/msi/glexts/GL_EXT_framebuffer_object.txt.html
12:01:23 <lambdabot> Title: GL_EXT_framebuffer_object, http://tinyurl.com/5qhb9c
12:01:26 <quicksilver> describes the extension
12:01:36 <quicksilver> and actually apple have some good practical non-OSX-specific docs on it
12:01:59 <quicksilver> http://developer.apple.com/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_offscreen/chapter_5_section_5.html
12:02:01 <lambdabot> Title: OpenGL Programming Guide for Mac OS X: Rendering to a Framebuffer Object, http://tinyurl.com/ybpdvv
12:02:10 <quicksilver> but what I don't know is if there is a hopengl binding.
12:02:58 <conal> quicksilver: i've seen these FBOs in a hopengl program.
12:03:07 <geezusfreeek> hey conal
12:03:24 <conal> geezusfreeek: hey there!
12:03:30 <geezusfreeek> conal: have you considered making Future a GADT?
12:03:45 <conal> geezusfreeek: i don't think i have.
12:03:53 <geezusfreeek> conal: basically to model some functions, then having a reduce function
12:04:01 <geezusfreeek> i'm doing that right now and it seems to be very nice
12:04:07 <conal> geezusfreeek: cool!  what kind of constructors?
12:04:21 <geezusfreeek> lemme paste the structure i have right now
12:04:23 <quicksilver> conal: if you can remember who or how or where that would be awesome :)
12:04:35 <conal> quicksilver: i'll look around now ...
12:05:18 <gwern> hum. I was trying to find the source to Dazzle to package it up, but dons mentioned at some point it was being used in a commercial package
12:05:18 <lambdabot> gwern: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:05:19 <quicksilver> conal: althuogh my current glCopy approach is workable. So I have something.
12:05:23 <gwern> so much for that
12:05:29 <gwern> @messages
12:05:30 <lambdabot> lispy said 4h 4m 1s ago: I'm unlikely to have time before Wednesday. Also, if fetching the ghc testsuite is any indicator, I won't be able to retrieve the ghc source. My connection is too flaky. You
12:05:30 <lambdabot> can find information about the >1k files either in darcs-devel archive or on the bug tracker. I do remember this has been a real problem in the past.
12:05:30 <lambdabot> lispy said 4h 3m 41s ago: We should also stop depending on mmap. mmap is not a good thing.
12:05:30 <geezusfreeek> conal: http://hpaste.org/7330
12:05:36 <quicksilver> conal: I'll publish what I have some time soon and then you can steal code.
12:05:45 <conal> quicksilver: what drawbacks does the glCopy approach have?
12:05:47 <geezusfreeek> conal: see, it basically is just the functions i need in the instances for Monoid, Functor, etc.
12:05:58 <quicksilver> conal: the people in ##opengl tell me it's slower.
12:06:17 <quicksilver> conal: it's possible they're wrong :)
12:06:39 <quicksilver> conal: it is more compatible, though. I have at least one machine without the GL_EXT_framebuffer_object extension.
12:06:40 <geezusfreeek> and then i have a reduce function that attempts to reduce a future to a time and a value. it actually returns a tuple, the second part being whatever information it can get out of it, and the first part being a new future with some reduction steps applied in case it couldn't be fully reduced yet
12:06:40 <conal> quicksilver: won't you lose automatic caching, since you have an interpretation function?
12:07:06 <jaak> quicksilver: fbos should be blazing fast
12:07:10 <conal> quicksilver: what determines whether a GL extension is present or absent?
12:07:31 <visof> is " Algorithms: a functional programming approach" good for starting ?
12:07:31 <jaak> compared to pbuffer, atleast
12:08:07 <visof> or Graham Hutton book ?
12:08:15 <conal> geezusfreeek: i wonder if you'd run into the same problem as with functionally-implemented improving values.
12:08:27 <edwardk> conal: check: http://www.opengl.org/resources/features/OGLextensions/ and look in the 'how to see if an extension is supported' section
12:08:30 <lambdabot> Title: All About OpenGL Extensions
12:08:48 <astrolabe> visor: Starting haskell?
12:08:53 <geezusfreeek> conal: i have the beginnings of improving values in my implementation
12:09:00 <edwardk> glGetString(GL_EXTENSIONS) basically
12:09:03 <astrolabe> visof: Starting haskell?
12:09:06 <geezusfreeek> conal: or did i misunderstand what you meant?
12:09:06 <conal> edwardk: thx.  what i really meant to ask is why an extension might be present on some machines and absent on others.
12:09:31 <edwardk> conal: vendor support
12:09:34 <visof> astrolabe yes
12:09:47 <conal> geezusfreeek: with improving values, wouldn't the totally-straightforward semantics-as-implementation of futures work fine?
12:09:55 <edwardk> concal: nvidia has some ati has some others, some are standardized by the arb and lots of people support them, etc
12:10:46 <quicksilver> conal: hardware + driver.
12:10:56 <quicksilver> conal: mostly hardware.
12:11:07 <quicksilver> but on linux the driver might not support everything the hardware does
12:11:27 <astrolabe> visof: Probably not the algorithms one.  I can recommend http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
12:11:28 <geezusfreeek> conal: what i'm trying basically is straightforward
12:11:37 <conal> edwardk, quicksilver: okay.  got it.  creative chaos in evolving standards and hardware and drivers semi-independently.
12:11:43 <edwardk> yeah
12:11:45 <geezusfreeek> maybe i should paste my code
12:11:51 <conal> geezusfreeek: please!
12:11:57 <conal> geezusfreeek: i was just about to ask
12:11:58 <quicksilver> jaak: can you explain why fbos would be faster than rendering to a backbuffer and using glCopy?
12:12:08 <quicksilver> jaak: to me naivel it seems similar, both are all on the GPU
12:12:09 <astrolabe> visof: Also, this looks good http://www.haskell.org/haskellwiki/Meta-tutorial
12:12:10 <lambdabot> Title: Meta-tutorial - HaskellWiki
12:12:15 <edwardk> sgi just kinda threw opengl out there, but it wasn't good enough to keep up with the hardware folks, so the driver guys exploited the extension mechanism
12:12:32 <geezusfreeek> okay, it has been annotated with my (for now ugly) code
12:13:00 <edwardk> the problem with opengl is that you have to use extensions for almost everything and you usually have to code a few paths to handle different vendors so its not a lingua franca like it was intended to be
12:13:38 <conal> geezusfreeek: no more STM.
12:13:44 <edwardk> more of a pidgin than a creole
12:13:48 <geezusfreeek> the tuple result of the reduce function also hints at a nice StateT monad to keep the most reduced version of the future available at all times
12:13:51 <geezusfreeek> conal: nope!
12:13:54 <quicksilver> edwardk: in some cases the hardware vendors failed to understand SGI's plan to make it fast, and implemented an incompatible extension instead of doing it the 'opengl' way.
12:13:57 <quicksilver> edwardk: *sihg*
12:14:00 <geezusfreeek> conal: no racing either
12:14:05 <geezusfreeek> conal: or unsafePerformIO
12:14:08 <edwardk> quicksilver: sure, there is a ton of red paint
12:14:22 <dufflebunk> In a FFI, suppose there's a function c_a :: (Ptr CChar) -> IO CInt  and the actual C function modifies the stuff in the char*, should a haskell wrapper function be made that is my_a::(Ptr CChar) -> IO (CChar, CInt)  ?  Without that, I worry that if the CInt isn't actually used, the function will never be called...
12:14:33 <edwardk> quicksilver: its like with CSS on the web. everyone has their own interpretation, but the net result is not much works together
12:15:30 <conal> geezusfreeek: i like those aspects.  can you characterize what reduce means?  i'm assuming Future t a still means (Time t,a).
12:15:54 <conal> geezusfreeek: and that the constructors mean the corresponding operations on semantic futures
12:16:07 <geezusfreeek> conal: essentially
12:16:41 <geezusfreeek> conal: the force function is obvious. reduce is just force, but it also returns a new future which is just a simplified version of the original
12:17:07 <conal> geezusfreeek: simplified as in equivalent for the future?
12:17:14 <geezusfreeek> conal: yes
12:17:22 <geezusfreeek> conal: that is how i am planning to do the "caching"
12:18:09 <conal> geezusfreeek: can you get the reduce work to be reused when the same future is examined more than once?
12:18:24 <conal> geezusfreeek: i.e., separate uses of the same future
12:19:25 <geezusfreeek> conal: there are edge cases, but for the most part i expect that to be pretty easy
12:19:50 <MyCatVerbs> Bollocks! I need to do something like: do { left <- generateFoo right; right <- generateFoo left; } in a State monad.
12:20:00 <geezusfreeek> conal: at the worst i can just get rid of FutCached and just use FutSink instead
12:20:10 <MyCatVerbs> Anyone know how to do that, please? Heeeeelp. :(
12:20:32 <vixey> :t mfix
12:20:33 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
12:20:36 <vixey> I have no idea
12:20:39 <vixey> what about that
12:20:40 <geezusfreeek> conal: but that would force me to use unsafePerformIO, and i was just seeing how long i could go without resorting to that
12:21:29 <geezusfreeek> conal: another nice thing about this representation is it is essential an abstract syntax tree, which might make an optimization pass possible
12:21:30 <conal> geezusfreeek: yes, the hidden unsafePerformIO is what i was getting at.  in general, lazy (caching) functional interfaces rely on assignment wrapped up with an unsafePerformIO (usually figuratively, and in the RTS).
12:21:35 <MyCatVerbs> @src mfix
12:21:35 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:21:41 <MyCatVerbs> @src State mfix
12:21:41 <lambdabot> Source not found. Just try something else.
12:22:09 <vixey> oh right
12:22:11 <geezusfreeek> conal: i plan to start incorporating unsafePerformIO as i find the need
12:22:17 <vixey> @instances MonadFix
12:22:18 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:22:34 <geezusfreeek> conal: like i said, the FutCached constructor might be the first to go
12:22:56 <Deewiant> instance MonadFix (State s) where
12:22:57 <Deewiant>     mfix f = State $ \s -> let (a, s') = runState (f a) s in (a, s')
12:22:57 <conal> geezusfreeek: cool.  please let me know how it goes, especially around caching.
12:23:12 <geezusfreeek> conal: sure
12:23:45 <conal> geezusfreeek: i've been thinking some about a general problem encompassing some of what we're running into.
12:24:03 <conal> geezusfreeek: One way to represent a pure value is via a mutable cell for which the only permitted assignments are with semantically equal values.
12:24:10 <Bonus_> hmmm
12:24:16 <Bonus_> > maximum [1..1000000]
12:24:17 <lambdabot>  1000000
12:24:23 <geezusfreeek> conal: that is a nice way of looking at it
12:24:26 <Bonus_> why does that do a stack overflow
12:24:26 <Bonus_> in ghci
12:24:27 <Bonus_> with me
12:24:29 <Bonus_> :(((
12:24:29 <conal> geezusfreeek: This technique is at work inside lazy data representations in general.  A pure values is represented as a cell holding a thunk.  When more information is needed, the thunk is evaluated, resulting in a shell data structure (WHNF) around some more thunks, which is then stored in the cell, overwriting the thunk.
12:24:47 <conal> I'm suggesting generalizing the mechanism and allowing more instances of the generalization to be implemented on top of Haskell, probably with a proof obligation of semantic equivalence.
12:25:22 <geezusfreeek> conal: i have been thinking along similar lines. we are basically reimplementing thunks
12:25:40 <astrolabe> Bonus_: Write your own maximum using foldl'
12:26:05 <astrolabe> Bonus_: Or compile your code using -O
12:26:09 <Bonus_> hmm
12:26:15 <Bonus_> i'll do that
12:26:24 <Bonus_> if i did it with foldl it would still run out of stack, yeah?
12:26:27 <Bonus_> i need foldl'
12:26:30 <conal> geezusfreeek: yes.  so i'd like to either use the existing thunk mechanism (as in my Simply paper) or generalize that mechanism.
12:26:32 <Bonus_> is that correct
12:26:33 <Deewiant> astrolabe: oo, does the strictness analyser make foldl' obsolete?
12:26:39 <sclv_> geezusfreeek, conal: that's a useful insight. experience implementing laziness in a typically strict language probably helps to think about the problem, since this is just a higher level version of that.
12:26:39 <conal> I like the view of unsafePerformIO that it's a tool for programming the RTS.
12:27:09 <astrolabe> Deewiant: Does the strictness analyser work for interpreted code?
12:27:28 <astrolabe> Bonus_: I think so, but I may be out of date.
12:27:50 <dalien> hi folks, I'm a noob to Haskell, and trying to get my head around it, and encountered something that I do not fully understand - whether i do something wrong, or libraries are incomplete, or... any guru might take a glance ?
12:27:57 <Bonus_> ah, thanks
12:28:00 <Deewiant> astrolabe: no. But, outside that, and with -O?
12:28:09 <geezusfreeek> conal: this is actually exactly why i thought to try a GADT, because i had been thinking about it as a tree reduction, just like the RTS does
12:28:12 <sclv_> dalien: ask away, somebody usually is happy to chip right in.
12:28:28 <conal> geezusfreeek: oh!
12:28:41 <dalien> http://hpaste.org/7331 - it complains about absence of instance
12:28:49 <dalien> for Word16
12:29:10 <dalien> but from what I've seen - the instance of PrintfArg Word16 is indeed defined in Text.Printf...
12:29:35 <dalien> so either it is my install that has the old version of library which does not have that, or I miss something :)
12:29:39 <conal> geezusfreeek: i like this line of experimentation & inquiry.  one question i hope we get more clarity about is "what mechanism is missing in the machinery of pure functional programming that prevents us from an efficient functional implementation of this functional semantics."
12:29:51 <augustss> dalien: maybe you have an old Printf
12:30:13 <augustss> dalien: because I added Word16 fairly recently
12:30:44 <sclv_> in ghci you can get info on PrintfArg and see its instances.
12:31:01 <conal> geezusfreeek: btw, if you ignore the *implementation* of unamb and you see it as an RTS primitive (noting its referential transparency), does your distaste for the solution in my paper shift?
12:31:15 <geezusfreeek> conal: yes
12:31:28 <conal> geezusfreeek: thx.  i was wondering.
12:31:48 <dalien> augustss: ahha thanks :)
12:32:00 <sclv_> also, dalien, are you sure word16 does what you think?
12:32:09 <augustss> conal: could you have implemented unamb with por?
12:32:25 <quicksilver> MyCatVerbs: did you get an answer?
12:32:34 <quicksilver> MyCatVerbs: you can do exactly that with the 'mdo' extension.
12:32:50 <dalien> sclv_: good question... I'd need an equivalent of uint16_t - and it looks like it ?
12:32:50 <conal> augustss: unamb = por + unsafePerformIO + proof obligation of semantic compatibility
12:33:09 <augustss> conal: hmmmm, ok
12:33:19 <sclv_> yep
12:33:22 <conal> augustss: oh wait.  i may be confusing por with amb
12:33:32 <sclv_> ?quote fromIntegral
12:33:32 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
12:33:44 <geezusfreeek> i got confused there... por /= par?
12:33:50 <conal> augustss: i don't think i know the answer to your question.
12:33:53 <geezusfreeek> i thought it was a typo
12:33:58 <sclv_> (you can use fromIntegral to turn your word16 back into an int or whatever to printf it)
12:33:59 <conal> :)
12:33:59 <augustss> geezusfreeek: por is parallel or
12:34:06 <geezusfreeek> oh!
12:34:15 <dalien> sclv_ aah! :) sweet
12:34:37 <conal> augustss: that's an operational explanation.
12:34:56 <augustss> conal: it's an explanation of the name :)
12:34:59 <conal> denotationally, por is like or but is true if *either* argument is true, even if the other is bottom.
12:35:02 <dalien> the reason for this - I'm flirting with the idea of porting the opensimulator logic using haskell (for the purpose of learning the latter)
12:35:08 <conal> augustss: oh
12:35:21 <geezusfreeek> it was enough to tell me what to look for ;)
12:35:28 <conal> augustss: i like your por question.  i suspect it would be enough.
12:35:52 <augustss> and if I remember right, adding por makes the standard semantics for, e.g., the lambda calculus fulyy abstract
12:35:55 <conal> augustss: and it would place my unamb in a more familiar semantic setting.
12:36:07 <conal> augustss: i think that's correct.
12:36:43 * conal wishes he'd explained unamb in terms of por in his icfp submission
12:37:12 <augustss> conal: has your paper been accepted?
12:37:22 <conal> augustss: no word
12:37:34 <conal> oh hey: por a b = or a b `unamb` or b a
12:37:45 <conal> i wish i'd put *that* in the paper.
12:37:50 <dalien> sclv_: "hex xx = printf "%x" (toInteger (fromIntegral xx))" did the trick - otherwise it was complaining that "Num" was ambiguous
12:37:50 <augustss> heh
12:39:04 <conal> (s/or/||/)
12:39:38 <conal> a `por` b = (a || b) `unamb` (b || a)
12:39:49 <sclv_> ?hoogle showHex
12:39:50 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
12:39:51 <augustss> So it works one way
12:39:58 <sclv_> dalien: also ^^
12:40:07 <conal> yeah, one way.
12:40:21 <dalien> sclv_, augustss: thank you guys a ton :) I'm still in the very initial stage - but this language looks awesome :-)
12:40:39 <conal> yay!  happy new haskeller
12:40:50 <augustss> dalien: happy to help
12:40:57 <Saizan> ?type toInteger
12:40:59 <lambdabot> forall a. (Integral a) => a -> Integer
12:41:01 <dalien> heh :) still in process of getting my brain through the blender :)
12:41:03 <twanvl> por = commutative (||)  where commutative f a b = f a b `unamb` f b a
12:41:25 <conal> twanvl: better yet!
12:41:59 <ddarius> "por equals commutative or"
12:42:56 <MyCatVerbs> quicksilver: yes, indeed. vixey (since left) pointed it out. Thanks.
12:43:01 <sclv_> I can't think how to make it go the other way...
12:43:28 <conal> I have a similar example but not commutative:
12:43:28 <conal> tah <= tbh = ((tah `compareI` exact tbh) /= GT) `unamb` ((tbh `compareI` exact tah) /= LT)
12:43:30 <MyCatVerbs> quicksilver: well, mfix. I have no *clue* how to write using mfix what I just wrote in mdo, though. Guess I'll have to blow some time learning how mdo desugars. But, later.
12:43:41 <conal> (from the paper)
12:44:51 <augustss> conal: I liked your paper, btw
12:45:03 <conal> augustss: hey, thanks!  :)
12:45:31 <geezusfreeek> well, back to work
12:45:59 <conal> geezusfreeek: have fun
12:46:01 <Deewiant> @lastlog MyCatVerbs
12:46:02 <lambdabot> Unknown command, try @list
12:46:03 <Deewiant> darn
12:46:05 <augustss> geezusfreeek: discussing haskell isn't work?
12:46:10 <Deewiant> disregard that :-P
12:48:51 <mercury^> > let primes = 2:3:[n | n <- [5..], all (==False) $ map (\m -> n `mod `m == 0) $ takeWhile ((<=n).(^2)) primes] in filter snd $ zip primes $ map (\m -> 600851475143 `mod` m == 0) $ takeWhile ((<=600851475143).(^2)) primes
12:48:54 <lambdabot>  [(71,True),(839,True),(1471,True),(6857,True)]
12:49:31 <dalien> sclv_ took a bit of time to realise that showHex actually returns a function :-) I just love this.
12:50:00 <augustss> dalien: showHex isn't the most user friendly function :)
12:50:06 <quicksilver> MyCatVerbs: the desugarings moderately fiddly although not hard.
12:50:10 <xerox> mercury^: [5,7..] for added speed
12:50:19 <dalien> augustss: nah, it's ok: putStrLn $ (showHex(1234::Word16) "")
12:50:20 <sclv_> yeah, i should have warned you about that. ShowS is a "trick" for efficient appending of lists.
12:50:29 <dalien> i RTFMed :)
12:50:42 <xerox> mercury^: all (\p -> mod n p /= 0) for added simplicity
12:51:14 <sclv_> dalien: if you like to RTFM, you'll do great with haskell!
12:51:15 <mercury^> thanks
12:51:24 <dalien> the ease with which the functions become values (err.. values *are* functions :) is mindboggling :)
12:52:37 <mercury^> yeah, that all .. $ map .. was pretty stupid actually :)
12:52:42 <augustss> dalien: boggling the mind is what it's all about :)
12:52:42 <dalien> sclv_: yeah, i've gone through the gentle introduction to haskell and a few other tutorials - most of it looks pretty straightforward, just need the time to settle the dust in the brains... (although monads are a bit muddy for now, but i read the big warning signs so not worried atm :)
12:54:05 <conal> dalien: play with some other type classes before Monad, and then it won't be so mysterious.
12:54:28 <conal> dalien: e.g., Eq, Ord, Num, Show
12:54:37 <mauke> then Functor!
12:54:44 <dalien> conal: yeah - looks like Show is a good candidate - as well as the Binary
12:54:45 <byorgey> then Applicative!
12:54:47 <conal> yes, Functor!
12:54:57 <conal> amen to Applicative!
12:55:17 <conal> then Monad will be just more of the same
12:55:25 <thoughtpolice> dalien: if you want an excellent monad tutorial I really suggest "you could have invented monads (and maybe you already have)" by sigfpe (google it)
12:55:33 <thoughtpolice> made it really click :)
12:56:01 <byorgey> and don't forget Monoid!
12:56:16 * conal winced at sigfpe's tutorial's mixing of syntax and semantics.
12:56:23 <dalien> thoughtpolice: thx :) i will read it - although first i will make my own brain squeeze. Love the feeling of digesting the "unknown" concepts - and the haskell is full of that
12:56:38 <mauke> Monoid is just a simplified Num :-)
12:56:44 <conal> with all of these other type classes, why does Monad still have a mystique?
12:56:44 <sclv_> conal: maybe you're thinking of his other one, "IO without Monads" ?
12:57:00 <conal> sclv_: looking ...
12:57:06 <byorgey> conal: probably because of IO.
12:57:20 <Heffalump> and because it's very general and widely used
12:57:30 <sclv_> also because we give it special magic notation sugar
12:57:31 <byorgey> conal: i.e., it's always the first of these type classes that people run into.
12:57:54 <conal> byorgey: that's my suspicion also.  so we could demystify by separating out the often-muddled aspects of Monad
12:58:20 <byorgey> conal: what do you mean?
12:58:28 <dalien> byorgey: indeed. the IO is the one :)
12:58:31 <dons> bos, any chance of video of the bayfp talk?
12:58:42 <bos> probably, yes.
12:58:45 <dons> woot.
12:59:12 <conal> Monad has a few independent facets: it's type class, it relates to a type (IO) that represents imperative computations as values, and it has special notation.
12:59:15 <dons> maybe mention it on haskell-cafe@
12:59:35 <conal> each of these notions can be explained independently of the other two.
12:59:47 <Arnar_> @pl \f t -> f $ run t
12:59:47 <lambdabot> (. run)
13:00:46 <conal> sclv_: yeah: "The IO Monad for People who Simply Don't Care" is the one i winced at, mixing syntax and semantics.
13:01:25 <conal> speaking of videos, does anyone know what became of the videos of icfp07 presentations?
13:01:47 <bos> conal: they're up on acm.org now
13:02:06 <bos> kathleen is probably going to put them on google video.
13:02:23 <conal> bos: oh.  icfp as well as cufp?
13:02:32 <bos> oh, just cufp afaik.
13:02:43 <conal> urg.  whence the icfp vids?
13:02:45 <Heffalump> we could probably demystify just by changing the name
13:03:18 <conal> Heffalump: maybe at first.  until people caught on.
13:03:43 <dalien> conal: the way I understood so far the "do" semantics, is the sequence of operations in "do" actually has the "state of the world before" as one of the parameters, and returns "state of the world after" as result... - so technically each action is a pure function. but maybe i'm wrong :)
13:04:12 <bos> yes, you're wrong :-)
13:04:26 <Jedai> And no, you're right !
13:04:30 <conal> dalien: that semantics is about the IO type.  not about do notation or about monads.
13:04:48 <byorgey> well, it's about state monads in general, of which IO is a particular special (magical) case.
13:04:50 <conal> dalien: and it's really only true without concurrency.
13:04:56 <byorgey> but not of monads in general.
13:05:04 <Heffalump> I think there really is a lot of mystique attached to them because of the name. Perhaps it'd be hard to shed it now.
13:05:06 <Jedai> Anyway you shouldn't try to apply semantics to the "do" but rather to the monadic trasnlation underneath
13:05:28 <conal> state monads without concurrency.
13:05:34 <thoughtpolice> dalien: for IO that's about how it goes. everything's purely functional, even IO. you could think of 'main' as a series of 'World' transformations, and so if you have the same initial world, main will be the exact same every time.
13:05:46 <Jedai> The part where you're right is that what's in the do is really pure in a way
13:05:52 <byorgey> anyway, why bother de-mystiqueing monads?  demystify, yes, but a little mystique never hurt anyone =)
13:06:05 <thoughtpolice> of course note that an identical world means the exact same things will happen in the future, including you typing the exact same thing, network and disk being in the same state, etc. etc.
13:06:17 <dalien> aha :)
13:06:32 <Toxaris> thoughtpolice: that's an interesting idea of "identical world" which may or may not correspond to how the world works
13:06:38 <dalien> byorgey: "make a system understandable by idiots and only idiots will use it" ? :)
13:06:46 <conal> byorgey: not just to demystify.  also because type classes and computation-as-value are both very cool ideas.  if people understand them separately, then they can reuse each idea.
13:06:51 <conal> mental modularity!
13:06:55 <byorgey> dalien: hehe, that's one way to look at it. =)
13:07:04 <thoughtpolice> Toxaris: it probably doesn't but that's the best way I can think of explaining it in this context. :p
13:07:39 <byorgey> conal: agreed!  but, what is the best vehicle for promoting these ideas?  we can't just go and edit every one of the 497 monad tutorials out there =)
13:07:49 <conal> does no one want to challenge my claim that concurrency breaks the state -> (a,state) model?
13:08:12 <dons> conal, how does it "break"
13:08:22 <conal> byorgey: we can start writing new ones and encouraging a more modular way to think & talk.
13:08:28 * dons takes the bait.
13:08:30 <dalien> conal: computation-as-value = higher-order functions ? (or yet something I have to RTFM about ? :)
13:08:30 <conal> dons: thx!
13:08:51 <Heffalump> conal: it just requires one to break state into smaller pieces
13:09:43 <conal> dons: concurrency allows interleaving, which means that *intermediate* states become relevant, not just end states.
13:10:02 <Heffalump> they're only relevant if there's interference, hence breaking up state.
13:10:09 <byorgey> dalien: not really, it's just simply the idea that you can represent a computation -- some sort of algorithm, series of steps, etc. -- as a value, which can then be passed around, manipulated, composed with other computations, and so on
13:10:11 <conal> dons: assuming nondeterministic concurrency (as in IO), then we don't get a single state but rather a set of possible states.
13:10:19 <Jedai> dalien: No, computation-as-value means you represent a compuation by a value that you can "run" afterwards with an "interpreter", IO is like that in Haskell
13:10:30 <byorgey> dalien: the ability to represent functions as first-class values is a simple example.
13:10:49 <sclv_> conal: what do you mean nondeterministic concurrency?
13:11:21 <conal> sclv_: i mean that the order of interleaving isn't guaranteed and matters in the answer
13:11:23 <sclv_> you've got sort of the tautology that nondeterminism breaks purity.
13:11:39 <sclv_> but we can model deterministic concurrency just fine.
13:11:43 <Jedai> dalien: But IO is "run" by the runtime of Haskell, whereas more explicit examples are other monads for which you have a run function (runST for the ST monad, runState, run...)
13:12:18 <conal> we can model both deterministic and nondeterministic concurrency purely (math).  nondeterministic is *way* more complex of a semantic model.
13:12:32 <conal> and hence way more difficult to reason about and program with correctly.
13:12:52 <sclv_> you can even take the "nondeterminism" bit and wrap it up in a monad, no? just like we do with nondeterministic user input?
13:12:56 <conal> and ironically much more popular a model
13:13:16 <conal> sclv_: yes, and you've only hidden the semantic complexity, not improved it.
13:13:19 <sclv_> and then you get a pure function parameterized on the switching signal.
13:13:23 <dalien> Jedai: ok i will need to sleep on that a bit to digest it :)
13:13:26 <conal> sclv_: programs still have intractable meanings.
13:14:02 <sclv_> i just don't think its particularly more "broken" to think with than IO in general
13:14:14 <pjd_> Jedai: there's a run function for IO too, of course
13:14:15 <sclv_> its just an especially fancy side effect.
13:14:21 <Jedai> dalien: Yeah, you have to do a lot of that in Haskell, but the rewards are very good too :)
13:14:40 <conal> sclv_: s/broken/complex ?
13:14:42 <Jedai> pjd_: unsafePerformIO (but it's unsafe and beginners shouldn't learn about it)
13:15:19 <pjd_> Jedai: oh, sorry, didn't read all the scrollback
13:16:03 <conal> i don't know how to define "pure", since denotational semantics maps arbitrary languages to functional programming.  but i do have a metric for simple/complex: the domain definition in a denotational semantics specification.
13:16:07 <sclv_> erm, broken in the sense that you can't do it with state -> (a, state)
13:16:24 <dalien> Jedai: yeah, i can already feel it a bit :) it was slightly like that with Ruby - but that one is closer to the classic imperative languages
13:16:36 <conal> sclv_: do you mean you think you can model nondeterministic concurrency with state -> (a,state)?
13:17:08 <sclv_> deterministic concurrency parameterized over a scheduler input.
13:17:19 <conal> rather than state -> Pow ([state],a) ?
13:17:51 <Toxaris> conal: like "something is simple if it maps easily to the semantic domain of my favorite programming paradigm. see how simple my favorite programming paradigm is"
13:17:53 <conal> sclv_: with feedback between the scheduler and the scheduled computations?
13:17:57 <sclv_> for nondeterministic concurrency, then yeah. and i wonder if even what you have is sufficient...
13:18:19 <sclv_> conal: feedback like what?
13:18:22 <conal> Toxaris: i agree with your point.  my favorite paradigm is math.
13:18:53 <Toxaris> conal: in what sense is a turing machine more or less mathy then lambda calculus?
13:19:12 <conal> sclv_: can the scheduling decisions be influenced in any way by the execution of the program?
13:19:50 <dalien> Toxaris: which is a very reasonable statement - "simplicity <=> ease of understanding to a particular person"
13:20:09 <conal> Toxaris: i accept your point.  i knew "math" is too crude a classification.  though i wasn't comparing with the lambda calculus.  i'm talking about the semantic domains, not the semantic definitions.  and i'll settle for admitting i have a personal bias.
13:20:52 <Toxaris> conal: not that I see it differently, I'm just searching for good objective reasons
13:20:53 <Jedai> Toxaris: Lambda calculus translate directly to mathematic functions (given a model), whereas an imperative machine works with state, a concept which is not really represented in mathematics outside computer science
13:21:05 <conal> my bias prefers T->a (FRP) to world -> Pow ([world],a) (IO)
13:21:23 <sclv_> conal: have you seen http://hackage.haskell.org/cgi-bin/hackage-scripts/package/IOSpec-0.2 ?
13:21:25 <lambdabot> http://tinyurl.com/6eyxrx
13:21:45 <conal> Toxaris: me too!  for a long time, i've feeling my way toward a cogent expression of why i prefer functional programming to imperative programming (including IO).
13:21:49 <sclv_> conal: I wasn't imagining they could be, but don't know if it would matter ?
13:21:52 <conal> sclv_: yes.  and it's far from IO
13:23:07 <sclv_> but it lets you do MVars and arbitrary schedulers and forks, no?
13:23:30 <sclv_> so it at least gets the concurrent bit sort of down.
13:23:36 <conal> honestly, i'm sad about the acceptance of monadic imperative programming.  imperative programming used to be obviously painful in functional languages.  now it's much more convenient, but semantically it's no cleaner.  not that i want the old approaches.  i want more interest in awesome functional solutions.
13:24:33 <cjb> <naive> what functional solutions *are* there for performing side-effects? </>
13:24:55 <cjb> or are you saying that people use imperative code in places where they don't actually need to be imperative?  I guess I don't know what those places are.
13:25:33 <conal> cjb: i'm saying the latter.  the "don't actually need to" is partly observation and partly conjecture.
13:25:41 <dons> yeah, there's an overuse of monadic code, in general, as its  so easy now.
13:25:50 <mux> all of the monads but IO could be avoided
13:25:58 <conal> dons: thx.  that's exactly what i'm saying.
13:26:05 <mux> not that I think they should be :)
13:26:09 <conal> mux: i'm hoping for the opposite choice.
13:26:15 <cjb> Ah.
13:26:26 <dalien> mux: socket IO is part of the IO monad as well ?
13:26:36 <dons> then again, this greatly eases the path in, and people tend to pick up the purely functional solutions ... eventually
13:26:39 <conal> Monad is semantically neutral.  just a great interface structuring mechanism.  like Monoid & Show.
13:26:50 <Cale> Well, monadic programming is functional programming, it's just *also* somewhat imperative.
13:26:57 <conal> dons: yep.  comfort is two-edged.
13:27:04 <mux> conal: maybe applicative functors will yield new interesting uses some day
13:27:16 <mux> dalien: yes
13:27:18 <conal> Cale: how is monadic programming imperative?  (aside from state & io)
13:27:28 <sclv_> traverse actually covers a huge portion of where foax have generally used monads.
13:27:34 <conal> mux: maybe, but i doubt it.  Applicative is about structuring, not semantics.
13:27:38 <Cale> conal: Well, I'm specifically thinking of the monadic solution to IO, I should be clear :)
13:27:41 <conal> mux: btw, i love Applicative!
13:27:59 <mux> Applicative is cute
13:28:24 <Cale> conal: But even in any monad, you have some sense of 'step-by-step execution' even if it's a very very strange one :)
13:28:27 <conal> Cale: okay.  one could say that IO programming in Haskell is analogous to cpp+C programming.
13:28:48 <dons> yeah, its a bit unfortunate that the applicative class only made it into base so late on the scene
13:28:51 <conal> Cale: though often with a very simple semantic model, e.g., Maybe's and []'s
13:28:54 <dons> if only it had been there in 95
13:29:20 <geezusfreeek> augustss: nope, discussing haskell is only play, unfortunately
13:29:22 <conal> Consider cpp as a purely functional language that constructs C code at runtime.
13:29:50 <Heffalump> conal: umm, it has side effects (#define)
13:29:57 <conal> so Haskell IO programming is functional in the same sense as C programming.
13:30:04 <dons> Heffalump: are they effectful?
13:30:11 <Korollary> you can undefine too
13:30:12 <conal> Heffalump: okay, tweak the rules a bit to #define-once
13:30:14 <Heffalump> dons: yes
13:30:40 <dons> ah i see.
13:30:49 <conal> sure Cpp may have a few accidental imperative aspects.  remove them, and call that cpp'.
13:30:54 <dons> yeah.
13:30:57 <dalien> conal: if only cpp was a purely functional language with the insight into the semantics... :)
13:30:59 <Heffalump> "accidental"? :-)
13:31:06 <dons> term rewriting languages should be pure :)
13:31:20 <conal> dalien: that's my point.  IO has its own intractably complex semantics.
13:31:27 <conal> just like C
13:31:29 <Toxaris> conal: monadic programming is "somewhat imperative" because it supports an imperative mindset.
13:31:42 <conal> Toxaris: s/monadic/IO
13:31:44 <dalien> conal: one of the primary reasons for me to start looking into haskell is its template haskell
13:32:13 <dalien> conal: because in C I could not go much further than using "#defvar(name,src) typeof(src) name = src"
13:32:17 <Toxaris> conal: nope, I mean monadic, independent of the actual monad
13:32:29 <conal> dalien: that's the functional part (cpp)
13:33:02 <conal> Toxaris: maybe the imperative aspect of Monad is just habit rather essence.  try using join instead of >>=
13:33:13 <conal> Toxaris: and you may see Monad less imperatively.
13:33:28 <Toxaris> conal: I agree, with join it's much better
13:33:44 <dalien> conal: yup - but i also want something like "#define somewhat_copy(a,b) for_all_members(typeof(b)) { a.member = b.member }" - and it is impossible in CPP (but might be possible in TH from my glance)
13:33:48 <conal> Toxaris: and yet it's fully equivalent to the >>= formulation
13:33:50 <Toxaris> conal: actually, I try to use only Applicative, and join where I really need it
13:34:13 <conal> Toxaris: me too.  Applicative is fun!
13:34:15 <geezusfreeek> i kind of see bind as the continuation passing form of join
13:34:22 <Toxaris> conal: but that's not what is normally refered to as "monadic programming".
13:34:23 <conal> Toxaris: and semantically neutral
13:34:55 <conal> Toxaris: right.  different style.  i like it better.
13:35:17 <pjd_> Toxaris: perhaps it's better to say that do notation supports an imperative mindset?
13:35:21 <conal> i also cringe at the choice of the word "do", which also encourages imperative thinking.
13:35:29 <conal> pjd_: !
13:35:36 <conal> the word "do" in particular.
13:35:45 <conal> since functional programming is about being, while imperative is about doing.
13:36:13 <conal> and Monad is orthogonal to be/do
13:36:15 <Korollary> fp programs written for the sake of being?
13:36:20 <geezusfreeek> i prefer to think of do notation as a notation for data flow, not for control flow
13:36:53 <conal> Korollary: fp is mainly about composition, and composition is much more powerful on being than on doing.
13:37:04 <conal> which is the point of Backus's "liberated" paper
13:37:25 <Korollary> but people are doing things even when they're composing to get it done
13:37:30 <conal> i.e., that doing composes very weakly but being very simply & powerfully
13:37:37 <chessguy> 'ello
13:38:05 <conal> Korollary: sure.  coding is doing, even coding purely functional programs.
13:38:11 <conal> but the result of coding is a being
13:38:25 <conal> i.e., a program or a denotation
13:38:49 <conal> Korollary: though i may have missed your meaning completely
13:39:56 <conal> btw, i highly recommend backus's "liberated" paper
13:40:00 <geezusfreeek> huh, proggit's down
13:40:01 <Korollary> I think you're implying that do sounds like instructing the computer to perform individual commands. To me it adds no meaning and it's very short.
13:40:18 <geezusfreeek> all subreddits, it appears
13:40:53 <conal> Korollary: okay, i understand you comment better.  you don't take "do" to mean anything about do-ing.
13:41:54 <conal> i do worry about "do" contributing to the existing confusion in newbies between Monad and imperative models like IO
13:42:29 <conal> which i assume was part of the point of choosing do.
13:42:32 <vegai> isn't "return" kinda bad too?
13:42:44 <conal> vegai: definitely.
13:42:55 <conal> though not as loaded for me as "do"
13:43:19 <conal> yet it suggests C "return", which has a very different meaning, even for IO
13:44:10 <conal> "pure" is perhaps less loaded still.
13:44:57 <sclv_> I think of return as "i give you a value, and you return it to me" and it makes sense.
13:45:03 <Toxaris> I had problems understanding return when first confronted with it, not because confusing it with c's return, but because of the direction it maps values.
13:45:24 <sclv_> pure sounds like its going to *make* what you give it pure -- it reads backwards to me.
13:45:40 <conal> sclv_: oh, like purify
13:45:54 <Toxaris> I don't like pure either
13:46:03 <dalien> sclv_: then should it read like: "taint" ? :)
13:46:15 <conal> yeah.  there's an inherent tension between suggestiveness and generality.
13:46:27 <conal> do/return are suggestive but not general.
13:46:36 <geezusfreeek> i think "wrap" would fit pretty well
13:46:38 <sclv_> enstructure
13:46:39 <dalien> take a pure value and make it dirty in order to get into the realm of imperative :) (again if i get it all right)
13:46:52 <geezusfreeek> i don't like the idea of calling it dirty or tainted
13:46:57 <vegai> rwh uses "inject" for a while
13:47:09 <shachaf> What is dirty or tainted about Identity 5?
13:47:16 <conal> *any* meaning at all we give to pure/return/do would belie generality.
13:47:19 <dons> its tagged/tainted
13:47:23 <conal> shachaf: exactly
13:47:25 <sclv_> structured
13:47:28 <Lord_Illidan> Can anyone confirm..is the let notation in haskell just syntatic sugar for the lambda notation?
13:47:49 <dons> Lord_Illidan: you can rewrite binds as lambdas, yeah.
13:47:49 <shachaf> Lord_Illidan: No, it's more than that.
13:47:50 <dolio> No.
13:47:53 <dons> but they're not quite the same
13:47:58 <conal> Lord_Illidan: almost.  the typing rules differ between let and beta-redexes
13:47:58 <dons> 'let' allocates a thunk
13:48:00 <shachaf> > let x = id in (x 5, x 'c')
13:48:02 <lambdabot>  (5,'c')
13:48:08 <shachaf> > (\x -> (x 5, x 'c')) id
13:48:10 <lambdabot>   add an instance declaration for (Num Char)
13:48:17 <pjd_> Lord_Illidan: roughly everything in Haskell is syntax sugar for case and lambda
13:48:21 <Jedai> The pattern are lazy by default in a let binding, not so with a lambda
13:48:25 <Heffalump> dons: operationally in all existing implementations, not semantically
13:48:28 <conal> let is polymorphic
13:48:34 <dons> Heffalump: yep.
13:48:38 <Lord_Illidan> the (\x ->) style of notation, can anyone tell me exactly what it's called?
13:48:49 <conal> wow -- lots of differences, though identical in the pure lambda calculus.
13:48:58 <conal> Lord_Illidan: a lambda expression
13:48:58 <sclv_> Lord_Illidan: that's lambda.
13:49:07 <sclv_> \ is what haskell uses for lambda.
13:49:09 <Lord_Illidan> I've got some code in let format which I'd like to convert to that style of notation, that's why..
13:49:10 <Lord_Illidan> thanks all
13:49:31 <Toxaris> hmm. let allows recursion and lambda not.
13:49:40 <Toxaris> or at least that's what I believe...
13:49:44 <Lord_Illidan> oh, and before I go down a very wrong road..
13:49:46 <pjd_> modulo fix
13:49:59 <Toxaris> pjd_: can fix be expressed without let?
13:50:11 <Lord_Illidan> what I am doing basically is going to run one function, get the output of that function and run it to another function
13:50:34 <pjd_> Toxaris: well, there's fix f = f (fix f) :)
13:50:46 <conal> let has an implicit fix
13:51:11 <pjd_> Lord_Illidan: composition?
13:51:19 <geezusfreeek> Lord_Illidan: let a = b in a d is pretty close to (\a -> a d) b, but the latter needs fix explicitly if you want recursion
13:51:29 <Lord_Illidan> no, pjd it's a bit more complicated than that
13:51:30 <geezusfreeek> Lord_Illidan: composition?
13:51:34 <geezusfreeek> oh
13:51:50 <geezusfreeek> Lord_Illidan: show us with hpaste
13:51:56 <Lord_Illidan> what I'm doing is basically a small logo interpreter
13:52:28 <Lord_Illidan> and I want to parse 2 logo commands sequentially, and run them after eachother
13:52:35 <Lord_Illidan> now, I've done it with the let notation
13:53:37 <Toxaris> Lord_Illidan: lambda bindings will not gain you anything, let-bindings are normally easier to understand, but sometimes they need more lines to be written clearly.
13:53:45 <Lord_Illidan> http://hpaste.org/7334
13:54:06 <Lord_Illidan> aye, but I'd like to understand how to write them more..I know let bindings are easier
13:55:08 <pjd_> Lord_Illidan: you could also use a where clause, in that specific case
13:55:09 <Jedai> pjd_: but fix f = f (fix f) don't have the same memory behaviour than fix f = let x = f x in x, no ?
13:55:28 <Lord_Illidan> pjd_, I was thinking of that too
13:55:33 <conal> thanks for the chat, all.  i'm off to the post office.
13:55:34 <Lord_Illidan> what's with the fix function, btw?
13:55:42 <pjd_> :t fix
13:55:44 <lambdabot> forall a. (a -> a) -> a
13:56:02 <geezusfreeek> Lord_Illidan: i assume that the commented out code in your paste is what we are looking at here?
13:56:10 <pjd_> Lord_Illidan: it's the fixed-point combinator (also known as the Y combinator)
13:56:11 <conal> Lord_Illidan: fix is the essence of recursion: it finds least fixpoints.
13:56:11 <Lord_Illidan> geezusfreeek, you assume rightly
13:56:42 <conal> Lord_Illidan: ("least" as in least terminating)
13:56:54 <Jedai> > fix (\f n -> if n > 1 then n * f (n-1) else 1) 5
13:56:54 <lambdabot>  120
13:57:04 <Lord_Illidan> whew
13:57:09 <Jedai> > fix (1:)
13:57:10 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:57:46 <Lord_Illidan> well, I'll see what I can do, thanks all
13:58:00 <pjd_> Lord_Illidan: fix isn't really relevant to this example, though
13:58:15 <dolio> newtype Roll a = Roll { unRoll :: Roll a -> a } ; fix f = (\x -> f (unRoll x x)) (Roll (\x -> f (unRoll x x)))
13:58:17 <pjd_> you basically have some nested lets
13:58:43 <pjd_> you can transform them to nested lambdas
13:59:40 <oklopol> @die 1d2
13:59:40 <lambdabot> 1d2 => 2
14:01:16 <Jedai> Lord_Illidan: And when you've done that, you can consider using the State monad and a better TurtleState datatype ^^
14:01:50 <Lord_Illidan> Jedai, I would..however, I've got to use what we were given as part of an assignment
14:02:15 <Jedai> Lord_Illidan: Crappy assignment ?
14:02:19 <oklopol> @die 1d2
14:02:19 <lambdabot> 1d2 => 2
14:02:23 <Lord_Illidan> Jedai, well, not so much
14:02:32 <Lord_Illidan> It's quite interesting, takes logo statements
14:02:39 <Lord_Illidan> and make postscript files
14:02:48 <Toxaris> Jedai: it's easier to understand the state monad if you have done it manually before
14:03:00 <Jedai> Lord_Illidan: At least you're studying Haskell :(   I whish I could
14:03:10 <Lord_Illidan>  image2PS (fst (play ((Turn 30):>(Forward 300):>(Turn 60):>(Forward 20):>(Forward 10):>(Turn 50):>(Forward 30)) (True,(0,0),0))) "test.ps"
14:03:30 <Lord_Illidan> for instance..that parses the logo commands and generates a postscript file..
14:03:30 <Jedai> Toxaris: Right, which is why I told him to consider translating his code afterward :)
14:03:38 <geezusfreeek> Lord_Illidan: i think using let here, if you can't use the State monad, would be your best bet
14:03:52 <Lord_Illidan> geezusfreeek, I'm thinking of leaving it with let
14:04:10 <Lord_Illidan> It's probably better having code I can understand, than a bunch of code I'll forget how it works tomorrow
14:04:22 <Lord_Illidan> but thanks all
14:04:29 <Toxaris> Jedai: sure, and it's a good idea of course. but the assignment is not automatically crappy, just because it doesn't go that far, maybe he will learn in the next assignment?
14:04:46 <Lord_Illidan> Actually, we won't be touching monads this semester
14:05:07 <Lord_Illidan> I've played with monads for my first hw though
14:05:10 <MyCatVerbs> Lord_Illidan: really not hard at all.
14:05:22 <Toxaris> what *is* crappy about the assignment is the syntax though. (if that code Lord_Illidan pasted is original)
14:05:26 <Jedai> Toxaris: I don't like the assignment where I'm told which feature of the language I should use, only TP should be like that
14:05:38 <Lord_Illidan> The first hw of introduction to Haskell, heh
14:05:45 <Lord_Illidan> Toxaris, what syntax is crappy
14:05:46 <Lord_Illidan> ?
14:05:47 <pjd_> Lord_Illidan: i annotated the code with how you would translate the lets to lambda
14:05:51 <pjd_> (for completeness)
14:06:13 <Toxaris> Lord_Illidan: "(Turn 30):>(Forward 300):>(Turn 60)" instead of "Turn 30 :> Forward 300 :> Turn 60"
14:06:34 <Lord_Illidan> I didn't really know about interpreters so I automatically assumed that I had to compile the code..so I had to use IO monads
14:06:44 <Lord_Illidan> Toxaris, I don't think it works without the brackets
14:07:05 <Toxaris> Lord_Illidan: "(True,(0,0),0)" instead of "(True, (0, 0), 0)"
14:07:08 <Lord_Illidan> and yes, it is original, that's the huge bunch of code I have to write to generate an image
14:07:23 <Lord_Illidan> and oh..
14:07:29 <Lord_Illidan> Toxaris, if you mean that code
14:07:30 <Toxaris> Lord_Illidan: why shouldn't it work?
14:07:38 <Lord_Illidan> It's what I am typing into ghci to see an output
14:07:41 <Lord_Illidan> not actual code
14:08:32 <Lord_Illidan> strike me down..it did work
14:09:05 <Lord_Illidan> I must have gotten a bracket wrong when I tried it out first..well, thats great
14:09:12 <pjd_> Lord_Illidan: application binds tightly in Haskell
14:09:17 <Jedai> Lord_Illidan: function application has more priority that any binary operator
14:09:28 <Toxaris> Jedai: "TP"?
14:09:59 <Jedai> Toxaris: Sorry, let's say practical courses ?
14:10:16 <Jedai> Toxaris: (other language, other abbreviations)
14:10:20 <Lord_Illidan> pjd_, I am reading your lambda expression...
14:11:41 <Toxaris> Jedai: a problem with teaching is that normally the teacher has to teach more then one learner at once, simultany in some way. so the teacher has to decide about the speed and direction of knowledge acquisition, instead of the learner, which would be both funnier and more ressource efficient
14:12:30 <Lord_Illidan> funnier..good way to go about it :D
14:12:33 <geezusfreeek> then again, my programming languages teacher says "functional languages are just weird" and basically just leaves it at that
14:12:47 <Lord_Illidan> geezusfreeek, I'd have to agree with him..
14:12:55 <geezusfreeek> Lord_Illidan: why's that?
14:13:01 <Toxaris> Jedai: there are a number of approaches what to do about this (like e.g. placing learners in an environment which contains learning possibilities and let them decide which to use), but I don't think they are applied at university level
14:13:05 <dons> geezusfreeek: that's negligent for someone teaching programming languages
14:13:06 <Toxaris> Jedai: maybe they should
14:13:17 <geezusfreeek> dons: i know. it really ticked me off when she said that
14:13:28 <geezusfreeek> dons: she doesn't like me anymore
14:13:30 <Jedai> Toxaris: Yes, which is why I understand that practical courses could ask to only use some features of the language, but for homework assignment, where only the teacher has to correct the assignment, there's not really excuses to restrict the features to use
14:13:36 <Lord_Illidan> Simply because we never do practical assignments like we do in other languages
14:13:47 <dons> imagine a whole science built on a theoretical foundation -- that everyone ignores.
14:14:00 <geezusfreeek> Lord_Illidan: that seems a problem with the class then, not with the language
14:14:06 <Lord_Illidan> Could be, yes
14:14:09 <geezusfreeek> dons: i don't have to imagine
14:14:15 <Lord_Illidan> but that gives me a bad impression
14:14:27 <dons> here's a nice programming languages course, fwiw, http://cgi.cse.unsw.edu.au/~cs3161/lectures.php
14:14:28 <lambdabot> Title: Lectures : COMP3161/9161 Concepts of Progamming Languages 2007/S2
14:14:35 <Lord_Illidan> I mean, this program for instance.. yes, it is "interesting", but it's not too practical
14:14:36 <sauxdado> dons: you mean CS? :)
14:14:37 <dons> you write compilers, interpreters , type checkers, do proofs
14:14:52 <dons> and end up understanding the foundations for all programming languages, at a deep level
14:15:12 <geezusfreeek> Lord_Illidan: a few people in here actually use haskell at their jobs
14:15:21 <geezusfreeek> outside of academia, even
14:15:24 <dons> Lord_Illidan: heh.
14:15:36 <geezusfreeek> i wish i was one of them
14:15:41 <Lord_Illidan> geezusfreeek, I know, haskell does have practical applications
14:15:46 <Lord_Illidan> and I do like the language
14:15:58 <Jedai> Lord_Illidan: Did you see xmonad ? How is that not practical ?
14:16:00 <dons> its just a programming language, after all. you use it to do programming.
14:16:04 <Lord_Illidan> but some of it's syntax is just plain confusing :S
14:16:08 <dons> ah syntax.
14:16:25 <geezusfreeek> Lord_Illidan: i don't see the syntax as confusing. just not like C
14:16:36 <Lord_Illidan> what, I'm an idiot because I can't understand the syntax? Maybe...
14:16:46 <Toxaris> Lord_Illidan: haskell has mainstream syntax. have you ever looked at programs which feature crazy syntax, like lisp or beta?
14:16:49 <geezusfreeek> Lord_Illidan: no, you are just used to imperative languages
14:17:00 <Lord_Illidan> geezusfreeek, that's true.. java has influenced me a lot
14:17:02 <Jedai> Lord_Illidan: Well it's true that it's not a language of the Algol family... But that's all there is to it, try Smalltalk for an imperative language with very different syntax
14:17:16 <dons> still, people seem to get by with sh, sed, awk, perl, python, C, java all having different syntax
14:17:21 <dons> so clearly its not a big deal.
14:17:31 <dons> and every damn config file has different syntax. we survive.
14:18:04 <Jedai> dons: Perl, C and Java at least have very similar syntaxes though, all derives from an Algol root
14:18:04 <Toxaris> dons: I don't. (I do survive, but I refuse to use sh, sed, awk, perl, python, C, java or config files)
14:18:10 <Lord_Illidan> well, dons, config files don't have that dissimilar syntax
14:18:28 <Lord_Illidan> C and Java have similar syntax, as does python in some ways
14:18:40 <Lord_Illidan> I don't use Perl, so I can't comment
14:18:48 <MyCatVerbs> dons: except in the case of sendmail.cf, in which case we survive right up to the point where it all becomes too much and we feel compelled to find a clocktower.
14:18:54 <Jedai> Lord_Illidan: Oh yes, maybe not the .ini but try apache config and tell me it's not different...
14:19:04 <Lord_Illidan> I never used Apache :S
14:19:07 <Toxaris> dons: ok, sometimes I'm forced to use java :) but otherwise, if there is no gui for it, i don't use it. what's the point with learning whole formal languages for small applications I don't intend to use regulary?
14:19:20 <Lord_Illidan> Not that I edit config files that much, that is
14:19:42 <Lord_Illidan> On Linux the only config files I edit with some regularity are /etc/rc.conf (Arch Linux user here), and /etc/X11/xorg.conf
14:20:15 <Toxaris> I'm quite sure syntax matters a lot, and should be much more thought about.
14:20:16 <Jedai> Lord_Illidan: I think you don't, as soon as you need something better than key-value, you diverge violently between config format
14:20:40 <pjd_> Lord_Illidan: Haskell syntax is a model of simplicity compared to Perl syntax
14:21:07 <dons> humans seem surprisingly able to soak up bizarre notational rules
14:21:39 <Kamina> Hi
14:21:39 <Jedai> pjd_: But Perl syntax looks a lot like C (and some shells), so programmers with imperative experience don't find it so weird
14:22:19 <dons> ${@x{$y}->[2]}
14:22:23 <dons> ain't no C.
14:22:26 <Jedai> Very different imperative syntax : Forth, Smalltalk, Cobol....
14:22:39 <pjd_> dons: the brain is a language engine
14:22:51 <Lord_Illidan> pjd_, I can't understand your lambda_expression at all.
14:22:54 <dons> pjd_: exactly. syntax is want we're built for.
14:22:54 <mauke> dons: that doesn't look valid
14:23:05 <Jedai> dons: Except sigils :-)
14:23:09 <dons> mauke: are you sure? :)
14:23:11 <Lord_Illidan> Sorry if I am taking up your time
14:23:18 <mauke> dons: it's morally wrong, at least
14:23:21 <pjd_> Lord_Illidan: no problem
14:23:28 <Jedai> mauke: Yes it is
14:23:30 <mauke> did you mean ${$x{$y}[2]}?
14:23:41 <Jedai> wrong morally I mean
14:23:51 <Jedai> but it will work though
14:23:55 <dons> i'm sure its morally wrong. perl is morally wrong a priori :)
14:24:08 <pjd_> Lord_Illidan: basically, the rule is that every (let foo = bar in baz) becomes ((\foo -> baz) bar)
14:24:10 <geezusfreeek> perl doesn't even parse!
14:24:10 <Toxaris> Lord_Illidan: try to convert one of the let expression to a lambda expression and let the other as let.
14:24:27 <Lord_Illidan> pjd_, oh
14:24:31 <Jedai> dons: Nope, Haskell is the closer language I've even found to Perl (my former love)
14:24:50 <Jedai> dons: But more from a philosophical standpoint...
14:24:54 <thoughtp1lice> Lord_Illidan: weird syntax and not seeing lots of applications written in it may leave you with a bad taste initially, and it's understandable. the benefit is that you walk away with a lot more insight on languages (especially so if you have been heavily influenced by java :> )
14:25:05 <Toxaris> in haskell you sometimes write stuff like css@(~(c:cs))
14:25:15 <mauke> I've written map/grep pipelines in perl before hearing about functional programming :-)
14:25:41 <thoughtp1lice> and specifically you should walk away with a change in your thought process when programming. i may not ever write haskell for a job, but it has definitely taught me a few things I can carry one
14:25:41 <Lord_Illidan> pjd_, I've converted it to where notation, and I quite like it that way
14:25:48 <Jedai> mauke: You too ! ;)
14:25:52 <Lord_Illidan> thoughtp1lice, that's true
14:25:58 <pjd_> Lord_Illidan: yeah, that's probably most natural for this
14:26:08 <thoughtp1lice> s/one/on/
14:26:09 <Lord_Illidan> I've tried to think more in terms of functions when I program in Java now
14:26:27 <sauxdado> Lord_Illidan: don't you feel like killing yourself every time you want map?
14:26:37 <pjd_> Lord_Illidan: what you have is basically a manual expansion of the State monad, though :)
14:26:42 <Jedai> Lord_Illidan: And realized how badly Java needs closures ?
14:27:02 <Lord_Illidan> Actually, haven't done enough java, nor haskell to feel like killing myself :D
14:27:17 <Kamina> Java has closures using inner classes, hasn't it?
14:27:32 <Toxaris> Kamina: yes, but they are very syntax-heavy
14:27:40 <Kamina> yes i agree
14:27:44 <Jedai> Kamina: Right (I'll go enucleate myself right now...)
14:27:59 <pjd_> also, they're only partial closures (over final variables)
14:28:03 <Lord_Illidan> pjd_, what do you think of this : http://hpaste.org/7334#a2
14:28:11 <Lord_Illidan> what are closures?
14:28:25 <pjd_> Lord_Illidan: lambda expressions, more or less :)
14:28:34 <pjd_> first-class functions
14:28:39 <Lord_Illidan> oh
14:29:26 <pjd_> the term "closures" is usually used more in the context of imperative languages
14:29:40 <Lord_Illidan> is this like a closure : 3.times {puts "Inside the times method."}
14:29:51 <Lord_Illidan> I'm reading this one : http://notes-on-haskell.blogspot.com/2007/02/whats-wrong-with-for-loop.html
14:29:52 <lambdabot> Title: Notes on Haskell: What's Wrong with the For Loop, http://tinyurl.com/yog2dg
14:30:14 <qwr> Lord_Illidan: closure is basically a capture of expressions environment
14:30:31 <pjd_> Lord_Illidan: more or less (but Ruby has some funny rules about blocks versus procs and so on)
14:30:42 <thoughtp1lice> Lord_Illidan: some of the things that haskell have taught me are 1.) the greatness that is purity and 2.) strong, expressive types rock and keep the bugs away
14:30:42 <thoughtp1lice> i'm sure i'm forgetting things, as well
14:31:06 <pjd_> the importance of being non-strict
14:31:32 <sauxdado> haskell taught me to stop worrying and love the warm, fuzzy things!
14:31:49 <Toxaris> Haskell has thought me that you want to have as strong abstraction mechanisms as possible
14:31:52 <Kamina> I have some problems related with "inheritance" in haskell
14:32:20 <Toxaris> e.g. you want to express the idea of monad in a way which allows instance Monad Set -- oups. :)
14:32:26 <Kamina> perhaps someone can give me a hint how to "elegantly" solve some things?
14:32:35 <Toxaris> Kamina: there is no inheritance in haskell
14:32:43 <qwr> Lord_Illidan: the {puts "Inside... "} may be closure because of puts reference
14:32:45 <Toxaris> Kamina: what things to you want to solve?
14:32:58 <pjd_> type classes can inherit default implementations
14:33:02 <Kamina> Toxaris: but there are classes to group properties of types, and to provide polymorphic functions on them
14:33:26 <sauxdado> Lord_Illidan: it is called "closure" because it "encloses" all the variable bindings
14:33:37 <Lord_Illidan> I see..
14:33:39 <sauxdado> of the parent environment
14:33:50 <pjd_> alternatively, it's called a closure because its open bindings are closed by the environment
14:34:18 <Kamina> Toxaris: I would like to have different datatype(constructor)s, sharing a property.. and having a common (polymorphic) "accessor" and "update" function for it
14:34:32 <sauxdado> a closure doesn't have to be an anonymous function, it can be a regular function
14:34:51 <geezusfreeek> Lord_Illidan: just so you can see, i have annotated your paste with a State monad version
14:35:00 <sauxdado> (together with bindings at its creation)
14:35:15 <geezusfreeek> it's dense, but if you pick it apart you may find it easier to follow
14:35:35 <Toxaris> Kamina: yes
14:35:47 <thoughtp1lice> Lord_Illidan: a closure is a function + environment. for example, with some sort of psuedo-syntax: func f() { a = "hi"; g = func g() { print a; }; return g; } we return the bar function and it's paired with the 'a' variable from the outer scope
14:35:47 <thoughtp1lice> but more or less yeah, they are higher order functions
14:36:28 <Lord_Illidan> I must say, thanks for all of this help..I never encountered such a helpful channel, I sincerely hope I'm not wasting anybody's time here
14:36:30 <dmwit> Kamina: If it's really multiple constructors, then use a record type.  If it's actually multiple data types, use type classes.
14:36:40 <Kamina> Toxaris: I thought something like that could work: http://hpaste.org/7336
14:37:01 <geezusfreeek> Lord_Illidan: most of us in here are very passionate about this stuff. it is our pleasure
14:37:19 <sauxdado> because we never have sex
14:37:26 <geezusfreeek> sauxdado: exactly
14:37:27 <Lord_Illidan> You're not alone there
14:37:34 <Toxaris> Kamina: general idea is ok, but you cannot deriver user-defined classes
14:37:52 <dmwit> That's one issue.
14:38:07 <Kamina> dmwit: Is a record type something like  Constructor { field_name :: Int, ... } ?
14:38:14 <dmwit> Kamina: Yes.
14:38:23 <dmwit> Kamina: But you can't have multiple data types with the same record name.
14:38:32 <dmwit> Kamina: The record names are in the top-level namespace.
14:38:33 <Kamina> dmwit: But if i have several constructors, each want to have their own "accessor"-method
14:38:52 <Kamina> dmwit: yes, i know ,that's why i ask how to solve it in an elegant way.. I didn't see any
14:38:53 <Toxaris> Kamina: http://hpaste.org/7336#a1
14:39:00 <dmwit> Kamina: Just take out the record.
14:39:15 <Toxaris> Kamina: but depending on the complexity and layout of your real data, there are other solutions
14:39:15 <Kamina> dmwit: What do you mean by taking the record out?
14:39:33 <dmwit> Kamina: See Toxaris' paste, he went and fixed it in the time it took me to try to explain how to fix it. =P
14:40:03 <Kamina> Toxaris,dmrit: moment, let me se and understand
14:41:24 <Kamina> Toxaris: I understand how it works, but this get's a bit messy, if combining let's say 10 different properties...
14:41:34 <Toxaris> http://hpaste.org/7336#a2
14:41:36 <Kamina> and i would also need setters as well
14:41:57 <Kamina> and writing getters and setters is something i would like to get rid of
14:42:09 <Toxaris> I think there are tools for this stuff
14:42:27 <Toxaris> keyword "functional references"
14:42:31 <Lord_Illidan> thanks all, I have to run!
14:42:47 <Toxaris> but I never used them or remember their name or whatever
14:43:06 <dmwit> Kamina: http://hpaste.org/7336#a3
14:43:12 <dmwit> Perhaps you will like that way better.
14:43:14 <sclv_> Kamia: what's the more general problem?
14:43:17 <dmwit> No type classes at all.
14:43:17 <Kamina> Toxaris: the second way looks better, though still a bit clumsy
14:44:10 <Jedai> Functional references are probably the way to go (we have library for that in hackage, yes ?)
14:44:12 <dmwit> How do you feel about the third way?
14:44:26 <dmwit> It's very simple, and it doesn't require functional references.
14:44:30 <Kamina> moment, i need some time to process :-)
14:44:51 <sclv_> Well, the question first is why you need all this polymorphism -- depending on the data domain it might not even be at issue...
14:45:00 <Toxaris> dmwit: but it's typing is "more dynamic" then the other ways
14:45:05 <dmwit> yes
14:45:18 <Kamina> the 3rd way forces me to combine types sharing just one thing, to be the same type... i could end up with one type for everything
14:45:20 <Toxaris> dmwit: which may be a good thing depending on the use case of course
14:45:34 <Kamina> so
14:45:40 <Kamina> what are those functional references exactly?
14:45:43 <sclv_> if yr. writing a self-contained system rather than one that you expect others to extend with new records, thinking in terms of getters and setters might be overdoing it as a whole...
14:46:08 <sclv_> frefs still don't solve the namespace overloading issue, actually...
14:47:10 <Kamina> I thought about this, when thinking on having a data type for elements in a HTML page
14:47:13 <sclv_> maybe i'm just doing different sorts of things, but generally I've found that if I want to change something's color, for example, I already know what it is and can deconstruct it directly...
14:47:51 <Kamina> it would be not good, if i have just one single type for any kind of HTML element
14:47:54 <Kamina> but
14:48:00 <Toxaris> Kamina: functional references are a nice encoding of setters and getters, together with a kind of preprocessor to help you with writing all those instances needed for the typeclass approach, as i understand it
14:48:01 <Kamina> i would like to have generic ways to access some of the elements properties
14:48:57 <Kamina> and all three ways i've seen right now have drawbacks
14:49:22 <sclv_> if you're representing an html dom, something looser might actually make more sense -- data Div [Prop]; data Prop = Color ColorName | Width Int | Height Int etc.
14:49:42 <Toxaris> maybe HLists can help here?
14:49:51 <sclv_> "help"
14:50:31 <dalien> sclv_: assuming that I have several hundreds of flavours of "Prop" - would that scale ok ?
14:50:35 <Kamina> i thought a strict type system could help to avoid errors, and i actually learned to like it in the last days..... I either got compiler complaints... or the program worked fine.... (in most cases)
14:51:16 <sclv_> Kamina: look at how Text.HTML does it -- http://www.haskell.org/ghc/docs/latest/html/libraries/html/Text-Html.html
14:51:17 <lambdabot> http://tinyurl.com/2qgf4r
14:51:35 <Jedai> Hmmm... For a HTML, I'm not sure if enumerating all the properties would work (think about the "mozilla-*" specific properties for example)
14:52:02 <sclv_> Kamina: yeah you're right that the more you put in types the more errors you avoid.
14:52:36 <sclv_> but getting strongly typed extensible heterogenous collections is a set of tradeoffs and areas for research in general, so for practical day-to-day stuff its better to start simple and scale up.
14:52:37 <Kamina> sclv_: they use almost only one type, as far as i can overlook it
14:53:06 <Toxaris> Kamina: how do you know statically which nodes have an Color attribute and which not?
14:53:38 <Kamina> Toxaris: any node belonging to the "Colored" class has a color attribute
14:53:51 <Kamina> (the HTML stuff was just the reason why i started thinking about this problem)
14:54:23 <Toxaris> Kamina: and how do you know which node should belong to Colored after having parsed some HTML
14:54:42 <Kamina> so a common attribute of different types of data is something java can handle quite easy.... i was surprised haskell could not do it so easily (or i just didn't see the way yet)
14:55:09 <sclv_> There's also Text.XHTML which uses "smart constructors" to constrain what you can build... http://www.haskell.org/ghc/docs/latest/html/libraries/xhtml/Text-XHtml.html
14:55:10 <lambdabot> http://tinyurl.com/2asj48
14:55:28 <mauke> http://homepages.cwi.nl/~ralf/OOHaskell/ and weep
14:55:32 <Kamina> Toxaris: depending on the kind of node, it has a color or not... (a <script> has no color.. but a <p>aragraph has)
14:55:32 <lambdabot> Title: Haskell's overlooked object system
14:55:48 <Toxaris> Kamina: and how do you know statically wich kind of node it is?
14:55:56 <Kamina> sclv_: even if i constrain the constructors, i would give up type seperation
14:55:58 <Toxaris> Kamina: consider a function parse :: String -> HTMLTree
14:56:18 <sclv_> type seperation?
14:56:24 <Toxaris> Kamina: <p>This paragraph has no color</p> :)
14:56:31 <Lord_Illidan> Sorry to bug you guys again, but one other question, an easy one this time..
14:56:35 <Toxaris> Kamina: but of course this is not important, the problem is there with Haskell
14:56:36 <Kamina> but it has Maybe Color :-P
14:56:37 <Lord_Illidan> in literate programming
14:56:48 <Toxaris> Kamina: every HTML node has Maybe Color
14:56:49 <sclv_> you can do it nicely with typeclasses actually.
14:57:02 <Kamina> Toxaris: no, a <script> should NOT have Maybe Color
14:57:05 <Lord_Illidan> Should the > notation or the \begin{code}..\exit{code} notation be used to denote code?
14:57:11 <Kamina> at least, if you see it strongly typed
14:57:13 <Toxaris> Kamina: hmm ok I see
14:57:22 <Toxaris> Kamina: so generally, you want subtyping :)
14:57:34 <mauke> Lord_Illidan: depends on whether it's intended as plain text or latex
14:57:42 <Lord_Illidan> oh
14:57:49 <sclv_> Class MaybeColor a where setColor :: a -> Color -> a; getColor :: a -> Color
14:57:56 <Kamina> lambdabot: what did you want to say?
14:58:13 <Lord_Illidan> it's actually plain text, I just thought that using that kind of notation would be better
14:58:20 <mauke> > var "I'm just a bot!"
14:58:21 <lambdabot>  I'm just a bot!
14:58:31 <sclv_> instance MaybeColor P where setColor = setProp Color; getColor = getProp Color and etc.
14:58:40 <Saizan> Lord_Illidan: you can still use the latex notation, the compiler will understand your code just fine
14:58:43 <Lord_Illidan> as in surround a large function with \begin{code}..etc, not begin every line with >
14:58:49 <Kamina> oh :-)
14:59:13 <sclv_> you have to declare the instances manually, but that's not too bad...
14:59:26 <Lord_Illidan> Saizan, and I can't intermix?
14:59:27 <Jedai> Lord_Illidan: Good editors would put an "> " automatically as long you don't delete it
14:59:57 <Toxaris> sclv_: how handles MaybeColor's getColor the case of no color?
14:59:59 <Lord_Illidan> Good editors, suggest 1? I am using Geany, it's not bad, but I don't think it caters well to the haskell language
15:00:01 <Saizan> Lord_Illidan: i don't think you can but i've never tried
15:00:05 <Kamina> sclv_: how does "setProp" and "getProp" work?
15:00:08 <Lord_Illidan> I don't think I can
15:00:14 <Lord_Illidan> I have the first line of code
15:00:18 <Lord_Illidan> >import Logo
15:00:29 <Lord_Illidan> and from then on using \begin {code} .. etc
15:00:29 <Jedai> Kamina: With Template Haskell and some convention you can automatically generate the instances
15:00:45 <sclv_> getProp and setProp would look for something with the color constructor in your list of properties.
15:00:49 <Lord_Illidan> It was giving me a parse error, and when I changed import Logo to use the same Latex syntax, it worked
15:00:51 <Kamina> Jedai: Template Haskell is a glasgow extension?
15:00:52 <Saizan> you need a space after >, iirc
15:00:53 <Lord_Illidan> not a big deal
15:00:56 <Jedai> Lord_Illidan: emacs or vim
15:01:02 <Jedai> Kamina: Yes
15:01:14 <sclv_> maybe it would need to be written slightly differently -- but that's the general idea.
15:01:28 <Kamina> sclv_,Jedai: the getProp/setProp thing and the Template stuff are two different things?
15:01:36 <sclv_> well, they could work together...
15:01:50 <sclv_> the template stuff could make your instances easier to write.
15:01:53 <sclv_> by automating it.
15:02:00 <Lord_Illidan> Jedai, I'll try vim, never tried emacs
15:02:19 <Jedai> Kamina: Yes, they're different thing, Template Haskell is kind of a super preprocessor which would generate the getProp/setProp instance for you at compile time
15:02:29 <Lord_Illidan> Saizan, no it still doesn't work
15:02:33 <sclv_> anyway -- gotta run. good luck and cheers!
15:02:37 <Jedai> Lord_Illidan: haskell_mode for emacs is very good
15:02:40 <Kamina> Jedai: ah okay... but getProp/setProp are in the standard prelude?
15:02:53 <cjb> Jedai: it's written by the current emacs maintainer, which is a good sign :)
15:02:58 <Jedai> Kamina: No ? Why should they ?
15:03:06 <Toxaris> sclv: I would propose: class HasColor c where updateColor :: (Maybe Color -> Maybe Color) -> c -> c, getColor :: c -> Maybe Color
15:03:35 <Lord_Illidan> It appears that I actually shouldn't mix the two styles, no problem
15:03:39 <Lord_Illidan> thanks all
15:03:47 <Jedai> Kamina: getProp/setProp would just be part of a typeclass
15:04:14 <Randroid> Is there a predefined function that will turn [m [a], m [a]] into m [a]? (I could easily write one, of course.)
15:04:22 <Kamina> sclv_,Jedai: i still didn't understand what 'getProp' and 'setProp' actually are... functions i have to implement myself?
15:04:48 <Jedai> Kamina: functions in a typeclass you define yourself
15:04:59 <quicksilver> Randroid: if you mean [m [a]]
15:05:05 <dons> :t sequence
15:05:07 <mauke> Randroid: do you mean [(m [a], m [a])]?
15:05:07 <quicksilver> Randroid: then sequence gets you m [[a]]
15:05:07 <Kamina> Jedai: with a type as first argument?
15:05:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:05:08 <Randroid> Yeah, that's what I meant.
15:05:09 <byorgey> Randroid: liftM concat . sequence ?
15:05:16 <quicksilver> Randroid: and then fmap concat
15:05:20 <quicksilver> gets you m [a]
15:05:22 <Randroid> I mean [m [a]], sorry
15:05:28 <Jedai> Kamina: And then you write a small bit of Template Haskell to automatically generate instance of this typeclass
15:05:38 <mauke> :t join . sequence
15:05:40 <lambdabot> forall a. [[a]] -> [a]
15:05:43 <dons> :t concat `fmap` sequence
15:05:45 <lambdabot> forall a. [[a]] -> [a]
15:05:48 <Kamina> sclv_/Jedai: would it be complicated if you could show me an actual example of that?
15:05:58 <byorgey> Randroid: well, at any rate, there isn't a single function in the standard libraries to do that =)
15:06:12 <Randroid> No problem. I can make it happen. Thanks for the pointers!
15:06:14 <mauke> :t (.) join `fmap` sequence
15:06:16 <lambdabot> forall a (m :: * -> *). (Monad m, Functor m) => [m [a]] -> m [a]
15:06:22 <Randroid> Aha!
15:06:32 <mauke> sorry for the silliness
15:06:49 <dons> these little monad puzzles seem like something we could automate
15:07:05 <dons> ?djinn m (m a) -> m a
15:07:05 <lambdabot> -- f cannot be realized.
15:07:09 <byorgey> dons: hm, that's a cool idea.
15:07:22 <sauxdado> teach djinn the monad laws?
15:07:32 <dons> just a constraint solving exercise, with the known Control.Monad stuff, some rules,and some Prelude things
15:07:35 <Heffalump> I don't think it can be taught type constructors very easily.
15:08:26 <ddarius> It's a simple matter of automatic theorem proving.
15:08:27 <byorgey> nah, don't extend djinn, the idea would be to output a pointfree expression with the given type
15:09:00 <dons> yeah, not vim.
15:09:02 <dons> djinn.
15:09:16 <dons> a @pl-ish thing. rules, and types.
15:09:34 <Heffalump> ddarius: djinn uses a decision procedure, once you start going beyond what that can handle things become a bit more unreliable
15:10:07 <ddarius> I was being facetious.
15:10:12 <Toxaris> why constraint solving? isn't that more like searching?
15:11:25 <Heffalump> ddarius: ah, fair enough. I'd expect most of the actual problems to be fine with a standard tactics-based prover, so I thought you meant that it would be easy.
15:11:37 <Kamina> Jedai: if i define "getProp Color" myself, wouldn't i need an own definition for each type having that color poperty?
15:11:53 <Jedai> Kamina: Yes
15:11:54 <Kamina> as each type needs a different way to "extract" the color of it
15:12:02 <ddarius> Heffalump: Tactics are manually applied.
15:12:07 <Kamina> Jedai: would you agree, that this is very ugly?
15:12:22 <Jedai> Kamina: Which why I spoke of Template Haskell, which could automate this
15:12:32 <ddarius> Heffalump: Or do you mean something like search the space of Coq proof scripts?
15:13:22 <Toxaris> Kamina: what's the solution you have in mind for java? interface Colored {Color getColor()}?
15:13:28 <Kamina> Jedai: okay, i will take a look at how Template Haskell works.... but reminds me a bit of "eval" in other languages.. not sure if it's clean.. but i don't know it yet...
15:13:43 <Heffalump> ddarius: the latter, but just using the standard automatic tactics.
15:13:44 <MyCatVerbs> @pl get >>= \a -> return (bar,a)
15:13:44 <lambdabot> (,) bar `fmap` get
15:13:58 <Heffalump> It's ages since I really played with theorem provers, though, so I might be talking rubbish.
15:14:02 <Jedai> Kamina: No, it generates the code at compile-time, the compiler will complain if it generate badly typed code
15:14:11 <Kamina> Toxaris: perhaps i would need to write my own accessor method for each class as well... but in Java i'm used to write useless getters/setters ;-)
15:14:24 <Kamina> Jedai: okay...
15:14:46 <Toxaris> Kamina: exactly my point. so this is not a task Haskell doing worse then Java, but a task Haskell doing not better then Java
15:15:07 <Jedai> Toxaris: But Haskell should do it better than Java !! ^^
15:15:16 <Toxaris> Jedai: I agree.
15:15:23 <Kamina> Toxaris: unless you can use normal inheritance with classes, instead of needing interfaces!
15:15:54 <Toxaris> Kamina: but in general you can't because you're rules for which classes have which attribute are to complicated to do so
15:15:55 <Kamina> Toxaris: when every colored type has the same parent class, it's far more easy in java
15:16:10 <hellige> kamina: try it in scala
15:16:11 <Kamina> Toxaris: yes, i agree
15:16:14 <hellige> :)
15:16:25 <Toxaris> hellige: yes traits are cool!
15:16:28 <Kamina> hellige: is scala better in this aspect?
15:16:45 <Toxaris> Kamina: Scala is better then java in every aspect except production quality
15:17:02 <Jedai> Kamina: I think Traits are more or less what you need here
15:17:06 <hellige> oh, production quality of scala is pretty high. the compiler has some bugs, but the generated code is good.
15:17:12 <Toxaris> and scala is better as Haskell in some aspects
15:17:23 <Jedai> Where are we on the improvement of records in Haskell ?
15:17:26 <Toxaris> hellige: the language is not stable.
15:17:28 <hellige> kamina: scala is better for this, maybe, yes. traits are custom-designed for exactly this kind of scenario
15:17:44 <hellige> Toxaris: at a language-design level, that's definitely true.
15:17:55 <Toxaris> hellige: yeah that's what I meant.
15:17:55 <Kamina> But is scala purely function?
15:18:00 <hellige> Kamina: no
15:18:03 <Kamina> i liked the purely functional style of Haskell
15:18:03 <Jedai> Kamina: No
15:18:07 <hellige> so do we. :)
15:18:18 <hellige> i think of scala as a very conservative improvement to java.
15:18:19 <Kamina> I would like to have a better way of "inheritance" in Haskell :/
15:18:35 <Toxaris> Kamina: scala is not purely functional, but it's expressive enough to write purely functional programs in
15:18:52 <slava> you can wrte purely functional code in any language
15:18:57 <Jedai> Well I hope one of the "records improvement" proposition will win and be good enough for all of us
15:18:59 <hellige> scala would allow you do solve your example much better than java or haskell
15:19:07 <hellige> you can do something like:
15:19:14 <Toxaris> slava: X86 assembler
15:19:17 <slava> sure
15:19:20 <hellige> trait Colored { var color: String }
15:19:28 <hellige> class Element { ...}
15:19:31 <hellige> and then say things like:
15:19:38 <Toxaris> slava: show me how to write addition without changing an register
15:19:42 <hellige> class P extends Element with Colored
15:20:00 <hellige> which allows you to be very precise about which properties each element has.
15:20:10 <hellige> and of course it's all statically typed.
15:20:20 <hellige> i would say this is where the OO style shines, but only with modern features.
15:20:22 <Kamina> yes, i see
15:20:24 <slava> Toxaris: are you saying haskell is not purely functional because at the end of the day it compiles to assembler?
15:20:52 <Toxaris> slava: yes.
15:20:58 <Jedai> slava: No, he is saying that you can't write a purely functional program in asm
15:21:14 <Kamina> but... can someone tell me if there would be any problem in allowing the thing i did in my first approach ( http://hpaste.org/7336 )?
15:21:15 <pjd_> slava: i think he's saying that assembly isn't purely functional even when it corresponds to (is generated from) purely functional code
15:22:30 <Toxaris> slava: Haskell is purely functional, but compiled to Assembler is Haskell + a magic IO interpreter :)
15:22:36 <Jedai> Toxaris: I disagree, theoritically, there's no reason for Haskell to be compiled to one asm or the other, you could write a purely functional asm for a machine created for it, hence the fact that Haskell is currently compiled to a non-functional language don't affect the purely functional value of Haskell
15:23:00 <pjd_> hmm, purely functional hardware...
15:23:04 <Toxaris> Jedai: define "purely functional"
15:23:13 <hellige> Kamina: sure. you have two different definitions of "color"
15:23:35 <hellige> one of them has type Cube -> Color, and the other has type Car -> Color
15:23:40 <Jedai> Toxaris: Refer to ... article (and let me a little time to find this paper again... ;) )
15:23:44 <hellige> how can you distinguish them?
15:23:58 <vixey> CubeColor :: Color
15:24:01 <vixey> CarColor :: Color
15:24:12 <vixey> case/pattern match it ?
15:24:12 <Kamina> hellige: yes, but i would like haskel to not try to make a NEW function, but to provide a type specific function definition for the (existing) polymorphic function
15:24:39 <mauke> only with typeclasses
15:24:50 <Toxaris> mauke: there is a typeclass in Kamina's first approach
15:24:52 <hellige> Kamina: oh yes, i see what you mean.
15:24:58 <hellige> sorry i missed the type-class.
15:25:14 <Kamina> but when using type-classes
15:25:16 <hellige> well, iirc there are a few proposals for allowing extensible "deriving"
15:25:25 <hellige> one of them may be very close to what you want
15:25:29 <Kamina> i lose the ability to use the { ... } syntax for updating/extracting the color later
15:25:43 <sclv> I don't have time now, but I'll try to write up a blog post tomorrow with two simple and clean ways to do this now.
15:25:52 <Jedai> hellige: Yes, that is why I proposed Template Haskell
15:25:57 <Kamina> and i end up with needing getters and setters.. which do all the same, but need to be there for every type
15:26:17 <sclv> hint: you can use default methods in yr. typeclass.
15:26:23 <hellige> Kamina: yeah, i understand. i have nothing new to suggest. seems like others have covered the bases.
15:26:31 <joey> > (do return 1) :: Maybe Int
15:26:31 <lambdabot>  Just 1
15:26:34 <hellige> which is why i suggested scala. ;)
15:26:35 <Jedai> Kamina: using Template Haskell you can do it, there might even already be some similar code around
15:26:37 <Kamina> sclv: related to the inheritance problem you mean?
15:26:46 <vixey> > return 1 :: Maybe Int
15:26:47 <lambdabot>  Just 1
15:27:16 <vixey> > Nothing >>= x -> x
15:27:16 <lambdabot>  Parse error at "->" (column 15)
15:27:22 <vixey> > Nothing >>= \ x -> x
15:27:23 <lambdabot>  Nothing
15:27:24 <mauke> *> 1 :: Maybe Int
15:27:25 <mauke> Just 1
15:27:26 <vixey> > Just 1 >>= \ x -> x
15:27:27 <lambdabot>   add an instance declaration for (Num (Maybe b))
15:27:39 <sclv> class HasProps a where getProp :: PropType p -> a -> p; setProp = etc.
15:27:40 <vixey> > (Just 1) >>= \ x -> Just x
15:27:41 <lambdabot>  Just 1
15:27:45 <joey> > return 1
15:27:45 <lambdabot>   add an instance declaration for (Show (m t))
15:27:51 <Kamina> Jedai: so, i will take a look at template haskell for sure, but i would expect such an important thing being part of the language itself, and not available through meta-programming
15:27:55 <vixey> Nothing >>= f = f Nothing
15:27:59 <pjd_> > return :: a -> Maybe a
15:27:59 <vixey> Just x >>= f = f x
15:28:00 <lambdabot>  Add a type signature
15:28:07 <vixey> return = Just
15:28:08 <Jedai> Kamina: We don't like inheritance in Haskell, if there is a solution in the future it would more probably be a structural subtyping one (records extensions)
15:28:15 <joey> Hmm, GHCi doesn't have any problem with simply "return 1"
15:28:30 <joey> How does it determine which instance of Monad to use?
15:28:33 <vixey> > return 1 :: [] Integer
15:28:34 <sclv> class (HasProps a) => HasColor a where getColor :: a -> Color; getColor = getProp Color.
15:28:34 <lambdabot>  [1]
15:28:38 <mauke> I think ghci defaults to IO
15:28:39 <vixey> > return 1 :: IO
15:28:40 <lambdabot>      `IO' is not applied to enough type arguments
15:28:40 <lambdabot>     Expected kind `?', but ...
15:28:42 <joey> Ah.
15:28:45 <sclv> then to give anything a color it just needs a bare instance def.
15:29:06 <mauke> joey: try 'getLine'
15:29:08 <sclv> its not exactly right, but i'll try to cook it together -- there's also a neat way to do this with generics.
15:29:22 <Kamina> sclv: and can you explain me, what's getProp/setProp exactly? i still didn't understand it
15:29:39 <Kamina> sclv: can you tell me, where you will post it, if you are going to write it?
15:29:45 <Toxaris> joey: ghci tries to run your input as an IO action
15:29:47 <byorgey> mauke: 1 :: Maybe Int ?
15:29:57 <mauke> byorgey: yes?
15:30:03 <Kamina> Jedai: what are record extensions?
15:30:05 <sclv> getProp and setProp are methods of the HasProp class, and they have to be created for each instance. but once you do that all your other instance declarations will be very simple.
15:30:05 <joey> I see, Toxaris
15:30:09 <vixey> instance Num a => Num (Maybe a) where ?
15:30:10 <Toxaris> joey: note that ghci prints just 1 in reaction to return 1, without any data constructor
15:30:25 <mauke> instance (Num a, Applicative f, Eq (f a), Show (f a)) => Num (f a)
15:30:29 <sclv> Kamina: fmapfixreturn.blogspot.com -- sometime tomorrow, definitely by Sun. it'll be fun to write up.
15:30:33 <vixey> hmmmmmm
15:30:44 <vixey> mauke where?
15:30:46 <joey> > return 1 :: Writer Int Int
15:30:46 <lambdabot>        add an instance declaration for (Show (Writer Int Int))
15:30:52 <byorgey> mauke: cool, figured it was something like that =)
15:30:53 <Jedai> Kamina: They're only propositions for now, the problem being no one agree as to which one is the best though there is a general consensus is would be nice
15:31:03 <mauke> vixey: http://mauke.ath.cx/stuff/haskell/fun.hs
15:31:04 <Kamina> sclv: i think i have a vague idea, what you are going to do.... you mean each type has to implement a property getter/setter method.. and then you can use it for any "property"... colors.. sizes... etc..., right ?
15:31:17 <Jedai> Kamina: Most introduce first-class label and structural subtyping for records
15:31:18 <sclv> yeah -- pretty much.
15:31:31 <vixey> oh I see
15:31:32 <vixey> cool
15:31:33 <shachaf> joey: What Writer writes has to be a Monoid.
15:31:35 <shachaf> > runWriter (return 1 :: Writer [Int] Int)
15:31:37 <lambdabot>  (1,[])
15:31:55 <Jedai> sclv: Will you use HList, it seems to me it could be all automatic with HList, no ?
15:31:58 <sclv> the generics way is cool too. its totally different.
15:32:03 <Kamina> Jedai: are those record extensions something like the thing sclv proposed?
15:32:22 <Kamina> what is the generics way?
15:32:23 <sclv> what i'm proposing is a way to do it now -- the record extensions are new things.
15:32:42 <Kamina> but wouldn't it nice to have a "general" way to have "properties"?
15:32:44 <sclv> Jedai -- yeah, hlist gets you all this for free already too, but then you have to use hlist :-(
15:32:44 <Kamina> i mean
15:32:50 <Kamina> i could implement the getProp/setProp stuff
15:32:50 <Kamina> and
15:32:55 <Kamina> some other guy developing another library
15:33:01 <Jedai> Kamina: Not really, what sclv propose already exists, the record extensions would make it simpler (to understand) give it a better synthax and make it more efficient
15:33:01 <Kamina> will implement his/her own getProp/setProp
15:33:20 <sclv> (actually I think with record type punning you can maybe get a simpler proposal close to yr initial implimentation too)
15:33:21 <Kamina> and both systems would be incompatible
15:34:07 <sclv> the generics way would let you extract something of type Color from any class that has it, and inject it into any class you can inject it into.
15:34:11 <Jedai> Kamina: Yeah, it would be nice to have a general way (hence the record extensions), one "standard" way actually is to use HList which is seriously cool
15:34:22 <sclv> hlist is *not* standard.
15:34:24 <Kamina> sclv: http://fmapfixreturn.blogspot.com/  says it's not existent
15:34:33 <sclv> erm, sorry fmapfixreturn.wordpress.com
15:34:48 <Kamina> sclv: and the generics way is already existent/standard?
15:34:54 <Japsu> > let n `inBase` m = reverse . map snd . tail . takeWhile ((/= (0,0))) $ iterate ((`divMod` m) . fst) (n,0) in 39872619872394 `inBase` 256
15:34:55 <lambdabot>  [36,67,145,88,0,138]
15:34:57 <Jedai> Kamina: (do all you asked for using the actual Haskell) but it's slow and give not nice error messages and ...
15:35:02 <SamB> sclv: generics seem rather broken WRT abstract datatypes...
15:35:04 <sclv> the issue with the generics way is at compile time you actually wouldn't have a guarantee that the class would have a color property.
15:35:13 <sclv> SamB: how do you mean?
15:35:25 <sclv> Kamina: yeah, the generics library comes with ghc-libs
15:35:32 <sclv> extended libs that is.
15:35:34 <Kamina> sclv: you mean i can't do type checking at compile time?
15:35:36 <Jedai> sclv: Yeah HList is "standard" (with quotes) to do structural subtyping in Haskell, but not standard (without quotes)
15:35:47 <mauke> nice hostname :-)
15:35:48 <sclv> not with the generics way -- with the other way, yes.
15:35:53 <SamB> sclv: well, have you ever tried to use them to serialize/unserialize a Data.Map.Map?
15:35:54 <Japsu> > zipWith (iterate (256*) 1) (reverse [36,67,145,88,0,138])
15:35:54 <lambdabot>  Couldn't match expected type `a -> b -> c'
15:36:16 <Kamina> what happens if i write something like "last [1..]" in this channel?
15:36:20 <sclv> SamB: no, but it seems easy?
15:36:23 <Japsu> > sum $ zipWith (*) (iterate (256*) [1]) (reverse [36,67,145,88,0,138])
15:36:23 <lambdabot>   add an instance declaration for (Num [t])
15:36:26 <mauke> > last [1..]
15:36:27 <Jedai> > last [1..]
15:36:27 <pjd_> > last [1..]
15:36:29 <Japsu> > sum $ zipWith (*) (iterate (256*) 1) (reverse [36,67,145,88,0,138])
15:36:31 <lambdabot> Terminated
15:36:33 <lambdabot> Terminated
15:36:34 <lambdabot>  39872619872394
15:36:35 <sclv> wait... yes!
15:36:35 <lambdabot> Terminated
15:36:39 <SamB> sclv: try it and tell me if it still seems easy after you run the program?
15:36:43 <Japsu> works! \o/
15:36:46 <sclv> if by serialize you mean traverse...
15:36:51 <sclv> and transform.
15:36:52 <Kamina> i expected something like  Quit (Segmentation fault)
15:36:54 <shachaf> Kamina: Three people will ask lambdabot to evaluate it for you, it seems.
15:37:00 <shachaf> Kamina: Why?
15:37:02 <SamB> by serialize, I mean write to a file...
15:37:16 <byorgey> Kamina: why would there be a segmentation fault?
15:37:18 <Japsu> @where Data.Binary
15:37:18 <lambdabot> I know nothing about data.binary.
15:37:21 <pjd_> Kamina: it's an infinite loop, actually
15:37:22 <Japsu> @where binary
15:37:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
15:37:22 <vixey> > last [1..]
15:37:27 <lambdabot>  out of memory (requested 1048576 bytes)
15:37:27 <sclv> well, if i can traverse and transform it, then why can't I then write it?
15:37:33 <shachaf> > let x = [1..]; y = length x in last x
15:37:34 <SamB> sclv: well, TRY
15:37:37 <Kamina> i think my computer consumed some memory while being in the look for some reason
15:37:39 <pjd_> lambdabot runs code in a child process, and terminates it after a while
15:37:39 <lambdabot> Terminated
15:37:40 <Kamina> and my mouse freezed
15:37:47 <mauke> it'll run out of memory eventually
15:37:48 <Kamina> but perhaps it's my strange system..
15:37:48 <SamB> sclv: then try to read it back in
15:38:00 <vixey> It's an infinite loop that takes up more and more memory
15:38:08 <sclv> SamB: please. spare me the suspense.
15:38:12 <Kamina> sclv/Jedai: and the HList is what?
15:38:13 <shachaf> > last [1..] :: Int8
15:38:15 <lambdabot>  127
15:38:23 <sclv> ?where HList
15:38:23 <lambdabot> http://homepages.cwi.nl/~ralf/HList
15:38:25 <Jedai> Kamina: A library
15:38:32 <Kamina> part of the standard libraries?
15:38:33 <SamB> sclv: well, last time I tried it looked to be impossible
15:38:38 <byorgey> Kamina: note that lambdabot has special limits on what it will do.  for example, if it takes longer than a certain amount of time to evaluate something, it will just stop.  obviously, your computer has no such limits =)
15:38:39 <Jedai> Kamina: No
15:39:07 <SamB> because there was no support in Data.Generics for constructing data of non-concrete types
15:39:14 <sclv> SamB: can't you just call toList on it first :-)
15:39:33 <SamB> sclv: the idea is to do it with code that doesn't know about Data.Map specifically
15:40:10 <Jedai> SamB: General serialization of Typeable, that is ?
15:40:20 <Kamina> sclv: was your blog address correct?
15:40:20 <SamB> Jedai: of Data
15:40:48 <Saizan> the Data instance of Map is intentially partial to preserve encapsulation, so that may be it?
15:41:04 <SamB> Saizan: ... does that not seem broken to you?
15:41:43 <sclv> Kamina: should be. pasted again from my browser to be sure: http://fmapfixreturn.wordpress.com/
15:41:45 <Saizan> yeah, but i'm not sure what's broken :)
15:42:15 <SamB> Saizan: well, I note that there does not seem to be any option for Data.Map but that at the time being
15:42:21 <SamB> and so fault Data.Generics
15:42:22 <sclv> oh yeah, that's the problem... Data.Map errors out when you try to build it. but that's its fault.
15:42:24 <Kamina> sclv: okay i've saved it in my bookmarks
15:42:58 <sclv> data.map's gunfoldr = err "gunfoldr".
15:43:37 <sclv> that's like calling show broken if I create a class where its show method is show = err "die! die! die!"
15:43:51 <Kamina> so from the page of the HList library it looks like they exactly address my problem?
15:44:08 <Kamina> but not sure, if i understand it right...
15:44:11 <SamB> sclv: well, can you come up with a better thing to put there than that?
15:44:13 <sclv> yeah -- among others. HList is the most "common" solution, but its pretty fancy.
15:44:24 <sclv> SamB: yes.
15:44:29 <sclv> in fact you could just let GHC derive it for you...\
15:44:48 <SamB> sclv: ... you honestly think that would be an improvement?
15:44:56 <sclv> well, it would work :-)
15:44:58 <SamB> what part of "abstract data type" did you fail to understand?
15:45:19 <sclv> the part where its nonsense.
15:45:22 <Kamina> sclv: what do you mean with "fancy"?
15:45:39 <SamB> sclv: but if you did that ... you would be able to see the constructors of Data.Map
15:45:46 <sclv> hlist is complicated and gives complicated type errors and most production code tries to avoid it.
15:46:08 <sclv> SamB: so your issue is... you can't build a data type that doesn't let you see how to build it!?
15:47:15 <SamB> my complaint is that there is no real provision for building data without using constructors...
15:47:36 <vixey> what
15:47:41 <vixey> ?
15:47:49 <vixey> what's wrong with constructors
15:48:11 <SamB> well, you don't want client code to see the binary tree inside the Map, do you?
15:48:20 <vixey> No
15:48:22 <sclv> b...b.b.b.b.ut constructors are how you build data!
15:48:32 <SamB> sclv: not data of abstract datatypes!
15:48:43 <vixey> you don't though
15:48:44 <SamB> sclv: have you ever built a Map using a constructor???
15:49:06 <vixey> I don't understand
15:49:12 <Saizan> there's no way to define gunfoldr in terms of empty and insert?
15:49:36 <sclv> SamB: every time I call "empty" I do!
15:49:40 <SamB> Saizan: I don't know ... but there's no precedent for it
15:49:53 <sclv> ?type gunfoldr
15:49:54 <lambdabot> Not in scope: `gunfoldr'
15:49:57 <Saizan> vixey: we're talking about the Data instance for Map, and more generally that generics doesn't seem to work for abstract data types
15:49:59 <sclv> ?hoogle gunfold
15:49:59 <lambdabot> Data.Generics.Basics.gunfold :: Data a => (c (b -> r) -> c r) -> (r -> c r) -> Constr -> c a
15:50:10 <vixey> generics?
15:50:15 <vixey> ugh I don't know about any of this
15:50:20 <Saizan> Data.Generics
15:50:26 <SamB> @docs Data.Generics
15:50:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics.html
15:50:36 <SamB> face untold horrors!
15:51:08 <vixey> I'm not keen on this stuff
15:51:29 <sclv> SamB: I think you're being silly. anyway its not too hard to special case maps for serialization anyway.
15:51:49 <SamB> sclv: demonstrate
15:52:08 <sclv> ?hoogle ext2
15:52:09 <lambdabot> No matches found
15:53:02 <sclv> ?hoogle ext1
15:53:02 <lambdabot> Data.Generics.Aliases.ext1T :: (Data d, Typeable1 t) => (d -> d) -> (t d -> t d) -> d -> d
15:53:02 <lambdabot> Data.Generics.Aliases.ext1M :: (Monad m, Data d, Typeable1 t) => (d -> m d) -> (t d -> m (t d)) -> d -> m d
15:53:02 <lambdabot> Data.Generics.Aliases.ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (t d -> q) -> d -> q
15:53:07 <sclv> there we go.
15:53:20 <vixey> what is this?
15:53:39 <vixey> > ext1T id id Nothing
15:53:40 <lambdabot>  Add a type signature
15:53:40 <mauke> @hoogle (a,a) -> [a]
15:53:41 <lambdabot> No matches, try a more general search
15:53:57 <ddarius> @src Ix
15:53:58 <lambdabot> class (Ord a) => Ix a where
15:53:58 <lambdabot>     range           :: (a,a) -> [a]
15:53:58 <lambdabot>     index           :: (a,a) -> a -> Int
15:53:58 <lambdabot>     inRange         :: (a,a) -> a -> Bool
15:53:58 <lambdabot>     rangeSize       :: (a,a) -> Int
15:53:59 <Kamina> sclv / Jedai / and all others: thanks for your help so far..... i will think about all that new input, and look at the pages you referenced
15:54:34 <dolio> T is traversal, Q is query.
15:54:46 <dolio> M is monadic traversal, I guess.
15:54:59 <ddarius> A is apple.
15:58:28 <tero-> I have a weird problem with Control.Exception.catch http://hpaste.org/7338
15:59:11 <mauke> I think 'evaluate (x, y)' will never throw
15:59:32 <tero-> hm. why?
15:59:45 <mauke> because (,) is a constructor
15:59:47 * SamB wonders how ⇬ is the key cap for capslock
16:00:18 <mauke> evaluating it gives you a tuple (whose contents may be undefined, but the tuple itself is fine)
16:00:37 <tero-> this laziness hurts my head
16:00:50 <mauke> just don't try to catch exceptions from pure code
16:00:54 <mauke> like read
16:02:41 <tero-> I'd like to write a function which converts strings to ints with a best-effort service, that is, it returns 0 when the string does not contain a valid integer
16:02:54 <tero-> but it should work if I do it without the tuple, right?
16:03:15 <mauke> sloppyRead s = case reads s of [(n, "")] -> n; _ -> 0
16:03:45 <tero-> ah, thanks
16:03:45 <mauke> > let sloppyRead s = case reads s of [(n, "")] -> n; _ -> 0 in sloppyRead "123"
16:03:47 <lambdabot>  123
16:03:50 <mauke> > let sloppyRead s = case reads s of [(n, "")] -> n; _ -> 0 in sloppyRead "123 thousand"
16:03:52 <lambdabot>  0
16:03:57 * SamB suddenly realizes he has an entire row of unbound keys
16:04:06 <mauke> the horror!
16:08:22 <saudado> SamB: the home row?
16:14:38 <Igloo> Is there anyone around with knowledge of x86 assembly who can tell me why the fstsw in http://urchin.earth.li/~ian/trig.txt (code from libm) isn't a fnstsw like the others?
16:16:31 <dons> so fnstsw is "primarily used for branching" but that's weird, since there' sa branch straight after anyway
16:19:01 <Igloo> It's used for branching in the sense that it puts a value in a register to be tested, it doesn't branch itself
16:21:00 <ddarius> Igloo: Presumably it's because tan can fail in ways cos and sin can't.
16:21:41 <Igloo> But we haven't run tan again since the fnstsw immediately after it
16:22:05 <Igloo> I think I'll just make them all fnstsw and stick in a comment that libc does something different
16:22:23 <dons> what's this for?
16:22:53 <Igloo> Fixing sin/cos/tan on x86 in GHC
16:22:59 <Igloo> http://hackage.haskell.org/trac/ghc/ticket/2059
16:23:01 <lambdabot> Title: #2059 (Erroneous results in trigonometric functions for > double-precision value ...
16:23:08 <dons> cool
16:23:14 <bos> Igloo: fstsw checks for floating point exceptions.
16:24:10 <bos> but it does it before updating the status registers.
16:25:01 <Igloo> bos: Right, but why is it used there and not in any of the other 5 cases?
16:25:03 <bos> so if you get dropped into an FPE handler, it's due to a prior exception.
16:25:17 <ddarius> > tan 0
16:25:19 <lambdabot>  0.0
16:25:24 <ddarius> > tan (pi/4)
16:25:25 <lambdabot>  0.9999999999999999
16:25:38 <Heffalump> this is tan rather than atan?
16:25:41 <ddarius> > tan (pi/2)
16:25:42 <lambdabot>  1.6331778728383844e16
16:25:48 <Igloo> This is tan
16:25:59 <Heffalump> oh, but it can still go to infinity
16:26:07 <mauke> who is frederik and why does he use %lf in printf :(
16:26:09 <Heffalump> as ddarius showed
16:26:36 <bos> Igloo: afaik ddarius is correct.
16:29:33 <astrolabe> The ghc manual says that when you :trace your code in ghci, it will store up to 50 steps.  Why do I only seem to get 20 steps?
16:30:09 <Igloo> But it would never get to that opcode in the case of pi/2, woould it? It would just return after the fnstsw as it's in the right range?
16:30:32 <Igloo> And anyway, INF is a perfectly valid Double/Float value
16:30:33 <bos> Igloo: it's a loop normalising the operand to be in a valid range
16:31:00 <Igloo> bos: Right, and the sin and cos loops do exactly the same thing
16:31:49 <Igloo> It's just working out f `mod` 2 Pi AIUI
16:32:01 <Heffalump> astrolabe: do :history 50
16:32:16 <astrolabe> Heffalump: Thanks alot
16:33:30 <bos> Igloo: i think it's to do with floating point overflow if the result of tan goes to infinity
16:33:49 <bos> Igloo: but i'm not 100% sure of that.
16:36:33 <Heffalump> Igloo: INF might be valid, but 10^500 isn't
16:36:36 <Heffalump> (for example)
16:37:20 <Igloo> Heffalump: As an input or an output?
16:37:45 <Heffalump> as an output
16:38:14 <Igloo> If the input is < 2^63 then we don't reach that instruction
16:43:15 <roconnor> Given a DAG, is there a unique anti transtive-closure?
16:44:57 <Saizan> anti?
16:46:01 <roconnor> removing A -> C if there exists A -> B and B -> C
16:46:54 <Heffalump> roconnor: yes
16:47:12 <Heffalump> just do precisely what you just said, repeatedly :-)
16:47:35 <roconnor> Heffalump: that process is church-rosser?
16:48:04 <Heffalump> yes, but my proof involves demonstrating an alternate process that finds the end point :-)
16:48:30 <roconnor> oh okay
16:48:35 <Heffalump> that end point being G - (GxG + GxGxG + GxGxGxG + ...)
16:48:50 <roconnor> oh
16:49:16 <Heffalump> actually, I take it back about the first process being Church-Rosser, you can get stuck at a wrong answer.
16:49:31 <roconnor> really?
16:49:45 <Heffalump> well, not if you define the RHS of "there exists" to be the original graph
16:49:51 <Heffalump> but if you define it to be the new graph, then you can
16:50:10 <roconnor> huh?
16:50:42 <Heffalump> oh. No you can't.
16:51:01 <roconnor> whew
16:51:10 <Heffalump> though you need to generalise it to allow paths of any length, of course
16:51:17 <roconnor> oh right
16:51:49 <Heffalump> as it happens I've been doing that in SQL lately (using a fixed upper-bound on the G cross-products)
17:13:25 <Bonus_> hmm check out this project euler task guys http://projecteuler.net/index.php?section=problems&id=37
17:13:26 <lambdabot> Title: Problem 37 - Project Euler
17:13:33 <Bonus_> it says there are only eleven such numbers
17:13:45 <Bonus_> but i find more than 15 of them
17:13:48 <Bonus_> namely
17:14:01 <Bonus_> [11,13,17,23,31,37,53,71,73,113,131,137,173,197,311,313,317,373,797,1373,1997,31
17:14:01 <Bonus_> 37,3797,7331,73331Interrupted.
17:14:31 <Bonus_> ah wait nvm 1 is not a prime
17:14:31 <Bonus_> doh
17:14:52 <idnar> heh
17:16:44 <MathHat> well, only one to go, Bonus_.
17:16:50 <Bonus_> yeah hehe
17:17:19 <Bonus_> this project euler is pretty fun, a shame i didnt start doing it earlier
17:17:39 <Bonus_> hehe yay i got the answer
17:26:39 <Bonus_> it's cool how the lazyness of haskell makes some euler problems that are supposed to be difficult dead easy to solve
17:27:05 <olsner> yes, this is the secret purpose of haskell ;-)
17:27:19 <TSC> Yes, and Integer helps too
17:27:25 <Bonus_> yup
17:27:31 <Bonus_> for example
17:27:47 <Bonus_> calculating the last 10 digits of 28433 * 2^7830457 + 1
17:28:11 <dalien> wonder what (not if it exists :) is the more elegant way of writing this: http://hpaste.org/7340
17:28:24 <dalien> (the snippet is the code for Parsec)
17:28:25 <Bonus_> i just did reverse . take 10 . reverse . show $ (28433 * (2^7830457)) + 1
17:28:52 <TSC> dalien: The big case-expression could be replaced with "read"
17:29:07 <TSC> E.g. return (read str)
17:29:20 <dalien> ahha!
17:29:22 <dalien> let me try it :)
17:29:32 <Bonus_> yeah you already derive Read there so
17:29:36 <TSC> And the series of <|> choices could be replaced with something else
17:29:36 <Bonus_> there shouldn't be problems
17:29:41 <TSC> "oneOf", I think it is
17:30:03 <dalien> indeed :) i think it did not work at some point (hands growing out of ... ) - but now it does :)
17:30:29 <jberryman> Bonus_: I'm working on the problem about "amicable chains" myself (not sure which number that is atm)
17:30:47 <TomMD> Does anyone know if BayFP will be taped?
17:30:51 <jberryman> it's been really interesting looking at which parts of my code are the bottlenecks
17:30:55 <Bonus_> oh haha
17:31:02 <Bonus_> i still haven't done the amicable pairs
17:31:06 <Bonus_> i'm only at 10%, i started today
17:31:46 <jberryman> I haven't been going in order or anything, just doing the problems that look interesting
17:31:50 <TSC> dalien: Something like str <- choice (map string ["Fixed", "Low", "Medium", "High"])
17:31:52 <Bonus_> yeah me too
17:32:12 <Bonus_> i did the first 13 or so and now i just kind of jump around
17:32:14 <TSC> In fact, you could replace the list of strings with (map show [Fixed..High]) if you derived Enum
17:32:15 <vixey> string ?
17:32:34 <vixey> what is that
17:32:34 <dalien> TSC: oh! that's what I was looking for :)
17:32:47 <TSC> vixey: A parsec function
17:33:14 <TSC> Err, I think
17:34:21 <dalien> hmm, seems to error out - does not like the "Fixed.."
17:34:26 <jberryman> Bonus_: the amicable chain problem is basically factoring numbers over and over, and I found that 70% of the time in my program was taken by my little simple function to remove the duplicates from my list of recombined prime factors
17:34:51 <jberryman> so now I'm making a more elegant solution so i won't have to worry about dupes
17:35:02 <dalien> but i am mucking around with it..
17:35:13 <TSC> dalien: You'll need to derive Enum
17:35:15 <vixey> if you have some proc like
17:35:29 <vixey> f n = <calculation based on n from 0 on>
17:35:39 <vixey> you can memo it like
17:35:43 <Saizan> dalien: put a space between Fixed and ..
17:35:46 <dalien> TSC: for the MessageKind ? yeah, i added it to the "deriving()"
17:35:48 <vixey> fs = [<first n>, ...]
17:36:00 <vixey> then instead of f n = fs !! n
17:36:32 <vixey> since at the toplevel it's basically a let
17:36:43 <vixey> and lazyness makes sure the bits are evaluated once
17:37:04 <TSC> dalien: Put a space in between: [Fixed .. High]
17:37:14 <TSC> (otherwise it parses Fixed as a module name)
17:37:35 <dalien> TSC: yup, it now complains differently
17:38:16 <dalien> oh
17:38:21 <MathHat> can you really have a module with no name or that starts with '.'?
17:38:22 <dalien> str <- choice (map string (map show [Fixed .. High]))
17:38:24 <dalien> that is
17:39:13 <schemelab> How would you write a Haskell expression to model this english sentence - "The greater the authority of information and focused belief of
17:39:13 <schemelab> being, the greater the influence of the outcome.
17:39:35 <dalien> now to make it perfect it needs the "map all of these functions in sequence to the list being the last argument" construct..
17:40:14 <TSC> dalien: What do you mean?
17:40:22 <vixey> schemelab: huh??
17:40:27 <schemelab> :)
17:40:38 <dalien> TSC: to avoid two nested "map"
17:40:40 <schemelab> well, maybe I should go to a philosophy grup
17:40:41 <schemelab> group
17:40:46 <fishkandy> schemelab, probably by first writing a delimited continuation library ;-)
17:40:54 <schemelab> lol
17:41:21 <dalien> something like map2 string show [Fixed .. High]
17:41:23 <TSC> dalien: (map (string . show) [Fixed .. High])
17:41:25 <vixey> model it how?
17:41:33 <lispy> TSC: I was *just* typing that :)
17:41:36 <dalien> TSC: ahha! :)
17:41:41 <schemelab> vixey: Im starting to think a diagram of some sort is better
17:41:42 <TSC> dalien: You just compose the functions into one big function
17:41:44 <dalien> <-- noob, sorry for stupid questions :)
17:41:48 <dalien> ok, got that :)
17:42:01 <vixey> schemelab: what is this for
17:42:09 <schemelab> Just a book i'm reading
17:42:12 <TSC> No need for apologies here (:
17:42:55 <dalien> i love the power of the language :)
17:45:14 <dalien> as a starting exercise writing a parser for the secondlife message template to autogenerate the types / code from it
17:47:58 <lispy> secondlife?
17:48:01 <lispy> the video game?
17:48:06 <dalien> yeah :)
17:48:18 <lispy> dalien: so now tell me more about what you're doing?
17:48:44 <dalien> lispy: well, it all started with my participation into opensimulator - to try the C#
17:49:23 <dalien> which got me a bit annoyed with its quirks - and i wanted to try something less verbose..
17:49:41 <dalien> the C + cpp was reasonably good, but cpp is very weak when it comes to metaprogramming :)
17:50:13 <lispy> dalien: What will your program do?
17:50:15 <dalien> so since it was long time that i wanted to get a better grip on haskell, i want to see how far can i go with it :)
17:50:30 <dalien> lispy: it's a server code to which the clients will connect
17:50:45 <dalien> a lot of network I/O + simulation of the world :)
17:50:55 <lispy> dalien: oh so, you're writing a secondlife compatible server?
17:50:58 <dalien> yeah :)
17:51:12 <dalien> well, it is far from it yet, but if i manage to pull it up.. :)
17:51:30 <lispy> dalien: I've heard a lot of bad things about their architecture, so hopefully you can avoid their pitfalls :)
17:52:03 <dalien> hehe :) well, at least it gives a good learning ground...
17:52:26 <dalien> and re. architecture - indeed, centralized single points of failure is something i'd like to avoid
17:53:51 <lispy> dalien: one more question, what made you want to mimic secondlife?
17:55:04 <dalien> lispy: this avoids me having to muck around with GUI at all... plus - it's somewhat unique to an extent - when it comes to user-generated content.
17:55:28 <lispy> dalien: so your goal is to write the server and then use the existing client?
17:55:49 <dalien> yeah. similar to what opensimulator.org does
17:56:18 <dalien> although my assumption is that with more functional / metaprogramming approach the refactoring should be a lot easier and code more compact
17:58:32 <Jiten> So far I've found I've been able to make more compact readable code in Haskell than other languages I've tried. And I still haven't properly got my head around monads yet :)
17:59:09 <lispy> Well, succint code is good, but compact tends to have a bad connotation to me :)
17:59:27 <lispy> (I think of programming golf when I hear compact)
17:59:29 <ddarius> lispy is still upset about that black hole that ate is mother.
17:59:47 <lispy> yeah
17:59:55 <lispy> > let f = f in f
18:00:06 <lispy> stupid blackhole --^
18:00:19 <lambdabot>  thread killed
18:00:24 <dalien> :)
18:01:44 <Jiten> lispy: I guess that's why I added the "readable" to define what I mean a bit more accurately. I mean, you can make compact code in perl but ...
18:02:36 <TomMD> Not that the authors are here right now, but Real World Haskell has a kick butt chapter on Monad Transformers - if you haven't read it you should check it out!
18:02:56 * fishkandy makes transformer noises
18:04:41 <TomMD> We lots the professor!
18:04:50 <TomMD> s/lots/lost
18:04:55 <dalien> Jiten: yes, that's what i meant. :)
18:10:26 <lispy> Well, one of the things I like so much about Haskell is that often naive code in Haskell is pretty decent
18:10:53 <lispy> and since I like to code naive solutions first and add performance later, I'm pretty happy about that
18:11:22 <MyCatVerbs> lispy: ...what?
18:11:42 <ddarius> Naive not retarded.
18:11:54 <MyCatVerbs> lispy: as someone who just had a chunk of code that wasn't going to terminate until sometime after the sun burned out...
18:12:04 <MyCatVerbs> ddarius: ah, okay. Nevermind. ^^
18:13:15 <lispy> MyCatVerbs: actually, I was expecting ghc to print <<loop>> on that code, which is sometimse refered to a blackhole... :)
18:14:40 <MyCatVerbs> lispy: GHC's blackholing code is apparently imperfect.
18:15:29 <MathHat> what, like you think the they could solve the halting problem in one go?
18:15:41 <MyCatVerbs> lispy: presumably making it entirely accurate would be too much of a performance hit to be worthwhile? Anyway. If you look in the sources for Control.Monad.Fix, you'll find comments to that effect.
18:15:52 <TomMD> Has anyone here used harx before?
18:15:57 <MyCatVerbs> lispy: possibly that is something different, though.
18:16:09 <TomMD> errr, "haxr" is what I ment.
18:16:36 <lispy> Control.Monad.Fix is a odd
18:16:42 <lispy> you mean mfix, right?
18:16:45 <lispy> ?hoogle mfix
18:16:45 <lambdabot> Control.Monad.Fix.mfix :: MonadFix m => (a -> m a) -> m a
18:16:52 <lispy> ?src mfix
18:16:53 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
18:16:55 <MyCatVerbs> lispy: http://www.haskell.org/ghc/docs/6.8.2/html/libraries/base/src/System-IO.html#fixIO
18:16:56 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5qhfwh
18:16:59 * lispy shakes a fist at lambdabot 
18:17:17 <MyCatVerbs> lispy: fixIO, it was.
18:17:48 <Saizan> > let f = f in f
18:18:03 <lambdabot>  thread killed
18:18:11 <Saizan> > let f = f in f
18:18:27 <lambdabot>  thread killed
18:18:27 <MyCatVerbs> lispy: I'm not entirely sure whether or not that is the same issue.
18:18:44 <lispy> it could be related
18:18:54 <lispy> > let x = x in x
18:18:59 <lispy> > let foo = foo in foo
18:19:06 <lispy> I wonder why that's not <<loop>>
18:19:12 <lambdabot>  thread killed
18:19:14 <MyCatVerbs> Okay, let me rephrase that.
18:19:15 <lambdabot>  thread killed
18:19:23 <MyCatVerbs> I have no fucking clue whether or not they're related.
18:19:34 <Twey> Hm
18:19:45 <Saizan> "thread killed" is usually when the machine is too busy and lambdabot is not scheduled fast enough
18:20:02 <Twey> Is there a limit on the number of threads?
18:20:49 <lispy> but, even my local ghc is not saying loop
18:21:04 <bd_> lispy: Try building with optimizations
18:21:14 <Saizan> MyCatVerbs: yes, they are related, in fact you get an exception <<loop>> when you need to evaluate a thunk to just evaluate the thunk itself
18:21:23 <TomMD> > let x = 1 + x in x
18:21:26 <lispy> bd_: er, well I was using ghci :)
18:21:39 <lambdabot>  thread killed
18:21:44 <TomMD> lambdabot killed
18:22:29 <MyCatVerbs> Saizan: under what circumstances can the RTS/compiler/whatever handles it work that out?
18:24:04 <MyCatVerbs> Saizan: surely we can't afford to check an "under-evaluation" flag on every single thunk before forcing?
18:24:24 <Saizan> i think that's what is actually done
18:24:43 <MyCatVerbs> oO
18:25:07 <bd_> lispy: yes, ghci doesn't do the necessary analysic, I think
18:25:09 <bd_> analysis*
18:25:11 <bd_> > fix id
18:25:17 <MyCatVerbs> Uhhhhh. That would require a conditional branch on every single thunk force.
18:25:27 <lambdabot>  thread killed
18:25:50 <bd_> MyCatVerbs: moreover that would break in the threaded RTS
18:25:57 <MyCatVerbs> Oh sure, that branch almost always goes in the same direction, but still, mein pipeline.
18:26:12 <MyCatVerbs> bd_: probably actually acceptable.
18:26:26 <bd_> the threaded RTS is specifically designed to avoid locks by allowing thunks to be evaluated by multiple threads in some cases
18:26:58 <bd_> (long-running thunks will be detected to avoid wasted work, but short thunks could easily be evaluated twice)
18:27:14 <MyCatVerbs> bd_: it doesn't need to be perfect in practice, just decent enough not to waste CPU time gratituously. :P
18:27:40 <MyCatVerbs> (As for detecting black holes, that doesn't necessarily need to be perfect either. Imprecise exceptions and all that jazz.)
18:27:42 <bd_> I don't know specifically how the loop detection works, but probably it's based on strictness analysis or something?
18:27:44 <ddarius> MyCatVerbs: Forcing a thunk is an indirect jump/call.
18:27:46 <bd_> if some thunk is strict on itself, etc
18:28:30 <bd_> MyCatVerbs: and the problem with the threaded RTS is the 'mark thunks under evaluation' approach would cause false positives :)
18:28:41 <bd_> not that it would cause false negatives, which are unavoidable
18:28:56 <bd_> loop detection is neat, but it's not worth a runtime penalty imo
18:28:59 <cstork> /?
18:29:10 <ddarius> All blackholing does is when you are evaluating x in let x = ... x ... is replace the pointer to the x thunk with a pointer to the blackhole handler.
18:29:49 <MyCatVerbs> ddarius: hence the need for strictness analysis, right.
18:30:02 <Saizan> no, it's a runtime thing
18:30:27 <ddarius> MyCatVerbs: No.
18:31:11 <ddarius> MyCatVerbs: There's no need for strictness analysis, there are no conditions.  It can be done unconditionally.
18:31:45 <MyCatVerbs> ddarius: okay. Hence the really strong desire for strictness analysis.
18:32:07 <ddarius> MyCatVerbs: It has nothing whatsoever to do with strictness analysis.
18:32:19 <IsoPallo> Good evening people... Sorry to trash into an important looking discussion, but could someone give me a hint where to look for fome guidance on understanding the garbage collection in GHC?
18:32:45 <ddarius> IsoPallo: The GHC developer's wiki and the papers linked from it.
18:32:54 <MyCatVerbs> ddarius: yes it does. The fact that there's an indirect call on every thunk evalutation makes strictness analysis a really good idea. :P
18:33:10 <MyCatVerbs> ddarius: unless of course you don't want your programs to run quickly.
18:33:17 <ddarius> MyCatVerbs: That's irrelevant to blackholing.
18:34:33 <MyCatVerbs> ddarius: naturally. It's very closely related to thunk forcing overhead.
18:34:37 <IsoPallo> Thanks.
18:35:14 <lispy> IsoPallo: and also I think Simon Marlow has been the main PhD behind the garbage collection, so you could try looking up him and finding his research
18:36:02 <ddarius> MyCatVerbs: Blackholing or the fact that thunks exist at all?
18:36:03 <lispy> IsoPallo: like this one: http://www.haskell.org/~simonmar/papers/ExploringBarrierToEntry.pdf
18:36:09 <MyCatVerbs> ddarius: (really, I wasn't talking about blackholing at that point. Conversations *are* allowed to change topic, right?)
18:36:10 <lambdabot> http://tinyurl.com/5zkfnv
18:36:18 <lispy> IsoPallo: and this page in general: http://www.haskell.org/~simonmar/bib/bib.html
18:36:54 <lispy> MyCatVerbs: no, there is a fine for changing the topic.  Please pay in full when you receive the bill in the mail.
18:36:58 <lispy> MyCatVerbs: ;)
18:37:13 <ddarius> MyCatVerbs: "hence" implies a connection that, in this case, isn't there.
18:37:57 <MyCatVerbs> ddarius: "hence" was attached to your statement that thunk forcing already involves an indirect jump.
18:38:15 <MyCatVerbs> ddarius: why the Hell are we arguing about this, anyway?
18:38:24 * MyCatVerbs puts a pancake on ddarius' head.
18:38:40 <ddarius> MyCatVerbs: I say we are arguing about this because you can't speak clearly.
18:38:47 <lispy> ?slap pancake
18:38:48 * lambdabot jabs pancake with a C pointer
18:38:51 <ddarius> Or maybe because of lag.
18:40:58 * chessguy gets out some syrup and eyes the pancake
18:41:46 <MyCatVerbs> ddarius: ...ping?
18:57:52 <jberryman> man, learning this language I have these eureka(!) moments, and then a couple minutes later whatever it was just seems stupidly obvious
18:58:38 <ddarius> jberryman: That's the way it should be.
18:59:04 <jberryman> but then I forget how my algorithm works a week later :)
18:59:15 <jberryman> I just have to have faith
19:41:20 <xah_lee> is there a online text book for parsing?
19:41:42 <Mr_Awesome> yes. i dont remember where, but i happen to know one exists
19:41:58 <xah_lee> :(
19:42:08 <Mr_Awesome> shouldnt be too difficult to find
19:44:12 <Mr_Awesome> http://www.cs.vu.nl/~dick/PTAPG.html  there it is
19:44:13 <lambdabot> Title: Parsing Techniques - A Practical Guide
19:45:01 <Mr_Awesome> xah_lee: happy parsing :)
19:45:31 <xah_lee> Mr_Awesome: thxs a lot.
19:47:52 <xah_lee> Mr_Awesome: it does't seem to be free online? just table of content i think
19:49:28 <Mr_Awesome> xah_lee: ...scroll down to the "Availability" heading
19:51:49 <xah_lee> Mr_Awesome: thx a lot. i was looking at the 2nd ed. :)
19:52:07 <Mr_Awesome> heh, np
19:52:55 <MathHat> second edition is available online: ftp://ftp.cs.vu.nl/pub/dick/PTAPG_2nd_Edition/index.html
19:53:17 <MathHat> wait.
19:53:54 <MathHat> nope, ignore that.
20:21:32 <jberryman> is there a non-ugly way to sum a list except for the last element? or do i have to define my own fold, pattern matching for (x:[]) ?
20:22:29 <gweiqi> init ?
20:22:44 <gweiqi> > init [1, 2, 3, 4, 5]
20:22:45 <lambdabot>  [1,2,3,4]
20:23:08 <jberryman> :) thanks
20:23:11 <gweiqi> np
20:27:58 <dons> > snd $ foldl (\(b,xs) a -> case b of Nothing -> (Just a,xs) ; Just a' -> (Just a, a'+xs) ) (Nothing,0) $ [1..10]
20:27:59 <lambdabot>  45
20:28:14 <dons> > sum (init [1..10])
20:28:15 <lambdabot>  45
20:28:22 <dons> all you need is a fold or two :)
20:28:42 <IsoPallo> Aww... I just used my first foldr today...
20:28:46 <dons> (this is the encoding of `init' used to implement stream fusion for listsS)
20:28:49 <dons> IsoPallo: cool :)
20:30:55 <bos31337> dons: what
20:30:57 <bos31337> erk.
20:31:04 <bos31337> what's happening with the fusion stuff these days?
20:31:25 <bos> it seemed to sort of fall off the edge of the world a few months ago.
20:32:36 <dons> so deeply nested concatMaps are hard to optimise well. roman's been cranking up ghc's specconstr to make it work.
20:32:50 <dons> however, i'm doing a little bit on the side with an arrays library
20:33:02 <dons> now, arrays don't really need concatMap, and their fully strict, so the story is much simpler
20:33:15 <dons> and the pay off bigger -- eliminatinng an array allocation is really worth it
20:33:25 <dons> while eliminating a few list nodes doesn't help much
20:33:30 <dons> so, the future is arrays.
20:33:53 <dons>  http://code.haskell.org/~dons/code/uvector/
20:33:53 <lambdabot> Title: Index of /~dons/code/uvector
20:34:40 <dons> also, the current array lib sucks, so fixing it is worthwhile
20:34:42 <bos> so stream fusion for lists is not going ahead?
20:34:46 <bos> boy, no kidding.
20:34:57 <dons> well, it may yet. we've a full library for fusible lists on hackage that works nicely
20:35:12 <dons> but the win is small -- list nodes don't cost much
20:35:21 <gweiqi> hyperstrict, wow, what does that even mean?
20:35:30 <dons> but i'm more excited about a polymorphic arrays lib that fuses away
20:35:40 <dons> since there we end up with loop bodies that are infeasible to write in C.
20:35:45 <dons> just by composing fusible combinators
20:35:51 <dons> so == win.
20:35:57 <bos> yes, that's an interesting prospect.
20:36:22 <bos> was that the original target of the fusion work w.r.t ndp, or how were the two originally conceived to be related?
20:36:36 <dons> it was originally targetted to distributed, nested, parallel arrays, yeah.
20:36:44 <dons> but that proved too big a thing to mangle in one go.
20:36:49 <dons> so we sorted it out for bytestrings, then lists
20:36:56 <dons> and now the stream stuff is getting back ported to ndp arrays
20:37:17 <dons> there the fusion removes array rebalancing between cores
20:37:27 <dons> so you do bigger chunks in parallel
20:37:33 <bos> cool.
20:37:39 <bos> on a completely unrelated note:
20:38:03 <dons> gweiqi: the hyperstrict stuff is just a weird name for some (fully) strict data types
20:38:04 <IsoPallo> win == providing something that you can't do in C?
20:38:15 <bos> why are overlapping instances disabled by default? is it that the type systems of the day circa H98 couldn't deal with them
20:38:42 <dons> didn't h98 go to some trouble with the ShowS class to avoid overlapping with String?
20:38:47 <bos> yes.
20:38:54 <dons> there's a separate method for strings just for that, iirc
20:39:00 <bos> i'm writing about overlapping instances at the moment, and i want to not write nonsense.
20:39:29 <dons> i can't think of a safety issue
20:39:31 <bos> the current story i have has to do with the invisibility of exported instances causing potential changes in behaviour that are not easy to track down.
20:39:44 <bos> but i'm not sure i believe that story.
20:39:49 <dons> oh, it may not be obvious how the overlapping is resolved?
20:40:01 <bos> well, the rules are certainly tricky.
20:40:28 <dons> "In general, GHC requires that that it be unambiguous which instance declaration should be used to
20:40:31 <dons> resolve a type-class constraint. This behaviour can be modified by two flags: -XOverlappingInstances
20:40:34 <dons> and -XIncoherentInstances"
20:40:37 <bos> i'm not going to try to explain them. your intuition is a good guide for the simple cases, and for the complicated cases, take the GHC user guide and a bottle of gin.
20:41:10 <dons> S 8.6.3.3 in the user's guide has some things to say
20:41:19 <bos> yes, but it's not very informative.
20:41:21 <ddarius> I think the goal is to avoid situations requiring "the GHC user guide and a bottle of gin."
20:41:58 <dons> "These rules make it possible for a library author to design a library that relies on overlapping
20:42:01 <dons> instances without the library client having to know"
20:42:03 <dons> useful
20:43:44 <dons> so, its sometimes useful to allow ambiguous matches, and there's multiple ways you can script the ambiguity to work. but there's no obviously always best solution
20:43:50 <dons> so not on by default, i figure.
20:44:21 <dons> usual 'exploring the design space' thing.
20:44:40 <ddarius> My understanding is that overlapping instances start to reveal implementation details.
20:44:54 <dons> yeah, you end up looking into the unifier
20:45:08 <dons> its heart of darkness
20:45:28 <dons> which can drive you slowly insane
20:48:45 <bos> ooh, i have to write about flexible instances, too.
20:49:04 <bos> otherwise the huddled masses will go "wtf?" when GHC rejects "instance Num a => Foo a"
20:49:21 <bos> chapter 7 and a half is getting big.
20:49:54 <dolio> Someone asked about overlapping instances not being allowed with (open) type families, and the answer was that they make the type system unsound somehow.
20:50:22 <bos> i don't think we'll be writing about type families.
20:50:24 <dolio> Whereas with just classes, you get varying methods.
20:50:35 <bos> they have too much of that "subject to change in the next release" smell.
20:50:37 <dolio> Which is, perhaps, a reason to disallow them.
20:51:02 <dons> and only barely being used now
20:51:10 <ddarius> bos: They should certainly be mentioned in a conclusion somewhere.
20:51:15 <dons> mtl-tf , and the uvector library above use them.
20:51:22 <dons> so at most a mention if FDs are raised
20:51:46 <dolio> Well, I just mean that classes have a similar issue. It just doesn't lead to segmentation faults.
20:51:47 <bos> we have to mention FDs because otherwise you can't write a monad transformer in the currently prevailing style.
20:52:08 <dons> it'd take half a dozen books to cover just the non-researchy features in haskell in full detail
20:52:08 <bos> but my current coverage of FDs is extremely cursory, and ought to stay that way.
20:52:21 <dons> bloody big language, in all its implications
20:52:40 <IsoPallo> Well it is a research language after all...
20:52:59 <IsoPallo> I can't see it would catch up proper.
20:53:07 <IsoPallo> Being as big as it is.
20:53:43 <dolio> If I had to guess at what it was, I'd say that overlapping instances in separate modules lead to different instances being used depending on imports.
20:54:35 <dolio> But I don't remember too clearly.
20:54:52 <dons> dolio: i think that might be it, actually, i remember iavor complaining about this the other day
20:55:14 <dons> at least, module can mess things up.
20:55:26 <dons> he was grumbling about overlapping in the json lib
20:55:57 <dolio> So module B might have a different Foo Int instance than module A. That isn't a problem when the difference is just different functions being called, but when 'TFoo Int' is a different type depending on what module it comes from, that's a problem.
20:56:01 <ddarius> Why are you using overlapping instances in the JSON library?
20:56:29 <dolio> TFoo being a type family.
20:57:23 <bos> ddarius: to distinguish "instance JSON String" from "instance JSON a => JSON [a]"
20:57:29 <dons> ddarius: we're not, iirc, but it was for String.
20:57:48 <dons> since you really want to pick a custom instance for String (json has a natural representation for them)
20:57:51 <bos> ddarius: although that gets worked around with a newtype hack
21:10:02 <augustss_> bos: no need for overlapping instances just for that
21:10:27 <augustss_> the Show trick works
21:16:17 <bos> you mean showList? yes.
21:17:32 <bos> although overlapping instances are rather more convenient for the lazy among us.
21:38:07 <dufflebunk> I have a problem with a program, it's not outputting stuff in the order I expect it to. I'm not sure if it's something with the FFI stuff or I'm just missing the boat on the IO monad. http://dufflebunk.blogspot.com/2008/05/foreign-function-interface-in-haskell.html
21:38:09 <lambdabot> Title: In Aere Aedificare: Foreign Function Interface in Haskell, http://tinyurl.com/5lfwgn
21:38:29 <dufflebunk> If someone could take a quick look I'd appreciate it.
21:51:39 <red75> well, it's something to do with internal workings of IO monad. try to compile with -core-simpl and see what code it produced.
22:01:27 <bos> dufflebunk: C's stdio and Haskell's stdio are not related
22:02:22 <bos> they use different sets of buffers. so one guess is that that's all you're seeing.
22:13:09 <bos> haskell talk in SF next week: http://www.realworldhaskell.org/blog/2008/05/02/a-real-world-haskell-talk-in-san-francisco-may-8/
22:13:10 <lambdabot> Title: Real World Haskell  Blog Archive  A Real World Haskell talk in San Francisco,  ..., http://tinyurl.com/55sbkb
23:12:23 <dufflebunk> bos: in C, I purposely put in a flush so it wouldn't buffer. If Haskell's stdout is buffering, I would have expected it /after/ the C output. But it's not, it's before.
23:12:38 <bos> yeah.
23:21:40 <dufflebunk> red75: That option doesn't work. Google turned up -ddump-simpl  is that what you meant?
23:22:54 <red75> yes
23:24:45 <slava> how is fmap implemented on monads? is it return . bind ?
23:25:31 <dufflebunk> Do you know how to read this output? To my eyes, it looks like it should with the output happening in the correct order.
23:27:24 <dufflebunk> http://hpaste.org/7344
23:27:28 <dmwit> :t fmap
23:27:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:27:34 <bos> slava: usually, yes
23:27:38 <dmwit> :t liftM
23:27:40 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
23:27:45 <dmwit> slava: fmap = liftM
23:27:53 <dmwit> ?src liftM
23:27:54 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
23:29:27 <dmwit> :t flip (>>=) . (return .)
23:29:29 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a -> a1) -> m a -> m a1
23:29:50 <dmwit> So, pretty much bind . return, but with a bit of extra (.) and flip to make the types work out.
23:29:58 <red75> @src IO sequence_
23:29:58 <lambdabot> Source not found. Maybe if you used more than just two fingers...
23:30:08 <dmwit> ?src sequence_
23:30:08 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
23:30:28 <dufflebunk> Hmm, the nesting does look off.
23:31:42 <red75> dufflebunk: hmm. ghc translated your code almost vervatim. it calls sequence__r18z on list.
23:32:32 <red75> I don't know how it's being processed internally.
23:32:55 <paolino> is there a standard way to serialize data ?
23:33:10 <bos> sort of.  Data.Binary.
23:33:33 <dufflebunk> red75: Yeah, but it turns the list into: (putStr ... ( with_toString ... ) (putString ... (with_toString ...) (putString ... )))
23:34:01 <dufflebunk> It's nesting the putStr function calls, but not the with_toString calls?
23:34:08 <paolino> bos , is that distributed with core system ?
23:34:12 <bos> no
23:35:01 <paolino> @where Data.Binary
23:35:02 <lambdabot> I know nothing about data.binary.
23:35:18 <dmwit> ?go Data Binary haskell
23:35:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
23:35:20 <lambdabot> Title: Data.Binary - efficient, pure binary serialisation for Haskell
23:38:46 <red75> dufflebunk: no. it doesn't.
23:39:38 <red75> dufflebunk: i'm not a specialist in ghc internals. so... i cannot say more on topic.
23:41:46 <paolino> bos.  why that's only a sort of ?
23:42:05 <dufflebunk> red75: Thanks for suggesting the switch and taking a look.
23:43:29 <red75> :t sequence
23:43:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:43:33 <red75> :t sequence_
23:43:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
23:43:58 <paolino> because it's not an introspection system ?
23:44:03 <red75> dufflebunk: maybe it's lazy evaluation... not sure...
23:44:43 <red75> try to replace sequence_ with plain do.
23:45:00 <dmwit> Why would that help?
23:45:44 <slava> whats a functor that's not a monad?
23:45:46 <slava> something simple
23:45:53 <dmwit> Array
23:46:00 * dufflebunk goes to get some sleep and hopes things make more sens in the morning
23:46:27 <dmwit> (Although, yes, the sequence_ does seem a bit superfluous.)
23:47:15 <red75> dmwit: i'm not sure it will help.
23:49:05 <slava> if i'm implementing monads in a langauge without implicit currying, which way should i curry bind?
23:49:08 <slava> :t bind
23:49:09 <lambdabot> Not in scope: `bind'
23:49:10 <slava> :t >>=
23:49:11 <lambdabot> parse error on input `>>='
23:49:16 <slava> :t `>>=`
23:49:17 <lambdabot> parse error on input ``'
23:49:18 <dmwit> :t (>>=)
23:49:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:49:20 <slava> sorry
23:49:26 <dmwit> Yep, no worries.
23:49:31 <slava> should it take two parameters, or take one parameter and output a value
23:49:43 <slava> a function*
23:49:45 <slava> i'm tired :)
23:49:56 <dmwit> Well, in Haskell, it takes one parameter and outputs a function.
23:50:01 <dmwit> And I like Haskell, so... =)
23:50:06 <slava> :)
23:51:02 <dons> slava, maybe there's some related work here, http://haskell.org/haskellwiki/Monad#Monads_in_other_languages
23:51:28 <dons> i'm not sure which would be the most appropriate reference (or how fleshed out they are), but there might be some ideas
23:51:34 <slava> cool
23:51:58 <dons> maybe the lisp one?
23:52:30 <slava> my 'return' has to take a symbol for the return type, which is awkward compared to the situation in haskell
23:53:48 <dons> hmm. i think there's an good paper if you work out a nice solution in a non-statically typed setting
23:54:00 <slava> i'm mostly doing this for fun
23:54:04 <dons> :) of course!
23:55:46 <slava> @src Monad
23:55:46 <lambdabot> class  Monad m  where
23:55:46 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
23:55:46 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
23:55:46 <lambdabot>     return      :: a -> m a
23:55:46 <lambdabot>     fail        :: String -> m a
23:55:54 <red75> without type inference there will be a lot of handwork involved.
23:55:58 <slava> its kind of odd that fail hardcodes String?
23:56:15 <slava> @src (>>)
23:56:15 <lambdabot> m >> k      = m >>= \_ -> k
23:57:33 <dmwit> slava: It's kind of odd that fail exists.
