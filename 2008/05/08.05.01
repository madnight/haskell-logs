00:04:02 <megeria> Papageno: so the farrest swap length is 31 bits for a single move assuming i am only swapping 1 bit?
00:04:47 <Papageno> Yes. But I might increase the length of the bit field to 64 if that changes things for you.
00:09:18 <megeria> Papageno: so if you are doing the same transform on a large number of 32/64 bits wide data you are trying to find the minimum steps to move them into a different order?
00:10:09 <Papageno> Yes if that different order is ordered by value
00:10:09 <megeria> Papageno: sorry just trying to get the parameters of the problem
00:10:35 <Papageno> Sure. I really appreciate your help.
00:12:58 <megeria> Papageno: well i can see the worst case is O(n) given exchange swapping
00:15:27 <Baughn>  > œÄ
00:15:40 <Baughn> > œÄ
00:15:40 <lambdabot>  Illegal character ''\128''
00:15:40 <lambdabot>  at "Ä" (column 2)
00:19:30 <megeria> Papageno: so let me be clear, you are saying there is only 32 or 64 values in total but you need to mass apply this sort to a lot of data?
00:20:20 <megeria> Papageno: or does each 32/64 bits segment have different sort key?
00:29:45 <Papageno> megeria: Sorry, I was away for a sec. Yes, there are 64 values to sort for a collection of bit fields. There may be several collections. But considering each separately, there are 64 values to sort.
00:34:43 <megeria> Papageno: do you know the range of these values?
00:35:28 <notostraca_> oh crud.
00:35:51 <notostraca_> where is ghc SUPPOSED to look for .dylib files?
00:36:09 <notostraca_> because I must have set it to the wrong folder
00:36:54 <Papageno> megeria: the values themselves range from 0 to 63 but are usually in the lower end
00:38:09 <megeria> Papageno: honestly i am thinking of a radix sort for this with assuming you can use a temp variable like another register
00:38:36 <notostraca_> I am not sure how to uninstall ghc, either
00:38:50 <notostraca_> I am on a mac
00:41:00 <Papageno> I could use a temp variable. In what ways is radix sort optimal for this?
00:49:11 <megeria> Papageno: i am looking at the fact the your key order have to track the 32/64 bit data
00:50:44 <megeria> Papageno: i am thinking that you may have a way to move the value fast but the key is still a 64x64 array
00:51:22 <cjs> What the syntax for producing a new datum from an existing one with one named field replaced with a new value?
00:52:28 <glguy> a { b = c }
00:52:39 <cjs> Thanks.
00:58:11 <megeria> i think i read more academic papers learning haskell than i read in a semester while in school, is that unusual for people picking up haskell?
01:02:35 <cjs> I don't think so at all. I'm finding it to be the same.
01:02:46 <cjs> Though I sort of have a predeliction for academic papers, anyway.
01:03:49 <megeria> you are a masochist? lol
01:23:38 <dibblego> is there a paper that clearly shows the advantages of SmallCheck over QuickCheck?
01:31:37 <cjs> This is kinda cool: http://www-users.cs.york.ac.uk/~mfn/lazysmallcheck/
01:31:38 <lambdabot> Title: Lazy SmallCheck
01:36:29 <luqui> hallo.  is there an efficient algorithm for finding the complete subgraphs of a graph?
01:40:42 <dibblego> is there a function :: (Monad m) => (a -> m b) -> m (a -> b) ?
01:41:07 <luqui> awww, np-complete...
01:41:22 <luqui> dibblego, yes, flip (>>=)
01:41:30 <maltem> cjs, thanks for the link, that really looks interesting
01:41:32 <luqui> er no
01:41:34 <luqui> I'm stupid
01:41:52 <dibblego> :)
01:42:04 <dibblego> (=<<) = flip (>>=)
01:42:23 <luqui> dibblego, I believe not.
01:42:31 <luqui> what would you do for putStr?
01:42:51 <luqui> IO (String -> ())...
01:44:33 <bogomipz> haskell.org does not seem to respond to http requests today
01:44:34 <Deewiant> @ty \f -> f undefined >>= \x -> return (const x)
01:44:36 <lambdabot> forall a (m :: * -> *) a1 b. (Monad m) => (a -> m a1) -> m (b -> a1)
01:44:39 <Deewiant> dibblego: ^ :-P
01:44:42 <bogomipz> is there a mirror for the library reference?
01:44:44 <luqui> cheater
01:44:50 <dibblego> Deewiant, great thanks :)
01:45:01 <dibblego> Deewiant, I'm starting to suspect I made a big mistake
01:45:18 <luqui> dibblego, what is the problem?
01:45:22 <Deewiant> if you need that, I think so, that doesn't look like a sane operation to me :-)
01:45:24 <dibblego> long long story
01:45:59 <dibblego> imagine changing QuickCheck's Gen to Int -> Rand -> Maybe a, then trying to write promote :: (a -> Gen b) -> Gen (a -> b)
01:46:04 <Deewiant> @ty (const <$>) . ($ undefined)
01:46:06 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a1 -> f a) -> f (b -> a)
01:46:33 <dibblego> I think changing QuickCheck's Gen to Int -> Rand -> Maybe a is the equivalent of my mistake
01:46:45 <bogomipz> I need a function like words that matches quotes, similar to how you'd parse command line arguments
01:47:03 <bogomipz> words "the \"quick brown\" fox" => ["the","\"quick","brown\"","fox"]
01:47:27 <bogomipz> I need it to return ["the","quick brown","fox"]
01:47:47 <luqui> there is none builtin, you need to write it yourself
01:48:20 <bogomipz> right, would the source for getArgs have any hints in it?
01:48:37 <luqui> bogomipz, no
01:48:41 <luqui> that kind of stuff is done by the shell
01:48:47 <bogomipz> kthx
01:51:22 <luqui> bogomipz, do you need to handle \s?
01:51:26 <int-e> > let words' = filter (not . null) . (unfoldr (\xs -> guard (not (null xs)) >> return (span isLetter (tail xs)))) . (' ':) in words' "the \"quick brown\" fox"
01:51:27 <lambdabot>  ["the","quick","brown","fox"]
01:51:27 <luqui> er, \"s
01:52:37 <bogomipz> yes, i want them stripped and matched
01:52:53 <ziman> is there any function that splits a string on a given char? Char -> String -> [String], like words/lines with an arbitrary separator
01:53:10 <luqui> bogomipz, no, I mean, "hello \"world \\\"I enjoy\" cupcakes"
01:53:11 <bogomipz> int-e: it should be "quick brown"
01:53:56 <int-e> bogomipz: I misread.
01:53:58 <bogomipz> luqui: no that's not important
01:54:10 <noname``> when I look at forth again,today,I find Hakell a little bit book like Forth, :)
01:54:24 <luqui> bogomipz, okay, then I'd start by writing split :: (a -> Bool) -> [a] -> [[a]] that does what words does but in general
01:54:36 <luqui> (without stripping of spaces)
01:55:16 <luqui> (then split (== '\\') and do words to alternating result lists)
02:00:46 <Duddle> hello everybody! I'm still pretty new to functional programming and haskell, so bear with me. My question: how would I randomly select 2 items from a list and make sure that both are not the same? Normally I'd do something like: do{ a=$array[rand(0,5)]; b=$array[rand(0,5)]; } while(a==b)
02:00:51 <bogomipz> luqui: do you mean (== '"') ? then use words on index [1,3..] ?
02:01:12 <luqui> bogomipz, yes to the '"' part, words on indices [0,2..]
02:01:50 <bogomipz> err, right I messed up the indices
02:01:56 <luqui> Duddle, that is an O(infinity) algorithm :-)
02:02:28 <Duddle> yes, It's kinda like bogosort ;)
02:03:11 <luqui> Duddle, randoms are a little tricky but not too bad.  It's easy with a function pickRandom :: (RandomGen g) => g -> [a] -> (a,[a],g)
02:03:43 <luqui> which returns the picked element and the rest of them
02:04:09 <Valodim> create a list of infinite random numbers, zip with itself, filter (a,b) -> a == b and take 1
02:04:42 <luqui> Valodim, take 2 presumably.  and very nice.
02:04:53 <Valodim> no, take 1 you want a zipped pair
02:04:53 <luqui> though still O(infinity) :-)
02:04:58 <luqui> oh right
02:05:07 <Valodim> yeah but if you want random with a condition you can't avoid that I think
02:05:11 <Duddle> luqui: thanks, will try
02:05:23 <luqui> Valodim, my solution is O(n)
02:06:21 <cjs> Or maybe have a function that picks a number out of a list, and returns a pair of that number and the list with that number removed.
02:07:08 <Valodim> lugui: wait then I didn't get your solution. could you elaborate?
02:07:55 <luqui> Valodim, sure.  generate random number in [0,length list)
02:08:23 <luqui> call it n.  return (list !! n, elems before n ++ elems after n)
02:08:51 <luqui> but you have to thread the RandomGen through
02:08:56 <luqui> (or split one off I suppose)
02:09:33 <luqui> the elems before ++ elems after can be done with splitAt
02:10:04 <luqui> (but you still need to drop one from the tail list)
02:10:42 <luqui> i.e. removeAt n xs = let (pre,post) = splitAt n xs in pre ++ tail post
02:11:23 <luqui> hmm, you need to handle the case where post == [] there too...
02:11:27 <maltem> let (pre,x:post) = splitAt n xs
02:11:44 <luqui> maltem, heh, yeah :-)
02:12:08 <maltem> and make sure n is small enough
02:12:31 <luqui> > splitAt 42 [1,2,3]
02:12:32 <lambdabot>  ([1,2,3],[])
02:12:35 <luqui> splitAt does that :-)
02:13:02 <maltem> I mean, because of the (:) pattern match. If n i small enough then you don't need a check for the empty list
02:13:22 <luqui> maltem, but what if you chose the last element?
02:13:56 <maltem> then x:post = xlast:[]
02:14:38 <luqui> so you'd need to check for that...
02:14:43 <luqui> okay I see
02:14:55 <maltem> No? n is out ot 0..length list - 1
02:15:38 <luqui> > splitAt (length [1,2,3] - 1) [1,2,3]
02:15:39 <lambdabot>  ([1,2],[3])
02:15:51 <luqui> oh..... off by one error in my brain
02:16:00 <maltem> And once you know that, shout at your pattern-match-exhaustiveness-checker: Hah! I know better then you!
02:16:45 <visof> haskell.org doest open
02:18:50 <maltem> luqui: "splitAt n" splits _before_ the nth element if you count by zero, and _after_ the nth element if you count by one. Simple enough :)
02:22:26 <luqui> or the way I like to think of it:  it split's at the nth boundary
02:22:34 <luqui> I just didn't think it through :-)
02:24:30 <bogomipz> is there a Hoogle mirror somewhere?
02:30:03 <cjs> Oh, no, is haskell.org down again? It's been really flakey lately.
02:35:54 <dcoutts> the host is up, the http server is not accepting new connections
02:36:15 * dcoutts inspects http://localhost/server-status/ on haskell.org
02:42:36 * dcoutts restarts the http server on haskell.org
02:43:46 <bogomipz> thanks dcoutts :)
02:44:01 <dcoutts> np
02:54:18 <cjs> Want me to put it in my monitoring system and have it send you pages?
02:54:57 <cjs> Or heck, I'll help run it, if you like. It's not as if I don't run enough servers already.
02:58:52 <dcoutts> cjs: I don't admin it, though I've been given sudo access.
02:59:23 <dcoutts> cjs: one thing we'd like advice on, the problem always seems to be that we get to the maximum number of open connections
02:59:36 <dcoutts> we configure apache to use at most 50 sub processes
03:00:40 <dcoutts> but we get to a situation where some single client is tying them all up, not sending/receiving much data, but just holding the connections open and preventing other clients opening new connections
03:01:00 <dcoutts> it's a starvation attack, though it's not clear if it's deliberate or not
03:05:00 <aks42> Hello! I am looking for a function, maybe you can give me a hint. I have a large tree-shaped datastructure (no cycles), consisting of different types. All nodes in this tree are derived from Data and Typeable. I need to transform some nodes (of certain types), and feed back data some nodes upwards. I am looking for something like "everywhere", but working shallow intead of deep, and allowing me to return data. Is there such a thing?
03:07:01 <moozilla> hey all
03:08:10 <aks42> Hi
03:08:25 <moozilla> I need help with a small code
03:08:48 <moozilla> I need to convert a random number to a string
03:09:01 <moozilla> right now I have
03:09:01 <Botje> > show 42
03:09:02 <moozilla> r100 = getStdRandom (randomR (1,100))
03:09:03 <lambdabot>  "42"
03:09:12 <moozilla> but show r100 doesnt work
03:09:44 <moozilla> > getStdRandom (randomR (1,100))
03:09:46 <lambdabot>  <IO Integer>
03:09:59 <Botje> moozilla: it's an IO action, you need to execute it in the IO monad first.
03:10:14 <moozilla> how do I do that?
03:10:55 <sbahra> If I finish all this philosophy work (6 more hours to go), I can get back to learning haskell!
03:11:20 <Botje> main = do r100 <- getStdRandom (randomR (1,100))
03:11:33 <Botje>          print $ doSomethingWithr100
03:11:34 <visof> how can i write ord :: Char -> Int ?
03:11:41 <wjt> @index ord
03:11:42 <lambdabot> Data.Char
03:11:44 <wjt> @ty ord
03:11:46 <lambdabot> Char -> Int
03:12:02 <Botje> oops, gtg
03:12:02 <Botje> <<
03:12:30 <visof> how can i use it in prelude?
03:12:45 <visof> i have not in scope
03:13:33 <wjt> import Data.Char (ord)
03:13:57 <moozilla> main = do r100 <- getStdRandom (randomR (1,100))
03:14:14 <moozilla> how do I convert that to a function that just returns a number
03:14:37 <ski> you can't
03:14:45 <aks42> You can't really get rid of the IO here
03:15:10 <ski> what you can do, is use the `r100' locally in `main', and print some result computed from it
03:15:25 <moozilla> hm ok
03:15:33 <ski> you can also pass it off to some non-IO-function, and then use the result of that in `main' as above
03:16:37 <moozilla> in main i can use show on it?
03:16:44 <ski> sure
03:16:49 <ski> or
03:16:53 <ski> @type print
03:16:54 <lambdabot> forall a. (Show a) => a -> IO ()
03:16:57 <ski> @src print
03:16:58 <lambdabot> print x = putStrLn (show x)
03:17:17 <moozilla> > do r100 <- getStdRandom (randomR (1,100)); return r100
03:17:18 <lambdabot>  <IO Integer>
03:17:27 <moozilla> > do r100 <- getStdRandom (randomR (1,100)); return show r100
03:17:27 <lambdabot>  Couldn't match expected type `IO' against inferred type `(->) a'
03:17:57 <wjt> > do r100 <- getStdRandom (randomR (1,100)); return (show r100)
03:17:58 <ski> lambdabot refuses to do I/O for security reasons
03:17:58 <luqui> no IO in lambdabot :-)
03:17:58 <lambdabot>  <IO [Char]>
03:18:18 <ski> main = do r100 <- getStdRandom (randomR (1,100))
03:18:29 <ski>           print (computeSomething r100)
03:18:32 <luqui> > randomR (1,100) (mkStdRandom 42)
03:18:32 <lambdabot>   Not in scope: `mkStdRandom'
03:18:45 <luqui> er, damn, forgot what that was called
03:18:52 <wjt> @ty mkStdGen
03:18:53 <ski> moozilla : try something like that example
03:18:54 <lambdabot> Int -> StdGen
03:19:04 <luqui> you can use that to play with randoms
03:19:13 <moozilla> ski: print instead of show?
03:19:22 <luqui> > randomR (1,100) (mkStdGen 42)
03:19:23 <lambdabot>  (72,1720602 40692)
03:20:02 <visof> the function ord convert any character from 0 to 255 , right?
03:20:03 <ski> moozilla : `show' only gives you back a string .. you need to use `putStr' or `putStrLn' to make an `IO'-action that actually prints the string
03:20:29 <ski> moozilla : `print (computeSomething r100)' is the same as `putStrLn (show (computeSomething r100))'
03:20:36 <moozilla> i have an IO function that prints it on IRC
03:21:23 <ski> visof : should work for all of unicode, i'd guess
03:21:39 <visof> chr for reverse?
03:21:44 <ski> *nod*
03:21:54 <visof> chr :: Int -> Char
03:22:04 <visof> also in Dtat.Char ?
03:22:09 <ski> Data.Char
03:22:10 <visof> also in Data.Char ?
03:22:13 <visof> okay
03:22:51 <ski> moozilla : ok ?
03:23:13 <moozilla> ok
03:23:18 <visof> isLower ?
03:23:23 <visof> how can i use it?
03:23:51 <Beelsebob> same way you use any other function
03:23:52 <visof> also in Data.Char?
03:23:58 <Beelsebob> ?index isLower
03:23:59 <lambdabot> Data.Char
03:24:02 <Beelsebob> that'll be a yes then
03:24:04 <visof> okay
03:24:28 <visof> ?index product
03:24:29 <lambdabot> Data.List, Prelude
03:24:36 <visof> good
03:25:15 <moozilla> > do r100 <- getStdRandom (randomR (1,100)); return "TEST" ++ (show r100)
03:25:16 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
03:25:22 <moozilla> I can't get that to work
03:25:57 <ski> return ("TEST" ++ show r100)
03:26:35 <moozilla> > do r100 <- getStdRandom (randomR (1,100)); return ("TEST" ++ (show r100))
03:26:36 <lambdabot>  <IO [Char]>
03:26:40 <moozilla> ok
03:27:03 <moozilla> r100 returns an IO [Char] though
03:27:10 <moozilla> how do I make that a string
03:27:40 <ski> `r100' *is* a string
03:28:04 <Beelsebob> note, String is a type synonym for [Char]
03:28:05 <ski> the `IO'-action that computes it, however, is an `IO'-action returning that string
03:28:23 <ski> so either you do
03:28:36 <ski> compute_r100 = do
03:28:42 <ski>   r100 <- getStdRandom (randomR (1,100))
03:28:44 <ski>   return ("TEST" ++ (show r100))
03:28:47 <ski> main = do
03:28:49 <ski>   ...
03:28:57 <ski>   r100 <- compute_r100
03:29:03 <ski>   ..do something with r100..
03:29:20 <moozilla> ok
03:29:21 <ski> or you just inline the body of `compute_r100' into `main' (or whatever)
03:29:33 <ski> i.e.
03:29:36 <ski> main = do
03:29:38 <ski>   ..
03:29:46 <ski>   r100 <- getStdRandom (randomR (1,100))
03:29:50 <bogomipz> why "TEST" ++ (show r100) and not just "TEST" ++ r100
03:29:59 <ski>   let r100' = "TEST" ++ show r100
03:30:05 <ski>   .. do something with r100'..
03:30:24 <Beelsebob> bogomipz: because r100 is an Num a => a
03:30:33 <bogomipz> oh nm, got confused when you said before that `r100' *is* a string
03:30:43 <Beelsebob> yeh, we both meant show r100 is
03:30:45 <Beelsebob> >.<
03:30:54 <ski> bogomipz : moozilla had strange bracketing before, i corrected it, but here happened to copy a half-corrected version moozilla wrote afterwards
03:31:31 <ski> (oh .. right)
03:31:39 <Beelsebob> my suggestion in general for random number generation, is that you write a function that returns you an infinite list of random numbers that you can just pull one off later
03:31:50 <Beelsebob> it keeps your IO based code constrained only to the bits of the program that need it
03:40:12 <moozilla> Beelsebob: how would I write that function
03:42:36 <byorgey> @type randomR
03:42:37 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
03:42:49 <byorgey> @type getStdRandom
03:42:51 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
03:43:56 <byorgey> @type randomRs
03:43:57 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
03:44:18 <byorgey> @type getStdRandoms
03:44:19 <lambdabot> Not in scope: `getStdRandoms'
03:45:25 <byorgey> moozilla: create a generator with newStdGen, then pass it to randoms or randomRs
03:46:03 <byorgey> do { g <- newStdGen ; randomRs (1,100) g }
03:48:10 <masterdev> Free .com .net and .org domain in http://free.novafree.net
03:48:10 <masterdev> Free .com .net and .org domain in http://free.novafree.net
03:48:12 <lambdabot> Title:
03:48:12 <lambdabot> Title:
03:48:41 * Beelsebob ponders if there may be a really bad way to exploit security holes in \bot there
03:49:00 <Beelsebob> page title that causes it to asplode or something
03:49:25 --- mode: ChanServ set +o Igloo
03:49:41 --- mode: Igloo set +b *!*@https.ftp.sh
03:49:47 --- kick: masterdev was kicked by Igloo (Igloo)
03:50:21 <red75> Unlikely. It's haskell bot.
03:53:21 <vixey> What's this about Systematic Type System Design?
03:54:08 <bogomipz> why are so many useful list functions only implemented on ByteString?
03:54:12 <bogomipz> like mapIndexed
03:54:41 <vixey> :t mapIndexed
03:54:43 <lambdabot> Not in scope: `mapIndexed'
03:54:46 <vixey> what does it do?
03:55:11 <bogomipz> the same as map but revealing the index of the current element
03:55:27 <bogomipz> (Int -> Char -> Char) -> ByteString -> ByteString
03:55:53 <bogomipz> same thing with split / splitWith
03:57:27 <vixey> :t zipWith ?f [1..] ?list
03:57:28 <lambdabot> forall a b c. (?list::[b], Enum a, Num a, ?f::a -> b -> c) => [c]
03:57:42 <vixey> :t \f list -> zipWith f [1..] list
03:57:44 <lambdabot> forall a b c. (Enum a, Num a) => (a -> b -> c) -> [b] -> [c]
03:57:52 <vixey> yeah
03:57:57 <vixey> you can write it like that
03:58:07 <vixey> :t flip zipWith [1..]
03:58:08 <lambdabot> forall a b c. (Enum a, Num a) => (a -> b -> c) -> [b] -> [c]
03:58:14 <povman> @pl (\f l -> (map f.zip [0..]) l)
03:58:15 <lambdabot> (. zip [0..]) . map
03:58:20 <povman> there ya go
03:58:35 <bogomipz> I guess I'll have to use mapAccumL instead of mapIndexed then
03:59:04 <vixey> :t (. zip [0..]) . map
03:59:05 <lambdabot> forall t b b1. (Enum t, Num t) => ((t, b) -> b1) -> [b] -> [b1]
03:59:11 <povman> :t map
03:59:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:59:20 <vixey> you need less currying
03:59:27 <vixey> er.. more
03:59:33 <ivanm> since when did map == fmap? I thought map worked only on lists...
03:59:37 <ivanm> :t fmap
03:59:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:59:50 <vixey> ivanm: It's a correction/adjustment to the prelude
03:59:54 <vixey> :t (.)
03:59:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:59:58 <vixey> :t (++)
03:59:59 <lambdabot> forall m. (Monoid m) => m -> m -> m
04:00:01 <ivanm> vixey: which way?
04:00:09 <povman> eh, why can't map, filter, etc be defined in typeclasses?
04:00:10 <vixey> what do you mean?
04:00:13 <ivanm> as in the prelude specialises it, or generalises it?
04:00:20 <vixey> lambdabot is generalizing
04:00:25 <ivanm> ahhhh
04:00:29 <ivanm> silly lambdabot :p
04:00:43 <mux> lambdabot is haskell' already ;-)
04:00:54 <ivanm> ooohhh....
04:01:02 <aks42> Bye!
04:01:02 <bogomipz> hmm yeah, or maybe there's an even better way to do what I want
04:01:04 <ivanm> without haskell' even being finalised! :D
04:01:14 <ivanm> mux: so lambdabot defines haskell'?
04:01:20 <mux> not at all, I was kidding
04:01:28 <povman> ^^^
04:01:29 <ivanm> seeing how it writes most of our code for us anyway... :p
04:01:33 <mux> even though I hope haskell' will contain those "fixes"
04:01:35 <ivanm> mux: yes, I know...
04:01:38 <mux> (++) generalized back to monoids
04:01:43 <mux> and likewise for map on functors
04:01:56 <ivanm> I thought I read somewhere that they were just going to use fmap, to avoid the Data.Map issue
04:02:18 <povman> mux: .... so we don't have to keep doing Set.map, List.map, Map.map?!
04:02:30 <ivanm> povman: Map.map will remain different AFAIK
04:02:33 <ivanm> @type M.map
04:02:35 <lambdabot> forall a b k. (a -> b) -> M.Map k a -> M.Map k b
04:02:41 <ivanm> then again, maybe not...
04:02:42 <mux> not sure if Map is a functor
04:02:43 <povman> oh of course
04:02:55 <ivanm> M.Map k == functor?
04:02:56 <Saizan> (Map k) is an instance of Functor
04:03:03 <Saizan> Set can't
04:03:08 <luqui> what is the complexity of take k (sort xs)?
04:03:13 <mux> because of the pesky Ord restriction?
04:03:13 <Saizan> unless we change the Functor class
04:03:15 <povman> couldn't Map.map be defined uncurriedly?
04:03:31 <Saizan> mux: yeah
04:03:44 <Saizan> luqui: O(k log n)
04:03:57 <luqui> Saizan, I doubt that
04:04:02 <visof> Using a list comprehension, give an expression that calculates the sum
04:04:02 <Deewiant> O(n log n + k)
04:04:03 <edwardk> set can't be coz you'd need a Sat constraint right?
04:04:03 <visof> 12 + 22 + . . . 1002 of the first one hundred integer squares.
04:04:04 <luqui> you're saying I can find the least element in log n time?
04:04:12 <visof> i made a solution
04:04:19 <Deewiant> luqui: sort is strict
04:04:32 <visof> sum [ (x+1)^2 | x<- [1..99]]
04:04:33 <visof> ??
04:04:38 <mux> > sum [ x^2 | x <- [1..100] ]
04:04:39 <lambdabot>  338350
04:04:39 <vixey> > sum [ (x+1)^2 | x<- [1..99]]
04:04:40 <visof> is this good ?
04:04:41 <lambdabot>  338349
04:04:41 <luqui> Deewiant, that doesn't mean it's n log n
04:04:49 <mux> right, to 99
04:04:57 <luqui> Deewiant, it's not spine-strict
04:05:01 <luqui> (to invent a term)
04:05:09 <visof> another one?
04:05:11 <mux> > sum . map (^2) . take 100 $ [1..]
04:05:12 <lambdabot>  338350
04:05:18 <mux> I like it better without list comprehensions
04:05:18 <luqui> I'm sure that head . sort is O(n)
04:05:32 <visof> okay
04:05:41 <ivanm> visof: how are 12, 22, etc. integer squares?
04:05:59 <luqui> @src sort
04:05:59 <lambdabot> sort = sortBy compare
04:06:02 <luqui> @src sortBy
04:06:02 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
04:06:08 <luqui> oh it's an insertion sort
04:06:18 <Deewiant> no, not really
04:06:36 <Saizan> luqui: the GHC implementation is a merge sort
04:07:13 <luqui> I seem to recall something like O(n + k log n) or O(n + k log k)...
04:07:32 <luqui> and yes I'm saying I don't believe you Deewiant  :-)
04:07:59 <Deewiant> oh, I don't know anything
04:08:02 <Deewiant> that's just what I'd assume
04:08:14 <Deewiant> I'd also assume head . sort == O(n log n) :-P
04:09:20 <mux> actually, if sort is sufficiently lazy, head . sort ... should be able to return before having sorted the whole list
04:09:24 <mux> since it's a foldr
04:09:35 <Deewiant> yes, if, but I don't think it is
04:09:35 <mux> unless I'm missing something
04:09:41 <EvilTerran> indeed. it's O(n), AFAIK
04:09:53 <mux> EvilTerran: makes perfect sense
04:09:58 <EvilTerran> it does still need to check every element at least once
04:10:22 <EvilTerran> however, last.sort is O(n.log n)
04:10:27 <Beelsebob> > let pi acc = (let xs = [1..acc]; ys = [1..acc] in 4 * length (filter id (zipWith (isInCircle (acc `div` 2) xs ys)) / (acc * acc)); isInCircle r x y = (x * x + y * y) < (r * r) in pi 100
04:10:27 <lambdabot> Unbalanced parentheses
04:10:44 <mux> EvilTerran: but can be written head . sortBy (flip compare) ...
04:10:51 <Beelsebob> > let pi acc = (let xs = [1..acc]; ys = [1..acc] in 4 * length (filter id (zipWith (isInCircle (acc `div` 2) xs ys))) / (acc * acc)); isInCircle r x y = (x * x + y * y) < (r * r) in pi 100
04:10:52 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
04:10:52 <lambdabot>       Expected...
04:11:29 <vixey> I think I found a WAM in Haskell
04:11:38 <vixey> well GHC and C
04:11:40 <Beelsebob> > let pi acc = (let xs = [1..acc]; ys = [1..acc] in 4 * length (filter id (zipWith (isInCircle (acc `div` 2)) xs ys)) / (acc * acc)); isInCircle r x y = (x * x + y * y) < (r * r) in pi 100
04:11:42 <lambdabot>   add an instance declaration for (Fractional Int)
04:11:42 <lambdabot>     In the expression:
04:11:42 <lambdabot>    ...
04:11:44 <Beelsebob> bah
04:11:56 <vixey> Beelsebob no don't give up :P
04:11:56 <EvilTerran> mux, indeed
04:12:02 <Beelsebob> getting there I know
04:12:07 <jorick> :)
04:12:14 <Deewiant> > let pi acc = (let xs = [1..acc]; ys = [1..acc] in 4 * length (filter id (zipWith (isInCircle (acc `div` 2)) xs ys)) `div` (acc * acc)); isInCircle r x y = (x * x + y * y) < (r * r) in pi 100
04:12:17 <lambdabot>  0
04:12:21 <Deewiant> :-P
04:12:50 <Beelsebob> > let pi acc = (let xs = [1..acc]; ys = [1..acc] in (fromIntegral (4 * length (filter id (zipWith (isInCircle (acc `div` 2)) xs ys)))) / (acc * acc)); isInCircle r x y = (x * x + y * y) < (r * r) in pi 100
04:12:51 <lambdabot>  Add a type signature
04:12:54 <EvilTerran> > let pi acc = (let xs = [1..acc]; ys = [1..acc] in 4 * length (filter id (zipWith (isInCircle . floor $ acc / 2) xs ys)) / (acc * acc)); isInCircle r x y = (x * x + y * y) < (r * r) in pi 100
04:12:55 <lambdabot>   add an instance declaration for (RealFrac Int)
04:12:55 <mux> @check \s -> last (sort s) == head (sortBy (flip compare) (s :: String))
04:12:57 <lambdabot>  Exception: Prelude.last: empty list
04:13:11 <mux> @check \s -> not (null s) ==> last (sort s) == head (sortBy (flip compare) (s :: String))
04:13:12 <lambdabot>  OK, passed 500 tests.
04:13:16 <EvilTerran> ?type floor
04:13:18 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
04:13:18 * mux hearts quickcheck
04:13:35 <Beelsebob> > let pi acc = (let xs = [1..acc]; ys = [1..acc] in ((fromIntegral (4 * length (filter id (zipWith (isInCircle (acc `div` 2)) xs ys)))) :: Double) / (acc * acc)); isInCircle r x y = (x * x + y * y) < (r * r) in pi 100
04:13:36 <lambdabot>   add an instance declaration for (Integral Double)
04:13:42 <EvilTerran> > let pi acc = (let xs = [1..acc]; ys = [1..acc] in 4 * length (filter id (zipWith (isInCircle .fromIntegral $ acc `div` 2) xs ys)) / (acc * acc)); isInCircle r x y = (x * x + y * y) < (r * r) in pi 100
04:13:43 <lambdabot>   add an instance declaration for (Fractional Int)
04:13:43 <lambdabot>     In the expression:
04:13:43 <lambdabot>    ...
04:13:48 <Beelsebob> bah, got brackets wrong there didn't i
04:13:52 <EvilTerran> ...
04:14:03 <EvilTerran> why is that being made Int?
04:14:12 <Beelsebob> gyah
04:14:30 <mux> EvilTerran: maybe because of the length?
04:14:36 <mux> it's hard to tell without the full error message
04:14:36 <EvilTerran> oh yeah
04:15:06 <byorgey> you can't have acc `div` 2 and then / by (acc * acc)
04:15:12 <EvilTerran> > let pi acc = (let xs = [1..acc]; ys = [1..acc] in 4 * genericLength (filter id (zipWith (isInCircle . fromIntegral . floor $ acc / 2) xs ys)) / (acc * acc)); isInCircle r x y = (x * x + y * y) < (r * r) in pi 100
04:15:15 <lambdabot>  1.4e-2
04:15:17 <EvilTerran> ha!
04:15:20 <Beelsebob> > let pi acc = (let xs = [1..acc]; ys = [1..acc] in ((fromIntegral (4 * length (filter id (zipWith (isInCircle (acc / 2)) xs ys)))) :: Double) / (acc * acc)); isInCircle r x y = (x * x + y * y) < (r * r) in pi 100
04:15:21 <lambdabot>  1.4e-2
04:15:22 <mux> yay :)
04:15:23 <Beelsebob> haha
04:15:28 <byorgey> nice =)
04:15:30 <EvilTerran> and we even got the same answer :)
04:15:31 <Beelsebob> > let pi acc = (let xs = [1..acc]; ys = [1..acc] in ((fromIntegral (4 * length (filter id (zipWith (isInCircle (acc / 2)) xs ys)))) :: Double) / (acc * acc)); isInCircle r x y = (x * x + y * y) < (r * r) in pi 10000
04:15:32 <lambdabot>  1.414e-4
04:15:44 <Beelsebob> yeh, but it doesn't seem to be aproximating pi
04:15:45 <Deewiant> > sqrt 2
04:15:46 <lambdabot>  1.4142135623730951
04:15:50 <Beelsebob> indeed
04:15:54 <EvilTerran> oops :P
04:15:57 <Beelsebob> root 2 approximator instea
04:15:58 <byorgey> haha
04:15:59 <Beelsebob> lol
04:16:03 <mux> but it compiles!
04:16:07 <Deewiant> one irrational number is as good as any
04:16:12 <Beelsebob> rofl
04:16:26 <visof_>  replicate 3 True
04:16:28 <visof_> [True, True, True ]
04:16:30 <visof_> how can i make this function by list comprehension ?
04:16:34 <visof_> replicate n xs = [ (x:[]) ++ replicate (n-1) x | x <- xs] ?
04:16:36 <visof_> replicate n xs = [ (x:[]) ++ replicate (n-1) x | x <- xs] ?
04:16:42 <visof_> replicate n x = [ (x:[]) ++ replicate (n-1) x ] ?
04:16:55 <EvilTerran> replicate n x = [x | _ <- [1..n]]?
04:17:11 <EvilTerran> ?src replicate
04:17:11 <lambdabot> replicate n x = take n (repeat x)
04:17:16 <EvilTerran> doesn't use a comprehension, mind
04:17:45 <mux> replicate n = take n . cycle . []
04:17:46 * Beelsebob ponders why that doesn't generate pi
04:18:00 <mux> replicate n = take n . repeat
04:18:10 <mux> list comprehensions are over-rated :-)
04:18:29 <Deewiant> replicate = repeat >>> (take >>>)
04:18:34 <EvilTerran> Beelsebob, i think you need to square something
04:18:37 <visof_> EvilTerran it's Exercise in Graham Hutton book
04:18:49 <mux> oh.
04:19:02 <visof_> he want to use list comprehension
04:19:03 <EvilTerran> actually, you seem to be squaring the relevant bit. i dunno, then.
04:19:06 <Beelsebob> actually, I think I see why
04:19:14 <Beelsebob> my circle isn't centred on my square
04:19:18 <EvilTerran> oops
04:19:28 <ski> @type repeat >>> (take >>>)
04:19:29 <lambdabot>     Couldn't match expected type `[a]'
04:19:29 <lambdabot>            against inferred type `([a1] -> [a1]) -> d'
04:19:29 <lambdabot>     Probable cause: `>>>' is applied to too few arguments
04:19:46 <Beelsebob> > let pi acc = (let xs = [-acc..acc]; ys = [-acc..acc] in ((fromIntegral (4 * length (filter id (zipWith (isInCircle acc) xs ys)))) :: Double) / (acc * acc)); isInCircle r x y = (x * x + y * y) < (r * r) in pi 100
04:19:46 <Deewiant> darn
04:19:47 <lambdabot>  5.64e-2
04:19:53 <Beelsebob> still not pi though
04:20:26 <Deewiant> @ty take >>> (repeat >>>)
04:20:28 <lambdabot> forall a. Int -> a -> [a]
04:20:30 <Deewiant> got them the wrong way round :-P
04:20:46 <mux> > 4 * atan 1 -- cheting :-)
04:20:46 <lambdabot>  3.141592653589793
04:20:50 <Deewiant> > pi
04:20:51 <lambdabot>  3.141592653589793
04:20:51 <int-e> Beelsebob: you want liftM2 instead of zipWith, I think
04:20:55 <EvilTerran> ?src pi
04:20:55 <lambdabot> Source not found. Maybe if you used more than just two fingers...
04:20:59 <Beelsebob> int-e: why?
04:21:09 <Beelsebob> oh, I see why
04:21:10 <Beelsebob> yeh, I do
04:21:15 <ski> @src Double pi
04:21:16 <lambdabot> Source not found.
04:21:17 <EvilTerran> > acos (-1)
04:21:17 <lambdabot>  3.141592653589793
04:21:26 <Beelsebob> > let pi acc = (let xs = [-acc..acc]; ys = [-acc..acc] in ((fromIntegral (4 * length (filter id (liftM2 (isInCircle acc) xs ys)))) :: Double) / (acc * acc)); isInCircle r x y = (x * x + y * y) < (r * r) in pi 100
04:21:27 <lambdabot>  12.5588
04:21:31 <Beelsebob> rofl
04:21:34 <Deewiant> > 12.5588 / 4
04:21:36 <lambdabot>  3.1397
04:21:37 <Beelsebob> that's looking like 4 pi though
04:21:39 <Beelsebob> awesome
04:21:41 <EvilTerran> ... you're... getting colder...
04:21:42 <EvilTerran> :P
04:21:49 <Beelsebob> > let pi acc = (let xs = [-acc..acc]; ys = [-acc..acc] in ((fromIntegral (length (filter id (liftM2 (isInCircle acc) xs ys)))) :: Double) / (acc * acc)); isInCircle r x y = (x * x + y * y) < (r * r) in pi 10000
04:21:55 <lambdabot> Terminated
04:21:57 <Beelsebob> bah
04:22:00 <Beelsebob> > let pi acc = (let xs = [-acc..acc]; ys = [-acc..acc] in ((fromIntegral (length (filter id (liftM2 (isInCircle acc) xs ys)))) :: Double) / (acc * acc)); isInCircle r x y = (x * x + y * y) < (r * r) in pi 1000
04:22:02 <lambdabot>  3.141521
04:22:06 <Beelsebob> w00t
04:22:13 <Beelsebob> not the fastest bit of code ever though
04:22:34 <mmorrow> sweet
04:22:50 <EvilTerran> k, now simulate the "throwing sausages at a wooden floor" approach :P
04:23:01 * Beelsebob wonders off to do that
04:23:03 <Beelsebob> back in a sec
04:23:04 <ski> i thought it was needles
04:23:06 <EvilTerran> hehehe
04:23:17 <EvilTerran> ski, probably originally, but sausages makes it more memorable :)
04:23:28 <mmorrow> and more delicious
04:24:25 <Moridin419> Hi im having some issues building the latest hdbc sqlite3 driver on my macbook pro, running leopard
04:25:01 <cjs> Ah, I'm starting to learn refactoring techniques.
04:25:09 <Moridin419> during the build process i get some ld errors, but nothing fatal, something about atomic sorts
04:25:26 <cjs> Ê∞óÊåÅ„ÅÑ„ÅÑ
04:27:17 <Moridin419> can anyone help?
04:28:02 <EvilTerran> ?hpaste - Moridin419, can we see the error in full?
04:28:03 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:30:09 <Moridin419> ok just added
04:30:59 <Moridin419> http://hpaste.org/7295
04:31:12 <ivanm> cjs: since when were asian characters refactoring techniques?
04:31:14 <ivanm> :p
04:31:55 <Beelsebob> > let randomList = do {r <- randomRIO (-1,1); rs <- randomList; return (r:rs)}; pi n rs = pi' 0 n n rs; pi' a num 0 _ = a / num; pi' a num n (x:y:rs) = pi' (a + (if isInCircle x y then 1 else 0)) num (n-1) rs; isInCircle x y = (x * x + y * y) < 1 in do {rs <- randomList :: IO [Double]; putStrLn (pi 1000 rs)}
04:31:55 <lambdabot>   add an instance declaration for (Fractional String)
04:32:01 <Beelsebob> interesting
04:32:04 <Beelsebob> oh, I see
04:32:11 <Beelsebob> > let randomList = do {r <- randomRIO (-1,1); rs <- randomList; return (r:rs)}; pi n rs = pi' 0 n n rs; pi' a num 0 _ = a / num; pi' a num n (x:y:rs) = pi' (a + (if isInCircle x y then 1 else 0)) num (n-1) rs; isInCircle x y = (x * x + y * y) < 1 in do {rs <- randomList :: IO [Double]; print (pi 1000 rs)}
04:32:12 <lambdabot>  <IO ()>
04:32:15 <Moridin419> when i do sudo ./setup install it installs fine
04:32:18 <cjs> You'd be surprised!
04:32:29 <bogomipz> does this function have a name?: \(f, x) -> f x
04:32:48 <Beelsebob> > let randomList = do {r <- randomRIO (-1,1); rs <- randomList; return (r:rs)}; pi n rs = pi' 0 n n rs; pi' a num 0 _ = a / num; pi' a num n (x:y:rs) = pi' (a + (if isInCircle x y then 1 else 0)) num (n-1) rs; isInCircle x y = (x * x + y * y) < 1 in do {rs <- randomList :: IO [Double]; print rs}
04:32:48 <ski> @type uncurry id
04:32:49 <lambdabot>  <IO ()>
04:32:50 <lambdabot> forall b c. (b -> c, b) -> c
04:32:56 <ski> bogomipz : ^
04:33:02 <Beelsebob> > let randomList = do {r <- randomRIO (-1,1); rs <- randomList; return (r:rs)}; pi n rs = pi' 0 n n rs; pi' a num 0 _ = a / num; pi' a num n (x:y:rs) = pi' (a + (if isInCircle x y then 1 else 0)) num (n-1) rs; isInCircle x y = (x * x + y * y) < 1 in do {rs <- randomList :: IO [Double]; print (take 1000 rs)}
04:33:03 <lambdabot>  <IO ()>
04:33:16 <Beelsebob> > let randomList = do {r <- randomRIO (-1,1); rs <- randomList; return (r:rs)}; pi n rs = pi' 0 n n rs; pi' a num 0 _ = a / num; pi' a num n (x:y:rs) = pi' (a + (if isInCircle x y then 1 else 0)) num (n-1) rs; isInCircle x y = (x * x + y * y) < 1 in do {rs <- randomList :: [Double]; print (take 1000 rs)}
04:33:17 <lambdabot>  Couldn't match expected type `[Double]'
04:33:24 <ski> Beelsebob : `unsafeInterleaveIO' ?
04:33:38 <Beelsebob> > let randomList = do {r <- randomRIO (-1,1); rs <- randomList; return (r:rs)}; pi n rs = pi' 0 n n rs; pi' a num 0 _ = a / num; pi' a num n (x:y:rs) = pi' (a + (if isInCircle x y then 1 else 0)) num (n-1) rs; isInCircle x y = (x * x + y * y) < 1 in do {rs <- (randomList :: IO [Double]); print (take 1000 rs)}
04:33:39 <lambdabot>  <IO ()>
04:33:43 <Moridin419> i then load up ghci,
04:33:48 <Beelsebob> I'm not sure what I'm missing here
04:33:52 <bogomipz> ski: my function takes a pair and applies fst to snd
04:33:55 <Moridin419> an this is the result -> http://hpaste.org/7296
04:33:56 <ivanm> Beelsebob: you do realise that lambdabot can't return IO stuff as a security measure...
04:34:13 <Beelsebob> ivanm: oh?
04:34:19 <Beelsebob> so it won't do the print, but just complain?
04:34:24 <ivanm> yup
04:34:28 <Beelsebob> why doesn't it just quote the output?
04:34:36 <ivanm> after all, if you had access to the IO monad then you could do _anything_ to the host machine
04:34:40 <ski> bogomipz : so does `uncurry id'
04:34:51 <ivanm> so just use show or something
04:35:05 <ski> (bogomipz : s/id/($)/ if you prefer)
04:35:10 <Beelsebob> > let randomList = do {r <- randomRIO (-1,1); rs <- randomList; return (r:rs)}; pi n rs = pi' 0 n n rs; pi' a num 0 _ = a / num; pi' a num n (x:y:rs) = pi' (a + (if isInCircle x y then 1 else 0)) num (n-1) rs; isInCircle x y = (x * x + y * y) < 1 in do {rs <- (randomList :: IO [Double]); return show (take 1000 rs)}
04:35:11 <Toxaris> @type uncurry ($) -- probably clearer
04:35:13 <lambdabot>  Couldn't match expected type `IO' against inferred type `(->) a'
04:35:13 <lambdabot> forall a b. (a -> b, a) -> b
04:35:16 <Beelsebob> > let randomList = do {r <- randomRIO (-1,1); rs <- randomList; return (r:rs)}; pi n rs = pi' 0 n n rs; pi' a num 0 _ = a / num; pi' a num n (x:y:rs) = pi' (a + (if isInCircle x y then 1 else 0)) num (n-1) rs; isInCircle x y = (x * x + y * y) < 1 in do {rs <- (randomList :: IO [Double]); return $ show (take 1000 rs)}
04:35:17 <lambdabot>  <IO [Char]>
04:35:28 <Beelsebob> ivanm: I'm not following how to get that out of IO
04:35:36 <ivanm> Beelsebob: you can't do _anything_ with IO
04:35:44 <ivanm> so don't even try! :p
04:35:57 <Toxaris> @type app :: (a -> b, a) -> b
04:35:58 <lambdabot> forall a b. (a -> b, a) -> b
04:36:09 <ivanm> just do it on your own machine and paste the result here if you want people to see it
04:36:37 <bogomipz> ski: it sure does :) now i just need to undersand why :P
04:36:52 <ski> Toxaris : *nod*
04:36:56 <Beelsebob> ivanm: I don't want them to see, it's a stack overflow :P
04:37:04 <ski> Beelsebob : use `randomRs' ?
04:37:06 <Toxaris> > app (+ 3, 5) -- ski, bogomipz: actually, a generalization of (uncurry ($)) is called app. but you want (uncurry ($))
04:37:07 <ivanm> @slap Beelsebob
04:37:07 <lambdabot> Come on, let's all slap Beelsebob
04:37:07 <lambdabot>  Parse error at "," (column 9)
04:37:14 <Toxaris> > app ((+ 3), 5) -- ski, bogomipz: actually, a generalization of (uncurry ($)) is called app. but you want (uncurry ($))
04:37:15 <lambdabot>  8
04:37:16 <ivanm> why are you trying to kill lambdabot?!?!?!? :@
04:37:58 <Beelsebob> ski: I've never understood how to get a RandomGen
04:38:13 <ski> @type mkStdGen
04:38:15 <lambdabot> Int -> StdGen
04:38:30 <Beelsebob> I take it the Int provided is a seed
04:38:52 <ivanm> Beelsebob: if you want a _real_ random seed, then you need to use the IO command in the IO monad, and then pass it through to your non-monadic functions
04:38:56 <ivanm> > mkStdGen 10
04:38:57 <lambdabot>  11 1
04:39:00 <Beelsebob> kk
04:39:11 <ivanm> note that it isn't random... it returns the same StdGen each time
04:39:12 <ivanm> > mkStdGen 10
04:39:14 <lambdabot>  11 1
04:39:52 <ski> > let randomList' = randomRs (-1,1); pi n rs = pi' 0 n n rs; pi' a num 0 _ = a / num; pi' a num n (x:y:rs) = pi' (a + (if isInCircle x y then 1 else 0)) num (n-1) rs; isInCircle x y = (x * x + y * y) < 1 in take 20 (randomList' (mkStdGen 42))
04:39:53 <lambdabot>  [1,-1,0,0,1,0,-1,1,-1,-1,-1,-1,-1,1,1,0,1,0,-1,-1]
04:40:03 <bogomipz> Toxaris: the only app hoogle knows is Control.Arrow.app
04:40:16 <Toxaris> bogomipz: that's exactly the app I used :)
04:40:25 <ski> > let randomList' = randomRs (-1,1); pi n rs = pi' 0 n n rs; pi' a num 0 _ = a / num; pi' a num n (x:y:rs) = pi' (a + (if isInCircle x y then 1 else 0)) num (n-1) rs; isInCircle x y = (x * x + y * y) < 1 in take 10 (randomList' (mkStdGen 42) :: [Double])
04:40:26 <lambdabot>  [-0.779185974686217,0.6907969854517833,-0.38443573107580553,0.56277616521408...
04:41:14 <Toxaris> bogomipz: app is a generalization of (uncurry ($)). uncurry ($) works for functions, app works for arrows. functions are a special kind of arrows
04:41:23 <Beelsebob> > let randomList = randomRs (-1,1) (mkStdGen 237650); pi n rs = 4 * pi' 0 n n rs; pi' a num 0 _ = a / num; pi' a num n (x:y:rs) = pi' (a + (if isInCircle x y then 1 else 0)) num (n-1) rs; isInCircle x y = (x * x + y * y) < 1 in pi 100000 (randomList :: [Double])
04:41:25 <lambdabot>  3.14388
04:41:28 <Beelsebob> better :)
04:41:37 <Beelsebob> > let randomList = randomRs (-1,1) (mkStdGen 3948756); pi n rs = 4 * pi' 0 n n rs; pi' a num 0 _ = a / num; pi' a num n (x:y:rs) = pi' (a + (if isInCircle x y then 1 else 0)) num (n-1) rs; isInCircle x y = (x * x + y * y) < 1 in pi 100000 (randomList :: [Double])
04:41:38 <lambdabot>  3.14948
04:41:41 <Toxaris> bogomipz: but since you probably don't want to worry about arrows, you should use (uncurry ($))
04:41:49 <Beelsebob> heh, *bad* random seed :P
04:42:16 <Toxaris> Beelsebob: shouldn't all random seeds be equally good?
04:42:25 <bogomipz> Toxaris: map Control.Arrow.app theList actually did what i wanted, though
04:42:35 <visof_> > let pyth n = [(x,y,z) | x,y,z <- [1..n] , (^2 + y^2) = z^2] in pyth 10
04:42:35 <lambdabot>  Parse error at "=" (column 54)
04:42:36 <bogomipz> but i don't know the first thing about arrows
04:42:36 <Beelsebob> if the random number generator is good, and the output list used is infinite
04:42:37 <Beelsebob> then yes
04:42:47 <Beelsebob> > let randomList = randomRs (-1,1) (mkStdGen 3948756); pi n rs = 4 * pi' 0 n n rs; pi' a num 0 _ = a / num; pi' a num n (x:y:rs) = pi' (a + (if isInCircle x y then 1 else 0)) num (n-1) rs; isInCircle x y = (x * x + y * y) < 1 in pi 500000 (randomList :: [Double])
04:42:51 <lambdabot>  3.139728
04:42:57 <bogomipz> i better grasp why (uncurry id) and (uncurry ($)) is the same thing, though
04:42:58 <Toxaris> bogomipz: oh you have a list. what about (zip ($) theList)
04:43:04 <Beelsebob> > let randomList = randomRs (-1,1) (mkStdGen 3948756); pi n rs = 4 * pi' 0 n n rs; pi' a num 0 _ = a / num; pi' a num n (x:y:rs) = pi' (a + (if isInCircle x y then 1 else 0)) num (n-1) rs; isInCircle x y = (x * x + y * y) < 1 in pi 5000000 (randomList :: [Double])
04:43:11 <lambdabot>  Exception: Time limit exceeded
04:43:21 <visof_> > let pyth n = [(x,y,z) | x,y,z <- [1..n] , (^2 + y^2) = (z^2)] in pyth 10
04:43:21 <lambdabot>  Parse error at "=" (column 54)
04:43:26 <Beelsebob> myeh, so the sausages approach is no better really
04:43:29 <bogomipz> Toxaris: nope, it's a list of pairs, needs the uncurry
04:43:30 <visof_> what is the problem?
04:43:37 <Toxaris> bogomipz: try it
04:43:41 <Beelsebob> > let randomList = randomRs (-1,1) (mkStdGen 3948756); pi n rs = 4 * pi' 0 n n rs; pi' a num 0 _ = a / num; pi' a num n (x:y:rs) = pi' (a + (if isInCircle x y then 1 else 0)) num (n-1) rs; isInCircle x y = (x * x + y * y) < 1 in pi 1000000 (randomList :: [Double])
04:43:43 <visof_> > let pyth n = [(x,y,z) | x,y,z <- [1..n] , (x^2 + y^2) = (z^2)] in pyth 10
04:43:43 <lambdabot>  Parse error at "=" (column 55)
04:43:49 <lambdabot>  Exception: Time limit exceeded
04:44:05 <Beelsebob> in fact, it's worse -- the every point method worked for 1000x1000
04:44:06 <bogomipz> Toxaris: oh zip, not map
04:44:43 <ski> Beelsebob : that's Monte-Carlo, yes ?
04:44:48 <Toxaris> bogomipz: indeed. but I mean zipWith of course.
04:44:53 <Toxaris> no I don't
04:45:05 <Toxaris> bogomipz: sorry that's all nonsense
04:45:08 <cjs> Ooo. I used my first unprompted list comprehension.
04:45:27 <Beelsebob> ski: yes
04:45:30 <bogomipz> yea, i couldn't get that flying
04:45:43 <Toxaris> bogomipz: you have already a zipped list, kind of
04:46:02 <Toxaris> bogomipz: since you already have [(a -> b, a)] and want to go to [b]
04:46:08 <Beelsebob> interestingly, the deterministic version worked faster ski
04:46:10 <bogomipz> yes, it was made by zipping a list of functions with a list of data
04:46:30 <cjs> Wow, those work really well, too.
04:46:55 <Toxaris> bogomipz: so you could maybe use (zipWith ($)) instead of zip
04:47:01 <ski> map (uncurry ($)) (zip fs xs) = zipWith ($) fs xs
04:47:04 <bogomipz> map (uncurry id) theList worked, not sure why that's the same as (uncurry ($))
04:47:19 <ski> @src ($)
04:47:19 <Toxaris> bogomipz: look at the types of id and ($)
04:47:19 <lambdabot> f $ x = f x
04:47:22 <ski> @src id
04:47:23 <lambdabot> id x = x
04:47:31 <visof_> what should i do?
04:47:51 <ski> @src uncurry
04:47:51 <vixey> (id f) x = f x = f $ x = ($) f x = (($) f) x
04:47:51 <lambdabot> uncurry f p = f (fst p) (snd p)
04:47:57 <bogomipz> Toxaris: they are different, still uncurrying them gives the same thing
04:48:01 <vixey> -> id = ($)
04:48:08 <Toxaris> @type id
04:48:09 <lambdabot> forall a. a -> a
04:48:11 <Toxaris> @type ($)
04:48:12 <lambdabot> forall a b. (a -> b) -> a -> b
04:48:21 <vixey> :t flip (flip id)
04:48:22 <lambdabot> forall a c. (a -> c) -> a -> c
04:48:24 <Toxaris> bogomipz: instantiate a in the type of id by (a -> b)
04:48:54 <ski> bogomipz : `($)' is a specific instance of `id', just as `id :: Bool -> Bool' is an instance of the general `id :: a -> a'
04:49:38 <bogomipz> ski: i'm starting to grasp that they become the same because of implicit currying
04:49:48 <ski> *nod*
04:50:21 <vixey> bogomipz: do yo know f x y z = (((f x) y) z) ?
04:50:43 <bogomipz> yes, that's what i just said
04:50:49 <bogomipz> implicit currying
04:50:54 <vixey> this is not currying
04:51:06 <Toxaris> interesting approach. we have f $ x = f x, which is shorthand for ($) = \f -> \x -> f x which is \f -> f by eta reduction.
04:51:06 <bogomipz> no?
04:51:18 <vixey> curry is when you take a n-ary function and retirn a series of nested 1-ary functions
04:51:34 <vixey> e.g. ((p,q) -> x) -> (p -> q -> x)
04:51:56 <bogomipz> like (f x) above which gives a function of y and z
04:52:12 <vixey> that's just function application
04:52:41 <Toxaris> it's application of a curried function
04:52:43 <bogomipz> depends on how you look at it, i suppose
04:52:46 <vixey> (The language decision choice to make f x y z = (((f x) y) z) is probably due to currying)
04:53:10 <jorick> ((p,q) -> x) -> (p -> q -> x) isn't currying
04:53:13 <vixey> :t curry
04:53:15 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
04:53:37 <vixey> jorick: in general "curry is when you take a n-ary function and retirn a series of nested 1-ary functions"
04:54:06 <jorick> In computer science, currying, invented by Moses Sch√∂nfinkel and Gottlob Frege, is the technique of transforming a function that takes multiple arguments into a function that takes a single argument (the other arguments having been specified by the curry).
04:54:21 <vixey> joric: correct :P exactly the same thing
04:54:25 <jorick> curry isn't accuratly named than
04:54:25 <vixey> (lambda (x y z) ...) =curry=> (lambda (x) (lambda (y) (lambda (z) ...)))
04:54:30 <jorick> yes but
04:54:30 <idnar> jorick: (p -> q -> x) is a function that takes one argument
04:54:41 <ski> curry is curried :)
04:54:44 <jorick> the act of currying (imo) implies filling all the args
04:55:08 <MyCatVerbs> Curry is delicious.
04:55:09 <bogomipz> the way i understand haskell, all functions take a single argument
04:55:10 <ski> jorrick_curry :: ((a,b) -> c,a) -> (b -> c)  -- ?
04:55:25 <MyCatVerbs> bogomipz: except functions that take no arguments. :)
04:55:47 <bogomipz> () looks an afoul lot like no arguments :P
04:55:52 <ski> bogomipz : other values, you mean :)
04:56:03 <Toxaris> MyCatVerbs: i would not call them functions if they don't take arguments
04:56:11 <bogomipz> *awful
04:56:11 <ski> s/bogomipz/MyCatVerbs/
04:56:34 <vixey> Toxaris: sometimes it's useful to call them zero arg functions, sometimes not ..
04:56:51 <Toxaris> MyCatVerbs: There are values, and some values are functions. if it's a function, it's type has (->) as top-level constructor, and you can apply it to some value.
04:57:02 <MarTHiNUS> hi all.. i need help..
04:57:19 <MyCatVerbs> Toxaris: semantically Haskell quibbleth not over the difference between a zero-argument function and a value.
04:58:00 <MarTHiNUS> http://hpaste.org/7297
04:58:31 <MarTHiNUS> ERROR "Let-exp.hs":4 - Syntax error in expression (unexpected symbol "r2")
04:58:32 <Twey> 3 is a function that takes no arguments and returns 3, which is a function which takes no arguments and returns 3, which is a function which...
04:58:45 <MarTHiNUS> y ?
04:58:55 <Twey> z!
04:58:58 <Deewiant> > fix (const 3)
04:58:59 <lambdabot>  3
04:59:10 <Twey> Your indentation is wrong, MarTHiNUS
04:59:14 <Philippa> MyCatVerbs: sure it does - there's no such thing as a zero-argument function
04:59:26 <Twey> You need an extra space before those two so they line up with the d
04:59:28 <vixey> > (const 3) (const 3) (const 3) undefined
04:59:29 <lambdabot>        add an instance declaration for (Num ((b -> t) -> a -> a1))
04:59:35 <nomeata> > fix show
04:59:36 <vixey> > (const 3) ((const 3) ((const 3) undefined))
04:59:37 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
04:59:37 <lambdabot>  3
04:59:38 <Toxaris> MyCatVerbs: Clearly in haskell, all functions are values (as i said)
04:59:41 <MarTHiNUS> indentation wrong ? ok let me try
05:00:07 <red75> f: emptyset -> value
05:00:17 <MarTHiNUS> wow.. thx alot
05:00:24 <Twey> Welcome
05:00:25 <cjs> MyCatVerbs, it makes you wonder why none of _The LIttle ..._ series uses curry.
05:00:29 <MarTHiNUS> indentation is a problemm ic ic
05:00:31 <ski> red75 : aka the empty function
05:00:46 <MyCatVerbs> Philippa: sure there is. Just think of (at type-level) something that works like foldr (->) value []
05:01:19 <Philippa> MyCatVerbs: that's still not a function. That's something you're layering on top of the actual semantics for your own sake
05:01:32 <Philippa> there is no equivalent of [] for functions
05:02:07 <MyCatVerbs> cjs: dunno, never read'm.
05:02:26 <Philippa> the closest thing we actually have to a zero-parm function is the type () -> _ (by slightly extended isomorphism)
05:02:38 <Twey> MyCatVerbs: If you don't like it you can always use the braces and semicolons.
05:02:55 <bogomipz> luqui: my quotedWords function is done
05:03:01 <bogomipz> it only took me 3 hours to write two lines of code, it's almost like i've learned haskell already :P
05:03:12 <ski> s/MyCatVerbs/MarTHiNUS/
05:03:23 <Twey> Yep, sorry.
05:03:24 <MyCatVerbs> Philippa: why couldn't it be? All I'm doing there is expressing function types in a different form.
05:03:25 <Philippa> MarTHiNUS: indentation's based on the position of the left-most non-whitespace char on a line
05:03:35 <Philippa> MyCatVerbs: it's not a matter of whether it could be. It isn't.
05:04:15 <MyCatVerbs> Philippa: and yet the results you get are observationally no different either way.
05:05:02 <Philippa> yeah, and they're no different if I claim evaluation is done by invisible pixies either
05:05:38 <MyCatVerbs> Philippa: nothing works out differently if you express it that way, and it *does* more intuitively explain why a value with a totally uninteresting type can require massive quantities of time and space to force.
05:05:41 <Philippa> function has a definition in Haskell. It has a further common meaning defined by isomorphism - but that isomorphism doesn't exist for a notion of 'nullary function', even if we know exactly what it would look like
05:05:41 <bogomipz> Toxaris: thanks for the zipWith ($) hint, it simplified matters
05:06:04 <visof_>  A triple (x, y, z) of positive integers can be termed pythagorean if x2 +
05:06:04 <visof_>  y 2 = z 2 . Using a list comprehension, define a function pyths :: Int ‚Üí
05:06:04 <visof_>  [(Int, Int, Int )] that returns the list of all pythagorean triples whose
05:06:04 <visof_>  components are at most a given limit
05:06:12 <visof_>                                             For example:
05:06:13 <visof_> > pyths 10
05:06:13 <visof_> [(3, 4, 5), (4, 3, 5), (6, 8, 10), (8, 6, 10)]
05:06:14 <lambdabot>   Not in scope: `pyths'
05:06:15 <Philippa> MyCatVerbs: the 'right' explanation there is 'when you translate into a strict language, you /get/ a nullary function or an encoding thereof'
05:06:28 <visof_> > let pyth n = [(x,y,z) | x,y,z <- [1..n] , (^2 + y^2) = (z^2)] in pyth 10
05:06:28 <lambdabot>  Parse error at "=" (column 54)
05:06:41 <visof_> any help
05:06:46 <visof_> ?
05:06:51 <Philippa> (the traditional method gives you the () -> _ type, because it's also working in a calculus with no nullary functions)
05:06:52 <ski> ==
05:06:58 <MyCatVerbs> Philippa: someone coming from an imperative background sees a value of some arbitrary type and would presume that it must take O(1) to evaluate anything with no arguments, because in strict languages that's just a pointer read.
05:07:10 <ski> > let pyth n = [(x,y,z) | x,y,z <- [1..n] , (x^2 + y^2) == (z^2)] in pyth 10
05:07:11 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Expr'
05:07:26 <Philippa> MyCatVerbs: someone coming from an imperative language will likely benefit from the distinction between "what function means in haskell" and "what function means in the other languages I've used"
05:07:34 <Toxaris> MyCatVerbs: Haskell is not a strict language. surprise.
05:07:36 <MyCatVerbs> Philippa: whereas the operation of Haskell's thunks corresponds more closely to closures, which are usually explained as functions.
05:07:39 <Deewiant> > [x | x,y <- [1..10] ]
05:07:40 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Expr'
05:07:43 <ski> > let pyth n = [(x,y,z) | x <- [1..n] , y <- [1..n] , z <- [1..n] , (x^2 + y^2) == (z^2)] in pyth 10
05:07:45 <lambdabot>  [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
05:07:45 <Deewiant> > [x | x <- [1..10], y <- [1..10] ]
05:07:47 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4...
05:08:01 <Philippa> MyCatVerbs: yes. All I'm arguing for is *not wilfully conflating two concepts that have the same name in different contexts*
05:08:07 <ski> > let pyth n = [(x,y,z) | [x,y,z] <- replicateM 3 [1..n] , (x^2 + y^2) == (z^2)] in pyth 10
05:08:08 <Philippa> *In Haskell*, there are no nullary functions
05:08:09 <lambdabot>  [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
05:08:12 <vixey> > let trip (u,v) = (2*u*v, u^2 - v^2, u^2 + v^2) ; let uvs = [(u,v)| u <- [1..] ; v <- [1..u-1] ; u`gcd`v == 1 ] in map trip uvs
05:08:12 <lambdabot>  Parse error at "let" (column 50)
05:08:18 <MyCatVerbs> Toxaris: yes. Calling an evaluable thunk a zero-argument function makes plain the idea that it can take arbitrary quantities of time or space to evaluate.
05:08:20 <vixey> > let trip (u,v) = (2*u*v, u^2 - v^2, u^2 + v^2) ; uvs = [(u,v)| u <- [1..] ; v <- [1..u-1] ; u`gcd`v == 1 ] in map trip uvs
05:08:21 <lambdabot>  Parse error at ";" (column 75)
05:08:27 <vixey> > let trip (u,v) = (2*u*v, u^2 - v^2, u^2 + v^2) in let uvs = [(u,v)| u <- [1..] ; v <- [1..u-1] ; u`gcd`v == 1 ] in map trip uvs
05:08:28 <lambdabot>  Parse error at ";" (column 80)
05:08:30 <vixey> :(
05:08:40 <Deewiant> vixey: no semicolon in list comprehensions
05:08:47 <vixey> oh thank you
05:08:50 <vixey> > let trip (u,v) = (2*u*v, u^2 - v^2, u^2 + v^2) ; uvs = [ (u,v) | u <- [1..] , v <- [1..u-1] , u`gcd`v == 1 ] in map trip uvs
05:08:51 <lambdabot>  [(4,3,5),(6,8,10),(12,5,13),(8,15,17),(24,7,25),(10,24,26),(20,21,29),(30,16...
05:09:01 <vixey> sorry I never use list comprehesions :/
05:09:04 <MyCatVerbs> Philippa: all *I*'m asking for is to not draw arbitrary distinctions between things that are entirely isomorphic.
05:09:17 <Deewiant> neither do I, really
05:09:22 <Deewiant> but it helps to know their syntax anyway ;-)
05:09:33 <Philippa> MyCatVerbs: Fine. But I'm not drawing an arbitrary distinction
05:09:38 <vixey> > let trip (u,v) = (2*u*v, u^2 - v^2, u^2 + v^2) ; uvs = [ (u,v) | u <- [1..] , v <- [1..u-1] , u`gcd`v == 1 ] in map (\(x,y,z) -> (x^2+y^2,z^2)) (map trip uvs)
05:09:40 <lambdabot>  [(25,25),(100,100),(169,169),(289,289),(625,625),(676,676),(841,841),(1156,1...
05:09:46 <vixey> oh wow it actually worked :P
05:10:40 <MarTHiNUS> then y i type quad (1,2,3) is error ?
05:10:44 <Philippa> your isomorphism is between other languages' functions and Haskell terms. Distinguishing between other languages' functions and Haskell's thus has actual value because they're not isomorphic
05:10:50 <ski> vixey : how does that work ?
05:11:25 <MarTHiNUS> Program error: argument out of range
05:12:11 <vixey> (2uv)^2 = 4 u^2 v^2, (u^2 - v^2)^2 = u^4 - 2 u^2 v^2 + v^4, sum both those = u^4 + 2 u^2 v^2 + v^4
05:12:13 <MarTHiNUS> http://hpaste.org/7297 --> with correct indentation already
05:12:24 <vixey> (u^2 + v^2)^2 = that,
05:12:29 <MyCatVerbs> Philippa: no, my isomorphism is between Haskell's functions and Haskell's values. There's also a seperate one between Haskell's values (thunks) and other languages' closures, which is just a nice way of explaining lazy evaluation in more concrete terms than handwavey "nothing is calculated until it is needed".
05:12:34 <mauke> MarTHiNUS: that indentation looks wrong
05:12:45 <vixey> so when u`gcd`v == 1 you always get primitive pythagorean triples
05:13:21 <vixey> proof of that is like, there's no which divides all, where 2*u*v, u^2 - v^2 and u^2 + v^2
05:13:28 <Philippa> MyCatVerbs: so you're even conflating which isomorphism you're using for purpose of argument. Nice.
05:13:31 <vixey> there's no number*
05:13:35 <ski> vixey : neat
05:13:42 <MyCatVerbs> Philippa: yeah, my bad.
05:13:58 <vixey> (proof that it generates every PPT I forgot :()
05:14:10 <MarTHiNUS> mauke.. yup thats wrong.. but i fixed it already.. and when i type quad (1,2,3) is error too... what
05:14:15 <MarTHiNUS> what's wrong ?
05:14:26 <MarTHiNUS> Program error: argument out of range
05:14:34 <MyCatVerbs> Philippa: it's just that using both explains why something whose type looks like it should only ever take a single cycle to read in from memory can actually take unbounded time.
05:14:38 <Philippa> I do think using isomorphisms that're also (pairs of) endomorphisms without declaring them is a bad idea. Currying works because the only 'real' overlap is single-parm functions where it's actually the same object
05:15:14 <mauke> MarTHiNUS: you're passing a negative number to sqr
05:15:57 <Philippa> sure. But I'd far rather make the isomorphism explicit. That means not telling people who correctly say "haskell only has single-parm functions" that they're wrong - they're not, and even when it's a complete newbie who doesn't get currying yet the right thing is to confirm the fact they've got before explaining the isomorphism
05:16:29 <Toxaris> MyCatVerbs: I agree with you that it is sensible to *explain* Haskell non-function values as nullary functions in some contexts, but I strongly disagree with *calling* them nullary functions.
05:16:54 <vixey> (,) is product
05:17:03 <vixey> (p,q) -> x *is* a 2-ary function
05:17:25 <vixey> p :*: q -> x
05:17:36 <ski> vixey : and `id' ?
05:17:40 <Philippa> vixey: that's proof-by-notation. The pun's intentional, sure
05:17:57 <Toxaris> MyCatVerbs: clearly the set of values in Haskell can be divided into two disjunct subset: values in subset 1 can be applied to other values, and values in subset 2 can't. clearly, subset 1 is called functions. what's the point of calling subset 2 also functions. it's just confusing.
05:18:31 <Philippa> but the concept '2-ary function' doesn't exist per se in Haskell, and (p,q) -> x has no stronger a claim to being one than p -> q -> x does
05:18:34 <MarTHiNUS> http://hpaste.org/7298 --> thats my new code... negative number to sqrt ?
05:19:15 <MyCatVerbs> Philippa, Toxaris: aye, okay.
05:19:32 <Philippa> if you really want to be 'silly', "2-ary" is a domain concept which we're embedding in haskell :-)
05:19:34 <vixey> @src Complex
05:19:34 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
05:20:04 <Toxaris> Philippa: and curry and uncurry are converting between different embeddings of the same domain concept
05:20:10 <vixey> MarTHiNUS: you could write if descriminant < 0 then (real :+ imag, ...) else (..., ...)
05:20:11 <mauke> MarTHiNUS: a=1, b=2, c=3. b*b - 4*a*c == 2*2 - 4*1*3 == 4 - 12 == -8
05:20:12 <MyCatVerbs> I still like the analogy to closures for explaining lazy eval, but you're right, it's not really useful for anything other than explaining L.E. (or how L.E. can be implemented).
05:21:24 <Philippa> MyCatVerbs: you can't fully explain lazy (as opposed to call-by-name) evaluation without mutability either, 'sjust one of those things
05:21:27 <Toxaris> MarTHiNUS: consider quad (2, 1, 1)
05:21:43 <MarTHiNUS> ooooo
05:21:54 <MarTHiNUS> y cant negative number ?
05:22:27 <ski> > sqrt (-1)
05:22:28 <lambdabot>  NaN
05:22:29 <Toxaris> MarTHiNUS: well there is no sqrt of a negative number.
05:22:31 <Deewiant> > sqrt (-1) :: Int
05:22:32 <lambdabot>   add an instance declaration for (Floating Int)
05:22:32 <lambdabot>     In the expression: sqrt ...
05:22:51 <MarTHiNUS> ooo my badd u guys r rite
05:22:52 <Philippa> FWIW, you get a lot pickier about the semantic details when you write programs that absolutely rely on eg there only being single-parm functions. I'm probably spending too much time with interpreters and typecheckers and so forth
05:22:56 <MarTHiNUS> yup thx alott
05:23:01 <Deewiant> > round (sqrt (-1)) :: Int
05:23:02 <lambdabot>  0
05:23:14 <vixey> > round NaN
05:23:14 <red75> so, the function application can produce non functions...
05:23:15 <lambdabot>   Not in scope: data constructor `NaN'
05:23:33 <vixey> Philippa impossible :)
05:23:34 <MyCatVerbs> Philippa: well yeah, but not such an issue. People coming from an imperative background will find it perfectly natural that iff (f args) is guaranteed to give no side effects and always return the same value no matter when you call it, you might as well write a version of f that caches its result.
05:23:47 <Philippa> vixey: I accidentally read a lambda into what you wrote earlier, so the 'proof by notation' comment's not really justified. Sorry 'bout that
05:24:22 <MyCatVerbs> Philippa: no, that's actually a sign that I'm spending too -little- time with 'terps and typecheckers. :)
05:24:27 <Toxaris> red75: indeed. consider (const ()), which always returns a non-function when applied to whatever
05:24:47 <Philippa> MyCatVerbs: not always, but yeah. Still, I tend to find it useful to make it clear which semantic level I'm working at - I swear 95% of the stuff the typechecker catches in my own code is that kind of error
05:26:18 <MyCatVerbs> Philippa: 66% of the stuff the typechecker catches in my code is me forgetting one of the arguments to some function, or putting them in the wrong order. The rest is me being blatantly, fundamentally stupid, like trying to pass a [Char] to unlines. :)
05:26:18 <kiris> @pl pile t b = find (elem b) t
05:26:19 <lambdabot> pile = flip (find . elem)
05:26:50 <Philippa> MyCatVerbs: I'm exaggerating a little, but 95% of my time spent fixing type errors is indeed on such things
05:27:54 <Philippa> it lets me write code significantly more complex than I'd manage otherwise, so it's very much a good thing
05:29:02 <MyCatVerbs> Philippa: oh aye, certainly. This is one of the reasons I really can't imagine switching from Haskell to Lisp - the sheer amount of times I see myself breaking stuff in silly ways.
05:29:10 <MarTHiNUS> what command to show value of d ?
05:29:11 <MarTHiNUS> show d ?
05:29:44 <MyCatVerbs> Philippa: and the fact that I can safely write a ten-argument function in Haskell and call it correctly. Though I do try to avoid doing that, it happens anyway sometimes. ^_^
05:31:00 <red75> Philippa: so, haskell functions aren't isomorphic to lambda-expressions. are they?
05:31:04 <Toxaris> > show 14 -- MarTHiNUS: show converts stuff to string representations
05:31:06 <lambdabot>  "14"
05:32:26 <Toxaris> > print 14 -- MarTHiNUS: print is one way of producing an IO action which prints something to the console.
05:32:26 <Philippa> red75: lambda-expressions in which language? You can certainly write all haskell code in a form where all top-level and let patterns contain a single variable and in which pattern matching is all done via case
05:32:27 <lambdabot>  <IO ()>
05:32:59 <Philippa> it's not quite an isomorphism though
05:33:27 <Philippa> you can translate both ways, and the code'll be semantically equivalent but you won't necessarily get the same syntax back again
05:33:28 <red75> in lambda-calculus
05:33:32 <MyCatVerbs> red75: hmmm? I'd think they are. Just write a function that converts Haskell's integers into Church numerals (and then encode all other types in the natural numbers) and you're done quite happily.
05:34:11 <MyCatVerbs> red75: heck, you could quite probably write a Haskell compiler that used Church numerals for the representations of, well, everything. It'd just be fantastically slow.
05:34:23 <Philippa> yep, what MyCatVerbs said re types and pattern-matching. It's not an isomorphism, but it's an embedding
05:34:23 <Toxaris> Philippa, red75, MyCatVerbs: are you talking about lambda terms and Haskell syntax or about functions denotated by lambda terms and functions denotated by Haskell syntax?
05:35:03 <Philippa> Toxaris: when I talk about semantics I'm talking about the denoted functions
05:35:21 <red75> i was talking about denotated functions.
05:35:39 <Toxaris> Philippa: so it's not a question of what "syntax you get"
05:35:50 <MyCatVerbs> Toxaris: I was under the impression that red75 was pointing out that Haskell's datatypes aren't functions (whereas in Church's formulation of lambda-calculus, all values are expressed as functions) so I just pointed out that you could quite happily write a Haskell compiler or 'terp which used Church numerals to represent all its data types.
05:35:58 <Philippa> the untyped lambda calculus is turing complete, as is simply-typed lambda calculus with a fixpoint operator or letrec
05:36:48 <Philippa> so yes, all haskell functions can be expressed in them via an appropriate embedding of the types. It's not an isomorphism though
05:36:57 <Philippa> isomorphic means something pretty specific
05:37:46 <Toxaris> hmm the meaning of "isomorphic" depends on the structure we are talking about
05:39:06 <Philippa> Toxaris: there're multiple possible embeddings of a type into the untyped lambda calculus, and the untyped lambda calculus can't make 'nominal' distinctions between types
05:39:21 <Philippa> so there's information lost in the embedding
05:39:39 <Philippa> in the untyped lambda calculus, there's only one id, not one per type
05:39:39 <MyCatVerbs> Philippa: I thought all you needed for an isomorphism was to be able to map both ways while keeping the semantics intact?
05:39:56 <Philippa> MyCatVerbs: it's not "keeping the semantics intact". It's that mapping there and back is id
05:40:37 <Philippa> and even then: if I've got two structurally identical types...
05:40:58 <MyCatVerbs> Philippa: please elaborate? Like Church numerals are isomorphic to naturals, but you usually write something slightly more complicated than id to do tha mapping.
05:40:58 <Philippa> typeclasses muck things up somewhat too
05:41:28 <Toxaris> MyCatVerbs: haskell2lambda . lambda2haskell == lambda2haskell . haskell2lambda = id
05:41:42 <MyCatVerbs> Philippa: and even if you do lose some of the type information when you map Haskell to an untyped language, can't you always regain it when mapping back by inferring it all?
05:41:50 <vixey> == not caring about types though..
05:41:51 <MyCatVerbs> Toxaris: oh, I see.
05:41:52 <Bonus> whoop guys check this out
05:41:54 <Philippa> no, not even for Haskell98
05:42:05 <MyCatVerbs> Philippa: oh, okay.
05:42:10 <Philippa> Haskell98 supports polymorphic recursion, and inference for that's not decidable without annotation
05:42:24 <Toxaris> Philippa: what role play types in the semantics of Haskell?
05:42:25 <Philippa> also, no because you can't distinguish structurally identical types
05:42:35 <Bonus> guys do you know what's up with this http://hpaste.org/7302
05:42:42 <Bonus> if i try to compile that utterly simple program
05:42:45 <Bonus> i get those weird errors
05:42:49 <Philippa> data Nat = Z | S Nat; data Nat' = Z' | S' Nat'; -- how do you tell their embeddings apart?
05:42:53 <mauke> Bonus: try ghc --make
05:43:08 <Bonus> aha
05:43:09 <red75> map it to different labda terms.
05:43:10 <Bonus> what does that do
05:43:19 <Bonus> whoo it works
05:43:21 <mauke> Bonus: automatic dependency resolution
05:43:22 <Philippa> red75: you can't. HTH, HAND :-)
05:43:43 <Bonus> thanks!
05:44:01 <MyCatVerbs> Bonus: basically you never, ever use ghc *expect* with --make in practice, unless you have some really specific reason not to.
05:44:12 <MyCatVerbs> ...expect? *except, sorry
05:44:23 <Bonus> aha
05:44:26 <Bonus> so always use --make then
05:44:28 <mauke> __stginit_regex-posix-0.72.0.2_Text.Regex.Posix_
05:44:30 <Philippa> Toxaris: static or dynamic?
05:44:43 <MyCatVerbs> Yes. Makes everything nice and easy and Just Work, More Or Less.
05:44:46 <Philippa> also, ultimately it's fair to ask "what semantics?" - there's no formal semantics
05:44:49 <Bonus> kewl
05:44:57 <Toxaris> Philippa: we are talking about dynamic semantics, aren't we. "functions denoted by terms" sounds like dynamic semantics
05:45:01 <Bonus> i didn't know about that, i usually just import stuff into ghci :)
05:45:35 <Philippa> Toxaris: id :: Nat -> Nat != id :: Nat' -> Nat'. That's the role
05:45:51 <MyCatVerbs> Philippa: doesn't H98 define formal semantics?
05:46:03 <Philippa> MyCatVerbs: nope. You get equational reasoning, but that's your lot
05:46:39 <MyCatVerbs> So the H98 report is really no better than K&R in that respect.
05:46:51 <MyCatVerbs> (Nor significantly worse either, presumably.)
05:47:15 <dcoutts_> MyCatVerbs: you don't get much equational reasoning in K&R
05:47:16 <Duddle> why is there a difference between "Int" and "Integer"?
05:47:26 <dcoutts_> Duddle: size and performance
05:47:50 <Philippa> MyCatVerbs: it's a stronger definition than K&R. You can write easily-verifiable informal proofs with it
05:47:58 <muhtimin> is there a context where i'd be better off using int instead of integer, by the way?
05:48:32 <red75> Integer is arbitrary precision
05:48:35 <funktio> muhtimin: if you know that it will not overflow, and it needs to run fast
05:48:40 <dcoutts_> muhtimin: if the performance or memory use is important and you know that the numbers will not be "too large"
05:49:38 <kiris> valid x y = isJust x && isJust y
05:49:38 <Toxaris> Philippa: so what's the denotation of (\x -> x) :: a -> a?
05:49:38 <kiris> valid' = (&&) `on` isJust
05:49:41 <kiris> which is better?
05:49:49 <dcoutts_> muhtimin: Int is usually 32 or 64 bit (depending on the machine and Haskell compiler) but is only guaranteed to be 29 bits iirc
05:49:52 <Philippa> Toxaris: an entire family of functions
05:50:13 <muhtimin> okay, thanks
05:50:20 <Philippa> consider it as (\x->x) :: forall a.a -> a for a moment...
05:50:43 <Philippa> you're not looking at a function until you strip off the forall by instantiating a, right?
05:51:13 <Toxaris> what means "looking at a function" here?
05:51:43 <Philippa> the type "forall a.a->a" isn't a function
05:51:59 <Philippa> you can tell, the outermost thing's the forall
05:52:18 <Toxaris> oh ok I see.
05:52:31 <Philippa> we can freely instantiate it to /get/ a function, and so it's commonly referred to as a 'polymorphic function'
05:52:44 <vixey> (\A x -> x) :: Pi (a :: A) . (Pi (_ :: a) . a) -- isn't it the same as this?
05:52:54 <vixey> might have put things in wrong places ...
05:52:57 <Philippa> vixey: different calculus :-)
05:53:25 <Philippa> also, IIRC there's a slightly more general term than 'function' at that point?
05:53:30 <Philippa> PTSes're fun though
05:54:12 <vixey> I suppose they are just expressions, since it may be a type or a value
05:54:16 <vixey> I don't really know
05:55:38 <Philippa> the (a :: A) would be (A : *) in the most common PTSes
05:56:41 <Philippa> I think. Meh, I should get breakfast :-)
05:56:56 <Toxaris> Philippa: so we are talking about id_a = /\ a -> \x -> x, and id_Nat = id Nat
05:57:30 <MyCatVerbs> vixey: what on Earth was that?
05:57:48 <MyCatVerbs> vixey: ...and where can I get it on a tee-shirt?
05:58:03 <vixey> hehe
05:58:06 <vixey> um
05:58:08 <vixey> 1 sec
05:58:19 <lilac> > let n = 1000 in sum [1/n/n | x <- [-n..n], y <- [-n..n], x*x + y*y < n*n]
05:58:20 <dolio> You could call 'functions' in a dependently typed language 'dependent products' in general.
05:58:21 <lambdabot>  3.141521000085211
05:58:23 <Philippa> Toxaris: if you add those parts explicitly, yeah
05:58:31 <lilac> > let n = 10000 in sum [1/n/n | x <- [-n..n], y <- [-n..n], x*x + y*y < n*n]
05:58:34 <vixey> http://people.cs.uu.nl/andres/LambdaPi/index.html
05:58:34 <lambdabot> Title: A Tutorial Implementation of a Dependently Typed Lambda Calculus
05:58:39 <lambdabot> Terminated
05:58:40 <vixey> (\ a x -> x) :: forall (a :: *) . a -> a
05:59:08 <Philippa> Toxaris: I've been toying around with a variant of HM that allows them in the source language and explicitly generates them recently. If you stratify terms as well as types on mono/poly lines it makes things extremely straightforward
05:59:16 <lilac> why does that run out of stack?
05:59:33 <lilac> > let n = 10000 in length [1 | x <- [-n..n], y <- [-n..n], x*x + y*y < n*n] / n / n
05:59:34 <lambdabot>   add an instance declaration for (Fractional Int)
06:00:01 <lilac> > let n = 10000 in (fromIntegral $ length [1 | x <- [-n..n], y <- [-n..n], x*x + y*y < n*n]) / n / n
06:00:05 <ski> lilac : does it ? .. maybe it runs out of time ..
06:00:16 <lambdabot>  Exception: Time limit exceeded
06:00:22 <lilac> ski: ghc says stack overflow
06:00:25 <Toxaris> Philippa: so why can't I express Haskell types as lambda expressions, and bot /\ and \ as lambda?
06:00:42 <lilac> sum is O(1) in stack isn't it?
06:00:55 <vixey> type lambda quickly makes inferrence impossible
06:01:28 <Duddle> could somebody please take a look at http://pastebin.com/d2e304009 ? I get an error when I execute "mymap rate example" ... in my opinion, it should take the list "example" that is of my type "Population" and apply the function "rate" to every item... the error says, the inferred type is (Integer, Integer,...,Integer)
06:02:08 <Philippa> Toxaris: you need a nominal distinction, not just a structural one
06:02:11 <Toxaris> Philippa: but that's not enough. if [[ ... ]] denotes the mapping from Haskell functions to lambda calc functions, we want [[id Nat]] != [[id Nat']
06:02:19 <Saizan> lilac: are you compiling with optimizations?
06:02:27 <dcoutts_> Saizan: we should work out how make deals with the fact that most systems only keep file time stamps accurate to the second
06:02:46 <Philippa> Toxaris: yep
06:03:05 <Saizan> dcoutts_: do we need finer granularity?
06:03:10 <lilac> @src sum
06:03:10 <Philippa> basically, by the time you've really got it you've probably syntactically embedded something else
06:03:10 <lambdabot> sum = foldl (+) 0
06:03:24 <Philippa> so... hmm, yeah, if you're sufficiently picky it's probably doable
06:03:30 <dcoutts_> Saizan: if tasks take less than a second, and many do then we might, yes
06:03:40 <Philippa> it's definitely not the /obvious/ isomorphism though!
06:03:58 <dcoutts_> Saizan: I presume make has some trick though, like how it decides if two file timestamps are within the same second
06:04:58 <Toxaris> Philippa: I think I see now what's the point. We need to store more information then just the function per function in the lambda calc semantics. e.g., we need runtime type information.
06:05:05 <dcoutts_> Saizan: also, I believe linux at least will give you more accurate timestamps if the directory entry is still cached in memory, once it has to re-read the timestamp from disk then it goes back to one-second accuracy, or whatever the underlying filesystem supported
06:05:59 <Toxaris> Philippa: so we cannot map Haskell functions to lambda calc functions, but Haskell functions to something else. which is obvious, because we can write an Haskell interpreter in lambda calculus (since lambda calculus is turing complete).
06:06:12 <Philippa> yep
06:08:03 <Toxaris> Philippa: thanks for staying with me on my road to that realization :)
06:09:00 <Bonus> the new chapters up on realworldhaskell.org are p. cool
06:10:10 <bogomipz> why might i get IO error "resource vanished" while reading a tcp stream?
06:10:48 <bogomipz> the file handle is from accept socket
06:11:11 <Saizan> dcoutts_: if we say that a dep. must be younger than the target and define younger as (<=), can we still get false negatives?
06:12:01 * dcoutts_ thinks
06:13:43 <dcoutts_> Saizan: so if we rebuild and then touch the source file and rebuild again within the same second then we'd think it was up to date when it isn't
06:14:08 <dcoutts_> Saizan: otoh, that's exactly where the caching of more accurate timestamps would help us
06:14:26 <dcoutts_> and make seems to be able to get away with it, so we're probably ok
06:16:51 <Toxaris> Philippa: does that mean that we have no eta reduction in Haskell?
06:17:37 <Toxaris> Philippa: since eta reduction is justified by extensionality of functions, which we don't seem to have here.
06:17:47 <ski> > (\x -> undefined x) `seq` ()
06:17:48 <lambdabot>  ()
06:17:48 <ski> > undefined `seq` ()
06:17:49 <lambdabot>  Exception: Prelude.undefined
06:18:42 <Toxaris> ski: :)
06:18:44 <ski> i don't know of any other reason for eta failing than `seq' (and `!' annotations in type definitions, bang-patterns)
06:18:51 <gbacon> @ty when
06:18:53 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
06:18:55 <mauke> > (undefined :: forall a. a)
06:18:55 <lambdabot>  Parse error at "." (column 23)
06:19:22 <gbacon> @ty flip when
06:19:24 <lambdabot> forall (m :: * -> *). (Monad m) => m () -> Bool -> m ()
06:19:38 <gbacon> @hoogle (Monad m) => m () -> Bool -> m ()
06:19:46 <lambdabot> No matches, try a more general search
06:19:51 <gbacon> @hoogle  m () -> Bool -> m ()
06:19:52 <lambdabot> No matches, try a more general search
06:21:00 <Saizan> dcoutts_: do you know if there's any implementation commentary for make?
06:21:22 <dcoutts_> Saizan: not off the top of my head, I'd expect there probably is though
06:21:38 <dolio> How is extensionality violated?
06:21:57 <Philippa> Toxaris: I believe you just do it inside the type stuff
06:22:28 <Toxaris> so I have to insert the big lambdas first, then take them into account
06:22:50 <Philippa> in practice it turns out to 'just work'
06:23:06 <Philippa> they go 'on the outside'
06:23:33 <Philippa> (as the version of the type with the forall suggests)
06:25:44 <Toxaris> dolio: it is not I guess. I'm trying to grasp how to handle typed functions semantically
06:27:07 <Toxaris> dolio: e.g. consider id :: a -> a and id' :: Char -> Char. there is no x with (id x != id x'), so they seem to be extensionally equal. but clearly they aren't equal. on the other hand, there are x with id x is possible and id' x is not, like x = 42 :: Int.
06:28:26 <ski> (dolio : using `(forall x. f0 x = f1 x) => f0 = f1' and `f0 = f1 => (forall k. k f0 = k f1)' using `\f -> seq f ()' for `k' ?)
06:29:29 <dolio> ski: I'm not talking about seq. I know that's a problem. They were talking about translating Haskell to some variant of lambda calculus.
06:29:37 <Beelsebob> http://hpaste.org/7303 <-- How satisfying :)
06:29:40 <ski> ok
06:30:16 <Beelsebob> shame hpaste cut it off
06:30:22 <ivanm> yeah
06:30:33 <ivanm> but hpaste actually gave your "colours" colours! :p
06:30:34 <Beelsebob> but it at least got to the central axis
06:30:34 <Toxaris> but if I expand these to explicitly handle type arguments as Philippa suggested, I see that they are completely different, because id = /\ a -> \x -> x and id' = \x -> x. now we have id x != id' x for all x
06:30:39 <Beelsebob> hehe, it did
06:30:41 <Beelsebob> hich is win
06:30:45 <Beelsebob> which*
06:31:18 <dolio> Toxaris: Yeah.
06:31:49 <Beelsebob> ivanm: http://hpaste.org/7303#a1 <-- a bit nicer :)
06:32:34 <Toxaris> dolio: back to extensionality: instead of using lambda terms to encode the difference between (id Char) and (id Nat), we could maybe use an intentional semantics for lambda calculus?
06:32:47 <ivanm> Beelsebob: much better!
06:33:00 <dcoutts_> Saizan: see http://www.vestasys.org/ and in particular the paper "The Vesta Approach to Software Configuration Management"
06:33:03 <ivanm> though is there meant to be such a large spike in the middle?
06:33:04 <lambdabot> Title: Vesta Configuration Management System
06:33:05 <tromp> why wld you want to have different lambda terms?
06:33:31 <Beelsebob> ivanm: hmm? I think that spike extends all the way to -inf+0i
06:33:35 <tromp> i'd just map all id's to the same yntyped lambda calculus id
06:33:57 <ivanm> Beelsebob: could be.... I haven't studied mandelbrot recently :p
06:33:57 <Toxaris> tromp: but then you can't go back to Haskell semantics
06:34:13 * Beelsebob ponders what terminal colour escape codes look like
06:34:19 <ivanm> ugly
06:34:20 <Toxaris> tromp: this was the begin of the discussion, that Philippa stated that this "obvious" embedding is an embedding, and not an isomorphism
06:34:23 <povman> ping
06:34:29 <dcoutts_> Saizan: the thing I picked up from that and from Eelco's papers http://www.st.ewi.tudelft.nl/~dolstra/pubs/index.html is the importance of fanatically tracking dependencies
06:34:29 <ivanm> pong
06:34:29 <lambdabot> Title: Publications
06:34:35 <MyCatVerbs> Philippa: what representation would you use for CPS, please?
06:34:38 <povman> http://hpaste.org/7304
06:34:41 <tromp> right; it's an embedding
06:34:50 <ivanm> Beelsebob: have you seen the brainfuck mandelbrot generator?
06:35:04 <Beelsebob> ivanm: no, have you seen my brainfuck interpretter?
06:35:05 <Beelsebob> :D
06:35:11 <tromp> but i dont see need to go back
06:35:18 <ivanm> can't say I have
06:35:21 <MyCatVerbs> Philippa: all the representations I can think of would only be any good for an interpreter, or involve maintaining a map from labels CPS program fragments, or are only ever any good for interpretation but can't be compiled (because you can't really traverse them).
06:35:27 <Beelsebob> ivanm: time for the two to meet?
06:35:34 <ivanm> heh
06:35:39 <ivanm> http://esoteric.sange.fi/brainfuck/utils/mandelbrot/
06:35:41 <lambdabot> Title: Index of /brainfuck/utils/mandelbrot
06:36:06 <Philippa> MyCatVerbs: I'd run with the map myself. Btw, have you seen the recent ICFP paper on CPS?
06:36:15 <MyCatVerbs> Philippa: no, should I?
06:36:35 <Philippa> it's a good read. Gimme a mo to dig it up?
06:36:51 <MyCatVerbs> Philippa: (am I likely to understand it? This is a valid impediment to me, I often can't keep up with you in conversation.)
06:37:02 <ivanm> Beelsebob: this it? http://sabbatical-year.blogspot.com/2007/12/brainfuck-interpreter-in-haskell.html
06:37:03 <lambdabot> Title: my sabbatical year diary: Brainfuck interpreter in Haskell, http://tinyurl.com/5wj3f6
06:37:10 <Philippa> "Compiling with continuations, continued"
06:37:19 <Philippa> it's intended as a tutorial
06:37:30 <dcoutts_> Saizan: here's some commentary http://make.paulandlesley.org/
06:37:31 <lambdabot> Title: GNU Make
06:37:35 <Philippa> I'm not saying it never gave me cause to stop and think, but that that's because I don't work with CPS so much :-)
06:37:39 <Beelsebob> ivanm: nope, this is... http://hpaste.org/7305
06:38:52 <Toxaris> I used to have a BF interpreter lying around somewhere
06:39:02 <ivanm> heh
06:39:10 <ivanm> is it on hackage? :p
06:39:46 <MyCatVerbs> Philippa: oh excellent. Thank you very much.
06:40:46 <Beelsebob> ivanm: :) it's working... slowly :)
06:41:17 <MyCatVerbs> Philippa: daaaamn.
06:41:24 <Saizan> dcoutts_: yeah, dependecies seem to pop up everywhere..
06:41:31 <Beelsebob> I wonder whether the other interpretter is faster than mine -- probably... although distinctly less pleasant code
06:41:48 <MyCatVerbs> Philippa: as a relatively obsessive penguinite, it blows my mind how many good papers I wind up finding at .microsoft.com addresses. :)
06:42:01 <dcoutts_> Saizan: yes, its really all about managing dependencies
06:42:25 <dcoutts_> actually invoking compilers etc is easy :-)
06:46:12 <Saizan> a flaw about using timestamps is that we're actually using them only to infer mutation, but i don't see any pratical alternative if we don't control the sources
06:46:41 <dcoutts_> Saizan: aye, timestamps seem awfully concrete to me
06:46:54 <dcoutts_> Saizan: I keep wondering if there is a more general notion
06:47:20 <MyCatVerbs> Saizan: couldn't you use an incrementing counter and a hash of contents instead?
06:47:23 <edwardk> Does someone who has access to a compiler want to see if I screwed up my example at: http://comonad.com/reader/2008/the-cofree-comonad-and-the-expression-problem/#comment-1102
06:47:25 <lambdabot> http://tinyurl.com/5m4vjv
06:47:27 <MyCatVerbs> Saizan: maybe even just a hash-of-contents?
06:47:41 <dcoutts_> Saizan: eg some systems might prefer to work on hashes, or the other example of search path shadowing was a boolean value present/not-present
06:47:43 <edwardk> I was only able to run it through my mental typechecker, and my brain is known to have bugs
06:47:47 <MyCatVerbs> Saizan: (I'm unclear as to what it is you're discussing, though, so sorry if that's totally inappropriate.)
06:48:15 <dcoutts_> MyCatVerbs: Saizan is building a make-like lib for use in Cabal for GSoC
06:48:28 <MyCatVerbs> dcoutts_: oh awesome.
06:48:40 <Saizan> MyCatVerbs: i don't think the incrementing counter can work, since sources can change indipendently from us
06:48:56 <Saizan> the hash seems correct, but expensive?
06:49:08 <dcoutts_> Saizan: ghc uses incrementing counters in .hi files to work out what changed, but it's not completely reliable
06:49:21 <dcoutts_> Saizan: because one can delete .hi files and then all the counters reset
06:49:23 <MyCatVerbs> Saizan: cache the hash based on mtime from the operating system?
06:49:54 <dcoutts_> Saizan: they're probably moving to a system based on hashes, where they hash the exported api
06:49:54 <MyCatVerbs> Saizan: md5sum and sha1sum are both trivial in CPU time by comparison to their IO time, but you do need to read whole files from disk for both.
06:50:30 <MyCatVerbs> edwardk: I misread that as the Coffee Monad.
06:50:39 <dcoutts_> Saizan: yes, so the general notion is of change, rather than newness
06:50:40 <MyCatVerbs> edwardk: I take it that that doesn't count? :)
06:51:25 <edwardk> mycatverbs: i swear i'm going to keep count of the times i've heard that. ;)
06:51:31 <dcoutts_> Saizan: I know if a file has changed if I knew the previous timestamp and it now has a different one, or similarly for content
06:51:38 <edwardk> my next machine will definitely be coffee.comonad.com though.
06:52:10 <MyCatVerbs> edwardk: XD
06:52:15 <dcoutts_> Saizan: comparing timestamps of files is kind of a special case of that where I use the timestamp of one file as my memory and compare it to another
06:52:18 <Saizan> dcoutts_: unless we consider starting from a tree with already built pieces and want to try and keep what's already there, then we don't have something to compare against
06:52:28 <dcoutts_> Saizan: yeah, exactly
06:52:48 <dcoutts_> Saizan: and that's what file timestamps give you, something to compare against
06:54:42 <dcoutts_> an alternative would be to keep some auxiliary memory of the nodes, so we can see if they've changed just by looking at one node, rather than comparing two nodes
06:55:31 <Saizan> that would be best, i guess
06:56:27 <Saizan> it also means that if we lose that memory we must recompile everything, but it's probably not a problem?
06:57:38 <ndm> dcoutts, i was compiling a file with cabal that used Happy the other day, and it was useless
06:58:15 <Saizan> useless?
06:58:18 <ndm> dcoutts, i compiled it for GHC first, so it generated a Parser.hs from Parser.ly that was incompatible with hugs. I then recompiled it for Hugs, but it didn't regenerate the happy, so didn't work at all
06:58:26 <ndm> Saizan: usefulness = 0 :)
06:58:40 <ndm> (of cabal, when combined with happy's quirks)
06:59:05 <ndm> (usefulness = 0 but confusion = very high)
06:59:30 <Saizan> heh, than happy generated files have $compiler as dependency :)
06:59:39 <Saizan> s/than/then/
06:59:53 <dcoutts_> Saizan: aye, I think that would be ok, that if a user deleted our cached info that we would forget everything and have to rebuild
07:00:20 <ndm> Saizan: they do seem to, which is not currently tracked
07:00:28 <dcoutts_> ndm: oh, so you mean that it forgets that the .hs depends on both the .ly and the configuration
07:00:40 <ndm> i'm not overly complaining, just more throwing it out there for the proper dependency goodness to fix
07:00:45 <ndm> dcoutts_: yes, it did seem to
07:00:50 <dcoutts_> ndm: and that if you change the configuration (changing target GHC to hugs) then it needs to rebuild
07:01:00 <dcoutts_> to rebuild the .hs from the .ly
07:01:32 <dcoutts_> ndm: yes, the current rebuild check only compares the filestamps and does not consider the dependence on the configuration
07:01:51 <ndm> dcoutts_: precisely, its also a little weird that it dumps Parser.ly to Parser.hs in the same directory, despite it being a per-configuration file
07:01:59 <ndm> I was kind of expecting it to end up in dist
07:02:29 <dcoutts_> ndm: which is one reason for Saizan's projet we want to have a slightly more general notion of targets than just files so that we might be able to have configuration state as targets and so express the fact that many actions depend also on bits of the configuration
07:02:43 <dcoutts_> tracking dependencies accurately is the key thing in all these build bugs
07:03:02 <dcoutts_> ndm: oh I think the .hs does end up in dist
07:03:18 <dcoutts_> ndm: at least with recent cabal versions, like 1.2+
07:03:22 <ndm> dcoutts_: i know :) - I'm just making sure when you are designing the uber-goodness of this new make system, that you are able to support these weirdities
07:03:44 <saml> I have runMonad :: MyMonad a -> Foo -> Bar -> (Foo, Bar, a)  .   I want to implement  run :: MyMonad a -> Either String a   . how can I catch fail in MyMonad and return the message with Left constructor?
07:03:47 <ndm> dcoutts_: i think i was on HEAD from last week, and i think it wasn't ending up in dist - but i may have moved it myself to trouble shoot, so no guarantees
07:03:47 <dcoutts_> ndm: yes, we're aware of the configuration dependency :-)
07:03:55 <ndm> good good :)
07:04:05 <ndm> i have my fingers strongly crossed for the cabal make stuff!
07:04:14 <Saizan> :)
07:04:20 <dcoutts_> ndm: if you find it's not ending up in dist/ file a bug, but afaik it does and it certainly should
07:04:35 <EvilTerran> saml, by giving fail a definition other than the default, so fails are turned into values instead of exceptions?
07:04:40 <Saizan> the configuration dep. at least seems more concrete than the "file existence" one :)
07:05:01 <EvilTerran> saml, if your monad has a constructor "Fail String", and fail = Fail, it'd be fairly straightforward
07:05:04 <dcoutts_> Saizan: heh :-), they're just different typed bits of mutable state
07:05:29 <dcoutts_> Saizan: the file existence one is a really nice case actually for broadening our view of dependencies
07:05:30 <saml> EvilTerran, still fail will terminate computation?
07:05:37 <EvilTerran> saml, ... you'd have to extend your definition of >>= to propogate Fails from the left, mind
07:05:46 <saml> oh right
07:05:53 <edwardk> saml: fail means whatever your monad tells it to mean
07:06:04 <EvilTerran> saml, basically, i'm suggesting you bake ErrorT into your monad :)
07:06:09 <dcoutts_> ndm: you familiar with that one? that an action may depend on the non-existance of a file, so we need to track that non-existance because if the file then appears we have to rebuild
07:06:23 <dcoutts_> it's counter intuitive at first
07:06:43 <ndm> dcoutts_: my brain hurts too much, its very confusing!
07:07:16 <Beelsebob> ndm: w00t -- beelsebob.be
07:07:45 <dcoutts_> Saizan: so config is a good example for thinking about timestamps vs mutations
07:07:46 <saml> newtype TI a = TI { runTI :: Subst -> Int -> (Subst, Int, a) }  -- this is my monad. how can I bake ErrorT into it?  deriving (MonadError)  or do I instance MonadError TI .. ?
07:08:01 <ndm> Beelsebob: website not found?
07:08:09 <Beelsebob> ndm: no... I'm in .be
07:08:10 <Beelsebob> :P
07:08:11 <edwardk> @type State
07:08:13 <lambdabot> forall s a. (s -> (a, s)) -> State s a
07:08:14 <saml> I do instance Monad TI where .. so that TI behaves like Monad
07:08:15 <dcoutts_> Saizan: with config we can keep a copy of the value and just compare it with == to see if it has changed
07:08:20 <EvilTerran> saml, well, by adding a Fail constructor to it
07:08:29 <edwardk> saml: you have a state monad with (Subst,Int) as the state there
07:08:52 <saml> edwardk, yes i'm writing State monad myself for learning purpose
07:08:54 <edwardk> so ErrorT String (State (Subst, Int)) a would be an equivalent monad with the error
07:08:55 <EvilTerran> saml, if you look at the definition of Monad for Either, you'll see that does what i just described
07:09:05 <dcoutts_> Saizan: or keep a timestamp of when it last changed
07:09:09 <ndm> Beelsebob: forever? jobbed up?
07:09:10 <saml> EvilTerran, oh thank you
07:09:14 <edwardk> you can bake in the Error yourself by changing the last bit of it manually to
07:09:18 <Beelsebob> ndm: yep :) Haskell job at that
07:09:20 <EvilTerran> and ErrorT is just like a higher-kinded version of Either
07:09:33 <edwardk> newtype TI a = TI { runTI :: Subst -> Int -> Either MyError (Subst, Int, a) }
07:09:53 <EvilTerran> ?unmtl ErrorT String (State (Subst, Int)) a
07:09:55 <lambdabot> Subst -> Int -> (Either String a, Subst, Int)
07:09:56 <edwardk> where MyError is however you want to track errors
07:10:38 <edwardk> ErrorT just wraps your monad around an error
07:10:50 <EvilTerran> ?unmtl StateT (Subst, Int) Either a
07:10:50 <lambdabot> Subst -> Int -> Either (a, Subst, Int)
07:11:08 <EvilTerran> those have different semantics - you'll have to decide which one you want
07:11:09 <edwardk> you could just as well work in ErrorT MyError TI a
07:11:26 <edwardk> hah when did unmtl come around?
07:11:29 <EvilTerran> StateT Either loses the state when a fail happens, ErrorT State doesn't
07:11:37 <EvilTerran> edwardk, it's been around for ages, it's just a bit fiddly to use
07:11:53 <EvilTerran> you have to give it a fully-applied type of kind *
07:12:36 <edwardk> is there a corresponding @mtl ? =)
07:12:47 <EvilTerran> don't think so
07:12:50 <EvilTerran> @list unmtl
07:12:50 <lambdabot> unmtl provides: unmtl
07:12:54 <mauke> @mtl StateT (Subst, Int) Either a
07:12:54 <lambdabot> Maybe you meant: ft map msg pl unmtl url
07:13:06 <EvilTerran> @help url
07:13:06 <lambdabot> url <key>. Return element associated with key
07:13:26 <edwardk> heh i should see about tweaking it to support the comonad transformers i'm adding to category-extras
07:13:26 <EvilTerran> ah. so that's @where, then
07:14:48 <dcoutts_> Saizan: they had a PLDI paper http://www.vestasys.org/doc/pubs/pldi-00-04-20.pdf
07:15:20 <dcoutts_> Saizan: it might shed some light on the issue of how to decide if something is out of date / has changed
07:15:40 <saml> newtype TI a = TI { runTI :: E.ErrorT String (Subst -> Int -> (Subst, Int, a)) }    should I use StateT with Identity monad to use ErrorT? or can I somehow wrap existing custom state monad, TI, with ErrorT ?
07:16:48 <dcoutts_> Saizan: looks like they use a complex hashing and caching system
07:18:00 <edwardk> heya swiert
07:18:09 <swiert> hi edwardk
07:18:38 <Saizan> dcoutts_: reading
07:18:46 <edwardk> swiert: have you had a chance to look on planet haskell? i'd like your thoughts on my latest post as it relates to the ala carte stuff
07:19:17 <edwardk> swiert: i realize the ala carte solution is a lot more elegant in use coz of the typeclasses
07:19:17 <swiert> edwardk: I've had a quick read, but I'll try to give it a closer look.
07:19:43 <dcoutts_> Saizan: in 4.6.1 note that they track existence and non-existence of files as deps
07:20:19 <edwardk> swiert: i was mostly interested in showing you could annihilate a free monad with a cofree comonad of its dual, the connection to the other stuff is sort of tangential
07:22:09 <saml> newtype TI a = TI { runTI :: Subst -> Int -> Either String (Subst, Int, a) }  -- this is becoming tedius refactoring..  TI (\s n -> Right (s, n, ())) ...
07:22:46 <edwardk> saml: thats why we use the MTL =)
07:22:54 <edwardk> saml: see you're learning already =)
07:23:11 <swiert> edwardk: right. I was wondering if you know what the Dual class corresponds to categorically.
07:24:17 <edwardk> swiert: well, if you take the 'op' stuff out, and you read the left hand side as a container of continuations and the right as a dual container of values its just field selection or case analysis
07:25:06 <edwardk> swiert: i tripped over the idea when i was writing a pure variant/record calculus with continuations (and no functions)
07:25:27 <edwardk> (i.e. where every function returns bottom ala the haskell is not not ml approach)
07:26:26 <edwardk> sweirstra: so basically its just uniquely determining a 'path' whenever there is a product on one side or a case discrimination when there is a sum
07:28:15 <edwardk> in wadler's pure value continuation calculus it would be a 'reflection' operator across the * symbol he has
07:28:18 <swiert> edwardk: I understand the case for products/coproducts, but I'm still wrapping my head around the free/cofree connection.
07:28:51 <edwardk> think of a free monad, you have a tree with decorated leaves where you have not yet substituted right?
07:29:48 <edwardk> on the other hand in the cofree comonad you have a tree where at every node you have a decoration. ("the dual of substitution is redecoration")
07:29:50 <swiert> edwardk: sure.
07:30:41 <edwardk> so since i have a cofree comonad of the dual of the functor you built your free monad out of, every 'leaf' you can reach, i'll have a decoration that corresponds to
07:30:55 <nomeata> Hi. Can I make cabal generate haddock documentation for non-exposed modules as well, for use by the developers? And can I make haddock document unexported symbols?
07:31:05 <edwardk> and i'll have had to have determined a unique path to that leaf by the fact that whenever you had a pair i had a sum to select my path
07:31:22 <edwardk> and whenever you had a sum i had a pair to handle both cases
07:32:55 <dcoutts_> nomeata: not easily at the moment http://hackage.haskell.org/trac/hackage/ticket/156
07:32:59 <lambdabot> Title: #156 (setup haddock: option to expose all modules) - Hackage - Trac
07:33:28 <nomeata> dcoutts_: thx
07:33:29 <edwardk> so lets take a simple tree functor. (we actually have it as Prod Identity Identity. Its 'Dual is Sum Identity Identity. so if you give me a free 'tree' i'll give you a cofree 'path' that i can use to select any of the leaves of your tree.
07:33:52 <dcoutts_> nomeata: but it should be easy to implement in Cabal if you want to send us a patch
07:35:47 <edwardk> my cofree path (for the simple tree functor) has to be infinitely long (its codata) because i don't know how deep the leaf in your tree is.
07:36:40 <edwardk> otoh; if i work off of a 'list'-like' functor that can terminate, i had to wind up with a case for handling nil by duality
07:36:42 <nomeata> dcoutts_: maybe I‚Äôll have a look. It‚Äôs just removing the --hide parameters and adding --ignore-all-exports, maybe chosen independently on the setup haddock command line, and maybe putting the output in a doc-interal/ or similar path?
07:37:12 <dcoutts_> nomeata: I don't think you need to worry about changing where the output goes
07:37:38 <dcoutts_> nomeata: but yes, a setup haddock --flag with a suitable name that adds --ignore-all-exports and removes the --hide other-modules
07:37:48 * nomeata looks into that
07:38:07 <swiert> edwardk: ok. I think I'm starting to see what you mean.
07:38:11 <dcoutts_> nomeata: do you think we need to be able to independently control the hide vs ignore export list?
07:38:15 <swiert> edwardk: Let me mull it over for a bit.
07:39:28 <edwardk> swiert: np =)
07:39:28 <nomeata> dcoutts_: not sure. maybe sometimes I want my internal interfaces documented (so with hide and with ignore export list), and sometimes I might want to see all (so without hide and with ignore export list)
07:40:16 <edwardk> i was starting to wonder if anyone was reading those posts ;)
07:40:23 <dcoutts_> nomeata: if you wanted internal interfaces documented then surely you'd not want hide either?
07:40:37 <dolio> I've been reading them, of course.
07:40:43 <edwardk> ah true
07:40:53 <dcoutts_> @seen conal
07:40:53 <lambdabot> conal is in #haskell and #ghc. I don't know when conal last spoke.
07:41:04 <edwardk> dolio: i started merging the rest of category-extras last night
07:41:19 <nomeata> dcoutts_: eh, I consfused the two. I think there is a usecase for no hide but without --ignore-all-exports either.
07:41:24 <saml> where can I find source code for Either monad instanciation?
07:41:29 <edwardk> dolio: still have a ways to go. mostly want to raid it for the much better comments than i have ;)
07:41:39 <dolio> Heh.
07:41:52 <dcoutts_> conal: you had some opinions on what you wanted to do with cabal and haddock, is that documented on the trac? if not perhaps add something to http://hackage.haskell.org/trac/hackage/ticket/196
07:41:53 <lambdabot> Title: #196 (ability to specify custom args to haddock) - Hackage - Trac
07:42:22 <dolio> Yeah, the original comments were pretty good in some places.
07:42:40 <dolio> Although the Data.* stuff was completely uncommented.
07:42:40 <dcoutts_> nomeata: what might that be?
07:42:55 <edwardk> so did you just wind up maintaining it because menendez stopped caring about it or how did that come about?
07:43:14 <dcoutts_> nomeata: if we can get away with it, I'd prefer to have fewer flags with meanings corresponding closer to intentions that underlying actions
07:43:24 <dcoutts_> that/than
07:43:25 <dolio> Well, it was never on hackage, just on his website.
07:43:45 <dolio> So I volunteered to cabalize it back when someone expressed interest.
07:43:48 <dcoutts_> nomeata: having pages and pages of --help output is a bit scary to users :-)
07:44:03 <edwardk> dolio: ah
07:44:11 * dcoutts_ realises we may have already failed with cabal configure --help
07:44:19 <dolio> I think dons thought it'd be good to have a library that actually had comonads in it, since that might encourage actual use, but I don't know that it has. :)
07:44:26 <edwardk> yeah
07:44:40 <dolio> Maybe with your more fleshed out set it will, but even then I kind of doubt it.
07:44:44 <edwardk> i'm trying to get the rest of the comonad suite in there
07:44:58 <dolio> I don't think most people go trolling outside of the standard libraries for category theory stuff.
07:44:59 <nomeata> dcoutts_: well, I see if I can actually get it to do what I want before I worry about that :-)
07:45:01 <edwardk> i think with transformers maybe they can become something more useful
07:45:16 <edwardk> but i'll admit the more likely 'use' will be that they make better bikleisli arrows
07:45:25 <edwardk> because people can think in arrows and not be scared
07:46:12 <edwardk> so if i can give a simple set of comonadic transformers that can be used with the monad transformers to build a solid bikleisli arrow with the desired properties (supply, context, environment, writer, frp stuff, etc) then maybe
07:46:44 <edwardk> that said, not many users regardless =)
07:47:17 <dolio> Yeah. Someone will have to come up with some actual example programs at some point, I imagine, if people are ever going to use them.
07:47:22 <edwardk> i just wish i could type the stuff i want to have in Control.Category in Haskell =/
07:47:37 <edwardk> dolio: thats why i want a cofib suite.
07:48:55 <dolio> I guess Control.Category stuff is now a libraries@ matter.
07:48:58 <edwardk> the 6.9 addition of the Category class is a nice start, but the problem with it is, i can't seem to figure out how to define a dual category that doesn't conflict with contravariant functors over the original category
07:49:11 <dolio> It's kind of light at the moment, though.
07:49:17 <edwardk> dolio: did you see the stuff i started for handling categories?
07:49:49 <dolio> Where?
07:49:50 <edwardk> http://comonad.com/haskell/categories/dist/doc/html/categories/
07:50:08 <edwardk> its similar in a lot of ways to the stuff i started baking into category-extras, but look at Control.Category.Functor
07:50:13 <edwardk> to see where the differences really start
07:50:29 <dolio> Ah, yeah, I've done that, too.
07:51:22 <edwardk> then what i did with it was build back up to arrows by building up to braided/symmetric monoidal categories (though for sanity sake i chose to 'braid' the bifunctor)
07:51:23 <dolio> That way you can define the adjunction for the CPS monad.
07:51:41 <dolio> At the very least.
07:51:49 <edwardk> Yep.
07:52:13 <dolio> It's kind of disappointing that the only adjunction in category-extras is the one for the state monad.
07:52:13 <edwardk> class (Functor f c d, Functor g d c) => Adjunction f g c d | f c -> g d, f d -> g c, g  c -> f d, g d -> f c
07:52:39 <edwardk> you have the hom-prod one for reader/reader comonad right?
07:53:20 <dolio> You mean (->) a (,) a?
07:53:26 <edwardk> yeah
07:53:33 <dolio> Yeah. That's the only one, I think.
07:53:37 <edwardk> *nods*
07:54:07 <dolio> Which gives rise to State and Context, no?
07:54:09 <edwardk> my biggest problem with the above category-theoretic version of functor is that it costs you the ability to do much of ANYTHING with functors, monads, etc in general
07:54:17 <edwardk> yeah
07:54:57 <dolio> Yeah, that's my problem with it, too. It seems nice theoretically, but it seems like it'd be a pain to use for all the stuff you'd usually use functors/monads/etc. for.
07:55:49 <edwardk> i got to the point where the only way i could define a comonad generically in that setting was as a 'category transformer' because the cokleisli construction was 'hask' specific
07:56:02 <edwardk> because you have no way to lift newtypes into arbitrary categories
07:56:10 <edwardk> you need to be able to witness the isomorphism
07:56:14 <astrolabe> I just got the latest Ubuntu.  I imagine that got a new version of ghc.  Now when I try to compile some code, I get "Could not find module 'Text.ParserCombinators.Parsec'".  Is there a way to get ghc to use this as before without altering the 'ghc --make Abc.hs'?
07:56:53 <ToRA> apt-cache search parsec on a guess see if it's a package for ubuntu?
07:57:01 <Lemmih> astrolabe: aptitude install libghc6-parsec-dev
07:57:22 <edwardk> i may go back and finish it up because it DOES still make a nicer derivation of arrows though
07:57:29 <astrolabe> Lemmih: thanks, I'll try that.
07:57:56 <edwardk> just that functors, etc in that setting are kind of lost in the category-centric view.
07:57:59 <dolio> I've been playing around with category theory stuff in Agda 2, as well, and there seems to be similar problems there, too.
07:58:12 <lispy> are anonymous constants ever justified?
07:58:31 <dolio> I have to pick between a more faithful modelling and something that's practically useful.
07:59:06 <jorick> blog about the first and implement the second :p
07:59:07 <edwardk> dolio: yeah, my first stab at a toy language had a lot in common with agda/cayenne and i found overly generic CT stuff to be a pain in the butt there =) the haskell stuff is at a disturbingly good sweet spot
07:59:57 <dolio> I was thinking about messing with the functor fixpoint stuff, too, but that's kind of disappointing there, too.
08:00:04 <dolio> Since you can't define Mu, of course.
08:00:14 <edwardk> the main things i'd like to see is the stuff from the superclass proposals so i could implement (co)Pointed functors as a superclass of applicative, etc.
08:00:28 <dolio> I *had* to go with the category-extras style Fixpoint class (module/record, really).
08:04:27 <dolio> Although I have a vague notion that I could maybe experiment context-free types ala Constructing Universes for Generic Programming but that strikes me as a pain unless the language is designed with that as an underlying model.
08:05:49 <dolio> Or maybe I should just play with Charity, since that's based around (co)fixpoints of functors from the ground up.
08:13:23 <byorgey> is Charity still being developed?
08:20:10 <conal> dcoutts_: (cabal/haddock) do you mean my idea for replacing haddock's markup language with general markdown?
08:20:39 <dcoutts_> conal: no the issue of command line flags to get it to do what you want
08:21:09 <dcoutts_> conal: though on the other issue, I am getting more used to the idea of markdown/pandoc
08:21:15 <CosmicRay> > try (return (5 `div` 0))
08:21:19 <conal> dcoutts_: :)
08:21:20 <lambdabot>   Not in scope: `try'
08:21:23 <CosmicRay> bah.
08:21:38 <CosmicRay> when I try that in ghci, I get the supremely odd output of:
08:21:41 <CosmicRay> Prelude Control.Exception> try (return (5 `div` 0))
08:21:41 <CosmicRay> Right *** Exception: divide by zero
08:21:47 <conal> dcoutts_: oh -- maybe making it possible to have cross-lib docs even if some libs are not on hackage
08:21:54 <Lemmih> CosmicRay: That's the correct answer.
08:21:55 <edwardk> dolio: back. sorry got interrupted
08:21:59 <conal> dcoutts_: i mean cross-lib doc links
08:22:00 <dcoutts_> conal: my only dissapointment at the moment is that > is for block quoting not code, so we cannot make .lhs markdown documents
08:22:01 <CosmicRay> Lemmih: how?
08:22:03 <Lemmih> CosmicRay: Try 'evaluate' instead of return.
08:22:05 <Toxaris> Beelsebob: found an unfinished bf interpreter on my hdd and finished it. it's not really tested though. But I would consider it an interesting approach. http://hpaste.org/7307
08:22:25 <CosmicRay> Lemmih: hrm, that did indeed work..
08:22:36 <edwardk> conal: i just read through the simply elegant frp paper and i noticed you mentioned a monoid for Future a, wouldn't that also (or alternately) just be a MonadPlus instance for Future?
08:22:37 <CosmicRay> ah, I suppose that does make sense.
08:22:38 <conal> dcoutts_: yep.  that's a conflict
08:22:58 <nomeata> dcoutts_: oh, how funny. I implemented this behaviour and it works, only to notice that for the package I wanted it for, I don‚Äôt need it at all. (It‚Äôs a program package, so --executable already does include the documentation for Other-Modules). Anyways, I‚Äôll submit the patch :-)
08:23:19 <Beelsebob> Toxaris: ohh, that's nice
08:23:22 <conal> edwardk: sure.  both.  i like the simplicity of Monoid over MonadPlus, but it's both.
08:23:35 <Beelsebob> I think yours wins on neat idea, and mine wins on outright simplicity
08:23:36 <edwardk> conal: k, wasn't sure
08:23:41 <dcoutts_> conal: right, that was it, and you needed to call haddock with some tricky flags. If you could document what you want to do that'd be useful for people hacking on that area in future.
08:23:54 <dcoutts_> conal: a relevant ticket might be http://hackage.haskell.org/trac/hackage/ticket/196
08:23:56 <lambdabot> Title: #196 (ability to specify custom args to haddock) - Hackage - Trac
08:24:09 <dcoutts_> nomeata: thanks
08:24:48 <dcoutts_> nomeata: though for exes it still does not use the --ignore-all-exports
08:25:08 <nomeata> dcoutts_: right, adding that right now.
08:25:28 <conal> dcoutts_: i made more progress with compiling gtk2hs.  i'm now stuck at
08:25:28 <conal> ./tools/c2hs/c2hsLocal.exe +RTS -M120m -RTS --cppopts='-include "gtk2hs-config.h"' --precomp=glib/glib.precomp glib-object.h
08:25:28 <conal> c2hsLocal.exe: glib-object.h: File does not exist
08:25:40 <Toxaris> Beelsebob: I realy like the "microcode" approach in my interpreter :) I'm currently working on an formulation of bf in a single line
08:26:03 <conal> dcoutts_: i do have glib-object.h, but i don't know how to get it to be found.
08:26:07 <dcoutts_> conal: so that means we cannot find glib-object.h on the include search path
08:26:10 <Toxaris> Beelsebob: using (***) or something to hide tuple processing, and some sensible function to produce the Bands
08:26:19 <Beelsebob> Toxaris: >.< sounds idiotic, but exactly the kind of idiocy needed for BF
08:26:24 <dcoutts_> conal: pkg-config --cflags should have told us the right flags to make that work
08:26:51 <dcoutts_> conal: what does pkg-config --cflags gobject-2.0 tell us?
08:27:16 <dcoutts_> conal: eg on my system it says -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include and inside one of those dirs is glib-object.h
08:28:04 <conal> dcoutts_: 8 [main] pkg-config 248 _cygtls::handle_exceptions: Error while dumping st ate (probably corrupted stack)
08:28:14 <dcoutts_> conal: oh dear :-(
08:28:19 <conal> yeah :(
08:28:58 <dcoutts_> conal: I really have no experience with cygwin, I always use mingw and the Gtk+ packages from gtk.org, the ones I provide on the gtk2hs website
08:28:58 <conal> dcoutts_: should i add the directory with glib-object.h to INCLUDE?  will there be others?
08:29:26 <dcoutts_> conal: if pkg-config is not working then there would be a lot of manual work to do to find all the dirs and linker flags
08:29:40 <conal> dcoutts_: urg.  no fun.
08:29:59 <dcoutts_> conal: eg pkg-config --cflags --libs gtk+-2.0 gives me 20 different flags
08:30:09 <dcoutts_> that's a lot to work out manually
08:30:56 <nomeata> hmpf. darcs has no way to abort a darcs send when you are already editing the description, it seems. sorry for the undocumented send, another will follow shortly
08:31:09 <dcoutts_> conal: I'd recommend the gtk packages I have on the gtk2hs website, they should work ok, though they're native windows applications not cygwin ones
08:31:51 <dcoutts_> conal: you've tried that before though right? I recall making a .zip version for you
08:31:55 <dcoutts_> http://haskell.org/gtk2hs/win32/
08:32:10 <dcoutts_> or was it a .tar.bz2, I forger
08:32:13 <dcoutts_> forget
08:32:40 <conal> dcoutts_: i'm using packages from gtk.org: gtk+-bundle-2.12.9
08:32:51 <conal> dcoutts_: the cygwin ones didn't install for me
08:32:55 <dcoutts_> conal: oh right
08:33:20 <dcoutts_> conal: in that case are you sure that we're picking up the right pkg-config binary on the path?
08:33:51 <dcoutts_> conal: that error looked like it came from a cygwin binary, perhaps that one is getting found rather than the one from your gtk-bundle
08:34:10 <conal> dcoutts_: the gtk-bundle would have its own pkg-config command?
08:34:14 <dcoutts_> conal: yes
08:34:26 <dcoutts_> and it would not need any env var fiddling
08:34:53 <mehrheit> http://hpaste.org/7308#a0 -- could someone help with this?
08:35:01 <conal> oh -- 'which' finds the cygwin one.  not sure about gtk2hs's ./configure and make
08:35:11 <dcoutts_> conal: it'll do the same
08:35:26 <dcoutts_> so yes, try putting the bin dir of the gtk-bundle on the path first
08:35:33 <dcoutts_> conal: btw, if you just want a pre-built gtk2hs version that works with ghc-6.8.2, I've got one available. Of course you may prefer to build from source.
08:35:34 <dolio> byorgey: No, I don't think anyone's worked on Charity for like 10 years.
08:35:35 <conal> dcoutts_: will do.  thx.
08:36:02 <conal> dcoutts_: good to know.  would you give me that pointer again, in case i don't manage to build?
08:36:25 <dcoutts_> conal: http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.12.1.exe
08:36:33 <nomeata> dcoutts_: patch submitted. now darcswatch also tracks the cabal repository: http://darcswatch.nomeata.de/repo_http:__darcs.haskell.org_cabal.html
08:36:37 <lambdabot> Title: DarcsWatch overview for http://darcs.haskell.org/cabal, http://tinyurl.com/6jgmwh
08:36:39 <conal> dcoutts_: great.
08:36:41 <dcoutts_> nomeata: ta
08:37:20 <dcoutts_> nomeata: how does it know what are the unapplied patches?
08:37:56 <nomeata> dcoutts_: because it has seen them, either by CC: (see my patch bundle), or because it‚Äôs subscribed to the list (as with darcs and xmonad)
08:38:41 <dcoutts_> nomeata: cool, we could subscribe it to cabal-devel and link the page from the hackage dev wiki
08:39:13 <nomeata> dcoutts_: sure, if you like: just subscribe darcswatch@nomeata.de using the admin interface of the mailing ist.
08:39:16 <dcoutts_> nomeata: how do submitted patches get marked obsolete or rejected?
08:39:39 <nomeata> dcoutts_: details on http://darcs.nomeata.de/darcswatch/documentation.html
08:39:40 <lambdabot> Title: DarcsWatch documentation
08:40:01 <nomeata> dcoutts_: in sort: reply to the patch bundle with [OBSOLETE] or [REJECTED] in the subject
08:40:18 <nomeata> dcoutts_: (or the more friendly "darcswatch: rejected" in the body, by dons request :-))
08:40:58 <RobRobRob> How come I can do 23::Rational, but I can't do (read "23"::Integer)::Rational ?
08:41:13 <dcoutts_> nomeata: right, REJECTED!!!1 is a bit ott :-)
08:41:39 <mauke> RobRobRob: you can't do (23 :: Integer) :: Rational either
08:41:42 <dolio> ::Foo isn't a cast.
08:41:42 <nomeata> dcoutts_: well, it‚Äôs to the point :-)
08:42:00 <dolio> It's specifying a concrete type for a polymorphic expression.
08:42:02 <RobRobRob> oh... so basically, how can I convert a double into a rational?
08:42:04 <lesshaste> Hi.. xs > [0] appears to check to see if all the values in xs are greater than 0
08:42:11 <lesshaste> what is going on there?
08:42:31 <nomeata> dcoutts_: the other way to mark a patch as obsolete is to send it‚Äôs inverse to the list (or to darcswatch directly), but some consider this too much hassle.
08:42:39 <dolio> @type fromRational
08:42:41 <lambdabot> forall a. (Fractional a) => Rational -> a
08:42:44 <lesshaste> I naively thought that [0] was of length 1 :)
08:42:49 <byorgey> lesshaste: no, the Ord instance for lists compares lists lexicographically
08:42:51 <mauke> > realToFrac pi :: Rational
08:42:53 <lambdabot>  884279719003555%281474976710656
08:43:10 <lesshaste> byorgey: ah..
08:43:19 <lesshaste> byorgey: when you say no, which part are you saying no to?
08:43:25 <byorgey> lesshaste: so xs > [0] will be true if the first element of xs is greater than 0, or it is equal to 0 and xs has more elements
08:43:26 <sclv_> edwardk: I just read your post and mainly sort of understood it! I'm getting better at this stuff. :-)
08:43:41 <byorgey> lesshaste: xs > [0] does not check to see whether all the values in xs are greater than 0.
08:43:45 <byorgey> lesshaste: for example:
08:43:52 <byorgey> > [0, -2, -5] > [0]
08:43:53 <lambdabot>  True
08:43:54 <RobRobRob> realToFrac 23.4 gave 23.4
08:44:06 <RobRobRob> rather than 117%5
08:44:06 <byorgey> > [-1, 3, 5] > [0]
08:44:07 <mauke> > 23.4 :: Rational
08:44:08 <lambdabot>  False
08:44:08 <lambdabot>  117%5
08:44:24 <byorgey> lesshaste: think dictionary ordering, but with numbers instead of letters
08:44:36 <lesshaste> byorgey: thanks.. very helpful indeed
08:44:36 <byorgey> @src [] Ord
08:44:36 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:44:41 <byorgey> @src Ord []
08:44:42 <lambdabot> Source not found. You type like i drive.
08:44:44 <conal> dcoutts_: hm.  now 'pkg-config --cflags gobject-2.0' gives '-Ic:/gtk+-bundle-2.12.9/include/glib-2.0 -Ic:/gtk+-bundle-2.12.9/lib/glib-2.0/include', and 'make' still results in 'c2hsLocal.exe: glib-object.h: File does not exist'.  glib-object.h is in c:/gtk+-bundle-2.12.9/include/glib-2.0.
08:44:45 <mauke> RobRobRob: realToFrac returns a number, not "23.4" or "117%5"
08:44:47 <RobRobRob> um, it definitely gives me 23.4
08:45:01 <lesshaste> byorgey: so if they are all  numbers >= 0 it doesn't effectively do what I said
08:45:02 <RobRobRob> ohhh
08:45:03 <RobRobRob> thanks
08:45:19 <dcoutts_> conal: and you re-ran ./configure ?
08:45:28 <conal> dcoutts_: oops!
08:45:30 <byorgey> lesshaste: right, if the first element is > 0, it will return True and not even look at the rest of them
08:45:53 <lesshaste> > [0, 0, 1, 0] > [0]
08:45:54 <lambdabot>  True
08:46:08 <lesshaste> > [0] > [0, 0, 1, 0]
08:46:09 <lambdabot>  False
08:46:12 <lesshaste> ok thanks :)
08:46:14 <dcoutts_> conal: that's a nice example of the lack of proper dependency tracking in traditional build systems :-(
08:46:16 <byorgey> lesshaste: sure =)
08:46:56 <lesshaste> > [0, -5, 1, 0] > [0]
08:46:57 <lambdabot>  True
08:47:54 <lesshaste> > [0, -5, -1, 0] > [0]
08:47:55 <lambdabot>  True
08:48:20 <lesshaste> fascinating :)
08:48:32 <lesshaste> how are you supposed to know the lexicographic ordering of -5 and 0?
08:48:40 <lesshaste> is it really by ascii value of - and 0?
08:49:05 <tromp> @src [] (>)
08:49:06 <lambdabot> Source not found. Take a stress pill and think things over.
08:49:23 <tromp> @src [] (<)
08:49:24 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:49:33 <mauke> lesshaste: huh? -5 is obviously less than 0
08:49:51 <tromp> there's no 0 to compare -5 with
08:49:54 <lesshaste> mauke: numerically sure.. but not lexicographically
08:50:02 <mauke> what?
08:50:09 <mauke> you can't compare numbers lexicographically
08:50:12 <lesshaste> mauke: right
08:50:19 <lesshaste> tromp: good point
08:50:28 <conal> dcoutts_: i have a dilemma.  configuring with --enable-opengl seems to depend on one version of pkg-config, while getting 'make' to succeed depends on another.
08:50:54 <dcoutts_> conal: ah, so the gtk-bundle you got didn't include the gtkglext component
08:51:07 <conal> dcoutts_: oh -- that's exactly it.
08:51:08 <dcoutts_> conal: you might be able to get that separately
08:51:23 <conal> dcoutts_: i got it separately.  maybe that's the problem.
08:51:28 <lesshaste> mauke: it was suggested above that that was how > worked with Ords
08:51:41 <lesshaste> but tromp made the killer point :)
08:51:42 <conal> dcoutts_: it can be found with the cygwin pkg-config, but apparently not with the gtk+ pkg-config
08:51:48 <dcoutts_> conal: right
08:51:55 <mauke> lesshaste: no, that's how > works with lists
08:52:26 <mehrheit> let t op = (1 `op` 1 :: Integer, 1.0 `op` 1.0 :: Double) in t (+) -- why is this impossible?
08:52:34 <dcoutts_> conal: I got the gtkglext directly from its sourceforge project page
08:52:44 <lesshaste> mauke: so what does it do exactly?  basically zipwith > the lists?
08:52:51 <conal> dcoutts_: me too
08:52:54 <lesshaste> zipwith (>)
08:53:00 <mauke> lesshaste: no, it does a lexicographic comparison
08:53:02 <dcoutts_> conal: http://downloads.sourceforge.net/gtkglext/gtkglext-win32-1.0.6.zip
08:53:04 <lambdabot> http://tinyurl.com/6pgeor
08:53:18 <lesshaste> mauke: but for the individual items in the list it must compare by their type ordering right?
08:53:34 <lesshaste> so -5 < 0
08:53:45 <lesshaste> and it doesn't compare '-' with '0' in some ascii way
08:53:47 <conal> dcoutts_: i got gtkglext-win32-1.2.0.exe  is 1.0.6.zip any more likely to work?
08:54:09 <dcoutts_> conal: I seem to remember picking the older one for some reason, I don't recall why
08:54:19 <conal> dcoutts_: i'll give it a try.  thx.
08:54:37 <mauke> lesshaste: yes
08:54:46 <conal> dcoutts_: do the gtk+ packages from http://haskell.org/gtk2hs/win32/ contain gtkglext?
08:54:52 <dcoutts_> conal: yes
08:55:11 <lesshaste> mauke: thanks
08:55:12 <conal> dcoutts_: then i'll try one of them.  any recommendation of which?
08:55:17 <lilac> > foldl (\a b c -> if a then a else b > c) False [0, -5, 1, 0] [0, -5, -1, 0]
08:55:18 <lambdabot>  Couldn't match expected type `Bool' against inferred type `t -> t1'
08:55:19 <dcoutts_> conal: I have scripts for generating those packages by combining individual tarballs from the gtk.org and other websites
08:55:25 <dcoutts_> conal: grab the latest -dev version
08:56:01 <Igloo> CosmicRay: Do you know how your gcc symlink ended up like that?
08:56:07 --- mode: Igloo set -o Igloo
08:56:33 <CosmicRay> Igloo: no, I don't
08:56:53 <CosmicRay> I don't think I did it manually, but can't prove it
08:57:13 <Igloo> OK; I've msged doko, so I'll see what he says
08:57:54 <lilac> > foldl (\a (b,c) -> if a then a else b > c) False $ zip [0, -5, 1, 0] [0, -5, -1, 0]
08:57:57 <lambdabot>  True
08:58:08 <CosmicRay> hrm.  if he is sure that the version of gcc you depend on does not put the symlink in that state, I suppose you could close the report.  however it seems it might be better to depend on gcc-4.2 and call gcc-4.2
08:59:33 <Igloo> But there might be good reasons to use 4.3 (e.g. gcc bugs on your platform)
08:59:45 <lilac> > any id $ zipWith (>) [0, -5, 1, 0] [0, -5, -1, 0]
08:59:46 <lambdabot>  True
08:59:47 <Igloo> And it also means ghc needs to be regularly updated
09:01:20 <tromp> > any (uncurry (>)) $ zip [0, -5, 1, 0] [0, -5, -1, 0]
09:01:22 <lambdabot>  True
09:04:00 <luqui> > or $ zipWith (
09:04:00 <lambdabot> Unbalanced parentheses
09:04:10 <luqui> > or $ zipWith (>) [0, -5, 1, 0] [0, -5, -1, 0]
09:04:11 <lambdabot>  True
09:04:22 <lilac> > foldl (\a b -> if a /= EQ then a else b) EQ $ zipWith compare [0, -5, -1, 0] [0, -5, -10, 1]
09:04:23 <lambdabot>  GT
09:04:53 <lilac> the 'or' and 'any' versions aren't lexicographic comparisons -- nor is my first foldl one :(
09:05:43 <byorgey> lilac: you're trying to make a lexicographic comparison?
09:06:22 <luqui> here's one
09:06:31 <luqui> [0, -5, 1, 0] > [0, -5, -1, 0]
09:06:34 <byorgey> but the Ord instance for lists already implements lexicographic comparison.
09:06:36 <luqui> > [0, -5, 1, 0] > [0, -5, -1, 0]
09:06:37 <lambdabot>  True
09:06:39 <byorgey> right =)
09:09:18 <lilac> byorgey: that's not the point ;-)
09:09:21 <conal> dcoutts_: that gtk2hs/win32 package got me unblocked.  compiling now.  i get a *lot* of lines like "gtk/Graphics/UI/Gtk/Pango/Attributes.chs.pp:205: missing ')' in expression".
09:09:42 <conal> dcoutts_: always missing ')', with different files & line numbers
09:09:49 <byorgey> lilac: ok =)
09:09:57 <byorgey> lilac: you were just trying to write one, for fun/learning?
09:10:07 <dcoutts_> conal: that means the version checking stuff has failed
09:10:13 <dcoutts_> conal: those lines look like:
09:10:17 <dcoutts_> #if PANGO_CHECK_VERSION(1,4,0)
09:10:26 <dcoutts_> conal: which means the PANGO_CHECK_VERSION macro is undefined
09:10:35 <dcoutts_> or part of it is
09:10:50 <dcoutts_> conal: it's defined in gtk2hs-config.h
09:10:51 <lilac> byorgey: it's the latest instalment of the 'build function x out of a fold' game
09:10:58 <byorgey> ahhh
09:11:00 <lilac> pretty easy one tho
09:11:31 <dcoutts_> conal: it uses other defines like _PANGO_MAJOR_VERSION, it's those that are probably undefined
09:11:52 * lilac is still trying to do the zip one, correctly handling infinite lists...
09:11:53 <conal> dcoutts_: can i do something about it?  need i?
09:11:55 <dcoutts_> conal: are you seeing something like: #define _PANGO_MAJOR_VERSION ()
09:12:15 <byorgey> lilac: but zipping two lists doesn't preserve information about length, which you need to know to do lexicographic comparison.
09:12:40 <conal> dcoutts_: #define _PANGO_MAJOR_VERSION (1)
09:12:48 <lilac> byorgey: yep, my solution above was wrong ;)
09:13:03 <dcoutts_> conal: hmm, that's fine, anything else near there look like it's missing?
09:13:11 <conal> dcoutts_: i do note ^M before closing parens in some places in gtk2hs-config.h
09:13:57 <lilac> byorgey: it's not as easy as i thought ;-)
09:14:05 <dcoutts_> conal: oh, that might be relevant. does that mean the ')' end up on a following line?
09:14:36 <byorgey> lilac: hehe =)
09:14:47 <conal> dcoutts_: not in emacs, but who knows for the c compiler
09:14:55 <dcoutts_> conal: I wonder if it's because we're using the wrong flavour of gcc
09:15:12 <byorgey> lilac: you need to zip up the lists in such a way to preserve the length information.  then it should be easy enough.
09:15:17 <conal> dcoutts_: http://hpaste.org/7309
09:15:19 <dcoutts_> conal: eg if we're using the cygwin one rather than the one ghc uses
09:15:57 <dcoutts_> conal: mm, that doesn't look like it's healthy :-)
09:16:25 <dcoutts_> conal: you could try just editing that file so the )'s are in the right place
09:16:56 <dcoutts_> conal: but more generally I'm not sure how well cygwin's gcc will play with ghc's one
09:18:41 <dcoutts_> sigh, this would all be much less fragile if gtk2hs were cabalised, all this textual substitution that autoconf/automake does is rather prone to this kind of problem
09:18:42 <conal> dcoutts_: sigh.  my cygwin bash appears to prepend some of its own bin directories to my PATH, to get first dibs.
09:19:12 <conal> dcoutts_: i'm recompiling.  uneventful so far.
09:19:44 <dcoutts_> g'morning JaffaCake
09:19:55 <JaffaCake> hiya
09:21:49 <dcoutts_> JaffaCake: did you see I probably set a record yesterday for the most ghc packages ever installed :-)
09:22:03 <dcoutts_> and that's actually only half of hackage
09:26:24 <geezusfreeek> dcoutts_: why?!
09:26:51 <dcoutts_> geezusfreeek: testing cabal-install and it'll be really useful for hackage QA
09:27:32 <dcoutts_> we're adding build reporting to cabal-install so we'll be able to use it a bit like a built bot, but for the whole of hackage
09:28:06 <dcoutts_> built bot/build bot
09:28:17 <geezusfreeek> ah nice
09:34:39 <conal> dcoutts_: i got through quite a lot more.  now: "hsc2hs.exe: /cygdrive/c/ghc/ghc-6.8.2.20071221/bin/ghc: runProcess: does not exist (No such file or directory)".  maybe a missing ".exe"?
09:35:03 <dcoutts_> conal: sounds like it
09:35:32 <conal> dcoutts_: any idea how to fix?
09:35:47 <dcoutts_> conal: oh, wait, no the problem is that from hsc2hs's point of view there is no such thing as /cygdrive/blah
09:36:01 <conal> oh!
09:36:04 <dcoutts_> conal: hsc2hs is a windows program not a cygwin program, it has no idea about cygwin paths
09:36:16 <conal> dcoutts_: yeah.  makes sense.
09:36:21 <dcoutts_> conal: all the ghc tools are native, not cygwin
09:37:35 <dcoutts_> conal: ghc itself uses mingw + msys to build, and that's what I've used to build gtk2hs too
09:41:59 <dcoutts_> conal: I'm going to disappear for a bit
09:42:10 <byorgey> edwardk, dolio, or any other CT enthusiasts: I've been thinking about the well-known 'difference list' representation of lists, type List a = [a] -> [a] .
09:42:17 <conal> dcoutts_: thanks for all the help.  i'll try your gtk2hs-0.9.12.1.exe
09:42:26 <byorgey> 'List' isn't a Functor or a Cofunctor... so what is it?
09:43:34 <vixey> hm
09:43:35 <edwardk> byorgey: yeah?
09:43:37 <byorgey> I'm thinking there must be some sort of categorical description of the correspondence between [a] and List a (it's easy to write functions going both ways whose composition is the identity), but it doesn't seem to be a natural transformation, since List isn't a functor
09:43:42 <vixey> do you have some functions on List ?
09:44:05 <edwardk> list is a bifunctor folded on the right
09:44:06 <vixey> I know how they work in Prolog and Oz .. but Haskell doesn't have logic/dataflow variables
09:44:35 <edwardk> i think you have a hom-prod correspondence between the two
09:44:42 <mauke> :t \f dl -> (map f dl ++)
09:44:49 <edwardk> one uses pairs (,) for cons the other uses (->)
09:44:56 <edwardk> not sure
09:44:58 <lambdabot> thread killed
09:45:23 <edwardk> the latter has a tree like structure the former is more regular, i'd have to chew on it more i think
09:45:32 <byorgey> edwardk: ok =)
09:46:18 <byorgey> my curiosity has just been aroused, since I was like, 'oh, this is obviously a natural isomorphism... let me write a Functor instance for [a] -> [a], like... oh... hrm...'
09:47:13 <edwardk> byorgey: well [a] -> [a] isn't a functor, thats invariant in a. you need an isomorphism to transform it. my ExpFunctor class will work on it, but not Functor.,
09:47:32 <vixey> but what is append :: List a -> List a -> List a ?
09:47:32 <byorgey> edwardk: right, I figured that out, but that's as far as I got =)
09:47:39 <byorgey> vixey: (.)
09:47:50 <vixey> oooo
09:47:55 <edwardk> you want a dinatural transformation between [a] and DList thats formed by the fromList and toList functions
09:47:58 <vixey> :D
09:47:58 <byorgey> vixey: the list xs is represented by the function (xs++)
09:48:03 <cinema> @messages
09:48:03 <lambdabot> You don't have any new messages.
09:48:28 <byorgey> edwardk: ok, hmm, I'll have to look up 'dinatural transformation'
09:48:54 <edwardk> i might have that backwards in terminology
09:49:01 <edwardk> don't take what i said there with any weight ;)
09:49:07 <byorgey> ok =)
09:49:14 <mattam> List is a folded bifunctor ? What's the unfolded bifunctor then ?
09:49:37 <byorgey> edwardk: that was my next question, what's a folded bifunctor?  I know what a bifunctor is.
09:49:37 <edwardk> mattam: data ListF a x = Cons a x | Nil
09:50:17 <edwardk> data MuB s a = InB { outB :: s a (MuB s a) }
09:50:25 <edwardk> same construction as for fix just with a bifunctor
09:50:27 <mattam> Then you put a Œº ...
09:50:39 <mattam> But for List a = [a] -> [a]
09:50:39 <mauke> ¬µŒº¬µŒº¬µŒº¬µŒº
09:51:11 <edwardk> i think the bit about List a = [a] -> [a] was me misparsing his question at first
09:51:23 <edwardk> I read List as [] at first =)
09:51:33 <byorgey> ah, sorry =)
09:51:40 <byorgey> let's call it DList instead, to avoid confusion
09:51:43 <mattam> Then clearly [a] and List a would be isomorphic :
09:51:44 <mattam> )
09:52:14 <Saizan> mmh, so, what [a] -> [a] is the fixpoint of? (if it is)
09:52:24 <edwardk> [a] -> [a] is 'exponential'. you can't write an instance of Functor for it. you can write something similar given an isomorphism in Hask represented as an embedding projection pair though
09:53:07 <byorgey> 'embedding projection pair' = for example, toList = ($[]) and fromList = (++) ?
09:53:24 <mattam> ok.
09:53:25 <edwardk> saizan: it is (mu x. 1 + a x) -> (m x. 1 + a x)  it itself doesn't involve a fixpoint
09:53:49 <edwardk> class ExpFunctor f where xmap :: (a -> b) -> (b -> a) -> f a -> f b
09:54:22 <lispy> if programs are proofs how does that apply to dynamic languages like python or lisp?
09:54:27 <edwardk> given an embedding projection pair between a and b you can transform a function of [a] -> [a] to one from [b] -> [b]
09:54:41 <vixey> lispy: It doesn't
09:54:44 <orbitz> mauke: it's you!!
09:54:44 <mattam> Yep.
09:54:56 <mauke> orbitz: how are you gentlemen?
09:54:57 <lispy> vixey: no?
09:55:02 <vixey> lispy: no
09:55:05 <orbitz> languages like python and lisp are hard to prove correct for most of their properties
09:55:08 <lispy> vixey: why not?
09:55:16 <orbitz> that's why you have a buttload of unit tests
09:55:17 <edwardk> xmap f g = DList . map f . g . map h . runDList
09:55:17 <vixey> lispy: They aren't typed
09:55:23 <orbitz> mauke: i am at work good sir. how are you?
09:55:28 <edwardk> er map f . h . map g
09:55:33 <mauke> splendid
09:55:54 <orbitz> mauke: i need to start playign with haskell more. i have 2 book son it, i should read one, thent he other
09:55:58 <byorgey> edwardk: what's h?
09:56:15 <edwardk> er my mistake
09:56:28 <lispy> Okay, my question would be better stated as such: In the Curry-Howard isomorphism, they say a program is a proof.  But why is a python program not a program?
09:56:39 <edwardk> xmap f g (DList h) = DList (map f . h . map g)
09:56:50 <byorgey> edwardk: ah, right, that makes sense
09:56:59 <orbitz> not a program or not a proof?
09:56:59 <edwardk> thats what i get for trying to rewrite it 3 times before clicking submit ;)
09:57:05 <byorgey> hehe
09:57:14 <mauke> it probably proves something uninteresting, like A => A
09:57:18 <conal> lispy: i don't think CH says *all* programs are proofs.
09:57:19 <vixey> lispy: Because it's an untyped language
09:57:36 <edwardk> lispy: a python program is a proof, it just doesn't prove anything interesting coz the logic doesn't say anything
09:57:49 <lispy> vixey: careful, people object to that phrasing.  although, I would agree that it's not statically typed
09:57:57 <edwardk> you have blobs and you can apply any blobs to other blobs.
09:58:05 <edwardk> you've proven that you can write a particular soup of blobs
09:58:19 <mattam> Hmm, one can also see [] as a unary functor from types to types right, how does that relate to the bifunctor presentation ? What's the map for BiFunctor's looking like ?
09:58:24 <geezusfreeek> conal: i'd say all programs are proofs of something, it's just that that something might not be interesting in nonfunctional languages
09:58:25 <lilac> lispy: what you prove is about those degrees of freedom which are removed by types. no degrees of freedom are removed by pythons types
09:58:33 <vixey> lispy: just trying to explain to you ...
09:58:34 <lispy> ?remember edwardk [on python programs as proofs] you've proven that you can write a particular soup of blobs
09:58:35 <lambdabot> Done.
09:58:46 <geezusfreeek> lol nice quote there
09:59:11 <vixey> geezusfreeek: Curry Howard doesn't make sense unless you have typed lambda terms
09:59:21 <conal> how about this: a (well-typed) program is a proof that a given type is inhabited.
09:59:30 <lispy> conal: I see
09:59:42 <ptolomy2> Hm.. is there a convenient way to check for physical equality of bytestrings (as in, they represent the same memory region)?
09:59:43 <conal> some type systems correspond to interesting propositions.
09:59:47 <geezusfreeek> vixey: well there is certainly a typed lambda term equivalent for python programs. they are just going to be complicated and useless
10:00:12 <edwardk> mattam: for a list as a bifunctor, you tie off the right hand side of the bifunctor and you get a functor. the functor representation is the same output as the  map for Fix ListF
10:00:27 <vixey> that's not what a python program is
10:00:35 <conal> geezusfreeek: useless as logical propositions?
10:00:38 <lilac> lispy: if f :: (a -> b) -> [a] -> [b] then you know that the b's are created by applying the first argument to a's in the second argument, since the function has no other way of making b's.
10:00:40 <vixey> if you convert it to lambda terms and it happens to be well typed in some logic
10:00:50 <geezusfreeek> vixey: i know it's not what it is _designed_ to be
10:00:50 <vixey> you're so far off from where you started, you've not proved anything
10:00:50 <edwardk> instance Bifunctor p => Functor (MuB p) where map f = InB . bimap f (map f) . outB
10:00:56 <edwardk> er fmap
10:00:58 <geezusfreeek> vixey: that's exactly my point
10:01:02 <sclv_> @djinn (a->b) -> [a] -> [b]
10:01:02 <lambdabot> -- f cannot be realized.
10:01:06 <mattam> edwardk: ok
10:01:06 <geezusfreeek> the conversion is still possible, just probably not so useful
10:01:10 <mattam> @src Bifunctor
10:01:11 <lambdabot> Source not found. I've seen penguins that can type better than that.
10:01:27 <sclv_> oh right djinn no like lists
10:01:31 <Deewiant> lilac: you can always use undefined. ;-)
10:01:33 <conal> now substitute IO for Python
10:01:35 <edwardk> mattam one sec, i'll give you a def
10:01:44 <vixey> @djinn (a->b) -> Maybe a -> Maybe b
10:01:47 <lambdabot> f a b =
10:01:47 <lambdabot>     case b of
10:01:47 <lambdabot>     Nothing -> Nothing
10:01:47 <lambdabot>     Just c -> Just (a c)
10:01:48 <lilac> Deewiant: yes, undefined is of all types. so you can't prove a haskell program terminates based on type.
10:02:01 <mattam> (a -> b) -> (f a -> f b) -> g a b ?
10:02:02 <lilac> Deewiant: Turing would be happy about that...
10:02:03 <edwardk> mattam: http://comonad.com/haskell/category-extras/src/Control/Bifunctor.hs
10:02:04 <lambdabot> http://tinyurl.com/5a5y6l
10:02:09 <Deewiant> :-)
10:02:32 <lispy> conal: so you're saying that IO is equivalent to Python when it comes to proofs?
10:02:43 <mattam> Oh right they're completely independent.
10:03:33 <conal> lispy: that IO and Python are both languages of programs and neither has elegant & useful logic.
10:03:41 <lispy> Thanks everyone for the discussion about CH stuff :)
10:03:43 <edwardk> http://comonad.com/haskell/category-extras/src/Control/Bifunctor/ has a few other bifunctor bits and pieces. i just started putting it together so i could do bifunctor hylomorphisms
10:03:44 <lambdabot> Title: Index of /haskell/category-extras/src/Control/Bifunctor
10:04:05 <edwardk> mainly because that lets me do 'bimap' fusion to fuse in maps over the rest of the structure with a hylomorphism
10:04:10 <conal> lispy: Hakell IO that is.
10:04:16 <lispy> conal: right
10:04:53 <edwardk> coz right now i have to encode those using a natural transformation term
10:05:31 <lilac> lispy: if you have a value of type IO t, you know that (a) you've either hung or created a t, and (b) you've had zero or more arbitrary side-effects. not useful for proving stuff, really.
10:05:36 <edwardk> bbiab
10:06:01 <vixey> haskell isn't useful for proving stuff in general anyway
10:06:19 <vixey> you can't reason about programs in the type system and every type is inhabited anyway
10:06:41 <geezusfreeek> vixey: what do you mean you can't reason about programs in the type system?
10:07:05 <lispy> vixey: with some type system extensions you can reason quite a bit, like using GADTs to get ordered lists
10:07:08 <vixey> geezusfreeek: what I said isn't strictly true due to GADTs and such
10:07:40 <vixey> but you couldn't define say (++) :: Vector N -> Vector M -> Vector (N + M)
10:07:47 <vixey> because you can't put + in the type system
10:07:49 <conal> lispy: ordered lists via gadts??
10:08:02 <vixey> (as said not strictly true, you can do stuff like this :P)
10:08:13 <geezusfreeek> conal: you can do it but it's messy
10:08:16 <vixey> but it's hell
10:08:24 <conal> i didn't know that
10:08:35 <vixey> lispy: link?
10:10:53 <geezusfreeek> vixey: you can define a type level plus operator
10:11:10 <vixey> I know
10:11:15 <geezusfreeek> oh you qualified it
10:11:17 <geezusfreeek> i didn't see that
10:11:28 <dons> vixey: you should check out   the implementation of HOL in the type system
10:11:32 <lispy> vixey: http://darcs.net/  look in src/Darcs/Patch/Ordered.lhs
10:11:35 <lambdabot> Title: darcs
10:12:01 <lispy> vixey: report on how it's done is still being written
10:12:08 <vixey> where could it find it dons?
10:12:46 <RobRobRob> is there a way i can execute a string as a command?
10:13:01 <dons> vixey: roman leshchinskiy is working on it
10:13:06 <lispy> RobRobRob: like running a shell command?
10:13:07 <dons> vixey: using type families
10:13:19 <RobRobRob> like running a haskell command
10:13:19 <lispy> ?hoogle runInteractive
10:13:23 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
10:13:23 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
10:13:32 <byorgey> hm, I think edwardk was right, if we let  L a b = [b]  and  D a b = [a] -> [b]  then  fromList = (++) and toList = ($[]) can be seen as dinatural transformations from L -> D and D -> L respectively
10:13:36 <byorgey> ...I think =)
10:13:42 <mauke> RobRobRob: not really
10:13:43 <lispy> RobRobRob: oh, you'd probably need some magic if you're doing it from inside a haskell program.  lambdabot is a good example of such magic
10:14:02 <RobRobRob> ah ok
10:14:20 <RobRobRob> sounds a bit complicated
10:14:23 <geezusfreeek> RobRobRob: is this a case where you _know_ you need to do that or are you trying to metaprogram?
10:14:31 <vixey> sounds amazig
10:14:34 <vixey> sounds amazing*
10:14:44 <lispy> RobRobRob: another option is Template Haskell
10:14:57 <lispy> RobRobRob: it's not fully general, but you can essenitally execute some haskell at compile time
10:15:25 <vixey> is it online ?
10:15:28 <RobRobRob> ok
10:15:29 <RobRobRob> thanks
10:15:47 <geezusfreeek> hmm... this is the first time i have tried using the Cont monad. it seems... pathological
10:20:44 <Baughn> geezusfreeek: How so? Does it not work like continuations should?
10:21:06 <vixey> aren't continuations different in a \lazy language than strict?
10:21:17 <geezusfreeek> Baughn: i think my particular use of it is what is pathological ;)
10:21:45 <geezusfreeek> vixey: i don't see why they would be
10:22:02 <Baughn> vixey: Kinda. I haven't really tried to do the math, but I stil think laziness is more or less equivalent to continuations already, so..
10:22:21 <vixey> well I don't even understand strict cwcc yet so ...
10:22:24 <Baughn> vixey: Well, the difference would be that they're nicer in a lazy language. ;)
10:27:20 <mauke> :t local
10:27:21 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
10:28:51 <RobRobRob> Can someone have a look at my code for parsing a polish-notation input like '+ - 2 1 4' and help me correct getExpr? http://rafb.net/p/jAex2r68.html
10:28:53 <lambdabot> Title: Nopaste - No description
10:31:12 <Baughn> RobRobRob: Ah, are you hand-writing a parser?
10:31:22 <vixey> > unwords "+ - 2 1 4"
10:31:23 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
10:31:24 <Baughn> RobRobRob: Use parsec instead. Seriously.
10:31:29 <vixey> > words "+ - 2 1 4"
10:31:31 <lambdabot>  ["+","-","2","1","4"]
10:31:46 <RobRobRob> parsec?
10:32:10 <vixey> map classify . words where classify "+" = Add ; "-" = Subtract ; s = Num (read s)
10:32:30 <vixey> then implement an evalutor using a stack machine or something
10:33:09 <vixey> RobRobRob: That's how I'd go about it anyway
10:33:19 <RobRobRob> well it's the evaluator that i'm having trouble with... i don't know anything about stacks
10:33:28 <vixey> It's very simple
10:34:14 <vixey> suppose your language has two tyes
10:34:16 <vixey> types
10:34:17 <Baughn> RobRobRob: Parsec's a parser-combinator library. It should still be in the default ghc install, though not if you compiled it from source and failed to get extra libraries
10:34:36 <Baughn> RobRobRob: This stuff is simple enough that you /can/ write a parser by hand, but using parsec will still remove a lot of the scutwork
10:34:42 <vixey> Baughn I think map classify . unwords is more suitable than parsec here
10:35:22 <lispy> > Num (read "1")
10:35:23 <lambdabot>   Not in scope: data constructor `Num'
10:35:30 <lispy> Oh, N/m, I see
10:35:32 <Baughn> vixey: It really /is/ that simple, I guess
10:35:41 <vixey> so if you have binary Functions and Values, process the stream of tokens one by one modifying the state of the machine (state being a stack)
10:35:48 <Baughn> > (read "1") :: Num a => a -- This is what you wanted
10:35:48 <lambdabot>        add (Read a) to the context of
10:35:48 <lambdabot>         the polymorphic type `forall a....
10:36:03 <Baughn> ..not that it'd /work/, since you need a particular type to decide which read to call
10:36:15 <lispy> Baughn: yeah, I was just looking at vixey's example.  Then I realized that vixey intended for Num to be a constructor
10:40:06 <mattam> edwardk: you mention in your article: http://comonad.com/reader/2008/rotten-bananas/ that we could have ExpFunctor f => Functor f but I doubt it... it's the other way around.
10:40:09 <lambdabot> Title: The Comonad.Reader ª Rotten Bananas
10:43:23 <edwardk> mattam: not quite every Functor is an ExpFunctor. you can just ignore the other half of the morphism
10:43:40 <edwardk> mattam: every contravariant functor is also an instance of expfunctor
10:43:42 <byorgey> http://hpaste.org/7312
10:43:55 <edwardk> just ignore the OTHER morphism
10:44:08 <byorgey> edwardk: toList and fromList are indeed dinatural transformations, see my paste
10:45:07 <edwardk> byorgey: you defined it as a bifunctor contravariant in the first argument
10:45:15 <byorgey> edwardk: right
10:45:34 <vixey> RobRobRob: http://hpaste.org/7313
10:45:44 <vixey> > run "* + 2 2 7"
10:45:44 <vixey> Just 28
10:45:44 <lambdabot>   Not in scope: `run'
10:45:50 <vixey> shush lambdabot
10:45:51 <byorgey> edwardk: my code can probably be simplified considerably but I was pleased that I was able to make sense of it and get it to work =)
10:45:51 <mattam> edwardk: Why is not every functor an expfunctor ? I supposed they had roughly the same laws.
10:46:30 <edwardk> mattam: every functor is an expfunctor, its that not every expfunctor is a functor. i.e. data Exp a = App a a | Lam (a -> a) is an Expfunctor but not a Functor
10:46:55 <mattam> Yes. So the comment in your article is wrong.
10:47:28 <vixey> edwardk: is that higher order abstract syntax?
10:47:33 <edwardk> the 'class syntax' in haskell is wrong, i wrote it as a 'class specification' =)
10:47:35 <edwardk> vixey: yeah
10:47:59 <edwardk> class ExpFunctor f => Functor f is how you say that every Functor is an ExpFunctor ;)
10:48:05 <edwardk> the arrow runs the wrong way
10:48:36 <mattam> Oh.
10:48:53 <mattam> I know that proposition from Dan Piponi IIRC :)
10:49:10 <edwardk> yeah
10:49:25 <edwardk> it always messed me up
10:50:38 <edwardk> anyways the lack of extensible superclasses makes haskell rather painful if you modularize things too much and break out each law.
10:50:53 <Saizan> > take 10 (randoms (mkStdGen 1))::[Word64]
10:50:54 <lambdabot>   add an instance declaration for (Random Word64)
10:51:41 <mattam> Then it's clearer. You can always have instance Functor f => ExpFunctor f .
10:52:00 <edwardk> yeah but that means you can't have any other things => ExpFunctor and THAT is a problem
10:52:14 <edwardk> because you'd have an ambiguous instance head
10:52:16 <mattam> (or maybe you can't in Haskell).
10:52:22 <edwardk> you have to allow overlapping instances for that basically
10:52:40 <byorgey> ah, I just realized my BiOpFunctor, representing a functor A^op x B -> C was unnecessarily general, since dinatural transformations are defined on bifunctors C^op x C -> D... which is just edwardk's ExpFunctor =)
10:52:45 <edwardk> so if you had instance ExpFunctor f => ExpFunctor (Dual f) then you'd blow up
10:52:55 <mattam> Yeah right, I'm fine with that in Coq.
10:52:56 <edwardk> byorgey: heh
10:53:02 <byorgey> simplified version: http://hpaste.org/7312#a1
10:54:02 <byorgey> I just translated the diagram from https://secure.wikimedia.org/wikipedia/en/wiki/Dinatural_transformation into quickcheck properties =)
10:54:13 <dons> awesome.
10:54:39 <dons> so the natural transformation is what, an fmap fusion law?
10:55:28 <byorgey> dons: well, it's xmap (from edwardk's ExpFunctor class), not fmap, since DList a = [a] -> [a] is not a functor
10:55:43 <byorgey> I don't know if it would be useful as a fusion law.  probably not.
10:55:53 <dons> instance Functor DList where fmap = map
10:55:55 <dons> ?
10:56:06 <byorgey> dons: nope. try it =)
10:56:09 <dons> i don't know if that's morally sound though
10:56:26 <byorgey> you won't get it to type.  it can't be done.
10:56:31 <dons> hmm?
10:56:35 <byorgey> since the type a is on both sides of the arrow
10:56:44 <dons> map          :: (a -> b) -> DList a -> DList b
10:56:44 <dons> map f        = foldr (cons . f) empty
10:57:11 <dons> http://code.haskell.org/~dons/code/dlist/Data/DList.hs
10:57:12 <byorgey> ...oh.
10:57:15 <edwardk> byorgey: his map cheats =)
10:57:24 <byorgey> edwardk: how so?
10:57:42 <edwardk> map f = foldr (cons . f) empty
10:58:06 <dons> fold is a map :)
10:58:09 <byorgey> how is that cheating?
10:58:24 <dons> practice: 1, theory: 0
10:58:34 <byorgey> hehe
10:58:52 <byorgey> well, I'm not keeping score, I just want to understand the theory =)
10:59:16 <edwardk> byorgey: it basically pays the cost of converting back to a list form maps there nad converts back
10:59:32 <byorgey> edwardk: ah, right, I see.
10:59:56 <dons> right.
11:00:04 <dons> it literally does.
11:00:06 <dons> foldr f b    = List.foldr f b . toList
11:00:35 <edwardk> byorgey: i'd assume then that the cost of accessing the first element post map is something high
11:00:36 <dons> you really only get a few operations on the opaque (.) constructor
11:00:38 <byorgey> so it takes advantage of the dinatural isomorphism to 'lift' a functor instance for [] to a functor instance for DList
11:01:26 <byorgey> edwardk: right, makes sense
11:02:37 <Saizan> ?type \f -> (++) . map f . ($[]) -- without foldr fusion :)
11:02:39 <lambdabot> forall a b (f :: * -> *) a1. (Functor f, Monoid (f b)) => (a -> b) -> ([a1] -> f a) -> f b -> f b
11:02:52 <roconnor> This is because DList a is supposed to be a subset of the type [a] -> [a]?
11:03:15 <roconnor> or does parametricity make them exactly the same?
11:03:29 <roconnor> I guess rev :: [a] -> [a]
11:03:33 <roconnor> but it isn't a DList.
11:03:41 <byorgey> roconnor: yeah, I was just thinking along those lines
11:04:08 <edwardk> roconnor: yeah you have conventions on what you can do to the [a]'s
11:05:04 <byorgey> so although we can define map on DList, it doesn't make a valid instance of Functor, since it doesn't work on *any* values of type [a] -> [a]... right?
11:05:45 <edwardk> well technically i think it might
11:05:53 <byorgey> i.e. what would be the result of  map (+1) (DList rev) ?
11:06:09 <byorgey> hmm...
11:06:11 <roconnor> []
11:06:15 <roconnor> is my guess
11:06:39 <roconnor> er
11:06:40 <roconnor> id
11:06:43 <dons> ?seen Binkley
11:06:44 <lambdabot> I haven't seen Binkley.
11:07:00 <roconnor> because the corresponding list to rev is rev [] = []
11:07:20 <Philippa> dons: he tends not to be on IRC all that much, no? Haven't seen him on AIM in a while either though
11:07:30 <edwardk> byorgey: there aren't any real bad definitions you can make coz your worst case is an infinite list and loss of sharing
11:08:11 <edwardk> the problem is i can make a dlist that isn't a list
11:08:14 <edwardk> ah
11:08:16 <edwardk> here it is
11:08:25 <edwardk> take one that takes the list you give it and then does something to that
11:08:33 <edwardk> rather than append it
11:08:35 <byorgey> right
11:08:55 <edwardk> you are projecting from list -> something larger, thats why dlist isn't a functor
11:09:25 <edwardk> when you project back out to the smaller domain of [] you can map, but you can't represent every DList as a []
11:10:08 <edwardk> @type cycle
11:10:09 <lambdabot> forall a. [a] -> [a]
11:10:19 <edwardk> DList cycle is a 'valid' DList but doesn't make sense
11:11:20 <roconnor> > cycle []
11:11:21 <lambdabot>  Exception: Prelude.cycle: empty list
11:11:31 <roconnor> that doesn't seem very valid
11:11:32 <Beelsebob> > cycle [1,2,3,4,5]
11:11:33 <lambdabot>  [1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3...
11:11:41 <nominolo> @seen Beelsebob
11:11:42 <lambdabot> Beelsebob is in #haskell. I last heard Beelsebob speak 9s ago.
11:11:46 <Beelsebob> o.O
11:11:46 <nominolo> heh
11:11:51 <sfogarty> Um. As someone to whom kernel versions are an entirely abstract thing, might problems arise from running a binary compiled for 2.6.9 on a kernal running 2.6.4?
11:11:53 <Beelsebob> blimeh
11:11:59 <Beelsebob> what you looking for nominolo?
11:12:02 <sfogarty> er, 2.6.5
11:12:09 <nominolo> Beelsebob: are you at Kent?
11:12:17 <edwardk> @type (1:) . cycle
11:12:18 <lambdabot> forall a. (Num a) => [a] -> [a]
11:12:25 <edwardk> er
11:12:28 <Beelsebob> not any more, but I was until about 3 days ago
11:12:32 <edwardk> @type cycle . (1:)
11:12:34 <lambdabot> forall a. (Num a) => [a] -> [a]
11:12:36 <edwardk> there =)
11:13:23 <edwardk> i was just looking for any function that takes a list and does something other than append it for you =)
11:13:38 <edwardk> even easier (++xs)
11:13:51 <roconnor> edwardk: reverse?
11:13:57 <edwardk> another one
11:14:16 <edwardk> there are lots of things in DList a that aren't in [a]
11:14:18 <roconnor> reverse . reverse?
11:14:36 <edwardk> roconnor: sure coz now you've injected a bottom
11:14:47 <mauke> drop 1
11:14:48 <Saizan>  fmap id  cycle . DList (1:) /= cycle . (1:) so fmap id /= id? (where fmap is the one for DList here)
11:14:50 <sfogarty> Is there a way to compile a binary for 2.4 or 2.5?
11:14:52 <edwardk> mauke: heh
11:15:09 <Lemmih> sfogarty: The kernel version shouldn't matter.
11:15:20 <roconnor> drop 2
11:15:35 <sfogarty> beh. That was my only lead. Runs fine on one computer, crashes with 'floating point exception' on another
11:15:36 <byorgey> ah, right, so fmap id =/= id
11:15:50 <byorgey> ah, Saizan just said that =)
11:16:00 <Lemmih> sfogarty: Same GCC version on both machines?
11:16:12 <Saizan> yeah, leaving a spurios DList constructor :)
11:16:15 <edwardk> saizan: and hence why map isn't a valid representation of 'fmap' for all things you could represent in DList. Its fine though for the subset thats defined though
11:16:23 <sfogarty> No, can't get the compiler to run on one of the machines. Everything compiled on a third machine (which it also runs on)
11:17:42 <sfogarty> Which I suppose might be related :)
11:17:46 <edwardk> heh which is a shame coz i kinda like the sort of cheaty lists like: parenthesize x = DList (\x -> "(" ++ x ++ ")")
11:18:02 <byorgey> hehe
11:18:33 <byorgey> fromList . toList isn't id on that, I think
11:18:41 <edwardk> exactly
11:19:25 <mauke> what do you call a function that isn't an isomorphism?
11:19:48 <vixey> maybe a sur/injection ?
11:20:01 <byorgey> mauke: is this a question, or the start of a joke? =)
11:20:20 <mauke> a question but you're free to come up with a punchline :-)
11:20:49 <byorgey> I don't think there's a term for 'functions which are not isomorphisms'
11:21:17 <geezusfreeek> mauke: a homomorphism? is that what you are looking for?
11:21:31 <geezusfreeek> that's only on groups, of course
11:21:59 <dolio> There are homomorphisms on lots of kinds of things.
11:22:00 <YourAlgebra> a bit is to SQL as _______ is to java
11:22:00 <YourAlgebra> can anyone fill in the blank
11:22:20 <lispy> bit
11:22:23 <geezusfreeek> dolio: well, s/groups/less general things than just categories/
11:22:26 <sfogarty> Specifically, attempting to run the 'configure' script calls the build-in pwd, which died with: pwd: timer_create: Invalid argument
11:22:56 <geezusfreeek> or whatever
11:23:02 <geezusfreeek> it's all interrelated anyway
11:24:54 <geezusfreeek> in the context of categories i suppose just "morphism" would be the word... i wish i knew what i was talking about though ;)
11:25:37 <edwardk> morphisms are arrows, in the category of types (or set), arrows in that category are functions
11:26:13 <edwardk> isomorphisms say that something is in some sense the same thing or interchangeable. there isn't a word i know of for something that 'is a morphism but not an isomorphism' if thats what you meant
11:27:36 <dolio> Not-isompormphism. :)
11:28:12 <dolio> Like when someone asked a few days ago what you call a function that isn't injective.
11:28:14 <sfogarty> function with no inverse?
11:28:18 <edwardk> dolio: heh
11:28:42 <sfogarty> (my head projects category theory down to set theory, I'm afraid)
11:29:07 <sfogarty> so any clue why the programs included in the tarball all die with: ghc-pkg.bin: timer_create: Invalid argument
11:29:12 <acidjnk> hello
11:29:23 <geezusfreeek> hello
11:36:29 <YourAlgebra> hello
11:37:49 <minivan> ŒØœÉŒ∑œÇ œÉœáŒÆŒºŒ± -> ŒîŒµŒΩ ŒØœÉŒ∑ œÉœáŒÆŒºŒ±. So anisomorphic? =P
11:38:03 <Deewiant> It's all Greek to me!
11:38:06 <Beelsebob> o.O
11:38:09 <minivan> *anisomorphism
11:38:21 <minivan> (also google translation, probably not accurate)
11:38:41 <dmwit> Hiya, YourAlgebra!
11:40:10 <mauke> why "an-"? doesn't that say "den"?
11:42:10 <lispy> how do people combine unit tests with modules in Haskell in real projects?  Suppose you're using quickcheck or hunit.  You define a test somewhere (where?) and then how are running all of them (eg., how do you construct the unit test binary and run it)?
11:42:54 <lispy> It seems to me that the tests need to be defined and exported from the modules
11:43:00 <lispy> Otherwise you can only test top level definitions
11:43:02 <dmwit> Isn't there a tool to verify all the functions named "prop_*" in a file?
11:43:14 <lispy> dmwit: I wrote a TH hack to do that
11:43:22 <lispy> dmwit: but, I'm wondering what others do
11:43:38 * dmwit has a look at xmonad
11:45:49 <sfogarty> *grumble* If I'm using a haskell program on a old build with a broken ghc, is there any way to statically bundle the correct functions? I'm assuming now
11:46:25 <sfogarty> sorry, broken glibc
11:46:25 <minivan> mauke: heh, blame google! ;)
11:46:37 * dmwit doesn't understand how xmonad runs tests
11:47:32 <dmwit> Oh, never mind, yes I do.
11:47:54 <dmwit> lispy: It looks like in xmonad, they just list all of the tests to run in main and map over the list.
11:47:56 <lispy> dmwit: so it looks as though they only test the exported things
11:48:14 <olsner> sfogarty: I got that timer_create thing when trying to install ghc 6.8.2 ... the solution was to install 6.6.1 and build the newer ghc from source
11:49:16 <sfogarty> olsner: thanks, I will try that. I just succeded in installing 6.6, although it's complaining about libreadline.so.5
11:50:41 <sfogarty> because I seem to have libreadline.so.4
11:51:31 <glguy> @seen byorgey
11:51:31 <lambdabot> byorgey is in ##logic, #xmonad, #haskell-blah and #haskell. I last heard byorgey speak 26m 45s ago.
11:51:37 <byorgey> hi glguy
11:51:40 <pejo> sfogarty, if you just need 6.6 for building 6.8 chances are that you can change the "libreadline.so.5" to "libreadline.so.4" in the binary. But that is a hack to say the least. :-)
11:51:58 <olsner> yeah, you could try symlinking libreadline.so.4 to libreadline.so.5 (readline shouldn't be used anyway unless you use ghci (which you wouldn't when just building the source))
11:52:10 <glguy> byorgey: I was reading through the forum for pe155, and saw you Haskell solution (clean enough) but I wondered if you saw the 3 line J solution
11:52:11 <sfogarty> hey, I'll try
11:52:29 <pejo> olsner, that might make other programs confused though.
11:54:18 <byorgey> glguy: I hadn't really looked at it.  what about it?
11:54:31 <sfogarty> hey, look at that
11:54:40 <sfogarty> I just edited the binary.
11:55:34 <sfogarty> simlinking didn't immediately work, and making 'the more elegant hack' seemed a bit silly
11:56:14 <sfogarty> and hey, if it compiles this one program, I can even avoid having to build 6.6.8
11:57:06 <lilac> using Parsec, if I'm doing my own tokenizing, how can I create a SourcePos?
11:57:10 <sfogarty> wow. Thank you all very much.
11:57:55 <byorgey> so, I'm going to be giving a 15-minute talk to an audience of mostly mathematicians, showing them some cool examples of Haskell, and basically explaining why, as mathematicians, they should care about learning it.
11:58:01 <byorgey> any suggestions for a title?
11:59:39 <sfogarty> 'Don't throw away your set comprehensions'? ...I should note this is not a task at which I excel
11:59:45 <lispy> byorgey: something about Curry-Howard?
11:59:59 <sclv_> "proofs you can execute, executables you can prove"
12:00:25 <therp> I'm not sure if haskell is about curry-howard or proofs at all
12:00:35 <vixey> therp: it's not
12:00:37 <lilac> "abstract algebra for the new generation"
12:01:01 <byorgey> I was actually thinking of emphasizing more the fact that because of laziness + purity, Haskell code looks a lot like what a mathematician would expect.
12:01:03 <lispy> byorgey: why should a mathematician care about Haskell anyway?
12:01:20 <dmwit> Executable Math
12:01:28 <byorgey> because they can write code to compute things, which actually corresponds to the way they already think.
12:01:41 <sclv_> dmwit: nice!
12:01:44 <Botje> "Haskell :: Just Math"
12:01:50 <dmwit> oooo
12:01:51 <lispy> Botje: hahah
12:01:54 <sfogarty> That's what I would go with, byorgey. For me, it's the list comprehensions that really enable that
12:02:02 <byorgey> dmwit: hm, I like it!
12:02:06 <therp> byorgey: yes I'd say that's a good concept. at the end Haskell is pretty good at being just a functional programming language
12:02:23 <byorgey> I may mention curry-howard too
12:02:52 <byorgey> but if you really care about doing proofs you (as a mathematician) probably want to use a dependently typed language anyway.
12:02:59 <dmwit> Botje: Although Just isn't a type... it would have to be Haskell = Just Math. ;-)
12:03:00 <therp> sfogarty: list comprehensions are just sugar.. but it seems mathematicians like sugar. most of them constantly seem to invent new notations :)
12:03:11 <lispy> byorgey: there is a danger in telling math oriented people that programming language Y lets them write code the way they think...math people think in terms of values that are only known to exist and infinities that would be hard for even lazy eval to deal with
12:03:16 <byorgey> yeah, Haskell :: Maybe Math doesn't have the same ring to it =)
12:03:30 <dmwit> heh
12:03:47 <vegai> Haskell :: Maybe Meth
12:03:49 <sfogarty> therp: Might well be, but I can directly translate the set notation on my paper to the computer, add a nub, and call it good
12:03:51 <byorgey> lispy: well, that's true.  I'm not just going to say 'Haskell lets you translate your thoughts directly into code!' =)
12:03:59 <sfogarty> (and then I wonder why my performance dies)
12:04:23 <lispy> byorgey: good, that was the mistake people made when teaching me prolog.  I was disgusted that so many logical things just would end up in infinite searches
12:04:24 <dmwit> lispy: Actually, I think Haskell is pretty good at expressing math *concepts*.  (Though as you say, sometimes math *values* are a bit tougher.)
12:08:18 <sfogarty> therp: I assume they are compiled to zips and filters, then?
12:08:34 <sclv_> Oh main... I just backed myself into needing type level lists.
12:08:38 <sclv_> s/main/man/
12:09:16 <sclv_> although maybe I can make do with a type level maybe.
12:09:17 <therp> sfogarty: more generally they can be rewritten to monads http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#monads
12:09:18 <lambdabot> Title: Wadler: Monads
12:09:34 <therp> sfogarty: and on top of the List monads, it give you the list comprehension, you are most likely used to
12:09:42 <byorgey> ok, so how about "Executable Mathematics: a Whirlwind Introduction to Haskell" ?
12:09:46 <therp> s/give/gives/
12:09:50 <byorgey> or maybe some Other Sort of Introduction?
12:09:54 <dmwit> byorgey: I would attend. =)
12:10:11 <byorgey> dmwit: you don't count! =)
12:10:13 <dmwit> "An Unpleasant Introduction" =P
12:10:31 <byorgey> "An Insufferably Dull Introduction" ?
12:11:09 <sclv_> abbreviated introduction.
12:11:14 <sfogarty> therp: thanks. Although, imo, the "Essence of Functional Programming" paper is a nasty bait and swap trick. "Oh, after reading this six time I finally understand monads! Lets see what they do in haskell..."
12:11:20 <dmwit> I like abbreviated.
12:11:47 <byorgey> hm, really?  I think I want to give the impression that it's exciting, rather than that it's short.
12:11:56 <sclv_> or abridged :-)
12:11:56 <byorgey> everyone already knows it will be short, all the talks are 15 mins.
12:12:02 <dmwit> yeah
12:12:13 <dmwit> So hey, if it's dull, at least it's only 15 minutes. ;-)
12:12:24 <byorgey> and there will be three other talks going on at the same time, so advertising matters! =)
12:12:31 <therp> sfogarty: I read them when I was doing civil service with ex-prisoners. the papers were pure fun to me compared to the alternative activities offered :)
12:12:36 <byorgey> haha
12:12:38 <dmwit> Also, "introduction" sort if implies shortness.
12:12:44 <byorgey> indeed.
12:12:54 <sfogarty> therp: I believe it :) I actually love the essence paper, it just does /not/ prepare you for using monads in Haskell
12:12:55 <YourAlgebra> hi dmwit
12:17:28 <byorgey> an Intriguing Introduction?  an Inspiring Introduction?
12:17:59 <mauke> an Irresponsible Irritation
12:18:00 <byorgey> an (id) Introduction, where (id) is the identity adjective?
12:18:27 <byorgey> an Irresponsible Irritation to Haskell, I like it!
12:21:55 <byorgey> ok, I'm going with Whirlwind
12:22:07 <byorgey> dmwit++
12:24:59 <gbacon> is there a way to ask hoogle for functions with the same type as another function?
12:25:25 <Beelsebob> get the type of the function from Hoogle, then type it in?
12:26:03 <gbacon> well, yes, but is there a way to do it in one step?
12:26:52 <gbacon> say I've find that flip mapM_ is pretty nice to use, but I want to know if it already has a well-known name
12:27:48 <mauke> @. hoogle type flip mapM_
12:27:52 <lambdabot> Hoogle Error: Parse Error: Unexpected character '* -> *) b.'
12:27:55 <mauke> :(
12:28:00 <vixey> forM_ = flip mapM_ ?
12:28:14 <vixey> :t forM_
12:28:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
12:28:21 <vixey> :t flip mapM_
12:28:21 <gbacon> vixey: yes, I know; I was using it as an example
12:28:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
12:28:37 <vixey> oh right I'm an idiot then
12:28:47 <dmwit> gbacon: No, there is no one-step solution.
12:28:47 <vixey> @hoogle  [a] -> (a -> m b) -> m ()
12:28:48 <lambdabot> No matches, try a more general search
12:28:48 <gbacon> no, not my meaning
12:28:53 <vixey> @hoogle (a -> m b) -> m ()
12:28:54 <dmwit> But the two steps are not so big. =)
12:28:55 <lambdabot> Control.Monad.State.Class.modify :: MonadState s m => (s -> s) -> m ()
12:28:55 <lambdabot> Data.Function.fix :: (a -> a) -> a
12:28:55 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
12:29:01 <vixey> hmm=
12:29:07 <vixey> When is Hoogle 2?
12:29:10 <vixey> coming out
12:29:16 <dmwit> We're already at Hoogle 3. =)
12:29:19 <byorgey> you mean Hoogle 4?
12:29:20 <xerox> ...at the end of the summer.
12:29:21 <vixey> bah
12:29:26 <vixey> yeah we need more hoogle :D
12:29:27 <dmwit> Supposedly Hoogle 4 is a SoC project.
12:29:33 <vixey> hmm
12:30:10 <gbacon> for instance, this morning I was looking for a well-known name for flip when
12:30:21 <dmwit> :t flip when
12:30:23 <lambdabot> forall (m :: * -> *). (Monad m) => m () -> Bool -> m ()
12:30:25 <byorgey> it would be nice if this worked:
12:30:32 <byorgey> @. hoogle type flip mapM_
12:30:33 <vixey> @src when
12:30:33 <dmwit> ?hoogle (Monad m) => Bool -> m () -> m ()
12:30:34 <lambdabot> Hoogle Error: Parse Error: Unexpected character '* -> *) b.'
12:30:34 <lambdabot> when p s = if p then s else return ()
12:30:34 <lambdabot> No matches, try a more general search
12:30:43 <gbacon> @hoogle a b -> c -> a b
12:30:44 <lambdabot> Prelude.const :: a -> b -> a
12:30:44 <lambdabot> Prelude.asTypeOf :: a -> a -> a
12:30:44 <lambdabot> Prelude.seq :: a -> b -> b
12:30:44 <xerox> byorgey: @tell nmd!
12:30:50 <xerox> Err, ndm.
12:30:51 <vixey> :t unless
12:30:53 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
12:31:01 <byorgey> but it doesn't, since the output of @type includes the forall . and kind stuff
12:31:02 <vixey> @src unless
12:31:02 <lambdabot> unless p s = if p then return () else s
12:31:14 <mauke> provided = flip when
12:31:20 <vixey> :t provided
12:31:22 <lambdabot> Not in scope: `provided'
12:31:32 <vixey> I thought unless was a better name..
12:31:34 <gbacon> > let provided = flip when
12:31:35 <lambdabot>  Parse error at end of input
12:31:37 <mauke> print 42 `provided` i > 1
12:31:41 <vixey> @src unless
12:31:41 <lambdabot> unless p s = if p then return () else s
12:31:46 <vixey> :t unless
12:31:48 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
12:31:52 <byorgey> @tell ndm it would be nice if Hoogle 4 stripped explicit foralls off the front of types, so that, e.g. something like @. hoogle type flip mapM_ worked with lambdabot
12:31:52 <lambdabot> Consider it noted.
12:33:22 <gbacon> @tell ndm it would also be nice if Hoogle 4 were able to search for functions with the same type as some expression so, for example, hoogle same-type flip mapM_ would yield forM_
12:33:23 <lambdabot> Consider it noted.
12:33:53 <byorgey> gbacon: woah, you want hoogle to include type inference?
12:34:09 <vixey> why not just go
12:34:10 <byorgey> that sounds a little ambitious to me =)
12:34:12 <vixey> :t flip mapM_
12:34:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
12:34:20 <vixey> @hoogle forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
12:34:21 <lambdabot> Hoogle Error: Parse Error: Unexpected character '* -> *) b.'
12:34:40 <lispy> I don't think hoogle does kinds
12:34:48 <gbacon> why bother programming in Haskell when we can already do it in assembly language? :-)
12:35:00 <dmwit> Lots of reasons!
12:35:17 <xerox> No reaSegmentation Fault.
12:35:24 <dmwit> For one thing, the source takes up less space on the hard drive. ;-)
12:35:37 <sbahra> Fashion statement
12:35:46 <gbacon> @google rhetorical question
12:35:48 <lambdabot> http://en.wikipedia.org/wiki/Rhetorical_question
12:37:47 <astrolabe> Can anyone give me any tips on how to track down an "Error in array index"?
12:38:30 <mauke> the ghci debugger?
12:38:36 <xerox> How about dons' error position script.
12:38:46 * Corun read that as "the girl debugger"
12:38:51 <astrolabe> mauke: I just started trying that.  It seems quite difficult to use.
12:39:00 <olsner> heh, funny example of rhetorical questions: "Do you really think I want to have a Star Trek themed wedding?"
12:39:04 <xerox> http://www.cse.unsw.edu.au/~dons/loch.html
12:39:05 <lambdabot> Title: LocH
12:39:09 <astrolabe> xerox: thanks
12:39:38 <xerox> astrolabe: tell us if it helps afterwards :D
12:40:22 <gbacon> olsner: that's a good way to get out of wedding-planning duties!
12:42:06 <therp> omg http://www.vegas.com/weddings/themedweddings/startrek.html
12:42:07 <lambdabot> Title: VEGAS.com Wedding Guide: Star Trek Weddings
12:42:12 <kiris> any tip-top-tips on making this code less ugly? http://hpaste.org/7314
12:42:13 <olsner> what you're really looking for, though, is the girl that *would* want the star trek themed wedding (but probably someone normal enough to realize your *guests* probably don't want it star trek themed)
12:44:10 <olsner> therp: awesome! :P
12:45:06 <therp> even more shocking http://images.google.com/images?q=star%20trek%20wedding (sorry for the off-topic spam, but just too silly)
12:45:07 <lambdabot> Title: star trek wedding - Google Image Search
12:51:17 <dancor> i can't believe even the lambda calculus conflates False and 0
12:51:25 <Beelsebob> haha
12:51:33 <Beelsebob> it does not
12:51:41 <Beelsebob> they use different variable names :P
12:51:48 <dancor> and they cruisecontrolforcool it FALSE
12:51:49 <sfogarty> the lambda calculus usually has neither
12:52:04 <Beelsebob> sfogarty: no, but it does have standard representations for them
12:52:17 <Beelsebob> like \t -> \f -> f for false
12:52:39 <sfogarty> heh
12:52:45 <sfogarty> that is cute
12:52:57 <Beelsebob> \t -> \f -> t for true
12:53:04 <sfogarty> and \a -> \b -> \b for 0 :)
12:53:06 <mauke> \succ -> \zero -> zero
12:53:11 <Beelsebob> and \c -> \t -> \e -> c t e for if
12:53:36 <mauke> if := id
12:53:37 <mauke> OPTIMIZED
12:53:38 <EvilTerran> if = I
12:53:41 <EvilTerran> rah!
12:53:43 <Heffalump> you have rather bigger type safety problems than the FALSE/0 distinction if you are using pure lambda calculus...
12:53:54 <Beelsebob> mauke: bastard !
12:54:09 <EvilTerran> :O
12:54:15 <sfogarty> Beelsebob: I bow, that had never occured to me
12:54:31 <olsner> meh, don't you mean if := skk? :P
12:54:36 <Beelsebob> sfogarty: nothing I thought of either -- it just appears in many many papers
12:54:46 <mauke> lambda calculus is not combinators
12:54:53 <sfogarty> well, I knew the representation of 0 and 1
12:55:03 <sfogarty> I just had never connected the two as being the same
12:55:32 <mauke> 1 is not true, right?
12:55:33 <mauke> 1 is if
12:55:47 <sfogarty> \a . \b . a b
12:55:52 <sfogarty> no, 1 is apply, I think
12:55:57 <EvilTerran> olsner, ITYM if = X (X (X (X X)))) (X (X (X X))) (X (X (X X)))
12:55:57 <EvilTerran> :D
12:56:05 <olsner> EvilTerran: yes of course
12:56:15 <mauke> sfogarty: same thing
12:56:16 <olsner> thought I'd keep it simple for the cretins ;-)
12:56:21 <mauke> I invoke Œ∑
12:56:34 * EvilTerran suspects there's a simpler version in the X calculus, but I CBA to work it out
12:56:42 <Beelsebob> mauke: no, not the mauke who say's "Œ∑"
12:56:52 <Beelsebob> I will bring you no shrubberies!
12:57:23 <Dafra> hi folks
12:57:32 <mercury^> int-e: would you mind having a look at my solution for http://projecteuler.net/index.php?section=problems&id=189, telling me what I misunderstood about the problem?
12:57:34 <lambdabot> Title: Problem 189 - Project Euler
12:57:40 <Dafra> is there a pipe operator like in f# ?
12:57:47 <minivan> > length "‡∫±‡∫≤"
12:57:50 <lambdabot>  2
12:57:51 <vixey> Dafra: What does it do?
12:57:56 <Dafra> x |> f = f x
12:57:57 <olsner> EvilTerran: X(XX)(XX)(XX)
12:58:11 <mauke> @hoogle >>>
12:58:11 <lambdabot> Control.Category.(>>>) :: Category cat => cat a b -> cat b c -> cat a c
12:58:18 <vixey> > let x |> f = f x in (+1) |> 7
12:58:21 <olsner> which may or may not be the simplest one, but simpler than the above one
12:58:21 <lambdabot>        add an instance declaration for (Num ((a -> a) -> a1))
12:58:23 <Dafra> very useful if you want to appl 3 or 4 functions to a list
12:58:33 <vixey> > let x |> f = f x in 7 |> (+1) |> (*2)
12:58:35 <lambdabot>  16
12:58:37 <mauke> Dafra: we usually use . for that
12:58:59 <sfogarty> I use idx
12:59:01 <sfogarty> I have no idea why
12:59:02 <Beelsebob> indeed, it would normally be written . and put the arguments the other way round
12:59:13 <mauke> > map show . reverse . sort $ [1,10,2,9,20,16]
12:59:14 <lambdabot>  ["20","16","10","9","2","1"]
13:00:11 <dancor> i just know there's a good way to make  foldrMAsc :: (a -> Int -> b -> m b) -> b -> [a] -> m b  maybe with some state monad jonx
13:00:13 <Beelsebob> hmm, with |>'s associativity defined right though it could be rather nicer for multi-argument functions though
13:00:25 <Beelsebob> so you could do 2 |> 3 |> *
13:00:34 <Beelsebob> and get postfix by accident
13:01:02 <dmwit> > (*) $ 2 $ 3
13:01:03 <lambdabot>   add an instance declaration for (Num (a -> b))
13:01:03 <vixey> > let x |> f = f x ; f <| x = f x in 2 |> (*) <| 3
13:01:04 <lambdabot>  6
13:01:16 <dmwit> Ah, blast that stupid fixity.
13:01:33 <dmwit> > ((*) $ 2) $ 3 -- force the right fixity
13:01:35 <lambdabot>  6
13:01:38 <Beelsebob> vixey: nice
13:01:45 <Heffalump> s/right/wrong/ ;-)
13:02:06 <vixey> > let x |> f = f x ; f <| x = f x in "foo" |> (++) <| "bar"
13:02:08 <lambdabot>  "foobar"
13:02:13 <vixey> heh
13:02:15 <Beelsebob> heh
13:02:22 <Beelsebob> that's actually really nice
13:02:26 <Beelsebob> can has?
13:02:29 <dmwit> Heffalump: Nah, it's the Prelude that's wrong. ;-)
13:02:37 <olsner> EvilTerran: also, [1,0,1,0,1,0] as expressed in http://esolangs.org/wiki/1337
13:02:40 <lambdabot> Title: 1337 - Esolang
13:02:41 <minivan> > let let ‡∏≤ = 2
13:02:42 <lambdabot>  Parse error at "let" (column 5)
13:02:51 <minivan> > let ‡∏≤ = 2
13:02:51 <lambdabot>  Illegal character ''\184''
13:02:51 <lambdabot>  at "∏≤" (column 6)
13:03:09 <dmwit> minivan: Needs an "in" clause, too.
13:03:54 <dolio> lambdabot doesn't do unicode characters in code, either.
13:06:11 <Dafra> I dont get the >>> thing : how to use it ?
13:06:20 <Beelsebob> Dafra: don't
13:06:26 <Dafra> :)
13:06:30 <dmwit> > let prime = nubBy (\x y -> y `mod` x == 0) [2..] in last prime
13:06:37 <lambdabot>  Exception: Time limit exceeded
13:06:44 <Beelsebob> > let x |> f = f x in 5 |> (+1)
13:06:45 <lambdabot>  6
13:06:46 <dmwit> Dafra: For the function Arrow, (>>>) = flip (.)
13:06:51 <Beelsebob> Dafra: that's what you want
13:06:56 <edwardk> Dafra whenever you would use (.) flip the arguments ;)
13:07:08 <dolio> > ((+1) &&& (+2) >>> uncurry (+)) 5
13:07:09 <lambdabot>  13
13:07:10 <vixey> 2^232,582,657-1
13:07:16 <edwardk> > show . reverse $ [1,2,3]
13:07:17 <lambdabot>  "[3,2,1]"
13:07:27 <edwardk> > reverse >>> show $ [1,2,3]
13:07:29 <lambdabot>  "[3,2,1]"
13:07:31 <tromp> @pl \x y -> y `mod` x == 0
13:07:32 <lambdabot> flip flip 0 . ((==) .) . flip mod
13:07:34 <mauke> > sort >>> reverse >>> map show $ [1,10,2,9,20,16]
13:07:34 <dmwit> > [1, 2, 3] >>> reverse >>> show
13:07:35 <lambdabot>  ["20","16","10","9","2","1"]
13:07:35 <lambdabot>  Couldn't match expected type `a b c' against inferred type `[a1]'
13:08:25 <Dafra> looks fine
13:08:39 <dmwit> > flip ($) [1,10,2,9,20,16] $ sort >>> reverse >>> map show
13:08:41 <lambdabot>  ["20","16","10","9","2","1"]
13:08:45 <dmwit> ew
13:08:57 <red75> > arr (const [1,2,3]) >>> reverse >> show
13:08:58 <lambdabot>      precedence parsing error
13:08:58 <lambdabot>         cannot mix `(>>>)' [infixr 1] and `(>>)...
13:09:08 <red75> > arr (const [1,2,3]) >>> reverse >>> show
13:09:10 <lambdabot>  Add a type signature
13:09:32 <olsner> > (arr (const [1,2,3]) >>> reverse >>> show) :: [String]
13:09:33 <lambdabot>  Couldn't match expected type `[String]'
13:09:45 <olsner> no cake for me :(
13:10:28 <minivan> mm... how does the specification decides case and what is legal or not in source?
13:10:38 <minivan> (as identifiers)
13:13:18 <minivan> nevermind, just found this: http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource
13:13:21 <lambdabot> Title: UnicodeInHaskellSource - Haskell Prime - Trac, http://tinyurl.com/yfvxzv
13:14:17 <byorgey> > (arr (const [1,2,3]) >>> reverse >>> show) ""
13:14:18 <lambdabot>  "[3,2,1]"
13:14:41 <byorgey> even though it's const, you still have to give it an argument =)
13:15:36 <Dafra> >>> works fine, thanks
13:15:52 <vixey> > show . reverse $ [1,2,3]
13:15:53 <lambdabot>  "[3,2,1]"
13:15:56 <vixey> Dafra: ^
13:16:21 <byorgey> > let x |> f = f x in  [1,2,3] |> reverse >>> map show
13:16:25 <lambdabot>  Couldn't match expected type `a b' against inferred type `[]'
13:16:26 <lispy> > read . show . reverse $ [1,2,3] :: [Int]
13:16:29 <lambdabot>  [3,2,1]
13:16:37 <Beelsebob> not quite sure why everyone's trying to force him into a style he doesn't want to use
13:16:54 * lispy was just playing along
13:16:58 <Beelsebob> hehe
13:16:59 <lispy> > fix show
13:17:01 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
13:17:02 <byorgey> > let x |> f = f x ; infixl 0 |>  in  [1,2,3] |> reverse >>> map show
13:17:02 <red75> > arr (const [1,2,3]) >>> reverse >>> (show &&& map show) $ ()
13:17:03 <lambdabot>  ["3","2","1"]
13:17:04 <lambdabot>  ("[3,2,1]",["3","2","1"])
13:17:21 <Beelsebob> > fix (show . reverse)
13:17:22 <byorgey> hey, that's kind of nice
13:17:36 <lambdabot>  thread killed
13:17:46 <lispy> oh you strict reverse
13:17:46 <Beelsebob> byorgey: I'd rather have it infixr tbh
13:17:53 <byorgey> I've often found myself writing something like  argument >>> function >>> function >>> function  only to slap my forehead and say "duh, you can't put an argument there"
13:17:54 <Beelsebob> so I can do multi-argument doom with it
13:18:06 <byorgey> Beelsebob: fair enough, I didn't think about the associativity too hard
13:18:15 <Beelsebob> byorgey: well, it's a trade off
13:18:17 <vixey> > (
13:18:17 <lambdabot> Unbalanced parentheses
13:18:21 <Beelsebob> that one's useful for your thing
13:18:27 <vixey> > ((+1) >>> (*2)) 7
13:18:28 <dmwit> > ( -- )
13:18:28 <lambdabot> Unbalanced parentheses
13:18:28 <lambdabot>  16
13:18:34 <Beelsebob> but I'd quite like a "make postfix operator" like this byorgey:
13:18:44 <xerox> astrolabe: did it help?
13:18:49 <byorgey> > let x |> f = f x ; infixr 0 |>  in  [1,2,3] |> reverse >>> map show
13:18:50 <lambdabot>  ["3","2","1"]
13:18:53 <Beelsebob> > let x |> f = f x ; infixr 0 |>  in 5 |> 4 |> (*)
13:18:54 <lambdabot>  20
13:19:15 <byorgey> sure, that's nice
13:19:23 <byorgey> I think infixr works fine for my use too
13:20:50 <Beelsebob> > let x |> f = f x ; infixr 0 |>  in 5 |> 4 |> (-)
13:20:51 <lambdabot>  -1
13:21:01 <Beelsebob> cool, works the right way round too
13:21:19 <byorgey> o.O  that's the right way around?
13:21:22 <Beelsebob> well, for one way of thinking I guess
13:21:27 <Beelsebob> I can think of reasons to want it both ways
13:21:28 <Beelsebob> >.<
13:21:29 <byorgey> hehe
13:21:43 <mauke> @vixen you like it both ways, eh?
13:21:43 <lambdabot> i'm both at once
13:21:49 <byorgey> that's the opposite of what I would usually think of as a 'postfix operator'
13:21:56 <Beelsebob> this is true byorgey
13:22:00 <byorgey> but it does make some amount of sense
13:22:02 <mercury^> can anyone help me with http://projecteuler.net/index.php?section=problems&id=189 ?
13:22:03 <lambdabot> Title: Problem 189 - Project Euler
13:22:15 <Beelsebob> haha, everyone has trouble with that one
13:22:20 <mercury^> I have a program that gives a solution, but the website says it is the wrong one.
13:22:29 <mercury^> And I'm rather sure it is not.
13:22:31 <mercury^> :/
13:23:06 <byorgey> hehe, I still haven't actually gotten around to solving that one, although I did learn a ton about chromatic polynomials =D
13:23:29 <byorgey> I think I have an idea of how to do it, I just have to sit down and actually write the code at some point
13:23:32 <edwardk> heh solve the first few levels by brute force then ask sloane's ;)
13:23:46 <byorgey> edwardk: I tried that =)
13:23:51 <mauke> proof by @oeis
13:24:04 <edwardk> it works disturbingly well
13:24:09 <dmwit> That would defeat the entire purpose of the Euler project for me.
13:24:24 <dmwit> I mean, who cares if you can find the answers to all of them... that's easy.
13:24:29 <dmwit> Just go to the Haskell wiki.
13:24:48 <dmwit> Learning enough to solve it yourself... now that's worthwhile.
13:24:58 <byorgey> yeah, I like solving them for real and then later looking up the sequences in the OEIS to see if there's more I can learn (there usually is =)
13:26:05 <edwardk> what i like about sloane's is its like a type system for sequences coz you can see a bunch of different things that collapse down to the same sequence
13:26:15 <mercury^> anyone wants to look at my solution and tell me where the logical mistake is?
13:27:18 <dcoutts> @seen nometa
13:27:19 <lambdabot> I haven't seen nometa.
13:27:24 <mercury^> well, here you go: http://haskell.pastebin.com/m1c48b10e
13:32:58 <lilac> using Parsec, if I'm doing my own tokenizing, how can I create a SourcePos?
13:36:14 <xerox> newSourcePos I think
13:37:05 <bos> @users
13:37:05 <lambdabot> Maximum users seen in #haskell: 459, currently: 432 (94.1%), active: 22 (5.1%)
13:37:08 <xerox> no, there are set and inc functions
13:40:35 <lilac> xerox: hmm, that's unhelpful
13:41:47 <vixey> lilac
13:41:49 <vixey>  - lexToken c
13:41:49 <vixey>  -   = tokenPrim showToken nextPos testToken
13:41:49 <vixey>  -   where
13:41:49 <vixey>  -     showToken x        = "'" ++ (show x) ++ "'"
13:41:49 <vixey>  -     nextPos pos x xs  = incSourceColumn pos 1
13:41:50 <vixey>  -     testToken x       = if ((==) `on` toConstr) x c then Just x else Nothing
13:45:16 <lilac> xerox, vixey: ty
13:45:22 <xerox> lilac: what about errorPos
13:45:23 <orzo> hello
13:45:54 <orzo> I'd like to drop an RPL into a haskell program
13:46:02 <orzo> to let the user runcommands
13:46:25 <orzo> is there a nice module for that ?
13:46:34 <xerox> what's an RPL?
13:46:40 <orzo> run print loop
13:46:47 <mauke> (loop (print (read)))
13:46:48 <orzo> like lisp
13:46:53 <mauke> someone forgot the eval
13:46:55 <orzo> just an interactive interpreter
13:47:01 <xerox> ah, there's a slick lib.
13:47:14 <lilac> xerox: I don't have a ParseError ;-)
13:47:44 <xerox> now what was it called...
13:48:34 <orzo> oh
13:48:37 <orzo> ya i mean REPLE
13:48:38 <orzo> er
13:48:40 <orzo> REPL
13:48:45 <orzo> read eval print loop
13:49:40 <xerox> shellac
13:49:51 <byorgey> orzo: there's System.Console.SimpleLineEditor.
13:50:02 <xerox> http://www.cs.princeton.edu/~rdockins/shellac/Shellac.cabal
14:33:12 <Noxwizard> What's a good place to read up on maps and folds?
14:33:37 <pizza_> geography conference?
14:34:18 <dibblego> Noxwizard, I teach those concepts to people unfamiliar with them and undoubtedly the best practice is writing certain functions in various ways
14:34:26 <dibblego> Noxwizard, for example, write map using foldr
14:34:46 <dibblego> Noxwizard, many students understand map quite quickly (of all functions, this one is probably a good starting point)
14:35:48 <wagle> http://cale.yi.org/index.php/Fold_Diagrams is nice
14:35:53 <Cale> :)
14:36:01 <lambdabot> Title: Fold Diagrams - CaleWiki
14:36:14 <mauke> http://foldr.com/
14:36:15 <lambdabot> Title: foldr.com
14:37:23 <Noxwizard> I'm trying a simple one, like taking a list of items and making them into floats by multiplying by 1.0.
14:37:34 <dibblego> Noxwizard, good idea
14:37:38 <dibblego> ?type map
14:37:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:37:44 <dibblego> gah!
14:37:55 <dibblego> (a -> b) -> [a] -> [b]
14:37:57 <tromp> multiplying by 1.0 is ugly:(
14:37:58 <dibblego> it says that :)
14:38:24 <tromp> @hoogle Int -> Float
14:38:25 <lambdabot> No matches, try a more general search
14:38:28 <Cale> Noxwizard: That won't turn them into Floats. You can only multiply them by numbers of the same type they already are.
14:38:38 <Cale> :t (*)
14:38:39 <lambdabot> forall a. (Num a) => a -> a -> a
14:38:42 <tromp> :t fromIntegral
14:38:44 <lambdabot> forall a b. (Num b, Integral a) => a -> b
14:38:49 <Cale> So multiplication will never affect the type of a number.
14:39:36 <tromp> > fromIntegral 3 :: Float
14:39:38 <lambdabot>  3.0
14:41:30 <red75> > map ((*1.0) . fromIntegral) [1,2,3]
14:41:34 <lambdabot>  [1.0,2.0,3.0]
14:42:03 <Baughn> That'd work without the fromIntegral, seeing as the type of a literal number's just Num a => a
14:42:13 <Baughn> @type [1,2,3]
14:42:14 <lambdabot> forall t. (Num t) => [t]
14:42:19 <mauke> > [1,2,3] :: [Double]
14:42:20 <lambdabot>  [1.0,2.0,3.0]
14:42:33 <mauke> > [1,2,3] :: [Complex Double]
14:42:34 <lambdabot>  [1.0 :+ 0.0,2.0 :+ 0.0,3.0 :+ 0.0]
14:42:57 <Baughn> > map fromIntegral ([1,2,3] :: [Int]) :: [Double]
14:42:58 <lambdabot>  [1.0,2.0,3.0]
14:43:22 <Noxwizard> How would I do that as a fold?
14:43:40 <Baughn> Uncomfortably. Use the map.
14:44:09 <mauke> what, writing map in terms of foldr isn't hard
14:44:49 <dibblego> it's produces a good discussion about specialisaiton of functions
14:44:51 <Baughn> No, just pointless. And probably asymptotically slower if you get it wrong
14:45:07 <dibblego> I disagree; it is extremely pointful for learning
14:45:28 <oogali> vulpyne...
14:45:38 <red75> >foldr ((:) . (*1.0)) [] [1,2,3]
14:46:19 <Baughn> red75: (*1.0) == id. It doesn't do anything, ever, except perhaps reduce precision.
14:46:45 <Baughn> red75: Given that the type is a -> a -> a, it certainly can't change any types
14:46:49 <red75> Thanks, I know (now).
14:47:19 <red75> It's just to affect show.
14:47:48 <Baughn> > foldr (:) [] [1,2,3] :: [Double] -- An explicit type signature works just as well. ;)
14:47:49 <lambdabot>  [1.0,2.0,3.0]
14:48:54 <Baughn> Now do that with foldl. :P
14:49:04 <red75> It's not id, however. It subclasses Num a to hm
14:49:22 <red75> Integral?
14:49:31 <Baughn> @type (*)
14:49:32 <lambdabot> forall a. (Num a) => a -> a -> a
14:49:41 <Baughn> @src Num
14:49:41 <lambdabot> class  (Eq a, Show a) => Num a  where
14:49:41 <lambdabot>     (+), (-), (*)           :: a -> a -> a
14:49:41 <lambdabot>     negate, abs, signum     :: a -> a
14:49:41 <lambdabot>     fromInteger             :: Integer -> a
14:49:46 <ddarius> :t 1.0
14:49:47 <tromp> > foldr ((:).f) [] [a,b,c]
14:49:48 <lambdabot> forall t. (Fractional t) => t
14:49:48 <lambdabot>  Add a type signature
14:50:19 <tromp> > foldr ((:).(+1)) [] [0,1,2]
14:50:21 <lambdabot>  [1,2,3]
14:50:39 <ddarius> > foldr ((:).f) [] [a,b,c] :: Expr
14:50:39 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
14:50:40 <red75> :t (*1.0)
14:50:41 <lambdabot> forall a. (Fractional a) => a -> a
14:50:45 <ddarius> > foldr ((:).f) [] [a,b,c] :: [Expr]
14:50:46 <lambdabot>  [f a,f b,f c]
14:51:26 <ddarius> > not a
14:51:26 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Expr'
14:51:41 <ddarius> So when is lambdabot going to get a Boolean class?
14:51:57 <ddarius> (or should we start at a Heyting algebra?)
14:54:15 <Noxwizard> If I wanted to use this in a function, what would its type be?  foldr (:) [] xs :: [Float]
14:54:41 <Baughn> Noxwizard: The function? Or that expression?
14:54:44 <dibblego> Noxwizard, foldr (:) [] is identity; it produces the same list
14:55:00 <Baughn> Noxwizard: I'd have to say it depends on the rest of the function. Or, alternately, [Float].
14:55:32 <Noxwizard> The function is supposed to take a list of elements and convert them to a list of reals.
14:56:04 <Baughn> So, Num a, Fractional b => [a] -> [b]
14:56:04 <red75> The type will be (Num a) => [a] -> [Float]
14:56:27 <ddarius> As a function of xs, the type will be [Float] -> [Float]
14:56:34 <mauke> foo :: [a] -> [Float]; foo _ = []
14:56:43 <ddarius> And, as dibblego said, it is the identity function.
14:57:13 <dibblego> > foldr (:) [] [1..10]
14:57:14 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
14:57:14 <ddarius> foo _ = [3.14]
14:57:32 <acidjnk> hello
14:57:37 <dibblego> hello acidjnk
14:57:37 <ddarius> foo xs = [genericLength xs]
14:57:42 <red75> > foldr () [] [1,2,3] :: [Float] -- it was so
14:57:42 <lambdabot>  Couldn't match expected type `a -> b -> b'
14:57:57 <red75> > foldr (:) [] [1,2,3] :: [Float]
14:57:58 <lambdabot>  [1.0,2.0,3.0]
14:58:02 <byorgey> Noxwizard: if you want to convert a list of somethings to a list of reals, you'll need to map an appropriate conversion function over the list.
14:58:31 <Bonus> > map fromIntegral [1,2,3] :: [Float]
14:58:31 <byorgey> Noxwizard: for example, to convert a list of Ints to a list of any sort of other numbers, you can use  map fromIntegral
14:58:32 <lambdabot>  [1.0,2.0,3.0]
14:59:10 <acidjnk> ddarius & rest, is FP generally suitable for Numerical Analysis? How would it be used there, would still the common algorithms like runge kutter and Euler be used?
14:59:25 <ddarius> acidjnk: Why not?
15:00:00 <roconnor> acidjnk: you should read "Why Functional Programming Matters"
15:00:11 <dibblego> roconnor, excellent suggestion
15:00:13 <dibblego> ?where whyfp
15:00:14 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
15:00:14 <dons> you can still write algorithms in a functional style :)
15:00:16 <acidjnk> My impression is that those algorithms require very long loops, and that a recursive version of them would not work in such an extreme case.
15:00:39 <dons> recursion is compiled into loops
15:01:02 <roconnor> acidjnk: in it wadler develops higher-order numerical methods
15:01:09 <ddarius> In fact, FP is even nicer since many such algorithms are naturally parameterized by functions.
15:01:10 <acidjnk> Ah thanks, that answers a general question already, dons.
15:01:15 <roconnor> @pl func f l = l ++ map f l
15:01:16 <lambdabot> func = ap (++) . map
15:01:28 <byorgey> Hughes, not Wadler =)
15:01:50 <roconnor> @type ap
15:01:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:01:54 <roconnor> byorgey: oh, oops
15:02:01 <roconnor> Sorry Hughes
15:02:04 <roconnor> Hughes++
15:02:31 <acidjnk> Are there compilers for Haskell or other functional programming languages that can compete with c and fortran in this particular area?
15:02:41 <byorgey> I mean, not that Wadler isn't awesome too.
15:02:49 <dons> go :: Int  -> Int
15:02:49 <dons> go n | n > 10 = 7
15:02:49 <dons>      | otherwise = go (n+1)
15:02:49 <dons> Main_zdwgo_info:
15:02:49 <dons>   cmpq $10,%rsi
15:02:51 <dons>   jg .Lcx8
15:02:53 <byorgey> acidjnk: yes.
15:02:54 <dons>   incq %rsi
15:02:56 <dons>   jmp Main_zdwgo_info
15:02:59 <dons> just to compare how recursion is compiled
15:02:59 <ddarius> acidjnk: It depends on what you are competing for.
15:03:20 <dons> so feel free to go nuts
15:03:36 <acidjnk> I am thinking about szenarios where performance matters a lot. For example when a solution in c would take several days or weeks to solve a single problem.
15:03:38 <ddarius> acidjnk: As far as speed is concerned for high-performance numerical computation on things like vector machines, you may want to look at Single-Assignment C.
15:03:54 <ddarius> @google "Single Assignment C"
15:03:56 <lambdabot> http://www.sac-home.org/
15:03:56 <lambdabot> Title: SAC-Home [Home]
15:04:04 <dons> one approach used in haskell and ocaml is to generate specialised C programs from the functional language
15:04:10 <dons> that would outperform the hand written C
15:04:26 <dons> by doing optimisations on the more domain specific representation in haskell
15:05:18 <roconnor> @pl func l = l ++  l
15:05:19 <lambdabot> func = join (++)
15:05:34 <roconnor> @type join
15:05:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:05:57 <acidjnk> Thanks a lot @all! That answered all my initial questions and provided me with all the additional material I might need.
15:06:21 <dons> you might also think about parallisation of the code
15:06:40 <acidjnk> I often did that with c already.
15:06:48 <acidjnk> Well, very long time ago.
15:07:01 <dons> yeah, so parallelising C might be a lot harder than parallelising a much higher level language.
15:07:19 <vixey> I'll bet it is :)
15:07:21 <pizza_> not might be.
15:07:25 <dons> for example, there's a haskell array library that transparently parallelises the array transformations, taking advantage of type information
15:07:37 <acidjnk> It's always difficult, because in a typical situations all threads need to exchange information all the time.
15:07:41 <dons> and taking advantage of purity
15:07:50 <acidjnk> But possible.
15:08:15 <dons> acidjnk: right, the nested data parallelism array programming tends to minimise communication, so you can be far more aggressive in dividing up the jobs
15:10:17 <abrasive> automated parallelising of C is more or less impossible.
15:10:24 <abrasive> it's such a fundamentally procedural language.
15:10:37 <abrasive> as soon as somebody uses pointers, it becomes a halting-problem type of thing.
15:11:08 <dons> yeah, you have to do so much analysis to find the haskell subset (referentially transparent, well typed, no aliasing, etc), that actually getting the optimisations done becomes infeasible
15:11:10 <erg0t> abrasive: OpenMP tries to solve that
15:11:13 <dons> same goes for a lot of other optimisations
15:11:26 <abrasive> erg0t: try as you might, it doesn't make it possible :/
15:11:32 <dons> too much analysis has to be done to make it feasible, or, too little code matches the constraints
15:11:38 <abrasive> exactly.
15:11:45 <abrasive> procedural code is nasty.
15:11:57 * dons hugs pure, strongly typed code some more
15:12:00 * abrasive is writing a procedural code deobfuscator in haskell
15:12:25 <ddarius> > let rungeKutta4 f dt xs = zipWith4 (\k1 k2 k3 k4 -> (dt/6.0)*(k1+2*k2+2*k3+k4)) k1 k2 k3 k4 where k1 = f xs; k2 = f (addScale xs (dt/2) k1); k3 = f (addScale xs (dt/2) k2); k4 = f (addScale xs dt k3); addScale xs dt = zipWith (\x k -> x+dt*k) xs in iterate (rungeKutta (\[x,x'] -> [x',-x]) 0.1) [0,1]
15:12:26 <lambdabot>   Not in scope: `rungeKutta'
15:12:32 <ddarius> > let rungeKutta4 f dt xs = zipWith4 (\k1 k2 k3 k4 -> (dt/6.0)*(k1+2*k2+2*k3+k4)) k1 k2 k3 k4 where k1 = f xs; k2 = f (addScale xs (dt/2) k1); k3 = f (addScale xs (dt/2) k2); k4 = f (addScale xs dt k3); addScale xs dt = zipWith (\x k -> x+dt*k) xs in iterate (rungeKutta4 (\[x,x'] -> [x',-x]) 0.1) [0,1]
15:12:33 <lambdabot>  [[0.0,1.0],[9.983333333333333e-2,-4.995833333333334e-3],[-9.97501388888889e-...
15:12:58 <abrasive> functional languages offer great scope for optimisation. i've been meaning to do some work on a hardware computational fabric designed for same
15:13:12 <abrasive> i think you could make much more efficient use of silicon than, say, an x86 processor.
15:13:20 <ddarius> > let rungeKutta4 f dt xs = zipWith5 (\x k1 k2 k3 k4 -> x+(dt/6.0)*(k1+2*k2+2*k3+k4)) xs k1 k2 k3 k4 where k1 = f xs; k2 = f (addScale xs (dt/2) k1); k3 = f (addScale xs (dt/2) k2); k4 = f (addScale xs dt k3); addScale xs dt = zipWith (\x k -> x+dt*k) xs in iterate (rungeKutta4 (\[x,x'] -> [x',-x]) 0.1) [0,1]
15:13:21 <lambdabot>  [[0.0,1.0],[9.983333333333333e-2,0.9950041666666667],[0.19866916527777778,0....
15:13:25 <abrasive> and even main-memory bandwidth.
15:13:53 <roconnor> I've never seen the fruits of the so called ability for functional programs to be optimised.
15:14:02 <roconnor> only disappointment
15:14:04 <roconnor> :(
15:14:30 <abrasive> well, i am first and foremost a hardware hacker, so i'll just have to see how i go :)
15:14:37 <dons> roconnor: check out code.haskell.org/~dons/code/uvector and look at the core produced for the programs in tests/Fusion/
15:14:50 <dons> insane aggressive fusion
15:15:11 <red75> http://ulf.wiger.net/fp_seminar/Effects_Ericsson_Feb08.pdf
15:15:16 <dons> all thanks to having pure, strongly typed code, with lots of nice algebraic properties, to reorder at will
15:15:35 <roconnor> dons: okay, but you check out http://r6.ca/blog/20061012T181600Z.html
15:15:43 <lambdabot> Title: Functional Optimisation
15:15:46 <dons> is this you rbit shifting thing again?
15:15:53 <dons> it is :)
15:16:12 <dons> ghc's actually doing compile time bit shifting in some of those programs
15:16:15 <dons> let me find you an example
15:16:30 <dons> 2006/10 was a long time ago in ghc terms
15:16:41 <dons> the optimiser improved dramatically during 07
15:17:26 <roconnor> oh?
15:17:27 <dons> e.g. this program:
15:17:29 <dons> main = print . sumU . mapU (`shiftL` 7) . replicateU 10000000 $ (7 :: Int)
15:17:34 <dons> turns into this loop:
15:17:56 <dons> Main.$wfold =
15:17:56 <dons>   \ (ww_sO3 :: Int#) (ww1_sO7 :: Int#) ->
15:17:56 <dons>     case ww1_sO7 of wild_XM {
15:17:56 <dons>       __DEFAULT -> Main.$wfold (+# ww_sO3 896) (+# wild_XM 1);
15:17:56 <dons>       10000000 -> ww_sO3
15:18:14 <dons> not a shift in sight... nor any lists or arrays, for that matter
15:18:21 <roconnor> weee, no comparison of 7 to 32
15:18:25 <roconnor> what about rotateL?
15:18:32 <dons> i'm hoping to write a blog post soon about how inanely good the constant folding is getting
15:18:41 <dons> rotateL eh? let's see
15:18:58 <roconnor> which I think is the same as rotate
15:19:00 <roconnor> @src rotate
15:19:01 <lambdabot> Source not found. Maybe you made a typo?
15:19:16 <tromp> @src sumU
15:19:17 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:19:20 <bos> maybe you mean insanely?
15:19:24 <bos> :-)
15:19:29 <dons> heh
15:19:30 <dons> oops
15:19:30 <roconnor> hmm
15:19:35 <roconnor> what are all these U's?
15:19:53 <dons> the rotate is still there, not inlined. i'll need to dig around in Data.Bits to see why
15:20:00 <dons>         case Data.Bits.$wrotate 7 7 of ww2_aKS { __DEFAULT ->
15:20:01 <roconnor> bah
15:20:10 <roconnor> haskell--
15:20:13 <roconnor> er
15:20:15 <roconnor> haskell--
15:20:17 <roconnor> ghc--
15:20:18 <dons> whining++
15:20:22 <roconnor> haskell++
15:20:26 <roconnor> haskell++
15:20:28 <ddarius> If you compile via C, I imagine the rotate will be optimized out anyway.
15:20:29 <roconnor> there
15:20:31 <roconnor> :)
15:20:43 <roconnor> ddarius: rotate compares 7 to 32
15:20:45 <dons> oh, i had another good one:
15:20:51 <roconnor> on every single iteration!
15:21:01 <roconnor> 7 is always less than 32
15:21:05 <dons> print . sumU . takeWhileU (>= 7). replicateU 10000001 $ (7 :: Int)
15:21:11 <dons> so that takeWhile should go
15:21:14 <roconnor> it doesn't need to check every time!
15:21:15 <ddarius> roconnor: Which, when compiling via C, will almost certainly be removed by the C compiler.
15:21:22 <roconnor> oh
15:21:25 <roconnor> maybe you are right
15:21:31 <dons> Main.$wfold =
15:21:31 <dons>   \ (ww_sNw :: Int#) (ww1_sNA :: Int#) ->
15:21:31 <dons>     case ww1_sNA of wild_XM {
15:21:31 <dons>       __DEFAULT -> Main.$wfold (+# ww_sNw 7) (+# wild_XM 1);
15:21:31 <dons>       10000001 -> ww_sNw
15:21:42 <dons> no >= checking. gone, poof! fusion!
15:22:02 <dons> ghc rocking the free world
15:22:03 <ddarius> I don't know what kind of optimizations the NCG does currently, but it will certainly get better in the future.
15:22:18 <dons> yeah, the final thing to do now is the very low level register stuff.
15:22:38 <dons> nr's team is working on a cutting edge native code generate for the second half of the year
15:22:41 <dons> which is super exciting.
15:22:49 <dons> since the opimiser is already kicking butt
15:22:50 <ddarius> It is.
15:23:33 <ddarius> There's also ndm's stuff showing some improvements at the high level
15:23:40 <dibblego> http://hpaste.org/7316 is there a Monad here?
15:23:41 <dons> oh, looks like we're just missing an inline on rotate.
15:23:49 <dons> that looks easy enough to fix..
15:23:55 <dibblego> (lambdabot broke?)
15:24:03 <ddarius> dibblego: It's a reader monad.
15:24:19 <dibblego> ddarius, how does >>= look? (and is return correct? I can'
15:24:27 <dibblego> t think of any other implementation)
15:24:56 <mauke> looks like Reader (Int, String)
15:24:58 <bos> it's a shame to see dons lose his native tongue so quickly.
15:25:09 <ddarius> @djinn (x -> y -> a) -> (a -> x -> y -> b) -> x -> y -> b
15:25:09 <lambdabot> f a b c d = b (a c d) c d
15:25:09 <bos> "kicking butt" instead of "kicking arse".
15:25:13 <dons> hehe.
15:25:16 <kpreid> A question of terminology: A zipper is a data type, right? What do you call a value of a zipper type?
15:25:24 <dons> i've a whiteboard next to my desk with all the americanisms on it
15:25:37 <dons> so i remember how to say 'bananas' or 'caramel' or 'aluminum'
15:25:39 <red75> Well, not always, of course. Kleisly (const getContents) >>> words >>> filter (=="bla") >>> concat >>> Kleisly putStr Can such thing be optimized?
15:25:42 <ddarius> dons: -All- of them?
15:25:53 <dons> *ALL* of them
15:25:56 <ddarius> None of that aluminium nonsense.
15:26:09 <dons> "airplane", "dew"
15:26:26 <dons> "tuesday"
15:26:59 <bos> kpreid: a zipper is the name used for both the type and the value.
15:27:16 <mauke> how do you say airplane?
15:27:21 <dons> aeroplane
15:27:53 <dons> roconnor: cool, got rotateL optimised away
15:27:54 <kpreid> bos: okay, so I don't actually have to rename anything in my program to get it right :)
15:27:55 <bos> horseless air carriage.
15:28:05 <dons> roconnor: its just an inline difference
15:28:07 <kpreid> (I'm applying a zipper outside of haskell, btw)
15:28:07 <bos> actually, gooseless.
15:28:16 <dons> heh
15:28:19 <kpreid> (and I'm going to blog about it)
15:28:47 <dons> roconnor: watching?
15:28:52 <dons> main = print . sumU . mapU (`rotate'` 1) . replicateU 10000000 $ (7 :: Int)
15:28:53 <dons> goes to
15:28:55 * ddarius has all kinds of cool toys written in C# at work.
15:28:59 <dons> __DEFAULT -> Main.$wfold (+# ww_sQ2 14) (+# wild_XM 1);
15:29:07 <dons> roconnor: so compiled away
15:29:14 <dons> i'll push the patch for this now
15:29:54 <roconnor> dons: what did you change?
15:29:59 <bos> dons: what's that your working on?
15:30:01 <dons> roconnor: {-# INLINE rotateL #-}
15:30:06 <roconnor> oh
15:30:28 <roconnor> So we need to rework your UM implemenation benchmarks
15:30:33 <roconnor> is that page still up?
15:30:36 <dons> bos, oh, just the stream-fusion stuff for arrays. i get my free coding day at work today :)
15:30:43 <bos> heh.
15:32:26 <dons> roconnor: so that's both the examples in your 06 post solved?
15:33:53 <roconnor> Finally fast sha2
15:33:57 <roconnor> and a fast UM
15:34:10 <roconnor> http://www.cse.unsw.edu.au/~dons/um.html
15:34:12 <lambdabot> Title: Haskell UM
15:35:12 <roconnor> dons: what version of GHC?
15:35:25 <dons> so shiftL should work with 6.8.2
15:35:33 <dons> and the rotate stuff under 6.9 once i push some inlines
15:35:40 <tromp> the "full spec" link http://www.icfpcontest.org/task.shtml#materials is broken
15:35:49 <roconnor> you should rerun the sandmarks :P
15:36:03 <joey> :r
15:36:07 <joey> Whoops.
15:36:10 <roconnor> It'd be intresting to see how much some of the ratios decrease
15:37:16 <MarcWeber> dcoutts: If this httpRequest not closing connection trouble is serious maybe you can also try using the curl bindings lib to see wether this behaves better in this matter?
15:37:46 <dcoutts> MarcWeber: a pure haskell http is what we need for cabal-install since it also has to work on windows
15:37:58 <dcoutts> I'm confident we can work out why it's leaking handles
15:38:46 <MarcWeber> dcoutts: Right. I agree. It would have been a workaraund maybe helping troubleshooting the issue
15:38:56 <dcoutts> mind you we could do with a more memory efficient version, we sometimes have to download some big tarballs
15:39:23 <dons> roconnor: wasn't most of your complaints against the ghc optimiser about this bit shift constant folding?
15:39:46 <dcoutts> MarcWeber: it's not a major problem at the moment because not many users are fetching hundreds of packages in one shot, people more commonly cabal install just a couple things
15:40:41 <dcoutts> nomeata: I was just looking for you... :-)
15:40:54 <nomeata> dcoutts: and I was looking for you
15:40:58 <dcoutts> nomeata: I'm applying your cabal/haddock patches
15:41:04 <nomeata> dcoutts: it seems my mail did not get through, according to the archive
15:41:12 <dcoutts> nomeata: you were not subscribed
15:41:16 <nomeata> dcoutts: ah, nice. did the mail get through after all?
15:41:19 <dcoutts> no
15:41:21 <nomeata> dcoutts: hmm. maybe you should whitelist darcs patches
15:41:30 <dcoutts> I just downloaded them from darcswatch
15:41:37 <dcoutts> nomeata: if only we could! :-)
15:41:43 <roconnor> dons: yep
15:41:57 <dcoutts> nomeata: we cannot figure out how to get mailman to do that for us
15:41:59 <roconnor> dons: it make my Sha2 function and my UM slow.
15:42:24 <MarcWeber> dcoutts: Why ? What's the problem with this?
15:42:57 <dons> ok. so you can quit generalising from an INLINE rotate to all of "optimising pure functional languages" now :)
15:43:08 <dcoutts> nomeata, MarcWeber: I know it has that extra header we can use to recognise darcs emails but mailman looks at subscribers before other filter rules
15:43:33 <s|k_> GHC or Hugs?
15:43:39 <dons> i note xor, complement,shiftl, all get done at compile time too
15:43:54 <astrolabe> Using parsec, I want to use something like many1, but I need it to stop when it reaches the end of the file rather than giving an error.  Any ideas please?
15:44:39 <s|k_> ghc is 134mb wow
15:44:43 <dons> roconnor: yeah, looks like everything but rotate is working as is, and i'm pushing a patch for rotate now
15:44:57 <dons> s|k_: that's the full libraries, profiling tools, debugger etc.
15:44:59 <dcoutts> nomeata, MarcWeber: so I cannot see any way to configure mailman to accept emails by looking at a header without letting through spam from non-subscribers
15:45:06 <nomeata> dcoutts: hmm. I guess that can be changed relatively easy by swapping some lines in mailman, but of course that‚Äôs not as nice as an unmodified mailman
15:45:09 <roconnor> dons: I wonder how this constant folding works.
15:45:09 <dons> about the same size as any other full language distribution
15:45:27 <s|k_> say how good is the ghc compiler? pretty efficient? compariable to a C compiler?
15:45:30 <s|k_> comarable*
15:45:46 <dcoutts> nomeata: but the reason I was looking for you was to ask about part of the patch
15:45:48 <dons> its produce similar code from similar source
15:46:03 <nomeata> dcoutts: you could set up another alias that allows _only_ darcs patches, and that forwards them to the list. hmm. but then, the forwarded mail is either canged or still does not come from a subscriber
15:46:10 <tromp> ghc still lagging pretty far behind c on my connect-4 solving code
15:46:24 <ddarius> astrolabe: manyTill ?
15:46:28 <dcoutts> nomeata: the bit about the warning and turning it off with --internal, I don't understand it :-)
15:46:28 <roconnor> tromp: if you are looking for the spec, it is at http://boundvariable.org/task.shtml#materials  but yes, dons's link ought to be fixed.
15:46:35 <lambdabot> Title: ICFP Programming Contest, 2006 : Contest Materials and Task
15:46:41 <roconnor> actually there ought have been a redirect
15:46:43 <astrolabe> ddarius: thanks again, I'll look it up.
15:47:02 <dcoutts> nomeata: the thing about "Perhaps you want to use the haddock command with the --executables or --internal flag."
15:47:15 <dcoutts> nomeata: I can't see what the --internal has got to do with it
15:47:16 <roconnor> I can't complain about GHC anymore.
15:47:17 <roconnor> :)
15:47:28 <ddarius> roconnor: Sure you can.
15:47:29 <roconnor> I'll try to find something else to complain about.
15:47:37 <astrolabe> tromp: Do you know what it is about your code that ghc finds difficult?
15:47:42 <nomeata> dcoutts: right. I think I wrote that before I noticed that --executables already enables haddock for the unexposed modules.
15:48:05 <nomeata> dcoutts: I think you can revert that change, and sorry for the confusion.
15:48:10 <dcoutts> nomeata: ok, will do, np
15:48:13 <tromp> the 64-bit operations were pretty slow last time i checked (pre 6.8.2)
15:48:47 <astrolabe> tromp: You have a bitboard?
15:48:53 <tromp> yes
15:49:14 <tromp> http://homepages.cwi.nl/~tromp/c4/fhour.html
15:49:16 <lambdabot> Title: The Fhourstones Benchmark
15:49:29 <astrolabe> thanks
15:49:44 <Noxwizard> Ok, so I made a simple function to make an int a float, but I'm having trouble using it in a foldr: toF a = fromIntegral a :: Float
15:50:22 <Noxwizard> I tried: foldr (toF) [] [1,2,3] but it says the type is incorrect
15:50:40 <dibblego> ?type foldr
15:50:41 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:50:50 <dibblego> the first argument is a function that takes two arguments
15:51:26 <xd> you are prolly wanting map
15:51:49 <dibblego> I think he is trying to use foldr instead, to learn
15:53:43 <sioraiocht> > foldr ((:) . toF) [] [1..3]
15:53:44 <lambdabot>   Not in scope: `toF'
15:54:05 <sioraiocht> > let toF a = fromIntegral a :: Float in foldr ((:) . toF) [] [1..3]
15:54:06 <lambdabot>  [1.0,2.0,3.0]
15:55:24 <sioraiocht> :t foldr ((:) . f) []
15:55:26 <lambdabot> forall a a1. (SimpleReflect.FromExpr a, Show a1) => [a1] -> [a]
15:55:33 <dcoutts> nomeata: remind me the address I have to subscribe to get all patches to be noticed by darcswatch
15:55:40 <sioraiocht> oops..
15:55:45 <red75> Noxwizard: In your case foldr will have the type (by inferring) (a->[b]->[b])->[b]->[a]->[b], so you should supply foldr with function of type (a->[b]->[b]).
15:55:56 <nomeata> dcoutts: darcswatch@nomeata.de
15:56:00 <dcoutts> thanks
15:59:04 <sioraiocht> :t foldr ((:) . f) []
15:59:06 <lambdabot> forall a a1. (SimpleReflect.FromExpr a, Show a1) => [a1] -> [a]
15:59:10 <sioraiocht> :t f
15:59:11 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
15:59:13 <sioraiocht> ?
15:59:16 <Noxwizard> Thanks guys
15:59:38 <sioraiocht> Noxwizard: map f is equivalent to foldr ((:) . f) []
15:59:50 <Noxwizard> I know, but I'm trying it with maps and folds
16:00:55 <dcoutts> nominolo: thanks for replying :-) you're the only one who has
16:01:17 <nominolo> dcoutts: yes, that was weird
16:01:30 <dcoutts> nominolo: perhaps I wrote too much :-)
16:01:55 <dcoutts> nominolo: I was kind of hoping it'd be controversial, but maybe I was too diplomatic
16:01:56 <nominolo> dcoutts: well it's one of those things opposite to the bikeshed
16:02:11 <dcoutts> though it gets real flames on darcs-devel
16:02:22 <nomeata> dcoutts: this is not tested, but by reading the code of my mailman installation, it seems that header_filter_rules are applied before the non-member moderation, so maybe whitelisting something with that actually does work
16:02:33 <dcoutts> nominolo: I was phrasing it more in the abstract though
16:02:46 <dcoutts> nomeata: hmmm
16:02:49 <nominolo> dcoutts: what got flames?  your post?
16:03:23 <dcoutts> nominolo: no, I've never posted to darcs-devel, but if you read the thread last month on cabalising darcs, boom!
16:03:30 <nomeata> dcoutts: if not, the order of modules used for processing (GLOBAL_PIPELINE) can be changed in /usr/lib/mailman/Mailman/Defaults.py
16:03:51 <nominolo> oh, interesting
16:04:52 <red75> :t join $ return $ return
16:04:55 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
16:05:15 <nomeata> dcoutts: actually, this can be overriden by mm_cfg.py, so no changed to installed code would be necessary. but I think using an "accept" header_filter_rule (in the Spam Filter settings) should work
16:05:25 <dcoutts> nomeata: ok, so I'm adding a rule to accept X-Darcs-Version:.*
16:05:56 <nomeata> anyways, I‚Äôm off to bed, I just came online to see what happened to my patch :-)
16:06:20 <dcoutts> nomeata: now applied :-)
16:06:26 <dcoutts> thanks :-)
16:06:36 <nomeata> good night
16:07:31 <dcoutts> nominolo: yeah, david really doesn't like the approach to configuration
16:08:02 <dcoutts> nominolo: which is kind of related to his view on specifying dependencies on modules or packages
16:08:32 <dcoutts> nominolo: and some of the criticisms are quite valid but I think we can fix most within the system we've been advocating
16:08:54 <dcoutts> nominolo: ie the cabal configurations style of specifying optional/conditional dependencies
16:09:32 <dcoutts> nominolo: we just need to be able to condition on more things, not just haskell packages but other aspects of the environment like C libs, pkg-config packages, build-tools
16:10:01 <dons> roconnor: so rotate inlined is now in base. should work with tomorrow's head.
16:10:16 <dons> all other atomic-typed Bits instances and methods seem to be constant folding.
16:11:02 <dcoutts> and allow some kinds of custom code tests to set the default values of flags, but so long as they do not affect the dependencies of a package, only things like cpp flags, but not linking to C libs since we need to know about external deps up front
16:11:51 <dcoutts> otherwise package managers get stuffed because it's impossible to plan installations of multiple packages accurately
16:13:07 <mux> I wish ghc wouldn't warn about not having any type annotation for main with -Wall
16:15:11 <nominolo> dcoutts: so you're for duplicating some autoconf functionality?
16:15:22 <dcoutts> nominolo: yes
16:15:34 <dcoutts> but in a controlled way
16:15:56 <dcoutts> the crucial thing is whether some test results in us picking up an extra external dependency
16:16:11 <nominolo> ve taze no be *really* careful what to include
16:16:23 <nominolo> oops
16:16:23 <dcoutts> if it does then it has to be declared using the constraints language so that the package manager has any chance
16:16:30 <nominolo> *we have to be
16:17:00 <dcoutts> if it doesn't affect external deps then we can allow custom code to do more arbitrary checks
16:17:13 <nominolo> my concern is that most of the stuff in autoconf is there for a reason
16:17:21 <dcoutts> hmm?
16:17:35 <nominolo> so if we duplicate some part of it, we might find out we need to duplicate even more of it
16:17:55 <bos> it's a big problem to try to deal with.
16:17:57 <nominolo> someone will need this autoconf feature.  someone will need that
16:18:21 <roconnor> dons: thanks don
16:18:25 <nominolo> i wonder if we can define a clear border of where to stop
16:18:37 <roconnor> dons: I don't suppose there is a paper describing the new constant folding whatever.
16:18:53 <dcoutts> nominolo: I think the border is to do with picking up extra dependencies
16:20:13 <dcoutts> nominolo: some of these features are essential for some packages, they have to do them, either in ./configure scripts on in Setup.hs
16:20:52 <dons> roconnor: well, i think its just improved inlining
16:20:59 <dons> that happened as part of the spec constr changes
16:21:03 <nominolo> ah, so basically you only want those features to find out if a dependency is present or not?
16:21:10 <dcoutts> nominolo: yeah
16:21:23 <lilac> in parsec is there a better way to write: oneOf ['A'..'Z']++['a'..'z'] <|> digit ?
16:21:31 <bos> having pkg-config support would be useful and quite modular, for example.
16:21:46 <nominolo> lilac: letter <|> digit
16:21:51 <vixey> alphaNum
16:21:52 <nominolo> lilac: = alphaNum
16:22:05 <nominolo> bos: we do
16:22:10 <dcoutts> bos: done
16:22:13 <nominolo> bos: but not all packages are pkg-config
16:22:16 <bos> oh, cool.
16:22:19 <bos> yes, i know :-)
16:22:28 <dcoutts> eg the database libs
16:22:34 <nominolo> the point are the other tools
16:22:56 <nominolo> s/tools/non-haskell dependencies/
16:22:57 <lilac> nominolo: that also accepts '\194' (for instance)
16:23:08 <dcoutts> it needs custom code to find if the oracle client libs are installed for example
16:23:21 <dcoutts> which makes package planning really quite hard
16:23:53 <nominolo> lilac: well, then a probably more efficient way would be to use satisfies (...)
16:23:55 <dcoutts> how can a package manager know what to install if it requires custom code to decide if you'll pick up an extra dependency or not
16:24:12 <lilac> ta
16:24:16 <nominolo> lilac: pattern matching is usually faster than searching in a list
16:24:54 <lilac> @ty satisfies
16:24:56 <lambdabot> Not in scope: `satisfies'
16:25:21 <slava> is there a [Maybe a] -> [a] ?
16:25:31 <wjt> @ty catMaybes
16:25:32 <dolio> @type catMaybes
16:25:32 <lambdabot> forall a. [Maybe a] -> [a]
16:25:34 <lambdabot> forall a. [Maybe a] -> [a]
16:25:39 <dons> ?hoogle [Maybe a] -> [a]
16:25:40 <lambdabot> Data.Maybe.catMaybes :: [Maybe a] -> [a]
16:25:41 <dons> type search rocks
16:25:47 <dons> heya slava, how's code?
16:25:50 <nominolo> dcoutts: give it a name
16:26:05 <slava> hey dons, how's openbsd :)
16:26:19 <nominolo> dcoutts: ok, i mean: test it once and define a default way to find out
16:26:38 <dons> slava: i've got my 4.3 disk sitting right here.
16:26:39 <nominolo> dcoutts: kind of like "virtual packages" or "stub packages"
16:26:44 <dcoutts> nominolo: you mean run the code up front when we're planning what packages to install?
16:27:08 <nominolo> dcoutts: first you find out what might need to be considered, then check, then revise
16:27:09 <slava> is Maybe an instance of Functor? does fmap make sense on it even?
16:27:19 <nominolo> slava: sure
16:27:19 <slava> ?hoogle Maybe
16:27:20 <lambdabot> Data.Maybe :: module
16:27:20 <lambdabot> Prelude.Maybe :: data Maybe a
16:27:20 <lambdabot> Data.Maybe.Maybe :: data Maybe a
16:27:22 <mauke> @src Maybe fmap
16:27:22 <lambdabot> fmap _ Nothing       = Nothing
16:27:22 <lambdabot> fmap f (Just a)      = Just (f a)
16:27:28 <slava> yeah, that's the definition i had in mind
16:27:37 <nominolo> > (+3) `fmap` Just 42
16:27:38 <lambdabot>  Just 45
16:27:49 <dcoutts> nominolo: it might be possible for cabal-install but it's almost impossible for other package managers, they want deps on other packages
16:28:00 <nominolo> slava: every monad should be a functor
16:28:15 <dcoutts> nominolo: though some are ok with deps on files that might be provided by other packages
16:28:26 <nominolo> dcoutts: oh, i see
16:28:54 <nominolo> dcoutts: then they need to map from the "virtual package" to the package-manager-managed package
16:29:33 <dcoutts> nominolo: for several standard things that's quite possible, like well known prog or lib names
16:29:52 <dcoutts> nominolo: we can say a haskell packages deps on those and distros can map them to the packages that provide them
16:30:15 <dcoutts> and it's something cabal-install can check directly
16:30:47 <nominolo> big problem here is that it we need an agreed-upon way to define that "stub package"
16:31:02 <slava> nominolo: oh, you're right
16:31:19 <slava> @src Monad fmap
16:31:19 <lambdabot> Source not found. You untyped fool!
16:31:28 <slava> hmm
16:31:34 <red75> @src fmap
16:31:35 <lambdabot> Source not found. My brain just exploded
16:31:39 <dons> ?src fmap []
16:31:39 <lilac> ?hoogle (a -> Bool) -> GenParser b c a
16:31:40 <lambdabot> Source not found. It can only be attributed to human error.
16:31:40 <lambdabot> No matches, try a more general search
16:31:43 <dons> ?src [] fmap
16:31:43 <lambdabot> fmap = map
16:31:50 <dons> ?src Either fmap
16:31:50 <lambdabot> fmap _ (Left x) = Left x
16:31:50 <lambdabot> fmap f (Right y) = Right (f y)
16:32:01 <dcoutts> nominolo: I don't see what you mean about a stub package
16:32:13 <slava> dons: that's an interesting fmap for Either
16:32:25 <slava> why not map over the left and right values?
16:32:33 <dcoutts> nominolo: we can resolve configurations by looking at more fields than just build-depends
16:32:36 <Botje> slava: Left typically means failure
16:32:50 <nominolo> dcoutts: like for C-lib "libfoo" you have a cabal-package "c-pkg-libfoo" that only contains the test
16:33:00 <mauke> slava: because they have different types
16:33:06 <lilac> slava: it's not a monoid if you do
16:33:11 <dcoutts> nominolo: testing for C libs is more generic than that, doesn't need custom code
16:33:12 <nominolo> dcoutts: ie, you model the c-package as a haskell package
16:33:25 <dcoutts> nominolo: I don't think that's the way to go
16:33:27 <nominolo> dcoutts: then you only need to check for it once
16:33:28 <dons> ?src Either
16:33:28 <lambdabot> Source not found. Where did you learn to type?
16:33:31 <dons> grr
16:33:47 <nominolo> dcoutts: just an idea
16:33:59 <slava> dons: if lambdabot was a real person she'd be banned from here by now
16:34:10 <ziman> she? :)
16:34:16 <dcoutts> nominolo: sure, we'd want to do all those constant checks up front, after than it's a fixed evaluation since we assume our haskell package manager cannot install more C libs
16:34:17 <mauke> @vixen be nice, ok
16:34:17 <nominolo> ziman: of course!
16:34:17 <lambdabot> bad is better than nice ;)
16:34:36 <ziman> oh, i didn't know.. :)
16:34:42 <slava> ?src Either ++
16:34:42 <lambdabot> Source not found. That's something I cannot allow to happen.
16:34:44 <dcoutts> nominolo: it's a bit like translating: extra-libs: unavailable -> buildable: False
16:34:53 <slava> what's the monoid operation on Either?
16:35:00 <mauke> @src Either mappend
16:35:00 <lambdabot> Source not found. You speak an infinite deal of nothing
16:35:03 <mauke> :(
16:35:20 <nominolo> dcoutts: yes, but at the same time you can map the check to a distribution's package manager dependency
16:35:29 <dcoutts> nominolo: yes
16:35:51 <nominolo> > Left "a" `mappend` Left "b"
16:35:51 <lambdabot>        add an instance declaration for (Monoid (Either [Char] b))
16:36:05 <nominolo> > Left "a" `mappend` Right "b"
16:36:05 <lambdabot>        add an instance declaration for (Monoid (Either [Char] [Char]))
16:36:05 <lambdabot>     In...
16:36:23 <nominolo> @instances Monoid
16:36:24 <slava> so it inherits the monoid operation from the value being wrapped?
16:36:24 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
16:36:46 <nominolo> slava: it ain't a monoid
16:37:06 <slava> lilac said it was
16:37:16 <slava> ?src Maybe mappend
16:37:16 <lambdabot> Source not found. You speak an infinite deal of nothing
16:37:56 <nominolo> slava: it isn't --> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html#t%3AMonoid
16:37:57 <lambdabot> http://tinyurl.com/y5qk9n
16:38:40 <red75> ?hoogle [Just a]->[Just a]->[Just a]
16:38:41 <lambdabot> No matches, try a more general search
16:38:58 <red75> ?hoogle [Maybe a]->[Maybe a]->[Maybe a]
16:38:59 <lambdabot> No matches, try a more general search
16:39:12 <red75> ?hoogle Maybe a->Maybe a->Maybe a
16:39:13 <sarehu> red75: what are you looking for
16:39:13 <slava> red75: in general type constructors are not types
16:39:14 <lambdabot> Data.Generics.Aliases.orElse :: Maybe a -> Maybe a -> Maybe a
16:39:24 <slava> hey glguy
16:39:45 <red75> well. mappend for Maybe
16:41:25 <red75> Is Monoid correspond to MonadPlus?
16:41:37 <sarehu> a monoid operation on Either (that inherits monoid operations on the type arguments) is impossible
16:41:43 <mauke> see First/Last
16:41:45 <slava> that's what i thought
16:43:08 <sarehu> unless both type arguments were the same type
16:43:58 <nominolo> well, you could have: left >>= \l -> right >>= \r -> return $ l `mappend` r
16:44:09 <glguy> hi slava
16:44:46 <sarehu> oh wait
16:44:48 <slava> nominolo: that wouldn't commute with Left/Right
16:44:53 <sarehu> monoids don't commute
16:44:56 <sarehu> they assote
16:45:12 <slava> you want (Left a) `mappend` (Left b) == Left (a `mappend` b)
16:45:21 <slava> and ditto for Right
16:45:30 <sarehu> nominolo: yes -- and there l and r are the same type
16:47:11 <sarehu> wait I think I'm wrong -- (Left a) `mappend` (Right b) = Right b, (Right a) `mappend` (Left b) = Right a ;  mempty = Left mempty
16:47:15 <sarehu> that should work.
16:47:34 <Saizan> that's like MonadPlus for either no?
16:48:03 <dolio> Yes, except MonadPlus is tied to Error, unfortunately.
16:49:14 <dolio> Although it's slightly more sensible for MonadPlus than it is for Monad.
16:50:00 <dolio> Since it requires a monoid, at least, I think.
16:50:05 <Saizan> yes, for MonadPlus you need some context to fill mzero
16:50:42 <mux> is there a difference between what python guys call duck typing and structural subtyping in a more theoritical oriented language?
16:50:50 <mux> looks basically like the same thing to me
16:52:12 <Saizan> well structural subtyping is usually more static-oriented?
16:52:20 <mux> yes
16:52:50 <mux> but apart from the static/dynamic difference, am I correct in thinking this is the same idea?
16:52:58 <dolio> I think so.
16:52:59 <jamii> In python you can add methods at runtime rather than ducking...
16:53:15 <Saizan> yes, afaiu
16:53:22 <jamii> I think the general purpose is the same but there are things in each that can't be done in the other
16:53:56 <Saizan> right, in python you can change the structure at runtime and all the checking is at runtime too
16:54:01 <dcoutts> mux: I've always considered them as static/dynamic equivalents of each other
16:55:18 <mux> did you guys check on ecmascript 4.0?
16:55:50 <jamii> Structural subtyping for js?
16:55:55 <mux> yep
16:56:01 <mux> well, duck typing since it's dynamic :-)
16:56:19 <jamii> OK, yeah
16:56:28 <mux> http://www.ecmascript.org/es4/spec/overview.pdf
16:56:33 <jamii> They have that 'like' keyword in their type annotations too
16:56:39 <Bonus_> what is the difference effectively between fmap and liftM?
16:56:40 <jamii> Which is a pretty cool idea
16:56:44 <Bonus_> they seem kind of similar to me
16:56:46 <Bonus_> e.g.
16:56:56 <Bonus_> m >>= return . f
16:56:59 <Saizan> Bonus_: they are supposed to be the same
16:57:07 <Bonus_> aha
16:57:08 <Bonus_> why?
16:57:13 <dolio> One has a Monad constraint, the other has a Functor constraint.
16:57:22 <Bonus_> aah, i see
16:57:24 <dolio> Because Functor isn't a superclass of Monad like it should be.
16:57:27 <Saizan> liftM is how you implement fmap with the methods of Monad
16:57:34 <mux> jamii: one thing I like is the non-nullable types
16:57:48 <Bonus_> thanks
16:57:59 <dcoutts> Boney: and liftM generalises to liftM2, liftM3
16:58:03 <dcoutts> oops
16:58:05 <mux> you can suffix a type with ! in ecmascript 4.0 to tell that null values are not allowed
16:58:13 <dcoutts> Bonus_ not Boney
16:58:20 * dcoutts curses tab completion again
16:58:21 <jamii> js is looking more and more attractive lately. Especially with the progress in Rhino and Rhino on Rails
16:58:22 <Bonus_> haha
16:58:50 <mux> they also added parameterized types
16:58:55 <Bonus_> i prefer to use `ap` though
16:58:57 <mux> with a syntax similar to C++ templates
16:58:59 <jamii> I didnt see that one...
16:59:03 <mux> ie Foo.<T>
16:59:08 <jamii> And I never learned C++
16:59:09 <dcoutts> Bonus_: but even liftM, 2,3 etc should really go away since there is Applicative
16:59:25 <Bonus_> yeah
16:59:48 <mux> I find it's rather messy to have to pass types explicitely and all, but still, it's good that they're getting parametric polymorphism
17:00:18 <jamii> I really like the idea of using duck typing to prototype and then adding static typing when you're done
17:01:20 <mux> oh, and es4 (finally!) preserves "this" accross function calls
17:01:24 <mux> that was a major pita
17:02:20 <Bonus_> of what use is the identity function
17:02:27 <Bonus_> because it's just id x = x
17:02:35 <Botje> plenty of use
17:02:53 <Botje> you can use it as a base in a fold when combining functions
17:03:07 <Saizan> ?type liftM2 id -- ap
17:03:09 <Botje> or you can use it to restrict types
17:03:09 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
17:03:10 <Bonus_> aha
17:03:30 <jamii> Bonus_: its also used in genrics for type based traversales
17:03:34 <Botje> yeah, ap is pretty wild.
17:03:51 <jamii> Bonus_: So you say apply f to things of this type and apply id otherwise
17:03:59 <jamii> *generics
17:04:10 <jamii> *traversals
17:04:21 <jamii> Stupid american keyboard
17:04:55 <criminy> I'm used to storing functions in lists in lisp/scheme. Can I get that same affect in haskell?
17:05:02 <Bonus_> yes
17:05:03 <Bonus_> sure
17:05:09 <criminy> mutable lists, I guess I mean
17:05:22 <Botje> why mutable lists?
17:05:49 <jamii> Haskell lists aren't mutable. You can store functions in maps though.
17:06:13 <jamii> Or use Data.Sequence
17:06:45 <jamii> What exactly do you want to do?
17:06:45 <dons> well, you can store functions in lists too
17:07:08 <jamii> dons: You can, but you cant efficiently update the list...
17:07:09 <dons> > map ($ 7) [ (+1), (*2) ]
17:07:10 <lambdabot>  [8,14]
17:07:23 <dons> well, its O(n) update. so if you need faster update, use Sequence or Map
17:07:24 <criminy> I'll look into that. I'm trying to do callbacks, but the only reference I have found is GLUT's implementation
17:07:42 <dons> if you're implementing a symbol table, IntMap might be good
17:10:05 <criminy> I'm not really sure the best way to implement it, I'm just remembering how I did in other languages.
17:10:52 <slava> dons: real world haskell is looking good
17:10:55 <slava> i like the monads chapter so far
17:11:49 <dons> slava: great!
17:12:14 <mux> it definitely looks real good
17:12:20 <mux> I'm going to pre-order it on amazon soon
17:12:52 <dons> yeah, its getting exciting
17:13:02 <dons>  /scary
17:13:10 <mux> I think I'm not going to need to read many of the chapters, but I definitely want it on my bookshelf anyway :)
17:14:04 <mux> oh btw
17:14:13 <Bonus_> yeah i read the new chapter on monads today
17:14:16 <Bonus_> wonderful stuff
17:14:23 <mux> I glanced at the file manipulation chapter, where you implement some find(1) like API
17:14:34 <Bonus_> i'll be buying a hardcopy
17:14:37 <mux> dons: did you consider mentioning the FileManip package on hackage?
17:14:55 <dons> i think we're shying away from not widely used things
17:15:50 <mux> System.FilePath.Find there is very nice though
17:15:52 <mux> http://hackage.haskell.org/packages/archive/FileManip/0.3.2/doc/html/System-FilePath-Find.html
17:15:54 <lambdabot> http://tinyurl.com/3xbfak
17:54:13 * edwardk waves hello.
17:54:54 * edwardk realizes that for once he is out of things that he frantically wants to tell planet.haskell and that it is remarkably freeing.
17:57:12 <gwern> @src fmap
17:57:12 <lambdabot> Source not found. There are some things that I just don't know.
17:59:10 * ddarius whispers "Kan extensions" into edwardk's ear.
17:59:53 <edwardk> ddarius: hahahaha thought about it =)
18:01:53 <edwardk> ddarius: i really suck at CT stuff when the idea of (co)limits gets tossed around. The problem without having a good formal background in that area of category theory. I was at a school where it was viewed as generalized abstract nonsense.
18:02:14 <edwardk> I generally prefer to play in the kiddie pool ;)
18:03:16 <ddarius> What does school have to do with it?
18:03:29 <edwardk> ddarius: damnit now you have me seriously thinking about this
18:04:13 <ddarius> I'm more a fan of indexed (co)limits rather than Kan extensions.  They seem a bit more down to earth, though you can do some pretty things with Kan extensions.
18:04:44 <ddarius> Like the visual that Kan extensions give for (conical) (co)limits is pretty.
18:05:33 <edwardk> Sometimes I feel like I wasted my math degree going exercising all of the computational geometry demons of my youth. =/
18:05:43 <edwardk> I have yet to see a use for a stabbing line problem in type theory.
18:06:00 <edwardk> nor a single Plucker coordinate =)
18:06:47 <ddarius> I lightly tossed about the idea of a "geometric algebra" of type theory a year or two or more ago.
18:06:56 <povman> if I update an IArray, does it copy the whole thing internally?
18:06:57 <edwardk> hrmm
18:07:08 <ddarius> povman: Yes.
18:07:26 <povman> what a pain :) i'll use diff then
18:07:51 <povman> actually what disadvantages does DiffArray have?
18:08:03 <edwardk> i'm actually quite comfortable with clifford algebras, trying to figure out what a 'plane like thing' would be in a type system =)
18:08:14 <ddarius> edwardk: To make that particular idea go anywhere, I suspect you'd have to generalize GA to something weaker than a field.
18:08:45 <povman> and what about if I update an IntMap?
18:08:52 <edwardk> ddarius: yeah. just trying to figure out what the multivector stuff would look like
18:09:11 <ddarius> If you update an IntMap you'll only copy the path to the node in the tree.
18:09:21 <edwardk> after all we have derivatives of functors, and if you go by the species stuff you can have integration of them too
18:09:45 <povman> ddarius: thanks - is this documented anywhere?
18:10:19 <ddarius> Not "officially".  The asymptotic complexities should be documented somewhere though.
18:12:52 <edwardk> ddarius: i'm officially going to put down the GA stuff now and back away very very slowly
18:13:08 <ddarius> edwardk: Probably the best thing to do.
18:13:40 <edwardk> you have to realize my entire m.s. thesis was on plucker and study coordinates (which is all clifford algebra stuff) =)
18:13:48 <ddarius> Indeed.
18:13:50 <edwardk> its very easy to fall back into those lines
18:14:18 <edwardk> and i've yet to see a use other than visibility problems or playing with radiosity
18:14:25 <ddarius> I wrote a Point2, Vector2, Bivector2 and Rotor2 class today.
18:14:59 <edwardk> nice. i should dig up and post some old clifford algebra stuff i have lying around here somewhere in Haskell
18:15:54 <edwardk> i think i have some stolfi-style oriented projective geometry stuff here too
18:16:37 <edwardk> of course i think the intersection of the people who have a use for it and who use haskell consists of the singleton set of me, but hey
18:16:58 <ddarius> I haven't done too much with projective geometry.
18:17:03 <edwardk> er, i guess that would probably be the empty set, since i don't have a use for it
18:17:25 <ddarius> You know you like typeful programming when you implement torsor types.
18:17:49 * SamB wonders where he can find some examples of "binary-compatible" simply-typed lambda expressions...
18:18:05 <ddarius> Define "binary-compatible"
18:18:10 <ddarius> @google io jot
18:18:12 <lambdabot> http://books.google.com/books?id=eZuWM-eq5uYC&pg=PA391&lpg=PA391&dq=io+jot&source=web&ots=GcDe6gIdaO&sig=xIdVQiIZfHcXI0lABN_nsEAdwBY
18:18:12 <lambdabot> Title: Advances in Cryptology - ASIACRYPT ... - Google Book Search
18:18:20 <edwardk> i like to work with oriented projective geometries because then when you lift lines to their plucker construction you can do something with the quadratic form other than check for intersection. you can use it to tell 'how' lines pass each other (i.e. clockwise or counter-clockwise) because the sign regains meaning.
18:18:26 <SamB> well, I mean that they should be observationally equivalent
18:18:26 <ddarius> @google iota jot
18:18:30 <lambdabot> http://www.bartleby.com/68/14/5314.html
18:18:30 <lambdabot> Title: scintilla, iota, jot, smidgin. The Columbia Guide to Standard American English.  ...
18:18:48 <ddarius> Cripes.
18:21:32 * gwern feels stupid. I originally though Plucker here referred to the text format for PDAs
18:21:50 <SamB> gwern: what does it refer to, if not that?
18:22:26 <gwern> SamB: I don' know, but lines like 'i like to work with oriented projective geometries because then when you lift lines to their plucker construction' make me think that's a different plucker
18:22:38 <SamB> oh, probably yes
18:23:25 <edwardk> technically it should be written in ascii as Pluecker =) he chaired Klein (as in Mr. Klein bottle)'s dissertation
18:23:46 <SamB> he ... told it to sit in it's chair?
18:24:09 <SamB> except the chair was actually a blanket on a rug on the floor?
18:24:11 <kpreid> ascii? bah. Pl√ºcker
18:24:21 * SamB refers to his dog's "chair"
18:24:25 <tero-> hi. I'm trying to define a Show instance for a type synonym but I get an error "Illegal instance declaration". Is this even possible?
18:24:39 <edwardk> kpreid: heh
18:24:48 <kpreid> tero-: not possible. it's not distinct (it's a synonym!) so you can't have a different instance.
18:25:10 <gwern> tero-: 'the world is all that is the case', so of course this error is possible. you have a constructive proof it is
18:25:11 <edwardk> tero: if you need a Show instance for it you need a newtype
18:25:23 <kpreid> tero-: if you want a different instance, you have to use a different type; newtype is the thing to do.
18:25:55 <kpreid> on the other hand, if you're just trying to use a shorthand for describing your instance, well...apparently you can't do that.
18:25:56 <tero-> gwern: I hardly ever get errors so I'm always as surprised
18:26:14 <tero-> ack. let's try newtype
18:26:24 <edwardk> gwern: http://en.wikipedia.org/wiki/Pl%C3%BCcker_co-ordinates is what i was talking about
18:29:49 <gwern> @wn sapience
18:29:50 <lambdabot> *** "sapience" wn "WordNet (r) 2.0"
18:29:50 <lambdabot> sapience
18:29:50 <lambdabot>      n : ability to apply knowledge or experience or understanding or
18:29:50 <lambdabot>          common sense and insight [syn: {wisdom}]
18:30:25 <tero-> wee. it works. thank you
18:30:32 <gwern> @wn sentience
18:30:33 <lambdabot> *** "sentience" wn "WordNet (r) 2.0"
18:30:33 <lambdabot> sentience
18:30:33 <lambdabot>      n 1: state of elementary or undifferentiated consciousness; "the
18:30:33 <lambdabot>           crash intruded on his awareness" [syn: {awareness}]
18:30:33 <lambdabot>      2: the faculty through which the external world is apprehended;
18:30:35 <lambdabot> [6 @more lines]
18:30:43 <gwern> @more
18:30:43 <lambdabot>         "in the dark he had to depend on touch and on his senses
18:30:43 <lambdabot>         of smell and hearing" [syn: {sense}, {sensation}, {sentiency},
18:30:43 <lambdabot>          {sensory faculty}]
18:30:43 <lambdabot>      3: the readiness to perceive sensations; elementary or
18:30:45 <lambdabot>         undifferentiated consciousness; "gave sentience to slugs
18:30:47 <lambdabot>         and newts"- Richard Eberhart [ant: {insentience}]
18:31:20 <edwardk> @spam
18:31:20 * lambdabot throws some pointy lambdas at
18:37:28 <edwardk> ddarius: it looks like neil ghani and company have a bunch of haskell-ish kan extension stuff
18:49:09 <dons> some hackers might like, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ghc-core
18:49:11 <lambdabot> http://tinyurl.com/63zxnu
18:49:20 <dons> a tool for reading ghc core and assembly, colourised, in a pager
18:56:23 <ddarius> edwardk: They have some, yes.
18:58:11 <edwardk> ddarius: otoh, that led me to take one of ghani's papers and start generalizing to get hylomorphisms for higher order functors, so you can handle things like data Perfect a = Leaf a | Perfect (Perfect (a,a)) =)
18:58:21 <edwardk> ddarius: so thanks for the poke
18:59:48 <ddarius> edwardk: "Initial Algebra Semantics is Enough!" ?
19:00:36 <edwardk> ddarius: yeah, going through and seeing i can do all the generalized hylomorphism constructions in this setting
19:00:44 <edwardk> might require higher order monads and comonads though =/
19:00:54 <ddarius> That paper is very good.
19:01:09 <edwardk> i'd skimmed it before but i wasn't in this 'mode' at the time
19:06:13 <Modius> What does a typical GHC user use for defining larger multi-file projects/building same?  (I can't quite figure it out - just give me a search topic or two and I'll go dig up info but I need a name)
19:07:50 <edwardk> uh, dumb question, what is a natural transformation between er, natural transformations? =)
19:09:04 <ddarius> 3-cells?  Or you can view natural transformations as functors...
19:09:29 <edwardk> ddarius: just realized i didn't have a name for it =)
19:13:12 <edwardk> for now i'll pass on letting higher order hylomorphisms carry around a 3-cell to change representations in the middle though =)
19:13:49 <edwardk> and damnit, to do generalized hylomorphisms in that setting you DO need higher order monads/comonads.
19:14:04 <edwardk> but the basic stuff works out fine
19:14:20 <gwern> @wn slattern
19:14:20 <lambdabot> *** "slattern" wn "WordNet (r) 2.0"
19:14:20 <lambdabot> slattern
19:14:20 <lambdabot>      n 1: a prostitute who attracts customers by walking the streets
19:14:20 <lambdabot>           [syn: {streetwalker}, {street girl}, {hooker}, {hustler},
19:14:20 <lambdabot>            {floozy}, {floozie}]
19:14:22 <lambdabot>      2: a dirty untidy woman [syn: {slut}, {slovenly woman}, {trollop}]
19:15:11 <edwardk> modius: i just tend to use ghc, vi, and setup a cabal file
19:15:48 <edwardk> going to see if i can work out higher order zygomorphisms, using functor products
19:16:11 <dcoutts> sounds yummy
19:17:38 <edwardk> Well there isn't much difference between hylo :: Functor f => Alg g b -> Natural f g -> CoAlg f a -> a -> b and hyloH :: HFunctor f => AlgH g b -> HNatural f g -> CoAlgH f a -> Natural a b
19:31:05 <edwardk> a link from an old scener friend of mine: http://scene.org/file.php?file=/parties/2008/breakpoint08/demo/fullscreen.zip&fileinfo
19:31:06 <lambdabot> Title: scene.org - file download, http://tinyurl.com/5oe68n
19:32:08 <gwern> 'This reminds me of my idea to write a go/shogi style manga, except about programming. "I have no idea what referential integrity is, but it sounds exciting!!"'
19:32:30 <Cale> Yeah, I saw that a while back. It annoys me a bit that they didn't bother to include the source.
19:32:50 <Cale> (and it's only built for windows)
19:32:50 <edwardk> cale: was just amused that it existed =)
19:36:42 <edwardk> ddarius: hrmm so a higher order monad in that setting would act on natural transformations? class HFunctor m => HMonad m where returnH :: Functor f => Natural f (m f); ...
19:38:59 <bd_> gwern: I'd read it
19:39:03 <bd_> <.<
19:39:59 <ddarius> edwardk: A monad is naturally a 2-categorical thing.  So are you viewing this as a monad over a 1-cell in a 3-category?
19:40:16 <edwardk> ddarius: basically yeah
19:40:47 <edwardk> ddarius: i just grope around until the types fit ;)
19:40:58 <ddarius> That's what types are for.
19:42:04 <dolio> I thought they were to keep me from doing exploratory programming.
19:42:13 <edwardk> heh
19:42:45 <ddarius> dolio: They keep you from exploratory bug writing.
19:42:52 <dolio> Heh.
19:43:22 * edwardk debates about if its worth doing higher order pointed, applicative, etc.
19:43:47 <edwardk> i think i'll skip to the punchline and see if it works out
19:44:43 <edwardk> fortunately the syntax of all of this is the same as the general control category stuff i was trying to do before, but now the types don't fight me
19:45:43 <edwardk> hbind   :: Functor f => Natural f (m g) -> Natural (m f) (m g) seems to work out
19:45:43 <SamB> edwardk: that sounds like ... theorem priving!
19:45:47 <SamB> er.
19:45:48 <SamB> proving
19:45:55 <edwardk> samb: =P
19:46:13 <SamB> groping around until the types fit, I mean
19:46:28 <edwardk> yeah, thats a large part of my life the last couple of weeks
19:46:30 <SamB> that is the only way I know to formally prove a theorem
19:46:35 <edwardk> *nods*
19:46:52 <SamB> unless it's so easy that no groping is needed
19:47:04 <SamB> but you still need to figure out the type of the theorem ;-)
19:47:20 <edwardk> heh, well, at this point i still need to figure out the meaning of the type ;)
19:47:28 <SamB> er. the type that is the theorem
19:48:10 <edwardk> gah and i just realized i don't want to write the type for hjoin, coz it seems to require a composition operator i don't want to write
19:49:25 <SamB> huh.
19:49:46 <SamB> it's kind of disconcerting to accidentally paste Se‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ into a shell
19:53:14 <edwardk> hrmm does type AlgH f g = Natural (MuH f) g or type HAlg f g = Natural (HMu f) g seem more natural syntactically to you guys?
19:54:15 <ddarius> The latter
19:54:27 <edwardk> was afraid you'd say that =)
19:55:02 <edwardk> I guess I should do the same with all the postfixed B's i was using for Bifunctor versions of things as well
19:55:16 <edwardk> leads to hcata instead of cataH
19:55:31 <edwardk> which i like, less noise, and i hate camelcasing functions
19:56:38 <edwardk> hrmm otoh, i don't like HIn, and hout BIn and bout
19:58:18 <edwardk> damn you people and your non-polykinded languages, whats next hungarian notation? ;-)
20:01:04 * Cale would go with hOut / bOut, in that case.
20:01:58 <edwardk> i kinda like outF/outB/outH because outF is kinda traditional thanks to the early papers on the topic
20:02:25 <SamB> edwardk: polykinding would most likely make the lives of compiler authors easier, in my opinion...
20:02:49 <SamB> kind defaulting can cause intense pain
20:03:03 <edwardk> samb: i just want to be able to use id or flip at any level of the type system =)
20:03:37 <SamB> edwardk: that would be great if id or flip were in the typesystem...
20:06:02 <dolio> They can be, sort of.
20:06:08 <edwardk> gah, i give up. keeping em at the end i'd have to rewrite ~40 source files and the others don't wind up nearly as pretty for a syntactic change
20:06:29 <dolio> newtype Flip f a b = Flip (f b a)
20:07:04 <dolio> newtype Flip3 f a b c = Flip (f b a c) -- your complaint?
20:07:10 * araujo just uploaded a new himerge version
20:07:30 * araujo noticed it will be a year since he released first version
20:07:57 <edwardk> dolio: that i have to define them again =)
20:08:13 <dolio> Then again, I don't know how you could usefully turn the first into the second as a newtype.
20:09:04 <dolio> And as a type it can't be partially applied.
20:09:20 <edwardk> well, not in haskell =)
20:10:03 <dolio> :) Yeah, well, you've got more problems than lack of polymorphic kinds.
20:10:31 <edwardk> i was mostly being facetious
20:10:33 <TomMD> "I've been using MTL for over twenty years now." -- Every tech community needs their own version of the 'twenty year' quote.
20:10:57 <dolio> Over 9000 years.
20:11:17 <TomMD> Nah, thats how long I've been using the GHC debugger.
20:14:04 <edwardk> I just find it funny when i hear people say something like that about Java. Or when I see a company advertising a position that requires more years experience with something than the something has been around.
20:15:06 <edwardk> er. hrm i bothered with higher order functors, should i bother with higher order bifunctors?
20:15:29 * edwardk feels vaguely like he is chasing his tail
20:16:47 <zeno> what is a functor anyways
20:16:54 <thoughtpolice> can anybody explain what a type-witness is, exactly? i asked in #darcs about a week ago and there doesn't seem to be anything covering it.
20:17:04 <edwardk> @google functor
20:17:05 <lambdabot> http://en.wikipedia.org/wiki/Functor
20:17:25 <zeno> @hoogle functor
20:17:32 <lambdabot> Prelude.Functor :: class Functor f
20:17:32 <lambdabot> Control.Monad.Functor :: class Functor f
20:17:32 <lambdabot> Control.Monad.Instances.Functor :: class Functor f
20:17:41 <edwardk> @type fmap
20:17:51 <edwardk> fmap is the 'meat' of a functor
20:17:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:17:55 <zeno> stands for functor map?
20:17:58 <edwardk> yeah
20:18:41 <zeno> interesting, cant really see how it could be used though
20:18:43 <edwardk> a functor instance is something where you can define fmap. fmap lifts functions on values into functions over the functor. there are some properties that says that fmap id = id, and some stuff like that but the general idea is you can think of a functor as a container
20:18:54 <edwardk> > fmap (+1) [1,2,3]
20:18:55 <lambdabot>  [2,3,4]
20:19:04 <edwardk> >fmap (*2) (Just 4)
20:19:20 <dolio> Are you defining higher-order build?
20:19:37 <edwardk> dolio: thinking about it. right now i have a higher order anamorphism
20:19:44 <dolio> Who doesn't love build?
20:19:49 <zeno> edwardk: ah ok thanks
20:19:52 <edwardk> but i don't have lower order build so i figured ana was the better way to go
20:20:33 <edwardk> dolio: i have higher order hylo, but i wasn't able to get higher order generalized hylo because well, er, i hadn't yet defined higher order comonads/monads until a couple minutes ago
20:20:43 <edwardk> and i still don't have any good examples of them =)
20:20:49 <edwardk> they kinda scare me
20:20:55 <dolio> Heh.
20:21:04 <edwardk> i guess i could derive some mechanically
20:21:54 <bos> @seen dons
20:21:54 <lambdabot> dons is in #haskell-hac4, #haskell-soc, #xmonad and #haskell. I last heard dons speak 1h 21m 22s ago.
20:22:02 <edwardk> heh, kinda find it funny that i'm thinking about higher order bifunctors so i can fuse hfmaps with higher order generalized hylomorphisms, but thats just crazy talk =)
20:22:38 <edwardk> i have yet to find a need for a generalized hylomorphism that builds up perfect trees or something as an intermediate result.
20:22:44 <dolio> Yeah. Thoroughly useless. :)
20:23:13 <edwardk> ski had a couple of neat inductive type families iirc
20:23:36 <edwardk> i think he had one where the type was the traversal of a tree separated from the elements of a tree, etc.
20:24:07 <edwardk> great fun for scaring freshmen though
20:24:20 <saml> http://hpaste.org/7317  how can I implement sanitize function?
20:24:23 <dolio> I imagine.
20:25:48 <saml> oh i think i have an idea
20:33:02 <saml> http://hpaste.org/7317#a1 yay
20:33:15 <mapreduce> :t flatMap
20:33:16 <lambdabot> Not in scope: `flatMap'
20:33:30 <mapreduce> Is it called (>>=) or something?
20:33:58 <edwardk> gah i'm so tempted to define Bifunctor at least over a Category so i can get rid of (+++) (***) and subsume first and second rather than import Control.Arrow all over the place =/
20:34:06 <edwardk> mapreduce: bind
20:34:12 <mapreduce> :t bind
20:34:13 <lambdabot> Not in scope: `bind'
20:34:15 <edwardk> er
20:34:21 <edwardk> @type concatMap
20:34:23 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
20:34:29 <edwardk> @type (>>=)
20:34:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:34:45 <edwardk> @type (flip (>>=))
20:34:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
20:35:10 <mapreduce> If you had a `concatMap` b `concatMap` c would there be a better way?
20:35:17 <saml> > succ 'z'
20:35:18 <lambdabot>  '{'
20:35:31 <saml> is there a way to make succ 'z'  'aa' ?
20:35:52 <saml> a, b, c, d, ..., z, aa, ab, ac, ..
20:35:59 <mapreduce> > let succ 'z'='aa' in succ 'z'
20:35:59 <lambdabot>  Improperly terminated character constant at "'aa'" (column 14)
20:36:11 <mapreduce> > let succ 'z'="aa" in succ 'z'
20:36:11 <dolio> 'aa' isn't a character.
20:36:12 <lambdabot>  "aa"
20:36:18 <tromp> > succ "z"
20:36:19 <lambdabot>   add an instance declaration for (Enum [Char])
20:36:20 <lambdabot>     In the expression: succ "...
20:36:23 <mapreduce> :t succ
20:36:25 <lambdabot> forall a. (Enum a) => a -> a
20:36:34 <saml> hrm i think a, b, ...., z, a0, b0, .. z0, a1, .. would be nicer
20:36:38 <edwardk> > let f x = [x,x+1] in (f >>= f >>= f) 1
20:36:38 <lambdabot>  Couldn't match expected type `t -> a' against inferred type `[[t]]'
20:36:50 <saml> how does haskell assigns type variables?
20:36:51 <edwardk> hrmm
20:36:52 <mapreduce> :t nub
20:36:54 <lambdabot> forall a. (Eq a) => [a] -> [a]
20:36:54 <edwardk> ah
20:37:04 <edwardk> > let f x = [x,x+1] in (f 1 >>= f >>= f)
20:37:05 <lambdabot>  [1,2,2,3,2,3,3,4]
20:37:22 <edwardk> @type >=>
20:37:24 <lambdabot> parse error on input `>=>'
20:37:25 <dolio> let f x = [x,x+1] in (f >=> f >=> f) 1
20:37:31 <dolio> > let f x = [x,x+1] in (f >=> f >=> f) 1
20:37:32 <lambdabot>  [1,2,2,3,2,3,3,4]
20:37:42 <edwardk> yeah
20:37:51 <edwardk> was looking for whatever the kleisli composition got called =)
20:38:19 <mapreduce> I'll show you the single line of Scala that contains it:
20:38:23 <tromp> :t (>=>)
20:38:24 <mapreduce> def sortedCards(implicit network: Network) = children(network.all).flatMap(_.asCard).flatMap(_.withDrivers).toList.sort(_.ethNumber > _.ethNumber) }
20:38:25 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
20:38:42 <mapreduce> So I should google the kleisli composition and find a way to write that?
20:39:18 <TomMD> > "/tmp/" </> "X11" <.> "conf"
20:39:19 <lambdabot>   Not in scope: `<.>'
20:40:10 <TomMD> mapreduce: do you use hadoop?
20:40:21 <mapreduce> Not yet.
20:41:37 <TomMD> ?where dph
20:41:37 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
20:41:55 <mapreduce> Cheers. mapreduce -> sleep
20:46:15 <edwardk> dolio: the pathetic part is that merging the -Wall in your cabal file is taking longer than everything else ;)
20:46:37 <dolio> Wall complains about a lot.
20:46:55 <sauxdado> that clown and his stupid language
20:47:41 <dolio> Although you should be somewhat better off since you're using stuff like Natral f g and Distrib f g.
20:47:50 <dolio> Natural, even.
20:47:53 <edwardk> yeah
20:48:20 <edwardk> mostly its complaining about my very large number of syntactically incorrect rule instances ;)
20:48:30 <dolio> I kept getting complaints when I was using 'forall a. f (g a) -> g (f a)' because it shadows 'a'.
20:48:31 <edwardk> 40 source files down, 11 to go, blah
20:48:32 <Cale> sauxdado: what?
20:49:41 <sauxdado> Wall, pun, funny
20:50:26 <edwardk> heh wow that was a long warning. i just got a screen full about orphan rules, now to understand it
20:50:48 <dolio> Nothing you can do about that, I suspect. You'll just have to live with it.
20:51:24 <edwardk> oh got it, i can move them
20:51:48 <edwardk> "braid/associate/braid"         bimap id braid . associate . bimap braid id = associate . braid . associate was in the wrong file
20:54:24 <edwardk> holy crap it compiled
20:54:30 <Modius> I was wondering if anyone's ever made the attempt to statically analyze recursion (non-tail) for cases where it could be converted into something that generated said result without consuming stack.
20:58:59 <edwardk> Is the general consensus that http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Exponential.html is really just a dinatural transformation?
20:59:00 <lambdabot> http://tinyurl.com/67c3xk
20:59:55 <edwardk> byorgey earlier was talking about that his version of it had quickchecked or something, no?
21:06:23 <edwardk> Control.Functor.KanExtension ?
21:09:08 <dmwit> Kaaaaaaan -- a Kan extension
21:09:15 <edwardk> =)
21:09:22 <edwardk> Control.Functor.Kaaaaan then =)
21:09:27 <dmwit> =)
21:11:19 <roconnor> it's Khaaaaaaaaaan!
21:24:34 <bos> @ho Num a => a -> Double
21:24:35 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
21:24:41 <bos> @hoogle Num a => a -> Double
21:24:41 <lambdabot> No matches, try a more general search
21:24:53 <bos> @hoogle (Num a, Rational b) => a -> b
21:24:54 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
21:24:54 <lambdabot> Data.Generics.Aliases.unGM :: GenericM' m -> Data a => a -> m a
21:24:54 <lambdabot> Control.Monad.Error.Class.throwError :: MonadError e m => e -> m a
21:25:09 <bos> so much for class contexts.
21:26:06 <geezusfreeek> dangit dons ghc-core is going to make me performance crazy
21:26:48 <geezusfreeek> more seriously, i've been meaning to learn a bit about core anyway
21:27:08 <bos> ooh, a newish paper about using haskell for real world code: http://reddit.com/info/6hvg8/comments/
21:28:02 <geezusfreeek> ooh nice
21:29:53 <thoughtpolice> who wants to bet on one of the comments being "oxymoron"?
21:30:31 <Cale> Who wants to bet on that comment being downmodded into oblivion?
21:31:45 <geezusfreeek> i'm with cale on that one
21:31:46 <thoughtpolice> based on the surprising frequency of both on reddit lately, i doubt anyone will take either bet.
21:32:17 <dmwit> I bet no "oxymoron" comment.
21:33:40 <geezusfreeek> i love how each data structure in a haskell program always seems to have a very visually distinct flavor from the rest when you use it
21:43:37 <roconnor> geezusfreeek: how do you mean?
21:45:29 <geezusfreeek> maybe it's just the way I write code, but it just always seems like it is easy to identify what sorts of structures and algorithms are being used in some chunk of code just based on how it looks from afar without reading anything, moreso than in most imperative languages at least
21:48:08 <adu> even in Haskell?
21:49:38 <geezusfreeek> i am talking about haskell specifically
21:49:54 <geezusfreeek> adu: oh you missed the first half of that
21:50:28 <geezusfreeek> i said "i love how each data structure in a haskell program always seems to have a very visually distinct flavor from the rest when you use it" and then roconnor said "how do you mean?", then you came in
21:52:39 <roconnor> geezusfreeek: I wonder if that has to do with conciseness?
21:53:03 <Cale> At first I kind of read that as sarcasm... it can also be seen as a lack of use of polymorphism that different data structures are used in very different ways.
21:53:05 <sauxdado> geezusfreeek: i think that of type signatures. You see a type signature, and you don't need any further comments to understand what the function does.
21:53:34 <geezusfreeek> Cale: that is true. perhaps i just suck! ;)
21:53:43 <adu> geezusfreeek: ok, i agree, i was just checking...
21:53:48 <Cale> geezusfreeek: I don't think it's anything to do with you...
21:53:55 <roconnor> sauxdado: probably name + type signature
21:54:15 <Cale> We've generally struggled with a general containers library which everyone would find agreeable.
21:54:30 <Cale> And then of course, datastructures are not necessarily just datastructures in Haskell.
21:54:44 <Cale> They're often really control structures in disguise :)
21:54:59 <geezusfreeek> well, right now i'm using a GADT, and those _definitely_ have a distinct flavor
21:55:08 <geezusfreeek> in exactly the way you are talking about
21:55:21 <sauxdado> roconnor: right
22:02:33 <Cale> Hehe, has anyone been watching the recent Catsters videos? A monoid object in the monoidal category of monoids is a commutative monoid. :)
22:03:03 <edwardk> heh try saying THAT 3 times real fast ;)
22:04:08 <pavizard> Is there any better way to implement this?
22:04:11 <pavizard> def catalogueDetails():
22:04:11 <edwardk> so does that mean a comonoidal object in the comonoidal category of comonoids is a commutative comonoid? ;)
22:04:11 <roconnor> it doesn't take much to be a monoid.
22:04:13 <pavizard>     for k in catalogue.keys():
22:04:14 <pavizard>         print "Title: ",k[0]
22:04:20 <Cale> co-commutative
22:04:25 <edwardk> fair nuff
22:04:30 <Cale> :)
22:04:40 <pavizard> oppps sorry :P thatt was for #python
22:04:41 <Cale> Or perhaps just mmutative
22:04:46 <edwardk> =)
22:04:50 <sauxdado> or, if you'd like it put more simply - never imagine yourself not to be otherwise than what it might appear to others that what you were or might have been was not otherwise than what you had been would have appeared to them to be otherwise.
22:05:10 <edwardk> sometimes i wonder why i coassociate with you folks =P
22:05:24 <edwardk> heading to bed
22:05:36 <sauxdado> because we're cool? :)
22:12:52 <sauxdado> (does somebody actually understand (parse) that carroll quote?)
22:13:14 <Cale> Never imagine yourself not to be otherwise than what (it might appear to others that what you were or might have been was not otherwise than what you had been) would have appeared to them to be otherwise.
22:13:31 <Cale> Does that help?
22:13:37 <sauxdado> yes
22:13:44 <sauxdado> are you sure it's correct?
22:13:49 <Cale> I think so.
22:13:58 <sauxdado> that's REALLY hard to see.
22:14:09 <sauxdado> carroll rocks
22:16:26 <Cale> Obviously a mathematician :)
22:17:05 <sauxdado> and clearly some kind of pervert :D
22:17:10 <Cale> heh
22:17:44 <dobblego> doesn't imagine himself that way
22:25:40 <Cale> actually, perhaps that first paren should be back a word
22:25:46 <sauxdado> yes
22:25:47 <Cale> (before the 'what')
22:26:03 <sauxdado> ...or something
22:26:39 <Cale> Now to untangle the logic :)
22:29:20 <bos> @hoogle Int -> Double
22:29:21 <lambdabot> No matches, try a more general search
22:30:52 <bos> @hoogle RealFrac
22:30:52 <lambdabot> Prelude.RealFrac :: class (Real a, Fractional a) => RealFrac a
22:44:23 <quicksil1er> byorgey++ # diagrams library
22:45:03 <dobblego> @check \x f g -> map (f . g) x == (map f . map g) x -- can you check the functor laws with lambdabot?
22:45:04 <lambdabot>   add an instance declaration for (Eq (f b))
22:45:16 <quicksil1er> only in specific cases
22:45:28 <quicksil1er> QC provides arbitrary data, given a type.
22:45:36 <dobblego> @check \x f g -> map (f . g) x == (map f . map g) (x :: [Int])
22:45:37 <lambdabot>  Add a type signature
22:45:37 <quicksil1er> it doesn't provide arbitrary types, given a kind :)
22:45:57 <dobblego> I want to check the [] case
22:46:24 <quicksil1er> it doesn't know the type of f, from that
22:46:27 <quicksil1er> could be Int -> Blah
22:46:44 <dobblego> @check \x f g -> map (f . g) x == (map (f :: Int -> Int) . map g) (x :: [Int])
22:46:47 <lambdabot>  OK, passed 500 tests.
22:46:51 <dobblego> @check \x f g -> map (f . g) x == (map (f :: Int -> Int) . map g) x
22:46:52 <lambdabot>   add an instance declaration for (Eq (f Int))
22:46:52 <dobblego> thanks
22:46:58 <dobblego> @check \x f g -> map (f . g) x == (map (f :: Int -> Int) . map g) (x :: [Int])
22:47:00 <lambdabot>  OK, passed 500 tests.
22:47:57 <povman> @pl tr_ x = trace (show x) x
22:47:57 <lambdabot> tr_ = trace =<< show
22:48:20 <povman> :t show
22:48:22 <lambdabot> forall a. (Show a) => a -> String
22:48:26 <povman> :t trace
22:48:28 <lambdabot> Not in scope: `trace'
23:14:08 <solrize> @seen luqui
23:14:08 <lambdabot> I saw luqui leaving #haskell and #perl6 14h 5m 26s ago, and .
