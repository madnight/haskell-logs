00:00:06 <solrize> > fmap (+1) $ return 5 :: Identity Int
00:00:08 <lambdabot>   add an instance declaration for (Show (Identity Int))
00:00:58 <newsham> Id a doesnt seem to be exported (or used!)
00:01:30 <newsham> err, I take that back, used in fmapDefault
00:01:41 <solrize> > runIdentity $ fmap (+1) $ return 5 :: Identity Int
00:01:42 <lambdabot>   add an instance declaration for (Num (Identity Int))
00:01:45 <solrize> hmm
00:02:10 <luqui> > runIdentity $ fmap (+1) $ (return 5 :: Identity Int)
00:02:11 <lambdabot>  6
00:02:47 <newsham> > getConst (Const 5 :: Const Int String)
00:02:49 <lambdabot>  5
00:02:50 <vixey> is there any implementation of views yet?
00:05:16 <newsham> > foldMapDefault Sum [3,2,6]
00:05:17 <lambdabot>   Not in scope: `foldMapDefault'
00:05:46 <newsham> > Data.Traversable.foldMapDefault Sum [3,2,6]
00:05:47 <lambdabot>  Sum {getSum = 11}
00:06:23 <newsham> > Data.Traversable.foldMapDefault Sum Nothing
00:06:25 <lambdabot>  Sum {getSum = 0}
00:10:57 <dolio> ndm has a blog from a year ago saying that view patterns are going into GHC.
00:11:22 <newsham> ?instances Data.Traversable.Traversable
00:11:23 <lambdabot> Maybe, []
00:11:30 <newsham> how come Tree isnt listed?
00:11:40 <dolio> http://www.cs.cmu.edu/~drl/pubs/lpj07views/lpj07views-anglohaskell.pdf
00:11:41 <lambdabot> http://tinyurl.com/5an3ah
00:12:01 <dolio> @instances-importing Data.Tree Data.Traversable.Traversable
00:12:01 <lambdabot> Maybe, Tree, []
00:12:27 <newsham> oh, that makes it import more stuff before querying?
00:12:36 <vixey> > let f x | x <- Nothing = 0 in f Nothing
00:12:36 <lambdabot>  Parse error at "<-" (column 13)
00:12:39 <vixey> >_<
00:13:18 <newsham> > Data.Traversable.foldMapDefault Sum (Tree 3 [Tree 4 []])
00:13:19 <lambdabot>   Not in scope: data constructor `Tree'
00:13:52 <newsham> > Data.Traversable.foldMapDefault Sum (Node 3 [Node 4 []])
00:13:53 <lambdabot>  Sum {getSum = 7}
00:14:03 <newsham> is there a way to get a more complete list of traversables?
00:14:15 <dolio> What's with the foldMapDefault?
00:14:32 <dolio> That's just for defining Data.Foldable.foldMap more easily.
00:15:14 <dolio> I imagine the actual docs will have a fairly complete list.
00:15:51 <newsham> Data.Traversable just says [] and Maybe
00:16:34 <dolio> Oh, I guess splitting base doesn't allow for that.
00:17:50 <newsham> hmm.. foldMapDefault is defined directly from traversable,  Foldable needs a seperate definition?
00:18:24 <newsham> (looking at foldMapDefault because its described in the applicative paper)
00:18:27 <dolio> foldMapDefault is for when you just want to define a Traversable instance, and then write 'instance Foldable Foo where foldMap = foldMapDefault'
00:19:04 <dolio> It's like defining a Monad instance and then using 'fmap = liftM ; (<*>) = ap ...'
00:19:05 <newsham> > foldMap Sum (Node 3 [Node 4 []])
00:19:06 <lambdabot>   Not in scope: `foldMap'
00:19:19 <newsham> > Data.Foldable.foldMap Sum (Node 3 [Node 4 []])
00:19:20 <lambdabot>  Sum {getSum = 7}
00:19:55 <newsham> didnt hear about Foldable until now
00:23:16 <newsham> > Data.Foldable.foldMap (:[]) (Node 3 [Node 4 []])
00:23:17 <lambdabot>  [3,4]
00:23:32 <newsham> > Data.Foldable.foldMap return (Node 3 [Node 4 []]) :: [Int]
00:23:33 <lambdabot>  [3,4]
00:24:15 <newsham> ?instances MonadPlus
00:24:15 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
00:36:19 <mxc> just out of curiosity, is there a list of planned additions in GHC 6.9?
00:52:00 <quicksilver> mxc: hints have been dropped in emails by Simon Marlow and Simon PJ
00:52:14 <quicksilver> mxc: (note that 6.9 is the working name of the branch which will be released as 6.10)
00:52:24 <quicksilver> mxc: and there are further hints to be found in the trac tickets.
00:52:32 <quicksilver> I'm not aware ofa  centralised in-one-place roadmap.
00:53:16 <sjanssen> major improvements to type families is one thing I've heard
00:53:24 <sjanssen> they'll actually be a supported feature
00:57:46 <vixey> type families are types indexed by tpyes?
00:58:12 <sjanssen> yes
00:58:18 <sjanssen> type functions, essentially
00:58:42 <vixey> can you make Fin with it ?
00:58:51 <quicksilver> I think simon marlow mentioned hoping to get codegen improvements into 6.10
00:59:11 <vixey> like Fin Z has zero elemnts, Fin S(Z) is (), Fin S(S(Z)) is Bool
01:01:04 <luqui> > x^(p-1) `mod` p
01:01:15 <lambdabot>  Exception: Time limit exceeded
01:03:23 <sjanssen> vixey: Fin?
01:03:54 <mxc> quicksilver - ty.  do the GHC developers have some sort of aversion to odd numbers?
01:03:59 <int-e> > p
01:04:00 <lambdabot>  p
01:04:05 <int-e> I see.
01:04:11 <Zao> mxc: odd/even unstable/stable
01:04:15 <luqui> > p == 0
01:04:16 <lambdabot>  False
01:04:21 <luqui> thus ^ didn't terminate...
01:04:26 <Zao> Much like Linux and other silly project.
01:04:28 <mxc> zao - ah.  interesting. had no idea
01:04:33 <int-e> > x^6 `mod` 7
01:04:35 <lambdabot>  x * x * (x * x) * (x * x) `mod` 7
01:04:56 <luqui> oh whaddya know, it uses a smart implementation of ^
01:04:59 <int-e> @src (^)
01:05:00 <lambdabot> Source not found. Just what do you think you're doing Dave?
01:10:49 <dmwit> Yup, it uses repeated squaring.
01:11:11 <dmwit> (So those (x * x) subterms are shared.)
01:14:47 <BeelsebobWork> Can anyone recommend some good reading on implementing type checking for classes?
01:15:15 <BeelsebobWork> I'm reading "Type Classes In Haskell", and finding it one of the harder papers to penetrate that I've ever read
01:16:02 <mxc> beelsebobwork - i can try to dig up some old quantum computation papers
01:16:20 <dmwit> Would that help?
01:16:20 <BeelsebobWork> mxc: :P the idea wasn't to find me something *harder* to read
01:16:20 <mxc> they wont make reading the haskell paper easier in absolute terms, but it will feel easier
01:17:12 <mxc> its the age old cure for pain on your right foot
01:17:17 <mxc> * leg
01:17:23 <mxc> get kicked in your other leg
01:18:40 <mxc> so, one system that i'm ocnsidering implementing in haskell involves processing about 20 or 30 different types of messages
01:19:00 <mxc> many of them sharing the same fields
01:19:12 <BeelsebobWork> giant pattern matching a-go-go
01:19:12 <BeelsebobWork> :P
01:19:15 <mxc> i was going to have a record type for each one
01:19:34 <mxc> but the rules on overlapping field names in the same module are making this a pain
01:20:04 <mxc> my options as I can think of it are:  declare each message record type in a separate module and use the ghc disambiguate fields flag
01:20:27 <mxc> but thats a pain becuase it creates all these unnecesary files and modules
01:20:30 <dmwit> BeelsebobWork: The key seems to be that you basically don't do type checking with classes. =P
01:20:31 <mxc> or, have a type like:
01:20:41 <BeelsebobWork> dmwit: yeh, I'd got that
01:20:45 <mxc> data Message = M1 {a:: Int...} | M2 {...} etc
01:20:48 <BeelsebobWork> convert it into a program with dictionaries instead
01:20:57 <BeelsebobWork> and then do HM
01:21:03 <mxc> but then, you lose the typechecking
01:21:09 <mxc> HM?
01:21:12 <mxc> hindley milner?
01:21:14 <BeelsebobWork> yep
01:21:24 <mxc> not sure what you mean
01:21:25 <dmwit> mxc: Did you know this is legal?
01:21:39 <dmwit> data Message = M1 { a :: Int } | M2 { a :: Int }
01:21:40 <BeelsebobWork> mxc: sorry, that was directed at dmwit
01:21:53 <mxc> dmwit - yes, but the problem with that is that they dont all have the same fiels
01:22:01 <dmwit> They don't have to.
01:22:09 <mxc> so if you have data Msg = M1 {a::Int} | M2 {b::String}
01:22:13 <dmwit> The only restriction is that fields with the same name have to have the same type.
01:22:19 <mxc> the type system would allow you to have:
01:22:25 <mxc> f :: Msg -> Int
01:22:30 <mxc> f x = a x
01:22:51 <mxc> but that would fail on:  f (M2{b="SADF"})
01:22:57 <dmwit> Oh, you want the compiler to protect you from that?
01:23:06 <dmwit> Have you heard of "Catch"?
01:23:08 <dmwit> ?where catch
01:23:08 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
01:23:19 <mxc> was lookign at that
01:23:20 <BeelsebobWork> alternatively, define a class for Messages
01:23:27 <BeelsebobWork> and a type for each kind of message
01:23:41 <BeelsebobWork> but that potentially involves a lot of duplicate code
01:24:02 <mxc> BeelsebobWork> yeah, and each record type has to be in its on module/file which is just kidn of frustrating
01:24:09 <BeelsebobWork> yep
01:24:20 <mxc> dmwit - would that catch those kind of errors?
01:24:26 <BeelsebobWork> yes
01:24:35 <BeelsebobWork> the point of catch is to find pattern matches that don't cover all cases
01:24:44 <BeelsebobWork> like the one you showed above
01:24:57 <dmwit> mxc: Catch guarantees that it either reports some error, or your program will never fail a pattern match.
01:25:08 <dmwit> (Both could be true.)
01:25:23 <dmwit> (But as I understand it, it's not too common.)
01:27:18 <mxc> is that considered a failed pattern match?
01:27:29 <mxc> <mxc> f :: Msg -> Int
01:27:29 <mxc> <mxc> f x = a x
01:27:42 <dmwit> Ah, hm.
01:27:44 <BeelsebobWork> oh, good point
01:27:49 <BeelsebobWork> ask ndm
01:28:55 <quicksilver> luqui, dmwit : whilst Expr uses repeated squaring for ^, funnily enough the fixed prelude doesn't.
01:29:09 <dmwit> Uh, what?
01:29:11 <dmwit> ?where Prelude
01:29:12 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
01:29:39 <dmwit> It does in *that* Prelude.
01:29:40 <luqui> quicksilver, (^) is an ordinary function, not a class function, so that's impossible
01:30:07 <dmwit> What do you mean by "fixed prelude"?
01:30:42 <sjanssen> quicksilver: the actual Prelude does
01:32:23 <sjanssen> > (2 :: Int) ^ (2 ^ 1024 :: Integer)
01:32:24 <lambdabot>  0
01:32:35 <hpaste>  luqui pasted "Repeated squaring test case" at http://hpaste.org/7982
01:33:00 <quicksilver> sjanssen: I did some investigation once which suggested that it didn't, for Integer at least.
01:33:05 <quicksilver> sjanssen: I can't remember the details :)
01:33:10 <luqui> so it is important for your Num instances to have an associative (*)! :-)
01:33:25 <quicksilver> sjanssen: see http://hackage.haskell.org/trac/ghc/ticket/1687
01:33:33 <lambdabot> Title: #1687 (A faster (^)-function.) - GHC - Trac
01:34:25 <luqui> maybe fixed in 6.8?
01:34:32 <dmwit> ?source Prelude
01:34:32 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
01:34:58 <sjanssen> quicksilver: GHC uses the repeated squaring algorithm, this bug just recommends a refinement
01:35:07 <dmwit> ?source GHC.Num
01:35:07 <lambdabot> GHC.Num not available
01:35:31 * quicksilver nods
01:35:36 <quicksilver> maybe I misremember then :)
01:37:13 <sjanssen> perhaps the current implementation doesn't use a convenient order?
01:39:02 <mxc> quicksilver, beelsebobwork - this is the match error that comes up:
01:39:03 <mxc> Test.exe: No match in record selector Main.x
01:39:26 <dmwit> You probably meant to aim that at me, not quicksilver.
01:39:43 <dmwit> I saw that error, too; but I'm not sure how YHC handles records.
01:40:03 <quicksilver> it's a runtime error
01:40:03 <dmwit> As BeelsebobWork said, you probably have to ask ndm to be sure.
01:40:03 <BeelsebobWork> same way nhc does
01:40:18 <quicksilver> ah, does catch catch it?
01:40:21 <quicksilver> I would guess so.
01:40:32 <quicksilver> I would guess that catch notes "a" as being partial
01:40:36 <dmwit> That would be my guess, too.  But it's only a guess.
01:40:39 <quicksilver> but you'd definitely have to ask ndm to be sure.
01:41:51 <quicksilver> or read the source :)
01:49:13 <ndm> ndm returns!
01:49:13 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
01:49:29 <ndm> @messages
01:49:30 <lambdabot> Botje said 11h 26m 14s ago: tiny nitpick about uniplate: transform is spelled wrong in the example on haddock (negLits = trasform f)
01:49:41 <ndm> @tell Botje many thanks!!!
01:49:42 <lambdabot> Consider it noted.
01:50:24 <ndm> mxc: yes, Catch will get those errors, easily :)
01:50:41 * mxc bows appreciatively
01:50:53 <mxc> i like the 'easily' bit
01:51:07 <kalven> GonadT
01:51:18 <ndm> mxc: you aren't even talking recursive complex stuff, its nothing more complex than something like head
01:51:23 <BeelsebobWork> ndm: does it work on the YHC core level then?
01:51:48 <ndm> BeelsebobWork: yes
01:52:52 <ndm> @where+ catch http://www.cs.york.ac.uk/~ndm/catch/
01:52:52 <lambdabot> Good to know.
01:53:01 <mxc> ndm you're kind of my semi-hero
01:53:13 <mxc> since, against my personal wishes, i have to do a lot of haskell on windows
01:53:24 <ndm> mxc: many thanks :)
01:53:26 <mxc> so thanks for making a rough situation tolerable
01:53:42 <ndm> yeah, still more planned improvements to come
01:53:44 <mikeday> is it possible to mark a pattern match as being exhaustive and have the compiler check that?
01:53:56 <ndm> mikeday: yes, with catch
01:54:47 <mikeday> it's a separate tool like lint, not part of the basic language though right?
01:55:41 <Botje> ndm: always happy to help *G*
01:55:41 <lambdabot> Botje: You have 1 new message. '/msg lambdabot @messages' to read it.
01:55:45 <mxc> mikeday - for simple matching, doesn't -W catch those/
01:56:24 <ndm> Botje: has now been fixed in the darcs version :)
01:56:35 <Botje> yay!
01:56:43 <ndm> -W checks that all patterns are exhaustive, not just some marked ones
01:56:50 <ndm> plus it doesn't flag head [] as inexhaustive
01:56:59 <ndm> plus it does flag some exhaustive ones as non-exhaustive
01:57:11 <mikeday> ah, -Wincomplete-patterns
01:57:29 <ndm> plus it encourages people to replace nice useful error messages with f _ = error "doh", which is really a bad idea
01:58:25 <mikeday> hmm, I like being able to add a new symbol to a type and be told exactly which patterns need to be changed
02:00:21 <glowwormy> Hi
02:00:27 <glowwormy> I got a question...
02:00:36 <glowwormy> I have a list of list of integers
02:00:45 <glowwormy> and want to do the following:
02:00:52 <ndm> mikeday: yeah, its a useful indication, just not really something that you want to over-fixate on
02:01:45 <glowwormy> I want to obtain a list of lists of integers where each sublist is given by merging the old list respecting the given order...
02:01:50 <glowwormy> e.g.:
02:02:28 <glowwormy> [[1,2], [3]] -> [[1,2,3], [1,3,2], [3,2,1]]
02:03:01 <glowwormy> I think I should use the list monad...
02:03:15 <glowwormy> but I still don't really understand monads....
02:03:24 <luqui> it is an enumeration problem, so I would agree that the list monad would probably help
02:03:39 <vixey> what bout [[1,2], [3,4]] ?
02:03:45 <vixey> what would it give
02:04:27 <opqdonut> [[1,2,3,4],[1,3,2,4],...]
02:04:29 <dmwit> [[1,2,3,4], [1,3,2,4], [1,3,4,2], [3,1,2,4], [3,1,4,2], [3,4,1,2]] -- my guess
02:04:36 <opqdonut> yeah
02:04:41 <vixey> There's a couple obvious choices
02:04:41 <glowwormy> yep...
02:05:20 <glowwormy> I can program this with recursion, but a I would prefer a short monad solution...
02:05:38 <luqui> glowwormy, it will probably be recursive anyway
02:05:47 <dmwit> I think you can do it without recursion.
02:05:53 <luqui> I would suggest programming it with recursion and then factoring bits of it into the list monad...
02:06:11 <dmwit> glowwormy: Have a look at tails/inits, those seem like they could be helpful here.
02:06:24 <dmwit> You'll probably want to get a function that merges just two lists working first.
02:06:43 <luqui> indeed, given that function you can inductively define the full one
02:06:57 <glowwormy> this is true.
02:07:11 <luqui> and that inductive definition is where the list monad will be your aid
02:07:20 <glowwormy> I agree.
02:07:28 <dmwit> Disagree.
02:07:36 <dmwit> The list monad will help with defining the merge function.
02:07:41 <dmwit> The inductive guy is just a fold.
02:07:52 <luqui> dmwit, it's a monadic fold, since you fold over each of the many results
02:08:01 <dmwit> mmm
02:08:04 <dmwit> That might be true.
02:08:09 <dmwit> I buy it. =)
02:08:24 <dmwit> But the list monad can help with the merge function, too.
02:08:47 <glowwormy> So I need it for both things...
02:09:15 <ndm> sounds like a simple combinatorics problem, and i find list monads make those less clear, but more concise4
02:09:58 <glowwormy> I would go for the concise version...
02:10:05 <dmwit> > let merge xs [] = xs; merge xs (y:ys) = do { (b, e) <- zip (inits xs) (tails xs); return (b ++ y : merge e ys) } in merge [1, 2] [3, 4]
02:10:06 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
02:10:06 <lambdabot>       Expected...
02:10:29 <dmwit> > let merge xs [] = return xs; merge xs (y:ys) = do { (b, e) <- zip (inits xs) (tails xs); return (b ++ y : merge e ys) } in merge [1, 2] [3, 4]
02:10:29 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
02:10:30 <lambdabot>       Expected...
02:10:34 <dmwit> blarg
02:10:56 <gour> hi, any pandoc user here?
02:11:12 <luqui> glowwormy, is this homework?
02:11:53 <glowwormy> No
02:12:19 <glowwormy> I am just doing my PhD an I am trying to get some work done with haskell
02:12:23 <dmwit> > let merge :: [a] -> [a] -> [[a]]; merge xs [] = return xs; merge xs (y:ys) = do { (b, e') <- zip (inits xs) (tails xs); e <- merge e' ys; return (b ++ y:e) } in merge [1, 2] [3, 4]
02:12:25 <lambdabot>  [[3,4,1,2],[3,1,4,2],[3,1,2,4],[1,3,4,2],[1,3,2,4],[1,2,3,4]]
02:12:30 <glowwormy> instead of calculating big examples by hand
02:12:55 <dmwit> Now let's see if we can prettify that...
02:13:05 <hpaste>  luqui pasted "Her'es my merge function" at http://hpaste.org/7983
02:13:28 * luqui is rather pleased with the appearance of his
02:13:53 <dmwit> Pretty!
02:14:17 <glowwormy> Yep, that's it for example.
02:14:48 <dmwit> :t foldM
02:14:51 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
02:14:55 <dmwit> :t mapM
02:14:56 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
02:15:22 <quicksilver> beware foldM!
02:15:34 <quicksilver> you risk make s <-> s' bugs.
02:15:40 <luqui> quicksilver, huh?
02:15:42 <dmwit> Yeah, I don't think I've ever successfully used foldM.
02:15:51 <quicksilver> mapM_ in a State monad is often safer.
02:16:05 <quicksilver> luqui: an s <-> s' bug is where you have a state and you accidentally use the old version
02:16:17 <luqui> foldM merge2 []  seems to do just what I want.
02:16:22 <quicksilver> or update the old version twice when you meant to update the intermediate version.
02:16:35 <quicksilver> yeah, I didn't mean it was wrong for your specific case.
02:16:40 <luqui> ah, ok
02:16:41 <quicksilver> it was a general admonition about foldM.
02:16:45 <vixey> > let splits = (inits &&& tails) in splits "flap"
02:16:47 <lambdabot>  (["","f","fl","fla","flap"],["flap","lap","ap","p",""])
02:17:10 <vixey> > let splits = uncurry zip (inits &&& tails) in splits "flap"
02:17:10 <lambdabot>  Couldn't match expected type `([a], c)'
02:17:18 <dmwit> > let splits = liftM2 zip inits tails in splits "flap" -- probably more useful
02:17:20 <lambdabot>  [("","flap"),("f","lap"),("fl","ap"),("fla","p"),("flap","")]
02:17:21 <vixey> > let splits = uncurry zipWith (,) (inits &&& tails) in splits "flap"
02:17:21 <lambdabot>  Couldn't match expected type `(a -> b -> c, [a])'
02:27:47 <glowwormy> Thank you very much.
02:27:50 <glowwormy> it works.
02:29:17 <vixey> > liftM2 zip inits tails "xyz"
02:29:19 <lambdabot>  [("","xyz"),("x","yz"),("xy","z"),("xyz","")]
02:29:49 <vixey> I don't understand
02:30:01 <vixey> why does GHC say No instance for (Monad ((->) [Char])) ?
02:30:45 <int-e> vixey: import Control.Monad.Instances
02:30:54 <luqui> @src foldM
02:30:54 <lambdabot> foldM _ a []     = return a
02:30:54 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
02:30:58 <vixey> oh ok thansk
02:31:01 <vixey> thanks
02:53:42 <vixey> :|
02:53:47 <johnlunney> :|
02:54:46 <BeelsebobWork> :|
02:54:52 <dmwit> > let merge [] ys = [ys]; merge xs ys = [(xs, ys), (ys, xs)] >>= \(a:as, bs) -> map (a:) (merge as bs) in merge [1,2] [3,4]
02:54:54 <lambdabot>  [[1,2,3,4],[1,3,4,2],[1,3,2,4],[3,4,1,2],[3,1,2,4],[3,1,4,2]]
02:55:03 <dmwit> Just don't call it with an empty second argument and you're golden. =)
02:55:11 <vixey> wow
02:55:33 <BeelsebobWork> > let merge [] ys = [ys]; merge xs ys = [(xs, ys), (ys, xs)] >>= \(a:as, bs) -> map (a:) (merge as bs) in merge [1,2],3,4 []
02:55:33 <lambdabot>   parse error on input `,'
02:55:35 <BeelsebobWork> fail
02:55:42 <BeelsebobWork> > let merge [] ys = [ys]; merge xs ys = [(xs, ys), (ys, xs)] >>= \(a:as, bs) -> map (a:) (merge as bs) in merge [1,2,3,4] []
02:55:43 <lambdabot>   Non-exhaustive patterns in lambda
02:55:45 <dmwit> I already noted that problem.
02:56:02 <vixey> > let merge [] ys = [ys]; merge xs [] = [xs]; merge xs ys = [(xs, ys), (ys, xs)] >>= \(a:as, bs) -> map (a:) (merge as bs) in merge [1,2,3,4] []
02:56:03 <lambdabot>  [[1,2,3,4]]
02:56:06 <dmwit> The cute thing is that it never calls *itself* with an empty second argument.
02:56:30 <vixey> that's really cool
02:56:52 <dmwit> It's based heavily on luqui's solution.
02:57:34 <vixey> @pl \xs ys->([(xs,ys),(ys,xs)]>>=)
02:57:34 <lambdabot> ((>>=) .) . ap (ap . ((:) .) . (,)) (flip flip [] . ((:) .) . flip (,))
02:57:50 <dmwit> heh
02:57:51 <BeelsebobWork> hahaha
02:59:19 <dmwit> ?pl \(x, y) -> [x, y]
02:59:19 <lambdabot> uncurry ((. return) . (:))
03:00:14 <dmwit> ?pl \(x, y) -> [(x, y), (y, x)]
03:00:14 <lambdabot> uncurry (ap (ap . ((:) .) . (,)) (flip flip [] . ((:) .) . flip (,)))
03:01:19 <dmwit> ?pl \(x, y) -> (y, x)
03:01:19 <lambdabot> uncurry (flip (,))
03:01:29 <dmwit> :t sequence [id, uncurry (flip (,))]
03:01:30 <vixey> :t (snd &&& fst)
03:01:32 <lambdabot> forall b. (b, b) -> [(b, b)]
03:01:32 <lambdabot> forall a b. (a, b) -> (b, a)
03:01:39 <vixey> ooh
03:01:52 <dmwit> :t sequence [id, snd &&& fst]
03:01:53 <lambdabot> forall b. (b, b) -> [(b, b)]
03:01:55 <vixey> sequence[fst&&snd,snd&&&fst]
03:02:28 <dmwit> Okay, I *really* have to go to bed now.
03:04:20 <dmwit> Oh!
03:05:41 <dmwit> > let merge xs ys = [xs ++ ys | any null [xs, ys]] ++ ([(xs, ys), (ys, xs)] >>= \(a:as, bs) -> map (a:) (merge as bs)) in merge [1,2] [3,4]
03:05:42 <lambdabot>   Non-exhaustive patterns in lambda
03:06:20 <dmwit> > let merge xs ys = [xs ++ ys | any null [xs, ys]] ++ ([(xs, ys), (ys, xs) | all (not . null) [xs, ys]] >>= \(a:as, bs) -> map (a:) (merge as bs)) in merge [1,2] [3,4]
03:06:20 <lambdabot>  Parse error at "|" (column 74)
03:07:01 <dmwit> heh, oh well
03:07:30 <dmwit> Fixable, but not worth it.
03:10:21 <MedeaMelana> testing
03:10:33 <MedeaMelana> hrm
03:18:17 <mm_freak_work> is (STUArray s Int Bool) a bit-field?
03:18:33 <mm_freak_work> i mean, from the performance standpoint
03:23:16 <mbz> hiya
03:28:30 <Armored_Azrael> Hey, anyone know how to call haskell from C inside a shared object file?
03:35:03 <vixey> flip concatMap
03:35:25 <vixey> 'a geek if there ever was one, the kind of person who thinks that labelling a cat lying on its back "flip concatMap" and things like that are fun'
03:45:15 <skorpan> i never really got why it's concatMap and not just concat?
03:45:30 <jaj> @type flip concatMap
03:45:33 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
03:45:36 <jaj> @type flip concat
03:45:38 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `[a]'
03:45:39 <lambdabot>     Probable cause: `concat' is applied to too many arguments
03:45:39 <lambdabot>     In the first argument of `flip', namely `concat'
03:45:50 <skorpan> oh..
03:46:21 <skorpan> but the only thing in "concatMap" making up the joke is the "cat" part, right?
03:46:53 <vixey> (>>=) = flip concatMap
03:47:03 <mattam> maybe Map ~ nap ?
03:47:09 <vixey> haha
03:51:50 <byorgey> are you referring to this? http://arcanux.org/lambdacats/concatMap.jpg  =)
03:52:08 <byorgey> hi mbz
03:52:59 <mm_freak_work> i didn't expect the code to run that fast…  i have written a sieve of eratosthenes using STUArray, and it's amazingly fast
03:53:11 <mm_freak_work> compares well to its C counterpart
03:54:49 <luqui> STUArray is great at what it does
03:56:28 <hpaste>  mm_freak pasted "STUArray sieve of eratosthenes" at http://hpaste.org/7984
03:56:34 <mm_freak_work> if anyone cares =)
03:56:35 <vixey> byorgey! yes!
03:57:10 <byorgey> well, guilty as charged =)
04:06:32 <luqui> mm_freak_work, even cooler is the fact that it is devoid of strictness annotations!  (I think the one on "m" is superfluous; it will be evaluated immediately)
04:07:02 <luqui> (unless you have benchmarks indicating otherwise)
04:07:52 <mm_freak_work> luqui: i have, and it does make a difference
04:08:23 <mm_freak_work> i think, it builds the list lazily in a takeWhile fashion, and i'm unboxing the m, so the comparison goes faster
04:12:19 <luqui> mm_freak_work, yeah, I just repeated it and have reproduced the difference.  I'm trying to dig my way through the core to confirm your theory.
04:12:26 <luqui> (and to learn how to dig through core)
04:18:11 * luqui fails and gives up
04:18:35 <mm_freak_work> luqui: you're looking for enumFromThenTo in: instance Enum Int
04:18:59 <osfameron> hi luqui :-)
04:19:28 <mm_freak_work> should be in the Prelude
04:22:46 <ndm> mm_freak_work: most of those instances are actually in GHC.*, which is then imported into the Prelude
04:23:51 <mm_freak_work> ndm: i don't know the implementation details of GHC…  yet, to say
04:24:38 <mm_freak_work> somehow it's very hard in haskell to write incorrect code…  either it works, or it doesn't compile =)
04:24:48 <ndm> mm_freak_work: its a lot of work to learn! just trying to help before people search the Prelude, which gets very confusing
04:25:57 <mm_freak_work> ndm: honestly, for now i don't really care, as long as things make sense to me…  not to be ignorant, but i'm very impatient at such things =)
04:27:14 <frwmanners> could anyone point me towards solving strictness problems in the State Monad?
04:28:10 <mm_freak_work> frwmanners: you know that the State monad isn't strict, do you?
04:28:23 <frwmanners> mm_freak_work: yes.  That's the problem
04:28:54 <atp> if you're sure that's the problem you can make things strict with seq and $! where necessary
04:28:58 <mm_freak_work> frwmanners: if you need strictness, use 'seq' or strictness annotations properly
04:29:08 <mm_freak_work> if the whole execution should be strict, use the ST monad
04:29:28 <frwmanners> mm_freak_work: That's probably what I'm after; how do I get the same functionality with that?
04:30:08 <frwmanners> mm_freak_work: trouble is, I'm trying to do loads of operations on the state monad sequentially, and so it stack overflows
04:30:20 <frwmanners> mm_freak_work: sort of like a giant foldM
04:31:58 <mm_freak1work> well, the correct way is not to use it, but that probably isn't the answer you're looking for
04:32:14 <frwmanners> mm_freak_work: how so?
04:32:33 <mm_freak1work> as said, if you need strict execution, use ST instead of State
04:33:01 <frwmanners> ok; but can I get back inside a put - get like thing with ST?
04:33:09 <mm_freak1work> btw, if it stack-overflows, then ST won't help…  it's not strictness, what is your problem, but recursion
04:33:30 <mm_freak1work> the equivalent would be using STRef
04:34:24 <frwmanners> Thanks; I'll give it a go.
04:35:54 <mm_freak1work> well…  reconsider your problem…  a lot of things, which appear to need state, in fact don't
04:36:06 <mm_freak1work> maybe there is a more functional solution
04:37:29 <luqui> hello osfameron :-)
04:39:06 <osfameron> luqui: nice to read your last post - I thought you'd moved entirely into the haskell fold ;-)
04:39:50 <byorgey> isn't there a strict variant of the State monad?
04:40:09 <byorgey> Control.Monad.State.Strict
04:40:30 <luqui> osfameron, pretty much... but I still like PL stuff in general.
04:40:37 <mm_freak1work> indeed, there is one
04:40:46 <mm_freak1work> but what's strict about it?
04:41:03 <byorgey> so why wouldn't that help with frwmanners's issue?
04:41:12 <byorgey> ...the state?
04:41:13 <mm_freak1work> well, i didn't know about it =)
04:41:31 <byorgey> ah =)
04:41:55 <luqui> osfameron, it was nice to see a Moose exposition; I never really got into that
04:42:11 <byorgey> it ensures that the current state is always evaluated, rather than building up a big thunk
04:42:25 <osfameron> luqui: yeah, tbh neither have I... I totally believe it's cool and readable and what Perl dev ought to be, but I haven't found chances to use it in anger in paid work yet...
04:42:40 <osfameron> so the slides on it were a bit lame (ripped from the perldocs)
04:42:42 <byorgey> if makes a difference if you're doing a bunch of operations only updating the state, and not reading its value
04:43:34 <mm_freak1work> byorgey: yeah, that's indeed interesting
04:43:47 <frwmanners> byorgey: I'm kind of doing both; does it still help?
04:44:02 <quicksilver> mm_freak1work: I don't understand how you think ST is "more strict" than State?
04:44:08 <osfameron> luqui: I keep on meaning to try to get into pugs now that I've played a bit with haskell, but I seem to find other things to do with my tuits :-(
04:44:16 <mm_freak1work> maybe i could implement the sieve of eratosthenes again, using Integer, Data.Bits and strict State
04:44:18 <byorgey> frwmanners: it might.  it depends on exactly why you're having trouble.
04:44:53 <jaj> byorgey: is that your concatMap picture?
04:45:01 <byorgey> frwmanners: but if you already have something implemented in terms of State, all you need to do is change the import Control.Monad.State to Control.Monad.State.Strict
04:45:14 <byorgey> and see if it helps
04:45:16 <mm_freak1work> quicksilver: strict 'execution'
04:45:16 <quicksilver> frwmanners: I agree with byorgey, just switch to strict state
04:45:25 <frwmanners> byorgey: Ok.  Thanks.
04:45:29 <mm_freak1work> the binding operator is strict in ST
04:45:38 <vixey> how is it possible to have some things strict in haskell?
04:45:40 <Peaker> any convenient way to organize my .hs files somewhere so that ghc finds them when they're imported -- and they sit in a directory revisioned by a dvcs?
04:45:50 <byorgey> jaj: well, I didn't take the picture, but I put the words on it
04:46:03 <quicksilver> mm_freak1work: what you say is meaningless.
04:46:26 <mm_freak1work> quicksilver: what am i missing?
04:46:34 <quicksilver> mm_freak1work: the "sideeffects" of unboxed array update are strict, sure.
04:46:38 <byorgey> vixey: with the magical, special compiler-supported 'seq' primitive =)
04:46:42 <quicksilver> but that's not relevant to this case.
04:46:51 <jaj> byorgey: I was wondering if I could copy it
04:46:52 <quicksilver> STRefs aren't strict any more than IORefs are, AFAIK.
04:47:04 <vixey> but how does it work?
04:47:21 <byorgey> jaj: if you have viewed it on your computer, you have already made a copy =)
04:47:34 <jaj> byorgey: right :)
04:47:35 <byorgey> perhaps several
04:47:35 <quicksilver> ST is really IO. IO is only "strict" insofar as it sequences effects.
04:47:50 <quicksilver> however, ST doesn't have many effects.
04:47:54 <luqui> osfameron, yeah.. pugs is a mess though.  It's almost abandoned now in favor of rakudo, isn't it?
04:48:03 <luqui> (I'm hardly following the perl6 scene)
04:48:05 <quicksilver> so the "strictness" is only really visible in the array stuff, as far as I can think.
04:48:25 <byorgey> vixey: seq _|_ b = _|_ ; seq _ b = b
04:48:40 <mm_freak1work> quicksilver: i'm sure, frwmanners' problem isn't strictness anyway
04:48:58 <byorgey> vixey: so seq a b  has to force evaluation of a (to the first constructor) before returning b
04:48:59 <osfameron> luqui: I don't really know.  Perl 6 language discussions started making me cry.  I thought that Pugs was still the most complete implementation though?  But I hear more about peopl actually working on rakudo these days
04:49:06 <quicksilver> vixey: "a `seq` b" means "when you are asked to evaluate this expression return the value of b but *first* reduce a to WHNF"
04:49:18 <vixey> > case last [1..] of _ -> True
04:49:20 <lambdabot>  True
04:49:28 <vixey> > last [1..] `seq` True
04:49:33 <lambdabot> Terminated
04:49:53 <vixey> sooo......
04:50:00 <vixey> You could implement seq using generics?
04:50:19 <vixey> seq True b = b ; seq False b = b
04:50:32 <vixey> seq [] b = b ; seq (_:_) b = b
04:50:40 <vixey> are these kind of valid?
04:51:01 <frwmanners> Nope; strict state doesn't make a difference
04:52:59 <luqui> osfameron, yeah, it probably still is the most complete.  The whole process just started to bug me... they're implementing the full compiler in freaking parrot assembly as a "decision from above", rather than in Perl 6 with a bootstrap which was the whole point... sigh... anyway haskell is cool :-)
04:52:59 <vixey> what about seq :: (a -> b) -> x -> x ?
04:53:31 <vixey> I guess lambda terms are WHNF
04:54:04 <vixey> luqui; there is elf which is neat
04:54:16 <luqui> vixey, many folks would like seq to be a typeclass.
04:54:28 <vixey> luqui; it's a bootstrapping (subset of)p6->p5 compiler
04:54:41 <Peaker> where does ghc look for .hs libraries?
04:54:53 <quicksilver> frwmanners: did you already paste you code?
04:55:02 <quicksilver> frwmanners: are you compiling with optimisation?
04:55:10 <frwmanners> quicksilver: no and yes
04:55:38 <osfameron> luqui: iirc the parrot assembly seemed fairly high-level and using what look very much like Perl6 grammars.  But I'm not sure I'm parsing that correctly?  The pugs compiler is still haskell+parsec right?
04:55:50 <quicksilver> frwmanners: paste some code or give some more details about the problem ;)
04:55:56 <frwmanners> quicksilver: there's rather a lot of irrelevnt code in total; how much should I paste?
04:56:28 <malebria> Good morning.
04:56:33 <malebria> http://hpaste.org/7920
04:56:45 <malebria> I still don't get why the type declaration is necessary.
04:57:14 <mm_freak1work> frwmanners: as said, your problem likely isn't strictness
04:57:21 <quicksilver> malebria: because that's how HM-Damas type inference works.
04:58:03 <malebria> quicksilver: Where can I get doc about this?
04:58:45 <luqui> osfameron, yeah really it's not that far off from a high level language.  A main point for implementing it in itself is that the people who are most likely to hack on the compiler are people who know perl really really well.  Making them use something other than their favorite language seems silly.  (also improvements to the compiler improve the compiler, the standard bootstrap benefit)
04:58:49 <hpaste>  frwmanners pasted "Strict(?) State Problem" at http://hpaste.org/7985
04:59:43 * luqui realizes that his ranting should probably be in #perl6
05:00:02 <frwmanners> mm_freak1work: optimizeRoutine gets given a massive list of parameters for optimizeToDepthSt to deal with; but if the list is too large it breaks.
05:00:33 <quicksilver> malebria: read about the monomorphism restriction
05:00:38 <frwmanners> mm_freak1work: the State is to deal with a RandomGen being passed around the place
05:00:39 <ToRA> > case ((\x -> x)undefined) of _ -> 3
05:00:41 <lambdabot>  3
05:00:48 <ToRA> > (\x -> x)undefined `seq` 3
05:00:49 <lambdabot>  Exception: Prelude.undefined
05:00:54 <quicksilver> malebria: http://www.haskell.org/haskellwiki/Monomorphism_restriction
05:00:55 <lambdabot> Title: Monomorphism restriction - HaskellWiki
05:00:59 <mm_freak1work> frwmanners: oh well…  code is much more readable with type signatures
05:01:20 <mm_freak1work> but i'll try to infer myself
05:01:23 <frwmanners> mm_freak1work: ah; sorrry, top level only
05:01:25 <ToRA> i thought case forced the scrutinee to whnf?
05:01:27 <malebria> quicksilver: thanks..
05:02:56 <frwmanners> mm_freak1work: thanks
05:03:23 <quicksilver> frwmanners: what kind of "breaks" ?
05:04:29 <mm_freak1work> frwmanners: are you sure your problem is related to state at all?
05:04:43 <mm_freak1work> what does the randomPermute function do, and how does it work?
05:04:54 <frwmanners> quicksilver: Stack overflow when the list is about 1000000 long
05:04:55 <EvilTerran> ToRA, not quite - it forces the scrutinee far enough to tell if it matches each pattern in turn
05:05:15 <Peaker> you can use -Wall to have ghc generate most of your type signatures. sometimes you'll need to specify more specific types or fix type aliases but they're mostly correct
05:05:17 <frwmanners> mm_freak1work: Takes, in theory, a random permutation of a list.  I'll paste it
05:05:22 <ketil> @seen
05:05:23 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
05:05:26 <ketil> Hmm..
05:05:29 <EvilTerran> so, if the first pattern is "x" or "_", it won't even force as far as WHNF
05:05:30 <ToRA> EvilTerran: yeah, i guess i've spent too much time looking at core and forgotten haskell :)
05:05:42 <vixey> why seq though
05:05:47 <quicksilver> frwmanners: OK, that's not a strictness error. It's a stack overflow :)
05:05:53 <EvilTerran> but, if the pattern's something like ([1,2,3],Just True) it'll force a lot further than WHNF :P
05:06:05 <quicksilver> frwmanners: whilst they are related in some sense they're not really the same thing.
05:06:16 <hpaste>  frwmanners pasted "utils for previous post" at http://hpaste.org/7986
05:06:59 <quicksilver> vixey: why that name? or why have it at all?
05:07:07 <EvilTerran> ToRA, oh - is that how the "case" in Core works?
05:07:07 <frwmanners> quicksilver: Right.  I thought it was the same thing you get when you do foldl (+) [1..1000000]
05:07:16 <mm_freak1work> frwmanners: for the future, i really recommend writing type signatures…  it's a bit more work, but it certainly pays off
05:07:30 <vixey> I meant as opposed to a function that forces WHNF, but of course .. that would not work
05:07:30 <frwmanners> mm_freak1work: sure; sorry.
05:07:32 <vixey> so seq makes sense
05:07:45 <quicksilver> EvilTerran: yes, core case always forces.
05:07:48 <radix> Cale: Hi. Thanks for the comment and wiki page :-)
05:07:49 <mm_freak1work> frwmanners: try to replace randomPermute by a trivial function, which alters the list in a trivial way
05:07:54 <ToRA> EvilTerran: yeah, so for somethign that goes "further" than whnf you'll end up with nested cases
05:07:56 <mm_freak1work> see if that fixes the stack overflow problem
05:08:16 <frwmanners> mm_freak1work: Ok.  Presumably it needs to alter it sufficiently that it doesn't get shared
05:08:23 <EvilTerran> that makes a lot of sense
05:08:30 <MedeaMelana> then case of _ -> doesn't translate to a core case at all?
05:08:46 <ToRA> indeed
05:09:01 <ToRA> though core has a case x of DEFAULT ->
05:09:11 <ToRA> which is basically seq
05:09:18 <frwmanners> mm_freak1work: I may have to get back at some later time on this one.  Thanks a very great deal
05:09:21 <frwmanners> to everyone
05:09:55 <mm_freak1work> frwmanners: have a look at your randomList function
05:10:03 <mm_freak1work> make it strict in its first paramter
05:10:17 <mm_freak1work> (or use a fold)
05:10:39 <frwmanners> mm_freak1work: how can this be linked to the size of the list parsed to the optimizeRoutine function?
05:10:59 <frwmanners> mm_freak1work: In theory, it should just be doing one thing after another
05:11:06 <quicksilver> hmm
05:11:11 <quicksilver> randomList is building up very big thunks
05:11:13 <quicksilver> that could be it
05:11:18 <mm_freak1work> i didn't throroughly analyze your code, but it seems like you generate a permutation by zipping with randoms and sorting
05:11:27 <frwmanners> mm_freak1work: ya
05:11:39 <quicksilver> do you make very big randomLists ?
05:11:43 <quicksilver> that could stack overflow
05:11:55 <frwmanners> quicksilver: should but up to about 2000
05:12:01 <quicksilver> bah 2000 is nothing.
05:12:06 <quicksilver> that won't overflow your stack.
05:12:26 <mm_freak1work> frwmanners: so your randomList gets just as large as the list feeded into randomPermute
05:12:37 <quicksilver> still, it seems likely that massive thunks around Gens could be the problem
05:13:31 <frwmanners> quicksilver: That's what made me think I could fix it in the State monad where they are stored
05:13:39 <frwmanners> quicksilver: the Gens, that is
05:13:43 <quicksilver> except you're not consistently storing them there
05:13:52 <quicksilver> most of your functions just operate on them as parameters
05:13:53 <mm_freak1work> frwmanners: it's not the Gens themselves, it's what you generate from them
05:14:17 <frwmanners> Right
05:14:29 <frwmanners> How does that fix itself
05:14:49 <Peaker> @hoogle Word8 -> Char
05:14:50 <lambdabot> Data.ByteString.Internal.w2c :: Word8 -> Char
05:14:59 <Peaker> Can I assume that I am not supposed to import an Internal module?
05:15:29 <quicksilver> well it's probably not the right solution
05:15:30 <quicksilver> :)
05:15:38 <quicksilver> fromEnum . fromIntegral
05:16:01 <EvilTerran> betweEnum = toEnum . fromEnum
05:16:01 <quicksilver> > (fromEnum . fromIntegral $ (65 :: Word8)) :: Char
05:16:02 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
05:16:07 <quicksilver> > (toEnum . fromIntegral $ (65 :: Word8)) :: Char
05:16:09 <lambdabot>  'A'
05:16:14 <quicksilver> sorry, toEnum . fromIntegral :)
05:16:23 <Armored_Azrael> Anyone know how to get haskell into a shared object file?
05:16:30 <Peaker> thanks
05:17:13 <Peaker> If I have an image represented as [[Color]] where type Color = (Word8, Word8, Word8) -- is it efficient to map it with (toEnum . fromIntegral) to write to a file?
05:17:37 <Armored_Azrael> It appears to be able to compile to dll, is there no POSIX-style equivalent?
05:18:28 <quicksilver> Peaker: why not "just write" the Word8s?
05:18:32 <quicksilver> Peaker: that makes more sense.
05:18:53 <Peaker> quicksilver, I can? I thought the writers take a String
05:18:58 <quicksilver> Armored_Azrael: posix doesn't mandate executable formats.
05:19:07 <quicksilver> Peaker: I recommend using the writers from Bytestring
05:19:16 <quicksilver> which take bytestrings (which you can pack from [Word8])
05:19:23 <Peaker> oh..
05:19:28 <Peaker> @hoogle [Word8] -> ByteString
05:19:28 <lambdabot> Data.ByteString.pack :: [Word8] -> ByteString
05:19:28 <lambdabot> Data.ByteString.Lazy.pack :: [Word8] -> ByteString
05:20:07 <Peaker> @hoogle Handle -> ByteString
05:20:08 <lambdabot> No matches, try a more general search
05:20:09 <Armored_Azrael> quicksilver: OK, I'm sorry. I am however looking for ELF shared objects (it was only a guess they were part of posix). Is there a way to do this?
05:20:11 <quicksilver> Armored_Azrael: nonetheless it's probably possible to compile to local shared libs formats for a given OS but I certainly don't know how mysel.
05:21:02 <Peaker> how can I write a ByteString to a file?
05:21:14 <Syzygy-> Armored_Azrael: http://www.haskell.org/haskellwiki/GHC/Using_the_FFI this page has an example of calling Haskell from C. Working with that should enable you to call things inside Haskell-built object files from C-coded files. Thus, you should be able to compile shared objects "in the usual manner" - whatever that normally is...
05:21:15 <lambdabot> Title: GHC/Using the FFI - HaskellWiki
05:21:22 <quicksilver> Peaker: read the bytestring docs :)
05:23:18 <Syzygy-> And you do have -fPIC as argument to GHC - which with a subsequent call to ld -shared -soname libfoo.so -o libfoo.so -lc foo.o should do what you need.
05:25:08 <Armored_Azrael> Syzygy: I'll give that a shot... I was mostly under the interpretation that the .a files required for the rts would make this sad, but I'l try it
05:25:44 <Peaker> @pl doesn't work on tuple pattern matches?
05:25:44 <lambdabot> (line 1, column 39):
05:25:44 <lambdabot> unexpected end of input
05:25:44 <lambdabot> expecting white space or simple term
05:25:52 <Peaker> @pl f (r, g, b) = [r, g, b]
05:25:53 <lambdabot> (line 1, column 13):
05:25:53 <lambdabot> unexpected "="
05:25:53 <lambdabot> expecting variable, "(", operator or end of input
05:26:12 <vixey> @pl \ (r, g, b) -> [r, g, b]
05:26:12 <lambdabot> (line 1, column 8):
05:26:12 <lambdabot> unexpected ","
05:26:12 <lambdabot> expecting letter or digit, operator or ")"
05:26:12 <lambdabot> ambiguous use of a non associative operator
05:26:31 <vixey> @pl \ x -> case x of (r, g, b) -> [r, g, b]
05:26:31 <lambdabot> (line 1, column 28):
05:26:31 <lambdabot> unexpected ">" or "-"
05:26:31 <lambdabot> expecting variable, "(", operator or end of input
05:26:50 <quicksilver> @pl \(x,y) -> x
05:26:51 <lambdabot> fst
05:26:55 <quicksilver> just 2-tuples
05:27:39 <SamB_XP> @hoogle (a, b, c) -> a
05:27:39 <lambdabot> No matches, try a more general search
05:27:43 <quicksilver> JaffaCake: Armored_Azrael is wondering if you can compile haskell code to a .so under linux (to dynamically link with C code, I guess)
05:27:49 <SamB_XP> quicksilver: do you suppose that might be why?
05:28:02 <quicksilver> SamB_XP: yes, although it doesn't really excuse the parse errors :P
05:28:11 <SamB_XP> quicksilver: true enough
05:29:02 <JaffaCake> quicksilver: probably not, although we have some experimental support for PIC and we are hopefully planning to get it working for 6.10
05:29:07 <Peaker> why are there 3-tuples, why doesn't Haskell only have 2-tuples, such that you can concat them into bigger tuples?
05:29:17 <Peaker> (a, b, c) being equivalent to (a, (b, c)) or so
05:29:28 <SamB_XP> Peaker: lifting?
05:29:41 <Peaker> SamB_XP, what about lifting?
05:29:51 <JaffaCake> it might be possible to link all the libraries together into a single .so with no PIC, I don't know
05:30:02 <vixey> Peaker define data a :*: b = a :*: b
05:30:05 <SamB_XP> Peaker: (1, _|_)
05:30:10 <smg> mh.
05:30:36 <smg> is there a book about types, pure and not-pure, strictness, evaluation strategies in functioanl programming languages like haskell? i won't find one :|
05:30:39 <Peaker> SamB_XP, what's wrong with allowing that though?
05:30:41 <luqui> Peaker, also, try to define a Show instance that works the way you expect.
05:31:04 <pejo> smg, TAPL is the standard book about type theory stuff.
05:31:07 <SamB_XP> luqui: obviously such a thing would involve changing Show
05:31:12 <quicksilver> Armored_Azrael: did you see that answer from JaffaCake ?
05:31:28 <quicksilver> Peaker: because it's convenient, that's all.
05:31:39 <Armored_Azrael> quicksilver: Yes
05:31:45 <luqui> SamB, you mean to take some sort of extra parameter or something?
05:31:53 <Peaker> quicksilver, but if (a, b, c) in a type or value is equivalent to (a, (b, c)) then you don't lose the convenience..?
05:31:58 <quicksilver> it's true that (a,(b,c)) and (a,b,c) are not quite the same but I don't think that's the *reason*.
05:32:02 <SamB_XP> luqui: I was thinking more like an extra method...
05:32:12 <luqui> gross...
05:32:33 <Armored_Azrael> quicksilver: I'm going to give it a shot--see if ld and ar can do some magic to decompose the original libraries and re-link them -fPIC, though improbable. Otherwise, I have to write some kind of command structure in C to issue commands to the haskell program
05:32:35 <SamB_XP> that's how we handle String!
05:32:42 <luqui> that is also gross :-)
05:32:50 <Armored_Azrael> quicksilver: It kind of has to be a shared object, as it's supposed to be a module for postgresql
05:32:58 <quicksilver> Armored_Azrael: ah, interesting.
05:33:08 <Peaker> luqui, how do you handle Show for a data constructor that takes 2 args and is used to compose a sequence?
05:33:24 <quicksilver> Peaker: oh, you mean why not pretend one is sugar for the other?
05:33:30 <quicksilver> Peaker: yes, in that case the reason is the bottoms.
05:33:31 <Peaker> quicksilver, yeah
05:33:38 <Peaker> quicksilver, what about the bottoms?
05:33:39 <smg> pejo: is in this book also "calculation of free and bounded variables"?
05:33:49 <quicksilver> (a,(b,c)) has more values than (a,b,c)
05:33:55 <quicksilver> one more value, to be precise.
05:34:06 <Peaker> quicksilver, why is that a problem though?
05:34:07 <SamB_XP> quicksilver: no, it has many more
05:34:13 <SamB_XP> as many values as a has
05:34:19 <quicksilver> SamB_XP: ah, yes one more "family" :)
05:34:35 <quicksilver> Peaker: because it makes your langauge non-uniform with some extremely odd edge cases
05:34:40 <quicksilver> for zero benefit :)
05:34:40 <JaffaCake> quicksilver, Armored_Azrael: http://hackage.haskell.org/trac/ghc/wiki/DynamicLinking
05:34:42 <lambdabot> Title: DynamicLinking - GHC - Trac
05:34:51 <JaffaCake> also http://hackage.haskell.org/trac/ghc/wiki/SharedLibraries
05:34:52 <lambdabot> Title: SharedLibraries - GHC - Trac
05:34:54 <Armored_Azrael> JaffaCake: Thanks
05:35:02 <SamB_XP> Peaker: well, it would allow those things to work in @pl
05:35:03 <SamB_XP> er.
05:35:05 <SamB_XP> quicksilver:
05:35:08 <quicksilver> ;P
05:35:12 * SamB_XP HATES doing that
05:35:32 <Peaker> quicksilver, I think it has some benefit.. define tuples to be an instance of your class once and you win, for example :)  Maybe you could even have a (a, a, a, ...) -> [a] function for any n-tuple easy to generate in that case?
05:35:38 <smg> pejo: still in?
05:35:38 <vixey> Peaker define data a :*: b = a :*: b
05:35:44 <vixey> Peaker, this solves your problem
05:35:59 <Peaker> vixey, I don't want to use that in place of tuples everywhere
05:36:04 <vixey> Peaker, why?
05:36:13 <SamB_XP> responding to someone but addressing my response to whomever they had addressed their message TO...
05:36:25 <vixey> Peaker, this is exactly what you are asking for but it doesn't use (,,,) syntax
05:36:26 <Peaker> vixey, I'd still have to use tuples where I interact with existing code - others will want to read my code, and :*: is cumbersome to use :)
05:37:07 <SamB_XP> vixey: he can't exactly change everyone else's code to use :*:
05:37:12 <vixey> you really think one data structure will baffle someone reading your code?
05:37:24 <vixey> a program usually defines a lot more than that
05:37:29 <SamB_XP> vixey: with that name in particular? yes!
05:37:36 <SamB_XP> vixey: that name used to be magical
05:37:43 <smg> the book i am looking for should cover: types, pure and not-pure, strictness, evaluation strategies, computation of free and bound variables, preferably in haskell, is there something pejo?
05:37:56 <luqui> SamB, oh yeah?  for what?
05:38:12 <SamB_XP> I never rightly understood it
05:38:17 <Peaker> vixey, I believe code should be uniform.. I am a great fan of Python due to that
05:38:23 <vixey> Python is terrible
05:38:25 <Peaker> vixey, uniform where possible, that is
05:38:25 <vixey> :*: is not cumbersome to use
05:39:02 <pejo> smg, sorry, doing a few other things at the same time. I'm not sure you can find a single comprehensive thing that covers exactly what you're looking for.
05:39:13 <pejo> @where tapl
05:39:13 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
05:39:18 <smg> k
05:39:19 <vixey> @go popl
05:39:19 <lambdabot> http://www.cs.ucsd.edu/popl/08/
05:39:19 <lambdabot> Title: POPL 2008
05:39:21 <Peaker> vixey, (a, b, c) is probably less cumbersome than a :*: b :*: c -- and again, I still get tuples from everywhere else, etc
05:39:37 <smg> i need a good book to calculate the types of expressions AND to calculate bound/free variables
05:39:42 <Peaker> vixey, not to mention lambdabot and other utilities don't know about this type... uniformity has many advantages
05:40:01 <SamB_XP> smg: in what setting?
05:40:01 <vixey> smg: start by learning what free and bound variables are
05:40:17 <vixey> smg: computing them is trivial once you know that
05:40:45 <SamB_XP> I kinda like de bruijn numbering, due to the catastrophic failure if you get it wrong
05:40:51 <Peaker> vixey, I agree certain aspects of Python are terrible, btw, but the fact you can just pick up any piece of Python code anywhere and understand it is pretty nice -- because of use of similar constructs for similar purposes
05:40:57 <smg> mh SamB_XP in haskell :)
05:41:04 <MedeaMelana> vixey: if only that were true for all things :-P
05:41:09 <vixey> SamB,
05:41:10 <vixey>        n : Nat           i : Fin n     f, a : Lam n    b : Lam (s n)
05:41:11 <vixey> data ----------- where -------------  ---------------  -------------
05:41:11 <vixey>       Lam n : *        var i : Lam n  app f a : Lam n  abs b : Lam n
05:41:33 <SamB_XP> vixey: you seem to have forgot the parentheses
05:41:41 <SamB_XP> that code is not valid Epigram like that
05:41:57 <vixey> never claimed it was valid
05:41:59 <vixey> :p
05:42:22 <vixey> you can do this in Haskell using nested type, Maybe instead of Fin
05:42:34 <vixey> it's pretty cool
05:42:56 <ketil> @hoogle Control.Parallel
05:42:57 <lambdabot> No matches, try a more general search
05:42:58 <SamB_XP> that sounds disgusting
05:43:10 <vixey> not realy
05:43:15 <SamB_XP> the Haskell way, I mean
05:43:16 <smg> vixey, SamB, pejo: is this stuff related to lambda calculus? free + bound vars, and calculation of types?
05:43:26 <SamB_XP> smg: indeed!
05:43:30 <vixey> you write Just (Just (Just (Just (Nothing, instead of fs (fs (fs (fz
05:43:48 <SamB_XP> ick
05:43:52 <smg> so i need lambda calculus book?
05:43:53 <vixey> what .....
05:43:56 <SamB_XP> unbalanced parens!
05:43:58 <smg> or what do i need then?
05:44:00 <ketil> what package contains Control.Parallel?
05:44:14 <chessguy> @type unfoldr
05:44:16 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
05:44:17 <smg> evaluation strategy also depends on lambda calc?
05:44:25 <chessguy> @type unfoldTree
05:44:27 <lambdabot> forall b a. (b -> (a, [b])) -> b -> Tree a
05:44:40 <SamB_XP> smg: TAPL should cover it
05:44:47 <luqui> TAPL is a great book
05:44:59 <smg> mh i see
05:45:02 <chessguy> @src unfoldTree
05:45:02 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
05:45:22 <pejo> smg, the standard reference on lambda calculus is the book by Barendraegt, but I don't really think that is what you're looking for.
05:45:31 <smg> mh
05:45:49 <smg> in general i really need calculate the types of expressions AND to calculate bound/free variables
05:45:57 <SamB_XP> @google "Introduction to Lambda Calculus" Barendregt
05:45:58 <vixey> smg: start by learning what free and bound variables are
05:45:59 <lambdabot> http://citeseer.ist.psu.edu/barendregt94introduction.html
05:45:59 <lambdabot> Title: Introduction to Lambda Calculus - Barendregt, Barendsen (ResearchIndex)
05:46:02 <smg> i will get tapl should i get another book about lambda calc?
05:46:09 <smg> vixey: i know nevertheless i need a book
05:46:20 <SamB_XP> smg: you could just read that
05:46:38 <smg> k
05:47:12 * SamB_XP discovers that a page has worked it's way out of the staples and goes to restaple...
05:48:38 <smg> he Implementation of Functional Programming Languages.  <---
05:48:41 <smg> The Impl*
05:48:45 <smg> how about that?
05:48:58 <vixey> smg: what are you interested in?
05:49:05 <vixey> (what motivates your study?)
05:49:26 <SamB_XP> I think it would probably be good to learn theory before learning how to implement?
05:49:39 <vixey> SamB: I'm not sure there's a difference ?
05:50:04 <SamB_XP> well, in theory you don't have to write a parser
05:50:06 <chessguy> @hoogle unfoldr
05:50:06 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
05:50:06 <lambdabot> Data.ByteString.unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
05:50:06 <lambdabot> Data.ByteString.Char8.unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
05:50:10 <vixey> hehe
05:50:13 <smg> i'm interested in type checking system, lambda calculus stuff, bound/free variables, evaluation strategy and so on in functional programming, probably with haskell
05:50:13 * luqui disagrees...  to each his own, and luqui finds things much easier to think about once he has tried to implement them
05:50:16 <vixey> there's always lisp
05:50:34 <vixey> smg: Just read TAPL then like has been suggested many times
05:51:26 <smg> k
05:53:33 <Peaker> @hoogle String -> ByteString
05:53:33 <lambdabot> Data.ByteString.Char8.pack :: String -> ByteString
05:53:33 <MedeaMelana> > 2 + 3 * 4
05:53:33 <lambdabot>  14
05:53:33 <Peaker> am I supposed to import that directly?
05:53:34 <SamB_XP> luqui: well, okay, so I do try to implement the Lambda calculus in various forms
05:53:34 <SamB_XP> er. I meant to capitalize Calculus too...
05:53:59 <quicksilver> Peaker: you don't want to use Strings at all.
05:54:05 <quicksilver> Peaker: if I understood what you were doing.
05:54:11 <quicksilver> Peaker: you want to use Word8s and Bytestrings
05:54:31 <Peaker> quicksilver, I am encoding a PPM which starts out with some plaintext describing format, width/height, max pixel value
05:55:58 <Peaker> quicksilver, PPM format for binary pixel data "P6\n%d %d\n%d\n%s" % (width, height, max_pixel_value, encoded_pixels)
05:56:04 <SamB_XP> there he goes with his Python again...
05:56:14 <Peaker> heh
05:56:17 <Peaker> easier than the equivalent (show ..) ++ syntax
05:56:21 <SamB_XP> though actually I guess that could be Haskell if tuples worked like he said!
05:56:55 <SamB_XP> there ARE certain benefits to such a system, and some people have figured out how to do it WITHOUT the lifting problem...
05:56:58 <quicksilver> Peaker: ah, that's not a binary format at all?
05:56:59 <MedeaMelana> doesn't haskell have a printf that doesn't need tuples?
05:57:08 <quicksilver> I think we were talking at cross-purposes earlier
05:57:10 <SamB_XP> (it involves a basic type that is strict on the right but lazy on the left
05:57:19 <SamB_XP> quicksilver: it is a binary format
05:57:38 <SamB_XP> quicksilver: only the HEADER is ASCII
05:57:39 <quicksilver> oh
05:57:39 <Peaker> quicksilver, the encoded pixels are binary
05:57:39 <quicksilver> I understand :)
05:57:48 <SamB_XP> there is a text-only format too
05:57:48 <luqui> heh, yeah, haskell has a printf MAJOR HACK that doesn't need tuples
05:57:54 <Peaker> P3 is text-only, P6 is binary for pixels
05:57:59 <quicksilver> Peaker: pack . (map (fromIntegral.fromEnum))
05:58:04 <quicksilver> Peaker: :: String -> ByteString
05:58:05 <SamB_XP> Peaker: so yes, import that pack function somehow and use it
05:58:30 <quicksilver> no, that pack function has the wrong type :)
05:58:30 <quicksilver> it gives you Char8 ByteStrings
05:58:30 <Peaker> quicksilver, so its not a good idea to use ByteString.Char8 which does this?
05:58:30 <quicksilver> Peaker: wants Word8
05:58:31 <SamB_XP> quicksilver: they are the SAME type
05:58:38 <quicksilver> Peaker: well I think you want the word8 version
05:58:47 <quicksilver> SamB_XP: not as far as the type checker is concerned they are not.
05:58:55 <SamB_XP> quicksilver: are you certain?
05:59:13 <quicksilver> yes.
05:59:13 <SamB_XP> check!
06:00:07 <quicksilver> oh, ok :)
06:00:20 <quicksilver> they are the same type.
06:00:34 <luqui> that was a funny conversation
06:01:14 <SamB> Prelude> [Data.ByteString.Char8.pack "hi", Data.ByteString.pack [32]]
06:01:14 <SamB> ["hi"," "]
06:01:33 <SamB> see!
06:02:12 * SamB wonders if there is a simpler way to prove that they are the same type?
06:04:52 <luqui> soo... what is the difference between the two modules then?
06:04:52 <SamB> luqui: the methods
06:04:52 <SamB> er. functions
06:04:52 * SamB wonders why he said methods
06:04:53 <SamB> (do I subconsiously think they should be in a typeclass ???)
06:04:53 <quicksilver> in particular, the types of the functions
06:04:58 <luqui> ahh, they talk about Chars
06:04:59 <quicksilver> although there are a few other differences
06:05:37 <SamB> yes, many of the methods may in fact be identical
06:05:53 <SamB> for instance, I don't see concat being different
06:06:14 <Peaker> hmm.. how come openFile and then some writes only actually take place if you close the file?  Does Haskell not take care to flush buffers atexit?
06:07:55 <Peaker> its bad practice to rely on it, but its still probably a good idea to make sure all data is flushed at exit
06:09:38 <CVirus> plusPoly a b = zipWith (+) a b .... how can I make it deal with lists of different sizes ?
06:10:15 <MedeaMelana> what do you want to do when the lists have different sizes?
06:10:30 <Bonus> pad the smaller list with zeros maybe?
06:10:43 <CVirus> for instance [1,2,3] [1,2] would yield [2,4,3]
06:10:46 <SamB> Peaker: I guess GHC doesn't quite manage it
06:11:04 <SamB> Peaker: any input you would like to provide on libraries@ regarding this issue would be welcome, I'm sure
06:11:05 <vixey> @src zipWith
06:11:05 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
06:11:05 <lambdabot> zipWith _ _      _      = []
06:11:13 <Peaker> SamB, well at least it encourages the right style
06:11:15 <vixey> just change the last clause
06:11:25 <vixey> zipWith _ xs     []     = xs
06:11:30 <vixey> zipWith _ []     ys     = ys
06:11:43 <vixey> you would use a different name than zipWith though
06:11:51 <MedeaMelana> zipWith' :: (a -> a -> a) -> [a] -> [a] -> [a]
06:11:51 <MedeaMelana> zipWith' f = g where
06:11:51 <MedeaMelana>   g (x:xs) (y:ys) = f x y : g xs ys
06:11:51 <MedeaMelana>   g    xs     ys  = xs ++ ys
06:11:54 <CVirus> thanks alot
06:12:08 <SamB> this is likely related to the non-guarenteed running of finalizers
06:12:10 <vixey> oh I like MedeaMelanas one better though
06:12:39 <MedeaMelana> I needed that one a while back
06:12:40 <Peaker> zipWith could take a default value for the smaller list
06:12:45 <Vq^> zipPadWith :: a -> (a -> a -> b) -> [a] -> [a] -> [b]  -- perhaps
06:12:58 <Peaker> @type zipWith
06:12:58 <SamB> (that is, finalizers aren't guarenteed to be run upon program termination, because the objects to which they are attached aren't guarenteed to be GC'd then...)
06:13:00 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
06:13:18 <vixey> there are many many generalizations
06:13:36 <Peaker> @djinn (a -> b -> c) -> a -> [a] -> b -> [b] -> [c]
06:13:36 <lambdabot> -- f cannot be realized.
06:13:53 <Peaker> where a and b there could be the default values
06:14:05 <Bonus> how about this
06:14:05 <Bonus> zeroPadToLength s t = let difference = length s - length t in t ++ (take difference (repeat 0))
06:14:22 <vixey> Bonus: does this work on infinite lists?
06:14:23 <Vq^> Bonus: kills laziness
06:14:26 <Bonus> ah
06:14:35 <Armored_Azrael> When I use the code at http://haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html#foreign-export-ghc 9.2.1, I get an invalid type signature error on the foreign export
06:14:36 <lambdabot> Title: 9.2. Using the FFI with GHC, http://tinyurl.com/yvfmf3
06:14:44 <Armored_Azrael> Has something been changed not yet updated in the manual?
06:15:29 <SamB> hmm. why am I wanting MedeaMelana's one to incur proof obligations that the function has a single unit on left and right?
06:15:40 <vixey> SamB: *lol*
06:16:02 <SamB> essentially, that the function forms a monoid...
06:16:20 <SamB> hmm.
06:16:41 <SamB> > transpose [[1,2,3],[1,2],[1,2,3]]
06:16:42 <lambdabot>  [[1,1,1],[2,2,2],[3,3]]
06:16:56 <MedeaMelana> ghc's transpose is so awesome :-)
06:17:12 <BeelsebobWork> hmm?
06:17:39 <BeelsebobWork> what makes it more awesome than any other transpose?
06:18:08 <MedeaMelana> what i mean is, it nicely handles the case where the lists aren't equal size
06:18:14 <SamB> @type \f unit -> map foldl' f unit . transpose
06:18:15 <lambdabot> forall b t a. (Functor ((->) t)) => (t -> [[a]] -> b -> [[a]]) -> t -> [[a]] -> [b] -> [[a]]
06:18:15 <BeelsebobWork> ah, I see
06:18:44 <SamB> hmm.
06:18:49 <SamB> not quite what I had in mind.,
06:18:54 <BeelsebobWork> > transpose [[1,2,3],[1],[1,2,3]]
06:18:56 <lambdabot>  [[1,1,1],[2,2],[3,3]]
06:19:03 <SamB> @type \f unit -> foldl' f unit . transpose
06:19:05 <lambdabot> forall a a1. (a -> [a1] -> a) -> a -> [[a1]] -> a
06:19:16 <SamB> @type \f unit -> map (foldl' f unit) . transpose
06:19:18 <lambdabot> forall a a1. (a -> a1 -> a) -> a -> [[a1]] -> [a]
06:19:32 <SamB> ah, that's more like it...
06:19:50 <SamB> a bit general in type though
06:20:05 <SamB> i.e. I'd want both as the same...
06:20:24 <SamB> (of course, that's the strict version...
06:20:48 <SamB> ... the lazy version uses foldr)
06:23:12 <CVirus> vixey: your zipWith didn't yield the required result ...  for instance [1,2,3] [1,2] would yield [2,4] instead of [2,4,3]
06:23:26 <CVirus> vixey: sorry but I'm new to haskell
06:23:42 <SamB> CVirus: did you see my function?
06:24:28 <CVirus> SamB: too complicated for me
06:24:38 <Bonus> CVirus: transpose two lists
06:24:42 <Bonus> and then map sum to that
06:24:49 <quicksilver> CVirus: the simplest solution (for some sense of simplest) is to pad the shorter list with zeros.
06:24:50 <BeelsebobWork> > zipWith (\x y -> x >>= y >>= return x * y) [Just 1,Just 2,Just 3] [Just 1, Just 2, Nothing]
06:24:51 <lambdabot>  Couldn't match expected type `a -> Maybe a'
06:24:52 <SamB> but it handles n lists!
06:24:52 <CVirus> let me read about transpose then
06:25:05 <BeelsebobWork> > zipWith (\x y -> x >>= y >>= return (x * y)) [Just 1,Just 2,Just 3] [Just 1, Just 2, Nothing]
06:25:06 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a1
06:25:06 <lambdabot>     Probab...
06:25:15 <BeelsebobWork> oh, duh
06:25:15 <SamB> actually...
06:25:20 <SamB> now that I think about it
06:25:31 <CVirus> quicksilver: how so ?
06:25:32 <SamB> the unit is superfluous
06:25:43 <BeelsebobWork> > zipWith (\x y -> x >>= \x' -> y >>= \y' -> return (x' * y')) [Just 1,Just 2,Just 3] [Just 1, Just 2, Nothing]
06:25:45 <lambdabot>  [Just 1,Just 4,Nothing]
06:25:49 <quicksilver> CVirus: check which one is shorter. add zeros to it.
06:25:53 <BeelsebobWork> there you go
06:25:53 <SamB> @type \f -> map (foldl1' f) . transpose
06:25:55 <lambdabot> forall a. (a -> a -> a) -> [[a]] -> [a]
06:26:00 <quicksilver> CVirus: this is not the most elegant, but it is simple to understand.
06:26:03 <BeelsebobWork> quicksilver: you mean ones
06:26:13 <Bonus> CVirus: here's your function :)
06:26:14 <Bonus> zeroPadToLength s t = let difference = length s - length t in t ++ (take difference (repeat 0))
06:26:15 <Bonus> no
06:26:16 <Bonus> not this
06:26:21 <Bonus> zeroPadToLength s t = let difference = length s - length t in t ++ (take difference (repeat 0))
06:26:26 <hpaste>  morrow pasted "haskell.sty" at http://hpaste.org/7987
06:26:28 <Bonus> man it keeps pasting the wrong thing sorry
06:26:34 <CVirus> it's okay
06:26:40 <Bonus> plusPoly a b = map sum . transpose $ [a,b]
06:26:42 <Bonus> this
06:26:45 <MedeaMelana> If you use length, it won't work on infinite lists anymore
06:26:46 <Bonus> just be sure to import Data.List
06:26:51 <quicksilver> BeelsebobWork: oh, are we multiplying?
06:26:56 <BeelsebobWork> quicksilver: yep
06:27:04 <quicksilver> yes then ones :)
06:27:13 <quicksilver> I thought we were adding polynomials.
06:27:25 <SamB> well, Bonus' can easily be adapted
06:27:43 <SamB> and mine already doesn't care what operation you use
06:28:05 <SamB> though obviously if it doesn't have the associative property you better make sure to fold the right way
06:28:19 <CVirus> Bonus: works .. thanks alot
06:29:02 <Bonus> cool
06:29:17 <SamB> radix: how come you don't have tags on your blog posts?
06:29:38 <radix> SamB: I do, sometimes
06:29:49 <SamB> you should have a tag for the "search history" series
06:29:55 <radix> ah :)
06:29:59 <radix> well, maybe when I have more than two posts :)
06:30:06 <SamB> hehe, I guess so
06:30:19 <radix> huh
06:30:24 <radix> there should be a "planet search history" ;-)
06:30:30 * SamB subscribes to radix's blog now
06:32:48 <MedeaMelana> what url?
06:42:28 <radix> MedeaMelana: http://radix.twistedmatrix.com/
06:42:30 <lambdabot> Title: Twisted Radix
06:42:35 <radix> (sorry for advertising, it was asked :)
06:43:30 <MedeaMelana> thanks :-)
06:45:12 <dreixel> hello
06:45:29 <MedeaMelana> hallo!
06:45:34 <dreixel> would anyone know if it is possible to give a default declaration for an associated type synonym?
06:48:59 <Peaker> damn trying to solve some equations on paper is horrible. all my pens are failing to write half the time.. I guess that's what happens when you don't use em for a while
06:53:06 <SPAZZZ> http://www.FakeMagazineCover.com - Upload photo to fake magazine cover templates
06:53:08 <lambdabot> Title: Fake Magazine Cover Maker, Make Parody Covers With 500 Magazines Templates, Uplo ...
06:53:10 <mm_freak1work> Peaker: we live in the 21st century
06:53:12 <mm_freak1work> ;)
06:53:14 --- mode: ChanServ set +o quicksilver
06:53:14 <SPAZZZ> http://www.SillyWebcam.com - Play with webcam online (games, take pics, effects)
06:53:15 <lambdabot> Title: Silly Flash Webcam Tricks & Effects - Take Instant Photos Online For Free With W ...
06:53:20 --- mode: quicksilver set +b *!*=traveler@*.twcny.res.rr.com
06:53:20 --- kick: SPAZZZ was kicked by quicksilver (quicksilver)
06:53:49 <Peaker> mm_freak, I tried using maxima to solve my equations - but there's a weirdness I do not understand, so I want to solve them myself
07:00:37 <mm_freak1work> Peaker: i don't know whether maxima is already mature
07:01:35 <MedeaMelana> Whenever you say Maxima I think of our heir apparent princess ;-)
07:01:41 --- mode: quicksilver set -o quicksilver
07:05:22 <mercury^> which extension do I need to load in ghc for the following to work?
07:05:35 <mercury^> > take 10 $ iterate (join (**)) 0.1
07:05:36 <lambdabot>  [0.1,0.7943282347242815,0.8328507411010583,0.8587056375050984,0.877388099570...
07:06:47 <MedeaMelana> @hoogle join
07:06:48 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
07:06:48 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
07:06:48 <lambdabot> System.FilePath.Windows.joinDrive :: FilePath -> FilePath -> FilePath
07:06:55 <bastl> what does ''data DarcsCommand = DarcsCommand {function1 :: typeB, function2 :: typeC}'' mean? I cannot find this { ... } syntax in my books :-(
07:06:58 <Syzygy-> Control.Monad thus.
07:07:09 <mm_freak1work> mercury^: Control.Monad
07:07:13 <Syzygy-> mercury^: You're in #math too, aren't you?
07:07:32 <mercury^> Syzygy-: yes
07:07:38 <Syzygy-> :)
07:07:42 <mercury^> and no, I'm not asking for the module
07:07:49 <Syzygy-> mtl then?
07:07:52 <mercury^> it does not typecheck
07:08:05 <mm_freak1work> i don't understand it anyway
07:08:10 <Syzygy-> But you can just scanl to do that, or foldl to get the last element.
07:08:29 <Syzygy-> > scanl (\x y -> x**x) 0.1 [1..10]
07:08:30 <lambdabot>  [0.1,0.7943282347242815,0.8328507411010583,0.8587056375050984,0.877388099570...
07:08:48 <vixey> @src scanl
07:08:48 <lambdabot> scanl f q ls = q : case ls of
07:08:48 <lambdabot>     []   -> []
07:08:48 <lambdabot>     x:xs -> scanl f (f q x) xs
07:08:50 <Syzygy-> :t (join (**))
07:08:53 <lambdabot> forall a. (Floating a) => a -> a
07:08:59 <mm_freak1work> > iterate (\x -> x**x) 0.1
07:09:00 <lambdabot>  [0.1,0.7943282347242815,0.8328507411010583,0.8587056375050984,0.877388099570...
07:09:02 <Syzygy-> :src join
07:09:07 <MedeaMelana>     No instance for (Monad ((->) a))
07:09:08 <MedeaMelana>       arising from a use of `join' at Test.hs:3:25-33
07:09:08 <MedeaMelana>     Possible fix: add an instance declaration for (Monad ((->) a))
07:09:54 <MedeaMelana> I'm not sure in which module that instance is defined
07:10:07 <MedeaMelana> :i Monad
07:10:15 <MedeaMelana> oh, i guess that doesn't work
07:10:39 <mercury^> well, it works here and lambdabot compiles via ghc afaik
07:10:41 <bastl> where is the syntax for { f1 :: type2, f2 :: type2 } explained?
07:10:51 <mercury^> so there has to be an option that allows it to typecheck
07:11:00 <mm_freak1work> <mercury^> > take 10 $ iterate (join (**)) 0.1   ⇐ that somehow doesn't make sense to me
07:11:04 <MedeaMelana> I think you need to import another module, but I'm not sure which
07:11:14 <MedeaMelana> bastl: that's record notation
07:11:21 <mm_freak1work> you join a function, which makes no sense
07:11:54 <bastl> Medea: thanks i guess that keyword will get me further with google's help ...
07:12:55 <mercury^> mm_freak1work: if you consider (-> a) a monad, then (a -> a -> a) can be joined to (a -> a)
07:13:44 <MedeaMelana> bastl: take a look at http://en.wikibooks.org/wiki/Haskell/More_on_datatypes#Named_Fields_.28Record_Syntax.29
07:13:45 <lambdabot> http://tinyurl.com/24qgex
07:14:30 <mm_freak1work> mercury^: ok, i understand
07:15:23 <MedeaMelana> ah, mercury, you need to import Control.Arrow
07:16:07 <mercury^> ah, cool
07:16:09 <mercury^> thanks MedeaMelana
07:16:13 <MedeaMelana> np
07:19:29 <bastl> MedeaMelana: thanks alot. named fields are another example of useful thing that doesnt appear in the standard books ...
07:20:15 <MedeaMelana> What standard books do you mean?
07:20:30 <mm_freak1work> cool…  i didn't know that you can pattern match against named fields
07:20:47 <bastl> R. Bird, Gentle Introduction ...
07:21:14 <dcoutts_> named fields get really useful when you start writing real progs
07:21:30 <dcoutts_> which is pertly why they're not often covered in intro texts
07:21:45 <bastl> dcoutts_: right, and most books dont care about real programs but the beauty of FP
07:23:09 <mm_freak1work> i use named fields for large constructors like run-time configuration or program state
07:23:41 <MedeaMelana> yeah, when a data type has grows, named fields are very convenient
07:24:17 <dcoutts_> I use named fields for OOP style objects
07:24:41 <bastl> are there any books for advanced haskell programming? covering distribution (cabal), documentation (haddock, lhs), GetOpt, gtk2hs etc ... ?
07:24:59 <dcoutts_> bastl: I think Real World Haskell aims to cover that
07:25:25 <mm_freak1work> bastl: individual tutorials for the things you named
07:26:27 * quicksilver waves a #haskell yellow card at dcoutts_ for use of the dirty phrase 'OOP style object' ;)
07:26:33 <dcoutts_> heh
07:26:51 <dcoutts_> sometimes extensibility in that direction is the right tool for the job
07:28:10 <bastl> that rises another question of mine: i would like to manipulate objects from a large java api with haskell. how could i do that ?
07:28:36 <dcoutts_> bastl: that's not going to be easy
07:28:48 <quicksilver> there have been projects to bridge haskell to java apis
07:28:53 <quicksilver> I think they're all a bit dead.
07:29:16 <bastl> any idea why?
07:30:01 <mtag55> hi
07:30:01 <quicksilver> such projects die because no one uses them :)
07:30:05 <quicksilver> they live if people do.
07:30:19 <mtag55> i took a hopenGl tutorial onm the net
07:30:38 <bastl> ok, nice talk. gtg.
07:30:51 <mtag55> in the first program iti is said that i must import GLUT and GL
07:31:20 <mtag55> when i compile the program it say that some functions are not in scope
07:31:39 <mtag55> any sugestions?
07:31:42 <MedeaMelana> help /list
07:31:45 <MedeaMelana> oops
07:32:11 <ziman> mtag55, which functions?
07:32:19 <twobitwork> ?pl \l -> take (length l) (repeat l)
07:32:19 <lambdabot> liftM2 take length repeat
07:32:23 <twobitwork> that doesn't seem to work
07:32:39 <twobitwork> is ?pl known to give wrong answers occasionally
07:33:14 <Deewiant> > liftM2 take length repeat [1,2,3]
07:33:15 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
07:33:23 <twobitwork> hmm... doesn't work in ghci
07:33:28 <mtag55> i said it wrong
07:33:29 <Deewiant> works fine in my GHCi
07:33:41 <osfameron> a jvm bridge from haskell would be useful
07:33:49 <twobitwork>     No instance for (Monad ((->) [a]))
07:33:49 <Cale> twobitwork: You need the instance of Monad for ((->) e)
07:33:55 <twobitwork> ohh
07:34:02 <mtag55> when i impot glut and gl it say that cannot load interface for GLUT
07:34:03 <Cale> twobitwork: which is available from Control.Monad.Instances
07:34:10 <Cale> (and unfortunately not in the Prelude)
07:34:13 <Deewiant> or just Control.Monad
07:34:19 <twobitwork> ahhh
07:34:22 <Cale> Just Control.Monad now?
07:34:23 <Deewiant> @index liftM2
07:34:23 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
07:34:31 <Cale> liftM2 is in Control.Monad
07:34:37 <Deewiant> Control.Monad imports the instances, right?
07:34:38 <Cale> But I don't know about the instance.
07:34:40 <mtag55> i tried to import Graphics.UI.GLUT and then it say that some functions are not in scope
07:34:46 <Cale> Not the last time I checked.
07:34:54 <Deewiant> my .ghci only has Control.Monad, Control.Arrow, Control.Monad.Fix
07:34:58 <Deewiant> maybe one of those does
07:35:10 <twobitwork> yeah, Control.Monad works too
07:35:20 <MedeaMelana> heh, same problem as weaver ran into a moment ago
07:35:32 <mercury^> me actually, wasn't it?
07:35:39 <Deewiant> Control.Monad.Fix does, evidently, but Control.Monad doesn't
07:35:39 <MedeaMelana> oh mercury, yes, sorry
07:35:59 <twobitwork> .ghci?
07:36:07 <twobitwork> how does that work? I don't see it in my man page
07:36:18 <Deewiant> GHC has man pages? O_o
07:36:25 <Deewiant> it's in the HTML/PDF manual
07:36:30 <twobitwork> ahh
07:37:04 <mtag55> can anybody say to me what is the path for the package GL?
07:37:13 <mtag55> for GLUT is Graphics.UI.GLUT
07:38:17 <ziman> mtag55, http://www.haskell.org/ghc/docs/latest/html/libraries/ <-- there, it might be Graphics.Rendering.OpenGL.GL...
07:41:44 <mtag55> 10x but it stil doesn't work
07:44:22 <mar77a> is it possible to write a function
07:44:31 <mar77a> that can get the maxium of every container in the standard lib
07:44:40 <mar77a> arrays trees hash's lists etc
07:44:45 <mar77a> ALL in one single function
07:44:54 <vixey> hi mar77a
07:44:59 <mar77a> hiho
07:45:12 <conal> mtag55: i use import Graphics.Rendering.OpenGL
07:45:15 <mar77a> i want to know if it's possible before i start doing it
07:45:16 <vixey> :)
07:46:18 <MedeaMelana> You could build a type class I guess
07:46:44 <MedeaMelana> a la http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-default
07:46:44 <mtag55> conal and how do you compile?
07:46:46 <lambdabot> http://tinyurl.com/5ubarh
07:46:53 <Cale> mar77a: I would say yes, but I'm not sure about whether there's a Foldable instance for Arrays.
07:46:54 <mtag55> ghc - package OpenGL ...
07:46:55 <mtag55> ?
07:47:08 <Deewiant> @instances Foldable
07:47:09 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
07:47:11 <conal> mtag55: mostly, i use cabal
07:52:35 <ziman> mtag55, ghc --make will pull in all dependencies
08:08:55 <HairyDude> in Data.List: {-# RULES "all/build" forall p (g::forall b.(a->b->b)->b->b) . all p (build g) = g ((&&) . p) True
08:09:02 <HairyDude> #-}
08:09:09 <HairyDude> what is 'build' here?
08:09:25 <wjt> @ty build
08:09:26 <byorgey> @go build/foldr fusion
08:09:26 <lambdabot> Not in scope: `build'
08:09:28 <lambdabot> http://www.cs.ioc.ee/tfp-icfp-gpce05/tfp-proc/28num.pdf
08:09:47 <Saizan_> @ty GHC.Exts.build
08:09:49 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
08:10:14 <byorgey> it's sort of the opposite of foldr
08:10:20 <dmwit> That is a wacky type.
08:10:27 <wjt> oh, the first type is the church encoding of a list, no?
08:10:38 <byorgey> it builds up a list from a seed value instead of reducing a list
08:10:56 <byorgey> wjt: indeed
08:11:03 <wjt> enlightenment strikes
08:11:22 <dmwit> ?djinn (a -> b -> b) -> b -> b
08:11:23 <lambdabot> f _ a = a
08:11:25 <dmwit> bah
08:11:38 <byorgey> presumably build f = f (:) []
08:11:38 <HairyDude> trying to figure out why (for some n) all ((/=0) . (n `mod`)) is more efficient than all (\m -> n `mod` m == 0)
08:12:25 <wjt> so says said paper
08:12:26 <dmwit> Well... they do different things.
08:12:29 <smg> is there a difference between `mod` and `rem` btw?
08:12:33 <dmwit> Or is that just a typo?
08:12:41 <HairyDude> think there's a difference with negative numbers
08:12:43 <dmwit> smg: They deal with negative numbers differently.
08:12:52 <HairyDude> dmwit?
08:13:01 <HairyDude> they do the same
08:13:06 <dmwit> HairyDude: (==) vs. (/=)
08:13:06 <byorgey> HairyDude: you have == in one and /= in the other
08:13:19 <HairyDude> err, that was a typo, I meant /= in both cases
08:13:21 <dmwit> ok
08:13:34 <vixey> > 10000000000000000000000000000000000^10
08:13:35 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
08:13:51 <dmwit> > ((-1) `mod` 4, (-1) `rem` 4) -- smg
08:13:53 <lambdabot>  (3,-1)
08:13:53 <HairyDude> floor 1e1000
08:14:02 <HairyDude> > floor 1e1000
08:14:03 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
08:14:08 <dmwit> heh
08:14:14 <HairyDude> > floor 1e1000
08:14:16 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
08:14:18 <HairyDude> weird
08:14:27 <dmwit> Floating-point round-off error.
08:14:31 <byorgey> that's the largest number in the universe
08:14:43 <dmwit> > 10^1000
08:14:44 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
08:15:13 <smg> dmwit: k ty
08:15:18 <vixey> > 10^10000000000000000000000000000000000
08:16:37 <twobitwo1k> how do you get \bot to show the @src for an instance method?
08:16:38 <slavik> would lambdabot allow me to create functions?
08:16:48 <dmwit> ?src (->) fmap
08:16:48 <lambdabot> fmap = (.)
08:16:52 <vixey> @let f x = x^2
08:16:53 <lambdabot> Defined.
08:16:55 <twobitwo1k> slavik: let f x = something x in f 4
08:16:56 <vixey> > f 77
08:16:57 <lambdabot> Terminated
08:16:59 <dmwit> slavik: > let f x = ... in ...
08:16:59 <vixey> > f 77
08:17:00 <lambdabot> Terminated
08:17:02 <vixey> > f 77
08:17:03 <lambdabot> Terminated
08:17:07 <dmwit> ?undefine
08:17:07 <vixey> wow.. :?
08:17:08 <wjt> \o/
08:17:08 <lambdabot> Undefined.
08:17:13 <dmwit> ?let f x = x^2
08:17:14 <lambdabot> Defined.
08:17:15 <slavik> let fac n = if n == 0 then 1 else n*fac(n-1)
08:17:16 <dmwit> > f 77
08:17:17 <lambdabot> Terminated
08:17:17 <twobitwo1k> yeah... use > let instead of @let
08:17:17 <vixey> @let f' x = x^2
08:17:18 <lambdabot> Defined.
08:17:20 <vixey> > f1  77
08:17:21 <lambdabot>   Not in scope: `f1'
08:17:22 <vixey> > f'  77
08:17:24 <lambdabot>  5929
08:17:24 <slavik> > let fac n = if n == 0 then 1 else n*fac(n-1)
08:17:25 <lambdabot>  Parse error at end of input
08:17:31 <dmwit> oh
08:17:35 <wjt> presumably because of the SimpleReflect stuff
08:17:38 <dmwit> vixey: f :: Expr
08:17:39 <dmwit> yeah
08:17:41 <twobitwo1k> slavik: you have to to put "in ..." at the end
08:17:51 <slavik> > let fac n = if n == 0 then 1 else n*fac(n-1) in ...
08:17:52 <lambdabot>  Parse error at "..." (column 49)
08:17:55 <slavik> err
08:17:59 <dmwit> heh
08:18:08 * slavik is a noob
08:18:13 <dmwit> Try again. =)
08:18:32 <dmwit> > let fac n = if n == 0 then 1 else n*fac(n-1) in fac 10
08:18:32 <slavik> > let fac n = if n == 0 then 1 else n*fac(n-1) in 10
08:18:33 <lambdabot>  3628800
08:18:34 <lambdabot>  10
08:18:39 <slavik> ahh
08:18:46 <slavik> > let fac n = if n == 0 then 1 else n*fac(n-1) fac in 10
08:18:47 <lambdabot>      Occurs check: cannot construct the infinite type: t = (a -> t) -> a
08:18:47 <lambdabot>     ...
08:19:05 <dmwit> Your "fac" is a bit premature there. =)
08:19:05 <slavik> > let fac n = if n == 0 then 1 else n*fac(n-1) in fac 10
08:19:07 <lambdabot>  3628800
08:19:13 <slavik> I see
08:19:37 <dmwit> > let fac n = product [1..n] in fac 10
08:19:39 <lambdabot>  3628800
08:19:57 <dmwit> > let fac = product . enumFromTo 1 in fac 10
08:19:58 <lambdabot>  3628800
08:20:03 <slavik> hmm, now I wonder which is faster :P
08:20:20 <dmwit> http://www.willamette.edu/~fruehr/haskell/evolution.html
08:20:21 <lambdabot> Title: The Evolution of a Haskell Programmer
08:20:26 <dmwit> Includes a speed analysis at the end.
08:20:35 <slavik> ty
08:21:20 <Deewiant> I wonder if it's still valid with new GHCs though
08:21:32 <Deewiant> after all that's fairly old
08:21:35 <dmwit> Maybe not.
08:21:50 <dmwit> Anyway, the analysis is in Hugs.
08:25:12 <mm_freak1work> > let findFactor n = gcd (foldl (\x y -> rem (x*y) n) (takeWhile (<= n) [1..])) n in findFactor 15
08:25:13 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]
08:25:13 <lambdabot>       Expected...
08:25:23 <mm_freak1work> > let findFactor n = gcd (foldl (\x y -> rem (x*y) n) 1 (takeWhile (<= n) [1..])) n in findFactor 15
08:25:24 <lambdabot>  15
08:25:43 <mm_freak1work> > let findFactor n = gcd (foldl (\x y -> mod (x*y) n) 1 (takeWhile (<n) [2..])) n in findFactor 15
08:25:45 <lambdabot>  15
08:25:56 <slavik> wow ... haskell is fast
08:26:07 <mm_freak1work> > let findFactor n = gcd (foldl (\x y -> rem (x*y) n) 1 (takeWhile ((<=n) . (^2)) [2..])) n in findFactor 15
08:26:08 <lambdabot>  3
08:26:12 <mm_freak1work> > let findFactor n = gcd (foldl (\x y -> rem (x*y) n) 1 (takeWhile ((<=n) . (^2)) [2..])) n in findFactor 12827
08:26:13 <lambdabot>  101
08:26:49 <mm_freak1work> > let findFactor n = gcd (foldl (\x y -> rem (x*y) n) 1 (takeWhile ((<=n) . (^2)) [2..])) n in findFactor 9195413957
08:26:51 <lambdabot>  5107
08:26:51 <byorgey> slavik: indeed, a ton of work has gone into the ghc compiler in particular.
08:27:09 <mm_freak1work> pretty fast, even though it's interpreted
08:29:29 <byorgey> interpreted?
08:29:45 <mm_freak1work> i'm talking about lambdabot
08:29:55 <byorgey> I think it's actually compiled.
08:30:29 <mm_freak1work> then the developer has actually reinvented the wheel…  he could just have used GHC
08:30:41 <dmwit> He did.
08:30:47 <vixey> wtf
08:30:49 <dmwit> It's compiled by GHC.
08:30:53 <mm_freak1work> oh, ok
08:31:14 <byorgey> vixey: ?
08:31:26 <Outlande1> anyone know of haskell being used on a large web site/app yet?
08:31:29 <mm_freak1work> > print "test"
08:31:30 <lambdabot>  <IO ()>
08:31:33 <Outlande1> or a good example of one,etc
08:31:53 <mm_freak1work> Outlande1: IIRC a CMS has been written using WASH
08:32:02 <mm_freak1work> but i don't know its name
08:32:04 <dmwit> I seem to recall a fairly nice-looking website built with Haskell for some company.
08:32:58 <dmwit> Is haskell.org down?
08:33:05 <hpaste>  mqtt pasted "(no title)" at http://hpaste.org/7988
08:33:08 <MedeaMelana> doesn't look like it
08:33:17 <mm_freak1work> dmwit: nope, it works here
08:33:19 <dcoutts_> dmwit: seems fine to me
08:33:27 <dmwit> huh
08:33:55 <dcoutts_> dmwit: http://downforeveryoneorjustme.com/haskell.org
08:33:56 <lambdabot> Title: It's just you.
08:34:04 <MedeaMelana> hehe
08:34:11 <dmwit> Cool!
08:35:05 <dmwit> haskell.org statistics: 10 packets transmitted, 0 received, 100% packet loss
08:35:07 <dmwit> =/
08:35:33 <Botje> works for me
08:35:36 <Botje> maybe it just blocks pings
08:36:18 <mm_freak1work> --- haskell.org ping statistics ---
08:36:18 <mm_freak1work> 2 packets transmitted, 2 received, 0% packet loss, time 1004ms
08:37:07 <Botje> heh
08:37:08 <Botje> actually
08:37:11 <Botje> it pings just fine here :o)
08:41:03 <byorgey> hehe, that's a great site =)
08:49:30 <twobitwo1k> there has to be something better than this:
08:49:32 <twobitwo1k> reverse . unfoldr (\n -> if n <= 0 then Nothing else Just (n `mod` 10, n `div` 10)) $ 123
08:50:11 <twobitwo1k> > let digits = reverse . unfoldr (\n -> if n <= 0 then Nothing else Just (n `mod` 10, n `div` 10)) in digits 420
08:50:14 <lambdabot>  [4,2,0]
08:50:27 <quicksilver> > map digitToInt . show $ 420
08:50:29 <lambdabot>  [4,2,0]
08:50:38 <quicksilver> but to be honest I think your version is better.
08:50:41 <twobitwo1k> that seems like cheating
08:50:42 <quicksilver> going via show is a dirty hack.
08:50:45 <twobitwo1k> yeah
08:51:03 <twobitwo1k> it just seems like there should be a more elegant way to do it
08:51:12 <vixey> :t divMod
08:51:15 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
08:51:23 <twobitwo1k> ahh
08:51:28 <twobitwo1k> > divMod 14
08:51:29 <lambdabot>  <Integer -> (Integer,Integer)>
08:51:32 <twobitwo1k> > divMod 14 10
08:51:33 <lambdabot>  (1,4)
08:51:40 <twobitwo1k> > divMod 1434 10
08:51:41 <lambdabot>  (143,4)
08:52:39 <twobitwo1k> of course, I need to swap those
08:52:55 <twobitwo1k> :t modDiv
08:52:56 <lambdabot> Not in scope: `modDiv'
08:56:15 <Armored_Azrael> quicksilver: Thanks for the help (also Jaffa, but he doesn't seem to be here). It works
08:57:13 <Armored_Azrael> Turns out, if you use build.mk with
08:57:13 <Armored_Azrael> GhcLibHcOpts = -fPIC
08:57:13 <Armored_Azrael> GhcHcOpts = -fPIC
08:57:13 <Armored_Azrael> it produces static libraries that can be linked by passing -fPIC and -shared to ghc, producing the correct type of module
08:57:40 <luqui> :t divMod
08:57:41 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
08:58:07 <nolrai_> if i use the package libghc6-glade i get a link error, but on the other hand the source dosn't compile, any ideas?
08:58:54 <nolrai_> this was working before i upgraded to hardy heron, which doesnt make any sense.
08:59:16 <twobitwo1k> did the upgrade change the version of ghc?
09:00:56 <hajamie> Hi, what does deriving mean, e.g. deriving (eq,ord,show)
09:02:36 <nolrai_> no, but it might have forced me to reinstall the librarys (for some reason that excapes me now).
09:03:02 <mm_freak1work> quicksilver: i think your version is better, since show is probably highly optimized for the basic types
09:03:04 <N3cRoM4nc3r> guys am trying to generate a list from [1.0 to c] where c is the length[1,2,3] i always get the error zipWith (*) b (enumFromTo 1.0 c)
09:03:09 <N3cRoM4nc3r> can any one help ?
09:03:43 <gubagem> so you want [1.0,2.0,3.0] ?
09:04:02 <nolrai_> hajamie: it means that the compiler is building a instance of those typeclases for you.
09:04:03 <mm_freak1work> > enumFromTo 1.0 (length [1,2,3] :: fromIntegral)
09:04:05 <lambdabot>  : fromIntegral)'
09:04:05 <lambdabot>     In the expression:
09:04:05 <lambdabot>         enumFromTo 1.0 (length [1, 2...
09:04:11 <mm_freak1work> uhm
09:04:17 <mm_freak1work> it's not my day, i guess
09:04:23 <mm_freak1work> > enumFromTo 1.0 (fromIntegral $ length [1,2,3])
09:04:24 <lambdabot>  [1.0,2.0,3.0]
09:04:30 <N3cRoM4nc3r> lol
09:04:32 <N3cRoM4nc3r> have a look : http://pastebin.com/d672dc1e1
09:04:42 <frwmanners> @src scanl
09:04:42 <lambdabot> scanl f q ls = q : case ls of
09:04:42 <lambdabot>     []   -> []
09:04:42 <lambdabot>     x:xs -> scanl f (f q x) xs
09:04:59 <hajamie> thanks nolrai_
09:05:00 <gubagem> > [1.0...(length [1..3])]
09:05:01 <lambdabot>   Not in scope: `...'
09:05:03 <vixey> write (length xs)
09:05:05 <vixey> not length(xs)
09:05:18 <mm_freak1work> N3cRoM4nc3r: it's a type problem
09:05:24 <gubagem> > [1.0..(length [1..3])]
09:05:24 <N3cRoM4nc3r> k where ?
09:05:25 <lambdabot>   add an instance declaration for (Fractional Int)
09:05:25 <lambdabot>     In the expression: 1.0...
09:05:31 <mm_freak1work> you can't multiply a Float to an Int
09:05:34 * gubagem gives up
09:05:47 <mm_freak1work> > (3::Int) + (4::Float)
09:05:48 <lambdabot>  Couldn't match expected type `Int' against inferred type `Float'
09:05:53 <N3cRoM4nc3r> the problem is i wnna multiply two lists together, 1 is int and 1 is float
09:05:57 <mm_freak1work> > fromIntegral (3::Int) + (4::Float)
09:05:59 <lambdabot>  7.0
09:06:01 <N3cRoM4nc3r> and i want the output list to be float
09:06:17 <N3cRoM4nc3r> how can i do that ?
09:06:17 <gubagem> so you want the cartesian product of them?
09:06:18 <N3cRoM4nc3r> yea
09:06:18 <gubagem> not pairs of integers with floats?
09:06:22 <N3cRoM4nc3r> no
09:06:26 <mm_freak1work> N3cRoM4nc3r: the fromIntegral function is your friend
09:06:41 <gubagem> @hoogle fromIntegral
09:06:42 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
09:06:59 <quicksilver> Armored_Azrael: yay :)
09:06:59 <N3cRoM4nc3r> so wat does fromintergral do ?
09:07:11 <gubagem> so that function takes an Integer, and casts it into number
09:07:15 <mm_freak1work> it generalizes an Integral type to a Num type
09:07:20 <N3cRoM4nc3r> hmm
09:07:34 <N3cRoM4nc3r> mm_freak1work,  u had a look at my code, wat part shud be changed ?
09:07:40 <gubagem> is Integral type same as Integer
09:07:56 <Beelsebob> no
09:07:57 <Cale> Wow, an actual lolcat is in the channel!
09:08:01 <mm_freak1work> N3cRoM4nc3r: i'm not going to do your homework, but i tell you that you cannot multiply/add Float to Int
09:08:08 <Beelsebob> Integral is a class that includes all integer like types
09:08:11 <Beelsebob> for example Int
09:08:15 <N3cRoM4nc3r> ok so the solution is to generalize the Int to Num
09:08:16 <N3cRoM4nc3r> ?
09:08:36 <N3cRoM4nc3r> then multiply Int by float wud give out float ?
09:08:38 <mm_freak1work> you can use fromIntegral on the integral numbers to generalize them to whatever is demanded (Float in this case)
09:08:52 <gubagem> so int,integer,fractional int, are all type integral?
09:09:08 <sclv_>  ?quote fromIntegral
09:09:09 <Beelsebob> no, Fractional Int is an *instance* of the Fractional class
09:09:09 <gubagem> which fall under a Num umbrella
09:09:22 <sclv_> ?quote fromIntegral
09:09:22 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
09:09:23 <gubagem> so i cant 'cast' it with fromIntegral?
09:09:30 <Cale> N3cRoM4nc3r: To put it slightly differently, fromIntegral will convert a number of any integral type (Int, Integer, Word32, etc.) to any numeric type you would like (Int, Integer, Float, Double, Complex Double, etc.)
09:09:30 <Beelsebob> (which is a class which describes all numbers that can be described as a fraction)
09:09:33 <mm_freak1work> > zipWith (+) ([1..3] :: [Int]) [4.0 .. 6.0]   -- won't work
09:09:33 <lambdabot>   add an instance declaration for (Fractional Int)
09:09:33 <lambdabot>     In the expression: 4.0
09:09:41 <Beelsebob> gubagem: you don't cast it, it's an explicit coercion
09:09:50 <mm_freak1work> > zipWith (+) (map fromIntegral $ [1..3] :: [Int]) [4.0 .. 6.0]   -- does work
09:09:50 <lambdabot>   add an instance declaration for (Fractional Int)
09:09:50 <Beelsebob> @type fromIntegral
09:09:50 <lambdabot>     In the expression: 4.0
09:09:52 <lambdabot> forall a b. (Num b, Integral a) => a -> b
09:10:03 <mm_freak1work> > zipWith (+) (map fromIntegral $ ([1..3] :: [Int])) [4.0 .. 6.0]   -- does work
09:10:04 <lambdabot>  [5.0,7.0,9.0]
09:10:05 <Beelsebob> takes and Integral type, produces and Numeric type
09:10:35 <byorgey> gubagem: Int and Integer are types in class Integral.
09:10:44 <byorgey> there's no such thing as fractional int.
09:10:44 <sclv_> ?instances Integral
09:10:45 <lambdabot> Int, Integer
09:10:54 <Beelsebob> @instances Fractional
09:10:54 <lambdabot> Double, Float
09:11:07 <Beelsebob> @instances Num
09:11:08 <lambdabot> Double, Float, Int, Integer
09:11:25 <sclv_> ?instances RealFloat
09:11:25 <lambdabot> Double, Float
09:12:04 <mm_freak1work> <byorgey> there's no such thing as fractional int. ⇐ there is, for example elements of a finite field
09:12:18 <gubagem> > f 5 where f n=product [1..n]
09:12:18 <lambdabot>  Parse error at "where" (column 5)
09:12:38 <mm_freak1work> > let f n = product [1..n] in f 5
09:12:39 <lambdabot>  120
09:12:39 <gubagem> > let f n=product [1..n] in f 5
09:12:41 <lambdabot>  120
09:12:48 <byorgey> well, ok, you could make Int an instance of Fractional in various sensible ways, that's true.
09:12:49 <gubagem> just showing my brother lambdabot
09:13:01 <byorgey> my point was that it's not in the standard Prelude.
09:13:07 <mm_freak1work> byorgey: not Int, but some other integral number types
09:13:33 <mm_freak1work> but in fact, they wouldn't be Integral =)
09:13:37 <gubagem> @hoogle exitWith
09:13:37 <lambdabot> System.Exit.exitWith :: ExitCode -> IO a
09:13:53 <gubagem> how do i make an ExitCode?
09:14:08 <Beelsebob> @hoogle ExitCode
09:14:09 <lambdabot> System.Exit.ExitCode :: data ExitCode
09:14:09 <lambdabot> System.Process.getProcessExitCode :: ProcessHandle -> IO (Maybe ExitCode)
09:14:27 <quicksilver> gubagem: type ":i ExitCode" in ghci
09:14:30 <mm_freak1work> > exitWith ExitSuccess
09:14:30 <lambdabot>   Not in scope: data constructor `ExitSuccess'
09:14:39 <mm_freak1work> well, it is in the standard libs =)
09:14:45 <gubagem> mm_freak: thanks
09:14:52 <mm_freak1work> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Exit.html
09:14:53 <lambdabot> http://tinyurl.com/34e7ph
09:15:28 <N3cRoM4nc3r> thanks mm_freak1work  it works now
09:15:28 <chessguy_> byorgey:  it seems like the standard approach, if there are multiple easy, sensible ways to do something, is to not put it in the library at all
09:15:40 <N3cRoM4nc3r> cheers guys
09:16:19 <byorgey> chessguy_: indeed. except for the MonadPlus instance of Maybe =)
09:16:38 <byorgey> er, I meant the Monoid instance of Maybe
09:16:41 * chessguy_ decides not to touch Maybe, since it's been so volatile lately
09:17:39 <Saizan_> ?src Fractional
09:17:40 <lambdabot> class  (Num a) => Fractional a  where
09:17:40 <lambdabot>     (/)             :: a -> a -> a
09:17:40 <lambdabot>     recip           :: a -> a
09:17:40 <lambdabot>     fromRational    :: Rational -> a
09:17:48 <byorgey> data Maybe a = DONTTOUCHME | IWARNEDYOU !a
09:18:36 <mm_freak1work> N3cRoM4nc3r: you're welcome
09:19:10 <MedeaMelana> ?src Monoid
09:19:11 <lambdabot> class Monoid a where
09:19:11 <lambdabot>     mempty  :: a
09:19:11 <lambdabot>     mappend :: a -> a -> a
09:19:11 <lambdabot>     mconcat :: [a] -> a
09:19:43 <MedeaMelana> ?src instance Monoid Maybe
09:19:44 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:19:50 <MedeaMelana> oh
09:20:22 <sclv_> I don't think Maybe has a Monoid instance? (I think it should though)
09:20:35 <mm_freak1work> uhm, it would make sense
09:20:38 <MedeaMelana> Monoid a => Monoid (Maybe a)
09:20:39 <geezusfreeek> it does
09:20:42 <MedeaMelana> is what it says here
09:20:47 <quicksilver> sclv_: yes, it does. the lifting one which adds a new identity
09:20:57 <ToRA> > mempty :: Just []
09:20:57 <lambdabot>   Not in scope: type constructor or class `Just'
09:21:03 <mm_freak1work> mempty = Nothing; mappend _ (Just x) = Just x; mappend (Just x) Nothing = Just x
09:21:16 <ToRA> > mempty :: Maybe [Int]
09:21:17 <lambdabot>  Nothing
09:21:35 <mm_freak1work> > mappend (Just 3) (Just 4)
09:21:36 <lambdabot>  Add a type signature
09:21:37 <quicksilver> it's a bit odd, really.
09:21:49 <mm_freak1work> > mappend (Just 3) (Just 4) :: Maybe Int
09:21:49 <lambdabot>   add an instance declaration for (Monoid Int)
09:21:50 <lambdabot>     In the expression: mappend...
09:21:50 <vixey> > Just [3] ++ Just [4]
09:21:51 <geezusfreeek> there are also First and Last wrappers for Maybe
09:21:51 <lambdabot>  Just [3,4]
09:21:57 <geezusfreeek> for the Monoid instances
09:22:38 <FordCortina> pastebin
09:22:42 <FordCortina> > pastebin
09:22:43 <lambdabot>   Not in scope: `pastebin'
09:22:47 <FordCortina> !pastebin
09:22:48 <hpaste> Haskell paste bin: http://hpaste.org/
09:22:50 <sclv_> quicksilver: oh, right, the lifting instance. I was refering to standardizing either the First or Last instance.
09:22:51 <vixey> /topic
09:23:30 <Bonus> what's the function to quickly make an array from a list called again
09:23:41 <dsrogers> does haskell have a hashmap implementation?
09:23:45 <Bonus> so i only have to give it a list
09:23:48 <Bonus> of elements
09:23:50 <Bonus> without the indices
09:23:53 <Bonus> dsrogers: yeah, Data.Map
09:23:59 <mm_freak1work> Bonus: listArray
09:24:04 <vixey> :t listArray
09:24:06 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
09:24:12 <Bonus> hmmm
09:24:13 <vixey> ?hoogle [e] -> Array i e
09:24:14 <lambdabot> No matches, try a more general search
09:24:15 <mm_freak1work> or newListArray for mutable arrays
09:24:15 <hpaste>  FordCortina pasted "Linker error?" at http://hpaste.org/7989
09:24:15 <dsrogers> Bonus: I thought that was tree map?
09:24:26 <Bonus> dsrogers ah you mean like
09:24:28 <byorgey> Data.Map isn't a hashmap.
09:24:28 <Bonus> implemented with hashes
09:24:30 <Bonus> yeah
09:24:30 <dsrogers> Bonus: it gives O(log n) for operations.  that's a tree map
09:24:32 <Bonus> my bad
09:24:35 <FordCortina> any idea what your supposed to do when you get that sort of error?
09:24:59 <pgavin> @seen dcoutts
09:24:59 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
09:25:06 <byorgey> there is a hashmap, but it's kind of annoying to use
09:25:08 <Deewiant> preflex: seen dcoutts
09:25:09 <preflex>  dcoutts was last seen on #ghc 6 hours, 4 minutes and 4 seconds ago, saying: 13 for Setup.hs, 17 for cabal-install
09:25:12 <byorgey> since it's all in the IO monad
09:25:31 <dsrogers> why does it need to be in the IO monad?
09:25:41 <byorgey> dsrogers: Data.Map usually works just fine for all but the most demanding applications.
09:26:00 <dcoutts_> pgavin: hia
09:26:08 <pgavin> hi dcoutts_
09:26:14 <dcoutts_> how's it going?
09:26:21 <dsrogers> byorgey: I know.  I was just thinking about how you would do it, functionally, and wanted an example.
09:26:21 <Bonus> why is Data.Map implemented as a tree isntead of a hasmap though?
09:26:22 <byorgey> dsrogers: because the whole idea of a hashmap is that you index into an array and update it in-place.
09:26:28 <Bonus> ah
09:26:31 <sclv_> hmm, did that lifting instance to maybe just get added recently, or have I just been blind?
09:26:32 <pgavin> thinking maybe we should go ahead and branch the gtk2hs repo
09:26:34 <dcoutts_> pgavin: how much do you hate windows installers yet? :-)
09:26:36 <quicksilver> sclv_: recently.
09:26:38 <dcoutts_> pgavin: sure
09:27:00 <sclv_> You think it's more useful than First, generally?
09:27:00 <byorgey> there might be a way to do it functionally, I guess, but I don't know of one
09:27:09 <dsrogers> ﻿byorgey: not really.  usually the most important part of a hashmap is O(1) lookups.
09:27:10 <dcoutts_> pgavin: you can see how we've done it previously: http://darcs.haskell.org/gtk2hs-branches/
09:27:11 <lambdabot> Title: Index of /gtk2hs-branches
09:27:25 <pgavin> dcoutts_: what versions of ghc/gtk should I build binaries for?
09:27:32 <dsrogers> well, it would depend on application....
09:27:40 <pgavin> dcoutts_: ok, do you want me to branch it myself?
09:28:03 <johnlunney> Here's a totally irrelevant question... I just found a weird file on my computer. /usr/bin/Cd
09:28:06 <johnlunney> Does anyone else have it? :)
09:28:17 <dcoutts_> pgavin: you can yes, just make a branches dir on the server side (not recorded in the repo) and make a copy into there
09:28:28 <FordCortina> does ghc on windows use the gnu linker?
09:28:30 <johnlunney> /usr/bin/Cd: fork: Resource temporarily unavailable
09:28:33 <johnlunney> Very odd...
09:28:45 <sclv_> I guess it makes more sense for it to be the unwrapped one however...
09:28:47 <dcoutts_> FordCortina: yes and gcc
09:28:58 <pgavin> dcoutts_: e.g. /srv/code/gtk2hs/branches?
09:29:07 <byorgey> johnlunney: that sounds very fishy.
09:29:18 <dsrogers> john: your process may have hit process count limits.
09:29:31 <dsrogers> john: assuming the error is correct in the first place.
09:29:41 <johnlunney> Ah
09:29:43 <johnlunney> I see what it is
09:29:45 <johnlunney> http://lists.apple.com/archives/Darwin-userlevel/2005/May/msg00036.html
09:29:46 <lambdabot> Title: Re: /usr/bin/cd??, http://tinyurl.com/6hdr32
09:29:48 <johnlunney> It's a compatibility trick
09:29:50 <dcoutts_> pgavin: right, I think that'll work fine so long as we never make a branches dir in the gtk2hs repo itself, but I don't think that's a problem
09:30:04 <dcoutts_> pgavin: as for binaries, I assume you mean for windows. Well whatever version of gtk you like and I'd go for ghc-6.6.1 and 6.8.3 which of course is not out yet :-)
09:30:16 <johnlunney> byorgey: I opened it and saw ${0##*/} ${1+"$@"}, and thought "Uh oh, fork-bomb!"
09:30:29 <byorgey> hehe
09:30:31 <dcoutts_> pgavin: perhaps we don't need 6.6.1 even
09:30:36 <pgavin> dcoutts_: ok, so maybe sync up the gtk2hs release with 6.8.3?
09:30:38 <johnlunney> Turns out it's just a little wrapper for shell built-ins
09:30:45 <pgavin> dcoutts_: k
09:30:57 <dcoutts_> pgavin: we would not have to wait long I think, it'll be out soon and you can test with pre-releases
09:31:02 <FordCortina> so if ghc is having a problem linking my program to the Parsec lib it's going to be a bug with the ghc binary distribution?
09:31:29 <pgavin> dcoutts_: ok, sounds good
09:31:35 <dcoutts_> pgavin: as for gtk+ you already grabbed one from gtk.org right? they're doing all in one binary + dev header bundles now right?
09:31:57 <dcoutts_> pgavin: previously I had to make them be combining dozens of individual tarballs
09:32:01 <pgavin> dcoutts_: that's right
09:32:01 <dcoutts_> be/by
09:32:10 <pgavin> dcoutts_: yeah, they have a nice little bundle now
09:32:12 <Bonus> i've been thinking about fp and i've figured out that by its nature it encourages decoupled code since every function can work in isolation and is dependent only on the arguments it receives. i'm sure i'm not the first guy to figure this out, so does anyone know where i could read more on that?
09:32:15 <pgavin> dcoutts_: much easier :)
09:32:20 <dcoutts_> pgavin: right so just pick the latest
09:32:25 <pgavin> dcoutts_: k
09:32:38 <pgavin> dcoutts_: I actually made the directory /srv/code/gtk2hs/BRANCHES
09:32:49 <dcoutts_> pgavin: heh, ok, if you like :-)
09:32:58 <pejo> Bonus, have you read "Why functional programming matters" by Hughes?
09:33:03 <pgavin> dcoutts_: just so it stands out better :)
09:33:07 <Bonus> pejo nope :)
09:33:28 <pejo> Bonus, probably a good starting point, one of the classics.
09:33:40 <Bonus> kewl, thanks!
09:34:07 <dcoutts_> pgavin: one here noticed the other day that the links for the stock icons in our api docs are messed up, we should check that when we make the new docs. You can decide if you want to use haddock-0.9 or 2.x.
09:34:28 <pgavin> dcoutts_: haddock 2 doesn't work
09:34:35 <dcoutts_> pgavin: fine
09:34:40 <pgavin> dcoutts_: not without changing the makefile, anyways
09:34:41 <Saizan_> FordCortina: do you use --make when compiling?
09:34:47 <pgavin> dcoutts_: which I haven't bothered doing :)
09:34:57 <FordCortina> Saizan_: no
09:34:58 <dcoutts_> pgavin: I'm quite happy to stick with 0.9 for the moment
09:35:03 <conal> Bonus: also related is "Can programming be liberated from the von Neumann style", by John Backus.
09:35:10 <Saizan_> FordCortina: you should.
09:35:22 <slavik> is there a way to parallelize product[1..n] ???
09:35:25 <FordCortina> Saizan_: yes it seemed to work that time
09:35:44 <dcoutts_> slavik: yes! because * is associative
09:35:54 <mux> yay for monoids
09:36:38 <dcoutts_> slavik: you can parallelise any fold of an associative operator
09:36:52 * mux notes it should be possible to automagically parallelize monoid operations but that would probably be slow
09:37:21 <mux> like mconcatPar or whatever
09:39:48 <mux> and it could actually not be slow if we pass the number of "operations" for which it makes sense to spark a thread
09:40:09 <conal> list might not be the friendliest collection type for parallelization
09:41:10 <dolio> Poor IO monad. It has such a bad reputation.
09:41:16 <quicksilver> mux: GHC is pretty clever about sparks
09:41:23 <quicksilver> mux: it's rather cheap to spawn thousands of sparks.
09:41:54 <vixey> > let outerleave (x:y:zs) = let (ls,rs) = outerleave zs in (x:ls,y:rs) in outerleave [1..]
09:41:55 <lambdabot>  ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
09:42:09 <conal> dolio: maybe because it's imperative programming?
09:42:24 <mux> quicksilver: yes but it's still slower to spawn too many threads with respect to the number of cores
09:42:50 <byorgey> > let outerleave (x:y:zs) = let (ls,rs) = outerleave zs in (x:ls,y:rs) in outerleave [1..10]
09:42:51 <lambdabot>   Non-exhaustive patterns in function outerleave
09:43:22 <quicksilver> mux: spark != thread.
09:43:44 <quicksilver> mux: a GHC spark (which is what the par stuff works on) is just a little job of work for a thread to do when it becomes free.
09:43:45 <vixey> > let outerleave (x:y:zs) = let (ls,rs) = outerleave zs in (x:ls,y:rs) in take 3 . fst . outerleave $ [1..10]
09:43:46 <lambdabot>  [1,3,5]
09:44:00 <dolio> conal: I meant more along the lines of people attempting to 'do IO without the IO monad.' As if using it is a burden to Haskell.
09:44:01 <quicksilver> mux: those are very very cheap (much cheaper than forkIO's lightweight threads)
09:44:01 <hircus> vixey: what're you trying to do?
09:44:22 <mux> quicksilver: right but I was thinking of dons' article about parallel fibonacci and remember it was a pessimisation to spark too much
09:44:41 <mux> quicksilver: or was he using explicit threading?
09:44:46 <dsrogers> why can't I do my day job in a functional language?
09:45:44 <dcoutts_> dsrogers: drop it and go freelance :-)
09:46:16 <hircus> dsrogers: there's always Scala and F# :)
09:46:23 <dcoutts_> or apply to one of the dozens of companies advertising Haskell jobs
09:46:25 <hircus> sneak FP through the back door
09:46:35 <dsrogers> oh, we have some scheme here.
09:46:40 <conal> dcoutts_: dozens now?
09:46:54 <dsrogers> freelance is hard on a family
09:47:07 <vixey> meow meow
09:47:29 <dcoutts_> conal: several sent representatives to the the JobsInFP event and there were fliers from a few others
09:47:52 <conal> dcoutts_: glad to hear it! :)
09:48:11 <dcoutts_> conal: and a CUFP last summer a couple companies were looking to take on lots of new functional hackers
09:48:28 <dcoutts_> where lots >= 20
09:48:46 <conal> dcoutts_: any guesstimate of what proportion wanted Haskellers?
09:49:44 <dcoutts_> conal: at CUFP the biggest was erlang by something like 2:1 vs haskell and at the JobsInFP I think it was mostly Haskell I think
09:53:16 <Peaker> With -Wall:  blah^2 -- complains that 2 defaults to Integer.  What's the right way to go at it?
09:53:54 <Igloo> blah ^ (2 :: Int)
09:54:12 <dcoutts_> hia dbueno
09:54:24 <dbueno> dcoutts_ Hey there
09:54:44 <Peaker> Igloo, that's not nice, though. I have lots of these expressions
09:55:14 <dcoutts_> Peaker: you can declare the defaulting for the whole module
09:55:20 <dbueno> dcoutts_: What's up?  Just saying hi?
09:55:29 <Peaker> dcoutts, how?
09:55:30 <dcoutts_> dbueno: yep :-)
09:55:39 <b_jonas> dcoutts_: hi
09:55:44 <dcoutts_> Peaker: using the 'default' declaration
09:56:00 <Saizan_> or define a specialized ^
09:56:02 <dcoutts_> b_jonas: hello
09:56:09 <dolio> Oh good, ayrnieu's back trolling haskell articles.
09:56:13 <monochrom> <3 haskell
09:56:17 <dcoutts_> dbueno: how's the SAT translation going?
09:56:23 <dbueno> dcoutts_: Cool.  I'm off to a meeting now; I hope to have some code for testing soonish.  I'll get back to you.
09:56:25 <sclv_> oh hey have ppl looked at pierce's stuff with harmony?
09:56:35 <dcoutts_> dbueno: cool. I'm tweaking my heuristic dep resolver
09:56:40 <Peaker> dcoutts, that's not in any of the tutorials..
09:56:52 <dcoutts_> Peaker: that's because hardly anyone ever uses it
09:57:00 <Peaker> dcoutts, Saizan_: I used dx*dx eventually
09:57:08 <Peaker> (for all of these cases)
09:57:15 <dbueno> dcoutts_: I've been on vacation for a few days; just got back, and had to add "true" and "false" inputs to my circuit data type.  Now that's working, will be coding up the problem formalisation that I have (written down).
09:57:21 <sclv_> total kid-stuff in comparison, but his simple examples for strongly-typed lenses for string conversion look very handy for haskell.
09:57:28 <dcoutts_> dbueno: great
09:57:52 <dbueno> dcoutts_: Oh, btw, one of the last commits you made doesn't haddock; small problem, but, it messes up those of us who don't fully understand the code base. =]
09:58:19 <dbueno> dcoutts_: Anyway; I must be off now.
10:03:28 <dmwit> sclv_: You mean Boomerang?
10:10:43 <dsrogers> ok, so I want to build a functional representation of a log based data structure.
10:11:21 <dsrogers> is the best way for that using some inital data structure, and applying a set of functinos that maps A->A
10:11:25 <dsrogers> one for each log entry?
10:12:03 <sclv_> dmwit: yeah. obv related to fref style stuff, but i'd never read any work specifically on lenses before.
10:12:18 <dsrogers> and .... if I do that, do I risk running into stack overflow exceptions if my log gets big?
10:12:32 <sclv_> a simple combinator library for basic string conversions in haskell built on top of that looks like a nifty idea.
10:13:40 <sclv_> I guess one could try to use biarrows too...
10:14:05 <sclv_> has anyone actually done any work along these lines?
10:14:14 <Saizan_> dsrogers: you can solve that with some strictness annotations if it becomes a problem, e.g. foldl' vs foldl
10:14:17 <sclv_> (i.e. real code, not papers)
10:14:22 <Saizan_> @wiki Stack Overflow
10:14:22 <lambdabot> http://www.haskell.org/haskellwiki/Stack_Overflow
10:14:45 <dsrogers> there is no page there.
10:14:59 <Saizan_> http://www.haskell.org/haskellwiki/Stack_overflow
10:15:00 <lambdabot> Title: Stack overflow - HaskellWiki
10:18:34 <nolrai_> :t maybe
10:18:41 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:23:42 <dsrogers> huh.  is tail recursion the only form of recursion that is optimized away?
10:24:01 <sclv_> > let f = f in f
10:24:17 <lambdabot>  thread killed
10:24:17 <smg> sclv_: bot
10:24:29 <sclv_> > let f = f in f
10:24:44 <lambdabot>  thread killed
10:24:48 * sclv_ could have sworn that was "optimized" away into a <loop> exception
10:25:01 <smg> hehe
10:25:07 <smg> *** Exception: stack overflow
10:26:28 <Toxaris> sclv_: maybe it was, but since it's tail-recursive, it would have been a bad example
10:26:33 <dsrogers> when you create a copy of the stack with callCC, is that copy of the stack, actually /on/ the stack?
10:26:49 <quicksilver> dsrogers: callCC doesn't really copy the stack.
10:26:50 <nolrai_> if I get a link error in ghci, but not ghc is that a bug?
10:26:57 <sclv_> Toxaris: true that.
10:27:04 <quicksilver> it doesn't cheat by having access to haskell's runtime like it might in a lisp language.
10:27:14 <dsrogers> ah.
10:27:23 <quicksilver> rather it builds an equivalent structure by explicitly modelling the continuations
10:27:42 <quicksilver> it's a pure haskell method, requiring no runtime support
10:27:46 <dsrogers> ah
10:27:47 <quicksilver> which is quite neat, in a way.
10:27:52 * dsrogers goes and looks
10:28:14 <quicksilver> (the cheating method risks breaking referential transparency and sharing unless you are very careful)
10:28:47 <sclv_> instance MonadCont (Cont r) where callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
10:30:02 <dsrogers> my haskell is not good enough to parse that.
10:30:03 <Deewiant> @pl callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
10:30:03 <lambdabot> callCC = Cont . join . (runCont .) . (. ((Cont . const) .))
10:31:32 <Saizan_> dsrogers: essentially the Cont monad hides the explicit passing of continuation functions, like you would do in lambda calculus
10:32:59 <nolrai_> what is the Cont monad used for?
10:33:33 <dolio> Abortive continuations.
10:33:35 <Deewiant> I use it for early returning in IO-heavy code
10:33:51 <bos> @seen igloo
10:33:51 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
10:33:54 <bos> bah.
10:33:59 <Deewiant> preflex: seen igloo
10:33:59 <preflex>  igloo was last seen on #haskell 40 minutes and 4 seconds ago, saying: blah ^ (2 :: Int)
10:37:48 <nolrai_> :t (id *** (round))
10:37:50 <lambdabot> forall a b' b. (Integral b, RealFrac b') => (a, b') -> (a, b)
10:38:08 <nolrai_> :t (id &&& (round))
10:38:10 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> (a, b)
10:39:01 <nolrai_> :t (findMin &&& findMax)
10:39:03 <lambdabot> Not in scope: `findMin'
10:39:03 <lambdabot> Not in scope: `findMax'
10:39:10 <Bonus> where is &&& defined anyway
10:39:14 <nolrai_> :t (M.findMin &&& M.findMax)
10:39:16 <lambdabot> forall k a. M.Map k a -> ((k, a), (k, a))
10:39:42 <nolrai_> Bonus: Control.Arrow
10:39:43 <Toxaris> Bonus: look in Control.Arrow
10:39:48 <Bonus> ah
10:39:49 <Bonus> cheers
10:39:52 <Botje> mmm, stereo.
10:39:54 <Botje> @quote switch
10:39:55 <lambdabot> bakert says: [On text editors] The best plan is to install them all and switch between them typing one line at a time in each until you know which is best for you.  Usually it can be decided within
10:39:55 <lambdabot> a few months.
10:40:35 <Toxaris> are we quoting random things on semi-stereo answers now?
10:41:07 <Botje> aren't we?
10:42:37 <nolrai_> @pl \f (x, y) -> (f x, f y)
10:42:38 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
10:42:49 <EvilTerran> ?type join (***)
10:42:51 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
10:43:24 <EvilTerran> > join (***) f (x,y) :: (Expr,Expr)
10:43:25 <lambdabot> Terminated
10:43:29 <EvilTerran> > join (***) f (x,y) :: (Expr,Expr)
10:43:29 <lambdabot> Terminated
10:43:31 <EvilTerran> what?
10:43:37 <EvilTerran> ?bot
10:43:38 <lambdabot> :)
10:43:44 <Deewiant> > join (***) f (x, y)
10:43:44 <lambdabot> Terminated
10:43:48 <Deewiant> > (f x, f y)
10:43:49 <lambdabot> Terminated
10:43:50 <nolrai_> > a + b
10:43:51 <lambdabot>  a + b
10:43:55 <EvilTerran> > 1 + 2
10:43:55 <Deewiant> > (x, y)
10:43:57 <lambdabot>  3
10:43:57 <lambdabot>  (x,y)
10:43:59 <Deewiant> > (f x, y)
10:44:00 <lambdabot> Terminated
10:44:02 <EvilTerran> > f x :: Expr
10:44:03 <lambdabot> Terminated
10:44:04 <wjt> @undefine
10:44:05 <lambdabot> Undefined.
10:44:07 <Deewiant> > f x
10:44:07 <EvilTerran> > f x :: Expr
10:44:07 <lambdabot>  Add a type signature
10:44:08 <lambdabot>  f x
10:44:12 <Deewiant> O_o
10:44:15 <EvilTerran> ... er. what was defined?
10:44:17 <EvilTerran> > join (***) f (x,y) :: (Expr,Expr)
10:44:19 <lambdabot>  (f x,f y)
10:44:21 <wjt> someone @let f x = x ^ 2
10:44:24 <wjt> it broke the world
10:44:27 <EvilTerran> fail
10:44:31 <Deewiant> > join (***) (^2) (x,y)
10:44:32 <lambdabot>  (x * x,y * y)
10:44:50 * Peaker needs a minBy
10:44:53 <EvilTerran> don't see why that should've broken like it did, tho
10:45:16 <mauke> :t minBy
10:45:18 <nolrai_> > a ^ 2 :: Exp
10:45:18 <lambdabot> Not in scope: `minBy'
10:45:18 <lambdabot>   Not in scope: type constructor or class `Exp'
10:45:19 <dsrogers> :t runCont
10:45:20 <byorgey> maybe someone @let f x = f x
10:45:21 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
10:45:24 <nolrai_> > a ^ 2 :: Expr
10:45:25 <lambdabot>  a * a
10:45:31 <EvilTerran> > let f x = f x in f 1
10:45:47 <lambdabot>  thread killed
10:45:47 <Deewiant> > let f x = f x in join (***) f (x,y)
10:46:00 <Deewiant> what would cause "Terminated" instantaneously?
10:46:02 <lambdabot>  thread killed
10:46:28 <Peaker> @djinn (Ord b => a -> b) -> [a] -> a
10:46:28 <lambdabot> Cannot parse command
10:46:30 <mauke> Deewiant: broken execution environment?
10:46:30 <MedeaMelana> > undefined
10:46:32 <lambdabot>  Exception: Prelude.undefined
10:46:47 <mauke> @djinn (Ord b) => (a -> b) -> [a] -> a
10:47:08 <Deewiant> mauke: and why would @let f = (^2) cause that :-P
10:47:12 <Peaker> the type of minBy could either be that, or (a -> a -> Ordering) -> [a] -> a
10:47:30 <dsrogers> if I want to load Control.Monad.Cont into ghci, how do I do that?
10:47:37 <Deewiant> :m +Control.Monad.Cont
10:47:43 <Peaker> (to avoid newtype Ord just for a min call)
10:47:43 <dsrogers> why +?
10:48:04 <Deewiant> because - unloads :-)
10:48:06 <dsrogers> Prelude> :m +Control.Monad.Cont
10:48:06 <dsrogers> Could not find module `Control.Monad.Cont':
10:48:06 <dsrogers>   Use -v to see a list of the files searched for.
10:48:15 <mauke> Deewiant: no idea
10:48:26 <dsrogers> whcih is what I get without the +
10:48:32 <mauke> apparently you don't have Control.Monad.Cont
10:48:41 <dsrogers> I do.
10:48:52 <dsrogers> I can import Control.Monad.Cont from a file and it works fine.
10:49:17 <dsrogers> I just can't start up ghci with no files and then somehow load that.
10:49:55 <mauke> :-S
10:52:23 <dsrogers> oh weird.  no I don't.  not on this machine.
10:52:51 <dsrogers> hmm, what module is callCC in then, if I don't have Control.Monad.Cont?
10:53:20 <byorgey> dsrogers: you need the mtl library, perhaps?
10:53:28 <byorgey> dsrogers: how did you install ghc?
10:54:11 <mauke> dsrogers: none
10:54:13 <dsrogers> apt-get install ghc
10:54:18 <dsrogers> on this machine.
10:54:55 <byorgey> ok, then you should be able to just apt-get install libghc6-mtl-dev
10:55:12 <conal> anyone here play with associated data types?  i'm getting what i guess is an odd bug in 6.8.2 with a type family extended outside of the package that defines the family.
10:55:29 <dons> go haskell!
10:55:30 <dons> http://pithyless.com/blog/2008/05/18/hback-haskell-n-back-memory-game/
10:55:32 <lambdabot> Title: 9 Pithyless 2d  hback - A Haskell N-Back Memory Game 49, http://tinyurl.com/5n9qqv
10:55:40 <dons> first implementation of the dual n-back memory game?
10:55:45 <dcoutts_> conal: I hear the advice for any weirdness with type families is to use ghc 6.9, not 6.8.x
10:55:52 <dons> dcoutts_: and it uses gtk2hs
10:55:56 <conal> dcoutts_: thx.
10:56:26 <dcoutts_> dons: :-)
10:56:35 <dcoutts_> I'm must be being stupid, anyone familiar with graph algorithms? I seem to be calculating the depth first search number incorrectly
10:56:41 <dcoutts_> depthFirstOrder   = concatMap Tree.flatten (Graph.dff graph)
10:56:44 <dsrogers> oic.  haskell is lazy, so you can bind a future result before you have it available.
10:56:57 <dsrogers> that's extremely nifty
10:56:59 <dons> this game got a lot of coverage on the webs a few weeks ago, after it was proposed in a paper as being useful for memory training
10:57:07 <dons> so i think this might be the first real implementation
10:58:11 <mauke> dsrogers: have you seen the infinite list of fibonacci numbers?
10:58:17 <dons> which would be a bit of a coup, dcoutts_
10:58:17 <dsrogers> yes.
10:58:22 <dons> http://reddit.com/info/6lfl4/comments/
10:58:29 <dcoutts_> dons: mm
10:58:34 <dsrogers> it's one of the first exercises in the tutorial.
11:01:36 <dsrogers> understand now lazy binding works for first order fuctions is pretty easy.
11:02:06 <dsrogers> recusrive definitions like that were common in my math education.
11:02:27 <dsrogers> but understand the implications for a higher order function is mind bending
11:02:34 <dons> recent research indicates that the first thing on a language's homepage should be a link to download the implementation. i just added this  to haskell.org
11:02:38 <dons> any thoughts?
11:02:57 <nolrai_> sounds good to me.
11:03:00 <glguy> "the" implementation?
11:03:16 <dons> damn straight.
11:03:19 <dons> we are not lisp.
11:03:22 <Deewiant> :-D
11:03:29 <quicksilver> "recent research"? "should be"?
11:03:36 <quicksilver> you sound like you're running an SEO firm :P
11:03:44 <dons> :)
11:03:50 <Deewiant> (it was on reddit)
11:03:50 <quicksilver> having said that, I have no objections to a clear link
11:03:51 <quicksilver> ;)
11:03:53 <dons> "recent research" == a blogger
11:03:54 <glguy> dons is leveraging his existing core competencies
11:04:03 <dons> http://www.lispcast.com/drupal/node/29
11:04:03 <lambdabot> Title: No easy download | LispCast
11:07:22 <dsrogers> how does newtype Cont r a = Cont {runCont :: ((a -> r) -> r)} create a :t of runCont  of Cont r a -> (a -> r) -> r
11:07:56 <Deewiant> what else should it be :-)
11:08:01 <dsrogers> ie. I see the defination of a single argument function there, but it creates a two argument function.
11:08:04 <mauke> newtype X = Cont {runCont :: Y} ===> runCont :: X -> Y
11:08:24 <dsrogers> oh.
11:08:36 <dsrogers> why is that?
11:08:45 <mauke> because that's how record selectors work
11:08:50 <Deewiant> newtype Color = Color { redness :: Int }
11:08:58 <dsrogers> oh.
11:08:59 <dsrogers> ok.
11:09:10 <Deewiant> how would you get the redness of a color without giving a color whose redness to get ;-)
11:09:10 <dsrogers> I see the parallel now.
11:09:13 <dsrogers> thanks.
11:09:14 <byorgey> dsrogers: when you use record syntax like that, you automagically get a selector function with the same name as the field.
11:10:35 <dsrogers> is the only reason to use a record selector there to create the accessor?
11:10:42 <byorgey> pretty much
11:10:48 <dsrogers> ok.
11:11:09 <Deewiant> you also get the ability to pattern match on record fields
11:11:23 <dsrogers> yeah.  but it only has one field.
11:11:37 <dsrogers> so pattern matching on position is not a burden.
11:11:44 <Deewiant> f (Color { redness = 0 }) = 1
11:11:46 <Deewiant> true
11:12:06 <Toxaris>  pattern matching on record files can be less fragile then pattern matching on position
11:12:17 <Deewiant> but it can also be self-documenting as in the above (you don't necessarily need to look at the definition of Color to see what the first field is)
11:12:19 <dsrogers> I understand, but not with only one field.
11:12:27 <Toxaris> consider adding blueness later, but all the redness-aware function should keep working
11:12:28 <mauke> dsrogers: the only advantage is that you don't have to define runCont yourself
11:12:32 <dsrogers> yeah
11:12:33 <mauke> the function, I mean
11:12:43 <hajamie> hi, how would i make a zf expression for the natural numbers - ie a list of all numbers from 0 up?
11:12:54 <byorgey> I answered dsrogers' question on the assumption that it was about the definition of Cont in particular, rather than record syntax in general
11:13:12 <dcoutts_> hajamie: [0..] ?
11:13:19 <byorgey> hajamie: I'm not sure what you mean by 'zf expression'
11:13:31 <Deewiant> byorgey: I saw that and decided to generalize a bit :-)
11:13:35 <hajamie> I think that is what i meant!
11:13:41 <hajamie> Thanks :D
11:13:41 <byorgey> > [0..]  -- a list of all the numbers from 0 up
11:13:42 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:13:55 <hajamie> yeah.  sweet, thanks.
11:13:58 <mauke> :t unfoldr
11:14:00 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
11:14:24 <byorgey> > [Infinity, Infinity-1, ..]  -- a list of all the numbers from infinity down
11:14:24 <lambdabot>  Parse error at "..]" (column 24)
11:14:26 <mrd> anamorphism!
11:14:30 <byorgey> drat
11:14:42 <dolio> > reverse' [0..]
11:14:51 <mauke> > unfoldr (Just . join (,) . succ) 0
11:14:54 <lambdabot>   Not in scope: `reverse''
11:15:00 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
11:15:10 <Deewiant> > unfoldr (Just . ap (,) (1+)) 0
11:15:11 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:16:43 <dsrogers> ok .. I obviously have a lot of questions queued up here.  thanks everyone...  here I go again
11:17:12 <dsrogers> I was thinking about a haskell image processing library.
11:17:29 <dsrogers> but I see a lot of efficiency problems.
11:18:07 <dsrogers> for example, the obvious defintion of an image is Image :: (Num a) => a->a->b
11:19:04 <dsrogers> but per position access (while obviously needed for continuous images) because slow for discrete images
11:19:13 <dsrogers> s/because/becomes/
11:19:40 <dsrogers> has someone thought about this before?
11:19:50 <dsrogers> (e.g. is there some literature I can read?)
11:20:23 <Toxaris> dsrogers: http://conal.net/
11:20:24 <lambdabot> Title: Conal Elliott's home page
11:20:33 <Saizan_> there's a library built like that iirc, pancito?
11:21:38 <dsrogers> oh excellent.  that's perfect, thanks.
11:21:46 <dsrogers> well, /almost/ perfect.
11:21:55 <dsrogers> still, thanks!
11:22:18 <byorgey> dsrogers: you should definitely talk to conal about it, though =)
11:22:41 <Toxaris> there exist a bunch of Papers from Conal about exactly what you're describing
11:24:09 <nolrai_> :t maybe
11:24:10 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:26:00 <dsrogers> oh i see.  yes.  lots of stuff besides just the animations on his front page.
11:26:12 <dsrogers> excellent.
11:28:44 <nolrai_> :t reads
11:28:46 <lambdabot> forall a. (Read a) => String -> [(a, String)]
11:34:45 <dons> Cale: a job for you, http://jartur.l-square.net/2008/05/is-haskell-really-that-great-as-a-programming-language/
11:34:48 <lambdabot> Title: ~~  Blog Archive  Is Haskell really that&#8230; great as a programming languag ..., http://tinyurl.com/5txbup
11:36:44 <dsrogers> ... that post is irritating.  Haskell just forces you to express directly what you should be thinking about anyway.
11:36:53 <dsrogers> well, FP does this.
11:36:57 <dsrogers> Haskell is good at it.
11:37:22 <MedeaMelana> @pl id
11:37:22 <lambdabot> id
11:37:28 <roconnor> dsrogers: I had the experience of wanted to ask #haskell how to write a particular function.
11:37:41 <roconnor> dsrogers: but I figured I shouldn't be vauge in my question
11:37:56 <roconnor> dsrogers: so I wrote out a detailed description of my function
11:38:08 <roconnor> dsrogers: and then I realized that it was an implementation in Haskell.
11:38:08 <MedeaMelana> @pl \x f -> filter ((== x) . f)
11:38:09 <lambdabot> (filter .) . (.) . (==)
11:38:15 <dsrogers> yes, exactly.
11:38:17 <roconnor> dsrogers: so no need to ask
11:38:28 <MedeaMelana> lambdabot: uh-oh
11:38:33 <dsrogers> I write proofs for my methods.
11:38:51 <dsrogers> it doesn't occur to a lot of programmers that they should have to prove that their methods work...
11:39:23 <dsrogers> translating my declaritve proof to an imperitive language is often non-trivial
11:39:25 <Peaker> a mathematical vector isn't a Num, right?
11:39:34 <Peaker> (if it is, what is the abs?)
11:39:35 <dsrogers> it's a tuple of nums.
11:39:58 <roconnor> Peaker: yeah, but sometimes we are so desparate for + and * we make Vectors an instance of Num
11:39:59 <dsrogers> but yes, (Num) is just a trivial vector.
11:40:10 <Peaker> roconnor, but then what's abs defined to?
11:40:12 <roconnor> well +
11:40:23 <roconnor> Peaker: undefined
11:40:25 <Peaker> roconnor, I need + and - and not sure what I can use
11:40:29 <dsrogers> sqrt(a^2)
11:40:42 <dsrogers> just the case of a vector with a single dimension.
11:40:46 <Peaker> roconnor, maybe Num ought to be split?
11:40:57 <roconnor> Peaker: there have been proposals
11:41:00 <Peaker> @type abs
11:41:02 <lambdabot> forall a. (Num a) => a -> a
11:41:13 <Peaker> does that make sense? Maybe abs needs to be (Num a, Num b) => a -> b?
11:41:36 <Peaker> or maybe abs should be in a separate (non-Num) class and return a Num?
11:41:59 <Peaker> -Wall yells at me for all the undefined methods
11:42:18 <dsrogers> you probably want to go more general.  and create a "Field" class.
11:42:27 <Peaker> what's signum?
11:42:28 <dsrogers> and put + and * into the Field.
11:42:50 <Peaker> dsrogers, what about -?
11:43:07 <dsrogers> - can be defined in terms o f+
11:43:14 <dolio> Num is closer to rings than fields.
11:43:24 <dolio> Fields have division.
11:44:06 <dsrogers> yeah, a lot of Num's are not closed under division
11:44:29 <roconnor> @type signum
11:44:30 <lambdabot> forall a. (Num a) => a -> a
11:44:40 <roconnor> Peaker: signum is the normalized vector
11:44:47 <roconnor> or 0 for the 0 vector
11:44:57 <dolio> And then there's currently Integral, with integer division, and Fractional with fractional division.
11:45:05 <dsrogers> yeah.
11:45:27 <Peaker> dsrogers, with only + how do you define -?
11:45:47 <Peaker> dsrogers, a-b = a+(-1)*b ?  But -1 does not exist?
11:45:50 <dolio> The real problem is that in general, you probably want, say, Monoid (or perhaps something slightly more general) at the base of your numeric tower.
11:45:50 <dsrogers> but if you're going to start pushing numerical oerations into their own classes, the best way to do it would be to start looking a groups, rings and fields
11:46:09 <dsrogers> yes it does.  -1 is the + identity of 1
11:46:16 <dsrogers> that's how you define negative numbers.
11:46:22 <dolio> But then Monoid => Group => ...
11:46:27 <dolio> Er...
11:46:34 <Peaker> dsrogers, but then my vectors are not a Field?
11:46:46 <dsrogers> vectors are usually a field.
11:46:56 <dolio> When you get to Ring, it's both a Group (Monoid) for addition and a Monoid for multiplication.
11:47:19 * chessguy gets a second phone call from Microsoft
11:47:32 <Peaker> chessguy, btw: Did you check out my chess gui thing?
11:47:44 <chessguy> nope
11:47:46 <dolio> So you need AdditiveMonoid => AdditiveGroup => Ring and MultiplicativeMonoid => Right. But that gets into a lot of duplication.
11:48:05 <roconnor> vectors are usually not a field.
11:48:10 <Peaker> chessguy, are you interested in seeing an SDL gui to my chess move generator?
11:48:12 <chessguy> Peaker: where?
11:48:25 <roconnor> although vectors have a field as an associated type
11:48:41 <Peaker> chessguy, http://nextflow.dyndns.org/chess.tgz
11:48:41 <dolio> And that doesn't address Monoids that you might not want to call either Additive or Multiplicative (which one describes lists?).
11:50:02 <chessguy> Peaker:  what's this MapManyToOne?
11:50:22 <Peaker> chessguy, a reversible map that lets you find all keys matching a value
11:50:34 <chessguy> Peaker:  why not just use BiMap?
11:50:46 <Peaker> chessguy, it requires unique keys
11:50:54 <nolrai_> :t fmap fst . listToMaybe
11:50:56 <lambdabot> forall a b. [(a, b)] -> Maybe a
11:51:12 <Deewiant> :t (fst .) . listToMaybe
11:51:13 <lambdabot> forall a b. [(a, b)] -> Maybe a
11:51:36 <nolrai_> huh!?
11:51:49 <nolrai_> :t (fst .)
11:51:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> f a
11:51:56 <dsrogers> oh right.  vectors don't really have multiplicative inverses.
11:52:21 <nolrai_> :t fmap fst
11:52:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> f a
11:52:53 <dsrogers> hmm, but,  you can make a non-communicative field with cross-product as *
11:52:59 <nolrai_> . == fmap in \bot
11:53:02 <dolio> (foo .) . bar = \x y -> foo (bar x y)
11:53:18 <byorgey> nolrai_: without that extension, (fst .) . listToMaybe doesn't typecheck
11:53:38 <bos> hmm, it's a shame that i can't get at the unboxed representation of words.
11:53:54 <bos> GHC.Word doesn't export W32# and friends.
11:53:56 <dolio> You can't?
11:54:06 <dolio> Huh.
11:54:18 <bos> an oversight, i think.
11:54:32 <dolio> Sounds like it.
11:54:45 <chessguy> Peaker:  have you done any actual testing yet?
11:56:00 <Peaker> chessguy, not vs. real move counts.. I played with it and it seems to do everything right ;)
11:56:05 <dsrogers> ﻿Peaker: look at peano numbers, or just number theory in general.
11:56:20 <Peaker> dsrogers, I will at some point, right now I just wanted + and - defined on vectors ;)
11:57:44 <Peaker> chessguy, I have the only chess GUI I know that shows you the valid pieces that can move at any given turn
11:58:28 <Peaker> I have kind of a funny hack to allow choosing which piece pawns can become (which part of the top/bottom square you land on :-)
11:58:55 <chessguy> Peaker:  there are a ton of edge cases though
11:59:49 <Peaker> chessguy, Examples?
11:59:57 <chessguy> here we go again
12:00:03 <chessguy> why can't you just take my word for it
12:00:33 <Peaker> chessguy, I'd just like to try out some of them to see if I handle them right
12:00:43 <Peaker> chessguy, doing a real move count comparison is too much of a hassle :)
12:00:58 <chessguy> Peaker:  fine, then talking to you is too much of a hassle
12:01:10 <Peaker> chessguy, k, sure. Try out the GUI though ;)
12:01:47 <chessguy> i don't care about a GUI. that part is solved, if you ahve a good library
12:02:37 <hajamie> how do I :load Char  in my .hs file?
12:02:49 <chessguy> import Data.Char
12:02:56 <hajamie> sweet, thanks
12:03:52 <hajamie> i still get Undefined variable "islower"
12:04:06 <chessguy> isLower
12:04:08 <chessguy> @hoogle isLower
12:04:09 <lambdabot> Data.Char.isLower :: Char -> Bool
12:06:57 <byorgey> hajamie: Haskell is case-sensitive
12:07:53 <dolio> We should switch to case insensitive.
12:08:16 <dolio> Then we could get quality error messages like "Undefined variable 'ISLOWER'".
12:08:40 <MedeaMelana> Haskell relies on case for deciding if you mean variables or types/classes
12:08:54 <shapr> yarr!
12:09:03 <dolio> @yow!
12:09:04 <lambdabot> TAILFINS!! ... click ...
12:09:13 <hajamie> It works!  Thanks again!
12:09:25 <shapr> @quote
12:09:25 <lambdabot> Binkley says: [Monads as clothes] <Binkley> using unsafePerformIO is kind of like going naked in public, might be safe in some contexts, but you really don't want to know what happensif you do it in
12:09:25 <lambdabot> a really bad one
12:09:36 <shapr> heh
12:09:49 <dolio> @quote qwe1234
12:09:49 <lambdabot> qwe1234 says: the lisp folks have purposefully made lisp so that static analysis is impossible.
12:10:16 <roconnor> That only makes sense because Binkley is from Berkeley
12:10:21 <roconnor> or was in Berkeley
12:10:24 <ikegami--> I'm reading Benjamin's latest slides :) http://www.cis.upenn.edu/~bcpierce/papers/harmful-mfps.pdf
12:10:26 <ikegami--> lol
12:14:22 <byorgey> haha!  * two PhD's for Haskell
12:18:46 <dons> where's that, byorgey ?
12:18:52 * shapr hugs dons
12:18:57 <shapr> Yay Haskell!
12:18:59 <dons> woot!
12:19:13 <byorgey> dons: p. 21
12:19:57 <byorgey> man, where does he find all these great pictures?
12:20:31 <byorgey> note: rhetorical question, please do not answer "the internet" =)
12:20:35 <Peaker> is Float as big as a C float or a double? if a float, what's a double?
12:21:07 <bd_> Peaker: If you need C floats or doubles specifically, use CFloat and CDouble
12:21:09 <bd_> @hoogle CFloat
12:21:10 <lambdabot> Foreign.C.Types.CFloat :: data CFloat
12:21:18 <bd_> > (1 + 2) :: CFloat
12:21:19 <lambdabot>   Not in scope: type constructor or class `CFloat'
12:21:28 <bd_> hmm. lambdabot doesn't allow it
12:21:31 <byorgey> who uses Float anyway?
12:21:31 <mrd> ghc Float and Double should correspond to IEEE single and double
12:21:36 <bd_> > (1 + 2) :: Foreign.C.Types.CFloat
12:21:37 <lambdabot>      Not in scope: type constructor or class `Foreign.C.Types.CFloat'
12:21:44 <Peaker> bd_, I just need as much precision as possible
12:21:54 <mrd> Rational
12:22:07 * mrd cackles maniacally
12:22:08 <Peaker> I need to sqrt on it and stuff ;)
12:22:39 <zenon> Those are some funny slides :D
12:23:09 <shapr> @quote dons
12:23:09 <lambdabot> dons says: that's 3 things i've never seen in the one sentence before: my assembler .. a bunch of type classes .. a natural syntax
12:23:14 <shapr> hah
12:23:16 <shapr> @quote conal
12:23:17 <lambdabot> No quotes match. My mind is going. I can feel it.
12:23:19 <shapr> aww
12:27:05 <dons> shapr: hey, have you seen http://headrush.typepad.com/creating_passionate_users/2006/04/angrynegative_p.html ?
12:27:06 <lambdabot> Title: Creating Passionate Users: Angry/negative people can be bad for your brain, http://tinyurl.com/k492v
12:27:10 * shapr looks
12:27:22 <dons> i was just rereading it after a couple of years since i last tried it. still useful
12:27:30 <shapr> Good stuff
12:27:32 <shapr> And so very true..
12:27:48 <shapr> dons: Did you see the creativity thread on my blog?
12:28:08 <dons> oh, no?
12:28:18 <shapr> In short, I was convinced that closed systems deprived people of creativity, but I had my hypothesis shot down by my mother.
12:28:29 * mahogny is a health hazard :(
12:28:34 <shapr> So I decided I should try to connect creative communities instead.
12:28:38 <shapr> mahogny: Be nice, it's good for you!
12:28:59 <shapr> So I'm trying to make a boston-local fusion of Arduino, XO and BUGlabs communities.
12:29:01 <dons> hang around optimistic people. it helps get things done!
12:29:05 <shapr> Yes it does!
12:29:16 <shapr> And don't be afraid to fail, it's a great way to learn stuff.
12:29:19 <mahogny> shapr, my hate toward the current systems is my driving force to keep working and replace them :P
12:29:30 <shapr> mahogny: Well, just don't use it on other people.
12:29:41 <mahogny> I use it on my competitors <:)
12:29:50 <CosmicRay> heh.  I was just watching the SPJ lecture at http://www.foomongers.org.uk/videos/spj-typedriventestinginhaskell.html.  He says "'Monad' is probably an unfortunate name because it makes you think they're esoteric.  Really, they just let you write C in Haskell."
12:29:51 <lambdabot> Title: Type-driven testing in Haskell (Simon Peyton Jones), http://tinyurl.com/2u2mtq
12:30:10 <shapr> Type driven testing is a cool idea!
12:30:22 <CosmicRay> shapr: yep, it's a lecture about quickcheck
12:30:37 <zenon> Is is the same as quickcheck? Or something else?
12:30:45 <CosmicRay> it is the quickcheck
12:30:50 <zenon> Ah, okay.
12:30:57 <dons> we all love the quickchecks
12:31:07 <zenon> Have to keep up with all new terminology
12:31:27 <dons> shapr: did you see http://pithyless.com/blog/2008/05/18/hback-haskell-n-back-memory-game/
12:31:28 <lambdabot> Title: 9 Pithyless 2d  hback - A Haskell N-Back Memory Game 49, http://tinyurl.com/5n9qqv
12:31:42 <Cale> dons: got it :)
12:31:49 <dons> i think its so cool a new guy hacked up the first (i think) instantiation of a new paper on improving memory, in haskell, with gtk.
12:31:55 <dons> Cale++
12:32:35 <Cale> dons: my comment is fairly long even :)  It's awaiting moderation yet, so you might not see it.
12:32:36 <shapr> Oh hey, edwardk told me about an idea of his that is cooler than QuickCheck, white box something testing.
12:33:04 <mercury^> white box is not always possible
12:33:07 <shapr> dons: Cool game, I gotta try that.
12:33:10 <shapr> mercury^: Yeah, but when it is...
12:33:16 <shapr> It's like partition testing but better.
12:33:23 <shapr> edwardk found it in a microsoft research paper.
12:33:30 <shapr> It could be done with TH.
12:33:52 <shapr> I'll have to ask him about the details next time I see him.
12:33:57 <shapr> (probably this evening)
12:34:08 <CosmicRay> dons: whoa, SPJ recommended our book at 79:37 at that URL
12:34:15 <dons> woot!
12:34:17 <CosmicRay> dons: though he thought it was you, bos, and dcoutts working on it ;-)
12:34:22 <dons> doh!
12:34:27 * dons will have words with SPJ
12:34:34 <CosmicRay> I think I should /nick AnonymousHacker :-)
12:34:36 <dons> hehe
12:34:43 <shapr> haha
12:34:59 <CosmicRay> nobody ever expects a rural Kansan to use Haskell.
12:35:02 <shapr> I recommended your book to several people who recently asked me for in-person advice on learning Haskell.
12:35:02 <Gilly> Cale: did i understand you correctly if i say you commented that "Is haskell really that..."?
12:35:09 <Cale> Gilly: yes
12:35:11 <shapr> Nobody expects the Kansas Inquisition!
12:35:16 <shapr> Bah, dentist time...
12:35:17 <CosmicRay> hehe
12:35:20 <dons> CosmicRay: well, andy gill's also out in kansas now, or soon to be.
12:35:24 <CosmicRay> really
12:35:30 <dons> so KU is going to be a new haskell center of excellence
12:35:35 <Gilly> ok, thanks :) waiting for it to get through so i can read your comment *G*
12:35:46 <CosmicRay> dons: that's within driving distance for me.
12:35:48 <Cale> CosmicRay: That claim regarding monads actually bothers me quite a lot. That's what the *IO* monad lets you do, not what all the rest of them are for.
12:35:55 <CosmicRay> dons: also close to, ironically, Haskell University
12:36:12 <dons> CosmicRay: I'll ping Andy. I think he's keen to find out more FP hackers in the area
12:36:25 <CosmicRay> Cale: yeah I know.  He was answering in the context of a question from the audience asking if "this monad thing" is the answer for how you do GUI programming in a pure language
12:36:48 <Cale> I figured there would be some context in which the comment would be appropriate :)
12:37:00 <dons> CosmicRay: btw, i've been enjoying your blog stuff about cycling.
12:37:05 <sjanssen_> dons: is he teaching at KU?
12:37:15 <dons> sjanssen_: yeah
12:37:30 <dons> there'll be a lot of haskell stuff happening there soon, i think
12:37:38 <CosmicRay> dons: oh, thanks.  I hope to start doing it regularly next week.  I must say, it would be really nice to be a cyclist in portland.
12:37:45 <CosmicRay> dons: that is great to hear
12:37:59 <dons> CosmicRay: yeah, its pretty much compulsory in portland
12:38:01 <Cale> But yeah, it's especially disturbing to confuse the IO monad for the monad abstraction itself because if you're only looking at any one monad, the fact that it is a monad is unimportant.
12:38:24 <dons> actually, pweaver was from KU, he's a new hacker at galois.
12:38:38 <dons> so there's something of an underground haskell movement in kansas
12:38:55 <zenon> why underground?
12:39:11 <CosmicRay> zenon: it's so underground none of us know it exists
12:39:12 <dcoutts> because the surface of kansas is dull?
12:39:14 <dons> well, they're quiet.
12:39:20 <zenon> I believe Haskell has a pretty strong stand in all learning institutions?
12:39:33 <CosmicRay> zenon: http://www.undergroundmuseum.org/
12:39:34 <lambdabot> Title: Untitled Document
12:39:34 <zenon> dcoutts: okay.
12:39:40 <dons> dcoutts: you can't talk, coming from south dakota...
12:39:53 <Cale> zenon: In Europe and Australia at least. In North America, not as much.
12:40:21 <dons> there's an awfully rich density of haskell hackers in portland, OR though.
12:40:24 <dcoutts> dons: a but my mum came from the hilly bits of south dakota and was most scornful of the flatlanders
12:40:25 <dons> so there are clumps
12:40:28 <zenon> vive la recistance then, go haskell!
12:40:32 <dons> dcoutts: ah hehe
12:40:44 <CosmicRay> from what I hear from people I know in academia, there is a strong movement in undergrad CS classes to use languages used in industry, esp. Java
12:41:13 <zenon> I can say there is a lot of Java in CTH - Gothenburg
12:41:16 <Cale> The university I went to for undergrad (Waterloo) used primarily Java, due to the influence of its co-op program. However, I hear that they've started up a track in which students use Scheme instead now.
12:41:18 <shepheb> there's a fair bit of Haskell love at some NA institutions. but more the traditional hackerly ones. the "learn Java and be a code grinder" places obviously not so much
12:41:44 * dons compiles some more haskell for the government. viva industrial haskell!
12:41:45 <shepheb> Cale: I was about to say, there's a fair bit of Haskell love in the undergrad CS club at Waterloo
12:42:16 <mahogny> I heard the case with CTH is that early classes need java in many undergrad courses, and haskell not until grad. and then when all foreign students come who have no idea about haskell, it becomes a mess overall
12:42:24 <Cale> shepheb: That's interesting. I was always trying to push it when I was there, but wasn't getting much traction.
12:43:03 <Cale> But I suppose Holden learned it at least to some extent (?)
12:43:20 <shepheb> Cale: well, the current president is a fan. there have been a few CSC-hosted talks. I'm trying hard to spread the word, too.
12:43:26 <Cale> cool.
12:43:29 <zenon> mahogny: Yeah well, CS students get a lot of haskell first year, and I have also heard a lot about foreign students having a hard time when Haskell is used widely in other subjects =/ . Kind of messy
12:43:36 <dolio> Oh come now, dons, everyone knows that all time spent on Haskell is just useless playing with nothing to show for it in the end. </ayrnieu>
12:43:38 <shepheb> it's a pain when everyone keeps leaving for co-op and back
12:44:05 <dolio> We should all use Oz instead.
12:44:05 <dons> dolio: hah
12:44:09 <dons> yeah, ayrnieu's a grump
12:44:10 <CosmicRay> incidentally, I have begun work on porting OfflineIMAP to Haskell.  I want to make it usable as a library as well.  my first task is to write a generic bidirectional syncing framework.  I currently take state1, state2, and the final state after the last sync and produce a list of modifications to make to state1 and state2 to bring them into sync.  is anyone aware of code or literature in this area?
12:44:14 <zenon> dolio: Actually, I think it is a gr8 way to learn the core of CS
12:44:26 <mahogny> zenon, I'd say, give a warning about haskell to all foreign students ahead of time. one cannot allow this useless(?) exchange to drag down the level of our education
12:44:39 <dolio> zenon: Which, Haskell or Oz?
12:44:53 <zenon> dolio: haskell
12:45:20 <zenon> mahogny: Yeah I agree. All courses using Haskell should clearly state the importance of knowing haskell OR there should be some other way .
12:45:23 <dolio> I don't know. Writing befunge programs might be more practical... :)
12:45:33 <zenon> mahogny: I really don't know... hmm.
12:45:40 <mahogny> have them code haskell for a while, prove properties about some code. then let them prove properties about C code. then they will understand the core of CS
12:45:46 <Cale> Haskell is a really nice language to start with in CS, I think. There's almost no clutter.
12:46:06 <Cale> Java is horrifying in that regard.
12:46:14 <zenon> Cale: I agree,, how nice that all haskell lovers love haskell :D
12:46:15 <mahogny> the last thing you want in a first intro class is tons of syntax
12:46:30 <mahogny> Cale, agreed. I hate teaching it. not even the lecturer knew all the syntax
12:47:03 <mahogny> and our standard java book even teaches buggy java programing >_< (skansholm)
12:47:11 <Cale> Like, I wouldn't mind a really clean and simple imperative language so much either. Python comes close in certain respects and falls down in others.
12:47:28 <araujo> Cale, Haskell
12:47:30 <araujo> :-P
12:47:35 <Cale> For teaching CS, you want to minimise the amount of crap which is specific to the particular day and age.
12:47:37 <zenon> What I love the most with haskell is that you can punch in the whole notion of functions, function properties, sets and set operations so easily, just as a by-product of using Haskell
12:47:48 <Cale> araujo: I suggested Haskell first.
12:48:09 <Toxaris> Cale: Pascal?
12:48:13 <Cale> zenon: I like the fact that the definition of a function in Haskell agrees with the mathematical definition.
12:48:18 <Cale> Toxaris: Pascal is not terrible.
12:48:26 <araujo> Cale, oh sorry, I thought you were going to the dark side
12:48:31 <Cale> Toxaris: In fact, that's what we used in highschool.
12:48:45 <zenon> List comprehension! Come an, who does _not_ like list comprehensions? It is basically lik the set syntax in mathematics! So gr8
12:49:02 <araujo> what about monads?
12:49:06 <araujo> we all love them
12:49:25 <byorgey> I taught a year of intro CS at the high school level using Pascal, and I have to say I did not enjoy the experience.
12:49:26 <mahogny> imperative programming in a nutshell: dedicate one week in the intro course to for() and arrays, the week after to make them understand that you can use arrays without for()
12:49:34 <Cale> Monads were a concern when I talked to some professors about putting Haskell into the curriculum.
12:49:37 <byorgey> then I taught another year using scheme which went a lot better.
12:49:52 <Toxaris> zenon: you know, not everyone actually likes mathematics. to be more procise, about 99% of the world population hates mathematics
12:49:58 <Toxaris> zenon: "precise"
12:49:58 <byorgey> but in the end I have come to the conclusion that all languages suck for teaching intro CS.
12:50:10 <chessguy> hear hear
12:50:11 <Cale> It takes a bit of finesse to teach CS properly in Haskell without getting dragged into a discussion about monads at some point.
12:50:11 <zenon> Toxaris: I love you totally scientific numbers there ;)
12:50:11 <byorgey> it's just that some suck less than others.
12:50:22 <mahogny> Toxaris, the more reason to make up for it
12:50:36 <Cale> (It can be done, certainly!)
12:51:07 <zenon> <80% of all statistics in a conversation are made up > <--- my favourite joke
12:51:10 <byorgey> maybe Dijkstra was right after all.  don't give the students actual computers until the second or third year. =)
12:51:16 <Toxaris> mahogny: but then it's "look how cool Haskell is, math is similiar", not the other way around
12:51:20 <chessguy> zeno:  did you make that joke up? :)
12:51:37 <zenon> chessguy: No, just passing it on ;)
12:51:42 <Cale> I find it interesting that Simon is giving talks on type-driven testing, of all the things he could be talking about :)
12:51:42 <zenon> Spread the word
12:52:00 <chessguy> hm, that sounds interesting
12:52:04 <dolio> byorgey: I think it's too late for that. Most students in general have laptops these days. :)
12:52:13 <zenon> dolio: true ;)
12:52:17 <Cale> I suppose it's the ideal advertising-for-haskell sort of thing to talk about, because it's an approachable topic for outsiders.
12:52:21 <Peaker> hmm.. I have an existential list type:  type World = [forall a. Object a => a] -- and I try to create a value of that type [Sphere { ... }] but it doesn't let me be more specific than World is
12:52:22 <noecksit> oh snap, i just found the "Programming in Haskell" book by Graham Hutton in the ACM library, i am so happy :)
12:52:30 <mahogny> Toxaris, just hide the math is similar part and let them discover it themselves
12:52:46 <dolio> Peaker: That's not existential.
12:52:49 <slarba> http://www.cis.upenn.edu/~bcpierce/papers/harmful-mfps.pdf b. pierce has gone mad
12:52:53 <slarba> :D
12:53:05 <Cale> But I'd like to see him give a talk about types :)
12:53:07 <Toxaris> mahogny: yep, what I said. That Haskell is similiar to math is great, but its not a selling point for Haskell (given a general target audience, not geeks)
12:53:15 <Peaker> dolio, why? There are type variables on the right side which aren't on the left
12:53:17 <Cale> Toxaris: For teaching, I think it is.
12:53:29 <sclv> is tapl as conversational as b. pierce's talks/papers?
12:53:35 <byorgey> dolio: just wrap a big coil of wire around the door to the lecture hall, and run an electric current through it.
12:53:38 <zenon> I think the greatest problem is that students with a hard time accepting functional programming have a harder time accepting it since "haskell can't do any real things" (like someone said a while ago)
12:53:41 <dolio> Peaker: That's actually a universal type. So [forall a. Object a => a] means that it's a list of things that can be instantiated to any type in the Object class.
12:53:53 <Cale> sclv: It's as conversational as I suspect you can get with that subject matter.
12:53:55 <zenon> And... well, the lecturers owe themselves the credit for that criticism
12:54:02 <byorgey> sclv: it's not quite so informal, but it's still quite readable IMO
12:54:09 <Toxaris> Cale: hmm yes, actually, how are such things decided? who decides them?
12:54:13 <Peaker> dolio, hmm - so why can't I create such a list via [SomeSpecificInstanceOfObject] ?
12:54:16 <sclv> i really need to get myself a copy.
12:54:25 <Cale> Toxaris: What language to use in a university?
12:54:30 <dolio> Peaker: A proper existential type would be: 'data World = forall a. Object a => World [a]'
12:54:31 <psygnisfive> would you consider IO to be side effects?
12:54:35 <Toxaris> Cale: yes.
12:54:36 <Cale> psygnisfive: yes
12:54:52 <Toxaris> Cale: or more generally, what to teach to the students in a specific course.
12:54:54 <Peaker> dolio, what's a universal type useful for? How can you create values of a universal type?
12:55:07 <dolio> Peaker: You can't actually use 'type' to make an existential type (existentials aren't first class in GHC).
12:55:09 <chessguy> noecksit:  are you talking about http://portal.acm.org/toc.cfm?id=SERIES11430&type=series&coll=ACM&dl=ACM ?
12:55:11 <lambdabot> Title: TOC, http://tinyurl.com/3xpzf6
12:55:27 <Cale> Toxaris: As far as I know, it's largely decided collectively by the professors, but there's also some pressure from companies that provide financial support to the university and/or companies that hire co-op students.
12:56:01 <dolio> Peaker: Universal is for parametric polymorphism. For instance [2] can be typed as '[forall a. Num a => a]
12:56:18 <Cale> Toxaris: You can probably tell a lot about the ideals of a university by the choice of programming languages. :)
12:56:23 <mercury^> Cale: hback seems pretty nice
12:56:25 <Toxaris> Peaker: consider the identity function
12:56:39 <Peaker> dolio, ok, I don't understand but I see how to resolve my issue at least :) Thanks
12:56:50 <dolio> Peaker: Which means that you could do '(head [2] :: Int, head [2] :: Float)'.
12:57:54 <Peaker> dolio, I see, but that's because literal numbers are not specific types - when I have some specific type, any way to put it into a universally-typed list?
12:58:16 <ehird> peaker is still trying to get homogenous lists i see
12:58:23 <ehird> how many weeks now?
12:58:28 <dolio> Peaker: Not unless you have something similar to fromInteger (which is how numeric literals become polymorphic).
12:58:32 <mercury^> Cale: what would be the common level, what is your peak?
12:58:45 <Cale> mercury^: hm?
12:59:46 <Cale> mercury^: You're referring to that memory game someone wrote in Haskell?
12:59:46 <Toxaris> Cale: Hehe I come from a Java place, spiced with some bits of Scheme, Assembler and VHDL (!), but I managed to learn Prolog and Haskell there, too, by careful selection of lectures. Now I moved away to the place where they make gBeta. Does that tell something about my ideals?
12:59:46 <Cale> mercury^: I haven't tried it.
12:59:46 <Peaker> dolio, so I can use a function to lose the specifity of my type and then use it?
12:59:46 <Cale> Toxaris: :)
12:59:46 <mercury^> oh
12:59:46 <mercury^> thought it was you who wrote it
12:59:46 <mercury^> my mistake there
12:59:48 <mercury^> so, who wrote it? :>
12:59:48 <zenon> Someone mentioned Integer ?
13:00:49 <dolio> Peaker: well, what you need is some function that takes some concrete type and produces something of any arbitrary type of the class.
13:01:17 <zenon> I usually try to go Integer and never use Int
13:01:21 <zenon> really
13:01:29 <Peaker> dolio, oh, I see! thanks
13:01:42 <dolio> Then, when you apply that function to your concrete type, you effectively get back something that can be instantiated to any member of the class.
13:01:43 <Cale> mercury^: Someone apparently named Norbert.
13:01:45 <Peaker> dolio, Haskell's type system (with the extensions) is crazy
13:01:59 <dolio> At least, when you have higher-rank polymorphism.
13:02:39 <dolio> I think part of the original confusion is that the GHC extension opted out of adding an 'exists' keyword.
13:02:49 <Toxaris> yeah, the absence of a 'exists' keyword really hurts
13:03:18 <Cale> I don't know so much about that. When defining existential types, I just always use the GADT syntax.
13:03:37 <dolio> Well, there is that.
13:04:02 <Toxaris> consider the vast amound of research possibilities: "This paper shows how to change Haskell to made exists work in one more place it didn't work before"
13:04:02 <Deewiant> > [Just 1, [1]] :: (Monad m => [m Int]) -- is something like this possible?
13:04:03 <lambdabot>  Parse error at "=>" (column 27)
13:04:16 <dolio> But in the absense of that, I think it's hard when you're first learning to think about why, for example, 'type Foo = forall a. Bar a => a' fails.
13:04:21 <Cale> Deewiant: yes
13:04:39 <Cale> Deewiant: but you have to wrap the elements in a constructor
13:04:59 <zenon> Does lambdabot parse all haskell code after > ?
13:04:59 <Cale> Deewiant: and (exists m. m Int) is a pretty useless type
13:05:01 <dolio> Because it's equally the type version of 'data Foo = forall a. Bar a => Foo a' and 'data Foo = Foo (forall a. Bar a => Foo a)'.
13:05:20 <Deewiant> Cale: just wondering, came to mind from Peaker's lists discussion
13:05:32 <dolio> But it's the latter, merely because existentials aren't first class.
13:06:12 <Cale> data Monadic a where M :: (Monad m) => m a -> Monadic a
13:06:37 <dolio> If there were an exists keyword, 'type Foo = exists a. Bar a => a' could at least give a sensible error message.
13:06:40 <Cale> Forgetting which monad a computation comes from is a pretty silly thing to do, but that's how you'd do it.
13:08:04 <Cale> *Main> :t [M [1], M (Just 1)]
13:08:04 <Cale> [M [1], M (Just 1)] :: forall t. (Num t) => [Monadic t]
13:08:42 <Cale> Unfortunately, the one-way nature of monads makes those values pretty useless.
13:08:57 <Cale> Comonadic computations on the other hand might be interesting to do that with.
13:09:10 <Cale> Because you can at least extract.
13:09:49 <Rapiere>  h
13:09:49 <zenon> To get back to the issue of learning haskell in undergrad: Should the lecturers not press on harder with monads ? Why leave it out / wait? That only hypes it up more.
13:10:35 <Cale> zenon: Well, if you really want to do things right, you follow SICP's lead and teach the concept of a combinator library.
13:10:36 <Toxaris> Cale: why not just extract and pass the result around?
13:10:53 <Cale> zenon: At that point, monads become a footnote as a specific type of combinator library.
13:10:56 <proq> I got hugs running on my zaurus and there seems to be a shocking lack of compatibility with ghc. it reminds me of guile <-> mzscheme incompability
13:10:58 <CosmicRay> shapr: enjoyed your swedish blog post
13:10:59 <Cale> Toxaris: exactly, yes.
13:11:22 <Cale> Toxaris: duplicating won't get you anywhere, so it's not very useful.
13:11:44 <Cale> proq: hm?
13:11:47 <CosmicRay> shapr: my third blog post ever was http://changelog.complete.org/posts/3-Scaring-Swedes-the-Coleman-Way.html
13:11:48 <lambdabot> Title: Scaring Swedes the Coleman Way - The Changelog, http://tinyurl.com/6bjyt2
13:12:06 <zenon> Cale: Why not going from the monad laws directly?
13:12:07 <Cale> proq: If you stick to Haskell 98, there's compatibility, beyond that, it's not guaranteed.
13:12:18 <zenon> Cale: I realise that was a stupid question
13:12:47 <Cale> zenon: Because, well, that'll help you define what a monad is, mathematically, but it doesn't tell you what it is in the context of computer science.
13:13:09 <Toxaris> zenon: Monads are not the important point about programming and computer science, so why waste time with them in the beginning?
13:13:45 <zenon> Cale: Yeah, I realized that ;) But still, it would take a lot of the hype of. Just show the barebone rules. And that's it.
13:14:03 <zenon> So everything abiding those rules is a monad. end. period.
13:14:06 <Cale> zenon: I think that mostly just makes people confused.
13:14:32 <Cale> It is totally unclear why, just from those rules, you should ever want to recognise that something is a monad, even.
13:14:38 <zenon> Toxaris: Sure. True. Maybe that could be tweaked depending on how much your school uses Haskell
13:14:50 <dsrogers> arg.  do continuations and closures get easier to read if I stare at them long enough?
13:15:12 <Cale> dsrogers: Are you looking at a compiler implementation?
13:15:14 <proq> zenon: if you are really hyping it up, they will go ahead and look into it on their own time
13:15:36 <dsrogers> Cale: I'm just looking at code in the stardard library.  I'm trying to think in haskell.
13:15:47 <Cale> dsrogers: (closures are an implementation detail for first-class functions, they're not visible to the programmer)
13:16:04 <dsrogers> I'm trying to make sense of the definition of callCC
13:16:05 <zenon> proq: I don't know. It seems lecturers slip it out by accident, and then everyone is scared, because of the ungraspable-super-abstract monads. Which is silly.
13:16:09 <Cale> dsrogers: ah, okay
13:16:27 <dsrogers> and I can't read it and tell you that it makes sense or does what I want.
13:16:29 <Toxaris> zenon: from my POV, the complicated thing about monads in Haskell are not the monad laws, but the fact that it's a type constructor class, which is a quite advanced concept.
13:16:41 <Deewiant> dsrogers: neither can I, but amazingly it seems to work regardless ;-)
13:16:58 <dsrogers> well, if I can't read the code, how am I supposed to write in in?
13:17:00 <dsrogers> err, it
13:17:10 <Peaker> [(a, long expr of a here) | a <- blah, long expr of a here] -- how to use let/where to share long expr of a there?
13:17:11 <dsrogers> in no imperative language to I have this problem.
13:17:19 <Deewiant> that's a rather esoteric piece of code IMHO
13:17:20 <Cale> dsrogers: The idea behind callCC is that in the definition of x >>= f for the Cont monad, the computation x is effectively passed a transformed version of f
13:17:31 <roconnor> you don't need to understand the definition of a function to use it
13:17:39 <Cale> dsrogers: The Cont monad isn't something you use every day.
13:17:44 <dsrogers> roconnor: that's not the point.
13:17:59 <dsrogers> roconnor: I should be able to understand it.
13:18:04 <roconnor> oh okay
13:18:15 <dsrogers> roconnor: as a demonstration in fluency of the language.
13:18:18 <Cale> dsrogers: Do you understand first of all what callCC is supposed to do?
13:18:19 <Toxaris> Peaker: [(a, expr) | a <- blah, let expr = long expr of a here, expr]?
13:18:28 <dsrogers> I understand what callCC is suppose to do.
13:18:29 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
13:18:30 <lambdabot> f a b = a (\ c _ -> b c) b
13:18:37 <proq> zenon: the name monad lends a bit of intrigue and fear as well
13:18:57 <Peaker> Toxaris, oh, it can use stuff from lets in the right, thanks
13:19:15 <dsrogers> I just get seriously lost when trying to break the code into pieces.
13:19:16 <zenon> proq: Yes, that's why it is important to show the bare structure. @Toxaris: Maybe.
13:19:31 <dsrogers> there is no "first this happens, then this happens"
13:19:43 <Cale> callCC g = Cont (\q -> runCont (g (\v -> Cont (\_ -> q v))) q)
13:19:44 <zenon> I don't know if introducing Monads the IO way is the best thing. Really.
13:19:46 <dolio> callCC e k = e (\a _ -> k a) k is probably better.
13:20:14 <zenon> It seems students get locked up with the IO and never see "past" it
13:20:35 <Cale> Wait, first of all, we should have another look at bind...
13:20:36 <Cale> x >>= f = Cont (\q -> runCont x (\v -> runCont (f v) q))
13:20:38 <dsrogers> I don't understand how to break the understanding of something complex into smaller pieces, understand those, then glue that understanding of the small pieces together into an understanding of the whole.
13:21:09 <dsrogers> well, at least when closures and continuations enter the picture.
13:21:14 <zenon> dsrogers: works for some areas. like math
13:21:15 <Cale> Note that x is being run with a function that is built up from f
13:21:25 <Cale> dsrogers: There are no closures here.
13:21:31 <Cale> dsrogers: Only functions.
13:22:04 <dsrogers> ...that makes no sense.  every function in haskell is a closure.
13:22:06 <Toxaris> dsrogers: my prof calls that "modular reasoning about programs" and argues all the time that programming languages should allow it
13:22:26 <Cale> dsrogers: A closure is a pair consisting of a concrete representation of some code that has free variables in it, and a mapping from the free variables in that code to values.
13:22:38 <Cale> dsrogers: The key part of that is that a closure is a pair.
13:22:39 <roconnor> @bab nl en bedrag beschikbaar voor herbelegging in aandelen
13:22:40 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
13:23:06 <dsrogers> that's just one defintion of a closure.
13:23:12 <Cale> (and hence, if you have a closure, you should be able to project out the two components of it)
13:23:19 <roconnor> lambdabot: you are useless this year
13:23:20 <zenon> dsrogers: what is your def then?
13:23:33 <dsrogers> a function that contains external scope
13:23:38 <Cale> If you can't look at the mapping from free variables to values, separate from the code, then you don't have a closure.
13:24:11 <Toxaris> Cale: why can't it be a closure but hide its closureness from the programmer?
13:24:15 <Cale> Closures are typically used to implement first class functions, and people always get them confused with their most-common application.
13:24:18 <dsrogers> ok.  but haskell has closures.  you just can separate those two within the context of the language of haskell
13:24:29 <Cale> No, Haskell does not have closures.
13:24:36 <Cale> Haskell has first class functions.
13:24:49 <Cale> How those functions are implemented is not of any concern.
13:24:59 <Cale> In fact, it's usually implemented with graph reduction.
13:25:06 <zenon> by lazyness
13:25:11 <roconnor> lambdabot: BTW, "amount available for reinvestment in shares"
13:25:59 <dsrogers> I fail to see how much misuse of the word closure in anyway invalidates my question.
13:26:16 <dsrogers> or my problem.
13:26:16 <zenon> of topic: I should add another desktop, I have just 4
13:26:55 <Cale> Okay, so what is your real question? You're confused about how functions work?
13:26:59 <dsrogers> no.
13:27:21 <dsrogers> I have no strategies for breaking down complex fuctions into pieces I can understand.
13:27:25 <Cale> okay
13:27:46 <Cale> Well, sometimes it's possible, and sometimes it's just plain complicated.
13:27:47 <dolio> There's not much to break down in callCC.
13:27:59 <dsrogers> well, then how do I understand it?
13:28:15 <Cale> callCC may be one of those times that it's complicated, and you just have to carefully stretch your brain around it.
13:28:27 <Peaker> (or avoid using it? :-)
13:28:29 <bd_> @src callCC
13:28:30 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:28:33 <bd_> @src callCC Cont
13:28:33 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:28:35 <Cale> callCC g = Cont (\q -> runCont (g (\v -> Cont (\_ -> q v))) q) -- let's look at this carefully
13:28:36 <bd_> :|
13:28:37 <Deewiant> @src Cont callCC
13:28:37 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
13:28:40 <bd_> oh
13:28:44 <bd_> @src ContT callCC
13:28:44 <lambdabot> callCC f = ContT $ \c -> runContT (f (\a -> ContT $ \_ -> c a)) c
13:28:46 <dsrogers> basically, I won't be satisfied here until I can go "I need callCC, huh, I should implement it" then do so from first principles.
13:29:14 <dsrogers> because there is almost nothing I can do that with in, say, Java for example.
13:29:19 <Cale> I'd never implement it myself if I could use the ready-made implementation.
13:29:19 <dsrogers> *can't
13:29:20 <bd_> dsrogers: huh, that's actually exactly how it finally clicked for me :)
13:29:27 <zenon> This is serious lambdabot spam
13:29:29 <Cale> dsrogers: Can you implement callCC in Java?
13:29:37 <dsrogers> no.
13:29:45 <dsrogers> well, maybe.
13:29:49 <dsrogers> I haven't thought about it.
13:29:49 <proq> sure you can
13:29:50 <Cale> It's possible to do.
13:30:16 <Cale> But that one-line of Haskell is going to get bigger :)
13:30:19 <dsrogers> the typing would be horrendous.
13:30:55 <dsrogers> my point is not that I /would/ implement it, it's that I should be able too.
13:30:59 <Cale> So first of all, callCC is going to take a function (which I'll call f), and it's going to produce a Cont computation
13:31:09 <Cale> So we already know that it looks something like:
13:31:19 <Cale> callCC f = Cont (\q -> ...)
13:31:58 <dsrogers> why would callCC f produce a continuation?  Doesn't it effectively return a result?
13:32:09 <Deewiant> @ty callCC
13:32:10 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
13:32:21 <Cale> It produces a computation in the Cont monad which calls f with the current continuation.
13:32:30 <Cale> That is
13:32:39 <Deewiant> @unmtl Cont t a
13:32:39 <lambdabot> (a -> t) -> t
13:32:46 <Cale> When you have something like  callCC f >>= g
13:32:48 <dolio> Why does my connection always get dropped when I'm actually trying to communicate? :)
13:33:04 <roconnor> callCC is pretty easy to implement, there is essentially only one function of the correct type :P
13:33:35 <Cale> That should be roughly the same as f g
13:33:42 <Deewiant> @unmtl ((a -> Cont t b) -> Cont t a) -> Cont t a
13:33:42 <lambdabot> ((a -> Cont t b) -> Cont t a) -> Cont t a
13:33:57 <Cale> (I might have to think a bit to tell if that's really a true law)
13:35:20 <Cale> yeah, that seems right
13:35:32 <boyscared> in ghci, you can :set editor to your favorite editor, however when you exit ghci, this setting disappears
13:35:44 <boyscared> is there a dotfile or something for ghci?
13:35:49 <Cale> boyscared: put that command into your .ghci
13:36:06 <Cale> (with the colon and all)
13:36:09 <boyscared> Cale: thanks, that's what i was looking for :)
13:36:45 * Cale checks algebraically that the callCC law holds
13:37:02 <Deewiant> @djinn ((a -> (b -> t) -> t) -> (a -> t) -> t) -> (a -> t) -> t
13:37:02 <lambdabot> f a b = a (\ c _ -> b c) b
13:37:25 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
13:37:26 <lambdabot> f a b = a (\ c _ -> b c) b
13:37:33 <Deewiant> d'oh
13:37:42 <Deewiant> didn't realize it knew of Cont :-P
13:40:03 <dsrogers> Cale: I think there is no way around it.  I just have to stare at it and think about it more.
13:40:12 <Cale> dsrogers: basically, yes
13:40:23 <Cale> dsrogers: It's not a simple idea.
13:40:37 <chessguy> @type let f a b = a (\ c _ -> b c) b in f
13:40:39 <lambdabot> forall t t1 t2 t3. ((t -> t1 -> t2) -> (t -> t2) -> t3) -> (t -> t2) -> t3
13:40:41 <Cale> dsrogers: and it's hardly ever what you want when programming in Haskell.
13:41:07 <dsrogers> Cale: I just felt like I was missing something.
13:41:08 <Cale> dsrogers: (continuations are even less important in Haskell than they are in strict functional languages)
13:41:16 <dsrogers> Cale: yeah, I realize that.
13:41:26 <dsrogers> I don't want to use callCC.  I want to understand it.
13:41:46 <zenon> Cale: I have to agree with dsrogers, it is still a nice feat to be able to understand everything thrown at you in haskell
13:42:16 <Cale> zenon: sure.
13:42:25 <dsrogers> I don't consider it a useful trick.  I considering it a fundamental.
13:42:26 <zenon> It should be possible to figure everything out if you understand the basics leading to it.
13:42:26 <Cale> zenon: and I'm not saying it's impossible either
13:42:55 <dsrogers> err, consider
13:43:21 <zenon> Cale: No, I know. I just thought it seemed  a little hand-wavy ; "it's hardly .... "
13:43:22 * glguy found it easier to grok callCC by first writing code in CPS without the Cont type and the once I saw how tha tworked I wrote my Cont monad instance and callCC to matach
13:43:36 <dolio> Cale: I don't think 'callCC f >>= g = f g' unless f is of the form "\esc -> do ... no calls to esc ... ; esc a"
13:43:38 <dsrogers> oh, that's a good idea.
13:43:50 <dolio> Or something of the sort.
13:43:56 <Cale> dolio: ah hmm...
13:47:47 <Cale> dolio: why is that?
13:48:04 <Cale> How will they behave differently if f is not of that form?
13:48:12 <dolio> Well...
13:48:50 <dolio> If f never calls the escape continuation, then 'f g' does nothing with g, while 'callCC f >>= g' does.
13:50:01 <Cale> mm, you have a point there :)
13:50:21 <Cale> yeah, forgot about returning to the continuation after
13:50:26 <dolio> And in '\esc -> do ... ; esc a ; ...' all the stuff after 'esc a' gets aborted with 'callCC f >>= g' but not when the escape continuation is just g.
13:50:33 <Cale> So is it the same as  f g >>= g then?
13:50:57 <Cale> There must be a nice law of this sort..
13:51:01 <dolio> Or, not with 'f g' that is.
13:51:20 <dolio> Because g doesn't discard its continuation (presumably).
13:52:59 <hpaste>  gubagem pasted "why is loadFile returning just []" at http://hpaste.org/7992
13:53:40 <Deewiant> gubagem: hClose is a bad idea
13:53:48 <Deewiant> gubagem: since hGetContents is lazy
13:53:54 <gubagem> oh seriously
13:53:56 <Deewiant> it won't have read anything when you close it
13:53:59 <Cale> gubagem: You're closing the handle that hGetContents needs to use
13:54:00 <gubagem> what should I use
13:54:05 <Deewiant> hGetContents will close the file by itself when it's done
13:54:06 <Cale> gubagem: don't use hClose
13:54:12 <gubagem> at all?
13:54:15 <Cale> right.
13:54:19 <Deewiant> (although in bytestring.lazy it won't, currently, unless you have the darcs version... grr)
13:54:31 <Cale> It'll close the handle at some point after the string is GC'd.
13:54:37 <dons> Deewiant: no, that's false
13:54:38 * Deewiant just ran into that today and spent a few hours wondering
13:54:45 <Deewiant> dons: bug 1994 IIRC
13:54:53 <dons> the release version on hackage has long had correct hClose, hasn't it?
13:54:54 <Deewiant> it's fixed, but not in the release that comes with GHC
13:55:02 <Deewiant> hm, possibly
13:55:03 <dons> oh, was that on windows? or mac only?
13:55:07 <Deewiant> windows
13:55:08 <gubagem> can i non lazily read the file in?
13:55:11 <Deewiant> but also on linux
13:55:19 <dons> let me check..
13:55:26 <Deewiant> bytestring-0.9.1.0 has the fix
13:55:30 <Cale> gubagem: yes, you can use hGetLine and so on.
13:55:38 <Deewiant> that much I do know
13:55:40 <dons> you can do strict IO as well
13:55:58 <gubagem> but for now i can just drop the hClose and it should work?
13:56:02 <Cale> right
13:56:04 <dons> oh, yeah, i fixed 1994 6 months ago
13:56:10 <gubagem> k let me try that
13:56:20 <dons> Deewiant: so all is good. just grab the released version
13:56:34 <dmwit> Oh, *bug* 1994.
13:56:34 <lambdabot> dmwit: You have 1 new message. '/msg lambdabot @messages' to read it.
13:56:46 <gubagem> totally works now
13:56:50 <Cale> dons: Oh yeah? Well I fixed 1994 14 years ago!
13:56:51 <dmwit> I just jumped in the middle there, and I was like, what, you fixed the year 1994?
13:56:55 <dmwit> What was wrong with it?
13:57:01 <Deewiant> dons: I already got the latest darcs and it works fine :-)
13:57:06 <gubagem> was mc hammer around?
13:57:16 <Deewiant> dons: that version isn't distributed with the GHC 6.8.3 release candidates, though.
13:58:00 <dons> no, they don't update libs on the stable branch
13:58:35 <Deewiant> shame, that's a rather annoying bug
13:58:51 <dons> easy enough to: cabal install bytestring
13:58:54 <dons> problem solved.
13:59:05 <gubagem> ok so should i ditch the hClose from my file saving as well? is that were my data file could have got zeroed out from?
13:59:12 <Deewiant> yes, I suppose I should look into that ^_^
13:59:23 <Deewiant> I did manual dependency chasing and discovered that I had to rebuild most of my libraries
13:59:41 <dons> yeah, best to upgrade any newer versions of core libraries first
13:59:47 <dons> straight after install
13:59:52 <dons> as for say, a linux distro.
13:59:59 <Deewiant> does cabal-install work well on Windows?
14:00:39 <dons> dcoutts would know. i believe so.
14:00:58 <Saizan_> Deewiant: yup, even if it's less tested than on unix, as usual
14:01:14 <dsrogers> so CPS you never return anything but _|_?
14:01:17 <Deewiant> good to know, I guess I'll try it some time
14:02:04 <eu-prleu-peupeu> hello
14:02:08 <eu-prleu-peupeu> is haskell better than java ?
14:02:21 <Cale> eu-prleu-peupeu: are you seriously going to ask that?
14:02:21 --- mode: ChanServ set +o dons
14:02:32 <eu-prleu-peupeu> yes
14:02:34 <dons> known troll nick
14:02:34 <Deewiant> wrong channel to ask that question :-P
14:02:49 <eu-prleu-peupeu> i mean, java seems faster, and seems to have a good garbage collector
14:02:56 <elliottt> does anyone know when the darcs version of lazysmallcheck will be packaged and released?
14:03:09 <Cale> eu-prleu-peupeu: The languages are completely different though.
14:03:18 <gubagem> eu-prleu-peupeu: go try to map a function to a list in java, have fun
14:03:24 <dsrogers> eu-prleu: is it true that I'm a better troll than you?
14:04:02 <eu-prleu-peupeu> hmm
14:04:03 <eu-prleu-peupeu> ok
14:04:05 <Cale> eu-prleu-peupeu: Java is verbose, has an awkward type system, poor control over effects...
14:04:13 <eu-prleu-peupeu> hmm i see
14:04:20 <eu-prleu-peupeu> but has a good garbage collector
14:04:34 <Cale> I don't think the GHC garbage collector is all that bad either...
14:04:38 <eu-prleu-peupeu> can haskell cache align everything ?
14:04:46 <gubagem> they stole garbage collection from lisp
14:04:53 <gubagem> eu-prleu-peupeu: whats cache align?
14:04:56 <elliottt> re lazysmallcheck, nevermind :)
14:04:58 <dons> 08.03.15:12:41:59 <eu-prleu-peupeu> what is the best programming language in the world ?
14:05:02 <dons> 08.03.15:12:41:06 <eu-prleu-peupeu> and lisp, is haskell better than lisp ?
14:05:06 <dons> 08.03.15:12:39:53 <eu-prleu-peupeu> is haskell better than OCaml ?
14:05:21 <Cale> eu-prleu-peupeu: I think the best thing you can do is just to learn the languages in question and then make up your own mind.
14:05:36 <Cale> eu-prleu-peupeu: What languages do you already know?
14:06:07 <eu-prleu-peupeu> i did somethings in ocaml
14:06:19 <gubagem> like what
14:06:29 <eu-prleu-peupeu> i mostly coded java and C#, but i prefer C / C++
14:06:33 <Cale> okay.
14:06:41 <Cale> So you already know what Java is like then.
14:06:44 <eu-prleu-peupeu> C# has assemblies which are good
14:06:46 <eu-prleu-peupeu> yes i do
14:06:52 <Cale> Haskell will probably take about a year.
14:06:54 <zenon> eu-prleu-peupeu: What is your purpose here? Did you come to learn haskell?
14:07:08 <eu-prleu-peupeu> zenon: i just came to talk a bit
14:07:12 <eu-prleu-peupeu> a year ?
14:07:16 <gubagem> eu-prleu-peupeu: im rewriting my last java project in haskell and I am just learning haskell and it will most likely be half as many lines of code
14:07:22 <Cale> To get comfortable, yeah.
14:07:33 <Peaker> I have an existential type: data World = forall a. Object.Object a => World [a]  -- but I am not allowed to place hetrogenous types into it via: World [a, b, c] -- where a,b,c are different instances of Object)
14:07:43 <eu-prleu-peupeu> lines of code is a bad measure... just look at perl :P
14:07:45 <Cale> But you can do useful things with it within a couple weeks to a couple months.
14:08:08 <Cale> eu-prleu-peupeu: The LOC reduction in Haskell is usually a real one, due to actual abstractions which are made available.
14:08:08 <gubagem> i have looked at perl and ive decided it is often write only even if you comment it
14:08:24 <eu-prleu-peupeu> LOC reduction ?
14:08:26 <Elly|wr0k> maybe if you suck at writing perl :P
14:08:26 <conal> Peaker: can you put homogeneous lists into your World?
14:08:28 <Cale> Peaker: right.
14:08:40 <gubagem> eu-prleu-peupeu: LOC -> lines of code
14:08:47 <Peaker> conal, I am creating a toy ray tracer, I want to put different kinds of objects in the world
14:08:48 <eu-prleu-peupeu> ah ok
14:09:07 <Peaker> Cale, how can I create a hetrogenous list then?
14:09:14 <gubagem> eu-prleu-peupeu: i have seen myself a 30 to 1 reduction of lines of code in haskell
14:09:16 <Peaker> Cale, (via existential types)
14:09:23 <Cale> Peaker: First you have to decide what operations you'd like to keep.
14:09:31 <Peaker> Cale, I have those in Object
14:09:45 <zenon> eu-prleu-peupeu: Okay, just got a feeling that you came to say "my language is better than your"
14:09:46 <gubagem> eu-prleu-peupeu: I wrote a program that was thirty lines long and asked for comments and three different people chimed back in #haskell within 5 minutes with 3 different ways to do it in 1 line of haskell code
14:10:03 <Peaker> Cale, And I created the existential type - I am just unsure about how to drop the specific type and remain with the instance
14:10:08 <eu-prleu-peupeu> it was a very long line i supose :P
14:10:14 <Cale> Peaker: Maybe something like   data Obj where O :: Object a -> Obj
14:10:48 <Cale> Peaker: then the O function will forget the type 'a'
14:11:04 <Cale> Peaker: and you'll be able to construct, for instance, a list of type [Obj]
14:11:07 <gubagem> eu-prleu-peupeu: it wasnt really that long
14:11:08 <Peaker> Cale, so you have to explicitly use a function to "forget" each specific type?
14:11:18 <Cale> Peaker: yes
14:11:21 <Peaker> Cale, ah, thanks
14:11:44 <Cale> Peaker: It's not a function which you apply lightly either, because it makes all the values of type a in the structure inaccessible.
14:11:54 <Heffalump> actually O remembers the type a :-)
14:12:02 <Heffalump> it's all a matter of perspective
14:12:10 <eu-prleu-peupeu> why do haskell programs start with a 'do' ?
14:12:20 <eu-prleu-peupeu> isn't that "anti-pure functional" ?
14:12:34 <zenon> no
14:12:36 <Peaker> eu-prleu-peupeu, no, read the tutorial :)
14:12:42 <Cale> eu-prleu-peupeu: do-notation is a means of gluing computations in various monads together.
14:12:47 <zenon> yeah
14:12:51 <zenon> it's syntax sugar really
14:12:52 <Cale> (well, one monad at a time)
14:12:52 <eu-prleu-peupeu> so, its anti-pure functional :P
14:12:55 <Cale> no.
14:13:04 <eu-prleu-peupeu> its imposing a sequence
14:13:15 <Cale> That doesn't mean it's not purely functional.
14:13:20 <zenon> exactly
14:13:24 <Cale> It's not a sequence of evaluation either.
14:13:36 <Cale> At least, not necessarily.
14:13:40 <Peaker> eu-prleu-peupeu, Haskell describes a pure functional computation, that computes a value that describes a non-pure computation.  While a non-pure computation is described, it does not run as part of the Haskell program's evaluation/computation
14:13:47 <dsrogers> f (g (h ([1..10]))) also imposes a sequence.
14:13:52 <zenon> why would f( g ( h ( n) ) ) be un-pure functional ?
14:13:59 <zenon> dsrogers: hehe ;)
14:13:59 <gubagem> all: I am guessing calling exitWith inside of GHCi is causing an exception
14:14:17 <Cale> eu-prleu-peupeu: It's the IO monad specifically which gives you impure actions, but lets you work with them as pure values.
14:14:36 <eu-prleu-peupeu> okey, i see, but i cannot have out of order execution inside a do, right ?
14:14:47 <zenon> That's why " Haskell programmers do it in a monad , and stay pure " <--- god I love that one
14:14:55 <Cale> eu-prleu-peupeu: depends what you mean by "out of order execution"?
14:14:58 <eu-prleu-peupeu> if i use a par, how does it know when to parallelize inside a do ?
14:15:07 <gubagem> zenon: kind of sounds like celibacy O:-)
14:15:25 <zenon> ;)
14:15:47 <Cale> eu-prleu-peupeu: When an expression  par x y  is evaluated, the expression x is 'sparked' which means that it is put into a queue of expressions to be evaluated on some processor, and the value y is returned.
14:15:53 <thetallguy> anyone familiar with the state of haddock 2.x?
14:15:55 <gubagem> eu-prleu-peupeu: you want some newbie haskell code to look at?
14:16:17 <gubagem> eu-prleu-peupeu: im coming to haskell from java and scheme
14:16:26 <Cale> eu-prleu-peupeu: It only happens when the value of the (par x y) expression itself is needed though.
14:16:36 <eu-prleu-peupeu> okey i see
14:16:50 <eu-prleu-peupeu> thanks
14:16:54 <eu-prleu-peupeu> sorry for the mess :P
14:17:02 <dolio> Cale: callCC is too messy. reset (shift f >>= g) = f g, I think.
14:17:09 <thetallguy> David is finding that it fails on ﻿{-# OPTIONS -cpp #-}.  I had understood that 2.0 was built to hadnle all the current syntax
14:17:17 <Cale> dolio: ah, okay, that makes more sense.
14:17:19 <ddarius> dolio: I doubt that.
14:17:26 <Cale> hmm
14:17:26 <eu-prleu-peupeu> one more question...
14:17:26 <dsrogers> My copy of "Programming in Haskell" just arrived.
14:17:32 <zenon> shoot
14:17:38 <dsrogers> however it covers neither CPS or Monads in detail.
14:17:42 <dolio> Or maybe reset (f g).
14:17:47 <gubagem> anyone: is Programming in Haskell worth the purchase
14:17:47 <dsrogers> where will I go next?
14:17:47 <eu-prleu-peupeu> ...does haskell allows making tests inside comments ? like python ?
14:17:52 <gubagem> dsrogers: WWHAT
14:18:03 <eu-prleu-peupeu> is there a test suit for haskell ?
14:18:04 <zenon> how do you mean tests in comments?
14:18:04 <dons> eu-prleu-peupeu: haskell allows this, yes.
14:18:10 <dons> zenon: doctest
14:18:10 <Cale> eu-prleu-peupeu: Usually we make our tests plain Haskell values though.
14:18:10 <gubagem> eu-prleu-peupeu: why would you want tests inside of comments
14:18:14 <zenon> ah....
14:18:28 <dons> gubagem: basically, examples in comments can be checked
14:18:35 <eu-prleu-peupeu> ok, thanks :)
14:18:37 <dobblego> eu-prleu-peupeu, no Haskell is cleverly thought out
14:18:42 <gubagem> with some sort of utility program?
14:18:42 <dons> eu-prleu-peupeu: do you have a random list of haskell features you're ticking off ?
14:18:47 <dobblego> @check \a b -> a + b == b + a -- yes there is testing
14:18:51 <lambdabot>  OK, passed 500 tests.
14:18:53 <sjanssen> dons: how does one do that?
14:19:02 <zenon> QuickCheck is the shit
14:19:04 <gubagem> @faq can haskell make eu-prleu-peupeu a better coder?
14:19:05 <lambdabot> The answer is: Yes! Haskell can do that.
14:19:09 <dsrogers> gubagem: if it has a section on CPS or Monads, I'm missing it
14:19:12 <dons> sjanssen: you write a script that runs quickcheck properties from comments
14:19:14 * shapr boings
14:19:16 <eu-prleu-peupeu> dons: no, i just have read the yaht, and lots of questions poped-out... i think ill read it again
14:19:23 <sjanssen> dons: does such a script exist?
14:19:26 <dons> does yaht even talk about testing or `par`
14:19:35 <eu-prleu-peupeu> i still havent wrote a line of haskell code though :P
14:19:40 <dons> sjanssen: there's a couple floating around, but no official one.
14:19:43 <thetallguy> sjanssen: yes, it's in the original paper
14:19:46 <dons> eu-prleu-peupeu: ok. stop now. go write some code!
14:19:55 <dolio> If you use the control primitive for abortive continuations, you might have 'control f >>= g = control (\k -> f (g >=> k))' too.
14:19:59 <Cale> eu-prleu-peupeu: You should just dive in with one of the tutorials, I think.
14:20:07 <eu-prleu-peupeu> haskell code ? because ive been coding lots of c++ latelty :( and my head is about to blow
14:20:13 <ddarius> dons: Does Haskell have Icon style scanning?
14:20:14 <zenon> I may propose the Gentle Introduction to Haskell
14:20:15 <eu-prleu-peupeu> im in serious need of something "healthier"
14:20:21 <dons> ?faq
14:20:22 <lambdabot> The answer is: Yes! Haskell can do that.
14:20:40 <Peaker> What does this mean: "Inferred type is less polymorphic than expected, Quantified type variable `a' escapes, When checking an existential match that binds"
14:20:53 <Cale> I normally recommend YAHT, but there's no one tutorial which I'm perfectly happy about.
14:20:58 <Heffalump> it means that you're unwrapping an existential
14:21:08 <Heffalump> and the code that uses the result of doing so, must be fully polymorphic in the existential type
14:21:11 <zenon> Cale: Sure, YAHT does well also
14:21:17 <Heffalump> because anything (that's suitably constrained) might be wrapped up inside
14:21:18 * thetallguy throws shapr a unicycle
14:21:24 <Cale> @where tutorial
14:21:24 <lambdabot> http://www.haskell.org/tutorial/
14:21:27 <Cale> @where YAHT
14:21:27 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
14:21:29 <zenon> eu-prleu-peupeu download both YAHT and Gentle
14:21:31 <Cale> @where wikibook
14:21:31 <lambdabot> http://en.wikibooks.org/wiki/Haskell
14:21:33 <zenon> both are gr8
14:21:35 <Heffalump> but somehow you've made your code less polymorphic, typically by having 'a' in the result of that function or something like that
14:21:37 <eu-prleu-peupeu> i have read both of them
14:21:45 <zenon> I would also recommend ghci
14:21:51 <Cale> eu-prleu-peupeu: You read them without writing any code?
14:21:55 <eu-prleu-peupeu> yes
14:21:59 <eu-prleu-peupeu> just for the kick
14:21:59 <zenon> Then why are you ascing these questions?
14:22:02 <Cale> Curious approach :)
14:22:04 <zenon> asking*
14:22:05 * shapr throws a lambda to thetallguy
14:22:29 <Peaker> Heffalump, hmm.. "fully polymorphic in the existential type" meaning?
14:22:30 * thetallguy thunks
14:22:34 <Cale> gubagem: Oh, btw, you don't need multiple lets to make multiple declarations
14:22:42 <Cale> let foo = bar
14:22:47 <Cale>     baz = quux
14:22:50 <Peaker> Heffalump, I am fully polymorphic there, I think, must be some weird funny thing
14:22:54 <Cale>  in foo . baz
14:22:58 <thetallguy> shapr: am I correct in thinking you are now in the NE?
14:23:00 <eu-prleu-peupeu> i have some projects pending for some friends that i must do :( so whenever i think about writing haskell code, i think to myself "arghh, i should really get that actionscript flash running, or else my friend will be sad..."
14:23:07 <thetallguy> shapr: or just virtually?
14:23:12 <shapr> thetallguy: Yeah, just outside of Boston. Where are you?
14:23:20 <thetallguy> shapr: San Diego
14:23:27 <shapr> Ah, not that close.
14:23:43 <thetallguy> shapr: no, I just noticed that you were no longer in the SE
14:23:49 <shapr> Yup, I moved in January.
14:24:05 <Heffalump> Peaker: can you paste your code?
14:24:06 <thetallguy> shapr: haskell gig?
14:24:12 <Heffalump> I'm not very good at explaining generally.
14:24:13 <shapr> Nah, C# gig :-(
14:24:14 <zenon> Okay, I have to go. Cu round
14:24:24 <ddarius> Peaker: When you crack open an existential, you can't have the type variable it releases anywhere in the result type.
14:24:26 <zenon> return zenon
14:24:31 <Peaker> Heffalump, yeah, I will
14:24:39 <Peaker> ddarius, I didn't think I did
14:24:46 <thetallguy> sounds like an exercise video:  I am fully polymorphic there, but up here...
14:25:23 * thetallguy commiserates with shapr, but is happy he has garbage collection, at least
14:25:30 <shapr> Yeah, and lambdas
14:25:37 <shapr> And a tiny bit of type inference.
14:25:40 <hpaste>  dons pasted "eu-prleu-peupeu's opus" at http://hpaste.org/7994
14:26:02 <Peaker> Heffalump, ddarius : http://hpaste.org/7995
14:26:03 <eu-prleu-peupeu> ahaha
14:26:08 <eu-prleu-peupeu> you actually collect those things
14:26:10 <Heffalump> the reason you can't have the released type variable anywhere in the result type, is that the existential must be completely free to determine what type it is. If it's in the result type, then the context can determine that.
14:26:26 <Peaker> Heffalump, yeah cause of the missing (exists a). ...
14:27:36 <Heffalump> Peaker: that pattern-match won't produce the same type each time
14:27:49 <Cale> eu-prleu-peupeu: keep it up, and you'll be made part of lambdabot like protontorpedo was :)
14:27:55 <Heffalump> the first element of objects might be one type, the next element a different type
14:27:56 <Cale> @protontorpedo
14:27:56 <lambdabot> can u build things fast in haskell?
14:27:58 <Cale> @protontorpedo
14:27:58 <lambdabot> cmon Im asking cool questions
14:27:59 <Cale> @protontorpedo
14:28:00 <lambdabot> Im wondering if there are uncharted business waters that haskell can enable, even if it is simply by not accepting norms
14:28:01 <Cale> @protontorpedo
14:28:02 <lambdabot> scheme, lisp, php, python, perl, tcl, al banned
14:28:03 <Cale> @protontorpedo
14:28:03 <lambdabot> whera re the end user apps?
14:28:07 <Heffalump> so points isn't well-typed in itself
14:28:10 <Peaker> Heffalump, but all I do with the pattern match is call an instance method on it
14:28:20 <vixey> cmon Im asking cool questions, lol
14:28:24 <dons> ah gschuett.
14:28:25 <Heffalump> Peaker: much later on
14:28:30 <dons> now that was a troll who persisted.
14:28:31 <Heffalump> what type does points have?
14:28:31 --- mode: ChanServ set -o dons
14:28:41 <Peaker> Heffalump, oh I can't have the object out in the tuple
14:28:43 <Peaker> Heffalump, thanks!
14:28:57 <Heffalump> you can't even have it free in that list comprehension
14:29:05 <vixey> dons was gschuett really a troll though?
14:29:08 <Heffalump> at least I don't think you can. I could be wrong.
14:29:18 <Heffalump> actually, you might be able to.
14:29:20 <ddarius> A talk by Benjamin C. Peirce for those that don't follow LtU: http://lambda-the-ultimate.org/node/2828
14:29:21 <lambdabot> Title: Types Considered Harmful | Lambda the Ultimate
14:29:21 <Heffalump> try, anyway :-)
14:29:24 <dons> vixey: certainly. over several channels and several years
14:29:32 <Peaker> Heffalump, I will, thanks. I finally understand what it means by the type "escaping" :)
14:30:19 <Peaker> Heffalump, yeah it works if I just don't let it out into the list's type
14:30:27 <Heffalump> ok, cool
14:30:45 <Heffalump> the reason that works is that the rest of the comprehension after that binding gets turned into a function argument to concatMap
14:31:05 <Heffalump> so you get concatMap (\(Obj object) -> ...) objects
14:31:11 <Cale> Heh, callCC f >>= g = f g isn't even type correct. I also see clearly why it's not callCC f >>= g = f g >>= g now too. It would be nice to have an equational understanding of callCC -- what laws should an instance of MonadCont satisfy?
14:31:12 <Heffalump> which is fine for the usual reasons
14:31:17 <Peaker> nice I added Planes and they're working pretty well on the first attempt, except for the point at infinity, it seems
14:31:36 <Heffalump> projective planes?
14:31:37 <Peaker> Heffalump, if that wasn't fine, I am not sure what you could possibly do with an existential type
14:31:48 <Peaker> Heffalump, just a simple plane, what's a projective plane?
14:32:06 <dsrogers> Cale: the monad laws, of course!
14:32:12 <Heffalump> Peaker: yes, that would always be fine, but it was whether the comprehension desugared into something like that, that I wasn't sure about
14:32:15 <Peaker> Heffalump, Ax+By+Cz+D=0
14:32:24 <Cale> dsrogers: Yeah, I'm specifically looking for one which involves callCC
14:32:28 <vixey> there's no way to understand callcc ....
14:32:33 <vixey> :(
14:32:50 <Peaker> Heffalump, I think Haskell's Inf has a screwed up Ord implementation or so :)
14:32:50 <Cale> Like, you can describe it in English easily enough.
14:32:57 <Heffalump> Peaker: projective planes are a coordinate system for planes that have some advantages I forget, but I think include being able to describe points at infinity
14:32:58 <Cale> But it's not easy to write down an equation...
14:33:01 <Heffalump> Peaker: IEEE has screwed up ordering
14:33:04 <Cale> hmm
14:33:18 <Heffalump> oh, perhaps just for NaN, not Inf, I forget
14:33:21 <Peaker> Heffalump, oh.. because I'm using Doubles and getting NaNs?
14:33:29 <ddarius> Cale: I believe you'll need to explicitate a notion of "context" to give comprehensive rules for how callCC should behave, but once you have it, it's pretty straight forward.
14:33:36 <Cale> (and harder still to write down an equation which you can have confidence that it totally characterises the behaviour)
14:33:38 <Heffalump> NaN /= NaN in IEEE
14:33:49 <Heffalump> I forget how Haskell treats that. I suspect it doesn't define it.
14:34:00 <ddarius> > 0/0
14:34:02 <lambdabot>  NaN
14:34:04 <Peaker> Heffalump, it does seem that Inf/-Inf are handled correctly which is why I think I have here
14:34:05 <Cale> > (0/0) == (0/0)
14:34:07 <lambdabot>  False
14:34:07 <ddarius> > 0/0 /= 0/0
14:34:08 <lambdabot>  True
14:34:34 <Peaker> > sqrt(1/0)
14:34:35 <lambdabot>  Infinity
14:34:45 <vixey> why is 0/0 = NaN useful?
14:34:53 <dolio> @remember JonHarrop All of these language implementations (OCaml, SML, Haskell) lack concurrent GC so they are completely screwed for general purpose programming on multicore machines. A concurrent GC is too hard for these implementors to write so they must build upon existing technology. That means the JVM, Mono or .NET [...] F# is the only similar language that can survive the multicore transition.
14:34:53 <lambdabot> Good to know.
14:34:55 <Heffalump> vixey: what else could it return?
14:35:00 <dsrogers> vixey: it's better than throwing an exception
14:35:05 <vixey> it shouldn't return
14:35:12 <vixey> why is that better?
14:35:25 <dsrogers> that's just the reasoning for NaN
14:35:27 <dons> dolio: hehe
14:35:32 <dons> i can add that to my suite of jdh quotes
14:35:36 <dobblego> I met Don Syme yesterday; such a contrast to how I expect Jon Harrop would be
14:35:38 <Peaker> I'd rather get exceptions!
14:35:43 <dobblego> (speaking of F#)
14:35:44 <Peaker> so I know what to fix now that its broken
14:35:45 <dolio> Those MLTon guys are too dumb to write a concurrent GC.
14:35:50 <dons> dobblego: cool. don syme is great.
14:36:00 <dons> dobblego: does he know how bad jdh is?
14:36:08 <ddarius> Benjamin Pierce taking potshots at Haskell, but he has a good question.  "Is it better for Jane Programmer to write ~20 more or less correct lines of code / day or ~0 perfect ones?"
14:36:22 <dobblego> dons, yes, he's pretty smart; we had a discussion about fun stuff with Erik Meijer and the two argued quite passionately :)
14:36:28 <Cale> callCC (\k -> k x >>= f) >>= g = g x -- there's one
14:36:37 <dons> hey, bjp at least has visited galois and writes and teaches haskell ...
14:36:44 <monochrom> Sometimes I think it is better for Joe or Jane to write 0 lines of code.
14:36:45 <dobblego> dons, I didn't ask, just that Don seems like a level headed person and I wouldn't expect the same if I met JDH
14:36:48 <Peaker> ddarius, I'd guess ~0, but it depends on how big of an error ~ represents here :)
14:37:04 <Cale> But we need one which moves things out of the callCC at the front...
14:37:07 <ddarius> To be honest, I prefer writing negative lines of code / day
14:37:18 <vixey> dolio: is that sarcasm?
14:37:37 <Peaker> deleting code is always great
14:37:39 <dolio> vixey: I think jdh is serious.
14:37:43 <dons> dobblego: was he back in .au?
14:37:58 <dobblego> dons, my colleagues were putting shit on me because Meijer said exactly the same things I say; I was quite disappointed that I couldn't disagree with him and so learn something; when I tried I asked him a question where I thought I had something, but he gave the same answer I would give
14:38:06 <dobblego> dons, yes, Brisbane (JAOO conference)
14:38:06 <monochrom> Actually, I think the question is distracting.  The question has a different answer for a different niche.
14:38:55 <eu-prleu-peupeu> @hoogle &&&
14:38:56 <lambdabot> Control.Arrow.(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
14:39:23 <monochrom> Suppose you are an amateur adding a bit of javascript to your personal blog. It is better for you to write 20 lines of code, perfect or total crap.  It is your personal blog, who cares.
14:39:42 <ptolomy2> I tend to see a lot of this pattern in my code: "x = y { someField = fun (someField y) }".. seems redundant. Is there a better way to modify a record field?
14:40:20 <gubagem> why would this be making my file empty: do I need the hclose? saveFile itemList=do handle<-openFile fileName WriteMode
14:40:21 <gubagem>                      imap (\x->hPutStrLn handle $ itemString x) itemList
14:40:21 <gubagem>                      --hClose handle
14:40:21 <gubagem>                      putStrLn "Inventory Saved"
14:40:26 <Cale> callCC (\k -> x >>= f k) = x >>= \v -> callCC (\k -> f k v), where x doesn't mention k. Is this true?
14:40:29 <gubagem> uh that looks nasty
14:40:32 <Cale> Seems true.
14:40:34 <Heffalump> ptolomy2: there are abstractions around that wrap up record update nicely and make it composable
14:41:08 <vixey> Cale: I think so
14:41:21 <vixey> Cale: How might you prove these ?
14:41:32 <monochrom> Suppose you are writing avionics code for the next Chinese-designed airliner. You should write very few lines of code, and they should be backed by the strictest rigour.
14:41:33 <ptolomy2> Heffalump: Oooh. I was hoping so. Links?
14:41:35 <gubagem> @hoogle hFlush
14:41:36 <lambdabot> System.IO.hFlush :: Handle -> IO ()
14:41:36 <vixey> the only tool I know for dealing with cwcc is cps
14:41:44 <Heffalump> http://hackage.haskell.org/packages/archive/data-accessor/0.0.1/doc/html/Data-Accessor.html
14:41:46 <lambdabot> http://tinyurl.com/6mztqv
14:41:49 <dolio> You'd rewrite to cps, I imagine.
14:42:00 <Heffalump> I've seen a nice blog post about this too, but I forget where now.
14:42:04 <gubagem> can i safely use hFlush with hClose with lazy reading?
14:42:12 <ptolomy2> TH..
14:42:14 <ptolomy2> neato.
14:43:18 <dons> gubagem: for writing a file?
14:43:56 <gubagem> dons: yes (and possibly reading or i may be way off key on reading)
14:44:22 <dons> are you attempting to read and write to the same flie?
14:44:41 <dons> i.e. why do you need explicit IO control?
14:46:12 <ptolomy2> Heffalump: http://luqui.org/blog/archives/2007/08/05/haskell-state-accessors-second-attempt-composability/
14:46:13 <lambdabot> Title: Haskell State Accessors (second attempt: Composability) @ The dreams that stuff  ..., http://tinyurl.com/2ve2zw
14:46:25 <gubagem> dons: i am reading from the file, making a list of its contents, (planning to play with list with userinput), then saving to the same file and then exitWith ExitSuccess
14:46:36 <dons> right. so i'd do strict io then.
14:46:44 <dons> use Data.ByteString.Char8.readFile
14:46:54 * gubagem is scared 
14:46:56 <dons> or else use lazy string IO, but take the length of the input string
14:46:59 <dons> so that it is fully read.
14:47:07 <dons> generally, mutation and lazy IO don't mix.
14:47:14 <dons> and you're treating a file as a mutable variable
14:47:26 <dons> so you need precise control over when the reads and writes happen
14:47:36 * ptolomy2 is a bit afraid of the performance implications.
14:47:37 <dons> we should have a wiki faq on this
14:47:40 <gubagem> yeah but only at the beginning, and at the end
14:47:47 <dons> its identical to the approach in any language.
14:47:57 <Peaker> nice! checker-board pattern on my plane :)
14:48:47 <Heffalump> ptolomy2: of what?
14:49:33 <Cale> vixey: well, you'd prove them in the specific cases using the instances of MonadCont and Monad...
14:50:07 <Cale> vixey: effectively you should be able to sub in the definition of callCC and use the monad laws a bit and make it work
14:50:12 <Heffalump> ptolomy2: profile and and INLINE pragmas if need be
14:50:18 * Heffalump disappears
14:50:36 <Cale> (and maybe if it comes down to that, the definition of bind...)
14:51:09 <Cale> Though it's probably sanest to prove the properties for ContT and treat Cont as a special case of that.
14:51:28 <Cale> What I don't know is if those properties are really all that you need.
14:51:48 <vixey> another one is what differences are there with cwcc in a lazy setting compared to strict?
14:52:23 <hpaste>  dolio pasted "callCC" at http://hpaste.org/7997
14:52:24 <Cale> Well, I suspect the monad ordering takes care of that somewhat...
14:52:31 <dolio> Cale: ^^
14:52:49 <dolio> Not 100% on all of those.
14:54:14 <dolio> Oh, wait, I think I messed up one.
14:57:42 <Peaker> is there a short-hand for   case blah of Nothing -> default ; Just x -> x ?
14:58:03 <bd_> :t fromMaybe
14:58:05 <lambdabot> forall a. a -> Maybe a -> a
14:58:10 <bd_> ^^^ that :)
14:58:12 <hpaste>  dolio annotated "callCC" with "fixed?" at http://hpaste.org/7997#a1
14:58:23 <dolio> Cale: I think that one's right.
14:58:34 <Peaker> :t fromJust
14:58:36 <lambdabot> forall a. Maybe a -> a
14:58:43 <Peaker> oh, missed that a-> there
14:58:44 <Peaker> thanks
14:58:46 <bd_> Peaker: fromJust is undefined with Nothing
14:58:58 <bd_> @src fromMaybe
14:58:58 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
14:59:13 <bd_> @src fromMaybeM
14:59:14 <lambdabot> Source not found. :(
14:59:15 <bd_> :(
14:59:32 <bd_> there needs to be a fromMaybeM :: Monad m => Maybe a -> m a
15:00:13 <vixey> :t id :: Maybe a -> Maybe a
15:00:15 <dolio> That's going to have to call fail, which would be bad for arbitrary Monads.
15:00:16 <lambdabot> forall a. Maybe a -> Maybe a
15:00:18 <MarcWeber> Has anyone thought about pattern guards and non Maybe monads?
15:00:36 <vixey> MarcWeber: huh ?
15:01:56 <dolio> @type Data.Foldable.msum . map return
15:01:58 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Functor f, MonadPlus m, Data.Foldable.Foldable f) => f a -> m a
15:02:33 <dolio> @type Data.Foldable.msum . map return :: (MonadPlus m) => Maybe a -> m a
15:02:34 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => Maybe a -> m a
15:04:29 <hpaste>  MarcWeber pasted "pattern guard an non Maybe monad example" at http://hpaste.org/7998
15:04:37 <MarcWeber> @vixey
15:04:38 <lambdabot> I'm your huckleberry
15:04:57 * vixey wonders what a huckleberry is
15:05:01 <monochrom> @codsnack
15:05:02 <lambdabot> :)
15:05:15 <monochrom> I had cod fish-n-chips last night :)
15:05:16 <MarcWeber> Mmh can alos be done using error handling I think..
15:05:49 <dolio> MarcWeber: That doesn't work because you can't pattern match on IO computations.
15:06:19 <MarcWeber> dolio I know that it doesn't .. but maybe it could ?
15:07:19 <dolio> Pattern guards don't have anything specific to do with Maybe or any other monad.
15:07:27 <vixey> ddarius: I am not so keen on this I thin
15:08:01 <dolio> 'foo | "foo" <- "foo" = "bar"' is a valid definition with pattern guards.
15:08:17 <gubagem> you guyz told me last night i cant get a nice list out of io ([Item]) but i finally got it :-)
15:08:55 <vixey> why has nobody mentioned SCM or bakers work I wonder
15:09:10 <vixey> or yokoyama for that matter
15:09:12 <roconnor> gubagem: what's a nice list?
15:09:24 <gubagem> something not wrapped in a monad :D
15:09:42 <roconnor> gubagem: did you use unsafePerformIO?
15:09:46 <gubagem> nope
15:09:56 <roconnor> gubagem: hmm, so what did you do?
15:10:50 <gubagem> rewrote my save and load functions cause they were nulling out, commented out my main and mainloop, rewrote them and got rid of bugs
15:12:26 <vixey> yeah why is boomerang written in C?
15:12:37 <gubagem> vixey: whats boomerang?
15:13:03 <roconnor> gubagem: that sounds good, but i don't see how it is related to getting [Item] from IO [Item].
15:13:08 <vixey> oh it's written in ML
15:14:02 <gubagem> i did some IO and returned [Item] i think there was just bugs in other parts and the type was getting inferred wrong
15:14:17 <roconnor> gubagem: oh, that's good then
15:14:32 <roconnor> gubagem: keep it up.  Pretty soon you will hardly be using IO at all.
15:14:49 * roconnor remembers weening myself from goto when switching from Basic to Pascal.
15:16:01 * thetallguy remembers doing the same
15:16:29 <thetallguy> actually, global variables were what really took some time to flush out
15:16:41 <roconnor> thetallguy: I remember proudly showing my father a Pascal program with only 1 goto!
15:16:44 <gubagem> roconnor: i wanna tackle sockets soon :-(
15:16:52 * gubagem goes to play chess
15:17:49 <thetallguy> roconnor: My father had learned Algol and looked at the main of my big term project in Pascal, was impressed that the main was so simple, three lines, I think, init, process, print or some such
15:18:20 <thetallguy> roconnor: too bad the rest was ten pages of bugs
15:19:47 <roconnor> :)
15:20:10 <Peaker> is there a name for an angle between two 3d vectors? Such an angle would require two numbers to describe, right?
15:20:21 <thetallguy> actually, looking back, that program would have been great if I'd had quickCheck
15:20:26 <vixey> look up dot product
15:20:37 <nornagon> quaternions :D
15:20:46 <thetallguy> it did gaussian elimination on matrices using arbitrary precision rationals
15:21:41 <roconnor> nornagon: Clifford Algebras :D
15:22:12 <thetallguy> I wrote it all out, then spent forever tracking down bug after bug.  If I'd written it piece by piece and quickCheck'ed it, it would have been done right.
15:22:27 <dsrogers> ﻿Peaker: no it doesn't.  Two 3D vectors (with non-zero angle between them) define a plane.
15:22:41 <dsrogers> you define the angle within that plane.
15:23:15 <roconnor> I haven't used quickCheck much in Haskell yet
15:23:27 <Peaker> dsrogers, in 2d though, I can use a vector and an angle (a single number) to find another vector.  In 3d, what would I do instead?
15:23:43 * ptolomy2 is loving Data.Accessor... with my own sugar,  ["happy"] .-> (li 0 .: li 1) .= 'o' -- yields ["hoppy"]
15:23:58 <thetallguy> roconnor: I wrote a little arithmetic library and it was invaluable
15:24:22 <nornagon> a·b/(|a||b|) should give you the cosine of the angle between the vectors, iirc
15:24:22 <Peaker> dsrogers, If I want, given a vector and "angles", to create another vector
15:24:39 <roconnor> Peaker: in 3d you need another vector instead of a single number
15:24:40 <nornagon> a.b being |a||b|cos(t)
15:24:41 <dsrogers> you need another reference.
15:24:43 <dsrogers> yeah
15:24:54 <Peaker> roconnor, surely I can do it with less "information" than the whole extra vector?
15:24:56 <roconnor> Peaker: the vector gives the axis of rotation, and the length of the vector says how much to rotate around that axis.
15:25:46 <roconnor> Peaker: the topology of SO(3) is 3-D hence you need 3 numbers.  The topology of SO(2) is 1-D, which is why you only need 1 number for the 2-D case
15:25:47 <Peaker> roconnor, if I give two angles, how much to rotate in the xy plane, and how much in the xz plane, I can also generate another vector, and that's less "information" than a whole new vector, right?
15:26:09 * ptolomy2 secretly dreams that composable accessors will become widespread, automatically generated (or part of libs), and will be as performant as the manual alternative.
15:26:32 <roconnor> Peaker: you are still missing a degree of freedom.  (rotating in the yz plane perhaps?)
15:26:40 <noecksit> hello, do u guys know if there is a public darcs hosting site like github or repo.or.cz?
15:26:54 <dcoutts> Deewiant: if you'd like to test cabal-install on windows for us that'd be great
15:27:05 <Peaker> roconnor, Intuitively, perhaps, but I think that freedom is just to rotate the vector around itself (drill a hole in the wall :-)
15:27:07 <dsrogers> roconnor: no, I think he can borrow one of his axes implicitly for the extra vector, bacially.
15:27:14 <ptolomy2> Well, technically speaking, I guess I have no real evidence that there _is_ a performance penalty..
15:27:35 <roconnor> Peaker: oh, intresting.
15:27:46 <dsrogers> Peaker: but that's your answer.  You're extra number is mixed up in your choice of axes.
15:28:26 <Peaker> dsrogers, but that's cheating since its a fixed one
15:28:37 <dsrogers> axes are not fixed.
15:28:44 <dsrogers> you can always choose a different one.
15:28:58 <noecksit> guess not
15:29:02 <dsrogers> and if you choose a different one, with your rotation specified that way, you'll get a different operation
15:29:25 <dsrogers> whereas, with roconnor's original suggestion, the answer doesn't depend on the choice of axes.
15:29:33 <Peaker> dsrogers, well, the vector is represented in some way, which already assumes an axis
15:30:03 <Peaker> dsrogers, that's not a math thing, though but an implementation detail :)
15:30:14 <dsrogers> no, it's not quite the same.
15:30:42 <dsrogers> given a vector and two angles, if you change the axis, the vector changes, but the angles don't.
15:31:13 <dsrogers> given two vectors, they'll both transform with the axes.
15:31:59 <dsrogers> well, you can say, "in that case change the angles when you change the axes"
15:32:27 <dsrogers> but then the set of angles end up transforming like a vector.
15:32:36 <Peaker> I am actually trying to compute the vector that will return from a spherical mirror. I have the intersection point, the vector from the center of the sphere to the intersection, the vector that went to the intersection, I want to compute the vector from the intersection
15:33:24 <Peaker> I was thinking of using atan2 on the difference between the two vectors in two orthogonal planes, and then rotating the vector by the negation of those degrees to find where it will mirror to
15:33:56 * bos uploads new bloom filter package to hackage.
15:34:07 <tirpen> Just rotate the vector 180 degrees around the normal vector?
15:34:11 <dsrogers> yeah
15:34:59 <dsrogers> you only need one plane.
15:35:07 <dsrogers> the plane defined by the normal to the surface.
15:35:20 <Peaker> the normal in this case would be the spherical center to the intersection point
15:35:36 <Peaker> I need to do the trigonometry to see how to rotate it that way
15:35:54 <dsrogers> it's a linear transform.
15:35:58 <dsrogers> use a matrix.
15:35:59 <thetallguy> bos: looks nice
15:36:08 <dsrogers> or compose some matricies
15:36:32 <Peaker> dsrogers, I'd need a matrix type and to break a lot of existing code, I just do the trig manually :)
15:37:13 <dsrogers> well yo ucan use matrices on paper to derive the formula you need
15:37:52 <dons> bos, nice announce.
15:38:03 <bos> thetallguy, dons: thanks!
15:38:05 <dons> pleased with the performance in the end?
15:38:08 <Peaker> Then I'd need to look up how rotation matrices look like - but I'd rather do it all without looking up such things :)
15:40:25 <roconnor> rotation matricies look like exp([[0,z,y],[-x,0,x],[-y,-z,0])
15:42:00 <nornagon> exp?
15:42:13 <Peaker> but part of the fun in this project is doing it all from first principles, and I wouldn't want to learn the proofs behind that matrix for this
15:42:15 <nornagon> nuts :)
15:42:21 <roconnor> 1 + A + (1/2)*A^2 + ...
15:42:38 <Peaker> so I am just looking at each problem separately and solving it ad-hoc'ishly on paper :)
15:42:46 <Peaker> (its a toy, after all)
15:43:24 * thetallguy contemplates various uses for a bloom filter
15:44:11 <dolio> You could make a 3d engine with phat graphix!
15:44:31 <bos> dons: pleased enough. it does more consing than i'd like, but that would be very difficult to avoid without making the code really horrible.
15:44:31 <dolio> The more bloom the better.
15:44:31 <thetallguy> long ago, in the days of slow disks and small memories, I had a friend who made a spell checker with a probabilistic filter
15:44:46 <thetallguy> he figured you got more errors from homonyms than from false positives
15:45:15 <bos> homonyms. their a problem.
15:45:20 <thetallguy> lol
15:45:28 <thetallguy> I nearly corrected that out of habit
15:45:29 <lilac> thetallguy: have you read Programming Pearls?
15:45:39 <xif> hai!
15:45:41 <thetallguy> lilac: uhhhh
15:45:48 <thetallguy> lilac: all of them?
15:46:03 <lilac> thetallguy: the book version, specifically. it's got a section on a spell checker written by (IIRC) Doug McIlroy, which was apparently pretty cool
15:47:00 <thetallguy> lilac: ah yes, you were referring to Bentley's column
15:47:16 <thetallguy> lilac: sounds interesting
15:48:08 <thetallguy> my favorite spell checker of all time represented the dictionary as a finite state machine, then ran myhill-nerode on it and wrote the minimal machine to disk
15:48:09 <lilac> thetallguy: as i recall, it used a combination of suffix analysis, hashing and a fairly nutty compressed datastructure to fit the dictionary in a few K
15:48:24 <thetallguy> I'm not sure if that was the one that actually represented the state machine as assembler or not
15:48:45 <thetallguy> but the resulting file was significantly smaller than the original dictionary (sans definitions)
15:49:03 <thetallguy> lilac: sounds like that might be the same algorithm
15:49:11 <thetallguy> or a cousin
15:50:09 <lilac> thetallguy: i was mainly wondering if you were talking about the same guy ;-)
15:50:20 <Bonus> anyone here read "Programming in Haskell"?
15:50:31 <Bonus> im thinking about buying it but i fear it might be a bit too basic
15:50:46 <dsrogers> I have it in my hands right now
15:50:47 <thetallguy> lilac: I read of the finite state disctionary in CACM mid '80s
15:50:53 <dsrogers> I just bought it.
15:50:53 <thetallguy> don't remember any other details
15:50:58 <Bonus> cool
15:51:14 <Bonus> what are the last few chapters of the book if you skim it
15:51:17 <Bonus> i mean like what topics
15:51:30 <thetallguy> about that time I did see Jon Bentley give a symposium on approximate solutions to NP complete problems
15:51:53 <dsrogers> you can get the table of contents from google book search
15:52:03 <Bonus> ooh, didnt know that
15:52:10 <dsrogers> it seems to have good coverage of the types and classes.
15:52:23 <dsrogers> err, syntax, and basic fp structure.
15:52:27 <thetallguy> he was surprised to discover that this hard problem had fast solutions that were provably within 1% of optimal
15:52:58 <thetallguy> so he did a bunch of experimental work comparing all these algorithms on a big library of sample graphs
15:53:46 <thetallguy> it was a theory seminar and a friend of mine swore she heard the hard-core theoreticians saying ``Poor Bentley, he used to do good work before he started on this experimental stuff...''
15:54:11 <dsrogers> it has good organization, I like his "first principles" explanations
15:54:43 <thetallguy> lilac: anyway, thanks for the tip.  I might pick that book up.
15:55:03 <lilac> thetallguy: well, i enjoyed it ;-)
15:55:07 <thetallguy> has anyone rewritten them all in Haskell?
15:55:07 <dons> more on performance, the comparison of mlton and streamf fused haskell arrays here is pleasing, http://reddit.com/info/6lfh1/comments/
15:55:08 <thetallguy> ;-)
15:55:17 <dsrogers> and so far, there is a good range of exercises.
15:55:47 <dsrogers> the cons are that it's short, and so doesn't go in depth on many of the concepts that are actually troubling me.
15:56:12 <thetallguy> dons: ugh, all those let's bring back bad memories. ;-)
15:56:15 <monochrom> experimental theory
15:56:29 <dsrogers> he also doesn't cover optimization
15:56:43 <monochrom> We are on our way to beat mlton?
15:57:12 <dons> thetallguy: hehe
15:57:21 <dons> monochrom: well, check out the comments
15:57:32 <dons> yes, stream fusion kicks butt here
15:58:29 <dons> foldl is basically a macro for a nice little :L1 ; ... ; jmp L1
15:58:30 <Bonus> dons when is real world haskell ocming out in real book form do you have a timeline
15:58:51 <dons> soon!
15:59:00 <Bonus> awesome
15:59:10 <Bonus> gonna tap that
15:59:27 <EvilTerran> for two white mana!
15:59:32 <Bonus> zing!
15:59:43 <thetallguy> dons: there was a great exchange about that during my CUFP 2006 talk. SPJ asked about the experience programming in each and I complained that everything in ocaml ended up as a big series of nested lets
16:00:10 <thetallguy> dons: and SPJ turned to the MLers and said ``The truth hurts, doesn't it?''
16:00:26 <EvilTerran> ha!
16:01:03 <thetallguy> I made it clear that both languages are excellent and I'd choose either above any 'big' language...
16:01:14 <EvilTerran> ?remember thetallguy I complained that everything in ocaml ended up as a big series of nested lets, and SPJ turned to the MLers and said ``The truth hurts, doesn't it?''
16:01:14 <lambdabot> It is forever etched in my memory.
16:01:24 <thetallguy> oh, no
16:01:33 <thetallguy> You're not supposed to write it down...
16:01:39 <thetallguy> lol
16:02:10 <EvilTerran> oh well. it's forever etched in her memory now.
16:02:26 <monochrom> Everything in Haskell ends up as a big series of x <- m y.
16:02:38 <dons> thetallguy: hehe
16:02:54 <thetallguy> monochrom: that's true, the IO monad takes some work to make it look nice
16:03:11 <thetallguy> monochrom: like Conal, I want to get away from that.
16:03:25 <bos> bloom filter blog posting: http://reddit.com/info/6lgum/comments/
16:03:57 <thetallguy> monochrom: now that I think about it, David went to the 2004 CUFP and came back saying that was the big complaint about Haskell.
16:04:19 <cjb> bos: bah, taunting me -- I started working on a bloom filter in Python yesterday and had trouble.
16:04:32 <monochrom> Every ocaml "let x = m y" is haskell "x <- m y".
16:04:43 <cjb> bos: also, IIRC, Bloom filters can easily be configured with a false negative rate, too.
16:04:44 <bos> cjb: heh, sorry :-)
16:05:02 <bos> cjb: you do not RC
16:05:09 <cjb> RC?
16:05:16 <bos> recall correctly.
16:05:22 <monochrom> The only difference is sometimes you need no y, and it becomes "let x = m ()" vs "x <- m".  You can claim an advantage there.
16:05:29 <cjb> ah, ok, let me research.
16:06:34 <bos> cjb: http://en.wikipedia.org/wiki/Bloom_filter
16:07:01 <thetallguy> monochrom: but you have >>= and other such concise ways of composing things
16:07:12 <cjb> I know the standard formulation doesn't provide for false negatives, but I thought there was a simple enhancement (combination?) that did.  I'll stop talking until I've worked out what I'm remembering.  :)
16:08:54 <bos> cjb: the idea of a false negative doesn't really make sense.  a counting bloom filter could have a false negative, but they're pretty dodgy structures anyway.
16:09:06 <cjb> Yeah, counting bloom filters were what I was thinking of.
16:09:16 <cjb> I understand it's not really a bloom filter anymore when you invert it.
16:09:22 <cjb> (or rather, that you *can't* invert it.)
16:09:33 <cjb> Okay.  Sorry for the noise.
16:09:47 <cjb> I saw that "Beyond Bloom Filters" paper recently; that's what was triggering my memory.
16:17:51 <dons> mm. ocaml does some nasty things in that loop/foldl program
16:18:08 <dons> i think ghc can rightfully claim the mantle as optimising compiler of choice now
16:18:37 <dons> e.g. "Another nasty effect of partial applications is that they prevent inlining. It is a common style to define small generic functions and make specialized versions through partial application. "
16:18:50 <dons> we gain so much with the super aggressive inlining in ghc
16:19:29 <monochrom> Yeah.
16:20:54 <UtopiahGHML> hello
16:21:05 <bos> the inlining made a big difference to the performance of the bloom filter library.
16:21:11 <bos> probably 20% or so.
16:21:38 <bos> specialisation less so, perhaps 5%.
16:22:55 <UtopiahGHML> does someone tried to use UML (or another modeling language or software engineering oriented method) to prepare the writing of a large software in a functional programming language ? (Haskell or not actually)
16:23:38 <bos> no, UML makes no sense for functional languages.
16:23:54 <bos> arguably, it makes no sense in any setting.
16:24:03 <dons> we use a different modelling pseudocode :)
16:24:18 <thetallguy> dons: I think the upside of GHC being a community compiler is coming through nicely
16:24:34 <dons> thetallguy: more eyes looking at the optimiser? or ?
16:24:42 <thetallguy> dons: so many people dismiss Haskell as a research language
16:25:22 <UtopiahGHML> bos: so... what is the alternative ? I like boxes ;)
16:25:23 <bos> we just need one or two web 2.0 startups to pick it up.
16:25:24 <thetallguy> dons: but over time, having all those researchers proposing/adding optimizations should pay off
16:25:34 <dons> that's right.
16:25:37 <thetallguy> dons: not just eyes and minds
16:25:40 <bos> UtopiahGHML: beats me.  i like writing code.
16:25:44 <newsham> > let fib 0 = 0; fib 1 = 1; fib n = (let l = fib (n-1); r = fib (n-2) in r `par` (l `pseq` l+r)) in fib 35
16:25:44 <eu-prleu-peupeu> i have a web 2.0 startup
16:25:48 <dons> there's an unstoppable mountain of optimisations inside ghc now
16:25:48 <lambdabot>  9227465
16:25:49 <thetallguy> sorry, not just eyes, but eyes and minds
16:25:56 <newsham> how many cores hath the bot?
16:26:01 <dons> 1, atm
16:26:08 <dons> we did run it on a 16 core machine for a while
16:26:13 <dons> `par` was fun
16:26:19 <eu-prleu-peupeu> if you want, you can check it: http://point.pt
16:26:20 <lambdabot> Title: == point.pt == Alertas por sms GRATUITO
16:26:28 <eu-prleu-peupeu> yes :)
16:26:33 <eu-prleu-peupeu> labdabot is smart
16:26:37 <newsham> some day all bots will have 16cores!
16:26:41 <thetallguy> this has always been part of my elevator pitch, that Haskell, GHC in particular, is a technology transfer conduit
16:27:07 <dons> yeah, that's right. we have a fast track from research into production
16:27:27 <bos> duh, my spellchecker was two lines longer than it needed to be. that's just criminal. don't code while tired, kids!
16:27:45 <MyCatVerbs> thetallguy: "technology transfer conduit"?
16:27:53 <thetallguy> it's sort of the corollary of something David Fox said about his thesis work.  When asked at SIGGRAPH if it was fast enough, he said, ``Yes, after several applications of Moore's Law.''
16:27:57 <newsham> ie. "its a series of tubes"
16:28:00 <dons> its not atypical for production use of newly invented language optimisations and features at around the same time as publication of the initial results
16:28:13 <mrd> bos: 200% the size it should be?
16:28:33 <thetallguy> MyCatVerbs: yes, you stand at the mouth of the river and nutrients flow to you...
16:28:35 <bos> mrd: shameful, eh?
16:29:14 <MyCatVerbs> bos: oh man, I -wish- my programs were merely O(1) lines longer than necessary. More often I end up writing things that're too long by a polynomial in the amount of atoms in the universe. :P
16:29:26 <thetallguy> dons: which of course then provides the inevitable tension about changing syntax and features
16:29:33 <UtopiahGHML> so... no formalism for analyse or architecture of boxes for func languages ? (I found a thesis about an obscure thing but was too lazy to dive deeper in it)
16:29:49 <newsham> thetallguy: hydroponics?
16:29:59 <bos> UtopiahGHML: usually, the code is the model.
16:30:18 <thetallguy> but from my perspective, it's obviously so much easier to keep up than to invent/implement it all onself.
16:30:24 <eu-prleu-peupeu> bos: that works fine for small snippets
16:30:40 <bos> eu-prleu-peupeu: hmm?
16:30:50 <thetallguy> oddly, I think it's the mathematicians/theory researchers who complain the most
16:30:53 <MyCatVerbs> newsham: I think what he means is that, if you sit still for about a year or two, SPJ will come up with some new thing that magically makes your program a third faster, without any effort on your part.
16:31:04 <UtopiahGHML> bos: well to me that lacks a level of magnitude, you need to be able to "zoom-out" and see modules or architecture without having to dive into the code itself
16:31:11 <eu-prleu-peupeu> you can't have "the code as the model" in a 100.000+ lines project
16:31:18 <thetallguy> you'd think they would just make a Haskell98 -> Haskell' converter...
16:31:20 <monochrom> UML is not a formalism either.
16:31:21 <bos> eu-prleu-peupeu: code-as-model works just fine for tens of millions of lines of code too.
16:31:31 <newsham> mycatverb: thats cool and all, but moore just made it 2.5x faster
16:31:44 <thetallguy> newsham: no, I like to get my hands dirty, or at least have the opportunity
16:32:02 <eu-prleu-peupeu> i wont argue bos, but my experience tells me otherwise
16:32:16 <dons> for formalisms, we usually use theorem provers
16:32:20 <UtopiahGHML> bos : but doesnt it risk to form a bias of implementation ?
16:32:29 <bos> eu-prleu-peupeu: i've worked on a number of million+ LOC projects. my modelling tool is grep.
16:32:48 <dons> :)
16:32:59 <thetallguy> bos: funny, the Codeweavers guys said the same thing
16:33:08 <eu-prleu-peupeu> bos: you and how many other programmers ?
16:33:13 <newsham> bos: you shoulda spent some resources to make it smaller :)
16:33:30 <bos> eu-prleu-peupeu: dozens of people per project.
16:33:52 <eu-prleu-peupeu> ok
16:34:00 <bos> i do think there's a place for modelling tools, in fact.
16:34:00 <thetallguy> bos: although, in fact, they would use xterm and less and just page through big logs of output at high speeds
16:34:10 <monochrom> I think you will be surprised that certain assertions like "modeling language is more abstract than code" and "recursion is inefficient" are much less true for Haskell.
16:34:20 <dons> heh
16:34:22 <thetallguy> bos: when the visual pattern changed, they'd stop and back up and find the problem
16:34:29 <bos> that kind of place would be the back office of an accountancy firm, or some other such crawling horror.
16:34:34 <dons> monochrom: our code is more abstract than our models :)
16:34:37 <eu-prleu-peupeu> recursion is inefficient if you are using it on linear stack based languages
16:34:39 <UtopiahGHML> :)
16:34:45 <monochrom> I think if you have a billion-line haskell project, you may need a modeling language.
16:34:56 <bos> monochrom: i look forward to that day.
16:35:01 <eu-prleu-peupeu> if its not linear stack based, then its inefficient by nature :P
16:35:06 <newsham> you can use the same language for modelling and implementation and still have them be two distinct things
16:35:11 <thetallguy> monochrom: I think ifyou have a billion-line haskell project, you've missed the point
16:35:20 <dons> a billion lines of haskell eh
16:35:30 <monochrom> Quickcheck and Smallcheck's specification language will be part of a modeling language suitable for Haskell.
16:35:39 <dons> that's about ~200x as much haskell as is in the world
16:35:44 * dons speculates
16:36:03 <thetallguy> think of all those thunks
16:36:12 <newsham> i can write that in 10kloc in 6mos, if you want it any smaller it will take longer....
16:36:16 <gnuvince_> "I thunk, therefore I am not (yet)"
16:36:20 <mar77a> is haskell code compiled to C then compiled using gcc?
16:36:22 <bos> dons: i think we'll pass a billion lines of total haskell by about 2013.
16:36:23 <newsham> lazy bottoms thunk empty thoughts
16:36:53 <thetallguy> bos: it should compress over time, though
16:36:56 <monochrom> @remember gnuvince I thunk, therefore I am not (yet)
16:36:56 <lambdabot> Nice!
16:37:10 <dons> bos, that seems possible. i'd not be surprised if the amount of haskell was doubling each year
16:37:13 <dons> or more
16:37:24 <monochrom> @remember newsham lazy bottoms thunk empty thoughts
16:37:25 <lambdabot> Nice!
16:37:43 <mrd> mar77a: ghc has a gcc backend, but nowadays it uses its own native-code backend by default
16:37:48 <bos> thetallguy: true.
16:39:43 <thetallguy> bos: although, I suppose inevitably, the larger the base of haskell programmers, the less meticulous they will be
16:39:44 <monochrom> I agree that the ease of re-factoring in Haskell postpones a project reaching a billion lines, like various quantum effects postpones a star becoming a black hole.  But if your project is ambitious, like mimicking human mind fully, it may reach that point.
16:39:46 <UtopiahGHML> well, thanks for your insights, basically I'll have to ... find my way ;)
16:39:58 <bos> UtopiahGHML: afraid so.
16:40:37 <UtopiahGHML> my model predicted that anyway but I had to verify, just in case I was in a dream world
16:40:38 <thetallguy> Did you all read the interview with the group that makes/maintains the shuttle launch code?
16:40:38 <bos> thetallguy: yes, for sure.  we already see a big reversion to the mean in the quality of python hackers, and ruby hackers couldn't collectively spell their own names any more thanks to tails.
16:40:53 <thetallguy> bos: heh
16:41:09 <UtopiahGHML> ciao, have a nice day everybody
16:41:13 <bos> that was a brilliant interview, but i never, ever want to develop space shuttle code :-)
16:41:25 <thetallguy> bos: I think the correct answer is fewer programmers wielding more powerful tools
16:42:16 <monochrom> Precisely why sometimes I think "Joe/Jane Programmer" is better off writing 0 lines of code.
16:42:33 <MyCatVerbs> bos: y'know, C++ once had exclusively awesome hackers as its users, and the same is true of Java.
16:42:38 <eu-prleu-peupeu> stop being elitist
16:42:51 <monochrom> Why?
16:43:05 <bos> MyCatVerbs: i was around for, and participated in, both of those waves.
16:43:06 <monochrom> You speak as though elitism is axiomatically dogmatically wrong.
16:43:31 <gnuvince_> Because people with bad eye sight should be able to fly planes and people with parkinson's disease should be able to do brain surgery
16:43:51 <eu-prleu-peupeu> ok, continue then
16:43:54 <monochrom> Since we now embrace some kind of relativism, "nothing is wrong", I may as well also be elitist. It's just another perspective and suggested solution.
16:44:03 <dons> in the future, your dna will be tested to determine if you can work as a programmer.
16:44:14 <MyCatVerbs> eu-prleu-peupeu: it's true, though. Empirican observation backs it up again and again and again.
16:44:20 <bos> gnuvince_: buh?
16:44:40 <gnuvince_> bos: people who don't have the capacity to do a job should not be doing it.
16:44:54 <monochrom> gnuvince_ is being sarcastic. :)
16:44:57 <thetallguy> dons: now there's a sci fi novel
16:45:05 <dons> heh. i think i saw that movie
16:45:15 <bos> gattaca for haskellers.
16:45:20 <Peaker> bad programmers can create bad programs, which are sometimes better than no programs at all.  But they cannot help good programmers make good programs
16:45:23 <MyCatVerbs> thetallguy: eh, that film has already been shot and sent to the cinemas. Dunno if it was any good, though.
16:45:36 <dsrogers> the elitism comes in here, when you toss out all the stuff that medicore programmers have created just because it wasn't done well.
16:45:45 <eu-prleu-peupeu> everybody can learn how to program
16:45:48 <dsrogers> there is a lot of shit out there, that still magically gets the job done.
16:45:55 <thetallguy> bos: scary to actually control real devices with people in them, eh?
16:46:01 <eu-prleu-peupeu> ...its a matter of practice, and having the right guidance
16:46:11 <mrd> what's wrong with elitism?
16:46:16 <MyCatVerbs> eu-prleu-peupeu: er...
16:46:26 <bos> thetallguy: partly that, but mostly the incredible boredom would get me.
16:46:38 <Peaker> eu-prleu-peupeu, I think you may have not been exposed, or ignored completely, the amount of stupidity that is out there :)
16:46:38 <thetallguy> bos: I wonder if the more one knows about programming, the less one is inclined to brave that sort of thing.
16:46:39 <gnuvince_> mrd: the anti-intellectualism people don't like it
16:46:48 <dsrogers> it's dismissive and fails to recognize the value of other human beings unless they meet (often unattainable) standards.
16:46:57 <thetallguy> bos: I really liked the fact that they kept the entire history
16:47:07 <bos> thetallguy: they do many amazing things.
16:47:12 <thetallguy> bos: I've been noodling about ways to do that in literate style
16:47:29 <MyCatVerbs> eu-prleu-peupeu: no? Seriously, no. That's no more true than is the assertion that everybody can run a marathon. There exist people with no legs., and analogously...
16:47:58 <thetallguy> bos: discussions on -cafe where people talk about floating point, then Lennart comes in and talks about decisions made 15 years ago...
16:48:06 <glguy> MyCatVerbs: they let the people in wheelchairs go first because they tend to do it faster
16:48:23 * mrd is very thankful for the elite programmers that work on haskell projects
16:48:28 <thetallguy> bos: it would be nice to see those decisions and discussions attached to the relevant code.
16:48:30 <MyCatVerbs> glguy: ... and no fucking arms, jeez.
16:48:38 * thetallguy seconds mrd
16:48:40 <MyCatVerbs> glguy: stop breaking my analogies, damn you! ;)
16:48:52 <eu-prleu-peupeu> :D
16:49:06 <MyCatVerbs> glguy: and if you suggest putting a jet engine on Stephen Hawking's wheelchair then I can't be your friend.
16:49:18 <Peaker> People forget, but there are some really, really, really stupid people out there :)
16:49:28 <MyCatVerbs> glguy: (though we can be best enemies, because suggesting that would make me think you were awesome.)
16:49:39 <MyCatVerbs> Er, s/can/could/, sorry.
16:49:46 <Peaker> There's nothing wrong with being stupid, someone who is stupid deserves no less, but he cannot program non-trivial things
16:51:08 <dsrogers> does the Ord instance of String respect unicode wrt lexigraphic ordering?
16:52:19 <dsrogers> boy that's a way to silence a room.
16:52:25 <eu-prleu-peupeu> i think you guys are playing defense because haskell is probably easier to code...
16:52:38 <Saizan_> > "\x1000" < "\x999"
16:52:39 <lilac> > '\xeb' < 'f'
16:52:39 <lambdabot>  False
16:52:40 <lambdabot>  False
16:53:29 <lilac> dsrogers: it can't; unicode has combining chars, and Ord String is just Ord [Char] which is instanced as Ord x => Ord [x] IIRC
16:54:29 <dsrogers> ah, I see.
16:54:56 <dsrogers> yeah, besides which, ordering by codepoint is not lexigraphic anyway
16:55:22 <lilac> quite
17:00:24 <EvilTerran> does the unicode consortium specify a sort order or something?
17:00:51 <bos> no, sorting order depends on both language and characters.
17:01:44 <dsrogers> ....
17:01:48 <dsrogers> the answer was yes.
17:01:57 <dsrogers> yes, unicode defines a sort order.
17:02:26 <bos> http://en.wikipedia.org/wiki/Unicode_collation_algorithm
17:03:04 <EvilTerran> ok
17:03:18 <dsrogers> but "depending on language" thing is not new to unicode.
17:03:42 <bos> yes, strcoll predates unicode by years.
17:12:23 <gwern> hum. I wonder whether hlean or hback are on hackage yet
17:12:24 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
17:12:33 <gwern> @messages
17:12:33 <lambdabot> vincenz said 2d 5h 46m 2s ago: don't release broken packages, thank yoy
17:12:59 <gwern> @seen vincenz
17:12:59 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
17:13:12 <gwern> 0.o
17:13:24 <gwern> @seen vincenz
17:13:24 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
17:13:33 <gwern> OK...
17:13:48 <gwern> @tell vincenz whatever do you mean? I have been away a little while
17:13:49 <lambdabot> Consider it noted.
17:17:30 <byorgey> gwern: IIRC it was in reference to the lambdabot package on hackage
17:17:35 <byorgey> which is apparently broken
17:18:02 <gwern> ah. yeah, that is not surprising. lambdabot is seriously messy, IMO
17:18:51 <byorgey> indeed
17:19:06 <Saizan_> his point was that it's not much sense to make a package that is unlikely to work :)
17:32:05 <gwern> perhaps. but I think it was a useful little step, and if it failed to build on hackage, then it will warn you so
18:12:14 <OceanSpray> types classify values
18:12:20 <OceanSpray> classes classify types
18:12:28 <OceanSpray> what classifies classes?
18:13:08 <Liempt> Classifiers.
18:13:09 <Liempt> >_>
18:13:10 <Liempt> <_<
18:14:42 <roconnor> classes classify types?
18:14:50 <OceanSpray> sort of.
18:14:56 * roconnor ponders that
18:14:56 <OceanSpray> it's how I think of them.
18:15:13 <shachaf> OceanSpray: Not in the same way that types classify values, anyway.
18:15:20 <OceanSpray> eh.
18:15:33 <roconnor> values have unique types
18:18:33 <byorgey> OceanSpray: kinds classify types.
18:18:55 <byorgey> in the same way that types classify values.
18:19:26 <byorgey> Haskell doesn't have anything beyond that level, but you can easily imagine more levels beyond that
18:19:49 <byorgey> for example, Tim Sheard's language Omega has an infinite heirarchy of user-extensible kinds
18:22:10 <mar77a> > 1 / 2 / 2 / 1 / 2 / 2 / 1 / 2 / 2
18:22:11 <lambdabot>  1.5625e-2
18:22:22 <mar77a> > 1 / 2 / 2 / 2 / 2
18:22:24 <lambdabot>  6.25e-2
18:22:40 <mar77a> oh
18:23:45 <dolio> Classes are sort of like extensible kinds.
18:24:01 <dolio> Single-parameter ones, at least.
18:24:05 <newsham> is there a win32 binary for gtk2hs that works with 6.8.2?
18:34:47 <NReed> Hey how would you guys sum two lists together into one list?
18:35:03 <NReed> i assume you could use map for that kind of thing
18:35:09 <NReed> but i couldnt figure out how
18:35:20 <mar77a> zipWith i think
18:35:22 <mar77a> :t zipWith
18:35:24 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
18:35:49 <mar77a> > zipWith (+) [1,2,3] [1,2,3]
18:35:51 <lambdabot>  [2,4,6]
18:36:17 <NReed> ah thanks
18:53:12 <roconnor> why does array fusion do better than stream fusion?
18:53:30 <roconnor> maybe I don't understand dons comments
18:53:37 <roconnor> http://reddit.com/r/programming/info/6lfh1/comments/c046ml9
18:54:51 <dolio> Array fusion is stream fusion.
18:54:57 <dolio> Lists aren't currently stream fused.
18:55:03 <roconnor> ?
18:55:10 <byorgey> maybe because it's parallelizable?
18:55:11 <roconnor> lists aren't stream fused?
18:55:19 <SamB> roconnor: array fusion is like list fusion, only for arrays
18:55:21 <dolio> Nope. They still use foldr/build.
18:55:42 <roconnor> but what about all that stream fusion from a few years back?
18:55:47 <SamB> roconnor: the stream-based implementation of list fusion hasn't hit base yet
18:55:56 <roconnor> but array fusion has?
18:55:56 <SamB> wasn't that last year?
18:55:59 <dolio> There's a package for stream-fused lists on hackage, but it's not rolled into GHC (yet).
18:56:45 <dolio> Note, those fused arrays that dons is talking about aren't good for use as arrays.
18:56:59 <roconnor> no they aren't
18:57:02 <SamB> dolio: eh?
18:57:05 <SamB> what are they like?
18:57:20 <dolio> Indexing into them is like indexing into a stream.
18:57:22 * SamB goes to look for blog post or whatever
18:57:44 <dolio> Because it all gets rewritten into streams, currently.
18:57:59 <dolio> I don't think there's an interface to use the arrays yet.
18:58:09 <dolio> Well, the mutable ones there is, but not the immutable ones.
19:00:16 <dolio> For instance, if in ghci you do 'let a = enumFromToU 1 1000000 :: UArr Int' each subsequent 'lastU a' takes a second or so.
19:04:26 <roconnor> UArr is unboxed Array?
19:04:38 <dolio> Yeah.
19:04:50 <roconnor> why does lastU take so long?
19:05:15 <dolio> Because currently the library doesn't actually make an array. It's more like convenient combinators for programming with streams.
19:05:52 <dolio> I think dons plans on making combinators for actually using the arrays, but it hasn't happened yet.
19:05:52 <roconnor> um
19:06:01 <roconnor> in what way is UArr an unboxed array then?
19:06:24 <dolio> Well, there is code for unboxed mutable arrays in there, too.
19:06:38 <roconnor> this all doesn't make any sense
19:06:39 <dolio> There just aren't combinators for the immutable ones that don't get run through streams.
19:06:48 <roconnor> I feel like i'm in the twilight zone
19:06:52 <dolio> Unless I'm missing something.
19:07:12 <roconnor> we have array fusion for arrays that don't exist, but no stream fusion for lists that do exist.
19:07:25 <dolio> There actually might be such things, but they're not exported in the publicly accessible module.
19:07:30 * roconnor loses his mind
19:07:46 <dolio> It's actually stream fusion for arrays that don't exist. :)
19:08:02 <roconnor> right
19:08:19 <SamB> oh... kay...
19:08:43 <roconnor> okay, I'm putting a moratorium on all functions ending in U for one year
19:08:54 <roconnor> I will ignore them and all discussions about them.
19:08:55 <dolio> @hackage stream-fusion
19:08:55 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stream-fusion
19:08:59 <roconnor> for my own sanity
19:09:11 <dolio> That has stream fused lists.
19:10:20 <dolio> I haven't tried it myself.
19:11:40 <dolio> It appears to be slated for inclusion in 6.10.
19:13:56 <dolio> Not much activity on the track ticket, though.
19:14:07 <SamB> trac!
19:14:32 <dolio> Oh, yeah. I meant to type that, but my fingers spelled it like the real word by mistake. :)
19:14:57 <TomMD> GHC 6.10 also includes the "genSource :: EnglishString -> HsSource" funcion.  This will place extreme pressure on groups like "galois, well-typed :: Money -> HsSource"
19:16:49 <dolio> I guess dons says in that ticket that it's pretty much done. I guess they got list comprehensions working?
19:51:20 <hpaste>  gubagem pasted "contents of m.bat" at http://hpaste.org/7999
19:51:36 <gubagem1> or is that only to be used for haskell code? ;)
19:58:03 <hpaste>  NEwws pasted "(no title)" at http://hpaste.org/8000
19:58:26 <NReed> woops messed up my name :P
19:58:32 <NReed> but thats my code snippet
19:58:42 <gubagem1> and that works?!
19:58:42 <NReed> i was wondering if someone could explain why this is rejected
19:58:45 <NReed> matrixSum [[1,2],[3,4]] [[1,2],[3,4]]
19:59:44 <Zao> Since Matrix is a newtype, you need to do   matrixSum (Matrix ...) (Matrix [[1,2],[3,4]])
20:00:06 <Zao> It cannot be implictly constructed.
20:00:23 <NReed> hm.. is there a way for that to be implicitly converted?
20:00:48 <Zao> Use data instead of newtype.
20:00:56 <Zao> Maybe.
20:01:02 <roconnor> Use type instead of newtype
20:01:06 <Zao> Or type or whatever the keyword is.
20:01:39 <NReed> alright
20:01:44 <NReed> and whats the difference between newtype and type?
20:02:29 <bd_> NReed: type doesn't make a new type - it just makes a new name for an existing one
20:02:56 <bd_> newtype makes a new type which is stored identically to an existing one, but treated seperately by the type resolver
20:02:59 <NReed> oh alright thats what im looking for then
20:03:13 <NReed> thanks you guys
20:06:48 <NReed> hm well im still having problems
20:06:56 <NReed> i directly swapped out newtype with type
20:07:24 <NReed> but now i get a "matrix.hs:3:11: Not in scope: data constructor `Matrix' matrix.hs:3:22: Not in scope: data constructor `Matrix'"
20:07:46 <chessguy> !paste
20:07:46 <hpaste> Haskell paste bin: http://hpaste.org/
20:07:55 <chessguy> NReed:  ^^
20:08:05 <NReed> already did: http://hpaste.org/8000
20:08:15 <chessguy> oh, musta been before i got here
20:08:26 <NReed> ya right before :P
20:08:50 <mar77a> > 0^0
20:08:51 <lambdabot>  1
20:08:55 <mar77a> > 0 ** 0
20:08:56 <lambdabot>  1.0
20:11:15 <NReed> so any one know why im getting those errors?
20:12:53 <nolrai_> :t signum
20:12:54 <lambdabot> forall a. (Num a) => a -> a
20:13:03 <Saizan_> NReed: if you use type then you don't have a constructor Matrix anymore
20:13:20 <nolrai_> why is there only one 'n' in signum?
20:13:40 <NReed> so how do i make sure that m1 and m2 are type Matrix?
20:13:57 <chessguy> type signature?
20:14:31 <nolrai_> m1 :: Matrix
20:15:18 <NReed> so I should add "matrixSum :: Matrix -> Matrix -> Matrix"?
20:15:28 <gubagem1> is reinventing the wheel ok in haskell?
20:16:00 <Saizan_> NReed: yeah, if you want
20:16:38 <chessguy> except the way you have it written, it's (Matrix, Matrix) -> Matrix
20:17:14 <NReed> ya i removed the braces just now
20:18:11 <Saizan_> gubagem: why do you ask?
20:18:21 * Surfer24 Visit http://www.FakeMagazineCover.com (upload pic make mag) - http://www.SillyWebcam.com (play with webcam online) - http://www.Is-A-Jerk.com (insulter/anon email) - http://www.ComedySearchEngine.com (fun) - http://www.BodySwitcher.com (put your face on funny body) - http://www.MedChecker.com (health) - http://www.Canuckster.com (Canada eh) - http://www.Nerdful.com (geeks)
20:18:23 <lambdabot> Title: Fake Magazine Cover Maker, Make Parody Covers With 500 Magazines Templates, Uplo ...
20:18:38 <Surfer24> http://www.FakeMagazineCover.com - Upload photo to fake magazine cover templates
20:18:39 <lambdabot> Title: Fake Magazine Cover Maker, Make Parody Covers With 500 Magazines Templates, Uplo ...
20:18:46 <Surfer24> http://www.SillyWebcam.com - Play with webcam online (games, take pics, effects)
20:18:47 <lambdabot> Title: Silly Flash Webcam Tricks & Effects - Take Instant Photos Online For Free With W ...
20:18:52 <Surfer24> http://www.Is-A-Jerk.com - Random Insults/Anon Email
20:18:54 <lambdabot> Title: Who Is A Jerk? Random Insult Generator (DANGER/BEWARE)
20:18:59 <Surfer24> http://www.VirtualHolyBible.com - Holy Bible, online version
20:19:00 <lambdabot> Title: Virtual Holy Bible  Online Bible
20:19:07 <Surfer24> http://www.ScrapbookGenerator.com - Make free online digital scrapbook pages
20:19:08 <lambdabot> Title: Scrapbook Generator, The Web 2.0 Scrapbooker For Free Online Digital Scrapbookin ...
20:19:09 --- mode: ChanServ set +o Saizan
20:19:12 <Surfer24> http://www.WHAK.com - W.H.A.K. Comedy Radio
20:19:17 --- mode: Saizan set +b *!*=javachat@*.twcny.res.rr.com
20:19:17 --- kick: Surfer24 was kicked by Saizan (Saizan)
20:19:18 <lambdabot> Title: Get Whacked, WHAK Comedy Radio Is Now Online!
20:19:25 * chessguy looks for a lead-lined refrigerator
20:19:32 * gubagem lawls
20:20:07 <Saizan> hah, i should keep me identified..
20:20:26 --- mode: Saizan set -o Saizan
20:23:30 <gubagem> @hoogle Maybe
20:23:30 <lambdabot> Data.Maybe :: module
20:23:30 <lambdabot> Prelude.Maybe :: data Maybe a
20:23:30 <lambdabot> Data.Maybe.Maybe :: data Maybe a
20:24:42 <hpaste>  gubagem pasted "Maybe lookAtThis" at http://hpaste.org/8001
20:25:56 <Saizan> gubagem: you need commas between fields
20:26:17 <paczesiowa> have anyone noticed that ghc's --make (or -package) usage involves running ld with too many parameters which results in extra memory usage? e.g. ghc --make Setup.hs (mtl package) takes 180mb of ram (if I understand memusage output), but manual compilation (with extra object files of cabal,containers and pretty) only uses 80mb.
20:26:58 <chessguy> @type >>=
20:27:00 <lambdabot> parse error on input `>>='
20:27:06 <chessguy> @type (>>=)
20:27:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:28:06 <chessguy> wonder why that abstraction nis so powerful
20:29:12 <Saizan> paczesiowa: i noticed that the linker was using a large amount of memory, but never seen why
20:30:02 <Saizan> paczesiowa: by object files of cabal,containers and pretty you mean the *.a files?
20:30:38 <paczesiowa> Saizan: my command: ghc Setup.hs -o Setup /usr/lib/ghc-6.8.2/lib/Cabal-1.2.3.0/HSCabal-1.2.3.0.o /usr/lib/ghc-6.8.2/lib/containers-0.1.0.1/HScontainers-0.1.0.1.o /usr/lib/ghc-6.8.2/lib/pretty-1.0.0.0/HSpretty-1.0.0.0.o
20:30:41 <chessguy> oh well, time for bed
20:33:19 <hpaste>  gubagem pasted "how is my indentation wrong, or is there anyway for me to continue lines when i run around of screen" at http://hpaste.org/8002
20:33:50 <TomMD> grrrr, darcs cabal-install requires an older version of Cabal than what is in the darcs repo.
20:34:15 <NReed> gubagem you can use the { and } braces
20:34:20 <paczesiowa> I have an old laptop where it takes over 40 minutes to link Setup.hs (and 2 minutes for the rest of install), so I'd like to minimize linker's memory usage
20:34:34 <bos> alas, i cannot find any interesting uses of Control.Parallel.Strategies in the wild.
20:35:04 <gubagem> NReed: just block off the code with the {}'s ?!
20:35:35 <bos> as far as i can tell, the only thing people do with parallel strategies is evaluate fib in parallel.
20:36:33 <NReed> if I remember correctly you can surround code with {}'s and the do a C-style formating with semicolons.
20:36:57 <Saizan> TomMD: seen the "stable" branch? http://darcs.haskell.org/cabal-branches/cabal-1.4/
20:36:59 <lambdabot> Title: Index of /cabal-branches/cabal-1.4
20:38:06 <hpaste>  gubagem pasted "NReed: why how do i use braces correctly?" at http://hpaste.org/8003
20:39:29 <TomMD> Saizan: Bah, stable is boring.
20:43:30 <NReed> gubagem i honestly cant remember how to do it
20:43:37 <NReed> since im just getting back into haskell from a long break
20:44:04 <gubagem> im just getting into haskell from scheme and a semester of java
20:44:21 <gubagem> java kind of grossed me out but I obtained a 102 out of 100 course points
20:44:39 <Saizan> gubagem: you need to put pares around the arguments
20:44:51 <gubagem> i have just done that actually, thanks for the tip
20:45:17 <lament> java is supposed to be easy, that's its main selling point :)
20:45:33 <SamB> heh
20:46:24 <hpaste>  (anonymous) annotated "NReed: why how do i use braces correctly?" with "e.g. like this" at http://hpaste.org/8003#a1
20:47:23 <NReed> hehe i find java confusing
20:47:32 <NReed> but thats because I come from the pitiful world of C
20:47:56 <TomMD> I just find it ugly.  "public static void main ..."
20:48:07 <TomMD> I much perfer "main ="
20:48:33 <dobblego> NReed, the most effective Java user in the world finds Java confusing
20:48:37 <lament> TomMD: that, unfortunately, doesn't tell you that the function is public, static and returns no value.
20:49:06 <lament> TomMD: do you write haskell without type signatures?
20:49:23 <TomMD> main functions?  Quite frequently.
20:49:39 <lament> see
20:49:53 <lament> whereas people who use java don't write main functions frequently
20:50:06 <lament> because they have some huge project to work on, and it only has one main function
20:50:21 <Saizan> still, when you put signatures in haskell for documentation you can just get them from ghci
20:51:20 <SamB> TomMD: JHC will not like you
20:51:25 <NReed> lament most programs only have one main ;)
20:51:27 * gwern finishes reading the HCAR. what a lot of new projects I had never heard of
20:51:37 <lament> NReed: yes, but TomMD said he writes main functions frequently :)
20:52:12 <NReed> he must write programs likes me :P (you delete them right before you finish the last 10%)
20:52:35 <TomMD> ﻿JHC won't like me?  While I am curious why I must say I don't really care much until it is of use to me.
20:52:50 <SamB> TomMD: well, the typechecker is a bit broken
20:53:04 <SamB> it really won't work unless you give main a type signature
20:53:04 <TomMD> Has anyone told John?
20:53:13 <SamB> I'm pretty sure he knows that
20:53:15 <TomMD> main :: IO () -- done!
20:53:34 <TomMD> SamB: Yeah, that was sacrasm ;-)
20:53:52 <SamB> there are MUCH WORSE things about the typechecker
20:53:59 <SamB> or at least types
20:54:25 <TomMD> Such as the lack of support for Type families and Existentials?
20:54:27 <SamB> JHC can easily be made to generate ill-typed method calls!
20:54:33 <SamB> (in E)
20:54:37 <TomMD> Owch!
20:55:55 <hpaste>  gubagem pasted "why doesnt it like my else :-(" at http://hpaste.org/8004
20:59:01 <Saizan> gubagem: mismatching parentheses in the "then"
21:01:34 <nolrai_> > signum (-5)
21:01:44 <nolrai_> @bot
21:01:44 <lambdabot> :)
21:01:49 <lambdabot>  thread killed
21:02:04 <nolrai_> > 1 + 1
21:02:07 <lambdabot>  2
21:02:16 <nolrai_> @undefine
21:02:19 <lambdabot> Undefined.
21:02:30 <nolrai_> :t signum
21:02:33 <lambdabot> forall a. (Num a) => a -> a
21:02:43 <nolrai_> > signum 5
21:02:45 <lambdabot>  1
21:02:57 <nolrai_> > signum (-5)
21:02:59 <lambdabot>  -1
21:03:22 <gubagem> Saizan: I fixed the parantheses and it still whining (as am eye)
21:03:32 <gubagem> s/it/its
21:04:10 <mbz> s/its/it's/
21:04:12 <mbz> :p
21:04:30 <gubagem> for it is?
21:04:33 <dobblego> s/parantheses/parentheses
21:04:47 <dobblego> it is contracts to it's
21:04:55 <mbz> :)
21:04:56 <gubagem> oh ok
21:08:10 <Saizan> gubagem: if that's the whole function you also miss an "in .." part
21:11:29 <gubagem> is it Just a to return a Maybe?
21:11:36 <gubagem> @hoogle Just
21:11:36 <lambdabot> Prelude.Just :: a -> Maybe a
21:11:36 <lambdabot> Data.Maybe.Just :: a -> Maybe a
21:11:36 <lambdabot> Data.Maybe.isJust :: Maybe a -> Bool
21:12:35 <gubagem> hooray it finally compiles
21:14:08 <roconnor> @src return Maybe
21:14:08 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:14:13 <roconnor> @src Maybe return
21:14:14 <lambdabot> return              = Just
21:14:38 <roconnor> @src Maybe mzero
21:14:38 <lambdabot> mzero = Nothing
21:18:49 <Saizan> :t foldr (either (first . (:)) (second . (:))) ([],[]) -- nice
21:18:51 <lambdabot> forall a b. [Either a b] -> ([a], [b])
21:19:51 <Saizan> i wonder if GHC can deforest this: foldr (either (first . (:)) (second . (:))) ([],[]) . map (\t -> maybe (Left t) Right . hasRule g $ t)
21:22:33 <gubagem> > Just 5
21:22:34 <nolrai_> > [10 .. 2]
21:22:35 <lambdabot>  Just 5
21:22:36 <lambdabot>  []
21:23:34 <gubagem> how do i unwrap something from a maybe and if i already am sure its not a Nothing
21:23:53 <dobblego> ?type fromMaybe
21:23:55 <lambdabot> forall a. a -> Maybe a -> a
21:23:58 <dobblego> ?type fromJust
21:24:00 <lambdabot> forall a. Maybe a -> a
21:25:16 <gubagem> @hoogle fromJust
21:25:17 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
21:27:10 <ddarius> Saizan: GHC should fuse any foldr/map composition.
21:28:06 <ddarius> Of course, you don't have to take my word for it.  You can just have the compiler tell you which and how many RULEs fired.
21:29:10 <Saizan> and avoid to build the Either at all? i guess i can see this from core
21:32:40 <gubagem> night
21:46:36 <bos> @seen igloo
21:46:37 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
21:49:50 <Saizan> someone should reset the seen database..
21:49:52 <dons> ah lambdabot.
21:49:59 <dons> Cale, can you clear the @seen file?
21:53:42 * bos fiddles with trying to find a non-trivial use of parallel strategies
21:55:47 <dons> mm. that's a good problem.
21:55:55 <dons> though we know satnam managed it
21:55:58 <TomMD> bos: The first thought that comes to my mind would be evolutionary algorithms
21:56:05 <dons> with `par` runtime feedback
21:56:25 * dons suspects we need parallel profiling tools , as we used to need strictness tools
21:56:50 <jkff> Hi people. I've got a question about monads, specifically: There exist functions polymorphic across all monads, like liftM, sequence, mapM etc. All of these functions I've seen possess 2 properties: 1) They are very generic (absolutely not domain-specific) and are either control structures or traversal functions, and 2) In the vast majority of cases they are used with 'effectful' monads, like IO or State or the alike. So, th
21:56:56 <dons> -fpar -- infer the expensive thunks, put `par` on them
21:57:19 <bos> dons: that's a bit like the stuff satnam and tim published last year
21:57:28 <dons> yeah, exactly like it :)
21:57:43 <bos> TomMD: what do you have in mind?
21:58:52 <Saizan> jkff: the message got cut after "alike."
21:58:59 <TomMD> bos: Knee jerk comment so the details are fuzzy.  Something like using par when benchmarking your current population.  You might also beable to use par when generating your new generation... not sure if that would work as well.
21:59:03 <jkff> Thanks. So, the question is: What other use is there for monad-polymorphic functions? Maybe can someone point me to an example of code that uses them non-trivially?
21:59:25 <dons> jkff: the list monad perhaps?
21:59:33 <dons> its used for lots of interesting 'backtracking' like search problems
21:59:40 <dons> ie.. sequence, liftM , repeatM, replicateM
21:59:49 <dons> not traditional control structures
21:59:58 <jkff> Well, I've seen the filterM [const True,const False] stuff, what else?
22:00:28 <jkff> I've been thinking about List, but didn't come up with anything
22:00:31 <dons> find a use of ContT or ListT etc, and you'll find some monad combinators.
22:00:35 <dons> LogicT is another
22:00:46 <dons> but of course, IO is the most common, so you see lots of stuff in IO.
22:01:53 <bos> it doesn't help that the threaded runtime and profiling don't mix :-(
22:02:03 <jkff> Yes, I thought about ContT too but Cont is a bit too complex for me yet, so I feared to invent anything with it :) However it looks it could give really interesting control structures when used even for traversal.
22:02:30 <Saizan> jkff: however code that works on _any_ monad will probably always look as a control structure, but that's fine since what the Monad class gives us is a standard way of composing combinators of a "library"
22:03:11 <jkff> I've codesearch.google'd for 'Monad m =>' and found lots of code like processFormals :: Monad m => [[Exp]] -> m (Maybe Exp, [Exp])  (this one from Pugs)
22:03:13 <dons> bos, yeah, big open problem: "backporting" the single core ghc runtime onto glasgow parallel haskell
22:03:35 <jkff> Doesn't look like a control structure, but I don't understand why does this piece have to be monad-polymorphic. The whole code here http://www.google.com/codesearch?hl=en&q=+pugs+%22Monad+m%22+show:7h45yujOkbI:Li4KVJyH_mc:3XH04pkCeEE&sa=N&cd=1&ct=rc&cs_p=http://www.jnthn.net/perl6/pugs-win32.zip&cs_f=lib/CORE/pugs/Pugs/Parser.hs#l1369
22:03:37 <lambdabot> Title: lib/CORE/pugs/Pugs/Parser.hs - Google Code Search, http://tinyurl.com/6feclw
22:03:55 <dons> jkff: yeah, typically those things are polymorphic over  things like  IO, StateT .. IO, and higher stacks
22:04:05 <bd_> jkff: fail requires some kind of monad
22:04:05 <dons> MonadIO is also used for that kind of thing
22:04:09 <bd_> but it doesn't really care what
22:04:19 <bd_> so it's just been set to be as polymorphic as it can get
22:04:24 <jkff> Yep, fail is yet another case, like 'lookup' in Data.Map
22:05:58 <jkff> But if it doesn't care, why should it be inside a monad at all?
22:06:10 <bd_> jkff: because fail doesn't exist outside of a monad
22:06:18 <bd_> there's error, but you can't catch that
22:06:36 <bd_> likely whatever monad(s) pugs does use with that function have custom fails that give debugging information
22:07:11 <jkff> Oh, that makes sense now! Thanks, I didn't think about that
22:08:31 <jkff> Ok, thanks to all who helped, leaving for my exams :)
22:11:21 <augur> haskellers should appreciate this:
22:11:22 <augur> http://foldr.com/
22:11:22 <lambdabot> Title: 9 foldr.com 20
22:16:42 <dons> i think a haskeller must have set it up.
22:16:54 <dons> ah no.
22:16:59 <dons>  Technical
22:16:59 <dons>    Oliver Steele
22:17:24 <SamB> who is that?
22:17:56 <dons> google will tell you :) use the force!
22:18:10 <joed> Openlazlo guy.
22:18:31 <joed> Major python person, did some amazing work in it.
22:18:45 <augur> hes a bit of a fan of haskell tho i think
22:19:05 <joed> He's also a very openminded and nice person to discuss features with.
22:19:11 <dons> he's written about haskell on his blog
22:19:16 <dons> e.g. http://osteele.com/archives/2007/12/overloading-semicolon
22:19:18 <lambdabot> Title: Overloading Semicolon, or, monads from 10,000 Feet | Oliver Steele
22:19:25 <augur> well
22:19:25 <SamB> certainly looks like he's familiar with FP ;-)
22:19:30 <augur> thats "monads" in JS.
22:19:33 <augur> but close enough :p
22:19:43 <joed> He did most of the interesting JS script stuff for Laszlo.
22:20:01 <dons> oh hmm, did he use that before i did? ah no. I wrote about the overloaded semicolon in 2007/03
22:20:08 <dons> i wonder if he got the idea from my blog. hmm
22:20:15 <joed> Let us hope?
22:20:26 <joed> He is a sharp guy nontheless
22:20:54 <augur> dons: link?
22:21:04 <joed> Most of what I get paid for now would not be implementable were it not for him
22:21:11 <augur> i dont see how you can overload the semicolon in JS
22:21:15 <augur> i never got what he was saying
22:21:28 <dons> he was talking about overloading the semicolon in languages that support monadic syntax
22:21:44 <dons> a la http://cgi.cse.unsw.edu.au/~dons/blog/2007/03/10#programmable-semicolons
22:21:45 <lambdabot> Title: Haskell hacking, http://tinyurl.com/ywdjsr
22:21:49 <dons> and then , http://osteele.com/archives/2007/12/overloading-semicolon
22:21:50 <lambdabot> Title: Overloading Semicolon, or, monads from 10,000 Feet | Oliver Steele
22:22:01 <joed> He made a really decent proposal for XML namespace adoptation.
22:22:16 <dons> hehe. got the top hit for "programmable semicolon"
22:22:24 <joed> Combined with relax-ng notation
22:23:00 <joed> Which would help large UI efforts in anything laszlo like....
22:23:29 <augur> relax-ng?
22:23:48 <joed> Yes, different way of expressing xml
22:23:58 <augur> oh.
22:24:06 <joed> Much more succint
22:24:12 <joed> <sp>
22:25:32 <joed> augur: it helps where you need to redfine the schema as you go along.
22:25:41 <augur> ok
22:26:04 <joed> So you programatically can have a base of a language in xml, then extend it.
22:26:16 <joed> Which is a sick notion, but works.
22:26:27 <joed> It is essentially what laszlo is.
22:27:03 <ikeda> sup lambda people
22:28:14 <SamB> sugar lambdas for all!
22:28:21 * SamB tosses lambdas
22:28:25 <bos> oh, YUCK.  the instance of NFData for Data.Map.Map is useless.
22:28:33 <SamB> *lambdas go fwip-fwip-fwip
22:37:27 <SamB> hey, check this out: http://feeds.feedburner.com/~r/osteele/~3/286971821/my-no-tv
22:37:27 <lambdabot> Title: My No TV | Oliver Steele
22:41:59 <ddarius> > span isAlpha "aouc3sa"
22:42:01 <lambdabot>  ("aouc","3sa")
22:43:46 <ddarius> SamB: Getting time back by not watching TV doesn't take a rocket scientist to figure out.  What most people don't realize, I suppose, is how much more they'd be doing.
22:43:47 <Saizan> i wonder if they have a No Internet too, that can save a lot of time too
22:44:52 <ddarius> > first read . span isDigit $ "34foo" :: (Int,String)
22:44:53 <lambdabot>  (34,"foo")
22:45:08 * joed threw the TV out ages ago...
22:45:19 <SamB> I just think it's funny
22:45:29 <SamB> the way he puts it
22:45:30 <joed> And it is damned good for the kids.
22:45:32 <SamB> you know ;-)?
22:46:10 <SamB> I mean, I spend way to much time on the internet to even have time to watch a no tv!
22:46:25 <joed> Yeah, I read it, I have a few large TV's in the house, I just avoid turning em on and I indroctinate my daughter to think that TV time is time lost.
22:46:53 <joed> We do Bookstore or library outings.
22:47:25 <joed> She is 6 and reads, so she gets to pick a topic, we find a book, read that book.
22:47:27 <gwern> remember, TV is the reason we do not have more Wikipedias! (pace Shirky)
22:47:39 <joed> Awesome way of killing time.
22:48:27 <bos> boy, parallel haskell completely sucks.
22:49:15 <bos> i get 50% variations in runtime from one run to another, on an idle box.
22:49:27 <dolio> Hasn't had much work done on it in a while, I imagine.
22:49:28 <TomMD> Task parallel carries the day, thats for sure.
22:49:31 <ddarius> joed: Why don't you sell the TVs (maybe keep one?)
22:49:56 <bos> sorry, apparently i meant nearly 100% variation.  run 1: 7.5 seconds. run 2: 13.5 seconds.
22:50:00 * bos weeps.
22:50:14 <ddarius> The joy of non-determinism
22:50:31 * gwern envisions joed and daughter, cuddled up in a big chair, reading Little House in the Big Woods together. awww
22:50:41 <joed> ddarius: Little value, and I'd admit to every now and then watching history channel... I work too much, I can keep those as endulgence.
22:52:11 <TomMD> On the topic of non-determinism:  prop_eq = let struct = c_complexStructInit ; struct2 = c_complexStructInit in struct == struct2  -- Fails every time, ohhh, when I find the programmer...
22:52:39 <joed> gwern: Pretty much it, June Be Jones though, awesome books for early readers.
22:52:42 <ddarius> :t lookup
22:52:44 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
22:53:56 <gwern> bos: do not think of it as 100% from A -> B; think of it as 50% as B -> A!
22:53:56 <gwern> it gets faster!
22:54:08 <joed> Hah
22:54:38 * gwern suddenly remembers I was going to burn a dvd of knoppix tonight. better go do that
22:57:17 <ddarius> Writing lexers is so relaxing.
22:57:30 <bos> ah, it's the damn garbage collector that's killing me.
22:57:50 <bos> my code allocates like mad, so the stop-the-world GC essentially single-threads it.
22:58:34 <dolio> Well, that just goes to show how we need to adopt the .Net runtime.
23:00:40 <joed> heh
23:11:33 <rhar> what does the :& operator do?
23:12:05 <rhar> ex: sat (a :& b) = b
23:12:12 <Saizan> operators that start with ":" are infix constructors
23:12:40 <rhar> ah, thanks!
23:30:56 <rhar> ok, stupid follow-up question: if && and "and" are boolean operators and .&. is the bitwise operator what is just a single & and what does it mean in the context of the following
23:30:59 <rhar> ex: sat (a :& b) = b
23:31:19 <bd_> that's a :& operator
23:31:23 <bd_> @hoogle (:&)
23:31:24 <lambdabot> Prelude.undefined :: a
23:31:24 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
23:31:24 <lambdabot> Control.Monad.Reader.Class.ask :: MonadReader r m => m r
23:31:30 <bd_> hoogle fails
23:31:32 <bd_> :t (:&)
23:31:33 <lambdabot> Not in scope: data constructor `:&'
23:31:42 <bd_> okay, it's a data constructor, at that :)
23:32:02 <bd_> I don't know what it is though - probably not in the haskell core
23:32:36 <rhar> ok, so i need to track down the & operator for some inferred type in this library I'm looking at
23:33:15 <Saizan> rhar: ":&" is a single token
23:33:36 <Saizan> rhar: and it's defined as part of a data declaration somewhere.
23:34:27 <rhar> ok, i just need to figure out what declaration i should be looking at in this computational geometry library to figure out what that statement is doing
23:34:29 <Saizan> rhar: if you can load the module it's used in in ghci you can use :info (:&) to find out where it comes from
23:34:47 <rhar> ooh good idea
23:35:33 <Saizan> if that fails use grep :)
23:35:52 <ddarius> @hoogle isWhite
23:35:52 <lambdabot> No matches found
23:57:29 <newsham> is there a boyer moore for data.sequence?
