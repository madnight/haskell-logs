00:00:25 <vixey> @docs Haskell
00:00:25 <lambdabot> Haskell not available
00:00:29 <vixey> :(
00:01:35 <stepcut> well, all the monads in the world can't save me now, I off to bed.
00:01:47 <Apocalisp> sleep monad
00:01:52 <vixey> hahaha
00:02:04 <vixey> hm
00:02:09 <vixey> Language.Haskell.Parser
00:02:09 <vixey> *Main> parseModule "data Foo"
00:02:09 <vixey> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 9}) "Parse error"
00:02:10 <vixey> :(
00:02:39 <vixey> oh it does actually work, seems like I just have to put nonempty definitions
00:02:45 <Apocalisp> where some magic happens. Tired idiot goes in, refreshed hero comes out.
00:13:38 <vixey> @src []
00:13:38 <lambdabot> data [] a = [] | a : [a]
00:14:00 <vixey> hmf
00:58:42 <nolrai_> @pl g (a, b) f = (f a, f b)
00:58:43 <lambdabot> g = uncurry ((. flip id) . ap . ((,) .) . flip id)
00:59:08 <dmwit> f *** f
00:59:15 <nolrai_> thanks
00:59:21 <Deewiant> flip $ join (***)
00:59:28 <dmwit> If f is monomorphic, you can also use (join (***)).
01:01:22 <nolrai_> Come to think of it what i really want is: g (a, b) (fa, fb) = (fa a, fb b). Is that something simple?
01:01:38 <dmwit> (>>>)
01:01:45 <nolrai_> cool
01:01:49 <dmwit> Hmm, kind of.
01:01:51 <dmwit> Let's see.
01:02:05 <dmwit> No, it's more like
01:02:07 <dmwit> uncurry (***)
01:02:13 <dmwit> :t uncurry (***)
01:02:15 <lambdabot> Not in scope: `***'
01:02:18 <dmwit> ?
01:02:26 <dmwit> :t uncurry (Control.Arrow.***)
01:02:27 <Deewiant> @ty uncurry (Control.Arrow.***)
01:02:30 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Control.Arrow.Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
01:02:30 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Control.Arrow.Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
01:02:50 <dmwit> So, in the (->) Arrow, it's
01:03:05 <dmwit> (b -> c, b' -> c') -> (b, b') -> (c, c')
01:04:09 <nolrai_> :t Control.Arrow.***
01:04:11 <lambdabot> parse error on input `Control.Arrow.***'
01:04:19 <dmwit> :t (Control.Arrow.***)
01:04:19 <nolrai_> :t (Control.Arrow.***)
01:04:22 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Control.Arrow.Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
01:04:22 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Control.Arrow.Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
01:04:31 <vixey> @src foldr
01:04:32 <lambdabot> foldr f z []     = z
01:04:32 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:04:34 <vixey> @src maybe
01:04:34 <lambdabot> maybe n _ Nothing  = n
01:04:34 <lambdabot> maybe _ f (Just x) = f x
01:04:36 <vixey> @src either
01:04:37 <lambdabot> either f _ (Left x)     =  f x
01:04:37 <lambdabot> either _ g (Right y)    =  g y
01:05:04 <koninkje> (catamorphisms)++
01:05:28 <dmwit> ?karma (catamorphisms)
01:05:28 <lambdabot> (catamorphisms) has a karma of 1
01:05:30 <koninkje> (or homomorphisms)
01:05:32 <dmwit> weird
01:05:36 <dmwit> ?karma catamorphisms
01:05:36 <lambdabot> catamorphisms has a karma of 1
01:05:36 <vixey> where are the homomorphisms
01:05:46 <vixey> is that just when result = input
01:06:28 <koninkje> technically "cata" is collapsing the object down into some summary value, "homo" is just mapping it to another object ala functors
01:06:40 <vixey> oh ok
01:07:01 <koninkje> so "foldr (+) 0" is a catamorphism, but "foldr (:) []" is a homomorphism
01:07:12 <koninkje> (...if I have my jargon right...)
01:07:35 <dmwit> Oh, I thought "foldr" was the catamorphism.
01:09:43 <koninkje> it can be both, there's some overlap
01:09:51 * koninkje looking for that nice page I found
01:10:01 <nolrai_> :t (Control.Arrow.>>>)
01:10:03 <lambdabot> forall (a :: * -> * -> *) b c d. (Control.Arrow.Arrow a) => a b c -> a c d -> a b d
01:10:09 <lispy> :t foldr (:) []
01:10:11 <lambdabot> forall a. [a] -> [a]
01:10:17 <lispy> :t foldr (:) [] [1..3]
01:10:18 <lambdabot> forall a. (Enum a, Num a) => [a]
01:10:21 <nomeata> Hi. Is Axel Simon of gtk2hs around here?
01:10:26 <lispy> > foldr (:) [] [1..3]
01:10:28 <lambdabot>  [1,2,3]
01:10:29 <koninkje> foldr (:) [] == id
01:10:34 <lispy> koninkje: that's what I was thinking
01:10:54 <dmwit> nolrai_: It was a dumb comment by me; (>>>) is just a re-ordered, generalized (.).
01:11:00 <lispy> > foldr (flip (:)) [] [1..3]
01:11:01 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]
01:11:01 <lambdabot>       Expected...
01:11:17 <lispy> > foldl (flip (:)) [] [1..3]
01:11:17 <dmwit> > foldl (flip (:)) [] [1..3]
01:11:18 <lambdabot>  [3,2,1]
01:11:19 <lambdabot>  [3,2,1]
01:11:26 <dmwit> jinx!
01:11:35 <lispy> I never really thought about it that foldr (flip (:)) is not typed correctly
01:11:40 <nolrai_> > (Control.Arrow.***) (+1) (+2) (1,2)
01:11:41 <lambdabot>  (2,4)
01:12:07 <dmwit> > ((+1) *** (+2)) (1, 2)
01:12:08 <lambdabot>  (2,4)
01:12:09 <Deewiant> > (+1) *** (+2) $ (1,2)
01:12:10 <lambdabot>  (2,4)
01:13:07 <koninkje> heh, wikipedia of all places: http://en.wikipedia.org/wiki/Homomorphism
01:13:09 <nolrai_> Ok that IS what i wanted. The types looked wierd to me.
01:14:28 <koninkje> basically, since data constructures in some sense "don't evaluate" (i.e. they don't reduce to anything other than themselves) using data constructors as your functions in a fold makes it a homomorphism (assuming you don't map two old constructors to the same new constructor)
01:19:58 <nolrai_> whats the work around for (-1) being negative one as opposed to the section?
01:20:06 <dmwit> subtract, negate
01:20:39 <nolrai_> thanks
01:25:06 <vixey> what's the way to turn (3,'x') "abcde" into "abcxe" ?
01:25:34 <dmwit> :t splitAt
01:25:36 <lambdabot> forall a. Int -> [a] -> ([a], [a])
01:25:43 <dmwit> (You have to write your own list update function.)
01:25:56 <dmwit> There's a nicer way for Array, but not for lists.
01:26:34 <vixey> @pl \(i,e) a->uncurry(\x (_:y)->x++e:y)(splitAt i a)
01:26:35 <lambdabot> uncurry (flip ((.) . uncurry . flip flip tail . (ap .) . flip flip head . (((.) . const) .) . flip ((.) . (++)) . (:)) . splitAt)
01:26:52 <vixey> :(
01:28:06 <Deewiant> @pl \(i, e) a -> uncurry (f e) (splitAt i a)
01:28:06 <lambdabot> uncurry (flip ((.) . uncurry . f) . splitAt)
01:28:31 <koninkje> @pl \(i,e) -> (\(x,(_:y)) -> x++e:y) . splitAt i
01:28:33 <lambdabot> uncurry (flip ((.) . (`ap` snd) . (. fst) . flip flip tail . (ap .) . flip flip head . (((.) . const) .) . flip ((.) . (++)) . (:)) . splitAt)
01:30:02 <koninkje> I have an aesthetic question for folks...
01:30:57 <koninkje> given a function like zip but which returns Just [(a,b)] if the lists are the same length and Nothing otherwise... what's a good name for that?
01:31:19 <koninkje> I'm coming to mislike `evenZip`
01:31:19 <vixey> pair
01:31:56 <Valodim_> maybeZip?
01:32:09 <dmwit> safeZip
01:32:45 <dmwit> oh!
01:33:04 <dmwit> How about something like "function", that refers to the fact that there's exactly one output for each input?
01:33:24 <Deewiant> zipFunction? :-P
01:33:38 <koninkje> map?
01:33:44 <dmwit> Well, "relation" is closer, I guess.
01:33:50 <dmwit> koninkje: heh
01:34:01 <dmwit> hm
01:34:25 <dmwit> zipListsThatAreTheSameLength
01:34:50 <dmwit> putInAOneToOneRelation
01:34:57 <dmwit> How about "relate"?
01:35:26 <nolrai_> zipOrBust
01:35:30 <dmwit> Or maybe "biject".
01:35:34 <koninkje> but relations don't have to be bijections...
01:35:42 <dmwit> Although biject is way to specific.
01:35:43 <dmwit> Yeah.
01:36:03 <dmwit> Well, it's really a bijection on the indices.
01:37:35 <koninkje> true. I'm liking `pair` though. `biject` strikes me as it should take functions for arguments
01:37:47 <dmwit> Yeah, biject connotes too many wrong things.
01:37:55 <dmwit> I would also go with pair, probably.
01:38:08 <koninkje> vixey++ :)
01:39:04 <nolrai_> I stll like "zipListsThatAreTheSameLength" i mean what were all those typeing lessens for :P
01:39:46 <koninkje> heh heh, but it's such a primitive operation, it should be short enough to almost interfere with variable names ;)
01:40:40 <vixey> would the type of the catamorphism for data Tree a = Leaf | Branch (Tree a) a (Tree a)
01:40:41 <vixey> be
01:40:47 <vixey> z -> ((z -> z) -> a -> (z -> z)) -> Tree a -> z
01:40:48 <vixey> or
01:40:49 <vixey> z -> ((z -> a -> (z -> z)) -> (Tree a) -> z)
01:40:49 <vixey> ?
01:41:22 <vixey> It's the second one isn't it ? I' pretty sure
01:42:53 <solrize> http://alessio.guglielmi.name/res/cos/index.html this looks neat, a proof system based on deep pattern matching
01:42:54 <lambdabot> Title: Deep Inference and the Calculus of Structures
01:42:56 <dmwit> The second, although your parentheses are weird.
01:43:00 <koninkje> :: b -> (b -> a -> b -> b) -> Tree a -> b
01:44:54 <koninkje>  :t Branch == Tree a -> a -> Tree a -> Tree a; hence the second arg after we've finished the fmap
01:47:23 <nolrai_> Dose catamophism make sense on for data LTree a = Leaf a | Branch (Tree a) (Tree a)?
01:47:48 <koninkje> catamorphism makes sense on any ADT :)
01:47:56 <vixey> yeah it should be (a -> z) -> (z -> z -> z) -> LTree a -> z  I think
01:48:14 <koninkje> indeed
01:48:26 <vixey> this is so cool
01:48:28 <nolrai_> Oh that makes sense. hmm
01:51:01 <vixey> :(
01:51:13 <vixey> ghci should be able to print unicode to my terminal, shouldn't it?
01:52:06 <nolrai_> so would the catamorphism for pair be the obvious instance of (a -> x) -> (b -> y) -> (x -> y -> z) -> (a, b) -> z?
01:52:13 <vixey> @src (,)
01:52:13 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
01:52:15 <vixey> @src (a,b)
01:52:15 <lambdabot> Source not found. stty: unknown mode: doofus
01:52:18 <vixey> :/
01:52:29 <vixey> data (a,b) = (a,b)
01:52:59 <nolrai_> ??
01:53:11 <vixey> cataPair :: ((a,b) -> z) -> (a,b) -> z isn't it ?
01:53:38 <vixey> ohh no
01:53:45 <vixey> cataPair :: (a -> b -> z) -> (a,b) -> z
01:53:47 <Deewiant> cataPair = id
01:53:47 <koninkje> :: (a -> b -> z) -> (a,b) -> z
01:53:49 <Deewiant> ;-)
01:54:05 <Deewiant> @djinn (a -> b -> z) -> (a,b) -> z
01:54:06 <lambdabot> f a (b, c) = a b c
01:55:12 <nolrai_> :t curry
01:55:14 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
01:55:25 <Deewiant> :t uncurry
01:55:27 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
01:55:45 <solrize> wow, mathematical theory of bureaucracy
01:56:22 <solrize> Building on ideas by Guglielmi, we identify two forms of bureaucracy that occur in the calculus of structures (and, in fact, in every non-trivial term rewriting derivation). We develop term calculi that provide derivations that do not contain this bureaucracy. We also give a normalisation procedure that removes bureaucracy from derivations and find that in a certain sense the normalisation process is a process of cut elimination.
01:57:17 <koninkje> sounds entertaining
01:57:58 <solrize> http://www.iam.unibe.ch/~kai/Papers/sd05.pdf
01:59:19 <vixey> @src foldr
01:59:20 <lambdabot> foldr f z []     = z
01:59:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:02:09 * osfameron reads through his old blogs and remembers he's really missing haskell :-(
02:05:21 <vixey> :D
02:05:24 <vixey> I wrote a fun thing
02:06:52 <vixey> ?but
02:06:53 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
02:07:28 <vixey> chekc it out http://hpaste.org/7682
02:09:59 <vixey> (It generates the catamorphism for a datatye you give it)
02:10:06 <vixey> the code and type are printed .. it all typechecks too
02:10:48 <koninkje> re `modifyIndex` cf http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Sequence.html#v%3Aadjust
02:10:50 <lambdabot> http://tinyurl.com/2pqluj
02:12:21 <vixey> any comments ?
02:14:26 <mbz> i'm too dumb to provide any usefull comments =)
02:14:52 <mbz> i'm playing with haskell for three days
02:17:04 <vixey> seems like I killed this channel with my horrifying code?
02:17:22 <koninkje> just taking the time to read it is all
02:17:44 <koninkje> I've seen the idea before, though long ago in a kingdom by the sea
02:17:54 <vixey> hehe
02:19:11 <koninkje> seems like there's a lot more string manipulation than there needs to be
02:19:38 <vixey> yeah It should be done more symbolic but I just kicked this out quickly
02:19:54 <vixey> (I'll rewrite it maybe .. and support GADT?)
02:20:36 <trez> @src foldM
02:20:36 <lambdabot> foldM _ a []     = return a
02:20:36 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
02:21:04 <vixey> trez: oh scary! how do you derive this one?
02:21:06 <vixey> :t foldM
02:21:08 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
02:22:11 <vixey> I guess we take fold
02:22:49 <vixey> then unnest it
02:22:57 <vixey> @src foldl
02:22:57 <lambdabot> foldl f z []     = z
02:22:57 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:23:08 <vixey> foldM looks more like a foldl than foldr though
02:25:14 <koninkje> Another aesthetic question, is there a convention for `fooWith` vs `fooBy` as generalisations for `foo`?
02:26:06 <dons> By usually indicates it is higher order. With is rare.
02:26:14 <dons> :t groupBy
02:26:16 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
02:26:17 <dons> :t group
02:26:18 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
02:26:26 <dons> :t sortBy
02:26:28 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
02:26:28 <vixey> @hoogle With
02:26:28 <dons> :t sort
02:26:29 <lambdabot> Foreign.Marshal.Utils.with :: Storable a => a -> (Ptr a -> IO b) -> IO b
02:26:29 <lambdabot> Foreign.ForeignPtr.withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
02:26:29 <lambdabot> System.IO.withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
02:26:30 <lambdabot> forall a. (Ord a) => [a] -> [a]
02:26:34 <dons> :t length
02:26:35 <lambdabot> forall a. [a] -> Int
02:26:38 <dons> :t genericLength
02:26:40 <lambdabot> forall b i. (Num i) => [b] -> i
02:27:11 <dons> so 'generic' for overloaded things. withFoo for things that take a Foo and do something to it. By for higher order things
02:27:18 <dons> we should write these down some time
02:27:39 <glguy> shouldn't you be sleeping?
02:27:59 <koninkje> I was meaning more like `zipWith` though that may be a one-off
02:28:02 <vixey> does every GADT have an associated fold?
02:28:42 <koninkje> I made a safe zip and now I'm generalizing it to take in cons and nil combinators
02:28:58 <vixey> why would it take combinators?
02:29:10 <vixey> I mean rather than just fold the result?
02:29:55 <koninkje> so you don't have to do multiple traversals of construct intermediate lists
02:30:02 <schme_> yp54444444444pppppppppppppppppppppppppdipööääääääääääääääääääääääääääääääääääääääääääääääaåjäq jjjjjje47777777777777777777777777777777777777777777777777777777777
02:30:03 <koninkje> aka inlining the fold
02:30:10 <vixey> hm :
02:30:14 <vixey> Can't a compiler do it?
02:30:14 <koninkje> s/of/or/
02:30:37 <koninkje> sometimes, but it's not too hard to generalize
02:30:45 <vixey> supero maybe does this sort of thing, right?
02:30:50 <vixey> or GHC/
02:31:04 <koninkje> and it makes code a lot more legible ifyou don't have to explicitly add folds and unfolds everywhere
02:34:18 <Foloex> Hello world !
02:37:47 <Foloex> :t readFile
02:37:49 <lambdabot> FilePath -> IO String
02:38:21 <shubuntu> http://hpaste.org/7683
02:38:30 <shubuntu> can anyone help me with that code
02:39:25 <shubuntu> the last bit I made a typo
02:39:28 <shubuntu> accumN (x,y) stone board places =
02:39:28 <shubuntu>        [(x,y-1) | y > 0, opponent stone == access board (x, y-1)] ++ places
02:41:04 <shubuntu> anyone?
02:41:30 <shubuntu> will that last bit do what I want it to?
02:41:41 <shubuntu> is there a better way to write it?
02:42:05 <koninkje> @hoogle WithBy
02:42:05 <Foloex> :t getLine
02:42:07 <lambdabot> No matches found
02:42:08 <lambdabot> IO String
02:42:50 <shubuntu> :( nobody wants to help me
02:43:12 <Baughn> shubuntu: Well, you haven't actually said what it's supposed to do
02:43:17 <pejo> vixey, supero should eliminate the intermediate lists, yeah. The short cut deforestation currently in can only fuse one of the lists iirc.
02:43:30 <shubuntu> it's in the link i posted
02:43:40 <shubuntu> I've posted a fully commented code there
02:43:50 <shubuntu> http://hpaste.org/7683
02:43:52 <Baughn> Your comments are insufficient.
02:44:02 <shubuntu> what do you need to know
02:44:12 <Baughn> Yes, I can /see/ it takes a coord, a stone, a board and returns more coords.. you don't need to put that in comments
02:44:12 <shubuntu> it needs to return a list of coordinates
02:44:22 <Baughn> What are those coordinates supposed to represent?
02:44:48 <shubuntu> the coordinates of the cell right up north of the passed coordinate place
02:45:17 <shubuntu> if that is the opponent's stone it will be flipped
02:45:47 <shubuntu> so it should check to see if the cell up north is the opponent of the stone that's going to be placed on (x, y)
02:46:08 <shubuntu> and then return that in a list
02:46:24 <shubuntu> i'll check all 8 directions the same way
02:46:54 <Foloex> > ! True == False
02:46:54 <lambdabot>   parse error on input `!'
02:47:00 <Baughn> Foloex: not
02:47:03 <Foloex> > not True == False
02:47:04 <lambdabot>  True
02:47:11 <Foloex> Baughn: thanks ;)
02:47:24 <Baughn> shubuntu: This is the first time I've seen list comprehensions used in this manner, but it looks good.. what makes you think it isn't working?
02:47:34 <schme_> G'day #haskell
02:47:57 <Baughn> shubuntu: Although, you could probably check all eight directions with a single comprehension
02:48:33 <shubuntu> i know
02:48:47 <Baughn> Foloex: Oh, and try this:
02:48:52 <shubuntu> our prof has set the code this way
02:48:53 <Baughn> @hoogle Boolean -> Boolean
02:48:53 <lambdabot> No matches, try a more general search
02:48:55 <shubuntu> i can't change it
02:48:59 <Baughn> @hoogle Bool -> Bool
02:48:59 <lambdabot> Prelude.not :: Bool -> Bool
02:49:00 <lambdabot> Data.Bool.not :: Bool -> Bool
02:49:00 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
02:49:04 <schme_> Still no news on haskell on ovms ?
02:49:06 <Baughn> ..I keep forgetting that detail
02:49:06 <shubuntu> i have to just fill the place holders
02:49:24 <Baughn> shubuntu: Well, then go ahead
02:50:42 <Baughn> shubuntu: Although I think you'd find that most teachers are most understanding when it comes to improving on their suggested solution. It might improve your grade.
02:50:54 <Baughn> (And if you don't know, ask)
02:51:47 <shubuntu> captureN (1,1) Dark [[Dark,Light,Light],[Dark,Light,Light]]
02:51:47 <shubuntu> [(1,0)]
02:51:57 <shubuntu> it seems to be working
02:52:09 <shubuntu> the prof doesn't allow it in assignments
02:52:19 <shubuntu> we can do improvements in extra work
02:52:30 <shubuntu> the base assignment has to be exactly the way he sets it
02:52:38 <Baughn> Hm. Well, you might do the single-comprehension thing on your own anyway, just so you see how it works
02:52:58 <tibbe> @msg dons FYI, ghc-core doesn't install because hscolour doesn't build
02:53:02 <lambdabot> Not enough privileges
02:53:12 <Baughn> tibbe: @tell
02:53:15 <tibbe> @tell dons FYI, ghc-core doesn't install because hscolour doesn't build
02:53:15 <lambdabot> Consider it noted.
02:54:24 <shubuntu> ok so let's say instead of captureN i define a capture
02:54:31 <shubuntu> that will check all 8
02:54:57 <Baughn> Yes..
02:56:10 <tibbe> anyone know about any papers on layering streams in haskell e.g. a stream that decodes chunk encoded HTTP 1.1 over a normal TCP stream?
02:56:16 <Foloex> I have some problem with file reading: not (hIsEOF handle) is not accepted: type IO Bool does not match Bool ...
02:56:42 <Foloex> I'm in a Do though
02:57:08 <Baughn> Foloex: YEah, type mismatch. not works on Bool; IO Bool is an action that, when executed, returns a Bool - not a Bool itself
02:57:34 <Baughn> Foloex: Quick solution, say foo <- hIsEof handle; something something (not foo)
02:57:48 <Foloex> Baughn: ok
02:57:54 <Baughn> Foloex: Better solution, say liftM not (hIsEOF handle)
02:57:55 <schme_> by god you people are just no help :)
02:57:57 <shubuntu> capture (x, y) stone board = [(i, j) | i >=0, j >=0, opponent stone == access  board (i , j) ]
02:58:01 <shubuntu> that needs a bit
02:58:15 <Baughn> Foloex: (That bit's in Control.Monad)
02:58:22 <shubuntu> i need to map something
02:58:38 <Baughn> Foloex: If you want to chain them, don't say liftM foo $ liftM bar $ action - say liftM (foo . bar) $ action. ;)
02:59:29 <Baughn> shubuntu: It /is/ homework, so there's not very much we can say. If you have a specific problem we could give hints, but not really this..
02:59:34 <Foloex> Baughn: what's the liftM ?
02:59:41 <shubuntu> directions = [(0,-1),(-1,0),(0,1),(1,0),(-1,-1),(-1,1),(1,1),(1,-1)]
02:59:48 <Foloex> :t liftM
02:59:49 <shubuntu> i need syntax help
02:59:50 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
02:59:55 <shubuntu> i know how to write it the long way
02:59:58 <shubuntu> i've already done that
03:00:02 <shubuntu> i'm just optimizing
03:00:27 <shubuntu> first of all how to define that list using a loop thingie?
03:01:11 <dieJana> is there a way to get haskell for suse through yast?
03:01:13 <Baughn> Foloex: perhaps this is simpler..
03:01:15 <koninkje> @hoogle a -> Bool -> Maybe a
03:01:16 <Baughn> @src liftM
03:01:16 <lambdabot> No matches, try a more general search
03:01:16 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
03:01:29 <koninkje> @hoogle Bool -> a -> Maybe a
03:01:30 <lambdabot> No matches, try a more general search
03:01:33 <Baughn> @djinn a -> Bool -> Maybe a
03:01:34 <lambdabot> f a b =
03:01:34 <lambdabot>     case b of
03:01:34 <lambdabot>     False -> Nothing
03:01:34 <lambdabot>     True -> Just a
03:01:52 <koninkje> it's trivial, i was just seeing if it had a name
03:01:58 <vixey> :t let f a _ True = return a ; f _ b False = return b in f
03:01:59 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> a -> Bool -> m a
03:02:01 <shubuntu> Baughn?
03:02:20 <vixey> :t let f a _ Nothing = return a ; f _ g (Just x) = g x in f
03:02:22 <lambdabot> forall a t (m :: * -> *). (Monad m) => a -> (t -> m a) -> Maybe t -> m a
03:02:29 <Baughn> shubuntu: Hm. Try this:
03:02:37 <koninkje> :t \a b -> if b then Just a else Nothing
03:02:39 <lambdabot> forall a. a -> Bool -> Maybe a
03:02:49 <Baughn> > [(x,y) | x <- [1,2], y <- [0,3]]
03:02:52 <lambdabot>  [(1,0),(1,3),(2,0),(2,3)]
03:03:04 <shubuntu> uhh cool
03:03:20 <shubuntu> now can i map +(x,y) directions
03:03:58 <mbz> Baughn: in case [-1..1] we will got (0,0) direction
03:03:58 <shubuntu> where directions = [(i,j) | i <- [-1,1], j <- [-1,1]]
03:04:20 <Baughn> > [(-1,-1)..(1,1)]
03:04:20 <lambdabot>   add an instance declaration for (Enum (a, a1))
03:04:21 <shubuntu> will that produce a list like i want?
03:04:37 <Baughn> shubuntu: It should
03:04:39 <vixey> > [(1,1),(1,-1),(-1,1),(-1,-1)]
03:04:41 <lambdabot>  [(1,1),(1,-1),(-1,1),(-1,-1)]
03:04:54 <shubuntu> but does the + function know how to add tuples?
03:04:58 <mbz> > [(a,b) | a <- [-1..1], b <- [-1..1]]
03:04:59 <lambdabot>  [(-1,-1),(-1,0),(-1,1),(0,-1),(0,0),(0,1),(1,-1),(1,0),(1,1)]
03:05:06 <mbz> (0,0)
03:05:09 <Baughn> shubuntu: Oh, but you could fold the + into the list comprehension Just make it [(i+x,j+y)... or something
03:05:14 <Baughn> shubuntu: It does not
03:05:16 <mercury^> @djinn [Int] -> Int
03:05:17 <lambdabot> -- f cannot be realized.
03:05:19 <mercury^> :(
03:05:26 <shubuntu> ok
03:05:38 <vixey> > head [] -- mercury^
03:05:39 <lambdabot>  Exception: Prelude.head: empty list
03:06:21 <Cale> djinn doesn't know about recursive types
03:06:31 <Cale> (like lists)
03:06:33 <mercury^> vixey: I had hoped for foldl' (+) 0 or something like that
03:06:45 <mercury^> ah
03:06:47 <vixey> mercury^: djinn doesn't know about 0
03:06:50 <Cale> It also doesn't know about Int
03:06:51 <vixey> ?djinn Maybe Int -> Int
03:06:52 <lambdabot> -- f cannot be realized.
03:06:52 <mux> :t sum
03:06:54 <lambdabot> forall a. (Num a) => [a] -> a
03:07:01 <Cale> @djinn Int -> Maybe Int
03:07:02 <lambdabot> f = Just
03:07:08 <vixey> there's not -total- function [a] -> a
03:07:17 <vixey> so djinn will never make it
03:07:17 <Cale> heh, it's probably treating Int as a type variable there :)
03:07:31 <mux> sum is total
03:07:34 <mux> > sum []
03:07:35 <lambdabot>  0
03:07:36 <shubuntu> so [ (x+i, y+j) | x+i >=0, y+j >=0, (i,j) `elem` [(-1,-1)..(1,1)], opponent stone == access board (x+i, y+j)]
03:08:07 <vixey> Can I make data ... deriving (Cata named myCata) with template haskell?
03:08:18 <Baughn> shubuntu: You don't have anything in there to /produce/ i and j
03:08:49 <Baughn> shubuntu: Oh, and as I demonstrated a bit ago, [a..b] doesn't work of a/b are tuples
03:08:50 <shubuntu> well i say (i,j) are elements of that list?
03:09:05 <Baughn> > [(x,y) | x <- [1,2], y <- [0,3]] -- Experiment with this
03:09:06 <lambdabot>  [(1,0),(1,3),(2,0),(2,3)]
03:09:09 <shubuntu> ok
03:09:29 <Baughn> shubuntu: (Oh, you are using ghci, right?)
03:09:39 <shubuntu> yes
03:09:40 <Baughn> ..or some other interpreter, I mean
03:09:40 <vixey> > [(x*2-1,y*2-1) | x <- [0,1] , y <- [0,1] ]
03:09:42 <lambdabot>  [(-1,-1),(-1,1),(1,-1),(1,1)]
03:09:50 <shubuntu> ghci yeppers
03:10:54 <shubuntu> so [ (x+i, y+j) | x+i >=0, y+j >=0, i <- [-1..1], j <- [-1..1], opponent stone == access board (x+i, y+j)]
03:10:59 <shubuntu> how about this?
03:11:30 <Baughn> shubuntu: The >= 0 is to make sure you don't go off one edge of the board, right?
03:11:41 <shubuntu> yes
03:11:49 <Baughn> How about the other edge?
03:11:53 <shubuntu> that's a problem i'm facing here
03:11:59 <Baughn> Oh, and you probably don't want [-1..1]
03:12:01 <Baughn> > [-1..1]
03:12:04 <lambdabot>  [-1,0,1]
03:12:27 <shubuntu> like will it still call access if it does not satisfy that condition
03:12:39 <Baughn> There's nothing to prevent it in there
03:12:46 <shubuntu> so [ (x+i, y+j) | x+i >=0, y+j >=0, i <- [-1,0,1], j <- [-1,0,1], opponent stone == access board (x+i, y+j)]
03:13:02 <Baughn> That's the same as before
03:13:08 <Baughn> Do you /want/ 0 in the lists?
03:13:27 <shubuntu> i want it yes
03:13:36 <shubuntu> like when i'm checking north
03:13:44 <Baughn> Oh. Then you might as well use [-1..1].
03:13:47 <shubuntu> x+0, y-1 is the coordination
03:14:07 <Baughn> So what about the case where x=y=0?
03:14:36 <shubuntu> hmmm
03:14:45 <Baughn> (Hint: You can add one more comma)
03:14:46 <shubuntu> yeah I don't want 0,0 for i,j
03:15:13 <shubuntu> those will produce 0,0
03:15:32 <shubuntu> 0,0 will remain in the spot
03:15:38 <shubuntu> which isn't supposed to
03:15:49 <vixey> How are GADT folds synthesized?
03:18:39 <Foloex> :t hGetLine
03:18:41 <lambdabot> Not in scope: `hGetLine'
03:18:56 <Foloex> :t IO.hGetLine
03:18:58 <lambdabot> GHC.IOBase.Handle -> IO String
03:19:31 <Baughn> Foloex: By the way, you can do the same with /msg or even in ghci (for :t)
03:21:58 <Foloex> Baughn: the lambdabot doesn't seem to answer to /msg
03:22:19 <Baughn> Foloex: Oh, you need to register your nick first
03:22:39 <Foloex> where is the nickserv ?
03:22:49 <shubuntu> Baughn?
03:22:59 <Baughn> Foloex: /msg nickserv help
03:23:13 <Baughn> shubuntu: Hm?
03:23:33 <mbz> hm, i haven't register the nickname and bot answers to me
03:24:23 <shubuntu> well any thoughts on how to do it properly in one comprehension?
03:24:24 <shubuntu> lol
03:24:35 <roderyk> in gtk2hs, there is timeoutAdd :: IO Bool -> Int -> IO HandlerId, where the IO Bool keeps getting called at intervals until it returns False. Can I somehow register a function to be called when the IO Bool returns False? Or maybe there is a way I can poll HandlerID to see if it still exists?
03:24:38 <Baughn> shubuntu: No, that's /your/ job. ;)
03:24:54 <shubuntu> you're just being harsh
03:25:50 <Baughn> shubuntu: You've got all the tools you need. If you don't understand how list comprehensions work completely.. look it up.
03:26:15 <shubuntu> I haven't been successful in looking it up
03:26:20 <shubuntu> otherwise i wouldn't be here
03:26:25 <shubuntu> i'm not lazy
03:26:30 <Baughn> Well, if /that's/ the problem..
03:26:31 <shubuntu> i just don't know how it works properly
03:26:35 <Baughn> Hang on
03:27:13 <Baughn> http://en.wikibooks.org/wiki/Haskell/More_about_lists#List_comprehensions <-- Here's one
03:27:19 <tibbe> what does the concept "least fixpoint type" mean?
03:27:22 <lambdabot> http://tinyurl.com/2srmzq
03:27:33 <Baughn> tibbe: You know what a fixed point is?
03:27:59 <tibbe> Baughn: kinda
03:28:09 <tibbe> a value such that f(f) = f?
03:28:18 <Baughn> No, a value such that f(x) = x
03:28:24 <tibbe> ah
03:28:26 <tibbe> :)
03:28:32 <tibbe> ok
03:28:33 <Baughn> The /least/ fixed point is just the smallest such x, for some definition of "smallest"
03:28:56 <Foloex> could someone help me with IO, I can't read line by line -> http://hpaste.org/7686#a1
03:29:13 <nomeata> So id is it’s own fixed point, right? id id = id. Are other other functions that are their own fixed point?
03:29:28 <tibbe> "The recursion operator fold encapsulates a common pattern for defining programs that consume values of a least fixpoint type such as finite lists."
03:29:29 <Baughn> shubuntu: http://www.haskell.org/onlinereport/exps.html#list-comprehensions <-- Here's the official one
03:29:35 <lambdabot> Title: The Haskell 98 Report: Expressions
03:29:37 <sjanssen> nomeata: undefined?
03:29:47 <Baughn> nomeata: An infinite number
03:29:58 <tibbe> what does that say ^^
03:30:16 <Baughn> nomeata: Although, not in haskell, mostly. (Since the set of operations you can do on haskell functions is so small)
03:30:23 <tibbe> why is a list a least fixpoint type?
03:30:31 <shubuntu> that doesn't answer the question
03:30:45 <shubuntu> wether it will call the access function if those conditions don't hold
03:31:07 <nomeata> Baughn: can you give me an example?
03:31:31 <Baughn> shubuntu: It won't call anything if you've got a clause (such as x >= 0, or x /= 0 && y /= 0) that prevents it. Laziness, and all.
03:31:46 <vixey> :t (flip const)(flip const)
03:31:48 <lambdabot> forall a. a -> a
03:32:19 <Baughn> nomeata: How about the function that turns any function you pass it into a function that alters functions?
03:32:27 <shubuntu> i wish they had more detailed documentation with examples
03:32:31 <shubuntu> that would help a lot
03:32:40 <Baughn> nomeata: There's at least an infinite variety of those, and since they won't affect /each other/ (or themselves), those are fixed points
03:33:00 <Baughn> nomeata: But you can't express most of them in haskell
03:33:15 <Baughn> (Since haskell functions are opaque
03:34:18 <shubuntu> does zipWith work with all lists?
03:34:22 <shubuntu> or only Strings
03:34:30 <Baughn> All lists, as the type implies
03:34:49 <nomeata> Baughn: not sure how that function would work. How should the passed function alter functions? (.f)?
03:35:14 <Baughn> nomeata: Exactly. You can't express it in haskell.
03:35:21 <shubuntu> ok can I say a list direction is a list minus another list?
03:35:26 <Baughn> nomeata: I'm having visions of it inspecting assembly code
03:35:33 <shubuntu> can I subtract a list from another
03:35:35 <nomeata> Baughn: well, can you express it in math?
03:35:52 <shubuntu> cause then I could go like this
03:35:57 <Baughn> nomeata: Oh, sure. Might take a while, but it certainly /exists/.
03:36:13 <Baughn> shubuntu: That's what zipWith (-) does, obviously
03:36:26 <nomeata> Baughn: ok, guess as an mathematican I should be satisfied with that answer :-)
03:37:05 <Baughn> nomeata: Think about it. The problem statement is a bit vague, but it's possible for humans to do
03:37:12 <shubuntu> directions = zipWith (\i j -> (i,j) | not if i == j && i == 0)
03:37:12 <Baughn> nomeata: And humans can be expressed mathematically, so..
03:37:15 <shubuntu> does that work?
03:37:24 <Baughn> nomeata: (Realistically you probably don't need strong AI, but strong AI would do)
03:38:30 <Baughn> shubuntu: No. It's not in a list comprehension, to begin with..
03:38:38 <shubuntu> i'm confused
03:39:15 <Baughn> The a|b syntax is really [a|b] syntax. It doesn't work outside lists.
03:39:25 <shubuntu> directions = zipWith (\i j -> (i,j) | not if i == j && i == 0) [-1..1] [-1..1]?
03:39:29 <Baughn> And your use of if is just wrong
03:39:46 <Baughn> shubuntu: That's no different
03:40:36 <Baughn> shubuntu: Also, zipWith does not work like that. The resulting list will be just as long as (the shorter of) the two input lists; you seem to want to remove some elements.
03:40:37 <shubuntu> you're really not helping
03:41:00 <shubuntu> i want to remove (0,0)
03:41:05 <shubuntu> that's not wanted
03:41:17 <shubuntu> it shouldn't be this difficult
03:41:33 <shubuntu> there should a function to chop one item out?
03:41:37 <Botje> filter (/= (0,0)) $ zip [-1..1] [-1..1]
03:41:41 <Botje> there.
03:41:43 <Baughn> > [(a,b) | a /= 0 || b /= 0, a <- [-1..1], b <- [-1..1]] -- YOu mean like this?
03:41:45 <lambdabot>  [(-1,-1),(-1,0),(-1,1),(0,-1),(0,0),(0,1),(1,-1),(1,0),(1,1)]
03:41:57 <Botje> .oO(zip probably not right)
03:42:03 <Baughn> ..what the
03:42:12 <Botje> > filter (/= (0,0)) $ liftM2 (,) [-1..1] [-1..1]
03:42:13 <lambdabot>  [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]
03:42:36 <koninkje> :t (\\)
03:42:38 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
03:43:20 <koninkje> > [(a,b) | a <- [-1..1]\\[0], b <- [-1..1]\\[0]]
03:43:21 <lambdabot>  [(-1,-1),(-1,1),(1,-1),(1,1)]
03:43:32 <vixey> I am gonna go with:
03:43:33 <vixey> [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]
03:43:37 <vixey> :)
03:43:53 <Foloex> is there a (easy) way to remove every spaces and every \n from a file ?
03:43:54 <Baughn> I don't see what's wrong with mine. :/
03:44:02 <vixey> Baughn: seems ridiculous
03:44:06 <vixey> to me ..
03:44:09 <vixey> all of them
03:44:19 <Baughn> Foloex: liftM (filter x) readFile, I imagine
03:44:40 <koninkje> Foloex: sed 's/[[:space:]]//g'
03:44:46 <vixey> How do I pretty print haskell code and types?
03:44:52 <Baughn> > [a | a/=0, a<-[-1..1]]
03:44:53 <lambdabot>  [-1,0,1]
03:45:16 <Foloex> :t filter
03:45:17 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
03:45:18 <koninkje> > [a | a<-[-1..1], a /=0]
03:45:19 <lambdabot>  [-1,1]
03:45:24 <vixey> actually I only really would like a way to print
03:45:25 <vixey> ((a -> z) -> ((b -> z) -> (((Either a) b) -> z)))
03:45:42 <vixey> as (a -> z) -> (b -> z) -> (Either a b) -> z
03:45:49 <vixey> infact one less ()'s
03:45:51 <Botje> Foloex: perl -pe 's/\s+//g' ? :)
03:46:29 <koninkje> Foloex: tr -dc '[:space:]' ? ;)
03:46:30 <vixey> do you use showsPrec?
03:46:52 <Baughn> > [a | a<-[-1..1], a/= 0]
03:46:53 <lambdabot>  [-1,1]
03:46:55 <Baughn> ...
03:47:05 <vixey> > [-1,1]
03:47:06 <lambdabot>  [-1,1]
03:47:08 <Baughn> > a
03:47:09 <lambdabot>  a
03:47:15 <Baughn> Bad lambdabot, having such a bizarre a in scope
03:47:53 <koninkje> > iterate f x
03:47:54 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
03:48:09 <Baughn> @src a
03:48:09 <lambdabot> Source not found. Where did you learn to type?
03:48:11 <shubuntu> ok Baughn I'm writing it that way but i'll need to define a few helping variables for formatting
03:48:13 <koninkje> Baughn: that's why. so we can show off that sort of thing
03:48:22 <vixey> a = undefined :: Expr
03:48:26 <koninkje> > map f [1..10]
03:48:27 <lambdabot>  Add a type signature
03:48:28 <vixey> maybe ..?
03:48:34 <koninkje> > map f [a,b,c]
03:48:35 <lambdabot>  Add a type signature
03:48:38 <koninkje> meh
03:48:44 * koninkje -> bed
03:48:50 <Botje> > map f [a,b,c] :: [Expr]
03:48:51 <lambdabot>  [f a,f b,f c]
03:48:57 <Botje> thank you for playing the Expr game! :)
03:50:31 <shubuntu> -- capture (x,y) stone board =
03:50:31 <shubuntu> --         [(x+i, y+j) | x+i >= 0, x+i <= length board !! y, y+j >= 0, y+j <= length board, opponent stone == access board (x+i, y+j)]
03:50:31 <shubuntu> --       where directions = [(a,b) | a /= 0 || b /= 0, a <- [-1..1], b <- [-1..1]]
03:50:55 <vixey> does anyone have a formatter for types_
03:50:56 <vixey> ?
03:51:06 <vixey> maybe using showsPrec
03:51:10 <shubuntu> ok now how do i define those conditions as formats to map on them?
03:51:59 <shubuntu>  -- capture (x,y) stone board =
03:51:59 <shubuntu>  --         [(x+i, y+j) | x+i >= 0, x+i <= length board !! y, y+j >= 0, y+j <= length board, opponent stone == access board (x+i, y+j), (i,j) <- directions]
03:51:59 <shubuntu>  --       where directions = [(a,b) | a /= 0 || b /= 0, a <- [-1..1], b <- [-1..1]
03:52:07 <Botje> don't repaste, we saw it the first time.
03:52:18 <shubuntu> i hadn't put the directions bit in
03:52:20 <shubuntu> sorry
03:52:40 <Botje> you probably need to move the directions bit to the front
03:52:49 <Botje> before you start checking i and j
03:52:57 <shubuntu> ok
03:53:07 <shubuntu> but like i need to define a formatter
03:53:23 <shubuntu> to say like map this on to that
03:53:24 <Botje> what do you mean by "formatter"
03:53:30 <Botje> what do you mean by "map this onto that"
03:53:57 <vixey> so I have data Type = Var Name | Type :->: Type | Tuple [Type] | Type :$: Type
03:54:04 <Botje> we don't have access to the information you do, remember
03:54:05 <shubuntu> map formatLst directions
03:54:09 <vixey> right now I print ((a -> z) -> ((b -> z) -> (((Either a) b) -> z)))
03:55:02 <Botje> how would that fit in with your current function? what's map formatList directions supposed to do?
03:55:05 <shubuntu> and bring the  x+i >= 0, x+i <= length board !! y, y+j >= 0, y+j <= length board bit out of that expression
03:55:25 <shubuntu> only give i,j's  that satisfy that
03:55:34 <Botje> map can't leave out elements
03:56:06 <shubuntu> ok how do i remove those bits then
03:56:13 <Botje> filter
03:56:16 <shubuntu> ok
03:56:17 <nomeata> Baughn: hmm. I can’t think of an example. Do you really think that it’s possible with normal, set theory based functions?
03:56:28 <shubuntu> i need to make that lengthy expression into something neat
03:56:32 <vixey> use fold for a filtering map
03:57:01 <Botje> validPos (x,y) = x `inRange` (0,length board) && y `inRange` (0, length board)
03:57:16 <Botje> @hoogle inRange
03:57:17 <lambdabot> Data.Ix.inRange :: Ix a => (a, a) -> a -> Bool
03:57:17 <lambdabot> Distribution.Version.withinRange :: Version -> VersionRange -> Bool
03:57:25 <Botje> bah, reversed the arguments :/
03:57:44 <shubuntu> Botje
03:58:06 <shubuntu> if x is not in the list for north it still is for the south
03:58:25 <shubuntu> so that validPos thing may not work
03:59:06 <Botje> .. what?
03:59:06 <heavensrevenge> hello, this channel seems quite active
03:59:20 <Botje> will you stop giving information piecewise and get it out one at a time?
03:59:29 <Botje> put some code on hpaste and describe what's wrong with it
03:59:31 <heavensrevenge> im just gonna sit back and enjoy the action for now :)
03:59:44 <Botje> heavensrevenge: hope you don't mind exploding brains flying by
03:59:56 <shubuntu> i did initiallly Botje
04:00:01 <shubuntu> i'm sorry you're aggravated
04:00:07 <shubuntu> but I initially did
04:00:17 <Botje> i looked at my lastlog, yes
04:00:19 <shubuntu> if you need the code I can do it on hpaste
04:00:46 <Botje> shubuntu: you can start by weeding out all positions NOT on the board with validPos
04:01:01 <Botje> working out valid moves for the different sides can be done in a different function
04:01:05 <heavensrevenge> haha im a newby, but ive decided to look into functional languages 1st
04:01:26 <vixey> heavensrevenge: wise desicion
04:01:43 <heavensrevenge> well im glad it was
04:02:50 <heavensrevenge> i WAS going to do erlang at 1st, but haskell caught my eye for some odd reason
04:03:41 <Foloex> I have a problem with IO, I read a file and pass the string to a function. The problem is that I can't call my function, I get a "Does not match : IO a" on it's parameters
04:03:59 <Botje> Foloex: can you put some code on hpaste?
04:04:31 <Botje> shubuntu: you have a way of figuring out what kind of stone is on a square, yes?
04:04:43 <shubuntu> yes
04:04:48 <shubuntu> by access
04:04:50 <Foloex> Botje: http://hpaste.org/7687
04:05:05 <Foloex> I pasted the error at the end
04:05:06 <shubuntu> that access function returns the type of stone
04:05:19 <shubuntu> and opponent returns the opposite of a stone
04:05:46 <Foloex> Botje: the comments are in French, sorry about that ^^
04:05:48 <shubuntu> opponent :: Stone -> Stone; opponent Dark = Light; opponent Light = Dark
04:06:08 <shubuntu> access :: Board -> Coord -> Stone
04:06:08 <shubuntu> access board (x, y) = board !! y !! x
04:06:50 <Botje> shubuntu: okay
04:07:02 <Botje> shubuntu: so you can write a function canMove
04:07:10 <Botje> that gets a stone and a move
04:07:17 <Botje> that checks if that move is allowed
04:07:20 <scook0> does anybody know what I'm supposed to do to submit a new SSH key for code.haskell.org?
04:07:29 <shubuntu> well the range one sounds better
04:07:52 <Botje> Foloex: you need to do something IO-ish with the chargeLigne thing
04:08:02 <Botje> shubuntu: you can keep the range to check if a stone doesn't move out of the board
04:08:11 <Botje> and then you can use canMove to see if a move is allowed
04:08:21 <shubuntu> isInRange (x,y) 0 (length board)
04:08:29 <tibbe> @type :map
04:08:31 <lambdabot> parse error on input `:'
04:08:36 <Foloex> Botje: ^o) ?
04:08:37 <tibbe> @type map
04:08:39 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
04:08:40 <tibbe> @type mapM
04:08:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:08:54 <Botje> Foloex: i'm guessing you want to do print $ chargeLigne ...
04:09:17 <Botje> how are you using lireFichier?
04:09:32 <osfameron> how can I tell if an array contains all Just's ?
04:09:33 <Foloex> Botje: chargeLigne fill an array with the number read from the file
04:09:48 <osfameron> or more generally, matches a particular constructor for all elements ?
04:09:50 <Foloex> Botje: lireFichier returns the filled array
04:10:02 <Botje> Foloex: ah. then you just do return $ chargeLigne
04:10:14 <Botje> Foloex: ah. then you just do return $ chargeLigne grille chaine 'A' 'a'
04:10:18 <Botje> at the end of lireFichier
04:10:36 <Foloex> Botje: ok, testing ...
04:11:35 <Botje> shubuntu: how are you coming along?
04:12:20 <Foloex> Botje: it kind of work except it returns a IO Array
04:12:34 <Botje> Foloex: that's what a do block means
04:12:41 <Botje> again, how are you using lireFichier?
04:13:06 <Foloex> lireFichier should return an Array, I use this array to solve the sudoku
04:13:15 <Botje> but you can't do that :)
04:13:19 <Botje> lireFichier is in the IO monad
04:13:26 <Botje> because you're using readFile
04:13:33 <Botje> what you CAN do
04:13:38 <Botje> is define main as follows:
04:13:51 <Botje> main = do grille <- lireFichier "somefile"
04:14:05 <shubuntu> BotJe I'll post it on hpaste and paste the link
04:14:07 <Botje>         print $ solve grille
04:14:08 <shubuntu> let me finish up
04:14:12 <Botje> shubuntu: fair enough
04:14:29 <Foloex> Botje: I'll try
04:14:29 <Botje> Foloex: that's the "proper" way to solve this
04:15:32 * osfameron gives up and does a "| catMaybes x == []" but that seems a bit horrid
04:15:38 <shubuntu> http://hpaste.org/7689
04:15:42 <Botje> osfameron: in the case of [Maybe
04:15:45 <shubuntu> it still doesn't look neat
04:15:47 <Botje> ] you can use sequence
04:15:53 <Botje> in other cases, i dunno
04:16:07 <Botje> length list == length [ () | Con _ <- list]
04:16:09 <Botje> or somesuch? :)
04:16:10 <Foloex> Botje: wokrs
04:16:15 <Botje> Foloex: yay!
04:16:31 <osfameron> Botje: oh, cos sequence will end up with Nothing or Just for the whole thing?
04:16:36 <Botje> osfameron: indeed :)
04:16:38 <Foloex> Botje: now I have to write the solver's code ^^
04:16:41 <Botje> evil side effects :)
04:16:46 <Botje> Foloex: congratulations :p
04:16:50 <osfameron> Botje: but that's still in a guard clause right?
04:17:03 <Botje> osfameron: uh, maybe? dunno :)
04:17:09 <Botje> shubuntu: inRange is in Data.Ix
04:17:13 <Botje> so you need to import that
04:17:13 <Foloex> Botje: anyway, thank you a lot Botje !
04:17:21 <Botje> and when i gave you that line, i reversed the arguments
04:17:21 <shubuntu> ok I'll import it
04:17:24 <Botje> :t inRange
04:17:25 <osfameron> Botje: as in, there's no pattern match for, say (x@"all Justs")  ?
04:17:26 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
04:17:32 <Botje> osfameron: don't think so :)
04:17:46 <Botje> shubuntu: as you can see, it should be (0,xRange) `inRange` x
04:17:47 <osfameron> ok, thanks :D
04:17:49 <Botje> and likewise for the y
04:18:36 <Botje> shubuntu: also, you can pass the board itself to isValidPos
04:18:43 <Botje> and have that figure out the proper dimensions
04:18:56 <Botje> that would reduce it some more
04:18:57 <shubuntu> well then I'll have to pass i and j too
04:19:04 <electronx> just wandering has anyone thought of making a 3d game in haskell?
04:19:07 <Botje> no, why?
04:19:11 <osfameron> hmmm, actually, I want the opposite (all Nothings), so that won't work anyway.
04:19:23 <shubuntu> cause the length of board and columns of board aren't neccessarily the same
04:19:45 <Botje> shubuntu: fair enough, but you can at least assume the board is the same size on every row, no?
04:19:55 <Botje> it's not like one row is 5 squares and another is 9?
04:20:11 <shubuntu> yes
04:20:16 <electronx> just took a look at frag and it looks amazing and the code is pretty small and readable makes haskell look pretty good for game development
04:20:28 <Botje> in which case you can just check length (board !! 0)
04:20:48 <Botje> electronx: did you see Tim Sweeny's presentation on the future of game development?
04:20:53 <shubuntu> easy way to get the length of row of it?
04:21:15 <electronx> Botje: yeah
04:21:35 <Botje> shubuntu: length (board !! 0)
04:21:41 <electronx> Botje: but to me it doesn't seems like anyone is interested in taking the plunge
04:21:59 <Botje> electronx: that's because c++ is only now showing some cracks
04:22:00 <shubuntu> ooh easy
04:22:01 <shubuntu> yeah
04:22:04 <shubuntu> silly me
04:22:11 <Botje> multiprogramming is still "manageable" with 2 or 4 cores
04:22:33 <Botje> but once you have 16 cores all doing a different thing, life gets very hard
04:23:06 <electronx> Botje: i'm thinking of porting my grapics project, which is a 3d terrain generator into haskell after seeing frag :)
04:23:24 <Botje> electronx: heh, i wrote a simple terrain generator in haskell this summer
04:23:24 <shubuntu> http://hpaste.org/7690
04:23:27 <shubuntu> how abot this
04:23:31 <Botje> nothing fancy, just an exercise
04:23:38 <electronx> Botje: can i see it?
04:23:45 <Botje> electronx: i'll put it on hpaste, sec
04:23:52 <Botje> it's not too sexy but it works
04:23:56 <electronx> :)
04:24:09 <Botje> shubuntu: why is isValidPos still commented?
04:24:20 <Botje> and you still need to reverse the arguments to inRange
04:24:39 <Botje> and you forgot the :: on the type dec for isValidPos
04:25:07 <AliPang> question: i have an implementation of a linked list data List a = Empty | Cons a (List a)... i have implemented Show for it... but i would like to do a special case for List Char, and print it as a string... anyone know how to do?
04:25:13 <shubuntu> the range has to first?
04:25:18 <AliPang> instance (Show a) => Show (List a) where
04:25:18 <AliPang> 	show Empty = "[]"
04:25:18 <AliPang> 	show l = "[" ++ (init.init) (go l) ++ "]" where
04:25:18 <AliPang> 	     go Empty = ""
04:25:18 <AliPang> 	     go (Cons x xs) = (show x) ++ ", " ++ go xs
04:25:44 <Botje> electronx: http://hpaste.org/7691
04:25:53 <electronx> Botje: thanks
04:26:05 <Botje> AliPang: just define a separate instance for Show (List Char)
04:26:10 <AliPang> i tried to do instance (List Char) where ..., but thart didnt work
04:26:15 <Botje> but you'll need overlapping instances, probably.
04:26:28 <AliPang> overlapping instances?
04:26:29 <Botje> shubuntu: yes.
04:26:31 <Botje> :t inRange
04:26:32 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
04:26:36 <Baughn> Botje: Not really
04:26:36 <Botje> AliPang: yeah, that's what you're doing.
04:26:38 <Botje> no?
04:26:44 <AliPang> let me see
04:26:46 <Baughn> AliPang: Show (for []) does it by having a separate showList function
04:26:48 * Botje is still a bit fuzzy on instances
04:27:02 <Baughn> AliPang: So [Char] calls showList on Char, not show on []
04:27:29 <Baughn> Botje: Well, you could conceivably do it with overlapping instances, but that would be ugly
04:27:55 <Baughn> @type showList
04:27:57 <lambdabot> forall a. (Show a) => [a] -> String -> String
04:28:23 <Botje> shubuntu: and you still need to do (i,j) <- directions in the capture (before the isValidPos check)
04:28:56 <AliPang> i added the code:
04:28:56 <AliPang> instance (List Char) where
04:28:56 <AliPang> 	 show list = "test"
04:28:56 <AliPang> and get: test.hs:34:2: `show' is not a (visible) method of class `List'
04:29:03 <electronx> Botje: it doesn't render anything :)
04:29:12 <Botje> electronx: ah, no. it's just a generator
04:29:22 <Botje> i didn't implement the renderer yet, sorry :)
04:29:22 <Baughn> AliPang: show is already a method of class Show. Invent a new name.
04:29:38 <Baughn> AliPang: Or wait, maybe you want "instance Show (List Char)"
04:29:58 <AliPang> yeah i just realized
04:30:08 <electronx> Botje: hehe my project involved rendering a 3d terrain then implementing a 3d snake game i think it will be interesting to try and implement it in haskell :)
04:30:12 <frwmanners> Anyone know reasons why the ghc profiler should create completely blank files?
04:30:20 <AliPang> but it still doesnt compile.. this time with: Illegal instance declaration for `Show (List Char)'
04:30:27 <Botje> electronx: sounds like a fun project, go for it :)
04:30:31 <AliPang> 	(All instance types must be of the form (T a1 ... an)
04:30:31 <AliPang> 	 where a1 ... an are distinct type *variables*
04:30:54 <Baughn> AliPang: Mm, yes. You can't instance List Char, only List a
04:31:03 <frwmanners> AliPang: FlexibleInstances this time?
04:31:49 <electronx> Botje: maybe i will just suprised by the lack of almost any 3d in haskell apart from frag
04:32:35 <Baughn> electronx: opengl mysteriously fails to work in ghci, which is no doubt discouraging (but I don't think that's really why)
04:33:30 <shubuntu> http://hpaste.org/7692
04:33:43 <shubuntu> ok look Botje
04:33:48 <AliPang> ok, i got it working using -flexinstances and antoehr flag... is this a feature of ghc then? does anyone know a way to do this without special compiler flags? i mean it works for the built in lists in haskell?
04:33:51 <shubuntu> it should be alright this time
04:34:04 <Botje> shubuntu: length (board !! 0)
04:34:06 <Baughn> AliPang: It doesn't work for the built-in lists in haskell
04:34:11 <Botje> and isValidPos :: Coord -> Board -> Bool
04:34:17 <AliPang> no?
04:34:17 <Botje> (are you even running this by the typechecker?)
04:34:25 <Baughn> AliPang: You can instance for Show a => List a, which is what those do
04:34:30 <Botje> because you misspelled directions
04:34:58 <Baughn> @src [] show
04:34:58 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
04:35:03 <Botje> for the rest it's looking fine.
04:35:19 <electronx> Baughn: has it been filed as a bug?
04:35:26 <Baughn> electronx: No idea
04:35:37 <AliPang> Baughn: but it prints ['t', 'e', 's', 't'] as "test", and [1,2,3,4] as [1,2,3,4]? how is that not a special case for [Char]?
04:36:00 <AliPang> and how would i do it with Show a => List a?
04:36:06 <Baughn> AliPang: It cheats, using the showList function defined for Char instead of the show function defined for []. Or rather, the latter calls the former
04:36:44 <AliPang> ok, i see... thanks
04:39:07 <AliPang> Baughn: any insight as to why what i was trying to do is not allowed in vanilla haskell? that is some sort of pattern matching... first instancing List Char and then Show a => List a?
04:39:44 <roderyk> what is the idiom for getting a gtk2hs to sleep/poll for a couple seconds? I really can't seem to find an example. I tried putting the thread to sleep, but all the other timers still interfere with it
04:40:10 <vixey> AliPang: Typeclass dispatch
04:40:42 <AliPang> vixey: could you explain that further? or do you know somewhere i could read up on it?
04:42:27 <vixey> AliPang: For example, Functor is a class
04:42:30 <vixey> @src Functor
04:42:30 <lambdabot> class  Functor f  where
04:42:30 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
04:42:40 <vixey> and there are some instances of this class
04:42:48 <vixey> @instances Functor
04:42:50 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
04:43:13 <vixey> @src [] fmap
04:43:13 <lambdabot> fmap = map
04:43:18 <vixey> @src Maybe fmap
04:43:18 <lambdabot> fmap _ Nothing       = Nothing
04:43:18 <lambdabot> fmap f (Just a)      = Just (f a)
04:43:34 <vixey> here's two different definitions of fmap in the two different instances
04:43:40 <vixey> so...
04:43:47 <vixey> > fmap (+1) [1,2,3]
04:43:49 <lambdabot>  [2,3,4]
04:43:54 <vixey> > fmap (+1) (Just 7)
04:43:55 <lambdabot>  Just 8
04:44:16 <vixey> which definition of fmap to be used is decided by typeclass dispatch
04:44:28 <vixey> and I'm guessing the same is done here with the Show class
04:44:29 <vixey> :t show
04:44:31 <lambdabot> forall a. (Show a) => a -> String
04:44:43 <vixey> so that one for String = [Char] is different to the default
04:45:01 <shubuntu> Botje, I just noticed. the range is one less than the length
04:45:13 <AliPang> yaeh, but you could allow for some sort of patter matching for it to be unambiguous, no?
04:45:18 <vixey> no
04:45:24 <shubuntu> i'm not sure about the inRange now how it works
04:46:22 <shubuntu> like is InRange (1,8) 8 true or false?
04:46:34 <AliPang> vixey: i dont see why not.. could you give an example?
04:46:42 <vixey> of what
04:46:50 <AliPang> where it would be ambiguous
04:46:57 <Botje> shubuntu: uhh
04:47:01 <vixey> don't know what you mean
04:47:14 <shubuntu> that's tricky
04:47:19 <Botje> > map (Data.Ix.inRange (1,10)) [1..10]
04:47:20 <lambdabot>  [True,True,True,True,True,True,True,True,True,True]
04:47:36 <Botje> oh,
04:47:37 <Botje> yes
04:47:43 <Botje> you need to do length - 1 then :)
04:47:53 <shubuntu> cause it has to be 0<= y+j < length board
04:48:03 <Botje> yeah
04:48:05 <Botje> OR
04:48:13 <Botje> you check x+1 and y+1
04:48:21 <shubuntu> then 0
04:48:21 <Botje> against 1 <= x+1 <= length board
04:48:24 <shubuntu> has to become 1
04:48:25 <shubuntu> lol
04:48:27 <shubuntu> either way
04:48:57 <shubuntu> oh can I write it that way?
04:49:07 <Botje> unfortunately not.
04:49:12 <shubuntu> aww
04:49:14 <shubuntu> how bad
04:49:56 <Botje> so do length -1 and you'll be fine
04:50:48 <MarcWeber> dcoutts: The PackageDescriptnios contains buildDepends :: [ Dependency ] and BuildInfo does as well. Which is the relation?
05:15:51 <shubuntu> Botje
05:16:06 <shubuntu> how do I write a put function without doing a whole iteration?
05:16:25 <shubuntu> put :: Stone -> Coord -> Board -> Board
05:16:25 <shubuntu> put stone place board =
05:19:24 <shubuntu> it's an insert function basically
05:19:37 <shubuntu> to replace the cell at x,y
05:21:28 <Syzygy-> > map (Data.Ix.inRange (1,10)) [0..11]
05:21:30 <lambdabot>  [False,True,True,True,True,True,True,True,True,True,True,False]
05:21:37 <dcoutts> MarcWeber: I think one is the union of the other
05:22:17 <dcoutts> roderyk: I'm not quite sure what you're trying to do, what kind of sleep/poll thing?
05:22:21 <shubuntu> Botje?
05:23:06 <dcoutts> nomeata: Axel doesn't come here much
05:23:44 <nomeata> dcoutts: ok. He was quite responsive by mail, though, as you might have noticed :-)
05:24:14 <dcoutts> nomeata: oh yes
05:24:45 <roderyk> dcoutts: do {renderImage ; sleep (3); timeoutAdd(..)} where the the timeoutAdd uses the same drawingwindow as render. So, essentially... if I can't sleep it will automatically overwrite the rendered image
05:25:52 <dcoutts> roderyk: ok, so what goes wrong?
05:30:10 <dcoutts> nomeata: I agree with Axel's analysis -g is not needed
05:30:21 <roderyk> dcoutts: well, for some reason I couldn't get it to sleep. the timeoutAdd() would just jump in; if that should have worked, then maybe my code was off. I ended up refactoring a bunch, so maybe it was my mistake : )  For now, I added an additional case to my timer. I think what I'm really looking for is: startNew = do {h <- timeoutAdd(..); return h};  and then some kind of iteration: everytime (isDone h) startNew
05:30:40 <nomeata> dcoutts: merci
05:30:45 <roderyk> since h will return False after  a couple iterations, but I can't find an API/signal to check when it's done
05:31:10 <dcoutts> roderyk: there is none, but since you know when it returns Fasle, then you can do something
05:31:16 <RayNbow> http://reddit.com/r/programming/info/6jqtk/comments/ <-- needs more upvotes :p (Bryan O’Sullivan: Concurrent and multicore programming in Haskell (video) (blip.tv))
05:31:26 <dcoutts> roderyk: however, do you mean that the sleep is not doing anything, ie not sleeping?
05:32:06 <dcoutts> roderyk: are you sure you got the sleep duration correct? what function are you using exactly to do the sleep? threadDelay? Check the timeout, I think they're usually in milliseconds
05:32:29 <roderyk> dcoutts: yea, essentially my timer has grown into this gigantic thing that seems to handle the entire logic in 500 ms increments, heh
05:33:16 <roderyk> dcoutts: I remember trying usleep (in ms) and even tried a System.Cmd.system "sleep 1" heh
05:35:02 <dcoutts> roderyk: threadDelay should be the default choice
05:36:32 <roderyk> dcoutts: i see. For now, this seems to work well enough for me, but I will keep it in mind for future reference
05:36:47 <esteth_> I currently have ghc 6.6.1 installed. I'm upgrading to 6.8.2 through source. Should i remove 6.6.1 (installed via debian package) before i make install?
05:37:28 <ivanm> esteth_: there's not debian 6.8.2 install package?
05:38:24 <esteth_> There may be, but i can't see one for ubuntu 7.10
05:38:56 <ivanm> *nod*
05:41:58 <esteth_> So, does anyone know if i should remove the package before installing from source?
05:42:27 <Lemmih> esteth_: You can have both installed at the same time.
05:43:14 <chessguy> good morning, folks
05:43:48 <RayNbow> *watching vid* hmm, so that's how you're supposed to pronounce `seq` :p
05:43:50 <Saizan> esteth_: btw, it's common to just use the generic linux binary that's on GHC's download page
05:44:44 <Foloex> is there a function that returns the difference between 2 list ?
05:45:07 <Deewiant> > [1,2,3] \\ [1,2]
05:45:08 <lambdabot>  [3]
05:45:20 <Foloex> Deewiant: thanks ^^
05:45:28 <esteth_> Lemmih / Saizan: Thanks
05:45:43 <RayNbow> Foloex: you might need to import the List module though
05:45:49 <Foloex> [1,2,3,4,5,6] // [ 2,3,5]
05:45:52 <Foloex> > [1,2,3,4,5,6] // [ 2,3,5]
05:45:53 <lambdabot>  Couldn't match expected type `Array i e'
05:46:05 <Foloex> > [1,2,3,4,5,6] \\ [ 2,3,5]
05:46:06 <lambdabot>  [1,4,6]
05:46:43 <kaol> > [] \\ [undefined]
05:46:44 <lambdabot>  []
05:47:28 <kaol> @src (\\)
05:47:28 <lambdabot> (\\) = foldl (flip delete)
05:47:37 <kaol> @src delete
05:47:38 <lambdabot> delete = deleteBy (==)
05:47:42 <kaol> @src deleteBy
05:47:42 <lambdabot> Source not found. Sorry.
05:54:37 <nomeata> dcoutts: btw, thx again for gtk2hs, I could do nice things with it (http://www.joachim-breitner.de/blog/archives/292-FrakView-An-Haskell-Renderer-for-Iterated-Function-Systems.html)
05:54:40 <lambdabot> Title: FrakView: An Haskell Renderer for Iterated Function Systems - nomeata’s mind s ..., http://tinyurl.com/6dtoww
06:03:36 <lilac> is there a generalization of break, ([a] -> Bool) -> [a] -> ([a], [a])?   something like:  break' p xs@(x:xs') = if p xs then ([], xs) else first (x:) (break' p xs')
06:04:19 <mercury^> :t break
06:04:21 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
06:05:18 <chessguy> lilac: the problem is, there are a lot of ways you can generalize that
06:05:23 <chessguy> it's been talked about many times
06:07:34 <lilac> chessguy: ok, thanks. the break = break' . head generalization i want seems like a pretty obvious one, tho...
06:07:53 <chessguy> sure. there are other obvious ones, too, though
06:08:06 <chessguy> and they're all easy enough to write
06:08:16 <EvilTerran> ?type \p xs -> fromMaybe (xs,[]) . listToMaybe . filter (p.snd) $ zip (inits xs) (tails xs)
06:08:18 <lambdabot> forall a. ([a] -> Bool) -> [a] -> ([a], [a])
06:08:37 <lilac> fair point. i guess the prelude needs to focus on those ones which come up most often
06:08:38 <EvilTerran> ?type \p xs -> fromMaybe (xs,[]) . find (p.snd) $ zip (inits xs) (tails xs) -- even
06:08:40 <lambdabot> forall a. ([a] -> Bool) -> [a] -> ([a], [a])
06:10:30 <lilac> EvilTerran: isn't that O(n^2)?
06:10:49 * lilac is not very good at runtime analysis w/laziness
06:11:06 <chessguy> are there any sticky issues with re-licensing code under a different license?
06:11:15 <Bonus> depends on the licences
06:11:26 <lilac> chessguy: depends on the license holders
06:11:41 <chessguy> i want to start with my own license that says that it may not be used for anything, and then change it to a more amenable one later
06:11:42 <Bonus> generaly you can go from a restrictive license to a permissive one easily
06:11:59 <Bonus> yeah that's kewl
06:12:00 <lilac> chessguy: if it's your own copyright, then there's no problem.
06:12:08 <Bonus> it's harder to have something released, say, under the GPL
06:12:12 <Bonus> and then want to close source it later
06:12:20 <chessguy> ok cool, just wanted to make sure i wasn't shooting myself in the foot
06:12:41 <nomeata> Bonus: not really harder, as long as you have the copyright. the old code is still available under the GPL then, though.
06:13:11 <Bonus> but isn't it like hmm
06:13:16 <Bonus> that because you use the old code in your new code
06:13:22 <Bonus> the new code has to also be GPL
06:13:25 <Bonus> because of the viral property
06:13:33 <nomeata> Bonus: nope, the GPL does not apply to yourself :-)
06:13:41 <Bonus> aah
06:13:44 <nomeata> Bonus: only to people you _give_ the code to
06:13:59 <lilac> chessguy: general rules are (IANAL): your own copyright, license it how you like. other people's copyright, you need permission, unless the existing license says otherwise. you can't take back a license you've granted.
06:14:13 * nomeata nods.
06:15:00 <chessguy> what the heck is IANAL
06:15:01 <lilac> slight complication: under certain jurisdictions, you may not have copyright on works you create (check your employment contract) :(
06:15:08 <lilac> chessguy: I Am Not A Lawyer
06:15:13 <chessguy> aha
06:15:28 <chessguy> oh, this is stuff i'm doing in my free time, so that shouldn't be an issue
06:15:41 <nomeata> chessguy: yes, who would think of a layer when he reads something ANAL, right ;-)
06:16:03 <nomeata> chessguy: actually, some contracts even affect your private work, I heared.
06:16:13 <chessguy> wow, really?
06:16:19 <chessguy> hrm
06:16:39 <chessguy> even if your private work is completely unrelated to your job?
06:17:20 <nomeata> I heard so. Not sure how legally effecive it is.
06:17:41 <chessguy> worth checking into though :(
06:20:02 <lilac> chessguy: here in the UK, contracts often say that things you do in your spare time are theirs, but it's usually not enforceable (unless you're competing with them or similar)
06:21:22 <Foloex> > fst (0,1)
06:21:24 <lambdabot>  0
06:21:30 <Foloex> > snd (0,1)
06:21:31 <lambdabot>  1
06:22:28 <Foloex> > 2 mod 3
06:22:30 <lambdabot>        add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
06:22:42 <Foloex> > (mod 2 3)
06:22:44 <lambdabot>  2
06:23:26 <nomeata> > 2 `mod` 3
06:23:28 <lambdabot>  2
06:23:44 <EvilTerran> lilac, i wouldn't expect it to be O(n^2) - tails is O(n) on how far down the result list you go, find is O(n) similarly, and only one element of the result of inits is forced, so that'll be O(n) too
06:23:53 <Bonus> > concat ['i','m',' ','g','a','y']
06:23:54 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
06:24:08 <Bonus> > concat ['i','m',' ','g','a','y'] :: String
06:24:09 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
06:24:13 * EvilTerran looks askance at Bonus
06:24:13 <Bonus> ughghgh
06:24:34 <Bonus> oh lol man
06:24:44 <Bonus> i'd have to have " "
06:24:46 <nomeata> > concat ["i","m"," ","h","a","p","p","y"]
06:24:47 <EvilTerran> > ['w','t','f',' ','r',' ','u',' ','d','o','i','n','?']
06:24:48 <lambdabot>  "wtf r u doin?"
06:24:49 <lambdabot>  "im happy"
06:24:59 <Bonus> ah yes
06:25:00 <MarcWeber> dcoutts: any reason for using     noDesc = die $ "No cabal file found.\n"
06:25:18 <MarcWeber> because using die disables you catching the error case..
06:25:31 <MarcWeber> (it inkoves exitWith ..)
06:26:25 <MarcWeber> Oh I've been wrong it can be catched
06:26:35 <schme2> So where do I find information on what $ is ?
06:28:12 <Bonus> @src $
06:28:13 <lambdabot> f $ x = f x
06:28:17 <Bonus> it looks pretty stupid
06:28:19 <Bonus> but the thing is
06:28:25 <Bonus> it has a very weak precedence
06:28:43 <Bonus> so you can think of it as kind of making a )( and then adding matching parens at the end and beginning of an expression
06:29:10 <schme2> Hmm.. sorry.. making a )( ?
06:29:15 <Bonus> yeah like
06:29:19 <Bonus> f $ x
06:29:23 <Bonus> f )( x
06:29:27 <Bonus> ( f ) ( x )
06:29:36 <schme2> (.) (.)  ;)
06:29:36 <Bonus> as just replacing it with two parens
06:29:40 <Bonus> :o
06:29:58 <schme2> Right ok.. well .. huh. It makes no sense what so ever that there $ :)
06:30:08 <Bonus> yeah but if you have like
06:30:27 <schme2> putStrLn $ "Welcome to Haskell, " ++ inpStr ++ "!"          seems to be what I have
06:30:35 <Bonus> yeah that's like doing
06:30:39 <schme2> Oh wait I see.
06:30:41 <schme2> thanks.
06:30:46 <Bonus> putStrLn ("Welcome to Haskell, " ++ inpStr ++ "!")
06:31:05 <Bonus> when you have multiple $'s
06:31:09 <Bonus> then you just go from right to left
06:31:24 <schme2> I don't quite get the point of it.
06:31:29 <schme2> Why not just use parens?
06:31:38 <Bonus> so you don't end up with heaps of parens
06:31:58 <schme2> Hmm. So it's just there to uglify the code? :)
06:32:03 <schme2> (((()))) = pretty
06:32:04 <Bonus> beautify it! :]
06:32:11 <nomeata> schme2: only until you are used to it
06:32:12 <Bonus> yeah if you're a lisp guy
06:32:16 <schme2> Bonus: I am.
06:32:19 <Bonus> ahah
06:32:20 <Bonus> i knew it
06:32:37 <Bonus> usually it's great to use it with function composition
06:32:40 <Bonus> so instead of doing
06:32:49 <Bonus> (j (h (g (f x))))
06:32:50 <Bonus> you do
06:32:53 <Bonus> j . h . g . f $ x
06:33:05 <nomeata> although some combine it with . for even nicer syntax. a (b (c (d (e x)))) or a $ b $ c $ d $ e $ x or a . b . c . d . e $ x
06:33:15 <schme2> I'm sorry.
06:33:22 <schme2> It's very much uglier :P
06:33:32 <Bonus> haha that's not saying a lot coming from a lisper :P
06:33:38 <schme2> :D
06:33:54 <nomeata> “Brace yourself, a lisper is coming!”
06:34:00 <Bonus> haha
06:34:03 <Bonus> oh god the puns
06:34:10 <schme2> But ya ok. There's no hmm.. what you say... "real" differenc between the parens and the $ though? Just sugar, eh?
06:34:27 <nomeata> Yes, I prefer pointless programming over punless chatting.
06:34:33 <Bonus> yeah well no effective difference
06:34:40 <schme2> K thanks.
06:34:52 <schme2> I'm reading this here real world haskell book and that $ kinda pops up now and then :)
06:34:57 <Bonus> but remember, anyone can write code readable by machines
06:35:03 <Bonus> the trick is to write code that is readable by humans
06:35:04 <nomeata> Actually, with zero optimization, the use of $ is another function call, isn’t it?
06:35:10 <Bonus> yup
06:35:18 <mbz> hm, it is not a syntax sugar at all
06:35:24 <Bonus> its a function with infixr of 1
06:35:24 <mbz> you can do map . map
06:35:29 <Bonus> yeah its not but you can think of it that way
06:35:48 <schme2> Why on earth would I worry about having code readable by humans though?
06:35:50 <schme2> ;)
06:35:50 <nomeata> So there is a performance cost unless the compiler starts to inline it?
06:35:51 <mbz> well, may be a bit
06:36:16 <Baughn> Not so you'd notice
06:37:06 <vixey> nomeata: hey speaking of.. (~> (fibs) ('cons (succ (zero)) ('cons (succ (zero)) (zip-with + (fibs) (cdr (fibs))))))
06:37:24 <Bonus> > ($) (+ 4) 3
06:37:26 <lambdabot>  7
06:37:28 <Bonus> yay
06:37:41 <nomeata> vixey: was that directed to me?
06:37:41 <vixey> ($) = id -- too
06:37:45 <vixey> nomeata: yes
06:37:52 <Bonus> ah
06:37:57 <Larose> is there a function that returns unique elements of a list ?
06:38:02 <vixey> Laros: nub
06:38:06 <Bonus> > uncurry ($) ((+ 3), 4)
06:38:08 <lambdabot>  7
06:38:17 <Bonus> Larose the funciton is called nub
06:38:21 <Bonus> he's not calling you a nub
06:38:24 <Bonus> it's in Data.List
06:38:33 <mux> except when you want map head . group . sort
06:39:58 <Larose> vixey, Bonus: ok, thanks
06:41:25 <lilac> hmm, nub looks to be O(n^2), whereas map head . group . sort would presumably be O(n log n)
06:41:40 <schme2> Oh ya. I have been looking around http://www.haskell.org/ghc/docs/latest/html/libraries/index.html and I can't seem to find any xlib bindings. Where would I look for those?
06:41:59 <Bonus> umm
06:42:04 <Bonus> whats the complexity of sort
06:42:14 <Baughn> n*log n
06:42:32 <Bonus> how about group?
06:42:39 <Baughn> lilac: Yes, but probably still slower than stuffing them into and then extracting from a set
06:43:10 <lilac> Bonus: O(n)
06:43:38 <lilac> Bonus: actually, \Phi(n), to be more precise
06:44:13 <nomeata> lilac: \Phi? I thought there was O, Omega and Theta?
06:44:30 <lilac> nomeata: yea, i probably mean Theta.
06:44:36 <nomeata> ok :-)
06:44:51 <Larose> http://hpaste.org/7697 First, how can I apply this operation n times. Second, can I do it without monad ?
06:44:52 <ehird> Type system programming is fun.
06:45:00 <lilac> nomeata: out by 90 degrees ;-)
06:45:03 <ehird> Larose: what
06:45:15 <schme2> No one who knows, eh?
06:45:21 <vixey> Larose: you can't
06:45:40 <vixey> Larose: what's the type of the opeartion?
06:45:52 <Larose> list of Num
06:46:22 <mux> a >>= return  is the same as just a
06:46:28 <schme2> Right. I'll just pop over to #xmonad. They have got to know :)
06:46:28 <nomeata> ">>= return" cancels away, doesn’t it?
06:46:35 <ehird> nomeata: yes.
06:46:38 <ehird> yes it does.
06:46:39 <Larose> vixey: mult :: Num a => [a] -> [a] ?
06:46:40 <vixey> Larose: oh in that case, (!!n).iterate
06:46:48 <lilac> Larose: which monad are you in?
06:46:48 <vixey> > iterate f x
06:46:50 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
06:46:53 <nomeata> so it’s just  prod = nub [a*b | a <- prod, b <- prod]
06:46:56 <ehird> vixey: shocked ... WITH THE POWER OF POINTLESS!
06:46:57 <vixey> > (!!7).(iterate f)$x
06:46:58 <lambdabot>  f (f (f (f (f (f (f x))))))
06:47:02 <vixey> > (!!12).(iterate f)$x
06:47:03 <ehird> :t nub [a*b | a <- prod, b <- prod]
06:47:03 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f x)))))))))))
06:47:05 <lambdabot> Not in scope: `prod'
06:47:05 <lambdabot> Not in scope: `prod'
06:47:08 <vixey> Larose: does that make sense?
06:47:10 <vixey> @src iterate
06:47:10 <lambdabot> iterate f x =  x : iterate f (f x)
06:47:13 <ehird> :t prod = nub [a*b | a <- prod, b <- prod]
06:47:15 <lambdabot> parse error on input `='
06:47:20 <ehird> :t \prod -> nub [a*b | a <- prod, b <- prod]
06:47:22 <lambdabot> forall t. (Num t) => [t] -> [t]
06:47:28 <ehird> :t let prod = nub [a*b | a <- prod, b <- prod] in prod
06:47:30 <lambdabot> forall t. (Num t) => [t]
06:47:33 <ehird> > let prod = nub [a*b | a <- prod, b <- prod] in prod
06:47:40 <nomeata> @pl let  prod = nub [a*b | a <- prod, b <- prod] in prod
06:47:40 <lambdabot> fix (nub . ap ((:) . (a *) . ((b | a) <-)) (return . (b <-)))
06:47:42 <vixey> Larose: By the way * multiplies things, it doesn't pair tem
06:47:49 <lambdabot>  thread killed
06:48:00 <ehird> vixey: I imagine he knows that.
06:48:20 <ehird>  (b <-)
06:48:22 <ehird> does that WORK?!
06:48:25 <ehird> :t (<-)
06:48:27 <lambdabot> parse error on input `<-'
06:48:34 <lilac> Larose: try something like "nub (foldl (*) (combinations n prod))" for an appropriately defined combinations function
06:48:47 <vixey> Does anyone have a short lazy evaluator in Haskell which does some sharing?
06:49:00 <mux> no it does not, though this has been suggested as an extension
06:49:01 <nomeata> @pl let mult prod = nub (concatMap (\a -> concatMap (\b -> a*b) prod) prod) in mult
06:49:01 <lambdabot> nub . ((=<<) =<< (. (*)) . (>>=))
06:49:12 <nomeata> wow, that’s alsmost ascii-art
06:49:13 <ehird> mux: I can't think of a type for (<-)
06:49:16 <ehird> I don't think it Makes Sense.
06:49:28 <nomeata> (<-) is a @pl bug with list comprehensions, afaik
06:49:32 <mux> the @pl plugin doesn't really understand stuff, it just rewrites stuff
06:49:46 <mux> so it took this has an operator, that's all
06:49:54 <lilac> Larose: something like "combinations 0 xs = []; combinations n+1 x:xs = map (x:) (combinations n xs) ++ combinations (n+1) xs"
06:50:08 <mux> ehird: it would be syntax
06:50:20 <mux> but I don't like that idea much anyways
06:50:22 <ehird> mux: that's lame
06:50:44 <ehird> nomeata: a @pl bug? unpossible!
06:51:07 <Larose> thanks!
06:52:04 <vixey> there's stuff like mini haskell
06:52:23 <lilac> Larose: you can probably make "combinations" quicker by keeping track of length xs and short-circuiting in the case of combinations n xs | n == length xs
06:52:45 <mux> ehird: *shrugs* the do notation is already syntax
06:52:55 <Saizan> vixey: there's hhi which works by translating to SKI (and other combinators=
06:53:18 <vixey> Saizan: cool! thanks
06:54:14 <Saizan> there's an article on it in a recent The Monad.Reader
06:54:42 <vixey> great
06:55:22 <vixey> ?users
06:55:22 <lambdabot> Maximum users seen in #haskell: 463, currently: 443 (95.7%), active: 16 (3.6%)
06:55:37 <vixey> I really want to see it hit 500
06:55:49 <ehird> vixey: I could put a botnet in here.
06:56:06 <frwmanners> Larose: combinations n = map (take n) . permutations  might also work
06:56:27 <nomeata> uh, this SimpleReflexion stuff is nice:
06:56:29 <nomeata> > y + fix f
06:56:30 <lambdabot>  y + f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
06:56:55 <frwmanners> @src fix
06:56:55 <lambdabot> fix f = let x = f x in x
06:57:49 <nomeata> It’s strange. You tell lambdabot to fix it, but then:
06:57:50 <nomeata> > fix id
06:58:06 <lambdabot>  thread killed
06:58:20 <nomeata> Not a nice way to fix things.
06:59:03 <vixey> >foldr g z (iterate f x)
06:59:06 <vixey> > foldr g z (iterate f x)
06:59:07 <lambdabot>  g x (g (f x) (g (f (f x)) (g (f (f (f x))) (g (f (f (f (f x)))) (g (f (f (f ...
06:59:13 <mux> > fix (\f x -> if x == 0 then 1 else x * f (x - 1)) 3
06:59:14 <lambdabot>  6
06:59:20 <mux> > fix (\f x -> if x == 0 then 1 else x * f (x - 1)) 4
06:59:21 <lambdabot>  24
06:59:49 <vixey> > foldr ((:).sum) 0 (iterate (1:) 0)
06:59:50 <lambdabot>   add an instance declaration for (Num [a])
06:59:53 <vixey> > foldr ((:).sum) [] (iterate (1:) 0)
06:59:54 <lambdabot>   add an instance declaration for (Num [a])
07:00:08 <vixey> > foldr (\x y->sum x:y) [] (iterate (1:) 0)
07:00:09 <lambdabot>   add an instance declaration for (Num [a])
07:00:21 <vixey> > iterate (1:) 0
07:00:22 <lambdabot>   add an instance declaration for (Num [t])
07:00:36 <vixey> > foldr ((:).sum) 0 (iterate (1:) [])
07:00:37 <lambdabot>   add an instance declaration for (Num [a])
07:00:49 <shubuntu> hey Saizan
07:00:55 <shubuntu> little help?:P
07:01:37 <Saizan> you shouldn't count on my help :)
07:01:39 <ehird> > let x = 45 in x-x
07:01:41 <lambdabot>  0
07:01:51 <shubuntu> lol why not
07:02:22 <shubuntu> ok i need to write the put function the smart way
07:02:46 <shubuntu> put :: Stone -> Coord -> Board -> Board
07:02:47 <shubuntu> put stone place board =
07:02:51 <shubuntu> can i say
07:03:50 <shubuntu> put stone (x,y) board = board | (board !! y ) !! x = stone
07:04:10 <Saizan> no :)
07:04:19 <dcoutts> nomeata: is your blog syndicated on planet.haskell.org?
07:04:25 <shubuntu> ugh what kinda insert function is there to use
07:04:41 <nomeata> dcoutts: yes
07:05:00 <shubuntu> really difficult to get syntax of haskell
07:05:07 <Saizan> shubuntu: there's no insertAt function in the libraries, but you can easily write one with splitAt
07:05:18 <dcoutts> nomeata: oh yes, and planet just updated :-)
07:05:37 <shubuntu> i want something efficient
07:05:38 <nomeata> shubuntu: or use "Map Coord Stone" instead of lists, then you have update functions.
07:05:49 <nomeata> shubuntu: or use arrays
07:05:58 <shubuntu> well the data types are set
07:05:59 <Saizan> shubuntu: assignments of that sort are not contemplated in haskell, you must use constructors to produce values
07:06:23 <chessguy> shubuntu: stone?
07:06:28 <chessguy> switched to go, have we?
07:06:40 <shubuntu> hey chessguy
07:06:49 <shubuntu> i'm doing the othello part
07:06:49 <lilac> > fix (0+)
07:07:00 <shubuntu> chess is finished
07:07:04 <lambdabot>  thread killed
07:07:07 <chessguy> oh really? it works?
07:07:13 <shubuntu> yep
07:07:22 <chessguy> with ai and everything?
07:07:49 <shubuntu> i haven't hooked it to graphics yet if that's what you're asking for
07:07:58 <shubuntu> but yeah the multiplayer works
07:07:58 <chessguy> ai has nothing to do with graphics
07:08:07 <shubuntu> you said everything
07:08:10 <shubuntu> lol
07:08:19 <shubuntu> ai is almost done
07:08:19 <chessguy> does ai work?
07:08:24 <chessguy> hm
07:08:38 <chessguy> what algorithm did you use?
07:09:13 <chessguy> (for the ai)
07:09:16 <shubuntu> alpha-beta
07:09:32 <chessguy> how many moves deep are you searching?
07:10:08 <shubuntu> i'm doing a bruteforce over leafs
07:10:14 <shubuntu> and evaluate highest points
07:10:26 <chessguy> well yeah, but you must cut off at a certain depth
07:12:26 <chessguy> is the code available somewhere?
07:14:46 <chessguy> (crickets chirping)
07:14:49 <vixey> that's insane
07:14:58 <vixey> hhi is faster than GHCi ?
07:15:16 <vixey> http://www.haskell.org/sitewiki/images/0/0a/TMR-Issue10.pdf
07:24:13 <vixey> the fold for a GADT might need explicit foralls in the type?
07:28:33 <SamB> vixey: wait until you see the fold for a dependant data type!
07:28:44 <SamB> or wait, probably you already have ;-P
07:29:02 <orbitz> SamB: top of the morning to you!
07:29:16 <SamB> orbitz: greetings
07:29:20 <orbitz> hi
07:29:28 <ehird> oh my god. Someone ought to make a subset-of-haskell -> type-system compiler.
07:29:41 * orbitz need sto think of osmething personnaly useful to writ ein haskell
07:29:57 <orbitz> ehird: what do you mean?
07:29:58 <SamB> ehird: we could start with a Haskell -> Prolog compiler?
07:30:19 <ehird> SamB: heh, that's the boring way
07:30:20 <ehird> :)
07:30:33 <ehird> I wanna see thunks in prolog though!
07:30:45 <SamB> ehird: why is that boring? you should know by now that typeclass prolog is the way to do computation in the typesystem
07:30:58 <ehird> SamB: no
07:30:58 <vixey> mmm
07:30:59 <ehird> magic is the way
07:31:10 <vixey> I think that dependant types they are much more uniform and simpler than GADT
07:31:33 <vixey> maybe I'm wrong .. I don't understand all these initial algebra carrier semantics stuff :S
07:31:36 <SamB> vixey: certainly!
07:31:50 <vixey> but type theory is just a handful of axoims :)
07:31:58 <augustss> GADTs are orthogonal to dependent types
07:32:16 <SamB> augustss: are they now?
07:32:23 <vixey> I don't really know what that means
07:32:38 <augustss> SamB: You can have them with and without dependent types
07:32:51 <SamB> augustss: I honestly can't imagine using a dependently typed language without GADTs
07:33:00 <augustss> And if you have dependent types you can have GADTs or not
07:33:05 <Philippa> SamB: it's much like using a typed language without ADTs
07:33:14 <SamB> AHHH! the horror!
07:33:30 <augustss> Cayenne doesn't have GADTs
07:33:35 <Philippa> hell, Coq doesn't "have GADTs"
07:33:43 <SamB> Philippa: doesn't it?
07:33:44 <augustss> right
07:33:48 <SamB> are you CERTAIN?
07:33:49 <Philippa> SamB: not in the core language, no
07:34:08 <SamB> what are those inductive types then?
07:34:26 <augustss> They add no theoretical power
07:34:41 <SamB> I never said they added theoretical power
07:35:13 <Philippa> SamB: they're cute sugar. But you build an induction principle fresh for each one
07:35:18 <ehird> why does my system.filepath not have normalize?
07:35:18 <augustss> Pure Calculus of Constructions doesn't have them
07:35:41 <SamB> yes, but I can't imagine actually writing programs in the CoC ;-)
07:36:15 <vixey> cool
07:36:16 * SamB wonders what Martin-Lof is
07:36:17 <schme2> Hmm.. I just reached the file io bit in this here haskell book and I was wondering if there is a way to avoid having to do inh <- openFile .....    stuffstuffstuffit ... hClose inh   . I mean why the close?
07:36:17 <Philippa> augustss: on a completely unrelated note, has much been done on (partial!) type inference for PTSes?
07:36:28 <Philippa> (or well-defined subsets that aren't the lambda cube or smaller)
07:36:31 <augustss> Philippa: I don't know
07:36:36 <Botje> schme2: because leaving open files is Bad(tm)
07:36:37 <vixey> isn't Martin-Lof, CoC with Type : Type ?
07:36:45 <SamB> vixey: that can't be it
07:36:49 <schme2> Botje: Yes. I was wondering if there was not a better way to do it in haskell.
07:36:59 <Botje> there's the bracket function
07:37:02 <SamB> since Agda claims to be Martin-Lof, and doesn't default to Type : Type
07:37:05 <Philippa> augustss: ah well, I should poke around at some point
07:37:06 <augustss> vixey: M-L hasn't had Type:Type since the 70s
07:37:11 <schme2> Botje: What's that?
07:37:30 <SamB> (though of course it would be Set : Set for Agda...)
07:37:37 <Botje> bracket (openFile "foo") (hClose) $ \file -> do ...
07:37:39 <augustss> Per took that away when Girard discovered his paradox
07:37:55 <Botje> bracket guarantees the hclose gets executed no matter what
07:38:03 <Botje> and in the \file -> do block you do what you want with the file
07:38:23 * SamB hopes that a usable alternative is implemented in Agda soon
07:38:35 <SamB> (to Set : Set)
07:38:44 <noecksit> hello, i have a question on threads, i posted my code at hpaste.org/7678
07:38:57 <schme2> Botje: Great. I was looking for something of CL's WITH-OPEN-FILE macro and that bracket thing seems like it would work.
07:39:01 <Botje> so you could write "withFile foo = bracket (openFile foo) hClose
07:39:20 <schme2> Botje: Esselent. Thanks.
07:39:32 <noecksit> im not sure on line 86 how to save tid so i can access it later on with killThread
07:39:37 <Botje> and finally: withFile "/etc/passwd" $ \f -> mapM_ print =<< hGetContents c
07:39:44 <SamB> wow, that is pithy
07:40:04 <augustss> SamB: Agda2 has a flag for Set:Set since a few days back
07:40:08 <schme2> Botje: I can paste my /etc/passwd on a pastebin if you are interested.
07:40:11 <noecksit> id probably have to use some StateT monad, but the thing is that there is no initial state
07:40:14 <SamB> augustss: well, yes, that's okay for now
07:40:15 <Botje> schme2: not really ;)
07:40:29 <schme2> Botje: It's all x anyway.
07:40:31 <augustss> SamB: Until someone implements the universe consistency check
07:40:37 <vixey> so how do you synthesize the fold for any GADT?
07:40:43 <noecksit> i need to access the tid in line 90
07:40:45 <SamB> augustss: and I admit that it seems highly unlikely that I will accidentally invoke the paradox
07:40:48 <Botje> noecksit: you can always use an IORef
07:41:15 <lilac> > unsafePerformIO $ hGetContents $ openFile "/etc/password"
07:41:15 <lambdabot>   Not in scope: `openFile'
07:41:16 <noecksit> Botje: oh, ive never used that, what is it for?
07:41:17 <augustss> SamB: but the library comes with a version of the paradox :)
07:41:18 <SamB> but it is just a stopgap, and obviously not something that the libraries may use
07:41:25 <Botje> noecksit: it's a mutable reference
07:41:33 <Botje> what other languages call (*shudder*) a variable :)
07:41:35 <ehird> :\
07:41:54 <SamB> augustss: yes, but I'm not going to invoke that unless I really need to prove something HARD ;-)
07:42:01 <vixey> haha
07:42:02 <Botje> ref <- newIORef 0 :: IORef ThreadID
07:42:15 <Botje> then writeIORef ref tid
07:42:16 <augustss> SamB: exactly! :)
07:42:16 <SamB> augustss: hmm, how does the library do that without using the option???
07:42:25 <Botje> and tid <- readIORef ref
07:42:30 <Botje> in he appropriate places :)
07:42:48 <Philippa> SamB: You had a formulation that didn't need it, but the margin wasn't big enough?
07:42:49 <augustss> SamB: I'm sure that library module can only be compiled with the option on
07:42:53 <chessguy_> > 3 mod 2
07:42:53 <lambdabot>        add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
07:43:00 <chessguy_> @src mod
07:43:00 <lambdabot> Source not found.
07:43:03 <chessguy_> @type od
07:43:05 <lambdabot> Not in scope: `od'
07:43:05 <vixey> > 3`mod`2
07:43:06 <lambdabot>  1
07:43:07 <Botje> > 3 `mod` 2
07:43:08 <lambdabot>  1
07:43:10 <noecksit> Botje: yeah, a variable is exactly what i need
07:43:11 <Botje> damn!
07:43:15 <augustss> SamB: There is also a universe overflow bug that you can use
07:43:30 <SamB> augustss: ... woah
07:43:42 <SamB> augustss: they shoulda used Integer!
07:43:52 <augustss> Ulf is changing it.
07:45:20 <SamB> I don't suppose any of you can explain the error I get in Term.agda in the darcs repo http://naesten.dyndns.org:8080/repos/agda-lambda/ ?
07:46:28 <augustss> I doubt it, since I've never actually used Agda
07:46:48 <SamB> augustss: so why are you following the mailing list then?
07:47:01 <chessguy_> @type (-1)
07:47:03 <lambdabot> forall a. (Num a) => a
07:47:13 <chessguy_> (-1) `mod` 4
07:47:19 <Botje> anyone got a good reference for CPS conversion?
07:47:21 <SamB> in that case, you certainly seem unlikely to be able to help, since the message is most unhelpful ...
07:47:27 <chessguy_> > (-1) `mod` 4
07:47:28 <lambdabot>  3
07:47:29 <Botje> I left my "compiling with continuations" book at school :/
07:47:51 <augustss> SamB: because it interests me
07:47:58 <vixey> compiling with continuations is awesome
07:48:10 <vixey> Botje: by AppeL/
07:48:19 <Botje> yeah
07:48:31 <Botje> very awesome
07:49:53 <vixey> hm :[
07:51:18 <augustss> The book or the concept?
07:51:48 <vixey> both
07:52:06 <vincenz> I found the book dissapointing from a polish aspect
07:52:54 <Heffalump> do the Poles do compilation differently, then?
07:52:55 <Botje> i would've liked some more info on code generation, but meh
07:53:36 * vincenz coughs "pollish"?
07:53:52 <Heffalump> no, "polish" is the right spelling
07:54:03 <Heffalump> and the lack of capital letter disambiguates
07:54:09 <Heffalump> I was just being silly
07:55:09 <ehird> Anyone re: system.filepath?
07:55:30 <vincenz> Heffalump: I was pretty sure, but you had me doubting
07:56:46 <Heffalump> sorry :-)
07:56:51 <ehird> :\
07:56:54 <Philippa> vincenz: could you clarify a little for those of us who didn't 'get it' straight away?
07:57:17 <ehird> Philippa: polished
07:57:24 <ehird> the book wasn't polished enough, sez vincenz
07:57:32 <ehird> Heffalump joked it as 'from a Polish aspect'
07:58:06 <lilac> Heffalump: yes, the Poles to computation differently: they put the operator first
07:58:12 <Philippa> ah, thanks. Complete parsing failure on my part
07:58:21 <ehird> let's talk in polish english
07:58:26 <Philippa> probably because of... well, what lilac said
07:58:39 <ehird> let's talk in polish english        ... heh, that's already polish notation
07:58:41 <lilac> : ehird ok
07:58:53 <ehird> : lilac cool
07:59:19 <ehird> : forth this like looks ;
07:59:41 <lilac> : ehird is this ambiguous
08:00:19 <ehird> : lilac ? was that a question
08:00:26 <ehird> (english is pretty polish as it is .. hah!)
08:01:29 <lilac> : ehird exactly
08:02:06 <lilac> @hoogle [Either a b] -> ([a], [b])
08:02:06 <lambdabot> No matches, try a more general search
08:02:19 <ehird> : lilac anyway is ambiguous english
08:02:27 <lilac> :)
08:02:29 <ehird> : lilac like normal use ? for question
08:02:58 <ehird> :lilac more correct no space
08:03:24 <vixey> SamB: Is there some environment variable or something to tell Agda 2 where Data.Nat and all these are hidden away?
08:03:40 <vixey> (or do you just work in the same directory as those?)
08:04:21 <vixey> :t either
08:04:23 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
08:04:31 <vixey> :t first
08:04:33 <lambdabot> Not in scope: `first'
08:05:00 <vixey> :t (id &&& (1:))
08:05:01 <lambdabot> Not in scope: `&&&'
08:05:02 <vincenz> first :: a b c -> a (b,d) (c,d)
08:05:09 <vincenz> o.O
08:05:12 <vixey> it seems like lambabot is broken
08:05:13 <vixey> @unlet
08:05:14 <lambdabot> Defined.
08:05:15 <vincenz> Cale: why is lambabot missing Arrow?
08:05:16 <vixey> :t (id &&& (1:))
08:05:17 <lambdabot> forall t. (Num t) => [t] -> ([t], [t])
08:05:21 <vincenz> :t first
08:05:23 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
08:05:26 <vincenz> odd
08:05:38 <vixey> ahh ok
08:05:51 <Cale> odd indeed
08:05:52 <vincenz> for functions: (a -> b) -> (a,d) -> (b,d)
08:06:00 <vincenz> Cale: why would a @let block all of arrow?
08:06:07 <vixey> :t sequnce.repeat$((1:).)
08:06:08 <Cale> @undef
08:06:10 <lambdabot> Undefined.
08:06:26 <Cale> :t first
08:06:28 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
08:06:31 <ehird> @hoogle Either a b -> (a,b)
08:06:32 <lambdabot> No matches, try a more general search
08:06:41 <vincenz> ehird: that makes no sense
08:06:49 <ehird> vincenz: But of course not!
08:06:53 <ehird> Your point?
08:06:58 <vincenz> dunno?
08:07:04 <vincenz> ehird: why would you @hoogle for it?
08:07:14 <Cale> vincenz: If you make definitions with @let that break the module it's trying to load, you can end up having no imports.
08:07:23 <vincenz> Cale: oic
08:07:26 <ehird> vincenz: I @hoogle for impossible functions all day!
08:07:30 <Cale> (it's like when you load ghci on a broken module)
08:07:36 <vincenz> ehird: to prove False?
08:07:45 <ehird> vincenz: Yes!
08:09:33 <lilac> > foldr (either (first.(:)) (second.(:))) ([],[]) [Left 1, Left 2, Right 'a', Left 3, Right 'b']
08:09:35 <lambdabot>  ([1,2,3],"ab")
08:10:47 <sanity> so, if Haskell was created 20 years ago, what are programming language research people creating today?
08:10:57 <vincenz> sanity: Caleskell
08:11:01 <dejones> lol
08:11:07 <vincenz> :t (.)
08:11:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:11:30 <sanity> vincenz: do you have a URL for that?
08:11:54 <vixey> Does Caleskell have a new typeclass dispatch system?
08:12:04 <vincenz> sanity: irc.freenode.net/Cale
08:12:09 <paolino> we have a cage for vincenz
08:12:47 <chr1s> sanity: dependent types are hot research right now.
08:13:00 <Cale> sanity: He's at least half-joking. He's referring to some minor changes I made to Lambdabot's prelude.
08:13:08 <sanity> Cale: ah
08:13:11 <chr1s> dependently typed programming is like programming in Haskell, but better.
08:13:18 <vixey> chr1s: Better??
08:13:19 <vincenz> paolino: I fail to see where the cage comes in
08:13:23 <sanity> chr1s: is there an example of such a language you can point me to?
08:13:32 <chr1s> sanity: epigram or agda2
08:13:34 <sanity>  /ignore vincenz
08:13:34 <vixey> sanity: Coq
08:13:56 <Cale> sanity: There's still lots of research being poured into new features for Haskell.
08:14:08 <sanity> chr1s: which do you recommend I investigate first?
08:14:15 <vixey> chr1s: have you done much with any of these?
08:14:17 <vincenz> Cale: not to mention the runtime system improvements
08:14:43 <Cale> Indeed.
08:14:48 <chr1s> vixey: not too much, I'm writing a paper about some Agda-stuff, but I am certainly not an expert.
08:14:54 <schme2> What would be neat for Haskell, me thinks, is sexps and macros ;)
08:14:56 <dejones> does Haskell have any module introspection at run-time where you can see what functions are available and what other modules are imported?
08:15:07 <vincenz> schme2: look at "Liskell"
08:15:19 <chr1s> sanity: doesn't matter too much. maybe try to read a tutorial on programming with dependent types
08:15:22 <vincenz> schme2: it's a frontend that has lisp-style macros for haskell, tied in with GHC I believe
08:15:27 <sanity> chr1s: will do, thanks
08:15:30 <schme2> vincenz: I'll check it out. thanks.
08:15:40 <Cale> sanity: For the recent Haskell stuff, check out SPJ's papers here: http://research.microsoft.com/~simonpj/
08:15:40 <lambdabot> Title: Simon Peyton Jones
08:15:53 <Cale> (well, some of it anyway :)
08:15:58 <dejones> sanity: parallel programming is also very hot research now, and a big area that improvements have been made with Haskell.
08:16:27 <chr1s> sanity: you might find this interesting: http://www.cs.nott.ac.uk/~wss/Publications/ThePowerOfPi.pdf
08:16:28 <schme2> vincenz: looks mostly like new syntax from the page?
08:16:33 <SamB> vixey: M-x customize-group agda2
08:16:40 <sanity> chr1s: cool
08:16:46 <vincenz> schme2: well yes, basically a lisp-style syntax on topo, but that does give it macros and such
08:17:05 <schme2> hmm.
08:17:06 <sanity> on a different topic, anyone familiar with this work: http://www-users.cs.york.ac.uk/~ndm/supero/
08:17:07 <lambdabot> Title: Neil Mitchell - Supero
08:17:18 <vincenz> sanity: ndm hangs in this channel
08:17:20 <dejones> Hey Cale, does Haskell have any module introspection at run-time where you can see what functions are available and what other modules are imported?
08:17:26 <schme2> well looks neat. I'll howm it. Thank vincenz
08:17:38 <sanity> vincenz: cool, I've exchanged a few emails with it
08:17:43 <SamB> dejones: what do you think this is, Python?
08:17:44 <Cale> dejones: At runtime, no.
08:17:46 <sanity> vincenz: um, s/it/him
08:17:58 <dejones> SamB: lol, it is still helpful.  :)
08:17:59 <vincenz> :D
08:18:04 <Cale> dejones: compilation throws all that sort of thing away.
08:18:16 <SamB> dejones: what were you hoping to use it for?
08:18:20 <dejones> Cale: Ahh...
08:20:13 <dejones> SamB: Well, I was wanting to implement essentially the dispatcher in Ruby on Rails... they take a url, say http://foo.com/bar/blah and there is a config file that says if a url matches a particular pattern, then execute this class and method.
08:20:27 <dejones> bar is the class, blah is the method.
08:20:40 <SamB> dejones: hs-plugins or ghc-api might help
08:21:17 <dejones> SamB: Yah, I think they use the Ruby eval() to interpret the data as code.  ;)
08:22:00 <dejones> SamB: I guess really though for better efficiency I should just hard-code the pattern matching to particular functions...
08:25:00 <SamB> dejones: personally, I would think more about maintainability
08:25:43 <dejones> SamB: Well, it's a very small part of the overall project.. so I am thinking that I can hard-code it to test the other parts, then later build the better system.
08:25:47 <ehird> Anyone know about my System.FilePath?
08:26:24 <schme2> my gosh. Finally an example of why lazyness can be a good thing. Yay for real world haskell.
08:26:38 <dejones> SamB: But, I agree that eventually I'll have to fix it.  :)
08:26:42 <dcoutts> ehird: what version have you got?
08:27:10 <ehird> dcoutts: The Glorious Glasgow Haskell Compilation System, version 6.8.2
08:27:14 <SamB> dejones: well, note that hs-plugins and ghc-api also raise maintainability concerns ;-)
08:27:19 <dcoutts> ehird: I mean of filepath
08:27:26 <ehird> dcoutts: Oh. I don't know. :3
08:29:07 <dejones> SamB: True.  It needs more thought, but right now I'm not so interested in that part of the project.  ;) hehe.
08:30:17 <SamB> namely, they keep changing the API for ghc-api and hs-plugins always seems to break when a new GHC is released
08:30:23 <dcoutts> ehird: so?
08:30:43 <vixey> sorry SamB, I think it's too advanced for me to help
08:30:51 <ehird> dcoutts: Well. How do I tell?
08:31:14 <dcoutts> ehird: ah right :-) ghc-pkg list $pkgname
08:31:48 <ehird> /usr/local/lib/ghc-6.8.2/package.conf:
08:31:49 <ehird>     filepath-1.1.0.0
08:31:51 <dcoutts> ehird: normalise is exported by System.FilePath (and .Posix and .Windows) in filepath-1.1.0.0
08:32:10 <dcoutts> @hoogle normalise
08:32:10 <lambdabot> System.FilePath.Windows.normalise :: FilePath -> FilePath
08:32:10 <lambdabot> System.FilePath.Posix.normalise :: FilePath -> FilePath
08:32:19 <ehird> dcoutts: I find issue with your statement.
08:32:23 <ehird> Prelude System.FilePath> normalize "a"
08:32:23 <ehird> <interactive>:1:0: Not in scope: `normalize'
08:32:24 <Baughn> schme2: Finally? I take advantage of laziness /all the time/, to mutate structures without mutating
08:32:33 <dcoutts> ehird: spelling
08:32:59 <ehird> dcoutts: O.
08:33:05 <dcoutts> ;-)
08:33:17 <ehird> Prelude System.FilePath> normalise "a/../b"
08:33:17 <ehird> "a/../b"
08:33:18 <ehird> wtfoo :|
08:33:26 <ehird> that should be a/b.
08:34:07 <Lemmih> ehird: .. is not .
08:34:37 <ehird> Lemmih: oh. oops.
08:34:40 <ehird> It should be b, i mean.
08:34:46 <ehird> normalize "a/../b" -> "b"
08:34:59 <vincenz> nt true on linux
08:35:13 <vincenz> if a is a symlink, I don't think that holds
08:35:16 <dejones> SamB: So, if I know all the functions that I am interested in executing are within a single directory, I could read each file and get the module name and what functions are exported at run-time, then generate the Haskell code to execute the particular functions based upon the patterns put in a config file...  That seem more reasonable?
08:35:25 <ehird> vincenz: Yes well.
08:35:32 <Baughn> vincenz: bash does all sorts of magic to /make/ it hold, but yes, not really
08:35:50 <SamB> dejones: I'm not sure what's the best way to do what you want
08:36:18 <dejones> SamB: Yah, me neither... just bouncing ideas off of you.  ;)
08:36:50 <dcoutts> ehird: yep, it's a design decision and part of the filepath spec, check the docs for normalise
08:37:01 <ehird> dcoutts: Fsck design decisions. :P
08:37:04 <dcoutts> it gives a couple examples with ..
08:37:11 <SamB> dejones: you could do something involving extraction of the information from the source files, yes...
08:37:25 <dcoutts> ehird: as people have said, the problem is it doesn't hold in general
08:37:28 <SamB> that would probably be pretty maintainable
08:38:28 <dejones> SamB: Yah, that's the best idea I can think of the moment that doesn't make me dependent upon other plugins and also generates code only one time.
08:38:36 <dejones> :)
08:39:51 <dcoutts> ehird: there's also canonicalizePath and makeRelative
08:40:38 <dcoutts> ehird: the difference is that canonicalizePath is in IO so can actually look at the filesystem
08:40:58 <ehird> dcoutts: yeah, I guess I could do canonicalizePath+makeRelativeToCurrentDirectory
08:41:02 <ehird> just seems like a hack though.
08:47:57 <sw17ch> so, i'm looking at the output of ghc-core on the Fibonacci example, and i'm meeting syntax i've not met before...
08:48:16 <ehird> normalizeToCurrentDirectory -- better name anyone?
08:49:25 <dejones> All modules that you want to import must be in the same directory?
08:49:33 <Lemmih> normaliseToCurrentDirectory, perhaps.
08:50:03 <dejones> Is there no way to split up the directories with different files that are logically separate and import them?
08:50:21 <sw17ch> when i see something like 'a1 = : @ Int a a2', is any one familiar with what's happening there?
08:50:51 <dejones> nevermind, I found it.  :)  http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#OPTIONS-FINDING-IMPORTS
08:50:52 <lambdabot> Title: 5.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
08:50:59 <Saizan> sw17ch: that you're creating an [Int]
08:51:01 <Lemmih> sw17ch: a1 = (a::Int) : a2
08:52:22 <Saizan> sw17ch: (:) :: forall a. a -> [a] -> [a], (:) @ Int :: Int -> [Int] -> [Int]
08:53:28 <sw17ch> what is the '@'?
08:53:40 <sw17ch> is it naming the pattern to the right?
08:54:08 <Lemmih> sw17ch: It has nothing to do with at-patterns.
08:54:26 <sw17ch> Lemmih, i didn't think so... what does it have to do with?
08:54:31 <twanvl> In ghc core, @ is type application
08:54:38 <Lemmih> sw17ch: See Saizan last message.
08:55:46 <sw17ch> well, i suppose this is magic i should dabble in a bit slower then...
08:56:00 <Saizan> sw17ch: in core you've(?) to specialize a polymorphic function by telling it what type substitute at the type variables
08:56:30 <sw17ch> ahh... i was curious where that happened
08:57:01 <sw17ch> so, each use of a polymorphic function needs to have a type substitution defined somewhere?
08:57:15 <sw17ch> each use of a polymorphic function with a different type, that is
08:57:55 <mar77a> is YAHT a good place to start?
08:57:55 <Saizan> sw17ch: well (@ Int) is what makes that substitution, which is more like an assignment
08:58:44 <sw17ch> Saizan, well, with the (:) example, if i'm building lists of Int's and Char's, i need an (@ Int) for the Int usage, and an (@ Char) with the Char usage... correct?
08:59:38 <Saizan> correct, like ": @ Char c cs" will typecheck only if c :: Char and cs :: [Char]
09:01:07 <dejones> mar77a: Yes, I think so.  I used a combination of sources to help me learn Haskell: YAHT, Haskell School of Expression, Advanced Functional Programming Course at Chalmers (online docs), and Real-World Haskell (beta book).
09:01:13 <sw17ch> oh alright, this is much clearer now.. .thanks :)
09:01:24 <Saizan> sw17ch: in fact polymorphic functions are represented as functions that take a type as parameter. e.g. id = \(a :: *) (x :: a) -> x, id :: forall a. a -> a
09:02:56 <sw17ch> slick
09:27:08 <chessguy> anybody know if there is an iterative version of alphabeta?
09:28:02 <Heffalump> in what sense? Specific code to do it?
09:28:24 <Heffalump> you'd need to maintain a queue, so it still wouldn't run in constant space without quite a lot of trickery.
09:30:11 <chessguy> yeah
09:30:38 <chessguy> but i want to try to do it without recursion, if possible
09:34:39 <lilac> what is alphabeta?
09:35:23 <lilac> alpha-beta pruning?
09:36:03 <chessguy> yes
09:42:11 <gwern> @seen nomeata
09:42:11 <lambdabot> I saw nomeata leaving #darcs, #xmonad and #haskell 2h 35m 51s ago, and .
09:43:36 <gwern> @ask nomeata could you add some license info for FrakView? I would fain package it up like I did nymphaea, but not without knowing whether it's Free or not
09:43:37 <lambdabot> Consider it noted.
09:45:23 <patco444> One very interesting game for the maniacs that are playing strategies or RPG, so if you want to take part in this game skype : patco444 ... http://www.fallensword.com/?ref=1461055
09:46:55 <ehird> Lulz.
09:49:44 <gwern> spammers, bleh
09:52:17 <ehird> normalizeToCurrentDirectory fp = do
09:52:17 <ehird>   canon <- canonicalizePath fp
09:52:17 <ehird>   makeRelativeToCurrentDirectory canon
09:52:20 <ehird> Dis name. It is dis suxor.
09:52:27 <ehird> Who can think of a better one?
09:53:42 <MyCatVerbs> normalizeAgainstCWD ?
09:53:59 <dancor> i'm trying to figure out why join (,) x == (x, x), so i'm trying to see how ((,) a) is a Monad.  i don't see anything near http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#Monad.  is something more internal?
09:54:00 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/3dzxqb
09:54:25 <sclv> dancor: it has nothing to do with ((,) a) as a monad
09:54:38 <vixey> dancor: It's the (->)a monad
09:54:38 <sclv> its just the reader monad, unwrapped.
09:54:47 <sclv> its in control.monad.instances, as i recall
09:54:57 <sclv> > join (*) 4
09:55:00 <lambdabot>  16
09:55:03 <vixey> :t join :: (a -> a -> b) -> (a -> b)
09:55:05 <lambdabot> forall a b. (a -> a -> b) -> a -> b
09:55:59 <sclv> a function of type a->b is in the unwrapped reader monad of ((->) a)
09:56:34 <sclv> bind is compose, return is const.
09:56:50 <Saizan> ?src (->) >>=
09:56:50 <lambdabot> Source not found. You untyped fool!
09:56:57 <Saizan> ?src (->) (>>=)
09:56:58 <lambdabot> f >>= k = \ r -> k (f r) r
09:57:00 <sclv> and join takes a function requiring 2 as and feeds a single a in as both.
09:57:24 <ehird> <MyCatVerbs> normalizeAgainstCWD ?
09:57:27 <sclv> oh right, bind is a bit more complicated than compose. sorry for the confusion.
09:57:28 <ehird> that's not conventional
09:57:31 <ehird> at least I have never seen it
09:57:43 <Saizan> fmap is composition
09:58:04 <sclv> there we go
09:58:07 <ehird> :t join
09:58:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:58:10 <Jaak> @dijin (a -> a -> b) -> (a -> b)
09:58:10 <lambdabot> f a b = a b b
09:58:24 <ehird> @src join
09:58:24 <lambdabot> join x =  x >>= id
09:58:32 <ehird> didn't know that was stand-uhd
09:58:35 <ehird> @src getContents
09:58:35 <lambdabot> getContents = hGetContents stdin
09:58:36 <ehird> @src hGetContents
09:58:37 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:00:39 <lilac> is the compiler allowed to transform a non-terminating program into a terminating one?
10:01:35 <lilac> eg, in f :: (), f = f, may the compiler say f = ()?
10:02:13 <sclv> ?ty let f = f in f
10:02:14 <lambdabot> forall t. t
10:02:47 <MyCatVerbs> ehird: cwd is a Unix-ism for current directory. None of the rest comes from anywhere. :P
10:03:14 <ehird> MyCatVerbs: I know.
10:03:21 <dcoutts> lilac: no
10:03:29 <ehird> lilac: no
10:03:39 <ehird> that doesn't even make SENSE
10:03:42 <ehird> esp. due to turing
10:03:47 <ehird> (F*ck you, turing.)
10:04:10 <dcoutts> lilac: though bytestring fusion does sometimes do program refinements (ie make things more terminating)
10:05:27 <dejones> is there a Haskell function similar to map that I could use to print "IO [Filepath]" essentially I want to print the files found from a directory...
10:05:40 <dejones> with putStrLn
10:05:45 <sclv> ?ty mapM_
10:05:46 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
10:06:03 <sclv> ?ty mapM_ putStrLn
10:06:05 <lambdabot> [String] -> IO ()
10:06:07 <dejones> ty!
10:06:21 <lilac> ehird: in cases where a type has only one non-bottom value, it's a well-defined transformation which can only make programs terminate more. if you equate bottom with undefined behaviour rather than with non-termination, it's even semantics-preserving
10:06:26 <dejones> sclv: thanks.  :)  I forgot all about the maps for monads.
10:06:36 <dejones> that worked, heh
10:06:43 <ehird> lilac: it's also pretty pointless.
10:07:01 <lilac> ehird: arguably :)
10:07:06 <Saizan> lilac: with GADTs you introduce unsoundness in the type system
10:07:22 <thetallguy> cnet now has an international edition
10:07:34 <thetallguy> D'oh!  Wrong channel, sorry
10:08:50 <SamB> what definition of termination are we using?
10:10:23 <ehird> SamB: (== magic)
10:10:56 <MyCatVerbs> ehird: hey, hey, no need to rag on Turing like that.
10:11:13 <MyCatVerbs> ehird: Church proved the same result, albeit in a different manner, y'know.
10:11:27 <ehird> MyCatVerbs: <_<
10:11:57 <MyCatVerbs> ehird: plus, if you think about it carefully, it's looks really similar to Russel's paradox turned sideways and squinted-at.
10:12:13 <MyCatVerbs> *Russell's paradox, oops.
10:13:00 <ehird> Hmmmmmmm.
10:13:08 <ehird> Is there a darcs API that I can use from haskell?
10:13:39 <lilac> ehird: anyway, turing doesn't show that a program can't compute non-termination ever, just that it can't do it in the general case.
10:14:43 <SamB> termination is semi-decidable
10:14:50 <dancor> otherwise we wouldn't be able to see that f = f doesn't terminate (as turning machines ourselves)
10:14:55 <MyCatVerbs> SamB: recognisable, you mean?
10:15:09 <SamB> I meant what I said!!
10:15:11 <lilac> semi-decidable is correct
10:15:35 <lilac> just run it!
10:15:37 <MyCatVerbs> Just wondering, hadn't heard that term before. Always heard it called recognisable.
10:16:06 <roconnor> > let f = f in f
10:16:22 <lambdabot>  thread killed
10:16:47 <SamB> just like disequality is semi-decidable on the reals
10:16:48 <roconnor> lambdabot: are you seriously that dumb?
10:16:57 <qebab> I think I am finally starting to get Haskell \o/
10:17:09 <dolio> > let f = f in f
10:17:23 <qebab> in memory of all the headaches that have been, I am going to reward myself with a beer.
10:17:24 <lambdabot>  thread killed
10:17:43 <SamB> qebab: to give yourself another headache?
10:17:50 <lilac> MyCatVerbs: in uni i always heard it called recursively enumerable, but i was a mathematician, not a compsci
10:17:53 <qebab> SamB: something like that
10:17:58 <roconnor> *sigh*
10:18:03 <roconnor> where is my loop exception?
10:18:06 <dolio> > 2 + 2
10:18:08 <lambdabot>  4
10:18:33 <dolio> > fix id
10:18:34 <lambdabot>  ghc: failed with error code 15
10:18:39 <qebab> this is sort of like when I got lisp, only it took a lot more work and seems a bit more rewarding in the end
10:18:43 <dolio> Hmm...
10:18:46 <chessguy> @docs
10:18:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
10:21:33 <MyCatVerbs> lilac: bah. Terminology in computablity is like keyboard shortcuts in browsers and email clients.
10:22:43 <MyCatVerbs> lilac: much more difficult to get people to stop using a particular term than to get them to start. Hence, eventually the field will eventually take over the entire dictionary, if given long enough.
10:23:03 <lilac> MyCatVerbs: :)
10:23:15 <MyCatVerbs> lilac: Just like how, one day in the distant future, every single key on your keyboard will cause firefox to select the address bar.
10:23:18 <ehird> qebab: I don't think a beer will help you learn haskell
10:23:18 <ehird> :)
10:23:35 <ehird> roconnor: yeah, <<loop>> is kinda a toy.
10:23:37 <atsampson> MyCatVerbs: no, Firefox's keyboard behaviour will never be that consistent.
10:23:44 <lilac> MyCatVerbs: I suspect the trouble is, the terms start off different, and then inconsiderate people go and prove them equivalent
10:23:47 <ehird> roconnor: it seems like a "heh, we can detect up to 3 cases of non-termination. cute"
10:24:10 <ehird> <MyCatVerbs> lilac: Just like how, one day in the distant future, every single key on your keyboard will cause firefox to select the address bar.
10:24:11 <MyCatVerbs> atsampson: whaddaya mean? control+l, F6, alt+d, and those're only the ones I know of. It's going that way, comrade.
10:24:14 <ehird> that will be a virtuous day
10:24:26 <ehird> MyCatVerbs: he was joking
10:24:33 <ehird> MyCatVerbs: because firefox's keyboard handling is .. inconsistent
10:24:39 <atsampson> MyCatVerbs: I mean that every key will be *meant* to do that, but in practice they'll only work "most" of the time ;)
10:25:01 <MyCatVerbs> atsampson: ahhhh. I've, uh, never come across those bugs. (Or at least, if I did, I've forgotten them.)
10:25:22 <lilac> MyCatVerbs: for compatibility with Konqueror, they need to add Alt-L and Alt-O as well
10:25:41 <MyCatVerbs> Right. So every working key will take you to the address bar. The rest will take you to the search bar, unless it's Thursday. Firefox, like Arthur Dent, never could get the hang of Thursdays.
10:26:15 <MyCatVerbs> lilac: hrmn, alt-l and alt-o don't do anything on my (3.0b5) install. What're they meant to be for?
10:26:39 <lilac> taking you to the address bar, naturally ;-)
10:26:47 <ehird> MyCatVerbs: konqueror uses alt-l and alt-o
10:26:50 <ehird> so FF needs to add them
10:26:55 <ehird> is what lilac was saying
10:27:11 <noecksit> hello, what was the command on lambdabot to show monads without the do notation, in terms of >> and >>=?
10:27:22 <ehird> noecksit: undo
10:27:30 <MyCatVerbs> lilac: oh, sorry, misparsed there. Thought you said they already had, not needed to.
10:27:51 <MyCatVerbs> lilac: having five different keyboard shortcuts for the address bar is going to start feeling silly after a while, y'know.
10:27:56 <noecksit> undo do hClose $ socket st; putStrLn "disconnected"
10:28:02 <ehird> @und
10:28:03 <lambdabot> Maybe you meant: undefine undo
10:28:09 <ehird> @undo do hClose $ socket st; putStrLn "disconnected"
10:28:09 <lambdabot> hClose $ socket st >> putStrLn "disconnected"
10:28:10 <lilac> actually, it'd make some sense for any alphanum keypress to take you to the address bar if an edit box doesn't have focus...
10:28:13 <ehird> err
10:28:14 <ehird> that's broken
10:28:20 <ehird> hClose (socket st) >> putStrLn "disconnected"
10:28:21 <ehird> that's not
10:28:21 <ehird> :-)
10:28:51 <noecksit> oh, that matters?
10:29:12 <lilac> ($) has precedence 0
10:29:16 <ehird> noecksit: yeah
10:29:18 <ehird> that parses into:
10:29:25 <ehird> hClose (socket st >> putStrLn "disconnected")
10:29:30 <ehird> which is .. obviously not what you want.
10:29:30 <lilac> (>>) has precedence 1
10:29:41 <MyCatVerbs> lilac: no it wouldn't. Well, it would, but find-as-you-type already has precedence there.
10:29:54 <noecksit> ehird: oh ok, i didn't think of that
10:29:59 <MyCatVerbs> lilac: I kinda have a soft spot for that feature, myself, even if I don't use it all that much.
10:30:09 <lilac> MyCatVerbs: in FF and Konq you need to type / for find-as-you-type, no?
10:30:09 * MyCatVerbs pokes FF.
10:30:18 <MyCatVerbs> Wait, it doesn't actually do that now. Curses!
10:30:33 <ehird> Safari does it
10:30:34 <ehird> :3
10:30:48 <ehird> Safari's searching is also superior to firefox's in 3
10:30:51 <MyCatVerbs> ARGH. They copy VI's / shortcut, but then don't let you enter real regular expressions.
10:30:55 <atsampson> MyCatVerbs: there's a config option for it (accessibility.typeaheadfind.autostart) which I've also got turned off
10:31:10 <MyCatVerbs> To add insult to injury, you can't even hit ^M and then use n and N to flip through the results. :(
10:31:10 <SamB> I think there might be a "find link as you type" that is active without /
10:32:30 <qebab> @src foldr
10:32:30 <lambdabot> foldr f z []     = z
10:32:30 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:32:36 <MyCatVerbs> atsampson: ah, thank you. Nice.
10:32:51 <qebab> @src foldl
10:32:51 <lambdabot> foldl f z []     = z
10:32:51 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:34:52 <pergesu> I'm following the real world haskell book, and I'm having trouble defining multiple values with let.  I've stripped the function definition to the bare minimum I think... http://hpaste.org/7700  and when I try to load the file into ghci I get "add.hs:16:19: parse error on input `='"
10:34:58 <noecksit> idk if this is the right place to ask, but does anyone know the function that allows a leaf item to be grayed out so it can't be clicked on it GTK2HS?
10:35:04 <pergesu> I'm not sure what's wrong...it looks just like the lets I'm seeing everywhere via google
10:35:32 <Botje> pergesu: the r should line up with the n
10:35:41 <Botje> if you are using tabs, convert them to spaces
10:35:48 <MyCatVerbs> pergesu: confusing indentation, by the look of it.
10:36:20 <mar77a> is Floating included in Num
10:36:21 <Botje> http://hpaste.org/7700#a1
10:36:26 <Botje> (where's that damn hpaste gone again)
10:36:27 <Botje> mar77a: yes
10:36:31 <qebab> you should find a haskell aware editor that'll just do the indenting correctly for you :)
10:36:37 <mar77a> why is sqrt defined as Floating and not as Num
10:36:48 <ehird> mar77a: obvious reasons
10:36:58 <mar77a> care to elaborate?
10:37:12 <MyCatVerbs> mar77a: not all numerical types can nicely represent the result.
10:37:12 <Botje> mar77a: the answer is almost always a floating point number
10:37:13 <SamB> mar77a: ever try to take the sqrt of an Int?
10:37:14 <Valodim> because num is a subset of floating
10:37:34 <pergesu> Botje & MyCatVerbs: um, so you're right, it doesn't look like the examples I saw :)  thanks
10:37:54 <pergesu> qebab: I thought I was...I'm using emacs, and that's where it indented it.  However if I hit tab it cycles through possible indentations it seems
10:37:55 <mar77a> i thought Floating was a subset of Num
10:38:05 <conal> mar77a: i think it could have gone either way.
10:38:12 <conal> mar77a: (sqrt in Num or Floating)
10:38:17 <qebab> pergesu: yeah, it does
10:38:32 <SamB> God knows they have way too much in Num already
10:38:32 <MyCatVerbs> mar77a: in this case, they mean that the set of operations defined by Floating is strictly larger than the set of operations defined by Num.
10:38:36 <qebab> pergesu: it gets it right most of the time here though, on the first try
10:39:09 <conal> mar77a: sometimes a method is put in a smaller class in order to have properties that are true.  that's almost the case with sqrt: (sqrt x)^2 == x.  but that property isn't even true in Double.
10:39:28 <qebab> mar77a: I can't think of a practical way to calculate a square root without using division, and unless I'm very wrong I don't think that Num has that?
10:39:38 <conal> mar77a: my guess, though, is because the ideal sqrt does satisfy that property.
10:39:47 <qebab> I don't know these things though, so don't listen to me
10:39:48 <MyCatVerbs> mar77a: honestly though, the numerical stuff in the Prelude is considered annoying by an awful lot of people.
10:39:58 <MyCatVerbs> mar77a: you're by no means the first to find it a PITA.
10:40:09 <conal> qebab: still, an inefficient sqrt could be defined for Int and a more efficient for Float etc
10:40:11 <mar77a> PITA?
10:40:27 <MyCatVerbs> mar77a: pain in the, um, you can guess the last word.
10:40:27 <qebab> conal: true enough
10:40:51 <atsampson> MyCatVerbs: "arithmetic"
10:40:54 <qebab> is there a way for me to find out what a typeclass contains in ghci?
10:41:04 <SamB> :i
10:41:05 <MyCatVerbs> atsampson: ah, yes. Thanks for the save.
10:41:14 <qebab> SamB: thanks a lot :)
10:41:30 <conal> mar77a: one could define a higher-order function that would help: onFloat :: (Int -> Float) -> (Float -> Float) -> (Int -> Int).  then isqrt = onFloat sqrt.   then generalize from Int & from Float.
10:41:42 <noecksit> nvm, i found it
10:41:49 <Botje> .oO(liftFloat)
10:41:56 <conal> @type round
10:41:58 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
10:42:11 <conal> generalize onFloat to RealFrac
10:44:33 <mar77a> why can i do something like 'h':'i':" there" and not something like "hi ther":'e' or "hi ther":'e':[] ?
10:45:06 <SamB> @type (:)
10:45:08 <lambdabot> forall a. a -> [a] -> [a]
10:45:12 <SamB> mar77a: that's why
10:45:19 <mar77a> eh..
10:45:21 <saml> i have list of FilePath. how can I test one by one if it exists. and open the first file whiceh exists?
10:45:30 <saml> mapM doesFileExists paths
10:45:33 <SamB> @src String
10:45:33 <lambdabot> type String = [Char]
10:45:34 <gnuvince_> mar77a: you "push" an element of type a into a list of a's
10:46:11 <mar77a> oh
10:46:17 <mar77a> goes from left to right
10:46:43 <mar77a> can't push an [b] in a b
10:46:46 <mar77a> right?
10:46:53 <mar77a> a [b]*
10:49:08 <saml> > or [True, undefined]
10:49:10 <lambdabot>  True
10:49:49 <ehird> > and [True,False,undefined]
10:49:51 <lambdabot>  False
10:50:01 <ehird> Odd.
10:50:03 <Baughn> > [True,undefined,False]
10:50:04 <lambdabot>  [True,Exception: Prelude.undefined
10:50:05 <ehird> > False & & undefined
10:50:05 <lambdabot>  Parse error at "&" (column 9)
10:50:08 <ehird> > False && undefined
10:50:10 <lambdabot>  False
10:50:12 <ehird> O, ic.
10:50:27 <ehird> > and [True,False,undefined,True]
10:50:27 <saml> how can I return the first file that exists from a list of FilePath?
10:50:28 <lambdabot>  False
10:50:31 <ehird> > and [True,undefined,True]
10:50:32 <lambdabot>  Exception: Prelude.undefined
10:50:33 <ehird> @src and
10:50:34 <lambdabot> and   =  foldr (&&) True
10:50:36 <Baughn> > False && (error "er, what?")
10:50:37 <lambdabot>  False
10:50:43 <ehird> Baughn: Cute
10:51:04 <Baughn> ehird: The wonders of laziness. Of course this happens
10:51:27 * Baughn was actually confused for a moment
10:52:08 <schme2> Baughn: I am sure you've had much more time to find out good things about it :)
10:52:15 <schme2> Baughn: compared to me.
10:52:41 <Baughn> schme2: Sure. Good things: It gives you both usable, troublefree continuations and usable, troublefree mutations.
10:52:56 <Baughn> Though it isn't quite continuations, nor mutation. Close enough.
10:53:56 <Baughn> schme2: http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/16#fast <-- This one's very interesting
10:53:57 <schme2> hehehe.
10:53:57 <lambdabot> Title: Haskell hacking
10:54:07 <schme2> Yeah.. I might have to add it to my lisp :)
10:54:15 * schme2 looks at ze site.
10:54:56 <schme2> oh that one.
10:55:49 <SamB> Baughn: how in the world can you possibly have trouble-free mutations?
10:56:02 <nolrai_> Would bytestream be what i want if i want a effecient strict array of Bools?
10:56:09 <Baughn> SamB: By evaluating thunks. ;)
10:56:14 <mar77a> is there an un-let
10:56:19 <mar77a> that undefines a function
10:56:28 <SamB> mar77a: what the heck?
10:56:34 <Baughn> mar77a: In ghci? Or for lambdabot?
10:56:35 <ehird> mar77a: there's no mutation,
10:56:41 <ehird> mar77a: and it does not make sense anyway
10:56:42 <mar77a> ghci
10:56:45 <ehird> oh
10:56:49 <SamB> mar77a: reload something
10:56:54 <SamB> then everything goes bye-bye!
10:56:57 <Baughn> mar77a: re-let it to undefined
10:57:10 <SamB> Baughn: how will that help?
10:57:18 <Baughn> SamB: It won't
10:57:34 <mar77a> ah, doing :r cleared everything
10:57:35 <Baughn> Well, it'll leave the GC free to free whatever he let earlier
10:57:36 <mar77a> apparently
10:57:47 <Baughn> Which is the only /practical/ reason to want that..
10:58:05 <SamB> mar77a: see ;-)
10:58:15 <Baughn> mar77a: If you've done something like "let (+) = (*)", you could say let (+) = Prelude.(+)
10:58:37 <SamB> mar77a: many of us are liking to work in files
10:59:03 <Baughn> Well, (Prelude.+) anyhow
10:59:06 <mar77a> i don't like loading modules and stuff every time :<
10:59:07 <SamB> one nice benefit is that we can save it for later easily
10:59:31 <Baughn> Mm. It's inconvenient to keep too much stuff in ghci, for you will eventually need to restart.
10:59:51 * SamB sneaks up behind mar77a and turns off the computer
11:00:04 <mar77a> it's ok i'm just playing around
11:00:13 <SamB> okay then ;-)
11:04:40 <mar77a> what's the correct way to define an if using {} and ;
11:05:02 <mar77a> well, a conditional, rather
11:05:32 <vixey> > if True then { 1 + 2 + 3 } else undefined
11:05:32 <lambdabot>  Parse error at "{" (column 14)
11:05:37 <vixey> I guess you can't
11:05:59 <vixey> > if True then head (do { return (1 + 2 + 3) }) else undefined
11:06:00 <lambdabot>  6
11:06:34 <mar77a> i mean in a function definition, something like:
11:06:35 <ehird> vixey: err
11:06:35 <ehird> or
11:06:42 <ehird> > if True then head [1 + 2 + 3] else undefined
11:06:44 <lambdabot>  6
11:06:46 <ehird> JUST A THOUGHT.
11:07:08 <mar77a> > let sign x = {if x < 0 then -1; else if x > 0 then 1; else 0;}
11:07:09 <lambdabot>  Parse error at "{if" (column 14)
11:07:25 <mar77a> something like that :)
11:09:03 <maltem> mar77a: {} are syntax for do notation
11:09:18 <mar77a> can't do one line conditionals?
11:09:29 <maltem> mar77a: you don't use them in ordinary expressions
11:09:30 <nolrai_> >let sign x = if x < 0 then -1 else 0 in sign -2
11:09:39 <nolrai_> > let sign x = if x < 0 then -1 else 0 in sign -2
11:09:40 <lambdabot>   add an instance declaration for (Num (a -> a1))
11:10:10 <nolrai_> > let sign x = if x < 0 then (-1) else 0 in sign (-2)
11:10:12 <lambdabot>  -1
11:10:26 <nolrai_> like that.
11:10:29 <chessguy> @pl \f -> m f >> g
11:10:30 <lambdabot> (>> g) . m
11:10:30 <maltem> sigh. Haskell-98's unary minus is hell
11:10:38 <vixey> yes
11:12:51 <maltem> btw that's a very funny definition of signum :)
11:14:19 <SamB> I've had no issues with that in Agda! However, it is quite possible that this is because (a) I ave only used the nats (b) I avoid subtraction and (c) I don't know how to use sections, which were apparantly implemented only recently
11:15:36 <nolrai_> noone ever answered my question.  Is there haskell suport for implementing an array of bools as individual bits of one memory location??
11:16:10 <Lemmih> Of one memory location?
11:16:28 <Saizan> nolrai_: unboxed Bool arrays are bit-packed
11:16:36 <nolrai_> sweet
11:17:00 <Baughn> nolrai_: There is unboxed support for everything in http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-Unboxed.html
11:17:01 <lambdabot> http://tinyurl.com/2q5bxh
11:17:07 <SamB> Lemmih: I assume he meant "several in one memory location"
11:17:08 <Baughn> Mind you, you lose laziness like this
11:17:29 <SamB> well obviously you can't bitpack thunks ;-)
11:18:03 <vixey> hm why?
11:18:12 <SamB> vixey: what?
11:18:28 <vixey> I don't see why you couldn't serialize functions
11:18:31 <SamB> thunks take several words on the heap, and must be pointed at
11:18:54 <SamB> bitpacking refers to sqeezing multiple things into a single storage unit
11:19:05 <Lemmih> vixey: You need a bad-ass compression to store a pointer in a single bit.
11:19:08 <vixey> oh I think I understand
11:19:58 <SamB> for some reason, they won't let us use UArrays of Bool on the shootout :-(
11:20:03 <SamB> claim it's cheating or something
11:20:21 <juhe> Hello people, is there some other command line parsing module besides System.Console.GetOpt (which doesn't allow spaces between specifier and argument - i.e. "-t small" doesn't work, "-tsmall" works)?
11:21:30 <schme2>   Ok.. so with Real World Haskell here I'm lookin' at chapter 10 and it tells me to :module +Text.Regex.Posix . This, however, gives me Could not find module `Text.Regex.Posix' . Is my ghc install broken or what is going on here?
11:21:45 <Lemmih> juhe: "-tsmall" is "-t -s -m -a -l -l", I think.
11:22:09 <SamB> schme2: you probably need to install the package
11:22:10 <atsampson> Lemmih: not if t takes an argument...
11:22:22 <SamB> schme2: unfortunately I don't remember which one :-(
11:22:29 <atsampson> (i.e. if it's specified as "t:" in conventional getopt)
11:22:38 <schme2> SamB: ... ok.. so where does one find information on how to install packages and where to find 'em?
11:22:55 <SamB> schme2: how did you install GHC?
11:24:14 <schme2> SamB: ./configure && make install  IIRC
11:25:14 <schme2> SamB: Just like the installation instructions say ;)
11:25:47 <SamB> schme2: so you already had GHC installed?
11:25:52 <schme2> SamB: Yes.
11:26:11 <schme2> when I did the :module thing of course.
11:26:37 <lilac> has someone written a parser generator in template haskell
11:27:01 <SamB> schme2: well, you could use the ghc-extras tarball or whatever
11:27:27 <schme2> SamB: Ok.. I'll look to see if I can find that. thanks.
11:27:37 <SamB> perhaps ghc-extralibs
11:28:09 <schme2> SamB: any idea of where on haskell.org one would find it ? :P
11:28:15 <SamB> I think you untar it into the GHC tree and then just rebuild GHC...
11:28:22 <schme2> sounds great.
11:28:33 <schme2> well real life calls.
11:28:35 <schme2> ta ta :)
11:28:35 <SamB> schme2: or you could of course switch to your distros packages, if available...
11:28:47 <schme2> SamB: No such thing.
11:30:06 <schme2> Too bad the book has nothing on this :D
11:30:12 <schme2> oh pizza. :D
11:35:02 <mar77a> what is wrong with this definition of pow x y which computes x^y
11:35:05 <mar77a> pow x 1 = 1
11:35:06 <mar77a> pow x y = x * pow x (y-1)
11:35:19 <mar77a> it's computing correctly but x^(y-1)
11:35:24 <chessguy> @pl \u t -> e u' (f t 0)
11:35:25 <lambdabot> const (e u' . flip f 0)
11:35:32 <lilac> mar77a: x^1 /= 1
11:35:58 <mar77a> huh?
11:36:04 <mar77a> right
11:36:05 <lilac> line 1: pow x 1 = 1
11:36:09 <mar77a> hehe
11:36:12 <chessguy> @pl \t -> e u (f t 0)
11:36:12 <lambdabot> e u . flip f 0
11:36:23 <mar77a> ty
11:36:40 <lilac> mar77a: also, you know that pow = (^) ?
11:36:50 <mar77a> now i do
11:37:04 <lilac> :ty (^)
11:37:17 <lilac> @type (^)
11:37:19 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:37:22 <lilac> @type (**)
11:37:24 <lambdabot> forall a. (Floating a) => a -> a -> a
11:37:33 <lilac> > a ^ 5
11:37:34 <lambdabot>  a * a * (a * a) * a
11:38:30 <nolrai_> @ty a
11:38:32 <lambdabot> Expr
11:38:55 <vixey> > a ^ 98
11:38:56 <lambdabot>  a * a * (a * a) * (a * a * (a * a)) * (a * a * (a * a) * (a * a * (a * a))) ...
11:39:05 <vixey> I guess this is sharing?
11:39:11 <vixey> which is causing the bracketing
11:39:18 <vixey> could that be it?
11:39:22 <lilac> vixey: yep, divide-and-conquer implementation
11:39:28 <vixey> cool
11:39:39 <nolrai_> > a ^ 10
11:39:41 <lambdabot>  a * a * (a * a) * (a * a * (a * a)) * (a * a)
11:40:17 <vixey> > drop 50 $ show (a ^ 98)
11:40:18 <lambdabot>  "* a) * (a * a * (a * a))) * (a * a * (a * a) * (a * a * (a * a)) * (a * a *...
11:40:24 <vixey> > drop 100 $ show (a ^ 98)
11:40:25 <lambdabot>  "* a * (a * a)) * (a * a * (a * a) * (a * a * (a * a)))) * (a * a * (a * a) ...
11:40:53 <lilac> SimpleReflect is awesome, by the way...
11:41:09 <nolrai_> @src Expr
11:41:10 <lambdabot> Source not found. My pet ferret can type better than you!
11:41:24 <lilac> @src (^)
11:41:24 <lambdabot> Source not found. Maybe if you used more than just two fingers...
11:41:56 <sjanssen> lilac: yeah, that a ^ 98 example is pretty much amazing
11:42:06 <sjanssen> SimpleRefect++ ClassBasedOverloading++
11:43:47 <dons> mm, a fast md5.hs would be a nice follow up post.
11:43:47 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
11:44:12 <sjanssen> hmm, too bad it doesn't show the sharing
11:44:36 <dons> malcolmw: i've had a couple of reports that ghc-core doesn't build from hackage, due to hscolour failing
11:44:39 <dons> have you seen that?
11:46:40 <dcoutts> this calls for hackage build reporting!
11:51:29 <ehird> > fix (^) a
11:51:30 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
11:51:30 <lambdabot>     Probabl...
11:51:35 <ehird> oh oosp
11:51:53 <ehird> > iterate (^) a
11:51:54 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
11:51:54 <lambdabot>     Probabl...
11:52:02 <ehird> > iterate (join.(^)) a
11:52:03 <lambdabot>  Couldn't match expected type `b -> a' against inferred type `Expr'
11:52:08 <ehird> > iterate (join(^)) a
11:52:16 <ehird> > iterate (join(^)) a :: [Expr]
11:52:20 <ehird> I broke lambdabot :|
11:52:22 <lambdabot>  [a,Exception: Time limit exceeded
11:52:30 <lambdabot>  [a,Exception: Time limit exceeded
11:52:30 <ehird> > a^a
11:52:39 <ehird> > iterate ((^)2) a :: [Expr]
11:52:42 <lambdabot>  Exception: Time limit exceeded
11:52:51 <lambdabot>  [a,Exception: Time limit exceeded
11:52:57 <ehird> :|
11:53:00 <ehird> > a^2
11:53:01 <lambdabot>  a * a
11:53:02 <ehird> Oh
11:53:03 * Baughn is just happy to see his code being exercised a lot
11:53:06 <ehird> > iterate (2^) a :: [Expr]
11:53:17 <lambdabot>  [a,Exception: Time limit exceeded
11:53:20 <giksos_> hi, I have a question: the new version of haddock requires the -B option telling it the lib directory. How should I call haddock from a makefile in a portable way?
11:53:51 <ehird> > iterate (^2) a :: [Expr]
11:53:53 <lambdabot>  [a,a * a,a * a * (a * a),a * a * (a * a) * (a * a * (a * a)),a * a * (a * a)...
11:54:01 <ehird> > iterate (a:) [] :: [Expr]
11:54:03 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Expr]'
11:54:05 <ehird> > iterate (a:) [] :: [[Expr]]
11:54:07 <lambdabot>  [[],[a],[a,a],[a,a,a],[a,a,a,a],[a,a,a,a,a],[a,a,a,a,a,a],[a,a,a,a,a,a,a],[a...
11:54:10 <ehird> Wheee.
11:54:20 <ehird> > iterate ((,)a) () :: [[Expr]]
11:54:20 <conal> fun toy!
11:54:21 <lambdabot>  Couldn't match expected type `[Expr]'
11:54:24 <ehird> > iterate ((,)a) ()
11:54:25 <lambdabot>      Occurs check: cannot construct the infinite type: a = (Expr, a)
11:54:25 <lambdabot>       Ex...
11:54:26 <ehird> conal: you bet
11:54:49 <conal> would be great to add CSE to Expr
11:54:54 <nolrai_> Baughn: have you look at Things That Amuse Me's extention to cover functions on expretions?
11:55:05 <nolrai_> what's CSE?
11:55:14 <conal> common subexpression elimination
11:56:03 <sjanssen> conal: hmm, I have mixed feelings on that
11:56:20 <sjanssen> because it doesn't necessarily give you a better idea of what the compiler is actually doing
11:56:33 <thetallguy> just put it in as a function call
11:56:58 <sjanssen> ah, good idea
11:57:00 <conal> sjanssen: if i do iterate (^2) a where a is a number, i won't get the massive recomputation suggested by the Expr version
11:57:21 <conal> if i add CSE to Expr, i think the result would correspond to the computation done on numbers
11:57:32 <conal> though accidental additional CSE might be done
11:57:42 <sjanssen> conal: sure, but there are plenty of other places where it will reduce expressions that GHC is actually evaluating repeatedly
11:57:48 <mar77a> what's wrong about this:
11:57:49 <mar77a> e :: (Integral a, Floating b) => a -> b
11:57:50 <mar77a> e = \x -> (1 + 1/x)^x
11:57:58 <conal> btw, this Expr trick, plus CSE is how the Pan and Vertigo systems.
11:58:21 <thetallguy> It would be nice to know/see exactly what the compiler does and does not do, and be able to toggle the optimizations in and out
11:58:23 <conal> sjanssen: yep.
11:58:26 <newsham> mar77: you're mixing expressions of type integral and of type float
11:58:38 <sjanssen> mar77a: if 'x' is an Integral type, you can't divide by it
11:58:46 <newsham> mar77: try   let x' = fromIntegral x  and   1/x' and ^x'
11:59:00 <mar77a> how can i fix this
11:59:01 <sjanssen> @type \x -> (1 + 1 / fromIntegral x) ^ x
11:59:03 <lambdabot> forall t a. (Integral a, Fractional t) => a -> t
11:59:06 <sjanssen> newsham: that isn't right
11:59:23 <newsham> what did I botch?
11:59:28 <sjanssen> @type (^)
11:59:30 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:59:37 <newsham> ahh..
11:59:41 <conal> sjanssen: neither with cse nor without cse corresponds to what really gets executed.  cse is probably much closer, but i'd like some way to get exactly to equivalence.
11:59:42 <newsham> sorry
12:00:09 <sjanssen> conal: I suppose that technically breaks referential transparency (different results whether -O is on)
12:00:32 <conal> sjanssen: how??
12:00:45 <ehird> Not accessable ¨Õ  Ç·¨Õ Ç·¨Õ Ç·¨Õ !Ç·,&@JÈ
12:00:50 <ehird> i buffer overflowed haskell!
12:00:51 <conal> sjanssen: example?
12:00:51 <ehird> wowzers
12:01:06 <sjanssen> conal: GHC can decide to share/unshare results depending on optimizations
12:01:13 <mar77a> still can't fix it
12:01:16 <mar77a> e :: (Integral a, Fractional b) => a -> b
12:01:16 <mar77a> e = \x -> (1 + 1 / x) ^ x
12:01:19 <mar77a> doesn't work >:
12:01:20 <nolrai_> is there a better way to do "replace a b = a // (assocs b)"?
12:01:21 <conal> sjanssen: go on
12:01:25 <Syzygy-> Now, #haskell almost always surprises me in the insane span of areas you'll get good answers on.
12:01:29 <sjanssen> mar77a: look at my example above
12:01:36 <Syzygy-> I can't get MPI.Scatter to work with MPI4Py. Anyone ever did that?
12:01:56 <conal> sjanssen: by "different results", you mean *semantically* different, right?
12:02:14 <sjanssen> conal: well, maybe I'm not clear on what you want
12:02:16 <mar77a> sjanssen: that didn't work either
12:02:19 <newsham> (\x -> (1 + 1 / fromIntegral x) ^ x) 5
12:02:22 <newsham> > (\x -> (1 + 1 / fromIntegral x) ^ x) 5
12:02:23 <lambdabot>  2.48832
12:02:39 <sjanssen> conal: I imagined a function of type "a -> Expr" -- is this what you meant?
12:02:43 <conal> sjanssen: i think cse is always correct with call-by-name denotational semantics
12:03:07 <newsham> conal: when exprs have no side effects.
12:03:11 <ehird> how did i make haskell buffer overflow?
12:03:16 <sjanssen> mar77a: "\x ->(1 + 1 / fromIntegral x) ^ x" will work
12:03:25 <mar77a> why doesn't it work without that
12:03:39 <newsham> ?type (/)
12:03:41 <lambdabot> forall a. (Fractional a) => a -> a -> a
12:03:54 <frwmanners> mar77a: haskell doesn't do recasting
12:03:57 <sjanssen> conal: I'm saying that the resulting Expr will be different depending on whether -O is on
12:04:01 <conal> sjanssen: i mean the representation and meaning of an Expr, and so anything at all one would want to do with an Expr.
12:04:13 <nolrai_> sjanssen: Wouldent you want the function to take the optimisation level as a pram, not just use what GHC is useing right then?
12:04:23 <conal> sjanssen: oh, but with the same meaning (given the semantic function i have in mind)
12:04:33 <frwmanners> ehird: what were you doing when you managed it?
12:04:37 <sjanssen> conal: depends on what you mean by "meaning"
12:04:46 <sjanssen> conal: of course they'll evaluate to the same value
12:04:58 <conal> sjanssen: that's the meaning of meaning i mean!
12:05:11 <sjanssen> conal: but say you wanted to count the number of function calls in an expression
12:05:12 <ehird> frwmanners: Possibly some of the System.Directory stuff done it
12:05:15 <sjanssen> or 'show' it
12:05:16 <ehird> normalizeToCurrentDirectory fp = liftIO $ do
12:05:16 <ehird>   canon <- canonicalizePath fp
12:05:16 <ehird>   makeRelativeToCurrentDirectory canon
12:05:20 <ehird> I bet that's the culprit
12:06:08 <conal> sjanssen: i think i understand what you're saying: a syntactic representation has more information than a semantic one.  (in other words semantic functions are many-to-1)
12:07:17 <conal> sjanssen: though i don't know what you mean about -O changing even a syntactic representation of an Expr.
12:07:34 <conal> sjanssen: though what the representation change i have in mind would (of course) change the representation.
12:07:46 <sjanssen> conal: GHC rearranges things all the time
12:07:57 <monochrom> good afternoon
12:08:04 <conal> sjanssen: right.  in meaning-preserving ways
12:08:11 <chessguy> w00t!
12:08:22 * chessguy implements tree traversal as an algebraic data type
12:08:25 <conal> sjanssen: probably we have some communication wires crossed.
12:08:35 <sjanssen> conal: compare the results of "exprOf (map f . map g)" depending whether fusion rules are activated
12:08:38 <conal> chessguy: let's see!
12:09:14 <conal> sjanssen: is exprOf from lennart's post?
12:09:34 <chessguy> conal: http://hpaste.org/7702
12:09:49 <sjanssen> conal: no, this is the imaginary exprOf that show you what GHC is actually doing
12:09:51 <chessguy> i'll add more complex traversals, this is just a proof-of-concept so far
12:11:12 <monochrom> What does pointer :: Int serve?
12:11:35 <chessguy> monochrom it points to a child node
12:11:51 <chessguy> to indicate what direction it will go down to next, if down is called
12:12:35 <chessguy> my next step is to pull that out, and allow arbitrary state for the zipper itself
12:14:53 <mar77a> how about this:
12:14:53 <mar77a> sq :: (Num a) => a -> a
12:14:54 <mar77a> sq = \x -> 2.71828183 ^ log x
12:15:01 <mar77a> what trickery do i need to make it work :<
12:15:44 <monochrom> Design a new language.
12:15:52 <nolrai_> sq :: (Floating a) ?
12:15:57 <chessguy> conal: thoughts?
12:16:00 <monochrom> I'm just teasing you. Num is incapable of doing log.
12:16:16 <monochrom> And ^ is incapable of working with Floating.
12:16:22 <mar77a> ah
12:16:27 <ari> :t (**)
12:16:29 <lambdabot> forall a. (Floating a) => a -> a -> a
12:16:36 <ziman> :t (^)
12:16:37 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
12:16:42 <mar77a> smooth
12:16:46 <mar77a> ** > ^
12:16:49 <ari> :t (^^)
12:16:51 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
12:16:57 <newsham> > exp 1
12:16:57 <monochrom> No trickery. Pure logic.
12:16:58 <lambdabot>  2.718281828459045
12:17:22 <mar77a> wait what's 'exp'
12:17:29 <newsham> > let sq x = (exp 1) ** log x in sq 5
12:17:31 <lambdabot>  4.999999999999999
12:17:33 <conal> chessguy: just that i don't know what you're striving for.
12:17:37 <monochrom> exp x = e^x
12:17:40 <geezusfreeek> chessguy: so this is basically a tree zipper along with a structure that stores "directions"?
12:17:49 <ari> > log (exp 1)
12:17:50 <lambdabot>  1.0
12:17:57 <dons> wow, a well timed blog post can really change the debate. hmm
12:17:58 <chessguy> @pl \t -> e (f t) . g
12:17:58 <lambdabot> (. g) . e . f
12:18:12 <ari> dons: zomg url plz
12:19:06 <mar77a> how come e isn't defined
12:19:07 <conal> chessguy: which i mean as no criticism at all.
12:19:10 <mar77a> or is it in some math module
12:19:11 <chessguy> conal: i want to be able to have a simple algebraic data type to represent tree traversals - one that can easily instantiate Arbitrary
12:19:19 <chessguy> conal: sure
12:19:45 <newsham> mar77a: not sure, but maybe because e = e^1 = exp 1 ?
12:19:46 <conal> chessguy: is Context that adt?
12:19:56 <conal> chessguy: or maybe TreeLoc?
12:20:00 <chessguy> conal: http://code.haskell.org/ChessLibrary/README.txt should provide some background
12:20:04 <mar77a> yeah i'm using (exp 1) now
12:20:07 <chessguy> conal: no, those are just the zipper
12:20:25 <chessguy> conal: look near the end
12:20:29 <mar77a> i can just do e = exp 1
12:20:32 <chessguy> data TreeTraversal = Up | Down | TurnRight | TurnLeft | Seq [TreeTraversal]
12:20:32 <newsham> mar77a: you can define it .
12:20:33 <newsham> yup
12:21:04 <conal> chessguy: oh!  i hadn't read closely enough to find it before.
12:21:51 <conal> chessguy: and since TreeTraversal is simple and algebraic, it's easy to define a useful Arbitrary.  Nice. :)
12:21:54 <chessguy> well, it's not very well-organized yet
12:21:55 <mar77a> how do i define a function that doesn't take arguments -- the return type
12:22:10 <geezusfreeek> mar77a: a side-effecting function?
12:22:18 <mar77a> nope, a constant
12:22:25 <mar77a> maybe i should use let
12:22:25 <monochrom> pi is a function that doesn't take arguments
12:22:27 <monochrom> > pi
12:22:28 <lambdabot>  3.141592653589793
12:22:29 <geezusfreeek> mar77a: just the type of the constant
12:22:36 <conal> chessguy: since you probably don't really want arbitrary values of type 'State (TreeLoc a) a'
12:22:37 <mar77a> how?
12:22:39 <geezusfreeek> :t pi
12:22:39 <chessguy> conal: exactly, which i need for what i'm doing :)
12:22:40 <ziman> pi :: Double
12:22:41 <lambdabot> forall a. (Floating a) => a
12:22:45 <chessguy> right again
12:22:45 <mar77a> o
12:22:58 <conal> chessguy: thx
12:23:02 <mar77a> so for
12:23:03 <mar77a> e = exp 1
12:23:09 <mar77a> what should i do e :: ?
12:23:19 <monochrom> refer to the pi example
12:23:25 <geezusfreeek> chessguy: please keep me up to date on your chess project. i am interested in evolutionary algorithms
12:23:55 <monochrom> omit "forall a."  it's for a haskell dialect
12:23:55 <mar77a> well e :: Double; e = exp 1; doesn't work
12:23:59 <geezusfreeek> oh, is this a darcs repo i see?
12:24:02 <chessguy> geezusfreeek: your best bet is to keep en eye on the site i just referenced
12:24:09 <geezusfreeek> ah yes
12:24:16 <geezusfreeek> i will just check its logs every once in a while
12:24:59 <newsham> ?type exp 1
12:25:00 <lambdabot> forall t. (Floating t) => t
12:25:04 <conal> chessguy: i like your solution, and i wonder if the algebraic type is necessary.  could you instead define an Arbitrary that selects from [up,down,turn,turn'] as well as the the compositions that correspond to 'f (Seq ...)'?  more curiosity than preference.
12:25:36 <geezusfreeek> conal: i'm sure he could, but an ast can get a Show instance :)
12:25:47 <chessguy> geezusfreeek: you may also be interested in  http://catenova.org/~awagner/GPLib , where i've done some preliminary GP work
12:25:48 <lambdabot> Title: Index of /~awagner/GPLib/
12:25:54 <newsham> [09:21] < mar77a> well e :: Double; e = exp 1; doesn't work
12:25:56 <newsham> works here
12:25:57 <mar77a> ah i was using e :: Floating but since floating is a class i had to do (Floating x) => x
12:26:11 <conal> geezusfreeek: yeah -- Show is very handy
12:26:14 <ehird> sclv: Got an hvac tutorial?
12:26:16 <mar77a> newsham: strange
12:26:25 <chessguy> conal: maybe, but eventually i can imagine the algebraic type getting pretty complex, and domain-specific
12:26:30 <ehird> > let e :: Double; e = exp 1 in e
12:26:31 <newsham> because I used "Double".  if you're using "Floating" you need the (..) =>
12:26:32 <lambdabot>  2.718281828459045
12:26:53 <jumper^> sorry for ask, but, what is this language?
12:27:02 <gwern> @hoogle sort
12:27:02 <conal> chessguy: TreeTraversal is a DSL with f as its interpreter
12:27:03 <lambdabot> Data.List.sort :: Ord a => [a] -> [a]
12:27:03 <lambdabot> Data.ByteString.sort :: ByteString -> ByteString
12:27:03 <lambdabot> Data.ByteString.Char8.sort :: ByteString -> ByteString
12:27:09 <jumper^> what can i do, with haskell?
12:27:23 <chessguy> conal: exactly
12:27:29 <newsham> jumper: make programs as in other programming languages
12:27:42 <newsham> you can write an editor, a ray tracer, a mandelbrot set plotter, etc.
12:27:46 <jumper^> can you give an example, please?
12:27:47 <roconnor> @faq can haskell make anything?
12:27:47 <lambdabot> The answer is: Yes! Haskell can do that.
12:27:52 <conal> chessguy: so the usual considerations with direct embedding vs an interpretive layer probably apply.  such as geezusfreeek's comment about Show
12:28:16 <ehird> jumper^: it's a progamming language
12:28:20 <newsham> you can even make a turing machine emulator
12:28:27 <ehird> newsham: revolutionary
12:28:28 <jumper^> really?
12:28:35 <ehird> jumper^: what do you mean, really?
12:28:37 <tetha> its a turing-complete language :) so it might be unable to compute the universe, but it can compute a damn lot
12:29:05 <conal> chessguy: and you might even get ghc to remove the interpretive layer, in case performance becomes an issue.
12:29:07 <geezusfreeek> jumper^: haskell is just another programming language. useful for whatever you feel like making with it
12:29:07 <newsham> its been rumored that someone once wrote a lambda calculus evaluator in haskell
12:29:08 <chessguy> conal: it's very easy to see practical implcations, too
12:29:09 <jumper^> just i don't know anything about it, but i wanna learn...
12:29:12 <conal> chessguy: via fusion.
12:29:48 <chessguy> conal: in my case, i want to literally write a small chess engine in the TreeTraversal DSL
12:29:49 <jumper^> there is some information about it were i can learn?
12:30:02 <newsham> ?where tutorial
12:30:02 <lambdabot> http://www.haskell.org/tutorial/
12:30:04 <chessguy> or, rather, evolve engines in it :)
12:30:04 <conal> chessguy: minor style suggestion: write the f (Seq ..) part as a single case, using mapM_
12:30:10 <conal> chessguy: makes a lot of sense to me
12:30:13 <chessguy> oh, good point
12:30:22 <jumper^> yes, a tutorial
12:30:36 <conal> chessguy: something like f (Seq es) = mapM_ f es >> getNode
12:30:38 <chessguy> and thanks for the name for f, too :)
12:30:41 <geezusfreeek> jumper^: http://book.realworldhaskell.org/beta/
12:30:42 <lambdabot> Title: Real World Haskell
12:30:46 <geezusfreeek> ;)
12:30:49 <chessguy> (interpret)
12:30:55 <jumper^> thks geezusfreeek
12:31:06 <conal> chessguy: then my eyes don't have to go around in circles to understand the code ;)
12:31:21 <geezusfreeek> jumper^: also, newsham wasn't asking if you wanted a tutorial, he was getting lambdabot to give you a url
12:31:24 <chessguy> haha
12:31:48 <jumper^> do i need a compilator for this?
12:31:55 <conal> chessguy: you could also write some optimizers or a set of bottom-up-optimizing smart constructors for TreeTraversal.
12:31:57 <Vaelys> @faq what can't haskell do?
12:31:57 <lambdabot> The answer is: Yes! Haskell can do that.
12:32:01 <newsham> the tutorials should mention how to get a compiler.  and yes you do
12:32:06 <tetha> oh, some chapter about data structures, gotta read that
12:32:08 <conal> chessguy: which may or may not be useful, but probably interesting.
12:32:12 <chessguy> conal: not sure what you mean by that?
12:32:15 <geezusfreeek> jumper^: see the Getting Stated chapter
12:32:41 <geezusfreeek> jumper^: actually, see appendix a
12:32:55 <conal> chessguy: if f is your "semantic function", then there are some non-trivial meaning-preserving transformations on TreeTraversal.
12:32:57 <jumper^> oks
12:33:15 <conal> chessguy: you could code up those transformations/equations as an optimizer function
12:33:38 <conal> and then perhaps write semantic quickcheck properties that prove your optimizer correct.
12:33:46 <chessguy> hrmm
12:33:47 <ehird> sclv: ping
12:33:51 <ehird> compilator
12:33:52 <ehird> :-))))))))
12:34:00 <roconnor> > nubBy(((>1).).gcd) [2..]
12:34:02 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:34:07 <jumper^> does anybody have a pdf about haskell?
12:34:10 <geezusfreeek> chessguy: for example, sequences of turn left, turn right, turn left, turn right, etc.
12:34:10 <chessguy> conal, like, e.g., removing Down/Up pairs?
12:34:21 <conal> chessguy: yes, for instance.
12:34:24 <chessguy> gotcha
12:34:30 <ehird> jumper^: what's wrong with real world haskell
12:34:42 <geezusfreeek> ?where YAHT
12:34:43 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
12:34:43 <newsham> jumper: see the tutorials pages
12:34:50 <geezusfreeek> jumper^: ^
12:34:53 <conal> chessguy: another suggestion: define a Monoid instance for TreeTraversal
12:35:08 <chessguy> conal: ok. why's that?
12:35:35 <ehird> sclv: ping
12:35:39 <ehird> anyone who knows HVAC: ping
12:35:40 <conal> chessguy: because it captures what i bet will be useful operations on traversals.
12:36:02 <conal> chessguy: and they have nice properties with respect to your interpreter
12:36:08 <geezusfreeek> chessguy: for example, you could use Data.Foldable.fold on a list of TreeTraversals
12:36:28 <geezusfreeek> :t Data.Foldable.fold
12:36:29 <lambdabot> forall (t :: * -> *) m. (Monoid m, Data.Foldable.Foldable t) => t m -> m
12:36:33 <conal> chessguy: and if i'm mistaken and they *don't* have nice properties, then you'll know to improve your design.
12:37:13 <chessguy> fair enough
12:37:45 <jumper^> tks for all, bye bye
12:37:57 <roconnor> > show "foo\tbar\tbaz\n"
12:37:58 <lambdabot>  "\"foo\\tbar\\tbaz\\n\""
12:39:27 <conal> chessguy: anyway, it looks like a fun & interesting project!
12:39:35 <gwern> > 2^8
12:39:36 <lambdabot>  256
12:39:45 <ehird> =|
12:40:02 <chessguy> conal / geezusfreeek : i'm looking for a mentor for this project, just someone to touch base with weekly or so, to provide code reviews and general advice
12:40:09 <gwern> hm. bytestrings can only encode 256 values?
12:40:13 <nolrai_> @Hoogle Bool -> a -> Maybe a
12:40:14 <lambdabot> Maybe you meant: google hoogle
12:40:14 <chessguy> in case you guys know anyone that might be interested :)
12:40:22 <monochrom> well, byte...
12:40:26 <sjanssen> gwern: 256 per byte
12:40:41 <ehird> :t (<$>)
12:40:43 <sjanssen> and ByteString is an array of bytes
12:40:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:41:20 <geezusfreeek> chessguy: i will be keeping an eye on your progress out of interest, but no promises of regular code reviews ;)
12:41:25 <gwern> sjanssen: but bytestring is [Word8], and each charcter is a single Word8, and a Word8 is 8 bits, and 8 bits can represent 2^8 different possibilities
12:41:30 <chessguy> geezusfreeek: fair enough
12:41:32 <monochrom> a bytestring of length 2 can encode 65536 values.
12:41:49 <monochrom> > 2^8
12:41:50 <lambdabot>  256
12:41:52 <gwern> so there are only 256 possible characters, if I'm doing this right
12:42:04 <geezusfreeek> chessguy: i don't have the best eye for good refactorings yet anyway
12:42:15 * Baughn wonders why bytestring doesn't share code with data.array?
12:42:16 <conal> chessguy: i'm happy to chat, see how it's coming, and provide random comments, for as long as you & i both enjoy it.
12:42:17 <sjanssen> gwern: correct
12:42:41 <nolrai_> @hoogle Bool -> a -> Maybe a
12:42:42 <lambdabot> No matches, try a more general search
12:42:48 <geezusfreeek> chessguy: same as conal ^
12:42:49 <conal> chessguy: what's YUI (from the README)?
12:43:00 <chessguy> uh
12:43:01 <dolio> Is there some function in template haskell that will show what code it's generating?
12:43:04 <chessguy> that's supposed to say Yi
12:43:04 <ziman> @hoogle a -> Bool -> Maybe a
12:43:05 <lambdabot> No matches, try a more general search
12:43:10 <Baughn> gwern: There's a reason it's called a /Byte/string, after all. If you want arbitrary values, Data.Array might help
12:43:14 <conal> @localtime chessguy
12:43:14 <lambdabot> Local time for chessguy is 2008-05-17 15:43:14 -0400
12:43:28 <chessguy> though i pretty much wound up coding the zipper almost from scratch anyway
12:43:30 * monochrom wonders what gwern wants to assert.
12:43:35 <geezusfreeek> YUI = Yahoo User Interface library
12:43:37 <geezusfreeek> :P
12:43:41 <dolio> That's more informative than '$( foo ) ==> syntax error'?
12:43:44 <gwern> sjanssen: I ask because I'm pondering whether a radix or counting sort might be faster than the kmp or boyer-moore or whatever bytestring currently uses
12:43:49 <chessguy> just used his code to avoid having to think
12:44:01 <chessguy> geezusfreeek: yes, i work in javascript for a living. a definite freudian slip
12:44:15 <conal> chessguy: a yahoo ui lib has a rose tree zipper ??
12:44:16 <Baughn> dolio: Try -ddump-splices for ghc
12:44:26 <Baughn> dolio: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html
12:44:27 <lambdabot> Title: 5.16. Debugging the compiler, http://tinyurl.com/t96uq
12:44:28 <geezusfreeek> chessguy: yes, i also have had plenty of runins with YUI
12:44:35 <newsham> chessguy: what kinda js stuff? web applicationd ev?
12:44:36 <chessguy> conal: no, that's a typo. it's supposed to say yi
12:44:41 <geezusfreeek> conal: why yes, haven't you heard? CSS is written in Haskell now!
12:44:42 <dcoutts> gwern: do you mean sorting a bytestring? it already uses a counting sort
12:44:57 <conal> chessguy: oh!!  (freudian slip)
12:45:04 <chessguy> newsham: yes, i write web apps in server-side JS
12:45:12 <dolio> Baughn: Ah, thanks.
12:45:19 <monochrom> kmp or boyer-moore doesn't strike me as sorting
12:45:37 <dcoutts> monochrom: yeah, I was confused :-)
12:45:53 <newsham> chess: I work for a security consultancy, we do lots of web app audits.
12:46:05 <geezusfreeek> hmm… now i'm trying to think of ways to apply boyer-moore to sorting algorithms
12:46:15 <monochrom> and radix sort doesn't strike me as matching or searching...
12:46:25 <gwern> argh, you're right, kmp is searching
12:46:34 <monochrom> is it really difficult to say something that make sense?
12:46:48 <newsham> have you poked around any of the haskell->js compilers for kicks?
12:47:00 <conal> geezusfreeek: replacing all web languages with (purely functional) Haskell is one of my pet projects.
12:47:01 <chessguy> newsham: very briefly, but the js is not human-readable
12:47:07 * gwern goes to the bytestring source to see what it actually is using for sorting
12:47:17 <geezusfreeek> conal: me too! with little progress yet…
12:47:22 <geezusfreeek> well
12:47:22 <conal> geezusfreeek: (html, css, jpg, mpeg,...)
12:47:25 <geezusfreeek> not _all_
12:47:27 <OceanSpray> are type classes in Haskell grounded as much in mathematics as the language's other features?
12:47:37 <gwern> monochrom: I'm tired, is why - sorting, searching, the words are so similar...
12:47:42 <newsham> conal: ambitions for a browser implementation?
12:47:50 <geezusfreeek> i'm really doing more backend stuff, but i want to be able to write typechecked html+css
12:47:51 <conal> geezusfreeek: (and of course js)
12:47:59 <monochrom> Glad I didn't grow up in English. :)
12:48:02 <roconnor> Haskell dosn't even have formal semantics
12:48:09 <sjanssen> gwern: ByteString currently using a counting sort (I wrote it :) )
12:48:10 <dons> Cale, a job for you, http://www.heimburg.com/heimblog/?p=3
12:48:11 <conal> newsham: i care more about the data languages.
12:48:11 <lambdabot> Title: Heimblog  Haskell
12:48:26 <conal> iswim for the web!
12:48:34 <newsham> iswim?
12:48:35 <dancor> am i crazy for wanting dot2 = (.) . (.), dot3 = (.) . (.) . (.)  (and is there something like `ap` for this?)  i want to be able to use something like . even when there is more than one variable being acted on
12:48:37 <conal> "the next 700 web data formats"
12:49:02 <Baughn> dancor: How about (..) = (.).(.) instead?
12:49:06 <conal> newsham: the ancestor of ml & haskell.  from peter landin's paper "the next 700 programming languages"
12:49:18 <roconnor> (.:) is traditional for (.).(.)
12:49:19 <Baughn> Oh, right. Syntax.
12:49:21 <conal> newsham: the source of the idea of DSELs
12:49:27 <roconnor> traditional on #haskell
12:49:34 <gwern> sjanssen: darn
12:49:38 * conal prefers (fmap.fmap).  more scalable
12:49:41 <geezusfreeek> dancor: i think i would need to work on internalizing that but it still looks useful
12:49:51 <frwmanners> Has anyone written a coerce function using MPTC's?
12:49:52 <dons> dancor: it comes up sometimes.
12:50:01 <dons> frwmanners: for numeric types?
12:50:02 <monochrom> "the next 700 terrabytes of web data"
12:50:12 <frwmanners> dons: For a start
12:50:24 <conal> monochrom: a web-iswim would *reduce* the size of data.
12:50:25 <dons> frwmanners: people do it occasionally as an exercise
12:50:35 <nolrai_> whats a good name for f True a = Just a; f False a = Nothing;?
12:50:43 <dons> boolToMaybe ?
12:50:44 <shachaf> conal: Not in #haskell. :-)
12:50:52 <vincenz> :t boolToMaybe
12:50:54 <lambdabot> Not in scope: `boolToMaybe'
12:51:05 <conal> monochrom: because iswim/haskell has parameterization, unlike most data formats
12:51:12 <vincenz> dons: actually, even better . (?)
12:51:13 <dons> :t isJust
12:51:13 <conal> shachaf: good point!
12:51:15 <sjanssen> @pl \b x -> guard b >> return x
12:51:15 <lambdabot> forall a. Maybe a -> Bool
12:51:15 <lambdabot> (. return) . (>>) . guard
12:51:32 <vincenz> dons: then you can do (bool ? true := false)
12:51:33 <shachaf> @let (...) = map map map
12:51:34 <lambdabot> <local>:1:12:     Ambiguous type variable `f' in the constraint:       `Funct...
12:51:35 <dons> nolrai_: its a funny function, the bool represents the tag.
12:51:36 <vincenz> erm =:
12:51:43 <shachaf> @let (...) x = map map map x
12:51:44 <lambdabot> Defined.
12:51:44 <monochrom> conal: I'm thinking along a different line. The next 700 terrabytes of web data will be pointless youtube videos, pointless blogs, etc.
12:51:52 <sjanssen> nolrai_: I call it (. return) . (>>) . guard :)
12:52:49 <newsham> the next 700TB will be written in Flex
12:52:52 <conal> monochrom: oh yeah.  i bet the blogosphere etc will sift out the good stuff anyway.
12:53:17 <shachaf> @ty flip (join ... map)
12:53:19 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => f a1 -> (a1 -> f a) -> f a
12:53:40 <OceanSpray> :t (...)
12:53:42 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:53:45 <OceanSpray> wha
12:53:51 <vincenz> wtf
12:53:56 <shachaf> OceanSpray: I just @let it.
12:54:04 <shachaf> (...) = map map map
12:54:05 <vincenz> :t map
12:54:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:54:11 <shachaf> (@ty works with @let now?)
12:54:23 <shachaf> @let magnesium = "cadmium"
12:54:23 <vincenz> shachaf: always has
12:54:24 <lambdabot> Defined.
12:54:32 <shachaf> Oh.
12:54:35 <shachaf> @ty magnesium
12:54:36 <monochrom> devious
12:54:37 <lambdabot> [Char]
12:54:44 <nolrai_> > magnesium
12:54:44 <OceanSpray> > magnesium
12:54:46 <lambdabot>  "cadmium"
12:54:46 <lambdabot>  "cadmium"
12:54:47 <sjanssen> vincenz: that isn't true
12:55:02 <vincenz> sjanssen: ok, well not "always" :)
12:55:06 * monochrom feeds cadmium into shachaf's oysters
12:55:14 <shachaf> Last time I checked, it didn't.
12:55:32 <shachaf> monochrom: My oysters?
12:55:38 * shachaf sets his oysters free.
12:58:53 <EmptyBox> how can send command to vim when you want to open file; e.g: $vim myfile :set ruler ?
12:59:36 <ehird> > magnesium
12:59:37 <lambdabot>  "cadmium"
12:59:40 <monochrom> :e myfile
12:59:49 <ehird> @let id = fix
12:59:50 <lambdabot> Defined.
12:59:51 <ehird> > id
12:59:52 <lambdabot> Terminated
12:59:55 <ehird> someone try id?
13:00:17 <shachaf> EmptyBox: #vim might be a better channel for this.
13:00:17 <edwardk> > id "rather not"
13:00:18 <lambdabot> Terminated
13:00:23 <ehird> brilliant
13:00:28 <shachaf> EmptyBox: (And it's -c, if you check the man page.)
13:00:29 <ehird> @let map = fix
13:00:30 <lambdabot> L.hs:14:0:     Multiple declarations of `L.map'     Declared at: <local>:4:0 ...
13:00:34 <ehird> @let foldl = fix
13:00:35 <lambdabot> Defined.
13:00:36 <geezusfreeek> lambdabot has been timing out a lot lately
13:00:38 <ehird> @let foldr = fix
13:00:39 <lambdabot> Defined.
13:00:43 <ehird> Take that >!!
13:00:50 <shachaf> @let (*) = fix
13:00:50 <geezusfreeek> > id "hello?"
13:00:51 <lambdabot> Defined.
13:00:51 <lambdabot> Terminated
13:00:56 <shachaf> @let (+) = fix
13:00:57 <lambdabot> Defined.
13:00:58 <geezusfreeek> and that is just weird
13:01:02 <vixey> @unlef
13:01:03 <lambdabot> ()
13:01:08 <shachaf> @undef
13:01:09 * edwardk watches as ehird gets his lambdabot privileges revoked ;)
13:01:10 <lambdabot> Undefined.
13:01:13 <geezusfreeek> > let id' x = x in "foo"
13:01:14 <lambdabot>  "foo"
13:01:25 <EmptyBox> $ vim -c :set ruler        do not works !
13:01:55 <edwardk> empty box "'s around the :set ruler?
13:02:24 <EmptyBox> :) thanks
13:02:53 <nolrai_> @pl p x = (x, g x)
13:02:53 <lambdabot> p = ap (,) g
13:03:13 <nolrai_> hmmm
13:03:43 <shachaf> @ty ap (,) ?g
13:03:45 <lambdabot> forall a b. (?g::a -> b) => a -> (a, b)
13:03:46 <shachaf> @ty id &&& ?g
13:03:48 <lambdabot> forall a c'. (?g::a -> c') => a -> (a, c')
13:03:55 <vixey> @left
13:03:55 <lambdabot> Defined.
13:03:57 <shachaf> @ty second ?g
13:03:59 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a, ?g::a b c) => a (d, b) (d, c)
13:04:02 <ehird> @ty ?a
13:04:02 <vixey> @left
13:04:03 <dmwit> I wonder what @unlef spell-corrects to, to give ()
13:04:04 <lambdabot> forall t. (?a::t) => t
13:04:04 <lambdabot> Defined.
13:04:07 <ehird> > ?a
13:04:08 <lambdabot>   parse error on input `?'
13:04:12 <ehird> @ty ?a -> ?a
13:04:14 <lambdabot> parse error on input `->'
13:04:17 <vixey> @unpl
13:04:17 <lambdabot> ()
13:04:19 <ehird> @ty \?a -> ?a
13:04:21 <dmwit> mmm
13:04:21 <lambdabot> parse error on input `\?'
13:04:26 <ehird> @ty \a -> ?a
13:04:28 <lambdabot> forall t t1. (?a::t1) => t -> t1
13:04:31 <EmptyBox> edwardk>: is there any way to start vim at edit mode not command mode ?
13:04:34 <ehird> @ty ?2
13:04:36 <lambdabot> parse error on input `?'
13:04:39 <ehird> :\
13:04:47 <shachaf> EmptyBox: There is no edit mode in vim.
13:04:57 <shachaf> EmptyBox: Could you /join #vim for these questions, maybe?
13:04:58 <dmwit> EmptyBox: Really, take these to #vim.
13:05:37 <Bonus> vim in insert mode huh?
13:05:39 <Bonus> ew
13:05:52 <EmptyBox> ok sorry to disturb you
13:06:27 <edwardk> emptybox: dunno, never felt the need
13:06:42 <monochrom> perhaps because #vim requires root access and $vim doesn't? :)
13:07:08 <shachaf> monochrom: #vim is commented out, $vim is expanded.
13:13:01 <nolrai_> @pl \(index, newValue) -> newValue \= oldValues ! index
13:13:02 <lambdabot> (line 1, column 32):
13:13:02 <lambdabot> unexpected "\\"
13:13:02 <lambdabot> expecting variable, "(", operator or end of input
13:13:34 <nolrai_> @pl (index, newValue) -> newValue \= oldValues ! index
13:13:35 <lambdabot> (line 1, column 19):
13:13:35 <lambdabot> unexpected ">" or "-"
13:13:35 <lambdabot> expecting variable, "(", operator or end of input
13:13:48 <nolrai_> @pl f (index, newValue) = newValue \= oldValues ! index
13:13:48 <lambdabot> (line 1, column 32):
13:13:48 <lambdabot> unexpected "\\"
13:13:48 <lambdabot> expecting variable, "(", operator or end of input
13:13:58 <nolrai_> @pl f (index, newValue) = newValue /= oldValues ! index
13:13:58 <lambdabot> f = uncurry ((/=) . (oldValues !))
13:15:15 <chessguy> hmm, conal, what i really want to do is to allow clients of this code to extend TreeTraversal, but only with more simple algebraic data types. thoughts on this?
13:16:14 <nolrai_> @pl \index -> (index, getNewValue index)
13:16:15 <lambdabot> ap (,) getNewValue
13:17:56 <dmwit> nolrai_: You may also be interested in: iterate getNewValue index
13:18:13 <nolrai_> :t iterate
13:18:15 <lambdabot> forall a. (a -> a) -> a -> [a]
13:18:55 <Apocalisp> What kind of operation is [m a] -> [a]?
13:19:21 <dmwit> Apocalisp: That's a run*, where * is the name of m.
13:19:26 <dmwit> (After a sequence.)
13:19:36 <dmwit> :t runState 0 . sequence
13:19:38 <lambdabot> forall a (m :: * -> *) a1. (Monad m, Num (State (m [a1]) a)) => [m a1] -> (a, m [a1])
13:19:45 <dmwit> whoops
13:19:46 <dmwit> :t runState
13:19:48 <lambdabot> forall s a. State s a -> s -> (a, s)
13:19:53 <dmwit> > runState . sequence
13:19:54 <lambdabot>   add an instance declaration for (Typeable2 State)
13:20:03 <dmwit> :t runState . sequence
13:20:05 <lambdabot> forall s a. [State s a] -> s -> ([a], s)
13:20:06 <nolrai_> evalState? or is it execState?
13:20:12 <dmwit> whew!  It took me a few tries.
13:20:29 <nolrai_> :t evalState
13:20:32 <lambdabot> forall s a. State s a -> s -> a
13:22:41 <nolrai_> :t mapM
13:22:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:27:12 <nolrai_> :t liftM (ap (,))
13:27:15 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m (a -> (a, b))
13:27:27 <conal> chessguy: just saw your comment.
13:28:10 <chessguy> conal: ah
13:28:21 <conal> chessguy: do you mean you'd like the TreeTraversal data type to be extensible, as in clients adding new data constructors?
13:29:00 <Apocalisp> thanks dmwit
13:29:35 <chessguy> conal: yes. for example, there can be some generic things built into it, but the ability to add domain-specific stuff
13:29:58 <nolrai_> @undo do {new <- getNew i; (i, new)}
13:29:58 <lambdabot> getNew i >>= \ new -> (i, new)
13:30:24 <conal> chessguy: lack of constructor-extensibility is a basic weakness of algebraic types (dual to the lack of method-extensibility in OOP).
13:30:41 <nolrai_> @pl f i = getNew i >>= \ new -> (i, new)
13:30:42 <lambdabot> f = liftM2 (>>=) getNew (,)
13:30:50 <conal> chessguy: however, i wonder whether there's a simple way to get what you're after
13:31:12 <conal> chessguy: what's an example of a constructor/operation/whatever someone might want to add?
13:31:21 <nolrai_> wow, I didn't think that would get nice again.
13:31:40 <chessguy> so, Down, Up, etc., can be built in, but i may also want something like If DomainSpecifPredicate Down Up
13:32:15 <chessguy> where DomainSpecificPredicate 'hides' the state monad stuff
13:32:25 <conal> chessguy: interesting.  what information could the predicate access?
13:32:49 <chessguy> conal: information about the value of type in in the TreeLoc a
13:32:56 <nolrai_> :t liftM2 (>>=) return (,)
13:32:58 <lambdabot> forall a. (Monad ((,) a)) => a -> (a, a)
13:33:06 <geezusfreeek> chessguy: so, a constructor like If :: m Bool -> TreeTraversal -> TreeTraversal -> TreeTraversal?
13:33:08 <chessguy> or, more accurately, about the value of type Tree a
13:33:23 <conal> chessguy: got it, thx.  thinking ...
13:33:31 <nolrai_> hmm that dosen't look right.
13:33:53 <chessguy> geezusfreeek: yeah, but without requiring Arbitrary state actions
13:34:07 <conal> chessguy: that extension would give the traverser eyes and ability to react to what it sees
13:34:14 <conal> chessguy: sounds pretty useful
13:34:39 <geezusfreeek> chessguy: so something more like Context -> Bool instead of m Bool?
13:35:02 <chessguy> conal: i was thinking of doing something like adding (to TreeTraversal) | If Pred TreeTraversalTreeTraversal, but not defining it in the module
13:35:12 <chessguy> conal: that would force the client to define it
13:35:32 <conal> chessguy: not defining Pred in the module?
13:35:33 <chessguy> geezusfreeek: hmm
13:35:42 <chessguy> conal: correct
13:35:51 <geezusfreeek> chessguy: ah, it is sounding like you actually want a type class instead of your own ADT…
13:36:31 <geezusfreeek> chessguy: class TreeTraversal a where; up :: a; down :: a; turn :: a, etc.
13:36:34 <conal> wow -- i wonder how one could enable Arbitrary on open-ened data-types
13:36:47 <geezusfreeek> then the client would have to define their own Arbitrary for it as well
13:36:55 <chessguy> oh, ugh
13:36:57 <conal> (that class reminds me of ralf hinze's "weaving a web" paper)
13:37:53 <geezusfreeek> but the benefit would be that the client can use constructors not specifically in the type class
13:38:35 * geezusfreeek looks up "weaving a web"
13:39:17 <geezusfreeek> oh, Zipper
13:39:27 <geezusfreeek> oh wait, this is just intro
13:39:29 <conal> geezusfreeek: related
13:39:58 * chessguy shrugs
13:40:11 <chessguy> perhaps i need to just say 'screw it', and have a domain-specific zipper
13:40:16 <geezusfreeek> oh this does look cool
13:40:22 * geezusfreeek puts it on his reading queue
13:40:27 <conal> geezusfreeek: yeah :)
13:40:28 <chessguy> geezusfreeek: link?
13:40:32 * chessguy is lazy
13:40:35 <geezusfreeek> http://citeseer.ist.psu.edu/609884.html
13:40:36 <lambdabot> Title: Weaving a Web (ResearchIndex)
13:40:39 <chessguy> thanks
13:40:40 <conal> chessguy: is efficient!
13:40:58 <geezusfreeek> conal: he must be more haskelly than i am
13:41:09 <conal> :)
13:41:55 <chessguy> geezusfreeek: i doubt that :)
13:42:34 <conal> chessguy: something smells funny to me about your type and interpreter (TreeTraversal and f): the last line of f uses (>>), discarding information from 'f e'.  if that info is expendable, i wonder if you really have the type you want.
13:42:57 <nolrai_> :t (//)
13:42:59 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
13:43:03 <conal> chessguy: tho i haven't internalized the intention of the State (TreeLoc a) a type.
13:43:39 <chessguy> conal: i'm discarding the result, but not the side effect
13:43:52 <conal> chessguy: yeah, i see.  that's why i'm suspicious about the type.
13:44:11 <chessguy> but the side effect is what i really want :)
13:44:12 <geezusfreeek> conal: i think that is his zipper monad, or are you actually wondering why he has a zipper monad at all?
13:44:13 <conal> chessguy: if the value isn't *crucial*, i bet you could remove it altogether.
13:44:17 <qebab> is there a function that can partition a list every n elemests, so that [a] -> Int -> [[a]]?
13:44:25 <qebab> elements, even
13:44:31 <conal> chessguy: yes, i think you could do with *just* the side-effect
13:44:54 <conal> chessguy: though i wouldn't call it a side-effect.  i'd call it a TreeLoc a -> TreeLoc a.
13:44:58 <chessguy> conal: the idea is that every action of the traversal has a side effect, but also returns the result, so that you can cut the traversal off at any arbitrary place
13:45:17 <chessguy> (and still get back the result)
13:45:31 <conal> chessguy: the node can always be extracted from the TreeLoc?
13:45:32 <chessguy> but of course i'm open to ideas
13:45:44 <chessguy> sure
13:45:45 <geezusfreeek> chessguy: ah, so you are just using the State (TreeLoc a) to chain together invokations of your TreeTraversal interpreter?
13:45:56 <chessguy> geezusfreeek: correct
13:46:07 <chessguy> (i think)
13:46:09 <ddarius> qebab: No, but it is commonly requested.  Usually it is called 'chunk'.  There is an implementation on the wiki somewhere, though it's also easy to implement yourself.
13:46:18 <conal> geezusfreeek: one clue that something is fishy is the 'getNode' in every traversal primitive.
13:46:33 <conal> oops -- that was for chessguy
13:46:55 <qebab> ddarius: shouldn't be too hard, and it won't hurt me to get some more practice :)
13:46:55 <chessguy> i suppose i could provide a way to chain them together and do the getNode at the end
13:47:03 <geezusfreeek> chessguy: yeah, it seems to me that you could simply compose your TreeTraversals beforehand and then use it in some function :: TreeTraversal -> Tree -> TreeLoc, or something like that
13:47:14 <conal> chessguy: i bet you could define TreeTraversal a = Endo (TreeLoc a)
13:47:27 <chessguy> what the heck is Endo?
13:47:35 <ddarius> qebab: Also, usually the argument order is Int -> [a] -> [[a]]
13:47:35 <dmwit> "function"
13:47:40 <conal> @src Endo
13:47:41 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:47:42 <ddarius> :t Endo
13:47:42 <conal> @src Data.Endo
13:47:42 <lambdabot> Source not found. I am sorry.
13:47:43 <lambdabot> forall a. (a -> a) -> Endo a
13:47:48 <dmwit> chessguy: Specifically, a function with the same domain and co-domain.
13:48:01 <conal> chessguy: with a newtype wrapper
13:48:12 <chessguy> conal: how would that help?
13:48:13 <gwern> wasm't Endp an ICFP character?
13:48:13 <edwardk> chessguy: he's an alien
13:48:15 <conal> chessguy: which means it's a monoid.  maybe other fun stuff.
13:48:21 <gwern> *Endo
13:48:29 <chessguy> edwardk: i was waiting for that joke
13:48:58 <conal> chessguy: forget about the 'Endo' remark for now.  try replacing 'State (TreeLoc a) a' with 'TreeLoc a -> TreeLoc a'
13:49:02 <gwern> yeah, he was last year's, I thought
13:49:43 <conal> chessguy: i think you'll get a simpler model, useful properties that are obviously correct, and almost no loss of convenience.
13:49:47 <chessguy> conal: that's easy enough. are you suggesting it will help with my extension problem?
13:49:51 <chessguy> (brb)
13:49:52 <edwardk> gwern: yeah, i had to work that weekend, didn't get to play =(
13:50:46 <qebab> ddarius: yeah, that makes more sense so I can say chunks2 = chunks 2 and so on :)
13:50:49 * gwern uploads a package to hackage. dum de dum
13:50:49 <gwern> I wonder how much of hackage I've uploaded?
13:51:00 <nolrai_> :t for
13:51:02 <lambdabot> Not in scope: `for'
13:51:09 <conal> chessguy: no, i'm not suggesting that.  just something that was bugging me after looking at that last line of code discarding the return value and then the previous one making up a value.  and then seeing up, down, etc, all ending with a getNode.  suggested to me that the whole getNode thing could be factored out.
13:51:12 <nolrai_> :t forM
13:51:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
13:51:16 <edwardk> gwern: i think you are probably the only user of a good 2/3rds of it ;)
13:51:56 * edwardk sometimes thinks gwern is an automated build-bot in disguise.
13:52:13 <gwern> edwardk: bah. does a librarian need to read all the books she preserves? :)
13:52:27 <gwern> whenever I fail a captcha, I think that too
13:52:55 <dmwit> "programmed to think it is real"
13:53:19 <edwardk> does anyone here actually care if category-extras will only build with 6.9?
13:53:46 <nolrai_> :t forM_
13:53:46 <conal> edwardk: what 6.9 language features does it use?
13:53:47 <dancor> haskell: the bleeding edge of reason
13:53:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
13:53:59 <chessguy> conal: i can also facter it out without removing the State stuff
13:54:08 <edwardk> class associated types, and I use Control.Category which was added to the library in 6.9
13:54:19 <chessguy> (i think)
13:54:39 <gwern> edwardk: I can't see who would; nobody is using it, so they can hardly be hurt if they can't use it on non-6.9 stuff, right?
13:55:10 <conal> chessguy: maybe.  personal note: i measure simplicity foremost by the central type.  if i can possibly simplify that type, the rest of my system becomes significantly simpler.
13:55:16 <geezusfreeek> edwardk: would the documentation for category-extras be useful for somebody who doesn't know category theory too well yet?
13:55:45 <edwardk> geezusfreek: thats one of the reasons i'm writing it, because it serves as a decent haskell introduction to kan extensions, etc. which are pretty opaque to most haskellers.
13:55:45 <conal> edwardk: thx.  i'm always curious about uses of recent language features.
13:56:11 <edwardk> conal: it makes a huge difference in readability of code that uses closed cartesian categories, etc.
13:56:16 <chessguy> conal: an interesting axiom
13:56:30 <conal> edwardk: nice!
13:57:17 * chessguy thinks soon we're going to see a book like Real World Category Theory
13:57:28 <chessguy> or at least Real World Abstract Algebra
13:57:33 <dancor> real world oxymorons
13:57:38 <Apocalisp> real world morons
13:57:44 <chessguy> dancor: except they're clearly not
13:57:45 <gwern> shoot... what's the ghc flag to get the library directory? I remember it was like 'ghc -lib-dir' or something
13:57:46 <schme2> What are "ropes" ?
13:57:46 <edwardk> my current main headache is i can't go back and redefine Functor to be more general so i have a 'pain point' when it comes to deciding how to interoperate with the standard library. currently i dumb most of my constructs down to only work on Hask.
13:58:01 <edwardk> chessguy: hrmm, good idea =)
13:58:25 <conal> schme2: string rep with efficient concatenation, i think.
13:58:47 <schme2> conal: Ok. Any idea where I find information on this?
13:58:49 <edwardk> Categories for the Working Class Programmer
13:59:19 <conal> nope.  i'd google for ropes, string, efficient, data structure.  that sort of thing
13:59:24 <edwardk> geezusfreeek: if you go through the fairly non-existent documentation for category-extras and have questions, ask! i'll go through and flesh out areas of it as you go
13:59:43 <chessguy> edwardk: i'd buy it, if it were well done
13:59:50 <gwern> ah, it was '--print-libdir'
13:59:51 <osfameron> ropes are vaguely related to enfilades iirc?
13:59:54 <gwern> having the ghc source can be handy :)
14:00:13 <edwardk> chessguy: i'll keep that it mind and think about writing it then =)
14:00:31 <geezusfreeek> i'd also buy it if it was good
14:00:49 <edwardk> woohoo: an audience of two, my publisher will be thrilled ;)
14:00:55 <chessguy> haha
14:00:55 <geezusfreeek> yeah buddy
14:01:33 <chessguy> oh conal , by the way, i'm hoping to write an article on this stuff for the next TMR, which means i have to have some thoughts together on paper by August 1
14:01:50 <conal> chessguy: cool!
14:03:15 <nolrai_> I want somthing of type [a] -> (a -> m (maybe b)) -> m b, does it already exist?
14:03:32 <opqdonut> :t filterM
14:03:35 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
14:03:35 <opqdonut> :t mapM
14:03:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
14:03:44 <opqdonut> a combination of those would probably work
14:04:33 <opqdonut> or you could just map with that (a -> m (maybe b)) and then "sequence . filter isJust"
14:05:13 <chessguy> conal: hmm. i'm not sure i buy your argument though. you're saying TreeLoc a -> TreeLoc a is a simpler type than State (TreeLoc a) a?
14:05:15 <edwardk> How helpful for locating errors:  src/Control/Category/Cartesian.hs:1:0: Occurs check: cannot construct the infinite type: c = Prod cat b c
14:05:25 <conal> chessguy: yes
14:05:27 <edwardk> i'll give a hint there error isn't on line 1 ;)
14:05:31 <chessguy> conal: why?
14:05:32 <geezusfreeek> chessguy: it is very very much simpler
14:05:41 <conal> chessguy: expand out the meaning of StateLoc
14:05:42 <chessguy> (i'm not disagreeing, just trying to understand)
14:05:50 <conal> chessguy: i mean of State
14:06:12 <conal> chessguy: i'm measuring semantic complexity not notational.
14:06:38 <chessguy> fair enough
14:06:52 <geezusfreeek> State (TreeLoc a) a expands to TreeLoc a -> (a, TreeLoc a)
14:07:04 <conal> chessguy: i'm glad you asked.  gave me a chance to clarify.
14:07:36 <schme2> Hmmm.. be readin' Real Worl Haskell here and I try: "I, B. Ionsonii, uurit a lift'd batch" =~ "(uu|ii)" :: [String] and I get a huge chunk of error message saying  No instance for (RegexContext Regex [Char] [String]) and other things. What am I doing wrong?
14:07:54 <conal> chessguy: semantic complexity can't be fixed with notation, only hidden.
14:09:00 <nolrai_> conal: thats not quite true if the notation is good enough to think in.
14:09:20 <conal> chessguy: so i always go for semantic simplicity, and then find nifty notation and implementation.
14:09:58 <chessguy> conal: stuff like this is why i need a mentor on this project
14:10:10 <conal> :)
14:10:11 <chessguy> conal: care to flesh out what you mean by 'semantic simplicity'?
14:10:18 <nolrai_> :t filterM
14:10:20 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
14:10:40 <Apocalisp> What do you use when you need a random-access list in Haskell?
14:10:54 <dmwit> Array
14:10:56 <schme2> Apocalisp: Another language ;)
14:11:07 <conal> chessguy: i'll try.  let's take a few primitive notions: integers, functions and pairs.
14:11:10 <dmwit> Apocalisp: But you rarely *need* a random-access list.
14:11:19 <Apocalisp> well, say you want to write a parallel fmap
14:11:20 <osfameron> a tree
14:11:21 <dmwit> Apocalisp: May I humbly suggest considering another approach?
14:11:32 <dmwit> Apocalisp: This has worked for me more times than I like to admit.
14:11:46 <geezusfreeek> an Array also works
14:11:53 <conal> chessguy: we think about them, study math, whatever.  and we get a grasp of these essentials.  (throw in a few others if you want, such as strings and lists.  but definitely not IO.)
14:12:02 <geezusfreeek> oh, it was the first answer
14:12:16 <Apocalisp> I'm open to considering a different approach.
14:12:32 <Apocalisp> That's one of my favourite things to do :-)
14:12:41 <conal> chessguy: then when designing, define the meaning of your model in these terms (pairs, functions, ...).
14:12:48 <geezusfreeek> Apocalisp: that seems to be something a lot of haskeller share
14:12:51 <geezusfreeek> *haskellers
14:13:24 <schme2> Should I maybe reinstall GHC to see if this regexp thing works better then?
14:13:26 <conal> chessguy: one rough cut at simplicity is the size of that type expression.
14:14:06 <conal> chessguy: though there are helpful refinements, e.g., weighting a function type in the domain of a function more than in the range (currying).
14:14:21 <dmwit> > 3^7
14:14:22 <lambdabot>  2187
14:14:23 <Apocalisp> So I have a list of values and I want to map a (very expensive) function over those values simultaneously.
14:14:51 <Apocalisp> I'm actually lying a little bit. I have a list of IO actions.
14:14:51 <geezusfreeek> :t parMap
14:14:52 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
14:15:00 <geezusfreeek> Apocalisp: ^
14:15:03 <geezusfreeek> oh
14:15:06 <geezusfreeek> io
14:15:06 <Apocalisp> oooh
14:15:21 <geezusfreeek> i suspect IO changes things
14:15:28 <conal> chessguy: in your implementation, you might use this semantic model as your representation (makes things easy to reason about) or not.  even if not, you'll have a reference model that defines correctness of your implementation.
14:15:32 <geezusfreeek> because you would need to forkIO for each thread
14:15:43 <gwern> is said function pure?
14:15:51 <geezusfreeek> instead of using the nice par-derived strategies
14:15:51 <Apocalisp> geezusfreeek: I'm still kind of lying.
14:16:03 <geezusfreeek> Apocalisp: you dirty trickster
14:16:05 <gwern> Apocalisp: you dirty dog! now you must repent and use threads
14:16:24 <conal> chessguy: how's that for a start?
14:16:31 <gwern> ...how could the situation be *worse* than a list of IO stuff?
14:16:50 <chessguy> conal: pretty abstract
14:17:00 <chessguy> @pl \x -> f x . g
14:17:00 <lambdabot> (. g) . f
14:17:15 <Apocalisp> gwern: It's not haskell. That's how.
14:17:22 <edwardk> gah found it, it was buried in a RULE
14:17:43 <geezusfreeek> so you need a parMapM or something? seems like that would be… unreliable
14:17:51 <geezusfreeek> at best
14:18:04 <conal> chessguy: :)  as a concrete example, expand the meaning of your 'State (TreeLoc a) a' and compare with the one i suggested.
14:18:20 <gwern> geezusfreeek: well, the real problem with mapping a forkIO over a long list of stuff is that when 'main' exits, all the threads are killed
14:18:29 <chessguy> conal: yes, i can see why that's more complex, in this specific case
14:18:58 <geezusfreeek> gwern: well, it isn't too hard to merge back if you watch your plumbing
14:18:59 <edwardk> @hpaste
14:18:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:19:09 <Apocalisp> gwern: I'm kind of OK with that. 'main' is not going away during my call.
14:19:17 <conal> chessguy: then switching to the simpler model will also simplify the meanings of everything that works with the model (up, down, f, ...)
14:19:31 <chessguy> fair enough
14:19:34 <gwern> geezusfreeek: no, but it's annoying and a subtle issue. when I ran into that with a wikipedia bot, it took a while to diagnose why my program was running so very fast but doing nothing
14:19:40 <geezusfreeek> some sort of foldM over the resulting list of ThreadIds would work fine
14:19:47 <chessguy> conal: it seems to turn Seq es into a fold of some type
14:19:48 <edwardk> hrmm: this looks bad http://hpaste.org/7703
14:20:11 <conal> chessguy: i'm guessing you can replace Seq with a simple binary operation.
14:20:21 <conal> chessguy: which would probably be mappend
14:20:24 <Apocalisp> " my program was running so very fast but doing nothing" <- The inverse infinite recursion.
14:20:41 <gwern> Apocalisp: well, is there anything from stopping you from mapping forkIO over the list? it's the simplest approach, in a way
14:21:10 <Apocalisp> I'm not sure yet. Thanks for the suggestions.
14:21:20 <geezusfreeek> Apocalisp: i think we could help better if you tell us what you are trying to do
14:21:32 <vixey> impossible
14:21:33 <Zao> map a wrapper around it that gathers the threadids into a channel and lets you join them later?
14:21:34 <geezusfreeek> perhaps suggest a better alternative
14:21:39 <nolrai_> :t foldr
14:21:40 <conal> chessguy: and it'd be swell if: f (t `mappend` t') == f t `mappend` f t' .  or substitute some other really familiar function for the second mappend.
14:21:41 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:21:48 <gwern> Apocalisp: well, I actually mean 'running and exiting so very fast' if you follow
14:21:52 <conal> chessguy: (familiar and simple)
14:22:05 <Apocalisp> gwern: ;-)
14:22:16 <chessguy> conal: you mean for the sake of making it easy for clients of the library to see how it works?
14:22:35 <conal> chessguy: not exactly.  for giving a precise and compelling semantics to you types.
14:23:05 <conal> chessguy: if you look at my paper "simply efficient functional reactivity", you'll see the notion of "type class morphisms" and some examples of it.
14:23:21 <conal> chessguy: i've come to see this notion as a very helpful design guide.
14:24:00 <conal> chessguy: if my main functions are type class morphisms, i know i'm onto something beautiful.  otherwise, i look for a beter design.
14:24:10 <dons> dcoutts: solved the last issue -- we have to specialise the strict pairs in the accumulator to the ytpe
14:24:17 <dons> then we get unboxed returns in registers
14:24:23 <dcoutts> hmm
14:24:28 <dons> and foldlU  . enumFromTo produces identical code to gcc -O2
14:24:35 <dons> i've added info to the ticket
14:24:44 <dons> we really need this to work though
14:25:08 <dons> data T a b = T {-# UNPACK #-} !a {-# UNPACK #-} !b
14:25:08 <chessguy> @pl \tt tr -> g $ (i tt) (a tr)
14:25:08 <lambdabot> (g .) . (. a) . i
14:25:17 <dons> should specialise if the only use is T Double Int, and its strict
14:25:33 <conal> hey -- i've seen the pattern "(g .) . (. a)" a lot
14:25:39 <conal> when g and a are inverses
14:25:44 <dons> so local definitions of T for accumulators specialised helps
14:25:46 <dcoutts> dons: ah yes, unpack means nothing currently for polymorphic fields
14:25:46 <conal> like constructor and deconstructor
14:26:03 <vixey> :t (?f .) . (. ?g)
14:26:05 <lambdabot> forall b a b1 (f :: * -> *). (?g::f a, Functor f, ?f::b1 -> b) => (a -> b1) -> f b
14:26:08 <dons> dcoutts: right. and the unbxoing that looks like it should work doesn't.
14:26:10 <schme2> GAH. well ok guys and dolls, is there something else to read than this real world haskell.. preferably something where the examples actually work .. ?
14:26:14 <dons> so at least this gives us a workaround
14:26:26 <chessguy> conal: they are indeed inverses here
14:26:27 <dons> but not for the general case of fused functions, which have lots of polymorphic strict pairs
14:26:42 <dcoutts> dons: but I think that's not the problem, we should get the unboxing anyway with worker/wrapper I think
14:26:45 <dons> schme2: examples not working in the book!?
14:26:46 <conal> chessguy: :) !
14:26:48 <geezusfreeek> conal: reminds me of some sort of functor operation
14:26:49 <chessguy> conal: getNode and addZipper
14:26:50 <dons> dcoutts: right.
14:26:52 <schme2> dons: Yes.
14:26:58 <schme2> dons: Several of them.
14:27:05 <dons> schme2: that's scary. did you add comments to the chapters?
14:27:09 <dcoutts> dons: even if we used (,) and the strictness analysis worked out that it was strict in both components
14:27:10 <dons> you're not using hugs, are you?
14:27:22 <dons> dcoutts: right. i'm keen to hear what SPJ says here.
14:27:24 <conal> i like to write inFoo = (Foo .) . (. unFoo)
14:27:29 <schme2> dons: I have no idea how I add comments to chapters, and no I use ghc 6.8.2
14:27:30 <dons> looks like it might not be too hard -- its right up his alley.
14:27:45 <dons> schme2: ok. so the online chaptes have a comment system
14:27:50 <dons> you just click on the paragraphs to add comments
14:27:52 <conal> then inFoo transforms a Foo but i only have to write code for the representation inside a Foo.
14:28:02 <dons> which go back to the authors (me, bos, CosmicRay), who fix things.
14:28:04 <schme2> dons: No. That does not work for me.
14:28:12 <conal> but it works with any view/representation pair
14:28:18 <dcoutts> dons: schme2 uses lynx :-)
14:28:21 <dons> ok. so you should then send an email to the realworldhaskell mailing list.
14:28:23 <conal> (or whatever those guys are called)
14:28:25 <schme2> dons: I seem to recall talking about this commentary stuff some time ago and it required javascript.
14:28:44 <dons> right. sorry. that's the small price we pay for online commenting
14:28:47 <schme2> Cools. Where is that mailing list?
14:28:55 <dons> check the blog, realworldhaskell.org
14:28:57 <dons> which has addresses
14:29:11 <geezusfreeek> @pl \f g -> (f .) . (. g)
14:29:11 <lambdabot> (. flip (.)) . (.) . (.)
14:29:13 <chessguy> conal: in this case, you're talking about inZipper
14:29:28 <schme2> dons: It is this   "mondegreen" =~ pat :: [(Int,Int)]    and other things that are totally not working.
14:29:30 <chessguy> conal: so i suspect that the real beauty of what you're seeing here is in the zipper itself
14:29:30 <conal> chessguy: nice!
14:29:32 <dons> dcoutts: but at least i managed to write a fold that worked :)
14:29:39 <dcoutts> dons: yay
14:29:43 <schme2> :: [ByteString] too
14:30:33 <dcoutts> dons: I've been hacking on my dep resolver, got it working for easy cases, like xmonad. Now working on installing all of hackage simultaneously (which is probably impossible).
14:30:35 <dons> looks ok..
14:30:40 <dons> schme2: what version of the regex library do you have?
14:30:45 <dons> dcoutts: wow.
14:30:52 <schme2> dons: I have no idea whatsoever.
14:30:58 <dons> let me know if you want us to test things at work. i'm trying to get more cabal-install adoption
14:31:18 <schme2> dons: How do I check what version it is?
14:31:31 <dcoutts> dons: hackage is the biggest test case for dep resolving, but for things like build reporting internal use might be quite helpful
14:31:32 <geezusfreeek> :t \f g -> (f .) . (. g)
14:31:34 <lambdabot> forall b a b1 (f :: * -> *). (Functor f) => (b1 -> b) -> f a -> (a -> b1) -> f b
14:31:40 <geezusfreeek> oh somebody already did that
14:31:44 <dcoutts> schme2: ghc-pkg list $pkgname
14:32:09 <dons> dcoutts: note this stuff affects the partial-sums shootout program, which has a heap check in what i thought was a tight inner loop
14:32:17 <dcoutts> schme2: or just "ghc-pkg list" to list everything
14:32:22 <dons> which i can now work around with a monomorphic strict tuple
14:32:26 <gwern> hm. suppose I have a Cabal datatype, and I have one entry 'Compiler/Interpreter'; obvioulsy I can't just name one of the constructors that since it won't parse; but how can I get Show to turn 'Compiler_Interpreters' into "Compiler/Interpeters"?
14:32:31 <schme2> Right... 0.93.1
14:32:33 <dcoutts> dons: I'm sure there's an open report on the heap check thing
14:32:40 <dons> yeah. i expect so.
14:32:45 <chessguy> conal: http://hpaste.org/7704
14:32:54 <dcoutts> dons: but I might be mis-remembering, I recall talking to JaffaCake about it
14:32:55 * conal looks
14:33:13 <chessguy> conal: i suspect the latter is what you meant
14:33:24 <conal> chessguy: neither.
14:33:27 <geezusfreeek> ooh, both are interesting
14:33:56 <geezusfreeek> those don't appear to be inverse functions to me…
14:33:59 <conal> chessguy: what i'm talking about always looks like ((a->a) -> (b->b))
14:34:05 <dcoutts> gwern: I'm not sure I really follow, can you be more specific?
14:34:15 <dcoutts> gwern: what data type?
14:34:24 <schme2> D
14:34:27 <schme2> gah
14:34:29 <conal> chessguy: or ((Foo a -> Foo b) -> (Bar a -> Bar b))
14:34:34 <schme2> I'll just build a new ghc and see if it works better.
14:34:40 <gwern> dcoutts: ah heck, I'll hpaste it
14:34:45 <chessguy> hm
14:34:47 <dons> dcoutts: fusion matches gcc -O2 :)  an example, http://hpaste.org/7705
14:35:23 <conal> chessguy: but maybe i'm used to seeing a more specific pattern rather than the general one.
14:35:25 <dcoutts> dons: nice
14:35:47 <dcoutts> gwern: ta
14:35:48 <geezusfreeek> conal: my category theory is very bad, but i can't help but think that looks like some sort of natural transformation, or perhaps something else i have seen somewhere
14:35:55 <gwern> dcoutts:  http://hpaste.org/7706#a1
14:35:59 <conal> phew!  it's feeling like summer here in CA
14:36:05 <dons> ?weather
14:36:06 <lambdabot> Unknown command, try @list
14:36:08 <dons> oh, wrong bot.
14:36:17 <dons> 14:36  lambdabot> Current Conditions - 93.7F / 34.3C | Clear - 2:36 PM PDT May. 17
14:36:21 <dons> hot hot hot.
14:36:22 <vincenz> dons: I think the C is faster due to better jumps
14:36:27 <conal> geezusfreeek: probably so.  at least a commuting diagram.
14:36:28 <dons> first real heat since I moved from sydney :)
14:36:37 <vincenz> dons: that could probably be fixed with a better code layout-system
14:36:43 <dons> vincenz: yep.
14:37:10 <dons> actually, i've got a more complicated example where ghc wins
14:37:32 <geezusfreeek> very nice outside here right now: Huntsville, AL (35816) Mostly Cloudy 74F
14:37:33 <vincenz> dons: just nice to know that it's not a complicated problem that remains to make it par here :)
14:37:54 <dons> right. its damn close now.
14:37:58 <vincenz> basically a graph transfo on the cdfg
14:38:14 <halberd> if every variable was only allowed to be used once when passed as the argument to a destructive function, that would still be referentially transparent
14:38:16 <dcoutts> gwern: so you're trying to make a Show instance that shows it a bit differently but you'd like to use mostly the derived Show
14:38:30 <gwern> dcoutts: I'm sure there's some simple way to do it - all I want to do is override the Show derivation for one bit of the ADT
14:38:33 <halberd> i.e. X = X + 1 is referentially transparent if it is the only use of X
14:38:37 <sjanssen> gwern: seems to me that a separate function would be the best way to do it
14:38:53 <dcoutts> gwern: to be honest, I'd not bother. I'd not use a enumeration type at all. Just make a list/map of category strings.
14:39:09 <sjanssen> gwern: eg. data Foo = ... deriving Show; prettyShow CaseThatIsSlightlyDifferent = "asdf"; prettyShow x = show x
14:39:15 <gwern> sjanssen: hm, you mean just define 'show Interpreters_Compilers = "Interpreters/Compilers"'? but then that'll get me major conflicts
14:39:29 <halberd> that would allow you to have destructive operations that return the mutated object
14:39:40 <sjanssen> gwern: do you follow that example?
14:39:41 <halberd> so long as you only use the variable once before the operation
14:40:12 <gwern> sjanssen: I think so. the function show has to be specified, so I can go around and replacement it with my wrapper
14:40:12 <halberd> referential transparency would be preserved with a possible speed bonus
14:40:26 <gwern> kind of an ugly solution... is there no GHC extension which can save me? :)
14:40:30 <vixey> halberd: Do you have a prototype?
14:40:35 <chessguy> @type \x -> foldl' ($x)
14:40:36 <sjanssen> gwern: why do you have to use Show?
14:40:37 <lambdabot>     Occurs check: cannot construct the infinite type: b = b1 -> a -> b
14:40:37 <lambdabot>     Probable cause: `$' is applied to too many arguments
14:40:37 <lambdabot>     In the first argument of `foldl'', namely `($ x)'
14:40:39 <halberd> no I'm just throwing the thought out there
14:40:49 <gwern> sjanssen: printing out to the cabal file
14:41:01 <vincenz> dons: what's 5(%rbx) ?
14:41:04 <vincenz> dons: is that an indirect access?
14:41:05 <dons> a more complicated example, http://hpaste.org/7705#a1
14:41:13 <sjanssen> gwern: dcoutts is right, I think -- just use Strings
14:41:19 <dons> vincenz: don't know. we should work out what's going on.
14:41:36 <gwern> well, I suppose I might as well
14:41:48 * gwern darns mkcabal for having so few categories
14:41:49 <chessguy> @type foldr ($)
14:41:49 <vincenz> or .LC0(%rip)
14:41:50 <lambdabot> forall b. b -> [b -> b] -> b
14:41:59 <halberd> i.e. if x = 3 and you have a destructive operation incr that increases the value of x, then incr(x) is referentially transparent so long as x is never used anywhere else but as the argument to incr in that one place
14:42:46 <chessguy> > foldr ($) 2 [(* 18), subtract 1]
14:42:47 <lambdabot>  18
14:42:56 <halberd> no, that's not quite right because x could be part of something else
14:43:14 <halberd> some larger data structure
14:43:19 <chessguy> > foldl ($) 2 [(* 18), subtract 1]
14:43:19 <lambdabot>      Occurs check: cannot construct the infinite type: b = a -> b
14:43:19 <lambdabot>     Probabl...
14:43:20 <edwardk> @hpaste
14:43:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:43:42 <chessguy> > foldl' ($) 2 [(* 18), subtract 1]
14:43:42 <lambdabot>      Occurs check: cannot construct the infinite type: b = a -> b
14:43:43 <lambdabot>     Probabl...
14:43:46 * chessguy sighs
14:43:52 <chessguy> i hate folds
14:44:00 <dons> jso i think i'll present the fold version early in the week, showing the performance and issues involved
14:44:10 <dons> and then maybe finish the series with a fast md5.hs :)
14:44:11 <shachaf> > foldl (flip ($)) 2 [(* 18), subtract 1]
14:44:12 <lambdabot>  35
14:44:28 <EvilTerran> ?type foldl1' (.) [(*18), subtract 1]
14:44:30 <lambdabot> forall a. (Num a) => a -> a
14:44:43 <EvilTerran> ?type foldl' ($) 2 [(*18), subtract 1]
14:44:45 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
14:44:45 <lambdabot>     Probable cause: `$' is applied to too many arguments
14:44:45 <lambdabot>     In the first argument of `foldl'', namely `($)'
14:44:49 <EvilTerran> um
14:45:03 <edwardk> does someone with 6.9 feel like looking at http://hpaste.org/7707 and pointing out that i'm making a stupid error and that the bug is in my rewrite rules and not GHC?
14:45:03 * EvilTerran notes shachaf has beaten him to the punch, and wanders off
14:45:35 <dons> edwardk: note that rules are flakey unliness you put NOINLINE or INLINE [1] or later on the things you wish to match on
14:45:47 <dons> but no, they look fine.
14:46:10 <edwardk> dons: i'm ok with them being flaky but they shouldn't trigger a PANIC regardless, no?
14:46:12 <dons> edwardk: i'm using rules and type familes in the uvector library without trouble
14:46:15 <dons> no panics, no.
14:46:28 <edwardk> dons: hence my confusion.
14:46:39 <dons> oh, associated type synonyms
14:46:42 <dons> do they work?
14:46:47 <edwardk> note though that you have a rewrite rule that 'round trips' through two different class associated types
14:46:48 <dons> i've only tried newtypes and data.
14:46:58 <edwardk> they are in, i've been using them quite a bit in 6.9
14:47:12 <dons> class UA e where data UArr  e data MUArr e :: * -> *
14:47:12 <dons> -- |Yield the length of an unboxed array lengthU        :: UArr e                     -> Int
14:47:18 <dons> ok.
14:47:22 <conal> edwardk: show us some code!
14:47:33 <chessguy> @pl \tl -> foldl (flip ($)) tl (map interpret es)
14:47:33 <lambdabot> flip (foldl (flip id)) (map interpret es)
14:47:33 <dons> they're the hardest of the three, so could still be buggy.
14:47:40 <edwardk> conal: http://hpaste.org/7707
14:47:51 <Peaker> conal, hey.. I finally understood what you were trying to say yesterday night (when I sat with simony)
14:47:56 <conal> edwardk: thx.
14:48:06 <chessguy> id?
14:48:06 <conal> Peaker: !
14:48:08 <chessguy> wtf
14:48:14 <edwardk> dons: the usecase there works with data families, but not with types, so they appear to still be buggy
14:48:22 <conal> Peaker: i'd like to hear what you understood
14:48:23 <chessguy> where did that id come from?
14:48:24 <edwardk> if you swap 'type' for 'data' it works
14:48:26 <dons> ah good to know.
14:48:39 <dons> ok, so now you've got a bug report for manuel.
14:48:44 <conal> edwardk: and an instance?
14:49:05 <Peaker> conal, if I understood correctly, you would agree that a functional algorithm (equivalent to a computational graph) is a syntax to encode a function (which is basically a mapping)
14:49:07 <edwardk> conal: oh you want an instance that actually implements that? =)
14:49:33 <conal> Peaker: more or less.
14:49:48 <edwardk> conal: drop the words 'co' everywhere and you can flip that around to work for a closed cartesian category, this was just the case where it crashed because it was the first one in the file.
14:50:00 <Peaker> conal, The thing is, I think that algorithms are practical to view, edit and review, and functions are not
14:50:01 <conal> edwardk: well, if you have one.  but no big deal.  i'm tickled that associated type synonyms are in.
14:50:13 <edwardk> conal: one sec. i'll flip it and give you a CCC version
14:50:15 <conal> Peaker: of course.
14:50:34 <Peaker> conal, displaying a "fused function" only as a mapping, and not as an algorithm is not a practical approach, imo
14:51:07 <conal> Peaker: i agree.  even if you drop the ", and not as an algorithm"
14:51:12 <Peaker> conal, in other words, you will want to show the function/mapping as a computational graph - and the only practical one you have is the one the user used to generate the function
14:51:36 <conal> Peaker: oops -- that's a jump i can't agree with.
14:51:55 <conal> Peaker: sounds like the closed world assumption.
14:52:00 <Peaker> conal, well, you do agree that you have to display the function as an algorithm?
14:52:27 <Peaker> conal, if not, how else?
14:52:36 <conal> Peaker: no.  "have to" is pretty strong.  it's an obvious candidate, but i wouldn't know how to prove there aren't alternatives.
14:53:16 <Peaker> conal, Do you believe there is a practical non-algorithmic way to view functions?
14:53:43 <conal> Peaker: non-algorithmic == non-syntactic ?
14:54:31 <Peaker> conal, I am trying to avoid the word "syntax", I have a different idea of what "syntax" generally means... Anything you display on screen is a "syntax"
14:54:37 <Peaker> or encoded using one
14:54:56 <edwardk> conal: http://hpaste.org/7707#a2
14:55:09 <conal> Peaker: "view functions" == "create related functions" ?  or maybe == "revise decisions made in reaching a denotation"?
14:55:18 <Peaker> conal, by non-algorithmic, I mean a view of the function that does not show a computational graph (algorithm) that generates that mapping
14:55:25 <conal> edwardk: lovely!
14:55:26 <Peaker> conal, the latter
14:55:33 <Peaker> conal, or actually both :)
14:55:43 <conal> associated types are going to be so fun!
14:55:43 <edwardk> conal: the instance for the other one is hard coz i would have had to undumb down the example enough to have dual categories handy so i could define an instance.
14:55:47 <chessguy> conal: i've succeeded in swapping out that type
14:56:01 <conal> chessguy: let's see
14:57:23 <chessguy> conal: http://hpaste.org/7708
14:57:55 <edwardk> conal: http://comonad.com/haskell/categories/src/Control/Category/Cartesian/Closed.hs is the original http://comonad.com/haskell/category-extras/src/Control/Category/Cartesian/Closed.hs is the current version i'm hacking on
14:57:56 <lambdabot> http://tinyurl.com/5nho3x
14:58:00 <conal> Peaker: i'm having to guess a bit at your meaning of "graph (algorithm)", but i'd say yes, i expect there are alternatives that are friendlier to right-brain creativity.  your choice (a graph) is fine for the a verbal mode.
14:58:32 <conal> chessguy:  super!
14:58:36 <conal> chessguy: do you like it?
14:58:47 <geezusfreeek> chessguy: that is looking a lot nicer now!
14:58:55 <Peaker> conal, well, maybe there are, but until those are discovered, aren't we stuck with showing functions as computational-graphs in order to be able to revise decisions or created related functions?
14:59:03 <conal> chessguy: how about replacing Seq with a binop and unit, whose meanings are (.)  and id ?
14:59:15 <chessguy> ummm
14:59:30 <conal> Peaker: i buy that.
14:59:39 <chessguy> conal: you mean instantiating Monoid?
14:59:46 <chessguy> @src Monoid
14:59:46 <lambdabot> class Monoid a where
14:59:46 <lambdabot>     mempty  :: a
14:59:46 <lambdabot>     mappend :: a -> a -> a
14:59:46 <lambdabot>     mconcat :: [a] -> a
15:00:11 <conal> Peaker: rephrased: until we know how to solve a problem differently, we're stuck with our old solutions.
15:00:29 <conal> chessguy: yes, as a second step
15:00:36 <Peaker> conal, I wouldn't say its the old solution.. Its a new solution in many many aspects.
15:01:02 <conal> Peaker: new in some aspects & old in others.
15:01:16 <Peaker> conal, for example, we store and use the UI to edit directly a much higher-level encoding (computational graph) rather than storing and editing a low-level encoding (grammar/characters)
15:01:24 <conal> chessguy: for a first step, i suggest replacing the Seq constructor with two simpler constructors.
15:01:54 <Peaker> conal, we also remove a large set of ideas from our semantics (namespaces and names, for example, as links are not generated via unique names)
15:02:00 <conal> Peaker: sorry.  i didn't mean to nullify your innovative ideas.  i was just focusing on a different aspect
15:02:24 <conal> Peaker: great
15:02:56 <monochrom> Instead of names you could use icons.
15:03:12 <monochrom> Like a picture of a trash can standing for "My Computer".
15:03:20 <Peaker> conal, no problem, I think we can generally agree now, except maybe I am less optimistic about useful different representations of functions being found :)
15:03:26 <chessguy> conal: i see what you mean about the binop meaning (.), but i'm not sure about the unit meaning id
15:04:00 <conal> chessguy: "unit" is probably not a suggestive name.  try "zero"
15:04:16 <chessguy> oh, a noop?
15:04:21 <conal> exactly
15:04:25 <Peaker> conal, simony also insists that properties like runtime/memory-use which are different in differing algorithms are lost and ignored in a representation that keeps only the mapping of functions, without their algorithm
15:04:43 <Peaker> conal, so you might imply a wrong equivalence
15:07:25 <chessguy> conal: that was easy: http://hpaste.org/7708#a1
15:08:07 <conal> chessguy: :)  i like it.  do you?  add the Monoid instance.
15:08:38 <conal> chessguy: then you'll see that interpret is (spiritually) a monoid morphism
15:09:50 <conal> chessguy: also, once TreeTraversal is a monoid, you can use it in the writer Applicative, i.e., (,) TreeTraversal, which is very handy.
15:10:30 <conal> chessguy: a lovely way to factor an algorithm that traverses while doing something else.
15:11:12 <chessguy> @hoogle Monoid
15:11:12 <lambdabot> Data.Monoid :: module
15:11:12 <lambdabot> Data.Monoid.Monoid :: class Monoid a
15:11:42 <conal> chessguy: also see Control.Applicative, particularly the ((,) o) instance for arbitrary monad o.
15:12:02 <conal> chessguy: you may have seen this trick in it's less general form: WriterT
15:12:09 <conal> (s/it's/its)
15:12:15 <chessguy> conal: Applicative is way over my head
15:12:28 <chessguy> i'm still scratching my head over mconcat
15:12:34 <conal> chessguy: sadly, there aren't simple tutorials.  Applicative is actually way simpler than Monad
15:12:41 <geezusfreeek> chessguy: Applicative is actually pretty simple.
15:13:02 <geezusfreeek> chessguy: it is barely more complicated than functor
15:13:23 <conal> chessguy: here's a simple way to learn Applicative: change your monadic code so you use liftM, liftM2, ap, instead of (>>=)/do.
15:13:56 <Peaker> Applicative is like a Functor, except it can also apply a function when the function is wrapped in the container too, right?
15:14:10 <geezusfreeek> chessguy: the most important thing to understand is that you have fmap and <*>, and you can use <*> to apply wrapped functions to wrapped values
15:14:38 <geezusfreeek> fmap for applying unwrapped functions to wrapped values
15:14:57 <conal> chessguy: e.g., a list of functions to a list of arguments.  or a time-varying function to a time-varying argument.
15:15:21 <conal> or an image of functions to an image of arguments
15:15:27 <conal> (visual image)
15:15:35 <conal> (well, 2D image)
15:16:07 <geezusfreeek> conal: which sounds like a neat way to represent image filters, actually
15:16:08 <nolrai_> an 2D image of a function?
15:16:17 <conal> geezusfreeek: it is!  see Pan
15:16:21 <chessguy> ok, i've got the Monoid instance
15:16:23 <conal> geezusfreeek: that's how i do filters
15:16:27 * geezusfreeek checks out Pan
15:16:49 * chessguy goes digging in his cupboards....oh, not that kind of pan? :)
15:17:00 <conal> geezusfreeek: and works on parametric surfaces
15:17:03 <conal> :)
15:17:07 <geezusfreeek> conal: :o
15:17:53 <conal> chessguy:  let's see the instance
15:17:56 <geezusfreeek> conal: this is sexy. i don't know how this slipped under my radar
15:18:32 <conal> geezusfreeek: it's wonderful magic!  i was delighted when i read the Applicative paper, because i recognized it as how i structured functional animation *and* functional image synthesis
15:18:38 <chessguy> conal: http://hpaste.org/7708#a2
15:19:14 <chessguy> @where pan
15:19:14 <lambdabot> I know nothing about pan.
15:19:44 <conal> chessguy: thx.  now how about dropping the DoAll constructor.  looks redundant to me.
15:19:45 <Peaker> is it possible to define an instance of Applicative and let it figure out how to do fmap? In other words, to specify that Applicative does not only extend Functor it also implies it?
15:19:56 <chessguy> conal: oh?
15:20:08 <geezusfreeek> chessguy: wait, what's the semantic difference between DoAll [a, b, c] and a `Sequence` b `Sequence` c?
15:20:22 <conal> yeah.
15:20:25 <chessguy> well, it's convenience
15:20:41 <conal> chessguy: i bet it'll be more of an inconvenience.
15:20:46 <geezusfreeek> chessguy: i wouldn't put redundancies in an ADT if i don't have to
15:20:51 <conal> chessguy: keep mconcat for the convenience.
15:20:52 <geezusfreeek> i prefer Sequence, personally
15:21:50 <conal> i'd make the semantics of each constructor as simple as possible.  and entirely orthogonal.
15:22:16 <conal> if i can replace a constructor with one or two with simpler semantics, i do it.
15:22:37 <conal> not sure i can explain why, right now.
15:22:45 <chessguy> conal: err...so mconcat is now some kind of foldr over Sequence?
15:22:46 <geezusfreeek> chessguy: basically, doAll is a fold, and you might as well just use the nice fold functions that haskell already has
15:23:00 <conal> chessguy: eliminate Sequence altogether.
15:23:10 <conal> chessguy: and use the *default* definition of mconcat
15:23:21 <geezusfreeek> conal: don't you mean eliminate DoAll?
15:23:21 <chessguy> oh!
15:23:42 <conal> chessguy: yes.  DoAll
15:23:50 <chessguy> geezusfreeek: yeah, i've been flippant about how i've been using Sequence
15:24:01 <chessguy> @src mconcat
15:24:01 <lambdabot> Source not found. I am sorry.
15:24:18 <chessguy> @source Data.Monoid
15:24:18 <lambdabot> http://darcs.haskell.org/packages/base/Data/Monoid.hs
15:24:18 <conal> thx.  "sequence" conjures up a sequence for me.  rather than (binary) "sequencing"
15:24:20 <sioraiocht>  
15:25:14 <conal> chessguy: btw, i'd be careful not to use "Do" in any of these names.  it may tip you unconsciously toward imperative thinking habits.
15:25:14 <chessguy> mconcat = foldr mappend mempty -- heh. that's just ridiculous :)
15:25:35 <conal> chessguy: yeah!  exactly the right thing, without you having to write it!
15:25:41 <geezusfreeek> chessguy: :)
15:25:58 <chessguy> conal: well, the client code will be pretty imperative, i suspect
15:26:12 <geezusfreeek> chessguy: probably doesn't have to be
15:26:14 <conal> chessguy: only if you tip it that way.
15:26:17 <conal> :)
15:26:30 <geezusfreeek> alright, time to work on futures!
15:26:34 <conal> chessguy: beware confusing "natural" with "habitual", as gandhi said.
15:26:36 <chessguy> ok, mconcat is nuked
15:26:46 <conal> geezusfreeek: please do :)  i'm curious how it will come out.
15:26:49 <geezusfreeek> conal: happen to have done anything interesting since your last email?
15:27:03 <conal> geezusfreeek: this morning's email?
15:28:23 <geezusfreeek> yes
15:28:33 <sclv> would i be totally wrong to describe the clisp loop macro as a monadic catamorphism over a recursively defined tree?
15:28:34 <conal> geezusfreeek: lots of interesting stuff, but not related.  i'm working on generalizing derivatives to handle higher-dimensional domains elegantly.  ("multi-variate", but i don't like the syntax/semantics confusion i hear in tha term).
15:28:50 <conal> geezusfreeek: will be in two upcoming blog posts.  parts 2 and 3 of "beautiful derivatives"
15:29:02 <wolverian> I wonder if I should try cabal-install again. last time I used it, I ran into some problems / my confusion over how to configure it to install things locally.
15:29:21 <geezusfreeek> conal: sweet! i was just checking to make sure you hadn't had any revelations on the IVar stuff that would be good to know about before i tackle it again
15:29:24 <conal> geezusfreeek: the immediate applications are a the functional 3d library that andy gill & i are developing.
15:29:25 <dcoutts> wolverian: it now does local install by default into ~/.cabal/
15:29:38 <roconnor> > round 1.5
15:29:39 <lambdabot>  2
15:29:44 <roconnor> > round 2.5
15:29:46 <lambdabot>  2
15:29:47 <dcoutts> wolverian: you have to use the darcs version though, not the one on hackage
15:29:57 <conal> geezusfreeek: yeah -- your new rep really got me inspired!  it was those teases of common patterns from type composition and type class morphisms.
15:30:02 <geezusfreeek> conal: as you might imagine, a functional 3d library would fit in with what i'm doing very well :)
15:30:07 <opqdonut> roconnor: wow
15:30:20 <opqdonut> :t float
15:30:20 <conal> geezusfreeek: i imagine.  i forget the specifics of what you're doing.
15:30:22 <lambdabot> Float -> Doc
15:30:22 <opqdonut> gah
15:30:25 <opqdonut> :t round
15:30:27 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
15:30:30 <conal> geezusfreeek: more & more people are interested in functional 3d.  :) :)
15:30:30 <geezusfreeek> conal: games
15:30:37 <roconnor> opqdonut: that is IEEE I believe
15:30:38 <opqdonut> roconnor: does defaulting make 1.5 a float?
15:30:38 <stepcut> is there an ANSI-C backend in the works for GHC ?
15:30:44 <opqdonut> roconnor: yeah, closest float
15:30:56 <wolverian> dcoutts, mm. I think it did that for me, but then I was unsure how to use those packages. I think there were problems with ghc not seeing them. shrug. I'll just try again :)
15:30:58 <opqdonut> i guess Rational doesn't implement RealFrac
15:30:59 <roconnor> > round (2.5::Rational)
15:31:01 <lambdabot>  2
15:31:04 <conal> geezusfreeek: cool.  i'll let you know how it's going.  i bet you'll have some great input.
15:31:06 <opqdonut> :i RealFrac
15:31:13 <opqdonut> > round (1.5::Rational)
15:31:14 <lambdabot>  2
15:31:22 <conal> chessguy: new version?
15:31:25 <opqdonut> @info RealFrac
15:31:25 <lambdabot> RealFrac
15:32:50 <dcoutts> wolverian: by default all globally and locally registered packages are available to ghc/ghci
15:33:09 <chessguy> conal: http://hpaste.org/7708#a3
15:33:13 <dcoutts> wolverian: ghc-pkg list will always tell you what's registered
15:33:50 <conal> chessguy: there we go.  i like it.  how about you?
15:33:57 <chessguy> conal: works for me
15:34:17 <conal> chessguy: btw, optionally, you can implement mappend as a smart constructor.
15:34:30 <chessguy> i'm still concerned about the extension issue though
15:34:42 <conal> chessguy: oh yeah.  i forgot all about that issue.
15:34:56 <geezusfreeek> chessguy: export a type class instead of your ADT
15:35:12 <geezusfreeek> making the ADT one of many possible instances of it
15:35:18 <conal> chessguy: i bet now you're in a better position for extensibility.
15:35:27 <chessguy> conal: i don't see how
15:35:28 <geezusfreeek> oh yeah
15:35:39 <conal> chessguy: just occured to me:  maybe the extensibility you want has nothing to do with traversal.
15:35:48 <geezusfreeek> it is now much easier to simply compose new structures out of the existing ones
15:35:57 <conal> the Monoid/Applicative technique i mentioned .
15:36:28 <conal> chessguy: that Monoid/Applicative technique nicely separates the monoid aspect from the other aspect.
15:36:36 <geezusfreeek> chessguy: the key here is to consider TreeTraversal to be merely the _core_ of your DSL
15:36:43 <chessguy> conal: i want the resulting values to literally just be constructors, or at least things that can be shown easily
15:36:49 <conal> chessguy: yeah.  what geezusfreeek said.
15:36:52 <geezusfreeek> chessguy: extensions should be defined in terms of the core
15:37:10 <chessguy> 'Show'n i should say
15:37:29 <chessguy> and 'Arbitrary'd
15:37:51 <roconnor> > round 3.5
15:37:53 <conal> chessguy: sure.  how about this idea: use (TreeTraversal,a).
15:37:53 <lambdabot>  4
15:38:02 <conal> chessguy: if Show a then Show (TreeTraversal,a)
15:38:08 <chessguy> geezusfreeek, conal, yeah, it's not the ability to extend that i'm concerned about, it's the ability to extend while still maintaining these qualities
15:38:16 <conal> chessguy: and that type gives you Functor and Applicative.
15:38:29 <geezusfreeek> chessguy: think of it as "compose" rather than "extend" and your all set
15:38:33 <conal> chessguy: if you really want Monad you can get it also
15:38:42 <conal> geezusfreeek: nicely put!
15:39:14 <geezusfreeek> :)
15:39:15 <chessguy> i don't get it
15:39:22 <conal> chessguy: i get to have lists of numbers, not because numbers are extensible, but because the type can be composed with list.
15:39:44 <chessguy> because anything can be composed with a list
15:39:49 <conal> right
15:40:06 <conal> composition, when it works, beats extension
15:40:25 <conal> because composition doesn't complicate the interfaces or semantics of what's being composed
15:41:01 <chessguy> so i want to allow the client to compose something new with a TreeTraversal, and get a new TreeTraversal?
15:41:24 <conal> for instance, when i design graphics APIs, my circle or sphere primitive has unit radius and centered at the origin.  i don't make size and center be parameters.  because i can compose instead.  simple & powerful.
15:41:38 <conal> chessguy: probably not a new TreeTraversal.
15:41:58 <chessguy> but a new Applicative or something
15:42:02 <conal> chessguy: type TreeF a = (TreeTraversal,a)
15:42:14 <conal> chessguy: i.e., type TreeF = (,) TreeTraversal
15:42:27 <chessguy> ok
15:42:38 <conal> chessguy: right.  you get the Functor and Applicative for free.
15:42:45 <chessguy> and then make TreeF an instance of Show, Applicative, and Functor, right?
15:42:57 <conal> chessguy: better!  you don't have to.
15:43:03 <conal> chessguy: they come for free.
15:43:09 <conal> (the instances come for free)
15:43:25 <chessguy> oh, because (,) is an instance or something?
15:43:30 <conal> yes!
15:43:37 <conal> see Control.Applicative
15:43:57 <conal> chessguy: my goal is to write as little code as possible, and then delete as much as i can of what i wrote.
15:44:03 <geezusfreeek> hmm… a summary of these activities would make a nice tutorial on "thinking in Haskell"
15:44:08 <conal> chessguy: and get wonderful general results.
15:44:30 <chessguy> i'm not seeing how this helps allow what i'm looking for
15:44:37 <conal> geezusfreeek: or "thinking compositionally" or something.
15:45:29 <chessguy> which, ultimately, is the ability to create new TreeTraversals
15:45:44 <conal> chessguy: change the question.
15:45:58 <chessguy> to what?
15:46:00 <conal> chessguy: you'll get a more powerful answer with a define question
15:46:52 * chessguy is totally not getting what you're driving at, though i'm sure it's good
15:47:06 <conal> chessguy: i can only guess.  i'd start with what your motivation was in defining TreeTraversal.
15:47:28 <conal> chessguy: and then letting go of the idea the TreeTraversal is the *whole* solution.
15:47:47 <gwern> @seen dons
15:47:47 <lambdabot> dons is in #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 59m 9s ago.
15:48:10 <gwern> @tell dons I've sent a bunch of patches for mkcabal
15:48:10 <lambdabot> Consider it noted.
15:48:48 <chessguy> conal: the motivation is to create something that 1.) represents traversing a tree 2.) can easily be an instance of Show, and 3.) can easily be an instance of Arbitrary
15:49:02 <conal> chessguy: okay.  you're done.
15:49:36 <chessguy> i guess i am. except i want a typeclass instead of an algebraic type
15:49:50 <conal> chessguy: it'll be more complex.
15:49:58 * monochrom signs chessguy's graduation diploma. You're done!
15:50:21 <chessguy> well, then people can just instantiate TreeTraversal, Show, and Arbitrary
15:50:23 <conal> chessguy: i suspect you aren't really done.  there's at least a 4 isn't there?
15:51:13 <monochrom> . o O ( "4. cabalize" ? )
15:51:17 <conal> chessguy: there's a piece of the question (goal) that's missing.  get clear about that missing piece, and then we can think clearly about how best to accomplish it, while keeping simplicity.
15:51:35 <chessguy> hmm. i suppose 4.) allows for domain-specific additions to the tree-traversal
15:51:53 <conal> chessguy: yep -- getting there!
15:52:12 <conal> chessguy: so you have something in mind that these "additions" can do that your current type cannot.
15:52:31 <conal> chessguy: let's see if those things really have to be "traversals" or they can be layered onto traversals.
15:52:40 <chessguy> conal: yes, but what those things are depends on what 'a' is
15:52:42 <conal> chessguy: that's extensibility vs composability
15:52:49 <conal> chessguy: exactly!
15:53:09 <conal> chessguy: probably why you had that 'a' that i suggested you remove
15:53:28 <conal> chessguy: let's find a different home for that 'a' and everything one might want to do with it.
15:53:47 <chessguy> sounds good
15:54:46 * chessguy feels as if conal is about to give him the blue pill (or is it the red one, i forget)
15:55:49 <nburlett> hello all
15:56:08 * conal hopes chessguy will reach for it himself
15:56:09 <nburlett> *** Exception: /var/folders/l4/l45NjIn62ReIB++BYmstCU+++TI/-Tmp-//ghc6667_0: createDirectory: does not exist (No such file or directory)
15:56:11 <nburlett> any ideas?
15:56:20 <chessguy> conal: so any ideas where to put it?
15:56:28 <conal> nburlett: awesome error message!
15:56:36 <nburlett> conal: :-<
15:56:38 <chessguy> @ghc
15:56:38 <lambdabot> ghc says: Cycle in type synonym declarations
15:57:02 <wolverian> the ocaml hate article is quite interesting, but it does make me think of evil haskellers hunting down Forrest Gump and mutilating him with sharp implements
15:57:31 <conal> chessguy: start with an example of what you might want to do with a traversal that you can't do now.
15:57:49 <conal> chessguy: i.e., something that involves traversing.
15:57:58 <chessguy> conal: conditional traversal
15:58:05 <chessguy> that's domain-specific
15:58:06 <nburlett> wtf is /var/folders
15:59:21 <conal> chessguy: great.  test a value or context and decide where to traverse next?
15:59:35 <chessguy> conal: yes
15:59:56 <nolrai_> is there a way to union two lists (i know that elements are only once in each list but if there in both i want them to only show up once.)
16:00:04 <nburlett> ooh, my tmpdir is borked
16:00:19 <chessguy> e.g., If QueenUnderAttack Foo Bar
16:00:20 <Lemmih> nolrai_: Use Sets?
16:00:32 <sjanssen> @hoogle union
16:00:33 <lambdabot> Data.List.union :: Eq a => [a] -> [a] -> [a]
16:00:33 <lambdabot> Data.Set.union :: Ord a => Set a -> Set a -> Set a
16:00:33 <lambdabot> Data.Map.union :: Ord k => Map k a -> Map k a -> Map k a
16:00:39 <sjanssen> nolrai_: ^^^
16:00:41 <conal> chessguy: more details.  so we can program it.
16:01:09 <nolrai_> thanks hoogle is our friend.
16:01:36 <sjanssen> @src union
16:01:37 <lambdabot> union = unionBy (==)
16:01:40 <Vaelys> nolrai_: only if you keep giving him shiny things
16:01:41 <sjanssen> @src unionBy
16:01:42 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
16:01:44 <conal> chessguy: here's a meta-plan: define a totally specific example.  solve it without worrying about an ideal abstraction.  then reflect and generalize.  rinse & repeat.
16:03:18 <chessguy> conal: ok, i want the client to be able to define a QueenAttacked predicate, and supply traversals for if it's true or false
16:03:33 <nburlett> what's the O() of Data.List.union?
16:04:27 <conal> chessguy: great.  i think you can implement that example on top of your current type.  give it a try.
16:04:45 <conal> chessguy: (remember: specific now, generalize later)
16:04:46 <monochrom> quadratic.
16:04:59 <nburlett> is Data.Set.union linear?
16:05:13 <monochrom> n log n
16:05:25 <nburlett> oh, right, that makes more sense :->
16:05:47 <chessguy> conal: you mean as part of the TreeTraversal structure, or in addition?
16:06:28 <conal> chessguy: not sure i understand the question.  use the TreeTraversal structure and functions as *part* of the implementation of this example.
16:06:56 <chessguy> conal: but you're saying not to add anything to the TreeTraversal type, right?
16:07:03 <conal> chessguy: exactly.
16:07:15 <nburlett> OMGWTF:
16:07:16 <nburlett>     no such instruction: `addi r31, r22,-8'
16:07:30 * chessguy scratches his head
16:07:31 <monochrom> weak assembler
16:07:32 <conal> chessguy: (leaving the TreeTraversal type unchanged is how test its composability)
16:07:40 <nburlett> OF COURSE THERE'S NO addi INSTRUCTION!!! I"M ON X86!!!?!?!?!!
16:07:57 <monochrom> You wrote it yourself?
16:09:08 <Heffalump> nburlett: there's also no r31 ;-)
16:09:21 <nburlett> Heffalump: no on YOUR x86 maybe :->
16:10:07 <monochrom> my x86 is weak
16:10:32 <nburlett> ok, so the real question becomes why it thinks it's ppc
16:10:54 <Heffalump> perhaps it's a confused Mac
16:10:56 <nburlett> OH, CRUD
16:11:09 <monochrom> identity crisis XD
16:11:11 <sjanssen> did you install the PPC binaries?
16:11:21 <chessguy> conal: http://hpaste.org/7708#a4
16:11:35 <nburlett> my /usr/local directory came over from when I told my new computer that it should copy stuff from the old one
16:11:46 * conal looks 
16:11:50 <nburlett> and /usr/local/bin is in my PATH before my /opt/local/bin/
16:11:51 <monochrom> hahahaha excellent!
16:11:53 <Cale> (wget -q -O- http://www.songstowearpantsto.com/archive/ | html2 | grep "li.*a/@href" | grep songs | cut -d= -f2 | sed 's#\(.*\)#GET \1 | html2 | grep --only-matching soundFile=\.* | cut -d= -f2#' | bash) 2>/dev/null | sed 'y/+/ /; s/%/\\x/g' | xargs -L1 -d'\n' echo -e | xargs -L1 -d'\n' wget
16:11:54 <lambdabot> Title: SONGS TO WEAR PANTS TO  Archive
16:11:59 <Cale> ah, the commandline :)
16:11:59 * chessguy flinches
16:12:20 <conal> chessguy: does that function do what you wanted?
16:12:39 <monochrom> Great haskell you have there, Cales.  <duck>
16:12:49 <Cale> monochrom: it's a composition chain!
16:13:02 <shachaf> monochrom: These are Cale's latest changes to #haskell Haskell.
16:13:08 <shachaf> First it was (.) = fmap, and now this.
16:13:11 <chessguy> conal: i don't know what i want any more
16:13:17 <sjanssen> shachaf++ well played
16:13:22 <monochrom> hehe
16:13:30 <conal> chessguy: maybe you want a break! ;)
16:13:36 <nburlett> woo
16:13:39 <nburlett> working
16:13:48 <conal> chessguy: i gotta go soon anyway.
16:13:54 <conal> chessguy: we can continue later
16:13:57 <chessguy> conal: maybe. let me ponder a while and catch up with you another time
16:14:00 <chessguy> thanks!
16:14:01 * sjanssen replaces the |s with >>=s
16:14:15 <conal> chessguy: :)  you're welcome!
16:15:35 <Cale> (That walks through that site's song archive, reads out a bit of the string it's passing to the flash player which is a urlencoded URL for the song on each page, decodes it and wgets that :)
16:16:17 <ehird> Cale: wow
16:21:54 <nolrai_> building a set is n log n also right?
16:23:12 <nolrai_> So, even if you only use union once set is beter?
16:25:51 <MyCatVerbs> Cale: (.) == fmap, uses the Functor instance for ((->) a)?
16:26:02 <Cale> yeah
16:26:37 <Cale> (a -> b) -> f a -> f b, when f = ((->) e) turns into  (a -> b) -> (e -> a) -> (e -> b)
16:27:45 <MyCatVerbs> Some sort of expansion for instances would be *really* nice when trying to understand things like the (a ->) monad. (If you'll excuse my type sections.)
16:28:34 <MyCatVerbs> Still. Haddock could do with a caleskell package. ;)
16:31:25 <nolrai_> So, even if you only use union once set is beter?
16:31:39 <dmwit> Better than what?
16:32:03 <nolrai_> sorry trying to hight enter on my terminal insted
16:32:18 <nolrai_> ok thats some wierd typos
16:32:47 <nolrai_> hight/hit
16:33:08 <nolrai_> but better than list
16:34:07 <nolrai_> because its n log n to build and n log n to union, as opposed to n to build and n^2 to union, right?
16:34:09 <dmwit> Well, list (without assuming ordering) has an O(m * n) union.
16:34:34 <dmwit> Yeah, something like that.
16:34:53 <dmwit> nolrai_: Except a list-set is also n^2 to build.
16:35:13 <nolrai_> a what?
16:35:22 <dmwit> (Assuming only Eq; with Ord you can get n log n as before.)
16:35:36 <dmwit> nolrai_: A list with no repetitions can't be built in O(n) worst-case time.
16:35:38 <dons> new sigfpe, http://reddit.com/info/6jsqz/comments/
16:35:38 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
16:36:11 <roconnor> > null do (Nothing <- [Just 5, Nothing])
16:36:11 <lambdabot>  Parse error at "do" (column 6)
16:36:18 <roconnor> > null (do Nothing <- [Just 5, Nothing])
16:36:18 <lambdabot>  Parse error at ")" (column 38)
16:36:38 <roconnor> > do Nothing <- [Just 5, Nothing]
16:36:38 <lambdabot>  Parse error at end of input
16:36:44 <nolrai_> Oh no, I know that there arn't repitions, in the lists, because im generating them with fillters from lists without repetions.
16:36:47 <dmwit> Hey, anybody else want to help me evangelize Haskell? http://reddit.com/info/6jro3/comments/c041m8m
16:37:08 <dmwit> nolrai_: ah, ok
16:37:29 <dmwit> nolrai_: If you happen to know they're ascending, then you can actually do *better* with lists than with Set.
16:37:37 <dmwit> nolrai_: Otherwise, yeah, Set is probably easiest and fastest.
16:37:48 <roconnor> > null do (x@Nothing <- [Just 5, Nothing]; return x)
16:37:49 <lambdabot>  Parse error at "do" (column 6)
16:37:56 <roconnor> > null (do x@Nothing <- [Just 5, Nothing]; return x)
16:38:08 <lambdabot>  False
16:38:13 <dmwit> > null $ do { Nothing <- [Just 5, Nothing]; return x }
16:38:14 <lambdabot>  False
16:38:39 <Cale> dmwit: heh
16:38:44 <dmwit> ;-)
16:38:54 <roconnor> > [x | x@Nothing <-  [Just 5, Nothing]]
16:38:55 <lambdabot>  [Nothing]
16:39:06 <dmwit> > [() | Nothing <- [Just 5, Nothing]]
16:39:07 <lambdabot>  [()]
16:39:25 <dmwit> > null $ do Nothing <- [Just 5, Nothing]; return ()
16:39:26 <lambdabot>  False
16:39:42 <dmwit> > null $ do [Just 5, Nothing]; guard . isNothing
16:39:42 <lambdabot>  Couldn't match expected type `[Bool]'
16:39:57 <dmwit> > null $ [Just 5, Nothing] >>= guard . isNothing
16:39:58 <lambdabot>  False
16:40:14 <dmwit> > null . filter isNothing $ [Just 5, Nothing]
16:40:16 <lambdabot>  False
16:40:29 <dmwit> There's lots of ways to spell this function. =)
16:41:08 <nolrai_> hmm, I think i can garranty ascendingness (ascendency?).  How do you do better then Set? eh, Set is most likely good enough.
16:41:29 <roconnor> dmwit: I sort of want to avoid writing an isNothing function
16:41:32 <dmwit> Yeah, just use Set.
16:41:34 <nolrai_> and how much better?
16:41:36 <dmwit> roconnor: import Data.Maybe
16:41:39 <roconnor> dmwit: why bring Bool into the picture
16:41:41 <dmwit> nolrai_: O(n)
16:41:44 <Cale> nolrai_: You can merge two ascending lists in linear time
16:42:06 <roconnor> > [() | Nothing <- [Just 5, Just 6]]
16:42:07 <lambdabot>  []
16:42:21 <dmwit> Well, O(m + n) to be more precise.
16:43:04 <roconnor> dmwit: I'm jusing Maybe in place of my own data type here
16:43:06 <dmwit> roconnor: You should feel fine bringing "Bool" into the picture; the way you're doing it, you're bringing "fail" into the picture.
16:43:16 <dmwit> roconnor: Oh, okay.
16:43:35 <roconnor> dmwit: but fail is attached to lists
16:43:42 <roconnor> and list are part of the picture
16:43:54 <roconnor> I'll pretend fail is part of MonadPlus
16:43:58 <dmwit> ;-)
16:44:47 <dmwit> :t M.lookup
16:44:49 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
16:44:54 <dmwit> bah
16:45:31 <roconnor> oh
16:45:39 <roconnor> @hoogle a -> [a] -> Int
16:45:44 <roconnor> @hoogle a -> [a] -> Maybe Int
16:45:47 <lambdabot> No matches, try a more general search
16:45:48 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
16:46:03 <roconnor> dmwit: I have not instance of Eq
16:46:08 <roconnor> no
16:46:13 <dmwit> ?
16:46:39 <roconnor> well actually I this is academic
16:46:50 <roconnor> but data Foo = Foo | Bar (Int -> Int)
16:47:03 <roconnor> is not such a crazy type
16:47:25 <dmwit> Sure, but why are you telling me you have no instance of Eq?
16:47:34 <nolrai_> and how much better?
16:47:41 <ehird> sclv: I could do with a HVAC tutorial :3
16:47:43 <nolrai_> did it again
16:49:06 <gwern> by the way everyone, roguestar is now on hackage
16:49:42 <nolrai_> whats rougestar?
16:49:47 <roconnor> @type fail
16:49:47 <gwern> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/roguestar-engine-0.2.1  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/roguestar-gl-0.2.1 http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rsagl-0.2.1
16:49:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
16:50:23 <edwardk> @pl \f -> fmap (bimap f (fmap f))
16:50:35 <roconnor> dmwit: because Data.List.elemIndex (which I assume was why you were querying lookup) doesn't work
16:50:44 <roconnor> dmwit: but maybe you were just looking up lookup for some other reason
16:50:52 <gwern> nolrai_: 3d roguelike
16:50:52 <dmwit> Oh, no, lookup was for something else. heh
16:50:59 <edwardk> @pl \f -> fmap (bimap f (fmap f))
16:51:10 * edwardk shrugs
16:51:48 <sclv> ehird: I'll see what I can do soon... the example programs should make lots of the stuff clear tho...
16:53:09 <ehird> sclv: yes, but they're kinda dense
16:53:11 <ehird> without much help
16:53:20 <ehird> sclv: really, a crash-course in the most important things would be enough
16:53:36 <ehird> like: how do i start an app, how do I roughly structure it, what is that ReadOnly shizz, and how do I do sql.
16:54:37 <roconnor> @where logicT
16:54:49 <ehird> @where LogicT
16:54:58 <roconnor> @vixen why so slow?
16:55:12 <Cale> @hackage logict
16:55:31 <roconnor> lamabda is thinking about edwardk's pf question
16:55:31 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/logict
16:55:48 <roconnor> @calesnack
16:55:51 <ehird> Lulz lambdabot died.
16:56:02 <nolrai_> :t foldr
16:56:10 <dmwit> How can I get more detailed information on memory allocation?
16:56:24 <dmwit> I used +RTS -P -RTS, but it only tells the total allocation.
16:56:36 <dmwit> I thought there was a way to get the max allocation at any point, as well.
16:56:36 <Cale> Heh, better hope that it restarts on its own, since my account still seems to be disabled on code.h.o
16:57:02 * edwardk apologizes for killing lambdabot
16:57:29 <Cale> Probably wasn't you :)
17:01:09 <roconnor> edwardk: fmap . (ap bimap fmap)
17:01:17 <roconnor> edwardk: I think
17:01:29 <Cale> hmm
17:01:33 <edwardk> roconnor: was trying to see if it would go down to one word for a nice type name
17:01:49 <dolio> Man, inlining can really make a difference.
17:01:59 <edwardk> dolio: ?
17:02:31 <dolio> I've been marking all my sorting stuff with INLINE pragmas, because I'm naive like that...
17:02:42 <dolio> So I thought I'd go through and see which ones actually do stuff.
17:03:01 <dolio> I removed the pragma for 'sort'.
17:03:03 <nolrai_> is there an easy way to get subarrays out of arrays?
17:03:06 <edwardk> good difference/bad difference? =)
17:03:19 <dolio> With inlining, 3.5 seconds, without, I killed it after 4+ minutes without it completing.
17:03:25 <edwardk> ouch
17:03:58 <edwardk> i need to start putting together a benchmark suite so i can figure out what is worth inlining in the category stuff
17:03:59 <nolrai_> hmm, thats huge!
17:04:13 <dmwit> nolrai_: Yes, ixmap.
17:04:15 <dmwit> :t ixmap
17:04:27 <dmwit> Oh, right, no \bot.
17:04:28 <dolio> Yeah. That seems like too big of a difference to be right.
17:04:44 <dolio> Especially since the definition is 'sort = sortBy compare'.
17:04:47 <nolrai_> dmwit: umm, explain please.
17:04:49 <Bonus> @src join
17:05:08 <Bonus> is it join a = a >>= id
17:05:22 <dolio> Yes.
17:05:25 <Bonus> kewl
17:05:26 <dmwit> nolrai_: ixmap :: (i, i) -> (i -> j) -> Array j e -> Array i e
17:05:27 <dolio> Or something equivalent.
17:05:35 <dolio> But I think that's the one that's used.
17:05:46 <dmwit> nolrai_: So (ixmap (lowerBound, upperBound) id) should do what you want.
17:06:15 <nolrai_> Oh!
17:07:05 <dmwit> You could also probably do something complicated with elems, listArray, and drop.
17:07:24 <Saizan> dolio: inlining sort maybe triggers a specialization of compare?
17:09:06 <dolio> Could be.
17:09:13 <dolio> Whatever it's doing, it's huge. :)
17:10:35 <ehird> sclv: would a quickstart to hvac be practical over irc?
17:11:27 <shachaf> No \bot?
17:11:29 <shachaf> Why not?
17:11:43 <ehird> shachaf: We broke it.
17:11:54 <dolio> Saizan: That's probably what happens. I have INLINE on all the sorting functions, and removing any of them destroys performance.
17:11:56 <ehird> <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
17:11:59 <ehird> that broke its brain
17:12:11 <ehird> RIP \bot
17:12:35 <dolio> So inlining everything must enable it to do lots of work specializing the entire sorting algorithm to whatever comparison is used.
17:13:03 <shachaf> allbery_b: You have a λbot in ##sports?
17:14:04 <monochrom> @botshack
17:14:26 <monochrom> She's out Saturday night.
17:15:04 * ehird kicks Cale
17:15:05 <ehird> restart it!
17:15:25 <monochrom> Cale took her out for dinner.
17:21:28 <Cale> ehird: Can't get into my account on code.h.o
17:21:35 <ehird> Cale: DISASTER
17:21:48 <Saizan> banned key?
17:21:48 <Cale> ehird: It was disabled because my ssh key was apparently compromised.
17:21:58 <dmwit> So generate a new key?
17:22:03 <dmwit> Or are you banned indefinitely?
17:22:05 <Cale> I did
17:22:09 <Cale> and sent it.
17:22:27 <dmwit> ...oh
17:22:31 <dmwit> sorry =/
17:33:04 <nolrai_> one can foldr over IntSet, can't you?
17:34:57 <dmwit> Probably not foldr, but some associative fold.
17:35:06 <dmwit> But yeah, there's probably a fold in there
17:35:20 <dcoutts> @type Data.IntSet.fold
17:35:33 <dcoutts> lambdabot?
17:35:48 <dcoutts> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-IntSet.html#v%3Afold
17:35:50 <dcoutts> nolrai_: ^^
17:35:55 <shubuntu> hey what's the best approach for replace in a two dimensional list?
17:36:20 <dmwit> replace your algorithm
17:36:22 <dmwit> ;-)
17:37:00 <dmwit> How about writing something like (update :: (a -> a) -> Int -> [a] -> [a]) or so?
17:37:54 <dmwit> Then you could use (update2D f x y = update (update f x) y).
17:38:59 <shubuntu> and f is the value being replaced?
17:39:23 <dmwit> f is a function that tells what the new value should be (given the old value).
17:39:39 <dmwit> If you just want a single value replacement, you could do
17:39:46 <shubuntu> so it can be just the value itself right
17:39:53 <shubuntu> ok
17:39:55 <dmwit> update2D newVal x y = update (update (const newVal) x) y
17:40:11 <shubuntu> so let's say i'm replacing on my board
17:40:38 <dmwit> But if you expect to do this a lot, you may want to switch over to Data.Map or Data.Array.
17:41:00 <allbery_b> shachaf: yep
17:41:05 <shubuntu> where do you guys get these?
17:41:13 <nolrai_> dcoutts, thanks
17:41:18 <dmwit> shubuntu: Get what?
17:41:24 <shubuntu> i can't seem to be able to find these modules and documentations properlyh
17:41:32 <allbery_b> (with most of the haskell fun stripped.  see the help file via @list)
17:42:01 <shubuntu> @List
17:42:03 <dmwit> shubuntu: http://www.haskell.org/ghc/docs/latest/html/libraries/
17:43:40 <dejones> well, before I complained about the "$" syntactic sugar existing.. but honestly now that I'm using Haskell more often, I find that I prefer to use the $ far more often than ()'s.
17:43:41 <dejones> :)
17:43:49 <dejones> smart guys designing Haskell.  ;)
17:46:26 <dons> hehe
17:46:45 <shubuntu> insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
17:46:49 <shubuntu> can i use that?
17:47:20 <shubuntu> it's from Data.List
17:47:55 <shubuntu> replace :: Stone -> Coord -> Board -> Board
17:49:00 <shubuntu> replace stone (x,y) Board =
17:49:22 <shubuntu> now how do i write it so the stone is placed at position (x,y)
17:49:57 <dmwit> type Board = ?
17:50:48 <shubuntu> Data Board = [[Stone]]
17:51:08 <dmwit> Then using insertBy will be more trouble than it's worth.
17:51:17 <shubuntu> uhhh
17:51:22 <dmwit> Try writing the "update" function I suggested above.
17:51:56 <shubuntu> but how would it work with my data types?
17:53:16 <shubuntu> replace stone (x,y) board = update (update stone y) x?
17:53:36 <shubuntu> replace stone (x,y) board = update (update stone y Board) x?
17:53:46 <shubuntu> replace stone (x,y) board = update (update stone y board) x?
17:53:48 <dmwit> Close, though s/stone/(const stone)/
17:54:01 <Botje> don't guess, work out the types.
17:54:14 <Botje> you can ask the compiler to work it out for you
17:54:15 <shubuntu> hey Botje
17:54:19 <shubuntu> how?
17:54:31 <Botje> update :: (type dmwit gave you above)
17:54:33 <Botje> update = undefined
17:54:49 <Botje> then ask for some types
17:58:10 <shubuntu> hmm that doesn't seem to be working
17:58:29 <shubuntu> because when accessing the rows I don't update anything
17:58:40 <shubuntu> the actual update happens inside of the chosen row
17:59:45 <shubuntu> http://hpaste.org/7710
17:59:55 <noecksit> hello shubuntu, the update function manipulates one element or one row of the 2d list
17:59:57 <electronx> why is haskell more popular then clean? it seems ver much faster
18:00:14 <Botje> shubuntu: err.. you're not every _trying_ to typecheck it?
18:00:15 <shubuntu> hi neocksit
18:00:23 <Botje> stone is very much NOT a function from a to a
18:00:45 <shubuntu> i'm still thinking in C i guess. this new programmnig way is kinda alien to me
18:00:54 <noecksit> the first argument, (a -> a) is a function that transforms the value u want to change into the changed value
18:01:11 <Zao> electronx: Because the Clean homepage burns eyes.
18:01:20 <electronx> lol
18:01:21 <noecksit> the second argument, Int, is the position of the element you want to change, i think
18:01:23 <monochrom> Haskell is a cultural shock.
18:01:47 <shubuntu> update :: a -> Int -> [a] -> [a]
18:02:03 <noecksit> the third argument, [a], is the actual row in your two dimensional list
18:02:10 <dons> electronx: clean seems faster? have you written programs in it?
18:02:11 <noecksit> and the final argument is the result
18:02:14 <dmwit> shubuntu: That type is too restrictive to do what you want.
18:02:19 * monochrom should think of a fancier name for that next time.  Maybe postmodern paradigm shift new age thinking?
18:02:34 <shubuntu> how about I write it like this
18:02:40 <noecksit> its update :: (a -> a) Int -> [a] -> [a]
18:02:52 <monochrom> Haskell is a postmodern paradigm deconstruction new age ontology. :)
18:02:54 <idnar> noecksit: I think you're missing a ->
18:02:54 <noecksit> update :: (a -> a) -> Int -> [a] -> [a]
18:02:58 <idnar> ah there
18:04:05 <shubuntu> replace stone (x,y) board = update ((board !! y ) !! x) stone
18:04:20 <shubuntu> i donno i just want to put that stone in that place
18:04:25 <shubuntu> shouldn't be soo troublesome
18:04:28 <nolrai_> any one have a clue how to instal gtk2hs on ubuntu?
18:04:32 <shubuntu> that's why i get frustrated
18:04:48 <dcoutts> nolrai_: there are ubuntu packages for it I believe
18:04:57 <shubuntu> nolrai apt-get update
18:05:04 <nolrai_> really
18:05:05 <shubuntu> aptitude install gtk2hs
18:05:30 <Botje> replace stone (x,y) board = update (update (const stone) y) x board -- free fish
18:05:40 <dcoutts> nolrai_: called something like libghc6-gtk-dev
18:06:11 <dmwit> Botje: He seems to ignore free fish, I posted that (twice!) nearly twenty minutes ago.
18:06:13 <shubuntu> Botje I don't understand that
18:06:26 <shubuntu> free fish?
18:06:31 <nolrai_> oh thats why.
18:06:47 <Botje> shubuntu: what do you not understand about it?
18:06:52 <nolrai_> free fish?
18:06:55 <Botje> perhaps there's just one little thing wrong
18:07:22 <shubuntu> ok first of all does that return a two dimensional list?
18:07:23 <nolrai_> why not just use "//"
18:07:38 <Botje> shubuntu: feed it into haskell and ask for the type
18:07:55 <shubuntu> :t <all you typed>?
18:08:20 <Botje> put it in a file
18:08:38 <Botje> also put in the type & definition for update
18:08:46 <Botje> load that file with ghci, and :t replace
18:09:00 <hexpuem> someone redo the ghc packages for ubuntu and turn on splitobjs haha
18:09:11 <dmwit> nolrai_: He wants to use lists, for some reason.
18:12:08 <orbitz> hai
18:12:30 <dmwit> Hiya, orbitz!
18:12:39 <Saizan> shubuntu: first of all, you can't really update a value in a list, you can only create a new list with a different value
18:12:41 <shubuntu> Botje it doesn't work as expected
18:12:50 <Botje> shubuntu: what do you mean "doesn't work" ?
18:13:06 <shubuntu> :type replace
18:13:06 <shubuntu> replace :: Stone -> Coord -> Board -> Board
18:13:12 <shubuntu> that's how i defined it
18:13:36 <shubuntu> Saizan but in C i could just replace a value
18:13:42 <shubuntu> why can't I here
18:13:53 <shubuntu> i don't understand how it works
18:13:56 <Botje> because you're using haskell and haskell does not have mutable values? :)
18:14:10 <shubuntu> I don't get the mindset
18:14:20 <hexpuem> copy on write
18:14:22 <noecksit> Botje: wouldn't it be more understandable to write "update (update (const stone) y board) x board"?
18:14:23 <Botje> what update is supposed to do
18:14:34 <chessguy> @seen conal
18:14:44 <shubuntu> hi chessguy
18:14:51 <chessguy> hiya shubuntu
18:14:58 <dmwit> noecksit: Maybe, but that's broken.
18:15:10 <Botje> noecksit: that's a type error :) you want the outer update to select a row, feed that to the inner update, and get back a row to plug into the [[Stone]]
18:15:29 <Botje> shubuntu: you're supposed to return a copy of the matrix with one element altered
18:15:38 <shubuntu> yes
18:15:42 <Botje> the function update basically takes a list and an index
18:15:54 <Botje> and a function to transform the element at index i in the list
18:16:04 <saml> statically typed vs. dynamically typed is not property of a language, but of implementation right?
18:16:04 <Botje> it then does that and returns the list, with that one element transformed
18:16:47 <chessguy> @bot
18:16:58 <mbz> hiya
18:17:06 <shubuntu> ok so that const stone acts as a function that replaces stone at position y of row x?
18:17:09 <noecksit> oh ok
18:17:15 <dmwit> shubuntu: Exactly!
18:17:27 <Botje> shubuntu: well, const stone is really a shorthand for "ignore whatever value is in there, and put stone in its place"
18:17:39 <shubuntu> ok
18:17:41 <shubuntu> now i understand
18:17:47 <Botje> now go write update :)
18:17:54 <Botje> you might want to look at the splitAt function
18:18:00 <shubuntu> write update?
18:18:06 <Botje> yes
18:18:10 <Botje> write the update function
18:18:16 <chessguy> @docs
18:18:19 <Botje> because "undefined" is not exactly a good implementation :)
18:18:20 <shubuntu> hmmm
18:18:23 <chessguy> oops
18:18:36 <Botje> while developing, it's generally good to stub out functions with undefined and see if you can get the types right
18:18:52 <Botje> once they're right, writing the function is easy
18:19:00 <shubuntu> not for me
18:19:08 <shubuntu> i don't understand how it works
18:19:09 <shubuntu> lol
18:19:24 <Botje> what do you not understand?
18:20:33 <shubuntu> update :: (a -> a) -> Int -> [a] -> [a]
18:20:34 <shubuntu> update f x lst =
18:20:40 <shubuntu> write it like that?
18:20:52 <Botje> yes
18:20:57 <Botje> now fill in the definition :)
18:21:11 <Botje> you definitely want to use splitAt and ++
18:21:18 <jaj> hmm no lambdabot in here?
18:21:28 <shubuntu> ok but i'll have the boundary problems again?
18:21:49 <mbz> somebody killed lambdabot :\
18:21:54 <orbitz> is Enum a way to provide a standard way to iterate over anything iteratable?
18:22:00 <dmwit> shubuntu: Yes, you have to worry about boundaries.
18:22:06 <dmwit> Nothing new there, that's true in C, too.
18:22:06 <shubuntu> ugh
18:22:11 <shubuntu> i'd go to the recursive
18:22:12 <shubuntu> lol
18:22:16 <shubuntu> that's easier
18:22:17 <shubuntu> lol
18:22:20 <dmwit> ?
18:22:21 <Botje> fine, do that then
18:22:29 <jaj> mbz: that's sad
18:22:31 <Botje> that's good too
18:23:50 <dmwit> I mean, sure, go recursive... but that's not going to magically make out-of-bounds accesses suddenly in-bounds.
18:24:00 <dmwit> Just so you don't get your hopes up. ;-)
18:25:15 <shubuntu> replace stone (x,y) (row:rows) = row: replace stone (x,y-1) rows
18:26:26 <shubuntu> replace stone (x,0) (row:rows) = newRow:rows
18:26:57 <Saizan> you've to put the second definition first
18:27:24 <shubuntu> yeah i'll swamp
18:27:26 <shubuntu> swap
18:27:33 <shubuntu> now I need to define newRow
18:28:12 <shubuntu> [ i | i <-row, row!!x = stone]?
18:28:28 <dmwit> Try it. ;-)
18:28:31 <shubuntu> does that kind of assignment work?
18:28:47 <dmwit> If you try it, you will get a faster and more precise answer than asking here. =)
18:28:55 <shubuntu> uhhhh
18:29:15 <shubuntu> programming should be about doing in it on paper and knowing how it will result
18:29:30 <dmwit> Yes, but first you need experience with how things work.
18:29:37 <shubuntu> if they explained the logic of this language well enough i wouldn't have so much problem writing for it
18:29:41 <dmwit> So, to get that experience, you will need to play with the language.
18:29:51 <dmwit> shubuntu: Well, have you worked through any tutorials?
18:29:52 <noecksit> shubuntu: why r u rewriting replace, i thought that was already done for u?
18:30:05 <shubuntu> no
18:30:15 <Saizan> shubuntu: assignements like that are never going to work
18:30:18 <shubuntu> that update function has to boundary check
18:30:31 <dmwit> shubuntu: Then may I recommend that you work through a tutorial?  Those will "explain the logic of this language".
18:30:38 <Saizan> shubuntu: the only think allowed on the LHS of "=" is a pattern
18:31:00 <shubuntu> ok the zip?
18:31:04 <shubuntu> then*
18:31:23 <shubuntu> or that doesn't work either
18:32:12 <noecksit> shubuntu: the boundary is the second argument of the function, the Int that is, you go that far into the list
18:32:15 <shubuntu> i could write a new function and do it easily
18:32:49 <shubuntu> GRRRR I'm confused with this language
18:32:57 <nolrai_> that list zip doesnt make any sense.
18:33:02 <Botje> then stop mucking about and read some tutorials first
18:33:16 <shubuntu> i have and they didn't help a bit
18:33:18 <Botje> you're jumping all over the place and trying to bruteforce your way into a proper program
18:33:30 <Botje> this may work with other languages but not with haskell.
18:33:33 <shubuntu> simple thing
18:33:42 <shubuntu> if i want something done in C i write it based on a logic
18:33:47 <nolrai_> They realy help the transefer from itterative to functional.
18:33:58 <shubuntu> even if i haven't known any similar ways i can transfer math to C
18:34:11 <shubuntu> but with haskell i their logic is not mathematical
18:34:15 <nolrai_> yes, and your using C logic to program in haskell.
18:34:17 <Botje> *splorf*
18:34:31 <Botje> haskell not mathematical?
18:34:48 <Saizan> shubuntu: the logic you use when writing C can't work in haskell, they are based con completely different models.
18:35:00 <Botje> last time i checked, maths doesn't have pointers, structs or mutable variables.
18:35:19 <shubuntu> then why on God's earth can't i iterate to a simple position on a li?
18:35:41 <dmwit> shubuntu: Because your mind is stuck in the wrong model!
18:35:46 <Botje> because haskell is a functional language, not an imperative one.
18:35:51 <shubuntu> :(
18:36:12 <Saizan> shubuntu: you can't change a list, every value is immutable in haskell, you must construct a new list with a changed value.
18:36:22 <Botje> what you learned by doing C is useless here. open your mind.
18:36:24 <Saizan> however this is indeed very simple once you know the language
18:36:27 <dmwit> shubuntu: Also, because C's notation overloads "[]" in a bad way.
18:37:33 <shubuntu> well by recursion you can iterate but it's not a nice way of doing it
18:37:46 <Botje> ah
18:38:12 <Botje> and "for (p = list; p; p=p->next) { ... } " is ?
18:38:14 <shubuntu> like to do that newRow I could define a new function that takes x, row and stone and places it there
18:38:25 <dmwit> Higher-order functions make recursion nice again by hiding it. =)
18:38:46 <Saizan> shubuntu: why you don't do that? it's perfectly sane
18:39:04 <shubuntu> because it's messy and doesn't look mathematical
18:39:28 <Saizan> splitting your problem in smaller subproblems is not mathematical?
18:39:35 <shubuntu> noooo
18:39:46 <shubuntu> i meant the code doesn't look mathematical
18:39:47 <shubuntu> lol
18:40:06 <Botje> does it have to?
18:40:11 <Saizan> we have a different notion of mathematical :)
18:40:13 <Botje> was that a part of your assignment ?
18:40:23 <Botje> "CODE HAS TO BE IN HASKELL AND LOOK MATHEMATICAL."
18:40:47 * dmwit doesn't think "arr[i] = newValue;" looks particularly mathematical.
18:41:19 <shubuntu> i've already submitted the assignment
18:41:58 <shubuntu> it's a part of the assignment that if you're capable of finding a code to write it more mathematically looking you will be given a chance to do an HPO
18:42:04 <shubuntu> that's why I'm sweating it
18:42:29 <Botje> "more mathematically looking"
18:42:31 * Botje boggles
18:43:37 <shubuntu> http://hpaste.org/7711
18:43:41 <shubuntu> like that Botje
18:43:59 <shubuntu> with operators and zips
18:44:11 <shubuntu> more like defining sets and groups
18:44:26 <dmwit> So you want to use higher-order functions.  That's admirable.
18:44:43 <nolrai_> thats what haskell does best.
18:44:47 <shubuntu> i've already done it the usual way
18:44:58 <dmwit> That is why, at the beginning, I suggested writing your own HOF.
18:45:01 <shubuntu> i know how to write code don't get me wrong
18:45:13 <shubuntu> i don't know how to do those higher order things
18:45:24 <dmwit> Then you should learn. =)
18:45:35 <shubuntu> well i'm struggling with the logic mate
18:45:43 <shubuntu> as you've seen so far
18:45:44 <noecksit> hmm, i wish i had programming assignments in haskell, all we have in school is java
18:45:57 <heavensrevenge> hello
18:45:57 <shubuntu> ewe java sucks
18:45:58 <shubuntu> lol
18:45:59 <nolrai_> I just get C.
18:46:06 <dmwit> heavensrevenge: Hiya!
18:46:11 <heavensrevenge> salut
18:46:17 <shubuntu> java is for kids
18:46:22 <nolrai_> Our data structures class is in C.
18:46:26 <dmwit> shubuntu: What language is for adults?
18:46:32 <dmwit> (Just out of curiosity.)
18:46:33 <shubuntu> C++
18:46:38 <heavensrevenge> ok, im comiting to do both haskell AND erlang, but may i ask for a thought or few
18:46:38 <dmwit> *blink*
18:46:43 <shubuntu> or better C#
18:46:44 <heavensrevenge> which should i go for 1st??
18:46:50 <shubuntu> i like eiffel too
18:47:09 <dmwit> heavensrevenge: My impression is that Haskell is cleaner.
18:47:12 <heavensrevenge> im pretty new to coding, but im highly logical
18:47:21 <nolrai_> C++ is better then java? they dont feel much diffrent to me.
18:47:24 <dmwit> heavensrevenge: It's not even clear that Erlang wins on parallelism these days.
18:47:28 <noecksit> java isnt that bad, but it sux that we learn no new languages
18:47:30 <heavensrevenge> and ive narrowed down functional languages, as to which erlang and haskell came out on top
18:47:30 <dmwit> nolrai_: I'm with you.
18:47:36 <chessguy> @hoogle ((->) a)
18:47:45 <chessguy> ugh, silly bot
18:47:47 <dmwit> chessguy: No \bot for now.
18:47:50 <shubuntu> java doesn't have assignment in constructors
18:47:51 <heavensrevenge> hmm
18:48:04 <chessguy> where are the docs for ((->) a), anybody know?
18:48:04 <geezusfreeek> conal: I am done working on futures for tonight I think, and it's not ready to show yet, but just so you know, it's coming along beautifully.
18:48:09 <shubuntu> their approach of inheritence is too restrictive
18:48:12 <dmwit> Control.Monad.Reader
18:48:24 <shubuntu> their graphics libararies are too limited
18:48:27 <heavensrevenge> well i can expect there to be a bias towards haskell here :P BUT for a more inexperienced coder, which may be more suitable to start out with?
18:48:30 <Botje> "assignment in constructors" ?
18:48:43 <chessguy> thanks dmwit
18:48:43 <Botje> you mean you can't do Foo() : mem1("blarf") {} ?
18:49:02 <shubuntu> foo ( int i = 0)
18:49:10 <Botje> uh
18:49:14 <Botje> that's called default parameters
18:49:21 <shubuntu> yeah
18:49:21 <Botje> and it's not a big deal
18:49:26 <noecksit> heavensrevenge: i like python and haskell best
18:49:31 <shubuntu> well the little bits make a program nice
18:49:40 <Botje> that's not what i call "nice"
18:49:50 <nolrai_> I like it.
18:49:51 <shubuntu> anyways I'm not here to defend any language
18:50:15 <shubuntu> I'm here to learn about Haskell
18:50:19 <heavensrevenge> ok then
18:50:20 <shubuntu> and become witted in it
18:50:20 <shubuntu> lol
18:50:30 <heavensrevenge> thank you very much for the extra opinions :)
18:50:37 <nolrai_> its one of the two things i miss in haskell, the other being good named records.
18:50:52 <heavensrevenge> im going to start out with haskell and finally do erlang afterwards
18:51:11 <mbz> so what is the right way for updating list? i see i've missed it
18:51:30 <dmwit> mbz: The right way is to use a different data structure.
18:51:33 <nolrai_> use array.
18:51:35 <dmwit> Or a different algorithm.
18:51:49 <dmwit> (i.e. an algorithm that doesn't require updating a given position.)
18:52:01 <mbz> that's clear
18:52:18 <mbz> also it is possible to enumerate all states and just change one num
18:52:25 <mbz> j/k
18:52:39 <dmwit> ;-)
18:52:45 <shubuntu> you can count the distance to the moon by stones too
18:52:46 <shubuntu> lol
18:52:57 <spazz> Hi
18:53:06 <spazz> +nc
18:53:11 <shubuntu> hello spazz
18:53:16 <spazz> Hi
18:53:22 <dmwit> mbz: Effectively, that is what you are doing, where "all states" includes all the states your computer can be in. ;-)
18:53:55 <spazz> Can you guys tell me where I can find an interesting IRC chatroom that is lively
18:54:08 <spazz> I've been looking about for some rooms, and even the most packed rooms have little activity
18:54:12 <dmwit> Nope, never found one!
18:54:14 <dmwit> ;-)
18:54:14 <spazz> It's pretty discouraging
18:54:20 <Saizan> > let replace i v xs = let (as,b:bs) = splitAt i xs in as ++ v : bs in replace 3 100 [1..10]
18:54:26 <shubuntu> lol dmwit
18:54:28 <shubuntu> go to a bar
18:54:33 <spazz> I'm underage
18:54:37 <dmwit> I don't drink.
18:54:38 <Saizan> no bot? shame
18:54:39 <spazz> and I like stimulating conversation
18:54:45 <spazz> Not drunken slander
18:54:49 <dmwit> And I have plenty of interesting things to do without a bar.
18:55:07 <chessguy> why do both pure and arr exist?
18:55:21 <spazz> I as well, but you can't blame me for having a craving for conversation
18:55:31 <dmwit> chessguy: For namespace collision avoidance.
18:55:46 <dmwit> chessguy: You can import hiding (pure) if you are also importing Control.Applicative.
18:56:00 <chessguy> so why have one called pure at all?
18:56:06 <Saizan> dmwit: that's not historically true, but ok :)
18:56:20 <shubuntu> Saizan can you explain the code you wrote?
18:58:22 <spazz> This is a very timid room ..
18:58:58 <Botje> spazz: there's always tons of stuff to talk about in #perl and #nethack
18:58:58 <Saizan> shubuntu: what you don't understand?
18:59:10 <spazz> Oh really?
18:59:27 <spazz> I will try that out
18:59:28 <spazz> thank you
19:01:09 <mbz> shubuntu: splitAt splits list and returns tuple; we are using cons to pull the first element
19:01:34 <mbz> then we simple replace it with given value
19:01:45 <noecksit> do u guys know which universities in America are particularly strong in their cirriculum in functional programming?
19:02:13 <noecksit> i might think about doing masters in one of these
19:02:41 <shubuntu> MIT, Stanford, Caltech
19:02:50 <dmwit> Stanford?
19:02:54 <dmwit> Where do you get your information?
19:03:00 <noecksit> all the ones ive heard of are in england or denmark or netherlands
19:03:04 <shubuntu> my cousin goes there
19:03:16 <dmwit> At the very least, Stanford's undergrad curriculum is embarassingly low on FP.
19:03:27 <shubuntu> he said masters
19:03:33 <dmwit> Yeah, I know.
19:03:36 <shubuntu> they're doing lots of research on functional programming
19:03:56 <shubuntu> they're not doing haskell though
19:04:32 <noecksit> stanford or mit would be really hard to get into and would cost a fortune
19:05:09 <shubuntu> not if you get a scholarship
19:05:11 <shubuntu> but anyways
19:05:21 <shubuntu> Caltech's good too
19:05:32 <shubuntu> my second cousin is doing her phd there
19:06:19 <shubuntu> if you can stand the cold waterloo seems to be getting a lot of attention in that regards too
19:06:20 <dmwit> In what field?
19:06:33 <shubuntu> she's doing AI
19:06:47 <dmwit> Wow, your family is pretty big on computer science, hey? =)
19:06:58 <shubuntu> yeah pretty much
19:07:20 <shubuntu> except for one cousin that's a doc
19:07:25 <shubuntu> the rest all engineers
19:07:32 <shubuntu> and mostly math / computer
19:07:44 <noecksit> shubuntu: yeah, waterloos nice
19:08:52 <noecksit> idk how it tuition works in canada though
19:10:39 <edwardk> @pl \g h -> HyperB (runHyperB h . contramap g)
19:10:48 <edwardk> er is lambdabot still down?
19:11:07 <chessguy> edwardk: yes
19:11:07 <dmwit> yes
19:11:12 <edwardk> crud
19:11:13 <edwardk> k
19:11:28 <orbitz> we're all gunna die!
19:13:33 <chessguy> conal: ping?
19:18:45 <mbz> btw, what's happened with lambdabot?
19:19:03 <MyCatVerbs> > 1 + 1
19:19:12 <dmwit> Death happened!
19:19:19 <MyCatVerbs> Aieee! She's gone! Nooooooo!
19:19:47 <mbz> that's bad :\
19:19:58 <Spockz|Orthesaur> Stack overflow :p
19:20:17 <shubuntu> http://hpaste.org/7713
19:20:32 <shubuntu> ok can you guys help transfer it into higher order now?
19:21:27 <Spockz|Orthesaur> but lamdabot is just not here
19:21:34 <Spockz|Orthesaur> maybe she is sleeping?
19:21:53 <shubuntu> lambdabot is prolly in church
19:21:55 <shubuntu> lol
19:22:10 <shubuntu> or maybe out to lunch
19:22:22 <chessguy> shubuntu: you clearly haven't even typechecked that
19:22:42 <shubuntu> did i wrongly copy paste?
19:24:11 <orbitz> row:(replace stone (x,y-1) row
19:24:13 <orbitz> is that right?
19:24:21 <dmwit> orbitz: Did you even try it once?
19:24:27 <orbitz> missing a )
19:24:28 <dmwit> You will see it's wrong if you do. ;-)
19:24:32 <orbitz> dmwit: it's not mine :)
19:24:37 <shubuntu> http://hpaste.org/7714
19:24:46 <dmwit> orbitz: Sorry, mis-nick.
19:24:50 <shubuntu> fixed
19:25:03 <shubuntu> mistake of copy paste
19:25:04 <shubuntu> lol
19:25:05 <shubuntu> sorry
19:25:08 <dmwit> shubuntu: It has a bug, if you want a fixed-size board.
19:25:26 <shubuntu> check the new one dmwit
19:25:29 <shubuntu> shouldn't have a bug
19:25:33 <chessguy> dmwit: only one?
19:25:34 <dmwit> shubuntu: I am talking about the new one.
19:25:42 <shubuntu> ok what's the bug
19:25:49 <dmwit> shubuntu: Try it out and see for yourself.
19:26:03 <shubuntu> i'm testing it and it works
19:26:15 <dmwit> oh
19:26:19 <dmwit> Heh, I misread.
19:26:21 <Spockz|Orthesaur> Does anyone know how to properly install ghc on a mac?
19:26:22 <dmwit> =P
19:26:36 <chessguy> Spockz|Orthesaur: i did it with macports
19:26:36 <dmwit> shubuntu: Sorry for being inflammatory.
19:26:54 <shubuntu> hehe no worries dmwit
19:27:00 <shubuntu> happens to the best of us
19:27:26 <dmwit> shubuntu: Okay, do you see the pattern you are using in both parts of the code?
19:27:41 <shubuntu> yes it's an iterative pattern
19:27:43 <dmwit> Namely: iterate until a counter reaches zero, then update that part of the list.
19:27:51 <dmwit> See if you can abstract away that behavior.
19:27:51 <Spockz|Orthesaur> chessguy: There is an download for leopard available from the ghc webste, however I can't run the configure script
19:28:09 <chessguy> Spockz|Orthesaur: so...why not use macports?
19:28:16 <shubuntu> ok
19:28:30 <roconnor> @hoogle concatM
19:28:38 <roconnor> oh right
19:28:40 <dmwit> shubuntu: So, you should write a function that takes an "updater" that knows how to update a single element, an index, and a list.
19:28:44 <Spockz|Orthesaur> chessguy: dunno, just telling what I tried I guess?
19:28:50 <dmwit> shubuntu: It should return the list, with the corresponding element updated.
19:28:59 <chessguy> Spockz|Orthesaur: likewise :)
19:29:10 <chessguy> except it worked for me
19:29:49 <shubuntu> updater :: Int -> [a] -> [a]?
19:30:07 <shubuntu> updater :: Int -> a -> [a] -> [a]?
19:30:08 <dmwit> shubuntu: updater :: (a -> a) -> Int -> [a] -> [a]
19:30:24 <dmwit> shubuntu: The first argument should be a function that knows how to update a single element.
19:30:33 <dmwit> shubuntu: It's not enough to *replace* a given element with a new one.
19:30:44 <Spockz|Orthesaur> chessguy: the macports thing? Or the ghc download?
19:30:56 <dmwit> shubuntu: (If you look at the definition of "replace", you'll see why: the new value depends on the old one.)
19:30:58 <chessguy> Spockz|Orthesaur: the macports
19:31:35 <shubuntu> i don't get what you're trying to say
19:31:45 <orbitz> dmwit: fyi i made a delicious asian stir fry tonight
19:31:46 <dmwit> shubuntu: Hm.
19:31:56 <dmwit> orbitz: ...?  Well, great!
19:32:07 <shubuntu> show me mathematically?
19:32:09 <shubuntu> lol
19:32:10 <orbitz> dmwit: i hought so
19:32:28 <dmwit> shubuntu: Take a look at this line from the definition of "replace":
19:32:47 <dmwit> replace ... = newRow : rows where newRow = insertAt ... row
19:33:01 <dmwit> shubuntu: Notice that the value "newRow" is a *function* of row.
19:33:05 <shubuntu> yes
19:33:24 <dmwit> shubuntu: So, when you are writing "updater", you need to be able to apply a function to any single element.
19:33:42 <dmwit> shubuntu: It's not enough to replace that element with a new one known ahead of time; you need to apply a function to the old value.
19:33:46 <dmwit> shubuntu: Do you see what I am saying?
19:33:56 <dmwit> shubuntu: It's the difference between
19:34:03 <dmwit> arr[i] = newVal;
19:34:04 <dmwit> and
19:34:11 <dmwit> arr[i] = f(arr[i]);
19:35:16 <dmwit> (i.e. you don't know the value of arr[i] until you've iterated to the i'th position, so it doesn't make sense to write "newVal = f(arr[i])" on the previous line.)
19:35:33 <dmwit> This is only a half-truth, but maybe you believe me anyway. ;-)
19:36:10 <shubuntu> updater (x,y) stone board = insertAt y (insertAt x stone) board?
19:36:16 <shubuntu> that's problematic
19:36:27 <dmwit> Exactly!
19:36:30 <dmwit> It's problematic.
19:36:31 <shubuntu> that can't be right
19:36:34 <dmwit> So you need something more general.
19:36:46 <dmwit> I am trying to give you a hint about what direction to generalize.
19:36:55 <dmwit> But I'm not convinced you're following along with me. =P
19:37:08 <shubuntu> yeah lost in translation
19:37:09 <shubuntu> lol
19:37:15 * SamB wonders about getting RSS feeds for darcs repositories...
19:37:20 <dmwit> shubuntu: Okay.
19:37:25 <dmwit> shubuntu: There are two things happening here.
19:37:33 <dmwit> shubuntu: 1. you iterate to the i'th position
19:37:41 <dmwit> shubuntu: 2. you replace the i'th position with a new value
19:37:50 <dmwit> shubuntu: I'm convinced you know how to do (1), right?
19:37:51 <shubuntu> exactly
19:38:08 <dmwit> shubuntu: So, we only need to tackle (2).
19:38:11 <shubuntu> well I'm doing it in that code aren't i
19:38:17 <dmwit> shubuntu: There are (at least) two approaches to (2).
19:38:35 <dmwit> shubuntu: Approach one is what you are doing right now: send the new value as an argument to your updater.
19:38:43 <dmwit> This gets you "insertAt".
19:38:51 <shubuntu> kk
19:38:54 <dmwit> shubuntu: Here is another (radical!) approach:
19:39:20 <dmwit> shubuntu: Send a *function* that takes the *old* value at the i'th position, and returns the *new* value for the i'th position.
19:41:27 <shubuntu> i understand that now
19:41:28 <shubuntu> ok
19:41:30 <shubuntu> next?
19:41:47 * chessguy chuckles
19:41:53 <chessguy> next you write the function :)
19:42:08 <dmwit> shubuntu: Okay, so what would the type of this hypothetical updater (that takes a function) be?
19:42:11 <shubuntu> not yet
19:42:33 <shubuntu> i need to work out what updater does in respect to replace
19:42:50 <dmwit> No, easy things first!
19:42:54 <dmwit> We'll get updater.
19:43:01 <dmwit> Then we'll write insertAt in terms of updater.
19:43:11 <dmwit> Then we'll write replace.
19:43:19 <dmwit> Then we'll collapse replace and insertAt. ;-)
19:43:39 <shubuntu> ok
19:43:44 <shubuntu> so first updater
19:43:46 <Spockz|Orthesaur> chessguy: I've installed MacPorts
19:43:52 <dmwit> shubuntu: What would its type be?
19:44:02 <Spockz|Orthesaur> but the ghc download is a diff file?
19:44:17 <shubuntu> updater :: (a->a) -> Int -> [a] -> [a]
19:44:51 <chessguy> Spockz|Orthesaur: eh?
19:44:58 <dmwit> shubuntu: Great!
19:45:09 <dmwit> shubuntu: Now, see if you can write a first version of updater.
19:45:09 <shubuntu> ok now to define updater
19:45:14 <chessguy> Spockz|Orthesaur: once you have macports going, you should just be able to do something like 'port install ghc'
19:45:25 <Spockz|Orthesaur> aaaah
19:45:28 <dmwit> shubuntu: At this point, using explicit recursion (a la the style you used for "insertAt") should be fine.
19:46:11 <Spockz|Orthesaur> chessguy: macport nor port is a recognized command in the terminal?
19:46:38 <chessguy> Spockz|Orthesaur: on my machine it put it in /opt/local/bin/
19:46:46 <nolrai_> so any ideas of what image formats pixbufNewFromFile (from gtk2hs) supports?
19:46:51 <shubuntu> updater f 0 (x:xs) = (f x):xs
19:47:09 <chessguy> Spockz|Orthesaur: you may want to add it to your path
19:47:13 <shubuntu> updater f i (x:xs) = updater f i-1 xs
19:47:25 <dmwit> shubuntu: Correct, up to parentheses. =)
19:47:36 <dmwit> updater f i (x:xs) = updater f (i-1) xs
19:47:42 <Spockz|Orthesaur> chessguy: Ok, i'm in that directory
19:47:52 <dmwit> shubuntu: Okay, now this part is kind of tricky.
19:47:55 <chessguy> Spockz|Orthesaur: now run that command
19:48:02 <dmwit> shubuntu: How would you write insertAt in terms of updater?
19:48:10 <chessguy> Spockz|Orthesaur: (port install ghc)
19:48:12 <Spockz|Orthesaur> chessguy: Still the same
19:48:35 <chessguy> Spockz|Orthesaur: is the port command there?
19:48:38 <Spockz|Orthesaur> but I can see 'port' and 'portf' with ls
19:48:56 <chessguy> try doing ./port ...
19:49:11 <xif> anyone editing Haskell code with Vim here?
19:49:16 <dmwit> Yes+
19:49:23 <chessguy> xif: sorry, we use real editors
19:49:25 * chessguy ducks
19:49:38 <dmwit> xif: You might like: http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
19:49:43 <Spockz|Orthesaur> chessguy: permission denied? :(
19:49:45 <dmwit> shubuntu: I'll give you a hint.
19:49:46 <shubuntu> insertAt x stone row = updater (const stone) x row
19:49:53 <dmwit> shubuntu: Oh, perfect!
19:49:54 <chessguy> Spockz|Orthesaur: ah, you'll want to chown it
19:49:56 <Spockz|Orthesaur> let's sudo
19:50:01 <xif> dmwit: thanks, looks great.
19:50:07 <chessguy> that'll work too
19:50:16 <Spockz|Orthesaur> chessguy: what's better? sudo or chown?
19:50:23 * chessguy shrugs
19:50:28 <dmwit> shubuntu: Okay, now how about writing "replace" in terms of "insertAt" and "updater"?
19:50:32 <chessguy> your system
19:51:59 <Spockz|Orthesaur> chessguy: sure, but in theory. ;)
19:52:08 <Spockz|Orthesaur> Now there are some dependancy errors
19:52:30 <Spockz|Orthesaur> well i'll look at in the morning. It's 4:52 AM now here..
19:53:47 <shubuntu> replace stone (x,0) (row:rows) = (updater (const stone) x row):rows
19:54:08 <dmwit> shubuntu: Hmm.
19:54:20 <dmwit> shubuntu: This one doesn't look like it's using our fancy new updater.
19:54:40 <shubuntu> why not?
19:54:51 <shubuntu> i'm just taking that insertAt out of the equation
19:55:23 <dmwit> shubuntu: For now, let's keep insertAt, and see if we can use our new updater to eliminate the explicit recursion in replace.
19:55:36 <dmwit> (That was the whole point of writing updater in the first place.)
19:55:49 <shubuntu> replace stone (x,0) (row:rows) = newRow:rows           where newRow = insertAt x stone row
19:57:12 <dmwit> shubuntu: Imagine that instead of
19:57:20 <dmwit> replace :: Stone -> Coord -> Board -> Board
19:57:21 <dmwit> we had
19:57:30 <dmwit> replace :: Stone -> Coord -> [Row] -> [Row]
19:57:34 <orbitz> ahh
19:57:38 <shubuntu> yeah
19:57:40 <shubuntu> ok
19:57:42 <orbitz> wine and honey nut cheerios, not the delicious mix i envisione
19:57:52 <dmwit> shubuntu: So we're iterating over the Row's.
19:58:01 <dmwit> shubuntu: Why not hand off that iteration to "updater"?
19:58:06 <shubuntu> so we should call
19:58:26 <shubuntu> updater f y board
19:58:37 <shubuntu> where f is a function of row
19:58:41 <shubuntu> i get that
19:58:49 <dmwit> Okay!
19:58:52 <shubuntu> i'm having trouble expressing it right
19:59:03 <dmwit> Now, just use the "f" that you already have in your definition of replace.
19:59:10 <dmwit> Hint: it's in the "where" clause. ;-)
20:01:16 <shubuntu> replace stone (x,y) board = updater (updater (const stone) x) y board
20:01:19 <shubuntu> right?
20:01:34 <shubuntu> i hope i didn't make any mistakes
20:02:03 <dmwit> Yeah!
20:02:04 <dmwit> Nice!
20:02:10 <shubuntu> wooh
20:02:12 <shubuntu> finally
20:02:14 <shubuntu> lol
20:02:22 <dmwit> Now, you want bonus points?
20:02:28 <shubuntu> yes
20:02:38 <dmwit> Okay, recall all the way back to when you were writing updater.
20:02:47 <dmwit> We said two things were happening: (1) iterating, (2) update.
20:02:55 <shubuntu> yes
20:02:56 <dmwit> It turns out you can separate these two things.
20:03:01 <dmwit> There's already a function that does (1).
20:03:05 <dmwit> It's called splitAt.
20:03:11 <dmwit> splitAt :: Int -> [a] -> ([a], [a]).
20:03:11 <shubuntu> ok
20:03:28 <dmwit> See if you can see how to use splitAt to write updater without explicit recursion.
20:03:40 <shubuntu> well question here
20:03:43 <dmwit> Sure!
20:03:48 <shubuntu> what happens if x =0
20:04:08 <dmwit> With splitAt, or with explicit recursion?
20:04:16 <shubuntu> splitAt
20:04:26 <orbitz> try it
20:04:30 <dmwit> splitAt 0 [a, b, ...] = ([], [a, b, ...])
20:04:32 <orbitz> ghci
20:04:33 <shubuntu> what happens if x = length row
20:04:36 <dmwit> But yes, try it. ;-)
20:04:57 <dmwit> shubuntu: That's an error, as it ought to be.
20:05:02 <gnuvince_> ~urbandict junk
20:05:06 <dmwit> shubuntu: (Out-of-bounds access.)
20:05:19 <shubuntu> well it shouldn't be out of bound?
20:05:28 <orbitz> hrm
20:05:32 <shubuntu> I don't understand this bit
20:05:38 <dmwit> shubuntu: Off-by-one.
20:05:41 <orbitz> splitAt 4 [1, 2] -> ([1,2],[])
20:05:46 <orbitz> shubuntu: 0 index
20:05:47 <dmwit> shubuntu: The bounds are [0..length row - 1].
20:06:02 <dmwit> orbitz: Oh, interesting.
20:06:51 <Apokalipz> http://www.prizerebel.com/index.php?r=225026 Go there to get awesome free prizes such as Anime, Video Games, Nexon Cards and much more! Click on the link, sign up, and start earning points by completing the surveys and 100% free offers (No credit card required). Redeem the points that you earned to get those free prizes. Its that easy! So what are you waiting for? Click on that link, sign up, and start earning those points
20:06:58 <dmwit> ?ops
20:07:00 <dmwit> bah!
20:07:01 <shubuntu> well that's problematic for me?
20:07:03 <dmwit> No bot.
20:07:04 <orbitz> no lambda bot!
20:07:05 <dmwit> shubuntu: Why?
20:07:13 <orbitz> #haskell is criped without it
20:07:20 <shubuntu> because when x = 0 i need the first item on the list
20:07:26 <shubuntu> this doesn't do it right
20:07:33 <dmwit> "this" meaning what?
20:07:42 <shubuntu> and when x = length-1 i want the last item on the list
20:07:59 <orbitz> length -1 is the last elemnt
20:08:17 <orbitz> splitAt 1 [1, 2] == ([1],[2])
20:08:34 <dmwit> shubuntu: splitAt n xs = (take n xs, drop n xs)
20:08:42 <shubuntu> the thing is
20:08:49 <dmwit> shubuntu: So, it *does* do what you want, you just have to think a little bit about it.
20:08:50 <shubuntu> perhaps i'm not explaining right
20:09:04 <shubuntu> ok let's say
20:09:10 <shubuntu> we have a list of 3 items
20:09:20 <shubuntu> and we have a coordinate
20:09:36 <shubuntu> coords are 0 : first item
20:09:44 <shubuntu> 1: second item
20:09:51 <shubuntu> 2:third item
20:09:58 <orbitz> right right, 0 idnexed
20:10:01 <orbitz> continue
20:10:12 <shubuntu> ok now with your splitAt
20:10:17 <shubuntu> i can't access them right
20:10:21 <shubuntu> because if I say
20:10:26 <shubuntu> splitAt x
20:10:31 <shubuntu> while x = 0
20:10:46 <shubuntu> it will return an empty item in the first position of the tuple
20:10:56 <dmwit> Yes, but what about in the *second* position?
20:10:58 <dmwit> ;-)
20:11:11 <shubuntu> it will return the whole row
20:11:16 <shubuntu> which isn't what I want
20:11:20 <dmwit> Are you sure?
20:11:23 <shubuntu> remember
20:11:24 <thetallguy> > map (\n -> splitAt n [1,2,3]) [0..4]
20:11:44 <shubuntu> we want to single out the xth item from a list
20:11:55 <shubuntu> 0th being the first and so on
20:11:57 <dmwit> shubuntu: Yes, and what's at the head of the second position?
20:12:02 <thetallguy> ou est le bot?
20:12:04 <orbitz> do you wan tto access specific elements? you can use (!!)
20:12:04 <dmwit> shubuntu: I would have to say it's the first element of the list.
20:12:08 <thetallguy> Oh, I see, it died.
20:12:14 <shubuntu> ok
20:12:17 <shubuntu> so let's say
20:12:17 <dmwit> orbitz: We also want the elements before and after the nth element.
20:12:21 <shubuntu> we go by your rule
20:12:35 <orbitz> dmwit: so he want somethign like ([a], a, [a]) returned?
20:12:41 <dmwit> orbitz: Yeah.
20:12:46 <dmwit> orbitz: Hence, splitAt. ;-)
20:12:54 <orbitz> that's not to hard
20:12:59 <dmwit> orbitz: shhh
20:13:03 <shubuntu> head j | (i,j) <- splitAt x row
20:13:04 <dmwit> orbitz: He's working it out for himself.
20:13:13 <orbitz> whoops sorry
20:13:21 <orbitz> :)
20:13:41 <edwardk> gah. don't you hate it when you discover something has been written up before, but the last time it was in print was 1972? ;)
20:13:46 <conal> geezusfreeek: thanks for the update.  i'm glad to hear your futures re-impl is going well.  i have a good feeling about this one.
20:14:33 <edwardk> @seen dolio
20:14:40 <edwardk> er wait, bot dead
20:14:44 <shubuntu> dmwit?
20:15:13 <orbitz> shubuntu: yeah that's what ou want
20:15:32 <dmwit> shubuntu: Yeah, you want something like that (though the syntax is not right).
20:15:38 <orbitz> hehe
20:15:51 <thetallguy> So, what should this 'newSplitAt' do with 'newSplitAt 0 [1,2,3]' ?
20:16:06 <thetallguy> ([],1,[2,3])?
20:16:22 <dmwit> thetallguy: Yeah, but let's just skip newSplitAt and just use splitAt. ;-)
20:16:36 <dmwit> thetallguy: No sense defining a new one, what with our beautiful pattern matching ability.
20:17:12 <thetallguy> Heh.
20:17:30 <shubuntu> ok don't confuse me now
20:17:30 <shubuntu> lol
20:17:48 <orbitz> shubuntu: consider (:)
20:17:54 * dolio is slowly driven insane by Template Haskell.
20:17:58 <dmwit> Okay, I'm leaving now.
20:18:05 <dmwit> shubuntu: But good luck! =)
20:18:13 <dolio> edwardk: What you need?
20:19:33 <shubuntu> thanks
20:19:35 <shubuntu> have fun
20:20:22 <edwardk> dolio: nothing really, just got category-extras to build again
20:21:46 <edwardk> dolio: though i think i should try to make a 'no-type families available' compile flag work before restoring it to hackage
20:22:25 <dolio> Probably a good idea, since most people don't have a compiler that implements a definitely-correct version of type families.
20:22:34 <edwardk> yeah
20:22:38 <dolio> Or, technically, no one does.
20:22:52 <dolio> Since 6.9 isn't complete either/still has bugs.
20:23:25 <edwardk> i've only caused 2-3 panics so far, no big deal ;)
20:24:56 <dolio> Well, I got a type error for something that shouldn't be last time I tried it.
20:29:02 <thetallguy> who was working on the new splitAt?
20:35:02 <dolio> Riddle me this:
20:36:12 <dolio> Why does 'foo :: (C1 e, Ord e) => e -> T ; foo = bar compare ; bar :: (C1 e) => (e -> e -> Ordering) -> e -> T ; bar cmp e = ...' get complained about with TH on, but not off?
20:36:28 <dolio> The complaint being 'differing context lengths.'
20:37:09 <dolio> If you need glasgow-exts for that, shouldn't it get complained about without them whether or not template haskell is enabled?
20:37:47 <shubuntu> ok any other smart haskell programmers that can help me finish this?
20:38:42 <orbitz> shubuntu: are you still stuck on using splitAT?
20:39:03 <xif> dmwit: that Haskell mode is nice, unfortunately it doesn't provide indent.
20:39:29 <shubuntu> yes
20:39:47 <shubuntu> i know I've got to use ++ somehow to add those bits
20:39:55 <orbitz> shubuntu: to add what bits?
20:40:02 <xif> anyone using Vim to edit Haskell here?
20:40:05 <shubuntu> http://hpaste.org/7716
20:40:15 <xif> I'm looking for a good Vim Haskell indent script.
20:40:17 <shubuntu> I've gotta split it into three parts
20:40:44 <shubuntu> (splitAt x lst)
20:40:55 <shubuntu> gives me a (i,j) tuple
20:41:02 <orbitz> shubuntu: so you want to split list on x, but you want the stuff before the list, the element you want, adn teh stuff after the list right?
20:41:14 <orbitz> shubuntu: splitAt 0 lst, what does that give you?
20:41:35 <shubuntu> that gives ([], lst)
20:41:49 <orbitz> shubuntu: and you want the head of lst though right?
20:41:58 <shubuntu> i need all the elements
20:42:01 <shubuntu> so i'm thinking
20:42:17 <orbitz> right, but you specificaly want the head of lst for your updater right?
20:42:45 <shubuntu> (i,j)<- splitAt x lst, (k,l) <- splitAt 1 j
20:42:53 <orbitz> shubuntu: eeep
20:43:11 <orbitz> shubuntu: you just want the head of j don't you? why another split?
20:43:25 <shubuntu> i need it to update the row
20:43:36 <orbitz> yes i know
20:43:44 <orbitz> but you ened ot extract the head of j
20:43:45 <shubuntu> i need to apply f on that head of that list
20:43:46 <orbitz> so extract it
20:44:02 <orbitz> you don't need to do another splitAt
20:44:11 <shubuntu> huh?
20:44:18 <shubuntu> i'm confused
20:44:23 <orbitz> what are you confused about?
20:44:44 <orbitz> shubuntu: if you have [1, 2, 3], and x == 1, you want [1], 2, [3] yes?
20:44:57 <shubuntu> yes
20:45:11 <orbitz> so splitAt 1 [1, 2, 3] gives you ([1], [2, 3])
20:45:15 <orbitz> so ust pull the 2 out of there
20:45:25 <shubuntu> ok?
20:45:46 <orbitz> shubuntu: what is the pattern you use when you are recursing over a list?
20:46:15 <shubuntu> you keep going down to 0
20:46:24 <orbitz> no, what is the pattern you match on
20:46:30 <shubuntu> f
20:46:34 <orbitz> recurseFoo ... =
20:46:36 <orbitz> wha tis teh ...
20:46:42 <orbitz> i'm asking a general question
20:47:15 <shubuntu> recurseFoo (x:xs)
20:47:49 <orbitz> shubuntu: right, so if you do let (x:xs) = [2, 3]
20:47:52 <orbitz> what is x, and what is xs?
20:48:05 <shubuntu> 2, [3[
20:48:10 <orbitz> so there you go
20:48:22 <shubuntu> how do i write it in though
20:48:23 <shubuntu> lol
20:48:39 <orbitz> use a let to bind the values returend from splitAt to soem variables
20:48:44 <orbitz> (or where)
20:49:30 <edwardk> hrmm does cabal build the files for haddock with the cpp-options set?
20:49:44 <shubuntu> updater f x lst = is: (f j): js where (i,j) = splitAt x lst
20:49:56 <orbitz> shubuntu: apply your x:xs knowledge to j
20:50:08 <shubuntu> updater f x lst = is: (f j): js where (is, j:js) = splitAt x lst
20:50:34 <edwardk> coz with a ghc-options: -D__ARROW_SUBCLASSES_CATEGORY__  everything is fine. but with a cpp-options: -D__ARROW_SUBCLASSES_CATEGORY__ while the code builds, haddock doesn't see the definition.
20:50:39 <orbitz> shubuntu: you need to use ++, as [1]:[2, 3] == [[1], 2 3] which dons't work
20:51:15 <shubuntu> updater f x lst = is ++ (f j): js where (is, j:js) = splitAt x lst
20:51:30 <shubuntu> or should i go
20:51:42 <shubuntu> updater f x lst = is ++ [(f j)]++ js where (is, j:js) = splitAt x lst
20:52:00 <orbitz> proabbly doesn't matter, , i prefer usign :
20:52:14 <shubuntu> ok so the fist one?
20:52:20 <orbitz> if you want
20:55:08 <shubuntu> let board = [[Dark,Light,Vacant]] in put Light (3,0) board
20:55:08 <shubuntu> [*** Exception: Othello.hs:56:24-49: Irrefutable pattern failed for pattern (is, j : js)
20:55:50 <orbitz> shubuntu: your x is probably too large
20:56:14 <shubuntu> yeah
20:56:15 <orbitz> shubuntu: [] == x:xs can't be true
20:56:24 <shubuntu> let board = [[Dark,Light,Vacant]] in put Light (2,0) board
20:56:24 <shubuntu> [[Dark,Light,Light]]
20:57:02 <shubuntu> thanks
20:57:03 <shubuntu> :)
20:58:29 <shubuntu> can i apply the same technique for flipAll?
20:59:04 <shubuntu> or can i map it somehow?
20:59:21 <shubuntu> flipAll :: Board -> Stone -> [Coord] -> Board
20:59:21 <shubuntu> flipAll board stone places =
21:00:32 <shubuntu> the recursive way is easy
21:00:39 <shubuntu> but how do i make it higher level
21:01:25 <orbitz> what does flipAll do?
21:02:53 <shubuntu> flipAll board stone []             = board
21:02:53 <shubuntu> flipAll board stone (place:places) = put (opponent stone) place: flipAll board stone places
21:03:09 <shubuntu> oops hold on lemme fix that
21:03:25 <glguy> shubuntu: if you have a lot of code to paste you can also use http://hpaste.org
21:03:39 <glguy> makes it easier to look at all at once
21:03:45 <glguy> and it doesn't scroll off the screen
21:04:16 <shubuntu> http://hpaste.org/7717
21:05:15 <orbitz> you can just do that with map
21:05:58 <shubuntu> ok
21:06:03 <shubuntu> how do i go about it?
21:06:17 <orbitz> look up the map function, and apply
21:07:36 <Saizan> shubuntu: does that flipAll compile?
21:07:48 <thetallguy> map  not [True, False, True]
21:07:48 <thetallguy> [False,True,False]
21:07:50 <shubuntu> flipAll board stone places = map (put (opponent stone) places) board?
21:08:15 <shubuntu> yes it does
21:08:17 <orbitz> no
21:08:27 <orbitz> you don't call put on places, you call i ton a place
21:08:34 <dolio> Man...
21:08:41 <orbitz> and board is the last argument to put
21:08:51 <orbitz> shubuntu: do you understand what map does?
21:09:14 <shubuntu> yes it maps a function on items
21:09:23 <orbitz> what items?
21:09:27 <shubuntu> in a list
21:09:31 <shubuntu> and returns a list
21:09:34 <orbitz> in your case?
21:09:50 <orbitz> specificaly, what items in your case
21:10:08 <dolio> So, I spent hours writing a template haskell version of (statically) variable branching heapsort, and it turns out that the optimal version is the trinary heapsort I'd already implemented by hand.
21:10:36 <shubuntu> i want to map put on items in the board that correspond to coordinates in places
21:10:52 <orbitz> so what list do you want to map a function on to?
21:11:15 <shubuntu> to board?
21:11:27 <shubuntu> no wait
21:11:31 <shubuntu> to places
21:11:32 <orbitz> that isn't what it looks like in your code
21:11:50 <shubuntu> i need to map to places
21:11:58 <conal> ping Saizan
21:11:58 <shubuntu> and produce a list of functions right
21:12:06 <orbitz> uhh no
21:12:09 <orbitz> you want to apply a function
21:12:22 <conal> ping dcoutts
21:15:19 <shubuntu> map f (x:xs) = f x : map f xs
21:15:23 <shubuntu> isn't that true?
21:16:09 <orbitz> more or les
21:16:14 <orbitz> it might be tail recursive or osmething
21:16:26 <glguy> tail recursive would be bad for map
21:16:34 <orbitz> why?
21:16:35 <glguy> ?src map
21:16:49 <glguy> Because it would break map's lazy semantics
21:16:56 <orbitz> oh ok
21:17:17 <shubuntu> so if i go flipAll board stone places = map (put (opponent stone)) places board
21:17:22 <shubuntu> that won't work
21:17:31 <orbitz> correct it won't
21:17:46 <orbitz> map :: (a -> b) -> [a] -> [b]
21:18:05 <Saizan> conal: pong
21:18:06 <orbitz> yours does not match that
21:18:13 <shubuntu> so i'm guessing b has to be functions
21:18:20 <orbitz> no
21:18:22 <orbitz> b is the new type
21:18:26 <shubuntu> yeah
21:18:26 <orbitz> (a -> b) is a function
21:18:37 <shubuntu> well can't b itsel be a function
21:18:37 <orbitz> b can be teh same as a
21:18:47 <shubuntu> well i donno
21:18:49 <orbitz> it can, but why would you want that? it's not what your flipAll does
21:19:04 <orbitz> don't you want to apply the funciton 'put' to every elemnt of places?
21:19:18 <shubuntu> well i need to apply put on place:places in board
21:19:34 <orbitz> you apply put on every element of places
21:19:34 <shubuntu> i want to apply it with respect to board
21:19:37 <conal> Saizan: i've been chatting with paolino about maybe helping with cabal dependencies.
21:19:41 <conal> Saizan: using frp ideas
21:19:43 <orbitz> sire
21:19:46 <orbitz> so i can do
21:19:46 <shubuntu> but what about board
21:20:00 <orbitz> addNToall n = map (\e -> e + n) [1, 2, 3]
21:20:18 <orbitz> notice how i'm not passing 'n' to map
21:20:47 <Saizan> conal: yeah, he told me something like that
21:21:36 <shubuntu> flipAll board stone places = map (\place -> put (opponent stone) place board) places
21:21:40 <shubuntu> like that?
21:21:48 <orbitz> does it work?
21:21:58 <shubuntu> let me test
21:22:15 <conal> Saizan: i'm interested in giving a clear semantic specification and then working from there.  i'm guessing that what interests me is outside the scope of the soc project and perhaps even the cabal project overall, but i wanted to check with you and/or duncan.
21:22:45 <shubuntu> no
21:22:51 <shubuntu> says place is not in scope
21:23:05 <orbitz> i doubt that for somereason
21:23:32 <conal> Saizan: my guess is that one the problem (independent of its solution) is clearly defined, we'd want to revisit some fundamental decisions in cabal.
21:24:27 <conal> Saizan: my impression is that there's been a lot of work on how to implement the task, but not so much on what the task is.
21:25:08 <Saizan> conal: i've been thinking about the problem in terms of frp too, but there are some differencies wrt the notion of time-changing values and what we want
21:25:37 <conal> Saizan: do you have an example?
21:27:13 <Saizan> conal: we can e.g. recompute a value because some of its dependecies have changed, but if the recomputation gives the same result as the previously seen we don't need to trigger more recomputation
21:27:33 <shubuntu> it's giving a random error
21:27:37 <conal> Saizan: great.  that's consistent with frp semantics.  i'd do the same.
21:27:47 <orbitz> shubuntu: feel free to paste it and the code to hpaste
21:28:11 <conal> Saizan: btw, i would not want to use an existing frp implementation for this problem.
21:28:15 <shubuntu> http://hpaste.org/7718
21:28:17 <conal> Saizan: i'd want to design a new one.
21:28:39 <conal> Saizan: based on an algebra of recomputation strategies.
21:28:59 <conal> Saizan: having a consistent denotational semantics
21:29:05 <conal> (done)
21:29:08 <orbitz> shubuntu: code too
21:29:28 <Saizan> conal: that seems a bit too much for soc, but yes i think it would need a new framework too
21:29:33 <geezusfreeek> ah looks like i get to work on futures some more before going to bed
21:29:43 <Saizan> conal: another problem is that we'd want extensive sharing
21:29:45 <conal> geezusfreeek: whee!
21:29:50 <orbitz> futures? like options?
21:29:59 <conal> Saizan: what kind of sharing?
21:30:01 <geezusfreeek> orbitz: futures like undetermined values
21:30:08 <orbitz> ohhh
21:31:19 <Saizan> conal: sharing of reactive values, even if they are not let-bound, unless we explicitly use a Map or something
21:31:23 <shubuntu> http://hpaste.org/7719
21:31:28 <shubuntu> is that good enough
21:31:50 <conal> Saizan: i don't know what you mean that's different from what frp implementations already do.
21:32:47 <Saizan> conal: they do it if i pass the value around in my expression, i guess
21:33:10 <Saizan> conal: and that's perfectly reasonable
21:33:25 <conal> Saizan: i'm not following what you're saying.
21:33:40 <Saizan> ok..
21:33:46 <conal> Saizan: i don't know whether you're describing a problem that i don't recognize, or maybe you have a misconception.
21:34:19 <conal> Saizan: anyway, i get it that the questions i raise are beyond the scope of the soc project.
21:34:20 <Saizan> conal: i don't know either, maybe i can try describing the problem in terms of dependencies hoping you can map it to frp :)
21:35:01 <conal> Saizan: sure.  if you'd like.  i'm also happy to drop it, considering the project is about implementation, not research.
21:35:30 <orbitz> shubuntu: are you sure your original flipAll worked?
21:36:20 <shubuntu> yes
21:37:01 <orbitz> shubuntu: can you put it back up
21:37:12 <orbitz> to compare
21:40:19 <Saizan> conal: ok, with somewhat imaginary syntax, "link <*> traverse compile [A.hs,B.hs]" now, executing the "compile A.hs" part, we realize that it depends on "compile B.hs", but we already need to compute it as part of the overall traverse expression, how can the two consumers of the reactive value denoted by "compile B.hs" simply share its computation?
21:40:22 <shubuntu> ugh now it's not working either
21:40:29 <shubuntu> must be the put function?
21:40:30 <orbitz> shubuntu: :)
21:40:41 <orbitz> i don't know
21:40:45 <shubuntu> it worked before we changed the put function
21:40:57 <orbitz> when did we change the put function?
21:41:09 <shubuntu> when we used updater
21:41:15 <orbitz> oh i wasn't htere for that
21:41:19 <shubuntu> before that i was using a recursive way
21:42:02 <shubuntu> http://hpaste.org/7720
21:42:10 <shubuntu> the commented part is the original put function
21:42:14 <Saizan> conal: honestly i think that if my soc involves research is a lot more fun :) but we still need a reasonable dep. system by the end of the summer
21:44:18 <orbitz> shubuntu: i dunno, i'm sure you'll figure it out
21:44:21 <conal> Saizan: i get it.  i don't think it's possible to create something beautiful (simple, powerful, general, robust) from the current state during one summer.  i think it'd take rethinking and redesigning cabal from scratch.  a completely separate project from cabal.
21:44:35 <shubuntu> it's annoying
21:44:36 <shubuntu> lol
21:44:46 <shubuntu> i don't have any toolkits to use
21:45:03 <shubuntu> there's no environment thingie like c++
21:45:15 <shubuntu> i can't follow my functions to see what they're doing at each level
21:45:21 <Saizan> conal: do you have anything to say about my example above?
21:45:23 <shubuntu> and follow the variables
21:45:41 <orbitz> shubuntu: that wouldn't help as your code doe snot compile
21:46:00 <shubuntu> in c++ environments it doesn't matter
21:46:07 <shubuntu> it'll compile to a point
21:46:11 <orbitz> C++ code stil needs to compile in order to debut
21:46:12 <shubuntu> and see what you're passing
21:46:13 <orbitz> debug*
21:46:17 <orbitz> uhh no
21:46:22 <orbitz> if you cannot link your C++ project you cannot debug it
21:46:37 <shubuntu> i do that all the time in visual cpp
21:46:41 <shubuntu> lol
21:46:41 <orbitz> no you don't
21:46:43 <conal> sure.  i'd first see about breaking the problem in two.  one part tracks dependencies and changes to dependencies.  the other tracks changes of inputs with respect to a given set of dependencies.
21:46:52 <shubuntu> come on over and I'll show you
21:47:02 <shubuntu> i say compile to this point
21:47:04 <shubuntu> and debug
21:47:34 <orbitz> are you confusing compiling with a breakpoint?
21:47:42 <conal> Saizan: in other words, i'd preprocess the problem to a much simpler, functional form.
21:48:08 <conal> Saizan: where the preprocessing is also specified and implemented by frp
21:49:18 <conal> i had an aha! last year that the source code of even functional programs is structured using deeply imperative concepts, not functional ones.
21:49:51 <conal> and that restructuring them functional reduces this whole 'make' problem to a very simple thing.
21:49:58 <conal> (s/functional/functionally)
21:51:04 <conal> Saizan: for me, that insight explains why the cabal dependency problem is a messy one.  rather than solve the problem as is, i'd clean it up in one phase and then optimally solve the remaining trivial problem in the second phase.
21:51:29 <conal> because dependency management is simple for functional semantics and a mess for imperative.
21:51:43 <shubuntu> argh the previous compliation was wrong
21:51:43 <shubuntu> lol
21:51:52 <shubuntu> i wonder why it compiled in the first place
21:51:53 <shubuntu> lol
21:51:57 <Saizan> conal: do you have an idea of what this functional form looks like yet?
21:52:11 <conal> Saizan: yes.  something like ML functors
21:52:13 <shubuntu> flipAll board stone (place:places) = flipAll (put (opponent stone) place board) stone places
21:52:18 <shubuntu> that's how it should be
21:52:24 <Saizan> conal: analysing the problem it starts to present complexities everywhere
21:52:29 <shubuntu> sorry about that
21:52:49 <xif> OK, I'm a Haskell newb, so please excuse me, but how exactly do I install Haddock?
21:52:53 <xif> http://www.haskell.org/haddock/
21:53:46 <Saizan> conal: ah, never used ML
21:53:58 <xif> do I need to install anything (Cabal?  Hackage?!) before I do?
21:54:02 <conal> Saizan: i don't know whether those complexities will turn out to be essential or avoidable.  as i said, the exploration i'm interested in is a research project.
21:54:05 <xif> it is a bit unclear on that page.
21:54:10 <shubuntu> ok now how do I map it this time?
21:54:14 <shubuntu> i don't know if i can map
21:54:16 <shubuntu> can I?
21:54:26 <orbitz> shubuntu: how does that do anything useful?
21:54:44 <shubuntu> i won't need a base case?
21:54:46 <orbitz> actually nm
21:55:16 <orbitz> your defintion is probably otpimal then
21:55:27 <shubuntu> http://hpaste.org/7721
21:55:32 <orbitz> shubuntu: you can use foldl
21:55:33 <shubuntu> that's a working version using recursion
21:56:14 <conal> Saizan: anyway, i want to get back to focusing on another project.  we can talk later if you're interested or think it might help.
21:56:35 <orbitz> flipAll board stone places = foldl (\acc e -> put (opponent stone) e acc) board places
21:56:45 <Saizan> conal: ok, thanks
21:57:02 <conal> Saizan: np.  take care.  :)
21:58:02 <shubuntu> i'll have a bit of problem here with the way to write it but i understand how foldl works
22:01:13 <shubuntu> flipAll board stone (place:places) = foldl (\place -> put (opponent stone) place board) board places
22:01:16 <shubuntu> is that it?
22:03:10 <shubuntu> http://hpaste.org/7722
22:03:16 <shubuntu> orbitz?
22:05:36 <shubuntu> i donno if i can use foldl
22:07:40 <glguy> foldl (\board place -> f board place) board0 places
22:07:56 <edwardk> is there anyway to override hackage when it thinks you're being a moron, when you really DO have to use some flags it doesn't like because it doesn't work? =)
22:08:27 <shubuntu> glguy that's not what i want though
22:08:51 <shubuntu> i don't have a list of boards
22:08:54 <shubuntu> there's one board
22:08:57 <glguy> right
22:08:57 <Saizan> edwardk: put it in the file with a OPTIONS pragma?
22:08:59 <glguy> that's what I wrote
22:09:03 <glguy> one board many places
22:09:45 <shubuntu> i don't see it
22:09:51 <shubuntu> explain how that works?
22:09:59 <edwardk> saizan: well, i can use the __GLASGOW_HASKELL__ > 609 crap but i went through all the trouble to make a compile flag ;)
22:11:08 <Saizan> edwardk: ah, i misunderstood the kind of flag
22:11:42 <edwardk> is there no way to pass a -D__Whatever__  option to haddock in cabal? passing it via ghc-options causes hackage to pitch a fit, passing it via cpp-options only works for the main compile., not haddock
22:11:48 <ivanm> where's lb gone to?
22:12:21 <edwardk> i'm just giving up now, since its been an hour and my wife has been patiently waiting to watch a movie with me this entire time ;)
22:12:23 <glguy> shubuntu: foldl (\ x y -> ... ) x0 ys   means
22:12:55 <glguy> (or to be more specific)
22:13:11 <glguy> foldl f x [1,2,3]
22:13:16 <edwardk> i just want to drop the thing on hackage before i quit for the night.
22:13:27 <glguy> foldl f (f x 1) [2,3]
22:13:45 <shubuntu> i know how foldl works
22:13:47 <glguy> now one piece has been played
22:13:49 <glguy> on the board
22:13:57 <glguy> and we recur with the new board
22:14:01 <glguy> and the next piece
22:14:02 <shubuntu> did you see my original flipAll?
22:14:26 <shubuntu> -- flipAll board stone (place:places) =
22:14:26 <shubuntu> --                     flipAll (put (opponent stone) place board) stone places
22:14:42 <shubuntu> board doesn't change
22:15:09 <glguy> board never changes
22:15:13 <glguy> you can only get a new board
22:15:35 <glguy> flipAll board stone places = foldl (\board place -> put (opponent stone) place board) board places
22:15:57 <glguy> and that will return the new board
22:16:04 <glguy> but won't change the original one
22:16:10 <shubuntu> ok
22:16:17 <shubuntu> well each time we iterate
22:16:28 <shubuntu> the new board will have that changed bit that put does right?
22:17:08 <glguy> yeah, the board in "(\board place->" will be the result of the previous placement
22:17:28 <shubuntu> ok let's try
22:19:24 <shubuntu> it compiled
22:19:30 <shubuntu> let's see if it works
22:27:46 <geezusfreeek> aw man stack overflow
22:30:23 <shubuntu> ok works
22:30:25 <shubuntu> thanks glguy
22:31:21 <glguy> you're welcome
22:31:38 <geezusfreeek> dangit, i hate that i can't use ghci to debug sdl programs on os x
22:32:04 <geezusfreeek> i guess i need to boot up vmware…
23:04:14 <pjdelport> nooo they be stealin my lambdabot
23:06:52 <Eelis> is it just me or has the ghc wiki ( http://hackage.haskell.org/trac/ghc/wiki/ ) been down for the last day or two?
23:16:39 <mbz> Eelis: it works
23:17:01 <mbz> i mean now
23:31:36 <Eelis> mbz: ok, then it's just me :) thanks
23:32:17 <mbz> Eelis: welcome =)
23:39:19 <qebab> anyone else doing the google treasure hunt thing? :)
23:39:46 <qebab> I probably doomed my chances by saying that in this room
23:40:27 <solrize_> haskell.org down?
23:49:23 <Eelis> solrize_: it is for me.
23:51:54 <solrize_> looks like it's up but verrry slow
