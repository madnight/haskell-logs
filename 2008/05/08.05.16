00:01:16 <jfredett> yay, yi works.
00:14:18 <maltem> jfredett: that cabal version is what is mentioned in the current state of the darcs repository and is probably intended to be the next version, but don't ask me where 1.4 or 1.5.0 went
00:22:45 <mxc> i wish they'd make yi for the wii for me
00:23:39 <mxc> not really, but I wanted to say that anyway
00:24:07 <qebab> does anyone know if Real World Haskell is available in a downloadable bundle of some sort? I want to read it, but I don't have stable access to the internet these days
00:29:01 <maltem> qebab, the only point of the open beta chapters is have people comment on the text, so I guess they wouldn't want to distribute a bundle (which would be soon out of date anyways)
00:29:49 <qebab> maltem: that's true of course, I was just wondering
00:30:09 <qebab> hard for me to comment on anything without being able to read it thought :p
00:30:46 <qebab> I generally only have internet when at work these days, and when I'm at work I'm supposed to be doing stuff
00:31:06 <dv\> hm. my ghc 6.8.2 doesn't have Control.Parallel
00:38:27 * kaol feels silly for writing reverse . tail . reverse
00:40:57 <dolio> What's the C++ analogue of sscanf?
00:41:11 <dolio> > init [1..10]
00:41:13 <lambdabot>  [1,2,3,4,5,6,7,8,9]
00:41:17 <maltem> @src init
00:41:17 <lambdabot> init [x]    = []
00:41:17 <lambdabot> init (x:xs) = x : init xs
00:41:17 <lambdabot> init []     = undefined
00:41:29 <Botje> you can set certain parameters on the stream you're reading from, iirc
00:41:59 <dolio> Well, I just want to read a size_t from argv.
00:42:33 <Botje> fast and easy way: dump it in a stringstream and read from that.
00:42:52 <kaol> optimally, I'd like to have hGetLine to chomp \r\n, not just \n
00:53:22 <maltem> > let initP p [x] = if p x then [] else [x]; initP p (x:xs) = x : initP p xs in initP (=='\r') "Line\r"
00:53:23 <lambdabot>  "Line"
00:54:35 <quicksilver> dv\: you probably didn't install the parallel package
01:02:49 <roconnor> @src nub
01:02:49 <lambdabot> nub = nubBy (==)
01:02:51 <roconnor> @src nubBy
01:02:52 <lambdabot> nubBy eq []             =  []
01:02:52 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
01:03:27 <roconnor> no fold?
01:06:53 <roconnor> @src concat
01:06:53 <lambdabot> concat = foldr (++) []
01:11:45 <roconnor> > let nub0 = foldr (\x y -> x : filter (x/=) y) [] in nub0 [1,2,3,2]
01:11:47 <lambdabot>  [1,2,3]
01:11:55 <roconnor> > let nub0 = foldr (\x y -> x : filter (x/=) y) [] in nub0 [1,2,3,2,1,1,2,1]
01:11:56 <lambdabot>  [1,2,3]
01:12:33 <roconnor> @check \x -> let nub0 = foldr (\x y -> x : filter (x/=) y) [] in nub0 x == nub x
01:12:34 <lambdabot>  OK, passed 500 tests.
01:14:04 <dmwit> ?check let nub' = foldr (\x y -> x : filter (x /=) y) [] in liftM2 (==) nub nub' -- look, it's that extensionality definition of function equality!
01:14:06 <lambdabot>  OK, passed 500 tests.
01:15:32 <roconnor> are there any foldr/foldr laws
01:15:37 <dmwit> ?free foldr
01:15:39 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
01:16:08 <roconnor> hm
01:16:17 <dmwit> It's a bit cryptic, eh?
01:17:11 <roconnor> I have the problem nub . concat === concat . x Solve for x.
01:17:28 <roconnor> I'd like to solve it algebraically
01:17:37 <roconnor> and then write up the solution in my blog
01:18:52 <Baughn> roconnor: Oh, that one's ugly. Is it a problem you really /want/ to solve?
01:19:27 <roconnor> Baughn: are you interested in the broader  context?
01:19:28 <quicksilver> is it really that bad?
01:19:33 <quicksilver> isn't it just a sublist aware nub?
01:19:58 <Baughn> Well, it's considerably uglier than nub.concat ;)
01:20:26 <Baughn> roconnor: Nominally yes, but not right now I think
01:20:58 <dmwit> ?free concat
01:21:00 <lambdabot> $map f . concat = concat . $map ($map f)
01:21:22 <dmwit> Well, that doesn't help much.
01:21:28 <dmwit> ?free [[a]] -> [a]
01:21:29 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
01:21:37 <roconnor> let's see in my case h = (++); k = (++), y= [] and g = num
01:21:47 <roconnor> we need nub [] = []
01:21:54 <roconnor> which we have, so that is good
01:22:30 <roconnor> so now just solve nub . (x++) = (f x++) . nub
01:22:46 <roconnor> which seems a bit unlikely
01:23:01 <roconnor> stupid free theorems
01:23:08 <roconnor> You get what you pay for
01:24:18 <roconnor> this solving programs algebraically is turning out to harder than just solving x directly
01:25:28 <Baughn> Well, yes. You're limiting yourself to a small part of what your brain is capable of, simply to make it easy to verify.
01:26:23 <roconnor> @src nubBy
01:26:23 <lambdabot> nubBy eq []             =  []
01:26:23 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
01:26:33 <roconnor> any reason for that definition rather than
01:26:54 <roconnor> nubBy eq (x:xs)         =  x : filter (\ y -> not (eq x y)) (nubBy eq xs)
01:27:03 <roconnor> ?
01:28:18 <Baughn> roconnor: Well, the laziness is easier to rason about if you don't interleave calls to nubBy and filter
01:28:25 <Baughn> *reason
01:28:40 <roconnor> right, my definition is a foldr
01:28:50 <roconnor> but their definition is crazy
01:33:46 <Cale> crazy?
01:33:59 <roconnor> not a fold
01:36:40 <sjanssen> roconnor: the first defn. is more efficient
01:36:53 <roconnor> why?
01:37:13 <sjanssen> roconnor: consider the amount of work done for (nub $ replicate n ()) for each
01:37:32 <sjanssen> the first is O(n), the second is O(n^2)
01:37:47 <roconnor> ah
01:40:19 <roconnor> let metaNum [] = []; metaNub []:ls = []:metaNub ls; metaNum (x:xs):ls = let (a:b) = metaNub (filter (x/=) xs: map (filter (x/=) ls)) in (x:a):b in metaNub [[1],[],[2,3],[2]]
01:40:24 <roconnor> > let metaNum [] = []; metaNub []:ls = []:metaNub ls; metaNum (x:xs):ls = let (a:b) = metaNub (filter (x/=) xs: map (filter (x/=) ls)) in (x:a):b in metaNub [[1],[],[2,3],[2]]
01:40:24 <lambdabot>  Parse error in pattern at ";" (column 51)
01:40:48 <roconnor> > let metaNum [] = []; metaNub ([]:ls) = []:metaNub ls; metaNum ((x:xs):ls) = let (a:b) = metaNub (filter (x/=) xs: map (filter (x/=) ls)) in (x:a):b in metaNub [[1],[],[2,3],[2]]
01:40:49 <lambdabot>      Conflicting definitions for `metaNum'
01:40:49 <lambdabot>     In the binding group for: meta...
01:41:11 <roconnor> > let metaNub [] = []; metaNub ([]:ls) = []:metaNub ls; metaNub ((x:xs):ls) = let (a:b) = metaNub (filter (x/=) xs: map (filter (x/=) ls)) in (x:a):b in metaNub [[1],[],[2,3],[2]]
01:41:12 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
01:41:12 <lambdabot>       Expected...
01:41:41 <roconnor> > let metaNub [] = []; metaNub ([]:ls) = []:metaNub ls; metaNub ((x:xs):ls) = let (a:b) = metaNub (filter (x/=) xs: map (filter (x/=)) ls) in (x:a):b in metaNub [[1],[],[2,3],[2]]
01:41:42 <lambdabot>  [[1],[],[2,3],[]]
01:44:14 <roconnor> > let f 1 = [2,3]; f 2 = [3]; f 3 = [1]; metaNub [] = []; metaNub ([]:ls) = []:metaNub ls; metaNub ((x:xs):ls) = let (a:b) = metaNub (filter (x/=) xs: map (filter (x/=)) ls) in (x:a):b; x = concat (takeWhile (not . null) (metaNub ([1]:(map f x))) in x
01:44:15 <lambdabot> Unbalanced parentheses
01:44:30 <roconnor> > let f 1 = [2,3]; f 2 = [3]; f 3 = [1]; metaNub [] = []; metaNub ([]:ls) = []:metaNub ls; metaNub ((x:xs):ls) = let (a:b) = metaNub (filter (x/=) xs: map (filter (x/=)) ls) in (x:a):b; x = concat (takeWhile (not . null) (metaNub ([1]:(map f x)))) in x
01:44:31 <lambdabot>  [1,2,3]
01:44:37 <roconnor> \o/
01:44:39 <roconnor> it works
01:46:26 <roconnor> from  x = [1]++(f =<< x)   to  x = concat (takeWhile (not . null) (metaNub ([1]:(map f x))))
01:46:50 <roconnor> > let f 1 = [2,3]; f 2 = [3]; f 3 = [1]; x = [1]++(f =<< x) in x
01:46:51 <lambdabot>  [1,2,3,3,1,1,2,3,2,3,3,1,3,1,1,2,3,1,2,3,2,3,3,1,2,3,3,1,3,1,1,2,3,3,1,1,2,3...
01:48:56 <roconnor> > let f 1 = [2,3]; f 2 = [3]; f 3 = [1]; x = [1]++concat (takeWhile (not . null) (map f x)) in x
01:48:58 <lambdabot>  [1,2,3,3,1,1,2,3,2,3,3,1,3,1,1,2,3,1,2,3,2,3,3,1,2,3,3,1,3,1,1,2,3,3,1,1,2,3...
01:49:09 <roconnor> > let f 1 = [2,3]; f 2 = [3]; f 3 = [1]; x = nub $ [1]++concat (takeWhile (not . null) (map f x)) in x
01:49:10 <lambdabot>  [1,2,3Exception: stack overflow
01:49:22 <roconnor> that's why I wanted metaNub
01:49:37 <roconnor> so I could push it to the otherside of the takeWhile
01:50:36 <roconnor> > let f 1 = [2,3]; f 2 = [3]; f 3 = [1]; x = nub $ concat (takeWhile (not . null) ([1]:(map f x))) in x
01:50:37 <lambdabot>  [1,2,3Exception: stack overflow
01:51:20 <MarcWeber> Is there some class providing catch for different nested monads?
01:51:42 <MarcWeber> Ah MonadError. :)
01:51:50 <Baughn> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
01:51:51 <lambdabot> http://tinyurl.com/2cvgfn
01:52:03 <Baughn> ..yeah.
02:18:28 --- mode: irc.freenode.net set +o ChanServ
02:18:41 <Botje> welcome back, chanserv!
02:18:46 <Botje> bye bye, chanserv!
02:19:59 --- mode: irc.freenode.net set +o ChanServ
02:20:11 <dmwit> There he is!
02:20:18 <dmwit> Just a big ol' bundle of joy, that ChanServ.
02:49:34 <mxc> @src filter
02:49:35 <lambdabot> filter _ []     = []
02:49:35 <lambdabot> filter p (x:xs)
02:49:35 <lambdabot>     | p x       = x : filter p xs
02:49:35 <lambdabot>     | otherwise = filter p xs
02:49:53 <mxc> @hoogle filter
02:49:53 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
02:49:53 <lambdabot> Data.List.filter :: (a -> Bool) -> [a] -> [a]
02:49:53 <lambdabot> Data.ByteString.filter :: (Word8 -> Bool) -> ByteString -> ByteString
02:57:54 <mxc> @src groupBy
02:57:54 <lambdabot> groupBy _  []       =  []
02:57:55 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
02:57:55 <lambdabot>     where (ys,zs) = span (eq x) xs
02:58:09 <mxc> @src span
02:58:10 <lambdabot> Source not found. stty: unknown mode: doofus
02:59:20 <EvilTerran> @src break
02:59:20 <lambdabot> break p =  span (not . p)
02:59:25 <EvilTerran> nyah
02:59:34 <EvilTerran> span p = break (not . p) -- :p
03:13:08 <wolverian> dons, so, are you implementing neelk's method (from reddit)? ;)
03:17:32 <wolverian> oh, I see you *are*, or at least writing about it. dons++
03:19:47 <opqdonut> wolverian: link?
03:22:58 <wolverian> opqdonut, http://reddit.com/r/programming/info/6jjhg/comments/c040ybt
03:26:20 <dolio> Some people associated with GHC (I think) back a while did a bunch of work on hylo fusion, but apparently it never went anywhere.
03:28:05 <dolio> At least, GHC still uses foldr/build fusion, which was around even before the buzz about hylo fusion, I think.
03:33:18 <shubuntu> hi does anyone know how to match an element on a list
03:33:25 <shubuntu> i know how to do it recursively
03:33:35 <shubuntu> but like does haskell have a construct of its own
03:33:49 <quicksilver> I'm not entirely sure what you mean.
03:33:52 <atsampso1> shubuntu: can you give an example of what you're trying to do?
03:34:00 <quicksilver> haskell has very few constructs of its own :)
03:34:08 <quicksilver> but there are some useful thins in the standard library.
03:34:09 <shubuntu> let's say we have a list of rows
03:34:14 <shubuntu> and we have an element x
03:34:27 <shubuntu> we want to see whether x exists in the list
03:34:34 <shubuntu> i'd go
03:34:36 <quicksilver> > 4 `elem` [1,2,3,4,6]
03:34:44 <shubuntu> ok
03:34:51 <lambdabot>  thread killed
03:34:53 <shubuntu> do you know how to use any
03:35:08 <quicksilver> > 4 `elem` [1,2,3,4,6]
03:35:09 <lambdabot>  True
03:35:18 <quicksilver> > any (<0) [1,2,3,4,5,6]
03:35:20 <lambdabot>  False
03:36:14 <shubuntu> can you use it as an equal as well?
03:36:28 <atsampson> > any (== 4) [1 .. 6]
03:36:29 <shubuntu> any (==5) [1,2,3,4,5]
03:36:30 <lambdabot>  True
03:36:43 <shubuntu> ok
03:36:50 <shubuntu> one last thing
03:36:57 <shubuntu> how do you reverse the result of that
03:37:04 <quicksilver> "any (==4)" is precisely the same as "4 `elem`"
03:37:19 <quicksilver> > not ( any (==4) [1..6] )
03:37:20 <lambdabot>  False
03:37:25 <atsampson> (== 4) is just a function; you can pass any function (of type t -> Bool) you like to any
03:37:26 <shubuntu> like i want a function to say not found
03:37:35 <shubuntu> i see
03:37:37 <shubuntu> cool
03:37:41 <quicksilver> > not ( 4 `elem` [1..6] )
03:37:42 <lambdabot>  False
03:37:44 <shubuntu> thanks a lot
03:38:01 <shubuntu> ok is there a way to make it easier
03:38:10 <Deewiant> > 4 `notElem` [1..6]
03:38:11 <lambdabot>  False
03:38:15 <shubuntu> like as soon as the element is found on a row it says found
03:38:27 <shubuntu> doesn't search anymore
03:38:42 <shubuntu> i know i can do that with cases
03:38:47 <shubuntu> but like is there an easier way
03:38:49 <quicksilver> that's what it does automatically.
03:39:00 <shubuntu> i'll have a search
03:39:07 <quicksilver> haskell things tend to short-circuit early because of lazy evaluation.
03:39:15 <quicksilver> so you don't need to do anything special.
03:39:20 <quicksilver> > 4 `elem` [1..]
03:39:22 <lambdabot>  True
03:39:23 <shubuntu> searchX type1 -> [type1] -> Bool
03:39:32 <quicksilver> that's an infinite list.
03:39:38 <quicksilver> so that proves it stops early :)
03:39:51 <shubuntu> yeah i understand that part
03:39:56 <shubuntu> that's no what i meant
03:40:02 <shubuntu> now if i have this one
03:40:15 <shubuntu> searchX type1 -> [[type1]] -> Bool
03:40:19 <shubuntu> that's a list of rows
03:40:22 <shubuntu> i could go
03:40:56 <quicksilver> :t any (any (==4))
03:40:58 <lambdabot> forall a. (Num a) => [[a]] -> Bool
03:41:03 <quicksilver> that works ;)
03:41:05 <shubuntu> searchX x (row:rows) = x 'elem' row || searchX x rows
03:41:31 <shubuntu> oh so i can say
03:42:03 <quicksilver> but your definition also looked good.
03:42:04 <shubuntu> searchX x lst = x 'elem' lst
03:42:13 <quicksilver> you're just writing any by hand.
03:42:18 <quicksilver> it's `elem`
03:42:21 <quicksilver> they're back-quotes.
03:42:32 <shubuntu> searchX x lst = any (==x) lst
03:42:33 <quicksilver> `elem` is just for one-level-deep lists.
03:42:39 <quicksilver> yup.
03:42:42 <shubuntu> neat
03:43:15 <shubuntu> thanks a lot
03:47:56 <shubuntu> ok i need some more help
03:48:03 <shubuntu> i'm writing a gameOver function
03:48:19 <shubuntu> it's taking Pawns
03:50:26 <shubuntu> Dark | Light | Vacant
03:50:26 <shubuntu> now how do i pass a test list to gameOver?
03:50:26 <shubuntu> gameOver Vacant [[Dark:Light:Dark]:[Dark,Dark:Dark]]
03:50:30 <shubuntu> is that it?
03:51:01 <shubuntu> gameOver [[Dark:Light:Dark]:[Dark,Dark:Dark]]
03:54:20 <quicksilver> lists are like this [1,2,3]
03:54:25 <quicksilver> or like this 1:2:3:[]
03:54:34 <quicksilver> not a mixture of the two :)
03:55:17 <shubuntu> well it's a list of lists
03:55:23 <shubuntu> so how do i write it
03:55:29 <quicksilver> [[1,2,3],[4,5,6]]
03:55:34 <shubuntu> oh ok
04:00:06 <shubuntu> ok the any part isn't working
04:01:10 <shubuntu> game.hs:58:39:
04:01:10 <shubuntu>     Couldn't match expected type `Pawn'
04:01:10 <shubuntu>            against inferred type `[Pawn]'
04:01:10 <shubuntu>       Expected type: [Pawn]
04:01:10 <shubuntu>       Inferred type: Board
04:01:11 <shubuntu>     In the second argument of `any', namely `board'
04:01:13 <shubuntu>     In the first argument of `not', namely `(any ((== Vacant)) board)'
04:01:15 <shubuntu> Failed, modules loaded: none.
04:02:18 <quicksilver> well board is a list of lists, not a list
04:02:21 <quicksilver> so you need
04:02:28 <quicksilver> any (any (== Vacant))
04:02:33 <quicksilver> as discussed earlier :)
04:03:02 <shubuntu> uhh two anys
04:03:12 <shubuntu> i love haskell's systematic work
04:03:15 <shubuntu> it's cute
04:04:36 <shubuntu> so it will be gameOver board = not ( any (any (== Vacant)) board))
04:06:20 <shubuntu> wooh it works
04:06:24 <shubuntu> thanks a lot
04:08:09 <Corun> Pop quiz! "Thy" is olde english for "your"... How does one say "I"? Particularly "I am fine" or "I'm OK"
04:09:30 <fatalerrorx> anyone know why Happs.org is still down?
04:10:39 <shubuntu> quicksilver another question
04:10:47 <shubuntu> how do you count the occurances
04:11:00 <shubuntu> is there a count function
04:11:16 <Feuerbach> shubuntu: there are filter and length functions
04:11:35 <quicksilver> Corun: "I" goes back a long way indeed; it goes back well into time when "thy" was current.
04:11:38 <shubuntu> well i don't want to recreate a list and then get the length of it
04:11:44 <shubuntu> should be an easier faster way?
04:11:51 <Corun> Ok, cheers quicksilver
04:11:57 <Corun> Someone else says it's "I", too
04:12:07 <quicksilver> Corun: you have to go back far indeed for older forms like "Ik"
04:12:50 <Feuerbach> shubuntu: you can also do using fold
04:12:54 <quicksilver> shubuntu: no, not really. it's the same thing.
04:13:16 <shubuntu> fold and scan are basically the same
04:13:19 <quicksilver> shubuntu: length . filter will not actually produce the intermediate list, with optimisations on.
04:13:30 <shubuntu> ok
04:13:42 <shubuntu> so how do you count Vacants
04:13:57 <fatalerrorx> can't believe nobody knows why Happs.org has been down for so long
04:14:16 <Koobs> Hi all.  I'm trying to build a DLL for use from C and I'm having a bit of trouble.  One of the modules I'm building into the DLL uses Parsec, but I don't know how to tell ghc to go find the Parsec object files.  Does anyone know how I might do that?
04:14:28 <shubuntu> countVacant board = length (filter (filter (==vacant)) board)
04:14:46 <shubuntu> countVacant board = length (filter (filter (== Vacant)) board)
04:15:21 <Arnar> > let count predicate list = foldl (\s x -> if (predicate x) then s+1 else s) 0 list in count (== 1) [1,3,4,5,2,1,3,4]
04:15:22 <lambdabot>  2
04:15:36 <Feuerbach> shubuntu: you might want to use composition (the dot)
04:15:54 <Arnar> @pl \s x -> if (predicate x) then s+1 else s
04:15:54 <lambdabot> flip =<< flip (if' . predicate) . (1 +)
04:16:06 <shubuntu> Feuerbach where?
04:16:36 <Feuerbach> countVacant board = (length.filter.filter (== Vacant)) board
04:16:42 <Feuerbach> less parens
04:16:47 <shubuntu> ahh
04:16:50 <quicksilver> :t length . filter . filter (==1)
04:16:52 <lambdabot>     Couldn't match expected type `a -> Bool'
04:16:52 <lambdabot>            against inferred type `[a1]'
04:16:52 <lambdabot>     Probable cause: `filter' is applied to too many arguments
04:16:58 <quicksilver> I don't think that's right :)
04:17:08 <Arnar> :t length . filter . filter
04:17:10 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[a]'
04:17:10 <lambdabot>       Expected type: (a -> Bool) -> [a] -> Bool
04:17:10 <lambdabot>       Inferred type: (a -> Bool) -> [a] -> [a]
04:17:20 <quicksilver> you're in danger of counting the number of rows which contain at least one vacant squae.
04:17:32 <Arnar> :t length . (filter (== 1)) . (filter (== 1))
04:17:32 <quicksilver> shubuntu: I would recommend using 'concat' to flatten the board, for this problem.
04:17:34 <lambdabot> forall a. (Num a) => [a] -> Int
04:17:35 <fatalerrorx> anyone tell me how i can see the execution of my code step by step in ghc in the consol?
04:17:43 <shubuntu> ok
04:17:51 <quicksilver> length . filter (==Vacant) . concat $ board
04:17:52 <shubuntu> it's becoming grusome
04:17:53 <shubuntu> lol
04:17:55 <Feuerbach> fatalerrorx: google for ghci debugger
04:18:15 <shubuntu> that looks neat
04:18:21 <Arnar> even neater:
04:18:29 <Arnar> countVacant = length . filter (== Vacant) . concat
04:19:12 <shubuntu> concat what
04:19:14 <shubuntu> lol
04:19:30 <Arnar> shubuntu: just define the function..
04:19:32 <quicksilver> here is a really cute appraoch:
04:19:52 <quicksilver> sum [ 1 | row <- board, Vacant <- row ]
04:20:25 <shubuntu> Arnar that definition is missing arguments
04:20:31 <quicksilver> shubuntu: no, it's not.
04:20:38 <shubuntu> quicksilver what you've put looks like a for loop
04:20:41 <quicksilver> shubuntu: he's deliberately defining a function.
04:20:42 <Feuerbach> shubuntu: yeah, it's pointless definition
04:20:46 <quicksilver> it does look a bit like a for loop.
04:20:50 <quicksilver> in a sense, it is a for loop.
04:20:54 <quicksilver> lists are haskell's for loops.
04:21:14 <shubuntu> ok so if i go by Arnar's approach
04:21:30 <Arnar> shubuntu: its just defining the function..
04:21:31 <shubuntu> i'd have to change the Function's definition too?
04:21:39 <Arnar> :t length . filter (== 1) . concat
04:21:41 <lambdabot> forall a. (Num a) => [[a]] -> Int
04:21:50 <Arnar> replace "Num" with your type
04:22:33 <shubuntu> i'm confused now
04:22:34 <shubuntu> lol
04:22:43 <Arnar> shubuntu: haskell allows you to define just functions like that.. no need to worry about the argument
04:22:50 <shubuntu> give me a complete code so i can read it properly
04:23:16 <Arnar> data YourType = Vacant | NotVacant
04:23:25 <Arnar> countVacant :: [[YourType]] -> Int
04:23:40 <Arnar> countVacant = length . filter (== Vacant) . concat
04:23:49 <shubuntu> wow
04:23:51 <shubuntu> without arguments
04:24:12 <Arnar> see the type of countVacant, [[YourType]] -> Int
04:24:17 <shubuntu> yes
04:24:25 <Arnar> read as "function that takes a list of lists of YourType and returns an Int"
04:24:29 <shubuntu> i didn't know that was possible
04:24:48 <shubuntu> i'm still thinking in C terms
04:24:48 <shubuntu> lol
04:24:50 <Arnar> beauty of functional programming :)
04:25:09 <mapreduce> > (\a b -> if (a<b) (+) (-)) 3 4
04:25:09 <lambdabot>  Parse error at ")" (column 26)
04:25:25 <mapreduce> > (\a b -> if (a<b) then (+) else (-)) 3 4
04:25:29 <lambdabot>  <Integer -> Integer -> Integer>
04:26:10 <shubuntu> ok now a twist
04:26:17 <shubuntu> if i want to count any pawn
04:26:31 <shubuntu> so the function will have to take two arguments
04:26:36 <Arnar> this is a chessboard?
04:26:40 <mapreduce> > (\a b -> (if (a<b) then (+) else (-)) a b) 3 4
04:26:40 <shubuntu> yep
04:26:41 <lambdabot>  7
04:26:46 <shubuntu> or any board
04:26:48 <mapreduce> > (\a b -> (if (a<b) then (+) else (-)) a b) 4 3
04:26:49 <dcoutts_> jfredett: Cabal-1.4 is not released yet, it's currently at 1.3.10, the development branch is at 1.5.x already
04:26:49 <lambdabot>  1
04:26:52 <shubuntu> i'm using it for othello as well
04:26:55 <Arnar> ok
04:27:08 <mapreduce> shubuntu: Can you understand what's going on in the last two lines I wrote?
04:27:13 <Arnar> so you want the function to take as argument the thing you're looking for?
04:27:15 <quicksilver> length . filter (`elem`[Dark,White]) . concat
04:27:43 <Arnar> countVacant needle = length . filter (== needle) . concat
04:27:44 <mapreduce> I think wrt point-free, some things make more sense intuiviely, like (+) and (-)
04:27:53 <Arnar> sorry.. better not call it "countVacant" then
04:28:42 <shubuntu> countPawn pawn = length . filter (== pawn) . concat
04:28:51 <shubuntu> like that?
04:29:00 <Arnar> what values could "pawn" take?
04:29:19 <shubuntu> countPawn :: Pawn -> [[Pawn]] -> Int
04:29:43 <shubuntu> Data Pawn = Dark | Light | Vacant Deriving (Eq, Show)
04:29:55 <Arnar> ah..
04:29:56 <Arnar> ok
04:30:10 <Arnar> then what quicksilver said above
04:30:15 <Arnar> or:
04:30:26 <Arnar> countPawn = length . filter (/= Vacant) . concat
04:30:50 <shubuntu> that doesn't give all white / black
04:30:59 <Arnar> you want seperate counts?
04:31:03 <shubuntu> yes
04:31:15 <Arnar> and in one function?
04:31:20 <shubuntu> yes
04:31:32 <shubuntu> if i do it like this it works
04:31:52 <Arnar> ok, so countPawn :: [[Pawn]] -> (Int,Int)
04:31:59 <shubuntu> count pawn board = length . filter (== pawn) . concat $ board
04:32:22 <Arnar> something like:
04:32:42 <Arnar> countGeneric s = length . filter (== s) . concat
04:32:45 <shubuntu> does mine work?
04:32:57 <Arnar> yes.. its the same
04:33:01 <Arnar> then you can define:
04:33:06 <Arnar> countVacant = countGeneric Vacant
04:33:12 <Arnar> countLight = countGeneric Light
04:33:19 <Arnar> countDark = countGeneric Dark
04:33:40 <shubuntu> so all in one
04:33:43 <Arnar> countPawns board = (countLight board, countDark board)
04:33:55 <shubuntu> i could write countPawn pawn = countGeneric pawn
04:34:10 <shubuntu> while countPawn being
04:34:28 <shubuntu> countPawn :: Pawn -> [[Pawn]] -> Int
04:34:47 <Arnar> that would be the signature for what I called countGeneric
04:35:14 <shubuntu> ok so no need for it
04:35:23 <shubuntu> i could just write it with one argument
04:35:36 <Arnar> yes..
04:35:41 <shubuntu> i don't want to do the tuples
04:35:51 <Arnar> shubuntu: never mind that.. I misunderstood
04:36:01 <shubuntu> i'd like to be able to count the winner's pawns alone for example
04:36:24 <luqui> shubuntu, so just take the first element of the tuple, and you only will compute that
04:36:40 <shubuntu> yeah but it's easier to just pass an Int
04:36:42 <Arnar> I think this is what you want: countPawn :: Pawn -> [[Pawn]] -> Int
04:36:48 <shubuntu> why waste computation
04:36:48 <don333> I'd like to do some sort of a reverse map, where I have a list of functions and a single argument
04:36:51 <don333> my Haskell skills are still weak, so could anyone help me with that?
04:36:52 <Arnar> countPawn s = length . filter (== s) . concat
04:36:56 <luqui> shubuntu, llaaaaazy
04:36:59 <shubuntu> yes Arnar
04:37:11 <shubuntu> yes that's exactly it
04:37:14 <shubuntu> should work
04:37:17 <Arnar> shubuntu: you won't waste computation.. Haskell only evaluates what you end up using
04:37:26 <chessguy> did someone say pawn?
04:37:31 <luqui> heheheh
04:37:33 * chessguy raises an eyebrow
04:37:34 <Vaelys> prawns imo
04:37:47 <shubuntu>  sum [ 1 | row <- board, Vacant <- row ]
04:38:05 <shubuntu> this is the for loop approach quicksilver suggested
04:38:17 <shubuntu> i think it's neat to have as a comment there
04:38:42 <shubuntu> I could just change the Vacant to pawn
04:38:45 <fatalerrorx> just wandering how do i install packages on windows that use cabal?
04:39:14 <dcoutts_> fatalerrorx: you use cabal to install them
04:39:46 <fatalerrorx> how to i get cabal to install them?
04:39:47 <shubuntu> so I could write countPawn pawn = sum [1 | row <- board, pawn <- row]
04:39:50 <shubuntu> correct?
04:39:56 <quicksilver> NO.
04:40:01 <quicksilver> oop,s didn't mean the caps.
04:40:02 <quicksilver> But No.
04:40:09 <quicksilver> the Vacant <- trick is special
04:40:15 * chessguy restrains quicksilver
04:40:16 <quicksilver> it relies on 'Vacant' being a constructor.
04:40:21 <quicksilver> you can't abstract it, which is a shame.
04:40:24 <dcoutts_> @where cabal
04:40:25 <lambdabot> http://www.haskell.org/cabal
04:40:25 <quicksilver> it's a neat trick though.
04:40:47 <dcoutts_> fatalerrorx: first link on the cabal homepage is "How to install a Cabal package."
04:41:16 <fatalerrorx> yeah but its all for linux
04:41:18 <shubuntu> yep
04:41:20 <shubuntu> pitty
04:41:31 <dcoutts_> fatalerrorx: it's all portable, just different paths
04:41:37 <chessguy> shubuntu: why not just keep track of the pieces themselves, and then just loop over them instead of the squares?
04:42:21 <quicksilver> chessguy: I was wondering that but shubuntu is just learning haskell and I think it's a bit harsh to get him to re-engineer his entire data model :)
04:42:34 <quicksilver> chessguy: after all, for learning purposes, working with nested lists is quite interesting.
04:42:41 <Arnar> how you model the board depends more on your algorithms ..
04:42:55 * chessguy shrugs
04:42:57 <chessguy> just a suggestion
04:43:03 <luqui> chess has an annoying property where both organizations kind of suck
04:43:11 <Arnar> shubuntu: sum [1 | row <- board, square <- row, square == pawn]
04:43:12 <shubuntu> that's because i use openGL to render graphics
04:43:17 <chessguy> luqui: both organizations?
04:43:20 <shubuntu> I only update rows if they're affected
04:43:25 <luqui> board-oriented or piece-oriented
04:43:28 <shubuntu> it's better graphics that way
04:43:38 <chessguy> luqui: ah
04:43:47 <chessguy> luqui: that's why you do both :)
04:43:50 * don333 finds some solution to his problem in the form of "map (\f -> f argument) functions", but feels like there's a cleaner way
04:43:50 <shubuntu> Arnar that's neat
04:43:52 <luqui> aye
04:43:55 <shubuntu> let me see if it works
04:44:06 <quicksilver> don333: map ($argument) functions
04:44:20 <chessguy> luqui: BiMap would be perfect for it, if it didn't have Ord restrictions on both member types
04:44:22 <quicksilver> don333: I missed your question, sorry :)
04:44:46 <luqui> chessguy, what is the unOrdered type you want to map to?
04:45:04 <chessguy> luqui: Piece
04:45:12 <chessguy> luqui: as in BiMap Square Piece
04:45:29 <luqui> that's pretty nice.  Ord is just artificial, but is well-defined
04:45:31 <chessguy> i mean, i guess you could order them
04:45:39 <Arnar> don333: I've looked for a cleaner way to..
04:45:40 <don333> quicksilver: no need to be sorry, that's a chat and not a paid support channel ;-)
04:45:51 <don333> and yes, that works, thanks
04:45:59 <chessguy> @src Ord
04:45:59 <lambdabot> class  (Eq a) => Ord a  where
04:45:59 <lambdabot>     compare      :: a -> a -> Ordering
04:45:59 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
04:45:59 <lambdabot>     max, min         :: a -> a -> a
04:46:33 <don333> I don't unfortunately know how - is the "$" prefix some special syntax?
04:46:43 <Arnar> don333: it is not a prefix.. its a function
04:46:43 <luqui> don333, it's a section
04:46:45 <pjd_> don333: another option is Control.Applicative: functions <*> pure argument
04:46:55 <Arnar> :t ($)
04:46:56 <chessguy>  @quote explode
04:46:56 <lambdabot> forall a b. (a -> b) -> a -> b
04:47:05 <luqui> don333, (+$$# b) means (\a -> a +$$# b) for any value of +$$#
04:47:13 <Arnar> :t ($ x)
04:47:14 <lambdabot> forall b. (Expr -> b) -> b
04:47:24 <shubuntu> Arnar it worked
04:47:26 <shubuntu> nice job
04:47:46 <Arnar> :)
04:47:55 <luqui> :t ($ ?x)
04:47:57 <lambdabot> forall a b. (?x::a) => (a -> b) -> b
04:48:13 <Arnar> luqui: ah..
04:48:19 <Arnar> what is Expr though?
04:48:29 <luqui> Arnar, a hack for doing things like
04:48:31 <luqui> > x + y
04:48:36 <lambdabot>  x + y
04:48:41 <Arnar> ok..
04:48:46 <luqui> > x^4
04:48:47 <lambdabot>  x * x * (x * x)
04:48:48 <Arnar> so its sth. lambdabot specific
04:48:48 <chessguy> > map f [1..5]
04:48:49 <lambdabot>  Add a type signature
04:48:54 <luqui> Arnar, aye
04:49:02 <chessguy> > map f [1..3] :: Expr
04:49:02 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[b]'
04:49:07 <don333> I feel ashamed, the very example luqui and Arnar mentioned is in the docs of ($)...
04:49:27 <chessguy> > map f [1..3] :: [Expr]
04:49:28 <lambdabot>  [f 1,f 2,f 3]
04:49:34 <chessguy> about time
04:49:54 * luqui too is guilty of asking when he could have checked the docs
04:50:07 * Arnar considers #haskell part of the docs
04:50:11 <luqui> I figure I'm doing the #haskell folks a favor, because if they're watching the channel, they are bored and need somebody to teach
04:50:11 <chessguy> @hoogle ($)
04:50:12 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
04:50:12 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
04:50:12 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
04:50:20 <fatalerrorx> i got problem
04:50:21 <fatalerrorx> HTTP-3001.0.4>setup configu
04:50:21 <fatalerrorx> re
04:50:21 <fatalerrorx> Configuring HTTP-3001.0.4...
04:50:21 <fatalerrorx> setup: Cabal was not bootstrapped correctly
04:50:33 <fatalerrorx> what does that mean?
04:50:36 <don333> "$ [...] sometimes allows parentheses to be omitted" - and I thought that was it's only purpose :-)
04:50:51 <Arnar> don333: heh.. so did I for a good while :)
04:51:21 <luqui> if you want to be weird, you could also say "map (flip id argument) functions"
04:51:58 <don333> I've actually been doing that before I got to the (\f -> f argument)
04:52:18 <luqui> I actually think that looks quite clear
04:52:27 <luqui> (not flip id, of course -- the lambda)
04:52:37 <matthew_-> grrrrrrrrr. why aren't type classes first class?
04:52:44 <matthew_-> this language sucks...
04:52:46 * matthew_- ducks
04:53:15 <luqui> matthew_-, now I say sir, haskell does not suck for reasons available here there and elsewhere! :-)
04:53:50 <matthew_-> it sucks for the same reason that all non-dependently typed languages suck :p
04:54:03 <shubuntu> matthew every language requires its own particular way of thinking
04:54:07 <luqui> ah.  but doesn't suck for the same reason that dependently typed languages do suck
04:54:12 <shubuntu> don't knock it if your mind set isn't right
04:54:14 <Cale> matthew_-: Have a good application for first class typeclasses?
04:54:14 <matthew_-> luqui: aindeed
04:54:24 <matthew_-> Cale: yep
04:54:36 <matthew_-> Cale: take a look at HFoldr from HList
04:54:42 <fatalerrorx> why does it have to be so hard to install some stupid packages on windows
04:54:59 <Zao> fatalerrorx: Because the package authors are silly and use unixisms.
04:55:06 <matthew_-> now tell me how I can have two instances of Apply in scope at the same time, one which does (+) and one which does (-)
04:55:20 <matthew_-> and apply them separately to the same hlist
04:55:21 <luqui> it is the bane of geek languages' existence it is, fatalerrorx
04:55:22 <mepsipax> why does GHC take 410 MB?
04:55:27 <mepsipax> isn't that a bit large?
04:55:30 <matthew_-> nah
04:55:33 <luqui> not these days
04:55:37 <matthew_-> it's less than java
04:55:43 <luqui> less ram than java!
04:55:53 <matthew_-> @quote stereo
04:55:53 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
04:56:04 <matthew_-> ssl randomness bug his Î»b
04:56:10 <matthew_-> grr, "hits"
04:56:13 <luqui> matthew_-, no no, I was _expanding_ on your comment
04:56:18 <matthew_-> ahh! sorry.
04:56:19 <Zao> mepsipax: Lots of bundled libraries.
04:56:48 <matthew_-> Cale: do you see the problem?
04:56:49 <fatalerrorx> why did they even bother creating a windows version sigh
04:56:58 <Cale> matthew_-: You have two separate selector datatypes.
04:57:00 <matthew_-> the behaviour is different but the types are the same.
04:57:13 <Cale> HApply is designed to take a dummy type parameter to select the instance.
04:57:38 <matthew_-> AHH! With you.
04:57:47 <matthew_-> that's a fugly hack, but it sure works.
04:57:54 <shubuntu> GHC takes 410 MB?
04:57:55 <shubuntu> where
04:58:03 <matthew_-> and basically gets what I want - a handle to an instance
04:58:07 <shubuntu> it only takes 80 MB i think
04:58:08 <shubuntu> lol
04:58:12 <mepsipax> nope
04:58:13 <mepsipax> 410
04:58:13 <rabbit64> Hi. How would you unify this two type expressions: [a->Bool->b->a, (Bool->c)->d->a], a..z are type variables; they say it isn't unifiable but I think it is.
04:58:17 <Cale> Yeah.
04:58:31 <shubuntu> It didn't take that long to download on my Ubuntu
04:58:43 <shubuntu> i don't think it was anything near 410 MB
04:58:47 <mepsipax> it's 35MB
04:58:51 <mepsipax> but expands to 410
04:58:53 <matthew_-> rabbit64 : a -> Bool -> b -> a === (a -> (Bool -> (b -> a)))
04:58:57 <shubuntu> oh ok
04:59:23 <matthew_-> so a would have to be (Bool -> c)
04:59:33 <Cale> are those the same a?
04:59:41 <matthew_-> and then you don't have enough params left, I think
05:00:01 <rabbit64> matthew_-, my result is (Bool->c) -> Bool -> b  - > Bool -> c no?
05:00:06 <Cale> If they are, then you'll have a = b -> a, which fails the occurs check
05:00:45 <matthew_-> yeah, or you've tried to make d into (Bool -> b) which is not right
05:01:41 <rabbit64> matthew_-, ah yeah, thanks
05:05:15 <fatalerrorx> anyone see the problem with this?
05:05:16 <fatalerrorx> http://hpaste.org/7643
05:05:56 <fatalerrorx> this is the error i get
05:05:57 <fatalerrorx> http://hpaste.org/7644
05:06:06 <Arnar> @hoogle (a,a) -> (a -> b) -> (b,b)
05:06:06 <lambdabot> No matches, try a more general search
05:06:14 <shubuntu>  i need help with my showBoard to make it optimized
05:06:14 <shubuntu>  showboard :: Board -> String
05:06:14 <shubuntu>  then i'll pass that string to my openGL draw to draw
05:06:14 <shubuntu>  so let's say I'm doing something simple
05:06:14 <shubuntu>  0 1 2 3 4 5 6 7
05:06:15 <shubuntu> 0 . . . . . . .
05:06:17 <shubuntu> 1 . . . . . . .
05:06:18 <Arnar> ^^ anything like this somewhere?
05:06:19 <shubuntu> 2 . . . . . . .
05:06:21 <shubuntu> 3 . . . . . . .
05:06:23 <shubuntu> 4 . . . . . . .
05:06:23 <Botje> fatalerrorx: rename the file to .hs
05:06:25 <shubuntu> 5 . . . . . . .
05:06:27 <shubuntu> 6 . . . . . . .
05:06:29 <shubuntu> 7 . . . . . . .
05:06:30 <matthew_-> shubuntu STOP
05:06:32 <Zao> shubuntu: Thank you for spamming.
05:06:40 <shubuntu> i didn't spam
05:06:44 <Arnar> shubuntu: http://hpaste.org
05:06:45 <matthew_-> use hpaste. Do not flood #haskell
05:06:45 <shubuntu> i asked a question
05:06:50 <Zao> shubuntu: So those eight lines of junk is?
05:06:52 <fatalerrorx> Botje: thanks
05:07:04 <shubuntu> it's a question
05:07:05 <Arnar> shubuntu: use hpaste if your question is more than three lines or so
05:07:12 <Cale> shubuntu: Don't paste large amounts of text into an IRC channel. Paste it on a pastebin, and refer to it.
05:07:15 <shubuntu> i want to be able to produce a board in string
05:07:22 <Zao> shubuntu: It's common courtesy to not paste stuff in-channel.
05:07:28 <shubuntu> oh ok
05:07:37 <shubuntu> sorry
05:07:46 <shubuntu> didn't mean to annoy anyone
05:07:50 <Arnar> no worries.. everyone gets one chance :)
05:08:11 <matthew_-> np. ok so produce the board in a useful data type and then have a good show instance to stringify it
05:08:13 <Zao> shubuntu: Had it been ##C, you'd be gone by now :)
05:08:27 <fatalerrorx> whats ##C?
05:08:30 <Arnar> sorry for repeating.. but I think my thing got lost.. is there anything std. for (a,a) -> (a -> b) -> (b,b).. like map for tuples ?
05:08:39 <chessguy> most likely lying in the gutter along a road somewhere, too :)
05:08:54 <Zao> fatalerrorx: The channel for C zealots.
05:09:00 <Cale> shubuntu: I'd probably start by using unlines along with a list of the lines of text for the board.
05:09:02 <matthew_-> Arnar: not that I know of. Tuples generally suck for higher order apis
05:09:17 <shubuntu> ok
05:09:22 <Zao> Arnar: Combine unzip, map and zip?
05:09:24 <luqui> Arnar, Control.Arrow has some nice stuff
05:09:29 <chessguy> @pl \f (x,y) -> (f x, f y)
05:09:30 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
05:09:31 <Cale> shubuntu: That would start with the initial index line, and be followed by a list of the remaining lines.
05:09:35 <ari> > join (***) (+1) (2, 3)
05:09:35 <shubuntu> so Cale I need to ++ several lines with \n?
05:09:36 <lambdabot>  (3,4)
05:09:37 <chessguy> well, gee, there ya go
05:09:47 <Arnar> chessguy: sheesh :)
05:09:52 <chessguy> Arnar, lol
05:10:08 <chessguy> @type unlines
05:10:10 <lambdabot> [String] -> String
05:10:11 <Arnar> Zao: you have an example up your sleeve?
05:10:13 <Cale> So it would look like:  unlines (x:xs), where x is "  0 1 2 3 4 5 6 7" or some such
05:10:30 <Arnar> :t unzip
05:10:32 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
05:10:36 <Cale> and xs is a list of the lines making up the rest of the board (perhaps produced by a list comprehension)
05:11:18 <Cale> unlines ["abc","def","ghi"]
05:11:20 <Cale> > unlines ["abc","def","ghi"]
05:11:21 <lambdabot>  "abc\ndef\nghi\n"
05:11:28 <chessguy> Arnar, i think ari's example is your best bet
05:11:44 <chessguy> @type join (***)
05:11:47 <lambdabot> Not in scope: `***'
05:11:47 <Arnar> chessguy: ah.. I missed that one
05:11:50 <Arnar> ari: thx
05:12:06 * luqui dislikes join for some reason
05:12:12 <luqui> or rather join on ((->) r)
05:12:18 <chessguy> @type join (Arrow.(***))
05:12:20 <lambdabot> Not in scope: data constructor `Arrow'
05:12:20 <lambdabot> Not in scope: `***'
05:12:24 * chessguy sighs
05:12:32 <chessguy> one more try
05:12:38 <chessguy> @type join (Control.Arrow.(***))
05:12:40 <lambdabot> Couldn't find qualified module.
05:12:45 <chessguy> ok, i give up
05:12:46 <Arnar> hee hee
05:12:56 <matthew_-> @slap lambdabot
05:12:56 <lambdabot> *SMACK*, *SLAM*, take that lambdabot!
05:13:23 <luqui> @type join (Control.Arrow.***)
05:13:25 <lambdabot> forall (a :: * -> * -> *) b c. (Control.Arrow.Arrow a) => a b c -> a (b, b) (c, c)
05:13:29 <luqui> biyatch!
05:13:37 <fatalerrorx> error http://hpaste.org/7645 code http://hpaste.org/7646 can anyone take a quick look?
05:13:37 <mxc> :t return (Data.List)
05:13:39 <lambdabot> Couldn't find qualified module.
05:13:58 <mxc> @type return (Data.List)
05:14:00 <lambdabot> Couldn't find qualified module.
05:14:02 <luqui> mxc, ..... .... .. what?
05:14:24 <mxc> oh, oops
05:14:29 <mxc> @src return (Data.List)
05:14:29 <lambdabot> Source not found. That's something I cannot allow to happen.
05:14:32 <matthew_-> ahh, the long awaited modules are first class extension
05:14:39 <mxc> trying to find the source for an overloaded operator
05:14:44 <luqui> @src [] return
05:14:45 <lambdabot> return x    = [x]
05:14:45 <mercury^> :t Data.List.return
05:14:47 <lambdabot> Not in scope: `Data.List.return'
05:14:51 <mxc> forget how to ask lambdabot
05:15:01 <mxc> @src Maybe return
05:15:01 <lambdabot> return              = Just
05:15:04 <mxc> ah
05:15:57 <chessguy> @src [] (>>=)
05:15:58 <lambdabot> xs >>= f     = concatMap f xs
05:15:59 <shubuntu> Arnar
05:16:02 <shubuntu> http://hpaste.org/7647
05:16:05 <shubuntu> that's it
05:16:16 <shubuntu> can you tell me an optimized way to do it
05:16:41 <chessguy> shubuntu, i thought you were doing a graphical board
05:16:48 <shubuntu> I am
05:16:51 * luqui is having trouble coming up with an unoptimized way
05:16:57 <luqui> seems pretty streamy to me
05:16:58 <shubuntu> I'm using a text one first
05:17:15 <shubuntu> when the code is finished I'll just either convert the string to the graphical
05:17:26 <shubuntu> or just comment this and use a graphical one
05:17:42 <luqui> or typeclass it!
05:17:51 <chessguy> er...parsing the string would seem a little silly to me
05:18:11 <chessguy> or rather RE-parsing, i should say
05:18:14 <shubuntu> instead of a string you could use Cells
05:18:19 <luqui> first task is to do a single line, shubuntu
05:18:35 <shubuntu> well I know how to do it the long way
05:18:48 <shubuntu> i need the optimized way
05:18:54 <luqui> shubuntu, oh you're looking for a code-size optimized, not a speed-optimized?
05:19:04 <shubuntu> both
05:19:11 <shubuntu> something smart
05:19:12 <shubuntu> lol
05:19:38 <chessguy> you shouldn't be worrying about optimizing IO
05:19:40 <shubuntu> the problem is i'm still learning haskell. if it were C i'd have no problem
05:20:06 <chessguy> shubuntu, are you writting a chess engine, too, or just the interface?
05:20:14 <Arnar> shubuntu: paste the "long way".. :)
05:20:17 <shubuntu> a whole engine
05:20:21 <shubuntu> for all board games
05:20:25 <tromp> my connect-4 solver has a showboard function in haskell
05:20:36 <luqui> showPiece :: Piece -> Char;  unlines . map (intercalate ' ' . map showPiece line)
05:20:38 <luqui> something like that?
05:20:56 <luqui> er, lose the line in the abov
05:20:57 <luqui> e
05:21:02 <tromp> showbb white black = header++'\n':unlines (map showrow [height-1,height-2..0])++wininfo where header    = ' ':unwords (map show [1..width]) showrow h = ' ':intersperse ' ' (map cell [h,h+height'..bsize-1])
05:21:12 <chessguy> @type unlines . map (intercalate ' ' . map ?showPiece)
05:21:16 <tromp> based on bitboards
05:21:25 <matthew_-> or just use cairo and/or gtk ...
05:21:28 <lambdabot> thread killed
05:21:32 <chessguy> tromp, you have a haskell bitboard implementation?
05:21:36 <tromp> (i left out def. of cell and wininfo)
05:21:45 <tromp> yes
05:21:55 <Arnar> a thought.. since String is [Char] -- can one use a do-block somehow to concatenate a bunch of strings?
05:21:55 <chessguy> what kind of bitboards?
05:22:01 <luqui> @type unlines . map (intercalate ' ' . map ?showPiece)
05:22:03 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Char'
05:22:03 <lambdabot>     In the first argument of `intercalate', namely ' '
05:22:03 <lambdabot>     In the first argument of `(.)', namely `intercalate ' ''
05:22:09 <luqui> :t intercalate
05:22:10 <lambdabot> forall a. [a] -> [[a]] -> [a]
05:22:32 <tromp> one Word64 for each of black and white
05:22:34 <luqui> ah
05:22:38 <Arnar> intercalate " "
05:22:41 <Arnar> not ' '
05:22:44 <luqui> @type unlines . map (intercalate " " . map ?showPiece)
05:22:46 <lambdabot> forall a. (?showPiece::a -> [Char]) => [[a]] -> String
05:23:11 <chessguy> tromp, oh, not the classical bitboards approach?
05:23:23 <chessguy> one for each piece type?
05:23:29 <tromp> it's for connect4
05:23:37 <chessguy> oh!
05:23:38 <tromp> only one piece type:)
05:23:49 <chessguy> i thought you meant for chess
05:24:00 <tromp> nah
05:24:01 <luqui> > do { x <- "hello"; y <- "world"; [x,y] }
05:24:02 <lambdabot>  "hwhohrhlhdeweoereledlwlolrllldlwlolrllldowooorolod"
05:24:10 <chessguy> there's been a lot of cool work done on bitboard implementations for chess
05:24:13 <luqui> Arnar:  answer: no not really
05:24:28 <luqui> but you can get some fun sounding gibberish
05:24:36 <Arnar> :)
05:24:54 <Arnar> > do { "hello"; "world" }
05:24:55 <lambdabot>  "worldworldworldworldworld"
05:25:02 <Arnar> huh?
05:25:05 <chessguy> haha
05:25:09 <chessguy> welcome to the list monad :)
05:25:14 <Arnar> :t [] >>=
05:25:16 <lambdabot> parse error (possibly incorrect indentation)
05:25:18 <Arnar> no..
05:25:19 <luqui> list monad cycles through all permutations
05:25:20 <Arnar> @src [] >>=
05:25:20 <lambdabot> Source not found.
05:25:29 <Arnar> @src [] (>>=)
05:25:29 <lambdabot> xs >>= f     = concatMap f xs
05:25:36 <Arnar> @src concatMap
05:25:36 <lambdabot> concatMap f = foldr ((++) . f) []
05:25:37 <luqui> so it gave all permutations of "hello", which was just 5 things, and ignored the actual things.
05:25:48 <chessguy> > [1..5] >>= [1,2]
05:25:50 <lambdabot>  Couldn't match expected type `t -> [b]' against inferred type `[a]'
05:26:02 <luqui> > [1..5] >> [1,2]
05:26:02 <Arnar> > [1..5] >> [1,2]
05:26:03 <lambdabot>  [1,2,1,2,1,2,1,2,1,2]
05:26:04 <lambdabot>  [1,2,1,2,1,2,1,2,1,2]
05:26:06 <saml> class (Monad m) => MonadSourcePos m where getSourcePos :: m SourcePos   can I create such monad in general?
05:26:11 <chessguy> oh, right, dugh
05:26:13 <Saizan> luqui: permutations?
05:26:20 <luqui> and through and through and through and through, the vorpal sword went snicker snack
05:26:22 <saml> so that I can add it to my custom monad stack
05:26:48 <Arnar> lesson reiterated: don't start with [] when teaching someone about monads!
05:26:49 <Arnar> :)
05:26:59 * chessguy watches luqui go galumphing back
05:27:00 <luqui> do { x <- [1,2,3]; y <- [4,5,6]; return (x,y) }
05:27:04 <saml> data Expr = Int Integer | .... | At SourcePos Expr   I can do this and make typechecker and evaluator look at data constructed with At constructor.. but it gets messy
05:27:11 <luqui> > do { x <- [1,2,3]; y <- [4,5,6]; return (x,y) }
05:27:12 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
05:27:22 <Arnar> luqui: ah..
05:27:23 <Saizan> luqui: there are 5! permutations of "hello", while you get only 5 copies of "world"
05:27:27 <saml> it's all to print out line numbers in case of error
05:27:28 <luqui> ah
05:27:35 <luqui> permutations was not the right word
05:27:38 <Arnar> > [(x,y] | x <- [1,2,3], y<-[4,5,6]]
05:27:38 <lambdabot> Unbalanced parentheses
05:27:46 <luqui> it's an outer product
05:27:47 <Arnar> whatever
05:27:48 <pjdelport> @undo do { "hello"; "world" } as for
05:27:48 <lambdabot>  Parse error at "as" (column 25)
05:27:53 <pjdelport> err
05:27:54 <pjdelport> @undo do { "hello"; "world" }
05:27:54 <lambdabot> "hello" >> "world"
05:28:09 <Botje> > liftM2 (,) [1,2,3] [4,5,6]
05:28:09 <Arnar> > do { return "hello" ; return "world" }
05:28:10 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
05:28:10 <lambdabot>   add an instance declaration for (Show (t [Char]))
05:28:16 <luqui> and the list monad was actually _the one_ that made it all come together when I was learning about them
05:28:20 <Saizan> > concatMap (\_ -> "world") "hello"
05:28:22 <lambdabot>  "worldworldworldworldworld"
05:28:23 <pjdelport> there should be a @comp
05:28:27 <pjdelport> and @uncomp
05:28:44 <matthew_-> does that Expr stuff work for do notation?
05:28:52 <luqui> hmm
05:29:00 <luqui> > do { foo <- x; return foo }
05:29:01 <lambdabot>  Couldn't match expected type `t t1' against inferred type `Expr'
05:29:03 <idnar> > do { x; y; }
05:29:04 <lambdabot>  Couldn't match expected type `t1 t' against inferred type `Expr'
05:29:07 <idnar> heh
05:29:11 <matthew_-> > (liftM2 (,) [1,2,3] [4,5,6]) :: [Expr]
05:29:11 <lambdabot>  Couldn't match expected type `Expr'
05:29:18 <Arnar> :t x
05:29:20 <lambdabot> Expr
05:29:28 <luqui> > liftM2 (,) [a,b,c] [x,y,z]
05:29:29 <lambdabot>  [(a,x),(a,y),(a,z),(b,x),(b,y),(b,z),(c,x),(c,y),(c,z)]
05:29:38 <Arnar> ^^ so lambdabot has definitions for a bunch of single-letter names as Expr?
05:29:42 <matthew_-> > (liftM2 (,) [1,2,3] [4,5,6]) :: [(Expr, Expr)]
05:29:43 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
05:29:45 <luqui> yep
05:29:47 <pjdelport> > do { [x]; [y] }
05:29:48 <lambdabot>  [y]
05:29:54 <Arnar> durr..
05:30:10 <pjdelport> > do { [x,y]; [z] }
05:30:11 <lambdabot>  [z,z]
05:30:26 <luqui> do { repeat 1; [z] }   -- bedtime
05:30:39 <shubuntu> http://hpaste.org/7648
05:30:41 <shubuntu> Arnar
05:30:48 <Syzygy-> > do repeat 1; return z
05:30:48 <Arnar> inside an IO ()  typed do-block.. I have a Int variable x.. how do I read x lines from a handle into a list?
05:30:48 <shubuntu> that's what I've done so far
05:30:49 <lambdabot>  [z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z...
05:30:52 <Botje> "shubuntu"?
05:30:56 <Botje> linux for shoes? :)
05:31:01 <Syzygy-> > concat $ do repeat 1; return z
05:31:02 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Expr'
05:31:09 <Syzygy-> Tsk.
05:31:39 <shubuntu> I need to add spaces in between the items
05:31:54 <Botje> shubuntu: the function is called "show", btw
05:31:56 <shubuntu> map " " row?
05:32:05 <shubuntu> oh ok
05:32:09 <Botje> shubuntu: unwords (map show row)
05:32:20 <Botje> > unwords (map show [1..5])
05:32:21 <lambdabot>  "1 2 3 4 5"
05:32:33 <Arnar> :t repeat
05:32:33 <shubuntu> i need to add spaces
05:32:35 <lambdabot> forall a. a -> [a]
05:32:40 <Botje> that's what unwords does
05:32:41 <Arnar> :t replicate
05:32:43 <lambdabot> forall a. Int -> a -> [a]
05:33:06 <shubuntu> ok so both code optimization and adding space
05:33:13 <Arnar> :t replicate 10 (hGetLine hdl)
05:33:15 <lambdabot> Not in scope: `hGetLine'
05:33:15 <lambdabot> Not in scope: `hdl'
05:33:23 <Arnar> :t replicate 10 (getLine)
05:33:24 <Botje> don't utter the O-word before your code works :)
05:33:25 <lambdabot> [IO String]
05:33:40 <Arnar> @hoogle [m a] -> m [a]
05:33:41 <lambdabot> Prelude.head :: [a] -> a
05:33:41 <lambdabot> Prelude.last :: [a] -> a
05:33:41 <lambdabot> Data.List.head :: [a] -> a
05:33:48 <Botje> Arnar: sequence . replicate or just use replicateM
05:33:55 <Arnar> Botje: ah, thanks
05:36:57 <mepsipax> why does round 6.5 give 6?
05:37:06 <mepsipax> it should give 7.
05:38:27 <chessguy> @src round
05:38:27 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
05:38:32 <chessguy> @hoogle round
05:38:32 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
05:38:58 <Botje> > map round [ 6.4, 6.5, 6.55, 6.6 ]
05:38:59 <lambdabot>  [6,6,7,7]
05:39:32 <Botje> 6.51 also rounds towars 7
05:39:48 <Botje> i think you're only supposed to round up at .55
05:40:01 <is_me> anyone can help to solve my issue >> http://hpaste.org/7650
05:40:14 <mepsipax> huh? I think when you reach half way you round up
05:40:37 <mepsipax> type javascript:alert(Math.round(6.5)) in your browser
05:40:40 <Botje> mepsipax: http://en.wikipedia.org/wiki/Rounding
05:40:40 <schme_> dmwit: that house looks very interesting!
05:40:43 <mepsipax> you'll get 7
05:40:50 <luqui> > (0.54,1 - 0.54)  -- let's play the "which number is bigger" game
05:40:51 <lambdabot>  (0.54,0.45999999999999996)
05:40:52 <Botje> look at the "round-to-even" method
05:41:02 <lelf> > map round [0.5, 1.5, 2.5, 3.5, 4.5] -- ;-)
05:41:04 <lambdabot>  [0,2,2,4,4]
05:41:08 <is_me> i would like to remove the character of "d" when the last character of my input word do contain 'd'
05:41:08 <Botje> is_me: what's wrong with it?
05:41:25 <is_me> e.g. ["word"]
05:41:38 <is_me> is only work if i give two word
05:41:53 <is_me> e.g. ["word", "mild"]
05:42:09 <luqui> > last "word"
05:42:11 <lambdabot>  'd'
05:42:13 <ketil> > filter (/='d') "word"
05:42:15 <Botje> is_me: that's because you included a clause forremove[a] = [a]
05:42:15 <lambdabot>  "wor"
05:42:22 <Botje> which applies if you only give one word
05:42:31 <Botje> if you remove that it should work fine, i think.
05:42:39 <is_me> let me try.
05:42:44 <Botje> also, take(length c1-1)c1 is better written as init c1
05:42:51 <Botje> and you don't need as much parens
05:43:02 <Botje> and a bit of whitespace between remove and its arguments won't hurt :)
05:43:41 <luqui> and making a custom monad would be elegant
05:43:44 <luqui> (no I'm just kidding)
05:45:21 <is_me> Botje: yo.. yes.. thanks so much..
05:45:25 <is_me> is works..
05:45:53 <Botje> no problem
05:45:54 <Botje> have fun! :)
05:46:11 <is_me> emm.. wat is init mean acctually?
05:46:25 <Botje> it removes the last element from a list
05:46:25 <luqui> "initial"
05:46:30 <Botje> > init [1..5]
05:46:31 <lambdabot>  [1,2,3,4]
05:46:45 <Botje> it does the same as take(length c1-1)c1, but looks nicer :)
05:46:54 <is_me> cool!!
05:47:03 <luqui> it's actually a little better, if you want to be picky
05:47:16 <Botje> i know
05:47:25 <luqui> > take (length [1..] - 1) [1..]
05:47:28 <lambdabot> Terminated
05:47:38 <schme_> So what is the neat haskall function we use to draw vector images and dump 'em as a png or what not?
05:47:53 <luqui> cairo bindings?
05:47:59 <schme_> I was browsing that there ghc doc site thingie and couldn't find anything good.
05:48:08 <schme_> luqui: I have no idea. I'm asking :)
05:48:43 <Arnar> are there any predefined compositions of head and tail in Haskell.. like cadr, cddr, caddr lin Scheme?
05:48:56 <Botje> nope
05:48:57 <Arnar> or people just use !!
05:48:59 <schme_> luqui: What is cairo?
05:49:06 <Botje> people generally use pattern matching or !!
05:49:08 <Botje> whichever is nicest
05:49:12 <Arnar> ok.. cheers
05:49:35 <luqui> http://haskell.org/gtk2hs/docs/current/Graphics-Rendering-Cairo.html
05:49:36 <lambdabot> http://tinyurl.com/tkkq9
05:50:53 * luqui simply does not write algorithms that need anything other than the head of a list :-)
05:51:08 <luqui> (and recurse on tail of course)
05:51:40 <Arnar> http://hpaste.org/7651  <- Could someone have a look, I'm a little confused about typeclasses here..
05:52:09 <Arnar> wtf.. hpaste cut off the last half :/
05:52:27 <shubuntu> ok so I've modified it like this
05:52:35 <shubuntu> now please help me optimize it
05:52:35 <shubuntu> http://hpaste.org/7652
05:52:43 <skorpan> if i have a FilePath e.g. "/something/lol.x" and i want to replace the "x" with "y", how do i do that?
05:53:04 <skorpan> i.e. change the file extension to something else.
05:53:11 <luqui> ow, that is mucho codigo
05:53:39 <Arnar> is there a size limit on hpaste?
05:53:58 <skorpan> Notice: hpaste is for small pastes and truncates after 5K
05:54:24 <Arnar> skorpan: ok.. didn't know
05:54:26 <twanvl> skorpan: I would expect System.FilePath.replaceExtension to do what you want
05:54:32 <Boney> happs.org seems to be down.
05:54:35 <Arnar> skorpan: nor notice :/
05:54:38 <luqui> skorpan, there are many errors in the latter half of that code
05:54:38 <ketil> are there strict versions of maps and sets around?
05:54:46 <luqui> er
05:54:49 <luqui> not skorpan
05:54:50 <luqui> shubuntu,
05:54:57 <Arnar> so, here goes -> http://hpaste.org/7654
05:55:06 <skorpan> twanvl: can't find it on hoogle?
05:55:13 <skorpan> no wait there it is
05:55:14 <skorpan> thanks
05:55:41 <luqui> shubuntu, which line is it talking about?
05:55:59 <ketil> And: I get a discrepancy between profiling time (ticks), and actual time (measured by 'time'), it's a factor of about 6.  Is there any good explanation?
05:56:01 <luqui> grr
05:56:01 <trez> skorpan: I used replaceExtension :)
05:56:07 <luqui> I'm getting everyone all mixed up
05:56:12 <luqui> Arnar, which line is it talking about
05:56:28 <luqui> shubuntu, it is more important for your code to actually work than for it to be elegant
05:56:35 <shubuntu> http://hpaste.org/7655#a0
05:56:37 <Arnar> luqui: the last one.. in the definiton of readSheetFile
05:56:38 <shubuntu> that works
05:56:41 <shubuntu> i fixed it
05:56:44 <luqui> (though you will find the largest cardinality of disagreeers in this channel I think)
05:56:48 <Arnar> luqui: readSheetFile :: Sheet s => String -> IO s
05:56:59 <Arnar> and I'm returning a SheetImpl.. which has an instance for Sheet
05:57:02 <skorpan> trez: how many points have you claimed so far?
05:57:18 <luqui> Arnar, ahh, you're treating it like OO
05:57:28 <is_me> Botje: what if i would like to remove last two character, which no longer a character and is string, e.g. when input as glasses, the output will be glass, tht remove "es" (string) at the back
05:57:32 <schme_> luqui: Hey thanks. That seems usable.
05:57:44 <Arnar> luqui: figures.. :)
05:57:47 <trez> skorpan: nooo idea :)
05:57:50 <Arnar> luqui: what is the proper way?
05:57:50 <luqui> Arnar, Sheet s => Int -> s means "for *whatever* type s I (the caller) choose, you can give me one"
05:58:04 <schme_> Hmm.
05:58:05 <is_me> botje: as i know ..last only applicable for character..
05:58:06 <luqui> not "I will give you something which implements Sheet, but you won't know"
05:58:10 <schme_> I can's seem to use that cairo :(
05:58:16 <Arnar> luqui: ah ok..
05:58:27 <skorpan> trez: i'm trying to figure out quadruples function calls atm... :P
05:58:39 <schme_> Oh. while I'm on the topic here. What is that way cool function we use for doing candle stick charts and what not?
05:58:39 <Arnar> luqui: so I just use SheetImpl in the definiton of readSheetFile..
05:58:57 <luqui> Arnar, the proper way is a much harder question.   The cop-out answer is "eventually you'll stop designing code that way"
05:59:00 <shubuntu> luqui http://hpaste.org/7655 that should be working
05:59:01 <Arnar> the caller takes care of using it as a Sheet
05:59:14 <schme_> I get this here in my ghci: Could not find module `Graphics.Rendering.Cairo':  :(
05:59:14 <Arnar> luqui: :)
05:59:19 <dcoutts_> schme_: what's the problem with cairo? can't get it to install/work?
05:59:30 <Arnar> luqui: perhaps I shouldn't be using a typeclass for Sheet here at all?
05:59:30 <schme_> dcoutts_: I did import Graphics.Rendering.Cairo
05:59:32 <dcoutts_> schme_: did you install gtk2hs?
05:59:36 <schme_> dcoutts_: What is that?
05:59:41 <schme_> I just have ghc
05:59:53 <luqui> Arnar, there are several ways to do it if you haven't reorganized your brain yet, though.
05:59:55 <dcoutts_> schme_: it's the thing that provides cairo (which provides Graphics.Rendering.Cairo)
06:00:07 <luqui> the most obvious is to not use typeclasses, and instead use a vtable
06:00:08 <dcoutts_> schme_: ghc comes with a small core of libs, everything else is extra
06:00:13 <shubuntu> schme gtk is a linux library
06:00:17 <shubuntu> are you even on linux?
06:00:27 <dcoutts_> gtk2hs works on windows too
06:00:32 <dcoutts_> and osx
06:00:34 <Arnar> luqui: that doesn't sound very functional :/
06:00:39 <luqui> Arnar, data Sheet = Sheet { getProjectCount :: STM Int, getProjectName :: Int -> STM String, ... }
06:00:41 <shubuntu> yes but different installations
06:00:44 <matthew_-> dcoutts_: but not minix!
06:01:02 <dcoutts_> matthew_-: bah! I bet it could if ghc and gtk+ worked on minix :-)
06:01:09 <matthew_-> or RISC OS!
06:01:09 <luqui> Arnar, I'd say it's the functional way to achieve that kind of polymorphism
06:01:31 <Arnar> I see..
06:01:33 <schme_> shubuntu: I know what gtk is.
06:01:38 <Arnar> luqui: and how do I provide implementations?
06:01:42 <schme_> shubuntu: Yes I am on linux at the moment.
06:02:07 <luqui> returnSomeSheet = Sheet { getProjectCount = do { ... }, getProjectName = \i -> do {...}, ... }
06:02:08 <schme_> dcoutts_: So ok. Thanks for the info there. Any url to info on how to install extra gunk then?
06:02:18 <schme_> shubuntu: Does it really matter what OS I am on?
06:02:19 <Arnar> luqui: ah.. of course.. just like values :)
06:02:20 <dcoutts_> 'where gtk2hs
06:02:22 <dcoutts_> @where gtk2hs
06:02:22 <lambdabot> http://haskell.org/gtk2hs/
06:02:26 <luqui> Arnar, returnSomeSheet corresponds to a constructor in OO land
06:02:39 <Arnar> sure..
06:02:47 <Arnar> I'm not a big OO guy though..
06:02:49 <dcoutts_> schme_: depending on your linux distro, there may already be gtk2hs packages available
06:02:49 <Apocalisp> can foldM be made tail-recursive?
06:02:55 <schme_> Is there maybe a vector drawing function that does not require gtk though?
06:02:56 <is_me1> my connection is lost just now, anyone attempt my issue i raised?
06:03:04 <dcoutts_> schme_: eg, there are for debian, ubuntu, fedora etc
06:03:06 <schme_> dcoutts_: Right. I'm not on a distro. So I doubt there is :)
06:03:10 <Arnar> luqui: would like to stay away from that if there is a more (mathematically) elegant design
06:03:22 <shubuntu> Arnar, Luqui ok any way to concatmap my board adding the "\n" at the end of each row?
06:03:39 <Arnar> :t intercalate
06:03:41 <lambdabot> forall a. [a] -> [[a]] -> [a]
06:03:49 <schme_> It kinda sucks if I have to install gtk just to output some images to a png :)
06:03:57 <schme_> eeh to a file.
06:04:02 <Arnar> > intercalate "<newline>" ["bla", "ble"]
06:04:03 <lambdabot>  "bla<newline>ble"
06:04:11 <Apocalisp> ?src Maybe foldM
06:04:11 <lambdabot> Source not found. I feel much better now.
06:04:24 <ari> @src foldM
06:04:24 <lambdabot> foldM _ a []     = return a
06:04:25 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
06:04:35 <Apocalisp> oh right
06:05:47 <Apocalisp> I'm guessing it cannot be made tail-recursive without "getting out" of the monad.
06:06:08 <schme_> Right. yes. This gtk2hs is not at all what I want it turns out.
06:06:13 <dcoutts_> schme_: yeah, we're trying to separate out the gtk2hs components so that if you just need cairo then you could do that
06:06:15 <shubuntu> shme_ what matters is what versions of a certain library are available for you and which ones go with the compiler you're running and work with the environment you're in
06:06:36 <schme_> shubuntu: Right.
06:06:44 <Arnar> damn.. I'm always impressed when I write > 50 lines of code, correct a few (statically reported) type errors and the code just works on first run !
06:07:01 <luqui> schme_, just look around on http://hackage.haskell.org/packages/archive/pkg-list.html in the "Graphics" category
06:07:03 <luqui> gd might do it
06:07:04 <shubuntu> schme_ for ubuntu users since the debian packaging will check dependancies you won't have much of a problem as long as you stick to repositories
06:07:32 <schme_> shubuntu: I am aware of how debian checks dependencies.. yes.. I used it back in the 90s ;)
06:07:42 <schme_> luqui: ah thanks.
06:08:18 <shubuntu> ok luqui are you gonna help me out or what
06:08:19 <shubuntu> lol
06:08:50 <luqui> shubuntu, sry
06:08:55 <luqui> it's suddenly busy in here
06:08:55 <SamB> schme_: and you know that ubuntu uses the debian package system?
06:09:04 <shubuntu> i noticed
06:09:05 <shubuntu> lol
06:09:18 <schme_> SamB: Yes.
06:09:30 <schme_> SamB: Why?
06:09:54 <schme_> Gaarr! So here Iam viewing that there url and I find a thingie that seems very interesting and it too requires tonsa odd libraries installed. :(
06:10:17 <SamB> schme_: just making sure...
06:10:17 <shubuntu> switch to ubuntu mate
06:10:18 <shubuntu> lol
06:10:19 <luqui> > unlines $ zipWith (\n line -> show n ++ " " ++ line) [0..] ["hello", "world", "line"]
06:10:21 <lambdabot>  "0 hello\n1 world\n2 line\n"
06:10:30 <SamB> schme_: which odd libraries?
06:10:30 <luqui> shubuntu, that's a way to get the numbering
06:10:33 <schme_> shubuntu: Why on earth would I switch to ubuntu?
06:10:45 <schme_> SamB: gtk and cairo
06:10:59 <SamB> those are odd now?
06:11:02 <luqui> http://xkcd.com/178/
06:11:02 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
06:11:13 <dcoutts_> most standard linux systems have gtk and therefore also cairo
06:11:13 <shubuntu> luqui that's nice
06:11:17 <SamB> ... you ain't seen nothing yet
06:11:23 <shubuntu> though i need a bit of help in conversion
06:11:25 <matthew_-> ghc: 80% memory useage: 1667m virt; 1.6g res
06:11:28 <shubuntu> i'm still new to haskell
06:11:31 <schme_> Yes.. it seems very odd that a "A library for generating 2D Charts and Plots" requires those, ya. :)
06:11:36 <SamB> the type-level aritmatic libraries, now, *they* are wierd
06:11:36 <pjdelport> luqui: http://xkcd.com/424/ more like it
06:11:37 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
06:12:05 <SamB> matthew_-: 1337m would be cooler
06:12:13 <matthew_-> SamB: r.
06:12:28 <matthew_-> type level arithmetic isn't that odd
06:12:34 <schme_> Well that's messed up.   How do I do somethnig like run an external process from haskell?
06:12:40 <shubuntu> luqui so instead of that last list i could put my board?
06:12:44 <schme_> eg. gnuplot
06:12:45 <dcoutts_> schme_: well it's obvious that it needs cairo, since cairo is a 2D vector graphics api. I agree that the fact that you currently cannot install just the cairo bindings without also getting the gtk bindings is a problem.
06:12:52 <luqui> shubuntu, it really helps to break things up into small chunks
06:13:04 <luqui> shubuntu, try to do it without explicit recursion, but not worrying about terseness
06:13:10 <dcoutts_> schme_: it's on my TODO list in fact
06:13:12 <SamB> schme_: hmm, it does seem a bit odd that it would REQUIRE gtk...
06:13:19 <SamB> not so odd that it would need cairo though
06:13:22 <schme_> dcoutts_: That's bollocks, though. :) generating 2d charts and plots should not require anything remotely related to displaying stuff. :)
06:13:46 <schme_> But anyway.. calling external processes?
06:13:58 <schme_> --> make my haskell program run gnuplot
06:14:00 <matthew_-> schme_: look at System.Process
06:14:00 <dcoutts_> schme_: cairo doesn't display anything, though it does have an X11 backend
06:14:16 <SamB> matthew_-: yes, but the libraries are a bit less often installed aren't they?
06:14:19 <schme_> dcoutts_: Well it does require the gtk stuff though :)
06:14:27 <is_me1> halo..anyone can help out my issue?
06:14:28 <schme_> matthew_-: thanks, mate!
06:14:36 <dblhelix> does anyone know how to give a default definition for an associated type synonym in a class declaration?
06:14:40 <SamB> schme_: cairo is a vector graphics lib, okay?
06:14:49 <shubuntu> luqui: unlines $ zipWith (\n line -> show n ++ " " ++ line) [0..] [map 'show' row, row <- board]
06:14:54 <shubuntu> does that work?
06:14:56 <schme_> SamB: indeed!
06:15:06 <SamB> dblhelix: you tried the obvious way?
06:15:09 <luqui> I don't know what those ticks are around show
06:15:10 <dcoutts_> schme_: cairo does not, but the gtk2hs package requires both, see? the problem is that the gtk2hs package is a bit monolithic. As I said, it's on my TODO list to modularise the packaging of it.
06:15:20 <dblhelix> SamB: obviously :-)
06:15:23 <schme_> SamB: Too bad I can't use that there charts thingie :)
06:15:30 <luqui> shubuntu, and also... you have ghci don't you?
06:15:33 <SamB> dblhelix: I can't imagine any *other* method working...
06:15:37 <paczesiowa> wouldn't it be nice if every library function instead of type IO a would have type (MonadIO m) => m a ?
06:15:45 <schme_> dcoutts_: it seems very confusing there. Good luck with the work!
06:15:47 <SamB> and I don't see chak here
06:16:11 <SamB> I believe his usual nick is ChilliX ...
06:16:15 <quicksilver> paczesiowa: Yes. It would be very nice.
06:16:34 <SamB> paczesiowa: dunno
06:16:36 <Foloex> hello world
06:16:48 <dblhelix> SamB: me neither, but now I have class C a where { type T a = Int } and GHC complains: "Type declaration in a class must be a kind signature or synonym default" which is rather frustrating :-)
06:16:56 <SamB> paczesiowa: seems like it would mean having MonadIO wired into the compiler...
06:17:07 <SamB> dblhelix: ... okay
06:17:07 <schme_> SamB: The system I plan to run this on does not have GTK. That is the main problem here.
06:17:11 <luqui> > liftM2 (\x y -> [x,y]) "hello" "Foloex"
06:17:11 <shubuntu> luqui it gives lexical error that's why i asked
06:17:12 <lambdabot>  ["hF","ho","hl","ho","he","hx","eF","eo","el","eo","ee","ex","lF","lo","ll",...
06:17:17 <paczesiowa> SamB: why?
06:17:43 <Foloex> luqui: what ?
06:17:44 <luqui> shubuntu, right.  ticks unnecessary.  and there are a couple other things wrong, but first things first
06:17:50 <luqui> Foloex, just playing
06:17:58 <SamB> paczesiowa: well, for FFI imports...
06:18:20 <paczesiowa> since I learned how to use monad transformers I hate Maybe and plain IO
06:18:27 <Foloex> luqui: yeah, but I didn't get it
06:18:31 <SamB> also it would mean moving MonadIO from mtl to base (or below)
06:18:41 <dolio> dblhelix: I doubt you can give them a default.
06:18:42 <schme_> (and building gtk libs requires building Xlibs... so it just goes on like that. sucks)
06:18:57 <dblhelix> dolio: the error message seems to imply that, however
06:18:58 <paczesiowa> SamB: that's not the problem, I think. just library author would export IO actions wrapped in liftIO
06:19:06 <shubuntu> luqui
06:19:07 <shubuntu> showBoard board = "   0 1 2 3 4 5 6 7"  ++  unlines $ zipWith (\n line -> show n ++ " " ++ line) [0..] [map 'show' row, row <- board]
06:19:08 <SamB> dblhelix: perhaps that isn't implemented?
06:19:13 <shubuntu> that's how i've written it
06:19:15 <SamB> @go GHC trac type functions
06:19:18 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions
06:19:18 <lambdabot> Title: TypeFunctions - GHC - Trac
06:19:20 <dblhelix> SamB: probably
06:19:38 <SamB> dblhelix: let us check!
06:19:46 <luqui> shubuntu, but that doesn't type check!
06:19:47 <paczesiowa> there is ghc switch to overload strings, maybe we could have something to overload IO
06:20:03 <luqui> shubuntu, that doesn't even parse.
06:20:14 <luqui> (problem is that , in the list comprehension needs to be a | )
06:20:39 <dblhelix> SamB: indeed, it's still on the ToDo list:
06:20:43 <SamB> dblhelix: ah, it's still listed as TODO on http://hackage.haskell.org/trac/ghc/wiki/TypeFunctionsStatus
06:20:44 <dblhelix> http://hackage.haskell.org/trac/ghc/wiki/TypeFunctionsStatus
06:20:47 <lambdabot> Title: TypeFunctionsStatus - GHC - Trac
06:20:47 <lambdabot> Title: TypeFunctionsStatus - GHC - Trac
06:20:49 <luqui> shubuntu, but break the problem down inside ghci.   gradually work your way toward the final solution
06:20:52 <SamB> heh
06:20:58 <dblhelix> :-)
06:21:09 <SamB> ... we tell each other simultaneously
06:21:13 <luqui> shubuntu, start with the list comprehension and make sure that makes sense.  then add the zipWith.  etc.
06:21:21 <schme_> Hmmm.. Is there an easy way to set a time limit for a function?
06:21:40 <luqui> schme_, there is no such thing as time :-)
06:21:49 <schme_> Of course there is.
06:21:52 <luqui> it would violate referential transparency
06:21:53 <luqui> :-)
06:22:04 <luqui> (I'm sure there is in IO, don't know it)
06:22:09 <schme_> Right.
06:22:26 <schme_> Well I'll just switch this project over to some other lang then :(
06:22:30 <schme_> Too bad :(
06:22:40 <luqui> no guilt tripping me into finding the answer for you!
06:22:42 <schme_> Now I need a new one for haskell. grr.
06:22:46 <is_me1> halo.. anyone can help me?
06:22:46 <schme_> What.
06:22:52 <paczesiowa> maybe there is TimeMonad where bind takes you one small step to the future
06:22:53 <shubuntu> showBoard board = "   0 1 2 3 4 5 6 7"  ++  unlines $ zipWith (\n line -> show n ++ " " ++ line) [0..] [ x | x == concat board, concat (map 'mark' row), row <- board]
06:23:04 <is_me1> how could i remove the last two character from a word that contain the word of "ss", e.g, my input as "glasses", the output should be "glass"
06:23:08 <schme_> luqui: You already gave me an answer. it would violate dadadada
06:23:10 <schme_> etc.
06:23:20 <dolio> You can do it in IO, I expect.
06:23:24 <ari> http://hackage.haskell.org/packages/archive/ChasingBottoms/1.2.2/doc/html/Test-ChasingBottoms-TimeOut.html
06:23:25 <lambdabot> http://tinyurl.com/6rlzlb
06:23:31 <luqui> schme_, it was a joke.
06:23:34 <schme_> oh ok.
06:23:58 <SamB> dblhelix: yeah, the error message probably should have mentioned that that feature wasn't implemented yet!
06:24:13 <shubuntu> i'm confuzzled
06:24:20 <luqui> shubuntu, please take my advice.  this part: [ x | x == concat board, concat (map 'mark' row), row <- board] doesn't even make sense.  start with that, lose all the other crap.
06:24:33 <dblhelix> SamB: that would have been helpful yes, but I'll survive :-)
06:24:48 <shubuntu> i don't know the proper lexical syntax
06:24:54 <Saizan> shubuntu: that "'mark'" is invalid, maybe you meant `mark` ? but there you probably just want (map mark row) since map `mark` row == mark map row
06:24:55 <shubuntu> this is a new language to me
06:25:11 <conal> is_me1: try simpler problems first: (a) how would you know if a word contains "ss"? (b) how would you remove the *first* two characters?
06:25:14 <luqui> shubuntu, right.  I'm just advising that you start smaller than you are.
06:25:17 <SamB> shubuntu: what kind of token are you having trouble with?
06:25:35 <is_me1> conal: should be last two character.
06:25:40 <SamB> shubuntu: ... or do you not know what "lexical syntax" actually means?
06:25:42 <luqui> (not that this problem is out of your reach in the next hour, but you have to break it down)
06:25:55 <conal> is_me1: i know, but *first* two is simpler
06:26:00 <shubuntu> I don't know how to define that set
06:26:01 <schme_> Hmm.. System.CPUTime seems kinda interesting. I'm just not sure how I would use it to kill a function if it takes too long.
06:26:09 <conal> is_me1: and will help you solve the real problem
06:26:15 <schme_> woh.
06:26:16 <luqui> conal, we should consolidate our advice it seems :-)
06:26:25 <schme_> How do I check the precision of getCPUTime though?
06:26:27 <SamB> shubuntu: I think you do not know what lexical syntax means...
06:26:28 <is_me1> conal: http://hpaste.org/7650
06:26:29 <schme_> aah
06:26:32 <schme_> found it. thanks
06:26:38 <is_me1> this is wat i work earlier..
06:27:06 <is_me1> and already resolved.. to remove last character for 'd'
06:27:12 <shubuntu> [map mark row, row <- board]
06:27:26 <is_me1> but the "last" only can work in character..
06:27:40 <is_me1> if i put two character.. it wil be a string..
06:27:51 <is_me1> sorry if i m wrong.. just new to haskell
06:27:55 <conal> luqui: hi!  ?? were you helping is_me1 also?  (i may be missing context)
06:28:03 <Saizan> shubuntu: the syntax for list comprehensin is [ <element> | <pattern> <- <list> ]
06:28:14 <luqui> shubuntu, ok, that needs to be [ map mark row | row <- board ]
06:28:20 <SamB> shubuntu: lexical syntax generally refers to the syntax of the "tokens" used in a language
06:28:23 <luqui> shubuntu, do you have mark defined in your ghci session
06:28:24 <Saizan> > [x * 2 | x <- [1..10]]
06:28:25 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
06:28:31 <luqui> conal, no we were giving identical advice to two different people
06:28:40 <conal> luqui: oh!
06:29:03 <shubuntu> yes I have mark defined
06:29:06 <Vaelys> Saizan: Why would you want to do it that way instead of using a function?
06:29:11 <SamB> where tokens are things like keywords, identifiers, operators, literals...
06:29:12 <Saizan> shubuntu: so you mean [ map mark row | row <- board] ?
06:29:14 <shubuntu> mark reads a cell and returns a string
06:29:25 <schme_> hmmm.. Is there a way to increase the precision of getCPUTime ?
06:29:32 <shubuntu> i need to produce lines of string
06:29:53 <shubuntu> and add "\n" at the end and concat / unzip the whole thing into one string
06:29:54 <SamB> schme_: dunno!
06:29:59 <SamB> schme_: why do you want to?
06:30:00 <Saizan> Vaelys: because that's only the simplest form of list comprehension, you can add guards and more lists
06:30:10 <dolio> Buy a computer with a higher precision clock?
06:30:16 <shubuntu> so each row will be one line of string
06:30:22 <shubuntu> and then "\n"
06:30:27 <shubuntu> and then the next row
06:30:30 <schme_> SamB: To be able to time stuff better, ya.
06:30:38 <SamB> dolio: then again, it might be an OS issue?
06:30:53 <dolio> Yeah. I imagine it's a combination of things.
06:31:00 <schme_> dolio: I'm going on 1000hz here and I am getting 10 ms precision though
06:31:04 <schme_> which is shit.
06:31:20 <conal> is_me1: basic problem solving tactic: take just a piece of your problem, or even a simplified version of a piece of your problem, and solve it in isolation.  you'll learn something and maybe have a usable component of the solution.
06:31:22 <luqui> shubuntu, that's okay.  there is a function to get from one to the other (concat)
06:31:37 <shubuntu> luqui [concat (map mark row) | row <-board]
06:31:55 <luqui> does that do the right thing when you try it?
06:31:57 <shubuntu> does that produce those lines in a list of strings?
06:32:26 <shubuntu> how do i test it in prelude
06:32:29 <Saizan> shubuntu: but row is a list?
06:32:40 <shubuntu> row is a list of pawns
06:32:48 <shubuntu> and board is a list of rows
06:32:55 <luqui> shubuntu, either  "ghci MyFile.hs"  and start typing
06:33:07 <shubuntu> so board is a [[pawn]]
06:33:11 <Saizan> shubuntu: so yeah, that produces a [String]
06:33:19 <luqui> or in prelude define mark yourself using let;   Prelude> let mark x = whatever
06:33:33 <luqui> but that's only practical for small functions
06:33:42 <shubuntu> ok
06:34:10 <shubuntu> do i have to define mark :: pawn -> String ?
06:34:20 <luqui> yes
06:34:30 <luqui> if you have it defined in the .hs file ghci can use it
06:34:33 <shubuntu> so let mark :: pawn -> string
06:34:47 <shubuntu> let mark Dark = " X"
06:34:47 <luqui> oh, probably forget about the type signature for something so small
06:34:48 <paczesiowa> what does "(ghc-6.8.2)" mean in ghc-pkg output?
06:34:52 <kpreid> no, you don't have to write out the type signature
06:35:03 <luqui> let mark Dark = " X" ; mark Light = " O"
06:35:16 <shubuntu> ok so can use semicolons
06:35:47 <luqui> mind that they separate the clauses of the let, not different *statements*...
06:35:59 <luqui> let mark Dark = " X"
06:36:00 <kpreid> shubuntu: it's probably better to write stuff in a file and :load it
06:36:03 <luqui> let mark Light = " O"
06:36:06 <luqui> will *not* work
06:36:14 <kpreid> shubuntu: once you've done that you can just type :r to reload the file
06:36:31 * luqui seconds that advice
06:36:39 <shubuntu> that i know
06:36:42 <kpreid> so try something, edit the file, :r, try again, ...
06:36:42 <shubuntu> the problem wasn't there
06:36:51 <shubuntu> it was with testing that bit we produced up there
06:36:57 <shubuntu> [concat (map mark row) | row <-board]
06:37:03 <Arnar> kpreid: nice.. I didn't know about that.. been ding ":load file" over and over
06:37:19 <shubuntu> i wanted to see that if I passed a board to it, would it or not produce a list of strings
06:37:34 <pcc1> why aren't these types compatible? "Couldn't match expected type `forall s. ST s a' against inferred type `ST s Bool'"
06:37:58 <schme_> Oh System.Timeout seems great! yay.
06:37:59 <kpreid> shubuntu: ah, :t will tell you that
06:38:03 <kpreid> shubuntu: :type
06:38:22 <edwardk> pcc1 you probably used a . or $ where you shouldn't have
06:38:26 <schme_> It only goes down to microseconds :(
06:38:27 <kpreid> shubuntu: :type [concat (map mark row) | row <- (undefined :: Board)]
06:38:39 <Saizan> shubuntu: you can write your mark function in a file, and then load that file in ghci, so you can play with the functions defined in it at the prompt
06:38:41 <luqui> pcc1, it's about the "forall" inside the argument to runST.  need more context to help more.
06:39:03 <pcc1> edwardk: ah, removing the $ fixed it, thanks
06:39:18 <Saizan> shubuntu: if you already have ghci open the command is :load YourFile.hs
06:39:29 * luqui is annoyed by that polymorphism-reducing ($)
06:39:33 <schme_> This is confusing to my head. It says System.Timeout wraps an IO computation... does this mean I can not use it with any random function ?
06:40:10 <luqui> schme_, it's easy to go from ordinary functions *to* IO computations, you can't go the other way
06:40:11 <edwardk> i do sometimes wish that $ was 'primitive' so you could use it in types, when you want forall's to pass through it, etc.
06:40:23 <shubuntu> ok the loading bit is done
06:40:38 <luqui> edwardk, wasn't there a new paper by spj et al describing how to solve the polymorphism problem at least?
06:40:47 <shubuntu> now how do i test to see what the results are
06:40:50 <schme_> luqui: ok... ? :)
06:41:07 <dolio> It was solved for a couple versions, but they took out the thing that solved it.
06:41:10 <edwardk> luqui: the paper described how to make it so you never needed annotations on application right?
06:41:33 <Saizan> shubuntu: just write your expression at the prompt, assuming you've also defined a board
06:42:00 <luqui> schme_, oh, hmm, actually thinking about it it might be a little more subtle than that
06:42:18 <schme_> luqui: Ok :)
06:42:21 <shubuntu> [concat (map mark row) | row <- Board)] [[Dark,Light,Vacant],[Dark,Light,Light]]
06:42:24 <luqui> but you could try: result <- timeout 1000000 (return $! myFunction x y z)
06:42:25 <Arnar> :t sequence.sequence
06:42:30 <lambdabot> forall a. [[a]] -> [[a]]
06:42:32 <schme_> luqui: I have done haskell for like 2 days here so I have no idea what you are talking about really :)
06:42:34 <shubuntu> is that how?
06:42:38 <Arnar> ^ how do I get [[m a]] -> m [[a]] ?
06:42:54 <Saizan> shubuntu: no,  [concat (map mark row) | row <- [[Dark,Light,Vacant],[Dark,Light,Light]]]
06:42:58 <Arnar> :t mapM.sequence
06:43:00 <lambdabot> forall a a1. [a -> a1] -> [a] -> [[a1]]
06:43:14 <luqui> schme_, I have done haskell for like 3 years and still there are enough conversations in here that I don't know about.  get used to it :-)
06:43:29 <luqui> sigh.... category theory
06:43:31 <Saizan> shubuntu: or let board = [[Dark,Light,Vacant],[Dark,Light,Light]] in  [concat (map mark row) | row <- board]
06:43:41 <schme_> luqui: hahhahaha!
06:43:50 <schme_> Btw is it true that all haskellers run ubuntu?
06:43:57 <luqui> how dare you!
06:43:59 <Arnar> has anyone read the category theory for cs-tists by Pierce?
06:44:00 <dolio> timeout 1000000 (evaluate $ sum [1..]) ==> Nothing
06:44:04 * luqui gentoos
06:44:06 <schme_> It's just something I heard.
06:44:10 <schme_> oh gentoo.
06:44:15 <schme_> I even tried installing that twice.
06:44:16 <Saizan> edwardk: sometime you've to eta-expand, but yes
06:44:25 <shubuntu> that was nice
06:44:28 <shubuntu> thanks
06:44:31 <luqui> something about haskell, gentoo, masochism all have in common
06:44:40 <dolio> Arnar: I've read some of it.
06:44:50 <Arnar> dolio: is it worth it?
06:45:21 <dolio> It's okay. I've heard there's better stuff out there, but I haven't read much else.
06:45:28 <Arnar> ok
06:45:41 <schme_> Great.. well I'll just get back to reading this here real world haskell book. Which I finally figured out why it is so very boring at the moment. But but.. on to the next chapter :)
06:45:49 <Arnar> @hoogle Monad m => [[m a]] -> m [[a]]
06:45:54 <lambdabot> No matches, try a more general search
06:46:00 <shubuntu> ok first bit is down
06:46:03 <luqui> schme_, you should leave a comment about why it's boring
06:46:08 <Foloex> is it normal that I get an error saying that Int was expected but Integer was found ?
06:46:14 <shubuntu> now I need to add "\n" to the end of each line
06:46:14 * luqui also thought it a bit dry
06:46:18 <schme_> luqui: Where do I do that?
06:46:29 <luqui> schme_, aren't you reading online?
06:46:34 <dolio> @type sequence . map sequence
06:46:35 <schme_> luqui: yes I am reading it online!
06:46:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m [[a]]
06:46:39 <Arnar> shubuntu: map (++"\n") lines
06:46:47 <schme_> luqui: No. I bought the printed version :P
06:46:48 <Arnar> dolio: thanks
06:46:56 <vegai> Hello... I was wondering... and this may sound a bit odd
06:47:05 <vegai> how do you say "release evil monkeys" in swedish?
06:47:12 <Foloex> lol
06:47:21 <luqui> schme_, I read from here http://book.realworldhaskell.org/beta/library.html  There are "comment" links all over the place
06:47:22 <lambdabot> Title: ChapterÂ 6.Â Writing a Library
06:47:27 <schme_> slÃ¤pp ut onda apor
06:47:28 <schme_> vegai:
06:47:35 <luqui> oh and associated places of course
06:47:35 <schme_> luqui: hmm.
06:47:41 <vegai> schme_: thank you. I had something like that, but I needed to verify
06:48:03 <schme_> vegai: I must ask... why would you use such a phrase? :)
06:48:23 <vegai> I have this silly mandatory swedish course, and I'll be talking about Haskell
06:48:25 <shubuntu> Arnar will that add to the beginning or the end
06:48:36 <schme_> luqui: weird. I'm reading http://book.realworldhaskell.org/beta/fp.html and did C-s comment and all I find is a thing for subscribing to a fee.
06:48:36 <lambdabot> Title: ChapterÂ 5.Â Functional programming
06:48:39 <Arnar> shubuntu: to the end
06:48:44 <Arnar> shubuntu: if you want the beginning:
06:48:50 <schme_> a mandatory swedish course!? the fuck?
06:48:51 <vegai> and I'm hoping to get that phrase in there somewhere
06:48:53 <Arnar> map ("\n" ++) lines
06:49:03 <vegai> schme_: it's a finnish thing
06:49:07 <schme_> Aaah.
06:49:53 <is_me1> i got this with me.. http://hpaste.org/7657
06:49:58 <vegai> http://en.wikipedia.org/wiki/Image:Distribution-sv.png -- I suppose it's obvious from that picture that the whole country must learn the language ;)
06:49:59 <lambdabot> Title: Image:Distribution-sv.png - Wikipedia, the free encyclopedia
06:50:19 <is_me1> anyone do hv any idea how could i make it more easier..
06:50:28 <is_me1> seem d work i done so complicated..
06:50:37 <is_me1> conal.. any idea?
06:50:42 <shubuntu> [map (++"\n") lines | lines <- [concat (map mark row) | row <- board]]
06:50:44 <luqui> schme_, that's highly odd
06:51:13 <schme_> luqui: Ijust looked at that library.html and did a search for comment. I found three. none being anything related to posting a comment :S
06:51:57 <Arnar> shubuntu: hmm..
06:52:17 <Arnar> unlines [concat (map mark row) | row <- board]
06:52:20 <conal> is_me1: yes. decompose into simpler problems.  then compose their solutions.
06:52:24 <Saizan> schme_: do you have javascript enabled?
06:52:26 <luqui> schme_, this is confusing me then.  I'm there right now...
06:52:35 <Arnar> > unlines ["one","two","three"]
06:52:37 <lambdabot>  "one\ntwo\nthree\n"
06:52:50 <esteth_> is_me1: It seems like you could use a map instead of a recursion
06:53:00 <luqui> schme_, maybe there's some funny stuff happening with cookies, since i left comments weeks ago
06:53:10 <esteth_> is_me1: If you're changing a list of things, a map makes more sense in my opinion
06:53:20 <Foloex> how do I force 0 to be an Int and not a Num ?
06:53:25 <is_me1> is that the better solution?
06:53:29 <esteth_> Foloex: 0 :: Int ?
06:53:36 <is_me1> conal .. wat u think?
06:53:50 <Foloex> esteth: I thought it would be harder, thanks :)
06:53:52 <pjdelport> Foloex: or use it in any context that expects an Int
06:54:00 <Saizan> shubuntu: [ f x | x <- xs ] is already like (map f xs)
06:55:15 <Saizan> shubuntu: so in you've to use [lines ++"\n" | lines <- [concat (map mark row) | row <- board]] which is equivalent to:  map (++"\n") [concat (map mark row) | row <- board]
06:55:20 <shubuntu> ok i almost understand how it works
06:55:21 <schme_> luqui: odd :)
06:55:27 <Foloex> pjdelport: actually I'm using an array filled with zero and then I put other Int in it, 0 was taken as an Num so my other function could not put Int in it ...
06:55:28 <is_me1> conal: r u looking at my issue?
06:56:00 <Saizan> shubuntu: actually, what is called "lines" there, is just a single line
06:56:03 <Arnar> is there some RTS parameter I can use with runhaskell so that it gives me the location (or even backtrace) of runtime exceptions?
06:56:05 <schme_> Saizan: No, I do not have JS enabled.
06:56:23 <Saizan> schme_: that's why you're not seeing the comments links :)
06:56:32 <schme_> Ok.
06:56:33 <conal> is_me1: i think decompose-problem/compose-solutions will take you a long way in programming.  i'd like you to learn that paradigm so you'll have an easier time with future projects/assigments as well.
06:56:45 <schme_> Well that's cool then. Too bad I can't post comments then.
06:56:57 <pjdelport> Foloex: that function should probably be determining the Num instance to Int, then
06:57:01 <schme_> Not that my comments really would have been useful. (:
06:57:17 <schme_> (mah browser does not support js)
06:57:17 <shubuntu> ok Saizan
06:57:23 <shubuntu> i understand what you said
06:57:25 <roconnor> let fastNub l = [x | (x,s) <- zip l (scanl (flip insert) empty l), x `notMember` s] in fastNub [1,2,3,2]
06:57:33 <roconnor> > let fastNub l = [x | (x,s) <- zip l (scanl (flip Set.insert) Set.empty l), x `notMember` s] in fastNub [1,2,3,2]
06:57:34 <lambdabot>   Not in scope: `notMember'
06:57:35 <Foloex> pjdelport: no, it was saying that Integer was expected but Int was found
06:57:38 <shubuntu> now a for loop is needed to add 0 to n to the lines
06:57:41 <roconnor> > let fastNub l = [x | (x,s) <- zip l (scanl (flip Set.insert) Set.empty l), x `Set.notMember` s] in fastNub [1,2,3,2]
06:57:42 <lambdabot>   Not in scope: `Set.notMember'
06:57:44 <shubuntu> beginning of each line
06:57:49 <conal> is_me1: aka "divide and conquer"
06:57:53 <shubuntu> from [0..]
06:57:56 <luqui> schme_, ahhhh that's probably why
06:58:00 <luqui> schme_, it's definitely a js thing
06:58:13 <schme_> Mmm.. too bad.
06:58:17 <pjdelport> Foloex: what was the code?
06:58:34 <roconnor> > let fastNub l = [x | (x,s) <- zip l (scanl (flip Set.insert) Set.empty l), x `S.notMember` s] in fastNub [1,2,3,2]
06:58:34 <lambdabot>   Not in scope: `Set.empty'
06:58:42 <roconnor> > let fastNub l = [x | (x,s) <- zip l (scanl (flip S.insert) S.empty l), x `S.notMember` s] in fastNub [1,2,3,2]
06:58:48 <lambdabot>  [1,2,3]
06:59:05 <Foloex> pjdelport: grille = array (('A','I'),('a','i')) [ ((x,y), 0 ) |  x <- ['A'..'I'],y <- ['a'..'i'] ]
06:59:22 <roconnor> Is that just as good as nub when a is an instance of Ord?
06:59:31 <Saizan> shubuntu: ok, so a way to do that is traversing the two lists in parallel and computing (show i ++ l), where i is the index and l the line
06:59:32 <Foloex> pjdelport: charge grille c x y = grille // [((x, y), digitToInt(c))]
06:59:48 <Saizan> shubuntu: to traverse two lists in parallel you can use zipWith
07:00:19 <Saizan> > zipWith (\a b -> a + b) [1..5] [1..5]
07:00:21 <lambdabot>  [2,4,6,8,10]
07:00:31 <Saizan> ?type zipWith
07:00:33 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
07:00:46 <Syzygy-> > zipWith (+) [1..5] [1..5]
07:00:47 <lambdabot>  [2,4,6,8,10]
07:01:02 <Syzygy-> @pl (\a b -> a+b)
07:01:02 <lambdabot> (+)
07:01:26 <shubuntu> i see
07:02:06 <Botje> !seen simonpj
07:02:13 <Botje> @seen simonpj
07:02:14 <lambdabot> I haven't seen simonpj.
07:02:16 <Botje> boo.
07:02:49 <shubuntu> (\i line -> i + line)[0..][line ++"\n" | line <- [concat (map mark row) | row <- board]]
07:02:55 <shubuntu> is that the right syntax
07:03:11 <pjdelport> Foloex: do you have -fno-monomorphism-restriction?
07:03:15 <Saizan> shubuntu: you've forgotten zipWith
07:03:24 <Foloex> pjdelport: I don't know
07:03:31 <Saizan> shubuntu: and we usually put a whitespace between parameters
07:03:33 <schme2> So this cairo does not require X ?
07:03:44 <pjdelport> Foloex: ok, that's probably the problem then
07:03:56 <Foloex> pjdelport: I just use winhugs
07:04:10 <dcoutts_> schme2: it has backends for png/bitmap, for X, for win32, for OSX, pdf, ps, svg, opengl
07:04:16 <Saizan> shubuntu: also, + is addition for numbers, while here you need list concatenation
07:04:41 <shubuntu> unlines $ zipwith (\i line -> (show i) ++ line) [0..] [line ++"\n" | line <- [concat (map mark row) | row <- board]]
07:04:41 <dcoutts_> schme2: any/all backends can be built (except bitmap/png which is required)
07:04:46 <Saizan> shubuntu: and think about what "i" is
07:04:55 <pjdelport> Foloex: oh, i don't know how you turn it off in hugs
07:05:08 <schme2> dcoutts_: Ah cool. Sounds great as long as the haskell thingie does not require it to be built on way or the other :)  (I mean when it's there for the takin')
07:05:08 <dcoutts_> schme2: which means, yes, it can be built without support for X11 surfaces
07:05:38 <pjdelport> Foloex: but see here: http://www.haskell.org/haskellwiki/Monomorphism_restriction
07:05:38 <lambdabot> Title: Monomorphism restriction - HaskellWiki
07:06:08 <Saizan> shubuntu: ok, that looks good, try it :) (not the correct solution probably but will give you an output)
07:06:16 <pjdelport> Foloex: basically, the generic type for grille would be grille :: (Num t) => Array (Char, Char) t
07:06:41 <Foloex> pjdelport: ok, thanks
07:07:30 <pjdelport> however, the monomorphism restriction changes the default type to remove the type class, defaulting the instance to Integer instead:
07:07:31 <pjdelport> grille :: Array (Char, Char) Integer
07:07:37 <shubuntu> let board = [[Dark,Light,Vacant],[Dark,Light,Light]] in unlines $ zipWith (\i line -> (show i) ++ line) [0..] [line ++"\n" | line <- [concat (map mark row) | row <- board]]
07:07:43 <shubuntu> that's what I put in
07:07:57 <Foloex> how can I go from 'a' to 'b' ? something like 'a'++
07:08:05 <shubuntu> "0 X O .\n\n1 X O O\n\n"
07:08:10 <shubuntu> that's the result
07:08:11 <pjdelport> Foloex: so to get around that, you have to explicitly give the generic type
07:08:22 <shubuntu> i'm getting one extra \n per line
07:08:33 <Foloex> pjdelport: that's what I did 0 :: Int
07:08:34 <dozer> hi
07:08:37 <dozer> I'm writing a paper finally
07:08:41 <shubuntu> I think should remove that Line ++ "\n" bit
07:08:43 <pjdelport> or disable the restriction (-fno-monomorphism-restriction in GHC)
07:08:43 <dozer> and want to dump some haskell code into it
07:08:46 <esteth_> is_me1: This is how i would have done it: http://hpaste.org/7658 Perhaps not good style though, i'm still a haskell newbie
07:09:13 <dozer> I tried this but it wasn't very satisfactory: \begin{lstlisting}[frame=tb]{code}
07:09:15 <pjdelport> > succ 'a'
07:09:18 <luqui> shubuntu, unlines adds "\n"s already
07:09:18 <lambdabot>  'b'
07:09:21 <dozer> is there something better?
07:09:27 <pjdelport> Foloex: -^
07:09:33 <Saizan> shubuntu: yeah, or equivalently you can use concat in place of unlines
07:11:28 <pcc1> can you impose a constraint on a parameter to a parameterised type (i.e. must be a member of a particular class)
07:11:48 <pjdelport> Foloex: 0 :: Int is probably not the best solution, in this case
07:12:11 <Foloex> pjdelport: it works fine ^^
07:12:13 <pjdelport> Foloex: unless you're sure you want Int
07:12:18 <shubuntu> unlines $ zipWith (\i line -> (show i) ++ line) [0..][concat (map mark row) | row <- board]
07:12:27 <Foloex> pjdelport: I am for now
07:12:35 <pcc1> pcc1: I got it
07:12:36 <is_me1> esteth_: thanks for doing tht... will get to hv a look..
07:12:39 <pjdelport> Foloex: if the values can get big, you don't want it :)
07:12:43 <shubuntu> that doesn't work I need to define line somewhere
07:13:07 <pjdelport> Foloex: ok, but for future reference, you can put fromIntegral in front of digitToInt
07:13:19 <pjdelport> :t fromIntegral
07:13:21 <lambdabot> forall a b. (Num b, Integral a) => a -> b
07:13:47 <pjdelport> Foloex: it converts the Int to any desired target type
07:14:04 <shubuntu> ok so that bit is fixed
07:14:07 <Saizan> :t let board = undefined; mark = undefined; in unlines $ zipWith (\i line -> (show i) ++ line) [0..] [concat (map mark row) | row <- board]
07:14:09 <lambdabot> String
07:14:12 <Foloex> pjdelport: I'm making a sudoku solver so the values won't go over 9 ^^
07:14:18 <pjdelport> Foloex: so that the result type of change remains a generic Num, instead of Int
07:14:34 <shubuntu> yeah worked
07:15:23 <shubuntu> is there a way to squeeze in a first line of "   0 1 2 3 4 5 6 7" or am i better off just adding it as a string
07:15:51 <shubuntu> cause for boards of different size I could get a row and set that to the size of the row if it were numbers
07:17:06 <shubuntu> I know i can get the length of a row in [length(row) | row <- board]
07:17:24 <shubuntu> but will that add up lengths or just give me the length of one row
07:18:18 <luqui> shubuntu, it will give you a list of the lengths of each row
07:18:25 <paczesiowa> what does "(ghc-6.8.2)" mean in ghc-pkg output?
07:18:36 <luqui> shubuntu, (and those parentheses around row are not necessary, fwiw)
07:18:41 <shubuntu> ok so what do i do if i want the length of the first row alone without going through all rows?
07:18:54 <luqui> take head of that list?
07:19:03 <luqui> haskell is lazy, it won't bother computing any other lengths
07:19:30 <luqui> or even do the equivalent (but perhaps more transparent):  length (head board)
07:20:08 <shubuntu> length[head board]
07:20:14 <luqui> "head (map length board)"  is exactly the same, including performance, as "length (head board)"
07:20:26 <luqui> parens, not brackets, otherwise it will just give you 1, the length of that list
07:20:54 <luqui> @free map :: (a -> b) -> [a] -> [b]
07:20:54 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
07:21:21 <luqui> hmm, not the free theorem I thought
07:21:30 <luqui> (ignore me)
07:21:31 <maltem> What do the $ tell us?
07:21:46 <shubuntu> so either head (map length board) or length (head board)
07:21:49 <luqui> maltem, I think that's just distinguishing its map from my map.
07:22:06 <luqui> i.e. its map means "map", my map means "something with map's signature"
07:22:43 <luqui> shubuntu, yeah.   map length board  you have written  [length row | row <- board].  same thing.
07:22:44 <maltem> ah. funny it uses both together
07:22:56 <luqui> I could have said
07:23:06 <luqui> @free beer :: (a -> b) -> [a] -> [b]
07:23:06 <lambdabot> g . h = k . f => $map g . beer h = beer k . $map f
07:23:25 <Foloex> pjdelport: Do you know how I could make a display function for my array ?
07:23:53 <maltem> ah, so the $ marks functions with a specific implementation
07:24:23 <maltem> whereas all other variables are universally quantified - right?
07:24:50 * Apocalisp sings "You got to know when to liftM, know when to foldM..."
07:24:51 <pjdelport> Foloex: it should come with a default Show instance
07:25:21 <pjdelport> @remember Apocalisp sings "You got to know when to liftM, know when to foldM..."
07:25:22 <lambdabot> It is forever etched in my memory.
07:25:31 <shubuntu> ok now i need to create a list of i's from 0 to length
07:25:38 <shubuntu> how do i do that?
07:26:05 <Vaelys> why limit it?
07:26:39 <shubuntu> [0..(length (head board)]
07:27:36 <Foloex> pjdelport: I this when I want to see the "grille"
07:27:36 <Foloex> array (('A','I'),('a','i')) [(('A','I'),
07:27:36 <Foloex> Program error: undefined array element
07:28:27 <pjdelport> Foloex: right, it's trying to print the first value, but it's not defined
07:28:29 <luqui> shubuntu, an infinite list will do if you're zipping
07:28:32 <shubuntu> that didn't work
07:28:44 <luqui> > zip [0..] [3,1,4,1,5]
07:28:45 <lambdabot>  [(0,3),(1,1),(2,4),(3,1),(4,5)]
07:28:46 <shubuntu> not for the first zipping
07:28:46 <luqui> no?
07:28:49 <shubuntu> nooo
07:28:53 <luqui> nooooo?
07:28:54 <shubuntu> for the first line
07:28:59 <luqui> oh right
07:29:02 <Foloex> pjdelport: but it's filled with 0 at first
07:29:16 <shubuntu> "   0 1 2 3 4 5 6 7"
07:29:26 <shubuntu> that's dependant of the length of rows
07:29:35 <Foloex> pjdelport: grille ! ('A','a') does return 0
07:29:38 <shubuntu> for an 8 by 8 board that goes up to 7
07:30:03 <shubuntu> for a 3 by 3 like X/O it only goes up to 2
07:30:08 <luqui> so... start at 1
07:30:08 <shubuntu> etc
07:30:21 <luqui> or you're just explaining
07:30:22 <luqui> okay
07:30:23 <shubuntu> doesn't matter where I start at
07:30:42 <shubuntu> the problem is the syntax i'm not familiar with
07:30:43 <shubuntu> lol
07:30:51 <shubuntu> i'm so sorry for bugging you guys
07:31:01 <luqui> if I didn't want you to bug me I'd stop talking
07:31:08 <shubuntu> fair enough
07:31:24 <luqui> > [0..length [1,2,3]]
07:31:25 <lambdabot>  [0,1,2,3]
07:31:46 <shubuntu> that didn't work
07:32:02 <shubuntu> let board = [[Dark,Light,Vacant],[Dark,Light,Light]] in [0..(length (head board)]
07:32:02 <shubuntu> <interactive>:1:80: parse error on input `]'
07:32:07 <shubuntu> or maybe i wrote it wrong?
07:32:16 <luqui> missing a closing parenthesis near the end
07:32:35 <shubuntu> i see
07:32:51 <luqui> safe to omit the opening one before length
07:33:05 <shubuntu> oh i can?
07:33:11 <luqui> (an important thing to remember about haskell syntax is that function application is tighter than *anything* else)
07:33:40 <luqui> so "foo x *&^@ bar y" is always "(foo x) *&^@ (bar y)", no matter what the precedence of *&^@
07:33:44 <shubuntu> let board = [[Dark,Light,Vacant],[Dark,Light,Light]] in [0..(length (head board)]
07:33:44 <shubuntu> <interactive>:1:80: parse error on input `]'
07:34:01 <shubuntu>  let board = [[Dark,Light,Vacant],[Dark,Light,Light]] in [0..length (head board)-1]
07:34:01 <shubuntu> [0,1,2]
07:34:06 <shubuntu> ok it works
07:34:24 <shubuntu> now the last bit to make a list out of it
07:34:38 <shubuntu> easiest way is combination of show and concat
07:34:43 <pjdelport> Foloex: i think you want grille = array (('A','a'),('I','i')) [...]
07:34:48 <shubuntu> that zipWith won't work here will it?
07:34:58 <shubuntu> anything familar
07:35:10 <luqui> i'm a bit lost.  make a list out of what?  show what?
07:35:23 <roconnor> @check (==)
07:35:26 <lambdabot>  OK, passed 500 tests.
07:35:38 <shubuntu> luqui was that question directed at me?
07:35:40 <roconnor> :/
07:35:42 <pjdelport> Foloex: the first tuple gives the actual start and end index
07:36:14 <Foloex> pjdelport: I want to display the values stored inside the grille
07:36:18 <shubuntu> I need to make the list into a string that goes on top
07:36:27 <luqui> shubuntu, anye
07:36:40 <roconnor> dons: @check (==)  -- this is not a useful way of checking polymorphic functions
07:36:40 <pjdelport> Foloex: well, that will let you display it
07:36:41 <Foloex> pjdelport: I did a little function which goes through the whole thing
07:36:55 <luqui> oh now I know what you're talking about shubuntu
07:37:04 <luqui> yes that is what show is there for :-)
07:37:06 <pjdelport> Foloex: the problem at the moment is happening earlier:  the array is declared with different indexes than what you're giving it
07:37:30 <shubuntu> so could go concat (map show [0..length (head board)-1]) ++ "\n"
07:37:54 <quicksilver> > concat (map show [0..7]) ++ "\n"
07:37:57 <lambdabot>  "01234567\n"
07:38:34 <pjdelport> Foloex: array (('A','a'),('I','i')) means that rows and colums range from A to I and from a to i
07:39:19 <shubuntu> however that will lack the space in between
07:39:30 <quicksilver> indeed.
07:39:33 <pjdelport> Foloex: array (('A','I'),('a','i')) means the rows and columns go from 'A' to 'a' and 'I' to 'i'
07:39:49 <luqui> > intercalate " " (map show [0..7])
07:39:49 <quicksilver> > intersperse 9 [1..7]
07:39:51 <lambdabot>  "0 1 2 3 4 5 6 7"
07:39:51 <lambdabot>  [1,9,2,9,3,9,4,9,5,9,6,9,7]
07:40:04 <schme2> Hmm.. I was lookin' around and found references to happs. But it seems happs.org is not in working order. Where do I look for info on this thing?
07:40:14 <Foloex> pjdelport: exactly
07:40:45 <Foloex> pjdelport: wait no, It goes from 'A' to 'I' and from 'a' to 'i'
07:40:57 <pjdelport> Foloex: right, so you want the first version
07:41:27 <shubuntu> the total thing should be like "  " ++ intercalate " " (map show [0.. length (head board)-1]) ++ "\n"
07:41:34 <shubuntu> right?
07:41:37 <Foloex> pjdelport: no, the second
07:42:18 <luqui> looks fine
07:42:18 <Foloex> pjdelport: array (('A','I'),('a','i')) means the rows and columns go from 'A' to 'I' and 'a' to 'i'
07:42:25 <pjdelport> Foloex: no, it doesn't :)
07:42:29 <shubuntu> what
07:42:44 <shubuntu> what's the difference between intercalate and intersperse
07:42:49 <Deewiant> @ty intercalate
07:42:50 <luqui> shubuntu, as far as layout, I'd put that in a where clause in your render function.  "where header = "  " ++ intercalate ... "
07:42:51 <lambdabot> forall a. [a] -> [[a]] -> [a]
07:42:52 <Deewiant> @ty intersperse
07:42:53 <lambdabot> forall a. a -> [a] -> [a]
07:42:54 <matthew_-> about 6 letters
07:42:57 <luqui> @src intercalate
07:42:57 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
07:42:58 <pjdelport> Foloex: think of it as giving the top-left and bottom-right coordinates
07:43:21 <roconnor> > range (('A','C'),('a','c'))
07:43:23 <lambdabot>  [('A','C'),('A','D'),('A','E'),('A','F'),('A','G'),('A','H'),('A','I'),('A',...
07:43:33 <roconnor> > range (('A','a'),('C','c'))
07:43:34 <lambdabot>  [('A','a'),('A','b'),('A','c'),('B','a'),('B','b'),('B','c'),('C','a'),('C',...
07:43:35 <shubuntu> this is just a temp thing and will be used for redevelopment
07:43:45 <Foloex> thanks roconnor
07:43:47 <shubuntu> i'm going to render these graphically with openGL
07:44:03 <shubuntu> so i'll be redefining the data sets a bit
07:44:15 <pjdelport> > range (('a',0),('z',9)
07:44:15 <lambdabot> Unbalanced parentheses
07:44:18 <pjdelport> > range (('a',0),('z',9))
07:44:19 <lambdabot>  [('a',0),('a',1),('a',2),('a',3),('a',4),('a',5),('a',6),('a',7),('a',8),('a...
07:44:19 <shubuntu> and yes i understand why you say it should go to the render function and I'll make a note of that
07:44:23 <shubuntu> thanks for the advice
07:44:28 <pjdelport> > range (('a','z'),(0,9))
07:44:28 <lambdabot>   add an instance declaration for (Num Char)
07:44:28 <lambdabot>     In the expression: 0
07:44:28 <lambdabot>     In ...
07:44:59 <luqui> shubuntu, I think the openGL render could use the same data structures and just massage differently
07:45:06 <luqui> maybe that's what you're saying
07:45:09 <pjdelport> (that's asking to go from 'a' to 0 and 'z' to 9, which doesn't make much sense)
07:45:18 <shubuntu> yep
07:45:46 <shubuntu> i'll be passing the board itself to the draw function in my openGLRender
07:45:53 <shubuntu> it'll just draw Cells
07:46:23 <luqui> probably be easier than this text function, actually :-)
07:46:30 <shubuntu> yes
07:46:33 <shubuntu> it will be
07:46:38 <shubuntu> but this is for later use
07:46:46 <shubuntu> when the program is done
07:46:51 <shubuntu> and i need to add one new game
07:46:56 <luqui> have you done haskell opengl stuff yet?
07:47:02 <shubuntu> then I won't have to worry about too many things
07:47:05 <shubuntu> yes
07:47:09 <shubuntu> I've done most of it
07:47:15 <shubuntu> the bitmap part is done
07:47:17 <WebGuest> hi there.. how could i present my output in table format or in nice indented column?
07:47:22 <shubuntu> and the window stuff are done too
07:47:25 <WebGuest> tought of using \t
07:47:29 <shubuntu> just need the input window
07:47:38 <shubuntu> and a bit on IO manipluations
07:47:45 <WebGuest> do haskell have someting like setw like what C++ having?
07:47:45 <shubuntu> and I need to work on my threads too
07:47:57 <shubuntu> loads left actually
07:47:58 <shubuntu> lol
07:48:07 <lilac> WebGuest: i'm no expert, but haskell does have printf, which allows width specifications
07:48:17 <luqui> WebGuest, it has printf from Text.Printf, but I consider that hacky
07:49:04 <WebGuest> do i need to import anything prior fr. using printf?
07:49:27 <luqui> > let setw w str = replicate (w - length str) ' ' ++ str in setw 12 "hello"
07:49:28 <lambdabot>  "       hello"
07:49:30 <lilac> > let alignr n x = let s = show x in take (n - length s) (repeat ' ') ++ s in alignr 5 1.2
07:49:32 <lambdabot>  "  1.2"
07:49:46 <luqui> lilac, we should go out
07:49:48 <luqui> :-p
07:50:00 <lilac> luqui: perhaps we're *too* similar? :-)
07:50:40 * lilac adds 'replicate' to list of useful stuff
07:50:46 <luqui> WebGuest, you need to import Text.Printf for printf
07:50:50 <luqui> or you could just use our version
07:51:04 <WebGuest> yup.. definitely will give a try.
07:51:47 <lilac> http://lukeplant.me.uk/blog.php?id=1107301645
07:51:48 <lambdabot> Title: Why learning Haskell/Python makes you a worse programmer
07:52:05 <lilac> ^^ so very true :(  Haskell is making me hate my C++ day job ;-)
07:53:05 <maltem> I hated C++ before I met Haskell, actually
07:53:28 * luqui blames haskell for causing me not to want to be a professional programmer
07:53:29 <ddarius> I liked C++ before I heard of Haskell and I like C++ now.
07:53:37 <luqui> going to be a musician or something now
07:53:40 <dozer> +1 for C++ hate
07:53:41 <esteth_> I used to hate C# after i met haskell, but C# 3.0 makes it somewhat manageable
07:53:59 <luqui> esteth_, after haskell though?  C#3 is so half-assed!
07:54:15 <luqui> type inference, but not really.  coroutines, but not really.
07:54:35 <schme2> My god! Why all the hate!?
07:54:51 <luqui> because haksel is the awsum
07:54:58 <edwardk> luqui: yeah but it is a step in the right direction and a sign that the general population is starting to 'get it'
07:54:58 <luqui> oh man, I misspelled the
07:54:58 <schme2> (ok. I'm finding meself hating haskell here, but still)
07:55:04 <luqui> no I didn't
07:55:05 <luqui> xchat did
07:55:11 <lilac> yeah, C++ isn't *that* bad. i wrote a currying HOF in c++0x this morning
07:55:12 <esteth_> luqui: But we finally have real lambdas, and extension methods are useful too :D
07:55:15 <luqui> "teh"
07:55:16 <schme2> luqui: I'm really lookin' forward to finding the awsum bit :)
07:55:38 <edwardk> and to be quite honest, c# provides inspection on lambda terms, which haskell wouldn't touch with a ten foot pole.
07:56:17 <edwardk> the ability to play with your function bodies via the reflection mechanism gives you the possibility of doing things like linq-to-sql which you can't do in haskell try as you might
07:56:42 <luqui> lilac, C++0x gets props for stealing typeclasses
07:56:45 <edwardk> the haskell equivalent would be disturbingly clunky and unnatural.
07:57:00 <edwardk> @karma C
07:57:00 <lambdabot> C has a karma of 15
07:57:11 <schme2> play with function bodies?
07:57:11 <edwardk> I wonder what talking about C++ does?
07:57:13 <edwardk> @karma C
07:57:13 <lambdabot> C has a karma of 15
07:57:17 <edwardk> ah good =)
07:57:27 <Philippa> edwardk: the haskell equivalent wouldn't use a monad, or at least not a Monad - it'd embed a turing-complete language
07:58:07 <edwardk> Philippa: sure, but the nice thing about linq-to-sql is not the capability it provides but that the syntax is not unnatural to use. the template haskell equivalent would be terrible.
07:58:12 <Philippa> I keep meaning to get round to doing a study on such things and on useful sugar for them
07:58:15 * luqui wants haskell to be dependently typed so it can embed its own type system in its terms
07:58:23 <luqui> and thus give me typesafe reflection
07:58:28 <Philippa> sure. I deliberately didn't say TH :-)
07:58:43 <quicksilver> surely the haskell equivalent of linq would be some kind of preprocessing or metaquoting.
07:58:45 <luqui> but I do not want haskell to be dependently typed, because we don't know how to do that well yet
07:58:46 <shubuntu> luqui
07:58:54 <shubuntu> it says intercalate is not in scope
07:58:55 <edwardk> *nods* but without it you lack any good binder syntax ;)
07:58:56 <schme2> oh syntax
07:58:58 <shubuntu> is that a typo?
07:59:00 <luqui> @hoogle intercalate
07:59:00 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
07:59:00 <lambdabot> Data.ByteString.intercalate :: ByteString -> [ByteString] -> ByteString
07:59:00 <lambdabot> Data.ByteString.Char8.intercalate :: ByteString -> [ByteString] -> ByteString
07:59:01 <schme2> that's one thing that bugs me about haskell.
07:59:09 <luqui> shubuntu, in Data.List
07:59:24 <Philippa> edwardk: yep. I'd rather find some good general binder syntax, personally
07:59:30 <shubuntu> so should import a module?
07:59:38 <Philippa> it's pretty high on my "damn I wish this didn't take so long" to-do list
07:59:41 <luqui> "import Data.List" indeed :-)
07:59:49 <edwardk> i tried a quick hack using hoas to see if i could inspect something that way, but you still have to use a 'second class' syntax for everything because all the good operators are taken
08:00:09 <lilac> luqui: C++0x gets props for some approximation of lambdas, too, and variadic templates
08:00:30 * luqui gives it no props for lambda approximates.
08:00:32 <edwardk> just like lennart's embedded imperative language posts
08:00:35 <WebGuest> lilac: i m not quite sure about that.. do u think you could give an example in http://hpaste.org/?
08:01:00 <shubuntu> what about intersperse
08:01:04 <lilac> WebGuest: i'm not quite sure what you want an example of ;-)
08:01:07 <shubuntu> they're both in the same module?
08:01:17 <luqui> I think it deserves props for modular parametric polymorphism more than variadic
08:02:24 <luqui> C++ finally lost the, er, feature that client code could cause library code to fail to typecheck
08:02:59 <shubuntu> hehe
08:03:11 <edwardk> luqui: =)
08:03:18 <shubuntu> hey do i need to import the module Data.List in my main file as well
08:03:31 <luqui> shubuntu, wherever you want "intercalate" to be in scope
08:03:32 <shubuntu> or by importing the game module it'll be imported automatically
08:03:35 <luqui> nowhere else
08:03:52 <luqui> yes that one
08:03:56 <luqui> well, sortof
08:04:15 <luqui> the names don't carry through unless you tell them to
08:04:27 <shubuntu> like I'm importing Data.List in the game.hs
08:04:41 <shubuntu> and the showBoard is there
08:05:03 <Saizan> that suffices
08:05:04 <shubuntu> so if I import game into my main module in main.hs
08:05:12 <shubuntu> and call showBoard
08:05:25 <lilac> luqui: i think move semantics is pretty awesome too, tbh -- assuming you want mutable state, it's really nifty
08:05:40 <luqui> lilac, hmm, haven't heard of this
08:05:47 <luqui> what is it?
08:06:01 <luqui> shubuntu, that will be fine of course
08:07:24 <lilac> luqui: basically, it's a way of overloading based on whether an argument is a temporary or not. it's a lot like unique types in other languages. mostly, it's used for optimizations, where you can steal resources from an object because you know it's about to go out of scope
08:07:52 <luqui> ah so you can do that manually
08:08:20 <lilac> luqui: the canonical example is string concatenation, whereby it allows str1 + str2 + str3 + str4 to be implemented with a single buffer
08:08:49 * luqui prefers stream fusion :-p
08:08:56 <luqui> yeah that's cool from a low level angle
08:09:05 <luqui> which is so far below now that I cannot even see it
08:09:39 <Foloex> the symbol to seperate two lines is ';'right ?
08:09:43 * quicksilver prefers steam-powered-fusion
08:09:49 <quicksilver> Foloex: in a layout block, yes.
08:09:55 <quicksilver> (which is the only time lines matter)
08:10:50 <Foloex> quicksilver: I want to do two things in a if so it's if (condition) then first; second else something
08:10:55 <lilac> luqui: if i didn't want / need to get elbow-deep in zeroes and ones, i wouldn't be using c++ anyway :)
08:11:04 <luqui> good point
08:11:14 <quicksilver> Foloex: no, you don't need any semicolons.
08:11:22 <quicksilver> Foloex: erm, sorry.
08:11:33 <quicksilver> Foloex: I need to concentrate harder on what you're saying :)
08:11:37 <lilac> Foloex: is this inside a monad?
08:11:40 <quicksilver> Foloex: "do" two things?
08:11:45 <quicksilver> Foloex: presumably that's a monad then
08:11:51 <Foloex> quicksilver: no, it's just in a function
08:12:04 <quicksilver> if it's not a monad what does "do" two things mean? :)
08:12:05 <luqui> Foloex, what are you going to do with the result of first?
08:12:07 <lilac> Foloex: in a monad, use >> instead of ;. Otherwise, you want the results of both first and second, so something like (first, second) would be your friend
08:12:09 <quicksilver> can you give an exmaple.
08:12:34 <Foloex> aff grille x y =
08:12:35 <Foloex> 	if (y /= 'i') then
08:12:35 <Foloex> 		putChar (get grille x y);
08:12:35 <Foloex> 		aff grille x (succ y);
08:12:35 <Foloex> 	else
08:12:50 <quicksilver> you are in a monad :)
08:12:58 <Foloex> quicksilver: ah? ok
08:12:58 <quicksilver> putChar is a monadic function.
08:13:00 <quicksilver> :t putChar
08:13:08 <lambdabot> Char -> IO ()
08:13:25 <shubuntu> i'm having trouble again with intercalate
08:13:26 <shubuntu> http://hpaste.org/7660
08:13:39 <Foloex> but I don't care about the result of putChar ...
08:13:56 <quicksilver> Foloex: if (y /= 'i') then putChar (get grille x y) >> aff grille x (succ y) else ...
08:14:04 <geezusfreeek> then do putChar blahblahblah; aff blahblahblah; else â¦ or: then putChar blahblahblah >> aff blahblahblah else
08:14:08 <quicksilver> you can also rewrite a >> b is
08:14:09 <quicksilver> as
08:14:11 <quicksilver> do { a ; b}
08:14:13 <luqui> shubuntu, it's the $
08:14:14 <quicksilver> or simply
08:14:16 <quicksilver> do a
08:14:17 <quicksilver>    b
08:14:18 <luqui> it has lower precedence than ++
08:14:42 <Foloex> geezusfreeek: doesn't work
08:14:45 <shubuntu> oh so I should put it in parentheses
08:15:19 <geezusfreeek> Foloex: hpaste? i want to see what you're doing with proper indentation and everything
08:15:29 <geezusfreeek> i'll annotate it
08:15:32 <shubuntu> seems to be working let me test it
08:15:40 <quicksilver> Foloex: doesn't work tells us nothing :)
08:15:47 <Apocalisp> Where's a good explanation of the (-> a) monad?
08:15:53 <quicksilver> Foloex: apart from anything else we gave you a whole bunch of different ways of doign it :)
08:15:57 <Foloex> quicksilver: Syntax error in expression (unexpected symbol "aff")
08:16:29 <quicksilver> Foloex: need to see the code. Please hpaste.
08:16:34 <quicksilver> Apocalisp: http://www.haskell.org/all_about_monads/html/readermonad.html
08:16:35 <lambdabot> Title: The Reader monad
08:17:21 <Foloex> quicksilver: http://hpaste.org/7661
08:18:02 <shubuntu> putStr (showBoard [[Dark,Light,Vacant],[Dark,Light,Light]])
08:18:06 <quicksilver> Foloex: if you're just going to put it on separate lines
08:18:10 <quicksilver> Foloex: then you need the "do"
08:18:12 <schme2> Grr...
08:18:13 <Apocalisp> quicksilver: Am I really using Reader when I apply functions?
08:18:18 <quicksilver> Apocalisp: yes.
08:18:21 <shubuntu>   0 1 2
08:18:21 <Apocalisp> Nice!
08:18:21 <shubuntu> 0 X O .
08:18:21 <shubuntu> 1 X O O
08:18:26 <geezusfreeek> ooh, imperative programmer ;)
08:18:27 <quicksilver> Foloex: and the "return" on its own isn't meaningful.
08:18:30 <shubuntu> don't you just love it when things finally work
08:18:36 <shubuntu> lol
08:18:42 <schme2> This haskell book.. 5 chapters read and still not anything closely resembling a usable piece of software :(
08:18:44 <quicksilver> Foloex: but perhaps you want return ()
08:18:50 <Foloex> quicksilver: how do I use the Do ?
08:19:08 <quicksilver> whenever you want a bunch of statements on separate lines
08:19:12 <quicksilver> there must be a do
08:19:14 <geezusfreeek> Foloex: i annotated
08:19:15 <quicksilver> ... then do
08:19:27 <geezusfreeek> it may be wrong, actually
08:19:37 <geezusfreeek> i should have cleaned up the indentation and just done it the way i normally would have
08:19:54 <quicksilver> looks ok to me
08:20:06 <Foloex> geezusfreeek: thanks ^^
08:20:07 <geezusfreeek> it's just not the way i'm used to seeing it ;)
08:20:15 <geezusfreeek> Foloex: work?
08:20:18 <shubuntu> try reading "Haskell: The Craft of Functional Programming" by Simon Thompson - Pearson / Addison Wesley
08:20:19 <luqui> shubuntu, http://hpaste.org/7660#a1
08:20:26 <Foloex> geezusfreeek: checking ...
08:20:50 <schme2> shubuntu: I will check that out.
08:20:57 <Foloex> geezusfreeek, quicksilver: it works ! thanks
08:21:03 <geezusfreeek> Foloex: no prob
08:21:07 <shubuntu> luqui that looks nice
08:21:09 <shubuntu> thanks
08:21:12 <nomeata> gwern: hi. just got your message, sorry for the delay. no problem to add repos, just give me the urls (or send them by mail)
08:22:46 <schme2> Also I asked yesterdi but don't think I got a reply by anyone. I have been googlin' around for a haskell implementation for oVMS. Can't find anything. Does anyone know of one?
08:22:56 <shapr> @quote haskell
08:22:57 <lambdabot> jlouis says: Q: When does one know he has programmed too much Haskell? A: When he uses == and /= in everyday IRC chat or when he tries to fix a relationship by passing himself as a continuation
08:23:52 <geezusfreeek> Foloex: i just added another annotation with a version you might find nicer looking than those nested ifs
08:24:03 <geezusfreeek> Foloex: just fyi
08:24:19 <shapr> @quote hylo
08:24:19 <lambdabot> EvilTerran says: Hylo morphism batman!
08:24:21 <shapr> @quote hylo
08:24:21 <lambdabot> EvilTerran says: Hylo morphism batman!
08:24:22 <shapr> @quote hylo
08:24:22 <lambdabot> edwardk says: i just got bitten in the ass by the lack of a notion of commutative monad for a in a toy kind of memoizing hylomorphism that now has way too much 'ordering' baked into it
08:24:24 <shapr> huh
08:24:32 <shapr> Good morning #haskell!
08:24:46 <thetallguy> Good morning, shapr!
08:24:48 <dcoutts_> hia shapr
08:25:00 * geezusfreeek cracks up at EvilTerran's quote
08:25:01 <shapr> How's code treating everybody?
08:25:07 <dcoutts_> @yarr!
08:25:07 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
08:25:15 <dcoutts_> lambdabot: it's not that bad!
08:25:20 <dcoutts_> @botsnack
08:25:21 <lambdabot> :)
08:25:29 <shapr> @quote dcoutts
08:25:29 <lambdabot> dcoutts says: Of course Cabal-1.2 works perfectly well with all versions of GHC
08:25:33 * luqui cracks up at edwardk's quote.  in the alternate universe where he understands it.
08:25:37 <dcoutts_> hah hah hah
08:25:43 <dcoutts_> it's true!
08:25:55 <dcoutts_> I'll say the same for Cabal-1.4
08:26:09 <shubuntu> hehe one dumb question
08:26:14 <dcoutts_> (hmm, except for a bug with ghc-pkg-6.9)
08:26:19 <shubuntu> how do you run shell commands from inside of ghci?
08:26:22 <shubuntu> like clear
08:27:14 <pjdelport> shubuntu: :!
08:27:30 <geezusfreeek> :\
08:27:51 <nomeata> @tell gwern: hi. just got your message, sorry for the delay. no problem to add repos, just give me the urls (or send them by mail)
08:27:51 <lambdabot> Consider it noted.
08:28:04 <luqui> ^Z clear fg  :-p
08:28:12 <edwardk> luqui: i was trying to build a 'pure' memoizing hylomorphism. i since resorted to cheating and using Data.Supply-like hacks
08:28:20 <shubuntu> pjdelport many thanks
08:28:46 <edwardk> luqui: though you could also use Erwig's synchromorphism approach if you want to coz my cheesy hack is not very categorical =)
08:29:02 <geezusfreeek> pjdelport: heh, i thought that was a smiley
08:29:08 * luqui knows not category theory no hylosynchromorphisms
08:29:17 <luqui> s/no /nor /
08:29:34 * shapr hugs dcoutts_
08:29:39 <pjdelport> geezusfreeek: a one-toothed grimace?
08:29:54 <luqui> my favorite function:  (:[])
08:29:58 <geezusfreeek> no idea what i thought it was. it just looked like a smiley of some sort
08:30:04 <edwardk> luqui: a hylomorphism is pretty straight forward. you keep using a function of the form (a -> f a) to build up a tower of some structure of f's, then you use (f b -> b) repeatedly to tear it back down.
08:30:05 <shubuntu> luqui do you remember when internet chat was just beginning to grow, people would give help by recommending pressing Ctrl+Alt+Del
08:30:09 <shubuntu> lol
08:30:13 <geezusfreeek> luqui: i like conal's :-> operator
08:30:58 <chessguy> 'afternoon, #haskellers
08:31:04 <shapr> hiya chessguy !
08:31:08 <pjdelport> > (:[]) 8
08:31:09 <lambdabot>  [8]
08:31:12 <luqui> > let (:-) = (+) in (:-) 0 0
08:31:13 <lambdabot>   Not in scope: data constructor `:-'
08:31:14 <shubuntu> hello chessguy
08:31:16 <luqui> oh right
08:31:19 <pjdelport> i call it "monkey putting on sunglasses"
08:31:23 <dcoutts_> shapr: :-)
08:31:39 <geezusfreeek> heh
08:31:40 <chessguy> shubuntu, how's code?
08:31:51 * shapr boings cheerfully
08:31:52 <shubuntu> getting there slowly
08:31:56 <idnar> smilomorphism
08:31:58 <luqui> > (:[]) (8-b)
08:31:59 <conal> geezusfreeek: which :-> ?
08:31:59 <lambdabot>  [8 - b]
08:32:00 <shubuntu> working on my capture bits
08:32:02 <chessguy> @get-slap :)
08:32:02 <lambdabot> shapr!!
08:32:07 <shubuntu> thanks for asking
08:32:13 <luqui> it's a smiley-preserving function
08:32:26 <geezusfreeek> conal: well, i just remember seeing that sequence of symbols for an operator somewhere in your blog
08:33:04 <conal> geezusfreeek: i'm about to release a post with those symbols, and i forgot i had before.  hence my bafflement!
08:33:08 <shapr> @shapr shapr
08:33:09 * lambdabot moulds shapr into a delicous cookie, and places it in her oven
08:33:19 <geezusfreeek> conal: :)
08:33:19 <chessguy> haha
08:33:31 <edwardk> > [8-b]
08:33:32 <lambdabot>  [8 - b]
08:33:33 <chessguy> wow shapr, you and lambdabot are....close...
08:33:46 <conal> maybe geezusfreeek, like merlin, remembers the future
08:33:56 <shapr> Yeah, something about cookies..
08:34:04 <geezusfreeek> i just watched memento too many times
08:34:06 <conal> or anti-cookies
08:34:09 <chessguy> @shapr chessguy
08:34:09 * lambdabot hits chessguy with a hammer, so he breaks into a thousand pieces
08:34:15 * chessguy cries
08:34:20 <geezusfreeek> everything is backward
08:34:30 <chessguy> geezusfreeek, ooh, great movie
08:34:33 <conal> merlin anti-cookie gets deposited on my machine just before i visit a site
08:34:42 <luqui> geezusfreeek is an antiparticle
08:34:55 <luqui> in a feynman diagram
08:34:55 <geezusfreeek> i remember seeing an xkcd comic where merlin is watching memento and it makes perfect sense to him ;)
08:35:08 <geezusfreeek> luqui: i don't understand that at all :(
08:35:09 <luqui> "well, that was straightforward"
08:35:12 <geezusfreeek> i fail http://www.slurpy.org/?s=4bwkzi
08:35:13 <lambdabot> Title: Dog trainer fail - fail | Slurpy.org
08:35:47 <luqui> geezusfreeek, feynman diagram identifies that antiparticles are just regular particles traveling back in time
08:36:05 <idnar> @shapr idnar
08:36:05 * lambdabot hits idnar with a hammer, so he breaks into a thousand pieces
08:36:18 <geezusfreeek> luqui: i remember learning something about it in physics, but i apparently didn't learn it well enough
08:36:24 <shapr> Obviously, shapr is a word that means something violent.
08:36:24 <chessguy> @shapr lambdabot
08:36:25 * lambdabot pokes lambdabot in the eye
08:37:05 <shapr> luqui: Hey! I like your music!
08:37:16 <seanmce> can someone help me with line 92 of this hpaste. I think I need a liftIO? http://hpaste.org/7662?lines=true
08:37:42 <geezusfreeek> seanmce: what is the error?
08:37:43 <quicksilver> seanmce: don't think so.
08:37:47 <shapr> Ya know, hpaste buffer could really be larger.
08:37:50 <shapr> !paste
08:37:56 <quicksilver> seanmce: it's just the type for usage is wrong.
08:38:00 <shapr> um, where's hpaste?
08:38:07 * shapr sighs, connects to the server
08:38:07 <quicksilver> seanmce: usage doesn't really return anything, it should be IO () or IO a
08:38:10 <shapr> @seen hpaste
08:38:10 <lambdabot> I haven't seen hpaste.
08:38:19 <seanmce>  Couldn't match expected type `()' against inferred type `Options'
08:38:37 <quicksilver> seanmce: the error arises because all the other if/then branches have type IO () and that one has type IO Options.
08:39:00 <luqui> shapr, thank you
08:39:01 <seanmce> Thanks, IO a works.
08:39:11 <edwardk> shapr: lambdabot doesn't get ouch much, other than hitting google she doesn't get to surf the web.
08:39:21 <schme2> orbitz: oh you are here too! hah!
08:39:29 <orbitz> schme2: yes!
08:39:33 <orbitz> thanks for remembering me from yesterday
08:39:34 <orbitz> jackass
08:39:39 <shapr> lambdabot does the ouch to me!
08:39:47 <shapr> orbitz: ?
08:39:50 <geezusfreeek> @shapr shapr
08:39:50 * lambdabot places her fist firmly on shapr's jaw
08:40:10 <schme2> orbitz: sorry :(
08:40:13 <schme2> orbitz: I'm not good with names!
08:40:15 <Arnar> is there a way to define functions with pattern matching on arguments from the ghci prompt
08:40:18 <orbitz> schme2: we're broken up
08:40:18 <Arnar> ?
08:40:20 <shapr> orbitz: Hey, be nice, don't call people names!
08:40:25 <orbitz> schme2: you can pick your stuff up tonight
08:40:26 <schme2> orbitz: But I luvs you!
08:40:35 <orbitz> i'm sur eyou tell that ot all the people
08:40:51 <schme2> Well yeah. But you're special. ;)
08:40:56 <roconnor> schme2: try using an ascii heart
08:41:05 <schme2> <3 orbitz
08:41:16 <shapr> Still looks like testicles to me.
08:41:21 <schme2> 8-
08:41:23 <edwardk> arnar let foo = bar where bar (a:as) = ...; bar [] = ...
08:41:29 <shapr> um
08:41:30 <Arnar> edwardk: ah, thx
08:41:33 <shapr> anyway
08:41:43 <monochrom> haskell < 3
08:42:04 <edwardk> nah, #haskell = 432
08:42:19 <shapr> @users
08:42:19 <lambdabot> Maximum users seen in #haskell: 463, currently: 431 (93.1%), active: 29 (6.7%)
08:42:27 * shapr grins
08:42:44 <edwardk> apparently my definition was functional reactive
08:42:46 <shapr> edwardk: lunch?
08:43:04 <shapr> edwardk: I have a math question btw
08:43:15 <chessguy> schme2, ignore orbitz, he doesn't belong here anyway
08:43:31 <schme2> chessguy: He doesn't?
08:43:36 <shapr> He doesn't?
08:43:48 <schme2> chessguy: But really. Even though he might not belong here he belongs in my heart.
08:43:49 <Arnar> I asked a question earlier today.. and then went to lunch like a fool.. hope you don't mind me asking again:
08:43:50 <shapr> orbitz: Are you learning Haskell?
08:43:51 <schme2> haha
08:44:01 <orbitz> shapr: no, i just hang out in here
08:44:01 <twobitwork> for some reason, Database.HDBC.Sqlite3 is giving me SqlStrings when I would expect SqlInts
08:44:12 <Arnar> can I add some RTS options to runhaskell so that I get a location and/or backtrace of runtime exceptions?
08:44:17 <shapr> orbitz: I dunno.. being off-topic distract people from learning Haskell.
08:44:20 <edwardk> shapr: whats haskell?
08:44:29 <roconnor> *L*
08:44:29 <shapr> Like me for example :-/
08:44:29 <chessguy> @shapr edwardk
08:44:30 * lambdabot puts on her slapping gloves, and slaps edwardk
08:44:45 * shapr goes for food
08:44:58 <Arnar> twobitwork: sqlite does not have other types than strings
08:45:07 <twobitwork> Arnar: ohh...?
08:45:21 <Arnar> twobitwork: the type name are stored as "text comments" on the table columns..
08:45:31 <Arnar> twobitwork: but internally all columns are text
08:45:49 <twobitwork> I see... well, that's good to know
08:45:55 <Arnar> twobitwork: I've no idea if the haskell bindings do the "right" thing by looking at the table definitions and convert the strings to whatever is there
08:46:02 <twobitwork> not much of a problem, I was just surprised :)
08:46:12 <Arnar> sure :)
08:46:13 <twobitwork> Arnar: doesn't seem like it
08:46:42 <Arnar> twobitwork: it would be hard anyway.. as you can both write whatever gibberish as the column type - and you can always store a string in any column
08:46:55 <twobitwork> right
08:47:02 <dons> ?users
08:47:02 <lambdabot> Maximum users seen in #haskell: 463, currently: 430 (92.9%), active: 30 (7.0%)
08:47:11 <twobitwork> well... most of my data is strings anyways, so that actually works out
08:47:11 <Arnar> so.. no pointers on how to track origin of runtime exceptions?
08:48:09 <Arnar> twobitwork: yeah.. sqlite is brilliant. the python bindings support "custom" types.. you just supply it with functions to serialize them to strings and deserialize
08:48:22 <Arnar> twobitwork: very useful.. but strictly specific to the python sqlite module
08:48:46 <twobitwork> Arnar: wouldn't be hard to do the same in haskell, right?
08:48:56 <Arnar> twobitwork: I wouldn't think so.. no
08:49:13 <Arnar> twobitwork: you'd have to pass around some "registry" of the known types and their serializers/deserializers
08:49:22 <Arnar> in python it is stored in a module global
08:49:28 <twobitwork> right
08:49:46 <Foloex> how do I convert IO String to [Char] ?
08:50:02 <twobitwork> well... most of my queries are going to be fairly static minus some parameterization, so accessor functions could do the conversion no problem
08:50:04 <Arnar> Foloex: if it is inside a do block.. use <-
08:50:25 <twobitwork> :t ['a','b']
08:50:27 <lambdabot> [Char]
08:50:29 <Arnar> Foloex:    x <- getLine
08:50:33 <twobitwork> :t "ab"
08:50:35 <lambdabot> [Char]
08:50:41 <Foloex> :t getLine
08:50:42 <lambdabot> IO String
08:50:43 <Arnar> > "ab" == ['a','b']
08:50:44 <lambdabot>  True
08:51:10 <Foloex> :t readFile
08:51:11 <lambdabot> FilePath -> IO String
08:51:17 <Saizan> Arnar: there's a trick, you've to compile with profiling enabled (-prof -auto-all) and run with +RTS -xc
08:51:24 <Arnar> Foloex:    contents <- readFile "/etc/passwd"
08:51:35 <Arnar> Foloex: then contents will be a string for the rest of the do block
08:51:46 <Arnar> Saizan: I have to compile (I'm using runhaskell now)?
08:51:55 <Foloex> Arnar: a string ? not a IO String ?
08:52:21 <twobitwork> Foloex: the monad takes care of unwrapping the String from the IO
08:52:23 <Arnar> Foloex: no.. well, it is a little more complex.. but for all intents and purposes, you can think of "<-" instead of "=" as an unswrap operator
08:52:42 <Saizan> Arnar: ah, you could also load the code in ghci and use the debugger
08:52:49 <Arnar> Saizan: ah ok..
08:53:01 <twobitwork> Arnar: :trace would probably be helpful
08:53:04 <Arnar> Saizan: :set -fbreak-on-error  or sth. similar?
08:53:28 <Saizan> Arnar: yeah, i've never used it, but ghc's manual should have the answer
08:53:58 <Arnar> Saizan: yeah.. I remember using it, have an issue of the monad reader here on my desk that has a tutorial on the ghci debugger
08:54:41 <Arnar> Saizan: just thought it'd be an overkill as I just need to know where the exception is coming from.. was hoping there was just a simple +RTS -showtraceback or sth.
08:55:09 <twobitwork> yeah, I do wish ghc had tracebacking ability like python
08:57:21 <quicksilver> for technical reasons it turns out to be surprisingly complicated to produce useful tracebacks with ghc's compilation model.
08:57:29 <quicksilver> However it is possible, the ghci debugger shows how :)
08:57:39 <quicksilver> but it's harder than in C, which is why this feature took a while to appear.
08:57:55 <Arnar> quicksilver: are you referring to ":history" in the ghci debugger?
08:58:07 <Arnar> doesn't that rely on running the code with :trace?
08:58:23 <yrlnry_> In ghci, how can I add a binding to the current environment?
08:58:45 <Arnar> yrlnry_: let x = y
08:59:12 <yrlnry_> Thanks!
09:00:24 <Arnar> rats.. :set -fbreak-on-error doesn't seem to break inside other threads than the main thread
09:03:59 <Apocalisp> ?hoogle (Monad m) (a -> b) -> a -> m b
09:03:59 <lambdabot> hoogle: src/Hoogle/MatchType.hs:74:8-45: Non-exhaustive patterns in function asBound
09:03:59 <lambdabot>  
09:04:04 <Apocalisp> ?hoogle (Monad m) => (a -> b) -> a -> m b
09:04:05 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
09:04:05 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
09:04:05 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
09:04:29 <EvilTerran> ?type (return.)
09:04:30 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
09:04:52 <Apocalisp> Hoogle doesn't know about return?
09:05:06 <EvilTerran> it doesn't know about expressions, only defined values
09:05:12 <Deewiant> ?hoogle return
09:05:12 <lambdabot> Prelude.return :: Monad m => a -> m a
09:05:12 <lambdabot> Control.Monad.return :: Monad m => a -> m a
09:05:12 <lambdabot> Control.Monad.Instances.return :: Monad m => a -> m a
09:05:20 <EvilTerran> er, s/values/names/ - so it knows about return, but not about (return .)
09:05:29 <monochrom> @goohle return
09:05:29 <lambdabot> http://en.wikipedia.org/wiki/Return_on_investment
09:05:36 <monochrom> oh well
09:05:40 <Apocalisp> haha
09:05:45 <EvilTerran> you'd need some freaky combination of djinn and hoogle to get something like that
09:06:02 <Apocalisp> EvilTerran: Of course.
09:06:07 <EvilTerran> a djinn that understood monadic values, no less (which should be possible, i'd've thought...)
09:06:07 <Arnar> EvilTerran: how do you use djinn?
09:06:22 <quicksilver> @djinn (a,b) -> a
09:06:22 <lambdabot> f (a, _) = a
09:06:30 <EvilTerran> ?djinn (a -> Either b c) -> a -> Maybe c
09:06:30 <lambdabot> f a b =
09:06:30 <lambdabot>     case a b of
09:06:30 <lambdabot>     Left _ -> Nothing
09:06:30 <lambdabot>     Right c -> Just c
09:06:35 <lilac> @djinn Maybe a -> b -> Either a b
09:06:35 <lambdabot> f a b =
09:06:36 <lambdabot>     case a of
09:06:36 <lambdabot>     Nothing -> Right b
09:06:36 <lambdabot>     Just c -> Left c
09:06:43 <Arnar> ooh..
09:06:58 <Arnar> @djinn a -> a
09:06:58 <lambdabot> f a = a
09:07:07 <Apocalisp> @djinn  (a -> b) -> a -> Maybe b
09:07:07 <lambdabot> f a b = Just (a b)
09:07:15 <EvilTerran> but it doesn't do lists or typeclasses
09:07:16 <Arnar> is it doing lookups.. or some magical inference?
09:07:23 <EvilTerran> magical inference. hence the name.
09:07:42 <Arnar> @djinn a -> b
09:07:42 <lambdabot> -- f cannot be realized.
09:07:48 <pjdelport> Arnar: Curry-Howard magic
09:07:55 <Arnar> pjdelport: oh, nice
09:07:59 <Apocalisp> @djinn a -> b -> a -> b
09:07:59 <lambdabot> f _ a _ = a
09:08:06 <EvilTerran> it's basically a theorem prover under the hood, only equating types to theorems and expressions to proofs. Curry-Howard, as Arnar said.
09:08:26 <Arnar> pjdelport said it
09:08:34 <Apocalisp> yea, but you were thinking it
09:08:39 <Arnar> :)
09:08:41 <idnar> haha
09:09:14 <Arnar> @djinn (a,b,c) -> (b,c,a)
09:09:14 <lambdabot> f (a, b, c) = (b, c, a)
09:09:35 <Apocalisp> Does (return .) have a name?
09:09:40 <Arnar> @djinn (a -> b) -> a -> b
09:09:40 <lambdabot> f a = a
09:09:57 <idnar> @type (return .)
09:10:01 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
09:10:08 <idnar> @type liftM
09:10:10 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:10:21 <idnar> doh
09:10:26 <roconnor> @type (=<<)
09:10:26 <Arnar> @type >>=
09:10:29 <simony> why is there a difference between extracting a value from a record via its getter than via pattern matching?
09:10:31 <Arnar> right..
09:10:36 <idnar> oh, of course
09:10:37 <simony> (At least when using existential types)
09:10:39 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
09:10:41 <lambdabot> parse error on input `>>='
09:10:47 <idnar> oh, no, not that either
09:10:54 * idnar confuses himself
09:11:40 <simony> Example:   data MyTuple = forall a. (Show a) => MyTuple {myName :: a}       This is acceptable: doShowYs ((MyTuple y):ys) = show y ++ doShowYs ys    but this isn't:   doShowYs (y:ys) = show (myName y) ++ doShowYs ys
09:11:44 <lilac> @pl (return .)
09:11:45 <lambdabot> (return .)
09:11:46 <BMeph> ?ty ((.) . (=<<)   -- I like this; it's the Kleisli, before I'd heard of Kleislis
09:11:48 <lambdabot> parse error (possibly incorrect indentation)
09:11:51 <lilac> d'oh
09:11:55 <BMeph> ?ty ((.) . (=<<)
09:11:57 <lilac> @unpl (return .)
09:11:58 <lambdabot> parse error (possibly incorrect indentation)
09:11:59 <lambdabot> (\ a d -> return (a d))
09:12:00 <BMeph> ?ty ((.) . (=<<)  )
09:12:01 <simony> how is one acceptable and one not?
09:12:02 <lambdabot> forall a a1 (m :: * -> *) b. (Monad m) => (a1 -> m b) -> (a -> m a1) -> a -> m b
09:12:11 <roderyk> does cabal have something like Data-dir option; I found a data-files but I have a lot of graphic files - do I really need to keep track of them all individually in the cabal file?
09:13:36 <dcoutts_> roderyk: we were thinking of allowing wildcards, perhaps you'd like to add you comments on ticket http://hackage.haskell.org/trac/hackage/ticket/213
09:13:36 <BMeph> simony: How does the compiler know that the (y:ys) is a list of MyTuples, w/o a type signature? ;)
09:13:38 <lambdabot> Title: #213 (allow wildcards in data-files or extra-source-files?) - Hackage - Trac
09:14:24 <luqui> Apocalisp, it's the pure Kleisli arrow
09:14:33 <luqui> constructor
09:15:15 <BMeph> Okay, I get what you mean - the type inferrer is stopping at saying that (y:ys) is a list of something, and not inferring that it's a list of MyTuples, since you used myName on its elements on the RHS.
09:16:37 <simony> BMeph, I gave it the type signature
09:17:11 <simony> BMeph, its not that - and its even telling me "Try to use pattern matching instead" :) it says its not working because of "escaped type variables"
09:17:17 <simony> (Which I don't what those are)
09:18:39 <roderyk> dcoutts_: currently my prog does a getDirectoryContents to find all the graphics (I need to select one at random). So even if we allow globbing, I will still need to keep track of all the images in the source file since as far as I understand the only way to access the file later is via getDataFileName :: FilePath -> IO FilePath. Ideally I was thinking of cabal: Data-dir and haskell getDataDirName :: FilePath -> IO FilePath
09:18:50 <roderyk> I'm not sure how useful this is outside of my program's scope...
09:18:54 <pjdelport> simony: what would the type of myName be?
09:19:27 <dcoutts_> roderyk: there is also getDataDir
09:19:56 <simony> pjdelport, forall a. (Show a) => MyTuple -> a
09:19:59 <dcoutts_> roderyk: look at the dist/build/autogen/Paths_foo module
09:20:05 <BMeph> myName :: (exists a.)  MyTuple ->a
09:20:25 <BMeph> THAT's why. :)
09:20:51 <BMeph> MyTuple does not specify an a, so it's existential.
09:20:55 <dcoutts_> roderyk: if you have a real world case that could benefit from something like what is described in that ticket then please comment to say so, it helps us prioritise what features to add
09:21:36 <roderyk> dcoutts_: thanks for the getDataDir : )
09:21:48 <simony> BMeph, why can't I return an existential type?
09:22:07 <pjdelport> simony: that type signature means that the caller gets to choose the Show instance of a
09:22:18 <pjdelport> compare:
09:22:18 <pjdelport> :t read
09:22:21 <lambdabot> forall a. (Read a) => String -> a
09:23:49 <BMeph> simony: Because an existential type isn't specified. It exists, that's all you're saying. You're not saying which type it is, only THAT it is. :)
09:24:02 <simony> pjdelport, so how do I make the signature mean that the callee selects the type?
09:24:08 <pjdelport> simony: in other words, the result of myName isn't an arbitrary Show instance, it's only a (hidden) Show instance previously wrapped
09:24:50 <simony> pjdelport, how is it possible that a pattern-match CAN be used to extract the value, but there is no signature that matches a function that would do the same?
09:25:00 <Cale> simony: Just return a string.
09:25:11 <simony> Cale, this is an educational excercise :-)
09:25:22 <simony> Cale, Just trying to understand existential types better
09:25:38 <Apocalisp> ?type return
09:25:40 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
09:25:41 <Apocalisp> ?type (.)
09:25:42 <pjdelport> simony: when you pattern match, the type (Show instance) is bound in the body of the match
09:25:42 <Cale> To understand existential types, I think it's easiest to understand how to avoid them first.
09:25:43 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:25:46 <Apocalisp> ?type (return .)
09:25:48 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
09:25:49 <simony> how come this function cannot exist: extractMyTuple (MyTuple a) = a  ?
09:25:53 <Cale> (which is really how to implement them)
09:25:55 <pjdelport> simony: the body can't choose it
09:25:57 <roderyk> dcoutts_: I will comment as soon as I get a hackage account. But for what it's worth, I think restricting globbing to the final directory and not allowing recursion is a good balance. In my case, using this for graphics and extra-source-files, the directories are never deep and it's informative to make them explicit in the cabal file (even as a documentation of sorts)
09:26:09 <Cale> simony: Is MyTuple an existential constructor?
09:26:13 <dcoutts_> roderyk: you can login a guest
09:26:14 <simony> Cale, yes
09:26:17 <dcoutts_> a/as
09:26:19 <schme_> Ok. I have decided not to give up on haskell just yet. Yay.
09:26:25 <Cale> simony: what's the type of extractMyTuple?
09:26:27 <schme_> I'll give it another day :)
09:26:32 <simony> Cale, I don't know :-)
09:26:42 <Apocalisp> ?type ((.) return)
09:26:43 <Cale> Haskell doesn't have first-class existentials.
09:26:44 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
09:26:49 <BMeph> simony: This issue is mentioned in the GHC manual. If you hold on a bit, I'll find the reference for you; I was just looking at it a while ago.
09:27:04 <Cale> It would be something like  MyTupleType -> (exists a. Foo a => a)
09:27:09 <simony> BMeph, thanks
09:28:11 <Cale> simony: The whole point of existential types is to hide the implementation behind an interface and abstract over it.
09:28:23 <Arnar> which has higher precedence, . or application (f a)  ?
09:28:30 <pjdelport> Arnar: application
09:28:31 <nanjoutai> the latter
09:28:36 <Arnar> thx
09:28:43 <Arnar> does that trump anything?
09:28:59 <BMeph> simony: Check out 8.4.4.4 - Restrictions (to existential types), it pretty much tells you exactly why GHC doesn't like your example. :)
09:29:07 <nanjoutai> yes
09:29:16 <Cale> simony: In a sense, the existential constructor throws away or forgets the original type, and hence throws away the permissions to use the contained values apart from the bit of the interface specified by the typeclass
09:29:27 <simony> BMeph, link"?
09:29:30 <Cale> (or typeclasses, if there's more than one involved)
09:30:21 <pjdelport> simony: an example to think about: consider a list of MyTuple
09:30:33 <BMeph> simony: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#id403652
09:30:33 <lambdabot> Title: 8.4. Extensions to data types and type synonyms, http://tinyurl.com/2cmgjm
09:30:41 <pjdelport> simony: and then map myName mytuples
09:30:55 <Cale> It's possible that in the future someone will work out how to do type inference together with an acceptably small number of explicit type signatures for first-class existential types, and at that point, you could write your function :)
09:30:57 <BMeph> Arnar: "function application has precedence over every other operation."
09:30:57 <pcc1> if you give a list of required classes for a parameter to a data type, why do we still need to give that list of classes in the signature of a function that takes as a parameter a value of that type and uses one of the classes?
09:31:23 <ptolomy2> Hmm.. is it possible to have UArray work for any Storable, instead of only on the listed native types? Does it need to be a word-sized element?
09:31:24 <Arnar> BMeph: thanks.. nice to have peole to rtfm for me :)
09:31:28 <Cale> pcc1: The typeclass constraint in data declarations is stupid.
09:31:30 <BMeph> Arnar: This includes function application in the arguments of a function. ;)
09:31:50 <Arnar> BMeph: menaning that  a b c is (a (b c)) ?
09:32:00 <vixey> Arnar: no
09:32:04 <Arnar> no.. that doesn't make sens
09:32:04 <smarmy> Arnar: no
09:32:07 <Arnar> :)
09:32:09 <Cale> pcc1: *All* that it does is restrict the type of the data constructor.
09:32:12 <smarmy> the first a has precendence
09:32:19 <vixey> f x y z = (((f x) y) z)
09:32:21 <smarmy> and consumes b and c
09:32:25 <Arnar> right
09:32:28 <Arnar> of course
09:32:46 <vixey> a type like a -> b -> c -> d = a -> (b -> (c -> d))
09:32:47 <Arnar> sorry for the brainslip
09:33:08 <Cale> pcc1: It doesn't ensure that a dictionary for the involved classes is passed around with the data (for an example of how you'd implement the behaviour you're expecting)
09:33:09 <smarmy> so things like "map f xs" makes sense ;)
09:33:10 <Arnar> vixey: (->) is not associative?
09:33:17 <lilac> why are 'forall' types called existential rather than universal?
09:33:20 <vixey> no it's not
09:33:29 <vixey> so you kinda know a -> (b -> c) -> d is higher order
09:33:39 <Arnar> right..
09:33:45 <Cale> (->) is defined to associate to the right
09:33:47 <pjdelport> lilac: the wikibook has a bit discussing that
09:34:20 <BMeph> lilac: ...er, yeah, what pjdelport said.
09:34:36 <pjdelport> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Explaining_the_term_existential
09:34:37 <lambdabot> http://tinyurl.com/f9umb
09:35:03 <pcc1> Cale: thanks.  yes, that is stupid.  has there been any discussion of the neccessary constraints being "inferred" as it were?
09:35:05 <BMeph> Heh-heh, and Cale is campaigning to have $ associate to the left. I like it, actually. :)
09:35:41 <dozer> in the haskell latex presentation, is there a way to make data declarations look prety?
09:35:52 <Saizan> lilac: existential types are encoded with forall exploiting the equivalences wrt (->)
09:36:02 <ptolomy2> Are the types that can be put in UArray limited by Haskell or by GHC? (I realize that is a fuzzy question, since GHC has it's own flavor of haskell as it is)
09:36:38 <Cale> pcc1: GHC can already do the right thing if you use the GADT syntax
09:36:44 <pjdelport> lilac: short version is that data Foo = F (exists a. Show a => a) is equivalent to data Foo = forall a. Show a => F a
09:36:47 <BMeph> dozer: What, like with a WingDings font? ;)
09:36:57 <dozer> BMeph: lol
09:37:17 <Cale> pcc1: data Foo a where F :: (Show a) => a -> Foo a
09:37:19 <dozer> BMeph: not sure what I want, but the default ascii art is ugly
09:37:39 <pcc1> Cale: thanks
09:38:06 <lilac> pjdelport: ah, of course, there's an implicit 'not' in the type class
09:38:18 <Cale> pcc1: That'll store a dictionary for Show in with the data, so that functions that take values of type Foo a don't have to specify that a is an instance of Show.
09:38:53 <pjdelport> lilac: so the former is basically an existential constraint on the argument to F, and the latter a constraint on the result of F
09:39:03 <pjdelport> (which implies the existential constraint on the argument)
09:40:52 * Cale likes the GADT syntax anyway :)
09:41:38 <pcc1> hmm, syntax error. how do you turn on gadt?
09:42:05 <Cale> {-# LANGUAGE GADTs #-}
09:42:10 * Saizan fears GADTs because he doesn't know if they are encodable in lambda calculus
09:42:35 <Arnar> Saizan: what do you mean "encodable" ?
09:42:43 <Cale> Everything is encodable in lambda calculus in one way or another :)
09:42:47 <Philippa> Saizan: yes, of course they are. The question's what flavours of typed lambda calculus they're encodable in
09:43:02 <dozer> Cale: bold claim
09:43:03 <Saizan> Philippa: yeah, which?
09:43:04 <RayNbow> how about untyped LC? :p
09:43:04 <Arnar> Cale: yeah.. if not, I'll have to burn my computability theory books :)
09:43:13 <Cale> Arnar: exactly
09:43:18 <vixey> dozer: it's been proved universal ages ago
09:43:31 <dozer> vixey: for suitable values of 'everything'
09:43:38 <Arnar> dozer: no.. not really, it's called the Church-Turing thesis
09:43:58 <dozer> Arnar: which only applies to computable procedures, not 'everything'
09:44:10 <Saizan> well, i mean conserving the type information in that particular flavor of LC's typesystem
09:44:12 <Arnar> dozer: in our world.. computable is "everything"
09:44:25 <simony> Cale, what if I could have optional type arguments on the left side, such that if they are not given, "forall" is used on the right side, and if they are given, they bind the right side to a specific type.  Then when not giving them, its equivalent to existential types, but extractMyRecord would have a valid type:  MyTuple a -> a
09:44:26 <pcc1> "cannot parse LANGUAGE pragma" I have ghc 6.6 do I need a particular version?
09:44:34 <Arnar> dozer: haskell can't be more powerful
09:44:36 <dozer> Arnar: there are lots of interesting predicates that are also not computable
09:44:57 <pcc1> GADTs are mentioned in that version's ANNOUNCE
09:45:24 <Saizan> pcc1: -fglasgow-exts
09:45:31 <Cale> simony: uh, you can have type parameters...
09:45:41 <simony> Cale, I mean optional ones
09:45:46 <Saizan> pcc1: i mean instead of the LANGUAGE pragma use that option
09:45:50 <Cale> I don't see how that would work though.
09:45:55 <simony> Cale, such that the same record type can be existential or used normally
09:45:55 <pcc1> Saizan: I already have that enabled
09:46:16 <Saizan> pcc1: so gadts should already be enabled
09:46:19 <Cale> Suppose I have x :: MyTuple. Then what's the type of extractMyRecord x ?
09:46:55 <Cale> Is it just a type error? In that case, just define a new separate type with a parameter and use it separately. :)
09:47:03 <pcc1> they should, but I get "parse error on input `::'"
09:47:30 <Cale> pcc1: Maybe just use -fglasgow-exts
09:47:41 <pcc1> Cale: I have that enabled
09:47:44 <Cale> pcc1: hmm
09:47:54 <Cale> Oh, also, that trick doesn't work in 6.6
09:48:10 <Cale> There are GADTs, but the type inference for that case wasn't working yet.
09:48:36 <Cale> (The GADTs in 6.6 didn't really play very well with typeclasses)
09:49:07 <conal> is GADTs + typeclasses sorted out now?
09:49:13 <Cale> I think mostly...
09:49:15 <pjdelport> simony: the reason you can't have the type MyTuple a -> a is that MyTuple doesn't have (or expose, rather) the type variable
09:49:16 <pcc1> ok I'll see if I can upgrade to 6.8
09:49:29 <Cale> I haven't noticed anything strange, but I haven't used them extensively.
09:49:41 <Cale> 6.10 is coming out pretty soon too :)
09:49:50 <conal> wow -- what's new in 6.10?
09:49:52 <Cale> (at least, I hope :)
09:49:54 <pjdelport> simony: compare data MyTuple a = MyTuple {myName :: a} versus data MyTuple = forall a. (Show a) => MyTuple {myName :: a}
09:50:50 <pjdelport> simony: because the former exposes the type variable, you can say things like map myName ::[MyTuple a] -> [a]
09:51:07 <pjdelport> so whatever the a on the left is, the a on the right will be
09:51:43 <Arnar> if openFile in WriteMode that is already open, will the thread block for some time or will it throw an exception right away (on other words, need I protect it with an MVar)?
09:51:57 <pjdelport> simony:  but with an existential type, it's just map myName :: [MyTuple] -> [?]
09:52:12 <pjdelport> there is no a to match
09:52:54 <pjdelport> each individual MyTuple element has a different potential type, instead of the single type as before
09:53:26 <laz0r> hi #haskell, i just played around with the opengl examples, and i discovered that using my trackball, which is recognized by X as a 9-button mouse, causes errors in unmarshalMouseButton
09:53:50 <laz0r> apperently, any button with an id >5 is 'unexpected'
09:53:54 <roconnor> @tell dons @check \x -> fst x == snd x
09:53:55 <lambdabot> Consider it noted.
09:54:08 <laz0r> can i somehow fix this?
09:54:11 <simony> Cale, pjdelport: I think that with (exists) as Cale mentions it would be great, and that maybe it would be an improvement to also allow optionally specifying that extractMyRecord returns a type which is the same one that is inside the existential record, but its not that important an improvement..   Thanks for all the explanations!
09:56:20 <Cale> simony: In some sense, the whole point of existential types is to throw away the type so that you can never get it back
09:56:37 * ptolomy2 wonders idly what sort of "real program" the intellectually honest masses will accept as proof that Haskell can be speedy.
09:57:01 <quicksilver> laz0r: sounds like a weakness in GLUT (I'm not too surprised)
09:57:11 <quicksilver> laz0r: you'll probably want ot use a more capable input library like SDL.
09:57:49 <Cale> simony: It's rather like the encapsulation provided in object oriented languages.
09:58:07 <laz0r> quicksilver: mmh, ok, thanks, i'll check out HSDL i guess
09:58:09 <opqdonut> i somehow misread that as "oriental languages"
09:58:20 <pjdelport> simony: there's http://www.haskell.org/haskellwiki/Existential_type#Examples_from_the_Essential_Haskell_Compiler_project
09:58:22 <lambdabot> Title: Existential type - HaskellWiki, http://tinyurl.com/5qjo8m
09:59:29 <schme_> splat net
10:00:04 <simony> pjdelport, thanks
10:00:33 <chessguy> @check \x -> fst x == snd x
10:00:34 <lambdabot>  OK, passed 500 tests.
10:00:57 <conal> wow -- i wonder what the test cases were
10:01:09 <conal> even what the type of x was
10:01:21 <Saizan> () probably
10:01:22 <Feuerbach> conal: obviously, pairs
10:01:36 <chessguy> @check \x -> fst (x::(Int,Int)) == snd x
10:01:37 <vixey> @scheck \x -> fst x == snd x
10:01:37 <lambdabot>  Falsifiable, after 0 tests: (-1,1)
10:01:39 <lambdabot>   Completed 1 test(s) without failure.
10:01:41 <conal> Saizan: perhaps so: ((),()), but why?
10:01:52 <vixey> @scheck \x -> fst x :: () == snd x
10:01:53 <lambdabot>  Parse error at "==" (column 19)
10:02:02 <Saizan> conal: extended defaulting i think
10:02:10 <Botje> :t \x -> fst x == snd x
10:02:12 <lambdabot> forall b. (Eq b) => (b, b) -> Bool
10:02:24 <Saizan> > [] -- this gets printed because it defaults to [()]
10:02:25 <lambdabot>  []
10:02:49 <roconnor> the defaulting is extremely bad for quickcheck
10:03:27 <conal> wow -- the worst for qc
10:03:54 <conal> is that default part of the haskell standard?
10:04:07 <Saizan> no
10:04:28 <conal> oh, wow: ghci says '[] == []' evaluates to True, with no type annotations
10:04:47 <conal> is the extended default in ghci?
10:04:49 <oldsalt> hi all, i am having problems converting a string into a bytestring (yes, that can be a problem)
10:05:02 <oldsalt> i am typing     read "foo" :: ByteString
10:05:16 <Saizan> yes, i think it was mostly introduced to reduce type annotations at ghci's prompt
10:05:16 <oldsalt> in ghci and i will get an exception Prelude.read: no parse
10:05:41 <Saizan> oldsalt: use pack
10:05:47 <Saizan> ?type pack
10:05:49 <lambdabot> Not in scope: `pack'
10:05:59 <Saizan> ?type Data.ByteString.pack
10:06:01 <lambdabot> [Word8] -> Data.ByteString.Internal.ByteString
10:06:11 <Saizan> ?type Data.ByteString.Char8.pack
10:06:13 <lambdabot> String -> Data.ByteString.Internal.ByteString
10:06:27 <roconnor> conal: presumably [] defaults to [Integer] or [Int]
10:06:31 <roconnor> in ghci
10:06:48 <conal> roconnor: but not in @check ?
10:07:00 <roconnor> not in lambdabot
10:07:10 <conal> oh.  maybe change lambdabot.
10:07:10 <chessguy> @check undefined == undefined
10:07:12 <lambdabot>  Undefined
10:07:25 <chessguy> @check \x -> undefined == undefined
10:07:26 <lambdabot>  Undefined
10:08:00 <oldsalt> Saizan: thanks alot, that seems to work
10:10:51 <Saizan> Prelude> let x =  \v -> (v,show v)
10:10:51 <Saizan> Prelude> :t x
10:10:51 <Saizan> x :: () -> ((), String)
10:11:12 <Saizan> it defaults to Integer only with an Integral constraint, afaiu
10:11:42 <ehird> So
10:11:47 <ehird> Has anyone fixed fastcgi yet
10:11:48 <ehird> :-)
10:12:05 <oldsalt> now i get a typecheck error: expected Data.ByteString.Lazy.Internal.ByteString, inferred Data.ByteString.Internal.ByteString
10:12:44 <Saizan> oldsalt: use Data.ByteString.Lazy.Char8.pack
10:13:08 <Saizan> or well, decide if you want lazy or strict bytestrings and stick to that hierarchy
10:13:15 <oldsalt> Saizan: crazy stuff, thanks again
10:13:47 <oldsalt> i don't care too much about the laziness but the bytestring goes into another function that seems to be allergic to un-lazy bytestrings
10:14:02 <dv_> hm, say,
10:14:12 <dv_> how easy/hard is it to write a shared library with haskell?
10:14:24 <ehird> sclv: you awake? :)
10:14:29 <dv_> think of a xmms/audacious/etc. plugin for instance?
10:14:32 <dv_> -?
10:14:47 <Saizan> oldsalt: they are two distinct types, they can have the same name because they are defined in distinct modules
10:15:14 <ddarius> dv_: I have a small library for writing LADSPA plugins.
10:15:19 <oldsalt> ok, i see
10:16:11 <roconnor> Prelude> let x =  \v -> (v,show v)
10:16:12 <roconnor> Prelude> :t x
10:16:12 <roconnor> x :: Integer -> (Integer, String)
10:16:25 <roconnor> GHC Interactive, version 6.6.1, for Haskell 98.
10:16:38 <Saizan> roconnor: i'm using 6.8.2
10:16:49 <ehird> roconnor: lulz, type defaulting.
10:17:08 <roconnor> Saizan: that must make using quickCheck annoying.
10:17:15 <ehird> HAHAHAHAHA
10:17:15 <ehird> Prelude> let x = \v -> (v,show v)
10:17:15 <ehird> Prelude> :t x
10:17:15 <ehird> x :: () -> ((), String)
10:17:57 <opqdonut> that's defaulting for you
10:18:24 <ehird> opqdonut: indeed
10:18:24 <Saizan> roconnor: i don't use it much with such unconstrained types
10:19:36 <vixey> I thought check was meant to try different types
10:19:54 <Saizan> only different values
10:20:02 <dozer> mm, I can't find the tex that typesets ++
10:22:06 <gwern> @messages
10:22:06 <lambdabot> boegel said 8h 52m 55s ago: I tried applying the patch by saving the email containing the patch as raw text, and then running "darcs apply" on it... doesn't seem to work: darcs failed: Malformed
10:22:06 <lambdabot> patch bundle: '[de-haskell98' is not 'Context:'
10:22:06 <lambdabot> boegel said 8h 52m 41s ago: as for the website being down, I'm aware of that, server issues...
10:22:06 <lambdabot> boegel said 8h 14m 25s ago: webserver is back up, you should be able to reach my website again... it's possible it'll happen again in the near future, because the sysadmins are merging our main
10:22:07 <lambdabot> server to multiple different ones
10:22:09 <lambdabot> nomeata said 1h 54m 16s ago: hi. just got your message, sorry for the delay. no problem to add repos, just give me the urls (or send them by mail)
10:22:30 * gwern is irked. why can't I darcs get http://code.haskell.org/ChessLibrary ? I can get there in a web browser just fine!
10:22:30 <lambdabot> Title: Index of /ChessLibrary
10:23:15 <roconnor> gwern: is there a  http://code.haskell.org/ChessLibrary/_darcs ?
10:23:40 <gwern> roconnor: ....no, actually
10:24:01 <gwern> what the heck? who puts stuff up on code.haskell without a _darcs?
10:24:38 <roconnor> in particular is there a  http://code.haskell.org/ChessLibrary/_darcs/inventory
10:24:50 <roconnor> because that is the first thing darcs will try to get (I think)
10:25:12 <dons> ?yow!
10:25:12 <lambdabot> This is a NO-FRILLS flight -- hold th' CANADIAN BACON!!
10:25:18 <dons> let's change the world!
10:25:18 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
10:25:20 <dons> with monads!
10:25:20 <GavinMcG> getNums nums = do
10:25:20 <GavinMcG> 	putStrLn "Please enter a number (0 to quit): "
10:25:21 <GavinMcG> 	input <- getLine
10:25:21 <GavinMcG> 	let number = read input
10:25:21 <GavinMcG> 	if number == 0
10:25:21 <GavinMcG> 		then return (nums)
10:25:23 <GavinMcG> 		else
10:25:25 <GavinMcG> 			rest <- getNums nums
10:25:27 <GavinMcG> 			return (number : nums)
10:25:28 <dons> GavinMcG: you should use hpaste.org
10:25:29 <GavinMcG> sorry bout that
10:25:31 <roconnor> @hpaste
10:25:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:25:42 <GavinMcG> thanks!
10:25:56 <dons> roconnor: were you complaining about ghci's defaulting?
10:26:21 <roconnor> dons: Sorry, I just learned now that it is a ghc 6.8 bug
10:26:26 <dons> oh?
10:26:47 <roconnor> er
10:26:52 <roconnor>  a ghci 6.8  bug?
10:27:35 <roconnor> Prelude> let x = \v -> (v,show v)
10:27:35 <roconnor> Prelude> :t x
10:27:46 <roconnor> yeilds different answers in ghci 6.6 and ghci 6.8
10:27:51 <roconnor> yields
10:28:35 <roconnor> I claim 6.8 is broken, but it might be a bit hard to justify.
10:28:55 <roconnor> dons: is it at all possible to get different defaulting for @check?
10:29:14 <dons> it just uses extended defaulting
10:29:19 <dons> > [] -- same as this
10:29:21 <lambdabot>  []
10:29:27 <dons> but if its a trouble, use a type annotation
10:29:30 <roconnor> whatevet, that works fine in 6.6
10:30:07 <roconnor> dons: it trouble because quickcheck succeeds
10:30:15 <tromp> :t \v -> (v,show v)
10:30:17 <lambdabot> forall a. (Show a) => a -> (a, String)
10:30:17 <dons> yeah true enough
10:30:23 <roconnor> and everyone goes around thinking their broken code is tested
10:30:25 <dons> ask Cale to disable extended defaulting for the quickcheck module
10:30:37 <dons> this is what hpc is good for, fwiw
10:30:43 <ehird> @ping sclv
10:30:43 <lambdabot> pong
10:30:45 <roconnor> oh is Cale in charge of lambdabot nowadays?
10:30:54 <roconnor> @what hpc
10:30:54 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_Program_Coverage
10:30:57 <saml> lambdabot
10:31:09 <Cale> Mm... that's probably a good idea.
10:31:19 <roconnor> how does hpc help \x -> fst x == snd x ?
10:31:32 <Cale> uhh...
10:31:47 <Cale> Why can't I log into code? It's asking for a password.
10:31:59 <roconnor> damn you Debian. :)
10:32:27 <ehird> @hpx 2
10:32:28 <lambdabot> Maybe you meant: pl thx
10:32:30 <ehird> @thx
10:32:31 <lambdabot> you are welcome
10:32:34 <ehird> @thx lambdabot
10:32:34 <lambdabot> you are welcome
10:32:37 <ehird> @thx Cale
10:32:37 <lambdabot> you are welcome
10:33:05 <orbitz> in ghci, is there a way to see the contents of a module? lik ein ocmal i can do module M = List as a trick to see what List exports
10:33:10 <ddarius> Cale: You need to regenerate your ssl key
10:33:17 <roconnor> orbitz: :b Data.List
10:33:18 <Cale> ddarius: oh?
10:33:51 <orbitz> :( module 'Data.List' is not interpreted
10:34:06 <roconnor> orbitz: :b List ?
10:34:16 <Cale> I also forget who I should send the public key to.
10:34:44 <orbitz> same
10:34:55 <roconnor> um something strang is going on
10:35:12 <roconnor> 'cause that should work
10:35:21 <roconnor> orbitz: try on a fresh ghci
10:35:33 * shapr throws orbiting lambdas at orbitz 
10:35:51 <ddarius> Cale: I emailed the support at community.haskell.org, but I'm not sure if that is the right thing.
10:35:53 <Cale> orbitz: are you named after the exceptionally awful drink?
10:36:58 <orbitz> Cale: yes
10:36:59 <BMeph> roconnor: It doesn't work on my GHCi either. I am using Windows, though.
10:37:17 <orbitz> roconnor: same on a fresh run
10:37:47 <orbitz> Cale: there was a van parked outside my house for like a week or 2 when i was a youngin and i liked it os much i naem dmyself after it
10:37:50 <orbitz> an orbitz van*
10:38:10 <Cale> Wow, I don't think I've ever heard a good review of it. :)
10:38:31 <simony> most Haskell games/etc that I run get these hickups/short periodical delays   like 30-50 mili every second or so (subjective, not measured). Could this be the GC?
10:39:02 <roconnor> BMeph, orbitz: I don't get it, but I'm running Linux
10:39:12 <Cale> simony: You could possibly turn on the GC beeping feature to try to see
10:39:18 <ptolomy2> GHC profiling confuses me. I have a function that is basically "do { x <- getStateThing; return $! (Map.lookup v stateThing }".. profiler says 1/2 the time is spent in 'getStateThing', no time is spent in the lookup according to a manually inserted cost center. So, either '>>=' is really expensie here, or something is confusing.
10:39:29 <orbitz> roconnor: i'm on osx
10:39:36 <roconnor> orbitz: does :?  list a :browse command?
10:39:40 <Cale> simony: run the program with  +RTS -B
10:39:50 <ehird> Just to make this clear: Nobody here uses SCGI or FastCGI?
10:39:53 <ehird> This is a _crippling_ problme
10:39:55 <simony> Cale, thanks
10:39:56 <roconnor> orbitz: I guess try :m + Data.List
10:40:03 <roconnor> orbitz: and then :b Data.List
10:40:09 <orbitz> roconnor: works on freebsd though
10:40:24 <Cale> simony: It'll beep at the start of every major garbage collection
10:40:37 <BMeph> roconnor: Oh, CRAP! Thanks for reminding me!
10:41:23 <BMeph> GHCi always assumes ":b" is :break, not b rowse. The whole word works wonders. ;p
10:41:49 <orbitz> ahh :browse works
10:41:55 <orbitz> on osx
10:41:56 <orbitz> thank you
10:42:31 <simony> Cale, thanks, its not the GC
10:42:37 <simony> I wonder what it could be
10:43:00 <roconnor> oh
10:43:08 <roconnor> I don't have the new fancy debugger
10:43:13 <roconnor> I have no break
10:43:44 <ehird> :\
10:44:36 <GavinMcG> I'm using GHC 6.4.1 and going through YAHT. I'm doing the first exercise in section 3.8, which involves creating a list of numbers input by the user. When I try to compile the following code ( http://hpaste.org/7663 ) I get the error "Parse error in pattern" after the indent of line 5 ("if number == 0"). All indentation is 8-space tabs. I'm using TextWrangler. Any idea what's wrong?
10:44:36 <ehird> Lemmih: Hey you
10:44:46 <Lemmih> ehird: Hiya.
10:44:56 <ehird> Lemmih: Your fastcgi package is broken, and babies are crying.
10:45:09 <glguy> GavinMcG: add a "do" after the "else"
10:45:41 <GavinMcG> glguy: because getNums is an action?
10:45:52 <Lemmih> ehird: Excellent, my evil plans are on track then.
10:46:07 <glguy> GavinMcG: because you are using do-notation with the "<-" and multiple lines
10:46:08 <ehird> Lemmih: Specifically, runFastCGI &co are of type (CGI CGIResult -> IO ()). They should be of type ((MonadIO m) => CGIT m CGIResult -> m ()), like runCGI. Right now, I can't use a custom CGIT monad. This sucks, heavily.
10:46:21 <ehird> Lemmih: I tried to fix it, but with alloca&co. I'm not quite sure how.
10:46:26 <Cale> GavinMcG: yeah, you're missing a 'do', but I also recommend not allowing any tabs in your source files. It's best to have your editor automatically convert tabs to spaces (which is generally what most Haskell programmers will expect too)
10:46:40 <mwc> GavinMcG: indeed, that's good advice
10:46:45 <GavinMcG> glguy: thank you
10:46:55 <mwc> GavinMcG: it helps avoid somebody with different tab width settings from seeing a different indent structure
10:46:58 <Lemmih> ehird: I'll have a look.
10:47:02 <Cale> GavinMcG: The do-notation glues IO (and other monadic) actions together in sequence.
10:47:13 <GavinMcG> Cale: any suggestions for OS X editors which can do that automatically?
10:47:20 <gwern> does 'error' print to stderr or stdout?
10:47:31 <mwc> GavinMcG: your editor should have a prefence to "convert tabs to spaces" or the like
10:47:48 <GavinMcG> mwc: ok. Thanks, and you too Cale.
10:47:57 <ehird> gwern: Mu.
10:47:58 <Cale> GavinMcG: It's been a while since I used OS X, and I mostly used vim and emacs when I did, but I'd be surprised if TextMate couldn't do that.
10:48:01 <pjdelport> GavinMcG: specifically, <- is specific to do-syntax;  you can't use it outside
10:48:07 <ehird> Cale: textwrangler!=mate
10:48:24 <gwern> hm. seems so; 'main = error "foo" |less' doesn't show anything
10:48:25 <ehird> textwrangler = bbedit-lite[free version]
10:48:34 <Cale> Well, okay, textwrangler can certainly do it. I used that briefly as well.
10:48:40 <pjdelport> (other than list comprehensions, which also have <-)
10:48:45 <ehird> Cale: yeah
10:48:48 <ehird> but really he wants emacs
10:48:49 <ehird> ;)
10:48:55 <GavinMcG> :D
10:49:10 <ehird> GavinMcG: emacs can help you indent haskell! it's that awesome!
10:49:22 <ehird> * vixey has quit ("* I'm too lame to read BitchX.doc *")
10:49:22 <GavinMcG> eherd: I'll switch immediately!
10:49:23 <ehird> i agree
10:49:30 <ehird> GavinMcG: I'm not sure eherd is interested
10:49:43 <Cale> If gnome's gedit has that feature, I find it hard to believe that there exist nontrivial text editors which lack it.
10:49:46 <GavinMcG> sorry
10:50:22 <benignvulcan> Hello!  I'm interested in doing logical inferencing in Haskell.  I tried out LogicT last weekend and was horrified at its performance (12 seconds to generate 100 prime numbers).  Is this a reasonable place to ask about this?  Is there a more appropriate/specific place?
10:50:34 <Cale> 4.11 Using Spaces Instead of Tabs
10:50:34 <Cale> TextMate can use spaces instead of tab characters. This is done by clicking the âTab Sizeâ pop-up in the status bar and enabling Soft Tabs.
10:50:58 <Cale> benignvulcan: It's certainly a reasonable plac
10:50:58 <schme_> We solved the crossword puzzle!
10:50:59 <Cale> e*
10:51:11 <Cale> benignvulcan: What algorithm did you use?
10:51:19 <mwc> GavinMcG: there's also VIM which has a decent haskell mode. The choice between the two depends on if you prefer RSI or non-modal interfaces ;)
10:51:39 <Cale> benignvulcan: Certainly naive constraint solving isn't the best algorithm for generating primes by any measure.
10:51:59 <ehird> mwc: or automatic or manual
10:52:03 <ehird> haskell is hard enough ;)
10:52:14 <shachaf> mwc: Vim isn't modal. :-)
10:52:34 <opqdonut> shachaf: how come?
10:52:38 <mwc> shachaf: yes, it is. There are patches (Cream?) that make it nonmodal
10:52:44 <geezusfreeek> <3 emacs
10:52:46 <benignvulcan> Oh my goal isn't really to generate primes, but it was one of the examples to play with.  Is it ok to paste a dozen lines of code here?
10:52:55 <Cale> @paste
10:52:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:52:58 <tromp> >
10:53:02 <ddarius> mwc: emacs is for improving your guitar playing?
10:53:04 <gwern> @hpaste
10:53:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:53:06 <shachaf> Vim is command-based, and one of the commands is "insert text".
10:53:10 <mwc> ddarius: heh, that's good
10:53:22 * shachaf summons obk.
10:53:36 <opqdonut> shachaf: i'd say vim is _more_ modal than traditional vi-clones
10:53:42 * obk surfaces from the deep
10:53:46 * Cale invents a command-based editor which only has an 'insert single character' command :)
10:54:00 <schme_> my gawd are we talking text editors.
10:54:00 <mwc> shachaf: that's an interesting way to look at it... so you have a commands to "enter" various modes?
10:54:02 <opqdonut> as it's "insert text" is richer, closer to a real mode
10:54:02 <opqdonut> compared to a really stripped down vi where you can't really do much more than type
10:54:07 <schme_> real coders use cat
10:54:17 <geezusfreeek> it's modal. if it was purely command based then it wouldn't actually be inserting text into the text buffer in insert mode
10:54:23 <obk> mwc: There's no "mode". Just text parameter to the insert command :-)
10:54:29 <mwc> schme_: real coders cat /dev/random and manipulate the entropy
10:54:35 <benignvulcan> OK, I've pasted my code to http://hpaste.org/7665
10:54:52 <Apocalisp> ?hoogle ((a -> b) -> a -> m b) -> (a -> b) -> m a -> m b
10:54:52 <lambdabot> No matches, try a more general search
10:54:54 <obk> Of course, you can _make_ VIM to be modal... it has this abominable extension...
10:54:56 <mwc> obk: what about other modes which have distinct interface characteristics, say visual
10:55:16 * gwern sighs, and just invokes the butterfly: real coders...<insert xkcd link>
10:55:17 <obk> Visual is just a way to specify a parameter
10:55:21 <mwc> I agree taht the ability to do something like 5ihelloworld<esc> makes insert closer to a command
10:55:26 <obk> vim is really a functional language editor :-)
10:55:40 <geezusfreeek> mwc: oh yeah i didn't think of it like that
10:55:41 <mwc> obk: now that I like!
10:56:16 <obk> It is just that VI tutorials dn't describe it that way, which is why people find it so hard to learn
10:56:33 <obk> Imagine if someone tried to teach haskell pretending it is an imperative language :-)
10:57:10 <opqdonut> the thing i like about vi is that the ui is very "combinatorial"
10:57:21 <opqdonut> which is something i'd like to see in an emacsish editor
10:57:21 <schme_> mwc: hah! That's a good one :D
10:57:31 <opqdonut> which is why i'm coding my own :)
10:57:40 <Cale> benignvulcan: This clearly isn't meant to work with the LogicT on hackage :)
10:58:02 <schme_> Just use climacs :P
10:58:10 <obk> opqdonut: Exactly! This is the main reason I hate emacs.
10:58:41 <schme_> There is a good solution to the emacs vim problem. emacs for apps, vim run in emacs shell for editing.
10:58:44 <schme_> :)
10:58:53 <geezusfreeek> ew
10:58:58 <obk> schme_: Or use viper :-)
10:59:42 <schme_> obk: viper is a horrible pain in the arse. In a bad way too.
10:59:45 <benignvulcan> cale: That's probably true.  I wanted the `once` and `ifte` features, which I didn't think were available that way.
10:59:59 * obk finds it ironic that Emacs, written in a (somewhat) functional language, has a non-functional editing model, while vi, written in an imperative language (C), has a functional editing model :-)
11:00:00 <Cale> they're available
11:00:11 <obk> schme_: I know. I tried it and gave it up
11:00:13 <dons> did anyone else spot the interesting ghc patch regarding inlining of `seq` ?
11:00:20 <Cale> They're in the Control.Monad.Logic.Class module (which is reexported by Control.Monad.Logic)
11:00:29 <dons> let x = e in x `seq` ... x ...  is not robust enough
11:00:37 <dons> while let !x = e in .. x .. always works
11:00:38 <schme_> obk: I remember trying it and I couldn't get it completely disabled without restarting my emacsen. It was a bad day.
11:00:41 <schme_> lost mah uptime!
11:01:07 <dozer> what is the form of words for introducing Haskell in papers that aren't about Haskell?
11:01:22 <dozer> "developed in Haskell, a modern functional programming langauge with support for ..."
11:01:23 <dozer> ?
11:01:32 <obk> schme_: I used it more than 10 years ago. My main problem was that it didn't "play well" with anything else in Emacs, so there was not much point
11:01:38 <dons> dozer: something like that, and refer them to haskell.org for more info
11:01:39 <ehird> dozer: 'developed in Haskell, a modern Pony.'
11:01:54 <schme_> obk: Ugh. that sounds horrid, ya.   I just stick with the running vim in an emacs buffer (:
11:01:57 <benignvulcan> cale: I had somehow gotten the impression that it was missing features.
11:02:40 <obk> schme_: I don;t think vim as around at the time...
11:02:49 <schme_> oh
11:02:50 * obk switched to vim pretty much as soon as it came out
11:02:51 <schme_> in the before time.
11:03:07 <dozer> thx dons - is www.haskell.org The Reference?
11:03:10 <schme_> It's kinda funny really. I use vim to hack emacs code :)
11:03:18 <dons> dozer: yeah
11:03:24 <dons> or just http://haskell.org
11:03:26 <dozer> (since I'm just saying I used it, not discussing type theory or anything)
11:03:26 <lambdabot> Title: Haskell - HaskellWiki
11:03:28 * obk is ancient. Used to chase  mamuths and escape smilodons and all that :-)
11:03:55 <schme_> hahaha
11:04:02 <twobitwork> why does everything writen about haskell seem to have a very strong bias towards advanced mathematics?
11:04:02 <dons> smilodons rocks
11:04:17 <dons> twobitwork: it doesn't. go read my blog. no math in sight.
11:04:28 <dozer> dons: and in the acknowledgements we have "We would like to thank all those who provided help and support during the development of the Runcible rules engine, in particular the community in \texttt{\#haskell} on \url{irc.freenode.net}"
11:04:30 <dons> lots of shell scripting and systems hacking though
11:04:38 <shapr> dozer: Yay!
11:04:43 <shapr> #haskell rocks!
11:04:44 <twobitwork> I mean, the example in the wikibook about continuations jumps right into quadradics: http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
11:04:46 <ddarius> twobitwork: Indeed, like xmonad.
11:04:57 <dons> well, that's one article. not every article.
11:05:02 <Cale> benignvulcan: real: 0m0.023s, user: 0m0.011s, sys:0m0.004s
11:05:07 <schme_> my god! this music is the best evah!  *run run rasputin lover of the russian queen. that was a cat that was really gone. raw raw rasputin, russia's greatest love machine...*
11:05:09 <dons> Exists x . x in haskell and x has the math.
11:05:10 <Cale> benignvulcan: using the version on Hackage.
11:05:31 <benignvulcan> cale: thank god that's much more sane
11:05:35 <obk> schme_: didn't they also do "gengis Khan"?
11:05:36 <shapr> twobitwork: I failed bonehead calculus twice before passing with a D... but I can write Haskell just fine. Haskell really doesn't require much math knowledge.
11:05:40 <tantalum> I want do create a pattern type.... A pattern is either one "thing" or a list of patterns so I wrote:data Pattern p = Const p | List (Pattern p)
11:05:45 <schme_> obk: No idea. :)
11:05:54 <twobitwork> dons: sorry... I do realize that you and others have tried to escape that, I'm just making overblown generalizations out of frustration :P
11:06:01 * shapr hugs twobitwork 
11:06:07 <ddarius> shapr: Maybe you should have tried bonehead formal logic.
11:06:09 <benignvulcan> just gotta figure out how to install the hackage version (under ubuntu) now...
11:06:12 <dons> there are mathy guys around
11:06:12 <shapr> Maybe so!
11:06:18 <tantalum> but then I have a function repeatPattern :: Pattern -> Int -> Pattern
11:06:30 <twobitwork> shapr: no, haskell itself doesn't, but a lot of the learning material does... which is sort of self-defeating in terms of promoting haskell
11:06:31 <tantalum> I'll paste the code in pastebin
11:06:33 <shapr> twobitwork: On the other hand, if you ever have to work with edwardk, your brain will explode.
11:07:17 <Cale> benignvulcan: http://hpaste.org/7665#a1
11:07:30 <Cale> benignvulcan: Oh, also I'm using 6.8.2, I should say
11:07:43 <tantalum> http://pastebin.com/d4441e05a
11:07:47 <twobitwork> I just don't understand why the people who wrote the wikibooks article couldn't find something other than quadradics to use as an example.......
11:08:14 <shapr> hpaste may have blacklisted ssh keys, I might end up ripping out the whole server and reinstalling.
11:08:29 <monochrom> hehe
11:08:34 <benignvulcan> cale: I'm using ghc 6.6.1.  I would hope that doesn't make for orders-of-magnitude difference in speed for this code!
11:09:05 <ddarius> benignvulcan: 6.8 is quite a bit better at optimizations that 6.6 was...
11:09:08 <tantalum> but I get this error: http://pastebin.com/d625e6d3b that I dont understand
11:09:08 <Cale> benignvulcan: Ubuntu before hardy had only 6.6.1, right, which is rather old and may be tricky to install packages for.
11:09:13 <Apocalisp> So, (return .) is the pure kleisli arrow.  foo f = \f -> return . f   What's a better name for foo?
11:09:13 <shapr> twobitwork: I don't know, CPS has lots of other good examples. How about looking for CPS examples for scheme or other languages, reading their tutorials, and then applying that knowledge to Haskell?
11:09:25 <Cale> But yeah things got quite a lot faster with 6.8
11:09:29 <ddarius> Apocalisp: (return .)
11:09:51 <tantalum> Can some one please tell me what I'm doing wrong?
11:10:03 <Apocalisp> well, suppose I were making a fuction f = (return .)
11:10:11 <Apocalisp> function, even
11:10:30 <Philippa> tantalum: you're not filling in the p in Pattern p
11:10:34 <benignvulcan> cale: my ubuntu is 7.10/gutsy and I haven't had the gumption to upgrade yet
11:10:35 <Cale> tantalum: That says that Pattern isn't being applied to enough type parameters -- it's a type constructor and not a type itself
11:10:42 <Philippa> "Pattern" isn't a type, "Pattern p" is
11:10:55 <Cale> benignvulcan: I don't blame you. 8.04 was a bit of a rocky upgrade.
11:11:21 <Cale> benignvulcan: But yeah, I installed the generic linux binary for 6.8.2 by hand.
11:11:35 <Cale> (when I was using 7.10)
11:11:35 <monochrom> why do people think that quadratic is hard? or obscure?
11:11:41 <tantalum> ok that I understand "Pattern Bool" is a type
11:12:01 <tantalum> but I still dont understand the error
11:12:04 <Philippa> monochrom: it's a common point in algebra for people's brains to explode on account of being non-linear
11:12:22 <ddarius> Philippa: ...
11:12:23 <GavinMcG> I'm trying to take a list of numbers [k1, k2, k3, ... ,kn] and display on separate lines "The factorial of <k> is <k!>". What's wrong with this code? ( http://hpaste.org/7666 )
11:12:55 <benignvulcan> cale: which do you think would be easier: installing ghc 6.8.2 + hackage logict or just the hackage logict ?
11:13:02 <monochrom> Perhaps, but there are many similar points throughout highschool education.
11:13:37 <monochrom> The whole point of education is brain explosion.
11:13:39 <Philippa> ddarius: yeah, I know. It makes my head hurt just thinking down to that level etc etc
11:13:49 <benignvulcan> cale: (and do I dare ask why the performance of the original/naive LogicT library was so bad?)
11:13:53 <Cale> If you can't understand the quadratic formula, you probably should not be programming.
11:14:09 <Philippa> monochrom: it's also an example that a large number of people never have any use for at all later on, whereas working with linear stuff does come up
11:14:10 <Cale> benignvulcan: I really don't know :)
11:14:29 <Cale> benignvulcan: Installing 6.8.2 has lots of side benefits. It's what I'd do.
11:14:47 <Cale> benignvulcan: But you might try just installing the LogicT package yourself.
11:15:10 <Cale> Um, I can't remember if 6.8.2 comes with cabal-install or not, but that's also a good idea.
11:15:12 <monochrom> Yes, but there are still many points throughout highschool education where both brain explodes and you "never use" it afterwards.
11:15:24 <shachaf> GavinMcG: You want mapM (mapM_, actually).
11:15:24 <dcoutts> Cale: it doesn't
11:15:28 <ddarius> Philippa: No, my point is I don't see most people having no trouble with high school linear algebraic equations and then suddenly having a massive difficulty with quadratics because they are non-linear.  Usually you have to be quite a bit further along before the distinction between linear and non-linear means much.
11:15:38 <GavinMcG> shachaf: what is that?
11:15:40 <monochrom> There are such points in history classes, science classes, art classes, essay classes, English classes...
11:15:51 <shachaf> GavinMcG: mapM_ f is sequence . map f.
11:16:13 <Philippa> ddarius: I'm not talking about people who had no trouble with linear
11:16:14 <shachaf> @ty sequence
11:16:18 <benignvulcan> cale: thing is I don't have much time right at the moment, and no bandwidth until Monday., so since I've never done either before, I fear I'll not have a critical component when I go to install/configure all this tonight.
11:16:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:16:26 <shachaf> @ty map print
11:16:28 <lambdabot> forall a. (Show a) => [a] -> [IO ()]
11:16:29 <shachaf> @ty mapM_ print
11:16:31 <lambdabot> forall a. (Show a) => [a] -> IO ()
11:16:44 <Cale> benignvulcan: ah, okay, then just try the logict package on its own first :)
11:16:50 <Philippa> rather, I'm talking about people who just about got the concept and had a lot of trouble in practice but could just about figure it out /from/ the concept. At which point if you don't memorise at least one of the techniques you're kinda screwed with quadratics
11:16:55 <benignvulcan> cale: oh well.  I suppose I'm not really in such a rush if I know it's at least feasible to use logict
11:16:56 <spainish> f(x)=x^2 is not linear because    f(a*x) != a*f(x)    (a*x)^2 = a^2*x^2 != a*x^2
11:18:00 <spainish> and same for f(a+b) != f(a) + f(b)
11:18:24 <monochrom> Anyway, let's say I agree it's hard and obscure. No matter. Suppose a programming tutorial uses the quadratic formula. Obscure and useless as it is, the reader could easily just treat it as "here is some random formula pulled out of thin air to demonstrate how to turn formulas into code". Very little prerequisite needed. What's so wrong with that?
11:18:31 <ddarius> Philippa: The concept that is usually trying to be taught (from my experience) is one that would apply more or less equally well to quadratics, albeit, in general you will need to know or essentially derive the quadratic equation.
11:19:39 <Philippa> right. If you can't memorise it and you're a little too dopey to derive it, that's an "I just can't do it!" point
11:20:40 <monochrom> I can see an objection to what I said being: why not pick a useful formula rather than a useless one.
11:21:15 <Philippa> using stats formulae'd probably pick up at least some people
11:21:17 <ddarius> Philippa: Usually there are two cases: 1) the examples are chosen to doable without the quadratic equation, or 2) memorization of the quadratic equation is the "didactic" goal.
11:21:27 <geezusfreeek> what would be the recommended way to use alex on a buffered io stream? write my own wrapper instead of using a %wrapper declaration?
11:21:46 <monochrom> My answer: "useful" varies too much with reader. And although there is some common ground among all of us, it's so bloody lowest-common-denominator that it's too dumb to worth coding for.
11:21:53 <ddarius> Philippa: I use the quadratic equation way more than any stats equation.  I often use it when doing statistical things.
11:22:07 <monochrom> It's so dumb, you can't use it to exemplify any advanced programming technique.
11:23:01 <Philippa> ddarius: MMV, I barely touch quadratics whereas I at least use something as basic as the mean formula pretty regularly
11:23:42 <saml> when do I use RankNTypes exntension?
11:23:50 <ddarius> I may use arithmetic means often, but usually it's not something you have to "memorize"
11:24:24 <saml> can I say if I want to do data Foo = Foo { x :: (Monad m) => A -> m B }   do I need RankNTypes?
11:24:28 <Philippa> not in the same form, no
11:25:39 <Cale> The quadratic formula isn't by any means useless. Ever write a raytracer? :)
11:25:40 <Philippa> saml: no, that's rank-1 - it just uses 'existential' datatypes
11:26:04 <esteth_> Something that i don't really understand about haskell is that how can we call it "pure" when we can have side effects?
11:26:13 <mrd> existential types are rank-2
11:26:19 <monochrom> I wrote a raytracer to render a bunch of cubes and planes. The quadratic formula was utterly useless. :)
11:26:40 <geezusfreeek> esteth_: haskell itself is side-effect free... when you run a haskell program, it's output is actually a lazy IO action, which just happens to be executed by the runtime
11:26:42 <monochrom> The if-then-else construct was way more useful :)
11:26:43 <mrd> and you'd need a forall in there
11:26:44 <Philippa> mrd: not in the sense of requiring a rank-2 extension, they're no
11:26:46 <Philippa> *not
11:26:46 <Cale> Or any program which needs to do a small amount of plane geometry, for example, many games, will most likely require the quadratic formula.
11:26:55 <Philippa> also, no - only the encoding of them in terms of universal types is
11:27:02 <ddarius> monochrom: It was useless in the implicit surface one I wrote (which used Newton-Raphson iteration)
11:27:19 <monochrom> Pong did not use the quadratic formula. :)
11:27:24 <ddarius> Cale: Or physics simulation.
11:27:25 <geezusfreeek> esteth_: essentially, a haskell program is an expression which reduces to an imperative program
11:27:27 <Cale> Sure.
11:27:46 <saml> I want to store this in a record: (MonadEval m, E.MonadError Err m, T.MonadIO m, MonadPos m) => Val -> m Val
11:27:46 <monochrom> Don't worry, Cale, I'm just teasing you. I mean, Pong?! :)
11:27:49 <Cale> Collision detection for accelerating objects, for instance  :)
11:27:55 <Philippa> Cale: you're actually demonstrating the point for a lot of people though
11:28:01 <Cale> Huh?
11:28:01 <Philippa> I'm not saying these aren't good or interesting applications
11:28:05 <saml> RankNTypes works fine. but i'm not sure why
11:28:06 <Philippa> but they're ones most people don't actually care about
11:28:11 <geezusfreeek> esteth_: it is in that sense that haskell is so high-level. you are basically metaprogramming you effectful code
11:28:23 <Cale> Really?
11:28:25 <esteth_> geezusfreeek: Ahh, ok
11:28:34 <Cale> Anything simpler, and I'd probably stop caring about it :)
11:28:34 <idnar> hardly anyone writes raytracers, or their own collision detection code
11:28:45 <Philippa> Cale: people in here aren't "most people", almost by definition
11:29:10 <idnar> I mean, there are already five hundred implementations of those things, you might as well just pick one of those and get one with writing your Half-Life killer ;)
11:29:19 <monochrom> Newton-Raphson may more reliable than and not too slower than quadratic formula.
11:29:59 <dozer> I seem to be getting sucked into a stats job
11:30:16 <dozer> so have started thinking about how to do a type-safe DSL for stats
11:30:21 <ehird> Lemmih: Any news on fastcgi?
11:30:33 <Cale> monochrom: You might still want to know about the discriminant though.
11:30:34 <dozer> that knows that if you divide two probabilities, you get odds, and so on
11:30:37 <geezusfreeek> ehird: what is broken about fastcgi?
11:30:45 <ehird> geezusfreeek: this-
11:30:53 <Cale> And if you can understand Newton-Raphson, you can *certainly* understand the quadratic formula :)
11:30:54 <ehird> runCGI :: (MonadIO m) => CGIT m () -> m ()
11:31:04 <ehird> runFastCGI :: CGI CGIResult -> IO ()
11:31:05 <ehird> err
11:31:07 <dozer> and can flip things according to bayes law
11:31:09 <ehird> runCGI :: (MonadIO m) => CGIT m CGIResult -> m ()
11:31:10 <ehird> but yeah
11:31:12 <ehird> CGI = CGIT IO
11:31:21 <ehird> so with cgi, you can use a custom CGIT monad
11:31:30 <ehird> with fastcgi, you can't. only plain-jane-quite-boring-and-annoying CGI.
11:31:36 <ehird> it's a very bad flaw
11:31:37 <geezusfreeek> oh!
11:31:37 <dozer> and ultimately evaluate expressions to simulation, solving, mcmc, frequentist vs bayesian models, ..
11:31:53 <geezusfreeek> i had noticed that, but forgotten
11:32:11 * geezusfreeek is not using fastcgi at the moment
11:33:44 <simony> ListT, Monad's class, and other stuff is known to be "broken" in the stdlib. Does anyone keep a "correct" backwards incompatible stdlib around?
11:33:50 <simony> (Sort of a Haskell 3k)
11:34:22 <Cale> In fact, ListT isn't even part of the standard library
11:34:27 <simony> for people who start Haskell from scratch and don't mind backwards compatibility (just researching or toying around) it could be nice not to pay the price for backwards compatibility
11:34:53 <Cale> It's part of the mtl... libraries@ maintains that, and I'm really not sure why nobody's bothered to remove and/or replace it.
11:35:03 <ehird> geezusfreeek: what are you using?
11:35:11 <Cale> There are mtl-replacement type libraries.
11:35:15 <simony> Cale, sounds to me like it would take 5 minutes for you to do it? :-)
11:35:20 <geezusfreeek> ehird: well, i'm actually thinking of writing my own http server
11:35:27 <ehird> geezusfreeek: that's unhelpful for me
11:35:28 <ehird> :)
11:35:35 <geezusfreeek> sry
11:36:17 <Cale> Basically, it should just be removed. If you wanted to include something useful in its place, I recommend LogicT from the logict package on Hackage.
11:36:42 <simony> Cale, but if list is a monad, wouldn't it make sense to have a corresponding monad transformer?
11:37:01 <Cale> There is no corresponding monad transformer.
11:37:02 <shapr> Why don't we have a #haskell standard library?
11:37:18 <Cale> Well, hmm
11:37:23 <Cale> That's a slight lie :)
11:37:59 <Cale> The obvious thing doesn't work -- anything involving lists directly will probably be wrong.
11:38:36 <Cale> But you can have nondeterminism monad transformers which are effectively isomorphic to the list monad when applied to the Identity monad.
11:38:53 <Cale> Not quite isomorphic, but observationally so.
11:39:29 <Cale> hmm, I suppose you could say isomorphic, yeah
11:40:09 <benignvulcan> cale: OK, I munged the LogicT package onto my system and I got a time of 0.304s now!  Really makes me wonder what the difference is.  Thank you VERY much!
11:40:21 <Cale> benignvulcan: no problem :)
11:41:02 <Cale> newtype LogicT m a =
11:41:02 <Cale>     LogicT { unLogicT :: forall ans. SK (m ans) a -> FK (m ans) -> m ans }
11:41:15 <Cale> It uses the success/failure continuation implementation
11:41:47 <Cale> Oh, you were using SR?
11:42:53 <Maddas> @yow
11:42:54 <lambdabot> Everywhere I look I see NEGATIVITY and ASPHALT ...
11:43:11 <Maddas> I just happened to wonder, did anybody work on Conjure since 2006?
11:44:10 <Cale> benignvulcan: The SR implementation was of primarily theoretical interest.
11:46:54 <Cale> benignvulcan: You probably would have wanted to import the SFK1 or SFKT module.
11:47:35 <Cale> (Looking at the Oleg et.al. code)
11:49:31 * Apocalisp imports the STFU module
11:49:58 <dmwit> Cale: I thought there was a ListT monad transformer, but that it only worked on commutative monads or something like that.
11:50:58 <benignvulcan> cale: I tried all the variations; the fastest i could get was 12 second
11:51:47 <Cale> dmwit: yeah, it's not really a monad transformer
11:52:26 * dmwit considers
11:52:30 <Cale> dmwit: I'm not saying it doesn't exist. It's just broken and should be removed.
11:52:36 <dmwit> Yeah, I guess there's not so many interesting commutative monads.
11:52:51 <Cale> Yeah, at least in functional programming.
11:52:58 <dmwit> There's basically the container monads and that's all I can think of.
11:53:14 <Cale> The container monads aren't usually commutative even.
11:53:19 <Cale> The list monad isn't commutative.
11:53:24 <Cale> The set monad would be
11:53:30 <dmwit> Well... up to ordering it is, right?
11:53:36 <Cale> up to ordering, right
11:53:57 <Cale> (which is why the set monad would be commutative, but of course it has the problem of not being an instance of Monad)
11:54:03 <dmwit> right =)
11:54:38 <saml> i can't build my project using cabal because it says parsec is hidden
11:54:40 <Cale> The identity monad, the reader monad, and the writer monad using a commutative monoid are the three main examples.
11:54:47 <saml> but using ghc, i can compile it manually
11:55:00 <dcoutts> saml: build-depends: parsec
11:57:12 <Cale> There are other examples from mathematics, like the completion monad on metric spaces. (Though it's a boring example of a monad, since join is an isomorphism.)
11:57:23 <edwardk> cale: you can also construct a 'memoizing' monad that just has access to a memo table of values and a function to compute them with and which holds onto the memo table.
11:58:04 <edwardk> then the order instructions get issued to the memo table doesn't matter, so it commutes
11:58:28 <saml> dcoutts thanks. I had to use base, parsec, containers, pretty, mtl, template-haskell, directory
11:58:30 <Cale> Isn't that effectively a reader monad?
11:58:58 <dcoutts> saml: yep, the point is to make packages portable by declaring exactly what their dependencies are
11:59:10 <edwardk> it can probably be implemented that way, i just wasn't able to figure it out, I write to the memo table in my current implementation.
11:59:16 <Heffalump> Cale: only if you construct the entire table up front (but with unevaluated results)
11:59:38 <Heffalump> that's not suitable e.g. for infinite domain functions
11:59:45 <edwardk> when you have something too large to represent polynomially i think the reader is insufficient
11:59:45 <edwardk> yeah
12:00:14 <Cale> hmm, okay
12:00:48 <Heffalump> it's also not suitable if you need expiry
12:00:51 <saml> can I copy some files over the dist output directory for Cabal?
12:01:32 <dcoutts> saml: like what? and why?
12:01:32 <edwardk> i wanted it for a memoizing hylomorphism, so that you could recall previously constructed seeds and just plug, which then gives the benefit of allowing circular constructions to be built with sharing given common seeds
12:01:51 <saml> my interpreter needs stdlib.lsp file to run
12:01:57 <Cale> Yeah, I was just thinking that probably the problem of large/infinite domain functions could be solved with a smarter choice of memo table datastructure, but that won't get you expiry.
12:02:29 <roconnor> @check \x -> fst x == snd x
12:02:34 <lambdabot>  OK, passed 500 tests.
12:02:35 <Cale> It would be interesting to have more primitives in Haskell's pure language for manipulating evaluation, given that we already have seq
12:02:41 <ehird> <Cale> (which is why the set monad would be commutative, but of course it has the problem of not being an instance of Monad)
12:02:46 <ehird> can you write a set monad?
12:02:48 <saml> so, in dist/build/projname, I would like to have proj.exe and stdlib.lisp . maybe i'm not approaching this properly
12:02:54 <Heffalump> Cale: I can imagine that you could do something nested if the data structure was infinite because of nesting, but not if it was say Integer (short of looking at the representation of the Integer), I think
12:02:55 <dcoutts> saml: sure, that doesn't mean you need to copy anything into dist/ manually
12:03:02 <Cale> ehird: You can, but the Ord dependency means you can't make it an instance of Monad.
12:03:21 <ehird> Cale: :<
12:03:29 <dcoutts> saml: so you just run dist/build/projname/proj.exe and give it stdlib.lisp as input
12:03:36 <benignvulcan> cale: A likely simple follow-up question: Should I care that bagofN disappeared in the hackage version of LogicT?  Seems I might want it -- t's sure useful in Prolog.
12:03:40 <ehird> Cale: Haskell' should let you do it, somehow,
12:03:42 <Cale> ehird: Technically, it's not a monad on the category of Haskell types, but rather on a subcategory
12:04:06 <Heffalump> ehird: it won't
12:04:11 <Cale> benignvulcan: It's implementable in terms of the other stuff which is provided.
12:04:16 <ehird> Heffalump: BOYCOTT HASKELL'
12:04:23 <saml> dcoutts yup. i would just document that users should run it like that
12:04:26 <Cale> benignvulcan: and the common case is provided by observeMany(T)
12:04:27 <Heffalump> there's quite a lot of restricted monad solutions out there though
12:04:35 <edwardk> ehird: you can do it now with a trick http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros but its not a haskell monad
12:04:35 <lambdabot> Title: How to make Data.Set a monad, http://tinyurl.com/22rhsc
12:04:53 <dcoutts> saml: users should build and install your program
12:04:56 <edwardk> and restricted monads have their own problems, because 90% of the monad combinators can't be written for them in general
12:04:58 <Cale> ehird: It's a very hard problem which looks easy until you actually try to attack it.
12:05:04 <Heffalump> there's also rmonad on Hackage (which I wrote)
12:05:11 <dcoutts> saml: not run it from the build tree, only you as a developer might want to do that
12:05:26 <dcoutts> saml: cabal provides a way to install data files and find them at runtime
12:05:26 <Heffalump> it's quite nice because it's not an MPTC (it uses an associated datatype as suggested by someone on haskell-cafe)
12:05:37 <esteth_> does liftM take a function from a -> b and use it on values inside a monad?
12:05:52 <Heffalump> ISTR all the standard monad combinators were fine, too
12:06:05 <dmwit> esteth_: Yes, exactnly.
12:06:06 <edwardk> heff: hrmm, i'll have to take a look.
12:06:26 <Heffalump> I plan to put the mtl into it too but haven't yet.
12:06:40 <esteth_> dmwit: Thanks, seems like i might be getting close to understanding all this now :)
12:06:47 <Cale> edwardk: Heh, I was surprised when oleg posted that Monad1 solution, since I'd come up with it well before that, but considered it too stupid a solution to consider actually using.
12:07:32 <benignvulcan> cale: OK, I would have guessed it could be done.
12:07:39 <Heffalump> the split classes are really horrid
12:07:40 <edwardk> Heffalump: i'll have to see how it compares to my version and probably dump mine ;)
12:07:53 <benignvulcan> This has been great!  I should get out more.  Can you tell I'm a geek?
12:08:24 <Heffalump> (clever idea, but really painful in practice)
12:08:28 <ehird> <benignvulcan> This has been great!  I should get out more.  Can you tell I'm a geek?
12:08:29 <Cale> benignvulcan: #haskell is definitely a good place to hang out when using/learning Haskell :)
12:08:32 <ehird> this is #haskell
12:08:35 <ehird> do not say such things!
12:08:38 <Heffalump> edwardk: is your one online somewhere?
12:09:16 <Heffalump> oh, rmonad also has a general embedding from restricted monads into normal monads (at the cost of wrapping/unwrapping)
12:09:24 <edwardk> heff: i don't think so, i posted up stuff for parameterized monads a couple of ways and indexed monads in the category-extras library
12:09:43 <edwardk> but i didn't roll in the restricted stuff i have lying around because i kinda hated how ugly all the standard combinators got
12:10:02 <Heffalump> yeah. I just liked this solution enough that it seemed worth trying to standardise it.
12:10:05 <saml> dcoutts: which project property is responsible for including some files into $PREFIX/bin directory upon install?
12:10:28 <edwardk> i'm waiting for other people to have access to class associated types so i can move more of my category-theory stuff into category-extras
12:10:45 <dcoutts> saml: it only installs executables into $bindir, data files go in the $datadir
12:10:57 <Heffalump> associated datatypes, or type synonyms?
12:10:58 <edwardk> i'm currently thinking about cabalizing it in a fashion that would allow it to build both ways, and only give you all the interesting classes when used with 6.9+
12:10:58 <saml> maybe i'll modify the interpreter to look at $HOME/.proj directory for required files
12:11:04 <edwardk> type synonyms
12:11:13 <tieTYT> haskell compiles all code first.  That way if I have a function with something bad in it, I don't have to wait till it's called to see i made a mistake, correct?
12:11:15 <saml> dcoutts oh thanks
12:11:23 <Heffalump> they're still a bit of a mess in 6.9, lots of stuff not implemented
12:11:26 <edwardk> i use type Prod k a b and type Sum k a b for sums and products in arbitrary categories a lot, etc.
12:11:27 <dcoutts> saml: or just use Cabal's feature for accessing data files that have to be installed with the package, there is a data-files field in the .cabal file
12:11:51 <edwardk> that way i can recycle (,) over multiple categories to get Arrow like semantics
12:12:12 <edwardk> but it also means that i can correctly build the dual category in which the product is the sum from the other category, etc.
12:12:15 <dcoutts> saml: import Paths_proj (getDataFileName)
12:13:02 <edwardk> similarly i also use Exp k as the type for exponentials in a given category, usually that just reduces to k (as in Hask)
12:13:18 <dcoutts> saml: then use getDataFileName "stdlib.lisp", and list data-files: stdlib.lisp in your .cabal file
12:14:09 <edwardk> and it also allows me to define class associated types for Initial k, and Terminal k so you don't wind up carrying all these terms around when dealing with a category in every class.
12:14:36 <tieTYT> how well will i know haskell if I read all exists of Real World Haskell right now?
12:15:14 <dancor> i don't see how fix works
12:15:17 <tromp> reasonably well?!
12:15:24 <saml> @hoogle getDataFileName
12:15:33 <lambdabot> No matches found
12:15:46 <dcoutts> saml: it's defined in the Paths_proj module that Cabal generates for you
12:15:49 <dancor> > fix (+ 1)
12:15:51 <geezusfreeek> tieTYT: it's not so much a matter of knowing haskell as much as it is about knowing effective ways to use functional programming
12:16:04 <lambdabot>  thread killed
12:16:06 <geezusfreeek> tieTYT: that can only truly be gained through experience
12:16:10 <dancor> > fix (+ 0)
12:16:17 <tieTYT> geezusfreeek: yeah well I need to know a language to write functional programming code first
12:16:25 <lambdabot>  thread killed
12:16:27 <edwardk> gets awfully tedious to talk about class restrictions like (CCC k prod exp bottom, PreCoCartesian k either) => ... on just about everything rather than (CCC k, PreCoCartesian k) => ...
12:16:41 <dancor> > fix (++ "")
12:16:54 <saml> dcoutts: oh thanks. i think i need to read up on the manual.
12:16:56 <geezusfreeek> tieTYT: i'd say the existing RWH chapters should get you going pretty quickly
12:16:56 <lambdabot>  thread killed
12:17:13 <geezusfreeek> tieTYT: though "how much" is kind of ambiguous
12:18:01 <tieTYT> yep
12:18:05 <dancor> > fix (\ x -> x^2 - 2)
12:18:16 <sjanssen> has anyone noticed that Data.List.sort isn't really a merge sort?  It is actually a deforested heap sort!
12:18:19 <tieTYT> RWH says functions have a type.  Does this really mean that their return values have a type?
12:18:20 <lambdabot>  thread killed
12:18:26 <geezusfreeek> does anybody know of any libraries for or papers about writing incremental parsers (as in from a buffered stream) in haskell?
12:18:43 <bos> tieTYT: a function is a kind of value, so both.
12:18:52 <tieTYT> oh
12:18:53 <sjanssen> tieTYT: it means that functions have types, but this also implies that the return value has a type too
12:19:31 <tieTYT> ok
12:19:37 <tieTYT> i think i remember this from last time
12:19:51 <sjanssen> a -> b -- is a function type
12:20:09 <sjanssen> notice that it is composed of two types: 'a' the argument, and 'b' the result
12:20:11 <geezusfreeek> tieTYT: just like IO is a type constructor (apply it to a to get IO a), so is (->) (apply it to a and b to get a -> b), basically
12:21:01 <tieTYT> geezusfreeek: that's beyond me at this point
12:21:06 <tieTYT> but i got what sjanssen said
12:21:08 <ehird> Lemmih: Ping.
12:21:09 <monochrom> type-oriented programming is a cultural shock
12:21:15 <geezusfreeek> tieTYT: that is close enough then
12:21:26 <dancor> fix is just like last . iterate?
12:21:48 <monochrom> No, fix is not like last . iterate. Best to consider them unrelated.
12:22:07 <geezusfreeek> :t fix
12:22:09 <lambdabot> forall a. (a -> a) -> a
12:22:13 <geezusfreeek> :t last . iterate
12:22:15 <lambdabot>     Couldn't match expected type `[a]'
12:22:15 <lambdabot>            against inferred type `a1 -> [a1]'
12:22:15 <lambdabot>     Probable cause: `iterate' is applied to too few arguments
12:22:27 <Lemmih> ehird: It looks like we have to write our own 'alloca'.
12:22:35 <dancor> . never lives up to my expectations
12:22:35 <geezusfreeek> :t \f -> last . iterate f
12:22:37 <lambdabot> forall a. (a -> a) -> a -> a
12:22:40 <monochrom> http://www.vex.net/~trebla/haskell/fix.xhtml   my explanation of fix.
12:23:12 <dancor> :pl \ f x -> (last (iterate f)) x
12:23:36 <monochrom> Note that last (infinite list here) does you no good.
12:23:54 <geezusfreeek> @pl \f -> last . iterate f
12:23:54 <lambdabot> (last .) . iterate
12:24:10 <dancor> crazy .'s
12:24:25 <monochrom> Wait til you've grokked (.) . (.)
12:24:31 <geezusfreeek> that's not crazy to me (anymore)
12:24:40 * dancor begs for mercy and more on-like functions
12:24:47 <geezusfreeek> well, (.) . (.) is still kind of crazy
12:24:55 <geezusfreeek> :t (.) . (.)
12:24:57 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:25:21 <Deewiant> @ty (.) . (.) last . iterate
12:25:22 <lambdabot> forall a a1. (a1 -> a1) -> (a -> a1) -> a -> a1
12:25:24 <geezusfreeek> @unpl (.) . (.)
12:25:24 <lambdabot> (\ i b c f -> i (b c f))
12:25:35 <geezusfreeek> ^ not too crazy
12:25:35 <sjanssen> @. djinn type (.) . (.)
12:25:37 <lambdabot> f a b c d = a (b c d)
12:25:47 <BMeph> :t ($)
12:25:49 <lambdabot> forall a b. (a -> b) -> a -> b
12:26:00 <BMeph> Cale: Slacking? ;)
12:26:01 <Deewiant> @. djinn type (.)
12:26:03 <lambdabot> f a b c = a (b c)
12:26:19 <sjanssen> > succ . [1, 2, 3]
12:26:19 <Deewiant> @. djinn type (.) $ (.)
12:26:21 <lambdabot> Cannot parse command
12:26:22 <lambdabot>  [2,3,4]
12:26:23 <geezusfreeek> woah, does @. compose lambdabot commands?
12:26:24 <sjanssen> boo
12:26:27 <sjanssen> geezusfreeek: yep
12:26:29 <Deewiant> yep
12:26:30 <ehird> <Lemmih> ehird: It looks like we have to write our own 'alloca'.
12:26:30 <geezusfreeek> sweet!
12:26:36 <ehird> Lemmih: unfortunately I tried that
12:26:40 <ehird> Lemmih: but it depends on bracket
12:26:50 <ehird> Lemmih: which depends on IO - you can trace it back, but it gets to a # primitive
12:27:07 <paczesiowa_> @src when
12:27:07 <lambdabot> when p s = if p then s else return ()
12:28:05 <Lemmih> ehird: Oh, hm.
12:28:06 <paczesiowa_> what is a good name for "flip when" ?
12:28:24 <ehird> Lemmih: Something worth noting.
12:28:35 <vixey> paczesiowa_: flip with a bit like when . not ? ?I call it unless
12:28:38 <ehird> Lemmih: runCGI, i believe, does not catch errors.
12:28:57 <ehird> Lemmih: alloca - for the ghc point of view and the one we will code upon - is a malloc/free in a bracket so that it's sure to be collected
12:29:11 <ehird> Lemmih: Now, handleErrors in CGI requires IO.
12:29:22 <ehird> Lemmih: We could rewrite it with malloc/free in liftIO without bracket.
12:29:34 <ehird> Lemmih: Then write something like handleErrors for plain CGI
12:29:39 <ehird> I ... guess
12:30:27 <paczesiowa_> vixey: I don't get it, I don't need unless I need flipped when in one word. too bad I can't use `flip when`
12:30:45 <vixey> oh .. yeah I see the difference
12:34:29 <ehird> @type (.)
12:34:31 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
12:34:38 <monochrom> @hotsnack
12:34:38 <lambdabot> :)
12:34:42 <ehird> hotsnack?
12:34:47 <monochrom> hehehe
12:34:51 <monochrom> @seez ehird
12:34:51 <lambdabot> ehird is in #haskell. I last heard ehird speak 9s ago.
12:35:05 <ehird> @sleaze mokus
12:35:05 <lambdabot> Not enough privileges
12:35:06 <ehird> err
12:35:08 <ehird> @sleaze monochrom
12:35:09 <lambdabot> Not enough privileges
12:35:12 <ehird> Whut
12:35:12 <monochrom> @unquote monochrom
12:35:12 <lambdabot> monochrom says: I really like insults.
12:35:18 <EvilTerran> @help sleaze
12:35:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:36:08 <simony> What does this do: "newtype Max a = Max a deriving (Eq, Ord , Bounded )" ? What's Bounded?
12:36:55 <BMeph> simonny: ...types with a minimum or maximum. :)
12:37:05 <BMeph> s/nn/n/
12:37:10 <monochrom> Bounded is the class that promises maxBound and minBound (sp?), so you can find out largest and smallest values of a type, if it has them.
12:37:25 <monochrom> > minBound :: Char
12:37:26 <lambdabot>  '\NUL'
12:37:32 <jaj> @b52s
12:37:32 <lambdabot> You belong in Ripley's Believe It Or Not
12:38:40 <simony> BMeph, I am reading conal's paper about efficient FRP, and he defines AddBounds that has a MinBound/MaxBound data constructors, and then uses a Max (AddBounds ...)  -- how does Haskell know that MinBound/MaxBound are those of Bounded?
12:38:46 <ehird> @oic
12:38:46 <lambdabot> Maybe you meant: dice dict ghc id join oeis rc src
12:38:50 <ehird> @sux
12:38:51 <lambdabot> Maybe you meant: bug run src thx
12:38:57 <ehird> @ohcomeon
12:38:57 <lambdabot> Unknown command, try @list
12:38:59 <ehird> Bah.
12:39:13 <schme_> hmm.
12:39:19 <BMeph> simony: Because Bounded is a class, defined with those functions. :)
12:39:23 <dancor> edit distance 2?
12:39:45 <simony> monochrom, BMeph what's the deriving rule for Bounded? What is the value that is defined as minBound and maxBound?
12:40:02 <schme_> readin' the type class chapter here in real world haskell. I must say the whole thing strikes me a bit like CL's generic functions. Could anyone perhaps shed some light on if my thinking is right?
12:40:31 <monochrom> I bet it goes like "if a is Bounded, then Max a is also Bounded, by forwarding calls"
12:40:37 <dancor> simony: it's implemented per-type
12:40:48 <dancor> oh deriving
12:41:00 <BMeph> simony: What they (monochrom, dancor) said. :)
12:41:09 <dancor> probably just min of leftmost, max of rightmost
12:41:33 <BMeph> Okay, scratch what I said about dancor... ;)
12:41:48 <idnar> haha
12:42:30 <mrd> schme_: i don't see a real connection
12:42:49 <simony> I see, thanks!
12:43:25 <monochrom> I don't know CL generic functions.
12:43:38 <monochrom> I just know that if you want an analogy between X and Y, you will find one.
12:43:50 <mrd> overloading a name, ok
12:44:10 <schme_> mrd: Well. with haskell instances being CL class objects, and type classes being CL generic methods.
12:44:23 <monochrom> "type class is like sex"...
12:44:34 <schme_> Sounds like odd sex.
12:44:36 <ehird> how do I get a CGIRequest in CGIT?
12:44:37 <schme_> I'm all for it then.
12:44:38 <ehird> That is:
12:44:50 <ehird> :: CGIT m CGIRequest
12:44:51 <ehird> or similar
12:45:09 <schme_> mrd: Well nevermind. Just made it easier in my mind. and it helps when I implement this type system later on ;)
12:45:23 <mrd> perhaps, but i think you might be just confusing yourself more.
12:45:32 <schme_> mrd: How so?
12:45:48 <schme_> It doesn't seem terribly confusing at all ?
12:46:10 <mrd> type classes are unlike classes in OOP languages as they are classes of types (emphasizing this) rather than classes of values
12:46:21 <monochrom> If you aren't confused, that's cool.
12:46:24 <schme_> Is it true that haskellers like to write "typeclasses" and not "type classes"
12:46:37 <schme_> mrd: Sure. that makes perfect sense.
12:46:38 <orbitz> i prefer typeclassics
12:46:48 <schme_> orbitz: Darling!
12:46:50 <ehird> typelasses
12:46:51 <dancor> i guess you can't derive Bounded if you have more than one constructor (not entirely clear why not)
12:47:00 <monochrom> I like writing type class, home page. I'm not German.
12:47:01 <schme_> ehird: my god that's horrible :(
12:47:46 <schme_> mrd: That is why I did not do the parallel between haskell type class and CL class objects though :)
12:47:49 <schme_> well nevermind.
12:48:08 <mrd> by class objects, you mean objects of class subclassed from standard-class?
12:48:13 <schme_> Either it's just very simple stuff, or it's really hard and I just don't understand that I am confused yet.
12:48:17 <ehird> @hoogle Headers -> CGIT m ()
12:48:17 <lambdabot> No matches, try a more general search
12:48:19 <ehird> bah
12:48:23 <orbitz> do any other langauges have an equivalent of typeclases?  maybe tempaltes in C++?
12:48:30 <orbitz> not equiv, but close...srta
12:48:47 <geezusfreeek> templates are closer to polymorphic functions
12:49:01 <spainish> no geezusfreeek
12:49:09 <geezusfreeek> well, in their most simple use cases anyway
12:49:17 <schme_> mrd: Actually I mean objects of the class class.
12:49:45 <schme_> mrd: But really. It's no biggie. nevahmind :)
12:49:47 <monochrom> operator overloading in c++ is close to type class. the c++ people are proposing a change to operator overloading to make them equivalent. I forgot the new name.
12:50:01 <ehird> monochrom: Functional-reactor class-type monomorphisms.
12:50:16 <orbitz> monochrom: 'concepts'
12:50:22 <mrd> schme_: of course, the other big deal is that generic functions are very much about late-binding
12:50:25 <BMeph> ehird: Gesundheit! ;)
12:50:28 <ziman> overloading seems more flexible to me than typeclasses
12:50:32 <mrd> and runtime typechecking
12:50:46 <schme_> mrd: Yes yes, of course. :)
12:50:55 <spainish> the templates are a restringed subset of polymorphism, and it's not dynamic binding.
12:51:17 <mrd> schme_: H'98 typeclasses only work on a single type
12:51:26 <mrd> at a time
12:51:38 <BMeph> Run time typechecking (or "run time type checking," for mono...) is easy: Segmentation fault (core dumped)
12:51:49 <schme_> mrd: indeed
12:52:35 <schme_> Seems to me that types are classed according to protocol. That's what I'm getting here. dunno if i'm missing something.
12:52:44 <monochrom> runtimetypechecking :)
12:53:03 <spainish> unafortunately, yes monochrom.
12:53:29 <schme_> BMeph: Seems to me that run time type checking more tends to temporarily stop the program and let people enter new data and continue ;)
12:53:41 <schme_> oh well.
12:53:47 <schme_> Time to go touch myself. ta ta!
12:54:53 <ehird> that's some exit
12:58:25 <saml> how can I make an instance of IOError?
12:58:41 <saml> data Err = Err String -- this is my Err type
12:59:33 <BMeph> simony: ping
12:59:44 <simony> BMeph, pong
12:59:58 <edwardk>  hrmm. does anyone here know of any work on forgetful laziness? i.e. where you store just the forwarding pointer to the result when forcing a thunk, and then periodically allow the GC to throw them away
12:59:59 <Botje> "this is my Err type. There are many others like it, but this one is mine"
13:00:06 <simony> BMeph, your ping lacks a payload :)
13:00:38 <edwardk> maybe with either exponential backoff on the 'discarding of a given thunk by annotating it with a number of times it has been regenerating or a 'forget only once' bit
13:00:54 <BMeph> Okay, from what I gather of that Max a type, it means that when you declare something as Max ___, that you have to say how it implements Eq, Ord and Bounded.
13:01:15 <BMeph> Botje: s/others//
13:01:26 <Botje> really?
13:01:39 <BMeph> Botje: "many" implies "others," you know - or Do you? ;)
13:01:58 <Botje> not if the RealWorld## uses sharing
13:02:12 <simony> BMeph, oh, I understood that part already -- Max is used to add an instance of Monoid to AddBounds
13:02:24 <ehird> :t mapM
13:02:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:02:36 <Botje> (and given the concept of quantum entanglement, i'm not so sure that it's easy to disprove that)
13:02:36 <ehird> :t mapM_
13:02:38 <edwardk> while the exponential back off is not a 'W-safe' optimization, it is asymptotically equivalent, so shouldn't change timescale by more than a constant for practical purposes.
13:02:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
13:03:11 <simony> conal, ping
13:03:25 <BMeph> simony: The thing is, it's a declaration - how you implement it is your decision. You're just promising that it will be done if used.
13:03:43 <conal> simony: hi
13:03:55 <simony> conal, hey, I think I found a few typos in "efficient FRP"
13:04:03 <simony> conal, is the one on site the most up-to-date one?
13:04:55 <conal> simony: yes, except for the errata listed on the paper's web page.
13:05:02 <Botje> edwardk: fwiw, the closest i've seen is something about "rotting" references to objects
13:05:07 <simony> conal, oh, why not fix those?
13:05:24 <simony> conal, btw: Do you have a library available for download?
13:05:31 <ehird> http://hpaste.org/7668 why is runApp badly typed?     Occurs check: cannot construct the infinite type: a = Nomic a
13:05:39 <BMeph> Botje: How does sharing modify "many" so as not to mean... well, "Many"? ;)
13:05:50 <edwardk> botje: heh lazy bitrot =)
13:06:03 <conal> simony: not ready yet.  not tested enough.  i'm working now with andy gill on a new functional 3d library that we'll use to test & profile the new frp lib.
13:06:09 <ehird> ahh wait..
13:06:19 <Botje> BMeph: not so much "many", but "others"
13:06:29 <pjdelport> "don't be so lazy your thunks fall off"?
13:06:36 <simony> conal, cool - can you release some half-arsed untested one until its ready? :-)   I just want to toy/experiement with it
13:06:44 <Botje> BMeph: there's no guarantee a tree i see on the road isn't the exact same somewhere in japan :)
13:07:02 <conal> simony: after checking with the errata, would you please either email your comments or (if more than typos), leave a comment on the paper's blog post?
13:07:27 <conal> simony: if it's the interface you want to play with, try out Reactive
13:07:30 <conal> @wiki Reactive
13:07:30 <lambdabot> http://www.haskell.org/haskellwiki/Reactive
13:07:31 <BMeph> Botje: Ah, so. Hm...
13:07:34 <simony> conal, I found stuff like "Behavior" where "Reactive" was probably meant, and one inf instead of -inf, stuff like that
13:07:56 <conal> simony: super.  i'll make sure they get in the errata list *and* fixed.
13:08:24 <simony> conal, ok, cool
13:08:27 <Heffalump> ehird: it compiles fine if you remove the signature on runApp
13:08:30 <ehird> Heffalump: yes
13:08:34 <ehird> i'm rewriting it to get the right type
13:08:36 <conal> simony: thx :)
13:08:38 <Heffalump> I suggest you read the inferred signature and work it out for yourself :-)
13:08:54 <ehird> Heffalump: indeed
13:09:20 <simony> conal, Hmm, does seem like they're all on the errata, sorry :)
13:09:23 <Botje> BMeph: but you are absolutely correct on the full metal jacket reference.
13:09:33 <SamB> always remember to compile not only your t-shirts but also your papers before publication
13:09:34 <Botje> the "others" shouldn't be there :)
13:09:41 <Trinithis> what is frp?
13:10:10 <SamB> Trinithis: Functional Reactive Programming
13:10:20 <Trinithis> and that?
13:10:23 <conal> Trinithis: functional reactive programming.  it's a functional paradigm for describing time-changing values that has simple and composable semantics (unlike imperative programming)
13:10:50 <conal> Trinithis: and has an underlying *continuous* model of time
13:10:51 <SamB> conal: a bit like signals in circuits, yes?
13:11:05 <SamB> except without the "two-way" stuff
13:11:07 <conal> SamB: analog circuits, yes
13:11:19 <SamB> conal: why only analog?
13:11:24 <pjdelport> with bits of spreadsheet thrown in
13:11:28 <geezusfreeek> conal: another update on my frp stuff... i came up with yet another implementation whereby i simply represent a future as a (IORef (IO (Available t a))), where Available is the same as in my GADT version, and it evaluates by rewriting itself whenever you force it, just like a thunk
13:11:38 <Trinithis> conal: ah ok
13:11:44 <geezusfreeek> works fine except i have a little memory problem right now
13:12:03 <SamB> geezusfreeek: you can't remember what you were going to do next?
13:12:18 <conal> Trinithis: also highly concurrent semantics while retaining simplicity and determinacy (predictability)
13:12:19 <geezusfreeek> SamB: huh?
13:12:20 <SamB> ... or you ran out of memory and the computer crashed?
13:12:34 <geezusfreeek> i have a slight space leak ^_^
13:13:03 <conal> geezusfreeek: sounds nice.  does the IORef content have to be an IO?
13:13:12 <conal> geezusfreeek: otherwise it sounds like a thunk
13:13:35 <saml> http://hpaste.org/7669  what should I do with this IOError problem?
13:13:45 <ehird> runApp :: (MonadTrans t, Monad m, MonadCGI (t m), MonadCGI t2) =>
13:13:45 <ehird>           CGIT m (t m t1) -> t2 (t m t1)
13:13:46 <ehird> gah
13:13:48 <Trinithis> what cause space leaks?
13:13:58 <geezusfreeek> conal: well, the action in the IORef is what is actually responsible for rewriting what the IORef stores
13:14:21 <geezusfreeek> conal: i don't know how else i could type it besides as an IO action
13:14:24 <ehird> :((((((((((((((((((((((((((((((((((((((((((((((((((9
13:14:49 <conal> geezusfreeek: couldn't you just move the overwrite part out to the context that does the readRef?
13:15:07 <conal> geezusfreeek: or may there's more to the IO than writing the ref?
13:15:09 <orbitz> is mixing monads difficult? (this is a question form someone with only a rudamentry knowledge of monads)
13:15:16 <geezusfreeek> conal: there is a bit more to it
13:15:23 <conal> geezusfreeek: ok
13:15:49 <conal> geezusfreeek: i'd like to take a look at the code when you're happy with it.
13:16:00 <geezusfreeek> conal: the thunk stores all the functionality of the future. for example, fmap f fut creates a future whose action is to force fut and apply f to it
13:16:00 <ehird> runApp :: (MonadIO m, MonadCGI m, MonadCGI t) => CGIT Nomic a -> t (m a)
13:16:02 <ehird> SO CLOSE!
13:16:17 <ehird> runApp :: App a -> CGI a
13:16:18 <ehird> woot
13:16:47 <conal> geezusfreeek: i get it.
13:17:29 <geezusfreeek> certainly not happy with it yet. a bit frustrated with my space leak right now
13:17:33 <Saizan> orbitz: we usually build the monad we want via monad transfomers, so effectively mixing the effects of various monads
13:17:45 <conal> geezusfreeek: sounds *very* like the inner workings of lazy evaluation
13:17:55 <geezusfreeek> conal: exactly
13:18:19 <orbitz> Saizan: i'm not sure i fully understand, is it possible to dumb it down even more?  For instance, wha ti fi want to do I/O and have a modifyable array?
13:18:34 <conal> geezusfreeek: i'd love to understand exactly what makes FP with laziness not enough here.
13:18:51 <Saizan> orbitz: in that particular case you use an IOArray :)
13:18:59 <geezusfreeek> conal: as would i
13:19:12 <conal> geezusfreeek: maybe it's the absence of something like unambiguous choice or parallel or
13:19:21 <Saizan> orbitz: however suppose you want to use State SomeState and IO, you can instead use StateT SomeState IO
13:19:25 <conal> geezusfreeek: both of which have simple, pure semantics.
13:19:45 <Saizan> orbitz: StateT is the transformer correspondig to State
13:19:49 <conal> geezusfreeek: and/or maybe some other reason
13:19:59 <ehird> :t sortM
13:20:01 <lambdabot> Not in scope: `sortM'
13:20:03 <ehird> WHAT
13:20:04 <ehird> NO SORTM
13:20:04 <ehird> :(
13:20:15 <hexpuem> is there something in prelude that applys [args] to a func?
13:20:24 <ehird> hexpuem: tell us what type that would be would you?
13:20:28 <orbitz> Saizan: is creating a tarnsformer somethign that can be done by the compiler or is it a manual process?
13:20:36 <Saizan> orbitz: manual
13:21:16 <hexpuem> type of the list or what?
13:21:37 <orbitz> Saizan: is this generaly sufficient? or do things become difficult the more ocmplex you do things?
13:21:40 <conal> geezusfreeek: another angle: i wonder if one could extract and encapsulate from your implementation a reusable mechanism that has purely functional semantics (though statefully implemented) and is enough to allow the rest of your implementation to be purely functional.
13:21:47 <Saizan> orbitz: usually not very different from creating the monad in the first place, it's relatively common to define just the tranformer and get the monad transformin Identity
13:21:51 <roconnor> @type \f -> ((((f .) .) .) .)
13:21:53 <lambdabot> forall b c a a1 a2 a3. (b -> c) -> (a3 -> a2 -> a1 -> a -> b) -> a3 -> a2 -> a1 -> a -> c
13:22:09 <conal> @type fmap.fmap.fmap.fmap
13:22:11 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f3, Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
13:22:14 <roconnor> thinking of . as fmap really helps
13:22:19 <conal> !
13:22:23 <geezusfreeek> good lord!
13:22:45 <conal> roconnor: and (broken record) remembering that you can throw first and second into the mix
13:22:45 <roconnor> . simly lifts one level in a reader monad
13:22:54 <conal> roconnor: or indeed any functor
13:22:59 <ehird> I need a sortm. :(
13:23:05 <roconnor> conal: first and second?
13:23:14 <conal> yes.
13:23:21 <conal> @type first
13:23:22 <roconnor> conal: oh, deep arrow?
13:23:22 <lambdabot> Not in scope: `first'
13:23:32 <conal> roconnor: yes, and regular arrows
13:23:43 <orbitz> do you think the EMH on the starship voyage would be written in haskell?
13:23:51 <ehird> @src sort
13:23:51 <lambdabot> sort = sortBy compare
13:23:54 <ehird> @src sortBy
13:23:54 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
13:23:55 <roconnor> Hey, do we have some kind of generic functor class that supports filter?
13:23:57 <ehird> @src insertBy
13:23:58 <lambdabot> insertBy _   x [] = [x]
13:23:58 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
13:23:58 <lambdabot>                                  GT -> y : insertBy cmp x ys'
13:23:58 <lambdabot>                                  _  -> x : ys
13:24:01 <conal> roconnor: this trick of composing (.)'s, first, and second is the heart of DeepArrow, which makes Eros fly
13:24:02 <ehird> Gah.
13:24:02 <Saizan> orbitz: there are some drawbacks, but typeclasses usually help
13:24:03 <ehird> SortM!!
13:24:05 <ehird> Please?
13:24:07 <roconnor> orbitz: no, I'd use lisp
13:24:09 <ehird> ah wait
13:24:10 <ehird> :t filterM
13:24:12 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
13:24:15 <orbitz> roconnor: what abotu Qi?
13:24:17 <ehird> YAY
13:24:24 <roconnor> orbitz: is Qi typed?
13:24:36 <orbitz> roconnor: optional
13:24:39 <conal> roconnor: and can be used with GUIs, syntax, type representations, ...
13:24:46 <orbitz> roconnor: some claim it has the best type system. EVER.
13:24:51 <conal> roconnor: (to manipulate those things)
13:24:57 <ehird> orbitz: EVERRRRRRRRRRRRRRR
13:24:58 <roconnor> orbitz: untyped is good
13:25:12 <orbitz> evverrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
13:25:14 <roconnor> ehird: filterM still has to do with lists
13:25:34 <roconnor> ehird: I want to filter trees ... well, actually want to filter lists of lists.
13:25:45 <orbitz> roconnor: it needs to be very safe though.  you don't want him to be messing around in your guts and get a type error on the scalpel
13:25:46 <ehird> roconnor: I don't care about your problem. This was my problem.
13:25:47 <ehird> :P
13:26:45 <roconnor> orbitz: I imagine that code EMHs would be evolved.
13:26:53 <roconnor> orbitz: and in that case, type systems get in the way
13:27:15 <orbitz> i suppose you ha ea point
13:27:27 <orbitz> i think EMH's will probably be part of emacs
13:27:49 <roconnor> there are some really cool ways of subtracting church numerals that is extremely difficult to type.
13:28:22 <schme_> orbitz: M-x doctor RET
13:28:33 <orbitz> for sure
13:28:34 <roconnor> orbitz: but some parts can be typed
13:28:47 <roconnor> orbitz: like the code for the holographic emitters
13:28:57 <orbitz> yeah good
13:29:03 <orbitz> roconnor: what about hologrpahic organs?
13:29:07 <orbitz> i think they should be in haskell
13:29:22 <roconnor> I don't think holograms have organs
13:29:32 <spainish> have you access to http://www.xach.com/lisp/ ?
13:29:33 <lambdabot> Title: Zach Beane's Lisp Resources
13:29:45 <ehird> :t hotlink
13:29:47 <lambdabot> Not in scope: `hotlink'
13:29:50 <ehird> :t Text.XHtml.Strict.hotlink
13:29:52 <lambdabot> Couldn't find qualified module.
13:30:18 <orbitz> ehird: try hawtlink
13:30:31 <ehird> orbitz: Thanks, you are very useful
13:30:49 <roconnor> @hoogle hotlink
13:30:49 <lambdabot> No matches found
13:30:59 <orbitz> ehird: ahem, i think you mean "most useful EVERRRRRRRRRRRRRR"
13:31:03 <roconnor> @hoogle hawtlink
13:31:03 <lambdabot> No matches found
13:31:33 <schme_> the type specification language of Qi is Turing-equivalent   <<-- hah!
13:31:38 <orbitz> hi preflix
13:31:41 <orbitz> preflex: be mauke
13:31:44 <roconnor> @. leet hoogle hawlink
13:31:44 <lambdabot> Plugin `compose' failed with: Unknown command: "leet"
13:31:52 <orbitz> schme_: it may never compile!
13:31:55 <roconnor> @. eleet hoogle hawlink
13:31:55 <lambdabot> Plugin `compose' failed with: Unknown command: "eleet"
13:32:05 -preflex(i=mauke@rm-f.net)- no quotes found for mauke
13:32:34 <saml> is creating a thin wrappers around existing monads (such as State) a good idea?
13:32:46 <schme_> orbitz: Qi seems like great fun :)
13:32:47 <roconnor> @. elite hoogle hawlink
13:32:47 <lambdabot> no /\/\At(HEz0rz FOuND
13:32:49 <saml> instead of get, getN...etc
13:32:56 <roconnor> there we go
13:32:57 <orbitz> schme_: i'm sur eyou' dlike it
13:33:39 <conal> saml: sure, especially with "deriving (Functor,Applicative,Monad)"
13:33:50 <schme_> orbitz: I like the bit where you can turn off type checking ;)
13:33:52 <ehird> @pl \fn -> all not $ map (isSuffixOf fn) ["~", "#", ".hi", ".o"]
13:33:52 <lambdabot> all not . flip map ["~", "#", ".hi", ".o"] . isSuffixOf
13:34:01 <ehird> @. unpl pl \fn -> all not $ map (isSuffixOf fn) ["~", "#", ".hi", ".o"]
13:34:01 <lambdabot> (\ f -> all not (map (isSuffixOf f) ["~", "#", ".hi", ".o"]))
13:34:04 <orbitz> schme_: i figured you might
13:34:11 <conal> saml: gives you some extra type-checking and friendlier type error messages
13:34:52 <schme_> orbitz: this combined with cl-muproc (the lisp erlang) will be great fun I am sure (:  Thanks for the Qi tip there!
13:35:21 <orbitz> schme_: i aim to please
13:35:42 <saml> conal: yah. also, i can change internal monad stack while keeping the interface. one thing i wasn't sure was that i was making it instance of existing mtl stack monads. very repetitive process. almost like writing getters and setters in Java
13:36:11 <mauke> just derive MonadState
13:36:13 <saml> maybe there's way to use TemplateHaskell to do the dirty work
13:36:53 <conal> saml: see if you can derive all the instances you want
13:37:52 <saml> newtype SourcePosT m a = SourcePosT { runSourcePosT :: StateT .... } deriving (...)   and instance MonadReader ... -- this instance declaration part is dirty and repetitive
13:39:03 <mauke> DERIVE IT
13:39:39 <geezusfreeek> lol
13:40:15 <ehird>     where zipPaths :: [FilePath] -> [(FilePath,FilePath)]
13:40:15 <ehird>           zipPaths xs = mapM (\x -> do p <- liftIO $ canonicalizePath x
13:40:15 <ehird>                                        return (p,x)) xs
13:40:18 <ehird> why doesn't that type?
13:40:24 <ehird> it wants [[(FilePath,FilePath)]] as the return ...
13:40:45 <mauke> liftIO?
13:40:58 <mauke> what monad is this and why doesn't it appear in the return type?
13:41:05 <geezusfreeek> :t \xs -> mapM (\x -> do p <- liftIO $ canonicalizePath x; return (p,x)) xs
13:41:07 <lambdabot> Not in scope: `canonicalizePath'
13:41:12 <geezusfreeek> oh dang
13:41:39 <ehird> mauke: O.
13:42:26 <geezusfreeek> :t \xs -> mapM (\x -> do p <- liftIO $ System.Directory.canonicalizePath x; return (p,x)) xs
13:42:28 <lambdabot> forall (m :: * -> *). (MonadIO m) => [FilePath] -> m [(FilePath, FilePath)]
13:43:12 <geezusfreeek> ehird: has to return in the IO monad
13:43:23 <ehird> geezusfreeek: no. Nomic actually.
13:43:26 <saml> oh deriving works too
13:43:28 <geezusfreeek> well
13:43:44 <vixey> does anyone have a mirror of Algebra of Programming using Dependant Types?
13:44:07 <edwardk> vixey: the agda paper?
13:44:09 <vixey> oh I'm sorry I think I must have cached a partially downloaded version, it's fine now
13:44:21 <vixey> edwardk: yes
13:48:35 <roconnor> ``Python's hasattr ignores exceptions like KeyboardInterrupt and SystemExit? Use getattr(x,y,None)==None instead.
13:48:44 <roconnor> ``What if the attribute is a None value?
13:48:52 <roconnor> Ahhhh, use types for god's sake!
13:52:30 <ehird>           filter
13:52:30 <ehird>                (\fn -> all not $ map (isSuffixOf fn) ["~", "#", ".hi", ".o"])
13:52:30 <ehird>                contents
13:52:41 <ehird> That removes entries ending in ~,#,.hi,o.
13:52:42 <ehird> right?
13:53:06 <mauke> that looks wrong
13:55:11 <mauke> > filter (\x -> not $ any (`isSuffixOf` x) (words "~ # .hi .o")) ["foo", "foo#", "bar.o", "baz"]
13:55:13 <lambdabot>  ["foo","baz"]
13:56:53 <geezusfreeek> conal: i misstated my future representation, actually. it's just Future (IO (Available t a)) .. the IORef is referenced internally to the action... my bad
13:58:37 <saml> newtype Foo e a = Foo { runFoo :: ErrorT e (...) a } is this normal? taking e as parameter
13:59:01 <conal> geezusfreeek: oh, simpler!  :)
13:59:14 <geezusfreeek> conal: :)
14:00:08 <geezusfreeek> conal: as we speak i'm playing with implementing IVar with it
14:01:00 <conal> geezusfreeek: great.  IVar is probably close to the hypothetical functional interface i mentioned
14:01:44 <geezusfreeek> it certainly was much more elegant when we were trying to use it when STM was still on the table
14:01:47 <conal> geezusfreeek: btw, IVar is where i started with Reactive.
14:01:58 <conal> geezusfreeek: yes, sigh.
14:03:13 * SamB wonders how you prove confluence
14:04:16 <vixey> SamB: I really hope you will release your agda code at some point
14:04:31 <vixey> hey wy
14:04:38 <wy> hi vixey
14:05:19 * SamB wonders if he can get people to sign an NRA
14:05:38 <vixey> @wtf NRA
14:05:38 <lambdabot> Maybe you meant: bf ft wn
14:05:40 <vixey> :(
14:05:54 <SamB> in this case, I mean "non ridicule agreement"
14:06:00 <vixey> haha
14:06:02 <vixey> sure :)
14:06:20 <vixey> SamB: I ask because there's not so much and everything is useful to learn from
14:06:33 <kosmikus> SamB: what are you writing in Agda?
14:07:35 <SamB> at present, I'm just trying to formalize some of the stuff in "a Î»-calculus with explicit weakening and explicit substitution"
14:08:44 <kosmikus> ok, nice
14:12:25 <conal> simony: now i've updated the web copy of the "simply efficient frp" paper and made clear which version is associated with the listed errata.
14:14:22 <conal> (oops -- darcs push hanging ...)
14:15:13 <gwern> hm. I wonder where WASH is?
14:15:14 <gwern> @where wash
14:15:14 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
14:18:08 <conal> (push finished)
14:18:41 <noecksit> hello, is there a way that you can make a monad return IO () instead of IO Smthing?
14:18:54 <lament> yes
14:18:56 <lament> return ()
14:19:25 <Lemmih> noecksit: action >> return ()
14:19:34 <noecksit> oh, i see
14:19:40 <jaj> @type ()
14:19:42 <lambdabot> ()
14:20:22 <noecksit> since return () returns by inference what the monad is supposed to be, it returns the right type
14:20:31 <noecksit> thanx
14:26:57 <thetallguy> Howdy folks.  I've run into this little problem a bunch recently, and stepcut just did as well.  Given a list, break it up into a list of lists of length max n.
14:27:29 <thetallguy> I just hpasted it: http://hpaste.org/7670
14:27:37 <roconnor> that function really ought to be added to the standard library
14:27:48 <roconnor> chunk n
14:27:50 <thetallguy> roconnor: that's the question I'm polling
14:28:15 <thetallguy> I'll take that as one vote in favor.
14:28:38 <thetallguy> I originally called it chunk as well.
14:28:43 <RayNbow> > [1.0,1.1..2]
14:28:43 <roconnor> I used unfoldr in my code
14:28:44 <lambdabot>  [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.50000000...
14:28:48 <roconnor> I needed this function for my sha1
14:28:53 <roconnor> although I think I called it block at the time.
14:28:53 <gwern> heh. so what would chunkBy be?
14:28:58 <thetallguy> -- I haven't explored rewriting this with unfoldr.  That might yield something more general, but neither drop nor take fail here, so I'm happy with this for now.
14:29:00 <Cale> What if you want to minimise the sum of the squares of differences between the lengths of the lists and n? ;)
14:29:06 <thetallguy> gwern, I thought about that
14:29:13 <gwern> would you pass chunkBy an unfold?
14:29:27 <thetallguy> gwern: I think you might apply f instead of (drop n
14:29:28 <roconnor> @poll
14:29:28 <lambdabot> Maybe you meant: poll-add poll-close poll-list poll-remove poll-result poll-show pl spell tell
14:29:33 <gwern> ...actually, that makes sense. 'chunk n = chunkBy (repeat n)'
14:29:35 <roconnor> @poll-add
14:29:35 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
14:29:44 <roconnor> @help poll-add
14:29:44 <lambdabot> poll-add <name>             Adds a new poll, with no candidates
14:29:52 <thetallguy> roconnor: Oh right, I'd forgotten we have a poll bot
14:30:12 <dylan> so.. I'm using haskell to solve which bit of a bitfield to set.
14:30:14 <roconnor> @poll-add Chunks
14:30:14 <lambdabot> Added new poll: "Chunks"
14:30:33 <gwern> chunkBy (n:ns) m@(l:ls) = take n m : chunkBy ns ls?
14:30:43 <roconnor> @help poll-list
14:30:43 <lambdabot> poll-list                   Shows all current polls
14:30:48 <roconnor> @poll-list
14:30:49 <lambdabot> ["Chunks"]
14:30:53 <vixey> @poll-add Chunks
14:30:54 <lambdabot> Poll "Chunks" already exists, choose another name for your poll
14:30:56 <vixey> :(
14:30:58 <roconnor> @vote
14:30:58 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
14:31:04 <roconnor> @help vote
14:31:04 <lambdabot> vote <poll> <choice>        Vote for <choice> in <poll>
14:31:07 <vixey> @vote Chunks YES
14:31:07 <lambdabot> "YES" is not currently a candidate in this poll
14:31:31 <dylan> could someone tell me there's a way to simplify this function?
14:31:33 <dylan> http://hpaste.org/7671
14:31:44 <roconnor> @poll-add Chunks Yes
14:31:44 <lambdabot> usage: @poll-add <poll>   with "ThisTopic" style names
14:31:53 <gwern> #haskell, sometimes you just have to give up and say 'lambdabot is not a good tool to do <foo>', where foo in this case is polling
14:31:56 <thetallguy> A more general form might also be 'chunk 3 1', giving [1..7] -> [[1,2,3].[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7],[7]]
14:32:07 <thetallguy> a sliding window sort of thing
14:32:13 <roconnor> @help poll
14:32:14 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
14:32:15 <wuxia> what's the haskell library I should use for reading midi files?
14:32:30 <roconnor> @choice-add Chunks Yes
14:32:30 <lambdabot> New candidate "Yes", added to poll "Chunks".
14:32:38 <dons> wuxia: look on hackage.haskell.org
14:32:38 <roconnor> @choice-add Chunks No
14:32:39 <lambdabot> New candidate "No", added to poll "Chunks".
14:32:41 <dons> there's something for midi
14:32:42 <vixey> @vote Chunks Yes
14:32:42 <lambdabot> voted on "Yes"
14:32:56 <thetallguy> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HCodecs
14:33:01 <lambdabot> http://tinyurl.com/576mxw
14:33:22 <roconnor> @choice-add Chunks YourFavouriteAmusingOtherOption
14:33:22 <lambdabot> New candidate "YourFavouriteAmusingOtherOption", added to poll "Chunks".
14:33:32 <roconnor> @vote Chunks Yes
14:33:32 <lambdabot> voted on "Yes"
14:33:47 <gwern> dylan: what happens if n = 24?
14:34:00 <dylan> gwern: bottom
14:34:02 <dylan> :)
14:34:33 <roconnor> thetallguy: we should stick with the basic chunk
14:34:39 <thetallguy> roconnor: thanks, looks like there will be enough positive response to make a submission to the library list
14:35:03 <thetallguy> roconnor: I agree on the basic one.  The window is more for convolution stuff, which isn't so basic.
14:35:07 <roconnor> if people need fancy functions, they can write it themselves.
14:35:18 <gwern> what
14:35:24 <thetallguy> roconnor: I'll work on that one with Conal for his new LA library
14:35:25 <gwern> 's wrong with chunkBy?
14:35:32 <dons> dylan: are you using the Data.Bits module?
14:35:38 <dons> dylan: testBit, setBit and friends?
14:35:42 <roconnor> what does chunkBy do?
14:35:45 <dons> or the BitSet class
14:35:49 <dylan> dons: I'm not using haskell, sadly
14:35:59 <dylan> dons: I'm using haskell to solve a problem in another language
14:36:02 <gwern> roconnor: I have examples earlier :(
14:36:06 <dons> ah i see.
14:36:59 <gwern> roconnor: 'chunk n = chunkBy (repeat n)', say. so you could also maybe go 'chunkBy [1..]' to get [[1], [2,3], [4,5,6],...]
14:37:07 <roconnor> gwern: ah
14:37:09 <roconnor> interesting
14:37:40 <roconnor> gwern: does it interfer with fusion?
14:37:50 <thetallguy> gwern: yeah, that's another possibility, but By's usually take functions, not lists
14:37:59 <gwern> roconnor: sink me if I know!
14:38:02 <vixey> just think of chunk n = chunkBy (repeat n) as a specification
14:38:08 <thetallguy> so I would prefer
14:38:08 <roconnor> @sink gwern
14:38:08 <lambdabot> Maybe you meant: kind ping ring
14:38:10 <gwern> thetallguy: well, 'repeat n' is a function, no?
14:38:22 <roconnor> @type repeat n
14:38:24 <lambdabot> [Expr]
14:38:29 <roconnor> nope
14:38:40 <vixey> :t const ?n
14:38:42 <lambdabot> forall a b. (?n::a) => b -> a
14:39:05 <gwern> thetallguy: I could go all verbose and say 'let the initial parameter to chunkBy be an unfold on lists' or whatever, but I find it easier to think of infinite lists
14:39:29 <roconnor> gwern: have you ever used chunkBy?
14:39:58 <gwern> roconnor: no. I've never used 'chunk' either, but I'm not the one asking for't
14:40:16 <roconnor> who was asking for chunkBy?
14:40:16 <thetallguy> roconnor: nor have I
14:40:17 <gwern> hm. or maybe I have
14:40:19 * gwern checks
14:40:39 <thetallguy> roconnor: I thought about it, but I haven't ever had a need.
14:40:50 <thetallguy> Doing 'chunkBy f' isn't trivial
14:41:02 <gwern> roconnor: it's an obvious generalization. why not?
14:41:04 <roconnor> I'd be hesitent to add something to the standard library that no one has used
14:41:08 <thetallguy> instead of 'map (take n)' you could do 'map f'
14:41:17 <roconnor> I don't think this generalization is obvious
14:41:31 <thetallguy> but then what do you do to replace 'drop n'?
14:41:44 <gwern> hm. I've never used chunk, I don't think. the closest I've come is: '> split ' ' "foo bar baz" -> ["foo","bar","baz"]'
14:41:45 <roconnor> map (take n)?
14:42:13 <thetallguy> roconnor: I agree.  There are too many possibilities and the design doesn't seem to converge
14:42:25 <geezusfreeek> conal: http://github.com/geezusfreeek/simple-haskell-game/tree/experimental%2Fsrc%2FData%2FIVar.hs?raw=true
14:42:27 <lambdabot> http://tinyurl.com/5t3ocv
14:42:27 <roconnor> the question about chunk comes up fairly regularly on #haskell
14:42:36 <thetallguy> roconnor: re: map (take n), that's in my original definition
14:42:52 <conal> geezusfreeek: thx
14:42:56 <roconnor> thetallguy: ah right
14:42:57 <thetallguy> roconnor: okay, I'm sold.  I'll propose chunk and only chunk.
14:43:10 <dolio> If you want chunks, which is an unfold with splitAt (take,drop), then you probably want breaks, which is an unfold with break (takeWhile,dropWhile).
14:43:22 <gwern> nooo
14:43:24 <dolio> Or spans, whichever.
14:43:32 <geezusfreeek> conal: obviously note quite as nice as the stm one since we don't get the free retry behavior, but i think just using Maybe works fine too
14:43:49 <roconnor> what's the differnce between break and splitAt again?
14:43:54 <roconnor> oh
14:43:57 <roconnor> right the while
14:44:13 <roconnor> @type break
14:44:15 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
14:44:16 <dolio> That's what I'd use as chunkBy.
14:44:30 <dolio> breaks or spans, pick one.
14:44:39 <roconnor> don't call it chunkBy
14:45:23 <conal> geezusfreeek: small comment: in cached, try using mdo to eliminate the let & writeIORef.
14:45:38 * geezusfreeek is not familiar with mdo
14:45:41 <geezusfreeek> i will look into it
14:45:46 <thetallguy> dolio: I don't see how you'd use break to do what gwern proposed as chunkBy
14:45:48 <dolio> Then again, I'd settle for splitAt/break/span/etc. that work nicely with unfoldr.
14:45:56 <conal> geezusfreeek: recursive do.
14:46:10 <dolio> thetallguy: Which?
14:46:13 <conal> geezusfreeek: so you can use ref in its own initialization.
14:46:16 <dolio> split?
14:46:25 <geezusfreeek> oh!, okay that'd be good
14:47:21 <conal> geezusfreeek: looks very simple.  i wonder how Reactive will look on top of this IVar.
14:47:39 <geezusfreeek> not a clue yet. mine is fugly right now ;)
14:47:41 <gwern> personally, I don't see how you could pass a function into chunkBy instead of a list/a-function-making-a-list; what would this function be applied to? would it get applied to the list being split up? that's a weird definition
14:48:02 <conal> geezusfreeek: can you define pure via pure and <*> via <*>?
14:48:33 <geezusfreeek> conal: i was thinking about that. i probably can, but i don't know that it would be any prettier
14:48:34 <conal> geezusfreeek: and how about IVar = IO :. Maybe
14:48:44 <noecksit> hello, do you guys know if Control.Concurrent's killThread does the same thing as exitWith?
14:48:48 * roconnor annotated inGroupsOf -- propose for Data.List? with chunks used in Data.Digest.SHA2 at http://hpaste.org/7670#a1
14:48:51 <geezusfreeek> conal: heh, i haven't familiarized myself with type composition yet
14:48:54 <conal> geezusfreeek: try.  see if it can come out looking "standard"
14:49:04 <noecksit> ie does it close all currently open sockets and files?
14:49:08 <conal> geezusfreeek: with type composition your definitions may almost vanish
14:49:18 <geezusfreeek> conal: that would be very nice
14:49:20 <dolio> > let stopAt p f x = if p x then Nothing else Just (f x) in unfoldr (stopAt null $ second (drop 1) . break ' ') "foo bar baz"
14:49:21 <lambdabot>  Couldn't match expected type `a -> Bool'
14:49:30 <dolio> > let stopAt p f x = if p x then Nothing else Just (f x) in unfoldr (stopAt null $ second (drop 1) . break isSpace) "foo bar baz"
14:49:31 <lambdabot>  ["foo","bar","baz"]
14:49:45 <conal> geezusfreeek: i'll play with it also.
14:49:59 <geezusfreeek> unfortunately i think i will have to wait until late tonight to get to work on this again
14:50:40 <noecksit> oh, i can just use throwTo to throw an exception to the thread
14:50:55 <conal> sure.  i like this one (and some of your previous formulations).  i'll play with it.  i don't think i'd thought to try the IO (Maybe a) representation.
14:51:55 <geezusfreeek> conal: which previous ones do you find most promising?
14:52:33 <conal> none of them any more, but i liked them anyway!
14:52:40 <geezusfreeek> conal: :P
14:53:01 <geezusfreeek> i just didn't take that in past tense as i now see it was intended
14:53:03 <conal> geezusfreeek: lots of good ideas don't pan out
14:53:31 <christastrophe> does haskell have a pack/unpack library like perl or python? or am I expected to convert Int to Word8 manually?
14:53:31 <malebria> Hello there..
14:53:45 <geezusfreeek> conal: seems to be more often than not for me. i guess that's what happens when your projects are all researchy though
14:53:49 <malebria> I used to program with haskell a lot, but I've been a lot of time without using it.
14:53:58 <malebria> Now I'm just confused with simple compiler errors.
14:54:13 <dolio> christastrophe: What's pack do exactly?
14:54:19 <malebria>     Could not find module `Data.Set':
14:54:19 <malebria>       it is a member of package containers-0.1.0.1, which is hidden
14:54:30 <conal> geezusfreeek: and the ones that didn't work out may be inspire another idea that does, even if for a different purpose.
14:54:34 <dons> christastrophe: use Data.Binary
14:54:34 <mauke> christastrophe: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
14:54:35 <malebria> What's the problem here?
14:54:42 <dons> christastrophe: it provides encode/decode from bytes
14:55:09 <esteth_> Linux esteth-desktop 2.6.22-14-generic #1 SMP Tue Feb 12 07:42:25 UTC 2008 i686 GNU/Linux
14:55:17 <esteth_> wrong window, sorry :(
14:55:49 <gwern> malebria: cabal package?
14:55:54 <malebria> gwern: yes.
14:55:57 <gwern> add 'containers' to build-depends:
14:56:14 <christastrophe> dons: I don't see that listed here: http://haskell.org/ghc/docs/latest/html/libraries/index.html -- is it non-standard?
14:56:21 <dcoutts> gwern: one day we'll be able to have a better error message for that
14:56:25 <conal> geezusfreeek: one reason i try to define fmap via fmap, pure via pure, and <*> via <*> is that, when successful, the resulting definition is more general.  and sometimes turns out to be equivalent to something in a standard library, which means you get to remove the code.
14:56:28 <malebria> gwern: thanks.
14:56:28 <dons> its one of the many non-core libraries
14:56:32 <dons> ?hackage binary
14:56:32 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
14:56:32 <christastrophe> mauke: ha, oopps I missed that . thanks :)
14:56:42 <dons> christastrophe: there's some 500+ libs on hackage.haskell.org
14:56:47 <mauke> christastrophe: hackage is like haskell's cpan
14:56:49 <dons> so often people just refer to those things on 'hackage'
14:56:51 <gwern> malebria: which one is it? I thought most were updated by now
14:56:53 <mauke> only much smaller
14:56:59 <geezusfreeek> conal: ah, yes, i can see how that would be beneficial
14:57:04 <gwern> dcoutts: did you see my recent sdist messages?
14:57:14 <dcoutts> gwern: yep, thanks
14:57:19 <christastrophe> I have yet to venture into hackage... looks like nows the time
14:57:40 <dons> well, binary is certainly one of the most popular packages
14:57:43 <malebria> gwern: it's one I've wrote some time ago.
14:57:47 <malebria> gwern: =)
14:57:48 <esteth_> sprig, here's mine: Linux esteth-desktop 2.6.22-14-generic #1 SMP Tue Feb 12 07:42:25 UTC 2008 i686 GNU/Linux
14:57:51 <dons> you can install it with just: cabal install binary
14:57:54 <esteth_> argh, same window again :(
14:57:57 <dons> if you've set up your haskell dev environment
14:58:01 <geezusfreeek> well, it's time to leave work
14:58:09 <dons> it is probably also available on many distros
14:58:11 <gwern> malebria: ah. is it worth adding to hackage? I do that sort of thing
14:58:12 <dons> i hope so, at least
14:58:31 <malebria> gwern: let me see if it still works.
14:58:39 <malebria> If it does, I'll tell you.
14:58:52 <gwern> dcoutts: actually, I have another question: do you know whether anyone has proposed adding uuagc as one of the precompile tools cabal supports? it'd be neat to be able to upload the EHC compilers to hackage
14:58:55 <conal> geezusfreeek: i discovered this process while playing with the  "DataDriven" FRP implementation, when my data-driven values definition collapsed into simply "type SourceG change m = ((,) change) :. m", for an *arbitrary* monoid change and applicative m.
14:59:18 <noecksit> hello, what is the monad Writer used for?
14:59:27 <christastrophe> hmm. well I'm just using what debian gives me right now. so I'm not sure about how cabal is set up
14:59:29 <conal> noecksit: logging, collecting info as you go
14:59:43 <conal> geezusfreeek: with the usual case being m = IO and o = IO () -> IO ()
14:59:43 <geezusfreeek> conal: nice
14:59:45 <dcoutts> gwern: no reason we couldn't add them, assuming they're reasonably standard pre-processors
14:59:53 <conal> geezusfreeek: surprised me big time!
14:59:57 <noecksit> i understand that Reader is like a constant in imperative languages, but i wonder if i could use Writer instaed
15:00:06 <Botje> noecksit: i've used it to log side effects and execute them after pure code
15:00:07 <gwern> dcoutts: but no one has brought them up before as far as you know?
15:00:09 <conal> geezusfreeek: so now i always look for these patterns.
15:00:10 <mauke> Reader is not like a constant
15:00:19 <mauke> constants are like constants
15:00:26 <malebria> Where do I get the doc for tested-with syntax?
15:00:27 <dcoutts> gwern: are they simple single input, single output pre-processors? or do they need to read other things?
15:00:29 <malebria> in cabal
15:00:51 <geezusfreeek> yeah, this looks like it could become something similar actually
15:00:52 <dcoutts> gwern: to my knowledge nobody has asked before
15:01:03 <gwern> malebria: eg 'tested-with: GHC==6.8.2, GHC==6.6'
15:01:05 <noecksit> well, you execute it with run in the beginning, and then you can't reassign it again, in that case its a constant
15:01:12 <malebria> thanks.
15:01:20 <geezusfreeek> alright time to go. i'll catch up with you later, conal
15:01:28 <mauke> noecksit: like all variables
15:01:29 <gwern> dcoutts: I'm not sure. I thought I had them downloaded, but I apparently no longer do
15:02:04 <dcoutts> gwern: hmm, uuagc has a lot of command line flags
15:02:07 <malebria> gwern: it seems the package is working..
15:02:08 <gwern> apparently ehc is at https://svn.cs.uu.nl:12443/repos/EHC/trunk/EHC
15:02:17 <malebria> gwern: can I send it to you to take a look?
15:02:58 <dcoutts> gwern: apparently it can generate several different kinds of output
15:03:49 <dcoutts> gwern: indeed it even has a -M flag to generate deps
15:04:15 <dcoutts> gwern: so too complex for us at the moment, though perhaps it'd be supportable with Saizan's work after the summer
15:05:39 <gwern> malebria: sure. gwern0@gmail.com
15:05:55 <gwern> dcoutts: what's saizan doing? the make stuff?
15:06:01 <dcoutts> gwern: right
15:10:53 <gwern> dcoutts: looking the makefile, the commands don't seem too hairy
15:10:56 <gwern> '/usr/bin/uuagc --module=MainAG -dcfspr  -Psrc/shuffle/ -o build/shuffle/MainAG.hs src/shuffle/MainAG.ag'
15:11:16 <dcoutts> gwern: but how do we know how many of -dcfspr to use?
15:12:28 <dcoutts> gwern: that, and what is the -P search path for?
15:13:39 <ketil> dons: I'm only reading an Int or two...should it be that costly?
15:14:34 <ketil> ...but I can use readInt from bytestring instead, of course.
15:21:55 <sclv> ?seen ehird
15:21:55 <lambdabot> ehird is in #haskell. I last heard ehird speak 1h 29m 14s ago.
15:24:00 <tromp> > "hi">>"bao"
15:24:01 <lambdabot>  "baobao"
15:24:56 <jamii> This is why maths is more fun in haskell - http://hpaste.org/7674
15:25:21 <dons> :)
15:25:48 <christastrophe> hmm, anyone here working with haskell on a debian system? i'm having a bit of trouble with the 'runhaskell' command
15:27:27 <dons> christastrophe: you have ghc 6.6 or ghc 6.8?
15:27:30 <sclv> ?tell ehird -- unless you want monad transformers *inside* CGIT, and I don't see why, then just make yr custom monad on top of (CGIT IO) and then run all the external bits before you pass the result to runFastCGI and friends..
15:27:30 <lambdabot> Consider it noted.
15:28:03 <christastrophe> dons: 6.6
15:28:38 <dons> christastrophe: what happens?
15:29:27 <christastrophe> I tried running 'runhaskell Setup.hs configure' for your Binary package (0.4.2)
15:29:48 <christastrophe> it complains I'm missing a colon after the field 'flag' on line 22...
15:30:32 <dons> oh, that means you have an old version of cabal
15:30:39 <christastrophe> ah.
15:30:55 <dons> so you need to either update to ghc 6.8.2, or install a newer cabal  (1.2.x or later)
15:31:05 <dons> both options are available for debian in the package
15:33:10 <sclv> ?tell ehird and if you want to use something that can be "turned" into IO inside the CGIT then look at gAtomically in http://code.haskell.org/~sclv/hvac/Network/Frameworks/HVAC/Classes.hs
15:33:10 <lambdabot> Consider it noted.
15:36:20 <christastrophe> dons: thanks, i think I'll try and get ghc6.8 installed
15:37:31 <roconnor> @bab nl en Niet van toepassing
15:37:31 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
15:39:31 <sclv> ?tell ehird, but yeah, this isn't a general solution for putting CGIT around arbitrary monads, but on the other hand, I really don't see a case where wrapping them around CGIT instead will do any harm...
15:39:31 <lambdabot> Consider it noted.
15:41:54 <ehird> Bacq.
15:41:54 <lambdabot> ehird: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:42:00 <ehird> Ha
15:42:02 <ehird> I can just read them here,
15:42:10 <idnar> heh
15:42:22 <ehird> <sclv> ?tell ehird -- unless you want monad transformers *inside* CGIT, and I don't see why, then just make yr custom monad on top of (CGIT IO) and then run all the external bits before you pass the result to runFastCGI and friends..
15:42:33 <ehird> sclv: well, my Nomic computation lasts longer than my CGIT Nomic computation.
15:44:31 <sclv> I don't even see how that makes sense...
15:45:05 <dancor> what is a use-case for fixIO
15:45:22 <sclv> runFastCGI doesn't give you a usable result... it just keeps serving up requests.
15:45:27 <dancor> (and why not fixM instead?)
15:45:36 <dons> dancor: some people use mdo for this stuff
15:45:37 <ddarius> dancor: fixIO is the mfix for IO
15:45:53 <dons> but yeah, its just mfix
15:45:54 <dancor> oh, mfix
15:46:07 <dons> instance MonadFix IO where mfix = fixIO
15:46:07 <dons> instance MonadFix ((->) r) where mfix f = \ r -> let a = f a r in a
15:46:32 <ehird> <sclv> runFastCGI doesn't give you a usable result... it just keeps serving up requests.
15:46:32 <SamB_XP> dancor: the "why not" is because it can look nicer with mdo
15:46:41 <ehird> main = runNomic $ do nomicInit; runFastCGI nomicMain
15:46:53 <ehird> sclv: nomicMain :: CGIT Nomic CGIResult
15:47:04 <ehird> sclv: Note that the nomic monad contains, for example, database connections.
15:47:16 <ehird> sclv: And note that runCGI handles this fine.
15:48:09 <sclv> ehird -- thats coz runCGI just handles a single request. you need to turn your thinking inside out. fastCGI  should be for longlived and persistent apps. you generally want to call it with runFastCGIConcurrent...
15:48:33 <ehird> sclv: I do I was simplifying.
15:48:44 <ehird> sclv: Anyway, nomicInit can be expensive.
15:48:48 <ehird> sclv: so I don't wanna do:
15:48:52 <SamB_XP> ehird: ... why would you want a result?
15:48:53 <ehird> runFsatCGI (nomicInit >> nomicMain)
15:49:05 <ehird> SamB_XP: I don't think you have read, like, any of my past messages.
15:49:25 <SamB_XP> why is anyone mentioning a result?
15:49:33 <sclv> have nomicInit stash its stuff in Mvars or whatever and call them from nomic main
15:50:30 <ehird> sclv: because that's sooooo much more elegant
15:50:38 <sclv> hvac has a channel for database connections that it keeps in a pool, and it grabs one on each request, for example then replaces it at the end.
15:50:55 <sclv> elegant be damned :-P
15:51:01 <SamB_XP> ehird: do you know how fastcgi works?
15:51:20 <ehird> SamB_XP: Yes. You don't know how my messages work though, as you don't seem to have read them.
15:51:31 <ehird> sclv: if I didn't want elegant ... I'd be using php
15:51:54 <sclv> gotta run -- friends' b-day. good luck!
15:52:40 <SamB_XP> ehird: ... where were you hoping for the result to be returned TO?
15:55:06 <Lemmih> SamB_XP: Non-terminating actions are perfectly valid. I don't think ehird is expecting the call to return.
15:55:30 <simony> conal, On page 6, "Applicative Behavior" instead of "Applicative Reactive" seems to not have been fixed
15:55:39 <SamB_XP> Lemmih: one would HOPE
15:56:12 <Lemmih> ehird: Generalizing 'runFastCGI' is hard and generalizing 'runFastCGIConcurrent' is impossible.
15:56:19 <SamB_XP> of course, this is only the case because monads are codata...
15:56:28 <conal> simony: oops!  thx.
15:56:29 <ehird> Bacq.x2
15:56:40 <ehird> <Lemmih> SamB_XP: Non-terminating actions are perfectly valid. I don't think ehird is expecting the call to return.
15:56:42 <SamB_XP> Lemmih: how is generalizing runFastCGI hard?
15:56:42 <ehird> true 'dat.
15:57:01 <ehird> SamB_XP: alloca
15:57:19 <Lemmih> SamB_XP: Exception handling is tough without IO.
15:57:20 <ehird> & other functions that want a function returning IO
15:57:23 <ehird> you can't liftIO them
15:57:31 <ehird> Lemmih: I would be fine with requiring MonadIO
15:57:33 <ehird> But that's not enough.
15:57:34 <conal> simony: i'm pushing a new copy now ...
15:57:36 <SamB_XP> oh, true
15:57:38 <Lemmih> ehird: Is Nomic akind to a reader monad?
15:57:51 <conal> simony: ... done
15:57:54 <ehird> Lemmih: Nomic is .. lots of stuff.
15:57:58 <ehird> Lemmih: Right now, it's just IO.
15:58:01 <ehird> Later, it'll have a DB.
15:58:04 <ehird> Then, maybe some state.
15:58:04 <ehird> etc
15:58:09 <ehird> Lemmih: But it is a MonadIO.
15:58:45 <simony> conal, http://conal.net/papers/simply-reactive/ still seems to display the former.. does it take time to re-render the pdf/etc?
15:58:46 <lambdabot> Title: Simply efficient functional reactivity
15:59:07 <conal> odd.  let me check also ...
15:59:30 <Lemmih> ehird: I'd go with 'runFastCGIConcurrent' and forget about non-mutable state.
15:59:47 <conal> simony: i see the typo fix.  maybe a browser cache thing
16:00:02 <conal> simony: if you're on firefox, try control-shift-r
16:00:08 <simony> conal, indeed a browser cache thing.. browsers suck!
16:00:09 <ehird> Lemmih: Right now, I'm using a Total Hack.
16:00:18 <ehird> Lemmih: runNomic returns a tuple also including the state it was using.
16:00:23 <ehird> Lemmih: And it takes a state parameter.
16:00:23 <conal> simony: the web is demand-driven.  how broken is that?
16:00:24 <SamB_XP> ehird: yeah, I tried to figure out how to deal with that sort of thing
16:00:39 <ehird> Lemmih: Then, on the next run, I call it with the current state and store the new state it gives me (into an IORef)
16:00:42 <simony> conal, very :)
16:00:43 <ehird> (next run = next request)
16:00:44 <conal> simony: i'd like to apply the ideas in my paper to the web.
16:00:47 <SamB_XP> (carrying transformers into functions taking callbacks)
16:00:56 <SamB_XP> but I was not very successful ;-)
16:01:08 <conal> simony: but with a more flexible algebra for push/pull/etc strategies.
16:01:24 <simony> conal, the ideas you present in TV/Eros and others are ones me and a few friends want to take to the web and desktop interfaces too
16:01:26 <conal> simony: also to code recompilation, re-testing, etc
16:01:41 <conal> simony: hurray!  me too.  :)
16:01:48 <simony> conal, mind if I take it private?
16:02:00 <conal> simony: do
16:03:32 <ehird> simony: i have a webtv project.
16:03:35 <Lemmih> ehird: I'd use a Reader monad + an IORef/MVar if I were you.
16:03:50 <conal> simony: are you sending me a priv msg?  i'm not getting one.
16:04:26 <simony> conal, Yeah I sent you plenty
16:04:32 <tieTYT> as a best practice, should I be using head/tail when possible even if I could use take/drop?
16:04:33 <simony> conal, maybe you have some privmsg ignore rule?
16:04:58 <conal> simony: hm.  others get through fine. i also /query 'd you
16:05:00 <simony> conal, oh wait, I'm an unregistered user and blocked, sec
16:05:12 <conal> k
16:05:18 <ehird> tieTYT: they are subtly different
16:05:34 <tieTYT> right, i notice take returns a list and head returns an.... atom?
16:05:37 <Saizan> conal: do you know of where i could find a collection of possible "evaluation strategies" for a FRP expression with comparisons? i've just read your simply-reactive paper and wanted to understand better differences between e.g. pull/push
16:05:37 <tieTYT> is that the word to use?
16:06:09 <ehird> <tieTYT> right, i notice take returns a list and head returns an.... atom?
16:06:15 <monochrom> element or item
16:06:17 <ehird> i think you're quite confused
16:06:27 <simony> conal, still nothing?
16:06:32 <tieTYT> why?
16:06:47 <tieTYT> what did i say that was wrong
16:06:56 <monochrom> I refuse the word "atom" because:
16:07:02 <monochrom> > head [ [1,2], [3,4] ]
16:07:04 <lambdabot>  [1,2]
16:07:07 <monochrom> not atom
16:07:16 <tieTYT> ok
16:07:17 <Lemmih> ehird: Nah, he's just looking for the right term.
16:07:31 <tieTYT> so i guess i should have said it returns the first element of the list
16:07:40 <tieTYT> tail returns a list missing the first element
16:07:41 <ehird> tieTYT: yes
16:07:41 <monochrom> "element" and "item" are more vague, allowing list of list of list of tree of record of array.
16:09:00 <monochrom> type-oriented programming is a cultural shock. complex data structures are fathomed by few.
16:10:02 <tieTYT> i have a little scheme background
16:10:07 <tieTYT> that's helping me a bit
16:10:21 <ehird> <monochrom> type-oriented programming is a cultural shock. complex data structures are fathomed by few. and in the darkness bind them?
16:10:22 <tieTYT> but yeah, i don't get it yet.  Working on it
16:10:46 <ehird> one monad to rule them all
16:10:50 <monochrom> hahaha
16:11:14 <monochrom> Let's add "and in the darkness bind them" to every sentence henceforth. and in the darkness bind them.
16:12:03 <ehird> okay and in the darkness bind them
16:12:42 <ehird> I wonder how long before someone's sick mind reads and in the darkness bind them
16:12:49 <ehird> we'll move them to -blah and in the darkness bind them
16:13:40 <Boney> urgh,  I just glanced over at my irc window.
16:13:54 <Boney> and started with 09:12 < ehird> I wonder how long before someone's sick mind  reads and in the darkness bind them
16:14:09 <Boney> not what I was expecting.
16:14:17 <ehird> Boney: I'm sorry to hear that and in the darkness bind them.
16:14:41 <Boney> Whoops. I've not been saying and in the darkness bind them and in the darkness bind them.
16:14:52 <Boney> :-)
16:15:46 <monochrom> @quotez bind
16:15:46 <lambdabot> ghc says: bindings for unlifted types aren't allowed
16:15:54 <monochrom> @quotez darkness
16:15:54 <lambdabot> apfelmus says: Ah, yet another UndeadArray necromancer exhausting his stack of bones. May the forces of light suggest to structure the incantation of darkness?
16:16:06 <monochrom> @quotez the darkness
16:16:06 <lambdabot> No quotes for this person. Take a stress pill and think things over.
16:16:11 <monochrom> @quotez the.*darkness
16:16:11 <lambdabot> apfelmus says: Ah, yet another UndeadArray necromancer exhausting his stack of bones. May the forces of light suggest to structure the incantation of darkness?
16:16:36 <monochrom> @quotez the.darkness
16:16:36 <lambdabot> No quotes match. You type like i drive.
16:16:50 <monochrom> @quotez darkness.*bind
16:16:50 <lambdabot> No quotes match. :(
16:18:29 <Boney> mabye lambdabot has a sillyness filter.
16:18:36 <Boney> but then,
16:18:37 <Boney> @yow
16:18:37 <lambdabot> RHAPSODY in Glue!
16:19:08 <ari> @protontorpedo
16:19:08 <lambdabot> why haskell over say clsip or smalltalk?
16:22:15 <Saizan> @keal
16:22:15 <lambdabot> are there full body recognition files for sorting art?
16:22:41 <mauke> preflex: be PoppaVic
16:22:41 <preflex>  yeah, but is amazingly issue is, problem: not mine.
16:23:18 <ehird> mauke: oh wow
16:23:27 <ehird> I always held that poppavic was a bot
16:23:57 <ehird> preflex: help
16:23:58 <preflex>  try 'help help' or see 'list' for available commands
16:23:58 <mauke> sadly, the quote above is 100% real and human
16:24:04 <ehird> mauke: jesus
16:24:07 <ehird> not a markov?
16:24:10 <mauke> nope
16:24:12 <ehird> preflex: be PoppaVic
16:24:12 <preflex>  you know? I think is another context where you share an interface. How many wrenches you own? Metric? Ansi? blind? Ever rivet or weld?
16:24:17 <ehird> ...
16:24:19 <ehird> that is not real
16:24:34 <mauke> BEHOLD! the power of PoppaVic
16:25:37 <Cale> preflex: be PoppaVic
16:25:38 <preflex>  trigraphs remind me of "escapes" - which means "well, we agree - but what do we send and what does it do?"
16:27:08 <ehird> mauke: Is that real?
16:27:12 <mauke> yep
16:27:19 <ehird> mauke: I've seen poppavic be a retard
16:27:21 <ehird> but not THAT retarded
16:27:29 <ehird> mauke: who IS he, anyway?
16:27:36 <mauke> I have no idea
16:27:46 <ehird> i've always pictured him as some kind of middle-aged fart who goes on and genuinely believes he's correct
16:27:49 <ehird> & not talking nonsense
16:29:02 <ehird> mauke: first result for poppavic on google
16:29:03 <ehird> http://profile.myspace.com/index.cfm?fuseaction=user.viewprofile&friendid=96116392
16:29:03 <lambdabot> http://tinyurl.com/5vup94
16:30:15 <ehird> preflex: be PoppaVic
16:30:15 <preflex>  Now, yes. I have no issue with funcs that imply "STFU" to the compiler, and they tend to be internal. I also have no issue with a program crashing after screaming. Once again, YMMV
16:30:38 <mauke> see also http://ortdotlove.net/poppavic_wisdom.html
16:30:39 <lambdabot> Title: Words of Wisdom from PoppaVic
16:39:50 <ehird> I should put a bot in ##c which swallows up everything poppavic says
16:39:56 <ehird> and maintains a database
16:41:08 <Apocalisp> LtU fans: I'm looking for the name of a declarative language used for specifying hardware systems.
16:41:53 <ehird> hm
16:42:00 <ehird> dependently typed systems can make (head []) a type error right?
16:42:04 <ehird> But surely that must be at run-time?
16:43:05 <Saizan> not necessarily
16:43:36 <ehird> Saizan: Let's say I write a program that breaks its stdin into lines
16:43:39 <ehird> Then does (head lines)
16:43:44 <ehird> that can ONLY be at runtime- surely?
16:44:07 <stepcut> ehird: the type system might force to to first ensure that lines is not null
16:44:24 <ehird> stepcut: ahh, i see
16:44:28 <stepcut> ehird: so, head . lines, would not type check
16:44:33 <ehird> stepcut: that's kind of nifty
16:44:38 <ehird> stepcut: what is the type of head?
16:44:44 <ehird> extend haskell's notation liberally to do it
16:44:46 <ehird> i can understand that
16:44:56 <EvilTerran> head :: NonEmptyList a -> a
16:45:29 <noecksit> hello, i need to use a monad that saves the thread id of a forked thread when a user clicks a button, and kill the thread later when the user clicks another button
16:45:32 <EvilTerran> on the other hand, i think lines :: String -> NonEmptyList String, so maybe it would typecheck...
16:45:40 <EvilTerran> ?src lines
16:45:40 <lambdabot> Source not found. Just try something else.
16:45:43 <EvilTerran> bah
16:45:44 <ehird> EvilTerran: lines ""
16:45:45 <ehird> -> []
16:45:49 <EvilTerran> > lines ""
16:45:51 <lambdabot>  []
16:45:52 <noecksit> which monad would u suggest using, reader, writer, or state?
16:45:55 <stepcut> ehird: something like, (NotEmpty [a]) ~> head :: [a] -> a
16:45:57 <EvilTerran> huh. thought that would be [""]
16:46:05 <ehird> EvilTerran: hmm, good point
16:46:06 <ehird> > lines "a"
16:46:07 <lambdabot>  ["a"]
16:46:09 <ehird> ..
16:46:11 <ehird> @src lines
16:46:11 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:46:13 <ehird> ...
16:46:18 <ehird> that is TOTALLY broken
16:46:19 <EvilTerran> > lines "\n"
16:46:20 <lambdabot>  [""]
16:46:35 <ehird> i can ... kinda see the logic
16:46:40 <ehird> EvilTerran: if you press ctrl-D immediately
16:46:42 <ehird> you entered no lines at all
16:46:44 <ehird> but .. even so
16:46:48 <ehird> that's kinda .. broken
16:47:00 <dons> dcoutts: it matters which order you put parameters over 2, for register use.
16:47:11 <dcoutts> dons: hmm?
16:47:19 <dons> i can double perforamance in an inner loop by reordering function parameters, leading to less moves in the inner loop
16:47:30 <dons> i'm going to open a ticket for it.
16:47:37 <dcoutts> dons: sounds like something the code gen should handle
16:47:40 <dons> yeah.
16:47:52 <ehird> stepcut: hmm
16:47:56 <EvilTerran> see, that sort of thing's why i prefer sticking to programming language theory and hiding from compiler theory ;)
16:47:58 <ehird> stepcut: can you write a function:
16:48:01 <ehird> build 1 a => [a]
16:48:04 <ehird> build 2 a b => [a,b]
16:48:07 <ehird> in a dependent system?
16:48:09 <ehird> it's like:
16:48:09 <mauke> > unlines []
16:48:10 <dcoutts> dons: anyway, for loops like that it should not be passing parameters and everything should be in registers
16:48:10 <lambdabot>  ""
16:48:13 <mauke> > unlines [""]
16:48:14 <lambdabot>  "\n"
16:48:20 <ehird> (ValueOf a b) ~> build :: a -> ... something ..
16:48:21 <dons> dcoutts: in registers, i mean.
16:48:24 <ehird> .or ... I don't know
16:48:29 <EvilTerran> ehird, yes
16:48:36 <ehird> EvilTerran: what is the type of build
16:48:40 <EvilTerran> (depending on the system)
16:48:40 <ehird> EvilTerran: & how does this work:
16:48:44 <ehird> build a b c d
16:48:46 <ehird> where a!=3
16:48:49 <ehird> does it make you ensure that a=3?
16:48:56 <EvilTerran> the latter will not typecheck, i suspect
16:49:02 <ehird> EvilTerran: would this:
16:49:07 <EvilTerran> unless its type indicates what number it must be
16:49:07 <ehird> if a == 3 then build a b c d else []
16:49:20 <EvilTerran> depends on the system
16:49:38 <ehird> EvilTerran: list of a few dep-type systems?
16:49:39 <EvilTerran> but probably not in most
16:49:53 <dons> dcoutts: http://hpaste.org/7676
16:50:03 <EvilTerran> if that "a" had the type IntVal3 instead of, say, Int, it'd work
16:50:26 <EvilTerran> er, s/Val3/Val 3/
16:50:50 <ehird> <Sgeo> e.g. comex's point score as of this point in my determination is 0 + 42 + (10+1+4+5  + 1,000,000 + xkcd +1 - 9543331207720871041898 - 1000000000000000000th-digit-of-pi - g_(10+1+4+5  + 1,000,000 + xkcd +1 - 9543331207720871041898 - 1000000000000000000th-digit-of-pi))%10
16:51:05 <dons> dcoutts: so it can matter at the moment which order we put values in pairs
16:51:08 <stepcut> ehird: I am not sure how many dependent type systems allow functions with a variable number of arguments
16:51:10 <EvilTerran> but, if you could ensure the value at compile-time you probably wouldn't be using the (==3) check
16:51:11 <dons> in foldl loops and other accumulators
16:51:29 <ehird> stepcut: AWESOME ONES RITE
16:51:55 <Saizan> dolio has written zipWithN in Agda2, not entirely straighforward
16:52:00 <dcoutts> dons: "addsd %xmm5, %xmm0" means "%xmm0 := %xmm0 + %xmm5" ?
16:52:01 <Saizan> but it's a variadic function
16:52:28 <ehird> Is it easy to write a toy dependently-typed system?
16:52:30 <dons> dcoutts: yeah, iirc.
16:52:31 <ehird> I have an urge to. :3
16:52:34 <stepcut> ehird: but, for a simple function like, f a b c d, you could have the type system enforce that a != 3.
16:52:39 <ehird> I want to give it LEEEEMITLESS POWAH.
16:52:42 <dons> its the stupid moves from xmm6 to xmm0 and back each time around
16:52:48 <dons> that cause the slow down
16:52:52 <dcoutts> dons: so that does look purely like a register allocator issue, have you tried both reg allocators?
16:53:04 <dons> that's the C backend, when fed to gcc. otherwise it comes out horribly
16:53:31 <dons> the floating point code is a mess in the native gen
16:53:31 <dcoutts> dons: what? that's what gcc produces?
16:53:35 <dons> yeah
16:53:36 <stepcut> ehird: in order to call that function, you would first have to have some sort of proof that it 'a' could never be 3, for example, if a != 3 then f a b c d else someOtherFuntion
16:53:45 <dons> so gcc is not doing a good job
16:53:47 <dcoutts> dons: well then that's gcc's fault
16:53:52 <dons> ghc's fault :)
16:53:57 <dons> let me check -fasm
16:54:05 <Saizan> ehird: http://people.cs.uu.nl/andres/LambdaPi/index.html
16:54:06 <lambdabot> Title: A Tutorial Implementation of a Dependently Typed Lambda Calculus
16:54:24 <stepcut> ehird: the compiler would see that 'a' could never be 3 when you call 'f a b c d', and would allow that to pass the type checker.
16:54:30 <ehird> Saizan: interesting!
16:54:37 <ehird> stepcut: um, a must be 3 for that to work
16:54:39 <ehird> just fyi
16:54:39 <dcoutts> dons: I don't see why you say it's ghc's fault, it's gcc doing silly register allocation
16:54:45 <dons> yeah, no, my mistake.
16:55:06 <dons> i was chasing another issue (needless boxing), and spotted this one when writing the core i wanted directly
16:55:14 <dcoutts> dons: that's with gcc -O2 ?
16:55:16 <dons> but its gcc (and probably my older gcc)
16:55:17 <dons> yeah.
16:55:20 <stepcut> ehird: ?
16:55:32 <dcoutts> dons: have you tried any other gcc flags on that?
16:55:39 <dons> no.
16:55:42 <dcoutts> or gcc versions
16:55:43 <ehird> stef_: f a b(1) c(2) d(3)
16:55:43 <dons> but that's an optionn.
16:55:48 <ehird> first parm is argc
16:56:26 <ehird> so are dependently typed systems practical? it seems like they'd cover the remaining stuff that haskell can't catch at compile-time
16:56:48 <dons> huh, -fasm puts the same moves in.
16:56:54 <dons> so now it is a register allocator issue
16:57:41 <dons> but the codegen also moves the int value around needlessly
16:58:35 <stepcut> ehird: They are not practical as general purpose languages today, but in the early days I suspect Haskell wasn't either.
16:58:40 <dons> so that's a new thing: parameter order at the core level can affect the register allocation directly
16:58:46 <dons> in both -fasm and C backends
16:59:10 <ehird> stepcut: I think I will write a language with a TC type system (recursive types and stuff too) that is dependently typed
16:59:14 <ehird> and unifies types and values
16:59:19 <ehird> and has type-types to an infinite level
16:59:22 <ehird> :DDDDDDDDDDd
16:59:35 <stepcut> ehird: :)
16:59:45 <Saizan> mmh isn't that Cayenne?
17:00:08 <ehird> Saizan: SHUT UP. Nobody ever gets ideas as good as mine. La la la la I can't hear you
17:00:08 <ehird> <__<
17:00:11 <dons> dcoutts: the parameter order entirely determines the order of instructions in the inner loop
17:00:19 <dons> i didn't know that  -- but it makes sense
17:00:31 <stepcut> ehird: Coq is probably one of the most actively used dependently typed languages in use -- but people use it more for proving things than writing applications
17:00:49 <ehird> stepcut: Yeah 'xactly.
17:00:52 <ehird> Coq is pretty darn foreign.
17:00:56 <ehird> 'Course, so is my idea.
17:01:04 <ehird> But it's foreign in a more 'oh, that's an obvious idea' kind of way.
17:01:25 <ehird> test :: head [Int,Str]
17:01:26 <ehird> test = 2
17:01:27 <ehird> :DDDDDDDDDD
17:01:28 <dcoutts> dons: I don't think it should affect it except for the initial register assignments on entry to the function, once we're into a loop it should have complete freedom
17:01:47 <dcoutts> dons: especially since reg moves outside the loop are cheap compared to those inside
17:01:57 <dons> right, but in practice, the registers used are determined by the parameter order
17:02:12 <dons> which then affects which things have to be moved in the inner loop
17:02:36 <dcoutts> that's backwards
17:02:41 <dons> i can reorder the parameters 3 different ways, and get 3 different inner loops, with 3 different runtimes :)
17:03:04 <dons> so the fast example i used on the blog was lucky -- i picked the parameter order correctly
17:03:07 <ehird> test :: if reimannHypothesis then Int else Str
17:03:09 <ehird> test = 2
17:03:12 <ehird> DOES IT TYPE-CHECK???
17:03:16 <dons> i'd not thought to try reordering things
17:03:16 <dcoutts> dons: have you tried with gcc -O11 :-) ?
17:03:21 <dons> let me see.
17:03:47 <dcoutts> ehird: if you can provide a proof at the type level then yes, but good luck with that.
17:04:00 <ehird> dcoutts: that'd actually just run until reimannHypothesis terminated.
17:04:06 <ehird> dcoutts: at compile time.
17:05:02 <dons> dcoutts: no, you can still get variation
17:05:10 <dons> so my gcc is not so hot.
17:05:33 <dcoutts> dons: variation in the number of reg-reg moves in the loop?
17:06:50 <dcoutts> dons: how about if you force gcc to use x87 insns rather than the xmm regs
17:09:46 <ehird> Hmm.
17:09:46 <ehird> build :: Int~a -> fix (\t i -> if i == 0 then [b] else b -> t (i-1)) a
17:09:51 <dons> dcoutts: hang on, let me sort this out.
17:09:59 <ehird> Awesome, or not awesome?
17:10:03 <ehird> THough I need some 's in ther
17:10:04 <ehird> e
17:10:20 <ehird> build :: Int~a -> fix (\t i -> if i == 0 then ['b] else 'b -> t (i-1)) a
17:11:45 <monochrom> dolio: Control.Monad.Omega is scary! Deep magic! :)
17:12:55 <dons> these reg-reg moves are annoying
17:14:20 <ehird> Is my build thing correct for a dep-typed lang?
17:16:26 <dons> dcoutts: this affects fused code somewhat, since fusion effectively determines an argument order based on the pipeline order
17:16:38 <dons> so foldl (1,2) (enumFromTo 3 10)
17:16:44 <dons> puts 3 1 2 in registers 1 2 3
17:16:58 <dons> but to get gcc to behave, i want the enum in the 3rd register :)
17:17:13 <dons> if i explictily fuse i get to decide the register allocation
17:17:28 <dcoutts> dons: this should all be done by the native code gen
17:17:32 <dons> yep.
17:17:57 <dons> its a good example of the kind of thing that should work
17:18:13 <dcoutts> yes, file it as an example for the native code gen
17:18:16 <dons> i'll add it to the native codegen examples ticket
17:18:25 <dcoutts> and how it can and should do better than gcc in this example
17:18:25 <monochrom> This is royally annoying even if I hand-fuse, since how and why would I order my parameters the "right" way...
17:18:34 <dons> it does mean i can't get the same performance from the fused version
17:18:43 <dons> due to 2 extra reg-reg moves in the inner loop
17:18:45 <dolio> monochrom: Don't look at me, I didn't make it.
17:18:52 <dcoutts> dons: it's a tough life :-)
17:19:08 <dons> so close, yet so far
17:19:10 <dcoutts> dons: at least you can explain why it's not your fault :-)
17:19:10 <dolio> dons: Here's a question for you.
17:19:24 <dons> dcoutts: yeah. i bet if i play around with gcc, i can get it to work
17:20:02 <dolio> dons: Is "loop x = ... loop x' where y = f x" usually slower than "loop x y = ... loop x' (f x')" for, say, Ints x and y?
17:20:09 * monochrom goes back to the "this algorithm is O(n) and constant factors don't matter" world. :)
17:20:17 <dons> dolio: nope.
17:20:28 <dons> dolio: assuming the strictness analyser has at it.
17:20:35 <dons> which for Int it does.
17:20:40 <dons> monochrom: :)
17:21:02 <dolio> So the former will get all unboxed and register allocated and such instead of heap allocating y?
17:21:07 <dons> we're at the point that controlling instruction scheduling in the haskell src level matters :)
17:21:18 <dons> since everything else is optimised perfectly
17:21:32 <dons> dolio: yeah, that let will become a let!
17:21:38 <dons> for Int, since its so cheap
17:21:44 <dons> 'where' is often used like this
17:21:44 <dolio> Okay.
17:21:56 <dons> install ghc-core, and look at some examples
17:22:01 <dons> easy way to learn.
17:23:19 <dons> dcoutts: this discovery that -optc-O2 optimises the computed jumps is so so useful
17:23:34 <dons> we get much better code from the C backend consistently for the type of fused loops now
17:23:36 <int-e> monochrom: it's not a monad though ;)
17:23:39 <mib_budcz8> does anyone know how to install wxhaskell ?
17:23:48 <dcoutts> dons: mm
17:23:55 <mib_budcz8> please help me, i need it for a project fast
17:24:07 <dmwit> ?where wxhaskell
17:24:08 <lambdabot> http://wxhaskell.sourceforge.net/
17:24:12 <mib_budcz8> the new version seems to be givin some bugs
17:24:26 <mib_budcz8> so i was told of u guys expertise
17:24:29 <monochrom> wxhaskell installation is becoming a faq
17:24:51 <dcoutts> dons: as I understand it, the fact that gcc produced those computed jumps was always considered a bug but JaffaCake had a hard time preventing them as gcc versions come and go
17:24:53 <dmwit> Are you installing from source, or a binary?
17:24:55 <mib_budcz8> it would be nice if u made a faq :)
17:25:14 <mib_budcz8> binary
17:25:44 <mib_budcz8> keeps giving me a .//dll msw32.wxhask..dll error
17:26:04 <monochrom> the windows story is even worse...
17:26:08 <mib_budcz8> a link error or something
17:27:00 <mib_budcz8> installing it on linux was easy, but the laptop i was usjing was taken
17:27:48 <mib_budcz8> giving me errors on windows, even tried installing wxwidgets, and calling the dll in ghc and still get a error
17:30:23 <GavinMcG> Hi, all! Third question on the day: Can someone please explain what, for example "data Triple a b c = Triple a b c" means? I understand the "data" keyword, but could you please break the rest down, especially regarding what the left half and the right half each mean?
17:30:42 <mbz> mib_budcz8: have you tried this: http://wxhaskell.sourceforge.net/building-msc.html
17:30:48 <lambdabot> Title: wxHaskell - Building - Visual C++
17:32:28 <monochrom> The two "Triple" are different things.
17:32:38 <Saizan> GavinMcG: the left half declares how the type looks like, the right half declares how values of that type look like :)
17:33:41 <monochrom> The LHS: "data Triple a b c" means the type name is Triple with three type parameters. Henceforth you can haz types like "Triple Int Bool String", etc.
17:34:31 <GavinMcG> Saizan: Ok, so when I declare a function "tripleFirst (Triple a b c) = a" why is it that I have to include the entire "Triple a b c" rather than just "Triple" ?
17:34:40 <mbz> hmm, a stupid question. how do i define a data type in ghci prompt?
17:34:57 <monochrom> The RHS: that "Triple" is a data constructor, not a type name. This constructor takes three value parameters. Henceforth 'Triple 5 True "hey" ' is a valid value.
17:35:23 <monochrom> It is pure coincidence that the LHS looks like the RHS.
17:36:10 <Saizan> GavinMcG: what monochrom said, also because so you can get at the values inside your Triple
17:36:27 <monochrom> It is a requirement of pattern matching to have the entire "Triple a b c" there. No other reason.
17:36:37 <Saizan> we use the same syntax for constructing values and for taking them apart
17:36:53 <monochrom> BTW the "Triple a b c" there corresponds to the RHS, not the LHS.
17:37:48 <mbz> and when the LHS (data type name) is used?
17:38:11 <monochrom> Suppose you have "data X a b c = F a b | G b c".  Then you can write a function like: f (F a b) = ...; f (G b c) = ...
17:38:34 <monochrom> You are not allowed: f (F a) = ... or f F = ...
17:39:04 <GavinMcG> monochrom, Saizan: Thank you. I think I understand. Just called to dinner, I'll be sure to check in if I have another question. Thanks again!
17:39:09 <monochrom> I can design a language and a compiler to allow it. But I doubt its utility.
17:39:14 <GavinMcG> That comma should have been a ;
17:39:36 <monochrom> Don't worry we aren't grammar nazis :)
17:40:40 <Saizan> monochrom: well, that's almost like record syntax
17:41:07 <Saizan> mbz: in type signatures
17:41:56 <monochrom> Suppose f (F a) = ... is allowed. Its type will be (b -> c -> X a b c) -> ...
17:42:38 <monochrom> oops, (b -> X a b c) -> ...
17:43:13 <mbz> i got, thanks
17:43:50 <monochrom> I doubt if anyone needs this feature at a very high priority. There are few uses of the non-fully-applied "F a".
17:44:09 <edwardk> monochrom: ?
17:44:34 <monochrom> Compiler writers' lives are also much simpler if they can assume "data constructors are fully applied" once in a while.
17:45:59 <edwardk> ah just found it in the logs
17:46:07 <monochrom> On a different note, I think it's a crime to use examples like "data Ctor ... = Ctor ..." in very beginning tutorials. The overlapping Ctor is a recipe for trouble.
17:47:46 <edwardk> monochrom: i've occasionally thought about allowing partially applied data constructors in patterns, its just got some crazy semantics that i haven't figured out how to make uniform across all cases.
17:53:06 <dmwit> monochrom: Yeah, it took me a few reads on that paragraph of the Gentle Intro to understand that subtlety.
17:53:18 <dmwit> monochrom: (Though at least there they mention what's going on.)
17:54:44 <Saizan> yaht was totally confusing in that chapter
17:54:46 <monochrom> I had Perl experience before I came to Haskell, i.e., $x, @x, %x are three distinct x's. So it wasn't hard on me. But it's a crime.
17:55:16 * edwardk waves hello to cmarcelo
17:55:34 <monochrom> In a few years, no haskell newbie will start with Perl experience. Can't rely on it. :)
17:56:10 * edwardk just realized that if it hadn't been for trying to track cmarcelo down on this channel about the hsjudy bindings a couple years back I never would have really immersed myself in Haskell.
17:56:51 <monochrom> All roads lead to Haskell.
17:57:15 <Saizan> i think it's also a crime to not mention that the use of parentheses is totally different from C-like syntax, at least in these days
17:57:17 <monochrom> Haskell leads to Paradise.
17:57:45 <dmwit> I think most tutorials do mention that pretty early, to be fair.
17:58:14 <monochrom> Like f(x,y) vs f x y vs [(x,y)]?
17:58:41 <monochrom> They stole it from stupid mathematicians. It's a much more entrenched problem.
17:59:23 <dons> dcoutts: http://hackage.haskell.org/trac/ghc/ticket/2289 affects us.
17:59:24 <dmwit> Yes, but who created the chaos?
17:59:25 <edwardk> f(x) always struck me as flawed notation.
17:59:30 <lambdabot> Title: #2289 (Needless reboxing of values when returning from a tight loop) - GHC - Tra ...
17:59:45 <dons> needless reboxing when returning from tight loops, just to use the result
17:59:46 <monochrom> Algol.
18:00:01 <monochrom> Most likely before Algol, too.
18:00:10 <fatalerrorx> just wadering what does someting like this mean in haskell simpleHTTP nullConf {port=5000} [blah blah]
18:00:25 <fatalerrorx> what on earth does {port=5000} mean?
18:00:31 <pjdelport> fatalerrorx: record syntax
18:00:32 <dmwit> It's a record update.
18:00:40 <fatalerrorx> record update?
18:00:48 <dmwit> Some data types are "records".
18:00:50 <monochrom> nullConf {port=5000}  is one piece
18:00:53 <dmwit> They are declared like this:
18:01:08 <dmwit> data RecordGuy = Constructor { name1 :: type1, name2 :: type2 }
18:01:19 <fatalerrorx> oh ok
18:01:22 <edwardk> fatalerrorx: That makes a copy of the record returned by simpleHTTP nullConf, giving you a copy of it with its 'port' field to 5000.
18:01:28 <dmwit> This defines an accessor "name1 :: RecordGuy -> type1" and an updater.
18:01:46 <edwardk> er
18:01:50 <edwardk> nullConf
18:01:50 <dmwit> The syntax of the updater is "someValueOfTypeRecord { name1 = newName1Value }"
18:02:12 <dcoutts> dons: yes, that's a bit odd
18:02:26 <fatalerrorx> RecordGuy { value1 = 3 } ????
18:02:33 <dcoutts> dons: I'd expect the strictness analyser to get that
18:02:34 <fatalerrorx> would that be correc
18:02:58 <dmwit> No, RecordGuy is a type.
18:02:59 <_JFT_> Hello, is anybody familiar with the package hmatrix?
18:03:10 <dmwit> Constructor { name1 = 3, name2 = 5 } -- this would be correct
18:03:12 <dcoutts> dons: I wonder if it's the strictness or the worker/wrapper that is failing us here
18:03:30 <fatalerrorx> oh ok thanks a bunch
18:03:45 <dons> dcoutts: yeah, and i don't know why we get an extra test at the start of the loop either
18:04:03 <dons> i'd have thought the boxing would only affect the exit
18:04:06 <dcoutts> dons: heap check?
18:04:17 <dons> ah. so it now needs to check, since it might exit at any point
18:04:19 <dons> hmm
18:04:21 <dcoutts> dons: since it's boxing it has to be allocating
18:04:36 <dons> yeah, you'd think the check could happen on the way out.
18:04:41 <dons> interesting
18:04:57 <dons> now, to add the one about register allocation
18:05:08 <dons> i'd like to be able to get in and fix this stuff
18:05:16 <dons> need to hang out with simonmar some more
18:05:26 <dcoutts> dons: no, the heap check only gets done on entry, I've filed bugs about that in the past too
18:05:37 <dons> urgh
18:05:50 <dons> yeah, so that's doubly bad then
18:05:56 <dcoutts> dons: it's bad because it means that in a tail recursion we do a heap check every iteration even when we only allocate in the exiting branch
18:06:00 <dons> since it hits every loop that boxes on the way home.
18:06:19 <dons> if we write the recursion by hand, we can move the division inside the loop exit
18:06:26 <dons> then there's no heap check
18:06:38 <dons> if only i could fuse: uncurryS (/) . foldU k
18:06:48 <dons> so that the division would move inside the fold's exit branch
18:06:52 <dons> we'd avoid the boxing
18:07:46 <dons> instead, we get the current code, with the pair created, and then boxed
18:08:05 <dcoutts> dons: the pairs are ok, it's the D# I# that's problematic
18:08:07 <dons> its annoying, since folds remaing less performant
18:08:19 <dons> since they're forced to box their return
18:08:23 <dons> and thus pay a heap check
18:08:41 <dons> yeah (# , #) is fine
18:08:53 <dons> so we can do the division on the outside
18:12:52 <visof> what is the meaning of "Setup.hs:22:15: Not in scope: `compilerPath'" ?
18:13:32 <mbz> `undefined symbol' i guess
18:14:22 <OceanSpray> Is there a special name for a case expression with only two branches?
18:18:53 <mbz> guys, is it possible to define a new data type using ghci prompt?
18:19:06 <mbz> or i've to write it to the file and reload it?
18:20:20 <dons> dcoutts: so we fix the reboxing, and sort out the register allocator, and that's it. the fused version is exactly the same as C.
18:20:24 <dons> :D woot.
18:20:35 <dcoutts> @yarr!
18:20:35 <lambdabot> Har de har har!
18:31:01 <dmwit> mbz: You have to use a file.
18:31:34 <dmwit> OceanSpray: "if"?
18:31:53 <OceanSpray> except "if" is already taken.
18:32:11 <OceanSpray> I'm actually thinking of this.
18:32:28 <OceanSpray> Let's say there's a hypothetical language with pattern matching.
18:33:04 <OceanSpray> Its lambda expressions have pattern matching built in, much like Haskell.
18:33:37 <OceanSpray> Now, the only difference is that these lambdas take more "arguments"
18:33:50 <pjdelport> dmwit: either isn't boolean
18:33:56 <OceanSpray> the pattern to match against, the expression to evaluate in the resulting environment,
18:34:20 <OceanSpray> and an 'alternate' function of the same type signature, to apply to the arguments if the match fails.
18:34:22 <dmwit> pjdelport: It is when combined with isLeft.
18:34:52 <dmwit> OceanSpray: Maybe you are looking for a catamorphism.
18:34:59 <dmwit> OceanSpray: Here's an example of a handy one:
18:35:01 <dmwit> :t either
18:35:12 <dmwit> uh...
18:35:12 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
18:35:21 <dmwit> :t maybe -- another one that I use a lot
18:35:23 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:35:41 <pjdelport> :t foldr
18:35:42 <dmwit> OceanSpray: Your language could potentially define catamorphisms automatically.
18:35:44 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
18:35:51 <dmwit> pjdelport: Great example. =)
18:36:09 <OceanSpray> catamorphisms, eh?
18:36:31 <pjdelport> cata, ana, hylo, meta, chrono, synchro!
18:36:37 <dmwit> I've got to go, but plenty of people here can explain them. =)
18:37:33 <pjdelport> OceanSpray: have you read http://citeseer.ist.psu.edu/meijer91functional.html ?
18:37:45 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
18:38:00 <OceanSpray> no, I have not.
18:38:01 <OceanSpray> what is it?
18:38:29 <pjdelport> it's one of the classic papers on the subject
18:38:52 <OceanSpray> oh wow, it's pretty long.
18:40:00 <pjdelport> OceanSpray: basically, every algebraic data type has an associated catamorphism and anamorphism, which mirror its definition
18:40:44 <pjdelport> loosely speaking, the catamorphism breaks it down, and the anamorphism builds it up
18:40:45 <edwardk> pjdelport: ignoring exponential functors ;)
18:41:17 <pjdelport> (mnemonic: think "catastrophe" and "anabolic")
18:42:37 <pjdelport> OceanSpray: for each constructor, a catamorphism takes a function of the same signature
18:42:56 <pjdelport> to replace it with, intuitively
18:43:06 <OceanSpray> hmm.
18:43:20 <pjdelport> recursion in the type is replaced with recursion of the catamorphism
18:43:31 <pjdelport> @src foldr
18:43:31 <lambdabot> foldr f z []     = z
18:43:31 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:43:42 <pjdelport> @src []
18:43:42 <lambdabot> data [] a = [] | a : [a]
18:44:16 <edwardk> you could view a catamorphism on lists as taking a binary function for what to do with a cons cell, and a value to plug in for nil, then starting from the end of the list and rolling up' the result to give you an answer like foldr does
18:44:20 <pjdelport> OceanSpray: note how z "replaces" [], and f replaces (:)
18:45:18 <edwardk> a catamorphism for decorated trees would do the same thing, it would take a value to plug in for the leaves, and a ternary function that gets applied to the nodes
18:45:37 <pjdelport> OceanSpray: and the second argument to (:) is recursed into by foldr
18:46:49 <pjdelport> http://en.wikipedia.org/wiki/Catamorphism has an example of the catamorphism of a Tree type
18:46:55 <pjdelport> which derives similarly
18:48:23 <pjdelport> OceanSpray: anamorphisms are the dual of catamorphisms
18:49:14 <pjdelport> :t unfoldr
18:49:16 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
18:49:59 <OceanSpray> wha
18:50:03 <OceanSpray> there's UNfold?
18:50:15 <pjdelport> the opposite of foldr
18:50:30 <pjdelport> (for a particular sense of "opposite" :)
18:51:05 <int-e> > unfoldr (\n -> if n == 0 then Nothing else Just ("Card " ++ show n, n-1)) 6
18:51:07 <lambdabot>  ["Card 6","Card 5","Card 4","Card 3","Card 2","Card 1"]
18:51:32 <int-e> (the mental image behind this example is a stack of 6 cards)
18:52:14 <OceanSpray> I'll need a while to figure this stuff out.
18:52:22 <pjdelport> OceanSpray: the function you give to unfold translates a "seed" value to one of the type's constructors
18:53:34 <pjdelport> Haskell doesn't have anonymous union types, so in this case Maybe stands in
18:53:46 <int-e> > (foldr (:) [] "abc", unfoldr (\xs -> case xs of [] -> Nothing; x:xs' -> Just (x,xs')) "abc") -- two identity functions
18:53:47 <lambdabot>  ("abc","abc")
18:53:51 <pjdelport> with Nothing corresponding to [], and Just corresponding to (:)
18:55:46 <pjdelport> for anamorphisms, recursion in the type correspond to returning a new seed (which is again recursed on by the anamorphism)
18:55:52 <pjdelport> :t unfoldr
18:55:54 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
18:55:56 <pjdelport> err
18:56:02 <pjdelport> @src unfoldr
18:56:02 <lambdabot> unfoldr f b  = case f b of
18:56:02 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
18:56:02 <lambdabot>    Nothing        -> []
18:56:11 <int-e> it is also worth noting that you could implement foldr :: (b -> a -> a) -> a -> [b] -> a  as  foldr' :: (Maybe (b, a) -> a) -> [b] -> a
18:56:17 <pjdelport> @src foldr
18:56:18 <lambdabot> foldr f z []     = z
18:56:18 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:56:47 <pjdelport> here you should roughly be able to see how they are dual to each other
18:57:05 <pjdelport> foldr has the list constructors on the left, unfoldr has them on the right
18:57:05 <int-e> and List as the fixed point  newtype List a = List (Maybe (a, List a))
18:57:09 <zooko> Hello folks.  Does anyone know of a roguelike in Haskell?
18:57:20 <zooko> I'm teaching my 7 year old son programming, but we're doing it in C, because of Dungeon Crawl.
18:57:28 <zooko> (Actually C++, but very C'ish.)
18:58:03 <roconnor> No Logo?
18:58:21 <OceanSpray> There's no roguelike in Haskell?
18:58:42 <OceanSpray> This looks like a job for...
18:58:55 <roconnor> (what is roguelike?)
18:59:10 <OceanSpray> It's a type of RPG.
18:59:16 <pjdelport> http://en.wikipedia.org/wiki/Roguelike
18:59:24 <OceanSpray> with extremely simple graphics and mechanics.
18:59:28 <roconnor> oh boy
18:59:34 <roconnor> I should write Empire in Haskell
18:59:38 <int-e> http://www.haskell.org/pipermail/haskell-cafe/2008-May/042681.html
18:59:39 <lambdabot> Title: [Haskell-cafe] ANN: Roguestar 0.2, http://tinyurl.com/69o3r3
18:59:52 * araujo looks in
18:59:53 <lambdabot> araujo: You have 1 new message. '/msg lambdabot @messages' to read it.
19:00:07 <araujo> OceanSpray, I had an idea for a roquelike game in Haskell
19:00:14 <pjdelport> OceanSpray: i wouldn't call nethack's mechanics simple
19:00:15 <araujo> still in my TODO list though
19:00:16 <araujo> :-]
19:00:16 <roconnor> or Star Trek
19:00:23 <roconnor> those were the days
19:00:58 <roconnor> the RogueStar Animation and Graphics Library
19:01:00 <roconnor> cool
19:01:04 * araujo hopes to release 'the Lambda revenge' someday
19:01:22 <gwern> OceanSpray: there are two roguelikes I know
19:01:22 <int-e> I can't say anything about it, I just remembered the announcement :)
19:01:24 <roconnor> araujo: zombie curry horror?
19:01:28 <gwern> the mentioned roguestar, and mage
19:01:35 <araujo> roconnor, rogue-like Haskell game
19:01:46 <roconnor> maybe I should play rogue
19:01:47 <gwern> roguestar should be cabalized and on hackage soon
19:02:02 <gwern> (actually, I should finish that up tonight, I'm not doing anything)
19:02:29 <pjdelport> OceanSpray: any questions re. the above?
19:02:49 <OceanSpray> none, because I'm still trying to wrap my head around these concepts.
19:03:09 <pjdelport> okay;  things become more interesting later :)
19:03:43 <zooko> mage looks good!
19:03:46 <OceanSpray> oh wow, there's these other morphisms
19:04:18 <pjdelport> OceanSpray: the first interesting bit is that in general, when you compose a catamorphism with an anamorphism, you can fuse them together and eliminate the intermediate data
19:04:29 <pjdelport> (that the cata builds up and the ana breaks down)
19:04:35 <roconnor> hylomorphism
19:04:37 <pjdelport> which is known as a hylomorphism
19:05:39 <gwern> zooko: good, but very incomplete
19:05:39 <gwern> its maze generation isn't even complete: you can start off trapped
19:06:05 <pjdelport> OceanSpray: one example i love is tree sort
19:06:12 <pjdelport> http://reddit.com/r/programming/info/2h0j2/comments/c2h196
19:06:39 <zooko> gwern: well, my guess is that this won't be playable-out-of-the-box enough for Irby.
19:06:50 <zooko> He loves Crawl, although nowadays he loves adding to Crawl more than playing it.
19:07:05 <gwern> zooko: heck no. no commands, no plot, minimal content...
19:07:12 <zooko> He and I argue every evening about whether to play our best character (which I want) or to add some new character classes and creatures and branches (which is what he wants).
19:07:28 <pjdelport> OceanSpray: you define an anamorphism that builds up a binary search tree from a list
19:07:40 <gwern> it's a solid starting point, but if I were setting out to clone nethack, i'd probably look to mage for inspiration, but maybe only borrow some graphics code at most
19:07:43 <pjdelport> OceanSpray: and then a catamorphism that flattens the tree
19:08:23 <OceanSpray> pjdelport, and that's efficient?
19:08:24 <pjdelport> OceanSpray: thereby sorting the list, via the tree
19:08:27 <edwardk> oceanspray: there are a bunch of "foo"-morphisms, but they generally follow the same pattern
19:08:31 <zooko> I don't want graphics.
19:08:40 <zooko> The fancier the graphics, the harder it is for Irby to express his creativity.
19:08:53 <pjdelport> OceanSpray: well, when you put the morphisms together to get a hylomorphism
19:08:58 <pjdelport> the intermediate tree disappears
19:09:04 <zooko> With crawl (pure text descriptions plus ascii roguelike display), he can choose an ascii char and write a sentence in order to invite a new kind of monster.
19:09:18 <pjdelport> OceanSpray: it becomes entirely implicit in the way the functions are wired together
19:09:21 <zooko> If there are 2-d graphics, he would have to use a drawing program or copy other art or cetera.
19:09:30 <OceanSpray> This is almost magical.
19:09:31 <zooko> With 3-d graphics, he would have to use a 3-d  modelling program or copy other art, etc.
19:09:38 <edwardk> oceanspray: the nice thing about working with recursion in this form is that there exist fusion laws for when you can just sort of bolt another morphism on the side of what you already have, so that instead of building something up and tearing it down, then building up and tearing down you can generally get a single build-up/tear-down phase.
19:09:39 <zooko> So I want pure text, plus the 2-d grid of ascii chars as a map.
19:09:53 <pjdelport> OceanSpray: those comments i linked to goes through it in detail;  you should be able to follow it
19:10:23 <OceanSpray> alright.
19:10:24 <pjdelport> the resulting sort function is actually the one usually used as an example of "quicksort" in Haskell
19:10:36 <OceanSpray> bbl; dinnar
19:10:38 <gwern> zooko: well, that's why a engine/interface seperation like roguestar is nice
19:11:09 <zooko> Hm.
19:11:15 <gwern> @seen clanehin
19:11:15 <lambdabot> I saw clanehin leaving #xmonad, #darcs and #haskell 48m 48s ago, and .
19:12:43 <gwern> @ask clanehin is there any obstacle to uploading the three roguestar packages to hackage, now that you've fixed up my cabalizations?
19:12:43 <lambdabot> Consider it noted.
19:15:57 <roconnor> hylomorphism: http://reddit.com/r/programming/info/2h0j2/comments/c2hwvl
19:37:47 <edwardk> @type mfix
19:37:49 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
19:49:50 <chessguy> hiya #haskellers
19:50:15 <chessguy> #bot
19:51:02 <chessguy> @bot
19:51:02 <lambdabot> :)
19:51:18 <chessguy> did ya'all just see me in here a second ago?
19:51:37 <pjdelport> yes
19:51:55 <chessguy> weird
19:52:19 <mbz_> it weren't you?
19:53:06 <chessguy> i wasn't seeing anything in my channel
19:53:09 <chessguy> even what i was saying
19:53:26 <pjdelport> lag?
19:53:54 <chessguy> dunno
19:54:02 <chessguy> anyway, hi :)
19:55:58 <pjdelport> helomorphism
19:56:13 <mbz> what is the difference between [Char] and String?
19:56:19 <scodil> none
19:56:57 <scodil> oh wait was that like a zen koan? what's the sound of one hand clapping, and stuff?
19:57:15 <mbz> ;)
19:57:33 <pjdelport> what's the type of one Char repeating?
19:59:32 <mbz> pjdelport: what are you talking about?
20:00:06 <pjdelport> mbz: just talking nonsense
20:00:13 <pjdelport> :)
20:01:14 <mbz> =)
20:10:11 <dons> dcoutts: i upgraded to gcc 4.2, and the register allocator seems to be getting it right now.
20:10:22 <dons> so that was gcc 3.3.x playing up.
20:10:33 <jdrake> Does haskell have an ide similar to what PLT does for scheme?
20:10:35 <dons> so now we just need the unboxing of tight loops to be fixed.
20:10:46 <dons> jdrake: there's winhugs, but its not like dr.scheme at all
20:10:52 <dons> mostly people use emacs or vim + ghci.
20:11:07 <jdrake> I won't use anything but ghc
20:11:20 <jdrake> gedit will work for me :p
20:11:41 <dons> there's visual haskell, but i'm  not sure who uses it
20:15:02 <scodil> wasn't there some kind of haskell eclipse plugin?
20:15:56 <dons> dcoutts: http://hpaste.org/7679  only one instruction different now :)
20:16:04 <dons> so ghc's almost got gcc -O2
20:16:28 <edwardk> i use visual haskell off and on
20:21:40 <gwern> pjdelport: what was the type of 'undefined' before it was used? does Stringalike have the list-nature?
20:23:30 <pjdelport> gwern: if you meet the lambda on the road, kill it?
20:24:27 <gwern> pjdelport: why did dons come from the west?
20:25:04 <gwern> when not even a function has been defined, is there program termination?
20:29:12 <gwern> an old function once called an argument who asked for evaluation nothing but a common constant. when spj heard, he said: 'wait until I investigate'. The next day, he went and asked the same. the old function repeated its comment. spj remarked, 'I have investigated that function'
20:31:30 <geezusfreeek> i believe there is also a haskell plugin for xcode somewhere, but i don't know anybody that uses it
20:33:07 <koninkje> Is there a way to turn on undecidable instances only for a single instance, without breaking that instance out to a separate file?
20:35:31 <koninkje> or equivalently, turning off the Paterson Conditions for a particular context assertion?
20:36:24 * koninkje is trying to retain as much enforced decidability as possible
20:42:13 <OceanSpray> I really like the font they used in that research paper about catamorphisms.
20:42:53 <OceanSpray> Makes the equations look very Tolkienesque.
20:44:20 <gwern> 'speak comradomorphism, and enter'?
20:46:33 <pjdelport> a monk asked sigpfe, "What is the categorical nature?"  sigfpe replied, "Three pounds of fmap."
20:47:02 <gwern> nice
20:47:43 <gwern> the infinite list that can be written is not the true infinite list
20:49:39 <augur> WOW look at all the haskellians
20:49:52 <gwern> you sound surprised
20:50:27 <augur> if i understood haskell as much as i'd like, i imagine i'd feel like i'd come home 0.0;
20:50:48 <augur> i have a question for anyone who's familiar with the underlying principles of haskell's pattern matching
20:50:58 <SamB_XP> gwern: so #1=(1 . #1#) isn't really an infinite list?
20:51:15 <gwern> fonce, master foo stood before his students and asked: tell me about (1+1) 10 years from now. the students were silent. master foo banged his laptop, and said, 'Every addition is referentially transparent!'
20:51:22 <vixey> SamB: I call it ourbouros
20:51:25 <gwern> SamB_XP: I don't even know what that is
20:51:37 <pjdelport> SamB_XP: it's not the true infinite list :)
20:51:41 <vixey> > fix (1:)
20:51:44 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:52:25 <pjdelport> gwern: Lispy syntax for fix (1:)
20:52:47 <gwern> a noob asked, 'when can main be reused and inlined'?' wadler replied "When the broken mirror is mended; when the fallen flowers return to their old branches."
20:52:51 <vixey> It's more like x = (1 : x) in x
20:53:02 <augur> in a pattern like fac n = ..., how does the compiler know to bind only the n to a value, and not fac? e.g. why doesn't "fac n" match the sequence "4 5", with fac=4 and n=5?
20:53:08 <gwern> SamB_XP: sure, you've written part of it, but where's the rest? :)
20:53:37 <vixey> augur: The very first thing is always the name of a function, so it only takes the parameters when doing pattern matching
20:53:39 <SamB_XP> gwern: I could get Cale to draw you a diagram ;-)
20:54:06 <augur> ok, that makes sense.
20:54:08 <augur> thanks vixey.
20:55:31 <gwern> a young programmer was studying with his mentor, when he accidentally deleted the program. his master returned, and quickly the programmer asked him, 'master, you say that when a value is no longer referenced by any other values, it has come time to be garbage collected?' the master affirmed this. 'Master, it was this program's time to be garbage collected.'
20:55:55 <pjdelport> haha
20:55:57 <augur> lol
20:58:20 <gwern> a young novice spoke to #haskell, asking to be taught about the ways of the Maybe monad. 'What have you brought me to see?' asked the #haskeller. 'Nothing', replied the noob. 'Then take it away!'
20:59:21 <pjdelport> gwern++
20:59:38 <OceanSpray> :t fix
20:59:41 <lambdabot> forall a. (a -> a) -> a
20:59:58 <OceanSpray> @src fix
20:59:59 <lambdabot> fix f = let x = f x in x
21:00:10 <SamB_XP> shouldn't someone tell the n00b about Just?
21:00:42 <thetallguy> Maybe.
21:01:03 <gwern> Justice is an illusion
21:01:17 * gwern is a nihilist, and thinks there is only Nothing
21:01:23 <pjdelport> poetic justice doubly so
21:01:33 * SamB_XP hands gwern a return
21:01:42 <thetallguy> Never let it be said that #haskell isn't helpful
21:02:15 <augur> you guys are as nerdy about haskell as i am about linguistics... my god...
21:02:50 <gwern> Another time, a fellow Haskeller asked dons why his program did so little garbage collection. dons replied, 'because memory is so plentiful'
21:02:54 <thetallguy> data Maybe a = Nothing | Just a
21:02:54 <SamB_XP> augur: is that odd in some way?
21:02:59 <gwern> augur: not computational linguistics?
21:03:21 <thetallguy> Lets you turn partial functions into total ones.
21:03:23 <augur> samb: no, its just rare and i'm please to find it. :)
21:03:33 <pjdelport> The allocation of a thousand bytes begins with one seq.
21:03:49 <augur> gwern: eh. im more towards theoretical, but i love me some computers and i do computational stuff for fun
21:03:49 <thetallguy> > replicate 1000 "pardon"
21:03:52 <SamB_XP> pjdelport: eh?
21:04:00 <lambdabot>  ["pardon","pardon","pardon","pardon","pardon","pardon","pardon","pardon","pa...
21:04:11 <gwern> pjdelport: how about 'the forcing of a thousand thinks begins with one seq'?
21:04:14 <gwern> *thinks
21:04:17 <gwern> **thunks
21:04:31 <thetallguy> ***thanks
21:04:40 <pjdelport> gwern: yeah, that's better :)
21:07:21 <gwern> Once, Wadler was sought out by a curious hacker, who wished to learn about the differences between imperative and functional. Wadler mocked the hacker and said, one so ill-educated as you could never appreciate the ways of Haskell. The hacker grew angry, and prepared to 'rm -rf' Wadler, when Wadler said: 'Here open the gates of imperatism!' The hacker desisted, and began to copy down his words, whereupon Wadler interrupted: 'Here open the gates of functiona
21:07:31 <vixey> > [ (x^2+y^2)`div`(1+x*y) | x<-[1..] , y<-[1..x] , 0==(x^2+y^2)`rem`(1+x*y)]
21:07:41 <lambdabot>  [1,4,9,4,16,4,25,36,9,49,4,64,81,100,16,121,4,144,9,169,196,25,225,256,289,4...
21:08:59 <GavinMcG> If I have a datatype declaration "data MyType a b = MyTypeConstructor a b", then when I say "let var = MyTypeConstructor x y" I am using the function MyTypeConstructor to construct  a structure of type MyType with the values x and y and then assigning the resulting MyType structure to var. Is this a correct understanding?
21:10:38 * gwern lols at http://xkcd.com/114/ : 'Ooh, look at me, my field is so ill-defined I can subscribe to any of dozens of contradictory models and still be taken seriousl!'
21:10:39 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
21:11:04 <gwern> 'Chomskyists, computational linguists, and Ryan North: your days are numbered!'
21:11:40 <augur> gwern: :(
21:11:52 <koninkje> GavinMcG: that's one correct understanding
21:12:23 <koninkje> GavinMcG: though it's "binding" var to that structure, not "assigning"
21:12:24 <augur> gwern dont be a hater
21:12:42 <koninkje> gwern: ooh ooh, what's my number?
21:13:12 <gwern> koninkje: finite, and bounded by the maximum human population?
21:13:35 <gwern> augur: I'll hate the player and not the game if I choose!
21:13:54 <GavinMcG> koninkje: that's trivial to the question I was intending to ask, but thank you - I'm obviously coming from an imperative background, although "binding" certainly makes more sense in a functional-programming mode of thinking.
21:14:00 <augur> as an aside from haskellnerdery, has anyone seen the MIT open courseware video lectures of Abelson and Sussman's 1986 course on the structure of programs?
21:14:08 <koninkje> gwern: Well sure, but is it well-founded? How am I supposed to know in what order we should line up at the wall? ;)
21:14:14 <GavinMcG> koninkje: What other ways of thinking about it are there?
21:14:37 <gwern> augur: I have'em downloaded, I think...
21:15:03 <augur> they're quite good. dont just have them downloaded, watch them. they're reeeaaally addictive
21:15:04 <koninkje> GavinMcG: I just would've phrased it less verbosely is all.
21:15:11 <augur> i watched them all over the course of a few days
21:15:44 <koninkje> GavinMcG: though yes, data constructors are simply functions like any other
21:15:50 <koninkje> :t Just
21:15:52 <lambdabot> forall a. a -> Maybe a
21:16:06 <koninkje> :i Maybe
21:16:26 <GavinMcG> Ok, thank you koninkje
21:16:31 * koninkje kicks lambdabot 
21:17:03 <koninkje> np
21:17:42 <koninkje> The only thing special about data constructors (aside form being spelled capitalized) is that you can pattern match on them as well
21:17:50 <koninkje> s/form/from/
21:18:42 <koninkje> hence they're always invertable functions (unless you're playing with existential types)
21:21:46 <GavinMcG> I'm not even sure how to approach understanding that. Let's save it for later.
21:22:10 <koninkje> :t (\(Just x) -> x)
21:22:12 <lambdabot> forall t. Maybe t -> t
21:23:40 <koninkje> It's nothing too major, but you can't write a function like "foo (bar x) = x" because calling it as "foo 17" means you'd have to invert the bar function to figure out what x is
21:24:19 <thetallguy> dons: non-unboxed?
21:36:27 <gwern> "I/O considered harmful (at least for the first few weeks)" <-- hee
21:36:36 <gwern> http://portal.acm.org/ft_gateway.cfm?id=299390&type=pdf&coll=ACM&dl=ACM&CFID=19617795&CFTOKEN=34489434
21:39:12 <augur> anyone have a reference for how haskell is interpreted?
21:40:28 <swidgy> spj's stg paper and his '87 book are great references
21:40:57 <swidgy> obviously time has passed... but still
21:41:43 <dons> augur: its compiled these days :)
21:41:58 <monochrom> gwern: your url requires Full-Text privilege. Is there a url for just the bibliographic info?
21:42:06 <augur> sure, but that doesn't stop there from being references in the abstract sense :p
21:42:08 <dons> augur: this is the paper, http://citeseer.ist.psu.edu/peytonjones92implementing.html
21:42:09 <lambdabot> Title: Implementing lazy functional languages on stock hardware: the Spineless Tagless  ...
21:42:16 <dons> for how ghc does it.
21:42:17 <augur> sort of like how you can define lisp in terms of itself in an abstract way
21:42:23 <dons> there are other approaches too.
21:42:48 <augur> im just really interested in seeing how pattern matching and tail recursion are handled in terms of evaluation
21:43:07 <dons> right, so check the above paper, that shows how it works
21:43:12 <augur> k :)
21:43:16 <gwern> monochrom: dunno
21:43:17 <dons> tail recursion are just loops
21:43:18 <gwern> probably
21:43:25 <dons> pattern matching is basically a big switch
21:43:33 <monochrom> Surely it exists.
21:43:38 <dons> that checks the constructor tag, which is encoded in the bottom bits of the pointer to the value
21:43:46 <monochrom> You just have to use your browser's "back" button.
21:43:55 <dons> the latter implementation is covered in the tagged pointers paper
21:44:13 <augur> cool
21:44:15 <augur> thanks
21:44:17 <dons> augur: http://research.microsoft.com/~simonpj/papers/ptr-tag/index.htm
21:44:17 <lambdabot> Title: Faster laziness using dynamic pointer tagging
21:44:29 <dons> is the paper about how pointer tagging works (for e.g. pattern matching on data)
21:45:10 <dons> its all rather cool, imo :)
21:48:13 <monochrom> Example: https://portal.acm.org/citation.cfm?id=299359.299390&coll=ACM&dl=ACM&CFID=19617795&CFTOKEN=34489434
21:48:20 <lambdabot> Title: I/O considered harmful (at least for the first few weeks), http://tinyurl.com/5pgfvc
21:49:51 <dons> oh, for teaching new programmers
21:49:54 <koninkje> http://citeseer.ist.psu.edu/128583.html
21:49:55 <lambdabot> Title: I/O Considered Harmful (At Least for the First Few Weeks) (ResearchIndex)
21:50:02 <koninkje> for the abstract...
21:51:06 <geezusfreeek> <3 citeseer
22:01:40 <vixey> > [ (x^2+y^2)`div`(1+x*y) | x<-[1..] , y<-[1..x] , 0==(x^2+y^2)`rem`(1+x*y)] -- how come they are all squares?
22:01:50 <lambdabot>  [1,4,9,4,16,4,25,36,9,49,4,64,81,100,16,121,4,144,9,169,196,25,225,256,289,4...
22:08:20 <augur> i hear i missed something. :P
22:15:16 <paolino> vixey: finite group things?
22:24:52 <conal> @localtime paolino
22:29:15 <dmwit> ?botsnack
22:29:15 <lambdabot> :)
22:29:21 <shubuntu> hey guys two access a two dimensional list we can go (list ! x) ! y right
22:29:38 <dmwit> Gotta use (!!) if it's actually a list.
22:29:41 <dmwit> Otherwise, yes.
22:29:58 <mbz> @src !!
22:29:58 <lambdabot> xs     !! n | n < 0 = undefined
22:29:58 <lambdabot> []     !! _         = undefined
22:29:58 <lambdabot> (x:_)  !! 0         = x
22:29:58 <lambdabot> (_:xs) !! n         = xs !! (n-1)
22:30:03 <shubuntu> ok so (list !! x ) !! y
22:30:32 <dmwit> > [[1]] !! 0 !! 0
22:30:34 <lambdabot>  1
22:30:34 <mbz> how do i check the source like this in ghci?
22:30:40 <dmwit> You don't even need the parens.
22:30:45 <shubuntu> ok
22:30:53 <dmwit> mbz: You can't. =/
22:30:57 <shubuntu> so the !! has precedence?
22:31:04 <dmwit> precedence?
22:31:07 <shubuntu> mbz use let
22:31:07 <mbz> :\
22:31:08 <koninkje> mbz: but you can (kinda) in hugs
22:31:11 <dmwit> No, but it's left-associative.
22:31:14 <shubuntu> and seperate those lines with semicolon
22:31:24 <shubuntu> write them all in one consecutive command
22:31:41 <pjdelport> lambdabot: goa?
22:31:49 <dmwit> ?where goa
22:31:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
22:31:56 <pjdelport> mbz: -^
22:32:06 <mbz> thanks
22:32:11 <dmwit> mbz: Basically, you have to install lambdabot locally if you want lambdabot's features. =)
22:32:19 <mbz> :D
22:32:28 <shubuntu> lambdabot you're in Sydney?
22:32:29 <shubuntu> lol
22:53:25 <gwern> pjdelport: isn't GOA long since bitrotted and broken?
22:53:36 <pjdelport> no idea
23:04:10 <fatalerrorx> just wadering are there any fp langs that are popular as haskell but don't have lazy eval?
23:04:59 <dmwit> Almost all of them.
23:05:44 <fatalerrorx> such as?
23:05:51 <fatalerrorx> not ocaml or erlang
23:05:56 <dmwit> lisp, scheme, maybe Python if that counts
23:06:01 <dmwit> Why not ocaml or erlang?
23:06:12 <fatalerrorx> ocaml is stale and erlang is server only pretty much
23:06:30 <dmwit> Server only?
23:06:32 <fatalerrorx> no python doesn't count :)
23:06:39 <vixey> ocaml isn't stale
23:06:46 <fatalerrorx> well erlangs libs arn't that mature for gui
23:06:55 <fatalerrorx> ocaml is stale....period
23:07:04 <vixey> that doesn't even mean anything
23:07:18 <fatalerrorx> the devs are lazy
23:07:25 * dmwit feels a little lost
23:07:27 <vixey> I think you should "I don't like ocaml" or something more descriptive than saying it's stale
23:07:32 <vixey> should say*
23:08:05 <fatalerrorx> vixey: the don't want to add parallel gc because its too hard.....heh???
23:08:11 <fatalerrorx> they*
23:08:34 <fatalerrorx> they also don't want to improve the type system because thats too involved
23:08:37 <vixey> pay them or do it yourself
23:09:27 <fatalerrorx> vixey: my point exactly there is not enough interest in the language thus i feel its going stale
23:10:37 <fatalerrorx> i believe that paralles gc will be in ghc 6.10.1
23:10:45 <fatalerrorx> parallel*
23:10:59 <OceanSpray> fatalerrorx, if that language you're looking for is really as popular as Haskell,
23:11:05 <OceanSpray> you would have known about it by now.
23:11:14 <dons> haha, i just worked out why partial-sums was so slow, compared to Clean
23:11:52 <fatalerrorx> OceanSpray: yeah i was just wandering that maybe there was a lanuage that i had not know about
23:12:02 <fatalerrorx> i guess not
23:12:21 <stepcut> given the equation, (n + |x|) `mod` 7 == 0, I would like a function that calculates x from n. (aka, f n = <calculate x>). I don't see how to do it with out an 'if' statement.
23:13:02 <dmwit> You can do it without if.
23:13:24 <vixey> 7 - n`mod`7
23:13:41 <swidgy> dons: so... the suspense is killing me.  why?
23:14:09 <mbz> dons: how much slower? four times?
23:14:26 <dons> oh, sorry. its http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=all
23:14:27 <lambdabot> Title: partial-sums benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/lk8xz
23:14:45 <dons> there's a bug in the optimiser which means the result is returned as boxed values.
23:14:50 <stepcut> vixey: that is what I had, but it yields x = 7 when I want it to yield x = 0.  I realize now that I need some additional constraints on my specification.
23:14:50 <vixey> > let f n = 7 - n`mod`7 ; g x n = (n + x) `mod` 7 in [ g (f n) | n <- [1..] ]
23:14:51 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer -> ...
23:14:56 <dmwit> fatalerrorx: What, you don't agree that Lisp and Scheme are popular functional languages?
23:14:56 <dons> this then means there's a check to see if the heap is ok, used every time around in the loop
23:15:05 <dons> by avoiding that check the running time is halved
23:15:13 <vixey> > let f n = (7 - n`mod`7)`mod`)7 ; g x n = (n + x) `mod` 7 in [ g n (f n) | n <- [1..] ]
23:15:13 <lambdabot> Unbalanced parentheses
23:15:23 <vixey> > let f n = (7 - n`mod`7)`mod`7 ; g x n = (n + x) `mod` 7 in [ g n (f n) | n <- [1..] ]
23:15:25 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
23:15:30 <vixey> stepcut: you can do mod 7 twice
23:15:32 <dmwit> vixey: (negate n) `mod` 7 -- I prefer this
23:15:43 <stepcut> I guess the problem is, I want to solve for x in (n + x) `mod` 7 == 0 where 0 <= x <= 6.
23:15:58 <vixey> dmwit: that is nicer actually yeah
23:15:58 <dmwit> stepcut: ...
23:15:58 <fatalerrorx> dmwit: no listp and scheme are popular but the syntax sucks really
23:16:07 <stepcut> vixey: ah, right, that thought sort of occured to me, but not all the way :)
23:16:15 <fatalerrorx> dmwit: i find it really hard to read
23:16:22 <mbz> 4.18s for clean and 4.75s for ghc
23:16:25 <mbz> not so bad
23:16:26 <vixey> fatalerrorx: I guess you are just trolling here
23:16:26 <dmwit> fatalerrorx: Okay, but you have an answer to your question, then.
23:16:34 <dons> yeah, but its a stupid optimiser bug
23:16:41 <mbz> i agree
23:16:49 <dons> i can write a version by hand to work around it, that should thrash clean here.
23:16:55 <dons> and i've opened a ticket for it
23:19:04 <stepcut> vixey, dmwit: thanks! In case you are wondering, I am trying to generate an month calendar in HTML -- my code is far more complex than I had expected :-/
23:19:22 <dmwit> stepcut: Oh!
23:19:35 <stepcut> with out the second `mod` 7, I got a whole empty week at the end of the month, which looked stupid :)
23:20:20 <vixey> if you had say 31 days, and 7 columns
23:20:24 <vixey> > 31`div`7
23:20:25 <lambdabot>  4
23:20:35 <vixey> use 4 rows
23:20:59 <vixey> > (7 - (31 `mod` 7))`mod`7
23:21:00 <lambdabot>  4
23:21:28 <vixey> if code is compilicated, it's probably doing something unnecessary
23:21:56 <nolrai_> is gtk2hs on hackage?
23:22:16 <dmwit> stepcut: You may be interested in some code I wrote recently to make a calendar table for a webapp:
23:22:17 <gwern> no
23:22:19 <dmwit> http://hpaste.org/7680
23:22:31 <stepcut> dmwit: cool, i check it out
23:22:41 <stepcut> here is my code, http://hpaste.org/7681
23:22:50 <gwern> nolrai_: gtk2hs is currently a bit too complex to cabalize
23:23:07 <gwern> although it's probably doable these days
23:24:08 <stepcut> dmwit: at first glance, it appears your code has the same issue as mine -- generates an empty week at the end of May 2008?
23:24:22 <dmwit> stepcut: Hehe, everybody writes "chunks". =)
23:24:26 <dmwit> stepcut: Oh, really?
23:24:27 <dmwit> hum
23:25:08 <stepcut> dmwit: yeah, i think there was some dicussion about submitting chunks to Data.List earlier today
23:25:24 * dmwit loves commenting out bits of Dmwit.hs
23:25:45 <stepcut> dmwit: your approach looks like mine, add padding to the begin and end of the month and then take things in chunks of 7
23:25:48 <gwern> a relatively long one
23:26:07 <nolrai_> whats chunks again? I feel like I've talked about it before.
23:26:32 <stepcut> nolrai_:  chunks :: Int -> [a] -> [[a]]
23:26:52 <stepcut> splits a list into a list of lists where the inner lists are 'Int' elements long
23:26:55 <dmwit> stepcut: No, mine has no empty extra week.
23:27:07 <stepcut> dmwit: ok, I'll have to look and see why
23:27:07 <dmwit> stepcut: concat eliminates empty lists
23:27:26 <nolrai_> ah, yeah that feels like Data.List material to me.
23:27:26 <stepcut> dmwit: ah, that makes sense
23:27:29 <dmwit> > concat [["padding"], ["real stuff"], [ {- empty padding -} ]]
23:27:30 <lambdabot>  ["padding","real stuff"]
23:29:15 <koninkje> @pl (\(a,b) -> a : f b)
23:29:15 <lambdabot> uncurry ((. f) . (:))
23:29:40 <dmwit> uncurry (:) . second f
23:29:52 <dmwit> :t uncurry (:) . second f
23:29:54 <lambdabot> Not in scope: `second'
23:30:02 <dmwit> :t uncurry (:) . Control.Arrow.second f
23:30:04 <lambdabot> forall b d. (FromExpr [d], Show b) => (d, b) -> [d]
23:30:09 <dmwit> oh
23:30:14 <dmwit> :t \f -> uncurry (:) . Control.Arrow.second f
23:30:16 <lambdabot> forall b d. (b -> [d]) -> (d, b) -> [d]
23:30:24 <stepcut> dmwit: hrm, but emptyCell = td . text $ "", so why would concat get rid of that ?
23:30:36 <dmwit> stepcut: replicate 0 emptyCell
23:30:47 * koninkje wonders why people use take n ... drop n instead of splitAt n
23:31:22 <stepcut> dmwit: oh, I see, with negate you don't need `mod` 7 twice.
23:31:46 <vixey> stepcut: what's wrong with `div`?
23:32:24 <stepcut> so, ((7 - (monthLen + dow) `mod` 7) `mod` 7) can be better written as, (negate (monthLen + dow) `mod` 7)
23:32:40 <stepcut> vixey: ?
23:33:02 <vixey> stepcut:  <vixey> if you had say 31 days, and 7 columns
23:33:02 <vixey>  <vixey> > 31`div`7
23:33:02 <vixey>  <lambdabot>  4
23:33:02 <vixey>  <vixey> use 4 rows
23:33:02 <vixey>  <vixey> > (7 - (31 `mod` 7))`mod`7
23:33:03 <vixey>  <lambdabot>  4
23:34:45 <stepcut> vixey: the next step is to generate the content to fill the four rows, making sure that each row has exactly 7 columns
23:35:09 <stepcut> vixey: because it's an html table, you still have to generate the empty cells
23:35:21 <stepcut> vixey: could be done that though
23:35:31 <vixey> anyway it seems a very imperative way to do this
23:35:52 * dmwit disagrees
23:35:55 <vixey> why don't you just make a list of cells (including empty ones) and chunk them, map over turning them into HTML
23:36:05 <dmwit> vixey: That's exactly what I do.
23:36:06 <dmwit> ;-)
23:36:19 <vixey> dmwit: was talking about stepcuts approach
23:36:22 <dmwit> oh
23:36:27 <stepcut> vixey: that is what I do, http://hpaste.org/7681
23:36:43 <stepcut>  weeks = inGroupsOf 7 $ replicate dow Nothing ++ map Just [1..monthLen] ++ replicate ((negate (monthLen + dow) `mod` 7) `mod` 7) Nothing
23:36:43 <stepcut>  
23:36:54 <vixey> hey how come there is HTML in there?
23:36:59 <vixey> lots of operator definitions?
23:37:00 <stepcut> vixey: HSP
23:37:09 <vixey> hows HSP work?
23:37:14 <dmwit> stepcut: Incidentally, I write "chunk" a little differently these days.
23:37:26 <dmwit> chunk i = takeWhile (not . null) . unfoldr (Just . splitAt i)
23:37:45 <vixey> change replicate ((negate (monthLen + dow) `mod` 7) `mod` 7) Nothing to repeat Nothing
23:37:58 <stepcut> vixey: there is a preprocessor trhsx that converts it into normal Haskell code
23:38:09 <vixey> oh ok
23:38:43 <stepcut> dmwit: yeah, I came up with something similar
23:38:53 <vixey> weeks = take (monthLen + dow `div` 7) . (inGroupsOf 7) . ...
23:39:18 <stepcut> dmwit: igo n l = (unfoldr (list Nothing (Just . splitAt n)) l)
23:39:32 <stepcut> dmwit: where 'list' is like 'maybe' but for lists
23:39:38 <dmwit> list = foldr?
23:39:41 <stepcut> list :: b -> ([a] -> b) -> [a] -> b
23:39:41 <stepcut>       list b _ [] = b
23:39:41 <stepcut>       list _ f l = f l
23:40:14 <dmwit> oh, weird
23:40:44 <dmwit> :t maybe
23:40:45 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:41:04 <dmwit> :t ((maybe .) .) . listToMaybe
23:41:05 <lambdabot>     Couldn't match expected type `a1 -> a -> b'
23:41:05 <lambdabot>            against inferred type `Maybe a2'
23:41:05 <lambdabot>     Probable cause: `listToMaybe' is applied to too many arguments
23:41:27 <dmwit> :t \b f l -> maybe b f (listToMaybe l)
23:41:30 <lambdabot> forall b a. b -> (a -> b) -> [a] -> b
23:41:31 <stepcut> dmwit: unfortunately, listToMaybe only preserves the first element of a list
23:41:35 <dmwit> yeah
23:41:45 <dmwit> I'm just trying to get a grasp on what you're doing. =)
23:42:22 <stepcut> \b f l -> if null l then b else (f l)
23:42:29 <dmwit> yeah
23:42:38 * dmwit slowly comes to understand
23:43:32 <stepcut> dmwit: it would be nice if there was a general purpose function like, maybe, either, list, etc. But, the types are different enough that I don't see an obvious type-class that ties them all together
23:43:58 <dmwit> Yeah, but maybe and either are catamorphisms, whereas the catamorphism for lists is foldr.
23:44:08 <dmwit> So list doesn't really fit the pattern.
23:45:05 <dmwit> (If you send the constructors of a data type to its catamorphism, you get the identity function restricted to that data type.)
23:45:06 <stepcut> something like, monoid :: (Eq a, Monoid m) => b -> (a -> b) -> m a -> b, but that doesn't quite work out
23:45:09 <dmwit> :t either Left Right
23:45:11 <lambdabot> forall a b. Either a b -> Either a b
23:45:17 <dmwit> :t maybe Nothing Just
23:45:18 <lambdabot> forall a. Maybe a -> Maybe a
23:45:27 <dmwit> :t foldr (:) []
23:45:29 <lambdabot> forall a. [a] -> [a]
23:45:33 <dmwit> etc.
23:45:46 <stepcut> oh yeah
23:46:13 <stepcut> It's been a while since I read about bananas and friends
23:46:36 <dmwit> I've just sort of absorbed the concept of catamorphisms by hanging out here. =P
23:46:36 <paolino> @localtime conal
23:46:37 <lambdabot> Local time for conal is Fri May 16 23:44:22 2008
23:47:00 <conal> :)
23:47:28 <stepcut> I absorbed it, but it all oozed back out again
23:48:16 <dmwit> :t \p x -> guard (p x) >> return x
23:48:17 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => (b -> Bool) -> b -> m b
23:48:28 <vixey> is it true to say a catamorphism = a fold
23:48:43 <vixey> foldl isn't really a fold ..
23:48:45 <dmwit> hum
23:48:56 <dmwit> Well, it depends on what you mean by fold, I guess. =)
23:48:59 <stepcut> vixey: yes, if I calculated the number of weeks that I needed, then I would just change the trailing padding to repeat Nothing, and do (chunks numWeeks ...)
23:49:00 <vixey> just a useful list function with a misleading name
23:49:12 <dmwit> no
23:49:29 <dmwit> You can construct a catamorphism for any data type, recursive or otherwise.
23:50:02 <sjanssen> vixey: I would say foldl is "a" fold, but not "the" fold
23:50:24 <vixey> ahh ok
23:50:38 <sjanssen> of course this is subjective
23:50:41 <Apocalisp> ?src Maybe fold
23:50:41 <lambdabot> Source not found. It can only be attributed to human error.
23:50:53 <sjanssen> @src maybe
23:50:54 <lambdabot> maybe n _ Nothing  = n
23:50:54 <lambdabot> maybe _ f (Just x) = f x
23:51:03 <vixey> I with that haskell had deriving Cata
23:51:05 <vixey> or whatever
23:51:08 <sjanssen> Apocalisp: Maybe's catamorphism is called maybe
23:51:16 <Apocalisp> of course!
23:51:19 <dmwit> vixey: Sometimes, I do too. =)
23:51:27 <sjanssen> vixey: I have a feeling this would be a very complicated class
23:51:30 <dmwit> vixey: Of course, it's not a proper type-class, but you get the idea.
23:51:33 <sjanssen> you'd need MPTC at the very least
23:51:39 <vixey> Coq does .. I guess we can just extract the haskell code from coq ::P
23:51:52 <dmwit> sjanssen: Possibly a variable-PTC!
23:51:58 <vixey> sjanssen: or name them individually, which I suppose is a whole new can of worms
23:52:09 <sjanssen> right, not a class
23:52:14 <vixey> deriving (Cata named fold)
23:52:17 <vixey> deriving (Cata named fo)
23:52:20 <vixey> etc..
23:52:29 <dmwit> You see a cat named Foo.
23:52:32 <dmwit> nethack++
23:53:34 <Apocalisp> ?type maybe
23:53:35 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:53:42 <vixey> @src Maybe
23:53:42 <lambdabot> data Maybe a = Nothing | Just a
23:53:55 <Apocalisp> ?type foldl
23:53:58 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
23:54:34 <Apocalisp> Is there a reason why maybe's arguments are ordered that way?
23:54:43 <vixey> yes
23:54:48 <vixey> Nothing ==> z
23:54:48 <Apocalisp> what is it?
23:54:54 <vixey> Just a ==> a -> z
23:55:10 <vixey> Maybe catamorphism : z -> (a -> z) -> Maybe a -> z
23:55:36 <vixey> for Bool, it's the same True ==> z, False ==> z, cata : z -> z -> Bool -> z
23:56:16 <vixey> in general, pick some result type z, take all the parameters type from each constructor turn add -> z, chain them and stuck on Type -> z at the end
23:56:16 <dmwit> Apocalisp: Because the constructors are ordered that way in the data definition.
23:56:19 <dmwit> ?src Maybe
23:56:19 <lambdabot> data Maybe a = Nothing | Just a
23:56:24 <vixey> I guess it's clearer when expressed in code..
23:56:36 <vixey> how do you parse Haskell data type definitions?
23:56:53 <stepcut> it would be nice if, Data.Bool.bool :: Bool -> a -> a, existed
23:57:10 <geezusfreeek> @djinn Bool -> a -> a
23:57:11 <lambdabot> f _ a = a
23:57:21 <Apocalisp> dmwit: That makes sense. I was just wondering if it was arbitrary in some sense.
23:57:26 <vixey> like is there any foo which goes foo "data Maybe a = Nothing | Just a" ~~> Data "Maybe" ["a"] [Constructor "Nothing" [], Constructor "Just" ["a"]] ?
23:57:27 <sjanssen> Bool -> a -> a -> a -- I'm sure stepcut meant this
23:57:32 <stepcut> oops, I meant, a -> a -> Bool, i think
23:57:35 <dmwit> Apocalisp: Yep, it's a little arbitrary.
23:57:40 <stepcut> it's getting late :-)
23:57:43 <vixey> :t (==)
23:57:44 <lambdabot> forall a. (Eq a) => a -> a -> Bool
23:57:46 <vixey> there you go ^
23:57:47 <geezusfreeek> @djinn a -> a -> Bool
23:57:47 <lambdabot> f _ _ = False
23:57:59 <geezusfreeek> well, djinn is not very helpful there
23:58:03 <stepcut> yikes
23:58:13 <dmwit> Apocalisp: As a convention, you specify the value you're catamorphing last, but the rest are just whatever order the data definition happens to be in.
23:58:13 <stepcut> sjanssen is correct, i meant, Bool -> a -> a -> a
23:58:14 <vixey> or in general parsing Haskell into a form which is easy to deal with?
23:58:23 * stepcut better stop coding for tonight
23:58:25 <vixey> :t bool
23:58:26 <lambdabot> Not in scope: `bool'
23:58:27 <geezusfreeek> @djinn Bool -> a -> a -> a
23:58:27 <lambdabot> f a b c =
23:58:28 <lambdabot>     case a of
23:58:28 <lambdabot>     False -> c
23:58:28 <lambdabot>     True -> b
23:58:30 <vixey> hmm
23:58:36 <vixey> @hoogle Bool -> a -> a -> a
23:58:36 <lambdabot> No matches, try a more general search
23:58:42 <vixey> really? It's missing?
23:58:42 <dmwit> stepcut: Are you sure you didn't mean a -> a -> Bool -> a? ;-)
23:58:52 * stepcut stops to think for a minute
23:59:01 <stepcut> dmwit: yes that is what I meant
23:59:02 <dmwit> bool f t b = if b then t else f -- from Dmwit.hs
23:59:02 <geezusfreeek> i think bool = if'
23:59:35 <geezusfreeek> well, modula argument order
23:59:38 <dmwit> yeah
23:59:39 <geezusfreeek> *modulo
23:59:40 <stepcut> dmwit: yeah, I have that function in many places
