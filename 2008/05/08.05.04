00:26:16 <dancor> @type first (:)
00:26:17 <lambdabot> forall a d. (a, d) -> ([a] -> [a], d)
00:26:41 <dancor> @type second (:)
00:26:42 <lambdabot> forall a d. (d, a) -> (d, [a] -> [a])
00:28:32 <Syzygy-> @type (first (:)) . (second (:)))
00:28:34 <lambdabot> parse error on input `)'
00:28:39 <Syzygy-> @type (first (:)) . (second (:))
00:28:40 <lambdabot> forall a d. (d, a) -> ([d] -> [d], [a] -> [a])
00:33:24 <edwardk> @seen dolio
00:33:24 <lambdabot> dolio is in #haskell-blah and #haskell. I last heard dolio speak 1h 50m 19s ago.
00:33:34 <dolio> Eh?
00:33:35 <dancor> @pl \ x (y, z) -> (x:y, z)
00:33:35 <lambdabot> (`ap` snd) . (. fst) . ((,) .) . (:)
00:34:02 <edwardk> i started converting over to the bifunctor based cofree/free stuff, got cofree done, doing free now. its not that painful with the parameterized (co)monad stuff in
00:34:51 <edwardk> dolio: http://comonad.com/haskell/category-extras/src/Control/Comonad/Cofree.hs
00:34:52 <lambdabot> http://tinyurl.com/6ph4tv
00:35:10 <edwardk> the CofreeB version there is interchangeable with the commented out version up above it
00:36:31 <edwardk> and becomes a (co)monad instance for Cofree f through the instances for PMonad f => Monad (FixB f) and PComonad f => Comonad (FixB f)
00:36:57 <dolio> Hmm, interesting.
00:37:50 <edwardk> dolio: i'm currently flipping over to this because it lets me exploit more of the parameterized monad machinery, giving both examples of it, and because it makes a nice simple rose tree monad
00:38:13 <edwardk> er s/giving both/both giving
00:38:49 <edwardk> (also cofree picked up that monad instance)
00:39:18 <edwardk> for the same reason that (,)e is a writer when e is an instance of Monoid
00:40:14 <dolio> What's a FunctorPlus?
00:40:21 <edwardk> monadplus for functors
00:41:17 <edwardk> if it has an 'fzero :: f a' and 'fplus :: f a -> f a -> f a' and is a Functor
00:42:04 <dolio> Huh. I guess being a monoid doesn't really require being Applicative/Monad.
00:42:10 <edwardk> yeah
00:42:28 <edwardk> is there already an applicativeplus or something like that?
00:42:39 <dolio> Yeah. It's called Alternative.
00:42:43 <edwardk> oh yeah
00:42:43 <edwardk> forgot
00:43:32 <dolio> There's another potential forall context.
00:43:40 <dolio> forall a. Monoid (m a) => ...
00:43:41 <edwardk> yeah
00:43:57 <dolio> Although with that, there's also the multiple monoid issue.
00:52:28 * dolio goes to bed.
00:52:35 <edwardk> night
00:52:39 <dolio> Night.
01:02:56 <mmorrow> i hate the multiple monoid issue!
01:03:12 <edwardk> @pl \ws' -> (f,ws')
01:03:12 <lambdabot> (,) f
01:03:20 <edwardk> duh
01:06:00 <visq> hi ! is it possible to use new language pragmas like MagicHash and retain compatible with ghc 6.6 ?
01:07:14 <mmorrow> maybe with cpp if you wanna go there
01:08:15 <ohub> :t (,)
01:08:17 <lambdabot> forall a b. a -> b -> (a, b)
01:08:24 <ohub> oh :)
01:08:50 <vixey> (x,y) = (,) x y
01:08:54 <vixey> :t (,,,,,,,,,,,,,,,,,,,)
01:08:56 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q,
01:08:56 <lambdabot>  r, s, t)
01:09:33 <edwardk> woot my context comonad transformer works
01:09:40 <mmorrow> visq: check out #if USE_ST_MONAD ... #endif /* !USE_ST_MONAD */ here: http://haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Graph.html
01:09:41 <lambdabot> http://tinyurl.com/66dkmd
01:10:24 <edwardk> i didn't want w (s -> a, s) i wanted (w s -> a, w s)
01:11:31 <mmorrow> context comonad transformer has a certain ring to it
01:11:50 <visq> mmorrow: thanks. Are there some popular packages which use cpp for selecting language pragmas ?
01:12:42 <visq> I think the pragmas are a great way to make explicit what extensions you are using.
01:13:14 <mmorrow> visq: that's just a #define, but lemme think a minute
01:13:14 <visq> But staying compatible with 6.6 would be nice as well.
01:14:41 <mmorrow> oh i see what you mean, mostly i've seen this method is used for backwards compat, but using it to conditionally use extensions seems nice
01:15:53 <visq> Yes, but it needs -cpp
01:16:13 <visq> I mean #if needs the CPP extension
01:16:25 <mmorrow> could maybe be a catch 22...
01:16:32 <mmorrow> (just kidding)
01:17:41 <visq> It would be nice if there were some guidelines regarding 6.6 compat on the wiki
01:17:47 <mmorrow> you can always feed the .hs through cpp explicitly to avoid chicken and egg issues
01:28:15 <visq> oh, using -cpp for selecting extensions doesn't work
01:28:41 <mmorrow> yeah, you have to explicitly #define things
01:28:50 <DuClare> Does readFile actually read the whole thing to memory at once, or is there some fancy laziness involved?
01:29:18 <mmorrow> visq: this might be useful: #if __GLASGOW_HASKELL__>661 ... #endif
01:31:01 <DuClare> I might be better off reading a line at a time. :o~
01:32:43 <mmorrow> DuClare: i just did a <- readFile "/dev/sda1" in ghci and it returned immediately...
01:32:57 <DuClare> Hum.
01:33:01 <mmorrow> (/dev/sda1 is 28G)
01:33:09 <DuClare> I guess it's fine thne
01:33:23 <Cale> DuClare: it's lazy
01:33:23 <visq> mmorrow: doesn't seem to work.
01:33:25 <visq> http://hpaste.org/7377
01:33:31 <DuClare> Okay, thanks
01:33:41 <Cale> DuClare: you should never readFile a file and then delete it right after for example...
01:33:53 <Cale> (because you'll be deleting unread parts of the file)
01:34:32 <mmorrow> visq: you should prob use that only with cabal to avoid hellish #defining
01:34:48 <visq> what's that about define ?
01:35:31 <mmorrow> visq: ahh, i just looked the paste. i've never seen that tried
01:36:02 <visq> it seems that the LANGUAGE pragmas are read before the preprocessor is invoked
01:36:15 <visq> just guessing
01:36:15 <mmorrow> you'd have to also put the code that uses the conditionally included extension in #if .. #endif
01:36:59 <visq> ok, but that would be obviously pointless here
01:37:38 <Jedai> Cale: But if you unlink an opened file on Unix it's fine, since you can still read it (you just can't reach it again), no ?
01:37:39 <mmorrow> huh, what exactly didn't work?
01:38:22 <Cale> Jedai: mm... yeah it's probably okay.
01:39:16 <visq> So, the conclusion is: don't use language pragmas if you want to retain compatibility with 6.6 ?
01:40:23 <mmorrow> ohhh. i see.
01:40:56 <mmorrow> you'd definitely (i think) have to use cpp yourself pre-ghc
01:41:46 <mmorrow> rephrasing, using cpp pre-ghc would definitely work
01:42:23 <mmorrow> but you'd have to set all the #defines yourself somehow
01:43:43 <visq> right.
01:52:11 <dancor> @pl \ x y -> [x] ++ y ++ [z]
01:52:11 <lambdabot> (. (++ [z])) . (:)
01:52:21 <dancor> duh
01:52:34 <vixey> that is not worth pl'ing
01:52:59 <dancor> true but i'm considering it in some liftM2 jonx
01:53:23 <dancor> it's a little too much tho
01:54:22 <vixey> > (22:) . (++[88]) $ [1,2,3]
01:54:24 <lambdabot>  [22,1,2,3,88]
01:58:41 <visq> mmorrow: thanks for your suggestions. Still, I'd like to know if it is recommended to use language pragmas at all.
01:59:01 <visq> Maybe I should ask on ghc-users...
02:03:26 <mmorrow> you mean is it recommended to use language pragmas if you're attempting to retain compat with 6.6?
02:04:06 <mmorrow> or in general? imo, no, yes
02:08:36 <ndm> morning all
02:08:46 <ndm> anyone got any Template Haskell experience - Igloo around?
02:09:13 <ToRA> ndm: i have some
02:09:28 <ndm> I'm writing $(derive bar ''A) $(derive bar ''B) $(derive bar ''C) ...
02:09:36 <ndm> where ''A .. ''C are data types
02:09:43 <ndm> is there a way to abstract that?
02:09:58 <ndm> i.e. so I can write names = $[ ''A, ''B, ''C]
02:10:06 <ndm> $(deriveAll bar names)
02:10:17 <dancor> @type join liftM2
02:10:17 <ndm> where deriveAll x = map (derive x)
02:10:19 <lambdabot> forall a2 r. ((a2 -> r) -> a2 -> r) -> ((a2 -> r) -> a2) -> (a2 -> r) -> r
02:10:32 <ToRA> if you have -fth, then ''A is a normal thing you can manipulate
02:10:34 <ToRA> so you could do
02:10:43 <ToRA> $(deriveAll bar [''A, ''B, ''C]) no?
02:10:45 <mmorrow> visq: whoa. everything I said was thinking that LANGUAGE pragmas didn't exist pre-6.8. If that's not the case, then....
02:11:01 <ndm> ToRA - I get very confused with the details
02:11:32 <ToRA> Prelude> :t [''Maybe, ''Bool]
02:11:33 <ToRA> [''Maybe, ''Bool] :: [Language.Haskell.TH.Syntax.Name]
02:11:50 <ToRA> Prelude> [''Maybe, ''Bool]
02:11:50 <ToRA> [Data.Maybe.Maybe,GHC.Base.Bool]
02:11:53 <ndm> deriveAll f = map (derive f) names ;  names = $( [''A, ''B, ''Color] )
02:12:03 <ToRA> no splice there
02:12:23 <ToRA> quasi-quoting doesn't need to run code at compile time
02:12:25 <ToRA> erm
02:12:32 <ToRA> '' doesn't need to run code at compile time
02:12:38 <ToRA> it's a language feature (as i understand it)
02:12:50 <ndm> oh, ok
02:13:35 <ToRA> stuff inside $( .. ) must have type Q [Dec], or Q [Exp] or something, ''x :: Name so your names there wouldn't type check
02:14:13 <ndm> ToRA - yeah, i realised that, but couldn't think how to do the quoting and still get back to TH land - the answer is rather obvious now I know quoting can come outside TH stuff
02:14:21 <ndm> @karma+ ToRA
02:14:21 <lambdabot> ToRA's karma raised to 3.
02:14:28 <ndm> thanks, have it all solved now :)
02:14:33 <ToRA> np
02:20:17 <visq> mmorrow: 6.6 has a slightly different set of language extensions. It supports unboxed tuples for example, but not via LANGUAGE UnboxedTuple.
02:21:28 <visq> Probably its best if cabal handles this, and you don't use language pragmas inside .hs files (if 6.6 compat is an issue, that is)
02:21:57 <taruti> Is there a way to get a recent ghc-head snapshot easily? Seems like there are no binary snapshots for the last month at http://www.haskell.org/ghc/dist/current/dist/
02:21:57 <lambdabot> Title: Index of /ghc/dist/current/dist
02:22:53 <mmorrow> visq: i was just thinking you could write a short program that takes the ghc version and parses any pragma lines, then if need be maps the 6.8 extensions to the 6.6 equivs
02:23:17 <mmorrow> then preproc your src files with that
02:24:28 <dancor> can   (f)   ever differ from   (f >>= right)
02:24:38 <dancor> (f >>= return)
02:24:40 <dancor> i mean
02:24:47 <mmorrow> visq: maybe you could incorporate running that into your cabal Setup.lhs somehow
02:25:32 <wjt> dancor: one of the monad laws is that  x >>= return  is equivalent to  x
02:25:45 <wjt> dancor: you could write an instance of Monad that violates that, but then it wouldn't really be a monad
02:26:04 <dancor> a Liead
02:31:39 <mmorrow> visq: ok, so "-pgmP cmd" uses cmd as the C pre-processor (with -cpp only), so this hypothetical language-options-compat-mapping program could be used as cpp, and it would do its stuff, then feed the src file into cpp itself (somehow preserving all the #defines along the way).
02:32:12 <mmorrow> i dunno if -pgmP is supported in 6.6 though
02:33:02 <visq> mmorrow: Nice idea, but I'd rather stick to standard solutions.
02:33:06 <mmorrow> haha
02:33:14 <visq> Cabal should handle this.
02:33:52 <mmorrow> good luck.
02:34:14 <visq> And to keep maintenance costs low, it is easiest to remove unsupported language pragmas like MagicHash from the cabal file and use fglasgow-exts instead.
02:34:44 <mmorrow> love the -fglasgow-exts sledgehammer
02:35:52 <visq> Yes, not soo beautiful I know. But custom solutions like the one you proposed are really hard to maintain.
02:36:24 <Heffalump> 6.6 will disappear after not too long, hopefully
02:36:30 <mmorrow> they are. i was without sarcasm ;)
02:36:31 <visq> The only thing that bothers me is that I really like in-source-file language pragmas for documentation purposes.
02:37:23 <visq> I think 6.6 is still standard on most (linux a-like) systems ?
02:39:33 <mmorrow> fedora8 has 6.8.2 standard
02:39:53 <visq> Didn't know that. Good to know.
02:48:45 <lewk> Can someone please help me sort out a bug?  My code isn't implementing DFS (it's suppose to) but I wouldn't mind handing in code that at least compiles :)
02:48:53 <lewk> http://hpaste.org/7380?lines=true
02:50:45 <b_jonas> hi guys
02:50:53 <b_jonas> I have to leave very soon now
02:51:00 <lewk> Im getting this error http://hpaste.org/7381 :(
02:51:04 <b_jonas> but in case anyone's interested,
02:51:21 <b_jonas> I've written a primitive version of the @unpl transformer for the J language
02:51:25 <b_jonas> at http://www.jsoftware.com/jwiki/Scripts/TacitToExplicit
02:51:26 <lambdabot> Title: Scripts/TacitToExplicit - J Wiki
02:51:59 <b_jonas> it tries to convert a pointless definition to a lambda
02:56:26 <NameAlreadyInUse> what are some good learning resources for haskell?
02:56:35 <NameAlreadyInUse> preferably something online or a book that isn't too expensive
02:57:44 <paolino> the wiki
02:58:28 <NameAlreadyInUse> where? :\
02:58:43 <paolino> ?go haskell
02:58:44 <lambdabot> http://www.haskell.org/
02:58:44 <lambdabot> Title: Haskell - HaskellWiki
02:58:53 <NameAlreadyInUse> oh
02:58:56 <NameAlreadyInUse> thanks paolino
02:59:44 <paolino> known resources are listed there
02:59:57 <NameAlreadyInUse> ah, great
03:00:15 <NameAlreadyInUse> so haskell doesn't have loops or mutable data?
03:00:45 <paolino> have both
03:01:16 <paolino> they are not used when not needed
03:01:29 <NameAlreadyInUse> so they are available?
03:02:05 <NameAlreadyInUse> but you don't have to use them?
03:02:06 <paolino> loops are abstracted away from flow
03:02:54 <paolino> mutable data are ready in IO and ST monads
03:03:09 <paolino> that I know of
03:03:41 <NameAlreadyInUse> ah
03:04:33 <paolino> looping over lists ie is done by deconstruction
03:05:27 <DuClare> NameAlreadyInUse, You can actually get pretty far without having to use mutable data
03:06:44 <NameAlreadyInUse> yeah, i've done some stuff in scheme
03:09:07 <paolino> at least in most cases *one* can prototype inefficent algorythms without
03:13:29 <paolino> and be quite happy it has taken little time and did it correct
03:13:52 <ivanm> paolino: I think we missed something there... without what?
03:14:16 <paolino> IORef
03:14:25 <ivanm> ahhhh
03:27:57 <GreamBell> ok
03:38:34 * defarge is a noob crossing over to FP from java/c++ focused on building web/middleware and particularly soft real time systems
03:39:40 <defarge> it's going to cost me time to get up to speed and i need to do this fast -- so hoping for advice on whether to go with haskell, erlang or CL
03:40:20 <defarge> right now erlang seems to be the most appropriate for me -- does anyone have comment on what would be best for me?
03:40:52 <ivanm> well, AFAIK CL isn't that functional :p
03:41:46 <defarge> because it has side effects? not single assignment?
03:42:22 <defarge> or should i say single binding (hey i said i was a noob :))
03:42:26 <ivanm> because it does imperative stuff as well
03:42:35 <qwr> defarge: not only. CL culture/style is multiparadigmatic
03:42:48 <ivanm> no side effects is pure programming, not really anything to do with functional stuff
03:43:56 <defarge> ok i understand that i think from what i read so far -- i.e. programmable programming language
03:44:38 <defarge> is haskell more academic than i need -- i.e. should i learn erlang first
03:44:53 <ibid> what happened between ghc 6.6 and 6.8 so that the same code does not require FlexibleContexts and FlexibleInstances with 6.6 but does with 6.8? i find nothing relevant in ghc release notes
03:44:55 <ivanm> I find erlang's syntax rather ugly
03:45:00 <defarge> i'm definitely impressed by armstrong on COP and that reasoning
03:45:29 <ivanm> I had already been using haskell for a bit and wanted to learn erlang as well, but got turned off by its weirdness (e.g. IIRC, there's no concept of a string :s )
03:45:34 <defarge> but haskell seems more "pure"
03:45:56 <qwr> defarge: haskell might be harder to master. although i don't really know... i like haskell/ocaml static typing too much.
03:45:56 <defarge> but the concurrent/fault tolerance does appeal
03:46:24 <augustss_> Erlang has some weird bits, but it's a great implementation.
03:46:25 <ivanm> defarge: yes, that aspect of erlang as well as the ability to soft-reload is rather cool
03:46:29 <defarge> i've faced so many issues with that in java/c++ and frankly i'm sick of it
03:46:40 * ivanm wishes erlang had haskell-like syntax
03:47:01 <defarge> so if i am doing systems that need fault tolerance should i first start with erlang and maybe move up to haskell later?
03:47:48 <ivanm> *shrug* everything I've written in Haskell so far has been for assignments, project, etc.
03:47:49 <qwr> ivanm: somewhat there is no strings in haskell either ;) although haskell has characters and erlang imho didn't really.
03:48:20 <ivanm> qwr: but Haskell has syntax sugaring (i.e. "...") for strings and from my look at erlang it didn't...
03:48:45 <defarge> yea a lot of what i do involves string manipulation
03:49:43 <defarge> but i'm prepared to relinquish that in the syntax if i get reliability
03:50:06 <qwr> ivanm: http://schemecookbook.org/Erlang/StringBasics
03:50:12 <lambdabot> Title: StringBasics - Erlang - e r l a n g : c o o k b o o k
03:50:21 <defarge> qwr: i'll read that ty
03:52:02 <defarge> ok this is a really basic question -- is there equivalent concurrency support in haskell to that inbuilt to erlang?
03:52:13 <defarge> that could seal it for me right now
03:52:38 <augustss_> defarge: mostly, yes
03:52:55 <RayNbow> does the standard library of Haskell contain a "strict" indexing operator? (i.e., an index operator that evaluates all values of a list up to the nth element and returns the latter)
03:53:19 <augustss_> RayNbow: no
03:53:23 <ivanm> qwr: fair enough
03:53:29 <defarge> augustss: oh then i'll read further before deciding ty
03:53:37 <ivanm> defarge: see STM... quite nice
03:53:43 <RayNbow> augustss_: could this be a correct implementation? http://raynbow.pastebin.com/f7c10e14c
03:54:01 <ivanm> though I thought erlangs was more of a parallel processing capability than just concurrency?
03:54:09 <RayNbow> it works on nats `strictIndex` 999999 (nats !! 999999 gives a stack overflow)
03:54:36 * RayNbow is trying it on fibs `strictIndex` 999999 now... but his system is starting to respond slowly :p
03:54:41 <augustss_> RayNbow: looks ok, except that line 6 say genericIndex
03:54:53 <defarge> ivanm: it manages its own processes rather than pushing it out into OS threads yes
03:55:23 <defarge> ivanm: so that does appeal to me given where i'm coming from and what i have to achieve
03:55:28 <ivanm> defarge: as does ghc's STM
03:55:38 <defarge> but i'll read further on the STM stuff in haskell first
03:56:01 <RayNbow> oh joy... there might be a memory leak... my virtual memory is now @ 2300+ MB  :p
03:56:04 <defarge> thanks very much all i have some reading to do - you've been most helpful :)
03:56:13 <ivanm> though STM is more of a way of memory access... you use the standard forkIO primitives (with cheap runtime-based processes) for the actual "threads"
03:56:17 <ivanm> no worries ;-)
03:56:23 <augustss_> RayNbow: which definition of fib?
03:56:43 <RayNbow> fibs = 0 : 1 : zipWith (+) (tail fibs) fibs
03:56:47 <augustss_> RayNbow: and is fibs a global definition?
03:56:59 <RayNbow> I defined it in ghci using let
03:57:09 <augustss_> ugh
03:57:19 <RayNbow> oh, is that a bad thing? :p
03:57:20 <augustss_> it's bound to leak then
03:57:31 <augustss_> it can't be GCed
03:57:34 <RayNbow> ah
03:57:46 <augustss_> because it's still in scope
03:57:53 <opqdonut> yeah you should've used "let fibs = ... in "
03:58:58 <augustss_> in general, anything performance sensitive should be done in compiled and optimized code
03:59:25 <opqdonut> we need a JITting REPL :P
04:00:00 <DRMacIver> Am I right in thinking that in order to do custom lazy IO implementations one basically has to use things like unsafePerformIO, etc.? e.g. suppose I wanted to define a lazy getLines method for strict byte strings.
04:00:06 <RayNbow> I wasn't trying to get high performance... I just trying out strict indexing :p
04:00:27 <RayNbow> (blowing up my virtual memory in the proces :p)
04:00:53 <ivanm> where's that page on the wiki on how to start/write a haskell project?
04:02:11 <RayNbow> btw augustss_, is it ok or not if I had "fibs = ..." as a normal declaration in a HS file?
04:02:24 <augustss_> DRMacIver: most likely, yes
04:02:30 <DRMacIver> ok
04:03:01 <augustss_> RayNbow: I think it should work, but a local definitions is safer
04:03:41 <DRMacIver> (I'm thinking through some ideas regarding custom monads for doing lazy IO with deterministic resource usage and not masquerading IO as pure, and wanted to make sure I had the details of the existing setup straight)
04:04:39 <augustss_> DRMacIver: you might get away with the slightly less evil unsafeInterleaveIO
04:05:20 <DRMacIver> Right. I was subsuming that under the "etc." column. :)
04:05:32 <augustss_> ok :)
04:06:28 <dcoutts> visq: what is it about language extensions that you think cabal should handle?
04:06:29 <DRMacIver> The idea being "you have to perform unsafe operations" more than the details.
04:07:06 <dcoutts> @seen SyntaxNinja
04:07:06 <lambdabot> I saw SyntaxNinja leaving #haskell and #haskell-blah 2h 49m 9s ago, and .
04:07:38 <dcoutts> @tell SyntaxNinja the version of cabal-install you want is the latest darcs version, we'll be making a release after Cabal-1.4 is released
04:07:38 <lambdabot> Consider it noted.
04:08:14 <dcoutts> @tell SyntaxNinja there are recent pre-release shapshots from the cabal website
04:08:14 <lambdabot> Consider it noted.
04:08:41 <visq> dcoutts:  I asked if it is possible to use language pragmas and stay compatible with ghc 6.6.
04:09:01 <DRMacIver> The essential idea is that you can define a pair of monads - one basically looks like a combination of List and IO, and the other is I think a sort of continuation monad, and between them you can recreate a lot of the functionality of lazy lists backed with IO in a safer way.
04:09:09 <dcoutts> visq: the answer is yes, if you put them in the 'extensions:' field
04:09:10 <DRMacIver> It may prove to be nonsense or useless, but it seems an interesting idea
04:09:18 <visq> What does cabal do if there is a language extension UnboxedTuple and it compiles with ghc-6.6 ?
04:09:33 <dcoutts> visq: cabal will translate them into -X flags for ghc-6.8 or -fglasgow-exts for 6.6
04:09:40 <visq> Ah great.
04:09:45 <dcoutts> or if it had a specific flag in 6.6 it'll use it
04:09:45 <DRMacIver> (Or useful, sensible and entirely well known. That often happens too)
04:09:53 <visq> I hoped cabal would do that.
04:09:58 <Maddas> xerox: yow!
04:10:03 <Maddas> @yow
04:10:03 <lambdabot> All right, you degenerates!  I want this place evacuated in 20 seconds!
04:10:27 <visq> dcoutts: So putting language pragmas inside .hs files is discouraged ?
04:10:38 <dcoutts> visq: no, it's encouraged
04:10:48 <dcoutts> it makes it more explicit
04:10:55 <dcoutts> so you know which modules use what
04:11:25 <visq> I like it too.
04:12:04 <visq> But the translation (UnpackedTuples -> fglasgow-exts if ghc-6.6) only works if I specify the extensions in the .cabal file, right ?
04:12:15 <dcoutts> visq: yes
04:12:59 <visq> Thanks for clarifying this.
04:16:32 <ivanm> I'm about to start writing my first "real" library in Haskell... what's the correct directory structure to be used? since It's going to be graph-oriented, have all my code in <src root>/Data/Graph/<library name>/ ?
04:18:59 <lilac> If I compile with optimization turned on, will terms with no unbound variables get evaluated at compile-time?
04:19:47 <Lemmih> lilac: No.
04:20:24 <lilac> is there any way to persuade ghc to evaluate something at compile-time?
04:20:57 <ivanm> hard code it?
04:21:08 <Lemmih> lilac: You most likely don't want that.
04:23:12 <mmorrow> lilac: template-haskell
04:39:38 <lilac> mmorrow: neat, that's pretty easy. thanks!
04:48:20 <mmorrow> th is pretty cool
04:51:17 <Maddas> Lemmih: Why not?
04:53:50 <GreamBell> i need a shell account for psybnc
05:13:42 <ivanm> is there anyway I can use a type alias to save me continuosly having something like: data (Show a) => Foo = Bar a ?
05:15:59 <lilac> i want to split a string on spaces. i've got: filter (not.isSpace.head) (groupBy (\x y -> isSpace x == isSpace y) o)   how might i improve this?
05:17:07 <ivanm> > words "lets split spaces"
05:17:12 <lambdabot>  ["lets","split","spaces"]
05:17:38 <pastorn> ivanm: very funny :D
05:18:05 <ivanm> well, it _is_ an improvement, is it not?
05:19:21 <ivanm> I've found that if I've ever wished there was a simple function that did foo, then there usually already was one
05:19:54 <EvilTerran> ?src words
05:19:54 <lambdabot> words s = case dropWhile isSpace s of
05:19:54 <lambdabot>     "" -> []
05:19:54 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
05:22:30 * RayNbow pats Haskell
05:23:05 * DuClare bats Haskell.
05:23:19 <RayNbow> it computed the millionth Fibonacci number... (iteratively... a nice way to waste some CPU cycles)
05:23:43 <lilac> ivanm: now if only there were an easy way to *find* the simple function that did foo.
05:23:47 * lilac looks at #haskell
05:24:27 <Beelsebob> @hoogle String -> [String]
05:24:28 <lambdabot> Prelude.lines :: String -> [String]
05:24:28 <lambdabot> Prelude.words :: String -> [String]
05:24:28 <lambdabot> Data.List.lines :: String -> [String]
05:24:33 <Beelsebob> there you go lilac
05:24:37 <ivanm> Beelsebob: dammit, you beat me to it!
05:24:43 <Beelsebob> lol
05:25:14 <lilac> @hoogle MonadPlus m => [m a] -> m a
05:25:15 <lambdabot> Prelude.head :: [a] -> a
05:25:15 <lambdabot> Prelude.last :: [a] -> a
05:25:15 <lambdabot> Data.List.head :: [a] -> a
05:25:27 <ivanm> lilac: the scary thing is when the channel looks back! :p
05:25:34 <lilac> :)
05:25:35 <olsner> lilac: the laziest way is to go to #haskell, describe what you want to do, then wait for the responses (seems it took a whole 1m08s for ivan to answer this one though)
05:26:01 <olsner> the other way is to hoogle for the type of the function
05:26:03 <ivanm> lol
05:26:23 <Beelsebob> lilac: for a more complete listing btw http://www.haskell.org/hoogle
05:26:24 <lambdabot> Title: Hoogle
05:26:31 <Valodim> haskell doesn't promote laziness >:(
05:26:38 <ivanm> what's the correct way of specifying that my custom data type takes in a parameter which is in the Show class?
05:26:40 <Beelsebob> yes it does
05:26:48 <ivanm> Beelsebob: no, it promotes non-strictness
05:26:55 <Beelsebob> true dat
05:26:57 <ivanm> which usually devolves down to laziness
05:27:09 <olsner> it is strange though, that you only got three answers, seems #haskell is unusually quiet today
05:27:10 <ivanm> (is there even a non-lazy implementation of haskell?)
05:27:37 <Valodim> how could it
05:27:37 <Beelsebob> ivanm: I thought SPJ had fiddled with an optimistic evaluator for it
05:27:51 <Heffalump> Rob Ennals did, but it didn't make enough difference to be merged, I think
05:28:04 <ivanm> Beelsebob: could be... I know there's Eager Haskell, but I don't recall ever seeing a release for it
05:28:05 <lilac> hmm. why is the only function which matches my search the 98th hit on hoogle?
05:28:21 <Heffalump> Eager Haskell was very coarse-grained eagerness
05:28:22 <ivanm> @where hayoo
05:28:23 <lambdabot> I know nothing about hayoo.
05:28:27 <Beelsebob> lilac: because hoogle doesn't know much about classes at the moment
05:28:31 <ivanm> what's that new API search engine?
05:28:32 <Beelsebob> ndm is working on that one
05:28:39 <Heffalump> speculative execution (Rob Ennals' work) was much more fine-grained, and was a GHC branch
05:28:53 <ivanm> AFAIK, the only implementations that are even partially alive atm are {g,y,n,j}hc and hugs
05:29:12 <ivanm> Heffalump: "coarse-grained"?
05:29:16 <Beelsebob> I haven't heard anything about jhc for ages
05:29:51 <ivanm> someone mentioned it on -cafe the other day, IIRC
05:29:52 <Philippa> ivanm: eagerness or otherwise applying to large chunks
05:29:59 <ivanm> ahhh
05:30:02 <maltem> @where+ hayoo http://holumbus.fh-wedel.de/hayoo/hayoo.html
05:30:03 <lambdabot> I will never forget.
05:30:17 <ivanm> lilac: have a look at hayoo that maltem posted the link to above
05:30:31 <ivanm> it does the same thing as hoogle but differently atm
05:31:10 <maltem> Now, hayoo doesn't know much about classes either.
05:31:20 <Beelsebob> ivanm: is there something it does better than Hoogle?
05:31:20 <ivanm> heh
05:31:29 <Beelsebob> because at the moment, it just seems like a more annoying version
05:31:47 <ivanm> Beelsebob: live search? I haven't used it much, since I unfortunately haven't done much non-xmonad.hs haskell for a while :(
05:31:54 <ivanm> starting again now though! :D
05:32:02 <Beelsebob> yeh, the live search is exactly what I'm finding annoying about it
05:32:05 <ivanm> but yes, I found it more annoying than anything else as well
05:32:28 * ivanm considers gmail and google maps the only decent ajax sites around, and even then they've got bugs
05:33:03 <Beelsebob>  /.'s new comments page works pretty well
05:33:31 <wjt> Beelsebob: you mean, apparent from the quality of the comments?
05:33:41 <Beelsebob> indeed
05:33:42 <ivanm> well, seeing as how I don't frequent such sordid places :p
05:34:20 <Beelsebob> heh
05:34:29 <maltem> Beelsebob: direct "Source" links and different colors, that's about it. but it'd be interesting to know if/how their searching strategy differs
05:34:50 <Beelsebob> who wrote it? do you know?
05:35:09 <ivanm> dammit, I was talking to them the other day...
05:35:11 <Heffalump> ivanm: with any evaluator for Haskell, you have to suspend at some point, otherwise you violate Haskell's non-strict semantics if you happen to be evaluating something infinite.
05:35:16 * ivanm checks logs
05:35:19 <ivanm> Heffalump: *nod*
05:35:21 <maltem> Beelsebob, there's a bottom line on the page
05:35:33 <Heffalump> Eager Haskell spent a long time before suspending.
05:35:44 <Beelsebob> so there is
05:35:51 <ivanm> Beelsebob: shag
05:36:11 <ivanm> @seen shag
05:36:12 <lambdabot> I saw shag leaving #gentoo-haskell and #haskell 1d 13h 21m 26s ago, and .
05:36:58 <ivanm> Heffalump: ahhh, OK.... so it was way too eager to evaluate stuff? :p
05:37:10 <lilac> ivanm: thanks. seems like a nicer inferface, even if the results don't appear to be much better
05:37:18 <ivanm> heh
05:37:38 <ivanm> I know that there's a firefox searchbar plugin for hoogle as well
05:38:05 <mux> yay, finally got a working haskell solution for the problem 54 of project euler, ie the poker one
05:38:09 * RayNbow pokes luite... "don't be shy" :p
05:38:20 <Beelsebob> heh, Safari Inquisitor doesn't need plugins for such things
05:38:22 <mux> and I got to use both applicative functions (for parsing) and monoids
05:38:26 <Beelsebob> you just tell it the query format and it does it
05:38:33 * mux happy
05:38:38 <ivanm> Beelsebob: tell it the format? how?
05:38:57 <lilac> Beelsebob: firefox can do the same
05:39:06 <mux> http://hpaste.org/7386 for those interested
05:39:17 <Beelsebob> ivanm: you tell it to search using "http://haskell.org/hoogle/?q=%@"
05:39:42 <Deewiant> in firefox it's %s
05:39:52 <ivanm> ahhh, k
05:57:29 <RayNbow> hmm, does anyone know where I can find the code for Integer multiplication? I have found that timesInteger uses timesInteger#, but now I'm interested in the definition of the latter one :)
05:58:01 <mmorrow> lilac: started messing around with th stuff and got http://hpaste.org/7387
05:58:08 <MyCatVerbs> RayNbow: anything ending in # is a primitive, generally. As in, you'd have to look in your compiler's implementation (I presume GHC).
05:58:53 <RayNbow> MyCatVerbs: I have the source of GHC here, but I have no idea where I'm supposed to look
05:58:58 <int-e> RayNbow: look in rts/PrimOps.cmm in the ghc sources
05:59:16 <RayNbow> ah thx
05:59:39 <int-e> (that defines timesIntegerzh_fast in terms of __gmpz_mul of libgmp)
06:00:11 <ivanm> RayNbow: I'm guessing it uses C code, etc.... so you won't actually find any Haskell source for it :p
06:01:47 <ivanm> is Data.Map the best choice to use for a single-use lookup table? I have a function of type: [a] -> [(a,a)] -> ..., and as part of it I want to replace all a's in the second argument with Int values
06:03:11 <int-e> RayNbow: another bit of glue is defined in compiler/prelude/primops.txt.pp
06:07:39 <lilac> mmorrow: i'm still trying to figure out what you've done there ;-)
06:11:03 <ivanm> @hoogle lookup
06:11:04 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
06:11:04 <lambdabot> Data.List.lookup :: Eq a => a -> [(a, b)] -> Maybe b
06:11:04 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
06:11:23 <ivanm> are HashTables implemented in IO?
06:14:11 <qwr> use Data.Map if you want pure map
06:16:11 <ivanm> @type M.lookup
06:16:13 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
06:16:20 <ivanm> why does it use a monad though?
06:16:31 <ivanm> presumably I can just use the Maybe monad or something though?
06:16:42 <EvilTerran> indeed
06:16:46 <EvilTerran> i imagine it uses fail
06:16:55 <mux> yes it does
06:17:04 <ivanm> *nod*
06:17:43 <ivanm> with Data.Map k a, which is the index and which the output? i.e. does k map to a or vice-versa?
06:17:58 <qwr> k is key
06:18:34 <ivanm> *nod*
06:19:03 <ivanm> String is an instance of Ord, isn't it? (since String == [Char] and Char is presumably an instance of Ord?)
06:19:30 <EvilTerran> yes
06:19:38 <EvilTerran> > "foo" < "food"
06:19:39 <lambdabot>  True
06:19:41 <EvilTerran> > "foom" < "food"
06:19:43 <lambdabot>  False
06:20:00 <ivanm> good-o
06:23:45 <DRMacIver> Hm. Is C-- still being actively developed? The site doesn't seem to have anything from the last year
06:23:54 <johnnowak> > "D" < "c"
06:23:55 <lambdabot>  True
06:24:17 <sieni> > 'D' < 'c'
06:24:18 <lambdabot>  True
06:24:26 <sieni> > 'd' < 'c'
06:24:27 <lambdabot>  False
06:25:17 <mmorrow> lilac: http://hpaste.org/7387#a2
06:25:36 <johnnowak> silly question: why is Char an instance of Ord?
06:25:47 <DRMacIver> Why wouldn't it be?
06:25:52 <johnnowak> why wouldn't anything be?
06:25:54 <ivanm> johnnowak: because there is an order involved?
06:26:09 <ivanm> 'a' < 'b' < 'c' < 'd' etc.
06:26:10 <johnnowak> the order varies though depending on how you want them ordered
06:26:16 <MyCatVerbs> johnnowak: because we can order them on the number of their unicode codepoints.
06:26:22 <ivanm> used for string searching, etc.
06:26:41 <MyCatVerbs> johnnowak: if you want a different order, I'd recommend newtyping them and declaring an Ord instance for the newtype.
06:26:46 <DRMacIver> johnnowak: Most things which could reasonably be ordered are Ord. It's really useful from a data structures point of view.
06:27:07 <johnnowak> MyCatVerbs: ah, i suppose there is that.
06:27:13 <MyCatVerbs> johnnowak: also, for things like Data.Map and friends in particular, it's really useful to have pretty much everything be an Ord instance.
06:27:15 <DRMacIver> If you want to use a custom ordering, having them be Ord doesn't make it any harder that it would already be.
06:27:17 <mmorrow> lilac: i'm pretty sure (but not positive) that (read _) will get evaluated at compile-time, and the spliced in code will be the result
06:27:20 <DRMacIver> And it's convenient for a lot of things.
06:28:08 <DRMacIver> Also, the ord instance for Char seems like a correct default
06:28:14 <MyCatVerbs> e.g. if Char wasn't an Ord instance, [Char] wouldn't be either, so I couldn't have things like a Data.Map.Map String String for passing around configuration parameters, for example.
06:29:27 <johnnowak> i suppose it's just a matter of thinking of it as "orderable" rather than "ordered"
06:30:30 <ivanm> "orderable with a default imposed order"?
06:30:59 <DRMacIver> "has a reasonable way of ordering it" more than "has a canonical ordering"
06:31:57 <sieni> I guess it's just leakage of information from the implementation to the interface
06:32:09 <MyCatVerbs> DRMacIver: I'd say even less strong than that. "An ordering is defined" rather than "a sensible ordering is defined">
06:32:40 <sieni> the implementation might be using binary trees, where you presumably want the ordering, even though the ordering isn't otherwise visible in the interface
06:32:45 <MyCatVerbs> DRMacIver: that said, we're working on computers. Everything we can represent is orderable - all we have to do is bitwise comparison.
06:33:13 <DRMacIver> I meant reasonable more in the sense of "not totally stupid". :)
06:33:32 <johnnowak> totally stupid orderings would work fine for using them as keys too
06:33:57 <sieni> johnnowak: indeed
06:33:59 <DRMacIver> Well, degenerate orderings don't work very well as keys.
06:34:17 <DRMacIver> "compare x y = Eq" would be a bad choice for example
06:34:33 <Philippa> "stupid but not pathological"
06:36:20 <DRMacIver> Well, orderings which identify too large a set of things aren't really pathological. They can be quite useful.
06:36:26 <DRMacIver> They're just not really orderings.
06:36:42 <DRMacIver> But I'm nitpicking now. :)
06:37:38 <tonky> um, guys, how do i cast fractional to float? http://hpaste.org/7388
06:37:44 <EvilTerran> realToFrac, iirc
06:38:13 <EvilTerran> tonky, however, you're not using a Fractional type there
06:38:26 <EvilTerran> you're using an Integral type (Int), so want fromIntegral
06:38:42 <EvilTerran> or you could use `div` instead of (/), depending on what you want exactly
06:38:42 <tonky> so a/b is Integral?
06:38:53 <EvilTerran> a :: Int
06:38:55 <EvilTerran> ?type (/)
06:38:56 <lambdabot> forall a. (Fractional a) => a -> a -> a
06:39:10 <EvilTerran> / takes two values of the same type and returns something of the same type
06:39:25 <EvilTerran> but the type must be a Fractional type, and Int isn't
06:40:21 <EvilTerran> ?type (/) `on` fromIntegral
06:40:22 <lambdabot> forall b a. (Integral a, Fractional b) => a -> a -> b
06:40:56 <tonky> i tried fromIntegral, but it didn't work either. http://hpaste.org/7389
06:41:04 <tonky> sorry, getting lost in all of these :)
06:41:30 <EvilTerran> c and b are both type Int. you can't pass Ints to /
06:41:31 <Beelsebob> tonky: the (/) operator doesn't work on integer types
06:41:34 <EvilTerran> your fromIntegral is in the wrong place
06:41:42 <tonky> ah
06:41:50 <Beelsebob> (/) :: Real a => a -> a -> a
06:42:04 <Beelsebob> IIRC
06:42:10 <Deewiant> ?ty (/)
06:42:12 <lambdabot> forall a. (Fractional a) => a -> a -> a
06:42:13 <Beelsebob> or is it fractional?
06:42:14 <wjt> ?ty div
06:42:14 <Beelsebob> yes
06:42:16 <lambdabot> forall a. (Integral a) => a -> a -> a
06:43:21 <EvilTerran> `div` does divide-and-round-down
06:43:32 <tonky> exactly
06:43:38 <EvilTerran> but without the risk of floating-point errors presented by using fromIntegral, (/), and floor
06:43:40 <maltem> tonky, btw, do you really want -c/b rather than -c/a ?
06:43:43 <EvilTerran> and faster
06:43:48 <Deewiant> ?ty (/) `on` round
06:43:49 <lambdabot> forall b a. (Integral b, RealFrac a, Fractional b) => a -> a -> b
06:43:56 <EvilTerran> ...
06:44:06 <tonky> lol, maltem - idd :)
06:44:24 <tonky> so, i should cast Int's to float before division?
06:44:55 <tonky> i guess not
06:45:02 <maltem> :) if you want Float as a result type, then you should
06:45:13 <tonky> oh, ok, lemme try
06:45:49 <maltem> But let's call it convertion rather than a cast. Casts sound so C-ish...
06:46:15 <mux> the appropriate term is coercion, fwiw
06:46:24 <tonky> ok, sure
06:47:36 <maltem> coercion sounds so violent... but alright
06:48:09 <Beelsebob> the difference by the way is that a cast merely takes the bit pattern and says "actually, these bits are not an int, they're a float", coercion actually does some kind of sane conversion so that 5 comes out the other end as 5.0
06:48:18 <Deewiant> 'cast' doesn't? :-P
06:48:35 <Deewiant> (maltem: ^)
06:48:56 <tonky> i'm still trying to figure out how to coerce Int to Float btw :)\
06:49:05 <Beelsebob> fromIntegral
06:49:12 <Deewiant> Beelsebob: well, in C-family languages you'd call a Float->Int type conversion a cast even though it does change the bit pattern
06:49:17 <Beelsebob> > (fromIntegral 5) :: Float
06:49:18 <lambdabot>  5.0
06:49:31 <maltem> Deewiant, it would sound less violent if the word weren't used in C :)
06:49:37 <Beelsebob> Deewiant: yes, but that doesn't mean it *is* a cast
06:49:46 <Beelsebob> remember, C gets a lot of things wrong
06:49:47 <Beelsebob> :P
06:49:53 <Deewiant> Beelsebob: was the official terminology established somewhere? :-P
06:49:59 <johnnowak> now lets discuss what strong typing means
06:50:02 <tonky> nm, got it
06:50:18 * EvilTerran likes his type systems big and strong :)
06:50:19 <MyCatVerbs> johnnowak: or just copy ML instead. ;p
06:50:19 <Deewiant> maltem: youre 'casting' from one type to another - you're throwing the value into another type. Sounds pretty violent to me. ;-)
06:51:07 <maltem> sure ^^
06:51:48 <ivanm> what does this error mean? "Inferred type is less polymorphic than expected"
06:52:47 <DuClare> Does 'lines' drop empty lines?
06:52:58 <ivanm> @type lines
06:52:59 <lambdabot> String -> [String]
06:53:04 <ivanm> @src lines
06:53:04 <lambdabot> Source not found.
06:53:06 <Beelsebob> > lines "abc\n\njam\nham\n"
06:53:07 <lambdabot>  ["abc","","jam","ham"]
06:53:09 <Beelsebob> no
06:53:11 <sieni> > lines "sdfg\n\nsdfgsdfgs\nsdfgsfdg"
06:53:12 <lambdabot>  ["sdfg","","sdfgsdfgs","sdfgsfdg"]
06:53:17 <sieni> no :-)
06:53:26 <wjt> > (filter (not . null) . lines) "monkey\nmonkey\n\nwilliam\nshatner"
06:53:27 <lambdabot>  ["monkey","monkey","william","shatner"]
06:53:32 <DuClare> Great, thanks. :)
06:53:58 <Valodim> haha, shatner
06:54:08 <johnnowak> i'm not sure i could use william shatner as a metasyntactic variable of sorts without causing nausea
06:54:34 <tonky> ok, got it working, thanks everyone :) http://hpaste.org/7390 can i make it better? i dont like coercing 2 different variables separately. there got to be a better way :)
06:55:10 <EvilTerran> you could write it as ((/) `on` fromIntegral) (-c) a
06:55:18 <EvilTerran> not that that's much better
06:55:23 <Beelsebob> :t on
06:55:24 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
06:55:31 <EvilTerran> `on` is defined in Data.Function
06:55:32 <Beelsebob> cunning
06:55:52 <Beelsebob> anyway, why would you not coerce the two seperately?
06:56:15 <tonky> dunno. maybe it's my weak typing talking in me :)
06:56:19 <tonky> ok, thanks :)
06:56:32 <Deewiant> > (\a b -> (-b) * recip (fromIntegral a)) 5 3
06:56:33 <lambdabot>  -0.6000000000000001
06:56:47 <Beelsebob> i have to admit that mixing integer/real maths is probably the messiest bit of Haskell's type system
06:56:47 <Deewiant> somewhat cheating but that avoids one fromIntegral :-P
06:57:24 <sclv> ?quote fromIntegral
06:57:24 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
06:57:56 <Deewiant> that name is much too long.
06:57:57 <Beelsebob> >.<
06:58:13 <Deewiant> don't know what would be much better, though.
06:58:21 <Beelsebob> fi = fromIntegral
06:58:24 <Beelsebob> there you go
06:58:32 <Deewiant> yeah, because that's intuitive and clean. :-P
06:58:34 <EvilTerran> class Cast a b where cast :: a -> b -- >:)
06:59:05 <MyCatVerbs> EvilTerran: call it Interchangeable instead?
06:59:22 <EvilTerran> i was thinking calling it inject might be better
06:59:27 <MyCatVerbs> (Can't have the names too short, elsewise clowns will murder us in our sleep.)
07:00:12 <EvilTerran> class Inject a b where inject :: a -> b; extract :: b -> Maybe a -- or something
07:01:13 <MyCatVerbs> That's a bit more general, though.
07:01:56 <Deewiant> extract :: Maybe (b -> a)
07:02:13 <MyCatVerbs> Sound more like a generalisation of listToMaybe than casting.
07:03:06 <ivanm> what can I do about this error? "Quantified type variable `a' is mentioned in the environment:"
07:03:20 <Beelsebob> Deewiant: I think I'd want extract to be b -> Maybe a actually
07:03:42 <Beelsebob> so extract 5.0 :: Maybe Int produced Just 5, but extract 5.3 :: Maybe Int produced Nothing
07:04:12 <MyCatVerbs> Deewiant: b -> Maybe a gives you the ability to express thing like the idea that some but not all lists are convertible to elements, etc.
07:04:16 <Deewiant> I'd just have no extract method
07:04:28 <Deewiant> have an instance in the other direction if one exists
07:04:45 <maltem> Beelsebob, floating point arithmetics would bite you anyway when you determine whether 5.0 is integral
07:04:49 <Deewiant> if not, there are better-specified conversion functions like round, floor, head, tail, etc.
07:04:54 <Deewiant> er, not tail, but anyway.
07:05:01 <MyCatVerbs> And also to express things like how only a subset of Float's possible values are convertible to integers without loss of precision, etc.
07:05:10 <Beelsebob> maltem: depends on the representation used for 5.0
07:05:27 <MyCatVerbs> Beelsebob: most *fast* representations will bite you in the ass, though.
07:05:33 <Beelsebob> yes
07:05:45 <maltem> Beelsebob, ah right, my thinking was fixed to floating-points
07:06:21 <maltem> (that stood at the beginning of this talk)
07:06:25 <Beelsebob> in all honesty, so was mine, until I thought for a sec when you said it would bite me
07:06:26 <Beelsebob> :P
07:06:37 <maltem> heh
07:07:05 <MyCatVerbs> IMO, I'd rather see (Cast a b, Cast b a) than a single Cast instance that covers both directions.
07:07:24 <Deewiant> ditto.
07:07:32 <Beelsebob> but again, that doesn't cover the case where there's only a partial cast in one direction
07:07:42 <MyCatVerbs> But then, that's not necesarily such a good idea anyway, for numerical data. I mean, are you rounding? Truncating? Rouding upward, downwards, or towards zero?
07:07:51 <maltem> class Cast where ...; class PartialCast where ...
07:08:16 <Beelsebob> true
07:08:30 <maltem> only, will it be partialCast, pcast, maybeCast or mcast?
07:08:48 <MyCatVerbs> Beelsebob: I can't really think of so many places where a partial cast would be useful for numerical stuff. For containers, sure, but in that case you want to call the interface Inject anyway. :)
07:09:13 <Beelsebob> MyCatVerbs: could be true
07:09:53 <MyCatVerbs> Standard caveat applies: there could well be entire fields of useful utilities that would be made easier to write that way. I just can't think of any.
07:14:48 <Saizan> the conversion between Integer and Float is partial in both directions, btw
07:14:57 <Beelsebob> so it is
07:15:01 <Deewiant> even between Int and Float
07:15:41 <Beelsebob> question is, do you want integers near max int to round to the {nearest | lower | upper} float, or just return Nothing
07:16:15 <Deewiant> > fromIntegral 2^29 :: Float
07:16:16 <lambdabot>  5.3687092e8
07:16:21 <Deewiant> > 2^29
07:16:23 <lambdabot>  536870912
07:16:46 <DuClare> Hi. :o  Currently I'm matching regexes on the same string twice:  first to determine what type of data it contains (like, isUserName :: String -> Bool) and if it evaluates to true, then matching again to actually *extract* the username from this string.  Is there a way to avoid this repetition and handle everything in one pass?
07:17:18 <EvilTerran> for each type of data, return a Maybe <type> instead of just the type
07:17:21 <eugman|college> Is there a way to filter based a list of functions and or them all together so if any one returns true then the element is not filtered?
07:17:35 <EvilTerran> return Nothing if it doesn't match, otherwise Just <the value>
07:17:45 <DuClare> EvilTerran, Right, of course.  I must be an idiot. :)
07:17:50 <maltem> Hmm, nobody has yet uttered the usual warning that you normally use Double instead of Float anywhere?
07:17:56 <ivanm> http://hpaste.org/7392 <-- can anyone see what's wrong here?
07:17:58 <Beelsebob> EvilTerran: either that or an Either a a containing a precice version, or an imprecise version depending on Left/Right
07:18:08 <MyCatVerbs> eugman|college: you could roll 'em all up into one function.
07:18:32 <sieni> eugman|college: use "any"
07:18:47 <Saizan> maltem: that just requires Int64 instead of Int32 to get you in trouble :)
07:18:51 <DuClare> EvilTerran, Thank you.
07:19:22 <eugman|college> sieni, you can't have reasonably named syntax because then I look silly. :)
07:19:29 <eugman> thanks
07:20:08 <Saizan> ivanm: remove the signature on nodeMap
07:20:50 <Saizan> ivanm: if you really want it enable ScopedTypeVariables and use a forall a. in importData's signature
07:21:07 <sieni> > filter (\x -> any (\f -> f x) [(>5), (<3)]) [1..7]
07:21:09 <lambdabot>  [1,2,6,7]
07:21:16 <ivanm> Saizan: grrr..... I tried splitting that function out because it wasn't working... for some reason I thought I needed it there :s
07:21:29 <ivanm> why does it make a difference?
07:22:21 <Saizan> ivanm: the 'a' in nodeMap's signature doesn't refer to the 'a' in importData's one, it's a distinct type variable for the compiler
07:22:30 <ivanm> ahhhh
07:22:47 <ivanm> I thought it would have been the same :s
07:24:06 <Saizan> no, in haskell98 it won't, that's reason for the ScopedTypeVariables extension
07:24:22 <ivanm> *nod*
07:26:14 <sieni> eugman: did that answer your question?
07:27:58 <sieni> @pl (\x y -> filter (\z -> any (\f -> f z) x) y)
07:27:59 <lambdabot> filter . flip (any . flip id)
07:28:31 <sieni> > filter . flip (any . flip id) [(>5), (<3)] [1..7]
07:28:32 <lambdabot>  Couldn't match expected type `f (a -> Bool)'
07:28:40 <sieni> > filter . flip (any . flip id) $ [(>5), (<3)] [1..7]
07:28:41 <lambdabot>  Couldn't match expected type `t -> [a -> Bool]'
07:28:53 <sieni> wtf
07:29:10 <sieni> > (\x y -> filter (\z -> any (\f -> f z) x) y) [(>5), (<3)] [1..7]
07:29:11 <lambdabot>  [1,2,6,7]
07:29:42 <Botje> > filter $ flip (any . flip id) [(>5), (<3)] [1..7]
07:29:43 <lambdabot>  Couldn't match expected type `a -> Bool'
07:29:46 <Botje> uh
07:29:46 <sieni> > (filter . flip (any . flip id)) [(>5), (<3)] [1..7]
07:29:46 <Botje> fail :)
07:29:48 <lambdabot>  [1,2,6,7]
07:30:48 <DuClare> Uhhuhh.. :|
07:30:53 <eugman> sieni, yes quite. I probably should have checked prelude for an any function
07:31:34 <mar77a> hello, i'm new to haskell and i need a bit of help solving "We've seen how to calculate sums and products using folding functions. Given that the function max returns the maximum of two numbers, write a function using a fold that will return the maximum value in a list (and zero if the list is empty). So, when applied to [5,10,2,8,1] it will return 10. " items of the list are >= 0 too
07:31:42 <sieni> @pl \f -> f
07:31:43 <lambdabot> id
07:31:44 <sieni> @pl \f -> f x
07:31:45 <lambdabot> ($ x)
07:31:45 * edwardk wakes up and proceeds to flood the channel with poorly thought out category theory.
07:32:00 <allbery_b> @wiki Homework_help
07:32:00 <lambdabot> http://www.haskell.org/haskellwiki/Homework_help
07:32:12 <mar77a> it's not homework >:(
07:32:21 <TomMD> > maximum []
07:32:22 <lambdabot>  Exception: Prelude.maximum: empty list
07:32:43 <TomMD> @let newMaximum = maximum . (0:)
07:32:44 <lambdabot> Defined.
07:32:51 <TomMD> > newMaximum []
07:32:52 <lambdabot>  0
07:33:00 <TomMD> mar77a: See above
07:33:02 <maltem> mar77a: Show us what you tried so far.
07:33:03 <Philippa> mar77a: here's a hint - you need to fold a function that does something involving the maximum over the list
07:33:36 <allbery_b> TomMD: no negative numbers?
07:33:51 <Philippa> allbery_b: we were given that, yeah
07:34:02 <mar77a> i've tried
07:34:04 <mar77a> foldr max [5,10,2,8,1] 0
07:34:05 <TomMD> allbery_b: Seeing as its an obvious cheat - it was more for fun.  Still, it wouldn't be hard to filter out negatives.
07:34:14 <maltem> @type foldr
07:34:15 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:34:25 <maltem> mar77a: Pay attention to argument order.
07:34:26 <edwardk> mat77a very close
07:34:46 <mar77a> oops
07:35:05 <mar77a> > foldr max 0 [5,10,2,8,1]
07:35:06 <lambdabot>  10
07:35:34 <maltem> There you go. Of course, there's the same issue with negative numbers as with the maximum . (0:) solution
07:35:55 <TomMD> maltem: But the answer will be the same because 0 is greater than any negative.
07:35:55 <EvilTerran> > foldr max minBound [5,10,2,8,1]
07:35:56 <lambdabot>  Add a type signature
07:36:06 <mar77a> i'm not sure what that unfolds to
07:36:19 <edwardk> @seen cale
07:36:19 <maltem> TomMD, that's why I used the word "same", too
07:36:19 <lambdabot> cale is in #ghc, #haskell-overflow and #haskell. I last heard cale speak 5h 57m 56s ago.
07:36:31 <Deewiant> > foldr max minBound [5,10,2,8,1] :: Int
07:36:33 <lambdabot>  10
07:37:06 <EvilTerran> > foldr max Nothing . map Just $ [5,10,2,8,1]
07:37:07 <lambdabot>  Just 10
07:37:09 <EvilTerran> > foldr max Nothing . map Just $ []
07:37:10 <lambdabot>  Nothing
07:37:18 <mar77a> foldr max 0 [5,10,2,8,1] how does this work exactly
07:37:27 <Deewiant> > foldr f z [a,b,c,d,e]
07:37:28 <lambdabot>  f a (f b (f c (f d (f e z))))
07:37:45 <TomMD> Answer: Lots of thunks
07:38:08 <EvilTerran> > foldr min Nothing . map Just $ [5,10,2,8,1] -- won't work, though
07:38:09 <lambdabot>  Nothing
07:38:21 <edwardk> maltem/evilterran: the problem did mention to have the empty list go to 0
07:38:28 <EvilTerran> oh, ok
07:38:32 <maltem>  > foldr f o [a,b,c,d,e] -- mar77a
07:38:38 <maltem> > foldr f o [a,b,c,d,e] -- mar77a
07:38:39 <lambdabot>  f a (f b (f c (f d (f e o))))
07:39:14 <mar77a> is it like a function composition
07:39:46 <sclv> > foldr1 max [0,2,5,1,6,7]  :: Expr
07:39:47 <lambdabot>  max 0 (max 2 (max 5 (max 1 (max 6 7))))
07:39:49 <maltem> It's a fold...
07:40:21 <kpreid> sclv: cute
07:40:27 <mar77a> hm
07:40:30 <maltem> Oh, we can print an Expr without defining it?
07:40:32 <mar77a> how does max work
07:40:38 <kpreid> @src max
07:40:38 <lambdabot> max x y = if x <= y then y else x
07:40:38 <EvilTerran> ?type maybe
07:40:40 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:40:53 <mar77a> perfect
07:40:57 <EvilTerran> > maybe 0 minimum $ [5,10,2,8,1]
07:40:58 <lambdabot>  Couldn't match expected type `Maybe [a]'
07:41:05 <EvilTerran> er
07:41:07 <mar77a> > max 0 0
07:41:08 <lambdabot>  0
07:41:40 <mar77a> joy i got it
07:41:40 <EvilTerran> > maybe 0 minimum . (guard <$> not.null <*> return) $ [5,10,2,8,1]
07:41:41 <lambdabot>  Couldn't match expected type `Maybe [a]' against inferred type `()'
07:42:03 <EvilTerran> > maybe 0 minimum . ((>>) <$> guard.not.null <*> return) $ [5,10,2,8,1]
07:42:04 <lambdabot>  1
07:42:10 <EvilTerran> whee! :P
07:42:28 * Maddas falls off his chair
07:42:30 <sclv> > maybe 0 minimum . ((>>) <$> guard.not.null <*> return) $ []
07:42:32 <lambdabot>  0
07:43:06 <sclv> > maybe 0 minimum . ((>>) <$> guard.not.null <*> return) $ [5,10,2,8,1] :: Expr
07:43:08 <lambdabot>  min (min (min (min 5 10) 2) 8) 1
07:43:17 <sclv> zounds.
07:43:29 <mar77a> how can i define something in ghci without loading a module?
07:43:51 <sclv> let, just like in a do block.
07:44:16 <sclv> "let func x = x + 5" for example
07:44:16 <mar77a> sounds mathematical
07:44:42 <maltem> Adding five _is_ mathematical.
07:44:53 <mar77a> no, the "let" :p
07:45:18 * EvilTerran eta-reduces to (+5)
07:45:33 <allbery_b> haskell is pretty mathematical in notation, yes
07:45:40 * maltem sets -XNoMonomorphismRestriction
07:45:42 <mar77a> me likes
07:45:43 <allbery_b> but "let" creates a binding (variable)
07:45:54 <DuClare> Hum.
07:46:04 <Spark> int x = 10 ; e
07:46:07 <DuClare> How can I have a literal * within regular expression?
07:46:11 <Spark> let x = 10 in e
07:46:13 <DuClare> The pattern
07:46:18 <EvilTerran> maltem, i thought the DMR didn't apply to things of functional type, anyway
07:46:24 <sieni> DuClare: \* perhaps?
07:46:30 <DuClare> sieni, I tried that..
07:46:36 <wjt> \\*
07:46:38 <DuClare>     lexical error in string/character literal at character '\\'
07:46:40 <DuClare> Oh
07:46:43 <EvilTerran> hm... apparently not
07:47:04 <DuClare> wjt, Great. :)
07:47:22 <EvilTerran> hooray for leaning toothpick syndrome!
07:47:25 <sieni> DuClare: yeah, you would quote \* in a string literal as \\* :-)
07:47:41 <mar77a> what does this mean?
07:47:42 <mar77a> mar77a@scarecrow:~/public_html/hs$ ghc hello.hs -o hello
07:47:42 <mar77a> compilation IS NOT required
07:47:57 <maltem> Leaning toothpick syndrome?
07:48:07 <kpreid> mar77a: it means it's been done already
07:48:09 <EvilTerran> it means the timestamp on ./hello is newer than that on hello.hs, so it thinks it doesn't need to recompile it
07:48:14 <mar77a> .-.
07:48:19 <EvilTerran> maltem, trouble with regular expressions
07:48:26 <maltem> Ah :)
07:48:32 <mar77a> well that's interesting
07:48:45 <EvilTerran> in /-delimited regexes, the classic example is "http\:\/\/"
07:48:58 <kpreid> EvilTerran: who needs to escape : ?
07:49:13 <EvilTerran> well, in PCREs, it's good practice to \ escape all punctuation
07:49:23 <kpreid> ...
07:49:29 <matthew_-> yeah quite
07:49:39 <kpreid> <rant elided>
07:49:40 <matthew_-> it makes it rather less readable if you do that
07:50:12 <EvilTerran> "\ed alphanumerics and un-\ed punctuation are always magic. un-\ed alphanumerics and \ed punctuation are never magic"
07:50:40 <matthew_-> yeah, but that's just not true
07:50:45 <matthew_-> anyway...
07:50:48 <EvilTerran> there's a few special cases in bog-standard PCREs - [&:#!] etc
07:50:54 <EvilTerran> but, for instance, vim gives meaning to &
07:52:07 <EvilTerran> so some would argue it's good style to backslash-escape all punctuation you don't intend to be magical
07:53:11 <EvilTerran> i don't usually bother, mind
07:53:51 <EvilTerran> here's a better example of LTS, then - if you're using strings as regexes, a literal | is "\\\|"
07:54:32 * ddarius likes C#'s @"foo\bar"
07:55:05 <edwardk> ddarius: yeah
07:55:07 <maltem> EvilTerran:  lexical error in string/character literal at end of input
07:55:10 * yitz likes Python's r"foo\bar"
07:55:27 * Deewiant likes D's r"foo\bar" and `foo\bar`
07:55:46 <EvilTerran> maltem, er, yes. see, i can't even keep track of all those \s!
07:56:08 <maltem> ^^
07:56:14 * EvilTerran quite likes perl's m <delimiter> ... <delimiter> notation
07:56:24 * maltem likes Ruby's 'foo\bar'
07:56:32 <EvilTerran> m/.../, m!...!, m#...#, m(...), ...
07:56:38 * edwardk watches the syntax love-in progress. ;)
07:57:21 * yitz likes the fact that the Haskell community is very wary of adding new syntax.
07:57:35 <Twey> Hehe
07:57:51 <EvilTerran> especially as it also works for strings ( qq'this acts like a double-quoted string, so this\nworks as a newline, but you can also have ""s in it') and so on
07:58:22 <wolverian> using ' there is extremely confusing though
07:58:48 <EvilTerran> yes. that was just me being pathological. i usually use () or {}
07:59:31 <wolverian> perl 6 will disallow (), which is reserved for function calls only :)
08:00:01 <EvilTerran> I'm not particularly looking forward to perl6, tbh. it's a bit of a frankenstein's monster.
08:00:58 <ddarius> EvilTerran: Unlike Perl 5?
08:01:08 <qwr> EvilTerran: like http://otierney.net/images/perl6.gif ?
08:02:18 <wolverian> like scala? :)
08:03:14 <Ivatar> ES4 is expanding quite a bit as well...
08:03:23 <qwr> wolverian: perl6 didn't have inbuilt xml literals... when i last looked. ;)
08:03:27 <EvilTerran> perl5 is more like igor than the monster
08:03:44 <wolverian> qwr, that might be a good thing...
08:03:58 <ddarius> Even the original perl was a chimera.
08:04:47 <mauke> http://search.cpan.org/~audreyt/XML-Literal-0.02/lib/XML/Literal.pm
08:04:49 <lambdabot> Title: XML::Literal - Syntax suppor for XML literals - search.cpan.org, http://tinyurl.com/2s4ahj
08:05:14 <qwr> wolverian: having syntactic bloat for a format that is NOT designed for representing data structures?
08:05:18 <wolverian> see, you don't need support for XML in the core.. just use a library :)
08:05:58 <wolverian> qwr, doesn't need to be in the core, in any case.
08:06:02 * qwr is all for libraries ;)
08:19:41 <Saizan> ?seen dcoutts
08:19:41 <lambdabot> dcoutts is in #haskell-blah, #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 2h 54m 17s ago.
08:20:07 <dcoutts_> @yarr!
08:20:07 <lambdabot> Yarrr!
08:20:15 <dcoutts_> hia Saizan
08:22:05 <Saizan> hi
08:23:08 <dcoutts_> Saizan: got some questions?
08:23:13 * dcoutts_ goes to get some coffee
08:23:22 <Saizan> dcoutts_: that vesta paper stresses that it has performance proportional to the work to do rather than the sixe of the project
08:25:02 <dcoutts_> Saizan: that's nice but I don't think we have to aim for that
08:25:15 <dcoutts_> it also seems quite hard judging by the paper
08:25:38 <dcoutts_> Saizan: make has performance proportional to the project, but it's a fairly low constant factor
08:26:03 <dcoutts_> stating every file in the project is usually not that bad even for fairly big projects
08:26:11 <dcoutts_> it's much better than what we have atm
08:26:11 <Saizan> yeah, and it seems you've to not consider some dependencies to have that
08:26:17 <dcoutts_> right
08:26:31 <dcoutts_> or have some way of knowing they're up to date without inspecting them
08:26:49 <dcoutts_> eg gtk2hs has quite a lot of files in a built tree, several thousand
08:27:15 <dcoutts_> but make in a built tree is still less than half a second on an old machine, over NFS
08:28:14 <Saizan> ok
08:28:41 <dcoutts_> Saizan: otoh, if we had to read every file then we might be more concerned as that has a much higher constant factor
08:28:45 <Saizan> but using hashes instead of timestamp would be proibitive i guess?
08:28:55 <dcoutts_> right, because we'd have to read every file
08:30:04 <dcoutts_> Saizan: it's not yet clear to me if we want to compare file timestamps to each other or to a saved file timestamp
08:30:32 <dcoutts_> though I'm beginning to think the latter would be more general
08:30:41 <Saizan> dcoutts_: the latter is more consistent wrt other kinds of deps where you effectively have to check if the cached value corresponds to reality
08:30:47 <dcoutts_> right
08:30:53 <dcoutts_> it's a check for "has this changed"
08:31:03 <dcoutts_> rather than is it up to date wrt some other target
08:31:21 <Saizan> yeah
08:31:24 <dcoutts_> and as you say, it allows us to have different notions of change for different types
08:31:32 <dcoutts_> like config, or non-existant files
08:34:57 <dcoutts_> Saizan: I think it's probably nicer to have out of date testing be a predicate on just the target rather than a relation on two dependent targets
08:35:22 <dcoutts_> Saizan: I take it you were thinking the same?
08:36:14 <Saizan> dcoutts_: i'd say so
08:37:55 <Saizan> i'm not sure how this fits in the algorithm though
08:39:59 <Saizan> it's also interesting that they have the code as a dependency
08:40:28 <dcoutts_> Saizan: what code?
08:41:07 <Saizan> the body of a function is hashed and used as a dependency for its result
08:41:12 <dcoutts_> ah right
08:42:19 <dcoutts_> Saizan: btw, it's possible to optimise the stating of 100's of files so it'll be fairly efficient on seeks by grouping the files to stat by their directory name and their order within the result of the directory listing
08:42:53 <dcoutts_> but don't worry about that for now
08:44:50 <dcoutts_> hia SyntaxNinja
08:46:15 <dcoutts_> Saizan: so I guess then a Target is something with Ord and a up to date function, Target -> m Bool, in the monad we're using
08:47:06 <dcoutts_> Saizan: so eg for a file it'd stat the file and compare the timestamp to the saved one (saved in a state component of the monad)
08:47:31 <Saizan> Ord just for Map or similar?
08:47:34 <dcoutts_> right
08:48:27 <Saizan> it seems that's all we need, yes
08:48:42 <sclv> class declaration scope question: http://hpaste.org/7394
08:49:11 <sclv> I'd really like to be able to bring things into implicit scope in class declarations, to simplify type signatures.
08:49:23 <sclv> Is this remotely feasible?
08:51:06 <sclv> class (StaticRecord a a', StaticRecord b b') => HasTwo a b where... for example, gives me not in scope errors for a', b'
08:51:31 <Saizan> dcoutts_: the haskell98 way is to make Target an union type i guess, but it feels unextensible
08:52:07 <dcoutts_> Saizan: yeah, but I'd go with it for the moment
08:52:25 <dcoutts_> Saizan: if we can parameterise by the target type then it's not so bad
08:52:42 <dcoutts_> since for different uses you can choose different monads and target types
08:53:56 <Saizan> sclv: only if you can move the fundep in StaticRecord
08:54:15 <sclv> I have a fundep in staticrecord already.
08:54:40 <Saizan> dcoutts_: right, class Ord t => Target t m where hasChanged :: t -> m Bool
08:55:16 <dcoutts_> Saizan: a class or just take the hasChanged as a parameter like we do for the JobControl for the original prototype
08:55:32 <Mr_Awesome> whenever i see "fundep" i think "fun dependency."  and then immediately want to say something like, haskell is my fundep. :)
08:55:54 <johnnowak> oi
08:56:03 <Saizan> sclv: then you can remove a' b' from Has, but have foreignKey :: StaticRecord a a' => a -> (b -> a')
08:56:26 <dcoutts_> Saizan: with JobControl we could have done it as an class that extends monad and then asked that the monad we use be in that extension, but it's simpler to just take JobControl as a param I think (and have JobControl be parameterised by the monad)
08:57:57 <sclv> if I do "class (StaticRecord a a', StaticRecord b b') => HasTwo a b where" I get "Not in scope: type variable a'"
08:58:46 <sclv> oh.. I see, move the constraints entirely from the class to the functions. nice!
09:02:37 <jdavis> I'm in the tutorial here: http://www.haskell.org/tutorial/goodies.html, but when inside ghci, if I do "Prelude> type String = [Char]", I get a parse error.
09:02:38 <lambdabot> Title: A Gentle Introduction to Haskell: Values and Types
09:03:12 <mauke> you can't write type definitions in the interpreter
09:03:54 <jdavis> mauke: ok, in general should I write my experiments in a file and compile them?
09:04:16 <mauke> file yes, compiling is optional
09:04:21 <mauke> you can just load it into the interpreter
09:04:42 <jdavis> mauke: ok, so I just can't do the type declaration interactively?
09:05:05 <mauke> right
09:05:21 <mauke> ghci only does expressions (and let bindings)
09:07:23 <jdavis> ok, thanks. It appears to load the file and then put me inside the interactive interpreter again. Is that expected?
09:08:28 <mauke> what did you do?
09:08:52 <jdavis> ghci myfile.hs
09:09:03 <jdavis> where myfile.hs contains "type String = [Char]"
09:09:37 <mauke> yes
09:10:14 <jdavis> ok, thanks.
09:10:30 <mauke> see also :load, :reload
09:11:04 <kpreid> jdavis: once you've loaded the code in ghci, just type :r to reload it
09:12:39 <jdavis> Ok.
09:43:49 <paolino> and use readline facilities ;-)
09:49:51 <mauke> ack, running external programs from haskell is painful
09:50:41 <mrd> @hoogle runShellCommand
09:50:41 <lambdabot> No matches found
09:53:21 <conal> mauke: i think thetallguy has some helpful tools
10:00:31 <mauke> conal: do you have a url?
10:14:30 <ktne> hello
10:14:32 <TomMD> hi
10:14:39 <ktne> i want to enter "let fac n = if n == 0 then 1 else n * fac (n-1)
10:15:00 <ktne> in WinHugs
10:15:00 <ktne> and i get: "ERROR - Syntax error in expression (unexpected end of input)
10:15:00 <ktne> any idea?
10:15:00 <Deewiant> > let fac n = if n == 0 then 1 else n * fac (n-1) in fac 10
10:15:04 <lambdabot>  3628800
10:15:13 <BONUS> usi ghci :)
10:15:21 <byorgey> ktne: the syntax for let-expressions is  let <definitions>  in <expression>
10:15:31 <ktne> ah
10:15:35 <Deewiant> in Hugs you might not use the 'let'
10:15:36 <byorgey> ktne: if you are defining it in a file, just drop the 'let'
10:15:39 <TomMD> ktne: You could just drop the 'let' to declare a top level function
10:15:52 <mauke> ktne: basically, that syntax only works in ghci, not hugs
10:16:09 <ktne> so i should use ghci instead?
10:16:31 <ktne> does ghci have a nice interface like winhugs?
10:16:39 <byorgey> probably, although I hear it is not as nice on windows.
10:16:47 <lilac> ktne: you're missing the 'in' clause
10:17:10 <TomMD> > let fac n = if null n then [] else tail n : fac n in fac "ktne"
10:17:11 <lambdabot>  ["tne","tne","tne","tne","tne","tne","tne","tne","tne","tne","tne","tne","tn...
10:17:13 <byorgey> ktne: yeah, ghci on windows has to run in a terminal which I hear is kind of annoying. =(
10:17:16 <ktne> i'm getting ghc now
10:17:43 <ktne> i'll run it in ntemacs
10:17:50 <mauke> I don't like winhugs' line editor
10:17:50 <ktne> that one has a nice interface AFAIR
10:17:53 <byorgey> ah, yeah, that should work
10:17:54 <BONUS> i don't know, i don't mind running it on a terminal in windows
10:18:18 <BONUS> when messing around i write most of my functions in a file funcs.hs
10:18:23 <BONUS> and then in ghci i just do :l funcs
10:18:27 <BONUS> and i play around with them
10:22:37 * EvilTerran vastly prefers ghci's console interface to hugs' pseudoconsole thing
10:22:56 <SamB> EvilTerran: MY hugs uses a console, mwahahahaha
10:25:20 <EvilTerran> so does my ghci :P
10:26:43 <keir> does anyone here use data parallel haskell?
10:27:27 <SamB> keir: not yet
10:27:44 <SamB> that is, I don't yet
10:28:02 <keir> it looks really neat
10:28:03 <SamB> my understanding is that it only became usable very recently?
10:28:15 <edwardk> @seen dolio
10:28:15 <lambdabot> dolio is in #haskell-blah and #haskell. I don't know when dolio last spoke.
10:28:15 <b_jonas> data parallel? is that different from just parallel as in threading?
10:28:16 <SamB> and still isn't performant
10:28:20 <keir> i'm interested in it not for parallel computation, but simply for efficient serial numeric computation.
10:28:22 <SamB> b_jonas: oh, yes, much!
10:28:33 <SamB> b_jonas: there's lots of papers to read about it in
10:28:41 <keir> it seems like haskell has a bad rap for scienttific stuff.
10:28:42 <b_jonas> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
10:28:46 <SamB> but it is only now actually coming together
10:29:11 <keir> it looks like it has amazing potential
10:29:18 <keir> i am going through the slides / papers now
10:29:49 <ddvlad> if an IO operation modifies the state, is StateT MyType IO a a right approach?
10:32:32 <kpreid> sure
10:33:06 <kpreid> (on the other hand, IORef MyType -> IO a might be more convenient, depending on what exactly you do)
10:34:18 <ddvlad> kpreid: I'll look into IORef, I've never heard of it. Thanks!
10:34:44 <kpreid> StateT is arguably more precise about what you're doing, though
10:35:21 <ddvlad> ok, thanks, i'll experiment more. I'm hoping to do a small POP3 reader
10:35:47 <ddarius> The combinators are efficient and the syntax is added, but the flattening transform that connects them is not implemented in any released GHC currently, but should be in the next stable release.
10:39:59 <keir> is anyone working on a LLVM backend for haskell?
10:40:53 <dcoutts> keir: I think the people who have looked at it have found that it doesn't provide enough for Haskell
10:40:55 <TomMD> I think someone uploaded LLVM libs to hackage once upon a time.
10:41:07 <dcoutts> yes, bos made some LLVM bindings
10:41:11 <edwardk> keir: not that i know of, but there has been some brownian motion in that direction. i think bos and augustsson have a LLVM bytecode generator api that wraps the LLVM.Core
10:41:19 <keir> dcoutts, interesting. i would have thought llvm would be an ideal target (rather than gcc).
10:41:42 <edwardk> the biggest issue is you can't implement a GHC style spineless tagless g-machine in LLVM without adding some primitives and i don't think anyone has been willing to put in the effort
10:41:54 <keir> especially because llvm's whole program optimization is better than gcc's
10:41:57 <dcoutts> keir: it's to do with things like using own stack management, knowing where all heap pointers end up on the stack etc
10:42:19 <TomMD> Where is the discussion re: missing primitives?  Haskell-Cafe?
10:42:25 <keir> interesting
10:42:31 <dcoutts> it's that kind of issue, not optimisation, which may well be better than gcc
10:42:31 <edwardk> keir: ghc does a lot of magic with 'small stacks' and stack walking that doesn't transcribe well into LLVM.
10:43:05 <edwardk> tommd: i googled until i found haskell-cafe, etc posts of people griping about the issues
10:43:10 <keir> i suspect llvm will surpass gcc in a couple years for 'typical compiling' work (gcc has supports an insane amount of stuff)
10:43:29 <keir> yeah, i was looking into stack management into LLVM and it looked like a bit of a pain
10:43:42 <edwardk> keir: heh as in, what stack management? =)
10:43:50 <dcoutts> keir: the obvious target is C-- on top of LLVM
10:44:00 <dcoutts> if that's doable then ghc on LLVM would be too
10:44:18 <keir> c-- on top of llvm? i thought c-- was an llvm competitor
10:44:20 <TomMD> These long compile chains scare me.
10:44:32 <dcoutts> keir: c-- is a language as well as an impl of it
10:45:18 <keir> dcoutts, yes, but why bother with c-- instead of just straight llvm?
10:45:22 <keir> seems like an unnecesssssssary extra step
10:45:35 <keir> (note to self: turn down keyboard repeat rate)
10:45:39 <dcoutts> keir: because it's a useful intermediate abstraction
10:45:50 <dcoutts> ;-)
10:45:57 <b_jonas> meanwhile, if in interests anyone, I've written a simple @unpl operator for J verbs
10:46:12 <b_jonas> it's at http://www.jsoftware.com/jwiki/Scripts/TacitToExplicit
10:46:14 <lambdabot> Title: Scripts/TacitToExplicit - J Wiki
10:46:40 <dcoutts> keir: LLVM does not have a low level native source language afiak, that's what C-- gives you
10:46:48 <keir> dcoutts, that's not true
10:46:57 <keir> dcoutts, llvm has a nice ascii representation
10:47:03 <keir> portable, etc
10:47:07 <dcoutts> oh ok, I didn't know that
10:47:29 <keir> and the API (though in c++) is very clean and nice to use C++. (yes yes C++ sucks, but the llvm api is good).
10:47:38 <dcoutts> I presume it's at a lower level language than C--
10:47:52 <edwardk> dcoutts: though as i recall the maintainer of the cminusminus.org stuff stopped working on it in frustration, over real life issues involving tenure and issues with the fact that it never became as general as intended no?
10:48:13 <dcoutts> edwardk: he's working on C-- inside ghc now as is one of his students
10:48:55 <keir> llvm has many contributors, and several commercial entities with vested interests in seeing llvm go really fast.
10:49:40 <keir> http://osdir.com/ml/lang.c--/2006-12/msg00006.html
10:49:41 <lambdabot> Title: Re: [C--] C-- status report: yes, someone is (bare: msg#00006
10:49:42 <edwardk> dcoutts: its not too much lower to be honest. you have an ssa form assembler. the main issue was giving up a lot of the wins that ghc has grown into in its current environment and the fact that the lava flow of primops has become somewhat insane
10:50:14 <TomMD> edwardk: Who are you referring to? Tolmach?
10:50:53 <keir> (that post is from chris lattner, the original llvm author)
10:51:11 <pavizard> http://hpaste.org/7395
10:51:13 <edwardk> i'm only half remembering from reading the c-- mailing list one evening a few months back, i thought it was norman ramsey but i could be a making a fool out of myself =)
10:51:46 <dcoutts> It'd be very useful to have people hack on LLVM to support the few things that C-- had that LLVM doesn't, that ghc needs
10:51:52 <edwardk> http://osdir.com/ml/lang.c--/2006-12/msg00002.html was the post i was thinking about
10:51:52 <lambdabot> Title: [C--] C-- status report: yes, someone is (barely) : msg#00002
10:53:07 <keir> one of my friends is developing a llvm-backed C++ successor (another one!). he was having problems with LLVM optimizing his benchmarks to int main () {return 0;}
10:53:47 <edwardk> keir: sounds like he needs better benchmarks. ;)
10:53:57 <keir> edwardk, obviously :)
10:55:41 <keir> i want to switch to haskell, but i am afraid i will be very disappointed with the performance. hence looking into this stuff.
10:56:23 <edwardk> keir: its performance isn't bad, it actually can rock pretty hard at some stuff, the rest is about learning when to throw in strictness annotations and unbox stuff to restore performance where needed
10:56:37 <edwardk> 90% of the time you don't need to though
10:56:41 <sieni> keir: compared to what? hand-tuned assembler? c? java? perl?
10:56:45 <keir> C++
10:56:51 <keir> i do vision research
10:56:55 <keir> lots and lots of arrays
10:57:05 <keir> using GB's of memory for arrays
10:57:13 <keir> lots of linear algebra
10:57:24 <dons> you can also combine C and Haskell, using C for some number crunching (or its libraries), and gluing them together with haskell
10:57:28 <keir> but i don't enjoy writing C++
10:57:32 <edwardk> then you'll probably spend a disproportionate amount of time in the IO and ST monad working with IOUArrays and STUArrays.
10:57:56 <mauke> :t foldM
10:57:59 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
10:58:27 <keir> there are two parts to the work i do... big and small arrays. something that can create efficient code for processing small (<20x20) arrays would go a long way
10:58:35 <keir> i really like the pure aspect of haskell
10:59:16 <keir> data parallel haskell looks amazing. hopefully it will continue to be developed
10:59:46 <sieni> keir: in the end it will boil down to profiling your code and hand tuning the time wasters
10:59:48 <TomMD> Purity is great.  One of my programs, several thousand lines, was written for an obscure OS.  One modules / one hundred line patch and I can run the exact same program on Linux :-).
11:00:41 <keir> sieni, indeed! i am a bit afraid of performance because i don't understand the performance implications of various constructions in haskell.
11:00:56 <keir> in C++ I know very precisely where my performance is going.
11:01:28 <keir> but I am hopeful :)
11:02:56 <sieni> keir: yeah, it's not very simple with haskell (mostly because of laziness, I guess)
11:03:03 <Cale> keir: A good approximation is obtained by just understanding lazy evaluation
11:04:02 <Cale> Strict evaluation proceeds by evaluating the innermost (and usually leftmost) subexpression first.
11:04:45 <Cale> Normal order evaluation, by contrast, starts with the outermost reducible subexpression.
11:04:46 <keir> yeah, i was reading some papers about optimizing lazy functional languages
11:05:43 <Cale> Lazy evaluation is an optimisation of normal order evaluation in which the results of evaluating function parameters that occur multiple times in a function's body are shared between the copies.
11:06:30 <b_jonas> (that much is easy but all the consequences like what runs when get all complicated for me)
11:06:49 <TomMD> The best Haskell optimization strategy: Send funds to language researchers whos first or last name starts with an 'S'.
11:07:02 <Cale> Well, it can be complicated, but doing a bunch of evaluation by hand is a good way to start to get a feel for it.
11:07:19 <sieni> not to speak about space leaks and overspanking the lambda and all that
11:07:30 <johnnowak> overspanking the lambda
11:07:40 <b_jonas> TomMD: which ones are you thinking exactly?
11:07:55 <TomMD> Simon *, Don *
11:08:06 <b_jonas> sieni: yeah
11:08:12 <keir> overspanking the lambda?
11:08:17 <b_jonas> avoiding all those
11:08:21 <keir> i am not familiar with the space leaks problem
11:08:35 <b_jonas> making sure to evaluate relevant things strictly in an interactive thingy
11:08:35 <Cale> keir: I think sieni is being silly.
11:08:38 <sieni> johnnowak: that's what results when you spank the lambda too much, i.e. have unnecessarily many unevaluated thunks in your heap
11:09:12 <b_jonas> I imagined what a lazy evaluation problem could cause with a long-running progam like deep thought
11:09:19 <Cale> sieni: uh... that's a very strange name for having unevaluated thunks...
11:09:30 <keir> anyone going to the bay area haskell meetup thursday?
11:09:31 <b_jonas> mice leave the computer alone for trillions of years,
11:09:50 <b_jonas> at the end, they ask the machine "there is an answer? you have it?"
11:09:56 <b_jonas> the computer says "sure,"
11:10:10 <b_jonas> "in fact, I've had it computed in the first year"
11:10:16 <b_jonas> "and been sitting here bored since"
11:10:21 <b_jonas> the mice say "ok, what's it"
11:10:40 <b_jonas> the computer says "um" and starts to evaluate it deeply for trillions of years
11:10:51 <b_jonas> so it can say it
11:11:04 <sieni> Cale: well, actually it's a misnomer, I usually use the term "spanking the lambda" for scheme or lisp code with too many lambda-keywords (and where perhaps lazy evaluation would be better)
11:11:39 <johnnowak> what qualifies as scheme code with too many lambdas?
11:12:29 <sieni> the traditional implementation of the Y-combinator, for example, I'd say
11:13:02 <johnnowak> fair enough
11:13:12 <b_jonas> oh
11:13:52 <sieni> mostly I was thinking code that's idiomatically lazy and then you end up wrapping everything in lambdas manually
11:14:01 <sieni> like infinite lists and such things
11:16:45 <b_jonas> but that's actually the easy thing to do if you need some things to be lazy because they would take much or infinite time otherwise, but you don't understand all-lazy programming languages like haskell
11:16:48 <ddarius> @google EasyVision
11:16:49 <lambdabot> No Result Found.
11:17:26 <ddarius> keir: You may or may no find this interesting: http://alberrto.googlepages.com/easyvision
11:17:26 <lambdabot> Title: Alberrto - easyVision
11:18:09 <keir> ddarius, i already emailed the author about it :) i am thinking of converting my SFM library (http://launchpad.net/libmv) to build on top of easyvision.
11:20:47 <TomMD> Since I'll be getting a new laptop soon, I figured I should get one that can run The Reduceron - anyone know of a laptop with an FPGA? :-)
11:23:17 <dcoutts> TomMD: heh, though perhaps one can get FPGAs as pcimca cards or similar
11:24:33 <dcoutts> TomMD: google has quite a few results for FPGA pcmcia
11:25:05 <TomMD> I'm looking now
11:28:10 <TomMD> Googling for 'pc card fpga' and my first three results are patents... how sad.
11:35:49 <dolio> edwardk: Pong.
11:37:55 <IsoPallo> Aww... The type system hates me. Is there a way to restrict a type to "not too specific"?
11:38:27 <dolio> How specific is too specific?
11:38:37 <keir> i am not sure why this is wrong when I paste it into ghci:
11:38:39 <keir> http://hpaste.org/7396
11:38:55 <dolio> keir: Are you trying to type it on multiple lines?
11:38:59 <keir> yes
11:39:03 <BONUS> yeah ghci doesnt do multiple lines well
11:39:04 <BONUS> try
11:39:07 <keir> oh, ok
11:39:12 <Adamant> dcoutts: picocomputing looks good
11:39:13 <BONUS> let f x | x > 10 = 1 | otherwise = 4
11:39:16 <BONUS> or load it from a file
11:39:17 <keir> is there a way to 'run' a haskell file from within ghci?
11:39:21 <BONUS> yeah
11:39:31 <dcoutts> Adamant: huh?
11:39:32 <BONUS> put that function definition in, say, funcs.hs
11:39:37 <BONUS> then in ghci just do
11:39:37 <keir> i am doing the project euler exercises for fun
11:39:38 <BONUS> :l funcs
11:39:56 <IsoPallo> dolio: Like if I'd like take list scrambling function as a parameter without giving it possibility to mess with the list items contents.
11:40:06 <BONUS> that's how i work when i'm doing euler problems
11:40:12 <Adamant> dcoutts: they make Expresscards and Cardbus with Virtex FPGA's, company name
11:40:31 <ddarius> IsoPallo: Parametricity will do that.
11:40:37 <dolio> ([a] -> [a]) -> ...
11:40:43 <Adamant> if I could afford them I'd buy one
11:40:46 <dcoutts> Adamant: oh right, it was TomMD who was looking for that really
11:41:08 <Adamant> Ping TomMD
11:41:47 <IsoPallo> If I give that, the compiler complains. If I leave the type signature off the type becomes (Forest (a,b) -> Forest (a,b))
11:42:11 <IsoPallo> And then I can use functions like ([a] -> [a])
11:42:24 <dolio> Oh.
11:42:33 <IsoPallo> But then I could mess with the items firectly as well.
11:42:41 <IsoPallo> directly even.
11:42:55 <dolio> Is your type like '(scrambling function) -> Forest (a,b) -> Forest (a,b)' or something?
11:43:07 <IsoPallo> Yes.
11:43:28 <dolio> (forall a. Forest a -> Forest a) -> Forest (a,b) -> Forest (a,b)
11:43:48 <dolio> {-# LANGUAGE Rank2Types #-}
11:44:31 <IsoPallo> Uh. This looks like more learning to do...
11:44:38 <IsoPallo> But thanks!
11:44:44 <IsoPallo> I'll give it a try.
11:46:31 <TomMD> Adamant: Pong
11:46:49 <Adamant> picocomputing for FPGA's
11:46:54 <TomMD> Thanks!
11:47:48 <RayNbow> dons, how do those case expressions work in your blog post? ( http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/04#strict )
11:47:49 <lambdabot> Title: Haskell hacking
11:48:00 <b_jonas> that looks strange really
11:48:14 <edwardk> dolio: ping pong
11:48:44 <ToRA> mmm, anyone know why I can't write "foo :: forall a . a -> Either a _" as a signature?
11:49:04 <edwardk> dolio: gutted Control.Comonad.Cofree and Control.Monad.Free to use a generalized bifunctor of two functors bifunctor: http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Comonad-Cofree.html
11:49:05 <lambdabot> http://tinyurl.com/582nkm
11:49:28 <edwardk> dolio: that let me get rid of a ton of instances throughout
11:49:35 <b_jonas> Co*.Co*.Co* sounds scary
11:49:35 <maltem> ToRA, what's that _ in there?
11:49:44 <IsoPallo> What does the forall stuff do anyway? Or better where I should look to find out?
11:49:52 <ToRA> it would be a forall a b . a -> Either a b
11:49:57 <dolio> edwardk: Ooo. That's kind of nice.
11:49:59 <edwardk> b_jonas: I can't figure out a less scary name =)
11:50:03 <dons> RayNbow: that's core, it flips things around
11:50:22 <b_jonas> edwardk: if the module itself is scary, than it's approperiate that the name is scary to warn people
11:50:34 <ToRA> i have a function which has a load of forall qualified variables that all mean something, and i want to indicate that this variable isn't "important"
11:50:34 <mux> dons: great article btw
11:51:03 <dons> cheers. i might do a few more things about array programming, and low level grokking haskell, over the coming months.
11:51:06 <Deewiant> edwardk: hooray for documentation
11:51:10 <edwardk> dolio: also started doing generic functor zipping: http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Zip.html after someone asked a question on my blog, i think i'll post up about it. note the lack of instance for Zip Either, and hence the lack of one for Free f, which is logical if you think about it
11:51:11 <lambdabot> http://tinyurl.com/6ga4tf
11:51:12 <maltem> ToRA, ah ok, well, there's only the option to give it an unimportant name
11:51:18 <RayNbow> dons: I'm more confused that the first case matches against _... does the other case pattern actually ever succeed?
11:51:20 <Deewiant> but then I guess you shouldn't use that stuff unless you know what it is before hand :-)
11:51:21 <edwardk> Deewiant: i'll add some don't worry =)
11:51:31 <dons> RayNbow: so in core, for some reason, you can put defaults first
11:51:46 <edwardk> deewiant i had a lot, then i gutted the whole module replacing it with like 20 lines ;)
11:51:47 <RayNbow> ah
11:51:57 <mux> types aren't allowed to be uninmportant, only values are :-)
11:51:58 <Deewiant> >_<
11:52:18 <ToRA> mux: i beg to differ
11:52:21 <ToRA> foldCursor :: forall a b witness i_ .  Cursor a i_ -> (forall to . TypeRep to -> witness to) -> (witness a -> a -> b) -> (forall from to . witness to -> b -> from -> Context from to -> b) -> b
11:52:31 <ToRA> that i_ is really very unimportant ;)
11:52:47 <dolio> edwardk: Does this zip like list zipping? Pruning according to shared structure?
11:53:14 <edwardk> dolio: no pruning, only works on functors you can't have to 'prune'
11:53:24 <mux> ToRA: you really need just type synonyms so that this signature is human readable
11:53:43 <ToRA> mux: yeah that would be a good plan
11:53:47 <edwardk> it was a generalization of uustalu and vene's signal and comonads ComonadZip class.
11:53:53 <Corun> ToRA, you use a Mac, right?
11:54:11 <edwardk> its mostly useful for comonads, but there are some monads it can be instantiated for
11:54:29 <edwardk> so you get them for free for Cofree comonads over zippable functors, etc.
11:54:53 <b_jonas> type synonyms for readability are for the weak.  I want void (*signal(int, void (*)(int)))(int).
11:54:54 <edwardk> so i.e. since Identity is zippable so is 'Cofree Identity' which is ~ Stream
11:55:16 <mux> category-extras blows my head off, chops the rest of my body into little pieces, and sets fire to it
11:55:31 <b_jonas> type synonyms for abstracting things away or to be portable, now those make more sense, but in a strictly typed language like haskell newtypes are usually better.
11:56:07 <edwardk> interestingly i can't instantiate BiZip Either, which precludes the zipping of free monads, which makes sense, thats not possible in general.
11:56:23 <mux> is there some paper that can be read prior to the "programming with bananas, lenses, envelopes and barbed wire" for an easier introduction?
11:56:24 <b_jonas> (e.g. if int32_t is the same as int on a computer, the compiler may not detect a type error when you mix them, but which will be a problem when you compile the program on a machine where they aren't the same)
11:56:47 <b_jonas> (in haskell, Int32 can't be the same as Int, it's always at least a newtype away from it.)
11:57:07 <edwardk> mux: heh, fraid there isn't much out there. i figured i'd get this up, post some examples in a cofib suite and go from there
11:57:31 <edwardk> it doesn't help that i'm trying to find more general implementations of a lot of stuff that has gone before with this version
11:59:19 <mux> edwardk: does this module actually allows one to guarantee termination whenever we use those *morphisms functions?
11:59:26 <mux> for recursion
11:59:56 <edwardk> mux: well, no, because you don't get any assurance that you were really GIVEN a Mu f to a catamorphism, you just know that you were given some fixed point
12:00:09 <edwardk> so it could be a 'Nu f' in otherwords it could go on forever, so you might never stop
12:01:09 <sioraiocht> oh god
12:01:11 <sioraiocht> fixpoint theory
12:01:21 * mux shares the pain
12:01:22 <dolio> edwardk: Have you considered adding the Fixpoint class back in (or am I just missing it?). One problem I have with stuff like this is that it restricts you to working with datatypes defined in terms of the stuff in the library.
12:01:23 * sioraiocht curls into foetal position.
12:01:50 <edwardk> i actually kinda prefer not having it because it makes implementing the library harder
12:02:01 <dolio> Ah.
12:02:11 <edwardk> everywhere you use a fixpoint you have to choose one, etc.
12:05:38 <dolio> You need to get some haddock 2.0 in there. :)
12:05:47 <dolio> For less "???"
12:05:52 <edwardk> i didn't even know haddock 2.0 existed ;)
12:06:34 <dolio> Actually, apparently it's on 2.1 now.
12:06:35 <jdavis> In the intro I see code like: [ f x | x <- xs ], in which xs is a list. Is there a way to use similar notation where xs is a real set, and not a list?
12:07:07 <dolio> Nope, unfortunately.
12:07:32 <Botje> jdavis: you could use fromList if it's a Data.Set set
12:07:44 <jdavis> Ok
12:08:10 <keir> is there a way to make haskell dump all the intermediate nodes of a computation? for debugging?
12:08:27 <jdavis> for my program I work mostly with sets, which seem much more natural to me than lists, but most languages prefer to manipulate lists.
12:08:54 <dons> keir: well, you can see the compiled code (-ddump-simpl and -ddump-asm)
12:09:11 <dons> assuming your using ghc, and have optimisations on, that should be interesting
12:09:19 <keir> hmm
12:09:24 <Korollary> then sets are the right thing to manipulate. Forget the syntactic sugar of the comprehension syntax and use Data.Set.filter
12:09:27 <keir> more, as in, i have a recursive expression which is wrong
12:09:33 <keir> to debug i'd like to visualize the tree
12:09:37 <keir> poke around with the mouse type thing
12:09:49 <keir> and see what the evaluated tree looks like (i.e. seeing intermediate computed values)
12:10:02 <jdavis> Korollary: ok, good to hear.
12:10:42 <ddarius> jdavis: Lists are free data types and so are much simpler to deal with.
12:11:28 <edwardk> dolio: added http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Monad-Indexed.html in light of our earlier discussion
12:11:29 <lambdabot> http://tinyurl.com/6pnkhl
12:11:42 <edwardk> and control.comonad.indexed and control.functor.indexed to give them a common ancestor
12:11:43 <jdavis> ddarius: what do you mean "free data type"? I'm fairly new to FP.
12:12:29 <dolio> edwardk: Ah, nice.
12:12:35 <edwardk> jdavis: http://comonad.com/reader/2008/monads-for-free/
12:12:37 <lambdabot> Title: The Comonad.Reader  Monads for Free
12:13:23 <edwardk> dolio: wrote an indexed state monad, and a 'LowerIx' and 'LiftIx' to embed/project to normal (co)monads
12:14:23 <edwardk> i think an indexed comonad is an interesting way to handle 'encapsulable effects' because iextract only extracts from m i i a -> a so if you say indexed something with a list of 'stuff you must take care of' then m () effects a can only be extracted from once effects = ()
12:14:51 <jdavis> lambdabot, edwardk: I'll have to learn more about functors and monads first, I think. I've done some OCaml, but this is all fairly new to me.
12:15:30 <edwardk> dolio: that should give you something ala nanevski's modal possibility for handling local effects in haskell 98
12:15:48 <dolio> Huh. Interesting.
12:16:46 <dolio> jdavis: The clearest explanation I've heard of a 'free object' is that it satisfies only the laws it's required to satisfy to be such an object.
12:17:50 <dolio> So, lists are free monoids. So it has empty and (++) satisfying l ++ empty = l = empty ++ l, and l ++ (m ++ n) = (l ++ m) ++ n.
12:18:02 <BONUS> where can i find a function that searches for a sublist in a list
12:18:06 <BONUS> and returns a Bool
12:18:10 <dolio> @type isInfixOf
12:18:12 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
12:18:56 <mux> @src isInfixOf
12:18:57 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
12:19:06 <BONUS> ah
12:19:26 <jdavis> dolio: so a set fails because it requires an ordered type?
12:19:27 <awesame> @src any
12:19:27 <lambdabot> any p =  or . map p
12:19:28 <olsner> @ty findSubstring
12:19:29 <lambdabot> Not in scope: `findSubstring'
12:20:04 <Saizan_> is there an explicit relation between "free" and "initial"?
12:20:17 <awesame> @src or
12:20:18 <lambdabot> or    =  foldr (||) False
12:20:30 <ddarius> Saizan: There are definitely relations.
12:21:19 <awesame> wow, I would have called "or" "any"
12:21:28 <ddarius> @src any
12:21:28 <lambdabot> any p =  or . map p
12:21:33 <BONUS> nah
12:21:39 <BONUS> > any (==5) [1,2,3,4,5,6]
12:21:40 <lambdabot>  True
12:21:46 <BONUS> readable and obvious
12:22:01 <awesame> sure, but this isn't
12:22:02 <Deewiant> or [True, False] however isn't. :-P
12:22:11 <awesame> > or [True, False, False]
12:22:12 <lambdabot>  True
12:22:15 <dolio> jdavis: Sets satisfy additional laws. For instance: 'l ++ l = l'.
12:22:22 <ddarius> or = any id
12:22:23 <b_jonas> dolio: exactly, and that's why mathematicians usually use multiplicative notation for "words" in language theory
12:22:34 <BONUS> > any (==True) [True, False, False]
12:22:35 <lambdabot>  True
12:22:36 <BONUS> hehe
12:23:03 <Saul_> > any id [True, False, False]
12:23:04 <lambdabot>  True
12:23:08 <awesame> "any" seems like a reasonable name for that function, but "or" seems unreasonable to me
12:23:34 <ddarius> or [a,b,c] == a || b || c
12:23:52 <awesame> I'd either not define "or", or call it "any" and rename "any" to "anyMatch" or something
12:23:59 <Saul_> awesame: I don't think it is that unreasonable
12:24:08 <Deewiant> I'd probably define or = (||)
12:24:11 <opqdonut> or and any are good succint names
12:24:12 <awesame> "or" sounds like a synonym for "||"
12:24:21 <opqdonut> as opposed to anyMatch
12:24:21 <awesame> there's no clue in its name that it means anything different
12:24:24 <Deewiant> similarly for 'and'
12:24:36 <awesame> Deewiant: exactly
12:24:39 <ddarius> awesame: or is the obvious generalization of (||) to an n-ary function
12:24:56 <awesame> ddarius: but it's not the obvious name for that!
12:25:10 <ddarius> You have no problem with "or a b", but not with "or [a,b]" ?
12:25:20 <awesame> exactly
12:25:21 <Deewiant> the problem is rather "or xs".
12:25:40 <BONUS> some people would prefer it to be named anyTrue then?
12:25:55 <maltem> "or" doesn't convey it's a fold. "foldOr" would, but that's too similar to its implementation to be useful
12:26:01 <BONUS> i think that's pretty much bikeshedding
12:26:02 <nominolo> @seen dons
12:26:02 <lambdabot> dons is in #haskell-hac4, #haskell-soc, #xmonad and #haskell. I last heard dons speak 16m 50s ago.
12:26:05 <Deewiant> BONUS: that would certainly be better, but then there's no point, might as well use "any id".
12:26:26 <ddarius> Indeed.  any id is likely to be exactly as efficient as or in GHC
12:26:28 <BONUS> yeah then you could just use any (==True)
12:26:47 <maltem> a good name would be disjunction, I think
12:26:53 <maltem> just as we have sum vs. (+)
12:26:54 <ddarius> isTrue = id; isFalse = not
12:27:48 * mux is quite happy with and/or/any
12:27:54 <mux> and all
12:27:55 <ddarius> and all
12:27:59 <mux> heh
12:28:25 <Deewiant> :t and all
12:28:27 <lambdabot>     Couldn't match expected type `[Bool]'
12:28:27 <lambdabot>            against inferred type `(a -> Bool) -> [a] -> Bool'
12:28:27 <lambdabot>     In the first argument of `and', namely `all'
12:28:33 <Deewiant> d'oh
12:28:39 <awesame> well, having never seen "or" before, "or . map p" was confusing to read
12:28:42 <ddarius> :t all and
12:28:44 <lambdabot> [[Bool]] -> Bool
12:28:49 <mux> :t any all
12:28:51 <lambdabot>     Couldn't match expected type `Bool'
12:28:51 <lambdabot>            against inferred type `[a] -> Bool'
12:28:51 <lambdabot>     Probable cause: `all' is applied to too few arguments
12:28:52 <Deewiant> :t all and all
12:28:52 <awesame> I read "(||) . map p" and was confused
12:28:54 <lambdabot>     Couldn't match expected type `[[Bool]]'
12:28:54 <lambdabot>            against inferred type `(a -> Bool) -> [a] -> Bool'
12:28:54 <lambdabot>     In the second argument of `all', namely `all'
12:29:03 <dmwit> awesame: Live and learn.
12:29:17 <dolio> Clearly we should have a Lattice class. Then we can use meets and joins, and everyone will be happy.
12:29:25 <awesame> dmwit: okay, I'll just head over to #intercal
12:29:25 <dmwit> awesame: Sometimes, the tradeoff for concision is a large vocabulary.
12:29:43 <dmwit> awesame: It's not obfuscated; it's just that you didn't know it yet.
12:29:55 <awesame> I think it is obtuse
12:30:14 <dmwit> I think it is convenient.
12:30:16 <Cale> awesame: how so?
12:30:23 <Cale> awesame: or, what is obtuse?
12:30:49 <awesame> Cale: not a big deal, but I was surprised at the definitions of "or" and "any"
12:30:53 <Cale> The implementation of any p as or . map p ?
12:31:09 <Deewiant> The definition of 'or' as something other than '(||)'.
12:31:20 <Cale> @src or
12:31:21 <lambdabot> or    =  foldr (||) False
12:31:28 <awesame> I saw "or" for the first time and thought "(||)"
12:31:58 <awesame> turns out "or" means what I assumed "any" meant, which is why I was looking at the definition of "any" in the first place
12:32:01 <mux> but that was the first time; if you trip on it a second time I'll acknowledge a problem :-P
12:32:20 <Cale> It's just a matter of looking at the types and/or definitions once :)
12:32:28 <mux> since I read about those folds, I never ever wondered if they were folds or not ;-)
12:32:28 <Cale> :t or
12:32:30 <lambdabot> [Bool] -> Bool
12:32:33 <awesame> sure, but I find myself doing that a lot in Haskell
12:32:46 <awesame> seems like some of the Prelude functions have unfortunate names
12:32:57 <Cale> Once you look at the type of 'or' together with its name, what it does can hardly be surprising.
12:33:07 <Cale> What should it be called?
12:33:11 <awesame> "any"
12:33:15 <Cale> any?
12:33:17 <twanvl> perhaps 'ors' and 'ands'?
12:33:20 <dmwit> =/
12:33:29 <dmwit> This is so pointless.
12:33:29 <Cale> Then what should any be called?
12:33:35 <dons> nominolo: ?
12:33:35 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
12:33:43 <awesame> I'm not sure what "any" should be called
12:33:49 <nominolo> dons: see message
12:33:53 <Cale> any is what you usually want anyway
12:33:59 <dons> nominolo: it took about 4 weeks, and it failed at the System Fc merge in 2006
12:34:11 <awesame> I'd also be fine with "or" being spelled "any id"
12:34:12 <Cale> :t any
12:34:14 <nominolo> 4 weeks!?
12:34:14 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:34:27 <awesame> anyway, I didn't mean for this to turn into a big discussion
12:34:29 <glguy> dons: Did Simon have any luck with it?
12:34:30 <dons> yep
12:34:34 <nominolo> did you use that darcs-to-git script?
12:34:34 <dons> glguy: not sure
12:34:44 <dons> nominolo: i used all 3 darcs-git scripts :)
12:34:45 <Cale> awesame: I'm not sure what you see as unnatural about it...
12:34:46 <mux> I agree any is more problematic than or
12:34:51 <nominolo> omg
12:34:55 <nominolo> that's sad
12:35:05 <Cale> or is the usual multiparameter or function :)
12:35:06 <glguy> vendor lock-in
12:35:07 <mux> but once you've seen it, it's okay
12:35:16 <dons> glguy: heh
12:35:17 <awesame> Cale: "or" sounds like a synonym for "(||)" -- there's nothing in its name that gives any clue that it operates on a list
12:35:21 <maltem> What, are they migrating ghc to git now, officially?
12:35:29 <b_jonas> I'd prefer or included, even if in another name
12:35:32 <Cale> awesame: There is something in its type which indicates that though :)
12:35:32 <dons> maltem: nope.
12:35:35 <nominolo> maltem: not anytime soon
12:35:48 <b_jonas> just like zip in addition to zipWith
12:35:53 <glguy> how about: at_least_one_element_is_true
12:36:00 <nominolo> maltem: dons converted it so that ohloh could gather statistics
12:36:05 <awesame> Cale: yes, but that wasn't good enough to keep me from being confused when I saw it, and it still doesn't make me like it
12:36:07 <b_jonas> even though I usually use zipWith or any instead of zip or or, that's only a habit from strict languages
12:36:09 <nominolo> which are way wrong, too
12:36:13 <Dafra> hi, i am looking to a good way to debug code
12:36:14 <ddarius> awesame: There is nothing in the name of most functions that operate that gives any clue that they operate on a list.
12:36:14 <glguy> GHC might be stuck on darcs for some time
12:36:15 <Cale> disjunction
12:36:17 <Dafra> what do you use ?
12:36:19 <dmwit> glguy: Underscores?
12:36:27 <Cale> Dafra: I use ghci, mostly
12:36:28 <glguy> dmwit: extra emphasis
12:36:31 <dmwit> Dafra: Well, ghci has a debugger, now.
12:36:31 <dons> glguy: oh, i doubt it. it was a small issue of tag patches the script couldn't handle
12:36:32 <awesame> I also wouldn't define something like equalsFive = any (==5)
12:36:35 <b_jonas> how abour orReduce?
12:36:36 <maltem> nominolo, ah, the oloh thing where dons gives people git mirrors for free
12:36:41 <dons> glguy: if it came to it, you'd just start 6.10 in a new repo
12:36:42 <b_jonas> @type reduce
12:36:44 <lambdabot> Expr -> Expr
12:36:46 <Cale> Dafra: and separating code into smaller bits until each part is comprehensible on its own
12:36:49 <b_jonas> meh
12:36:51 <Dafra> i've just tried ghci
12:36:52 <b_jonas> @type fold
12:36:53 <lambdabot> Not in scope: `fold'
12:37:03 <awesame> ddarius: yes, but "or" already is the pronounced name of a familiar binary function
12:37:03 <dmwit> > reduce (x / x)
12:37:04 <Dafra> stepping output is rather strange
12:37:05 <lambdabot>  x / x
12:37:07 <dons> glguy: or we'd write our own conversion script that worked
12:37:18 <Dafra> any frontend ?
12:37:25 <ddarius> a || b = or [a,b]
12:37:26 <Dafra> emacs mode doesn't seem to have it yet
12:37:27 <Cale> awesame: It would make little sense to have or be a synonym for (||)
12:37:28 <awesame> ddarius: see also my "equalsFive" example, that's how weird it seems to me
12:37:43 <b_jonas> ah, it's called foldr1
12:37:49 <dmwit> Dafra: Actually, I've never used ghci's debugging facilities.  Usually I try to build very small functions, testing each of the small ones in ghci before moving on.
12:37:50 <dons> ?users
12:37:50 <lambdabot> Maximum users seen in #haskell: 459, currently: 458 (99.8%), active: 27 (5.9%)
12:37:50 <Cale> :t foldr
12:37:52 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
12:37:59 <b_jonas> then orFold
12:38:02 <Dafra> Cale, the problem is with inner functions (let, where)
12:38:04 <BONUS> hehe
12:38:06 <dmwit> Dafra: That catches almost all of my bugs.
12:38:07 <BONUS> just a few more
12:38:13 <b_jonas> or what about just minimum
12:38:17 <glguy> dmwit: but I do prefer this-style (which doesn't work in Haskell, so I often use this_style)
12:38:24 <dmwit> Dafra: For the last 3-5% of bugs, there's Debug.Trace. =)
12:38:24 <nominolo> dons: well you could start at an earlier point
12:38:25 <b_jonas> is minimum lazy enough for bools?
12:38:26 <Cale> Dafra: you might lift some definitions up out of the let/where temporarily to make them easier to test
12:38:39 <dmwit> glguy: Ah, so no camel case for you?
12:38:41 <glguy> minimum doesn't understand minBounds
12:38:41 <nominolo> dons: like end of 2006 for example
12:38:49 <dons> nominolo: sure. say the 6.8 branch
12:38:49 <b_jonas> > minimum (True : replicate False)
12:38:50 <dmwit> glguy: Do other Haskeller's have to read your code? =P
12:38:50 <lambdabot>  Couldn't match expected type `Int' against inferred type `Bool'
12:38:51 <Cale> Dafra: Or even permanently, if there's any chance of them being more generally useful.
12:39:00 <glguy> dmwit: I try to avoid camelcase unless the rest of the module uses it
12:39:02 <b_jonas> > minimum (True : repeat False)
12:39:02 <glguy> dmwit: they do!
12:39:07 <dons> sadly
12:39:10 <lambdabot> Terminated
12:39:12 <dmwit> haha
12:39:16 <b_jonas> > or (True : repeat False)
12:39:17 <lambdabot>  True
12:39:19 <Cale> glguy: ugh :)
12:39:20 <b_jonas> that's wierd
12:39:32 <b_jonas> why's it not lazy enough for this?
12:39:34 <Dafra> I'll have a look at the Debug.Trace thing
12:39:35 <Cale> CamelCase is the one true Haskell naming convention :)
12:39:38 <b_jonas> @src minimum
12:39:39 <lambdabot> minimum [] = undefined
12:39:39 <lambdabot> minimum xs = foldl1 min xs
12:39:46 <dons> glguy is a renegade
12:39:48 <b_jonas> @src Bool min
12:39:48 <lambdabot> Source not found. Where did you learn to type?
12:39:50 <Dafra> ghci's :trace is useful for what i have seen
12:39:55 <Cale> Dafra: What sort of problem are you trying to debug?
12:39:56 <b_jonas> @src Bool Ord
12:39:56 <lambdabot> Source not found. Just try something else.
12:40:04 <glguy> dons: I'm a *trailblazer* ;)
12:40:15 <dmwit> b_jonas: It has to do every comparison.
12:40:15 <dolio> you'should'use'oleg'case
12:40:15 <dons> heh
12:40:19 <b_jonas> oh, it's inferred for it's an enumerated type
12:40:25 <ddarius> b_jonas: As glguy said, minimum doesn't know that there is nothing less than False.
12:40:39 <Dafra> i run a unit_test, the result is wrong, and the cause must be that a list contend si wrong
12:40:47 <b_jonas> > min True undefined
12:40:48 <lambdabot>  Exception: Prelude.undefined
12:40:56 <Dafra> i want to how i came at that result
12:41:06 <edwardk> dolio: looks like a 'correct' version of nanevski's modal possibility using an indexed comonad needs an initial object. haskell fails =/
12:41:13 <glguy> > min False undefined
12:41:15 <lambdabot>  Exception: Prelude.undefined
12:41:16 <dolio> Heh.
12:41:17 <ddarius> > False < True
12:41:18 <Dafra> tracing can be OK
12:41:18 <lambdabot>  True
12:41:48 <b_jonas> ddarius, dmwit: I guess it depends on how min is derived
12:41:49 <Cale> Dafra: I often just check things on paper, if it's not too complicated to do so.
12:42:00 <dmwit> b_jonas: Not really.
12:42:02 <Cale> (but perhaps I'm strange :)
12:42:06 <b_jonas> or its default definition
12:42:09 <b_jonas> @src Ord
12:42:09 <lambdabot> class  (Eq a) => Ord a  where
12:42:09 <lambdabot>     compare      :: a -> a -> Ordering
12:42:09 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
12:42:09 <lambdabot>     max, min         :: a -> a -> a
12:42:14 <Deewiant> > let False < _ = True; _ < _ = False in False < undefined
12:42:15 <lambdabot>  True
12:42:17 <dmwit> b_jonas: The problem is in the definition of minimum, not in the definition of min.
12:42:17 <edwardk> dolio: coz you need an object Initial such that you can always go from Either Initial a -> a  in haskell Initial is not possible because every type is inhabited by bottom.
12:42:23 <b_jonas> dmwit: is it?
12:42:30 <Deewiant> @src Bool Ord
12:42:31 <lambdabot> Source not found. Wrong!  You cheating scum!
12:42:39 <dmwit> b_jonas: Yes.  Think about it. ;-)
12:42:45 <b_jonas> ahh, it uses foldl1, not foldr1
12:43:01 <Dafra> Cale, that's the Don Knuth method :)
12:43:29 <b_jonas> foldl1 means (...(((x1 || x2) || x3 ) || x4)...) so it's strict
12:43:31 <ddarius> Dafra: Isn't the Don Knuth method simply to write correct code the first time?
12:43:44 <ddarius> > foldr1 min (True:repeat False)
12:43:46 <lambdabot>  Exception: stack overflow
12:43:48 <b_jonas> it does that so it doesn't need much stack, right?
12:44:03 <ddarius> > foldr1 min (False:repeat True)
12:44:04 <lambdabot>  Exception: stack overflow
12:44:14 <b_jonas> so both?
12:44:17 <Dafra> the problem is I dont have Don's brain
12:44:20 <Dafra> or brains ?
12:44:29 <b_jonas> you see how min is strict
12:44:36 <b_jonas> from the min False undefined
12:45:01 <Deewiant> > let min True True = True; min _ _ = False in foldr1 min (True:repeat False)
12:45:03 <lambdabot>  False
12:45:15 <b_jonas> yep, but how is it derived or defaulted?
12:45:25 <ddarius> let min = (&&)
12:46:06 <maltem> > and (True : repeat False)
12:46:06 <lambdabot>  False
12:46:28 <dmwit> > foldl1 (&&) min (True : repeat False) -- whee!!
12:46:30 <lambdabot>  Couldn't match expected type `[Bool]'
12:46:34 <dmwit> bleh
12:46:36 <Deewiant> (&&) min? :-P
12:46:38 <dmwit> > foldl1 (&&) (True : repeat False) -- whee!!
12:46:44 <b_jonas> though as even Apl has different verbs for and/or from min/max, maybe it's not a Good Thing to use min instead of and
12:46:51 <lambdabot> Terminated
12:47:02 <Deewiant> > foldr1 (&&) (True : repeat False)
12:47:04 <lambdabot>  False
12:47:06 <b_jonas> classic apl at least
12:48:06 <b_jonas> ah, in fact
12:48:06 <Cale> > foldr (&&) True (True : repeat False)
12:48:07 <lambdabot>  False
12:48:22 <b_jonas> http://www.haskell.org/onlinereport/derived.html#sect10.1 specifically claims that Ord functions are strict this way
12:48:22 <lambdabot> Title: The Haskell 98 Report: Derived Instances
12:48:25 <Cale> > and (True : repeat False)
12:48:27 <lambdabot>  False
12:48:36 <Deewiant> @src and
12:48:37 <lambdabot> and   =  foldr (&&) True
12:48:51 <b_jonas> though not completely deeply strict on constructors with arguments
12:49:16 <b_jonas> it says "For example, False <= _|_ is _|_, even though False is the first constructor of the Bool type.
12:49:17 <b_jonas> "
12:49:33 <b_jonas> good
12:49:55 <b_jonas> so it's both min and minimum that are strict
13:00:02 <dansa> i downloaded lambdabot and line 70 of the makefile says include depend, but i get Makefile:70: depend: No such file or directory because i don't have any file called depend in the distribution; am i missing something?
13:03:10 <Saizan_> dansa: did you use the build.sh script?
13:03:40 <dansa> i don't have it; README says to edit BotConfig.hs and run make
13:04:05 <dansa> this is lambdabot2.tar.gz
13:04:25 <Japsu> No, this is Sparta.
13:04:54 <edwardk> @pl \a -> runHyperB (k (h a)) a
13:04:54 <lambdabot> runHyperB =<< k . h
13:06:31 <dons> dansa: i think you're using some old lambdabot
13:06:35 <dons> ?version lambdabot
13:06:35 <lambdabot> lambdabot 4p629, GHC 6.8.2 (Linux i686 2.40GHz)
13:06:35 <lambdabot> darcs get http://code.haskell.org/lambdabot
13:07:24 <dansa> that's possible
13:09:02 <dansa> thanks; gotta wait for darcs to do its thing now
13:10:29 <edwardk> @pl \f g h -> HyperB (f . runHyperB h . contramap g)
13:10:29 <lambdabot> ((HyperB .) .) . (. (flip ((.) . runHyperB) . contramap)) . (.) . (.)
13:10:32 <edwardk> ugh
13:11:02 <dolio> edwardk: http://hpaste.org/7399
13:11:22 <edwardk> dolio: nice that was my next project to tackle =)
13:11:49 <edwardk> (4:10:56 PM) Edward Allan Kmett: dolio: nice that was my next project to tackle =)
13:12:16 <edwardk> dolio: did you notice that indexed monads make crappy monad transformers?
13:12:31 <edwardk> coz you have only one set of 'indexes'
13:12:46 <jatqceer> darcs.net down?
13:12:47 <dolio> Yeah. They only transform non-indexed monads.
13:12:51 <b_jonas> I didn't like the idea of indexed monads
13:13:03 <b_jonas> even thoguh I could't really understand all of it
13:13:06 <b_jonas> I mean,
13:13:11 <edwardk> b_jonas: i'm mostly including them for sake of completeness
13:13:17 <b_jonas> I like the idea of the problem, but not the solution
13:13:35 <b_jonas> it needs to be solved somewhat differenlty
13:14:36 <b_jonas> I think if I ever do serious haskell programming, I'll probably learn the c api too
13:14:42 <b_jonas> luckily it doesn't seem to be too complicated
13:15:18 <dolio> edwardk: Those 'run' functions could be tightened up to 'Cont(T m) a a a -> (m) a', I guess. That's how they do it in the type-safe printf stuff.
13:15:45 <edwardk> dolio: going through and bikeshedding the names and stuf now =)
13:16:07 <dolio> :)
13:16:43 <edwardk> not sure i like the super tight runCont it breaks symmetry with normal runCont, no?
13:17:46 <dolio> Yeah. It's up to whether or not you want to supply an initial continuation besides return/id.
13:18:09 <SyntaxNinja> y0
13:18:09 <lambdabot> SyntaxNinja: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:24:24 <kadir> hello everyone
13:24:32 <Corun> Hello.
13:24:35 <kadir> i have one question
13:24:35 <TomMD> Hello
13:24:41 <Corun> People always do :-)
13:24:42 <kadir> about haskell
13:24:45 <kadir> :)
13:24:54 <kadir> about operator overloading
13:25:02 <kadir> is it possible in haskell
13:25:08 <Botje> no such thing
13:25:10 <TomMD> Use type classes
13:25:15 <kadir> i have a code snippet, i could share with you
13:25:18 <kadir> but it fails
13:25:21 <Botje> operators like + and - are governed by typeclasses
13:25:22 <TomMD> @where hpaste
13:25:22 <lambdabot> http://hpaste.org/
13:25:32 <TomMD> kadir: use hpaste if you want to share the code.
13:25:33 <dolio> > (2 + 3, 2.1 + 3.2)
13:25:34 <lambdabot>  (5,5.300000000000001)
13:25:40 <dolio> Nice.
13:25:47 <Corun> Heh
13:26:17 <kadir> oh, hpaste
13:26:24 <kadir> i'm too new for irc
13:26:32 <kadir> years years later
13:27:23 <kadir> that' fine
13:27:28 <kadir> i'll paste there :)
13:28:05 <b_jonas> of course, you can lexically override an infix operator symbol
13:28:48 <kadir> i did http://hpaste.org/7400
13:29:30 <jamii> kadir: Function overloading in haskell is governed by typeclasses. Have a look at http://www.haskell.org/tutorial/classes.html
13:29:30 <lambdabot> Title: A Gentle Introduction to Haskell: Classes
13:30:05 <kadir> oh thanks, i thought that i had gave it a nice try :)
13:30:16 <kadir> but failed...
13:30:36 <paolino> :t (*)
13:30:38 <lambdabot> forall a. (Num a) => a -> a -> a
13:31:00 <kadir> i'll continue to dig more, thanks
13:31:20 <jamii> Operator overloading in haskell is a bit more constrained than most languages. If you want to overload multiplication on strings you need to declare strings as an instance of Num.
13:31:35 <jamii> The link I posted shows you how to overload (==)
13:31:46 <dons> jamii: right, its disciplined ad-hoc polymorphism
13:31:55 <Corun> Bless you ;-)
13:32:05 <dons> i'd not say its more constrained -- its more thoughtout.
13:32:16 <Corun> I'd not say that
13:32:21 <Corun> I'd just say that it didn't suck :-)
13:32:32 <Corun> *doesn't
13:32:41 <edwardk> @pl \k -> k a
13:32:41 <lambdabot> ($ a)
13:32:43 <paolino> can't multiply with (*) different types anyway
13:36:48 <dolio> With multi-parameter type classes (and functional dependencies, I suppose) you can recover C++-like ad-hoc overloading.
13:37:08 <dolio> Although, it's messy.
13:39:13 <shapr> yarr!
13:39:13 <lambdabot> shapr: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:39:16 <shapr> Whoa
13:39:21 <opqdonut> :D
13:39:23 <edwardk> heya shapr
13:39:25 <dolio> You're blowing up.
13:39:26 <shapr> hiya edwardk
13:39:37 <shapr> edwardk: I got Mike's flu. ugh.
13:39:45 <edwardk> i have some sniffles from it myself =/
13:40:01 <dons> ?yarr shapr !
13:40:01 <lambdabot> What be a priate's favourite cheese?
13:40:01 <lambdabot> Yarrlsburg!
13:40:11 <edwardk> @where haddock 2.0
13:40:11 <lambdabot> http://www.haskell.org/haddock/
13:40:15 <shapr> I got fever, swollen throat, cough, etc. Sucks.
13:40:25 <shapr> hiya dons
13:40:38 <dolio> edwardk: Just cabal-install it. :)
13:40:56 <edwardk> heh, i should probably get around to installing cabal-install then ;)
13:41:04 <dcoutts> @yarr!
13:41:04 <lambdabot> Splice the Mainbrace!
13:41:10 <dcoutts> edwardk: indeed you should :-)
13:41:10 <opqdonut> @. elite yarr
13:41:11 <lambdabot> |-|4r D3 |-|aR HaR!
13:41:22 <shapr> @yarr
13:41:22 <lambdabot> Smartly me lass
13:41:39 * dcoutts goes back to hacking on cabal-install
13:41:45 * shapr wanders off to find food
13:43:27 <jamii> dons: I didnt say constrained was a bad thing....
13:43:49 <edwardk> is it ironic that i have to install a bunch of packages to install cabal-install? =)
13:43:58 <dcoutts> edwardk: sigh, yes.
13:44:08 <paolino> it's convincing
13:44:09 <dcoutts> edwardk: but only two, zlib and http
13:44:34 <dons> dcoutts: do you want to put a mini-http in cabal-install?
13:44:37 <edwardk> yeah. its just enough inertia that its not a oh -btw- i needed cabal-install, poof.
13:44:39 <dons> and a zlib for that matter.
13:44:45 <dons>  we could get rid of both of those
13:44:46 <dcoutts> dons: we might make a package that bundles them up
13:44:57 <dcoutts> but I don't think we could get away with a smaller http lib
13:45:05 <dcoutts> we're starting to use quite a few of the http features
13:45:08 <dons> ah ok
13:45:12 <dcoutts> like proxies
13:45:16 <edwardk> is cabal-install going to be bundled with ghc?
13:45:18 <dons> doing pipeline downloading yet of all packages ?
13:45:26 <dcoutts> dons: not yet
13:45:26 <dons> when i do: cabal install haskell
13:45:32 <dons> i might want that in a couple of years :)
13:45:55 <dcoutts> dons: I had it downloading and installing half of hackage the other day, I wanted pipelining then
13:46:04 <dcoutts> and downloading concurrently with building
13:46:49 <zeno__> does length [1..10] run at the same speed as length <list of 10 really large text blocks>
13:47:04 <dcoutts> edwardk: not sure about that, but certainly as part of the platform
13:47:23 <dcoutts> edwardk: the trend is for a smaller ghc but then a bigger platform
13:47:24 <dons> zeno__: yeah
13:47:38 <edwardk> dcoutts: even if it was buried in the extra-libraries thing
13:48:21 <dons> ?src length
13:48:21 <lambdabot> Source not found. There are some things that I just don't know.
13:48:25 <dons> oh right.
13:48:41 <dcoutts> edwardk: right, what we have now is platform == ghc + extra-libs, in future the platform releases need not be synchronised with ghc releases and they may contain more stuff
13:49:10 <edwardk> dcoutts: fair nuff
13:49:16 <zeno__> dons: oh cause of laziness right? (man that seems to save lots of cpu cycles :)
13:49:36 <dons> zeno__: well, polymorphism. it isn't allowed to look at the elements of the list
13:49:39 <dcoutts> edwardk: big synchronised releases are too much work for the ghc folk, the platform releases need to be separated
13:49:53 <dons> i guess that's to do with laziness as well -- walking along the spine of the list doesn't force the elements
13:50:25 <edwardk> dcoutts: is there a better way to check for things like Control.Category than checking if __GLASGOW_HASKELL__ < 609 in an ifdef?
13:50:47 <dons> do a ifdef in the .cabal file?
13:50:57 <SamB> edwardk: I should hope they've changed the base version number?
13:50:59 <dons>     if impl(ghc > 6.8.2)
13:50:59 <dons>         build-depends: ghc-prim
13:51:13 <dons> for modules *inside* base, you've got to use cpp sadly
13:51:16 <dcoutts> or preferably based on the version number of base, not of ghc
13:51:20 <edwardk> i.e. in my extended category-extras i wrote stuff for BiKleisli and CoKleisli arrows, but they need to implement different methods depending
13:51:24 <dcoutts> since it's not ghc specific
13:51:27 <SamB> dons: they are SUPPOSED to change the version number on the base package
13:51:34 <SamB> are they not doing this?
13:51:38 <edwardk> dcoutts: unfortunately i have no idea when the version numbers change on base =/
13:51:38 <dcoutts> SamB: yes it's certainly changed
13:51:48 <dcoutts> every release :-)
13:51:52 <dons> right.
13:52:01 <dons> depending on darcs revisions doesn't fly
13:52:11 <SamB> dcoutts: is there a changelog for it?
13:52:15 <edwardk> heh, what i mean is i don't have a good process for binary searching for the release when it changed
13:52:22 <dons> 'darcs changes' SamB
13:52:41 <edwardk> maybe i'm just slow, but its mostly because i haven't done a lot in that arena
13:53:06 <dcoutts> edwardk: the simplest way is just to look at the older docs
13:53:14 <SamB> dons: I meant a summary of changes, not the whole dang history of the library
13:53:31 <dcoutts> SamB: core lib changes are supparised in the ghc release notes
13:53:53 <dcoutts> supparised/summarised
13:54:15 <SamB> is there only one base version change between GHC releases?
13:54:52 <dcoutts> SamB: can you rephrase that, I don't know what you're asking exactly
13:55:22 <dons> SamB: darcs changes is a summary. the entire history is changes -v
13:55:38 <edwardk> @hpaste
13:55:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:56:15 <SamB> that is, is there a one-to-many relation from base versions to GHC versions?
13:56:17 <edwardk> http://hpaste.org/7401 cabal-install build snafu ?
13:56:33 <SamB> or are there ever some base versions that never see a GHC release?
13:56:43 <dcoutts> edwardk: that version of cabal-install is far far to old
13:56:56 <edwardk> dcoutts, thats what i get for clicking in hackage i guess
13:57:13 <SamB> though I suppose it's not like people would often end up with those long after the next GHC release...
13:57:25 <dcoutts> edwardk: we cannot release the current version on hackage yet because it uses the development version of the Cabal library, which is also not released yet
13:57:54 <SamB> dcoutts: there should be a way to flag a hackage package as obsolete regardless of availability of newer versions
13:57:57 <edwardk> dcoutts: ok, so basically i just can't use cabal-install without going to grab your head releases of both?
13:58:06 <dcoutts> SamB: each ghc version has one base version, there may be base versions that do not exist in any ghc release
13:58:41 <dcoutts> SamB: I agree, and to mark superseded etc, there's an open ticket on that if you want to work on it
13:58:47 <SamB> dcoutts: I suppose those between-release versions won't be too much of an issue, if anyone wants them to work they can figure out how to get it to work...
13:59:10 <dcoutts> edwardk: if you don't want the darcs versions then you can use the pre-release tarballs I made recently
13:59:35 <keir> does haskell have an API for manipulating haskell?
13:59:45 <edwardk> dcoutts: basically i just want something i can run cabal-install and get something with, the shorter the path to that the better. where are the tarballs?
13:59:53 <ddarius> keir: There are several.
13:59:54 <SamB> ... and there's of course an open ticket on creating an "unstable" repository, right?
14:00:13 <dons> keir: there's a few different metaprogramming tools (Data.Generics, Template Haskell, the ghc-api, hs-plugins, Language.Haskell parser and pretty printer, etc)
14:00:15 <SamB> keir: what do you want to do in your manipulations?
14:00:19 <keir> ddarius, cool. is it possible to do runtime compilation stuff on it?
14:00:28 <dcoutts> edwardk: http://haskell.org/cabal/release/
14:00:44 <keir> one of my thought experiments is a language where it is impossible to make a syntax or type error
14:00:44 <ddarius> keir: Depends on what you mean by "run-time compilation."
14:00:55 <keir> i.e. incremental compilation
14:00:56 <dcoutts> edwardk: you want Cabal-1.3.10 and cabal-install-0.4.6
14:01:05 <keir> by 'language' i mean an IDE type thing
14:01:09 <keir> except you are not manipulating text
14:01:13 <edwardk> dcoutts: thanks a lot man
14:01:15 <mauke> I have a language without syntax errors
14:01:16 <keir> you are directly manipulating the program representation
14:01:25 <ddarius> keir: Structure editors have been tried and my impression is that no one really liked them.
14:01:27 <mauke> every character sequence is a valid program
14:01:44 <ddarius> mauke: iota or jot can execute any binary.
14:01:48 <keir> ddarius, where? i didn't see any that i would have liked.
14:01:56 <dcoutts> edwardk: and we appreciate if people testing the pre-releases can report bugs in our tracker and not just assume that someone else has already reported it first ;-)
14:01:58 <dolio> SKKSSKSKKK
14:02:07 <edwardk> dcoutts: will do
14:02:18 <ddarius> keir: Littered throughout the history of computer science.  The idea has come up several times in the past 60 years.
14:02:20 <dcoutts> edwardk: thanks muchly :-)
14:02:41 <OceanSpray> what's littered throughout the history of computer science?
14:02:58 <dcoutts> structure editors?
14:03:04 <ddarius> keir: There are a few languages that have similar or related things such as Subtext, Epigram, Citrus and others.
14:03:19 <keir> subtext is a neat idea but i suspect impractical
14:03:41 <ddarius> s/few languages/few current languages/
14:04:22 <johnnowak> keir: you'd be surprised what people will use
14:05:25 <keir> oh, cool, i didn't know about epigram or citrus
14:06:24 <SyntaxNinja> dons: are there public repos anywhere for the galois stuff like feed & xml
14:06:28 <SyntaxNinja> ?
14:06:30 <johnnowak> a lot of lisp/scheme programmers use structure editors in which the code is always a valid tree
14:07:03 <dons> SyntaxNinja: curl, selenium and utf8-string are on code
14:07:09 <dons> the plan was to move other things there if there was demand.
14:09:16 <keir> hmm, upon further inspection epigram does not impress
14:09:40 <mrd> structure editing was tried for Lisp, see INTERLISP
14:09:43 <ehird> how can i disable warnings for one definition?
14:10:38 <mauke> step 1: use perl; step 2: sub foo { no warnings; ... }
14:11:06 <TomMD> Wouldn't step 1 suffice?
14:11:30 <dons> ehird: which warning?
14:11:54 <ehird> dons: specifically, the 'fields not initialized' one
14:12:34 <dons> ehird: -fno-warn-missing-fields i htink
14:12:43 <ehird> dons: For one definition?
14:12:51 <dons> well, for the module it is in
14:12:55 <dons> that's as much as you can do
14:13:06 <Saizan_> ehird: initialize with an error "foo"
14:13:54 <ehird> Saizan_: cute
14:14:54 <keir> citrus looks closer to what i want to do, but it is WAY general
14:15:15 <SyntaxNinja> dons: OK.
14:16:15 <keir> johnnowak, do you know if the lisp/scheme structured editors do type checking too?
14:16:19 <dons> ehird: yeah, that's actually more common "error "unitiliased blah"
14:16:20 <astrolabe> In a module I've newTyped something as an Int.  In the ghci debugger, something with type related to the newType appears to have type related to Int instead.  Is this likely?  Is it a bug in ghc?  Is it known?
14:16:50 <dons> astrolabe: example? newtypes should be rather opaque
14:17:14 <johnnowak> keir: i doubt it
14:17:15 <astrolabe> dons: I'll try to make a less complicated example, and see how I get on.  Thanks.
14:17:38 <mauke> astrolabe: the debugger uses runtime type information to recover types
14:17:45 <mauke> newtypes don't have a runtime representation
14:18:28 <dons> oh, in the debugger.
14:18:33 <dons> yeah, that's what is going on
14:18:54 <dmwit> ehird: Did you see byorgey's partial knowledge blog post?
14:19:15 <ehird> dmwit: nope
14:19:51 <dmwit> http://byorgey.wordpress.com/category/math/
14:19:52 <lambdabot> Title: math  blog :: Brent -> [String]
14:20:01 <astrolabe> Hmmm. But that means I can't use some functions from my code because they're expecting the newType.
14:21:04 <astrolabe> I don't really want to have to write special versions for the debugger, and if I did, they wouldn't compile.
14:21:51 <astrolabe> Do I have a valid whinge?  And if so, who do I whinge at?
14:22:44 <dmwit> If true, I would call that a valid whinge.
14:23:00 <dmwit> Maybe whinge at haskell-cafe?
14:23:12 <astrolabe> Thanks all.  I'll see if I can make a convincing simple example.
14:24:29 <dolio> You could replace 'newtype' with 'data' no?
14:24:47 <dons> astrolabe: you can coerce the type to a newtype in the debugger
14:24:53 <dons> that might give it enough information to proceed
14:25:05 <astrolabe> dolio: thanks for the idea
14:25:10 <dmwit> dolio: Then you might not get fancy deriving.
14:25:20 <astrolabe> dons: how do you coerce in haskell?
14:25:21 <dolio> Oh, that's true.
14:25:33 <dons> astrolabe: the debugger has some coerce function
14:25:52 * astrolabe looks
14:26:06 <dmwit> There's also the newtype's constructor, right?  That's like a coerce function, kind of.
14:28:23 <astrolabe> dmwit I don't actually have something of the newtype, but of a type constructed from it.
14:28:46 <dmwit> Oh, yeah, then things get nastier. heh
14:30:32 <dons> you could case on it
14:30:47 <dons> give the type reconstruction some hints
14:32:03 <astrolabe> The trouble is, I've got about 5 layers of type obfuscation, so it's all pretty confusing.  I think I'll try using Debug.Trace.  Thanks for the help though everyone.
14:33:22 <astrolabe> I can't help thinking I should have used unit tests like a good boy :)
14:34:55 <dons> quickcheck ftw!
14:35:17 <dons> seriously, in haskell, there's no excuse to end up in the debugger :) so many tools available to prevent you reaching that point
14:35:20 <dons> :)
14:35:31 <johnnowak> :)
14:36:37 <ygale> still, given the ever-present Murphy, it's good to know that the debugger is there if we do reach that point.
14:36:49 <astrolabe> Perhaps I am a poor coder, but constructing test cases for a lot of my code is a pretty complicated undertaking.
14:37:40 <dons> but you write small, referentially transparent functions that do simple, orthogonal tasks, right? :)
14:37:52 <johnnowak> astrolabe: dons is just saying that because ghc only recently got a debugger
14:38:17 <astrolabe> dons: Is there a theorem that every algorithm breaks down into such simple tasks?
14:38:31 <ddarius> astrolabe: Compilation.
14:38:35 <dons> yeah.
14:38:47 <dons> its all S and K
14:38:59 <astrolabe> The impression I get is that there is some irreducable level of complication for each algorithm.
14:39:20 <astrolabe> ddarius: I don't understand.  Dons I don't understand you either :)
14:39:31 * edwardk puts cabal-get, cabal-install, etc all down and gets back to work, frustrated that an hour later everything is still not in a usable state. 
14:39:35 <dons> i've found quickcheck actually guides me towards the proper decomposition, fwiw.
14:39:42 <dons> since you're encourages to find things with good properties
14:39:47 <dcoutts> edwardk: what went wrong?
14:39:52 <TomMD> dons: That is an interesting way to look at things
14:39:54 <dons> so its sort of machine support pushing you towards sensible primitives
14:39:57 <astrolabe> dons: That seems sensible.
14:40:17 <ddarius> edwardk: I had no trouble just darcs getting the latest cabal-install and buliding zlib and some other library with the standard cabal triple.
14:40:18 <dons> certainly worked like that in xmonad
14:40:31 <dons> we threw out code whose properties were too dificult to formalise
14:40:34 <TomMD> My mind problem when using quickcheck is that some of my functions have too many corner cases (typically: when the input is at a minBound or maxBound)
14:40:43 <TomMD> s/mind/main/
14:40:54 <edwardk> dcoutts: well, to be quite honest, color me the clueless user. i just wanted to install something quick from hackage an hour ago, that i have managed to forget and i can't figure out how to use the blasted thing =)
14:41:22 <dcoutts> edwardk: http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
14:41:23 <lambdabot> http://tinyurl.com/39kra4
14:41:48 <edwardk> that much i've been able to do all along
14:42:02 <shapr> edwardk: You called?
14:42:26 <edwardk> i was looking for something that would pull the package down from hackage and just do the right thing with it
14:42:38 <edwardk> maybe it was an expectation impedence mismatch of some sort
14:43:01 <dons> TomMD: so you want more precise generators?
14:43:19 <dons> Gen IntEmphasisingBoundaries
14:43:36 <dons> i'd like hpc to show me the range of values a variable held in a test run
14:43:55 <TomMD> I typically make something that generates to 'a' and have a function (or several) that converts the data to a specific constructor that I know the function expects.
14:44:08 <dons> yep
14:44:34 <andyjgill> dons: There is a trick to show values that might work.
14:45:00 <dcoutts> edwardk: right, so cabal-install is exactly the tool that pulls the packages from hackage and does the right thing
14:45:03 <dons> andyjgill: ah ha!
14:45:18 <dons> andyjgill: ideally, some warning if sufficient coverage of the type's inhabitants wasn't achieved
14:45:22 <dcoutts> edwardk: but as you said, you need two dependnecies first, zlib and HTTP
14:45:25 <edwardk> dcoutts: ok, so call me stupid, i just can't figure out how to get it to do anything =)
14:45:29 <edwardk> dcoutts: i got those
14:45:30 <dons> kind of like a case x of 1 -> ;2 -> ; 3 -> ... n ->
14:45:38 <dcoutts> edwardk: and you got cabal-install built and installed?
14:45:46 <dons> i guess i could do a funky macro to make that work, actually
14:45:50 <edwardk> dcoutts: yeah have for quite a while
14:45:52 <andyjgill> Look at section 6.5 of the paper.
14:46:09 <dons> ok. cool. and its typically a set of boundaries i care about. and then everything in between
14:46:18 <dolio> cabal update ; cabal install foo
14:46:24 <TomMD> andyjgill: Good work on KU.  Will you be teaching any courses or is it all research time?
14:46:25 <andyjgill> Its far from ideal, but might work for your needed.
14:46:27 <dcoutts> edwardk: ok, so then first time you do anything it'll tell you that the list of packages is not up to date and to run 'cabal update'
14:46:35 <edwardk> i ran cabal update
14:46:37 <dcoutts> edwardk: at least it should tell you to do that :-)
14:46:41 <dcoutts> edwardk: ok, good
14:46:46 <andyjgill> Both teaching and research.
14:46:47 <edwardk> but cabal install whatever does nothing
14:46:54 <edwardk> thats why i'm sitting here wondering wtf
14:46:56 <dcoutts> edwardk: then after than you should be able to cabal install foobar
14:47:17 <edwardk> as does cabal list, i get nothing
14:48:07 <dcoutts> edwardk: you mean it just terminates immediately without reporting any message, what are you trying to install?
14:48:36 <dcoutts> edwardk: using the -v flag helps us with debugging the problem
14:48:44 <edwardk> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/value-supply as an example
14:48:45 <lambdabot> http://tinyurl.com/27ge84
14:48:49 <dcoutts> or -v3 for max verbosity output
14:49:20 <dcoutts> edwardk: so 'cabal list value-supply' is ok then, just not install right?
14:49:42 <edwardk> cabal list value-supply just returns nothing as well
14:49:52 <dcoutts> hmm weird
14:49:57 <dcoutts> edwardk: try with -v3
14:50:04 <kadir> huh? does String can implemet Num at all?
14:50:18 <ddarius> No, strings aren't numbers.
14:50:19 <edwardk> @hpaste
14:50:19 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:50:19 <dcoutts> edwardk: so that's not your fault, it's a bug of some sort
14:50:26 <kadir> sorry at all for maybe stupid questions
14:50:29 <mauke> kadir: not in any sane way
14:50:35 <edwardk> dcoutts: http://hpaste.org/7402
14:50:40 <dcoutts> ta
14:50:52 <edwardk> dcoutts: i'm glad coz i was thinking i was doing something incredibly stupid =)
14:51:08 <dcoutts> edwardk: ah, hmm, ghc-6.9, we've not tested that extremely carefully
14:51:22 <dcoutts> edwardk: and the ghc-pkg stuff is different in 6.9
14:51:31 <edwardk> i need 6.9 to be able to run stuff based on Control.Category
14:51:44 <edwardk> so basically i'll just go back to what i was doing before
14:51:47 <dmwit> kadir: What would (*) mean on strings?  Or how about "negate"?
14:51:57 <dcoutts> edwardk: run this command and tell us the result: ghc-pkg describe '*' --user
14:52:06 <mauke> dmwit: as for negate, just ask perl
14:52:13 <kadir> not so important
14:52:22 <edwardk> ghc-pkg: cannot find package matching *
14:52:32 <dcoutts> edwardk: ok, that's our problem :-)
14:52:37 <johnnowak> kadir: you could write a Num instance for String if you really wanted to
14:52:38 <dmwit> kadir: If you just want (+), then use Monoid.  (String is, incidentally, an instance of Monoid.)
14:52:39 <edwardk> heh
14:53:01 <dcoutts> edwardk: cabal expects an empty list of packages, ie nothing at all, it's not prepared to cope with that error message and non-0 exit code
14:53:14 <dcoutts> edwardk: it's a mismatch between cabal and ghc-pkg-6.9 at the moment
14:53:18 <edwardk> ah
14:53:22 <wjt> hmm, i suppose since ghc does UTF-8 you could write () :: [a] -> Int -> [a] which does what x does in Perl
14:53:24 <dmwit> kadir: Although Monoid instances spell (+) as "mappend".
14:53:41 <mauke> `replicate`
14:53:43 <edwardk> so if i cheated and wrapped it in a shell script to discard the error code and message i might be able to bandaid this? ;)
14:53:46 <dcoutts> edwardk: the workaround is to install 1 or more packages as --user, then it should avoid that zero case
14:53:55 <wjt> mauke: yes i know
14:54:00 <Japsu> we should make all numeric types instances of Monoid and let (+) = mappend
14:54:04 <dmwit> mauke: That would be concat . replicate... right?
14:54:10 <mauke> yes :(
14:54:19 <Japsu> then make a nef type class called Field that would also have (*)
14:54:22 <Japsu> *new
14:54:23 <wjt> dmwit: yes, but actually i feel like () = replicate would look nice
14:54:24 <dmwit> Japsu: There are at least two reasonable Monoid instances for Int.
14:54:33 <Japsu> ;/
14:54:39 <edwardk> dcoutts: would i just Setup.lhs configure --user or something to do that?
14:54:46 <dmwit> Japsu: See Sum and Product. ;-)
14:54:51 <Japsu> Bah
14:55:00 <ygale> @pl \x i -> concat $ replicate i x
14:55:00 <lambdabot> (join .) . flip replicate
14:55:01 <wjt> It'd be really nice if you could write   foo   for  repeat foo   :-)
14:55:22 <SamB> wjt: what do you think this is, Coq?
14:55:32 <dcoutts> edwardk: yes, and assuming you're using Cabal-1.3.x it'll install to $HOME/.cabal/ by default unless you override with --prefix
14:55:38 <dolio> Agda.
14:55:45 <dmwit> APL
14:55:48 <SamB> oh you can do that in Agda too?
14:55:59 <SamB> neat
14:56:04 <dolio> Yeah. Arbitrary mixfix operators.
14:56:07 <dolio> And unicode in source.
14:56:23 <SamB> since I'm just installing that since Coq is frustrating me endlessly for expecting me to include ALL cases in match expressions, even impossible ones
14:57:01 <BONUS> is partial function application currying?
14:57:06 <dolio> You sometimes have to include impossible cases in Agda.
14:57:13 <BONUS> because i've seen most other languages define it like that
14:57:15 <dolio> Using the absurd pattern ().
14:57:19 <SamB> BONUS: currying is making functions that can be partially applied
14:57:19 <edwardk> hrmm configure --user is still trying to dump into /usr/local/share/doc/...
14:57:20 <dmwit> BONUS: Currying can refer to two different things.
14:57:34 <BONUS> yeah i've noticed
14:57:36 <MyCatVerbs> dmwit: three things, depending on how hungry you are.
14:57:38 <SamB> dolio: I don't mind as long as there is some way to implement them!
14:57:48 <SamB> some reasonably well-documented way
14:58:02 <dmwit> BONUS: In some uses, it means partial application.  In other uses, it means:
14:58:03 <dmwit> :t curry
14:58:06 <dcoutts> edwardk: you may be using the Cabal-1.2.x, in which case you'll need to set --prefix=wherever
14:58:07 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:58:14 <BONUS> yeah that's what i was confused about
14:58:25 <edwardk> dcoutts: didn't i just install 1.3.10?
14:58:32 <SamB> so curried functions can be partially applied, non-curried functions can't
14:58:55 <edwardk> [slipwave@www category-extras]$ ./Setup.lhs -V\nCabal library version 1.3.10
14:58:56 <dmwit> SamB++ I never thought of it that way.
14:58:58 <dcoutts> edwardk: yes, but it depends how you're invoking, eg are you doing runghc Setup.hs, or running a compiled ./setup?
14:59:08 <yaarg> @hpaste
14:59:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:59:10 <edwardk> ah good point
14:59:13 <BONUS> so in haskell what curry does is take a function that takes a pair and two parameters, packs them into a pair and calls the function?
14:59:25 <dmwit> yup!
14:59:27 <dmwit> ?src curry
14:59:28 <lambdabot> curry f x y = f (x, y)
14:59:52 <dcoutts> edwardk: all this is so much simpler once you have a cabal binary :-)
15:00:07 <dmwit> Or, curry f = \x y -> f (x, y) -- maybe closer to your English description, and mostly equivalent
15:00:15 <edwardk> dcoutts: i hope so =)
15:00:23 <BONUS> kewl
15:00:29 <dcoutts> edwardk: cabal-install decides what version of the Cabal lib to use, based on what's installed and what the package requests
15:00:29 <BONUS> i recon that's usually used with zipped lists
15:00:31 <edwardk> dcoutts: i've been using runhaskell ./Setup.lhs ...
15:00:38 <SamB> dcoutts: is it really that much simpler?
15:00:49 <byorgey> anyone know when the ICFP programming competition is going to be?
15:00:52 <dmwit> BONUS: Yeah, that's one of the most common uses for uncurry.
15:00:53 <BONUS> i haven't used curry that much so far, although i proably could have replaced some lambda uglyness with curry
15:00:59 <SamB> I mean, you can't exactly say "cabal install cabal-install"
15:01:04 <byorgey> I heard that PSU is organizing it
15:01:08 <SamB> if you want to upgrade, that is
15:01:13 <SamB> byorgey: again???
15:01:17 <dcoutts> SamB: you can, once we have a cabal-install release
15:01:22 <SamB> they did it like to years ago didn't they?
15:01:23 <byorgey> SamB: did they organize it before?
15:01:26 <dmwit> BONUS: But if you are doing that a lot, you might want to look into zipWith. ;-)
15:01:27 <byorgey> oh, I don't know
15:01:29 <SamB> er. two?
15:01:38 <BONUS> hehe yeah
15:01:45 <SamB> @go cult bound variable
15:01:47 <lambdabot> http://www.boundvariable.org/
15:01:47 <lambdabot> Title: ICFP Programming Contest, 2006
15:01:52 <dcoutts> edwardk: hmm, so ghc-pkg list Cabal reports all the versions you expect?
15:01:57 <BONUS> i always think of zipWith like i used to think of fold
15:02:06 <edwardk> yeah 1.3.2 and 1.3.10
15:02:07 <BONUS> as in that it should always take something like (+)
15:02:09 <SamB> yup, that was CMU
15:02:18 <BONUS> but then you see the uses are actually a lot greater
15:02:35 <byorgey> SamB: seems it was organized by OGI in 2002, and most of those people are probably at PSU now
15:02:56 <dcoutts> edwardk: I'm confused then, --user should imply --prefix=$HOME/.cabal
15:02:59 <SamB> hmm.
15:03:04 <dcoutts> edwardk: but you can set --prefix= anyway
15:03:12 * SamB seems to have trouble distinguishing TLAs ending in U
15:03:43 <byorgey> SamB: hehe, that's unfortunate, there are a lot of them =)
15:03:54 <dcoutts> edwardk: and your runhaskell is using your expected version of ghc?
15:04:45 <SamB> where does one find QuickCheck 2?
15:04:52 <ygale> SamB: how about ETLAs?
15:05:02 <edwardk> dcoutts: hrmm whats the easiest way to check the version being run by runhaskell?
15:05:18 <SamB> ygale: well, it may depend on whether or not they spell something
15:05:26 <wolverian> DDC gives me warnings because it uses Int32# for long in its FFI for fseek(). what is it supposed to use?
15:05:48 <dcoutts> edwardk: I'd not bother, ghc-6.9 -package Cabal-1.3.10 --make Setup.lhs -o setup && ./setup configure --user
15:06:04 <dmwit> wolverian: Something like CInt or CLong?
15:06:06 <dons> CLong ?
15:06:10 <dons>      fseek(FILE *stream, long offset, int whence)
15:06:24 <SamB> wolverian: CLong, yes...
15:06:38 <edwardk> @hpaste
15:06:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:06:39 <wolverian> I'm just cargo culting FFI. I thought it needs unboxed types. or do you mean I should use CLong#?
15:06:50 <mauke> Ptr FILE -> CLong -> CInt -> IO CInt
15:06:52 <SamB> wolverian: no, it unboxes those for you
15:06:57 <wolverian> ah.
15:06:58 <mauke> I've never seen unboxed types in FFI
15:07:12 <edwardk> dcoutts: you'll love this http://hpaste.org/7403
15:07:30 * SamB should know, after having implemented FFI export in JHC along with dynamic FFI calls...
15:07:55 <wolverian> oh, dammit, this is DDC code, not haskell. :)
15:08:07 <SamB> what is DDC anyway?
15:08:21 <dmwit> ?go ddc programming
15:08:22 <lambdabot> http://highperformancehvac.com/ddc-programming-logic.html
15:08:22 <lambdabot> Title: HVAC DDC Programming Logic and Symbols - Direct Digital Controls - DDC HVAC Cont ...
15:08:24 <ygale> SamB: a TLA
15:08:27 <wolverian> http://code.haskell.org/ddc/disciple-HEAD/library/System/File.ds
15:08:35 <wolverian> SamB, it's a strict haskell variant
15:08:36 <edwardk> samb: ben lippmeier's region-based strict haskell-analogue, has a type-and-effect system
15:08:50 <byorgey> SamB: darcs get http://code.haskell.org/QuickCheck
15:08:51 <lambdabot> Title: Index of /QuickCheck
15:08:57 <wolverian> I'm mostly interested in the field system
15:09:02 <SamB> oh, I have no clue then...
15:09:03 <wolverian> it makes records almost usable :)
15:09:04 <dmwit> Whoa, semicolons.
15:09:06 <dcoutts> edwardk: that's pretty weird, but I'm not at all convinced we're picking up the right version
15:09:16 <dcoutts> edwardk: try ghc-6.9 -package Cabal-1.3.10 --make Setup.lhs -o setup
15:09:52 <SamB> why is it using the "BSD4" license??????
15:10:02 <SamB> QuicCheck 2, I mean...
15:10:19 <SamB> cabal thinks that's wierd
15:10:22 <edwardk> just did it. was pasting that too =)
15:10:35 <SamB> cabal doesn't seem to remember about that license ever having existed, either
15:10:38 <edwardk> but hpaste is thinking there is a url somewhere in the output of ghc-v or something
15:10:51 <wolverian> the four-clause BSD license is evil
15:11:03 * SamB is hoping it was a clerical error
15:11:06 <gwern> I wonder if anyone has managed to download this recent SAT solver program; the git clone is taking *forever*
15:11:06 <dcoutts> SamB: it's still an existing license in Cabal
15:11:16 <dcoutts> SamB: but yes we do warn about people using it
15:11:33 <SamB> % cabal --version
15:11:33 <SamB> cabal-install version 0.4.6
15:11:33 <SamB> using version 1.5.1 of the Cabal library
15:11:45 <SamB> % cabal install
15:11:45 <SamB> Configuring QuickCheck-2.0...
15:11:45 <SamB> Warning: 'license: BSD4' is not a recognised license.
15:12:09 <edwardk> dcoutts: http://comonad.com/haskell/wtf.txt
15:12:20 <gwern> I think it got removed, no?
15:12:23 <dcoutts> SamB: that was a temporary and embarrassing bug I fixed the other day :-)
15:12:36 <gwern> since no one was correctly using it, and the few who needed it could just use Other
15:12:48 <SamB> dcoutts: ah.
15:12:57 <SamB> I don't see why it's embarrasing or a bug
15:13:08 <dcoutts> SamB: I missed something out in the parsing
15:13:12 <SamB> I just thought the license had made it past deprecation...
15:13:19 <dcoutts> not yet
15:14:09 * SamB wonders why Agda needs haskell-src
15:15:10 <gwern> SamB: comment out and discover why?
15:15:14 <edwardk> dcoutts: http://comonad.com/haskell/wtf.txt notice that it complained about the 'run the configure command first' after i ran configure with --user
15:16:55 <dcoutts> edwardk: oh, right because you're still getting the problem with ghc-pkg describe '*' --user
15:17:13 <edwardk> dcoutts: so bootstrapping won't solve the problem?
15:17:48 * SamB is amused that the first step to install the Emacs frontend is numbered "-1"
15:18:04 <b_jonas> gwern: heh
15:18:06 <b_jonas> that's ironic
15:18:49 <b_jonas> maybe it's a sat solver that performs in finite time but has an infinitely large lookup table that's generated dynamically and in exponential time by the server
15:18:55 <dcoutts> edwardk: ah, lets try something slightly different
15:18:55 <SamB> b_jonas: why, does "git clone" lack a decent SAT solver?
15:19:25 <gwern> b_jonas: I find the irony to be that git is running so slowly; although it's possible that the server is so slow/stressed that a darcs get would be even worse
15:19:48 <edwardk> ghc-package describe '*' works fine as root
15:20:22 <dcoutts> edwardk: that's because there are some packages installed globally, it's --user that doesn't
15:20:31 <edwardk> yeah
15:20:31 <dcoutts> edwardk: try: ghc-pkg describe Cabal-1.3.10 | ghc-pkg --user register -
15:20:52 <dcoutts> edwardk: that just copies a package registration from the global to user package db
15:21:08 <edwardk> hey that seems to have done something
15:21:13 <dcoutts> then ghc-pkg describe '*' --user will work
15:21:18 <wolverian> gwern, git can max out my pipe (10mbit/s), so surely it's not git's fault :)
15:21:22 <edwardk> yep
15:21:28 <b_jonas> g'night
15:21:33 <edwardk> good trick
15:21:33 <dcoutts> edwardk: and then Cabal will not fall over when calling ghc-pkg describe '*' --user
15:21:57 <dcoutts> edwardk: btw, I'll go improve the error message we get when that fails, it's currently most unhelpful (being completely silent)
15:22:19 <edwardk> beautiful, now it works and i can install stuff as --user
15:22:22 <dcoutts> yay
15:22:37 <dcoutts> edwardk: for a full fix we're waiting on: http://hackage.haskell.org/trac/ghc/ticket/2201
15:22:39 <lambdabot> Title: #2201 (&#34;ghc-pkg --user describe '*'&#34; fails with empty user db) - GHC - T ...
15:22:51 <gwern> wolverian: on that particular repo?
15:23:12 <edwardk> ok, so now i can try to actually use this thing ;)
15:23:32 <wolverian> gwern, no. I just parsed your statement as "is git really this slow?" sorry if that was a misparse and you were blaming the repo.
15:23:43 <edwardk> and cabal list no longer silently dies
15:24:49 <gwern> wolverian: well, I added a clause to the effect 'maybe it's the servers fault'
15:24:59 <edwardk> dcoutts: ok, one last unrelated question, dolio and i were going to merge our versions of category-extras, what do you have to do to update a package on hackage that was originally created by someone else?
15:25:35 <wolverian> gwern, yes, it is.
15:26:58 <gwern> edwardk: nothing prevents you from uploading
15:27:21 <gwern> edwardk: it isn't like 'the first one to upload a package of a specific name is the only one who can upload'
15:27:24 <edwardk> gwern: ok wasn't sure if there was some sort of package name protection or something
15:27:40 * gwern notes that this is perhaps a security problem, but I've sure found it convenient
15:28:03 <ehird> gwern: You could say that.
15:30:09 <edwardk> gwern: ok, then i'll start spamming the hackage logs with category-extras updates ;)
15:35:51 <edwardk> @tell dolio first draft thrown on hackage
15:35:51 <lambdabot> Consider it noted.
15:36:18 * gwern runs into a DDC compile error. bleh. I guess the x86_64 support is still not quite there
15:36:48 <gwern> personally, I always wonder how people can still be running i686 or lower; didn't 64-bit become standard like, 4 years ago or something?
15:37:08 <dmwit> nope
15:39:12 <jamii> Wont be standard till everyone can watch youtube on 64 bit without using brain cells
15:39:30 <dis9> Hello all, I was reccommended this channel by someoen stating that it actually matters to the real world
15:39:52 <dis9> someone*
15:39:58 <edwardk> dis9: we like to think it does
15:40:22 <gwern> jamii: so the windows and mac flashes are still 32-bits?
15:40:35 * gwern always assumed that adobe was deliberately neglecting linux flash
15:40:48 <ehird> gweiqi: 'everyone'
15:40:51 <ehird> err
15:40:53 <ehird> gwern
15:41:15 <gwern> ehird
15:41:25 <ehird> gwern
15:41:33 <mauke> 
15:41:34 <gwern> ehird
15:41:38 <dons> dis9: welcome. #haskell: changing the RealWorld#
15:41:38 <ehird> gwern
15:41:52 <ehird> dons: HAHAHA
15:42:05 <gwern> ehird!
15:42:12 <ehird> gwern!!!
15:42:16 <dons> ?users
15:42:16 <lambdabot> Maximum users seen in #haskell: 460, currently: 422 (91.7%), active: 14 (3.3%)
15:42:22 * dmwit !!!
15:42:24 <jamii> 64 bits flash falls over on vista
15:42:38 <gwern> ehird!1111
15:42:39 <jamii> At least for every machine we have here
15:42:45 <ehird> fun fact: #haslkell is bigger than #ruby+#ruby-lang
15:42:51 <ehird> gwern?
15:42:54 <jamii> An XP support for 64 bits isnt great
15:42:58 <dmwit> gwern!cos 0!!
15:43:10 <jamii> ehird: How do you measure a channel?
15:43:13 <ehird> gwern factorial
15:43:24 <gwern> ehird-ackermann
15:43:32 <ehird> jamii: nickcount
15:43:50 <dmwit> > 309 + 189
15:43:53 <lambdabot>  498
15:43:54 <dons> http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode
15:43:54 <jamii> But that assumes that every nick is equal
15:43:55 <lambdabot> Title: Search IRC, displaying all channels on freenode
15:44:14 <gwern> jamii: then go by active count?
15:44:18 <dmwit> ehird: I see 498 in ruby+ruby-lang, 421 in haskell.
15:44:20 <dons> ruby channels aren't in the top 20 anymore. huh
15:44:37 <gwern> you know what? I'm tired of gentoo. I'm going to switch back to ubuntu or debian
15:44:52 * gwern waits 6 to 8 weeks for my cd to arrive
15:44:53 <ehird> dmwit: must be a good day
15:44:54 <dmwit> Whoa, #vim is in the top 20?
15:45:01 <mauke> gwern: what, too boring for you? :-)
15:45:22 <gwern> mauke: no, too much work. I think the last straw was not being able to compile wxhaskell
15:45:38 <dmwit> gwern: You could also torrent it and burn yourself a disc.  That's only one day (two, if your connection is slow).
15:45:43 <dons> #ruby-lang is in 23rd, #rubyonrails is 32nd.
15:45:53 <jamii> gwern: With my scientist hat on I have to force myself to consider the hypothesis that the average ruby nick has more value than the average haskell nick. Of course once the scientist hat comes off I find the idea hilarious
15:45:57 <gwern> dmwit: unfortunately, my only cd/dvd burner is in my laptop, which is badly borked
15:46:07 <ehird> jamii: hah
15:46:11 <dons> that's quite a fall from its high, #rubyonrails, Current: 286, Max: 1475
15:46:18 <gwern> jamii: lol. well, ask yourself: how could I quantify 'value' in this respect?
15:46:26 <dons> jamii: that's bizarre.
15:46:37 <dmwit> gwern: Total number of characters sent to the channel?
15:46:48 <ehird> Ruby chans may have more clones and bots
15:46:53 <jamii> gwern: I dont know? Beard length. Haskell definitely wins on average beard length
15:46:58 <gwern> dmwit: no, that'd overcount those whoe flame and go offtopic
15:47:02 <dons> really?
15:47:18 <jamii> dons: Bizarre how?
15:47:23 <dons> i'm not sure beards are that common, actually
15:47:24 * dmwit suddenly feels bad for bringing down the average beard length
15:47:46 <jamii> I think wadler has beard enough for all of us
15:47:47 <mauke> ABL!
15:47:50 <gwern> I dislike the beardo count method, since obviously it penalizes languages with female users
15:47:51 <dons> he's not in #haskell though.
15:48:01 <dons> this is the 3rd gen haskellers, mostly. 20-somethings
15:48:19 <jamii> gwern: Are you saying women cant have beards. Sexist!
15:48:25 <mauke> and Igloo?
15:48:33 <ddarius> dons: What's a 2nd gen haskeller?
15:49:02 <gwern> jamii: no, I'm saying that going by beards means we are forced into an awkward delimma: be penalized by omitting beards, or... endure the horrors of all the women being bearded
15:49:12 <dons> ddarius: the phd students of the first gen. guys like andy gill or simon marlow
15:49:23 <dons> first gen is wadler, hughes, lennart et al
15:49:28 <jamii> dons: Thats true. It seems beards are a flawed measure. Science defeats me again
15:49:52 <dons> first gen are approaching 50 now, second gen in their late 30s, 3rd gen in their late 20s.
15:50:15 <dons> some of the 3rd geners might end up with phd students of their own in 5 years or so
15:50:19 <Twey> So I'm... fourth-gen?  :-P
15:50:25 <Twey> Oh
15:50:26 <Igloo> Does the age gap between successive generations continue to halve indefinitely?
15:50:29 <jamii> How about we let the bots fight to the death - the winning channel takes all
15:50:31 <Twey> 3.5th-gen?  :-P
15:50:48 <dons> yeah, Twey and byorgey are 3.5th
15:50:56 <dons> since you're not actually the students of 3rd geners
15:51:02 <Twey> That's true
15:51:21 <edwardk> heh then what about us weirdos who weren't students of any gen'er? =)
15:51:24 <dons> so if duncan or swiert or kosmikus have students sometime, those guys will be 4th gen
15:51:35 <dons> edwardk: then it goes by when you started
15:51:47 <dons> mid 80s, mid 90s or mid 20s
15:51:50 <edwardk> ok, so i've been floating around here for about 2 years =)
15:51:53 <ddarius> If I become a student of a 1st generation-er, do I become 2nd generation?
15:52:05 <dons> ddarius: i don't think so, at this point.
15:52:09 <edwardk> ddarius: this sounds disturbingly like haskell diablerie
15:52:13 <jamii> gwern: Given the general compsci statistics I dont think bearded women are a significant part of our score anyway
15:52:14 <dons> you had to be involved in the h98-era
15:52:16 <mauke> edwardk: hahaha
15:52:38 * ddarius has been here over six years...
15:52:39 <IsoPallo> This sounds like some World of Darkness-series game...
15:52:42 <dons> e.g. i'm the student of manuel, who's (sort of) spj
15:52:45 <dons> s student
15:52:59 <jamii> dons: nice save
15:53:07 <dons> space / enter too close
15:53:27 <dmwit> Mmmm, ergonomics.
15:53:30 <dons> yeah, ddarius is on the cusp of 3rd gen. same as say, igloo or kosmikus
15:53:30 <Igloo> dons: Whereas Duncan and I were taught by Bird...  :-)
15:53:32 <jamii> What kind of keyboard ... never mind
15:53:38 <dons> Igloo: yeah, that's the puzzle
15:54:00 * Igloo is a generation vortex
15:54:29 <Igloo> Scientists theorise that lambdas actually bend as they fly past me
15:54:40 <jamii> gen p = gen (teacher p) - 1 ; teacher jamii = jamii
15:54:59 <jamii> Oh dear - I appear to be an infinite loop
15:55:16 <jamii> * + 1
15:55:33 <dons> now, the other thing is the beards.
15:55:36 <IsoPallo> Or a cyclic list
15:55:45 <dons> the beards seem to be decreasing in each generation. with some exceptions.
15:55:57 <dons> so igloo balances bird's beardlessness. for example
15:56:13 <Igloo> Eh?
15:56:16 <ehird> its like the erdos count
15:56:18 <ehird> (gens)
15:56:19 <ehird> :)
15:56:19 <jamii> Its well known that beards are essential for a succesful language. Is the future of haskell in doubt? Maybe I should stop shaving, do my part
15:56:24 <ehird> i'm like 500th gen tho
15:56:30 <dons> well, as long as the founders were well bearded
15:56:39 <Igloo> How can I balance the beardlessness of someone in a different generation to me?
15:56:39 <jamii> ehird: Typing from the womb?
15:56:56 <dons> Igloo: so you're an exception to the decreasing beardies trend
15:57:06 <ehird> jamii: yeh :q
15:57:09 <dons> the bird branch of the family is going the opposite way
15:57:15 <Igloo> I see
15:57:17 <ehird> but seriously i'm probably the youngest person here
15:57:20 <IsoPallo> I'm remaining Caitiff as I have not been taught by anyone...
15:57:21 <ehird> that's a rather wild guess though ;)
15:57:22 <dons> ehird: i'd not be so sure.
15:57:27 <dons> we've some mid-teen hackers
15:57:38 <ehird> dons: that's pretty close to the mark.
15:57:41 <ddarius> ehird: You'd be surprised.
15:57:53 <solrize_> i know a hippie lisp hacker who told me he was always impressed by how normal and well-dressed the staticly-typed FPL community was.
15:57:57 <ehird> ddarius: prove me wrong :-)
15:58:05 <MyCatVerbs> solrize_: damn him.
15:58:08 <solrize_> hee
15:58:14 <dons> solrize_: Europe versus the US :)
15:58:23 <solrize_> dons, that could explain it :)
15:58:26 * Igloo has a theory that dons is actually prepubescent. Hence his inability to grow the beard he craves.
15:58:26 <MyCatVerbs> solrize_: I should start hacking on GHC, and grow a beard.
15:58:34 <ddarius> timthelion was 14(?) (if not 14 he was younger)
15:58:35 <dons> also, lisp is more west coasty, isn't it? while over on the east coast, the CMU guys dress *sharp*
15:58:56 <MyCatVerbs> Igloo: now that's mean.
15:58:56 <ehird> ddarius: suprise me :)
15:58:56 * solrize_ thought lisp-hackerism was an MIT thing
15:58:57 <dons> Igloo: oh but there you're wrong, i've had some serious beards over the years :)
15:59:06 <Igloo> dons: JPG!
15:59:15 * dons will have to hunt hard for this. undergrad days
15:59:25 <SamB> damnit, why did they have to use  in Agda's library... Windows isn't good about that character...
15:59:31 <thetallguy> dang, I drop in for a second and there's a brawl
15:59:40 <Vq^> dons: west coast of the ocean?
15:59:55 * jamii hits the tall guy with a chair
16:00:03 <ehird> ddarius sucks at suprising :)
16:00:11 <ddarius> So why wasn't Haskell more popular when I was a kid?
16:00:16 * thetallguy thinks jamii will live to regret that
16:00:27 <SamB> ddarius: because shapr hadn't yet made this channel?
16:00:34 <SamB> or taken it over or whatever
16:00:55 <ddarius> SamB: It didn't exist when he made it, but it existed before he made it.
16:01:07 <ygale> @slap jamii
16:01:08 <lambdabot> stop telling me what to do
16:01:13 <ygale> @slap jamii
16:01:13 * lambdabot secretly deletes jamii's source code
16:01:20 * SamB lols
16:01:23 <Vq^> heh
16:01:42 <ddarius> We'll never be able to rebuild jamii now.
16:01:42 <jamii> lambdabot, how could you, I wrote that code for you
16:01:44 <SamB> speaking of which, some crazy person on the bus was saying O-M-G and L-O-L
16:01:59 <SamB> well, not quite crazy
16:02:02 <SamB> but silly
16:02:03 <ddarius> SamB: Did you punch him/her in the face?
16:02:03 <solrize_> omg, lol.
16:02:10 <ygale> SamB: accessibility module on their cell phone
16:02:12 <jamii> ddarius: Its alright, Im version controlled
16:02:37 <Vq^> SamB: tragic
16:02:50 <SamB> I think she thought it was somehow funny
16:03:01 <ddarius> SamB: Did you punch her in the face?
16:03:05 <SamB> no
16:03:09 <solrize_> http://www.flickr.com/photos/22009051@N05/2437351739/  faq
16:03:10 <lambdabot> Title: Best FAQ ever on Flickr - Photo Sharing!
16:03:13 <ddarius> SamB: Do that next time.
16:03:19 <SamB> it's not considered good bus-riding protocol to punch fellow passengers in the face
16:03:24 <ehird> ddarius: So, if I'll be so suprised, how old's the youngest person here that you know of?
16:03:28 <jamii> SamB: It should be a hanging offence. We need LOL police
16:03:29 <SamB> if you do that, they might think you are one of the crazies...
16:03:34 <Runaro> foldl (\k a b -> k (f a b)) id as b0
16:03:35 <Vq^> SamB: what kind of country are you from? :)
16:03:47 <ddarius> SamB: I think most people would understand and empathize.
16:03:55 <SamB> also, one of the crazies might get mad!
16:03:57 <Runaro> How does the above parse?
16:03:58 <ddarius> ehird: I think the youngest might have been 11 (that I know of)
16:04:14 <ehird> ddarius: Heh. What was the situation with that?
16:04:25 <ygale> @type  foldl (\k a b -> k (f a b)) id as b0
16:04:27 <lambdabot> Not in scope: `as'
16:04:27 <lambdabot> Not in scope: `b0'
16:04:34 <Runaro> foldl f id as b0
16:04:43 <ygale> @type \as b0 ->  foldl (\k a b -> k (f a b)) id as b0
16:04:44 <Runaro> what gets passed to foldl?
16:04:45 <lambdabot> forall b a. (SimpleReflect.FromExpr a, Show a, Show b) => [b] -> a -> a
16:04:49 <mauke> Runaro: (((foldl f) id) as) b0
16:04:59 <Runaro> oh!
16:05:14 <mauke> > ((+) 1) 2
16:05:16 <lambdabot>  3
16:05:48 <ygale> > (+) 1 2
16:05:49 <lambdabot>  3
16:05:54 <ddarius> Anyone have flickl.com?
16:06:01 <mauke> no :(
16:06:13 <Runaro> :type (((foldl (+)) id) [])
16:06:16 <ehird> ddarius: Some kind of ... actually, I have no idea.
16:06:20 <Runaro> ?type (((foldl (+)) id) [])
16:06:22 <lambdabot> forall a. (Num (a -> a)) => a -> a
16:06:27 <Runaro> clever
16:07:33 <ygale> Runaro: a -> a doesn't have a Num instance, so you can't do much with that.
16:07:40 <dmwit> I don't think (foldl (+) id []) does what you think it does.
16:08:00 <dmwit> Perhaps you wanted (foldl (+) 0) ?
16:08:08 <dmwit> :t foldl (+) 0
16:08:11 <lambdabot> forall a. (Num a) => [a] -> a
16:08:40 <ygale> @type foldl (.) id
16:08:41 <lambdabot> forall a. [a -> a] -> a -> a
16:08:52 <dmwit> foldl (+) id [] === (id +)
16:09:06 <dmwit> err, no
16:09:17 <dmwit> foldl (+) id [] === id, but type-restricted in a bad way
16:09:40 <ygale> i.e., essentially unusable for anything
16:10:05 <qwr> > foldl (.) id [(+1),(*2)] 3
16:10:06 <lambdabot>  7
16:18:04 <wolverian>  /aw
16:18:12 <wolverian> fail :(
16:19:11 <edwardk> Is there a way to lie to cabal install to get it to let you install a package even when you don't meet the build dependencies?
16:19:56 <edwardk> i.e. if it says ghc < 6.9 but you have 6.9 installed and want to try anyways
16:20:21 <Lemmih> edwardk: Edit the .cabal file?
16:20:30 <edwardk> lemmih: fair nuff
16:20:58 <edwardk> hrmm, you can't even cabal fetch when you don't meet the dependencies?
16:22:33 <ehird> ddarius died :-)
16:31:54 <dcoutts> edwardk: well in general it will not know what to fetch
16:32:18 <edwardk> dcoutts: fair nuff
16:32:30 <dcoutts> edwardk: we could make it fetch the things you ask for explicitly but if we don't know what it'll depend on then we cannot fetch those
16:32:49 <dcoutts> edwardk: feel free to file a feature request about that one
16:33:44 <edwardk> dcoutts: mostly trying to understand the system. i'm not nearly as negative about the whole experience as i probably sound =)
16:37:08 <dcoutts> edwardk: keeping track of feature requests is useful
16:37:45 <dcoutts> edwardk: just because it behaves the way it does at the moment doesn't mean it's the most intuitive or expected behaviour
16:37:51 <edwardk> *nods*
16:38:11 <edwardk> thats one of the reasons why i bothered to hop on channel in frustration rather than slink away a disaffected user
16:38:12 <edwardk> =)
16:38:15 <dcoutts> edwardk: so we do value your feature requests, even if it's just "I did this, I expected it to do this but it did that"
16:38:24 <dcoutts> edwardk: thanks :-)
16:38:33 <dcoutts> edwardk: I'll fix the problem you ran into
16:39:05 <gwern> oh my god. why is this SAT repo still being cloned by git? how many patches did the fellow go through? o.0
16:39:36 <gwern> output from git has actually totally filled up my terminal's scrollback!
16:40:54 <gwern> 'Note, however, that even here there is no free lunch -- while this algorithm is O(n) in time, permuting the list requires that we consume O(n log n) bits of quantum randomness.'
16:43:23 <gwern> (in reference to a sorting algorithm where you randomly permute the list and destroy the universe if not sorted)
16:44:08 <mauke> yeah, quantum bogosort
16:47:39 <solrize_> haha.  scott aaronson?
16:49:14 <ehird> we nede 'quantum molecular double-bosomsort'
16:49:19 <ehird> which is a metaphysical sort
16:49:23 <ehird> involving molecules
16:49:24 <ehird> and bosoms
16:49:28 <ehird> and is O() time
16:49:38 <dmwit> O() time?
16:49:50 <dmwit> "This algorithm can only be truly understood while the reader is high."
16:51:02 <dmwit> Is there a better way to spell (and .) . sequence?
16:51:16 <MathHat> ?pl (and .) . sequence
16:51:16 <ehird> yes, O() tim
16:51:16 <lambdabot> (and .) . sequence
16:51:16 <ehird> e
16:51:24 <ehird> O(                         )
16:51:27 <ehird> understand the zen of empty-O
16:51:33 <dmwit> :t (and .) . sequence
16:51:34 <lambdabot> forall (m :: * -> *). (Monad m, Functor m) => [m Bool] -> m Bool
16:51:58 <dmwit> Errr, maybe I wrote that wrong.
16:52:13 <dmwit> :t \ps -> and . sequence ps
16:52:15 <lambdabot> forall (f :: * -> *). (Functor f, Monad f) => [f Bool] -> f Bool
16:52:40 <dmwit> Oh, (.) :: Functor f => (a -> b) -> (f a -> f b). heh
16:54:01 <dmwit> :t all
16:54:01 <ehird> dmwit: only in lambdabot
16:54:03 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
16:54:08 <ehird> lambdabot is opinionated :-)
16:54:11 <ehird> e.g.
16:54:18 <ehird> > let pred (n+1) = n in pred 3
16:54:18 <lambdabot>  Parse error in pattern at "in" (column 20)
16:54:24 <dmwit> ehird: Yeah, I know.  From time to time, I just forget that generalization exists here.
16:54:26 <ehird> takes the right stance on n+k pattersn to
16:54:26 <ehird> o
16:54:42 <ehird> dmwit: If it could display Monad as a subclass of Functor somehow it probably would ;)
16:54:59 <dmwit> lambdabot uses Haskell'. ;-)
16:55:23 <lament> no, it's got nothing to do with Haskell'
16:55:24 <dmwit> :t \x -> all ($ x)
16:55:26 <lambdabot> forall a. a -> [a -> Bool] -> Bool
16:55:27 <lament> it's Caskell
16:55:58 <dmwit> :t all . ($)
16:56:00 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
16:56:11 <dmwit> :t all . flip ($)
16:56:13 <lambdabot> forall a. a -> [a -> Bool] -> Bool
16:57:46 <dmwit> :t ap (==) nub
16:57:47 <lambdabot> forall a. (Eq a) => [a] -> Bool
16:58:29 <dmwit> I think I am finally getting to the point where I grok "ap".
17:04:27 <ddarius> dmwit: liftM2 is easy to understand, ap is just liftM2 ($)
17:09:20 <dmwit> true
17:39:49 <sclv> ?seen SamB
17:39:49 <lambdabot> SamB is in #ghc, #perl6, #xmonad, #haskell, #haskell-blah and #darcs. I last heard SamB speak 1h 35m 54s ago.
17:40:12 <sclv> ?tell SamB hah! solved the generic map serialization, and all it took was one unsafeCoerce :-)
17:40:13 <lambdabot> Consider it noted.
17:43:54 <sclv> ?hoogle Any
17:43:55 <lambdabot> Data.Monoid.Any :: newtype Any
17:43:55 <lambdabot> Data.Monoid.Any :: Bool -> Any
17:43:55 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
17:46:27 <dlomsak> lambdabot seems pretty great
17:48:20 <ddarius> ?faq Can Haskell make you great?
17:48:20 <lambdabot> The answer is: Yes! Haskell can do that.
17:48:36 <lament> ?faq Can Haskell ruin your life?
17:48:36 <lambdabot> The answer is: Yes! Haskell can do that.
17:49:47 <mauke> ?faq Can Haskell mine for fish?!
17:49:48 <lambdabot> The answer is: Yes! Haskell can do that.
17:52:07 <sclv> ?tell SamB oh wait, the unsafeCoerce reall y is unsafe :-(
17:52:08 <lambdabot> Consider it noted.
17:52:22 <dlomsak> I have a little question for you folks. I am an MLer who is most of the way through YAHT and I am finding Haskell very enjoyable. Is there any one location that breaks down some of the internals of the language like how lists are implemented or how thunks are used, etc?
17:53:37 <mauke> data [a] = [] | a : [a]
17:53:42 <mauke> ^ list implementation
17:53:50 <dlomsak> I like to know what's going on inside of a language so I can avoid doing things that are horribly inefficient
17:53:58 <SamB> sclv: ... you forgot the proof obligation, eh?
17:53:58 <ddarius> That would be implementation dependent.  There are papers on specific implementations (primarily GHC), plus an (old) book on implementing functional languages in general.
17:53:58 <lambdabot> SamB: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:54:03 <SamB> @messages
17:54:03 <lambdabot> sclv said 13m 51s ago: hah! solved the generic map serialization, and all it took was one unsafeCoerce :-)
17:54:03 <lambdabot> sclv said 1m 56s ago: oh wait, the unsafeCoerce reall y is unsafe :-(
17:54:18 <dons> yeah, http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts
17:54:19 <lambdabot> Title: Commentary/Rts - GHC - Trac
17:54:26 <sclv> it seemed to work at first, but then... kaboom.
17:54:27 <dons> dlomsak: ^
17:54:37 <dlomsak> thanks for the link
17:54:43 <sclv> so close and so far.
17:55:14 <sclv> did you blog about this problem somewhere, or was it just posts to haskell-cafe... I sort of remember it now?
17:56:12 <sclv> my failed try: http://hpaste.org/7404
17:58:08 <sclv> the problem isn't just type safety, its really that we do need to "bake in" the ord dictionary somewhere. sigh.
18:08:44 <Woo> I have a type [(Char,Int)]. I want to supply a Character, and have a functionr eturn the integer paired up with it. Is there a handy function to do this?
18:09:24 <lament> yes.
18:09:36 <Woo> Which function is that, lament
18:09:44 <lament> :t lookup
18:09:46 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
18:09:50 <Woo> you'remagic
18:10:44 <Woo> :t flip
18:10:46 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
18:12:36 <mauke> @hoogle [(Char,Int)] -> Char -> Int
18:12:37 <lambdabot> No matches, try a more general search
18:12:46 <mauke> @hoogle [(a,b)] -> a -> b
18:12:47 <lambdabot> No matches, try a more general search
18:12:53 <mauke> :(
18:36:38 <slava> @src mapM
18:36:39 <lambdabot> mapM f as = sequence (map f as)
18:36:45 <slava> @src sequence
18:36:45 <lambdabot> sequence []     = return []
18:36:45 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
18:36:45 <lambdabot> --OR
18:36:45 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
18:42:51 <TomMD> Not sure if there is any interest, but I've proposed a library change (Trac 2261).  I'll send an e-mail to libraries at haskell as soon as it stops rejecting my e-mails.
18:43:27 <TomMD> Basically, I think Errno should be an instance of Show, Ord.  Perhaps an instance of other classes as well?
18:43:28 <dolio> It's good to know that the most constructive thing most people can come up with in reply to an article about Coq is a pun/complaint about its name sounding like a synonym for 'penis'.
18:43:29 <lambdabot> dolio: You have 1 new message. '/msg lambdabot @messages' to read it.
18:43:55 <TomMD> dolio: I've never heard that - perhaps my circle is just too limited.
18:44:28 <dolio> Your group must not be well represented on reddit. :)
18:44:44 <dolio> @seen edwardk
18:44:44 <lambdabot> edwardk is in #haskell. I last heard edwardk speak 2h 6m 32s ago.
18:44:53 <TomMD> I read reddit, but that I've never bothered to read comments on Coq.
18:45:41 <TomMD> I'll stick with talking to Mathematicians about Coq.  Programmers can be included when the conversation shifts to Haskell.
18:46:35 <dons> psnively wrote (the only?) useful comment.
18:46:45 <dolio> More or less.
18:47:05 <slava> hi dons
18:47:11 <dons> heya slava. how's code?
18:47:12 <dolio> He actually wrote serious responses to some of the puns, too.
18:47:35 <slava> dons: i got my monads working. i'll revisit it later on to add mapM and a few other HOFs.
18:47:57 <dons> sweet.
18:48:28 <dons> so now you can get applicatives (for, say, parsers) (they're simpler)
18:48:54 <dons> did you get a chance to peek at the arrays post i made? that sort of summarises where the double-array solutions are going to come from
18:49:04 <slava> not yet, sorry
18:49:07 <dolio> @tell edwardk You should make an announcement of your replacement, considering how vastly different it is from the one I released a week or so ago, on the off chance that someone besides you or I cares.
18:49:08 <lambdabot> Consider it noted.
18:52:28 <lament> there's a replacement edwardk?
18:52:47 <dolio> He whipped up a much more extensive replacement of category-extras.
18:55:33 <ddarius> lament's pun fails horribly.
18:55:59 <edwardk> dolio:will do
18:55:59 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
18:56:33 <lament> without failing, there's no success
18:57:14 <edwardk> dolio: i announced it somewhat indirectly with my latest post
18:57:39 <dolio> Yeah, but I'm not sure all the people on haskell@ or haskell-cafe read your blog. :)
18:58:00 <edwardk> dolio: heh fair nuff. not quite sure what subset of those read planet-haskell
19:01:45 <edwardk> dolio: heh i just realized quite the difference in breadth and depth between the two releases.
19:02:05 <dolio> Yeah, you have tons more stuff.
19:02:43 <edwardk> i still have a ton of instances to plug in to flesh it all out
19:02:48 <dolio> Now you just need to document it. :)
19:02:51 <edwardk> yeah
19:03:30 <edwardk> documenting, clean building under -Wall , SupplyT, and a pure Split comonad are i think my next major steps
19:04:05 <edwardk> and then starting a test suite of examples
19:04:31 <edwardk> but i figured i should at least get something on hackage so someone other than me can play with it
19:06:00 <edwardk> oh, and i want to do some more intelligent module exporting so you don't have to import the kitchen sink to do anything
19:06:11 <dolio> Should comonads be copointed?
19:06:22 <ddarius> They should be.
19:06:25 <edwardk> yes, all of them are, thats one of those sets of instances that should show up
19:06:36 <edwardk> same with pointed for the monads
19:06:54 <edwardk> that lets all the (co)pointed composition machinery work with real monads
19:07:17 <edwardk> i swear i'm just going to throw an issue tracker up somewhere
19:08:15 <edwardk> i'm also thinking indexed/parametered/higher order applicatives make sense
19:08:20 <edwardk> er parameterized
19:08:21 <dolio> Well, I meant more like, should it be 'class Copointed w => Comonad w where'.
19:08:43 <dolio> There's nothing you can do there for Monad.
19:08:45 <edwardk> dolio: i left it off because i can't do the same to monad, so i felt it was a little unfair =)
19:08:59 <dolio> Agda's standard libraries have indexed applicatives.
19:09:19 <edwardk> fair enough
19:09:23 <edwardk> then i'll add them
19:09:41 <dolio> Although they don't do anything with them, besides having them be related to indexed monads.
19:09:42 <edwardk> and i'll bite the bullet and add Copointed to Comonad
19:09:54 <edwardk> that will at least show me the instances i forgot =)
19:11:33 <dolio> Their indexed monads are weird, too. They index them with values, so you can essentially only have type indexed monads where the type is in an inductive family.
19:12:53 <orbitz> hellooooo
19:12:56 <dolio> Or, you could write a function : I -> Set, but that doesn't work very well for, say, that continuation monad.
19:15:56 <edwardk> @src ap
19:15:57 <lambdabot> ap = liftM2 id
19:21:01 <edwardk> the main problem with requiring pointed for applicative/monad and copointed for comonad is the amount of verbosity introduced to each case =/ and the fact that i can't "fix" the base monad so doing it for IxFunctor/IxPointed/IxApplicative/IxMonad for instance just makes the derivation of LiftIx/LowerIx a pain in the ass =)
19:21:43 <dolio> Well, it doesn't really bother me either way.
19:22:21 <edwardk> ideally i'd just fix monad, but i don't think anyone would use a library in which the standard library monads didn't work
19:22:38 <dolio> Yeah.
19:23:07 <edwardk> as it is i already make you trade in ErrorT to use some of the morphisms
19:23:57 <edwardk> (because i require any (Either a) to be a monad, not just ones  where a is an instance of Error)
19:24:13 <dolio> Yeah, well, ErrorT stinks. :)
19:24:46 <edwardk> nah it was a good trick
19:24:46 <dolio> I guess it's fail that's the problem, strictly speaking.
19:24:54 <edwardk> its fail that hurts, yeah
19:25:14 <edwardk> if fail was factored out then you could say your Either was an instance of MonadFail when its left side was an instance of Either
19:25:21 <edwardk> and the rest of the construction would work fine
19:25:54 <dolio> Monoid, you mean?
19:25:56 <dolio> Or Error?
19:26:11 <edwardk> er error/monoid take your pick
19:26:23 <dolio> Monoid throws away the string, I guess.
19:26:31 <dolio> Which is less than ideal.
19:26:49 <edwardk> would want it to be error i guess if you want to support fail
19:29:47 <slava> @src MonadPlus
19:29:47 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
19:32:10 <dons> http://en.wikibooks.org/wiki/Haskell/MonadPlus
19:32:33 <dons> note,
19:32:36 <dons> instance Monoid [a] where mempty  = []; mappend = (++)
19:33:17 <SamB> dons: what about the proof obligations?
19:33:27 <dons> won't somebody think of the proof obligations!
19:35:40 <slava> so MonadPlus replaces 'fail'?
19:36:15 <dolio> If only.
19:36:37 <SamB> no, that's MonadZero!
19:37:23 <dolio> MonadPlus has been around since the report, but for some reason they didn't put fail in there.
19:37:51 <dolio> In 1.4, there was separate MonadZero and MonadPlus, and pattern match failure used 'zero' from MonadZero.
19:38:16 <dolio> But in 98 they combined Zero with Plus, and put fail in Monad and used that for pattern match failure.
19:39:22 <SamB> in 1.7, I'm hoping they'll pull out MonadZero with fail and zero, and figure out how to say that fail and zero are essentially the same...
19:56:34 * SamB wonders how to establish a homomorphism between Data.List and Data.DifferenceList (in Agda2)
20:03:11 <SamB> huh, Agda has a funky sectioning syntax, but I guess it makes sense...
20:04:23 <dolio> It has one?
20:05:07 <SamB> isn't _++_ the full section of the "++" operator?
20:05:20 <newsham> hmm, how come this hackage package doesnt let you browse the API like other packages on hackage do?  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numeric-prelude-0.0.2
20:05:21 <lambdabot> http://tinyurl.com/56hsl3
20:05:22 <dolio> Oh, well, there is that.
20:06:01 <newsham> samb: its cool being able to define  if _ then _ else _
20:07:12 <dolio> I don't really consider that sectioning.
20:07:27 <newsham> oh, hmm.. haddock build failure i think
20:09:09 <ivanm> is there an easy way to reverse a Data.Map value? i.e. something that is Data.Map.Map k a -> Data.Map.Map a k ?
20:10:04 <dolio> No. Someone did write a Bimap module, I believe.
20:10:11 <ivanm> *nod*
20:10:31 <dolio> @hackage bimap
20:10:31 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bimap
20:10:36 <ivanm> it's not that big a deal... if I do end up needing it, I can always create it when I construct my original map (since the map itself doens't change)
20:12:11 <newsham> M.fromAscList $ map (\(a,b) -> (b,a)) $ M.toList  ?
20:13:28 <dolio> That's not a good idea.
20:13:54 <dolio> It assumes that the bs are sorted.
20:15:18 <newsham> err..  fromList/toList
20:15:51 <dolio> @type M.foldWithKey (flip M.insert) M.empty
20:15:52 <lambdabot> forall a k. (Ord a) => M.Map k a -> M.Map a k
20:22:45 <dancor> can i do   if null l then .. else let (x, xs) = (head l, tail l) in ..  a better way (can you use pattern matching not just for a function)
20:24:16 <sclv> omg! that's it!
20:24:24 <glguy> ( case l of [] -> ... ; (x:xs) -> ... )
20:24:25 <sclv> fromDistinctAscList! how did I miss that!?!
20:24:52 <glguy> oh.. I didn't see the (head l , tail l )
20:25:01 <glguy> err... nvm, I did :)
20:25:33 <sclv> SamB: Got it! :-)
20:26:27 <sclv> wow that took me way too long to do.
20:29:55 <dancor> is it just me or should break really be :: Maybe ([a], [a])  and not include the break-part
20:31:19 <bd_> :t break
20:31:21 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:33:28 <dolio> break f [] = Nothing?
20:33:44 <bos> does a newtyped type's constructor actually cause any allocation to occur when applied at runtime?
20:34:16 <sjanssen> bos: nope
20:34:28 <bos> i didn't think so.
20:34:52 <bos> i knew there was no actual constructor involved, but didn't know if the existing value might be copied with a different runtime representation or something.
20:34:58 <sjanssen> newtypes are erased after class desugaring, AFAIK
20:36:08 <bos> brilliant. i do a search for "newtype erased", and i get a wikipedia page about some japanese cartoon.
20:36:55 <dons> the report even guarantees they have the same runtime representation as the thing they wrap.
20:36:55 <bos> searching for "type erasure haskell" doesn't help.
20:37:21 <dons> and without runtime overhead.
20:37:22 <mxc2> @hoogle date
20:37:22 <lambdabot> System.Locale.dateTimeFmt :: TimeLocale -> String
20:37:22 <lambdabot> System.Locale.dateFmt :: TimeLocale -> String
20:37:22 <lambdabot> Data.Time.Calendar.OrdinalDate :: module
20:37:37 <dons> the report is surprisingly strong on this -- newtypes have to be compile time only artifacts
20:38:24 <ivanm> why surprisingly?
20:38:48 <TomMD> Is this true for single constructor data types as well?  Such an simplification rule should be simple enough.
20:38:59 <bos> usually details are left for implementations.
20:39:01 <bos> TomMD: no.
20:39:01 <dons> well, newtypes have unlifted constructors
20:40:08 <sjanssen> TomMD: consider the differences between "T undefined" where T is any of "data T = T ()", "data T = T !()" and "newtype T = T ()"
20:40:28 <bos> TomMD: the constructor for 'data' is always lifted. in other words, it can safely contain _|_ as an element.
20:40:35 <bos> s/the/a/
20:41:03 <TomMD> Yes, I see now.  Great fun!  You should write a book... ;-)
20:41:33 <bos> i'm writing about exactly this at the moment.
20:41:47 <mxc2> dons - real world haskell looks to be fantastic.  just want to thank you for it.  will buy it as soon as its out, even if the whole thing is online
20:41:54 <bos> but i don't want to introduce the word "lift", because it's too overloaded.
20:42:17 <dons> "wrap"?
20:42:27 <dons> "box" :)
20:42:28 <bos> functional programming already has lifting for abstracting into a different domain, lambda lifting for moving a function outside an expression, and lifted data.
20:42:41 <lament> mxc2: you can already buy it, you don't need to way!
20:42:44 <lament> er, wait
20:42:52 <bos> i've stuck with "lift" solely to refer to hoisting pure values into functorial and monadic contexts.
20:42:54 <dons> 'box' would be nicely confusing, as the constructor is strict (so can be unboxed)
20:43:10 <mxc2> yeah, but i can't get it yet.. i'm big into immediate gratification w/ purchases
20:43:14 <bos> i've stuck with wrap, and some worked examples in ghci to show the differences in pattern matching.
20:43:43 <bos> operational semantics explained via the command line, the stuff of which every hacker's knowledge is built.
20:44:18 <bos> dons: who wrote galois's little xml parser?
20:44:41 <dons> i think originally it was sigbjorn and andy gill, in some proportion.
20:44:55 <dons> there were apparently a few kicking around, from pre-cabal days
20:45:07 <bos> i assume it's not complete. are the bits it's missing documented?
20:45:16 <dons> hmm, possibly
20:45:18 <sclv> o man that map problem was ridiculously hard to solve.
20:45:50 <dons> sclv: did you want a BiMap ?
20:46:05 <bos> e.g. i assume it doesn't handle namespaces, and probably doesn't validate.
20:46:15 <dons> right.
20:46:20 <sclv> no -- this was just the issue of serializing/deserializing a map with generics.
20:46:28 <dons> sclv: oh right. yeah, its a hard problem.
20:46:37 <dons> xmonad does some funky type level description stuff
20:46:39 <sclv> and somehow the simple fromDistinctAscList solution escaped me forever.
20:46:41 <dons> used to have a Map of Dynamics
20:48:02 <sclv> http://hpaste.org/7404#a1
20:50:59 <edwardk> @src liftM2
20:50:59 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
20:51:13 <edwardk> @undo \f m1 m2 -> do { x1 <- m1; x2 <- m2; return (f x1 x2) }
20:51:14 <lambdabot> \ f m1 m2 -> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
20:52:39 <thoughtpolice> dons: your little uvector lib looks neat. since it's a cleanup of some ndp-stuff can you try it out on 6.8.2 or is it HEAD-only?
20:53:39 <dons> thoughtpolice: works fine with 6.8.2
20:54:23 <dons> thoughtpolice: feedback welcome, i'm incrementally improving it on my morning commute
20:54:29 <mxc2> @hoogle calendartime
20:54:30 <lambdabot> System.Time.CalendarTime :: data CalendarTime
20:54:30 <lambdabot> System.Time.CalendarTime :: Int -> Month -> Int -> Int -> Int -> Int -> Integer -> Day -> Int -> String -> Int -> Bool -> CalendarTime
20:54:30 <lambdabot> System.Time.calendarTimeToString :: CalendarTime -> String
20:55:35 <thoughtpolice> dons: just a tiny replacement until ndp makes a stable release? :)
20:55:58 <dons> well, ndp is a huge thing. i can see this being a useful non-researchy solution
20:56:23 <dons> the whole auto-vectorisation and parallelisation of arrays is a longer term project
20:57:12 <thoughtpolice> good point.
21:00:38 <bos> dons: do you recall why you didn't use overlapping instances in your json library?
21:00:54 <dons> iavor is against them. :)
21:00:58 <dons> he's old school
21:01:18 <dons> i wrote it to use overlapping instances, originally
21:01:46 <bos> ok.
21:02:48 * ddarius is against them as well.
21:02:52 <bos> because it's hard to look at the newtype wrestling you have to go through otherwise through the eyes of happiness and joy.
21:03:01 <dons> hah
21:03:06 <dons> i'll use that.
21:03:15 <bos> "yes, you're casting stuff like crazy, but all this extra work is, er, good for your fingers."
21:03:43 <dons> types are good for your soul.
21:03:56 <bos> ddarius: why?
21:03:59 <Pseudonym> Types are good for your sanity.
21:04:19 <Pseudonym> And also to justify your high salary.
21:04:20 <dons> Pseudonym: heh, i /wasn't/ suggesting using incoherent instances :)
21:04:24 <Pseudonym> :-)
21:04:51 <ddarius> bos: I don't think the story for them is clean enough.
21:04:53 * dons has seen the best minds of his generation lost to the abuse of types
21:04:55 <bos> i think actually not using types is a justification for a high salary, because you'll spend so many more hours in the office.
21:05:22 <Pseudonym> Actually, using types makes your time more effectively used.
21:05:28 <bos> ddarius: not clean enough, in what manner?
21:05:38 <bos> Pseudonym: indeed.
21:05:39 <Pseudonym> If it's just hours in the office, well, let's just say I know how I'd initialise a 10,000 element array.
21:06:28 <bos> there is after all a reason i'm writing a haskell book, and not a python book. and it's not the smaller amount of competition :-)
21:07:24 <Pseudonym> It's for those big royalty bucks.
21:07:51 <bos> i'm going to buy my own private island with my third of the proceedings.
21:08:16 <bos> once i've fed the hungry, and housed the homeless, and cured all disease.
21:08:20 <dons> what with the strength of the dollar and all
21:09:27 <ivanm> bos: what, from all those sales to 1st year uni students who will probably never read it? :p
21:09:29 <bos> ouch. don't remind me about that.
21:09:49 <ivanm> heh.... why not?
21:09:56 <bos> ivanm: actually, i was responding to dons.
21:10:04 <ivanm> ahhhh
21:10:07 <roconnor> @go 1 EUR in USD
21:10:08 <bos> i heartily encourage uni students to buy the book.
21:10:08 <lambdabot> http://www.x-rates.com/d/USD/EUR/graph120.html
21:10:09 <lambdabot> Title: Exchange Rates Graph (Euro, American Dollar)
21:10:20 <dons> hey, sales to europe should be fine.
21:10:38 <ivanm> bos: yes, but you're biased!
21:10:41 <bos> i don't care whether they read it or use it to prop their bedroom doors open, provided they buy new copies from a non-discounting retailer.
21:11:16 <bos> i think the book will also be useful to steady wobbly tables, and possibly as a projectile weapon.
21:11:33 <bos> meanwhile, you can learn about monads and that stuff.
21:11:46 <dons> i plan on distributing copies to the needy to fight off ruby programmers with
21:12:00 <bos> i plan to distribute copies to the nerdy.
21:12:15 <dons> :)
21:13:58 <ivanm> heh
21:14:13 <ivanm> bos: why a non-discounting one? so you getz more coinz? :p
21:14:51 <bos> ivanm: precise-a-mundo.
21:15:42 <dons> you don't get marlon brando's island with discounts
21:15:48 * ivanm stops printing the draft chapters
21:16:08 <dons> ivanm: just make sure you comment on any errors or omissions :)
21:17:21 <ivanm> heh
21:17:28 <ivanm> tbh, I haven't been following it that much
21:17:58 <newsham> ?tick eurusd=x
21:17:59 <lambdabot> EURUSD=X: 1.5469 N/A - @ 5/5/2008 12:10am
21:20:07 <roconnor> I remember when people (reddit?) was saying that it would be the end of the world if the euro reached $1.23
21:20:45 <dolio> I'd recommend not listening to most people on reddit.
21:20:54 <roconnor> I didn't :)
21:21:13 <roconnor> *sigh*
21:21:20 <roconnor> why is the internet full of crazies?
21:21:23 <newsham> > 1.5469 == 1.23
21:21:24 <lambdabot>  False
21:21:43 <ivanm> roconnor: oh? so the apocalypse is now being heralded by currency fluctuations and _not_ the four horsemen?
21:22:00 <roconnor> newsham: I don't think you are interpreting "reached" liberally enough.
21:22:24 <newsham> apocalypse averted when we skipped right by $1.23
21:22:25 <roconnor> ivanm: well, maybe they didn't say the end of the world.
21:22:37 <roconnor> ivanm: they said something about everyone dumping the US dollar at that point.
21:22:42 <dolio> Has Sam Neill risen to power yet?
21:25:38 <dolio> With his army of killer boy scouts?
21:26:22 <ivanm> not that I've noticed
21:26:34 <ivanm> the scouts here appear to be having too much fun
21:26:36 <gwern> roconnor: well, people do seem to be dumping the dollar
21:26:51 <roconnor> gwern: not really in a panic
21:26:54 * gwern offers as proof the observation that the dollar doesn't seem likely to recover soon
21:28:03 <gwern> mm. the panic predictions may've been wrong, but the substance true. at the very least, there seems to have been a permanent shift away from dollars
21:28:13 <gwern> interesting times, anyway
21:35:03 <newsham> america has racked up 9trillion dollars in debt, has a large trade deficit, has repeatedly lowered interest rates despite high energy and food inflation
21:47:36 <cjb> the dollar's doing better against the British pound than it was 5 months ago, so there are plenty of currencies tanking..
21:49:13 <newsham> gbp was $1.75 in 2006.  it wasnt that much higher than it is today for most of 2007
21:49:38 <newsham> meanwhile AUD, EUR and CAD have gained tremendously against the dollar
21:49:45 <cjb> yeah.
21:50:07 <newsham> also GBP pays 4.5% on their cash,  we're payng a mere 3%?
21:50:10 <newsham> ?tick swvxx
21:50:11 <lambdabot> SWVXX: 2.51% N/A - @ 5/2/2008 6:02pm
21:50:13 <newsham> 2.5% now.
21:50:30 * cjb has his savings in GBP, and wishes the dollar would tank some more :)
21:50:43 <newsham> i've got some of my cash in gbp as well.
21:50:48 <cjb> although even if it did, I guess I'd keep them in the 5% account they're in in the UK.  Hm.
21:50:57 <roconnor> 3%, you wish. :D
21:52:01 <cjb> isn't it 2.0% now?
21:52:20 <cjb> http://news.bbc.co.uk/2/hi/business/7376060.stm
21:52:21 <lambdabot> Title: BBC NEWS | Business | Further cut in US interest rates
21:53:20 <roconnor> I've been trying to understand what it means for the prime rate to be below inflation.
21:53:25 <newsham> ?tick swgxx
21:53:25 <roconnor> but perhaps it doesn't mean anything in particular.
21:53:26 <lambdabot> SWGXX: 1.77% N/A - @ 5/2/2008 6:02pm
21:53:42 <newsham> yah, <2% for govt, but you can still get about 2.5%
21:54:26 <newsham> roconnor: it means that if you hold money in the bank its worth less next year than it is this year.
21:54:34 <newsham> depreciating asset.
21:54:38 <newsham> btw, this is prob -blah :)
21:55:15 <visof> Good morning
21:58:43 <allbery_b> of course, in reality it's been there for a long time --- US inflation figures have been systematically under-reported
21:58:50 <allbery_b> for several decades
22:00:02 <newsham> another great reason to invest america!  our books are never undercooked
22:08:15 <visof> i have an Algorithm in a text
22:08:32 <visof> i need to understand how is it working?
22:09:31 <visof> a segment [1;3] contain all natural numbers between 1 and 3
22:10:12 <visof> {[0;1], [1;2], [1;3]} is a multi-set
22:10:40 <visof> is equal {{0,1}, {1,2},{1,2,3}}
22:11:01 <visof> and the Algorithm is:
22:11:17 <Cale> That wouldn't be a multiset, it would just be an ordinary set of sets, wouldn't it?
22:12:04 <visof> okay Cale
22:12:17 <visof> brb
22:12:41 <GrayShade> is it normal for a program to use about four times more memory when it is compiled from separate modules?
22:13:12 <Cale> It could, because certain optimisations might become impossible.
22:13:44 <visof> Cale follow?
22:13:57 <Cale> what?
22:14:05 <bd_> Cale: I thought ghc embeds enough information to inline functions in the .hi files?
22:14:58 <visof> the Algorithm is:
22:15:18 <visof> - take the segment with the highest end (if there are multiple segments having the same highest end, take the shortest)
22:15:20 <Cale> It does some cross-module optimisation, but from what I understand, not everything.
22:15:32 <bd_> hmmm
22:15:35 <visof> - take a next segment, which ends one position before the previous one, and which starts one or more positions before the privious one, if there are multiple choices take the shortest one
22:15:49 <visof> - repeat the 2nd step as long as you find new segments
22:15:59 <visof> - cut all the segments you found by one element at the end, and form a new segment out of the "cutted" ends
22:16:05 <visof> this is
22:16:12 <Cale> visof: What's the goal here?
22:16:18 <bd_> I suppose that makes sense - you don't want a ghc --make update of a small number of files to use more memory&time than catting everything into one file
22:16:36 <GrayShade> and if i write f <* g instead of r <- f; g; return r; in the trivial definition of Applicative for monads? shouldn't they be reduced to the same code?
22:16:53 <visof> apply the Algorthim to {[0;1],[1;2],[1;3]}
22:17:19 <Cale> GrayShade: Unless the code is polymorphic...
22:17:22 <visof> i want to know how is it working?
22:17:52 <visof> i can't understand the steps also the second step in particular
22:17:56 <prb> darcs.net has appeared offline for me all day - others?
22:17:57 <GrayShade> Cale: it's not
22:20:06 <dons> GrayShade: hmm, interesting.
22:20:14 <dons> so, there are some optimisations that only work inside a single module.
22:20:25 <dons> and there are other issues (like inlining) that might explain a change like that
22:20:33 <dons> are you compiling everything in one shot, with -O2 ?
22:20:47 <GrayShade> i'm using ghc --make -O2
22:21:20 <dons> there's also the 'state hack' issue that comes up every now and then. zero-arity cafs getting duplicated
22:21:42 <dons> oh, not CAFs, actually, but functions written in a particular way. there's a ticket about that.
22:21:51 <dons> but -- is the code small enough to boil it down to a test case?
22:21:56 <dons> maybe do some profiling too,
22:21:58 <GrayShade> does ghc inline functions from one module into functions in another?
22:22:02 <dons> yep
22:22:06 <Cale> visof: We can apply the algorithm step by step, but it would help if I knew what the algorithm was intended to do.
22:22:06 <dons> aggressively.
22:22:17 <dons> you can enable that explicitly by telling {-# INLINE foo #-} next to a function
22:22:21 <dons> otherwise it uses a cost heuristic
22:22:58 <GrayShade> i don't think the code is small enough
22:23:09 <dons> i'd try profiling it then.
22:23:12 <dons> that might help narrow things down
22:23:17 <dons> do you know how to do that?
22:23:23 <Cale> visof: I'm also not certain I completely understand what the steps mean individually.
22:23:58 <GrayShade> i've used the profiling options when trying to find out how could the program allocate 6 gb of memory when it's not doing too much
22:24:02 <GrayShade> but without success
22:24:22 <Cale> visof: Specifically, I don't know what the 3rd step means...
22:24:24 <dons> 6 G?
22:24:35 <dons> GrayShade: so profiling is the key tool for debugging time and space issues.
22:24:41 <dons> ghc -O2 -prof -auto-all --make
22:24:46 <Cale> "cut all the segments you found by one element at the end" -- does this mean to drop the last element of each?
22:24:47 <GrayShade> did that
22:24:57 <dons> and then you can narrow that down to subexpressions
22:25:02 <dons> {-# SCC foo" 3-}
22:25:07 <dons> {-# SCC "foo" #-}
22:25:10 <GrayShade> best i could get was to move some local function that used expressions in its parent scope to top-level
22:25:23 <GrayShade> that reduced the allocation count by about 1.3 gb
22:25:35 <dons> so did you determine what functions were allocating the most?
22:25:39 <dons> also, what is your program doing?
22:25:52 <dons> what data types?
22:26:03 <GrayShade> it's a fib benchmark in a lisp-like interpreter that is only smart enough to run a fib :)
22:26:26 <dons> so one obvious thing could be a simple space leak. are you often updating a value, but not actually using it?
22:26:38 <dons> such a thing might sneak past the strictness analsyer
22:26:44 <GrayShade> ghc -hb says that i'm doing so
22:26:55 <GrayShade> er
22:27:03 <GrayShade> ^running the program with -hb
22:27:38 <dons> so you say there's much better memory behaviour when all code is in a single module?
22:28:09 <GrayShade> 6,312,036,684 vs 22,795,835,708 bytes
22:28:32 <dons> so that's the total allocation over the entire lifetime?
22:28:38 <conal> dons: i'm reading your "strict" blog post, and i'm confused about the optimizer output.  why do the wildcard cases come before the constant cases.
22:28:40 <GrayShade> yup
22:28:51 <dons> conal: ghc core gets printed like that for some reason.
22:29:11 <dons> conal: i wonder if its just a pretty printer issue (reverse alts) , or it has some non-haskell semantics
22:29:30 <conal> dons: hm.  yeah probably one or the other.  maybe just a printing bug.
22:29:32 <conal> thx.
22:29:45 <GrayShade> i'm looking at the two profiles but i don't know what makes the difference
22:29:48 <conal> dons: btw, wow!
22:29:58 <dons> conal: i note that it can clean up the code a bit, when all the defaults are grouped like that
22:30:24 <dons> GrayShade: can you narrow down to the subexpression with {-# SCC #-} pragmas on expressions?
22:30:27 <dons> conal: :)
22:30:34 <dons> ghc's getting smart
22:30:39 <conal> dons: and how!!
22:31:52 <conal> dons: "2 << 10" turned into "2 10" in google reader.
22:32:00 <GrayShade> (should lookup from Data.Map allocate memory?)
22:32:15 <dons> conal: oh heh
22:32:25 <dons> GrayShade: hmm, well, it wraps the failure case
22:33:10 <GrayShade> when it's compiled from separate modules almost 70% of the used memory comes from that
22:33:39 <dons> GrayShade: huh, that's interesting. can you produce a smaller test case?
22:33:48 <dons> i've wondered sometimes if Map needed a bit more help with inlining
22:34:04 <dons> GrayShade: if you can come up with a smaller test case, i'll poke around during the week
22:34:28 <GrayShade> how do i make ghc evaluate an expression multiple times?
22:34:58 <dons> turn it into a function taking () as a an argument?
22:36:17 <kosmikus> dons: if you count johan as 2nd gen, then nad and ulf norell are already 4th gen ...
22:36:58 <GrayShade> can i do f _ = "foo"; test = map (\x -> lookup s mymap) take 100000 $ repeat $ f () ?
22:37:53 <GrayShade> er
22:38:01 <dons> kosmikus: heh! too many phds! but yes, could be!
22:38:16 <GrayShade> f s = lookup s mymap; test = map f take 100000 $ repeat "foo" ?
23:04:26 <GrayShade> i can't seem to reproduce that high memory usage outside of my program
23:08:49 <mxc2> @hoogle readlines
23:08:49 <lambdabot> No matches found
23:08:52 <mxc2> oops
23:08:59 <mxc2> @hoogle IO
23:08:59 <lambdabot> System.IO :: module
23:09:00 <lambdabot> Data.Array.IO :: module
23:09:00 <lambdabot> Prelude.IO :: data IO a
23:09:28 <mxc2> @hoogle arg
23:09:28 <lambdabot> Distribution.Simple.Args :: type Args
23:09:28 <lambdabot> System.Console.GetOpt.ArgOrder :: data ArgOrder a
23:09:28 <lambdabot> System.Console.GetOpt.ArgDescr :: data ArgDescr a
23:09:34 <mxc2> @hoogle argv
23:09:34 <lambdabot> No matches found
23:09:46 <TSC> @type System.Environ.getArgs
23:09:49 <lambdabot> Couldn't find qualified module.
23:09:54 <TSC> @type System.Environment.getArgs
23:09:56 <lambdabot> IO [String]
23:10:03 <TSC> That's the one you want
23:43:46 <mxc2> @hoogle split
23:43:47 <lambdabot> Data.ByteString.split :: Word8 -> ByteString -> [ByteString]
23:43:47 <lambdabot> Data.Set.split :: Ord a => a -> Set a -> (Set a, Set a)
23:43:47 <lambdabot> Data.Map.split :: Ord k => k -> Map k a -> (Map k a, Map k a)
23:55:55 <visof> > sum[x^2 | x<- [1..100]]
23:56:09 <lambdabot>  338350
23:56:37 <visof> is this representing 1^2 + 2^2 + . . . 100^2 ??
23:56:51 <mauke> > sum[x^2 | x<- [1..100]] :: Expr
23:56:52 <lambdabot>  0 + 1 * 1 + 2 * 2 + 3 * 3 + 4 * 4 + 5 * 5 + 6 * 6 + 7 * 7 + 8 * 8 + 9 * 9 + ...
23:57:11 <visof> oh
23:57:43 <visof> but how?
23:57:54 <visof> x^2 , 2 is constant
23:57:55 <mauke> how what?
23:58:07 <visof> ah
23:58:09 <visof> okay
23:58:15 <visof> hehe
