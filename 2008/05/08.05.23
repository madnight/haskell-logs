00:00:01 <Vq^> vixey: we do
00:00:07 <vixey> (x:xs) ++ y := x : (xs ++ ys)
00:00:08 <olsner> sorry, have to keep trying to sneak in syntax extensions :)
00:00:28 <vixey> oh yeah but := is already a contructor :[
00:00:30 <sjanssen> vixey: why is that any better?
00:01:25 <vixey> sjanssen: to say which is a declaration and which is an equality
00:01:39 <sjanssen> where would we use = ?
00:04:03 <dolio> Clearly we should use ≡ for something.
00:04:40 <Vq^> unicode snowman for keyword!
00:05:28 <mahogny> maybe for raising an exception?
00:05:55 <mahogny> <3 as keyword as well. hm
00:17:25 <mxc> @hoogle fromIntegral
00:17:25 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
00:17:43 <Mitar> l
00:33:01 <augur> http://www.youtube.com/watch?v=kzniaKxMr2g&feature=related
00:33:02 <lambdabot> Title: YouTube - Lapis - James Whitney (1966)
00:33:20 <augur> everyone should check this out. :O
00:39:38 <nkdop> hi, is there any tutorial about installing haskell libraries in my /home and configuring them so ghc can find them? libghc6-cabal-dev is broken in ubuntu, and anyway most of the libraries doesn't exist in the repositories
00:41:02 <mahogny> I guess you compile ghc and give a prefix option to configure
00:41:14 * mahogny has never tried
00:42:48 <qebab> you never realise how life was before apt before you have a bunch of things to install that you can't get from it
00:42:50 <glguy> nkdop: when building libraries from source use:
00:42:57 <glguy> runghc Setup configure --prefix=$HOME --user
00:43:02 <glguy> and runghc Setup install --user
00:44:58 <nkdop> maybe I have to install ghc in /home like mahogny said, I tried what glguy but I get an error:
00:45:09 <nkdop> Unable to rename "/usr/lib/ghc-6.8.2/package.conf" to "/usr/lib/ghc-6.8.2/package.conf.old"
00:45:26 <glguy> to install GHC itself locally
00:45:32 <glguy> you'd do: ./configure --prefix=$HOME
00:46:14 <glguy> but installing GHC in your home directory isn't necessary to install libraries in your home directory
00:46:30 <sjanssen> nkdop: you ran exactly what glguy wrote?
00:46:34 <sjanssen> nkdop: including --user?
00:46:35 <nkdop> hum ok
00:46:47 <nkdop> oops, no sjanssen , I'm going to try
00:47:15 <nkdop> ok, now it runs, thanks
00:59:31 <heavensrevenge> hello?
00:59:39 <augur> hullo helloo!
01:00:13 <heavensrevenge> hi lol
01:00:23 <heavensrevenge> hows it in this room?
01:01:04 <nornagon> quick, something say something about the curry-howard isomorphism
01:01:14 <nornagon> er, someone say something, even.
01:01:16 <dfranke> Curry is yummy.
01:01:32 <augur> lamb curry is good.
01:01:35 <heavensrevenge> im not deep enough to know its use yet, so i cant
01:01:41 <augur> chicken tikka masala? delicious.
01:01:50 <nornagon> yum
01:01:56 <nornagon> i'm hungry now :(
01:02:00 <heavensrevenge> so haskell has a c->haskell converter right?
01:02:22 <heavensrevenge> anyone know how well it works?
01:02:40 <nornagon> pretty well
01:02:46 <nornagon> http://www.google.com/url?sa=t&ct=res&cd=1&url=http%3A%2F%2Fwww.cse.unsw.edu.au%2F~chak%2Fhaskell%2Fc2hs%2F&ei=FHo2SO3JJaCwgQPP27G9Bg&usg=AFQjCNGRW_C5nvOvAdVEZ62QM-Blu9mfbQ&sig2=2wnaKLKhxnU_ynw0KTI4RA
01:02:50 <lambdabot> Title: Manuel M T Chakravarty - C->Haskell, http://tinyurl.com/6fyfsn
01:02:50 <nornagon> ergh
01:03:01 <heavensrevenge> reason=if i can use an already OK MSN protocol specification in c, then my work is decreased
01:03:02 <nornagon> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
01:03:03 <lambdabot> Title: Manuel M T Chakravarty - C->Haskell
01:03:24 <nornagon> you could just bind to it using FFI stuff
01:03:26 <mahogny> c2hs. it has caveats
01:03:33 <nornagon> @where c2hs
01:03:33 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
01:03:35 <heavensrevenge> are text protocols done decently well in haskell?
01:03:38 <augur> manuel chakravarty?
01:03:42 <augur> spanish-indian? lol
01:03:46 <augur> thats a rare combination i think
01:03:53 <nornagon> german, i think
01:03:54 <heavensrevenge> ive already reached a conclusion haskell is my fav language, but im a newby
01:03:59 <augur> german! haha
01:04:01 <augur> crazy
01:04:03 <nornagon> at least, i know he speaks german :p
01:04:08 <augur> a german with a spanish-indian name
01:04:14 <heavensrevenge> lol
01:04:17 <laye> <- another newbie
01:04:18 <heavensrevenge> intrestin
01:04:24 <heavensrevenge> hey laye
01:04:37 <laye> hey ~
01:04:40 <mahogny> functional languages were as good as made for text protocols (good pattern matching and parser libs)
01:04:40 <heavensrevenge> my goal is to make a cross platform MSN client
01:04:54 <agentzh> wow
01:05:00 <heavensrevenge> awesome mahogny
01:05:06 * agentzh looks forward to that.
01:05:17 <mahogny> heavensrevenge, you can have a look at parsec and happy
01:05:21 * nornagon hugs bitlbee + irssi + ssh
01:05:22 <heavensrevenge> im pissed at all the other MSN clients
01:05:24 <mahogny> but they might be overkill
01:05:30 <heavensrevenge> the only good one is microsoft's
01:05:58 <heavensrevenge> parsec and happy eh?
01:06:03 <nornagon> the best thing about the M$ MSN client is that it's useless until you install MSN Plus
01:06:20 <nornagon> (the latter being a 3rd-party LD_PRELOAD style hack)
01:06:34 <heavensrevenge> lol meh, i dont really use msn plus, but ive tried it briefly
01:06:43 <mahogny> I like how they blocked files before such as... did it include mp3?
01:07:14 <heavensrevenge> well, a properly implemented p2pmsn should just be a straight p2p thing
01:07:31 <heavensrevenge> i believe
01:07:55 <heavensrevenge> most msn implementations have file transfers be routed through the msn servers themselves, which is DUMB and slow
01:08:29 <mahogny> means you don't have to bother about firewalls though
01:08:34 <heavensrevenge> id just create a damn bridge/tunnel from p2p and transfer directly
01:09:10 <heavensrevenge> lol then ill use port 80 as the transfr port, like basically every other file transfr
01:09:31 <mahogny> it doesn't help if you are proxied and lack a proper IP
01:09:50 <mahogny> too common. damn abuse of adress space
01:10:08 <heavensrevenge> id say a majority of users dont use a proxy...
01:10:31 <eek> heavensrevenge, I'd say you're mostly likely incorrect
01:10:34 <nornagon> my isp puts a transparent proxy in front of port 80
01:10:41 <heavensrevenge> oh u mean that
01:10:51 <mahogny> most workspaces proxy
01:10:55 <eek> heavensrevenge, but if you're correct, it's at least a very large minority that runs a proxy
01:10:57 <nornagon> that's likely several hundred thousand home users
01:10:59 <heavensrevenge> so its gotta be ip forwarding then?
01:11:10 <eek> heavensrevenge, large amounts of Asia is behind NAT at the ISP level
01:11:30 <eek> heavensrevenge, many (most?) home routing setups use NAT
01:11:37 <heavensrevenge> lol ok, that sunds important, but im not really seeing the problem yet
01:11:48 <eek> heavensrevenge, and most corporate stuff use a firewall or a NAT proxy
01:11:58 <mahogny> funny how the anti-piracy organizations doesn't try to get everyone to use NAT. it is a much bigger problem than any legislation could be :S
01:12:37 <eek> mahogny, well, with the UPnP stuff it often just works
01:12:50 <heavensrevenge> my lack of understanding firewall/NAT traversals are preventing me from seeing the problem of a decently formed ip tunnel
01:13:26 <mahogny> eek, hm? how do you mean?
01:13:37 <heavensrevenge> im a linux user of 8 years now so not playing with firewalls anymore so im rusty lol
01:14:11 <eek> heavensrevenge, there's no way to target the things behind a firewall/NAT (excepting UPnP, which I'll explain in a moment).  so it's OK for one end to be behind a NAT/firewall, but if both ends are behind it, it's not possible for them to communicate (usually)
01:14:11 <heavensrevenge> also i havent really seen the basics of protocol handeling yet
01:14:22 <heavensrevenge> i know my goal, ut i havent done too much past anything yet
01:14:35 <heavensrevenge> my 1st problem was to find the language i wanted to use
01:14:52 <eek> heavensrevenge, I'm a Unix user since the early 1990s and wrote parts of the firewall software for my Unix ;)
01:14:59 <mahogny> I know there 2-proxy problem is usually resolved by a third party. is that what upnp does?
01:15:05 <heavensrevenge> i JUST decided haskell to be my language less than a week ago, so you may be able to understand why im not too sure of the details yet
01:15:29 <eek> mahogny, effectively, UPnP is a protocol for talking to your NAT router and telling it to do port forwarding
01:15:36 <mahogny> I see
01:16:02 <mahogny> one less excuse for the ISPs to upgrade to IPv6 =)/(&%¤#
01:16:08 <eek> mahogny, it's supposed to do a bunch more (which I don't really remember what is), but as far as I understand that's in effect all UPnP is used for
01:16:58 <heavensrevenge> would... an ssh tunnel with the proper port, be an ok transfer method??
01:17:28 <mahogny> 2 proxy and neither computer can initiate a session. without upnp or something to break the wall
01:18:41 <heavensrevenge> was that directed @ me mahogny ?
01:18:45 <eek> heavensrevenge, you can't connect to an ssh server that's inside a NAT/firewall, so you'd have to have an external SSH server to be able to do that
01:18:45 <mahogny> yes
01:19:15 <quicksilver> unless a third party server agrees a port
01:19:23 <heavensrevenge> so basically, msn protocol itself wont do, i need to use UPnP aswell?
01:19:26 <quicksilver> which is how some of the IM stuff works.
01:19:55 <quicksilver> e.g. iChat audio is done by a third party (AIM) passing on port numbers.
01:19:55 <mahogny> heavensrevenge, well, you need to do some additional hacking. I think this is still in infant state
01:20:12 <heavensrevenge> i have to bend over a barrel and jimmyrig multiple encapsulating protocols to get the desired result?
01:20:20 <mahogny> it makes most sense to use the server in this case, yes
01:20:45 <mahogny> heavensrevenge, once you have a connection there is no more fuss involved
01:21:06 <heavensrevenge> but p2p is the oddball
01:21:39 <heavensrevenge> file transfers, since file transfers through the MSN servers as must do, die and dont work, or need to part the file and rebuild it on the other end
01:22:30 <heavensrevenge> my plan(a very primitive plan) was to just use the clients to set up an alternate transfer method directly between the 2 clients
01:22:44 <heavensrevenge> and have transfers basically as fast as the connection speed at the time can support
01:24:36 <heavensrevenge> could i... embed its own basic http server inside of the client, and then use port 80 transfers to do the dirtywork already set up for internet connectio in the 1st place?
01:25:32 <heavensrevenge> id rather plan and get this right, based on imput from knowagable and experienced people (you guys&gals) :P
01:27:37 <heavensrevenge> lol i am trying to figure out a good way here with considering the use case and design around the best possible solution
01:29:14 <heavensrevenge> any thoughts?
01:29:47 <boegel> heavensrevenge: are you a bot?
01:30:03 <heavensrevenge> lol really?? no im no bot
01:30:20 <boegel> heavensrevenge: prove it
01:30:20 <heavensrevenge> should i take that as a compliment or a warning?
01:30:27 <boegel> heavensrevenge: not sure :)
01:30:40 <heavensrevenge> ok, how the hell can i prove im not a bot
01:30:45 <heavensrevenge> oh
01:31:00 <heavensrevenge> tell me to read something off a specific web page or something
01:31:11 <heavensrevenge> or a pdf if it suits your fancy
01:31:34 <qwr> lol, YAB. ;)
01:31:34 <heavensrevenge> hard to actually find a way to prove im no machine, since AI is gettin quite good these days ;)
01:31:54 <heavensrevenge> im no bot!!
01:32:07 <heavensrevenge> im still tryin to figure out if thats a compiment or not
01:32:16 <heavensrevenge> *compliment
01:32:30 <heavensrevenge> AH!
01:32:31 <heavensrevenge> ok
01:32:48 <augur> heavensrevenge
01:32:54 <augur> you are now part of a turing test
01:32:56 <heavensrevenge> i DONT think bots can keep conversatin by varyingly hold a converstion at proper intervals
01:33:16 <sutats> We'll let the Turing test decide that, won't we?
01:33:19 <augur> how do we know you're not an intelligent, conscious AI?
01:33:21 <heavensrevenge> im not sure tho, ive never tried to make a bot or anything
01:33:32 <heavensrevenge> lmfao
01:33:34 <heavensrevenge> sure?
01:33:40 <heavensrevenge> ok how does a turng test actually work?
01:33:46 <boegel> heavensrevenge: if you can tell me what this is, and what color it is, you're free to go: http://trappist.elis.ugent.be/~kehoste/nice_little_doggie.jpg
01:34:09 <eek> heavensrevenge, optimal case: try first with direct transfer between the two machines on port 80 (try serving on both ends) (or other port if 80 is busy or blocked), then try UPnP to forward a port on each end, and if none of it work, go through servers - ideally, with a distributed set of servers to use
01:34:16 <augur> the turing test works like this:
01:34:21 <augur> you pretend you're actually human
01:34:33 <augur> and i try to figure out that you're not
01:34:59 <augur> ok but seriously
01:35:01 <augur> it works like this
01:35:04 <boegel> augur: no, I believe the thing is the real human doesn't know, and the test fails if he realizes something's up
01:35:07 <qwr> passing turing test won't prove you're not a bot. only, that you are human OR a well-written bot.
01:35:09 <heavensrevenge> its a slightly shiney, gay ass looking teapot, with an elephant crackled skin design, blush/green
01:35:15 <augur> you have a bunch of computers
01:35:17 <Plareplane> how do i use pattern guards inside case expressions
01:35:19 <boegel> augur: right? if he knows it might be a bot, it's not that hard to figure it out
01:35:25 <boegel> heavensrevenge: ok :)
01:35:28 <eek> augur, it's a brown, little doggie that shouldn't call the pot black ;)
01:35:29 <augur> and they're connected to chat apps
01:35:30 <heavensrevenge> lol
01:35:33 <augur> you talk to other people
01:35:35 <boegel> heavensrevenge: I'm glad you didn't say a "cute little doggie" :)
01:35:36 <augur> one or more of which might be human
01:35:43 <augur> and you have to figure out whose human and whose not
01:35:46 <augur> no restrictions
01:35:47 <augur> no nothing
01:35:52 <augur> you just talk
01:35:53 <vixey> > case Just 3 of Just x | odd x -> True | otherwise -> False ; Nothing -> False
01:35:54 <lambdabot>  True
01:36:00 <augur> over the chat app
01:36:08 <Vq^> boegel: that means it's a really good bot
01:36:15 <augur> and you're aware that you're trying to figure out whos a robot
01:36:18 <vixey> Plareplane: like this?
01:36:23 <boegel> Vq^: ^_^
01:36:27 <augur> there have been turing tests in the past
01:36:32 <augur> that dont tell the contestants
01:36:33 <augur> er
01:36:35 <augur> the judges
01:36:41 <augur> or that restrict the topic of conversation
01:36:42 <augur> or both
01:36:53 <ziman> a bot with a decent image recognition capability, at least :)
01:36:57 <augur> and ofcourse the people cant always tell
01:37:08 <augur> but in a free, unrestricted convo
01:37:09 <heavensrevenge> geez 1 sec, thats hard to follow
01:37:13 <augur> the bots stand out like a sore thumb
01:38:01 <augur> ofcourse, the turing test isnt an absolute test
01:38:20 <heavensrevenge> oh, so the range of comprehension?
01:38:22 <augur> firstly, it's not an absolute guarantee that who you're talking to is a conscious thinking being
01:38:30 <augur> its just that its a fairly good benchmark
01:38:42 <augur> daniel dennett discusses this at length in brainchildren
01:38:44 <augur> for instance
01:38:45 <augur> consider
01:39:00 <augur> if i said that a Great City is a city where
01:39:07 <augur> on any given day
01:39:10 <augur> I can
01:39:19 <Saizan> augur: isn't this more appropiate for #haskell-blah
01:39:20 <augur> 1: get a creme brulee at a nice french restaurant
01:39:21 <Saizan> ?
01:39:30 <augur> maybe, i dont know. the convo started here :P
01:39:31 <heavensrevenge> and couldnt you use longer sentences??
01:39:34 <vixey> good point
01:39:46 <augur> HR, to haskell-blah!
01:40:00 <heavensrevenge> hey i didnt start this lol
01:40:06 <augur> :p
01:40:10 <heavensrevenge> HE wanted to test me if i was a bot
01:40:21 <heavensrevenge> so he got into the whole turing test business
01:40:25 <augur> actually someone else did im just explaining the details of the turing test. :P
01:40:45 <heavensrevenge> true, sorry
01:40:53 <augur> cmon, come to blah
01:40:57 <augur> you'll learn some fascinating stuff
01:41:11 <heavensrevenge> ok, can anyone answer, if being called a bot(when not a bot) is an insult or a compilment//
01:41:18 <heavensrevenge> *??
01:41:36 <boegel> heavensrevenge: a compliment, so HUP, to #haskell-blah
01:41:46 <pejo> Seriously, please take this to -blah.
01:41:53 <heavensrevenge> i was there, but noone was talking, so i stated here lol
01:46:24 <quicksilver> I don't think it's terribly important if there aren't other people trying to discuss on-topic issues.
01:46:35 <quicksilver> but, if there are, it's best to keep the noise down a bit.
01:46:55 <quicksilver> after all, #haskell is famously a loquacracy
01:47:22 <vixey> @w80 only known use of that word is ...
01:47:23 <lambdabot> *** "only" wn "WordNet (r) 2.0"
01:47:23 <lambdabot> only
01:47:23 <lambdabot>      adj 1: being the only one; single and isolated from others; "the
01:47:23 <lambdabot>             lone doctor in the entire county"; "a lonesome pine";
01:47:23 <lambdabot>             "an only child"; "the sole heir"; "the sole example";
01:47:25 <lambdabot> [164 @more lines]
01:47:32 <vixey> oops lol
01:47:34 <vixey> @w80 loquacracy
01:47:34 <lambdabot> No match for "loquacracy".
01:47:56 <Plareplane> vixey, is it necessary to have the expression between case and of? how about before the |'s?  is there something like if-then-(elseif-then-...)-else?
01:48:07 <vixey> no there isn't
01:48:10 <vixey> you can write it though
01:48:16 <vixey> x --> y = (x,y)
01:48:28 <vixey> cond ((p,q):xs) = if p then q else cond xs
01:48:32 <vixey> then stuff like
01:48:36 <vixey> cond [ p 1 --> that
01:48:42 <vixey>      , q 1 --> something else
01:48:47 <vixey>      , otherwise --> ...
01:49:05 <quicksilver> vixey: if you google for loquacracy, you find #haskell
01:49:16 <vixey> quicksilver yeah .. you said it before :P
01:49:24 <quicksilver> vixey: so it's obviously the most famous example :)
01:49:55 <quicksilver> Plareplane: you can of course write if then else if then else if then else
01:50:04 <quicksilver> Plareplane: some people prefer case () of _ | ....
01:50:23 <Plareplane> quicksilver, i was using the latter, but the () and the _ seemed real ugly to me
01:51:11 <quicksilver> yeah, slightly.
01:51:25 <vixey> > let (-->) = (,) ; cond ((p,q):xs) = if p then q else cond xs ; go x = cond [ odd x --> 3*x+1 , otherwise --> x`div`2 ] in map go [1..]
01:51:26 <lambdabot> Unbalanced parentheses
01:51:32 <wjt> you can use « foo x y z = c where c | p = blah | q = bar | otherwise = baz » no?
01:51:33 <vixey> I don't think so
01:51:59 <vixey> lambdabot wrong...
01:52:27 <eek> quicksilver, loquacracy?
01:53:02 <quicksilver> eek: a system of government where the rule is granted to the people who talk the most.
01:53:10 <eek> quicksilver, oh.
01:53:12 <eek> *grin*
01:53:43 <augur> lambdabot is not wrong.
01:53:49 <augur> oh, yes it is.
01:53:52 <augur> look at that
01:54:03 <augur> thats painful
01:54:32 <quicksilver> if I was doing to do that trick, I'd probably do data Cond a = Bool :-> a
01:54:36 <quicksilver> use a constructor
01:54:42 <quicksilver> rather than tuples
01:54:57 <Plareplane> i was trying to do alternatives based on prefix of a string: case () of _ | Just x <- stripPrefix "foo" s -> something | Just x <- stripPrefix "bar" s -> somethingelse ...
01:54:59 <vixey> tuples are constructors :P
01:55:08 <quicksilver> use a fresh constructor ;)
01:55:23 <quicksilver> Plareplane: I'd do that with a dispatch table
01:55:35 <quicksilver> [("bar",something),
01:55:42 <quicksilver> ("foo",somethingelse)]
01:55:58 <quicksilver> you can kind of use lists of tuples as a way to build lightweight syntax
01:56:34 <Plareplane> hmm, that would do, thanks
01:56:53 <quicksilver> indeed, I've got something very like that in some code somewhere
01:57:13 <wjt> vixey: yes, you can use guards on a var in a where
01:57:21 <vixey> wjt what
01:57:27 <wjt> > let x | False = 3 | True = 6 in 3 * x
01:57:28 <lambdabot>  18
01:57:34 <vixey> oh cool
01:57:38 <vixey> I didn't know that
01:57:47 <wjt> i tend to do that when i want to use guards in the middle of a function
01:58:06 <vixey> that's really neat
01:58:14 <hpaste>  quicksilver pasted "stripPrefix style dispatch" at http://hpaste.org/7825
01:58:24 <quicksilver> Plareplane: that paste is very similar to what you're doing
01:58:30 <quicksilver> (only I didn't have stripPrefix available)
02:03:06 <augur> anyone know of any really good video lectures on computer science?
02:03:11 <augur> excluding SICP ofcourse
02:03:25 <vixey> why ofcourse?
02:03:39 <augur> because that ones obvious :p
02:03:45 <augur> and ive watched it already. u.u
02:04:04 <vixey> then you don't need to waste your time with other intros to computing science
02:04:17 <vixey> what do you want to know about?
02:05:50 <augur> aww but i like these
02:05:53 <augur> not just to learn
02:05:57 <augur> they're entertaining
02:06:01 <augur> im a knowledge sponge
02:06:09 <augur> even if i already know it :p
02:06:20 <augur> besides, SICP isnt so much on CS but about programs themselves
02:09:07 <Botje> augur: well, you could watch SimonPJ's intro to haskell
02:09:16 <augur> link?
02:09:27 <Botje> haskell.org, videos
02:10:07 <augur> 3q
02:12:06 <Baughn> > let a :: [forall a. (Num a, Show a) => a]; a = [2,3] in a
02:12:06 <lambdabot>  Parse error at "." (column 19)
02:12:39 <Baughn> ..right. No, but apparently ghci refuses to print this list, citing a lack of Show instance. Does this make sense?
02:13:21 <quicksilver> that's not even a type.
02:13:30 <Baughn> Obviously, I have rank-n types on
02:13:46 <quicksilver> forall a . Show a => a
02:13:51 <quicksilver> is not itself an instance of show :)
02:13:58 <quicksilver> although logically it could be.
02:14:17 <quicksilver> actually, no it couldn't.
02:14:32 <quicksilver> you have a list of things which can be coerced to *any* showable Num type.
02:14:38 <quicksilver> how could you make then instances of show?
02:14:48 <quicksilver> the way they show might depend which concrete type you chose.
02:15:43 <Baughn> Oh, I see. Okay, so how about if it's just Show a => a?
02:17:11 <Baughn> let a :: [forall a. (Show a) => a]; a = ([2,3] :: [Int]) <-- This fails too. Yes, I know it's a type mismatch, but I was sort of thinking I could stuff /any/ showable value in that list
02:17:38 <Baughn> ..wait a minute
02:18:06 <dolio> [forall a. (Show a) => a] means it's a list of things that can be instantiated to any type in Show.
02:18:27 <dolio> Which is... bottom only, I think.
02:18:51 <Baughn> ..unless someone writes instance Show a
02:19:06 <Baughn> But yes, I see the problem. How should I be writing it?
02:19:32 <dolio> No, because you nead to be able to do stuff like 'head l :: Int' and 'head l :: Char'.
02:19:46 <dolio> And the only thing that's both an Int and a Char is bottom.
02:20:17 <dolio> If you want a list of stuff-that's-in-Show, that's '[exists a. Show a => a]'.
02:20:34 <dolio> Which has to be wrapped in an existential datatype, because GHC doesn't have first-class existentials.
02:20:35 <quicksilver> Baughn: yes, you want an existential.
02:20:49 <Baughn> Tried that. No go. Right, one data coming up.
02:20:55 <quicksilver> data AnyShowable = Show a => MkAnyShowable a
02:21:15 <quicksilver> instance Show AnyShowable where show x = case x of MkAnyShowable a -> show a
02:21:26 <quicksilver> remember to use case to unwrap existentials
02:21:33 <quicksilver> if you use let, ghc's head will explode
02:21:36 <quicksilver> which is bad for your keyboard
02:22:09 <dolio> [forall a. Num a => a] is a valid type, and it can contain stuff like [2, 3, 4], since those literals are polymorphic.
02:22:28 <dolio> So it's a little more interesting than the Show example.
02:22:40 <quicksilver> of course you can encode existentials as higher ranked types
02:22:57 <quicksilver> [forall a b . (Show a -> b) -> b]
02:22:59 <quicksilver> is that right?
02:23:03 <quicksilver> somethign along those lines.
02:23:23 <dolio> forall b. [(forall a. Show a -> b) -> b] I think.
02:23:36 <Baughn> dolio: Yes, I saw that. Sadly Num doesn't seem to require Show. :/
02:23:39 <dolio> Maybe forall b inside, I'm not sure.
02:23:52 <Baughn> Well, the real scenario here is a bit different, and I do want exists.
02:24:16 <quicksilver> dolio: don't think it matters whether the be is inside or outside
02:24:20 <quicksilver> "the b"
02:25:24 <dolio> Well, they're different types, but I don't know if they'd work differently in practice.
02:25:47 <quicksilver> yeah, that's what I mean ;)
02:25:54 <quicksilver> it doesn't matter for this kind of use case.
02:26:24 <quicksilver> in fact, we can be stronger than that
02:26:37 <quicksilver> forall b . [T(b)] and [forall b . T(b)] are isomorphic
02:26:41 <quicksilver> for any type expression T.
02:26:49 <quicksilver> they're not the 'same' but they are isomorphic.
02:28:33 <dolio> Well, good enough, then.
02:29:53 <quicksilver> because you can instantiate universals as many times as you want.
02:31:42 <dolio> Is impredicative instantiation just turned on automatically with Rank2/NTypes?
02:33:53 <dolio> I guess it must be.
02:35:07 <quicksilver> I think so, yes.
02:35:21 <quicksilver> Having rank N types without it would be more surprising
02:39:37 <Saizan> to be picky it's [(forall a. Show a => a -> b) -> b)]
02:40:07 <Saizan> i.e. s/Show a/Show a => a/
02:40:47 <quicksilver> good point ;)
02:41:09 <quicksilver> to be picky, you have unbalanced parentheses :P
02:44:15 <vixey> wtf o_o
02:48:34 <vixey> why are you using such weird types?
02:50:58 <quicksilver> I'm not.
02:51:04 <quicksilver> We were discussing htem, not using them :)
02:53:01 <smg> hello.
03:04:45 <mae> what is that symbol which is the implicit return value of the last function in hugs?
03:04:46 <mae> i can't remember
03:04:57 <ivanm> question mark?
03:05:21 <mae> i get "unexpected symbol"
03:05:23 <mae> you know like
03:05:26 <mae> i do 1 + 5
03:05:29 <mae> and i type the symbol
03:05:34 <mae> and i get the last rval
03:06:49 <defarge> um... anyone up for a bit of a trig question? ...I have two sides of a triangle (a, c) and a non-included angle (A) - finding the length of the third side (b) --- so cosine rule is no good but using the sine rule i end up with b = A * sin(asin(c * sin(A) / a) - A) / sin(A) --- my issue is that this runs in a particularly sensitive part of the code --- is there a way to avoid having to call...
03:06:51 <defarge> ...some (all?) of the trig functions this implies?
03:07:32 <quicksilver> mae: "it" I think
03:07:56 <mae> it?
03:08:03 <quicksilver> that's what I thought, yes.
03:08:08 <mae> what is it?
03:08:13 <mae> is that a symbol?
03:08:19 <Deewiant> just type "it"
03:08:28 <mae> nope
03:08:45 <ski_> mae : `$$'
03:08:54 <Deewiant> it's "it" in GHCi
03:08:54 <mae> AHA!
03:08:56 <mae> thanks ski
03:09:49 <ski_> `it' is ghci (and iirc, SML/NJ's interactor)
03:11:04 <ski_> defarge : mayhaps you wanted #math ?
03:12:05 <defarge> ski_: well the math is good it's just that if i translate it direct into code it's a big hit ...
03:12:48 <defarge> ...so wondered if there was a better algorigthm that i could derive from the basics
03:14:05 <vixey> hi mae
03:14:59 <lilac> defarge: use the sine rule to get the included angle, then use the cosine rule
03:15:58 <defarge> lilac: yes that's essentially what i am doing as in that pseudocode --- but i end up with an expensive implementation :(
03:17:24 <defarge> really my thinking is to convert it somehow to vector math and avoid some of the trig - but can't see how
03:18:58 <lilac> defarge: one problem is that there are, in general, two solutions.
03:20:48 <quicksilver> yup
03:20:58 <quicksilver> straight line cuts a circle twice
03:21:06 <lilac> defarge: try it this way:
03:21:11 <quicksilver> tis one of those annoying euclidean rules :)
03:21:12 <defarge> lilac - yes i elided that -- i'm only interested in the solution where C > PI/2
03:21:30 <lilac> defarge: put the a,b at (0,0), with b going along the x axis.
03:21:30 <defarge> i.e. an obtuse triangle
03:21:53 <lilac> defarge: then find an equation for the c line as x = my + c
03:22:05 <lilac> defarge: then you know that x^2 + y^2 = b^2, substitute and solve
03:22:43 <defarge> lilac: sounds promisiing!
03:22:45 <lilac> let m = cotan A, c = b in x = m*y+c ;-)
03:24:40 <defarge> lilac: let me give that a go - nice idea :)
03:28:16 <lilac> defarge: remember 1 + cot^2 A = csc^2 A
03:31:34 <dcoutts_> bos, thetallguy: yes, I'm sure there's lots of code we share between the various distros that map Cabal -> native packages. Gentoo has something similar.
03:31:55 <Arnar> @src uncurry
03:31:55 <lambdabot> uncurry f p = f (fst p) (snd p)
03:31:56 <dcoutts_> bos, thetallguy: and of course making those progs easier by thinking about the Cabal lib api
03:32:20 <Arnar> I saw this:  uncurry f ~(x,y) = f x y    <-- what does the ~ mean?
03:32:53 <doun> lazy
03:33:24 <Arnar> ok.. like the opposite of !
03:33:35 <Arnar> it is just a hint, or an explicit instruction to the compiler?
03:33:57 <doun> I think it means a lazy pattern but I can't remember, I've never used it. there's a bit about it in Gentle Introduction. I'll bring it up
03:34:18 <doun> http://www.haskell.org/tutorial/patterns.html
03:34:19 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
03:34:21 <ndm> doun: is right
03:34:21 <lilac> the ~ means irrefutable
03:34:23 <doun> scroll down to 4.4
03:34:28 <Arnar> doun: thanks
03:34:42 <dcoutts_> it's occasionally vital
03:34:43 <ndm> it means that you don't wait for the tuple, but take that branch without evaluating the tuple
03:34:50 <dcoutts_> @src unzip
03:34:50 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
03:34:55 <ndm> uncurry f x = f (fst x) (snd y)
03:34:56 <dcoutts_> for example ^^^
03:35:08 <ndm> that would be the translation for uncurry without lazy patterns
03:35:27 <dcoutts_> ndm: hmm, it's a bit different
03:35:30 <dcoutts_> it has sharing
03:35:31 <lilac> "foo ~pattern = bar" basically means "foo x = let pattern = x in bar"
03:35:39 <dcoutts_> lilac: right
03:35:42 <ndm> dcoutts_: sure?
03:35:52 <dcoutts_> ndm: lilac has the translation
03:35:55 <doun> useful
03:35:55 <ndm> other than (snd x) instead of (snd y)
03:35:59 <Arnar> ok.. so "don't wait for the tuple" but take that branch.. what if the argument turns out not to match the pattern?
03:36:08 <lilac> Arnar: runtime error
03:36:15 <ndm> dcoutts_: yes, but in that pariticular example each is only used once, hence the sharing doesn't matter
03:36:20 <Arnar> ok..
03:36:21 <dcoutts_> ndm: I guess so
03:36:43 * ndm deals with lazy patterns all day long...
03:36:44 <doun> ndm: your TagSoup package is brilliant :) I appreciate it
03:36:52 <Arnar> lilac: thanks.. the translation explains it to me
03:36:57 <ndm> doun: thanks, glad to hear you like it
03:37:16 <hpaste>  cremetorte pasted "queue" at http://hpaste.org/7826
03:37:30 <cremetorte> thats right
03:37:31 <Arnar> "I like Haskell because it is lazy - just like me"
03:37:33 <cremetorte> and there is my problem
03:38:10 <cremetorte> in http://hpaste.org/7826  .   enq wont work  only when i turn  enq x t = t:x it works but i need  enq x  = x:t ...
03:40:16 <Saizan> cremetorte: ":" only adds elements at the head of a list, to add an element at the end what you must do is append a singleton list containint that element
03:40:41 <Saizan> > [1,2] ++ [3]
03:40:42 <lambdabot>  [1,2,3]
03:41:03 <Saizan> ?type (++)
03:41:05 <lambdabot> forall a. [a] -> [a] -> [a]
03:41:09 <Saizan> ?type (:)
03:41:10 <lambdabot> forall a. a -> [a] -> [a]
03:41:22 <cremetorte> ok
03:41:33 <cremetorte> u use enq x t = x++[t] thanks
03:44:05 <mbz> yarr!
03:44:14 <quicksilver> @yarr
03:44:16 <lambdabot> Get out o' me way, yeh landlubber
03:45:43 <Saizan> cremetorte: it's an O(n) operation tough, [a] is not a very good implementation for a queue
03:46:06 <cremetorte> its my task
03:46:26 <cremetorte> to do a queue implementation on the base of lists :)
03:47:59 <Lemmih> cremetorte: How about using two lists?
03:49:01 <cremetorte> i could ,but i have all to complete my task now. it was the task to do it with 1 list but thanks for your help
03:49:06 <quicksilver> there are efficient queue implementations for every prime number of lists, each slightly more fiddly than the last. I like to use 17-list queues.
03:53:51 <mbz> quicksilver, mmm, could you please show an example?
03:55:10 <vixey> quicksilver: huh!? cool
03:57:14 <quicksilver> mbz: I'm afraid I was joking ;P
03:57:36 <Deewiant> I prefer 13-list queues as Prelude instances for tuples only go up to 15... makes things simpler
03:57:58 <mbz> quicksilver, ;)
04:00:22 <Saizan> btw, how the 2-lists implementation work? keeping one in reversed order and exploiting laziness?
04:00:43 <quicksilver> don't think laziness is essential
04:00:53 <quicksilver> that just affects when you pay your amortized costs a bit
04:00:59 <quicksilver> overall cost ist he same strict/lazy
04:01:35 <vixey> how do you do a 3-queue though?
04:01:51 <vixey> and what's wrong with a 4-queue?
04:07:37 <dolio> Skimming Okasaki's book, it looks like non-lazy 2-list queues might not meet the amortized analysis if they're used persistently.
04:07:50 <lilac> Saizan: is (++) really O(n)? it seems to me that, due to laziness, it's O(1) -- the concatenation is only done if some other O(n) algorithm is walking the list anyway
04:08:17 <lilac> come to think of it, what does asymptotic complexity *mean* in a lazy language?
04:08:37 <lilac> certainly, reducing (a ++ b) to WHNF is O(1)
04:09:24 <dolio> Well, you could say n is the length of the demanded portion of a.
04:09:39 <lilac> well, depending on the complexity of reducing a to WHNF, it could be anything, i suppose...
04:09:59 <quicksilver> dolio: I think that's almost certainly true.
04:10:15 <lilac> dolio: how do you generalize that to arbitrary data constructors?
04:10:30 <quicksilver> lilac: traversing [1..2*n] is O(n) cheaper than traversing [1..n] (++) [1..n]
04:11:02 <quicksilver> lilac: so, (++) has an O(n) cost. The difference in the lazy case is that you don't necessarily pay it, i fyou never demand the data.
04:11:34 <lilac> quicksilver: you can't subtract complexity classes from each other like that, though, can you?
04:11:51 <quicksilver> I didn't subtract anything.
04:12:10 <lilac> "cheaper than"?
04:12:11 <quicksilver> I was saying alorgithm A is O(n) slower than algorithm be
04:12:14 <quicksilver> that's fair enough.
04:12:22 <lilac> quicksilver: but it's not
04:12:26 <quicksilver> I'm subtracting run times, if you.
04:12:29 <quicksilver> if ou like.
04:12:34 <quicksilver> not complexity classes.
04:12:38 <lilac> quicksilver: algorithm A is O(n), algorithm B is O(n)
04:12:44 <quicksilver> indeed.
04:12:51 <quicksilver> but they run at different speeds.
04:12:55 <Saizan> you can say that [1..n] (++) [1..n] does O(n) more reductions
04:12:56 <quicksilver> and you'll find the difference is O(n)
04:13:24 <Saizan> however the problem is when you repeadetly append, which becomes O(n^2)
04:13:36 <lilac> Saizan: more reductions when what happens?
04:13:46 <quicksilver> lilac: when you demand the whole list.
04:13:58 <lilac> quicksilver: then what's the complexity of concantenating two infinite lists?
04:14:05 <quicksilver> meaningless.
04:14:11 <lilac> i disagree
04:14:17 <quicksilver> concatenating two infinite lists is not something you can actually do.
04:14:23 <quicksilver> how can you ask for its complexity?
04:14:32 <quicksilver> algorithms have complexity.
04:14:37 <quicksilver> that is, thngs you actually do.
04:14:37 <Arnar> inflistA ++ inflistB == inflistA
04:14:39 <lilac> if calculating the value of each element was linear in the number of elements before it, the complexity should be something like O(n^2)
04:14:42 <quicksilver> programs you actually run.
04:14:52 <Saizan> well, "forcing the first n elements of a concatenation of 2 infinite lists is O(n) slower than forcing n elements of the first list"
04:15:01 <lilac> where "should be" is based on my intuition
04:15:09 <quicksilver> you're making no sense.
04:15:16 <Arnar> what does "O(n) slower" mean?
04:15:21 <lilac> ^^ exactly
04:15:32 <lilac> asymptotic complexity classes don't work like that
04:15:33 <quicksilver> well it means eactly what it says
04:15:37 <quicksilver> yes, they do.
04:15:48 <Saizan> Arnar: it does O(n) more work
04:15:48 <quicksilver> it means if you compare the running times of the two algorithms
04:15:52 <quicksilver> you see a difference
04:15:57 <lilac> really? can you say "this O(n log n) sort is O(n) slower than that O(n log n) sort"?
04:15:57 <quicksilver> and that difference is O(n)
04:16:04 <quicksilver> yes, you can say that.
04:16:22 <lilac> but what would that mean?
04:16:29 <quicksilver> what I've just said. twice.
04:16:36 <Arnar> so O(1) is O(n) slower than O(n) ?
04:16:40 <quicksilver> it means if you compare the running times of the two algorithms there is a difference.
04:16:41 <lilac> complexity classes are about *limits* as n -> infinity.
04:16:46 <quicksilver> and the difference is O(n)
04:16:55 <Saizan> Arnar: why you say that?
04:17:01 <quicksilver> Arnar: it's not precise to subtract classes.
04:17:03 <lilac> i guess i'm saying i want a mathematical formulation for what it is that you mean
04:17:13 <quicksilver> lilac: I've said it three times now.
04:17:13 <Arnar> Saizan: I was asking..
04:17:19 <quicksilver> How many more do you want?
04:17:24 <quicksilver> run both programs.
04:17:26 <quicksilver> compare speed.
04:17:31 <quicksilver> look at difference in timings.
04:17:31 <vixey> perl 5
04:17:35 <dolio> Appending with (++) adds a constant overhead to accessing each element.
04:17:37 <vixey> :?
04:17:37 <quicksilver> difference in timings is O(b)
04:17:41 <quicksilver> O(n)
04:17:46 <dolio> So if you access n of them, that's O(n) more work.
04:18:20 <Arnar> dolio: more work than simply traversing the list you mean?
04:18:29 <quicksilver> yes.
04:18:31 <dolio> Than the original one, yes.
04:18:34 <Arnar> ok..
04:18:37 <Arnar> I think I get it..
04:18:47 <quicksilver> demanding all elements of [1..n] (++) [1..n] does O(n) more work than demanding all elements of [1..2*n]
04:19:03 <Arnar> they're still both in the same complexity class though ( O(n) )
04:19:08 <quicksilver> indeed.
04:19:18 <quicksilver> but one is still slower, even asymptotically.
04:19:26 <Arnar> I understand
04:19:35 <quicksilver> so you can't subtract classes
04:19:44 <quicksilver> O(n) - O(n) could be O(1) or O(n)
04:19:46 <quicksilver> informally.
04:19:53 <quicksilver> but you can certainly compare concrete algorithms
04:20:01 <Bonus> does anyone have any example code that makes instance declarations of multiparameter type classes?
04:20:04 <quicksilver> and ask if one does more primitive operations
04:20:23 <quicksilver> Bonus: I tend not to use them, but what's the issue?
04:20:34 <Bonus> nothing specific
04:20:36 <quicksilver> instance Foo Int Char where foo = ....
04:20:40 <Bonus> just trying to learn how to use them
04:20:43 <Arnar> up to now I'd have put it "alg Y has double the constant of alg X"
04:20:50 <Bonus> aha so its
04:20:59 <lilac> quicksilver: actual runtimes are irrelevant for asymptotic complexity because asymptotic complexity is the *limit* as the size of the problem goes to infinity
04:21:03 <Bonus> instance Class Type1 Type2 Typen where
04:21:04 <quicksilver> lilac: yes.
04:21:14 <quicksilver> lilac: but you analyze that limit by calculating runtimes.
04:21:15 <lilac> quicksilver: so saying "run it and see" is not a valid definition
04:21:19 <quicksilver> yes it is.
04:21:25 <quicksilver> you run it in an abstract machine
04:21:29 <quicksilver> with indefinite 'n'
04:21:35 <quicksilver> and look at the numbers which come out.
04:22:01 <lilac> this: "< quicksilver> but one is still slower, even asymptotically." <<-- is false
04:22:14 <Arnar> I wouldn't use the word *limit*, big-O notation is about upper bounds
04:22:27 <lilac> asymptotically slower means *by definition* they're not in the same complexity class
04:22:39 <lilac> Arnar: fair point
04:22:47 <quicksilver> well that's certainly one definition of asymptotically slower, I agree.
04:22:53 <quicksilver> It's not the only possible way to use the phrase.
04:23:00 <lilac> ok, so how about this, then:
04:23:19 <quicksilver> the algorithm whose complexity class we are trying analyze here is the difference between the two.
04:23:28 <quicksilver> we're asking how much 'extra' work (++) does
04:23:45 <quicksilver> a convenient way to do that is to compare two
04:23:53 <quicksilver> one which uses (++) and once which doesn't.
04:23:58 <lilac> suppose there were a rigorous way of defining the difference of two algoriths, as you suggest. i'm not saying you've convinced me that there is...
04:24:08 <quicksilver> and it's actually the asymptotic behaviour of the difference we're trying to analyze.
04:24:19 <Arnar> quicksilver: so a proper answer would be "constant pr. input element"
04:24:50 <lilac> ... now, how do you define the asymptotic complexity of an arbitrary haskell function f?
04:25:08 <lilac> presumably it depends on how its output is used?
04:25:32 <Arnar> I think you'd have to assume the output is fully evaluated
04:26:12 <lilac> Arnar: i guess so. although there are more interesting questions you could ask
04:26:26 <Saizan> "evaluating up to <some parameter> takes ..."
04:26:35 <quicksilver> there are a whole bunch of choices
04:26:38 <lilac> for instance, the complexity of "take n . sort" is interesting
04:26:47 <quicksilver> including whether you assume the input is already evaluated.
04:27:10 <quicksilver> or whether you want to take into account the cost of evaluating the input.
04:27:23 <quicksilver> however, the answers in practice are fairly obvious ;)
04:27:37 <quicksilver> I think everyone knows what you mean when you say (1:) is O(1)
04:27:39 <lilac> quicksilver: i think you have to take into account the cost of evaluating the input. but i'm not sure how that works either
04:27:44 <lilac> quicksilver: i don't
04:28:01 <lilac> quicksilver: that's why i'm interested in this. i find complexity analysis of haskell fundamentally very hard
04:28:04 <quicksilver> ok, I revise that.
04:28:11 <quicksilver> Everyone except lilac knows what it menas :)
04:28:39 <lilac> quicksilver: in that specific case, i know what you mean. but in general, if you say that sort is O(n log n) in an input list of size n...
04:28:47 <lilac> ... and i say take n . sort . f ...
04:28:58 <lilac> ... and f is O(k^2) ...
04:29:16 <lilac> ... then i have *no idea* how to compute the complexity class of the result
04:29:29 <quicksilver> well you need to know more about the sort algorithm than you've told us so far :)
04:29:32 <lilac> (ok, sort is a bad example, because if n >= 1, it clearly has to force the whole list)
04:29:38 <quicksilver> actually it doesn't.
04:29:47 <quicksilver> there are sort algorithms which don't force the whole list
04:29:54 <lilac> quicksilver: take 1 . sort must force the whole list
04:29:58 <quicksilver> nope.
04:30:01 <lilac> quicksilver: otherwise it can't find the minimum element
04:30:10 <quicksilver> oh, sorry, whole input list yes
04:30:17 <quicksilver> but not whole *sorted* list.
04:30:20 <lilac> sure
04:30:44 <lilac> but my point was, in f . g, i need to know how much of g's result is forced by f.
04:31:03 * quicksilver nods
04:31:05 <quicksilver> true.
04:31:23 <lilac> i would very much like some calculus of complexity which would let me figure out how long my programs will run for
04:31:27 <quicksilver> complexity analysis for lazy programs is not composable.
04:31:36 <quicksilver> (at least the standard model is not composable)
04:31:50 <quicksilver> a composable model would need to be cleverer.
04:32:07 <Saizan> you essentially have to do strctiness analysis in the middle
04:32:56 <lilac> ok, i think this dialogue has got somewhere useful now. my problem with saying that "lazy f is O(n)" is that complexity classes *are* composable.
04:33:22 <lilac> or at least, classical complexity classes are
04:33:40 <quicksilver> I don't think it's the classes that are compsoable
04:33:45 <lilac> if nothing else, i think this would be an interesting PhD thesis for someone... ;-)
04:33:51 <quicksilver> it's the complexity analysis of strict programs that is.
04:34:06 <quicksilver> the classes stand distinct from the worries about strict or lazy or the details of the analysis.
04:34:22 <quicksilver> I'm not sure it's deep enough for a PhD thesis.
04:34:28 <quicksilver> I'm sure there is an interesting conference paper.
04:34:42 <quicksilver> a lot of this stuff is well known and documented around the folk lore
04:34:51 <quicksilver> okasaki's thesis has loads on it I believe.
04:34:59 <Saizan> however to make a judgement like the one above for (++) you need more precision than what complexity classes gives you, even if the result can be expressed in terms of them
04:35:08 <lilac> quicksilver: is said thesis available online?
04:35:12 <quicksilver> not sure
04:35:25 <quicksilver> yes.
04:35:33 <quicksilver> first google hit for 'okasaki thesis' :)
04:36:05 <lilac> is there any conventional way of expressing the complexity of lazily-evaluated functional programs, which is composable?
04:36:10 <quicksilver> there is the book too of course.
04:36:22 <quicksilver> lilac: i can imagine there might be one. I'm not aware of one having been written down.
04:36:47 <quicksilver> it would need to specify the amount of work done according to which parts of the output you forced
04:36:47 <lilac> ok, well i'll read this PhD before i say anything more on the subject
04:37:00 <quicksilver> like a 'work-done tree' on the structure of your output types.
04:37:09 <lilac> quicksilver: yes, it would. i suspect you'd end up with a calculus about as complex as the original language
04:37:22 <quicksilver> hopefully not quite.
04:37:25 <quicksilver> but yes
04:37:41 <lilac> quicksilver: i'd be interested to see if it was actually equivalent to a turing-complete model of computation :)
04:38:07 <lilac> ... actually, it's obviously undecidable
04:38:35 <lilac> (by reduction to the halting problem)
04:38:49 <lilac> s/undecidable/at most semi-decidable/
04:38:57 <Arnar> wasn't there something on LtU the other day about analyzing complexity of functional programs?
04:39:54 <Saizan> lilac: that's true for strict evaluation as well, then, no?
04:40:03 <lilac> i guess that you can say that (++) is O(n), because a strict (++) would be O(n)
04:40:09 <lilac> Saizan: yes, indeed
04:41:59 <lilac> but a strict (++) would also be \Omega(n), whereas a lazy (++) might not be
04:42:39 <quicksilver> lazy (++) makes you pay up front
04:42:51 <quicksilver> you pay an extra constant for each element of the left-hand list you traverse
04:42:57 <quicksilver> once you get to the right hand list it's free.
04:43:05 <lilac> this notion of 'runtime as difference' doesn't work, i don't think. what if your function is a -> b? how do you define the difference?
04:43:38 <quicksilver> it's a fair comment
04:43:48 <quicksilver> I was doing a bespoke analysis for (++)
04:43:52 <quicksilver> not a general one.
04:43:54 <lilac> heh :)
04:44:09 <quicksilver> but basically you compare the work to generate "a"
04:44:21 <quicksilver> with the work to generate "b" using "a".
04:44:41 <quicksilver> however the question that does arise is 'what if we don't need all of a'
04:44:46 <lilac> :)
04:45:00 <lilac> 'take' appears to have potentially negative complexity
04:45:15 <lilac> maybe that's actually appropriate?
04:46:11 <quicksilver> well with take you can ask the question
04:46:17 <quicksilver> how much slower is take n . take n
04:46:19 <quicksilver> than take n
04:46:34 <quicksilver> is it just a constant overhead or is it an O(n) overhead?
04:46:40 <lilac> both?
04:46:47 <lilac> it's a constant multiple
04:46:51 <quicksilver> assuming you demand all n elements.
04:47:01 <quicksilver> yes, it's an O(n) overhead.
04:47:07 <quicksilver> so I would say take as O(n)
04:47:17 <lilac> a constant multiple and an O(n) overhead are the same for an O(n) algorithm, though
04:47:55 <lilac> anyway, time for lunch. thanks for the interesting thoughts!
05:03:32 <edwardk> @seen hellige
05:03:32 <lambdabot> hellige is in #haskell, #xmonad and #scala. I last heard hellige speak 15h 13m 57s ago.
05:27:25 <Saizan> does and applicative functor have to be an endofunctor in general?
05:28:30 <bla123> HaXml-1.19.2 fails to build on windows, ghc 6.8.1, when linking xtract: i get lots of "fake: undefined reference to" linker errors pointing to the containers package
05:28:46 <bla123> containers is an explicit dependency in the cabal file though
05:29:24 <edwardk> saizan: i think technically your only requirement is that the target category be a CCC.
05:29:34 <malcolmw> bla123: building with cabal, or with Makefiles?
05:29:46 <bla123> malcolmw: building with cabal
05:30:46 <edwardk> saizan: the CCC bit comes from the fact that you use tis notion of an exponential. and since you use pure as the way to lift functions into it, your source category also, but technically I don't think it'd have to be if you had some other way to construct Foo (a -> b)'s to use with <*>
05:30:56 <malcolmw> bla123: I don't know so much about that route for building - dcoutts_ might be able to help
05:32:13 <malcolmw> dcoutts_: if my cabal file has a library with package deps, but also executable stanzas, do the latter need to repeat the package deps, or are they automatically passed through?
05:32:34 <edwardk> er s/tis/its
05:33:01 <bla123> malcolmw: i already tried that: i added explicit depends-on lines in the executable section
05:34:39 <Saizan> edwardk: so having an applicative functor from the kliesli category of some monad to Hask should work?
05:35:43 <edwardk> saizan: yeah. though note, if you start allowing general categories then every monad is not necessarily an applicative
05:36:33 <edwardk> saizan: and with your kleisli category example, i just decided to parameterize pointed and applicative on both categories. damn you i have too many arguments floating around ;)
05:37:39 <Saizan> <heh :)
05:38:03 <edwardk> the monads not being applicative part follows because you can have a monad on a non-CCC.
05:38:32 <Saizan> an applicative built this way can be a monad? i'd say no since monads are : C -> C
05:38:43 <edwardk> monads have to be C -> C
05:39:14 <edwardk> i just thought i'd mention that when you start widening the definitions you get some funny corner cases.
05:40:26 <Saizan> yeah, sure. too bad i'd need a monad too here :)
05:40:35 <edwardk> heh
05:41:33 <edwardk> well you just mentioned having the other category be a kleisli category, so in that that monad is C -> C, even if your applicative is D -> C. or do you mean yet another monad?
05:44:47 <Saizan> i want AP over (a -> m b), so e.g. AP (a -> b) is some structure around (a -> m b), but also have (>>=) for AP
05:47:16 <Saizan> i'm not sure if any part of this makes actually sense :) it's for a somewhat fictional EDSL
05:47:53 <edwardk> hrmm, so first thought is just to define a class like class Functor k => KleisliApplicative k where  kpure :: m a -> k (m a); kap :: k (a -> m b) -> k (m a) -> k (m b)
05:48:11 <mar77a> i need help writting a function is_prime_number n, any ideas?
05:48:27 <edwardk> but that doesn't give you the ability to get a a -> m b into the category, so you'd need to allow kpure :: a -> k a
05:48:33 <vixey> mar77a: first write a function which gives the prime decomposition of a number
05:48:45 <vixey> mar77a: e.g. f 15 = [3,5]
05:48:45 <vixey> \
05:48:55 <mar77a> o_o
05:49:04 <edwardk> er KleisliApplicative k m | k -> m
05:49:45 <Saizan> right
05:50:04 <dolio> You can write kpure for any applicative (pointed) functor, no?
05:50:10 <dolio> It's just pure.
05:50:12 <edwardk> yeah
05:50:41 <dolio> And kap is... ap (\f -> extend f)?
05:51:03 <edwardk> bind
05:51:14 <dolio> @type ap (\f -> (=<<) f)
05:51:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => ((a -> m b) -> m a) -> (a -> m b) -> m b
05:51:35 <dolio> Hmm.
05:51:56 <dolio> @type ap . fmap (=<<)
05:51:58 <lambdabot> forall a (m :: * -> *) b (f :: * -> *). (Functor f, Monad m, Monad f) => f (a -> m b) -> f (m a) -> f (m b)
05:52:25 <quicksilver> mar77a: in general you need a list of all the primes up to sqrt(n)
05:52:40 <quicksilver> mar77a: there are around 12 million programs to calculate lists of primes in haskell on the intertubes.
05:53:47 <edwardk> @type (<*>) . liftA (=<<)
05:53:49 <lambdabot> forall a (m :: * -> *) b (f :: * -> *). (Monad m, Applicative f) => f (a -> m b) -> f (m a) -> f (m b)
05:54:33 <Saizan> ?type let kap x =  (<*>) . liftA (=<<) $ x in \f a b -> pure f `kap` a `kap` b
05:54:34 <lambdabot> forall a a1 (m :: * -> *) b (f :: * -> *). (Applicative f, Monad m) => (a -> a1 -> m b) -> f (a1 -> a) -> f (m a1) -> f (m b)
05:55:18 <Saizan> ?type let kap x =  (<*>) . liftA (=<<) $ x in \f a b -> (pure f `kap` a) `kap` b
05:55:20 <lambdabot> forall a a1 (m :: * -> *) b (f :: * -> *). (Applicative f, Monad m) => (a -> a1 -> m b) -> f (a1 -> a) -> f (m a1) -> f (m b)
05:55:56 <edwardk> not quite as nice as I'd like
05:56:07 <Saizan> yeah
05:56:46 <edwardk> you'd want to require functions to have the form a -> m (b -> m c)    right?
05:57:06 <sioraiocht_> @tibbe
05:57:07 <lambdabot> Local time for sioraiocht_ is 2008-05-23 13:57:06 +0100
05:57:13 <sioraiocht_> grr
05:57:16 <Saizan> to make kap work, yes
05:57:17 <sioraiocht_> @seen tibbe
05:57:18 <edwardk> yeah each kap would set you up for the next one
05:57:18 <lambdabot> I saw tibbe leaving #haskell-soc, #xmonad, #ghc and #haskell 5h 24m 42s ago, and .
05:57:56 <mar77a> woah
05:57:57 <mar77a> i think this works
05:57:59 <mar77a> is_prime n = (filter (==0) ( map (n `rem`) [2..(n+1)])) == [0]
05:58:13 <edwardk> some typeclass hackery/type family work? =)
05:58:41 <vixey> > let is_prime n = (filter (==0) ( map (n `rem`) [2..(n+1)])) == [0] in zip (is_prime [1..]) [1..]
05:58:42 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Bool'
05:58:47 <vixey> > let is_prime n = (filter (==0) ( map (n `rem`) [2..(n+1)])) == [0] in zip (map is_prime [1..]) [1..]
05:58:48 <lambdabot>  [(False,1),(True,2),(True,3),(False,4),(True,5),(False,6),(True,7),(False,8)...
05:58:52 <Saizan> first i've to realize if it makes sense semantically :)
05:58:54 <vixey> cool
05:58:55 <edwardk> heh
05:58:56 <edwardk> yeah
05:59:01 <mar77a> i'm surprised at myself
05:59:13 <edwardk> ok, gotta get to work. bbiab
06:00:01 <vixey> mar77a++
06:00:38 <mar77a> hm?
06:00:47 <EvilTerran> ?karma mar77a
06:00:47 <lambdabot> mar77a has a karma of 1
06:00:54 <mar77a> interesting
06:00:59 <vixey> I would have written it like this
06:01:01 <mar77a> ?trade_karma_for_money
06:01:01 <lambdabot> Unknown command, try @list
06:01:07 <mar77a> bah
06:02:56 <Saizan> > nubBy (((>1) .) . gcd) [2..] -- just to not forget #haskell's classics
06:02:58 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
06:03:36 <dolio> sorear lives on in our memories.
06:03:52 <quicksilver> eh?
06:04:10 <mar77a> gcd = greatest common divisor?
06:04:11 <vixey> > let n`divides`d = n`mod`d==0 ; factors 1 = [] ; factors n = d : factors (n`div`d) where d = head (filter (divides n) [2..]) in let isPrime n = 1 == length (factors n) in isPrime 71
06:04:12 <lambdabot>  True
06:04:17 <dolio> Well, he apparently has better stuff to do these days than sit around here coming up with shorest possible strings to generate primes.
06:04:17 <quicksilver> dolio: ?
06:04:20 <quicksilver> ;)
06:04:23 <quicksilver> ah, yes.
06:04:31 <quicksilver> god for a moment there I thought you were saying he was dead
06:04:45 <dolio> Not that I know of.
06:04:54 <Saizan> he0s still on freenode, /whois says
06:05:08 <vixey>  * sorear :No such nick/channel
06:05:09 <vixey>  * sorear :There was no such nickname
06:05:09 <vixey>  * sorear :End of WHOWAS
06:05:17 <Saizan> well, said yesterdat
06:05:18 <dolio> Huh, just giving us the brushoff.
06:05:39 <mar77a>  isn't there a where command?
06:05:52 <Saizan> ?where where
06:05:52 <lambdabot> ?where where
06:05:57 <vixey> ?where ?where
06:05:57 <lambdabot> ?where ?where
06:07:13 <mar77a> or seen
06:07:15 <mar77a> something
06:07:23 <quicksilver> ?seen sorear
06:07:23 <lambdabot> I haven't seen sorear.
06:07:58 <orbitz> > putStr "Sunshine lollyposp and rain bow colored drops!"
06:08:00 <lambdabot>  <IO ()>
06:09:45 <Leimy> So I was thinking more and more about dons pseudo "challenge" to me to rewrite the parallel/concurrent prime sieve I have in IO under pure parallel haskell.
06:09:53 <Leimy> It seems the right way to do this is with continuations.
06:10:14 <orbitz> is there any effort for a haskell mapreduce impl? or something similar?
06:11:27 <Saizan> foldl g z . parMap rnf f
06:11:59 <orbitz> is that forshizzle?
06:12:51 <dolio> You mean forizzle?
06:13:01 <Saizan> it's mostly a joke, but it does compute the application of f in potentially multiple threads
06:13:25 <Leimy> parallel map would be nice
06:13:44 <Saizan> we've it.
06:13:53 <Apocalisp> parMap
06:13:56 <dolio> @hoogle parMap
06:13:56 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
06:13:59 <Leimy> I think haskell needs to get distribution :-)
06:14:04 <Leimy> like ... for grids/clusters
06:14:13 <orbitz> yeah
06:14:16 <orbitz> like mapreduce!
06:14:30 <Leimy> I think there's MPI bindings
06:14:37 <Leimy> but ... not enough sugar
06:14:43 <Leimy> and I say that because I've implemented MPI myself :-)
06:14:44 <orbitz> MPI bindings? IEEEEE
06:14:57 <mar77a> argh i'm STUCK
06:15:09 <orbitz> what are ones solutiosn for doign dynamic linking in haskell?
06:15:10 <mar77a> how can i find the factors of a number
06:15:15 <quicksilver> the naive way to distribute haskell requires the ability to serialise thunks.
06:15:25 <orbitz> mar77a: find numbers taht dividie it evenly
06:15:27 <brad_larsen> mar77a: project euler problem?
06:15:28 <Peaker> mar77a, efficiently or simply?
06:15:32 <quicksilver> mar77a: from its prime factors (are you doing eulur problems?:)
06:15:45 <quicksilver> being able to serialise thunks would definitly be cool.
06:15:53 <mar77a> yep
06:15:55 <Leimy> quicksilver: I think I'm constantly having trouble with the somewhat ambiguity of what "thinks" are in different systems :-)
06:15:59 <quicksilver> but not trivial.
06:16:01 <Leimy> what's the difference between a thunk and a closure?
06:16:02 <mar77a> "What is the largest prime factor of the number 600851475143 ?"
06:16:05 <Peaker> mar77a, simply: Just take all numbers that have a 0 modulu result
06:16:15 <mar77a> right
06:16:34 <quicksilver> Leimy: hmm. difference of emphasis, I guess. similar concepts.
06:16:47 <brad_larsen> :t unfoldr
06:16:49 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
06:16:52 <quicksilver> Leimy: I'd say a closure was more of a denotational notion, and a thunk is an operational notion.
06:16:57 <Leimy> quicksilver: yeah, I mean in scheme there's a lot of thunks talked about in certain high levl functions.
06:17:08 <quicksilver> Leimy: A thunk is a code pointer which you jump to when you want to evaluate more.
06:17:10 <Leimy> however it does seem that not all lambdas are thunks :-)
06:17:11 <brad_larsen> I saw a prime factorization function in terms of unfoldr, once
06:17:24 <Leimy> quicksilver: ah it's like a semantic definition for a lambda
06:17:34 <Leimy> talking about it's purpose
06:17:36 <cpst> how about an efficient factorization function? ;-)
06:17:37 <quicksilver> Leimy: peobably it has access to a 'local' environment so in that sense it could be said to use closures.
06:17:53 <Saizan> Leimy: an applied lambda
06:17:58 <quicksilver> Leimy: in a strct language, only lambdas are thunks.
06:18:04 <Leimy> interesting!
06:18:05 <quicksilver> Leimy: in a lazy language ALL values are thunks
06:18:08 <Leimy> yep
06:18:08 <quicksilver> Leimy: speaking loosely.
06:18:24 <Leimy> I was just thinking, but with Currying you get a lot of thunks :-)
06:18:27 <quicksilver> Saizan's point is slightly more accurate, perhaps.
06:18:46 <quicksilver> thunks are really a concrete implementation thing rather than a theoretical thing.
06:18:59 <Leimy> I think I get it.
06:19:06 <quicksilver> I.e. a given compiler might produce more thunks than another, due to different compilation styles.
06:19:23 * orbitz still doesn't get it
06:19:57 <dolio> GHC will produce different ammounts of thunks depending on optimization levels.
06:20:01 <quicksilver> orbitz: did you mean dynamic linking or dynamic loading?
06:20:03 <brad_larsen> any fixpoint wizards here?
06:20:13 <brad_larsen> I have been looking at Control.Monad.Fix
06:20:23 <dolio> Heh.
06:20:24 <orbitz> quicksilver: dynamic linking i guess (like implementing a plugin system)
06:20:37 <brad_larsen> wrote fibs & fac using fix
06:20:50 <orbitz> Yi just recompiles everythign everytime right?
06:20:52 <quicksilver> orbitz: I'd call that dynamic loading :)
06:20:57 <dolio> You want to know about fix or mfix?
06:21:02 <orbitz> quicksilver: ok
06:21:05 <mar77a> grrr
06:21:13 <orbitz> quicksilver: linux seems to like to cal lit dynamic linking
06:21:14 <mar77a> print $ filter (==0) $ map (rem 600851475143) [1..600851475143]
06:21:14 <quicksilver> your choices are hs-plugins, or plugins, or ghc-api
06:21:16 <quicksilver> or metaplug.
06:21:20 <mar77a> something like that is extremely inefficient
06:21:21 <brad_larsen> fix.  just looking for some neat examples of defining functions using fix
06:21:29 <mar77a> if it even works
06:21:37 <brad_larsen> or papers, etc. on computation via fixpoints
06:21:43 <phlpp> @src rem
06:21:44 <lambdabot> Source not found. Just what do you think you're doing Dave?
06:21:46 <orbitz> quicksilver: would that be sufficient to imlement a mapreduce? or do yo uthink serializign thunks is really important?
06:21:55 <doun> could you define foldr with fix...
06:22:13 <quicksilver> you can implement specific distribution strategies without thunk serialisation.
06:22:17 <brad_larsen> doun: that makes my head hurt ;-)
06:22:26 <quicksilver> but to do somethign general, you need to be able to send thunks over the wite.
06:22:28 <quicksilver> wire.
06:23:00 <mar77a> what's wrong with print $ zip (filter (==0) $ map (rem 600851475143) [1..600851475143] [1..]) ?
06:23:08 <ndm> Yhc already lets you send thunks over the wire
06:23:18 <dolio> @type let foldr = fix f where f rec g z [] = z ; f rec g z (x:xs) = g x (rec z xs) in foldr
06:23:19 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t2 -> t
06:23:19 <lambdabot>     Probable cause: `f' is applied to too few arguments
06:23:19 <lambdabot>     In the first argument of `fix', namely `f'
06:23:22 <ndm> but i think the conclusion was that its actually not that useful...
06:23:31 <dolio> @type let foldr = fix f where f rec g z [] = z ; f rec g z (x:xs) = g x (rec g z xs) in foldr
06:23:33 <lambdabot> forall t t1. (t -> t1 -> t1) -> t1 -> [t] -> t1
06:23:43 <quicksilver> ndm: interesting, both parts.
06:23:52 <brad_larsen> :t print $ zip (filter (==0) $ map (rem 600851475143) [1..600851475143] [1..])
06:23:54 <lambdabot>     Couldn't match expected type `[t] -> [a]'
06:23:54 <lambdabot>            against inferred type `[t1]'
06:23:54 <lambdabot>     In the second argument of `($)', namely
06:24:19 <phlpp> @src fix
06:24:20 <lambdabot> fix f = let x = f x in x
06:24:24 <ndm> quicksilver: much better to send data, and not worry about architecture differences and the other code thats in memory,  which a thunk depends on
06:24:38 <quicksilver> yes.
06:24:43 <ndm> plus if you make a thunk more robust, you loose your ability to optimise it properly
06:24:47 * quicksilver nods
06:24:49 <quicksilver> I cna believe that.
06:24:50 <mar77a> oh got it
06:24:50 <brad_larsen> mar77a: the use of map is bogus, i think
06:24:54 <Saizan> that means yhc can serialize functions?
06:25:02 <brad_larsen> mar77a: there are 3 arguments to it
06:25:58 <mar77a> (filter (==0) $ map (rem 600851475143) [1..600851475143]) how can i know which numbers from [1...6...] are actually satisfying the condition
06:26:00 <quicksilver> ndm: maybe I haven't thought it through.
06:26:17 <quicksilver> ndm: it seems that (naively) if you want parMap to do transparent distributed processing.
06:26:19 <ndm> Saizan: you need more than just serialising functions, you need to send code over the wire too - if the code depends on other code
06:26:31 <ndm> Saizan: but Yhc can do all that
06:26:53 <ndm> quicksilver: distributed as in shared code memory space would be fine, if they are truely distributed, then it gets harder
06:27:13 <ndm> the best guess would be shove a shared read-only code memory and have each machine "cache" the copy of it locally
06:27:40 <ndm> i think Wadler's Links does something kind of similar, using defunctionalisation
06:27:57 <ndm> so you make an explicit interpreter and send data over, which is interpreted
06:28:04 <quicksilver> ndm: yes, I wasn't sugesting it was easy :)
06:28:10 <quicksilver> ndm: it's clearly not.
06:28:14 <ndm> of course not :)
06:28:19 <brad_larsen> mar77a: try a list of tuples of (number, remainder)
06:28:30 <quicksilver> but I'm not sure if there is another obvious approach to 'automatic' distribution
06:28:34 <quicksilver> or mostly automatic
06:28:36 <ndm> but i don't think its ridiculously complicated
06:28:42 <mar77a> too hard to think about it, i'll just re-structure
06:28:44 <ndm> i think Wadler has an ICFP paper
06:29:15 <brad_larsen> mar77a: although I don't think your strategy will work for the problem you are working on
06:29:54 <brad_larsen> let foldr = fix f where f rec g z [] = z ; f rec g z (x:xs) = g x (rec g z xs) in foldr
06:30:05 <brad_larsen> :t foldr
06:30:07 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:30:21 <ndm> quicksilver: http://homepages.inf.ed.ac.uk/wadler/topics/links.html#located-lambda
06:30:22 <lambdabot> Title: Wadler: Links, http://tinyurl.com/5j58vk
06:31:05 <Peaker> Is it right to view an arrow as a non-opaque (to those who defined the arrow type) function representation?  In that case, why is the order of arrow combinator use meaningful?
06:31:31 <Saizan> ndm: has anyone used this yhc feature for persistent continuations?
06:31:33 <Peaker> I guess the kleisly arrow has meaningful order because of the underlying meaning of the monad ordering
06:31:52 <ndm> Saizan: unlikely
06:32:09 <mar77a> it worked
06:32:14 <ndm> Yhc features have a nasty habit of existing but rarely working...
06:32:28 <Peaker> btw: what's the equivalent of python's os.path.join and other os.path functions in Haskell?
06:32:42 <Saizan> Peaker: System.FilePath
06:32:52 <Peaker> Saizan, thanks
06:33:10 <quicksilver> Peaker: an arrow is like a function which can have side effects.
06:33:13 <mar77a> print $ filter is_prime (filter is_fact [1..600851475143]) worked :)
06:33:27 <mar77a> i'm starting to fall in love...
06:33:28 <quicksilver> Peaker: and that's why the order matters (the order of the effects)
06:34:13 <Peaker> quicksilver, How many practical applications of arrows do have side effects? If few, it might be a problem that order is wrongfully assigned a meaning
06:34:21 <brad_larsen> dolio: I suppose once you have foldr, you have (just about?) everything.
06:34:34 <quicksilver> Peaker: all of them. Otherwise you're just using functions with a funny notation.
06:34:35 <dolio> Everything primitive recursive.
06:34:43 <hpaste>  titusg pasted "parsec problem" at http://hpaste.org/7829
06:34:47 <titusg> Hi, I have a really basic problem with parsec, can someone have a look?
06:35:04 <Peaker> quicksilver, oh, maybe I misunderstood the arrow examples I've looked at then
06:35:04 <brad_larsen> dolio: aha.  need to read more.  thanks!
06:35:19 <dolio> brad_larsen: You can't write unfoldr, for instance.
06:35:26 <Peaker> quicksilver, Reading about something without playing with it is dangerous for one's true understanding :)
06:35:30 <quicksilver> Peaker: ;)
06:35:44 <quicksilver> Peaker: note that I have a general definition of side-effect.
06:35:44 <Saizan> dolio: you can write fix with foldr
06:35:48 <quicksilver> Peaker: similar to monads.
06:35:55 <quicksilver> Peaker: for example, the list arrow a -> [b]
06:36:12 <brad_larsen> Saizan: and you can write foldr with fix
06:36:17 <quicksilver> Peaker: the "effect" is to have multiple return values.
06:36:33 <Saizan> dolio: ah, well, assuming infinite codata i guess, so that's cheating :)
06:36:42 <dolio> Yeah, that's cheating.
06:36:55 <brad_larsen> titusg: what is in test.tex?
06:36:59 <Peaker> quicksilver, what happens when you self-feedback (loop) such an arrow, does it feed multiple results as multiple inputs ad-infinitum?
06:37:27 <titusg> brad_larsen: some latex, including \cite tags and lots of other text
06:37:36 <Saizan> brad_larsen: you can mechanically convert every recursively definite function to one built with fix and no recursion
06:37:47 <dolio> Having recursive and corecursive operators on the same data type is what gets you general recursion there.
06:38:00 <quicksilver> Peaker: well there are ways of tying loops that produce useful results.
06:38:08 <quicksilver> Peaker: I can't give specific examples though :)
06:38:14 <Peaker> btw: are you supposed to import System.FilePath or the underlying Posix/Windows modules?
06:38:16 <quicksilver> Peaker: there isn't enough interesting written about arrows.
06:38:29 <quicksilver> Peaker: in particular, I find it hard to imagine an interesting arrow which isn't a Kleisli arrow.
06:38:42 <Peaker> quicksilver, there's the parsing arrow which I thought "started it all"
06:38:52 <Peaker> (and afaik is not a kleisly arrow)
06:38:57 <Saizan> Peaker: if you import the former you get the one corresponding to the OS where you're building
06:39:05 <Peaker> Saizan, ah, thanks
06:39:40 <titusg> brad_larsen: I wanted to do "get contents of cite tag OR get contents of bibliography tag OR skip a char and keep going"
06:40:26 <mar77a> eh
06:42:16 <brad_larsen> titusg: I see a couple problems
06:42:41 <titusg> brad_larsen: tell me more :-)
06:42:50 <brad_larsen> titusg: (endBy p sep) parses zero or more occurrences of p, seperated and ended by sep. Returns a list of values returned by p.
06:43:03 <brad_larsen> from the parsec doc at <http://legacy.cs.uu.nl/daan/download/parsec/parsec.html>
06:43:09 <Peaker> quicksilver, I think they had a problem with Monads because the monads are combined with opaque Haskell functions - but when combining Non-opaque arrow-wrapped functions the parser library can analyze the parser you build and convert it to an efficient representation
06:43:23 <titusg> brad_larsen: that's what I thought - so from "foo}" I want "foo"
06:43:35 <Peaker> quicksilver, I am not sure if that specific arrow assigns meaning to the order of combinators (I would assume maybe the order matters in things like a parse-choice and stuff like that)
06:43:49 <brad_larsen> titusg: that doesn't seem like what you want, i think it would parse "f}o}o}"
06:44:20 <Saizan> Peaker: however function composition in itself requires ordering
06:44:21 <brad_larsen> titusg: also, I think your `cite' and `bib' parsers will have trouble with nested parens
06:44:35 <Peaker> Saizan, what do you mean?
06:44:35 <brad_larsen> titusg: (not sure if that's allowed in latex citations)
06:44:38 <sclv> e.g., why does a monad have order?
06:45:01 <sclv> x >>= y implies that x has to be somewhat forced before y can happen.
06:45:06 <Saizan> Peaker: f . g . h /= h . g . f in general, even if they type
06:45:08 <titusg> brad_larsen: no braces allowed inside {}
06:45:17 <Peaker> sclv, what about >>= \_ -> ?
06:45:46 <Peaker> sclv, or x >>= \y -> dontUseY >>= \z -> useYAndZHere
06:45:56 <paolino> @pl ﻿(>>= \_ ->)
06:46:00 <lambdabot> (line 1, column 2):
06:46:02 <lambdabot> unexpected "\187"
06:46:06 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
06:46:07 <Peaker> sclv, these can be rearranged as far as direct dependencies go
06:46:20 <Saizan> Peaker: the order of arrow composition doesn't necessarily impose an evaluation order either
06:46:47 <BeelsebobWork> Is there someone here who knows about type checking that's prepared to help me with a bit of understanding of the parametric polymorphism section of Pierce's book?
06:47:22 <quicksilver> Peaker: up to a first approximation, a classic parsing arrow is just the Kleisli arrow of a state monad
06:47:30 <quicksilver> Peaker: where the state is the stream of tokens.
06:47:44 <Peaker> Saizan, but by definition the ordering a bunch of Haskell statements is not meaningful, while the order of a bunch of arrow compositions may be meaningful - it may impede understanding when it is in fact non-meaningful, including for the optimizer which may not be able to know it does not matter
06:47:53 <quicksilver> note that a -> s -> (s,b) is isomoprhic to (s,a) -> (s,b)
06:48:10 <quicksilver> so it's not that parsing arrows are not monads.
06:48:13 <opqdonut> modulo a few bottoms?
06:48:23 <quicksilver> it's that by promising not to use them as monads
06:48:28 <quicksilver> by restricting your intrface
06:48:32 <quicksilver> you can make more laws true
06:48:47 <quicksilver> and hence, you can do the clever trick with the first-token stuff.
06:49:00 <quicksilver> as described in duponcheel and swierstra
06:49:11 <quicksilver> opqdonut: right.
06:49:14 <opqdonut> :)
06:49:22 <Peaker> quicksilver, I guess I need to play with it a little at some point..
06:49:26 <sclv> > (error "yo" >>= const (Just 4))
06:49:27 <lambdabot>  Exception: yo
06:49:43 <Saizan> Peaker: in haskell we don't really have a list of statements anywhere, but we have trees of expressions, and that's not so different from arrows, you just have only (.) instead of also ($)
06:49:45 <sclv> this works because Maybe's bind will pattern match.
06:49:52 <Peaker> I wonder how good an iteratively deepening chess AI in Haskell will be, with a crap material-based heuristic will be
06:49:59 <sclv> you can also have binds that won't.
06:50:01 <quicksilver> of course, there certainly *are* arrows which don't occur as kleisli cats of monads.
06:50:11 <quicksilver> but I haven't managed to grok any interesting ones.
06:50:13 <sclv> > runReader (error "yo" >>= const (return 4)) "foo"
06:50:14 <lambdabot>  4
06:50:15 <opqdonut> sclv: well for example the lazy state monad?
06:50:18 <opqdonut> or that
06:50:30 <Peaker> Saizan, the expressions are graphs, not trees, no?
06:50:44 <opqdonut> well the AST is a tree
06:50:52 <malcolmw> bla123: still here?
06:50:52 <opqdonut> evaluation does graph reduction
06:50:53 <Peaker> the AST is not the expression, though
06:51:05 <quicksilver> indeed monads do not theoretically enforce an evaluation order
06:51:07 <bla123> malcolmw: yes
06:51:09 <Saizan> yeah, graphs, my bad
06:51:11 <quicksilver> but many monads do in practice.
06:51:14 <malcolmw> bla123: dcoutts_ suggests you might have duplicate versions of the containers package installed
06:51:27 <quicksilver> at least they enforce as much as is needed to decide between effects.
06:51:38 <quicksilver> q.v. recent discussion on haskell-cafe about whethere >> is strict.
06:51:51 <quicksilver> (and whether Control.Exception.evaluate's documentaiton makes sense)
06:51:53 <Peaker> Saizan, so both of them define an expression/computation graph - however due to arrows being created with (>>>) operators and others, there is extra information in there (>>> is not necessarily cummutative)
06:51:57 <bla123> malcolmw: checked that, it's true, but the older version is hidden
06:52:00 <malcolmw> bla123: maybe one in the global ghc db + one in the per-user db
06:52:04 <bla123> malcolmw: must i uninstall it?
06:52:29 <sclv> I guess you could say that "monadic bind structures an order of dependencies." ?
06:52:41 <Peaker> Saizan, oops, I meant the arrow operator which joins in independent computations (I don't remember what >>> is :-)
06:53:32 <malcolmw> bla123: the suggestion is to get rid of the per-user version altogether
06:53:32 <Peaker> proc do { a <- func -< b ; c <- func -< d } -- contains more information than   { let a = func b ; c = func d }
06:53:34 <bla123> malcolmw: i only install globally, but just to be sure, i unregistered the old version and am recompiling now
06:53:59 <dcoutts_> bla123: so you have two different versions registered globally?
06:54:16 <bla123> dcoutts_: yes, but the older one was hidden
06:54:19 <malcolmw> bla123: ah, apparently the problem is that _other_ packages have been built against the old version of containers
06:54:20 <dcoutts_> bla123: you'll need to make sure everything is using the same one, either the old or new but not a mixture
06:54:48 <dcoutts_> bla123: the fact that the old one is hidden does not change the fact that most other existing packages will have been built against it
06:54:50 <bla123> dcoutts_: ok, that sounds very likely
06:55:01 <Saizan> Peaker: yeah, but it still doesn't imply that a must be evaluated before c
06:55:18 <dcoutts_> bla123: you can see what each installed thing was built against using ghc-pkg field pkgfoo depends
06:55:19 <Peaker> Saizan, but how do you know whether it implies that?
06:55:32 <Saizan> Peaker: by the arrow implementation
06:55:38 <bla123> dcoutts_: is there no way to use different versions? bytestring for example is used by a lot of packages and changes frequently
06:55:43 <quicksilver> no, but it does imply that any effects caused by the 'a <- -< b' occur before the effects caused by 'c <- -< d'
06:55:44 <Peaker> Saizan, how does the optimizer know?
06:55:51 <quicksilver> by inlining.
06:55:58 <quicksilver> and inspection of code
06:56:00 <Saizan> by the arrow implementation :)
06:56:02 <quicksilver> and code transformation.
06:56:03 <Peaker> hehe
06:56:14 <dcoutts_> bla123: you can have several different versions installed at once, but within any single compilation it's almost certainly unwise to have two of the same package
06:56:37 <Peaker> it bothers me, though, that the order information is forced in there by the notation - to be discarded by the implementation, which hopefully documents it
06:56:47 <dcoutts_> bla123: but that's exactly what you get if you have a package that you build against the new containers and another package that was itself built against the old containers, see?
06:56:55 <hpaste>  (anonymous) annotated "wget" with "(no title)" at http://hpaste.org/7782#a2
06:57:12 <bla123> dcoutts_: ok, thanks, i guess i have a lot to fix now as i often download newer versions without recompiling everything that depends on it
06:57:16 <dcoutts_> bla123: http://blog.well-typed.com/2008/04/the-dreaded-diamond-dependency-problem/
06:57:17 <lambdabot> Title: blog.well-typed.com  Blog Archive  The dreaded diamond dependency problem, http://tinyurl.com/6hbfwv
06:57:46 <Saizan> Peaker: no one thinks the proc notation is very pretty, i think
06:57:48 <dcoutts_> bla123: it's something that cabal-install will deal with eventually, but not yet. I've got to replace the package dependency algorithm first.
06:58:47 <bla123> dcoutts_: ok, thanks a lot, as this is not the first linker problem i ran into, this was very enlightening. i'm seeing forward to the day cabal can do this automatically
06:59:39 <dcoutts_> bla123: if you use the latest version of cabal it'll warn you about these problems, but not fix them automagically
07:00:48 <bla123> dcoutts_: thats nice, i guess i should have updated more cabal and less all-important libraries ;-)
07:00:57 <dcoutts_> heh
07:01:00 <Leimy> Saizan: I find the proc notation to be a bit clunky I think.
07:01:11 <Leimy> Just started playing with arrows though
07:01:30 <Leimy> one of the greatest things about Haskell is the code is often beautiful
07:03:22 <Peaker> I wish code could BE the drawing - rather than be accompanied by such a drawing in the documentation, as so often happens with arrows
07:03:55 <quicksilver> any number of people have designed graphical progamming languages :)
07:03:59 <quicksilver> it's a really cool idea.
07:04:07 <quicksilver> none of them have been overwhelmingly successful though.
07:04:37 <Peaker> quicksilver, I would like to be able to switch back to "textual" notation at a press of a key shortcut :)
07:04:38 <Saizan> btw, do-notation have the same problem do a <- foo; b <- bar;
07:04:41 <Leimy> I've seen some languages that used layouts
07:04:55 <Leimy> and used XSLT and other weirdness to rewrite out other languages.
07:04:56 <Peaker> quicksilver, though I would never want the editor to emulate a teletype as I edit the code, even when shown textually :)
07:05:08 <quicksilver> epigram has a 2-d syntax
07:05:14 <quicksilver> although not really for these reasons :)
07:05:18 <quicksilver> it's cool in its way though.
07:05:26 <Leimy> I thought Microsoft did some stuff called Intentional Programming that was all about context sensitive languages.
07:06:59 <Peaker> Leimy, its not Microsoft, its a former Microsoft employee.. and he wrote some patent which I read to discover contains a lot of stuff I had in a little toy demo I made :(
07:07:15 <opqdonut> :\
07:07:18 <Peaker> lots of overlap between them and Subtext (www.subtextual.org) I hope Subtext is prior art
07:07:52 <Peaker> I would really hate to see this entire field stuck with Microsoft-ly software, due to stupid patents
07:12:22 <Vq^> Peaker: is that a big issue?
07:13:10 <Peaker> Vq^, I don't know - I hope to make a non-textual code editor for Haskell, in Haskell (which will take me a while, being a Haskell newbie), and when I do, I hope this patent won't be in the way
07:13:12 <Vq^> i thought those patents weren't applicable in most countries
07:13:19 <Bonus> [1..n] ++ [1...m] has a complexity of O(n), right?
07:13:28 <Bonus> i mean 1..m
07:13:33 <Peaker> well, I'm in Israel, and its probably not registered here
07:13:41 <mar77a> is there a way to force standard notation instead of scientific notation?
07:13:45 <quicksilver> Bonus: the (++) part is O(left side), yes.
07:13:50 <Vq^> Peaker: it's not about wheter it's registred
07:13:54 <Bonus> yeah, just checking to be sure
07:14:01 <Peaker> Vq^, How come?
07:14:03 <Bonus> cause i'm explaining lists to someone, wouldn't want to give them the wrong info
07:14:04 <Bonus> cheers
07:14:55 <Vq^> Peaker: software patents isn't valid where i live for example
07:15:10 <Vq^> Peaker: even if they are registred
07:15:32 <Peaker> Vq^, they are valid in Israel, I think
07:17:28 <opqdonut> Vq^: cli patents are, though
07:17:33 <opqdonut> afaik
07:17:53 <Peaker> cli?
07:18:26 <opqdonut> grah, i meant ui of course
07:18:29 <opqdonut> user interface
07:20:48 <mar77a> q: i'm trying to make a list with all the numbers from a stringed number, ie: "230" => [2,3,0]
07:20:58 <mar77a> this is what i tried: print $ map read (show (2^1000))
07:21:04 <mar77a> not sure what's wrong
07:21:20 <opqdonut> try digitToInt
07:21:58 <qebab> mar77a: you could get all the digits directly from a number (if it is integral) without going by way of a string
07:22:12 <mar77a> how?
07:22:50 <Deewiant> > map (\c -> ord c - ord '0') "230"
07:22:52 <lambdabot>  [2,3,0]
07:23:00 <mar77a> C :)
07:23:08 <opqdonut> > map digitToInt "230"
07:23:09 <lambdabot>  [2,3,0]
07:23:11 <dolio> > map digitToInt "230"
07:23:12 <lambdabot>  [2,3,0]
07:23:15 <opqdonut> much nicer than the ord solution
07:23:16 <mar77a> yeah looks better
07:23:18 <dolio> @yarr
07:23:19 <lambdabot> This is the END for you, you gutter-crawling cur!
07:23:22 <Deewiant> @src digitToInt
07:23:22 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:23:25 <Deewiant> d'oh
07:23:33 <mar77a> @src urmom
07:23:33 <lambdabot> Source not found. Sorry.
07:23:39 <mar77a> now you're polite...
07:24:00 <hpaste>  qebab pasted "One way to get the digits directly from an Integer" at http://hpaste.org/7831
07:24:37 <Deewiant> > reverse . map (flip mod 10) . takeWhile (/= 0) . iterate (flip div 10) $ 230
07:24:38 <lambdabot>  [2,3,0]
07:25:02 <quicksilver> > map read (show (2^1000)) :: [Int]
07:25:03 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
07:25:03 <qebab> cleverer :p
07:25:14 <mar77a> :t sum
07:25:16 <lambdabot> forall a. (Num a) => [a] -> a
07:25:22 <quicksilver> > map read . map (:[]) $ (show (2^1000)) :: [Int]
07:25:25 <lambdabot>  [1,0,7,1,5,0,8,6,0,7,1,8,6,2,6,7,3,2,0,9,4,8,4,2,5,0,4,9,0,6,0,0,0,1,8,1,0,5...
07:25:33 <quicksilver> mar77a: FWIW, there is the map read version.
07:25:54 <mar77a> > sum $ map digitToInt (show (2^1000))
07:25:55 <quicksilver> mar77a: yours didn't work becase the elements of that string are characters, not strings
07:25:55 <lambdabot>  1366
07:25:58 <mar77a> which is, quicksilver ?
07:26:04 <quicksilver> whaty I just typed.
07:26:14 <mar77a> whatsafok
07:26:55 <sclv_> that's a trick question, isn't it?
07:28:27 <mar77a> python dominates in proj euler :<
07:29:50 <qebab> mar77a: I list myself as python, but I use both C, Haskell and Scheme also. I think that a lot of the people there use more languages than one :)
07:30:30 <mar77a> yeah, figured
07:38:36 <seanmce> I'm giving a Haskell talk at my local Ruby users group next month. Any suggestions on what I should show them?
07:38:54 <matthew_-> clue bat?
07:38:57 <ndm> seanmce: a nice little application is usually la good idea
07:39:16 <ndm> seanmce: xmonad has been used before, tagsoup might be good - something little but highly potent
07:39:19 <monochrom> Will they ask about "something like ruby on rails but for haskell"?
07:40:06 <seanmce> I probably should show them at least HTML
07:40:14 <opqdonut> and parsec
07:40:29 <opqdonut> and cool tricks with laziness, ruby users can appreciate those
07:40:33 <Leimy> And tell them to not fear the monads
07:40:33 <ndm> quickcheck is another good one
07:40:35 <Leimy> :-)
07:40:38 <ndm> since it would be really hard in Ruby
07:41:02 <qebab> the "don't fear monads" thing is actually what made me scared of them in the first place
07:41:22 <seanmce> I found a good article on monads in ruby
07:41:23 <Leimy> qebab: Yeah but there's a really good video explaining why they're not so bad :-)
07:41:32 <Leimy> called "Don't Fear the Monads"
07:41:46 <seanmce> I'll check out the vid
07:41:59 <seanmce> can parsec be shown in a simple way?
07:42:12 <qebab> Leimy: they are not so bad when you are not scared of them, like I was
07:42:14 <quicksilver> parsec is only impressive to someone who has already written a parser.
07:42:31 <quicksilver> if your ruby have never gone beyond a few regexp matches
07:42:38 <quicksilver> then they'll think parsec is worse.
07:42:41 <Leimy> qebab: Eh, I found them really confusing from the get-go.
07:43:00 <ndm> i found monads scary too
07:43:14 <quicksilver> yeah, but ndm was bitten by one as a child
07:43:17 <quicksilver> he still has the scar.
07:43:19 <qebab> Leimy: I had a book that made me make a monad without telling me what it was before the end of the chapter
07:43:24 <ndm> its true...
07:43:29 <Leimy> qebab: sounds good
07:43:35 <qebab> Leimy: I felt cheated at first, but I didn't fear them after that :p
07:44:07 <seanmce> http://moonbase.rydia.net/mental/writings/programming/monads-in-ruby/00introduction.html
07:44:08 <lambdabot> Title: Monads in Ruby, Part 1: Introduction - Moonbase, http://tinyurl.com/d725u
07:44:26 <qebab> oh my god, there's a bee in my room
07:44:36 <qebab> they are a thousand times more scary than monads
07:44:48 * qebab flees
07:45:20 <Peaker> a bee far from its hive is not very aggressive
07:45:43 <Peaker> one got into my pants once, I guess it panic'd and bit me on the leg (whew) :)
07:45:52 <qebab> it took a sip from my coke, and then it left
07:46:03 <Peaker> it saw too many ads, maybe
07:46:12 <qebab> possibly
07:47:31 <Peaker> I have a bunch of png's in a directory, and there's SDL.Image.load in IO that can load them. I don't want to pre-load them all, but it could be nice to have some memoized loader. Is there an elegant way to create such a memoizer so that it lazily loads the images?
07:48:43 <Peaker> I guess it would be lazy/memoized if I just put them all in a lazy list, however I would like not to have to enumerate all the images - I have a function mapping some game parameters to an image (e.g which chess player, which piece, which color its on, etc)
07:49:32 <quicksilver> I would not describe it as elegant.k
07:49:38 <quicksilver> but you can do it with unsafePerformIO
07:50:04 <christastrophe> what does it mean exactly wrt ByteString.Lazy when it says that readFile will read a file lazily into a bytestring? does that indicate that IO will be preformed on demand?
07:50:18 <Peaker> quicksilver, I guess for now I'll see how bad it is to just always load the image to blit it
07:51:21 <quicksilver> hmm don't do that :)
07:51:25 <quicksilver> load them at startup time, once.
07:51:46 <quicksilver> or maintain a cache (Data.Map String Surface)
07:52:39 <Peaker> a cache would have to be "global" (I don't want to pass it around). I could make that with unsafePerformIO for a new IORef, or I could use a ReaderT around IO...
07:53:51 <quicksilver> ReaderT is passing it around, of course :)
07:54:11 <quicksilver> I find that graphics programs normally need a blog of 'graphics state' to store graphics resources
07:54:19 <quicksilver> blob, that was suposed to be.
07:54:32 <quicksilver> stuff like loaded files, offscreen buffers,
07:54:33 <quicksilver> etc
07:55:38 <mar77a> print $ filter (`d` 20) [1..]
07:55:44 <mar77a> how do i make that stop once it finds the first element?
07:56:00 <orbitz> why not just use remove?
07:56:09 <mar77a> o_o
07:56:28 <Peaker> mar77a, head $ the filter?
07:56:32 <quicksilver> head (filter (`d` 20) [1..])
07:57:55 <mar77a> let d n m = sum( ( map (n `rem`) [2..m]) ) == 0 in head $ filter (`d` 20) [1..]
07:57:59 <mar77a> > let d n m = sum( ( map (n `rem`) [2..m]) ) == 0 in head $ filter (`d` 20) [1..]
07:58:10 <lambdabot>  Exception: Time limit exceeded
07:58:17 <mar77a> :<
07:59:23 <christastrophe> would'nt dropWhile work in this case?
07:59:38 <christastrophe> @hoogle dropWhile
07:59:38 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
07:59:38 <lambdabot> Data.List.dropWhile :: (a -> Bool) -> [a] -> [a]
07:59:38 <lambdabot> Data.ByteString.dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
07:59:39 <Jaak> > let d n m = sum( ( map (n `rem`) [2..m]) ) == 0 in head $ filter (`d` 10) [1..]
07:59:41 <lambdabot>  2520
08:00:15 <quicksilver> head $ dropWhile  and head $ filter are rather similar.
08:00:24 <quicksilver> assuming you reverse the predicate
08:00:54 <christastrophe> i thought the issue was stopping on the first predicate match (or failure I guess)
08:01:23 <quicksilver> yes, band both solutions have that property
08:01:28 <Jaak> no need to stop if you have lazyness :P
08:01:29 <christastrophe> ah
08:03:26 <Peaker> emacs's Haskell-mode indentation sucks, I keep wanting the second option, it should reverse first/second indentation options
08:03:52 <quicksilver> use kuribas' version
08:04:00 <quicksilver> it's much better at guessing the one you likely want.
08:04:25 <Peaker> can't find it - any link?
08:04:28 <quicksilver> and lets you step through the options more logically.
08:04:45 <quicksilver> @where kuribas-indentation
08:04:45 <lambdabot> I know nothing about kuribas-indentation.
08:04:51 <dolio> http://kuribas.hcoop.net/haskell-indentation.el
08:04:53 <quicksilver> !
08:05:00 <quicksilver> wtf is wrong with LB's where database?
08:05:15 <dolio> @quote
08:05:16 <lambdabot> oerjan says: hotsmack
08:05:25 <quicksilver> @where+ kuribas-indentation http://kuribas.hcoop.net/haskell-indentation.el
08:05:26 <lambdabot> I will never forget.
08:05:29 <dolio> @quote dolio
08:05:29 <lambdabot> dolio says: Perhaps he's an epigram guy and frowns on Turing completeness.
08:05:36 <quicksilver> lambdabot: frankly I don't believe you.
08:05:47 <quicksilver> lambdabot: since that's the fifth time I asked you remember that URL.
08:06:04 <dolio> Clearly she's in denial about her frequent amnesia.
08:06:19 <quicksilver> Cale: why does LB keep losing her @where database?
08:06:33 <quicksilver> Cale: can we checkpoint it hourly or daily or something?
08:06:35 <quicksilver> .win 26
08:06:36 <Saizan> i think she keeps losing parts of its state in general
08:13:25 <Bonus> hmm
08:13:30 <Bonus> if I have
08:13:34 <Leimy> I'm beginning to think the way I wrote the parallel prime sieve with forkIO is the only way to parallelize that algorithm in Haskell.
08:13:38 <Bonus> myfun a = a*2 + a*2
08:13:42 <Bonus> will a*2 be computet twice?
08:13:45 <Bonus> or will it be memoized
08:13:50 <Bonus> computed*
08:14:24 <Leimy> the problem is that different stages of a prime sieve depend on one another before they can do their job.
08:14:31 <Leimy> so it's a streaming kind of parallelism.
08:14:36 <quicksilver> Bonus: computed twice, probably.
08:14:55 <Bonus> but in myfun a = let d = a*2 in d+d has it computed only once, right?
08:14:59 <quicksilver> right.
08:15:02 <Bonus> kewl
08:15:06 <Leimy> one spark wouldn't know it's input data until the prior one is done filtering.
08:15:12 <Leimy> er its
08:16:14 <Saizan> completely done?
08:16:21 <Saizan> where's the parallelism then?
08:16:28 <Leimy> Saizan: not completely done
08:16:35 <Leimy> but think of it as pipes
08:16:48 <Leimy> if the first process isn't there and running, it won't have the proper input
08:16:56 <Leimy> and I'm too new with par and pseq to grok how to do that :-)
08:17:23 <Leimy> 2s-handler | 3s-handler | 5s-handler
08:18:17 <Saizan> and as 2s starts producing output, 3s can starts crunching it in parallel?
08:18:17 <quicksilver> Leimy: that should 'just work' with sparks.
08:18:19 <Leimy> the 2s handler is what tells the 3s handler that it's going to handle 3s :-)
08:18:31 <quicksilver> Leimy: sparks will suspend until the data is there
08:18:42 <Leimy> before that it has no idea... so it has to be a late binding function that takes it's input off that stream.
08:18:55 <Leimy> at least, that's as far as I can tell
08:19:06 <Peaker> dolio: Thanks, but that doesn't seem to work on Hardy's Emacs 22.1.1
08:19:08 <Leimy> which is why I used typed data channels to do the concurrency, and then parallelism previously
08:19:44 <dolio> Ah. I use 23.0.60.1 (evidently).
08:19:46 <Leimy> the original input data is [2,3,4,5,6...] etc.
08:20:32 <Leimy> the 2's handler is only the 2s handler because that's the head of that list
08:20:59 <Leimy> it's job is to filter all things that are (flip mod 2) x /= 0
08:21:08 <Leimy> er its
08:21:12 <Leimy> dang I suck today :-)
08:21:44 <Leimy> the 3s handler has to filter out all (flip mod 3) x /= 0 things to the next handler, which is 5s, because the 2s already filtered out the 4 :-)
08:22:03 <Saizan> Leimy: it's not like you've to determine the parts you run in parallel statically, you can generate new ones as you go
08:22:18 <Leimy> Yeah but I'm not sure how to write the code.
08:22:36 <Leimy> I got as far as
08:22:46 <Leimy> well i'll hpaste it :-)
08:23:22 <hpaste>  Leimy pasted "steps towards pure parallel prime sieving?" at http://hpaste.org/7832
08:23:44 <Leimy> I feel I need to decompose that algorithm to make it go parallel.
08:24:00 <Leimy> Or is the parallelism on the "consing"?
08:25:48 <Saizan> random thought: sieve (x:xs) = x: let zs = filter (\y -> y `mod` x == 0) in zs `par` sieve zs
08:25:59 <Leimy> hmmm
08:26:23 <Saizan> but you need some strictess annotations
08:26:54 <Saizan> an expression like that is only going to compute the first cons cell in parallel
08:28:35 <Saizan> so yeah, like your parsieve but you've to name the argument to the recursive call, and make it compute in parallel
08:29:27 * Peaker is writing a GUI frontend to the chess thing -- after seeing FRP stuff I am paralyzed. I can't use ugly IORef's/etc anymore after seeing that, but I don't know how to implement FRP either! I am stuck!
08:29:52 <Leimy> Saizan: at one point I was taking the function for examine as a parameter... but that's just a single step
08:29:57 <Peaker> I don't know how to write the reactive mainloop...
08:29:57 <Leimy> it's the filters doing all the work though
08:30:01 <dolio> @yarr, too many split libraries that Ubuntu doesn't install by default.
08:30:01 <lambdabot> I want me grog!
08:30:01 <Leimy> and they should be run in parallel if possible
08:30:15 <Leimy> but they need to be piped into each other.
08:30:46 <Peaker> conal, ping
08:30:57 <Leimy> so the fundamental problem is I don't know how to connect a series of filters in parallel :-)
08:31:02 <Leimy> without explicit comms -)
08:31:05 <Saizan> Leimy: the piping part is done exaclty as normal haskell
08:31:20 <Peaker> any FRP library (+ tutorial, hopefully) I can use that lets me use SDL/etc (Not like FranTK)
08:31:24 <Saizan> i.e. what your parsieve does
08:32:06 <Saizan> you just pass things around as arguments
08:33:36 <Saizan> prallelizing only requires you to bind the computation to a name, apply an evaluation strategy and using par
08:33:54 <Saizan> *use
08:33:57 <saml> > foldl1 f [a,b,c,d,e] :: Expr
08:33:58 <lambdabot>  f (f (f (f a b) c) d) e
08:39:35 <hpaste>  (anonymous) annotated "steps towards pure parallel prime sieving?" with "(no title)" at http://hpaste.org/7832#a1
08:40:01 <Leimy> Saizan: that seems to be correct...
08:40:28 <Peaker> does ghc-6.8.2 support proc do syntax?
08:40:33 <Saizan> does it get you any parallelism?
08:40:39 <Leimy> I'll see in a second :-)
08:40:59 <Saizan> i guess not
08:41:23 <Saizan> Peaker: -farrows , i don't recall if there's a LANGUAGE flag
08:41:56 <Peaker> Saizan, thanks, could be nice if ghc hinted about -farrows when encountering that syntax :)
08:42:43 <orbitz> is someone goign to make a botnet plugin for lambda bot so we can run parallelized code on it ?:)
08:42:50 <mar77a> smooth, it only took an hour to solve but i finally got problem 5!
08:44:01 <quicksilver> if it took an hour you were doing it wrong ;)
08:44:38 <quicksilver> "an efficient implementation will allow a solution to be obtained on a modestly powered computer in less than one minute"
08:44:45 <tchakkazulu> :P
08:44:50 <Apocalisp> Euler?
08:45:03 <tchakkazulu> I have my old code. Way too much overhead.
08:45:08 <Peaker> who wrote the problems for project Euler?
08:45:20 <Apocalisp> Peaker: Euler himself. :-)
08:45:22 <orbitz> Euler did
08:45:36 <tchakkazulu> Only to find out that the final code was a one-liner <_<
08:45:36 <orbitz> he was resurrected using the necronomicon
08:45:55 <Peaker> oh ;)
08:46:05 <quicksilver> they were written by a bunch of people.
08:46:09 <quicksilver> One of them is called Colin.
08:46:11 <Peaker> mar77a, I think you need a multiplication of the superset of all the sets of primes that compose all the numbers 1..20
08:46:13 <mar77a> used this tchakkazulu : 17:06 < mar77a> > let d n m = sum( ( map (n `rem`) [2..m]) ) == 0 in head $ filter (`d` 20) [1..]
08:46:15 <quicksilver> The others probably aren't.
08:47:44 <tchakkazulu> mar77a: foldl1' lcm [1..20]
08:48:21 <Peaker> @src lcm
08:48:22 <lambdabot> lcm _ 0     =  0
08:48:22 <lambdabot> lcm 0 _     =  0
08:48:22 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
08:48:27 <mar77a> least common denominator?
08:48:30 <mar77a> or what
08:48:32 <Peaker> @type quot
08:48:32 <ziman> @src quot
08:48:33 <lambdabot> forall a. (Integral a) => a -> a -> a
08:48:33 <lambdabot> Source not found. Just try something else.
08:48:34 <tchakkazulu> least common multiple
08:48:51 <orbitz> > lcm 5 20
08:48:52 <lambdabot>  20
08:48:58 <ziman> > lcm -5 3
08:48:58 <lambdabot>        add an instance declaration for
08:48:58 <lambdabot>       (Num (a -> a -> a), Num (t -> a ...
08:49:02 <orbitz> > lcm 7 20
08:49:05 <lambdabot>  140
08:49:12 <Deewiant> > lcm (-5) 3
08:49:13 <lambdabot>  15
08:51:26 <Peaker> @type rec
08:51:28 <lambdabot> Not in scope: `rec'
08:51:43 <Peaker> what's Yampa's rec? (I think its Yampas but its not using qualified imports :-( )
08:51:59 <Deewiant> @hoogle rec
08:52:00 <lambdabot> Prelude.recip :: Fractional a => a -> a
08:52:00 <lambdabot> Data.Generics.Aliases.recoverMp :: MonadPlus m => GenericM m -> GenericM m
08:52:00 <lambdabot> Data.Generics.Aliases.recoverQ :: MonadPlus m => r -> GenericQ (m r) -> GenericQ (m r)
08:52:03 <tchakkazulu> Peaker: That's an arrow-specific construct, like do and proc and such.
08:52:15 <tchakkazulu> Peaker: For use with ArrowLoop instances.
08:52:26 <Peaker> tchakkazulu, what's ArrowLoop and what is rec?
08:52:33 <Peaker> @src ArrowLoop
08:52:33 <lambdabot> Source not found. That's something I cannot allow to happen.
08:52:37 <Deewiant> @hoogle ArrowLoop
08:52:38 <lambdabot> Control.Arrow.ArrowLoop :: class Arrow a => ArrowLoop a
08:53:13 <tchakkazulu> Peaker: do you know mdo (no typo)?
08:53:39 <tchakkazulu> Peaker: If so, rec is the Arrow-equivalent of what mdo is for Monads.
08:53:59 <Peaker> tchakkazulu, nope, maybe unacronym'd?
08:54:35 <tchakkazulu> Peaker: 'rec' just means 'recursive'. 'mdo' is like 'do', but with an 'm'.
08:54:46 <Deewiant> I've heard it allows for stuff like mdo { a <- f b; b <- g a; }
08:55:17 <tchakkazulu> Deewiant: Indeed.
08:55:55 <Peaker> Deewiant, do allows that too?
08:55:55 <tchakkazulu> Anyway, my knowledge on this subject is rather fuzzy, since I hardly ever use it, so sorry for not being much help besides that.
08:56:08 <Peaker> tchakkazulu, no problem, thanks
08:56:17 <Deewiant> Peaker: not to my knowledge?
08:56:30 <tchakkazulu> Peaker: Mind that the 'b' used in 'f b' is bound *after* a <- f b;
08:56:31 <Peaker> Deewiant, oh, I didn't notice the use of b there sorry :)
08:56:39 <Deewiant> :-)
08:56:53 <Peaker> so its for cummutative monads?
08:57:36 <hpaste>  Leimy annotated "steps towards pure parallel prime sieving?" with "Success?" at http://hpaste.org/7832#a2
08:57:49 <Leimy> same problem size, pretty good speed up
08:57:55 <Saizan> Peaker: it's desugared to mfix
08:58:04 <tchakkazulu> Peaker: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html section 8.3.3
08:58:06 <lambdabot> Title: 8.3. Syntactic extensions, http://tinyurl.com/y6v6by
08:58:22 <Leimy> Saizan: I must not forget to use "let" from time to time :-)
08:58:25 <Peaker> @type mfix
08:58:27 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
08:58:54 <chessguy> hiya #haskell-ers
08:58:57 <Saizan> Peaker: just like let .. in can be desugared with fix, i.e. value recursion, but it doesn't work only on commutative monads
08:59:52 <Saizan> Leimy: heh, it's how you request sharing to the compiler
09:00:35 <Leimy> Saizan: on my dual core machine I'm getting a minor benefit of oversubscribing too with this algorithm
09:00:43 <Leimy> but my overall CPU % utilization isn't terribly high
09:01:22 <Saizan> try with ..rnf zs `par` ..
09:01:45 <Leimy> I'm not at all familiar with that notation :-)
09:01:49 <Saizan> ?hoogle rnf
09:01:50 <lambdabot> Control.Parallel.Strategies.rnf :: NFData a => Strategy a
09:02:18 <Peaker> Except for Yampa, is there anything simpler that lets me use FRP? Or alternatively, a tutorial for Yampa that also explains about "rec", ArrowLoop, etc?
09:02:23 <Saizan> with ".." i just meant "rest of code"
09:02:42 <Leimy> ah rnf is a strategy!
09:02:47 <Leimy> I was just wondering that
09:02:47 <mar77a> how would i go around checking if a number is a palindrome
09:03:04 <Deewiant> how would you check whether a string is a palindrome
09:03:16 <Peaker> mar77a, a number cannot be a pallindrome - a particular representation of the number (in some numeric base, for example) may be
09:03:28 <mar77a> well, the number in base 10, basically show n
09:03:38 <Peaker> mar77a, then the question is as Deewiant put it :)
09:03:47 <mar77a> i have no idea :)
09:03:53 <mar77a> i know the pseudo code
09:03:58 <mar77a> but i have no clue how to write that in haskell
09:04:17 <mar77a> i'd compare the first+n with the last-n
09:04:23 <Peaker> a bit inefficient: someStr == reverse someStr ?
09:04:40 <mar77a> how's that inefficient?
09:04:49 <Peaker> it compares each pair twice
09:05:01 <Peaker> (if its indeed a pallindrome)
09:05:06 <Apocalisp> > (\s -> s == reverse s) "radar"
09:05:07 <lambdabot>  True
09:05:29 <Deewiant> you only need to check half way through, using reverse checks the whole lists
09:05:52 <mar77a> well i can afford it :)
09:06:06 <Deewiant> but since we're working with lists, to find out whether you're half way through means a call to length, which is again slow
09:06:12 <Saizan> can't you use some mathematical properties on the number relative to the base? rather than blindly compare the representation?
09:06:23 <mar77a> it's more intuitive this way
09:06:25 <Deewiant> yes, you can
09:06:33 <mar77a> i'm doing this to learn haskell, not math :<
09:06:48 <Apocalisp> > (\n -> let s = show n in reverse s == s) 32123
09:06:49 <lambdabot>  True
09:06:50 <Leimy> Saizan: that totally made my machine crawl :-)
09:07:12 <Leimy> the introduction of rnf into this algorithm made my mac almost unresponsive... for like 3 minutes
09:07:24 <Leimy> I'd say if that were meant to increase CPU utilization, it worked.
09:07:29 <Peaker> yay for modern software!
09:07:40 <Apocalisp> Wonder if there's an Arbitrary for palindromes.
09:07:48 <Peaker> Leimy, CPU overuse is not the cause of serious unresponsiveness (in my experience)
09:07:49 <Saizan> but it didn't help with performance, eh?
09:08:00 <Peaker> Leimy, thrashing virtual memory - swapping out everyone else seems to be the major cause
09:08:09 <Leimy> Saizan: much worse performance :-)
09:08:18 <quicksilver> if you just rnf'ed an infinite list
09:08:22 <quicksilver> or a very very long one
09:08:27 <Leimy> Saizan: but i ran it with just 1 core
09:08:28 <quicksilver> then that woudl indeed take all your memory ;)
09:08:55 <Leimy> quicksilver: ah indeed I did :-)
09:09:06 <Leimy> parprimes = parsieve [2 .. ]
09:09:12 <Leimy> but i'm evaluating it with take 20000 :-)
09:09:19 <Peaker> Deewiant, if Haskell let you compare identities, you could know you're halfway through by comparing the forward cons and the backward one
09:09:39 <Saizan> uhm, actually i'm not so sure how par works here
09:09:41 <Deewiant> compare identities? what do you mean?
09:09:45 <Peaker> Deewiant, or not, stupid idea from an imperative background :)
09:09:52 <Deewiant> :-)
09:10:07 <Deewiant> Peaker: what you could do is write a function which both reverses a list and gets its length at the same time
09:10:18 <Saizan> but par is not strict in its first argument, right?
09:10:25 <Deewiant> which might be best of both worlds... I'm not sure
09:10:31 <Peaker> Deewiant, could use a ByteString instead of a list, or a data-structure that also keeps a length-from-here-to-end-of-list in each cons
09:10:36 <Leimy> Saizan: it doesn't need to be as far as I can tell.
09:10:54 <Leimy> should I try rwhnf?
09:10:54 <Peaker> Deewiant, An array/bytestring would be even better, probably
09:10:56 <Deewiant> Peaker: of course, but I'm trying to work with just lists here to keep things simple
09:11:11 <Deewiant> Peaker: one could of course design the optimal data structure for comparing data with its reverse :-P
09:11:12 <Peaker> Deewiant, then I guess you have the optimal solution there
09:11:49 <Peaker> how do you guys implement your GUI mainloops?
09:12:06 <Peaker> do you generally write a UI for your Haskell programs?
09:12:08 <Leimy> Saizan: the other strategy I used was to fork a ton of sparks and then let the scheduler decide which ones needed to run
09:12:16 <Leimy> but that's not pure haskell parallelism
09:12:21 <Deewiant> I don't generally write UIs for any of my programs ;-)
09:12:39 <Peaker> Deewiant, how do you use your programs?
09:12:47 <Deewiant> command line parameters
09:13:01 <Deewiant> I generally don't write interactive programs
09:13:29 <Saizan> Leimy: you put rnf only on the LHS of `par` right?
09:13:29 <Deewiant> when I do, I just use stdin/stdout on the console, I rarely even go as far as curses
09:13:37 <Leimy> Saizan correct
09:13:39 <Leimy> it looked like this
09:13:40 <Peaker> I want to try out the FRP approach for a GUI but none of the FRP libraries seem usable without a few years of prior Haskell experience ...
09:13:56 <Leimy> parsieve (p:xs) = p : let zs = filter (examine p) xs in rnf zs `par` parsieve zs
09:14:08 <Peaker> Deewiant, I wrote a chess move generator (maybe later I'll try my luck with an AI too) but a stdin/stdout based UI is really annoying to use...
09:14:12 <mar77a> how come i can't do:
09:14:22 <mar77a> > take $ 2 (show 100)
09:14:22 <Leimy> but that zs is an inifite list
09:14:23 <lambdabot>   add an instance declaration for (Num (String -> Int))
09:14:34 <Deewiant> Peaker: I don't find it that bad... might depend on your program of course
09:14:35 <Leimy> made of [2 .. ]
09:14:59 <Leimy> or rather it's filtering on an infinite list :-)
09:15:07 <ziman> mar77a, because that translates as: take (2 (show 100))
09:15:09 <Saizan> i guess the scheduler is not preemptive enough for this to work
09:15:18 <mar77a> ziman: and?
09:15:19 <ziman> mar77a, and 2 cannot be applied to anything
09:15:23 <mar77a> ah
09:15:31 <mar77a> got it
09:15:31 <Peaker> Deewiant, well, printing a chess board via ascii art and then taking coordinates instead of clicking on them with the mouse is annoying
09:15:42 <Leimy> Saizan: I'm getting bad performance and more utilization out of rwhnf :-)
09:16:01 <Apocalisp> @let pal = s == reverse s
09:16:02 <lambdabot> Couldn't match expected type `[a]' against inferred type `Expr'
09:16:08 <Apocalisp> @let pal s = s == reverse s
09:16:09 <lambdabot> Defined.
09:16:20 <Peaker> Deewiant, I know how to make an ugly imperative UI but after seeing some FRP code, I don't want to :-(
09:16:26 <Deewiant> Peaker: just use algebraic chess notation :-)
09:16:35 <Saizan> Leimy: try rnf with a finite input, and see if that gets higher utilization
09:16:47 <Peaker> Deewiant, I don't know what that is but I doubt it will be easier than a mousy-clicky chess interface :)
09:16:50 <Leimy> probably can do :-)
09:17:59 <wolgo> Peaker algebraic notation is: Enghlish: Knight takes pawn at e4 : Algebraic Notation: Knxe4
09:18:33 <Peaker> wolgo, I use: E4 and then choose destination square from a "menu" (mostly designed this way to test the move generation code)
09:18:34 <Saul_> Is there a way to make the output of a function dependent on the type of the output without abusing type classes?
09:18:52 <quicksilver> that's not abuse.
09:18:59 <quicksilver> that's what type classes are for
09:19:04 <quicksilver> type-directed overloading.
09:19:11 <wolgo> Or (in english) Bishop takes rook at f6: bxf6
09:19:17 <Saul_> yeah you're right
09:19:32 <mar77a> print $ [take 5 (take n (show num)) | n <- [1..(length(show num)-5)] argh
09:19:40 <Saizan> however this doesn't seem a particulary parallelizable algorithm, it would if 2s-filter could produce output reasonably faster than the 3s-filter can consume it
09:19:44 <Saul_> I'll rephrase:
09:19:46 <Peaker> wolgo, that notation seems like it can be ambiguous sometimes (not for bishops, ofcourse)
09:19:59 <wolgo> How so?
09:20:15 <Peaker> wolgo, what if two knights can take the pawn at e4?
09:20:21 <wolgo> say for any n piece a capture is indicated by an x and the coordinate
09:20:34 <wolgo> Well then you have a double attack on a square
09:20:50 <Peaker> wolgo, Knxe4 is ambiguous then?
09:20:50 <Deewiant> Peaker: then it's disambiguated, say Ngxf3 or N5xf3 (to indicate column g or row 5 respectively)
09:20:57 <Saul_> transpose :: Matrix m n a -> Matrix n m a -- Is there are way to define the case where m is Zero and n is some number?
09:21:00 <Deewiant> K is for kings, btw
09:21:01 <Peaker> Deewiant, Unnecessarily complicated, IMO
09:21:11 <wolgo> You have to give the knight position
09:21:12 <Deewiant> Peaker: it's the standard used practically everywhere
09:21:15 <Peaker> Deewiant, E4->E2 and such is simple
09:21:39 <wolgo> like say a knight is on f3 and another knight is on d3
09:21:40 <Peaker> Saul_, pattern matching, you mean?
09:21:45 <Saul_> yeah sort of
09:21:47 <Leimy> Saizan: So the first thing I did was make it not an infinite list and run it "Serially".  It's about 2x faster and 99% CPU utilization.
09:21:49 <wolgo> you could both attack e5
09:22:01 <wolgo> SO Knfxe5
09:22:10 <wolgo> OR Kndxe5
09:22:13 <Leimy> Saizan: however, now that it's not an inifinite list... `par` with 2 cores isn't giving any benefit.
09:22:15 <titusg> how do I get pcre-light to find all matches? match (compile (S.pack "ab+") []) (S.pack "cabcabb") [] gives me one match, not two
09:22:19 <Peaker> wolgo, hard to read... F3->E5 is easier
09:22:27 <Saul_> although since I encode matrices as nested vectors, you will pattern match on the value Nil of type Vector Zero (Vector n a)
09:22:34 <Deewiant> Peaker: you get used to it, and it takes less space
09:22:35 <dons> titusg: you need to write a loop, i think
09:22:47 <Peaker> Deewiant, F3E5 then :)
09:22:47 <wolgo> Yeah it assumes that the player knows algebraic notation
09:22:49 <Saul_> and you want a result of type Vector n (Vector Zero a)
09:22:53 <wolgo> which someone should not assume
09:22:55 <Peaker> Deewiant, seems to take less space even
09:22:56 <Deewiant> Peaker: but you're right, that (called "long algebraic notation" IIRC) is clearer if you're not used to the std
09:23:01 <Deewiant> Peaker: not usually
09:23:09 <Saul_> so a vector of empty vectors (with the proper size)
09:23:17 <Deewiant> Peaker: and if you don't indicate captures and checks I'd say the std is actually clearer :-P
09:23:21 <titusg> dons: the presence of the anchored option made me think all matches was the default...
09:23:23 <Peaker> Deewiant, it seems like that notation is 4-6 chars long, and this is constantly 4 chars long
09:23:40 <ehird> How do I get Infinity again?
09:23:43 <Deewiant> Peaker: exactly, so you don't specify captures, checks, checkmates
09:23:48 <Deewiant> Peaker: so yours has less information
09:23:49 <Saul_> ehird: 1/0
09:23:49 <ehird> aha
09:23:50 <ehird> 1/0
09:23:50 <dons> titusg: i.e. /foo/g ?
09:23:56 <dons> that's not a primitive provided by the library
09:23:58 <Peaker> Deewiant, yeah, show those on a whole board with everything
09:24:07 <ehird> oh NO, Peaker is at UI design again?
09:24:08 <Deewiant> Peaker: and btw, this can have a length of 2-6: "d4" means to move a pawn to d4
09:24:20 <wolgo> right
09:24:26 <Peaker> Deewiant, ah
09:24:34 <wolgo> Knf3
09:24:38 <Apocalisp> @check \x -> x == reverse x
09:24:39 <lambdabot>  OK, passed 500 tests.
09:24:43 <wolgo> What about a castle
09:24:44 <Apocalisp> hrm
09:24:52 <Saizan> Leimy: that's because you start consuming the list as soon as you spark it, essentially requiring serialization, laziness already takes care of giving you the effect of pipes
09:24:55 <Apocalisp> id is reverse?
09:25:00 <Deewiant> Peaker: long algebraic notation generally does E2-E4 normally, E2xE4 for a capture, and E2-E4+ and E2-E4# for checks/mates
09:25:17 <Deewiant> Peaker: contrast that to e4, ex4, e4+, e4# ;-)
09:25:25 <titusg> dons: ok, so I'm confused -- how would I match recursively?
09:25:26 <wolgo> That is 4 3 or 5 chars
09:25:28 <dblhelix> Apocalisp: mmm, that's strange
09:25:37 <hpaste>  mar77a pasted "Compare to http://www.haskell.org/haskellwiki/Euler_problems/1_to_10#Problem_8 !" at http://hpaste.org/7833
09:25:39 <Peaker> Deewiant, I think I'd rather see the whole board :)
09:25:41 <Leimy> Saizan: yeah I figured the laziness was giving a benefit when the data was unbounded on one end... in terms of opportunties for the paralellism to kick in with a speedup
09:25:52 <dblhelix> @check \x y -> x + y == y + x
09:25:54 <lambdabot>  OK, passed 500 tests.
09:25:57 <wolgo> O-O or O-O-O
09:25:58 <Deewiant> Peaker: well sure, working through it in your head is tricky in any notation :-P
09:26:05 <dblhelix> @check \x y -> x `div` y == y `div x
09:26:06 <lambdabot>  Parse error at "x" (column 29)
09:26:06 <Saul_> Is there a way to use type information of the input for your output?
09:26:09 <dons> titusg: match, take the tail, match again. but looks like we should have a function for this, no?
09:26:18 <Saizan> @check \x -> (x :: [Int]) == reverse x
09:26:19 <dblhelix> heck \x y -> x `div` y == y `div` x
09:26:19 <lambdabot>  Falsifiable, after 4 tests: [-3,1,-2]
09:26:29 <Leimy> Saizan: however now that I'm running with rnf on a finite but big list... -N2 is 2x slower than -N1
09:26:30 <wolgo> O-O -> king side O-O-O -> queen side
09:26:40 <Leimy> I was better off with an inifnite list in fact
09:26:46 <Leimy> and no rnf'ng :-)
09:27:01 <wolgo> Hey Peaker, I am learning haskell, if you work on this I would like to see how you print the board and the pieces.
09:27:02 <Leimy> but the CPU utilization is indeed up :-)
09:27:13 <titusg> dons: yeah...:-) where is the tail available? match just gives the first match doesn't it?
09:27:14 <dblhelix> Saizan: okay, but what gets tested without the type signature? x :: [ () ] ?
09:27:15 <dmwit> Saul_: I think somebody was recently asking this exact question (about transposing matrices).
09:27:24 <Saizan> dblhelix: yes
09:27:26 <Peaker> wolgo, I have a command-line stdin/stdout working one, and print characters to represent pieces on the board
09:27:28 <dmwit> Saul_: Was it you, or should I try to dig up the relevant hpaste?
09:27:32 <Apocalisp> Saizan: Thanks
09:27:41 <Saul_> dmwit: That might have been me, but maybe not
09:27:45 <Peaker> wolgo, trying to create a GUI now but I don't want to use ugly imperative stuff (which I guess I will)
09:27:58 <dmwit> Saul_: (By recently, I mean, say, a month ago.)
09:27:59 <dblhelix> Saizan: mmm, that's unfortunate default :-)
09:28:10 <dblhelix> Saizan: especially, for this particular example
09:28:15 <Saul_> dmwit: Yeah that sounds about the same time as I asked
09:28:16 <wolgo> Peaker: if it is not too much of a horrible task can you put it on hpaste? Or some other paste if it is >5k
09:28:33 <wolgo> This sounds pretty cool.
09:28:38 <Peaker> wolgo, hmm its a bunch of files, maybe it can be uploaded somewhere?
09:28:40 <Saizan> Leimy: that means you don't have any parallelism to exploit there i think
09:28:49 <wolgo> That is what I thought.
09:28:50 <dmwit> Saul_: Okay, I won't bother digging that up, then. =P
09:28:54 <wolgo> Ok!
09:29:11 <wolgo> The tar.gz would be relatively small no?
09:29:15 <Leimy> Saizan: but this same structure, with explicit data channels does get a significant speedup
09:29:51 <Saizan> Leimy: does explicit data channels perform better than the simply serial algorithm?
09:30:01 <Leimy> Saizan: that's what I need to figure out
09:30:04 <Leimy> I haven't timed those yet :-)
09:30:28 <Apocalisp> @check \s -> pal ((s::String) ++ reverse s)
09:30:29 <lambdabot>  OK, passed 500 tests.
09:30:41 <Saizan> i guess what benefits from 2-cores with the channels is just the overhead introduced by the channels
09:30:47 <sclv_> Leimy: take a look at the merge algo here. http://www.haskell.org/haskellwiki/Prime_numbers
09:30:48 <lambdabot> Title: Prime numbers - HaskellWiki
09:31:03 <Leimy> Saizan:  http://hpaste.org/7766
09:31:16 <Leimy> Saizan: I also explicitly create a ton of Sparks
09:31:28 <Peaker> wolgo, tgz is 4.7KB
09:31:45 <Leimy> Saizan: and the scheduler seems to figure those out pretty well
09:32:19 <sclv_> Something based on that with each spark processing a bounded list of products of primes up to whatever might be cute.
09:32:35 <Peaker> can you take DCC file transfers?
09:32:37 <Leimy> sclv_: this is the "actor" method :-)
09:33:04 <Leimy> anyway... I gotta get some stuff done here.
09:33:15 <sclv_> ok, cheers.
09:33:20 <Leimy> thanks for the help!
09:33:41 <Peaker> wolgo, http://nextflow.dyndns.org/chess.tgz
09:34:35 <wolgo> sorry I was blocking transfers
09:35:00 <Peaker> wolgo, got the tgz?
09:35:11 <tantalum> What is a godd haskell image manipulation library?
09:35:27 <Peaker> wolgo, nm dcc, use http://
09:35:29 <wolgo> Not yet
09:36:02 * SamB_XP wonders if set theory is actually good for anything
09:37:56 <wolgo> I got it :) thanks
09:38:11 <Syzygy-> SamB_XP: Confusing philosophers.
09:38:32 <wolgo> Alright, I need to do some actual work.
09:38:44 <SamB_XP> Syzygy-: ... I thought philosophers were naturally like that
09:38:51 <wolgo> Haskell is not a good thing when you work from home
09:39:03 <wolgo> At least when you are learning it.
09:39:05 <SamB_XP> wolgo: it depends what you do
09:39:06 <Syzygy-> Sure, but in order to really drive them over the edge, se ttheory is useful.
09:39:29 <wolgo> I am not a programmer by trade.
09:39:32 <SamB_XP> and it has the unfortunate fact that it seems to confuse students of mathematics
09:40:04 <wolgo> SamB_XP haskell does?
09:40:09 <SamB_XP> and ... is hard to implement computations in terms of
09:40:13 <Peaker> I give up, I'll write my chess GUI with IORefs :(
09:40:13 <SamB_XP> wolgo: no! set theory
09:40:28 <wolgo> Oh
09:41:07 <wolgo> BRB!
09:43:17 <Baughn> Peaker: Are you writing your own chess engine too?
09:43:46 <Peaker> Baughn, yeah - Haskell practice
09:43:50 <Baughn> (And aren't IORefs thread-unsafe? I'd rather stick to MVars and optimize at need)
09:44:02 <Peaker> Baughn, I don't use threads
09:44:18 <Baughn> Peaker: You should. You could evaluate more positions, faster. ;)
09:44:21 <Peaker> Baughn, also, I plan to throw away any IORef code and replace it with FRP code once I understand how to use FRP
09:44:24 <SamB_XP> Baughn: ... right
09:44:26 <Peaker> Baughn, I have just 1 core :)
09:44:40 <astrolabe> FRP?
09:44:43 <Baughn> SamB_XP: Well, you /could/
09:44:46 <Peaker> Functional Reactive Programming
09:44:51 * astrolabe is writing a go problem solver
09:44:59 <astrolabe> (in haskell)
09:45:05 <SamB_XP> Baughn: that wouldn't necessarily even need the use of explicit threading on his part
09:45:24 <Peaker> Baughn, the chess engine is purely functional, but I am working on a GUI now, using the stdin/stdout interface is too annoying
09:45:26 <SamB_XP> possibly he could just go forward in time and use GHC 6.10
09:45:46 <Peaker> SamB_XP, how will it do automatic threading?
09:45:52 <SamB_XP> with NDP that is supposedly actually fast
09:45:56 <Peaker> SamB_XP, NDP?
09:46:03 <BMeph> astrolabe: Got a Gomoku solver yet? ;)
09:46:05 <SamB_XP> Nested Data Parallelism
09:46:05 <Baughn> SamB_XP: Well, true..
09:46:16 <Peaker> SamB_XP, That still requires explicit threading specifications (for the data)?
09:46:25 <SamB_XP> Peaker: not precisely
09:46:28 <astrolabe> BMeph: The relation with go is only superficial :)
09:46:30 <Peaker> SamB_XP, oh, what then?
09:46:39 <Peaker> SamB_XP, I need to specify "This is a parallel array" right?
09:46:45 <SamB_XP> Peaker: well, yes
09:46:47 <BMeph> astrolabe: True - but it's still fun! :)
09:46:56 <SamB_XP> but that's a lot simpler than explicit threading!
09:47:16 <SamB_XP> and NDP is even useful without the P
09:47:18 <Peaker> SamB_XP, Ah, I'd rather have the runtime do some heuristics/profiling on my functions, determine which ones are very likely to require large execution times, and spawn them off to other threads if those are available..
09:47:22 <SamB_XP> IMO
09:47:55 <Peaker> SamB_XP, (Purely functional computations can auto-thread that way, if I understand things correctly)
09:48:07 <SamB_XP> Peaker: hah
09:48:15 <Peaker> SamB_XP, Why not?
09:48:25 <SamB_XP> they used to think so ;-)
09:48:35 <Peaker> they don't think so anymore?
09:48:40 <SamB_XP> well. I guess you COULD do that at runtime...
09:49:02 <SamB_XP> but then you'd need to have code that the RTS could decipher well enough to do that...
09:49:10 <SamB_XP> there is this "par" thing
09:49:27 <BMeph> Sounds like we need a more modular runtime engine, the better to introduce plugins. :)
09:49:48 <SamB_XP> which does the "spawn them off if other threads are available" bit
09:50:03 <Peaker> SamB_XP, but why not "par" everything?
09:50:10 <Saul_> I'm trying to use -XPatternSignatures, but if I try something like f (x::a) = x then it says that the type variable a isn't in scope
09:50:15 <Peaker> SamB_XP, due to small functions not being worth the spawn-off overhead, right
09:50:20 <Peaker> SamB, s/right/right?
09:50:23 <Saul_> does anyone know what I'm doing wrong?
09:50:25 <SamB_XP> Peaker: I expect there is an SPJ paper that either explains this or references other papers that do
09:51:22 <dblhelix> Saul_:  I think you need to explicitly introduce the variable a in the signature of f
09:51:24 <SamB_XP> but, I mean, that had been the holy grail of functional parallelism...
09:51:30 <dblhelix> f :: forall a. a -> ...
09:52:14 <tantalum> I need to create a bunch of images in haskell and save them to disk. What is a good library that can help with loading/saving images and accessing there pixel information?
09:52:20 <SamB_XP> dblhelix: so it implicitly activates scoped type variables?
09:52:39 <dblhelix> SamB_XP: indeed, but it's just a guess
09:52:54 <SamB_XP> tantalum: well, I usually use the pnm formats
09:53:18 <BMeph> Saul: lists are written with one colon in Haskell. :)
09:53:23 <Saul_> dblhelix: If I do that, it says I need -XTypeOperators
09:53:25 <BMeph> Types use two.
09:53:56 <Peaker> I wanna barf on my IORef code
09:54:01 <dblhelix> Saul_: no, that hint is just incorrect (I saw GHC emitting it): you need explicit quantifiers
09:54:19 <pejo> Peaker, check SPJ's homepage for data parallell haskell stuff, but basically you're right - often par costs more than you get from it.
09:54:19 <tantalum> pnm?
09:54:22 <Peaker> now I need some GUI state (to implement drag&drop and so I have to add IORefs and pass em too around. Yuck! If I do imperative work I at least want OO
09:54:32 <Saul_> dblhelix: do you know what flag that is?
09:54:38 <Peaker> pejo, so some runtime profiling + heuristics can guess where its worthwhile to put a par?
09:54:42 <SamB_XP> tantalum: but maybe the gtk2hs library has something you can use?
09:55:03 <SamB_XP> tantalum: what kind of images are you creating anyway?
09:55:17 <tantalum> yeah I was looking at that and I was also looking at the SDL-image library
09:55:24 <dcoutts_> tantalum: pnm is not a bad choice, it's simple
09:55:29 <SamB> http://netpbm.sourceforge.net/
09:55:30 <lambdabot> Title: Netpbm home page
09:55:50 <SamB> http://netpbm.sourceforge.net/doc/#formats
09:55:50 <lambdabot> Title: User manual for Netpbm
09:55:58 <dblhelix> Saul_: I am browsing Distribution.Extension, but I don't see it in there
09:56:31 <pejo> Peaker, I'm not sure, you need to find someone with more experience of this (dons maybe?).
09:56:35 <SamB> dblhelix: scoped type variables?
09:56:43 <SamB> dblhelix: higher-order polymorphism?
09:57:34 <Saul_> dblhelix: Hmmz if I use -fglasgow-exts it works fine, even without the forall
09:57:40 <tantalum> I'm writing a pttern generator that I want to use to make some cool pictures, just for fun but after that I was thinking about doing some image manipulation of recognition
09:57:47 <tantalum> *pattern
09:57:54 <dblhelix> SamB, Saul_: ScopedTypeVariables seems to do the trick
09:58:13 <dblhelix> SamB:
09:58:16 <dblhelix> Saul_:
09:58:18 <SamB> Peaker: you are right: some runtime profiling and heuristics can be used to figure out where to put the par. your job is to perform the heuristics.
09:58:27 <dblhelix> indeed: even without forall
09:58:48 <Peaker> SamB, you don't think its possible to automate it?
09:59:13 <hpaste>  dblhelix pasted "(no title)" at http://hpaste.org/7834
09:59:21 <tantalum> What I'm looking for is something like ImageMagic but works with haskell
09:59:31 <Saul_> dblhelix: Ok thanks
09:59:32 <SamB> Peaker: I suppose it might be possible
09:59:35 <dblhelix> Saul_: http://hpaste.org/7834
09:59:44 <dblhelix> Saul_: you're welcome
09:59:53 <SamB> *IF* you could figure out how to add the pars at runtime
10:00:12 <SamB> and how to take them out if they didn't seem to be helping anymore
10:02:11 <SamB> tantalum: there might be bindings?
10:02:45 <SamB> hmm, doesn't look promising
10:03:11 <orbitz> SamB: 7th heaven is on
10:03:27 <orbitz> SamB: and wargames. I can't decide which to watch!
10:03:52 <SamB> wargames is that cool movie?
10:10:29 <SamB> huh. I wasn't sure what to expect from these slides about "How to Be Both Lazy and Reasonable" by a tim chevalier, since they were for a talk to a "scholarship skills" class...
10:10:58 <SamB> (lazy as in avoiding excessive work, or lazy as in the evaluation strategy?)
10:11:56 <doun> SamB: same fing, I reckons!
10:12:22 <SamB> doun: well, I meant *human* work
10:12:27 <SamB> not CPU work
10:12:40 <doun> I know :P
10:13:23 <BMeph> "What's the difference?" ;)
10:13:49 <SamB> well, I can read a book while the CPU does work
10:13:53 <SamB> in theory
10:14:12 <SamB> I supposedly do not have to stare at the screen until it finishes compiling or whatever!
10:14:27 <doun> but you still do it anyway :((
10:14:34 <SamB> sometimes
10:14:48 <SamB> especially if I'm being too optimistic about how long it will take
10:15:54 <SamB> tantalum: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsmagick ?
10:15:57 <lambdabot> http://tinyurl.com/5cpj9z
10:17:28 <tantalum> SamB: nice... I was looking at some Cairo stuff to see if that would work. I googled imagemagic but I didn't see thoes bindings
10:17:59 <dcoutts_> tantalum: cairo is appropriate if you're doing mostly vector graphics, not if you're doing mostly bitmap
10:18:21 <dcoutts_> though it's also ok if you're compositing lots of bitmap images together
10:18:23 <SamB> tantalum: well, perhaps that's because "graphicsmagick" /= "imagemagick" ?
10:18:52 <SamB> dcoutts: it sounded like he just wanted to read/write them
10:18:59 <dcoutts_> mm
10:19:03 <dcoutts_> overkill then
10:19:51 <Peaker> yay, I have ugly-ass IORef gui for my chess engine :)
10:20:51 <SamB> ugly-ass code, or ugly-ass on screen?
10:21:11 <doun> human ugly or computer ugly?
10:21:19 <doun> :-P
10:21:32 <SamB> computers don't understand ugly yet, sadly
10:21:34 <Peaker> SamB, both, currently :)
10:21:35 <nburlett> off topic, but is anyone here familiar with timestamps in sqlite3?
10:21:45 <Peaker> SamB, its decent on screen, but could be prettier
10:21:57 <Peaker> the code/architecture is completely non-scalable.. a global game state, yech
10:22:07 <SamB> if they did, I would be able to do google searches for beautiful mathematical things directly
10:22:13 <tantalum> Basicly I want to read an image, mess around with the pixels a bit and then write it back to disk
10:22:52 <SamB> Peaker: you mean you use unsafePerformIO to allocate those IORefs?
10:23:15 <Peaker> SamB, no but I pass an IORef GameState record to everyone and everyone reads/writes into it
10:23:24 <Peaker> SamB, to everyone being event handler and game drawer
10:24:17 <SamB> besides which, is there much demand for scalable chess UIs?
10:24:19 <Peaker> SamB, OOP would be nice than this
10:24:31 <Peaker> SamB, scalable as in - will be reasonable to add new featurse
10:24:36 <SamB> OH
10:24:46 <Peaker> maybe that's the wrong word..
10:24:52 <SamB> I was thinking "could play more than one game at a time" when you said scalable
10:24:58 <Peaker> oh
10:24:59 <SamB> the word is "maintainable"
10:25:44 * SamB thinks most people would be happy to start another process to launch another chessboard -- happy to do so, even
10:25:48 <SamB> er.
10:25:59 <SamB> I meant, I think they would even prefer it
10:26:46 <Deewiant> not on windows
10:27:00 <Deewiant> where the simple act of starting a process takes upwards of a second :-P
10:27:41 <Peaker> oh damn - I downloaded free chess graphics - and only now I realized that they use whole square png's, where I need transparent piece png's or I cannot have reasonable drag graphics for the piece
10:27:48 <Peaker> I'll draw the whole square for now, I guess
10:28:42 <kevinu> you should probably redesign it entirely in opengl with md5 model formats and then gpl it and give me the link
10:29:37 <Peaker> kevinu, the code sucks (mainly for the GUI) :-(
10:30:58 <lament> Peaker: write a chess teaching program
10:31:16 <kevinu> i think those are called books
10:31:55 <lament> chess teaching programs?
10:31:56 <Peaker> lament, How would I know how to teach chess? :-)
10:32:02 <Peaker> lament, teach as in basic movement?
10:32:06 <Peaker> lament, or strategy/etc?
10:32:15 * Peaker is no chess strategy general
10:32:38 <lament> you could have an ai point out player's mistakes
10:33:55 <Peaker> that could be interesting
10:34:16 <kevinu> it would get confusing because take the game start for example with all pieces in initial possition, there is every mistake possible and you'd have to play a long movie showing em all
10:34:26 <ddarius> Peaker: I imagine you could set the background color to transparent in about 3 seconds in an image editor.
10:35:14 <Peaker> ddarius, good idea
10:35:31 <Peaker> funny how a 30 minute project has already grown to 2-3 days
10:35:55 <kevinu> yep, software development for ya
10:38:57 * SamB likes that in Agda, a "map" function for dependent pairs can be made that is not excessively painful
10:40:53 <noecksit> @undo t <- forkIO $ bracketLoop; writeIORef tid d;
10:40:54 <lambdabot>  Parse error at "<-" (column 3)
10:41:09 <wjt> @undo do t <- forkIO $ bracketLoop; writeIORef tid d
10:41:10 <lambdabot> forkIO $ bracketLoop >>= \ t -> writeIORef tid d
10:41:38 <noecksit> oh thanx
10:41:49 <noecksit> @undo do t <- forkIO $ bracketLoop; writeIORef tid t;
10:41:49 <lambdabot> forkIO $ bracketLoop >>= \ t -> writeIORef tid t
10:42:34 <Deewiant> hmm, isn't that actually incorrect?
10:42:51 <Deewiant> doesn't the $ make that the same as forkIO (bracketLoop >>= \t -> writeIORef tid t)
10:43:01 <Deewiant> and not (forkIO bracketLoop) >>= \t -> writeIORef tid t
10:43:18 <mauke> doesn't forkIO return () anyway?
10:43:32 <noecksit> Deewiant: oh yea, thats why i keep getting the error, i keep forgetting about $ having lowest precedence
10:43:35 <Deewiant> @ty forkIO
10:43:37 <lambdabot> Not in scope: `forkIO'
10:43:40 <Deewiant> @hoogle forkIO
10:43:40 <lambdabot> GHC.Conc.forkIO :: IO () -> IO ThreadId
10:43:40 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
10:43:44 <Deewiant> evidently not
10:43:58 <mauke> ah, d'oh
10:43:59 <Deewiant> noecksit: just use do-notation and you'll be safe ;-)
10:44:06 <mauke> it's the thread itself that has to return ()
10:45:58 <doun> hehe
10:48:02 <roconnor> > 247.09 + 15.36
10:48:04 <lambdabot>  262.45
10:48:20 <roconnor> > 262.45/3
10:48:21 <lambdabot>  87.48333333333333
10:48:29 * SamB CCs a mailing list in a non-reply email for what he believes to be his first time ever
10:50:33 <Peaker> yay I have a decently-looking (horror code) GUI chess frontend
10:50:42 * SamB wonders how you use input methods with Mozilla-based browsers
10:53:41 <Peaker> http://nextflow.dyndns.org/chess.tgz -- you can download this and compile guichess -- and play a hotseat game of chess heh
10:53:53 * Peaker gtg
10:54:53 <Lycurgus> SamB: js/ajax?
10:56:48 <Lycurgus> if you mean like scim, should be transparent if js level stuff not char set restricted
11:01:09 <SamB> Lycurgus: well, the problem is the menu items just aren't there for me to activate SCIM
11:01:23 <SamB> at least, that's how I see it
11:01:33 <SamB> for all I know, it could be deeper than that!
11:01:50 <Lycurgus> yeah that's all complete indepedent of the apps
11:02:16 <SamB> Lycurgus: well, try right clicking in a text field in Iceweasel
11:02:31 <SamB> do you see the "Input Methods" item?
11:03:26 <Lycurgus> not familiar with Iceweasel, I've got SKIM installed but haven't got my desktop working with all the character sets I want to use, Hanzi in particular.
11:03:49 <SamB> what browser do you use?
11:03:59 <Lycurgus> though I have verified operation of Cangjie in a SCIM enabled xterm
11:04:08 <SamB> Iceweasel is actually just the non-trademark-encumbered version of Firefox...
11:04:08 <Lycurgus> seamonkey or ff
11:04:16 <Lycurgus> ie on DOS
11:04:21 <gubagem> am I an evil newbie if I want to use some sort of arrays in haskell? and how would I do it
11:04:35 <SamB> xterm can do SCIM?
11:04:37 <Lycurgus> safari on mac
11:04:51 <SamB> Lycurgus: IE doesn't support DOS as far as I know
11:05:04 <SamB> I admit that I've never tried it, though
11:05:12 <Lycurgus> yes, it's a special version though, maybe rxvt would have to check
11:05:12 <Korollary> gubagem: See Data.Array
11:05:28 <Lycurgus> and it's renamed something
11:05:29 <SamB> but I also don't have a TCP/IP stack or even ethernet device drivers for DOS, or knowlege of the interfaces thereof
11:05:35 <gubagem> korrollary: thank you
11:05:45 <gubagem> but am i eveil for wanting that?
11:06:03 <Lycurgus> (DOS==Windows)
11:06:12 <Deewiant> depends on why you want it, I guess
11:06:15 <SamB> Lycurgus: simply not true
11:06:35 <gubagem> i want to count digits in a number and have a tally for each digit
11:06:37 <SamB> though Windows 95 does come rather close
11:06:58 <Deewiant> I guess that's fine
11:06:59 <Lycurgus> does this notation work better: DOS := Windows?
11:07:16 <mauke> gubagem: you could also use a Data.Map for that
11:07:23 <gubagem> I just wrote it in scheme, but I want to see how it would look and how much faster it would be in haskell
11:07:23 <SamB> Lycurgus: no! now you are shadowing one of my favorite OSes
11:08:17 <erg0t> DOS?
11:08:28 <SamB> erg0t: why not?
11:08:41 <erg0t> you are right
11:08:45 <Lycurgus> (cxterm it's called)
11:09:24 <Lycurgus> ( http://cxterm.sourceforge.net/ )
11:09:24 <lambdabot> Title: CXTERM's UnOfficial Homepage on SourceForge.net
11:10:13 <roconnor> what's the latex for banana brackets?
11:10:25 <roconnor> \lbanana \rbanana?
11:10:40 * RayNbow opens LaTeX symbol table
11:11:01 <RayNbow> hmm, no hits...
11:11:06 <roconnor> :)
11:11:10 <RayNbow> ah
11:11:17 <SamB_XP> you could always ask the paper authors
11:11:24 <RayNbow> llparenthesis
11:11:28 <Lycurgus> should be in amstex
11:11:29 <RayNbow> rrparenthesis
11:11:40 <RayNbow> page 55
11:11:44 <RayNbow> symbols-letter.pdf
11:12:08 <orbitz> roconnor: this is what I get when google banana brackets
11:12:10 <orbitz> http://www.springerlink.com/content/77t3588175m4h5n7/
11:12:11 <lambdabot> Title: SpringerLink - Book Chapter
11:12:18 <RayNbow> roconnor, I recommend downloading a copy of ftp://tug.ctan.org/pub/tex-archive/info/symbols/comprehensive/symbols-letter.pdf
11:12:19 <roconnor> ⦇
11:12:21 <SamB_XP> paper authors who introduce notation using possibly unfamiliar symbols ought to include appendices in the preprint version saying how to get the funky symbols
11:12:43 <SamB_XP> (if they can't just say it in the main text)
11:12:43 <roconnor> oh
11:12:53 <roconnor> okay, how do I do it in TeXmacs now. :P
11:13:11 <RayNbow> no idea
11:13:13 <SamB_XP> roconnor: well, you figure out what glyph in what font ...
11:13:21 <SamB_XP> and then you figure out how to tell that to TeXmacs!
11:13:50 <orbitz> hrm
11:13:53 * roconnor wonder if he actually wants to write banana brackets
11:13:53 <orbitz> i need to shave my chest again
11:13:56 <orbitz> it's so hairy
11:13:57 <SamB_XP> well, hopefully you don't need to do that but I bet it is nearly that bad
11:14:10 * roconnor hands orbitz some barbed wire
11:14:17 <orbitz> what abou tbananas?
11:14:25 <lynn> wat
11:14:41 <orbitz> simons girlfriend on 7th heaven is a real jerk
11:14:51 <lynn> hi
11:14:56 <dolio> How can you watch that show?
11:15:13 <orbitz> dolio: i have functioning optical nerves
11:15:20 <SamB_XP> orbitz: he doesn't think you can shave with a banana
11:15:22 <orbitz> functional, made from bananas and barbwire
11:15:29 <roconnor> orbitz: I don't think bananas are used for shaving.
11:15:35 <orbitz> roconnor: shaving cream
11:15:37 <lynn> dnt knw abou any show, want to chat
11:15:49 <orbitz> lynn: 7th heaven
11:15:49 <dons> Cale: http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/24#monad_fail
11:15:50 <lambdabot> Title: Haskell hacking
11:15:57 <dolio> @vixen lynn wants to chat.
11:15:58 <lambdabot> You should add me to your buddy list!
11:17:04 <RayNbow> dons: thousands hours of MSPAINT?
11:17:31 <roconnor>  \bigbosonloop
11:17:52 <orbitz> can you express  a recursive function with lambd anoation?
11:18:11 <roconnor> orbitz: you need to use fix
11:18:13 <mauke> (\f -> f f) (\f -> f f)
11:18:15 <dolio> You can in the untyped lambda calculus.
11:18:20 <roconnor> oh
11:18:23 <roconnor> right
11:18:27 <Deewiant> @ty \f -> f f
11:18:28 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
11:18:28 <lambdabot>     Probable cause: `f' is applied to too many arguments
11:18:28 <lambdabot>     In the expression: f f
11:18:30 <dolio> Otherwise you'll need a primitive.
11:18:52 <dolio> Or type wrappers in Haskell, for instance.
11:18:54 <roconnor> or use the data Mu a = Roll {unRoll :: a -> Mu a} type.
11:19:09 <ddarius> dons: Just because fail is ugly doesn't mean the NotJustMaybe idiom is.
11:19:11 <roconnor> @seen Cale
11:19:11 <lambdabot> Cale is in #haskell, #haskell-overflow and #ghc. I last heard Cale speak 12h 13m 28s ago.
11:19:37 <lynn> will like to chat wit u
11:19:40 <SamB_XP> ddarius: fail is only ugly because we haven't figured out how to explain it properly
11:19:46 <orbitz> lynn: 86/f/korea
11:19:47 <roconnor> @tell Cale How do you feel about adding data Mu a = Roll {unRoll :: a -> Mu a} to lambdabot?
11:19:48 <lambdabot> Consider it noted.
11:19:59 <dons> ddarius: sure. it introduces new changes to crash haskell programs.
11:20:08 <SamB_XP> also possibly the fact that it takes a String
11:20:08 <dons> Map.lookup .. fail.
11:20:54 * chessguy stomps on orbitz' toe
11:20:55 <SamB_XP> ... oh, and obviously it's not in a sensible class
11:20:56 <lament> thunk/thunk/thunk
11:21:07 <SamB_XP> that part was so obvious I almost forgot to say it
11:21:07 <vixey> roconnor: what can you do with Mu?
11:21:15 <vixey> roconnor: and no other types..?
11:21:25 <gubagem> cant you use the Y combinator to make lambdas recursive?
11:21:35 <vixey> gubagem: not in haskell
11:21:46 <gubagem> why not? cause its typed?
11:21:50 <vixey> yes
11:21:54 <vixey> but you can use fix instead
11:22:01 <dolio> gubagem: You can't type some of the subterms of the Y combinator in Haskell without wrapping or unsafe coerce or the like.
11:22:27 * gubagem needs his 'head' fix(ed)
11:22:50 * Taggnostr needs to understand haskell syntax asap
11:23:03 <dolio> I've got a file here somewhere...
11:23:30 <hpaste>  dolio pasted "y-combinators" at http://hpaste.org/7835
11:23:35 <orbitz> oh those crazy camdens
11:23:39 <sclv_> oh wow, I just realized that fail taking a string is an example of what derrida would have called "logocentrism"
11:23:43 <roconnor> vixey: you can do (\f -> unroll f f) (Roll (\f -> unroll f f)) ... or something like that
11:23:45 <dolio> Oh, hpaste is announcing again.
11:23:56 <Deewiant> @ty let y g = g (y g) in y
11:23:58 <lambdabot> forall t. (t -> t) -> t
11:24:03 <Deewiant> is that not the y combinator in haskell?
11:24:34 <Lycurgus> fwiw, looks like base amstex does lack banana parens
11:24:36 <roconnor> Deewiant: yes, but it isn't in the lambda calculus
11:25:04 <ziman> @pl y g = g (y g)
11:25:04 <lambdabot> y = fix (ap id)
11:25:27 <roconnor> @tell Cale nevermind, it's probably a dumb idea.
11:25:27 <lambdabot> Consider it noted.
11:25:44 <dolio> That paste shows you can type 'w = \x -> f (x x)' in ghc, but not 'w w'.
11:26:34 <ddarius> roconnor: It would let you define new data types, e.g. binary trees.
11:27:19 <roconnor> dolio: unsafeCoerce is unsafe
11:27:35 <dons> roconnor: yeah. (re. derrida)
11:27:41 <dons> privledging the word.
11:28:02 <roconnor> dons: ?
11:28:10 <ddarius> dons: Using MonadError and ignoring 'fail' seems reasonable.
11:28:13 <roconnor> derrida?
11:28:37 <ddarius> (or alternatively MonadZero)
11:28:40 <gubagem> whats so unsafe about coercing mr.haskell to do things, i mean my gun is only loaded with blanks, and i dont intend to pistol whip him
11:28:58 <dons> oh, oops, sclv_ i mean.
11:29:04 <dolio> unsafeCoerce lets you cause segfaults in Haskell.
11:29:08 <roconnor> gubagem: the optimizer does things based on the type of terms.
11:29:09 <dolio> Which we don't like.
11:29:22 <dons> ddarius: yeah.
11:29:31 <roconnor> AFAIK the only time unsafeCoerce is safe is when a and b are actually the same type.
11:29:32 <dons> these days we are happy to track our effects in the type system
11:30:00 <gubagem> ok im looking at Data.Array.MArray, but it says that its experimental, should i even bother using it?
11:30:12 <sclv_> philosophy of language in the programming world pays off again.
11:30:13 <dons> MArray?
11:30:17 <Saizan> then someone should propose to move fail somewhere else for haskell'
11:30:22 <dons> gubagem: its only 15 years old, and in the core libraries..
11:30:27 <SamB_XP> gubagem: it isn't mark "explodey", si it?
11:30:30 <SamB_XP> er. is it?
11:30:44 <Taggnostr> how do I write 2 things on the same line?
11:30:46 <SamB_XP> gubagem: that just means they might change the interface without warning every 5 years or so
11:30:52 <SamB_XP> Taggnostr: two things?
11:30:53 <mauke> Taggnostr: one two
11:30:54 <dolio> I think a lot of stuff is tagged 'experimental' in haddock that hasn't been very experimental in a while.
11:31:04 <dons> we should audit that before 6.10
11:31:06 <roconnor> It is probably also safe to unsafeCoerce to and from GHC.Any, or whatever it is called.
11:31:26 <dolio> MTL is all experimental, I think.
11:31:36 <SamB_XP> well, first we should create guidelines on what the different levels actually mean
11:31:40 * roconnor plugs monadLib
11:31:50 <roconnor> we should switch to monadLib
11:32:08 <SamB_XP> roconnor: but monadlib actually *is* experimental, isn't it?
11:32:11 <dolio> Ooo, Data.Array is provisional.
11:32:20 <Taggnostr> I have to call 2 functions on the same line
11:32:23 <SamB_XP> dolio: I should hope so!
11:32:26 <sclv_> if we don't it won't get adopted widely, because everyone rightfully wants to code to the least requirements.
11:32:41 <roconnor> SamB_XP: true, but it seems better.
11:32:57 <edwardk> btw- if anyone is looking for an understanding of histomorphisms and dynamorphisms, I found http://www.ekabanov.net/reccomp.pdf to be a very approachable introduction to them.
11:32:58 <dolio> Ah, Data.Char is stable. There's one.
11:33:00 <SamB_XP> roconnor: that doesn't have much to do with the levels
11:33:13 <vixey> doesn't Control.Category have enough to replace monadLib?
11:33:21 <sclv_> some stuff that's only in the mtl/monadlib should also maybe get split out more widely. i.e. monadTrans is more general than any particular set of transformers. the Id monad is pretty basic, etc.
11:33:31 <Saizan> vixey: category-extras you mean?
11:33:33 <edwardk> vixey: not yet, i don't have any monads, just comonads and some category transformers on the way
11:33:46 <SamB_XP> roconnor: the levels refer to how stable the interfaces are
11:33:55 <edwardk> vixey: wel, thats not entirely true, i have free monads, ideal monads and some misc. things like that on the monad side
11:33:55 <roconnor> ok
11:34:03 <SamB_XP> not how happy people are with the whole approach
11:34:05 <sclv_> category-extras would be a terrible idea to replace anything!
11:34:11 <edwardk> sclv: bah ;)
11:34:19 <sclv_> the generality which is awesome comes at a terrible learning curve.
11:34:24 <edwardk> agreed
11:34:39 <vixey> edwardk: I'd like to use that stuff in general
11:34:59 <sclv_> when i've been playing with yr. stuff (only a little so far) I tend to distill down the code to less general type signatures that capture only what I want.
11:35:10 <edwardk> i wanted category-extras for 'sapir-whorf' reasons, i'm just now getting to the point of optimizing it ;)
11:35:52 <sclv_> I mean fine, if someone wants to use comonad transformers they're probably ok learning that BiFF isn't just this dude that beat up marty in back to the future.
11:36:25 <edwardk> oh speaking of optimizing it, i went through and redefined all dyna, futu, histo and chrono to be able to run over the right and left kan extensions of (co)free (co)monads. that should give an asymptotic improvement in some cases.
11:36:56 <edwardk> sclv: i'll admit biff is scary. but the number of instances i had without it was scarier ;)
11:37:30 <edwardk> sclv: i had a spreadsheet mapping 25 data types onto 40+ classes i was going to have to fill in all the instances by hand and that was just for bifunctors!
11:37:33 <sclv_> edwardk: what sorts of cases?
11:37:42 <Taggnostr> mod 5 2 mod 8 3 <- what should I put between them to execute one and then the other?
11:38:06 <vixey> Taggnostr: that dosent make any sense
11:38:08 <ddarius> Taggnostr: What's the point of "executing" mod 5 2 if you aren't going to do anything with the result.
11:38:30 <sclv_> (i.e. could anything there be ported "improve" style to, e.g., transparently speed up monadLib?)
11:38:37 <Taggnostr> actually I have mod 5 2 : list func arg1 arg2
11:39:03 <gubagem> Taggnostr: use do block notation, or let, or lambdas
11:39:18 <edwardk> sclv: basically most dynamorphisms. the same things that right kan extensions speed up free monad use in general for. so i.e. if i build an futumorphism that builds a whole tree, and tear it down with an algebra that only cares about parts of it, traditionally you can get n^2 performance in places. i'm still trying to get to where i have benchmarks, etc. motivating it
11:39:28 <Saizan> gubagem: do-notation doesn't make sense here either
11:39:30 <Taggnostr> can't I simply put a ; or something after list?
11:39:39 <edwardk> sclv: not yet. monadlib has no free monads.
11:39:45 <gubagem> Taggnostr: you can in a do block with braces
11:39:47 <Deewiant> you can put "`seq`"
11:39:50 <vixey> Taggnostr: no that doesn't make any sense
11:39:57 <mauke> Taggnostr: const x y
11:40:04 <edwardk> sclv: my monads are pretty far from the monadlib/mtl set because i figure they had those covered.
11:40:06 <ddarius> Taggnostr: Everything in Haskell has a value and it's value is the only relevant thing.
11:40:12 <Deewiant> mauke: but that doesn't execute x, seq does :-)
11:40:15 <dons> edwardk: you should write a new mtl
11:40:24 <roconnor> let {x = mod 5 2; y = mod 8 3} in <do whatever you want with x and y>
11:40:25 <mauke> Deewiant: who cares :-)
11:40:34 <Deewiant> mauke: he said he wanted them executed :-)
11:40:47 <roconnor> Deewiant: I'm not sure you are helping.
11:40:48 <ddarius> Taggnostr: If you are not doing something with the result, then there's no reason the expression should be there.
11:40:50 <mauke> he doesn't know what he wants
11:40:53 <edwardk> dons: evil thought.
11:41:02 <dons> we need an mtl champion
11:41:06 <edwardk> dons: i'd want to run it over arbitrary categories though =)
11:41:11 <Deewiant> in this case I think throwing in a seq to make it compile might be good
11:41:13 <Taggnostr> the result should be returned, it's inside an if/else
11:41:14 <edwardk> dons: and i think that might be less popular ;)
11:41:15 <sclv_> edwardk: if none of the standard monad set are free, I'm not sure if I understand what free monads means :-0
11:41:15 <dons> yav doesn't care if people use monadLib or not.
11:41:27 <Deewiant> might be able to figure out why it doesn't work, then
11:41:58 <ddarius> Taggnostr: What does "executing one then the other" mean to you?
11:42:04 <edwardk> sclv: a free monad is created by repeatedly wrapping: a + f (a + f (a + ...)))  and performing >>= by substituting at all the a's.
11:42:13 <Saizan> Taggnostr: so you want both results?
11:42:50 <Taggnostr> nope, the first result should go in the list, and then I've to call another function
11:42:54 <edwardk> sclv: by contrast a cofree comonad is a * f (a * f (...) and extend 'redecorates'
11:43:11 <gubagem> Taggnostr: do { let a=f whatever; let b=f whatever; f2 a b}
11:43:27 <gubagem> or you can use white space indenatation with the do block
11:43:34 <sclv_> edwardk: maybe and error are free, no?
11:43:36 <gubagem> actually there you dont even need a do block
11:43:39 <vixey> Taggnostr: There is no ordering of evaluation like that in haskell
11:43:46 <ddarius> sclv: Yes.
11:43:51 <edwardk> they are ideal, not free
11:43:52 <ziman> Taggnostr, a haskell program isn't a list of commands to do. instead, it's a single _expression_, that can be evaluated, just like 1*2 + 3. what's the sense of calculating 1+2 and then 3+4? what would that evaluate to? you need to combine the subexpressions somehow to get a single expression.
11:43:56 <roconnor> gubagem: depends on if f2 is an action, like print, or not.
11:44:06 <ddarius> edwardk: They are free.
11:44:07 <gubagem> right right
11:44:19 <Taggnostr> I see
11:44:25 <gubagem> Taggnostr: if you use do blocks haskell can seem like a regular language to a degree
11:44:30 <edwardk> ddarius: checking. its been a while since i wrote them out =)
11:44:42 <Taggnostr> btw now I can declare the function but it doesn't work
11:44:49 <Taggnostr> let me do some test
11:44:54 <edwardk> yeah they are my mistake
11:44:56 <gubagem> do I need a phd in mathematics to figure out what half the stuff you guys are talking about
11:45:13 <edwardk> heh i have that right on a sheet of paper 4 feet from me, go figure
11:45:16 * sclv_ wipes brow and sighs in relief that he understands at least a little.
11:45:46 <edwardk> for that matter stream is cofree and identity is the cofree of the trivial zero functor.
11:45:47 <Deewiant> gubagem: only for a quarter, I'd say (I don't have a phd and I think that's approximately the amount I don't understand at all)
11:46:08 <ddarius> sclv_: Quick!  Write a FreeMonad type constructor and appropriate Monad and Functor instances!
11:46:15 <vixey> I think I finally figured out what a category is today
11:46:19 <Taggnostr> how can I get 2 from 7/3 ?
11:46:25 <roconnor> gubagem: no, you just need to be a phd candidate.
11:46:27 <roconnor> :P
11:46:32 <gubagem> integer division
11:46:33 <edwardk> Taggnostr: floor ? =)
11:46:36 <mauke> > let f _ = 2 in f (7/3)
11:46:36 <vixey> > floor (2/7)
11:46:37 <lambdabot>  2
11:46:38 <lambdabot>  0
11:46:43 <sclv_> Reader isn't free, and State isn't, right?
11:46:44 <mauke> vixey: FAIL
11:46:44 <ziman> Taggnostr, 7 `div` 3
11:46:49 <Deewiant> > 7 `div` 3
11:46:50 <lambdabot>  2
11:46:54 <vixey> mauke: Monad fail
11:46:57 <mauke> Taggnostr: const 2 (7/3)
11:47:00 <sclv_> But state-like things are "Ideal"?
11:47:04 <gubagem> vixey: whats your definitions of categories now
11:47:06 <ziman> :))
11:47:15 <ddarius> sclv_:  Reader is.
11:47:18 <edwardk> state is a monad given by adjunction composition most easily
11:47:31 <Taggnostr> `div` seems what I'm searching for
11:47:53 <Taggnostr> now the function works, it just return the wrong thing
11:47:59 <edwardk> and yeah you can build reader as an ideal coreader/product as a coideal, and use their adjunction to get state and context.
11:48:01 <sclv_> oh, I see how reader is now.
11:48:02 <ddarius> gubagem: There have been high schoolers that have no trouble understanding this stuff.
11:48:21 <gubagem> ddarius: young fertile minds im guessing
11:48:42 <Deewiant> it's a matter of how much time you want to spend in reading about the newest foo-morphism ;-)
11:48:49 <vixey> but natural transforms seem very confusing
11:49:30 <edwardk> vixey: type Nat f g = forall a. f a -> g a -- is a good enough model to make it easy to think about.
11:49:39 <ddarius> vixey: (Most) polymorphic functions are representative examples of natural transformations.
11:49:43 <Taggnostr> why if I do let l = [] and then I have a function that adds element to l at the end l is empty?
11:50:09 <edwardk> for that matter any polymorphic... yeah what ddarius said
11:50:25 <twobitwork> howdy
11:50:28 <gubagem> Taggnostr: because variables are immutable in haskell(or so i think)
11:50:35 <ddarius> edwardk: Not -any- polymorphic function, e.g. fix isn't a natural transformation.
11:50:45 <edwardk> ok, point
11:50:46 <vixey> @free fix
11:50:48 <lambdabot> f . g = h . f => f (fix g) = fix h
11:50:48 <mauke> Taggnostr: what do you mean by "add to l"
11:50:49 <mauke> variables are just names for values
11:50:49 <mauke> they're not boxes
11:51:01 <Taggnostr> func a1 a2 : l
11:51:04 <gubagem> Taggnostr: do some recursion and pass in the updated value in one of the arguments to the recursing function
11:51:08 <ddarius> (It is a dinatural transformation and I think every polymorphic function is a dinatural transformation.)
11:51:11 <mauke> Taggnostr: that doesn't modify l
11:51:33 <Deewiant> Taggnostr: that creates a new list with func a1 a2 prepended to l
11:51:39 <Taggnostr> is that the right way to prepend a value to l?
11:51:47 <vixey> whyy are natural transforms named
11:51:50 <Deewiant> certainly, but l itself will never be modified
11:52:03 <Taggnostr> how can I prepend always at the same list?
11:52:10 <ddarius> vixey: Because it would be hard to refer to them if they didn't have names.
11:52:15 <gubagem> Taggnostr: huh?
11:52:30 <gubagem> are there automorphisms and isomorphisms in haskell?
11:52:35 <Taggnostr> so that at the end I find all the prepended values in l
11:52:51 <ddarius> gubagem: It depends on what you mean by that.
11:53:20 <gubagem> just words ive read from reading books on group theory (has a vague idea what group theory is)
11:53:52 * sclv_ laughs at all the leibnitz hits that come up googling for "ideal monad"
11:53:54 <ddarius> gubagem: An isomorphism is just a pair of functions f :: A -> B and g :: B -> A such that f . g = id and g . f = id
11:54:13 <ddarius> There are certainly pairs of functions that satisfy those equations in Haskell.
11:54:19 <Deewiant> Taggnostr: you can't do that, when you name something it's immutable. "x = x + 1" makes no sense, for instance.
11:54:28 <vixey> yes it dose
11:54:34 <vixey> > let x = x + 1 in x
11:54:48 <Deewiant> it makes no sense
11:54:49 <lambdabot>  thread killed
11:54:50 <Deewiant> x is bottom
11:54:53 <Deewiant> it's rather useless :-P
11:54:54 <BMeph> Peaker: Just wondering: Is there a special reason you represent knights in your program with an "h" instead of an "n" or "s"? :)
11:54:55 <dolio> exception: loop
11:54:56 <ddarius> > let x = x + 1 in x :: Expr
11:54:58 <vixey> useless, ok
11:54:59 <lambdabot> Terminated
11:55:07 <Taggnostr> uhm
11:55:08 <ddarius> Deewiant: That depends on the definition of (+)
11:55:08 <Deewiant> > let x = x + 1 :: Expr in x
11:55:12 <lambdabot> Terminated
11:55:17 <ddarius> > let x =  1 + x in x :: Expr
11:55:18 <lambdabot>  1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1...
11:55:21 <vixey> It makes more sense than  True + Just "sheep" though
11:55:30 <Deewiant> ddarius: well sure, everything depends on definitions... I'm trying not to confuse the guy too much :-)
11:55:50 <Taggnostr> so I have to define a new list adding the values to the old list?
11:56:00 <Deewiant> ddarius: you can always define (+) = const "hahaha" but... no. Just "no" ;-)
11:56:02 <Taggnostr> value*
11:56:18 <gubagem> Taggnostr: do you know about recursion?
11:56:21 <ddarius> Deewiant: It's not unreasonable to define (+) = Plus
11:56:31 <Taggnostr> yes, is what I'm trying to use
11:56:54 <gubagem> well in your recursive call just do the prepending there inside of parantheses
11:56:56 <Taggnostr> I've a recursive function that has to add values to the list
11:57:04 <vixey> :t Just "no"
11:57:06 <lambdabot> Maybe [Char]
11:57:06 <gubagem> but where are you getting the values you are adding to the list
11:57:36 <Deewiant> ddarius: alright, fine, in which case you've got Plus bottom instead of plain bottom. :-)
11:57:42 <Taggnostr> uhm?
11:58:10 <dolio> Well, it's not bottom.
11:58:14 <Taggnostr> actually I only have mod a b : l, and I return the list at the end
11:58:23 <dolio> Any more than 'fix (1:)' is bottom.
11:58:36 <Deewiant> hmph, good point, it's just an infinite stream of Plus.
11:58:39 <dolio> Depending on Plus, of course.
11:58:44 <gubagem> Taggnostr: so you have an accumulator as a variable that starts out life as empty-list ( [] ) correct?
11:58:53 <Taggnostr> yep
11:59:03 <dolio> It could be 'data Foo = Plus !Int !Foo', in which case it would be bottom.
11:59:16 <Taggnostr> and I declared it as let l = [] outside the function
11:59:19 <Deewiant> or it could be a newtype.
11:59:28 <Taggnostr> (i also tried to do it inside but I failed
11:59:32 <Taggnostr> )
11:59:37 <gubagem> Taggnostr: lets say for example you have f l=blah blah blah ; f (newVal:l)
11:59:52 <gubagem> that will prepend to L the way you want
12:00:01 <gubagem> you just need a conditional or a pattern match to exit out
12:00:08 <Taggnostr> also I'm not passing the list around
12:00:19 <gubagem> you should be, as far as i know for now
12:00:44 <gubagem> you have to pass "State" around in variables unless you get into monads (which i have no clue about)
12:00:56 <Taggnostr> uhm
12:01:00 <dolio> He could put the list in a state monad to hide the passing around.
12:01:22 <Taggnostr> but if I do that, should I pass an empty list when I call the function for the first time?
12:01:27 <gubagem> dolio: what do i need to know before i try tackling monads
12:01:44 <gubagem> Taggnostr: yes pass [] as l for the first function call
12:01:57 <Taggnostr> do I need monads to avoid that?
12:02:19 <gubagem> Taggnostr: I believe so, but its really no biggie passing state around unless you get really complicated
12:02:42 <dolio> gubagem: I don't know. You need to know that there's not much to them, despite their reputation, I suppose.
12:03:06 <sclv_> my advice: write nice things and paste them up to hpaste, and sooner or later somebody will say "you could have abstracted that with a monad" and then you'll get it.
12:03:18 <Taggnostr> ok, I did it but it still doesn't seem to work
12:03:30 <Taggnostr> is mod a b : l correct?
12:03:33 <gubagem> dolio: they look like wrapped packages with a goodie inside, and when you wrap the package again the wrappers just merge
12:03:42 <Deewiant> > mod 5 6 : [1,2,3]
12:03:44 <lambdabot>  [5,1,2,3]
12:03:48 <dolio> Something like that.
12:03:58 <gubagem> how do i get the goodies out?
12:04:16 <dolio> That's specific to each monad.
12:04:19 <Deewiant> execState, runState, etc.
12:04:33 <gubagem> args<-getArgs ??
12:04:46 <dolio> Except that in general, monads have ways of gluing together wrapped goodies with functions that take ordinary goodies and return wrapped goodies.
12:04:54 <gubagem> is that using a moand and getting the gooddies out
12:05:00 <Taggnostr> it doesn't work :\
12:05:16 <gubagem> Taggnostr: where are you gettting the a and b you are passing to mod
12:05:35 <gubagem> Taggnostr: try adding some parantheses for proper ordering
12:05:43 <Taggnostr> from the function call, I call it as func a b []
12:06:35 <dolio> gubagem: When you do 'a <- ma' in a do-block, you always have to follow it up with something like 'foo a' where foo a :: m b.
12:06:42 <gubagem> where you getting the a and b that you call func with
12:06:43 <SamB> hmm, apparantly im-switch is the key
12:06:59 <gubagem> dolio: m being monad?
12:07:06 <dolio> gubagem: And that gets translated to, roughly, 'ma >>= \a -> foo a'.
12:07:08 <dolio> Right.
12:07:09 <Taggnostr> func 9 2 []
12:07:26 <dolio> Where >>= is how you glue together wrapped things with functions that take ordinary things and return wrapped things.
12:07:27 <Deewiant> > let func a b l = mod a b : l in func 9 2 []
12:07:28 <lambdabot>  [1]
12:07:30 <gubagem> dolio: yea i started getting into that the other day
12:07:33 <SamB> gubagem: it was either that or a type-level natural number!
12:08:02 <seanmce> is threadDelay the way to sleep, and why does it return immediately for me?
12:08:25 <Saizan> seanmce: it is, the input is in microseconds
12:08:32 <gubagem> seanmce: maybe its not returning cause its sleeping
12:08:42 <dolio> So 'ma :: m a', and '(\a -> foo a) :: a -> m b' and '(ma >>= \a -> foo a) :: m b'.
12:09:10 <seanmce> even 100000 did nothing
12:09:27 <ddarius> seanmce: 100000 is a tenth of a second
12:09:37 <gubagem> dolio: see you are losing me there, whats all that :: stuff mean and the a-prime
12:09:37 <bd_> @hoogle fix
12:09:38 <lambdabot> Data.Function.fix :: (a -> a) -> a
12:09:38 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
12:09:38 <lambdabot> Control.Monad.Fix :: module
12:09:56 <dolio> gubagem: 'a :: b' means a has type b.
12:09:58 <seanmce> ddarius: thanks
12:10:15 <dolio> And I was just putting stuff in quotes so it's easier to tell what's code and what's the rest of my sentence.
12:10:45 <monochrom> need a quote mark for quoting code
12:10:46 <ddarius> dolio: <code>ma :: m a</code>
12:11:00 <dolio> Heh.
12:11:25 <dolio> I don't know, might need more markup.
12:11:42 <Deewiant> \begin{code}ma :: m a\end{code}
12:12:12 <vixey> > ma :: m a
12:12:12 <lambdabot>   Not in scope: `ma'
12:12:26 <gubagem> > m a :: m a
12:12:27 <lambdabot>  Couldn't match expected type `Expr -> m a'
12:12:32 <gubagem> huh
12:12:33 <Deewiant> <code language="Haskell" length="fairly short"><snippet type="type signature">ma <doublecolon fallback="::"/> m a</snippet></code>
12:12:40 <dolio> > m
12:12:42 <lambdabot>  m
12:12:43 <BMeph> ?tell Peaker Just wondering: Is there a special reason you represent knights in your program with an "h" instead of an "n" or "s"? :)
12:12:43 <lambdabot> Consider it noted.
12:12:52 * gubagem weeps at Deewiants feet 
12:12:56 <ddarius> <code language="haskell" medium="irc"><typedeclaration><variable>ma</variable><type><typeapplication><typevariable>m</typevariable><typevariable>a</typevariable></typeapplication></type></typedeclaration></code>
12:13:19 <Deewiant> :-)
12:13:36 <vixey> > (++)
12:13:37 <lambdabot>  Add a type signature
12:13:49 <Deewiant> > (++) ::
12:13:49 <lambdabot>  Parse error at end of input
12:13:50 <vixey> > (++) + a -> b
12:13:50 <lambdabot>  Parse error at "->" (column 10)
12:13:54 <gubagem> > m a -> m a
12:13:54 <lambdabot>  Parse error at "->" (column 5)
12:14:01 <gubagem> :-(
12:14:04 <vixey> > <- -> <
12:14:04 <lambdabot>  Parse error at "<-" (column 1)
12:14:19 <monochrom> <code id="hello" class="haskell" style="font-size: 1em; display: block; white-space: pre"><![CDATA[ma :: m a]]</code>
12:14:31 <vixey> lol
12:15:05 <dbpatterson> sclv_: if you're there, did I see in a commit message that hvac has support for the '|.' combinator (to match only an empty request string)? if so, what is an example of how it is used?
12:15:19 <gubagem> is haskell fast enough to pull off graphics at 30+fps?
12:15:33 <ddarius> gubagem: Of course.
12:15:43 <mahogny> gubagem, your graphics card will be the limiting factor
12:15:47 <Deewiant> > (=<<)(>>=)(\_->[0])(\_->"haha")
12:15:48 <lambdabot>  "haha"
12:15:58 <gubagem> seriously? cause drscheme sure as hell wasnt , oh i have to use opengl extensions
12:16:16 <gubagem> are those wrapped pretty or are they all C-ish and gnarly?
12:16:22 <ddarius> gubagem: If you write slow code, then it won't be.
12:16:26 <mahogny> gubagem, yes, opengl is a must. software is slow even in assembly if you have modern requirements on polycount etc
12:16:28 <lament> gubagem: your question is actually a FAQ
12:16:35 <vixey> You can do realtime 3D with drscheme
12:16:53 <gubagem> link?
12:16:56 <vixey> I know this because it comes with example of that
12:16:56 <lament> @faq Can Haskell pull off graphics at 30+ fps?
12:16:57 <lambdabot> The answer is: Yes! Haskell can do that.
12:17:17 <gubagem> drschemes opengl interface was nasty looking, never got into it
12:17:19 <Apocalisp> @faq I can hazkell?
12:17:19 <lambdabot> The answer is: Yes! Haskell can do that.
12:17:32 <mahogny> lo
12:17:34 <mahogny> l
12:17:42 <gubagem> @faq Can I fly (with haskell)?
12:17:42 <lambdabot> The answer is: Yes! Haskell can do that.
12:17:49 <dbpatterson> sclv_: nevermind, I should have just looked at the code...
12:17:52 <vixey> gubagem: compared to say C?
12:18:04 <gubagem> it seemed almost like C
12:18:12 <gubagem> there wasnt anything very schemish about it
12:18:18 <Baughn> gubagem: http://brage.info/~svein/opengl.hs.txt <-- Here, this pulls of graphics at 60fps. (Wub wub wub..)
12:18:25 <mahogny> @faq can haskell help me with genocide?
12:18:25 <lambdabot> The answer is: Yes! Haskell can do that.
12:18:35 <mahogny> shit. NSA is soon joining the chan
12:18:40 <opqdonut> i need to "compose" tree traversions for a heterogenous tree, atm i'm doing it like "class Traverse a b | a -> b where traverse :: (Monad m) => a -> m b; instance Traverse Foo Bar where traverse = f >>= g >>= h where f = ...; g = ...; h = ..."
12:18:58 <opqdonut> seems kinda ugly
12:19:00 <Baughn> gubagem: I dare say haskell does a better job of it than scheme, but opengl fundamentally isn't very functional. Doesn't stop you from building functional abstractions on top of it.
12:19:14 <mehrheit> @faq are these answers random?
12:19:14 <lambdabot> The answer is: Yes! Haskell can do that.
12:19:21 <dolio> gubagem: Anyhow, lots of computation can be modeled as a way of injecting pure values into the computation (return :: a -> m a), and ways of gluing computed values together to get other computed values ((>>=) :: m a -> (a -> m b) -> m b), and those two things (that satisfy certian associativity and identity laws) make a monad.
12:19:32 <mahogny> to extend that, I would say opengl is the very antithesis of functional
12:19:43 <dolio> One of those things happens to be threading state values through a series of function calls.
12:19:55 <Baughn> The upcoming opengl 3 design is a bit better, but of course it's neither done nor does it have bindings
12:20:20 <mahogny> well. dunno about better; only reason it is less imperative is that they removed functionality :P
12:20:55 <vixey> not really gl is a just a big state machine
12:21:01 <Baughn> Ahem. *Any*way, you can still build functional abstractions on top of gl. ;)
12:21:12 <Baughn> x86 assembly is just a big state machine too, after all
12:21:20 <gubagem> Baughn: what do i need to get that code to compile
12:21:22 <mahogny> abstracting gl will slow it though
12:21:27 <mahogny> +down
12:21:29 <Baughn> gubagem: It should compile out of the box
12:21:32 <ddarius> Considering your computer is just an FSA...
12:21:49 <Baughn> mahogny: True, but newer gpus definitely have power to burn
12:22:15 <znutar> gpus are limited by the ability of the cpu to feed them commands a lot of the time nowadays
12:22:19 <mahogny> not in this case really; calls are expensive because of latency so you really want to avoid useless state affecting calls
12:22:21 <jmg_> hi everyone
12:22:28 <vixey> hello
12:22:38 <gubagem> Baughn: that code is complaining about some openglzm2si2zizi1_graphics something or another, but hey its probably my fault cause im on win XP
12:23:03 <Baughn> gubagem: You could try pasting the error. You did compile with --make, right?
12:23:10 <Deewiant> gubagem: you might want to link in opengl32 at least
12:23:14 <gubagem> hmmm nope
12:23:20 <gubagem> how do i do these things
12:23:44 <Baughn> gubagem: ghc --make opengl.hs should work. Or, at least it does work on OS X and Linux
12:23:59 <gubagem> whats the make do? like unix make?
12:24:15 <Deewiant> how does ghc --make know what libraries to link in?
12:24:26 <Baughn> Deewiant: Consults package description files
12:24:31 <Baughn> Although..
12:25:19 <gubagem> now i get a windows error: "This application has failed to start because glut32.dll was not found. re-installing the application may fix this problem"
12:25:30 <Deewiant> hence, get glut32.dll
12:25:33 * gubagem goes to look at his graphics card
12:25:45 <sclv_> dbpatterson: have you taken a look at the new AltController api?
12:25:54 <gubagem> Deewiant: where do i put it? in the exe directory?
12:26:09 <sclv_> I'm actually sort of happy with it because a) folks seem to want it and B) it lets me fold validation back into the general parsing notion.
12:26:16 <Deewiant> gubagem: yeah, or %WINDIR%/system32 if you don't want to worry about this problem ever again ;-)
12:26:19 <sclv_> (which I of course have to code up)
12:26:30 <Baughn> Deewiant: I have to pass -lglut on linux (debian), but it worked automatically on linux(ubuntu) and os x
12:26:36 * Baughn shrugs
12:27:10 <Baughn> gubagem: In the exe directory if you want to distribute it, obviously, which is why I have seventeen copies of glut32.dll on my system
12:27:14 <sclv_> The disadvantage is that it makes everything strongly monadic, when I was shooting for something purely applicative.
12:27:56 <monochrom> hahaha 17 copies
12:28:43 <Baughn> Aha! Bug report time. Maybe.
12:28:44 <dbpatterson> sclv_: no, link?
12:29:04 <Taggnostr> ho can I have 123 from [1,2,3]?
12:29:08 <Taggnostr> how*
12:29:17 <dbpatterson> or is in the code?
12:29:21 <monochrom> @type foldl'
12:29:22 <Deewiant> I did a search and came up with 6 copies only
12:29:23 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:29:43 <Baughn> Deewiant: The opengl package only tells gcc to link against libGLU and libGL, not libglut
12:29:43 <monochrom> > foldl' (\x y -> 10*x+y) 0 [1,2,3]
12:29:45 * dolio always gets confused by the type of foldl.
12:29:45 <lambdabot>  123
12:29:55 <sclv_> browse the source at the repo... also in the comments of the latest blogpost
12:29:59 <ddarius> @pl \x y -> 10*x+y
12:29:59 <lambdabot> (+) . (10 *)
12:30:12 <Taggnostr> what if I want them as a string?
12:30:13 <bd_> > read . concatMap show $ [1,2,3]
12:30:14 * gubagem thanks people for help getting opengl working under haskell
12:30:14 <doun> dolio: why so?
12:30:14 <ddarius> > foldl' ((+) . (10*)) 0 [1,2,3]
12:30:15 <lambdabot>  Exception: Prelude.read: no parse
12:30:16 <lambdabot>  123
12:30:19 <sclv_> I haven't rewritten any examples to use them yet.
12:30:22 <Deewiant> Baughn: aye, Graphics.UI.GLUT definitely should link to libglut
12:30:25 <bd_> > concatMap show $ [1,2,3]
12:30:27 <lambdabot>  "123"
12:30:27 <gubagem> I think im just gonna stare at this thing
12:30:35 <bd_> > read . concatMap show $ [1,2,3]
12:30:37 <lambdabot>  Exception: Prelude.read: no parse
12:30:37 <monochrom> @type foldr
12:30:39 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
12:30:39 <bd_> oO
12:30:46 <Deewiant> > read . concatMap show $ [1,2,3] :: Int
12:30:47 <lambdabot>  123
12:30:50 <ddarius> bd_: You have to tell it what type to read
12:30:52 <bd_> ahh
12:30:56 <bd_> forgot about that
12:30:57 <Deewiant> what does it default to?
12:31:01 <bd_> defaults to ()
12:31:02 <monochrom> I guess it could be remembered.
12:31:03 <ddarius> Deewiant: In lambdabot ()
12:31:04 <bd_> > read "()"
12:31:06 <lambdabot>  ()
12:31:09 <dolio> doun: I'm used to foldr :: (a -> b -> b) -> b -> [a] -> b, and I expect foldl to just flip the argument to the function...
12:31:10 <Deewiant> right
12:31:29 <dolio> doun: But it flips the variable names, too, which causes me to have to think a bit whenever I see it.
12:31:42 <Deewiant> > foldr (flip ((+) . (10*))) 0 [1,2,3]
12:31:43 <lambdabot>  321
12:31:58 <sclv_> dbpatterson: I need to get a clean seperation of StaticRecord into a seperate package, and then I think I'm nearly ready for a hackage release. Next step after that is generalizing from sqlite support to more DB backends.
12:32:00 <dbpatterson> sclv_: okay. yes, it is ugly. along the lines of the original controller api, I'm writing up an explanation of all the symbols that I know of... I'm going to definitely want to run it by you, because for a few I'm not even sure if I understand them (not your stuff, control.applicative stuff). hopefully it will make it easier for people to understand?
12:32:03 <Baughn> Deewiant: Right. The glut package, meanwhile, doesn't tell it to link against /anything/; ubuntu has apparently patched it to do so.
12:32:20 <Deewiant> Baughn: wow, good for ubuntu :-)
12:32:32 <doun> dolio: ah
12:32:39 * monochrom hugs his ubuntu
12:32:41 <Baughn> Deewiant: Not so good for us
12:32:56 <sclv_> yeah, no way am I getting rid of the original controller api, but it makes sense to keep both around because, hey, to each their own.
12:33:02 <Deewiant> Baughn: I'm paranoid enough that I'd link everything in manually anyway :-)
12:33:53 <sclv_> I also really want to write a CGICheck package that handles simple mocks for testing apps in the CGI monad.
12:34:05 <Baughn> Deewiant: Not so good. Using a manual -lGL on os x would massively mess it up, since that goes for the (broken!) X11 compatibility library and not the OpenGL framework
12:34:27 <Deewiant> Baughn: O_o, what's the right thing to do on OS X then
12:34:37 <sclv_> Then I can get some nice properties for hvac.
12:34:41 <Baughn> Deewiant: Well, whatever it's currently doing, so look in the package. ;)
12:34:48 <dbpatterson> sclv_: you mean like proving correctness?
12:34:51 <Deewiant> >_<
12:35:06 <sclv_> well, like quickcheck properties.
12:35:09 <Baughn> Deewiant: Linking wise, that's -framework OpenGL -framework GLUT
12:35:36 <Deewiant> riight
12:35:40 <sclv_> a toolkit to run concurrent mock cgi requests, leveraging off of arbitrary.
12:35:45 <Deewiant> is there a good reason why -lGL doesn't work out of the box?
12:35:49 <dbpatterson> sclv_: oh, that _would_ be handy
12:36:14 <dbpatterson> plus, it could be a simple sort of load testing too, no?
12:36:15 <Baughn> Deewiant: -lGL is reserved for the "legacy" libGL.dylib, ie. the X11 compatibility stuff
12:36:30 <Deewiant> and when would one want to use that instead
12:36:42 <sclv_> The irritating part is then how to declare properties on the reply -- tagsoup maybe.
12:36:44 <Baughn> Well, if you want indirect GLX, I guess
12:36:55 <Baughn> Deewiant: X11 isn't installed by default, and using it would mean an extra, unneccessary layer of redirection for local applications
12:37:17 <sclv_> dbpatterson: yah, load testing, but more importantly I can check concurrency issues and stress-test the stm invarients for logic flaws.
12:37:20 <dbpatterson> sclv_: yeah... html is by default crap...
12:37:21 <Baughn> Deewiant: Worse, there are currently *two* OpenGL libraries on the system - one in the framework, one in X11. The latter links to the former, which messes up the linker logic.
12:37:40 <Deewiant> lovely
12:37:45 * edwardk is thinking about taking most of the fooToBar, barToFoo instances and making a simple embedding/projection pair representation out of them for natural isomorphisms ala monadLib. type m :<~>: n = (m :~> n, n :~> m)  where type m :~> n = forall a. m a -> n a
12:37:46 <Baughn> Deewiant: That is to say, two libraries with the exact same name
12:38:04 <edwardk> would cut the number of names in my library in half, but require you to project them out of the isomorphism
12:38:09 <edwardk> er natural isomorphism
12:39:12 <edwardk> or NatIso or Iso instead of :<~>:, whatever
12:39:28 <sclv_> edwardk: that's my biggest gripe with the library actually. for example, just looking at dyna and trying to see what it mean, I had to go chase down four or so type signatures.
12:39:53 <sclv_> It would be nice to, in the haddocks, put the "expanded" version of the signatures sans type-aliases.
12:40:04 <edwardk> sclv: well the type signatures were to make it so i could actually get my head around the concepts at a level above a -> b. =/
12:40:07 <Baughn> Deewiant: This primarily means that wine won't run directx applications for love or money. I'm working at it, but the most promising solution involves copying the system library and re-linking libGL
12:40:07 <dbpatterson> sclv_: quite question - is this valid: h |\ (\a b -> ...) -- matching /argA/argB ?
12:40:13 <dbpatterson> quick*
12:40:21 <edwardk> sclv: yeah i agree the expansion would make a great haddock comment.
12:40:21 <sclv_> nope.
12:40:29 <dbpatterson> sclv_: so only single argument functons
12:40:31 <dbpatterson> functions*
12:40:49 <sclv_> right you just need h |\ \a -> |\ \b ->
12:42:42 <sclv_> there's no easy way to determine arity of functions in haskell, otherwise that would be sort of cute...
12:44:18 <edwardk> sclv: the main reason why i do the short hand is: g_hylo :: (Comonad w, Functor f, Monad m) => (forall d. g (w d) -> w (g d)) -> (forall e. m (f e) -> f (m e)) -> (g (w b) -> b)  -> (forall c. f c -> g c) -> (a -> f (m a)) -> a -> b -- is fairly impenetrable
12:44:42 <gubagem> that really does look like a huge mess
12:45:11 <edwardk> With g_hylo :: (Comonad w, Functor f, Monad m) => Dist g w -> Dist m f -> GAlgebra g w b -> (f :~> g) -> GCoalgebra f m a -> a -> b   -- you can at least see what the purpose of everything is.
12:45:34 <edwardk> its still ugly, but hey
12:46:03 <gubagem> whats squiggly arrow mean :~> ??
12:46:18 <sclv_> maybe hvac could use http://okmij.org/ftp/Haskell/isFunction.lhs just to be bratty. (It already needs typeCast at the moment)
12:46:25 <edwardk> type f :~> g = forall a. f a -> g a. its the notation I use for natural transformation rather than the word 'Nat'
12:47:28 <edwardk> if only because i had some a non-category person look at that line and say the only thing i recognize is that you are passing it a number there... whereupon I headdesked and changed it ;)
12:48:00 <sclv_> edwardk: your way is cleaner for thinking about it, but the expanded version is sort of necessary for actually reasoning about how to write one...
12:48:35 <edwardk> sclv: well, one of the reasons I put all the distFoo functions was to give you tools for building up distributive laws 'out of the box'
12:48:37 <seanmce> echo :: (PrintfType r) => Bool -> String -> r -> IO ()
12:48:37 <seanmce> echo verbose str r = if verbose then printf str r else return ()
12:48:45 <seanmce> can that be made to work?
12:49:03 <edwardk> otoh, splitting them into a dozen Control.Morphism.* files made them harder to see the commonalities between ;)
12:49:07 <sclv_> the Dist and Nat types I have no problem with.
12:49:16 <sclv_> its really the GAlgebra stuff
12:49:17 <ddarius> seanmce: In what way does it not work?
12:49:38 <seanmce> Could not deduce (PrintfArg r) from the context (PrintfType r)
12:49:55 <edwardk> Algebra, Coalgebra, Dialgebra, Bialgebra are pretty common in the associated literature. the GFoo's are a little ugly I'll admit.
12:49:55 <ddarius> :t printf
12:49:57 <lambdabot> forall r. (PrintfType r) => String -> r
12:50:10 <edwardk> I just couldn't come up with a cleaner way to say them though =(
12:50:16 <ddarius> :t \x -> printf "" x
12:50:18 <lambdabot> forall t t1. (PrintfType (t -> t1)) => t -> t1
12:50:45 <edwardk> and one goal is to supply a bunch of foo-algebras in control.functor.algebra to do the same thing i was doing with dist, to allow you to cookie-cutter the boring cases.
12:51:02 <ddarius> :t \verbose str r -> if verbose then printf str r else return ()
12:51:03 <edwardk> hence the liftAlgebra, liftCoalgebra methods, etc.
12:51:04 <lambdabot> forall t (m :: * -> *). (Monad m, PrintfType (t -> m ())) => Bool -> String -> t -> m ()
12:51:31 <edwardk> without a vocabulary for spotting 'whats an algebra' you'd never know when to apply the tools.
12:52:30 <sclv_> ah... gotcha...
12:52:46 <jmg_> seanmce: what about:
12:52:53 <jmg_> echo True = printf
12:52:59 <jmg_> echo False = return(0
12:53:03 <vincenz> hi
12:53:03 <edwardk> also if you are using this to learn category theory, algebras form categories all their own, etc. something you lose sight of in the (f a -> a) form, and when using them over a monad you typically want them to respect the notion of return for the monad, so some times you aren't allowed to pass in any old function of that form, so i needed a cue.
12:53:11 <doun> hi vincenz
12:53:21 <jmg_> echo False = return ()
12:53:21 <edwardk> that said i'm not nearly as defensive about this as i probably sound right now ;)
12:53:29 <seanmce> jmg_ : ah, yes that should work
12:53:47 <sclv_> This is all really helpful actually.
12:54:38 <sclv_> Eventually some sort of documentation or "handbook" would be nice probably. You could probably get a real book out of this actually...
12:54:49 <dcoutts> dons: nice post :-)
12:54:55 <edwardk> we'll see how much it cleans up =)
12:54:58 <SamB> edwardk: which kind of algebra are you referring to?
12:55:02 <edwardk> documentation is definitely on the list.
12:55:10 <SamB> I really wish the term "algebra" wasn't so overloaded
12:55:13 <edwardk> f-algebras
12:55:21 <edwardk> for a functor or monad f.
12:55:30 <SamB> I especially wish it wasn't usually used to mean high-school algebra!
12:55:35 <edwardk> heh
12:55:35 <dcoutts> dons: someone somewhere had a nice article on fail and monad plus. The argument is that there is nothing wrong with fail and we do not need to demonise it, but it should be in a separate extended class.
12:55:47 <dcoutts> dons: but I cannot now find that article again.
12:55:48 <edwardk> fail is evil ;)
12:55:50 <seanmce> sclv_: didn't work, No Instance for (PrintfType ())
12:55:50 <SamB> makes it a heck of a lot harder to gooogle
12:55:59 <edwardk> j/k ;) but yeah it should be a separate class ;)
12:56:19 <edwardk> that would let you remove the !@#!&@#(& Error constraint on the base monad instance for Either!
12:57:05 <jmg_> does anybody know whether there are special issues regarding the combination of type families and existentially quantified types?
12:57:06 <seanmce> jmg_: didn't work: No instance for (PrintfType ())
12:57:38 <edwardk> jmg: nothing i've run into
12:57:41 <dcoutts> dons: so do '<-' refutable patterns should introduce a MonadFail or whatever class constraint
12:57:42 <Arnar> hey folks..
12:58:03 <ddarius> SamB: They're all interrelated.
12:58:31 <SamB> ddarius: yes, I know. sigh.
12:58:46 <gubagem> is there anything past category theory? or does it umbrella almost all of mathematics?
12:58:48 <Arnar> I'm writing a set of SOS rules for a project... involving regular haskell terms. I need to represent a function that turns a specific outer (mathematical) object into a Haskell term.. does anyone know of specific conventions of what symbol to use for such a function?
12:58:51 <SamB> okay, I guess what I really wish was that I could filter out all the high-scool algebra results
12:59:09 <ddarius> gubagem: It's a small part of mathematics.  Mathematics doesn't form a hierarchy let alone a tower.
12:59:14 <gubagem> try abstract algebra or modern algebra
12:59:33 <gubagem> can category theory be defined in terms of set theory?
12:59:35 <doun> SamB: there's always the "-" google operator. e.g. you might do "-school"?
12:59:41 <ddarius> gubagem: Yes.
12:59:47 <edwardk> class Functor f => Copointed f where extract :: Algebra f a -- or do you think thats going too far? =)
12:59:53 <gubagem> is that a real huge pain in the arse to do?
12:59:55 <SamB> well, when trying to figure out what someone is talking about when they say something about an algebra...
12:59:58 <ddarius> gubagem: NO.
13:00:03 <ddarius> s/NO/No
13:00:03 <doun> I thought a category was a set and an operation for the elements of that set
13:00:19 <SamB> gubagem: can set theory be discarded without loss of generality?
13:00:30 <SamB> that is the question I want to know the answer to
13:00:32 <gubagem> <-is unsure
13:00:34 <jmg_> edwardk: thanks, than I should meditate more about that errors
13:00:53 <SamB> Set theory doesn't seem to work well computationally ;-)
13:01:07 <ddarius> SamB: That question doesn't make much sense.
13:01:13 <gubagem> SamB: why do you want to throw out set theory, ohhhhh
13:01:16 <BMeph> edwardk: Fail isn't evil, just misunderstood. ;)
13:01:17 <edwardk> doun: A category is basically a big bag of 'morphisms' with an associativity law basically.
13:01:38 <SamB> ddarius: I want to know if it can be trashed without losing anything important
13:01:50 <gubagem> an associativity law for the Functors? of that category?
13:01:53 <ddarius> SamB: In what context?  What is "important"?
13:02:02 <SamB> i.e. if we would lose analysis, it would be a no-go
13:02:09 <SamB> that sort of thing
13:02:10 <edwardk> gubagem: you usually define the bassics of category theory in terms of set theory. categories for the working mathematician starts out that way, but gives an appendix with the construction of a finite flavor of set theory in terms of category theory directly.
13:02:31 <edwardk> BMeph: and in the wrong typeclass ;)
13:02:34 <gubagem> so its a different like spoke of mathematics then set theory
13:02:50 <ddarius> SamB: You could axiomatize these things, but most likely you'd just end up with something Set theory-ish.
13:02:52 <SamB> edwardk: that didn't sound right
13:03:10 <SamB> @google abstract stone duality
13:03:11 <lambdabot> http://www.cs.man.ac.uk/~pt/ASD/
13:03:12 <lambdabot> Title: redirection to www.PaulTaylor.EU/ASD
13:04:02 <hpaste>  jmg pasted "(no title)" at http://hpaste.org/7837
13:04:24 <edwardk> gubagem: the associativity law being that any order you compose a given chain of morphisms gives you the same morphism.
13:04:24 <jmg_> seanmce: have a look here : http://hpaste.org/7837
13:05:45 * SamB wonders why that page gets the wigglies
13:06:06 <gubagem> edwardk: I get the associativity part, but whats a category? can it be a set, a group, a ring, a powerset, what is it all those things and then more because it is more general?
13:07:32 <seanmce> jmg_: thanks, i'll try it
13:07:53 <jmg_> seanmce: you're welcome
13:08:01 * SamB wonders whether he is a programmer or a theoretical computer scientist
13:08:07 * SamB decides to go with the latter
13:08:07 <edwardk> gubagem: basically a category itself is pretty simple. its just a kind of monoid on morphisms composition. you get the fact that for every 'object' in the category you have an identity arrow and that arrow composition is associative. at that level a category is pretty boring. category theory just gives you tools for building up over that base.
13:08:21 <ddarius> SamB: Do you write code that is executable?
13:08:28 <edwardk> er s/morphisms/morphism/
13:08:57 <SamB> ddarius: how am I supposed to know if my theorems are good if they won't run?
13:08:59 <dbpatterson> can someone explain fmap to me?
13:09:18 <ddarius> SamB: By proving them correct with pencil and paper.
13:09:22 <dbpatterson> oh wait, mapM but with functors?
13:09:40 <SamB> ddarius: pencil and paper are known not to be very reliable for that purpose
13:09:41 <ddarius> dbpatterson: fmap id = id and fmap (f . g) = fmap f . fmap g plus the type says everything.
13:09:44 <SamB> they are pretty good for writing stuff
13:09:50 <SamB> but not so good for checking your work
13:09:53 <edwardk> gubagem: it just turns out that most of those ideas, sets, groups, rings, etc. have some operation that is associative, so we typically view the world through the category theory lens, and call that the operation composition, and the things it composes the morphisms and then we keep trying to apply the common bag of tricks that category theory gives us to the other properties we have
13:09:54 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/7837#a1
13:10:20 <ddarius> SamB: Nevertheless, that would decide the issue for you.  Alternatively, if your primary language is TeX...
13:10:51 <SamB> ddarius: I'd like to see a proof of a theorem in TeX!
13:10:53 <seanmce> jmg_: it doesn't compile when I try to call it. See my annotation
13:11:12 <SamB> I don't think it even has a typesystem!
13:12:06 <edwardk> once you have the tools you can go through and see things like 'powerset' is a monad over set, and then you can bring to bear the monad machinery. without having to prove everything all over again.
13:12:15 <flux> samb, hmm, it's difficult to say. you can't really run tex programs, only compile, or vice versa?
13:12:42 <SamB> flux: well, the closest to "compile" is "dump a format"
13:13:06 <SamB> flux: you can certainly run them -- where do you suppose DVI (or now PDF) files come from?
13:13:42 <flux> samb, well, are you running your haskell program when you produce executable files by using ghc on them?
13:14:28 <edwardk> dons: i love the monad fail post =)
13:14:30 <flux> well, you're not, but yes, it's not the same thing ;)
13:14:35 <SamB> flux: of course not
13:14:59 <SamB> but are you running postscript files when you print or view them
13:15:09 <ddarius> Yes.
13:15:34 <dons> dcoutts: i think in modern haskell we really are ok with having effects stated in the type. in particular, "my program could fail" is really something i want to rule out statically
13:15:37 <flux> so a proper type system in a tex-like system would guarantee it would produce properly executing ps (or intermediate) files?
13:15:42 <dons> so yeah, fail is ok, but has to be in another class.
13:16:02 * SamB wonders if anyone has ever accidentally run a postscript program when attempting to print a listing of it
13:16:11 <dons> edwardk: :D
13:16:30 <SamB> flux: eh?
13:16:32 <edwardk> unfortunately there is a certain inertia and that pesky haskell 98 thing about its current location
13:16:44 <dons> yeah
13:16:57 <dons> at least we can prevent new uses of fail instead of safer alternatives
13:17:02 <ddarius> I think Haskell 98 is the primary source of that inertia.
13:17:10 <edwardk> yeah
13:17:12 <SamB> Haskell 98 must be destroyed
13:17:30 <SamB> hmm.
13:17:30 <edwardk> i wish there was any way to break that 'required compatibility' without screwing everyone
13:18:03 <SamB> the question is, is it really screwing everyone to break their code now to improve things in the long run?
13:18:13 <edwardk> in my case I have to go through and hide, hide! a monad instance for Either to work around that stupid thing.
13:18:17 <dbpatterson> sclv_: where is |= defined?
13:18:38 <edwardk> and then i have to be careful not to import Control.Monad.Error by any means
13:19:41 <edwardk> if it was factored out, then i wouldn't have to worry about apomorphisms not being able to use Either because the monad is cocked up by a spurious dependency on Error.
13:20:16 <noecksit> hello, i seem to be getting some weird assertion error when using gtk2hs and threads
13:21:07 <noecksit> even though i did "timeoutAddFull (yield >> return True) priorityDefaultIdle 50"
13:21:36 <noecksit> has anyone experienced that ever before?
13:21:56 <edwardk> I found http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg03267.html at least erik meijer tried to stop the fail train ;)
13:21:57 <lambdabot> Title: MonadZero
13:22:22 <dons> i knew John Hughes must have been behind this!
13:22:32 <dons> and now he's off in erlang land anyway.
13:22:33 <ddarius> We added fail and now Erik Meijer writes VB
13:22:45 <jmg_> seanmce: i'm sorry, but i don't get it right
13:22:46 <edwardk> ddarius: hrmm you drove him off!
13:22:53 <dons> JH complaining about haskell's restrictive type system at last year's ICFP makes sense now
13:23:39 <dons> ah, but no, is JH arguing for MonadZero here too?
13:24:00 <dons> yes, JH and EM. interesting.
13:24:15 <edwardk> wadler tried to fight it off too
13:24:27 <gubagem> whats MonadZero
13:25:38 <dolio> I didn't realize that 1.4 had different semantics for pattern matching than 98's irrefutable patterns.
13:25:54 <edwardk> gubagem: the short answer is 'the place where fail should go =), the long answer is 'mzero :: m a', the 'identity half' of MonadPlus.
13:26:18 <gubagem> is fail like a barfing segfault
13:26:18 <edwardk> weren't products strict or something?
13:26:38 <ddarius> fail is just a function
13:26:48 <dons> ?src fail
13:26:49 <lambdabot> fail s      = error s
13:26:52 <dolio> I don't know. Apparently they had 'unfailable patterns'.
13:26:53 <gubagem> do haskell binaries have some sort of runtime (from ghc) that makes them give those pretty error messages, and is the code really x86 or is it bytecode
13:27:00 <dons> edwardk: strict products? that'd be curious
13:27:15 <dolio> Which don't take bottom into account as to whether they're refutable, I guess.
13:27:20 <dons> gubagem: ghc compiles haskell source to native code for the architecture you are on
13:27:32 <edwardk> fail is 'wrong way please try again' in a haskell monad. in the list monad it just cuts off that path, in a lot of monads it translates to error.
13:27:40 <dons> which is linked with the haskell runtime system, which provides multithreading, memory management, etc.
13:28:06 <cmschat> # Appears as ARMANDO
13:28:09 <edwardk> dons: i forget the detail that led me to think in that direction there was something that was more strict than it is now, wasn't there?
13:28:38 <edwardk> @src fail Maybe
13:28:38 <lambdabot> Source not found.
13:28:44 <edwardk> @src Maybe fail
13:28:45 <lambdabot> fail _      = Nothing
13:28:58 <edwardk> @src [] fail
13:28:59 <lambdabot> fail _      = []
13:29:22 <ddarius> dolio: Presumably 'unfailable' refers to the fact that case undefined of (_,_) -> 3 is undefined while case undefined of ~(_,_) -> 3 is 3.
13:29:54 <dolio> Christian Sievers suggests making products unlifted to rectify the problem of monadic matchign on pairs.
13:31:01 <dolio> ddarius: Right, it can't fail to match any constructors.
13:31:01 <dons> woot, http://www.googlefight.com/index.php?lang=en_GB&word1=haskell&word2=erlang
13:31:01 <lambdabot> Title: Google Fight : Make this fight with googleFight haskell VS erlang, http://tinyurl.com/66esbn
13:31:01 <sjanssen> dolio: there is a problem with monadic matching on pairs?
13:31:01 <ddarius> dons: Haskell is a common word, erlang is not.
13:31:01 <BMeph> > case undefined of [_] -> 3
13:31:01 <lambdabot>  Exception: Prelude.undefined
13:31:01 <edwardk> bah ralf hinze is on the fail train. checking to see who else to call names.
13:31:01 <dolio> sjanssen: Well, they didn't like that 'do x <- m ...' is Monad m => ... and 'do (x,y) <- m ...' is MonadZero m => ...
13:31:01 <BMeph> > case undefined of (_:_)-> 3
13:31:01 <lambdabot>  Exception: Prelude.undefined
13:31:07 <dons> ddarius: right.
13:31:17 <BMeph> > case undefined of ~(_:_)-> 3
13:31:18 <lambdabot>  3
13:31:20 <sjanssen> dolio: ah
13:31:32 <sjanssen> dolio: I'd say that single constructor types should have an exception
13:31:41 <sjanssen> because they can't fail in any meaningful way
13:31:43 <dolio> sjanssen: In 1.4 those would both have been Monad m => ... I guess, because (x,y) is unfailable.
13:31:45 <jmg_> seanmce: it seems it is not possible to write your echo without repeating most stuff from Text.Printf, since it's contents is hidden
13:33:16 <ddarius> > let echo verbose str r = if verbose then printf str r else "" in (echo False "%0.5f" pi, echo True "%0.5f" pi)
13:33:17 <lambdabot>  ("","3.14159")
13:35:14 <sjanssen> @google haskell 1.4 report
13:35:16 <lambdabot> http://www.cs.auckland.ac.nz/references/haskell/haskell-report-1.4-html/
13:35:16 <lambdabot> Title: The Haskell 1.4 Report
13:35:41 <ddarius> If you want to get the same kind of pattern, echo needs to end PrintfType r => ... -> r
13:35:41 <sjanssen> dolio: where should I look for unfailable patterns?
13:35:43 <jmg_> > let echo verbose str r = if verbose then printf str r else "" in (echo False "%0.5f" pi, echo True "%d" 1)
13:35:45 <lambdabot>  ("","1")
13:36:11 <dolio> sjanssen: I don't know. That mailing list thread linked to above is the first I'd heard of them.
13:36:20 <dolio> sjanssen: Presumably they're in the 1.4 report somewhere.
13:36:47 <ddarius> > printf "" 1 2 3 :: String
13:36:48 <lambdabot>  "Exception: Printf.printf: formatting string ended prematurely
13:37:04 <jmg_> > let echo verbose str r = if verbose then printf str r else "" in (echo False "%0.5f" pi, echo True "%d %d" 1 2)
13:37:04 <lambdabot>  Couldn't match expected type `t1 -> t'
13:37:51 <sjanssen> dolio: http://www.cs.auckland.ac.nz/references/haskell/haskell-report-1.4-html/exps.html#sect3.14
13:37:53 <lambdabot> Title: The Haskell 1.4 Report: Expressions, http://tinyurl.com/5hltd3
13:37:57 <sjanssen> dolio: look for "failure-free"
13:38:16 <dolio> Ah.
13:38:55 <sjanssen> those choices seem sane to me, let's bring back MonadZero!
13:42:39 <dons> its really basic haskell  stuff: if you're doing something that might crash the program, that should be in the type
13:43:20 <sjanssen> > error "it should?" :: Int
13:43:22 <lambdabot>  Exception: it should?
13:43:26 <dons> right.
13:43:34 <dons> 'error' is a bane in high assurance code
13:43:40 <dolio> > (\ ~(x:xs) -> x:x:xs) undefined `seq` ()
13:43:41 <lambdabot>  ()
13:43:42 <sjanssen> > let x = x in x
13:43:43 <lilac> dons: lol@blog
13:43:50 * dons starts the brotherhood of total functional programming!
13:43:58 <lambdabot>  thread killed
13:44:25 <dons> unfortunately, error is much more common than non termination.
13:44:32 <dons> and is deep down in some core libraries
13:45:00 <sjanssen> > let f x = x `seq` f (x+1) :: Int in f 0 -- this will lock up all other threads forever
13:45:11 <lambdabot>  Exception: Time limit exceeded
13:45:55 <dolio> I don't know. I'm not sure how interested I am in total programming without dependent types.
13:46:07 <dons> read s = either error id (readEither s) is one of the worst
13:47:03 <dolio> Definitely needs some readM.
13:47:15 <sjanssen> @hoogle readEither
13:47:16 <lambdabot> No matches found
13:47:36 <dolio> readEither is internal to the (ghc?) implementation, and isn't exported.
13:47:50 <ddarius> read :: (Read a, MonadZero a) => String -> m a
13:47:56 <dons> getEnv is another shocker
13:47:59 <dons> :t getEnv
13:47:59 <sjanssen> MonadZero m
13:48:01 <lambdabot> Not in scope: `getEnv'
13:48:04 <dons> :t System.IO.getEnv
13:48:07 <lambdabot> Not in scope: `System.IO.getEnv'
13:48:10 <sjanssen> at least it can raise a proper exception
13:48:11 <dons> :t System.IO.Environment.getEnv
13:48:13 <lambdabot> Couldn't find qualified module.
13:48:16 <sjanssen> but yes, still annoying
13:48:17 <dons> :t System.Environment.getEnv
13:48:19 <lambdabot> String -> IO String
13:48:22 <dons> there we go.
13:48:34 <dons> but typical 'common case will crash program' :(
13:48:37 <lilac> what would you do with refutable pattern matching then? require MonadZero?
13:48:50 <ddarius> dons: Does it not give an ioError?
13:49:07 <dons> ioException, yes.
13:49:10 <ddarius> lilac: That's how it was.
13:49:22 <dons> System.IO.Error.isDoesNotExistError
13:49:29 <lilac> sure, but presumably it was changed from that for a reason
13:49:30 <ddarius> dons: What's wrong with that (besides the IO exception mechanisms being clunky)?
13:49:40 <dolio> is does?
13:49:43 <dons> looking up variables that may not be defined is very common
13:50:09 <dons> but by default this will crash your program. so its the opposite of haskell's usual flavour
13:50:12 <ddarius> dons: Isn't there another variant that is more explicit?
13:50:25 <dons> no, only getEnvironment, which returns the entire environment in an association list
13:50:45 <ddarius> :t getEnvironment >>= lookup
13:50:46 <lambdabot> Not in scope: `getEnvironment'
13:51:04 <dcoutts> noecksit: what was the symptom of the problem?
13:51:17 <dons> i can't think of a good reason why getEnv by default should crash, actually. who would rely on that behaviour?
13:51:47 <sjanssen> ddarius: that is a bit absurd, since the C interface provides a way to get a single variable or detect the absence of that variable
13:51:51 <lilac> i quite like the notion of each constructor defining its own subtype, so that given "data F = Foo Int | Bar", "do { Foo x <- a; return x }" would have type "Monad m => m Foo" rather than "Monad m => F", but it means constructors and types have to go in the same namespace :(
13:52:09 <sjanssen> dons: why wouldn't you rely on that?  It is documented
13:52:09 <lilac> s/Monad m => F/Monad m => m F/
13:52:19 <ddarius> sjanssen: I'm not saying that a getEnv :: String -> IO (Maybe String) is inappropriate.
13:52:21 <dons> ok. i mean, why is this useful?
13:52:40 <dcoutts> dons: for cases where you expect to find the env var
13:52:57 <dons> oh, hmake does this , actually.
13:52:57 <dcoutts> dons: it's like readFile failing if you specify a non-existant file
13:53:00 <dons> its really frustrating.
13:53:07 <dons> you have to set an env var for the program to work
13:53:15 <lilac> dons: how about it being "MonadFail f => IO (f String)"?
13:53:26 <dons> :t lookup
13:53:27 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
13:53:29 <ddarius> dons: Admittedly most people don't write programs that way.
13:53:34 <sjanssen> should readFile :: IO (Maybe String)?
13:53:38 <dons> :t lookupEnv :: String -> IO (Maybe String)
13:53:40 <lambdabot> Not in scope: `lookupEnv'
13:53:45 <dcoutts> sjanssen: no, that'd be annoying :-)
13:53:52 <dons> its about how exceptional the case is.
13:53:57 <dcoutts> dons: exactly
13:54:03 <dons> getEnv not finding a value in the map is not exceptional
13:54:14 <ddarius> :t \s -> liftM Just getEnv `catch` const Nothing
13:54:16 <lambdabot> Not in scope: `getEnv'
13:54:24 <ddarius> :t \s -> liftM Just System.Environment.getEnv `catch` const Nothing
13:54:24 <dcoutts> dons: which is why I think I advocate callProcess :: FilePath -> [String] -> IO ()
13:54:26 <lambdabot>     Couldn't match expected type `IO a1'
13:54:26 <lambdabot>            against inferred type `String -> IO String'
13:54:26 <lambdabot>     In the second argument of `liftM', namely
13:54:39 <dcoutts> dons: compared to the current rawSystem which returns ExitCode
13:54:42 <ddarius> :t \s -> liftM Just System.Environment.getEnv s `catch` const (return Nothing)
13:54:44 <lambdabot>     Couldn't match expected type `IO a'
13:54:44 <lambdabot>            against inferred type `Maybe a1'
13:54:44 <lambdabot>       Expected type: a1 -> IO a
13:55:09 <ddarius> :t \s -> liftM Just (System.Environment.getEnv s) `catch` const (return Nothing)
13:55:11 <lambdabot> String -> IO (Maybe String)
13:55:59 <dons> i usually use handle (return $ const Nothing) (getEnv s)
13:56:06 <dcoutts> dons: going back to monad fail, I don't actually get why people think MonadPlus is the answer, why should the possibility of failure imply that we have some kind of alternative combinator? I mean sure we might have one as well, but it's not necessary.
13:56:17 <dons> along with readMaybe, two things defined in every real program
13:56:24 <dcoutts> is IO in MonadPlus?
13:56:35 <dons> dcoutts: yeah, i don't get that either
13:56:51 <bringert> I though the argument was for a MonadZero, with just fail
13:57:11 <dcoutts> bringert: ah, ok. And MonadPlus extends MonadZero?
13:57:15 <bringert> yeah
13:57:55 <dcoutts> that's ok then
13:58:30 <dobblego> can lambdabot join two networks with the one instance?
13:59:10 <int-e> But should there be any default instances of MonadZero that define  fail = error?
13:59:30 <dcoutts> int-e: no
13:59:45 <dcoutts> imho
13:59:51 <bringert> the problem is with do-notation
14:00:12 <bringert> you could only use pattern matching if do for MonadZero
14:00:20 <bringert> which actually makes sense
14:01:41 <BMeph> Sounds like maybe Tullsen was right...
14:03:47 <int-e> dobblego: that should work.
14:03:57 <dcoutts> bringert: right, so for single constructor data types it's ok
14:04:03 <dcoutts> (a,b,c) <- foo
14:04:14 <dcoutts> since that cannot fail (except if foo return _|_)
14:04:26 <dcoutts> and if it does return _|_ then it's _|_ anyway, not fail
14:04:34 <sjanssen> http://www.cs.auckland.ac.nz/references/haskell/haskell-report-1.4-html/exps.html#sect3.14
14:04:35 <lambdabot> Title: The Haskell 1.4 Report: Expressions, http://tinyurl.com/5hltd3
14:04:36 <bringert> or in general any pattern that can't fail
14:04:45 <dcoutts> indeed
14:04:50 <sjanssen> dcoutts, bringert: the 1.4 report defines all such patterns
14:04:59 * dcoutts reads
14:05:01 <bringert> hmm, how do irrefutable patterns work in do?
14:05:37 <dcoutts> bringert: they're irrefutable! :-)
14:05:39 <dcoutts> so cannot fail
14:05:45 <ddarius> bringert: Now or then?
14:05:48 <dcoutts> sjanssen: ah yes, that looks quite sane
14:05:50 <sclv> dbpatterson: |= is in StringTemplate
14:05:52 <ddarius> (Either way it works out to the same)
14:06:05 <int-e> > do x@(~1) <- [1..2]; return x
14:06:07 <lambdabot>  [1,2]
14:06:16 <int-e> err.
14:06:29 <int-e> > do ~(x@1) <- [1..2]; return x
14:06:30 <lambdabot>   Irrefutable pattern failed for pattern ((x@1))
14:06:48 <dcoutts> int-e: heh, subtle
14:07:14 <dcoutts> dons: yes, I think we should argue for the Haskell 1.4 semantics for Monad / MonadFail for Haskell'
14:07:17 <sclv> reading that old thread is like watching a horror movie... you know what's going to happen and you can't look away. :-)
14:07:28 <dcoutts> :-) yeah
14:07:38 <sjanssen> dcoutts: it will break heaps of code
14:07:51 <dcoutts> sjanssen: because they define fail?
14:08:14 <sjanssen> dcoutts: or because they use a refutable pattern match and give a type signature of Monad m =>
14:08:20 <ddarius> Type declarations will need to change too.
14:08:44 <ddarius> The changes will be rather minor in the vast majority of cases.
14:08:46 <dcoutts> sjanssen: I rather get the impression that very little code actually uses refutable pattern matches in do blocks
14:08:49 <edwardk> sclv: heh
14:08:58 <sclv> I thought the result of the (.) discussion was that breaking changes are fine as long as there's a compelling motivation.
14:08:59 <dcoutts> sjanssen: and even less that's polymorphic in the monad
14:09:15 <edwardk> dcoutts: agreed completely.
14:09:28 <sclv> mainly, custom monads will need to add back MonadZero instances.
14:09:36 <dcoutts> sclv: right
14:09:46 <int-e> dcoutts: it happens though. say,  Just x <- Hash.lookup hash key -- where key is known to be in the hash by other means.
14:09:46 <dcoutts> if they defined fail in the first place
14:10:00 <edwardk> yeah and now that we have a 'wonderful monad library' as they kept saying, the changes are mostly localized anyways
14:10:30 <edwardk> monad transformers kind of kill most of the 'oh my god this will break a dozen of my monads' arguments.
14:10:36 <dcoutts> int-e: is that in IO or an arbitrary monad?
14:11:02 <int-e> dcoutts: IO, I guess. Or something like MonadSTIO m => m x
14:11:05 <sclv> Lots of code calls fail though.
14:11:07 <dcoutts> int-e: if it's in IO then it still works
14:11:24 <sclv> So maybe we need a MonadZero that works, and a MonadFail for pure backward compat.
14:11:31 <dcoutts> int-e: since IO is in MonadZero
14:11:52 <int-e> ok
14:11:54 <dcoutts> sclv: perhaps MonadFail with fail :: String -> m a, and leave MonadZero/Plus for other stuff
14:12:18 <sclv> except that its sort of a wart to have a MonadFail where half the instances throw away the string?
14:12:21 <dons> its great how a good blog post can spur discussion
14:12:32 <sjanssen> sclv, dcoutts: what is the purpose of having separate classes?
14:12:38 <sclv> mspaint ftw!
14:12:52 <edwardk> monadfail can fit into monadzero, you have a zero, so fail can have a default definition.
14:13:09 <sjanssen> fail = const mzero
14:13:09 <ddarius> dons: Your blog post was hardly necessary. This is a discussion that's occurred several times.
14:13:14 <sclv> edwardk: right, that makes sense.
14:13:24 <dcoutts> sjanssen: presumably there are real uses of MonadZero/Plus, eg in parsers or whatever and the simple convenience string error message isn't really the same thing
14:13:41 <dons> ddarius: right. and it was just starting up again.
14:13:43 <dcoutts> it's not as if fail is a good error reporting mechanism
14:13:53 <edwardk> i whinged about it about a year back, i beat my head against it again when i started defining more generic apomorphisms, so i feel the pain freshly ;)
14:13:54 <dcoutts> since there is no structure to the error type
14:14:22 <sjanssen> maybe we could have class MonadZero m => MonadFail m
14:14:26 <BMeph> Heh-heh, "instance ... MonadFail where error s = fail" Yes! >8)
14:14:54 <sjanssen> dcoutts: actually, can you name any Monads that should be MonadZero but not MonadFail?
14:14:55 <twanvl> but should pattern matches uses MonadZero or MonadFail?
14:15:00 <int-e> sjanssen: how do you decide whether () <- foo  should use fail or mzero?
14:15:13 <ddarius> Maybe
14:15:24 <int-e> Maybe, List, Nondet
14:15:29 <sclv> which gets us a nice MonadError too?
14:15:41 <edwardk> twanvl: roll them together, then call fail on all of them with a text error message, fail can call the mzero instance by default discarding the message
14:15:44 <sjanssen> actually, I asked that in the wrong way
14:15:47 <edwardk> but you can't manufacture information
14:16:04 <edwardk> so calling mzero wastes info on the failed pattern
14:16:20 <int-e> MonadError just shouldn't grab the generic Either for error states, IMO.
14:16:23 <sjanssen> can we all agree that the exceptions containing line numbers and such are useful?
14:16:25 <dcoutts> sjanssen: my point is that they're somewhat different purposes, not that there might be lots of monads that are in one and not the other
14:16:35 <sclv> int-e: agreed.
14:16:56 <sclv> sjanssen: that's a distinct issue though, no?
14:17:07 <sjanssen> sclv: it is related
14:17:08 <dcoutts> sjanssen: I'm not so sure, since you do not get a stack trace you do not know which caller is to blame
14:17:10 <edwardk> int-e: if you pull fail out into MonadZero, then using Either for error state is harmless, its the oh crap i can't use Either as a monad at ALL without an instance of error that causes the problem
14:17:26 <sjanssen> if we want to have those error messages, then do desugaring must use fail, not mzero
14:17:36 <dcoutts> yes
14:17:57 <sclv> sjanssen: i agree
14:18:10 <edwardk> sjanssen: so, then define mzero, fail, and failedPattern :: String -> Int -> String -> m a which passes the file name, line number and error ;)
14:18:23 <lilac> imo, Either a should be neither MonadZero nor MonadFail, but Either String should be MonadFail but not MonadZero
14:18:29 <sjanssen> edwardk: the question is where fail and failedPattern lie
14:18:47 <lilac> this implies that MonadFail and MonadZero are distinct
14:18:50 <opqdonut> yeah the Either instance for MonadZero is kinda wierd
14:19:51 <twanvl> instance HasZero a => MonadZero (Either a)
14:20:10 <edwardk> sjanssen: sure, usually I am the champion of splitting as many hairs as possible. I just don't see the need to factor them into more pieces than just MonadZero. otherwise you'll probably get enough pressure back from the 'hey one of the major reasons we did this was to avoid having too many classes floating around' crowd.
14:20:31 <sjanssen> edwardk: I agree with you :)
14:20:41 <noecksit> hello, exactly what does the "ghci -threaded code.hs" do?
14:21:07 <sjanssen> I see no reason to split them, especially when we can use 'fail = const mzero' as a default in the class declaration
14:21:07 <edwardk> noecksit: not much unless you give it RTS flags for more than one thread, no?
14:21:11 <noecksit> i seemed to have solved my problem by using this command
14:21:22 <sjanssen> noecksit: it links it against GHC's threaded runtime
14:21:29 <sjanssen> noecksit: what is your problem?
14:22:21 <noecksit> sjanssen : i was having problems with gtk and haskell threads
14:22:43 <sclv> weird, I could have sworn IO had an mzero...
14:22:51 <sjanssen> doesn't it?
14:22:54 <noecksit> sometimes i got assertion failures and segmentation faults, sometimes i didn't
14:22:58 <sjanssen> > mzero :: IO ()
14:22:59 <lambdabot>  <IO ()>
14:23:11 <edwardk> @src IO mzero
14:23:12 <lambdabot> mzero       = ioError (userError "mzero")
14:23:26 <sclv> ah -- just didn't have the right module in my gchi
14:23:37 <opqdonut> twanvl: how about: instance Monoid a => MonadZero (Either a)
14:23:37 <sjanssen> which module is it in?
14:24:08 <sjanssen> opqdonut: aren't there a's that have a zero but not a plus?
14:24:12 <sclv> Control.Monad.Error
14:24:27 <sjanssen> that is stupid
14:24:27 <opqdonut> sjanssen: ah, i was thinking MonadPlus
14:25:04 <opqdonut> argh, i've been battling my way around a haskell encapsulation problem for a week now
14:25:21 <opqdonut> also trying to come up with the right abstractions
14:25:44 <int-e> m `mplus` n = m `catch` \_ -> n
14:25:52 <edwardk> I really have nothing against Error personally, I just find it kicks me in the pants when I want to use the Either monad as the canonical a + b ideal monad =)
14:25:53 <int-e> eek :)
14:27:36 <twanvl> Perhaps we need to lobby for universally quantification in contexts, so we get  MonadPlus m == (Monad m, forall a. Monoid (m a))
14:29:02 <edwardk> apomorphism = generalizedAnamorphism (fmap Left . outF  ||| fmap Right) -- with the current Either, you can't define that because Either is contaminated
14:29:46 <sclv> Alternately we could just get rid of pattern matching in do notation altogether...
14:30:09 <edwardk> or you have to go through and define a 'real' Either, rebuild all the instances on it, and remember not to call anything in the std library =(
14:30:11 <quicksilver> opqdonut: the problem with haskell is there are so many abstractions :)
14:30:25 <quicksilver> opqdonut: it takes a while to decide which one suits a particular problem best.
14:30:27 <sclv> its just sugar for a case expression anyway, and  we have pattern guards and all that now.
14:30:46 <edwardk> sclv: i don't think you'll convince anyone to kill pattern matching there
14:31:13 * sclv has personally never used pattern failable pattern matching in do notation.
14:31:24 <edwardk> sclv: its handy in the list monad
14:31:30 <sclv> the other way would be to get rid of failable pattern matches.
14:31:30 * quicksilver has used it quite often in the [] and Maybe monads
14:31:43 * roconnor not sure if he has either
14:31:50 <sclv> hmm.. yeah, there is that.
14:32:36 <roconnor> pesumably it would be easy to have a MonadZero constratian only if patterns are used in the do clause
14:32:39 <quicksilver> [ x | Left x <- ees ]
14:32:42 <roconnor> constraint
14:32:43 <quicksilver> is quite handy.
14:32:57 <roconnor> quicksilver: on in list comprehensions, all the time.
14:33:04 <sclv> We could keep it, but only for list comprehensions!
14:33:12 <grahamhutton> @users
14:33:12 <lambdabot> Maximum users seen in #haskell: 480, currently: 450 (93.8%), active: 22 (4.9%)
14:33:14 * sclv realizes he is being silly.
14:33:39 <quicksilver> roconnor: I use it in long Maybe monad do blocks too
14:33:49 <quicksilver> guard (this)
14:33:49 <grahamhutton> hmm. what happened to 500 users on Haskell...
14:33:52 <quicksilver> guard (that)
14:33:56 <quicksilver> Foo x <- bar
14:34:00 <edwardk> i was just looking for the least obtrusive fix
14:34:02 <quicksilver> guard (baz x)
14:34:03 <quicksilver> return x
14:34:27 <monochrom> 500 users will happen in the near future
14:34:29 <edwardk> the minimalist answer is to roll the minimum amount of stuff to ease everyone's pain into MonadZero
14:34:48 <skorpan> @pl \s -> (x s, y s)
14:34:48 <lambdabot> liftM2 (,) x y
14:34:52 <skorpan> nice
14:34:56 <quicksilver> no, grahamhutton is right, it was 500 once
14:34:59 <quicksilver> LB lost her database.
14:35:12 <hpaste>  morrow pasted "hscsv vs. parsec-csv" at http://hpaste.org/7842
14:35:20 <sclv> anyway somebody authoritative should write this discussion up and send it to the prime list.
14:35:29 <grahamhutton> monochrom: seems that the numbers have reduced a bit in recent months
14:35:37 <skorpan> @pl \s -> (x s, y s, z s)
14:35:37 <lambdabot> ap (liftM2 (,,) x y) z
14:36:18 <grahamhutton> (it hasn't hit 500 yet, as noted above by lambdabot)
14:36:21 <skorpan> @src (,,)
14:36:21 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:37:10 <ziman> hm, how does pattern-matching in do-block work? shouldn't "do { (Just x) <- [Just 3, Nothing]; return x }" be equivalent to "[Just 3, Nothing] >>= \(Just x) -> return x"? Because the latter one produces an error wile the first one does not.
14:37:11 <quicksilver> skorpan: (,,) is primitive.
14:37:17 <quicksilver> skorpan: it's the constructor for 3-tuples.
14:37:30 <quicksilver> ziman: no, it's a clever trick
14:38:04 <quicksilver> ziman: it's equivalent to >>= \xx -> case xx of Just x -> retun x ; _ -> fail "do pattern match"
14:38:21 <edwardk> one last alternate suggestion, if you can't win the monadzero argument. since a big shift to monadlib or something is already in the air. letting go of Either, in exchange for an explicit Error monad with Error | Ok constructors or something
14:38:31 <MyCatVerbs> quicksilver: oh hey, I didn't know that there were versions of higher arity than just (,). Tell me, are there perchance (,,,,) and possibly even (,*k) for many different values of k?
14:38:56 <ddarius> monochrom: The rise has slowed quite a bit recently, though fall will bring more people.
14:38:57 <quicksilver> MyCatVerbs: yes. ISTR haskel compilers are required to do tuples up to 15. I could be wrong.
14:38:58 <edwardk> then Either can be a monad in its purest sense, and Error can have all the connotations it currently has, since Identity -> Id, etc, all these kinds of tweaky changes are in the air anyways
14:39:09 <quicksilver> :t (,,,,,,,,,,,,,,,,,,)
14:39:12 <lambdabot> forall a b c d e f g h i j k l m n o p q r s. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)
14:39:12 <ddarius> grahamhutton: The top is 482.
14:39:23 <quicksilver> MyCatVerbs: I think ghc might work for any number.
14:39:24 <ziman> quicksilver, i see. thank you.
14:39:40 <grahamhutton> indeed, not yet 500, but it was heading there a few months ago, but seems to have dropped back now...
14:40:00 <monochrom> Last night the count was 419. Also last night the historic maximum seen by lambdabot was 451. Now it's 450 again. I think as average increases, variance also increases. Expect something like 450-700 swing within a day next year. :)
14:40:03 <MyCatVerbs> quicksilver: oh sexy.
14:40:12 <edwardk> meh, come september/october we should shoot over when there is a semester starting or something like that
14:40:21 <sclv> obviously we need to step up our dosages of the water supply.
14:40:28 <MyCatVerbs> quicksilver: now we just need to find a way of autogenerating liftM6 through liftM400 for all these extra commas.
14:40:59 <MyCatVerbs> monochrom: what if it's the sum of a gaussian and a constant?
14:41:00 <roconnor> TemplateHaskell ?
14:41:20 <monochrom> Heh, I don't even know it's Gaussian.
14:41:30 <dons> grahamhutton: yeah, it has been relatively stable for a few months
14:41:34 <MyCatVerbs> monochrom: like, there are maybe a couple dozen people who, come Hell or high water, are guaranteed to be in here. Oldschool haskell hackers and the like.
14:41:36 <dons> for the first time in a 18 months or so
14:41:50 <grahamhutton> hi dons!
14:41:51 <dons> we would have hit 500 now, had the growth continued, after 450 in jan or so.
14:42:14 <MyCatVerbs> monochrom: and then the gaussian term, whose mean is increasing over time.
14:42:21 <skorpan> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
14:42:22 <skorpan> ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
14:42:23 <lambdabot> parse error (possibly incorrect indentation)
14:42:23 <edwardk> i scared them away with badly interpreted category theory ;)
14:42:24 <skorpan> :)
14:42:46 <monochrom> Note: gaussian(m,s) + constant = gaussian(m+constant, s)
14:42:55 <MyCatVerbs> monochrom: as the gaussian's mean increased, the variance would *appear* to be increasing, because it'd be gradually getting larger by comparison to the rock-steady constant.
14:43:02 <ddarius> edwardk: I've been scaring them with uninterpreted category theory for six years.
14:43:19 <edwardk> ddarius: =)
14:43:21 <dons> the number of unique nicks is on target to increase again
14:43:25 <dons> http://www.cse.unsw.edu.au/~dons/irc/
14:43:26 <lambdabot> Title: Haskell IRC Activity
14:43:49 <monochrom> We need more reddit trolls to troll haskell :)
14:43:53 <edwardk> woot, i'm almost back to the bottom of the 'real people list' ;)
14:43:58 <dons> monochrom: hah
14:44:17 <MyCatVerbs> monochrom: Isn't the average observed variation from the mean propo... damn, no it isn't.
14:44:23 * monochrom goes establish a secret society called "the Emmanuel Haskell Goldstein society"...
14:44:23 <MyCatVerbs> monochrom: bah, I suck at statistics. :(
14:44:28 <edwardk> i suppose taking 3 months off haskell at the beginning of the year didn't help my standing in the listings;)
14:44:38 <dons> you can see here there has been a spike this week, http://www.cse.unsw.edu.au/~dons/irc/haskell-08.html
14:44:39 <lambdabot> Title: #haskell @ freenode.org stats by dons
14:45:42 <MyCatVerbs> monochrom: eh? Why the 1984 reference?
14:45:47 <ddarius> My crap is spread over two nicks.
14:46:12 <MyCatVerbs> monochrom: besides, shouldn't we be ripping the Lisp hackers off instead? I'm thinking maybe "Knights of the Strongly Typed Lambda Calculus".
14:46:28 <hpaste>  morrow annotated "hscsv vs. parsec-csv" with "(no title)" at http://hpaste.org/7842#a1
14:46:45 <monochrom> MyCatVerbs: Don't get too precise (like fixing something as Gaussian), and you'll be right. The variation happens to be propertional to the mean (for whatever reason --- there are several good ones), and therefore the range grows in absolute number, that's all you need to claim.
14:48:19 <MyCatVerbs> monochrom: alternatively, we could claim that it's secretly a Poisson wearing a funny hat. Those have variation equal to the mean, right?
14:48:28 <monochrom> Yes!
14:48:49 <monochrom> People come and go. It should be Poisson.
14:48:55 <MyCatVerbs> http://en.wikipedia.org/wiki/Image:Simeon_Poisson.jpg <-- now just add a hat and one of those Groucho Marx disguise kits.
14:49:14 <dbpatterson> sclv: could you check out this - http://dbpatterson.com/articles/9 - specifically the stuff on the Control.Applicative stuff I am very unsure of... but hopefully something like this would be helpful? I might format it a little better too.
14:49:16 <lambdabot> Title: dbpatterson.com - Demystifying hvac - Making sense of all the symbols.
14:49:59 <ddarius> dbpatterson: s/apposed/opposed
14:50:27 <koninkje_away> @pl (\m n -> m >>= put >> n)
14:50:28 <lambdabot> (>>) . (put =<<)
14:51:11 <dbpatterson> ddarius: thanks, changed
14:51:50 <MyCatVerbs> monochrom: thing is, the variance here seems to be pretty low.
14:54:48 <sclv> dbpatterson -- it looks nice. "h |\ (\arg1 -> |\ (\arg2 -> ...))." is missing an h
14:55:20 <sclv> "match the next work" should be word, no?
14:55:49 <sclv> for your own purposes, you may want to learn more about applicatives though -- they're really handy.
14:56:16 <dbpatterson> sclv: thanks, fixed word, and I'll fix that h... yes, applicatives... any good tutorials?
14:57:18 <sclv> oh, and "which simple names an unnamed value to be injected into a template." should be simply, and maybe "unnamed" is unnecessary. also, I think you misspelled labels in the same para?
14:57:59 <sclv> http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/
14:58:00 <lambdabot> Title: teideal glic deisbhéalach  Blog Archive  The basics of applicative functors,  ..., http://tinyurl.com/2lrb68
14:58:10 <sclv> is a nice tutorial on practical applicatives, by the way.
14:59:11 <sclv> and there's also: http://www.haskell.org/haskellwiki/Applicative_functor
14:59:11 <lambdabot> Title: Applicative functor - HaskellWiki
14:59:20 <dbpatterson> sclv: cool, thanks!
14:59:27 <sclv> where the advice in part 3 is particularly helpful, once you have your head around monads.
14:59:33 <dbpatterson> now I just need an actual read project to work on :)
14:59:40 <dbpatterson> real*
14:59:54 <ddarius> dbpatterson: Implement a lollimon interpreter so I don't have to.
15:00:04 <sclv> learning monads is sort of easy, and then when you get applicatives you start to realize that you actually didn't need everything monads gave you most of the time.
15:00:30 <dbpatterson> sclv: I think I have a (somewhat working) understanding of monads... so I'll look into the applicative stuff
15:00:44 <ddarius> sclv: I suspect most of the time you do.
15:02:01 <dbpatterson> ddarius: maybe in a few months? :) Monadic Concurrent Linear Logic Programming seems a little out of my reach...
15:02:21 <ddarius> dbpatterson: It's pretty beautiful
15:03:30 <sclv> ddarius: well, I think most of the time you need a monad "behind the scenes" but you can still get by using only the applicative combinators more often than you'd think.
15:04:34 <dbpatterson> is anyone using firefox3.0rc1 on linux? haskellwiki looks terrible unless I disable css....
15:05:00 <dbpatterson> characters are spaced apart way too far
15:05:24 <sclv> ddarius: do you work on lollimon for research?
15:06:15 <TomMD> @seen dons
15:06:15 <lambdabot> dons is in #haskell, #xmonad, #haskell-soc and #ghc. I last heard dons speak 21m 37s ago.
15:06:32 <BMeph> Hey, TomMD! :)
15:06:34 <dons> TomMD: yo?
15:07:05 <TomMD> dons: There is a bug in nano-md5 - probably worth posting a warning or fixing.
15:07:09 <BMeph> Woot! I got GLUT to compile! 8D
15:07:15 <TomMD> Basically, due to the static buffer there is a race condition
15:07:17 <dons> TomMD: oh fixing sounds good
15:07:20 <dons> ah!
15:07:24 <dbpatterson> looks like this: http://img211.imageshack.us/my.php?image=sswl4.jpg
15:07:29 <dons> yeah, i meant to revist that.
15:07:55 <dons> TomMD: so not thread safe?
15:08:04 <TomMD> Exactly
15:08:10 <TomMD> I've test code that exposes the issue if you want it.
15:08:15 <dons> yeah, that'd be good.
15:08:18 <dons> 'tis easy to fix.
15:08:23 <TomMD> @where paste
15:08:23 <lambdabot> http://hpaste.org/new
15:08:29 <dons> did you hit in practice?
15:08:33 <dons> or just poking around.
15:08:37 <TomMD> Nope, just poking around
15:08:42 <dons> ok. good to know.
15:09:18 <TomMD> Someone asked in here about inet_ntoa being IO - I figured it was the static buffer and realized the race - took me a bit of time to realize several other packages might have the issue
15:09:34 <dons> yeah, its a good point.
15:09:44 <dons> i think an ffi bindings best practice document would be worthwhile.
15:09:48 <dons> hmm, in a book
15:09:58 <dons> using newtype, foreign ptr, etc
15:10:08 <hpaste>  TomMD pasted "Racing MD5" at http://hpaste.org/7843
15:10:29 <dons> cheers TomMD
15:10:39 <TomMD> np
15:12:08 <ddarius> sclv: No.
15:12:10 <sclv> ddarius: (I ask because coincidentally I was just reading jpolakow's thesis on linear logic today..)
15:12:14 <TomMD> BMeph: Sorry, didn't even see your greeting (not all focus is on the computer ;-)).  How goes it?
15:12:40 <tromp> > showHex 103079215104
15:12:42 <lambdabot>  <[Char] -> [Char]>
15:12:43 <BMeph> No problems, doing okay. You? :)
15:12:45 <tromp> > showHex 103079215104 ""
15:12:46 <lambdabot>  "1800000000"
15:13:09 <TomMD> Things are going well - a Friday, back home after vacation and a long weekend :-)
15:13:24 <tromp> > showHex 241099097344 ""
15:13:25 <lambdabot>  "3822a04500"
15:13:31 <BMeph> Nice timing. ;)
15:13:33 <tromp> > showOct 241099097344 ""
15:13:34 <lambdabot>  "3404250042400"
15:19:36 <tromp> > showOct 103660143872 ""
15:19:37 <lambdabot>  "1404250042400"
15:25:33 <tromp> > showOct 515977004288 ""
15:25:34 <lambdabot>  "7404250042400"
15:28:10 <tromp> > showOct 240518168576 ""
15:28:11 <lambdabot>  "3400000000000"
15:28:25 <mar77a> i have to admit project euler has widely improved my haskell. while i wait for my inefficient brute force method to solve a low-id problem i read wikibooks and tutorials on hs
15:30:14 <Peaker> BMeph, heh - I made it up and later noticed everyone else uses n
15:30:15 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
15:30:36 <lilac> > (\a -> do let Just (Just b) = a; return b) Nothing
15:30:36 <lambdabot>  Parse error at ")" (column 42)
15:31:42 <BMeph> Peaker: Yeah - except German chess players have an easy out; their name for a (chess) knight (Springer) has an initial that doesn't conflict with any other pieces.
15:31:59 <Peaker> BMeph, oh ;) Well, the GUI doesn't use any silly letters
15:32:36 <BMeph> Peaker: :)
15:32:48 <tromp> > showOct 60129542144 ""
15:32:50 <lambdabot>  "700000000000"
15:33:01 <tromp> > showOct 240518168576 ""
15:33:02 <lambdabot>  "3400000000000"
15:33:24 <lilac> > let f a = do let {Just (Just b) = a}; Just b in f Nothing
15:33:26 <lambdabot>   Irrefutable pattern failed for pattern Data.Maybe.Just (Data.Maybe.Just b)
15:33:42 <lilac> > let f a = do Just (Just b) <- a; Just b in f Nothing
15:33:44 <lambdabot>  Nothing
15:33:59 <lilac> hmm, that sucks
15:34:33 <Peaker> BMeph, did you compile the gui?
15:34:35 * lilac is writing "pattern <- return x" a lot
15:35:06 <Peaker> lilac, why?
15:35:09 <BMeph> No, I've just been perusing the code. What graphics package does it use?
15:35:18 <Peaker> BMeph, SDL
15:35:49 <Peaker> BMeph, might be a silly dependency on SDL ttf too even though it doesn't use it (some in-brewed lib that uses it alongside sdl)
15:36:12 <BMeph> I'll check it out, then.
15:36:34 <Peaker> its not very interesting yet, but it seems to work ;)
15:36:46 <lilac> Peaker: I'm in Maybe, and I want Nothing if the pattern doesn't match. it seems to be much more elegant than "case x of pattern -> ...; _ -> Nothing" x lots
15:37:56 <Peaker> lilac, ah I see
15:39:45 <lilac> for monadic list processing, is there a better idiom than "f (x:xs) = return.(x:) =<< f xs; f [] = return []"?
15:40:04 <dons> TomMD: on your blog you say you submitted a patch?
15:40:28 <sclv> ?hoogle mapM
15:40:28 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
15:40:29 <lambdabot> Control.Monad.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
15:40:29 <lambdabot> Data.Traversable.mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:40:35 <sclv> @src mapM
15:40:36 <lambdabot> mapM f as = sequence (map f as)
15:41:07 <Peaker> and the flipped forM alias and the underscore suffixed ones
15:42:02 <lilac> that's no good -- i'm pattern matching "f (p1:p2:xs) = ...", and i may consume more of xs when doing so :(
15:42:11 <sclv> and of course traverse
15:42:15 <Peaker> hmm, seems that SDL's drawing functions aren't wrapped
15:42:24 <lilac> but a HOF approach sounds like a good plan
15:42:33 <Peaker> @type traverse
15:42:35 <lambdabot> Not in scope: `traverse'
15:42:39 <Peaker> @hoogle traverse
15:42:39 <lambdabot> Data.Traversable.traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:42:39 <lambdabot> Data.Foldable.traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
15:43:19 <grahamhutton> lilac: it depends what you want to do.  If you want to map, then mapM is the right thing, if you want to fold, then ...
15:43:23 <sclv> lilac: what sort of function is this where you've got a list that you're taking various amounts from?
15:43:38 <grahamhutton> .k
15:44:05 <grahamhutton> lilac: but pretty much anything you want can be done with monadic fold if you use enough tricks...
15:45:13 <lilac> sclv: current case is something like: transform "#":identifier:rest -> return.("\"" ++ expand identifier ++ "\"":) =<< transform rest
15:45:31 <lilac> grahamhutton: trouble is, it seems like the more tricks i do, the less readable my code becomes ;)
15:45:31 <grahamhutton> there is even a paper somewhere about the expressive power of fold :-)
15:46:08 <grahamhutton> lilac: it's always a tradeoff whether to use abstraction or hard coding.
15:46:19 <tromp> < 253/60
15:46:24 <tromp> > 253/60
15:46:26 <lambdabot>  4.216666666666667
15:46:45 <lilac> grahamhutton: sure. the trick is picking the right level of abstraction ;-)
15:47:26 <grahamhutton> personally, i think maps and filters are fine, but folds often take a step too far.
15:48:09 <sclv> hmm.. break it up into steps maybe -- parse for the '#'char sequences first, then transform, then join...
15:48:20 <sclv> and then chain the whole thing.
15:48:54 <sclv> and the monadic bit only needs to be the transformation.
15:49:34 <sclv> (if that)
15:51:44 <lilac> sclv: hmm, that might well be simpler. thanks!
15:52:03 <dons> TomMD: this makes me want to implement nano-md5-lazy now
15:52:37 <dons> TomMD: how quickly do you get the race condition?
16:00:44 <dons> TomMD: uploaded a threadsafe version. I wasn't able to reproduce any race conditions sadly, so you might want to check on your scheduler/kernel/optimiser whatever
16:04:28 <dv_> heh
16:04:35 <dv_> "the code works. damn!"
16:07:38 <MyCatVerbs> monochrom: oh awesome, Poisson distributions look just like Gaussians (I mean, visually) when lambda gets anywhere above about twenty or so.
16:08:12 <MyCatVerbs> monochrom: three cheers for GNUPlot, four for Henning Thielemann. ^_^
16:10:17 <lilac> is there a 'break' equivalent which breaks after the last match rather than before the first?
16:22:00 <BMeph> lilac: reverse input and match strings? ;)
16:22:13 <lilac> BMeph: that's what i'm doing.
16:22:27 <BMeph> Is it working? :)
16:24:23 <lilac> > let f = snd . break . (not . isDigit) . reverse in f f "hello 12345 foo bar 67 world"
16:24:24 <lambdabot>  Couldn't match expected type `(a, b)'
16:25:19 <lilac> > let f = snd . break (not . isDigit) . reverse in f $ f "hello 12345 foo bar 67 world"
16:25:21 <lambdabot>  "hello 12345 foo bar 67 world"
16:25:34 <lilac> > let f = snd . break isDigit . reverse in f $ f "hello 12345 foo bar 67 world"
16:25:35 <lambdabot>  "12345 foo bar 67"
16:25:57 <lilac> BMeph: yes, it works, naturally
16:26:35 <lilac> but it's a bit messy, and I believe quicksilver would say it's O(n) slower than it needs to be ;-)
16:28:27 <BMeph> Ah, yes, you have to "re-reverse" the string, once you find it. Hmm...
16:29:22 <BMeph> Of course, since you're stripping the string at both ends that way... :)
16:45:44 <Peaker> ok my yucky-code gui is starting to look nice
16:46:35 <dmwit> :t partition
16:46:37 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:46:39 <dmwit> :t groupBy
16:46:41 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
16:46:59 <BMeph> Hmm, has anyone here set up SDL on a Windows system lately? ;)
16:48:59 <Peaker> BMeph, ouch, on Windows.. they probably have an installer...
16:49:20 <BMeph> Oh, sorry, let me rephrase:
16:49:26 <BMeph> Hmm, has anyone here set up HsSDL on a Windows system lately? ;)
16:50:34 <koninkje> when doing type arithmetic, is there a way to capture types being specifically unequal? (or doing Prolog's cut?)
16:51:32 <koninkje> without enumerating all the types, natch
16:53:58 <dmwit> > let onLast f xs = init xs ++ [f (last xs)]; chompBy f = concat . concat . onLast (take 1) . chunk 2 . groupBy ((==) `on` f) . dropWhile f in chompBy isSpace "   hey lilac, how about this?  "
16:53:59 <lambdabot>  "hey lilac, how about this?"
16:54:09 <Peaker> BMeph, cabal install SDL ?
16:54:15 <Peaker> BMeph, the one in sourceforge is ancient/wrong one
16:54:22 <Peaker> BMeph, there's a new SDL on hackage
16:54:31 <Peaker> BMeph, did you set up cabal-install?
16:55:11 <dmwit> It does one pass of size 'n', and a bunch of passes of size 'm', where 'm' is the number of transitions that your predicate makes.
16:55:17 <BMeph> I have it, but I d/l'd the package directly. From Hackage. :)
16:55:41 <dmwit> Probably worse performance in practice, but... =P
16:56:13 <dmwit> koninkje: With a type class?
16:56:25 <dmwit> err...
16:56:26 <dmwit> hum
16:56:27 <Peaker> BMeph, why not use cabal-install? it makes life so easy
16:56:36 <koninkje> dmwit: I'm trying to write a type-level uniq/nub
16:56:40 <BMeph> Odd. "cabal install SDL" calls up 0.5.1, while 0.5.4 sits merrily on Hackage. :|
16:57:18 <BMeph> Plus, it doesn't compile. :(
16:57:19 <koninkje> dmwit: I can do it in Prolog, but only by using the impure cut, since they're also unification driven
16:57:21 <dmwit> koninkje: I think maybe you can do it with two type classes, Greater and Less.
16:57:26 <Lemmih> BMeph: 'cabal update'?
16:57:29 <BMeph> "configure: error: cannot find sources (includes/HsSDLConfig.h.in) in . or .."
16:57:50 <dmwit> koninkje: But I don't know how to "OR" together two types. =P
16:57:53 <BMeph> Hi, Lemmih. :)
16:58:16 <koninkje> dmwit: that could work, the greater/less breakdown
16:58:48 <Peaker> BMeph, btw I didn't yet update the tarball
16:58:53 <dmwit> s/types/typeclasses/
16:59:19 <Peaker> BMeph, you need SDL itself installed (with headers and all accessible. Not sure how you get the -dev equivalent in Windows)
16:59:31 <BMeph> Bah, same problem, it can't find SDL.h, for some odd reason. :(
17:00:09 <BMeph> Peaker: It's on the SDL site, artfully categorized. :)
17:00:29 <Lemmih> BMeph: Are you on windows?
17:00:41 <BMeph> Lemmih: Yes, I am. ;)
17:00:57 <Peaker> BMeph, windows is so stone-age :)
17:00:59 <BMeph> (Thanks for the condolences.) ;)
17:03:06 <Ringwaith> hm
17:03:07 <Ringwaith> /server -m irc.thyexile.net -j #Main
17:15:54 <koninkje> dmwit: I can't seem to get past duplicate instances (or runtime overlapping instance errors) with the greater/lesser approach
17:16:16 <dmwit> Do you actually need both greater and lesser?
17:16:51 <mar77a> bah i need help with "Find the sum of all the primes below two million."
17:17:01 <mar77a> i had a program but i aborted it after like 2 hours
17:17:07 <koninkje> No, just one. but "instance LT a b => NE a b; instance LT b a => NE a b" has issues
17:17:30 <dmwit> koninkje: Really?
17:17:38 <dmwit> mar77a: Write a faster primes generator?
17:17:39 <koninkje> "duplicate instance"
17:17:47 <dmwit> What is the duplicate instance?
17:17:51 <mar77a> can't think of one
17:18:00 <dmwit> mar77a: Then steal one. ;-)
17:18:09 <Saizan> dmwit: they are both "NE a b"
17:18:10 <mar77a> i did and it's slow :<
17:18:16 <dmwit> koninkje: Wouldn't a duplicate instance imply both a < b and b < a?
17:18:22 <luite> steal a better one then?
17:18:29 <mar77a> can't find 8)
17:18:36 <koninkje> dmwit: they're both defining "instance NE a b"-- context is ignored for instantiating instances, much to my dismay
17:18:54 <dmwit> oh...
17:19:01 <dmwit> I'm sure there's some extension that covers that.
17:19:14 * koninkje wishes for forward-chaining instances in haskell'
17:19:18 <dmwit> mar77a: Which one did you steal?
17:20:13 <mar77a> the one from euler solutions
17:20:26 <dmwit> This one?
17:20:29 <dmwit> http://haskell.org/haskellwiki/Prime_numbers
17:20:30 <lambdabot> Title: Prime numbers - HaskellWiki
17:20:38 <mar77a> i don't think so
17:20:49 <dmwit> Then steal that one.
17:21:19 <mar77a> there's like 50
17:21:21 <mar77a> :D
17:21:42 <dmwit> And you said you couldn't find a faster one. =P
17:21:42 <mar77a> hop
17:21:43 <mar77a> it finished
17:21:48 <mar77a> :D
17:23:24 * BMeph is amazed that his PE problem hasn't used up the stack after running for four hours...
17:23:33 <wolgo> Hi
17:23:53 * BMeph is even more impressed, since he's running the program in GHCi
17:24:05 <BMeph> Hi, wolgo! :)
17:24:16 <wolgo> Greetings :)
17:24:30 <ddarius> BMeph: The time spent compiling probably would have paid for itself...
17:25:00 <BMeph> ddaruis: Oh, it compiles in about twenty seconds. ;)
17:25:14 <mar77a> BMeph: which number?
17:25:27 <BMeph> 193.
17:26:08 <mar77a> interesting
17:26:33 <mar77a> > show (2^50)
17:26:35 <lambdabot>  "1125899906842624"
17:26:40 <bohez> does anyone know a good haskell noob tutorial?
17:26:50 <mar77a> yet another haskell tutorial from wikibooks helped me
17:26:53 <mar77a> (and still does)
17:26:59 <mauke> "How to noob in 12 easy steps"
17:27:07 <bohez> ok
17:27:15 <dmwit> ?where yaht
17:27:16 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
17:27:18 <dmwit> ?where gentle
17:27:18 <lambdabot> http://www.haskell.org/tutorial/
17:27:33 <dmwit> bohez: Those two are the most commonly recommended.
17:27:48 <Botje> ?where money
17:27:48 <lambdabot> I know nothing about money.
17:27:51 <Botje> aww
17:27:59 <mar77a> ?where my mom
17:28:00 <lambdabot> I know nothing about my.
17:28:09 <mar77a> ?where haskell
17:28:10 <lambdabot> http://haskell.org/
17:28:15 <mar77a> poo
17:30:52 <bohez> ?where your mom
17:30:52 <lambdabot> I know nothing about your.
17:31:00 <bohez> haha
17:34:15 * SamB wonders why there isn't a name for the kind of algebraic structure the nats are
17:35:19 <kevinu> if i had to guess, id say society
17:36:41 <ddarius> SamB: Huh?
17:37:05 <SamB> ddarius: well, the integers form a field
17:37:10 <SamB> what do the natural numbers form?
17:37:21 <ddarius> The integers don't form a field (except mod a prime)
17:37:29 <SamB> er. ring?
17:37:39 * SamB was maybe thinking rationals
17:37:48 <oklopol> ring?
17:37:49 <oklopol> oh
17:37:54 <ddarius> Natural numbers form a monoid under addition and under multiplication.  They form something called a near-rig
17:38:00 <oklopol> SamB beat me up real bad to it
17:39:16 <ddarius> Actually, they have more structure, they are a semiring.
17:39:36 * SamB wishes Agda had a more convenient notation for these things
17:42:39 <dmwit> "inductive set"
17:42:59 <dmwit> Possibly even "least inductive set".
17:42:59 <mauke> > 0/0 < 0
17:43:00 <lambdabot>  False
17:43:05 <SamB> dmwit: I don't know as Agda's theory involves sets
17:43:10 <dmwit> > cmp (0/0) 0
17:43:11 <hpaste>  (anonymous) annotated "Type mismatches" with "wolgo" at http://hpaste.org/7824#a7
17:43:11 <lambdabot>   Not in scope: `cmp'
17:43:16 <dmwit> > compare (0/0) 0
17:43:17 <lambdabot>  GT
17:43:24 <mauke> > 0/0 > 0
17:43:25 <lambdabot>  False
17:43:27 <dmwit> =/
17:43:44 <SamB> just because the sorts are all called Set...
17:43:45 <BMeph> ?where botjes_mom
17:43:45 <lambdabot> I know nothing about botjes_mom.
17:43:49 <saml> how would you implement fixed point function when it has to have type [Expr] -> Expr ?
17:43:59 <mauke> saml: what?
17:44:06 <xif> hi. this book I'm reading says primMaxInt is the way to find the maximal fixed-precision Int, but it doesn't work in current Hugs or GHC, wha'ts the alternative?
17:44:16 <mauke> maxBound
17:44:27 <wolgo> Hey I have a question: How do you say this in English "not $ null (filter (==bool) string)"
17:44:38 <wolgo> I understand what filter does
17:44:45 <wolgo> jus the not $ null part
17:44:51 <mauke> contains an element equal to bool
17:45:03 <mauke> bool `elem` string
17:45:06 <wolgo> $
17:45:13 <mauke> @src ($)
17:45:14 <lambdabot> f $ x = f x
17:45:17 <dmwit> wolgo: (not . null) tests whether a list is not null.
17:45:21 <Peaker> goddamnit, I found another SDL CInt vs Int bug :P
17:45:33 <dmwit> ...i.e. has some element in it.
17:45:40 <wolgo> oh ok
17:45:50 <wolgo> so $ is similar to function composition?
17:45:56 <mauke> no, function application
17:46:04 <wolgo> AHH
17:46:07 <wolgo> I see
17:46:19 <mauke> 'not' is the function, 'null (...)' the argument
17:46:30 <saml> mauke: fix f = let x = f x in x  (in Haskell). In my language, I can define built-in functions that take [Expr] and outputs Expr, where Expr is my language's value.
17:46:51 <wolgo> so these execute the same job with a different technique (not . null) filter (==bool) string and not $ null filter blah blah
17:47:09 <mauke> the first one needs more parens
17:47:20 <mauke> so does the second one
17:47:26 <wolgo> oh yeah
17:47:34 <wolgo> not $ null (filter blah blah)
17:47:35 <mauke> f (g x) is the same as (f . g) x
17:47:46 <mauke> f $ g x is the same as f . g $ x
17:47:50 <mauke> :-)
17:47:57 <wolgo> Thanks Mauke
17:48:00 <wolgo> I am getting there.
17:48:11 * wolgo admits he is a dense guy
17:48:32 <Peaker> Lemmih, you here?
17:48:41 <dmwit> In any case, you probably want the equivalent of "not . null $ filter bool string" (note the lack of (==)).
17:48:43 <Lemmih> Maybe.
17:48:47 <Peaker> Lemmih: sdlGetMouseState also should use CInt rather than Int
17:49:03 * BMeph while impressed, is swearing off of building packages with ghc -v5 ...
17:49:07 <wolgo> why does that work without == ?
17:49:08 <dmwit> Either that, or "bool" is a terrible name. =P
17:49:17 <wolgo> it is a terrible name
17:49:24 <dmwit> wolgo: Then it infers "bool" to be a *function* of type Char -> Bool.
17:49:26 <wolgo> it should be searchChar
17:49:30 <mauke> then string is also a terrible name :-)
17:49:33 <Lemmih> Peaker: Excellent found. Send a patch. (:
17:49:34 <mauke> oh, ok
17:49:47 <mauke> searchChar `elem` string
17:49:49 <Peaker> Lemmih, heh do you have a darcs repo?
17:49:55 <dmwit> yeah
17:50:00 <Peaker> Lemmih, Patching against a tarball is .. unnice
17:50:06 <wolgo> what the function does is look for a char in my String
17:50:07 <Peaker> Lemmih, its in Event.hsc anyhow
17:50:15 <Peaker> Lemmih, two character insertions :)
17:50:19 <dmwit> wolgo: Use "elem", as mauke suggested.
17:50:25 * wolgo is writing the age old hangman newbie exercise
17:50:33 <Lemmih> Peaker: http://darcs.haskell.org/~lemmih/hsSDL/hssdl/
17:50:34 <lambdabot> Title: Index of /~lemmih/hsSDL/hssdl
17:50:35 <dmwit> :t elem
17:50:36 <wolgo> elem
17:50:37 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
17:50:46 <wolgo> elem
17:50:47 <wolgo> ok
17:51:18 * BMeph whimpers at the thought of having to re-compile HsSDL...on Windows...
17:51:26 <Peaker> Lemmih, please put the CInts into Event.hsc? pretty please? :)
17:51:35 <Lemmih> Peaker: Ok, what line?
17:51:46 <Lemmih> Ah, there it is.
17:51:48 <Peaker> Lemmih, 522
17:52:08 <wolgo> oh
17:52:26 <saml> g2 :: (forall a. Eq a => [a] -> a -> Bool) -> Int -> Int   what does this mean?
17:52:27 <Peaker> I changed the SDL tarball in my .cabal/packages, now how do I tricks it to rebuild
17:53:00 <dobblego> saml, it's a type signature; read :: as "is of type"
17:53:02 <saml> for all a such that when a is an instance of Eq, [a] -> a -> Bool?
17:53:12 <mauke> yes
17:53:19 <wolgo> jeez
17:53:27 <wolgo> Mauke you just removed 4 lines from my code :)
17:53:30 <saml> ([a] -> a -> Bool) -> Int -> Int   but a is of class Eq?
17:53:31 <wolgo> by just using elem :)
17:53:38 <mauke> btw, this is not a haskell98 type
17:53:41 <Saizan> Peaker: you can just unpack the tarball somewhere and run "cabal install" from inside that directory
17:53:54 <saml> so, a can be anything or Eq ?
17:53:58 <dobblego> saml, yes (Eq a) is a restriction on 'a'
17:54:05 <mauke> saml: Eq is not a type
17:54:12 <saml> if a should be Eq, then i would just write (Eq a) => [a] -> ...
17:54:28 <mauke> a can't be Eq
17:54:35 <Peaker> Saizan, I thought I had to use Setup --stuff
17:54:38 <saml> i mean an instance of Eq
17:54:44 <Peaker> Saizan, is that a cabal-install feature?
17:54:45 <wolgo> I think I am going to start a blog keeping track of my haskell learning.
17:55:13 <Saizan> Peaker: yeah, it calls Setup .. or equivalent for you
17:55:13 <Peaker> Lemmih, ouch, CInt is out of scope at that point, sorry (Only now I managed to try and build it)
17:55:58 <saml> difference of (forall a. (Eq a) => [a] -> a) -> Int   and forall a. (Eq a) => [a] -> a -> Int ?
17:56:13 <Peaker> Lemmih, can add CInt next to CString in the import list
17:56:39 <saml> it says one is Rank2, the other Rank3:  from http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#universal-quantification
17:56:40 <lambdabot> Title: 8.7. Other type system extensions, http://tinyurl.com/3c7ura
17:56:55 <mauke> saml: in the first case, the argument is polymorphic in the function body
17:57:14 <mauke> the second one should be rank-1
17:57:32 <Lemmih> Peaker: Done, patch pushed.
17:57:59 <Peaker> Lemmih, cool, thanks!
17:58:07 <saml> mauke: for the first case, does that mean a can be EqInstance1 and EqInstance2 at the same time in the function body?
17:58:18 * saml can't think of an example
17:58:58 <saml> @where rank
17:58:59 <lambdabot> I know nothing about rank.
17:58:59 <mauke> saml: http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#impredicative-polymorphism
17:59:00 <lambdabot> Title: 8.7. Other type system extensions, http://tinyurl.com/3c7ura
17:59:04 <Peaker> I think maybe something could auto-generate foreign loads to avoid Int/CInt confusions
17:59:14 <BMeph> mauke: Not the second one saml showed (being rank-3, that is.)
17:59:22 <mauke> saml: see how f calls g with [3] and "hello"
18:00:39 <saml> mauke: oh thanks
18:01:02 <saml> BMeph: i think i made a mistake saying the 2nd one is rank3
18:01:17 <Saizan> ?type let f :: (forall a. Eq a => [a] -> a -> Bool) -> Int; f g = length (filter (g [1..4]) [1..5]) + length (filter (g "foo") "foobaroof" in f elem
18:01:19 <lambdabot> parse error on input `in'
18:01:36 <Saizan> ?type let f :: (forall a. Eq a => [a] -> a -> Bool) -> Int; f g = length (filter (g [1..4]) [1..5]) + length (filter (g "foo") "foobaroof") in f elem
18:01:38 <lambdabot>     Occurs check: cannot construct the infinite type: a = [[a]]
18:01:38 <lambdabot>     In the first argument of `f', namely `elem'
18:01:42 <BMeph> saml: If you meant the second one in the response a couple of answers back, then yes.
18:02:53 <BMeph> Ranks are pretty easy. Functions that have arguments of rank _n_ are then said to be of rank _n+1_.
18:03:51 <saml> is there a way to tell location of compiled haskell program?    ghc --make main.hs -o main  && cp main /some/other/place.  and main still knows where it is located.
18:04:02 <BMeph> (forall a. a->a)  is a rank 1 function; ((forall a. a->a) -> Int) is rank 2; ((forall a. a->a) -> Int) -> Bool -> Bool is rank 3.
18:04:59 <mauke> > abs (1/-0)
18:05:00 <lambdabot>   Not in scope: `/-'
18:05:04 <mauke> > abs (1/ -0)
18:05:04 <lambdabot>      precedence parsing error
18:05:04 <lambdabot>         cannot mix `(/)' [infixl 7] and prefix ...
18:05:18 <mauke> (unary minus)--
18:06:33 <saml> > let (--) n = n - 1 in (n--)
18:06:33 <lambdabot> Unbalanced parentheses
18:06:45 <saml> > let (--) n = n - 1 in (--n--)
18:06:45 <ddarius> @karma minus)
18:06:45 <lambdabot> Unbalanced parentheses
18:06:45 <lambdabot> minus) has a karma of -1
18:06:58 <mauke> preflex: karma unary minus
18:06:58 <preflex>  karma for unary minus: -1
18:07:21 <ddarius> preflex: karma mauke
18:07:22 <preflex>  karma for mauke: 20
18:07:36 * BMeph imagines mauke in some secluded wilderness, shaking his fist at the impudent precedence assigner
18:08:53 <int-e> Well, unary minus should die and become part of the numeric literal lexical syntax.
18:08:56 <saml> ah -- is line comment
18:09:34 <mauke> int-e: yes!
18:09:55 <ddarius> -b
18:10:31 <Saizan> 0-b or negate b, still ugly
18:10:43 <mauke> negate shall be renamed to neg
18:11:51 <int-e> Saizan: that's a small price to pay for improved regularity.
18:12:37 <int-e> > map (-1+) [1..4]
18:12:38 <lambdabot>  [0,1,2,3]
18:12:45 <saml> > let (-) = negate in (2-)
18:12:46 <lambdabot>  -2
18:12:57 <saml> oh well i don't gain anything
18:12:57 <int-e> Hugs.Base> map (-1+) [1..4]
18:12:58 <int-e> ERROR - Syntax error in expression (unexpected `)')
18:13:52 <saml> > read "-1"
18:13:54 <lambdabot>  Exception: Prelude.read: no parse
18:14:09 <int-e> > read "()"
18:14:11 <lambdabot>  ()
18:14:17 <int-e> defaulting-- ;-)
18:14:39 <bd_> nonstandard, isn't it?
18:14:54 <Saizan> extendend, yeah, like in ghci
18:14:57 <int-e> yes, lambdabot uses ghc's extended defaulting in runplugs
18:15:10 <saml> > let x = read "undefined" :: Int in x
18:15:11 <lambdabot>  Exception: Prelude.read: no parse
18:15:31 <bd_> saml: It worked!
18:16:00 <Saizan> it would be a nice easter egg
18:16:05 <mauke> > let x = read "error \"Prelude.read: no parse\"" in x
18:16:06 <lambdabot>  Exception: Prelude.read: no parse
18:17:04 <Peaker> yay, my chess GUI is actually usable for real games now
18:17:11 <Peaker> now I just need to write an AI...
18:17:24 <int-e> Saizan: it worked - it read one representation of bottom and returned another ;)
18:18:32 <Peaker> http://nextflow.dyndns.org/chess.tgz -- the code is *ugly*, the GUI is pretty :)
18:20:19 <FordCortina> has anybody had problems building ghc-6.8.2 on debian testing recently? I'm getting errors like " undefined reference to `__DISCARD__' "
18:20:30 <FordCortina> which is wierd
18:20:47 <chessguy> 'evening folks
18:20:54 <FordCortina> becuase i had no problem compiling that version of ghc a few weeks ago
18:21:37 <Cale> FordCortina: Why are you compiling it?
18:21:37 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:21:38 <jcreigh> 'Douglas Crockford — "An Inconvenient API: The Theory of the DOM"' heh, the guy is good at catchy titles.
18:21:57 <jcreigh> ah, mistell, sorry.
18:22:10 <FordCortina> Cale: No 6.8.2 binary on debian
18:22:19 <FordCortina> plus it worked ok before
18:22:29 <Cale> FordCortina: There's a generic linux binary
18:22:59 <Cale> FordCortina: There's no point in compiling GHC yourself unless you're hacking on it.
18:24:03 <FordCortina> the configure script failed with the binary
18:24:29 <FordCortina> says i need the gmp lib, but the gmp lib is in the binary distribution
18:24:48 <mauke> seems to be in "sid (unstable)", whatever that is
18:25:12 <Cale> sudo apt-get install libgmp3c2 ?
18:25:40 <Cale> (maybe -dev as well)
18:27:16 <monochrom> sudo aptitude install libgmp3c2 :)
18:27:50 <monochrom> Actually libgmp3-dev also needed
18:29:14 <FordCortina> oh yeah looks like that gmp folder in the bin dist. is empty
18:29:16 <FordCortina> red herring
18:29:29 <FordCortina> ok ill just apt get it
18:29:38 <FordCortina> or aptitude it
18:30:09 <FordCortina> still im worried that there's something wrong with my system
18:30:14 <FordCortina> it worked great before
18:30:48 <bd_> FordCortina: Maybe gcc changed its code generation in a way that confuses the Evil Mangler?
18:30:55 <bd_> I'll run a build in sid and see what happens
18:31:34 <FordCortina> thanks bd_
18:34:16 <bd_> FordCortina: are you using the debian buildscripts, or just directly building?
18:34:52 <FordCortina> i was directly building from the sources at http://www.haskell.org/ghc/download_ghc_682.html
18:34:52 <lambdabot> Title: GHC: Download version 6.8.2
18:35:03 <bd_> hmm, okay, I'll do that in testing then
18:36:49 <FordCortina> im running debian testing (gcc 4.2.3), the last change in gcc-defaults seems to have been made in februrary. that was before the last time i built ghc :S
18:37:40 <mauke> which version of perl are you using?
18:38:02 <bd_> I'm on perl 5.10.0
18:38:15 <dbpatterson> easiest way to get e (math constant, 2.718...) in ghci?
18:38:23 <mauke> exp 1
18:38:23 <bd_> I won't know if that breaks anything until stage2 begins
18:38:33 <bd_> > exp 1
18:38:35 <lambdabot>  2.718281828459045
18:39:00 <FordCortina> yeh ive got the same version, v5.10.0
18:39:02 <roconnor> > exp 1 :: CReal
18:39:03 <lambdabot>  2.7182818284590452353602874713526624977572
18:39:20 <bd_> mmm -j4 build :3
18:39:22 <mar77a> > (\x -> (1 + 1/x) ** x) 200000000000 ::CReal
18:39:24 <lambdabot>  2.7182818284522495307891710052435460569828
18:39:34 <dbpatterson> cool thanks :)
18:40:03 <bd_> > (\x -> (1 + 1/x) ** x) maxBound ::CReal
18:40:04 <lambdabot>   add an instance declaration for (Bounded CReal)
18:40:07 <bd_> bah
18:40:09 <mauke> @index CReal
18:40:09 <lambdabot> bzzt
18:40:11 <hpaste>  saml pasted "ambiguous type??" at http://hpaste.org/7848
18:40:19 <monochrom> Hi, what is CReal?
18:40:24 <dons> CReal, eh?
18:40:29 <monochrom> Oh, computable real?
18:40:42 <roconnor> > showCReal 100 (exp 1)
18:40:42 <bd_> monochrom: some C type
18:40:43 <lambdabot>  "2.7182818284590452353602874713526624977572470936999595749669676277240766303...
18:40:53 <monochrom> Oh! C real... :)
18:40:54 <mar77a> 90 bit
18:40:57 <dons> where is it coming from?
18:41:03 <Cale> It's computable real.
18:41:07 <roconnor> > showCReal 1000 (exp 1)
18:41:08 <lambdabot>  "2.7182818284590452353602874713526624977572470936999595749669676277240766303...
18:41:08 <mauke> C has no Real type
18:41:18 <Cale> dons: You'd know better than I, I think...
18:41:20 <monochrom> Neato. Where can I find CReal? :)
18:41:20 <mar77a> there's assembly real afair
18:41:27 <mauke> saml: yes, it's the monomorphism restriction
18:41:28 <dons> Cale, oh, is it the crypto big num stuff?
18:41:31 <bd_> @src CReal
18:41:31 <lambdabot> Source not found. :(
18:41:40 <Cale> bd_: Doesn't come with GHC.
18:41:40 <dons> :k Word256
18:41:42 <lambdabot> *
18:41:48 <dons> ah so that stuff works again cool.
18:41:50 <Cale> (and src doesn't know about it)
18:42:10 <dons> > maxBound :: Word1024
18:42:12 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
18:42:15 <bd_> $* is no longer supported at /home/bd/ghc-build/directbuild/ghc-6.8.2/driver/split/ghc-split line 39.
18:42:16 <saml> mauke: how should I fix it?
18:42:18 <bd_> hmmm
18:42:25 <mauke>     Probable fix: give these definition(s) an explicit type signature
18:42:25 <mauke>                   or use -fno-monomorphism-restriction
18:42:31 <bd_>     $* = 1;     # multi-line matches are OK
18:42:34 <dons> > maxBound :: Word128
18:42:35 <lambdabot>  340282366920938463463374607431768211455
18:42:41 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
18:42:42 <mauke> bd_: fixed in head, IIRC
18:42:44 <lambdabot> http://tinyurl.com/33mfjx
18:42:45 <Cale> It's from that package.
18:43:02 <monochrom> Cale beated me by a few seconds.
18:43:03 <dons> oh, not the one I was thinking of.
18:43:23 <saml> oh that flag fixed it!
18:43:39 <bd_> oh wow, this'll be painful for debian
18:43:50 <bd_> Don't they bootstrap off of the previous version of GHC? >_>
18:44:09 <monochrom> whois leandroma
18:44:26 <monochrom> (typo)
18:45:11 <FordCortina> bd_: yes you need a previous ghc
18:45:37 <FordCortina> bd_: i just used the ghc from debian (about 6.6)
18:48:07 <bd_> FordCortina: yes, the problem is all their autobuilders will only pull ghc and perl from unstable...
18:48:20 <bd_> ghc-6.8.2: panic! (the 'impossible' happened)
18:48:20 <bd_>   (GHC version 6.8.2 for i386-unknown-linux):
18:48:20 <bd_>         lookupVers1 base:GHC.Prim CoUnsafe{tc}
18:48:24 <bd_> well, that's interesting
18:48:49 <bd_> (build with -j4 of 6.8.2 on debian testing)
18:49:00 <monochrom> augustss++
18:49:06 <xif> hi. is there a good reference to common Haskell operators, e.g. the list concatenation operator : ?
18:49:32 <monochrom> I hope augustss is Lennart Augustsson.
18:49:35 <bd_> xif: http://undergraduate.csse.uwa.edu.au/units/230.301/lectureNotes/tourofprelude.html
18:49:38 <lambdabot> Title: A Tour of the Haskell Prelude, http://tinyurl.com/ywhnjx
18:49:44 <saml> data B = B ( (Monad m, Ord t) => [t] -> m t )   -- how come this doesn't go through?
18:49:57 <xif> bd_: thanks!
18:50:08 <saml> Illegal polymorphic or qualified type: forall (m :: * -> *) t. (Monad m, Ord t) => [t] -> m t
18:50:14 <mauke> saml: because you can't just invent type variables in the middle of a data definition
18:52:01 <saml> data (Monad m, Ord t) => B m t = B ( [t] -> m t )  -- ah!
18:52:37 <Cale> saml: Also, you probably don't want those class constraints, since they mean something much dumber than you probably want them to mean.
18:53:33 <saml> Cale: just data m t = B ([t] -> m t) works too. hrm
18:53:42 <xif> hm, why can't I find (:) in the official Prelude docs? http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
18:53:43 <lambdabot> http://tinyurl.com/ovjef
18:54:28 <bd_> xif: internally in the compiler, it's defined elsewhere
18:54:47 <bd_> and I guess haddock (the documentation tool) wasn't given whatever overrides would be needed to move it
18:54:50 <Cale> xif: The list type is somewhat treated specially, just for syntax reasons.
18:55:17 <Cale> You can't actually declare the type yourself, because the type constructor has special syntax.
18:55:27 <bd_> data [] a = MkNil
18:55:29 <xif> bd_, Cale: OK, could you tell me where in the official docs I could find it?
18:55:29 <bd_> MkNil?
18:56:11 <bd_> xif: http://www.haskell.org/onlinereport/basic.html 6.1.3
18:56:11 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
18:56:43 <xif> bd_: thanks, though it's not the official GHC docs :)
18:56:59 <bd_> xif: The assumption is it doesn't need documenting in the compiler reference docs, I guess :)
18:57:08 <bd_> That and due to its implementation it's hard to document
18:57:33 <bd_> what I pasted above is the actual definition in GHC.Base... but the compiler special-cases things, so that's not actually how it's implemented
18:57:46 <xif> bd_: *nod* thanks!
19:03:05 <orbitz> what does :kind do in ghci?
19:03:51 <bd_> orbitz: Gives you the kind of a type function
19:03:55 <bd_> :k Monad
19:03:58 <lambdabot> Class `Monad' used as a type
19:04:02 <bd_> :k StateT
19:04:04 <lambdabot> * -> (* -> *) -> * -> *
19:04:36 <orbitz> what do teh *'s mean in this case?
19:05:03 <mauke> types
19:05:09 <mauke> :k Int
19:05:10 <bd_> orbitz: * is the kind of a type
19:05:10 <lambdabot> *
19:05:14 <FordCortina> bd_: im building 6.8.2 with the 6.8.2 binary and that seems to be working (it got past that bit where the error came up last time, its still building)
19:05:20 <mauke> also, s/ function//
19:05:39 <bd_> mauke: I suppose. Except StateT isn't a type, per se, is it?
19:05:53 <qwr> :k M.Map
19:05:54 <mauke> yeah, it's a type constructor
19:05:55 <lambdabot> * -> * -> *
19:05:58 <FordCortina> im not sure what to conclude from that
19:06:23 <bd_> FordCortina: hmmm
19:06:36 <bd_> I'm starting a pbuilder build of 6.8.2 now
19:06:41 <bd_> with perl v5.10.0 in the chroot
19:07:30 <orbitz> oh no, Joe Pesci and Sharon Stone are about to hook up
19:07:57 <Korollary> ouch
19:09:05 <Cale> xif: Those docs are autogenerated from the source code of the libraries and the comments in them.
19:09:38 <Cale> xif: It might be possible to add annotations to make it appear that the list type is defined there.
19:12:37 <TomMD> @tell dons oops, what an ugly and dishonest mistake - I often write a post up a day before hitting post / finishing up the issue.  I corrected the mistake, thanks!
19:12:37 <lambdabot> Consider it noted.
19:15:33 <saml> how can I express (C1 m, C2 m, C3 m, C4 m) => a -> m a  where m doesn't have to be instance of C1 C2 C3 and C4 at the same time?  m should be able to choose some of C1 ~ C4 to be instance of.
19:16:00 <saml> kinda sounds like rank2 type
19:20:22 <mrd> saml: how would you know which methods to use?
19:21:07 <saml> mrd: some functions use functions from C1 and C2.. others C3 and C4...etc. but i want to store those functions in a list
19:21:08 <Saizan> that's kind of weird what are you trying to do?
19:22:11 <sjanssen> saml: I don't think Haskell supports that
19:23:01 <Saizan> well, it can via gadts, since you've assumed a finite universe of classes
19:23:09 <Saizan> it's not pretty.
19:23:18 <saml> in my little language, i define built-in functions. and i store those built-ins in a list (actually a Map String BuiltinFunction where BuiltinFunction is a data that stores built-in functions of which some of them use C1 C2.. some C3 C4...etc
19:24:01 <sjanssen> what are C1, etc.?  Monad capabilities, like MonadState, MonadIO, and such?
19:24:15 <saml> MonadError, and some custom classes
19:24:57 <Saizan> how do you define BuiltinFunction? or is that what you're asking?
19:26:04 <saml> Saizan: yes. right now I'm using Rank2Type extension and:  data BuiltinFunction = BuiltinFunction { ..., func :: forall m. (C1 m, C2 m, C3 m, ..) => [Expr] -> m Expr
19:26:31 <saml> i mean it compiles and works.. but i don't really understand how/why it works :)
19:27:13 <saml> it's just too magic to me
19:28:27 <sjanssen> saml: "forall m. X -> m X" subsumes "forall m. C1 m => X -> m X" subsumes "forall m. (C1 m, C2 m) => X -> m X"
19:28:55 <sjanssen> just like "forall a. a -> a" subsumes "Int -> Int"
19:28:56 <dons> what an interesting mix, http://enhyper.blogspot.com/2008/05/haskell-get-together-22nd-may-2008.html
19:28:56 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
19:28:57 <lambdabot> Title: Enhyper: Haskell, HPC and Crypto Get Together 22nd May 2008, http://tinyurl.com/57jg63
19:30:46 <dons> TomMD: btw, i couldn't trigger any failures on my bsd box, which is interesting
19:31:37 <koninkje> mrd: Would there be a way to do that (ensure (C1 m -or- C2 m) => D m) if no methods ever needed to be chosen? (i.e. in type arithemetic)
19:32:56 <koninkje> mrd: i.e. in a type class instance, trying to avoid duplicate instances
19:34:54 <sjanssen> koninkje: I'd take a page from Oleg and use HTrue/HFalse
19:35:59 <sjanssen> for example, rather than have "class IsEven a; instance IsEven Zero", use "class IsEven a b | a -> b; instance IsEven Zero HTrue"
19:36:15 <koninkje> sjanssen: I've been trying to, but the types at hand aren't peano integers (it's a finite set, but no particular well-founding of interest)
19:36:45 <koninkje> and I'm trying to avoid enumerating all the nC2 cases where they're unequal
19:36:51 <sjanssen> class HAnd p q r | p q -> r; instance HAnd HTrue q q; instance HAnd HFalse q HFalse
19:37:18 <koninkje> (and trying to do better than enuerating the n classes of unequal types)
19:37:27 <wolgo> > :t return
19:37:28 <lambdabot>   parse error on input `:'
19:37:39 <wolgo> @type return
19:37:41 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
19:39:26 <wolgo> monad...
19:39:57 <mar77a> do not be afraid
19:40:03 <wolgo> I am not
19:40:05 <mar77a> it's just a m-m-...-m...
19:40:12 <mar77a> MONAD ARGHH GHGRHGH HGHRGHR RUN
19:40:49 <sjanssen> @remember mar77a MONAD ARGHH GHGRHGH HGHRGHR RUN
19:40:49 <lambdabot> Nice!
19:41:40 <wolgo> So is return an IO action?
19:41:53 <wolgo> are all monads IO actions?
19:41:58 <wolgo> ,.
19:41:59 <sjanssen> no
19:42:00 <wolgo> nm
19:42:10 <wolgo> I have not gotten to that part yet.
19:42:15 <sjanssen> no to the second at least
19:42:29 <wolgo> I will worry about that when I can get a friggen case statement correct in main instead of a function
19:42:32 <sjanssen> and 'return' isn't really an IO action, but 'return ()' is
19:42:41 <sjanssen> or return "foo", etc.
19:42:43 <wolgo> return True
19:42:48 <sjanssen> right
19:42:53 <dbpatterson> wolgo: IO is a monad
19:42:57 <dbpatterson> not all monads are IO
19:42:57 <wolgo> @type return True
19:42:59 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool
19:43:07 <sjanssen> 'return True' is the trivial action that always returns True
19:43:40 <wolgo> Monad :)
19:43:41 <mar77a> what's that sjanssen >:
19:44:35 <wolgo> is there a way to do something like exit()
19:44:43 <ddarius> @seen malcolmw
19:44:43 <lambdabot> I saw malcolmw leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 9h 46m ago, and .
19:44:47 <wolgo> let me rephrase that
19:44:50 <sjanssen> @hoogle exit
19:44:51 <lambdabot> System.Exit :: module
19:44:51 <lambdabot> System.Exit.exitWith :: ExitCode -> IO a
19:44:51 <lambdabot> System.Exit.exitFailure :: IO a
19:45:30 <ddarius> :t System.Exit.exitSuccess
19:45:31 <mar77a> :t ExitCode
19:45:32 <dbpatterson> wolgo: in what context would you use 'exit()'
19:45:32 <lambdabot> Not in scope: `System.Exit.exitSuccess'
19:45:33 <lambdabot> Not in scope: data constructor `ExitCode'
19:46:16 <sjanssen> @type System.Exit.ExitSuccess
19:46:18 <lambdabot> GHC.IOBase.ExitCode
19:48:25 <jberryman> dumb question: can someone point me to an explanation for some syntax I found here. In the line: sumTwoDice = \seed0 ->
19:48:29 <jberryman> http://en.wikibooks.org/wiki/Haskell/Understanding_monads#Threading_the_State_with_bind
19:48:30 <lambdabot> http://tinyurl.com/ewuzt
19:48:44 <sjanssen> jberryman: that is lambda syntax
19:48:56 <sjanssen> > (\x -> x + 1) 2
19:48:57 <lambdabot>  3
19:49:02 <jberryman> oooohhhh, duh
19:49:26 <jberryman> thanks, I'd just never seen it in that context
19:55:25 <Kamina> does anyone know if there is a fixpoint combinator in haskell predefined?
19:55:56 <sjanssen> @type Control.Monad.Fix.fix
19:55:58 <lambdabot> forall a. (a -> a) -> a
19:56:09 <sjanssen> Kamina: there is one in mtl, in a fairly odd place
19:56:16 <mar77a> ?karma God
19:56:16 <lambdabot> God has a karma of 0
19:56:18 <monochrom> It is now in...
19:56:20 <Kamina> what is mtl?
19:56:27 <bd_> Kamina: the Monad Template Library
19:56:28 <monochrom> @type Data.Function.fix
19:56:29 <lambdabot> forall a. (a -> a) -> a
19:56:35 <sjanssen> Kamina: monad transformer library
19:56:43 <bd_> it has all kinds of useful monads that you can snap together
19:56:43 <mar77a> :t id
19:56:45 <lambdabot> forall a. a -> a
19:56:45 <sjanssen> ah, thanks monochrom
19:56:50 <mar77a> > id 5
19:56:51 <lambdabot>  5
19:56:54 <monochrom> And it is in base.
19:56:57 <mar77a> what's the use of the id function?
19:56:57 <Kamina> okay, thanks...
19:57:13 <bd_> mar77a: I often do things like runCont (something) id
19:57:15 <bd_> :t runCont
19:57:17 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
19:57:24 <bd_> ;t runCont id
19:57:26 <bd_> er
19:57:29 <bd_> :t flip runCont id
19:57:31 <lambdabot> forall a. Cont a a -> a
19:59:04 <koninkje> mar77a: it's for higher-order functions (i.e. to pass in as an argument). runCont is one example, there are others
19:59:23 <koninkje> mar77a: const has similar uses
19:59:24 <mar77a> i guess that will make sense later
19:59:41 <monochrom> There is a recently-discovered obscure use.
19:59:52 <mar77a> :t const
19:59:54 <lambdabot> forall a b. a -> b -> a
19:59:58 <monochrom> > (f `id` g) x :: Expr
19:59:58 <lambdabot>  Add a type signature
20:00:27 <monochrom> > f `id` x :: Expr
20:00:28 <lambdabot>  f x
20:00:33 <bd_> that's recently discovered?
20:00:35 <monochrom> Yes!
20:00:39 <Cale> uhh...
20:00:41 <koninkje> > map id [(+1),(+2),(+3)] [0,0,0]
20:00:42 <lambdabot>  Couldn't match expected type `[t1] -> t'
20:00:46 <bd_> @. pl src id
20:00:47 <lambdabot> (line 1, column 1):
20:00:47 <lambdabot> unexpected end of input
20:00:47 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
20:00:51 <bd_> mmh
20:00:52 <bd_> @src id
20:00:53 <lambdabot> id x = x
20:00:56 <bd_> @pl id x = x
20:00:56 <lambdabot> id = id
20:01:00 <Cale> I knew about that quite a long time ago
20:01:03 <koninkje> >  zipWith id [(+1),(+2),(+3)] [0,0,0]
20:01:04 <lambdabot>  [1,2,3]
20:01:06 <bd_> hmmmm
20:01:15 <Cale> ($) is just id specialised to functions
20:01:17 <monochrom> OK, recently-taught.
20:01:31 <bd_> :t fmap fix return
20:01:33 <lambdabot> forall a. a -> a
20:01:34 <bd_> :3
20:01:55 <koninkje> (zipWith id) is a frequently asked for function :)
20:01:59 <Cale> > zipWith id [(+2), (*2), (^2)] [5,10,20]
20:02:00 <lambdabot>  [7,20,400]
20:02:30 <edwardk> hrmm, do you think its worth building a monad instance for Yoneda in the same vein as Ran? you can build an instance (fairly boringly) for Yoneda m = Ran Identity m, that is different than the one for Ran m m.
20:02:40 <bd_> I've found myself using fmap (const ()) in a compiler I'm writing a lot :)
20:03:12 <bd_> (one of the intermediate structures is a functor, with the functor argument being the type of certain annotations in the tree)
20:03:20 <edwardk> pros another way to build a continuation-like monad, cons, it obscures the Yoneda/Ran connection
20:03:21 <Cale> edwardk: Why not?
20:03:22 <monochrom> > fmap fix return 0
20:03:24 <lambdabot>  0
20:03:26 <Cale> edwardk: hmm
20:04:13 <edwardk> basically I get newtype Y f a = Y { runY :: forall b. ((a -> b) -> f b) };  instance Monad f => Monad (Y f) where return a = Y (\f -> return (f a)); m >>= k = Y (\f -> runY m id >>= \a -> liftM f (runY (k a) id))
20:04:29 <ddarius> mar77a: While true in programming in general, functional programmers are especially aware of units and zeros to their operations.  You'll often find seemingly "useless" functions in libraries.
20:04:51 <mar77a> well i don't think it's USELESS i just can't find or have come across any use for it
20:04:54 <mar77a> not even in my mind
20:04:55 <edwardk> the main win i can see is that if you fmap alot the fmaps are batched up in the (a -> b) side of the continuation, without any 'join' overhead
20:05:15 <dobblego> mar77a, it's about spotting the pattern of use; in reality, you use such patterns hundreds of times per day
20:05:21 <ddarius> mar77a: You may have heard of the Null Object Pattern.
20:05:35 <mar77a> as i might haven't
20:05:37 <saml> python has __file__  that is absolute path of the python script being executed. does haskell have similar thing? somethign that tells location of the program?
20:05:42 <bd_> mar77a: id isn't useful /often/, but it comes in handy occasionally
20:05:58 <mar77a> command line arguments?
20:06:03 <mar77a> argv[0]!?
20:06:40 <edwardk> by comparison return into Ran f f is return x = Ran (\k -> k x); and bind: m >>= k = Ran (\c -> runRan m (\a -> runRan (k a) c))
20:06:47 <Cale> mar77a: Consider the case of wanting to use foldr to compose a bunch of functions in a list together
20:06:51 <saml> there is getProgName. but it doesn't give me dirname of the progname
20:07:00 <mar77a> i have yet to understand foldr / l
20:07:03 <mar77a> :(
20:07:03 <Cale> mar77a: id is what you'd supply as the replacement for the [] at the end of the list
20:07:35 <monochrom> premature opinion is the root of all evil.
20:07:46 <dobblego> @remember <monochrom> premature opinion is the root of all evil.
20:07:46 <lambdabot> It is forever etched in my memory.
20:07:55 <monochrom> (but of course, all opinions are premature by definition.)
20:07:59 * mrd invokes monochrom -O2
20:08:07 <monochrom> You can omit < >
20:08:12 <edwardk> hrmm fmap has the same asymptotic performance in both cases. so i think the difference comes down to that >>= in Yoneda keeps the same general performance characteristics of the base monad. while >>= in Ran m m takes on the characteristics of bind in ContT performance wise, both 'bunch up' fmaps into the continuation term.
20:09:01 <Cale> > foldr (.) id [("hello "++), reverse, map toLower] "A77RAM"
20:09:03 <lambdabot>  "hello mar77a"
20:09:19 <mar77a> > "hi cale i suck at haskell ok bye"
20:09:20 <lambdabot>  "hi cale i suck at haskell ok bye"
20:09:35 <monochrom> > foldr (.) id [f, g, h] x :: Expr
20:09:37 <lambdabot>  f (g (h x))
20:09:52 <Cale> mar77a: The idea behind foldr is that foldr f z is a function which replaces each (:) in the construction of a list with f, and the [] at the end with z
20:09:57 <edwardk> i may be able to carry over an extra monad transformer or two for Yoneda though, so i guess i should consider it. since i think i might be able to monadfix it or something whereas thats ill posed for ContT/Ran f f
20:10:07 <mar77a> yeah i know the definition but
20:10:13 <mar77a> and i know it's extremely powerful etc
20:10:17 <dobblego> mar77a, functional programming is about composing from smaller parts (the promise that OO makes, but fails); it's entirely possible and even probable that one of those parts is the identity transformation
20:10:19 <monochrom> Next year Cale will make lambdabot into a CAS for haskell. :)
20:10:20 <mar77a> i just can't think in terms of foldr
20:10:32 <Cale> mar77a: So here we replace the list conses with function composition, and the [] at the end with id
20:10:41 <Cale> The result is the composite of all the functions in the list.
20:10:52 <dobblego> mar77a, can you think in terms of map? it just takes foldr and some other parts
20:10:59 <mar77a> yeah i like map
20:11:03 <mar77a> it's like more intuitive
20:11:06 <Cale> Similarly, we could replace the conses in a list of numbers with addition, and the [] at the end with 0
20:11:11 <mar77a> apply f to each element of this list
20:11:12 <Cale> and get the sum of the elements
20:11:18 <Cale> > foldr (+) 0 [1,2,3]
20:11:19 <lambdabot>  6
20:11:20 <dobblego> mar77a, it's a specialisation of foldr; you're thinking in terms of foldr plus some other bits
20:11:29 <monochrom> (E.g., you enter "@differentiate data Tree a = Null | Node a (Tree a) (Tree a)" and you will get its zipper!)
20:11:31 <Cale> map f = foldr ((:) . f) []
20:11:38 <mar77a> yeah i read that somewhere
20:11:43 <mar77a> YAHT probably
20:11:49 <dobblego> mar77a, what about filter?
20:11:55 <mar77a> filter is nice too
20:11:57 <edwardk> @pl \a -> Yoneda (\f -> return (f a))
20:11:57 <lambdabot> Yoneda . (return .) . flip id
20:12:02 <dobblego> that too, is foldr plus some other bits
20:12:02 <mar77a> map and filter, list comprehensions and recursion
20:12:05 <mar77a> that's what i've used so far
20:12:07 <ddarius> monochrom: That would be a pretty easy command to add.
20:12:17 <mar77a> i heard they all convert to assembly, dobblego
20:12:42 <dobblego> mar77a, Iam talking about the transformation, in the abstract
20:12:49 <mar77a> yeah i was just kidding
20:12:56 <mar77a> foldr just looks more low-level
20:13:02 <dobblego> well it's not
20:13:07 <mar77a> and i can't my mind to think in terms of foldr
20:13:12 <dobblego> you can't write foldr from map, but you can write map from foldr
20:13:25 <Cale> I have a diagram which might help.
20:13:29 <mar77a> i've seen it
20:13:32 <mar77a> you showed it to me
20:13:34 <Cale> okay
20:13:34 <mar77a> 6 months ago
20:13:36 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
20:13:37 <lambdabot> Title: Fold Diagrams - CaleWiki
20:13:41 <koninkje> mar77a: with foldr, (:), and [] you can define any function on lists (though some are more obscure than others)
20:13:44 <mar77a> :)
20:13:47 <dobblego> mar77a, do you understand left folds?
20:14:00 <mar77a> only read about em
20:14:01 <Cale> Left folds are more complicated
20:14:01 <mar77a> never used
20:14:06 <Cale> (slightly)
20:14:25 <edwardk> @pl \f -> runYoneda m id >>= \a -> runYoneda (k a) f
20:14:25 <lambdabot> (runYoneda m id >>=) . flip (runYoneda . k)
20:14:27 <ddarius> Cale: Perhaps, but they map much more naturally onto something familiar in a strict language.
20:14:36 <dobblego> yes, what ddarius said
20:14:50 <koninkje> mar77a: that is, foldr is the fundamental way to destroy/iterate a list; and (:) [] are the fundamental way to build them
20:14:57 <mar77a> but foldl can't be used on infinite lists
20:15:07 <dobblego> mar77a, can you write a for loop on an infinite list?
20:15:14 <mar77a> yes...
20:15:24 <dobblego> with a break, right?
20:15:28 <mar77a> no...
20:15:43 <dobblego> or with a special condition in the loop
20:15:50 <mar77a> well i was thinking in something like
20:15:54 <Cale> It could just be an infinite loop :)
20:16:12 <mar77a> list = [1..]; for(int i = 0;i < 10;i++){ list[i]; ...
20:16:14 <monochrom> infinite loops are cool.
20:16:24 <dobblego> that might help with left folds http://blog.tmorris.net/scalalistfoldleft-for-java-programmers/
20:16:25 <lambdabot> Title: λ Tony&#8217;s blog λ  Blog Archive  scala.List.foldLeft for Java programmer ...
20:16:38 <mar77a> making irssi use utf might help too
20:16:40 <Cale> list = [1..]; for i in list { print i }
20:17:06 <Cale> ;)
20:17:13 <mar77a> there's no such thing as....infinite loops
20:17:22 <mar77a> everything that has a beginning, has an end....neo
20:17:27 <mar77a> hehe ok
20:17:31 <Cale> haha
20:17:33 <mar77a> anyways let me take a look at your images again Cale
20:17:42 <Cale> Yeah, have a good look at the foldr one
20:17:44 <mar77a> they might make more sense this time
20:17:55 <mar77a> i'll print it and hang it on my wall, cumm on it then take a closer look
20:17:58 <mar77a> hmh
20:19:21 <mar77a> > foldr `+` [1..5]
20:19:21 <lambdabot>  Parse error at "+`" (column 8)
20:19:26 <mar77a> hm
20:19:26 <dobblego> ?type foldr
20:19:28 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:19:29 <Cale> (+)
20:19:30 <dobblego> ?type foldr (+)
20:19:32 <mar77a> > foldr (+) [1..5] 0
20:19:32 <lambdabot> forall a. (Num a) => a -> [a] -> a
20:19:33 <lambdabot>   add an instance declaration for (Num [[t]], Num [t])
20:19:39 <Cale> > foldr (+) 0 [1..5]
20:19:41 <lambdabot>  15
20:19:47 <mar77a> oh right
20:19:52 <mar77a> point free programming horay
20:19:57 <dobblego> > 1 + 2 + 3 + 4 + 5 + 0
20:19:58 <lambdabot>  15
20:20:01 <Cale> > foldr (*) 1 [1..5]
20:20:04 <lambdabot>  120
20:20:15 <mar77a> > foldr `div` 1 [1..5]
20:20:16 <lambdabot>        add an instance declaration for
20:20:16 <lambdabot>       (Integral ((a -> b -> b) -> b ->...
20:20:19 <Cale> > foldr f z [1..5]
20:20:21 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
20:20:28 <mar77a> hhhhhhhhhh
20:20:30 <Cale> > foldr (:) [] [1..5]
20:20:30 <dobblego> > foldr div 1 [1..5]
20:20:32 <lambdabot>  [1,2,3,4,5]
20:20:32 <lambdabot>  Exception: divide by zero
20:20:32 <mar77a> that is gold
20:21:02 <mar77a> > foldr (^) 1 [1..5]
20:21:14 <lambdabot> Terminated
20:21:23 <mar77a> > "Hasta la vista, baby"
20:21:24 <lambdabot>  "Hasta la vista, baby"
20:21:35 <mar77a> > foldr (^) 1 [1,2,3]
20:21:36 <lambdabot>  1
20:21:42 <mar77a> > foldr (^) 1 [2,3]
20:21:43 <lambdabot>  8
20:21:49 <dobblego> > 1 ^ (2 ^ (3 ^ 1))
20:21:50 <lambdabot>  1
20:21:58 <mar77a> yeah figured
20:21:58 <dobblego> > 2 ^ (3 ^ 1)
20:21:59 <lambdabot>  8
20:22:07 <ddarius> > foldr (+) 0 [1..5] :: Expr
20:22:09 <lambdabot>  1 + (2 + (3 + (4 + (5 + 0))))
20:22:17 <Cale> 2^(3^(4^(5^1))) is a rather large number though
20:22:40 <Cale> foldr (^) 1 [3,4,5]
20:22:42 <Cale> > foldr (^) 1 [3,4,5]
20:22:43 <lambdabot>  3733918487410200435329597541848665882254097767837340077506369317220790406172...
20:22:54 <Cale> > length . show $ foldr (^) 1 [3,4,5]
20:22:55 <lambdabot>  489
20:22:56 <gubagem> > foldr (*) 1 [1..52]
20:22:56 <mar77a> foldr foldr 0 [1..5]
20:22:57 <lambdabot>  80658175170943878571660636856403766975289505440883277824000000000000
20:23:05 <mar77a> > foldr foldr 0 [1..5]
20:23:06 <lambdabot>      Occurs check: cannot construct the infinite type: b = [a] -> b
20:23:06 <lambdabot>     Proba...
20:23:11 <gubagem> the number of ways to shuffle a standard 52 deck of cards
20:23:52 <mar77a> > foldr (**) 1 [1.1,1.2..2]
20:23:53 <lambdabot>  Infinity
20:23:59 <gubagem> whats ** do
20:24:06 <dbpatterson> raise to power
20:24:10 <mar77a> it's a smiley in disguise
20:24:23 <Cale> There are three exponentiation operators in the Prelude.
20:24:27 <Cale> :t (^)
20:24:29 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
20:24:29 <Cale> :t (^^)
20:24:31 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
20:24:32 <Cale> :t (**)
20:24:34 <lambdabot> forall a. (Floating a) => a -> a -> a
20:24:40 <mar77a> ajá
20:24:45 <gubagem> oh wtfrig
20:25:05 <gubagem> one for integers, one for rationals, and one for floats(ie reals)
20:25:09 <Cale> They correspond to three mathematically distinct definitions which are given the same notation in mathematics.
20:25:26 <mar77a> > 9 ^^1/2
20:25:27 <lambdabot>  4.5
20:25:31 <dons> its a bit weird though. but that's  it. easy to remember now.
20:25:31 <mar77a> > 9 ^^ (1/2)
20:25:32 <lambdabot>  Add a type signature
20:25:38 <mar77a> o_o
20:25:47 <Cale> > 9 ^^ (-2)
20:25:48 <lambdabot>  1.2345679012345678e-2
20:25:52 <Cale> > 9 ^ (-2)
20:25:53 <lambdabot>  Exception: Prelude.^: negative exponent
20:25:57 <gubagem> ok how do i make a function/(named box) that returns that does i++ and returns i++ on every call
20:26:10 <Cale> gubagem: hm?
20:26:11 <gubagem> i call a function so it goes 1,2,3,4,5
20:26:13 <dons> ?let f = (+1)
20:26:14 <lambdabot> Defined.
20:26:22 <mar77a> nah he wants something like
20:26:35 <dons> > iterate (+1) 0
20:26:35 <Cale> gubagem: Functions in Haskell are mathematical functions. When given the same arguments they always give the same result.
20:26:36 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
20:26:45 <mar77a> i = 0; int f(){ return i++; }
20:26:50 <gubagem> can i do it with lambdas? (are lambas in haskell closures as well)
20:26:59 <gubagem> do i need to have a monad
20:27:10 <Cale> gubagem: Nope, functions are referentially transparent. You can do it in particular monads.
20:27:32 <hpaste>  neurogeek pasted "(no title)" at http://hpaste.org/7849
20:27:34 <gubagem> what is referentially transparent
20:27:48 <edwardk> ah neat the newfangled Yoneda works as an HMonad
20:27:50 <mar77a> > map (+2) [1..10]
20:27:51 <lambdabot>  [3,4,5,6,7,8,9,10,11,12]
20:27:59 <mar77a> what's the equal expression with foldr
20:27:59 <Cale> It means that if f x = g x for all x, you can replace f with g whenever it occurs without affecting the meaning of the program.
20:28:02 <neurogeek> im sorry.. im reaaaally new to haskell.. can somebody tell me whats wrong with my code please??
20:28:06 <neurogeek> http://hpaste.org/7849
20:28:16 <Cale> neurogeek: I'll have a look
20:28:25 <neurogeek> thanks a lot Cale
20:28:56 <Cale> neurogeek: You need to do something with that Float
20:29:02 <mar77a> Cale: you have a pending question on the queue :)
20:29:03 <Cale> neurogeek: perhaps you wanted to print it?
20:29:15 <Cale> neurogeek:  print (dotP [2.0, 3.0] [2.0, 3.0])
20:29:17 <neurogeek> oh..
20:29:41 <Cale> mar77a: foldr ((:) . (+2)) []
20:29:41 <neurogeek> Cale, thats because the code is in a 'do' statement??
20:29:41 <gubagem> can you really do the type definition for a function in a let body?
20:29:51 <Cale> gubagem: yep
20:30:05 <Cale> neurogeek: Well, sort of, yes.
20:30:15 <Cale> neurogeek: You're defining main, which is an IO action
20:30:19 <edwardk> duh, and HComonad
20:30:33 <mar77a> what the hell
20:30:36 <neurogeek> Cale, thanks a lot.. that was it.. :$
20:30:36 <Cale> neurogeek: You're using a do-expression, which glues together a sequence of IO actions.
20:30:48 <neurogeek> Oh.. I see now
20:30:49 <mar77a> i don't get that function composition
20:30:50 <mar77a> wait
20:30:53 <mar77a> i think i just ...
20:30:57 <mar77a> you add two
20:31:02 <mar77a> then add the :
20:31:08 <mar77a> ziing
20:31:25 <mar77a> let me see that in :: Expr
20:31:41 <mar77a> > foldr ((:) . (+2)) [] [1..10] :: Expr
20:31:42 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
20:31:45 <mar77a> nooo
20:31:47 <Cale> > expr ((:) . (+2)) [] [a,b,c]
20:31:48 <lambdabot>  Couldn't match expected type `Expr'
20:31:52 <Cale> > expr ((:) . (+2)) [] [a,b,c] :: [Expr]
20:31:53 <lambdabot>  Couldn't match expected type `Expr'
20:31:55 <Cale> mm...
20:32:03 <mar77a> +s ?
20:32:20 <Cale> > foldr ((:) . (+2)) [] [a,b,c] :: Expr
20:32:21 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Expr]'
20:32:24 <mar77a> > foldr ((:) . (+n)) [] [a,b,c] :: Expr
20:32:24 <Cale> > foldr ((:) . (+2)) [] [a,b,c] :: [Expr]
20:32:25 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Expr]'
20:32:26 <lambdabot>  [a + 2,b + 2,c + 2]
20:32:31 <Cale> sigh
20:32:31 <Cale> heh
20:32:42 <mar77a> ohh
20:32:53 <mar77a> |well it doesn't give me the low level thingy i wanted :>
20:32:55 <mar77a> :< *
20:32:55 <gubagem> whats the ::[Expr] doing
20:33:09 <Cale> gubagem: Just telling the thing what type we want it to be
20:33:18 <Cale> gubagem: because it's a bit too polymorphic otherwise
20:33:41 <Cale> mar77a: Well, I can draw a diagram if you want.
20:33:50 <Cale> maybe I already have one, let me see :)
20:34:03 <Cale> http://cale.yi.org/autoshare/foldr-map.png
20:34:05 <Cale> ah, I do
20:34:18 <mar77a> you've been in the business for a while
20:34:23 <mar77a> so...where do i send the money
20:34:26 <Cale> hehe
20:34:41 <mar77a> i swear, if i become fluent with this thing
20:34:43 <Cale> I have a paypal account, actually :)
20:34:52 <mar77a> let me quote what they said
20:34:54 <Cale> But I don't usually ask for money :)
20:34:54 <mar77a> when i posted about haskell
20:35:14 <mar77a> "Why do you guys like this extreme spaghetti coding?"
20:36:10 <dobblego> mar77a, who said that?
20:36:18 <mar77a> http://www.gamingw.net/forums/index.php?topic=71966.0
20:36:19 <lambdabot> Title: Gaming World Forums - Functional programming languages
20:36:23 <Cale> heh
20:36:33 <dobblego> mar77a, I find things like that amusing :)
20:36:48 <mar77a> things like..?
20:37:25 <dobblego> things where someone says "X exhibits property P", when in fact, it is what they are doing that exhibits property P while what they are accusing is the very anti-thesis of P
20:37:53 <mar77a> so..how's the weather
20:37:59 <gubagem> ive been trying to teach my  brother some coding, was using scheme but all the bananna peels i mean parentheses he just couldnt get a taste for
20:37:59 <mar77a> what
20:38:52 <gubagem> i was having an easier time teaching coding to my brother using haskell instead of scheme
20:39:19 <gubagem> but then he came to recursion and got a little lost
20:39:24 <gubagem> so i am taking him back to scheme
20:39:26 <dobblego> gubagem, Haskell is a good first language, but I'm undecided on whether it is good for an already-raped mind
20:39:44 <gubagem> he has lil to no coding experience
20:39:48 <mar77a> needs to go to reh(a)b
20:40:16 <Cale> mar77a: maybe use the SICP book and lectures :)
20:40:29 <saml> does # also start literate haskell?
20:40:40 <Cale> saml: not that I'm aware of, no
20:41:16 <saml> MainUtils.lhs:94:1: lexical error at character '.'  that line is:  #. in the current working directory.
20:41:19 <mar77a> SICP what?
20:41:20 <Cale> saml: There are two literate Haskell forms, one with > to start the lines of code, and one where the code occurs between \begin{code} and \end{code}
20:41:38 <Cale> mar77a: http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/
20:41:39 <lambdabot> Title: Structure and Interpretation of Computer Programs, Video Lectures, http://tinyurl.com/2by7b
20:41:50 <mar77a> EH
20:41:54 <mar77a> miranda is so similar to haskell
20:42:06 <Cale> mar77a: Haskell is Miranda's successor.
20:42:28 <gubagem> ok i want a thingie like this:  do {a<-andOne;b<-andOne;c<-andOne;print [a,b,c]} and then would print out [1,2,3]
20:42:31 <ddarius> Scheme isn't going to make recursion any simpler.
20:42:51 <Cale> Miranda was proprietary and people wanted an open lazy functional language, which is why Haskell was designed.
20:43:00 <mar77a> developed by who?
20:43:03 <mar77a> microsoft?!
20:43:13 <Cale> mar77a: Research Software Ltd.
20:43:16 <gubagem> so how would i define andOne?
20:43:20 <mar77a> btw what's this SICP anyways
20:43:28 <mar77a> addOne = (+1)
20:43:28 <Cale> gubagem: In the state monad, it'd be  modify (+1)
20:43:40 <gubagem> mit's intro to comp sci textbook freelly available online
20:43:41 <Cale> er
20:43:46 <Cale> print is in the IO monad though
20:43:51 <gubagem> its a bit intense from what ive gleened of it
20:43:55 <Cale> So I suppose you want something which involves an IORef
20:44:00 <gubagem> i have no idea
20:44:03 <mar77a> yeah but i mean why did you link me to this Cale
20:44:20 <Cale> mar77a: It's a cool introductory course on computer science which uses scheme
20:44:32 <mar77a> i er...what ok
20:44:35 <gubagem> so i would have to 'lift' (+1) into the io monad
20:44:51 <gubagem> scheme gives you really good rigour on parentheses and you can code in any style you want
20:45:12 <Cale> gubagem: In the IO monad, you'd probably use an IORef
20:45:12 <mar77a> LISP
20:45:20 <mar77a> Scheme
20:45:24 <gubagem> yea but lisp defined in 50 pages
20:45:25 <mar77a> where's haskell :<
20:45:37 <hpaste>  saml pasted "can't compile literate haskell" at http://hpaste.org/7850
20:45:40 <gubagem> these monad things scare me
20:45:50 <ddarius> @where sicp
20:45:50 <lambdabot> http://mitpress.mit.edu/sicp/
20:46:21 <gubagem> @where realworldhaskell
20:46:21 <lambdabot> http://www.realworldhaskell.org/
20:46:31 <saml> @where girls
20:46:32 <lambdabot> I know nothing about girls.
20:46:34 <ddarius> @where htdp
20:46:34 <lambdabot> http://www.htdp.org/
20:46:44 <gubagem> @where lambdabot
20:46:44 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
20:46:49 <gubagem> sweet
20:46:57 <ddarius> gubagem: htdp is probably a good Scheme resource on learning how to program and learning recursion.
20:47:03 <Cale> saml: very strange....
20:47:48 <saml> maybe it's like C++. C++ allows some weird characters to be used instead of normal << or something
20:48:07 <saml> thing is #. is wierd to google about
20:48:24 <saml> maybe # starts something in literate haskell
20:48:26 <Cale> It also occurs just with #
20:48:40 <Cale> but # certainly isn't equivalent to >
20:48:58 <Cale> Putting a function definition after the # doesn't help
20:49:03 <saml> http://www.haskell.org/onlinereport/literate.html  this page doesn't contain #  (so it doesnt' mention about #)
20:49:03 <lambdabot> Title: The Haskell 98 Report: Literate Comments
20:49:18 <koninkje> saml: You can't have # as the first character in a line
20:49:32 <Cale> I can only imagine that it's a bug in the literate haskell parser.
20:49:36 <koninkje> saml: in GHC at least. It assumes it's a sort of pragma (usually cpp)
20:49:42 <saml> koninkje: how come? oh
20:49:57 <Cale> That's a bug if cpp isn't turned on.
20:50:03 <koninkje> even in literate haskell it won't allow it; not sure if that's buggy or not
20:50:38 <gubagem> so for my do blocks
20:50:48 <gubagem> i can only have one kind of monad at a time?
20:50:53 <Cale> gubagem: right
20:51:07 <gubagem> that sounds mildly not amusing
20:51:29 <Cale> Monads can be sufficiently different that mixing their effects is a nontrivial matter.
20:51:31 <koninkje> gubagem: though monad transformers allow you to merge more than one into one
20:51:51 <Cale> Well, they allow you to extend the effects of one monad with new effects.
20:52:05 <koninkje> yes,
20:52:26 <wolgo> hi
20:52:38 <koninkje> gubagem: you can have multiple monads in different places in your program, but any given value is only in one of them
20:52:47 <gubagem> > reverse "hello wolgo"
20:52:48 <lambdabot>  "oglow olleh"
20:54:29 <Cale> Prelude Data.IORef> let inc r = do v <- readIORef r; writeIORef r (v+1); return (v+1)
20:54:29 <Cale> Prelude Data.IORef> do r <- newIORef 0; a <- inc r; b <- inc r; c <- inc r; print [a,b,c]
20:54:29 <Cale> [1,2,3]
20:54:58 <gubagem> can i do {do let a=andOne;let b=andOne; let c=andOne; print [a,b,c]}
20:55:04 <koninkje> saml: N.B. if you put leading spaces or anything before the # it's fine. The problem is only when it's exactly the first character
20:55:16 <bd_> gubagem: sure.
20:55:20 <Cale> gubagem: a, b, and c would necessarily be equal in that case
20:55:27 <Cale> gubagem: because they'd all be equal to andOne
20:55:51 <Cale> And things which are equal to the same thing are equal to each other.
20:55:53 <bd_> also note the { should be on the right od 'do'
20:56:14 <Cale> So I doubt it would mean what you want it to mean :)
20:56:36 <Cale> also, if andOne is an IO action, that'll fail, because there's no way to print IO actions.
20:56:39 <gubagem> so i have to pass in some sort of 'magical' "state variable"
20:56:44 <bd_> you might mean: do { a <- andOne; b <- andOne; c <- andOne; print [a,b,c] }
20:56:50 <saml> koninkje: oh thanks
20:56:54 <gubagem> yes yes
20:56:56 <bd_> where andOne :: IO a   for some Show a
20:57:07 <bd_> in which case a,b,c can be totally different
20:57:21 <bd_> depending on what andOne does, of course
20:58:28 <Cale> do r <- newIORef 0; let { andOne = do modifyIORef r (+1); readIORef r }; a <- andOne; b <- andOne; c <- andOne; print [a,b,c]
20:59:21 <Cale> Sorry to squish that all onto one line :)
20:59:52 <Cale> do r <- newIORef 0
20:59:52 <Cale>    let andOne = do modifyIORef r (+1)
20:59:52 <Cale>                    readIORef r
20:59:52 <Cale>    a <- andOne; b <- andOne; c <- andOne
20:59:52 <Cale>    print [a,b,c]
21:01:28 <Cale> You could also have something like  print =<< replicateM 3 andOne
21:01:57 <Cale> (where replicateM is a function defined in Control.Monad)
21:02:21 <bd_> :t replicateM
21:02:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
21:02:25 <Cale> It's just a loop which repeats an action a given number of times and collects a list of the results.
21:02:32 <bd_> :t replicateM_
21:02:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
21:05:45 <mar77a> > [1,2,3,4,5,6,7,8,9,a,b,c...]
21:05:45 <lambdabot>  Parse error at "]" (column 28)
21:05:50 <mar77a> > [1,2,3,4,5,6,7,8,9,a,b,c..]
21:05:50 <lambdabot>  Parse error at "..]" (column 25)
21:06:06 <mar77a> > [1,2,4,8,16..]
21:06:06 <lambdabot>  Parse error at "..]" (column 12)
21:06:56 <mar77a> @hoogle mysql
21:06:57 <lambdabot> No matches found
21:07:01 <mar77a> ..oh
21:07:10 <bd_> mar77a: hoogle doesn't cover outside libraries
21:07:14 <gubagem> > [1,2,4,8,16..64]
21:07:14 <lambdabot>  Parse error at "..64]" (column 12)
21:07:27 <bd_> > [1,3,..]
21:07:28 <lambdabot>  Parse error at "..]" (column 6)
21:07:30 <bd_> > [1,3..]
21:07:32 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
21:07:33 <mar77a> ah ok
21:07:40 <gubagem> [1,4..64]
21:07:48 <bd_> > iterate (*2) 1
21:07:50 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
21:07:58 <gubagem> > [1,4..64]
21:08:00 <lambdabot>  [1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64]
21:08:08 <Cale> > extendSequence [1,2,4,8,16]
21:08:15 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
21:08:16 <bd_> > doWhatIMean [1]
21:08:17 <lambdabot>   Not in scope: `doWhatIMean'
21:08:25 <bd_> :t extendSequence
21:08:27 <lambdabot> SequenceData -> SequenceData
21:08:30 <bd_> hmm
21:08:32 <gubagem> Cale: holy CRAP that works
21:08:32 <Cale> > extendSequence [1,1,2,3,5,8,13]
21:08:34 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:08:38 <mar77a> haskell is HUGE
21:08:45 <orbitz> > describeSequence [1]
21:08:48 <lambdabot>  Just "Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = ...
21:08:51 <Cale> heh
21:08:53 <bd_> > extendSequence $ map read "718281828459045"
21:08:53 <orbitz> heh
21:08:54 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
21:09:03 <orbitz> > describeSequence [1, 37]
21:09:05 <lambdabot>  Just "Square-free part of n: a(n) = smallest positive number m such that mn ...
21:09:05 <bd_> > extendSequence $ map (read.(:[])) "718281828459045"
21:09:07 <lambdabot>  [7,1,8,2,8,1,8,2,8,4,5,9,0,4,5,2,3,5,3,6,0,2,8,7,4,7,1,3,5,2,6,6,2,4,9,7,7,5...
21:09:15 <bd_> > exp 1 :: CReal
21:09:17 <lambdabot>  2.7182818284590452353602874713526624977572
21:09:27 <bd_> nice
21:09:36 <mar77a> > ln 10
21:09:37 <lambdabot>   Not in scope: `ln'
21:09:42 <mar77a> > log 10
21:09:43 <lambdabot>  2.302585092994046
21:09:52 <Cale> extendSequence cheats a bit
21:10:03 <Cale> Where by "a bit", I mean a lot.
21:10:11 <mar77a> > (log 10) / (log (exp 1))
21:10:12 <lambdabot>  2.302585092994046
21:10:12 <gubagem> > extendSequence [1,2,6,24]
21:10:14 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
21:10:29 <Cale> It contacts the online encyclopedia of integer sequences and collects the result.
21:10:34 <gubagem> how does extendSequence cheat? has .......
21:10:37 <gubagem> oh
21:10:55 <Cale> and it's not in IO because of more cheating :)
21:11:05 <mar77a> so it's not a part of the language or ...
21:11:16 <Cale> It's part of the OEIS library.
21:11:21 <Cale> You can get that on Hackage.
21:12:01 <gubagem> i was just about to make a golden calf with lambda shaped horns to worship in honor of extendSequence, but now you broke my idolic heart, cheats, oh so bad
21:12:03 <koninkje> Cale: How'd they get it out of IO?
21:12:09 <Cale> > extendSequence [2,3,5,7,11,13]
21:12:11 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:12:17 <Cale> koninkje: unsafePerformIO
21:12:22 <koninkje> feh
21:12:25 <koninkje> :)
21:12:46 <edwardk> heh i was joking the other day that if you had an efficient means to represent generating functions for functors you could use OEIS as your type system. ;) Oh thats A000108 here is an efficient representation for that as binary trees.... ( I realize you optimize different structures for different operations, etc)
21:13:17 <edwardk> just compute the first dozen terms of the generating function for a functor, and hit OEIS
21:13:27 <Cale> heh
21:14:13 <edwardk> computer the first dozen terms of the derivative of the series, oh an efficient form for the derivative of that functor is A001023 or whatever. ;)
21:14:38 <edwardk> or just keep computing until you get a unique result or what not ;)
21:14:45 <Cale> > getSequenceByID "A000108"
21:14:46 <lambdabot>  Just [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694...
21:14:55 <edwardk> see, catalan numbers ;)
21:14:58 <Cale> yes
21:15:11 <koninkje> Is there a way to make fundeps play nice with overlapping instances (i.e. just pick the same one -XOverlappingInstances would and not complain)?
21:15:13 <mar77a> > (\x -> (1 + 1/x) ** x) [1..]
21:15:14 <lambdabot>   add an instance declaration for (Floating [t])
21:16:03 <dancor> extendProgram
21:16:14 <edwardk> btw- i'm still trying to figure out a good use of bivariate generating functions to try to model the infinite cases
21:16:43 <Cale> edwardk: Maybe just mark constructors with one variable.
21:17:24 <orbitz> why can i do 1 + 1.2 if (+) is defined as (Num a) => a -> a -> a?
21:17:56 <Cale> orbitz: because of numeric defaulting, the type will be defaulted to Double
21:18:13 <edwardk> cale: yeah, the trick with that though is i tried measuing constructors 'met' in a traversal of n items, but the number of ways an m item structure can be represented is also a factor. so you need the number of n item traversals of an m+ item structure and the number of m item structures. so it appears trivariate
21:18:30 <Cale> orbitz: Note that 1 :: Num a => a, and 1.2 :: Floating a => a
21:18:38 <edwardk> otherwise i was able to show multiple structures with the same bivariate generating function
21:19:29 <edwardk> cotrees with and without leaves gave the same bivariate function when i tried it the naive way
21:19:33 <Cale> edwardk: Well, you could even encode the complete structure of any algebraic datatype using enough noncommuting variables.
21:20:15 <edwardk> i was mostly trying to keep it simple enough to be represented as a small generating function. too much encoding and you lose sight of the insights
21:20:19 <Cale> hmm, but you might need some infinite products ;)
21:20:24 <edwardk> er rather you don't get them in the first place.
21:20:31 <Cale> right
21:20:43 <gubagem> night
21:20:47 <edwardk> ido think counting potential productive corecursions of a given size is the right model
21:21:02 <orbitz> Cale: on my achine 1.2 is Fractional t
21:21:17 <Cale> orbitz: er... yes, Fractional, sorry
21:21:25 <orbitz> Cale: i accept your apology
21:21:36 <wolgo> Haskell!
21:22:03 <mar77a> ok going to get some sleep
21:22:08 <mar77a> hopefully...
21:22:13 <mar77a> thanks for all the help, Cale
21:22:22 <edwardk> wolgo: how goes the learning?
21:22:27 <Cale> mar77a: no problem :)
21:26:24 <wolgo> edwardk: It is going. I am on the list part of the tutorial.
21:26:38 <wolgo> I like the list comprehension stuff
21:26:44 <wolgo> I think that is pretty neat
21:26:51 <wolgo> it is very compact
21:27:00 <edwardk> you'd done python before this right?
21:27:06 <wolgo> a little bit
21:27:07 * Cale adds the map diagram to http://cale.yi.org/index.php/Fold_Diagrams
21:27:08 <lambdabot> Title: Fold Diagrams - CaleWiki
21:27:21 <wolgo> python has a similar construct
21:27:24 <edwardk> yeah
21:27:32 <wolgo> b = [i for i in blah]
21:27:41 <edwardk> thats what i was going to mention similarity wise
21:27:51 <wolgo> yeah
21:28:02 <edwardk> its just the haskell version destroys the python version generality wise
21:28:12 <wolgo> I have to say that this language is an order of magnitude more interesting though.
21:28:30 * wolgo says that with limited programming experience.
21:28:32 <edwardk> what i like about it is everytime you turn around you find the rabbit hole goes deeper.
21:28:48 <edwardk> and thats coming from lots of programming experience ;)
21:28:51 <wolgo> :)
21:28:53 <wolgo> hahah
21:29:26 <edwardk> I do wish I had discovered Haskell about 10 years earlier in my career though.
21:29:27 <Cale> How are python list comprehensions crippled?
21:30:23 <wolgo> Thinking recursively instead of in while, for/foreach is different for me though. I know you can use recursion where ever you can use a function. Being forced to evaluate and trace things recursively is different though.
21:30:50 <wolgo> Well, not forced. But following the functional way.
21:30:53 <Cale> Loops become lists :)
21:30:58 <edwardk> i can just never remember the arcane bits of [foo for bar in blech if blarg ]
21:31:02 <orbitz> do you mean you can use recursion everywhere you can use interation?
21:31:53 <orbitz> edwardk: and youc an do it lazily with generations comprehension ro whatever, (but i cannot remember what the darn syntax is)
21:32:21 <vininim> orbitz: IIRC, mu-recursive functions are turing complete
21:32:27 <edwardk> yeah i remember the generator bits, i just always feel if you're going to give me generators/iterators give me continuations already ;)
21:32:36 <wolgo> yeah
21:32:49 <wolgo> yeah to the iteration vs function issue
21:33:06 <Cale> iteration vs. recursion
21:33:10 <Immmortal> vinim, has the same grammar?
21:33:30 <wolgo> doh
21:33:46 <vininim> same computability(sic?) power.
21:34:17 <Immmortal> aXb -> cDe | ...
21:35:14 <Immmortal> remember the Chomsky theories, only there 4 types.
21:35:23 <Cale> I wonder if mapAccumR ever got flipped.
21:35:28 <Immmortal> remember the Chomsky theories, only there are 4 types.
21:36:04 <Immmortal> is type 0 the mu-recursive functions?
21:38:11 <vininim> well, by transitiveness they are equivalent
21:39:17 <Cale> The awesome thing about #haskell is that if you stay here long enough, you'll eventually run into a conversation where you have no idea what the heck people are talking about.
21:40:01 <ddarius> Cale: Like conversations about the vagaries of python?
21:40:08 <bd_> Unless you're Oleg. :)
21:42:28 <Cale> ddarius: Or this conversation between vininim and Immmortal
21:43:05 <vininim> well, there is nothing sophisticate in it. =P
21:43:06 <Cale> Maybe I actually *do* know what that's about though, now that I've looked on wikipedia.
21:43:08 <ddarius> Cale: You know what regular expressions, context free grammars and context-sensitive grammars are.
21:43:28 <orbitz> i don't thinke cale does
21:43:41 <vininim> mu-recursion = turing machine = type 0 grammar is easier to understand thatn cobormis and co-limite co-monadic dual groups (made up by the way) =P
21:43:46 <orbitz> that doesn't sound liek soemthing cale would know
21:43:47 <Cale> ddarius: yeah. Actually, I have seen the definition of mu-recursive functions before, and perhaps they were just called something slightly different.
21:44:11 <vininim> fvso "="
21:44:17 <vininim> *fsvo
21:44:35 <Immmortal> and their machines are: finite automaton (DFA), pushdownstack automaton (PDL), bounded automaton and turing machine, i though.
21:44:41 <wolgo> whoa
21:44:49 <wolgo> currying is bizarre
21:45:18 <edwardk> wolgo: it cleans up the syntax a LOT though =)
21:45:30 <wolgo> The people who created this language included some pretty smart features.
21:45:56 <Cale> Yeah, I'm missing some formal education in that regard. I have a strong understanding of regular grammars and finite automata, but after that, it's somewhat more hazy, since I wasn't actually in CS, but pure mathematics.
21:46:00 <orbitz> wolgo: you like it now, just wait until you get to I/O, you'll cry
21:46:15 <Cale> (so I just know what I've picked up in random conversations)
21:46:27 <edwardk> Its very hard to argue with most of the decisions they made *cough* except for baking fail into Monad *cough* ;)
21:47:15 <wolgo> Is it pretty easy to grab a random line out of a file?
21:47:15 <Cale> edwardk: Everything that happened as a result of removing monad comprehensions was a mistake, including the removal of monad comprehensions.
21:47:23 <edwardk> yeah
21:47:30 <Cale> wolgo: It's not bad.
21:47:31 <Immmortal> if it's type 0 then this language can use any language of type 0, 1, 2 and 3.
21:47:39 <edwardk> that was a reaction to a bad type checker that took a very bad turn
21:47:52 <Immmortal> paradoxically
21:48:10 <Immmortal> if mu-rec functions are type 0 then it can use any language of type 0, 1, 2 and 3.
21:48:24 <edwardk> you can use the IO stuff to read into into a string, unlines it to turn it into a list of lines, select one at random and call it a day basically
21:48:40 <ddarius> lines
21:48:57 <edwardk> @remember Cale Everything that happened as a result of removing monad comprehensions was a mistake, including the removal of monad comprehensions.
21:48:57 <lambdabot> Done.
21:49:08 <vininim> ontologically speaking, substitutions systems and partial functions are very different beasts. You can only map between them, you can't say "they are".
21:49:44 <Immmortal> the substitutions systems are type 2
21:51:20 <vininim> *rewrite systems
21:51:36 <Immmortal> i wanted to say it
21:52:03 <Immmortal> the deductive systems are type 1 and rarely type 0
21:52:18 <vininim> uh... I thought general rewrite systems didn't have restrictions to make it type 2.
21:53:35 <solrize> type 2 = context-free grammar?
21:53:45 <Immmortal> yes solrize
21:53:55 <Immmortal> type 1 = context-sensitive grammar
21:54:45 <Immmortal> type 0 = turing grammar (grammar without restrictions)
21:54:48 <solrize> type 1 = linearly bounded
21:55:14 <solrize> but if the rewrite system can have higher order functions then it can do a much bigger class ?
21:56:03 <Immmortal> solrize, higher order functions only can be solved by deductive systems
21:57:04 <Immmortal> F-systems are nearly to deductive systems
21:57:44 <Immmortal> but they are lesser powerful covering than deductive systems.
22:08:23 <orbitz> :t ( . )( . )
22:08:25 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (a -> b) -> f1 (f a -> f b)
22:15:08 <ivanm> what's with dons "monad fail" post?
22:16:56 <proqesi> ivanm: url?
22:17:18 <Immmortal> a language of type N can't use a language of type N-1, N-2, ...
22:18:07 <Immmortal> then the language of type N is limited!
22:19:25 <ivanm> http://www.cse.unsw.edu.au/~dons/blog/2008/05/24#monad_fail
22:19:28 <lambdabot> Title: Haskell hacking
22:20:53 <koninkje> Immmortal: of course it is. type-0 is restricted to not using oracles, frex
22:21:49 <allbery_b> complaint that "fail" doesn't belong in class Monad, lolcat-style
22:23:21 <ivanm> allbery_b: ahhhh.... didn't get the lolcat bit ;-)
22:24:06 <Trinithis> what is "a language of type N"?
22:24:46 <solrize> chomsky hierarchy, 0=unrestricted, 1=context sensitive, 2=context free, 3=regular
22:25:03 <solrize> stuff no one cares about any more ;)
22:25:08 <Trinithis> :D
22:25:10 <vininim> D:
22:25:35 <koninkje> Chomsky didn't envision undecitable and A' languages ;)
22:25:42 <edwardk> heh i'd almost say it should go on http://failblog.org/ or something ;)
22:25:42 <lambdabot> Title: The FAIL Blog
22:25:43 <ivanm> solrize: hang on, there's a type system not only _within_ languages but also _between_ languages? :o
22:25:53 <Trinithis> A'?
22:26:06 <koninkje> not-A
22:26:11 <vininim> I think catsters do. =P
22:30:15 <koninkje> A are languages which are recognizable by TM (though not necessarily decidable), not-A are those not recognized by a TM
22:30:37 * koninkje doesn't know how much "A" is used outside of Sipser
22:35:08 <thetallguy> Heh.  I just came in to say 'dons: where's the rest of your 'monad fail' post?'
22:35:17 <thetallguy> I see ivanm had the same thought
22:35:24 <thetallguy> I guess he got bitten.
22:38:08 <edwardk> i think it was mostly to provoke a response
22:39:15 * edwardk finally bites. So how tall is the tall guy ;)
22:40:15 <Trinithis> Taller than a duplex
22:41:19 <thetallguy> edwardk: taller than your average bear
22:41:36 <edwardk> fair nuff =P
22:41:48 <Trinithis> ... taller than YOU!!!
22:42:05 <thetallguy> edwardk: 6'5"
22:42:14 <edwardk> ah ok so a couple inches taller than me
22:42:38 <Trinithis> He's a monstrosity: 14'11'
22:42:55 <thetallguy> 14feet 11 feet?
22:43:11 <edwardk> yeah they ran out of tape after the first 14 feet, then had to start over
22:43:13 <Trinithis> 14'11" (typo)
22:43:29 <Trinithis> err.. edward's explanation is better
22:43:55 <thetallguy> conal thought my handle was 'theta llguy' at first
22:44:28 <edwardk> spreading activation goes to strange places for strange people ;)
22:45:23 <thetallguy> I wonder how many people call him Colin?
22:45:27 * edwardk finally got the shiny new yoneda/coyoneda instances in. looks like they are sort of half-way between ContT and the original (co)monad.
22:46:02 <edwardk> took me about a year before i could distinguish between him and conor mcbride in my brain for some reason.
22:46:07 <thetallguy> Don't know about yoneda
22:47:01 <edwardk> thetallguy: http://comonad.com/reader/2008/kan-extensions/  and http://sigfpe.blogspot.com/2006/11/yoneda-lemma.html
22:47:02 <solrize> yeah i asked conal a question about one of conor's blog posts once.  he figured out the error
22:47:03 <lambdabot> Title: The Comonad.Reader  Kan Extensions
22:48:30 <edwardk> thetallguy the short answer is you can say (forall b. (a -> b) -> f b) ~= f a
22:48:59 <edwardk> the interesting bit is you can fmap over the former and they just accumulate in the function
22:50:20 <edwardk> so if you fmap a lot it looks like a win. and the monad instance, etc has comparable characteristics to the original monad.
22:51:06 <davidL> @seen glguy
22:51:07 <lambdabot> glguy is in #haskell. I don't know when glguy last spoke.
22:51:29 <edwardk> otoh you can map more things over this monad than you can over ContT, so some MonadFoo classes that don't lift over ContT will over Yoneda.
22:51:58 <thetallguy> edwardk: hmm.
22:52:27 <edwardk> it mostly exists as a theoretical nicety, but i'm trying it out for performance in certain recursion schemes
22:52:36 <hpaste>  wolgo pasted "Flow of execution" at http://hpaste.org/7851
22:53:13 <davidL> @ask glguy is there a repo for the new fcgi hpaste?
22:53:13 <lambdabot> Consider it noted.
22:53:39 <wolgo> hpaste is pretty cool
22:53:51 <edwardk> pretty close modulo a couple of typos
22:54:15 <hpaste>  edwardk annotated "Flow of execution" with "typos" at http://hpaste.org/7851#a1
22:54:57 <wolgo> Ahh I see.
22:55:11 <wolgo> Thanks edwardk
22:55:15 <edwardk> er slight error on my behalf even
22:55:32 <Trinithis> 1 : 2 : 3 : takeint 0 [4,5]
22:55:33 <thetallguy> edwardk: thanks for the rundown. Still quite fuzzy, but I will walk that road myself later and see what's up.
22:55:36 <hpaste>  (anonymous) annotated "Flow of execution" with "(no title)" at http://hpaste.org/7851#a2
22:55:39 <edwardk> yeah
22:55:45 <edwardk> that was the error =)
22:55:54 <wolgo> Ahh yes that is where the [] comes in
22:56:26 <edwardk> > take 3 [1..]
22:56:26 <koninkje> @hoogle (a -> m b) -> (a -> m c) -> a -> m c
22:56:27 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
22:56:27 <lambdabot> Data.Function.(.) :: (b -> c) -> (a -> b) -> a -> c
22:56:27 <lambdabot> Control.Parallel.Strategies.(.|) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
22:56:28 <lambdabot>  [1,2,3]
22:56:35 <edwardk> @src take
22:56:36 <lambdabot> take n _      | n <= 0 =  []
22:56:36 <lambdabot> take _ []              =  []
22:56:36 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
22:56:49 <wolgo> hmm
22:57:40 <edwardk> koninkje: did you mean b -> m c?
22:57:50 <edwardk> @type (>=>)
22:57:51 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
22:58:11 <koninkje> edwardk: no, I was looking for foo f g = \x -> f x >> g x
22:58:30 * koninkje knew about (>=>), (<=<)
22:58:48 <edwardk> kk
22:59:30 <edwardk> @type liftM2 (>>)
22:59:31 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m1, Monad m) => m1 (m a) -> m1 (m b) -> m1 (m b)
23:00:03 <edwardk> should work
23:00:11 <Trinithis> @pl \x -> f x >> g x
23:00:12 <lambdabot> liftM2 (>>) f g
23:00:26 <wolgo> @src sum
23:00:26 <lambdabot> sum = foldl (+) 0
23:00:35 <wolgo> @src foldl
23:00:35 <lambdabot> foldl f z []     = z
23:00:35 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:05:27 <wolgo> When I do listsum (x:xs) = x + listsum xs it gives a "non-exhaustive pattern etc" message, when I define the base case listsum [] = 0 it does not
23:05:40 <wolgo> What does non-exhaustive pattern mean?
23:06:02 <koninkje> wolgo: it means you don't have a pattern for every constructor
23:06:28 <wolgo> Oh ok
23:06:40 <koninkje> e.g. Lists are defined by (:) and [], but "let foo [] = True" isn't exhaustive since foo could be passed some (_:_)
23:07:58 <koninkje> e.g.2 "let foo [] = True ; foo (a:b:c) = False" also isn't complete because (_:[]) could be passed
23:14:37 <koninkje> @pl \f x -> f x >> reutrn x
23:14:37 <lambdabot> (`ap` reutrn) . ((>>) .)
23:14:49 <koninkje> @pl \f x -> f x >> return x
23:14:49 <lambdabot> (`ap` return) . ((>>) .)
23:14:54 <koninkje> meh
23:16:15 <Trinithis> @pl flip liftM2 return
23:16:15 <lambdabot> flip liftM2 return
23:16:33 <Trinithis> @ty flip liftM2 return
23:16:37 <lambdabot> forall a2 r a (m :: * -> *). (Monad m) => (m a -> a2 -> r) -> (a -> a2) -> a -> r
23:17:28 <koninkje> What do y'all think is a good name for (\f x -> f x >> return x) ?
23:18:11 <edwardk> kojinkje: randomCombinatorISeemToNeed1 ;)
23:18:18 <koninkje> heh heh
23:18:26 <koninkje> too many things return m ()
23:18:35 <koninkje> effectful things I mean
23:18:52 <edwardk> purpose of it?
23:18:58 <edwardk> @type \f x -> f x >> return x
23:19:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (b -> m a) -> b -> m b
23:19:19 <koninkje> edwardk: just trying to clarify/brevity-ify some code
23:19:20 <edwardk> ah got it. to avoid throwing away the input?
23:19:29 <edwardk> when a = ()?
23:20:04 <koninkje> I seem to run into that pattern all the time, e.g. put State but also return it, etc
23:20:30 <koninkje> The general combinator wouldn't care about a, though the majority of the time it is () yes
23:21:13 <bd_> koninkje: What's wrong with m ()?
23:21:35 <edwardk> sounds like he's trying to avoid having to capture it explicitly in a variable first
23:21:46 <koninkje> bd_: the function this is embedded in don't return ()?
23:22:11 <koninkje> edwardk: pretty much. oo many lambdas become clutter after a while
23:22:16 <koninkje> s/oo/too/
23:22:18 <edwardk> yeah
23:22:39 <bd_> (\f x -> f x >> return x) <-- how about pass?
23:22:42 <bd_> f `pass` 42
23:22:46 * edwardk is sitting here letting his OCD write a ton of instances no one will care about when he should be sleeping ;)
23:23:01 <koninkje> @hoogle pass
23:23:01 <lambdabot> Control.Monad.Writer.Class.pass :: MonadWriter w m => m (a, w -> w) -> m a
23:24:14 <bd_> oh.
23:24:22 <bd_> passThru f 42 ?
23:24:25 <bd_> or
23:24:27 <bd_> through f 42 ?
23:25:06 <bd_> @hoogle through
23:25:07 <lambdabot> No matches found
23:27:07 <koninkje> @hoogle (a -> b) -> a -> a
23:27:07 <lambdabot> Control.Monad.Writer.Class.listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
23:27:07 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
23:27:07 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
23:27:46 <koninkje> eh, I'll figure something out
23:27:49 * koninkje -> bed
23:58:28 <tibbe> has there been an official release of cabal-install yet?
