00:09:55 <optikal> Has anybody seen something like the following: An application that can visually represent a functional program?
00:10:11 <cjs> DrScheme?
00:10:22 <cjs> I think it might have had something like that.
00:10:51 <optikal> I have used DrScheme before, I don't remember seeing anything like that
00:10:56 <dolio> Represent what about it?
00:11:09 <optikal> dolio: THat's a good question. I don't know
00:11:19 <cjs> Hm. Maybe I'm just thinking of some sort of line drawing it did to link parts of a function or something.
00:11:28 <optikal> I was just interested in seeing how they represent it
00:12:22 <optikal> Like for example -- say you had a library of functions -- the application could show in some intuitive manner how you can compose these functions
00:12:33 <optikal> and maybe even reactively display the results
00:13:40 <optikal> From what I've read there is some supposed problem with graphical representations not having as much 'information density' as text
00:14:20 <vegai> I worked in a research project once where there was a language specifically designed for a sort-of n-dimensional spreadsheet
00:14:31 <dolio> There was some haskell-ish environment that would animate certain things.
00:14:41 <vegai> ibid can tell you more, I think he designed it
00:15:22 <dolio> Like, if you typed in an expression for an infinite list, it would display it as a bunch of linked boxes, and would expand it further at your request or something.
00:15:36 <dolio> I don't remember what it was called, though.
00:16:39 <optikal> I genreally hate "Visual Programming", but I think it may just be a problem with the implementations I've used in the past that tended to be procedural rather than functional
00:17:00 <optikal> and a hybrid solution might just be the best of both worlds
00:17:42 <ibid> i designed what?...
00:17:44 <optikal> use a text editor to build up your library then have some sort of dataflow front-end
00:17:49 <vegai> ibid: clang?
00:17:57 <ibid> thales clang
00:18:06 <ibid> and it was never a finished design, nor implemented
00:18:12 <vegai> ah, ok.
00:18:25 <ibid> benja had his language which was actually used
00:18:37 <ibid> i think i have our ht'01 writeup somewhere
00:18:55 <vegai> it was clasm then, I think
00:19:08 <quicksilver> http://www.cs.kent.ac.uk/projects/vital/
00:19:09 <quicksilver> ?
00:19:09 <lambdabot> Title: Vital homepage
00:19:11 <ibid> yes, http://www.mit.jyu.fi/antkaij/plinzz.html
00:19:13 <lambdabot> Title: Totally Different Structural Programming - Programming Languages in ZigZag
00:19:17 <quicksilver> might be what dolio was thinking of.
00:19:32 <dolio> Yeah, vital is it.
00:19:41 <ibid> i was thinking about zaubertrank
00:19:46 <ibid> but yeah, clasm too
00:24:37 <dolio> There's other stuff for animated graph reduction and suchlike.
00:24:50 <dolio> http://thyer.name/lambda-animator/
00:24:51 <lambdabot> Title: Lambda Animator : animated reduction of the lambda calculus
00:26:04 <dolio> http://www.haskell.org/pipermail/haskell-cafe/2008-February/039930.html
00:26:05 <lambdabot> Title: [Haskell-cafe] Graphical graph reduction, http://tinyurl.com/57ahw9
00:29:45 <optikal> Yeah, that doesn't seem very helpful though
00:31:16 <optikal> In that case the textual representation has a much greater information density in terms of pixels
00:31:32 <koninkje> @hoogle (a,b) -> (b,a)
00:31:34 <lambdabot> No matches, try a more general search
00:40:10 <dolio> @type uncurry $ flip (,)
00:40:12 <lambdabot> forall a b. (a, b) -> (b, a)
00:45:12 <koninkje> not much clearer than the lambda expression. I was just seeing if anyone'd named it already
00:45:34 <dolio> Nope. It's kind of a surprising omission.
00:50:26 <dolio> It might be going in in 6.10. There's a libraries@ mail about it.
00:50:33 <dolio> swap, fst3, snd3, thd3
00:52:55 <Cale> Heh, what about the 5 nonidentity permutations of a 3-tuple? ;)
00:53:11 <dolio> Nothing about those. :)
00:53:34 <mauke> :t (snd &&& fst)
00:53:36 <lambdabot> forall a b. (a, b) -> (b, a)
01:26:50 <mae> if you were stranded on a desert island for the rest of your natural life and you had a choice between a gun, a laptop with infinity battery power and no internet connectivity (only the original version of qdos is installed + qbasic), or a picture of barbara streissand naked, which would you choose?
01:27:42 <quicksilver> I've always wanted to reimplement GHC in qbasic.
01:27:45 <quicksilver> So the answer is obvious.
01:28:08 <mae> see now i was having a similar idea on another channel
01:28:12 <mae> i would bootstrap lisp on basic
01:28:18 <mae> because its a simpler vm
01:28:24 <mae> because, lets face it.
01:28:31 <mae> basic is pretty.... basic
01:28:41 <mae> how many gotos can you handle before your brain explodes?
01:32:49 <AshyIsMe> mae, a fair few if they're used appropriately
01:33:55 <mae> ok
01:34:05 <mae> so you have your own goto methodology do you?
01:34:19 <mae> do you have a name for it? like "Extreme Gotos (tm)"
01:34:31 <dcoutts> aka continuations?
01:35:58 <flux> mae, maybe you could use the infinite battery to boil the ocean and walk your way off the island!
01:36:15 <koninkje> @hoogle unsafeFromJust
01:36:16 <lambdabot> No matches found
01:36:21 <koninkje> @hoogle fromJust
01:36:22 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
01:38:19 <mae> @hoogle unsafeSexJust
01:38:19 <lambdabot> No matches found
01:39:54 <mae> flux: the infinite battery was infinite in the sense of "within your human lifetime", the amount of amps that would draw would void your warranty and would probably not last infinity anymore. Please understand that the battery is not to be used around small children and is a choking hazard. I will not be held responsible for any misuse and/or disassembling of the unit.
01:43:26 <mae> so
01:43:53 * mae speaks of monomorphism restrictions in such a way that it infuriates a controversial discussion *ok now*
01:44:54 <Japsu> monomorphism restriction - serious business
01:47:10 <mae> so, one day i was coding this monad right, and all of a sudden, I got this error message from the compiler screaming at me about instances and type signatures and whatnot. The End.
01:48:51 <ski_> @arr
01:48:51 <lambdabot> Har de har har!
01:50:47 <dolio> ski_: Did you want something from me a few days ago?
01:52:07 <quicksilver> @seen kuribas
01:52:07 <lambdabot> I haven't seen kuribas.
01:52:11 <quicksilver> lais!
01:53:18 <ski_> dolio : oh, right .. edwardk said something about me having an "indexed inductive data type" which "separated traversal from elements of a tree" or something to that effect
01:53:57 <ski_> dolio : i just briefly wondered if you wanted to see what the datatype was (and it's just a plain regular haskell data type)
01:54:08 <dolio> Sure.
01:54:42 <ski_> ok, consider the usual
01:54:54 <ski_> data BinTree a = Leaf a
01:55:13 <ski_>                | Branch (BinTree a) (BinTree a)
01:55:23 <ski_> just a binary tree with elements in the leaves
01:55:36 <ski_> now, a perfectly balanced tree
01:55:47 <ski_> data BalTree a = Zero a
01:56:06 <ski_>                | Succ (BalTree (a,a))
01:56:20 <ski_> with a sample element
01:56:53 <ski_> (S . S . S) $ Z (((0,1),(2,3)),((4,5),(6,7))) :: BalTree Int
01:56:59 <ski_> ok, so far ?
01:57:03 <dolio> Yep.
01:58:04 <ski_> so, my tree type is like `BalTree' in that the elements of the tree is in one place, and the "branches part" in another place .. but for general unbalanced trees
01:58:14 <ski_> here it comes :
01:58:35 <ski_> newtype Identity a = I a
01:59:02 <ski_> type BinTree' a = BinTreeK Identity a
01:59:14 <ski_> data BinTreeK k a = LeafK (k a)
02:00:01 <ski_>                   | BranchK (BinTreeK (Tmp0 a k) a)
02:00:29 <ski_> newtype Tmp0 a k t0 = T0 (BinTreeK (Tmp1 k t0) a)
02:00:43 <ski_> newtype Tmp1 k t0 t1 = T1 (k (t0,t1))
02:00:56 <ski_> with a sample element
02:02:21 <ski_> (B . B . L . T0 . B . L . T0 . L . T1 . T1 . T0 . B . B . L . T0 . L . T1 . T0 . L . T1 . T1) $ I ((0,(1,2)),((3,4),5))
02:02:31 <ski_> (iirc, i'm taking this from memory)
02:03:07 <ski_> the part before the `$' describes how to turn in a depth-first, left-to-right traversal of the tree
02:03:27 <ski_> B : enter the left subtree of a branch
02:03:37 <ski_> L : enter and exit a leaf
02:03:54 <ski_> T0 : exit the left subtree of a branch, and enter the right subtree
02:04:08 <ski_> T1 : exit the right subtree of a branch, and exit the whole current tree
02:04:19 * quicksilver slaps ski_ gently with the 'hpaste' stick.
02:04:24 <ski_> dolio : what do you think ?
02:04:28 <dolio> Interesting.
02:04:54 <quicksilver> it is interesting.
02:04:56 <ski_> i stumbled upon this type when pondering sortof CPS transformation of types
02:05:45 <ski_> quicksilver : sorry, didn't think of it (i was taking from memory, so i didn't recall how long it would be)
02:07:09 <ski_> interesting excercises is coding the bijections between  BinTree a  and  BinTree' a
02:09:45 <ski_> (er, actually of course it is not regular, i don't pass `k' as argument to the recursive calls ..)
02:10:27 <ski_> (also, it would be nice if one could avoid the ugly `Tmp0',`Tmp1',`T0',`T1', but alas, i don't think this can be avoided, here)
02:10:31 <quicksilver> non-regular types are interesting.
02:10:45 <quicksilver> You could certainly choose better names :)
02:10:55 <ski_> (but it is regular in the second type argument ..)
02:11:03 <ski_> quicksilver : you mean the `Tmp' types ?
02:11:24 * quicksilver nods
02:11:27 <ski_> have any suggestion for meaningful names for them ?
02:12:15 <ski_> (.. hm, maybe `LeftToRight',`RightToUp', or something in that spirit)
02:14:39 <JaffaCake> dons: there?
02:15:12 <ski_>                   | BranchK (BinTreeK (\t0 -> BinTreeK (\t1 -> k (t0,t1)) a) a)  -- just for completeness, the more readable pseudo-code
02:15:23 <glguy> JaffaCake: I can't imagine he's up right now
02:15:33 <JaffaCake> oh well, worth a try :)
02:15:39 <JaffaCake> what are you doing up anyway?
02:15:46 <glguy> I stay up later than him
02:15:56 <glguy> there's still Internet left to browse
02:16:15 <JaffaCake> yeah I know, every time you think you've read the internet, someone writes something else
02:16:40 <glguy> I need a google that filters out all blogs
02:16:53 <JaffaCake> sounds useful
02:17:08 <JaffaCake> so anyway, I was converting the GHC repo to git, and I think I hit the same problem that dons did
02:17:21 <quicksilver> ski_: Right and Out ?
02:17:23 <glguy> system fc patch?
02:17:33 <JaffaCake> it's the "before FC merge" tag
02:17:40 <JaffaCake> there are two tags with the same name
02:17:45 <glguy> ew
02:17:57 <quicksilver> glguy: http://xkcd.com/386/
02:17:57 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
02:18:06 <quicksilver> (there really *is* an xkcd for every occasion, you know)
02:18:13 <JaffaCake> I imagine it's possible to work around it somehow
02:18:20 <ski_> quicksilver : could work better than `Tmp0' and `Tmp1', at least
02:18:22 <glguy> quicksilver: I recognize that one by number ;)
02:21:06 <appletizer> glguy, you could probably do a -blog in the google search for a close approximation
02:21:07 <appletizer> :)
02:21:56 * dolio wonders to himself what's going on with hpastetwo.
02:22:59 <glguy> installing anything from this decade is a hassle on debian
02:23:19 <glguy> so sitting down and doing it is just that much less appetizing
02:23:23 <glguy> that's what's holding it up
02:23:26 <dolio> Heh.
02:28:24 <RayNbow> <quicksilver> (there really *is* an xkcd for every occasion, you know) <-- I haven't read all xkcds yet, but is there one related to Haskell? :)
02:29:14 <quicksilver> sadly not, no.
02:29:20 <quicksilver> but there is a well-known coda to http://xkcd.com/353/
02:29:20 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
02:29:38 <quicksilver> If python lets you fly, then haskell lets you fold space like a guild navigator.
02:30:42 <RayNbow> :)
02:31:19 <dolio> Which language lets you copulate like a Bene Gesserit imprinter?
02:31:54 <profmakx> extension of internet rule 34: If you can imagine it, there is an xkcd for it
02:32:35 <quicksilver> dolio: clearly I'm not going to share that knowledge
02:32:55 <dolio> Awww.
02:35:53 <dolio> It's INTERCAL isn't it?
02:46:10 <kuribas> dolio: I fixed the problem.
02:46:11 <lambdabot> kuribas: You have 1 new message. '/msg lambdabot @messages' to read it.
02:46:46 <kuribas> lambdabot: You already told me
02:47:11 <kuribas> dolio: (the second one, the first not yet)
02:47:16 <quicksilver> kuribas: I sent you a new problem :)
02:47:56 <dolio> Second and first...
02:48:00 <kuribas> quicksilver: Oh, then it was your f
02:48:04 <dolio> You fixed the -} ?
02:48:16 <kuribas> No the char literal problem.
02:48:24 <dolio> Oh, okay.
02:48:35 <kuribas> Guess it was quicksilver's...
02:50:08 <kuribas> dolio: I'll the other one this evening.
02:50:34 <dolio> All right. It's not something that's bothering me much.
02:53:42 <quicksilver> kuribas: what was it?
02:56:05 <visof> foo [[]] = []
02:56:06 <visof> foo [xs] = xs
02:56:06 <visof> foo (xs:ys:zs) | last xs > last ys = xs
02:56:06 <visof>                 |otherwise          = foo (ys:zs)
02:56:25 <visof> i want choose the list of the highest end
02:56:28 <visof> like:
02:56:52 <visof> [[1..2],[2..4],[4..5]]
02:56:54 <ski_> @hoogle maxBy
02:56:54 <lambdabot> No matches found
02:57:05 <visof> so the result is [4..5]
02:57:06 <EvilTerran> ?hoogle maximumBy
02:57:07 <lambdabot> Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
02:57:07 <lambdabot> Data.Foldable.maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
02:57:26 <visof> is my function wrong?
02:57:32 <visof> is it very bad?
02:58:38 <quicksilver> no, it's not very bad.
02:58:49 <quicksilver> it crashes if you have a [] in the middle though, I think.
02:59:02 <pastorn> @hoogle cmp
02:59:03 <lambdabot> Data.ByteString.Internal.memcmp :: Ptr Word8 -> Ptr Word8 -> CSize -> IO CInt
02:59:53 <ski_> > (maximumBy (compare `on` last) . filter (not . null)) [[1,2,3],[],[4,9],[5,6,7,8]]
02:59:55 <lambdabot>  [4,9]
03:00:53 <visof> ski is my function very wrong?
03:01:14 <mehrheit> > (maximumBy (compare `on` last) . filter (not . null)) []
03:01:16 <lambdabot>  Exception: List.maximumBy: empty list
03:01:28 <ski_> visof : what is "very wrong" ?
03:01:38 <visof> foo [[]] = []
03:01:39 <visof> <visof> foo [xs] = xs
03:01:39 <visof> <visof> foo (xs:ys:zs) | last xs > last ys = xs
03:01:39 <visof> <visof>                 |otherwise          = foo (ys:zs)
03:01:39 <ski_> mehrheit : can otherwise be expected ?
03:02:00 <visof> ski_ what do you mean?
03:02:26 <mehrheit> ski_, probably not, just checking
03:02:35 <ski_> visof : presumably you want to allow (and ignore) empty lists anywhere in the list of lists, not just at the end ?
03:03:13 <ski_> visof : consider `foo [[1,2,3],[],[4,9],[5,6,7,8]]' e.g.
03:03:21 <visof> okay
03:03:39 <visof> xs = [1,2,3] and ys = []
03:03:49 <visof> last xs = 3
03:04:00 <visof> ah
03:04:07 <visof> understood
03:04:11 <sieni> ski_: well, what would be the answer then, if all the lists were empty?
03:04:13 <ski_> (actually s/at the end/when the list of lists is a singleton list of the empty list)
03:04:33 <ski_> sieni : what os the answer of `head []' ?
03:05:14 <sieni> ski_: yeah
03:06:17 <sieni> ski_: you might conceivably want to have an error if you have empty lists and non-empty lists mixed
03:06:32 <quicksilver> ski_: <Singularity in Space-Time> perhaps ?
03:07:19 <ski_> presumably we want `forall xss xs.  xs `elem` xss = True  ==>  xs = []  \/  last xs <= last (foo xss) = True'
03:08:00 <ski_> quicksilver : aka run-time type error ?
03:08:36 <ski_> (or something in that vein)
03:09:31 <sieni> btw, are there anything else with the most general type in haskell besides head []?
03:09:38 <sieni> @t head []
03:09:39 <lambdabot> Maybe you meant: tell temp thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
03:09:50 <sieni> @type head []
03:09:53 <lambdabot> forall a. a
03:10:15 <mehrheit> @type undefined
03:10:17 <lambdabot> forall a. a
03:10:23 <sieni> oh, that one :-)
03:11:16 <ski_> @type fix id
03:11:19 <lambdabot> forall a. a
03:11:39 <ski_> @type let loop = loop in loop
03:11:42 <lambdabot> forall t. t
03:11:43 <sieni> that one I haven't even thought about
03:11:57 <skorpan> you can't do something like this right? e@(c,s) <- get
03:12:00 <ski_> > fix id
03:12:15 <lambdabot>  thread killed
03:12:17 <ski_> > let loop = loop in loop
03:12:32 <lambdabot>  thread killed
03:12:34 * ski_ expected a "Loop" exception ..
03:12:50 <ski_> skorpan : afaik, you can
03:13:29 <skorpan> oh... lol, that's awesome :)
03:13:30 <ski_> > do e@(c,s) <- [(0,1),(2,3)]; return (e,c,s)
03:13:31 <lambdabot>  [((0,1),0,1),((2,3),2,3)]
03:13:41 <ski_> seems to work just fine
03:14:02 <skorpan> i thought i had tried it a while back and was going to ask if there is something similar you can do instead :)
03:14:04 <MyCatVerbs> @ois 4 8 15 16 23 42
03:14:04 <lambdabot> The Lost Numbers.
03:14:04 <lambdabot> [4,8,15,16,23,42,108]
03:14:41 <mehrheit> @help ois
03:14:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:15:12 <ski_> @help oeis
03:15:13 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
03:15:27 <ski_> @oeis
03:15:27 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
03:15:29 <ski_> @oeis 0
03:15:30 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
03:15:30 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
03:15:32 <ski_> @oeis 0 0
03:15:33 <lambdabot> Moebius (or Mobius) function mu(n).
03:15:33 <lambdabot> [1,1,1,0,1,1,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,1,0,0,1,1,1,0,1,1,1,0,1,1,...
03:15:34 <ski_> @oeis 0 0 0
03:15:35 <lambdabot> Moebius (or Mobius) function mu(n).
03:15:35 <lambdabot> [1,1,1,0,1,1,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,1,0,0,1,1,1,0,1,1,1,0,1,1,...
03:15:37 <ski_> @oeis 0 0 0 0
03:15:37 <lambdabot> Binomial coefficients binomial(n,4).
03:15:37 <lambdabot> [0,0,0,0,1,5,15,35,70,126,210,330,495,715,1001,1365,1820,2380,3060,3876,4845,...
03:15:40 <ski_> @oeis 0 0 0 0 0
03:15:40 <lambdabot> The characteristic function of 0: a(n) = 0^n.
03:15:41 <lambdabot> [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
03:15:45 <ski_> ..
03:16:00 <ski_> i only wanted `\_ -> 0' ..
03:17:52 <mehrheit> are strict fields in records possible?
03:18:20 <MyCatVerbs> mehrheit: yesh.
03:18:31 <mehrheit> what is the syntax?
03:18:39 <MyCatVerbs> data Foo = { bar :: ! Integer, baz :: Bool, bum :: ! String }
03:18:44 <mehrheit> thank you
03:18:49 <MyCatVerbs> For strict bar, lazy baz and strict bum.
03:18:49 <ski_> records are just a syntactic disguise of algebraic data types (or newtypes)
03:19:24 <ski_> (s// in haskell/)
03:21:19 <skorpan> lemme test something
03:21:20 <skorpan> hello
03:21:24 <skorpan> s/llo/y/
03:21:26 <skorpan> awesome
03:22:17 <mehrheit> IRC client with built-in sed?
03:22:46 <skorpan> rcirc with rcirc-late-fix
03:23:01 <mehrheit> %s/.*//
03:23:07 <skorpan> it's not that complex :)
03:23:38 <skorpan> s/a/?/
03:23:46 <skorpan> okay so that didn't work
03:23:52 <skorpan> i'm not sure how this piece of crap works
03:24:16 <skorpan> no wait! it actually replaced my last "a" with "?"
03:24:21 <skorpan> awesome :)
03:24:27 <MyCatVerbs> :%s/.*/YOUR MOTHER/g <-- for great justice, and instant bash quote
03:26:16 <opqdonut> MyCatVerbs: why was is "strict bum" and not "lazy bum"
03:26:44 <MyCatVerbs> opqdonut: because I didn't think of that pun until just *after* I hit ^M on the example, sorry. :(
03:26:50 <opqdonut> :P
03:28:57 <yitz> @let s x y z = let {(h,t) = dropWhile (not . (x `isPrefixOf``) . snd) $ zip (inits z) (tails z)} in concat [h, y, zipWith const t x]
03:28:58 <lambdabot>  Parse error
03:29:51 <yitz> @let s x y z = let {(h,t) = dropWhile (not . (x `isPrefixOf`) . snd) $ zip (inits z) (tails z)} in concat [h, y, zipWith const t x]
03:29:52 <lambdabot> Couldn't match expected type `(t, t1)'
03:30:23 <yitz> @let s x y z = let {(h,t) = head $ dropWhile (not . (x `isPrefixOf`) . snd) $ zip (inits z) (tails z)} in concat [h, y, zipWith const t x]
03:30:24 <lambdabot> Defined.
03:30:47 <yitz> > s "llo" "y" "hello"
03:30:48 <lambdabot> Terminated
03:30:55 <yitz> ergh
03:31:16 <skorpan> ..
03:31:25 <yitz> @let s x y z = let {(h,t) = head $ dropWhile (not . (x `isPrefixOf`) . snd) $ zip (inits z) (tails z)} in concat [h, y, take (length x) t]
03:31:27 <lambdabot> <local>:3:0:     Warning: Pattern match(es) are overlapped              In th...
03:32:21 <mehrheit> where is the Show (->) instance?
03:32:30 <mehrheit> (in which module)
03:32:38 <EvilTerran> in the lambdabot source
03:32:48 <MyCatVerbs> mehrheit: over the rainbow, right next to the Eq instance for (a->a)
03:33:12 <mehrheit> MyCatVerbs, I mean the one that prints "<function>" or something similar
03:33:20 <MyCatVerbs> mehrheit: just under the shelf where we keep the halting oracle and the super-halting oracle and the super-super halting oracle... ;)
03:33:21 <EvilTerran> instance (Typeable a, Typeable b) => Show (a -> b) where show f = "<" ++ show (typeOf f) ++ ">"
03:33:42 <EvilTerran> or something
03:33:53 <MyCatVerbs> (It's a really long shelf. Swiped it from the supply cupboard back when Hilbert's Hotel went out of business.)
03:34:51 <EvilTerran> yitz, if you want to redefine something with @let that's already defined that way, you need to @undef between times
03:35:02 <EvilTerran> which clears all the @let'ed definitions
03:35:33 <slava> Show for (->) could print the source of the function
03:36:19 <yitz> @let s x y z = let {(h,t) = head $ dropWhile (not . (x `isPrefixOf`) . snd) $ zip (inits z) (tails z)} in concat [h, y, drop (length x) t]
03:36:20 <lambdabot> <local>:3:0:     Warning: Pattern match(es) are overlapped              In th...
03:36:24 <MyCatVerbs> slava: if it weren't for our lust for efficiency through compilation, I guess we could define Read and Show instances for (->) based on source code. :)
03:36:27 <yitz> @undef
03:36:28 <lambdabot> Undefined.
03:36:33 <yitz> @let s x y z = let {(h,t) = head $ dropWhile (not . (x `isPrefixOf`) . snd) $ zip (inits z) (tails z)} in concat [h, y, drop (length x) t]
03:36:35 <lambdabot> Defined.
03:36:38 <Beelsebob> Anyone familiar with Yampa about?
03:36:51 <yitz> > s "llo" "y" "hello"
03:36:52 <lambdabot> Terminated
03:37:26 <yitz> @type s
03:37:28 <lambdabot>     Ambiguous occurrence `s'
03:37:28 <lambdabot>     It could refer to either `L.s', defined at <local>:1:0
03:37:28 <lambdabot>                           or `SimpleReflect.s', imported from SimpleReflect at State/imports.h:71:0-32
03:37:40 <yitz> aha
03:37:47 <yitz> > L.s "llo" "y" "hello"
03:37:49 <lambdabot>  "hey"
03:38:10 <yitz> Well, there we go folks. Who needs some fancy irc client?
03:38:11 <MyCatVerbs> slava: I guess programming languages with eval do that all the time, though few have anything resembling static typing. >>
03:38:52 <Beelsebob> http://hpaste.org/7452 <-- anyone have a clue why my program exits cleanly when the rSwitch here is triggered?
03:39:28 <quicksilver> MyCatVerbs: and our lust for referential transparency.
03:40:12 <MyCatVerbs> quicksilver: eh, no reason you couldn't have referentially transparent readSource :: String -> (Dynamic -> Dynamic).
03:40:52 <slava> MyCatVerbs: i'm not sure what static typing and compilation have to do with it
03:40:54 <MyCatVerbs> It's just that no one's ever thought it'd be useful, so they always implement readAction :: String -> (Dynamic -> IO ()) instead.
03:41:31 <MyCatVerbs> slava: static typing means that your eval'd-at-runtime functions can't just return any old damn thing.
03:41:57 <slava> you can't statically gaurantee that Read will read a valid integer, either
03:41:59 <MyCatVerbs> slava: compilation has plenty to do with it. eval pretty much requires an interpreter.
03:42:12 <slava> or a compiler
03:42:19 <quicksilver> MyCatVerbs: but the kind of Show istance you were talking about is not referentially transparent.
03:42:32 <MyCatVerbs> quicksilver: how so?
03:42:41 <quicksilver> MyCatVerbs: since it can distinguish id and id . f
03:42:43 <quicksilver> for example.
03:42:47 <ski_> `show (\x -> x)' vs. `show (\y -> y)'
03:42:48 <quicksilver> erm f and id . f
03:43:07 <MyCatVerbs> quicksilver: ahhhh. Hrmn, yeah, problematic.
03:43:23 <slava> then use monads or whatever ;)
03:43:27 <quicksilver> it kind of doesn't matter.
03:43:28 <quicksilver> in a sense.
03:43:33 <quicksilver> but it's somethign to be aware of .
03:43:43 <quicksilver> it doesn't matter if it's "only for debugging" or some such.
03:44:20 <dolio> Having show require the IO monad would be absolutely wonderful.
03:44:32 <ski_> (slava : i'm suspecting maybe a comonad ..)
03:44:49 <ski_> dolio : `require' ?
03:46:17 <quicksilver> 13
03:46:20 <EvilTerran> class Reify a where reify :: a -> IO String --?
03:49:29 <EvilTerran> you could have a default instance for show-able types, and compiler support for, eg, functions
03:49:52 <mxc> how do you convert and int to a double?
03:50:01 <mxc> newbie question alert
03:50:07 <sieni> fromIntegral
03:50:10 <EvilTerran> ?type fromIntegral
03:50:10 <MyCatVerbs> mxc: fromIntegral.
03:50:12 <lambdabot> forall a b. (Num b, Integral a) => a -> b
03:50:20 <mxc> ty
03:50:21 <MyCatVerbs> mxc: we like newbie questions, they don't usually take half an hour to answer. ;)
03:50:42 <EvilTerran> ?type realToFrac -- this is the other very general numeric casting function
03:50:45 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
03:52:14 <quicksilver> @quote when.you.need
03:52:14 <lambdabot> No quotes match. The more you drive -- the dumber you get.
03:52:18 * quicksilver sighs
03:52:30 <quicksilver> Cale: it makes me sad that LB loses its quote DB so often.
03:52:38 <MyCatVerbs> @quote quicksilver
03:52:38 <lambdabot> quicksilver says: learning from other people's mistakes is so web 1.0
03:52:47 <dolio> @quote gonna.call
03:52:47 <lambdabot> No quotes match. My mind is going. I can feel it.
03:52:49 <MyCatVerbs> quicksilver: Not *that* often. :)
03:52:52 <MyCatVerbs> @quote menorah
03:52:52 <lambdabot> No quotes match. Maybe you made a typo?
03:53:02 <MyCatVerbs> Oh, damn. Lost that one.
03:53:05 <MyCatVerbs> @quote dons
03:53:05 <lambdabot> dons says: The "I'm swallowing TaPL smiley" :[]
03:53:16 <dolio> @qutoe do.you.call
03:53:16 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
03:53:33 <MyCatVerbs> Heheheh, sweet.
03:53:55 <MyCatVerbs> Don't cross lazy streams. Bad things will happen. ;)
03:54:04 <idnar> @quote
03:54:04 <lambdabot> JaffaCake says: I don't remember a recruitment process where the interviewees all talk to each other before, it's kind of scary :)
03:54:32 <quicksilver> dolio: Ah. It was obviously quicksilver whose quote DB was at fault that time.
03:54:49 <MyCatVerbs> @quote lambdabot
03:54:49 <lambdabot> lambdabot says: I know nothing about love.
03:55:14 <dolio> Nah. It's monochrom's fault for not quoting from the Ghostbusters song strictly enough. :)
03:55:59 <opqdonut> @quote tapl
03:55:59 <lambdabot> dons says: The "I'm swallowing TaPL smiley" :[]
03:56:14 <EvilTerran> (:[ {-OM NOM NOM-} ])
03:57:05 <equanimity> EvilTerran: eh?
03:57:22 <EvilTerran> oh, hello
03:57:52 <paolino> @djinn [Maybe a] -> Bool
03:57:52 <lambdabot> f _ = False
03:58:03 <opqdonut> hmm, loaned my TaPL to some mathematician
03:58:07 <opqdonut> still hasn't returned it
03:58:10 <dolio> Heh.
03:58:14 <EvilTerran> that's cheating!
03:58:40 <opqdonut> @djinn [Maybe a] -> Maybe a
03:58:40 <lambdabot> f _ = Nothing
03:58:44 <opqdonut> heh
03:58:46 <EvilTerran> f [] = False; f (Nothing:_) = True; f (Just _:_) = False -- that's better
03:59:16 <dolio> djinn doesn't know about lists.
03:59:40 <EvilTerran> ah yes
04:00:25 <yitz> f = isJust . msum
04:00:39 <yitz> @type isJust . msum
04:00:41 <lambdabot> forall a. [Maybe a] -> Bool
04:01:15 <paolino> @src msum
04:01:16 <lambdabot> msum =  foldr mplus mzero
04:01:48 <yitz> @type isJust . foldr (>>) Nothing
04:01:50 <lambdabot> forall a. [Maybe a] -> Bool
04:01:58 <paolino> @src Maybe mplus
04:01:59 <lambdabot> Nothing `mplus` ys = ys
04:01:59 <lambdabot> xs      `mplus` ys = xs
04:03:00 <yitz> in short, it looks like djinn could use a little more magic lantern smoke.
04:03:58 <yitz> @djinn [a] -> Maybe a
04:03:59 <lambdabot> f _ = Nothing
04:04:03 <yitz> ha!
04:04:13 <yitz> @type listToMaybe
04:04:16 <lambdabot> forall a. [a] -> Maybe a
04:04:54 <paolino> >  msum  [Nothing ,Just 1]
04:04:57 <lambdabot>  Just 1
04:06:48 <paolino> what is the use of this msum, ignoring last Nothings ?
04:07:00 <yitz> @type msum
04:07:03 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
04:07:38 <yitz> paolino: it's general, for any MonadPlus. For Maybe, msum is the same as pattern matching: pick the first one that matches.
04:08:28 <paolino> right
04:08:56 <pjd_> > msum ["foo","","bar"]
04:08:58 <lambdabot>  "foobar"
04:10:54 <pjd_> paolino: there's also the slightly more general mconcat
04:10:58 <pjd_> :t mconcat
04:10:59 <lambdabot> forall a. (Monoid a) => [a] -> a
04:12:21 <paolino> @src Monoid
04:12:22 <lambdabot> class Monoid a where
04:12:22 <lambdabot>     mempty  :: a
04:12:22 <lambdabot>     mappend :: a -> a -> a
04:12:22 <lambdabot>     mconcat :: [a] -> a
04:13:01 <pjd_> paolino: roughly speaking, Monad + Monoid gives you MonadPlus
04:14:32 <paolino> @src MonadPlus
04:14:33 <lambdabot> Source not found. Just try something else.
04:16:43 <paolino> mmhh Monoid is enough to rule out Java interfaces
04:16:51 <paolino> [a] -> a
04:17:28 <pjd_> paolino: many things are :)
04:17:41 <pjd_> paolino: are you familiar with monoid concept from abstract algebra?
04:17:46 <paolino> subject oriented programming
04:17:52 <paolino> not really
04:18:32 <pjd_> paolino: it's one of the more general constructs
04:19:21 <paolino> I suppose it's naturals with (+) and 0
04:19:31 <paolino> or (*) and 1
04:19:33 <yitz> paolino: right!
04:19:44 <pjd_> yep
04:19:47 <yitz> Monad is like a group, MonadPlus is like a ring
04:19:52 <pjd_> any associative binary operator with an identity forms a monoid
04:20:05 <paolino> mconcat ?
04:20:57 <pjd_> paolino: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html has many examples of Monoids in Haskell
04:21:01 <lambdabot> http://tinyurl.com/y5qk9n
04:21:49 <pjd_> e.g. + and * are Sum and Product
04:23:09 <pjd_> there are also All and Any, for && / True and || / False
04:25:22 <pjd_> even functions form a monoid, when they're from and to the same type
04:25:27 <pjd_> that is, (a -> a)
04:25:37 <paolino> >mappend (Sum 1) (Sum 2)
04:25:48 <paolino> > mappend (Sum 1) (Sum 2)
04:25:50 <quicksilver> yitz: well "Monad is to MonadPlus as group is to ring", perhaps.
04:25:50 <lambdabot>  Sum {getSum = 3}
04:26:10 <quicksilver> but MonadPlusses don't satisfy the ring laws.
04:26:24 <yitz> quicksilver: yeah.
04:27:03 <pjd_> > getSum $ mconcat $ map Sum [1..5]
04:27:04 <lambdabot>  15
04:27:12 <pjd_> > getProduct $ mconcat $ map Product [1..5]
04:27:14 <lambdabot>  120
04:27:48 <pjd_> paolino: those are newtypes, by the way, so they have no run-time overhead
04:28:05 <byorgey> > appEndo . mconcat . map Endo [(+1), (*6), (sqrt)] $ 2
04:28:06 <lambdabot>  Couldn't match expected type `[Endo a]'
04:28:06 <yitz> quicksilver: the analogue of the distributive law is not required, but it is satisfied in most (all?) common instances. Perhaps it should be a law.
04:28:31 <paolino> > getProduct (mzero $  Product undefined) == 1
04:28:32 <lambdabot>        add an instance declaration for (MonadPlus ((->) (Product a)))
04:28:44 <byorgey> > (appEndo . mconcat $ map Endo [(+1), (*6), (sqrt)]) $ 2
04:28:45 <lambdabot>  9.485281374238571
04:29:13 <paolino> > getProduct (mempty  $  Product undefined) == 1
04:29:15 <lambdabot>  True
04:31:54 <paolino> > execWriter (tell (Product 2) >> tell (Product 2))
04:32:04 <lambdabot>  Product {getProduct = 4}
04:32:46 <pastorn> @hoogle fix
04:32:46 <lambdabot> Data.Function.fix :: (a -> a) -> a
04:32:46 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
04:32:46 <lambdabot> Control.Monad.Fix :: module
04:33:56 <pastorn> @src fix
04:33:56 <lambdabot> fix f = let x = f x in x
04:34:08 <popcorn> fix f = f (fix f)
04:36:05 <yitz> http://en.wikibooks.org/wiki/Haskell/MonadPlus#Relationship_with_Monoids
04:36:06 <lambdabot> http://tinyurl.com/ywaoj4
04:36:51 <quicksilver> yitz: yeah, I know ;)
04:37:14 <quicksilver> yitz: also http://www.haskell.org/haskellwiki/MonadPlus
04:37:15 <lambdabot> Title: MonadPlus - HaskellWiki
04:38:03 <yitz> quicksilver: yeah, talks about the distributive law there.
04:47:47 <dblhelix> any template-haskell gurus in the house? is it correct that TH does not have support for associates types en associated type synonyms yet? (I would be surprised if I just overlooked it, but you never know...)
04:48:13 <dolio> Associated types are pretty new.
04:48:25 <dolio> I doubt they've added them to TH yet.
04:48:48 <dolio> The underlying machinery isn't even fully developed in 6.8.2.
04:48:56 <quicksilver> associated types are so new they aren't even finished.
04:49:01 <quicksilver> they're new like tomorrow's dawn :)
04:49:38 <dblhelix> quicksilver: and, you see, I am already bored writing them by hand ;-)
04:49:56 <quicksilver> which seems to indicate that something is wrong, really.
04:50:22 <popcorn> if you have map unit and join, what's bind and return ?
04:50:24 <quicksilver> "dblhelix is so blaze he's already bored by tomorrow's dawn" ?
04:50:34 <quicksilver> popcorn: return is unit.
04:50:37 <quicksilver> (that's the easy on!)
04:51:09 <dolio> bind is join . map, for some sufficiently arity-preserving .
04:51:32 <popcorn> ?djinn ((a -> b) -> m a -> m b, a -> m a, m (m a) -> m a) -> (a -> m a, m a -> (a -> m b) -> m b)
04:51:33 <lambdabot> -- f cannot be realized.
04:51:33 <quicksilver> bind :: m a -> (a -> m b) -> m b is given by bind ma fmb = join ((map fmb) ma)
04:51:37 <dolio> And possibly some flipping.
04:52:02 <quicksilver> popcorn: i.e., you use "map" to lift fmb up to (m a -> m m b), then you apply it to ma, and get m m b, which you join.
04:52:04 <popcorn> ?djinn ((a -> b) -> ma -> mb, a -> ma, mma -> ma -> (a -> ma, ma -> (a -> mb) -> mb)
04:52:04 <lambdabot> Cannot parse command
04:52:20 <popcorn> ok
04:57:38 <dolio> @djinn ((a -> mb) -> ma -> mmb) -> (mmb -> mb) -> (ma -> (a -> mb) -> mb)
04:57:38 <lambdabot> f a b c d = b (a d c)
04:58:53 <dblhelix> mmm... that suggest a small addition to djinn...
05:01:16 <dblhelix> what about @djinn (fmap :: (a -> mb) -> ma -> mmb) -> (join :: mmb -> mb) -> ma -> (a -> mb) -> mb)?
05:01:34 <dblhelix> less readable input, more readable output...
05:01:45 <dolio> Oh, I thought you were going to suggest higher-kinded type variables. :)
05:01:53 <popcorn> djinn 2 is well due :P
05:02:10 <popcorn> hmm http://www.uni-koblenz.de/~beckert/leantap/
05:02:11 <lambdabot> Title: The leanTAP Home Page
05:02:50 <dolio> I'm not enough of an expert to know how fancy you can get before you run into undecidability.
05:04:28 <popcorn> cool
05:05:00 <dolio> type classes were a fairly recent addition.
05:05:44 <dolio> Although, a lot of classes aren't very interesting with how it works.
05:06:20 <popcorn> hmm
05:06:28 <popcorn> is Coqs eauto a decision procedure?
05:06:46 <popcorn> (It can prove bind/return <-> map/unit/join http://rafb.net/p/9LRHEK59.txt )
05:06:57 <dolio> I don't know much about Coq.
05:08:34 * popcorn wonders if they a -> m a thing could be used like that regex prime checker
05:10:24 <popcorn> (m (m a) -> a) -> (m (m (m (m a)))) -> a
05:10:40 <popcorn> in only inhabited because 4 divisible by 2
05:11:16 <popcorn> is it possible to something like that which is only inhabited when the number of m's is prime (or isnt)?
05:12:51 <pastorn> with ":set +s", what is the "XXXXXX bytes" i see?
05:15:31 <popcorn>     +s            print timing/memory stats after each evaluation
05:15:35 <popcorn> it's memory stats :P
05:15:44 <yitz> popcorn: sorry, I wasn't following, are there any conditions on m and a?
05:16:10 <popcorn> yitz: no I don't think so
05:17:08 <popcorn> this is absolutely great http://citeseer.ist.psu.edu/seres99algebra.html
05:17:09 <lambdabot> Title: Algebra of Logic Programming - Seres, Spivey, Hoare (ResearchIndex)
05:17:34 <Saul__> I'm having a bit of a problem with this vector/matrix library I'm building
05:17:51 <Saul__> http://hpaste.org/7455 if I try v1 + v2, I get an error message
05:19:03 <Saul__> it says that instance (Num a) => Plus a and instance (Plus a, Plus (Vector n a)) => Plus (Vector (Succ n) a) both match (so it's an overlapping instances problem)
05:19:13 <Saul__> But I don't see how the former is a match
05:19:24 <Saul__> Can anyone explain?
05:19:33 <mauke> Plus a matches anything
05:19:37 <mauke> how is it not a match?
05:19:53 <sek> if i had a very trivial (mainly definition-involving) question about algorithm time, would I be frowned upon for posting it in here?
05:20:01 <opqdonut> Saul__: err, where is zipWith defined?
05:20:32 <popcorn> sek: there's always ##algorithms
05:20:39 <sek> popcorn, thanks
05:20:54 <Saul__> opqdonut: Sorry, I pasted foldl instead of zipWith
05:21:24 <opqdonut> seems odd that you're "inductively" deriving the class
05:21:32 <quicksilver> Saul__: instance (Num a) => Plus a says the following
05:21:33 <opqdonut> but then you use noninductive definitions for the functions
05:21:40 <quicksilver> ALL TYPES a are a member of class Plus
05:21:47 <quicksilver> (but please add a Num constraint)
05:21:58 <quicksilver> so, that overlaps with every other instance you might write.
05:22:21 <Saul__> ok
05:22:31 <Saul__> Is there any way to make what I intend to do
05:22:50 <quicksilver> instance (Num a) => Plus (WrappedNum a)
05:22:54 <quicksilver> is the standard way
05:23:13 <quicksilver> which is a bit messy but makes your intentions clear to the typechecker
05:23:29 <quicksilver> alternative you turn on overlapping and undecidable instances
05:23:37 <quicksilver> and then I can't help you, because I don't understand the semantics of that case.
05:24:18 <dolio> Or wait until 6.10 and use sexy total type families.
05:24:39 <dolio> With overlapping with, presumably, decent semantics.
05:25:20 <dolio> Or, I suppose that assumes it extends to classes. It might not.
05:25:22 <Saul__> The weird thing is that the instance are actually disjoint, only not the way haskell checks it
05:25:48 <Saul__> instances*
05:26:53 <quicksilver> Saul__: actually, they aren't.
05:27:01 <quicksilver> you might define a num instance for Vector n a
05:27:06 <quicksilver> then they both apply
05:27:07 <Saul__> It's so annoying when you know that something is computable/decidable but the language your working in doesn't
05:27:14 <Saul__> Yes but I didn't
05:27:24 <quicksilver> Saul__: but I might do it. Now.
05:27:27 <quicksilver> In fact, I just have.
05:27:30 <quicksilver> now your code is broken.
05:27:33 <opqdonut> :D
05:27:38 <popcorn> hehe
05:27:39 <quicksilver> all because someone thousands of miles away defines an instance.
05:27:50 <quicksilver> the point is that instances are global and non-local.
05:27:50 <dolio> Actually, his code isn't broken.
05:27:54 <dolio> Unless it imports your module.
05:28:03 <dolio> Yours might be, though. :)
05:28:12 <Saul__> I get that, but people might also create a new instance of Plus, giving the same problems
05:28:36 <popcorn> btw Num is a good name?
05:28:43 <quicksilver> You can never be sure that someone doesn't define a new instance somewhere else.
05:28:49 <popcorn> not Vector/InnerProductSpace or somesuch
05:28:56 <quicksilver> that's the open type class problem.
05:28:59 <popcorn> I mean is Plus a good name?
05:29:58 <Saul__> but why is the possibility of a new instance of Plus that breaks things okay, but the same thing for Num isn't?
05:30:09 <Saul__> popcorn: Probably not
05:31:16 <Saul__> popcorn: It's actually quite annoying to use, since you need to write negate 1 instead of -1 (since the latter is rewritten to Prelude.negate 1)
05:31:48 <SamB_XP> the only way to make sure all instances satisfy the laws is to (a) use a total language and (b) add the laws as methods
05:31:52 <ddarius> -fno-implicit-prelude
05:32:27 <Saul__> ddarius: Does that fix that though?
05:32:44 <ddarius> It should lead to those sort of things being unqualified.
05:32:53 <SamB_XP> or rather, the laws would be the types of the methods
05:33:16 <SamB_XP> the methods would be the proofs ;-)
05:33:50 <popcorn> > 0 - 7
05:33:52 <lambdabot>  -7
05:33:59 <popcorn> just write 0 - x instead of negate x ?
05:34:19 <popcorn> well I prefer negate actually
05:34:23 <popcorn> (negative infact)
05:34:59 <quicksilver> Saul__: what do you mean about a new instance of Num breaking things being OK?
05:35:19 <quicksilver> it's just that the typeclass resolution mechanism doesn't take constraints into account.
05:35:28 <quicksilver> it's not really a case of "why doesn't it work like this"
05:35:34 <quicksilver> it would be a major rework of typeclass inference.
05:35:46 <Saul__> No it wouldn't
05:36:24 <mauke> WELL VOLUNTEERED
05:36:36 <popcorn> lol
05:36:50 <Saul__> You get a list of matching instances, you check their constraints and those that pass the constraint check are left
05:36:58 <quicksilver> Saul__: Yes. It would be a major change.
05:37:14 <Saul__> if that is more than one, there are overlapping instances
05:37:25 <popcorn> using CHR/CLP to solve which function to use?
05:37:26 <quicksilver> There are a couple of emails from (I think) SPJ, explaining the problems you get.
05:37:29 <popcorn> from typeclasses
05:37:47 <quicksilver> Saul__: you get some version of that algorithm by turning on undecidable/incoherent/overlapping instances
05:38:04 <Saul__> ok
05:38:18 <popcorn> why not redesign the class system
05:39:17 <Saul__> turning on overlapping instances did the trick btw
05:39:24 <quicksilver> there are details of the algorithm GHC uses in the GHC docs.
05:39:56 <quicksilver> it doesn't document the shortcomings as far as I can see
05:40:01 <quicksilver> and sadly I can't remember what they were.
05:42:09 <Saul__> quicksilver: Well thanks for your help and explanation
05:43:22 <quicksilver> a little googling fails ti find the message from SPJ I was thinking of
05:43:25 <quicksilver> or maybe it wasn't from him :)
05:43:38 <quicksilver> it's a reasonably Frequently Asked Q
05:47:21 <araujo> morning
05:47:54 <matthew_-> nah, it's mid afternoon
05:48:03 <ivanm> evening, actually
05:48:05 <matthew_-> time for a post-lunch nap
05:48:23 <ivanm> you have time for a nap? you lucky, lucky bastard!
05:48:31 * ivanm has to suffice with sleeping through lectures ;-)
05:48:37 <matthew_-> PhD procrastination takes many forms
05:48:57 <matthew_-> sleeping is one of the more obviously enjoyable ones!
05:50:11 <popcorn> this is confusing
05:50:20 <matthew_-> then have a nap
05:50:22 <ivanm> no, this is life
05:50:23 <ivanm> lol
05:50:24 <matthew_-> it'll make more sense
05:50:27 <ivanm> @localtime popcorn
05:50:28 <lambdabot> Local time for popcorn is Wed May  7 13:50:27
05:50:38 <quicksilver> my favourite was writing other people's phds.
05:50:43 <osfameron> every time is popcorn time
05:50:56 <ivanm> heh
05:51:16 <profmakx> yeah i enjoyed representation theory while i wrote my diploma thesis
05:51:17 <ivanm> @remember osfameron <ivanm> @localtime popcorn <osfameron> every time is popcorn time
05:51:17 <lambdabot> Good to know.
05:51:24 <profmakx> and learning haskell...
05:51:37 <popcorn> you can make a monad transformer stack with multiple StateTs in it right?
05:51:57 <matthew_-> @faq you can make a monad transformer stack with multiple StateTs in it right?
05:51:57 <lambdabot> The answer is: Yes! Haskell can do that.
05:52:04 <popcorn> ok thank :)
05:52:09 <popcorn> so is this wise:
05:52:33 <Deewiant> @unmtl StateT (StateT a b c) d e
05:52:34 <lambdabot> (a -> b (c, a)) -> d (e, a -> b (c, a))
05:52:39 <popcorn> Write a monad transformer which is basically StateT except it creates/handles fresh logic variables
05:52:42 <SamB> popcorn: I would suggest not explicitly making stacks like that
05:53:01 <popcorn> then I can tack it onto like Identity or IO or whatever, and tack LogicT onto all that
05:53:18 <SamB> but stacks that end up being implemented that way are totally fine
05:53:33 <popcorn> ok
05:53:41 <popcorn> one thing still doesn't make sense though
05:54:00 <popcorn> if I have a stack like: LogicT (StateT (Identity))
05:54:03 <popcorn> err
05:54:11 <popcorn> LogicT (LogicVarsT (Identity))
05:54:12 <ToRA> > flip execStateT True . flip execStateT "hello" $ modify not >> modify tail
05:54:13 <lambdabot>          let
05:54:13 <lambdabot>           bjm = flip execStateT True . flip execStateT "hello"
05:54:13 <lambdabot>  ...
05:54:28 <ToRA> eh
05:54:28 <popcorn> how can LogicVarsT tell LogicT to fail :/
05:54:51 <popcorn> I have to implement unify in logicT using primitives from LogicVarsT instead?
05:55:02 <SamB> eh?
05:55:08 <popcorn> (and also hopefully think of a better name for it)
05:55:10 <SamB> tell it to fail?
05:55:26 <popcorn> well it's a MonadPlus
05:55:37 <popcorn> or I guess something is a MonadPlus, maybe the entire stack is
05:56:36 <Saizan> > runStateT (fail "FAIL" :: StateT () (Either String) ()) ()
05:56:38 <lambdabot>  Left "FAIL"
05:56:57 <ToRA> > fromJust . flip runStateT True . flip execStateT "hello" $ lift (modify not) >> modify tail
05:56:58 <lambdabot>  ("ello",False)
05:57:31 <Saizan> > runStateT (lift (fail "FAIL" :: Either String ())) ()
05:57:33 <lambdabot>  Left "FAIL"
05:57:51 <popcorn> oh I see
05:58:20 <popcorn> I thought lift worked the other way around :S
05:59:04 <Saizan> @unmtl StateT Int (Either String) ()
05:59:04 <lambdabot> Int -> Either String ((), Int)
06:02:53 <popcorn> :t maximumBy(compare`on`fst)
06:03:08 <lambdabot> thread killed
06:05:23 <yitz> :t maximumBy(compare`on`fst)
06:05:26 <lambdabot> forall a b. (Ord a) => [(a, b)] -> (a, b)
06:05:45 <ivanm> popcorn: I don't think lambdabot likes you... :p
06:05:51 <popcorn> I know :(
06:06:15 <popcorn> :t lookupFM
06:06:16 <yitz> @vixen do you like popcorn?
06:06:17 <lambdabot> Not in scope: `lookupFM'
06:06:17 <lambdabot> yah, i like
06:06:23 <popcorn> lol
06:06:25 <yitz> ivanm: wrong
06:07:03 <ivanm> yitz: no, that was just lambdabot's "vixen" persona (lb has a case of MPD, and I don't mean the music daemon :p )
06:07:39 <popcorn> lookupFM = flip Map.lookup
06:07:39 <popcorn> emptyFM = Map.empty
06:07:39 <popcorn> addToFM m k e = Map.insert k e m
06:07:49 <popcorn> why not just have that stuff
06:07:52 <popcorn> in Data.FiniteMap
06:07:58 <yitz> popcorn: that was the old interface
06:08:32 <yitz> ah, for backwards compat. yeah.
06:08:49 <yitz> you can upload that to hackage.
06:10:31 <ToRA> @type maximumBy (comparing fst)
06:10:34 <lambdabot> forall a b. (Ord a) => [(a, b)] -> (a, b)
06:17:08 <popcorn> oh
06:17:17 <popcorn> It's impossible to implement unitFM :: key -> elt -> FiniteMap key elt
06:17:29 <popcorn> since you have to have an Ord constraint on key in Data.Map
06:18:14 * edwardk waves hello
06:18:30 <popcorn> hi
06:18:31 <yitz> popcorn: it would be rare to use it that way anyway.
06:19:21 <yitz> so if you provide it with the constraint, it will still provide bkwd. compat. in practice
06:20:08 <Saizan> popcorn: why are you reimplementing FiniteMap with Map?
06:20:46 <popcorn> I'm not just wanted to run this code
06:20:58 <popcorn> those 3 lines were all I neded
06:21:11 <Saizan> oh
06:21:17 <Saizan> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FiniteMap-0.1 --however
06:21:19 <lambdabot> http://tinyurl.com/2j3ho6
06:22:03 <popcorn> you know Typed Logical Variables in Haskell , it would make sense as a transformer rather than a monad wouldn't it?
06:39:03 <edwardk> has anyone here read http://web.engr.oregonstate.edu/~erwig/papers/RandomAccessADT_REPORT.pdf and have any opinion on the exomorphism/synchromorphism mentioned therein?
06:39:05 <lambdabot> http://tinyurl.com/566j57
06:39:59 <edwardk> i'm thinking about adding them into Control.Morphism.* to flesh out the zoo
06:43:18 <dejones> @seen dons
06:43:18 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 6h 50m 48s ago.
06:55:35 <edwardk> hrmm it appears an exomorphism is just a less general hylomorphism somewhat obscured
06:56:04 <quicksilver> obscuromorphism
06:56:06 <edwardk> exo :: Functor h => (m c -> c) -> (h c -> m c) -> (h a -> h (g a)) -> (g a -> h a) -> g a -> c; exo phi f g a = let h = phi . f . fmap h . g . a in h
06:56:35 <edwardk> if you merge phi and f and g and a you get a hylomorphism from g a -> c
06:56:46 <mauke> cryptomorphism
06:56:57 <edwardk> synchro still seems to be distinct from the other recursion patterns to me
06:57:15 <quicksilver> steganomorphism
06:57:41 <edwardk> i guess the part that makes it useful is that phi and a are sort of predetermined by the kind of container you are going from/to
06:57:55 <edwardk> but it still seems like an exercise in mental masturbation
07:00:08 <TomMD> @seen dons
07:00:08 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 7h 7m 37s ago.
07:01:23 <edwardk> i guess i am curious to see what interesting bi/tri-algebras you can use to describe data structures that would make the exo/syncho stuff less painful to use as a building block
07:02:22 <edwardk> but i think when even i am wondering "where the heck can i use this?" i'm probably barking up the wrong tree =)
07:11:58 <ilyak> How is Data.Map.lookup implemented
07:12:20 <ilyak> Is it using some black magic or it can determine on what monad should it act?
07:12:28 <popcorn> ilyak: http://haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Map.html#lookup
07:12:28 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2bjwxd
07:12:56 <popcorn> it is just walking down the binary tree
07:13:52 <Saizan> ilyak: you can determine on which monad should it act, haskell has method dispatch also on the result type
07:14:01 <qwr> ilyak: probably something like if found then return foo else fail "not found"
07:14:21 <popcorn>     Just x -> return x
07:14:22 <popcorn>     Nothing -> fail "Data.Map.lookup: Key not found"
07:15:02 <opqdonut> GADTs are the "right" solution for an AST right? how would one go about implementing attribute grammars for such an AST
07:15:20 <popcorn> opqdonut: they are one right solution
07:15:24 <opqdonut> seems it requires adding new fields to the constructors ore something
07:15:36 <opqdonut> s/ore/or/
07:15:44 <opqdonut> which strikes me as inelegant
07:17:30 <ilyak> Oh, I understand
07:17:37 <ilyak> It's really cool.
07:22:13 <Bonus> how are pairs implemented as an instance of Ord
07:22:21 <Bonus> or tuples in general
07:22:27 <mauke> lexically
07:22:29 <Saizan> lexicographically
07:22:50 <MyCatVerbs> Saizan: pedantically.
07:22:50 <Bonus> ah so
07:22:57 <mauke> monoidal
07:23:05 <Bonus> (1, x) will always be smaller than (2,x)
07:23:18 <MyCatVerbs> Yesh.
07:23:31 <Bonus> kewl
07:23:43 <MyCatVerbs> Unless you've created a type with Num interface and a backwards Ord interface, just for kicks.
07:24:03 <opqdonut> MyCatVerbs: :D
07:24:11 <MyCatVerbs> instance Ord YouWillNeverTakeMeAlive where (Villany a) > (Villany b) = b > a
07:24:28 <MyCatVerbs> Er, instance, not interface.
07:24:29 <orbitz> what problems does first class polymorphism solve
07:24:40 <opqdonut> everything
07:24:55 <orbitz> hrm
07:24:57 <byorgey> what is 'first class polymorphism'?
07:24:59 <orbitz> could you be moer specific
07:25:05 <mauke> @pl \(a,b) (c,d) -> compare a b `mappend` compare c d
07:25:06 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip compare . (((.) . (.) . mappend) .) . compare)
07:25:26 <mauke> @pl \(a,b) (c,d) -> compare a c `mappend` compare b d
07:25:26 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. compare) . flip . (((.) . mappend) .) . compare)
07:25:53 <quicksilver> what polymorphs do first-class solutions problem?
07:26:12 <byorgey> 'flip flip snd . (ap .) . flip flip fst' would be great to use in some freestyle nerdcore
07:26:12 <quicksilver> (we're not sure what you mean by first-class polymorphism, orbitz)
07:26:33 <orbitz> hi
07:26:37 <orbitz> hi
07:26:45 <byorgey> hi?
07:26:51 <orbitz> i'm efering to
07:26:53 <orbitz> http://lambda-the-ultimate.org/node/2780
07:26:56 <lambdabot> Title: FPH: First-class Polymorphism for Haskell | Lambda the Ultimate
07:27:05 <MyCatVerbs> Hey, no one wrote a Monad instance for Data.Map?
07:27:21 <mauke> MyCatVerbs: many people have
07:27:26 <Saizan> ooh, that refers to polymorphic instantiation
07:27:41 <byorgey> MyCatVerbs: Data.Map requires an Ord instance on the data, though, so it's not entirely straightforward
07:28:00 <byorgey> but see the 'rmonad' package
07:28:51 <Saizan> orbitz: your question is best answered by reading that paper, it starts with some motivational examples
07:29:29 <ziman> is there a fancy way to drop each other element from a list? (keep, drop, keep, drop, keep, ..)
07:29:38 <MyCatVerbs> byorgey: only on the keys, though.
07:29:55 <quicksilver> ziman: map (take 1) . iterate (drop 2) $ l
07:29:58 <byorgey> MyCatVerbs: oh, right.
07:30:03 <MyCatVerbs> mauke: I'm just wonderin' why there isn't one in the standard library by default.
07:30:15 <quicksilver> ziman: or map head . takeWhile (not.null) . iterate (drop 2) $ l
07:30:16 <MyCatVerbs> byorgey: it's Data.Set that requires Ord keys.
07:30:23 <byorgey> MyCatVerbs: right.
07:31:00 <ziman> quicksilver, thanks
07:31:16 <byorgey> or map snd . filter fst . zip (cycle [True, False]) $ l
07:31:45 <popcorn> anyone got the source code for/based from Type Logical Variables in Haskell?
07:32:04 <popcorn> (I just typed it out but it doesn't work :/)
07:32:08 <Saizan> MyCatVerbs: with which join?
07:32:21 <pejo> +
07:32:23 <pejo> Ups, sorry.
07:32:26 <mm_freak_work> when is it more appropriate to use data instead of newtype?
07:32:47 <Saizan> when you can't use newtype?
07:32:56 <MyCatVerbs> Saizan: union. What else?
07:33:04 <Zao> mm_freak_work: When you just want to make a friendly alias.
07:33:08 <Saizan> ?type Data.Map.union
07:33:09 <Zao> cf. typedef in C++.
07:33:10 <lambdabot> forall k a. (Ord k) => M.Map k a -> M.Map k a -> M.Map k a
07:33:31 <Saizan> MyCatVerbs: join :: Map k (Map k a) -> Map k a
07:33:32 <mm_freak_work> when is that?  as far as i have understood, the only difference is that data types are boxed, whereas newtype types inherit boxing
07:33:58 <Igloo> You can only use newtype when you have exactly 1 constructor with exactly 1 argument
07:34:01 <mauke> MyCatVerbs: oh wait, I was wrong
07:34:09 <orbitz> mauke: you jerk
07:34:41 <mauke> return :: v -> Map k v?
07:35:20 <MyCatVerbs> mauke: oh, eck.
07:35:34 <Saizan> mm_freak_work: to write data Tree a = Leaf a | Branch (Tree a) (Tree a) as newtype you need newtype Tree a = Tree (Either a (Tree a,Tree a)), which might be less nice to use.
07:35:41 <MyCatVerbs> Saizan: (>>= id) :P
07:36:20 <mm_freak_work> ah  i didn't know that newtype really can only make alias types
07:36:27 <trez> @src (=<<)
07:36:27 <lambdabot> f =<< x = x >>= f
07:36:28 <Saizan> MyCatVerbs: then how do you implement >>= :) the question is more "how do you combine the keys from the outer map with the ones of the inner maps"?
07:36:30 <mm_freak_work>     The constructor of a newtype must have exactly one field
07:36:31 <mm_freak_work>       but `Probably' has two
07:36:47 <mm_freak_work> ok, question answered, thanks =)
07:37:12 <MyCatVerbs> Saizan: yeah, that's broken. Nevermind.
07:38:35 <roderyk> I'm back with my Readline questions. I've figured out the issue is with the Readline.getKey utility. Runs fine in ghci, because the terminal has been correctly initialized. If I compile my code, getKey segfaults the code. If I first Readline.initialize in the main loop, it does work BUT waits for key and carriage return (so it's useless to me). Anyone have experience with initializing readline to work (not exactly a lot of documentation)?
07:38:47 <Saizan> one could require a Monoid contraint on the keys..
07:40:55 <Saizan> roderyk: Readline.getKey doesn't wait for carriage return in ghci?
07:41:55 <roderyk> Saizan: correct, it automatically returns IO Char
07:42:44 <mm_freak_work> data Probably a = forall f. Floating f => Probably f a   -- is my thinking correct?  it should be a monad, which _probably_ contains a value
07:43:50 <Saizan> mm_freak_work: you'll have problems on performing operations on that f when you take it out
07:44:26 <mm_freak_work> Saizan: f will never leave the monad  it should be opaque
07:44:48 <byorgey> mm_freak_work: why not just  data Probably f a = Probably f a, and then instance (Floating f) => Monad (Probably f) ?
07:45:04 <byorgey> that seems simpler to me
07:45:45 <mm_freak_work> byorgey: because i'm gonna make sure that differing Floating types will work well together
07:46:03 <mm_freak_work> i want to be able to mix them
07:46:15 <geezusfreeek> okay that just sounds like asking for trouble there
07:46:28 <byorgey> well, that makes sense, but I'm not sure why you'd want to be able to mix different Floating types
07:46:37 <pejo> roderyk, it sounds like your terminal is set to buffer input
07:46:55 <mm_freak_work> because in some places, performance is important, in others precision
07:47:02 <geezusfreeek> you could write explicit converters, say Probably Double a -> Probably Float a, etc., and that wouldn't be as bad, but intermixing just sounds like a mess
07:47:13 <mm_freak_work> it's not a type i'm gonna work with seriously  i'm just experimenting, so don't worry =)
07:47:20 <byorgey> mm_freak_work: you know, you are still going to have a lot of trouble mixing Floating types even with the forall
07:47:30 <geezusfreeek> yeah the forall hides the type
07:47:40 <byorgey> mm_freak_work: because if you have two values of type Probably a,  the compiler doesn't know whether they have the *same* Floating types
07:47:50 <byorgey> so if you try to combine the f values the type checker will complain
07:48:04 <roderyk> pejo: can I reset it somehow programmatically? I'm curious how ghci does it - should this really be this complicated?
07:48:15 <byorgey> it will probably say something like 'can't match expected type f with inferred type f1'
07:48:29 <byorgey> someone correct me if I am wrong her...
07:48:31 <byorgey> *here
07:48:52 <geezusfreeek> he could do something like data Probably a = forall f. Floating f => Probably f a
07:48:55 <geezusfreeek> or something
07:48:59 <geezusfreeek> maybe his own type class
07:49:06 <byorgey> geezusfreeek: that is exactly what mm_freak_work is proposing to do.
07:49:10 <byorgey> but I don't think it will work.
07:49:31 <geezusfreeek> well, the right type class would allow him to use whatever functions are defined in the type class no matter what the type is
07:49:42 <mm_freak_work> hmm
07:49:45 <geezusfreeek> just not whatever he wants
07:49:50 <pejo> roderyk, it's "just" some initialization that is missing. You would probably have the same problem with the same thing in plain C.
07:49:52 <mm_freak_work> yeah, i see just now that it will lead into problems with Floating
07:49:58 <byorgey> geezusfreeek: the problem is with combining two such values.  see what I wrote above.
07:50:03 <mm_freak_work> my idea was to use something like fromFloating
07:50:22 <geezusfreeek> byorgey: right, unless the type class has a function of type a -> Floating, or whatever
07:50:34 <mm_freak_work> ok, i'll make f a type parameter
07:50:37 <byorgey> mm_freak_work: well, yes, I guess that could work
07:50:54 <byorgey> convert everything to Double first before doing the operations
07:51:07 <byorgey> but in that case you might as well just use Double in the first place.
07:51:16 <geezusfreeek> byorgey: i think you missed the point
07:51:16 <byorgey> @type fromFloating
07:51:18 <lambdabot> Not in scope: `fromFloating'
07:51:23 <mm_freak_work> yeah
07:51:31 <mm_freak_work> but there is no universal toDouble or fromFloating
07:51:37 <byorgey> mm_freak_work: right.
07:51:50 <mm_freak_work> so i'll have to restrict it anyway =)
07:52:25 <roderyk> pejo: yep, I'm just having trouble finding out what initialization I am missing. The docs are a bit lacking...
07:52:25 <quicksilver> mm_freak_work: "in some places performance is important, in other places precision"
07:52:33 <quicksilver> mm_freak_work: fortunately, performance and precision coincide.
07:52:35 <geezusfreeek> yeah i was gonna question that too
07:52:42 <quicksilver> Double is the most precise, and the most performant.
07:52:45 <geezusfreeek> Double is the best you'll get on most architectures
07:52:52 <geezusfreeek> it is the native format
07:52:58 <quicksilver> there is a universal toDouble, by the way.
07:53:02 <quicksilver> it's called realToFrac.
07:53:08 <geezusfreeek> :t realToFrac
07:53:10 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
07:53:11 <mm_freak_work> quicksilver: in most of today's systems, yeah
07:53:22 <geezusfreeek> yup that's what i was trying to allude to!
07:53:42 <byorgey> mm_freak_work: on a separate but related point, if I were you I'd use  Fractional instead of Floating.  That way you can use Rational probabilities if you like, as well as Double or some other floating point type.
07:53:52 <ehird> i had an awesomely evil idea
07:53:56 <ehird> a haskell implementation... for the jvm
07:54:00 * ehird cackles
07:54:04 <mm_freak_work> byorgey: that won't work  i need to use functions from Floating
07:54:05 <geezusfreeek> why?!
07:54:08 <byorgey> ehird: have fun with that
07:54:12 <ehird> geezusfreeek: because it's evil
07:54:12 <quicksilver> mm_freak_work: I think you mean RealFloat, not Floating, anyway.
07:54:14 <byorgey> mm_freak_work: oh? which ones?
07:54:22 <ehird> byorgey: you think i'd torture myself like that?!
07:54:22 <ehird> hah
07:54:24 <quicksilver> mm_freak_work: Floating includes complex, which is probably not what you want :)
07:54:26 <geezusfreeek> ehird: only if you give access to the "nice" java libraries
07:54:38 <quicksilver> ehird: been done, I believe.
07:54:40 <byorgey> ehird: oh, so the evil idea is to force someone else to write it?
07:54:41 <ehird> geezusfreeek: think of how slow it'll be :-)
07:54:44 <mm_freak_work> byorgey: logarithms
07:54:47 <ehird> byorgey: no, the evil thing is the end product
07:54:50 <ehird> devil incarnate
07:54:54 <mm_freak_work> quicksilver: let me have a quick look
07:54:56 <Corun> http://www.scdi.org/~avernet/projects/jaskell/
07:54:59 <lambdabot> Title: Jaskell Project Home Page
07:55:01 <byorgey> mm_freak_work: your Monad instance for Probably needs logarithms??
07:55:08 <geezusfreeek> on a related note, does anybody think haskell would compile well to the llvm? just curious
07:55:12 <ehird> Corun: Do I really want to click that link?
07:55:14 <ehird> geezusfreeek: no
07:55:29 <ehird> Corun: 'netscape now'
07:55:32 <ehird> '1995-2003'
07:55:43 <ehird> And it's a GHC backend :-)
07:55:46 <ehird> Needs more evil
07:55:49 <ehird> And less 1996
07:55:50 <Corun> Oh, sorry
07:55:52 <Corun> :-P
07:56:10 <ehird> i dunno where they got 2003 from
07:56:13 <ehird> ' Page last modified on September 03, 2000.'
07:56:18 <mm_freak_work> byorgey: no  i'm looking whether my idea of data with slowly ceasing existence makes sense at all  and i want to do that logarithmically
07:56:21 <quicksilver> geezusfreeek: SPJ doesn't think haskell would compile well to the llvm.
07:56:22 <geezusfreeek> advance copyright?
07:56:25 <quicksilver> geezusfreeek: he said as much.
07:56:32 <ehird> mm_freak_work: I like your ellipses.
07:56:35 <geezusfreeek> quicksilver: he would know better than i, for sure
07:56:37 <Corun> http://www.cs.rit.edu/~bja8464/lambdavm/
07:56:38 <lambdabot> Title: LambdaVM - The Haskell to Java Translator
07:56:54 <quicksilver> geezusfreeek: it could be argued he has a vested interest : he thinks it should compile to C-- :)
07:56:55 <mm_freak_work> byorgey: not a serious project, just a pointless idea for further jumping into haskell =)
07:57:00 <byorgey> mm_freak_work: ah, ok =)
07:57:02 <mm_freak_work> ehird: hehe
07:57:14 <pejo> roderyk, (guessing) try set your stdin to NoBuffering
07:57:30 <mm_freak_work> byorgey: i wanted to implement a monad, something that hasn't been implemented before
07:57:31 <ehird> Corun: Not evil enough
07:57:40 <ehird> These just use ghc's stuff
07:57:47 <geezusfreeek> quicksilver: perhaps, but i've always seen spj as having a genuine enthusiasm (well, obviously) for any advancement
07:57:58 <Corun> Well, write it in bf, then :-)
07:58:02 <pejo> roderyk, (using hSetBuffer)
07:58:08 <geezusfreeek> ooh, a haskell -> bf compiler
07:58:10 <geezusfreeek> lol
07:58:17 <Corun> O_o
07:58:28 <Corun> Someone should make a llvm->bf
07:58:37 <Corun> Then lots of languages can suddenly be compiled to bf ^_^
07:58:46 <quicksilver> geezusfreeek: http://article.gmane.org/gmane.comp.lang.haskell.cafe/34496
07:58:49 <lambdabot> Title: Gmane -- Mail To News And Back Again
07:58:57 <quicksilver> geezusfreeek: (which contains links to two older messages)
07:59:16 <ehird> there's a C -> Brainfuck compiler
07:59:21 <ehird> it's nowhere near complete, but it works
07:59:33 <ehird> so -- if it was improved, massively
07:59:38 <ehird> then haskell -> brainfuck would be possible
07:59:42 <ehird> and then i'd commit suicide.
07:59:44 <geezusfreeek> "[LLVM lacks] the ability to put data next to code" yeah i remember reading that one before and realizing how big a deal that was
08:00:02 <quicksilver> geezusfreeek: it's suprising how many assumptions you make even in something low level like llvm
08:00:13 <quicksilver> geezusfreeek: they definitely had C-like languages in mind, even if they didn't think they did.
08:00:17 <geezusfreeek> ehird: i'd use my haskell brainfuck interpreter to run my haskell programs!
08:01:57 <geezusfreeek> quicksilver: yeah, i was a little afraid of something like this happening with llvm, although i had no idea in what form the problems would manifest
08:02:16 <geezusfreeek> i am pretty sure llvm supports tail calls though
08:02:31 <geezusfreeek> oh he just couldn't get it to work, n/m
08:02:38 <quicksilver> geezusfreeek: C--, although it is at a slightly different level of abstraction, takes a much more thoroughly language agnostic approach.
08:02:52 <quicksilver> arguably more hardware agnostic, too
08:02:55 <geezusfreeek> i have not even looked at C-- yet
08:03:02 * Corun ganders
08:03:14 <ehird> compiling haskell into c-- isn't exactly a new idea though ;)))
08:03:53 <mm_freak_work> quicksilver: RealFrac alone doesn't give me functions like log, sqrt and (**)
08:04:05 <mm_freak_work> but i'll just use Double
08:07:22 <roderyk> pejo: brilliant! thanks for the help :)
08:08:50 <quicksilver> mm_freak_work: yes it does
08:09:00 <quicksilver> mm_freak_work: because RealFloat is a subclass of Floating.
08:09:07 <quicksilver> mm_freak_work: so you get all that jazz for free.
08:10:58 <quicksilver> (and the RealFrac jazz)
08:12:53 <ehird> jazzy jazz
08:13:34 <geezusfreeek> hmm, based on this mailing list thread i'd say spj might actually be a bit biased against llvm since it appears his main complaints about it are lack of lower-level control, which i say is kind of the point of llvm
08:14:26 <geezusfreeek> (not that i would want to take on the task of making a haskell->llvm compiler though!)
08:17:13 <geezusfreeek> i guess it would be a bit easier to just do haskell->C and C->llvm
08:17:33 <mm_freak_work> quicksilver: ah, ok
08:19:46 <dcoutts_> geezusfreeek: though ghc doesn't really produce C
08:20:01 <geezusfreeek> yeah, well yeah
08:20:04 <dcoutts_> and not just because it generated C with lots of extensions
08:20:37 <geezusfreeek> hmm, jhc produces C though
08:20:45 <dcoutts_> but because even that isn't enough to represent all the things ghc needs, so it then post-processes the gcc assembler to get tail calls and tables next to code
08:21:48 <Igloo> Unregisterised compilers do just produce C
08:22:09 <dcoutts_> at the cost of ~2x performance
08:22:11 <Igloo> Right
08:22:17 <dcoutts_> geezusfreeek: true, though afaik jhc doesn't use GC, at least not accurate GC, so it does not have to track pointers in the stack
08:22:24 <geezusfreeek> right
08:23:07 <geezusfreeek> it uses region inference for most of it
08:23:16 <geezusfreeek> iirc, it leaks a bit though
08:25:14 <geezusfreeek> good grief! i can't believe people complain about how slow ghc is. g++ is waaaay worse
08:25:33 * Zao throws some deep template magic at geezusfreeek 
08:25:41 <geezusfreeek> ouch!
08:31:11 <Beelsebob> @hoogle [Maybe a] -> [a]
08:31:12 <lambdabot> Data.Maybe.catMaybes :: [Maybe a] -> [a]
08:32:09 <popcorn> Prelude Data.Maybe> Data.Maybe.<tab>
08:32:11 <popcorn> is useful too
08:32:53 <Bonus> Maybe should be called Schrodinger
08:39:04 <mm_freak_work> Bonus: my Probably type above would be more appropriate =)
08:39:18 <mm_freak_work> data Probably a = Probably Double a
08:39:43 <mm_freak_work> though then, we'd also need probabilistic lists
08:39:51 <popcorn> What's Probably?
08:40:17 <mm_freak_work> popcorn: probabilistic data
08:40:38 <mm_freak_work> actually i also added a Ceased constructor
08:40:46 <mm_freak_work> data Probably a = Probably Double a | Ceased
08:41:22 <popcorn> type Unlikey a = Probably (Not a)
08:41:34 <opqdonut> :P
08:41:37 <mm_freak_work> lol
08:42:28 <mm_freak_work> data Not a = forall b. b
08:42:28 <mm_freak_work> =)
08:43:28 <Saizan> type Not a = forall b. (a -> b)
08:44:04 <popcorn> ?djinn-env
08:44:05 <lambdabot> data () = ()
08:44:05 <lambdabot> data Either a b = Left a | Right b
08:44:05 <lambdabot> data Maybe a = Nothing | Just a
08:44:05 <lambdabot> data Bool = False | True
08:44:05 <lambdabot> data Void
08:44:06 <lambdabot> type Not x = x -> Void
08:44:08 <lambdabot> class Eq a where (==) :: a -> a -> Bool
08:44:11 <lambdabot> type Cont r a = (a -> r) -> r
08:45:05 <popcorn> kind of wish 0, 1, 2 were type (Void, (), Bool)
08:45:08 <dmead> > foldr (+) 0 [1..10]
08:45:10 <lambdabot>  55
08:45:24 <popcorn> > 10*11`div`2
08:45:25 <lambdabot>  55
08:45:28 <dmead> > foldr (+) 0 [ x^2 | x <- [0.100]]
08:45:29 <lambdabot>  1.0000000000000002e-2
08:45:50 <popcorn> > foldr (+) 0 [ x^2 | x <- [0..100]]
08:45:51 <lambdabot>  338350
08:46:07 <dmead> wot
08:46:14 <dmead> > foldr (+) 0 [ x^2 | x <- [0..100]]
08:46:15 <dmead> oh
08:46:16 <lambdabot>  338350
08:46:16 <dmead> ah ah
08:46:30 <dmead> > foldr (+) 0 [ exp x^2 | x <- [0..100]]
08:46:33 <lambdabot>  8.356966148883713e86
08:46:37 <mm_freak_work> > foldr (+) 0 ([0..100] >>= (^2))> foldr (+) 0 ([0..100] >>= (return . (^2)))
08:46:38 <dmead> > e
08:46:38 <lambdabot>   add an instance declaration for (Num [a])
08:46:38 <lambdabot>     In the expression: 0
08:46:39 <mm_freak_work> > foldr (+) 0 ([0..100] >>= (return . (^2)))
08:46:40 <lambdabot>  e
08:46:41 <lambdabot>  338350
08:47:05 <dmead> mm_freak_work, ugly code makes me cringe
08:47:09 <dmead> especially in haskell
08:47:26 <mm_freak_work> that was intentional
08:47:31 <dmead> :P
08:47:38 <popcorn> > (\n->n*(n+1)*(2*n+1)`div`6) 100
08:47:39 <lambdabot>  338350
08:47:54 <mm_freak_work> > foldr1 (+) (map (^2) [0..100])
08:47:55 <lambdabot>  338350
08:48:19 <popcorn> @src sum
08:48:19 <lambdabot> sum = foldl (+) 0
08:49:27 <popcorn> so....
08:49:40 <popcorn> Which programs use typed logic variables?
08:50:02 <Bonus> > sum . map (^2) $ [0..100]
08:50:04 <lambdabot>  338350
08:50:13 <dmead> my prover does
08:50:14 <dmead> did
08:50:16 <dmead> has done
08:50:17 <dmead> etc
08:50:22 <dmead> types predicates, etc
08:50:24 <dmead> *typed
08:50:30 <dmead> instead of just strings like some
08:50:36 <popcorn> dmead: Can I see the code please?
08:50:58 <dmead> http://taz.cs.wcupa.edu/~dmead/code/prover/
08:51:00 <lambdabot> Title: Index of /~dmead/code/prover
08:51:05 <dmead> one for first order logic, one for propositional logic
08:51:22 <dmead> that copy of FOL is screwed up, some of the test units pass when they shouldnt
08:51:31 <dmead> http://taz.cs.wcupa.edu/~dmead/code/prover/FOL/FirstOrderLogic.hs
09:01:06 <Arnar> ?index assert
09:01:06 <lambdabot> Control.Exception, Test.HUnit.Base, Test.HUnit
09:03:00 <Arnar> :t assert
09:03:02 <lambdabot> Not in scope: `assert'
09:03:11 <Arnar> :t Control.Exception.assert
09:03:13 <lambdabot> forall a. Bool -> a -> a
09:07:55 <Arnar> hmm..
09:08:08 <Arnar> :t Control.Concurrent.STM.check
09:08:10 <lambdabot> Couldn't find qualified module.
09:08:17 <Arnar> :t Control.Parallel.STM.check
09:08:20 <lambdabot> Couldn't find qualified module.
09:08:24 <Arnar> ?index check
09:08:24 <lambdabot> Control.Concurrent.STM, Test.QuickCheck, Debug.QuickCheck
09:08:43 <Arnar> :t Control.Concurrent.STM.check
09:08:45 <lambdabot> Couldn't find qualified module.
09:08:48 <Arnar> ?hoogle check
09:08:48 <lambdabot> Control.Monad.STM.check :: Bool -> STM a
09:08:48 <lambdabot> GHC.Dotnet.checkResult :: (State# RealWorld -> (State# RealWorld, a, Addr#)) -> IO a
09:08:48 <lambdabot> Distribution.Simple.Configure.checkPersistBuildConfig :: FilePath -> IO ()
09:09:00 <Arnar> :t Control.Monad.STM.check
09:09:02 <lambdabot> Couldn't find qualified module.
09:09:29 <Arnar> anyways.. the Bool -> STM a  type signature does not match the invariant paper of TH and SPJ
09:10:40 <Arnar> did they change it.. or hasn't it been implemented like that yet?
09:11:00 <sclv_> ?hoogle always
09:11:01 <lambdabot> GHC.Conc.always :: STM Bool -> STM ()
09:11:01 <lambdabot> GHC.Conc.alwaysSucceeds :: STM a -> STM ()
09:11:32 <Arnar> ah ok..
09:11:40 <Arnar> so "check" from the paper is called alwaysSucceeds
09:11:45 --- mode: ChanServ set -o dons
09:11:45 <zgold> do not doubt the SPJ :)
09:12:06 <Arnar> zgold: never.. :)
09:12:39 <Arnar> so.. the stm action passed to always and alwaysSucceeds still gets rolled back, right?
09:22:30 <Beelsebob> @hoogle Eq a => [(a,b)] -> a -> [b]
09:22:31 <lambdabot> No matches, try a more general search
09:22:36 <Beelsebob> @hoogle Eq a => [(a,b)] -> a -> b
09:22:36 <lambdabot> No matches, try a more general search
09:22:42 <popcorn> :t flip lookup
09:22:44 <lambdabot> forall a b. (Eq a) => [(a, b)] -> a -> Maybe b
09:22:55 <Beelsebob> yeh
09:23:01 <Beelsebob> but this isn't a mapping exactly
09:23:14 <Beelsebob> there can be multiple values with the same key
09:23:38 <popcorn> :t filter ((==?x).fst)
09:23:40 <lambdabot> Not in scope: `==?'
09:23:43 <popcorn> :t filter ((== ?x).fst)
09:23:45 <lambdabot> forall a b. (Eq a, ?x::a) => [(a, b)] -> [(a, b)]
09:23:50 <popcorn> :t map fst . filter ((== ?x).fst)
09:23:52 <lambdabot> forall a b. (Eq a, ?x::a) => [(a, b)] -> [a]
09:24:01 <ziman> what is ?x ?
09:24:07 <popcorn> :t flip (\x -> map snd . filter ((== x).fst))
09:24:09 <lambdabot> forall a b. (Eq a) => [(a, b)] -> a -> [b]
09:24:31 <popcorn> @pl (\x -> map snd . filter ((== x).fst))
09:24:31 <lambdabot> (map snd .) . filter . (. fst) . (==)
09:25:08 <Beelsebob> yep, looks sensible
09:25:16 <Beelsebob> but... lets have the pointfull version
09:29:33 <Arnar> I'm having a hard time finding up-to-date docs on the STM invariant stuff
09:29:45 <Arnar> so Control.Monad.STM.check does not install an invariant?
09:29:57 <Arnar> just retries if the argument is false.. right?
09:31:07 <mm_freak_work> IIRC i've asked this question already, but i think nobody could answer it  if getContents fails, where does it fail?
09:31:10 <mm_freak_work> and how?
09:32:11 <dons> if it fails, it throws an exception.
09:32:20 <dons> at the point where the value is demanded.
09:32:43 <dons> lazy io means it'll happen based on when the data is used, that forces the read
09:35:10 <mm_freak_work> dons: so if i use the list somewhere deep in my pure code, it would drop me back to IO ?
09:36:08 <dons> it if fails, it'll through an exception that can only be caught in IO, yep.
09:36:20 <mm_freak_work> k, many thanks
09:36:21 <dons> if you need to ensure all errors are handled *before* entering some pure code, use strict io
09:36:35 <dons> there's System.IO.Strict for this (on hackage), but its also easy to write yourself
09:36:53 <mm_freak_work> yeah, i'd just do it myself
09:37:12 <mm_freak_work> thanks  and see you guys tomorrow
09:38:03 <quicksilver> damn
09:38:11 <quicksilver> I missed a great opportunity for hyperbole there
09:38:33 <quicksilver> oh well, there will be more.
09:42:40 <TomMD> dons: Is Simon M still in Portland?
09:43:06 <Igloo> No, he's back in the UK
09:48:31 <matthew_-> hey Igloo. How's that bug?
09:48:48 <Igloo> Which bug?
09:48:57 <matthew_-> there's more than one?!!
09:49:03 <matthew_-> 2231
09:49:19 <gms> hi
09:49:41 <TomMD> hello gms
09:49:47 <gms> is -optl is supposed to work with ghci 6.8.2 and static libs?
09:50:40 <matthew_-> gms: are you trying to make a fully static program?
09:50:59 <dcoutts_> gms: -optl just passes args through to gcc when linking
09:51:04 <Igloo> matthew_-: Ah, it's pending me talking to Simon about some RTS details
09:51:18 <matthew_-> Igloo: ahh ok. Did you track down a suspect then?
09:51:31 <gms> matthew: no, I am trying to access some c-fn via ffi
09:51:35 <dcoutts_> gms: so you have to pass some flag to tell gcc to use static libs, -optl-gcc-please-use-static-libs-thanks
09:51:36 <matthew_-> I verified that it doesn't happen on 32-bit x86
09:51:41 <Igloo> Well, I have found one problem at least
09:52:25 <matthew_-> cool. So long as it's not going to be put down to cosmic radiation ;)
09:54:36 <TomMD> That would be an interesting bug report: "Compiled programs are not resistant to computation errors caused by cosmic radiation or single faults."  Perhaps a sure fire way to get a developer to order a hit on a tester.
09:55:27 * matthew_- misread that as "...sure fire way to get a developer to hit on a tester."
09:55:32 <ddarius> TomMD: Some programs have such requirements.
09:56:26 <TomMD> ddarius: And what is your solution
09:58:25 <ddarius> There are ways like error correcting codes and having multiple instances vote on solutions.
09:59:01 <gms> ok, I use -optl libfoo.a with ghc - which works fine - but how to load libfoo.a with ghci ...?
09:59:08 <matthew_-> but it's always going to be stochastic right?
09:59:48 <gms> -l looks for a dynamic (.so) library ...
10:00:16 <ddarius> matthew_-: You can, for example, have guarantees against say single bit (or n-bit for some given n), but yeah, if you set the computer on fire the program is probably going to fail.
10:02:07 <edwardk> hey, anyone have better names for: a 'functor wrapping a bifunctor' Foo f p x y = f (p x y), a 'bifunctor wrapping 2 functors' Bar p f g a b = p (f a) (g b), a 'bifunctor wrapping 2 bifunctors' Baz r p q a b = r (p a b) (q a b)
10:02:29 <gms> 'GHCi cannot load .a files directly' from http://www.haskell.org/ghc/docs/latest/html/users_guide/packages.html gives a solution ...
10:02:42 <gms> sorry for the noise
10:02:44 <edwardk> i find myself drowning in these combinators. right now they are FunctorB, BiffB and CompB respectively
10:03:29 <ddarius> edwardk: You need a functor composition type constructor.
10:03:50 <edwardk> i have one, the thing is when you compose bifunctors there are a few ways you want to do it
10:03:53 <ddarius> But I guess that's what those are.
10:04:14 <edwardk> CompB can subsume the rest, but its a little painful to use that that way
10:04:30 <edwardk> (you need to use FstB and SndB to select out a parameter, etc)
10:05:16 <edwardk> And technically FunctorB and BiffB could be rolled into one to get a functor wrapped around a bifunctor wrapped around two functors, but then it loses a lot of explanatory adequacy =)
10:05:35 <edwardk> BiffB just generalizes functor product and coproduct by letting you pass the operation (product or coproduct) as its first parameter
10:05:58 <edwardk> BiffB (,) f g   is functor product BiffB Either f g is functor coproduct
10:06:33 <edwardk> er not quite, i have a separate combinator for that because BiffB takes two arguments. =) but dangit, BifunctorB (,) f g is =)
10:06:37 <edwardk> er BifunctorF
10:06:39 <edwardk> see my point =)
10:06:40 <Cale> BiffB is type-level 'on'
10:06:44 <edwardk> yeah
10:06:50 <edwardk> hrmm
10:06:53 <edwardk> that might work
10:06:55 <edwardk> On
10:07:12 <edwardk> hrmm, not quite coz i take two parameters one for each side
10:07:21 <edwardk> On would take one functor and apply it to both sides no?
10:07:22 <Cale> er, right, it's not
10:07:49 <edwardk> type On p f a b = BiffB p f f a b
10:07:50 <Cale> I suppose it's really liftA2
10:08:39 <edwardk> i'm thinking i may take the term level names and make the type names reflect them LiftA2 or Lift2 or something like that
10:08:42 <Cale> > liftA2 (,) f g x
10:08:43 <lambdabot>  Add a type signature
10:08:48 <Cale> > liftA2 (,) f g x :: Expr
10:08:49 <lambdabot>  Couldn't match expected type `Expr' against inferred type `(a, b)'
10:08:54 <Cale> > liftA2 (,) f g x :: (Expr, Expr)
10:08:56 <lambdabot>  (f x,g x)
10:09:11 <edwardk> @type liftA2 p f g x
10:09:14 <lambdabot>     Couldn't match expected type `a -> b -> c'
10:09:14 <lambdabot>            against inferred type `Expr'
10:09:14 <lambdabot>     In the first argument of `liftA2', namely `p'
10:09:26 <edwardk> ah forgot Expr doesn't work as a function
10:09:28 <popcorn> @type liftA2 ?p ?f ?g ?x
10:09:30 <lambdabot> forall a b c t. (Applicative ((->) t), ?x::t, ?g::t -> b, ?f::t -> a, ?p::a -> b -> c) => c
10:09:57 <edwardk> ah neat trick with the implicit arguments =)
10:10:12 <Deewiant> @ty liftA2
10:10:13 <Saizan> not so readable..
10:10:14 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
10:10:16 <Cale> I was about to do the same actually :)
10:10:22 <Deewiant> much more readable :-P
10:10:41 <popcorn> it's a different type though
10:10:48 <Cale> except that it doesn't specialise the instance
10:11:16 <Cale> :t (\p f g x -> liftA2 p f g x)
10:11:18 <lambdabot> forall t a b c. (Applicative ((->) t)) => (a -> b -> c) -> (t -> a) -> (t -> b) -> t -> c
10:11:27 <edwardk> @type liftA2 (,)
10:11:30 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
10:11:48 <popcorn> @instances Applicative
10:11:49 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
10:11:50 <edwardk> hrmm seems a little different still
10:11:55 <popcorn> @instances-importing Applicative Applicative
10:11:56 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
10:12:00 <popcorn> @instances-importing Control.Applicative Applicative
10:12:01 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
10:12:13 <edwardk> @pl \p f g x y -> p (f x) (g y)
10:12:14 <lambdabot> ((flip . ((.) .)) .) . (.)
10:12:20 <edwardk> heh not a very good type name
10:12:22 <Cale> So I guess we're using the applicative functor of natural transformations from a fixed functor?
10:12:32 <popcorn> > liftA2 (,) (1,2) (3,4)
10:12:33 <lambdabot>  Add a type signature
10:12:39 <popcorn> > liftA2 (,) (1,2) (3,4) :: (Int,(Int,Int))
10:12:39 <lambdabot>   add an instance declaration for (Monoid Int)
10:12:39 <lambdabot>     In the expression: liftA2 ...
10:12:48 <Cale> hmm, I'd have to think about it :)
10:12:52 <matthew_-> Is it just me or do other people get worried when their code type checks?
10:12:57 <edwardk> the p f g x y example is really what biffB is at the type level
10:13:05 <Cale> matthew_-: worried?
10:13:12 <matthew_-> especially when you're trying to do something vaguely mad which you're not sure if it's possible or not...
10:13:34 <popcorn> :t liftA2 (,) (1,2) (3,4)
10:13:34 <edwardk> i was scared when my higher order adjunction module worked first try last night
10:13:36 <lambdabot> forall a b t. (Monoid t, Num b, Num a, Num t) => (t, (a, b))
10:13:44 <Cale> matthew_-: Usually if it typechecks it does something useful, even if you don't know what that useful thing is :)
10:13:46 <matthew_-> and :r doesn't result in the familiar multi-thousand line error which you have to log to disk to be able to read...
10:13:56 <popcorn> > liftA2 (,) (Just 1,2) (Just 3,4) :: (Maybe Int,(Int,Int))
10:13:57 <esap> edwardk: "higher-order adjunction"?
10:13:58 <lambdabot>   add an instance declaration for (Monoid Int)
10:13:58 <lambdabot>     In the expression:
10:13:58 <lambdabot>        ...
10:14:32 <edwardk> esap: http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction-HigherOrder.html
10:14:34 <lambdabot> http://tinyurl.com/5rxltu
10:14:43 <edwardk> adjunction between 'functor functors'
10:14:53 <Cale> > liftA2 (,) (Just [1],2) (Just [3],4)
10:14:54 <lambdabot>  (Just [1,3],(2,4))
10:15:51 <edwardk> with hunint :: a b -> g (f a) b -- and hcounit :: f (g b) a -> b a
10:17:35 <esap> edwardk: ok
10:18:05 <edwardk> esap: want them so i can define higher order generalized hylomorphisms and figure out what to use them for =)
10:18:17 <popcorn> hehe
10:18:29 <edwardk> they seem to have all sorts of opportunities for fusion though
10:18:49 <esap> edwardk: heh. I've barely found out what to use adjunctions for [in a compiler].
10:18:57 <cpoucet> anyone know the c++ equivalent of Data.Sequence?
10:19:18 <edwardk> since you can fuse bimaps and anything lower in the sort of generalized hylo- food-chain
10:19:58 <edwardk> esap: most collecting a bunch of this stuff in one place to see what it looks like classified, stuffed and mounted
10:20:54 <esap> edwardk: Heh. I've got quite a bit of code that's intended like that - proof of concept and waiting for future...
10:21:32 <edwardk> esap: a lot of the comonad stuff in there is because i find myself using it over and over and i got sick of rewriting it constantly
10:21:35 <esap> edwardk: For example, I have type-safe polymorphic queues
10:22:01 <edwardk> that and i'd never seen anyone else even talk about a comonad transformer
10:23:17 <esap> http://www.kotiposti.net/~epulkkin/PolyQueue.txt and http://www.kotiposti.net/~epulkkin/PolyStack.txt
10:24:14 <edwardk> esap: ah neat =)
10:25:07 <esap> edwardk: Try to uncomment the type declaration for 'dequeue'. I tried and can't find a form which would work. But without the type declaration, it works...
10:25:27 <edwardk> esap: i am missing the Tools.*
10:25:31 <lispy> esap: did you ask ghci what the type is?
10:25:58 <esap> lispy: yes, and if I use that type, it gives an error!
10:26:14 <edwardk> esap: that sounds like a nice bug report for the simons =)
10:26:32 <edwardk> gah, i want to play with this more but i need to go help someone
10:26:35 <edwardk> bbiab
10:27:01 <lispy> esap: oh dear, you're using bird style code, I can't read it
10:27:30 <esap> edwardk: http://www.kotiposti.net/~epulkkin/Adjunction.txt is I think the only thing needed from Tools
10:28:03 <edwardk> Orthogonal as well i think
10:28:15 * lispy is rather against bird syntax, especially in email where it is utter and completely confusing due to the overloaded meaning of ">"
10:28:27 <Arnar> http://www.haskell.org/tutorial/modules.html <- there's a small error here..
10:28:27 <lambdabot> Title: A Gentle Introduction to Haskell: Modules
10:28:45 <Arnar> says the syntax for hiding is "import Prelude hiding length"
10:29:01 <esap> edwardk: http://www.kotiposti.net/~epulkkin/Orthogonal.txt
10:29:30 <edwardk> esap: mind if i steal a couple of your RULES for category-extras? i omitted a couple of these
10:30:17 <esap> edwardk: sure go ahead. (I'm not sure if they do any good :-)
10:30:25 <edwardk> esap: heh
10:30:41 <edwardk> esap: will profile what i can
10:30:43 <matthew_-> edwardk: you know what you call a Type Indexed Monad?
10:30:53 <edwardk> matthew: yeah?
10:31:15 <matthew_-> well, I use something very similar which I call a parameterised monad
10:31:20 <matthew_-> and the cite I use is earlier
10:31:32 <edwardk> yeah the thing is there are two other notions of a parameterized monad notions
10:31:52 <edwardk> and one of them carries one 'parameter' so it seems more appropriate to the name =)
10:31:52 <RayNbow> augustss, thx for submitting that CTL link to reddit :)
10:31:52 <matthew_-> ahh ok http://homepages.inf.ed.ac.uk/ratkey/
10:31:53 <lambdabot> Title: Bob Atkey
10:31:58 <matthew_-> http://homepages.inf.ed.ac.uk/ratkey/paramnotions-jfp.pdf
10:32:22 <matthew_-> which is 2006. I think you're citing 2007 stuff aren't you?
10:32:40 <matthew_-> ahh, I mean http://homepages.inf.ed.ac.uk/ratkey/param-notions.pdf
10:32:40 <edwardk> re the type indexed stuff?
10:32:56 <matthew_-> sorry, I should have checked my dates / facts before acosting you
10:33:46 <matthew_-> right, no, you're right. Your cite for parameterised monads was 2007 and I'd not realised you were talking about something different there
10:33:49 <matthew_-> sorry.
10:34:03 <matthew_-> (I'm referring to http://www.haskell.org/pipermail/haskell-cafe/2008-May/042463.html)
10:34:05 <lambdabot> Title: [Haskell-cafe] ANNOUNCE: category-extras 0.44.2, http://tinyurl.com/65mtuk
10:34:06 <edwardk> matthew: http://www.mail-archive.com/haskell-cafe@haskell.org/msg18908.html is 2006. but the notion is a lot older due to wadler forever ago
10:34:07 <lambdabot> Title: Re: [Haskell-cafe] AT solution: rebinding >>= for restricted monads, http://tinyurl.com/5hfkqt
10:34:43 <matthew_-> oh ok. yeah, I may vaguely remember that one. I'll be quiet now :)
10:35:05 <edwardk> no i definitely welcome input =)
10:36:52 <edwardk> so as near as i can tell the original use of the two-index monad was by danvy and filinski between 89 and 92, but they never called it anything and wadler called it 'something slightly more general than a monad'
10:37:19 <edwardk> wadler's bit: http://citeseer.ist.psu.edu/wadler93monads.html
10:37:20 <lambdabot> Title: Monads and Composable Continuations - Wadler (ResearchIndex)
10:39:04 <edwardk> matthew-: anyways there are like 5 names for this idea. i think sackman calls it a 'supermonad' in the session type stuff
10:40:41 <edwardk> and i think i also used the name 'parameterized' for my class Bind m m' m'' | m m' -> m'' where (>>=) :: m a -> (a -> m' a) -> m'' a -- post which i made a while back, while ghani et al. used it for one with just a single extra parameter (so it can be built off a bifunctor)
10:40:57 * edwardk stops deluging the channel with references =)
10:41:27 <MarcWeber> dcoutts_: Have you seen my cabal interface idea? Any thoughts on this?
10:41:49 <MarcWeber> (I'm patching a Setup file again .. :)
10:41:56 <dcoutts_> MarcWeber: I saw it, I've not considered it in detail yet
10:42:40 <dcoutts_> MarcWeber: I'd like to provide a better Setup api, my main concern is that it's not always possible to implement the old api in terms of the new implementation
10:43:13 <MarcWeber> dcoutts_: Yeah. but if you can.. you won't break things
10:43:19 <dcoutts_> for example we have various contortions in the current code precisely to avoid breaking setup scripts
10:43:41 <dcoutts_> we've done that so that Cabal-1.4 works with all the Setup scripts that worked with Cabal-1.2
10:43:43 <MarcWeber> If it's not possible it's possible to add a nice error $ "plase have a look at update notice http://..../123"
10:44:14 <dcoutts_> MarcWeber: I'm not sure how, the break would be a type error not a nice deprecation message
10:44:41 <dcoutts_> eg we want to remove a member of a structure that should never have been there
10:44:51 <MarcWeber> dcoutts_: You remember the runTests False thingy? Is this an example where it would break because of types?
10:45:06 <dcoutts_> MarcWeber: that's the nicest easiest kind of example
10:45:19 <dcoutts_> that's just the kind of thing where such a scheme would work
10:45:47 <dcoutts_> but thinking of the changes I'd like to make in future, it's much less clear how to do that and implement an old api
10:46:12 <edwardk> matthew_-: hrmm parameterized freyd categories in that paper sound like an interesting and easy-to-code-up type of arrow-like construct
10:49:05 <dons> ?bug
10:49:05 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
10:51:00 <MarcWeber> dcoutts_: http://rafb.net/p/IkPnFe25.html coulde be one solution if you drop fields..
10:51:01 <lambdabot> Title: Nopaste - No description
10:51:36 <dcoutts_> MarcWeber: true true, we can make them fail at runtime with error
10:51:59 <MarcWeber> The little change that there is no longer a compilerPath is bothering me again and means I have to add about 7 lines. This kind of annyoance could be avoided maybe
10:52:19 <edwardk> matthew_-: er in any event i've been thinking about taking what ghani et al call parameterized monads and renaming them to something indicative that they are all bifunctors because the current name doesn;t give any clue where to find the typeclasses
10:52:51 <edwardk> matthew_-: in the event i do that and i choose to call them something counter intuitive like BiWhatevers i'll go through and rename from indexed to parameterized
10:53:04 <MarcWeber> dcoutts_: You are right.. that's a bad solution. A better one is changing it's type so that a compile time error occurs only when used (otherwise the value from defaultHooks will be used)
10:53:38 <MarcWeber> But in these cases there is not much benefit I agree (to say none)
10:53:52 <dons> Igloo: http://hackage.haskell.org/trac/ghc/ticket/1434 i'll take care of this.
10:53:54 <lambdabot> Title: #1434 (Slow conversion from Double to Int) - GHC - Trac
10:54:11 <dons> Igloo: looks very similar to the realToFrac stuff I was looking at last week -- more id rules missing
10:59:10 <JamesR> Oh my, this many Haskell programmers in one place can't be good for the internet
10:59:38 <Cale> JamesR: heh
10:59:48 <esap> JamesR: You mean we don't get anything else done? :-)
10:59:52 <edwardk> jamesR: shhh, you'll blow the coup
10:59:59 <JamesR> ^_^
11:00:19 <JamesR> Some guys dropped by my blog and told me to come ... That was about two months ago
11:00:26 <dons> JamesR: welcome!
11:00:33 <geezusfreeek> hello
11:00:38 <Cale> Possibly one of them was me :)
11:00:44 * dons points at Cale 
11:00:55 <geezusfreeek> JamesR: what's your blog?
11:01:01 <dons> you're implicated now, JamesR :)
11:01:03 <JamesR> NobodyReadsThis.co.uk
11:01:11 <JamesR> Aptly named
11:01:15 <dons> oh, that might have been me.
11:01:31 <dons> ah, Cale it was
11:01:35 <Cale> yep, I posted there :)
11:01:36 <JamesR> Doing coursework at the moment, Haskell can be mighty fussy when it wants to be
11:01:57 <dons> you use haskell.org?
11:02:02 <dons> and you've got ghc installed?
11:02:16 * JamesR blinks
11:02:35 <JamesR> Haskell.org is probably my primary reference ... But GHC?
11:02:44 <dons> haskell.org/ghc
11:02:56 <esap> edwardk: btw, in the Adjunction class in category-extras, the functional dependencies aren't there?
11:02:56 <dons> the fastest, best supported, most comprehensive haskell compiler
11:03:01 <JamesR> Just using Notepadd++ / WinHugs
11:03:07 <dons> ah, WinHugs eh?
11:03:16 <JamesR> The University points and I follow
11:03:18 <dons> worth getting ghc installed -- the code produced is you know, 100x faster.
11:03:26 <dons> makes hugs feel like a toy :)
11:03:35 <edwardk> esap: ack, they got dropped when i cut it out of my full categories package
11:03:59 <edwardk> esap i'll drop em in
11:04:08 <esap> edwardk: I was wondering if that was on purpose :-)
11:04:45 <skorpan> ok
11:04:49 <geezusfreeek> i don't think i've ever even bothered to try hugs
11:04:55 <edwardk> what it was is when i was using a more generalized functor they became more complicated iirc. there were four parameters 2 of which were categories such that any 2 inferred the other 2
11:05:11 <edwardk> i just cut them all and forgot to add the f -> g, g -> f one back in
11:05:14 <dons> hugs was awesome in 1998.
11:05:26 <esap> edwardk: ah ok
11:05:28 <glguy>  a window manager?
11:05:32 * dons remembers writing cgi apps to solve maze puzzles, running in hugs
11:05:57 <dons> the cgi libs are still pretty much the same, fwiw
11:06:14 <edwardk> esap: http://comonad.com/haskell/categories/dist/doc/html/categories/Control-Category-Functor-Adjunction.html is what i had
11:06:16 <lambdabot> http://tinyurl.com/6bleo4
11:06:18 <byorgey> welcome, JamesR!
11:06:19 <IsoPallo> How much faster will the ultimate optimized GHC be? As understood it still pays to let gcc do the code generation. But surely a native one could be x times bette?
11:06:28 <JamesR> byorgey: Hello! :)
11:06:33 * byorgey hands JamesR a peppermint lambda
11:06:45 <JamesR> You say Lamda, I think Half-life
11:06:49 <byorgey> hehe
11:06:52 <JamesR> ./shame
11:06:53 <dons> IsoPallo: it'll be somewhere a little faster then Clean, I think
11:07:18 <glguy> dons: what will be?
11:07:24 <dons> ghc with the new code gen.
11:07:40 <dons> if the code gen can just match Clean, we'll win on the runtime and optimiser
11:07:40 <edwardk> esap: i have a ton of little 'omg, why didn't he do that?' things in there that just happened coz i spewed all the code over the last couple of weeks hoping someone else would notice what i messed up ;)
11:07:42 <geezusfreeek> i don't know how fast it is being worked on, but i'm paying very close attention to jhc
11:07:48 <glguy> :-p you aren't seriously predicting the performance of a backend that hasn't been written, are you
11:08:01 <geezusfreeek> it's got some bugs right now, but when it works it works FAST
11:08:02 <dons> glguy: well, the problem is all the silly register shuffle
11:08:10 <dons> fix that, and you've got the same code gen as Clean.
11:08:13 <dons> pretty straightforward.
11:08:42 <dons> so yeah, i think since the final bottlenecks are so obvious, you can do some predictions.
11:08:51 <byorgey> JamesR: if you ever have any questions or problems you're running into, we're more than happy to help. just ask. =)
11:08:56 <dons> esp. since we have the gcc-produced asm to match against
11:09:01 <geezusfreeek> JamesR: yeah everybody here is very helpful
11:09:21 <JamesR> Thanks, but my problems would probably be a waste of your time O.o
11:09:28 <geezusfreeek> JamesR: never!
11:09:37 <edwardk> hrmm, i'm debating about moving the non-functor/bifunctor bits out of my categories library into category-extras but that forces the question of if it works with standard arrows out of the box. =(
11:09:38 <IsoPallo> Maybe you could run it on Z80... It has native silly register shuffle support.
11:10:07 <byorgey> JamesR: guess again!
11:10:34 <byorgey> ...of course, I'm referring to *Haskell* problems.  if you have an annoying aunt who keeps e-mailing you, for example, you're on your own.
11:10:58 <lament> ?faq an annoying aunt keeps e-mailing me, can Haskell help?
11:10:58 <lambdabot> The answer is: Yes! Haskell can do that.
11:11:30 <edwardk> the only issue i have is that to do Control.Category.* _right_ i need class-associated types, which then cuts off my user base =/
11:12:39 <edwardk> hrmm when i set up the cabal file, how do i set it up to only build some of the files on certain build-depends combinations?
11:13:18 <JamesR> I have a Haskell question actually ...
11:13:20 <JamesR> I was in an interview for Xerox recently, and they asked me "So what is Haskell used for"
11:13:30 <JamesR> I had no answer for him ...
11:13:43 <JamesR> So I bumbled something about compilers and changed the subject >_>
11:13:44 <mrd> used for answering interview questions!
11:13:47 <edwardk> jamesr: writing compilers, researching software transactional memory
11:14:07 <byorgey> edwardk: hmm, maybe something like: create some flags to indicate different build-modes, and conditional on the value of the flags, set the build-depends and exposed-modules as appropriate?
11:14:10 <dons> JamesR: i'm (and others) are employed to write high assurance software for governments in haskell
11:14:13 <geezusfreeek> JamesR: i and conal are working on new ways to write GUIs and games
11:14:26 <edwardk> writing exceptionally beautiful implementations of 'fib' and 'fac' using category theory =)
11:14:30 <dons> JamesR: there's also a good presence in the banking industry
11:14:31 <geezusfreeek> not much of a common use yet though
11:14:33 <dons> http://haskell.org/haskellwiki/Haskell_in_industry
11:14:34 <lambdabot> Title: Haskell in industry - HaskellWiki
11:14:41 <mrd> why would govts be interested in high assurance software? it would make them look bad
11:14:48 <dons> most of those companies are either banks, or high assurance stuff
11:15:11 <dcoutts_> edwardk: re build-depends, can you be more specific? it sounds like what configurations are for
11:15:32 <dons> JamesR: all that type safety and purity makes for really robust software, so you'll find it in areas where correctness matters
11:15:36 <geezusfreeek> JamesR: haskell is also beginning to be used for web apps (see HAppS)
11:15:37 <edwardk> mrd: well if you have a system that deals with both secret and non-secret data, then having assurance that you don't leak secret data out of the system on non-secret channels is a good thing
11:15:54 <dons> its a bit like asking what OCaml is used for :)
11:16:01 <mrd> edwardk: that can be subverted by one lazy employee with a laptop
11:16:04 <JamesR> And now I know for next time, I find it's vastly more helpful when a lecturer tells me the application of something before just teaching it. I spent a year doing python before I realised what people actually used it for.
11:16:12 <edwardk> ocaml is mostly used for making my eyes bleed when i try to read it
11:16:17 <dons> edwardk: right.
11:16:27 <dons> ocaml is used to motivate haskell :)
11:16:38 <edwardk> ocaml is the best advertisement haskell could wish for
11:16:39 <geezusfreeek> ocaml looks a little nicer to a C programmer than Haskell does, for some reason
11:16:48 <dcoutts_> more ;;;'s
11:16:48 <popcorn> no it doesn't
11:16:53 <edwardk> geezus: thats fine, its a gateway drug
11:16:58 <byorgey> mrd: not if you use haskell to design a laptop with a type such that the compile prevents you from taking it out of the building.
11:17:02 <byorgey> *compiler
11:17:03 <Vq^> geezusfreeek: no it doesn't
11:17:11 <geezusfreeek> well, it did to me... i'm glad i chose haskell though
11:17:21 <dons> do { alloca ( { do some; things; } ) ; };;
11:17:21 <geezusfreeek> now C looks terrible terrible terrible
11:17:37 <popcorn> really the syntax is the least of your troubles when writing C
11:17:46 <Vq^> geezusfreeek: i was a pretty pure C coder and i chose Haskell over the MLs
11:17:50 <mrd> i realized recently that i find writing imperative code unnatural and awkward now
11:18:04 <edwardk> i'll admit the only mainstream language i can bring myself to use much these days is c# coz of the lambdas and type inference.
11:18:24 <geezusfreeek> mrd: i am in the same boat
11:19:31 <geezusfreeek> i'm scared of what i'll have to do once i get done with my degree and need to find a real job. i am too picky for a java shop!
11:19:34 <JamesR> I have C# cw to do ... It's going disasterously.
11:19:40 <byorgey> mrd: hear hear!
11:19:54 <edwardk> jamesr: well, i like the 3.5 stuff anyways
11:20:06 <mrd> when demonstrating code on the board i just can't help but write it functionally
11:20:16 <geezusfreeek> so who's up for a Haskell startup of some sort? :)
11:20:21 <Vq^> C# got some good sides but it could really use a better syntax
11:20:27 <byorgey> .oO ( and then I just map over this list... argh!  for... int i = 0 .... sigh)
11:20:29 <qwr> geezusfreeek: you can use "lambdas" in java (anonymous). they just look funny. i occasionally use curring in Java too ;)
11:20:49 <Vq^> qwr: how do they look?
11:20:50 <qwr> ... (anonymous classes)
11:20:53 <geezusfreeek> qwr: i can't even use most java libraries without resorting to impure code though :(
11:21:05 <edwardk> geezusfreeek: there are already a couple out there no? galois, well-typed, the happs folks, i have something kicking around in the breeze that might pan out, etc.
11:22:41 <geezusfreeek> yeah, i'd be up for joining any of those or starting my own, given the opportunity... but i'm not sure how well about 1.5 years experience with haskell looks for trying to join a haskell shop
11:22:59 <cjb> geezusfreeek: depends what you did in the 1.5 years, I guess :)
11:23:02 <qwr> Vq^: like that: http://hpaste.org/7456
11:23:02 <geezusfreeek> that's including my noob time
11:23:27 <geezusfreeek> cjb: guess i better get cracking
11:24:02 <JamesR> I am really beginning to hate working with lists in Haskell
11:24:16 <popcorn> JamesR: What are you doing with lists?
11:24:19 <geezusfreeek> JamesR: if it sucks then perhaps you need a more expressive data structure?
11:26:10 <edwardk> geezus: i don't think i've been around here much longer than that
11:26:23 <JamesR> Creating a simple routine to prompt for a String (IO) then add it to a list. But i'm having a bit of a "Computer says no" moment :>
11:26:32 <arussel> hi, I am trying to do : http://www.nobugs.org/developer/yi/example-helloworld.html . Anyone knowleagable enough to give a hand ?
11:26:33 <JamesR> And making it recursive
11:26:33 <lambdabot> Title: Hello World Yi example
11:27:24 <arussel> I just don't have the M-x reconfigureE function defined , using 0.4
11:28:04 <popcorn> JamesR: You can't add something to a list
11:28:06 <geezusfreeek> edwardk: do you have a haskell job?
11:28:39 <popcorn> JamesR: Say I have some list [1,2,3] and I wanted [0,1,2,3], you actually create a new list rather than adding anything
11:28:44 <popcorn> > (0:) [1,2,3]
11:28:45 <lambdabot>  [0,1,2,3]
11:28:56 <edwardk> geezusfreeek: nope, though it didn't keep me from having the chutzpah to ask galois for one. i just never actually got back to them about it because i got the one i have now around that time
11:29:08 <Cale> You create a new list which refers to the old one.
11:29:11 <popcorn> > let l = [1,2,3] in ( (0:) l , l ) -- the old list stays the same
11:29:12 <lambdabot>  ([0,1,2,3],[1,2,3])
11:29:29 <geezusfreeek> edwardk: it would be premature for me to do so now
11:29:39 <geezusfreeek> still have a degree to finish up
11:29:40 <Cale> > let l = [1,2,3] in (0:l, l)
11:29:41 <popcorn> Cale: shouldn't it be utterly impossible to observe that the old list is referenced?
11:29:42 <lambdabot>  ([0,1,2,3],[1,2,3])
11:30:12 <byorgey> still, it's nice to know that it doesn't create an entire new copy of the list in memory.
11:30:14 <Cale> popcorn: except by the asymptotic performance of the code.
11:30:48 <edwardk> geezus: well, finish up, acquire some useful skills along the way, master some dark art that you can only pick up in deep academia like formal automated theorem proving, and then step out into the world into one of the 5 jobs or so out there per year for someone with those skills ;)
11:31:07 <JamesR> http://hpaste.org/7457
11:31:26 * JamesR shields self
11:31:40 <mrd> you are in a maze of twisty academic buildings, all alike
11:31:47 <Cale> JamesR: It's fine, we were all beginners at some point :)
11:31:50 <geezusfreeek> edwardk: my undergrad degree isn't deep academia :\
11:32:02 <Cale> JamesR: x :: String, xs :: [String]
11:32:12 <edwardk> geezusfreeek: fair nuff, so you have a ways to go yet =)
11:32:32 <edwardk> geezusfreeek: i still want to go back and do my ph.d myself, but i need to pay off the mortgage on my brain first
11:32:36 <Cale> The (:) operator has type  a -> [a] -> [a]
11:32:39 <geezusfreeek> i'm impatient :P
11:33:09 <Cale> That is, the thing on the left is an element (the first element of the new list), and the thing on the right is a list of elements to which it's being added.
11:33:20 <Cale> str :: String
11:33:29 <geezusfreeek> i've never had much success with education anyway. i understand that getting a Ph.D. should be a lot more challenging, but as an undergrad i just feel that classes slow me down
11:33:30 <Cale> So x : xs : str  is badly typed here.
11:33:45 <Cale> If you want to add str to the end of the list, you'll have to use concatenation
11:33:50 <mrd> geezusfreeek: great. PhD has nothing to do with classes
11:33:59 <mrd> (well there's classes, but whatever)
11:34:01 <byorgey> > "x" : ["xs","xs"] : "str"  -- like this
11:34:02 <Cale> (x:xs) ++ [str]
11:34:02 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
11:34:22 <byorgey> > "x" : ["xs","xs"] ++ ["str"]  -- better!
11:34:23 <lambdabot>  ["x","xs","xs","str"]
11:34:26 <mrd> geezusfreeek: if you feel slowed down, approach a professor and try to do an independent project
11:34:31 <edwardk> geezus: i understand i bothered with academia after 10 years in industry and burned through my undergrad and first masters within a year and a half of coming in (i had about a freshman's worth of misc scattered credits when arriving). i feel your pain regarding them slowing you down
11:34:55 <popcorn> @hoogle String -> Bool
11:34:56 <lambdabot> No matches, try a more general search
11:35:22 <Deewiant> @hoogle [a] -> Bool
11:35:23 <lambdabot> Prelude.null :: [a] -> Bool
11:35:23 <lambdabot> Data.List.null :: [a] -> Bool
11:35:23 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
11:35:35 <byorgey> JamesR: also, putStr :: String -> IO (), but (x:xs) :: [String]
11:35:40 <popcorn> JamesR: how I'd do it: http://hpaste.org/7457#a2
11:35:54 <edwardk> i had to switch schools to get one that was willing to let me contort their schedule to do what i wanted to do though =)
11:36:08 <byorgey> JamesR: so you will need to use something like  putStr (concat (x:xs)), or even better, putStr (unlines (x:xs))
11:36:23 <geezusfreeek> i would have switched schools, but i only have one class to go here now though
11:37:01 <geezusfreeek> i didn't even start my computer science major officially until just last semester (computer engineering before that)
11:37:12 <edwardk> now i kind of wish i'd taken a little more time and gone some place better, but to be quite honest the opportunity cost of going back to school for what i did was quite high for me, since its hard to take all your money and just say you know what? i don't want to earn anything any more, in fact i'll spend this and go to school =)
11:37:53 <byorgey> JamesR: but even better than that would be to return the list of Strings, as in popcorn's example.  That way it's more reusable -- whatever code calls buildList can decide what to do with the strings.
11:38:15 <Cale> http://hpaste.org/7457#a3
11:38:21 <edwardk> geezusfreeek: then it sounds like you should finish up there =)
11:38:43 <popcorn> null !
11:38:46 <popcorn> that's what I was looking for
11:40:24 <JamesR> The puzzling part is that all the solutions start with "strings :: IO [String]" and the worksheet i'm following asks for [String] IO() although why is beyond me already
11:40:57 <Cale> [String] -> IO () would be a more suitable type for a function which printed out a list of strings or something like that.
11:41:21 <Cale> But if you really want to accumulate the list in a parameter, you can do it...
11:41:22 <popcorn> [String] IO () isn't even valid Haskell
11:41:27 <JamesR> The worksheet also calls for two functions - although again I have no idea why
11:41:34 <byorgey> popcorn: I'm sure JamesR meant [String] -> IO ()
11:41:51 <Cale> JamesR: Could you type the problem verbatim perhaps?
11:42:00 <JamesR> Will do ;)
11:42:04 <popcorn> JamesR: well hopefully Cales example showed that it needn't be a hassle (unless bizarre constraints are imposed)
11:42:20 <popcorn> (dealing with lists/io etc)
11:43:24 <JamesR> http://hpaste.org/7457#a4
11:43:36 <JamesR> (I haven't changed my solution btw
11:44:03 <JamesR> Curse you missing bracket
11:44:04 <popcorn> JamesR: You should add a line that prints the list out
11:44:13 <Cale> JamesR: ah, okay. They want you to use an accumulating parameter -- that's sort of necessary to do the printing on each step.
11:44:14 <popcorn> like after x <- getLine
11:44:33 <popcorn> you shold also use ++ [x] rather than x:
11:44:45 <JamesR> Indeed, which is why your solutions - all be they brilliant - served only to baffle me further :>
11:44:51 <popcorn> since you're putting things at the end (unusual and in general less useful)
11:45:10 <popcorn> JamesR: What did you not understand about the code I pasted?
11:45:58 <JamesR> popcorn: I understood it, don't worry ;)
11:46:12 <popcorn> ok...
11:46:17 <Cale> http://hpaste.org/7457#a5 -- here's a solution to the problem
11:46:22 <edwardk> jamesr: they probably expect you to build up a list of strings as one io action with a function like getStrings :: IO [String] and to connect it with a function printStrings :: [String] -> IO () that knows how to print them all out
11:46:34 <Cale> (I haven't actually tried it)
11:46:59 <edwardk> oh i see the instructions now
11:47:33 <Cale> yep, that works
11:47:46 <Cale> So buildList will initially be called with an empty list
11:48:12 <Cale> (representing the fact that no strings have been read yet)
11:48:53 <Cale> Then, as the user types strings, buildList calls itself with new lists constructed by appending the new string on to the list of old ones.
11:49:33 <JamesR> See I was afraid that by referring to a list as xs and not x:xs I would be truncating the first result
11:49:47 <Cale> Nope :)
11:49:53 <Cale> That xs will match the whole list.
11:50:19 <Cale> To truncate the first element of the list, you'd need to match with a pattern like (_:xs) or something
11:50:33 <Cale> (the _ is a wildcard)
11:50:49 <JamesR> One thing I did know :)
11:51:14 <JamesR> List manipulation just feels unusual in Haskell
11:51:22 <popcorn> compared to?
11:51:38 <Botje> uh, it's really natural to those coming from lisp / scheme :)
11:51:43 <Vq^> JamesR: it's all those different languages fault! :o)
11:51:48 <Spark> penises feel unnatural until your recognise your true sexuality
11:51:51 <Cale> It's actually quite natural once you get to know the operations. Appending repeatedly to the end of a list, like this program is required to do is very unnatural though.
11:51:59 <geezusfreeek> woah woah
11:52:42 <byorgey> Spark, take it to #haskell-blah please
11:52:43 <JamesR> popcorn: C
11:52:50 <JamesR> Bah, pesky enter key
11:53:06 <popcorn> JamesR: linked lists in C, or char * type things?
11:53:09 <JamesR> C#, Python, PHP ... It's probably a matter of syntax more than anything
11:53:34 <geezusfreeek> i find using arrays in C to be vastly more tedious than in haskell... all that manual iteration and allocation and stuff
11:53:34 <Cale> JamesR: You can think of (:) as building a structure with two pointers: a pointer to an element, and a pointer to another list (which in turn is either a structure of the same sort, or the empty list)
11:53:51 <Vq^> JamesR: does any of those have simple linked lists?
11:54:02 * JamesR blinks
11:54:10 <byorgey> not built-in, I don't think
11:54:11 <Cale> (If you're used to linked lists in C, that should be familiar)
11:54:26 <byorgey> and if you're not, then you can ignore it =)
11:54:27 <Toxaris> I think Python has built-in single linked lists
11:54:41 <byorgey> it does?
11:54:58 <edwardk> byorgey: pythons have lists in the primitive syntax
11:55:03 <Vq^> Toxaris: i've never seen them
11:55:15 <edwardk> ['a','b','c'].append("Hello")
11:55:28 <byorgey> edwardk: yes, but they feel more like arrays than linked lists
11:55:41 <JamesR> Thats because they are, by definition I think
11:55:43 <popcorn> JamesR: a linked list is like struct list { datum e; list *tail; };
11:55:57 <popcorn> JamesR: you have used those or what did you mean by lists in CL
11:56:01 <popcorn> C*
11:56:04 <idnar> python lists are dynamic arrays of object references, not linked lists
11:56:15 <IsoPallo> Hmm... Actually now it comes to mind: Do haskell lists "grow" backwards or why it is just foldr that works on infinite lists?
11:56:36 <popcorn> IsoPallo: backwards... which way is forwards?
11:56:38 <Cale> IsoPallo: well... let's have a look at what foldl does
11:56:42 <JamesR> I was referring to just the general handling of lists (/arrays) and such. As I said, it's likely a matter of taste and syntax than an actual critique of the language
11:56:47 <Cale> foldl f z [] = z
11:56:54 <Deewiant> > foldl f z [a,b,c]
11:56:56 <lambdabot>  f (f (f z a) b) c
11:57:03 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
11:57:07 <popcorn> JamesR: ok just trying to understand what you'd used before, still not sure
11:57:11 <byorgey> JamesR: yeah, if you're used to languages like PHP, C, Python, etc, haskell lists will feel very different
11:57:13 <edwardk> iso: the thing is you can cons onto the front of the list without affecting the contents of an immutable list. you can implement the same thing in C or any other mainstream language
11:57:19 <Cale> So on an infinite list, foldl will call itself immediately forever.
11:57:22 <byorgey> JamesR: you'll get used to them =)
11:57:31 <Cale> Let's contrast that with foldr
11:57:37 <Cale> foldr f z [] = z
11:57:37 <Deewiant> > foldr f z [a,b,c]
11:57:39 <lambdabot>  f a (f b (f c z))
11:57:46 <Cale> foldr f z [] = z
11:57:56 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
11:58:24 <Cale> So when applied to a cons, foldr immediately returns an application of f to some arguments.
11:58:33 <Toxaris> idnar: I used python once some years ago, and i was under impression lists were linked lists then. but maybe this was because I was able to use them like linked lists because of syntactic sugar or whatever
11:58:48 <Cale> So f gets to evaluate next, and if it doesn't happen to use its second argument, the recursion stops.
11:59:19 <IsoPallo> edwardk: consing into front was just what I meant by "growing" backwards :) Tanks.
11:59:21 <edwardk> jamesr: the main reason pattern matching feels unnatural at first is because it is not a common idiom in the languages most programmers come from.
11:59:22 <IsoPallo> +h
11:59:24 <JamesR> Question: What is the " ' " at the end of xs' ?
11:59:36 <Cale> JamesR: You'd read it as 'prime'
12:00:00 <idnar> Toxaris: uhm, perhaps; I don't think they've ever actually been implemented as linked lists
12:00:01 <Cale> JamesR: It's just a new identifier.
12:00:19 <idnar> Toxaris: looping over a list used to be implemented by sequential indexing
12:00:21 <Cale> xs' being related to xs, but being something new :)
12:00:28 <edwardk> jamesr: you only assign to a variable once in haskell, so he needed a new name for the changed 'xs', rather than call it 'ys' or something xs' is indicative of the fact that its just a slightly modified xs
12:01:27 <Toxaris> edwardk: the main reason anything feels unnatural is because it is not a common idiom in the context you come from.
12:01:49 <popcorn> I thought of let x = y in .. as like,   x = y -> ...
12:01:53 <byorgey> edwardk: putting the names of xs and ys in single quotes when discussing the difference between xs and xs' is quite confusing =)
12:03:00 <byorgey> JamesR: 'x' :: Char  is the character constant representing the character x.   xs' is just a name, like xs_ or xs1
12:03:12 <Toxaris> idnar: I remember some kind of pattern-matching to extract head and tail
12:03:22 <byorgey> kind of confusing that Haskell allows names to contain ' anywhere other than the beginning, actually =)
12:03:32 <JamesR> Ok, thank you :P
12:03:55 <JamesR> My brain feels like a slinky at the moment
12:04:00 <popcorn> :D
12:04:07 <JamesR> Struggling to climb up an escalator
12:04:16 <mauke> another satisfied customer
12:04:16 <idnar> Toxaris: you can get the tail by slicing, but I can't think of any way to do it directly
12:04:17 <Saizan> mmh, so foo'c' /= foo 'c'
12:04:33 <byorgey> JamesR: that is a common symptom of Haskellitis
12:04:46 <idnar> head = someList[0]; tail = someList[1:]
12:04:50 <Toxaris> idnar: maybe I just remember nonsense, or a different language :) I don't have to code lying around here, so I cannot look it up
12:04:53 <popcorn> beh
12:05:02 <popcorn> x[y] has nothing to do with lists
12:05:24 <idnar> Toxaris: heh, okay
12:05:28 <idnar> popcorn: hmm?
12:05:43 <popcorn> it's all random accessy
12:06:13 <edwardk> byorgey: touche
12:06:24 <idnar> popcorn: lists in python support numeric indexing; I wasn't trying to say that they're the only object that does, just suggesting a way to get the "head" and "tail" of a list
12:06:41 <byorgey> http://arcanux.org/lambdacats/brain.jpg
12:08:36 <JamesR> There isn't a place on the internet that doesn't appreciate a good lolcat once in a while
12:10:26 <byorgey> JamesR: indeed.  go up a level to http://arcanux.org/lambdacats/  =)
12:11:23 <mauke> 403
12:11:28 <JamesR> 403 indeed!
12:11:49 <Toxaris> I attended a class about generic scientific english today. it was quite interesting, but it seemed to be widely unrelated to computer science. is the impression correct that I can use much more informal language for computer science papers then what is usual in other sciences?
12:11:59 <Deewiant> the root is http://arcanux.org/lambdacats.html
12:12:04 <lambdabot> Title: Lambdacats
12:12:37 <Toxaris> more precisely: programming language papers.
12:14:07 <Cale> http://cale.yi.org/autoshare/coequaliser.jpg
12:25:42 <Apocalisp> lambdacats: Higher order cats.
12:38:24 <JamesR> Small query:
12:38:24 <JamesR> http://hpaste.org/7458
12:39:53 <mauke> no, the error is in the line above
12:40:05 <Vulpyne> Every expression has to evaluate to something.
12:40:16 <Vulpyne> The last line of your second do is: a <- getInt
12:40:47 <Vulpyne> Also, the scope of that block ends at that point, your second part where you do "else if a" is actually using the "a" from the function definition.
12:41:05 <JamesR> Ah, ok
12:41:32 <Vulpyne> Also, "null" doesn't mean the same thing as "NULL" in C. null is a function that returns True or False whether the list is empty or not.
12:42:13 <Vulpyne> An Int can only contain numeric values. If you want something that may or may not be set, look into the Maybe type.
12:43:05 <Vulpyne> BTW, with if/then/else, it might help to think of it more like the ternary operator from other languages.
12:43:14 <esap> the 'let a = a + num' doesn't probably do what you want
12:44:27 <JamesR> probably better to go with something more akin to let b = a + num ?
12:44:39 <JamesR> and return b?
12:44:52 <Vulpyne> Or just return (a + 1)
12:45:02 <Deewiant> > let foo a = let a = a + 1 in a in foo 10
12:45:05 <esap> JamesR: yes. Note that each let and '<-' will declare a new variable.
12:45:18 <lambdabot>  thread killed
12:45:36 <JamesR> Ah, that makes more sense
12:46:23 <esap> JamesR: And there is no easy way to do assignment to a (normal) variable.
12:47:06 <Vulpyne> And trying to do it that way is going against the flow of normal Haskell code.
12:51:18 <elaforge> how do you lift catchError into a transformer?
12:51:34 <elaforge> I can lift the function itself, but it wants to take a ErrorMonad arg
12:52:04 <elaforge> and while I can lift catchError into my transformer, I can't push the arg down to the transformer from ErrorMonad
12:52:47 <esap> elaforge: ErrorT transformer?
12:52:50 <elaforge> yeah
12:52:55 <elaforge> :t catchError
12:52:58 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
12:53:08 <elaforge> :t Monad.Trans.lift catchError
12:53:10 <lambdabot> Couldn't find qualified module.
12:53:23 <elaforge> :t Control.Monad.Trans.lift catchError
12:53:25 <lambdabot> forall (m :: * -> *) a e (t :: (* -> *) -> * -> *). (MonadTrans t, MonadError e m) => t ((->) (m a)) ((e -> m a) -> m a)
12:53:34 <elaforge> ow
12:53:42 <esap> elaforge: ErrorT is already member of MonadError class
12:54:43 <elaforge> sure, but I have my own stack, called Ui.StateT
12:54:47 <elaforge> so I have throw as
12:54:51 <elaforge>     throw msg = (StateT . lift . lift) (Error.throwError (StateError msg))
12:55:05 <elaforge> but I can't seem to write catch
12:55:30 <elaforge> i.e. the type of this
12:55:30 <elaforge> catch m handler = (StateT . lift . lift) (Error.catchError m handler)
12:55:49 <elaforge> 'm' is expected to be an ErrorT, not a StateT
12:56:35 <esap> elaforge: You need to pattern match 'm'
12:57:08 <elaforge> you mean from the StateT newtype? lemme try
12:57:09 <dbueno> Does anyone know of an Test.QuickCheck.Arbitrary instance for Text.Regex.Regex types?
12:57:19 <roconnor> @type catchError
12:57:21 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
12:57:28 <roconnor> @type catch
12:57:31 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
12:57:47 <elaforge> yeah, that just gets
12:57:47 <elaforge>       Expected type: Error.ErrorT StateError m a
12:57:47 <elaforge>       Inferred type: StateStack t t1
12:58:11 <elaforge> it still requires the handled arg to be a MonadError, which is understandable
12:58:41 <elaforge> this would be a problem in general with lifting operations that take monadic args...
12:59:09 <roconnor> elaforge: you need to apply some run functions to m before you can use catchError
12:59:16 <roconnor> (kinda like what esap was saying)
12:59:32 <elaforge> ah, I see
12:59:57 <elaforge> so run it, extract all its various bits, handle the error, and then somehow repack them into the return val?
13:00:10 <roconnor> that's the idea
13:00:12 <esap> yea, the run functions do the pattern matching in nicer way
13:00:22 <roconnor> you man need some runs composed with the handler as well
13:00:28 <roconnor> you may ...
13:01:21 <roconnor> elaforge: but in theory you don't need to be doing any of this work yourself.
13:01:35 <elaforge> oh?  is there a library way?
13:02:22 <roconnor> elaforge: if you build your own monad out of monad transformers, you should automaticailly get an instance of MonadError.
13:02:54 <elaforge> all I want to be able to do is type "mapM x y `catchError` \exc -> throwError (annotate exc)
13:03:07 <roconnor> How is your Monad defined?
13:03:29 <elaforge>       Expected type: Error.ErrorT StateError m a
13:03:29 <elaforge>       Inferred type: StateStack t t1
13:03:34 <elaforge> oops sorry
13:03:35 <elaforge> newtype Monad m => StateT m a = StateT (StateStack m a)
13:03:41 <elaforge> I'm going to try deriving MonadError
13:04:58 <elaforge> hmm, it's not happy because it wants the exception type arg, which I can't put in deriving
13:05:00 <Toxaris> elaforge: your newtype doesn't look like it should like :)
13:05:11 <roconnor> you should put the exeption arg into deriving
13:06:04 <elaforge> Toxaris, is there a better way for it to look?
13:06:24 <Toxaris> elaforge: I don't think you want "Monad m =>"
13:06:53 <Toxaris> elaforge: and I would consider a name different from StateT (because that one is taken by the mtl)
13:07:16 <elaforge> roconnor, wow, didn't know I could do that, but it says no instance for MonadError StateError (... stack...))
13:07:17 <Toxaris> elaforge: finally, you probably want a bunch of derivings
13:07:37 <elaforge> Toxaris, so I do have a Monad m => up there, and I left off the derivings
13:07:54 <elaforge> and fully qualified this is Ui.State.StateT, which makes more sense
13:08:22 <elaforge> newtype Monad m => StateT m a = StateT (StateStack m a)
13:08:22 <elaforge>     deriving (Functor, Monad, Trans.MonadIO, Error.MonadError StateError)
13:08:41 <roconnor> what is StateStack?
13:08:50 <elaforge> type StateStack m = State.StateT State
13:08:50 <elaforge>     (Logger.LoggerT Update.Update
13:08:50 <elaforge>         (Error.ErrorT StateError m))
13:09:10 <roconnor> what is LoggerT?
13:09:28 <JamesR> There's nothing like thinking you've written perfect code
13:09:40 <JamesR> But suddenly realising that you cleared the modules to test something else
13:09:42 <elaforge> something from the logging subsystem, basically a wrapper around WriterT
13:09:45 <roconnor> elaforge: you should remove the Monad m =>.  It doesn't do what you think it does.
13:10:04 <roconnor> (and it doesn't do what it ought to do)
13:10:33 <elaforge> roconnor, ah, interesting, seems to work fine without it
13:10:46 <elaforge> but I still can't derive Error.MonadError StateError
13:10:56 <roconnor> where is LoggerT documented?
13:11:11 * roconnor searches hackage
13:11:13 <elaforge> oh I see... it wants LoggerT to have a MonadError instance, maybe
13:11:24 <elaforge> oh, it's just from another local module
13:11:36 <elaforge>     No instance for (Error.MonadError
13:11:36 <elaforge>                        StateError
13:11:36 <elaforge>                        (Logger.LoggerT Update.Update (Error.ErrorT StateError m)))
13:12:08 * RayNbow probably figured out why he can't install new LaTeX packages...
13:12:24 <RayNbow> my MiKTeX install is ancient :p
13:13:12 <elaforge> ... but that doesn't make much sense... how could a Writer be an instance of ErrorMonad?
13:13:37 <Toxaris> elaforge: instance MonadError e m => MonadError e (WriterT m) where ...
13:14:12 <elaforge> oh right, it would just lift the throwError through
13:14:14 <Toxaris> elaforge: the idea of the mtl is to lift the interfaces of the inner monads to the wrapping monad transformers
13:14:57 <Toxaris> elaforge: if you introduce your own transformers, you have to produces these boilerplate instances lifting all possible (or interesting) MonadWhatever classes
13:15:23 <elaforge> yeah, I've been using newtype deriving for that
13:15:38 <elaforge> but I can't derive MonadError because then where do I get the exception type argument?
13:15:59 <Toxaris> elaforge: I think that's the problem, newtype deriving does not work for polymorphic exception types here
13:16:17 <roconnor> LoggerT m outght to be an instance of MonadError when m is an instance of MonadError.
13:16:45 <elaforge> I see, so I write it by hand, and do the run, extract vals, repack thing?
13:16:59 <Toxaris> elaforge: no you just need lift I think
13:17:10 <Toxaris> elaforge: but i'm not sure
13:17:16 <elaforge> even for catchError?
13:17:18 <roconnor> Toxaris: catch is pretty complicated
13:17:19 <JamesR> Right, thank you for your help - I will certainly return with my sloppy coding antics tommorow
13:17:25 <elaforge> that's the problem I had that started the whole thing...
13:17:36 <Toxaris> yeah I see, catch is pretty complicated
13:17:39 <roconnor> what is LoggerT
13:17:49 <elaforge> type LoggerM w m = Writer.WriterT (DList.DList w) m
13:17:49 <elaforge> newtype Monad m => LoggerT w m a = LoggerT (LoggerM w m a)
13:17:49 <elaforge>     deriving (Functor, Monad, Trans.MonadIO, Trans.MonadTrans)
13:17:49 <elaforge> run_logger_t (LoggerT x) = x
13:17:51 <Toxaris> but LoggerT is a renamed WriterT
13:17:58 <Toxaris> so you can use WriterT's MonadError instance
13:18:14 <Toxaris> I guess
13:18:32 <roconnor> can't we use deriving to make an MonadError instance for LoggerT?
13:18:33 <byorgey> JamesR: sure, see you tomorrow
13:18:44 <elaforge> roconnor, well, then what type should the exception be?
13:18:49 <byorgey> JamesR: there's nothing wrong with learning =)
13:18:56 <roconnor> elaforge: oh right, I see
13:18:56 <Toxaris> roconnor: I think the problem is that we want an instance transformer polymorphic in the exception type
13:19:05 <roconnor> so you have to write the instance by hand
13:19:08 * JamesR bows out
13:19:09 <roconnor> okay
13:19:21 <elaforge> but like he said, this really is just WriterT
13:19:23 <roconnor> elaforge: but your instance for LoggerT will be easier to write
13:19:53 <roconnor> you just have to unwrap/wrap LoggerT and call catchError that you get with WriterT
13:22:11 <elaforge> instance Error.MonadError e LoggerT where
13:23:08 <elaforge> brain hurts
13:23:14 <Toxaris> instance (Monoid w, Error e, MonadError e m) => MonadError (LoggerT w m) where throwError = LoggerT . throwError; catchError (LoggerT x) handler = LoggerT (catchError x (runLoggerT . handler))
13:23:21 <roconnor>  instance ... catchError (LoggerT m) handler = LoggerT (catchError m (runLoggerT . handler))
13:23:23 <Toxaris> something like this
13:23:43 <roconnor> Toxaris: I concur
13:23:54 <elaforge> checking it out...
13:24:08 <roconnor> newtype LoggerT w m a = LoggerT { runLoggerT :: LoggerM w m a }
13:24:38 <roconnor> this allows you to define the consturctor (Logger T) and the projection function (runLoggerT) at the same time.
13:25:04 <Toxaris> roconnor: remote pair programming?
13:25:05 <elaforge> yeah, I saw that idiom, but opted out for some reason.  I guess it's not a bad idiom :)
13:25:41 <elaforge> it's awesome, not like there are a lot of haskell programmers around here I could ask...
13:26:07 <roconnor> elaforge: well, so long as you defined runLoggerT one way or another.
13:26:47 <Toxaris> elaforge: what's the point in introducing these newtypes in the first placE?
13:26:58 <Toxaris> elaforge: couldn't you just use LoggerM?
13:27:14 <elaforge> Toxaris, the idea was to restrict the operations to what's exported from the module
13:27:21 <elaforge> but in practice, yeah, I could do without that
13:27:33 <gwern> I was astounded and disgusted to realize recently that haskell.org still offers CVS hosting
13:27:34 <gwern> and that people still use it!
13:27:40 <geezusfreeek> :o
13:27:42 <Toxaris> elaforge: but if you want to restrict operations, you maybe should not derive all these instances
13:27:59 <Toxaris> but instead write your own typeclass in a mtl-like style, containing exactly the operations you want to expose
13:28:23 <geezusfreeek> that is an unfortunate thing about type classes in haskell, that they are global in nature :(
13:28:27 <elaforge> well, it was my understanding that the derivations allow you to lift whatever through, even IO, but don't give direct access to the implementation
13:28:42 * gwern realized this as I painfully tried to download the CVS of the haskell-mode package for emacs
13:29:05 <Elly> wait, people still use CVS?
13:29:07 <Toxaris> elaforge: hmm ok yes that's true
13:29:11 <Elly> wasn't that made illegal a while ago?
13:29:38 <elaforge> Elly, I hear some people still use emacs too :P
13:29:40 <gwern> Elly: yes, and no
13:30:24 <SubStack> people don't use emacs, emacs uses them!
13:31:46 <gwern> I would use Yi, but we keep having issues with libraries
13:32:13 <gwern> between needing a darcs version of cabal, and the bytestring linking problems, even a would-be dev like myself is intimidated
13:32:17 <elaforge> Toxaris, MonadError (LoggerT w m) gets kind errors, I guess because it's partially applying the value type...
13:32:40 <Toxaris> MonadError e (LoggerT w m)
13:32:44 <geezusfreeek> is happily being used by emacs right now
13:33:21 * roconnor edits haskell with kate.
13:33:40 <bos> haskell edits me.
13:33:55 <elaforge>     Illegal instance declaration for `Error.MonadError e (LoggerT w m)'
13:33:55 <elaforge>         (the Coverage Condition fails for one of the functional dependencies;
13:33:55 <elaforge>          Use -fallow-undecidable-instances to permit this)
13:33:56 * Lycurgus where I work they use CVS and I was told if any other RCS was to be used, I'd have to "sell" it. So, of course happy to use CVS in such cases.
13:34:39 <gwern> CVS is old and broken; subversion is better than that, and darcs better than that
13:34:41 <roconnor> elaforge: Toxaris has a small error
13:34:41 <Toxaris> elaforge: seems to be harder then expected
13:34:49 <roconnor> should be
13:34:52 <roconnor> instance (Monoid w, Error e, MonadError e m) => MonadError e (LoggerT w m)
13:35:12 <Lycurgus> if CVS is "broken" darcs surely is
13:35:20 <roconnor> elaforge: oh wait, you caught that
13:35:21 <Toxaris> roconnor: I already added the "e" seperately
13:35:35 <geezusfreeek> i am a heretic here because i prefer git over darcs
13:35:38 <gwern> how is darcs broken?
13:35:39 <Lycurgus> i think "braindead" is what you want for CVS
13:35:41 <elaforge> yeah, that's what drags in the mptc type stuff
13:35:42 <roconnor> you probably don't need the Monoid w bit.
13:35:56 * roconnor ponders the error message
13:36:25 <Toxaris> roconnor: I guess you need it because of (class Monad m => MonadError e m) and instance Monoid w => Monad (WriterT ...)
13:36:32 <elaforge> I actually got some requests to add XFlexibleInstances and XMultiParamTypeClasses too
13:36:38 <Elly> gwern: bzr :D
13:36:55 <gwern> geezusfreeek: no, using git is not heretical - it's penance
13:36:55 <roconnor> Toxaris: oh
13:37:19 <Toxaris> roconnor: my syntax is somewhat crappy but I rely on a fuzzy parser on your site
13:37:26 <geezusfreeek> gwern: :)
13:37:36 <roconnor> elaforge: try removing Error e
13:37:46 <gwern> Elly: bzr is so odd and obscure I don't even know the proper way to castigate it/you
13:37:56 <elaforge> same issue
13:37:56 <Elly> exactly!
13:38:05 * Toxaris goes into state 2 of #haskell code discussion: trying out ideas at home
13:38:15 <geezusfreeek> "bzr is so odd and obscure I don't even know the proper way to castrate you"
13:38:27 <roconnor> elaforge: what is your instance declaration line?
13:38:29 <Elly> it's like using a window manager or editor nobody has heard of - nobody can make fun of you for it :)
13:38:54 <elaforge> now, it's
13:39:00 <elaforge> instance (MonadError e m) => MonadError e (LoggerT w m) where
13:39:03 <geezusfreeek> ^ is how i read it the first time
13:39:11 * gwern urticates Elly with a ??? of perplexity
13:39:25 <roconnor> elaforge: okay put back in the Monoid thing. :P
13:39:26 <geezusfreeek> gwern: you are all about vocabulary today, aren't you?
13:39:31 <geezusfreeek> and yesterday
13:40:00 <roconnor> elaforge: the sources in the MTL also require undecidable instances
13:40:08 <gwern> geezusfreeek: ...you hae an interesting vocab there, but I used castigate correctly
13:40:09 <gwern> @wn castigate
13:40:10 <lambdabot> *** "castigate" wn "WordNet (r) 2.0"
13:40:10 <lambdabot> castigate
13:40:10 <lambdabot>      v 1: censure severely; "She chastised him for his insensitive
13:40:10 <lambdabot>           remarks" [syn: {chastise}, {objurgate}, {chasten}, {correct}]
13:40:10 <lambdabot>      2: inflict severe punishment on
13:40:11 <roconnor> elaforge: so I guess we will have to live with it.
13:40:23 <gwern> @wn castrate
13:40:24 <lambdabot> *** "castrate" wn "WordNet (r) 2.0"
13:40:24 <lambdabot> castrate
13:40:24 <lambdabot>      n : a man who has been castrated and is incapable of
13:40:24 <lambdabot>          reproduction; "eunuchs guarded the harem" [syn: {eunuch}]
13:40:24 <lambdabot>      v 1: deprive of strength or vigor; "The Senate emasculated the
13:40:26 <lambdabot> [8 @more lines]
13:40:26 <geezusfreeek> gwern: i wasn't correcting. i was stating how i read it
13:40:35 <elaforge> holy cow it loads
13:40:37 <gwern> geezusfreeek: dude, my vocab switch - it has one setting. ON
13:40:56 <elaforge> gwern, urticate was the new one for me, that's a good one
13:41:01 * gwern is a spiritual brethren of Tycho of Penny Arcade, ken?
13:41:04 <roconnor> elaforge: no error?
13:41:11 <elaforge> roconnor indeed
13:41:17 <roconnor> oh good
13:41:26 <roconnor> elaforge: see, haskell is easy :P
13:41:33 <elaforge> I have to run, so I can't check if it works with the other parts right now, but thanks so much
13:41:45 <elaforge> yeah, exception handling in haskell is... um... not as easy as python
13:42:00 <popcorn> don't use exceptions
13:42:06 <Elly> gwern: 'brethren' is plural, is it not?
13:42:19 <gwern> elaforge: it is. I like to use it in part because I enjoy reading things on urticator.net, so it's kind of a tribute
13:42:20 <popcorn> elaforge: anyway things like the Maybe Monad are easy to use
13:42:35 <Elly> Maybe is a monad? o_O
13:42:37 <gwern> Elly: what's the singular then?
13:42:42 <elaforge> popcorn, then I'd have to case on Either on every single call, and I have lots of those
13:42:50 <roconnor> @src return Maybe
13:42:51 <lambdabot> Source not found. My pet ferret can type better than you!
13:42:55 <roconnor> @src Maybe return
13:42:56 <lambdabot> return              = Just
13:43:01 <gwern> @wn brethren
13:43:01 <lambdabot> *** "brethren" wn "WordNet (r) 2.0"
13:43:01 <lambdabot> brethren
13:43:01 <lambdabot>      See {brother}
13:43:01 <lambdabot>  
13:43:01 <lambdabot> *** "brethren" wn "WordNet (r) 2.0"
13:43:01 <roconnor> @src Maybe (>>=)
13:43:03 <lambdabot> [18 @more lines]
13:43:04 <popcorn> elaforg: no
13:43:05 <lambdabot> (Just x) >>= k      = k x
13:43:07 <lambdabot> Nothing  >>= _      = Nothing
13:43:21 <popcorn> elaforg: It's actually totally transparent due to do notation
13:43:28 <gwern> elaforge: sure. you can put stuff *into* it - 'Just foo', you can take stuff *out* of it - case a of Nothing -> ..., and you can write functions which are lifted into maybe
13:43:59 <gwern> Elly: if 'brethren' is a synonym of 'brother' - do you still think it plural?
13:43:59 <roconnor> popcorn: only Either String is totally transparent AFAIK
13:44:22 <elaforge> popcorn, oh right, but then I wind up putting in lifts to avoid nested monad notation, which is what exceptions basically are
13:44:47 <mauke> gwern: brethren means brothers
13:44:52 <Elly> gwern: I thought 'brethren' was an archaic plural form of 'brother'
13:44:52 <byorgey> Elly: Maybe is the monad of possible failure.
13:44:55 <elaforge> not the IO version of course
13:44:59 <popcorn> elaforg: do you?
13:45:06 <byorgey> Elly: that is, a computation in the Maybe monad might return or a result, or it might fail.
13:45:09 <Elly> apparently I am not correct, though
13:45:09 <popcorn> I've never seen that
13:45:18 <Elly> I just looked it up and it can also mean singular brother
13:45:30 <Elly> byorgey: oh
13:45:30 <mauke> Elly: not in my dictionary!
13:45:37 * gwern sighs and pulls out my photoreduced OED
13:45:49 <byorgey> haha, the kind that comes with a magnifying glass? =D
13:45:56 <elaforge> popcorn, yeah, in many places, though the lifts are hidden behind an instance
13:46:41 <gwern> byorgey: yes. it's awesome. I love it so much
13:47:13 <gwern> with its aid, my family has learned a long time ago that arguing with me over vocab is otiose, to say the least
13:47:20 <byorgey> gwern: my wife and I looked into getting one of those, but they they are fricking expensive.
13:48:11 <gwern> byorgey: I consider the ~250USD to be well worth it; the full scores strong volume set is even more fricking expensive
13:48:31 <byorgey> I bet
13:49:01 <byorgey> well, maybe someday
13:49:25 <gwern> (web subscription is cheaper, but impermanent and just not as satisfying; and the incomplete smaller editions... well, really. what's the point of a concise or reduced OED?)
13:49:37 <byorgey> in the meantime, if anyone ever happens to feel like giving me a $250 gift instead of a ++ ...
13:50:36 <sethk> byorgey, I hope you aren't waiting desparately for someone to take you up on that ...
13:50:45 <Toxaris> roconnor, elaforge: newtype deriving seems to do the job quite fine. this works: http://hpaste.org/7460
13:50:58 <Toxaris> roconnor, elaforge: ("works" as in "typechecks")
13:51:20 <gwern> (isn't byorgey one of those writing the haskell book? just tell o'reilly to send his royalties as books :)
13:51:37 <dons> byorgey: you're writing a book for o'reilly now?
13:51:42 <dons> real world xmonads?
13:51:53 * byorgey chooses not to quash the rumor just yet
13:52:11 <dons> i'd like an option on the movie rights
13:52:14 <dons> what's your rate?
13:52:34 <gwern> my xmonads - let me shows you dem
13:52:43 <byorgey> um... 3000 rpm?
13:52:43 <Toxaris> roconnor, elaforge: I'm sorry, my "this cannot work because the derived instance cannot be polymorphic in e" have lured us on a wrong trail, as it seems
13:53:53 <byorgey> maybe I should write a book called "Real World #haskell"
13:54:36 <byorgey> with chapters on effective lambdabot use, helping newbies, hpaste, the proper etiquette for ++ing...
13:54:57 <Toxaris> byorgey: there is an etiquette for ++ing?
13:55:07 <byorgey> Toxaris: there will be after I write my book
13:55:10 * Toxaris looks forward to byorgey's book
13:55:23 <gwern> byorgey: exploring practical use of lambdabot, and how to troll for help?
13:56:00 <gwern> byorgeys-book++
13:58:20 <sethk> just don't let them put "for dummies" in the title
13:59:05 <byorgey> Chapter 9: What To Do When People Are Talking About Strong Hylozygomorphism Trifunctor Transformations And You Are All Like WTF!?
13:59:16 <byorgey> Step 1: Don't Panic!
13:59:26 <geezusfreeek> lol
13:59:39 <geezusfreeek> dude i totally want to see that book
14:00:10 <thoughtpolice> dons: after looking at uvector for a little I was wondering - there seems to be no unfoldr-analog. is it something someone just hasn't gotten around to yet?
14:00:36 <thoughtpolice> (I was running random tests and comparing core output on uvector-based programs vs. list-based ones, optionally with the stream-fusion package linked in.)
14:01:22 <Elly> byorgey: I would like to subscribe to your news-letter or periodical
14:01:37 <dons> thoughtpolice: right. there's a  pretty straight forward unfoldr for streams
14:01:53 <dons> thoughtpolice, someone == me.
14:02:02 <thoughtpolice> the main reason I'm wondering is because one of the little tests I was running was the collatz conjecture and it's expressed pretty naturally with an unfold, but without a uvector/ndp analog it's unfair, and in terms of using pattern matching, regular lists actually outperform uvector
14:02:03 <dons> i'm doing a little each day to get it into shape
14:02:16 <dons> ok. i'll add unfoldr now for you :)
14:02:55 <dons> thoughtpolice: could you mail me the example program?
14:02:59 <dons> i'll add it to my test suite
14:03:02 <dons> got my address?
14:03:39 <thoughtpolice> dons: I would send a patch but the Data.Array.Vector.Strict stuff is a little scary - afraid I might severly break the fusion going on, and I would have no idea on how to fix it. :)
14:03:46 <dons> sure.
14:03:48 <thoughtpolice> dons@galois.com right?
14:03:52 <dons> yep
14:04:21 <bos> more RWH chapters, and a reviewer deadline as we start feeding stuff into the publication pipeline: http://www.realworldhaskell.org/blog/2008/05/07/two-new-chapters-and-a-review-deadline/
14:04:22 <lambdabot> Title: Real World Haskell  Blog Archive  Two new chapters, and &#8230; a review deadl ..., http://tinyurl.com/3qr93c
14:04:27 <dons> woot!
14:05:09 <thoughtpolice> dons: normally the list version using pattern matching beats the uvector one by about 2x, but I haven't exactly optimized anything. looking at core though, the uvector version is quite a bit longer (2x) than the list one
14:05:35 <thoughtpolice> and the list version using unfoldr is short, but then again my local function was lambda-lifted-out.
14:06:06 <byorgey> http://haskell.org/haskellwiki/Real_World#haskell
14:06:07 <lambdabot> Title: Real World - HaskellWiki
14:06:24 <byorgey> help me write the outline! ;)
14:06:40 <bos> thoughtpolice: you're writing an unfoldr analogue for uvector?
14:06:42 <dons> chapter 9 should be addressed to edwardk
14:06:59 <thoughtpolice> bos: no, i'm too intimidated :p
14:07:09 <dcoutts> gwern: btw, I'd like you get you to test drive cabal-install's new dependency resolving / installation planning stuff some time in the not too distant future
14:07:21 <dons> thoughtpolice: the main issue is, as usual for strict things, that its a good idea to bound the unfoldr
14:07:29 <dons> like Data.ByteString.unfoldN
14:07:42 <byorgey> dons: it already is ;)  (affectionately, of course, I happen to like hylozygomorphism trifunctor transformations)
14:07:48 <dons> :)
14:08:11 * Elly just recently started doing the Project Euler problems in haskell and is enjoying them immensely so far
14:08:22 <dcoutts> gwern: I'm especially aiming to tackle those tricky cases with inconsistent versions of dependencies
14:08:29 <gwern> dcoutts: how new is this stuff?
14:08:42 <geezusfreeek> i should really do some more project euler problems sometime
14:08:47 <geezusfreeek> i did maybe 15 and then stopped
14:09:13 <thoughtpolice> dons: actually since the code/output is pretty short, you mind if I just hpaste it?
14:09:19 <byorgey> Elly: yes, those are fun. =)
14:09:20 <dons> thoughtpolice: go for it
14:10:12 * byorgey leaves a big plate of lambda-shaped peanut butter cookies before heading home
14:10:24 <bos> redditors, please vote up http://reddit.com/info/6ijoj/comments/
14:11:28 * geezusfreeek votes up
14:11:56 <popcorn> ghci> putJValue (JBool True)
14:11:56 <popcorn> trueghci> putJValue (JString "foo")
14:12:03 <popcorn> maybe missing newline
14:12:08 <Elly> hm
14:12:19 <Elly> I should figure out how to bake lambda-shaped cookies and leave them in the computer lab
14:12:31 <Elly> although we use SML here instead of Haskell :P
14:14:19 <thoughtpolice> bos: done! :)
14:14:35 <bos> thoughtpolice: :-)
14:15:03 <dcoutts> gwern: much is new in the last few days, some more not committed yet and yet more that is not written yet
14:15:35 <dcoutts> gwern: don't expect much immediately, the current status is that in all tricky cases the dep resolver generates invalid install plans
14:16:03 <dcoutts> we've made the install plan system much stricter and now it's time for the dep resolver to catch up
14:16:35 <gwern> dcoutts: well, I'm reinstalling from darcs
14:16:52 <gwern> are there any particular things I should try?
14:17:03 <dcoutts> gwern: at the moment instead of deciding to install stuff and failing it'll refuse to install at all
14:17:11 <dcoutts> so you might class that as a regression :-)
14:18:13 <gwern> fail early doesn't sound bad to me
14:18:16 <gwern> like static typing
14:18:30 <dcoutts> right
14:18:36 <popcorn> > iterate (\x->1+1/x) 1
14:18:39 <lambdabot>  [1.0,2.0,1.5,1.6666666666666667,1.5999999999999999,1.625,1.6153846153846154,...
14:18:52 <IsoPallo> fail early, fail often...
14:19:03 <IsoPallo> Or what I was thinking...
14:19:03 <dcoutts> gwern: though it might be a tad frustrating at the moment since you can't override it and install anyway
14:19:13 <gwern> dcoutts: anyway, so how's the parallel build stuff going, you know?
14:19:24 <thoughtpolice> dons: here's the code and output - http://hpaste.org/7461
14:19:38 <gwern> IsoPallo: fail early, otherwise don't fail at all, is kind of what I hope for
14:19:48 <dcoutts> gwern: do you mean building a single package in parallel or multiple packages in parallel?
14:19:58 * dcoutts is aiming for both
14:20:16 <gwern> dcoutts: former
14:20:22 <gwern> well, that's great, but how the SoC coming along?
14:20:23 <dons> thoughtpolice: i just pushed unfoldU for arrays. fuses wel
14:20:40 <dcoutts> gwern: Saizan is working on the basics of dep style (re-)building
14:20:40 <IsoPallo> gwern: I was thinking the Sierra-games slogan...
14:20:40 <thoughtpolice> dons: i'm thinking of throwing a bit of these results together in a blog post in the next couple of days (as soon as I come up with more example programs to compare with,) if I find anything else interesting or have comments on uvector, I'll let you know.
14:20:42 <geezusfreeek> ooh, unfoldU!
14:20:51 <thoughtpolice> dons: cool! i'll have to check that out as well.
14:21:15 <dons> though if you can avoid printing the array as a list somehow , that might help
14:21:30 <dons> unfoldU :: UA a => Int -> (b -> MaybeS (a :*: b)) -> b -> UArr a
14:21:30 <dons> unfoldU n f z = unstreamU (unfoldS n f z)
14:21:35 <dcoutts> gwern: my impression is that doing it in parallel is not so hard once you've got the basics
14:22:40 <gwern> dcoutts: actually, do you know what I'd like in cabal? some sort of buildInSdist command
14:22:46 <gwern> dcoutts: I notice a fair number of people/users/installers/devs have broken sdist stuff/hackage packages because building and installing from sdist is so uncommon. I have a shell script to do it for me, so I notice it fairly often
14:23:16 <geezusfreeek> this data parallel physics engine is going to be great to see. i may end up using it in this game library i'm still toying with
14:23:45 <geezusfreeek> especially since it seems there are no good C ones which would bind to haskell very elegantly
14:23:45 <dons> thoughtpolice: what value of N do you typically use?
14:24:17 <dcoutts> gwern: yes, like make checkdist
14:24:31 <thoughtpolice> dons: 27, since it produces a fairly long list with the collatz conjecture
14:24:41 <dcoutts> gwern: I'd like to see that too
14:24:47 <dons> is the result 'n' elements long?
14:24:57 <dcoutts> gwern: as 'cabal check' for example
14:25:09 <dons> no, i guess not.
14:25:20 <thoughtpolice> most other things are only in the range of 10-12 elements, 27 is about ~110
14:25:24 <gwern> (the script does like this: 'function build_sdist { clean_configure && sdist && cd dist/ && untar *.tar.gz && cd `ls -t ./ | grep "/" | head -n 1` && clean_configure && build && hinstall; haddock && hinstall; }'; note the length and fragility of it)
14:25:25 <dcoutts> gwern: if you want to open a feature request and describe the behaviour you want and attach your existing script that'd be useful
14:25:29 <gwern> dcoutts: never heard of that, but sounds good
14:26:13 <thoughtpolice> dons: i've pulled the patches; I'll be sure to rebuild and run some more tests. if I come across anything weird/any other regressions (or regression-look-alikes) over the next few days as I write more little snippets I'll let you know.
14:26:16 <gwern> dcoutts: actually, even better would defaulting to building from a sdist tarball; it seem straightforward enough, except for how do you copy the top-level build into the unpacked tarball's dir
14:26:17 <gwern> dcoutts: alright
14:26:37 <dcoutts> gwern: ta
14:27:30 <dons> thoughtpolice: the running times seem very short?
14:28:31 <thoughtpolice> dons: i'll be sure to look through the sources over the next few days too to get a grip on some of the inner parts of the lib and maybe submit some patches for missing things if I find them.
14:28:57 * gwern swoons, nooh, cabal-install has bytestring link problems! argh
14:29:11 * edwardk waves hello.
14:29:17 <geezusfreeek> hello
14:29:19 <dons> thoughtpolice: http://hpaste.org/7461#a1
14:30:36 <dons> thoughtpolice: though they all take 0.004s on my laptop
14:30:39 <dons> i can't really distinguish them
14:30:42 <edwardk> I just wanted to point out that a good point for someone looking to grok more of the intro category theory/foo-morphism stuff would probably by maarten fokkinga's phd dissertation: http://dbappl.cs.utwente.nl/Publications/PaperStore/db-utwente-404F4540.pdf
14:30:43 <lambdabot> http://tinyurl.com/6z8ht2
14:31:12 <dons> thoughtpolice: but treating strict arrays as lists (appendU) et al is usually going to be a bad idea.
14:31:32 <edwardk> er would probably be, not by
14:32:09 <geezusfreeek> edwardk: thanks for linking this, i'll be taking a peek at it
14:33:07 <edwardk> geezus: i started mining through it and have grabbed a couple of typeclasses from the ideas in it already
14:35:04 <geezusfreeek> time to go home
14:38:02 <dcoutts> gwern: oh, btw, there's a new flag to constrain the choices of dependencies when you configure
14:39:19 <thoughtp1lice> dons: btw, what's the int parameter for in unfoldU?
14:39:50 <dons> thoughtp1lice: a maximum size. useful if we're filling an array (since we allocate that much, rather than resizing)
14:40:14 <gwern> dcoutts: hm?
14:40:37 <dcoutts> gwern: eg if you want to configure a package to use bytestring-0.9.0.1 you could cabal configure --constraint 'bytestring == 0.9.0.1'
14:40:58 <dcoutts> constraints are the same syntax as build-depends
14:41:05 <dcoutts> and you can specify as many as you like
14:41:09 <dons> thoughtp1lice: btw, if you can manage to merge the n==0 case into the unfold
14:41:20 <dons> collatz will become a good producer
14:41:25 <dons> and fuse with array consumers
14:41:31 <dons>   print $ sumU $ collatz (read x :: Int) e.g
14:41:36 <dons> will then allocate no arrays
14:41:56 <dons> not that it matters with such a short program,
14:42:50 <gwern> dcoutts: hm. doesn't seem too useful in the bytestring link problem
14:43:56 <dcoutts> gwern: it's only helpful if it's an immediate dependency you want to change
14:44:29 <gwern> ah
14:50:35 <nominolo> dons: http://github.com/nominolo/darcs-to-git/ <-- seems to work rather well now
14:50:39 <lambdabot> Title: nominolo's darcs-to-git at master &mdash; GitHub
14:51:02 <dons> nominolo: oh interesting
14:51:12 <dons> nominolo: can you let simon marlow know
14:51:32 <nominolo> dons: i'm running into the darcs bug now
14:51:42 <dons> ok
14:52:12 <nominolo> dons: so i'm going to try it on freebsd, but i want to update git + darcs first
14:52:16 <edwardk> Hah! i just found the universal half of the cozip/unzip stuff i have been posting the last couple of days in that paper
14:52:39 <thoughtp1lice> dons: how would one manage that? i'm not super familiar with fusion techniques, although I gather that (from the ghc rewrite-rules page) if good consumers take input from good producers, no arrays should be needlessly constructed
14:52:54 <thoughtp1lice> that's about as far as I go, though
14:53:07 <dons> thoughtp1lice: generally, you try to avoid sticking branches between composed stream functions
14:53:10 <dons> of which unfold is one
14:53:16 <dons> so sumU . unfoldU k -- OK
14:53:21 <dons> so sumU . if x then y else unfoldU k -- BAD
14:53:24 <edwardk> Bird's 'abide_F' is unfzip. and his 'abide_B' is unbizip, and his 'coabide' is the uncozip i posted.
14:55:01 <thoughtp1lice> dons: so you only want pure composition - any sort of branching should be dealt with by the function itself?
14:56:46 <thoughtp1lice> dons: btw, in comparison, with the unfoldU version, the time is brought back down considerably to the level of the list versions. :)
14:57:59 <praseodym> I want to write a sum-of-divisors function; but everything I can find seems to be overly complex. any ideas to a simple approach?
14:59:17 <tromp> > sum [d | d<-[1..27], 28 `div` d == 0]
14:59:19 <lambdabot>  0
14:59:24 <Jaak> > let sdivs n = sum $ filter (\x -> x `mod` n == 0) [1..n] in sdivs 100 -- ?
14:59:25 <lambdabot>  100
14:59:28 <tromp> > sum [d | d<-[1..27], 28 `mod` d == 0]
14:59:30 <lambdabot>  28
14:59:40 <EvilTerran> tromp wins :)
14:59:47 <Jaak> heh, same error
15:00:05 <Jaak> oh, nm
15:00:09 <praseodym> interesting approach
15:00:16 <tromp> no, different error
15:00:33 <tromp> i mixed up div& mod, he had wrong order:)
15:00:38 <gwern> @hoogle sum
15:00:38 <lambdabot> Prelude.sum :: Num a => [a] -> a
15:00:38 <lambdabot> Data.List.sum :: Num a => [a] -> a
15:00:38 <lambdabot> Data.Foldable.sum :: (Foldable t, Num a) => t a -> a
15:00:59 <gwern> bleh. everyone beat me to it. lagging FTF!
15:01:14 <praseodym> no standard functions unfortunatelhy
15:01:41 <EvilTerran> everything's a standard function
15:01:47 <praseodym> hehe
15:01:59 <gwern> dcoutts: there's something I noticed. does the cabal-deve list disallow non-subscriber emails?
15:02:01 <EvilTerran> which ones aren't you allowed? sum? filter? div? (==)?
15:02:11 <dcoutts> gwern: yes
15:02:13 <popcorn> @src sum
15:02:13 <lambdabot> sum = foldl (+) 0
15:02:21 <popcorn> just write that
15:02:40 <gwern> dcoutts: ah.that explains why my spelling patch never shows up, even though I've sent it two or three times
15:02:44 <dcoutts> gwern: we used to have them moderated but the rate of spam was too high for the moderator
15:03:00 <dcoutts> gwern: I can add you to a whitelist if you don't want to subscribe
15:03:28 * gwern would appreciate it
15:03:53 <dcoutts> gwern: pm me the email address that the patches would claim to be from
15:03:57 <sw17ch> can some one explain the idea behind liftM to me? i'm using it, and i see what's happening, but i'm not sure how it's happening
15:03:58 <EvilTerran> > let sumDivs x = sd [1..x-1] where sd [] = 0; sd (d:ds) | (x `mod` d == 0) = d + sd ds | otherwise = sd ds in sumDivs 28
15:04:00 <lambdabot>  28
15:04:08 <gwern> dcoutts: gwern0@gmail.com
15:04:16 <dcoutts> 'k
15:04:19 <gwern> (my address is hardly a secret :)
15:04:20 * Zao spoofs a bazillion patches.
15:04:32 <geezusfreeek> sw17ch: do you understand fmap?
15:04:39 <sw17ch> geezusfreeek, no :)
15:04:45 <geezusfreeek> sw17ch: okay then
15:04:49 <geezusfreeek> :t liftM
15:04:51 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:05:44 <geezusfreeek> so liftM takes a function :: a -> r, and also a value in some monad :: m a, and returns a value in the same monad :: m r
15:05:46 <dcoutts> gwern: done
15:05:49 <tromp> @let properDivisors n = [d|d<-[1..n-1],n`mod`d==0]
15:05:50 <praseodym> EvilTerran: same approach as tromp, right? but a lot longer
15:05:51 <lambdabot> Defined.
15:06:20 <geezusfreeek> sw17ch: so say you have a fibonacci function called fib
15:06:25 <tromp> > map (sum.properDivisors) [1..30]
15:06:27 <gwern> dcoutts: thanks
15:06:27 <lambdabot>  [0,1,1,3,1,6,1,7,4,8,1,16,1,10,9,15,1,21,1,22,11,14,1,36,6,16,13,28,1,42]
15:06:34 <EvilTerran> using as few standard library functions as possible
15:06:40 <geezusfreeek> sw17ch: so fib n returns the nth fibonacci number
15:06:50 <sw17ch> geezusfreeek, alright
15:06:59 <geezusfreeek> sw17ch: fib `liftM` return n does exactly the same thing, but in the current monad
15:07:09 <popcorn> > (\n -> filter ((==0).(n`mod`)) [1..n-1]) 360
15:07:11 <lambdabot>  [1,2,3,4,5,6,8,9,10,12,15,18,20,24,30,36,40,45,60,72,90,120,180]
15:07:40 <sw17ch> geezusfreeek, ahhh.... alright. the word "promote" confused me i suppose
15:07:54 <sw17ch> alright, here's the example i'm working with
15:07:56 <geezusfreeek> sw17ch: to paraphrase, if fib n has type Int, then fib `liftM` return n has type m Int
15:08:16 <geezusfreeek> it would be similar to: return $ fib n
15:08:31 <sw17ch> alright...
15:08:40 <sw17ch> so how do liftM[2345] differ?
15:08:59 <sw17ch> i'm sure it's trivial... but the type signatures don't match what i think is happening
15:09:32 <geezusfreeek> i don't see what you mean by liftM[2345]
15:09:36 <dobblego> sw17ch, they call bind N times
15:09:47 <geezusfreeek> oh that
15:09:55 <dobblego> sw17ch, or really, they call bind N-1 times and fmap once
15:10:05 <sw17ch> ah, i just figured it out
15:10:07 <sw17ch> i think
15:10:08 <sw17ch> :)
15:10:13 <sw17ch> :t liftM3
15:10:15 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
15:10:26 <geezusfreeek> sw17ch: think of liftM2 as doing the same thing liftM does, but for a function of 2 arguments instead of just 1
15:10:29 <sw17ch> yeah, i see it now... wow, that was much simpler than i was making it
15:11:31 <sw17ch> thanks
15:11:34 <sw17ch> geezusfreeek++
15:11:36 <sw17ch> dobblego++
15:11:40 <dobblego> np
15:12:03 <Botje> @. pl src liftM
15:12:03 <lambdabot> (line 1, column 1):
15:12:03 <lambdabot> unexpected end of input
15:12:03 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
15:12:45 <dobblego> ?type \f m1 m2 -> m1 >>= \x -> m2 >>= \y -> return (f x y) -- liftM2
15:12:47 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a -> a1 -> b) -> m a -> m a1 -> m b
15:13:42 <dobblego> ?type \f m1 m2 -> m1 >>= \x -> (\y -> f x y) `fmap` m2
15:13:44 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m, Functor m) => (a -> a1 -> b) -> m a -> m a1 -> m b
15:14:26 <dobblego> ?type \f m1 m2 m3 -> m1 >>= \x -> m2 >>= \y -> m3 >>= \z -> return (f x y z) -- liftM3
15:14:28 <lambdabot> forall (m :: * -> *) a a1 a2 b. (Monad m) => (a -> a1 -> a2 -> b) -> m a -> m a1 -> m a2 -> m b
15:15:10 <tahir_hh> Hi, I am looking to write a COM component and I am wondering what is the best way to go about it
15:16:00 <tahir_hh> I am thinking of HDirect but I would like the most maintained, most "official" one
15:16:17 <gwern> dcoutts: http://hackage.haskell.org/trac/hackage/ticket/274
15:16:18 <lambdabot> Title: #274 (Add a 'build from sdist tarball' feature) - Hackage - Trac
15:16:30 <dcoutts> gwern: ta
15:19:18 <praseodym> is it possible to make filter stop at the first true evalutation of its function?
15:19:18 <dons> thoughtp1lice: yeah, i'd hope they'd be either the same, or a little better in the vector case (due to unboxed pairs)
15:19:30 <dons> praseodym: takeWhile . filter ?
15:19:36 <dons> (i.e. just use laziness)
15:19:46 <gwern> hm. if haddock says 'no documentation to generate', should that be an error? it seems to currently treat that as a success
15:19:46 <mauke> praseodym: take 1 . filter
15:20:04 <praseodym> mauke: ty :)
15:20:05 <dons> ah yes, *first true evaluation*
15:20:13 <dons> so that's find isn't it?
15:20:14 <dons> :t find
15:20:16 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
15:20:28 <dons> :t take 1 . filter
15:20:30 <lambdabot>     Couldn't match expected type `[a]'
15:20:30 <lambdabot>            against inferred type `[a1] -> [a1]'
15:20:30 <lambdabot>     Probable cause: `filter' is applied to too few arguments
15:20:43 <Bonus> filter returns a function
15:20:49 <Bonus> take 1 takes a list
15:21:00 <dons> :t take 1 . filter ?f
15:21:02 <lambdabot> forall a. (?f::a -> Bool) => [a] -> [a]
15:21:27 <dons> :t maybeToList . find ?f
15:21:29 <lambdabot> forall a. (?f::a -> Bool) => [a] -> [a]
15:22:09 <thoughtp1lice> dons: btw I made a note about your good producer/consumer input; the easiest way off the top of my head would simply be to eliminate the 0 pattern match case and let it fall to the local function (perhaps producing an empty array,) but I'll look into using both versions with a consumer like sumU or something and examining the core output to check if fusion happens. a fun exercise, I guess. :)
15:22:25 <dons> thoughtp1lice: i wonder if we can use a fusible if_
15:22:30 <dons> thoughtp1lice: that would also solve things.
15:22:48 <dons> rewrite if-then-else to ifStream
15:23:29 <praseodym> dons: ghci says 'find' is not in scope?
15:23:36 <dons> pastorn: in Data.List
15:23:39 <dons> :hoogle find
15:23:43 <dons> ?hoogle find
15:23:44 <lambdabot> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
15:23:44 <lambdabot> Data.Foldable.find :: Foldable t => (a -> Bool) -> t a -> Maybe a
15:23:44 <lambdabot> Data.ByteString.find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
15:23:49 <praseodym> duh. :)
15:24:43 <thoughtp1lice> dons: also, the ghc-core tool is a pretty nice little thing to have, most definitely. :) i think it would be worthwhile to expand on it a little more -- of the top of my head one thing that would be nice is just to be able to output core and/or asm to a file, so it'd be easier to diff and see where things are changing.
15:25:07 <dons> thoughtp1lice: you can do that from 'less'
15:25:14 <dons> but  yeah, a quick flag would make that work
15:26:17 <thoughtp1lice> in the long run, hyperlinked html would be awesome too like ndm mentioned.
15:26:24 <dons> yeah
15:28:55 <praseodym> and how can I get a 'maybe int' function to always return a int? (i.e. if the function doesn't evaluate, return 1)
15:29:08 <dons> :t maybe
15:29:10 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:29:13 <mauke> :t fromMaybe 1
15:29:15 <lambdabot> forall t. (Num t) => Maybe t -> t
15:29:35 <mauke> @src fromMaybe
15:29:35 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
15:30:13 <praseodym> ?hoogle fromMaybe
15:30:13 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
15:37:00 <Apocalisp> Why is Either not a monad?
15:37:08 <dons> it is
15:37:08 <dobblego> (Either e) is a monad
15:37:22 <dobblego> Either cannot be a monad because it is not well-kinded
15:37:39 <dons> ?src Monad
15:37:40 <lambdabot> class  Monad m  where
15:37:40 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
15:37:40 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
15:37:40 <lambdabot>     return      :: a -> m a
15:37:40 <lambdabot>     fail        :: String -> m a
15:37:59 <dobblego> ?kind Either
15:38:00 <dons> they're parameterised only by an element type
15:38:01 <lambdabot> * -> * -> *
15:38:09 <dobblego> ?kind Either Int
15:38:10 <dons> while Either is both the fail, and 'element' type
15:38:11 <lambdabot> * -> *
15:38:42 <geezusfreeek> @src Either return
15:38:42 <lambdabot> return        = Right
15:38:49 <geezusfreeek> @src Either (>>=)
15:38:50 <lambdabot> Left  l >>= _ = Left l
15:38:50 <lambdabot> Right r >>= k = k r
15:39:18 <ddarius> @djinn a -> Either a b
15:39:19 <lambdabot> f = Left
15:39:23 <ddarius> @djinn a -> Either e a
15:39:24 <lambdabot> f = Right
15:39:25 <Apocalisp> is there any analog for Monad that has kind * -> * -> * ?
15:39:39 <roconnor> @kind Arrow
15:39:39 <ddarius> @djinn Either e a -> (a -> Either e b) -> Either e b
15:39:40 <lambdabot> f a b =
15:39:40 <lambdabot>     case a of
15:39:40 <lambdabot>     Left c -> Left c
15:39:40 <lambdabot>     Right d -> b d
15:39:42 <lambdabot> Class `Arrow' used as a type
15:39:43 <bos> actually, Either e is only a monad for Error e
15:39:48 <roconnor> @kind arrow
15:39:51 <lambdabot> Not in scope: type variable `arrow'
15:40:13 <roconnor> @kind Monad
15:40:16 <lambdabot> Class `Monad' used as a type
15:40:33 <Apocalisp> @kind Monad Int
15:40:35 <lambdabot> Class `Monad' used as a type
15:40:42 <roconnor> @kind Monad IO
15:40:45 <lambdabot> Class `Monad' used as a type
15:40:52 <roconnor> @kind IO
15:40:54 <lambdabot> * -> *
15:40:57 <Apocalisp> ah
15:41:06 <roconnor> @kind (->)
15:41:09 <lambdabot> ?? -> ? -> *
15:42:35 <byorgey> @kind (Monad m) => m
15:42:37 <lambdabot>     `m' is not applied to enough type arguments
15:42:37 <lambdabot>     Expected kind `*', but `m' has kind `* -> *'
15:42:43 <byorgey> hehe
15:43:11 <dolio> @kind GHC.Prim.ByteArray#
15:43:13 <lambdabot> #
15:45:35 <edwardk> dolio: do you think changing from PComonad/PMonad/P* to either MonadB or BiMonad or something like that would be too counter intuitive? the name 'parameterized' has like 3 different connotations, one of which is the 'indexed' notion we have
15:46:04 <edwardk> the plus is that you'd get a more intuitive reason to look in Control.Bifunctor.Pointed for PPointed
15:46:29 <dolio> I'd say go ahead with BiMonad, I guess.
15:46:52 <edwardk> the name makes me wince when i see it, but i don't see a cleaner one
15:47:59 * byorgey suggests Binad
15:48:15 <dolio> But it's not a binoid.
15:48:27 <byorgey> what's a binoid?
15:48:41 <dolio> There's no such thing, as far as I know. :)
15:48:50 <byorgey> oh =)
15:48:59 <edwardk> a binad would likely be something that is binoidal or both a monad and a comonad - a binoid is a bimonoid with the same identity twice =)
15:49:25 <byorgey> hw, what's a bimonoid?
15:49:36 <byorgey> *hm
15:49:38 <dolio> Oh, is a bimonoid a monoid and a comonoid?
15:50:07 <edwardk> A bisemigroup consists of a set of elements and two associative operations. A bimonoid is a bisemigroup which has an identity to each associative operation. A binoid is a bimonoid which has the same identity to the two associative operations.
15:50:18 <IsoPallo> Thay sound like some alien races fron UFO: The enemy unknown...
15:50:32 <MyCatVerbs> dolio: I'm starting to think mathematicians need more prefixes, and to stop using the ones they have in novel contexts so often. ;P
15:51:10 <Apocalisp> there's always di-
15:51:11 <MyCatVerbs> IsoPallo: no way, couldn't be. *Nothing* in XCom is scary once you have flying suits and plasma cannon, whereas the above mathematics will probably never cease to scare the Hell out of me.
15:51:17 * edwardk would prefer a dimonoid, at least that sounds expensive ;)
15:51:46 <MyCatVerbs> Apocalisp: as in "damn mathematicians, use more varied prefixes or di!"
15:51:53 <Vulpyne> Dimonoid: The gift that last forever.
15:51:54 <dolio> Ah, well, I guess that bimonoid does use bi- in a bifunctor-like fashion.
15:51:58 <Apocalisp> haha
15:52:00 <Vulpyne> lasts.
15:52:07 <edwardk> yeah
15:52:11 <dolio> Instead of a bi-Kleisli-like fashion.
15:52:26 <Apocalisp> wow, I just understood that
15:53:08 <MyCatVerbs> edwardk: so, bitwise-or and bitwise-and with the identity element zero, operating on binary strings, form a bimonoid?
15:53:38 <edwardk> hrmm there appears to be a notion of bimonoid: http://www.cirm.univ-mrs.fr/videos/2006/exposes/23/Bruguieres.pdf
15:53:47 <MyCatVerbs> (Or does a semigroup require that an inverse element for every element in the set, or was that a ring?)
15:53:50 <gwern> hm. it seems my quickcheck functions are broken. Curse your sudden but inevitable betrayal, QC 2!
15:53:54 <dolio> 0 isn't the identity for and, is it?
15:54:13 <edwardk> 0 isn't the identity for both, it annihilates for and
15:54:15 <popcorn> > all []
15:54:15 <lambdabot>  Couldn't match expected type `a -> Bool'
15:54:23 <popcorn> :|
15:54:30 <mauke> > and []
15:54:31 <lambdabot>  True
15:54:32 <dolio> The identity for and is, what, -1?
15:54:34 <praseodym> meh. how can I get a list of all digits in a number, e.g. [4,5,6] for 456?
15:54:40 <mauke> > complement 0
15:54:40 <lambdabot>  Add a type signature
15:54:44 <mauke> > complement 0 :: Integer
15:54:46 <lambdabot>  -1
15:54:52 <edwardk> a semigroup is pretty boring its just associative =)
15:55:01 <mauke> > map digitToInt . show $ 456
15:55:03 <lambdabot>  [4,5,6]
15:55:16 <edwardk> dolio: yeah in 2s complement
15:55:38 <popcorn> > iterate (map ((10*).digitToInt) . show) 1
15:55:39 <lambdabot>   add an instance declaration for (Num [Int])
15:55:54 <praseodym> mauke: what does the $ do?
15:56:00 <mauke> @src ($)
15:56:01 <lambdabot> f $ x = f x
15:56:21 <popcorn> > iterate (map (map ((7*).digitToInt) . show)) [1]
15:56:22 <lambdabot>   add an instance declaration for (Num [Int])
15:56:22 <lambdabot>     In the expression: 1
15:56:26 <dmwit> The purpose of ($) is to confuse newbies. =)
15:56:33 <IsoPallo> Works.
15:56:53 <praseodym> dmwit: :-)
15:57:01 <popcorn> > iterate ((map ((7*).digitToInt) . show)=<<) [1]
15:57:07 <lambdabot>  [[1],[7],[49],[28,63],[14,56,42,21],[7,28,35,42,28,14,14,7],[49,14,56,21,35,...
15:57:37 <mauke> > map digitToInt . show `id` 456
15:57:38 <lambdabot>      precedence parsing error
15:57:40 <lambdabot>         cannot mix `(.)' [infixr 9] and `id' [i...
15:57:40 <mauke> :(
15:57:59 <mauke> > fmap (map digitToInt) show `id` 456
15:58:01 <lambdabot>  [4,5,6]
15:58:26 <dmwit> heh
15:58:37 <edwardk> dolio: been working up another pair of 'traditional' foo-morphisms
15:58:48 <dmwit> > map digitToInt . show $ 456 -- more idiomatic
15:58:49 <edwardk> dolio: trying to work in erwig's synchromorphism
15:58:50 <lambdabot>  [4,5,6]
15:59:03 <mauke> dmwit: er, I already said that
15:59:05 <dmwit> mauke: It took me a few seconds to decode that. =P
15:59:06 <dolio> Geeze.
15:59:08 <popcorn> > [4,5,6] -- shortest
15:59:10 <lambdabot>  [4,5,6]
15:59:28 <praseodym> popcorn: hehe :)
15:59:34 <edwardk> he also has an 'exomorphism' that appears can be viewed as a special case of hylo so can be ignored =)
15:59:39 <dmwit> mauke: Oh, sorry, I guess I don't have enough scrollback.
15:59:42 <mauke> > [4..6]
15:59:43 <lambdabot>  [4,5,6]
15:59:54 <mauke> popcorn: shortester
15:59:57 <edwardk> dolio: http://books.google.com/books?id=alX4rN7Vy3AC&pg=PA146&lpg=PA146&dq=synchromorphism&source=web&ots=Yos4kZwFy_&sig=EyXoKgeUDd95wLvM0NpneFAZMC4&hl=en
15:59:59 <praseodym> so is there a way to shorten the sum function for it: sum (map digitToInt . show $ n)
15:59:59 <lambdabot> Title: Algebraic Methodology and Software ... - Google Book Search, http://tinyurl.com/66gsuq
16:00:00 <popcorn> >:D
16:00:18 <popcorn> :t sum . map digitToInt . show
16:00:22 <lambdabot> forall a. (Show a) => a -> Int
16:00:23 <dolio> I found a .ps I think.
16:00:35 <mauke> praseodym: digitSum = sum . map digitToInt . show
16:00:42 <edwardk> hrmm that appears to have eaten the body part of the link. yeah its available online
16:00:56 <edwardk> its the random access data structures long version paper
16:01:17 <praseodym> mauke: nice one :)
16:01:19 <dolio> Yeah.
16:01:37 <dmwit> ?pl \n -> sum (map digitToInt . show $ n) -- this process can be automated
16:01:37 <lambdabot> sum . map digitToInt . show
16:01:39 <dolio> How do you find all of these?
16:01:40 <edwardk> http://web.engr.oregonstate.edu/~erwig/papers/RandomAccessADT_REPORT.pdf
16:01:42 <lambdabot> http://tinyurl.com/566j57
16:01:55 <dolio> Going through the cites of other papers?
16:01:59 <edwardk> dolio: mostly i got obsessed several months ago and printed out everything worth skimming =)
16:02:11 <edwardk> i circled a bunch of stuff and forgot about it
16:02:13 <praseodym> dmwit: how does it do that??
16:02:22 <mauke> MAGOC
16:02:31 <dmwit> praseodym: It has a couple of rewrite rules that it applies over and over, I think.
16:02:49 <mauke> @unpl sum . map digitToInt . show
16:02:50 <lambdabot> (\ c -> sum (map digitToInt (show c)))
16:03:07 <edwardk> dolio: also found that a lot of interesting stuff (which i needed to parse the erwig paper) was in fokkinga's dissertation
16:03:28 <praseodym> ?pl \n -> fromMaybe 1 (find ((==0).(n`mod`)) (reverse [1..n-1]))
16:03:28 <lambdabot> fromMaybe 1 . ap (find . ((0 ==) .) . mod) (reverse . enumFromTo 1 . subtract 1)
16:03:52 <praseodym> right :)
16:04:01 <edwardk> including the definitions i reinvented for unfzip and uncozip as 'abide' and 'coabide'
16:04:04 <mauke> @. unpl pl \n -> fromMaybe 1 (find ((==0).(n`mod`)) (reverse [1..n-1]))
16:04:05 <lambdabot> (\ e -> fromMaybe 1 ((\ h i j -> i >>= \ g -> j >>= \ h -> return (h g h)) (\ k -> k) (\ n -> find (\ y -> 0 == (mod n y))) (\ t -> reverse (enumFromTo 1 (subtract 1 t))) e))
16:04:15 <dmwit> praseodym: The point-free version is not always shorter. =P
16:04:40 <praseodym> dmwit: I notice :-)
16:04:41 <mauke> @. type . unpl pl \n -> fromMaybe 1 (find ((==0).(n`mod`)) (reverse [1..n-1]))
16:04:43 <edwardk> one of the fragments i'm playing with is when do 2 bifunctors abide
16:04:44 <lambdabot>     Occurs check: cannot construct the infinite type:
16:04:44 <lambdabot>       a = a1 -> a -> Maybe t
16:04:44 <lambdabot>     Probable cause: `h' is applied to too many arguments
16:05:04 <dmwit> praseodym: reverse [1..n-1] === [n-1,n-2..1]
16:05:18 <dolio> What's his dissertation called? He has too many papers. :)
16:05:39 <praseodym> dmwit: cool. I was trying [n-1..1] but of course that didn't work
16:05:43 <edwardk> http://dbappl.cs.utwente.nl/Publications/PaperStore/db-utwente-404F4540.pdf law and order in algorithmics is also linked off the first article on comonad.com =)
16:05:44 <lambdabot> http://tinyurl.com/6z8ht2
16:05:48 <dolio> Law and Order in Algorithmics?
16:06:00 <edwardk> yeah
16:06:22 <dmwit> :t find
16:06:24 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
16:06:47 <dmwit> praseodym: You may also want:
16:07:02 <dmwit> fromMaybe 1 (find f) ==> head . filter f
16:07:13 <mauke> is it?
16:07:15 <dmwit> (Since you know 1 will pass the filter, this is equivalent.)
16:07:21 <mauke> oh, ok
16:07:53 <praseodym> my other variant was last (filter ((==0).(n`mod`)) [1..n-1])
16:08:03 <dmwit> So, close. =)
16:08:07 <praseodym> I wonder if there's any difference in performance
16:08:18 <dmwit> Head is faster than last in most cases.
16:08:26 <dmwit> (Because you only have to compute the first element.)
16:08:37 <dolio> edwardk: That looks like a pretty good paper. I must say, after reading the Initial Algebraic ... paper, I'm quite taken by how nice the categorical approach to data types seems to be.
16:08:54 <dmwit> With last . filter, you have to test every single element in the list; with head . filter, you only have to test elements until you find one that passes.
16:09:17 <praseodym> dmwit: that was my thought as well. I'll make it:
16:09:28 <edwardk> dolio: i'm fond of parts of it. mostly i'm trying to collect stuff so it can be evaluated without it being scattered over hell and back
16:09:32 <praseodym> head (filter ((==0).(n`mod`)) [n-1,n-2..1])
16:09:48 <edwardk> and coz my obsessive streak won't let me stop
16:09:57 <dolio> :)
16:10:03 <praseodym> head . filter is as efficient as using find, right?
16:10:04 <dmwit> praseodym: Close, but that won't type correctly.
16:10:12 <dolio> He's got other stuff I haven't heard of in here.
16:10:13 <dmwit> praseodym: You could do:
16:10:15 <praseodym> dmwit: actually it works..
16:10:20 <dolio> Mutumorphisms, prepromorphisms...
16:10:31 <dmwit> *blink*
16:10:39 <dmwit> praseodym: Oh, I misparsed the parens, sorry.
16:11:05 <edwardk> mutumorphisms look like zygomorphisms
16:11:06 <praseodym> dmwit: I wonder if I need that many :)
16:11:21 <dmwit> praseodym: If you don't want to use (.) and ($), then yes. =)
16:11:42 <edwardk> and erwig's 'metamorphism' is just a hylo, his exo can be rephrased as a particular subform of hylo
16:11:46 <mauke> @src find
16:11:46 <lambdabot> find p          = listToMaybe . filter p
16:12:01 <mauke> @src listToMaybe
16:12:02 <lambdabot> listToMaybe []        =  Nothing
16:12:02 <lambdabot> listToMaybe (a:_)     =  Just a
16:12:12 <dolio> Isn't meta a reverse hylo?
16:12:26 <dolio> fold then unfold instead of unfold then fold?
16:12:28 <edwardk> dolio: as defined by gibbons
16:12:36 <dolio> Oh, I see.
16:12:43 <dolio> There are two with the same name. :)
16:12:48 <edwardk> dolio: erwig used 'metamorphism' to refer to a subtype of hylomorphism with a common carrier
16:13:06 <edwardk> hrmm, mutu is slightly stronger than zygo
16:13:07 <praseodym> dmwit: :) thanks for the help
16:13:32 <Elly> edwardk: what are you guys talking about?
16:13:53 <popcorn> Elly: http://haskell.org/haskellwiki/Real_World#haskell
16:13:54 <lambdabot> Title: Real World - HaskellWiki
16:13:59 <Elly> ah, thanks :)
16:14:02 <edwardk> elly: various ways to structure recursion basically.
16:14:11 * Elly back to studying for linear algebra exam
16:14:56 <praseodym> Elly: good luck :)
16:15:07 <Bonus> i have linear algebra in a month! :)
16:15:14 <praseodym> popcorn: well, I'm very curious about chapter 9
16:15:18 <Bonus> LA is fun
16:15:30 <praseodym> Bonus: me too. but I'm no good at it
16:16:16 <dolio> edwardk: Well, I've got to leave for a bit. We can talk about prepromorphisms and popromorphisms later. :)
16:16:16 <dmwit> Heh, chapter 7: Keeping yourself amused when \bot is down
16:16:30 <edwardk> dolio: mutu takes (f (a,b) -> a) -> (f (a,b) -> b) -> Mu f -> a
16:16:51 <edwardk> which if you fuse the first two, you get f (a,b) -> (a,b) -> Mu f -> a
16:16:53 <Elly> praseodym: thanks :)
16:16:54 <edwardk> which is kinda boring
16:17:14 <edwardk> er (f (a,b) -> (a,b) -> Mu f -> a, which is just a cata followed by a fst =)
16:17:19 <edwardk> dolio: kk
16:17:53 <dmwit> Mu f is the type-level version of fix f?
16:18:13 <edwardk> dmwit: yeah
16:19:52 <jaj> ok, is there really going to be such an o'reilly book? :)
16:20:10 <mauke> read-write haskell
16:20:37 <Saizan> they'd probably make a serie
16:21:28 <bd_> Oleg-Class Type Logic in Haskell aka the Cthulhu Book
16:22:31 <Pseudonym> The Typonomicon
16:23:28 <mauke> preflex: remember bd_ Oleg-Class Type Logic in Haskell aka the Cthulhu Book  <Pseudonym> The Typonomicon
16:23:45 <bd_> missing <> around bd_ there
16:24:04 <dmwit> guess again
16:24:15 <bd_> oh?
16:24:24 <dmwit> He's missing an entire <bd_> after the bd_ there.
16:24:30 <mauke> preflex: quote bd_
16:24:30 -preflex(n=preflex@d83-191-168-92.cust.tele2.de)- <bd_> Oleg-Class Type Logic in Haskell aka the Cthulhu Book  <Pseudonym> The Typonomicon
16:24:37 <dmwit> bwuh
16:24:41 <dmwit> dmwit: guess again
16:24:49 <Pseudonym> Oh, we have another bot?
16:25:08 <mauke> yes, but it just sits there and listens
16:25:15 <Pseudonym> That's creepy.
16:26:06 * roconnor sits here and listens
16:26:17 <Pseudonym> lurkerbot
16:26:22 <mauke> roconnor: do you also keep track of karma?
16:26:31 <roconnor> yep
16:26:34 <Pseudonym> mauke: Yes, he's lying in wait in that respect.
16:26:46 * Pseudonym accidentally steps on an ant
16:27:43 <mauke> I mostly put it in here because I don't like how lambdabot loses state all the time
16:27:52 <rrrggghhh> can somebody give me an example of when a tree would be useful
16:28:11 <lambdabot> So would you if you had to put up with what I have to put up with.
16:28:20 <mauke> rrrggghhh: why are you asking the same question in multiple channels?
16:28:29 <rrrggghhh> because nobody answered in perl
16:28:33 <Pseudonym> rrrggghhh: I find them useful on a sunny day, for shade.
16:28:39 <preflex> hah!
16:28:46 <rrrggghhh> trees as in, binary trees or threaded trees
16:28:50 <praseodym> kids like them to climb in
16:28:58 <roconnor> rrrggghhh: Data.Seq uses a finger tree
16:28:58 <rrrggghhh> etc
16:29:16 <dmwit> What is a threaded tree?
16:29:27 <astrolabe> I expect Data.Map and Data.Set use binary trees
16:29:36 <Pseudonym> rrrggghhh: A tree as opposed to what?  A hash table, say?
16:29:36 <Elly> you can use them to store dictionaries in a rather elegant manner
16:29:43 <rrrggghhh> yeah
16:29:59 <Pseudonym> A binary search tree stores data in sorted order.
16:30:00 <rrrggghhh> by letter, elly?
16:30:02 <Elly> one example that comes to mind is expression trees
16:30:05 <Pseudonym> So it supports, for example, range queries.
16:30:07 <Elly> rrrggghhh: yep; those are called tries
16:30:11 <rrrggghhh> ooo
16:30:27 <mauke> trees naturally store expressions
16:30:29 <rrrggghhh> so generally for the categorization of a lot of data?
16:30:37 <Elly> they are used for tab-completion because you can just walk down them until you hit the right prefix
16:30:39 <mauke> trees are hierarchical
16:30:47 <Elly> um...most data structures are used for that :P
16:30:53 <rrrggghhh> i imagine ;)
16:30:59 <rrrggghhh> but i mean a lot
16:31:03 <Pseudonym> Chances are, your favourite database server uses B-trees rather than hash tables for most of its indexes.
16:31:03 <ehird> @remember mauke trees are hierarchical
16:31:03 <lambdabot> Okay.
16:31:19 <Elly> file systems also extensively use trees
16:31:19 <ehird> @quote mauke
16:31:19 <lambdabot> mauke says: product `liftM` liftM read `liftM` liftM return `liftM` take 5 $ "1234567"
16:31:24 <Pseudonym> Precisely because you can do more with them.
16:31:29 <rrrggghhh> ext3 inodes kill me
16:31:32 <pjd_> dmwit: a special kind of binary tree that repurposes leaf child pointers to store predecessor/successor pointers
16:31:40 <popcorn> > product `liftM` liftM read `liftM` liftM return `liftM` take 5 $ "1234567"
16:31:41 <Pseudonym> Oh, good example!
16:31:41 <lambdabot>  120
16:31:50 <ehird> what's so odd about that mauke quote?
16:31:54 <Pseudonym> On-disk filesystems use trees to store information about where files are.
16:31:54 <ehird> just lots of liftM abuse..
16:32:03 <pjd_> dmwit: to allow linear traversal
16:32:08 <Pseudonym> The last part of an inode is the root of a tree.
16:32:08 <dmwit> pjd_: Ah, so if you only store info in leaves, traversal is easy?
16:32:09 <dmwit> yeas
16:32:12 <dmwit> yeah
16:32:15 <dmwit> pjd_: Neat!
16:32:37 <rrrggghhh> well i would imagine any hierarchal directory structure would be stored in a tree, yes
16:32:41 <pjd_> dmwit: http://en.wikipedia.org/wiki/Threaded_binary_tree
16:32:41 <lambdabot> Title: Threaded binary tree - Wikipedia, the free encyclopedia
16:32:43 <Pseudonym> Yes.
16:33:02 <Pseudonym> BSD (as well as many other OSes) use Patricia tries to store routing information.
16:33:09 * dmwit dreams of a tag-based file-system.
16:33:17 <Elly> dmwit: logicfs?
16:33:23 <rrrggghhh> dmwit: make it
16:33:28 <popcorn> have you seen zipper fs
16:33:34 <dmwit> No!
16:33:37 <dmwit> And I don't want to.
16:33:38 <popcorn> this is amazing
16:33:47 <dmwit> Most of my dreams would be better kept on my pillow.
16:33:50 <popcorn> it's like a fs made of callcc
16:33:56 <Pseudonym> In fact, a good data structure for routing was what held up the release of Linux 1.0, IIRC.
16:34:05 <Pseudonym> Or rather, the _lack_ of a good data structure.
16:34:14 <Elly> "it's like a fs made of callcc" scares me
16:34:27 <dmwit> pjd_: Oh, so in fact even internal nodes have data.
16:34:44 <dmwit> pjd_: The interesting bit is that traversal doesn't require a stack, right?
16:34:49 <popcorn> hi saml
16:34:51 <dmwit> Even more neat than I thought!
16:34:56 <Pseudonym> So yeah, trees (and their offspring, tries) pervade computer programming.
16:35:09 * popcorn wonders if you got further with your code?
16:35:19 <rrrggghhh> i wonder where i could see exactly how they're written to
16:35:42 <pjd_> dmwit: right
16:36:10 <Pseudonym> rrrggghhh: Just a suggestion, but any introductory book on data structures and algorithms should go through this stuff.
16:36:21 <Pseudonym> There are probably a bunch of them free on the web.
16:43:35 <dmwit> :b from :break to :browse: perhaps the worst UI decision made to date?
16:43:38 <dmwit> Please comment.
16:44:01 <dmwit> ...AND of course I meant "from :browse to :break", not the other way around.
16:44:06 <gwern> Elly: go look at the ZFS PDF, then the source. scary!
16:44:15 <mauke> they broke :
16:44:24 <gwern> on the other hand, ZFS is insanely cool, and I truly wish there were a full-featured version you could use with FUSE or in a shell
16:44:35 <dmwit> mauke: Yeah, that too. =/
16:44:57 <popcorn> I wish I understood callCC and delimited continuations
16:45:00 * gwern hearts the idea of putting the filesystem into memory, with all the power that implies
16:45:02 <mauke> well, : meaning :reload was actually a bug
16:45:22 <dmwit> But it was a useful bug!
16:45:24 <gwern> :break/:browse: threat, or menace?
16:45:48 <SamB> what is the difference between threat and menace?
16:46:05 <SamB> but I hate :b => :break
16:46:06 <pjd_> gwern: woo FreeBSD
16:46:23 <dmwit> SamB: menace can be a verb?
16:46:36 <gwern> pjd_: er,,,
16:46:53 * gwern menaces dmwit for not knowing his english vocab
16:46:56 <SamB> gwern: could you ask a more comprehensible question
16:47:24 <gwern> SamB: jokes are attempts to break the mind of logic
16:47:31 * SamB threatens dmwit with referential opacity
16:47:45 <dmwit> heh
16:48:09 <SamB> hmm, I seem to have answered the actual question posed
16:48:22 <gwern> she threatened me - with science!
16:48:49 <IsoPallo> Threat and menace both imply coersion and all tutorials agree that coersion is bad. Or at least not for you.
16:49:23 <gwern> coercion just means the writer/user has some more proof obligations
16:50:23 <IsoPallo> My instinct tells me that obligations are bad too.
16:50:28 <SamB> IsoPallo: that's only because nobody's written a tutorial on coercions in Coq yet
16:50:31 <dmwit> Therefore... more proof obligations are bad!
16:50:34 <saml> hi popcorn
16:50:40 <gwern> and yet they are necessary for a civilized society
16:51:15 <saml> popcorn: i found the working implementation. but it's out of my league at the moment
16:51:26 <popcorn> saml: did you see the Prolog?
16:52:11 <saml> popcorn: no?
16:52:23 <MyCatVerbs> > fac 52
16:52:24 <lambdabot>   Not in scope: `fac'
16:52:32 <popcorn> saml: http://muaddibspace.blogspot.com/2008/01/type-inference-for-simply-typed-lambda.html
16:52:33 <lambdabot> Title: Muad`Dib: Type inference for The Simply Typed Lambda Calculus, http://tinyurl.com/ynjhl6
16:52:39 <dmwit> Quick, I need a Haskell puzzle to keep me busy?
16:52:41 <dmwit> !
16:52:43 <popcorn> saml: so I started trying to do the logic variables things
16:52:54 <popcorn> saml: but I didn't get it to work either :/
16:53:26 <saml> popcorn: oh thanks. i remember the link.
16:53:47 <saml> i might just rename all lambda bound variables
16:53:50 <MyCatVerbs> dmwit: sort a linked list in O(n) time, given that the elements are enumerable and there are only two dozen possible values?
16:54:01 <MyCatVerbs> Damn. With the factorial function being Haskell's equivalent of "Hello World", I'm amazed that nobody's left a definition of factorial in \bot.
16:54:09 <dmwit> Flashsort! done
16:54:15 <saml> \x -> \x -> ..   ==>  \var1 -> \var2 -> ...
16:54:22 <MyCatVerbs> dmwit: or will you just look that up in the lite-ahh, excellent.
16:54:26 <dmwit> Well... counting sort, or whatever it's called.
16:54:28 <gwern> flashsort? wouldn't it be a bucket sort?
16:54:39 <gwern> (or was that for a range of integers?)
16:55:13 <MyCatVerbs> Damn, damn. 52! is *way* more cycles than I have access to. :)
16:55:15 * dmwit goes off to code it up anyway
16:56:01 <MyCatVerbs> dmwit: okay, I have a harder one.
16:56:12 <MyCatVerbs> dmwit: use unsafePerformIO to implement Spaghetti Sort.
16:56:27 * MyCatVerbs cackles.
16:57:22 <dmwit> I think I'll stick to counting sort. =P
16:57:44 <dmwit> Unless you happen to have a quantumEffect :: IO () primitive lying around?
16:58:09 <pjd_> dmwit: implement slowsort
16:58:13 <dmwit> bogosort
16:58:25 <MyCatVerbs> No, but I'm sure if you try very hard you'll be able to get one of those Honda things to do the kitchen work for you.
16:58:37 <astrolabe> Is there a way of getting an off-line copy of the haskell wiki?
16:58:50 <gwern> astrolabe: wget -r :)
16:59:06 <astrolabe> thanks
16:59:16 <Saizan> wget -r might kill the server :D
16:59:20 <MyCatVerbs> Don't forget to carefully read wget's man-page first.
16:59:22 <pjd_> dmwit: no, http://c2.com/cgi/wiki?SlowSort
16:59:22 <lambdabot> Title: Slow Sort
16:59:28 <pjd_> bogosort isn't deterministic
16:59:45 <MyCatVerbs> There's a whole stack of options that you'll want to give wget, too, to make sure you get something actually usable at the end.
16:59:56 <astrolabe> Ok, I won't do it without thought.
17:00:07 <gwern> astrolabe: but I did once see a db dump of the old haskell wiki, so probably there's something for the new one too
17:00:11 <popcorn> speaking of
17:00:12 <popcorn> http://rosettacode.org/wiki/Bogosort
17:00:13 <lambdabot> Title: Bogosort - Rosetta Code
17:00:19 <popcorn> I just made that page yesterday
17:00:23 <dmwit> pjd_: Heh, that's funny.  "Continue... until the lists have at most one element each, at which point we are forced to surrender."
17:00:47 <pjd_> dmwit: there's a paper, http://portal.acm.org/citation.cfm?id=990534.990536
17:00:49 <lambdabot> Title: Pessimal algorithms and simplexity analysis
17:01:00 <pjd_> which formalizes the notion a bit more
17:01:12 <pjd_> it's pretty nifty
17:01:59 <pjd_> dmwit: for bonus point, convert more of your favorite algorithms to reluctant versions
17:02:05 <MyCatVerbs> "Takes O(n!) in the average case, unbounded time in the worst case. SlowSort is only O(n ^ (lg n)). Of course, SlowSort is O(n ^ (lg n)) in the best case, whereas BogoSort might well succeed on the first pass. SlowSort has the advantage of being deterministic, as well." <-- win, heheh.
17:02:06 <pjd_> e.g. http://www.ivan.fomichev.name/2008/04/reluctant-sorting-algorithms.html
17:02:07 <lambdabot> Title: Codeholic's Codex: Reluctant Sorting Algorithms, http://tinyurl.com/3vgtbm
17:03:33 <gwern> hm. I wonder how I would express 'monotonically increasing' as a quickcheck prop. maybe a map and then fold in a > or something?
17:04:17 <popcorn> increasing (x:y:zs) = x<y && increasing (y:zs)
17:04:42 <MyCatVerbs> foldr1 (\a b -> case b of { [] -> True; (c:_) -> a < c; } ) if you wanted to be disgusting about it.
17:04:42 <popcorn> are props like some subsets of haskell though?
17:04:58 <MyCatVerbs> > foldr1 (\a b -> case b of { [] -> True; (c:_) -> a < c; } ) $ [1..10]
17:04:59 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Bool'
17:05:07 <dmwit> gwern: all (uncurry (<)) . ap zip tail
17:05:13 <MyCatVerbs> Wait, no, that isn't even removely right. Nevermind.
17:05:15 <dmwit> :t all (uncurry (<)) . ap zip tail
17:05:19 <MyCatVerbs> dmwit: thanks.
17:05:21 <lambdabot> forall b. (Ord b) => [b] -> Bool
17:05:47 <MyCatVerbs> @unpl all (uncurry (<)) . ap zip tail
17:05:47 <lambdabot> (\ c -> all (uncurry (<)) ((zip >>= \ e -> tail >>= \ d -> return (e d)) c))
17:05:53 <dmwit> heh
17:06:05 <dmwit> \xs -> all (uncurry (<)) . zip xs (tail xs)
17:06:07 * MyCatVerbs shakes his fist at lambdabot. That didn't help much.
17:06:11 <gwern> ...I think I'll go write my own
17:06:35 <MyCatVerbs> dmwit: I don't have a clue how that parses. More brackets, please?
17:06:44 <dmwit> mmm
17:06:52 <dmwit> It doesn't parse. =P
17:07:03 <dmwit> \xs -> all (uncurry (<)) (zip xs (tail xs))
17:07:10 <popcorn> > (\xs -> null [()|(x,y)<-zip xs (tail xs),x>=y]) [1,2,3,4,5]
17:07:11 <lambdabot>  True
17:07:14 <popcorn> > (\xs -> null [()|(x,y)<-zip xs (tail xs),x>=y]) (reverse [1,2,3,4,5])
17:07:16 <lambdabot>  False
17:07:26 <MyCatVerbs> dmwit: I can see how it works, that's great. \a b -> all [ a < b | a <- l; b <- tail l ] -- I just can't see how the Hell it cometh about.
17:07:39 <dmwit> hehehe
17:07:45 <MyCatVerbs> Er, \l, I mean. I has the dumb today.
17:07:53 * MyCatVerbs kan't Haskell. :(
17:07:56 <dmwit> Well, it would be "and", not "all", in that case.
17:07:59 <dmwit> But yes.
17:08:18 <Botje> @pl \l -> all $ zipWith (<) l $ tail l
17:08:18 <lambdabot> all . ap (zipWith (<)) tail
17:08:33 <dmwit> Oooh, even nicer.
17:09:05 <dmwit> err...
17:09:11 <MyCatVerbs> dmwit: bah. all id, then. ;)
17:09:13 <dmwit> :t \l -> all . ap (zipWith (<)) tail
17:09:15 <lambdabot>     Couldn't match expected type `a -> Bool'
17:09:15 <lambdabot>            against inferred type `[Bool]'
17:09:15 <lambdabot>     Probable cause: `zipWith' is applied to too many arguments
17:09:18 <Botje> uh, yeah
17:09:21 <dmwit> :t \l -> and . ap (zipWith (<)) tail
17:09:21 <Botje> that all should be an and
17:09:23 <lambdabot> forall t a. (Ord a) => t -> [a] -> Bool
17:09:24 <Botje> brainfart.
17:09:28 <dmwit> yeah
17:09:38 <dmwit> And I shouldn't have put the "\l ->" in. =P
17:11:06 <MyCatVerbs> dmwit: see, this is why I could probably never switch to Lisp.
17:11:06 <Botje> :)
17:11:08 <Botje> << ETQW
17:11:16 <MyCatVerbs> dmwit: or at least, if I did, the first couple months would be painful.
17:11:24 <popcorn> what is why?
17:11:27 <dmwit> eh?
17:11:27 <Botje> MyCatVerbs: really only the first hour
17:11:40 <Botje> after that the () kind of fade away and the structure comes out
17:11:46 <MyCatVerbs> Botje: you overestimate my ability to moderate my stupidity.
17:12:05 <Botje> that's why you have ()-matching
17:12:22 <MyCatVerbs> Botje: the brackets thing doesn't phase me at all, it's the switch to dynamic typing, and from there the adjustment to things like typing "all" when I mean "any"
17:12:27 <dmwit> % is the best thing ever
17:12:28 <MyCatVerbs> Er, faze, even.
17:12:35 <dmwit> oh
17:12:42 <dmwit> Yeah, type-checking has saved me a lot of times.
17:12:53 <MyCatVerbs> Botje: the only part of Lisp syntax I do actually dislike is ', it feels kinda ugly. Aside from that, all good.
17:13:01 <Botje> MyCatVerbs: you'll need to do dynamic languages some day
17:13:17 <MyCatVerbs> Botje: whatever for?
17:13:24 <Botje> to assure yourself that statically typed is the way to go and all else is evil =)
17:13:43 <popcorn> CLOS is worth looking at
17:13:47 <popcorn> Kanren is worth looking at
17:13:48 <MyCatVerbs> Botje: I already know that from using C, and I like C.
17:13:54 <Botje> :)
17:13:55 <sw17ch> is there a good way to convert a [Char] to a [Word8]?
17:14:07 <MyCatVerbs> Fucking loss of numerical precision without even fucking warning me, you bastard compiler.
17:14:17 <popcorn> :t map (toEnum.fromEnum) :: [Char] -> [Word8]
17:14:19 <lambdabot> [Char] -> [Word8]
17:14:23 <popcorn> :t map (fromEnum.toEnum) :: [Char] -> [Word8]
17:14:25 <lambdabot>     Couldn't match expected type `Word8' against inferred type `Int'
17:14:25 <lambdabot>       Expected type: a -> Word8
17:14:25 <lambdabot>       Inferred type: a -> Int
17:14:27 <Botje> MyCatVerbs: :D
17:14:33 <sw17ch> popcorn, wow
17:14:35 <sw17ch> that's slick :)
17:14:37 * Botje will be doing CPS conversion this weekend
17:14:42 <popcorn> sw17ch: I stole it from mauke :P
17:15:10 * SamB seems to have re-invented de bruijin numbering (and reinvented how to spell the guys name, too!)
17:15:23 <Botje> re-inventing everything!
17:15:25 <Botje> yaaaaaaay
17:15:35 <SamB> well, see, I was forced into it!
17:15:46 <IsoPallo> You lazy you!
17:15:50 <gwern> @src foldr
17:15:50 <lambdabot> foldr f z []     = z
17:15:50 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:15:55 <dmwit> sw17ch: If it's for using ByteString, just use the Char version of pack.
17:16:19 <dmwit> http://hpaste.org/7462 # MyCatVerbs
17:16:19 <sw17ch> Data.ByteString.Char8 version?
17:16:28 <dmwit> Data.ByteString.Char I think.
17:16:29 <SamB> and also these aren't -abstractions, these are -abstractions
17:16:42 <Botje> moo-abstractions? :)
17:16:50 <gwern> :t foldr (<) 0 $ map s [1..100]
17:16:52 <lambdabot>     Ambiguous occurrence `s'
17:16:52 <lambdabot>     It could refer to either `L.s', defined at <local>:1:0
17:16:52 <lambdabot>                           or `SimpleReflect.s', imported from SimpleReflect at State/imports.h:71:0-32
17:17:05 <sw17ch> dmwit, it's Char8
17:17:11 <glguy> ?type L.s
17:17:12 <gwern> :t foldr (<) 0 $ map id [1..100]
17:17:12 <SamB> type-level fixpoints, in fact
17:17:15 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a] -> [a]
17:17:16 <MyCatVerbs> dmwit: damn that's terse.
17:17:16 <lambdabot>     No instance for (Num Bool)
17:17:16 <lambdabot>       arising from the literal `0' at <interactive>:1:10
17:17:16 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
17:17:24 <gwern> argh
17:17:28 <MyCatVerbs> dmwit: I've seen people blow an evening trying to implement the same in C.
17:17:39 <dmwit> MyCatVerbs: Haskell is amazing, isn't it?
17:17:40 <byorgey> > L.s [1,2,3] [4,5,6] [1,4,7]
17:17:41 <lambdabot>   Not in scope: `L.s'
17:17:50 <byorgey> > s [1,2,3] [4,5,6] [1,4,7]
17:17:50 <lambdabot>  Couldn't match expected type `[t1] -> [t2] -> [t3] -> t'
17:17:56 <MyCatVerbs> dmwit: admittedly, they weren't particularly well taught at C (nor particularly experienced), but yeah.
17:18:00 * byorgey is confused
17:18:02 * gwern wonders why that foldr isn't working
17:18:12 <popcorn> :t (<)
17:18:14 <lambdabot> forall a. (Ord a) => a -> a -> Bool
17:18:17 <dmwit> yup
17:18:20 <popcorn> :t foldr
17:18:22 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
17:18:26 <popcorn> :t foldl
17:18:27 <MyCatVerbs> dmwit: what libraries does that pull in, please?
17:18:28 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:18:36 <popcorn> you can't use either fold
17:18:37 <dmwit> MyCatVerbs: Just Data.Array, sorry.
17:18:46 <popcorn> unless a is Bool
17:18:58 <dmwit> MyCatVerbs: (I was wondering why there was a blank line at the beginning, I must not have copied the entire file.)
17:19:05 <byorgey> > foldr (<) False [True, False, False, True]
17:19:06 <lambdabot>  False
17:19:15 <gwern> popcorn: why? seems like 0 < 1 < 2 < 3... is a fold to me
17:19:23 <MyCatVerbs> dmwit: Ah, cool.
17:19:27 <popcorn>   0 < 1 < 2 < 3
17:19:31 <popcorn> = (0 < 1) < 2 < 3
17:19:32 <byorgey> gwern: 0 < 1 < 2 < 3 ... is not well-typed.
17:19:34 <dmwit> gwern: That first (0 < 1) becomes True, so it becomes True < 2 < 3...
17:19:34 <popcorn> = True < 2 < 3
17:19:34 <MyCatVerbs> dmwit: Oooh, I like accumArray, I should use that more often.
17:19:41 <popcorn> = (True < 2) < 3
17:19:43 <gwern> I have an Int -> Int I want; so should work
17:19:45 <sw17ch> oh, forgot
17:19:46 * MyCatVerbs has been using Data.Map as a golden hammer lately.
17:19:46 <sw17ch> popcorn++
17:20:20 <MyCatVerbs> > [1,1..1]
17:20:21 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:20:29 <gwern> argh. now why did my intuitions lead me astray there to think that'd work?
17:20:30 <dmwit> > [1,1..] -- shorter still
17:20:32 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:20:34 <byorgey> gwern: if you want to test whether a list is strictly increasing, try  and $ zipWith (<) l (tail l)
17:20:38 <popcorn> > fix(1:)
17:20:39 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:20:53 <saml> > let ordered l = sort l == l in ordered [1,2,3,4]
17:20:54 <lambdabot>  True
17:21:00 <MyCatVerbs> dmwit: (repeat 1) is clearer than both. I just like the look of [1,1..1] because it'll confuse people as to what you really meant. :)
17:21:09 <dmwit> heh
17:21:12 <popcorn> oh nice saml
17:21:23 <byorgey> saml's version works too, although doing it with sort is O(n lg n) where as the zip version is O(n).
17:21:42 <dmwit> :t ap (==) sort
17:21:44 <lambdabot> forall a. (Ord a) => [a] -> Bool
17:21:49 <popcorn> let ordered l = bubblesort l == l
17:21:50 <popcorn> :P
17:21:50 <gwern> ah, sort is even clearer
17:21:51 <dmwit> Yes!
17:21:52 <popcorn> O(2n)
17:22:07 <MyCatVerbs> dmwit: plus if you write it on a white board and read it off really fast and then erase it straight away then all people end up coming away with is the phrase "from one to one through one". :D
17:22:08 <popcorn> (although that's only when you have mutation)
17:22:21 <gwern> @hoogle sort
17:22:21 <lambdabot> Data.List.sort :: Ord a => [a] -> [a]
17:22:21 <lambdabot> Data.ByteString.sort :: ByteString -> ByteString
17:22:21 <lambdabot> Data.ByteString.Char8.sort :: ByteString -> ByteString
17:22:33 <byorgey> popcorn: O(2n)?
17:22:48 <byorgey> ITYM O(n^2)?
17:22:50 <popcorn> bubblesort is O(n) when the list is sorted
17:22:52 <dmwit> popcorn: No, I think that's O(n^2).  Imagine the mutation is that the last two elements are swapped.
17:22:59 <dmwit> err...
17:23:00 <popcorn> oh bah
17:23:01 <byorgey> popcorn: yes, but it might NOT be sorted =)
17:23:06 <popcorn> yeah the list wont always be sorted
17:23:18 <MyCatVerbs> It will if our sorts don't have any bugs! ;)
17:23:20 <sw17ch> is there an equivalent  to sizeOf()?
17:23:29 <byorgey> if you know the list will be sorted, then no point in calling ordered on it =)
17:23:32 <dmwit> ?src Data.Typeable
17:23:33 <lambdabot> Source not found. My pet ferret can type better than you!
17:23:34 <popcorn> :t sizeOf
17:23:36 <lambdabot> Not in scope: `sizeOf'
17:23:40 <MyCatVerbs> Even if they don't return before the sun burns out, we'll be able to tell failed tests by how long they take. :D
17:23:43 <popcorn> @hoogle sizeOf
17:23:44 <dmwit> sw17ch: Yes.
17:23:44 <lambdabot> Foreign.Storable.sizeOf :: Storable a => a -> Int
17:24:07 <sw17ch> dmwit: i guess the correct question would have been "What is the sizeof() function in haskell?"
17:24:11 <MyCatVerbs> byorgey: oooh, oooh! sort l = filter ordered (permutations l) -- :D
17:24:20 <byorgey> MyCatVerbs: nice!!
17:24:26 <dmwit> sw17ch: Heh, I was going to try to answer that real question, but popcorn beat me to it. =P
17:24:35 <MyCatVerbs> byorgey: not really, just a straightforward translation from Prolog. ;)
17:24:41 <sw17ch> oh wow, missed it
17:24:43 <sw17ch> ty all
17:24:52 <MyCatVerbs> byorgey: but with the benefit of an additional infinite corecursion! XD
17:25:06 <byorgey> hehe
17:26:33 <gwern> @hoogle Enum
17:26:34 <lambdabot> Prelude.Enum :: class Enum a
17:26:34 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
17:26:34 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
17:27:36 <dmwit> What, no instance (Enum a, Enum b, Bounded b) => Enum (a, b)?
17:27:51 <dmwit> ?more
17:27:54 <gwern> ooh, my first use of GeneralizedNewtypeDeriving in anger!
17:28:01 <bd_> dmwit: I think that's not possible in H98\
17:28:12 <dmwit> =/
17:28:50 <dmwit> There's a really small number of data types that are usable in the countingSort I defined.
17:29:08 <saml> will RealWorldHaskell teach us about writing custom MonadTransformers and undecidable instances and other extensions?
17:29:16 <dmwit> Ix a, Bounded a, Enum a, and small enough that you can make an array of length (maxBound - minBound).
17:29:31 <gwern> dmwit: I've wondered whether the standard libraries define the same slow sort for everything, or occasionally specialized them
17:29:41 <dmwit> same one
17:29:50 <bd_> @source Data.List
17:29:51 <dmwit> Though that may change if associated type families get standardized.
17:29:51 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
17:30:22 * gwern wonders whether any of the shootout entries would benefit from specialized sorts
17:30:32 <bd_> gwern: mergesort for everything in GHC
17:30:45 <saml> oh it already does
17:30:57 <gwern> hm. my increasing property really increases testing time!
17:31:08 <dmwit> Oh, you can derive Ix, so that helps with testing.
17:31:08 <bd_> gwern: I thought the point of the shootout was to compare the obvious way of doing things in each language? :)
17:31:17 <bd_> If non-obvious was encouraged C would win more often
17:31:40 <gwern> bd_: if the base libraries quietly add a faster Integer or Bool sort, does that not improve the obvious way of doing things?
17:31:40 <dmwit> bd_: No, the shootout has lots of examples of non-idiomatic, optimized code.
17:31:56 <bd_> dmwit: Yes, and I'm personally of the opinion that that's a terrible iea :)
17:32:05 <dmwit> Well... me too.
17:32:06 <bd_> gwern: oh, sure, if it's part of the language ,that's fine
17:32:12 <bd_> but there really should be two shootouts
17:32:12 <dmwit> But "idiomatic" is a really hard thing to enforce.
17:32:15 <bd_> an idiomatic one
17:32:26 <dons> raw performance while staying in the language is a reasonable metric
17:32:28 <bd_> and an all-out, no-holds-barred, fight to be the fastest
17:32:35 <MyCatVerbs> bd_: eh, for most of the "slow" languages on there it does provide a repository of "this style will generate unusually fast microcode" code.
17:32:38 <dons> code ugliness leads to peer pressure to clean things up anyway
17:32:39 <dons> so its all good
17:33:13 <jorick> :t (++)
17:33:15 <lambdabot> forall m. (Monoid m) => m -> m -> m
17:33:17 <MyCatVerbs> bd_: which is handy for Haskell, though I have no idea how useful it is for others.
17:33:30 <dmwit> jorick: (++) :: [a] -> [a] -> [a] everywhere but lambdabot.
17:33:46 <jorick> oh
17:34:04 <popcorn> (++) = mappend
17:34:06 <dmwit> \bot has its own little dialect of Haskell. =)
17:34:11 <popcorn> > Just 1 ++ Just 2
17:34:11 <lambdabot>  Add a type signature
17:34:14 <MyCatVerbs> jorick: \bot's maintainer has some... interesting ideas about common types.
17:34:19 <bd_> MyCatVerbs: The thing is, if we give the impression that one has to hand-unroll loops while examining the resulting core, that doesn't reflect well on haskell's ease of use :)
17:34:34 <popcorn> > Just [1] ++ Just [2]
17:34:36 <lambdabot>  Just [1,2]
17:34:44 <popcorn> > [1] ++ [2]
17:34:45 <lambdabot>  [1,2]
17:34:52 <popcorn> MyCatVerbs: It's an improvement
17:34:53 <dmwit> hehehe, countingSort "heyo" takes a while.
17:35:03 <MyCatVerbs> bd_: that *is* what you need to do if you want to get close to C, though.
17:35:29 <MyCatVerbs> dmwit: ...convert it to Word8 first?
17:35:35 <bd_> MyCatVerbs: For certain applications, bytestring's loop fusion does well vs C
17:35:37 <dmwit> Yeah, that would help.
17:35:41 <bd_> We should be showing off that sort of stuff
17:35:46 <glguy> like adding a constant :)
17:35:49 <MyCatVerbs> That's surely going to blow your memory, unless you have a 64bit machine and a lot of swap.
17:36:24 <MyCatVerbs> Or, y'know, one of those terabyte-of-RAM specialized cacheing boxes. :P
17:36:24 <dmwit> What is?
17:36:28 <bd_> MyCatVerbs: and, I mean, if you're going to spend all that much effort optimizing and examing core, to be honest, you might even be better just going straight to C...
17:36:48 <MyCatVerbs> dmwit: trying to sort a [Char] with countingSort, on account of the size of the alphabet.
17:36:54 <dmwit> MyCatVerbs: You mean sorting a String with countingSort?  It actually works fine here on a pretty standard PC.
17:36:57 <bd_> I mean, for libraries it's justified, but applications we should be pushing the easier-to-write-safe-fast-code stuff
17:37:00 <glguy> dons: tell bd_ that just isn't true!
17:37:11 <MyCatVerbs> dmwit: oh, really? I thought Unicode points went out to 2^31?
17:37:13 <dmwit> MyCatVerbs: i.e. 512MB RAM, no special caching.
17:37:25 <dmwit> > maxBound :: Char -- pretty big, yeah
17:37:26 <lambdabot>  '\1114111'
17:37:29 <SamB> MyCatVerbs: not anymore
17:37:38 <SamB> they shrunk the codespace
17:37:38 <bd_> > fromEnum (maxBound :: Char)
17:37:40 <lambdabot>  1114111
17:37:46 <bd_> that's not so bad
17:37:57 <dmwit> Yeah, 4MB of memory.
17:38:19 <dmwit> But you can *see* it traverse the 4MB. =)
17:38:38 <MyCatVerbs> Huh. Who's responsible for that, the Unicode Consortium, or did Haskell implementors just take note of the *actual* limits?
17:38:43 <dons> bd_: the shootout ends up improving our libraries and optimiser
17:38:45 <SamB> dmwit: seee?
17:39:02 <bd_> dons: Sure, that's fine. I just don't think we should be micro-optimizing the benchmark programs
17:39:13 <SamB> bd_: why not?
17:39:20 <dmwit> SamB: There's a visible pause between outputting the last (sorted) character and outputting the '"' termination mark.
17:39:21 <dons> but we must! the shootout pushes on the sore spots
17:39:22 <SamB> as long as we do it in the library and compiler
17:39:22 <bd_> ie, the benchmark programs should look like Real Code that people might write without working too hard at it
17:39:26 <dons> which forces develoment of libraries
17:39:27 <MyCatVerbs> SamB: yeah, use -Sstderr and watch the GC go! ;)
17:39:28 <bd_> dons: Fix the sore spots :)
17:39:31 <SamB> well sure
17:39:37 <bd_> don't cover it up in the benchmark
17:39:40 <MyCatVerbs> (It shouldn't, right? On account of there being so little consing going on, I mean.)
17:39:52 <bd_> fix it in the library and compiler, then show off how much faster GHC 6.10 is than 6.8 on foomark
17:39:55 <dons> bd_: there's no coverups though. go get bytestring or uvector
17:40:02 <dons> all products of the shootout competition
17:40:17 <dons> bd_: this is *exactly* what has happened over the last 4 years
17:40:29 <dons> each ghc release incorporates library and optimiser improvements highlighted by the shootout
17:40:40 <dons> and has been getting faster, at each release, over that time
17:40:42 <dmwit> That's a pretty cool way to look at it.
17:40:57 <SamB> I hope they add a UM to the shootout
17:41:13 <dons> so we sit right at the top of the shootout for pretty much everything now, with programs gradually getting refactored to use nicer libraries
17:41:19 <dons> consider sum-file before and after bytestring
17:41:23 <SamB> because that is a really damn sore spot IMO
17:41:24 <dons> now its both super-fast and super-short
17:41:38 <MyCatVerbs> dons: hrmn. So we could get a quantum-computer interface for GHC by, say, next summer, by adding an entry for integer factorization to the shootout then lying and saying that Perl 7 does a 2000-bit integer with two prime factors in a tenth of second on a 486? :D
17:41:40 <dmwit> SamB: University of Michigan?  Google has nothing else...
17:41:40 <dons> the uvector library will clean up most of the remaining nits
17:41:42 <gwern> wasn't 'after' still slower than clean's?
17:41:44 <dons> which are Double array programs
17:41:51 <SamB> @go cult bound variable
17:41:52 <lambdabot> http://www.boundvariable.org/task.shtml
17:41:52 <lambdabot> Title: ICFP Programming Contest, 2006 : Contest Materials and Task
17:41:59 <dons> gwern: yep. it comes down the the code generator now
17:42:07 <dons> and maybe the Integer parsing routines
17:42:23 <dons> so: shootout good, imo.
17:42:25 <dons> unquestionably
17:42:26 <MyCatVerbs> @hoogle (String -> a) -> ByteString -> a
17:42:27 <lambdabot> No matches, try a more general search
17:42:29 <bd_> use of unsafe* in benchmarks seems like it's hiding a sort spot (lack of uniqueness detection?) in ghc...
17:42:41 <dmwit> SamB: hehe
17:43:09 <gwern> cult of the bound variable....
17:43:09 <dons> bd_: if you think putting it on public display is hiding, then sure.
17:43:11 <bd_> anyway, my point is the optimization work should be focussed on the runtime, not on the individual programs, and in the past it had looked a bit like too much effort was going into the wrong place
17:43:19 <gwern> hey, I could use that as a blog title, if I ever start a blog
17:43:24 <dons> there's a couple of programs that explictily mutate buffers
17:43:25 <bd_> dons: well, I mean, it's not the sort of thing one would normally do as an 'obvious' solution
17:43:29 <dons> which would be safe in Clean
17:43:37 <MyCatVerbs> bd_: there's a practically infinite space of possible optimizations that you could attempt.
17:43:43 <dons> but requires programmer approval in haskell
17:43:55 <dmwit> "Why Compiler Writers Will Never Be Out Of A Job"
17:44:07 <dons> the runtime isn't the bottleneck though
17:44:17 <bd_> runtime/compiler even
17:44:22 <MyCatVerbs> bd_: the shootout is doing an excellent job of highlighting those that would be fruitful to spend time on, since it generally incorporates pretty decent algorithms.
17:44:22 * gwern reads through the quickcheck documentation. still no paralleization?
17:44:29 <dons> the bottlenecks now are: efficient floating point code generaxtion, register allocation, hash tables, and a fast, flexible array library
17:44:32 <MyCatVerbs> gwern: please no.
17:44:44 <dons> all those are being worked on, except the hash table, where we want to use tries
17:44:58 <gwern> MyCatVerbs: it's a cute blog title! and all the othe good ones are taken
17:45:11 <MyCatVerbs> gwern: I know, I know, it might be useful. But please not by default. I want my SMP machine to be able to play DOOM on the other core while the quickcheck runs on the other one.
17:45:12 <dons> anyway, if you notice something on the shootout that looks weird, ask, and see if there's a solution in the works
17:45:15 <dons> for most cases there are.
17:45:19 <MyCatVerbs> gwern: oh, I wasn't complaining about the title.
17:45:51 <MyCatVerbs> dons: tries? Doesn't Data.Map cut the mustard really well already?
17:45:52 <gwern> MyCatVerbs: er, don't you have to ask for parallelism, even if it's working, with the +RTS options?
17:45:53 <dons> i just opened up a bunch of tickets today about math on Double types, for example
17:46:04 <dons> which will specifically address some of the shootout issues where we drop into primops
17:46:09 <MyCatVerbs> gwern: oh. Yes. Of course.
17:46:21 <dons> MyCatVerbs: not for the hashtable benchmark. there are some better Map libs in the works though
17:46:24 * gwern squits
17:46:37 <gwern> dons: didn't you assure me the quickcheck guys were working on adding parallelism?
17:46:50 <MyCatVerbs> Squites? Where I'm from, that's a euphemism for something.
17:46:56 <MyCatVerbs> *Squits
17:46:57 <dons> gwern: sure. i use the parallel driver all th etime
17:47:00 <dmwit> "...with 'A' as the most magnificent byte, and 'D' as the most shoddy..."
17:47:01 <gwern> *squints
17:47:03 <dmwit> =D
17:47:06 <gwern> MyCatVerbs: ...I hesitate to ask
17:47:29 <gwern> dons: this parallel dirver, it's separate?
17:47:51 <MyCatVerbs> gwern: not particularly nasty. You'd want to open a window.
17:48:56 <sw17ch> hmm.... so if i'm using a module (Network.Socket.ByteString) which expects Data.ByteString.Internal.ByteString and i'm using another (Data.Binary) which makes the Lazy version... how do i reconcile the two?
17:49:04 * gwern reads the urban dictionary entry. that explains it quite well enough
17:49:27 <MyCatVerbs> gwern: what did UD say?
17:49:42 <dons> sw17ch: you convert from one to the other with concat . toChunks or fromChunks
17:49:51 <dmwit> MyCatVerbs: Hershey squirts.
17:50:10 <MyCatVerbs> dmwit: I hope you're referring to colour rather than flavour.
17:50:14 <gwern> MyCatVerbs: it claimed squits are where you accidentaly beshitten yourself with overly liquid feces
17:50:27 <dmwit> piratey!
17:50:34 <shapr> @yarr!
17:50:34 <lambdabot> Shiver me timbers!
17:50:42 <dmwit> "Arrr, I be shitten myself afore the mainsail!"
17:50:45 <MyCatVerbs> gwern: ...ohkay. I've honestly never heard it used for accidents, but ah well.
17:50:52 <shapr> eww
17:51:02 <sw17ch> @hoogle fromChunks
17:51:02 <lambdabot> Data.ByteString.Lazy.fromChunks :: [ByteString] -> ByteString
17:51:02 <lambdabot> Data.ByteString.Lazy.Char8.fromChunks :: [ByteString] -> ByteString
17:51:16 <MyCatVerbs> dmwit: no, dammit. No. Just because it's called the "poop deck" does not mean you're allowed to do that there!
17:51:23 <dmwit> sw17ch: How appropriate. =P
17:51:29 <shapr> ugh
17:51:32 <dons> ?yow!
17:51:32 <lambdabot> does your DRESSING ROOM have enough ASPARAGUS?
17:51:35 * shapr goes off to recover from unicycling
17:51:36 <dolio> Man...
17:51:38 <gwern> now he has to swab it
17:51:39 <dmwit> MyCatVerbs++
17:51:58 <sw17ch> :)
17:52:00 <dolio> I came back at the right moment.
17:52:44 <dmwit> "The '0' array shall be the most sublime choice for loading, and shall be handled with the utmost velocity."
17:52:47 <dmwit> indeed
17:56:37 <sw17ch> @hoogle toChunks
17:56:37 <lambdabot> Data.ByteString.Lazy.toChunks :: ByteString -> [ByteString]
17:56:37 <lambdabot> Data.ByteString.Lazy.Char8.toChunks :: ByteString -> [ByteString]
17:58:16 <MyCatVerbs> Why on Earth would one wish to examine the chunks?
17:58:28 <mm_freak> @src product
17:58:29 <lambdabot> product = foldl (*) 1
17:58:36 <gwern> debugging?
17:58:37 <MyCatVerbs> Except for analysis, maybe, for the overly curious. :P
17:58:47 <MyCatVerbs> gwern: fair 'nuff.
17:59:05 <dolio> MyCatVerbs: For writing hand-optimized loops.
17:59:18 <mm_freak> mh  is there a strict version of foldl predefined?
17:59:25 <dolio> foldl'
17:59:30 <MyCatVerbs> mm_freak: foldl' in Data.List
17:59:45 <mm_freak> ah, thanks
18:00:14 <gwern> @hoogle foldl'
18:00:14 <MyCatVerbs> dolio: example, please? I can't think of any sensible ones right now.
18:00:14 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
18:00:14 <lambdabot> Data.Foldable.foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
18:00:14 <lambdabot> Data.ByteString.foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
18:00:28 <dolio> MyCatVerbs: Although, ideally, with good optimizations, that isn't necessary. But one (at least) of dons' shootout benchmarks used that tecnnique.
18:00:39 <dolio> Although I think it got disqualified.
18:00:44 <MyCatVerbs> dolio: heh.
18:00:51 <MyCatVerbs> For that, or for something else?
18:01:14 <davidL> Where is the darcs repo for the next version of hpaste?
18:01:16 <dolio> MyCatVerbs: Essentially. It was supposed to use a standard getLine, and that obviously doesn't.
18:01:30 * MyCatVerbs nods.
18:01:53 <dolio> What he did was do lazy getContents, and then toChunks, and then operate on each chunk in turn, so you're ensured to read in the most optimal way.
18:02:02 <gwern> davidL: I'm not sure glguy has it public
18:02:22 <davidL> oh, hm, well was there a demo of it somewhere?
18:02:31 <mm_freak> i wonder if a purely arithmetical faculty function is faster than product [1..n]
18:02:36 <davidL> I vaguely remember playing around with it
18:02:37 <dmwit> ?where hpaste2
18:02:38 <lambdabot> I know nothing about hpaste2.
18:03:05 <MyCatVerbs> dolio: that sounds pretty spiffy. How does the RTS know what the optimal chunk size to grab is, though?
18:03:25 <MyCatVerbs> dolio: (and how much did he actually gain from doing that?)
18:03:36 <dolio> MyCatVerbs: They did a bunch of testing and then picked the best constant. :)
18:03:40 <gwern> I'm sure on very large numbers multiply 1..n is inefficient, but I doubt it's really noticeable on the small numbers most people deal with
18:04:23 <dolio> MyCatVerbs: I don't know if it's different on different platforms or what. It's supposed to be related to cache size.
18:04:25 <MyCatVerbs> dolio: sensible.
18:05:07 * MyCatVerbs would've presumed something like the page size as a minimum, moving up to half the L1 cache at most.
18:06:08 <dolio> I think dcoutts has said that doing 'getContents >>= lines ...' should provide similar performance these days, so the shootout one may eventually approach the optimized loop.
18:06:19 <dolio> Which is good, because writing the latter kind of sucks.
18:06:26 <MyCatVerbs> Excellent.
18:06:53 <MyCatVerbs> gwern: given a sufficiently smart compiler, multiple 1..n gets reduced to a tight loop anyway. ;)
18:06:54 <gwern> offhand, does anyone know why 'Outputable' and GHC would cause problems when trying to compile with profiling?
18:08:53 <dolio> MyCatVerbs: http://www.cse.unsw.edu.au/~dons/papers/fusion.pdf
18:09:15 <dolio> According to that, chunks that fit in the L2 cache were found to be best.
18:09:25 <gwern> quick show of hands: how many people here are using Darcs-2?
18:09:36 <dmwit> ?index Word32
18:09:36 <lambdabot> Data.Word, Foreign, Graphics.SOE
18:09:48 <dolio> I've used it a couple times, but only to pull.
18:10:45 <gwern> hm. so most of y'all are still on darcs 1.x?
18:15:22 <dolio> Maybe they all switched to git.
18:15:51 <gwern> dolio: :(
18:19:45 <MyCatVerbs> dolio: oh, spiffy. Thanks.
18:20:01 * MyCatVerbs pushes that onto his stack of papers that he's too lazy to read right now. ;)
18:21:46 <gwern> @seen dcoutts
18:21:46 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #haskell-blah, #ghc and #haskell. I last heard dcoutts speak 1h 30m 21s ago.
18:23:38 <dmwit> Oh man.
18:23:48 <dmwit> If I do a getChar, will that get a UTF-8 encoded character?
18:24:11 <SamB> it depends on what module you got the getChar from, I think
18:24:21 <dmwit> Prelude
18:24:33 <SamB> and on what Haskell implementation you are using
18:24:38 <dmwit> GHC 6.8
18:24:43 <dmwit> I guess I could just test it.
18:24:51 <SamB> but in GHC, that generally gets you a byte
18:25:08 <SamB> which is assumed to be in ISO 8859-1
18:26:16 <wagle_home> Prelude> maxBound :: Char
18:26:16 <wagle_home> '\1114111'
18:26:44 <SamB> wagle_home: what are you doing that for?
18:28:51 <gwern> @ask dcoutts what would you make of a cabal patch like this: http://hpaste.org/7463 ? this way, if you run the wrong kind of haddock on a repo, it has an error exit code, not a success, so you can go 'runhaskell haddock || runhaskell haddock --executables' in the shell
18:28:52 <lambdabot> Consider it noted.
18:30:27 <dolio> Char can hold unicode, but the standard IO routines don't read/write unicode, as I recall.
18:30:39 <dancor> @hoogle (a -> b -> c) -> [a] -> [b] -> [c]
18:30:40 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
18:30:40 <lambdabot> Data.List.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
18:30:40 <lambdabot> Control.Parallel.Strategies.parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
18:30:54 <gwern> char is unicode, internally, iirc
18:30:59 <dolio> At least, that's my understanding of the situation. I haven't tried to do it myself.
18:31:34 <dancor> @pl \ f xs ys -> [f x y | x <- xs, y <- ys]
18:31:34 <lambdabot> flip flip (return . (y <-)) . (((.) . (:)) .) . (<-) . (| x) . flip ($ x) y
18:31:49 <dancor> @pl \ xs ys -> [f x y | x <- xs, y <- ys]
18:31:49 <lambdabot> (. (return . (y <-))) . (:) . ((f x y | x) <-)
18:32:35 <SamB> dolio: quite so
18:32:38 <dancor> @type (<-)
18:32:39 <Cale> The @pl command doesn't know about list comprehensions
18:32:41 <lambdabot> parse error on input `<-'
18:32:54 <dancor> Cale: well it did it, right?
18:33:04 <Cale> dancor: It misinterpreted your line
18:33:09 <dancor> oh
18:33:20 <dmwit> heh, (| x)
18:33:23 <SamB> dolio: except I think JHC might do something different, but that's not going to be very hard to change if so...
18:33:55 <Cale> You're looking for liftM2 btw
18:33:57 <dolio> Different like properly handling unicode? :)
18:34:08 <Cale> > liftM2 f [1,2,3] [4,5,6] :: [Expr]
18:34:10 <lambdabot>  [f 1 4,f 1 5,f 1 6,f 2 4,f 2 5,f 2 6,f 3 4,f 3 5,f 3 6]
18:34:12 <dolio> @undo [f x y | x <- xs, y <- ys]
18:34:12 <lambdabot> concatMap (\ x -> concatMap (\ y -> [f x y]) ys) xs
18:34:24 <dolio> @. pl undo [f x y | x <- xs, y <- ys]
18:34:24 <lambdabot> (ys >>=) . flip flip [] . ((:) .) . f =<< xs
18:34:26 <dancor> > liftM2 f [1] [4]
18:34:27 <lambdabot>  Add a type signature
18:35:08 <dolio> @. pl undo \xs ys -> [f x y | x <- xs, y <- ys]
18:35:08 <lambdabot> (. flip ((=<<) . flip flip [] . ((:) .) . f)) . (>>=)
18:35:21 <Cale> heh
18:36:35 <SamB> dolio: well, we still haven't figured out what "proper" is, AIUI
18:36:59 <dolio> Heh, yeah, I get the impression it isn't easy.
18:37:17 * Cale would be happy with consistent use of UTF-8
18:37:20 <dolio> I haven't done much reading on unicode and all that, so I don't really know.
18:37:31 <SamB> Cale: but then there's binary data...
18:37:39 <Cale> SamB: You can use ByteString for that
18:37:41 <SamB> anyway, JHC isn't complete enough for it to be an issue
18:37:58 <dancor> putting binary data in Char is already a waste right
18:38:17 <dancor> instead of [Word8] or something better
18:38:21 <Cale> Char isn't the right type for binary data
18:38:22 <SamB> dancor: it isn't as if Char is any larger than Word8
18:38:33 <SamB> Cale is correct, thouggh
18:38:33 <dancor> SamB: i thought it was?
18:38:54 <Cale> maxBound :: Char
18:38:57 <Cale> > maxBound :: Char
18:38:58 <lambdabot>  '\1114111'
18:39:02 <SamB> dancor: well, an unboxed one could be
18:39:19 <Cale> > fromEnum (maxBound :: Char)
18:39:21 <lambdabot>  1114111
18:39:23 <SamB> but on the heap, they both get rounded to the nearest word...
18:39:46 <Cale> > log (fromIntegral (fromEnum (maxBound :: Char)) / log 2
18:39:46 <lambdabot> Unbalanced parentheses
18:39:49 <SamB> and both types are smaller than any reazonable wordsize...
18:39:50 <Cale> > log (fromIntegral (fromEnum (maxBound :: Char))) / log 2
18:39:51 <lambdabot>  20.087461546321563
18:40:17 <SamB> well, perhaps not on a Reduceron
18:40:29 <SamB> reducerons might have only 18-bit words..
18:41:11 <dancor> they should call it the lolputer
18:41:26 <Cale> How about a machine with words that are log 1114111 / log 2 bits wide? :)
18:42:20 <SamB> Cale: they won't even teach me to design *normal* CPUs uuntil grad school
18:42:59 <Cale> Heh, some kind of machine where the bus is a noisy channel and error correcting codes are used everywhere.
18:43:29 <SamB> nevermind CPUs with nonintegral word sizes
18:43:50 <SamB> I'm not very happy about it :-(
18:44:21 <SamB> how lame is it if you go to school and they won't even teach you the, like, most important thing about your chosen major!
18:44:41 <SamB> it's like if you majored in philosophy and they refused to teach you the meaning of life!
18:46:09 <Cale> SamB: there was a video the other day which was quite informative...
18:46:35 * SamB hopes he isn't about to learn the meaning of the word "rickroll"
18:46:48 <Cale> http://web.cecs.pdx.edu/~harry/Relay/VideoTutorial/index.html
18:46:49 <lambdabot> Title: A Video Tutorial
18:47:04 <QtPlatypus> SamB: They tend to do that.
18:47:07 <SamB> Cale: which is that, the meaning of life or how to design a CPU?
18:47:25 <Cale> That explains the workings of a computer built from 415 relays pretty thoroughly.
18:47:38 <Cale> So, yeah, basic CPU design :)
18:47:54 <SamB> RELAYS?
18:48:08 <SamB> so ... it's an electromechanical CPU?
18:48:08 <Cale> yep :)
18:48:12 <Cale> yeah
18:48:19 <SamB> how retro
18:49:31 <solrize> hey, bn.com is taking preorders for "a romance on three legs" but not for real world haskell :(
18:51:27 <shapr> SamB: You've never been rickrolled?
18:51:32 <SamB> not yet
18:51:44 <shapr> Wow
18:52:14 <SamB> I have looked it up on wikipedia from hearing the word so many times
18:52:17 <kpreid> me either
18:52:26 <SamB> but that doesn't really teach me the actual meaning
18:52:48 * shapr grins
18:53:10 * SamB begins to wish he hadn't mentioned the subject
18:54:55 <Adamant> SamB: don't they have Hennessey and Patterson or something?
18:55:20 <SamB> Adamant: eh?
18:55:31 <Adamant> SamB: your CE program
18:55:40 <SamB> CE program?
18:55:54 <Adamant> you were talking about designing CPU's
18:56:00 <Adamant> I assumed you were a CE
18:56:30 <SamB> My school has an EE program with a graduation rate of around 12 EE/year
18:56:44 <Adamant> ah
18:57:14 <SamB> according to one of the graduating seniors
18:58:27 <Adamant> nice
18:58:40 <Adamant> at least people do graduate
19:00:24 <MUFFASO> hello?
19:00:32 <Adamant> olleh
19:00:54 <MUFFASO> ?wiki Monad
19:00:54 <lambdabot> http://www.haskell.org/haskellwiki/Monad
19:04:11 <dmwit> Bah
19:04:23 <dmwit> monomorphism_restriction--
19:04:36 <popcorn> what if there was no monomorphism?
19:04:40 <popcorn> would life really be better? :P
19:04:49 <dmwit> What if there was no restriction?
19:04:51 <SamB> popcorn: that would be another monomorphism restriction
19:04:52 <saml> popcorn: yay i fixed it!!!!
19:04:54 <dmwit> Then life really would be better.
19:05:13 <popcorn> saml: really? cool!
19:05:15 <SamB> trading the current MR for that MR would make Haskell programming more or less impossible
19:05:16 <MUFFASO> r u bots?
19:05:24 <SamB> only lambdabot is
19:05:25 <saml> debuggin haskell with using only Debug.trace is sooooooooo hard
19:05:30 * dmwit can count on the fingers of 0 hands how many times polymorphism has caused more computation than I wanted
19:05:33 <SamB> well, there might be some other bots lurking
19:05:35 <dolio> Yes, we are all bots.
19:05:43 <MUFFASO> 
19:05:51 <SamB> but they are indistinguishable from lurking humans, to me
19:06:08 <SamB> especially considering the number of people in the channel ;-)
19:06:15 <dolio> preflex: seen SamB
19:06:15 -preflex(n=preflex@d83-191-168-92.cust.tele2.de)- SamB was last seen on #haskell 6 seconds ago, saying: especially considering the number of people in the channel ;-)
19:06:18 <saml> i just replaced   s' @@ s    with s' @@ s  (@@ being composition of type substitution rules). and it worked out alright
19:06:25 <dolio> That's a bot.
19:06:39 <sw17ch> what is the monomorphism restriction?
19:06:49 <saml> man 1 week of blurry eyes. and i finially found the bug
19:07:14 <dmwit> ?wiki monomorphism restriction
19:07:14 <saml> sw17ch: it means i think you only instantiate type variable once
19:07:14 <lambdabot> http://www.haskell.org/haskellwiki/monomorphism_restriction
19:07:23 <popcorn> ummmm
19:07:28 <popcorn> you replaced
19:07:28 <popcorn> s' @@ s
19:07:31 <popcorn> with
19:07:31 <popcorn> s' @@ s
19:07:33 <popcorn> ?
19:07:41 <dmwit> sw17ch: It means that top-level functions are restricted to not be polymorphic, even if they could be.
19:07:42 <popcorn> and that fixed it? :D
19:07:43 <saml> popcorn: no. sorry.  with s @@ s'
19:07:46 <popcorn> ohh ok
19:08:05 <sw17ch> dmwit, eh?
19:08:09 <dmwit> sw17ch: So, for example, "enum = toEnum . fromEnum" gets defaulted to Integer -> Integer, which is slightly less than useful.
19:08:25 <sw17ch> oh, hmmm....
19:08:27 <dolio> Not top level functions. Just definitions of the form 'caf = expression'.
19:08:29 <dmwit> sw17ch: The correct (polymorphic) type is (Enum a, Enum b) => a -> b.
19:08:33 <sw17ch> perhaps i'm thinking polymorphic in the wrong way
19:08:46 <saml> sw17ch: id :: t0 -> t0.  once t0 is initialized to Int because of (id 1),  id 'a'  will fail to unify
19:08:55 <sw17ch> so, then you can't define map in the top level then
19:09:00 <dolio> And they aren't restricted from being polymorphic, just type-class constrained polymorphic.
19:09:06 <dolio> And only if you don't provide a type signature.
19:09:10 <saml> so, you make sure id :: t0 -> t0  where t0 can be instantiated with new type variables
19:09:28 <dmwit> dolio: They are restricted from being polymorphic.  The example I gave is from real life...
19:09:40 <dmwit> It wasn't type-class constrained as I wanted.
19:09:43 <dolio> dmwit: That's type-class constrained polymorphism.
19:09:50 <dmwit> I'm confused.
19:09:58 <dmwit> In what way is "Integer -> Integer" polymorphism?
19:10:42 <sw17ch> so, why isn't it allowed? :)
19:10:52 <dolio> dmwit: Type in a top-level 'map' = \f -> foldr ((:) . f) []'
19:10:53 <dmwit> It's a protection mechanism.
19:10:58 <dolio> That will be polymorphic.
19:11:06 <sw17ch> like the lack of infinite types?
19:11:15 <dolio> The monomorphism restriction only applies to type-class constrained polymorphism.
19:11:27 <sw17ch> hmm... alright
19:11:33 <dmwit> Oh, okay.
19:11:39 <dmwit> I understand now.
19:11:42 <sw17ch> so, on needs to define the polymorphic functions in the class instances then
19:11:50 <dmwit> sw17ch: It protects you from this:
19:11:50 <sw17ch> instead of in top level areas
19:12:00 <dolio> No, you just need to give it an explicit type signature.
19:12:05 <dmwit> (f 0, f 0) -- may compute f twice if 0 and 0 are different types
19:12:49 <dolio> The monomorphism restriction only restricts what types can be assigned by inference.
19:12:54 <dmwit> i.e. let f = someExpensiveCalculation in (f (0 :: Int), f (0 :: Integer)) -- this could potentially be bad
19:13:06 <dmwit> But in reality, I've never had such a bad case occur.
19:13:37 <sw17ch> dmwit, alright. i think i see it now. i guess, since i'm pretty deliberate about my type signatures, that shouldn't bug me too much
19:15:00 <saml> two questions: 1. can I add SomeMoandT to MyMonad ?   2. can I convert MyMonad into MyMonadT ?
19:15:02 <dolio> The most 'realistic' example I can think of is a global list of primes.
19:15:40 <saml> I want to use MyMonad1 in other monads. and also MyMonad2 in MyMonad1
19:15:42 <dolio> If you have 'primes :: Num a => [a]' it'll recompute every time you access the list, but 'primes :: [Integer]' should be memoized.
19:15:52 <SamB> a global list of primes is a bad idea for other reasons
19:16:05 <dolio> True enough. :)
19:16:14 <SamB> actually, recomputing is probably better ;-)
19:16:22 <popcorn> really?
19:16:28 <popcorn> I thought it was a good example of memoing
19:16:31 <popcorn> why is it bad
19:16:39 <SamB> depending on when it happens
19:16:53 <dolio> Depends on what you're doing. You might not want a list of the first 1,000,000 primes clogging up memory for the entire runtime of your program.
19:17:04 <SamB> that's my point exactly
19:18:23 <popcorn> oh I see
19:21:19 <dons> i think this post is pretty good, http://enfranchisedmind.com/blog/2008/05/07/why-ocaml-sucks/  but don't really want to post it.
19:21:19 <lambdabot> Title: Enfranchised Mind  Why Ocaml Sucks
19:21:24 * dons tries to stay vaguely non-partisan.
19:21:32 <dons> someone should put it on reddit :)
19:22:15 <dmwit> ?src zip
19:22:15 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
19:22:15 <lambdabot> zip _      _      = []
19:22:21 <dmwit> Ah, too bad.
19:22:26 <dmwit> ?src zipWith
19:22:26 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
19:22:26 <lambdabot> zipWith _ _      _      = []
19:24:30 <dolio> Huh, ocaml has dangling-else?
19:25:03 <SamB> dolio: dangling?
19:25:18 <chessguy> dolio: how embarrassing
19:25:22 <dolio> Well, if-without-else.
19:25:27 <dmwit> > let foo'a' = 3 in foo'a'
19:25:28 <lambdabot>  3
19:25:30 <dolio> Which leads to ambiguous nested ifs.
19:25:31 <dmwit> > let foo'a' = 3 in foo'b'
19:25:32 <lambdabot>   Not in scope: `foo'b''
19:25:38 <dmwit> Interesting.
19:25:54 <popcorn> > let o'''o = "upside down skull" in ()
19:25:56 <lambdabot>  ()
19:28:02 <wagle_home> haskell sorta has dangling if's and let's in do expressions
19:28:23 <dolio> Not ifs.
19:28:39 <wagle_home> i thought you could (never did it)
19:28:50 <dolio> Nope. Only let is special.
19:29:08 <dmwit> There's "when", maybe you're thinking of that?
19:29:25 <dolio> OCaml also lacks layout, it seems, which would alleviate it a bit, I suppose.
19:30:23 <wagle_home> yeah..  prolly
19:31:28 <SamB> yeah, dangling ifs in dos would be differently typed from non-dangling ones!
19:32:01 <dolio> Although the author seems to be against layout, because he thinks mixed tabs and spaces are a problem.
19:32:02 <wagle_home> MonadZero constraint?
19:32:20 <dmwit> Well, mixed tabs and spaces *are* a problem.
19:32:25 <dolio> Yeah.
19:32:36 <SamB> dolio: that's a really odd way of thinking
19:32:43 <SamB> mixed tabs and spaces are a problem, sure
19:33:13 <SamB> at least, if you think tabs don't skip to the next column divisible by 8
19:33:15 <dolio> If you decide to go with layout, I think the solution is simple, though.
19:33:20 <dolio> Tell the tab folks to take a hike. :)
19:33:28 <SamB> but yes
19:33:31 <SamB> that!
19:33:39 <SamB> same as the Python folks
19:34:02 <dmwit> Python allows tabs.
19:34:14 <SamB> ... maybe it does TODAY
19:34:17 <dmwit> Python and Haskell both treat tabs as eight spaces.
19:34:19 <dmwit> heh
19:34:20 <SamB> but what about TOMORROW?
19:34:26 <dolio> Python has less problems, I imagine, because it's structured more like C.
19:34:34 <SamB> not a great deal less problems
19:34:37 <dmwit> With any luck, Haskell won't support tabs tomorrow, either. =)
19:34:40 <wagle_home> but mommy!  sammy across the street gets to stay up late!
19:34:52 <SamB> anyways, they don't support them crazy variable-width tabs
19:35:18 <SamB> at least not mixed with spaces
19:35:49 <dolio> I suppose as long as you can say something like 'x = if ...' it's an issue.
19:36:04 <SamB> (I supose nobody will know if you use them unmixed)
19:36:04 <SamB> because it is impossible to compare arbitrary line prefixes consisting of tab and space for length...
19:36:16 <dolio> Which I assume python supports.
19:36:27 <SamB> ... at least, if you don't fix the interpretation of tab
19:36:53 <SamB> I read this in Python mailing list archives long ago
19:37:04 <SamB> I think I had been googling timbot ;-)
19:40:35 <sanity> is there an efficient way to represent and manipulate a directed acyclic graph in haskell?
19:41:22 <sw17ch> Data.Graph?
19:42:51 <dolio> Stack overflow?
19:45:55 <thetallguy> Not_found is definitely a bad thing in O'Caml
19:46:09 <roconnor> @hackage Data.Graph
19:46:10 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Data.Graph
19:46:18 <roconnor> wow, I just made up that command
19:46:26 <popcorn> ahaha
19:46:36 <roconnor> 404 Not Found
19:46:41 <roconnor> oh right
19:46:45 <popcorn> @haddok Data.Graph
19:46:45 <lambdabot> Unknown command, try @list
19:46:47 <roconnor> hackage has no intellegence
19:46:54 <dolio> @hackage roconnor-is-lame
19:46:54 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/roconnor-is-lame
19:47:12 <roconnor> Now I remember why I forgot about @hackage
19:47:13 <popcorn> @hackage warning
19:47:13 <dmwit> ?src (++)
19:47:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/warning
19:47:13 <lambdabot> []     ++ ys = ys
19:47:13 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
19:47:13 <lambdabot> -- OR
19:47:13 <lambdabot> xs ++ ys = foldr (:) ys xs
19:47:18 <dolio> It's not terribly smart. :)
19:47:24 <dejones> are multiple where clauses allowed in one function?
19:47:33 <popcorn> dejones: foo = x
19:47:36 <roconnor> dolio: it's marginally smarter than @faq
19:47:36 <popcorn>   where a = 3
19:47:39 <roconnor> its
19:47:41 <popcorn>        b = 7
19:47:44 <dolio> Heh.
19:47:55 <popcorn> with better indentation
19:48:26 <roconnor> dejones: multiple statments are allowed in a where clause
19:48:29 <dejones> I mean like, foo = x where x = a * b where a = 100; b = 10
19:48:35 <dmwit> dejones: You can have multiple definitions in a single where clause.  You can also have multiple where clauses, I think.
19:48:39 <roconnor> and where clauses can be nested indirectly
19:48:41 <popcorn> > let foo = x where x = a * b where a = 100; b = 10 in foo
19:48:41 <dejones> but, I guess it's not really necessary to have the multiple wheres?
19:48:42 <lambdabot>  1000
19:48:45 <popcorn> this works.
19:48:49 <dmwit> dejones: For that, just collapse those two where clauses.
19:48:50 <dmwit> right
19:48:51 <popcorn> > let foo = x where x = a * b; a = 100; b = 10 in foo
19:48:52 <lambdabot>  1000
19:49:14 <dejones> can you think of an example where multiple wheres might be needed?
19:49:21 <dmwit> > let foo = x where { x = a * b; a = 100; b = 10 } in foo
19:49:22 <popcorn> no
19:49:22 <lambdabot>  1000
19:49:27 <dejones> ok :)
19:49:33 <dejones> thanks popcorn and dmwit
19:49:36 <popcorn> if you use multiple where you probably should infact define a new toplevel function
19:49:58 <dejones> yeah, that sounds reasonable. :)
19:50:00 <dejones> thanks again
19:50:18 <dolio> I sometimes do 'foo x = bar where { bar y = baz where quux = quuux }'.
19:50:55 <gwern> > 100 `div` 8
19:50:57 <lambdabot>  12
19:52:51 <dmwit> > let asInt xs = loop 0 xs; loop acc [] = acc; loop acc (x:xs) = loop (acc * 10 + ord x - ord '0') xs in asInt "32"
19:52:52 <lambdabot>  32
19:59:44 <roconnor> *L* ``If writing monad tutorials is the cottage industry of Haskell programmers, than rewriting the standard library is Ocamls cottage industry.
20:02:38 <Korollary> or scheme's cottage industry
20:02:45 <gwern> maybe one of the problems with haskell is we don't hack on the standard library enough
20:03:21 <pjd_> Korollary: isn't scheme's is rewriting everything but the standard library?
20:03:28 <pjd_> s/is //
20:05:15 <dolio> Haskell is too popular to rewrite the standard library now. :)
20:05:25 <roconnor> gwern: I added PartitionEithers. It only took me 2 years :D
20:05:50 <pjd_> dolio: nonsense, look at Python
20:05:58 <dmwit> exactly
20:06:09 <gwern> roconnor: an eminently reasonble time lag, wot wot
20:06:09 <dolio> Look at the haskell' mailing list. :)
20:06:12 <dmwit> People who like the old library install the old compiler.
20:07:38 <solrize> anyone use Expat?
20:12:16 <dons> just write your own standard library
20:12:23 <dons> its not too hard, and hackage lets you distribute it.
20:13:57 <OceanSpray> oy, hackage?
20:14:06 <OceanSpray> you just let anybody put stuff on there?
20:14:14 <dmwit> yep!
20:14:40 <shapr> I'd like to have a web of trust.
20:14:50 <shapr> Ya know, SPJ signed dons key, and dons signed my key...
20:14:54 <pjd_> OceanSpray: no hackage without hackage
20:15:09 <shapr> So if I r00t someone's box, I know dons and spj will show up and kick my butt.
20:15:16 <roconnor> the web of trust is stupid
20:15:19 <dobblego> ?where applicative functors
20:15:20 <lambdabot> http://darcs.haskell.org/packages/base/Control/Applicative.hs
20:15:24 <shapr> roconnor: Why so?
20:15:31 <dobblego> what's that paper on applicative programming called?
20:15:46 <dolio> Applicative programming with effects?
20:15:47 <roconnor> shapr: It stops being useful at about distance 2 from you
20:15:49 <pjd_> roconnor: amen, but s/trust/coarse-grained trust/
20:16:02 <dobblego> that's it, ta
20:16:10 <shapr> roconnor: Maybe so, but my distance 1 group is very large.
20:16:11 <roconnor> none the less, signatures are good.
20:16:14 <roconnor> for updates
20:16:48 * pjd_ advocates ambient, pervasive, weak trust assertions
20:17:36 <roconnor> does cabal sign stuff?
20:17:41 <roconnor> or allow for it?
20:18:30 <roconnor> I keep wanting to make a shadow PGP key server
20:18:37 <roconnor> one where I own all the keys
20:18:55 <roconnor> but duplicates the names and relations of the "real" keyservers
20:19:07 <roconnor> I'll write it in Haskell :P
20:19:37 <roconnor> pjd_: whare are weak trust assertions?
20:21:01 <pjd_> roconnor: for example, "i connected to this web server and it claimed to have this key"
20:21:22 <roconnor> pjd_: you mean like how ssh behaves by default?
20:21:26 <pjd_> or "i received an email claiming to be from this person, signed by this key"
20:21:47 <pjd_> roconnor: not exactly;  SSH doesn't make any assertions
20:22:06 <roconnor> how does it not make assertions?
20:22:17 <pjd_> you just get the key and your client saves it
20:22:32 <roconnor> how is that different from an assertion?
20:22:33 <pjd_> it doesn't publish any signed statement about it
20:22:40 <roconnor> oh okay
20:22:47 <roconnor> hmm
20:23:14 <dmwit> :t (&)
20:23:15 <roconnor> publishing would be cool / disturbing
20:23:16 <lambdabot> Not in scope: `&'
20:23:17 <sw17ch> is any one familiar with the innards of Data.Binary ?
20:23:24 <pjd_> the idea is that hundreds of distributed, weak, and mostly automatic assertions are much more powerful than few "strong" assertions
20:23:50 <pjd_> well, s/hundreds/a great number/
20:24:12 <pjd_> yes, it would :)
20:24:40 <dons> "Haskell is doing data structure level optimizations with the ease that most other compiler do peephole instruction optimization."
20:24:43 <dons> fusion ftw!
20:25:12 <dons> its just so insanely fun to be able to extend the compiler with rewrite rules, adding new algebraic and data structure transformations with easse
20:25:13 <pjd_> roconnor: the distribution mechanism might resemble something like DNS;  an efficient distributed cache of small values
20:26:02 <roconnor> people would know what machines you have (tried) logged into.
20:26:04 <dmwit> GHC has got some pretty high-level optimizations to go along with its high-level language.
20:26:40 <pjd_> roconnor: well, not necessarily
20:26:47 <roconnor> how do you avoid it?
20:27:46 <pjd_> you can control where you get trust assertions from
20:28:03 <pjd_> so you could configure your agent to only use the assertions you feed it, for example
20:28:08 <roconnor> you mean we can control who we give trust assertions to.
20:28:53 <pjd_> well, the model is largely independent of the distribution mechanism
20:28:56 <bd_> @hoogle Int -> Int -> String
20:28:57 <lambdabot> No matches, try a more general search
20:29:01 <bd_> hmm
20:29:12 <bd_> what was the function to render a number as a string in a given radix?
20:29:21 <dmwit> :t showIntAtBase
20:29:23 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
20:29:27 <bd_> aha, thanks :)
20:29:42 <dmwit> You may also be interested in:
20:29:48 <bd_> @hoogle showIntAtBase
20:29:49 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
20:29:49 <pjd_> roconnor: you could easily imagine something RSS- or twitter-like, for example;  set up your agent to publish a "trust feed"
20:29:50 <dmwit> :t intToDigit
20:29:52 <lambdabot> Int -> Char
20:30:20 <roconnor> pjd_: sure, I just don't what to tell everyone what machines I'm logging into.
20:30:23 <pjd_> which gets subscribed to aggregated, pushed around, munged, filtered, etc.
20:30:32 <bd_> @source showIntAtBase
20:30:32 <lambdabot> showIntAtBase not available
20:30:43 <pjd_> right, so you would presumably configure your client to keep some assertions private
20:30:47 <pjd_> or not make them at all
20:30:51 <dmwit> ?source Numeric
20:30:52 <lambdabot> http://darcs.haskell.org/packages/base/Numeric.hs
20:30:55 <roconnor> or just tell my friends
20:31:00 <pjd_> right
20:31:04 <bos> @seen dons
20:31:04 <lambdabot> dons is in #ghc, #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 5m 52s ago.
20:31:06 <roconnor> that's fair
20:31:06 <bd_> @hoogle intToDigit
20:31:07 <lambdabot> Data.Char.intToDigit :: Int -> Char
20:31:42 <pjd_> but the main idea is to reify, if you will, the ambient trust that currently goes wasted
20:32:11 <pjd_> every time you connect to a website, that's a small assertion about the validity of its source, key, etc.
20:32:39 <roconnor> pjd_: that is actually pretty nice.  If this all happens automatically behinds the scenes when you subscribe to your friends blog or whatever.
20:32:41 <pjd_> if someone tries to MitM one connection to, say, gmail.com
20:33:02 <pjd_> they'd immediately be overwhelmed by thousands of contrary assertions you should have already been accumulated
20:33:12 <pjd_> accumulating, even
20:33:19 <roconnor> pjd_: Every once in a while you would connect someone and there would be a conflict
20:33:35 <roconnor> and then you'd know that one of your friends is getting scamed
20:33:41 <pjd_> right
20:33:59 <pjd_> another issue, of course, is the potential of someone trying to flood the network with bad trust data
20:34:16 <roconnor> pjd_: well I'd imagine you'd only connect to your friends
20:34:16 <pjd_> but that becomes a problem similar to blog or email spam
20:34:19 <pjd_> right
20:34:32 <roconnor> If you start getting bad data from one of your friends: plonk
20:34:44 <pjd_> zigactly
20:34:59 <dons> yo bos?
20:35:05 <pjd_> the nice thing is you can assign varying levels of trust
20:35:18 <roconnor> if you want
20:35:22 <pjd_> so you can weakly trust everyone by default
20:35:38 <pjd_> which will help a lot for, say, high-profile sites
20:36:22 <pjd_> you'd have a near infinite supply of second opinions over Google or MS's important keys, for example
20:36:35 <roconnor> does HTTP support signatures?
20:36:51 <pjd_> eh, sort of
20:36:53 <bos> dons: i've misplaced my memory
20:36:58 <bos> dons: so nemmind
20:37:04 <dons> darcs revert ?
20:37:28 <pjd_> there's a pretty nice PGP/PEM system from the early days that got trampled by HTTPS/SSL, if i'm not mistaken
20:37:49 <roconnor> hmm
20:37:58 <roconnor> there is very little nice about PGP. :)
20:38:11 <pjd_> there's even less nice about x.509
20:38:16 <roconnor> perhaps
20:38:32 <dons> i wish my memory was in a revision control system
20:38:42 <dons> instead, it seems to be some kind of mutable graph structure
20:38:48 <roconnor> I'm told we don't want to encrypt all webpages, because it would slow things down too much
20:38:56 <roconnor> but static signatures ought to be okay
20:38:57 <pjd_> roconnor: anyway, the other nice property is that assertions are much cheaper
20:38:57 <dons> $ darcs unrecord stupididea
20:39:15 <roconnor> pjd_: but we still need to sign webpages, right?
20:39:23 <roconnor> or at least we ought to?
20:39:43 <roconnor> stop ISPs from mucking around with them.
20:40:16 <pjd_> roconnor: yeah
20:40:40 <roconnor> It seems like there ought to be some moderately simple HTTP header for that.
20:40:54 <pjd_> there's an MD5 header
20:41:10 <roconnor> but we need a signed hash
20:41:15 <roconnor> and probably a link to the key
20:41:30 <roconnor> key/certificate
20:41:35 <pjd_> right;  HTTP has pretty much gone the way of SSL, unfortunately
20:41:49 <roconnor> and SSL requires encryption?
20:41:57 <roconnor> or is there a signature only version?
20:41:57 <thetallguy> dons: there are no stupid ideas, only misguided patches
20:42:22 <roconnor> I mean SSL is probably just on the wrong level for static signatures anyway
20:42:34 <pjd_> roconnor: practically speaking, it doesn't matter much, because all browsers require encryption for "security"
20:42:53 <pjd_> just like they require certs, and refuse ADH
20:44:19 <roconnor> ADH?
20:44:39 <pjd_> anonymous diffie-hellman key exchange
20:45:24 <roconnor> what good is that?
20:45:39 <pjd_> complete protection against sniffing
20:45:50 <pjd_> for starters
20:46:12 <pjd_> not everything is an active attack
20:46:25 <roconnor> it adds a lot overhead to serving webpages
20:46:47 <pjd_> well, this is in the context of SSL encryption already
20:47:01 <roconnor> oh okay
20:47:21 * roconnor has deleated all his root CAs on his browser
20:47:57 <pjd_> good :)
20:49:05 <pjd_> anyway, the key exchange is orthogonal to whether you actually encrypt the connection
20:49:13 <pjd_> you could use it to sign a session, for example
20:50:05 <pjd_> or to only encrypt certain parts of it (e.g. customized HTML), but not others
20:50:18 <roconnor> well, you couldn't make static signatures that way
20:50:22 <roconnor> so you might as well encrypt.
20:51:04 <pjd_> yeah, depends on your needs at the time
21:03:46 <bd_> @hoogle Char -> Int
21:03:47 <lambdabot> Data.Char.digitToInt :: Char -> Int
21:03:47 <lambdabot> Data.Char.ord :: Char -> Int
21:03:47 <lambdabot> Data.ByteString.Char8.count :: Char -> ByteString -> Int
21:06:45 <conal> bos: thx for the reddit (http://reddit.com/info/6ikr0/comments/)
21:07:08 <conal> ("Beautiful differentiation")
21:08:47 * roconnor uses AD to simplify his portofolio optimization code.
21:09:20 <conal> roconnor: sweet!
21:10:10 <roconnor> I used to type in code that I transcribed from maple
21:10:14 <roconnor> It was difficult to modify
21:10:34 <roconnor> but now it is simple to optimize different variations
21:12:45 <awesame> what's the "monomorphism restriction"?
21:13:05 <gwern> @seen dcoutts
21:13:05 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #haskell-blah, #ghc and #haskell. I last heard dcoutts speak 4h 21m 40s ago.
21:13:29 * dolio experiences nib'poH.
21:17:57 <ddarius> @wiki Monomorphism restriction
21:17:58 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
21:19:07 <awesame> thanks
21:19:40 <thetallguy> conal: have you published the new FRP code?
21:23:14 <roconnor> @type flip mapM
21:23:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
21:25:12 <Trinithis> is there a tool that takes layouted haskell code and turns it into code with braces?
21:26:03 <Trinithis> nvm gt
21:26:05 <Trinithis> gtg
21:37:20 <geezusfreeek> conal: you blog is down!
21:37:24 <geezusfreeek> *your
21:38:41 <ddarius> For shame.
21:43:35 <geezusfreeek> and i was interesting in seeing his automatic differentiation post
21:43:50 <geezusfreeek> *interested i still need to learn to read before i send
21:44:11 <ddarius> It was pretty nice, though I don't like the choice of operator.
21:44:50 <geezusfreeek> what is the operator and what does it do?
21:46:15 <ddarius> geezusfreeek: You'll have to read the post.
21:46:22 <geezusfreeek> darn
21:52:14 <dolio> @seen edwardk
21:52:14 <lambdabot> edwardk is in #haskell. I last heard edwardk speak 5h 34m ago.
21:54:29 <thetallguy> ?seen shar
21:54:29 <lambdabot> I haven't seen shar.
21:54:40 <thetallguy> ?seen shapr
21:54:41 <lambdabot> shapr is in #scannedinavian, #xmonad, #haskell-soc, #haskell-blah and #haskell. I last heard shapr speak 1h 36m 38s ago.
21:58:23 <cjs> Hm. So, I've got a question about dealing with an IO problem.
21:58:53 <cjs> Basically, I'm reading the input of TCPFlow, and I'll be getting two (usually, it could be more) streams of data, one from client to server and the other from server to client.
21:59:36 <cjs> I need to parse messages out of these streams and print them both. I get interleaved chunks from each stream, but a message might be split across multiple chunks.
21:59:46 <cjs> I wonder what the best way to read, parse and print these is?
22:01:47 <cjs> I guess keep a ByteString of "not-yet-parsed data" for each stream, and when I get a new chunk, append it to the appropriate stream, and then attempt to parse a message from that stream. If that succeeds, I return the message and a new "remainder", otherwise I keep the old remainder, read another chunk, and do the same thing again.
22:43:04 <cjs> So this appears not to be lazy; it reads in everything before printing anything: http://hpaste.org/7465
22:43:41 <cjs> So what should I be doing instead. I guess a getContents?
22:46:35 <cjs> Or just interleave my processing into getMessages, I suppose.
22:48:05 <ddarius> Use coroutines.
22:49:34 <cjs> Hm. Got a quick thought on how to do that?
22:50:00 <ddarius> Use an appropriate monad transformer.
22:50:40 <cjs> I don't know monad transformers. :-(
22:52:21 <cjs> Oh well. It will come eventually. I need to have another go at _All About Monads_ again, actually.
22:54:29 <geezusfreeek> ddarius: you're right, the operator in the post doesn't seem to make anything more intuitive
22:56:46 <quicksilver> cjs: it is important to appreciate that asking for IO to be done lazines is something qualitively very different from asking for evaluation to be done lazily.
22:57:35 <cjs> In the sense that with IO you're explicitly asking for sequencing of operations?
22:58:06 <quicksilver> in the sense that the whole point of lazy evaluation is that pure functions alwas evaluate to the same thing and can never go wrong (in some sense)
22:58:13 <quicksilver> so it really doesn't matter when they are evaluated.
22:58:19 <mxc> @hoogle IOMode
22:58:19 <lambdabot> System.IO.IOMode :: data IOMode
22:58:20 <geezusfreeek> in the sense that lazy IO _changes_ the sequencing of effects
22:58:30 <quicksilver> whereas IO actions may (a) have diffeferent values depeneding when they are executed
22:58:36 <quicksilver> and (b) may go wrong in interesting ways.
22:58:42 <cjs> Right. I understand.
22:58:54 <quicksilver> bearing all that in mind, if you're happy to take those risks
22:59:02 <quicksilver> then a quick unsafeInterleaveIO will sort you out
22:59:09 <cjs> Basically, in the one I posted, I was explicitly asking to read the whole thing before writing anything.
22:59:10 <quicksilver> in the definition of getMessages
22:59:45 <quicksilver> @hoogle unsafeInterleaveIO
22:59:46 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
23:00:08 <quicksilver> in the recursive call, change remainder
23:00:20 <quicksilver> remainder <- unsafeInterleaveIO (getMessages h)
23:00:22 <quicksilver> I think.
23:00:49 <quicksilver> unsafeInterleaveIO means 'construct an IO action which returns immediately but actually does the IO on demand later"
23:00:57 <quicksilver> it is, as the name suggests, unsafe in general :)
23:01:19 <quicksilver> it is the building block used to construct hGetContents and simiar.
23:02:13 <cjs> Ah, I see.
23:02:42 <cjs> It's nice to know that I can get down and dirty there if I want, but for this particular case, just interleaving the reads and prints is easy and works fine.
23:04:35 <cjs> but hGetContents is just as "unsafe" as unsafeInterleaveIO, then, isn't it.
23:07:09 <geezusfreeek> yes and consequently i personally think the function should be prefixed with "unsafe"
23:07:33 <dons> its not really  really really unsafe, its just got some other things you should think about :)
23:08:27 <geezusfreeek> which is still unsafe enough to warrant an "unsafe" prefix in my book
23:08:38 <dolio> Not even reallyUnsafePointerEquality is really, really, really unsafe. :)
23:08:58 <dons> well, i don't see anyone breaking type safety with getContents
23:09:00 <cjs> No, I understand the exact "safety" issue with it, and I'd almost be tempted to say that unsafeInterleaveIO is "just as safe" as hGetContents. But still, it is an issue.
23:09:12 <geezusfreeek> heh, reallyReallyReallyUnsafeCoerce
23:09:25 <cjs> I can imagine that someone with less background than me would miss the issue and get confused.
23:09:37 <dons> still, haskellers are right to think that *any* side conditions make code unsafe
23:09:40 <dons> its a good view
23:10:54 <Elly> what is hGetContents?
23:10:59 <ddarius> @src MonadIO
23:11:00 <lambdabot> Source not found. You untyped fool!
23:11:06 <ddarius> :t liftIO
23:11:09 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
23:11:18 <conal> geezusfreeek: my blog was down?
23:11:27 <geezusfreeek> conal: it was
23:11:40 <cjs> Elly: go to www.haskell.org/hoogle and type it in. It will take you directly to the description of the function.
23:12:04 <geezusfreeek> or at least it was for me i don't think i had anybody else verify though
23:12:15 <geezusfreeek> other sites loaded fine for me though, so i assume it was down
23:12:44 <Elly> cjs: ah, thanks! I did not know about that :)
23:13:15 <cjs> I live and die by it. :-)
23:13:17 <dolio> > let unsafeFix f = f (unsafeFix f) in unsafeFix id -- oh no!
23:13:27 <lambdabot>  Exception: Time limit exceeded
23:13:50 * Elly does not understand monads or what they are for - can someone recommend something to read?
23:15:06 <quicksilver> heh
23:15:25 <quicksilver> if only someone would write a tutorial on monads...
23:15:35 <Elly> well
23:15:42 <Elly> what are they in a category-theoretic sense?
23:16:29 <quicksilver> Elly: I was joking. There are about 1 million monad tutorials, it's a running joke.
23:16:33 <dolio> They're monoids in the category of endofunctors.
23:16:34 <quicksilver> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
23:16:35 <Elly> ah, okay :P
23:16:35 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
23:16:51 <quicksilver> http://www.haskell.org/all_about_monads/html/index.html
23:16:51 <lambdabot> Title: All About Monads
23:16:59 <Elly> w00t :)
23:17:17 <quicksilver> http://www.haskell.org/haskellwiki/Monads_as_Containers
23:17:18 <lambdabot> Title: Monads as containers - HaskellWiki
23:17:29 <quicksilver> I hesitate to say three of the best, because that's subjective.
23:17:35 <quicksilver> But, now I've hesitated appropriately:
23:17:38 <quicksilver> That's three of the best.
23:19:07 <dolio> No Wadler?
23:21:17 <quicksilver> well, I didn't say it was the three absolutely best :)
23:21:28 <quicksilver> I'm quite fond of the Moggi paper, which was my formal introduction.
23:21:39 <quicksilver> But you need the correct background for that to be a sensible choice.
23:21:49 <dolio> I haven't looked at that in a while.
23:22:25 <dolio> I haven't really read any monad tutorials in a while, either. But I've heard renewed raving about the original Wadler paper.
23:22:54 <cjs> I quite like _All About_ myself, but it was about the eighth monad tutorial I've read. :-)
23:23:47 <cjs> But the "functional parsers" chapter of Hutton was the one where it suddenly clicked and I got the really basic point about how one uses them for sequencing.
23:24:06 <quicksilver> I had already used functional parsers in ML before I learnt haskell
23:24:13 <quicksilver> and no one mentioned the magic word 'monad'
23:24:25 <quicksilver> so once I realised I'd already written monadic code, it helped a lot.
23:25:55 <cjs> I want "let" in Bourne shell. :-)
23:27:52 <ddarius> :t unless
23:27:54 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
23:28:27 <Elly> heh
23:28:34 <Elly> I need more grounding in theoretical computer science, it seems
23:28:46 <Elly> next semester will contain constructive logic :)
23:31:45 <andyjgill> ?seen dons
23:31:46 <lambdabot> dons is in #ghc, #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 22m 5s ago.
23:40:29 <Elly> damn, I really like Haskell :)
23:40:36 <Elly> I have been doing the Project Euler problems in it
23:46:13 <geezusfreeek> @hoogle (Monad m, Functor f) => (a -> m b) -> f a -> m (f b)
23:46:14 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
23:46:14 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
23:46:14 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
23:46:42 <geezusfreeek> i wonder if such a function can even exist
23:46:43 * ski_ isn't sure about `unsafeInterleaveIO' having `unsafe' in it
23:47:18 <geezusfreeek> i take it back
23:47:24 <geezusfreeek> i just need to go to sleep
23:47:35 <ski_> @type Data.Traversable.traverse
23:47:37 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
23:47:39 <ski_> @type Data.Traversable.mapM
23:47:41 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Monad m, Data.Traversable.Traversable t) => (a -> m b) -> t a -> m (t b)
23:47:51 <ski_> geezusfreeek : try those ?
23:48:04 <geezusfreeek> ski_: sweet!
23:48:14 <geezusfreeek> i'll look into that, thanks
23:51:23 <geezusfreeek> doh, mapM
23:51:28 <ski_> geezusfreeek : syntactically, `for' and `forM' in the same module might be nicer to use
23:51:38 <geezusfreeek> yeah
23:51:38 <ski_> if you don't need to collect a resulting structure, `Data.Foldable.(traverse|for)_',`Data.foldable.(map|for)M_' might be enough
23:52:03 <ski_> @type mapM
23:52:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
23:52:17 <ski_> that's the non-general one, just for lists
23:52:22 <geezusfreeek> right
23:52:29 <ski_> (maybe that's what you wanted ?)
23:52:33 <ski_> @index mapM
23:52:33 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
23:52:42 <geezusfreeek> i needed the more general one
23:52:46 <ski_> ok
23:52:49 <geezusfreeek> which is why i didn't think of it
23:52:58 <geezusfreeek> thanks for pointing it out
23:53:02 <ski_> np
23:53:08 <dons> andyjgill: ?
23:53:16 <andyjgill> Hi
23:54:03 <ski_> geezusfreeek : ooi, what monads or applicatives are you wanting to use this on ?
23:54:31 <ski_> (and what foldable/traversable structure ?)
23:56:19 <geezusfreeek> ski_: i'm actually thinking foldable will not apply i didn't realize the foldable constraint was there
23:56:40 <geezusfreeek> i will analyze this a bit more and report back here
23:57:15 <ski_> geezusfreeek : `Traversable' is more constraining than `Foldable', i think
23:57:20 <geezusfreeek> right
23:57:36 <ski_> so every `Traversable' should be a `Foldable'
23:58:13 <geezusfreeek> the only constraint that i think makes sense for this type is Functor, so i need to do something else
23:58:19 <ski_> (so if `Foldable' doesn't apply, you don't have any hope of `Traversable' applying .. maybe that's what you referred to ?)
23:58:29 <geezusfreeek> ^ correct
23:58:34 <ski_> what is the type in question ?
