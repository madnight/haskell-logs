00:00:49 <cjs_> Thanks.
00:01:10 <cjs_> I reckoned that since I was typing in a lot of the stuff anyway, I might as well clean it up, add some explanations, and make it available.
00:01:40 <cpoucet> cjs_: are you using CVS?
00:02:26 <cpoucet> cjs_: I have to go but, last thought, you could put it in darcs, and then people could send you patches and contribute
00:02:36 <cpoucet> (or git if that tickles your fancy)
00:04:12 <cjs_> I'm using subversion, unfortunately.
00:04:22 <cjs_> But patches by e-mail are fine.
00:04:30 <cjs_> I gotta start using darcs one day.
00:07:23 <cjs_> Gotta run.
00:29:09 <ketil> @seen droundy
00:29:30 * ketil shrugs.
00:31:34 <AndreWe> How can I find the position of a substring? I can check if there is a substring with isInfixOf.
00:34:18 <dmwit> Well, the naive algorithm uses tails and isPrefixOf.
00:35:17 <dmwit> > let find needle = length . takeWhile (not . isPrefixOf needle) . tails in find "world" "hello, world"
00:35:28 <dmwit> Bah, \bot isn't here.
00:35:32 <Cale> oh
00:35:36 <AndreWe> dmwit: Is there no function in the Prelude or Data.List?
00:35:50 <dolio> @type \l -> findIndex (isPrefixOf l) . tails
00:35:58 <Cale> uh, whoa
00:36:14 <Cale> > let find needle = length . takeWhile (not . isPrefixOf needle) . tails in find "world" "hello, world"
00:36:22 <lambdabot>  7
00:36:30 * Cale shrugs.
00:36:34 <dmwit> Yeah, findIndex is probably better.
00:36:45 <Cale> It seemed to still be running and logged in. I'm not sure why it didn't respond.
00:37:09 <AndreWe> thanks, dolio and dmwit
00:37:58 <dolio> > (\needle -> findIndex (isPrefixOf needle) . tails) "world" "hello, world"
00:38:06 <lambdabot>  Just 7
00:39:00 <Cale> huh, apparently code.haskell.org is now called nun?
00:39:45 <dmwit> > (\n -> findIndices (isPrefixOf n) . tails) "world" "hello, world world!"
00:39:47 <lambdabot>  [7,13]
00:43:14 <AndreWe> great, it works :-)
00:50:57 <ketil> Anybody else have trouble building darcs-2.0.0 with ghc-6.8.1?
00:53:35 <lament> eo.o: In function `rHP_info':
00:53:36 <lament> : undefined reference to `containerszm0zi1zi0zi1_DataziMap_fromList_closure'
00:53:51 <lament> am i supposed to link with some library when doing Data.Map? I didn't think so...
00:58:21 <mmorrow> ha, i just tried to build it and
00:58:22 <mmorrow> ghc-6.9.20080504: panic! (the 'impossible' happened)
00:58:22 <mmorrow>   (GHC version 6.9.20080504 for i386-unknown-linux):
00:58:22 <mmorrow>         RegAllocLinear.getStackSlotFor: out of stack slots, try -fregs-graph
00:58:22 <mmorrow> Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
00:58:22 <mmorrow> make: *** [src/SHA1.o] Error 1
00:58:24 <ketil> % ghc -cpp -E src/rts.c
00:58:24 <ketil> ghc-6.8.1: cannot compile this file to desired target: src/rts.c
00:58:24 <lambdabot> Title: ReportABug - GHC - Trac
00:58:32 <ketil> What does this mean? "target"?
00:58:54 <ketil> According to --help, -E should produce de-litted etc source code.
01:00:20 <mib_ix0f94> hey guys i am creating a syntax i highlighter, it's built and working, the problem is that the parser (parse the different elements and place them in a queue, comment, keyword, normal, number, etc.), but it's moving too slowly and sometimes crashing. i was thinking of just using list comprehension to filter out the elements them map my hightlighter to the list, do u think it can work?
01:00:32 <dmwit> lament: Yes, Data.Map is in the "containers" package.
01:08:45 <jsnx> mib_ix0f94: seems like the right idea -- but you really need to say more about the crashing part
01:21:26 <mib_ix0f94> jsnx parsing 1000 words takes about 5 secs (slow pc) , but it crashes when processing a book length file
01:24:26 <mib_ix0f94> because i am reading from a file : when it crashes i get a program errror read: no parse
01:24:47 <mib_ix0f94> something like
01:30:38 <Baughn> mib_ix0f94: Use reads instead of read, /handle/ errors?
01:31:42 <mib_ix0f94> ok
01:33:42 <Baughn> mib_ix0f94: Although, if you're parsing anything complex, you really should be using parsec
01:36:20 <mib_ix0f94> is it fast ?
01:37:20 <mib_ix0f94> what i am basically doing is creating my own parser, just trying ways to optimize it
01:37:23 <Baughn> It can be
01:37:30 <Baughn> It's certainly faster than writing your own
01:38:39 <mib_ix0f94> i don't want any  lagging, kinda like a normal syntax highlighter, just map the colors fast, tops 2 secs
01:39:08 <mib_ix0f94> and it's capable of doing what i am doing right?
01:39:26 <Baughn> Sure, but.. do you know how a normal syntax highlighter /works/?
01:39:38 <Baughn> Hint: It doesn't crash or stop working if the syntax is invalid
01:40:08 <mib_ix0f94> well i have idea.
01:41:16 <mib_ix0f94> the reason , i am straying from using a pre-built parser it's cause i want to know more about what the parser does, to enable to write it myself
01:41:44 <Baughn> That would require studying parser theory
01:41:57 <Baughn> You are /not/ going to be able to figure it out on your own. There's a lot of math involved.
01:42:20 <mib_ix0f94> i hate math, so i guess i am doomed
01:42:55 <mib_ix0f94> plus i have a compiler project in december so i wanted to learn more about the parser
01:46:05 <Baughn> At least read what's on wikipedia
01:46:11 <Baughn> http://en.wikipedia.org/wiki/Parsing is a decent introduction
01:51:27 <mib_ix0f94> thanks
01:55:34 <mib_nry1m8> i have read the wiki , it basically does the same thing my syntax highlighter does
01:55:53 <ex1stenz> can any1 tell me if the page opens? http://www.colectionarul.com/existenz1.html
01:55:54 <lambdabot> Title: Albumul de surprize a lui existenz1 | Colectionarul.Com
01:57:48 <mib_nry1m8> yes
02:05:07 <mxc> @hoogle average
02:05:08 <lambdabot> No matches found
02:05:14 <mxc> @hoogle mean
02:05:14 <lambdabot> No matches found
02:05:21 <mxc> @hoogle variance
02:05:21 <lambdabot> No matches found
02:05:59 <Botje_> mean l = sum l / genericLength l
02:06:23 <Botje_> @pl mean l = sum l / genericLength l
02:06:23 <lambdabot> mean = liftM2 (/) sum genericLength
02:06:25 <sioraiocht> that's not very  efficient...
02:06:36 <Botje_> sioraiocht: no, but it sure is easy to write :)
02:06:39 <sioraiocht> hehe
02:06:43 <sioraiocht> true...
02:07:03 <Botje_> if you wanted it to be _efficient_ you'd combine the two
02:07:09 <sioraiocht> indeed
02:07:49 <sioraiocht> but that IS less concise, heh
02:08:33 <Botje_> > let mean = uncurry (/) $ foldr (\x (s,i) -> (s+x,i+1)) (0.0, 0.0) $ map fromIntegral [1..5]
02:08:33 <lambdabot>  Parse error at end of input
02:08:49 <Botje_> > let mean = uncurry (/) $ foldr (\x (s,i) -> (s+x,i+1)) (0.0, 0.0) in mean $ map fromIntegral [1..5]
02:08:49 <lambdabot>  Couldn't match expected type `(a, a)'
02:08:55 <pjd_> mean = (/) <$> sum <*> genericLength
02:09:40 <Botje_> gah
02:10:30 <Botje_> > let mean = uncurry (/) . foldr (\x (s,i) -> (s+x,i+1)) (0.0, 0.0) in mean $ map fromIntegral [1..5]
02:10:32 <lambdabot>  3.0
02:10:48 * Botje_ mutters about stupid mental model not grasping the difference between . and $
03:00:04 <ex1stenz> can any1 tell me if the page opens? http://www.colectionarul.com/existenz1.html
03:00:05 <lambdabot> Title: Albumul de surprize a lui existenz1 | Colectionarul.Com
03:01:25 <ohub> ex1stenz; yes, it opens
03:14:34 <sioraiocht> does ghc understand hex?
03:14:45 <sioraiocht> i.e. can i use 0x10000 instead of 65535?
03:14:55 <dolio> > 0x10000
03:14:56 <lambdabot>  65536
03:15:04 <sioraiocht> thanks
03:16:05 <opqdonut> :P
03:16:11 <sioraiocht> how about binary? ;)
03:16:23 <dolio> Doubt it.
03:16:35 <dolio> > 0b101011
03:16:36 <lambdabot>   Not in scope: `b101011'
03:17:44 <quicksilver> periodically people suggest ridiculously elaborate ways to support binary literals
03:17:52 <quicksilver> by overloading Num or IsString etc
03:18:21 <sioraiocht> heheh
03:18:23 <sioraiocht> np
03:18:51 <kuribas> Is there software to do numerical computations like gnu octave, but in a functional way?  (An extention to haskell maybe?)
03:18:51 <lambdabot> kuribas: You have 1 new message. '/msg lambdabot @messages' to read it.
03:19:24 <dolio> Seems like just adding binary literals would be better.
03:20:08 <quicksilver> dolio: except since it only comes up about once every 6 months I'm not sure there is any demand for it.
03:20:37 <dolio> Yeah, can't say I've really pined for it.
03:23:26 <atsampso1> > let bin x = (if x == 0 then 0 else bin (x `div` 10) * 2) + (x `mod` 10) in bin 101010
03:23:36 <lambdabot>  42
03:25:03 <quicksilver> yes, that's one of the solutions :)
03:25:39 <dolio> That cuts the size of things you can express in binary by quite a bit in the Int case.
03:26:34 <Deewiant> I wonder how many people use octal?
03:26:44 <quicksilver> 8
03:26:47 <sioraiocht> octal hurrts my head
03:27:05 <ziman> @pl (join.) . fmap
03:27:05 <lambdabot> (=<<)
03:27:17 <Deewiant> Binary would be a lot more useful than octal, but that's just me.
03:27:21 <sioraiocht> are there any shift operations on Words?
03:27:24 <Deewiant> > 0o10
03:27:26 <lambdabot>  8
03:27:39 <sioraiocht> > 0b1
03:27:40 <lambdabot>   Not in scope: `b1'
03:27:43 <sioraiocht> :*
03:27:43 <quicksilver> sioraiocht: yes. Data.Bits
03:27:45 <sioraiocht> thanks
03:28:10 <kuribas> dolio: It's better that you email me, instead of /msg.
03:28:29 <kuribas> I check my email more often.
03:28:40 <dolio> Heh. That message was from me?
03:28:59 <kuribas> Yes :)
03:29:12 <kuribas> See? :-)
03:29:26 <quicksilver> kuribas: did you fix the case-guard thing?
03:29:36 <kuribas> yes
03:29:40 <quicksilver> excellent
03:29:45 <quicksilver> I must try new version! thanks.
03:30:10 <dolio> How do I go about finding your e-mail?
03:30:31 <kuribas> It's in the elisp file.
03:30:37 <dolio> Oh, okay.
03:31:29 <dolio> Man, I don't even remember what the last message I sent you was about.
03:31:46 <kuribas> Another bug...
03:32:01 <kuribas> I'll look into it now...
03:32:02 <dolio> Well, I figured that. But I don't remember what it was.
03:32:22 <kuribas> dolio said 16d 18h 19m 12s ago: It still seems to be broken in the "\n{-\nfoo a = bar a\n-}" case (although that comes up less for me).
03:32:25 <dolio> I guess it hasn't been bugging me much. :)
03:32:35 <dolio> Oh, right.
03:32:35 <pejo> kuribas, there was someone doing a CAS in Haskell at IFL in 2007.
03:32:47 <kuribas> pejo: Oh, cool.
03:33:54 <pejo> kuribas, but that wasn't exactly what you were looking for, I guess. Still, their related work might help. Oleg Lobachev was his name.
03:37:27 <nominolo> does anyone here know how i can intercept Ctrl-C so that i can run a clean-up action?
03:37:48 <nominolo> 'finally' doesn't seem to work
03:38:49 <TSC> nominolo: Posix?  http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Signals.html#4
03:38:50 <lambdabot> http://tinyurl.com/34y959
03:39:10 <nominolo> ah, right.
04:02:29 <skorpan> http://hpaste.org/7435
04:02:43 <skorpan> could anyone shorten that to something like one or two lines?
04:04:17 <wjt> well you can combine the last two lines as x `fmap` get
04:05:16 <Deewiant> myModificatingFunction = x `fmap` (modify (\s -> s { x = (x s) + 1 }) >> get)
04:05:28 <skorpan> >> is so hot..
04:05:31 <skorpan> thanks
04:08:09 <Arnar_> :t forM_
04:08:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
04:10:30 <czakey> @version
04:10:31 <lambdabot> lambdabot 4p629, GHC 6.8.2 (Linux i686 2.40GHz)
04:10:31 <lambdabot> darcs get http://code.haskell.org/lambdabot
04:12:35 <maltem> the tedious thing about that paste is really that record syntax is not higher-order
04:14:00 <mm_freak_work> i'm using GHC…  when i have (x:xs) on the left side of a function equation, i'd like to just write (x:xs) on the right side, where i need the full list…  is this a bad idea?
04:14:14 <mm_freak_work> i'm asking, because i find the axs@(x:xs) syntax pretty ugly
04:14:23 <skorpan> i can't see why that would be *bad*
04:14:42 <dolio> It might be slightly less efficient.
04:14:51 <mm_freak_work> skorpan: because a compiler may decide to implement it as x : (tail (x:xs))
04:15:32 <dolio> Depending on how smart GHC is.
04:16:47 <Botje_> GHC is VERY smrt
04:21:37 <kalven> right
04:21:54 <mm_freak_work> GHC 6.8.2 is smart enough
04:22:19 <mm_freak_work> at least it doesn't make any performance difference
04:22:39 <Deewiant> you can check the generated code if you want to be sure
04:23:55 * dolio is having trouble generating simple code that would find a difference.
04:24:18 <dolio> Ah, there we are.
04:24:40 <mm_freak_work> ok, it optimizes it out even without -O
04:24:48 <mm_freak_work> i love GHC =)
04:28:40 <dolio> The code seems to be different without -O here.
04:30:06 <dolio> At -O2 it looks the same.
04:32:50 <mm_freak_work> dolio: it's slower in general, but whether i use the syntax sugar or not doesn't seem to make any difference
04:34:12 <dolio> Well, I mean, my test function was 'foo (x:xs) = x:x:xs'. Without -O, it reallocates (x:xs), with -O2 it doesn't (with l@(x:xs) ... x:l) it doesn't reallocate in either case).
04:34:57 <Baughn> dolio: How about with just -O?
04:35:05 <dolio> I don't use -O.
04:35:10 <dolio> :)
04:35:15 <Deewiant> how about if you would? :-P
04:36:09 <dolio> -O looks like -O2.
04:36:37 <Deewiant> alright
04:40:56 <dolio> Took me a while to find a good program. At first I had 'main = print (foo [1])' but even without -O, that got inlined to (effectively) 'print (1:1:[])'.
04:43:51 <MyCatVerbs> dolio: why not just do main = getLine >>= putStrLn . foo -- ?
04:44:09 <MyCatVerbs> dolio: or does that not allow you to test what you need to test?
04:44:10 <dolio> Because 'main = interact foo' is better. :)
04:44:19 <MyCatVerbs> dolio: ah, of course, silly me.
04:47:35 <mxc> @src foldl
04:47:35 <lambdabot> foldl f z []     = z
04:47:35 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:47:37 <mxc> @src foldr
04:47:37 <lambdabot> foldr f z []     = z
04:47:37 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:48:32 <mxc> so foldl is tail recursive and generally better if you dont care about the order?
04:49:27 <Deewiant> foldr is better for lazy data because it can generate a list one element at a time
04:50:58 <dcoutts_> mxc: it really depends on the strictness of the function you are using to fold over the list
04:51:12 <ziman> and foldl' is strict & tail-recursive (useful for long lists to avoid stack overflow)
04:51:35 <dcoutts_> or (usually equivalently) the strictness of the data structure you're building as a result
04:58:50 <Beelsebob> anyone know what language extension is needed to get infix types?
04:59:02 <dolio> TypeOperators
04:59:13 <Beelsebob> cheers :)
04:59:17 <childe> Hi, how to write a function like this? f [g,h,i] == g.h.i
04:59:30 <childe> The list's length is variable.
04:59:31 <Beelsebob> remove one of the equal signs
04:59:41 <Botje_> childe: foldr (.) id
04:59:41 <Beelsebob> ah, okay then, you want to fold (.) on the list then
04:59:47 <Beelsebob> foldr1 (.)
04:59:54 <childe> Wow thanks!
04:59:59 <Botje_> or that :)
05:00:05 <Deewiant> > foldr (.) id [f,g,h]
05:00:08 <lambdabot>  Add a type signature
05:00:14 <Botje_> childe: this better not be homework, or we'll mail the solution to your teacher! :p
05:00:29 <childe> No no, not homework :-) I've left school for quite a few years.
05:00:38 <Deewiant> > foldr (.) id [f,g,h] $ x
05:00:40 <lambdabot>  f (g (h x))
05:00:43 <Beelsebob> > let f = (+1); g = (/2); h=(*3) in foldr1 (.) [f,g,h] 5
05:00:46 <lambdabot>  8.5
05:00:57 <Botje_> acutally
05:01:04 <Botje_> you could just use sequence in the ((->) r) monad
05:01:12 <Beelsebob> you could... but why would you want to
05:01:17 <Botje_> less typing!
05:01:20 <Beelsebob> when the alternative definition is *really* simple
05:01:26 <Beelsebob> and *really* clear
05:01:41 <dolio> Nope, that'd be \x -> [f x, g x, h x].
05:01:51 <dolio> It's mconcat in the Endo monoid.
05:02:01 <Beelsebob> >.<
05:02:06 <Beelsebob> just.. why
05:02:12 <Beelsebob> is foldr (.) not clear enough?
05:02:26 <dolio> @type appEndo . mconcat . map Endo
05:02:29 <lambdabot> forall a. [a -> a] -> a -> a
05:02:34 <Botje_> woah
05:02:37 <Botje_> that's scary
05:03:16 <Deewiant> > (appEndo . mconcat . map Endo) [f,g,h] x
05:03:18 <lambdabot>  f (g (h x))
05:05:16 <funktio> @pl \xs -> (xs, f xs)
05:05:16 <lambdabot> ap (,) f
05:05:59 <Deewiant> @pl \xs -> g xs (f xs)
05:06:00 <lambdabot> ap g f
05:06:16 <matthew_-> ANNOUNCE: Sessions 2008.5.2 and updated tutorial. Now supporting higher order sessions, channels and a new improved, composable means to describe session types. http://wellquite.org/sessions/tutorial_1.html
05:06:16 <lambdabot> Title: Well Quite
05:06:45 <dolio> > mconcat [show, reverse] "foo"
05:06:46 <lambdabot>  "\"foo\"oof"
05:07:41 <dolio> > sequence [f,g,h] x :: [Expr]
05:07:43 <lambdabot>  [f x,g x,h x]
05:11:16 <mm_freak_work> @pl \xs -> (head xs, length xs)
05:11:16 <lambdabot> liftM2 (,) head length
05:11:30 <MyCatVerbs> Oh wow, strictness annotations broke my program.
05:11:42 * MyCatVerbs wasn't even aware that he was making use of laziness anywhere in there.
05:15:25 <povman> map (+1) $ map (*2) $ [1,2,3,4] -- will this execute in the same way as map (\x -> x * 2 + 1) [1,2,3,4] ?
05:15:51 <povman> (with ghc)
05:15:53 <dolio> With optimizations it probably will.
05:16:25 <povman> so I shouldn't try to put lotsa-stuff in the same loop like i would in java?
05:16:36 <MyCatVerbs> If you turn optimizations up, it should make use of RULES pragmas to optimize that into ((+1).(*2))
05:16:44 <SamB> do whatever you feel is more readable
05:17:16 <MyCatVerbs> SamB: excellent advice. With that in mind, let's translate all the combinator names to Prussian.
05:17:35 <MyCatVerbs> SamB: not because I actually speak Prussian, but because AFAIK the language sounds quite pleasant when spoken aloud.
05:17:46 <SamB> not that kind of readable
05:17:57 <povman> MyCatVerbs: what if i have something a lot more complex than (+1).(*2)?
05:18:16 <MyCatVerbs> Okay, how about we use that newfangled UTF-8 support and rewrite everything using Hangul characters to make it physically prettier to look at?
05:18:43 <MyCatVerbs> povman: GHC knows that for all f and g, map f (map g (x)) can be reduced to map (f . g) x
05:18:54 <SamB> MyCatVerbs: what about first letters?
05:19:17 <MyCatVerbs> povman: (provided you turn the optimization options high enough to make it actually try, of course. -O0 need not apply. ^_^)
05:19:22 <SamB> also I don't know how to type hangul
05:19:30 <povman> SamB: class and type names etc are in bold :)
05:19:38 <MyCatVerbs> povman: check out RULES pragmas in GHC's manual, if you're interested.
05:19:43 <povman> MyCatVerbs: thanks
05:19:49 <SamB> povman: I don't know the Unicode for bold!
05:19:56 <MyCatVerbs> SamB: neither do I, but for prettier text, it might be worth learning.
05:20:30 <SamB> anyway, I meant "easier to understand"
05:20:49 <MyCatVerbs> SamB: ahhhh. In that case, we should phrase everything in terms of simpler, easier-to-learn building blocks.
05:20:54 <MyCatVerbs> SamB: SKI calculus, anyone? :)
05:21:01 <SamB> that isn't easy to understand
05:21:06 <povman> learn /= understand
05:21:31 <MyCatVerbs> SamB: maybe we should go for something procedurally straightforward then.... brainfuck!
05:21:46 <povman> MyCatVerbs: shakespeare programming language is really nice to read
05:21:59 <povman> or homespring
05:22:37 <SamB> I suppose we could use some of the JIS characters ;-)
05:25:05 <povman> ghc should have a feature for babelfishing code
05:25:26 <MyCatVerbs> Between programming languages too, not just natural ones.
05:25:54 <SamB> ｈｅｌｌｏ！
05:26:04 <povman> ghctranslate from=asm to=haskell'
05:26:52 <povman> SamB: !
05:27:03 <povman> the effect is amasing
05:27:38 <SamB> I was actually thinking more like the star and so forth...
05:27:48 <SamB> but I can't figure out how to type those
05:28:23 <povman> :t foldl
05:28:25 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:28:48 * SamB seeks tools to allow viewing of SCIM tables
05:31:21 <MyCatVerbs> povman: never heard of it. Once I heard of continuation-passing, deliberately obfusticated languages just didn't have the same appeal anymore. Not when I can write such incredibly confusing code myself on purpose, instead, and have it actually be useful and occasionally run unreasonably fast as a result. :)
05:31:42 <MyCatVerbs> povman: oh and knot-tying and delayed-instantiation (Prolog there, not Haskell) and many other such things.
05:32:29 <povman> what's knot-tying?
05:33:00 <MyCatVerbs> povman: building a data structure that refers to itself.
05:33:10 <povman> o like fix
05:33:12 <SamB> in Haskell knot-tying is relatively straight-forward
05:33:52 <povman> and.. the other one?
05:33:56 <povman> delayed-instantiation?
05:33:57 <MyCatVerbs> povman: like say you want to build a list where every element is the list's length...
05:34:02 <MyCatVerbs> > let l = repeat 40 (length l) in l
05:34:03 <lambdabot>  Couldn't match expected type `Int -> [a]'
05:34:11 <MyCatVerbs> > let l = replicate 40 (length l) in l
05:34:13 <lambdabot>  [40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,...
05:34:42 <povman> > let l = replicate 5 (length l) in l
05:34:43 <lambdabot>  [5,5,5,5,5]
05:34:45 <povman> wow.
05:34:56 <Deewiant> how does that work O_o
05:35:27 <MyCatVerbs> povman: er, probably the wrong term. Better phrased as "incomplete data structures". It's a cool technique in Prolog programming whereby you don't completely specify a data structure's contents, instead you have it be lazily filled in as your program runs.
05:35:29 <amiddelk> now so impressive if you convince yourself that computing the length of a list does not depend on the values of the contents of the list
05:35:32 <MyCatVerbs> Deewiant: laziness.
05:35:34 <amiddelk> -now +not
05:35:54 <Deewiant> right, it leaves the thunks unevaluated when it computes the length
05:35:57 <povman> MyCatVerbs: isn't that how haskell works?
05:35:59 <MyCatVerbs> Deewiant: the actual value of each of those cells isn't needed in order to compute the length of that list.
05:36:16 <Deewiant> > let l = replicate 5 (sum l) in l
05:36:17 <MyCatVerbs> povman: it's kind of difficult to explain, and I'm not really explaining it very well, or even correctly.
05:36:22 <Deewiant> :-)
05:36:32 <lambdabot>  thread killed
05:36:56 <pastorn> how do i write a recursive CPS function (factorial, for example)?
05:37:03 <MyCatVerbs> povman: I know of no way to do it in Haskell. It's not about lazily *evaluating* the data structure, but lazily *instantiating* it instead, using the unifier.
05:37:03 <pastorn> @paste
05:37:04 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:37:53 <pastorn> http://hpaste.org/7438
05:38:24 <povman> pastorn: use fix
05:38:30 <povman> :t fix
05:38:32 <lambdabot> forall a. (a -> a) -> a
05:38:35 <pastorn> povman: i hate fix
05:38:46 <pastorn> i wanna do it like a normal function
05:38:53 <pastorn> fix just gives me a headache
05:39:27 <SamB> MyCatVerbs: eh?
05:39:54 <pastorn> povman: annotated
05:39:58 <MyCatVerbs> SamB: like I said, it's subtle and I'm explaining it wrong.
05:40:26 <MyCatVerbs> SamB: I don't understand the technique well enough to apply it or explain it, but I've seen some really cool programs that demonstrate it.
05:41:02 <amiddelk> MyCatVerbs: probably means something like having values with holes in it, which can be filled in by the callee instead of the caller
05:41:26 <SamB> any links?
05:41:29 <MyCatVerbs> amiddelk: yes, I believe that is it.
05:41:49 <MyCatVerbs> SamB: 'fraid not. I read about it in "The Art Of Prolog", and I swiped that from my uni's library.
05:41:58 <amiddelk> there is a haskell library by the way
05:42:04 <SamB> wonder if my uni has it
05:42:32 <Deewiant> > let l = replicate 1 (sum l) in l
05:42:32 <SamB> haskell library for what?
05:42:48 <lambdabot>  thread killed
05:42:53 <Deewiant> > (\l -> l == replicate 1 (sum l)) [1]
05:42:55 <lambdabot>  True
05:43:10 <amiddelk> SamB: some monad called LogicT
05:43:38 <SamB> which allows this other knot-tying to occur?
05:44:22 <povman> pastorn: try that
05:44:31 <povman> you need to import Data.Function first though
05:44:40 <SamB> hmm, I think I could get a friend of mine to borrow it for me...
05:45:13 <SamB> or perhaps I could borrow it from the Philadelphia library system?
05:45:28 <povman> pastorn: you might enjoy the Cont monad too :)
05:45:53 <pastorn> povman: even without fix you would need a subfunction, right?
05:46:17 <pastorn> povman: gotta learn to walk before you run :)
05:46:21 <amiddelk> SamB: suppose you want to write something like: let { x = 3 + y; x = 4; y = _ } in y
05:46:23 <povman> do you mean the lambda?
05:46:29 <SamB> Google Book Search links to this neat service: http://worldcat.org/wcpa/isbn/0262193388
05:46:30 <lambdabot> Title: The art of Prolog : advanced programming techniques [WorldCat.org]
05:46:46 <SamB> shows you libraries that have the book
05:47:40 * SamB <3 google toolbar
05:47:57 <povman> pastorn: there's a version without lambdas for you :)
05:48:10 <povman> you can see how fix works there pretty clearly
05:48:26 <povman> it passes fact' to itself as the first argument
05:48:34 <pastorn> is it possible to do without fix?
05:48:52 <SamB> is everyone aware that google toolbar is now available for Firefox/Iceweasel on Linux?
05:49:33 <povman> pastorn: try that :)
05:49:35 <MyCatVerbs> SamB: it's a really good book, but it takes a while. Works from the definitions upwards.
05:49:51 <pastorn> povman: that seems better :D
05:49:58 <povman> pastorn: i.e. to make CPS, just wrap around the original function
05:49:59 <pastorn> thanks <3
05:50:13 <pastorn> @type fix
05:50:16 <lambdabot> forall a. (a -> a) -> a
05:50:23 <pastorn> ?src fix
05:50:24 <lambdabot> fix f = let x = f x in x
05:51:00 <Arnar_> ?index fix
05:51:00 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
05:51:12 <pastorn> povman: what is the f in the first fact'?
05:51:15 <MyCatVerbs> SamB: found this: http://www.lix.polytechnique.fr/~liberti/public/computing/prog/prolog/prolog-tutorial.html#inc -- might be useless, though, because it's so fantastically excessively terse. :/
05:51:16 <lambdabot> Title: Prolog Tutorial, http://tinyurl.com/59l8pc
05:51:56 <povman> you can see it used in (f (n-1))
05:52:14 <povman> fix takes a function, and passes it to itself as the first argument
05:52:30 <povman> so fix fact' means that f = fact' in fact'
05:53:49 <pastorn> povman: and so my headache is back ;)
05:54:06 <pastorn> need to go now, i'll look more into this later, thanks
05:54:11 <povman> cu
05:56:57 <SamB> hmm, yes, my library card will allow me to get books from the Philadelphia library system
05:57:20 <mxc> philly in the house
05:57:47 <mxc> dont let the singapore IP fool you, i'm a born and bred philadelphian
05:58:24 <SamB> which is good, because I fear my Philadelphia card exired LONG ago...
06:01:46 <SamB> now I'm emailing my mom to ask her how I would get the book out ;-)
06:02:24 <mxc> exploits of a mom
06:02:49 <SamB> well, she uses the library a lot more than I do, so maybe she knows, or she could ask a librarian next time she goes
06:03:42 <mapreduce> Does Haskell have any solution to the problem of "all my static typing is gone when I do SQL in strings" problem?
06:04:01 <mapreduce> E.g., running the database in-process and querying it without SQL.
06:04:14 <matthew_-> nah, not if you use HaskellDB
06:04:26 <mapreduce> @go haskelldb
06:04:27 <lambdabot> http://haskelldb.sourceforge.net/
06:04:27 <lambdabot> Title: HaskellDB
06:05:05 <SamB> matthew_-: ITYM "yes"
06:05:14 <SamB> rather than "nah"
06:05:17 <earthy> or HSQL, or Takusen
06:05:22 <SamB> since mapreduce asked if haskell had solutions
06:05:39 <earthy> iirc
06:05:43 <matthew_-> SamB: good point
06:05:59 <mapreduce> There's nothing in HaskellDB to guarantee that the column names mentioned in the code are what's really in the table.
06:06:07 <mapreduce> Or that they have the right types.
06:06:13 <SamB> mapreduce: that may be impossible to solve
06:06:31 <SamB> because, you know, someone could have changed the DB schema since you compiled your program
06:06:38 <earthy> s/may be/is/
06:06:56 <SamB> sometimes I use weaker language then necessary ;-)
06:07:03 <earthy> ;)
06:07:23 <mapreduce> Someone could have changed a byte in your binary, but that doesn't make Haskell's typing system useless.
06:07:45 <SamB> well, there are partial solutions
06:08:05 <SamB> maybe HSQL was the one that had solutions?
06:08:44 <mapreduce> Given the assumption that DB schemas do not change between compiles, you could stretch static typing across there.
06:09:14 <mapreduce> If the DB was written in Haskell and SQL wasn't used, it might not even be a stretch.
06:09:20 <SamB> personally I would prefer to use techniques that did not require a DB instance just to compile the code
06:09:37 <SamB> and yes, it would be a stretch even then
06:09:46 <mapreduce> I would prefer to use DBs where a DB instance was cheap enough to use when compiling the code :)
06:09:58 <SamB> haskell is not dependantly typed (yet) ;-)
06:10:23 <SamB> I was thinking more in terms of not having one set up, then it being expensive to set it up
06:10:31 <mapreduce> Anyway, I don't mean that, but you could compile the DB (or at least your part of it) when compiling your code.
06:10:55 <SamB> I would be happy for the tools to be able to work in that way, I just wouldn't want them to only work that way...
06:11:20 <mapreduce> I see, thanks.
06:11:22 <earthy> what you want is that you take the DDL for the DB and have types generated from it for your queries, if I understand you correctly, mapreduce?
06:11:34 <SamB> anyway, there is definately a library that will allow you to make typesafe SQL queries using combinators
06:11:47 <mapreduce> earthy: I was looking for ideas really, but yes that works.
06:11:53 <SamB> what's DDL?
06:11:58 <earthy> data description language
06:12:25 <earthy> or, in that sentence, the description as written in that language
06:12:33 <mapreduce> I've written such a typesafe thing for Java using some type hackery with its generics.
06:12:48 <earthy> it's doable with HaskellDB at least
06:12:56 <mapreduce> Unlike Haskell though, you really don't want to see the intermediate types. :)
06:13:06 <mapreduce> I was just wondering how far it could go.
06:13:35 <sioraiocht> @src length
06:13:35 <lambdabot> Source not found. Do you think like you type?
06:13:45 <sioraiocht> :t legnth
06:13:47 <lambdabot> Not in scope: `legnth'
06:13:49 <sioraiocht> :t length
06:13:51 <lambdabot> forall a. [a] -> Int
06:13:54 <SamB> well, it might be possible to stretch the record system we don't have to cover that case ;-)
06:13:56 <sioraiocht> @src genericLength
06:13:57 <lambdabot> genericLength []    = 0
06:13:57 <lambdabot> genericLength (_:l) = 1 + genericLength l
06:14:57 <tromp> @src length
06:14:58 <lambdabot> Source not found. Take a stress pill and think things over.
06:15:16 <tromp> @src Data.List.length
06:15:16 <lambdabot> Source not found. stty: unknown mode: doofus
06:15:45 <tromp> :t length
06:15:47 <lambdabot> forall a. [a] -> Int
06:16:36 <tromp> :t genericLength
06:16:36 <Deewiant> length = foldl' (const . (1+)) 0
06:16:38 <lambdabot> forall b i. (Num i) => [b] -> i
06:30:24 <yrlnry> @src foldl'
06:30:25 <lambdabot> foldl' f a []     = a
06:30:25 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:34:22 * SamB is happy to have found the homomorphisms in Agda's library, so he can assert homomorphism between Data.DifferenceList's DiffList and Data.List's [_]
06:37:10 <BattlePope|Uni> Say i have a Rational number and using show i want to output it as a double. How?
06:38:20 <sw17ch> BattlePope|Uni, show (fromRational x) :: Double
06:39:56 <Saizan> show (fromRational x :: Double)
06:43:05 <BattlePope|Uni> Cheers!
06:43:28 <bauchus> ?where KeyRight
06:43:28 <lambdabot> I know nothing about keyright.
06:44:12 <BattlePope|Uni> ?where are my keys
06:44:13 <lambdabot> I know nothing about are.
06:46:00 <quicksilver> ?faq Can haskell find my keys?
06:46:01 <lambdabot> The answer is: Yes! Haskell can do that.
06:47:22 <Saizan> that faq is not contructive.
06:47:28 <Saizan> +s
06:47:35 <sw17ch> ?faq Can haskell ask a question even Haskell can't answer?
06:47:35 <lambdabot> The answer is: Yes! Haskell can do that.
06:47:46 <sclv_> faq++
06:47:52 <sclv_> ?karma faq
06:47:53 <lambdabot> faq has a karma of 1
06:48:54 <HunterXHunter> ?faq Can Haskell beat Curry Haskell?
06:48:54 <lambdabot> The answer is: Yes! Haskell can do that.
06:49:28 <quicksilver> Not everything in this world has to be constructive.
06:49:40 <quicksilver> Some things are merely humorous, and all the better for it.
06:49:50 <sw17ch> ?faq Can Haskell brew a Porter?
06:49:50 <lambdabot> The answer is: Yes! Haskell can do that.
06:50:02 <sclv_> ?seen mapreduce
06:50:02 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
06:50:12 <sclv_> ?yow
06:50:13 <lambdabot> YOU PICKED KARL MALDEN'S NOSE!!
06:50:25 <sw17ch> ??
06:50:33 <sw17ch> ?help
06:50:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:50:52 <mapreduce> sclv_: What can I do for you?
06:50:54 <mauke> preflex_: seen mapreduce
06:50:54 <Deewiant> ?help yow
06:50:54 -preflex_(n=preflex@d83-189-98-12.cust.tele2.de)- mapreduce was last seen on #haskell 2 seconds ago, saying: sclv_: What can I do for you?
06:50:55 <lambdabot> yow. The zippy man.
06:50:57 <mauke> :(
06:51:28 <HunterXHunter> @seen mapreduce
06:51:29 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
06:51:33 <sclv_> mapreduce: http://hpaste.org/7168
06:51:51 <sclv_> its where i've gotten on the db/static typing problem so far.
06:52:32 <sclv_> same issue as haskelldb -- it requires you know your types at compile time, and there's no autogeneration tool yet.
06:52:44 <bauchus> boring? try the preview of topkata (darcs get http://cbauer.dnsalias.net/topkata/). Press the Tab key and find the exit.
06:52:52 <sclv_> but the language is more haskellish and more sqlish at once, and the typing is pretty strong.
06:52:54 <mapreduce> sclv_: http://pastebin.com/d1af91bc5 but still uses strings for column names etc.
06:56:54 <sclv_> code so far is here, if yr. interested: http://code.haskell.org/~sclv/hvac/Database/StaticRecord.hs
06:57:14 <sclv_> makes heavy use of generics, a few typeclass tricks.
06:59:28 * edwardk waves hello.
07:00:07 <mapreduce> sclv_: I don't actually care about 'transparent update' as ORM normally involves.  Interesting code.
07:01:02 <sclv_> I copied the phantom types for typing the dsl bit directly from haskelldb.
07:02:07 <sclv_> just got multikeys working too, which is nice.
07:15:53 <povman> woo, i converted my java dpll algorithm to haskell and it went faster!
07:16:22 <yaarg> you sound surprised?-)
07:16:23 <mauke> yay for compiled languages vs. interpreted
07:16:34 <povman> 1337
07:16:52 <mapreduce> Neither are interpreted.
07:17:06 <Baughn> Interpreted bytecode
07:17:15 <Baughn> No matter what you hope, it is /not/ going to be as fast as native
07:17:24 <mapreduce> That's not the language.
07:17:24 <povman> well the 'interpreted' one is also more than twice the length and a lot harder to read, so it gains nothing
07:17:28 <mauke> until they build a jvm in hardware
07:17:32 <Nafai> Java isn't interpreted bytecode, is it?
07:17:35 <Nafai> What about the jIT?
07:17:42 <sw17ch> mauke, AMD is considering that
07:17:50 <Nafai> The compiles things into native code, doesn't it?
07:17:54 <Nafai> s/The/That/
07:17:58 <mapreduce> The JVM interprets somebytecode and compiles some.
07:18:02 <Baughn> Nafai: JIT doesn't do very much optimization, though. Or at all.
07:18:03 <mauke> Nafai: maybe, possibly, sometimes
07:18:13 <Baughn> Nafai: It does have the advantage of profiling, but..
07:18:40 <Baughn> A combination of offline optimization and online profiling would work even better, if anyone cares to try
07:19:01 <povman> is anyone working on a hardware lambda calculus reducer?
07:19:01 <Nafai> My uninformed opinion would attribute the speed-up to Haskell's laziness and other features, rather than JVM vs. Native Code
07:19:03 <mapreduce> Baughn: It does enough that turning it off causes programs to be an order of magnitude slower.
07:19:55 <Baughn> mapreduce: Still, it has to execute in realtime. Heavy optimizations can take seconds, so..
07:20:02 <mapreduce> Nafai: Scala has laziness (not the default) and doesn't compete with Haskell on speed.
07:20:12 <mapreduce> Baughn: It caches them between runs.
07:20:49 <Nafai> mapreduce: That's why I said "uninformed" :)
07:21:16 <Nafai> Then again, I've been in the Java world too long so my views have probably been warped by enterprise thinking
07:21:28 <Baughn> mapreduce: It also doesn't have as much high-level information as the original java source, never mind haskell source. That makes it harder to do optimizations
07:21:50 <povman> my data format might have been more efficient in the haskell version, it was [[Term]] as opposed to Vector<Vector<Integer>>
07:22:27 <Baughn> povman: Seeing as that's a different /kind/ of data structure, that depends entirely on what you ask it to do
07:22:35 <mapreduce> Baughn: It has analysis that can tell when you're only putting Strings into a list and can optimise for that.
07:22:35 <ToRA> povman: why were you using Vector? for all but very special cases you want ArrayList...
07:22:57 <Baughn> mapreduce: Shouldn't that be obvious from the List<String> type?
07:23:02 <mapreduce> iow it can get back what little useful info is lost through inspection.
07:23:15 <mapreduce> Baughn: That's only a static type.
07:23:45 <povman> ToRA: i am only 5th kyu in java-fu
07:24:05 <Deewiant> ToRA: the difference isn't /that/ big in practice.
07:24:09 <mapreduce> Not only Java lives on the JVM; not many optimisations are Java-specific.
07:24:42 <povman> also my parsec parser was a lot quicker than the java scanner loop
07:25:08 <povman> which probably means i could have optimised the java code betterly, but i didn't have to with haskell
07:25:23 <povman> anyway sleepytime
07:26:08 <mauke> pfft, you call this a flamewar? I'm going to troll somewhere else
07:44:19 * edwardk finally gives in and subscribes to haskell-cafe
07:45:12 <edwardk> @seen dolio
07:45:12 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
07:45:20 <edwardk> interesting result
07:45:26 <edwardk> @seen edwardk
07:45:27 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
07:46:08 <mauke> preflex: seen dolio
07:46:08 -preflex(n=preflex@d83-189-98-12.cust.tele2.de)- dolio was last seen on #haskell 2 hours, 30 minutes and 14 seconds ago, saying: With optimizations it probably will.
07:46:41 <edwardk> mauke: thx
07:46:59 <edwardk> preflex: tell dolio announced
07:47:10 <mauke> it doesn't do that :(
07:47:14 <edwardk> fair nuff =)
07:47:20 <mauke> try memoserv
07:47:20 <edwardk> @tell dolio announced
07:47:20 <lambdabot> Consider it noted.
07:47:34 <edwardk> we'll see if she at least works that well then =)
07:52:50 <quicksilver> > 1+2
07:52:53 <lambdabot>  3
07:52:55 <quicksilver> @quote quicksilver
07:52:55 <lambdabot> quicksilver says: learning from other people's mistakes is so web 1.0
07:52:58 <quicksilver> hmm
07:53:00 <quicksilver> mostly working then
07:53:03 <quicksilver> just seen broken?
08:13:16 <sioraiocht> STUArray s Int Word16 <--- what is wrong with this type signature?
08:13:46 <sioraiocht> Expected type: STUArray s Int Word16
08:13:47 <sioraiocht>       Inferred type: STUArray s Int (a t t1)
08:13:51 <sioraiocht> that's rather unhelpful? =p
08:13:57 <fons> > dataTypeOf (1 :: Int)
08:13:59 <lambdabot>  DataType {tycon = "Prelude.Int", datarep = IntRep}
08:14:44 <fons> can someone tell me where the Data instances of all types are defined?
08:15:38 <fons> I import Data.Generics.Basics and, contrary to what the haddock documentation shows, they don't seem to be there
08:16:50 <sclv_> fons: just import Data.Generics
08:16:52 <mauke> sioraiocht: need more context
08:16:59 <sclv_> (they should be in Data.Generics.Instances though)
08:17:20 <fons> sclv_: Data.Generics.Instances ... perfect
08:17:24 <sioraiocht> mauke: okay, I'm trying to make an Unboxed STUArray of Word16 to fill up and then freeze
08:17:25 <fons> thanks
08:18:06 <sioraiocht> I was trying to get this code to run without typechecking problems runSTUArray (do { array <- (newArray (1,size) 0 ; return array})
08:18:13 <sioraiocht> but it compalins about the type of newArray
08:19:11 <sioraiocht> grr, adding a type signature to the enclosing function worked
08:19:13 <sioraiocht> but I have no idea why
08:19:55 <ToRA> @hoogle iterateM
08:19:56 <lambdabot> No matches found
08:20:51 <ToRA> @hoogle (a -> m a) -> a -> [m a]
08:20:52 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
08:20:52 <lambdabot> Data.List.iterate :: (a -> a) -> a -> [a]
08:20:52 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
08:25:08 <trez> > replaceExtension "foo/bar.baz" "foo"
08:25:08 <lambdabot>   Not in scope: `replaceExtension'
08:26:37 <fons> Question regarding Data.Generics, I would like to know the arity of the constructors of a data type
08:26:51 <fons> is it possible at all?
08:27:33 <fons> ConstRep only seems to keep track of the constructor name and fixity, but not its arguments :S
08:28:25 <fons> I'm totally new to Generics but I would like them to do type-translation in the embedded compiler of a EDSL
08:28:57 <fons> e.g. data List a = Null | a :- List a
08:29:25 <fons>   deriving (Data, Typeable)
08:30:51 <fons> I would like to be able to guess if the List type is enumerated by checking the the arity of its constructors (the answer is obviously no)
08:36:10 <LordBrain> enumerated as in a member of Enum?
08:36:50 <fons> LordBrain: by enumerated I mean, an algebraic type whose type constructors have xero arity
08:36:53 <fons> zero*
08:36:59 <LordBrain> oh
08:37:21 <fons> e.g. data Colors = Blue | Green | Red
08:37:28 <LordBrain> i get you
08:44:06 <BattlePope|Uni> Say I want to output an error message if a user tries to divide by zero. Right now I have eval (Expr Divide e1 0)     = error "division by zero". What is a more correct format for that?
08:45:21 <Philippa> BattlePope|Uni: you'd need some kind of channel for error messages from the eval function
08:45:36 <Philippa> a common way to do it's to use a monad that supports error handling - monads are *good* for evaluators
08:45:51 <Philippa> if they scare you, return an Either ErrorMsg Result (or similar) and work from there?
08:46:28 <Botje_> .. and when you're done we'll tell you what you've written >:)
08:47:16 <BattlePope|Uni> heh, way over my head I'm afraid.
08:47:37 <BattlePope|Uni> my understanding of it was just that if you match some condition, you can return an error using that function
08:48:02 <BattlePope|Uni> ie in the same way you establish a base case for a function, you establish a case that returns an error
08:48:05 <qwr> @src error
08:48:06 <lambdabot> error s = throw (ErrorCall s)
08:48:06 <Philippa> you can, yes
08:48:13 <Philippa> but you also need a way to return the error
08:48:40 <BattlePope|Uni> hmm
08:48:49 <Philippa> BattlePope|Uni: ignore how error's implemented, it's a built-in
08:48:57 <Philippa> for "a way to return the error", that's why I suggested the Either type
08:49:19 <Philippa> the approach you showed above works, it's just that it also kills your program dead :-)
08:49:30 <BattlePope|Uni> that's how it's supposed to work
08:49:51 <BattlePope|Uni> At least, it is if my understanding of my assignment is correct.
08:50:07 <qwr> Philippa: you can catch those bastards^Wexceptions. although it's nicer to use some monad
08:50:33 <Philippa> qwr: Trust me, for BattlePope|Uni's purposes that's not helpful
08:50:34 <qwr> (catch works anyway only in IO)
08:50:39 <Philippa> you can't do it in Haskell98, for example
08:50:54 <qwr> Philippa: i know :)
08:50:58 <BattlePope|Uni> This is like a twelve line program, so the simplest thing would work
08:50:58 <Philippa> BattlePope|Uni: error will work fine, then
08:51:21 <Philippa> so I guess the problem's getting the pattern-match right instead?
08:51:22 <BattlePope|Uni> ok. I am just unsure as to the proper syntax, as the one I have now returns an error when I try to do it
08:51:33 <BattlePope|Uni> No instance for (Num Expression)
08:51:34 <BattlePope|Uni>       arising from the literal `0' at calc.hs:19:20
08:52:04 <quicksilver> that's got nothing to do with your use of error.
08:52:11 <BattlePope|Uni> oh
08:52:13 <BattlePope|Uni> awesome
08:52:13 <Philippa> *nod*. Also, you really need to look at whether it's 0 after it's evaluated, not before
08:52:20 <quicksilver> that's to do with (Expr Divide e1 0)
08:52:26 <BattlePope|Uni> right
08:52:27 <Philippa> you're mixing up the source type (Expression) and the result type
08:52:47 <BattlePope|Uni> I wouldn't put it past me
08:53:26 <Philippa> does it work if you comment out that case?
08:53:33 <BattlePope|Uni> yeah
08:53:47 <BattlePope|Uni> it was working fine before I tried to add in the error case
08:54:42 <qwr> BattlePope|Uni: are sure, you didn't mean Expr (Divide e1 0)
08:54:47 <Philippa> okay. It might be easier to work the error-handling inside the existing divide case then?
08:54:59 <Philippa> qwr: unless I'm much mistaken, it's more complicated than that
08:55:32 <BattlePope|Uni> all my other cases are in the form eval (Expr [some operator] e1 e2)
08:55:50 <BattlePope|Uni> Philippa, that sounds logical.
08:56:28 <Philippa> one reason to do it inside: you care about whether the dividand /evaluates to/ 0, not whether it is zero
08:56:31 <BattlePope|Uni> So, I put a tab and a guard on a new line below the division case, with basically the same thing in there?
08:56:53 <MarcWeber> dcoutts: Which is the way to get the path of the ghc compiler nowadays? using lookup knownPrograms ? I need the path in postConf
08:57:02 <Philippa> it'd have to be above, but yeah, that'd work
08:57:23 <Philippa> there're neater ways of doing it - you might want to read up on case statements. But same difference
08:57:25 <BattlePope|Uni> above? oh.
08:57:36 <Philippa> yeah, you need the failing case to take priority if it fails
08:57:44 <BattlePope|Uni> oh, gotcha
08:57:54 <Philippa> the semantics say that it works by checking each pattern in turn and taking the first that matches
08:58:22 <BattlePope|Uni> hmmm
08:58:26 <BattlePope|Uni> parse error on input
08:58:26 <BattlePope|Uni> fail
08:58:32 <BattlePope|Uni> '|'
08:59:05 <Philippa> what does your line look like?
08:59:43 <BattlePope|Uni>     | eval (Expr Divide e1 0) = error "division by zero"
08:59:45 <qwr> BattlePope|Uni: what is the type of e1 ?
09:00:17 <BattlePope|Uni> Expression
09:00:29 <qwr> BattlePope|Uni: and the syntax is foo args... | condition = expr1 | condition = expr2
09:00:31 <BattlePope|Uni> which is rational, i think
09:00:45 <whe5xj> why you write 0 rather than e2 | eval e2 == 0 = error .. ?
09:00:58 <qwr> BattlePope|Uni: eval whatever is probably not a boolean expression
09:00:59 <BattlePope|Uni> dunno, I'm foolish?
09:01:07 <whe5xj> well it's possibly not a mistake
09:01:08 <whe5xj> idk
09:01:23 * whe5xj just popped in this moment
09:01:48 <qwr> BattlePope|Uni: and should anyway do something like = case eval e2 of { 0 -> error "..."; divisor -> eval e1 / divisor }
09:01:52 <Philippa> BattlePope|Uni: you don't want to use eval as the guard, you want to use whether eval results in zero
09:02:13 <Philippa> whe5xj's got the right idea
09:03:41 <BattlePope|Uni> e2 | eval e2 == 0 = error "division by zero" gives an error
09:04:41 <whe5xj> hey here's an idea
09:04:42 <BattlePope|Uni> qwr: is that an alternate way, which puts it on one line?
09:05:09 <whe5xj> eval (Expr Divide lhs rhs) = eval lhs / eval rhs
09:05:22 <qwr> BattlePope|Uni: case ... of is a pattern match. {;} are there to be able to write it on one line
09:05:32 <whe5xj> if you do that you get the if-the-denominator-is-zero-throw-error for free :)
09:05:58 <BattlePope|Uni> unfortunately putting the error message in there myself is part of the coursework
09:06:00 <BattlePope|Uni> :(
09:06:15 <whe5xj> oh well then you could say
09:06:17 <qwr> whe5xj: only thing, that it will probably cause double-evaluation of e2. of course, unless compiler optimizes it away ;)
09:06:21 <whe5xj> eval (Expr Divide lhs rhs) = eval lhs `mydiv` eval rhs
09:06:36 <whe5xj> _ `mydiv` 0 = error ...
09:06:44 <whe5xj> x `mydiv` y = pink elephants
09:08:03 <BattlePope|Uni> why can't I do something similar to _ `mydiv` 0 = error without defining another division function?
09:08:27 <dons> you can't add new cases to an existing function, separate from its original definition
09:08:46 <qwr> BattlePope|Uni: you can with case. the separate division function is mostly a matter of taste
09:09:54 <BattlePope|Uni> dons: what?
09:10:29 <Saizan> BattlePope|Uni: he meant that you can't modify the existing (/) function, however you don't need that here
09:10:43 <BattlePope|Uni> oh right.
09:11:31 <qwr> BattlePope|Uni: anyway, you've already given 3 solutions which probably work...
09:11:55 <BattlePope|Uni> but I have yet to understand why those solutions work
09:12:13 <BattlePope|Uni> And I'm not here for a code handout, I'm here for understanding :D
09:12:22 <Saizan> do you know about case .. of?
09:12:28 <BattlePope|Uni> no, Saizan
09:12:34 <whe5xj> BattlePope: Haskell doesn't think that: lhs == eval lhs
09:12:50 <whe5xj> BattlePope: so 0 == lhs is different to 0 == eval lhs
09:12:52 <BattlePope|Uni> this is like the third assignment in my haskell course
09:13:17 <BattlePope|Uni> well explained, whe5xj.
09:13:21 <qwr> BattlePope|Uni: read gentle introduction to haskell, if you want explanation on the syntax? :P
09:13:30 <Saizan> ?src length
09:13:30 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:13:59 <ibid> so bishop got renamed? cool
09:14:59 <Igloo> ibid: Yeah, and the hosting people have changed the name they have for it, so it should stay renamed
09:15:16 <qwr> BattlePope|Uni: or tell us, what you don't understand :)
09:15:52 <Saizan> BattlePope|Uni: you probably have seen a function definition like length [] = 0; length (x:xs) = 1 + length xs, that's equivalent to length list = case list of [] -> 0; (x:xs) -> 1 + length xs
09:15:53 <BattlePope|Uni> mostly everything
09:15:55 <Arnar_> hey folks
09:16:07 <Arnar_> what's the definition of a Monoid?
09:16:27 <conal> @src Data.Monoid
09:16:27 <lambdabot> Source not found. My brain just exploded
09:16:39 <BattlePope|Uni> lol
09:17:02 <Arnar_> ?info Data.Monoid
09:17:02 <lambdabot> Data.Monoid
09:17:04 <conal> Arnar_: has an associative operator, mappend, and an identity, mappend.
09:17:12 <BattlePope|Uni> so if I write eval (Expr Divide e1 e2) == 0     = error "division by zero"
09:17:16 <conal> i mean mempty
09:17:17 <Arnar_> conal: ok.. thx
09:17:18 <BattlePope|Uni> would that work?
09:17:23 <whe5xj> no
09:17:28 <Arnar_> :type mempty
09:17:45 <Arnar_> :t mempty
09:17:47 <lambdabot> forall a. (Monoid a) => a
09:17:53 <conal> @type mempty
09:17:55 <lambdabot> forall a. (Monoid a) => a
09:18:04 <Arnar_> > mempty :: [a]
09:18:05 <lambdabot>  []
09:18:06 <BattlePope|Uni> but that is looking at the output of the expr after evaluation, isntead of before, which was the larger point I thought everyone was going for?
09:18:08 <qwr> BattlePope|Uni: no. :)
09:18:13 <Arnar_> ok, í see
09:18:40 <BattlePope|Uni> qwr: Rats.
09:18:44 <Arnar_> conal: the associative operator for [] is (++) ?
09:18:57 <Saizan> BattlePope|Uni: you can't put functions in patterns like that
09:19:06 <Arnar_> and [] the idenity?
09:19:10 <whe5xj> BattlePope: do you have working code now? like except for the zero checking?
09:19:15 <BattlePope|Uni> yes
09:19:25 <whe5xj> BattlePope: and do you understand every bit of it?
09:19:34 <BattlePope|Uni> yeah, I think so.
09:19:44 <whe5xj> you could hpaste it
09:19:52 <dino-> For xmonad, could wm-style dockapps be used with ManageDocks?
09:19:52 <whe5xj> and ask if there's anything not clear
09:19:58 <whe5xj> hpaste: url?
09:20:04 <whe5xj> hpaste.org
09:20:38 <dons> dino-: i suspect so.
09:20:43 <BattlePope|Uni> er
09:20:46 <dons> dino-: but we'd need to check if wm stuff behaves
09:20:52 <BattlePope|Uni> how to i add stuff to the site?
09:21:02 <qwr> BattlePope|Uni: the thing you wrote (... == 0 = error) is not a valid haskell syntax. you can have guards (boolean expressions) which are marked as name arguments... | guard = exression
09:21:14 <whe5xj> BattlePope: go to new paste
09:21:52 <BattlePope|Uni> ok, it's up there
09:22:13 <Philippa> ... == 0 is a valid guard though
09:22:34 <whe5xj> first thing, you don't have to have those parenthesis
09:22:45 <BattlePope|Uni> ok, great
09:22:52 <BattlePope|Uni> next thing? ;)
09:23:03 <dino-> dons: Ok, thanks. I'm not so experienced with X stuff yet, so no sure what these dockapps are doing.
09:23:10 <whe5xj> (keep them if you like, but you could write evalr e1 + evalr e2 rather than ( evalr e1 ) + ( evalr e2) since function application binds tighter than operators)
09:23:38 <BattlePope|Uni> btw, http://hpaste.org/7440 is the rest of the program, if you want to look at it
09:23:46 <conal> > Arnar_: yes, both.
09:23:46 <lambdabot>  Parse error at end of input
09:24:31 <conal> Arnar_: more examples here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
09:24:33 <lambdabot> http://tinyurl.com/szdxl
09:24:47 <Arnar_> conal++ thanks
09:24:51 <conal> :)
09:25:55 <BattlePope|Uni> whe5xj, what else can I do to adapt that thing into workingness?
09:26:04 <Arnar_> off-topic: in order to train my keyboarding muscle memory with xmonad and some apps.. I put my mouse behind the desk. Does anyone know how to "click" links in gnome-terminal without using the mouse?
09:26:59 <whe5xj> BattlePope: I think you should replace / with some new division operator which checks for zero
09:33:16 <BattlePope|Uni> whe5xj, that ended up being a grood idea. Thanks very much.
09:33:32 <BattlePope|Uni> Thank you, #haskell, for putting up with my newbishness.
09:37:24 <dcoutts_> MarcWeber: you want the path to the haskell compiler that we're using to build the package?
09:38:04 <MarcWeber> Ideally yes. But I think I've found a solution..
09:38:18 <dcoutts_> MarcWeber: bear in mind it may not be ghc, it might be hugs etc
09:38:47 <dcoutts_> and even if it is ghc it might not be a ghc binary, we might be using the ghc library in-process
09:43:04 <Arnar_> ?index liftIO
09:43:04 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:43:31 <Arnar_> :t liftIO
09:43:36 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
09:43:37 <edwardk> doh, that reminds me i need to define the instances for lifting operations over comonad transformers
09:43:54 <sanity> [newbie] how do i get haskell to tell me the types its inferred for a function (like ML does when you declare the function)?
09:44:10 <Arnar_> sanity: :type function or :info function at the ghci prompt
09:44:11 <whe5xj> :t flip concatMap
09:44:13 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
09:44:22 <whe5xj> that :t works in ghci
09:44:26 <sanity> whe5xj: ah, thanks
09:44:45 <sanity> and I'm correct in inferring that you can't declare a function in ghci?
09:44:51 <whe5xj> you can,
09:44:56 <whe5xj> let f x = 7
09:45:03 <whe5xj> just like in a do block
09:45:29 <sanity> whe5xj: ah, ok.  why doesn't the normal syntax for function declaration work at the prompt?
09:45:48 <Arnar_> sanity: the ghci prompt is essentially like in a IO do block
09:46:30 <sanity> Arnar_: I see
09:46:42 <Arnar_> sanity: easiest to put your functions in somefile.hs and do :load somefile
09:47:05 <sanity> Arnar_: yes, i'm using haskell-mode in emacs, that makes it easy enough
09:47:15 <MarcWeber> dcoutts_: My library is ghc specific - so this doesn't matter I'm using this now http://rafb.net/p/SoQLlG26.html (line 30) requireProgram and rawSystemProgramStdout. 4 lines to execute ghc --print-libdir :)
09:47:16 <lambdabot> Title: Nopaste - No description
09:47:28 <sanity> Arnar_: and Haskell is like Python in that indentation is part of the syntax?
09:47:59 * sanity knows standard ML, and is just beginning to investigate Haskell
09:48:23 <Arnar_> sanity: yes, indentation is part of the syntax, but in a little different manner than python
09:48:47 <dcoutts_> MarcWeber: you can do it in one
09:48:57 <sanity> Arnar_: sure, its used with let declarations - right?
09:49:14 <Arnar_> sanity: yes, and do as well
09:49:29 <Nafai> My company has a new website with randomly generated titles, this is what it came up with for me: http://www.travishartwell.net/mytitle.png
09:49:38 <MarcWeber> dcoutts_ system "ghc --print-libdir" ?
09:49:45 <dcoutts_> MarcWeber: no, use rawSystemProgramStdoutConf
09:49:58 <dcoutts_> MarcWeber: system does not give you the stdout
09:50:53 <dcoutts_> MarcWeber: I don't see why you need fmap ( head . lines )
09:51:14 <MarcWeber> dcoutts_: It works. So it's fine now. Couldn't find this *StdoutConf. Maybe my cabal versions is to old. Because I was too lazy to check wether there is a newline at the end or not
09:52:19 <dcoutts_> MarcWeber: rawSystemProgramStdoutConf verbosity ghcProgram (withPrograms lbi) ["--print-libdir"]
09:52:27 <dcoutts_> MarcWeber: should work with cabal-1.2 and 1.4
09:53:36 <dcoutts_> MarcWeber: you're probably right about the fmap ( head . lines )
09:55:09 <dcoutts_> MarcWeber: though I'm not sure you should assume that the ghc path used at compile time is the right one to use at runtime
10:06:12 <whe5xj> yeah I wish I had an idea of something I should program that I could actually complete :`
10:08:51 <roconnor> can I browse GHC head online. In particular can I browse the latest standard library sources?
10:10:16 <whe5xj> roconnor: is this it ? http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html some of the things have | source on the right hand side of the page
10:10:17 <lambdabot> http://tinyurl.com/y4wexy
10:10:18 <whe5xj> not all of them though
10:11:21 <roconnor> whe5xj: I want the source from HEAD, not the latested released.
10:11:36 <Saizan> http://darcs.haskell.org/libraries ?
10:11:37 <lambdabot> Title: Index of /libraries
10:12:35 <roconnor> perfect
10:13:24 <seanmce> I'm learning monads and I'm trying to add a condition.  Where appendPlaying is now, I want to call appendNotPlaying if condstate retuns Stopped   http://hpaste.org/7441#a0
10:15:00 <whe5xj> http://darcs.haskell.org/haskell-prime/HaskellPrime/Exception.hs yuck :/
10:15:10 <bd_> @source GHC.IOBase
10:15:10 <lambdabot> GHC.IOBase not available
10:15:13 <bd_> hmm
10:15:18 <bd_> @source Control.Concurrent
10:15:19 <lambdabot> http://darcs.haskell.org/packages/base/Control/Concurrent.hs
10:16:17 <roconnor> @type foldMap
10:16:20 <lambdabot> Not in scope: `foldMap'
10:16:24 <roconnor> @hoogle foldMap
10:16:25 <lambdabot> Data.Foldable.foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
10:16:25 <lambdabot> Data.Traversable.foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
10:16:35 <Saizan> seanmce: what's the problem? you've to run condState first and use a case, like you're doing with appendPlaying
10:16:57 <roconnor> > mempty :: ([()],[()])
10:17:00 <lambdabot>  ([],[])
10:18:07 <seanmce> Saizan, I'll try and be right back
10:19:44 <Arnar_> :t (.)
10:19:46 <Arnar_> :t ($)
10:19:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:19:48 <lambdabot> forall a b. (a -> b) -> a -> b
10:20:12 <whe5xj> > (*2) . 1
10:20:13 <lambdabot>   add an instance declaration for (Num (f a))
10:20:26 <Arnar_> that's weird
10:20:31 <Arnar_> ?src (.)
10:20:31 <lambdabot> (f . g) x = f (g x)
10:20:42 <whe5xj> the src is sadly out of sync
10:20:44 <whe5xj> it shuold read
10:20:46 <whe5xj> (.) = fmap
10:20:48 <Saizan> :t Prelude.(.)
10:20:50 <lambdabot> Not in scope: data constructor `Prelude'
10:20:56 <Arnar_> ?unlet (.)
10:20:57 <lambdabot>  Parse error
10:21:00 <byorgey> Arnar_: that's Cale's specially redefined (.)
10:21:05 <Arnar_> byorgey: oh, ok..
10:21:06 <Saizan> :t (Prelude..)
10:21:06 <seanmce> Couldn't match expected type `Response State'  against inferred type `State'
10:21:08 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:21:11 <Arnar_> byorgey: what's the reason for it?
10:21:14 <whe5xj> Cale should update the src :/
10:21:19 <whe5xj> so it says fmap
10:21:23 <Cale> Really?
10:21:28 <whe5xj> I think it's a good idea
10:21:32 <Cale> Actually, I know what I'll do :)
10:21:39 <Cale> @src can report both versions :)
10:21:39 <lambdabot> Source not found. I feel much better now.
10:21:46 <byorgey> Arnar_: it's more general.
10:21:48 <idnar> heh
10:21:48 <whe5xj> oh cool
10:21:50 <Saizan> seanmce: annotate your paste with the new code
10:22:00 <byorgey> Arnar_: fmap for the ((->) e) functor is already (.)
10:22:06 <Cale> The @src command just reads the definitions from a text file
10:22:28 <Arnar_> byorgey: ah, ic
10:22:30 <byorgey> Arnar_: so the idea is that we might as well have (.) mean fmap, instead of only function composition.
10:22:40 <Arnar_> makes sense
10:22:56 <Arnar_> is ((->) e) really a valid type?
10:23:01 <whe5xj> Arnar:
10:23:02 <tromp> i think allowing (.) as a synonym of fmap is bad in the short term, until programmers get used to its more general use
10:23:04 <Cale> It's a type constructor
10:23:07 <whe5xj> > [1,2,3] :: [Int]
10:23:09 <lambdabot>  [1,2,3]
10:23:12 <whe5xj> > [1,2,3] :: [] Int
10:23:13 <lambdabot>  [1,2,3]
10:23:28 <whe5xj> :t (7,'x') :: (,) Int Char
10:23:29 <Cale> ((->) e) a = e -> a
10:23:30 <seanmce> done
10:23:30 <lambdabot> (Int, Char)
10:23:48 <Arnar_> Cale: neat
10:24:02 <Cale> :t fmap
10:24:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:24:07 <whe5xj> tromp: so get used to it :P
10:24:14 <Cale> So when f = (->) e, we have
10:24:22 <Cale> (a -> b) -> (e -> a) -> (e -> b)
10:24:29 <Cale> which is exactly the usual type of composition
10:24:54 <Arnar_> Cale: I like it :)
10:25:16 * whe5xj wishes <- was Haskell
10:25:23 <whe5xj> you can define :<- but it's ugly..
10:26:18 <Arnar_> I guess one can then view (->) as an operator on types.. right?
10:26:21 <Arnar_> are there others?
10:26:28 <tromp> why cant you define <- ?
10:26:31 <whe5xj> Arnar: I just gave a bunch of examples
10:26:41 <Cale> Arnar_: well, yeah, lots, but not many infix ones :)
10:26:42 <Arnar_> whe5xj: oh right.. []
10:26:44 <whe5xj> tromp: infix type constructors have to start with : (other than predefined)
10:26:58 <Cale> Arnar_: also, Either, Tree, Set, Map, Sequence
10:26:59 <Arnar_> Cale: yeah, guess that's what I meant
10:27:12 <tromp> i know, but you can still use it for ordinary functions
10:27:27 <tromp> let x <- y = (x,y) in 1 <- 2
10:27:32 <Arnar_> so can I define my own infix type ctors?
10:27:35 <tromp> > let x <- y = (x,y) in 1 <- 2
10:27:36 <lambdabot>  Parse error at "<-" (column 7)
10:27:39 <Saizan> seanmce: http://hpaste.org/7441#a2
10:27:45 <Cale> Arnar_: yep, but they must start with a colon
10:27:52 <tromp> hmm, nope:(
10:28:11 <Cale> (just a syntactic thing -- colon is treated as an "uppercase" symbol character)
10:28:14 <whe5xj> > do x <- [1,2,3] ; return x
10:28:15 <lambdabot>  [1,2,3]
10:28:25 <Arnar_> Cale: ok.. so just  newtype (:<-) a b = b -> a ?
10:28:48 <Cale> You'll need a data constructor to go along with it in that case
10:28:49 <Arnar_> looks like a weird smily-face :)
10:28:54 <whe5xj> Arnar: I'd rather write type b :<- a = a -> b but still it's ugly
10:29:00 <whe5xj> since there's that : there..
10:29:03 <xerox> > let (-<) = (.) in (succ -< (*2)) 10
10:29:05 <lambdabot>  21
10:29:13 <tromp> > let (<-) = (+) in (<-)
10:29:13 <lambdabot>  Parse error at "<-)" (column 6)
10:29:40 <idnar> <- is part of do syntax, so you can't use it
10:29:57 <tromp> ic
10:30:09 <whe5xj> idnar: haskell value and haskell type are different languages though
10:30:17 <idnar> whe5xj: what?
10:30:20 <whe5xj> idnar: I don't see that as any reason why you'd not be able to use <- in the type system
10:30:32 <idnar> whe5xj: tromp was talking about defining an ordinary function
10:30:47 <idnar> unless I missed something
10:30:50 <whe5xj> oh right, I was talking about foo :: a <- b
10:30:52 <seanmce> Saizan: still same error Couldn't match expected type `Response State'  against inferred type `State'
10:31:12 <Arnar_> I'm thinking I should read the haskell98 report.. are there better places to find an overview of low-level language details like these?
10:32:34 <Saizan> seanmce: oh, what's the type of withMPD? i guess it wraps the result in that Response type, in that case you've to unpack that too before you can look at the state
10:32:39 <Cale> That would probably be the best place to start...
10:32:55 <Cale> Also, there have been various extensions documented in the GHC user's guide.
10:33:06 <Arnar_> ok, thanks Cale++
10:33:33 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#infix-tycons
10:33:34 <lambdabot> Title: 8.4. Extensions to data types and type synonyms, http://tinyurl.com/2cmgjm
10:33:41 <Cale> In fact, infix tycons are one of them :)
10:33:41 <seanmce> withMPD :: MPD a -> IO (Response a)
10:33:59 <Arnar_> oh, so they're not standard haskell then :)
10:34:34 <whe5xj> :o
10:34:37 <LordBrain> 98 is still current standard?
10:34:37 <whe5xj> I thought it was std haskell
10:35:06 <seanmce> I though <- unpacked it?
10:35:13 <Cale> LordBrain: yes, sort of
10:35:40 <Arnar_> I like   type a :+: b = Either a b
10:36:06 <whe5xj> yes me too and a :*: b = Product a b
10:36:07 <Cale> LordBrain: There's work on another one, but GHC is sort of the de-facto standard.
10:37:00 <roderyk> how different is runhaskell from compiling into ghc and running the executable? I get a segmentation fault (core dumped) with the latter, but the former works fine; I think it chokes at some point waiting for user input, but I'm still not sure about that... are there known issues with ghc and System.Console.Readline or something?
10:37:19 <LordBrain> well that's a self fullfilling prophesy tho, if we code to ghc, it is the standard...
10:37:45 <bd_> roderyk: runhaskell has worse runtime performance, but (modulo unsafe use of unsafe*) it certainly shouldn't have a functional difference
10:37:53 <LordBrain> if we consider it the de-facto standard, we code to it...
10:38:00 <bd_> roderyk: try removing the .hi and .o files, and rebuilding from scratch
10:38:10 <Arnar_> guess you could regard ghc as the reference implementation of a standard.. except the standard hasn't been written down :)
10:39:51 <roderyk> bd_: no change :(  - I'm using cabal's default setup to ghc build, if that helps
10:40:54 <bd_> roderyk: hmm... are all the dependent libraries compiled with the same version of GHC?
10:41:02 <roderyk> removing -O option for ghc in cabal also doesn't seem to help
10:41:17 <seanmce> Saizan: I think I got it now
10:41:19 <roderyk> bd_: as far as I can tell/remember, yes
10:41:38 <bd_> weird :/
10:41:43 <roderyk> yea :/
10:41:54 <bd_> I'm going to have to pass to a GHC guru at this point >_>;
10:42:21 <roderyk> I have a core dump, but wouldn't even know where to begin with it :P
10:43:56 <seanmce> Saizan: It works now, thank you. http://hpaste.org/7441#a3
10:45:59 <whe5xj> :t fmap (fmap ?x)
10:46:01 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f, ?x::a -> b) => f1 (f a) -> f1 (f b)
10:47:02 <edwardk> > fst $ (gunfold (\(i,_) -> (i+1,undefined)) (\r -> (0,r)) (toConstr "Hello") :: (Int,String))
10:47:03 <lambdabot>  2
10:47:22 <Arnar_> :t lift
10:47:23 <Saizan> seanmce: oh, makes sense :)
10:47:24 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
10:47:49 <whe5xj> @instances MonadTrans
10:47:50 <lambdabot> ContT r, ErrorT e, RWST r w s, ReaderT r, StateT s, WriterT w
10:47:56 <edwardk> (reader comonad)++
10:49:21 <Saizan> ?karma comonad)
10:49:21 <lambdabot> comonad) has a karma of 1
10:49:25 <idnar> heh
10:49:26 <edwardk> heh
10:49:32 <edwardk> guess ()'s dont work
10:49:39 <edwardk> comonad++
10:49:42 <edwardk> there =)
10:49:51 <idnar> what does the reader comonad do?
10:49:55 <Arnar_> map (++) [reader, comonad]
10:50:10 <olsner> comagic?
10:50:35 <edwardk> basically you carry around an extra term with the value contained in the comonad. ((,)e) is the anonymous reader comonad, like ((->)e) is the anonymous reader monad
10:51:16 <edwardk> i abused it up there to figure out the arity of a constructor which seems to be strangely missing from data.generics
10:52:04 <edwardk> > fst $ (gunfold (\(i,_) -> (i+1,undefined)) (\r -> (0,r)) (toConstr "") :: (Int,String))
10:52:05 <lambdabot>  0
10:52:37 <Saizan> :t gunfold
10:52:39 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall b r. (Data b) => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a
10:53:02 <edwardk> i needed to hand it a c, so i handed it ((,)Int) as c
10:53:12 <ddarius> Indeed, Monad.Reader r a ~ Comonad.Reader r a
10:56:57 <Arnar_> I'm reading about monad transformers.. haven't had this much fun for ages. Should I seek phsyciatric help?
10:56:59 <LordBrain> Cale, why bother generalizing (.) anyway?  Just because you can?
10:57:00 <Arnar_> :)
10:57:49 <sfultong> how do I make a function byteToChar :: (Integral a) => a -> Char = chr . fromIntegral?
10:58:17 <Cale> LordBrain: Well, it's nice.
10:58:28 <LordBrain> because it's easy to type?
10:58:35 <Cale> LordBrain: yeah
10:58:39 <LordBrain> lol
10:58:48 <Cale> and there are nice things about it syntactically
10:58:52 <edwardk> arnar: nope. monad transformers were when haskell won me over =)
10:58:56 <Cale> Functors are required to satisfy this law:
10:58:56 <LordBrain> well, show me something nice
10:59:02 <Cale> fmap (f . g) = fmap f . fmap g
10:59:08 <Cale> Or:
10:59:13 <Cale> fmap (f . g) x = fmap f (fmap g x)
10:59:23 <Cale> If we replace fmap with (.), that becomes:
10:59:31 <Cale> (f . g) . x = f . (g . x)
10:59:41 <edwardk> cale: i admit i've actually been won over to the control.category view of (.) as working over other categories rather than the fmap version which seems less fundamental
10:59:42 <Cale> So it's an associative law of sorts :)
10:59:59 <Cale> edwardk: I'd rather use <<< for Control.Category
11:00:23 <Arnar_> edwardk: oh, I fell much more easily for let fib = 1 : 1 : zipWith (+) fib (tail fib)
11:00:44 <edwardk> <<< jumps out at you way too much for me for non-trivial examples though
11:00:48 <edwardk> . is nicely understated
11:01:32 <Cale> edwardk: But there aren't so many uses of Control.Category
11:01:34 <edwardk> and arrows/categories pay a pretty high cost with all the constructor noise generally anyways
11:01:48 <Cale> (at least not yet)
11:02:02 <edwardk> cale: http://comonad.com/haskell/categories/dist/doc/html/categories/ seems like a few uses ;)
11:02:39 <whe5xj> :t (<<<)
11:02:41 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> a b c -> a b d
11:02:44 <visof> where can i get  rss feeds for haskell ?
11:03:05 <whe5xj> :t (<<<)<<<(<<<)
11:03:07 <lambdabot> forall b (a :: * -> * -> *) c d b1. (Arrow a) => a c d -> (b -> a b1 c) -> b -> a b1 d
11:03:32 <Arnar_> visof:
11:03:32 <Cale> edwardk: Well, you can bring in lots of abstractions sure. But do you actually know how to use all those to structure programs and libraries? :)
11:03:35 <Arnar_> ?google planet haskell
11:03:36 <lambdabot> http://planet.haskell.org/
11:03:36 <lambdabot> Title: Planet Haskell
11:03:40 <edwardk> i need to port some more of that over into category-extras when i get a chance and i figure out the cabal config issues with control.category being in 6.9 and not prior
11:04:16 <LordBr4in> what's the Control.Category view of (.) ?
11:04:21 <edwardk> cale: mostly i wanted them so i could build a version of biarrows that weren't broken
11:04:52 <edwardk> lordbrian: class Category k where (.) :: k b c -> k a b -> k a c; id :: k a a
11:05:05 <bd_> http://wellquite.org/sessions/tutorial_1.html /me mutters about huge unmovable banners using up my already limited (16:9) vertical space
11:05:06 <lambdabot> Title: Well Quite
11:05:17 <whe5xj> is there anything that Category . doesn't do that Functor . does?
11:05:35 * Botje_ introduces bd_ to the wonders of the "nuke everything" extension for firefox
11:06:12 <edwardk> cale: also using that a lot of 'near-but-not-quite' arrows can be expressed, like the cgi-arrows or pipe-arrows, so there are a lot of useful constructions in that space waiting to be employed.
11:06:43 <whe5xj> :t coassociate
11:06:45 <lambdabot> Not in scope: `coassociate'
11:06:53 <edwardk> whe5xj: you can use it for arbitrary arrows composition
11:07:31 <edwardk> class Bifunctor s k k k =>  Coassociative s k where coassociate :: k (s a (s b c)) (s  (s a b) c) -- in my categories library
11:07:54 <Cale> edwardk: Except that I'm not convinced at all that these things are likely to see more common use than *functors*
11:07:58 <bd_> Botje_: webdeveloper+strategic 'display: none' CSS works nicely :)
11:08:15 <bd_> at least, until I go to the next page
11:08:17 <bd_> *shakes fist*
11:08:50 <Botje_> bd_: you could abuse adblock too, of course
11:09:18 <edwardk> cale: a reasonable argument, but i'm not as comfortable with the (.) as fmap implementation as I once was since I started having code that it blew up type inference for on me =)
11:10:25 <Cale> Oh? Can you give examples?
11:10:36 <bd_> Botje_: It's not a frame or image or anything, it's just a huge position:fixed div
11:10:46 <bd_> If I was planning to visit frequently I'd apply greasemonkey I guess
11:10:48 <Botje_> yeah, i noticed now
11:10:51 <whe5xj> @src (++)
11:10:51 <lambdabot> []     ++ ys = ys
11:10:51 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:10:51 <lambdabot> -- OR
11:10:51 <lambdabot> xs ++ ys = foldr (:) ys xs
11:10:57 <whe5xj> ^ grrr
11:11:02 <edwardk> cale: i'll see if i can dig some up. it hit me pretty hard a couple of months ago though.
11:11:03 <Cale> The only case I can imagine it blowing up type inference on is when the functor involved in the last element of the composition chain is ambiguous.
11:12:57 <quicksilver> edwardk: generally I would be very interested to see discussion on "Real-World" uses of the stuff in category-extras
11:13:14 <edwardk> quicksilver: likewise =)
11:13:27 <quicksilver> for some value of "real-world"
11:13:37 <quicksilver> perhaps I mean "software engineering" applications
11:13:39 <quicksilver> I'm not sure.
11:13:47 <edwardk> quicksilver: delimited continuations, indexed state have had some practical uses. indexed state came up a few times in the development of darcs iirc
11:13:59 <edwardk> and oleg is all about delimited continuations
11:14:31 <edwardk> the hylo- etc stuff has mostly been programming esoterica i'll admit. the g-hylo stuff there is there to help cover its missing cases
11:15:11 <edwardk> i do want to start putting together a cofib suite of examples of practical comonads though
11:15:12 <Cale> I'm not all that convinced of the general practicality of delimited continuations yet. I'd be interested in seeing some really decent applications.
11:16:05 <edwardk> oleg's generic zipper uses delimited continuations quite heavily
11:16:07 <whe5xj> what about that type safe printf?
11:16:42 <quicksilver> I'm not sure oleg's generic zipper is what I meant by 'real-world'
11:16:45 <whe5xj> that uses delmited continuations
11:16:49 <edwardk> mostly with category-extras i wanted to start gathering up the brain-bending stuff and put it in one place
11:16:53 <quicksilver> although I may have to extend my definition of real-world.
11:16:57 <edwardk> where it can all continue to be safely ignored =)
11:16:59 <quicksilver> edwardk: and I salute that goal, by the way.
11:17:12 <quicksilver> edwardk: what did you mean by indexed state?
11:17:51 <edwardk> http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Monad-Indexed-State.html is a state monad where you can change the type of the state carried around in it while you work with it
11:17:51 <lambdabot> http://tinyurl.com/5qrkao
11:18:04 <quicksilver> ah, yes.
11:18:13 <edwardk> er i need to write get and set for that actually =)
11:18:26 <quicksilver> yes, I've thought about that occasionally.
11:18:38 <quicksilver> isn't it more naturally an arrow than a monad?
11:18:44 <edwardk> its what iavor diatchki called a type-indexed monad
11:19:07 <quicksilver> hmm, no it's not an arrow.
11:19:10 <quicksilver> it has a return type.
11:19:25 <edwardk> not quite coz you have the parameter carried around in its type. arrows tend to be abused for that by using their built-in support for pairs, but its not intrinsic to arrows
11:19:30 <quicksilver> it just has a slightly more general bind which feels like a mixture of monadic bind and arrow composition
11:20:30 <edwardk> the heavy use of 'second' and 'first' to manipulate carried state in arrow code is sort of their way of doing this
11:21:45 <Saizan> edwardk: btw, the shift in the paper is shift :: ((forall i. a -> m i i o) -> m r j j) -> m r o a
11:24:10 <edwardk> ah dan omitted the forall
11:24:31 <edwardk> i'll fix it up
11:24:38 <Saizan> probably because oleg did that too to remain haskell98
11:25:05 <edwardk> bah we have tons of rank-2 polymorphism floating around in here anyways
11:25:39 <Arnar_> :t map
11:25:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:25:55 <Arnar_> :t fold
11:25:57 <lambdabot> Not in scope: `fold'
11:25:58 <Arnar_> :t foldl
11:26:00 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:26:44 <Arnar_> so I guess Cale defined map from Data.Traversable like what we were discussing about (.)?
11:26:49 <Saizan> actually i suspect shift :: ((a -> o) -> m r j j) -> m r o a, would work equally well
11:27:01 <Arnar_> then why not folds from Data.Foldable?
11:27:35 <Cale> I suppose that would be doable :)
11:27:42 <edwardk> saizan: but then you couldn't use the wrapped monad if you used the indexed continuation monad transformer
11:28:06 <Cale> Arnar_: map is fmap too :)
11:28:26 <Saizan> edwardk: ah, right :)
11:28:41 <Arnar_> Cale: ah ok..
11:28:43 <Arnar_> :t sequence
11:28:45 <Arnar_> :t mapM
11:28:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:28:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
11:28:57 <Cale> :t Data.Foldable.sequence
11:28:59 <lambdabot> Not in scope: `Data.Foldable.sequence'
11:29:01 <Cale> hmm
11:29:02 <Saizan> :t Data.Foldable.fold
11:29:05 <lambdabot> forall (t :: * -> *) m. (Monoid m, Data.Foldable.Foldable t) => t m -> m
11:29:10 <Arnar_> :t Data.Traversable.sequence
11:29:11 <Cale> :t Data.Traversable.sequence
11:29:12 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
11:29:13 <Cale> right
11:29:14 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
11:30:27 <whe5xj> @instances Foldable
11:30:27 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
11:30:35 <whe5xj> @instances Data.Foldable
11:30:35 <lambdabot> Couldn't find class `Data.Foldable'. Try @instances-importing
11:30:42 <whe5xj> @instances-importing Data.Foldable Foldable
11:30:43 <lambdabot> Maybe, []
11:30:49 <Cale> heh
11:30:59 <Saizan> edwardk: have you tried wrapping an indexed monad with an indexed monad transformer?:)
11:31:07 <Arnar_> no wonder I was feeling anxious.. didn't notice that I had the film score of Phsyco in my headphones o_O
11:31:12 <whe5xj> > Data.Foldable.fold [Just 1,Just 2,Just 3]
11:31:13 <lambdabot>  Add a type signature
11:31:22 <edwardk> saizan: you can't you have to hold one index or the other constant
11:31:22 <whe5xj> how do you actually use fold ?
11:31:47 <edwardk> saizan: thats why i have the LiftIx and LowerIx operations to move in and out of indexing
11:32:07 <whe5xj> > Data.Foldable.fold [Just 1,Just 2,Just 3] :: Maybe Int
11:32:08 <lambdabot>   add an instance declaration for (Monoid Int)
11:32:08 <lambdabot>     In the expression:
11:32:08 <lambdabot>        ...
11:32:35 <whe5xj> > Data.Foldable.fold [[1],[2],[3]] :: [Int]
11:32:36 <lambdabot>  [1,2,3]
11:32:44 <Arnar_> > Data.Foldable.fold [[1,2,3],[1,2,3]]
11:32:45 <lambdabot>  [1,2,3,1,2,3]
11:32:46 <whe5xj> how is that a fold :/
11:33:00 <Saizan> it looks more like a generalized mconcat
11:33:11 <edwardk> saizan: thats why i'm not a fan of type-indexed monads, they don't compose =/
11:33:15 <whe5xj> > Data.Foldable.fold [Just 1,Just 2,Just 3] :: [Int]
11:33:16 <lambdabot>  Couldn't match expected type `[Int]'
11:33:29 <Cale> whe5xj: fold folds the structure with the monoid operation
11:33:37 <Cale> The monoid operation for lists is concatenation
11:33:47 <Arnar_> ?check concat x :: [a] == Data.Foldable.fold x
11:33:47 <lambdabot>  Parse error at "==" (column 17)
11:33:47 <Saizan> edwardk: can't we use something like a pair of indexes?
11:33:49 <edwardk> saizan: the higher order ones can, and parameterized ones are usually just a stepping point to get the monad of their fixpoint, but type-indexed kinda doesn't do much
11:33:57 <Cale> > fold [Product 2, Product 5, Product 3]
11:33:58 <lambdabot>   Not in scope: `fold'
11:34:04 <Cale> > Data.Foldable.fold [Product 2, Product 5, Product 3]
11:34:05 <lambdabot>  Product {getProduct = 30}
11:34:16 <quicksilver> cale beat me to it by about 1 second :)
11:34:22 <edwardk> saizan: i tried to make a combinator that was indexed on the pair of the indices of the children, but i wasn't able to work out the type family
11:34:22 <quicksilver> I was testing in /msg first.
11:34:38 <edwardk> i'll take another crack at it
11:34:40 <whe5xj> > (Data.Foldable.fold [Endo (+1),Endo (*2),Endo (+3)])  7
11:34:41 <lambdabot>  Couldn't match expected type `t1 -> t'
11:34:59 <edwardk> but the problem is it plays havoc with the types for things like shift and reset
11:35:18 <quicksilver> whe5xj: you need to runEndo it
11:35:20 <edwardk> er another problem that is
11:35:23 <quicksilver> or unEndo, whatever it's called.
11:35:40 <whe5xj> > (unEndo . Data.Foldable.fold $ [Endo (+1),Endo (*2),Endo (+3)])  7
11:35:41 <lambdabot>   Not in scope: `unEndo'
11:35:54 <whe5xj> @hoogle Endo -> _
11:35:55 <lambdabot> Data.Monoid.appEndo :: Endo a -> a -> a
11:36:00 <whe5xj> > (appEndo . Data.Foldable.fold $ [Endo (+1),Endo (*2),Endo (+3)])  7
11:36:02 <lambdabot>  21
11:36:18 <quicksilver> concise, isn't it?
11:36:19 <edwardk> i love how there are 4 competing conventions for something like that if you have a constructor An you have people who use: unAn, runAn, an, iAn, ian, ...
11:36:21 <quicksilver> almost like Java.
11:36:24 <whe5xj> haha
11:36:30 <whe5xj> I don't get this
11:36:38 <whe5xj> does anybody use Foldable?
11:36:49 <quicksilver> edwardk: ian? as in data Igloo = { ian :: Lynagh } ?
11:36:55 <quicksilver> whe5xj: yes, sure.
11:37:01 <edwardk> quicksilver: =)
11:37:07 <whe5xj> why?
11:37:12 <edwardk> brb
11:37:18 <quicksilver> because they're working with Sequence, perhaps?
11:37:23 <quicksilver> or any other non-List Foldable.
11:38:04 <lilac> > Data.Foldable.fold [Just [1], Just [2]]
11:38:06 <lambdabot>  Just [1,2]
11:38:22 <whe5xj> > catmaybes [Just [1], Just [2]]
11:38:23 <lambdabot>   Not in scope: `catmaybes'
11:38:26 <whe5xj> > catMaybes [Just [1], Just [2]]
11:38:27 <lambdabot>  [[1],[2]]
11:39:40 <whe5xj> yeah I am confused by this
11:39:44 <quicksilver> I started using Foldables when I started using Sequence
11:39:52 <quicksilver> and Traversables shortly after.
11:40:12 <quicksilver> because they are the answer to all sorts of questions like "why doesn't Sequence have a function which does X"
11:43:14 <lilac> > Data.Foldable.fold [First (Just 1), First (Just 2)]
11:43:15 <lambdabot>  First {getFirst = Just 1}
11:43:40 <lilac> Maybe a isn't a Monoid
11:44:03 <Arnar_> what's the idea behind the First and Last monoids?
11:44:31 <lilac> First monoid produces the first non-Nothing value in some Maybe's
11:44:53 <dons> ?users
11:44:53 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
11:44:55 <dons> Cale^
11:45:19 <Cale> oy, not again
11:45:29 <lilac> > mconcat (map First [Nothing, Just 1, Just 2])
11:45:31 <lambdabot>  First {getFirst = Just 1}
11:45:36 <lilac> > mconcat (map Last [Nothing, Just 1, Just 2])
11:45:38 <lambdabot>  Last {getLast = Just 2}
11:45:46 <Arnar_> lilac: ok.. nice
11:45:51 <Cale> dons: Do you have any idea what's wrong with that plugin?
11:46:21 <whe5xj> @instances Monoid
11:46:22 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:46:45 <whe5xj> they all have one constructor? (except [])
11:46:47 <Cale> dons: Also, I'm seeing a lot of messages on lambdabot's console which look like "Main: caught (and ignoring) too few bytes. Failed reading at byte position 8"
11:48:00 <dons> http://reddit.com/info/6idro/comments/ mmm
11:48:00 <edwardk> cale: those are from:
11:48:02 <edwardk> @seen dolio
11:48:07 <dons> Cale, so corrupted Seen state
11:48:09 <lambdabot> dolio is in #haskell-blah and #haskell. I don't know when dolio last spoke.
11:48:12 <edwardk> hrmm
11:48:13 <edwardk> fixed now
11:48:25 <edwardk> earlier it was blowing up with too few bytes when calling @seen
11:48:31 <Cale> Actually, I get a bunch of those on startup as well.
11:49:05 <whe5xj> beh @ "is better than"
11:49:23 <roderyk> http://pithyless.com/code/hlean-0.1.1.tar.gz   In case someone is curious, this is the cabal package I'm trying to get going. runhaskell version works fine, while the ghc'ed version seg faults during runtime. If someone is curious, I can also upload a core dump.
11:51:17 <dcoutts_> roderyk: so what segfaults exactly? the program you get when you build hlean or the Setup.hs or what?
11:51:17 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
11:52:10 <roderyk> dcoutts_: the program when it runs; and only after a certain point (if it finds duplicate files, it will try to interact with the user)
11:53:31 <dcoutts_> roderyk: ok, build, so how do I get it to segfault?
11:53:35 <dcoutts_> build/built
11:53:43 <roderyk> cat 1 > foo1
11:53:47 <roderyk> cat 1 > foo2
11:53:51 <roderyk> ./dist/.../hlean .
11:54:21 * dcoutts_ assumes roderyk means echo rather than cat
11:54:31 <roderyk> yea : )
11:54:58 <dcoutts_> $ dist/build/hlean/hlean .
11:54:58 <dcoutts_> hlean: Prelude.last: empty list
11:55:09 <thetallguy> ?seen igloo
11:55:10 <lambdabot> igloo is in #haskell-soc, #darcs, #ghc and #haskell. I don't know when igloo last spoke.
11:57:04 <roderyk> dcoutts_: on mine it segfaults, but I guess that is understandable? I wonder where it's taking a head of an empty list...
11:57:19 <roderyk> s/head/last/
11:57:25 <dcoutts_> roderyk: haskell exceptions do not cause segfaults :-)
11:57:53 <Igloo> thetallguy: Yup?
11:58:09 <dcoutts_> roderyk: segfaults are almost always caused by problems with unclean rebuilds or dodgy FFI libs
11:58:26 <roderyk> dcoutts_: oh, I know the problem. I've hardcoded the hash function to sha256. if you're not running FreeBSD, you probably need to tweak hashCommand and hashCommandParse
11:58:34 <gwern> 'What you’ve described, “The bottleneck in writing code isn’t in the writing of the code, it’s in understanding and conceptualising what needs to be done,” is common to all highly abstract programming languages. Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.'
11:59:16 <dcoutts_> roderyk: right...
11:59:28 <roderyk> dcoutts_: for linux, you can probably change said functions to "md5sum" and "first" instead of last
11:59:41 <gwern> I think what makes that comment real win is 'emission of a fold expression'; the rhyme, the word emission... it all just comes together beautifully
12:00:53 <dcoutts_> roderyk: ok, got it to segfault :-)
12:01:11 <roderyk> dcoutts_: well, not sure if that's good or bad. :-)
12:01:30 <roderyk> and it should be fine if you run "runhaskell ./hlean.hs ."
12:02:00 <dcoutts_> roderyk: I cannot test that I'm afraid, my sparc ghc is not built with ghci support
12:02:53 <roderyk> dcoutts_: still, thanks for the help. What's the chance we both have similarly badly built/linked libs? :-)
12:03:03 <dcoutts_> roderyk: seems unlikely
12:04:10 <Toxaris> gwern: while this may sound good, I don't think it's true. My Haskell writing normally consists of meditation and emission of a typeclass instance for my home-made datatype. Haskell is not only about LIst Processing.
12:04:52 <thetallguy> igloo: we noticed you've been adding equals on the build deps
12:05:05 <thetallguy> igloo: what's the reasoning?
12:06:04 <thetallguy> igloo: Oh, I see David has already talked to you about it.
12:08:18 <dcoutts_> roderyk: I bet I know...
12:08:36 <thetallguy> igloo: I think Debian's autobuilder is busted ;-)
12:09:05 <Igloo> thetallguy: How do you mean?
12:09:14 * dcoutts_ curses the readline binding for being made of fail
12:09:23 <dcoutts_> or rather for being made of segfault in this case
12:09:59 <thetallguy> igloo: http://urchin.earth.li/pipermail/debian-haskell/2008-March/000386.html  Your explanation here of how X and Y get out of sync shouldn't happen, I think.
12:10:00 <dcoutts_> roderyk: the reason it works in ghci/runghc/runhaskell is that ghci has already initialised readline
12:10:01 <lambdabot> Title: [Debian-haskell] Build dependencies too tight?, http://tinyurl.com/55j2rm
12:10:22 <thetallguy> igloo: seems like an unnecessary race condition.
12:10:23 <skorpan> i believe there was some short piece of code which returns the 10001st prime number. does anyone know? something about (>1).gcd
12:10:46 <whe5xj> > (!! 10001) (nubBy(((>1).).gcd)[2..])
12:10:56 <lambdabot>  Exception: Time limit exceeded
12:11:08 <dcoutts_> roderyk: and because readline is made of segfault, it requires that you initialise it before using it first, otherwise it segfaults for you, and because the readline binding is also made of segfault, it does not hide this stupidity
12:11:20 <Igloo> thetallguy: Well, that's what we've got to work with  :-)
12:11:41 <skorpan> @src nubBy
12:11:42 <lambdabot> nubBy eq []             =  []
12:11:42 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
12:11:49 <roderyk> dcoutts_: what exactly do you mean by initialise readline?
12:12:00 <roderyk> oh, its in the API....
12:12:06 <dcoutts_> roderyk: yep
12:12:08 <whe5xj> > nubBy(((>1).).gcd)[2..]
12:12:10 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:12:13 <thetallguy> igloo: Yeah, I figured.  Your solution seems locally reasonable
12:12:16 <skorpan> cool
12:12:18 <dcoutts_> roderyk: and helpfully completely undocumented
12:12:28 <olsner> "locally" reasonable? :P
12:12:40 <roderyk> dcoutts_: initialize :: IO ()    -> self-documenting code :P
12:12:47 <thetallguy> igloo: but globally, it adds yet another argument for a purely functional model like nixos
12:13:42 <Igloo> thetallguy: Well, NixOS is a source-distro, right? So doesn't have this sort of desync problem
12:14:03 <thetallguy> igloo: :-)
12:14:04 <gwern> Toxaris: I dunno; I sympathize because I do a lot of scripting, which often is all about list processing and folds and unfolds
12:15:45 <saml> i can't debug this
12:16:20 <thetallguy> olsner: yes, locally.  The right answer would be to fix the Debian autobuilder, but that's too big a problem.
12:16:30 <olsner> ah, I see
12:16:38 <thetallguy> igloo: NixOS::  [Source] -> OS
12:17:04 <thetallguy> igloo: I've concluded that's the only correct way to build a distribution
12:17:34 <thetallguy> igloo: you can do binary distribution with that with a good caching scheme.  I'm not sure if NixOS does yet.
12:17:55 <cjb> thetallguy: how is Fedora any different?  It builds binary packages from source, and ships them.
12:17:59 <saml> http://hpaste.org/7443
12:18:13 <gwern> thetallguy: nix does 'channels'
12:18:23 <gwern> you can subscribe to a binary-providing 'channel'
12:18:26 <thetallguy> cjb: Does it link them all together?
12:18:39 <gwern> as opposed to say, a recipe-providing channel
12:18:43 <cjb> thetallguy: not sure what that means.
12:18:46 <whe5xj> saml: what monad is this in?
12:18:54 <gwern> (in which case you subscribe to the channel, download the scripts and compile locally)
12:19:08 <saml> whe5xj, in my monad, TI. it's a custom State monad
12:19:17 <thetallguy> cjb: in NixOS, filenames are prefixed with md5sums, computed from the build dependencies
12:19:47 <thetallguy> cjb: If you didn't link against a file during the build, you can't see it.
12:19:54 <whe5xj> saml: paste it?
12:19:56 <saml> TI monad stores 2 things: Subst :: [(String, Type)]  and Int (to generate unique type variables)
12:20:32 <cjb> Ah.  Neat.  Fedora builds binary packages with a tool called mock, which performs a chroot and only imports dependencies as specified in the package manifest.
12:20:37 <roderyk> dcoutts_: still don't quite follow; tried initializing in my main; and then also tried initializing before every Readline function. It doesn't segfault anymore, but instead when it gets to that same point it just sits there...
12:20:48 <thetallguy> cjb: the idea is that the OS is not tinkerable at all in binary form.  If you want something new, youchange the source package list and rebuild.
12:20:50 <whe5xj> saml: and you have unification on types?
12:20:51 <cjb> So, a different way of attempting to guarantee that binary packages were produced by the particular source packages that were uploaded.
12:21:05 <cjb> thetallguy: ah.  yes, that's more hardcore.
12:21:09 <thetallguy> in part, yes
12:21:15 <saml> whe5xj, yes. http://hpaste.org/7428  this is basic definitions for mgu, TI, ..etc
12:21:45 <edwardk> i'm rather fond of the nixos approach because it ensures that you can run multiple versions of the same package and have systems that depend on different versions on the same machine without any collisions possible
12:22:11 <thetallguy> cjb: and if I understand igloo's bug correctly, it would never happen in NixOS.
12:22:21 <dcoutts_> roderyk: hmm, perhaps some readline mode thing, I'm not especially familiar with it
12:22:33 <thetallguy> edwardk: it also forces you to write down a spec for your entire system
12:23:02 <dcoutts_> roderyk: is it readline or the other function you use that hangs? is it to do with the terminal mode or input buffering?
12:23:14 <thetallguy> edwardk: rather than adding packages willy nilly and then having to remember what you did later
12:23:32 <roderyk> dcoutts_: honestly, I'm not sure :)
12:23:57 <thetallguy> edwardk: since I used to administer a distro, it would have been really nice to be able to ship an untinkerable OS, or know exactly how it was updated.
12:24:17 <thetallguy> simply by doing a diff on the OS config file.
12:24:29 <edwardk> thetallguy: no complaints there. it also plays nice with venti-style file systems, you could use it to replicate whole sub-platforms around
12:24:44 <edwardk> though that would rely on binary distribution
12:25:08 <thetallguy> edwardk: I don't know 'venti-style'.  Link?
12:25:34 <edwardk> thetallguy: http://en.wikipedia.org/wiki/Venti
12:26:28 <edwardk> the basic idea is you 'index' to a block in the filesystem with a hash of its contents. the philosophy is that you can store forever all the content a user generates because its comparatively little then incremental backups melt into the store because anything sharing a hash is merged
12:26:30 <whe5xj> saml: pretty hecktic I think
12:26:40 <edwardk> you store nothing about sharing, so you can't delete from the store
12:27:27 <saml> whe5xj, yah. new to haskell and type inference
12:28:29 <thetallguy> edwardk: cool.  I designed something similar a few years ago but never built it.  Seemed like the git people were headed that way, as well as others.  Glad to see others have seen the benefits.
12:29:27 <thetallguy> edwardk: a lot of problems get solved by having a purely functional file system.
12:30:21 <edwardk> thetallguy: exactly =) the trick comes down to implementation on the venti front there are some tricks about how to manage the hashspace,etc.
12:30:45 <thetallguy> edwardk: have they made it distributed yet?
12:31:13 <edwardk> thetallguy: venti largely died with plan 9 iirc
12:31:40 <thetallguy> edwardk: Oh, I see, the wikipedia article is better than the one I was reading.
12:31:54 <thetallguy> edwardk: the fourth word is 'network' :-)
12:31:58 <edwardk> but the basic idea would work with a skip-graph or chord style distributed hash
12:33:26 <thetallguy> edwardk: yes.  Thanks for the pointer. I'll read up on this.
12:33:50 <edwardk> np. was going to use it for a distributed backup scheme once, never got around to it.
12:35:04 <thetallguy> Now, on a more practical note, does anyone have a cute function that does [1,2,3,4...] -> [(1,2),(3,4), ...] ?
12:35:32 <thetallguy> Easy enough to write, but I didn't find any way to do it with the standard list operations.
12:35:58 <thetallguy> Oh, and you can't filter on the contents, only the indices.
12:36:04 <cpoucet> > map (\[x,y] -> (x,y)) . map (take 2) . iterate (drop 2) $ [1..]
12:36:06 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21,...
12:36:32 <cpoucet> > map (\(x:y:r) -> (x,y)) . iterate (drop 2) $ [1..]
12:36:33 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21,...
12:37:01 <Botje_> sigh
12:37:01 <thetallguy> cpoucet: thanks, that's nice
12:37:11 <Botje_> I feel like i'm doing the world a disservice by writing ugly haskell code
12:37:22 <Botje_> but it's really the only way to go atm :(
12:37:39 <sclv_> why so?
12:37:52 <Botje_> i'm implementing pattern matching in my compiler
12:37:59 <thetallguy> cpoucet: I didn't think of iterate.  That should open up a whole bunch of new methods.
12:38:07 <Botje_> 34 lines of really dense and un-elegant code
12:39:02 <thetallguy> Botje_: Don't worry about it.  It's probably better than what you'd do in another language, and the more compact combinator forms take time to distill in your mind.
12:39:04 <sclv_> ah.. sounds like a month later you'll suddenly see the perfect abstraction?
12:39:20 <bd_> sclv_: Hah, I know that feeling :)
12:39:33 <Botje_> hehe :)
12:39:40 <Botje_> thetallguy: thanks, i'll keep it in mind ;)
12:39:48 <chr1s> anyone familiar with the readline library?
12:39:50 <bd_> Then the next month you find out that said abstraction is horribly inefficient and is consuming 99% of your time/allocation
12:39:51 <Botje_> #haskell++ # always good for a cheerup
12:40:05 <Botje_> thetallguy++ # actual cheerup
12:40:08 <thetallguy> Botje_: If you read the 'applicative functor' paper, you'll  see them say something like: we wrote all this code, then realized we were doing the same thing over and over...
12:40:14 <roconnor> a small puzzle for bored Haskellers: http://hpaste.org/7445
12:40:54 <thetallguy> roconnor: do you have the solution already?
12:41:01 <mauke> hey, that sounds like this compiler thingy I wrote
12:41:19 <mauke> or rather assembler
12:42:04 <roconnor> thetallguy: Not one that is efficent yet.
12:42:43 <roconnor> thetallguy: I know how to make it efficent, but I'm a bit unclear if I can make it efficent and elegant.
12:43:43 <thetallguy> Is it O(mn)?
12:44:43 <bd_> O(mn log(mn)) I'd think, unless you have a good hash function
12:44:47 <thetallguy> roconnor: Been a long time since I've actively done any graph problems.  Maybe I should practice.
12:45:01 <roconnor> I think we ought to be able to do it in O(max edges nodes) plus some logs thrown in.
12:45:14 <roconnor> assume a is an instance of Ord
12:45:22 <Igloo> roconnor: Is it acyclic?
12:45:29 <roconnor> oops
12:45:33 <roconnor> yes it is acylcic
12:45:49 * bd_ deletes a chunk of code
12:45:57 <Igloo> Ah, but we don't have a list of all nodes?
12:47:13 <roconnor> Igloo: Technically I can give you a list of nodes.
12:47:30 <roconnor> but I'm kinda intrested in the solution without such a list.
12:49:10 <sclv_> findpts func a = findpts' (func a) where findpts' a' = let nxt = join (func <$> a') in if nxt == a' then a' else findpts' nxt ? -- not efficient tho
12:50:39 <roconnor> sclv_: that's pretty good.
12:51:03 <sclv_> the fmap and join are really a bind, but i think it looks cleaner the other way.
12:54:41 <roconnor> sclv_: I guess you keep finding the same children over and over again.
12:56:53 <Botje_> WOO!
12:57:08 <Botje_> i just made a function monadic and only got a screenfull of errors
12:57:09 <edwardk> ah nice, i just realized that sackman's sessions are yet another indexed monad
12:57:14 <Botje_> i'm obviously getting better at haskell
12:57:20 <whe5xj> > let p |- q = True in 1 |- 2
12:57:22 <lambdabot>  True
12:58:14 <Botje_> @src liftM
12:58:15 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:59:04 <roconnor> > let (|-) = (<=) in False |- True
12:59:05 <lambdabot>  True
12:59:36 <sclv_> oh hey -- extract join (func <$> a) to a seperate function and shove a memo table in it and the above should be pretty efficient.
13:00:03 <Igloo> Hmm
13:00:06 <Igloo> reachable f xs = let ys = iterate (nub . (xs ++) . concatMap f) xs in fst $ head $ dropWhile (uncurry (/=)) $ zip ys (tail ys)
13:00:30 <Igloo> would be elegant (but not efficient) if there were a nice way to do the "get the value once it stops changing" part
13:00:33 <dejones> hey dons: do you have any examples available for using "xml-1.2.6: A simple XML library"  ??
13:00:57 <dmwit> Igloo: fix... ;-)
13:01:04 <dejones> @seen dons
13:01:04 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 1h 12m 57s ago.
13:01:08 <Igloo> ...which accounts for more than half the code
13:01:13 <dmwit> (Gets the wrong fixpoint, but...)
13:01:41 <sclv_> oh wait.. that's the wrong place for a memo table... not so easy.
13:01:58 <chr1s> hey all =)
13:02:08 <bd_> reachable g n = Set.fromList $ search n  where search n = (return n) `mplus` (g n >>= search)   -- elegant? but not particularly efficient
13:02:24 <chr1s> I'm doing a getChar, which works nicely in GHCi, but when running my program stand-alone it's waiting for a return
13:02:40 <chr1s> my guess is that it has something to do with input buffering
13:02:43 <bd_> make that reachable g = Set.fromList . search :)
13:02:43 <chr1s> any clues?
13:02:48 <sclv_> (and for a list it should be nub . join anyway)
13:03:06 <chr1s> ah, nm
13:06:05 <bd_> @hoogle mconcat
13:06:06 <lambdabot> Data.Monoid.mconcat :: Monoid a => [a] -> a
13:06:17 <bd_> @hoogle MonadPlus m => [a] -> m a
13:06:19 <lambdabot> Prelude.head :: [a] -> a
13:06:19 <lambdabot> Prelude.last :: [a] -> a
13:06:19 <lambdabot> Data.List.head :: [a] -> a
13:07:20 <bd_> reachableL g n = S.fromList $ evalState (runListT $ search n) S.empty  where search n = do { get >>= guard . not . S.member n; (modify (S.insert n) >> return n) `mplus` (foldl' mplus mzero (map return $ g n) >>= search) } -- not so elegant
13:10:46 * Botje_ has just noticed foldM == foldl :'(
13:11:01 <popcorn> :t (a -> Maybe b) -> [a] -> Maybe b
13:11:04 <lambdabot> parse error on input `->'
13:11:06 <popcorn> @hoogle (a -> Maybe b) -> [a] -> Maybe b
13:11:07 <lambdabot> No matches, try a more general search
13:11:22 <popcorn> @hoogle [Maybe a] -> a
13:11:23 <lambdabot> No matches, try a more general search
13:11:31 <popcorn> :t map First
13:11:34 <lambdabot> forall a (f :: * -> *). (Functor f) => f (Maybe a) -> f (First a)
13:11:52 <popcorn> :t Data.Foldable.fold . map First
13:11:54 <lambdabot> forall a (f :: * -> *). (Functor f, Data.Foldable.Foldable f) => f (Maybe a) -> First a
13:12:10 <sanity> [newbie] given that Haskell has type inference, how come a lot of the source code I see declares the types of functions explicitly?
13:12:26 <roconnor> bd_: tell me about it.  It seems there ought to be an efficent and elegant solution, but I just can't seem to figure it out.
13:12:32 <popcorn> :t \f -> Data.Foldable.fold . map First . map f :: [a] -> (a -> Maybe b) -> Maybe b
13:12:35 <lambdabot>     Couldn't match expected type `(a -> Maybe b) -> Maybe b'
13:12:35 <lambdabot>            against inferred type `First a1'
13:12:35 <lambdabot>       Expected type: f (Maybe a1) -> f ((a -> Maybe b) -> Maybe b)
13:12:36 <tromp> to help the read of said code
13:12:37 <Botje_> OMGOMGOMGOMG it compiles!
13:12:43 * Botje_ does the happy dance \o/
13:13:12 <tromp> makes code easier to read if human doesn't have to figure out type
13:13:34 <Vulpyne> sanity: And if you're still learning, it helps you to add the type signatures. So you know that you thought the same thing as the compiler about the types. :)
13:13:34 <Deewiant> and easier to correct while your code has the wrong type ;-)
13:13:50 <popcorn> [] -> Nothing
13:13:56 <popcorn> (x:xs) -> Just x
13:13:59 <popcorn> what's the name of that? function :/
13:14:06 <Deewiant> listToMaybe
13:14:09 <popcorn> ahh thank you
13:14:11 <sanity> Vulpyne: that is one reason I like that ML tells you the types it infers for a function, you can verify that its what you expect
13:14:19 <cpoucet> :t safeHead
13:14:22 <lambdabot> Not in scope: `safeHead'
13:14:30 <popcorn> :t \f -> listToMaybe . catMaybes . map f
13:14:32 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> Maybe a
13:14:35 <sanity> Vulpyne: but it seems to defeat the point of type inference somewhat to me :-/
13:14:38 <Vulpyne> sanity: I use ghci a lot in my development cycle, and :t stuff (:t shows the type)
13:15:11 <Vulpyne> sanity: Well, people usually just give functions type signatures, not whenever they do a let or create sub functions with "where".
13:15:15 <sclv_> fix' f = \a -> let nxt = f a in if nxt == a then nxt else fix' f nxt; reachable f = unions . toList . fmap (fix' (reachable f)) -- hmm.. depth first...
13:15:21 <Vulpyne> I pretty much only type-annotate top level functions.
13:15:33 <Vulpyne> But if that part is correct, usually the rest is.
13:15:35 <sanity> Vulpyne: right - do you do it by cutting and pasting the output of :t ?
13:15:48 <Vulpyne> sanity: At first.
13:16:04 <Vulpyne> sanity: I know the types pretty well by now, though, so I don't need to do that.
13:16:14 <sanity> Vulpyne: cool
13:16:28 <Vulpyne> Sometimes you want to say more about the type than would be inferred also.
13:16:39 <Vulpyne> Like if you want to restrict something to certain typeclasses.
13:17:00 <dmwit> :t \f -> (f .) . listToMaybe
13:17:03 <lambdabot> forall b a. (a -> b) -> [a] -> Maybe b
13:17:07 <sanity> Vulpyne: i understand
13:17:09 <dmwit> (@popcorn)
13:17:16 <Vulpyne> Or if you made a generic function that does something, and called it with ints, it would get an inferred signature more specific than what you might like.
13:17:20 <popcorn> :t listToMaybe
13:17:22 <lambdabot> forall a. [a] -> Maybe a
13:17:29 <dmwit> :t \f -> fmap f . listToMaybe -- bit this is really what's happening
13:17:31 <cpoucet> :t maybeToList
13:17:31 <popcorn> ok that I think is a different function that
13:17:32 <lambdabot> forall b a. (a -> b) -> [a] -> Maybe b
13:17:33 <lambdabot> forall a. Maybe a -> [a]
13:17:44 <cpoucet> maybe [] (:[])
13:17:46 <cpoucet> :T maybe [] (:[])
13:17:47 <dmwit> popcorn: Oh, you're right.
13:17:49 <cpoucet> :t maybe [] (:[])
13:17:52 <lambdabot> forall a. Maybe a -> [a]
13:18:06 <cpoucet> @src maybeToList
13:18:06 <lambdabot> maybeToList  Nothing   = []
13:18:06 <lambdabot> maybeToList  (Just x)  = [x]
13:18:31 <dmwit> :t \f -> msum . map f
13:18:33 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> m a) -> [a1] -> m a
13:18:51 <dmwit> popcorn: I think that's closer to what you wrote.
13:19:25 <popcorn> this is crazy :P
13:19:36 <popcorn> [] is a MonadPlus
13:19:43 <dmwit> So is Maybe.
13:19:47 <popcorn> oh oh ok
13:21:12 <dmwit> ?quote emission
13:21:13 <lambdabot> No quotes match.
13:22:08 <dmwit> ?remember jamesbritt Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
13:22:09 <lambdabot> I will remember.
13:26:41 <Vulpyne> I'm writing a simple cron-ish program and I've run into a weird problem. I partition my job list by whether it's runnable or not. It seems like it's getting into an infinite recursion somehow though.
13:26:54 <Vulpyne> http://hpaste.org/7446
13:27:12 <mmorrow> roconnor: a go at reachable: http://hpaste.org/7445#a2
13:28:53 <roconnor> mmorrow: :)
13:33:36 <sclv_> hah i was playing with a this depth first solution and couldn't get it to type, then realized that the type system had saved me yet again from something compelling but totally illogical :-)
13:35:36 <Vulpyne> Wow, I'm a moron.
13:36:01 <dons> oh?
13:36:31 <Vulpyne> I had "let (runnable,rest) = findRunnable now runnable" and wondered why it just stopped.
13:36:33 <DuClare> Me too.  But dons is cute.
13:36:42 <Vulpyne> (Last runnable should have been a different thing.)
13:37:08 <DuClare> {}{/g 21
13:37:11 <DuClare> Erm.
13:37:46 <sanity> anyone use emacs-mode?  <tab> doesn't seem to give me the correct indentation for the 'then' and 'else' lines of an 'if' statement - anyone got any ideas?
13:37:56 <sanity> um, i mean haskell-mode in emacs
13:38:36 <dons> Vulpyne: :)
13:38:40 <Vulpyne> sanity: I fought with it for a while and then gave up and just put the else at the end of the ine rather than a newline.
13:38:50 <Vulpyne> if something then
13:38:55 <Vulpyne>     blah blah else
13:39:02 <Vulpyne>     other stuff
13:39:27 <sanity> Vulpyne: ah, i guess that they must assume people will do
13:39:30 <sanity> Vulpyne: thanks
13:39:38 <Vulpyne> I don't know. I don't really like doing it that way, but...
13:40:12 <sanity> Vulpyne: i'll adapt :-)
13:40:45 <conal> Vulpyne: try 'else' on a new line and *then* hit tab again.  seems to work for me.
13:41:06 <Vulpyne> conal: It lines it up with the "if".
13:41:29 <conal> Vulpyne: yep.
13:41:34 <sclv_> there's a known hack to your .el files somewhere to fix this. its a pain tho -- you can also just do it manually and forget the tabs.
13:41:44 <conal> Vulpyne: you want it aligned with blah?
13:41:50 <Vulpyne> But the then/else have to be indented further or it's a syntax error.
13:42:02 <conal> Vulpyne: in a "do"?
13:42:18 <Vulpyne> conal: I'm not completely sure. I gave up and did it the other way a long time ago.
13:42:33 <Vulpyne> It did give me some pains when I was starting Haskell.
13:42:48 <conal> Vulpyne: okay.  the default "else" indentation will bite you in a "do".
13:43:05 <Vulpyne> Ah, probably was that then.
13:43:36 <thetallguy> I used to have trouble with this, but it seems to work correctly in my current version of emacs
13:44:09 <conal> oh!  stefan has been improving haskell-mode
13:45:18 <thetallguy> Hmm... Maybe not.  As you say, the default indentation doesn't work in a do block
13:45:33 <thetallguy> but outside the do, it seems better
13:45:47 <thetallguy> but I so rarely use 'if' that I don't remember.
13:47:36 <Vulpyne> Yeah, I think people starting out are more likely to use it frequently.
13:47:44 <Vulpyne> And with multiple lines in the parts.
13:50:39 <visof>  (e > 1 || e < 10) , is this right ? " e >1 or e <10 " ?
13:50:51 <visof> is the syntax right?
13:50:54 <dmwit> yes
13:51:20 <visof> p e | (e > 1 || e < 10) = "constant"
13:51:22 <visof>             | otherwise = 0
13:51:25 <visof> is this right?
13:51:40 <dmwit> no
13:51:44 <visof> why?
13:51:47 <dmwit> "constant" and 0 are different types.
13:51:51 <visof> "constant" ?
13:52:04 <dmwit> "constant" :: String, 0 :: Integer
13:52:09 <visof> ah
13:52:16 <visof> thanks dmwit
13:52:19 <dmwit> (Otherwise, it is OK.)
13:53:06 <visof> should i do |otherwise = "0"
13:53:15 <visof> it's working now
13:55:45 <conal> visof: and no parens needed there
13:55:57 <conal> though they don't hurt
13:56:20 <visof> conal what do you mean?
13:56:39 <glguy> p e | e > 1 || e < 10 = "constant"
13:56:44 <conal> yeah, that.
13:56:53 <glguy> extra parentheses hurt readability
13:57:00 <visof> ah
13:57:02 <dmwit> sometimes
13:57:08 <conal> for some readers, and help others
13:57:16 <dmwit> ?quote
13:57:17 <lambdabot> GentleIntro says: If k1 and k2 are kinds, then k1->k2 is the kind of types that take a type of kind k1 and return a type of kind k2.
13:57:18 <visof> okay conay
13:57:23 <visof> conal
13:57:25 <conal> :)
13:57:35 <dmwit> ?quote
13:57:35 <lambdabot> monochron says:  "Welcome to #haskell, where your questions are answered in contrapuntal fugues."
13:57:42 <dmwit> ?yow!
13:57:43 <lambdabot> Here we are in America ... when do we collect unemployment?
13:57:52 <dmwit> Wait, monochron?
13:58:00 <conal> would be cool to have unparsing be reader-dependent, inserting extra parens according to the readers' tastes.
13:58:05 * dmwit wonders if that was a typo
13:58:11 <thetallguy> conal: your nose is twitching
13:58:35 <conal> thetallguy: ??
13:58:46 <thetallguy> conal: coney
13:59:05 <conal> oh.  i didn't mind.
13:59:47 <conal> thetallguy: remember, i couldn't figure out your handle.  i parsed it as "theta llguy".
13:59:54 <thetallguy> conal: I was just enjoying the transform:  conal -> conay -> coney
14:00:05 <conal> thetallguy: don't stop there!
14:00:08 <thetallguy> conal: others have had trouble with that as well.
14:00:55 <thetallguy> conal: -> money, doesn't seem right
14:01:03 <conal> honey
14:01:06 <geezusfreeek> boney
14:01:11 <conal> lol!
14:01:12 <thetallguy> D'oh!
14:01:17 <thetallguy> Should have seen honey
14:01:18 <dmwit> caney canny granny
14:01:28 <dons> ?seen malcolmw
14:01:29 <lambdabot> I haven't seen malcolmw.
14:01:31 <dons> ?seen malcolm
14:01:31 <lambdabot> I haven't seen malcolm.
14:01:37 <dons> lambdabot: you lie!
14:01:50 <conal> ?seen my shoes
14:01:50 <lambdabot> I haven't seen my.
14:01:55 <conal> hey!
14:02:12 <conal> ?seen my_feet_for_weeks
14:02:12 <lambdabot> I haven't seen my_feet_for_weeks.
14:02:13 <geezusfreeek> ?seen coney
14:02:13 <lambdabot> I haven't seen coney.
14:02:31 <visof> hehe
14:02:33 <conal> gotta twak the ?seen argument parser
14:02:52 <visof> geezusfreeek  i type conal wrong
14:02:59 <visof> typed*
14:02:59 <dmwit> ?fact love
14:03:00 <lambdabot> I know nothing about love
14:03:07 <geezusfreeek> visof: i know
14:03:09 <thetallguy> It used to be that if you said 'cat <bottle', the shell would say "bottle: cannot open"
14:03:20 <conal> ha!
14:03:20 <geezusfreeek> heh
14:03:30 <thetallguy> but someone changed the errors and now a whole raft of jokes is gone
14:03:43 <dmwit> I like "[ God ]" better... "God does not exist"
14:04:04 <dmwit> Or maybe it was "[ -e God ]" or something like that; you get the idea.
14:04:07 <thetallguy> There was a whole usenet stream about those...
14:04:17 <thetallguy> different ones for C-shell
14:05:18 <thetallguy> Personally, I find dons calling lambdabot a liar a little disturbing
14:05:27 <geezusfreeek> in another irc server i frequent with some local friends there is a bot that used to learn things of the form "<foo> is <bar>" and would then say <bar> whenever somebody says <foo> ... lots of fun there
14:05:35 <geezusfreeek> accidental fun usually
14:06:13 <dmwit> Bucket?
14:08:14 <thetallguy> I never really noticed before that iterate is a special case of unfoldr.
14:08:42 <conal> thetallguy: neat.  i hadn't noticed either
14:08:44 <thetallguy> Even though I think I've read that section of the docs, it didn't really click.
14:09:16 <thetallguy> iterate basically assumes you never terminate, so you ditch the Maybe
14:10:00 <conal> or always use Just
14:10:14 <glguy> iterate f x = unfoldr (\ x -> let y = f x in Just (y,y) ) x
14:10:14 <thetallguy> cpoucet's answer to my question above brought it to light.
14:10:24 <thetallguy> listToPairs  :: forall a. [a] -> [(a,a)]
14:10:24 <thetallguy> listToPairs  xs = map (\[x,y] -> (x,y)) . map (take 2) . iterate (drop 2) $ xs
14:10:56 <thetallguy> (slightly generalized)
14:11:02 <thetallguy> listToPairs' :: forall a. [a] -> [(a,a)]
14:11:02 <thetallguy> listToPairs' xs = map (\(x:y:r) -> (x,y)) . iterate (drop 2) $ xs
14:11:58 <conal> listToPairs' = map (\(x:y:r) -> (x,y)) . iterate (drop 2)
14:12:30 * conal compulsively eta-reduces
14:12:58 <thetallguy> Yes, I would have done that, but I don't like the whole form.
14:13:47 <conal> thetallguy: don't like point-free?
14:13:51 <thetallguy> I seem to run into this problem a lot, where I want to work with the indices of elements rather than the elements themselves
14:14:24 <thetallguy> conal: no, love point-free, just don't like the lambda in there
14:14:43 <conal> oh.  and a lambda means we're not quite point-free
14:14:53 <thetallguy> conal: for one thing, it's ugly on finite lists
14:15:16 <thetallguy> *Main> take 50 $ listToPairs' [1..4]
14:15:16 <thetallguy> [(1,2),(3,4),*** Exception: /home/beshers/haskell/Pi.hs:15:23-39: Non-exhaustive patterns in lambda
14:15:33 <Apocalisp> Is there a general term for a function of the type (a -> M b) ?
14:15:51 <conal> Apocalisp: Kleisli arrow
14:15:53 <thetallguy> conal: that's what led me to unfoldr
14:15:58 <LordBrain> pairs (x1:x2:xs) = (x1,x2):pairs xs
14:15:58 <LordBrain> ; pairs _ = []
14:16:07 <dolio> > iterate (+1) 1
14:16:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:16:31 <Apocalisp> conal: Thank you! Not as catchy as I would have liked.
14:16:48 <dolio> > unfoldr (\x -> let y = 1 + x in Just (y,y) ) 1
14:16:49 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
14:17:07 <cdsmithus> What's the latex symbol that's often used to replace ++ in typeset Haskell?
14:17:10 <conal> @src Kleisli
14:17:10 <lambdabot> Source not found. :(
14:17:14 <conal> hm.
14:17:20 <conal> @src Control.Arrow.Kleisli
14:17:20 <lambdabot> Source not found. You type like i drive.
14:17:33 <Heffalump> cdsmithus: I think I've used negative space to make it
14:17:53 <Apocalisp> @hoogle Kleisli
14:17:53 <lambdabot> Control.Arrow.Kleisli :: newtype Kleisli m a b
14:17:53 <lambdabot> Control.Arrow.Kleisli :: (a -> m b) -> Kleisli m a b
14:17:53 <lambdabot> Control.Arrow.runKleisli :: Kleisli m a b -> a -> m b
14:17:55 <cdsmithus> Hmm.  I don't know that much latex. :(
14:18:11 <Heffalump> hangon, just looking up how I did it in my thesis
14:19:02 <conal> cdsmithus: btw, lhs2tex has that replacement and others build-in.  it's two pluses with a few negative spaces between.
14:19:05 <conal> (built-in)
14:19:10 <Heffalump> I seem to have used \cat without defining it myself.
14:19:14 <Botje_> phew
14:19:22 <Botje_> that pattern matching code was pretty tricky
14:19:26 <Heffalump> oh no, here it is:
14:19:31 <Botje_> but now i'm through with it
14:19:32 <Heffalump> \newcommand\cat{\mathbin{+\!\!\!+}}
14:19:32 <Botje_> yay!
14:19:35 <cdsmithus> conal, Heffalump: Thanks.
14:19:54 <Heffalump> lhs2tex sounds like the best plan
14:20:08 <conal> lhs2tex++
14:20:17 <cdsmithus> Yeah, but I'm not typesetting Haskell.  I just like the symbol for concatenation
14:21:26 <IsoPallo> Hmm... I suppose I can't pattern match against the parameters of just any function? Just data constructors? Or can I?
14:21:57 <geezusfreeek> IsoPallo: constructors only
14:22:05 <LordBrain> well, i think you can use + sometimes
14:22:21 <geezusfreeek> the + thing is just sugar
14:22:28 <popcorn> it's all sugar :)
14:22:30 <conal> what + thing?
14:22:58 <geezusfreeek> conal: where you can match things like f (n+1) and stuff, where it binds n to the parameter minus 1
14:23:06 <conal> oh!
14:23:10 <conal> n+k patterns.
14:23:13 <geezusfreeek> right
14:23:26 <popcorn> ahahaha
14:23:26 <popcorn> > let f (n+1) = n in f 7
14:23:27 <lambdabot>  Parse error in pattern at "in" (column 17)
14:23:31 <popcorn> gg
14:23:44 <LordBrain> we need an extension or something?
14:23:44 <popcorn> lambdabot has 'forgotten' about n+k ? :P
14:23:52 <geezusfreeek> hmm
14:24:04 <LordBrain> i so rarely use n+k ...
14:24:10 <geezusfreeek> i have never used it
14:24:28 <Vq^> what? we still admit that pattern?
14:24:37 <LordBrain> i think i may have once or twice, before someone said they were evil.
14:24:47 <glguy> Haskell' has forgotten about it too
14:25:06 <geezusfreeek> as a noob it confused me
14:25:16 <geezusfreeek> i thought somehow somebody had defined + as a constructor
14:26:12 <Vq^> geezusfreeek: ignore it and deny it's existance if anyone asks
14:26:17 <Apocalisp> Muhahaha! Java abuse is fun.
14:26:23 <dmwit> I think Cale dropped n+k patterns along with his (.) = fmap and (++) = mappend sorts of changes.
14:26:32 <Cale> huh?
14:26:38 <Cale> No, I wasn't responsible for that.
14:26:44 <LordBrain> they dont seem to work in hugs either
14:27:02 <Cale> It's just that the haskell parser which lambdabot uses to ensure the input is an expression doesn't support n+k patterns.
14:27:21 <geezusfreeek> Apocalisp: Java abuse is masochism
14:27:24 <dmwit> oh
14:27:27 <dmwit> Sorry, then.
14:27:57 <LordBrain> oh they do work in hugs... hmmm
14:28:12 <geezusfreeek> it is h98. isn't it?
14:28:47 <thetallguy> ?pl \n -> map (take n) . iterate (drop n)
14:28:47 <lambdabot> ap ((.) . map . take) (iterate . drop)
14:28:47 <dmwit> yeah
14:28:59 <LordBrain> i got a parse error on my first attempt... but closed the window since and dont know what i did
14:29:06 <Apocalisp> geezusfreeek: Not entirely. It's great for pedagogical purposes.
14:29:14 <geezusfreeek> conal: you will either love this or you will hate it http://github.com/geezusfreeek/simple-haskell-game/tree/experimental/Future2.hs
14:29:15 <lambdabot> Title: Future2.hs at experimental from geezusfreeek's simple-haskell-game &mdash; GitHu ..., http://tinyurl.com/6pvlbz
14:29:16 <mwc> Is there any poll(2) support in the unix lib?
14:29:19 <mwc> @src poll
14:29:20 <lambdabot> Source not found. My pet ferret can type better than you!
14:29:22 <mwc> @hoogle poll
14:29:22 <lambdabot> No matches found
14:29:57 <geezusfreeek> conal: that's my GADT future implementation. still without unsafePerformIO (or even IORef anymore), but with, i think, real memoization
14:30:09 <geezusfreeek> conal: using STRef, though
14:30:16 <LordBrain> That's at least the second time i've heard the lack of a binding for poll come up
14:30:29 <conal> geezusfreeek: i'll check it out.  thanks for the pointer!
14:30:44 <Apocalisp> geezusfreeek: Although I fear that "public abstract class DatabaseKleisli<A, B> extends Juggler2<A, Connection, B, SQLException>" will be considered obfuscation by the other developers.
14:30:50 <geezusfreeek> conal: no good comments yet. i'm adding some now though
14:31:18 <conal> geezusfreeek: okay.  i'll refresh after a while
14:31:24 <geezusfreeek> Apocalisp: looks like obfuscation to me :) (but at least i understand it)
14:31:30 <Apocalisp> ;-)
14:31:44 <mwc> There'
14:31:55 <mwc> 's something wrong with seing the word Kleisli in Java
14:32:03 <mwc> even any sort of category theory in Java
14:32:12 <conal> geezusfreeek: are you also working on a graphics library?
14:33:21 <geezusfreeek> conal: i haven't really thought about what i intend to do in that regard yet. i was thinking at first i would just use the reactive library to generate some IO, but then factor that out later
14:33:51 <geezusfreeek> that is what i had been doing in my test programs, at least
14:33:58 <conal> geezusfreeek: oh, okay.  meanwhile, i'm tinkering with functional 3d again.
14:36:25 <Apocalisp> A Kleisli Arrow and a Functor both fall under the concept of Arrow, yes?
14:36:48 <conal> Apocalisp: a Functor has the wrong kind
14:37:11 <Apocalisp> conal: Explain
14:37:33 <conal> Apocalisp: e.g., Maybe has kind * -> *, while arrows must have kind * -> * -> *
14:37:40 <popcorn> @src evalState
14:37:41 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:38:05 <Apocalisp> What's the most specific synonym for the two?
14:38:43 <conal> other than "Arrow or Functor"?
14:38:59 <conal> Apocalisp: or "type class"?
14:39:12 <conal> or "notion from category theory"
14:39:28 <popcorn> I get such crap results from this type checker :|
14:39:41 <popcorn> this is infuriating
14:40:03 <Apocalisp> conal: Right. What do you call any sequence of * ... -> * where "..." is any number of -> * ?
14:40:12 <popcorn> also GHCs derived show doesn't care what fixity I defined the infix constructors? :|
14:40:35 <Apocalisp> conal: Trying to get my category theory notions straight.
14:40:59 <conal> Apocalisp: oh!  perhaps just "a kind"
14:41:22 <Apocalisp> conal: Oh. That's boring innit?
14:41:26 <Apocalisp> :-)
14:41:39 <conal> Apocalisp: yeah
14:42:21 <Saizan> Apocalisp: anything with kind different from * is a "type constructor"
14:43:04 <conal> which seems unfortunate terminology.  inconsistent with "constructor" on values.
14:44:18 <Saizan> conal: why? a data-constructor builds a value, a type constructor builds a type
14:45:00 <conal> Saizan: on values, not all functions are "constructors"
14:45:27 <conal> but on types they are (by definition)
14:45:30 <conal> are there standard terms to distinguish higher-kinded type constants from higher-kinded type variables?  and "constructors" like (->) vs ((->) Int)?
14:47:23 <Apocalisp> So, if I have a monad M, it gives rise to a kleisli arrow a -> M a. So these two, the function M and the function k::a -> M a, are called ...s of the monad M? Constructors?
14:47:48 <cpoucet> methods?
14:47:51 <popcorn> :K (->)
14:47:59 <popcorn> :k (->)
14:48:02 <lambdabot> ?? -> ? -> *
14:48:03 <Saizan> uhm, well, i think calling ((->) Int) a type constructor is a bit of a stretch, it's just that we don't name many lambdas that aren't contructors in types
14:48:04 <popcorn> :k ((->) Int)
14:48:07 <lambdabot> ? -> *
14:48:18 <cpoucet> :k ((->) (->))
14:48:20 <lambdabot>     `(->)' is not applied to enough type arguments
14:48:20 <lambdabot>     Expected kind `??', but `(->)' has kind `?? -> ? -> *'
14:48:27 <popcorn> actually
14:48:35 <popcorn> why is it writing ?? and ? rather than * ?
14:48:45 <dolio> Those are special GHC kinds.
14:48:50 <popcorn> is that because * means a fully applied kind ?
14:48:53 <popcorn> um.
14:49:04 <dolio> ?? includes unboxed types, like Int# and so on.
14:49:04 <lambdabot>  includes unboxed types, like Int# and so on.
14:49:09 <Philippa> no
14:49:17 <Philippa> (to popcorn's question)
14:49:17 <popcorn> ?what
14:49:18 <lambdabot>  @where <key>, return element associated with key
14:49:18 <conal> Saizan: and yet ((->) Int) has kind * -> *
14:49:27 <cpoucet> dolio: and ?
14:49:27 <dolio> So, ?? is the union of * and #.
14:49:32 <Saizan> Apocalisp: the Kliesli Arrow for M is (a -> M b) and it's not a function, but a type
14:49:38 <dolio> And ? includes unboxed tuples and everything from ??.
14:49:48 <dolio> So ? is the union of ?? and (#).
14:50:12 <Saizan> conal: yeah, my definition was kind of broken :)
14:50:15 <dolio> I think there used to be a ! kind, too, but I can't find it anymore, so they may have gotten rid of it.
14:50:47 <conal> Saizan: exactly.  and i don't know of a non-broken definition that is consistent with the meaning of "constructor" on values.
14:51:15 <conal> Saizan: .. that also leaves us with a name for things like ((->) Int)
14:51:31 <geezusfreeek> conal: the url has changed because i renamed the module http://github.com/geezusfreeek/simple-haskell-game/tree/experimental/Future.hs
14:51:33 <lambdabot> Title: Future.hs at experimental from geezusfreeek's simple-haskell-game &mdash; GitHub, http://tinyurl.com/68rpjr
14:51:36 <geezusfreeek> comments are up now
14:51:41 <conal> geezusfreeek: thx
14:51:56 <geezusfreeek> and now it's time for me to go home
14:52:14 <Saizan> conal: we don't have a name for (1:) either, though
14:52:26 <conal> Saizan: a "function"
14:52:40 <conal> Saizan: or a "value function"
14:53:06 <conal> Saizan: or, syntactically, "an expression", "non-constant expression", ...
14:53:18 <conal> or a "partial application"
14:53:50 <dolio> Substitute 'type' for 'value' in any of those, then. :)
14:54:12 <Saizan> yeah, but value functions can be defined with case
14:54:31 <Apocalisp> I suppose I'm looking for what to call any function that yields a value of type M a.
14:54:41 <conal> dolio: exactly.  would then make more sense on types than "constructor".
14:54:44 <Saizan> while we don't have a type-level case if we don't resort to some extension
14:55:23 <dolio> conal: I guess. Things declared with 'type' aren't exactly constructors, either. They're (limited) type functions.
14:56:01 <conal> at the level of values "constructor" has a syntactic meaning, not about types.  at types, it has a kind meaning.  we've asked "constructor" to do double duty on types and not on values.
14:56:02 <Apocalisp> M functions?
14:56:30 <conal> so when i talk about "type constructors", i'm never sure if the meaning i have in mind will be understood.
14:58:21 <Apocalisp> conal: That's an unfortunate ambiguity.
14:59:11 <conal> Apocalisp: and one old-timers have gotten used to, i guess.
14:59:21 <dolio> conal: I suppose you could call things type constructors if they don't reduce beyond their syntactic application, too.
14:59:45 <dolio> Like, 'Maybe a" doesn't reduce beyond that. Nor '(->) a b'.
14:59:49 <Saizan> Apocalisp: aah, well those are morphisms in the kliesli category for that monad, even nicer no?:)
15:00:06 <conal> dolio: a syntactic definition.
15:00:35 <conal> dolio: and same for (:)[]?
15:00:37 <dolio> That leaves 'type' stuff kind of ambiguous.
15:00:46 <conal> yeah, it does.
15:01:07 <conal> i think the word "type" is also used inconsistently.
15:01:16 <dolio> But in that sense, besides type, you can't define anything that reduces until you get type families.
15:01:18 <conal> sometimes "type" means something of kind *,
15:01:27 <conal> but then what would "higher-kinded type" mean.
15:01:28 <dolio> At the type level.
15:02:16 <conal> dolio: parameterized type synonyms?
15:02:47 <dolio> Yeah, synonyms are the exception.
15:03:05 <Saizan> * is the kind 'type' :)
15:03:07 <conal> and it's just sort of an accident that we don't have type lambdas in the source language.
15:03:11 <Apocalisp> Saizan: That's it!
15:03:22 <Beelsebob> anyone got any idea why Haddock's parser baulks at line 1, column 0 here? http://hpaste.org/7448
15:03:23 <dolio> But you can't write stuff like 'Foo M N' reduces to 'Int' like you can at the value level.
15:03:36 <dolio> Aside from 'type Foo a b = Int' I guess. But that's not interesting. :)
15:03:39 <conal> Saizan: what sorts of thingies do "kinds" classify?
15:04:41 <Saizan> conal: types and functions/contructors on types
15:04:57 <Apocalisp> morphisms?
15:05:19 <conal> Saizan: also (sometimes but not always) known as "types"
15:05:44 <conal> types classify values, and kinds classify ...
15:06:28 <conal> i think it's just terminology we haven't got around to cleaning up yet.
15:06:37 <Saizan> well, there's also ambiguity on the scope of the term "value"
15:06:45 <conal> really?
15:07:16 <Saizan> in that sometimes with value you mean non-functions
15:07:51 <Beelsebob> no one sees why that's causing a parse error?
15:08:57 <conal> okay: how about this terminology: values can have base type or higher type.  types can have base kind or higher kind.
15:09:23 <Saizan> Beelsebob: well, module headers don't look like that
15:09:27 <conal> "constructor" is orthogonal, to do with matching, not types/kinds
15:09:37 <Beelsebob> Saizan: hmm?
15:09:46 <Beelsebob> is there something special for Haddock for a module header/
15:09:55 <Beelsebob> I assumed that it was just a comment like all other haddock docs :/
15:10:28 <Beelsebob> in fact, haddock docs say they do look like that ... http://www.haskell.org/haddock/doc/html/ch03s03.html
15:10:31 <lambdabot> Title: 3.3. The module description
15:10:53 <Saizan> i've always seen them like this http://hpaste.org/7448#a1
15:11:13 <roconnor> @hoogle prefix
15:11:14 <lambdabot> Distribution.Simple.InstallDirs.prefix :: InstallDirs dir -> dir
15:11:14 <lambdabot> Data.Generics.Basics.Prefix :: Fixity
15:11:14 <lambdabot> Text.ParserCombinators.Parsec.Expr.Prefix :: GenParser t st (a -> a) -> Operator t st a
15:11:20 <roconnor> @hoogle prefixOf
15:11:21 <lambdabot> Data.List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
15:11:21 <lambdabot> Data.ByteString.isPrefixOf :: ByteString -> ByteString -> Bool
15:11:21 <lambdabot> Data.ByteString.Char8.isPrefixOf :: ByteString -> ByteString -> Bool
15:11:55 <Beelsebob> Saizan: okay well, haddock throws an error at that too
15:12:03 <Beelsebob> plus, that's invalid H98 no?
15:12:10 <Beelsebob> in that --------....------- is an operator
15:12:52 <Saizan> Beelsebob: where do i have ---...--?
15:13:03 <Beelsebob> where ... indicates a lot of ----s
15:13:15 <Saizan> ah
15:13:16 <popcorn> I think it's a comment
15:13:22 <Beelsebob> -- ---- is a comment, --------- is an operator
15:13:24 <Beelsebob> unless I'm mistaken
15:13:34 <Beelsebob> (which is entirely plausable)
15:13:34 <popcorn> > let (----------------------) _ _ = 0 in (----------------------) 1 2
15:13:35 <lambdabot> Unbalanced parentheses
15:13:45 <Saizan> never had a problem with that module..
15:13:51 <Beelsebob> we established earier that lambdabot has a bug in that repsect popcorn
15:14:03 <popcorn> Prelude>  let (----------------------) _ _ = 0 in (----------------------) 1 2
15:14:03 <popcorn> <interactive>:1:68: parse error (possibly incorrect indentation)
15:14:03 <Beelsebob> > let (--^) _ _ = 0 in (--^) 1 2
15:14:04 <lambdabot> Unbalanced parentheses
15:14:16 <popcorn> oh weird that IS an operator
15:14:18 <popcorn> --^ is
15:14:25 <Beelsebob> indeed
15:14:30 <Beelsebob> lambdabot's parser has a bug there
15:15:02 <Beelsebob> Saizan: I was under the impression that operators were any sequence of the defined symbols, except for --
15:15:22 <twanvl> A haskell comment starts with two *or more* dashes
15:15:28 <Beelsebob> oh, okay
15:15:40 <Beelsebob> not followed by another symbol
15:15:50 <Beelsebob> (because --^ for example *is* an operator)
15:16:16 <twanvl> "comment -> dashes [ any<symbol> {any}] newline"
15:16:23 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Monad-Fix.html <-- another haddock example
15:16:25 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5pobpm
15:16:37 <Beelsebob> anyway, back to the original problem
15:16:47 <Beelsebob> with an exact copy/paste of that, haddock still baulks
15:16:47 <Beelsebob> :/
15:17:19 <Beelsebob> with this error... http://hpaste.org/7448#a2
15:19:30 <Saizan> weird, which haddock?
15:20:18 <Beelsebob> just grabbed it from hackage 15 mins ago
15:20:21 <Beelsebob> so... 2.1?
15:20:40 <Beelsebob> yeh, 2.1.0
15:21:26 <Saizan> did you rerun configure on mkbndl after installing haddock?
15:21:26 <Beelsebob> Ah, found the bug I think
15:21:31 <Beelsebob> yep
15:21:52 <Beelsebob> I *think* the bug is that haddock comments may not include (within the comment) a line containing lots of hyphens
15:22:07 <Beelsebob> i.e. {-| This is fine -}
15:22:21 <Beelsebob> {-| This is not\n----------------------\n-}
15:22:47 <Beelsebob> similarly, -- | This is fine, unless I immediately follow it with -- -------------------
15:22:55 <Saizan> hah
15:24:30 <eyeris> If I call connectSqlite3 (Database.HDBC.Sqlite3) and it fails (e.g. the file is mode 000) then my program just terminates. How can I prevent this?
15:24:54 <eyeris> It looks like it is segfaulting
15:27:25 <shapr> yarr!
15:27:27 <shapr> @users
15:27:27 <lambdabot> Maximum users seen in #haskell: 448, currently: 441 (98.4%), active: 11 (2.5%)
15:29:15 <Beelsebob> thanks for the help Saizan
15:29:33 <Beelsebob> looks all packaged up and good to go, once I finish off the niggly bits
15:31:42 <gwern> hm. is 'array' from split-base?
15:33:00 <dons> yep
15:33:15 <conal> has anyone here played with multivariate automatic differentiation (AD)?  i'm trying to do AD with a type of linear maps as derivatives, hoping to handle non-scalar domain types ("multivariate").
15:33:26 <conal> i haven't gotten the typing to work out
15:47:32 <jorick> is there already a working ECMA interpreter written in Haskell?
15:47:40 <jorick> ECMAscript
15:47:59 <geezusfreeek> conal: i have, but it's been a while
15:48:14 <conal> geezusfreeek: oh?  non-scalar (multivariate)?
15:48:21 <geezusfreeek> oh, not non-scalar no
15:48:25 <geezusfreeek> i missed the key word there
15:48:33 <conal> okay, np.
15:49:11 <conal> geezusfreeek: i'm trying to structure in an elegant way, with derivative values being linear maps, which generalizes scalars, vectors, matrices, etc.
15:49:12 <mwc> jorick: I believe the ECMAscript4 reference interpreter was actually written in SML
15:49:52 <geezusfreeek> conal: i spent all of fifteen minutes trying that once and gave up very quickly
15:50:02 <geezusfreeek> but i was just learning haskell at the time, so that doesn't mean much
15:50:20 <jorick> mwc: that would be a great reference point !
15:50:21 <conal> geezusfreeek: then use special cases for generating normals of curves and surfaces.  will be cool if it works out.  (if.)
15:51:15 <roconnor> @type any
15:51:17 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
15:51:32 <conal> the idea of derivative values as linear maps unifies so much.  for instance, all of the chain rules collapse into one, with the various notions of derivative multiplication becoming composition of linear maps.
15:52:10 <roconnor> @type \x -> (`isPrefixOf` x)
15:52:13 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
15:52:45 <ddarius> conal: What trouble are you having/what are you trying to do currently?
15:53:56 <jaj> Can't you use the [] constructor like any other constructor to create a list? like [] 1 == [1]
15:54:23 <dolio> [] is the empty list.
15:54:29 <ziman> [] isn't a constructor :)
15:54:40 <dolio> It is a constructor.
15:54:45 <conal> ddarius: i don't think i can pin down one problem.  the various pieces aren't yet fitting together.
15:54:49 <roconnor> ziman: actually is a constructor
15:54:50 <conal> ddarius: first there's the question of how to represent linear maps over arbitrary types.  i'm using data type familes for that, indexed by the domain type.
15:54:54 <roconnor> but it takes no arguments
15:55:02 <jaj> 'the haskell school of expression' says it's a constructor ;)
15:55:03 <ddarius> ziman: [] is a (nullary) data constructor and a unary type constructor.
15:55:09 <ziman> i see
15:55:19 <ziman> like Nothing ;)
15:55:22 <gwern> @wn coprophagia
15:55:23 <conal> thre are at least three different things called []
15:55:24 <lambdabot> *** "coprophagia" wn "WordNet (r) 2.0"
15:55:24 <lambdabot> coprophagia
15:55:24 <lambdabot>      n : eating feces; in human a symptom of some kinds of insanity
15:55:24 <lambdabot>          [syn: {coprophagy}]
15:55:36 <dolio> @slap gwern
15:55:36 * lambdabot secretly deletes gwern's source code
15:55:51 <gwern> ah; so I guess 'coprophagy' was the verb form. shucks
15:56:09 <mwc> jorick: I can't find anything specifically saying it's SML, but on http://www.ecmascript.org/dev.php they give the SML/NJ lib manual, and the SML basis lib manual as resources for developers. That's pretty conclusive to me
15:56:10 <jaj> I have a string which represents a number and I want a list with all of those numbers seperately.
15:56:11 <lambdabot> Title: ECMAScript - Development
15:56:37 <gwern> hm. so I suppose 'coprophilia' would be a noun then too
15:56:40 <gwern> @wn coprophilia
15:56:40 <lambdabot> No match for "coprophilia".
15:56:49 <jorick> mwc, i'm already browsing through the source :)
15:56:52 <jorick> thx
15:56:53 <geezusfreeek> jaj: what you want is (:) 1 []
15:57:03 <geezusfreeek> > (:) 1 []
15:57:06 <lambdabot>  [1]
15:57:11 <jaj> so I tried map read. but this results in the fact that read gets applied to a Char instead of a string
15:57:21 <jaj> so I wanted to do map read.[] string
15:57:33 <mwc> jaj, you are aware a string is [Char]?
15:57:34 <ddarius> > map digitToInt "123"
15:57:35 <lambdabot>  [1,2,3]
15:57:40 <mwc> there, that's what I was getting to
15:57:55 <gwern> @wn miserere
15:57:55 <lambdabot> No match for "miserere".
15:58:07 <jaj> ddarius: thanks that's easier ;)
15:58:30 <gwern> (miserere means 'fecal vomiting', if anyone was wondering)
15:58:30 <geezusfreeek> > map (read . (:[])) "123"
15:58:32 <lambdabot>  [Exception: Prelude.read: no parse
15:58:36 <geezusfreeek> err
15:58:37 <ddarius> @index digitToInt
15:58:37 <geezusfreeek> something
15:58:37 <lambdabot> Data.Char
15:59:15 <geezusfreeek> gwern: nice…
15:59:28 <Saizan> gwern: what are you reading?
16:00:25 <jaj> @index digitToInt
16:00:26 <lambdabot> Data.Char
16:00:35 <gwern> Saizan: http://www.neatorama.com/2008/05/03/10-insulting-words-you-should-know/
16:00:37 <lambdabot> Title: Neatorama  Blog Archive  10 Insulting Words You Should Know, http://tinyurl.com/46p76w
16:00:55 <gwern> the title is a lie - it has way more than 10 words
16:01:05 * gwern is slowly inputting them to my vocab builder program
16:01:11 <roconnor> does ParseArgs come with GHC?
16:02:06 <saml> > (\x -> \x -> x+x) "one" 1
16:02:08 <lambdabot>  2
16:02:22 <saml> > @pl (\x -> \x -> x+x)
16:02:22 <lambdabot>  Parse error at "@pl" (column 1)
16:02:30 <saml> @pl (\x -> \x -> x+x)
16:02:30 <lambdabot> const (join (+))
16:04:10 <eu-prleu-peupeu> hey people
16:04:16 <eu-prleu-peupeu> i want to start coding haskell really fast
16:04:22 <eu-prleu-peupeu> what documentation do you recomend ?
16:04:25 <dons> quick, install ghc!
16:04:27 <saml> > ((+) >>= id) 3
16:04:28 <lambdabot>  6
16:04:33 <dons> read YAHT
16:04:34 <dons> ?where yaht
16:04:35 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
16:04:37 <saml> is (+) monad?
16:04:38 <eu-prleu-peupeu> ok, i installed ghc
16:04:52 <eu-prleu-peupeu> nice, yaht
16:05:02 <geezusfreeek> quick, put on your robe and wizard hat!
16:05:05 <eu-prleu-peupeu> after yaht i will be able to code haskell like there is no tomorrow ?
16:05:11 <saml> eu-prleu-peupeu: yes
16:05:16 <dons> like there is *no* tomorrow!
16:05:34 <mwc> eu-prleu-peupeu: well, then you'll have to have your monad epiphany
16:05:39 <mwc> it's different for everyone
16:05:47 <eu-prleu-peupeu> epiphany ?
16:05:47 <mwc> sort of like a native american vision quest
16:05:52 <eu-prleu-peupeu> hmm ok
16:05:58 <geezusfreeek> s/monad/monad transformer/
16:06:04 <mwc> geezusfreeek: fair enough
16:06:04 <eu-prleu-peupeu> sweet
16:06:25 <mwc> I would say being able to recognize when you should create a monad is the key thing to understanding them
16:06:37 <saml> which is all the time
16:06:42 <eu-prleu-peupeu> it tends to be difficult to debug
16:06:48 <eu-prleu-peupeu> is haskell difficult to debug ?
16:06:52 <geezusfreeek> mwc: i love the comparison of the monad epiphany to a vision quest
16:06:53 <saml> i don't know how to debug haskell
16:06:59 <eu-prleu-peupeu> i tend to spend a lot of time on the gdb when coding C
16:07:11 <geezusfreeek> eu-prleu-peupeu: ghci is your friend
16:07:14 <saml> i tend to spend a lot of time on #haskell when coding haskell
16:07:23 <mwc> eu-prleu-peupeu: the type checker, properly used, also prevents inconsistent code from compiling
16:07:24 <geezusfreeek> most bugs that aren't caught by the type checker are fairly obvious
16:07:26 <eu-prleu-peupeu> yes, but ghci is like debuggin with printf
16:07:41 <geezusfreeek> ghci has a debugger as well, although i have never needed it
16:07:47 <eu-prleu-peupeu> okey
16:07:53 <saml> debugging in haskell is hard
16:08:01 <mwc> eu-prleu-peupeu: ghci is printf with the ability to insert new test values on a whim
16:08:08 <eu-prleu-peupeu> ok
16:08:10 <saml> it gets really hard that you want to rewrite the whole thing in java
16:08:21 <eu-prleu-peupeu> yaht is 192 pages :/
16:08:21 <saml> when you're stuck in a hard to debug bug
16:08:26 <geezusfreeek> saml: what are you doing here then?
16:08:50 <mwc> eu-prleu-peupeu: most of it is skimmable
16:09:22 <saml> geezusfreeek: i am resting from debugging now. i'll tackle the bug again at home
16:09:45 <eu-prleu-peupeu> do you think it is a good thing if i print it and read it on the bus ?
16:09:52 <eu-prleu-peupeu> or online viewing should be necessary ?
16:10:09 <saml> eu-prleu-peupeu: probably you need a computer to try stuff up
16:10:25 <geezusfreeek> eu-prleu-peupeu: you will want to do at least _some_ of the exercises, but if you consider yourself fairly competent then a bus read wouldn't hurt
16:10:56 <eu-prleu-peupeu> how long until i can start producing real hardcore haskell code ?
16:11:15 <geezusfreeek> eu-prleu-peupeu: in most cases it takes a while
16:11:19 <eu-prleu-peupeu> hmmf
16:11:27 <eu-prleu-peupeu> i want to start tomorrow
16:11:33 <eu-prleu-peupeu> okey, saturday then
16:11:34 <ddarius> So don't be like most cases.
16:12:16 <eu-prleu-peupeu> i've read the gentle haskell tutorial once
16:12:18 <eu-prleu-peupeu> it was nice
16:12:26 <geezusfreeek> and gentle?
16:12:31 <eu-prleu-peupeu> but it was some months ago, i've probably forgotten everything
16:12:38 <eu-prleu-peupeu> i think it was that name
16:12:40 <saml> my type inference function can't infer type of (\x -> \x -> x + x) correctly. it says Int -> a -> Int. where it should be a -> Int -> Int
16:14:40 <mwc> looks like the inner x + x expression is using the outer x variable
16:14:47 <mwc> check your variable capture
16:14:57 <BONUS> hehe gentle introduction to haskell
16:15:00 <saml> mwc: yah something is wrong with lambda variables
16:15:09 <BONUS> the not so gentle gentle tutorial
16:15:09 <popcorn> hey saml
16:15:17 <saml> hey popcorn
16:15:32 <mwc> saml: I think it's something to do with variable capture. It's like the inner x isn't shadowing the outer
16:15:34 * ddarius had no trouble with the Gentle Introduction.
16:15:37 <popcorn> I had a go at it myself and it's fairly tricky
16:15:56 <eu-prleu-peupeu> i found it good, only i remember the monad chapter required some other base text until i could decypher it
16:16:10 <saml> is "variable capture" a technical term?
16:16:24 <mwc> yes
16:16:46 <ddarius> A type inferencer for the simply typed lambda calculus is about three lines of Prolog.
16:16:51 <mwc> though perhaps for a functional language, "binding" capture would be more appropriate
16:16:58 <popcorn> yeah but it's much harder in Haskell
16:17:24 <saml> popcorn: you mean you implemented type inference?
16:17:31 <roconnor> @hoogle getArgs
16:17:31 <mwc> the inner lambda needs to "capture" the name x from the environment, shadowing the upper one
16:17:32 <lambdabot> System.Environment.getArgs :: IO [String]
16:17:49 <ddarius> popcorn: Not really.
16:17:59 <Pseudonym> ddarius: That's because there's only one algorithm in Prolog.
16:18:07 <Pseudonym> Exponential backtracking search.
16:18:21 <popcorn> Pseudonym: It's because of the way unification works actually
16:18:26 <mwc> it appears that your type inference is concluding x must be an Integer, but it's applying that to the outer x variable, not the inner
16:18:40 <popcorn> saml: yeah but mine doesn't work either :P http://rafb.net/p/Oqb54f84.txt
16:18:42 <saml> mwc what I'm doing is:   cache outer x = t0. put inner x = t1. type inference x+x. put x = t0 back.
16:18:43 <Pseudonym> True.
16:19:00 <popcorn> withTCM (infer termId) gives a -> a, but for termFlip it gives a bad answer
16:19:08 <popcorn> and flip id is even worse
16:19:09 <Pseudonym> I don't think I'd like a type checked whose only error message was "fail", though.
16:20:04 <saml> mine is at: http://hpaste.org/7428  popcorn
16:20:29 <popcorn> there is e.g. http://muaddibspace.blogspot.com/2008/01/type-inference-for-simply-typed-lambda.html
16:20:30 <lambdabot> Title: Muad`Dib: Type inference for The Simply Typed Lambda Calculus, http://tinyurl.com/ynjhl6
16:20:45 <popcorn> which I basicially tried to compile into haskell (that's where my infer function came from)
16:20:51 <popcorn> but without logic variables that idea didn't work
16:22:20 <popcorn> saml: did you find out why yours didn't work?
16:23:12 <saml> popcorn: no. but i'll tackle it when i get home
16:24:18 <saml> i'm gonna write a haskell tutoril like Write yourself a Scheme in 48 hours to confuse other people lol
16:24:28 <saml> later
16:25:56 <ddarius> popcorn: So implement logic variables.
16:26:12 <popcorn> I wish I knew how
16:26:28 <ddarius> @google "Typed Logic Variables in Haskell"
16:26:29 <lambdabot> No Result Found.
16:26:34 <ddarius> @google "Typed Logical Variables in Haskell"
16:26:47 <lambdabot> http://citeseer.ist.psu.edu/claessen00typed.html
16:26:47 <lambdabot> Title: Typed Logical Variables in Haskell - Claessen, Ljungl (ResearchIndex)
16:27:20 <eu-prleu-peupeu> Can you
16:27:20 <eu-prleu-peupeu> think of a way to determine whether function application binds more or less tightly
16:27:20 <eu-prleu-peupeu> than multiplication?
16:27:24 <eu-prleu-peupeu> :/
16:27:30 <eu-prleu-peupeu> i cant
16:27:34 <popcorn> > const True
16:27:35 <lambdabot>  Add a type signature
16:27:39 <Cale> eu-prleu-peupeu: sure
16:28:13 <Cale> > let f x = x + 1 in f 1 * 2
16:28:14 <lambdabot>  4
16:28:24 <ddarius> Almost any non-linear function will work.
16:29:23 <eu-prleu-peupeu> okey, but how to determine whether it binds more or less tightly than multiplication ?
16:29:46 <geezusfreeek> eu-prleu-peupeu: cale's example just showed it
16:29:55 <Cale> eu-prleu-peupeu: Well, that would have been 3 if it bound less tightly than multiplication
16:30:11 <Cale> The answer is that function application binds more tightly than any operator.
16:30:32 <ddarius> You could, of course, always just read the Report or any of a plethora of tutorials/introductions/books.
16:30:35 <eu-prleu-peupeu> ah ok, i was reading the problem in the wrong way, thank you yes...
16:30:42 <eu-prleu-peupeu> it is simple okok
16:31:50 <Cale> > succ 0 * 0
16:31:51 <lambdabot>  0
16:31:54 <Cale> > succ (0 * 0)
16:31:56 <lambdabot>  1
16:32:03 <Cale> There's a good one :)
16:33:10 <eu-prleu-peupeu> hmm :)
16:33:13 <eu-prleu-peupeu> yes i see
16:33:34 <ddarius> > show 0*0
16:33:34 <lambdabot>   add an instance declaration for (Num String)
16:33:37 <ddarius> > show (0*0)
16:33:38 <lambdabot>  "0"
16:34:12 * edward2 waves hello
16:34:23 <edward2> @seen gwern
16:34:24 <lambdabot> gwern is in #xmonad, #darcs and #haskell. I last heard gwern speak 33m 19s ago.
16:34:43 <edward2> @tell gwern thanks for the patch!
16:34:43 <lambdabot> Consider it noted.
16:39:43 <Trinithis> how can I do something like this: xss <- mapM (randN .) [[5], [10], [15]]
16:40:13 <Trinithis> where randN generates a num from [0, n)
16:40:37 <Trinithis> xss would be something like [[2], [7], [1]]
16:46:41 <popcorn> so basically use STRefs ?
16:46:48 <popcorn> to implement logic variables
16:47:46 <ddarius> popcorn: That's probably the sanest way.
16:49:04 <edwardk> weird, i have a module that if i import it with "import Control.Functor.Pointed" it complains during -Wall that it doesn't need anything it imported, but if I import it with "import Control.Functor.Pointed ()" it can't find the two things I need from it!
16:49:11 <edwardk> wish i had a smaller test case
16:49:52 <ddarius> Do you get warnings for orphan instances?
16:50:26 <edwardk> ddarius: nope
16:51:52 <edwardk> i use two classes defined in the other module that none of the other modules i am importing re-export
17:06:17 * shapr feels crappy
17:06:29 <ddarius> shapr: stop
17:06:41 <edwardk> heh he's been sniffling all day
17:07:12 <gwern> @wn PHALLOCRYPSIS
17:07:12 <lambdabot> No match for "PHALLOCRYPSIS".
17:07:28 <gwern> @wn phallocrypsis
17:07:28 <lambdabot> No match for "phallocrypsis".
17:07:51 <agnokapathetic> hello all
17:07:52 <gwern> wn--
17:07:52 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
17:08:05 <luqui> gwern, ew
17:08:12 <dmwit> gwern: Try dictionary.die.net/?q=phallocrypsis for spelling-correction suggestions.
17:08:23 <dmwit> Hiya, agnokapathetic!
17:08:27 <edwardk> bah, an orphan instance is an orphan instance if neither the head nor the class is in the module that defines it right?
17:08:42 <agnokapathetic> is there a zipN, like for zip3, zip4 etc. but as a general case?
17:08:44 <gwern> dmwit: no good
17:08:51 * thetallguy thinks shapr and crappy should get a room
17:09:00 <gwern> didn't someone define zipN using template haskell?
17:09:01 <edwardk> agnokapathetic: there is a paper on it using polykinded types, but its not typeable in haskell iirc
17:09:10 <edwardk> and yeah there is a TH implementation
17:09:16 <dmwit> agnokapathetic: transpose
17:09:30 <edwardk> @type transpose
17:09:32 <lambdabot> forall a. [[a]] -> [[a]]
17:09:39 <edwardk> or that works
17:09:57 <dmwit> =)
17:10:03 <gwern> luqui: you think that's bad? PHALLONCUS is even worse
17:10:06 <agnokapathetic> thank you, i think that may just work :)
17:10:09 <EvilTerran> i didn't think you needed polykinded types, merely dubious trickery with typeclasses, a la printf
17:10:43 <Saizan> you can write zipN without TH with some milliolegs, in fact
17:11:14 <EvilTerran> or the zipping instance of Applicative
17:11:29 <shapr> thetallguy: hah
17:11:31 <dmwit> gwern: I'm surprised it's not just called phallocitus or something.
17:11:35 <edwardk> http://citeseer.ist.psu.edu/hinze00polytypic.html was the version i was thinking of
17:11:35 <lambdabot> Title: Polytypic Values Possess Polykinded Types - Hinze (ResearchIndex)
17:11:47 <edwardk> but yeah there is hackery available
17:11:55 <dmwit> Ooh, ziplist.
17:11:57 <gwern> dmwit: -crypsis does make a sort of sense - 'hidden', after all
17:12:08 <dmwit> Oh, yeah, it's phalloncus that surprises me.
17:12:34 <dmwit> I mean, "-itis" is the usual "swelling" suffix.
17:13:50 <gwern> I actually have no idea what the -oncus suffix is supposed to be, unless it's related to the onco- prefix
17:13:58 <dmwit> Yeah, ZipList is really pretty sneaky.  I like it so much!
17:14:18 <dmwit> onkos is Greek for mass
17:14:32 <dmwit> (according to http://cancerweb.ncl.ac.uk/cgi-bin/omd?phalloncus )
17:14:33 <lambdabot> Title: Definition: phalloncus from Online Medical Dictionary
17:15:20 <edwardk> gwern: merged all but the -O2
17:17:18 * gwern knows
17:17:43 <edwardk> gwern: currently wrestling with moving some instances around to get them to now show up as orphans
17:18:44 <gwern> edwardk: actually, how did you upload? missing the LICENSE should've prevented you from making an sdist tarball for hackage, AFAIK
17:19:06 <edwardk> gwern: it went fine
17:19:35 <edwardk> gwern thats why i was kinda weirded out by that part of the patch
17:22:42 <popcorn> @src guard
17:22:42 <lambdabot> guard True  =  return ()
17:22:42 <lambdabot> guard False =  mzero
17:22:54 <popcorn> :t return ()
17:22:57 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
17:23:17 <popcorn> what is () ?
17:23:26 <dmwit> It's a unit type, with exactly one value.
17:23:30 <dmwit> () :: ()
17:23:48 <dmwit> (Technically, we also have undefined :: ().  but meh)
17:24:05 <dmwit> popcorn: It's usually used when we want a function that doesn't really return any real information.
17:24:21 <edwardk> bah it looks like i am stuck with a couple of orphan instances where the parameterized (co)monads are concerned. i can't put them in the file with the bifunctor fixpoint constructor and i obviously can't go put them in control.monad
17:24:32 <dmwit> popcorn: For example, the information returned from "guard" is embodied in the structure of the monad, not in the value wrapped in the monad.
17:24:46 <popcorn> I see
17:25:07 <dmwit> popcorn: If you look at (guard :: Bool -> [()]), you'll see that it either returns [] or [()]; what's interesting is the length of the list rather than the values.
17:25:08 <edwardk> you use () like you use void in java or C
17:25:39 <ddarius> @src ()
17:25:39 <lambdabot> data () = ()
17:26:07 <popcorn> It's a zero tuple?
17:26:18 <dmwit> Yeah!
17:26:20 <popcorn> @src (,)
17:26:20 <lambdabot> Source not found. stty: unknown mode: doofus
17:26:45 <dmwit> data (a, b) = (a, b) -- pseudocode from the Gentle Intro
17:28:59 <kpreid> pseudo, eh. it could have been defined to parse, but always give an 'already defined' error :-)
17:29:02 <kpreid> same for [] ...
17:29:28 <kpreid> (or just have no effect...that way you could include it in a executable Prelude)
17:29:41 <kpreid> (of course, data (a,b) = (b,a) would be rejected)
17:30:00 <dmwit> That seems like a lot of work for not much benefit.
17:30:34 <dolio> GHC apparently defines [] by making it parse and putting it in one of the GHC.* modules.
17:33:28 <dolio> I think it has a module with a lot of tuple definitions, too, but it seems to be able to generate them on the fly, too (although really large ones seem to be flaky).
17:34:14 <popcorn> cool
17:34:39 * dcoutts pushes a pile of patches to cabal-install
17:35:09 <popcorn> some language just define , as an infix product operator
17:35:12 <edwardk> er how frowned upon are hs-boot files? =)
17:35:33 <dcoutts> edwardk: they're fine
17:35:43 <popcorn> so (a,b,c,d) = (a,(b,(c,d)))
17:35:51 <dcoutts> edwardk: though they're ghc-only I think
17:36:07 <edwardk> dcoutts: k, i think i have to give in and use one or i have to put a lot of instances in some really unnatural places
17:36:10 <ddarius> edwardk: Frown at GHC.
17:36:42 <edwardk> dcoutts: either that or i have to collapse a bunch of stuff into an enormous base module
17:37:15 <dcoutts> edwardk: aye
17:38:11 <edwardk> dolio: that nice shiny BiffB thing i think has come around to bite me in the ass
17:38:22 <dolio> Like, asking for the type of (,,,...,) works, but (1,1,1,...1,1) doesn't (but (,,,...,) 1 1 1 ... 1 1 does).
17:38:37 <dolio> edwardk: Oh?
17:40:24 <edwardk> dolio: the instance declarations for PMonad are fine, but then the things like class PMonad f => Monad (FixB f) have to be in the file declaring FixB or they get declared orphans and might be missed, so i have to break the cycle by making the Bifunctor.Fix module look "out" at the things that use it for the most part, but then that makes lots of crap unrelated to Fix windup in that module, etc.
17:41:23 <dolio> Ah, yeah.
17:41:47 <dolio> There's nothing wrong with orphan instances, per se.
17:42:00 <dolio> Although I guess they may not get documented (not sure).
17:42:05 <edwardk> And I blow up when i go to define instances for PApplicative for certain versions of BiffB using the free declaration for any PMonad
17:42:21 <edwardk> er the free declaration of pap for any PMonad
17:42:46 <edwardk> because they have to either be defined in the Bifunctor.Biff module or they have to be placed in PApplicative
17:42:52 <edwardk> but PMonad depends on the PApplicative module
17:43:20 <edwardk> so more stuff collapses to the hub
17:43:43 <jaj> Hi! I'm desperately trying to use the list monad inside of the IO monad. I'd like to do something like 'a <- [1 .. 10]' inside an IO function.
17:44:05 <dolio> Maybe you should just lean on the GHC guys to implement mutually recursive modules properly. :)
17:44:10 <jaj> I tried several lift functiouns but I can't get it to work. I always get obscure type errors
17:44:10 <edwardk> hah
17:45:41 <dolio> Well, you could use ListT IO, but ListT is broken in some ways.
17:46:05 <ddarius> dolio: ListT IO is not a monad.
17:46:26 <dolio> To lift a list, you'll need 'MonadPlus m => choose :: [a] -> m a ; choose = msum . map return'
17:46:48 <dolio> Yeah, I know.
17:47:10 <popcorn> jaj: why is IO around?
17:47:21 <dolio> You might want to install logict. LogicT IO should be a monad if I'm not mistaken.
17:47:23 <jaj> popcorn: because it's in main :)
17:47:30 <ddarius> dolio: Yes.
17:47:34 <popcorn> maybe move it out of main?
17:49:09 <jaj> something like a <- [1 .. 10]; b <- [1 .. 10]; print (a + b), not possible?
17:49:21 <popcorn> what should it print?
17:49:32 <edwardk> dolio: also since every 'parameterized pointed' functor is really a bifunctor, do you think i should move control.functor.pointed.parameterized to control.bifunctor.pointed?
17:49:32 <jaj> [2,4,...]
17:49:40 <popcorn> why would it print that ;/
17:49:44 <popcorn> jaj: that makes no sense
17:50:04 <dolio> Why not 'a <- [1..10] ; b <- [1..10] ; return (show (a + b))'?
17:50:06 <popcorn> > do a <- [1 .. 10]; b <- [1 .. 10] ; return (a+b)
17:50:08 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7,...
17:50:13 <dolio> That gives you a [String], which you can then print.
17:50:21 <popcorn> :t map print (do a <- [1 .. 10]; b <- [1 .. 10] ; return (a+b))
17:50:24 <lambdabot> [IO ()]
17:50:28 <EvilTerran> or even return (print (a+b))
17:50:39 <EvilTerran> and then sequence_ the result
17:50:46 <popcorn> @hoogle [IO ()] -> IO [()]
17:50:47 <lambdabot> No matches, try a more general search
17:50:52 <popcorn> :t sequence_
17:50:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
17:51:31 <dolio> edwardk: My category-fu is fairly weak.
17:52:00 <edwardk> dolio: mostly just sounding to see if it sounded unnatural
17:52:15 <Kamina_> hello.. i have a questions related to implementation plans for a proposal related to existentials
17:52:17 <ddarius> Isn't a parameterized functor a bifunctor regardless of whether it is pointed or not?
17:52:18 <jaj> ok I think I know what I got wrong, thanks
17:52:30 <edwardk> ddarius: yes.
17:52:41 <SamB> ddarius: you lost me at "bifunctor" if not before
17:52:44 <dolio> What's the signature? a -> f p a?
17:53:16 <edwardk> ddarius: the only reason it was there was because Monad/Comonad were looking in Control.Functor.Pointed, and were themselves defined in Control.Foo.Parameterized so it was named Control.Functor.Pointed.Parameterized for symmetry
17:53:30 <dolio> Is that the same operation that would be associated with a pointed bifunctor (if there is such a construct)?
17:53:42 <ddarius> SamB: A bifunctor is simply a functor from a (binary) product category.
17:53:50 <edwardk> dolio: well pretty much
17:54:04 <SamB> product category?
17:54:06 <edwardk> samb: you know a couple. Either and (,) come to mind =)
17:54:36 <ddarius> SamB: The product of two categories.  The obvious way of doing that.
17:54:37 <edwardk> class Bifunctor f where bimap :: (a -> b) -> (c -> d) -> f a c -> f b d
17:54:47 <edwardk> bimap there is *** for (,) and +++ for Either
17:55:17 <SamB> ddarius: I didn't realize you could make pairs that had objects from different categories in them!
17:55:47 <ddarius> SamB: Why not?  You can define a category however you like as long as the laws hold.
17:56:05 <SamB> I suppose you have a point there
17:56:17 <SamB> as long as the pairs are sufficiently abstract ;-)
17:56:46 <ddarius> SamB: No, they are just set pairs.
17:56:57 <dolio> edwardk: I just mean, would a point for a bifunctor be expected to be :: (p,a) -> f p a or something.
17:57:22 <SamB> ddarius: I thought category theory was more abstract than set theory?
17:57:57 <dolio> I suppose given bimap, you can define that from a -> f p a.
17:58:03 <ddarius> Define "abstract"
17:58:08 <edwardk> dolio:  should be able to go from a single object
17:58:21 <edwardk> dolio: and the arguments are actually flipped it goes to a -> f a p
17:58:31 <dolio> Ah.
17:58:31 <edwardk> because you tie the fixpoint on the second argument
18:00:00 <edwardk> i'll move it to Bifunctor.Pointed
18:00:02 <edwardk> coz its cleaner
18:03:55 <popcorn> what happends if you lift callcc through the state monad transformer?
18:04:29 <EvilTerran> the state gets reverted to where the callcc was when you invoke the continuation
18:04:41 <edwardk> popcorn: iirc in that version you can't change state inside the cc
18:04:47 <EvilTerran> you can keep the state if you use ContT State instead of StateT Cont
18:04:49 <edwardk> what evilterran said
18:06:00 <dolio> Actually, that might not be true.
18:06:09 <glguy> I think that mtl is broken in that regard
18:06:16 <glguy> you might use MonadLib if it infact is
18:06:18 <edwardk> glguy: ?
18:06:18 <glguy> (which is not)
18:06:34 <Saizan> popcorn: with the current instances nothing very interesting
18:06:38 <glguy> one sec, I'm writing up a test case
18:07:15 <dolio> > runCont (runStateT (callCC (\k -> modify (+1) >> k ())) 5) id
18:07:17 <lambdabot>  ((),6)
18:07:35 <glguy> and the reverse?
18:07:56 <dolio> > runState (runContT (callCC (\k -> modify (+1) >> k ())) return) 5
18:07:58 <lambdabot>  ((),6)
18:08:04 <glguy> see, broken :)
18:08:06 <edwardk> odd
18:08:10 <EvilTerran> huh
18:08:14 <dolio> Yeah. It's implemented so they're both the same.
18:08:16 <edwardk> broken lift?
18:08:40 <glguy> Monadlib gets it right
18:08:48 <popcorn> ooh
18:09:09 <popcorn> and this is wrong why
18:09:17 <popcorn> where is the lift?
18:10:42 <glguy> Prelude MonadLib> runId $ runContT return $ runStateT 0 $ callCC $ \ k -> (get >>= set . succ) >> k ()
18:10:42 <glguy> ((),0)
18:11:22 <ddarius> @google ruind
18:11:23 <lambdabot> No Result Found.
18:11:31 <dolio> Oh yeah, MonadLib has the arguments the right way, too. :)
18:11:38 <glguy> Prelude MonadLib> runId $ runStateT 0 $ runContT return $ callCC $ \ k -> (get >>= set . succ) >> k ()
18:11:38 <glguy> ((),1)
18:12:43 <popcorn> instance (ContM m) => ContM (StateT i m) where
18:12:43 <popcorn>   callCC f = S $ \s -> callCC $ \k -> runStateT s $ f $ \a -> lift $ k (a,s)
18:12:46 <popcorn> is from MonadLib
18:13:58 <popcorn> instance (MonadCont m) => MonadCont (StateT s m) where
18:13:58 <popcorn>     callCC f = StateT $ \s ->
18:13:58 <popcorn>         callCC $ \c ->
18:13:58 <popcorn>         runStateT (f (\a -> StateT $ \s' -> c (a, s'))) s
18:14:01 <mib_gi8n1o> trying to install cabal on ghc 6.4 and keep getting errors, is not working, can u guys guide me through the process?
18:14:06 <popcorn> is from ghc
18:14:44 <popcorn> how is this code written?
18:14:49 <popcorn> derived somehow...?
18:15:08 <ddarius> It's written the same way any other code is written.
18:15:10 <dolio> By hand.
18:15:28 <ddarius> Albeit, in the case of CPS it's implementation is often completely determined by the types.
18:16:15 <ddarius> @djinn ((a -> (b->r) -> r) -> r -> r) -> (a -> r) -> r
18:16:15 <lambdabot> -- f cannot be realized.
18:16:37 <ddarius> @djinn (((a -> (b->r) -> r) -> r) -> r) -> (a -> r) -> r
18:16:37 <lambdabot> -- f cannot be realized.
18:16:46 <ddarius> I never expand that one right
18:16:51 <ddarius> :t callCC
18:16:53 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
18:17:16 <ddarius> @djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
18:17:16 <lambdabot> f a b = a (\ c _ -> b c) b
18:17:39 <ddarius> @djinn a -> (a -> r) -> r
18:17:39 <lambdabot> f a b = b a
18:18:10 <ddarius> @djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
18:18:10 <lambdabot> f a b c = a (\ d -> b d c)
18:18:34 <ddarius> That's djinn deriving all of the Cont monad from the types.
18:19:20 <popcorn> hey
18:19:22 <popcorn> so
18:19:48 <popcorn> well it's (_ -> r) -> r instead of m a
18:19:51 <geezusfreeek> @pl f a b c = a (\ d -> b d c)
18:19:54 <lambdabot> f = (. flip) . (.)
18:20:08 <geezusfreeek> @pl f a b = a (\ c _ -> b c) b
18:20:09 <lambdabot> f = join . (. (const .))
18:20:16 <popcorn> does that mean the real version uses something other than function application in a few places?
18:20:27 <popcorn> what the equivalent would be nto sur
18:20:35 <mib_gi8n1o> does anyone know how to install cabal?
18:20:44 <dolio> @djinn Cont r a -> (a -> Cont r b) -> Cont r b
18:20:44 <mib_gi8n1o> in ghc 6.4
18:20:44 <lambdabot> f a b c = a (\ d -> b d c)
18:20:58 <geezusfreeek> mib_gi8n1o: why such an old version of ghc?
18:21:02 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
18:21:02 <lambdabot> f a b = a (\ c _ -> b c) b
18:23:47 <mib_gi8n1o> cause i have some packages that depend on it
18:23:50 <mib_gi8n1o> to run
18:24:05 <geezusfreeek> ah
18:24:14 <mib_gi8n1o> any help ?
18:24:28 <geezusfreeek> i didn't jump on the haskell bandwagon until 6.6, and i think cabal basically came with it at that point
18:24:48 <mib_gi8n1o> oh cool
18:24:51 <dolio> 6.4 is pretty old.
18:24:51 <mib_gi8n1o> i am doomed
18:25:05 <geezusfreeek> what packages are dependent on 6.4?
18:26:19 <mib_gi8n1o> wxhaskell
18:26:33 <geezusfreeek> i was under the impression that wxhaskell worked fine under ghc 6.8
18:26:40 <geezusfreeek> i haven't done it myself though
18:26:45 <mib_gi8n1o> and some very old graphic pack
18:27:00 <Saizan> mib_gi8n1o: what problems do you get when trying to install cabal on 6.4?
18:27:12 <mib_gi8n1o> nope it doesn't work, only if built from the source, don't have the time
18:27:33 <mib_gi8n1o> firstly i don't know how to do it
18:27:43 <mib_gi8n1o> so that's big prob
18:28:33 <Saizan> oh well, you can download the Cabal package on hackage, there should be instructions inside
18:28:38 <Saizan> ?hackage Cabal
18:28:39 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Cabal
18:28:39 <geezusfreeek> don't have the time to build what from source? wxhaskell? cabal? ghc?
18:29:05 <mib_gi8n1o> wxhaskell & ghc
18:29:13 <geezusfreeek> ah yeah, ghc takes a while
18:29:37 <geezusfreeek> there are binaries for it though
18:29:49 <geezusfreeek> i don't know how long wxhaskell takes, but surely it's not that long
18:30:55 <geezusfreeek> but yeah, sorry i'm not solving your immediate problem
18:31:03 <mib_gi8n1o> trust me, on this pc, it's half a day
18:31:49 <ddarius> That'd have to be a pretty freakin' old PC
18:32:03 <mib_gi8n1o> yeah
18:32:10 <mib_gi8n1o> my betsy
18:32:15 <TomMD> I'm in the same boat for the next month
18:32:41 <TomMD> GHC compile often never finishes (errors out due to hardware failure)
18:32:44 <dolio> Get dons to compile it for you on his 16-core box.
18:32:53 <geezusfreeek> hmm… cabal install wx seems to not work
18:33:02 <geezusfreeek> it configures and then craps out
18:33:09 <geezusfreeek> i was just seeing how long it would take
18:33:32 <geezusfreeek> oh, perhaps i don't have widgets install in the first place
18:33:33 <mib_gi8n1o> u showing off
18:33:38 * ddarius could build 5.4.3 on Win2k with 64MB of RAM and a Pentium 200 in about 6-8 hours and GHC 6.8.2 builds faster and the base libraries are much smaller.
18:43:19 <dino-> How would you define what an action is?
18:43:54 <edwardk> @src MonadFix
18:43:54 <lambdabot> class (Monad m) => MonadFix m where
18:43:54 <lambdabot>     mfix :: (a -> m a) -> m a
18:45:04 <dino-> Also, the word action does not describe things solely in the IO monad, yes?
18:45:23 <edwardk> hrmm, what would an appropriate type for ComonadFix's cofix ?
18:45:44 <dolio> (w a -> a) -> a ?
18:46:15 <edwardk> dolio: thats the obvious one, not sure if it should be a comonadic action though on the outside too, so you'd have w (w a -> a) -> a  allowing it to be extended
18:46:42 <dolio> Hmm. Could be.
18:46:44 <edwardk> coz i can bind the output of mfix
18:46:52 <edwardk> i should be able to cobind/extend the output of cofix
18:56:50 <edwardk> dolio: the above allows the use of cofix for (,)e so i think the w (w a -> a) -> a definition is the right one
18:57:51 <edwardk> @src fix
18:57:51 <lambdabot> fix f = let x = f x in x
18:58:42 <popcorn> > runIdentity (runCC (promptP $ \p -> (do x <- shiftP p (\k -> k (k (return 2))) ; return (x+1))))
18:58:43 <lambdabot>   Not in scope: `shiftP'
18:58:44 <edwardk> instance ComonadFix ((,)e) where cofix ~(e,f) = let x = f (e,x) in x
18:58:48 <popcorn> :(
18:59:06 <dolio> lambdabot doesn't have CC-delcont installed.
18:59:14 <dolio> Awesome as that would be.
19:00:00 <dolio> Actually, that's not even CC-delcont. That looks like oleg code using his version of it.
19:01:58 <popcorn> I don't think I'll ever understand continuations :(
19:02:37 <dolio> Oleg's Delimited Continuations in Operating Systems is very good, I think.
19:04:26 <dolio> Explains them in a way that's more familiar to most programmers, I imagine.
19:05:11 <SamB> dolio: have a link for it?
19:05:17 <popcorn> http://okmij.org/ftp/papers/context-OS.pdf
19:05:57 <SamB> @go Delimited Continuations in Operating Systems
19:05:58 <lambdabot> http://www.cs.rutgers.edu/~ccshan/zipper/context2007.pdf
19:06:17 <SamB> @go Delimited Continuations in Operating Systems citeulike
19:06:18 <lambdabot> No Result Found.
19:07:38 <dolio> More familiar than talking about holes left in syntax trees, for my money, at least.
19:08:00 <popcorn> hehe
19:08:50 <dolio> I think monadic style makes them easier, too, since you're explicit about evaluation order.
19:10:58 <dolio> Whereas in scheme, when you see stuff like '(+ 1 2 (shift k e) 4 5)' or whatever, it's less clear.
19:11:52 <popcorn> the one that really got lost is (cwcc cwcc)
19:12:21 <popcorn> (more specifically when you have two of those made at different times and fit them into each other)
19:13:12 <popcorn> really got me lost*
19:20:51 <edwardk> dolio: ah neat indexed state is a valid bifunctor
19:21:10 <dolio> It is?
19:21:15 <dolio> It's not a trifunctor? :)
19:21:22 <edwardk> bimap f g (IxState m) = IxState $ (g *** f) . m
19:21:27 <edwardk> its contravariant in the first argument
19:21:41 <dolio> Ah.
19:22:00 <dolio> That makes sense.
19:22:28 <edwardk> none of the indexed monads are trifunctors in the trivial haskell sense, if you go to the ugly bifunctors take 3 category arguments version then you can do something
19:22:44 <edwardk> i just thought it was nice that you could represent 'modify with 'first' =)
19:23:24 <edwardk> but its cleaner with the direct formulation
19:24:44 <edwardk> hrmm does that collapse to bimap f g = IxState . (g *** f) . runIxState ?
19:25:42 <edwardk> @pl \f g m -> IxState $ (g *** f) (runIxState m)
19:25:42 <lambdabot> ((IxState .) .) . flip flip runIxState . ((.) .) . flip (***)
19:25:44 <edwardk> nope
19:25:55 <edwardk> er
19:26:02 <edwardk> @pl \m -> IxState $ (g *** f) (runIxState m)
19:26:03 <lambdabot> IxState . (g *** f) . runIxState
19:26:08 <edwardk> oh yeah i guess it does
19:27:01 <agnokapathetic> http://hpaste.org/7449
19:27:12 <agnokapathetic> is there a way to specify an empty character?
19:27:12 <edwardk> @type liftM
19:27:14 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
19:27:18 <agnokapathetic> like ''?
19:29:09 <ddarius> agnokapathetic: Use concatMap
19:29:55 <ddarius> Alternatively, you could filter then map
19:30:05 <geezusfreeek> @type \st -> runST st
19:30:08 <lambdabot>     Inferred type is less polymorphic than expected
19:30:08 <lambdabot>       Quantified type variable `s' is mentioned in the environment:
19:30:08 <lambdabot>         st :: ST s a (bound at <interactive>:1:1)
19:30:17 <geezusfreeek> how exactly am i supposed to use runST?
19:30:31 <geezusfreeek> it seems like i can't use it for anything at all
19:30:34 <ddarius> runST somecomputation
19:30:47 <geezusfreeek> why did the above typecheck fail?
19:30:48 <agnokapathetic> ddarius: but a filter would only remove unwanted characters, rather than replacing them with spaces?
19:30:54 <agnokapathetic> oh
19:30:56 <agnokapathetic> never mind.
19:30:59 <agnokapathetic> i understand
19:31:01 <agnokapathetic> thank you
19:31:25 <ddarius> geezusfreeek: Because lambda bound variables are monomorphic.
19:32:05 <geezusfreeek> let me put this differently… anything in the ST monad is typed as ST s a, right?
19:32:15 <geezusfreeek> i'm not supposed to specify s, right?
19:32:55 <ddarius> Correct.
19:33:52 <geezusfreeek> but typing the above function as f :: ST s a -> a would be incorrect? if so, what would be the correct way to achieve that sort of function?
19:34:07 <ddarius> :t runST
19:34:09 <lambdabot> forall a. (forall s. ST s a) -> a
19:35:00 <geezusfreeek> using the existential doesn't change anything for me, unfortunately
19:35:08 <geezusfreeek> not that it would make sense
19:35:42 <ddarius> That universal quantification (though it is equivalent [at least classically] to exists s. ST s a -> a
19:35:45 <ddarius> )
19:35:52 <geezusfreeek> right
19:36:18 <Elly> how does one convert an integer to a string?
19:36:22 <ddarius> show
19:36:47 <Elly> thanks :)
19:36:59 <geezusfreeek> the problem just seems to be that i can't figure out a single case in which runST actually compiles…
19:37:12 <geezusfreeek> which means i must be misunderstanding something fundamental about rank-2 types
19:37:26 <ddarius> runST somecomputation will work fine.
19:37:34 <ddarius> Don't write runST $ somecomputation
19:37:44 <geezusfreeek> OH
19:38:27 <geezusfreeek> err, removing ($) still didn't change anything though
19:38:42 <geezusfreeek> okay lemme decontextualize my code and paste it
19:39:10 <luqui> How do I tell cabal to generate a link for the source code?
19:39:19 <luqui> And is it possible for this to happen on hackage?
19:40:03 <geezusfreeek> okay, an example of a failing line of code that i'm trying to use: someFunction stateT = fst . runST (runStateT stateT minBound)
19:40:54 <geezusfreeek> where the stateT is of type Bounded t => StateT t (ST s) a or somesuch like that
19:41:26 <conal> luqui: i use ./setup haddock --hyperlink-source --hscolour-css=$(hscolour-css)
19:41:45 <geezusfreeek> well, except i wouldn't have normally used composition there but i had ($) instead of parens before, so
19:41:46 <conal> luqui: where $(hscolour-css) is set in a makefile include
19:42:00 <popcorn> (stole this from Oleg http://rafb.net/p/snQYGG11.txt )
19:43:22 <ddarius> geezusfreeek: That code is not type correct.
19:43:32 <geezusfreeek> that's what ghci tells me ;)
19:43:34 <luqui> conal, hm, okay.  I'll look a bit more to see if I can get that in the .cabal file or something for hackage
19:44:12 <geezusfreeek> okay i have a StateT on top of ST s. how would i run it?
19:44:44 <geezusfreeek> this is my noob moment i guess
19:44:52 <geezusfreeek> i thought i was done with those
19:45:04 <mwc> @type runStateT
19:45:06 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
19:45:08 <conal> luqui: i don't know a way to stash those options in a .cabal
19:45:24 <dons> runIt st (ItT x) = runStateT (runST x) st
19:45:25 <dons> or something
19:45:34 <mwc> geezusfreeek: you use {run,exec,eval}StateT to get an ST action, then you bind taht action in an ST monad
19:45:46 <ddarius> runStateTST :: state -> StateT state (ST s) a -> (a,state); runStateTST statet initialState = runST (runStateT statet initialState)
19:45:55 <mwc> bar <- runStateT foo state
19:45:56 <mwc> yeah
19:46:40 <dolio> Needs a forall s, I think.
19:48:22 <geezusfreeek> @type \statet initialState -> runST (runStateT statet initialState)
19:48:24 <lambdabot>     Inferred type is less polymorphic than expected
19:48:24 <lambdabot>       Quantified type variable `s' is mentioned in the environment:
19:48:24 <lambdabot>         statet :: StateT s1 (ST s) a (bound at <interactive>:1:1)
19:48:44 <ddarius> :t let f st is = runST (runStateT st is) in f
19:48:46 <lambdabot>     Inferred type is less polymorphic than expected
19:48:46 <lambdabot>       Quantified type variable `s' is mentioned in the environment:
19:48:46 <lambdabot>         st :: StateT s1 (ST s) a (bound at <interactive>:1:6)
19:49:08 <ddarius> I believe dolio is right, but the expression will work directly.
19:49:15 <dolio> state -> (forall s. StateT state (ST s) a) -> (a,state)
19:49:38 <geezusfreeek> it still fails to type check even with the forall
19:49:52 <geezusfreeek> although over here it complains about an infinite type
19:50:22 <geezusfreeek> trying to bind state = StateT (. (forall s) (StateT state (ST s) a)) (ST s1) a1
19:50:31 <geezusfreeek> which is a mess…
19:51:05 <dolio> Are you using -XRank2Types?
19:51:25 <dolio> That looks like it's getting confused by the forall syntax.
19:51:51 <geezusfreeek> oops i was using the wrong flags
19:52:00 <geezusfreeek> but now it's state = StateT (StateT state (ST s1) a) (ST s) a1
19:52:38 <koninkje> Does GHC have any sort of rtti extensions? i.e. I'm trying to write a single function :: a -> (forall b. b) -> c where the value returned depends on the second input type.
19:53:07 <conal> koninkje: Dynamic
19:53:12 <ddarius> let f :: (forall s. StateT Int (ST s) a) -> (a,Int); f m = runST (runStateT m 0) works fine in GHCi
19:53:13 <conal> @hoogle Dynamic
19:53:13 <lambdabot> Data.Dynamic :: module
19:53:13 <lambdabot> Data.Dynamic.Dynamic :: data Dynamic
19:53:13 <lambdabot> Data.Dynamic.fromDynamic :: Typeable a => Dynamic -> Maybe a
19:53:28 <ddarius> @hoogle Typeable
19:53:28 <lambdabot> Data.Typeable :: module
19:53:29 <lambdabot> Data.Typeable.Typeable :: class Typeable a
19:53:29 <lambdabot> Data.Typeable.Typeable1 :: class Typeable1 t
19:54:03 <koninkje> conal: I was wondering if Dynamic was the only way, guess I'll have to use it afterall
19:54:08 <koninkje> thanks
19:54:48 <geezusfreeek> ddarius: yay, something that type checks!
19:55:51 <koninkje> geezusfreeek: What's your goal? (the typecheck failure is the source of the security of ST)
19:56:21 <geezusfreeek> koninkje: i'm doing anything weird. this is working fine for me now
19:56:24 <geezusfreeek> *i'm not
19:56:47 <geezusfreeek> i think it was mainly that i forgot Rank2Types, and then i just further confused myself
20:02:47 <edwardk> @unpl \f g -> IxState . ((g *** f).) . runIxState
20:02:47 <lambdabot> \ f g d -> (IxState) (\ l -> (g *** f) (runIxState d l))
20:04:05 <edwardk> @pl \m -> IxState $ (g *** f) . runIxState m
20:04:05 <lambdabot> IxState . ((g *** f) .) . runIxState
20:04:11 <edwardk> gah nm
20:04:47 <dolio> curry $ IxState . (g *** f) . uncurry runIxState
20:05:11 <edwardk> dolio: it works but it is harder for someone to figure out what is going on
20:05:20 <dolio> Yeah.
20:05:21 <edwardk> i think i'll stick to the fairly naive translation
20:06:41 <dolio> @type \in out f g -> curry $ uncurry out >>> f *** g >>> in
20:06:43 <lambdabot> parse error on input `in'
20:06:49 <dolio> Bah.
20:08:14 <edwardk> i think i finally got category extras to compile cleanly under -Wall (modulo the two orphan instances that I can't fix no matter what i do because they are for Either)
20:08:51 <dolio> Heh. Congratulations.
20:08:58 <dolio> @type let infixr 0 |> ; x |> f = f x in \inn out f g -> uncurry out >>> f *** g >>> inn |> curry
20:09:00 <lambdabot> forall a b b1 c b' c' d. ((c, c') -> d) -> (a -> b -> (b1, b')) -> (b1 -> c) -> (b' -> c') -> a -> b -> d
20:09:09 <edwardk> i only had to move half of the instances into other files no big deal =)
20:09:56 <edwardk> packaging it up into a source dist
20:10:06 <edwardk> then i'll starrt hacking away on it again
20:20:10 <Apocalisp> What's the equivalent of fmap for fold?
20:20:35 <edwardk> Apocalisp: "cata"
20:20:47 <Apocalisp> @src cata
20:20:47 <lambdabot> Source not found. :(
20:20:49 <edwardk> its not in a standard lib though
20:20:59 <Apocalisp> What about Data.Foldable.fold?
20:21:08 <edwardk> that'd work =)
20:21:12 <edwardk> @src Data.Foldable.fold
20:21:12 <lambdabot> Source not found. Are you on drugs?
20:21:13 <dolio> There's Data.Foldable.foldr.
20:21:22 <edwardk> @src Data.Foldable.foldr
20:21:22 <lambdabot> Source not found. Where did you learn to type?
20:21:34 <dolio> Which isn't exactly cata, but it's all right.
20:21:52 <Apocalisp> Sounds like a plan
20:22:12 <dolio> Data.Foldable.fold is actually a generalized mconcat.
20:23:53 <SpyToreX> #Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#
20:23:53 <SpyToreX> #Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#
20:23:58 <SpyToreX> #Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#
20:24:07 <Elly> that was eloquent
20:24:14 <geezusfreeek> to the point
20:24:15 <dancor> should have used \bot
20:24:22 <popcorn> > replicate "#Girl"
20:24:23 <lambdabot>  Couldn't match expected type `Int' against inferred type `[Char]'
20:24:27 <popcorn> bah :P
20:24:35 <geezusfreeek> > cycle "#Girl"
20:24:37 <lambdabot>  "#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl...
20:24:58 <popcorn> > fun . cycle $ "#Girl"
20:24:58 --- mode: ChanServ set +o dons
20:24:59 <lambdabot>  Add a type signature
20:25:02 --- mode: dons set +b *!*n=Beyaz@88.238.98.*
20:25:03 --- kick: SpyToreX was kicked by dons (dons)
20:25:06 <edwardk> Is there any way to disable the warning: "'ghc-options: -O2' is rarely needed. Check that it is giving a real benefit"
20:25:14 <Apocalisp> Better than #Spam#Spam#Spam#Spam#Spam
20:25:28 <Spark> #Badger#Badger#Badger#Badger#Badger
20:25:35 <geezusfreeek> heh
20:25:37 <edwardk> #Mushroom#Mushrom
20:25:39 <dancor> it was more like thunk (spam)
20:29:21 <luqui> :t fun
20:29:23 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
20:29:50 <luqui> > fun "3+4" :: Int
20:29:51 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr Int)
20:29:51 <lambdabot>     In th...
20:30:11 <popcorn> > fun . cycle $ "#Girl" :: Expr
20:30:13 <lambdabot>  #Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#Girl#...
20:30:21 <popcorn> that's what I meant to do
20:31:19 <popcorn> this zipper os thing is crazy\
20:35:56 <Apocalisp> looks pretty cool
20:54:32 <jberryman> I wish the symbol for function application was something quieter than $
20:54:57 <jberryman> like a backquote or something?
20:55:41 <edwardk> i'm personally rather fond of !, because you can then drop the 'bar' part of it to get . so foo ! bar ! baz -> foo . bar ! baz at least shows a resemblance to each other
20:58:57 <jberryman> yeah that's nice
20:58:57 <luqui> edwardk, well you can drop the S and the | and you get the normal symbol for function application
20:59:13 <edwardk> luqui: =)
21:01:59 <jberryman> has anyone played with laying out haskell code in sort of two dimensions on the page
21:02:17 <luqui> jberryman, you mean like Text.PrettyPrint, or like epigram?
21:02:27 <Apocalisp> What would you use foldr for on Maybe?
21:03:13 <luqui> Apocalisp, foldr on Maybe = maybe (?), is that what you mean?
21:03:18 <edwardk> jberryman: well if you take pointfree notation and you drop it on a page with points at each of the '.'s in your pointfree notation, and label each arrow with the function, and each point with the type you get very close to standard category theory diagrams =)
21:03:26 <luqui> (?) not a binary operator, but a possible question
21:03:34 <edwardk> jberryman: but i'm guessing you meant more like luqui is talking about
21:04:11 <dmwit> Apocalisp: Can you maybe rephrase that?
21:04:42 <Apocalisp> Maybe.
21:04:48 <edwardk> Apocalisp: its there as a sort of degenerate case of the traversable/foldable stuff
21:04:54 <edwardk> it can be traversed, so its included
21:05:09 <edwardk> its not as simple as, say, identity, but its down there =)
21:05:39 <luqui> never underestimate the power of trivial instances
21:06:03 <edwardk> they make great base cases
21:06:17 <geezusfreeek> dang now i'm hitting this: http://www.mail-archive.com/haskell@haskell.org/msg18189.html
21:06:23 <lambdabot> Title: RE: [Haskell] Pattern Matching with rank-2 types
21:08:07 <jberryman> edwardk: been googling all those items :) I guess what I mean is aranging your functions not simply from top to bottom, but maybe in a tree shape, or something that reflects the structure better
21:08:50 <jberryman> like if function 'a' refers to 'b' and 'c', you could have:
21:08:55 <jberryman> a = ...
21:09:05 <jberryman> b =...    c=...
21:09:10 <edwardk> jberryman: well, thats kinda what that is you get a diagram and you start at one side and the arrows represent the computation steps involved.
21:09:21 <edwardk> you might also be interested in looking at something like 'subtext'
21:09:35 <edwardk> its not haskell, but the graphical layout bit is pretty much there
21:12:05 <jberryman> thanks, maybe I could write a parser that will allow me to layout code the way i described
21:12:28 <jberryman> when I learn a bit more; I'm sure it would be trivial for most of you
21:13:04 <zgold> Hey, whats that 3 letter "make this strict" function called?
21:13:14 <edwardk> @type seq
21:13:17 <lambdabot> forall a t. a -> t -> t
21:13:20 <zgold> Thanks :)
21:13:33 <edwardk> that sounded, retroactively like a homework question
21:13:48 <zgold> The homework is about 1000 lines of code
21:13:55 <zgold> forgetting a 3 letter function is pretty innocent :)
21:14:02 <edwardk> heh
21:14:38 <zgold> thanks edwardk
21:15:54 <zgold> does readFile lock the file in question?
21:20:02 <dolio> 1000 lines of haskell for a homework assignment?
21:20:44 <geezusfreeek> i have a newtype MyType s t a = MyType (StateT t (ST s) a), and also a working function runStateTST :: Bounded t => (forall s. StateT t (ST s) a) -> (a, t), but it seems that i cannot make a function runMyType :: Bounded t => (forall s. MyType s t a) -> (a, t) which extracts the inner stateT from the MyType and applies runStateTST to it.
21:20:45 <geezusfreeek> apparently from http://www.mail-archive.com/haskell@haskell.org/msg18189.html it couldn't be done at least as of GHC 6.4.1. i really want to hide the structure of MyType, so i don't want to just make a type alias. is there anything else i could do?
21:20:45 <lambdabot> Title: RE: [Haskell] Pattern Matching with rank-2 types
21:20:52 <luqui> 1000 lines of haskell is a lot of haskell for a pro
21:21:11 <luqui> jberryman, I wouldn't say "trivial".  I think the word is "fun".
21:23:58 <dolio> What's your definition of runMyType?
21:25:20 <geezusfreeek> it extracts with a pattern match (seems to be the problem) and applies runStateTST… so something like runMyType (MyType stateTST) = runStateTST stateTST
21:26:38 <geezusfreeek> it gives me "Couldn't match expected type `forall s. MyType s t a' against inferred type `MyType s t1 a1'
21:27:28 <dolio> Write an 'unMyType (MyType s) = s'.
21:27:42 <dolio> And then 'runMyType m t = runST (runStateT (unMyType m) t)'
21:27:49 <zgold> its a final project
21:27:54 <zgold> worth almost half of the course grade
21:28:08 <zgold> but yeah, we're near 1000 lines
21:28:09 <gwern> @wn perspicuous
21:28:10 <lambdabot> *** "perspicuous" wn "WordNet (r) 2.0"
21:28:10 <lambdabot> perspicuous
21:28:10 <lambdabot>      adj : (of language) transparently clear; easily understandable;
21:28:10 <lambdabot>            "writes in a limpid style"; "lucid directions"; "a
21:28:10 <lambdabot>            luculent oration"- Robert Burton; "pellucid prose"; "a
21:28:12 <lambdabot> [3 @more lines]
21:28:54 <gwern> @wn perspicacious
21:28:55 <lambdabot> *** "perspicacious" wn "WordNet (r) 2.0"
21:28:55 <lambdabot> perspicacious
21:28:55 <lambdabot>      adj 1: acutely insightful and wise; "much too perspicacious to be
21:28:55 <lambdabot>             taken in by such a spurious argument"; "observant and
21:28:55 <lambdabot>             thoughtful, he was given to asking sagacious
21:28:55 <geezusfreeek> wtf, i thought i had already tried that
21:28:56 <lambdabot> [7 @more lines]
21:28:59 <geezusfreeek> but it worked this time
21:29:04 <geezusfreeek> dolio: thanks
21:29:05 <dolio> :)
21:29:15 <geezusfreeek> seriously… i had tried that!
21:29:29 <geezusfreeek> something else must have been wrong
21:30:05 <edwardk> dolio: the scariest kind annotation i've ever seen: class HComposition (c :: ((* -> *) -> * -> *) -> ((* -> *) -> * -> *) -> ((* -> *) -> * -> *)) where hcompose :: f (g x) a ->  c f g x a
21:30:21 <dolio> Wow.
21:30:35 <edwardk> the composition of two higher order functors
21:31:04 <edwardk> of course ghc doesn't have enough info to intuit the kind so i had to hand mangle it
21:31:18 <geezusfreeek> wow
21:32:08 <geezusfreeek> i am not familiar enough with category theory to fully appreciate that, i don't think, but i do see that it is scary
21:32:31 <edwardk> the nice thing about it was that the definition for HFunctor for that composition just worked first try =)
21:33:07 <edwardk> geezusfreeek: the basic idea is take a functor and make it apply to 'functors' instead of values. then of course once you have that build up all the regular machinery over functors over these higher order ones
21:33:26 <geezusfreeek> this is types, not kind annotations, but i think this is pretty scary anyway: http://hackage.haskell.org/packages/archive/sessions/2008.2.28/doc/html/Control-Concurrent-Session.html
21:33:27 <lambdabot> http://tinyurl.com/6dhwft
21:33:32 <edwardk> so you can have higher order monads, comonads, and in this case functor composition
21:33:42 <edwardk> yeah sessions have crazy types =)
21:34:09 <edwardk> i had just never needed a dozen *'s in a single kind annotation before
21:35:37 * Heffalump appears
21:37:21 <ddarius> data F a b c d e f g h i j k l m n o p = F
21:37:37 <edwardk> ddarius: =)
21:37:51 <edwardk> ddarius: yeah but it infers those all as * -> * -> ... * no? =)
21:38:18 <ddarius> edwardk: It assumes they, are yes
21:38:30 <ddarius> If they aren't, an explicit annotation will need to be provided.
21:39:03 <edwardk> and after all that i don't seem to be able to figure out the definition for ffmap for CompH =(
21:41:20 <orbitz> what are otherways to create an object heirarchy (such as exceptions) than classes?
21:41:43 <gwern> @wn ninnyhammer
21:41:43 <lambdabot> No match for "ninnyhammer".
21:41:52 <gwern> @wn ninny
21:41:53 <lambdabot> *** "ninny" wn "WordNet (r) 2.0"
21:41:53 <lambdabot> ninny
21:41:53 <lambdabot>      n : a stupid foolish person [syn: {nincompoop}, {poop}]
21:43:17 <edwardk> aha
21:46:08 <gwern> @wn axillism
21:46:09 <lambdabot> No match for "axillism".
21:46:22 <gwern> useless
21:51:57 <gwern> @wn fussock
21:51:57 <lambdabot> No match for "fussock".
21:56:38 <gwern> @wn braggadocio
21:56:39 <lambdabot> *** "braggadocio" wn "WordNet (r) 2.0"
21:56:39 <lambdabot> braggadocio
21:56:39 <lambdabot>      n : vain and empty boasting [syn: {bluster}, {rodomontade}, {rhodomontade}]
21:57:28 <edwardk> I had to define a functor that took a higher order functor and dumbed it down, then: ffmap f = hcompose . hfmap liftH . ffmap f . hfmap LowerH . hdecompose -- was valid
21:58:19 <edwardk> since moving in and out of that valid Functor instance could be done through the natural transformations LowerH and liftH making haskell happy
22:06:15 <OceanSpray> what are sum and product types?
22:07:04 <edwardk> the short answer is that sum types are like 'Either' product types are like (,)
22:08:53 <OceanSpray> what's a good book to learn type theory from?
22:09:10 <edwardk> types and programming languages by benjamin pierce
22:09:18 <edwardk> thats probably the best starting point out there
22:09:44 <OceanSpray> wow, heard so many good things about that book already.
22:09:51 <OceanSpray> It must be really well written.
22:09:57 <edwardk> it is =)
22:10:57 <edwardk> The recommendations on http://www.cis.upenn.edu/~bcpierce/tapl/ read kind of like a 'who's who' of type theory
22:10:58 <lambdabot> Title: Types and Programming Languages
22:11:03 <geezusfreeek> seconded for TaPL
22:11:34 <OceanSpray> I recognize Milner and Reynolds.
22:11:43 <OceanSpray> Who are the other two?
22:12:09 <edwardk> henk berendregt basically came up with the 'lambda cube'
22:13:57 <geezusfreeek> which isn't covered until ATTaPL
22:13:58 <dolio> Man, CMU has some sexy courses.
22:14:03 <edwardk> bob harper has been around so long its hard to point to any one thing and say that his major contribution but has written a half dozen books and written a ton of papers: http://www.cs.cmu.edu/~rwh/papers.htm
22:14:03 <lambdabot> Title: Papers
22:14:27 <dolio> (The ones listed on Robert Harper's page, that is.)
22:15:15 <OceanSpray> hey, I'm going there!
22:15:26 <dolio> Lucky.
22:15:31 <geezusfreeek> i'm jealous already
22:15:36 <edwardk> dolio: feel like pulling a new version of category-extras from my darcs repo and seeing if it builds clean for you in a sec?
22:15:51 <dolio> All right. Let me know when.
22:16:46 <edwardk> rebuilding, and packaging, one sec
22:18:05 <edwardk> ok should be patched
22:19:02 <edwardk> major new stuff are higher order adjunctions and higher order functor composition, and a ton of shuffling and adding explicit exports to everything
22:20:28 <dolio> Looks good. Just the orphan instance complaints about Either.
22:20:34 <edwardk> nice
22:21:00 <edwardk> going to drop it on hackage then and call it a night i think
22:21:16 <dolio> All right.
22:21:24 <edwardk> the nice thing is modulo a couple of things the higher order cases are looking very very straightforward
22:21:40 <edwardk> but as usual given haskell you never see all the pain that went into deriving the clean concepts ;)
22:22:27 <edwardk> i also bit the bullet and followed your suggestion, so there is a Functor => Pointed => Applicative => Monad chain and a Functor => Copointed => Comonad chain
22:22:56 <dolio> :)
22:23:39 <edwardk> i'll drop instances into control.functor.pointed for all the mtl monads
22:23:48 <OceanSpray> I have no idea what you guys are talking about,
22:23:53 <OceanSpray> and it makes me sad.
22:24:08 <dolio> Is '9' commonly used in lieu of \exists?
22:24:16 <lament> OceanSpray: shopping
22:24:48 <edwardk> also saizan pointed out there was a universal quantification over "i" in the type for shift for delimited continuations in the original presentation that was dropped by oleg to make his version haskell 98. since nothing else here is, i added it back in for safety
22:25:28 <sanity> can anyone recommend a good book on haskell for a programmer new to haskell, but familiar with ML?
22:25:34 <dolio> Okay. I actually pulled that out of my agda delimited continuations, but I don't remember where I got that from.
22:25:48 <dolio> I think I cobbled it together out of an old Wadler paper and the idea of indexed monads.
22:26:17 <edwardk> fair nuff. i still need to bundle up a callCC and some things for that version of cont anyways
22:27:03 <edwardk> if nothing else i'm building up a zoo of pretty types =)
22:28:20 <edwardk> i'm also tempted to universally replace the 'P' prefix with 'Bi' even though its not quite correct, for symmetry.
22:29:27 <edwardk> So PPointed -> Bipointed, PCopointed -> Bicopointed, PComonad -> Bicomonad to indicate they are the same construction with an extra type parameter and that they are all build over bifunctors
22:29:42 <edwardk> because its not at all clear that a pointed bifunctor is ppointed.
22:30:55 <edwardk> either that or MonadB, PointedB, CopointedB to go with the B suffixed bifunctors i have elsewhere
22:53:52 <dcoutts> conal: re: "--hscolour-css=$(hscolour-css)". If you only want the default .css then you don't need to specify anything, so long as you have a recent HsColour that knows about the default css. If you want to use a non-default and use the same every time then you can stash the option in the ~/.cabal/config if you're using cabal-install. If you want a different one for each project you can keep doing what you're doing now.
22:54:40 <dcoutts> conal: It's not really an appropriate option to stick in the .cabal file since it's not a property of the package so much as they way in which you're locally choosing to configure/use it.
22:55:39 <dcoutts> conal: but maybe that tells us there is a need for a persistent way to keep per-package configuration.
22:56:09 <quicksilver> unless it's a feature of the package than its source, when viewed with the correct hscolour script, contains a secret message!
22:56:19 <quicksilver> then the hscolour config does belong to the package.
22:57:17 <dcoutts> :-)
22:58:16 <quicksilver> maybe it's source, when viewed correctl with hscolour, is simultaneously a piet ( http://www.dangermouse.net/esoteric/piet.html ) program?
22:58:16 <lambdabot> Title: DM's Esoteric Programming Languages - Piet
22:58:32 <quicksilver> piet rocks!
23:57:34 <dolio> @yow!
23:57:35 <lambdabot> On the road, ZIPPY is a pinhead without a purpose, but never without a POINT.
