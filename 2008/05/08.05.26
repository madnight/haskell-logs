00:03:39 <arw__> Plareplane: i have no idea how one would do that in haskell since i'm very new to the language, but from a previous experience with the same problem in perl:
00:04:57 <arw__> Plareplane: you need one thread which only does UI stuff, if other threads need to push values to the ui or get values / events from there you have to map that to communication of those threads with your UI thread.
00:07:05 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/7894
00:37:20 <cinimod> I've just built ghc. Is there a way of invoking ghci without having to install? I know you can do ghc-inplace.
00:48:03 <bos> @hoogle poke
00:48:04 <lambdabot> Foreign.Storable.poke :: Storable a => Ptr a -> a -> IO ()
00:48:04 <lambdabot> Foreign.Storable.pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()
00:48:04 <lambdabot> Foreign.Storable.pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
01:45:41 <Nyenburgh_> :t abs
01:45:43 <lambdabot> forall a. (Num a) => a -> a
01:45:58 <mxc> @hoogle abs
01:45:59 <lambdabot> Prelude.abs :: Num a => a -> a
01:45:59 <lambdabot> Distribution.Simple.InstallDirs.absoluteInstallDirs :: PackageIdentifier -> PackageIdentifier -> CopyDest -> InstallDirTemplates -> InstallDirs FilePath
01:45:59 <lambdabot> Distribution.Simple.LocalBuildInfo.absoluteInstallDirs :: PackageDescription -> LocalBuildInfo -> CopyDest -> InstallDirs FilePath
02:01:10 <mxc> when using Either, the convention is that Left a is for errors and Right b is a correct value correct?
02:01:19 <opqdonut> yep
02:01:29 <opqdonut> the monad instance uses that, for example
02:02:10 <qebab> opqdonut: a much better answer would have been Right "yes" ):
02:02:16 <opqdonut> :P
02:02:21 <opqdonut> Left "it depends"
02:02:24 <luqui> mxc, it's ever so slightly more than a convention
02:02:53 <luqui> since there is a monad instance for it, and you can't make a monad instance of "flip Either"
02:02:54 <opqdonut> yeah it's pretty useful since the error type usually stays the same but result values change
02:02:58 <opqdonut> the order ... echo
02:03:11 <opqdonut> partially applying is useful, yes
02:20:26 <mxc> :t (>>=)
02:20:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:22:08 <mxc> where is the Either monad defined?
02:22:19 <mxc> is Control.Monad.Error?
02:23:54 <vixey> all you need is (>>=)
02:24:23 <maltem> "bind, not love"?
02:25:18 <mxc> so something like eitherReturningFxn >>= eitherUsingFxn should work then?
02:25:51 <mxc> but, in the docs, Either isn't listed as an instance of monad
02:28:06 <sioraiocht> @instance Either
02:28:06 <lambdabot> Maybe you meant: instances instances-importing
02:28:11 <sioraiocht> @instances Either
02:28:11 <lambdabot> Couldn't find class `Either'. Try @instances-importing
02:28:19 <sioraiocht> @instances Monad
02:28:20 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
02:28:39 <mxc> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#t%3AMonad
02:28:40 <lambdabot> http://tinyurl.com/y25qsm
02:28:45 <sioraiocht> @src (>>=) Either
02:28:45 <lambdabot> Source not found. :(
02:28:52 <sioraiocht> @src Either (>>=)
02:28:53 <lambdabot> Left  l >>= _ = Left l
02:28:53 <lambdabot> Right r >>= k = k r
02:29:10 <mxc> right thats how I thought it worked
02:29:14 <mxc> thanks, must be some other issue
02:40:56 <mix25> There is func in haskell that construct all posible list if recieve list like a parameter of something ... ?
02:41:24 <mix25> with length n/2 +1  if list is [1..n]
02:44:27 <Heffalump> huh?
02:44:49 <mix25> for example : [1..3] = [[1,2],[2,3],[3,1]]
02:45:03 <buff_dri1kslot> aah permutations
02:47:14 <luqui> mix25, there is none in the standard library.  it's not terribly hard to write on your own, but not completely trivial either
02:47:37 <Deewiant> > filter (\x -> nub x == x) . nub . map sort . mapM (const [1..3]) $ [1..2] :: [[Int]]
02:47:38 <lambdabot>  [[1,2],[1,3],[2,3]]
02:47:48 <luqui> Deewiant, now how about without Eq
02:47:55 <Deewiant> :-)
02:48:07 <Deewiant> and how about generalizing that further
02:48:18 <Deewiant> you'll note the last list is [1..2], not [1..3] :-)
02:48:39 <luqui> heh, cheater :-)
02:51:07 <mix25> ahym
02:52:09 <luqui> mix25, why do you need it?
02:52:21 <luqui> (just curious)
02:53:23 <glguy> looks like what he described were combinations rather than permutations
02:54:07 <luqui> indeed.
02:54:11 <mix25> I have homework from university and i have not much idea of haskell , i never studied before and now is very dificult make this homework for me
02:54:48 <dancor> wait do you want like [1..n] -> [(1,2),(2,3),(3,4),..,(n-1,n)]
02:55:07 <mix25> [11:41:27] <mix25> with length n/2 +1
02:56:07 <dancor> powerset elements of length 2?
02:56:43 <mix25> example : list [1..3] perms of list with length 3/2 + 1 = 2
02:56:53 <dancor> powerList [] = [[]]
02:56:53 <dancor> powerList (x:xs) = l ++ map (x:) l where l = powerList xs
02:57:32 <dancor> f = filterBy ((== 2) . length) . powerList
02:57:45 <dancor> (not most efficient, but most general imho)
02:58:35 <mix25> yes i have some idea now :)
02:59:44 <xerox> > nub . map sort . (\xs -> [ [x,y] | x <- xs, y <- xs, x /= y ]) $ [1,2,3]
02:59:47 <lambdabot>  [[1,2],[1,3],[2,3]]
03:00:30 <mix25> > nub . map sort . (\xs -> [ [x,y] | x <- xs, y <- xs, x /= y ]) $ [1,2,3,4]
03:00:31 <lambdabot>  [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
03:00:58 <xerox> > (\xs -> [ (x,y) | x <- xs, y <- xs, x < y ]) $ [1,2,3]
03:00:59 <lambdabot>  [(1,2),(1,3),(2,3)]
03:01:29 <xerox> !
03:01:56 <xerox> it's the order relation <
03:02:15 <xerox> on the set [1..n]
03:02:24 <mix25> i see
03:02:38 <luqui> > (\xs -> [ (x,y,z) | x <- xs, y <- xs, z <- xs, x < y, y < z ]) [1,2,3,4]
03:02:40 <lambdabot>  [(1,2,3),(1,2,4),(1,3,4),(2,3,4)]
03:03:18 <luqui> quite nice xerox
03:03:23 <xerox> yeah right!
03:03:46 <luqui> nah, I think it gives a clear picture of what to generalize
03:04:36 <luqui> (even though i've been struggling myself to write this function in an unconstrained, (!!)-free list way)
03:10:56 <vixey> > let those 0 _ = [[]] ; those n list = do (x:xs) <- tails list ; map (x:) (those (n-1) xs) in those 3 (sort [1,2,3,4,5])
03:10:57 <lambdabot>  [[1,2,3],[1,2,4],[1,2,5],[1,3,4],[1,3,5],[1,4,5],[2,3,4],[2,3,5],[2,4,5],[3,...
03:12:46 <luqui> yeah, just do his homework for him why don't ya
03:13:00 <vixey>  <luqui> (even though i've been struggling myself to write this function in an unconstrained, (!!)-free list way)
03:13:10 <vixey> luqui: I didn't know you were doing this as homework
03:13:20 <luqui> I am not, the original asker was
03:13:37 <luqui> and I just got it as you posted, though my solution is quite different from yours.
03:13:44 <vixey> what's yours?
03:15:06 <luqui> lol, actually it's almost identical
03:15:19 <vixey> @src foldM
03:15:19 <lambdabot> foldM _ a []     = return a
03:15:19 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
03:15:28 <hpaste>  luqui pasted "(no title)" at http://hpaste.org/7895
03:16:13 <vixey> @do f a x >>= \fax -> foldM f fax xs
03:16:14 <lambdabot> f a x >>= \fax -> foldM f fax xs not available
03:16:24 <vixey> @undo do (x:xs) <- tails list ; map (x:) (those (n-1) xs)
03:16:24 <lambdabot> tails list >>= \ a -> case a of { (x : xs) -> map (x :) (those (n - 1) xs); _ -> fail ""}
03:16:29 <Deewiant> @redo f a x >>= \fax -> foldM f fax xs
03:16:30 <lambdabot> do { fax <- f a x; foldM f fax xs}
03:16:51 <vixey> I guess I can't rewrite those using foldM then
03:17:51 <luqui> yeah, it's "zip-like" recursive, so folds are no good
03:26:40 <dolio> You can write zip with foldr.
03:28:28 <luqui> dolio, demonstrate?
03:28:44 <dolio> Heh, it's going to take me a few minutes...
03:28:59 * luqui attempts as well
03:36:38 <dolio> let ip' as bs = foldr (\a bsToabs bs@(~(b:bt)) -> foldr (\_ _ -> (a,b):bsToabs bt) [] bs) (const []) as bs in (zip' [1,2,3] [4,5,6], zip' [1,2,3,4] [5,6,7], zip' [1,2,3] [4,5,6,7])
03:36:48 <dolio> > let zip' as bs = foldr (\a bsToabs bs@(~(b:bt)) -> foldr (\_ _ -> (a,b):bsToabs bt) [] bs) (const []) as bs in (zip' [1,2,3] [4,5,6], zip' [1,2,3,4] [5,6,7], zip' [1,2,3] [4,5,6,7])
03:36:49 <lambdabot>  ([(1,4),(2,5),(3,6)],[(1,5),(2,6),(3,7)],[(1,4),(2,5),(3,6)])
03:39:03 <luqui> impressive
03:39:15 <kaol> I wish I could do IO inside Data.Map.update's function... I can't see how I could avoid doing a lookup twice
03:39:52 <dcoutts_> need a Data.Map zipper or continuation
03:39:53 <EvilTerran> need a Data.Map.updateM
03:39:59 <EvilTerran> or that
03:40:34 <luqui> hopefully soon library authors will start including zippers for their data structures.  those things are handy.
03:40:46 <opqdonut> :t Data.Traversable.sequence
03:40:47 <dcoutts_> @type Data.Map.update
03:40:48 <opqdonut> that'd work
03:40:50 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
03:40:50 <lambdabot> forall a k. (Ord k) => (a -> Maybe a) -> k -> M.Map k a -> M.Map k a
03:40:54 <opqdonut> if Map was Traversable
03:40:57 <opqdonut> and i think it is
03:41:09 <kaol> I'll just go with my two lookups for now
03:41:46 <dcoutts_> so you want a general lookup :: k -> Map k a -> (a, Maybe a -> Map k a)
03:42:05 <dcoutts_> you give it a key and a map, it gives you the value and a continuation for inserting at that location
03:42:18 <dcoutts_> or deleting
03:42:49 <kaol> that'd work
03:43:06 <kaol> would even be nicer than an updateM, even
03:43:38 <dcoutts_> aye
03:43:46 <dcoutts_> keep it pure
03:46:08 <kaol> I'm sure lookup itself could be improved on, too
03:47:13 <dcoutts_> kaol: in what way?
03:48:25 <kaol> not using fail would be an easy start
03:48:27 <dolio> Adding more lenses/functional references to the libraries would probably be a good thing.
03:48:37 <dcoutts_> kaol: true
03:49:47 <kaol> never mind, I started thinking about how continuations could be applied to even that. but I guess it doesn't make much sense.
04:00:52 <BeelsebobWork> @src foldm
04:00:52 <lambdabot> Source not found. That's something I cannot allow to happen.
04:00:57 <BeelsebobWork> @src foldM
04:00:57 <lambdabot> foldM _ a []     = return a
04:00:57 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
04:13:08 <dcoutts_> foldM f a xs = foldr (\x ys a -> f a x >>= ys) return xs a
04:13:19 <dcoutts_> @type \ f a xs -> foldr (\x ys a -> f a x >>= ys) return xs a
04:13:21 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> a -> m a1) -> a1 -> [a] -> m a1
04:14:02 <EvilTerran> ?type foldM
04:14:04 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
04:14:23 <EvilTerran> types match, it *must* be the same
04:14:28 <dcoutts_> heh
04:14:29 <EvilTerran> :P
04:14:56 <dcoutts_> it's a higher order foldr
04:15:22 <dcoutts_> which gives you something like an accumulating parameter
04:18:44 <dcoutts_> it's rather like the foldl implemented in terms of foldr
04:19:07 <dcoutts_> > let foldl f a xs = foldr (\x ys a -> ys (f a x)) id xs a in foldl (flip (:)) [] [1..10]
04:19:08 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
04:19:28 * EvilTerran blinks
04:19:34 <EvilTerran> clever
04:19:48 <dcoutts_> EvilTerran: you've never seen that before?
04:20:03 <dcoutts_> it's cute and almost practical
04:20:06 <EvilTerran> not in that form. i'd seen it expressed with (.), i think
04:20:07 <Deewiant> it's in real world haskell
04:20:36 <dcoutts_> if it were compiled efficiently it might let you do build/foldr fusion for things defined in terms of foldl
04:20:53 <dcoutts_> unfortunately it requires an optimisation that's not been implemented
04:23:07 <sioraiocht> are there any C bindings to Pandoc?
04:23:31 <sioraiocht> or is there anyway straightforward way to call Pandoc functions from C?
04:24:56 * dcoutts_ wonders why sioraiocht would want to do that
04:25:07 <dcoutts_> sioraiocht: I guess you could export a C api
04:25:22 <sioraiocht> dcoutts_: yeah, I was wondering if anyone had done it...
04:25:27 <dcoutts_> or you could invoke the pandoc program from C
04:25:39 <sioraiocht> yeah, but that spawns a separate process
04:25:43 <dcoutts_> sioraiocht: we normally go in the other direction :-)
04:25:50 <sioraiocht> basically jim wants to use this in Lua...
04:25:54 <sioraiocht> and lua can call C functions
04:25:56 <dcoutts_> right
04:26:04 <sioraiocht> and there's no Lua <-> Haskell bridge
04:26:11 <dcoutts_> decide what C api you want and export it
04:27:03 <dcoutts_> sioraiocht: since you have the luxury of designing it you can keep it really simple
04:27:55 <dcoutts_> sioraiocht: presumably it's just a matter of passing a buffer and getting another one back in return?
04:28:11 <sioraiocht> dcoutts_: yes, and jus tinvoking pandoc with the flags you want
04:28:52 <dcoutts_> sioraiocht: the only tricky bit is deciding who allocates and frees the buffers since the output buffer is variable sized
04:29:08 <dcoutts_> unless you don't mind copying
04:31:09 <sioraiocht> I dunno, i'll have to ask...
04:33:33 <dcoutts_> sioraiocht: you might find it simpler to run pandoc as a server that can hangs around rather than invoking it again and again
04:34:42 <sioraiocht> that's a good idea..
04:35:26 <sioraiocht> does pandoc support hat?
04:35:28 <sioraiocht> *taht
04:35:29 <sioraiocht> *THAT
04:35:31 <dcoutts_> sioraiocht: though again, you'd need to code that bit yourself
04:35:35 <sioraiocht> ahh
04:35:36 <sioraiocht> okay
04:35:55 <dcoutts_> sioraiocht: but it might be easier than dealing with embedding haskell libs into a lua process
04:36:38 <hexpuem> is there any way to disable file locking in System.IO
04:37:01 <hexpuem> seems like its trying to get a read/write lock even though im only opening for reading
04:43:15 <dcoutts_> hexpuem: what's the problem exactly? you cannot open the same file twice for reading?
04:43:23 <dcoutts_> it should allow multiple readers or a single writer
04:43:46 <hexpuem> one process is writing to the file and has locking set to shared read
04:43:51 <hexpuem> and the haskell process needs to open it
04:43:52 <hexpuem> but cant
04:44:14 <dcoutts_> that's correct though
04:44:22 <dcoutts_> if the other process is writing to the file...
04:45:00 <dcoutts_> then that's the single writer, so no you cannot read it while the other process is writing it
04:45:00 <hexpuem> how else would you implement something like the unix tail command?
04:45:21 <dcoutts_> hexpuem: you could not, not using the portable System.IO api
04:45:54 <dcoutts_> hexpuem: you'll have to use one of the lower level system-specific file apis
04:46:05 <dcoutts_> I presume you're using Windows
04:46:08 <hexpuem> yea haha
04:46:32 <maltem_> hexpuem: File locking works differently on Windows
04:47:00 <dcoutts_> hexpuem: as it happens, unix doesn't really do cross process mandatory locking so you wouldn't get the same problem on unix
04:47:18 <dcoutts_> whether that's a bug or a feature is open for debate
04:48:08 <dcoutts_> so on unix System.IO only really enforces reader/writer within the single process
04:49:54 <hexpuem> theres no platform neutral pipe wrappers in the stdlib right
04:50:36 <dcoutts_> hexpuem: no, but there is a way to capture the stdin/out/err of processes you run, which is the normal use for pipes
04:51:17 <hexpuem> gonna just have to do windows specific code
04:51:17 <hexpuem> blah
04:52:16 <Vq^> hexpuem: just add cygwin as a dependency :o)
04:52:26 <hexpuem> lol
05:02:21 <cinimod> dcoutts_: I finally managed to get ndp working but it took a bit of work with makefiles and configs
05:18:36 <hpaste>  MarcWeber pasted "exical error in string/character literal at character 'n'" at http://hpaste.org/7897
05:18:56 <MarcWeber> What am I doing wrong here?
05:20:24 <MarcWeber> *lol* I didn't enable template haskell ..
05:33:33 <FordCortina> does anybody know where to submit bugs for haddock?
05:33:33 <byorgey> MarcWeber: that might help =)
05:35:15 <FordCortina> !pastebin
05:35:15 <hpaste> Haskell paste bin: http://hpaste.org/
05:37:08 <hpaste>  FordCortina pasted "Haddock linking bug?" at http://hpaste.org/7898
05:37:40 <FordCortina> it probably isnt a bug with Haddock itself
05:37:55 <FordCortina> ive seen it while building other hackage stuff
05:38:34 <FordCortina> im building this on mac osx leopard
05:38:59 <FordCortina> any ideas where i could report this? im a bit out of my depth
05:41:12 <byorgey> hmm, weird
05:44:11 <visq> FordCortina: maybe you've updated the containers package, and some other libraries still depend on an older version ?
05:45:44 <augur> heeeeeey guys
05:46:49 <FordCortina> visq: i dont think I have, and ghc-pkg only reports one installation of containers
05:48:03 <augur> i hate you all. the first thing i thought about when i woke up twenty minutes ago was think about haskell. :|
05:48:04 <byorgey> hey augur
05:48:19 <mix25> @src filter
05:48:19 <lambdabot> filter _ []     = []
05:48:19 <lambdabot> filter p (x:xs)
05:48:19 <lambdabot>     | p x       = x : filter p xs
05:48:19 <lambdabot>     | otherwise = filter p xs
05:48:22 <byorgey> augur: at least you didn't dream in Haskell, like I did. ;)
05:48:33 <mix25> :I filter
05:48:36 <mix25> :i filter
05:48:37 <augur> byorgey: I don't know, I don't remember what I dreamed about!
05:48:41 <byorgey> hehe
05:48:41 <mix25> :t filter
05:48:43 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
05:49:09 <augur> hey, so like
05:49:16 <visq> FordCortina: I had a similar error message lately, because some libraries where build with parsec-2 and some with parsec-3. Just guessing though.
05:49:24 <augur> i know that with haskell you can do ordered partials
05:49:54 <augur> e.g. if func is type a -> b -> c, you can to func a and get back a new function that's type b -> c
05:49:55 <augur> right
05:50:07 <augur> but is there any way to do func b and get back a new function thats type a -> c?
05:50:57 <augur> or to partially evaluate any arbitrary formal argument, rather than the formal arguments in order?
05:51:46 <malebria> Hello, I'm trying to compile Haskore.
05:52:19 <malebria> It depends on supercollider-ht, which depends on hsc3 0.1 and hosc 0.1.
05:52:44 <malebria> But this is strange because these versions are old.
05:53:29 <Philippa> nothing strange about that, it's just one of those things that happens with slowly-developing projects
05:53:36 <Philippa> making sure things work with newer versions is work
05:53:46 <malebria> hum..
05:56:55 <byorgey> augur: sure, using flip
05:57:08 <augur> :P
05:57:13 <augur> i was thinking more generally tho
05:58:05 <byorgey> using flip and uncurry/curry, you can partially apply a function to any of its arguments
05:58:15 <byorgey> but there's no way to do it with nicer syntax
05:58:24 <dcoutts_> cinimod: well done
05:58:24 <augur> ok.
05:58:36 <Arnar_> quit
05:58:52 <augur> well someone should make a function that does partials. :T
05:58:57 <byorgey> you can also do something like  \a b d -> f a b c d
05:59:11 <augur> yeah but thats no fun ;)
05:59:11 <cinimod> dcoutts_: now I need to work out how measure ndp's performance :-)
05:59:41 <Deewiant> @pl \a b d -> f a b c d
05:59:41 <lambdabot> flip flip c . f
05:59:45 <dcoutts_> cinimod: the ndp folk must have some benchmarks
06:00:31 <augur> haskell lambdas are too easy to do. *sigh*
06:00:56 <cinimod> dcoutts_: I'm sure they have but I'd like to be able to reproduce them (at least as far as I can on a 2 core machine)
06:08:19 <augur> byorgey, you know in JS, you can do anonymous functions just like you do named functions, but you just leave off the name. which is convenient in some respects, but painful in others, because that simple lambda you wrote before would have to look like this:
06:08:34 <augur> function(a,b,d){ return f(a,b,c,d); }
06:09:03 <augur> its really ugly when you're doing maps and stuff :\
06:13:45 <mix25> what's mean this error: ERROR - Garbage collection fails to reclaim sufficient space
06:13:55 <mix25> something like stack overflow?
06:14:34 <augur> it looks like it means your program is a memory hog.
06:14:47 <augur> not a stack overflow.
06:15:49 <mix25> Could you more precise?
06:16:18 <augur> what more precise is there?
06:16:34 <augur> your program uses too much memory at any one time.
06:16:47 <mix25> Thanks.
06:17:21 <hpaste>  Chagatai pasted "25" at http://hpaste.org/7900
06:21:25 <hpaste>  Magion pasted "Chagatron" at http://hpaste.org/7901
06:22:04 <dolio> Gah! Prolog!
06:25:11 <augur> prolog is cool, dont hate. :P
06:26:25 <EvilTerran> but it'd be niceif they didn't announce their pastes in here if they're not for us
06:27:44 <augur>  but its by us
06:27:51 <augur> which is how it determines whether or not to announce it
06:27:58 <augur> and so it might be for us
06:30:02 <EvilTerran> pardon?
06:30:19 <EvilTerran> it determines whether or not to announce it by whether or not you check the "announce" box as you paste
06:31:28 <augur> i imagine that in some other room it was relevant, and hpaste bot doesnt know how to distinguish rooms. :P
06:31:48 <kiris> sometimes it just doesn't announce it when I check the "announce" box. for a while I thought I had to speak in #haskell or it wouldn't do it. now I just think it sometimes fails to announce
06:32:04 <dolio> That's why we need hpastetwo.
06:32:29 <kiris> glguy has written one, hasn't he?
06:32:35 <dolio> The announce was broken for a while.
06:32:45 <dolio> Yeah, it just hasn't been set up for some reason.
06:33:10 <EvilTerran> kiris, it's fairly common for the hpaste bot to not even be in here, from what i've seen
06:33:19 <kiris> EvilTerran: ah
06:33:40 <EvilTerran> presumably gets disconnected occasionally and doesn't re-connect successfully or something
06:38:04 <mix25>  dh
06:54:49 <dancor> it means you are using like infinity memory i think
06:55:05 * dancor was scrolled up, oops
06:56:16 <augur> ;)
06:56:27 <augur> its fairly obvious from the error whats going on
06:56:34 <augur> i dont see why he found it so cryptic
06:56:40 <augur> it practically said "you're using too much memory"
06:58:56 <dancor> it's definitely clearer than many other ghc error messages ;)
07:17:13 <tibbe> quick I need an easy to read paper for the gym! ;)
07:17:55 <kiris> tibbe: http://citeseer.ist.psu.edu/cache/papers/cs/16216/http:zSzzSzwww.cs.nott.ac.ukzSz~gmhzSzpaperszSz20.pdf/claessen00typed.pdf
07:17:56 <lambdabot> http://tinyurl.com/5jyk29
07:19:19 <tibbe> kiris: thanks
07:19:33 <opqdonut> :D
07:27:44 <malebria> Hello.
07:28:01 <hpaste>  panaka pasted "presta" at http://hpaste.org/7902
07:28:16 <malebria> I'm trying to compile SDL-mixer, but it's searching for autoconfUserHooks in Distribution.Simple.
07:28:22 <malebria> Was this changed?
07:29:45 <dcoutts_> malebria: hmm, that's unfortunate as it means the package needs a version of Cabal that has not been released
07:31:17 <dcoutts_> malebria: you can change it to defaultUserHooks
07:33:01 <malebria> dcoutts_: thanks.
07:41:37 <hpaste>  ala pasted "ej34" at http://hpaste.org/7903
07:54:11 <malebria> I'm trying to build hmixer, but I'm getting in runhaskell Setup.hs build: Linking dist/build/hbeat/hbeat .../usr/local/lib/SDL-mixer-0.5.2/ghc-6.8.2/libHSSDL-mixer-0.5.2.a(Samples.o): In function `s5t4_info':
07:54:12 <malebria> (.text+0x365): undefined reference to `Mix_LoadWAV'
07:54:12 <malebria> collect2: ld returned 1 exit status
07:54:29 <malebria> What could this be?
07:58:04 <bos> incompatible version of SDL.
08:00:19 <malebria> bos: do you know what version is compatible with hbeat?
08:02:14 <hpaste>  Magion pasted "rar.exe" at http://hpaste.org/7904
08:02:50 <vixey> wtf o_o
08:03:58 <Philippa> suffice to say that I'm not taking a look? I smell attempts at browser exploits and I'd rather not find out the hard way
08:04:22 <MyCatVerbs> There's no script tags in that.
08:04:29 <Cale> It's just Erlang code.
08:04:32 <MyCatVerbs> It's actually a screenful of Prolog code, to look a.
08:04:35 <bos> malebria: no idea
08:04:35 <Cale> er
08:04:45 <Cale> right yeah
08:04:50 <vixey> It's like spanish ..?
08:04:52 <Cale> I didn't look hard enough :)
08:04:57 <MyCatVerbs> Cale: um.
08:05:11 <vixey> Erlang uses -> where Prolog uses :- I think
08:05:22 <MyCatVerbs> Cale: Prolog and Erlang almost practically identical syntax. It -looks- like Prolog, is all I'm saying.
08:05:29 <Cale> It is.
08:05:29 <vixey> (It is Prolog)
08:06:09 <vixey> why was it posted though :/
08:06:14 <MyCatVerbs> There's no javascript at all in there, anyway. So prolly fine.
08:06:21 <Cale> Probably someone talking about the code on another channel.
08:06:31 <Cale> and forgot to uncheck the announce box
08:06:47 <Philippa> yeah. "rar.exe" isn't exactly an innocuous-looking title though!
08:07:04 <vixey> Philippa: that's exactly why I clicked it infact
08:10:23 <vincenz> someone pinged?
08:11:00 <vincenz> edwardk: what's up?
08:11:57 <augur> <3prolog
08:12:00 <MyCatVerbs> Philippa: ah well. Three cheers for NoScript.
08:12:52 <malebria> vixey: it's spanish.
08:13:10 <vixey> ok
08:15:06 <Cale> Ah, rar, the clear choice of file compression for pirates. RARRRR matey!
08:16:30 <Philippa> Cale: it isn't quite the clear choice for actual pirates now, but sure was for a long time!
08:17:25 <vixey> hehe
08:36:48 <chessguy> 'morning #haskell folk
08:37:10 <vixey> hi chessguy
08:37:19 <byorgey> morning chessguy
08:37:29 <vixey> hi byorgey
08:37:36 <byorgey> hi vixey
08:39:09 <chessguy> hey if i'm designing an API with a number of functions requiring random numbers, what's the best practice, for most general use?
08:39:22 <chessguy> in terms of what type signatures to use
08:39:48 <kiris> a Random monad? :P
08:39:48 <opqdonut> the Random monad
08:39:58 <vixey> why not MonadSupply
08:40:04 <opqdonut> which basically has a randGen as state
08:41:15 <chessguy> @hoogle MonadRandom
08:41:15 <lambdabot> No matches found
08:42:11 <kiris> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
08:42:12 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
08:42:53 <chessguy> hm, it's not in the library?
08:43:41 <kiris> depends if you want a monad transformer, I suppose, otherwise MonadSupply looks lovely to supply an infinite list of random values
08:56:20 <byorgey> @seen Syzygy-
08:56:20 <lambdabot> Syzygy- is in #haskell. I last heard Syzygy- speak 2d 5h 35m 9s ago.
08:56:39 <augur> damn, syzygy is talkative
08:57:26 <conal> what does "golfing" mean, as in "Rather than golfing your questions ..."?
08:57:43 <saml> i finished my homework: http://www.lipl.googlepages.com/index.html#source
08:57:44 <lambdabot> Title: LIPL: a Little Idiotic Programming Language -- LIPL
08:57:49 <dolio> Trying to write the shortest possible expression that does the same thing.
08:57:57 <byorgey> @ask Syzygy- I'm going to be giving a 15-minute introductory talk on Haskell to an audience of mostly mathematicians.  The idea is to show them how great Haskell is for playing with mathematics.  Got any cool example code I could show them?
08:57:58 <lambdabot> Consider it noted.
08:58:20 <conal> dolio: oh!  i get it.  thanks.
08:58:49 <saml> > pythagorian a b = sqrt (a*a + b*b) in pythagorian 3 4
08:58:49 <lambdabot>  Parse error at "=" (column 17)
08:58:51 <mauke> http://en.wikipedia.org/wiki/Perl_Golf_Apocalypse
08:58:52 <lambdabot> Title: Perl Golf Apocalypse - Wikipedia, the free encyclopedia
08:59:00 <saml> > let pythagorian a b = sqrt (a*a + b*b) in pythagorian 3 4
08:59:02 <lambdabot>  5.0
08:59:29 <saml> mathematicians will get disappointed at floating point numbers
08:59:42 <vixey> > let pythagorian a b = sqrt (a*a + b*b) :: CReal in pythagorian 3 4
08:59:43 <byorgey> saml: of course.  which is why we have Integer. =)
08:59:44 <lambdabot>  5.0
08:59:47 <kiris> nice little article: http://en.literateprograms.org/Quicksort_(Haskell)
08:59:50 <lambdabot> Title: Quicksort (Haskell - LiteratePrograms
09:00:11 <augur> i dont get literate programming
09:00:17 <augur> can someone explain it to me?
09:00:49 <saml> augur: it's comments and code reversed. by default everything is a comment
09:00:59 <augur> example?
09:01:22 <saml> this is a comment \begin{code} f a = a \end{code}  this is a comment
09:01:29 <chessguy> @pl \a b -> s (a*a + b*b)
09:01:29 <lambdabot> (s .) . (. join (*)) . (+) . join (*)
09:01:30 <kiris> http://www.kennknowles.com/blog/2008/05/24/what-is-defunctionalization/
09:01:31 <lambdabot> Title: Mathematical Pamphlet » What is defunctionalization?, http://tinyurl.com/6s3dgm
09:01:40 <kiris> most of kenn knowles's posts are literate haskell
09:01:46 <kiris> you can just paste them right into your editor and compile them
09:01:47 <augur> ok
09:01:50 <mauke> literate haskell is not literate programming
09:02:33 <chessguy> mauke: what's the difference?
09:02:34 <kiris> he asked for an example
09:02:39 <augur> unless you believe that programming anything other than haskell isnt programming at all ;)
09:02:40 <mauke> http://en.wikipedia.org/wiki/Literate_programming
09:02:47 <saml> oh i don't know what literate programming is. it's a way to publish a book by writing a large program with a lot of comments.. like Metafont: the book
09:04:16 <Deewiant> @pl \a b -> sqrt $ ((+) `on` join (*)) a b
09:04:16 <lambdabot> (sqrt .) . ((+) `on` join (*))
09:04:42 <laz0r> is it possible to use (-),(+), etc as operators without interfering with the studf defined in Prelude=
09:04:46 <laz0r> ?
09:05:07 <saml> import Prelude hiding ((-), (+)) ?
09:05:55 <laz0r> mmh. i guess that would be a possible solution, but i would like to have both... my own (-) and the one in Prelude
09:06:06 <mauke> hmm, maybe .lhs with latex counts
09:06:07 <conal> > join (*) a b
09:06:08 <lambdabot>  Couldn't match expected type `t -> t1' against inferred type `Expr'
09:07:18 <saml> laz0r: a + b = a - b   then   1  Prelude.+ 2    and 1  YourModule.+ 2
09:07:33 <Deewiant> > join (*) a
09:07:34 <Jaak> let a + b = a - b in 1 + 2
09:07:35 <lambdabot>  a * a
09:07:37 <saml> > let a + b = a - b in 1 Prelude.+ 2 + 3
09:07:37 <Jaak> > let a + b = a - b in 1 + 2
09:07:40 <lambdabot>  0
09:07:40 <lambdabot>  -1
09:07:47 <conal> oh yeah
09:07:56 <conal> join (*) == (^2)
09:08:23 <conal> so (fmap.fmap) sqrt ((+) `on` (^2))
09:08:28 <conal> i like that one
09:08:40 <vixey> :t (fmap.fmap.fmap)
09:08:42 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
09:08:52 <Jaak> @type fix fmap
09:08:54 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
09:08:54 <lambdabot>       Expected type: (a -> b) -> a -> b
09:08:54 <lambdabot>       Inferred type: (a -> b) -> f a -> f b
09:09:02 <Jaak> @type fix fmap return
09:09:04 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
09:09:04 <lambdabot>       Expected type: (a -> b) -> a -> b
09:09:04 <lambdabot>       Inferred type: (a -> b) -> f a -> f b
09:09:10 <Jaak> mmh
09:09:11 <mix25> Can i use funcs from Data.List without import it?
09:09:21 <mauke> no
09:09:24 <mix25> ko
09:09:26 <mix25> ok*
09:09:31 <mix25> @src elem
09:09:31 <lambdabot> elem x    =  any (== x)
09:10:50 <mix25> @src delete
09:10:50 <lambdabot> delete = deleteBy (==)
09:10:55 <mix25> @src deleteBy
09:10:56 <lambdabot> Source not found. stty: unknown mode: doofus
09:11:05 <mix25> @src deleteBy.Data.List
09:11:05 <lambdabot> Source not found. I feel much better now.
09:11:12 <conal> :t (fmap.first.fmap.second.fmap)
09:11:14 <lambdabot> forall (f :: * -> *) d (f1 :: * -> *) d1 a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (d1, f2 a), d) -> f (f1 (d1, f2 b), d)
09:11:47 <vixey> :t (fmap.(!!0).fmap.(!!1).fmap)
09:11:48 <lambdabot>     Couldn't match expected type `[a -> b]'
09:11:48 <lambdabot>            against inferred type `f a1 -> f b1'
09:11:48 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
09:12:38 <conal> in fmap.first.fmap.second.fmap, each part of the path says how to make one step into a composite value, to find the piece to be transformed.
09:12:49 <conal> so fmap, first, and second, are semantic editor combinators.
09:13:38 <ndm> this sounds like a job for something like Biplate/Uniplate...
09:14:01 <ndm> although, i guess if you are changing the types, it wouldn't work :(
09:14:18 <ndm> but could be SYB'able
09:17:35 <mauke> does anyone here work on Haskell'?
09:17:57 <mauke> what the
09:19:28 <mauke> is there an echo in here?
09:19:40 <dcoutts> ping!
09:20:15 <mauke> I just saw myself saying "<mauke> does anyone here work on Haskell'?". I don't think that's allowed by the IRC protocol
09:21:03 <kiris> haha
09:24:36 <chessguy> mauke: what do you mean by 'work on' Haskell?
09:25:06 <Jaak> Haskell' not Haskell
09:25:13 <chessguy> oh
09:30:26 <mauke> > let x y z = mconcat (replicate z y) in "foo" `x` 3
09:30:27 <lambdabot>  "foofoofoo"
09:30:59 <vixey> lol
09:31:52 <mauke> > let y Ã— z = mconcat (replicate z y) in "foo" Ã— 3
09:31:52 <lambdabot>  Illegal character ''\151''
09:31:52 <lambdabot>  at "—" (column 8)
09:32:24 <vixey> > let die = unsafePerformIO (poke (fromEnum 0)) ; unless x p = if p then x else undefined in die `unless` (length l == 4)
09:32:24 <lambdabot>   Not in scope: `poke'
09:36:19 <vixey> @let undef = ()
09:36:20 <lambdabot> Defined.
09:41:18 <Syzygy-> byorgey: You called?
09:41:18 <lambdabot> Syzygy-: You have 1 new message. '/msg lambdabot @messages' to read it.
09:42:36 <vixey> what about model theory in haskell
09:42:37 <vixey> ?
09:53:27 <vixey> is it a good idea?
09:53:54 <MyCatVerbs> vixey: what's model theory?
09:54:42 <ibid> the model theory i know is a mechanism for describing the semantics of a logic
09:54:49 <ibid> dunno what it has to do with haskell
09:54:51 <MyCatVerbs> vixey: also, \bot has had its guts ripped up and all the IO stuff excised to prevent people from causing it to deref null pointers.
10:16:31 <sm_> good morning all
10:17:35 <sm_> I'm trying to resolve an issue with ghc not seeing the packages ghc-pkg shows installed, on a mac. Any tips ?
10:18:11 <xerox> using --make helps?
10:18:52 <sm_> no
10:19:41 <xerox> more info needed
10:19:45 <sm_> oh I know.. I'm forgetting the hierarchical module prefix
10:19:54 <sm_> just import Chart won't work
10:20:26 <dancor> Display.Excel.Pie.Chart
10:21:48 * edwardk returns to consciousness.
10:21:55 <sm_> right, or Graphics.Rendering.Chart here. I've been away from haskell a while. Thanks!
10:22:13 * sm_ tries the simple chart api
10:24:05 <sm_> oh boo.. cabal Chart is old
10:26:42 <sm_> latest is 0.8, I just installed 0.5. After cabal update I see cabal has 0.7. How to make cabal upgrade 0.5 to 0.7 though ?
10:27:36 <byorgey> sm_: you can just do 'cabal upgrade', or you can ask cabal to install a particular version: 'cabal install Chart-0.7' or whatever
10:28:08 <sm_> I see.. I think I need a newer cabal-install, no upgrade command here
10:28:35 <byorgey> that's possible, I don't know when the upgrade command was added
10:33:18 * sm_ is mistaken.. cabal has the latest, 0.7
10:40:05 <TomMD> sm_: There used to be a "cabal upgrade" but even after installing the darcs cabal I don't seem to have it either - I'm looking at it right now.
10:40:32 <sm_> yes.. I expect cabal install would do it then, if I had the latest version
10:41:12 <SamB> TomMD: but did you install the darcs cabal-install?
10:41:20 * sm_ is having some trouble doing that
10:42:25 <SamB> well, what version do you have?
10:42:37 <SamB> each of you?
10:42:41 <SamB> cabal --version
10:42:46 <sm_> mine doesn't have --version
10:42:54 <SamB> sm_: you are using the way old one then
10:43:22 <sm_> pulling from the cabal-install repo on darcs.haskell.org seems extremely slow for me
10:43:52 <HairyDude> I see hardy has no ghc6-libsrc package
10:45:43 <SamB> sm_: even with --partial?
10:46:03 <sm_> yes.. pulling only a few patches a minute
10:46:08 <SamB> HairyDude: they say it's not wise to use the GHC packages from Ubuntu...
10:46:14 <sm_> hmm, seems I can install cabal from cabal though
10:46:16 <SamB> sm_: wow
10:47:03 <sm_> that gets me 0.4.. still no --version :(
10:47:09 <HairyDude> SamB: "they" being...?
10:47:25 <SamB> I forgot who said
10:53:56 <Lemmih> sm_: http://seize.it/mirror/cabal-install/
10:53:58 <lambdabot> Title: Index of /mirror/cabal-install/
10:54:30 <Lemmih> ^^ 100Mbit upload located in the netherlands.
10:55:56 <TomMD> SamB: Yes, I have the darcs Cabal and cabal-install.  I'm getting some really weird behavior
10:56:13 <sm_> Lemmih: thank you, that's better
10:56:43 <sm_> or is it.. still only a few patches per second, here
10:56:49 <HairyDude> SamB: anyway, why is it not wise?
10:58:01 <Lemmih> sm_: Weird. It takes me 7 seconds to get the repo.
10:58:09 <SamB> HairyDude: don't remember that either!
10:58:21 * SamB uses Debian so has decent packages courtesy of Igloo
10:58:29 <HairyDude> you know, I don't like the smell of FUD ;)
10:58:45 <SamB> HairyDude: whatever
10:58:47 <Lemmih> sm_: Are you on a high latency connection?
10:58:47 <kiris> oo Real World Haskell sounds great
10:58:57 <sm_> not usually! everything else is fine
10:59:08 <TomMD> kiris: The event of the year will be that books release.
10:59:12 <SamB> sm_: maybe you didn't build darcs with pipelining support?
10:59:25 <TomMD> Unless DPH trumps it.
10:59:42 <sm_> hmm, do you know how to check  SamB ?
10:59:51 <SamB> well, how did you build it?
10:59:58 <sm_> make
11:00:18 <SamB> what library is it using for HTTTP?
11:00:19 <sm_> I just built the latest a few minutes ago
11:00:57 <SamB> the latest being that reached by "darcs get http://darcs.net"?
11:01:04 <sm_> yes
11:01:05 <kiris> TomMD: no doubt.
11:01:48 <kiris> TomMD: what's DPH?
11:01:54 <TomMD> Data Parallel Haskell
11:01:56 <TomMD> @where DPH
11:01:57 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
11:03:20 <kiris> I'll reda the paper
11:03:36 <dolio> @where NDP
11:03:36 <lambdabot> http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/ http://www.cse.unsw.edu.au/~chak/project/dph http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
11:03:37 <SamB> sm_: do you have the HTTP package?
11:04:01 <sm_> SamB: yes
11:04:11 <kiris> re RWH I wonder how they'll present monads
11:04:12 <SamB> sm_: is darcs building with that?
11:04:30 <sm_> I assume so. I've built this darcs a bunch of times and never seen this problem before
11:05:24 <TomMD> kiris: Many example chapters are up already, I thought they had a monad chapter (at least the transformer chapter) up already.
11:05:39 <sm_> I'd better go.. thanks for the help, all
11:05:43 <kiris> TomMD: oh, I'll see
11:07:26 <mix25> (xs:zss:ys) => ys is the last element of the list?
11:07:52 <TomMD> No, ys is the rest of the list
11:08:01 <TomMD> > 1 : 2 : []
11:08:02 <lambdabot>  [1,2]
11:08:03 <mix25> and zss ?
11:08:05 <dolio> xs is the first element, zss is the second.
11:08:08 <TomMD> > 1 : 2 : [3,4,5,6]
11:08:10 <lambdabot>  [1,2,3,4,5,6]
11:08:16 <mix25> ahym
11:08:23 <mix25> @src lst
11:08:24 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:08:25 <mix25> @src last
11:08:25 <lambdabot> last [x]    = x
11:08:25 <lambdabot> last (_:xs) = last xs
11:08:25 <lambdabot> last []     = undefined
11:08:53 <dolio> Need some views. Get yourself dependent types. :)
11:08:56 <TomMD> mix25: In general, avoiding "head" and "last" is good to avoid that 'undefined' situation.
11:09:17 <bd_> @check \a -> last (a :: [Int]) == foldl1 (flip const) a
11:09:19 <lambdabot>  Exception: Prelude.last: empty list
11:09:27 <bd_> @check \a -> null a || (last (a :: [Int]) == foldl1 (flip const) a)
11:09:29 <lambdabot>  OK, passed 500 tests.
11:10:34 <kiris> holy awesome. it is online /me excited
11:10:53 <TomMD> kiris: Be sure to thank the authors - they are typically here.
11:13:22 <hpaste>  mix25 pasted "(no title)" at http://hpaste.org/7906
11:13:50 <mix25> Why doesnt work properly the last func with resursive call
11:14:32 <mix25> off
11:14:52 <TomMD> Which funciton?
11:15:02 <TomMD> trianguloAux?
11:15:12 <mix25> "func" , but i see now that miss some things
11:16:07 <mix25> when the if is false then call to func (zss)
11:16:43 <TomMD> mix25: You need to define the function for if the argument is null.
11:16:46 <kiris> (tip: you don't need ...==True in an if statement)
11:16:57 <TomMD> mix25: func [] = ?
11:17:00 <roconnor> > exp(log 6/150)
11:17:01 <lambdabot>  1.0120166903076984
11:17:12 <mix25> yes
11:17:16 <mix25> u are right
11:18:46 <mix25> I think i need statemente when the 1 if == false right?
11:22:16 <thoughtpolice> @seen bos
11:22:16 <lambdabot> bos is in #ghc and #haskell. I last heard bos speak 3h 17m 41s ago.
11:24:45 <roconnor> > exp(log 6/150) :: CReal
11:24:46 <lambdabot>  1.0120166903076982834949317702450402387881
11:25:21 <roconnor> > 6**(1/150)
11:25:22 <lambdabot>  1.0120166903076984
11:25:32 <roconnor> > 6**(1/150) :: CReal
11:25:34 <lambdabot>  1.0120166903076982834949317702450402387881
11:33:33 <TomMD> hummm, I do I figure out a broken 'runhaskell' and 'runghc' binary?
11:34:12 <Korollary> you mean how?
11:34:47 <TomMD> Yes, sorry, I am just a bit confused by runhaskell / runghc being broken.
11:35:35 <TomMD> They eat 100% CPU, grow to 15% memory then exit with no side effects (not even stdout)
11:36:41 <TomMD> isn't there a ghc flag that will make ghc act like runghc?  I thought thats all runghc was at one time.
11:36:43 <kiris> this chapter on monads is great! much better than YAHT's imho
11:37:08 <newsham> "this chapter" =?   rwh?
11:37:18 <kiris> http://book.realworldhaskell.org/beta/monads.html
11:37:19 <lambdabot> Title: ChapterÂ 15.Â Monads
11:37:24 <kiris> yeah
11:37:27 <Korollary> TomMD: runghc just calls ghc. you may wanna look at its source.
11:37:29 <lament> kiris: yaht's is pretty bad though
11:37:29 <TomMD> kiris: I agree - and the transformers chapter is also a wonder.  Its nice to see the book before I pay my "citizen of Haskell tax"
11:37:44 <kiris> TomMD: heheh
11:38:19 <newsham> i thought the "citizens of haskell tax" was all the time you lost reading academic papers to figure out how to use haskell ;-)
11:38:36 <AndreWe> I tried to compile the Structs.chs example from c2hs-doc and get an error message " >>> Expected a pointer object!". Has anyone here used c2hs?
11:38:37 <newsham> rwh will be a considerable tax reduction
11:38:37 <TomMD> No no, that is time I get paid for.
11:38:39 <kiris> lament: true. it had me fixated on the state monad, thinking the concept of a monad was the way the state monad was implemented, instead of just an abstraction on a common kind of computation
11:39:53 <newsham> well I dont get paid for reading papers :(
11:40:25 <lament> i think some of the difficulty with monads is due to there being two very different things to be explained: what monads are, and what the IO monad is
11:40:47 <mix25> Can i see the progress of my functions ?
11:41:10 <TomMD> lament: You could expand that to "What is the ____ monad?"  Many people seem to learn monads through learning how to use many different monads.
11:41:17 <lament> mix25: if i understand you correctly, try Debug.Trace
11:41:20 <newsham> mix25: perhaps using the debugger (havent tried), or you can try Debug.Trace
11:41:37 <mix25> Ahym
11:41:38 <TomMD> @where debugger
11:41:38 <lambdabot> http://www.haskell.org/ghc/dist/current/docs/users_guide/ghci-debugger.html
11:41:42 <TomMD> mix25 ^^^
11:41:45 <AndreWe> mix25: what do you mean by the progress? Like a progress bar?
11:41:47 <lament> TomMD: my point is that the IO monad is magical, while many other monads aren't
11:42:03 <mix25> something like : wait
11:42:06 <TomMD> lament: Not arguing with that.
11:42:17 <ddarius> lament: There isn't much new to explain though.
11:42:25 <lament> TomMD: explaining what monads are: the monadic laws, etc, is fine but it doesn't really bring any understanding of how IO works
11:42:29 <kiris> TomMD: it clicked for me when I implemented the state monad and parsec's monad in javascript, and when Cale said, well, that's not monadic because you haven't generalised the computation (no type classes in javascript)
11:42:49 <ddarius> lament: As TomMD said, that doesn't bring any understanding of how any monad works.
11:43:00 <mix25> something like this: http://www.lcc.uma.es/~pacog/apuntes/pd/cap06.pdf
11:43:12 <mix25> page 17
11:43:13 <lament> ddarius: with monads like list and maybe, you can just look at the implementation to see how it works.
11:43:23 <lament> there's no magic involved
11:43:48 <AndreWe> I don't speak/read Spanish well enough, mix25.
11:43:51 <lament> if all monads were like that, i don't think people would have any difficulty grasping them
11:44:23 <ddarius> lament: Yes, but that's not explaining what monads are.  I imagine that Cont, for many people, might as well be magic.  Similarly for some more involved instances.
11:44:37 <TomMD> Isn't there a spanish #haskell (#haskell-es ?), not to say you can't ask here too.
11:44:50 <lament> you don't need much spanish to understand that slide :)
11:44:52 <AndreWe> mix25: page 17 is about folds, I don't see how that relates to progress???
11:44:56 <mix25> AndreWe only is the progress of function , u dont need speak/read spanish to see that
11:45:00 <lament> AndreWe: look at the blue text
11:45:10 <lament> it shows the operation of foldr step by step
11:45:26 <lament> i think the only way to do that is to ask Cale
11:45:40 <mix25> But this page shows what's doing the function
11:45:54 <ddarius> In my opinion, people confuse understanding monads with understanding how to implement any particular monad.  The former is easy, the latter requires understanding how to model some side-effect and may well be quite difficult even if you completely understand monads.
11:45:57 <lament> doesn't the debugger do that?
11:46:13 <mix25> I don't know.
11:46:15 <lament> show evaluation of expressions step by step
11:46:18 <lament> i think it does
11:46:26 <lament> mix25: look at the ghc debugger
11:46:35 <TomMD> as I said:
11:46:37 <mix25> I'm doing it
11:46:38 <TomMD> @where debugger
11:46:39 <lambdabot> http://www.haskell.org/ghc/dist/current/docs/users_guide/ghci-debugger.html
11:46:50 <TomMD> ok, just making sure it wasn't lost in the noise.
11:46:57 <mix25> Ok
11:47:00 <kiris> > foldr f z [a,b,c,d,e,f,g,h]
11:47:04 <lambdabot>  f a (f b (f c (f d (f e (f f (f g (f h z)))))))
11:47:29 <lament> kiris: that shows the end result, not step-by-step operation :)
11:47:31 <newsham> > foldr (+) z [a,b,c]
11:47:32 <lambdabot>  a + (b + (c + z))
11:47:58 <AndreWe> kiris: The "f f" part is confusing (but might be correct).
11:48:02 <kiris> lament: looks like step-by-step to me?
11:49:04 <kiris> oh, evaluations
11:49:30 <Beelsebob> if you want step by step evaluation, you'll need to use something like hat-anim
11:49:51 <Beelsebob> but it won't show you the step by step evaluation for foldr, because it's a trusted prelude function
11:50:05 <kiris> Beelsebob: why not write foldr'?
11:50:14 <Beelsebob> well, you can if you like
11:50:17 <Beelsebob> and then it will show you
11:50:54 <lament> or you can simply visit http://foldr.com/
11:50:55 <lambdabot> Title: foldr.com
11:51:01 <Beelsebob> hehe, that too
12:02:41 <newsham> whats the purpose of Data.Stream (compared to Data.List for example?)
12:04:25 <newsham> oh, nevermind, Data.Stream excludes finite lists
12:10:32 <byorgey> I think Data.Stream is coinductive, as opposed to Data.List which is inductive. (?)  However, I don't think I could explain the difference or its import.
12:12:50 <sjanssen> list has [], while Stream doesn't
12:15:13 <kiris> hum. if you got http://www.realworldhaskell.org/ , it doesn't actually tell you what the book is... a bit annoying if I want to link it to people. should be a link to "what it is" somewhere imho
12:15:14 <lambdabot> Title: Real World Haskell
12:15:31 <newsham> it isnt, yet.
12:15:38 <newsham> maybe when it is, they will describe what it is :)
12:16:15 <kiris> I've found the article saying what it is: http://www.realworldhaskell.org/blog/2007/05/23/real-world-haskell-its-time/
12:16:16 <lambdabot> Title: Real World Haskell » Blog Archive » Real-world Haskell: it&#8217;s time!, http://tinyurl.com/2ddm5b
12:16:58 <newsham> anyone familiar with Control.Arrow.Transformer.Stream.runStream?
12:16:58 <kiris> meh
12:17:42 <newsham> kiris: i think there is pre-release page on amazon for it
12:17:51 <newsham> which should say what it is
12:19:14 <newsham> I wish haddock docs let you click on any part of the "Control.Arrow.Transformer.Stream" title to go up to higher levels of docs
12:19:27 <newsham> (when they exist)
12:24:31 <conal> newsham: cool idea
12:25:35 <newsham> hey conal.  reading some of your blogs and some arrows docs.  what's the "e" in runStream :: ArrowLoop a => StreamArrow a (e, b) c -> a (e, Stream b) (Stream c)  ?
12:25:42 <newsham> is that just general "environment" type stuff?
12:26:35 <TomMD> Is there an easy way to grep through all of the hackage packages?
12:26:44 <conal> newsham: i think so
12:29:08 <newsham> conal: is the src to any of your chat bots available for running/viewing?
12:29:43 <conal> newsham: i've forgotten.  let me look...
12:32:34 <roconnor> > 1747-1049
12:32:37 <lambdabot>  698
12:32:59 <TomMD> Is there an "all packages" option for "cabal fetch"
12:33:05 <TomMD> Perhaps undocumented?
12:33:37 <conal> newsham: now i see.  there's a link in the second paragraph of http://conal.net/blog/posts/functional-reactive-partner-dancing/
12:33:38 <lambdabot> Title: Conal Elliott » Blog Archive » Functional reactive partner dancing
12:33:38 <sjanssen> they probably don't want you eating all their bandwidth :)
12:33:48 <newsham> ty
12:33:56 <TomMD> sjanssen: yes, I can guess that, but still.
12:34:27 <TomMD> Perhaps hackage should be a DHT (distributed hash table) :-) would make me happy
12:37:53 <TomMD> @users
12:37:53 <lambdabot> Maximum users seen in #haskell: 480, currently: 456 (95.0%), active: 10 (2.2%)
12:47:46 <newsham> are there any small example programs which use the chatter bot?
13:02:42 <noecksit> hello, does haskell come by default with a good parser?
13:02:53 <vixey> noecksit: yes
13:03:42 <Zao> Parsec is rather lovely.
13:03:50 <noecksit> is it Language.Haskell.Parser? I dont seem to have it
13:04:22 <opqdonut> do you mean a parser for haskell
13:04:25 <opqdonut> or a parser library
13:04:28 <vixey> @index parseModule
13:04:28 <lambdabot> Language.Haskell.Parser
13:04:37 <vixey> noecksit: Do you have GHC?
13:04:45 <noecksit> opqdonut: i mean a parser library
13:05:00 <noecksit> vixey: yeah, its ghc-6.6.1
13:05:11 <vixey> noecksit: Language.Haskell.Parser parses Haskell
13:05:28 <opqdonut> noecksit: parsec is a parser library with a quite unique approach
13:05:31 <TomMD> vixey: But not all the extentions, right?
13:05:32 <opqdonut> (combinatorial)
13:05:45 <opqdonut> happy is a parser generator in the vein of yacc
13:05:46 <vixey> TomMD: it probably does do all the extensions
13:05:55 <TomMD> @vixen: Is vixey correct?
13:05:55 <lambdabot> i think you know the answer to that one, silly
13:06:11 <noecksit> vixey: i dont seem to have Language.Haskell.Parser
13:06:22 <vixey> noecksit: why do you want it?
13:07:12 <vixey> TomMD: there's this http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html but I don't know if it's used for anything
13:07:13 <lambdabot> http://tinyurl.com/2xjyqs
13:07:59 <noecksit> vixey: well, i dont really need it, i just wanted to get familiar with it, i could parse the strings by hand i guess
13:08:10 <vixey> noecksit: what strings?
13:08:45 <byorgey> noecksit: if you want a parser library, you should use Text.ParserCombinators.Parsec
13:09:12 <TomMD> noecksit: Or use byorgey :: Money -> HsSource
13:09:39 <byorgey> yes, that works too
13:10:16 <noecksit> oh, that worked, i guess i did have Parsec after all thanx
13:10:35 <newsham> you can also parse with read
13:11:25 <byorgey> and there's Text.ParserCombinators.ReadP
13:11:47 <byorgey> which has the advantage of being fairly simple, and is naturally backtracking
13:12:02 <byorgey> whereas if you want backtracking with Parsec you have to explicitly insert calls to 'try'
13:12:07 <byorgey> (for performance reasons)
13:12:35 <newsham> on the other hand, parsers you write with parsec without using "try" might not represent exactly the language you think.
13:14:17 <vixey> newsham: I guess that depends on if you know what try does or not
13:14:58 <newsham> vixey: without backtracking <|> isnt the same as alternation.
13:15:08 <newsham> so if you're trying to approximate a CFG, you can get it wrong
13:15:12 <newsham> (and not realize it)
13:15:39 <vixey> oh you said without try sorry I thought you said with
13:16:21 <newsham> (I find it ironic that haskell in general encourages more formal reasoning, but haskell users often use parser generators that are more distant from the traditional language specifications)
13:18:39 <olsner> putting more formal reasoning in the compiler allows you to be more sloppy and informal when writing code, I guess
13:19:11 <olsner> plus, you can extract the formalities into your own abstractions that you can spend time proving correct using the type system etc
13:19:14 <opqdonut> yeah
13:19:24 <vixey> olsner: I don't think so
13:19:28 <opqdonut> a proper AST does wonders
13:19:51 <vixey> it allows you to be -more- formal
13:19:57 <vixey> which is where correctness comes from
13:23:45 <olsner> I have a vague idea that you're really agreeing with me but is choosing a different way to express your opinion
13:24:04 <newsham> lets agree to misagree
13:24:19 <olsner> misagree ;-) that's a new one
13:24:54 <ddarius> newsham: There are PEGs that more closely fit how people actually use grammars in parsing.
13:25:12 <newsham> PEG?
13:25:28 <ddarius> @google "parsing expression grammar"
13:25:29 <lambdabot> http://en.wikipedia.org/wiki/Parsing_expression_grammar
13:26:35 <newsham> danke
13:27:30 <olsner> there's a haskell library for PEG:s somewhere
13:28:08 <newsham> I'm not saying haskell doesnt let people use more formal grammar generators.  (ie. there's happy)
13:28:31 <newsham> this peg stuff sounds interesting.
13:28:32 <olsner> @where frisby
13:28:33 <lambdabot> http://repetae.net/computer/frisby/
13:28:55 <bos> thoughtp1lice: you were looking for me?
13:28:57 <ddarius> @where pappy
13:28:58 <lambdabot> http://pdos.csail.mit.edu/~baford/packrat/thesis/
13:29:13 <newsham> err except the left recursive thing
13:30:02 <thoughtp1lice> bos: yeah, it was about llvm-0.0.2 on hackage; got the examples to build using llvm-config
13:32:02 <bos> thoughtp1lice: ok
13:32:43 <phobes> newsham:  Did you see this? http://www.vpri.org/pdf/packrat_TR-2007-002.pdf
13:33:02 <bos> thoughtp1lice: was that a question? i'm a bit confused.
13:33:10 <phobes> It was linked from the wikipedia - I've not read it
13:37:21 <newsham> ph: no.  ty
13:38:36 <newsham> i think generally I prefer more general specifications, not less general ones that require more work on the developer to massage their specification into the proper form.
13:38:47 <newsham> since that massaging is done by hand and can lead to mistakes
13:39:17 <newsham> ie. GLR > LALR > LL(k)  (roughly)
13:40:25 <ddarius> newsham: You have to massage CFGs often times for practical reasons anyway.
13:40:53 <dons> ?yow!
13:40:54 <lambdabot> I can't think about that.  It doesn't go with HEDGES in the shape of
13:40:54 <lambdabot> LITTLE LULU -- or ROBOTS making BRICKS ...
13:40:57 <phobes> ya, I don't think PEGs are subsumed by LL(k) until LL(oo)
13:41:13 <phobes> or LR even
13:41:24 <dons> who's going to realease what cool new killer app for haskell today?
13:41:37 <ddarius> You don't see additive ::= factor | additive + additive | additive - additive
13:42:19 <dons> so what's happening with parsec3? where are all these performance rumours coming from?
13:42:46 <phobes> dons:  Are they rumors of high or low performance?
13:43:08 <dons> wobbly performance. do we have a parsec performance czar?
13:43:15 * dons thinks we need more library czars 
13:43:28 <ddarius> dons: There are quite a few potential routes for optimizing Parsec's performance.
13:43:42 <dons> is anyone looking at this?
13:44:21 <olsner> let's just say parsec3 did not make me crap my pants ;-)
13:44:36 <olsner> maybe a luke-warm woo
13:44:37 <dons> hmm. that's the main metric for library success though.
13:44:55 <olsner> yep, it was what I had hoped for
13:45:01 <olsner> *that was
13:45:05 <dons> indeed. hmm.
13:45:25 <dons> i wonder how we can churn out more killer library writers.
13:45:27 <ddarius> dons: The issues are recognized.  I haven't been doing much actual coding but ideas and data are collecting.
13:45:35 <dons> ddarius: is there a todo file?
13:45:48 <dons> just documenting issues is a good start, at least
13:46:46 <ddarius> dons: I could make one and there are some comments in the source files if I remember correctly, but it's not so much a TODO list as a TOTRY.
13:46:58 <olsner> the difficult thing with parsec is that it's virtually impossible for me to start with my parser, test case and profiling output, and see what's wrong with either the grammar or parsec
13:47:05 <olsner> (for me, that is)
13:47:23 <dons> i'd imagine you'd have to build it up piecewise, checking performance as you go.
13:47:32 <ddarius> The good news is, there is no doubt plenty of low hanging fruit to get some good performance gains.
13:47:41 <dons> yeah, that seems reasonable
13:48:23 * dons puts away libraries whip, and goes back to book writing.
13:49:17 <kiris> dons: Real World Haskell looks awesome!
13:49:46 <dons> i hope so. :) though we should be forking off other authors now for next year's haskell books.
13:49:57 <dons> haskell for parallel programming, haskell for scientific apps, haskell for the web.
13:50:09 <dons> haskell for crushing your enemies
13:50:15 <Syzygy-> I wanna merge the first and second!
13:50:18 <thoughtp1lice> haskell for compilers :)
13:50:23 <Syzygy-> Haskell for parallelized scientific computing!
13:50:29 <dons> right. a compilers book would be quite nice, imo.
13:50:37 <dons> Modern Compiler Implementation in Haskell
13:50:45 <Syzygy-> Throw in a helping of computational algebra and give me a postdoc in Galway, and -I'll- write it. ;)
13:50:53 <dons> bring compiler writing into the 21st century
13:51:12 <olsner> haskell for parallelized crushing of enemies ;-)
13:51:15 <dons> "Parallel purely functional data structures"
13:51:40 <dons> "Crushing your enemies with 21 different concurrency techniques"
13:51:51 <Syzygy-> "GrÃ¶bner bases for world domination"
13:51:55 <dons> "How not to suck like Twitter: scalable, parallel web apps in Haskell"
13:52:03 <dons> :D
13:52:34 <shachaf> "Haskell crushing your enemies lazily"
13:52:50 <shachaf> s/c/for c/
13:54:07 <olsner> a compilers-in-haskell book sounds really good though; most of the introductory compiler material I've seen assumes that you're writing the compiler in an imperative language
13:54:19 <dons> yeah. Appel's ML book is the main FP one.
13:54:27 <dons> but even that's a bit outdated, and ML-ish.
13:54:39 <dons> no compilation by typed transformation stuff
13:55:03 <dons> oh, its 10 years old , too. http://www.cs.princeton.edu/~appel/modern/ml/
13:55:03 <lambdabot> Title: Modern Compiler Implementation in ML
13:55:09 <dons> time for a 21st century compiler book.
13:55:39 <shachaf> "Haskell for sufficiently smart compilers"
13:57:23 <olsner> hmm, and IMO it shouldn't use lexer/parser *generators* ... parser combinators are the future
13:58:21 <solrize_> multi-stage compilation yum
13:58:28 <solrize_> for parser combinators
14:00:37 <solrize_> dunno if that's different from a parser generator...
14:01:24 <dons> i don't know of any non-toy compiler that uses parser combinators for its real lexer or parser.
14:01:29 <dons> anyone know of an example?
14:01:46 <dons> parser combinators are more often used for either small things, or difficult corner cases
14:03:27 <olsner_> that's unfortunate... maybe parser combinators aren't ready for prime-time yet?
14:03:30 <solrize_> looks like cpphs uses parselib
14:03:46 <solrize_> which appears to be some kind of forerunner of parsec
14:04:38 <dons> olsner_: sure they are. not every prime time thing needs to be optimised within an inch of its life.
14:05:05 <dons> just replacing half the regex programs out there with parser combinators is a good step
14:05:12 <olsner_> well, prime time as in useful in a real-life compiler
14:05:23 <ddarius> Parser combinators are more convenient for smaller things as they are "lighter weight"
14:06:02 <dons> so in a gcc-compliant parser developed at unsw, we used a parser generator for the core ansi C stuff, and dropped out to a parser combinator parser for the tricky gcc extensions
14:06:05 <solrize_> is there a real obstacle to optimizing parser combinators tow within an inch of their lives?
14:06:10 <buff_dri1kslot> is reddit down?
14:06:11 <ddarius> Parser generators make some things simpler, can catch more types of errors/issues and should never generate slower parsers.
14:06:19 <dons> that kind of balance of efficiency, for known grammars, and convenience for tricky things, seems like a good approach
14:06:37 <dons> buff_dri1kslot: maybe
14:06:47 <buff_dri1kslot> awww
14:07:51 <ddarius> solrize: You certainly could optimize parser combinators quite a bit, but if you really want speed, you'd want to use a parser generator.
14:09:49 <solrize_> i'm not sure if i get the difference, if optimizing parser combinators basically means sending the composed combinator back through the compiler to turn it into native code
14:10:24 <solrize_> which CPS optimizations and all that good stuff
14:10:59 <ddarius> solrize: Worse case scenario, a parser generator could generate code using parser combinators.  In practice, parser generators can do more.
14:11:34 <olsner> I'm thinking we're just still looking for the kind of combinator language that will allow sufficiently smart parser combinators ... using only parser monads places some limits on what you can do to the combinator-described grammar (I have read about arrow-based parsers, but they don't seem to have caught on)
14:12:17 <ddarius> You could make parser combinators that build up a representation of the grammar (and indeed this is how a parser combinator library related to pappy works).
14:14:03 <solrize_> then run it through a parser generator?
14:14:39 <ddarius> solrize: You'd do some of the same things that a parser generator does, but at run-time.
14:14:50 <solrize_> i'm used to old time parser generators (viz. yacc) that only handle a certain class of grammar that's recognized by a boilerplate state machine that the parser generator makes tables to run
14:15:59 <dcoutts> TomMD: you said you were getting weird behaviour with cabal-install. Care to elaborate?
14:16:43 <ddarius> solrize: You can represent state machines with a collection of mutually recursive functions, which usually is a speed gain (but often an increase in space usage).
14:16:57 <gubagem> is vim decent for writing haskell code?
14:17:07 <ddarius> It's what many people here use.
14:17:25 <ddarius> There's a fairly feature-ful mode as well made by Claus Reinke (which I don't use).
14:17:35 <gubagem> i was using edit.com(the dos program) and notepad but ive grown tired of them
14:19:21 <ddarius> gubagem: Try vim.  Go through the vimtutor; unless you have some desiderata for an editor, then there may be other options that might appeal to you more.
14:19:55 <gubagem> ive used vim a bit
14:20:12 <gubagem> im no vim master, i just know the basics, used to use it for scheme at times
14:20:26 <Jaak> vim support is okay
14:20:47 <jmelesky> on the flip side, you should try emacs
14:20:50 <gubagem> ive tried learning emacs quite a few times, but none of it sticks
14:20:59 <Jaak> the vim mode isn't exceptionally good, but still usable
14:21:12 <jmelesky> like any foreign language, immersion is the key to learning emacs
14:22:03 <gubagem> screen+vim works really nice on nix
14:24:16 <dons> mm, this is kind of cool, http://haskell.org/haskellwiki/Fibonacci_primes_in_parallel
14:24:17 <lambdabot> Title: Fibonacci primes in parallel - HaskellWiki
14:24:21 <noecksit> hello, i already have a readerT implemented with one environmental variable and i would like to add another, would it be easier to to add another readerT instance, or just make the argument be (env1,env2)?
14:24:25 <dons> nice to see simple parallel haskell programs like that
14:24:55 <ddarius> noecksit: The latter.
14:25:28 <gubagem> interesting .."In addition only the elements with prime indices in the sequence are considered due to known properties of Fibonacci numbers."
14:25:31 <noecksit> ddarius: oh ok
14:26:15 <ddarius> gubagem: Yeah, sounds like a fun thing to prove.
14:26:56 <noecksit> but then the thing is that when I do "asks " i would always get a tuple of the two environmental variables, right?
14:27:02 <dons> its interesting that there are only 40 known fib primes, but we can get to 30 of them in less than a day. i wonder how long it takes a 4 core machine to find all 40 ...
14:27:31 <ddarius> noecksit: Yes.  Just do asks fst/asks snd
14:27:58 <ddarius> Alternatively, you may want to stick these environment variables into a record.
14:28:25 <noecksit> ddarius : like in a finite Map?
14:30:00 <ddarius> No, like in a record. http://www.haskell.org/tutorial/moretypes.html
14:30:00 <lambdabot> Title: A Gentle Introduction to Haskell: Types, Again
14:30:20 <ddarius> See section 6.2
14:31:25 <ddarius> If you expect the environment variables to be added/removed then a Map may be appropriate.
14:31:57 <noecksit> oh i see
14:34:08 <gwern> I have to say, my love of ubuntu is cooling as I discover why a read-only / sucks so much
14:34:44 <gubagem> you running a one-cd ubuntu, or is that true for ubuntu in general
14:35:01 <gwern> in general; ubuntu has taken a disliking to my hard drive
14:35:33 <gwern> unless my hard drive decided to start throwing intermittent errors the very day I switched from gentoo to ubuntu... I think I'm going to blame this one on ubuntu
14:35:52 <gwern> and #ubuntu is being stunningly unhelpful (which makes me appreciate #xmonad and #haskell all the more)
14:37:49 <gubagem> did you reformat your drive?
14:39:13 <gwern> no; I think the only thing I might've done is change ext3's writeback settings in fstab, but the error appears long before fstab ever comes in play, e2fsck reports no errors, and I saw similar errors before I finished installing buntu. so it probably wasn't that
14:41:07 <gwern> oh well. I suppose I'd better try another reboot.
14:45:21 <Bonus> lol look what got into the planet haskell feed http://www.wellquite.org/derelict_sky.html
14:45:22 <lambdabot> Title: Well Quite
14:55:15 <RayNbow> can someone tell me what happened with reddit?
14:55:51 <roconnor> @unpl ap
14:55:51 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
14:56:06 <roconnor> @unpl ap f g z
14:56:06 <lambdabot> (f >>= \ b -> g >>= \ a -> return (b a)) z
14:56:17 <Bonus> yeah lol reddit got all doubled up
14:56:29 <roconnor> :/
14:56:34 <roconnor> @type . unpl ap f g z
14:56:51 <lambdabot> thread killed
14:57:09 <roconnor> @type \f g z -> (f >>= \ b -> g >>= \ a -> return (b a)) z
14:57:25 <lambdabot> thread killed
14:57:34 <roconnor> lambdabot: screw you
14:57:51 <kiris> RayNbow: aha, "DO NOT WANT! BRING BACK OLD REDDIT NOW! (self.reddit.com)"
14:58:15 <Bonus> all the reddit entries got duplicated in my feed reader
14:58:22 <Bonus> did this happen to anyone else?
15:01:07 <dons> haha, we know who quhaha is now.
15:01:30 <dibblego> dons, how and who?
15:01:57 <RayNbow> @src ($)
15:01:57 <lambdabot> f $ x = f x
15:02:56 <roconnor> @pl (\f g h -> (f `le` g) `imp` (g `le` h) `imp` (f `le` h))
15:02:56 <lambdabot> ap (flip . (liftM2 imp .) . (`ap` le) . (((.) . imp) .) . le) le
15:03:20 <roconnor> @pl (\f g h -> (f `le` g) `imp` ((g `le` h) `imp` (f `le` h)))
15:03:20 <lambdabot> ap (ap . (((.) . imp) .) . le) (flip (ap . (imp .) . le) . le)
15:04:10 <Bonus> what's `imp`
15:04:16 <roconnor> implies
15:04:29 <Bonus> @src imp
15:04:29 <lambdabot> Source not found. You untyped fool!
15:04:36 <Bonus> welp
15:04:39 <kiris> :t imp
15:04:46 <Bonus> what does it do
15:04:50 <roconnor> Bonus: (<=)
15:04:54 <lambdabot> thread killed
15:05:04 <roconnor> > True <= False
15:05:04 <Bonus> aah
15:05:11 <Bonus> implication
15:05:19 <lambdabot>  thread killed
15:05:23 <roconnor> @undefine
15:05:31 <lambdabot> Undefined.
15:05:34 <roconnor> > True <= False
15:05:36 <lambdabot>  False
15:05:44 <roconnor> > False <= True
15:05:46 <lambdabot>  True
15:05:51 <roconnor> > False <= False
15:05:52 <lambdabot>  True
15:05:58 <Bonus> ah, yase
15:05:59 <roconnor> > Ture <= True
15:06:00 <lambdabot>   Not in scope: data constructor `Ture'
15:06:47 <Bonus> a => b is equivalent to not (a or b), right?
15:07:08 <Saizan> (not a) or b
15:07:25 <Bonus> ah, yeah
15:07:37 <dcoutts> @quickcheck \a b -> (not a || b) == (a => b)
15:07:37 <lambdabot> Unknown command, try @list
15:07:43 <dcoutts> @list
15:07:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
15:08:00 <dcoutts> @check \a b -> (not a || b) == (a => b)
15:08:00 <lambdabot>  Parse error at "=>" (column 28)
15:08:05 <dcoutts> doh
15:08:40 <roconnor> @check \a b -> (not a || b) == (a >= b)
15:08:45 <lambdabot>  Falsifiable, after 1 tests: False, True
15:08:46 <ddarius> (f <= g) <= (g <= h) <= (f <= h)
15:08:51 <roconnor> @scheck \a b -> (not a || b) == (a >= b)
15:08:53 <lambdabot>   Failed test no. 2. Test values follow.: True, False
15:08:58 <roconnor> @scheck \a b -> (not a || b) == (a <= b)
15:09:00 <lambdabot>   Completed 4 test(s) without failure.
15:09:39 <roconnor> @scheck (f <= g) <= ((g <= h) <= (f <= h))
15:09:40 <lambdabot> Add a type signature
15:09:49 <roconnor> @scheck \f g h -> (f <= g) <= ((g <= h) <= (f <= h))
15:09:50 <lambdabot>   Completed 1 test(s) without failure.
15:10:12 <RayNbow> say, the Eq class contains "x /= y                =  not (x == y)"  and if you declare some type to be in the Eq class, you can suffice by only defining (/=) or (==) because of this definition in the Eq class... but how exactly does the Haskell compiler "reverses" the definition?
15:10:41 <dcoutts> RayNbow: using the default definitions for the Eq methods
15:10:44 <dcoutts> @src Eq
15:10:44 <lambdabot> class  Eq a  where
15:10:44 <lambdabot>     (==), (/=)   :: a -> a -> Bool
15:10:51 <dcoutts> oh, it doesn't show them
15:10:56 <ddarius> @src (==)
15:10:56 <lambdabot> x == y = not (x /= y)
15:11:00 <ddarius> @src (/=)
15:11:01 <lambdabot> x /= y = not (x == y)
15:11:01 <Bonus> it defines a == b as not (a /= b)
15:11:02 <Bonus> yeah
15:11:02 <RayNbow> dcoutts: I know, but I'm more interested in the details
15:11:29 <dons> dcoutts: got that 4 core box yet?
15:11:33 <dcoutts> dons: yep
15:11:34 <ddarius> RayNbow: There are no details.
15:12:22 <dcoutts> dons: first thing is to do package builds in parallel with cabal-install :-)
15:12:27 <hpaste>  dons pasted "fib primes, 4 core" at http://hpaste.org/7907
15:12:39 <dons> dcoutts: might be fun to see if you can get  that up near 400% cpu utilisation
15:12:50 * dcoutts tries
15:14:29 <RayNbow> ddarius: ah, n/m... the page I was using as a reference only displayed a part of the Eq class definition
15:15:20 <dcoutts> dons: actually only ~80% utilisation on 4cores
15:15:28 <dons> that's weird. i get 305%
15:15:42 <dcoutts> dons: that's 80% on each core
15:15:53 <dons> oh, ok. so 320% total?
15:16:05 <dcoutts> yep, thereabouts
15:16:09 <dons> ok. reasonable
15:16:43 <roconnor> @hoogle parBuffer
15:16:47 <lambdabot> Control.Parallel.Strategies.parBuffer :: Int -> Strategy a -> [a] -> [a]
15:16:47 <dcoutts> I wonder what it's doing the rest of the time
15:17:00 <roconnor> @hoogle rnf
15:17:00 <lambdabot> Control.Parallel.Strategies.rnf :: NFData a => Strategy a
15:18:36 <dejones> byorgey: this might be useful to you for your talk: http://www.kennknowles.com/blog/2008/04/16/drawing-fractals-in-haskell-with-a-cursor-graphics-dsel-and-a-cute-list-representation/
15:18:37 <luite> is there a manual for the unix package (from hackage) installation? I'm trying to install it on windows using cygwin, configure succeeds, but it cannot find the required includes anymore when building, I guess it's using a different compiler or something
15:18:38 <lambdabot> Title: Mathematical Pamphlet » Drawing fractals in Haskell with a cursor graphics DSEL  ..., http://tinyurl.com/6gzfgp
15:19:56 <dons> there you go, since this is such a nice little program, http://www.reddit.com/info/6kuz2/comments/
15:20:07 <khafra> I've been trying to learn a bit of functional programming for the last few weeks, and find it unnatural to force my brain into that type of thought.  Is it mostly meant for mathematicians, already trained to think functionally?  Or is it a really valuable exercise for joe sixpack?
15:20:09 <dcoutts> luite: cygwin will really not help you I think
15:20:20 <dcoutts> luite: the ghc build is native, not a cygwin prog
15:20:44 <luite> dcoutts: won't it link with cygwin things?
15:20:55 <dcoutts> luite: no, it has its own gcc
15:21:02 <luite> hm :(
15:21:14 <luite> guess I cannot run dons' sample then
15:21:25 <dons> khafra: its just a generally useful way of thinking about programming.
15:21:38 <dons> i doubt many mathematicians actually do much haskell programming, so its not for them.
15:21:43 <dcoutts> khafra: it's a valuable exercise for any programmer who cares about programming
15:22:26 <dons> teach people to think above the level of the raw machine, and you learn to exploit more interesting properties and abstractions in your code.
15:22:38 <mauke> khafra: what programming languages do you know?
15:22:50 <RayNbow> khafra: Haskell will most likely make you hate your currently favorite language for missing certain features :p
15:23:08 <luite> dcoutts: the description does say that it should work with cygwin, so I'd have to rebuild the whole ghc for that?
15:23:09 <khafra> I'm not a fluent developer in any, but I'm taking a class that includes some javascript right now
15:23:27 <dcoutts> dons: I came across a great example of that yesterday: citeseer.ist.psu.edu/nordin01modular.html
15:23:46 <khafra> Since the homework problems have some flexibility built in, and I'm already pretty comfortable with javascript, I thought I'd do 'em functionally.
15:23:47 <dons> well, javascript is a partially functional language
15:23:49 <dcoutts> dons: this was in the context of the new package dep resolver I'm working on
15:23:58 <dons> so you'll be able to exploit more javascript if you learn more FP in general
15:24:00 <kiris> khafra: joe sixpack? http://chrisdone.com/abs.gif
15:24:15 <dons> mm, interesting dcoutts
15:24:33 <khafra> kiris: Exactly, the programming language he'll be able to accomplish the most in
15:24:37 <dons> nordin works as a contractor for galois, btw, dcoutts
15:24:45 <dcoutts> dons: really? I didn't know
15:24:52 <dons> lives in the bay area now, iirc
15:25:08 <dcoutts> dons: he found that the functional presentation of all these classic search algorithms turned out to be so much clearer and more compositional
15:25:21 <dcoutts> allowing one to easily test and combine strategies
15:25:43 <dcoutts> I'm trying to follow that approach for the cabal dep resolver
15:25:43 <dons> mm, finding the primes above 25 is much faster when you've got extra cores available
15:25:59 <kiris> khafra: if he's not so bright perhaps he would prefer it if his code was pure, so he didn't have to hold loads of variables in his head at once to reason about it, and strict typing to make sure it's all the correct place for him
15:26:29 <dcoutts> dons: for me, the limitation on parallelism is the noise of my cpu fan
15:26:43 <Igloo> lol
15:26:46 <dons> heh
15:27:05 <dcoutts> when all 4 cores crank up it sounds like it's going to take off
15:27:13 <dcoutts> clearly I need a new cpu cooler
15:27:18 <dons> kiris: yeah, sometimes i'm amazed at how much state people happily accept in their heads when reasoning about imperative code
15:27:27 <dons> dcoutts: i need to get rl to turn serenity back on.
15:27:36 <dcoutts> dons: heh
15:27:47 <dcoutts> now that is a monster
15:27:53 <dons> i think it wa a bit unstable though ,due to all the heat
15:28:02 <dons> used to shutdown after 10pm when the air con in the room went off
15:28:04 <khafra> kiris: heh, cool.  I still just find it difficult to even do something simple like trace the logic of a recursive function call to find why it's printing "15" instead of the product of all odd numbers from 1..15
15:28:11 <dcoutts> dons: my research group are getting a server like that, but 4 sockets with 4 cores per socket
15:28:38 <ddarius> khafra: All you need is middle school knowledge.  You just replace equals with equals.
15:28:50 <edwardk> One last Kan extension post up. that should set me free of that topic for a while =)
15:29:22 <kiris> khafra: I believe that haskellers tend not to write recursive functions but prefer to use higher order functions. e.g. map, foldr, list comprehensions, etc
15:29:26 * ddarius thinks up some more esoteric branches of CT.  He's already mentioned Eilenberg-Moore algebras.
15:29:32 <edwardk> ddarius: lol
15:29:53 <kiris> khafra: what I mean is, you don't often have to deal with loads of different recrusively written functions in good code
15:30:08 <edwardk> ddarius: i'm tempted to do more with elgot (co)algebras actually
15:30:17 <dcoutts> dons: I'm not sure it's contesting for cpu time. I was getting each core not being fully loaded, system wide. Not just for the one process.
15:30:50 <dcoutts> dons: I'm referring to the last sentence on the wiki page you refer to
15:31:09 <dcoutts> "Note that this program runs at around 300% cpu utilisation, despite having 4 cores, as we're contesting for cpu time on this machine."
15:31:13 <khafra> kiris: So, in a more-functional language like Haskell or OcaML, there's less recursion to do than in javascript?
15:31:17 <kiris> khafra: e.g. surely you would just write product [1..4], or if you didn't have product, you would use foldr1 (*) [1..4]. do you know what I mean?
15:32:18 <dibblego> kiris, foldl1 more likely
15:32:24 <mauke> foldl'
15:32:30 <khafra> Sure; so the structures that need either an imperative loop or a recursive call at the lower levels disappear in higher levels?
15:32:45 <dibblego> > foldl' (*) 1 [1..4]
15:32:47 <kiris> yeah
15:33:01 <lambdabot>  thread killed
15:33:02 <dons> dcoutts: oh, right. so i definitely was contesting for 1 core though.
15:33:08 <dons> someone else was running a simulation
15:33:15 <dons> that said, likely it seems its not using 100% anyway
15:33:28 <dcoutts> dons: right, which is interesting.
15:33:37 <dons> i wonder what the gc stats look like
15:33:45 <kiris> khafra: and you can plug those things together
15:35:31 <dons> very little gc time.
15:35:36 <dons> 0.2%
15:35:44 <dons> mm, Productivity  99.8% of total user, 198.2% of total elapsed
15:35:52 <dons> 198.2% <-- haven't seen that before
15:36:39 <kiris> khafra lost interest??
15:36:52 <edwardk> ddarius: i sat down and encoded operads most of the way the other night using various HList like tricks. i suppose i could finish that ;)
15:37:03 <edwardk> ddarius: but I have yet to see a practical use for them in Haskell.
15:38:05 <kiris> > matchRegex (mkRegex ".*") "test"
15:38:06 <lambdabot>   Not in scope: `mkRegex'
15:38:15 <kiris> =(
15:38:34 <kiris> > Text.Regex.matchRegex (Text.Regex.mkRegex ".*") "test"
15:38:35 <lambdabot>   Not in scope: `Text.Regex.mkRegex'
15:38:46 <kiris> dang it!
15:38:55 <ddarius> edwardk: Why not generalize to multicategories?
15:40:53 <edwardk> ddarius: that is something i've been trying to figure out. Multicategories run into kinding issues though. I need universe polymorphism I believe to do that justice though. I do think I can get multifunctors right though.
15:42:04 <edwardk> er s/though//
15:42:33 <ddarius> edwardk: Just generalize all your stuff to arbitrary two categories, make the 2-category of T-spans in Set and then make a monad in that 2-category.
15:43:10 <edwardk> 2-categories isn't bad. HFunctors take me basically there already.
15:43:37 <ddarius> Hmm
15:44:03 <edwardk> I have HFunctors. HMonads, HComonads, etc. which are basically functors and monads over 1-cells.
15:44:54 <edwardk> hreturn :: Nat a (f a); hfmap :: Nat a b -> Nat (f a) (f b)  etc.
15:45:51 <edwardk> this lets me define a higher order generalized hylomorphism which i have yet to find a use for, but hey it sounds cool ;)
15:46:02 <ddarius> Bah, Span loses too much type information.
15:47:06 * ddarius tries to remember the other way of defining a multicategory.
15:47:37 <edwardk> I tripped over a primer on the topic, there does appear to be quite the zoo of these things.
15:49:55 <wolgo|away> @src tail
15:49:56 <lambdabot> tail (_:xs) = xs
15:49:56 <lambdabot> tail []     = undefined
15:50:21 <wolgo|away> I feel like that should have been obvious
15:50:29 <Bonus> hehe
15:50:35 <wolgo|away> and that I should not have looked at the source to figure out what it did
15:50:44 <edwardk> heh
15:50:47 <Bonus> no harm in looking at the source
15:50:48 * wolgo|away facepalm, duh
15:51:00 <Bonus> i keep the haskell 98 prelude open a lot
15:51:06 <Bonus> sometimes i just skim through it when im bored
15:51:29 <ddarius> wolgo|away: There are a lot of functions of type [a] -> [a].
15:51:59 <wolgo|away> hoogle here I come!
15:52:25 <wolgo|away> oh wow
15:52:27 <wolgo|away> there are
15:52:49 <mauke> @hoogle [a]->[a]
15:52:49 <wolgo|away> oh man I have my other box with my normal nick logged in
15:53:01 <wolgo|away> Can somone kick wolgo
15:53:04 <lambdabot> Prelude.tail :: [a] -> [a]
15:53:04 <lambdabot> Prelude.init :: [a] -> [a]
15:53:04 <lambdabot> Prelude.reverse :: [a] -> [a]
15:53:06 <mauke> won't help
15:53:11 <mauke> nicks are network-global
15:53:29 <wolgo|away> oh ok
15:53:40 <mauke> and apparently you haven't registered your nick so NickServ can't help you
15:55:53 <chessguy> 'evening #haskell citizens
15:56:21 <Bonus> salut
15:56:50 <hpaste>  morrow pasted "oh snap!" at http://hpaste.org/7908
16:02:48 <roconnor> @hoogle randomRIO
16:02:55 <lambdabot> System.Random.randomRIO :: Random a => (a, a) -> IO a
16:03:54 <saml> > randomRIO (1,2)
16:04:10 <lambdabot>  thread killed
16:05:49 <ddarius> wolgo|away: DoS your other machine.
16:23:38 <hpaste>  morrow annotated "oh snap!" with "!" at http://hpaste.org/7908#a1
16:29:47 <hpaste>  morrow annotated "oh snap!" with "simplified" at http://hpaste.org/7908#a2
16:54:02 <mauke> http://dis.4chan.org/read/prog/1211824162/
16:54:05 <lambdabot> Title: 4chan BBS - Excel Formula Help
16:55:00 <jdrake> Is that 4chan the same one in the news a few months back?
16:55:16 <mauke> dunno, what news?
16:58:57 <jdrake> I thought it was one of the sites involved in the 'anonymous' protest the Holy Church of Scientology.
16:59:24 <dmwit> yeah
16:59:36 <dmwit> The different sections of 4chan have very different personalities.
16:59:39 <mauke> oh, that
17:00:16 <jdrake> Imagine trying to give the church a bad name...
17:00:21 <jdrake> I don't think the church needs help
17:01:06 <ivanm> hang on, I thought 4chan _hated_ haskell ;o
17:01:36 <jdrake> Quick! Write some blogging software in haskell
17:01:40 <EvilTerran> jdrake, yes, some people who post on 4chan also went to the protests. the protests are not endorsed by any of the *chans, though
17:01:41 <mauke> not if it's used for trolling
17:01:43 * dmwit didn't realize they had a stance on Haskell.
17:02:15 <EvilTerran> and, from what i've seen from my occasional dip into such places, those who have an opinion on the matter seem to actually quite like haskell
17:02:27 <ivanm> dmwit: well, the whole xmonad wikipedia page controversy arose because some people on 4chan talked about "wtf is this haskell shit doing there", or something like that
17:02:56 <jdrake> xmonad conroversy? Do tell :-)
17:03:04 <dmwit> If by "some people", you mean "some one guy", then yes...
17:03:16 <ivanm> jdrake: someone put xmonad's article up for deletion a couple of times because it wasn't notable enough
17:03:19 <EvilTerran> of course, there's enough morons who hate everything they don't know to drown out the people who actually care, but that's primarily because they're much more vocal individually, i suspect
17:03:29 <ivanm> even though there were other WM articles with only a 1-line description
17:03:39 <ivanm> dmwit: I thought it was more than one person egging him on...
17:03:51 <ivanm> jdrake: and the guy that did so created a new account just for it...
17:03:58 <dmwit> I would hardly call that a stance.
17:03:59 <ivanm> because apparently he uses haskell :s
17:04:03 <jdrake> A lot of wikipedian politics seem arbitrary these days.
17:04:06 <ivanm> dmwit: maybe
17:04:21 <ivanm> hmmm.... what happened to knoll? google's wikipedia...
17:04:25 <dmwit> 4chan's /b/ would encourage *any* disruptive behavior; it's not a comment on Haskell, I think.
17:04:55 <ivanm> dmwit: ahhh
17:05:30 <jdrake> ivanm, I caught my school's marketing department modifying their entry on wikipedia. I 'fixed' it quite well. Now people know about a nasty little controversy that the college would much rather people not be reminded of (they destroyed a piece of art), and of course a mention of how much alcohol provides 'boisterous' entertainment in residence :-)
17:06:08 <ivanm> heh
17:06:34 <jdrake> If interested: http://en.wikipedia.org/wiki/Lambton_College  :-)
17:07:03 <jdrake> The picture of the logs that is below is a picture I took (although the school wouldn't know that) of the remains of the piece of art, of which they are being sued over.
17:07:27 <jdrake> Apparently if you commission a piece of art, the artist still has 'moral rights' to it (i.e. you can't just destroy it)
17:07:55 <ddarius> Oh?  Watch them.
17:07:57 <ivanm> jdrake: that's just crazy...
17:08:12 <lament> it makes sense
17:08:18 <ivanm> sounds like that 5 yo that wants to sue his friend because he gave away a drawing he gave him
17:08:45 <lament> jdrake: i don't think "degregate" is a word
17:08:49 <ivanm> jdrake: you saying that the artist only licensed the artwork to them, not sold it? :p
17:09:20 <dmwit> desecrate, denigrate are close
17:09:32 <jdrake> ivanm, no the school owned it, but there was a court ruling before about destroying art without consulting the artist.
17:09:42 <ivanm> wtf?
17:10:04 <ivanm> he no longer owns it, why should it make a difference to him?
17:10:19 <dmwit> Well, it still represents him.
17:10:20 <EvilTerran> i guess he was expecting free marketing from it being on display indefinitely
17:10:23 * ivanm makes a grand plan to buy the mona lisa and destroy it, just to prove a point :p
17:10:31 <ivanm> EvilTerran: yeah
17:10:33 <dmwit> I don't agree wiht htis satnce, but I can see where it comes from.
17:10:54 <lament> ivanm: he doesn't own the physical object, but he does own the "work of art"
17:10:55 <jdrake> degrading would be the word, I shall correct
17:11:12 <ivanm> lament: that's just crazy
17:11:46 <jdrake> ivanm, I am not sure I agree with it, but there is a certain logic to it
17:11:55 <chessguy> what in the world are we talking about?
17:11:58 <EvilTerran> intellectual property!
17:12:14 <chessguy> ...
17:12:14 <jdrake> chessguy: moral rights to art
17:12:20 <chessguy> doesn't that belong in -blah?
17:12:23 <ivanm> so it's not just SW companies with crazy things about ownership...
17:12:31 <jdrake> http://en.wikipedia.org/wiki/Moral_rights
17:12:32 <ivanm> chessguy: probably ;-)
17:12:37 <TSC> They're talking about Haskell in -blah
17:12:56 <ivanm> heh
17:13:00 <chessguy> ah, such a sorry state the world is in
17:13:04 <mauke> tell them they're off-topic
17:13:39 <jdrake> You desire a cease of moral conversation?
17:13:53 <lament> ivanm: attribution certainly makes sense
17:13:56 <lament> just cause you bought my statue
17:13:59 <jdrake> ""Section 14.1(1) of Canada's Copyright Act protects the moral rights of authors. The moral rights cannot be assigned, but can be waived contractually. Many publishing contracts in Canada now contain a standard moral right waiver.""
17:14:03 <lament> doesn't mean you can say you made it
17:14:27 <ivanm> lament: no, but if you own the physical item than you should be able to do what you want with it
17:15:03 <lament> ivanm: why?
17:15:15 <lament> ivanm: it's not a physical item, it's a work of art.
17:15:28 <lament> you own a physical item, but the artist has moral rights to his work of art.
17:15:52 <lament> humans are physical items yet they're remarkably special-cased by law
17:15:55 <lament> as are explosives
17:15:56 <lament> etc
17:16:10 <ivanm> how does morality (i.e. good, evil, etc.) come into blocks of wood?
17:17:13 <EvilTerran> through the hole i just made with my trepanning drill :P
17:17:24 <ivanm> heh
17:17:43 <lament> ivanm: if your biggest objection is the name, things can't be all that bad :)
17:18:21 <SamB> I don't think you can claim that a block of wood is a work of art unless you made it in a really unusual way
17:19:06 <SamB> for instance, if it was produced without using plants, or if you used some kind of 3d imaging to choose where to cut it out of a larger piece of wood...
17:19:12 <lament> SamB: sure you can claim it
17:19:14 <lament> you can claim anything
17:19:23 <lament> the trick is to get somebody to buy it from you as such
17:19:35 <SamB> hmm, okay
17:19:36 <lament> if they buy it as a work of art, it must have been a work of art and your moral arts are protected.
17:19:42 <lament> er, moral rights
17:20:05 <SamB> well, if I buy wood at the lumber yard, I don't expect anyone to chase after me asserting moral rights, is all ;-)
17:21:37 <EvilTerran> "some kind of 3d imaging" - one's imagination, perhaps?
17:22:05 <jdrake> Keep in mind that you can be made to have a moral rights waiver.
17:23:16 <jdrake> Does haskell have a mechanism to have dynamically loading modules?
17:23:24 <jdrake> or some kind of a plugin system possible?
17:23:36 <dons> jdrake: there are a few, though none currently entirely satisfactory
17:23:55 <dons> plugins, dynamically loaded modules, byte code interpreted modules etc are all supported to lesser or greater degrees
17:24:10 <dons> we do need a plugins czar though,  to drive development of a new plugins api
17:26:56 <Apocalisp> Where might I find the anamorphism laws stated?
17:28:08 <jdrake> I am curious how effective a program could be in haskell for the purposes of running a blog. The machine itself has a 64mb memory limit (it is a virtual machine), with about 128mb swap. It would generally be nice to keep it well under 32mb of usage, and it needs to be generally fast (wordpress is a dog some times, which is in php).
17:28:34 <dons> jdrake: i'd expect you could happily server up hundreds of req/sec in say, 2-3M resident heap
17:28:52 <dons> its a pretty simple task, and there's lots of frameworks out there for htis kind of thing
17:29:13 <jdrake> I have to refamiliarize myself with haskell :-)
17:29:15 <Zao> I ought to bench my offline blog sometime.
17:30:25 <dons> can i ask why you were focusing on memory requiremnts from the outset?
17:30:38 <dons> is it just that php things tend to be poor, or you thought haskell would be problematic here?
17:30:45 <chessguy> offline blog?
17:31:05 <chessguy> isn't that like a screen door on a submarine?
17:31:16 <SamB> dons: haskell programs aren't known for their low heap usage
17:31:31 <jdrake> dons: The memory requirements are mainly because this machine is a low memory machine.
17:32:07 <SamB> and, yes, most people have more than 64 MB of RAM these days
17:32:10 <dons> SamB: really? i'm surprised. xmonad, shootout things, stuff at work, memory is never the problem.
17:32:24 <SamB> dons: probably so
17:32:58 <SamB> but, well, look at JHC, Agda2 ...
17:33:24 <dons> sure, you can write huge monsters if you want, in any language.
17:33:30 <dons> mozilla, open office, ...
17:33:37 <SamB> true enough
17:33:45 <solrize_> i don't see why haskell should inherently need a lot of heap if you're not making too many unevaluated thunks.  it's just a lambda calculus evaluator and there are some lisp systems that are tiny.
17:33:48 <dons> serving up content isn't one of those monstrous tasks
17:33:48 <jdrake> What kind of design would make sense for a blog software in haskell?
17:34:16 <dons> serve up files over fastcgi tossing them out to the network?
17:34:22 <SamB> I think Agda2, at least, is much nicer than Mozilla or OO...
17:34:49 <dons> ghc's in the lower half of the memory stats on the shootout, fwiw, between clean and ocaml.
17:34:55 <solrize_> well there has to be some kind of database holding the blog articles and comments, and that's often done with something like mysql and ends up being a pig
17:35:14 <dons> yeah, maybe a simple rcs based db?
17:35:19 <dons> or just toss sqlite in there.
17:35:24 <SamB> so don't use MySQL
17:35:39 <dons> mix and match your off the shelf solutions from http://hackage.haskell.org/packages/archive/pkg-list.html
17:35:44 <SamB> it is well known that FOO is better than MySQL in almost every way
17:35:47 <dons> there's really little programming involved now, its just a glue project
17:36:18 <dons> write utf8 bytestrings to disk via sqlite, serve them up through fastcgi. forkIO on each new request, done.
17:36:22 <solrize_> i've been wanting to write a blog that uses data.map to hold all the content, maybe with happs
17:36:23 <jdrake> SamB, may I presume that FOO is a placeholder? :P
17:36:33 <SamB> jdrake: yes
17:36:40 <SamB> insert almost any other DBMS
17:36:44 <dons> shouldn't take more than half a day to write.
17:37:15 <jdrake> solrize_, some how I doubt that would scale
17:37:33 <solrize_> jdrake you mean in terms of amount of memory?
17:37:35 <dons> jdrake: imagine the Map is a memcache
17:38:04 <solrize_> the idea is to get rid of all the db traffic
17:38:07 <dons> actually, seems to scale enough for most needs. check out hpaste.org
17:38:08 <solrize_> and context switches
17:38:24 <dons> is your blog going tobe more active than hpaste?
17:38:33 <dons> its just happs + a Map
17:38:47 <solrize_> mine?  yes the idea is to be able to run something the size of slashdot on one box
17:39:08 <dons> that'll need some careful bottleneck tuning then.
17:39:14 <dons> it'd be an interesting project
17:39:16 <jdrake> dons: I suspect hpaste would get more activity.
17:39:25 <jdrake> Definitely
17:40:10 <Maciej> @pl \(x,y) f -> (x,f y)
17:40:10 <lambdabot> uncurry ((. flip id) . (.) . (,))
17:40:26 <dons> :t \(x,y) f -> (x,f y)
17:40:28 <lambdabot> forall t t1 t2. (t, t1) -> (t1 -> t2) -> (t, t2)
17:40:32 <jdrake> Now another potential problem would be templates (for customizing). Would it be possible to have a templating language that is able to get data from haskell?
17:40:37 <Maciej> @pl \f (x,y) -> (x,f y)
17:40:37 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,))
17:41:03 <dons> :t second
17:41:04 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
17:42:09 <jdrake> Is it possible to get a hackagedb package to automatically download and build itself?
17:42:40 <EvilTerran> that'd be cabal-install's job, i think
17:43:12 <dcoutts> jdrake: yeah, that's just what cabal-install is for
17:43:25 * dcoutts goes back to hacking on... cabal-install
17:44:07 <dcoutts> mmm constraint solving, fun fun fun :-)
17:45:56 <jdrake> hmm, What about having the underlying blog software that outputs to xml, and xslt converts it to the proper template look right in the browser (or let apache do it)?
17:46:43 <EvilTerran> why bother with xslt? i'm sure we can make a haskell EDSL that'd knock it's socks off :P
17:47:20 <EvilTerran> a web page could just be a haskell value, loaded from a file via hsplugins or whatever
17:47:37 <jdrake> EDSL?
17:47:46 <EvilTerran> "embedded domain-specific language
17:48:03 <solrize_> dependently typed even ;)  http://laconic.sourceforge.net/
17:48:03 <lambdabot> Title: The Laconic programming language family
17:48:22 <EvilTerran> basically, a library of functions that basically completely change the tone of programming in a language, to the point where it almost looks like a different one
17:48:42 <jdrake> solrize_, as I recall Adam's project isn't even complete
17:48:46 <EvilTerran> compare haskell for solving numeric problems to, say, a Parsec parser (where Parsec is the EDSL)
17:48:48 <Maciej> @pl \f x y -> (x,f y)
17:48:48 <lambdabot> flip ((.) . (,))
17:49:12 <solrize_> jdrake, yeah, i dunno how much of it is running, it looks like a cool idea though
17:49:25 <jdrake> solrize, look up smlweb
17:49:43 <solrize_> http://smlweb.sourceforge.net/
17:49:44 <lambdabot> Title: Dynamic web site tools for Standard ML
17:49:46 <solrize_> same guy
17:49:59 <jdrake> I know, this is what he did before
17:50:23 <EvilTerran> Maciej, you want Control.Arrow.right, i suspect
17:50:33 <EvilTerran> er, Control.Arrow.second
17:50:35 <EvilTerran> ?type second
17:50:37 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
17:50:54 <EvilTerran> ?type second :: (b -> c) -> (d,b) -> (d,c)
17:50:55 <solrize_> jdrake yeah i'd expect haskell could do about the same?
17:50:56 <lambdabot> forall b c d. (b -> c) -> (d, b) -> (d, c)
17:51:29 <solrize_> laconic is a lot different and seemed more interesting to get to understand
17:52:55 <Maciej> Yes, that's what I want.
17:53:43 <jdrake> solrize, maybe :-)
17:53:56 <jdrake> I should do something simple to get back into haskell... What to do..
17:54:37 <Maciej> > second succ ([], 1)
17:54:38 <lambdabot>  ([],2)
17:54:47 <Maciej> Cool :-)
17:54:57 <solrize_> jdrake, weren't you saying something about a blog?
17:55:10 <solrize_> actually another way i've thought of implementing a blog is just using an NNTP server as the backend
17:55:21 <solrize_> so the front end is simply an nntp to web client
17:55:23 <Strykar> hi, how hard is it to lean Haskell for someone with no programming experience, besides shell scripts?
17:55:42 <dibblego> Strykar, about 7
17:55:47 <solrize_> strykar, probably easier than for someone who is an experienced programmer with a lot of preconceptions to get rid of
17:55:59 <dibblego> I second that of solrize
17:56:14 <Strykar> danke, i'll give it a shot
17:56:23 <jdrake> solrize, I need something much more basic.
17:56:38 <jdrake> solrize, last time I only just figured out how to deal with IO :-)
17:56:56 <jdrake> I, unfortunately, did not keep my programs in a reliable place.
17:57:40 <solrize_> jdrake, as dons says, i think a basic blog should be easy to write, it's harder if you want to get fancy
17:57:47 <kiris> man jbo
17:57:51 <kiris> bah
17:58:33 <EvilTerran> Password for user 'root' incorrect.
17:58:36 <newsham> looking at applicative programming paper.
17:58:37 <EvilTerran> Password@:
17:58:49 <EvilTerran> gr. typo. never mind, spoilt the joke.
17:58:52 <newsham> "newtype Accy o a = Acc {acc : o }"
17:59:02 <newsham> the "a" here is just to select between diff monoids?
17:59:03 <jdrake> solrize, It might be easy to write when I feel more comfortable in haskell :-)
17:59:07 <solrize_> ic
17:59:19 * solrize_ looks through his haskell hacks folder
17:59:35 <kiris> EvilTerran: hehe
18:00:02 <solrize_> jdrake i did a bunch of the euler problems in haskell
18:00:09 <solrize_> that was interesting
18:00:53 <EvilTerran> good choice. i found that exceedingly helpful.
18:02:06 <jdrake> solrize, possibly this stuff? http://projecteuler.net/index.php?section=problems&id=1
18:02:07 <lambdabot> Title: Problem 1 - Project Euler
18:02:12 <newsham> err, blah, no, the "o" suggests whic monoid.
18:02:14 <newsham> i'm confused here
18:02:23 <solrize_> jdrake, yeah, those
18:02:25 <dmwit> jdrake: exactly
18:02:33 <jdrake> I think those would be a good start
18:04:10 <newsham> ?hoogle Traversable
18:04:11 <lambdabot> Data.Traversable :: module
18:04:11 <lambdabot> Data.Traversable.Traversable :: class (Functor t, Foldable t) => Traversable t
18:05:04 <solrize_> http://projecteuler.net/index.php?section=problems
18:05:04 <lambdabot> Title: Project Euler
18:05:35 <jdrake> Q: Find the sum of all the multiples of 3 or 5 below 1000.   What about a multiple that is of both?
18:05:54 <ddarius> jdrake: Then it would be a multiple of 3 or 5.
18:06:10 <jdrake> ddarius: , no it would be a multiple of 3 and 5
18:06:29 <solrize_> or != xor
18:06:32 <newsham> a and b implies a or b
18:06:43 <jdrake> fair enough
18:06:44 <ddarius> Which is also a multiple of 3 or 5.  or usually implies inclusive or in written/spoken English
18:07:31 <newsham> ?djinn (a,b) -> Either a b
18:07:31 <lambdabot> f (a, _) = Left a
18:08:36 <jdrake> Does haskell support named parameters? (ocaml supports something like ~parameter: ...)
18:08:42 <dibblego> newsham, nice :)
18:09:15 <newsham> ?bot snack
18:09:15 <lambdabot> :)
18:09:17 <ddarius> jdrake: No
18:12:07 <edwardk> jdrake: not really
18:14:28 <Cale> You can, however, have a function take a record datatype as a parameter.
18:16:57 * ddarius should migrate UsingRecords to haskellwiki
18:17:38 <dons> its kind of interesting to watch the hits on a post that makes the front page of reddit.
18:18:05 <dons> for example, the wiki page up there at the moment is getting 10 or so hits a minute atm.
18:19:46 <dons> ddarius: i'm sceptical andrew's going to actually try to grok the responses to the rank-n post, sadly.
18:20:03 <dons> we need more grokking.
18:22:57 * ivanm hands dons a copy of "stranger in a strange land"
18:23:05 <ivanm> does that have enough grokking for you? :p
18:23:59 <ddarius> dons: He needs to spend much more time reading.
18:25:39 <dons> to think of what could have been achieved in the last 1 year and 5 weeks since he joined our little community.
18:25:45 <dons> Do you think its all an elaborate hoax?
18:25:49 <dons> see here, the first email,
18:25:51 <dons>   http://article.gmane.org/gmane.comp.lang.haskell.cafe/21757
18:25:52 <lambdabot> Title: Gmane -- Mail To News And Back Again
18:25:56 <dons> what's changed since then? :(
18:26:28 <lament> wow, why is reddit uglified so
18:28:25 <dolio> It needed more web 2.0.
18:28:51 <lament> success
18:29:25 <glguy> You can make the new reddit suck less with the "compress links" option in "preference"
18:29:46 <dons> yeah. that's livable.
18:30:19 <dons> my brain must have been trained on the old layout though. the new one felt weirdly noisy.
18:31:10 <dibblego> is parBuffer written using parMap?
18:32:35 <dibblego> ?src parBuffer
18:32:36 <lambdabot> Source not found. Sorry.
18:33:14 <lament> glguy: yeah, that's what i thought, this is just a scheme to make people register so they can adjust preferences :(
18:35:23 <hpaste>  dons pasted "parBuffer" at http://hpaste.org/7909
18:35:36 <wuxia> erlang has wings3d -- are there any 3d modellers written in haskell?
18:35:46 <dibblego> thanks dons
18:35:57 <dibblego> I was getting to it :)
18:35:59 <wuxia> is h3d the closest?
18:36:50 <wuxia> does ogre3d/haskell bindings even exist yet?
18:36:51 <ddarius> wuxia: Probably.  I don't see why a language needs a 3D modeller.
18:37:27 <wuxia> i'm not saying it does
18:37:33 <wuxia> i just want to seee what  a 3d modeller written in haskell would look like
18:37:40 <dons> you mean, an app?
18:37:48 <dons> something with opengl, and lots of threads?
18:37:59 <dons> like the data parallel physics engine Feuerbach is writing?
18:38:39 <ddarius> wuxia: It would look more like a 3D modeller in any other language than unlike it.
18:42:01 <jdrake> Have you guys ever heard of a 'Bachelor's of Software Design'?
18:44:28 <dons> design eh?
18:44:48 <jdrake> A friend says "It's a pretty established degree", even though I have never heard of it.
18:46:10 <edwardk> jdrake: sounds kinda like those fly-by-night places that get you degrees in 'game development'
18:46:20 <jdrake> I thought it sounded fishy :p
18:46:23 <dons> me neither. software eng, sure. computer science, of course. software design? sounds a bit fishy.
18:46:56 <dons> you think they'll teach reactive programming approaches to modelling time varying data?
18:46:58 * chessguy wonders who really cares what the name of the degree is
18:47:14 <dons> region-based resource isolation?
18:47:15 <jdrake> I wonder if it is this: http://www.senecac.on.ca/fulltime/BSD.html
18:47:17 <chessguy> as long as the content is good, and the university is recognized
18:47:20 * dons imagines lots of interesting software designs
18:47:25 <shapr> edwardk: Hey, want to go get portuguese food? ;-)
18:47:30 <edwardk> shapr: heh
18:47:34 <jdrake> chessyguy, it is probably associated with a university. This is offered at a college.
18:48:16 <edwardk> shapr: i should opt out, going to finish up dualizing ghani and johann's initial algebra semantics is enough stuff, and then i need to get some stuff done for work before i pass out
18:48:24 <shapr> edwardk: Fair enough
18:56:12 <Maciej> @pl \f -> f &&& f
18:56:12 <lambdabot> join (&&&)
18:56:54 <Maciej> ?hoogle join
18:56:54 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
18:56:54 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
18:56:54 <lambdabot> System.FilePath.Windows.joinDrive :: FilePath -> FilePath -> FilePath
19:00:48 <Maciej> @pl \f x y -> (f x, f y)
19:00:48 <lambdabot> flip =<< (((.) . (,)) .)
19:02:23 <shepheb> there has to be a better way to write that one
19:03:40 <Maciej> I'm looking for "both" or something like this
19:03:59 <Maciej> a combination of first and second
19:07:37 <ddarius> :t (&&&)
19:07:40 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:08:20 <dolio> @type join (***)
19:08:22 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
19:08:50 <dolio> @type \f -> (,) `on` f
19:08:52 <lambdabot> forall b a. (a -> b) -> a -> a -> (b, b)
19:09:28 <dolio> @type curry $ join (***)
19:09:30 <lambdabot>     No instance for (Arrow (,))
19:09:30 <lambdabot>       arising from a use of `***' at <interactive>:1:13-17
19:09:30 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
19:09:42 <dolio> @type curry . join (***)
19:09:44 <lambdabot> forall b c. (b -> c) -> b -> b -> (c, c)
19:10:58 <Maciej> dolio: that's it.
19:11:42 <dolio> on (,) is shortest, although somewhat cryptic.
19:12:08 <Maciej> ?hoogle on
19:12:09 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
19:12:09 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
19:12:09 <lambdabot> Data.Function :: module
19:12:19 <ddarius> :t on (,)
19:12:21 <lambdabot> forall b a. (a -> b) -> a -> a -> (b, b)
19:13:37 <dolio> There's also join bimap if you have category-extras installed.
19:15:37 <Maciej> Btw is it possible to build lambdabot on Windows?
19:18:14 <newsham> maciej: it should be,althought it might require some minor tweaks
19:21:07 <Maciej> I just found that: http://www.cs.uu.nl/wiki/pub/Afp/TalkTopics/lambdabot.pdf
19:21:35 <Maciej> "It should be possible with cygwin" - also without cygwin?
19:21:49 <newsham> i've built it before without cygwin
19:30:26 <jdrake> Has anyone seen something like 'writeroom' (full screen text editor in graphics mode) but for coding in linux?
19:31:00 <ivanm> jdrake: just make any text editor in full screen?
19:32:00 <jdrake> It has to get rid of everything that is on the screen currently, but also support switching desktops.
19:32:06 <newsham> ?hoogle (Traversable t, Monoid o) => (a -> o) -> t a -> o
19:32:07 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
19:32:07 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
19:32:07 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
19:32:21 <Spark> jdrake: what you want is a good window manager
19:32:24 <Spark> jdrake: try ion
19:32:38 <jdrake> Spark, I am using gnome and won't change
19:32:48 <Spark> "full screen" and "get rid of everythign that is in the screen" are window manager features, not text editor features
19:33:05 <jdrake> Spark: Tell that to the game that goes fullscreen
19:33:29 <ivanm> jdrake: why can't you just make your text editor full screen?
19:33:31 <Spark> apps that do that are broken
19:33:40 <newsham> writeroom has no chrome it seems
19:33:50 <newsham> no menus, window borders, etc.
19:33:53 <rizzix> its not broken its a feature
19:33:58 <jdrake> That is the idea :-)
19:34:13 <Spark> start+alt+enter gets rid of the decorations on any arbitrary window for me
19:34:39 <newsham> software is not the answer to distractions ;-)
19:34:53 <ivanm> that sounds more like a WM problem to me...
19:35:07 <Spark> ivanm: i said that, but he refuses to believe it
19:35:15 <ivanm> I agree with Spark... any app that does that is broken
19:35:21 <ivanm> Spark: and I was leading up to agreeing with you!
19:35:42 <Spark> \o/
19:36:12 <jdrake> hmm, it appears my text console has an ugly font. I must find out how to change it to regular vga font, maybe at higher resolution (90 or 100 columns would be nice :-)
19:36:27 <ivanm> which console are you using?
19:36:32 <ivanm> terminus is rather nice
19:37:11 <jdrake> ivanm, I mean the real text console (C-M-F1)
19:37:21 <newsham> sounds off topic
19:37:24 <jdrake> Its using that vesa mode stuff
19:37:39 <ivanm> yes, so did I
19:37:41 <jdrake> newsham: Its all in the name of beautiful haskell code
19:37:58 <ivanm> wait, terminus mightn't work there... but there are other fonts you can use
19:38:09 <jdrake> ivanm, I am unsure how you would even set something up
19:38:36 <ivanm> gentoo has it in /etc/conf.d/consolefont
19:41:34 <jdrake> I found some of the configuration, but I am having trouble finding the fonts themselves
19:42:09 <ivanm> jdrake: /usr/share/consolefonts/ ?
19:42:37 <jdrake> All working now!
19:42:41 <ivanm> \o/
19:42:43 <jdrake> ivanm, yes that was it
19:42:44 <orbitz> @src uncurry
19:42:44 <lambdabot> uncurry f p = f (fst p) (snd p)
19:46:57 <patperry> I have a rewrite rule that isn't firing; can anyone tell me why?
19:47:07 <patperry> "scale/plus"   forall k l x y. plus (scale k x) (scale l y) = add k x l y
19:50:36 <dons> you don't have INLINE [1] on plus or scale ?
19:50:43 <dons> so they're inlined immediately, and not available to match on
19:50:54 <dons> or possibly, you're compiling without -fglasgow-exts, so rewrite rules themselves are not enabled.
19:51:47 <patperry> I don't think I can inline scale: it allocates memory
19:52:26 <dons> no, you want to disable inlining
19:52:39 <dons> so either NOINLINE or INLINe [1] (only inline at a late stage)
19:52:48 <patperry> I have a rule: plus (scale k x) y = add k x 1 y, and that works fine
19:52:48 <dons> you're doing manual memory allocation?
19:53:21 <dons> for rules to fire consistently, you have to limit the inlining phases on the identifiers being matched.
19:54:51 <patperry> I'll try putting INLINE [1] on plus
19:55:18 <dons> why don't you want to inline scale? does it do FFI-based memory allocation?
19:55:26 <dons> or is it caching something?
19:55:35 <patperry> yeah, ffi-based memory
19:56:12 <dons> ok. so yeah, you can inline that stuff, but you might want to be careful. if it is actually wrong to duplicate the allocation, then you better put a NOINLINE on it.
19:57:59 <patperry> I put NOINLINE on plus, and the rule still doesn't fire
19:59:47 <dons> ok. then you should look at the core transformations taking place, ghc -O2 -ddump-simpl-iterations
20:00:00 <dons> and what for your function to appear, to see what form it takes such that the rule doesn't match
20:00:18 <patperry> thanks, I'll try that
20:05:10 <patperry> yikes... 19000 lines of output.  any clues on what to look for?
20:05:34 <dibblego> do any of you redefine (.) to fmap and use it that way?
20:06:01 <dons> patperry: well, try to find your test function that contains the code you want to match on.
20:06:12 <dons> or write a simple test program that links against all the other stuff, just to see if the rule fires.
20:06:30 <dons> basically, isolate until you find your code in the AST, then think about why its not matching.
20:07:34 <patperry> yeah, this is my test function: main = putStrLn $ show $ plus (scale 2 x) (scale 3 y)
20:07:50 <ddarius> I sometimes wonder what you all are thinking when I read parts of RWH.
20:10:08 <patperry> dons: when I see the "Simplifier phase 2, iteration 2 out of 4" and then the rule listed, should I look forward or backward in the output to see the transormation?"
20:10:11 <kiris> ?
20:10:17 <kiris> ddarius: what do you mean>
20:13:42 <dons> patperry: oh, if the rule is listed, then it fired.
20:13:46 <dons> so that's good.
20:13:56 <dons> you can look above and below to see the result, yeah
20:14:09 <dons> ddarius: ?
20:14:36 <patperry> ok, I'll do some experimenting.  only the rule with one argument fires, not the rule with two arguments
20:14:42 <dons> ddarius: i think its along the lines of "holy crap, this book is getting big!"
20:18:14 <ddarius> dons: There are just examples or things that seem completely pointless.
20:18:58 <dons> i hope you're commenting on those then.
20:19:17 <ddarius> dons: Of course.
20:19:25 <dons> its a big book, and somewhat of an undertaking to keep all parts of it in your head. none of us do.
20:20:00 <dons> cool, thanks.
20:20:12 <dons> the more eyes that look at it before the trees get chopped down, the better
20:20:14 <Trinithis> RWH?
20:20:25 <ddarius> dons: It's not that.  The particular examples I'm thinking of I wonder why they got written in the first place.  And the most recent example, is just bizarre.
20:20:31 <dons> ?go real world haskell
20:20:32 <lambdabot> http://www.realworldhaskell.org/blog/
20:20:32 <lambdabot> Title: Real World Haskell
20:20:43 <dons> ddarius: in which chapter?
20:20:59 <Trinithis> that's one scary lambda picuure!
20:23:41 * dons goes back to more writing. chapters, chapters!
20:23:58 <Trinithis> dons: did you write the whole thing?
20:24:49 <dons> no, far from it.
20:24:57 <dons> there's 3 of us on this the thing.
20:27:22 <ddarius> dons: Last example here: http://book.realworldhaskell.org/beta/find.html
20:27:24 <lambdabot> Title: ChapterÂ 11.Â I/O case study: a library for searching the filesystem
20:29:50 <ivanm> dons: is the online draft version going to stay up there when the book gets published?
21:04:54 <orbitz> is there any style preference between handling all pattern matches o fa case/function? or only specifying what you are interested in and letting an error happen otherwise?
21:05:34 <ivanm> orbitz: after you've done what you're interested in, use "func _ = blah" to catch everything else
21:05:37 <dons> no, usually you will have an explicit default / error case
21:05:41 <dons> so the programmer's intention is clear
21:06:05 <dons> failing with a pattern match error is less helpful, than saying, say, error "The impossible happened in foo!"
21:06:07 <orbitz> can i tell ghci to complain when i don't?
21:06:18 <dons> yes, compile with -Wall
21:06:21 <newsham> even better is to write total functions :)
21:06:30 <orbitz> i just had fun tracking down a missing pattern match when i forgot to use correct capitaliztin on a functi
21:06:36 <orbitz> dons: will ha towrk on :l?
21:07:35 <newsham> http://www.cs.york.ac.uk/fp/darcs/catch/catch.htm
21:07:36 <lambdabot> Title: Catch: A User Manual
21:08:55 <newsham> ?instances Data.Traversable
21:08:57 <lambdabot> Couldn't find class `Data.Traversable'. Try @instances-importing
21:10:21 <dons> orbitz: yeah, -Wall -Werror will fail to compile your code on missing patterns
21:10:28 <dons> basic tool in the shed.
21:10:42 <orbitz> dons: right but i'm asking if i can have that applied in ghci when i :load a file
21:11:03 <dons> :set -Wall
21:11:07 <orbitz> thank you
21:11:11 <dons> or put it in the top of the file.
21:11:56 <newsham> > foldMapDefault
21:11:58 <lambdabot>   Not in scope: `foldMapDefault'
21:12:00 <newsham> hrm
21:16:48 <ivanm> dons: you mean -Wall doesn't do all checks?
21:17:59 <dons> well, it doesn't solve the halting problem.
21:18:23 <dons> so you can write code that is actually provably correct, yet doesn't cover all cases, and ghc is still going to complain
21:18:55 <dibblego> -Whalting will be in GHC 6.10
21:19:03 <dibblego> I kid
21:19:30 <ivanm> dons: so why do you have to specify -Werror?
21:19:31 <newsham> ?faq can haskell solve the halting problem?
21:19:31 <lambdabot> The answer is: Yes! Haskell can do that.
21:19:34 <ivanm> dibblego: awwww :(
21:19:40 <ivanm> newsham: \o/ :p
21:21:39 <dons> ivanm: to turn it into a compilation failure, rather than a warning
21:22:47 <ivanm> ahhh
21:23:05 <ivanm> as in if -Wall picks up anything, it refuses to compile rather than just complaining about it?
21:23:52 <dmwit> Hey, how come :r sometimes successfully loads a file but doesn't put its functions into the active namespace?
21:24:39 <dmwit> (I haven't detected a pattern yet.)
21:24:59 <ddarius> dmwit: Depends on whether the file is compiled or not.
21:25:06 <shepheb> dmwit: I think it has to do with the existence of a compiled .o file for the module. I could be wrong, but that's my pattern.
21:25:22 <dmwit> Oh, hm.
21:25:37 <dmwit> So is it just recommended not to mix ghci with compilation, then?
21:27:54 <ivanm> dmwit: yes
21:28:04 <ivanm> just touch the file if you want to play with it
21:28:11 <ivanm> that'll force re-interpretation
21:28:38 <dolio> dmwit: I've found that if you start ghci with errors in a file, once you've fixed them, :r doesn't correctly load the module into scope.
21:28:49 <dolio> You have to restart ghci.
21:29:01 <dolio> Er, that's true in 6.8.2.
21:29:02 <cjs> Yeah, I've seen that too, dolio.
21:29:11 <dolio> Fixed in 6.9, I think.
21:29:11 <cjs> Or, just do your :l again.
21:29:22 * edwardk headdesks and realizes that the Dual class I was using is just Adjunction =)
21:29:54 <ddarius> dmwit: There's nothing wrong with using a compiled file with GHCi.
21:30:17 <dmwit> dolio: Yeah, that sounds like the problem I see.
21:30:23 <dolio> Loading a good module in ghci, reloading with errors, and then reloading after fixing works correctly, though.
21:31:24 <cjs> Oh, btw, dmwit, it's nothing to do with compilation; it happens to me all the time on purely interpreted stuff.
21:34:50 <dolio> Of course, last time I tried 6.9, it had the alternate problem of not doing line editing correctly.
21:35:01 <dolio> I don't think backspace even worked.
21:37:46 <ddarius> dolio: Just don't make typos.
21:37:53 <dolio> Heh.
21:39:16 <newsham> foldMapDefault Product (Node 3 [Node 2 [], Node 5 []])
21:39:21 <newsham> thats really fricken cool
21:42:15 <dolio> foldr f z = flip appEndo z . foldMap (Endo . f) is cooler.
21:42:28 <newsham> whats the endo monoid?
21:42:36 <ddarius> :t End
21:42:38 <ddarius> :t Endo
21:42:38 <lambdabot> Not in scope: data constructor `End'
21:42:39 <lambdabot> forall a. (a -> a) -> Endo a
21:42:46 <dolio> Endo f ++ Endo g = Endo (f . g)
21:42:49 <ddarius> You should be able to figure it out from there.
21:42:56 <ddarius> Unfortunately dolio had to spoil it.
21:44:30 <dolio> I do my best.
22:01:50 <Mr_You> hi
22:07:51 <dmwit> Hiya, Mr_You!
22:16:18 <pastorn> @hoogle Word8
22:16:31 <lambdabot> Data.Word.Word8 :: data Word8
22:16:31 <lambdabot> Data.ByteString.Internal.isSpaceWord8 :: Word8 -> Bool
22:34:58 <cjs> Damn, it took me like 45 minutes to figure out how to use this clever testing library I wrote only two months ago.
22:38:19 <wolgo> sounds too clever :P
22:45:57 <cjs> It's not too clever, I'm just too dumb. :-)
22:46:39 <cjs> It's just as simple as 'yearsToMaturity _mat12 0  ~?~=  approx 0.032854'
23:39:13 <cjs> Aw right!
23:40:03 <cjs> I finally have a presenter to do a Lisp thing at our next TSAC meeting (the Tokyo Society for the Application of Currying). A nice break from me and all my darn Haskell.
23:43:47 <mxc> :t rnf
23:43:52 <lambdabot> forall a. (NFData a) => a -> Done
23:54:22 <cjs> I use that.
23:54:35 <vixey> ?docks rnf
23:54:36 <lambdabot> rnf not available
23:57:29 <mxc> are they supported under windows?
23:57:34 <mxc> getting linker errors
23:57:36 <mxc> Test.o(.text+0x5b):fake: undefined reference to `parallelzm1zi0zi0zi0_ControlziParallelziStrategies_parBuffer_closure'
23:57:36 <mxc> Test.o(.text+0x62):fake: undefined reference to `parallelzm1zi0zi0zi0_ControlziParallelziStrategies_rwhnf_closure'
23:57:36 <mxc> Test.o(.text+0x17a):fake: undefined reference to `ComziNyenburghziQuantziToolsziUtil_timedRun_closure'
23:57:36 <mxc> Test.o(.text+0xd6e):fake: undefined reference to `parallelzm1zi0zi0zi0_ControlziParallelziStrategies_parBuffer_closure'
23:57:46 <mxc> oops, sorry, only meant to copy one line
23:58:21 <glguy> I'd scold you if there'd been an discussion in the last 2 hours ;)
23:58:36 <mxc> it was an accident..
23:58:43 <mxc> *bows head in shame*
23:59:04 * mxc is hoping not to get excommunicated to the ocaml channel
23:59:44 <mxc> glguy - do you work for a company called GL?
