00:00:04 <dons> darcs get ?
00:00:07 <solrize_> you have a ton of stuff in that dir
00:00:14 <solrize_> i just did wget -r on the directory
00:00:23 <dons> that's a funny way to do a darcs get, but oh well
00:00:34 <solrize_> i don't have darcs on this box
00:00:49 <dons> oh, i think it walked up the directory tree?
00:00:56 <solrize_> yeah looks that way
00:01:01 <solrize_> i'll try again with --no-parent
00:01:22 <solrize_> still getting a ton of stuff
00:01:28 <dons> i'll give you a tarball
00:01:32 <solrize_> ok
00:01:32 <olsner> wget -r is no plaything ;-)
00:01:36 <dons> you should install darcs though.
00:01:43 <solrize_> yeah
00:01:59 <solrize_> installing is a pain on this machine because i don't have root
00:02:10 <dons> galois.com/~dons/tmp/uvector.tar.gz
00:02:15 <solrize_> ah, thanks
00:03:23 <solrize_>      error: gmp.h: No such file or directory
00:03:25 <solrize_> hmm
00:03:31 <dons> you sure you have ghc?
00:03:45 <solrize_> yes
00:03:48 <dons> oh, maybe you did a fresh ghc build and gmp is in some non-standard location?
00:03:56 <dons> like /usr/local ?
00:04:07 <solrize_> i'm trying to remember, i did something weird for gmp
00:04:14 <solrize_> it's not in /usr/local it's in my home dir
00:04:16 <dons> edit the headers to take the path ?
00:04:28 <dons> and modified package.conf so that ldOpts includes the linker path
00:04:38 <solrize_> and i have to do something weird to access it, i use ghc -L
00:04:40 <dons> -I and -L flags will likely work
00:05:11 <solrize_> i tried putting --prefix into the setup.lhs configure
00:05:16 <solrize_> should that work?
00:05:46 <dons> to do what?
00:06:00 <tieTYT2> hello
00:06:03 <solrize_> --prefix=/myhomedir/hs  which is where libgmp.a is
00:06:16 <solrize_> hi tietyt2
00:06:25 <tieTYT2> i tried to learn haskell before, but I didn't like the tutorial I read and I moved on.  I may want to give it another try soon
00:06:25 <solrize_> i think that's how i usually build hackage stuff
00:06:40 <olsner> @ty (:*:)
00:06:43 <lambdabot> forall a b. a -> b -> a :*: b
00:06:45 <tieTYT2> can anyone recommend a really good tutorial?  I already know Java, but that'll probably hurt me more than help
00:06:47 <solrize_> tietyt2 there are several tutorials and it may help to jump around between them
00:07:07 <olsner> hmm, a sectionable , operator?
00:07:23 <solrize_> tietyt2, http://realworldhaskell.org
00:07:25 <lambdabot> Title: Real World Haskell
00:07:44 <solrize_> there's a tutorial called "haskell for c programmers" which some people seem to like, i personally wasn't crazy about it
00:08:04 <tieTYT2> oh
00:08:04 <dons> tieTYT2: also, become familiar with haskell.org, and hang out here.
00:08:05 <tieTYT2> ok
00:08:08 <hexpuem> yea i diddnt like that tutorial
00:08:09 <dons> ?where yaht
00:08:10 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
00:08:11 <dons> is also good
00:08:19 <hexpuem> YAHT was good imo
00:09:22 <tieTYT2> oh this is the one i tried and didn't like
00:09:41 <tieTYT2> from what i could tell, it was giving you sample questions that you weren't able to answer yet if all you read was the tutorial
00:09:45 <solrize_> gentle introduction?
00:11:44 <dons> there's lots now. browse haskell.org for more tuts
00:11:48 <olsner> hmm, how the heck did I learn haskell? I don't remember reading any of the tutorials
00:12:32 <solrize_> tieTYT2 it's not about haskell but the first thing you should read imho is "why functional programming matters"
00:12:42 <solrize_> it uses a haskell-like language that no one uses any more
00:12:51 <tieTYT2> if i judge a book by its cover, that sounds like a good article :)
00:12:55 <solrize_> :)
00:13:12 <tieTYT2> but i have that question myself
00:13:34 <tieTYT2> i like java over dynamic languages (in general) because the compiler does more work for me.  But I know in Haskell, the compiler does even more work for me than Java
00:13:38 <tieTYT2> so that's one plus
00:14:02 <tieTYT2> by that, i mean it discovers more bone-headed errors I may cause
00:14:21 <solrize_> yeah, you really have to write haskell code with laser-like precision
00:14:25 <solrize_> don't let the conciseness fool you
00:14:50 <Botje> it's kind of hard to launch nukes with a catapult. (doesn't mean you can't try in fallout 3)
00:15:05 <tieTYT2> Botje: is that out now?
00:15:05 <hexpuem> they made fallout 3?
00:15:07 <solrize_> but, it's like a jigsaw puzzle, if you try extending a program by adding a piece of the wrong shape, it just won't fit, and the compiler will barf at you
00:15:19 <Botje> tieTYT2: nah, it's coming in october or so
00:15:22 <solrize_> unlike python, which is like a jigsaw puzzle where all the pieces are 1x1 squares ;)
00:15:25 <tieTYT2> oh
00:15:30 <tieTYT2> bestheda is making it so it should be good
00:15:40 <tieTYT2> i've never played the other two, but everyone always talks about it
00:15:46 <Botje> you should
00:15:58 <Botje> grab them for EUR 15 or so
00:16:01 <solrize_> there was a joke(?) about a nuclear hand grenade :)
00:16:04 <Botje> best. atmosphere. evar.
00:16:16 <Botje> solrize_: fallout3 includes a nuke you can fire with a catapult.
00:19:09 <solrize_> dons somehow i've been getting by with libgmp.a but no gmp.h
00:19:42 <solrize_> botje heh
00:20:28 <solrize_> dons - (does|will) uvector support int128 / word128 with xmm instructions?
00:20:39 <dons> nope, but its an interesting idea.
00:20:51 <dons> if you send me some C code for word128, i'll implement them.
00:21:30 <dons> (its just a matter of getting the Word128 type through the compiler)
00:22:15 <lament> i just downloaded fallout a couple days ago, haven't gotten much into it
00:22:18 <solrize_> i don't think gcc supports word128 directly, so it would be just for asm out i guess
00:22:40 <solrize_> i'll see what long long int does on an x86-64
00:24:54 <solrize_> otherwise the c code would have to use inline asm
00:25:43 <solrize_> would that be ok?  i don't know how haskell types arrive at the c compiler
00:27:49 <solrize_> i guess it's the only way that makes sense, i'm not thinking straight
00:28:31 <solrize_> uvector is building ok on my ancient pentium iii
00:28:42 <solrize_> slowly
00:29:00 <tieTYT2> thanks
00:34:05 <solrize_> omg this is awful, gcc takes 31 cpu sec
00:34:20 <solrize_> gcc -O2 takes 40 sec!!!
00:36:35 <solrize_> ghc -O2 takes 40.825 sec
00:41:18 <dmwit> Word128 was not meant to be.
00:41:32 <solrize_> ghc -O2 -fvia-C  57 sec  :-P
00:42:53 <solrize_> dmwit whats wrong with word128?
00:43:12 <solrize_> the next generation x86's will have word256 hardware
00:43:26 <dmwit> I don't know, isn't that what you're playing with that is screwing up gcc so badly?
00:43:50 <solrize_> dmwit, no right now i'm just running dons' benchmark on an old 32 bit system with gcc 4.0.0
00:44:04 <solrize_> which was a somewhat regressed compiler in some ways
00:44:06 <dmwit> Oh, never mind, then.
00:44:23 <solrize_> i will upgrade the os of this thing soon and will have a newer gcc on it
00:44:57 <solrize_> but, this is still a 1000 mhz pentium iii at the end of the day
00:45:01 <solrize_> it should not be 10x slower than a core 2
00:45:08 <solrize_> 3x or 4x, i can believe
00:45:13 <solrize_> but 10x???
00:48:15 <Elly> a better branch predictor and more cache can make a lot of difference
00:59:15 <solrize_> that code should have basically no cache misses
00:59:56 <solrize_> oh i see, it's the explicit 64 bit arithmetic
01:01:40 <boegel> solrize_: why wouldn't P3 be 10x slower than Core2?
01:01:46 <boegel> solrize_: sounds reasonable to me
01:02:14 <boegel> solrize_: I've noticed our Core2 to be 2.5x faster than my 3Ghz Pentium4
01:02:29 <solrize_> on single threaded code???
01:06:36 <ketil> @where bytestring
01:06:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
01:09:24 <cjs> The P4 series were famously slow.
01:09:33 <ketil> boegel: my experience is similar.  I only report performance on core2 for my own programs :-9
01:09:55 <ketil> cjs: /that/s an exaggeration, IMO.
01:10:03 <cjs> Core were not much better. More slowly-clocked Pentium M CPUs of the same generation kicked their you-know-whats.
01:10:43 <solrize_> i have a pentium m and found it beats the p3 slightly clock for clock
01:10:48 <solrize_> not 2x better or anything like that
01:12:11 <ketil> solrize_, but the p3 also beats the p4 clock for clock (the point of p4 was the high clock - 3GHz in 2002)
01:12:30 <cjs> Really? My 1.7 GHz Pentium M is noticably faster for pretty much anything than a 2 GHz Core Duo from about two years ago.
01:13:06 <cjs> (My Pentium M was slightly older than that.) I reckon that 2MB of cache might be helping quite a bit, though.
01:13:37 <ketil> cjs: It's too long since I followed this, but I think the architecture is similar.  Cache is likely to be the answer - or memory speed or similar.
01:13:38 <cjs> Wow. Yegge's description of attempting to use other languages at Google is rather frightening: http://steve-yegge.blogspot.com/2008/05/dynamic-languages-strike-back.html
01:13:38 <lambdabot> Title: Stevey's Blog Rants: Dynamic Languages Strike Back, http://tinyurl.com/6a6den
01:13:53 <dmwit> yeah
01:14:06 <nominolo> you can translate everything to jvm ;)
01:14:09 <cjs> I had the impression that the Core (not Core 2) and Pentium M were different architectures.
01:14:48 <cjs> Hey, what's up with Jaskell these days, anyway?
01:16:26 <ketil> cjs: about Yegge's talk: is there a shortcut to the right section of the talk?  It's a fairly long read...
01:17:31 <cjs> Search for "get lynched".
01:18:01 <ketil> cjs: /now/ we're talking! :-)  (thanks - will do)
01:23:06 <ketil> I used Haskell in "industry".  Didn't get lynched, but got weird looks.
01:24:51 <osfameron> ketil: but presumably either in a team that already did it, or you were "senior" enough that you had the leeway to introduce it?
01:27:04 <cjs> Oh, it's really amusing when he starts ranting about casting. ("Java keeps piling...")
01:38:43 <solrize_> that post looks pretty lame so far
01:41:20 <quicksilver> I think it was probably a 'you have to be there' moment
01:41:24 <quicksilver> I'm sure in person the talk was good.
01:41:36 <quicksilver> The transcription is not great, I'm thinking it doesn't do it justice.
01:41:52 <osfameron> that said, it's pretty good for a self-done transcript
01:41:58 <cjs> It's amusing. Not because there's anything useful in it, but just to see him getting worked up over all this "new" stuff.
01:42:22 <osfameron> I think Larry Wall's talks do better if you read them than if you're there (cos he just reads them out anyway in monotone)
01:43:38 <solrize_> the talk may have been presented entertainingly but the stuff in it is just bogus
01:43:58 <cjs> There's, like, a ton of rant about various things that are, say, pretty much fixed in Haskell, and then he starts ranting about how the static typing guys have failed at all of this.
01:44:28 <cjs> Fortunately, this time around, he's recording it all for posterity, so when he changes his mind again in 3-5 years, it will all be there.
01:45:11 <osfameron> one good thing about yegge is that he admits upfront that he talks too much and understands too little :-)  He also changes his mind occasionally, which is nice.
01:47:55 <solrize_> see, python is faster than haskell for one main reason, which is that python itself is so slow that all the work in a python app is done in C extensions :)
01:48:20 <vixey> oh well, let's rewrite haskell in c!
01:48:35 <cjs> Yegge's made some pretty big changes. He used to be a huge Java fan. (Then again, so did I.)
01:50:27 <solrize_> hmm this thing gets interesting around the middle
01:50:32 <solrize_> where he's talking about jit compilation
01:55:05 <solrize_> ehh
01:55:15 <solrize_> overall: lame with a few interesting spots.
01:56:12 <masklinn> cjs, Yegge hasn't been a java fan in a long time. He used to be an OCaml fan before he went to the dynamically typed side.
01:56:53 <masklinn> (which was a long time ago already, it was in his early "drunken rants", before they were published on the web)
01:57:09 <osfameron> I think his prediction about having to understand mathematical concepts like covariance being a problem for widespread acceptance is problematic for haskell, if it's true
01:58:04 <ketil> osfameron, no, but I was using it on my pet stuff, in a non-system-critical way.  (sorry bout the delay here)
01:58:20 <masklinn> yes and no, haskell doesn't really aim for being "mainstream" in the sense of being as popular as/replacing java. So it should have a far lower impact. And the biggest problem of haskell is that monads are hard, so let's go shopping.
01:58:21 <osfameron> np :-)
01:58:30 <ketil> Anyway - I think the main challenge with JS is getting it correct, not getting it fast.
01:58:46 <cjs> It is problematic for Haskell, no question about it.
01:58:50 <ketil> At least, that's in my very limited experience.
01:59:02 <vixey> getting it correct is really the hardest thing in any language
01:59:07 <gaetan> Hi
01:59:09 <solrize_> there's an ocaml to js compiler
01:59:16 <vixey> hi gaetan
01:59:24 <ketil> The point is that JS's dynamicisms does not help.
01:59:24 <masklinn> there's also a java to js compiler, doesn't mean it's a good idea
01:59:51 <dmwit> There's a Haskell to JS compiler, too.
02:00:00 <dmwit> I wonder why JS is such a popular target language?
02:00:02 <masklinn> ketil, JS is not much harder to "get correct" than e.g. Ruby or Python (well apart from the automatic coercion crap). So the way to get it correct is pretty much the same: unit tests
02:00:03 <osfameron> js is the closest thing we have to a portable web-runtime
02:00:09 <solrize_> becaues it's deployed everywhere!!!
02:00:20 <ketil> I mean - a main selling point for an interpreter is incremental coding - where's a web page where I can enter arbitrary JS expressions and examine the results?
02:00:21 <cjs> The future of Haskell in the commerical world will probably hinge on where the "a few smart programmers" versus "an army of cheap programmers" thing swings over the next decade or two.
02:00:24 <gaetan> I have a problem with maps (from Data.Map): they seem very memory inefficient
02:00:25 <masklinn> dmwit, because most people consider JS to be a sublanguage and don't want to learn it. Thus they try to compile their own pet language to JS instead.
02:00:39 <ketil> (should be possible though - perhaps it does exist?  An embeddable JS interpreter?)
02:00:46 <vixey> haskell and common lisp are pet language? :P
02:00:49 <vixey> hehe
02:00:57 <ketil> gaetan, join the club!
02:01:02 <masklinn> vixey, every language is someone's pet language
02:01:09 <solrize_> the main selling point for js is that you can write server code that runs js on the client side
02:01:09 <gaetan> can someone tell me if I have done something wrong in that small example ? http://hpaste.org/7584
02:01:20 <solrize_> i.e. ajax
02:01:30 <quicksilver> dmwit: surely JS is a popular target language because it runs in web browsers?
02:01:37 <ketil> solrize_, doesn't explain why it has to be dynamic/interpreted.
02:01:44 <quicksilver> dmwit: it's nice to be able to deploy an app which people can run without downloading anything.
02:01:45 <masklinn> ketil, Firefox' js interpreter is available out of it (as a lib), and the JVM6 has a JS interpreter bundled
02:01:52 <cjs> I'm betting that there's enough of a market for the "a few smart programmers" side of things that I'll make a good living. But that's biased; I'd rather not be leading a team of Java programmers any more. I suppose I could stand it a bit better if I stopped programming and became a manager....
02:01:53 <solrize_> ketil it just explains the popularity
02:01:55 <quicksilver> (well obviously they do download something, but it doesn't feel like it)
02:01:56 <dmwit> quicksilver: point
02:02:10 <quicksilver> dmwit: for the same reason, I'd rather like a flash backend for haskell.
02:02:14 <ketil> solrize_, right it was @dmwit, not @me :-)
02:02:20 <solrize_> gaetan use foldl' is the usual first answer :)
02:02:22 <quicksilver> dmwit: with a nice binding to the fast native flash graphics.
02:02:23 <cjs> masklinn, Firefox's interpreter is available as a stand-alone interpreter as well. I used to use it to run unit tests for JS and ActionScript code.
02:02:30 <dmwit> gaetan: Your memory problem is almost certainly in "foldl", not in Data.Map.
02:02:33 <masklinn> cjs, yes it is (I should have pointed it out, forgot)
02:03:00 <cjs> quicksilver, Really? Tell me more. I know a lot about Flash and SWF, having built a commerical product that gets right into the grungy details of it.
02:03:14 <dmwit> gaetan: Use foldl' or foldr instead.
02:03:29 <quicksilver> cjs: "I'd rather like" - there is nothing to tell ;)
02:03:36 <quicksilver> cjs: I just think it would be a cool thing to have.
02:03:42 <gaetan> I'll try, but there is no problem when I use the commented line (to simply count all the chars) instead of the map!
02:03:43 <cjs> What would it do, exactly?
02:04:56 <dmwit> cjs: Presumably, compile Haskell code to Flash, and have some interface to the Flash graphics/sound as libraries.
02:04:56 <masklinn> cjs, compile haskell code to AS3/Tamarin bytecode and flash files?
02:05:25 <solrize_> openlaszlo is something like that?  but w/o haskell
02:05:40 <cjs> Hm. That doesn't seem tooo hard.
02:05:59 <dmwit> gaetan: That is because Int's (+) is already strict.
02:05:59 <ketil> somewhat off topic - my program just failed to allocate.  Is there a 2Gb limit on 32bit Linux?  I'm pretty sure my other boxes can allocate 3.5GB - is there some config knob, and where do I check?
02:06:20 <solrize_> ketil, 3.5gb but you have to configure the kernel with PAE
02:06:33 <osfameron> openlaszlo looked really clever, but I think all the constraint stuff was a bit of a hack
02:06:50 <dmwit> gaetan: (Whereas Map's insertWith is not.)
02:06:52 <solrize_> hmm maybe there is some other flag
02:06:57 <osfameron> I can imagine the mathematical underpinnings of haskell working for something much more elegant (but probably harder to learn :-)
02:07:01 <ketil> solrize_, where can I see how it is configured?
02:07:18 <solrize_> dmesg ?
02:09:46 <gaetan> I'm afraid foldl' doesn't help :-/
02:10:24 <gaetan> it still needs about 800 MB of ram to build the map with an input file of 18 MB
02:11:55 <solrize_> i think the insertWith is making thinks
02:11:58 <vixey> where is CC_Ref.hs?
02:12:01 <solrize_> you want a strictness annotation on that too
02:12:33 <solrize_> something like this?       foldl' (\m k -> insertWith $! (+) k 1 m)
02:12:33 <dmwit> gaetan: Maybe use some profiling to find out where all your memory is going?
02:12:54 <dmwit> solrize_: That's a type error.
02:13:18 <solrize_> hmm
02:13:34 <dmwit> (It parses as: ...insertWith $! ((+) k 1 m)
02:13:59 <solrize_> also is that a random binary file or something?  maybe it's really getting parsed as millions of distinct unicode points in utf8...
02:14:39 <gaetan> its a pure ascii text file
02:15:02 <gaetan> the result is correct ‚Äî it just need lot of RAM
02:15:14 <solrize_> gaetan it's surely a strictness problem
02:15:58 <gaetan> ok, I'll try to find what I can do on that side :-)
02:16:25 <solrize_> let charCounts = foldl' (m k -> let a = insertWith (+) k 1 m in (a seq a)) empty str      ?
02:16:35 <solrize_> a seq a is probably wrong
02:17:02 <solrize_> compile with -O2 maybe the compiler will fix it
02:20:00 <dmwit> As I learned the other night, a `seq` a is never correct.
02:20:13 <solrize_> is that an exaggeration?
02:20:17 <dmwit> nope
02:20:28 <dmwit> You probably want something like
02:20:47 <quicksilver> a `seq` a is PRECISELY the same as a.
02:20:56 <dmwit> foldl' (\m k -> m `seq` insertWith (+) k 1 m) empty str -- or so
02:21:03 <vixey> if haskell didn't have return type polymorphism you could just use contiunation passing to get it instead?
02:22:04 <quicksilver> why not use insertWith' ?
02:22:18 <solrize_> that exists?
02:22:25 <quicksilver> dmwit: you're not trying to seq the Map, by the way.
02:22:30 <quicksilver> dmwit: Maps are strict anyway.
02:22:42 <dmwit> Right, I knew that.
02:22:43 <quicksilver> it's the thunk of (+)s you're trying to strictify.
02:22:59 <dmwit> I thought (+) :: Int -> Int -> Int was already strict?
02:23:11 <quicksilver> sure, but that doesn't meant it's always applied strictly.
02:23:23 <quicksilver> (+) may be a strict function but 1 + 2 + 3 is still a thunk.
02:23:35 <quicksilver> the strictness analyzer will try to always apply strict functions strictly.
02:23:39 <dmwit> mmmm
02:23:39 <quicksilver> but, it can't spot every use
02:23:46 <quicksilver> esepcially if you thread it through other thunks
02:23:50 <quicksilver> (insertWith thunks, for example)
02:23:58 <solrize_> > if 3==4 then (1 + 2/0) else 9
02:24:01 <lambdabot>  9.0
02:24:02 <dmwit> Yeah, you want to seq the value within the Map, not the Map's spine itself.
02:24:05 <dmwit> Good point.
02:24:11 <quicksilver> anyhow, the point of insertWith' is to do exactly that.
02:24:20 <quicksilver> "Same as insertWith, but the combining function is applied strictly"
02:24:34 <solrize_> + is not strict
02:24:39 <quicksilver> solrize_: yes, it is.
02:24:43 <vixey> is there anything special about return type polymorphism?
02:24:44 <quicksilver> > undefined + 1
02:24:45 <lambdabot>  Exception: Prelude.undefined
02:24:51 <quicksilver> > 1 + undefined
02:24:52 <lambdabot>  Exception: Prelude.undefined
02:25:02 <quicksilver> (+) is strict on both sides, for all Prelude Num instances.
02:25:02 <solrize_> hmm
02:25:05 <dmwit> vixey: "special"?
02:25:13 <quicksilver> of course, you're free to define it for lazy naturals where it naturally would not be.
02:25:21 <solrize_> ic, the 1 + 2/0 is not evaluated at all
02:25:22 <vixey> > True || (1 == undefined + 1)
02:25:23 <lambdabot>  True
02:25:29 <dmwit> gaetan: Are you getting all of this? =P
02:25:49 <dmwit> vixey: That just proves that (||) is lazy, it says nothing about (+).
02:26:19 <quicksilver> gaetan: short answer : use foldl' and insertWith'
02:26:23 <quicksilver> gaetan: I hope.
02:26:43 <quicksilver> foldl' will strictly do the inserts, insertWith' will strictly do the summing.
02:31:12 <gaetan> I'm not getting everything, I must admit :-)
02:31:31 <gaetan> but fold' and insertWith' works :-)
02:32:03 <gaetan> so I'll learn everything I can about strictness...
02:35:57 <quicksilver> gaetan: better memory performance now?
02:36:29 <quicksilver> gaetan: also, are you compiling with -O ?
02:37:22 <gaetan> it runs with 1 MB of ram now :-)
02:37:30 <gaetan> with -O2 flag
02:38:15 <solrize_> so what happened to theorems for free?  it breaks under strictness?  does fast/loose=morally correct apply?
02:38:42 <quicksilver> gaetan: how big is the file?
02:41:21 <gaetan> the file is 18 MB - the program was using 800 MB before fold' and insertWith'
02:41:30 <gaetan> about 800 times better :P
02:42:30 <quicksilver> yay.
03:00:23 <gaetan> thank you all for your help! The code is very fast now ‚Äî I'll take care of lazy/strict evaluation in the future :-)
03:00:35 <cjs> Damn, I can't beleive that for all this time I'd forgotten about "error".
03:03:40 <dmwit> gaetan: Out of curiosity, how does a purely list-backed approach perform?
03:03:43 <dmwit> Something like
03:04:00 <dmwit> > map (id &&& length) . group . sort $ "hello, world"
03:04:03 <lambdabot>  [(" ",1),(",",1),("d",1),("e",1),("h",1),("lll",3),("oo",2),("r",1),("w",1)]
03:04:22 <dmwit> > map (head &&& length) . group . sort $ "hello, world"
03:04:23 <lambdabot>  [(' ',1),(',',1),('d',1),('e',1),('h',1),('l',3),('o',2),('r',1),('w',1)]
03:05:28 <dmwit> ?index group
03:05:28 <lambdabot> Data.List
03:05:32 <dmwit> ?index (&&&)
03:05:32 <lambdabot> Control.Arrow
03:06:19 <quicksilver> that requires loading the whole file in memory as a list and then sorting it.
03:06:21 <quicksilver> probably not good.
03:06:33 <quicksilver> and 18M file as a list of chars takes a few hundred meg.
03:07:03 <solrize_> bytestring.sort
03:07:09 <dmwit> Oh yeah, list overhead is pretty bad.
03:07:47 <dmwit> Well, you can use a smarter sort. =)
03:07:53 <quicksilver> the head/length/group part should work pretty well though.
03:07:58 <quicksilver> e.g. a bucket sort.
03:08:03 <quicksilver> and then you've solved the whole problem :P
03:08:08 <dmwit> http://65.254.53.221:8000/7462
03:08:28 <dmwit> errr, that's odd, I wonder why it linked to an IP address.
03:08:37 <dmwit> ?go hpaste counting sort
03:08:38 <lambdabot> No Result Found.
03:08:47 <dmwit> orly?
03:09:59 <dmwit> But yeah, at that point you're basically back in Map-land.
03:11:09 <wolverian> hm. does Array implement that efficiently?
03:11:50 <wolverian> phew, the source looks scary.
03:12:51 <dmwit> I wonder why Data.Map implements elemAt :: Int -> Map k a -> (k, a).
03:12:59 <dmwit> That seems like it breaks the Map abstraction.
03:13:10 <twanvl> It doesn't
03:13:31 <twanvl> elemAt i m == toList m !! i
03:13:48 <twanvl> toAscList even
03:14:59 <dmwit> It just seems odd nestled in with functions like findMin and union and stuff.
03:15:06 <quicksilver> yes, it does seem odd.
03:15:13 <quicksilver> presumably someone made a case for its usefulness.
03:20:24 <Botje> @tell nominolo  darcs pull "yyyyyyyyyyyyyyyd" | darcs pull /path/to/ghc << is that first darcs pull supposed to be echo?
03:20:25 <lambdabot> Consider it noted.
03:21:07 <dmwit> heh
03:21:24 <dmwit> That was one of the more clever moments in that post, I thought.
03:22:25 <Botje> just making a local copy of the repo should already give a nice boost
03:22:36 <Botje> because darcs exchanges a lot of information about history when you connect
03:23:15 <matthew_-> ANNOUNCE: Sessions 2008.5.12 released. Some real network support; subtyping of Pids supported and a fix for a horrible and subtle bug
03:29:45 <matthew_-> why does cabal break terminals?
03:30:05 <matthew_-> whenever after doing a configure build sdist or something like that
03:30:12 <matthew_-> the next time I do su
03:30:20 <matthew_-> the first char goes in followed by a nl
03:30:34 <matthew_-> meaning the rest of the password appears as cleartext and the su fails
03:30:46 <matthew_-> I have to hit reset to sort out the terminal
03:31:03 <matthew_-> whether it's readline, bash, xterm or quite what, I dunno, but does this not happen to other people?
03:31:20 <dmwit> This does not happen to other people.
03:31:42 <matthew_-> now that I slightly fail to believe.
03:31:58 <matthew_-> seeing as I can make it happen on multiple machines
03:32:31 <dmwit> =)
03:32:41 <dmwit> Okay, I just meant that there are other people to which it fails to happen.
03:32:47 <dmwit> (Like me.)
03:33:01 <matthew_-> I see
03:33:06 <nominolo> Botje: oh, yes
03:33:06 <lambdabot> nominolo: You have 1 new message. '/msg lambdabot @messages' to read it.
03:33:14 * dmwit will now shut up until he has something useful to add
03:33:46 <matthew_-> ;)
03:34:25 <nominolo> Botje: thanks, fixed
03:35:41 <TSC> matthew_-: I've experienced that behaviour with su before
03:35:51 <TSC> I hadn't noticed it in relation to cabal, though
03:35:55 <matthew_-> TSC: oh!
03:36:06 <matthew_-> for me it's pretty reliable after a clean configure build
03:36:17 <matthew_-> very annoying as when you go to su to do the install
03:36:56 <TSC> Yep, I just reproduced it with clean + configure
03:36:57 <TSC> Weird
03:37:18 <TSC> It's not xterm, because I use rxvt
03:41:13 <cjs> matthew_-, Possibly something interesting in your shell setup. Can you make it happen with another shell, or without your .profile, etc.?
03:52:36 <cjs> It's rxvt!
03:58:40 <TSC> Happens for me with gnome-terminal too
04:04:36 <RayNbow> hehehe... http://reddit.com/r/programming/info/6j4j8/comments/c03zmjl <-- resistance is futile? :p
04:05:46 <TSC> There is a lot of Haskell stuff on reddit
04:06:00 <TSC> "sex in the face" sounds interesting, though
04:06:24 * RayNbow wants to see more Haskell stuff on reddit :p
04:08:22 <dmwit> Try programming.reddit.com, it has much more Haskell stuff.
04:09:29 <RayNbow> dmwit: that's actually the only part of reddit I visit :p
04:09:43 <dmwit> Me too. =)
04:10:33 <RayNbow> sigh... ssh = hell when you're on GPRS
04:11:35 <RayNbow> (my DSL connection is down at the moment and I'm using my cellphone instead to stay online :X)
04:13:24 <matthew_-> agh, overloaded acronynms
04:13:54 * earthy consoles RayNbow. 'Technici zijn op de hoogte'. :) (KPN lost a somewhat important ATM switch)
04:14:13 <RayNbow> :p
04:14:55 <RayNbow> the XS4ALL site lists an incorrect time though... it says the problem started at 3 AM
04:15:07 <RayNbow> my connection died a few minutes past 2 AM :p
04:15:28 * earthy nods
04:15:36 <earthy> sucks to be you. :)
04:16:02 <mattam> @src unfold
04:16:02 <lambdabot> Source not found. My pet ferret can type better than you!
04:16:12 <earthy> mattam: what unfold do you want?
04:16:22 <mattam> On Int.
04:16:25 <earthy> (that is, for what type?)
04:16:33 <mattam> Is that standard ?
04:16:33 <earthy> @type unfoldr
04:16:35 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
04:16:49 <earthy> @src unfoldr
04:16:50 <lambdabot> unfoldr f b  = case f b of
04:16:50 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
04:16:50 <lambdabot>    Nothing        -> []
04:16:51 <mattam> Ok.
04:16:55 <mattam> thx
04:17:00 <earthy> there's also unfoldl
04:17:33 <TSC> There is?
04:18:06 <dcoutts_> matthew_-: do you think it is Cabal or runghc? I've heard of issues with ghci/runghc not resetting terminal states
04:18:30 <matthew_-> well now I'm totally confused
04:18:39 <dcoutts_> matthew_-: are you running the cabal binary or runghc Setup.hs ?
04:18:40 <matthew_-> I can get it to repeatably happen in one xterm
04:18:47 <matthew_-> runghc Setup.hs
04:18:50 <dcoutts_> ok
04:18:58 <matthew_-> but in other xterms it refuses to happen
04:19:06 <dcoutts_> matthew_-: I suspect you'd get it with any program then, not just Setup.hs
04:19:07 <matthew_-> and I can't see why as they're all the same
04:19:16 <mattam> @src unfoldl
04:19:16 <lambdabot> Source not found.
04:19:23 <matthew_-> yeah, that seems likely
04:20:02 <matthew_-> hmm. bizarre. With a new fresh terminal it won't happen.
04:20:20 <matthew_-> but something must go wrong at some point because once it's started happening for me, it keeps happening
04:20:42 <matthew_-> though it sounds like TSC can make it happen from new terminals
04:20:43 <matthew_-> ?
04:20:56 <TSC> Yeah, new rxvt terminals
04:22:14 <solrize_> i've seen that too
04:25:03 <dcoutts_> @src unfoldr
04:25:03 <lambdabot> unfoldr f b  = case f b of
04:25:03 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
04:25:03 <lambdabot>    Nothing        -> []
04:25:10 <dcoutts_> matthew_-: there is no unfoldl
04:25:34 <dcoutts_> erm sorry, mattam
04:25:53 * dcoutts_ tries to think of a unfoldl
04:26:03 <dcoutts_> is it even possible? it's certainly unnatural
04:26:06 <dmwit> reverse . unfoldr
04:26:20 <dmwit> ?hoogle unfold
04:26:21 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
04:26:21 <lambdabot> Data.ByteString.unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
04:26:21 <lambdabot> Data.ByteString.unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
04:27:43 <Deewiant> unfoldl f x = case f x of Nothing -> []; Just (b,a) -> unfoldl f b ++ [a]
04:28:54 <vixey> what's the poin in that
04:29:21 <Deewiant> beats me
04:29:51 <Deewiant> but that's what comes to mind when thinking of unfoldl :-P
04:32:54 <vixey> @src foldl
04:32:55 <lambdabot> foldl f z []     = z
04:32:55 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:33:09 <vixey> :t foldl
04:33:13 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
04:45:41 <ToRA> is there a name for the class of things that have fmap and join (but not return) defined for them?
04:45:53 <vixey> :t join
04:45:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:46:35 <matthew_-> ToRA: class FMapAndJoinButNotReturn ...
04:46:50 <vixey> @src Applicative
04:46:51 <lambdabot> class Functor f => Applicative f where
04:46:51 <lambdabot>     pure  :: a -> f a
04:46:51 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
04:47:01 <vixey> :t fmap
04:47:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:57:45 <luqui> ToRA: (not a categorist) "semimonad"?
04:59:03 <quicksilver> I suspect luqui was right.
04:59:15 <quicksilver> google has a few references to semimonad and that probably ought to be what it means.
05:00:07 <quicksilver> assuming ToRA intends his join to be associative.
05:01:05 <ToRA> i'd assume so - i'm reading a paper that describes "Behaviours" in Flapjax, and outlines that they have those properties
05:01:24 <ToRA> (although annoyingly they call fmap lift, and join switch)
05:04:41 <Cale> lift isn't a bad name for fmap, but switch for join is questionable
05:07:25 <ToRA> i assume it's to allow the same kind of case structures that arrowapply gives to arrows
05:08:44 <slarba> hmm. ** Exception: Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string.
05:08:54 <slarba> but that parser does not accept an empty string...
05:09:18 <mauke> IT DOES NOW
05:09:35 <slarba> huh? :)
05:10:23 <slarba> (yes, I've tried yelling at it. Doesn't help ;))
05:10:54 <mauke> the parser does accept an empty string
05:11:43 <slarba> so it means if I have many x, and x successfully parses "", this happens?
05:12:02 <mauke> yes
05:12:12 <slarba> but x does not parse "", I've proven that
05:12:21 <mauke> technically, it should turn into an empty loop but parsec recognizes this case
05:12:26 <mauke> s/empty/infinite/
05:12:46 <Arnar> hey folks..
05:13:10 <slarba> mauke: does it use position information to detect if a parser accepts an empty string or something?
05:13:15 <Arnar> http://hpaste.org/7587 <- I have a WriterT STM -- and I'm not sure how to lift orElse..
05:13:17 <mauke> I have no idea
05:14:28 <mauke> @unmtl WriterT a STM b
05:14:28 <lambdabot> STM (b, a)
05:14:48 <Arnar> mauke: yeah,, someone (maybe you) showed me that before
05:14:58 <Arnar> although I'm not sure how to make use of it (or what it means exactly)
05:15:15 <Arnar> @help unmtl
05:15:15 <lambdabot> unroll mtl monads
05:15:27 <mauke> :t \a b -> WriterT (runWriterT a `orElse` runWriterT b)
05:15:33 <lambdabot> forall w a. WriterT w Maybe a -> WriterT w Maybe a -> WriterT w Maybe a
05:15:45 <ToRA> :t \x -> mapWriterT (orElse (runWriterT x))
05:15:47 <lambdabot> forall w a. WriterT w Maybe a -> WriterT w Maybe a -> WriterT w Maybe a
05:16:09 <mauke> where did it get the Maybe?
05:16:15 <Arnar> :t orElse
05:16:17 <lambdabot> forall a. Maybe a -> Maybe a -> Maybe a
05:16:21 <Arnar> different orElse
05:16:29 <Arnar> but I guess its the same though
05:16:38 <vixey> @src orElse
05:16:38 <lambdabot> Source not found. My brain just exploded
05:16:55 <vixey> :t >> :: Maybe a -> Maybe a -> Maybe a
05:16:56 <Arnar> :t \x -> mapWriterT (Control.Concurrent.STM.orElse (runWriterT x))
05:16:59 <lambdabot> parse error on input `>>'
05:17:00 <lambdabot> Couldn't find qualified module.
05:17:00 <vixey> :t (>>) :: Maybe a -> Maybe a -> Maybe a
05:17:02 <lambdabot> forall a. Maybe a -> Maybe a -> Maybe a
05:17:07 <Deewiant> slarba: you might accept EOF which counts as the empty string
05:17:17 <vixey> is orElse = (>>) ?
05:17:41 <slarba> Deewiant: AH
05:17:50 <slarba> true
05:17:50 <vixey> > Just 1 >> Nothing
05:17:51 <Deewiant> slarba: which I find annoying :-/
05:17:52 <slarba> thanks
05:17:53 <Arnar> vixey: isn't >> just the parameterless bind?
05:17:56 <slarba> Deewiant: yeah :I
05:17:57 <lambdabot>  Nothing
05:17:59 <vixey> > Nothing >> Just 1
05:18:01 <lambdabot>  Nothing
05:18:16 <vixey> > Just 1 `mplus` Nothing
05:18:18 <lambdabot>  Just 1
05:18:26 <vixey> :t mplus :: Maybe a -> Maybe a -> Maybe a
05:18:29 <lambdabot> forall a. Maybe a -> Maybe a -> Maybe a
05:18:29 <Deewiant> slarba: for my parser which did line-delimited data, this meant that the file has to end in a newline or it doesn't work
05:18:29 <vixey> maybe this then?
05:18:36 <Arnar> vixey: more likely, yes
05:18:43 <Arnar> @index orElse
05:18:43 <lambdabot> Data.Generics.Aliases, Data.Generics, GHC.Conc, Control.Concurrent.STM
05:18:50 <Arnar> @hoogle orElse
05:18:50 <lambdabot> GHC.Conc.orElse :: STM a -> STM a -> STM a
05:18:50 <lambdabot> Data.Generics.Aliases.orElse :: Maybe a -> Maybe a -> Maybe a
05:18:53 <Deewiant> slarba: because I can't accept EOL/EOF because then it would accept "".
05:19:04 <Arnar> @src Data.Generics.Aliases.orElse
05:19:04 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
05:19:42 <Arnar> :t \x -> mapWriterT (GHC.Conc.orElse (runWriterT x))
05:19:44 <lambdabot> forall w a. WriterT w GHC.Conc.STM a -> WriterT w GHC.Conc.STM a -> WriterT w GHC.Conc.STM a
05:19:47 <slarba> Deewiant: parsec 3.0.0?
05:20:11 <Deewiant> slarba: started with 2.0, changed to that when I wanted bytestring support.
05:20:12 <Arnar> with mapWriterT, what happens to the log?
05:20:16 <Arnar> is it concatenated?
05:20:22 <Deewiant> slarba: doesn't matter in terms of the EOL/EOF stuff.
05:20:27 <slarba> ok
05:20:59 <Saizan> :t mapWriterT
05:21:01 <lambdabot> forall (m :: * -> *) a w (n :: * -> *) b w'. (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
05:21:09 <Deewiant> because accepting 'nothing followed by EOF' means you have to accept the empty string and then you're screwed.
05:21:24 <ToRA> the log is kept
05:21:39 <ToRA> sorry
05:21:48 <Arnar> ok, thanks
05:21:51 <ToRA> i mean, erm
05:21:55 <Arnar> doesn't do it for me then :)
05:22:30 <ToRA> i mean the mapWriterT version will be the same as the (run...) `orElse (runW..) version
05:23:08 <Arnar> hmmm
05:24:01 <Saizan> only one of the two branches will succeed, so you get only that log
05:24:41 <Arnar> Saizan: yes..
05:24:45 <Arnar> which is exactly what I need
05:24:48 <Arnar> thanks
05:24:50 <cnwdup> ls
05:24:53 <cnwdup> sry
05:24:59 <vixey> :t orElse
05:25:01 <lambdabot> forall a. Maybe a -> Maybe a -> Maybe a
05:26:21 <quicksilver> :t liftM2 orElse
05:26:24 <lambdabot> forall a (m :: * -> *). (Monad m) => m (Maybe a) -> m (Maybe a) -> m (Maybe a)
05:26:34 <quicksilver> I didn't know that orElse was standard.
05:26:43 <quicksilver> I use something with the same type as the liftM2 version.
05:26:49 <quicksilver> although, not the same semantics
05:26:52 <quicksilver> under that name.
05:27:09 <lilac> :t liftM2
05:27:11 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:27:38 <vixey> :t mplus `asType` orElse
05:27:40 <lambdabot> Not in scope: `asType'
05:27:42 <vixey> :/
05:27:45 <vixey> :t mplus `asTypeOf` orElse
05:27:47 <lambdabot> forall a. Maybe a -> Maybe a -> Maybe a
05:28:02 <quicksilver> @indx orElse
05:28:03 <lambdabot> Data.Generics.Aliases, Data.Generics, GHC.Conc, Control.Concurrent.STM
05:28:16 <vixey> what the hell !
05:28:24 <vixey> @docs Data.Generics
05:28:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics.html
05:29:44 <schme> I'm back.
05:29:45 <ToRA> > runWriterT $ (\x -> mapWriterT (orElse (runWriterT x))) (tell "a" >> mzero) (tell "b" >> return ())
05:29:47 <lambdabot>  Just ((),"b")
05:29:51 <schme> byorgey: I am going to take your advice.
05:29:54 <ToRA> > runWriterT $ (\x -> mapWriterT (orElse (runWriterT x))) (tell "a" >> return ()) (tell "b" >> return ())
05:29:55 <lambdabot>  Just ((),"a")
05:32:33 <Arnar> ToRA: thanks.. I was convinced though :)
05:32:57 <ToRA> i wasn't ;)
05:35:21 <vixey> schme: I thought you'd packed it in :P
05:35:56 <schme> vixey: So did I. I have decided to take byorgey's advice there and write a completely new app from scratch and not just port one I already have. And see how things turn out.
05:36:11 <vixey> oh cool sounds fun, decided what yet?
05:37:05 <schme> Oh yes.
05:38:07 <mm_freak_work> will i get burnt by the community if i diverge from the usual convention to write functions inThisWay?  i like it in_this_way more for some things
05:38:30 <vixey> mmFreakWork: Never!
05:38:56 <schme> vixey: I'm going to write a eeh hmm.. watchama call it.. nutrition meal keep track of kinda program.
05:39:01 <vixey> (seriously, I'm sure you should just write what ever code you think is best, disregarding popular opinion)
05:39:03 <mm_freak_work> hehe (interestingly the highlighting worked even for that) =)
05:41:14 <schme> I guess you call it nutrition software.
05:41:49 <mm_freak_work> i wonder _why_ do haskell people prefer thisWay?
05:42:28 <mauke> they're messed up in the head
05:42:45 <schme> I like 'em in-this-way ;)
05:42:51 <schme> and in working order.
05:43:24 <cjs> I kinda like the scheme way, too. In the end, having switched back and forth between underscores, hyphens and camelCase several times over the past decade, it makes little difference now.
05:43:40 <czShadoW> Because camelCase.
05:44:13 <mauke> hyphens > underscores > miXedCaps
05:44:17 <mm_freak_work> i like hyphens for filenames, but in programming, they won't work for me
05:44:31 <mm_freak_work> even if '-' were allowed
05:44:36 <schme> maybe tHISwAY ?
05:44:55 <mm_freak_work> This%20Way.Function
05:44:58 <vixey> hahahahaha
05:45:00 <mauke> but all haskell libraries useThisStyle and consistency beats all
05:45:00 <schme> my god.
05:45:28 <cjs> ALTER VARIABLE CUMAVG TO BE CUMAVG * 0.5
05:45:58 <mm_freak_work> there is almost _no_ consistency in C++, and people still like the language and don't even notice the mess =)
05:46:13 <mauke> $01->($02,$03)
05:46:17 <mauke> VALID PERL CODE
05:46:36 <mm_freak_work> SELECT (\Y -> ‚Ä¶) WITH Y = X + 1
05:47:07 <saml> how do you print out help menu for terminal application?   putStrLn helpStr  where helpStr = "how can I do multiple line string constant" ?
05:47:18 <quicksilver> schme: some haskell libraries actually do do it tHISWAY
05:47:23 <mauke> "you\nmean\nlike\nthis?\n"
05:47:38 <mm_freak_work> saml: if you're using getOpt, use 'usageInfo'
05:48:12 <quicksilver> saml: I normally do concat ["very long string", \n "and some more"]
05:48:24 <quicksilver> saml: and possibly change 'concat' to 'unlines' or even 'wraplines'
05:49:00 <ToRA> ($01‚Üí($02,$03))
05:49:02 <ToRA> VALID HASKELL
05:49:09 <saml> > unlines ["a", "b"]
05:49:11 <lambdabot>  "a\nb\n"
05:49:14 <saml> cools!
05:49:28 <ToRA> though you need to define ‚Üí and provide some instances...
05:50:04 <Igloo> ToRA: Only valid Template Haskell, no?
05:50:07 <schme> quicksilver: That's not very pretty.
05:50:07 <mm_freak_work> i guess, (‚Üí) == (->)
05:50:22 <ToRA> Igloo: no, that passes the parser on ghci for me
05:50:28 <ToRA> without -fglasgow-exts
05:50:38 <Igloo> Hmm, how is ($02,$03) parsing?
05:51:03 <ToRA> > :t let (‚Üí) = undefined in  ($01‚Üí($02,$03))
05:51:03 <lambdabot>  Parse error at "let" (column 4)
05:51:10 <ToRA> :t let (‚Üí) = undefined in  ($01‚Üí($02,$03))
05:51:12 <lambdabot> parse error on input `í'
05:51:24 <ToRA> hmm, good question
05:51:24 <quicksilver> schme: it's when you have a C #define CONSTANT
05:51:33 <quicksilver> schme: but it maps to a value, not a constructor
05:51:37 <quicksilver> so has to have initial lower ase
05:51:38 <quicksilver> case
05:51:40 <quicksilver> it's quite rare.
05:51:45 <Igloo> That looks like a bug to me
05:52:03 <mauke> > let (f, g) = (+1, /2) in (f 9, g 9)
05:52:03 <lambdabot>  Parse error at "," (column 17)
05:52:12 <mauke> works in my ghci
05:52:23 <Igloo> It's not meant to, though...
05:52:35 <mauke> haha, accidental feature!
05:52:40 <schme> I see.
05:53:14 <ToRA> Igloo: http://hpaste.org/7588
05:53:47 <mm_freak_work> ToRA: it would be great if haskell or GHC supported UTF-8 ;)
05:53:56 <ToRA> mm_freak_work
05:53:58 <ToRA> they do
05:54:03 <mauke> ghci doesn't
05:54:06 <ToRA> it's just the output routines that don't
05:54:15 <Igloo> Hmm, they're deliberately allowed in the parser
05:54:16 <quicksilver> ghci 6.8 supports UTF8, I thought.
05:54:28 <mm_freak_work> really?
05:54:34 <quicksilver> and ghc 6.6 supports UTF8 source (but not ghci)
05:54:46 <mauke> *> ‚Üí
05:54:46 <mauke> <interactive>:1:0: parse error on input `ÔøΩ'
05:54:52 <quicksilver> and of course haskell itself supports unicode.
05:54:59 <quicksilver> but doesn't have built-in utf8 en/de coders
05:55:05 <quicksilver> plenty available on hackage.
05:55:08 <mauke> that error message should be <interactive>:1:0: parse error on input ‚Äò‚Üí‚Äô
05:55:18 <vixey> > let in 3
05:55:20 <lambdabot>  3
05:55:21 <mm_freak_work> indeed‚Ä¶  it does
05:55:24 <mm_freak_work> nice =)
05:55:29 <ToRA> it'd be nice if hpaste understood utf8....
05:55:49 <mm_freak_work> but i guess, i'll stick with ->
05:56:12 <mm_freak_work> it doesn't support the lambda, though =)
05:57:29 <quicksilver> I think it does.
05:57:34 <quicksilver> Maybe you're typing the wrong lambda?
05:57:39 <quicksilver> (ah, the joys of unicode)
05:57:43 <ToRA> it doesn't support lambda for abstraction afaik
05:57:47 <ToRA> it does support it as a variable
05:57:49 <mauke> *> let Œª = 2 in Œª
05:57:49 <mauke> 2
05:57:50 <mm_freak_work> Œªx ‚Üí x+1
05:57:53 <Deewiant> > (Œªx -> x + 1) 2
05:57:54 <lambdabot>  Illegal character ''\187''
05:57:54 <lambdabot>  at "ªx" (column 3)
05:58:10 <mm_freak_work> > let (‚â†) = (/=) in 3 ‚â† 4
05:58:10 <lambdabot>  Illegal character ''\137''
05:58:10 <lambdabot>  at "â†)" (column 7)
05:58:18 <quicksilver> don't even try it here.
05:58:19 <ToRA> mm_freak_work -fglasgow-exts
05:58:24 <quicksilver> lambdabot doesn't support it :)
05:58:31 <quicksilver> lambdabot != ghci
05:58:32 <mm_freak_work> ToRA: it works here
05:58:35 <mauke> heh, this one's particularly bad
05:58:37 <mauke> *> ‚â†
05:58:37 <mauke> <interactive>:1:0: parse error on input ``'
05:58:37 <ToRA> ah ok
05:58:56 <ToRA> oh yeah, for normal stuff you can use unicode regardless.  you need -flgasgow-exts to use ‚Üí as an arrow in types etc.
05:59:13 <Deewiant> -XUnicodeSyntax to be exact
05:59:20 <ToRA> ah cool
05:59:30 <mm_freak_work> main = print $ 3 ‚â† 3  where (‚â†) = (/=)
05:59:32 <mm_freak_work> works well =)
05:59:56 <mm_freak_work> and since i really hate that (/=) notation, maybe i'll switch to ‚â†
06:00:01 <ToRA> we need a UnicodePrelude for all the obvious aliases...
06:00:54 <mauke> just define (!=) = (/=)
06:01:33 <mm_freak_work> dunno‚Ä¶  there's no notation that's really satisfying‚Ä¶  ASCII is just not sufficient for such a mathematical language
06:01:48 <Deewiant> unfortunately my font isn't sufficient for Unicode ;-)
06:02:22 <matthew_-> nor is my keyboard
06:02:25 <mauke> ÔΩáÔΩÖÔΩî ÔΩçÔΩèÔΩíÔΩÖ ÔΩÜÔΩèÔΩéÔΩîÔΩì
06:02:41 <Deewiant> unfortunately my OS can't handle using more than one font at once
06:02:51 <Deewiant> (I don't think, anyway.)
06:02:51 <quicksilver> clearly time to mention the optimus maximus keyboard
06:02:58 <quicksilver> which OS, Deewiant ?
06:03:01 <mauke> DOS
06:03:02 <Deewiant> WinXP
06:03:12 <quicksilver> it can do more than one font.
06:03:15 <quicksilver> just look at a word document.
06:03:19 <quicksilver> what you need is a decent editor.
06:03:23 <Deewiant> GVim, then.
06:03:32 <mauke> s/editor/terminal/
06:03:40 <quicksilver> or that.
06:03:45 <Deewiant> it helps that Office probably writes half of the kernel from scratch for its own uses.
06:04:01 * quicksilver shrugs
06:04:15 <quicksilver> I know nothing about win32 but I'd be jolly surprised if it's particularly hard to use more than one font.
06:04:24 <quicksilver> certainly the emacs/win32 screenshots are usingmore than one font.
06:05:01 <Deewiant> placing the blame on Uniscribe might be the right thing to do. Not sure though.
06:08:04 <mm_freak_work> emacs in windows does support more than one font, for sure
06:08:10 <mm_freak_work> and it also supports unicode
06:09:36 <saml> @where map
06:09:36 <lambdabot> http://www.haskell.org/haskellwiki/HaskellUserLocations
06:12:26 <Arnar> is >>= usually associative?
06:12:45 <mauke> isn't that one of the laws?
06:13:02 <Deewiant> mm_freak_work: I'm thinking of automatically falling back to another font if some glyph doesn't exist in the current
06:13:17 <Arnar> mauke: yes, apparently :)
06:13:33 <mauke> urxvt does that
06:14:07 <mm_freak_work> yeah, urxvt does that, but i don't know whether emacs supports fallback
06:14:21 <mm_freak_work> never needed it
06:14:21 <twobitwork> how can I tell where ghci is looking for modules?
06:14:28 <twobitwork> i.e., for :load
06:14:52 <Arnar> twobitwork: :set -v
06:15:16 <mm_freak_work> Arnar: if it's a law, then >>= is always associative, and a monad, where this isn't the case, is invalid
06:15:42 <Arnar> mm_freak_work: yes.. it is a law
06:16:00 <twobitwork> Arnar: ok... it doesn't show any paths... but does give a lot of other stuff
06:16:13 <Arnar> twobitwork: do the :load again
06:16:18 <twobitwork> I did
06:16:23 <twobitwork> says: <no location info>: module `Data.Yaml.Syck' is a package module
06:16:28 <twobitwork> (amongst other things)
06:16:31 <Arnar> twobitwork: maybe I'm telling you lies.. :)
06:16:49 <twobitwork> want me to paste it ? :)
06:17:24 <Arnar> twobitwork: .. no, I mean I may be misleading you (I wasn't being sarcastic)
06:17:29 <Arnar> you should never listen to me anyways :)
06:17:35 <quicksilver> Arnar: it doesn't make sense to ask if >>= is associative.
06:17:38 <Arnar> if I do :set -v and then a :load
06:17:44 <twobitwork> http://hpaste.org/7589
06:17:45 <quicksilver> it is not a binary operation of the form a -> a -> a
06:18:03 <Arnar> quicksilver: right..
06:18:07 <quicksilver> it *does* however make sense to ask if >> is associative.
06:18:12 <quicksilver> and that is one of the laws, yes.
06:18:16 <Arnar> quicksilver: but you can think of it as composition of actions
06:18:29 <quicksilver> >>= doesn't have matching types.
06:18:34 <conal> sjanssen: is the lazy trie code you pasted a while back (http://hpaste.org/3839) in a hackage package?
06:18:36 <quicksilver> given "a >>= b >>= c"
06:18:44 <quicksilver> there will only be one type-correct way to bracket it.
06:19:24 <mauke> :t (?a >>= (\x -> ?b >>= \y -> ?c), (?a >>= \x -> ?b) >>= \y -> ?c)
06:19:28 <lambdabot> forall (m :: * -> *) a a1 b. (?a::m a, ?b::m a1, Monad m, ?c::m b) => (m b, m b)
06:19:50 <conal> @localtime sjanssen
06:19:50 <Arnar> quicksilver: right.. but "associative" is used as an informal alias of (m >>= f) >>= g == m (\x -> f x >>= g).. right?
06:19:51 <lambdabot> Local time for sjanssen is Tue May 13 08:19:57 2008
06:20:14 <quicksilver> well, perhaps.
06:20:22 <Arnar> sorry.. s/(/>>= (/
06:20:27 <quicksilver> but then I'd rather speak of >> being associative.
06:20:31 <quicksilver> ;)
06:20:38 <Arnar> quicksilver: yes.. that makes more sense :)
06:20:46 <Arnar> I was just wondering what happened if it wasn't
06:21:01 <quicksilver> your CPU will compact into a strangelet
06:21:04 <quicksilver> which will eat the world.
06:21:07 <quicksilver> the monad laws are serious stuff.
06:21:17 * Arnar hits ctl+c frantically
06:21:38 <lilac> quicksilver: you sure? i thought the leading theory was you'd create a micro-black-hole?
06:21:58 <Arnar> lilac: aren't the observable effects the same?
06:22:15 <twobitwork> lmao
06:22:27 <lilac> Arnar: there's a chance the micro-black-hole would evaporate before it fell into the centre of the planet and ate it from the inside out
06:22:47 <Arnar> lilac: ok.. so the two theories are not weakly bisimilar then?
06:23:11 <lilac> Arnar: i think it depends on which optimizations your compiler does.
06:23:23 <saml> <- has lower precedence than `operator`  right?
06:23:23 * twobitwork tries it out
06:23:39 <saml> s <- f `catchError` (\e -> ...) it seems
06:23:45 <mauke> saml: <- doesn't really have a precedence
06:23:49 <mauke> it's syntax, not an operator
06:24:27 <Arnar> mauke: meaning it has the highest "apparent" precedence?
06:24:41 <Arnar> sorry.. lowest
06:24:42 <mauke> more like lowest
06:24:45 <twobitwork> so, can someone help me out loading this Syck module?
06:25:03 <DarkAurel> Hi All!
06:25:16 <twobitwork> http://hpaste.org/7589
06:27:12 <DarkAurel> May anyone tell me why "[f 5 | f <- [(*2), (^5)]]" works, but "[do f | f <- [putStrlLn "123", putStrLn "456"]]" -- doesn't?
06:28:23 <mauke> do f is the same as f
06:28:31 <mauke> how doesn't it work?
06:28:40 <mauke> > [do f | f <- [putStrlLn "123", putStrLn "456"]]
06:28:42 <lambdabot>   Not in scope: `putStrlLn'
06:28:43 <sjw> you probably want sequence there
06:28:46 <mauke> > [do f | f <- [putStrLn "123", putStrLn "456"]]
06:28:48 <lambdabot>  [<IO ()>,<IO ()>]
06:28:55 <Arnar> twobitwork: I have no idea if it helps.. but can you do :m +Data.Yaml.Syck
06:29:04 <sjw> > sequence_ [do f | f <- [putStrLn "123", putStrLn "456"]]
06:29:06 <lambdabot>  <IO ()>
06:29:27 <mauke> [x | x <- y] is equivalent to y
06:29:35 <twobitwork> Arnar: hmm.... I get a "Prelude Data.Yaml.Syck>" prompt... but I'm not sure what that means..
06:29:44 <twobitwork> is there any module introspection in ghci?
06:29:45 <Arnar> twobitwork: that means Data.Yaml.Syck is loaded
06:29:53 <twobitwork> huh...
06:31:19 <mm_freak_work> > [ f | f <- [ putStrLn "1", putStrLn "2" ] ]
06:31:21 <lambdabot>  [<IO ()>,<IO ()>]
06:31:34 <Deewiant> > [ putStrLn "1", putStrLn "2" ]
06:31:35 <mm_freak_work> > foldl1 (>>=) [ f | f <- [ putStrLn "1", putStrLn "2" ] ]
06:31:36 <lambdabot>  [<IO ()>,<IO ()>]
06:31:36 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> b
06:31:36 <lambdabot>       Expec...
06:31:44 <mm_freak_work> > foldl1 (>>) [ f | f <- [ putStrLn "1", putStrLn "2" ] ]
06:31:45 <lambdabot>  <IO ()>
06:32:29 <Arnar> when can we expect real world haskell to be available in print?
06:32:55 <sjw> mm_freak_work: == sequence_ :)
06:33:07 <mm_freak_work> sure, just experimenting =)
06:33:07 <Deewiant> @src sequence_
06:33:08 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
06:33:16 <quicksilver> Arnar: you can preorder it already.
06:33:25 <mm_freak_work> foldr1 should work, too, shouldn't it?  since (>>=) is associative
06:33:48 <mm_freak_work> yeah, it does, as sequence_ is defined in terms of it =)
06:33:49 <Arnar> quicksilver: yes.. but I'm ordering more books with it (shipping to iceland is no joke).. wondering if I should wait or get the other stuff seperately
06:35:58 <twobitwork> what just happened?
06:36:08 <Deewiant> 2008-05-13 16:29:56 --> twobitwork (n=isaac@nat/ibm/x-65f6e356e8a189f9) has quit (Read error: 104 (Connection reset by peer))
06:36:25 <mauke> huhu
06:36:26 <Arnar> poor guy.. :)
06:36:30 <mauke> -!- .quit twobitwork [Read error: 104 (Connection reset by pee]
06:43:11 <cremetorte> hi i want to programm a function  fakt::Int->[Int]   it shall divide my number  n into primfactors like that     fakt 128128 = [13,11,7,2,2,2,2,2,2,2] but i cant think of any algoritm is there any known algorithm
06:45:17 <Zao> cremetorte: The trivial would be to divmod with increasing primes until you've reached the square root of the number?
06:45:33 <mauke> or simply increasing numbers
06:45:55 <ketil> what's the status of strict Data.Map/Data.Set?
06:46:03 <cremetorte> reach the square root of the number i have to think about it :) thanks
06:46:10 <Zao> mauke: Indeed, but that would be less effective.
06:46:12 <MyCatVerbs> @src sum
06:46:12 <lambdabot> sum = foldl (+) 0
06:46:18 * MyCatVerbs stabs the Prelude.
06:46:21 <ketil> I used a lookup for a non-existing value to force them, but that's a hack that's likely to leave a lot of stuff unevaluated, I think?
06:46:42 <Zao> mauke: But the primes themselves may be non-trivial to generate, so increasing numbers will do :)
06:46:58 <ketil> @hoogle insertWith'
06:46:59 <lambdabot> Data.Map.insertWith' :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
06:47:18 <ketil> ...isn't available in my version of Data.Map :-(
06:48:30 <cremetorte> what do you mean with reach square root of the number  e.g.  fakt 22 would be [2,11]  but square root of 22 is 4,3...
06:49:13 <Zao> Err, half then.
06:49:21 <cremetorte> k
06:50:09 <mauke> > let fakt = fakt' 2 where fakt' d n | d > n = [] | n `mod` d == 0 = d : fakt' d (n `div` d) | otherwise = fakt' (d + 1) n in fakt 22
06:50:11 <lambdabot>  [2,11]
06:50:17 <mauke> > let fakt = fakt' 2 where fakt' d n | d > n = [] | n `mod` d == 0 = d : fakt' d (n `div` d) | otherwise = fakt' (d + 1) n in fakt 128128
06:50:19 <lambdabot>  [2,2,2,2,2,2,2,7,11,13]
06:50:51 <cremetorte> mh looks good
06:51:11 <mauke> ... said the torte
06:51:23 <cremetorte> (= its german ;)
06:54:45 <mm_freak_work> mauke: a better termination constraint would be n == 1
06:55:17 <mauke> how is that better?
06:55:50 <cremetorte> mh i'm so new to haskell i try to figure out what you did and especially how you did it so fast :)
06:56:12 <mauke> do you know any other programming language?
06:56:14 <mm_freak_work> factors' c 1 = []
06:56:14 <mm_freak_work> factors' c n = if rem n c == 0 then c : factors' c (div n c) else factors' (c+1) n
06:56:37 <ThreeWood> I've noticed there's been an explosion of research into computing factorials lately
06:56:37 <mauke> mm_freak_work: fails for n < 1
06:56:48 <mm_freak_work> mauke: it makes no sense to run this algorithm for n < 1
06:56:53 <mauke> yes, it does
06:56:58 <mauke> > let fakt = fakt' 2 where fakt' d n | d > n = [] | n `mod` d == 0 = d : fakt' d (n `div` d) | otherwise = fakt' (d + 1) n in fakt 0
06:56:59 <lambdabot>  []
06:57:13 <ThreeWood> factorizations*
06:57:20 <mm_freak_work> let fakt = fakt' 2 where fakt' d n | d > n = [] | n `mod` d == 0 = d : fakt' d (n `div` d) | otherwise = fakt' (d + 1) n in fakt (-1)
06:57:23 <mm_freak_work> > let fakt = fakt' 2 where fakt' d n | d > n = [] | n `mod` d == 0 = d : fakt' d (n `div` d) | otherwise = fakt' (d + 1) n in fakt (-1)
06:57:25 <lambdabot>  []
06:57:31 <mm_freak_work> > let fakt = fakt' 2 where fakt' d n | d > n = [] | n `mod` d == 0 = d : fakt' d (n `div` d) | otherwise = fakt' (d + 1) n in fakt (-15)
06:57:33 <lambdabot>  []
06:57:37 <cremetorte> @mauke: sure i do know others
06:57:38 <lambdabot> Unknown command, try @list
06:57:55 <mm_freak_work> mauke: does fakt (-15) == [] make more sense than not defining it at all?
06:58:11 <mauke> mm_freak_work: at least I know it terminates in my version
06:58:27 <mm_freak_work> then your version is different, or lambdabot is buggy =)
06:58:28 <twobitwork> do { x <- 4; y <- x + 4; z <- y * 3; print z }
06:58:38 <twobitwork> what's wrong with that
06:58:50 <twobitwork> I know this is completely noobish :P
06:59:01 <cremetorte> @ mauke i know others but no other functional programming language
06:59:12 <mauke> cremetorte: void fakt(int n) { int d; for (d = 2; d < n; ) { if (n % d == 0) { printf("%d\n", d); n /= d; } else { d += 1; } } }
06:59:19 <mm_freak_work> twobitwork: it doesn't make sense
06:59:35 <twobitwork> mm_freak_work: I'm sure :) , I'm just trying to figure out do notation
06:59:42 <mauke> > let { x = 4; y = x + 4; z = y * 3 } in z
06:59:43 <lambdabot>  24
06:59:44 <mm_freak_work> twobitwork: then figure out monads ;)
07:00:00 <mauke> twobitwork: if you just want to give names to values, use 'let'
07:00:03 <cremetorte> thanks mauke it'll help me more to understand ;)
07:00:08 <twobitwork> ok
07:00:20 <twobitwork> I thought let was just a synonym for the <- notation?
07:00:40 <mm_freak_work> twobitwork: do { a; b; c } is the same as:  a >> b >> c
07:00:45 <mm_freak_work> just syntactic sugar
07:00:52 <mauke> twobitwork: no
07:00:58 <mauke> 'let' is primitive
07:01:15 <mauke> do { x <- y; z } notation is syntactic sugar for y >>= \x -> z
07:01:21 <mauke> (that's a call to the >>= operator)
07:01:40 <mm_freak_work> do { a <- b; c <- d; e <- f; g } is the same as b >>= (\a -> d >>= (\c -> f >>= (\e -> g)))
07:01:59 <mauke> @undo do { a <- b; c <- d; e <- f; g }
07:01:59 <lambdabot> b >>= \ a -> d >>= \ c -> f >>= \ e -> g
07:02:07 <mauke> @. redo undo do { a <- b; c <- d; e <- f; g }
07:02:08 <lambdabot> do { a <- b; c <- d; e <- f; g}
07:03:00 <conal> @seen sjanssen
07:03:00 <lambdabot> sjanssen is in #xmonad and #haskell. I last heard sjanssen speak 5h 22m 32s ago.
07:03:37 <conal> @ask sjanssen is the lazy trie code you pasted a while back (http://hpaste.org/3839) in a hackage package?
07:03:37 <lambdabot> Consider it noted.
07:04:34 <Valodim> ask? what's the difference to a regular message?
07:04:49 <mauke> @help ask
07:04:50 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
07:04:58 <Valodim> sweet
07:05:05 <mauke> @help tell
07:05:05 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
07:05:09 <mauke> wh
07:05:54 <mm_freak_work> data (:->:) a :: * -> *   -- what's that?
07:06:08 <conal> mm_freak_work: a GADT
07:06:25 <conal> mm_freak_work: sorry.  an associated type
07:06:59 <conal> mm_freak_work: it's a pretty new language feature.
07:07:33 <conal> http://www.haskell.org/haskellwiki/GHC/Indexed_types
07:07:36 <lambdabot> Title: GHC/Type families - HaskellWiki
07:08:47 <anne> Hello all. I'm fairly new to haskell and don't know much about type theory, so although I've been reading for some time, I couldn't find a clean way to de/serialize dynamic typed data (I tried a lot of things and switched back to Data.Dynamic to no avail). Is there any approach you would suggest?
07:09:01 <mm_freak_work> conal: thank you
07:09:06 <anne> And in addition, it would be really cool if there was a way to typecast a Typeable using a TypeRep, but I think it's theoretically impossible.
07:09:12 <saml> @hoogle Fractional -> Integral
07:09:12 <lambdabot> No matches, try a more general search
07:12:26 <cremetorte> i have one more question for understanding. fakt = fakt' 2 where fakt' d n...  n is my Int i entered, but what is d what type ( prob int) but initiated who and with what value?
07:13:06 <mauke> fakt' is a local helper function with two parameters, d and n
07:13:17 <cremetorte> i understand that
07:13:18 <mm_freak_work> cremetorte: there is no 'initialization' concept in haskell‚Ä¶  the 'initialization' is done by the "fakt" function
07:13:27 <mauke> the definition of fakt calls fakt', passing 2 as d
07:13:34 <mauke> n comes from the user calling fakt
07:13:38 <cremetorte>  ok
07:13:54 <saml> to print out stack trace on error, do you use Writer moand?
07:13:59 <cremetorte> sorry i know that are really low questions :/
07:14:28 <mm_freak_work> cremetorte: the whole fakt' function is likely of type:  Integral i => i -> i -> [i]
07:14:42 <mm_freak_work> so d has the same polymorphic type as n
07:14:54 <cremetorte> k
07:15:06 <mm_freak_work> cremetorte: it helps to write explicit type signatures
07:15:22 <mm_freak_work> twobitwork: http://haskell.org/haskellwiki/Tutorials#Using_monads
07:15:23 <lambdabot> Title: Tutorials - HaskellWiki
07:15:32 <mercury^> cremetorte: you can check types in ghci
07:15:58 <mercury^> :t fakt -- for example
07:16:01 <lambdabot> Not in scope: `fakt'
07:16:06 <cremetorte> k i will be quite :) and try to understand everything point after point ;)
07:16:10 <cremetorte> thanks to all
07:18:03 <cremetorte> reason for all asking is: i copied the function in a test.hs and tried to run it whith ghci , but something is wrong with the syntax probably because fakt 22 in the programm returns only [2]
07:18:30 <mercury^> what is the function supposed to do and what does it look like?
07:19:30 <byorgey> anne: I think deserialization of dynamically typed data is a very hard problem in a statically typed language like haskell.
07:19:49 <byorgey> I don't know much about it though, maybe someone else will have some thoughts/pointers.
07:20:32 <anne> I've been looking for a read function similar to Data.Generic's gread :-/
07:20:53 <saml> how would you implement modules?  (import Blah) (def f (x) (Blah.f x))  maybe (import Blah) is replaced with content of Blah.lsp  where all function names there are prepended by "Blah." ?
07:21:28 <anne> byorgey: Thanks for the comment, it's good to know that I'm not missing something obvious. :-)
07:22:58 <vixey> saml: I wouldn't do it that way
07:23:30 <saml> vixey: how would you do it?
07:24:08 <quicksilver> anne: it's easy if it's "dynamic but I know what type it is when I'm loading it"
07:24:26 <vixey> saml: I'd define namespaces, foo:bar looks for the symbol foo in the bar namespace, (import Blah) evaluates the file with package (or some other appropriate name) bound to Blah so values are stored into that namespace
07:24:28 <quicksilver> anne: e.g. explicit tags in the stream.
07:24:30 <anne> quicksilver: Yes. But it's not the case.
07:24:31 <quicksilver> it's hard otherwise.
07:24:45 <vixey> saml: one advantage is it's trivial to go (import Blah as foo)
07:25:38 <saml> hrm that might be another refactoring
07:25:52 <ThreeWood> quicksilver: Is that still true if you just have an existential type?
07:26:25 <anne> quicksilver: I want the users of my library to be able to use any type whatsoever (e.g. functions).
07:35:39 <quicksilver> ThreeWood: with an existential it's essentially impossible. AFAIK.
07:35:44 <quicksilver> (a general existential)
07:36:02 <quicksilver> you have to be able to encode the type reps into the stream.
07:38:22 <anne> TypeRep and Show can be used to encode data, but I don't know if it's possible to decode them. Data.Genetics does this, but then again, there is no dynamic type using Data. I'm a little bit confused about it.
07:41:02 <quicksilver> anne: I don't believe it is possible.
07:41:06 <anne> Say, for instance, user creates a data type like 'data K a = J [a] | N deriving (Show, Typeable)'. It's very easy for me to understand what "(K Integer, J [0, 1])" means and I can decode it in my mind :-)
07:41:17 <quicksilver> types in haskell have to exist at compile time.
07:41:26 <quicksilver> if you're decoding an over-the-wire protocol
07:41:31 <quicksilver> which may contain a TOTALLY UNKNOWN TYPE
07:41:37 <quicksilver> invented by your peer
07:41:42 <anne> Ah, no no
07:41:44 <quicksilver> there is no way for the compiler to know it at compile time.
07:42:09 <anne> What I meant by the 'user' is the person who's importing my library
07:42:22 <anne> So the types are available during compile time
07:42:33 <quicksilver> ah, it might be possible then.
07:42:53 <anne> So for instance "(K Integer, J [0, 1])" would be decoded to J [0, 1] :: K Integer
07:42:58 <quicksilver> there's no way to get back from a TypeRep to a type, though.
07:43:04 <quicksilver> all you can do is compare two TypeReps
07:43:08 <quicksilver> (which is how 'cast' works)
07:43:26 <s_clv> anne: have you looked at syb-with-class?
07:43:29 <anne> :-/ Yes, I use a lookup table containing all possible types actually...
07:43:51 <anne> SYB yes, SYB-with-class no, I'll check it now...
07:43:54 <quicksilver> Yes.
07:43:58 <quicksilver> You will need the lookup table.
07:44:03 <quicksilver> With the lookup table it should be possible.
07:44:08 <s_clv> it might not solve your problems, but odds are if you run into a limitation in syb, the with-class approach helps.
07:44:32 <s_clv> its described in the third syb paper on the site, and hackage has a package implementing it.
07:44:37 <quicksilver> For example, consider this:
07:44:50 <quicksilver> Data.Map TypeRep (String -> Dynamic)
07:45:02 <quicksilver> this contains a map from typereps, to "read" functions.
07:45:10 <quicksilver> the "read" functions wrap what they read into Dynamic.
07:45:11 <anne> s_clv: Thanks.
07:45:40 <quicksilver> (so you read the TypeRep first, then hand off to the read map in the table)
07:45:52 <s_clv> but still there's no way to on-the-fly serialize an arbitrary function in haskell.
07:46:27 <s_clv> you need to reify it, and then it gets rather ugly..
07:46:31 <anne> quicksilver: I'll try that approach.
07:46:51 <anne> quicksilver: I imagine that would be rather limited though...
07:47:26 <twobitwork> is there anything apt-like for cabal? seems like it should be doable
07:47:36 <dcoutts_> twobitwork: yes, cabal-install
07:47:57 <anne> s_clv: For functions, I would probably use a lookup table.
07:48:08 <dcoutts_> twobitwork: it's still kind of work in progress, especially the dependency resolution
07:49:53 <quicksilver> anne: it's limited to a finite number of types, sadly.
07:50:02 <quicksilver> anne: but it should be fine apart from that.
07:50:20 <quicksilver> you might be able to do something cleverer
07:50:29 <quicksilver> for finitely generated infinite families of types.
07:50:58 <anne> quicksilver: Yes, that might be correct. I'm still trying to get my mind around it. I'll see if I can implement it.
07:51:17 <twobitwork> dcoutts_: ok.... is it worth using?
07:51:43 <dcoutts_> twobitwork: I think so, but then I'm hacking on it :-)
07:51:53 <twobitwork> hehe
07:52:20 <anne> quicksilver: Thanks.
07:53:30 <twobitwork> dcoutts_: hmm... cabal-install should boostrap itself... had to manually install 2 depends :P
07:54:16 <dcoutts_> twobitwork: heh, right
07:59:34 <quicksilver> anne: yes, I'm pretty sure you can do (for example) a finite set of types, plus all permutations of tuples, Eithers, and Lists.
07:59:45 <quicksilver> anne: that gets you quite a long way.
08:01:23 <anne> quicksilver: Yes, I think so. This should also enable the user to supply read functions corresponding to the type he creates.
08:02:34 <quicksilver> anne: yes, you can write this:
08:02:36 <paczesiowa> is it possible (and under what conditions) to turn function :: [a] -> b to (fold fun, initial value) ?
08:02:55 <quicksilver> supplyRead :: Typeable a => (String -> a) -> m ()
08:03:04 <quicksilver> anne: to "attach new" read handlers.
08:03:27 <byorgey> paczesiowa: I'm not sure what you mean.  can you give an example?
08:03:31 <Baughn> Anyone know who I might ask about opengl/ghci interactions?
08:03:33 <quicksilver> paczesiowa: in general, certainly not.
08:03:45 <paczesiowa> byorgey: length -> (const(+1), 0)
08:03:47 <quicksilver> Baughn: my limited knowledge is I don't thin it's possible and I don't try.
08:03:52 <byorgey> ah, I see
08:04:02 <quicksilver> paczesiowa: I'm not sure if there is anything specific you can say about when it's possible.
08:04:22 <Baughn> quicksilver: I got the most bizarre bugs imaginable. I was hoping someone could explain why, but so far no good.
08:04:32 <quicksilver> paczesiowa: you can try, for example, looking at the values of the function on [0], [0,0], [0,0,0], [0,0,0,0] and so on.
08:05:01 <quicksilver> Baughn: I've always believed it not to be possible. I use ghci to check the types + syntax of my opengl programs.
08:05:07 <quicksilver> Baughn: but I always compile to actually test the 3D bits.
08:05:13 <quicksilver> Baughn: of course, it would be cool if it worked.
08:06:08 <Baughn> quicksilver: The interpreter has an api as well, and then there's the plugin interface. I need to figure out exactly /why/ it isn't working, and whether those would be troublesome as well..
08:06:26 <Baughn> I ask because I'm writing an application that will use opengl /and/ have an embedded haskell interpreter
08:07:19 <Baughn> Well, maybe I'll try the cafe
08:07:27 <quicksilver> Baughn: I will be very interested to hear what ou find out.
08:07:58 <Baughn> quicksilver: You're saying nobody knows? That's.. hmm
08:09:13 <Baughn> Okay, step one: strace the equivalent C program
08:09:28 <paczesiowa> I was thinking about that mean function (from reddit) and it would be nice to have general function to take two list traversal functions and turn them into one traversal, but this requires them to be in foldl form
08:09:43 <quicksilver> Baughn: well knock me down with a feather!
08:09:49 <quicksilver> Baughn: it works much more than I expected.
08:09:52 <swiert> @google When is a function a fold
08:09:53 <lambdabot> http://www.cs.nott.ac.uk/~gmh/when.pdf
08:09:54 <vixey> paczesiowa: did you see Olegs zip with using fold?
08:10:04 <swiert> paczesiowa: You might be interested in that link.
08:10:06 <quicksilver> Baughn: I can run my rather complex openGL game from ghci
08:10:13 <quicksilver> Baughn: it appears to all work except event dispatch
08:10:20 <quicksilver> (mind you without key input it's not a very good game)
08:10:25 <paczesiowa> it always comes down to Oleg:)
08:10:28 <Baughn> quicksilver: That coincides with my experience, yes
08:10:38 <quicksilver> Baughn: I'm sure last time I tried that didn't work.
08:10:49 <Baughn> quicksilver: It's *fragile*
08:10:51 <quicksilver> Baughn: as it happens I'm using macos and I'm sure that adds an extra wrinkle.
08:11:08 <paczesiowa> swiert, vixey: thanks for links
08:11:10 <quicksilver> the launched application didn't get properly registered with the OS : it didn't get window decorations and stuff.
08:11:13 <quicksilver> that's probably related.
08:11:27 <Baughn> quicksilver: Seems to be a few dozen race conditions, to start with. Adding an evaluate call to the timer callback breaks window rendering entirely, while when it's /nearly/ a no-op it "works"
08:11:37 <Baughn> ..yeah, that too
08:11:41 <quicksilver> Baughn: that's very interesting.
08:11:45 <quicksilver> what OS are you on?
08:11:49 <Baughn> Leopard
08:12:10 <s_clv> totally ignorant question -- maybe if ghci was run within X?
08:12:18 <Arnar> how do I unset -v in ghci?
08:12:32 <Baughn> Don't have X here. Don't intend to install it until I find one that, er, works properly..
08:12:52 <Baughn> quicksilver: It would be hard to do this by accident, unless GLUT/OpenGL happens to grab the same signals/alarms/whatever as ghci. That's my guess at the moment
08:13:00 <Baughn> So I'll be tracing the c program and comparing
08:13:12 <quicksilver> s_clv: good question. I will try that.
08:14:05 <quicksilver> s_clv: same behaviour
08:14:21 <quicksilver> but a bit harder to kill, because it's harder to kill an xterm which has lost its signals than an emacs subprocess :)
08:14:34 <SamB> is there a Y yet?
08:14:35 <quicksilver> s_clv: of course, GLUT on the mac is compiled to the mac native window layer.
08:14:50 <quicksilver> You could imagine a version of freeglut compiled on the mac but targetted to X11/GLX
08:14:56 <quicksilver> that would behave more like linux I imagine.
08:15:21 <Baughn> s_clv: For my part, I'm happy that ghc will at least give me opengl support on all three major platforms
08:15:33 <Baughn> So I'm busy writing a neat little UI framework in my copious spare time
08:15:56 * Baughn is trying to make something that feels native to haskell
08:16:21 <quicksilver> GL is a surprisingly fun language for UI experiments
08:16:30 <quicksilver> I actually prefer it to the major OO toolkits in many ways.
08:16:34 <s_clv> awesome -- haskell targeting cross-platform apps is made of win.
08:16:57 <SamB> s_clv: made of POSIX, itym
08:17:04 <quicksilver> *laugh*
08:17:16 <quicksilver> of course WX is also impressively X-platform.
08:20:27 * Baughn wishes $= was in something more standard
08:21:14 <quicksilver> Baughn: have you seen my 'with' combinator?
08:21:32 <Baughn> quicksilver: Nope
08:23:12 <quicksilver> Baughn: http://hpaste.org/7590
08:23:18 <quicksilver> use it like this:
08:23:36 <quicksilver> with [ depthFunc := Nothing, lighting := Disabled ] $ do
08:24:12 <Valodim> is it just me or does the haskell.org server have some serious hiccups lately
08:24:24 <quicksilver> it has, yes.
08:24:29 <quicksilver> I believe it's a bit overloaded.
08:24:39 <mm_freak_work> i'm using SDL for everything that's graphics, but not GUI
08:28:34 <saml> http://hpaste.org/7591  is this ok?
08:28:43 <twobitwork> hmm.... well, cabal-install failed :(
08:28:46 <saml> "foo.bar" ==> ["foo", "bar"]
08:30:05 <twobitwork> saml: seems wrong, seems like it should be recurive instead of using reverse so many times
08:32:50 <Beelsebob> hmm, is there no equiv of System.Directory.copyFile for directories?
08:33:15 <twobitwork> saml: http://hpaste.org/7591#a1
08:34:06 <twobitwork> well... that's naive and simple, but I hope you get the idea
08:34:41 <twobitwork> should be something like: splitAtDot "" = ""
08:35:05 <mm_freak_work> Beelsebob: copy for files, recurse for directories‚Ä¶  AFAIK there is no ready-made solution, but it should be fairly easy
08:41:43 <roconnor> @src sum
08:41:43 <lambdabot> sum = foldl (+) 0
08:41:52 <roconnor> whoa
08:42:08 <roconnor> > sum [1..10000000]
08:42:11 <swidgy> i know.  folds do that to me to
08:42:24 <opqdonut> roconnor: yeah, it's not foldl'
08:42:38 <roconnor> It isn't foldl' ... but you cannot trust @src too much.
08:42:53 <roconnor> is there a sum' ?
08:43:14 <roconnor> @pl \(s,n) x -> (s+x, n+1)
08:43:17 <vixey> I think @src is ok now
08:43:31 <roconnor> @src sort
08:43:49 <chessguy> way to kill the bot, roconnor
08:44:05 <roconnor> chessguy: not my fault
08:44:16 <quicksilver> foldr (+) might be useful definition for some obscure cases ;)
08:44:23 <opqdonut> yeah :P
08:44:34 <cremetorte> i want to declare a new datatype containing a tupel from (Integer,Integer)  how can i define.  ghc complains about  data Rat=(Integer,Integer)
08:44:56 <chessguy> data Rat = Rat (Integer, Integer)
08:45:04 <quicksilver> data Rat = Rat Integer Integer
08:45:08 <opqdonut> cremetorte: you want "type Rat=(Integer,Integer)" or "data Rat = Rat (Integer,Integer)"
08:45:10 <quicksilver> the extra () are probably not useful ;)
08:45:10 <chessguy> or newtype Rat = (Integer, Integer)
08:45:12 <opqdonut> type makes an alias
08:45:15 <roconnor> what is the point of defining sum with a foldl?
08:45:22 <opqdonut> chessguy: nah, newtype needs a constructor
08:45:27 <cremetorte> mh ok
08:45:34 <vixey> roconnor: doesn't it use O(1) space rather than O(n) like a foldr would?
08:45:34 <chessguy> err, yes, type, sorry
08:45:45 <vixey> > foldl (+) 0 [x,y,z]
08:45:55 <vixey> oh
08:45:56 <vixey> :/
08:46:00 <opqdonut> vixey: well the strict version would
08:46:13 <chessguy> Cale?
08:46:15 <roconnor> vixey: nope foldl' would
08:46:19 <lambdabot> uncurry ((. (1 +)) . flip . ((,) .) . (+))
08:46:19 <lambdabot> sort = sortBy compare
08:46:23 <vixey> oh well then I'm confused
08:46:23 <s_clv> ?seen anne
08:46:25 <lambdabot>  0 + x + y + z
08:46:25 <mm_freak_work> roconnor: in GHC, sum is implemented efficiently, like most special folds
08:46:29 <lambdabot> anne is in #haskell. I last heard anne speak 45m ago.
08:46:33 <lambdabot>  50000005000000
08:46:39 <roconnor> mm_freak_work: how so?
08:46:40 <chessguy> Cale, oh, sorry, never mind
08:46:50 <mm_freak_work> lambdabot gives intuitive sources, not the sources of real implementations
08:47:05 <roconnor> lambdabot: you need a timeout
08:47:15 <chessguy> @quote tiem
08:47:15 <lambdabot> No quotes match. You untyped fool!
08:47:20 <chessguy> @quote time
08:47:20 <lambdabot> _Stinger_ says: sometimes Haskell seems like an arms race between weird mathematical constructs and my brain
08:47:31 <roconnor> mm_freak_work: right, that's what I figured.
08:47:32 <mm_freak_work> it has a timeout, AFAIK
08:47:44 <mm_freak_work> > let f = f in f 3
08:47:52 <anne> s_clv: still reading...
08:47:59 <lambdabot>  thread killed
08:47:59 <mm_freak_work> hmm
08:48:02 <quicksilver> it should have a working timeout
08:48:03 <mm_freak_work> ah =)
08:48:04 <quicksilver> yes, there it is.
08:48:30 <s_clv> i had a  brainflash -- instead of greading a typeable, maybe you could just defer the recursive portion of the read until a concrete type is demanded (i.e. where the end user would normally cast).
08:48:46 <mm_freak_work> btw‚Ä¶  what's the complextity of the function f = f ?  O(1) or O(‚àû)?
08:49:29 <vixey> mm_freak_work: it doesn't have any input
08:49:29 <s_clv> eventually somebody will want a concrete type... so if you just held off on deserialization until then, you could circumvent dynamic entirely...
08:49:34 <Cale> mm_freak_work: the latter, though its the sort of infinite loop which will typically be caught as an exception
08:49:55 <anne> s_clv: Uh, my brain hurts...
08:50:15 <mm_freak_work> > let f = f in f 3 4 5
08:50:17 <Cale> But yeah, it has no input, so the big O notation doesn't make much sense
08:50:29 <anne> s_clv: Ah, yes, I got it now...
08:50:30 <lambdabot>  thread killed
08:50:37 <s_clv> might be much more open and elegant...
08:50:44 <Cale> heh, I suppose it's polymorphic enough to be treated as a function :)
08:50:47 <chessguy> > let f x = f x in f 3 4 5
08:50:49 <saml> how would you generate "foo.foo.foo.foo.foo..... ?
08:50:52 <cremetorte> data Rat=Rat (integer,integer)  :  i defined a fkt  addR::Rat->Rat   but he expects me to enter addR (Rat(2,3))  but i want to enter only addR (2,3)    :/ is this possible somehow
08:50:52 <mm_freak_work> well, it's of type f, which may be anything =)
08:50:55 <mm_freak_work> even a function
08:50:58 <chessguy> i don't think "no input" is really relevant :)
08:51:02 <lambdabot>  thread killed
08:51:23 <Cale> > let x = foo . x; foo = (1:) in x
08:51:23 <lambdabot>   add an instance declaration for (Show (f [t]))
08:51:35 <Cale> > let x = foo . x; foo = (1:) in x []
08:51:36 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:51:39 <mm_freak_work> > let f = g 1; g = \x -> f in f (g (f 3) 4)
08:51:55 <lambdabot>  thread killed
08:52:06 <Cale> > let x = fix (foo .); foo = (1:) in x []
08:52:07 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:52:12 <anne> s_clv: Whoa! Uhm... Well, it will still need to be wrapped in something until it's demanded...
08:52:19 <saml> > let x = foo . x; foo = ("foo." ++) in x []
08:52:20 <lambdabot>  "foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo...
08:52:28 * chessguy giggles
08:52:36 <tromp> > cycle "foo."
08:52:37 <lambdabot>  "foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo...
08:52:40 <mm_freak_work> Cale: O(1) and O(‚àû) don't need inputs, actually‚Ä¶  bottom has complexity O(‚àû), according to you
08:52:45 <s_clv> right... but it could just be wrapped in a newtyped string, even.
08:52:47 <mm_freak_work> which may be equivalent to O(1) anyway
08:52:49 <saml> tromp: hah
08:53:40 <s_clv> or even, although I don't know how well it will play with generics if you still need them otherwise, of type "forall a. Maybe a"
08:53:42 <mm_freak_work> and saying that f doesn't need inputs is imprecise‚Ä¶  it doesn't specify its input
08:54:10 <Cale> mm_freak_work: Well, the big O notation really requires a function, which is in the context of complexity theory, usually a function of the input size.
08:54:12 <anne> s_clv: Yes, I get your point then... But we need to read it when it will be used. We only circumvent deserializing Typeable right?
08:54:56 <anne> s_clv: I mean TypeRep*
08:55:06 <s_clv> right -- the idea is that the problem as i understand it with deserializing to dynamic is you can't conjure up a dictionary of instances from nowhere.
08:55:20 <Cale> mm_freak_work: Of course, you can treat f = f as a function of an arbitrary type, but it's not clear what "input size" means without specifying a monomorphic type for it.
08:55:31 <anne> Definitely...
08:55:44 <s_clv> so there's a number of ways you could approach simply delaying determining the concrete type you're deserializing, so that the TypeRep -> a problem doesn't occur.
08:56:06 <s_clv> and then you don't need an explicit dictionary...
08:56:28 <quicksilver> mm_freak_work: O(1) does need an input.
08:56:35 <twobitwork> > concat (repeat 1) (repeat 0)
08:56:36 <lambdabot>  Couldn't match expected type `[t1] -> t'
08:56:40 <quicksilver> mm_freak_work: O(1) is a declaration that "running time doesn't change as you vary n"
08:56:50 <quicksilver> mm_freak_work: that's not an interesting declaration if you don't know what 'n' is.
08:56:52 <anne> s_clv: Hmm... It's a really good idea. I'll check if it'll fit in to my project.
08:57:01 <mm_freak_work> true
08:57:21 <MyCatVerbs> > concat [repeat 1,repeat 0] -- twobitwork ?
08:57:22 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:57:28 <quicksilver> s_clv: in a way what you're describing is what Dynamic is, anyway.
08:57:29 <mm_freak_work> so O(1) for non-functions would actually be valid, but meaningless =)
08:57:43 <quicksilver> s_clv: it's a way of delaying interpretation of the thunk until you are somewhere guaranteed to be the right context.
08:57:52 <chessguy> @pl \n -> n >>= f >>= g >>= h
08:57:52 <lambdabot> (h =<<) . (g =<<) . (f =<<)
08:57:56 <twobitwork> > zip [repeat 1, repeat 0]
08:57:57 <lambdabot>  Add a type signature
08:57:57 <mm_freak_work> however‚Ä¶
08:58:02 <saml> swidgy: your version is nicer because it works on infinite list:  http://hpaste.org/7591#a4
08:58:20 <vixey> > let interleave (x:xs) (y:ys) = x:y:interleave xs ys in repeat 1 `interleave` repeat 0
08:58:22 <lambdabot>  [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0...
08:58:27 <vixey> fair :)
08:59:03 <vixey> > let interleave (x:xs) (y:ys) = x:y:interleave xs ys ; iotas n = repeat n `interleave` iotas (n+1) in iotas 0
08:59:13 <lambdabot>  Exception: Time limit exceeded
08:59:57 <MyCatVerbs> twobitwork: concat takes a list of lists, zip takes two lists as seperate parameters.
09:00:34 <anne> s_clv: From what I can understand it will only work if I don't need the type before I process the value. This might not be the case, as I also use a lookup table to emulate type classes...
09:00:47 <mm_freak_work> :t let f = f in (f 3, f 4 5, f)
09:00:49 <lambdabot> forall t t1 t2. (t, t1, t2)
09:00:52 <schme> So I was thinking here. If I want a type that can be either 1,2,3 or 4. How do I go by that?
09:01:02 <anne> s_clv: at run time I mean.
09:01:13 <vixey> data GFFour = One | Two | Three | Four
09:01:17 <paczesiowa> schme: data X = One | Two | Three | Four
09:01:33 <vixey> instance Field GFFour where .. :D
09:01:49 <roconnor> data Four = Either Bool Bool
09:02:00 <orbitz> can you have types that are subsets of types, for instance, only even ints?  or only ints between 1 and 10000?
09:02:01 <schme> Hmm.. I thought that made it One, Two, Three or Four.
09:02:04 <vixey> ooh
09:02:07 <vixey> roconnor++
09:02:20 <mm_freak_work> data Four = Four Bool Bool   -- would make more sense though
09:02:21 <twobitwork> MyCatVerbs: cool, thanks
09:02:23 <roconnor> er
09:02:26 <vixey> Either (Either () ()) (Either () ())
09:02:28 <vixey> too :)
09:02:28 <roconnor> type Four = Either Bool Bool
09:02:40 <schme> orbitz: That is what I want rite there. [1..4]
09:02:49 <roconnor> vixey: we get to resue haskell's existing machinery.
09:03:05 <roconnor> > maxBound :: Either Bool Bool
09:03:06 <lambdabot>        add an instance declaration for (Bounded (Either Bool Bool))
09:03:06 <lambdabot>     In th...
09:03:07 <vixey> scheme: Integer
09:03:13 <roconnor> aww!
09:03:14 <mm_freak_work> twobitwork: again, you really should study monads‚Ä¶  it will make many things clear =)
09:03:19 <roconnor> > maxBound :: Bool
09:03:20 <lambdabot>  True
09:03:37 <paczesiowa> orbitz: you can, but you have to make it abstract and define only safe functions (add for evens but not for odds)
09:03:39 <schme> vixey: I'm sorry. That GFFour = One | Two .. does not seem to be working for me.
09:03:43 <roconnor> We totally need an instance of Bounded for (Either a b) when a and b are bounded!
09:03:49 <twobitwork> mm_freak_work: I am, thanks
09:03:57 <vixey> schme: huh? some kind of error or what?
09:04:05 <vixey> roconnor: I agree :D
09:04:08 <schme> vixey: 1 2 3 4 are still not of that type.
09:04:15 <vixey> schme: Integer
09:04:18 <vixey> :t 1 :: Integer
09:04:21 <lambdabot> Integer
09:04:22 <saml> > succ False
09:04:23 <schme> Yes.
09:04:23 <lambdabot>  True
09:04:30 <schme> But integer can be other things than [1..4]
09:04:35 <saml> > [False..]
09:04:36 <lambdabot>  Parse error at "False..." (column 2)
09:04:36 <vixey> correct
09:04:38 <paczesiowa> "> succ False" "Yes"
09:04:45 <MyCatVerbs> twobitwork: no worries. If you're ever unsure, just :t to look up the type rather than scratching your head and wondering.
09:04:49 <schme> That's why I asked how I define a type that is 1,2,3 or 4
09:04:54 <mm_freak_work> schme: newtype Int2 = Int2 Word8
09:05:03 <twobitwork> MyCatVerbs: ok I'll do that
09:05:03 <MyCatVerbs> twobitwork: the intuition is that zip always glues exactly two lists together, concat concatenates arbitrarily many lists.
09:05:11 <mm_freak_work> and after that instantiate it properly, so it does calculations modulo 4
09:05:17 <vixey> scheme: instance Num ...
09:05:17 <schme> hmmm.. mm_freak_work: I'll take a look at that.
09:05:21 <vixey> 1 = One
09:05:26 <mm_freak_work> MyCatVerbs: zip and concat are different
09:05:36 <schme> hmm
09:05:36 <MyCatVerbs> twobitwork: (note, I'm not saying "fuck off, check the manual, never ask again", just, eh, "looking the type up will take you less time than asking". ;)
09:05:41 <mm_freak_work> > zip [1,2,3] [4,5,6]
09:05:42 <twobitwork> mm_freak_work: we're aware of that, thanks :)
09:05:42 <lambdabot>  [(1,4),(2,5),(3,6)]
09:05:49 <roconnor> schme: instance Num GFFour where fromInteger 1 = One; fromInteger 2 = Two ...
09:05:49 <paczesiowa> schme: you can't. but you can have a function that  maybe will turn 1 to One: toMyFour :: Int -> Maybe MyFour
09:06:10 <twobitwork> MyCatVerbs: of course :) I don't take offense in IRC, so no worries
09:06:19 <schme> Ugh.
09:06:34 <schme> So what is the easy way to do this from 1 up to 31 ?
09:06:36 <mm_freak_work> twobitwork: ok, sorry‚Ä¶  must have missed that
09:06:40 <vixey> schme: Integer
09:06:46 <paczesiowa> schme: what are you trying to accomplish?
09:06:50 <vixey> 31 :: Integer
09:06:51 <MyCatVerbs> twobitwork: hey, this channel has a reputation for being helpful. I don't want to ruin it by saying something that could be misconstrued. :)
09:06:51 <schme> paczesiowa: dates
09:07:15 <vixey> schme: Do you want modular arithmetic on this type or what?
09:07:19 <twobitwork> MyCatVerbs: hehe... people have always been friendly in here, and I wouldn't assume otherwise :)
09:07:27 <schme> vixey: I just want to specify dates really.
09:07:30 <vixey> schme: whis is the [1..31] type distinct from Integer?
09:07:39 <vixey> schme: e.g. why not just use Integer and be done with it
09:07:52 <mm_freak_work> i wonder whether it's possible to extend the parser by code‚Ä¶  i.e. make it recognize things like "34" as of an own type
09:07:56 <paczesiowa> multiplying dates
09:08:09 <twobitwork> I wish you could define times in ghci
09:08:12 <schme> vixey: that just seems wrong.. hmm... then I could be handing stuff day 6532 of the month and what not :S
09:08:13 <twobitwork> er, types
09:08:17 <twobitwork> (brain-o)
09:08:23 <vixey> schme: so put a runtime check in
09:08:39 <schme> ugh.
09:08:53 <vixey> schme: why "ugh."?
09:09:15 <schme> 'cause it's all so unpretty and complicated :)
09:09:27 <vixey> schme: how would you solve this problem in Lisp?
09:09:48 <paczesiowa> you can wrap ugly runtime checks in nice static checks (wrap every operation on dates in Maybe)
09:10:01 <schme> vixey: I'd probably create a date class and define methods on it.
09:10:21 <vixey> scheme: So define a Date type and then functions that operate on it
09:10:29 <paczesiowa> schme: what constructors would you use?
09:10:40 <vixey> scheme: anywhere you'd put (if (> x 6532) ...) put if x > 6532 ..
09:11:07 <schme> paczesiowa: whatcha mean?
09:11:30 <paczesiowa> how would you construct objects of type Date?
09:11:36 <schme> I was trying to define a Date type. That's the whole thing. Just thought I could do it without adding the checks.
09:11:47 <sclv_> anne: not sure what you meant above?
09:11:53 <MyCatVerbs> sclv_: sometimes you need to anyway, though.
09:12:03 <MyCatVerbs> Er, schme, sorry, not sclv_.
09:12:37 <schme> MyCatVerbs: ?
09:12:59 <schme> So the best way is integers and runtime checks?
09:13:10 <schme> paczesiowa: I'd use make-instance. Why? :)
09:13:19 <sclv_> you want to dispatch based on the typerep before you actually demand the value?
09:13:24 <MyCatVerbs> schme: if you can't encode September the ~6000th 1993, how do you expect to display dates for Usenet readers? :)
09:13:35 <anne> sclv_: Yes
09:13:35 <vixey> schme: again, yes, just use Integer
09:13:42 <sclv_> data GTypeable = GTyp TypeRep String
09:14:11 <mm_freak_work> i've just found that you just need to write a fromInteger function for that to work‚Ä¶  that's pretty useful
09:14:12 <twobitwork> http://hpaste.org/7592
09:14:20 <sclv_> cast' (Data a, Typeable a) :: GTypeable -> a
09:14:20 <twobitwork> can someone tell me if this is doing the right thing?
09:14:25 <paczesiowa> schme: sorry, never used lisp (clos?)
09:14:27 <twobitwork> seems like it isn't...
09:14:50 <anne> sclv_: But I wouldn't know the typerep, because I have no means of deserializing it, right?
09:16:50 <Riastradh> This isn't related to Haskell, but I believe the gravity of the situation warrants the interruption.  If you have generated any keys with OpenSSL (e.g., x.509 keys, ssh keys, &c.) on a Debian or Ubuntu system in the past eighteen months, it is highly likely that those keys have close to zero entropy, and you may wish to upgrade OpenSSL & regenerate the keys.  See <http://www.debian.org/security/2008/dsa-1571>.
09:17:25 <sclv_> hmm... well, you can always just use the string representation of the typerep, and write it out when serializing...
09:17:27 <twobitwork> Riastradh: thanks for the notice, that's good to know
09:17:36 <sclv_> then read it back in when deserializing, just for dispatch...
09:17:51 <schme2> Great. Did I miss anything?
09:17:53 <anne> sclv_: :-) Yes, true.
09:18:13 <sclv_> it sounds like a really interesting project...
09:18:16 <anne> sclv_: But it might be the last resort...
09:18:47 <anne> sclv_: It's a genetic programming library. It's nearing completion, but I just want to make in more extensible before releasing.
09:20:06 <sclv_> why do you need to emulate typeclasses anyway?
09:20:14 <schme2> Where do I look to find stuff on how to do file I/O ?
09:20:43 <sclv_> is this for the serialized function issue?
09:22:59 <anne> sclv_: No, no... Well, I don't really need to emulate them, but it would be easier for the users of the library. Say, for instance, you want the generated program to be able to add numbers. You add and addition function to the functions list (functions the generated programs can use). You won't need to define different additions for Real, Integer, etc.
09:23:00 <schme2> Also a more general question. Is there some recommended "maximum line length" for haskell source. Like C people tend to like 80 columns or somesuch ?
09:23:05 <lispy> schme2: what do you want?  A tutorial or a reference?
09:23:23 <schme2> lispy: both really :)
09:23:46 <lispy> schme2: recommended line length is probably the same.  But, don't use tabs, they confuse the layout parsing.
09:24:01 <anne> sclv_: So, the generator will match 'add' both if the requested type is Int -> Int -> Int and Double -> Double -> Double
09:24:05 <and][ng> hello
09:24:48 <schme2> lispy: ty
09:24:49 <sclv_> ah... gotcha.
09:25:35 <lispy> schme2: http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/IO
09:26:32 <sclv_> so you need to have a dictionary mapping from your deserialized data to the appropriate function...
09:26:47 <byorgey> hi and][ng
09:27:04 <schme2> lispy: supasweet!
09:27:22 <sclv_> this is getting overcomplicated again, but you could maybe delay things still further, so you maintain the polymorphism until the last minute, which seems to be what your really want.
09:27:27 <anne> sclv_: yes. Currently it's being done using type signatures, but there's no dynamic type, an it's easy.
09:28:49 <sclv_> i.e. add is of type (Num a) :: a -> a -> a, so therefore if you call it as liftM2 add (cast' a) (cast' b) you can still get a value of (Num a) :: Maybe a, no?
09:30:14 <sclv_> anyway, yeah, adding dynamics makes things complicated fast...
09:30:17 <anne> sclv_: Aha, I have no idea. :-)
09:30:52 <anne> sclv_: The last thing you said is way above me, but I get your point. I'll have to try it at home first...
09:31:17 <sclv_> cool... look forward to seeing your lib. :-)
09:31:24 <anne> sclv_: Thanks!
09:33:05 <Baughn> ..I don't care if dtrace is superior to strace, linux is so much cleaner than OS X that the simple reduction in number of system calls is a joy to behold
09:33:32 <Baughn> (And /why/ would this haskell program insist on re-reading the nonexistent preferences file once per frame?)
09:34:43 <ibid> i hope everyone here is aware of the critical security issue in debian and debian-derivatives (like ubuntu)
09:35:04 <Baughn> Does it affect things like SSH keys?
09:35:10 <ibid> yes
09:35:10 <opqdonut> yes
09:35:13 <opqdonut> them exactly
09:35:26 <opqdonut> http://lists.debian.org/debian-security-announce/2008/msg00152.html
09:35:27 <Baughn> Oh dear, then. I'll have to fix it.
09:35:27 <lambdabot> Title: [SECURITY] [DSA 1571-1] New openssl packages fix predictable random number gener ..., http://tinyurl.com/5epevf
09:35:58 <ibid> any ssh keys generated on debian based systems uin the last year or two are vulnerable and should be regenerated *after* upgrading
09:36:27 <opqdonut> yep
09:36:38 <opqdonut> luckily my ssh keypairs are pre-bug
09:36:44 <opqdonut> only had to regenerate hostkeys
09:44:13 <saml> "Foo.Bar.foo" ==> "Foo.Bar"
09:46:07 <saml> > let n = "Foo.Bar.foo" in splitAt (last (findIndices (== '.') n)) n
09:46:09 <lambdabot>  ("Foo.Bar",".foo")
09:50:22 <schme2> Ok. so if I understand this just about right all functions that deal with my new fancy date thingie now need to do a runtime check to see that day is between 1 and 31 ? Is there not some easier way..?
09:53:33 <dcoutts_> twobitwork: how did it fail?
09:54:09 <EvilTerran> you could make it an abstract type with a validating "constructor"
10:06:56 <twobitwork> dcoutts_: I didn't have the sqlite headers installed :P
10:07:21 <dcoutts_> twobitwork: oh, so cabal-install itself did not fail
10:09:39 <Arnar> hey guys..
10:09:57 <Arnar> can I ask someone a socket-related quiestion regarding an example from realworld haskell?
10:11:25 <MyCatVerbs> Arnar: yes, but you're not allowed to ask whether you're allowed to ask questions. ;)
10:11:49 <Arnar> MyCatVerbs: yeah..I know - this was sort of an intro :)
10:11:51 <Arnar> in any case
10:12:04 <Arnar> in the example syslogtcpserver.hs in chapter 25
10:12:13 <MyCatVerbs> Arnar: the worst that could happen is no one knowing the answer offhand... in which case, go ask on the haskell-cafe@ mailing list, where your chances will me better.
10:12:37 <Arnar> ok, here goes: there is a function to process the lines of a tcp stream
10:13:02 <Arnar> it gets a handle to the socket via socketToHandle.. then uses hSetBuffering to turn on LineBuffering
10:13:22 <MyCatVerbs> Mmmmhmmm.
10:13:22 <Arnar> then it gets the contents with hGetContents and mapM_-s over (lines contents)
10:13:34 <Arnar> I just wanted to be sure..
10:13:46 <Arnar> will the laziness do the right thing here..
10:14:02 <Arnar> i.e. lines will be processed (by the argument to mapM_) as soon as each line arrives?
10:14:29 <Arnar> and block, *inside* the mapM_ while it waits for more?
10:14:31 <MyCatVerbs> Yes. mapM_ over (lines contents) will fire the actions off as lines become available.
10:14:41 <Arnar> ok.. excellent
10:15:11 <Arnar> as I've told my parents before, and been telling my wife for 10 years.. laziness is a beautiful thing
10:15:14 <MyCatVerbs> And hGetContents reads lazily, so it makes characters available as soon as the RTS gets ahold of them.
10:15:29 <Arnar> MyCatVerbs: ok.. good to know
10:15:35 <Arnar> so this works with other buffering modes as well
10:16:10 <brrrrrrrm> what is the quivalent ot .ghci on Windows?
10:16:32 <MyCatVerbs> Yes. But if you use NoBuffering it can be frighteningly inefficient, and if you use BlockBuffering then it will block until an entire block has been taken in, rather than letting you process each line as it comes in.
10:17:08 <Arnar> MyCatVerbs: ok.. I see. is it hard to define other buffering schemes? for example to delimit on something other than newlines?
10:17:55 <MyCatVerbs> Arnar: for input, I don't actually know. For output, you'd use hFlush to dump output exactly when you want to (and then use block buffering).
10:18:06 <Arnar> ok
10:18:12 <Arnar> thanks MyCatVerbs++
10:18:18 <brrrrrrrm> what is the quivalent ot .ghci on Windows?
10:18:34 <MyCatVerbs> No worries. LineBuffering is what people usually expect for interactive tools, anyway.
10:18:40 <brrrrrrrm> what is the equivalent ot .ghci on Windows?
10:18:47 <Arnar> yes.. serves my purpose
10:19:02 <Arnar> brrrrrrrm: I'm sure someone will know if you ask again
10:19:08 <dmwit> brrrrrrrm: We heard you the first time.  If somebody knows, they will answer.
10:19:20 <MyCatVerbs> Like i've written things that work a little xargs-a-like by doing hGetContents stdin >>= \contents -> mapM_ process (lines contents) -- it works.
10:19:50 <MyCatVerbs> brrrrrrrm: don't know, sorry, I avoid Windows like the plague. :/
10:20:18 <MyCatVerbs> I also avoid windows, too, because they let the daystar's rays in. *hisses at the light*
10:20:35 <brrrrrrrm> I'm doomed  :s
10:22:01 <Deewiant> brrrrrrrm: %USERPROFILE%/.ghci
10:22:12 <MyCatVerbs> Isn't GHC on Windows built using cygwin, anyway?
10:22:20 <EvilTerran> MyCatVerbs, don't think so
10:22:20 <Deewiant> (most likely C:\Documents and Settings\your username\.ghci)
10:22:20 <MyCatVerbs> (Or am I completely wrong?0
10:22:26 <proq> MyCatVerbs: nope
10:22:27 <MyCatVerbs> EvilTerran: oh, okay.
10:22:41 <EvilTerran> brrrrrrrm, note, you can't name files starting with a . from the graphical interface - you'll have to do a rename from the command line or something
10:22:57 <EvilTerran> because windows is stoooopid
10:26:01 <brrrrrrrm> I see. 10Q!
10:27:16 <proq> EvilTerran: you use a gui to rename files on linux?
10:27:51 <mauke> xmv
10:28:08 <vixey> isn't the OS a GUI?
10:28:13 <EvilTerran> proq, pardon? er, i'm talking about windows ere.
10:28:19 <cjb> there are good vi/emacs modes that do that, too.. they show you the list of files, and you can delete files by deleting lines and rename files by changing their name in the list.
10:28:59 <proq> EvilTerran: no, you were comparing your OS to windows
10:29:14 <EvilTerran> proq, no i wasn't. i have no idea what you're talking about.
10:29:41 <proq> EvilTerran: ah
10:31:32 <proq> I never thought a point and grunt interface was smart to begin with
10:36:47 <schme2> EvilTerran: That abstract type with a validating constructor idea sounds interesting.
10:36:52 <schme2> EvilTerran: Where would I look into it?
10:41:39 <EvilTerran> well, it'd just be a case of putting the type in a module, and not exporting the constructor, but exporting a function with a plausible name (say, date, for the type Date) that validates its parameters and then uses the constructor
10:41:54 <EvilTerran> so the only way to get at that constructor outside that module is via the wrapper function
10:42:20 <EvilTerran> and then you'd need to also export some function(s) for getting the values out of the constructor again
10:42:55 <EvilTerran> if you define the constructor with record notation, just exporting the field functions would do fine
10:45:23 <schme2> hmmm
10:46:20 <schme2> That makes sense though.
10:48:10 <vixey> schme: validating constructor = runtime check
10:48:26 <schme2> It is too bad I can not have it called Date there though.
10:48:44 <schme2> It translates quite well how I would do it in my natural language. So that's good.
10:48:47 <schme2> :)
10:50:40 <EvilTerran> it is indeed a runtime check, but it means you only have to write the runtime check once
10:50:55 <schme2> Ya. That is very good.
10:52:01 <EvilTerran> and you still know at compile-time that it's impossible to make invalid values of that type outside the module it's defined in
10:53:09 <schme2> anyway. where are all the french speaking belgians hanging out?
10:54:33 <EvilTerran> there seems to be a conspicuous absence of #haskell.fr
10:55:07 <schme2> haha
10:55:48 <EvilTerran> heck, there's #haskell.cz, you'd think there's more french haskellers than czech
10:56:16 <ptolomy2> Where are strict pairs defined? (I find them intriguing)
10:57:48 <EvilTerran> ptolomy2, do you mean (#,#), or just data StrictPair a b = StrictPair !a !b ?
10:58:27 <EvilTerran> i think unboxed tuples (ie (#...#)) are described in the GHC manual.
10:58:35 <ptolomy2> I'm talking of the (x :*: y) stuff that dons mentioned in his post comparing fusable arrays and lists for "mean()".
10:58:50 <EvilTerran> ah. i think you have to do that yourself.
10:59:13 <EvilTerran> it'd just be data (:*:) a b = (:*:) !a !b
10:59:24 <ptolomy2> Oh.
10:59:37 <ptolomy2> Fair enough.
10:59:39 <ptolomy2> Thanks!
11:00:04 * EvilTerran waits for dons to jump in and tell him he's wrong
11:02:32 <s_clv> unboxed tuples are more efficient, but more limited. also, as i recall, ghc at sufficient optimization smartness will unbox tuples for you...
11:02:40 * MyCatVerbs pokes the FFI.
11:02:58 <dcoutts_> the mean example is a bit silly
11:03:02 <EvilTerran> * the FFI pokes back
11:03:10 <bos> dcoutts_: silly?
11:03:15 <dcoutts_> there are such simple functional solutions, you don't need any clever stuff
11:03:18 <MyCatVerbs> To call functions using dlopen(), I need to import them "dynamic"?
11:03:43 <s_clv> i remember some huge thread a while back with somebody writing an efficient cute pointfree mean using &&& and lots of ensuing discussion over resultant fusion and lack thereof...
11:03:51 <s_clv> wanted to link it on proggit, but couldn't find it...
11:03:53 <dcoutts_> bos: even if you just write out the primitive recursive version that any beginner would use
11:04:03 <bos> i think the mean example is pretty cool, myself.  it's a *very* common kind of stumbling block.
11:04:49 <dcoutts_> what's more, the simple primitive recursive version is optimal from a performance pov
11:05:02 <dcoutts_> the core output is perfect
11:05:12 <bos> if you don't understand the evaluation model well, it's easy to be tripped up when we tell you that on the one hand, you can compose things like (take k . sort) and do less work, but on the other hand, (sum xs / length xs) has awful behaviour.
11:06:08 <s_clv> meanFromTo x y = x + y / 2. look! O(1) :-P
11:06:40 * edward1 waves hello.
11:07:37 <Arnar> bos: hey there.. do you have any idea when to expect rwh in print? I have some stuff to order on amazon and I can't decide if I should order it now or wait until I can add rwh to the shipment
11:07:49 <dcoutts_> http://hpaste.org/7593
11:07:53 * ptolomy2 is ashamed to have tried to optimize many times by semi-randomly sprinkling strictness annotations and INLINE pragmas about
11:08:07 <bos> Arnar: a few months.
11:08:24 <Arnar> bos: ok, thx.. guess I'll order the other stuff now then :)
11:08:48 <Apocalisp> Arnar: Passau ˛ig · tollinum
11:08:49 <bos> dcoutts_: sure.
11:09:11 <Arnar> Apocalisp: hehe :) √©g borga bara..
11:09:30 <Apocalisp> helvÌtis harsjtÛrn
11:09:31 <bos> is that icelandic?
11:09:34 <MyCatVerbs> ptolomy2: before or after looking at Core?
11:09:36 <Arnar> bos: yes :)
11:09:43 <Arnar> bos: we're bitching about the customs
11:09:53 <bos> ha. popular pastime in ireland, too.
11:10:00 <Arnar> bos: books more than double in cost with the shipping, customs and vat
11:10:19 <bos> Arnar: ouch!
11:10:28 <ptolomy2> MyCatVerbs: Both, really.
11:10:43 <ptolomy2> A lot of the time I don't find the Core that useful.
11:11:02 <Valodim> unknown field 'build-type', does this mean my cabal installation is too old?
11:11:22 <dcoutts_> Valodim: yes, but it's not an error, just a warning
11:11:38 <Valodim> says "exception" and doesn't continue
11:11:46 <Valodim> any force option?
11:12:25 <dcoutts_> Valodim: what is the full error message?
11:12:33 <Valodim> *** Exception: Line 19: Unknown field 'build-type'
11:13:05 <Valodim> basically I'm trying to get a lambdabot on an ubuntu server
11:13:32 <Valodim> apt-get installed ghc-6.4.1, is that version even able to build a current \bot?
11:13:39 <dcoutts_> Valodim: so what command are you running exactly that gives that message?
11:14:14 <Valodim> I darcs got the \bot repository, the command is
11:14:14 <Valodim> runhaskell Setup.hs configure
11:14:56 <dcoutts_> hmm, that's weird, I don't recognise that error output style, cabal error messages usually do not look like that
11:15:09 <Duddle> hello everybody! a kinda non-haskell related question, but I guess there are a lot of smart people here, so: I've recently had the lambda-calculus in my lectures, but I have yet to see its meaning... can anyone briefly explain the _why_ of something like the lambda-calculus?
11:15:25 <Arnar> bos: heh.. RWHs turns out fairly cheap, only ~70 USD for me :)
11:15:32 <geezusfreeek> Duddle: like, when you would use it in programming?
11:15:33 <ibid> Duddle: not briefly, no :)
11:15:41 <bos> Arnar: ok, that's not too huge a premium
11:15:43 <p00ya> is there a more compact way to express "do a <- f; b <- f; ... ; return a + b + ..."?
11:16:15 <geezusfreeek> Duddle: it's pretty foundational to... pretty much _all_ functional programming
11:16:21 <Arnar> bos: no.. its ok - I'd rather pay the $45 if I lived in the US though :)
11:16:25 <ibid> Duddle: but i'll try: it is one of the simplest of models of computation, and of programming languages, and it has a prominent place in pl theory
11:16:27 <dcoutts_> Valodim: you're using ghc-6.4.1 you say? then probably it is a very old cabal, what does ghc-pkg list Cabal say?
11:16:40 <Valodim> 1.0 oO
11:16:41 <s_clv> p00ya -- are you familiar with the liftM family of functions?
11:16:43 <Valodim> uh, yea
11:16:53 <s_clv> ?ty liftM2
11:16:55 <p00ya> s_clv: no, but i'm happy to look them up
11:16:56 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:16:57 <s_clv> ?ty liftM3
11:16:59 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
11:17:23 <s_clv> after that you may want to read the section in the wiki on applicatives.
11:17:54 <dcoutts_> Valodim: yeah, that's a few years too old. I guess in that version unknown fields were an error, since at least 1.1.6 they've been a warning.
11:18:08 <dcoutts_> Valodim: I suggest you want a much more recent version of ghc
11:18:09 <dolio> edwardk: Commented on your blag.
11:18:11 <p00ya> s_clv: is there a short answer for my example? (it's been a while since i've used haskell)
11:18:17 <schme2> Right. so modules here. the wikibook says I name the file the same as the module. So I save my stuff as Nutrition.Data.Type.Module and now I can't figure out how to import it.
11:18:31 <schme2> It seems me ghc is not looking for modules in $PWD
11:18:41 <Valodim> the universe apt-get server has a years old version of ghc?
11:18:42 <Valodim> aw
11:18:52 <dolio> edwardk: Probably not helpful except for the information on total type families (which probably aren't available yet).
11:18:55 <schme2> So how do I tell it where to look?
11:19:01 <dcoutts_> Valodim: you want at least 6.6.1
11:19:23 <dcoutts_> schme2: it expects Nutrition.Data.Type.Module to be at Nutrition/Data/Type/Module.hs
11:19:30 <Duddle> ibid: so it is a model, generalizing computation? and if I understand l-calculus I could expand that to any functional programming language etc.?
11:19:46 <s_clv> p00ya: ok, so if you want  do {x <- f1; y <- f2; return (x+y)} that turns into liftM2 (+) f1 f2
11:19:52 <schme2> dcoutts_: My god.
11:20:11 <s_clv> it's full... of paths.
11:20:13 <p00ya> does that generalise to liftMn ?
11:20:20 <schme2> dcoutts_: Someone needs to put that in the wikibook :)
11:20:21 <ibid> Duddle: lambda calculus is at the same level as turing machines, albeit more useful for fp purposes
11:20:29 <dcoutts_> schme2: perhaps you want fewer '.'s :-)
11:20:37 <s_clv> yeah, although I forget how far the libraries actually define them -- 6 or something...
11:20:38 <ibid> Duddle: but yeah, any functional programming language will be at the core a lambda calculus
11:20:47 <dolio> @type liftM7
11:20:48 <lambdabot> Not in scope: `liftM7'
11:21:09 <Duddle> ok, that's basically what I wanted to hear :) thanks, ibid and geezusfreeek
11:21:09 <s_clv> you can define more if you need them, although at that point you're better off using applicatives...
11:21:32 <p00ya> ok.. well in this case i can get away with small numbers
11:21:38 <dolio> There should be a 7.
11:21:40 <p00ya> thanks
11:21:49 <s_clv> ?type liftM6
11:21:50 <lambdabot> Not in scope: `liftM6'
11:21:55 <s_clv> ?type liftM4
11:21:57 <lambdabot> forall a1 a2 a3 a4 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
11:21:59 <dcoutts_> schme2: so where did it say that exactly? I can't find it
11:22:03 <dolio> @type zip7
11:22:05 <lambdabot> forall a b c d e f g. [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]
11:22:05 <s_clv> ?type liftM5
11:22:07 <lambdabot> forall a1 a2 a3 a4 a5 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
11:22:08 <schme2> dcoutts_: It's not working anyway though. I renamed it to Module.DateType and saved it off as Module/DateType
11:22:14 <schme2> dcoutts_: Say what exactly?
11:22:23 <s_clv> hmm... 5 instead of 6 -- i was pretty close.
11:22:30 <dcoutts_> schme2: the file extension for haskell scripts is .hs
11:22:41 <schme2> dcoutts_: and I fire up ghci and do import Module.DateType
11:22:46 <dcoutts_> schme2: where in the wikibook does is it misleading?
11:23:01 <schme2> dcoutts_: I should name it Module.DateType.hs ??
11:23:15 <dcoutts_> schme2: Module/DateType.hs
11:23:44 <schme2> dcoutts_: Well right there is one misleading thing in the wikibook. "The name of the file should be that of the module" it says.
11:23:58 <dcoutts_> schme2: link please, I can't find where it says that
11:24:14 <dcoutts_> which chapter?
11:24:16 <schme2> dcoutts_: no mentioning of stuff translating to paths, and that it should have .hs tagged to the end of the name there.   http://en.wikibooks.org/wiki/Haskell/Intermediate_Haskell
11:24:50 <schme2> BUt thanks a bunch there. I'll try to rename it to DateType.hs then :)
11:25:19 <dcoutts_> schme2: mm, yes that is quite misleading
11:25:58 <schme2> still not working as I want here though. I fire up ghci and do import Module.DateType and it says main:Module.DateType is not loaded.
11:27:21 <s_clv> try running it from the command line: ghci Module/DateType.hs
11:27:34 <schme2> oki..
11:27:56 <Valodim> heh, sweet. the older ghc version can build the new one... fun. =)
11:28:25 <schme2> s_clv: That seemed very well to have loaded the module and changed the prompt to a fancy *Module.DataType>
11:28:44 <schme2> hmm
11:29:08 <schme2> aha
11:29:09 <s_clv> good! the general syntax to import a module in ghci by the way is :mod +Data.Map or whatever. the + keeps the other imports around too.
11:29:23 <s_clv> if you want to load a file as your main one, you use :load
11:29:26 <schme2> I tried putting import bla bla in foo.hs and load that. and that just worked. great.
11:29:36 <schme2> Well I didn't want to load it there :)
11:30:13 <schme2> grrr.
11:30:43 <schme2> well this stuff is just complicated :)
11:32:53 <schme2> So Ihave this module that exports me construct that I named date. Which takes a Date and returns a Date. It seems to me I also have to export Date though?
11:33:41 <schme2> hmm
11:38:14 <newsham> ?seen cale
11:38:14 <lambdabot> cale is in #ghc, #haskell-overflow and #haskell. I last heard cale speak 2h 42m 54s ago.
11:38:50 <dcoutts_> schme2: how about this: http://en.wikibooks.org/wiki/Haskell/Modules#Modules
11:39:14 <s_clv> you need to either export everything (i.e. by default) or specify everything in particular you want to export. so yes, that includes types, constructors, functions, etc.
11:39:29 <s_clv> instances are about the only thing that always get exported.
11:40:22 <schme2> Hrm.. I'm getting confused by what I'm doing here now :)
11:40:55 <schme2> dcoutts_: That looks a lot better! Nice!
11:41:12 <ibid> schme2: it's obvious. you're getting confused here. hth hand :)
11:41:23 <schme2> I'm doing this module here to create eeh.. an abstract type constructor or something.
11:41:37 <schme2> Hmm.
11:41:41 <schme2> Well maybe that works out.
11:43:54 <schme2> oh wait I get it. I just make date take the same args as Date does and return a Date... and maybe I can tell functions to take a date.
11:43:57 <schme2> yeah.
11:44:02 <schme2> it makes sense in my head atleast.
11:44:10 <proq> @type zip3
11:44:12 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
11:44:45 <ibid> i'm sure this one's old news already ... http://www.xkcd.com/221/
11:44:46 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
11:45:00 <dolio> @remember slava Show me some code, bitches.
11:45:01 <lambdabot> Done.
11:45:01 <schme2> You guys just wait 'til I start working on my game here and you'll be getting tons o' fucked up questions from me.
11:45:56 <schme2> It still makes no sense. I must have misunderstood what I'm doing.
11:46:03 <schme2> :)
11:51:31 <schme2> Hmmm.. But really you gals and guys. I have this here data Date = Date { year :: Integer, month :: Month, day :: Integer} and What the heck is an abstract type constructor and how do I make one and where in the wiki is it? :)
11:52:04 <roconnor> @wiki Smart_constructors
11:52:04 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructors
11:52:09 <schme2> hmmm
11:52:16 <schme2> thank roconnor !
11:53:23 <roconnor> hmm
11:53:30 <schme2> man that's exactly what I was doing anyway.
11:53:33 <roconnor> the article doesn't talk about handling module exports
11:53:39 <roconnor> that sucks
11:53:45 <schme2> But it makes no sense to me.
11:53:47 <roconnor> I don't have time to write something at the moment.
11:53:54 <schme2> :(
11:54:13 <roconnor> You want to not export the type constructors, and export your smart constructors instead
11:54:36 <schme2> I mean how do I make my type constructor work like  Date {year=4332, month=May, day=32343}  ?
11:54:38 <roconnor> This will prevent other people form violating your invarients
11:54:43 <schme2> I can only make it work like   date 12 May 122
11:55:13 <roconnor> schme2: The idea is that you don't export the Date function (only the Date type)
11:55:50 <roconnor> and make your own "date" function that throws a runtime exception if the inputs are out of range.
11:56:18 <edwardk> dolio: the posts there are from you?
11:56:32 <schme2> You have totally lost me there, roconnor :)  I just have data Date = Date { ....}    and I export Date, and Ihave a function data which at the moment is Integer -> Month -> Integer -> Date   and I export that too.
11:56:35 <dolio> One is.
11:56:57 <edwardk> ah missed it
11:57:22 <roconnor> schme2: yep
11:58:11 <schme2> roconnor: But I want to do date {year = 123, month = December, day = 123} though.
11:58:14 <edwardk> the issue with the Zero :+: g = g, f :+: Zero = f; f :+: g = Lift Either f g definition is that currently your overlapping instances MUST be confluent
11:58:24 <roconnor> schme2: and you have that function veify the range of it's inputs before constructing a Date.
11:58:35 <roconnor> schme2: oh, I don't think you will be able to use that notation.
11:58:36 <schme2> roconnor: yes. it does the verifying.
11:58:44 <schme2> roconnor: uh.
11:58:50 <dolio> Right. You need closed, total type families.
11:58:56 <roconnor> schme2: well, you could sort of hack something together.
11:58:57 <dolio> Which are coming, according to SPJ.
11:58:58 <gwern> I'm kind of wondering. does anyone know of any tool to parse changelogs like those generated by darcs such that you can 'get all changes since last release'?
11:58:59 <lambdabot> gwern: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:59:04 <edwardk> dolio: so i'm trying to figure out how to 'cut out holes' for the other functors in the quantification or to remove that quantification
11:59:05 <edwardk> ah nice
11:59:15 <roconnor> you could have two types: Date and UncheckedDate.
11:59:22 <ehird> @type \d m -> maybe d fromJust m
11:59:24 <lambdabot> forall a. a -> Maybe (Maybe a) -> a
11:59:28 <ehird> .. Whut?
11:59:33 <ehird> o
11:59:33 <ehird> @type \d m -> maybe d id m
11:59:35 <lambdabot> forall a. a -> Maybe a -> a
11:59:39 <schme2> roconnor: See the thing is that I can't just have it take int -> month -> int. 'cause some people do bizare stuff like day month year instead of year month day :)
11:59:49 <ehird> @hoogle a -> Maybe a -> a
11:59:50 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
11:59:50 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
11:59:50 <lambdabot> Data.Maybe.maybe :: b -> (a -> b) -> Maybe a -> b
11:59:52 <edwardk> nice, reading the ghc doc on it
11:59:57 <ehird> oh.
11:59:58 <ehird> fromMaybe.
12:00:01 <roconnor> schme2: I understand your concern.
12:00:02 <ehird> That looks nice
12:00:15 <gwern> at least lambdabot will talk to me :(
12:00:17 <gwern> @messages
12:00:17 <lambdabot> boegel said 11h 31m 31s ago: how is BSD3 different from GPL? I'm more familair with that... but I'm by no means an expert :)
12:00:17 <lambdabot> lispy said 1h 8m 22s ago: could you resubmit your use mmap for whatsnew patch making it a command line switch? I think it's important that people who have large files in their pending have the
12:00:17 <lambdabot> ability to keep using darcs without having to manually kill their pending.
12:00:40 <roconnor> schme2: there are some things you could do
12:00:43 <schme2> roconnor: UncheckedDate?     btw. I'm doing all this so I don't have to make every function that is fed a Date to do the actual run time checking. 'cause it's just tedious to write it over and over :)
12:01:00 <roconnor> schme2: you could also make Day a new type
12:01:09 <schme2> roconnor: I tried :)
12:01:18 <roconnor> schme2: how did that go?
12:01:30 <gwern> dammit lambdabot where are my messages?
12:01:38 <edwardk> dolio: a beautiful way to implement it. when can we have them? =)
12:01:39 <gwern> > 2 + 2
12:01:42 <lambdabot>  4
12:01:43 <schme2> roconnor: I started with date Day = 1 | 2 | 3 | 4   then I asked some questions here and it seemed complicated ;)
12:02:14 <roconnor> schme2: newtype Day = Day Int
12:02:22 * gwern must be laggin'
12:02:23 <roconnor> and then make a smart constructor for day
12:02:28 <schme2> aaaaah!
12:02:31 <schme2> brilliant!
12:02:35 <roconnor> if you want
12:02:38 <lispy> gwern: I left you a message
12:02:41 <roconnor> you could just let Day go.
12:02:50 <roconnor> and only have a smart constructor for Date.
12:02:59 <roconnor> or you could have smart constructors for both.
12:03:08 <gwern> lispy: I see it
12:03:17 <lispy> okay
12:03:18 <dolio> edwardk: Good question. :)
12:03:27 <schme2> roconnor: Ok.. I need to sleep on this :)
12:03:31 <schme2> roconnor: thanks a bunch there.
12:05:42 <dolio> @seen dons
12:05:42 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 11h 44m 11s ago.
12:06:56 <gwern> @tell boegel well, bsd3 is 'do whatever you want, but no guarantees about quality, and give me credit'. gpl is kind of like 'bsd3 + you have to give your modifications way under gpl'; see https://secure.wikimedia.org/wikipedia/en/wiki/BSD_licenses
12:06:56 <lambdabot> Consider it noted.
12:07:26 <twobitwork> man... haskell is such a relief after working with perl all day
12:07:43 <gwern> @tell boegel the difference isn't huge, but unless you really worry about people closing the source, for a haskell program bsd is a better choice (forexample, most of the stuff on hackage isd BSD; GHC is all-BSD iirc)
12:07:44 <lambdabot> Consider it noted.
12:07:49 <vixey> eat monad transformers for breakfast
12:08:36 <ehird> @tell boegel MIT LICENSE IS LIKE BSD BUT WITH MORE NINJAS. QED.
12:08:36 <lambdabot> Consider it noted.
12:09:49 <CosmicRay> solrize: I don't think it should be necessary to add anything specific to MissingPy for SimpleJSON.  But are you aware that JSON stuff exists for Haskell?
12:09:53 <gwern> ehird: that's not helpful
12:10:07 <ehird> gwern: :(
12:12:05 <gwern> MITers are more like samurais
12:13:48 <ehird> gwern: hahah
12:13:52 <schme2> right now it went to crap here again.
12:13:56 <MyCatVerbs> gwern: hang on, surely that's not quite it?
12:14:22 <ehird> schme2: are you insulting our amazingness
12:14:23 <gwern> MyCatVerbs: well, they are. they're lazy, pudgy, and on the government dole
12:14:35 <ehird> oh snap
12:14:42 <gwern> except when they're vicious intellectual warriors who decapitate people for fun
12:14:46 <MyCatVerbs> gwern: bsd4 is the one that says "gimme credit for it". That's the clause that makes it impossible to steal bsd4 code into gpl'd projects.
12:15:09 <gwern> MyCatVerbs: the advertising clause
12:15:29 <schme2> ehird: Hahaha!
12:15:46 <MyCatVerbs> Yes, precisely that. "Thou shalt pay homage to Thy Gods, the Regents of the Holy University of Berkely in the land of Cali Fornia."
12:15:59 <schme2> ehird: If you heard my random mumblings and saw the code I was producing I am quite sure you would feel insulted :)
12:16:09 <MyCatVerbs> Ah, that's it.
12:16:36 <MyCatVerbs> bsd-2 is "do what you want, it's not my problem if it explodes violently in your face"
12:16:42 <ehird> MyCatVerbs: I have this search for the most aesthetically-pleasing license.
12:17:00 <gwern> MyCatVerbs: but fortunately our gods are merciful gods, and they have rescinded the commandment
12:17:04 <gwern> alas, others have raised up false idols!
12:17:14 <ehird> Wha's that four line limit thing called?
12:17:32 <ehird> Well, a perfect license would be around that. Also, the UPPERCASE LEGALEASE would be at a minimum, with it still being legally valid.
12:17:32 <MyCatVerbs> bsd-3 is the same as bsd-2, but adds ", but you're not allowed to use my name to endorse it"
12:17:46 <MyCatVerbs> bsd-4 is bsd-3 plus "also, gimme credit, damn you"
12:17:47 * Baughn is just very annoyed that something as silly as an ad clause is preventing me from using zfs
12:17:58 <gwern> quatrain?
12:18:12 <ehird> gwern: what?
12:18:28 <MyCatVerbs> Baughn: yeah, I'm surprised there isn't a GPL variant with an exception for the advertising clause.
12:18:57 <ehird> http://www.opensource.org/licenses/fair.php this license is pretty close to perfect
12:19:00 <lambdabot> Title: Open Source Initiative OSI - Fair License:Licensing | Open Source Initiative
12:19:05 <gwern> Baughn: you think sun didn't do that deliberately?
12:19:06 <Baughn> MyCatVerbs: It'd be incompatible with any /other/ GPL. More to the point, still incompatible with linux
12:19:16 <ehird> but perhaps not as legally foolproof as I'd like
12:19:17 <gwern> they'll wait for the clones to get decent, then they'll relicense
12:19:21 <MyCatVerbs> Baughn: how so?
12:19:21 <gwern> just like with java
12:19:59 <Baughn> MyCatVerbs: Anyone can write a license. The *important* bit is which licenses zfs and linux use, and at least the latter is unalterable now
12:20:06 <MyCatVerbs> Baughn: hrmn, I guess it'd be infeasible to track down all the contributors, etc.
12:20:16 <MyCatVerbs> Ah well. Pity.
12:20:24 <Baughn> gwern: Then we'd still have the bsd-licensed code to build on..
12:20:39 <Baughn> gwern: Sure, might have to fork zfs, but it'd still be just as good
12:21:02 <MyCatVerbs> Perhaps the bigger pity is that 386BSD got held up by lawyers. Otherwise Linus would've installed that and Linux would never have been written.
12:21:39 <MyCatVerbs> (And then all that free-software effort *might* have gone into *BSD instead. Well, in my dreams. :P)
12:22:04 <int-e> GNU predates Linux
12:22:04 <ehird> The Elliott Hird Thisisprobablynotlegallysolid License, v1:
12:22:06 <ehird> <copyright>
12:22:06 <ehird> Distribution of this software is permitted provided that this license
12:22:06 <ehird> is included in the distribution.
12:22:06 <ehird> THIS SOFTWARE IS WITHOUT WARRANTY.
12:22:29 <gwern> Baughn: how can we fork zfs when it's already under cddl?
12:22:52 <Baughn> MyCatVerbs: Just for the record, I am totally uninterested in writing code for free tha companies can steal
12:23:02 <MyCatVerbs> Baughn: this is the downside. :/
12:23:09 <saml> > tell "Adfa"
12:23:10 <lambdabot>        add an instance declaration for (MonadWriter [Char] m)
12:23:14 <EvilTerran> while i'm totally uninterested in what companies do with my code, tbh
12:23:35 <gwern> I wish I wrote code companies would want to steal :(
12:23:38 <Baughn> gwern: Does CDDL prohibit forking?
12:23:53 <ehird> <Baughn> MyCatVerbs: Just for the record, I am totally uninterested in writing code for free tha companies can steal
12:23:55 <Baughn> MyCatVerbs: Then, what's the downside with gpl?
12:24:01 <ehird> 'Steal' is such a loaded word.
12:24:07 <ehird> I believe the term is 'use and modify'.
12:24:08 <Baughn> Overloaded, rather
12:24:15 <EvilTerran> i want my code in the hands of as many people as possible. if that means it ends up in closed-source projects, well, "meh"
12:24:22 <ehird> But arguing with GPL zealots is an excersise in brain rot. :-)
12:24:25 <Baughn> How do you feel about "use and modify without giving anything back"
12:24:34 <ehird> Baughn: Fine. It's called freedom.
12:24:35 <MyCatVerbs> Baughn: we can't swipe all nice code that shows up in the BSDs' userlands and kernels. :P
12:24:43 <EvilTerran> as long as i've made a useful contribution, i'm happy
12:24:47 <ehird> Same reason mandatory voting isn't free.
12:24:51 <EvilTerran> credit would be nice.
12:24:53 <Baughn> ehird: I'm willing to limit some freedoms in order to achieve a world more in line with my ideals
12:25:02 <saml> WTFPL ftw
12:25:15 <ehird> Baughn: See, that means you suck. Free software is about freedom.
12:25:19 <gwern> Baughn: I don't think so, but I don't think it's relevant? how can we fork a cddl-licensed project and get it under a gpl-compatible license?
12:25:27 <Baughn> gwern: Oh, we can't do /that/
12:25:36 <Baughn> gwern: But the freebsd folks can still use zfs, no matter what sun does
12:25:37 <EvilTerran> ?vixen what do you think of internet arguments?
12:25:37 <lambdabot> let's don't talk about that
12:25:48 <ehird> heh
12:25:56 <ehird> ?vixen what do you think of GPL zealots?
12:25:56 <lambdabot> i dunno...
12:25:59 <ehird> ..
12:26:00 <ehird> ?vixen what do you think of GPL zealots?
12:26:00 <lambdabot> i don't know, what?
12:26:01 <EvilTerran> i agree. to #haskell-blah!
12:26:02 <ehird> ..
12:26:05 <MyCatVerbs> ehird: ironically, use of the term "GPL zealot" tends to pigeonhole you as a BSD zealot. ;)
12:26:14 <EvilTerran> ?vixen what do you think of the BSD license?
12:26:14 <lambdabot> let's don't talk about that
12:26:22 <Baughn> ehird: Well, I'm not about to tell you you have to use gpl. Just don't tell me to use bsd. ^^;
12:26:24 <ehird> MyCatVerbs: Licenses-of-3-paragraphs-or-less zealot actually!
12:26:30 <ehird> I don't use BSD, anyway. Mostly I use MIT
12:26:36 <MyCatVerbs> ?vixen how do you feel about killing puppies?
12:26:36 <lambdabot> however you want
12:26:40 <MyCatVerbs> \o/
12:26:43 <saml> ?vixen say you don't know
12:26:44 <lambdabot> yup, i know
12:26:47 <ehird> hahahahah
12:26:47 <gwern> Baughn: oh. yeah, the BSd folks are just fine. but the bsds aren't really a thread to Sun/people Sun claims to support
12:26:48 <EvilTerran> hah
12:26:50 <olsner> <lambdabot> let's don't talk about that <-- very appropriate remark
12:27:03 <vixey> ?vixen hmm
12:27:04 <lambdabot> confused about something?
12:27:19 <ehird> lambdabot is confused.
12:27:21 <ehird> <ehird> ?vixen are you happier that the conversation has moved here?
12:27:21 <ehird> <lambdabot> i'm here
12:27:50 <Baughn> gwern: Now, if only we could convince the linux devs to allow haskell into the kernel, we could reimplement zfs...
12:28:09 <ehird> Baughn: That would be incredibly perverse..ly awesome
12:28:16 <ehird> MolassFS
12:28:31 <Baughn> ehird: I see no particular reason it should be at all slow
12:28:44 <Baughn> All the bulk operations could be done in C, as usual
12:28:49 <ehird> Baughn: Hahah
12:28:52 <MyCatVerbs> Baughn: garbage collection pauses in the -kernel- would be funny.
12:29:01 <ehird> Note to self- do not ever let Baughn write kernel code. Ever.
12:29:05 <gwern> Baughn: don't you know? we can't do that. We already have a ZFS
12:29:08 <ehird> Especially filesystems. Or drivers.
12:29:14 <MyCatVerbs> Baughn: just imagine the C++-on-Gentoo-with-all-optimizations-turned-up freaks going spastic. :D
12:29:29 <gwern> ehird: haskell has filesystems :(
12:29:29 <Baughn> ehird: Actually, my MSc project is a network filesystem. In haskell. Using FUSE.
12:29:45 <Baughn> s/is/will be/, but hey
12:29:47 <MyCatVerbs> ehird: you sure about that? Because (modulo unsafe things) Haskell programs under valgrind never drop -any- error messages.
12:29:50 <ehird> Baughn: Uh, I guess the network is the bottleneck there.
12:29:58 <ehird> MyCatVerbs: I'm thinking more about speed here.
12:30:02 <MyCatVerbs> ehird: I'd call that an upside. :)
12:30:04 <Baughn> ehird: And the disk is the bottleneck with a local filesystem
12:30:08 <ehird> Also, (modulo unsafe things) is hilarious
12:30:13 <Baughn> ehird: My network is actually faster than the disk, come to think of it
12:30:15 <ehird> C is save .. module unsafe things... like alloc
12:30:16 <ehird> *malloc
12:30:28 <MyCatVerbs> ehird: er, and pointer access. And every single array access, ever.
12:30:38 <ehird> MyCatVerbs: Exactly
12:30:50 <ehird> You're alright ... if you don't do anything wrong
12:31:15 <MyCatVerbs> ehird: whereas Haskell libraries are only ever really unsafe around the nasty edges where they interact with the rest of the system, generally. That's, uh, not an awfully large proportion of the code being written.
12:31:25 <MyCatVerbs> No, scratch that.
12:31:29 <ehird> MyCatVerbs: And you expect this to be the same for kernel code?
12:31:57 <MyCatVerbs> Unsafe things in Haskell tend to be rare enough that it's feasible to -mark- them as unsafe. Unsafe things in C pervade everywhere, plus everywhere else.
12:32:02 <Baughn> ehird: Filesystems do have relatively small boundaries
12:32:38 <MyCatVerbs> ehird: ahhh, point. Depends what you're doing, though. A filesystem is a different matter entirely to, say, a network card driver or the task switcher.
12:32:40 <opqdonut> how can i derive Eq and Show for my GADT?
12:32:50 <opqdonut> isn't there some package for "extended deriving"
12:32:54 <Baughn> There's the block layer (read/write/flushing-or-blocking), and there are a couple of operations exported upwards.. the rest is internal
12:33:03 <ehird> opqdonut: doesn't really make sense
12:33:09 <EvilTerran> opqdonut, there's Derive and so on, but i don't know if they support GADTs
12:33:34 <MyCatVerbs> ehird: What I *would* like to see, though, would be a Haskell-OS that ran purely under Xen. It'd be interesting to see how that'd perform.
12:33:41 <opqdonut> ehird: why not?
12:33:53 <ehird> MyCatVerbs: You should talk to the TUNES folks ... except that they all died in like 2005.
12:33:54 <Baughn> Mm, nice idea. Xen. Of course. :)
12:34:12 <bos> MyCatVerbs: i believe that galois has something like that running.
12:35:15 <dmwit> ?go house haskell operating system
12:35:15 <lambdabot> No Result Found.
12:35:22 <MyCatVerbs> Baughn: well, Xen actually manages to do the job of an exokernel system, just with much of the terminology inverted for various reasons.
12:35:22 <dmwit> You lie!
12:35:34 <MyCatVerbs> dmwit: that isn't open source though, is it/
12:35:51 <dmwit> I know nothing about it except for its name.
12:35:56 <MyCatVerbs> ehird: link, please? Looking at tunes.org, which doesn't seem to be it.
12:36:02 <ehird> MyCatVerbs: Yah, tunes.org
12:36:26 <MyCatVerbs> Ohhhh, right. *hops up to the root directory instead*
12:36:37 <ehird> TUNES is a visionary project, based upon the principles of computing freedom and mutual trust, to lay the social and technical foundations for a renaissance in computing.
12:36:42 <ehird> it's kinda like an OS project, but so much more
12:36:49 <ehird> they rethought everything from the ground up
12:36:57 <Baughn> Hm. Would it be illegal to distribute a patch set grafting zfs onto linux, given the bsd-zfs sources?
12:37:02 <Baughn> Would it be illegal to /use/ such a thing?
12:37:03 <ehird> loads of people put in their OS ideas and produced prototype/experimental OSs, etc
12:37:09 <ehird> but it never actually got anything done
12:37:19 <ehird> 1994-present, and it's still "alive" but ... not
12:37:31 <ehird> still, it's a pretty large scale project
12:37:34 <ehird> people will come back to it eventually
12:37:38 <gwern> Baughn: I don't *think* so
12:37:39 <ehird> it's just a very long, dormant hiatus
12:37:44 <MyCatVerbs> Baughn: yes and no respectively, I think.
12:38:06 <Baughn> MyCatVerbs: What exactly causes the first yes?
12:38:15 <Baughn> ..I need a lawyer
12:38:17 <ehird> Baughn: It violates the gpl, I believe.
12:38:18 <gwern> Baughn: for example, gentoo can distribute ebuild scripts adding firefox branding, or installing proprietary kernel modules; you can install it, but not distribute the results of the scripts
12:38:25 <MyCatVerbs> Or maybe even yes and "yes, but nobody would bother to chase you up", respectively.
12:38:31 <ehird> But if Baughn's a GPL zealot, he's not being very convincing right now ...
12:38:31 <gwern> licensing is hard
12:38:38 <gwern> let's - let's go shopping?
12:38:40 <MyCatVerbs> Baughn: yes, you need a lawyer for this. Sorry.
12:38:44 <MyCatVerbs> gwern: no, no.
12:38:58 <Baughn> gwern: I'm /not/ a gpl zealot
12:39:00 <MyCatVerbs> gwern: shopping is hard, let's do maths. Licensing is hard, let's hack on programs. Etc.
12:39:17 <Baughn> I just wouldn't want to use anything but gpl on my own programs, unless there was a good reason
12:39:23 <Baughn> "Doing neat stuff" is a good reason
12:39:23 <gwern> Baughn: hey, I didn't call you a zealot
12:39:25 <ehird> gwern: okay!
12:39:29 * gwern is a public-domain/GPL zealot, fwiw
12:39:39 <ehird> I like pd
12:39:56 <radix> french people don't
12:40:01 <gwern> MyCatVerbs: actually, I've been thinking of doing some programming, but this discussion keeps distracting me :)
12:40:51 <gwern> how annoying though that I cannot find any changelog parsers
12:41:16 <ehird> radix: good
12:41:22 <ehird> they'll all BURN IN HELL because they can't use my software
12:41:23 <ehird> mwahahahahaha!
12:41:33 <ehird> ... <.<
12:41:34 <radix> ehird: maybe you should be nicer
12:41:38 <dmwit> Public domain is problematic.
12:41:49 <ehird> dmwit: But not as much as commonly thought.
12:41:54 <Baughn> ..urk. My nice, entertaining firefox tab is all alone in a forest of haskell documentation. (There are.. fifteen library index pages here?)
12:41:59 <gwern> (oh man, subversion generates an ugly change log
12:42:01 <radix> ehird: and encode the basic concepts of your desires of making the code "public" into a trivial license, such as the MIT/Expat
12:42:30 <radix> that way, french people will be able to use it.
12:42:37 <Baughn> dmwit: What is problematic about public domain?
12:42:53 <gwern> dmwit: ironic, isn't it? copyright law is so entrenched that you can't even opt out of it
12:42:56 <dmwit> Baughn: It's not clear (legally) that you can put something into the public domain (even if you have the copyright).
12:43:10 <ehird> radix: What if my program is a program to launch missiles against the french?
12:43:15 <Baughn> dmwit: ...
12:43:17 <ehird> Didn't think of that huh?!!!
12:43:19 <dmwit> Baughn: Things *might* have to enter the public domain on their own (i.e. after 70 years).
12:43:22 <radix> ehird: I don't see a problem with that.
12:43:24 <Baughn> dmwit: Well, I'm pretty sure it /is/ clear /here/, at least
12:43:33 <gwern> Baughn: indeed. in US law, there's even an odd loophole where it might be possible to 'retract' a license you gave out for free
12:43:37 <ehird> radix: :<
12:43:47 <radix> ehird: Unless you're trying to prevent the French from modifying it to launch missiles at the US. Then you might want to indicate that in the license.
12:44:10 <ehird> radix: I just want to punish them a bit more before I launch missiles at them. :(
12:44:14 <ehird> And I'm from the UK thankyouverymuch.
12:44:36 <gwern> Baughn: keep in mind, by what I mean by 'retract' is undo the licensing on all derivatives and copies - everywhere. let's hope the loophole gets closed by a ruling at some point!
12:44:47 <snorbi07> I have  a problem with wxHaskell... when I run it in ghci, it fails to start twice. Meaning, run main, click the exit button on the form... then run main again and it leads to a crash. Ideas?
12:44:51 <Baughn> gwern: Hm. I can see potential in this
12:45:13 <Baughn> Put out some crucial code in public domain, wait for it to be commonly used, retract, profit!
12:45:37 <gwern> Baughn: well, you'd want to do it under GPL for maximum effect
12:45:37 <radix> Baughn: That may be nice if you only care about distributing stuff wherever "here" is, but if you really want everyone to be able to use it without restrictions, it's less controversial to just put it into a license that states as much.
12:45:43 <MyCatVerbs> Baughn: watch a dozen clones spring up in about fifteen minutes flat.
12:46:05 <Baughn> MyCatVerbs: I'll nail them for using my code without a license all these years
12:46:08 <gwern> doing it under public domain opens an estoppel defense and also a defense that you put it in the public domain :)
12:46:40 <Baughn> You're getting sanity on my profit. Stop.
12:47:20 <dmwit> CAN WE SHOUT FOR A BIT
12:47:42 <swidgy> shouldn't you have waited for an answer before shouting?
12:47:58 <swidgy> and where did the haskell go?
12:48:07 <s_clv> ?where haskell
12:48:07 <lambdabot> http://haskell.org/
12:48:10 <Baughn> Right here..
12:48:13 <s_clv> ^^
12:48:22 <Baughn> What system resources does ghci grab that other programs don't?
12:48:29 <dmwit> snorbi07: Dunno for sure, but probably something important gets destructed when you exit.
12:48:36 <Baughn> (Other ghc programs that is)
12:48:47 <dmwit> snorbi07: Does wxHaskell have an "initGUI" or similar command?
12:50:18 * Baughn wonders why glut felt the need to call getpid... 36,380 times to create one window
12:50:25 <ehird> dmwit: YES WE CAN
12:50:40 <MyCatVerbs> Baughn: to make sure?
12:51:11 <dmwit> EHIRD: EXCELLENT HOW WAS YOUR DAY I THINK I LIKE MY DAY BETTER
12:51:25 <ehird> DMWIT: I HATE YOUR DAY IT HATES FREEDOM
12:51:28 <ehird> YOUR DAY IS A TERRIST
12:51:54 <dmwit> I LIKE THINGS STOP I LIKE FREEDOM STOP TERRORISTS ARE SOMETIMES SMALL FULL STOP
12:52:32 <snorbi07> dmwit: I've tried the provided samples... As far as I can tell that would be the "run" function which you call from main, like "run myGui"
12:52:42 <ehird> STOP IT STOP STOP
12:52:57 <dmwit> hehe
12:54:30 <schme2> gaaah!
12:54:56 <ehird> schme2: what
12:55:18 <schme2> I will just conclude that I will never ever figure out how to do Date { year = 1231, Month = December, day=12 } and it actually checks that day <= 31
12:55:28 <ehird> schme2: impossible
12:55:36 <schme2> ehird: What?
12:55:39 <ehird> Requires dependant types.
12:55:48 <schme2> What is that?
12:55:48 <ehird> Haskell don't have those.
12:55:49 <Cale> You can construct a function to build Date values for you which does the required checks.
12:55:49 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
12:55:51 <ehird> You can do this though:
12:55:53 <schme2> Ugh.
12:55:56 <ehird> Date 1231 December 12
12:56:01 <ehird> err
12:56:03 <ehird> s/date/makeDate
12:56:08 <ehird> schme2: what's wrong with
12:56:13 <ehird> makeDate 1231 December 12
12:57:00 <schme2> Well first off all the people who would do makeDate 12 December 1231  would get odd stuff.
12:57:22 <schme2> and then it seems shit if all functions should be called with that huge arse thing. :)
12:57:30 <ehird> schme2: Uhm
12:57:39 <ehird> Programmers have to know what order functions take arguments in!!
12:57:41 <ehird> OMGWTF
12:57:48 <ehird> schme2: The type siagnature will help.
12:57:55 <ehird> makeDate :: Year -> Month -> Day -> Date
12:58:01 <ehird> (do type Year = Integer, etc.)
12:58:08 <ehird> that's the idiomatic way to communicate it
12:58:09 <schme2> My thinking is that a lot of functions will be working on Date.
12:58:13 <ehird> schme2: And?
12:58:18 <dmwit> You can easily enforce the order of arguments, if that's your only complaint.
12:58:21 <dolio> @tell dons http://hpaste.org/7595
12:58:22 <lambdabot> Consider it noted.
12:58:39 <schme2> and I just don't get how I avoid having each one of 'em checking for erronous dates.
12:58:49 <ehird> schme2: makeDtae will check it
12:58:56 <ehird> makeDate 1000 1 5646 -> ZOOP! Error.
12:59:01 <schme2> I'm not following you here though.
12:59:03 <ehird> makeDate :: Year -> Month -> Day -> Maybe Date -- This will help
12:59:08 <ehird> Nothing for an invalid date
12:59:11 <ehird> Just theDate for a valid one.
12:59:26 <ehird> schme2: do this
12:59:32 <schme2> but what about doSomethingToDate Date -> Date  ??
12:59:35 <ehird> makeDate y m d | d > 31 = OMFG
12:59:40 <ehird> makeDate y m d = Date y m d
12:59:55 <ehird> schme2: with that you can even check the number of days relateing to the month
13:00:00 <ehird> so feb 31 fails
13:00:11 <schme2> Ya but I don't get it with all the functions that do stuff on dates.
13:00:28 <ehird> schme2: Tip of the day - you aren't communicating clearly
13:00:31 <snorbi07> Ok so if I leave out the "run" function the second time the same crash happens... if I leave it out the first time I get a seg fault
13:00:32 <dmwit> schme2: For "doSomethingToDate", either write it to only produce correct Date's, or have it return a Maybe Date.
13:01:04 <Cale> Or you could, you know, not reinvent the wheel, and use Data.Time.Format to parse dates ;)
13:01:05 <schme2> Ok here. I want to write functions that Date -> Date
13:01:10 <dmwit> schme2: You can make what's called an "abstract data type", that is, one that doesn't expose the constructors.
13:01:25 <schme2> Cale: That sounds much better.
13:01:28 <dmwit> Or, yeah, just use Data.Time.
13:01:32 <ehird> jesus
13:01:34 <ehird> why didn't you guys tell me that
13:01:39 <ehird> I wouldn't have fussed about with this crap ;)
13:02:00 <schme2> dmwit: I have been trying to figure out what on earth I would want an abstract data type for though.
13:02:13 <schme2> It all seems way complicated doing stuff in haskell :S
13:02:16 <ehird> schme2: Data.Time
13:02:21 <dmwit> schme2: With a smart constructor, you can be sure that dates sent as inputs are well-formed.
13:02:22 <schme2> But I'm sure it'll all work out jez fine.
13:02:23 <ehird> until you know .. well, haskell :P
13:02:36 <ehird> (And Data.Time after that too!)
13:02:41 <schme2> dmwit: Yes. I have been trying to do that the last 2-3 hours here :)
13:02:42 <dmwit> schme2: Then, if all the functions acting on that type create well-formed dates, you never have to worry.
13:02:49 <tieTYT> hello, i'm reading this pdf about functional programming and it's defining a function like this:
13:02:54 <tieTYT> (reduce f x) nil = x
13:02:54 <schme2> dmwit: reading haskell.org about smart constructors and all.. still makes nooo sense.
13:02:57 <ehird> schme2: makeDate is said smart constructor
13:02:59 <dmwit> schme2: What problem were you running into?
13:02:59 <tieTYT> (reduce f x) (cons a l) = f a ((reduce f x) l)
13:03:13 <tieTYT> since it just calls reduce f x over and over again, why isn't this an infinite loop?
13:03:15 <dmwit> schme2: Why don't you paste some code showing what you've tried?
13:03:26 <ehird> tieTYT: it calls (reduce f x) l
13:03:29 <ehird> l can be nil
13:03:31 <ehird> at the end of the list
13:03:32 <schme2> dmwit: I am very confused about how all functions are so sure the Dates are correct.
13:03:34 <ehird> so it does the base case above
13:03:44 <Cale> schme2: You want an abstract datatype whenever the values you're interested in are not simply freely generated by constructor applications to arbitrary values of appropriate types -- that is, whenever there's some invariant you want enforced or imposed on the data as it's constructed.
13:03:51 <dmwit> tieTYT: It doesn't loop infinitely because it recurses on a smaller value.
13:03:56 <ehird> dmwit: He's thinking that currently he has to validate the dates inside each of his date->date functions.
13:04:15 <Cale> tieTYT: It immediately proceeds with f, not reduce
13:04:17 <ehird> dmwit: I am trying to explain that a makeDate function makes that unneccessary.
13:04:18 <dmwit> tieTYT: i.e. reduce f [1, 2, 3] recurses on reduce f [2, 3], then reduce f [3], then reduce f [], which is finally a base case.
13:04:27 <ehird> Howerver, he doesn't understand.
13:04:34 <Cale> dmwit: Not necessarily :)
13:04:42 <schme2> Cale: Yes. I didn't seem to get it to make much sense though.
13:04:46 <swidgy> tieTYT: you simply have to ensure that the non-recursive case is actually encountered on all input to ensure termination
13:04:52 <vixey> what's the simplest lazy lambda evaluator in haskell?
13:05:08 <Cale> @src foldr
13:05:09 <lambdabot> foldr f z []     = z
13:05:09 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:05:13 <ehird> vixey: id
13:05:21 <Cale> > foldr (\x xs -> 2*x : xs) [] [1..]
13:05:25 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
13:05:58 <Peaker> is it not a bit limiting that a list must be homogenous to types, and not homogenous to classes (as functions sort of are)?
13:06:03 <Cale> If you want to see why that's not an infinite loop...
13:06:04 <dmwit> schme2: Let me give you a simple example of an abstract data type that enforces non-negativity.
13:06:08 <Cale> foldr (\x xs -> 2*x : xs) [] [1..]
13:06:13 <schme2> ehird: I did have something quite like makeDate and others. It still did not prevent me from calling fooDate with fucked up data though. That is my problem :)
13:06:28 <dmwit> schme2: You need two modules to prevent that.
13:06:29 <Cale> -> (\x xs -> 2*x : xs) 1 (foldr (\x xs -> 2*x : xs) [] [2..])
13:06:31 <ehird> schme2: makeDate would stop you making invalid data in the first place.
13:06:41 <schme2> ehird: Hmm.. how?
13:06:42 <Cale> -> (\xs -> 2*1 : xs) (foldr (\x xs -> 2*x : xs) [] [2..])
13:06:45 <ehird> if makeDate validates it and you use makeDate to make Dates, how do you get an invalid one to pass to fooDate, schme2?
13:06:46 <dmwit> schme2: From the one module, you export Date and makeDate, but not Date's constructors.
13:06:51 <Cale> -> 2*1 : (foldr (\x xs -> 2*x : xs) [] [2..])
13:06:58 <ehird> dmwit: schme2 doesn't know that makeDate can do the validation for him
13:07:08 <dmwit> I don't think that's a correct statement.
13:07:18 <ehird> dmwit: I'm good at interpreting people. :-)
13:07:21 <ehird> ehird> schme2: makeDate would stop you making invalid data in the first place.
13:07:21 <ehird> <schme2> ehird: Hmm.. how?
13:07:23 <dmwit> I find it much more likely that he doesn't realize how to use modules correctly.
13:07:24 <schme2> ehird: my makeDate does validation.
13:07:25 <ehird> that shows it
13:07:29 <Cale> So the first element of the list is available without recursing forever.
13:07:33 <ehird> schme2: so how do you get an invalid Date to give to fooDate?
13:07:43 <schme2> ehird: The problem is that I can still make Dates by not using makeDate.
13:07:47 <ehird> schme2: OK
13:07:49 <ehird> in your module
13:07:53 <ehird> (say, Dateratamatron)
13:07:56 <ehird> tell it to only export makeDate
13:07:58 <Cale> schme2: So you don't export the Date constructor.
13:07:59 <ehird> and not Date's constructor
13:08:00 <ehird> so
13:08:06 <ehird> module Dateratamatron (Date, makeDate)
13:08:12 <ehird> (Date means the Date type)
13:08:19 <ehird> (Date(Date) would mean the Date type, and its constructor Date)
13:08:27 <ehird> So, if you do Date, not Date(Date), and then makeDate
13:08:33 <ehird> then you can't use the regular Date to make a date.
13:08:36 <Cale> (Or  Date(..)  if you want to export all the constructors)
13:08:38 <ehird> Ergo, invalid dates are impossible to get.
13:08:39 <ehird> Yay!
13:08:44 <ehird> Cale: Yeah, was gonna leave that as a note for last
13:08:45 <tieTYT> i'm still confused.  when I go through this the first time, with [1,2,3], will it do:  f 1 ((reduce f x) [2,3])
13:08:55 <Cale> tieTYT: yeah
13:08:59 <schme2> ehird: somehow that did not seem to work for me. I will try that again.
13:08:59 <ehird> tieTYT: yes
13:09:11 <ehird> schme2: Well, you can't do it form inside the module.
13:09:12 <Cale> tieTYT: Then f will be evaluated.
13:09:12 <tieTYT> but like, what does (reduce f x) mean?  How can that be evaluated?
13:09:17 <ehird> schme2: Make another module that does 'import Dateratamatron'
13:09:30 <ehird> schme2: Then you'll see.
13:09:45 <ehird> schme2: So, admittedly, if your own library creates Dates directly ... but, then, presumably you're not silly ;)
13:09:52 <Cale> tieTYT: (reduce f x) [2,3] = reduce f x [2,3]
13:10:10 <Cale> tieTYT: In general,  f x y z = ((f x) y) z
13:10:35 <tieTYT> and what's that mean?  There's no 3 arg reduce function
13:10:41 <dmwit> schme2: http://hpaste.org/7596
13:10:44 <schme2> ok. first off here. How do I do a makeDate { year=1212, month=January, day=12}  ?
13:10:51 <ehird> schme2: Can't
13:10:56 <ehird> schme2: And you don't need to.
13:10:57 <schme2> that's utter shit.
13:10:58 <ehird> What is wrong with:
13:11:03 <ehird> makeDate :: Year -> Month -> Day -> Date
13:11:07 <Cale> All functions in haskell are really functions of one parameter. Functions with more parameters just return functions which take the rest.
13:11:19 <ehird> schme2: Why is it, as you so eloquently put it, 'utter shit'?
13:11:24 <ehird> What is wrong with Year -> Month -> Day -> Date?
13:11:26 <Cale> But you don't have to think of it that way if you don't want to.
13:11:31 <ehird> Haskell people do leran a function before using it, FFS.
13:11:31 <schme2> well because it is what I want to do really.
13:11:35 <ehird> Even if they just look at its type
13:11:46 <Cale> You can just regard a function which returns another function as a function of two (or more) parameters.
13:11:53 <ehird> schme2: You might also want to use IO in a pure function and write imperatively. Doesn't mean Haskell should accomodate you :|
13:11:56 <schme2> Well it's for users though. Not haskell hackers.
13:12:14 <tieTYT> Cale: weird, that's hard for me to wrap my head around
13:12:19 <schme2> ehird: hahahaha
13:12:20 <ehird> schme2: why are you having a user write haskell code?!!!?!?!!?!!
13:12:26 <ehird> THAT is the problem here!
13:12:32 <Cale> > let add x y = x + y in map (add 1) [1,2,3]
13:12:33 <lambdabot>  [2,3,4]
13:12:45 <Cale> tieTYT: there's a little example...
13:12:52 <schme2> I don't get the problem. Users do date { year ....} was my plan and have it gets checked.
13:12:57 <Cale> > let add x y = x + y; addOne = add 1 in addOne 5
13:12:57 <Peaker> Coming from a background of other languages, a very commonly recurring pattern is using a list/stream of some objects that implement an interface, and then calling methods of the interface on items of the list, where each item may be hetrogenously-typed (but homogenously interfaced).  What would be used in Haskell instead?
13:12:58 <lambdabot>  6
13:13:03 <ehird> schme2: Why do you want your users to write haskell code
13:13:04 <schme2> seems I need to reeval my plan, that's all.
13:13:09 <ehird> that's evil
13:13:12 <ehird> your users don't know haskell
13:13:16 <ehird> they don't want to learn it
13:13:18 <Baughn> Peaker: Well, you could do exactly that
13:13:21 <ehird> and if they do want to use haskell with your software
13:13:23 <ehird> then they should learn it
13:13:29 <ehird> by extension they are then developers and don't have the proble many more
13:13:33 <Peaker> Baughn, but Haskell forces my list to be homogenously-typed, not homoegenous-interfaced
13:13:41 <Saizan> Peaker: an existential type
13:13:43 <Cale> Peaker: The first solution would be to pass around a bundle of functions (the interface) rather than the value itself.
13:13:45 <Baughn> Peaker: Look at rank-n types and existential  qualification
13:13:55 <dmwit> schme2: Yes, if you want to use that format, you'll probably have to parse it yourself.
13:13:59 <dmwit> schme2: Sorry. =/
13:14:02 <tibbe> OT: I'm thinking of starting a haskell blog. can anyone recommend some blog software that works well with haskell source
13:14:02 <Cale> Peaker: After you get how that works, you might want to have a look at existential types.
13:14:09 <Cale> Peaker: But usually it's sufficient.
13:14:15 <ehird> dmwit: why does he want his users to write haskell :\
13:14:23 <Baughn> Peaker: Passing around a bundle of functions instead of a raw data pointer is exactly what OO languages do, and how existential types work too, for that matter
13:14:24 <schme2> Cale: that thing you said there really makes sense though.
13:14:30 <dmwit> ehird: Why don't you let him figure out what he wants to do?
13:14:47 <schme2> See i'm not used to haskell think. So I hope ya'll don't get too annoyed by my weird ways here :)
13:14:53 <dmwit> ehird: I find it much more useful to state what's possible than to dictate desires.
13:15:01 <thoughtpolice> tibbe: i used markdown for a little while, but you can use hscolour on your source, stick it into the file, and just have the hscolour.css in your html
13:15:01 <Peaker> Baughn, yeah, I guess, thanks
13:15:06 <dmwit> schme2: No, you're doing fine. =)
13:15:07 <ehird> dmwit: x-not-y question - they're saying "how do I do x?", they mean "how do I do y?". x is a specific detail, y is a general problem.
13:15:14 <Baughn> Peaker: (There is the optimization of having a single global bundle for each class, but you can do /that/ by hand too)
13:15:18 <ehird> the general problem in this case is unknown
13:15:22 <ehird> but it's causing a silly X-problem
13:15:28 <orbitz> Baughn: HAI
13:15:41 <dmwit> ehird: Yes, I am aware of those.  In that case, it is also not helpful to dictate desires.
13:16:12 <schme2> ehird: But like this. I come from CL, so it makes perfect sense for me that the users actively use the REPL for doing stuff anyway. I guess maybe it makes not-sense in haskell.
13:16:29 <ehird> schme2: I'm not sure who you consider users.
13:16:36 <Baughn> schme2: If you want to do it, you can do it. There are at least two different interfaces for this
13:16:44 <dmwit> schme2: It can make sense.  It's just that record syntax is reserved for constructors.
13:16:59 <Cale> Peaker: For instance, if, say, you're writing a raytracer, and you have a bunch of objects that you want to pass around, you might consider just passing around functions which compute ray collision.
13:17:05 <orbitz> schme2: ocaml is a pretty good REPL if you find that very important.
13:17:05 <schme2> ehird: Well even my GUI programs tend to have a CL repl where you can enter stuff. Like :   move checker from 1 to 4    or some such :)
13:17:15 <ehird> schme2: That's not cl
13:17:19 <Cale> (and so on)
13:17:24 <Peaker> Cale, Yeah.. Actually I think I did think about it, but messed up an attempt to implement it :) trying again now
13:17:27 <schme2> orbitz: Well.. thanks. I really want to do this in haskell though.
13:17:30 <ehird> schme2: obviously, you parse 'move checker', ETC
13:17:32 <orbitz> ok
13:17:36 <ehird> schme2: so why don't you parse this?
13:17:48 <schme2> ehird: Ok. Let's not get carried away with what is CL and what is not CL here. But I ensure you that it is.
13:17:50 <ehird> or does your checker program really use (move checker :from 1 :to 4)
13:17:53 <ehird> 'cause if so, that's ugly
13:17:54 <dmwit> ehird: I'm pretty sure he's asking for the CL runtime to do the parsing.
13:17:57 <orbitz> Hugs REPL is generally considered superior to ghci from what i've heard, but I don't have much first hand exprience
13:18:00 <ehird> dmwit: Ah. Readtable.
13:18:10 <schme2> ok: nevermind the CL stuff.
13:18:11 <Cale> orbitz: really?
13:18:14 <ehird> dmwit: Well, readtables are a silly idea. :)
13:18:38 <dmwit> schme2: I think it's much more accepted in the Haskell world to just have a function that takes a bunch of parameters, and expect people to know how to call it given its type.
13:18:50 <Cale> orbitz: Hugs seems outright impoverished sitting next to GHCi these days.
13:18:51 <orbitz> Cale: that is what various pages i've read say. and Craft Of Functional Programming makes innuendo, perhaps i'm reading him wrong though and he just wants the windows support
13:19:01 <dmwit> schme2: So "makeDate 12 December 1231" is perfectly acceptable as a ghci interface, I think.
13:19:01 <schme2> Baughn: Actually I mostly want a wx interface for this one here. It seems that haskell lacks the repl obsession :)
13:19:04 <orbitz> Cale: ok, ilooks like i'm off
13:19:05 <Valodim> dmwit: indeed, and that's one concept that takes some time getting used to
13:19:15 <ehird> dmwit: no
13:19:16 <tieTYT> this is written so badly: A function of 3 arguments such as reduce, applied to
13:19:16 <tieTYT> only 2 is taken to be a function of the one remaining argument, and in general,
13:19:16 <tieTYT> a function of n arguments applied to only m(< n) is taken to be a function of
13:19:16 <tieTYT> the n ° m remaining ones.
13:19:20 <ehird> Year -> Month -> Date
13:19:22 <tieTYT> oh sorry, i thought that would be 1 line
13:19:34 <ehird> dmwit: let's not invade human crap date ordering systems into our haskell
13:19:39 <dmwit> ehird: The type will tell that, though, is the point.
13:19:42 <ehird> dmwit: YMD is top->bottom, DMY is also fine.
13:19:43 <schme2> dmwit, ehird: You're both quite right with the whole issue being kinda dumb. :)
13:19:50 <tieTYT> now it must be my OO background, but reduce is not defined with 3 arguments, it's defined with 1 or 2
13:19:55 <Baughn> schme2: If it works right the first time you don't /need/ a repl, now do you? ;)
13:20:00 <ehird> dmwit: oh I thogut hyou had month -> day -> year
13:20:03 <ehird> dmwit: if you did that i'd slap you
13:20:10 <dmwit> ehird: Also, what I wrote is DMY, why are you complaining?
13:20:10 <dmwit> yeah
13:20:27 <ehird> tieTYT: (f a b c = ...) is (((f a) b) c) = ...)
13:20:29 <Cale> tieTYT: reduce f z [] = z; reduce f z (x:xs) = f x (reduce f z xs) ?
13:20:33 <schme2> Baughn: Hahaha! I'm not going to bite on that.
13:20:44 <ehird> tieTYT: 'f a b c = ...' is actually 'f = \a -> (\b -> (\c -> (...)))'
13:20:46 <Valodim> the problem is it's kinda frustating when you have to figure out every single function you come accross. it gets better after a while but at the beginning when even the whole prelude is new... meh
13:20:51 <ehird> tieTYT: You see? Functions only have one argument.
13:21:05 <ehird> tieTYT: But since functions can return functions, and if 'a b c' is '((a b) c)'...
13:22:45 <tieTYT> no i don't get it :P  What's the next step after this f 1 ((reduce f x) [2,3])
13:22:54 <Baughn> tieTYT: Of course, this one-argument thing is all a big fat lie. Haskell won't start /evaluating/ anything until you have all the parameters accumulating (for the pattern match), and then there's slicing to deal with..
13:23:06 <tieTYT> i think this tutorial just started me off in a stupid place
13:23:07 <Baughn> *accumulated
13:23:44 <ehird> Baughn: You know what sucks? Bombarding newbies with fine points of detail before they've got the basics of a concept.
13:23:55 <Cale> tieTYT: The next step is to apply f to 1 and ((reduce f x) [2,3])
13:24:10 <Cale> tieTYT: So take the body of the function f, and substitute in those expressions.
13:24:15 <Baughn> ehird: Yeah, but that particular "fine point" confused me on the very /first/ serious haskell program I wrote..
13:24:27 <tieTYT> ok if f is add, that means : 1 + ((reduce f x) [2, 3]) ?
13:24:31 <Cale> yeah
13:24:37 <ehird> Baughn: But he seems to be not past toy ones. :-)
13:25:11 <tieTYT> i'm stuck again.  How can I continue from here?
13:25:18 <Baughn> tieTYT: Then note that my caveat won't affect /semantics/, only performance, and you can ignore it for a while
13:25:20 <Cale> tieTYT: and since + needs to know the values of both its parameters before it can decide what to return, ((reduce f x) [2, 3]) will need to be evaluated.
13:25:35 <dmwit> tieTYT: Then again use the definition of reduce (on the RHS of the +).
13:25:47 <ehird> God I need to write my haskell tutorial
13:25:53 <ehird> Seeing newbies confused pains me. :-)
13:26:00 <tieTYT> pains me just as much :)
13:26:14 <Baughn> ehird: Write it, and you get to see newbies confused by your tutorial. :)
13:26:20 <ehird> tieTYT: SOME SACRIFICES MUST BE MADE IN THE ROAD TO GREATNESS <.<
13:26:21 <Cale> > foldr f z [1,2,3]
13:26:22 <lambdabot>  f 1 (f 2 (f 3 z))
13:26:27 <ehird> Baughn: I'll start at 'for dummies' level :P
13:26:29 <ehird> Short sentences!
13:26:36 <tieTYT> yes that'll help
13:26:50 <Cale> In the end, that's the kind of expression we're building, assuming that all the reduces get evaluated before any f does.
13:26:53 <ehird> Words of 4 or less letters.
13:27:02 <ehird> Hack is fun with Hask.
13:27:03 <tieTYT> and don't write it with the dictionary syndrome: I shouldn't have to know haskell to understand your haskell tutorial
13:27:21 <ehird> Fluff is type class. Fluff has bind, wrap, fail.
13:27:22 <byorgey> 'This is your brain. <diagram>  This is your brain on Haskell. <diagram>'
13:27:29 <ehird> byorgey: That's more than 4 letters.
13:27:36 <byorgey> oops, sorry
13:27:46 <Baughn> byorgey: Diagrams are evil
13:28:06 <byorgey> 'This is your head.   This is your head with Hask.'
13:28:07 <Cale> tieTYT: Haskell has non-strict semantics, which means that if any order of evaluating things (applying definitions) will terminate, then a Haskell implementation is required to terminate and produce the same result.
13:28:14 <ehird> IO is Fluff. IO does in and out.
13:28:30 <byorgey> Fluff is five letters.
13:28:35 <ehird> byorgey: Crap.
13:28:37 <dmwit> IO is easy.
13:28:39 <ehird> Puff, then.
13:28:39 <Baughn> "This line here is where you can guarantee termination. This other line here is where you can also guarantee termination, less efficiently. This blue box over in the corner that is nowhere near the lines is the internet."
13:28:44 <Cale> tieTYT: You can treat it just like applying functions in highschool algebra
13:29:05 <ehird> Hask is lazy. Hask does not do it 'til it must.
13:29:20 <tieTYT> anyway, i don't know how to move on from that point.  The way I'm looking at this is that there's no match for reduce a b (cons x y) or whatever
13:29:24 <dmwit> "Haskell" is a long way to say "Hask".
13:29:32 <dmwit> There, now you can use Haskell instead of Hask.
13:29:47 <orbitz> ehird: how will you talk abotu currying?!
13:29:47 <byorgey> Hask is pure.  Hask does not do bad acts on the side.
13:29:55 <dmwit> tieTYT: Oh, [2, 3] is short for (cons 2 (cons 3 nil)).
13:29:58 <ehird> dmwit: Yeah but I could do that with every word.
13:30:03 <Cale> If f(x) = x^2, then to evaluate f(2 + 4), you can either add first to get f(6), and then apply f to get 6^2 which is 36
13:30:04 <ehird> byorgey: Great!
13:30:10 <ehird> orbitz: cury.
13:30:15 <Cale> or you can apply f directly: (2 + 4)^2
13:30:17 <dmwit> ehird: fail
13:30:25 <tieTYT> dmwit: yeah well I still don't see a reduce definition that'll take a b then (cons ...)
13:30:26 <ehird> Fine
13:30:27 <ehird> papp
13:30:30 <ehird> (Partial application)
13:30:32 <dmwit> ehird: Taking long words and making them short does not improve readability.
13:30:35 <Cale> and then continue in a number of different ways :)
13:30:57 <ehird> Hask does papp. Box gets one, but box can give a box, to make more.
13:30:59 <ehird> dmwit: It's a joke.
13:30:59 <byorgey> no, to make things simpler to understand, we have to use normal, everyday words instead of those scary technical terms.
13:31:10 <tieTYT> i think i'll just move to another tutorial
13:31:17 <Cale> tieTYT: But the basic idea is that you replace things with their definitions repeatedly.
13:31:18 <orbitz> ehird: joke is less than 5 letters!
13:31:18 <ehird> http://www.muppetlabs.com/~breadbox/txt/al.html
13:31:21 <lambdabot> Title: Short Words to Explain Relativity
13:31:21 <ehird> Albert Einstein's Theory of Relativity
13:31:22 <ehird> In Words of Four Letters or Less
13:31:23 <ehird> my inspiration
13:31:31 <Cale> tieTYT: Do you get what I'm saying?
13:31:36 <Cale> tieTYT: Maybe a bit?
13:31:41 <tieTYT> Cale: yes, but i don't know how to do it for that instnace
13:31:42 <tieTYT> instance
13:31:43 <byorgey> so instead of 'partial application', for example, we'll say 'poke'
13:31:56 <ehird> byorgey: brilliant
13:31:57 <byorgey> and instead of 'hylomorphism' we'll say 'sock'
13:31:58 <ehird> instead of monad, 'toaster'
13:31:59 <byorgey> and so on
13:32:04 <Cale> tieTYT: Okay, so you want to evaluate  reduce (+) 0 [2,3] ?
13:32:13 <dmwit> ehird: That is a work of art!
13:32:17 <ehird> byorgey: 'main' is a fridge. It is of type Oven ().
13:32:19 <tieTYT> where'd you get that 0?
13:32:26 <ehird> dmwit: Yes.
13:32:26 <byorgey> hehe
13:32:30 <olsner> hmm... isn't that what that bananas and barbed wire paper does? :P
13:32:39 <Cale> tieTYT: I figured that you'd have x = 0 as well :)
13:32:46 <tieTYT> right now it's reduce  f x [2, 3]
13:32:46 <Cale> tieTYT: Given that you have f = (+)
13:32:48 <Cale> okay
13:32:54 <Cale> well, that'll be fine too
13:32:54 * dolio starts the Meals for ndm foundation so that work on SuperO can progress.
13:33:02 <tieTYT> yes f = (+)
13:33:06 <Cale> So what does the definition of reduce for nonempty lists say?
13:33:12 <byorgey> olsner: hehe, well, except it uses banana *symbols* instead of actually writing 'banana'.
13:33:32 <Cale> reduce f x (y:ys) = f y (reduce f x ys), or some such, right?
13:33:37 <tieTYT> i think it was f a (reduce f x l)
13:33:39 <ehird> Cale: have you explained (...) syntax
13:33:48 <Cale> ehird: what syntax?
13:33:49 <ehird> tieTYT: Just a note - (+) a b is the same as a + b.
13:33:56 <tieTYT> k
13:33:58 <ehird> Cale: He might not know what (+) means.
13:34:00 <Cale> oh
13:34:08 <ehird> tieTYT: So, if you do 'f a b', and you want to do 'a+b'
13:34:12 <ehird> You can make f=(+)
13:34:16 <ehird> so '(+) a b', which is 'a + b'
13:34:20 <orbitz> what does let f x = f x in f 2 mean (i could be off since i've only seenr andome xampels here)
13:34:23 <tieTYT> yeah i remember that the first time i learned haskell
13:34:23 <ehird> It works for / too. (/). Any binary operator.
13:34:27 <ehird> tieTYT: ah ok :)
13:34:30 <Cale> orbitz: It means an infinite loop.
13:34:33 <tieTYT> i mean tried to learn
13:34:38 <orbitz> ok
13:34:38 <ehird> Cale: no it doesn't
13:34:45 <ehird> it means a non-terminating function
13:34:45 <ehird> ;)
13:35:00 <Cale> same thing.
13:35:00 <Saizan> ehird: ".. in f 2"
13:35:12 <ehird> Saizan: I know, but there's no such thing as a loop.
13:35:13 <Cale> If you want to be picky, its meaning is _|_
13:35:20 <ehird> Cale: I was going to say _|_ but I wasn't sure
13:35:40 <Cale> In other words, an infinite loop ;)
13:36:03 <dmwit> f x = f x -- f is now strict, great, I just added strictness to a lazy language!
13:36:21 <tieTYT> ok now i think I get it a little more
13:36:28 <Cale> tieTYT: So let's apply the definition
13:36:29 <tieTYT> (reduce f x l) does x + l first
13:36:43 <tieTYT> although, I don't realy know what x + [2,3] means
13:36:46 <Cale> return f x [2,3] = f 2 (reduce f x [3])
13:36:59 <Cale> no, it doesn't add the value to the list
13:37:02 <Cale> er
13:37:04 <ehird> by the way
13:37:06 <Cale> reduce f x [2,3] = f 2 (reduce f x [3])
13:37:06 <ehird> I had this idea yesterday
13:37:08 <tieTYT> oh
13:37:11 <schme2> ah cool. thanks. Now where do I look for finding out how to make error "day is whack!" pop up a wx window?
13:37:20 <ehird> if you have a special constructor - let's call it SeqSentinel
13:37:27 <ehird> this SeqSentinel is of _any_ type
13:37:34 <dmwit> schme2: MonadError
13:37:39 <ehird> that is, SeqSentinel :: Int, SeqSentinal :: IO ()
13:37:42 <tieTYT> Cale: how come you can do this: reduce f x [2,3] = f 2 (reduce f x [3])
13:37:44 <ehird> etc, they all work
13:37:47 <dmwit> schme2: Like (Either String).
13:37:48 <ehird> right?
13:37:50 <ehird> and now
13:37:52 <ehird> to write seq?
13:37:53 <Cale> tieTYT: actually, could you come to #haskell-overflow ?
13:37:56 <tieTYT> sure
13:38:00 <ehird> SeqSentinel `seq` a = a
13:38:03 <ehird> a `seq` b = b
13:38:07 <ehird> Tada!
13:38:08 <Cale> tieTYT: It's hard to follow this kind of discussion mixed in with everything else :)
13:38:09 <ehird> Tell me if I'm wrong.
13:38:18 <schme2> dmwit: oh seems like fun that there. ty!
13:39:00 <dmwit> Cale++ more patience than the rest of us =)
13:46:28 <twobitwork> is there a way to break data out of a constructor without using pattern matching?
13:46:39 <mauke> no
13:47:11 <mrd> use record syntax to automatically define accessors
13:47:27 <twobitwork> mrd: this is someone else's module
13:47:48 <byorgey> twobitwork: have they exported the constructors?
13:47:49 <mauke> if it doesn't export the constructors, you're out of luck
13:47:50 <mrd> no. and if the constructor is not exported, that's haskell's way of saying "no touchy"
13:47:59 <dmwit> twobitwork: Only if they have given you accessor functions.
13:48:03 <mauke> unless it's an instance of Data
13:48:32 <byorgey> unless it's an instance of Storable and you reverse-engineer the serialized format ;)
13:48:59 <sjanssen> or Show, for that matter
13:48:59 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
13:50:32 <sjanssen> @tell conal the trie code isn't on hackage, but we could put it there if you find it useful
13:50:32 <ehird> Hello again.
13:50:32 <lambdabot> Consider it noted.
13:50:46 <ehird> So. About my seq thing
13:50:47 <ehird> Is it right/
13:51:07 <sjanssen> what seq thing is this?
13:51:24 <sjanssen> oh, I see
13:51:29 <twobitwork> hmm... so I'm using this Yaml module... here, see if you can figure it out from the paste http://hpaste.org/7598 :)
13:51:40 <ehird> sjanssen: I mean, the SeqSentinel value is admittedly a bit magical
13:51:46 <ehird> but you could instead have a Wildcard value
13:51:57 <ehird> which is used whenever you need something like this (admittedly, not often)
13:52:00 <sjanssen> ehird: yes, that seems like it should work
13:52:02 <ehird> Hide it in WTFHC.Prim and you're all set.
13:52:04 <ehird> sjanssen: Cool!
13:52:09 <dmwit> Yes, SeqSentinel seems sufficiently magical to implement seq.
13:52:11 <ehird> I've gotta make a Haskell compiler that does that. :D
13:52:22 <sjanssen> if SeqSentinel existed (it can't really, because the only thing that has the type "forall a. a" is bottom)
13:52:23 <ehird> dmwit: It's pretty clever though, isn't it.
13:52:34 <ehird> sjanssen: You can put it in WTFHC.Prim, that is, make it primitive.
13:52:37 <dmwit> *shrug*
13:52:46 <ehird> It doesn't seem like making it primitive would take more than a few lines (OK, seq wouldn't either ;))
13:52:52 <dmwit> Implementing SeqSentinel in your compiler is likely to be just as much work as implementing seq.
13:52:55 <ehird> But like I said it could possibly have some other crazy use other than seq.
13:53:00 <ehird> So you'd call it Wildcard.
13:53:01 <sjanssen> ehird: SeqSentinel in a pattern is equivalent to !_ with the bang patterns extension
13:53:12 <ehird> sjanssen: Well, ! is just a nice way of saying 'seq'.
13:53:19 <sjanssen> ehird: I think SeqSentinel is more magical than seq
13:53:38 <ehird> sjanssen: But is Wildcard? I'm trying to think of another use for Wildcard. ;)
13:53:55 <sjanssen> ehird: how is Wildcard different?
13:54:19 <ehird> sjanssen: Not. Just what you'd call SeqSentinel if it wasn't just for seq.
13:54:30 <sjanssen> yeah, it is still magical
13:54:46 <ehird> sjanssen: But is there any non-seq use for it?
13:54:56 <sjanssen> ehird: what happens when I use Wildcard as an expression
13:55:28 <ehird> sjanssen: you get an ambigious type error
13:55:29 <dmwit> twobitwork: Try :i Yaml(Node|Element|Anchor) to see if they're instances of anything interesting.
13:55:32 <ehird> like the one you get with typeclasses
13:55:36 <sjanssen> ehird: Wildcard :: Int
13:55:44 <dmwit> twobitwork: Also, have a look to see if there are other modules with more accessor functions.
13:55:46 <ehird> sjanssen: 'Wildcard', I guess.
13:56:00 <sjanssen> ehird: how about show (Wildcard :: Int)
13:56:00 <ehird> And Wildcard + 1 gives a 'not defined for this' ala when you don't define it for typeclasses
13:56:07 <ehird> sjanssen: "Wildcard"
13:56:16 <dmwit> twobitwork: Also: it sure looks like that module is exporting the constructors.
13:56:21 <sjanssen> ehird: are you seeing why this is evil?
13:56:21 <ehird> sjanssen: Though, I may suggest it just erroring out.
13:56:25 <ehird> sjanssen: yeah
13:56:26 <ehird> so
13:56:29 <ehird> my thoughts are
13:56:37 <ehird> Wildcard just errors when you do anything with it
13:56:38 <ehird> :-)
13:56:49 <litb> so using arrows is superior than using monads?
13:57:06 <sjanssen> ehird: to make this sane, you have to ban Wildcard in expressions
13:57:06 <roconnor> is it possible to turn on some sort of aggresive CSE in GHC?
13:57:17 <dmwit> litb: Using Arrows is better when you're dealing with an Arrow; using Monads is better when you're dealing with a Monad.
13:57:18 <ehird> sjanssen: Okay then.
13:57:19 <dmwit> (As usual.)
13:57:26 <ehird> dmwit: MIND BLOWN
13:57:35 <litb> dmwit: lol
13:58:37 <dmwit> litb: Basically: some things can be expressed as Arrows, but not as Monads.  But as a result, you lose some of the nice properties of Monads.
13:59:15 <litb> oh
13:59:46 <ehird> blind-mowing
13:59:49 <ehird> My blind is now well-kept.
13:59:59 <litb> lol
14:00:00 <dmwit> This can be said about just about any A and B, where A is a generalization of B. ;-)
14:00:01 <gwern> strictures and structures / though they bind / strangely liberate the mind
14:00:14 <ehird> gwern: WHOA HASKELL POETRY AND HAIKU
14:00:15 <ehird> YES
14:00:17 <dmwit> gwern: Whoa, catchy, what's that from?
14:00:19 <ehird> oh my - haskell limericks
14:00:21 <sioraiocht> AHHHHHHHHHHHH
14:00:30 <litb> gwern: what is a stricture?
14:00:40 <dmwit> ?wn stricture
14:00:42 <lambdabot> *** "stricture" wn "WordNet (r) 2.0"
14:00:42 <lambdabot> stricture
14:00:42 <lambdabot>      n 1: abnormal narrowing of a bodily canal or passageway [syn: {stenosis}]
14:00:42 <lambdabot>      2: severe criticism
14:00:55 <mauke> perldoc strict
14:00:56 <dmwit> Similar to "restriction".
14:01:15 <litb> oh
14:01:40 <tromp> ?wn impregnate
14:01:41 <ehird> There once was a hacker much hazy / Who said to Haskell: "Too lazy!" / "You're much too slow, you're just a phase...y!" / And GHC responded: unsafePerformIOy.
14:01:41 <lambdabot> *** "impregnate" wn "WordNet (r) 2.0"
14:01:41 <lambdabot> impregnate
14:01:41 <lambdabot>      v 1: fill, as with a certain quality; "The heavy traffic
14:01:41 <lambdabot>           tinctures the air with carbon monoxide" [syn: {infuse},
14:01:41 <lambdabot>           {instill}, {tincture}]
14:01:43 <lambdabot> [5 @more lines]
14:01:46 <ehird> ^ WORST HASKELL LIMERICK EVER
14:01:56 <ehird> Especially because it doesn't make sense.
14:02:00 <gwern> dmwit: I am afraid I stole it from Douglas Hofstadter, who stole it from someone else
14:02:11 <litb> oh
14:02:17 <ehird> fill, as with a certain quality; "The heavy traffic tinctures the air with carbon monoxide"         <- is it just me or does this not contain 'impregnate'
14:02:33 <dmwit> gwern: That could join the ranks of "'Tenser!' said the tensor," I think. =)
14:02:38 <idnar> ehird: it contains "tincture", which is listed as a synonym ;)
14:02:44 <mauke> it's an anagram
14:03:10 <ehird> Anyone have a good Haskell limerick?
14:03:22 <ehird> There once was a hacker much hazy / Who said to Haskell: "Too lazy!" / <-- mine was good up to here
14:03:32 <idnar> There once was a Haskeller from #haskell / who decided that Haskell was too unwieldy a word to fit into a Limerick
14:03:39 <Vulpyne> http://www.haskell.org/haskellwiki/Humor/Limericks
14:03:40 <lambdabot> Title: Humor/Limericks - HaskellWiki
14:03:45 <tromp> a hacker much hazy already spoils it for me
14:03:53 <dmwit> Damn, Vulpyne beat me to it.
14:04:06 <Vulpyne> Not many there, though. :(
14:04:18 <litb> it's enough if you say "a hacker like litb" to insult haskell lol
14:04:19 <ehird> tromp: 'Unenlightened' don't sound too good.
14:04:19 <Vulpyne> Not exactly in normal limerick form, either.
14:05:01 <ehird> There once was a hacker -- collab time
14:05:34 <dmwit> This font has whitespace between the | and < of k. =/
14:06:03 <dmwit> http://haskell.org/haskellwiki/Humor/Poem
14:06:03 <lambdabot> Title: Humor/Poem - HaskellWiki
14:06:18 <ehird> OK, we need a haskell song then
14:06:25 <litb> dmwit: which font?
14:06:34 <dmwit> The one Firefox is using for Haskell.org.
14:06:45 <litb> oh
14:06:55 <litb> too bad
14:07:41 <dmwit> Heh, I like this one:
14:07:51 <litb> anyone of you calculated atan and atan2 before manually?
14:07:56 <dmwit> What did Goldilocks say when she saw a function :: Maybe (b -> Either a b) ?
14:07:57 <litb> i'm assigned to do that
14:07:59 <Vulpyne> Have you heard the lisp song?
14:08:07 <dmwit> litb: D=
14:08:10 <Vulpyne> http://www.modlost.net/home/music/programming/lisp-song.html
14:08:11 <lambdabot> Title: Abner Ballardo Urco Personal Page - Lisp Song
14:08:20 <dmwit> Answer: "It's Just Right!"
14:08:47 <litb> buto.O
14:08:55 <ehird> dmwit: Sgeo wrote that one.
14:09:00 <ehird> iirc.
14:09:28 <ehird> http://haskell.org/haskellwiki/?title=Humor/Goldilocks&action=history Yeah.
14:09:29 <lambdabot> Title: Humor/Goldilocks - History - HaskellWiki, http://tinyurl.com/693tur
14:09:37 <ehird> Sgeo knows just enough Haskell to know that joke, and no more.
14:09:55 <ehird> Well, just enough Haskell types. Code is a bit too much. :P
14:09:56 <sclv_> there once was a haskell coder / who was quite the linguistic promoter / till one day he spied / a lass on the imperative side / and at that point he cried / unsafe though she be, she sure revs my motor!
14:10:05 <Vulpyne> I'm going to try that one on my co-worker.
14:10:11 <ehird> sclv: isn't that a bit too long
14:10:16 <sclv_> yeah, well..
14:10:53 <ehird> sclv: you could remove the second-last line
14:11:15 <tibbe> how do I run a process and get its stdout as a String?
14:11:20 <sclv_> right, and the last becomes "unsafe, i'll grant, he said, but she sure revs my motor!"
14:11:24 <ehird> tibbe: you mean IO String right
14:11:31 <ehird> sclv: ok, that's worse
14:11:36 <ehird> write it from a first person perspective
14:11:40 <sclv_> well, you fix it then. :-P
14:11:41 <tibbe> ehird: of course
14:12:03 <ehird> Once I was a haskell coder / and quite the linguistic promoter / till one day I spied / a lass on the imperative side / unsafe though she be, she sure revved my motor!
14:12:07 <ehird> or something
14:12:34 <Vulpyne> http://www.haskell.org/ghc/docs/latest/html/libraries/process/System-Process.html -- You can read from the handle to get the process output.
14:12:36 <lambdabot> http://tinyurl.com/2uqkc5
14:12:41 <dmwit> ?hoogle runInteractiveCommand
14:12:42 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
14:12:57 <litb> uh
14:13:17 <dmwit> litb: What's up?
14:13:42 <litb> dmwit: i'm taking a beer now mate
14:13:43 <tibbe> Vulpyne: I guess I need to force the output as well?
14:13:53 <dmwit> =)
14:13:53 <Vulpyne> tibbe: Force the output?
14:14:01 <litb> tibbe: what does that mean?
14:14:10 <tibbe> Vulpyne: is it read lazily?
14:14:11 <litb> as i see it, you just get those three handles to stdin out and err
14:14:22 <dmwit> tibbe: Yes, it will be read lazily.
14:14:23 <Vulpyne> tibbe: Probably.
14:14:25 <dmwit> Is that a problem?
14:14:31 <ehird> so who's interested in my quite-functional haskell wiki? (functional as in the imperative/functional sense)
14:14:32 <tibbe> I need to waitForProcess
14:14:36 <ehird> it is made of wesome and love
14:14:41 <tibbe> for it to die and get cleaned up proberly
14:14:41 <ehird> *awesome
14:14:45 <ehird> and fastcgi
14:14:53 <sclv_> Haskell hacker joe schmoe / was fond of the unsafe IO / but with abandon so promiscuous / the denotation became quite ridiculous / until he decided, "I know, I'll just never call show!"
14:15:12 <vixey> @src foldl
14:15:13 <lambdabot> foldl f z []     = z
14:15:13 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:15:27 <Vulpyne> Well, you could read the whole stdout until EOF then wait for the process, then return the string.
14:15:32 <RayNbow> @src foldl'
14:15:32 <lambdabot> foldl' f a []     = a
14:15:32 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:15:40 <Vulpyne> Abstract it into getOutput :: String -> IO String if you wanted.
14:15:50 <Vulpyne> (Or probably Maybe or Either to catch errors.)
14:15:54 <dmwit> tibbe: That's what the ProcessHandle is for.
14:16:11 <dmwit> ?hoogle ProcessHandle
14:16:12 <lambdabot> System.Process.ProcessHandle :: data ProcessHandle
14:16:14 <tibbe> dmwit: yes but do I need to force stdout before I close it
14:16:26 <litb> what does "force" mean in this context?
14:16:28 <ehird> sclv: Win
14:16:43 <Vulpyne> If you read until EOF, lazyness won't matter.
14:16:50 <Vulpyne> If that is what you are worried about.
14:17:16 <litb> hmm
14:17:30 <litb> why not make these nasty imperative things with hsni ?
14:17:43 <litb> haskell scripting native interface ?
14:17:59 <litb> or doesn't that exist? i mean, it would be nice to write small snippets in c instead
14:18:02 <Vulpyne> What is that?
14:18:13 <dmwit> litb: It's called ffi instead of hsni.
14:18:18 <litb> oh
14:18:30 <dmwit> But really, it's hardly necessary.
14:18:42 <Vulpyne> Most of the time, writing the imperative stuff in Haskell isn't worse than writing it in an imperative language.
14:18:51 <mauke> I think it is necessary here because forkProcess is semibroken
14:19:04 <dmwit> I mean descending to C is hardly necessary.
14:19:12 <Valodim> umm... ok this compiler error is rather obvious, I still have no idea how to fix it:
14:19:12 <litb> mauke: oh is it broken?
14:19:12 <Valodim> Warning: This package indirectly depends on multiple versions of the same
14:19:12 <Valodim> package. This is highly likely to cause a compile failure.
14:19:12 <Valodim> package ghc-6.8.2 requires Cabal-1.2.3.0
14:19:12 <Valodim> package plugins-1.2 requires Cabal-1.5.1
14:19:14 <dmwit> It's perfectly possible to force the String in Haskell, and even easy.
14:19:28 <litb> too bad , that should not happen in production. why is such an important function broken in haskell?
14:19:49 <mauke> litb: the new process only contains the current thread
14:20:11 <mauke> I think the IO manager and GC run in their own thread
14:20:25 <mauke> which means the new process can't really do anything
14:20:46 <litb> oh
14:20:49 <Valodim> ...and the compiler fails with an ambiguity error, of course :|
14:21:12 <litb> i wonder how people are able to still fork and exec then
14:21:50 <Saizan> ambiguity? such inconsistent deps usually give a plain type error
14:21:54 <mauke> this might not apply when using the nonthreaded runtime
14:22:10 <litb> oh i see
14:22:24 <litb> but the single threaded one is slower on more cores?
14:22:30 <Valodim> so, uh, how to fix it? the cabal installed is the newer one
14:22:47 <sethk> mauke, I think (or perhaps thought) that if there is o/s support for threading the forked process does inherit threads
14:22:57 <litb> Valodim: apparently we should hope for a fix in the next haskell :/
14:23:07 <dcoutts> Valodim: do you mean you actually get a type error when you build?
14:23:09 <Valodim> so the plugins lib is just broken for now
14:23:33 <Valodim> let me paste the log
14:23:41 <dcoutts> @hpaste
14:23:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:23:45 <litb> sethk: with plain fork in c level threads are not inherited by all i know
14:23:48 <Valodim> I know :)
14:23:53 <Valodim> http://hpaste.org/7599
14:24:06 <litb> but i'm not sure
14:24:24 <litb> since it creates an exact copy... why doesn't it copy the theads. l
14:24:29 <dcoutts> Valodim: it will probably work if you compile it against Cabal-1.2.3.0 rather than 1.5.x
14:24:38 <Valodim> will try that
14:25:14 <Valodim> so basically it's just a missing <= dependency?
14:25:25 <dcoutts> Valodim: the problem is that plugins depends on Cabal-1.2.x but it probably only specifies build-depends: Cabal >= 1.2, when it should specify build-depends: Cabal >= 1.2 && < 1.3
14:25:34 <Valodim> yeah
14:25:44 <Valodim> well that does make sense then, at least :)
14:29:43 <ehird> Oh lawd, ghc won't let me do "ghc --make src/Foo.hs"
14:29:48 <ehird> if Foo.hs uses packages
14:29:50 <ehird> found in src/
14:29:57 <ehird> so if Foo.hs does "import Blah.Deblah", and I have src/Blah/Deblah.hs
14:30:00 <ehird> it won't recognize it
14:30:05 <ehird> I have to do the ghc --make from within src/
14:30:07 <ehird> what's up with that
14:32:08 <Cale> ehird: -i src
14:32:26 <Cale> iirc
14:32:51 <ehird> ah
14:33:15 <ehird>     Could not find module `src':
14:33:15 <ehird>       it is not a module in the current program, or in any known package.
14:33:17 <ehird> :D
14:33:59 <Saizan> -isrc maybe?
14:34:21 <ehird> ah
14:34:21 <ehird> yep
14:34:22 <ehird> :)
14:34:25 <ehird> thanks
14:37:48 <geezusfreeek> conal: just fyi, my gadt approach for futures works great, has pretty good memoization, and is pretty clean, but i think there is one major flaw that may just make it useless‚Ä¶ using the same future in two separate parts of the AST must always evaluate twice because there is no way i know of to check at runtime that they are the same (during the pre-execution stage where i convert the tree into a memoizable version)
14:38:10 <geezusfreeek> conal: i'm thinking this will be my last independent attempt and from here on i will just follow your work
14:38:40 <conal> geezusfreeek: thanks for the update
14:38:40 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
14:39:39 <ehird> @messages
14:39:39 <lambdabot> You don't have any new messages.
14:39:42 <ehird> ha
14:39:47 <ehird> :(
14:39:49 <ehird> @note ehird I wub joo
14:39:50 <lambdabot> usage: @vote <poll> <choice>
14:39:55 <ehird> ......
14:39:58 <geezusfreeek> lol
14:40:05 <ehird> Someone turn that crap off.
14:40:08 <Valodim> dcoutts: works with earlier cabal :)
14:40:10 <Valodim> thanks
14:41:04 <ari> Is the evaluation order of guards in list comprehensions defined somewhere? I'd prefer to do the cheaper checks in my complicated comprehension first...
14:41:28 <mauke> left to right
14:41:52 <ehird> ha
14:41:57 <ari> mauke: Ah, easy enough :)
14:45:54 <dolio> What does one do with bad ssh keys with regard to code.haskell.org?
14:46:28 <dcoutts> dolio: what do you mean exactly?
14:46:54 <dolio> Well, mine is weak evidently, so I should make a new one and get it on there, no?
14:47:05 <qwr> dolio: yes
14:47:05 <ehird> dcoutts: Debian just fixed a major security hole/.
14:47:11 <ehird> A lot of their entropy was deterministic.
14:47:15 <ehird> In openssl and others.
14:47:17 <ehird> For two years
14:47:22 <dcoutts> dolio: you mean you already have an account on code.h.o and you want to change your ssh key?
14:47:35 <dolio> Apparently I've lots the e-mail that would tell me who to send the new key to.
14:47:47 <ehird> dcoutts: sort of
14:47:49 <dolio> Lost, even.
14:47:52 <ehird> debian.org
14:47:54 <ehird> look at the openssl report
14:47:55 <ehird> and weep
14:48:32 <qwr> ehird: that one? http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=363516
14:48:34 <dcoutts> dolio: if you want to change your key, just log in with your old one and add the new one to the ~/.ssh/authorized_keys
14:48:35 <lambdabot> Title: #363516 - valgrind-clean the RNG - Debian Bug report logs
14:48:52 <dolio> Ah, that's easy, then.
14:49:12 <ehird> qwr: The one on the debian homepage.
14:49:19 <ehird> But that is the bug triggering it
14:49:47 <conal> geezusfreeek: i think i understand what you're getting at.  with an AST sort of rep that lacks visible sharing (e.g., some kind of 'let'), it's hard to recognize when something is referenced twice and avoid reinterpreting.
14:49:57 <geezusfreeek> conal: exactly
14:50:41 <geezusfreeek> conal: especially considering, for example, my FMap :: (a -> b) -> Future a -> Future b constructor
14:51:09 <geezusfreeek> i don't think it is possible to check that two functions are the same, even if they are literally from the same part of the source code
14:51:48 <ehird> <geezusfreeek> i don't think it is possible to check that two functions are the same, even if they are literally from the same part of the source code
14:51:49 <qwr> dolio: I deleted the old pubkeys too on some hosts (and keeped connection open while trying, that the new one works after that...)
14:51:49 <ehird> it is not
14:51:52 <ehird> Halting problem
14:52:19 <geezusfreeek> ehird: well, i mean things that are as simple as f = ‚Ä¶ and g = h
14:52:31 <geezusfreeek> err
14:52:33 <geezusfreeek> g = f
14:52:38 <mmnnbb> hi, i have this code : data Logic  = AND Bool | OR Bool , how can i convert it to match this : AND [Bool] | OR [Bool]
14:53:19 <qwr> dolio: basically, since the keyset seems to have been limited, there is probably possible to have bruteforce attack on the keyset
14:53:35 <conal> geezusfreeek: this gotcha is always a problem with embedded interpreters.  and with function-level programming in general, in which the functions get applied to the same argument twice, but the application is invisible.  e.g., "liftA (+) f f"
14:53:36 <geezusfreeek> ehird: more specifically, consider newtype SomeType a = SomeType a; f = SomeType id; g = SomeType id ‚Ä¶ can't tell that f and g are the same
14:54:21 <ehird> geezusfreeek: No. No you can't.
14:54:45 <geezusfreeek> even though on a purely lexical level, it is "obvious"
14:54:48 <conal> "lazy memo functions" work sometimes
14:54:57 <dmwit> mmnnbb: You can write it just as you have.
14:55:10 <dmwit> mmnnbb: i.e. data Logic = AND [Bool] | OR [Bool]
14:55:22 <dmwit> mmnnbb: But that's an awfully strange data type, why are you making it?
14:55:31 <dmwit> :t and
14:55:32 <dmwit> :t or
14:55:33 <lambdabot> [Bool] -> Bool
14:55:35 <lambdabot> [Bool] -> Bool
14:56:16 <mmnnbb> dmwit : i'm trying stuff
14:56:25 <Valodim> dons: might just be me, but fps-0.7 build fails saying Data.Array is hidden, but works when array is added to the dependency list
14:56:45 <dmwit> Valodim: Aren't you on 6.8 yet?
14:56:51 <Valodim> I am
14:56:59 <dmwit> fps became ByteString and got included in the standard library.
14:57:07 <Valodim> right, didn't say it didn't find it
14:57:15 <Valodim> it was just hidden because it wasn't listed in the dependencies in the cabal file
14:57:22 <dmwit> No, I mean, why are you building fps at all?
14:57:34 <Valodim> because lambdabot is for _some_ reason asking for it, I have no idea
14:57:56 <dcoutts> Valodim: use a more recent lambdabot then
14:58:00 <dcoutts> fps is ages old
14:58:12 <Valodim> the 'bot is the one from the darcs repository
14:58:26 <dcoutts> which darcs repo?
14:58:31 <Valodim> and it for some reason asked for the fps package only after I switched to the plugins cabal file
14:58:33 <Valodim> hum
14:58:39 <ari> Valodim: I think you should be using http://code.haskell.org/lambdabot/
14:58:39 <lambdabot> Title: Index of /lambdabot
14:58:56 <Valodim> I am
14:59:27 <Valodim> ...I think. let me verify
14:59:28 <dcoutts> well that one does not mention fps in its .cabal file
14:59:37 <roconnor> I wonder if I should try to go to Haskell 2008
14:59:58 <Valodim> last change from apr 27, 2008
15:00:29 <Valodim> yes it does
15:00:35 <Valodim> it's the lambdabot.cabal.plugin file
15:01:16 <dcoutts> Valodim: oh yes, so it does, well that's clearly rather old. I'd ignore it if I were you and use the ordinary .cabal file.
15:01:32 <Valodim> I see
15:10:20 <ehird> So what are the hip <foo> monad operators that maake do-notation totally unhip?
15:10:32 <ehird> People keep replacing my do-notation with them over irc.
15:10:32 <ehird> :P
15:10:55 <ddarius> return and (>>=)
15:11:13 <ehird> ddarius: Har de har har
15:11:18 <ehird> I've seen ones like <*> though.
15:11:20 <dmwit> ap
15:11:21 <ehird> And other weirdities
15:11:24 <dmwit> (>=>)
15:11:28 <dmwit> (=<<)
15:11:28 <ehird> dmwit: Okay it was funny once.
15:11:29 <ehird> :-)
15:11:46 <dmwit> Wait, no, I'm really answering your question.
15:12:03 <dmwit> You may also want to try :browse Control.Applicative
15:12:17 <ehird> dmwit: I'm saying things like <*>
15:12:21 <ehird> Always a symbol in <>
15:12:24 <dmwit> ehird: Just try it.
15:12:31 <TSC> @index (<*>)
15:12:32 <lambdabot> bzzt
15:12:34 <ehird> Alrighty. :P
15:12:47 <TSC> Look harder, stupid bot
15:12:55 <ddarius> @hoogle <*>
15:12:56 <lambdabot> Control.Applicative.(<*>) :: Applicative f => f (a -> b) -> f a -> f b
15:15:30 <samibbit> > let x = x in (+ x 1)
15:15:37 <lambdabot>  <Integer -> Integer>
15:15:49 <dmwit> Heh, that is a funny parse.
15:15:57 <samibbit> > let x = x in (x + 1)
15:16:01 <dmwit> > let x = x in x + 1 -- this will be more obvious
15:16:11 <ehird> <samibbit> > let x = x in (+ x 1) <-- how does THAT work?
15:16:12 <lambdabot>  thread killed
15:16:15 <ehird> > (+ 2 2)
15:16:16 <lambdabot>  thread killed
15:16:18 <lambdabot>   add an instance declaration for (Num (t -> a))
15:16:18 <dmwit> samibbit: (+ x 1) parses as ((+) (x 1))
15:16:22 <vixey> > let in 8
15:16:23 <lambdabot>  8
15:16:26 <ehird> dmwit: It doe?
15:16:28 <ehird> I didn't know that!
15:16:31 <dmwit> ehird: yes
15:16:31 <ehird> > (+ 2 2)
15:16:32 <lambdabot>   add an instance declaration for (Num (t -> a))
15:16:36 <ehird> oh
15:16:37 <ehird> I see!
15:16:39 <ehird> > (+ id 2)
15:16:40 <lambdabot>  <Integer -> Integer>
15:16:42 <ehird> Cute.
15:16:45 <dmwit> ehird: Actually, it's more accurately (flip (+) (x 1)), but yeah.
15:16:51 <ehird> Could we make a hack to satisfy the lisp programmers somehow, dmwit?
15:16:59 <dmwit> Liskell?
15:17:01 <samibbit> i was just confused with lisp
15:17:17 <ehird> dmwit: I mean actually inside haskell
15:17:20 <samibbit> > (((+) 1) 2)
15:17:21 <lambdabot>  3
15:17:28 <ehird> > (+) 1 2
15:17:29 <lambdabot>  3
15:17:40 <ehird> oh, I see how (+ x 1) works now
15:17:46 <ehird> it's like (+ 1)
15:17:50 <ehird> but with an application
15:17:52 <ehird> to confuse you
15:17:52 <dmwit> right
15:18:08 <ehird> dmwit: my brain went into lisp mode
15:18:08 <ehird> :-)
15:18:41 <samibbit> oh i get it too.
15:19:08 <dmwit> Yeah, the confusing bit is that (x) isn't usually the name of a function.
15:19:11 <samibbit> > let x = id in (+ x 1) 1
15:19:13 <lambdabot>  2
15:19:27 <dmwit> If you had written (+ f 1) you would have probably seen it instantly.
15:19:30 <wjt> @pl (\a b c -> f (g a b c))
15:19:30 <lambdabot> ((f .) .) . g
15:19:44 <wjt> i wish that doing that for n arguments were neater
15:20:01 <dmwit> Yeah, I used to wish that, too.
15:20:19 <wjt> and then?
15:20:21 <dmwit> But you get used to it, and then you appreciate it when you have to actually *read* code.
15:20:27 <vixey> > let ... f = (((f .) .) .) in ... g :: Expr
15:20:28 <lambdabot>  Parse error at "..." (column 5)
15:20:59 <dmwit> > let (...) f = (((f .) .) .) in (g ...) :: Expr
15:21:00 <lambdabot>  Couldn't match expected type `Expr'
15:21:06 <dmwit> > let (...) f = (((f .) .) .) in (g ...)
15:21:07 <lambdabot>  Add a type signature
15:21:22 <dmwit> > let (...) f = (((f .) .) .) in (g ...) :: Expr -> Expr -> Expr -> Expr
15:21:22 <lambdabot>  Couldn't match expected type `Expr'
15:21:25 <dmwit> whatever
15:22:01 <ehird> > let (...) f = (((f .) .) .) in (x ...)
15:22:01 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Expr'
15:22:04 <ehird> > let (...) f = (((f .) .) .) in (id ...)
15:22:04 <lambdabot>  Add a type signature
15:22:06 <wjt> Fuse has a record with a bunch of a -> ... -> IO x callbacks; i want my implementations to be in my own transformed monad, so I'm swaddling them all in run :: MyMonad a -> IO a.  But .. lots of dots :(
15:22:09 <ehird> eh.
15:22:19 <ehird> wjt: Awwwh.
15:22:30 <ehird> try:
15:22:32 * wjt is using a bunch of lambdas
15:22:51 <ehird> ioBridge :: IO a -> MyMonad a
15:22:56 <ehird> and then just things like
15:23:01 <samibbit> liftIO
15:23:02 <ehird> ioBridge (magicFuseThingy "blah")
15:23:07 <ehird> samibbit: well, ye.
15:23:12 <ehird> I was assuming this wouldn't work in this case
15:23:34 <ehird> what we really need is a cool containing system
15:23:38 <ehird> and we get things like
15:23:53 <ehird> putStrLn :: m `Contains` IO => String -> m ()
15:24:09 <wjt> it's the other way around
15:24:31 <ehird> wjt: ohhh I see
15:24:32 <ehird> then
15:24:37 <ehird> just
15:24:39 <ehird> return?
15:24:39 <ehird> :-)
15:24:42 <ehird> well
15:24:44 <ehird> run . return
15:24:52 <ehird> I see where you're coming from now
15:24:57 <wjt> you must get through enter keys at an alarming rate
15:25:11 <ehird> wjt: totally
15:25:20 <ehird> people keep hatin' on my freestylin' train-of-thought style
15:25:26 <ehird> and I just talk silly in response
15:25:27 <ehird> oh, wait.
15:26:08 <dmwit> wjt: You may be interested in MonadIO, or whatever it's called.  With a proper instance, you can just liftIO, as samibbit said.
15:26:09 <dmwit> :t liftIO
15:26:12 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
15:26:19 <wjt> What this actually needs is for one entry of the record of callbacks the application supplies to Fuse to be 'runAction :: Monad m => m a -> IO a'
15:26:19 <dmwit> Yup, MonadIO.
15:26:34 <dmwit> oh
15:26:36 <ehird> dmwit: It's the OTHER WAY AROUND
15:26:43 <wjt> so that you can implement the Fuse callbacks in whatever monad you want, and then just tell it how to run 'em
15:26:44 <ehird> which he just said ;)
15:26:47 <dmwit> Okay, sorry, I wasn't paying attention.
15:27:25 <mmnnbb> how can i declare a type that the list supplied can be a mix of Int and Bools? for example something like this : data LogicBool  = AND [Int|Bool] | OR [Int|Bool]   (incorrect but this is what i want)
15:27:36 <edward1> @seen dolio
15:27:36 <lambdabot> dolio is in #haskell-blah and #haskell. I last heard dolio speak 38m 44s ago.
15:27:37 <dmwit> mmnnbb: Either
15:27:56 <dolio> Eh?
15:28:12 <dmwit> wjt: But, you only need lots of dots once, right?
15:28:17 <edward1> dolio: just checked the syntax for total families doesn't work yet in head ;)
15:28:20 <wjt> dmwit: yes
15:28:24 <dmwit> ok
15:28:26 <wjt> well, once for each callback
15:28:28 <edward1> was just tring to see if it would even be syntactically legal yet ;)
15:28:32 <dolio> Ah, yeah, I figured.
15:28:52 * Botje would like to do a thesis about haskell but has noone to help :(
15:28:57 <mmnnbb> dmwit: how is this used in the declaration?
15:29:37 <dmwit> Either has kind * -> * -> *, and Either a b is a type than can have values of type "a" or type "b".
15:29:43 <edward1> dolio: one thought it so 'tag' non integer results some how so they can still be quantified but be quantified in a box so that i can use the existing machinery
15:29:55 <mmnnbb> dmwit: thanx
15:29:56 <dons> Botje: what country are you in?
15:29:56 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
15:30:03 <Botje> dons: .be
15:30:12 <dons> move to utrecht?
15:30:52 <Botje> can't quite do that yet :p
15:30:53 <dons> dolio: do I read correctly that uvector outperformed ST?
15:31:02 <edward1> dolio: i.e. in addition to 'Const' to define 'Var' and have Var take a functor, then define addition for Zero :+: Var x, Var x :+: Zero, etc.
15:31:34 <dons> dolio: that's awesome. thanks.
15:31:45 <dolio> dons: Yeah, but I don't think it's the ST portion that's slower, it's the list stuff afterwards.
15:31:56 <dons> yep. and the fact you're not using lists :)
15:32:04 <dons> so the key is to have filter / zip on arrays?
15:32:27 <dons> this is how i imagine uvector use, fwiw, swtiching between the frozen and unfrozen forms
15:32:34 <edward1> then Zero = Const Void, and the rest of the integers 'Succ (Succ (... Succ f)...)' would form a module-like construction over the more interesting parts of the functor.
15:32:43 <dons> dolio: any other thoughts?
15:32:51 <dolio> dons: Incidentally, is there no way to create a MUArr initialized to some single value?
15:33:13 <dons> dolio: only by filling it yourself.
15:33:22 <dons> but we can do a better job there with a primitive fill
15:33:28 <dons> ocaml and stuarray's provide that
15:33:33 <dolio> Ah. yeah, adding that would be nice.
15:33:48 <dons> how'd you compile it?
15:34:24 <dolio> ghc --make -O2 Tetration.hs
15:37:56 <ehird> @hoogle Char ->String->String
15:37:57 <lambdabot> No matches, try a more general search
15:38:05 <ehird> :(
15:38:27 <samibbit> > 'a' : "hello"
15:38:29 <lambdabot>  "ahello"
15:38:34 <ehird> I wanna strip all the leading chars of a certain kind in a string
15:38:39 <ehird> samibbit: Remove not add.
15:38:45 <ehird> strippy '/' "///abc" -> "abc"
15:38:53 <ehird> aha wait
15:38:54 <ehird> never mind
15:39:10 <samibbit> that can be hard.
15:40:21 <wjt> @pl \x -> f <$> m x
15:40:22 <lambdabot> (f <$>) . m
15:40:30 <wjt> @pl \x -> m x >>= return . f
15:40:30 <lambdabot> (f `fmap`) . m
15:41:55 <dmwit> > dropWhile (=='/') "///abc"
15:41:56 <lambdabot>  "abc"
15:42:51 <dons> dolio: we may be able to do a bit better there too
15:46:25 <samibbit> > dropWhile (== '/') "//a/b//" == "a/b"
15:46:27 <lambdabot>  False
15:47:41 <dmwit> heh
15:47:52 <dmwit> Tupping space segments.
15:48:25 <koninkje> > dropWhile (== '/') "//a/b//" == "a/b//"
15:48:27 <lambdabot>  True
15:48:33 <dmwit> Oh wait, I just read that wrong.
15:48:58 <dmwit> > dropWhile (== '\\') "\\a/b\ \"
15:49:00 <lambdabot>  "a/b"
15:49:09 <dmwit> Surprise!
15:50:19 <dmwit> > dropWhile (== '/') "/ / \ \ / / \ \"
15:50:20 <lambdabot>  " /  / / "
15:52:38 <mmnnbb> i still can't get it to work.. i need 'logic' to be able to hold patterns like that : (AND [1,True,False,3,3]),(OR [0,True,1,3])  .    data Logic  = AND [Int] | OR [Int]  , how can i add the bool type?
15:53:16 <dmwit> s/Int/Either Bool Int/g
15:53:27 <dmwit> Then use "Left True" and "Right 1", etc.
15:53:57 <mmnnbb> there is no way to avoid left and right?
15:54:14 <samibbit> > fromRight (Right 1)
15:54:15 <lambdabot>   Not in scope: `fromRight'
15:54:18 <dmwit> Well, you can write your own data type, but you'll still have to have constructor tags.
15:54:31 <dmwit> They'll just have a different name than Left and Right. ;-)
15:54:42 <sjanssen> mmnnbb: True and False aren't Int, what do you expect that bit of code to mean?
15:54:51 <mmnnbb> i see
15:55:17 <samibbit> data IntBool = Int :- | Bool :=   -- would this work?
15:55:22 <mmnnbb> sjanssen: i want to be able to have this types
15:55:36 <samibbit> [:-1, :=True]
15:55:41 <dmwit> samibbit: Maybe, with appropriate parentheses.
15:55:52 <dmwit> data IntBool = (Int :-) | (Bool :=)
15:56:01 <Cale> samibbit: that second line wouldn't though
15:56:13 <dmwit> [(1 :-), (True :=)]
15:56:17 <Cale> It would be either (:-) 1, or (1 :-)
15:56:28 <chessguy> those are some happy data types :)
15:56:33 <dmwit> I like the idea of having :-) sprinkled through the code, though. =)
15:56:57 <ehird> :-)
15:58:50 <samibbit> args smilies on this irc client
16:00:34 <ehird> :-)
16:04:35 <roconnor> :-)
16:04:38 <ddarius> @where ffi
16:04:39 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
16:05:32 <roconnor> is there an ffi ligature?
16:05:44 <Botje> yes
16:06:10 <roconnor> Ô¨É
16:06:15 <roconnor> @where Ô¨É
16:06:15 <lambdabot> I know nothing about Ô¨É.
16:06:59 <ehird> hahah
16:07:57 <tieTYT> do most of you guys have jobs where the primary language is haskell?
16:08:06 <Corun> Research
16:08:10 <Corun> Oh
16:08:15 <Corun> I misread that
16:08:20 <Corun> <_<
16:08:34 <Corun> Who says we even have jobs? :-P
16:08:42 * Botje doesn't have a job .. :p
16:08:44 <roconnor> tieTYT: Nah, I'm forced to use Coq most of the time.
16:09:43 <tieTYT> none of you use OO languages as a main job?
16:10:29 <dons> tieTYT: yeah.
16:10:52 <tieTYT> dons: do you find ways to use haskell at work?
16:10:55 <dons> i mean, yeah, haskell's a primary language.
16:10:59 <tieTYT> oh
16:10:59 <dons> well, we only use haskell.
16:11:03 <dons> oh, some ocaml
16:11:11 <dons> for legacy stuff
16:11:24 <dolio> dons: FYI: uvector seems to be slightly slower than ST for nsieve bits.
16:11:25 <JamesR> Anyone up for throwing some advice my way?
16:11:36 <dons> dolio: so it should be slightly slower due to the 'fill'
16:11:44 <dolio> Yeah.
16:11:56 <dons> which is a primitive in STUarrays
16:12:12 <dolio> Although, if you do a freeze and sum over the UArray vs. the UArr, I think uvector wins.
16:12:55 <dmwit> JamesR: Just ask.
16:13:12 <dons> dolio: so it looks like it should almost all fuse away
16:13:21 <ehird> Should I use HStringTemplate or Text.XHtml?
16:13:31 <dons> foldlU . zip . map . filter . takeWhile . psieve
16:13:41 <JamesR> I'm trying to put my question into words ... I'm staring at an assignment without the faintest clue on how to start it
16:13:44 <dons> oh, we might need to write psieve as a stream producer
16:14:09 <JamesR> Make a Haskell Music Store - Using datatypes for Tracks / Catalogue / Playlist.
16:14:13 <dons> dolio: thanks for digging around in this. pity haddock won't grok type families yet
16:14:16 * JamesR thinks it's jibberish
16:14:29 <dons> JamesR: it means, define a dats structure that stores those things
16:14:56 <ehird> nobody?
16:15:05 <ehird> I kinda have to go soon so unjustified opinions are welcome
16:15:05 <ehird> ;)
16:15:17 * dcoutts debugs his new cabal-install dep resolver...
16:16:40 <dolio> dons: If you can rewrite psieve as a stream, that'd be great. I'm not sure how to do an efficient sieve on a stream.
16:16:51 <dons> dolio: yeah.
16:16:54 <dons> i don't know either
16:16:59 <dolio> Anyhow, I'm off to dinner.
16:18:00 <geezusfreeek> don't most sieves require an upper bound to be at all efficient?
16:18:21 * tieTYT installs ghc
16:18:58 <tieTYT> maybe i'll make some useful program in haskell for my company.  Being the only one who would know it, that should ensure my job security
16:19:03 <tieTYT> great success
16:19:19 <ivanm> tieTYT: or they could just rewrite it in blub... :p
16:19:40 <geezusfreeek> tieTYT: or they could learn that haskell programmers are so efficient and hire more!
16:20:11 <tieTYT> geezusfreeek: naw, my boss is a java programmer (like me)
16:20:18 <geezusfreeek> aw :(
16:20:26 <tieTYT> he won't feel comfortable hiring people using a language he doesn't understand
16:20:38 <ttmrichter> tieTYT: If you're motivated to learn Haskell, you're not "just a Java programmer".
16:20:54 <monochrom> hi hi, just to be sure, ghc -O2 -ddump-simpl is the recommended way of looking at low-level code, right?
16:21:07 <dons> monochrom: well, yes. but I'd use the ghc-core program
16:21:09 <geezusfreeek> monochrom: there is also ghc-core now
16:21:15 <dons> which colourises, cleans it up, and displays it in a pager
16:21:19 <tieTYT> ttmrichter: well i donno how motivated i am yet
16:21:37 <tieTYT> i'll likely give up soon
16:21:45 <monochrom> thanks. whee!
16:21:47 <tieTYT> but probably try again after that
16:21:54 <ttmrichter> Wait until the publication of "Real World Haskell" before giving up.  ;)
16:22:02 <ttmrichter> It's shaping up to be a REALLY nice book.
16:22:15 <tieTYT> i'm reading the beta right now
16:22:27 <ttmrichter> I'm not one to talk, mind.  I've been Haskell on and off learning-wise for almost ten years now.  :D
16:22:45 <ttmrichter> But I've been stuck in the on position now for about two, so it finally clicked.
16:23:35 <tieTYT> working with it 8+ hours a day helps i bet :)
16:24:15 <dmwit> No, it hurts.
16:24:22 <dmwit> By that point, you start seeing warts. =)
16:24:41 <tieTYT> i'm writing this blog article right now.  I wish I could have people write 8 comments on every one of my paragraphs like in this book
16:25:34 <proq> tieTYT: there's always time to hack haskell when you're not at work  :)
16:25:42 <ehird> tieTYT: there's a wordpress plugin
16:25:54 <tieTYT> and, at my job, even when you're at work!
16:26:10 <JamesR> Is there any advantage to creating this Media store using Haskell over Python? The OO aspects of Python strike me as a far more suitable language for the task
16:26:13 <tieTYT> ehird: but from a "PR" stand point, I don't want to make it public
16:26:24 <proq> tieTYT: also, I'm motivated to get my tasks done sooner knowing I can do some haskell skunkworks afterwards
16:26:28 <tieTYT> ehird: so it's a catch 22
16:26:41 <tieTYT> proq: yep
16:27:28 <ehird> tieTYT: but if you have comments already
16:27:29 <ehird> just add that
16:27:59 <dmwit> JamesR: Probably not a whole lot of readily observable advantages.
16:28:17 <proq> dmwit: I find warts on everything. it's the ass principle
16:28:46 <dmwit> JamesR: But I think you will find that the mentality of immutability will grow on you, and even start invading your coding style in other languages.
16:29:37 <JamesR> I have 14.5 hours between now and the deadline to do this <_<
16:29:46 <JamesR> It's a nerdy race against time
16:29:55 * JamesR puts on headcrab
16:30:50 * proq gets his gravity gun
16:30:55 <geezusfreeek> tieTYT: 'but from a "PR" stand point, I don't want to make it public' ‚Ä¶ surprise! this channel is constantly logged and made available on the web
16:31:02 <ddarius> JamesR: I suspect the advantage of writing it in Haskell would be getting a passing grade on the assignment.
16:31:12 <JamesR> ddarius: Well said
16:31:24 <tieTYT> geezusfreeek: does the logging somehow magically know what my blog article's content is?
16:31:41 <JamesR> ddarius: Its 60% Haskell 40% Python. The Python took me a few hours, the Haskell will likely take me every minute I have
16:31:44 <geezusfreeek> well‚Ä¶ only if you link it and somebody follows the link ;)
16:31:55 <proq> tieTYT: of course, it uses powerset
16:31:57 <tieTYT> then i'm safe
16:32:58 <geezusfreeek> tieTYT: i think i had misunderstood
16:33:04 <geezusfreeek> so nevermind
16:33:40 <ttmrichter> dmwit: You've hit it on the head.  I'm likely to never wind up using Haskell in real work (more's the pity), but what I learned from using it invades everything else I do nowadays.
16:34:41 <noecksit> hello, is there a guide or some source code I can follow on writing network applications using haskell?
16:34:55 <ddarius> Needs more anamorphism
16:36:13 <ttmrichter> noecksit: Someone wrote a tutorial on making an IRC bot (dons, was it?).  You could track that down.
16:36:28 <tieTYT> ttmrichter: is that for the best?
16:36:54 <tieTYT> cause there are people in the #java channel that learn a functional language then try to make Java a functional language.  The results are always shit and confusing to anyone else that has to maintain it i bet
16:37:11 <SamB> tieTYT: guess who's fault that is?
16:37:11 <noecksit> ttmrichter : oh, i saw that, i was hoping for something more concise
16:37:18 <tieTYT> SamB: those developers
16:37:24 <vixey> that's the same for any language...
16:37:43 <ttmrichter> tieTYT: One of the big things I learned from my first stab at trying Haskell way back when was to stop making mutable objects.
16:37:50 <SamB> I was kinda thinking it was the people who made Java so ... Java
16:38:12 <tieTYT> SamB: I wouldn't say that
16:38:24 <ttmrichter> My C++ string wrappers didn't mutate in-place anymore.  I did copy-on-write semantics so I didn't wind up surprising myself (or having my clients surprise themselves, more accurately) with the way things worked behind the scenes.
16:38:27 <tieTYT> ttmrichter: yeah that's generally good
16:38:39 <ttmrichter> I learned that from Haskell.
16:38:51 <ttmrichter> I learned the value of making higher-level abstractions.
16:39:10 <SamB> even Python doesn't let you mutate strings...
16:39:15 <ttmrichter> Before Haskell I hardly ever used C++ functionoids/functors (same name, different concept entirely, from the Haskell functor).
16:39:17 <tieTYT> like implementing a map/foldl in your language of choice?
16:39:25 <ttmrichter> Exactly.
16:39:32 <tieTYT> ttmrichter: that's the part that usually looks like crap
16:39:33 <ttmrichter> Maps and folds started to show up in my work.
16:39:40 <tieTYT> and is hard to maintain, IMO
16:39:53 <ttmrichter> Meh, C++ is more expressive in this regard than Java.
16:39:54 <SamB> doesn't C++ already have maps and folds?
16:39:57 <tieTYT> at least in Java, there's no anonymous functions (or whatever)
16:40:11 <Cale> Well, usually better a fold than writing the same loop over and over and sometimes getting it wrong.
16:40:12 <tieTYT> ok that may make it a different situation then
16:40:13 <SamB> yeah they have those lousy inner classes instead
16:40:32 * SamB was thinking maybe STL had disguised maps and folds?
16:40:33 <tieTYT> Cale: if it's really the same, then put it in its own method.  You don't have to repeat yourself either way
16:40:37 <SamB> or possibly boost::?
16:40:40 <ttmrichter> You have anonymous classes in Java that you can use kinda/sorta like anonymous functions, but yeah, Java sucks for some of this.  I don't do Java, though, so it's not a problem for me.
16:40:49 <Cale> tieTYT: The loop body might be different, but how it iterates is the same.
16:40:52 <Pseudonym> I reckon that learning Haskell before learning C++ is a good thing, BTW.
16:40:57 <Pseudonym> It makes for far, far better C++.
16:41:00 <ttmrichter> What Cale said.
16:41:12 <ttmrichter> Patterns don't always have exactly the same bodies.
16:41:15 <tieTYT> ttmrichter: ok then I probably can't comment on your choice to do it.  But IMO, trying to do it in Java isn't pretty
16:41:15 * Pseudonym learned Miranda before learning C++
16:41:38 <ttmrichter> I learned a Lisp before C++, does that count?
16:41:46 <ttmrichter> I hated Lisp, though, so didn't internalize anything.
16:41:52 <SamB> hmm, btw, isn't the "visitor" pattern basically a description of folds?
16:41:54 <ttmrichter> So it really didn't inform my coding style.
16:41:57 <Pseudonym> Nah, I think you need to learn about abstraction and typing.
16:42:07 <Cale> SamB: yeah, pretty close to it
16:42:20 <ttmrichter> Visitors are folds with anemia.  :)
16:42:34 <ttmrichter> Anemia combined with elephantisis.
16:43:01 <SamB> hmm, that must work better with generics...
16:43:13 <tieTYT> i really don't see the comparison between folds and visitor
16:43:18 <Pseudonym> I do.
16:43:31 <tieTYT> although i get the comparision between visitor and elephantitis
16:43:33 <Pseudonym> It's a very good analogy.
16:43:39 <SamB> see, I am fortunate enough to have never actually had to use Java for anything ;-)
16:43:47 <ttmrichter> Visitor is an object passed into a collection one element at a time that has a specific method called on it each time.
16:44:00 <ttmrichter> Folds just get rid of the unnecessary object verbiage around the method.
16:44:20 <ttmrichter> I'm with you, SamB.  Never had to use Java in anger.
16:44:23 <tieTYT> ok i think i see it now
16:44:36 <tieTYT> one thing nice about java is the huge library for it
16:44:36 <Pseudonym> Yeah, that's really the problem with Simula-like OO languages.  They do have a lot of extraneous syntax.
16:44:37 <ttmrichter> And trust me: all my Java-using friends right now?  Anger is the right word.  :D
16:44:46 <dcoutts> woo! my new dep resolver can construct a plan for xmonad
16:44:53 <tieTYT> i happen to like java, that's just me
16:45:05 <Pseudonym> You can get part of the way there with a really good template library.
16:45:05 <SamB> tieTYT: how do you do it ?
16:45:07 <tieTYT> and no, i don't think it's perfect
16:45:14 <tieTYT> SamB: like it?
16:45:18 <SamB> yes, how?
16:45:20 <Nafai> ttmrichter: Lucky!  I'm almost done with using Java in anger....only to be using Python in anger
16:45:31 <Pseudonym> I was too scared to write a STL-compliant iterator before the relevant Boost library was written.
16:45:33 <tieTYT> i donno, i'm familiar with it and I like all the support and community it has
16:45:38 <ttmrichter> tieTYT: The huge library is a combination of things.  It is a blessing -- if you're using Java.  It is, however, also a big indicator of just how inexpressive Java is as a language.
16:45:42 <SamB> Nafai: which is the greater anger?
16:45:54 <tieTYT> ttmrichter: i don't see how it's an indicator of that at all
16:45:58 <ttmrichter> There are things in the Java library that exist solely because Java itself lacks abstraction capabilities.
16:46:09 <chessguy> hey, folks, i've been playing with a rose tree zipper that was implemented in yi, and ran across this snippet: http://hpaste.org/7604
16:46:20 <Pseudonym> ttmrichter: BTW, that's also partly true of Haskell.
16:46:23 <chessguy> what's this 'traverse' function he's talking about?
16:46:33 <Pseudonym> Some libraries exist because Haskell doesn't have native arrays or mutable global state.
16:46:37 <tieTYT> i don't think they're related.  There's libraries because people don't want to reinvent the wheel
16:46:38 <SamB> Pseudonym: do you think that's why they are rolling boost:: into the standard?
16:46:47 <ttmrichter> I would wager that if I went over Java with a fine-toothed comb I could eliminate half the standard library by just having closures.
16:46:49 <Pseudonym> SamB: That's part of it.
16:46:49 <tieTYT> if I could avoid writing a function, I will
16:47:14 <Pseudonym> Boost was founded by standards committee members as a testing ground for new additions to the standard.
16:47:27 <JamesR> Its got me and my pals stumped, anyone: http://hpaste.org/7603
16:47:29 <tieTYT> ttmrichter: perhaps.  Or maybe tha'd just be true for the collections framework
16:47:40 <Pseudonym> Some of the stuff in it won't end up in the standard, but that's the nature of the beast.
16:47:43 * qwr codes java somewhat like a people code brainfuck - as exercise how to write working code with some abstractions in a language, that don't seem to want to support those abstractions...
16:47:47 <SamB> tieTYT: I will only do it if the effort of writing the code is greater than the effort of getting the library going
16:48:05 <JamesR> How can I have a type mismatch when i'm trying to add a dtype Track to the end of an Array of Tracks? O.o
16:48:13 <Cale> JamesR: xs in addTC is not a list, it's a Catalogue
16:48:20 <tieTYT> SamB: when you consider that effort, you gotta consider the effort the other guy put into solving bugs you may not have thought of
16:48:21 <Nafai> SamB: Don't know yet, it's been a while since I've done anything serious with Python :)
16:48:35 <Cale> JamesR: You need to pattern match away the Catalogue constructor.
16:48:36 <tieTYT> and when you consider that, you rarely write it yourself
16:48:39 <tieTYT> at least in my experience
16:48:56 <tieTYT> and that's cause I don't know what I haven't thought of, and I don't want to waste time thinking of it :)
16:49:00 <Cale> JamesR: and then put it back when you're done with the list manipulation to turn the list of tracks into a Catalogue
16:49:06 <SamB> tieTYT: depends on how many bugs there could be in the function
16:49:25 <SamB> i.e. how many places there are for bugs to hide
16:49:32 <Cale> JamesR: So it'll look something like:  addTC tr (Catalogue xs) = Catalogue (xs ++ [tr])
16:50:00 * JamesR is speechless
16:50:13 <ttmrichter> tieTYT: in the security field at least, the developers of Java libraries tend not to think far enough, actually.  A buddy of mine is the security primo for a sizable company that has decided "all will be Java".  He's basically had to reinvent the security framework from scratch because the frameworks that exist out there were very badly thought outu.
16:50:24 <Cale> JamesR: It may also be worth noting that (xs ++ ys) takes O(length xs) steps to fully evaluate. Adding things to the front of a list is faster, if it doesn't matter what order they're in.
16:50:55 <Cale> (but it might matter here)
16:50:55 <ttmrichter> And if the order does matter, add to the front anyway and reverse the ensuing list when you're done.
16:51:13 <tieTYT> ttmrichter: that sounds related to the framework that was chosen
16:51:17 <Cale> If the lists aren't so long, it's not a big deal.
16:51:25 <ttmrichter> Not "the framework".  Pretty much most frameworks.
16:51:30 <JamesR> Cale: Sadly it's specified they must go on the end
16:51:39 <Cale> JamesR: Okay, then that's fine.
16:51:40 <ttmrichter> A lot of people write "security" software without being inundated with the culture.
16:53:49 <tieTYT> i donno what that means but it sounds a little ridiculous to think that any java security framework would be naturally flawed yet the same programmers, using haskell would magically make something secure
16:53:54 <tieTYT> sounds like a people problem to me
16:55:17 <qwr> tieTYT: at the same time it shows, that Java has achieved some of its goals - too well
16:55:22 <ttmrichter> tieTYT: That's not what I was saying.
16:55:22 <tieTYT> plus, it's strange that you say "Pretty much most frameworks".  How many java frameworks have you used?  I thought you said you're not a java programmer
16:55:25 <vixey> yeah java bytecode get's verified everything is type safe
16:55:40 * ttmrichter points to the "buddy of mine who's a security primo at ...."
16:55:58 <ttmrichter> I worked with this guy for years before I dumped the high tech world.
16:56:16 <ttmrichter> Just in time, it appears, given that his job satisfaction went into the toilet at about the same time that Java took over the world.
16:56:57 <qwr> tieTYT: (i'm referencing to the java goal being a language for masses)
16:57:00 <ttmrichter> But what I was saying wasn't that Haskell would make it better in this regard.  I was pointing out the flaw in your "I'll trust the guy who wrote the framework" reasoning.
16:57:19 <ttmrichter> The frameworks often have a myriad of bugs in them, lurking concealed.
16:57:29 <ttmrichter> And the more verbose the language, the more such lurking bugs are going to be there.
16:57:38 <tieTYT> it's better than the "i'll reinvent the wheel because it seems simple" reasoning IMHO
16:58:09 <tieTYT> well, i don't pretend to think that if I made my own framework i'd have LESS bugs
16:58:30 <tieTYT> but maybe that's my failing
17:00:08 <chessguy> anybody know where i can learn more about this 'structural calculation' stuff, mentioned here? http://en.wikibooks.org/wiki/Haskell/Zippers#Mechanical_Differentiation
17:00:08 <lambdabot> http://tinyurl.com/3cauba
17:00:47 <chessguy> it references a non-existent page in the wiki :(
17:02:00 <roconnor> chessguy: http://citeseer.ist.psu.edu/472190.html ?
17:02:02 <lambdabot> Title: The Derivative of a Regular Type is its Type of One-Hole Contexts (Extended Abst ...
17:03:49 <roconnor> chessguy: which I now see is directly referenced by the wikibook. :)
17:03:52 <dons> this mean() program is really breaking a lot of heads.
17:04:17 <dons> hardly anyone seems to understand how sum / length is compiled, or how to reason about folds that do the same.
17:04:29 <dcoutts> dons: I'm not sure showing folds or unboxed foo helps
17:04:31 <dons> sigh. maybe a good blog post
17:04:45 <chessguy> roconnor: sorry, missed that
17:04:59 <dons> well, if you can look at the core, you can reason precisely about the code.
17:05:07 <dcoutts> dons: http://hpaste.org/7593
17:05:09 <qwr> dons: haskell is too smart, people expect that it magically does everything ;)
17:05:13 <dons> if you've never look at it, its all just speculation.
17:05:23 <lament> @faq Can Haskell magically do everything?
17:05:23 <lambdabot> The answer is: Yes! Haskell can do that.
17:05:26 <elvis> hola chileno
17:05:28 <dons> qwr: and that's part of it. people just throw junk at ghc, and wonder why it doesn't work magically
17:05:47 <dcoutts> dons: my point is it's just simple primitive-recursive functional programming
17:05:54 <roconnor> dons: yeah, that surpised me.  There seemed to be many claims about the runtime behaviour of sum, and none of them were correct last time I looked.
17:05:56 <dons> dcoutts: right. isn't that the same thing I posted?
17:06:11 <sjanssen> dons: yes, noone seems to understand that "mean xs = sum xs / length xs" is slow in *every* language
17:06:15 <dcoutts> dons: well your first version used foldl and unboxed tuples :-)
17:06:25 <roconnor> dons: I want the mean monoid, and then use foldMap'
17:06:25 <dons> dcoutts: strict pairs!
17:06:39 <dcoutts> dons: right, and it's excessive
17:06:41 <dons> sjanssen:  yeah, i think that's why we've seen only haskell solutions.
17:06:44 <sjanssen> [1 .. 1e9] -- is going to eat all your memory in a strict language
17:06:53 <dons> dcoutts: well, if you want to do it without manual recursion.
17:07:09 <dons> but yes, to ensure it does what you want, recursion is highly predictable
17:07:14 <dons> so that's what i want to write about.
17:07:18 <dcoutts> dons: those people want simplicity, show it to them
17:07:20 <dons> the straight forward techniques.
17:07:21 <geezusfreeek> i find this whole deal frustrating
17:07:31 <dcoutts> you could write that version in any FP language from the past 30 years
17:07:49 <proq> tieTYT: a good majority of security holes tend to be a result of the features and flaws of the language. buffer overflows, sql injection, etc. cannot occur in all languages
17:07:52 <geezusfreeek> but one question i have for those would know‚Ä¶ why is sum defined with foldl instead of foldl'?
17:08:10 <dcoutts> geezusfreeek: foldl' isn't in Haskell98
17:08:15 <geezusfreeek> oh!
17:08:23 <geezusfreeek> okay that explains it
17:08:33 <dcoutts> well, it's one explanation
17:08:34 <Pseudonym> It's in Haskell', right?
17:08:34 <sjanssen> has that been looked at for Haskell'?
17:10:12 <dcoutts> dons: and note we don't need !/$!/seq or Int annotations for the strictness
17:10:32 <tieTYT> proq: what languages can't have sql injection?
17:10:40 <dcoutts> dons: though we do need Int annotation to get an unboxed Int# rather than Integer, but Interer.+ is strict too
17:10:45 <tieTYT> i wasn't aware that was language dependent
17:10:54 <vixey> tieTYT: it's a problem with the SQL interfaces
17:11:05 <roconnor> data Mean a = Mean !Integer !a; instance Monoid Mean where ... ; mean = foldMap' (Mean 1)
17:11:08 <tieTYT> define "sql interfaces"
17:11:11 <vixey> tieTYT: You could quite easily write a proper interface in any (realistic) language
17:11:16 <dons> geezusfreeek: also, foldl is optimised to foldl' for strict types like Int
17:11:34 <dcoutts> just by inlining right?
17:11:34 <tibbe> dcoutts: hate to repeat this question but what's the name of your student again? :)
17:11:39 <dons> sum, foldl, and foldl' all produce identical code
17:11:41 <dcoutts> tibbe: sioraiocht
17:11:52 <dons> so so so many issues that should be built into the brains of every haskeller
17:12:09 <dons> so maybe we can explore the issues and tools for analysing what's going on in a post
17:12:36 <dons> dcoutts: note there's an intersting overhead in the list version, not present in the streams version.
17:12:39 <sjanssen> roconnor: I'd prefer type Mean a = Sum Int :*: Sum a; mean = foldMap' ((1 :*:) . Sum) -- :)
17:12:45 <dcoutts> dons: oh?
17:12:48 <tieTYT> proq: as vixey doesn't seem to elaborate, could you?
17:12:56 <dons> dcoutts: walking a list has a penalty
17:12:56 <tieTYT> err, seem to want to
17:13:07 <vixey> tieTYT: not sure what you're asking
17:13:11 <dons> mean arr = b / fromIntegral a
17:13:11 <dons>   where
17:13:11 <dons>     k (n :*: s) a = (n+1 :*: s+a)
17:13:11 <dons>     (a :*: b) = foldl' k (0 :*: 0) arr :: (Int :*: Double)
17:13:12 <roconnor> thanks sjanssen I knew my code was too complicated.
17:13:16 <sjanssen> roconnor: with the strict pair constructor (:*:), an appropriate Monoid instance for it, and the Sum type from Data.Monoid
17:13:20 <proq> tieTYT: I thought vixey summed it up  :)
17:13:25 <dcoutts> dons: oh, you mean if you apply it directly to a [1..e] generator?
17:13:28 <Cale> tieTYT: What the problem with the way people use SQL from other languages is?
17:13:32 <dcoutts> dons: you mean you don't get list fusion
17:13:39 <dons> dcoutts: well, that won't fuse under lists
17:13:41 <dolio> > 1 :: Sum Int
17:13:43 <lambdabot>   add an instance declaration for (Num (Sum Int))
17:13:43 <lambdabot>     In the expression: 1 ::...
17:13:44 <dons> but that's fine.
17:13:45 <slava> dons: regarding generation of efficient code for sum list / length list, where list is [1..1000000000] in a strict language...
17:13:50 <dons> still, the lazy enum should be fine.
17:13:56 <dons> slava: ah yes?
17:13:57 <slava> dons: it would be efficient if [a..b] returns a special object instead of allocating an array
17:13:57 <roconnor> > Sum 1 :: Sum Int
17:13:57 <dcoutts> dons: it would with our lists of course
17:13:59 <lambdabot>  Sum {getSum = 1}
17:14:02 <slava> dons: and if length was constant time on that object :)
17:14:07 <dons> slava: so a thunk?
17:14:08 <tieTYT> vixey: I asked what a "sql interface" is
17:14:11 <dons> it would need laziness of some kind?
17:14:15 <Cale> tieTYT: The problem is that people generate SQL queries directly with string operations, which allows for things like injection.
17:14:16 <geezusfreeek> tieTYT: what everybody is getting at is that a proper interface could perform the validation and escaping necessary to prevent sql injection automatically
17:14:25 <dons> dcoutts: so with lists, though, you'd think the overhead wasn't too bad.
17:14:26 <slava> dons: factor has a 'range' type which implements sequence operations
17:14:35 <dons> slava: so its a special case of laziness?
17:14:36 <slava> dons: but this code is still slow in factor because the optimizer is unable to unbox the range object
17:14:46 <dons> a bit like perl's trick for this in foreach loops ?
17:14:48 <slava> dons: i guess, but i don't think of it that way
17:14:55 <slava> dons: its just one implementation of a sequence
17:14:58 <dcoutts> dons: it's just because of foldl doesn't fuse in build/foldr. A version written with foldl in our list lib should fuse perfectly.
17:15:00 <slava> out of many
17:15:11 <dons> slava: yeah, you've some how got to suspend the generation.
17:15:12 <Cale> tieTYT: Ideally, you'd build SQL queries using some library which would take care of building those strings carefully for you.
17:15:28 <dons> dcoutts: right sure. but i'm talking about the overhead of the list cells
17:15:32 <dons> its more than i'd expect
17:15:36 <Cale> (and possibly have other benefits, like being able to manipulate queries symbolically)
17:15:44 <vixey> the kids that do this stuff with SQL libs are the same ones that include($_GET['page'])
17:15:58 <slava> dons: to make efficient code there i have to replace the range object with its constituents, and then everything can be register allocated
17:15:59 <dons> dcoutts: since the list cells aren't kept in registers
17:16:07 <tieTYT> even so, you're using a library to do it.  You can't say the language is the one that's preventing SQL injections
17:16:12 <roconnor> mean arr = b / fromIntegral a
17:16:12 <roconnor>  where
17:16:12 <roconnor>   (a :*: b) = foldMap ((1 :*:) . Sum)
17:16:13 <dons> slava: yep, that sounds right.
17:16:21 <slava> dons: and do better loop analysis in general
17:16:23 <dcoutts> dons: aye, list fusion will buy a lot in that example
17:16:30 <geezusfreeek> tieTYT: i don't think anybody said the language prevented proper escaping
17:16:36 <dons> slava: somehow the list needs to be turned into an index and accumulator in registers
17:16:37 <vixey> tieTYT: agreed, it's not to do with the language (as long is it's type safe)
17:16:46 <slava> dons: yes
17:16:47 <tieTYT> <proq> tieTYT: a good majority of security holes tend to be a result of the features and flaws of the language. buffer overflows, sql injection, etc. cannot occur in all languages
17:16:56 <dcoutts> dons: but that's just a constant factor, compared to the confusion some people are suffering
17:17:02 <Cale> tieTYT: You could take advantage of language features in a lot of ways to make such libraries safer and more palatable though.
17:17:07 <dcoutts> which is a linear factor
17:17:08 <slava> dons: with a lazy langaugae, you can get a few things 'for free' with a concrete implementation of lists as a head/tail pair
17:17:17 <tieTYT> well anyway, i'm still curious about what languages prevent sql injections from happening
17:17:22 <tibbe> @seen sioraiocht
17:17:22 <lambdabot> sioraiocht is in #haskell-blah and #haskell. I last heard sioraiocht speak 3h 17m ago.
17:17:25 <tieTYT> Cale: agreed too
17:17:27 <slava> dons: in factor we have various 'virtual sequences'
17:17:36 <slava> dons: there's the range, also slices, reversals, groups
17:17:39 <dons> slava: yeah, well its trivial to turn [1 .. n] into register variables
17:17:39 <vixey> tieTYT: Didn't we just establish it's not a language issue?
17:17:41 <geezusfreeek> tieTYT: i think the idea was that _SQL_ was at fault, though it was probably a bad example
17:17:49 <chessguy> @bot
17:17:49 <lambdabot> :)
17:17:50 <dons> slava: interesting.
17:17:53 <vixey> geezusfreeek: no that's not the case
17:17:55 <tieTYT> geezusfreeek: oh ok
17:18:01 <vixey> SQL isn't the problem
17:18:03 <dons> slava: can you combine them? so no intermediate structure is used?
17:18:04 <geezusfreeek> vixey: i know it isn't the case
17:18:13 <geezusfreeek> vixey: like i said‚Ä¶ bad example
17:18:13 <proq> tieTYT: a sql injection occurs when you mix data and commands. in other languages this is a no-brainer
17:18:14 <dons> map (+1) . enumFromTo 1 n
17:18:32 <tibbe> @help
17:18:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:18:33 <dons> dcoutts: right, now i'm saying the constant factor is also surprisingly high.
17:18:33 <proq> tieTYT: do you still need more elaboration?
17:18:33 <vixey> proq not exactl
17:18:36 <slava> dons: you'll be able to when there's unboxing. the goal is that if you have a reversal of a slice or something, and iterate over it, it becomes a specialized loop over the underlying sequence
17:18:37 <dons> dcoutts: perhaps worth a bug report
17:18:55 <slava> dons: right now you avoid copying large amounts of data around, at the cost of additional indirection and dispatch at runtime
17:18:57 <tieTYT> proq: in other languages, you have libraries you can use that make it easier to avoid sql injections
17:18:58 <dons> slava: so i would definitely recommend the stream fusion paper
17:19:00 <vixey> proq: data and code are the same thing as far strings are concerned, it's about what interpretation is given
17:19:04 <dons> slava: which was exactly about this topic
17:19:19 <slava> i'll check it out
17:19:20 <dons> reflecting lists and arrays into abstract loop forms, that can be combined
17:19:28 <dcoutts> dons: so what are you comparing exactly? why do you think the difference is excessive?
17:19:35 <proq> tieTYT: for example, I don't take the login that someone entered and call exec on it because their login could be a malicious command
17:19:46 <dcoutts> dons: you've got a stream version where you fuse the foldl with the enumFromTo?
17:19:55 <slava> dons: i have some doubts about fusion in general though, namely the fact that it can throw exceptions out of order
17:20:00 <dons> yeah, it does the same version as for uvector, dcoutts
17:20:09 <dons> slava: yeah, you better have pure code.
17:20:22 <dons> otherwise only very special cases are safe
17:20:23 <proq> tieTYT: in the same way, you have to sanitize the database inputs because this was never taken into consideration with sql
17:21:03 <dcoutts> dons: and you're comparing a loop that does no allocation to one that generates and consumes [1..1e9], I'm not sure why you're surprised by any factor difference between the two :-)
17:21:08 <tibbe> dons: I would like to have a chat with you about streams and enumerators at some future date :)
17:21:23 <dons> dcoutts: i think its more than i'd expect. let me get you some numbers.
17:21:38 <slava> dons: also i'm not sure how reliable stream fusion is, in the sense that a programmer might depend on it occurring at a certain point, then make a minor change to his code which throws the optimzier off
17:22:00 <slava> dons: i try to stick to optimizations which don't complicate the programmer's mental performance model too much
17:22:06 <dcoutts> dons: if it is it's a low level issue since you can see the core is optimal
17:22:16 <dons> slava: perhaps.
17:22:28 <dons> dcoutts: yes. that's right.
17:22:30 <dons> the core is optimal
17:22:54 * MyCatVerbs pokes nobench.
17:23:07 <dcoutts> dons: so it'll be doing a heap check in every iteration, writing to memory, occasionally allocating new nursaries, GC'ing
17:23:15 <dcoutts> dons: there are lots of big differences
17:23:15 <slava> dons: but its interesting that in some sense, an object which returns consecutive integers is somewhat equivalent to a counting loop
17:23:23 <slava> dons: and most languages don't take advantage of this fact
17:23:35 <dons> right. this is what Cale talks about all the time. lazy lists are control structures
17:23:44 <slava> lazy anything really
17:23:45 <dons> when someone writes map print [1.. n]
17:23:49 <dons> they're writing a for loop
17:24:13 <tieTYT> dons: is that bad to do?
17:24:19 <dcoutts> @src sequence_
17:24:20 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
17:24:35 <MyCatVerbs> Re: nobench. Apparently this hasn't been touched since sometime in 2007? Pulling from the repo at code.haskell.org/nobench and attempting to build with ghc-6.8.2 fails in all sorts of interesting ways.
17:24:45 <slava> dons: certain operations on [1..n] will allocate the list right?
17:24:49 <slava> where the compiler cannot fuse things
17:25:02 <dons> slava: right. or things where you're required to hang onto the list
17:25:05 <dons> sum xs / length xs
17:25:07 <dons> has to.
17:25:32 <sjanssen> hmm, does it really?
17:25:46 <sjanssen> I wonder if we can write a RULE for that
17:25:47 <dons> sjanssen: well, you could regenerate xs
17:25:55 <dcoutts> slava: the rule of thumb, is that if it's got exactly one consumer and it's consumed by a 'nearby' foldr or something defined in terms of a foldr, then it can fuse
17:26:07 <slava> dcoutts: yup, i understand that
17:26:10 <chessguy> would anyone like to serve as sort of a mentor for a haskell chess project i'm working on?
17:26:10 <MyCatVerbs> dons: are you still hacking on nobench, please? Or is everyone using something entirely different?
17:26:11 <dcoutts> sjanssen: not very easily
17:26:14 <slava> with range objects you don't ever allocate it though
17:26:23 <slava> of course the downside is having to implement the range object in the first place :)
17:26:26 <dcoutts> sjanssen: it's another form of loop fusion, but a more tricky kind
17:26:39 <dons> MyCatVerbs: its at code.haskell.org
17:27:11 <dcoutts> sjanssen: the imperative compiler people have looked at that form a bit
17:27:35 <slava> dons: also i think dividing by n on each iteration and summing is not equivalent to dividing by n at the end, with floats
17:27:52 <sjanssen> forall f g x xs h y. f (foldl' g z xs) (foldl' h y xs) = uncurry f (foldl' (combine g h) (z, y) xs) -- workable?
17:28:02 <dcoutts> sjanssen: where you have two loops on after another that both read from a single array and you try to fuse them so they work in lock-step
17:28:24 <dons> slava: right, but the division still happens at the end
17:28:37 <sjanssen> where combine g h = \(x, y) z -> (g x z, h y z)
17:28:50 <dons> it becomes a loop that does sum and length together, and at the end does the division.
17:28:51 <MyCatVerbs> dons: k, thanks. Just wondering, since it breaks quite messily when I attempt to build it, and the last patch in there was from Dec 20th 2007.
17:28:52 <dcoutts> sjanssen: in a lazy language you need to know the result of the two loops are both demanded at the same time
17:29:11 <perspectival> is there a shorthand way to easily re-export everything imported into a module?
17:29:13 <sjanssen> dcoutts: oh, good point -- what if f = const
17:29:31 <dons> dcoutts: http://hpaste.org/7605
17:29:38 <dons> the lazy list overhead is more than i'd have thought
17:29:42 <slava> it sucks that FP math is not associative
17:29:45 <slava> and that equality is not reflexive :(
17:29:58 <dolio> sjanssen: Your rule changes the strictness of the accumulators, too.
17:29:59 <dons> ?keal
17:30:00 <lambdabot> doubles and floats cause b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b) to fuck up
17:30:01 <dons> hehe
17:30:03 <dons> yay keal.
17:30:21 <dolio> I guess that's just a matter of changing 'combine' though.
17:30:24 <monochrom> I have caught dons saying "your" instead of "you're" in "As long as you understand the operations your trying to make predictions about."  :)
17:30:35 <JamesR> Out of Curiosity, in the context of Programming what does Lamda stand for?
17:30:37 <dons> monochrom: oh not again
17:30:42 <slava> monochrom: now that's a type error
17:30:47 <dons> didn't you get me on irregardless yesterday?
17:30:48 <sjanssen> dolio: yeah, I meant to use a strict pair
17:30:50 <monochrom> Oh, it has already been noticed?  Hehe
17:31:02 <monochrom> No, I said nothing on irregardless.
17:31:08 <chessguy> jamesjb: frequently, it's "function"
17:31:21 <dons> i'm not sure why I do this sometimes. it's a fatal flaw.
17:31:30 <monochrom> It's OK! :)
17:31:43 <dcoutts> dons: we'd have to look at the cmm and GC stats I think to see why
17:31:44 <chessguy> jamesjb: e.g., lambda x.x would be the function that just returns its only parameter
17:32:04 <dons> dcoutts: tiny fraction of GC, like 1.2% in the list case
17:32:08 <dons> 0% in the streams case :)
17:32:17 <dcoutts> hmm
17:32:24 <dcoutts> that's less than I expected
17:32:26 <dons> still, memory traffic. cache behaviour
17:32:33 <dons> i'll just double check.
17:33:06 <dons>   %GC time       1.6%  (4.1% elapsed)
17:33:27 <dons> 10^9 nodes allocated?
17:34:02 <dons> maybe that's enough to throw off a tight loop like that by a lot
17:34:06 <wjt> Am I right in thinking there's now a standard function st.  f "foo" "foobar" -> Just "bar"; f "foo" "shatner" -> Nothing ?
17:35:03 <roconnor> @wn invaluable
17:35:03 <lambdabot> *** "invaluable" wn "WordNet (r) 2.0"
17:35:03 <lambdabot> invaluable
17:35:03 <lambdabot>      adj : having incalculable monetary worth [syn: {priceless}]
17:35:12 <wjt> @ty stripPrefix -- aha!
17:35:15 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
17:35:39 <dons> dcoutts: dolio wrote some euler program today to use streamed uvectors, and got a great speedup over STUArray
17:35:58 <vixey> ?viken strip prefix
17:35:59 <lambdabot> are you coming on to me?
17:36:05 <dcoutts> dons: nice
17:36:54 <dcoutts> dons: at some point we're going to want to be able to fuse the conversions between all these types, so we'll have to get them using a common stream impl
17:37:05 <dons> i've wanted that already sometimes
17:37:11 <dons> for streaming arrays into binary
17:37:13 <dons> via lists.
17:37:18 <dcoutts> converting lists, strings, arrays etc
17:37:24 <JamesR> What's this
17:37:28 <JamesR> A feeling of ... Accomplishment
17:37:55 <slava> @src catMaybes
17:37:56 <lambdabot> catMaybes ls = [x | Just x <- ls]
17:38:23 <dons> slava: i'd be interested to see how you'd write the: mean :: [Double] -> Double function in factor, for 1 .. 1e9
17:38:38 <dolio> dons: It's since occured to me that you could use a much more efficient algorithm for that particular problem that would probably beat the uvector, since it wouldn't have to sieve primes up to 100 million.
17:38:42 <slava> dons: i'd just write 1 1000000000 [a,b] [ sum ] [ length ] bi /
17:38:46 <slava> dons: but that's slow for the reasons i mentioned
17:38:58 <slava> are you asking about an optimized version?
17:39:01 <dolio> But as far as the array/list munging goes, it shows the advantages of uvector, I suppose.
17:39:15 <slava> hmm. in factor, 1e9 is a float not an integer
17:39:16 <dons> oh, does that duplicate the array into a and b?
17:39:24 <slava> [a,b] is a constructor for a range object
17:39:32 <slava> there's also [a,b), (a,b], etc
17:39:35 <dons> ah i see.
17:39:46 <dons> so,  [1 .. 1e9]
17:39:49 <slava> yup
17:39:52 <dons> (..) is the range generator
17:39:58 <slava> @src (..)
17:39:59 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:40:05 <dons> 1e9 is a floating literal in Haskell, btw
17:40:06 <vixey> @src enumFromTo
17:40:07 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:40:17 <dons> :t enumFromTo
17:40:18 <vixey> [a..b] = enumFromTo a b -- ?
17:40:19 <lambdabot> forall a. (Enum a) => a -> a -> [a]
17:40:25 <dons> :t enumFrom
17:40:26 <slava> what's an Enum?
17:40:27 <lambdabot> forall a. (Enum a) => a -> [a]
17:40:31 <dons> the class of enumerable types
17:40:33 <vixey> @instances Enum
17:40:33 <dons> ?src Enum
17:40:36 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
17:40:36 <lambdabot> class  Enum a   where
17:40:36 <lambdabot>     succ                     :: a -> a
17:40:36 <lambdabot>     pred                     :: a -> a
17:40:36 <lambdabot>     toEnum                   :: Int -> a
17:40:36 <slava> what's an enumerate type
17:40:38 <lambdabot>     fromEnum                 :: a -> Int
17:40:39 <slava> aha
17:40:40 <lambdabot> [3 @more lines]
17:40:45 <dolio> dons: Incidentally, doing some testing, indexU seems really terrible for usual array-like usage.
17:40:46 <vixey> > [False..]
17:40:47 <lambdabot>  Parse error at "False..." (column 2)
17:40:47 <slava> interesting
17:40:52 <vixey> > [False ..]
17:40:54 <lambdabot>  [False,True]
17:40:57 <dons> dolio: yeah, i'm think we should have two apis.
17:41:02 <dons> Stream.* and Strict.*
17:41:07 <slava> dons: i could generalize my range types with something similar, that way it wouldn't be limited to integers
17:41:09 <dons> one which uses the direct access
17:41:12 <vixey> > [(),() ..]
17:41:13 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
17:41:17 <dons> slava: so how would you write the optimised version?
17:41:23 <dons> and how fast is the result?
17:41:26 <slava> hang on
17:41:41 <dons> something like this? http://hpaste.org/7583
17:41:48 <dons> (the C loop)
17:42:02 <dons> dcoutts: oh, btw, gcc -O2 does something super amazing to that loop
17:42:20 <dons> while gcc -O is pretty much the same as ghc
17:42:54 <wolverian> how fast is -O2?
17:42:59 <dcoutts> dons: gcc is pretty good at loops :-)
17:43:49 <dons> dcoutts: i wish ghc spat out that for loop. it produced the same thing
17:43:53 <slava> : fast-average ( n -- x ) 0.0 over '[ >float , / + ] reduce ;
17:43:53 <slava> HINTS: fast-average fixnum ;
17:43:54 <dons> but not in a form gcc could grok
17:44:12 <dons> slava: ah, so a strict fold, with a pair accumulator
17:44:20 <dons> what kind of asm do you get?
17:45:18 <dons> you could annotate this page with the source and asm, http://hpaste.org/7583
17:45:39 <slava> 1e9 is bigger than my biggest fixnum :(
17:45:47 <dolio> dons: How many operations do you actually need two versions of?
17:45:54 <slava> so its pretty slow with 1e9
17:46:03 <slava> 1e8 takes 2.4 seconds (which is still slow)
17:46:04 <dolio> index, length...
17:46:23 * JamesR feels Haskell flowing through his veins
17:46:41 <slava> dons: 1e9 takes 100 seconds :(
17:47:09 <slava> but i forgot we have a 'sigma' word:
17:47:09 <slava> : fast-average ( n -- x ) dup '[ >float , / ] sigma ;
17:47:09 <slava> HINTS: fast-average fixnum bignum ;
17:47:14 <dolio> I suppose zip is radically faster if you really have two arrays, but I don't know how often I'd zip two arrays together in a context that wasn't fusable.
17:47:33 <dons> dolio: mostly, just those things that have better complexity when not streams
17:47:38 <dons> so take , drop, length, index
17:47:42 <dons> head, tail etd
17:48:31 <JamesR> Woah, net split
17:48:40 <JamesR> :P No, just one guy
17:49:09 <idnar> I saw 13 guys split
17:49:10 <dons> slava: yeah, i think this 1e9 is enough to make it interesting
17:49:38 <dons> slava: got to get everything into registers, and only the adds in the inner loop
17:49:41 <dons> or you get killed
17:51:13 <dolio> dons: Is there no way to rewrite, say 'indexS . streamU' to 'fastIndex' after stream fusion has triggered?
17:51:37 <chessguy> > Nothing == Nothing
17:51:39 <lambdabot>  True
17:52:38 <dons> dolio: there is, but its more fragile than i'd like
17:52:46 <dons> so i'd prefer to let the user switch between them
17:52:55 <dolio> Ah.
17:53:03 <slava> dons: i got a new version that runs in 19 seconds but its lower level
17:53:05 <dolio> That's a shame.
17:53:17 <dons> slava: oh, interesting. how do you go lower level?
17:53:19 <dobblego> is there a paper that talks about the relationship between objects and closures?
17:53:24 <slava> dons: by writing a loop instead of using sigma
17:53:32 <slava> dons: this allows me to use a float counter instead of a bignum counter
17:53:32 <dons> ah i see.
17:53:41 <dons> slava: right. the foldl in ghc turns into the loop form.
17:53:47 <mapreduce> dons: The Scheme Report?
17:53:51 <mapreduce> dobblego: ^^
17:53:52 <dons> yeah, and bignum won't help.
17:53:55 <slava> dons: so does factor's reduce, but here i'm using floats as indices instead of integers
17:54:00 <slava> ghc does this transformation automatically i presume
17:54:03 <slava> my compile doesn't (yet!)
17:54:05 <dobblego> mapreduce, yeah I guess there is that, thanks
17:54:23 <dons> well, its all double precision floats, except the length calculation
17:54:26 <slava> dons: http://paste.factorcode.org/responder/pastebin/show-paste?n=792
17:54:53 <dons> ah right, so what are the types of n i and acc?
17:54:58 <dons> int , float,  float?
17:55:00 <slava> they're all floats
17:55:10 <slava> n is converted to a float at the start of faster-average
17:55:17 <slava> the whole thing is done with floats and there are not ype checks
17:55:23 <slava> unfortunately, there's a boxing operation done on each loop iteration
17:55:29 <slava> since i don't register allocate across basic blocks yet :(
17:55:34 <dobblego> I found a paper with a promising title, but it requires ACM registration
17:55:35 <slava> one that's gone it should be a lot faster
17:55:48 <dons> yeah, that's surprisingly fast if it has to allocate to box
17:55:56 <slava> this is a 2.4 ghz core duo
17:55:58 <dons> is there a way to make the length counter an int?
17:56:04 <dons> ah, so is mine.
17:56:07 <slava> sure, but then it will need to be a bignum
17:56:10 <slava> which is slower than using a float
17:56:15 <slava> : fast-average ( n -- x ) dup '[ >float , / ] sigma ;
17:56:15 <slava> HINTS: fast-average fixnum bignum ;
17:56:20 <JamesR> If i'm pattern matching a string, and my first is the null value (ie. []) and my output has to be IO() is there a better way of doing null than putStr "" ?
17:56:20 <dons> oh i see.
17:56:35 <dons> slava: so not 64 bit int?
17:56:36 <Cale> JamesR: return ()
17:56:41 <JamesR> Cheers
17:56:44 <chessguy> would anyone like to serve as sort of a mentor for a haskell chess project i'm working on?
17:56:47 <slava> dons: oh, i'm running in 32 bit mode. on 64 bit it should be faster
17:56:51 <dons> core duo, not core 2.
17:56:55 <slava> its a core 2 duo.
17:57:04 <slava> also maybe you like this better:)
17:57:04 <slava> :: fast-average ( n -- x ) dup [ >float n / ] sigma ;
17:57:05 <dons> yeah, i'm in 64 bit, so the 'n' is an int, as you see.
17:57:05 <slava> HINTS: fast-average fixnum bignum ;
17:57:07 <JamesR> Cale: Cheers (Really got to get used to IRC again :>)
17:57:14 <dobblego> chessguy, I'd be interested in reviewing, but I'm not sure I could help that much
17:57:23 <slava> dons: using locals
17:57:28 <slava> err, s/dup/n
17:57:33 <mmnnbb> i get an error "Instance of Integral (Maybe Int) required for definition of eval", what am i doing wrong? here is my code: http://hpaste.org/7606
17:57:35 <chessguy> dobblego: i'm mostly interested in code reviews, and general advice
17:57:40 <slava> :: fast-average ( n -- x ) n [ >float n / ] sigma ;
17:57:48 <slava> that's with n in a local varaible instead of keeping it on the stack
17:57:50 <Cale> JamesR: One thing to notice about return is that it doesn't have the control effects that it does in most imperative languages. It's an ordinary function, and all it does is produce an action which when executed produces the given value.
17:57:58 <dobblego> chessguy, if letting me take a look is free, there is always the possibility that I offer an insight :)
17:58:01 <dons> slava: oh, interesting.so that ensure it lives where?
17:58:11 <slava> dons: it generates equivalent code in the end
17:58:16 <slava> locals are implemented at the library level
17:58:26 <dons> oh i see what you mean.
17:58:32 <dons> it tidies it up a bit
17:58:48 <chessguy> dobblego: if you privmsg me your email, i'll write up a description of what i'm doing, if you'd like
17:58:55 <dobblego> chessguy, thanks
17:59:10 <slava> dons: once the boxing is gone, it sholud be really fast on a 64-bit machine
17:59:28 <chessguy> thank you!
18:00:08 <slava> dons: but right now i'm not working on the compiler, my main project is the web server (with SSL being a major subproject of that)
18:00:19 <dons> yeah, i'd be interested to see that. i've a theory that most optimised languages will produce the same result as gcc-O, ocaml, ghc, C++ etc. the loops should look pretty much the same from each system
18:00:33 <slava> i've been reading compiler books and thinking about ideas
18:00:57 <Saizan> mmnnbb: well your eval functions returns a (Maybe Int) and you're e.g. using `div` on results of eval.. instead you should unpack those Maybe and use div on the Int contained inside
18:01:28 <slava> so dons
18:01:30 <slava> @src catMaybes
18:01:30 <lambdabot> catMaybes ls = [x | Just x <- ls]
18:01:40 <slava> i need to add this word to factor, it comes up often. but i don't like the name you guys are using :)
18:01:41 <dons> yeah?
18:02:08 <dons> so its a filter
18:02:13 <dons> :t catMaybes
18:02:15 <lambdabot> forall a. [Maybe a] -> [a]
18:02:19 <slava> yes
18:02:33 <slava> except instead of Maybe types i use a nil value. but the intention is the same
18:02:43 <dons> :t filter ( \x -> case x of Just _ -> True ; _ -> False)
18:02:46 <lambdabot> forall t. [Maybe t] -> [Maybe t]
18:02:54 <glguy> dons: catMaybes removes the Just
18:03:01 <dons> :t map fromJust . filter ( \x -> case x of Just _ -> True ; _ -> False)
18:03:03 <lambdabot> forall a. [Maybe a] -> [a]
18:03:26 <glguy> slava: isn't that just:   [ ] filter
18:03:27 <dons> fusion turns that into a single loop, fwiw. :)
18:03:30 <dobblego> filter isJust
18:03:32 <slava> map f . filter g seems ommon enough that it should have a nice name
18:03:37 <slava> glguy: yes, i want to name that
18:03:47 <dobblego> :t map fromJust . filter isJust
18:03:49 <lambdabot> forall a. [Maybe a] -> [a]
18:03:51 <slava> glguy: otherwise the compiler keeps expanding a copy of filter at each occurrence :)
18:03:53 <dons> ?pl map f . filter g
18:03:53 <lambdabot> map f . filter g
18:04:06 <slava> glguy: anotehr one is [ empty? not ] filter
18:04:22 <dons> filter (not . null) ?
18:04:24 <geezusfreeek> @pl \f g -> map f . filter g
18:04:24 <lambdabot> (. filter) . (.) . map
18:04:38 <slava> :t null
18:04:39 <lambdabot> forall a. [a] -> Bool
18:04:43 <roconnor> @where+ Ô¨É http://www.cse.unsw.edu.au/~chak/haskell/ffi/
18:04:44 <lambdabot> It is stored.
18:04:45 <slava> what about strings and arrays?
18:04:54 <roconnor> @where Ô¨É
18:04:54 <dolio> @type map fromJust . filter isJust
18:04:54 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
18:04:55 <dons> > null ""
18:04:56 <lambdabot> forall a. [Maybe a] -> [a]
18:04:57 <lambdabot>  True
18:05:00 <dons> > null [1..]
18:05:03 <lambdabot>  False
18:05:05 <roconnor> @where ffi
18:05:06 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
18:05:07 <slava> sorry, strings are lists :) i forgot
18:05:17 <slava> dons: question still stands w.r.t. arrays
18:05:22 <geezusfreeek> roconnor: you just @whered a ligature ‚Ä¶ and it worked?!
18:05:28 <dons> well, we don't have listy arrays
18:05:31 <roconnor> geezusfreeek: yep
18:05:36 <dons> but its 'null' in the vector library
18:05:39 <dobblego> ?type let null' = Data.Foldable.foldr (const False) True in null'
18:05:41 <lambdabot>     Couldn't match expected type `b -> b' against inferred type `Bool'
18:05:41 <lambdabot>     Probable cause: `const' is applied to too many arguments
18:05:41 <lambdabot>     In the first argument of `Data.Foldable.foldr', namely
18:05:44 * geezusfreeek gives lambdabot a cookie
18:05:45 <dons> there's no polymorphism between lists and arrays
18:06:04 <roconnor> geezusfreeek: ffi was already whered
18:06:06 <dobblego> ?type let null' = Data.Foldable.foldr (const $ const False) True in null'
18:06:08 <lambdabot> forall (t :: * -> *) b. (Data.Foldable.Foldable t) => t b -> Bool
18:06:10 <geezusfreeek> oh
18:06:14 <roconnor> geezusfreeek: so it is less amazing that you thought
18:06:19 <roconnor> geezusfreeek: take the cookie back
18:06:21 <slava> dons: heh nice
18:06:28 <slava> dobblego i mean
18:06:34 <slava> 'heh nice' about the null' function
18:06:36 <dobblego> slava, ;)
18:06:39 * dcoutts__ hits a hard case for package dependency analysis
18:06:41 * geezusfreeek takes the cookie from lambdabot's eager hands and stomps on it
18:06:47 <slava> dons: shame about the list and arrays. any real reason?
18:06:50 <slava> dons: at least you have fmap right?
18:07:04 <dons> yeah.and they're both monoids, functors, monads
18:07:12 <glguy> ?instances Functor
18:07:13 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
18:07:13 <Cale> slava: Arrays are more closely related to Maps
18:07:14 <slava> that's probably good enough :)
18:07:26 <dons> i guess we can do Traversable , Foldable and Applicative
18:07:30 <dons> i'd not thought of that
18:07:37 <dons> oh, the UA constraint might be hard.
18:07:40 <dons> its the Set problem
18:08:04 <dons> i want a class associated class constraint
18:08:28 <dons> so I can say arrays are functors, but only on element types in UA.
18:08:37 <dolio> Yes, class families.
18:08:45 <dolio> Crack the whips.
18:09:47 <dolio> Arrays are just Functors, not Applicatives or Monads.
18:11:18 <dons> dolio: well, they support foldr, singleton and empty
18:11:29 <dolio> The latter would probably involve a lot of undesirable allocation.
18:11:33 <dons> definitely
18:11:34 <dcoutts> woo!
18:11:45 * dcoutts constructs a valid install plan for upgrading his packages
18:11:47 <dons> m >>= k = foldrU (appendU . k) empty m
18:12:00 <dolio> Oh, I'm talking Data.Array.IArray type stuff.
18:12:07 * dcoutts solves the dreaded diamond dependency problem
18:12:39 <dolio> Those have an additional issue of having to pick indices for return and bind/join.
18:12:51 <dolio> In addition to not fusing.
18:20:38 <monochrom> I love you all.
18:22:11 * buff_drinkslot hugs monochrom 
18:25:21 <JamesR> If I need to increment a variable for EVERY item of a data type nested in an Array which is also a datatype (ie. ArrayType[(Type Str Int),(Type Str Int)]) do I need to create a recursive function which takes x, ammends it then places it onto another new Array before finally returning the new Array in place of the old?
18:25:24 <JamesR> If that makes any sense
18:27:14 <buff_drinkslot> I'm not sure if I understand but sounds like a job for map
18:27:49 <monochrom> ought not create new arrays
18:27:58 <gwern> @wn apothegm
18:27:59 <lambdabot> *** "apothegm" wn "WordNet (r) 2.0"
18:27:59 <lambdabot> apothegm
18:27:59 <lambdabot>      n : a short pithy instructive saying [syn: {aphorism}, {apophthegm}]
18:28:39 <monochrom> if I understand, you are just reading an array (and its complex elements) and counting something.
18:29:22 <JamesR> http://hpaste.org/7607
18:29:25 <JamesR> Hopefully that makes more sense
18:30:39 <JamesR> If you see where I was going with my lengthy explanation ...
18:30:50 <monochrom> Could you give some sample input and sample output?
18:30:53 <buff_drinkslot> length . filter . isPopular ?
18:31:17 <JamesR> Say ...
18:31:50 <JamesR> playAll (Playlist[("Billy Jean",3,"Michael Jackson",0)])
18:32:01 <JamesR> Would need to increment the Zero to a 1
18:32:16 <JamesR> And any other Tracks in that Playlist afterwards
18:33:08 <JamesR> ie playAll (Playlist[("Billy Jean",3,"Michael Jackson",0),("Never Gonna",3,"Rick Astley",1)])
18:33:16 <JamesR> Would have to increment the 0 in the first track to a 1
18:33:22 <JamesR> And the 1 in the second track to a 2
18:33:33 <monochrom> Always add 1?
18:33:46 <JamesR> Yeah, it's supposed to be a Media Shop ... Player ... Thing
18:34:00 <JamesR> So "Play All" would add 1 to the total number of times it has been played
18:34:39 <monochrom> playAll = map f where {f (Popular s f s' i) = Popular s f s' (i+1); f x = x}
18:35:14 * JamesR googles 'haskell map'
18:35:14 <monochrom> the code could be even slicker if you added record notation to Track.
18:35:27 <monochrom> Here is an example of map.
18:35:36 <monochrom> > map f [a, b, c] :: Expr
18:35:38 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[b]'
18:35:43 <monochrom> > map f [a, b, c] :: [Expr]
18:35:44 <JamesR> You thing they'd teach me Map
18:35:46 <lambdabot>  [f a,f b,f c]
18:36:24 <monochrom> If you're under a teacher and teacher wants you to write your own recursion, it is not too bad either.
18:36:55 <monochrom> Oh haha, I forgot Playlist adds an extra constructor.
18:37:31 <monochrom> playAll (Playlist y) = Playlist (map f y) where { ... same f as before ... }
18:39:09 <JamesR> The actual method by which I create most of the functions is up to me, but my question a minute ago was mainly angling for a "Is it even possible to do this with simple recursion?" (Without map)
18:39:30 <monochrom> Yes, since map itself is simple recursion too. :)
18:39:50 <monochrom> playAll (Playlist []) = Playlist []
18:40:53 <gwern> huh. I'm pretty impressed by Pesca. released in 2000, and a ghc --make Editor.hs works just fine
18:41:02 <gwern> and it is thoughtful enough to mention it's GPL'd
18:41:25 <monochrom> I'm stuck because this is a bad design.
18:42:29 <monochrom> playAll should not do the recursion itself. It should call an auxilliary function, which in turn does the recursion. This is because there is Playlist unpackaging and repackaging, and it's silly to do that inside your recursion.
18:43:46 <Saizan> monochrom: so you got one of those "can't write so ugly code" moments? :)
18:44:27 <monochrom> Yes, I have ethics and morality. :)
18:44:52 <gwern> Saizan: 'i kant haskell today; i has the dumbs'?
18:45:18 <Saizan> gwern: almost the opposite i'd say
18:45:19 <monochrom> http://hpaste.org/7607#a1  but note I counted the number of fields of Classic wrong, also typo.
18:45:43 <monochrom> I can't write ugly code today, Dijkstra is watching my back.
18:46:41 <gwern> omg
18:46:48 <gwern> 'ceiling dijstra is watching u'
18:47:29 <gwern> 'ceiling dijkstra is watching u'... hm, copy-paste your code? make an off-by-one error?
18:48:15 <monochrom> The equation playAll (Playlist x) = Playlist (f x) is of the form g.h = h.f.  When this happens, there are nice theorems concerning the fixed point of g.h.  (Dijkstra made me say so.)
18:49:04 <JamesR> O.o
18:50:12 <Saizan> :O
18:50:15 <chessguy> dobblego: you've got mail
18:50:23 <Saizan> such as?
18:50:38 <dobblego> chessguy, cheers mate; I shall read
18:50:57 <chessguy> dobblego: may want to get yourself a stiff drink first :)
18:51:31 <dobblego> chessguy, I used to play chess quite a lot; tried entering tournament recently
18:51:50 <monochrom> It'll take me a while to look up. Please wait.
18:51:53 <chessguy> oh nice
18:52:09 <chessguy> dobblego, have you tried your hand at any programming?
18:52:20 <dobblego> chessguy, not in terms of chess, no
18:52:33 <chessguy> ok
18:52:48 <chessguy> was this a USCF tournament? FIDE?
18:53:08 <dobblego> I used to play in tournaments organised by Chess Australia and Chess Association of Queensland
18:53:42 <dobblego> my jealous angry step-father broke most of my trophies
18:53:50 <chessguy> ouch
18:54:10 <dobblego> I still have medallions though ;) can't break those!
18:54:15 <chessguy> that sounds like the aussie equivalent of USCF then
18:54:24 <dobblego> yes I think so too
18:55:01 <chessguy> it's fun stuff, i've played in probably 15 or 20 tournaments myself, mostly small
18:55:14 <chessguy> but it's been a couple years
18:55:30 <dobblego> it seems you're trying to write a very general abstraction of chess
18:55:48 <chessguy> not of chess itself, but of the AI involved
18:55:59 <dobblego> right
18:56:05 <JamesR> monochrom: The only part of the explanation I don't totally get is Playlist (f x), in Haskell will it just hold f, read the "Where" then compute it as "do f to x"?
18:56:33 <chessguy> and the level of abstraction can be tightly controlled by the grammar
18:57:07 <chessguy> e.g., i can write a very domain-specific traversal grammar, and it won't be nearly as abstract
18:58:01 <chessguy> all the framework does is ensure that the traversal results in a legal move
19:00:50 <SamB_XP> chessguy: you can't get the trophies replaced?
19:01:09 <chessguy> SamB_XP: not my trophies, they were dobblego's
19:01:20 <SamB_XP> damnit
19:01:30 <SamB_XP> you are both the same color, length, and capitalization
19:01:34 * gwern facetiously suggests doing the entire thing in surreal numbers
19:01:35 <dobblego> SamB_XP, I could, but why bother and so long ago
19:01:48 <monochrom> Excuse, there is no nice theorem using g.h=h.f.  There is only one using h.g=f.h, and it grants: h . fix g = fix f.
19:03:08 <monochrom> JamesR: I don't know "hold f", but perhaps the answer is yes.
19:09:34 <chessguy> dobblego: any thoughts?
19:09:53 <dobblego> chessguy, I will read it in detail a bit later mate, sorry
19:10:04 <chessguy> no prob
19:10:14 * gwern uploads pesca
19:10:23 <gwern> I like cabal-upload, but it acts stupider than it needs to, imo
19:14:55 <Saizan> gwern: like?
19:15:39 <schme2> good mornin' #haskell
19:16:56 <chessguy> hiya schme2
19:18:10 <schme2> Hello there chessguy :)
19:25:15 <noecksit> hello, could anyone help me understand the article "Roll Your Own IRC bot" by dons
19:25:31 <noecksit> especially the part about making your own monads
19:25:45 <gwern> Saizan: well, you almost always run cabal intall from a directory which at the top level of a cabal project, no?
19:25:54 <gwern> and almost always there is only one sdist tarball in dist/
19:26:35 <gwern> Saizan: so why can't cabal-upload run an sdist and automatically upload the only tarball in dist/? why do you need to manually run sdist and manually tell cabal-install what tarball to use?
19:27:26 <gwern> Saizan: it is entirely reasonable from my view to default to the common case; if someone wants to run cabal-install from ~/, fine, they're no worse off - they still have to give the absolute or relative address of the tarball
19:27:40 <dmwit> noecksit: Probably; what's confusing?
19:27:41 <gwern> do you see what I mean by how I consider it dumber than it has to be?
19:29:06 <noecksit> dmwit: what does "asks socket >>= listen" do?
19:29:35 <monochrom> it does the same as: do { x <- asks socket; listen x }.  Does that help?
19:29:40 <dmwit> noecksit: In the Reader monad, "ask" gets the environment.
19:30:02 <dmwit> noecksit: The 's' suffix means that you also supply a function to apply to the environment first.
19:30:14 <dmwit> noecksit: So "asks socket" gets the "socket" part of the environment.
19:30:29 <dmwit> noecksit: (>>= listen) then sends this socket number to the "listen" function.
19:31:22 <noecksit> dmwit: so asks socket gets the handle (the socket) and puts it into x
19:31:29 <noecksit> as per your example?
19:31:53 * monochrom hides :)
19:31:55 <dmwit> Yeah, in the do version that monochrom posted, it puts the handle into x.
19:32:49 <dmwit> Also, Haskell.org's parser seems pretty buggy.
19:33:18 <noecksit> dmwit: also, what exactly does "init" do?
19:33:22 <gwern> indeed. I brought up the --> problem earlier
19:33:29 <gwern> still don't know whom to complain to :(
19:33:56 <noecksit> dmwit: oh actually i see
19:34:01 <dmwit> gwern: It parses (nick++"string") as (nick+ identifier) (+ operator) (""string). =/
19:34:06 <noecksit> drops the last element
19:34:08 <schme2> Is there some easy way to store and later read back lists or what not from a file?
19:34:17 <dmwit> noecksit: yep
19:34:27 <dmwit> schme2: writeFile, readFile?
19:34:42 <dmwit> schme2: See also class Show.
19:34:50 <dmwit> Well, Show and Read.
19:35:20 <gwern> dmwit: huh
19:35:31 <schme2> great. I'll look into that.
19:36:40 <noecksit> now, how exactly does listen terminate?
19:37:00 <noecksit> does it ever terminate since there is "a >> forever a" loop?
19:37:30 <dmwit> noecksit: Check out what eval h "!quit" does.
19:37:33 <schme2> I had some idea that writeFile and readFile worked with strings and it seemed weird converting stuff into strings. :)
19:37:58 <dmwit> schme2: If you want true serialization, you can do that, too.
19:38:07 <JamesR> I'm getting too tired for this
19:38:25 <schme2> dmwit: I just want to write stuff to a file and later read it really. :)
19:38:34 <JamesR> And i've still got a UI to build after the one last evil function
19:39:12 <dmwit> schme2: Yeah, okay, Read and Show are probably fine for intro-level stuff. =)
19:39:36 <dmwit> schme2: When you need speed/compression/etc. then you can crack out the big guns... serialize to ByteString and whatever.
19:39:45 <schme2> dmwit: ok.. I'll try to work out how works then.
19:40:02 <schme2> dmwit: Great.. no I just need to store lists. :)
19:41:38 <noecksit> so exitWith exitSuccess goes to the disconnect function
19:42:08 <noecksit> either that, or the socket automatically gets closed
19:43:15 <dmwit> The socket probably gets closed automatically by your OS.
19:43:22 <schme2> dmwit: 'scuse my question here but how do I use read and show to turn "[1,2,3,4,5,6]\n\n" into a list ?
19:43:36 <schme2> I mean a list like [1..6]. not a list of chars :)
19:43:50 <gwern> does haskell.org use hscolour to parse/highlight?
19:43:51 <dmwit> > read "[1,2,3,4,5,6]"
19:43:52 <lambdabot>  Exception: Prelude.read: no parse
19:43:56 <schme2> hmm.
19:43:58 <dmwit> > read "[1,2,3,4,5,6]" :: [Int]
19:43:59 <lambdabot>  [1,2,3,4,5,6]
19:44:00 <schme2> I think I tried that :S
19:44:16 <chessguy> @docs
19:44:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
19:44:31 <dmwit> read is polymorphic in the return type, so if it has no way to infer the return type, you have to tell it explicitly.
19:44:52 <schme2> I do read (readFile "bengbeng") and I get like 10 lines of errors :)
19:44:55 <schme2> hmm
19:45:03 <monochrom> > read "[1,2,3,4,5,6]\n\n" :: [Int]
19:45:04 <lambdabot>  [1,2,3,4,5,6]
19:45:11 <schme2> ok ok.
19:45:21 <dmwit> schme2: Oh, yeah, try this instead:
19:45:29 <dmwit> fmap read (readFile "bengbeng")
19:45:30 <monochrom> Don't worry, I was just trying to see if \n\n made a difference.
19:45:37 <schme2> monochrom: :)
19:45:44 <dmwit> schme2: readFile returns a value in the IO monad.
19:45:56 <byorgey> @type readFile "bengbeng"
19:45:58 <lambdabot> IO String
19:46:02 <byorgey> @type read
19:46:03 <lambdabot> forall a. (Read a) => String -> a
19:46:06 <dmwit> schme2: And "read" only knows about bare values, so you have to stick "read" into the IO monad for that to work.
19:46:18 <dmwit> :t fmap read
19:46:20 <lambdabot> forall a (f :: * -> *). (Functor f, Read a) => f String -> f a
19:46:27 <schme2> yes yes.. well the fmap thing gave roughly half the same error.
19:46:38 <dmwit> (IO is an instance of Functor.)
19:46:45 <schme2> well I'll just go to work and figure it out.
19:46:48 <schme2> thanks
19:47:04 <dmwit> schme2: You're likely using the result of "fmap read" as a bare value, when it is *also* in the IO monad. =)
19:47:04 <schme2> mm
19:47:09 <dmwit> Once you're in, you're in for good.
19:47:31 <schme2> read (readFile "bengbeng") :: Int    seemed not to work either as I was hoping
19:47:33 <schme2> oh well.
19:47:44 <schme2> I miss mah #'read and #'write here (:
19:47:44 <dmwit> Right, it has to be in the IO monad still.
19:47:55 <dmwit> fmap read (readFile "bengbeng") :: IO Int
19:48:04 <byorgey> you could also do something like this:  do { contents <- readFile "bengbeng"; putStrLn (process contents) }
19:48:23 <monochrom> do { ... ; x <- fmap read (readFile "xxx");  ... process x ... }
19:48:24 <dmwit> byorgey: Good suggestion, do notation is nice at the beginning.
19:48:24 <byorgey> and then 'process' is a pure function  String -> String  which takes the contents of the file as input and produces whatever output you like.
19:48:34 <schme2> dmwit: Exception: Prelude.read: no parse ;)
19:48:51 <dmwit> schme2: Well, then your file doesn't contain an Int. =)
19:49:09 <schme2> dmwit: the file contains exactly :   [1,2,3,4,5,6]\n\n
19:49:18 <dmwit> schme2: That's [Int], not Int. ;-)
19:49:38 <schme2> oh
19:49:40 <dmwit> So same as before, but ... :: IO [Int]
19:49:41 <schme2> ya that works. great.
19:49:44 <schme2> thanks
19:49:46 <chessguy> @pl \c s -> l s (f c)
19:49:46 <lambdabot> flip l . f
19:50:53 <schme2> Btw. I'm having some problems building ghc. Would this be a good place to ask stuff concerning that?
19:51:44 <dmwit> Yes, here or #ghc.
19:51:49 <chessguy> @pl \c s p -> i s p (f c)
19:51:50 <lambdabot> flip (flip . i) . f
19:51:52 <schme2> Oh there's a #ghc :D
20:00:57 <gwern> dmwit: do you have a link to the highlithing problem of yours?
20:01:11 <dmwit> It's on the "roll your own IRC bot" page.
20:01:14 <dmwit> One second.
20:01:36 <dmwit> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot#Talking_IRC
20:01:38 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/y4prf8
20:02:54 * gwern sees it
20:14:59 * gwern sends the email and patches to malcolm
20:15:16 <gwern> @seen nomeata
20:15:16 <lambdabot> I saw nomeata leaving #darcs, #xmonad and #haskell 4h 31m 23s ago, and .
20:16:02 <gwern> @ask nomeata if it's not too much trouble, could you add to darcswatch some of the repos I've been sending patches to lately?
20:16:02 <lambdabot> Consider it noted.
20:37:44 <dons> ?pl \(x,y) -> x / fromIntegral y
20:37:44 <lambdabot> uncurry ((. fromIntegral) . (/))
20:38:37 <dons> ?pl \(x,y) -> y / fromIntegral x
20:38:37 <lambdabot> uncurry (flip (/) . fromIntegral)
20:38:59 <sjanssen> uncurry (/) . second fromIntegral
20:40:08 <sjanssen> lambdabot should learn the arrow combinators
20:40:37 <dobblego> you going to teach it? :)
20:41:08 <sjanssen>  @pl code is nasty'
20:41:19 <dons> yeah, its pre-arrows though
20:41:24 <dons> we didn't know how to use them
20:42:26 <dons> so i'm forming up my position on reasoning about haskell: read the core, and reason about that.
20:42:34 <dons> then its all clear.
20:42:43 <dons> so, to make that easier for people, we need better core tools
20:43:11 <dons> once you learn a bit of the transformation process to core, then you can avoid looking at it, since you know the transformations
20:43:42 <sjanssen> I don't think you need to read core
20:43:46 <dons> but until people start looking, regularly, at the compilation strategy, we're going to continue to have mystified people.
20:43:54 <sjanssen> well, maybe for exact details about strictness analysis and stuff
20:44:00 <dons> for exactly details, yes.
20:44:07 <dons> otherwise, there's pretty simple rules to follow.
20:44:13 * sjanssen is still never sure when strictness analysis will fire
20:44:22 <dons> right. that turns out to be pretty reliable, i've found.
20:44:28 <dons> but now i'm reading core on every compile
20:44:35 <dons> if its demanded, its strictified
20:44:46 <dons> and then, if its an Int or other primitive type, its strictified
20:44:55 <dons> if its a strict field, its strictified
20:44:56 <dons> that's it.
20:45:31 <sjanssen> will uncurry (/) . foldl' (\(s, n) x -> (s + x, n)) (0, 0) be correctly analyzed?
20:45:32 <thetallguy> dons: I think that's an excellent point. (until people start looking...)
20:45:55 <dons> sjanssen: yep. assuming you give it type information about 'n' and 's'
20:46:03 <dons> if its inferred as Integer, it will be slower. but ok.
20:46:14 <sjanssen> > uncurry (/) . foldl' (\(s, n) x -> (s + x, n + 1)) (0, 0) $ [1 .. 1e6]
20:46:19 <lambdabot>  Exception: stack overflow
20:46:22 <sjanssen> nope
20:46:38 <dons> oh sorry, that's  a lazy pair
20:46:46 * dons lives in strict pairs these days
20:46:51 <sjanssen> this is exactly what I mean
20:47:00 <dons> see rule 3.
20:47:04 <dons> 20:44  dons> if its a strict field, its strictified
20:47:12 <sjanssen> I don't think it is good enough to require strict pairs
20:47:34 <dons> we can't break apart that pair unless its strictified somehow.
20:47:38 <dons> there's no information for the analysis
20:47:54 <dons> if we had a foldl'rnf itd be ok.
20:48:15 <dons> strict pairs, maybes and lists should be in the base lib.
20:48:25 <dons> they're so useful in this funny mixed strict/lazy language we call haskell
20:48:29 <sjanssen> I don't think that is good enough
20:48:32 <sjanssen> of course, they're useful
20:48:43 <JamesR> Thank you very much for the help guys, not sure if I'll ever have to use Haskell again, but if I do you can bet i'll drop by ;)
20:48:50 <dons> remember you're encoding register variables in that pair, sjanssen.
20:48:59 <sjanssen> but they're yet another module to learn, another concept to teach newbies, another thing for me to remember to type
20:48:59 <dons> so they have to be unlifted somehow.
20:49:02 <sjanssen> dons: no, I'm not
20:49:07 <sjanssen> I'm writing an average function
20:49:34 <dons> well, using a pair in an accumulator is code for a for loop with 2 parameters in registers.
20:49:57 <dons> we could ask SPJ nicely why lazy pairs are so so lazy
20:50:30 <dons> if its a foldl' , so we know its going to be demanded to the pair constructor, and the innards are Int,
20:50:40 <dons> maybe there's enough there for the strictness analyser..
20:50:49 <sjanssen> that's the problem with questioning strictness analysis, it often reduces to "ask SPJ" :)
20:51:19 <dons> but isn't it obvious that the pair constructor is going to cause a space leak, as it won't be strict enough/
20:51:21 <dolio> Does foldl' even make a difference in that case?
20:51:23 <dons> foldl' isn't a deep seq
20:51:37 <sjanssen> > uncurry div . foldl' (\(s, n) x -> (s + x, n + 1)) (0 :: Int, 0) $ [1 .. 1e6]
20:51:38 <dolio> \(s, n) x -> (s + x, n + 1) is already strict in the pair constructor.
20:51:38 <lambdabot>   add an instance declaration for (Fractional Int)
20:51:38 <lambdabot>     In the expression: 100...
20:51:46 <dons> if it was, you could have arbitrarily deep data in the accumulator safely
20:51:50 <sjanssen> > uncurry div . foldl' (\(s, n) x -> (s + x, n + 1)) (0 :: Int, 0) $ [1 .. 1000000]
20:51:52 <lambdabot>  Exception: stack overflow
20:51:52 <dons> but its the typical WHNF strictness
20:52:24 <sjanssen> dolio: no, it doesn't
20:52:37 <sjanssen> because it is just seq'ing a constructor application
20:52:41 <Saizan> dons: but if you don't demand the resulting tuple the pattern matching never occurs
20:52:42 <dons> $wlgo :: Int -> Int -> [Int] -> (# Int, Int #)
20:53:38 <geezusfreeek> i have a friend asking me how feasibly a haskell->parrot compiler would be. based on previous judgements of the same question about llvm here, i think unfeasible. does anybody have some differing opinions?
20:54:07 <dolio> > uncurry div . foldl' (\(s, n) x -> (s + x, n + 1)) (0 :: Int, 0) $ [1 .. 1000000] :: Int
20:54:10 <lambdabot>  Exception: stack overflow
20:54:15 <Saizan> with foldl you'd get a big thunk at the tuple level that will produce a tuple with other two big thunks inside (assuming we don't get a stack overflow early), i think
20:54:17 <dons> $s$wlgo :: [Int] -> Int# -> Int# -> (# Int, Int #)
20:54:36 <sjanssen> dolio: I gave enough type information to constrain everything to Int the first time
20:54:52 <dolio> Oh, right. I missed the Int there.
20:55:12 <dons> > foldl' (\s x -> (s + x) (0 :: Int, 0) $ [1 .. 1000000]
20:55:12 <lambdabot> Unbalanced parentheses
20:55:17 <dons> > foldl' (\s x -> (s + x) (0) $ [1 .. 1000000]
20:55:17 <lambdabot> Unbalanced parentheses
20:55:21 <dons> > foldl' (\s x -> (s + x)) (0) $ [1 .. 1000000]
20:55:22 <lambdabot>  500000500000
20:55:29 <dons> fold' considered not strong enough
20:55:36 <dons> strict pairs considered not common
20:55:44 <sjanssen> GHC will even figure it out if ordinary foldl is used, I reckon
20:55:49 <dons> that's right.
20:55:52 <dobblego> a functor is F x -> (x -> y) -> F y; what is T x -> (x -> y) -> (y -> x) -> T y ?
20:55:53 <dons> that's new with 6.8
20:56:03 <dons> > foldl (\s x -> (s + x)) (0::Int) $ [1 .. 1000000]
20:56:04 <lambdabot>  1784293664
20:56:12 <dons> > foldl (\s x -> (s + x)) (0::Int64) $ [1 .. 1000000]
20:56:14 <lambdabot>  500000500000
20:56:21 <dons> > foldl (\s x -> (s + x)) (0::Integer) $ [1 .. 1000000]
20:56:22 <lambdabot>  500000500000
20:56:30 <Saizan> dobblego: invariant functor, or expfunctor
20:56:32 <dons> > foldl (\s x -> (s + x)) (0::Rational) $ [1 .. 1000000]
20:56:35 <lambdabot>  500000500000%1
20:56:40 <dobblego> Saizan, great thanks
20:56:52 <Saizan> dobblego: your F is a covariant functor
20:56:53 <dons> sjanssen: so, how do we teach this?
20:57:01 <dons> foldl' should have better docs.
20:57:05 <dons> it isn't strict in the accumulator
20:57:13 <dons> its whnf strict.
20:57:35 <roconnor> for god sake, someone make a rewrite rule sum [a..b] -> (a+b)*(a-b+1)`div`2
20:57:56 <dons> heh. doesn't that rely on some magic about the Enum class? :)
20:59:01 <sjanssen> roconnor: sum [2 .. 0]
20:59:08 <sjanssen> > sum [2 .. 0]
20:59:10 <lambdabot>  0
20:59:35 <sjanssen> > (\a b -> (a + b) * (a - b + 1) `div` 2) 2 0
20:59:36 <lambdabot>  3
20:59:39 <dobblego> > (2+0) * (2 - 0 + 1) `div` 2
20:59:40 <lambdabot>  3
20:59:57 <roconnor> hmm
21:00:08 <roconnor> I need a coq proof before I do rules
21:00:43 <geezusfreeek> > [2..0]
21:00:45 <lambdabot>  []
21:00:46 <geezusfreeek> ah
21:02:46 <dobblego> > 5 ^ 0
21:02:47 <Saizan> is there a paper about Data.Reactive?
21:02:48 <lambdabot>  1
21:02:57 <dobblego> what is XOR?
21:03:12 <dmwit> > 5 .^. 0
21:03:13 <lambdabot>   Not in scope: `.^.'
21:03:20 <dmwit> > xor 5 0
21:03:20 <lambdabot>  Add a type signature
21:03:24 <dmwit> > xor 5 0 :: Int
21:03:25 <lambdabot>  5
21:03:33 <dobblego> ah thanks
21:03:42 <dobblego> ?type xor
21:03:46 <lambdabot> forall a. (Bits a) => a -> a -> a
21:04:11 <geezusfreeek> Saizan: not about Data.Reactive _specifically_, but there is a new paper out based on the same ideas‚Ä¶ you can find it as conal.net/blog, i believe
21:04:34 <geezusfreeek> Saizan: http://conal.net/blog/posts/simply-efficient-functional-reactivity/
21:04:35 <lambdabot> Title: Conal Elliott ª Blog Archive ª Simply efficient functional reactivity, http://tinyurl.com/6ma42k
21:05:09 <newsham> anyone knowledgable in agda2 and xemacs?
21:06:38 <dolio> xemacs?
21:07:49 <gwern> "The bad news is, analyzing Alloy specifications is 3-SAT, so it's exponential and NP-complete. But the good news is that analyzing Alloy specifications is 3-SAT, so we can solve it really quickly."
21:07:50 <newsham> does agda2-mode want emacs?
21:08:07 <dolio> I use emacs.
21:08:14 <newsham> ahh, i'll try that then
21:08:28 <newsham> xemacs is not grokking the files properly
21:09:19 <dolio> dons: Sorting vectors might be handy.
21:12:40 <Saizan> geezusfreeek: thanks :)
21:22:02 <newsham> dolio: does agda have a standard library?  any advice for figuring out how to use it?
21:22:11 <newsham> (so far been doing everything in a single standalone file with all defs)
21:22:33 <dolio> newsham: http://appserv.cs.chalmers.se/users/ulfn/wiki/agda.php?n=Libraries.StandardLibrary
21:22:35 <lambdabot> Title: 20 The Agda Wiki - Standard Library 4b, http://tinyurl.com/5n823v
21:22:51 <dolio> I haven't used it much. I went and defined a bunch of modules of my own to play around with.
21:23:06 <newsham> so this lib doesnt ship with the Agda2 dist?
21:23:10 <dolio> Although I peeked some at the standard library some.
21:23:19 <dolio> No, it's in its own darcs repo.
21:23:25 <conal> Saizan: that paper describes a successor to Reactive.  big overlap in ideas with Reactive, but removes the semantic indeterminacy.
21:39:54 <newsham> dolio: is there some file that explains how to use emacs interactively with agda?
21:43:27 <OceanSpray> Guys, I got
21:43:29 <OceanSpray> SICP
21:43:39 <OceanSpray> K&R
21:43:53 <OceanSpray> and the dragon book.
21:43:58 <OceanSpray> which do I read through first?
21:44:11 <newsham> what are you trying to accomplish?
21:44:12 <thetallguy> sicp
21:44:21 <OceanSpray> newsham, learning.
21:44:26 <dolio> newsham: Yeah. One of the readme files in the agda repository explains it.
21:44:33 <newsham> you can learn from any one of those :)
21:44:37 <thetallguy> Well, in that case, it doesn't matter what order.
21:44:50 <OceanSpray> I'm trying to maximize comprehension.
21:45:04 <thetallguy> Damn.  That's ambitious
21:45:21 <newsham> the README says how to install it but it doesnt say how to use it.
21:45:49 <newsham> other than that, emacs is mentioned in: TODO, notes/design/report, src/fullInteraction/{Optoins.hs,GhciTop.hs,eacs-mode/agda2-mode.el}
21:47:06 <thetallguy> OceanSpray: the picture is out of focus.  Why those three books?
21:47:22 <dolio> Oh, well, there's an Agda menu or something that shows all/most of the commands you can do.
21:47:32 <OceanSpray> Because those three are the only CS books I have at disposal.
21:47:50 <newsham> dolio: *nod* saw that.  whats the goal stuff?  how do I make goals and get it to help me with them?
21:48:03 <OceanSpray> Pierce's "Types and Programming Languages" is on the way.
21:48:07 <newsham> (is it similar enough to old agda that I can just read their docs?)
21:48:28 <newsham> oceanspray: they cover pretty different areas.  you can read them in any order
21:48:30 <dolio> newsham: Put a ? in somewhere.
21:48:50 <dolio> It will take the place of an expression, and it will say what type it's expected to be in the bottom window.
21:49:15 <OceanSpray> still, a plan of attack would be nice.
21:49:25 <dolio> {! !} also works.
21:49:32 <newsham> what is {! !} ?
21:49:37 <dolio> I think you can do more with them, but I haven't done much experimenting.
21:49:44 <OceanSpray> Let's FIND OUT
21:49:54 <dolio> {! !} is like ?, only you can type stuff in the middle.
21:50:20 <dolio> Man, smooth sort is heinous.
21:50:31 <newsham> hmm.. I did    foo : <some type>\n foo <args> = ?    and nothing special
21:50:40 <newsham> show goals menu shows nothing
21:50:59 <dmwit> dolio: link?
21:51:23 <newsham> ahh, found stuff thats simliar to what you're describing on the old catarina agda web page
21:51:26 <newsham> i'll read through that.
21:51:27 <newsham> thx
21:52:17 <dolio> dmwit: http://www.cs.utexas.edu/~EWD/transcriptions/EWD07xx/EWD796a.html
21:52:17 <lambdabot> Title: E.W.Dijkstra Archive: Smoothsort, an alternative for sorting in situ (EWD 796a)
21:53:18 <dolio> It's got, like, 9 integer variables that get mutably updated all over the place.
21:54:05 <dmwit> Have you seen timsort?
21:54:53 <dolio> Nope.
21:55:13 <dmwit> http://svn.python.org/projects/python/trunk/Objects/listsort.txt
22:39:36 <dmwit> Suddenly, an œâ appears!
22:40:12 * vegai puts on his robe and wizard hat
22:57:43 <cjs> Hmm. So another thing for which there must be a cool fix:
22:59:48 * dmwit breathes in anticipation
22:59:56 <cjs> I have a ParseState in my monadic parser, which as well as the ByteString to be parsed, the current position, etc.,  contains a "parse stack" that I use for debugging parse errors. When I enter a combinator, I do a 'pushStack "fooParser", and just before I return I do a 'popStack'. When I encounter a parse error of some sort, my ParseState thus has a list of all the combinators I was going through, so I can see exactly where I went wrong.
22:59:56 <dmwit> You're killing me!
23:00:16 <cjs> How might I set this up so that stuff happens automatically as I combine the combinators?
23:00:44 <quicksilver> change the combinators you use to combine.
23:01:04 <quicksilver> however note that there is no way to get "the name of this current function being defined now"
23:01:10 <cjs> Err...I figured that much. :-)
23:01:46 <cjs> http://hpaste.org/7610
23:02:25 <cjs> I can see the issues with getting the name of "the current function." But maybe I can at least get rid of the "popStack" somehow?
23:04:43 <cjs> BTW, writing my own parser was definitely the right idea, I think. Not only am I learning useful general techniques, but it seems as if it might be easier to customize to deal with some of my particular issues.
23:05:10 <cjs> quicksilver: Hey, I can get, however, __FILE__ and __LINE__. :-) (Ewww. cpp.)
23:05:52 <quicksilver> yes
23:06:04 <quicksilver> just do "withName "glLength" $ do"
23:06:28 <cjs> Ah, of course!
23:06:30 <quicksilver> withName x act = do { pushStack x; r <- act; popStack x; return r}
23:06:37 <cjs> You're so smart.
23:06:39 <quicksilver> this is a very very common idiom.
23:06:42 <quicksilver> why thankyou.
23:07:10 <dmwit> withName x act = pushStack x >> act <* popStack x -- ?
23:07:20 <dmwit> :t (<*) -- I can never remember the name of this thing
23:07:23 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
23:07:57 <quicksilver> well if you're gong to use the *s, use both
23:08:07 <quicksilver> pushStack x *> act <* popStack x
23:08:13 <quicksilver> the arrows point to the bit you care about
23:08:17 <dmwit> That's pretty.
23:08:21 <quicksilver> (I.e. the bit which returns a value)
23:08:21 <dmwit> The symmetry is nice.
23:08:28 <dmwit> quicksilver: Ah, good mnemonic.
23:41:14 <dolio> Man, moving from heapSort to heapSortBy made my test program take twice as long.
23:43:13 <dmwit> Time to use heapSortByDSU?
23:43:45 <dolio> DSU?
23:43:54 <dmwit> decorate-sort-undecorate
23:44:20 <Pseudonym> Schwartzian transform?
23:44:24 <dmwit> yes
23:44:29 * Pseudonym nods
23:44:37 <dmwit> I feel like we just had this argument last night. ;-)
23:44:58 <Pseudonym> Easier in Haskell because you can make a pair type that only sorts on the first element.
23:46:10 <bd_> :t heapSortBy
23:46:14 <lambdabot> Not in scope: `heapSortBy'
23:46:20 <bd_> :t Data.List.heapSortBy
23:46:22 <lambdabot> Not in scope: `Data.List.heapSortBy'
23:46:26 <bd_> @hoogle heapSortBhy
23:46:26 <lambdabot> No matches found
23:46:27 <bd_> @hoogle heapSortBy
23:46:28 <lambdabot> No matches found
23:46:29 <bd_> hmm
23:46:35 <bd_> new in HEAD?
23:46:54 <dmwit> Probably written by dolio.
23:48:20 <bd_> hmm, why would it be so much slower? I'd think invoking a passed-in function would be no worse than calling compare through a vtable
23:48:52 <thetallguy> I think he means it makes the program text longer
23:49:05 <bd_> take twice as long <-- usually refers to time
23:49:29 <thetallguy> Oh, you're right.  Eyes are tired, I guess.
23:50:34 <dmwit> bd_: Well, if the comparison function he's passing in is twice as expensive as the default comparison...
23:51:28 <dolio> ~ 14 seconds for heap sort with inline (<), ~ 28 seconds for 'heapSortBy compare'
23:54:05 <bd_> does a {-# INLINE heapSortBy #-} help, I wonder?
23:54:10 <dmwit> huh
23:54:41 <bd_> plus any dependent functions I suppose
23:56:12 <dolio> Ah, yeah, that's doing the trick.
23:57:41 <bd_> nice :)
23:59:45 <dolio> They're on par with each other when inline pragmas are given for both.
