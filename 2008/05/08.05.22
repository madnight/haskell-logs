00:00:05 <tieTYT2> as I have only thought of using (x:xs), a, or [] to pattern match a list
00:00:09 <EvilTerran> also, you don't need to bracket the parameter to length or head, there
00:00:19 <tieTYT2> oh right
00:00:21 <tieTYT2> sorry, habbit
00:01:31 <tieTYT2> ok i did this: myLast (_:xs) = myLast xs
00:01:34 <tieTYT2> seems to work
00:01:37 <Cale> right
00:02:00 <wolgo> SHIT
00:02:02 <tieTYT2> any haskellisms i'm missing?
00:02:09 <vixey> wolgo: what?
00:02:13 <Cale> @src last
00:02:13 <lambdabot> last [x]    = x
00:02:13 <lambdabot> last (_:xs) = last xs
00:02:13 <lambdabot> last []     = undefined
00:02:20 <wolgo> I GET IT
00:02:21 <Cale> Nope, that's the actual definition :)
00:02:32 <tieTYT2> oh it specifically puts last [] = undefined huh?
00:02:39 <tieTYT2> should i have done that?
00:02:40 <Cale> tieTYT2: That's just @src
00:02:53 <tieTYT2> what's that mean?
00:02:53 <Cale> tieTYT2: I think the real version supplies an error message
00:02:59 <paolino> myLast = myLast.tail should have worked, but doesn't
00:03:00 <tieTYT2> oh
00:03:07 <Cale> The @src command has its own database of code.
00:03:16 <wolgo> pow x y = (pow x (y - 1)) * x and this works because it just multiplies x * num_times_recursed
00:03:27 <vixey> why not head . reverse
00:03:31 <wolgo> well, x * x the number of times
00:03:34 <tieTYT2> i haven't learned .
00:03:46 <EvilTerran> paolino, how could that work?
00:04:14 <paolino> :t last.tail
00:04:16 <lambdabot> forall a. [a] -> a
00:04:18 <Cale> EvilTerran: He's proposing it as a catch-all case after  myLast [x] = x
00:04:22 <EvilTerran> ah, i see
00:04:27 <vixey> > let l [x] = x  ; l = l . tail in l [1,2,3,4,5,6]
00:04:28 <lambdabot>  1:17-28
00:04:28 <lambdabot>     In the expression:
00:04:28 <lambdabot>         let
00:04:28 <lambdabot>           l [x] = x
00:04:28 <lambdabot>           l =...
00:04:35 <vixey> > let l [x] = x  ; l x = l . tail $ x in l [1,2,3,4,5,6]
00:04:37 <lambdabot>  6
00:04:45 <vixey> > let l = head . reverse in l [1..6]
00:04:47 <lambdabot>  6
00:04:50 <EvilTerran> but you need the same number of parameters in all patterns in a definition
00:04:57 <Cale> right
00:04:57 <EvilTerran> for some reason
00:05:06 <paolino> that I don't get
00:05:09 <Cale> Probably for readability's sake.
00:05:16 <EvilTerran> true
00:05:20 <Cale> It's easier to check which cases are caught.
00:08:10 <olsner> but you can't write things like let safeLastPlusOne [] = error ""; safeLastPlusOne = (+1) . last
00:10:30 <paolino> Cale, tou say human should parse definitions of a funcion in random order ?
00:11:05 <Cale> paolino: It's nicer when they can.
00:11:55 <EvilTerran> Cale, you're also a fan of non-intersecting patterns, then?
00:12:08 <Cale> yeah.
00:12:18 <EvilTerran> in which case last should be "last [x] = x; last _:xs@(_:_) = last xs" :P
00:13:37 <paolino> to force a non empty xs ?
00:13:43 <edwardk> I know in kata i have a technical limitation which requires all definitions to have the same number of parameters due to how i have to handle backtracking in pattern matching between terms.
00:14:01 <edwardk> you may have a similar issue here
00:14:11 <EvilTerran> paolino, exactly
00:16:23 <ski__> roconnor : the categorification is `equivalences', i think
00:17:06 <paolino> @babel en it categorification
00:17:07 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
00:18:11 <paolino> which means i miss a parameter ?
00:18:15 <edwardk> ski: how are you with kan extensions?
00:18:20 <ski__> roconnor : hm, or maybe not
00:18:33 <ski__> roconnor : `f' and `g' would be pseudo-inverses iff `f . g . f = f' and `g . f . g = g'
00:19:03 <edwardk> there is a galois connection between them no?
00:19:32 <edwardk> or is there an unstable answer?
00:19:45 <ski__> edwardk : mostly i have some idea that it's about left and right adjunctions to functors of the form `(F .)' (or `(. F)' ?) .. not much more concrete
00:20:26 <edwardk> ski: was wondering if you felt like taking a once over on http://comonad.com/haskell/category-extras/src/Control/Functor/KanExtension.hs and seeing if there was anything you could think of to clean it up
00:20:27 <lambdabot> http://tinyurl.com/5o84vg
00:21:58 * ski__ wonders why chalmers.se apparently went down ..
00:22:41 <edwardk> I think everything left in that file is pretty straightforward. i'm not happy about moving some of the adjunction stuff there, but meh
00:29:39 <wolgo> Hey, I see things with a type signature of say, Int -> a -> [a]. How can I create a signature that allows any type as an argument?
00:29:45 <wolgo> I tried the above
00:30:10 <dmwit> wolgo: That type signature should be fine, what went wrong?
00:30:32 <EvilTerran> ?type replicate
00:30:36 <lambdabot> forall a. Int -> a -> [a]
00:30:38 <wolgo> yeah
00:30:55 <wolgo> like replicate, zip, map and things like that
00:30:58 <wolgo> ?type map
00:31:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:31:06 <vixey> don't bother writing down the signatures
00:31:18 <wolgo> oh...
00:31:19 <wolgo> ok
00:31:34 <wolgo> I should only do that when I need to be absolutely sure of types?
00:31:43 <EvilTerran> if you were defining replicate, you could literally write "replicate :: Int -> a -> [a]" in the source file
00:31:54 <dmwit> wolgo: People often write type signatures as documentation.
00:31:57 <vixey> I only write types signatures down when they make things clearer (or I am forced to)
00:32:10 <dmwit> wolgo: (And what do you mean by "absolutely sure of types"?)
00:32:38 <wolgo> So something doesn't get an incorrect type
00:32:40 <ski__> wolgo : if you already have a good idea what type you expect, then it can be a good idea to write the type signature down as you start (it can make finding errors easier), also it's a kind of documentation
00:32:52 <dmwit> wolgo: If it got an incorrect type, annotating it will not help.
00:33:01 <ski__> wolgo : however, some prefer to have as little type signatures as possible ..
00:33:33 <dmwit> wolgo: Except in a very small number of cases, where something can get a slightly restricted (less polymorphic) type.
00:33:49 <wolgo> Oh ok
00:33:55 <dmwit> wolgo: That is, if the inferred type is just plain wrong, it means your implementation is certainly wrong.
00:34:19 <EvilTerran> i often find it helps me think of how to write a function by writing its type down first
00:34:31 <EvilTerran> quite often the definition is trivial to derive from the type
00:41:24 <tieTYT2> how about this: myInit [x] = []
00:41:27 <tieTYT2> myInit (x:xs) = x : myInit xs
00:41:45 <vixey> tieTYT2: and?
00:41:48 <dmwit> tieTYT2: Looks good!
00:41:49 <tieTYT2> thats it
00:42:02 <vixey> reverse . tail . reverse
00:42:04 <tieTYT2> but it seems to go through the whole list to accomplish it.  Is there a way to avoid that?
00:42:14 <dmwit> newp
00:42:28 <tieTYT2> vixey: is that more efficient?
00:42:30 <vixey> no you certainly have to go through the entire list, the end is never known until you're there
00:42:39 <vixey> mine is less efficient
00:42:45 <dmwit> tieTYT2: No, vixey's is probably way less efficient.
00:42:48 <tieTYT2> oh
00:42:56 <vixey> dmwit O(n) vs O(n)
00:43:01 <dmwit> tieTYT2: In fact, his fails in the following interesting way:
00:43:05 <vixey> hers
00:43:17 <dmwit> sorry
00:43:29 <dmwit> > let vixey = reverse . tail . reverse in vixey [1..]
00:43:32 <vixey> but yeah good point about infinite lists
00:43:34 <lambdabot> Terminated
00:43:47 <dmwit> > let vixey = reverse . tail . reverse in head $ vixey [1..]
00:43:51 <lambdabot> Terminated
00:44:06 <wolgo> aha!
00:44:11 <dmwit> > let tieTYT2 [x] = []; tieTYT2 (x:xs) = x : tieTYT2 xs in head $ tieTYT2 [1..]
00:44:12 <lambdabot>  1
00:44:19 <wolgo> I am slowly getting a hang of this recursion stuff
00:44:37 <wolgo> ?type replicate
00:44:39 <lambdabot> forall a. Int -> a -> [a]
00:44:57 <dmwit> tieTYT2: In other words, vixey's version must traverse the entire list once before it can produce even one element of the result, whereas yours has nice laziness properties.
00:45:04 <wolgo> > :t replicate
00:45:04 <lambdabot>   parse error on input `:'
00:45:09 <dmwit> :t replicate
00:45:11 <lambdabot> forall a. Int -> a -> [a]
00:45:20 <tieTYT2> if I have the list [1,2,3], why does the pattern (x:xs) bind to 1/2,3 instead of 1,2/3?  Is it just the way haskell works?
00:45:32 <dmwit> :t (:)
00:45:33 <lambdabot> forall a. a -> [a] -> [a]
00:45:45 <dmwit> tieTYT2: 1,2 is not an a, it's an [a].
00:46:05 <tieTYT2> ah
00:46:10 <tieTYT2> oh yeah, right
00:46:12 <dmwit> tieTYT2: Also, (:) is infixr, so that resolves the remaining cases.
00:46:13 <vixey> [1,2,3] = 1:(2:(3:([])))
00:46:25 <vixey> [,,] is just syntax
00:47:21 <tieTYT2> why did lambdabot say forall a. there
00:47:27 <tieTYT2> i've never seen ghci say that
00:47:33 <dmwit> It's an extension.
00:47:45 <dmwit> Sometimes, "a" simply isn't polymorphic enough. =P
00:48:03 <tieTYT2> o_O
00:48:04 <tieTYT2> ok
00:48:16 <dmwit> tieTYT2: Consider the difference between these two types:
00:48:25 <dmwit> a -> (forall b. b -> c) -> d
00:48:33 <dmwit> a -> (b -> c) -> d
00:48:49 <dmwit> The second one restricts "b" to be a single type throughout the entire body of the function.
00:49:07 <dmwit> The first one does not; "b" can be different types in different parts of the function definition.
00:49:33 <vixey> @src on
00:49:34 <lambdabot> (*) `on` f = \x y -> f x * f y
00:50:15 <tieTYT2> dmwit: but b is only used once
00:50:26 <dmwit> tieTYT2: It's only used once in the *type*.
00:50:32 <dmwit> But it could be something like
00:51:02 <dmwit> f a weirdFunction = weirdFunction x + weirdFunction y
00:51:52 <dmwit> Now "x" and "y" could be values with two different types.
00:52:01 <dmwit> The first type allows this; the second does not.
00:52:28 <tieTYT2> but wouldn't it always be invalid to do f?
00:52:37 <tieTYT2> actually
00:52:43 <dmwit> Well, this is a bad example.
00:52:50 <tieTYT2> this is delving into areas about haskell that i don't know exist
00:53:03 <tieTYT2> does the first type restrict polymorphism too?
00:53:03 <chr1s> tieTYT2: in theory, all free variables are universally quantified over
00:53:07 <dmwit> But yeah, this is a pretty rare extension to use.
00:53:26 <chr1s> so when you see a type of a function like map's type (a -> b) -> [a] -> [b]
00:53:33 <dmwit> tieTYT2: Sure, c is still restricted a bit.
00:53:41 <mxc> this question will betray my sprawling ignorance, but it is possible to 'override' the behavior of Show::Double->String to change the way doubles are printed?
00:53:49 <vixey> :t (&&&)
00:53:52 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
00:53:56 <chr1s> what you should really read there is forall a b . (a -> b) -> [a] -> [b]
00:53:58 <dmwit> mxc: You can create a newtype, that's about the closest it comes.
00:54:01 <vixey> :t (***)
00:54:03 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
00:54:51 <chr1s> it's called polymorphism, because the function works on whatever a or b you choose
00:55:59 <dmwit> :t let weird f = f "hello" + f 32 in weird
00:56:01 <lambdabot>     No instance for (Num [Char])
00:56:01 <lambdabot>       arising from the literal `32' at <interactive>:1:28-29
00:56:01 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
00:56:22 <chr1s> and then sometimes you'll have to help the haskell-compiler a bit, and you'll do explicit universal quantification
00:57:01 <chr1s> tieTYT2: http://en.wikibooks.org/wiki/Haskell/Polymorphism
00:57:10 <dmwit> > let weird :: forall a. Num a => (forall b. b -> a) -> a; weird f = f "hello" + f 32 in weird (const 5)
00:57:10 <lambdabot>  Parse error at "." (column 22)
00:57:35 <dmwit> :t let weird :: forall a. Num a => (forall b. b -> a) -> a; weird f = f "hello" + f 32 in weird
00:57:37 <lambdabot> forall a. (Num a) => (forall b. b -> a) -> a
00:58:00 <dmwit> tieTYT2: There's an example of a function that can type correctly, but only if you use a forall.
00:58:25 <dmwit> (See above, where it complained about the "No instance for (Num [Char])" as proof that it doesn't type otherwise.)
01:05:36 <tieTYT2> sorry over my head
01:05:40 <tieTYT2> and i'm really distracted right now
01:05:45 <tieTYT2> didn't mean to waste your time :(
01:08:02 <dmwit> It's okay, you shouldn't need those for a really long time.
01:08:08 <dmwit> (I never have.)
01:09:26 <pjdelport> dmwit: zany
01:15:17 <quicksilver> mxc: you shouldn't want to.
01:15:31 <quicksilver> mxc: Show is special, its designed to produce haskell readable stuff
01:15:49 <quicksilver> mxc: if you want to format your double differently, try showEFloat showFFloat and showGFloat
01:16:13 <dolio> @yow!
01:16:13 <lambdabot> ... he dominates the DECADENT SUBWAY SCENE.
01:16:19 * dolio is relieved.
01:16:30 <vixey> j #lisp
01:16:31 <mxc> quicksilver - thanks
01:32:41 <vixey> lol
01:32:56 <vixey> I was in GHCi
01:33:16 <vixey> but I thought I was in my repl for the interp I was doing
01:33:34 <vixey> so I was like .. huh? how come this suddennly works 10x better
01:39:18 <quicksilver> vixey: ln -s /usr/bin/ghci vixinterp
01:39:23 <quicksilver> vixey: interpretet complete!
01:39:29 <vixey> hehe
01:40:42 <mxc> what are the chances of a deriving Binary being added to ghc?
01:41:21 <mxc> i guess Data.Binary would need to become official firs
01:41:23 <mxc> first
01:41:44 <mxc> hah
01:41:52 <mxc> (hah is for quicksilver)
01:43:01 <quicksilver> mxc: I have the impression there is not much interest in adding new derivings to ghc.
01:43:20 <quicksilver> mxc: better just to encourage the existing deriving tools liek Data.Derive and DrIFT
01:43:29 <ketil> Anybody use Network.CGI?  I probably have an error in my code, but handleError doesn't seem to.
01:43:49 <ketil> I just get a blank page, unless I comment out the offending parts...
02:04:50 <ketil> @hoogle Network.CGI
02:04:51 <lambdabot> No matches, try a more general search
02:05:07 <ketil> @hoogle runcgi
02:05:07 <lambdabot> No matches found
02:05:55 <ketil> Is there any reason to belive that one of the fastcgi implementation will be more debuggable?
02:11:01 <hpaste>  vicky pasted "lazy lazy" at http://hpaste.org/7806
02:11:15 <hpaste>  vicky annotated "lazy lazy" with "eval" at http://hpaste.org/7806#a1
02:11:27 <hpaste>  vicky annotated "lazy lazy" with "example" at http://hpaste.org/7806#a2
02:11:38 <vixey> such badly written code
02:11:58 <vixey> anyway there is a lazy evaluator in haskell
02:12:09 <vixey> no types, lots of fromJust .. unsafe
02:12:24 <vixey> :p
02:13:25 <vixey> it can run fibs
02:15:06 <mxc> :t liftM
02:15:11 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
02:21:07 <vixey> did anyone see my awful code
02:21:48 <dmwit> case ... of (Lambda ... -> ...) ?
02:22:01 <dmwit> That doesn't seem good. =P
02:22:21 <dmwit> Or, more precisely: allowing
02:22:34 <vixey> I'm not sure what you mean
02:22:54 <dmwit> Case (Var "hey") [(Lambda "bla" (Var "x"), Var "y")] -- doesn't seem good
02:23:03 <vixey> oh yeah
02:23:16 <vixey> that should not happen
02:23:32 <vixey> I'm lazy with this code and didn't put these details into types
02:23:42 <vixey> I just wanted to run fibs :P
02:23:42 <dmwit> ws = many spaces
02:23:48 <vixey> oh cool
02:24:20 <dmwit> You may also like liftM2, if you've never had a look at it.
02:24:22 <dmwit> :t liftM2
02:24:24 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
02:24:55 <dmwit> ident = liftM2 (:) (oneOf lower') (manyOf (lower' ++ upper')) -- for example
02:25:06 <vixey> ahh that's very neat
02:26:01 <dmwit> I would suggest lower' = satisfy isLower, upper' = satisfy isUpper.
02:26:12 <dmwit> Then manyOf lower' --> many lower'
02:29:41 <dmwit> Did you know there's a Language.Haskell?
02:30:09 <dmwit> ?index haskellDef
02:30:10 <lambdabot> Text.ParserCombinators.Parsec.Language
02:30:31 <vixey> yeah I didn't want to have to boil that AST down into my very simple terms though
02:30:47 <dmwit> Fair enough.
02:30:56 <vixey> (because it's tricky)
02:31:38 <EvilTerran> ... what about parsing Core and using that?
02:31:51 <dmwit> Why would he do that?
02:32:11 <dmwit> Sorry, she.
02:32:11 <EvilTerran> i don't have the full context here, i just wandered in
02:32:17 <vixey> Core o_o
02:32:31 <EvilTerran> but it's haskell boiled down into simple terms, so i thought it might be appropriate
02:32:38 <vixey> EvilTerran: If you like http://hpaste.org/7806
02:32:55 <dmwit> It really is pretty impressive overall.
02:33:09 <EvilTerran> hmm
02:36:01 <dmwit> The pattern matching is a bit less powerful than Haskell's, but I think that's okay.
02:36:14 * vixey nod
02:36:19 <vixey> I just have one level deep bindings
02:36:25 <dmwit> right
02:37:38 <dmwit> rewrites looks like a fold, let's see here...
02:39:51 <dmwit> > foldr (fun "rewrite" :: Expr -> Expr -> Expr) (expr $ fun "term") [x, y, z]
02:39:53 <lambdabot>  rewrite x (rewrite y (rewrite z term))
02:40:08 <dmwit> Not quite.
02:40:38 <dmwit> > foldl (fun "rewrite" :: Expr -> Expr -> Expr) (expr $ fun "term") [x, y, z]
02:40:39 <lambdabot>  rewrite (rewrite (rewrite term x) y) z
02:40:43 <vixey> that's it!
02:40:45 <vixey> cool
02:41:22 <EvilTerran> ?type expr.fun
02:41:24 <lambdabot> String -> Expr
02:41:28 <EvilTerran> ?type var
02:41:29 <lambdabot> forall a. String -> Sym a
02:41:38 <dmwit> expr = id :: Expr -> Expr
02:41:39 <EvilTerran> hmmmm?
02:41:47 <dmwit> > var "x"
02:41:49 <lambdabot>  x
02:41:58 <vixey> thanks for your comments :D
02:41:59 <dmwit> Ooh, that is just fiiine. =)
02:42:07 <dmwit> > foldl (fun "rewrite" :: Expr -> Expr -> Expr) (var "term") [x, y, z]
02:42:07 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Sym a'
02:42:14 <EvilTerran> > fun "f" $ var "x" :: Expr
02:42:15 <lambdabot>  f x
02:42:23 <dmwit> > foldl (fun "rewrite") (var "term") [x, y, z]
02:42:23 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr (Sym a))
02:42:36 <EvilTerran> > foldl (fun "rewrite") (var "term") [x, y, z] :: Expr
02:42:37 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Sym a'
02:44:57 * vixey wonders what to do next .
02:45:03 <dmwit> Although it's not clear that either fold is better in this case.
02:45:09 <dmwit> (I think.)
02:46:08 <smg> good morning lads.
02:46:20 <smg> can i use strict application to force "a kind of" tail recursion?
02:46:38 <vixey> smg: You needn't force TCO, it comes naturally
02:47:22 <smg> vixey: how do you mean that?
02:47:35 <dmwit> Tail recursion is fine, just so long as you've got a great whonking stack.
02:47:51 <dmwit> Otherwise, go ahead and force some things.
02:48:24 <smg> i see.
02:48:38 <smg> is there stackless haskell?
02:48:54 <dmwit> I've never heard of such a project.
02:48:54 <agentzh> hi, is there a better way to reduce GC time? -H10M -S10M still gives 60% GC time...oh my...
02:49:14 <agentzh> most of the running time is spent on GC...
02:49:38 <agentzh> " %GC time      63.1%  (60.8% elapsed)"
02:50:35 <quicksilver> try a larger allocation area
02:50:38 <dmwit> vixey: Maybe a next step is to eliminate the rewrites.
02:50:46 <quicksilver> agentzh: -A10m
02:50:55 <vixey> ok
02:50:59 <agentzh> quicksilver: trying :)
02:51:06 <dmwit> vixey: (By changing the "env" variable locally in recursive calls.)
02:51:14 <quicksilver> agentzh: and, 10M isn't a very big heap really. How much memory does your machine have?
02:51:23 <agentzh> quicksilver: 1 GB
02:51:30 <dmwit> vixey: Or, if that's too boring, try converting whnf to use a Reader monad for "env".
02:51:38 <agentzh> quicksilver: yay, -A10m reduces the GC time to 27% :D
02:51:52 <quicksilver> better.
02:52:03 <vixey> dmwit: that's what I did initially but the thing is, say I have like x :$: y, and I find the whnf of x, as x' with xenv.. I can't evaluate x' :$: y in xenv or env..
02:52:17 <vixey> dmwit: so I think I should add environment to the actual terms.. maybe?
02:52:29 <quicksilver> I think -S10M doesn't do what you think?
02:52:31 <vixey> I mean the AST may hold a local env..
02:52:45 <vixey> or maybe I should rather add Let to the Terms
02:52:59 <quicksilver> agentzh: I think -S10M writes profiling infomration to a file called '10M' :P
02:53:11 <agentzh> quicksilver: thanks for the info :)
02:53:30 <quicksilver> agentzh: anyhow increasing the stack size probably isn't interesting.
02:53:35 <dmwit> vixey: Why couldn't you use the current trick?
02:53:37 <agentzh> quicksilver: i was really saying -H10M ...
02:53:41 <agentzh> quicksilver: sorry for that typo
02:54:00 <ketil> agentzh, lots of GC time is a rather common occurrence, I'm afraid.
02:54:02 * quicksilver nods
02:54:03 <dmwit> vixey: Let (Lambda e b :$: q) introduce a local binding (e, q).
02:54:04 <dcoutts> @seen matthew_-
02:54:04 <lambdabot> matthew_- is in #haskell and #ghc. I don't know when matthew_- last spoke.
02:54:04 <agentzh> quicksilver: -H100M has no impact the GC time reduction for this program
02:54:08 <dcoutts> @seen Heffalump
02:54:09 <lambdabot> Heffalump is in #haskell and #darcs. I last heard Heffalump speak 11h 56m 8s ago.
02:54:12 <quicksilver> fair enough.
02:54:14 <agentzh> quicksilver: but -Axxx has great effect
02:54:24 <quicksilver> you may find adding a generation to the GC helps
02:54:27 <quicksilver> -G3 ?
02:54:31 <smg> someone can suggest an advanced haskell book with deals with "lazy evaluation, strict evaluation and graph reduction etc"?
02:55:00 <agentzh> quicksilver: trying
02:55:38 <agentzh> quicksilver: what does -G do?
02:55:47 <quicksilver> increases the number of generations in the GC
02:55:49 <quicksilver> (default 2)
02:55:59 <dmwit> :t local
02:56:01 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
02:56:06 <agentzh> quicksilver: generations?
02:56:10 <Deewiant> can these GC options be set in the program, or do you have to supply a script to run your program if you want it to run faster
02:57:20 <vixey> dmwit: ah! I see
02:57:31 <agentzh> -G3 makes things a bit worse :(
02:57:45 <ketil> Okay, so Network.CGI outputs errors to the error log, but has otherwise broken error handling, it seems.
02:58:02 <agentzh> -A20m makes my program 100% faster :D
02:58:16 <agentzh> quicksilver: thanks a lot for the help :))
02:58:34 <EvilTerran> agentzh, what level of optimisation are you using?
02:58:39 <quicksilver> 100% faster woo :)
02:58:40 <agentzh> EvilTerran: -O2
02:58:43 <EvilTerran> k
02:58:54 <quicksilver> agentzh: yay :)
02:59:21 <quicksilver> agentzh: you may also want to try to work out if you really need to produce all that garbage
02:59:24 <quicksilver> ;)
03:00:51 <agentzh> quicksilver: *nod*
03:01:38 <quicksilver> agentzh: perhaps you want to make some record fields strict and unbox them/
03:01:43 <quicksilver> (I am guessing here!)
03:02:36 <agentzh> hmm
03:03:16 <vixey> hey
03:03:16 <agentzh> i produce a lot of strings while emitting the code from my AST
03:03:22 <vixey> I have a question about monomorphis
03:03:28 <vixey> if you got like
03:03:33 <agentzh> using ByteString makes things a lot faster
03:03:36 <vixey> foo = goo . bug . zub
03:03:44 <agentzh> not sure if i can produce less strings in the emitter though :P
03:03:45 <vixey> and it's got a monomorphism restriction problem
03:04:01 <vixey> why not just change it to: foo x = (goo . bug . zub) x
03:04:19 <vixey> ?
03:04:32 <agentzh> quicksilver: could you take a look at my code here: http://svn.openfoundry.org/openapi/trunk/haskell/src/RestyView/Emitter/Fragments.hs
03:04:36 <lambdabot> http://tinyurl.com/69am9x
03:04:43 <agentzh> quicksilver: not sure if i'm doing something really bad there :P
03:04:54 <bla123> when running something in ghci 6.8.1 on windows that imports libs which use different versions of bytestring, i get "duplicate definition for symbol" linker errors ... do i have to recompile them to use the same version or is there a way around it?
03:05:43 <quicksilver> vixey: you can if you like, yes.
03:05:56 <vixey> why can't GHC do it though?
03:07:11 <quicksilver> because that's what the monomorphism restriction says.
03:07:25 <quicksilver> the monomorphism restriction is precisely there to make this illegal.
03:07:35 <quicksilver> You can turn it off if you don't like it (I don't like it myself)
03:07:44 <quicksilver> agentzh: nothing immediately obvious to me
03:07:54 <agentzh> quicksilver: okay :) thanks :)
03:08:07 <quicksilver> agentzh: you might get a small win by making Fragment strict in its fields
03:08:14 <quicksilver> agentzh: and using -funbox-strict-fields
03:08:23 <agentzh> quicksilver: i fed a select statement of 139KB to my compiler and that was what i got :)
03:08:49 <agentzh> quicksilver: how to make it strict? sorry if it's a newbie question :)
03:09:07 <quicksilver> data Fragment = FVariable !String !VarType | FString !B.ByteString
03:09:07 <agentzh> quicksilver: by using prefix "!" ?
03:09:13 <agentzh> ah...okay, thanks :)
03:09:18 <quicksilver> and recompile with -funbox-strict-fields
03:09:24 * agentzh is trying.
03:09:33 <sieni> funbox <3
03:09:52 <paolino> monomorphic functions have less runtime overhead ?
03:10:25 <dmwit> paolino: Not noticeably.
03:10:37 <dmwit> paolino: However, you might get surprised by something like this:
03:10:55 <dmwit> (f 3, f 3) -- could compute f either twice or once, depending on the exact types of 3.
03:11:41 <quicksilver> I don't think that's what you mean.
03:11:52 <dmwit> Yeah, it probably isn't.
03:11:59 <dmwit> Let me try again.
03:12:04 <vixey> -funroll-loops
03:12:05 <vixey> !
03:12:12 <quicksilver> let a = (f,f) in ....
03:12:13 <Cale> (f 3, f 3) will always compute f twice, unless you do CSE that GHC doesn't.
03:12:23 <quicksilver> ^^ could compute f once or twice
03:12:30 <dmwit> right
03:12:31 <quicksilver> depending if those fs are at the same type or not
03:12:47 <dmwit> (primes, primes) -- could be doubly expensive if this is :: (Integer, Int), for example.
03:13:02 <Cale> Don't you mean depending on whether f is polymorphic or not?
03:13:25 <dmwit> I don't think so.
03:13:41 <vixey> I guess I could write a typechecker for lambda poly and then rewrite my interpreter to be actually lazy
03:13:59 <agentzh> quicksilver: funny. making fields strict makes it a little slower :)
03:14:10 <dmwit> Cale: If it were polymorphic, and a top-level caf, it could still be computed once given that both instances were the same type, right?
03:14:22 <Cale> dmwit: could, but won't.
03:14:30 <dmwit> um
03:15:02 <Cale> at least, I don't think so
03:15:34 <dmwit> Time to test it! =)
03:16:08 <quicksilver> agentzh: ah well, laziness working in your favour then :)
03:16:53 <agentzh> :))
03:19:19 <dmwit> Cale, it only does it once, here.
03:19:30 <Cale> dmwit: What's f's type?
03:19:53 <hpaste>  dmwit pasted "once, or twice?" at http://hpaste.org/7807
03:21:28 <Cale> Interesting.
03:21:42 <quicksilver> I think that's automatic specialisation at work.
03:21:55 <quicksilver> GHC will compile a CAF "primes_[int]"
03:21:57 <Cale> Would have to be, yeah
03:22:00 <quicksilver> which is then cached since it's a CAF
03:22:18 <dmwit> But, it's not shared between Once and TwiceMaybe.
03:22:22 <quicksilver> you could probably prove that by splitting it over a module
03:22:34 <quicksilver> oh
03:22:36 <quicksilver> then it's not that.
03:22:52 <quicksilver> then it's let-floating/lambda lifting
03:22:56 <quicksilver> or whatver they call it
03:23:06 <quicksilver> (a,a) -> let a' = a in (a',a')
03:23:23 <dmwit> Yeah.
03:23:40 <dmwit> So, the point stands: it depends on the types, not on the polymorphismness. =)
03:23:47 <quicksilver> would be quite interesting to ask glasgow-haskell-users how that works.
03:24:36 <Cale> uh, all three are shared if I compile, even without optimisation
03:24:45 <dmwit> whoop!
03:24:51 <dmwit> I didn't think to compile. =P
03:25:02 <vixey> soo.....
03:25:17 <vixey> typechecking polymorphic lambda calculus
03:25:58 <quicksilver> ok, back to the specialisation theory then :)
03:26:05 <quicksilver> you should be able to prove that by splitting modules
03:26:17 <quicksilver> automatic specialisation doesn't go over module boundarys
03:26:24 <dmwit> Cale: It's not shared here with compilation...
03:26:27 <quicksilver> (which slowed my code down by a factor of 2 once)
03:26:32 <dmwit> GHC 6.8, are you on HEAD or so?
03:26:37 <Cale> 6.8.2
03:26:52 <dmwit> Er, wait, does runhaskell compile?
03:27:17 <Cale> no, I don't think so
03:27:32 <Cale> well, I'm not sure
03:27:33 <doun> doesn't it just compile and load like hs-plugins?
03:27:36 <vixey> hey is there any other interesting type systems around in that area?
03:27:44 <dmwit> No, runhaskell doesn't compile.
03:28:12 <dmwit> But it doesn't matter, compiling here doesn't help the sharing, as far as I can tell.
03:29:23 <dmwit> Cale: Try with an index bigger than 1000, say 3000 or 5000.  (With compilation, 1000 was too fast for me to notice the computation time.)
03:29:30 <Cale> I did 10000
03:29:34 <dmwit> huh
03:29:39 <Cale> It prints all three at the same time.
03:29:46 <dmwit> line buffering
03:29:47 <Cale> (after a delay)
03:29:48 <Cale> hmm
03:29:53 <Cale> good point
03:30:42 <vixey> wow http://www.fresh-ocaml.org/examples/hm.ml
03:30:49 <vixey> this is so shor
03:31:14 <dmwit> Yeah, HM is a pretty simple algorithm.
03:31:24 <dmwit> Well... small.
03:31:27 <dmwit> Not simple, maybe. =)
03:31:41 <vixey> Fresh O'Caml is a programming language which aims to provide the features of the Objective Caml language together with:
03:31:41 <vixey> types of names for representing object-level bindable names;
03:31:41 <vixey> abstraction expressions for representing object-level binding;
03:31:41 <vixey> pattern-matching for deconstructing abstraction values;
03:32:39 <quicksilver> dmwit: simple when you understand it, perhaps :)
03:32:40 <Cale> nope, even with stdout set to NoBuffering and the results split onto separate lines, they still all print at once
03:32:44 <quicksilver> dmwit: like so many things.
03:33:01 <vixey> I want to try some other type system..
03:33:03 <dmwit> right =)
03:33:21 <vixey> do you know any others.. beyond simple types ?
03:33:33 * quicksilver wishes the author of that hm.ml had known about align-regexp
03:33:54 <quicksilver> and furthermore than that dialect of lisp permitted multiple definitions in a single let
03:33:59 <quicksilver> s/lisp/ml/
03:34:09 <Cale> oh, that's interesting.
03:34:50 <Cale> Okay, with no optimisation they're unshared.
03:35:31 <Cale> but with optimisation, they do seem to be
03:35:41 <dmwit> optimization++
03:35:50 <dmwit> Agreed, there's a very noticeable difference.
03:36:24 <Cale> of course, we really should be looking at the core, but I'm too lazy
03:43:29 <vixey> hey if you added linear typed could you implement the IO Monad?
03:49:09 <quicksilver> vixey: it wouldn't be a monad.
03:49:22 <quicksilver> vixey: you can use linear/uniqueness typing for IO, but it's not the same as the monad solution.
03:49:28 <vixey> yeah
03:49:29 <quicksilver> (Clean does it)
03:49:36 <vixey> but could you implement the Monad using that
03:49:55 <dcoutts_> yes, and you would want to
03:50:13 <dcoutts_> otherwise Clean code with uniqueness typing looks like
03:50:35 <dcoutts_> let (x1, b) = foo b x0
03:50:47 <dcoutts_> let (x2, c) = bar d x1
03:50:59 <dcoutts_> let (x3, e) = baz z x2
03:51:23 <dcoutts_> all the intermediate states get passed around explicitly
03:51:26 <dcoutts_> bleugh
03:51:27 <dmwit> So even with uniqueness typing they end up using a Monad-alike?
03:51:33 <vixey> thats' cool
03:51:46 <dcoutts_> I'm not sure, I've seen quite a bit of code that looks like the above
03:52:14 <dmwit> =/
04:09:56 <pitr`> vixey: so, why are you pretending to be a woman? it's pretty weird
04:10:34 <pitr`> vixey: justin has met you. you have a beard...
04:11:35 <MyCatVerbs> @type on
04:11:37 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
04:12:16 <pitr`> vixey: I presume you seek the attention that females are given on IRC. who wouldn't want that? they are treated more fairly and more like a human being than a stupid fat man
04:12:29 <pitr`> vixey: but you are lying to them
04:12:33 <MyCatVerbs> Hey pitr`.
04:12:42 <pitr`> hello, MyCatVerbs
04:12:44 <MyCatVerbs> Go stick a pipebomb somewhere where the sun shineth not.
04:13:10 <Deewiant> @check \f x y -> (f `on` id) x y == f x y
04:13:11 <lambdabot>  OK, passed 500 tests.
04:13:21 <vixey> @src on
04:13:22 <lambdabot> (*) `on` f = \x y -> f x * f y
04:13:38 <MyCatVerbs> If people want to express completely insane gender identity, then that's their business and not yours.
04:13:39 <pitr`> MyCatVerbs: if you would rather deceive yourself and pretend that vixey is a woman for some weird desire then so be it
04:14:07 <MyCatVerbs> It doesn't exactly hurt you, so quit whining.
04:14:43 <MyCatVerbs> pitr`: sure, fine enough. I do not care what gender any particular IRC user has, it does not matter. Particularly when the subject of conversation is meant to be ridiculously theory-heavy programming, not hookups.
04:15:25 <MyCatVerbs> pitr`: if someone wishes to pass themself off as an ambulatory talkative jellybaby, that's just fine with me.
04:16:20 <Deewiant> @check \f g x -> on fmap fmap f g x == fmap (f.g) (x :: [Int])
04:16:23 <lambdabot>  OK, passed 500 tests.
04:16:27 <MyCatVerbs> ...would have to be a pretty big jellybaby, though, to be able to type. Not to mention the difficulty involved. Nobody who makes jellybabies ever gives them fingers. :(
04:28:43 * luqui is a mid-op transsexual ameoba
04:29:03 * luqui seeks the attention that such are given on IRC
04:29:07 <dolio> Going from no sex to no sex?
04:29:29 <luqui> right, transasexual I suppose
04:30:58 <MyCatVerbs> luqui: damn.
04:31:15 <MyCatVerbs> luqui: I was hoping you might be going from none to both.
04:32:07 <MyCatVerbs> luqui: having a friend in the middle of an asexual-to-hermaphrodite transition would've really helped bump up my street cred for by dint of the sheer exotica value.
04:36:14 <skbohra> what is functional programming
04:36:58 <quicksilver> nirvana
04:37:17 <sieni> opposite of dysfunctional programming
04:37:37 <skbohra> :P
04:37:40 <dolio> @wn functional
04:37:41 <lambdabot> *** "functional" wn "WordNet (r) 2.0"
04:37:42 <lambdabot> functional
04:37:42 <lambdabot>      adj 1: designed for or capable of a particular function or use; "a
04:37:42 <lambdabot>             style of writing in which every word is functional";
04:37:42 <lambdabot>             "functional architecture" [ant: {nonfunctional}]
04:37:43 <lambdabot> [18 @more lines]
04:37:47 <Auders> anybody here know parsec?
04:37:55 <vixey> Auders: somewhat
04:38:00 <MyCatVerbs> dolio: not really specific enough. :P
04:38:09 <dolio> :)
04:38:17 <Auders> i'm writing an expression parser using buildExpressionParser
04:38:19 <dolio> It's programming that works.
04:38:30 <Auders> and one of the operators need random numbers
04:38:38 <Auders> so I add state to the parser
04:38:53 <Auders> but how can the operator function in the operator table update the state?
04:39:45 <skbohra> can we declare variables and all that using functions
04:40:02 * ketil checks for the term 'bringert' in the Network.CGI documentation.
04:40:02 <quicksilver> Auders: "setParserState"
04:40:17 <quicksilver> Auders: (funnily enough ;)
04:40:18 <bringert> ketil: huh?
04:40:19 <MyCatVerbs> skbohra: it's where you do data-processing using functions that perform transformations and nothing else. No side effects.
04:40:47 <ketil> bringert, hah, found you!
04:40:50 <skbohra> side effects?
04:41:04 <Auders> from a function?
04:41:11 <ketil> Network.CGI.handleError: short story: it doesn't.
04:41:21 <MyCatVerbs> skbohra: anything that modifies the real world, more or less.
04:41:33 <MyCatVerbs> skbohra: printing things to screen, altering bits in memory...
04:41:46 <ketil> I've been trying to hack up a CGI script, but when there was an unhandled case (and thus an exception) all I got was a blank page.
04:42:11 <ketil> The error was printed to the log, so I managed to track it down and fix it, but I'd really like some kind of feedback to the user.
04:42:18 <MyCatVerbs> skbohra: in a purely functional style of programming, when you work on data structures, you don't modify them in-place, but rather you allocate new data structures that are similar (but altered in some useful way) to the previous data structure.
04:42:22 <yitz> MyCatVerbs, no, you can do all of those things. you just have to make sure the compiler knows about it
04:42:28 <ketil> Neither handleErrors or catchCGI seemed to work.
04:42:30 <ketil> Known issue?
04:42:43 <mbz> skbohra, you can find answers on en.wikipedia.org
04:42:46 <MyCatVerbs> yitz: just for pedagological purposes, I'm not going to mention IO right now, m'kay? :P
04:43:05 <MyCatVerbs> Er, pedagogical, even.
04:43:30 <yitz> MyCatVerbs: i know. but i don't think that's the main point of "no side effects"
04:43:50 <ketil> bringert, (using cgi-3001.1.5.1)
04:44:47 <bringert> ketil: I suspect laziness
04:45:08 <ketil> bringert, how so?  Anything I can do?
04:45:19 <bringert> ketil: the functions only catch exceptions that are thrown when the CGI action is forced, not it's result
04:45:31 <yitz> in C you write "if (++x > 9 ) ..." which both tests the value of x, and on the side updates that value. In Haskell, that is not allowed. This allows you to write functions that are guaranteed to work exactly the same way every time ("referential transparency")
04:45:33 <MyCatVerbs> skbohra: (part of) the point is that, given any pure function 'f', it doesn't matter in the least when when or how many times you call 'f', you'll always get the same result back.
04:45:47 <bringert> ketil: force the result inside the function that handleError wraps
04:47:03 <ketil> Not sure I follow you - let me paste the code (all four lines) to hpaste:
04:47:29 <hpaste>  ketil pasted "CGI program" at http://hpaste.org/7808
04:48:12 <bringert> ketil: where is the unhandled case?
04:48:40 <ketil> Oh, relatively deep below genResult.
04:49:16 <bringert> so you need to force evaluation of the output of genResult to make it possible for handleErrors to catch it
04:49:34 <bringert> use seq or evaluate
04:49:45 <ketil> I see.
04:49:56 <bringert> or a cheesy if x == x then x else fail "I am the pope"
04:50:20 <ketil> Just n  -> let r = genResult n in if r==r then output $ html (form ++ r) else undefined
04:50:39 <ketil> I'll try it out, thanks.
04:52:25 <ketil> Perhaps 'output' should do this automatically?
04:56:29 <ketil> Whoha.  Now it doesn't terminate(!) on incorrect input.  Just a hourglass in the browser, and the page not being updated...
04:56:38 <ketil> No CPU consumption on the server either.
05:00:00 <ketil> ...but 'text file busy' when trying to overwrite it.
05:24:26 <mxc> say there is a system which has a C API and a .Net API, which is the less hopeless one to access via haskell?
05:24:34 <dcoutts_> matthew_-: ping
05:24:39 <mxc> assuming the C API since there doesn't seem to be a haskell equivalent of F#
05:24:57 <dcoutts_> mxc: the C one would be easier
05:25:21 <dcoutts_> mxc: there is a .net bridge but it's not nearly as mature as the C FFI
05:25:41 <mxc> for a relatively inexperienced haskell coder, how hard is it to use the C FFI?
05:26:12 <dcoutts_> mxc: if you use a good tutorial, not too hard at least initially
05:26:24 <mxc> have any to suggest?
05:26:24 <dcoutts_> it depends on the complexity of the C api you're trying to use
05:27:33 <mxc> say, hypothetically, very
05:28:04 <dcoutts_> mxc: if the C api is very complex then it'll be hard :-)
05:28:27 <dcoutts_> mxc: especially if it has complex structures or tricky memory management semantics
05:28:40 <quicksilver> mxc: if the C api is mostly in terms of double, int, and char *
05:28:41 <dcoutts_> but then such things would be hard to use in C too :-)
05:28:44 <quicksilver> mxc: then you'll be fine :)
05:28:48 <mxc> yeah
05:28:56 <mxc> i'm going to see if i can get it working in C
05:28:59 <mxc> first
05:29:07 <mxc> how do you even compile C on windows
05:29:07 <quicksilver> if the C api makes heavy use of custom structs, CPP macros and callbacks
05:29:09 <mxc> ugh
05:29:19 <quicksilver> (1) install linux (2) install gcc (3) profit
05:29:32 <dcoutts_> mxc: it is certainly possible to use more complex apis, ut just gets harder. Eg we have bindings to Gtk+ which is large and complex, but that took a while to build.
05:29:38 <mxc> yeah
05:29:54 <quicksilver> and required the input of unusually talented and sometimes impressively bearded programmers.
05:30:00 <dcoutts_> mxc: I don't off the top of my head know of a great FFI tutorial, there's some stuff on the wiki though
05:30:02 <Deewiant> mxc: mingw or visual C are the two most common options
05:30:07 <dcoutts_> mxc: http://www.haskell.org/haskellwiki/FFI_Introduction
05:30:08 <lambdabot> Title: FFI Introduction - HaskellWiki
05:30:24 <mxc> yeah, there seems to be a correlation between beard length and haskell
05:30:37 * dcoutts_ only has a v. short beard
05:31:22 * maltem has a beard only from Tuesday through Friday
05:31:44 <quicksilver> dcoutts_: size is not the only important thing.
05:31:59 <quicksilver> But I don't think anyone doubts that Igloo is the beard-king. ;)
05:32:07 <dcoutts_> hah, that's certainly true
05:32:24 <quicksilver> for those following along at home, a 2006 comparison
05:32:25 <quicksilver> http://undecidable.org.uk/edwin/photo/anglohaskell.php?photo=IMG_0372.jpg
05:32:26 <lambdabot> Title: AngloHaskell, http://tinyurl.com/57fj55
05:32:29 <dmwit> maltem: It grows that slowly, hey?
05:32:31 <quicksilver> http://undecidable.org.uk/edwin/photo/anglohaskell.php?photo=IMG_0371.jpg
05:32:31 <lambdabot> Title: AngloHaskell, http://tinyurl.com/6gfhv3
05:32:56 <tibbe> what would be a good module name (in the module hierarchy) for type declarations and utility functions for an Oleg style Enumerator?
05:33:16 <quicksilver> tibbe: does it make sense to give such things generic types?
05:33:18 <maltem> dmwit, quite
05:33:28 <quicksilver> tibbe: I generally invent them anew each time I want to sue them..
05:34:08 <tibbe> quicksilver: the problem is if you have several libraries that use them, I think you could give some general type
05:34:12 * quicksilver nods
05:34:15 <quicksilver> you're probably right
05:34:21 <dmwit> That's an awkward comment, should the person in question ever read it: "Front to back; <name>, <name>, <name>, and, er, someone else."
05:34:22 <quicksilver> Control.Enumerator ?
05:34:51 <tibbe> quicksilver: that's my problem right now, they are very pervasive in code once you ditch lazy I/O but still deal with too much data to keep it in memory so you want some stream like processing
05:35:15 <tibbe> quicksilver: it's more or less a typedef (or a newtype)
05:35:39 <quicksilver> tibbe: the problem is there are choices
05:35:45 <tibbe> quicksilver: You need an Iteratee and an IterateeM
05:35:50 <quicksilver> (early stop? continuation for resuming?
05:35:57 <quicksilver> state within consumer?
05:36:00 <tibbe> quicksilver: yes, I know. anooying choices!
05:36:04 <quicksilver> custom monad for consumer?
05:36:13 <quicksilver> MonadIO constraint on consumer?
05:36:23 <dcoutts_> isn't it just a continuation?
05:36:28 <tibbe> quicksilver: from my discussions with oleg the explicit state passing is probably the best compromise
05:36:48 <quicksilver> I haven't used it in enough circumstances to be happy about a 'best' compromise
05:36:58 <quicksilver> I would be in favour of someone uploading something and trying to get people to use it.
05:37:03 <tibbe> quicksilver: one (a -> b -> m a) -> a -> m a and one without m on the iteratee
05:37:05 <quicksilver> it's only by trying to use it we find otu what's best :)
05:37:19 <tibbe> quicksilver: that's what I'm doing now but I'm thinking about a module name
05:37:22 <vixey> what's that b about?
05:37:51 <dcoutts_> it's the result type right?
05:37:58 <tibbe> vixey: it's one element in the collection being iterated over, think of an enumerator as a partially applied fold where the collection is already specified
05:38:08 <tibbe> @type fold
05:38:09 <dcoutts_> (a -> b -> m a) -> a -> m a ~= Cont b (a -> m a)
05:38:12 <lambdabot> Not in scope: `fold'
05:38:16 <vixey> ah nifty
05:38:16 <tibbe> @type foldl
05:38:17 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:38:27 <quicksilver> tibbe: Control.Enumerator is my suggestion
05:38:37 <quicksilver> tibbe: but you can pick something 'cooler' if you like.
05:38:47 <tibbe> dcoutts: I think both I and Oleg agreed that keeping some explicit state makes things simpler to understand
05:38:49 <quicksilver> Control.InsideOut.Fold ?
05:39:26 <tibbe> quicksilver: that sounds scary!
05:39:27 <yitz> closest to common usage would be Control.Oleg
05:39:34 <tibbe> heh
05:39:41 <tibbe> yitz: I use them a lot too
05:39:45 <quicksilver> seriously I think Control.Enumerator is good.
05:39:46 <tibbe> yitz: in my web server
05:39:58 <tibbe> quicksilver: yes, the best one I've come up with so far
05:40:00 <quicksilver> Unless you want to think of a cool name and write a pepr.
05:40:01 <quicksilver> Like idiom.
05:41:23 <tibbe> heh
05:41:30 <tibbe> enumerator sounds nice and simple
05:41:50 <tibbe> something that enumerates the element for you
05:44:48 <FordCortina> when ghc-pkg surrounds a library in brackets, that means its hidden?
05:45:08 <quicksilver> I believe so.
05:45:39 <tibbe> one really annoying thing when moving from streams to enumerators is that you get into rank 2 types :/
05:45:48 <FordCortina> and if (ghc-6.8.2) is in brackets is that not a bad thing?
05:45:59 <quicksilver> FordCortina: not really, it means the internal ghc stuff is hidden
05:46:03 <quicksilver> which it's supposed to be
05:46:12 <quicksilver> cose you're not really supppose to use it directly
05:46:49 <FordCortina> ic
05:48:15 <quicksilver> tibbe: Control.PostModern.Deconstructor
05:49:04 <EvilTerran> Control.Modern.Abstract?
05:49:32 <tibbe> hehe
05:51:46 <tibbe> hmm, maybe I'm better of just making a ByteString enumerator
05:53:51 <mxc> i think i'm setting myself up for disappointment, but is there any work on large scale grid computing in haskell?
05:54:11 <vixey> mxc: I think there is actually
05:54:11 <mxc> (seeming that referential transparency should make this easy)
05:54:34 <vixey> "grid parallel haskell"
05:54:42 <FordCortina> im trying to build the binary library, it claims the containers library is hidden, but containers is not hidden. Any idea what I should do?
05:54:46 <vixey> Glasgow Parallel Haskell
05:55:20 <FordCortina> (containers is not hidden according to ghc-pkg)
05:57:51 <tibbe> FordCortina: are you using Cabal to build?
05:58:06 <quicksilver> FordCortina: add containers to the depends field in the .cabal
05:58:11 <quicksilver> but, I thought this bug should be fixed?
05:58:18 <quicksilver> which version of binary do you have, where did you get it from?
05:58:33 <quicksilver> dcoutts_: does binary not have post-base-split depends fixed?
06:05:11 <FordCortina> hey i think i am using cabal, in that i am doing runhaskell Setup.lhs build etc
06:05:28 <FordCortina> i added containers to depends
06:05:31 <FordCortina> and then
06:05:48 <FordCortina> array and bytestring later when those dependencies also came up
06:06:22 <FordCortina> now it says:
06:06:24 <FordCortina> src/Data/Binary/Put.hs:52:17:
06:06:24 <FordCortina>     Could not find module `Data.ByteString.Base':
06:06:24 <FordCortina>       Use -v to see a list of the files searched for.
06:06:29 <FordCortina> ... after the build
06:06:39 <quicksilver> where did you get that version of binary from?
06:06:52 <FordCortina> im trying to compile version 0.3 of binary
06:06:54 <FordCortina> from hackage
06:09:19 <quicksilver> FordCortina: why 0.3?
06:09:23 <quicksilver> FordCortina: I would suggest 0.4.2
06:09:46 <quicksilver> (0.3 doesn't work with your version of ghc anyway, hence all these problems)
06:09:55 <FordCortina> i didnt see the later versions... dunno why
06:10:02 <FordCortina> ok
06:10:08 <FordCortina> 0.4.2 then
06:11:51 <FordCortina> that worked better :D
06:12:04 <FordCortina> thanks
06:13:19 <quicksilver> cool :)
06:18:56 <zambe> hello, I'm wondering why emacs haskell mode does :cd ~/.cabal/ before loading my module when I hit C-c C-l?
06:19:40 <zambe> ghci fails to find my other imported modules then, when they are not in the current directory any more
06:19:52 <dcoutts_> zambe: hmm, that's pretty odd
06:20:13 <dcoutts_> I don't think there is any good reason to want to be in ~/.cabal/
06:20:20 <mbz> can someone advice light and small opensource rtp-capable streaming server?
06:20:22 <zambe> this started when I installed cabal
06:20:44 <mbz> sorry for off-topic..
06:20:47 <dcoutts_> zambe: well previously the ~/.cabal/ dir did not exist so presumably haskell mode could not cd into it
06:21:06 <dcoutts_> zambe: I'd take it up with the haskell-mode devs, it sounds quite wrong to me
06:21:49 <quicksilver> zambe: the new version of the mode has some magic to try to cd into the right directory
06:21:55 <quicksilver> (the root of your current project)
06:21:59 <quicksilver> apparently that magic is failing :)
06:22:14 <quicksilver> I believe it looks in enclosing directories tring to find a .cabal file.
06:22:19 <dcoutts_> quicksilver: doh!
06:22:28 <dcoutts_> and it finds a .cabal directory :-)
06:22:34 <quicksilver> I presume so, yes.
06:22:35 <quicksilver> ;)
06:23:46 <zambe> hmm...
06:30:53 <zambe> doing 'touch .cabal' in my source directory seemed to help
06:31:00 <zambe> thanks, guys :-)
06:31:29 <dcoutts_> zambe: ah, cunning workaround :-)
06:32:06 <dcoutts_> someone should report it to the haskell-mode devs though
06:32:26 <dcoutts_> I had to fix a similar bug in cabal itself a month or so ago
06:33:05 <dcoutts_> when run in one's home dir it would think the .cabal/ dir was a .cabal project file with an empty name
06:33:29 <orbitz> dcoutts_: craaaazy
06:33:30 <dcoutts_> ie "".cabal
06:33:57 <dcoutts_> obviously now it checks for it being a proper file
06:34:11 <dcoutts_> and I probably for having a non-empty name
06:37:33 <zambe> dcoutts_: I'll send them (him) a report
06:38:05 <dcoutts_> great
06:45:57 <christastrophe> is it too early to be asking for some help with a type error?
06:46:04 <christastrophe> :)
06:46:22 <jewel> it's always too early for that
06:46:55 <christastrophe> I know. I should just be in bed instead of fussin with haskell ... but since were here...
06:47:52 <hpaste>  christastrophe pasted "monads and type classes" at http://hpaste.org/7812
06:48:32 <christastrophe> im sure this is just me overlooking the obvious... or completely abusing the language... but I thought it should work :(
06:51:10 <BMeph> christastrophe: Just curious, but it's permissible to use semi-colons, without braces?
06:51:29 <quicksilver> yes.
06:51:36 <quicksilver> do a ; b ; c
06:51:36 <christastrophe> BMeph, i do believe so
06:51:37 <Syzygy-> > do x <- [1,2,3]; y <- [2,3,4]; return (x+y)
06:51:38 <lambdabot>  [3,4,5,4,5,6,5,6,7]
06:51:39 <quicksilver> is fairly common
06:51:48 <maltem> christastrophe: Is it your intention that a and f are allowed to be different types?
06:52:21 <christastrophe> maltem... hmm, no actually they should be of the same type...
06:52:23 <christastrophe> hmmm
06:52:34 <maltem> christastrophe: That's your mistake
06:52:35 <christastrophe> should that then read: (Foo f) => f -> IO f
06:52:36 <christastrophe> >
06:52:37 <christastrophe> ?
06:52:41 <quicksilver> christastrophe: just f -> IO f
06:52:47 <christastrophe> ah
06:53:53 <maltem> Only if all type errors were as easy as that...
06:54:00 <christastrophe> ok. still getting used to this. so by using different type variables, even if I put a constraint on 'a' ghc will want them to be different types?
06:54:44 <maltem> christastrophe: If you use different variables, you're saying "This shall work for whatever a and f you choose, let them be the same or different types"
06:55:21 <BMeph> I think it's more like "by using a different type variable, you're telling GHC that it doesn't know anything more about 'a' other than it's a type in the Foo class.
06:55:25 <BMeph> "
06:55:28 <quicksilver> yes
06:55:34 <quicksilver> "for abitrary a"
06:55:40 <quicksilver> your original version said.
06:55:48 <quicksilver> (arbitrary with a constraint of Foo)
06:55:59 <christastrophe> hmm. well then why would the type checker complain? gratned it was more verbose than it had to be, but it seems like it should have worked... the types of f and a would just be equal...
06:56:05 <BMeph> I.e., it's an existential declaration? :)
06:56:14 <twobitwork> good morning
06:56:27 <BMeph> Good morning, twobitwork. :)
06:56:30 <twobitwork> @seen dons
06:56:30 <lambdabot> dons is in #haskell, #xmonad, #haskell-soc and #ghc. I last heard dons speak 7h 28m 59s ago.
06:57:21 <maltem> christastrophe: Your instance declaration only works for them being equal, not in any other case, but the type of clear demands that it works for arbitrarily chosen f and a
06:58:27 <christastrophe> maltem: ok. so if I say 'work for an arbitray a' than my implementation must also return arbitrary a's?
06:59:02 <maltem> right, at least if the type mentions a only one time
06:59:55 <maltem> (in contrast, id :: a -> a always returns a value of the same type as the value it receives)
07:00:44 <orbitz> what does the 'forall' in type defintions mean?  My book doesn't seem to mention it in teh section on typeclasses
07:00:48 <orbitz> or much else
07:00:51 <orbitz> but i should check th eindex
07:00:58 <christastrophe> I see. I have been reading it as the general class works for arbitray types, but when you define an instance you also define a concrete type for it to return...
07:01:07 <orbitz> err i don't knwo why is aid type calsses there, it clearly doesn't need to be just for typeclasses
07:01:08 <quicksilver> orbitz: means it works for any type, basically
07:01:22 <maltem> orbitz: The printed forall in ghc is an extension - usually the forall is understood implicitly.
07:01:24 <quicksilver> orbitz: or any type in a class, if there is a class contrsaint too
07:01:26 <orbitz> quicksilver: doesn't jsut saying a do that for us?
07:01:30 <quicksilver> yes, it does.
07:01:33 <orbitz> oh ok
07:01:34 <quicksilver> the forall is optional in GHC
07:01:40 <quicksilver> (and it's not haskell 98)
07:01:52 <orbitz> is tehre any good erason for it to exist?
07:01:55 <quicksilver> yes
07:01:57 <maltem> christastrophe: That's right, but then you need to refer to the f as it occurs in the class definition header
07:02:02 <quicksilver> higher ranked types
07:02:09 <quicksilver> is its real reason for existing
07:02:10 <orbitz> what are higher ranked types?
07:02:15 <quicksilver> (forall a . a -> a) -> b
07:02:21 <quicksilver> with a forall in brakcets
07:02:27 <BMeph> christastrophe: The problem is, you have an existential type (it exists, and that's all we know), but you're trying to use it as if you DO know what it is.
07:02:31 <quicksilver> you can't represent that without an explicit forall.
07:02:43 <orbitz> what is that saying?
07:03:01 <quicksilver> it's saying that I want a parameter of type (forall a . a -> a)
07:03:11 <quicksilver> I.e. i want a parameter which itself works for any a
07:03:18 <quicksilver> a "truly polymorphic parameter"
07:03:19 <christastrophe> so because I made the type concrete by calling if 'f' I can't also refer to it under the 'a' type?
07:03:23 <orbitz> is the . there composition?
07:03:26 <quicksilver> no
07:03:30 <quicksilver> it's just syntax
07:03:35 <christastrophe> (in the type declaration that is)
07:03:36 <quicksilver> to separate the forall part from the other part
07:03:49 <quicksilver> some maths writers would write it as [forall a] a -> a
07:04:45 <orbitz> hrm, is tehre a site with some concrete examples on HRT's? I'm not groking
07:05:09 <BMeph> Make it as concrete as you like - by using a different type variable, though, GHC naturally assumes that 'a' COULD be different from 'f', so it doesn't know that you want it to be the same type.
07:05:33 <orzo> i want some small bit of xml parsing code i can use on jabber messages
07:06:03 <quicksilver> orbitz: a conventional function taking a type of ( a -> a ) just knows it gets  function which works for some a
07:06:04 <orzo> what do you guys recommend
07:06:10 <quicksilver> orbitz: the 'a' is fixed at compile time.
07:06:21 <maltem> christastrophe: It's a little hard to talk about a "concrete" type when we don't actually know that much about it :)
07:06:22 <quicksilver> orzo: haxml or tagsoup
07:06:31 <quicksilver> orbitz: sorry, at *call* time, I meant
07:06:37 <quicksilver> orbitz: so it gets some (a -> a) for some a.
07:06:38 <orzo> quicksilver: either of those bundled with ghc?
07:07:05 <quicksilver> orzo: no.
07:07:17 <quicksilver> orbitz: if it was (forall a . a -> a) on the other hand
07:07:26 <BMeph> christastrophe: It just knows (modulo a coherent definition of 'know') that 'a' is a type in the Foo class.
07:07:51 <quicksilver> orbitz: then it would only accept a parameter which was itself polmorphic
07:08:02 <quicksilver> orbitz: the parameter woudl have to be a polymorphic function which works for any a.
07:08:12 <christastrophe> maltem: well in my example, the type declaration is in the class Foo, and I'm saying that 'a' is also of class Foo. so isn't saying (Foo a) f -> IO a, the same as saying: f -> IO f, when f is a Foo?
07:08:14 <quicksilver> haskell98 does not admit polymorphic parameters in this sense.
07:08:16 <BMeph> It's not even a concrete type at that point, and you're using it as if it's a value of a concrete type.
07:08:21 <quicksilver> they aren't needed very often.
07:08:26 <quicksilver> and they break type inference
07:08:51 <orbitz> quicksilver: so if i do (forall a . a -> a) a -> a, then i could not, for instance, call it with an a who's defintion is Int -> Int?
07:09:12 <quicksilver> right.
07:09:27 <orzo> tagsoup mentions HXT, is that another alternative to haxml and tagsoup?
07:09:27 <BMeph> christastrophe: Why should GHC assume that Foo has only one instance type of the Foo class? Why not NO instances of Foo, or twelve?
07:09:32 <quicksilver> orzo: yes.
07:09:40 <maltem> christastrophe: no it's not. to see this, maybe it's helpful to see the "full" type of clear: (Foo a, Foo f) => f -> IO a
07:09:44 <quicksilver> BMeph: I vote for twelve.
07:09:47 <orbitz> could I call it with somethign defined as (Num a) => a -> a
07:09:50 <christastrophe> maltem: oh wait. I think I see now. I am saying with (Foo a) f -> IO a, I will take an f as an argument and return an a... where a is a Foo, but with f -> IO f, I am saying I will take an f and return an f
07:09:52 <BMeph> quicksilver: :)
07:10:02 <maltem> right :)
07:10:13 <christastrophe> so even though they are both the same class, they are not the same type
07:10:24 <christastrophe> and a, and f aren't referring to classes, but to types.
07:10:33 <maltem> all right
07:11:00 <BMeph> "By George, I think he's got it!"
07:11:14 <BMeph> BRB, restarting browser.
07:11:54 <christastrophe> hah.
07:12:03 <maltem> orbitz, you couldn't
07:12:17 <orbitz> ok thank maltem
07:12:25 <christastrophe> see it was too early for help with a type error. :)
07:12:48 <christastrophe> thanks, its all starting to click ever so slightly now
07:13:55 <quicksilver> hmm, slight clicking? probably needs more oil.
07:14:20 <christastrophe> probably. maybe more coffee
07:22:47 <vixey> I want a statemonad in every node of an AST
07:23:02 <vixey> I doesn't work does it?
07:23:05 <vixey> that*
07:23:48 <hpaste>  doun pasted "(no title)" at http://hpaste.org/7814
07:24:36 <quicksilver> vixey: a whole monad at every node? that sounds odd.
07:24:42 <quicksilver> are you sure you dont' jsut want a state at each node.
07:26:18 <vixey> so go from data Term = Var Name | Lambda Name Term | ...
07:26:21 <vixey> to data Term = Var State Name | Lambda State Name Term | ... ?
07:26:39 <quicksilver> traditionally you use
07:26:50 <quicksilver> data Term a = Var a Name | Lambda a Name Term | ....
07:26:55 <quicksilver> to allow for arbitrary annotations
07:27:14 <vixey> that's perfect
07:27:15 <vixey> thank you
07:27:37 <quicksilver> then you can annotate with nothing (Term ()), or ints (Term Int)
07:27:42 <quicksilver> or partial type inferences
07:27:45 <quicksilver> (Term TypeMap)
07:27:49 <quicksilver> or whatever else appeals :)
07:28:34 <vixey> aww
07:28:40 <vixey> I can't use my infix :$: anymore
07:31:27 <mgdtgd> hello
07:31:38 <mgdtgd> I have a question regarding lazy IO
07:31:41 <doun> hi
07:31:51 <mgdtgd> (this has something to do with homework)
07:32:11 <mgdtgd> I have to redefine getLine in terms of getChar
07:32:24 <doun> mhm
07:32:36 <mgdtgd> so I thought "lets make a infinite lazy list of getChar" and take from it until we reach a newline
07:32:44 <mgdtgd> getLine1 :: IO String
07:32:44 <mgdtgd> getLine1 = do
07:32:44 <mgdtgd>     cs <- sequence $ repeat getChar
07:32:44 <mgdtgd>     return $ takeWhile (/='\n') cs
07:32:54 <mgdtgd> but it doesn't terminate
07:33:22 <vixey> @src sequence
07:33:22 <lambdabot> sequence []     = return []
07:33:22 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:33:22 <lambdabot> --OR
07:33:22 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
07:33:31 <mgdtgd> I suppose sequence forces the evaluation of the whole list
07:33:47 <mgdtgd> before anything is returned
07:35:16 <mgdtgd> has anybody a smart idea
07:35:48 <quicksilver> mgdtgd: (a) don't do that.
07:35:52 <quicksilver> it's a terrible idea.
07:35:59 <quicksilver> (b) the answer is unsafeInterleaveIO
07:36:08 <mgdtgd> hm ok
07:36:09 <quicksilver> but the 'unsafe' should be a clue.
07:36:15 <mgdtgd> yep
07:36:25 <quicksilver> lazy evaluation and lazy IO are different things
07:36:31 <mgdtgd> I thought it was a smart idea
07:36:33 <quicksilver> lazy IO means you don't know where the IO occurs in your program
07:36:37 <quicksilver> it is a smart idea.
07:36:40 <quicksilver> it's a terrible, smart, idea :)
07:36:45 <mgdtgd> :D
07:36:48 <quicksilver> if used carefully it can do very clever tricks
07:36:57 <quicksilver> and get really neat performance out of certain algorithms
07:37:04 <quicksilver> but if used uncarefully it can be a pain.
07:37:18 <mgdtgd> oh well, back to the drawing board
07:40:08 <quicksilver> mgdtgd: you really want a monad-aware version of takeWhile
07:40:18 <quicksilver> mgdtgd: which knows how to 'break' into the IO when it gets the '\n'
07:40:31 <quicksilver> mgdtgd: that's discussed fairly often but not in the standard lib
07:40:56 <mgdtgd> yes, I tried to takeWhile on the IO Chars directly
07:41:08 <mgdtgd> but they're not instances of Eq
07:41:31 <doun> no, they are actions
07:41:43 <mgdtgd> yes, I thought so
07:42:05 <mgdtgd> (after trying to make them instances, of course)
07:42:17 <quicksilver> your simplest solution is to write your own recursion.
07:42:24 <doun> mgdtgd: funny
07:42:27 <quicksilver> you could also consider how to generalise that to write a monadic takewhile
07:42:33 <vixey> You can base it directly on the source code of sequence
07:42:34 <quicksilver> which is often called takeWhileM
07:42:34 <mgdtgd> yes, but I need three different solutions
07:42:39 <quicksilver> (it has a name even though it doesn't exist)
07:42:48 <quicksilver> a bit like santa claus.
07:42:53 <mgdtgd> haha
07:45:19 <LeCamarade> System.Time.CalendarTime's ctTZ (time zone) could be negative, if the time zone lies to the West of the GMT, right?
07:48:08 <Peaker> Where can I find some example applications that use functional reactive programming? (Except Fran). I am thinking about it and I am worried that complicated interactions between elements which are simple to express imperatively may be difficult to express in FRP (for something that repeatedly adds, you can use 'integrate', but what about far more complicated operations?)
07:49:05 <Twigathy> well, I told vlc I do only have 2 speakers, it didn't seem to make any differenc
07:49:08 <Twigathy> woah
07:49:13 <Twigathy> Utterly wrong channel :)
07:51:07 <quicksilver> Peaker: I don't know of many. Try googling conal elliott
07:51:18 <quicksilver> Peaker: or catching him here. This isn't his time of day, I don't think.
07:51:20 <quicksilver> conal: ping?
07:51:35 <conal> here
07:51:45 <Peaker> I read conal's papers, they're great! and Fran is awesome ;)
07:52:16 <LeCamarade> Does ctTZ on ClockTime show negative, for those of you West of the GMT?
07:52:29 <Peaker> I am just wondering whether FRP scales up as some kinds of complexity grow (I may be completely wrong, I haven't played with it yet)
07:52:51 <conal> Peaker: wrong to wonder?
07:53:12 <Peaker> wrong as in maybe it scales wonderfully :)
07:53:32 <Peaker> conal, do you know RTS games (Real time strategy), as in Starcraft, Warcraft, etc?  I'd like to use that as an example
07:54:02 <mgdtgd> @src foldr
07:54:03 <lambdabot> foldr f z []     = z
07:54:03 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:54:31 <doun> Peaker: presumably you have seen Frag. that might be complex
07:55:05 <conal> Peaker: i suspect that complex applications, especially like a RTS, would show that there are still one or two missing concepts from FRP.  it's something i've been thinking about lately.
07:55:13 <Peaker> doun, Yeah, its pretty cool! I do get weird periodical delays though
07:56:13 <quicksilver> one of the things which concerns me is I tend to do physical models using the difference equation approach
07:56:21 <quicksilver> i.e. after delta_t (small t)
07:56:26 <quicksilver> I move every particle by its velocity
07:56:45 <quicksilver> adjust velocities by air resistance, gravity, other forces
07:56:46 <conal> Peaker: not inherent limitations of the functional approach, just less collective experience than with imperative.
07:57:07 <quicksilver> to switch to conal's continuous time, I have to solve that differential equation.
07:57:11 <quicksilver> which, unfortuantely, I can't do :)
07:57:27 <Peaker> conal, also a bit more abstract - which may be harder to first invent (and easier later to use)
07:57:30 <conal> quicksilver: great application of frp, which has integral built in.  your code would be so much more direct.
07:57:40 <maltem> quicksilver: Can both approaches qualify as FRP?
07:57:40 <conal> Peaker: exactly!
07:57:44 <quicksilver> conal: it has integral built in? how?
07:57:54 <quicksilver> using a fixed resolution approximation?
07:58:30 <conal> quicksilver: different frp implementations have used different implementations.  i like adaptive step size, independent from visual sampling.
07:58:48 <quicksilver> conal: OK. But underneath there is a sampling process?
07:58:58 <quicksilver> conal: I agree it should be independent from visual sampling, of course
07:59:09 <quicksilver> conal: what does it do "in between samples"? clamp? or interpolate?
07:59:43 <conal> quicksilver: not sure whether you're asking about frp semantics or a particular implementation.
07:59:45 <orzo> pj mp
07:59:47 <orzo> oh no
07:59:50 <orzo> damn
08:00:17 <orzo> I think i re-implemented Data.Bytestring.Lazy without knowing it existed already
08:00:25 <conal> quicksilver: though, certainly interpolation (linear, cubic, whatever) makes sense
08:00:32 <maltem> orzo: keyboard left shift? :)
08:00:36 <orzo> heh
08:00:39 <orzo> ya
08:01:00 <quicksilver> conal: I'm asking what you recommend / suggest / what exists :)
08:01:04 <quicksilver> conal: with no particular preference.
08:01:35 <orzo> here's what i did, I have a string type that is implemented as a lazy list of bytestrings
08:01:46 <conal> quicksilver: oh, okay.  i'd do (and have done) a nice runga kutta with compatible continuous interpolation between the samples.
08:01:48 <orzo> is that what Data.Bytestring.Lazy does?
08:01:56 <quicksilver> conal: cute.
08:01:59 <quicksilver> orzo: yes.
08:02:05 <orzo> oh damn
08:02:14 <quicksilver> conal: what I should do is package up my flame simulation which uses perlin 'wind'
08:02:15 <orzo> can i use swear words here?
08:02:26 <vixey> runga kutta is beautiful
08:02:37 <quicksilver> orzo: we're generally quite nicely spoken but there is no censorship as such ;)
08:02:44 <quicksilver> conal: and you can show me how to FRP it.
08:02:51 <orzo> i'm so pissed
08:02:57 <vixey> orzo: no
08:03:17 <orzo> my version is horribly inferior
08:03:25 <orzo> and i only wrote it as the need arose
08:03:34 <orzo> and its not compatible with TagSoup
08:03:46 <conal> quicksilver: usually people wire in iterative (difference) methods to their particular problem solution.  which always means that (a) their code is cluttered by and integrator and (b) they pick a crappy integration method.  by choosing a functional (no IO) model and continuous, we instead get beautifully simple & direct problem specification and an efficient and accurate implementation.
08:04:06 <orzo> but i already have a bunch of code by now that uses it
08:04:34 * orzo contemplates suicide
08:06:57 <LeCamarade> orzo: Change the crucial part, and let the compiler guide you.
08:07:02 <LeCamarade> Change a type.
08:07:20 <orzo> it'll take a long time tho
08:07:29 <LeCamarade> Suicide is for when you've been coding in [CENSORED].
08:07:44 <orzo> heh
08:07:51 <LeCamarade> Wow. #haskell censors it when you mention that language. [CENSORED]!
08:07:57 <orzo> heh
08:07:58 <LeCamarade> [CENSORED]!
08:07:59 <orzo> you are joking
08:08:04 <LeCamarade> Try it.
08:08:11 <orzo> c++
08:08:17 <orzo> idunno what language
08:08:18 <LeCamarade> http://[CENSORED].com
08:08:22 <orzo> heh
08:08:36 <LeCamarade> Wow. It's smart. Must be written with lots of monads. :o)
08:08:40 <orzo> heh
08:09:06 <edwardk> Why do I feel like I'm playing adventure from ICFP 06?
08:09:34 <LeCamarade> Who is West of the GMT line, comrades?
08:09:40 <Syzygy-> I don't see what's so bad about talking about [CENSORED]. I mean - it's not like [CENSORED], now is it?
08:10:02 <shepheb> LeCamarade: I am
08:10:21 * Syzygy- is east of Greenwich.
08:10:27 <LeCamarade> Does ctTZ show negatives when you run the following in GHCi?
08:10:35 <LeCamarade> :m + System.Time
08:11:22 <shepheb> ...
08:12:03 <LeCamarade> ctTZisneg <- fmap (ctTZ) (toCalendarTime =<< getClockTime)
08:12:07 <LeCamarade> isneg <- fmap (ctTZ) (toCalendarTime =<< getClockTime)
08:12:12 <LeCamarade> Later version.
08:12:23 <LeCamarade> is isneg neg?
08:13:17 <quicksilver> conal: well yes, actaully I have a framerate dependent physics model at the moment
08:13:25 <quicksilver> conal: due to the laziness you describe :)
08:13:34 <shepheb> -14400
08:13:37 <LeCamarade> :o)
08:13:39 <LeCamarade> Thank you.
08:13:44 <quicksilver> conal: but since it's only playing with special effects I'm not that fussed.
08:13:50 <quicksilver> conal: would like to fix though.
08:13:53 <shepheb> for the record, I'm UTC-4, GMT-5.
08:14:08 <LeCamarade> Cool.
08:14:37 <LeCamarade> isneg <- fmap ctIsDST (toCalendarTime =<< getClockTime)
08:14:44 <LeCamarade> istrue <- fmap ctIsDST (toCalendarTime =<< getClockTime)
08:14:46 <LeCamarade> ?
08:14:52 <LeCamarade> You got DST on
08:14:54 <LeCamarade> ?
08:15:01 <christastrophe> hm, I really thought this would work: foldl ((+) . snd) 0 [('a',1),('b',2)] == 3
08:15:40 <LeCamarade> christastrophe: Change positions of snd and + and try again.
08:16:37 <maltem> @pl \a b -> a + snd b
08:16:38 <lambdabot> (. snd) . (+)
08:17:23 <Deewiant> @ty foldl
08:17:24 <christastrophe> oh.
08:17:25 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
08:17:26 <Deewiant> @ty (+).snd
08:17:28 <lambdabot> forall a b. (Num b) => (a, b) -> b -> b
08:17:44 <maltem> @pl \a b -> snd a + b
08:17:44 <lambdabot> (+) . snd
08:18:57 <maltem> (. snd) . (+)  =  flip ((+) . snd)
08:19:47 <christastrophe> haha. ok. I thought I was being clever, but I guess I wasn't being clever enough!
08:22:02 <maltem> Rule of thumb for readable code: Use explicit parameters just a little more often than you can :)
08:22:15 <Peaker> Why does Yampa use arrows for signal functions?  Arrows assign meaning to the order of composed functions, but that does not seem to matter in Yampa?
08:22:18 <orbitz> maltem: hah
08:22:43 <orbitz> maltem: it's tough, it's so fun to try to convert evertyhign to PL for fun, until you go back and try to debug it the enxt day :)
08:22:59 <Peaker> maltem, could be nice if @pl/@unpl were view-side transformations, done by the code editor at will :)
08:23:24 <sieni> especially good if you pl while drunk
08:23:29 <orbitz> hah, then aren't you just engating the point?
08:23:57 <maltem> Peaker: Heh, nice idea
08:23:57 <orzo> hey
08:23:59 <orbitz> does a pl version of a functinohave any inherent optimiation over a non pl version?
08:24:46 <maltem> orbitz, in re debug the next day: how very true
08:25:01 <quicksilver> orbitz: no.
08:25:20 <quicksilver> orbitz: naively you'd imagine it would be worse, since it adds more applications of (.)
08:25:29 <quicksilver> in practice (.) is inlined so it amounts to the same thing.
08:25:43 <orzo> i have a basic haskell question involving modules and importing qualified.  On the web page http://www.haskell.org/alex/doc/html/wrappers.html#id289577 , there is example code that imports qualified Data.ByteString.Lazy.Char8 as ByteString and then goes on to use ByteString as a type.  That looks improper to me
08:25:43 <lambdabot> Title: 5.2. Wrappers
08:25:46 <orbitz> quicksilver: yeah i'd agree
08:25:52 <orbitz> quicksilver: oh ok
08:26:10 <quicksilver> orzo: yes, I believe that is wrong.
08:27:08 <monochrom> <3 you
08:27:26 <laz0r> is there a way to create functions that behave like i.e. fromInteger?
08:27:32 <doun> I didn't realise module names and types were in the same namespace
08:28:00 <laz0r> a function where the return type is variable and solely specified by the context in which I run the function?
08:28:01 <quicksilver> doun: they're not really.
08:28:08 <quicksilver> doun: module names are *always* before a .
08:28:14 <quicksilver> doun: so they're in a namespace of their own.
08:28:14 <yitz> orbitz, maltem: my rule of thumb is: use PL if people who are not yet used to it will also see that it is nicer, and it will help convince them to use it.
08:28:20 <tromp> > 11**0.5
08:28:22 <lambdabot>  3.3166247903554
08:28:25 <quicksilver> laz0r: yes.
08:28:27 <mar77a> > exp 1
08:28:28 <christastrophe> its strange that its called point-free, when it uses the (.) point quite often... oh well.
08:28:29 <lambdabot>  2.718281828459045
08:28:47 <doun> quicksilver: yes, that's what I meant. reading the page now I notice that the ByteString type was not imported elsewhere. disregard my comment
08:28:56 <orbitz> yitz: hah
08:28:59 <mar77a> > let e n = (1 + 1/n) ** n; e 2000000
08:29:00 <lambdabot>  Parse error at end of input
08:29:00 <maltem> orzo: That example is incomplete then
08:29:20 <orbitz> yitz: i am still new to haskell and don't ahve  much experience.  I think pl is REALLY clear for some things an di love using it there, but it quickly gets outof hand
08:29:24 <Deewiant> > let e n = (1 + 1/n) ** n in e 2000000
08:29:25 <lambdabot>  2.7182811492688685
08:29:37 <mar77a> ah
08:29:41 <quicksilver> orbitz: as a rule of thumb, (.)-sections are a bridge too far.
08:29:49 <quicksilver> I don't use (foo .) or (. foo) in real code.
08:30:01 <yitz> orbitz: agreed. when it gets out of hand, better not to use it imho.
08:30:15 <mar77a> > (\x -> (1 + 1/x) ** x) 2000000
08:30:17 <lambdabot>  2.7182811492688685
08:30:53 <Deewiant> > exp 1 - let x = 2000000 in (1 + 1/x) ** x
08:30:54 <orzo> ok, thanks maltem & quicksilver .  I just wanted to be sure
08:30:54 <lambdabot>  6.791901765446084e-7
08:30:56 <yitz> quicksilver: agreed. except i might on rare occasion use one in a map.
08:30:59 <orbitz> yitz: it's like trying to implemetn all your multiplcatino with bit shfits an subtraction :)
08:32:22 <laz0r> quicksilver: ok, cool. could you give me some pointers on how to do this? should it be enough to just create a function with the a type like 'Foo -> a'?
08:32:29 <tromp> > floor(3.32)
08:32:30 <lambdabot>  3
08:33:36 <orbitz> what always thrwos me off are the (f .)
08:33:47 <quicksilver> laz0r: you will need a typeclass.
08:33:57 <quicksilver> laz0r: either you use functions on an existing typeclass
08:33:59 <quicksilver> or you make a new one
08:34:01 <maltem> @unpl (f .) . g
08:34:01 <lambdabot> (\ d i -> f (g d i))
08:34:08 <wjt> @unpl (f .) (. g)
08:34:09 <lambdabot> (\ e -> f (\ j -> e (g j)))
08:34:19 <quicksilver> :t let f n = (fromIntegral n) + 1 in f
08:34:20 <lambdabot> forall a b. (Num b, Integral a) => a -> b
08:34:25 <tromp> > [floor (k*sqrt(11))`mod`2| k<-[0..]]
08:34:26 <lambdabot>  [0,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0...
08:34:26 <quicksilver> laz0r: ^^ there I have made one :)
08:34:27 <wjt> @unpl (f .) . (. g)
08:34:27 <lambdabot> (\ e j -> f (e (g j)))
08:34:53 <laz0r> quicksilver: ok, thanks, i'll look closely at it and see if I can figure it out
08:35:07 <maltem> orbitz: (f .) . g might be still acceptable (it's just special function composition)
08:35:48 <orbitz> quicksilver: what would i look up to see the emaning of yoru definitno of f there?  i have not seen the expr in expr syntax in my books yet
08:36:20 <quicksilver> orbitz: most haskell tutorials will mention 'let'
08:36:29 <quicksilver> orbitz: it's a way of defining a "local" value or function.
08:37:04 <orbitz> quicksilver: don' you generally ahve another 'let' in there?
08:37:07 <gubagem> and if you are in a do block you dont need to do 'in' code block with the let
08:37:12 <orbitz> oh wayt
08:37:13 <orbitz> i'm retarded
08:37:18 <orbitz> i'm sorry
08:37:27 <orbitz> i was thinking it was let f = (y in z)
08:37:33 <orbitz> not (let f = y) in x
08:37:34 <orbitz> z
08:37:46 <orbitz> tahnks
08:37:51 <gubagem> let f x=x^2
08:37:54 <gubagem> continue do block
08:37:58 <gubagem> you can leave out the in
08:38:19 <quicksilver> ;)
08:38:39 <quicksilver> more significantly, you can leave out the 'do'
08:38:42 <quicksilver> that's the point ;)
08:39:01 <gubagem> how do i totally leave out the do and still do imperative code?
08:39:03 <quicksilver> "let a = b" in a do context, is shorthand for "let a = b in do .."
08:39:08 <quicksilver> you don't.
08:39:14 <gubagem> ahhh
08:39:15 <quicksilver> all imperative code goes in "do" blocks.
08:39:28 <gubagem> which i find most tutorials didnt explain very well
08:39:39 <quicksilver> that's becaue it isn't true
08:39:44 <quicksilver> sometimes I say things which aren't true ;)
08:39:52 <quicksilver> putStr "hello" >> putStr "world"
08:39:55 <quicksilver> that's imperative code
08:39:59 <quicksilver> no "do" in sight....
08:40:06 <gubagem> using the monadic bind correct?
08:40:12 * gubagem still doesnt grok monads
08:40:22 <Peaker> does frag have an AI and enemies? its "leveleg" kinda sucks :)
08:40:38 <quicksilver> gubagem: yes. the point I'm making in a slightly flippant way
08:40:48 <quicksilver> is that of course do is jsut a shorthand
08:40:52 <quicksilver> for using >> and >>=
08:41:07 <quicksilver> so really teh correct statement is "all imperative code is in IO combinators"
08:41:08 <gubagem> whats the difference between >> and >>=
08:41:17 <quicksilver> >> discards the result
08:41:25 <quicksilver> >>= feeds teh result along to the next action
08:41:35 * gubagem still slightly confused
08:41:45 <Peaker> gubagem, most languages let you write a sequence of operations that they "combine" into a procedure - such that the items in the sequence will run one by one.  In C/C++/Java usually there is a ; between the combined statements, right?
08:41:57 <gubagem> right
08:42:01 <gubagem> and they execute in order
08:42:23 <Peaker> gubagem, in Haskell, you "combine" these sequences so that they run one by one with ">>", a user-defined operator, rather than a builtin semicolon
08:43:17 <gubagem> so i can toast my do blocks and just string 'actions' together with >> ?
08:43:20 <jcaldwell> "do" notation is just syntaxtic sugar to make haskell look more like those languages
08:43:23 <quicksilver> you can
08:43:35 <gubagem> so when do i need >>=
08:43:42 <Peaker> gubagem, Almost - you sometimes need access to the result values of those actions - which will only be available in runtime
08:43:52 <Peaker> gubagem, >>= is used to "extract" the result (when it is available)
08:44:14 <dbueno> @seen dcoutts
08:44:14 <lambdabot> dcoutts is in #haskell, #gentoo-haskell, #haskell-soc, #haskell-overflow, #haskell-blah and #ghc. I last heard dcoutts speak 5h 50m 5s ago.
08:44:17 <Syzygy-> f >> g is the same as f >>= (\_ -> g) though
08:44:20 <dbueno> @seen dcoutts_
08:44:20 <lambdabot> dcoutts_ is in #haskell, #gentoo-haskell, #haskell-overflow and #ghc. I last heard dcoutts_ speak 3m 33s ago.
08:44:24 <dcoutts_> dbueno: hia
08:44:55 <Peaker> gubagem, instead of requiring both >> and >>=  you can always "extract the result" and when its not interesting, throw it away, which is what Syzygy- just showed
08:45:04 <dbueno> dcoutts_, Hey.  Could you give me just a few sentences of comments about the relation of all the fields in a Distribution.PackageDescription.GenericPackageDescription?
08:45:12 <dcoutts_> dbueno: sure
08:45:23 <dbueno> It has no comments =[ and I'm trying to figure out how all the conditions and flags relate.
08:46:12 <Peaker> gubagem, so an action is a value that exists now, and it represents some computation which may take place later.  The things you can do with the action _now_ are binding it to other actions.  To gain access to the value that will exist when the computation does take place, you can use >>=.  To "run" the computation - you do something else for each kind of moand
08:46:19 <dcoutts_> dbueno: it sometimes confuses me too :-)
08:46:57 <dcoutts_> dbueno: ok so simple bits first, the packageDescription is the bits of meta data that cannot be guarded by flags/conditionals
08:47:16 <dcoutts_> dbueno: like the package name, version, author etc, but not things like the libraries or executable sections
08:47:49 <dcoutts_> dbueno: then the flags, that's all the flags defined in the file
08:48:10 <dcoutts_> dbueno: then we have the bits for the library section and any executable sections
08:48:40 <dcoutts_> dbueno: there can be 0 or 1 libraries and there can be 0 or more executables (though when there are 0 of both the package is a bit pointless)
08:49:10 <dcoutts_> dbueno: the CondTree "condition tree" is rather highly parametrised which makes it confusing
08:49:49 <dbueno> dcoutts_ yeah, it took me a moment to figure out where contree bottomed out (until I looked at how it's used in GenericPD)
08:50:01 <dcoutts_> but basically it's a hierarchical representation of the conditions and the stuff within in the library/executable
08:50:09 <dcoutts_> since if's can be nested
08:50:44 <dbueno> dcoutts_ It helps enormously to know that the stuff inside PackageDescription is not guarded.
08:51:22 <dcoutts_> dbueno: well, beware, the package description contained inside the generic package description is incomplete, some fields are just null
08:51:27 <dcoutts_> dbueno: like build-depends iirc
08:51:46 <dcoutts_> we only get a completed package description when we flatten or finalise the generic package description
08:52:00 <Peaker> gubagem, are you less confused now? :)
08:52:11 <gubagem> ok say im doing do {args<-getArgs;let a=head args;print a}, how do i convert that into >> / >>= notation
08:52:14 <gubagem> mildly
08:52:18 <dcoutts_> dbueno: so ConfVar is the type of atomic predicates, flags, os tests etc
08:52:21 <gubagem> monads kind of scare me
08:52:29 <quicksilver> getArgs >>= \args -> let a = head args in print a
08:52:33 <hpaste>  lazor pasted "(no title)" at http://hpaste.org/7815
08:52:48 <Peaker> @undo do {args<-getArgs;let a=head args;print a}
08:52:48 <lambdabot>  Parse error at "}" (column 42)
08:52:55 <LeCamarade> gubagem: Keep this for memory's sake, for when you'll start loving them.
08:52:58 <gubagem> ok whats the '\' do, is that a lambda?
08:53:00 <dbueno> dcoutts_: So is there some magic I need to put packages through to finalise them, after getting (e.g.) an available package from the PackageIndex?
08:53:03 <quicksilver> gubagem: yes.
08:53:05 <dcoutts_> dbueno: usually we have condition expressions of type Condition ConfVar, but we can partially evaluate the constant bits of a Condition ConfVar to get just a Condition Flag
08:53:19 <quicksilver> gubagem: it's a function which takes one argument (args) and does the rest
08:53:26 <quicksilver> gubagem: if I gave it a name, it would look like this:
08:53:33 <quicksilver> f args = let a = head args in print a
08:53:38 <dcoutts_> dbueno: so flattenPackageDescription is really a local version of the thing you're trying to implement globally
08:53:52 <laz0r> quicksilver: maybe you could take a quick look at what i just posted and tell me if i am completly wrong, or maybe if i could make something like that actually work
08:54:03 <dcoutts_> dbueno: it works out a flag assignment given a set of available packages, it does that by doing a complete backtracking search
08:54:12 <Peaker> gubagem, getArgs >>= \args -> ...   means "when getArgs actually runs and has a result, give it to the function in the right hand side which returns what computation to continue with
08:54:37 <orbitz> woudl how do works be described as CPS?
08:54:38 <dbueno> dcoutts_: Oh, okay, so part of my job is to come up with a finalised description.  That makes sense, since it will freeze the variables in an assignment that satisfies all the descriptions.
08:54:39 <gubagem> k
08:54:47 <dcoutts_> dbueno: oops, finalise, not flatten
08:54:56 <Peaker> gubagem, \a -> (a*2)   means a function that returns its input multiplied by 2, btw
08:55:00 <gubagem> so if i dont use something <- Actionwithresult i can just use >> to toss the return value
08:55:24 <Peaker> gubagem, its not a return value, its a computation result (a return value is something an ordinary function returns)
08:55:29 <orbitz> can't you just do Actionwithresult and not <-?
08:55:35 <Peaker> gubagem, but yeah you can use >>=
08:55:46 <dcoutts_> dbueno: yeah, so when you know the exact flag assignment you want to use, you can call finalisePackageDescription with a total flag assignment and it will then of course not to any backtracking search since it'll have no choices to make
08:55:46 <maltem> orbitz: no, because the further function is an argument to (>>=), not to, say, getArgs
08:55:51 <quicksilver> laz0r: off-hand I can't quite see what your'e doing there :)
08:55:57 <Peaker> gubagem, all actions have results. Those that don't want to have result have a () result (empty/none/uninteresting)
08:55:59 <orbitz> ok
08:56:13 <Arnar> hey folks
08:56:35 <dcoutts_> dbueno: really we should split the thing into two bits, one that searches locally for a flag assignment and another that applies a total flag assignment to a generic package description to get out a package description. But currently they're munged together.
08:56:41 <dbueno> dcoutts_: The flagassignment's (partial or total) refer to the flag list in the GenericPackageDescription, right?
08:56:50 <dcoutts_> dbueno: yep
08:56:51 <Arnar> what symbol (on paper / TeX) do you first think of to represent an associative but non-commutative operation (like (++)) ?
08:56:55 <orbitz> there is an Array monad right?
08:57:12 <opqdonut> Arnar: multiplicative
08:57:18 <jcaldwell> []
08:57:23 <dbueno> dcoutts_: Where are the FlagAssignments referred to?  I saw it yesterday, but I can't find it now.  UnresolvedDependency?  I bet that's it....
08:57:30 <opqdonut> Arnar: think matrices :)
08:57:31 <Arnar> opqdonut: like a "*" ?
08:57:38 <Arnar> opqdonut: ah
08:57:39 <quicksilver> Arnar: (+)
08:57:45 <dcoutts_> dbueno: to a first approximation you can assume the input partial flag assignment is []
08:57:49 <quicksilver> Arnar: (+) is a pretty standard 'generic monoid' oepration
08:58:00 <quicksilver> Arnar: I mean a cross in a circle, by the way
08:58:00 <opqdonut> top and bottom are used too
08:58:03 <quicksilver> that's ascii art
08:58:11 <dbueno> dcoutts_: So each unresolved dependency might leave some flags unassigned.  Any unassigned flags become variables in the SAT problem, right?
08:58:12 <dcoutts_> dbueno: don't worry about letting the user specify a partial assignment until later
08:58:19 <Arnar> quicksilver: ah.. good, that's the one I used when not thinking about it..
08:58:20 <quicksilver> the cross at 45 degrees is another option
08:58:21 <quicksilver> (x)
08:58:26 <dbueno> dcoutts_: I can do that.
08:58:41 <opqdonut> but i'd keep with juxtaposition when only one operation is needed
08:58:43 <dcoutts_> dbueno: right each unassigned var is something you have to solve for
08:58:43 <Arnar> quicksilver: I started having doubts when I started thinking too much :)
08:58:46 <opqdonut> pretty standard algebra notation
08:59:00 <laz0r> quicksilver: i think it all boils down to: i want to 'convert' tuples, that is if have Vector2, which is basicly just (Float,Float) and then do something like 'setC 3 3.0 $ VectorFoo2 (1.0,2.0)' i would get 'VectorFoo3 (1.0,2.0.3.0)'
08:59:29 <dcoutts_> dbueno: letting the user specify a partial assignment is then no harder than fixing foo = True in your solver.
08:59:39 <monochrom>  or  or 
08:59:40 <laz0r> quicksilver: i just found: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types ... that seems to be something that i should read
08:59:41 <lambdabot> http://tinyurl.com/f9umb
08:59:42 <Arnar> quicksilver: thanks.. a 'generic monoid' operation is exactly what I'm representing
08:59:49 <dbueno> dcoutts_: Quite true.
09:00:22 <dbueno> dcoutts_: Can I assume the PackageIndex AvailablePackage is all of hackage?  That's what cabal-install downloads, right?
09:00:32 <dcoutts_> dbueno: yep
09:01:05 <dbueno> dcoutts_: And if you just run `cabal-install install` it tries to install all of hackage?
09:01:10 <gubagem> aight, why doesnt getArgs >> \args -> let fileName=head args
09:01:10 <gubagem>         in openFile fileName WriteMode >>= \fileHandle -> loop fileHandle , work
09:01:23 <gubagem> oh wait
09:01:24 <dcoutts_> dbueno: no, it installs the local package, the one unpacked in the current dir.
09:01:26 <gubagem> im an idiot
09:01:47 <dbueno> dcoutts_: Is there a simple way to invoke the 'all of hackage' test?
09:01:50 <dcoutts_> dbueno: there's no direct way of installing everything
09:02:08 <BMeph> ?go Zip Calculus
09:02:10 <lambdabot> http://citeseer.ist.psu.edu/tullsen00zip.html
09:02:10 <lambdabot> Title: The Zip Calculus - Tullsen (ResearchIndex)
09:02:11 <monochrom> idiots are delicious
09:02:11 <dcoutts_> dbueno: but you can cabal list --simple-output | sed 'magic' > pkgs
09:02:13 <dbueno> dcoutts_: Okay.  So I'd want to get a list of all package names, and install that, when I'm ready.
09:02:18 * monochrom looks for idiots to eat
09:02:42 <dcoutts_> dbueno: yeah, just use cabal list --simple-output to get a set of packages.
09:02:46 * Arnar hides from monochrom
09:02:47 <gubagem> is let syntatic sugar for something as well?
09:02:49 <dbueno> dcoutts_: Can cabal install all packages from a file?
09:02:49 <BMeph> laz0r: The above paper is also a nice one for "expanding your horizons". :)
09:03:05 <dcoutts_> dbueno: no but you can cabal install --dry-run $(cat pkgs)
09:03:24 <dcoutts_> dbueno: you'll probably find you want to do a bit of pruning since some packages are simply impossible to install, they have missing deps etc
09:03:24 <dbueno> dcoutts_:  Okay, neat.  Thanks for the help.
09:04:34 <dcoutts_> np :-)
09:05:02 <dbueno> dcoutts_: Ah, right, I'll do that.
09:05:19 <BMeph> gubagem: As far as Haskell is concerned, let is for syntactic desugaring. ;)
09:05:26 <dcoutts_> dbueno: the tricky bit I guess is generating constraints from the condition tree
09:05:48 <laz0r> BMeph: thanks, i'll take a look at it
09:05:51 <gubagem> so i can just use lambdas to do the 'binding' that let does?
09:06:17 <dbueno> dcoutts_: I think I have enough to go on.  I have a generic circuit datatype and (reasonably) efficient conjunctive normal form generation from that.  "All" I need to do now is translate the package constraints into boolean circuits.
09:06:44 <dbueno> dcoutts_: I've just gotta do that such that I can map the SAT solver's solution back into the original problem.
09:07:00 <dcoutts_> dbueno: right
09:07:05 <Peaker> gubagem, I guess you can
09:07:19 <orbitz> let x = y in z would be (\x -> z) y
09:07:46 <dbueno> dcoutts_: Thanks, I'm gonna go now and work from this.
09:08:30 <dcoutts_> dbueno: great :-)
09:08:34 <doun> Prelude Text.XML.HaXml.Parse Text.XML.HaXml.Types Text.XML.HaXml.Xtract.Parse Text.XML.HaXml.Pretty> heheh, looks like I need a way to hide these package names
09:09:24 <dcoutts_> dbueno: it'd be really nice to see a clear presentation of the semantics of cabal configurations, by translation into a simple constraint language or something
09:10:04 <dbueno> dcoutts_: Well, that will fall out of my program, excepting perhaps with the requirement of "clarity".
09:10:09 <dcoutts_> heh
09:10:22 <dcoutts_> yeah, the AST details may get in the way in a real program
09:10:29 <doun> :set prompt "XMLPackages> " <-- excellent
09:10:41 <dbueno> dcoutts_: Circuits are pretty easy to understand, so, if it's straightforward to map the concepts in the cabal world into boolean variables, then the whole thing shouldn't be too hard to understand in pieces.
09:10:55 <dcoutts_> dbueno: are you going to be writing something up for a project report?
09:11:05 <BMeph> orbitz: Okay, now write repeat in lambda-form. ;)
09:11:38 <dbueno> dcoutts_: e.g. "an unresolved dep can be satisfied if and only if the following circuit has an assignment to its inputs that outputs true"
09:12:17 <orbitz> BMeph: IEEEE
09:12:28 <dbueno> dcoutts_: I wrote the SAT solver for a school project, and wrote that up.  Actually, I would like to write this up, once it's tested and if it's reasonable fast.  I also have some ideas for extension that I'd be happy to discuss with you later.  I think they're exciting....
09:12:29 <orbitz> @src repeat
09:12:30 <lambdabot> repeat x = xs where xs = x : xs
09:12:46 <BMeph> orbitz: Heh-heh. >8*)
09:12:52 <dcoutts_> dbueno: cool, ok
09:12:57 <orbitz> :t repeat
09:13:00 <lambdabot> forall a. a -> [a]
09:13:08 <dbueno> dcoutts_: I'm being purposefully vague to avoid getting ahead of myself.  Gotta take it one step at a time.  Anyway, I must be off now.
09:13:15 <dcoutts_> dbueno: :-)
09:13:16 <orbitz> > repeat 3
09:13:18 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
09:13:22 <orbitz> ieee
09:16:16 * BMeph channels shapr and starts juggling rotating lambdas around orbitz' head
09:17:02 <sclv_> has anybody played much with join calculus?
09:17:14 <orbitz> some peepz in #ocaml have
09:17:56 <sclv_> I'm curious about trying to get an intuition for it on the cheap
09:18:55 <Lycurgus> can't find the seminal paper?
09:19:17 <gubagem> if i join calculus then want out, would it be allowed or be considered sedition, you must preserve the union at all costs, even allowing the symmetric difference
09:21:49 <sclv_> I'm reading the 2000 paper. Figured it might be a bit more clear than the earlier stuff.
09:22:41 <sclv_> But I'm always sort of a philistine -- all this exposition and clarity and defining equality and soforth is nice, but first I'm always like "show me the code!"
09:22:48 <hpaste>  lazor annotated "(no title)" with "(no title)" at http://hpaste.org/7815#a1
09:23:15 <laz0r> i figured out a way to make it work
09:23:21 <sclv_> Partly curious if people have impressions of it -- is it easy to work with, does it model what you want modeled, things like that?
09:23:32 <quicksilver> laz0r: \o/
09:24:06 <quicksilver> laz0r: you've got the general idea.
09:24:17 <quicksilver> laz0r: the key point is you need somethin like "newVector"
09:24:25 <quicksilver> laz0r: you need an overloaded generalised constructor
09:24:30 <quicksilver> laz0r: which your newVector is.
09:25:25 <laz0r> quicksilver: ok, i'll experiment some more with this i think
09:25:25 <sclv_> what does it offer over straight message-passing, etc.
09:25:51 <sclv_> these are things I won't learn from a paper either.
09:26:19 <BMeph> quicksilver, laz0r: Didn't Oleg do this, or has the paper already been referenced?
09:27:42 <saml> can I say a monad can have at most 1 value inside to be returned ?  type signature of a monad usually, Monad a
09:27:43 <quicksilver> BMeph: I think laz0r is experimenting with typeclasses rather than looking for a packaged solution :)
09:27:49 <quicksilver> saml: no.
09:27:54 <quicksilver> saml: monads may have more than 1 value.
09:27:57 <quicksilver> e.g. list monad
09:28:23 <saml> isn't list-of-a's  1 value?
09:28:32 <saml> oh i see what you mean. list is monad
09:28:40 <saml> and in it, it has many a's
09:28:51 <quicksilver> yes.
09:29:10 <idnar> hmm
09:29:16 <quicksilver> an a state monad doesn't have any value in it, exactly.
09:29:20 <BMeph> quicksilver: Ah - carry on, then. :)
09:29:21 <idnar> how does testFoo typecheck there?
09:29:22 <quicksilver> but it will do, when you give it an initial state :)
09:29:48 <quicksilver> a state monad is a recipe for constructing values (and new states) from an initial state.
09:30:06 <quicksilver> a similar intuitive description of the Cont monad is left to the reader.
09:30:25 <saml> where can I find source of instance Monad [] it says Defined in GHC.Base
09:30:31 <saml> @hoogle GHC.Base
09:30:32 <lambdabot> No matches, try a more general search
09:31:15 <idnar> I don't understand how the compiler knows the return value is VectorFoo3 and not VectorFoo2
09:31:22 <gubagem> here is a super ghetto text editor using >>= and >> instead of do blocks
09:31:24 <gubagem> import IO
09:31:25 <gubagem> import System
09:31:25 <gubagem> main=getArgs>>= \a->openFile(head a)WriteMode>>= \f->o f
09:31:25 <gubagem> o f=getChar>>= \c->if '#' == c then hClose f else hPutChar f c >> o f
09:31:40 <saml> ah i found it!  http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#(line292)
09:31:41 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/3dzxqb
09:33:14 <BMeph> saml: look up lists in the Prelude, and check out the source code. :)
09:33:29 <sclv_> relatedly, why hasn't anyway done a simple haskell port of the join calc? or have they?
09:38:08 <sclv_> or is it just that the haskell concurrency prims get you equiv stuff anyway?
09:38:47 <orzo> If Data.Bytestring.Lazy.ByteString is a list of ByteString chunks as was indicated to me earlier, then why isn't fromChunks an O(1) operation?  It is said to be O(c).  What's c?  I'm looking at the documentation on hoogle: http://haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Lazy.html#v%3AfromChunks
09:38:48 <lambdabot> http://tinyurl.com/yspt37
09:39:40 <gubagem> orzo: i would imagine c being a constant
09:40:23 <orzo> gubagem: constant time is usually written O(1) which is also used on the same web page along with things like O(n\c)
09:44:27 <orzo> also, fromChunks is specified as :: [ByteString] -> ByteString.  I would want the first ByteString there to refer to Data.ByteString.ByteString and the second to refer to Data.ByteString.Lazy.ByteString
09:44:36 <orzo> is that the case?
09:44:43 <orzo> this documentation seems to be somewhat lacking
09:45:22 <dbueno> orzo: c = number of chunks?
09:46:11 <bd_> orzo: I'd guess that haddock doesn't deal too well with namespace clashes
09:46:18 <bd_> :t Data.ByteString.Lazy.fromChunks
09:46:21 <lambdabot> [BSC.ByteString] -> BSLC.ByteString
09:46:33 <orzo> ah
09:46:59 <BMeph> orzo: If you check out the "source code" view, you'll see the signature matches... oh, NM. :)
09:48:41 <orzo> length is specified as O(n\c) but I'd expect it to be O(number of chunks) since each chunk has a length associated and we need only total them
09:48:53 <quicksilver> orzo: c = chunk size
09:48:59 <quicksilver> thus, n/c = number of chunks
09:49:01 <quicksilver> AIUI.
09:49:13 <bd_> orzo: Since each chunk is at least one byte, it is at most O(n)
09:49:20 <bd_> and since O is upper bound...
09:49:24 <quicksilver> of course they are cheating really.
09:49:30 <quicksilver> because O(n/c) == O(n)
09:49:37 <quicksilver> but I think we can understand what they're getting at ;)
09:50:09 <bd_> quicksilver: chunk size doesn't have to be a constant, eg if you apply fromChunks directly...
09:50:12 <bd_> @src fromChunks
09:50:13 <lambdabot> Source not found.
09:50:15 <bd_> bah
09:50:19 <quicksilver> bd_: true.
09:50:46 <bd_> and so worst cast it'll be O(length in bytes), as empty chunks aren't allowed in a lazy bytestring
09:50:51 <quicksilver> right.
09:51:03 <quicksilver> but length for a lazy BS is still really O(n)
09:51:08 <orzo> well, i still dont understand how fromChunks would be O(c)
09:51:30 <quicksilver> fromChunks should be O(n/c) surely?
09:51:34 <quicksilver> just like length.
09:51:37 <orzo> no
09:51:38 <quicksilver> it's got to set up the spine.
09:51:41 <orzo> it should be O(1)
09:51:56 <orzo> what's a lazy BS under the hood?  I expect a list of chunks
09:52:02 <bd_> orzo: Yes, a /lazy/ list
09:52:04 <quicksilver> it's isomorphic to a list of chunks
09:52:09 <quicksilver> that doesn't mean it *is* a list of chunks
09:52:09 <bd_> Meaning you have to traverse the list to know the length
09:52:28 <quicksilver> converting between two isomorphic list reps is an O(n) operation after all.
09:52:28 <bd_> which might involve waiting for a unsafeInterleaveIO-suspended network read
09:52:42 <bd_> so you don't know the length ahead of time :)
09:53:58 <BMeph> What I want to know is: Do the index-referring functions use Int64, so that people will understand that it's a number, and not a character of the BS? Otherwise, it seems more logical to use Word64.
09:54:03 <orzo> so O(1) or O(n/c)
09:54:57 <BMeph> I'm just a quibbler that way, though. :)
09:54:57 <orzo> O(c) makes no sense for fromChunks
09:54:57 <quicksilver> BMeph: I suppose they think that occasionally you may wish to do maths on indices
09:54:57 <quicksilver> BMeph: including subtraction
09:54:58 <bd_> BMeph: characters of the BS are Word8, aren't they?
09:55:05 <quicksilver> BMeph: and it woudl be inconvenient if they didn't support negative numbers
09:55:09 <BMeph> Yes, they are.
09:55:36 <BMeph> quicksilver: But it doesn't - it throws an error if you try to use a negative index.
09:55:48 <BMeph> "index _  i | i < 0  = moduleError "index" ("negative index: " ++ show i)"
09:55:57 <quicksilver> BMeph: You might do this though (if i - j < 0 then ... )
09:56:01 <quicksilver> BMeph: in your own code
09:56:11 <quicksilver> BMeph: if BS forced those into words, that would never be true
09:56:14 <quicksilver> BMeph: confusing you
09:56:42 <quicksilver> BMeph: what I'm saying is, Word types are dangerous for subtraction, because overflow is unflagged.
09:57:09 <quicksilver> BMeph: so making type inference force Word types onto your library user when you might reasonably expect him to sometimes do subtraction...
09:57:11 <BMeph> Ah - manipulating the retrieved indices later - I get it, now.
09:57:14 <quicksilver> yeah.
09:57:26 <quicksilver> really it's a "bug" that overflow is not flagged.
09:57:38 <quicksilver> but it's a very very hard one to fix without sacrificing performance
09:57:40 <bd_> Is Int 64-bit on 64-bit platforms? Or is it still 32-bit, like in C?
09:57:53 <quicksilver> Int is 64bit if GHC has been compiled that way
09:57:59 <quicksilver> which would be the usual way on a 64 bit machine
09:58:06 <quicksilver> really this is all GHC-specific info.
09:58:10 <mauke> "like in C"? wtf?
09:58:15 <quicksilver> but in GHC, Int will always be 'native pointer size'
09:58:30 <quicksilver> because that suits the way GHC chooses to implement things
09:58:32 <bd_> mauke: The amd64 C ABI says int is 32-bit, long and pointers is 64-bit
09:58:34 <orzo> what's {-# UNPACK #-} do?
09:58:36 <BMeph> quicksilver: Ints aren't flagged either, are they?
09:58:45 <mauke> bd_: the amd64 ABI is not C
09:58:47 <bd_> quicksilver: makes sense. And means Int is appropriate for bytestring indices :)
09:58:49 <quicksilver> (unboxed cells and boxed cells take up the same size)
09:59:08 <bd_> mauke: Well, whatever spec governs what C datatypes are on windows and linux and probably OSX too
09:59:08 <quicksilver> BMeph: no, but Int overflow is not quite so common as word overflow.
09:59:17 <quicksilver> > (4 - 3 < 0)
09:59:18 <lambdabot>  False
09:59:20 <mauke> there is no such spec
09:59:27 <quicksilver> > (3 - 4  < 0)
09:59:28 <lambdabot>  True
09:59:33 <quicksilver> > (3 - 4  < 0 :: Word64)
09:59:35 <lambdabot>  Couldn't match expected type `Word64' against inferred type `Bool'
09:59:39 <quicksilver> > (3 - 4  < (0 :: Word64))
09:59:40 <lambdabot>  False
09:59:54 <quicksilver> BMeph: if it wasn't for all my typoes, that's a surprising result.
10:00:02 <quicksilver> can lead to fiercely hard to debug problems.
10:00:20 * BMeph nods
10:00:29 <bd_> mauke: Well, regardless, all the major OSes go with int=32-bit, long=64-bit on amd64.
10:00:45 <bd_> and I suppose there's a specific spec for each OS then, or something
10:00:57 <mauke> C is not an OS :(
10:00:59 <bd_> (where major = Darwin, Windows, Linux, probably BSD)
10:01:16 <BMeph> quicksilver: Yeah, it's just easier to notice in Ints, because the flip from -2^whatever to 2^whatever is more humanly noticeable? :)
10:01:19 <bd_> mauke: true, but the OSes are typically built with C, so they put down ground rules for C implementors so, you know, libraries actually work.
10:01:44 <mauke> working libraries are optional. I prefer to live in my fantasy world of pure C
10:01:50 <bd_> eg, http://www.x86-64.org/documentation/abi.pdf
10:02:15 <BMeph> mauke: BWAHAHAHA! "pure C," that's funny! ;p
10:02:17 <quicksilver> BMeph: and people doing math around 2^whatever are probably thinking about overflow
10:02:17 <bd_> mauke: Well, you can make a C implementation with a 128-bit char type, but don't expect it to work too well without implementing a new C library for it. :)
10:02:24 <quicksilver> BMeph: people doing math around 0 aren't really :)
10:02:30 <bd_> and having severe difficulties in doing anything
10:02:48 <BMeph> quicksilver: If they were deliberately using Words, they might. ;)
10:02:52 <quicksilver> true.
10:03:08 <quicksilver> but my point is that a bytestring using words would enforce that on them possbily without them noticing
10:03:12 <quicksilver> I think you understood that point :)
10:03:19 <mauke> bd_: sure, I'd need to make a standard library for it
10:03:24 <BMeph> Eh, "po-TAY-to, po-TAH-to" I guess. :)
10:03:44 <bd_> mauke: It won't play well with the rest of the OS, is the point :)
10:04:08 <mauke> I could write a FFI
10:04:14 <bd_> You can make it work if you try hard enough (Thanks, Turing!) but it's far easier to make your primitive datatypes and structure layouts match what the OS likes to work with
10:04:17 <bd_> mauke: overhead :)
10:04:22 <orzo> data ByteString = Empty | Chunk {-# UNPACK #-} !S.ByteString ByteString
10:04:27 <BMeph> If we were really true to the types, subtracting Words would automatically give an Int result... ;)
10:04:33 <orzo> so it's not simply [S.ByteString] like i thought it would be
10:04:43 <mauke> bd_: glibc already uses different structures than the kernel and translates internally
10:04:44 <twobitwork> I have a match question and figured you all would know :) ... In set theory, what is the notation to take all of the elements which two sets _don't_ have in common?
10:04:55 <orzo> The module ought to export Empty and Chunk then
10:05:11 <bd_> mauke: in some cases, but it doesn't marshal things like int into alternate representations arbitrarily.
10:05:17 <quicksilver> orzo: it deliberately doesn't because you're not supposed to meddle with them by hand
10:05:24 <quicksilver> orzo: they have invariants you might break
10:05:30 <quicksilver> orzo: tehre is fromChunks and toChunks
10:06:14 <quicksilver> if you want to fiddle.
10:07:36 <orzo> well, my situation is that i have c code that is calling haskell with a chunk at a time, and I have some magic on the haskell side to turn that into a lazy list of chunks and pass it to a function that is automatically suspended when it needs the next chunk from c
10:08:00 <quicksilver> use fromChunks and unsafeInterleave :)
10:08:34 <orzo> well i wanted this to be as low cost as possible
10:08:55 <orzo> i'm unclear on if fromChunks would cost me in its converting my lazy list to a lazy bytestring
10:09:14 <orzo> since i construct the list in the first palce, it might be more efficient to directly construct the lazy bytestring
10:09:34 <bd_> orzo: It'd be a constant factor at worst
10:10:19 <bd_> orzo: If you can ensure that you comply with whatever the relevant invariants are, you could also construct the lazy bytestring directly using Data.ByteString.Lazy.Internal
10:10:30 <bd_> er
10:10:34 <bd_> Data.ByteString.Internal
10:10:47 <bd_> wait, I was right the first time
10:13:06 <orzo> well
10:13:12 <orzo> i'd need to knwo what the invariants are
10:13:42 <saml> can there be a monad of kind * ?
10:13:45 <saml> @kind State
10:13:48 <lambdabot> * -> * -> *
10:14:03 <saml> all monad types have kind arity greater than 1 i think
10:14:27 <saml> i mean greater than or equal to 1 (taking at least 1 type)
10:16:51 <amiddelk> saml: that's impossible because your monad is required to take some type as parameter
10:17:38 <saml> yeup. i was just confused about kind of State being arity 2
10:17:47 <saml> i thought all monads had arity 1
10:17:58 <saml> but it makes all sense because of currying
10:18:01 <bd_> orzo: I believe the important one is none of the chunks can be empty
10:18:10 <bd_> it's documented in the source somewhere
10:18:14 <saml> everything is arity 1!
10:19:27 <bd_> Haskell doesn't curry types :)
10:19:51 <saml> @kind StateT
10:19:53 <lambdabot> * -> (* -> *) -> * -> *
10:20:08 <saml> @kind IdentityT
10:20:09 <lambdabot>     Not in scope: type constructor or class `IdentityT'
10:21:17 <nolrai_> @Kind []
10:21:19 <lambdabot> * -> *
10:21:48 <nolrai_> bd_: what do you mean?
10:22:02 <saml> oh darn. all monads in mtl have kind * -> * -> * and transformer * -> (* -> *) -> * -> *. but my monad has kind * -> *. and my transformer (* -> *) -> * -> *
10:22:28 <nolrai_> list is a monad, and only has kind * -> *
10:22:45 <ndm> saml: all monads have kind * -> *, i think...
10:22:48 <hpaste>  libben pasted "lxde" at http://hpaste.org/7817
10:22:51 <bd_> nolrai_: what I mean is you can't do:
10:22:53 <saml> is there list transformer?
10:22:59 <bd_> type State s = StateT s Identity
10:23:02 <bd_> you have to do:
10:23:06 <bd_> type State s v = StateT s Identity v
10:23:20 <saml> but you can do newtype State s = StateT s ?
10:23:36 <bd_> sure but that means something different :)
10:23:57 <nolrai_> saml: yes (although it breaks some rule or somthing).
10:24:23 <nolrai_> (i think)
10:24:33 <bd_> nolrai_: It means something different, is the problem
10:24:52 <bd_> newtype State s = StateT s <-- this is Identity with a funny name
10:25:21 <bd_> It defines a type State :: * -> *  with the constructor StateT
10:25:36 <bd_> StateT :: s -> State s
10:26:45 <saml> haskell is harder than pointers
10:27:34 <nolrai_> saml: haskell tends to give compile time errors.
10:27:35 <doun> harder than any kind of sharp instrument
10:27:56 <nolrai_> IME
10:28:34 <nolrai_> oh I was talking about the list transeformer
10:29:16 <nolrai_> earler
10:29:32 <nolrai_> oh, hell comincating is tough
10:30:55 <conal> thetallguy: do you guys have a tool for wrapping external programs as 'String -> IO String'?
10:31:42 <Deewiant> bd_: type Foo s = StateT s Identity works fine here and seems to be no different from type Foo s v = StateT s Identity v
10:32:40 <thetallguy> conal: we have lazyRun, where the return type is more complicated
10:33:10 <thetallguy> conal: and I'm about to take another crack at the DualForm stuff I wrote about, but never used in anger.
10:33:42 <saml> i just pronouced monad as monath
10:34:14 <saml> monath trathformers
10:34:26 <dons> who's going to be the first to write a haskell library for viewing redddit's json stream? www.beta.reddit.com/.json
10:34:32 <conal> thetallguy: i want to wrap some referentially transparent programs as *pure*, typed functions.  i thought i'd start with a simple String -> IO String, and work from there.
10:34:33 <dons> its all of two lines :)
10:34:42 <thetallguy> conal: we're about to get together today and work on some of that stuff.  I'll write you up a guide.  I doubt any one solution will be perfect for you, but we'd be happy to update/negotiate
10:35:30 <conal> thx!
10:35:56 <thetallguy> conal: That sounds like my DualForm more than lazyRun.  It's on my plate to see if DualForm can be replaced by IVar and Applicative
10:36:31 <thetallguy> This long weekend will be a good time for me to work on that.  Keep me updated and I'll see if I can't get this all cleaned up.
10:36:33 <conal> thetallguy: oh!  do you mean the IVar that geezusfreeek and i have been playing with?
10:36:43 <conal> thetallguy: super
10:38:18 <thetallguy> conal: yes.  If you look at DualForm, the idea is to transfer values from either memory/disk to either memory/disk, but only cross the boundary once
10:39:06 <thetallguy> conal: it seemed like you were coping with the same problem with IVar, and since I hadn't finished mine, it seemed logical to at least try yours.
10:42:13 <conal> thetallguy: fortuitous intersection of interests!
10:42:39 <geezusfreeek> conal, thetallguy: just came in, nice to see others interested
10:42:52 <geezusfreeek> should i perhaps go ahead and extract ivar into its own lib?
10:44:03 <geezusfreeek> thetallguy: what is it that you are doing? i think i came in too late to see that part
10:44:07 <conal> geezusfreeek: yeah.  though i still like the double generalization over IO *and* Maybe
10:44:22 <geezusfreeek> conal: i am still thinking about that
10:44:36 <conal> geezusfreeek: okay.
10:45:02 <geezusfreeek> conal: for now i am only reluctant because i don't foresee an easy way to put ST in it, and i even tried IOSpec for a bit and couldn't formulate the proper way to do it
10:45:14 <sclv_> oh hey, did Clojure's commute primitive come up in the IVar discussions?
10:45:24 <geezusfreeek> perhaps there needs to be a better fitting type class for it
10:46:45 <conal> geezusfreeek: i couldn't get ST to work either.
10:47:01 <conal> geezusfreeek: so no pragmatic benefit yet of the generalization.
10:47:18 <conal> geezusfreeek: did you find a benefit for generalized over Maybe?
10:47:48 <thetallguy> geezusfreeek, conal: Simon M has also been working on the external run library, and I've been meaning to get some suggestions in to him.
10:47:55 <geezusfreeek> conal: what i am doing now is in place of Maybe i am using my own Temporal (formerly Available) monad, which gives me the Future functionality for free!
10:48:00 <sclv_> Maybe this is already the notion -- but if commute can be written into STM, then IVar-like things can maybe be written neatly over commute.
10:48:02 <geezusfreeek> conal: at least i hope
10:48:15 <conal> geezusfreeek: oh!!  that's nifty.
10:48:22 <geezusfreeek> conal: to futures are implemented simply with type Future = IVar (Temporal t)
10:48:36 <geezusfreeek> s/type Future/type Future t/
10:48:53 <jaj> @hoogle (Maybe a, b) -> Maybe (a, b)
10:48:54 <lambdabot> No matches, try a more general search
10:48:54 <conal> geezusfreeek: i like that a lot.  or 'type Future = IVar :. Temporal' ?
10:49:05 <geezusfreeek> conal: there may also be some meaningful use for List, but i haven't thought about it enough yet
10:49:28 <conal> geezusfreeek: neat.  now i'm seeing the point more.
10:49:36 <geezusfreeek> conal: no, IVar (Temporal t) expands to IVar :. Temporal t
10:49:58 <geezusfreeek> err
10:50:01 <geezusfreeek> IO :. Temporal t
10:50:21 <thetallguy> geezusfreeek: http://seereason.com/publications/icfp2007-linspire-experiencereport*.pdf
10:50:22 <conal> geezusfreeek: oh, yeah
10:50:22 <lambdabot> http://tinyurl.com/5s6v3f
10:50:53 <doun> hey, hey!! it kind of works! http://jbotcan.org/clixra2/Clixra.fcgi and source code: http://jbotcan.org/clixra2/
10:51:02 <doun> (NOT SAFE FOR WORK)
10:51:18 <thetallguy> geezusfreeek: roughly, conal was asking if there was any code for running processes he could get out of that venture.  We're now independent at seereason.com
10:51:49 <conal> geezusfreeek: specifically, i want to wrap up referentially transparent external programs as pure functions.
10:52:23 <geezusfreeek> conal, thetallguy: i had gathered what conal wanted, just not what thetallguy was working on
10:52:25 <conal> geezusfreeek: statically typed ones.  thought i'd start with wrapping at 'String -> IO String' and wrap more from there.
10:52:31 <conal> oh
10:52:32 <geezusfreeek> sounds useful
10:53:32 <thetallguy> conal: I'll send you the latest lazyRun, which is very small and which you could easily use as a basis
10:53:47 <conal> thetallguy: thanks.
10:54:05 <geezusfreeek> might also be fun to try using frp to insert piped unix processes into reactive systems somehow
10:54:10 <thetallguy> conal: the first argument is not a command line, right?
10:54:36 <conal> thetallguy: right, it's not.  it's the program's input stdin
10:54:38 <thetallguy> geezusfreeek: that's really been part of the big goal for a long time...
10:54:48 <geezusfreeek> ah nice
10:55:08 <thetallguy> conal: good.
10:55:24 <conal> geezusfreeek: one thing thetallguy & i want to get to is a sort of unix-for-the-21st-century, akin to Eros
10:55:36 <geezusfreeek> i'm all for that!
10:55:38 <conal> geezusfreeek: with functional composable gui-rich programs.
10:55:44 <conal> :)
10:55:50 <geezusfreeek> tangible? :)
10:55:56 <conal> yes.
10:55:58 <conal> (really functional -- no io)
10:56:04 <geezusfreeek> perfect
10:56:28 <geezusfreeek> i have always had some interest in that as well, although most of my mental approaches have not been very unix like so far
10:56:45 <geezusfreeek> mine have generally been less about gui and more about security, actually
10:57:23 <conal> oh.  for me, the unix angle was an afterthought.  i got to reading about "the unix philosophy", especially doug mcilroy's description.
10:57:51 <geezusfreeek> before i was very familiar with functional programming my approach was from the angle of object capability systems
10:58:26 <geezusfreeek> and i think that angle can still apply, but perhaps more as a formalism than as a direct implementation detail
10:58:58 <conal> geezusfreeek: sounds interesting.  i haven't thought about that stuff at all.
10:59:18 <conal> reading doug mcilroy, i realized that the unix folks' choice of explicit I/O fundamentally thwarted their goal.  and that doug knew that pipes (his invention) are equivalent to lazy evaluation
10:59:25 <conal> and to coroutines
10:59:39 <dons> conal: doug's going to be at ICFP this year giving a haskell talk, it looks like
10:59:51 <geezusfreeek> conal: basically the idea of object capability systems is just that, in some psuedo object-oriented system, objects can only communicate with other objects they have explicitly been given references to
10:59:57 <conal> dons: wow!
11:00:05 <geezusfreeek> presumably by the user or by some other object they already could communicate with
11:00:06 <dons> yeah, super awesome.
11:00:11 <lament> dons: are you coming?
11:00:20 <dons> lament: sure. i'm a "local organiser" of sorts
11:00:30 <lament> oh
11:00:44 <geezusfreeek> the "by the user" part is what i find closely related to tangible programming
11:00:47 <lament> cool
11:01:16 <solrize_> what's that clixra thing supposed to be?  it  justshows some kind of flag
11:02:12 <pcc1> dons: how do I tell hs-plugins to load the haskell98 package?
11:02:19 <pcc1> unfortunately loadPackage "haskell98" appeared to do nothing, strace reveals that the package isn't even looked for
11:02:30 <pcc1> turning on debugging for hs-plugins reveals that haskell98 package's list of object files is empty
11:02:43 <pcc1> I eventually "solved" my problem by manually loading all the dependencies using loadRawObject.  this can't be the right way to do it?
11:03:33 <dons> hmm. sounds like the dependency chasing isn't working on your set up
11:06:09 <mauke> > ""++ printf "%u" (-1)
11:06:11 <lambdabot>  "Exception: Char.intToDigit: not a digit -1
11:06:14 <pcc1> this is package.conf's line for haskell98: http://hpaste.org/7818
11:06:18 <mauke> wat
11:06:24 <saml> how would you explan Control.Monad.Trans.lift function ?
11:06:41 <saml> transforming a monadic action to another kind of monadic action?
11:07:14 <saml> > "" ++ printf "%u: the answer" 42
11:07:15 <lambdabot>  "42: the answer"
11:07:37 <saml> > "" ++ printf "%i: not the answer" (-42)
11:07:38 <lambdabot>  "-42: not the answer"
11:08:49 <twobitwork> dons, you still there?
11:08:53 <pcc1> but if I specifically loadPackage "haskell98" wouldn't that be regardless of any dependencies (causing the symbol lookup to fail on some other symbol not in haskell98)?
11:10:43 <dbueno> @seen dcoutts_
11:10:43 <lambdabot> dcoutts_ is in #haskell, #gentoo-haskell, #haskell-overflow and #ghc. I last heard dcoutts_ speak 1h 8m 59s ago.
11:11:00 <dcoutts_> @arr?
11:11:01 <lambdabot> Smartly me lass
11:11:11 <dbueno> haha.
11:11:28 <dbueno> dcoutts_: So, a package cannot specify to depend on a particular *target* of its dependency, right?
11:11:45 <dcoutts_> dbueno: what do you mean exactly?
11:11:54 <dcoutts_> what do you mean by target there?
11:12:02 <dbueno> i.e. my program might want executable-2 of some dependency, and will not be happy if only the Library is available
11:12:08 <dbueno> Maybe target is the wrong word.
11:12:21 <dcoutts_> ah, you mean the lib/exe components of a package
11:12:34 <dcoutts_> no, the package itself is the smallest unit of distribution and dependency
11:12:35 <geezusfreeek> conal: okay, i've just been convinced by the paper thetallguy linked me to just i should generalize the IO in IVar. would allow for situations where you want to wrap IO in a newtype and give the IORef extra functionality, which sounds pragmatic to me
11:13:02 <dcoutts_> dbueno: if people want the bits inside then they should split the package out into separate lib/exes
11:13:27 <geezusfreeek> conal: because it looks to me like it would allow "references" to be either in memory or on disk by writing some a newtype wrapper for IO, fitting the requirements of dualform
11:13:32 <dbueno> dcoutts_: So the lib/exe compenents might have different dependencies.  When are a package's dependencies considered resolved?  When all "targets" (lib/exe bits) have a satisfying configuration?
11:14:01 <geezusfreeek> maybe
11:14:13 <dcoutts_> dbueno: generally yes.
11:14:42 <dbueno> dcoutts_: Cool, just making sure.  Thanks.
11:14:45 <dcoutts_> dbueno: there's a slight subtlety we've not really worked out where packages can specify buildable: False
11:14:54 <conal> geezusfreeek: oh!  i like that idea.  it may be a missing piece for how to replace cabal with something functional.
11:14:55 <dbueno> dcoutts_: Yes.
11:15:05 <conal> geezusfreeek: which i've been thinking about for a while.
11:15:08 <dcoutts_> dbueno: eg people use that sometimes for test progs that they don't want to be built normally
11:15:25 <geezusfreeek> conal: oh, i didn't mentally apply it to that. does sound good!
11:15:38 <geezusfreeek> conal: i guess i'll be generalizing it again soon then :)
11:15:52 <dcoutts_> dbueno: and we typically ignore those, but some people want to use buildable: False inside a conditional in which case it's no longer clear what it means, are we trying to find a configuration where it's buildable?
11:16:06 <dcoutts_> dbueno: so I'd ignore the problem for now, we've not worked out what it means
11:16:08 <conal> geezusfreeek: i think of ghc (etc) a pure function.  the business of files is a distraction to what ghc is about, namely compilation.
11:16:14 <dbueno> dcoutts_: Yeah, I'll ignore that. =]
11:16:29 <conal> same with linking, testing, etc.
11:16:29 <dcoutts_> dbueno: just assume we need all components to be configured for the package to be configured
11:16:47 <geezusfreeek> conal: yeah, i have come to think of haskell as an "IO _generating_" language
11:16:51 <conal> if we eliminate files, then frp can run compilation etc.
11:16:58 <dcoutts_> dbueno: I think the buildDepends you get back after finalisePackageDescription is the union of all the build-depends of each component
11:17:31 <dbueno> dcoutts_: But that's relative to some satisfying assignment of the variables you can use in the description, right?
11:17:39 <conal> geezusfreeek: sadly though, when the IO is explicit, an application's semantics depends on IO's semantics which is inscrutable.
11:17:50 <dcoutts_> conal: "improve" cabal by being more functional :-) not replace cabal with something functional ;-)
11:18:26 <conal> dcoutts_: i'm fine with that language, though the new "cabal" might not anything like the old.
11:18:37 <conal> dcoutts_: inside or out
11:18:43 <dcoutts_> conal: I don't mind that :-)
11:19:07 <conal> dcoutts_: okay, then "improve" cabal, not replace!
11:19:17 <conal> "functional cabal"
11:19:25 <dcoutts_> conal: obviously, small prototypes are good first before tackling the current monster
11:19:37 <conal> dcoutts_: that's my plan.
11:19:53 <thetallguy> Heh.
11:20:15 <dcoutts_> dbueno: sorry, I'm not sure what you mean
11:20:29 <conal> i'd like to find collaborators for Functional Cabal, which is initially a research project.  anyone interested?
11:20:42 <thetallguy> I could replace dcoutts with dsfox and conal with thetallguy, and this discussion has been going on for years, starting at Linspire. ;-)
11:20:56 <dcoutts_> thetallguy: yeah? :-)
11:20:58 <geezusfreeek> conal: you can count me in as interested by lazy :)
11:21:05 <geezusfreeek> *interested but lazy
11:21:19 <thetallguy> dcoutts: Yeah.  David gets stuff done in a hurry, I struggle along behind trying to make it more functional.
11:21:22 <conal> geezusfreeek: great
11:21:25 <dbueno> dcoutts_: Only that finalizePackageDescription takes a total flag assignment, which is one of the things that needs to be discovered by the dependency resolution process.
11:21:46 <dcoutts_> conal: depends on time commitment really. I'm working with Saizan on the SoC project and I've got to do releases of the current stuff (and hand in my Phd ;-) )
11:21:49 <thetallguy> conal: I'm in, of course
11:21:54 <dcoutts_> conal: I'm always happy to talk :-)
11:21:59 <conal> cool :)
11:22:00 <pgavin> dcoutts_: hi
11:22:04 <dcoutts_> hia pgavin
11:22:10 <dbueno> dcoutts_: Er, actually, forget that.  I'm wrong.
11:22:28 <conal> one example of functional cabal would be expressing compilation as 'ghc <*> src', where 'ghc :: Reactive (Src->Obj); src :: Reactive Src'
11:22:44 <conal> (no files, no IO)
11:22:56 <dcoutts_> dbueno: hmm? I think that's right. you want to pass finalizePackageDescription a total flag assignment, otherwise it'll make decision based only on a local search.
11:23:05 <dcoutts_> conal: right
11:23:11 <dbueno> dcoutts_: Oh, k.
11:23:16 <conal> i've oversimplified.  imports makes things a bit more interesting.
11:23:29 <dcoutts_> conal: oh yes, it certainly does :-)
11:23:37 <conal> a neat thing here is that ghc itself is time-varying.
11:23:42 <pgavin> dcoutts_: did you see my email about the gtk2hs commit script?
11:24:00 <geezusfreeek> conal: yeah i was going to ask about that. in what sense would ghc be time varying?
11:24:04 <dcoutts_> conal: seems that most things are in fact when you look at them carefully
11:24:13 <dcoutts_> pgavin: not if it was today
11:24:24 <conal> geezusfreeek: ghc changes over time, doesn't it?
11:24:35 <edwardk> conal: i might be, depends on my availability
11:24:35 <pgavin> dcoutts_: hmm... I think I sent it late last night
11:24:40 <edwardk> conal (re interested)
11:24:46 <pgavin> dcoutts_: so maybe today for you :)
11:24:49 <conal> edwardk: :)
11:24:50 <geezusfreeek> conal: huh? like 6.8.1 -> 6.8.2?
11:24:51 <dcoutts_> pgavin: oh, anyway, what's the issue?
11:24:58 <dcoutts_> geezusfreeek: yeah, exactly
11:25:01 <geezusfreeek> ah
11:25:09 <geezusfreeek> well that's cool
11:25:32 <pgavin> dcoutts_: the script to send the patch log to the list didn't work
11:25:37 <geezusfreeek> i see that the vision is slightly different from what i originally though and am now even more interested :)
11:25:47 <dcoutts_> pgavin: hrm, so darcs apply worked ok
11:25:50 <pgavin> dcoutts_: /home/duncan/bin/commit-messages-split.sh: line 15: /home/darcs/bin/Xtract: No such file or directory
11:25:54 <conal> geezusfreeek: exactly!  ghc is a time-varying value that results from compilation of its own source code.
11:25:59 <pgavin> dcoutts_: yes, everything went in fine
11:26:01 <dcoutts_> pgavin: ah doh!
11:26:09 <dcoutts_> pgavin: yeah, Xtract path is wrong
11:26:11 <geezusfreeek> conal: ooh, recursive definition for ghc :)
11:26:13 <pgavin> dcoutts_: :)
11:26:34 <conal> geezusfreeek: yeah, like a FRP accum or integral
11:26:53 <geezusfreeek> i like it as accum
11:27:06 <pgavin> dcoutts_: I'm down to building the windows binaries, then we can do a release
11:27:26 <conal> geezusfreeek: better fit, though i'm still interested in replacing accum with integral at some point, using impules.
11:27:44 <conal> geezusfreeek: compiling compilers is a very useful idea even without the recursion.
11:27:48 <dcoutts_> pgavin: great, how's that going with the win32 stuff? are the scripts in the repo ok?
11:28:02 <dons> sethk: http://article.gmane.org/gmane.comp.lang.haskell.cafe/40401   CUFP time.
11:28:04 <lambdabot> Title: Gmane -- Mail To News And Back Again
11:28:22 <dons> sethk, this is your chance to hang out with us at ICFP, and talk about all the cool things you've done commercially with haskell
11:28:36 <conal> geezusfreeek: e.g., your app is a compiler (processor) for your test data.  when either your app *or* your data changes, frp will re-run the processor
11:28:59 <pgavin> dcoutts_: I think so, I might have to make a few changes, but nothing drastic
11:29:01 <geezusfreeek> conal: i see
11:29:08 <pgavin> dcoutts_: are we supporting ghc 6.4.1?
11:29:20 <dcoutts_> pgavin: depends how difficult it is
11:29:29 <pgavin> dcoutts_: well, it definitely builds
11:29:39 <pgavin> dcoutts_: shouldn't be too hard
11:29:48 <dcoutts_> pgavin: if it's easy then yeah, if it makes life easier we can drop it in this or a future release
11:30:12 <dcoutts_> pgavin: historically I've aimed for supporting three major ghc releases
11:30:26 <dcoutts_> pgavin: so atm, that'd be 6.4, 6.6 and 6.8
11:31:02 <pgavin> dcoutts_: I don't see 6.4.1 as being a problem, as long as the users don't expect ByteString :)
11:31:18 <thetallguy> conal: have we talked about import as an expression?
11:31:33 <conal> thetallguy: i don't know
11:32:01 <dcoutts_> pgavin: bytestring works with ghc-6.4.2 I know
11:32:54 <dons> if there's demand, i'm happy to ensure bytestring remains 6.4.x compatible
11:33:00 <dons> its fairly trivial to ensure this.
11:33:19 <dcoutts_> dons: if it's easy it would not hurt
11:33:28 <dons> yeah. just got to dig up an old ghc.
11:33:33 <dons> we should have testing scripts for this
11:33:39 <thetallguy> conal: sounds like we haven't, or it was vague enough that it didn't stick.  I'll write something down. briefly, I've been wondering for some time if import shouldn't be an expression in the language, rather than a sort of awkward statement stuck at the front of the module.
11:33:45 <dcoutts_> dons: you mean you don't keep N versions of ghc installed all the time ? :-)
11:33:45 <dons> i'm moving to more QA automation
11:33:56 <dcoutts_> dons: you can test it using cabal install -w ghc-6.4.2
11:33:59 <dcoutts_> dons: that's what I do
11:34:01 <thetallguy> conal: this seems to dovetail nicely with the direction you're going with Src.
11:34:01 <dons> keep the last 3, and have a script that type checks in ghci all modules, under all 3 compilers
11:34:14 <conal> thetallguy: yes
11:34:21 <dcoutts_> dons: or actually, I do: for $ghc in ghc-6.4.2 ghc-6.6.1 ghc-6.8.2; do ...; done
11:34:45 <dcoutts_> for $ghc in ghc-6.4.2 ghc-6.6.1 ghc-6.8.2; do cabal install -w $ghc; done
11:34:52 <dons> so i've type checking scripts   now that ensure all modules are both type correct, and loadable in ghci without flags on the command line
11:35:02 <conal> thetallguy: my current thinking is rewrite haskell modules into explicit applications of parameterized modules.  the aha i had a while back is that the haskell language and compilers treat modules as mutable state accessed by global variables.  the solution: functional programming.
11:35:06 <dons> so its just a matter of tweaking that to pick up 3 ghc's
11:35:20 <dcoutts_> dons: just install the old ones under /usr/local
11:35:24 <dons> yeah
11:35:30 <dcoutts_> dons: and remove the 'ghc' program, leaving only ghc-x.y
11:35:42 <dcoutts_> ghc symlink I mean
11:35:50 <dons> dcoutts_: btw, i wonder how much impact using strict pairs would have on some of our code
11:36:00 <thetallguy> conal: yes, I remember.  I'm just not sure if that subsumes my idea or not.
11:36:04 <dons> getting pairs returned in registers, in tight loops
11:36:18 <dcoutts_> would have to look at the core to see
11:36:27 <dons> i bet it would help, e.g. unfoldr
11:36:32 <dcoutts_> hmm
11:36:36 <dons> it did help readInt
11:36:36 <conal> thetallguy: it doesn't subsume.  it's an alternative.  i don't know how to make semantic sense out of import as an expression.
11:36:46 <dons> (Int :*: Strict.BS)
11:36:50 <dons> two values in registers
11:36:59 <thetallguy> conal: old modules to new modules as power strips are to http://coroflot.com/public/individual_file.asp?from_url=true&sort_by=1&portfolio_id=1150545&individual_id=72006
11:37:02 <lambdabot> Title: TAKUMI YOSHIDA - Loughborough, United Kingdom - Revolve | Power Strip, http://tinyurl.com/59bmzn
11:37:43 <dons> we should get strict pairs and maybes into base.
11:37:55 <dcoutts_> na, we should fix the CPR/strictness analysis
11:37:58 <dcoutts_> :-)
11:37:59 <thetallguy> conal: I'm sure I don't either, but I'll write down what triggered the thoughts.
11:38:09 <dons> i'm not sure it's always going to work for lazy pairs anyway
11:38:14 <conal> thetallguy: wowzers.  i love that power non-strip
11:38:22 <thetallguy> conal: gotta move venues.
11:38:23 <dons> i.e. folds still need strict pairs for non trivial accumulators
11:38:25 <geezusfreeek> thetallguy: powerStripA `mappend` powerStripB ? ;)
11:38:30 <dons> if you want to really get a register bound loop
11:38:32 <dcoutts_> dons: surely if they're used strictly
11:38:45 <dons> you have to k (!x , !y) x = ...
11:38:46 <conal> thetallguy: k
11:38:47 <dons> :(
11:38:49 <pgavin> dcoutts_: well, gtk2hs only uses BS in a few places (notably cairo, gnomevfs, and gstreamer); the configure script doesn't check for bytestring unless SPLIT_BASE is defined
11:38:50 <dcoutts_> dons: sure
11:38:59 <thetallguy> conal: yeah, put core77.com into your rss feed.  It's like reddit for Industrial Design.
11:39:02 <pgavin> dcoutts_: SPLIT_BASE is never defined for 6.4.1
11:39:15 <dcoutts_> pgavin: ah I see
11:39:17 <conal> thetallguy: will do.  i'd forgotten.
11:39:30 <pgavin> dcoutts_: so what I've done for gnomevfs & gstreamer is just not support BS for 6.4.1
11:39:40 <pgavin> dcoutts_: I don't expect any complaints
11:39:42 <dcoutts_> pgavin: I think that's fine
11:39:42 <thetallguy> conal: for example: http://www.coolhunting.com/archives/2008/05/kraanspoor_dock.php
11:39:43 <lambdabot> Title: Kraanspoor: Dock Turned Office Building
11:39:46 <doun> dons: I figured out the HaXML stuff. it seems it does mildly advanced stuff when I wanted a dumb library :] e.g. in getURL here: http://github.com/chrisdone/clixra/tree/master/View/View.hs
11:39:47 <lambdabot> Title: View/View.hs at master from chrisdone's clixra &mdash; GitHub
11:39:52 <conal> thetallguy: no feed found at core77.com :(
11:40:00 <thetallguy> conal: the coolest new building on the planet.
11:40:00 <conal> thetallguy: nm.  found it
11:40:24 <dons> doun: great!
11:40:36 <doun> ^_^
11:44:17 <lament> the coolest new building is _still_ sagrada familia
11:44:38 <lament> and has been for more than 100 years :)
11:44:52 <mauke> gaudi++
11:46:34 <lament> (but kraanspoor is also really cool)
11:53:56 <brad_larsen> anyone have an example of a simple compiler in haskell, but one that also performs semantic analysis?
11:54:38 <brad_larsen> i'm working on a toy compiler for a course of mine, and I'm getting hung up on how best to structure it, e.g. datatypes and type classes
11:55:26 <dons> brad_larsen: hmm
11:55:27 <brad_larsen> it handles some simple arithmetic expressions, but can handle integer and float expressions
11:55:42 <dons> http://haskell.org/haskellwiki/Applications_and_libraries/Compilers_and_interpreters
11:55:43 <lambdabot> Title: Applications and libraries/Compilers and interpreters - HaskellWiki, http://tinyurl.com/2dt77g
11:56:08 <brad_larsen> so, I parse the source to build an AST, then analyze that AST (converting it into a different type), then do codegen on the analyzed tree.
11:56:41 <orbitz> i represent a recursive function with lambdas?
11:56:56 <brad_larsen> I'm poking around the ghc sources right now, but it's intimidating.
11:57:00 <brad_larsen> dons: thanks, I'll take a look
11:57:43 <orbitz> hrm
11:59:41 <saml> > fix (\fac n -> if n <= 0 then 1 else n * fac (pred n)) 10 -- orbitz
11:59:45 <lambdabot>  3628800
12:00:16 <saml> but i'm using fix also. not pure lambdas
12:01:08 <monochrom> You need something like fix or something like let (letrec in ocaml). No escape.
12:01:54 <dcoutts_> aarg! how do people work without cabal-install?
12:02:12 * dcoutts_ installs haskell software on an old machine...
12:02:28 <Deewiant> download tarball, runghc Setup.hs
12:02:35 <Deewiant> it's trivial
12:02:37 <monochrom> I live without cabal-install by: tar -xzf blahblah; Setup configure; ...
12:02:45 <dcoutts_> but I have to manually chase deps, it's such a pita
12:02:47 <sclv_> b) chase dependencies. c) chase dependencies of dependencies.
12:02:48 <saml> does cabal-install resolve dependencies?
12:02:54 <dcoutts_> saml: of course
12:03:15 * dcoutts_ is spoiled by using cabal-install all the time
12:03:15 <sclv_> d) bytestring incompatibility :-)
12:03:36 <monochrom> I rarely have dependency chore. I use extralibs, eliminates 90% of dependency chore. :)
12:03:36 <dcoutts_> sclv_: ah, my new cabal-install dep resolver will fix that :-)
12:03:39 <BMeph> orbitz: ...and THAT's why let is used to de-sugar other constructs. :)
12:04:51 <monochrom> Anyway, in untyped lambda calculus, you can implement fix using pure lambdas. In typed lambda calculus, you need fix or letrec given to you as builtin.
12:06:59 <monochrom> The latter is proved by: proving that typed lambda calculus is strongly normalizing, implying anything writable terminates when you execute it, implying you can't express all possible recursions, and so you need extra builtins.
12:10:13 <saml> if I have State String Int
12:10:57 <monochrom> Parse error. Expecting comma, "then", or clause.
12:11:50 <saml> if I have StateT String (ReaderT Char IO) Int, I can use ask function. is it because StateT implements lift function?
12:12:04 <saml> or is it because ReaderT implements lift function?
12:12:39 <Cale> It's because there's an instance (MonadReader r m) => MonadReader r (StateT s m)
12:12:48 <monochrom> Neither. It is because StateT implements ask function by forwarding to the next layer (which happens to be ReaderT, which has the real ask).
12:12:55 <mauke> it's because StateT implements MonadReader
12:13:30 <saml> hrm i'm not sure about the role of lift then (StateT implements MonadTrans. so does ReaderT)
12:13:42 <monochrom> lift isn't used.
12:14:07 <monochrom> Or to answer your question directly, the role of lift is to confound you.
12:14:17 <monochrom> You know, red herring etc.
12:14:25 <Cale> saml: if T is a monad transformer, and M is a monad, lift can be used to turn M-computations into T M-computations.
12:14:59 <Cale> Actually, I kind of dislike the lifting instances for the reason that they confuse the hell out of beginners.
12:15:12 <saml> Cale: i'm drawing a stack of monads (monad transformers).. and trying to picture how lift "lifts" bottom actions to top actions
12:15:15 <Cale> (that is, the instances like: MonadReader r m => MonadReader r (StateT s m))
12:15:30 <orbitz> BMeph: haah i know why let is gooood i'm justtryign to fid teh equivalent
12:15:59 <mauke> printf is made of concentrated satan
12:16:10 <monochrom> They are necessary because for example the "local" method has to be rewritten, not a straightforward forwarding.
12:16:12 <orbitz> can i get that at walmart?
12:16:26 <mauke> I have %c, %s and %u working now, but I dread %d
12:16:31 <Cale> monochrom: right, there's actual content there.
12:16:44 <orbitz> mauke: can i see? (will i understand?)
12:16:47 <Cale> monochrom: It's just a shame that they cloud the presentation of monad transformers so much.
12:16:53 <saml> StateT s (ReaderT r m) a  ==> drawn as [State, Reader]  where State is top.
12:17:17 <mauke> orbitz: no, but you can look at the source of Text.Printf :-)
12:17:26 <Cale> saml: [StateT, ReaderT], you mean? :)
12:17:27 <orbitz> do I want to?
12:18:04 <mauke> probably not
12:18:08 <malebria> Is there a function for Integrals like div, but that rounds up?
12:18:13 <mauke> but it demonstrates how to write vararg functions in H98
12:18:17 <malebria> like f 5 2 = 3
12:18:27 <monochrom> > div (-5) 2
12:18:28 * orbitz takes a look
12:18:29 <lambdabot>  -3
12:18:43 <malebria> hum..
12:19:01 <saml> > let  f a b =  div a b + 1 in f 5 3
12:19:03 <lambdabot>  2
12:19:08 <int-e> @type (negate .) . div . negate
12:19:12 <lambdabot> forall a. (Integral a) => a -> a -> a
12:19:15 <mauke> > let f n c = (n - 1) `div` c + 1 in f 5 2
12:19:16 <monochrom> f 5 2 = negate (div (negate 5) 2)
12:19:17 <Cale> > let f x y = - div (-x) y in map (f 5) [0..5]
12:19:20 <lambdabot>  [Exception: divide by zero
12:19:21 <lambdabot>  3
12:19:23 <Cale> > let f x y = - div (-x) y in map (f 5) [0..5]
12:19:25 <Cale> > let f x y = - div (-x) y in map (f 5) [1..5]
12:19:25 <lambdabot>  [Exception: divide by zero
12:19:27 <lambdabot>  [5,3,2,2,1]
12:19:43 <mauke> > let f n c = (n - 1) `div` c + 1 in map (f 5) [1..5]
12:19:44 <sclv_> mauke: what's yr. rewrite of printf going to look like?
12:19:44 <lambdabot>  [5,3,2,2,1]
12:19:48 <monochrom> Inspired by lattice theory!
12:19:50 <int-e> f x y = 1 + div (x-1) y  is more obvious, I guess.
12:19:56 <mauke> sclv_: it will be awesome.
12:20:08 <int-e> hmm
12:20:16 <sclv_> will it take format strings like a "standard" one, or some sort of composition of functions to get typing?
12:20:20 <int-e> > (-5) `div` (-3)
12:20:21 <lambdabot>  1
12:20:26 <monochrom> IMO 1 + div (x-1) y is very non-obvious.
12:20:29 <saml> if T is a monad transformer, and M is a monad, T M is a monad. True?
12:20:29 <mauke> sclv_: format string
12:20:37 <Cale> saml: right
12:20:38 <int-e> but probably broken for negative divisors.
12:20:38 <sclv_> so what makes it better than what we've got?
12:20:55 <Cale> saml: Monad transformers turn monads into other monads.
12:21:06 <mauke> sclv_: Text.Printf has a few bugs
12:21:09 <malebria> It should work for negative numbers..
12:21:31 <sclv_> ah... why a rewrite instead of a patch?
12:21:31 <mauke> sclv_: it also doesn't do %b, %B or the vector flag (which were introduced by perl)
12:21:46 <mauke> sclv_: I already sent a patch like 10 months ago
12:22:35 <Cale> saml: A good engineering point is to build up a monad you're interested in using a stack of transformers, and then wrap the resulting composition in a newtype, and use GHC's newtype deriving feature to derive instances of Functor, Monad, and any of the transformer classes you want.
12:22:57 <Cale> saml: This obscures the fact that you're using monad transformers from the user of your library.
12:23:18 <Cale> (in fact, if you don't export the data constructor for your newtype, it will do so perfectly)
12:23:25 <mauke> > ""++ printf "%+*d" 5 3
12:23:26 <lambdabot>  "   +3"
12:23:43 <mauke> > ""++ printf "%+*d" (-5) 3
12:23:44 <lambdabot>  "+3"
12:23:47 <mauke> fail
12:23:53 <sclv_> not to be a nudge here, but can't you just bug the libraries list a bit if you're worried about the patch not getting accepted?
12:24:06 <saml> lift turns M-computations to T M-computations. M-computations are used in M. T M-computations are used in T M. M computations cannot be used in T M. But sometimes they can, when there is instance (T m) => T (M m)
12:24:24 <Cale> M computations cannot be used in T M.
12:24:53 <Cale> The reason that things like get, ask, etc. can be used in multiple monads is that they're polymorphic themselves.
12:24:55 <mauke> sclv_: too complicated
12:24:57 <Cale> :t ask
12:24:58 <monochrom> What? Surely M computations can be used in T M. Just that sometimes it is uninteresting.
12:24:59 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
12:25:04 <mauke> also, my patch doesn't fix all issues
12:25:07 <Cale> monochrom: You have to lift them first.
12:25:14 <monochrom> Yes.
12:25:30 <Cale> You can't just use them directly.
12:25:31 <sclv_> yeah, printf contains multitudes.
12:25:53 <Cale> However, the polymorphism of things like 'ask' and 'get' confuse the issue a bit.
12:26:02 <monochrom> That paragraph is confusing IMO.
12:26:30 <Cale> 'ask', as you can see from its type, is not a computation in any one monad, it's a computation in an arbitrary monad which is an instance of MonadReader
12:26:32 * sclv_ idly wonders if an implementation taking an arbitrary tuple wouldn't be cleaner to write than a vararg style one.
12:26:42 <monochrom> I mean, as witnessed by a disagreement on what is meant by "can be used" between the two of us.
12:26:43 <dcoutts_> pgavin: ok, the darcs commits should come through
12:26:54 <dcoutts_> pgavin: and future ones should work too
12:28:30 <mauke> > ""++ printf "%100s" (repeat 'z')
12:28:31 <Cale> saml: Does it make sense anyway?
12:28:42 <lambdabot>  "
12:28:46 <ndm> @seen Igloo
12:28:47 <lambdabot> Igloo is in #haskell, #haskell-soc, #darcs and #ghc. I last heard Igloo speak 5h 18m 59s ago.
12:29:00 <ndm> (or even dcoutts)
12:29:18 <dcoutts_> ndm: mm?
12:29:20 <Cale> saml: So when you apply ask, you might be applying it at the type M, or you might be applying it at the type T M (or you might even be using it polymorphically)
12:29:44 <ndm> dcoutts_: how does one go about getting a package removed from cabal? other than making it root people by default
12:29:58 <dcoutts_> ndm: you mean from hackage. You ask ross nicely.
12:30:07 <dcoutts_> ndm: which package ooi?
12:30:11 <saml> Cale: yes i forgot about MonadReader/Writer/..  typeclasses.
12:30:19 <ndm> dcoutts_: Safe, i've uploaded safe, as that is the cabal preferred convention
12:30:28 <dcoutts_> ndm: we don't remove packages just because they're obsolete
12:30:44 <ndm> dcoutts_: i guess i can upload Safe 1.0, saying "go download safe"
12:31:00 <saml> Cale: i was confused to think that instance (MonadReader m) => ...   is about stacking up a monad onto another. while it's just function overloading.
12:31:09 <dcoutts_> ndm: some day we'll add support for adding notes to existing packages indicating an upgrade path
12:31:22 <dcoutts_> ndm: there's an open ticket on it if you want to hack :-)
12:31:31 <ndm> dcoutts_: my hacking time is already overallocated
12:31:36 <dcoutts_> I know :-)
12:31:51 <dcoutts_> ndm: don't worry about the old one, no need to take it down
12:32:00 <ndm> dcoutts_: fair enough
12:32:03 <dcoutts_> ndm: indeed we'd rather you did not
12:32:25 <ndm> i don't mind not taking it down, but i don't want users thinking its hte most recent version
12:32:28 <dcoutts_> ndm: it's good to have a historic record. Separately of course we need a way of presenting the current and the best.
12:32:44 <dcoutts_> ndm: right, it's about presentation and filtering, not the actual content of the archive
12:35:00 <ndm> dcoutts_: fair enough, well consider me an implicit cc on that bug :)
12:36:04 <dcoutts_> ndm: you can add yourself to the cc:
12:36:05 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/261
12:36:07 <lambdabot> Title: #261 (Marking packages deprecated) - Hackage - Trac
12:37:01 * dcoutts_ invites Haskell web hackers to have a go at this feature ^^
12:37:08 * ndm turns an implicit cc to an explicit one
12:37:25 <dcoutts_> ndm: you could cite your example as a comment too
12:45:38 <hellige> category theory question...
12:45:51 * dcoutts_ runs for the hills...
12:46:07 <hellige> ;) it's an easy one...
12:46:18 <Cale> I'll give it a shot
12:46:26 <hellige> i'm looking for the name for a particular construction
12:46:28 <BMeph> ndm: Did you ever find a satisfactory way to display 1-tuples?
12:46:47 <hellige> i think it's roughly the dual of natural transformation, so maybe "conatural transformation", but i'm not sure
12:47:03 <ndm> BMeph: no, data One a = One a is the best anyone came up with
12:47:11 <hellige> rather than functors F, G: C->D and mediating arrows in D
12:47:26 <hellige> i want categories F, G: C->D with mediating arrows in C
12:47:53 <hellige> so that for all X in C, we have: F(X) = G(eta(X)) in D
12:48:15 <hellige> so basically , just like a natural transformation, but we have morphisms on the other end.
12:48:56 <hellige> whoops, of course i mean "i want FUNCTORS F, G: C->D ..." rather than "categories"
12:49:56 <Cale> uh...
12:50:21 <Cale> F(X) is an object, as is X
12:50:34 <hellige> yes
12:50:40 <Cale> eta(X) is what?
12:50:50 <hellige> oh, eta(X) is an object in C
12:51:10 <hellige> "eta" is a collection of C-arrows, one for each object
12:51:17 <hellige> just like a natural transformation.
12:51:28 <Cale> So eta(X) is the component of eta at X?
12:51:33 <Cale> Wouldn't that be an arrow?
12:52:32 <hellige> yes it would. i've confused myself.
12:53:18 <hellige> thanks for pointing it out. so let me ask a simpler question.
12:53:26 <hellige> what's the dual of a natural transformation?
12:53:54 <Cale> Another natural transformation, I expect.
12:54:22 <hellige> that was my hunch too, but i've never seen it written down.
12:54:52 <hellige> anyway i think the right way to say what i originally intended was:
12:55:28 <BMeph> String diagrams! I wanna see string diagrams! ;)
12:55:55 <BMeph> (Say, that'd make a good ?yow  response, eh? :)
12:56:35 <hellige> we have an object Y and arrow eta_X : X -> Y so that
12:56:40 <hellige> F(X) = G(Y)
12:56:57 <hellige> (Y and eta_X in C, equality in D)
12:58:28 <Peaker> did anyone here play frag?
12:58:57 <edwardk> @src curry
12:58:59 <edwardk> @src uncurry
12:59:39 <jaj> @b52s
12:59:46 * edwardk pokes lambdabot. looks up and sees category theory questions.
13:00:23 <edwardk> hellige: i have functors c -> d in category-extras, i haven't been willing to break my dependency on the standard library the rest of the way to run them throughout though =)
13:00:52 <Cale> edwardk: How do you represent categories?
13:01:25 <Cale> edwardk: Just categories enriched over Hask?
13:01:29 <edwardk> cale: in the control.category sense. its not qutie as strong as i'd like but it works for the interesting case
13:01:39 <hellige> edwardk: yeah, i saw a bit of discussion about that yesterday
13:01:40 <edwardk> and yeah they are all hask enriched
13:02:03 <hellige> nice post on kan extensions, btw.
13:02:16 <edwardk> hellige: thanks. writing up one on adjunctions <-> kan extensions now
13:02:48 <edwardk> figured it'd be useful to show currying and uncurrying as related to this scary kan extension thing ;)
13:03:06 <hellige> indeed
13:03:23 <Cale> hellige: I'm not quite sure I completely understand what you're defining yet :)
13:03:51 <hellige> cale: i'm not sure i do either!
13:03:57 <hellige> thanks for thinking about it, though.
13:04:11 <Cale> Let's see if I can clear this up...
13:04:13 <lambdabot> curry f x y = f (x, y)
13:04:13 <lambdabot> uncurry f p = f (fst p) (snd p)
13:04:13 <lambdabot> Some say she's from Mars, or one of the seven stars that shine after 3:30 in the morning. WELL SHE ISN'T.
13:04:20 <Cale> You still have two functors F, G: C -> D
13:04:30 <hellige> right
13:04:31 <jaj> lambdabot: lag
13:05:52 <dons> dcoutts_: http://code.google.com/p/bitmatch/
13:05:53 <lambdabot> Title: bitmatch - Google Code
13:06:01 <Cale> and so for any arrow f: X -> Y in C, we have two images of that arrow, Ff: FX -> FY in D, and Gf: GX -> GY in D
13:06:26 <Cale> You said something about FX and GY being the same object somehow?
13:06:46 <dcoutts> dons: oh, a syntax extension
13:06:55 <hellige> right.
13:06:56 <Cale> Are we picking a specific arrow f? That would be rather different from the case of natural transformations...
13:07:08 <hellige> well, basically here's what i have in mind, intuitively...
13:07:13 <hellige> given two functors F and G
13:07:23 <dons> dcoutts: yeah, camlp4
13:07:36 <hellige> a natural transformation is a weak kind of equivalence between them
13:07:41 <Cale> yeah
13:07:50 <hellige> established by choosing mediating arrows in D (the target category)
13:08:22 <hellige> i have in mind the same kind of weak equivalence, but established by choosing mediating arrows in C (the domain)
13:08:38 <Cale> I'm not sure how the types will work out in that case though...
13:08:44 <Cale> You could maybe do both at once...
13:09:01 <Cale> You need something to go from FX to GX
13:09:15 <Cale> Or it's rather hard to compare the two :)
13:09:20 <hellige> well, forget about GX
13:09:33 <Cale> Okay, so we just have a single functor?
13:09:38 <hellige> no, two functors.
13:09:42 <hellige> basically given X
13:09:47 <hellige> i want to choose Y so that FX = GY
13:10:11 <Cale> ah, okay
13:10:16 <hellige> so another way to think of it
13:10:31 <hellige> is to take th standard diagram for natural transformation and literally flip the arrows.
13:10:39 <thoughtpolice> clear
13:10:50 <thoughtpolice> damn, forgot the / :(
13:11:14 <Cale> hellige: when I do that, I end up with a natural transformation from G to F
13:11:36 <hellige> oh, i'm thinking of a different diagram...
13:11:38 <edwardk> hellige: as do i
13:11:57 <hellige> if you put X,Y,f (in category C) in the diagram as well
13:12:23 <hellige> then you end up "flipping the arrows" on the functors as well.
13:12:53 <hellige> so (under this construction) you end up with F,G: D->C
13:13:59 <hellige> anyway i find the other intuition clearer... taking two functions F and G and establishing an equivalence by means of arrows in the domain rather than arrows in the codomain.
13:14:16 <Cale> Well, let's see, you have that for any objects X, Y, the maps eta_X: FX <- GX and eta_Y: FY <- GY are such that for any f: X <- Y, we have Ff . eta_Y = eta_X . Gf ?
13:14:35 <Cale> oh
13:14:49 <Cale> hmm
13:15:21 <Cale> No, that's right, I think.
13:16:12 <hellige> that's right.
13:16:35 <Cale> So this is exactly the same thing as a natural transformation from G to F.
13:16:48 <Cale> I think what you were doing is something rather different...
13:16:50 <hellige> but again, the functors i'm interested in are not F and G, but their inverses.
13:16:58 <hellige> (assuming such exist)
13:17:01 <Cale> hmm
13:17:11 <hellige> that's what i mean by flip ALL the arrows.
13:19:04 <hellige> anyway, this is by now more time/ink than it's worth for an idle curiosity... :(
13:20:03 <hellige> i was mostly just hoping for one of: "oh, that's called a such-and-such" or "that's equivalent to a ..."
13:20:56 <Cale> Can we formulate this in terms of an endofunctor on C?
13:21:05 <hellige> well, i thought of that as well.
13:21:34 <hellige> it's ALMOST like saying i want an endofunctor E so that F = GE
13:21:49 <Cale> Like, just a functor H: C -> C such that FH = G?
13:21:51 <Cale> yeah
13:22:12 <hellige> but a natural transformation isn't QUITE just a functor in D, is it?
13:22:32 <hellige> i mean, i could say i want a D-functor K so that KF = G
13:22:43 <hellige> but a natural transformation is a bit more subtle than that.
13:24:19 <doun> if I use randomR (x,y), is it ever possible that it will return a number greater than y? I have the weirdest error: http://github.com/chrisdone/clixra/tree/master/View/View.hs  apparently on line 48 !! is out of bounds. which is weird because I use the length of the list -1 as the maximum value
13:24:20 <lambdabot> Title: View/View.hs at master from chrisdone's clixra &mdash; GitHub
13:25:27 <doun> this happens randomly, of course
13:25:53 <Cale> Okay, so perhaps you don't quite want a functor, but just a family of maps and associated objects?
13:26:13 <hellige> yes, that's what i have in mind.
13:26:26 <dmwit> :t getStdRandom
13:26:28 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
13:26:41 <dmwit> :t randomR
13:26:43 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
13:27:24 <dmwit> doun: Is entries ever empty?
13:28:02 <dmwit> ?hoogle StdGen
13:28:02 <lambdabot> System.Random.StdGen :: data StdGen
13:28:02 <lambdabot> System.Random.mkStdGen :: Int -> StdGen
13:28:02 <lambdabot> System.Random.getStdGen :: IO StdGen
13:28:17 <dmwit> > randomR (0, -1) (mkStdGen 0)
13:28:17 <doun> dmwit: the file is never changed. do you think it might be an access problem? ie two threads reading the file at the same time causing some weird conflict?
13:28:18 <lambdabot>  (0,40014 40692)
13:28:58 <orbitz> > otherwise
13:29:00 <lambdabot>  True
13:29:27 <dmwit> doun: Dunno.  Something doesn't seem right.
13:29:50 <dmwit> doun: What's the exact run-time error you get?
13:31:07 <doun> 500 Internal Server Error
13:31:07 <doun> Prelude.(!!): index too large
13:31:07 <doun> Haskell CGI on lighttpd/1.4.19 at jbotcan.org, port 80
13:31:27 <dmwit> Is it possible that any of the libraries use (!!)?
13:31:33 <Cale> hellige: actually, when I write this out, I'm not sure how making it a family of maps is useful...
13:31:46 <hellige> cale: how do you mean?
13:32:02 <dons> dmwit: seems unlikely
13:32:14 <dmwit> yeah
13:32:33 <dmwit> doun: One way to find out if this is the case is to write your own "error" call right before the (!!), and see if you still get that runtime error or your new error...
13:32:35 <Cale> hellige: Well, let's suppose that for each X in C, there is some object HX such that FX = GHX
13:32:47 <doun> dmwit: hm, wait a moment! sorry, I think it is line 39. I had completely missed that line
13:33:21 <dmwit> Ah, yeah, that makes more sense.
13:33:21 <hellige> Cale: ok
13:33:29 <doun> dmwit: I am confident it is that line. sorry for wasting your time. thanks
13:33:39 <Cale> hellige: In order to relate the functors on arrows, we have to look at what happens to a map f: X -> Y in C.
13:34:09 <Cale> and presumably, something will be going on with a map HX -> HY
13:34:25 <hellige> right
13:34:30 <Cale> but which map?
13:34:34 <hellige> i would imagine that we also require the existence of such a map
13:34:38 <hellige> call it g
13:34:45 <Cale> How about Hf?
13:34:46 <hellige> so that F(f) = G(g)
13:35:00 <hellige> there is no Hf (remember, H is just a family of maps in C, it's not a functor)
13:35:16 <Cale> H is an association of objects in C to other objects in C
13:35:19 <hellige> just like in a natural transformation, we don't ask about eta(F(f))
13:35:24 <Cale> It's not a family of maps
13:35:48 <Cale> I haven't introduced any family of maps yet.
13:36:06 <hellige> oh, right. sorry. i had in mind both an association of objects and a family of maps.
13:36:32 <hellige> given X in C, we get an object Y and a map eta_X: X -> Y
13:36:43 <Cale> Yeah, on my page I have some maps  eta_X : X -> HX, but I don't actually know how to use those for anything.
13:37:16 <Cale> You can do something like insist that eta_Y . f = Hf . eta_X
13:37:38 <saml> i have a bunch of custom monad transformers. when I build a monad using them and ErrorT, do I put ErrorT at the top (outer most) ??  then I need to make ErrorT e m an instance of my classes (interfaces).
13:37:48 <hellige> right, ok, so yes, you can think of this as an endofunctor.
13:37:56 <hellige> because that's exactly what we want.
13:38:13 <hellige> given f: X -> Y, we require the existence of some map Hf: HX -> HY
13:38:23 <saml> i'll try to move ErrorT to the bottom and see
13:38:56 <hellige> so that eta_Y . f =  HF . eta_X
13:39:06 <hellige> (HF should be Hf)
13:39:37 <EvilTerran> saml, if you want magic lifting, you'll either need MonadError instances for your transformers, or MonadWhateverYou'reUsing instances for ErrorT
13:39:53 <hellige> and so that all the images under F and G are equal in D
13:40:15 <hellige> F(X) = G(H(X), F(Y) = G(H(Y), F(f) = G(H(f))
13:40:33 <Cale> hellige: Requiring the existence of the etas makes the definition stronger rather than weaker though. Is that what you really want?
13:40:43 <Cale> (that is, it would apply in fewer cases)
13:41:36 <hellige> well, i'm not sure i "really want" anything in particular.
13:41:39 <Cale> okay
13:41:41 <hellige> but yes, i see what you mean.
13:42:03 <hellige> so let's see how this contrasts with natural transformations...
13:42:32 <hellige> it seems to me that natural transformations are more interesting because the functors F and G need not cover the entire category.
13:42:46 <hellige> in their domain, of course, they're everywhere defined.
13:43:22 <hellige> so this notion of mediating "in the domain" isn't terribly useful, because it amounts to just defining an endofunctor on C plus some stuff.
13:43:23 <Cale> yeah
13:44:20 <Cale> oh, I suppose you could drop the functor conditions, and just require that the etas make a commutative square.
13:44:36 <hellige> well, that's what i originally had in mind,  yeah.
13:44:55 <hellige> but i hadn't thought through whether the functor conditions amount to the same thing or not.
13:45:21 <Cale> Well, this way you wouldn't require H(f.g) = Hf . Hg
13:45:31 <Cale> hmm
13:45:45 <hellige> but remember, we still will (eventually) require the functor conditions to hold on F and G
13:45:55 <hellige> and that F and G have the same images.
13:46:05 <Cale> yeah, but that's okay
13:46:08 <hellige> so it MAY buy something to relax the conditions on H, but i'm not sure.
13:46:49 <hellige> but yeah, actually it does get something
13:46:50 <Cale> G(H(f.g)) = G(Hf . Hg)
13:47:32 <hellige> certainly one could imagine that H(id) != id for some X and Y, but that G(H(id)) == id (for some object in D)
13:48:36 <hellige> anyway, at least now we're thinking of the same thing....
13:48:57 <hellige> my initial question was why i'd never heard of this notion. i assume one of:
13:49:09 <hellige> 1. it's named, but not that useful in practice
13:49:20 <hellige> 2. it's equivalent to something i already have a name for
13:49:34 <hellige> 3. it really never arises in practice, and so is not named.
13:49:50 <saml> can I configure ghci so that when I do :t it doesn't print the expression i typed?
13:50:11 <saml> like, :t expr  prints expr :: type of expr.. but i want it to print type of expr part only
13:50:39 <saml> runStateT ( runErrorT .... )  now the type is printed at the last 5 columns of the console or so
13:50:52 <EvilTerran> let x = ...
13:50:53 <EvilTerran> :t x
13:50:55 <lambdabot> Expr
13:50:59 <dons> saml: hmm.
13:51:04 <EvilTerran> lambdabot, shh. that's not what i meant.
13:51:18 <saml> hah or i can use it variable
13:51:37 <EvilTerran> indeed, but then you need to evaluate the expression to get "it" set correctly
13:51:45 <saml> oh well right.
13:52:30 <saml> what's the next step after getting sence of monad and monad transformers?
13:53:06 <saml> discovering i don't really have sence of monad and monad transformers :)
13:55:35 <EvilTerran> btw, it's spelt "sense"
13:56:04 <EvilTerran> but do you know the pattern for encapsulating monad transformers tidily?
13:57:28 <saml> newtype deriving with hiding constructor?
14:00:05 * BMeph hopes it wasn't anything he said.
14:04:16 <EvilTerran> saml, that would work, yeah
14:04:47 * saml never uses export list
14:05:16 * saml never programed a large enough haskell program to use export list
14:07:07 <jaj> I'm trying to understand the State Monad. If I understand correctly it is meant to do a sequence of calculations which needs to interact with some state, however I can not use it to store a value in it, forget about that value, do some random unrelated calculations and finally recall the value at a later point?
14:07:35 <Botje> sure you can
14:07:37 <opqdonut> yes you can
14:07:41 <opqdonut> see liftM
14:07:44 <opqdonut> :t liftM
14:07:45 <Botje> but those "random unrelated calculations" have to be in the State monad too :)
14:07:46 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:07:52 <opqdonut> lifts a pure function into a monad
14:08:00 <jaj> Botje: yes, that's a problem :)
14:08:02 <opqdonut> or then you can use "return . f"
14:08:29 <dmwit> jaj: Nah, it's no problem.
14:08:41 <dmwit> They might kick and scream a little, but you can always drag pure calculations into a monad.
14:08:44 <jaj> I'm trying to have some sort of "database" to pack data in and get them out when I need them at random places in the program
14:10:05 <jaj> like using a global variable in C
14:10:27 <jaj> but perhaps this is just bad programming style in haskell anyway and I need to rethink my design
14:10:46 <EvilTerran> using a global variable is bad programming style in C, too :P
14:11:30 <CosmicRay> jaj: yes, I would think that would make the program hard to debug and reason about in any language.
14:12:59 <Peaker> and harder to test
14:13:26 <Peaker> and harder to later extend (to have multiple instances of whatever is involved)
14:15:15 <BMeph> ...and more embarassing to demonstrate to later programmers as an example of "HOWTO ... in Haskell" :)
14:15:15 <jaj> you're probably right
14:18:16 <christastrophe> oh boy. here's one for ya. if I want to read from a handle using hGetBuf, and immediately write the result into another handle with hPutBuf -- is there a away I can compose those two calls?
14:18:36 <EvilTerran> ?type hGetBuf
14:18:38 <lambdabot> Not in scope: `hGetBuf'
14:18:44 <EvilTerran> ?hoogle hGetBuf
14:18:44 <lambdabot> System.IO.hGetBuf :: Handle -> Ptr a -> Int -> IO Int
14:18:44 <lambdabot> System.IO.hGetBuffering :: Handle -> IO BufferMode
14:18:44 <lambdabot> System.IO.hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
14:18:47 <EvilTerran> ?hoogle hPutBuf
14:18:47 <lambdabot> System.IO.hPutBuf :: Handle -> Ptr a -> Int -> IO ()
14:18:47 <lambdabot> System.IO.hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
14:18:49 <EvilTerran> hmm
14:19:11 <EvilTerran> christastrophe, do you know the length ahead of time?
14:19:14 <christastrophe> yes
14:19:15 <ketil> Huh.  I did a ^Z and bg, and my Haskell program crashed?
14:19:20 <ketil> xml2x: blast.d/CUST_20_PI390538385.html: hClose: invalid argument (Bad file descriptor)
14:19:41 <ketil> Shouldn't it be more robust than that?
14:19:44 <christastrophe> the length of both is a fixed know size
14:20:33 <EvilTerran> ... that puts the result into the ptr, i take it?
14:21:08 <christastrophe> not sure I follow.
14:21:19 <EvilTerran> sorry
14:21:38 <EvilTerran> hGetBuf doesn't return the bytes read, it stores them at the location given by the Ptr parameter, am i right?
14:21:43 <christastrophe> right
14:21:52 <christastrophe> hGetBuf returns the number of bytes read...
14:22:01 <EvilTerran> in which case, you can't "compose" them in the usual sense, but you can sequence them with >>
14:22:19 <christastrophe> hmm. ok.
14:22:30 <EvilTerran> hGetBuf inputHandle ptr n >> hPutBuf outputHandle ptr n
14:22:41 <christastrophe> where does ptr come from in that example?
14:22:42 <EvilTerran> or the equivalent (do hGetBuf inputHandle ptr n; hPutBuf outputHandle ptr n)
14:23:38 <christastrophe> im used to forms like: ptr <- doGetBuf handle length
14:23:47 <EvilTerran> yeah. it's a bit strange, that one
14:23:51 <christastrophe> but obviously that wont work here
14:24:15 <EvilTerran> if it returned the bytes read, you could pipe them together with >>= or >=>
14:24:24 <christastrophe> right
14:24:33 <christastrophe> if that was the case this would be easy :)
14:24:39 <sw17ch> is there a way to use the record syntax to make a new value with a single value changed?
14:24:42 <Saizan> hGetBuf is lower level than that
14:24:50 <Saizan> maybe you should use ByteString ?
14:24:56 <dons> sw17ch: sure, foo { y = 7 }
14:25:04 <EvilTerran> sw17ch, oldValue { key = newValue, otherKey = otherNewValue }
14:25:10 <sw17ch> dons: thanks, i knew it existed... i couldn't think of it :)
14:25:18 <EvilTerran> unfortunately, you can't take sections of the record update syntax
14:25:30 <EvilTerran> so ({y = 7}) foo won't work :(
14:25:36 <sw17ch> dons: ps, is there a chance you've been able to get the Galois sqlite bindings working win windows?
14:26:15 <BMeph> hGetBuf hdl buf count reads data from the handle hdl  into the buffer buf until either EOF is reached or count 8-bit bytes have been read. It returns the number of bytes actually read.
14:26:26 <dons> dcoutts: http://godi.camlcity.org/godi/index.html
14:26:27 <lambdabot> Title: GODI Homepage
14:26:35 <dons> sw17ch: it doesn't?
14:26:45 <dons> sw17ch: i thought it explicitly came with a win32 setup script
14:26:46 <sw17ch> i'm unable to set it up correctly
14:27:04 <sw17ch> it does, but either the docs there aren't clear enough, or something has changed recently
14:27:15 <christastrophe> Saizan, yeah ByteString looks like what I want
14:27:22 * EvilTerran isn't sure if he'd be entirely comfortable using a piece of software called "go die"
14:27:26 <sw17ch> i can build it, but when it comes time to link with the sqlite.dll file, it complains about a missing symbol... sqlite_temp_directory
14:27:45 <christastrophe> im curious, how would one get a Ptr for use with hGetBuf ?
14:27:51 <dons> we accept patches, sw17ch :)
14:27:51 <sw17ch> so, i'm not sure if i'm just setting things up wrong, or if something changed between .6 and .9 versions of sqlite
14:27:54 <sw17ch> :)
14:28:00 <sw17ch> if i find it, i'll send it in
14:28:01 <dons> christastrophe: alloc/malloc from Foreign.Marshal.*
14:28:11 <dons> christastrophe: see also Foreign.ForeignPtr
14:28:35 <BMeph> christastrophe: From the Foreign.Ptr module: A value of type Ptr a represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type a.
14:28:48 <christastrophe> oh! haha, ok. that strays very far out of typicall haskell land
14:29:28 <christastrophe> ByteString is probably doing this behind the scenes... and its the exact layer of abstraction I need.
14:31:36 <christastrophe> plus hGet and hPut compose with >>= which is nice
14:32:18 <dons> christastrophe: right, bytestring gives you a nice haskelly layer over raw pointers and memory buffers
14:32:25 <nburlett> quick question...
14:32:27 <dons> along with useful IO operations, and interaction with C
14:32:30 <nburlett> does this function exist somwhere: \a b -> [a,b]
14:32:41 <dons> nburlett: nope.
14:32:43 <dmwit> nburlett: No.
14:32:48 <nburlett> dons: thanks, I didn't think so
14:33:00 <nburlett> dmwit: also thanks
14:33:00 <dons> :t (,)
14:33:01 <lambdabot> forall a b. a -> b -> (a, b)
14:33:18 <dmwit> :t ((:) .) . (:[])
14:33:20 <lambdabot> forall a. a -> [[a] -> [a]]
14:33:32 <dmwit> ?pl \a b -> a:b:[]
14:33:32 <lambdabot> (. return) . (:)
14:33:38 <dmwit> There you go. =)
14:33:50 <nburlett> meh...\a b -> [a,b] is more readable ;->
14:33:55 <dmwit> *nods*
14:35:14 <dons> ?pl \a b -> uncurry (\x y -> [x,y]) (a , b)
14:35:14 <lambdabot> (uncurry ((. return) . (:)) .) . (,)
14:36:45 <hpaste>  Leimy annotated "parallel/concurrent prime sieve" with "some performance stuff" at http://hpaste.org/7766#a1
14:38:35 * dmwit wonders
14:38:38 <dmwit> ?pl \a b -> [a, b]
14:38:39 <lambdabot> (. return) . (:)
14:38:48 <dmwit> pl++
14:39:54 <dmwit> Leimy: Wait, -N2 knocked an hour off of a 2.5 hour job, but only cranked CPU up from 98% to 124%?
14:40:04 <Leimy>  That's minutes :-)
14:40:12 <dmwit> Okay, my question stands. =P
14:40:15 <Leimy> but yes
14:40:25 <dmwit> > 124 / 98 * (1 + 19 / 60)
14:40:27 <lambdabot>  1.6659863945578233
14:40:33 <geezusfreeek> > 98%124
14:40:35 <lambdabot>  49%62
14:40:37 <dmwit> That seems magical...
14:40:49 <dmwit> > 98 / 124 * (2 + 20 / 60)
14:40:50 <Leimy> well keep in mind, I'm generating a spark for all new primes :-)
14:40:50 <lambdabot>  1.8440860215053765
14:41:49 <dmwit> Okay, but how could the time improve so much with such a small CPU usage improvement?
14:41:55 <dmwit> Did you somehow stay in the cache more?
14:42:13 <Leimy> I'm not sure... I didn't have time to profile it just yet :-)
14:42:20 <Leimy> Just had a curious question in the middle of the workday
14:42:22 <dmwit> =)
14:42:27 <dmwit> But yeah, awesome!
14:42:37 <Leimy> for a small set of primes, [2 .. 10000] the -N2 made little difference
14:42:48 <Leimy> but [2 .. 100000] was quite significant
14:42:50 <dmwit> > (2 + 20 / 60) / (1 + 19 / 60)
14:42:51 <lambdabot>  1.7721518987341773
14:43:07 <dmwit> Considering the theoretical limit is 2.0, that's pretty darn good.
14:43:21 <Leimy> So all I can figure is "having pthreads to schedule sparks on, with a huge number of sparks, helps a buttload"
14:43:25 <Leimy> but that's not very scientific :-)
14:43:42 <ketil> Leimy: dual core?
14:44:08 <Cale> Speaking of sparks, have you tried just using parallel Haskell instead of STM?
14:44:34 <Leimy> ketil: yes this is a Macbook Pro
14:44:42 <Cale> hmm, I wonder what this would look like...
14:44:46 <dons> Leimy: oh, you're not using parallel haskell?
14:44:47 <Leimy> Cale: nope.... but I'd love to see the code :-)
14:44:48 <dons> `par` et al?
14:44:52 <Leimy> no `par`
14:44:58 <Leimy> I'm using forkIO
14:44:59 <geezusfreeek> huh?
14:45:02 <sclv_> do you need stm for this also, or would normal Chans give the same behavior?
14:45:03 <Leimy> and typed data channels
14:45:04 <dons> if you've already managed to write a parallel version in IO
14:45:11 <dons> converting it to a pure algo with `par` should be easy
14:45:21 <dons> the hard work of coming up with the parallel implementation has been done
14:45:26 <Leimy> Well, I really wanted it this way
14:45:30 <Cale> dons: Unless he's relied on mutation somehow?
14:45:33 <Leimy> I'm a fan of "actor concurrency" :-)
14:45:41 <dons> Cale: hmm, that'd be interesting.
14:46:07 <geezusfreeek> Leimy: well, concurrency and parallelism are two problems with similar implementations sometimes
14:46:13 <dons> i wonder under what conditions a concurrent haskell program can be rewritten as a pure parallel haskell program
14:46:30 <sclv_> hmm... actually it looks like all your atomic actions are trivial, which means that you're not taking advantage of STM at all.
14:46:39 <geezusfreeek> i would argue that for something like a seive just using parallel haskel would seem to wiser choice
14:46:51 <Leimy> sclv_: I probably don't need STM... but I'm not 100% on that
14:47:01 <Leimy> this was my first concurrent haskell program :-)
14:47:06 <Leimy> so be gentle
14:47:32 <geezusfreeek> Leimy: come on. you don't learn if we aren't harsh! ;)
14:47:37 <Cale> hehe
14:47:40 <Leimy> geezusfreeek: I know I was just kidding
14:47:43 <sclv_> The rule of thumb is -- if you're not composing multiple STM actions within a single "atomically" call, then you don't get any benefit.
14:47:56 <Leimy> sclv_: yeah I figured that after I wrote the code
14:48:01 <dons> sclv_: oh, just using TVars et al as a slower MVar ?
14:48:12 <sclv_> or TChans in this case...
14:48:19 <dons> right. so that's a good rule
14:48:21 <geezusfreeek> dons: from looking at the implementation of TVars i would think so
14:48:27 <Leimy> yeah just a TChan would probably do eh?
14:48:33 <dons> for when to just use classic concurrent haskell
14:48:51 <geezusfreeek> err, not tvar, TMVar
14:48:55 <ketil> Leimy: so you effectively double your cache with -N2, no?
14:49:05 <Leimy> ketil: interesting point.
14:49:06 <geezusfreeek> which is not the topic of discussion, so nevermind
14:50:07 <geezusfreeek> sometimes i suspect i come off as scatterbrained here... i'm really not so scatterbrained in real life if that is the case
14:50:12 <geezusfreeek> ;)
14:53:18 <Leimy> dons:  I think the problem with the algorithm with `par` is that each spark gets assigned it's own special number.
14:53:28 <Leimy> and pipelines a stage of the sieve
14:53:43 <Leimy> not sure how to do that with `par` offhand, but maybe that's because my brain isn't fully engaged today yet :-)
14:54:11 <Leimy> the other bit of the algorithm is how each "previous" spark hands the special number to the next
14:54:53 <Cale> Leimy: well, with par, the things which you're computing in parallel are usually named
14:54:55 <roconnor> heh heh. Lambdabot gets a citation in my paper.
14:55:13 <roconnor> we should add her as an author
14:55:25 <dons> Leimy: yeah, you name the forked jobs, as haskell variables
14:55:32 <Cale> For example, you might have something like  fib n = let x = fib (n-1); y = fib (n-2) in x `par` y `seq` x + y
14:56:16 <sw17ch> alright, i have another funny problem...
14:56:24 <Cale> (though with that example, you're better off limiting the sparking so that tiny cases don't get sparked -- sparking is more expensive than addition)
14:56:25 <Leimy> shouldn't that be `pseq` ?
14:56:51 <Leimy> > :t pseq
14:56:51 <lambdabot>   parse error on input `:'
14:56:55 <Leimy> :t pseq
14:56:57 <lambdabot> forall a b. a -> b -> b
14:57:11 <sw17ch> well, never mind
14:57:35 <int-e> @src pseq
14:57:35 <lambdabot> Source not found. Where did you learn to type?
14:57:56 <int-e> anyway, yes it should.
14:58:27 <roconnor> @pl \f->f x
14:58:28 <lambdabot> ($ x)
14:58:29 <Cale> Will it actually make a difference here?
14:58:46 <Cale> I suppose it should as a matter of principle.
14:58:47 <Leimy> it may not.
14:59:46 <roconnor> @unpl (flip id x)
14:59:46 <lambdabot> (\ c -> c x)
14:59:52 * BMeph waves "Hi" to SyntaxNinja, and "'Bye" to everyone...
15:00:04 <ddarius> dons: It should be pretty clear to the author whether or not a concurrent program could (in theory) be rewritten to use only the parallelism constructs.
15:00:25 <roconnor> I suppose flip id x is more confusing than \f->f x
15:00:32 <SyntaxNinja> y0
15:00:36 <Leimy> ddarius: if the author knows the parallelism constructs :-)
15:00:41 <Cale> I wonder if GHC actually ever does any transformation such that pseq and seq would be different.
15:00:57 <Leimy> I implemented this algorithm for the first time in Limbo :-)
15:00:59 <Leimy> for Inferno.
15:01:07 <ddarius> Leimy: The issue is whether you are going purely for a speed-up or whether non-determinism/concurrency is part of the semantics of your program.
15:01:07 <Leimy> well I didn't originate it.
15:01:26 <SyntaxNinja> is Chris Eidhof here by chance?
15:01:27 <ddarius> @src pseq
15:01:27 <lambdabot> Source not found. I am sorry.
15:01:33 <Leimy> I believe this algorithm can be expressed as a list comprehension actually
15:02:16 <int-e> pseq  x y = x `seq` lazy y
15:02:20 <Leimy> yes it can...
15:02:34 <Cale> ddarius: pseq has the same semantics as seq, but the compiler is tricked into thinking that it's lazy in the second parameter
15:03:09 <Cale> ddarius: So in pseq x y, it forces the evaluation of x before y.
15:03:21 <int-e> I really like the comment there. -- "pseq" is defined a bit weirdly (see below)
15:03:38 <Cale> and won't do something like translate it to seq y (seq x y)
15:04:16 <Cale> But I'm not sure that such a thing actually ever comes up.
15:04:53 <int-e> (http://darcs.haskell.org/packages/base/GHC/Conc.lhs)
15:05:10 <ddarius> @index pseq
15:05:11 <lambdabot> GHC.Conc
15:06:29 <thoughtpolice> Cale: doesn't seq x y also force x before y? or does pseq force x while y remains lazy, i.e. x = pseq y z will mean x is lazy while x is being evaluated?
15:06:30 <dcoutts> dons: interesting
15:06:34 <thoughtpolice> i never quite understood the difference
15:06:48 <int-e> thoughtpolice: it makes x just as strict as y
15:06:54 <Cale> thoughtpolice: seq x y just means that x must be evaluated before the result of evaluating y can be used
15:07:08 <int-e> thoughtpolice: but the compiler is free to evaluate y before x if it finds that more convenient
15:07:27 <Cale> So it's still valid to evaluate y first, then evaluate x before returning the result of evaluating y to the caller.
15:08:07 <Cale> The semantics as defined by the report are just that  seq _|_ y = _|_, and seq x y = y otherwise
15:08:24 <thoughtpolice> Cale: so, a = seq x y is still lazily evaluated, it's just that when we reduce a to WHNF, x must be reduced to WHNF, then y follows?
15:08:40 <int-e> in particular  f x y = x `seq` y `seq` ()  and  f x y = y `seq` x `seq` ()  are exactly equivalent, and I actually expect that ghc generates the same code for both.
15:08:41 <Cale> yes.
15:08:53 <edwardk> cale: http://comonad.com/reader/2008/kan-extensions-ii/
15:08:55 <lambdabot> Title: The Comonad.Reader  Kan Extensions II: Adjunctions, Composition, Lifting
15:08:59 <int-e> (because these seqs end up being a strictness annotation for f)
15:09:11 <Cale> int-e: oh, that's interesting.
15:09:27 <int-e> I haven't checked my claim, I should :)
15:10:34 <Cale> int-e: At least in ghci, the two are distinguishable using Debug.Trace
15:12:28 <Cale> Even compiled with -O2, they're distinguishable still.
15:12:42 <Cale> @paste
15:12:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:13:01 <hpaste>  Cale pasted "program for distinguishing seq order" at http://hpaste.org/7820
15:13:52 <Cale> edwardk: awesome, I'll check it out :)
15:15:02 <hpaste>  malebria annotated "GNOME bindings for XMonad" with "Infinite" at http://hpaste.org/7816#a2
15:15:57 <int-e> Cale: ok, ghc is much more careful about this than I expected. Hmm. Interesting.
15:18:21 <Leimy> hmmm parallel list comprehension...
15:19:05 <Cale> Leimy: has nothing to do with parallelism directly, though it generally would be a useful point to introduce parallelism.
15:19:11 <Leimy> yep
15:19:25 <Leimy> It's like a scatter/gather MPI algorithm :-)
15:21:59 <Cale> edwardk: Considered having a newtype Gen f a = G (Ran f f a) ?
15:22:39 <Cale> Then, I think you could define an instance of MonadTrans.
15:22:59 <tieTYT> monadtrans sounds innapropriate
15:23:18 <dmwit> Bwah!
15:23:22 <dmwit> tieTYT2 has a clone!
15:23:52 <tieTYT> naw uh
15:24:08 <tieTYT> doh
15:25:04 <dibblego> hey tieTYT, how's Haskelling?
15:25:10 <tieTYT> good so far
15:25:12 <tieTYT> last night
15:25:28 <hpaste>  int-e annotated "program for distinguishing seq order" with "more elaborate example that makes the strictness analyzer do some actual work" at http://hpaste.org/7820#a1
15:25:44 <tieTYT> i went though a bunch of simple functions and remade them myself.  eg: init, last, length, etc.
15:25:59 <tieTYT> i'm gonna continue with that tonight
15:26:05 <dmwit> Oh, nice!
15:26:23 <Cale> int-e: interesting
15:28:08 <int-e> (it's really the unboxing of strict arguments to 'h' that changes the evaluation order here)
15:28:31 <skorpan> i really have to try to grasp this whole thing about strictness in haskell
15:28:39 <skorpan> i see it in conversations here everyday
15:28:46 <Cale> So I suppose the answer is that yes, it really can swap the order. :)
15:30:13 <Cale> skorpan: Well, how well do you understand lazy evaluation?
15:30:49 <skorpan> pretty much to the point of "take 5 [2..]"
15:31:41 <Cale> Lazy evaluation is outermost-first evaluation with an additional proviso that says whenever a parameter to a function occurs multiple times in that function's body, any results of evaluating the parameter are shared between the copies
15:31:56 <Cale> An example I always give is using the program  double x = x + x
15:32:00 <int-e> (the -fno-state-hack makes no difference btw, that was a leftover from experimenting)
15:32:19 <Cale> Evaluating  double (double 5)  under strict (innermost-first) evaluation:
15:32:23 <Cale> double (double 5)
15:32:26 <Cale> -> double (5 + 5)
15:32:28 <Cale> -> double 10
15:32:31 <Cale> -> 10 + 10
15:32:32 <mar77a> > (\x -> (1 + 1/x) ** x) [1..100]
15:32:33 <Cale> -> 20
15:32:33 <lambdabot>   add an instance declaration for (Floating [t])
15:32:42 <mar77a> er
15:32:45 <mar77a> > map (\x -> (1 + 1/x) ** x) [1..100]
15:32:47 <lambdabot>  [2.0,2.25,2.37037037037037,2.44140625,2.4883199999999994,2.5216263717421135,...
15:32:51 <Cale> Under plain outermost-first evaluation, it looks like this:
15:32:56 <Cale> double (double 5)
15:33:00 <Cale> -> double 5 + double 5
15:33:06 <Cale> -> (5 + 5) + double 5
15:33:08 <Cale> -> 10 + double 5
15:33:12 <Cale> -> 10 + (5 + 5)
15:33:15 <mar77a> > exp 1
15:33:16 <Cale> -> 10 + 10
15:33:17 <lambdabot>  2.718281828459045
15:33:19 <Cale> -> 20
15:33:35 <skorpan> okay
15:33:38 <Cale> But you might notice that some work is wasted by evaluating double 5 twice.
15:34:21 <Cale> Lazy evaluation fixes this by sharing the evaluation of expressions which came from substituting into the same function parameter. If you'll permit me to use  let ... in ...  to represent the sharing, it looks like this:
15:34:26 <Cale> double (double 5)
15:34:32 <Cale> -> let x = double 5 in x + x
15:34:37 <Cale> -> let x = 5 + 5 in x + x
15:34:41 <Cale> -> let x = 10 in x + x
15:34:44 <Cale> -> 20
15:34:50 <skorpan> i see
15:35:32 <skorpan> i still don't see why strictness is useful though
15:35:39 <Cale> Okay, so now let's look at a case where laziness doesn't work out so well.
15:35:51 <Cale> Do you already know about foldl?
15:35:55 <skorpan> yes
15:35:56 <Cale> @src foldl
15:35:56 <lambdabot> foldl f z []     = z
15:35:56 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:36:05 <Cale> okay, so let's evaluate foldl (+) 0 [1,2,3]
15:36:07 <skorpan> it won't leave any result until it's finished
15:36:11 <Cale> foldl (+) 0 [1,2,3]
15:36:22 <Cale> -> foldl (+) (0+1) [2,3]
15:36:29 <Cale> -> foldl (+) ((0+1)+2) [3]
15:36:35 <Cale> -> foldl (+) (((0+1)+2)+3) []
15:36:42 <Cale> -> ((0+1)+2)+3
15:36:46 <Cale> -> (1+2)+3
15:36:48 <Cale> -> 3+3
15:36:49 <Cale> -> 6
15:37:19 <Cale> You can see there that an expression is being built up which is the same size as the original list, before any addition gets done.
15:37:35 <mar77a> how can i learn haskell without coding it...i need something to code :<
15:37:41 <Cale> This is because evaluation is outermost first, and the foldl is always outermost.
15:37:45 <skorpan> mar77a: project euler, google it
15:37:47 <Botje> mar77a: go do project euler?
15:37:52 <mar77a> nuu
15:38:07 <Botje> write a terrain generator / viewer
15:38:14 <mar77a> like something useful for me..i can't come up with the ways to do it with haskell
15:38:21 <mar77a> even though it's possible i just can't stop thinking imperatively
15:38:25 <Vulpyne> Rewrite some programs that you previously did in some other language.
15:38:45 <lament> Write a virtual girlfriend
15:38:49 <lilac> lol
15:39:05 <skorpan> mar77a: write a small game, that's always fun
15:39:12 <Vulpyne> Haskell wouldn't make a good girlfriend. Too lazy.
15:39:27 <tieTYT> i prefer that type of gf
15:39:27 <lilac> Vulpyne: she can be strict when you force her to be
15:39:30 <Cale> skorpan: Worse yet, when you get to the end of the list, you have a tremendously deep expression.
15:39:35 <Cale> skorpan: (if the list was long)
15:39:36 <tieTYT> that way i don't have to take her to the beach and carnival and shit
15:39:45 <skorpan> Cale: so strictness would solve this?
15:39:48 <lament> beach? carnival? do you live in rio?
15:39:48 <tchakkazulu> mar77a: I've heard more people complain about this.
15:40:06 <tchakkazulu> mar77a: Having read all the tutorials, but no experience to actually use this.
15:40:20 <Cale> skorpan: We can annotate for strictness to ensure that f is applied before foldl recurses.
15:40:24 <tchakkazulu> mar77a: Writing a small game is a good idea, yes :)
15:40:25 <Cale> @src foldl'
15:40:25 <lambdabot> foldl' f a []     = a
15:40:25 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:40:33 <NewBe> Is there any simple function which does something like this: [1,2,3] -> [[2,3],[1,3],[1,2]] where each element in the new list consecutively drops an elements from the argument?
15:41:22 <skorpan> interesting question
15:41:47 <int-e> > let f xs = zipWith (++) (inits xs) (tail (tails xs)) in f [1,2,3]
15:41:48 <lambdabot>  [[2,3],[1,3],[1,2]]
15:41:58 <mar77a> small game? argh
15:42:10 <skorpan> mar77a: seriously, that's fun
15:42:21 <ddarius> mar77a: Write whatever program you think would be interesting or useful.
15:42:27 <ddarius> (to you)
15:42:27 <mar77a> that's the problem
15:42:31 <skorpan> it could be any game, could be black jack, snake, whatever
15:42:32 <mar77a> i think of haskell as...useless
15:42:35 <tchakkazulu> > let f l = case l of {[] -> []; (x:xs) -> xs : map (x:) (f xs)} in f [1,2,3]
15:42:36 <mar77a> a nice language to do my math homework
15:42:37 <lambdabot>  [[2,3],[1,3],[1,2]]
15:42:38 <mar77a> but that's about it
15:42:45 <mar77a> like...all i need is in ghci!
15:43:00 <skorpan> mar77a: haskell is useful for lots and lots of things
15:43:03 <mar77a> then i was like..i should write some proggies but now i have no clue whatsoever as to what to write
15:43:08 <skorpan> e.g. xmonad is written in haskell and is the best tiling manager out there
15:43:10 <ddarius> mar77a: I didn't say anything about language.  What is a -program- that you'd like to write (in any language).
15:43:10 <tchakkazulu> mar77a: I told said other person to implement a stack-based calculator.
15:43:14 <Cale> mar77a: Maybe join an existing project?
15:43:25 <int-e> NewBe: warning, this is an expensive function, no matter how you implement it, because it has to construct O(n^2) list conses (applications of (:))
15:43:27 <mar77a> nah i'm too new to write anything
15:43:58 <tchakkazulu> mar77a: It's not too difficult, but should train you in the use of higher-order functions, and can be extended with memory cells and recording macros and whatever else if you feel like doing something more challenging.
15:44:04 <skorpan> mar77a: exactly what do you want to program? something useful to you or something which is fun to program?
15:44:06 <tieTYT> is haskell useful for as many applications as java?
15:44:18 <mar77a> skorpan: both!
15:44:24 <Cale> tieTYT: Of course.
15:44:30 <mar77a> of course i can't ask here, i'm just whining and maybe getting some cool ideas
15:44:40 <skorpan> mar77a: i have yet to program something which is useful to ME which is also fun. in any language.
15:44:41 <tieTYT> i got the sense you guys would say no if i asked about erlang
15:44:53 <tieTYT> you said it wasn't as general purpose
15:44:57 <Cale> mar77a: I was pretty content writing small combinatorial programs for the first year or so that I was using Haskell.
15:45:07 <mar77a> guess i'll go for porject euler then!
15:45:12 <ddarius> skorpan: The only things I write which are useful to me are fun for me.
15:45:15 <skorpan> mar77a: project euler is pretty fun actually
15:45:21 <tchakkazulu> mar77a: As a matter of fact, I'm attempting to integrate said stack-based calculator project into the wikibook.
15:45:24 <skorpan> ddarius: good for you
15:45:36 <mar77a> stack based calculator eh
15:45:38 <Cale> tieTYT: I don't know about that. :)
15:45:39 <tchakkazulu> mar77a: Project Euler is certainly pretty fun. I have to try some more of it one of these days :)
15:45:42 <mar77a> command line, ofc?
15:45:53 <tchakkazulu> mar77a: Sure.
15:45:56 <tchakkazulu> @hpaste
15:45:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:45:59 <NewBe> int-e, I am aware of the computation time, it's for a program to compute square matrices. Thanks! you just helped me finish =]
15:46:32 <mar77a> tchakkazulu: i think i wrote that in C
15:46:40 <mar77a> if it's what i'm thinking of
15:47:22 <tchakkazulu> mar77a: It's not really hard. About 30 lines, but you can add various features to it.
15:47:34 <ddarius> Stack calculators (or even stack based languages) are trivial, especially in Haskell.
15:47:56 <skorpan> this is probably the wrong channel to ask this, but why is it considered so bad to use public instance variables in oo languages?
15:48:20 <hpaste>  tchakkazulu pasted "Example run of stack based calculator." at http://hpaste.org/7821
15:48:30 <tchakkazulu> Yeah, indeed.
15:48:36 <dons> skorpan: abstraction breaking?
15:48:44 <dons> that's usually why things are bad
15:48:51 <lilac> skorpan: in short: it violates encapsulation. it means you don't have an abstraction layer between the implementation and the user of it
15:48:54 <dibblego> skorpan, because it breaks many people's warped idea of what encapsulation is
15:48:56 <tchakkazulu> ddarius: But adding memory cells and macro recording is cool, and less trivial ;)
15:49:18 <tchakkazulu> At least, that's what I think.
15:49:19 <mar77a> ah
15:49:22 <ddarius> tchakkazulu: Very slightly less trivial.
15:49:22 <mar77a> hungarian notation
15:49:27 <mar77a> or pole notation
15:49:29 <mar77a> something like that
15:49:32 <ddarius> Polish
15:49:35 <mar77a> anyways i'm going for project euler
15:49:37 <ddarius> Reverse Polish in this case
15:49:38 <mar77a> thanks though
15:49:46 <vixey> use a typed stack ;)
15:49:48 <tchakkazulu> mar77a: Heh, have fun with project euler :)
15:49:50 <mar77a> oh right hungarian is the variable naming thing
15:49:51 <mar77a> ty
15:50:05 <mar77a> is there nano for windows btw..
15:50:06 <tieTYT> skorpan: did you understand that?
15:50:06 <mar77a> i wonder
15:50:11 <skorpan> tieTYT: barely
15:50:27 <lament> skorpan: because when the langugae you use sucks, and something used to be a variable but you want to change it into a method, you would have to change it everywhere and not just the appropriate class.
15:50:34 <mar77a> awesome
15:50:35 <mar77a> there is
15:50:41 <skorpan> lament: ah, that's true of course
15:51:01 <vixey> tchakkazulu: http://www.eecs.harvard.edu/~nr/cs252r/archive/conor-mcbride/epigram-pearl.pdf
15:51:01 <skorpan> uhm.. no wait, is it?
15:51:02 <lambdabot> http://tinyurl.com/65yqms
15:51:06 <lament> skorpan: yes, it is
15:51:14 <lament> skorpan: instead of foo.bar you now have to write foo.bar() everywhere!
15:51:21 <ddarius> Here's a simple stack calculator: http://hpaste.org/7198
15:51:32 <skorpan> that cannot possibly be the best reason why not to use public instance variables
15:51:47 <lament> skorpan: it is as far as im' concerned
15:51:51 <skorpan> i'm not even sure you're being serious
15:51:54 <dibblego> skorpan, that's pretty much it
15:51:59 <lament> skorpan: look at properties
15:52:03 <lament> skorpan: in C# or objc
15:52:07 <lament> they exist to fix exactly this problem
15:52:12 <tieTYT> if you let code access instance variables correctly, you lose constrol of what it can be set to.  You can't stop someone from setting int employees = -5
15:52:28 <roconnor> @unpl flip const
15:52:28 <lambdabot> (\ b c -> c)
15:52:39 <roconnor> @unpl flip const const
15:52:39 <lambdabot> (\ c -> c)
15:52:42 * ddarius uses public readonly fields in C# often.
15:52:43 <skorpan> tieTYT: what i'm talking about here is the difference between public instance variables and getters and setters which just set the variable.
15:52:46 <tieTYT> correctly = directly
15:52:48 <skorpan> get/set
15:52:55 <roconnor> @unpl flip const join
15:52:56 <lambdabot> (\ c -> c)
15:53:09 <ddarius> skorpan: The difference is what people have said.
15:53:20 <skorpan> okay
15:53:28 <tieTYT> skorpan: I think someone already mentioned this, but in the future you may want to put logic in the method
15:53:36 <roconnor> I = CKW
15:53:37 <tieTYT> if you let people access it directly, you break code
15:53:42 <skorpan> tieTYT: no one mentioned it yet, but i kind of got the point
15:54:02 <ddarius> If you have setEmployees(int x) { employees = x; } you can later change it to setEmployees(int x) { assert(x >= 0); employees = x; }
15:54:09 <skorpan> yes
15:54:18 <skorpan> that's a good reason
15:54:41 <tieTYT> or you can mark it as deprecated
15:54:50 <tieTYT> i don't think you can mark an instance variable as deprecated in Java
15:55:10 <vixey> or you can use reflection to make every setter in a class log all method calls to a file?
15:55:10 <lament> skorpan: what do you mean no one mentioned it? that's exactly what i said.
15:55:26 <ddarius> roconnor: W is ?
15:55:26 <skorpan> i have no idea what you mean by marking stuff as deprecated
15:55:41 <roconnor> W is join
15:55:46 <skorpan> lament: what you said was that "if you want to change a variable into a method you'd have to change foo.bar to foo.bar()"
15:55:57 <ddarius> roconnor: Ah I see.
15:56:01 <skorpan> at least that's the way i interpreted what you said
15:56:03 <roconnor> Wxy = xyy
15:56:08 <tieTYT> yes that's what i said too, in more words
15:56:25 <tieTYT> the problem with that is that all code that called foo.bar will break now
15:56:30 <skorpan> tieTYT: except that what you said involved the point of changing the variable to a method
15:56:35 <roconnor> ddarius: I needed CK?  I wasn't sure what to put in for ?
15:57:03 * lament withdraws from the conversation
15:57:15 <ddarius> roconnor: Why did you need CK?
15:57:34 <MyCatVerbs> lament: y'know, your notice of withdrawal was inherently an element of the conversation in and of itself.
15:57:44 <dibblego> skorpan, ask yourself why it is not so important that it is not public if the variable is const/final
15:57:48 <roconnor> ddarius: I want to say that I is redudent in the BCKW system
15:57:51 <lament> MyCatVerbs: that's why it used present tense, and not past :)
15:58:14 <mar77a> is the mod function in the prelude the % operator for integers in c++?
15:58:16 <roconnor> @unpl (.) join flip const
15:58:16 <lambdabot> ((\ e f -> f) >>= \ h -> h)
15:58:20 <MyCatVerbs> lament: curses! Foiled again.
15:58:35 <ddarius> roconnor: Well K is return and W is join and B is fmap so you can make (=<<) which is S.
15:59:04 <roconnor> ddarius: sure, but saying I = B(B(BW)C)(BB)KK seems unecessarily long.
15:59:11 <ddarius> roconnor: True.
15:59:19 <tieTYT> skorpan: you see why setEmployees(int x) { assert(x >= 0); employees = x; } is better than adding "assert(x >= 0);" everywhere you used to call  myClass.employees = x; right?
15:59:36 <roconnor> @unpl join const
15:59:37 <lambdabot> ((\ a _ -> a) >>= \ b -> b)
15:59:37 <skorpan> tieTYT: yes, i'm not retarded
15:59:46 <skorpan> sorry, mentally challenged
16:00:08 <ddarius> mar77a: Actually rem is probably closer, but yes more or less.
16:01:03 <roconnor> @type join const
16:01:04 <lambdabot> forall a. a -> a
16:01:17 <roconnor> I guess WK is even simpler
16:01:20 <ddarius> Yep.
16:01:45 <roconnor> probably not going to get any simpler than that.
16:01:58 <ddarius> roconnor: It's kind of hard pressed to.
16:02:07 <ddarius> :t Reader flip
16:02:10 <lambdabot> forall a b c. Reader (a -> b -> c) (b -> a -> c)
16:02:11 <mar77a> what's the difference ddarius ? i get similar results
16:02:20 <wolgo> Hello
16:02:35 <ddarius> > ( (-3) `rem` 2, (-3) `mod` 2)
16:02:36 <lambdabot>  (-1,1)
16:02:49 <ddarius> :t Reader . flip
16:02:50 <lambdabot> forall a b c. (a -> b -> c) -> Reader b (a -> c)
16:02:54 <saml> can I say deriving (MonadReader r, MonadWriter w ..) enables me to write MonadReader and MonadWriter actions without explicit lift ?
16:04:25 <dons> saml: yeah. if the Monad is a newtype
16:04:44 <dons> saml: look at http://code.haskell.org/xmonad/XMonad/Core.hs
16:05:32 <wolgo> So it appears that (x:xs) when passed as an argument takes list and makes one portion head list and the other portion tail list. Is (x:xs) just a short cut?
16:06:02 <vixey> wolgo it's a little bit more than a short cut
16:06:10 <vixey> @src head
16:06:11 <lambdabot> head (x:_) = x
16:06:11 <lambdabot> head []    = undefined
16:06:14 <saml> dons: thank you
16:06:26 <vixey> wolgo: if you didnt have pattern matching, you wouldn't be able to program things like head and tail
16:06:27 <ddarius> @src []
16:06:28 <lambdabot> data [] a = [] | a : [a]
16:06:43 <vixey> wolgo: but they are equivalent, I mean you could replace any program that uses pattern matching with one that doesn't
16:06:47 <tieTYT> vixey: does lisp have pattern matching?
16:06:53 <tieTYT> cause i remember it having a head and tail
16:06:55 <saml> can I make my MonadBlah class derivable using GeneralizedNewtypeDeriving? or do I have to modify mtl to do so?
16:07:01 <tieTYT> but i don't remember pattern matching
16:07:07 <MyCatVerbs> tieTYT: most Lisp dialects don't have pattern matching built in...
16:07:10 <vixey> tieTYT; CL has destructuring bind
16:07:19 <MyCatVerbs> Oops, I'm wrong.
16:07:21 <vixey> tieTYT; You can easily add haskell style pattern matching though
16:07:40 <bos> saml: GeneralizedNewtypeDeriving isn't magic.
16:07:47 <MyCatVerbs> tieTYT: ...but people have written macro libraries that do pattern matching.
16:07:52 <wolgo> vixey: thanks, I think I am getting a little ahead of myself. I think i need to review recursion again. One of the challenges is to rewrite zip recursively. I was able to rewrite replicate. But I am struggling with recursion as a whole.
16:08:04 <bos> saml: all it does is unwrap and rewrap the underlying type to expose whatever typeclasses it already implements.
16:08:16 <MyCatVerbs> tieTYT: like, Qi is a Lisp dialect with pattern matching and a whole pile of other nice features, and is implemented entirely as a set of CL macros.
16:08:19 <bos> saml: it's just not very well documented.
16:08:47 <vixey> wolgo: well there's really 4 case to consider
16:08:52 <tieTYT> ok
16:09:07 <mar77a> is it bad if i use a lot of $
16:09:13 <mar77a> is the . operator more common?
16:09:19 <vixey> wolgo: if you look at zip [] [] ; zip (_:_) [] ; zip [] (_:_) and zip (x:xs) (y:ys) individually
16:09:28 <vixey> wolgo: that's one starting poin
16:09:29 <vixey> t
16:10:06 <Cale> mar77a: You never need to chain $'s end to end
16:10:19 <Cale> mar77a: you can always replace f $ g $ h $ x  with  f . g . h $ x
16:10:22 <wolgo> ok I will look at those
16:10:38 <wolgo> I am pretty happy getting this far.
16:10:38 <mar77a> well Cale the . operator looks better imo but $ requires less typing
16:10:40 <MyCatVerbs> mar77a: personally, I think it's fine, but Cale will kill you in your bed if you do.
16:10:46 <Cale> which is easier to work with, since g . h will be a well-typed thing, for example, whereas g $ h will be meaningless
16:10:49 <wolgo> I tried to learn haskell about 6 months ago and gave up hahah
16:10:51 <vixey> haha
16:11:01 <mar77a> also, is this the correct way i thought about the $ operator: replace every $ with ( and add a closing ) at the end of line / statement
16:11:06 <Cale> mar77a: less typing?
16:11:10 <mar77a> well yeah
16:11:14 <mar77a> putStrLn $ show $ mtof 16
16:11:29 <Cale> Doesn't (.) save you a shift key? :)
16:11:34 <mar77a> is something like (putStrLn . (show . mtof)) 16
16:11:44 <saml> if I have instance MyClass MyT where..   then newtype MyM a = MyM (MyT Identity a) can derive MyClass !
16:11:46 <Cale> putStrLn . show $ mtof 16
16:11:53 <mar77a> that's just confusing now :<
16:12:04 <Cale> Or:
16:12:09 <Cale> putStrLn . show . mtof $ 16
16:12:16 <Cale> putStrLn . show = print
16:12:21 <mar77a> roger
16:12:25 <Cale> So we can substitute:
16:12:30 <Cale> print . mtof $ 16
16:12:38 <mar77a> do you even need the $ there
16:12:51 <Cale> You either need a $ there, or some parens
16:12:55 <mar77a> yeah
16:12:56 <Cale> Or you can move it back
16:12:59 <mar77a> the parens just look clearer
16:13:00 <mar77a> for some reason
16:13:03 <Cale> print $ mtof 16
16:13:05 <mar77a> even the dot looks nicer than $
16:13:14 <mar77a> but i have to admit $ is the bomb
16:13:19 * mar77a high fives MyCatVerbs 
16:13:41 <mar77a> in any acse
16:13:44 <mar77a> i'll go for: (print . mtof) 16
16:13:53 <mar77a> huh
16:13:54 <Cale> The nice thing is that (.) is an associative operator
16:13:56 <mar77a> apparently that doesn't work
16:14:02 <Cale> it should
16:14:17 <mar77a> oh it's print failing
16:14:21 <mar77a> weird
16:14:31 <Cale> What does mtof return?
16:14:34 <mar77a> Bool
16:14:44 <Cale> What's its type?
16:14:51 <Cale> Integer -> Bool ?
16:14:56 <mar77a> mtof :: (Integral x) => x  -> Bool
16:15:07 <Cale> That should be fine then.
16:15:10 <mar77a> woah
16:15:11 <mar77a> now it works
16:15:15 <mar77a> could that extra space be bad
16:15:22 <mar77a> nvm it isn't
16:15:22 <Cale> which extra space?
16:15:22 <doun> cale deems it correct, and thus it shall be
16:15:24 <mar77a> not sure what it was
16:15:34 <vixey> :D
16:15:41 <mar77a> might've been something with indenting
16:15:42 <mar77a> oh well
16:15:44 <mar77a> thanks
16:15:46 <vixey> @remember <Cale> That should be fine then. <mar77a> woah <mar77a> now it works
16:15:46 <lambdabot> Nice!
16:16:16 <mar77a> :(
16:16:18 <mar77a> my first quote
16:16:35 <vixey> @quote vixey
16:16:35 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
16:16:39 <vixey> :..
16:16:46 <Cale> awww
16:16:47 <mar77a> @quote mar77a
16:16:48 <lambdabot> <Cale> says: That should be fine then. <mar77a> woah <mar77a> now it works
16:16:51 <vincenz> @quote vincenz
16:16:52 <lambdabot> vincenz says: sure, give us your homework and we'll email it straight to your teacher :)
16:16:57 <vixey> haha
16:16:59 <Cale> @quote Cale
16:16:59 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
16:17:05 <mar77a> :)
16:17:07 <vixey> lol
16:17:11 <vincenz> @quote vincenz
16:17:11 <lambdabot> vincenz says: Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
16:17:18 <vixey> ohh
16:18:16 <vixey> @quote
16:18:16 <lambdabot> blackdog says: i think coding in your sleep should trigger an exception
16:18:25 <vixey> I was coding in my sleep again :(
16:18:51 <vincenz> vixey: thank god for the type system
16:18:56 <mar77a> :t filter
16:18:58 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
16:19:19 <vixey> speaking of type systems...
16:19:25 <nburlett> can I get some advice on module layout for my application?
16:19:33 <vixey> how come every term in simply typed lambda calculus has a normal form?
16:19:42 <mar77a> > [1..1000]
16:19:43 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
16:19:45 <ddarius> vixey: Count the arrows.
16:19:45 <nburlett> I'm writing my first semi-complex haskell application
16:19:47 <mar77a> ok
16:19:55 <wolgo> I did this: zop (x:xs) (y:ys) = (x,y):zop xs ys
16:20:08 <roconnor> vixey: that is the way life is.
16:20:22 <vincenz> wolgo: looks good, except you're missing the cases when one of the lists is empty
16:20:36 <vixey> the number of arrows is invariant when you evaluate
16:20:39 <nburlett> and I have an AppT type deriving (Monad, MonadIO, MonadReader Connection) (that I basically stole from the haskell web-app page)
16:20:54 <mar77a> what's the conditional and and or?
16:20:54 <vixey> but if you have (x :: o -> o) $ (y :: o) .. then an arrow disappears...
16:21:04 <wolgo> So each time we eat head x and recur zop xs ys which calls up until zop [] y = [] or zop x [] = []
16:21:14 <wolgo> jeez
16:21:25 <wolgo> This will take some practice hahaha
16:21:27 <vixey> wolgo: I think that's perfect
16:21:36 <Cale> mar77a: && and || ?
16:21:48 <mar77a> ok
16:21:48 <wolgo> If I practice at this will it become more natural?
16:21:52 <Cale> Or you can use the list versions:
16:21:54 <Cale> :t and
16:21:56 <lambdabot> [Bool] -> Bool
16:21:58 <Cale> :t or
16:22:00 <lambdabot> [Bool] -> Bool
16:22:00 <wolgo> Is recursion normally a hang up for new programmers?
16:22:17 <Cale> wolgo: Learning to avoid recursion is a bigger one :)
16:22:18 <ddarius> wolgo: For completely new programmers, it often takes a little time.
16:22:29 * wolgo is new
16:22:29 <structured> wolgo: yeah but not as bad as continuations
16:22:42 <vixey> continuations :D
16:22:44 <doun> Cale: how might one avoid recursion in haskell?
16:22:47 <ddarius> Of course, recursion/iteration is where all the power of programming lies.
16:22:54 <nburlett> I'm ending up with circular imports :-<
16:22:55 <dons> doun: but not writing loops?
16:22:57 <Cale> doun: By using higher order functions
16:23:04 * vixey looks for a proof ..
16:23:14 <MyCatVerbs> ddarius: bah, direct recursion is for suckers.
16:23:15 <ddarius> vixey: Try to prove it yourself.
16:23:19 <mar77a> > [1..5]
16:23:21 <lambdabot>  [1,2,3,4,5]
16:23:22 <MyCatVerbs> ddarius: the cool kids are all using fixpoint operators now. :)
16:23:25 <vixey> ok
16:23:31 <wolgo> ok
16:23:41 <mar77a> "Congratulations, the answer you gave to problem 1 is correct."
16:23:44 <mar77a> sweeeet}
16:23:53 <mar77a> here's how i solved it, i look forward to major criticism
16:24:01 <wolgo> I think I am going to work on this even harder
16:24:12 <shepheb> behold, the start of an addiction
16:24:14 <hpaste>  mar77a pasted "Problem 1 , project euler" at http://hpaste.org/7822
16:24:22 <ddarius> wolgo: Recursion is a fundamental concept of programming.
16:24:43 <doun> dons: well, if you mean avoiding /writing/ your own recursive functions, then, yes
16:24:56 <mar77a> shepheb :)
16:25:00 <mar77a> so, any ideas?
16:25:21 <wolgo> ddarius: Ok, so that means that I should have a strong grasp of how it works and executes then right?
16:25:26 <wolgo> Since it is a building block
16:27:17 <doun> Cale: by high order functions, you mean functions that take functions as arguments?
16:27:19 <Cale> wolgo: yeah
16:27:23 <Cale> doun: yes
16:27:29 <Cale> doun: like map, filter and foldr
16:27:43 <doun> Cale: yeah, I thought you meant avoiding any use of recursion. >_>
16:27:46 <ddarius> "doun: like foldr, foldr, and foldr"
16:28:02 <Cale> heh
16:28:09 <doun> dons: sorry, did you say that? it didn't highlight
16:28:25 <doun> er, ddarius
16:29:12 <ddarius> doun: It's a slight joke on Cale's response
16:29:41 <Cale> map and filter can be written directly in terms of foldr
16:29:42 <doun> ddarius: because map and filter can be defined in terms of foldr? :D
16:29:48 * doun high-fives himself
16:31:06 <Cale> map f = foldr ((:) . f) []
16:31:44 <Cale> filter f = foldr (\x xs -> if f x then x:xs else xs) []
16:31:55 <gubagem> ok what is this fold business
16:31:57 <ddarius> and filter p = foldr (\x -> if p x then id else (x:)) []
16:32:44 <ddarius> > foldr (fun "cons") (var "nil") [1,2,3]
16:32:45 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr (Sym a))
16:32:49 <Cale> gubagem: foldr f z replaces each (:) in a list with f, and the [] at the end with z
16:32:57 <Cale> > foldr f z [1,2,3]
16:32:58 <lambdabot>  f 1 (f 2 (f 3 z))
16:33:21 <Cale> > foldr (:) [] [1,2,3]
16:33:22 <lambdabot>  [1,2,3]
16:33:28 <Cale> > foldr (+) 0 [1,2,3]
16:33:29 <lambdabot>  6
16:33:33 <doun> not to be confused with lisp's reduce
16:34:31 <gubagem> is there a foldl?
16:34:37 <doun> yeah
16:34:43 <gubagem> whats that do
16:34:53 <doun> @src foldl
16:34:53 <lambdabot> foldl f z []     = z
16:34:53 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:35:04 <vixey> gubagem: foldl (flip f) z l = foldr f z (reverse l)
16:35:11 <vincenz> vixey: argh
16:35:15 <vincenz> vixey: bad pattern
16:35:20 <vincenz> vixey: does not hold for infi-lists
16:35:25 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
16:35:33 <ddarius> Anyway, reverse = foldl (flip (:)) []
16:35:34 <lambdabot> Title: Fold Diagrams - CaleWiki
16:35:48 <Cale> vincenz: are you sure?
16:35:50 <vincenz> Cale: is that inkscpae?
16:35:53 <Cale> vincenz: yes
16:35:55 <vincenz> Cale: "reverse l" for infilist?
16:36:01 <Cale> vincenz: _|_
16:36:04 <ddarius> Cale: When read the other way it's false.
16:36:09 <vincenz> > foldl const [1..]
16:36:09 <Cale> So the equation becomes _|_ = _|_
16:36:10 <lambdabot>  Add a type signature
16:36:14 <ddarius> Er nevermind.
16:36:16 <vincenz> :t foldl
16:36:18 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:36:31 <vincenz> > foldl const 0 [1..]
16:36:33 <wolgo> I think I need to write a bunch of programs using only recursion.
16:36:34 <lambdabot> Terminated
16:36:36 <wolgo> that will help
16:36:37 <vincenz> hum
16:36:52 <ddarius> vincenz: Trying to define foldr in terms of foldl fails.
16:36:55 <doun> yi.org not found. odd
16:37:03 <vincenz> ddarius: oh
16:37:05 <vincenz> right
16:37:28 <ddarius> But still, I don't like that relation
16:37:48 <Cale> oh...
16:37:52 <Cale> that's strange...
16:38:03 <Cale> 99.247.166.96
16:38:08 <Cale> if it doesn't resolve
16:38:56 <ddarius> foldl is like an accumulating loop
16:38:58 <doun> hmm. what made foldr click for me was lazy evaluation p_p ie foldr'ing over an infite list
16:39:02 <doun> Cale: mmkay
16:39:12 <vixey> @free foldr
16:39:14 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
16:39:38 <ddarius> doun: foldr doesn't make much sense in a strict language
16:39:42 <tieTYT> would you guys say that haskell makes it hard to write code that's difficult to maintain?
16:39:55 <ddarius> tieTYT: No.
16:40:09 <tieTYT> tha'd be cool
16:40:13 <Cale> mm, a bit harder that some languages
16:40:17 <Cale> than*
16:40:18 <ddarius> tieTYT: It might be harder to -unintentionally- do so.
16:40:22 <dons> tieTYT: the opposite. purity, polymorphism and strong typing enforces separation of concerns.
16:40:33 <dons> making it much easier to refactor, and to enforce safety properties.
16:40:39 <tieTYT> my initial question may have been confusing
16:40:52 <tieTYT> i was trying to ask: is it easier to write maintainable code in haskell than other languages
16:41:01 <doun> Cale: nice diagrams
16:41:05 <Cale> doun: thanks :)
16:41:07 <tieTYT> dons: I think you thought I asked the opposite
16:41:24 <ddarius> tieTYT: That is a different question (not the opposite though) and I'd say yes and no, but seemingly mostly yes.
16:41:32 <dons> yes, double negatives are odd like that
16:41:38 <tieTYT> yep, sorry
16:41:43 <tieTYT> i think it's right
16:43:09 <Cale> You can write code which is hard to maintain in Haskell, but if you're not trying to do so, it's pretty easy to come up with very maintainable code.
16:43:14 <ddarius> tieTYT: It can be not difficult to write unmaintainable code and still be easy to write maintainable code simultaneously.
16:43:39 <Cale> Lean on the typesystem a bit :)
16:43:51 <tieTYT> if my boss could not re-assign variables, his code would be a lot cleaner
16:44:00 <tieTYT> so in that respect, haskell could definately help
16:44:08 <tieTYT> definitely, i mean.  I hate that word
16:45:08 <ddarius> I would say that poor Haskell code is likely to be significantly more maintainable than poor imperative code, but it's not necessarily true of good code in each language.
16:45:17 <doun> the whole concept of declaring a variable without a value seemed really odd to me today
16:45:56 <rfernand> Hello! I am having some trouble setting up HaskellDB. I've tried several things. Currently I am on a WIndows box, running GHC 6.6.
16:46:20 <doun> what problem are you experiencing?
16:46:24 <rfernand> I managed to install haskelldb 0.10, but I am somewhat stuck with HDBC.
16:46:55 <rfernand> Managed to use HDBC-1.1.3, but cannot compile HDBC-postgresql-1.1.3.0
16:47:43 <doun> why? do you need some postgresql development files?
16:48:17 <edwardk> cale: Gen so it can be a monad transformer?
16:48:28 <Cale> edwardk: yeah
16:48:34 <rfernand> can I connect to PostgreSQL using only HDBC?
16:48:44 <edwardk> cale: yeah actually i thought about it as another higher order functor to add to the library
16:48:46 <rfernand> (I would have thought I needed -postgresql)
16:49:15 <Cale> edwardk: there's probably a better name for it too :)
16:50:05 <rfernand> doun: when doing a setup build on hdbc-postgresql, I get a "libpq-fe.h: no ssuch file" error. Is this what you mean?
16:50:45 <doun> rfernand: it looks that way
16:51:12 <rfernand> I see what you are saying -- hmm, let me try installing a postgresql*-devel pkg on WIndows :)
16:51:14 <rfernand> thanks
16:51:32 <edwardk> cale: i'm mostly interesting in using these to play with performance. also i have been using a different argument ordering on my comonads because it lets many of them be bifunctors, not sure which is more valuable lift, or the ability to change out the type of state/env/etc in a monad.
16:52:08 <rfernand> doun: by any chance, you wouldn't happen to know about a HaskellDB tutorial, would you? I've looked around (unsuccessfully)
16:52:09 <edwardk> cale: any opinion on the latter?
16:52:11 <roconnor> these bananas and lenses are not as pretty as I imagined they would be.
16:52:31 <Cale> edwardk: On your monad transformers?
16:52:39 <doun> rfernand: I don't, sorry. I have used HDBC with Sqlite3 successfully, that is all :\
16:52:56 <rfernand> doun: thanks!
16:53:03 <doun> huh?
16:53:16 <edwardk> cale: yeah for instance a comonad transformer CoreaderT w e a lets you define an instance of Bifunctor over it that changes out the underlying comonad for another when you use its left hand map.
16:53:38 <rfernand> doun: thanks for all your answers :)
16:53:49 <doun> rfernand: ah, welcome
16:54:32 <edwardk> cale: otoh, lift is kinda nice, and give the lift ordering you can make each of the built in monad transformers into an instance of HFunctor, which lets you swap out the inner monad, so maybe the lift ordering is better.
16:54:42 <edwardk> er given
16:55:02 <Cale> edwardk: That's an interesting idea, but yeah, it does kind of spoil the use of the thing as a monad transformer proper, since we don't have type lambdas.
16:55:52 <doun> rfernand: hmm, libpq might be of some rel-oh
16:55:56 <edwardk> cale: http://comonad.com/haskell/category-extras/src/Control/Functor/HigherOrder.hs has the HFunctor i'm talking about and the instances for the MTL.
16:55:57 <lambdabot> http://tinyurl.com/6m55yh
16:57:00 <edwardk> so you can use the hfmap to change what monad you're in. or hreturn to transform an underlying monadic action into a transformed one. i.e. hreturn can take you from State s a to ReaderT e (State s) a
16:57:10 <edwardk> so i think i convinced myself to defect to the MTL ordering
16:58:23 <edwardk> er hfmap to change what monad you're running over. i.e. to go from a ListT (Reader e) a to a ListT (State e) a
16:59:11 <edwardk> i was amused that pretty much all the monad transformers make valid HFunctors (except ContT)
16:59:29 <Cale> Of course, ListT isn't a monad transformer ;)
16:59:33 <edwardk> yeah
16:59:37 <doun> Cale: oh, yeah. battlestar galactica is probably one of the best sci-fis out right now imho
16:59:45 <edwardk> but it is a valid HFunctor ;)
16:59:46 <Cale> doun: yep
16:59:56 <Cale> :)
17:02:07 <edwardk> btw- i found the most convincing argument for using class associated types, and remembered the reason why i liked them in my earlier categories library. they make category transformers a lot easier to use. otherwise you have to parameterize them not only on the category, but on the product and exponential for the category in a lot of cases. makes a lot of noise in the types.
17:02:39 <edwardk> er convincing argument for using them over using fundeps for things like all the misc types for a CCC in my setting, not in general ;)
17:03:51 <vixey> I can't prove this :[
17:04:43 <Cale> vixey: What are you trying to prove?
17:05:07 <vixey> all the simply typed terms are strong normalizing
17:07:39 <conal> @seen syntaxfree
17:07:39 <lambdabot> I haven't seen syntaxfree.
17:08:09 <gubagem> whats normalizing
17:08:53 <vixey> gubagem: It should have a normal form
17:08:58 <Ralith> Can anyone point me to a simple howto or example or something explaining how to make haskell code callable from C?
17:09:02 <conal> i just found syntaxfree's free post on generating dot format: http://syntaxfree.wordpress.com/2007/02/22/bycicling-for-collatz .  fun.  does anyone else play with Haskell & dot?
17:09:03 <lambdabot> Title: Bicycling for Collatz  Data.Syntaxfree
17:09:15 <gubagem> vixey: ok im a newb, whats a normal form
17:09:34 <ddarius> @where ffi Ralith
17:09:34 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
17:10:05 <vixey> gubagem: I think that's just a variable or (\x -> <normal form>) or (<variable> $ <normal form>)
17:10:11 <vixey> gubagem: I could be wrong...
17:10:25 <dolio> I imagine it involves not being able to do any more reductions.
17:10:30 * gubagem still has no idea 
17:10:32 <gubagem> ohhhh
17:11:17 <gubagem> im thinking of making a crappy webpage and just commenting all the lil haskell code ive written so far learning
17:11:27 <vixey> that sounds like a good idea
17:11:36 <gubagem> most code clippets are either really easy or far too advanced for me
17:11:44 <dolio> Although, there are normal forms in areas other than lambda calculus.
17:11:47 <Ralith> ddarius: so I'd just do expent thingIWantExposed?
17:11:59 <gubagem> whats a good website hosting url these days
17:12:03 <geezusfreeek> man, category-extras looks more and more appealing every time i see a blog post about it at comonad.com
17:12:09 <ddarius> Ralith: Read the FFI.
17:12:17 <geezusfreeek> i just have to install ghc 6.9 i guess :\
17:12:26 <Ralith> ddarius: what, the whole thing?
17:12:50 <Cale> vixey: The proof given in TaPL is sufficiently subtle that I don't think you can feel too bad about it :)
17:13:11 <thetallgu1> conal:is dot the graph rendering program?
17:13:28 <ddarius> Ralith: It's not that long and you can skip the parts that aren't relevant (which should be pretty obvious)
17:13:29 <edwardk> geezusfreeek: hrmm is should work on 6.8 did i miss something?
17:13:47 <geezusfreeek> edwardk: i actually don't remember the problem
17:13:54 <Ralith> ddarius: I skipped to 4.1.2 and I'm not sure quite how to interpret it.
17:13:54 * geezusfreeek tries cabal install
17:13:56 <edwardk> geezusfreeek: I bundled it with a version of Control.Category a version or so back
17:14:10 <Ralith> ddarius: I have zero experience with haskell
17:14:12 <edwardk> I unfortunately don't have 6.8 here at the moment or I'd have tested it ;)
17:14:40 <geezusfreeek> edwardk: it can't find Control.Functor. is that a ghc 6.9 thing?
17:14:44 <edwardk> if it doesn't work it should be a minor 2-3 line patch to figure out how to make it work
17:14:56 <edwardk> I think I may have forgotten to add to the package. I supply it.
17:15:01 <geezusfreeek> edwardk: ah
17:15:08 <Cale> vixey: They define a predicate R_T on the set of closed terms of a type T, by saying that R_A(t) iff t halts, where A is an atomic type, and R_(T_1 -> T_2)(t) iff t halts and, whenever R_(T_1)(s), we have R_(T_2)(t s)
17:15:33 <edwardk> hrm darcs says its already in the repository
17:15:37 <geezusfreeek> this is with the hackage version, not head
17:16:14 <edwardk> i apparently forgot to add it to the list of supplied modules.
17:16:25 <geezusfreeek> ah
17:16:32 <edwardk> er exposed modules
17:17:48 <dolio> gubagem: In general, a normal form is some restricted form of writing terms in some language such that every (most?) terms in the language are equivalent to some normal form term, and the normal form for any given term is unique. Or something along those lines.
17:17:59 <edwardk> geezus can you pull it from the darcs repo and test?
17:18:03 <edwardk> if it works i'll push to hackage
17:18:03 <geezusfreeek> sure
17:18:40 <edwardk> i gave up class associated types to get it to work on 6.8 it'd be a shame if i got nothing for my contortions ;)
17:18:44 <vixey> Cale: so left is proving that whenever R_(T_1)(s), we have R_(T_2)(t s) and that R contains ever well typed term?
17:19:22 <Cale> vixey: They then show that every element of R_T is normalisable (which is easy), and yeah, that R_T contains every term of type T, by structural induction on a derivation that the term has type T.
17:19:33 <geezusfreeek> edwardk: "Setup.lhs: category-extras.cabal:76: Do not use tabs for indentation (use spaces instead)"
17:19:35 <vixey> ooh
17:19:38 <edwardk> lol
17:19:56 <geezusfreeek> apparently that's an error not a warning
17:20:01 <geezusfreeek> it won't configure with that :P
17:20:09 <edwardk> recorded ;)
17:20:19 <vixey> o_o
17:20:21 <edwardk> that always trips me up with cabal ;)
17:20:32 <edwardk> patched, once more ;)
17:20:38 <geezusfreeek> edwardk: Setup.lhs: can't find source for Control.Category in ["pre-6.9","src"]
17:21:16 <edwardk> ok, patched try again =)
17:21:33 <edwardk> i really should just install 6.8. heh
17:21:38 <geezusfreeek> edwardk: the array package is hidden
17:21:49 <edwardk> ok, so we broke out into array before 6.9
17:22:12 <dolio> Split base was 6.6 -> 6.8, I believe.
17:22:19 <edwardk> ah ok
17:22:24 <geezusfreeek> dolio is correct
17:22:44 <geezusfreeek> seems to be compiling now
17:22:44 <edwardk> recorded with the array added to the list for < 6.9
17:23:21 <edwardk> i just keep spewing code into it figuring it'll eventually reach a critical mass ;)
17:23:30 <geezusfreeek> edwardk: seems to build now
17:23:31 <edwardk> nice
17:23:41 <geezusfreeek> yes. i will have some fun now
17:23:54 <geezusfreeek> i have a lot to look at
17:24:30 <edwardk> would you be too terribly hurt if i went through and defined monads over more general categories than hask if it meant that i lost access to most of the default functors in Haskell? i.e. if you had to use an explicit CFunctor or CMonad instance to use the library?
17:25:09 <Pseudonym> Clearly the problem is in the standard library, no?
17:25:21 <edwardk> Pseudonym: sure, but i can't fix that, i can fix this ;)
17:25:26 <Pseudonym> :-)
17:25:30 <Pseudonym> Get it _right_.
17:25:37 <Pseudonym> Then we can decide if the standard library is wrong.
17:25:37 <edwardk> yeah
17:25:40 <geezusfreeek> edwardk: i have occasionally struggled with that myself
17:26:07 <geezusfreeek> edwardk: what exactly is wrong with the standard Functor?
17:26:28 <edwardk> geezusfreek: i want to be able to define functors over say, a kleisli category of some monad for instance.
17:27:02 <edwardk> so i can have for instance a memoizing context comonad that works over the kleisli IO category (or any category with something like "CategoryIO")
17:27:08 <gubagem> whats a kleisli category
17:27:31 <geezusfreeek> okay it's a bit over my head yet i guess
17:28:04 <edwardk> gubagem: its what you get if you make it so that all arrows in your category (functions) are of the form a -> m b, like monadic actions.
17:28:14 <edwardk> its like looking at the world through lenses that don't see a particular monad.
17:29:08 <geezusfreeek> this isn't just so you can avoid orphan instances, is it?
17:29:19 <edwardk> nah. this is bigger than that
17:29:29 <edwardk> i only have like 3 orphan instances iirc
17:29:34 <edwardk> and they are all for Either
17:29:39 <geezusfreeek> yeah i think that is what i saw
17:30:02 <geezusfreeek> i'd say if there are things you just can't do otherwise, go for it
17:30:04 <edwardk> because I use Either as its real monadic self not the Error handling perversion it has become ;)
17:30:09 <geezusfreeek> it might hurt me though :\
17:30:51 <edwardk> Either should be a monad with or without an instance of Error for its left hand side, its current form is an artifact of bolting fail into Monad.
17:31:32 <geezusfreeek> is there any way to get do notation with something that isn't a standard Monad?
17:31:44 <edwardk> geezusfreeek: you can use the -fno-implicit-prelude
17:31:48 <geezusfreeek> aha
17:32:19 <edwardk> though i think the desugaring is slightly incorrect to work for these other categories.
17:32:20 <geezusfreeek> would category-extras have its own implementation of mtl to account for this?
17:32:44 <geezusfreeek> i assume it completely subsumes mtl anyway? :)
17:32:47 <edwardk> it'd have to coz Reader for instance uses -> not an arbitrary exponential for a given category
17:32:56 <edwardk> I actually don't replace the MTL instances yet =)
17:32:59 <gubagem> ok all these arrows from category theory look like diagrams from group theory
17:33:28 <edwardk> but yeah i'd pretty much have to bake in a specialized copy of MonadLib or the MTL.
17:33:28 <shapr> @yow !
17:33:28 <lambdabot> ... or were you driving the PONTIAC that HONKED at me in MIAMI last Tuesday?
17:33:31 <shapr> yarr!
17:33:31 <lambdabot> shapr: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:33:33 <shapr> ooh
17:33:45 <edwardk> heya shapr
17:33:48 <shapr> hiya edwardk!
17:33:59 <thetallgu1> @yow!
17:33:59 <lambdabot> Like I always say -- nothing can beat the BRATWURST here in DUSSELDORF!!
17:34:03 <geezusfreeek> edwardk: based on things i've seen from comonad.com you almost might as well just reimplement mtl/monadLib
17:34:06 <thetallgu1> That'strue
17:34:07 <edwardk> more kan extensions on the blog in case you want light reading.
17:34:16 <shapr> edwardk: Yeah, redo mtl/monadLib!
17:34:27 <edwardk> shapr: well, i don't want to i just can't type what i want with them
17:34:33 <shapr> Fix 'em?
17:34:49 <edwardk> the biggest problem is to do them RIGHT i should use class associated types. otherwise the types get noisy.
17:35:06 * geezusfreeek finally gets around to looking up class associated types
17:35:50 <geezusfreeek> oh i actually had a paper on my queue about this
17:36:15 <shapr> edwardk: Sounds good to me.
17:36:47 <edwardk> i.e. with class associated types I can define data StateT i k a = S (k i (Prod k a i)), without them you have to supply the product type for a given category data StateT i p k a = S (k i (p a i)) and carry it around everywhere you use it
17:37:03 <edwardk> and that extra (,) parameter or whatever just becomes noise.
17:37:36 <dolio> edwardk: Did my message get through about two minutes ago?
17:37:39 <edwardk> shapr: i can't fix them my needs are pretty far from the mainstream ;)
17:37:45 <doun> Pseudonym: heh, I discovered Lojban has lambda variables for its abstractions (events, qualities, etc.) e.g. le ka ce'u xlura da de di corresponds to \x.xlura(x,da,de,di) (the property that x influences ..). it truly is the language of geeks.
17:37:59 <edwardk> dolio: i see nothing
17:38:02 <geezusfreeek> doun: yes lojban rocks
17:38:08 <dolio> edwardk: I think there's a slight typo in your latest blog.
17:38:09 <shapr> edwardk: Bah, I'm sure everyone else will come around to your way of thinking.
17:38:16 <edwardk> i wasn't identified
17:38:19 <geezusfreeek> if only i had the patience to learn a bit of it
17:38:19 <edwardk> dolio: msg again fixed
17:38:21 <dolio> "The Reader arrow takes the form arr (a, e) b, which when a is (->) this reads as (a,e) -> b, which is just a curried Kleisli arrow for the Reader monad."
17:38:21 <shapr> doun: Yeah, lojban is based on predicate logic.
17:38:29 <dolio> I think you mean "when arr is (->)"
17:38:30 <edwardk> ah which when arr
17:38:32 <edwardk> yeah
17:38:36 <shapr> doun: Now, can you make a mapping from lojban to Haskell? :-)
17:38:43 <edwardk> i changed the notation and didn't rewrite the whole sentence
17:38:49 <geezusfreeek> shapr: hasn't somebody done that?
17:38:54 <geezusfreeek> :P
17:39:06 <shapr> I don't think so. I've only seen mappings to Prolog and something else.
17:39:13 <edwardk> fixed
17:39:16 <shapr> mi djica lenu mi gunka
17:39:23 <edwardk> should that be my worse typo, I'm doing pretty well ;)
17:39:27 <dolio> I had the impression that lambda calculus and such was occasionally used in general in linguistics.
17:39:31 <shapr> lambdabot had some lojban plugins for awhile.
17:39:33 <dolio> It's probably not specific to lojban.
17:39:42 <vixey> delimited continuations and dependant types too
17:39:55 <dolio> Yeah.
17:39:56 <edwardk> vixey: only really by CC Shan, but hey
17:40:02 <dolio> Heh.
17:40:23 <Spark> i saw a talk where they were using aspects in linguistics
17:40:28 <Spark> to find interesting patterns in the bible
17:40:36 <Spark> and to spot paedophiles in online chatrooms
17:40:48 <Spark> no joke
17:41:22 <dmwit> The lojban community is so small it operates on a first-name basis... O_o
17:41:42 <dmwit> But then, I guess the Haskell community is pretty much that way, too.
17:41:50 <doun> doi shapr go'i lo nu gunka ma .a'u
17:41:52 <edwardk> amazing given any large enough data set you can find "statistically significant" correlations scattered through out. film at 11. ;)
17:41:55 <Spark> all research communities are like that
17:41:59 <shapr> capr :-)
17:42:09 <doun> u'i
17:42:28 <edwardk> The main reason I never bothered to learn lojban is all you can do with it is talk to the kind of people who learn lojban ;)
17:42:42 <doun> edwardk: yeah, I think xkcd did that joke two years ago
17:42:42 <shapr> Bah, same old xkcd joke!
17:43:04 <shapr> doun: I'd rather be doing Arduino stuff at the moment :-)
17:43:12 <shapr> I forgot to buy a soldering iron at the mall today :-(
17:43:34 <wolgo> I think I am going to go somewhere outside and read these tutorials.
17:44:15 <geezusfreeek> .a'onairu'e
17:44:51 <doun> .ue doi djizus. do mo
17:45:38 <geezusfreeek> doun: not that much :\
17:45:48 <doun> hehe
17:46:08 <doun> geezusfreeek: have you heard the "ko mo"?
17:46:24 <geezusfreeek> i've mostly latched onto very short sentences and a few attitudinals
17:46:35 <shapr> doun: I like "ko mo do"
17:46:48 <shapr> It's funny that 'komodo' is a legal thing to say in lojban.
17:47:15 <shapr> I tried 'ma mo' instead of 'ma nuzba' for a greeting, but it's a bit too non-specific.
17:47:43 <geezusfreeek> nope
17:48:17 <doun> shapr: heh, "what is true about what"
17:48:20 <shapr> Lojban was useful to me in the same way that E-Prime was useful to me.. trying to phrase my thoughts in that format taught me something about what I was saying.
17:48:47 <geezusfreeek> shapr: that is exactly the feeling i have whenever i do try to learn a little lojban
17:49:00 <geezusfreeek> it makes me very much aware of the connotations of english that i have grown so used to
17:49:01 <vixey> that's why I like programming
17:49:05 <vixey> and maths
17:49:19 <shapr> Swedish had that effect on me, French not so much.
17:49:33 <doun> shapr: {do mo} is kind of common on the IRC, e.g. "what is true about you", but you could answer with any truth. context is helpful in this, er, context
17:51:19 <doun> geezusfreeek: after a couple hours of speaking it you begin to think in it, except lack of vocab pulls you down :-P
17:51:40 <geezusfreeek> yeah i had that problem before i succumbed to the demands of reality :(
17:51:43 <edwardk> hrmm math folks must not like haskell the new kan extension post got modded down to 0 there immediately
17:51:47 <shapr> heh
17:52:12 <geezusfreeek> says 1 here :)
17:52:18 <geezusfreeek> but now it's 2
17:53:20 <edwardk> i think someone spanked it for the crosspost (math and programming)
17:53:44 * geezusfreeek wishes reddit had tags
17:53:54 <doun> tags++
17:54:00 <geezusfreeek> @karma tags
17:54:01 <lambdabot> tags has a karma of 1
17:54:03 <geezusfreeek> :P
17:55:04 * doun screams functional references are COOL!" from the rooftops
17:55:20 <doun> blargh i are ded. /me goes sleep
17:55:25 <geezusfreeek> woah, class associated types seems very foreign to what i am used to doing
17:55:25 <vixey> doun,
17:55:38 <vixey> can I implement typed logic variables using functional references?
17:56:06 <edwardk> geezusfreeek: i wound up wanting them in like the second haskell program i ever wrote so they feel very natural to me by now ;)
17:56:40 <geezusfreeek> edwardk: i did try some similar things as a newb, but i have gotten so used to the status quo now
17:56:49 <geezusfreeek> perhaps status quo is the wron word choice
17:56:50 <edwardk> geezusfreeek: the main use is they let your classes not have to mention everything they ever remotely even think about
17:56:51 <geezusfreeek> but you get my point
17:57:15 <edwardk> geezusfreeek: i.e. why should the types used inside of something pollute its interface.
17:57:57 <geezusfreeek> yeah i'm usually a little discouraged by messy type annotations myself
17:58:11 <edwardk> geezusfreeek: i did something with a STM/IO/ST based hash table. but not only did i have to pass the monad, but the type of references for the monad AND the type of arrays for that monad, etc. all this extra crap the end user should need to know I need.
17:58:17 <chessguy> hiya #haskellers
17:58:30 <geezusfreeek> edwardk: i'm doing almost that exact same thing today, actually
17:59:18 * geezusfreeek is tempted to get ghc 6.9 now
17:59:22 <edwardk> with class associated types you can just pass in the monad, and use a class associated type to map STM -> TVar ST -> STRef, etc.
17:59:30 <gubagem> hi chessguy, are you really good at chess?
17:59:35 <dmwit> Hiya, chessguy!
17:59:44 <chessguy> gubagem: for some definition of 'good' :)
18:00:08 <geezusfreeek> my definition of good is "better than me"
18:00:11 <chessguy> dmwit: :)
18:00:16 <chessguy> lol geezusfreeek
18:00:24 <edwardk> in my case it lets me say CCC hom, instead of CCC hom prod exp i, when 99% of the time i just care about the type of hom =)
18:00:28 * chessguy has lots of time to work on his chess engine now
18:00:39 <chessguy> ...since i got laid off today
18:00:44 <edwardk> chessguy: =(
18:00:47 <dmwit> Oh, man.
18:00:50 <dmwit> What happened?
18:00:54 <edwardk> chessguy: where at?
18:01:07 <geezusfreeek> chessguy: man i feel horrible. i was typing "you got fired?!?!" right as you said you got laid off
18:01:12 <chessguy> edwardk: northern VA
18:01:12 <geezusfreeek> it was supposed to be in jest
18:01:20 <chessguy> geezusfreeek: haha, it's ok
18:01:32 <chessguy> my VP was a moron anyway
18:01:51 <chessguy> they were working on spinning off a startup, and it wasn't going so well, so they were losing money, and had to lay some people off
18:02:09 <lament> HMMM chessguy writing a chess engine why am i not surprised?
18:02:11 <edwardk> chessguy: i feel your pain. i spent most of a year doing next to nothing after the dot-com crash
18:02:13 <dmwit> Did he at least write you a nice recommendation?
18:02:35 <chessguy> oh, i can get all the recommendations i want.
18:02:50 <chessguy> that won't be a problem
18:03:40 <chessguy> of course, if anyone knows a haskell job that's open....:)
18:04:05 <geezusfreeek> chessguy: i've been in line for a little while already :P
18:04:27 * chessguy points to a bird in the sky and cuts in front of geezusfreeek  while he's looking
18:04:41 <geezusfreeek> damn, foiled!
18:04:49 <chessguy> mauahahaha
18:05:43 <edwardk> geezusfreeek: ok. posted 0.51.2 to hackage. the hackage version of category-extras should work for 6.8 now
18:05:52 <geezusfreeek> edwardk: sweet!
18:06:29 <edwardk> of course i'm probably going to break that momentarily, but hey ;)
18:06:57 <geezusfreeek> at least it works for now. perhaps i will have 6.9 by the time a new version is put in hackage
18:07:11 <lament> chessguy: what's a good way to learn chess?
18:07:35 <geezusfreeek> edwardk: Could not find module `Control.Monad.Ideal'
18:07:39 * chessguy shrugs. by playing, and getting stronger players to look at your games with you
18:07:39 <edwardk> hrmm
18:07:42 <geezusfreeek> sorry for the bad new
18:07:43 <geezusfreeek> s
18:07:45 <edwardk> ok, i must have not included it
18:07:47 <edwardk> fixing
18:08:52 <edwardk> rebuilding the sdist
18:09:12 <edwardk> if you drop that in the cabal file is there anything else its missing?
18:09:15 <chessguy> oh well, g'night all
18:09:39 <geezusfreeek> edwardk: hold on, gotta find it (i was using cabal-install)
18:09:55 <edwardk> will just push to hackage
18:10:24 <geezusfreeek> ah okay
18:10:30 <edwardk> pushed
18:10:52 * geezusfreeek trying again
18:11:05 <edwardk> hrmm there is no real way to get hackage to shut up about -O2 is there?
18:11:18 <edwardk> i moved it into a separate flag, etc.
18:11:57 <edwardk> its funny how many problems you can find when you get someone else to actually install something ;)
18:12:07 <geezusfreeek> edwardk: it builds for me now
18:12:17 <malebria> Does -- * xxx in module description needs an empty line before, in Haddock?
18:12:45 <malebria> In documentation it gives two examples without it, but when I don't put the line it does not get on the .html.
18:12:59 <geezusfreeek> malebria: it does the same thing for me
18:14:08 <malebria> It's a bug from haddock, or just from documentation?
18:15:32 <edwardk> geezusfreeek: lemme know if anything in there doesn't make sense or seems misorganized. i'll happily shuffle stuff around. a lot of the instances wind up in odd places though to keep from having orphans
18:16:00 <geezusfreeek> edwardk: sure thing
18:16:12 <edwardk> going off to spend a bit of time with the wife.
18:16:13 <geezusfreeek> malebria: i'm not sure
18:29:22 <vixey> still haven't chosen a type system to play with
18:30:07 <Riastradh> Try the red one.
18:30:20 <vixey> Hi Riastradh
18:30:25 <vixey> I read the Little MLer the other day
18:33:07 <vixey> I thougth I should rewrite my evaluator more neatly and also give it some interesting type system
18:35:46 <wolgo> hi
18:35:58 <vixey> hi wolgo what's up
18:36:01 <wolgo> I am participating in a great MMO while studying haskell
18:36:14 <wolgo> I am logged into  "Outside" right now!
18:36:24 <wolgo> wireless technology...
18:36:25 <wolgo> zomg
18:38:56 <vixey> wolgo: what aspects of haskell are you studying?
18:39:03 <wolgo> Recursion
18:39:06 <wolgo> basic stuff
18:39:10 <vixey> wolgo: oh were you writing n-queens?
18:39:24 <wolgo> That is going to be my first project.
18:39:33 <vixey> wolgo: Well don't look at this then http://hpaste.org/7805#a1
18:39:41 <vixey> but I finished my version
18:39:55 <vixey> I don't like the 'acceptable' predicate very much though
18:40:34 <wolgo> ?type insertions
18:40:36 <lambdabot> Not in scope: `insertions'
18:40:45 <wolgo> ahh
18:40:50 <vixey> a -> [a] -> [[a]]
18:40:53 <wolgo> insertions is a function that takes two args
18:41:03 <wolgo> you can pass an empty list as an arg eh?
18:41:07 <wolgo> That is good to know.
18:41:07 <gnuvince_> @hoogle a -> [a] -> [[a]]
18:41:07 <lambdabot> No matches, try a more general search
18:41:08 <vixey> @let insertions e [] = [[e]] ; insertions e (x:xs) = (e:x:xs) : map (x:) (insertions e xs)
18:41:08 <vixey> @let permutations [] = [[ ]] ; permutations (x:xs) = permutations xs >>= insertions x
18:41:09 <lambdabot> Defined.
18:41:10 <lambdabot> Defined.
18:41:22 <vixey> > insertions '!' "quibble"
18:41:22 <lambdabot>  ["!quibble","q!uibble","qu!ibble","qui!bble","quib!ble","quibb!le","quibbl!e...
18:42:53 <dibblego> > length $ insertions '!' "quibble"
18:42:55 <lambdabot>  8
18:43:23 <wolgo> So insertions in your function inserts e at the point where your recur
18:43:31 <vixey> > permutations . permutations $ "yes"
18:43:32 <lambdabot>  [["yes","eys","esy","yse","sye","sey"],["eys","yes","esy","yse","sye","sey"]...
18:43:38 <wolgo> Wow
18:43:49 <wolgo> This is unbelievably cool
18:43:52 <vixey> :)
18:44:23 <wolgo> and insertions is what you use to insert queens
18:44:32 <wolgo> e is a queen?
18:44:59 <wolgo> interesting, map (x:)
18:45:31 <wolgo> Does that cons x onto the value returned by insertions e xs?
18:45:36 <dibblego> @unpl (x:)
18:45:37 <lambdabot> (\ a -> x : a)
18:45:39 <wolgo> err, each value
18:45:41 <vixey> yes
18:45:52 <vixey> it just adds x to the start of everything
18:45:56 <wolgo> Mind if I save your code?
18:46:05 <vixey> of course not
18:46:11 <wolgo> This is helping me understand recursion better
18:46:19 <vixey> I'm really glad of that
18:46:37 <Spark> recursion?
18:46:56 <Spark> ah you defined them above
18:47:09 <Spark> is there not something similar in the libraries?
18:47:22 * bd_ ponders ways of implementing permutations with comonads
18:47:23 <vixey> Spark: I am not aware of anything similar
18:47:39 <vixey> bd_: Is there say, a list comonad?
18:48:22 <bd_> Not sure. I was thinking of something like:
18:48:23 <ddarius> vixey: There's a streams one, but that probably isn't horribly useful here.
18:48:39 <bd_> data CMList t = CMList (CMList t) t (CMList t)
18:49:05 <bd_> ie, each element holds its left and right context
18:49:07 <ddarius> vixey: However, a zipper comonad may work out quite well.
18:50:24 <pjdelport> @let insertions y = let ins xs zs = xs++y:zs in zipWith ins <$> inits <*> tails
18:50:24 <lambdabot> <local>:5:0:     Multiple declarations of `L.insertions'     Declared at: <lo...
18:50:35 <bd_> hmm, seems like it might be a bit clumsy with comonads though
18:50:38 <vixey> @unfed
18:50:38 <lambdabot> Unknown command, try @list
18:50:49 <pjdelport> > let insertions y = let ins xs zs = xs++y:zs in zipWith ins <$> inits <*> tails in insertions '!' "quibble"
18:50:50 <lambdabot>  ["!quibble","q!uibble","qu!ibble","qui!bble","quib!ble","quibb!le","quibbl!e...
18:51:10 <pjdelport> \o/
18:51:25 <vixey> c
18:51:25 <vixey> l
18:51:25 <vixey> a
18:51:25 <vixey> s
18:51:25 <vixey> s
18:51:25 <vixey> C
18:52:09 <vixey> oops :p
18:52:17 <vixey> I just pasted a huge file of single letter characters per line
18:52:30 <wolgo> hahha
18:52:43 <vixey> what I meant to say was,
18:52:49 <vixey> class Comonad d where
18:53:00 <vixey>  counit :: d a -> a
18:53:15 <vixey>  cobind :: (d a -> b) -> d a -> d b
18:53:18 <SamB> vixey: howw ddi dyou get it messed up like that?
18:53:34 <vixey> copying from a PDF didn't work well
18:53:53 <ddarius> pjdelport: Yuck
18:53:54 <SamB> ah
18:53:54 <bd_> vixey: class Functor d => Comonad d ..., you mean
18:54:05 <bd_> ohwait
18:54:08 <bd_> you used cobind not cojoin
18:54:12 <pjdelport> ddarius: acquired taste
18:54:12 <SamB> vixey: yes, that is a very iffy thing to do
18:54:16 <ddarius> @src inits
18:54:17 <lambdabot> inits []     =  [[]]
18:54:17 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
18:54:25 <SamB> vixey: depends much on the file and the reader version
18:54:36 <vixey> pjdelport: I liked it
18:54:53 <SamB> vixey: very occasionally I actually hit a combination that preserves indentation!
18:55:10 <vixey> SamB: something in between PDF and HTML would be nice I guess
18:55:56 <ddarius> > inits "foo"
18:55:57 <lambdabot>  ["","f","fo","foo"]
18:56:16 <MyCatVerbs> SamB: wouldn't it be wonderful if people just handed out TeX sources instead? :)
18:56:29 <Spark> how does pdf flow text?
18:56:34 <SamB> MyCatVerbs: those are harder to read
18:56:36 <wolgo> how do you say this in english:  listcount (x:xs) = 1 + listcount(xs)
18:56:37 <Spark> does it preserve the idea of a box of text?
18:56:41 <Spark> or are the letters all jumbled together
18:56:49 <dmwit> > let insertions x = liftM2 (zipWith (\a b -> a ++ x:b)) inits tails in insertions '!' "quibble"
18:56:50 <lambdabot>  ["!quibble","q!uibble","qu!ibble","qui!bble","quib!ble","quibb!le","quibbl!e...
18:57:00 <dmwit> ?pl \a b -> a ++ x:b
18:57:01 <lambdabot> (. (x :)) . (++)
18:57:02 <SamB> Spark: what do you mean, "flow"
18:57:04 <Spark> it wouldn't suprise me if it weren't just the pdf readers being shit
18:57:10 <geezusfreeek> @pl \xs zs -> xs++y:zs
18:57:10 <lambdabot> (. (y :)) . (++)
18:57:14 <Spark> SamB: you know, flow text...
18:57:29 <SamB> Spark: it's a combination of (a) readers being shit often and (b) files being shit often
18:57:33 <vixey> Spark: I suppose it's partly the file format that makes interacting with PDFs less than perfect
18:57:45 <dmwit> Oh, I see these definitions are equivalent.
18:58:01 <dmwit> Time to play with ZipList. =)
18:58:14 <Spark> maybe since it's such a versatile format, there's no kind of standard for doing text
18:58:26 <vixey> wolgo: I tend not to
18:58:28 <Spark> so a particular reader will only understand a particular writer, when it comes to selecting text
18:58:31 <SamB> really, you need BOTH a good reader and a good file to get good copy/paste
18:59:08 <SamB> but I think I was not imagining it when I actually saw indentation preserved once or twicee
19:00:03 <SamB> (you can't expect this from arbitrary converted postscript files, clearly...)
19:00:23 <Spark> i don't know the formats well enough to comment
19:00:37 <Spark> you could always write a broken converter thoguh
19:00:42 <Spark> e.g. rasterising the text :)
19:00:48 <SamB> well, postscript files have different semantics than PDF files
19:00:50 <Spark> or converting it from text into vector graphics
19:01:06 <SamB> postscript files are programs that usually draw page images
19:01:14 <pjdelport> wolgo: "the listcount of a list is one plus the listcount of the rest"?
19:01:17 <SamB> PDF files are pages bundled with metadata
19:02:08 <wolgo> pjdelport oh okay
19:02:13 <ddarius> insertions is a paramorphism
19:02:15 <Spark> that doesn't say much about the ability to select text though
19:02:19 <wolgo> that completely clears what (x:xs) is
19:02:22 <Spark> in either case you'd read it into some more convenient form for actual rendering
19:02:24 <wolgo> a list
19:02:30 <SamB> with facilities to allow reasonable copy/paste, outline, embedded thumbnails, hyperlinks ... I think it even has a few transitions for people who like to use those in presentations!
19:02:51 <pjdelport> wolgo: oh, right;  have you covered that list syntax yet?
19:03:26 <ddarius> @let para c n [] = n; para c n (x:xs) = c x xs (para c n xs)
19:03:27 <lambdabot> Defined.
19:03:41 <SamB> Spark: well, with postscript, you're lucky if you have a clue what character a given glyph represents
19:03:59 <SamB> Spark: and worse, you probably won't be aware of whether or not this is the case (programmatically)
19:04:00 <Spark> the ps2text programs seem to work ok
19:04:17 <Spark> nutil they hit maths
19:04:27 <pjdelport> more djvu required
19:04:28 <ddarius> > let insertions e = para (\x xs xs' -> (e:x:xs) : map (x:) xs') [[]] in insertions '!' "quibble"
19:04:29 <lambdabot>  ["!quibble","q!uibble","qu!ibble","qui!bble","quib!ble","quibb!le","quibbl!e...
19:04:30 <SamB> Spark: well, that's because most people are sane and use askii
19:04:32 <SamB> er. ascii
19:04:56 <vixey> ddarius: exactly
19:05:15 <wolgo> pjdelport no not yet but I wrote my own zip
19:05:26 <wolgo> so I have a small idea of what it does
19:05:28 <shepheb> sometimes I wish there was a "course in Haskell and FP theory", a sequence of concepts, wiki pages, papers, blog posts, etc. to read to bootstrap one's way through the concepts.
19:06:02 <wolgo> Does it mean something more complex than list?
19:06:07 <wolgo> or is it like a slice
19:06:16 <SamB> Spark: I think PDF might nearly be able to handle math copy/paste, if only you could coax the typesetter into producing a file for which this could work...
19:06:31 <vixey> wolgo: [1,2,3,4,5] is exactly the same as 1 : (2 : (3 : (4 : (5 : []))))
19:06:36 <Spark> SamB: you mean emit unicode?
19:06:41 <pjdelport> @src []
19:06:41 <lambdabot> data [] a = [] | a : [a]
19:06:43 <Spark> what about the things that you can do in latex and not in unicode
19:06:50 <Spark> e.g. a^a
19:06:55 <SamB> Spark: It ought to be possible, PDF does support unicode unlike postscript...
19:07:31 <pjdelport> wolgo: that's essentially the same as "data List a = Nil | Cons a (List a)"
19:08:12 <SamB> Spark: yeah, probably that wouldn't work too well...
19:08:13 <wolgo> eek
19:08:33 <pjdelport> wolgo: hence, for example,
19:08:33 <pjdelport> > foldr (:) [] "abracadabra"
19:08:34 <lambdabot>  "abracadabra"
19:08:36 <SamB> Spark: it might be possible to somehow insert unrendered characters in the text stream?
19:08:52 <Spark> hmm
19:08:55 <wolgo> foldr
19:09:02 <Spark> switch to a null font maybe?
19:09:04 <Spark> is that possible/
19:09:13 <Spark> this is all way too hacky though
19:09:15 <SamB> I'm sure SOMETHING can be done
19:09:17 <wolgo> :t folder
19:09:19 <lambdabot> Not in scope: `folder'
19:09:22 <wolgo> :t foldr
19:09:23 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:09:24 <wolgo> hahah
19:09:27 <vixey> provide a .txt accompanyment
19:09:30 <SamB> it can't be harder than what they do for OCR'd text!
19:09:37 <SamB> that's even hackier!
19:09:40 <Spark> heh
19:09:50 <Spark> we need a sensible format
19:09:52 <wolgo> Oh shite
19:09:53 <Spark> svg with embedded fonts?
19:09:55 <wolgo> : is a function
19:09:59 <pjdelport> wolgo: foldr is the catamorphism for lists;  a very general function
19:10:07 <pjdelport> you'll learn more about that later :)
19:10:20 <wolgo> down the rabbit hole
19:10:22 <pjdelport> wolgo: yes;  specifically, it's a constructor
19:10:24 <SamB> they basically seem to render the OCR'd text underneath the page image
19:10:40 <pjdelport> wolgo: so you can both use it as a function and pattern match with it
19:10:50 <wolgo> ok
19:10:51 <Spark> the world needs more standardised fonts
19:10:57 <Spark> it's stupid that web pages look different everywhere
19:11:06 <wolgo> I think I am going to do a little project now.
19:11:12 <pjdelport> (which is sort of like "un-applying" the function and getting its parameters back out, to speak loosely)
19:11:16 <jaj> pjdelport: however you cannot use [] as a function even though it is a constructor
19:11:23 <SamB> Spark: I honestly do not want webpages to look the same everywhere
19:11:24 <jaj> > [] 1
19:11:25 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `[a]'
19:11:28 <pjdelport> jaj: sure you can;  it's just nullary
19:11:56 <SamB> I think things would work fine if people didn't keep specifying absolute font sizes!
19:12:03 <wolgo> A short webpage that uses only recursive techniques
19:12:08 <pjdelport> jaj: Haskell doesn't really make any distinction between nullary functions and values
19:12:15 <wolgo> one that says Hello World!
19:12:19 <Spark> SamB: doing otherwise is too limiting
19:12:33 <Spark> virtually every serious webpage is broken because of this
19:12:57 <Spark> and making this brokenness invisible is a massive pita
19:12:59 <pjdelport> wolgo: have you seen The Evolution of a Haskell Programmer? :)
19:13:04 <SamB> what I want to know is why Google Reader has such crazy ideas about font metrics on IE6
19:13:28 <pjdelport> wolgo: http://www.willamette.edu/~fruehr/haskell/evolution.html
19:13:28 <lambdabot> Title: The Evolution of a Haskell Programmer
19:13:38 <SamB> it only uses like 1/6 of the available space, maybe less
19:14:02 <Spark> ubuntu has been fucking me off recently my continually changing the DPI
19:14:17 <Spark> every so often firefox will crash, and when i restart it all the menus are unreadable
19:14:29 <wolgo> pjdelportno
19:14:36 <wolgo> pjdelport I will read this :)
19:15:46 <wolgo> ahh
19:15:48 <wolgo> flodr
19:15:50 <wolgo> foldr
19:15:55 <wolgo> I can't even spell it right
19:16:21 <SamB> hmm.
19:16:22 <SamB> floodr...
19:16:57 <SamB> > let floodr = unlines (inits (repeat '*'))
19:16:57 <lambdabot>  Parse error at end of input
19:17:03 <SamB> @let floodr = unlines (inits (repeat '*'))
19:17:03 <lambdabot> Defined.
19:17:28 <SamB> @. read run floodr
19:17:28 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
19:18:03 <SamB> @let floodr = inits (repeat '*')
19:18:03 <lambdabot> <local>:7:0:     Multiple declarations of `L.floodr'     Declared at: <local>...
19:18:11 <SamB> @unlet floodr
19:18:11 <lambdabot>  Parse error
19:18:15 <SamB> @help let
19:18:15 <lambdabot> let <x> = <e>. Add a binding
19:18:23 <SamB> @reset
19:18:23 <lambdabot> Unknown command, try @list
19:18:25 <SamB> @list
19:18:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
19:18:26 <wolgo> soooo, foldr takes three arguments, an expression, an Int and a list and it applies the expression starting at the right bound of the list?
19:18:53 <dibblego> wolgo, think of a cons list in expanded form
19:19:02 <dibblego> wolgo, e.g. [1,2,3] is 1 : 2 : 3 : []
19:19:15 <wolgo> ok
19:19:15 <dibblego> now replace each of those : with the first argument to foldr
19:19:20 <SamB> Cale: why does it still point there when you say @list? That has always annoyed me, actually, since that information isn't based on the available plugins of the lambdabot instance in question...
19:19:29 <dibblego> then replace [] with the next argument
19:19:38 <wolgo> Oh snap
19:19:40 <wolgo> I see
19:19:41 <SamB> > floodr
19:19:42 <lambdabot>  "\n*\n**\n***\n****\n*****\n******\n*******\n********\n*********\n**********...
19:19:43 <dibblego> and whatever is the result is what foldr will return
19:20:02 <vixey> > fun floodr
19:20:03 <lambdabot>  Add a type signature
19:20:07 <pjdelport> > foldr f z [a,b,c]
19:20:08 <lambdabot>  f a (f b (f c z))
19:20:16 <dibblego> in other words, foldr (:) [] returns the same list (called *identity*)
19:20:19 <wolgo> that is why facn n = foldr (*) 2 [1..n] ; facn 4  returns 48
19:20:26 <SamB> @type fun floodr
19:20:27 <lambdabot> Not in scope: `floodr'
19:20:29 <dmwit> > expr $ fun floodr
19:20:31 <lambdabot>  *
19:20:31 <lambdabot> **
19:20:31 <lambdabot> ***
19:20:31 <lambdabot> ****
19:20:31 <lambdabot> *****
19:20:33 <lambdabot> [6 @more lines]
19:20:35 <wolgo> oh so : is the identity for []
19:20:37 <dibblego> @check \x -> foldr (:) [] x == x
19:20:38 <lambdabot>  OK, passed 500 tests.
19:20:42 <wolgo> because [] is the null list?
19:20:46 <SamB> dmwit: woooh
19:20:49 <SamB> exploit!
19:20:52 <dmwit> @more!
19:21:03 <dibblego> no, foldr is called the catamorphism for list
19:21:07 <SamB> dmwit: notice the lack of space at the start of the second line
19:21:14 <dmwit> SamB: Yep, I know. =)
19:21:20 <wolgo> let me look that word up in the dictionary
19:21:23 <dibblego> foldr (:) [] is identity
19:21:29 <SamB> dmwit: you've already done it?
19:21:33 <dmwit> yeah =)
19:21:35 <dibblego> don't worry too much about the terminology; focus on understanding foldr
19:21:37 <pjdelport> wolgo: look at that expansion above
19:21:37 <SamB> where is a second lambdabot when you need one?
19:21:56 <dmwit> wolgo: The catamorphism, loosely, is a function that replaces the constructors with user-supplied functions.
19:21:56 <dibblego> I have one running in other channels
19:22:09 <wolgo> Ahh
19:22:19 <SamB> @type expr
19:22:21 <lambdabot> Expr -> Expr
19:22:33 <SamB> @type fun
19:22:35 <lambdabot> forall a. (FromExpr a) => String -> a
19:22:42 <pjdelport> wolgo: in other words, foldr (:) [] is the list identity because it replaces (:) with (:) and [] with []
19:23:16 <wolgo> so the catamorphism that foldr is using is (*) replacing : in the expansion 1:2:3:4:5:n:...:[]
19:23:25 <wolgo> pjdelport I am beginning to understand
19:23:48 <SamB> dmwit: why do you say "loosely"?
19:23:53 <pjdelport> wolgo: right :)
19:23:55 <SamB> isn't that JUST what a catamorphism is?
19:24:04 <dibblego> 1:2:3:4:5:[] becomes 1*2*3*4*5*2
19:24:13 <wolgo> Holy
19:24:17 <wolgo> that is so awesome
19:24:17 <SamB> I was under the impression that "fold" was the ambiguous term
19:24:19 <dmwit> SamB: There's a lot of ambiguity in my definition that a truly rigorous mathematician would sneer at. ;-)
19:24:33 * wolgo is not a mathematician
19:24:38 <pjdelport> wolgo: generally, you would use the function's identity as the replacement of []
19:24:50 <wolgo> wait a minute
19:24:56 <pjdelport> wolgo: so product = foldr (*) 1, sum = foldr (+) 0
19:25:03 <pjdelport> and so on
19:25:04 <SamB> dmwit: well, I don't know a programming language in which you can write that
19:25:15 <SamB> (for that languages datatypes, I mean!)
19:25:18 <vixey> SamB: write what?
19:25:24 <wolgo> OH!
19:25:25 <vixey> ?where Charity
19:25:25 <lambdabot> http://pll.cpsc.ucalgary.ca/charity1/www/home.html
19:25:26 <wolgo> I SEE!
19:25:29 <SamB> vixey: the definition of catamorphism
19:25:36 <wolgo> 0 is the additive identity
19:25:41 <wolgo> 1 is the multiplicative
19:25:46 <vixey> SamB: well I tried to represent ADTs as data
19:25:53 <SamB> dmwit: btw, by programming language I mean logic
19:26:00 * wolgo actually did learn algebra
19:26:10 * wolgo needs to learn more math
19:26:17 <vixey> SamB: you can create a function CataType that take an ADT to the catas type and .. theoretically a function that creates the catamorphism but I didn't manage that bit
19:26:21 <wolgo> wow
19:26:23 <pjdelport> wolgo: there's lots more you can do
19:26:26 <wolgo> foldr and foldl are so awesome
19:26:31 <wolgo> that is ridiculous
19:26:37 <wolgo> do all programming languages have those?
19:26:37 <pjdelport> wolgo: for example, map f = foldr ((:) . f) []
19:26:38 <SamB> wolgo: yes, usually we do use those symbols to represent additive and multiplicative identities
19:27:13 <wolgo> map...
19:27:13 <wolgo> brb
19:27:17 <wolgo> let me use it
19:27:19 <pjdelport> wolgo: note how that's the same as the identity foldr, except for the extra application of f
19:27:34 <dibblego> wolgo, have you written map/concatMap/filter/++ using foldr yet?
19:27:44 <wolgo> no
19:27:50 <dibblego> you should give it a burl
19:28:04 <wolgo> I am on the pattern matching part of the basic path on the wikibook
19:28:08 <dibblego> map or filter are simple enough
19:28:47 <ddarius> dibblego: As is concat and (++).  And writing concatMap is an easy exercise in fusion.
19:28:58 <SamB> though for some reason Agda uses  and 
19:29:14 <dibblego> ddarius, I have watched students struggle with (++)
19:29:16 <SamB> (probably because it uses 0 and 1 for zero and suc zero...)
19:29:59 <SamB> dibblego: writing ++ is easier than proving it transitive
19:30:03 <SamB> er.
19:30:05 <SamB> associative
19:30:23 <SamB> I am so bad at saying the right property name :-(
19:30:42 <SamB> transitive doesn't even apply to that type of operator!
19:30:52 <ddarius> > (\f -> foldr (flip (foldr (:))) [] . foldr (f . (:)) []) (\x -> [x,x]) "fox"
19:30:53 <lambdabot>  Couldn't match expected type `[[a]] -> [[a]]'
19:31:54 <SamB> WTF
19:32:09 <SamB> check  out
19:32:24 <ddarius> > (\f -> foldr (flip (foldr (:))) [] . foldr ((:) . f) []) (\x -> [x,x]) "fox"
19:32:25 <lambdabot>  "ffooxx"
19:32:32 <ddarius> transposition error
19:33:20 <SamB> huh, that clowns and jokers paper stole this symbol from APL: 
19:33:23 <dolio> SamB: I think I've seen  and  used in some logics.
19:34:39 <dolio> So it'd make sense to use those in the type-system-as-a-logic portion of the library.
19:35:47 <dolio> Man, google gets 0 hits for those.
19:36:05 <hpaste>  dmwit annotated "a solution to N-queens" with "brute force is too slow!" at http://hpaste.org/7805#a2
19:37:05 <vixey> dmwit: ah! nice zipWith .. I didn't think of that
19:37:21 <dmwit> Although I think maybe mine may be broken, hold on a tick.
19:37:27 <monochrom> dmwit: Is yours forward constraint propagation?
19:37:30 <dmwit> monochrom: yeah
19:37:42 <dmwit> Ah, no, it's not broken, I just copied the wrong display function.
19:37:44 <SamB> dolio: I thought the whole thing was type-system-as-a-logic
19:37:48 <monochrom> I once wrote it in do-notation.
19:37:52 * ddarius wants to write a linear logic interpreter.
19:38:00 <vixey> ddarius: Cool
19:38:11 <vixey> ddarius: In Haskell?
19:38:19 <ddarius> Presumably.
19:38:46 <monochrom> http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.html  and  http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.hs
19:38:47 <lambdabot> http://tinyurl.com/5r8pxn
19:39:22 <monochrom> The first url (html) has a link to the second url as "Source Code".
19:39:55 <monochrom> The haddock is like five times longer than the code :)
19:40:42 <vixey> wow
19:41:06 <dons> ?users
19:41:06 <lambdabot> Maximum users seen in #haskell: 480, currently: 419 (87.3%), active: 18 (4.3%)
19:41:09 <dons> oh hmm
19:41:10 <vixey> monochrom: that's so cool
19:41:12 <dons> that's a new record.
19:41:13 <dolio> SamB: Well, in the portion that deals more with propositions than sets, then, perhaps.
19:41:43 <dons> when did we reach 480?
19:41:43 * vixey *bookmarks*
19:41:43 <ddarius> dons: I don't think so.
19:41:48 <dons> and how long till we hit 500?
19:41:57 <dons> ddarius: 479 has been the high score since january, afaik.
19:42:07 <wolgo> wtf is a Maybe?
19:42:09 <ddarius> I think the highest I've seen is 483 or something like that.
19:42:13 <ddarius> @src Maybe
19:42:13 <lambdabot> data Maybe a = Nothing | Just a
19:42:19 <dons> i note #python is bigger than #perl now, finally.
19:42:33 <dons> ddarius: ah right. yes, freenode has 482 as the max.
19:42:58 <pjdelport> wolgo: you can think of it as an optional value
19:42:59 <Spark> what are the numbers on #python and #perl
19:43:05 <dmwit> wolgo: When I'm in Java/C[++], I think of pointers as "Maybe" types; they can either point to something, or not (i.e. be NULL).
19:43:27 <thetallguy> dons: might be useful to graph theturnover rates
19:43:28 <pjdelport> wolgo: or as a bounded "list" of exactly 0 or 1 elements
19:43:36 <dons> php, 605. python, 561, perl, 553
19:43:40 <thetallguy> dons: sort of like cashflow
19:43:45 <dons> mm
19:43:53 <dons> ruby-lang, 319
19:43:54 <Spark> ##c 490
19:43:56 <dons> (hah!)
19:44:00 <Spark> c++ 503
19:44:07 <Spark> lua 116
19:44:13 <dons> http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode
19:44:14 <lambdabot> Title: Search IRC, displaying all channels on freenode
19:44:18 <vixey> #algol 3 !
19:44:20 <vixey> :P
19:44:22 <Spark> i'm not sure what this proves thoguh :)
19:44:39 <dons> ruby sure crashed bad. mwhaha
19:44:51 <dons> nothing to hold the interest?
19:45:05 <vixey> dons: I agree
19:45:06 <pjdelport> wolgo: many functions use Maybe to represent a choice between a result and nothing
19:45:08 <pjdelport> :t lookup
19:45:08 <thetallguy> dons: I have one friend who loves ruby
19:45:10 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
19:45:15 <dmwit> monochrom: Ah, handy, I've written that function several times now.
19:45:24 <dons> yeah, there are definitely some ruby aficionados around
19:45:30 <thetallguy> dons: but in working on building Chumby's proxy servers, he hit the wall
19:45:40 <dons> interesting.
19:45:41 <SamB> dolio: Agda identifies propositions with sets
19:45:51 <thetallguy> much like the twitter people found, I think
19:45:56 <dons> yeah
19:46:03 <SamB> dolio: I don't understand why Coq does not
19:46:10 <dolio> SamB: Yes, I know.
19:46:14 <dons> native code optimising compilers rock
19:46:16 <thetallguy> If we get a free weekend, I've promised to help him mock one up in Haskell
19:46:18 * shepheb resists the urge to turn the bag of grocery bags into a fixpoint bag of bag of bag of bag...
19:46:21 <vixey> SamB: Agda 2 has Prop a well
19:46:29 <dolio> Well, I think you can erase most Prop stuff at compile time. Whereas Set you may not be able to.
19:46:38 <SamB> vixey: I speak of Agda 2
19:46:50 <thetallguy> shepheb: don't let your cat into that bag, it will never get out
19:47:05 <SamB> dolio: why not just erase as much as possible?
19:47:07 <dolio> You might be able to do analysis to figure out when to erase Set stuff like it's Prop, but I'm not sure if that's more complicated.
19:47:19 <shepheb> thetallguy: I'd just use catMaybes
19:47:26 <thetallguy> On another note, any Debian/Debian derivative users around?
19:47:32 <SamB> if you can only erase *most* prop stuff, I don't see how you can avoid the analysis
19:47:39 <vixey> SamB: yeah like dolio said, you can't de structural induction on values in Prop.. so everything in Prop can be erased due to not being computationally significant (only logically)
19:47:49 <dolio> Well, make it all prop stuff, then. :) I'm just not totally sure.
19:48:01 <thetallguy> shepheb: that *might* work
19:48:07 <vixey> extraction in Coq will remove everything in Prop
19:48:11 <dolio> I'm not an expert on this stuff, I've just picked up bits and pieces.
19:48:26 <SamB> hmm.
19:48:40 <SamB> perhaps it would be nice to be able to specify how to extract things ...
19:48:41 <vixey> that's why exists foo, ... and { foo | ... } are different
19:48:49 <vixey> you can only use { foo | ... } to compute
19:48:52 <jaj> dons: a ruby coder told me that there are more people in #haskell because haskell is much more difficult to learn and a lot more people are looking for advice :)
19:49:02 <dynamix_> why is memoization called so?
19:49:03 <thetallguy> hah!
19:49:08 <vixey> SamB: that's how you specify to extract things
19:49:12 <dolio> I think there's something in the Agda list archives where Conor McBride talks about erasing stuff in Set and whatnot.
19:49:20 <ddarius> dons: It's not native code gen or compilation.  python is still going along.  From what I can tell, ruby is just rather poorly implemented.
19:49:39 <SamB> maybe haskell is much more difficult to learn  Haskell is more fun to learn
19:50:06 <SamB> vixey: but I think I'd rather do it a different way
19:50:36 <ddarius> From what I hear and from a little experience, #haskell has a relatively low number of newbies asking questions v. more experienced users
19:50:40 <pjdelport> jaj: it's people staying behind instead of leaving that make #haskell so big, i think
19:50:46 <SamB> i.e. by specifying the interface I wanted to implement in the language into which I was extracting
19:50:53 <dolio> SamB: Anyhow, in Coq, as I understand it, Something : Prop is guaranteed to have zero or one inhabitants, whereas that isn't true of Set/Type.
19:51:19 <ddarius> @wn memoization
19:51:20 <lambdabot> No match for "memoization".
19:51:31 <SamB> dolio: I don't see how that can be
19:51:33 <dolio> But I guess not in Agda, although I haven't tested it.
19:51:35 <vixey> dolio: Inductive True : Prop :=  I : True
19:51:42 <vixey> dolio: or .. what did you mean?
19:51:56 <SamB> dolio: istr proof equivalence is not the default in Coq!
19:51:59 <vixey> ohhh
19:52:02 <vixey> zero OR one, sorry
19:52:03 <jaj> pjdelport: I usually join #haskell as soon as I connect to freenode because there are always friendly people talking about interesting stuff and I feel like I learn a lot while reading the conversations
19:52:16 <pjdelport> dynamix_: it involves keeping a "memo" of previous results
19:52:16 <vixey> I'm not sure about that)
19:52:21 <pjdelport> jaj: exactly :)
19:52:41 <ddarius> SamB: "proof irrelevance" you mean?
19:52:43 <vixey> Coq accepts Inductive Foo : Prop := A : Foo | B : Foo.
19:52:50 <SamB> ddarius: isn't that the same thing?
19:52:54 <dolio> I guess not, then.
19:52:56 <Trinithis> what is the size of Int?
19:53:29 <SamB> vixey: I wonder if it accepts that with proof equivalence turned on?
19:53:34 <ddarius> SamB: I don't think I've heard the term "proof equivalence" used, though it seems reasonable.
19:53:39 <pjdelport> > maxBound Int
19:53:39 <lambdabot>   Not in scope: data constructor `Int'
19:53:42 <SamB> er. irrelevence
19:53:43 <pjdelport> err
19:53:46 <pjdelport> > maxBound :: Int
19:53:47 <lambdabot>  2147483647
19:53:57 <Trinithis> thx
19:54:01 <vixey> anyway the difference with Inductive Bar : Set := X : Bar | Y : Bar.
19:54:08 <bd_> > maxBound :: Int512
19:54:09 <pjdelport> Trinithis: it's allowed to vary, IINM
19:54:09 <lambdabot>   Not in scope: type constructor or class `Int512'
19:54:12 <bd_> > maxBound :: Int256
19:54:13 <lambdabot>   Not in scope: type constructor or class `Int256'
19:54:17 <bd_> hmmmmmm
19:54:28 <vixey> is that Foo generates Foo_ind, but Bar generates Bar_ind Bar_rec and Bar_rect
19:54:33 <wolgo> I just solved one of my own problems :)
19:54:39 <wolgo> That is good.
19:54:47 <wolgo> a simple one though it may be
19:54:52 <SamB> no, wait, I think Proof Irrelevance is added using that dodgy "Axiom" form...
19:55:15 <dynamix_> pjdelport: thanks, that makes sense!!
19:55:36 <SamB> (I say "dodgy" because it is the Coq equivalent of unsafeCoerce)
19:56:05 <vixey> :(
19:56:09 <vixey> Charity is written in C
19:56:24 <vixey> static void typecheck_fold(TYPED_PATT_LIST *context, PE_FOLD **phrases, TYPE_EXPR *domain, TYPE_EXPR *codomain);
19:56:35 <dolio> Nice.
19:56:35 <SamB> (except with less heap corruption and more logical inconsistancy, I guess)
19:56:46 <ddarius> Axiom A, B : Prop := ((A -> B) -> A) -> A
19:57:06 * ddarius has no idea what Coq syntax is.
19:57:15 <SamB> ddarius: I can't parse that either!
19:57:33 <vixey> ddarius: caml basically
19:58:30 <vixey> I give up trying to understand charity
19:58:31 <wolgo> I was able to rethink one of my functions, remove an argument completely, and reduce the base case to a single instance instead of two base cases
19:58:44 <SamB> ddarius: I can't see the name of the axiom in there
19:58:48 * wolgo begins to understand a couple of the basics
19:58:55 <pjdelport> wolgo: sounds cool :)
19:59:10 <SamB> (it needs a name, or else you use it to prove anything!)
19:59:20 <SamB> er. +can't
20:00:29 <vixey> ddarius; do you think you would use LogicT?
20:00:41 <ddarius> vixey: Probably not.
20:03:12 <dolio> https://lists.chalmers.se/mailman/private/agda/2008/000203.html <-- SamB
20:03:26 <dolio> That thread has stuff about Set and Prop and irrelevance in Epigram.
20:03:32 <dolio> I guess that's what I was thinking of, not Coq.
20:03:45 <vixey> I can't read it :(
20:04:01 <dolio> Yeah, you need to subscribe to the mailing list.
20:04:15 <dolio> The public archives have been down for as long as I've been on the list.
20:04:59 <dolio> As far as I can tell, anyway.
20:05:27 <SamB> or you could try gmane?
20:05:47 <dolio> Does that work? I thought that just linked to the private archives.
20:06:49 <SamB> gmane is UTTERLY SEPERATE
20:07:33 <SamB> it has a subscription to the Agda mailing list
20:07:44 <SamB> it uses that to archive all emails to the list
20:11:49 <dolio> http://article.gmane.org/gmane.comp.lang.agda/46
20:11:50 <lambdabot> Title: Gmane -- Mail To News And Back Again
20:11:53 <dolio> There's one.
20:12:12 <wolgo> why are n+k patterns bad?
20:12:32 <vixey> wolgo: I don't think they are
20:12:35 <edwardk> wolgo: because they lead you to expect that similar things like n * k, etc will also work
20:13:15 <gwern> wolgo: I think it's because they are some 'heavyweight' syntax useful only in very few circumstances, where the non-sugared way of doing things is practically as good
20:13:21 <edwardk> wolgo: they exist because they let you write things in a pseudo-inductive style over the integers, but in general they are considered a wart on the language because you have to do a lot of weird stuff to support them and they don't generalize
20:13:29 <dolio> They're also unrelated to the definition of (+) on your type.
20:13:34 <gwern> personally, I find non-n+k stuff *more*, not less understandable
20:14:08 <wolgo> I have not written anything n+k yet
20:14:25 <kpreid> > case -3 of x + 1 -> x
20:14:25 <lambdabot>  Parse error in pattern at "->" (column 18)
20:14:28 <wolgo> let it be understood that I have been a haskell programmer for 3 days though
20:14:30 <wolgo> hahaa
20:15:36 <gwern> wolgo: I've never written n+k patterns, and I've only very rarely seen'em. they're good to know just in case you run across them
20:15:50 <dolio> I wrote an n+k pattern the other day.
20:16:09 <sclv> you win gwern, I just wrote a "cleaner" api for the hvac controller...
20:16:18 <dolio> Smooth sort has a 'while (foo) p /= 2' loop, after which it does 'p--'.
20:16:20 <SamB> sometimes Agda writes n+k "patterns" for me
20:16:36 <gwern> sclv: woot. link/summary pls?
20:16:42 <SamB> ... but only non-binding ones
20:16:54 <dolio> So I did 'p' + 1 = until (not foo) (/2) p' or something of the sort.
20:16:57 <sclv> writing a reply on the page momentarily. just pushing the changes now.
20:17:05 <gwern> sclv: srsly though, anything to do with pipes or slashes is already too overloaded in people's minds. so those were silly names to begin with :)
20:17:50 <wolgo> srsly
20:18:03 <sclv> haha we'll agree to disagree...
20:18:11 <wolgo> Hey is RWH targetted toward noobs like me?
20:18:15 <dolio> gmane's web interface leaves something to be desired.
20:18:20 <ddarius> wolgo: No.
20:18:42 <sclv> srysly?
20:18:55 <wolgo> Hey I wonder if I could use what I know to make an ascii hangman game...
20:19:23 <vixey> wolgo: that sounds fun
20:19:39 <vixey> wolgo: You probably get real good experience doing that
20:19:50 <sclv> the rwh chapters I've seen look like they could take anyone handy at all with programming and turn them into a decent haskell programmer in.. uh... two months maybe.
20:19:50 <wolgo> Yeah
20:19:57 <vixey> @docs Language.Haskell
20:19:58 <lambdabot> Language.Haskell not available
20:20:05 <wolgo> I am going to make a hangman game
20:20:06 <vixey> ?where Haskell
20:20:06 <lambdabot> http://haskell.org/
20:20:35 <vixey> http://haskell.org/ghc/docs/latest/html/libraries/haskell-src/Language-Haskell-Syntax.html
20:20:35 <gwern> sclv: is that fast or slow?
20:20:36 <lambdabot> http://tinyurl.com/y7g5rc
20:20:38 <pjdelport> wolgo: it's targeted at anyone who wants to learn Haskell, with a slant towards topics that are poorly covered in the literature, like working with databases etc.
20:20:40 <ddarius> sclv: And people who aren't handy at all with programming?
20:20:45 <vixey> Why is there no fold on that?
20:21:15 <dolio> ddarius: One month!
20:21:21 <sclv> less to unlearn!
20:21:43 <gwern> hm. that inspires me to a haskell koan!
20:22:20 <gwern> 'Once, a programmer came to sclv, saying I wish to learn the ways of Haskell. How long would it take me, assiduously studying RWH?'
20:23:01 <gwern> 'sclv replied sagely, surely you could learn in 3 months. The programmer replied, three months is too long! What if I carefully recollect everything I know of my Java experience and study my computer science?'
20:24:14 <gwern> 'sclv thought, and told him, in that case, it will be no less than 4 months! The programmer despaired, and said, no! What if I study Knuth ferociously, and every minute of the day hack on C and Java and try to reimplement my programs in haskell? Surely I will learn Haskell much quicker than 4 months!'
20:24:29 <mxc> @hoogle stopwatch
20:24:29 <lambdabot> No matches found
20:24:42 <dolio> I think this is going on too long.
20:24:49 <gwern> 'sclv said, alas, in that case you will never learn Haskell. If you wish to learn Haskell, empty your mind of all knowledge, and then you will be enlightened within the month'
20:25:07 * wolgo stands in awe of Master Gwern
20:25:14 <jaj> @hoogle fire
20:25:15 <lambdabot> No matches found
20:25:22 <sclv> it is a bit lengthy.
20:25:39 <sclv> but so true.
20:25:43 <gwern> well, the original story is 'a bit lengthy'
20:25:59 <gwern> that's a pretty straight transcription and modification
20:26:11 <ddarius> gwern is playing Zen madlibs.
20:26:13 <dmwit> A student is power cycling his machine unsuccessfully.  Minsky says: "You cannot power cycle without understanding what is wrong!"  Minsky power cycles the machine.  It works.
20:26:31 <gwern> dmwit: wasn't it Tom Knight, since it was a Knight machine?
20:26:34 * dmwit likes the length of that one
20:26:46 <dmwit> gwern: Could be, I have a lossy memory system here.
20:26:51 * wagle SIGKILL's the sound-bite-only culture
20:26:56 <gwern> (ironically, I was just discussing ai koans like that tonight with another guy)
20:27:07 <jaj> gwern: the problem is that after that month you will not be able to write any language except haskell ;)
20:27:08 <gwern> (so it's kind of easy to recall)
20:27:35 <gwern> jaj: a great haskell programmer can write haskell in any language!
20:27:37 <sclv> A student asks mater wadler, what is the nature of a recursive type? Wadler replies: Mu.
20:27:49 <roconnor> ?
20:27:59 <gwern> http://www.catb.org/jargon/html/koans.html#id3141171 <-- yep, it was tom knight
20:28:00 <lambdabot> Title: Some AI Koans
20:28:01 <roconnor> I'm pretty sure a great haskell porgrammer can only write haskell in haskell
20:28:01 <shepheb> sclv++
20:28:06 <roconnor> ... maybe epigram
20:28:23 <vixey> I wish Epigram 2 was like
20:28:38 <vixey> ready
20:28:41 <gwern> A disciple of another sect once came to Drescher as he was eating his morning meal.
20:28:43 <gwern> I would like to give you this personality test, said the outsider, because I want you to be happy.
20:28:44 <sclv> s/mater/master
20:28:47 <gwern> Drescher took the paper that was offered him and put it into the toaster, saying: I wish the toaster to be happy, too.
20:28:48 <wagle> the adept scheme programmer can write haskell in fortran
20:29:28 <dolio> Yeah. It's not fair for Conor to keep taunting us with cool stuff Epigram 2 does when we can't use it.
20:29:37 <gwern> the effectual lisp programmer can write fortran in haskell!
20:29:59 <wagle> just do it
20:30:05 * shepheb read that as "effeminate"
20:30:06 <dmwit> Personally, my favorite AI koan is the Sussman-Minsky one.
20:30:13 <wolgo> I am going to try hard to become proficient at this
20:30:23 <sclv> A great haskell programmer can write epigram in haskell.
20:30:34 * gwern admires my own little joke on side-effects and 'effectual'
20:30:37 <sclv> s/great/derranged/ ?
20:30:37 <vixey> @src Extension
20:30:38 <lambdabot> Source not found.
20:30:57 <shepheb> Men named 'Oleg' can write Haskell in the type system.
20:31:06 <gwern> dmwit: that's a real one, actually. I managed to track down the original source for that one while referencing the ai koan wikipedia article
20:31:29 <gwern> dmwit: the actual incident is recorded in levy's _Hackers_. interesting huh?
20:31:36 <dmwit> Yeah!
20:31:52 <gwern> dmwit: https://secure.wikimedia.org/wikipedia/en/wiki/AI_koans#Uncarved_block
20:31:54 <lambdabot> http://tinyurl.com/6867aj
20:32:27 <shepheb> completely OT: is there a spell-checker for *nix that will ignore LaTeX?
20:32:58 <gwern> (although admittedly the punchline of the real story isn't as zenny as the ai koan, but I think it's interesting in its own right - ever since reading it, I've never been able to shake the feeling that resorting to randomness was often a failure of some sort)
20:33:09 <dmwit> right
20:34:51 <pjdelport> shepheb: aspell perhaps?
20:35:51 <wagle> haskell implements the Master Foo koan?
20:35:55 <SamB> gwern: so, are you going to write a deterministic nethack noww?
20:36:26 <SamB> gwern: also, are you asserting that real neural nets are not initialized essentially randomly?
20:36:36 <gwern> wagle: which one is that?
20:36:54 <gwern> SamB: neural darwinism seems to suggest that the initialization is more or less irrelevant
20:37:33 <gwern> not to mention, no, they aren't initialized randomly - infant brains learn much too rapidly and make too many assumptions for the genes to not have pre-wired the brain quite a bit
20:38:59 <SamB> truly, the embryonic bootstrapping is miraculous
20:39:17 <wagle> gwern, see https://secure.wikimedia.org/wikipedia/en/wiki/AI_koans
20:39:37 <gwern> wagle: oh, you mean 'Master Foo answered them thus: "Not incrementing, not decrementing  Equalizing!" whereupon both were enlightened.'
20:39:41 <SamB> which is to say, it is exceptionally well engineered
20:39:48 <gwern> I thought you might be talking about the rootless root ones
20:40:03 <gwern> wagle: I'm actually not sure where I got that one from, but I don't let it bother me
20:40:16 <gwern> I think it's pretty good; even if it isn't 'real', it deserves to be
20:41:44 <wolgo> BRB FBI
20:42:10 <thetallguy> You cannot power cycle a machine and expect it to solve anything without understand what is wrong.
20:42:30 <SamB> thetallguy: yes, I just love that
20:45:33 <gwern> I often think of Drescher and the toaster when psychology comes up
20:46:59 <vixey> hm :/
20:47:27 <vixey> trying to simplify import Language.Haskell.Syntax down to Var/Lam/Case/Constructor/App is a bit tricky
20:47:32 <vixey> hey adu
20:47:47 <adu> hi
20:47:58 <vixey> looks like I need to gensym and all this other stuff
20:48:18 <vixey> has anyone done this before and has code around?
20:48:35 <adu> vixey: are you working on the GHC API?
20:49:39 <vixey> adu: no
20:49:40 <SamB> it looks like vixey is trying to compile Haskell to a slightly extended -calculus
20:49:43 <vixey> I was thinking about rewriting this ( http://hpaste.org/7806 ) to use Language.Haskell and give it a type system and so on
20:50:04 <sclv> gwern: http://fmapfixreturn.wordpress.com/2008/05/21/some-concepts-behind-hvac/#comment-94
20:50:05 <lambdabot> http://tinyurl.com/56gpkg
20:50:13 <sclv> new hvac bits ^^
20:50:25 <vixey> :t fmap fix return
20:50:26 <lambdabot> forall a. a -> a
20:50:45 <shepheb> vixey: brain asplosion ahead. fmap fix return == id
20:50:51 <adu> vixey: is this for TH or the GHC API?
20:50:59 <bd_> hmmm
20:51:05 <vixey> adu: What do you mean
20:51:13 <adu> template haskell?
20:51:22 <vixey> I'm not using that
20:51:36 <bd_> shepheb: that's using return as reader :: Reader (Reader x x) (Reader x x) ... ?
20:51:44 <bd_> return :: *
20:52:00 <bd_> hmm
20:52:02 <bd_> not sure
20:52:07 <shepheb> I believe exactly which functor is involved doesn't matter
20:52:17 <pizza_> is there a canonical "Learning Haskell" book?
20:52:19 <bd_> o_O
20:52:25 <vixey> shepheb: it's not always ((->)e) ?
20:52:26 <wagle> hvac isnt "heating, ventilating, and air conditioning"?
20:52:34 <SamB> @type const
20:52:34 <wagle> 8)
20:52:35 <lambdabot> forall a b. a -> b -> a
20:52:36 <vixey> :t ?f fix return
20:52:38 <lambdabot> forall t a a1 (m :: * -> *). (Monad m, ?f::((a -> a) -> a) -> (a1 -> m a1) -> t) => t
20:52:39 <SamB> @type return
20:52:40 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
20:52:44 <vixey> :t fmap
20:52:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:52:58 * vixey tries to unify (a -> b) -> f a -> f b with ((a -> a) -> a) -> (a1 -> m a1) -> t
20:53:04 <vixey> huh .......... ?
20:53:16 <vixey> that makes no sense :D
20:53:26 <bd_> fmap fix :: f (a -> a) -> f a...
20:53:35 <dmwit> vixey: You can do it...
20:53:43 <SamB> :t fmap fix
20:53:44 <vixey> how do you get f b = t
20:53:44 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> a) -> f a
20:53:46 <bd_> wait, that means return :: Monad m => a -> m a  means a = m a?
20:53:55 <bd_> Wouldn't that trip an occurs check?
20:53:58 <bd_> :t fmap fix return
20:54:00 <lambdabot> forall a. a -> a
20:54:03 <bd_> mmm
20:54:09 <vixey> :t fmap fix ?f
20:54:11 <lambdabot> forall a (f :: * -> *). (Functor f, ?f::f (a -> a)) => f a
20:54:31 <bd_> ?f  ?
20:54:32 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq farber figlet figlet' flush foldoc forecast forget fortune fptools free freshname ft . ? @ bf v
20:54:35 <bd_> :t fmap fix
20:54:37 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> a) -> f a
20:54:44 <vixey> adu: Maybe I should just invent some new syntax or something
20:55:04 <sclv> :t fix const
20:55:06 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
20:55:06 <lambdabot>     Probable cause: `const' is applied to too few arguments
20:55:06 <lambdabot>     In the first argument of `fix', namely `const'
20:55:06 * bd_ lets the monad and functor be Reader to see what happens
20:55:12 <dmwit> sclv: Close.
20:55:32 <dmwit> Somebody (mauke?) posed "fmap fix return" as a puzzle on #xmonad the other day, I guess it found its way here...? =P
20:55:44 <sclv> dmwit: its the name of my blog...
20:55:48 <dmwit> ah
20:55:48 <bd_> aaaah!
20:55:52 <bd_> Aha!
20:55:57 <dmwit> bd_: =)
20:56:00 <dmwit> Sneaky, isn't it?
20:56:02 <pizza_> @book
20:56:02 <sclv> I just forget the easy way to explain what it does.
20:56:02 <lambdabot> Unknown command, try @list
20:56:03 <bd_> neat
20:56:04 <SamB> we really need a good way of visualizing typing derivations!
20:56:12 <dmwit> sclv: fmap = (.)
20:56:20 <SamB> including nice visual notation & tool
20:56:29 <dmwit> sclv: i.e. it's fix . const, not fix const.
20:56:32 <bd_> dmwit: tricky, that is
20:56:34 <sclv> ah.
20:56:46 <sclv> but that would have given the whole game away!
20:56:52 <vixey> :t fix . const
20:56:54 <lambdabot> forall a. a -> a
20:57:10 <SamB> @pl fmap fix return
20:57:10 <lambdabot> fmap fix return
20:58:16 <SamB> woah
20:58:23 <SamB> an intercalate symbol too?
20:58:25 <pjdelport> @pl pure fix <*> pure
20:58:25 <lambdabot> pure fix <*> pure
20:58:44 <sclv> ?ty \x -> fix (const x)
20:58:46 <lambdabot> forall a. a -> a
20:58:52 <sclv> that's maybe clearer.
20:58:58 <vixey> :t fix . return
20:59:00 <lambdabot> forall a. a -> a
20:59:31 <sclv> pjdelport: you want fix <$> pure
20:59:49 <pjdelport> sclv: s/want/could be using/
21:02:25 <vixey> f (Foo bar baz) = ...
21:02:38 <vixey> f x = case x of (Foo bar baz) -> ...
21:02:57 <vixey> problem is where does the name 'x' come from
21:03:23 <dmwit> What?
21:04:00 <wolgo> hey
21:04:05 <dmwit> Hey!
21:04:06 <vixey> if I am desugaring like this, I think I'll have to complicate my AST or something
21:04:12 * SamB wonders what these are good for: 
21:04:34 <vixey> SamB: drop it off the top of your staircase
21:04:48 <SamB> vixey: it's NOT a slinky!
21:05:13 <dmwit> It's for when you *really* don't know the relationship between two numbers.
21:05:23 <SamB> there does not seem to be a slinky character in Unicode (probably for trademark reasons?)
21:05:30 <vixey> e^pi  pi^e
21:06:06 <vixey> > let e = exp 1 in (e^pi) :: CReal > pi^e
21:06:06 <lambdabot>  Parse error at ">" (column 34)
21:06:07 <wolgo> So a hangman game should have these things: A file to get words from, a dictionary (/usr/share/dict), a function to update the screen and draw things on bad guesses, a function for getting input and comparing it to the String, and a way to track the number of times you have won and lost
21:06:12 <vixey> > let e = exp 1 in (e^pi :: CReal) > pi^e
21:06:13 <lambdabot>  Add a type signature
21:06:15 <wolgo> what else does it need?
21:06:16 <vixey> hmm
21:06:17 <edwardk> samb: thats what the user extension area is for ;)
21:06:38 <pjdelport> SamB: i guess it states that an ordering exists
21:07:07 <dmwit> wolgo: Having both a file to get words from and a dictionary seem redundant.
21:07:23 <wolgo> dmwit: that is poor grammar on my part
21:07:25 <SamB> oooh
21:07:32 <vixey> wolgo: type GameState = (String,Integer,[Char], ...) -- secret word, num guesses, guesses..
21:07:36 <SamB> what shall we use the communism operator for?
21:07:45 <SamB> 
21:07:58 <wolgo> You said state
21:07:58 <vixey> SamB: linear types
21:08:03 <dmwit> s/delete//
21:08:10 <sclv> wolgo: try writing it just with a command line interface first, then worry about drawing the hangman later.
21:08:22 <wolgo> good idea
21:08:29 <wolgo> that will be in 0.2
21:08:31 <wolgo> hahah
21:08:42 <dmwit> Gotta pay more for the GUI. ;-)
21:09:16 <vixey> I don't think there's any sensible way I can turn Language.Haskell into my AST actually
21:09:22 <SamB> ... why do they have the gay/bisexual symbols in the same block as recycling symbols?
21:09:25 <sclv> well, you'll want either a curses style thing or a windowing Gtk thing and either way its sort of a separate notion...
21:09:46 <sclv> SamB: is it the "hippie" block?
21:10:44 <wolgo> one more question before I write Haskman:
21:10:45 <wolgo> do a <- [1,2,3]
21:10:45 <wolgo>    b <- [3,4,5]
21:10:45 <wolgo>    return (a+b)
21:10:52 <wolgo> that is a n+k form right?
21:10:56 <vixey> no it's not
21:11:03 <sclv>  would be great for calling worker functions
21:11:06 <pjdelport> wolgo: that's just do-notation
21:11:29 <dolio> 'do (a + 1) <- [1,2,3]' would be an n+k pattern.
21:11:30 <wolgo> Ok so that must mean that n+k forms are of the form let bob (n+k) = some jobs
21:11:46 <wolgo> ahh I see
21:11:48 <SamB> sclv:  -- hard to say!
21:11:56 <vixey> if (n+k) works but (((+) n) k) doesn't you know it's not a pattern
21:12:19 <pjdelport>  = unsafePerformIO
21:12:29 <dolio> Hah, nice.
21:12:49 <vixey>  = unsafeLaunchNuclearMissles
21:13:06 <sclv>  = catch
21:13:37 <dolio> Scheme should adopt that.
21:13:40 <shepheb> for the unicode-impaired, are those actually ?s, or unicode?
21:13:43 <SamB> ?
21:13:47 <dolio> (set foo bar)
21:13:50 <SamB> shepheb: unicode!
21:13:54 <vixey> lol
21:14:06 * shepheb curses his unicode-hating screen session
21:14:29 <sclv> is one of those things a klingon symbol!!?
21:14:30 <gwern> sclv: looks much better to me
21:14:38 <vixey> (define  call-with-current-continuation)
21:14:44 <gwern> shepheb: can't you do defutf8 in .screenrc or something?
21:15:26 <sclv>  = exit (1)
21:15:30 * SamB just has his locale set properly
21:15:37 <gwern> is that a yin-yang?
21:15:39 <sclv> your program dies for its sins.
21:15:41 <vixey> yes
21:15:50 <sclv> oh wait, that's an ankh, not a cross..
21:15:55 <shepheb> bah, have to use screen -U on start. I will return.
21:16:03 <SamB> you know, this would all work better if Haskell had Agda syntax...
21:16:26 <sclv> Hagda: same types, more sugar.
21:16:28 <dolio> I'm eager for the improved Agda syntax.
21:16:28 <wolgo> I wonder why they do not have haskell for cygwin
21:16:30 <dolio> With sections.
21:16:31 <SamB> oh, look, a Java character!
21:16:33 <SamB> 
21:16:50 <gwern> hagda? is that supposed to be an uglified haskell?
21:16:52 <sclv> It looks like a birthday cake to me.
21:17:27 <SamB> gwern: well, I'm not sure I would want the treatment of brackety things...
21:18:10 <mxc> what does 'pattern match(es) are overlapped' mean?
21:18:28 <gwern> ironically, the java symbol here looks nothing so much as like a cartoon turd, steaming even
21:18:41 <dolio> Two of your patterns probably match the same thing.
21:18:55 <dolio> Or more.
21:18:59 <thetallguy> mxc: the set of matches intersect
21:19:19 <mxc> ah, accidentally undo'ed something and had two functiosn with the smae name
21:19:39 <vixey> (x) = x
21:19:42 <mxc> didn't see it because i was looking for some kind of more explicit pattern matching
21:19:51 <vixey> (_) :: forall a, a -> a
21:20:24 <sclv> btw, gwern, glad you like the new syntax. i'm not a huge fan of it, but I figure if i want anyone to actually adopt this, then I might as well bow to sentiment. :-)
21:21:06 <Dzlk> I suppose "matches are overlapped" is (sometimes) Haskell's way of saying "this function has type int but is here used with type int". :)
21:21:49 <SamB> gwern: that wasn't REALLY a java symbol
21:21:57 <vixey> Dzlk: f 1 = 0 ; f 1 = 1 ; f (n+2) = ... I might have written accidentally
21:21:57 <SamB> I just thought the steam looked kinda similar
21:22:02 <dolio> It was a steaming hole.
21:22:15 <vixey> Dzlk: so it's usually an indicator of a mistake
21:22:22 <dolio> You have to blow it up to tell the difference, really.
21:22:28 <dolio> At least, it's hard at my font size.
21:23:23 <vixey> \_->_ :: forall a b, a -> b
21:23:24 <vixey> \ x -> y = f where f x = y
21:23:38 <vixey> wait that doesn't work....
21:24:01 <mxc> can you pattern match on a type?  as in, say i have a function foo :: (Show a) => a -> [Char] , could I have it behave differently if the arguemnt is a [Char] as upposed to some other type?
21:24:26 <mxc> like foo (a::[Char]) = blah;  foo b = blah2
21:24:43 <wolgo> I have a question about ghc. Why does it take so long to compile a file with "putStrln "test"" ?
21:24:54 <wolgo> I know that is kind of vague
21:25:04 <edwardk> mxc: the short answer is you shouldn't, there is a notion called parametricity that gets violated. the long answer is there exist unsafe hacks ;)
21:25:20 <vixey> mxc: define each foo in a different instance of a typeclass
21:25:27 <wolgo> Does it get compiled to bytecode?
21:25:33 <wolgo> like java or python?
21:25:42 <pjdelport> wolgo: ghc compiles to machine code
21:25:51 <edwardk> mxc: if you have a small set of potential a's or they have a regular structure you can use typeclasses
21:26:07 <wolgo> oh so it is like gcc
21:26:12 <pjdelport> yeah
21:26:14 <edwardk> if you want to support 'every type a' but specially handle chars, you're probably doing something a little wonky
21:26:21 <wolgo> Ok
21:26:29 <pjdelport> (in fact, ghc can use gcc as a backend)
21:26:47 <pjdelport> wolgo: the compilation time depends on how much optimization you have enabled
21:27:20 <pjdelport> wolgo: so if you want to compile quicker, you can remove -O/-O2
21:28:18 <dolio> Compile time shouldn't be too bad even with -O2.
21:28:31 <dolio> Unless you're doing something with lots of inlining and specialization potential.
21:30:12 <jaj> is it possible to link everything statically using ghc, including libgmp?
21:32:02 <dibblego> can (liftM2 (,) x y) generalise?
21:32:17 <dibblego> @pl liftM2 (,) x y
21:32:17 <lambdabot> liftM2 (,) x y
21:32:29 <dolio> liftA2 (,) x y?
21:33:00 <vixey> > liftM2 (,) "bx" "feou"
21:33:01 <lambdabot>  [('b','f'),('b','e'),('b','o'),('b','u'),('x','f'),('x','e'),('x','o'),('x',...
21:33:10 <dmwit> dibblego: Generalize how?
21:33:24 <dibblego> dmwit, dunno, just feels like it could; I'll think about it some more
21:33:44 <dmwit> dibblego: You might be interested in this generalization:
21:33:51 <dmwit> return (,) `ap` x `ap` y
21:34:04 <dibblego> ah yes, the applicative functor
21:34:16 <dmwit> No Applicative here, just plain Monad.
21:34:19 <dibblego> right
21:34:23 <dmwit> But yeah.
21:34:27 <dibblego> thanks
21:34:52 <dibblego> ?type \x y -> pure (,) <*> x <*> y
21:34:54 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a -> f a1 -> f (a, a1)
21:35:06 <dolio> @type liftA2 (,)
21:35:08 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
21:35:12 <dibblego> right, thanks
21:53:27 <wolgo> > :t <-
21:53:27 <lambdabot>  Parse error at "<-" (column 4)
21:53:45 <wolgo> what is <-? It behaves like an assignment operator
21:53:47 <bos> any ruby programmers around?
21:54:11 * SamB thinks he found klingon: 
21:54:11 <bos> it's a special piece of syntax.
21:54:15 <vixey> wolgo: x <- y ; z = y >>= \x -> z
21:54:20 <bos> and yes, it behaves like an assignment operator.
21:54:20 <vixey> wolgo: sorry do x <- y ; z = y >>= \x -> z
21:54:50 <wolgo> so it has the type IO?
21:55:11 <bos> @undo a <- y
21:55:11 <lambdabot>  Parse error at "<-" (column 3)
21:55:26 <bos> wolgo: no, it's more general.
21:55:41 <wolgo> Oh ok
21:55:46 <vixey> wolgo: it doesn't have any type
21:55:48 <wolgo> I guess I will worry about it later.
21:55:51 <wolgo> oh ok
21:55:56 <wolgo> It just is.
21:57:24 <thetallguy> probably better to think of it as a specialized form of 'let', rather than assignment
21:58:46 <pjdelport> wolgo: it's part of do-notation
21:59:22 * SamB thinks he also found elvish: 
21:59:42 <bos> SamB: please.
21:59:49 <SamB> bos: sorry
21:59:54 <Pseudonym> Stop trying to hack my terminal.
22:00:19 <SamB> Pseudonym: what, your terminal doesn't do elvish?
22:00:27 <bos> is a ruby block a first-class value?
22:00:27 <Pseudonym> Take it #haskell-elv
22:00:41 <cjb> Pseudonym: ah, an Eterm user?  :)
22:01:01 <cjb> (Eterm had an exploit in the ANSI handler that was, I believe, exploitable through IRC.)
22:01:15 <Cale> wolgo: It's part of the syntax of various constructions -- the one you're looking at is probably the one which is part of the syntax of do-notation
22:01:18 <bos> i realise that's not exactly a haskell question, but i'm thinking about blocks in comparison with with-style monadic functions in haskell.
22:01:19 <thetallguy> bos: I think so.  I was never able to get an answer I fully understood.
22:01:33 <Pseudonym> cjb: vt100, actually
22:01:39 <Cale> wolgo: do v <- x; <stmts> translates into x >>= \v -> do <stmts>
22:01:39 <Pseudonym> Well, emulated.
22:01:50 <thetallguy> bos: you can certainly use blocks like lambdas
22:01:51 <SamB> Pseudonym: that ... says nothing
22:01:56 <cjb> Pseudonym: wow, even lamer
22:02:12 * Pseudonym is firewalled off from IRC, but not ssh
22:02:15 <Cale> wolgo: Where for the IO monad specifically, (>>=) :: IO a -> (a -> IO b) -> IO b
22:02:16 <bos> thetallguy: as in, you can define a block in one place, and then pass it around and use it elsewhere?
22:02:18 <pjdelport> bos: blocks aren't first-class
22:02:33 <bos> pjdelport: ok, thanks.
22:02:45 <thetallguy> bos: didn't pursue it enough to find out
22:02:51 <Pseudonym> And I don't care about lameness.  This is IRC.  How much more lame can you get?
22:03:21 <bos> Pseudonym: furfic-oriented IRC?
22:03:21 <wagle> i know someone who was in the navy when the cold-war was still happening.  he once translated the necronomicon into elvish, put it in a trash bag, and threw the trashbag overboard when a russian ship wass shadowing them
22:03:28 <thetallguy> bos: I was really just being polite.
22:03:42 <thetallguy> giving equal time, so to speak
22:03:43 <pjdelport> bos: you can pass them around though, in several ways
22:03:44 <bos> thetallguy: heh
22:03:46 <Pseudonym> True.  That's lame.
22:04:04 <bos> pjdelport: ok, now i'm confused.
22:04:19 <SamB> wagle: any word on what the russians did when they found it?
22:04:25 <thetallguy> bos: but the descriptions were so fuzzy, I gave up
22:04:34 <bos> thetallguy: are you still doing haskell stuff, now that you've moved on from, um, that distro shop?
22:04:38 <pjdelport> bos: there are other limitations, though
22:04:45 <thetallguy> bos: yup
22:04:51 <wagle> none i know of..  maybe if i tell the story enough, i will run across the russian who picked it up..  8)
22:04:56 <thetallguy> see HCAR/SeeReason
22:05:18 <thetallguy> in fact, today we got a cabal -> debian function going
22:06:03 <bos> oh, so you can create a .deb from a cabal description?
22:06:07 <pjdelport> bos: generally, blocks are passed to calls as a special kind of implicit parameter
22:06:18 <thetallguy> and  we're close to having debs for the new happs-hsp stuff, so we can deploy on our server consistently
22:06:25 <pjdelport> which are called with the "yield" keyword
22:06:26 <thetallguy> bos: yes.
22:06:27 <sclv> oh right.. they can only be in the final position, right?
22:06:43 <bos> nice. i have something similar for rpms.
22:06:54 <bos> pjdelport: that sounds manky and ad hoc.
22:06:57 <pjdelport> bos: to pass them around as an object, you have to wrap them in a Proc object
22:06:57 <thetallguy> bos: I know.  I swiped it. ;-)
22:07:29 <pjdelport> bos: which you call differently to normal methods:  f.call ... or f[...]
22:07:32 <sclv> as I recall there are um, three, I think types of closure-ish things in ruby? 1.9 is supposed to clean it up I think.
22:07:37 <bos> thetallguy: we should find some time to swipe common code and send it upstream to dcoutts.
22:07:46 <thetallguy> bos: but we have a package autobuilder that already does  DebSrc -> DebBin
22:08:08 <thetallguy> bos: so ours just does  Cabal -> DebSrc
22:08:10 <pjdelport> (the [] are literal:  the object overloads [] to approximate normal calling syntax)
22:08:22 <bos> thetallguy: sure.
22:08:32 <bos> thetallguy: will you be at ICFP?
22:08:42 <thetallguy> bos: I expect so
22:09:11 <bos> cool. maybe we can have a mini cabal hackathon or some such thing. if the beer doesn't distract.
22:09:18 <pjdelport> bos: if you want the whole story, check out http://innig.net/software/ruby/closures-in-ruby.rb
22:09:28 <hpaste>  morrow pasted "fast (tail recursive) csv parser (with String!!)" at http://hpaste.org/7823
22:09:35 <bos> pjdelport: thanks. sounds like i need a strong stomach.
22:09:37 <thetallguy> bos: David wrote something to talk to ghc-pkg to find bundled packages
22:09:50 <pjdelport> bos: yes :)
22:10:07 <bos> thetallguy: that's tricky to do. you can't tell bundled packages from ones that were installed later.
22:10:23 <bos> and debian has split extralibs into its component bits for a while.
22:10:29 <thetallguy> bos: Hmm...  I'll take a look.
22:11:18 <bos> thetallguy: i resorted to building a list of packages and versions that i "knew" should be present with a given fedora version of ghc. horribly hacky, but at least reliable.
22:12:23 <thetallguy> bos: yeah we saw.  That's all you can do if you can't get the info reliably.
22:12:57 <thetallguy> bos: strangely, Debian tags essential packages, but all their tools just use a list
22:13:00 <bos> thetallguy: the other thing you could do is parse the output of dpkg -L ghc or such. but again, ick.
22:13:13 <thetallguy> yeah
22:14:57 <sclv> oh wau! 7 closureish things! mindblown.
22:17:20 <pjdelport> sclv: and none of them are first-class :)
22:18:01 <bos> @pl \m -> return (quux, foo (bar m))
22:18:01 <lambdabot> return . (,) quux . foo . bar
22:19:28 <thetallguy> bos: yeah, I see, I expect that's a bug I'll have to work through tomorrow.
22:19:35 * sclv wonders about an esolang where *nothing* is first class...
22:19:54 <bos> thetallguy: i don't mean to be making work for you :-)
22:20:33 <thetallguy> Fixing things isn't work.  Leaving them broken makes for bad work.
22:22:29 <thetallguy> bos: it will work if I run it in a chroot. ;-0)
22:24:08 <thetallguy> anyone made unionfs bindings?
22:48:44 <augur> :o
22:50:14 <augur> hullo helloo!
22:51:57 <hpaste>  (anonymous) pasted "Type mismatches" at http://hpaste.org/7824
22:52:09 <wolgo> oops
22:52:12 <wolgo> I pasted that
22:52:26 <wolgo> brb
22:53:48 <dolio> Bool won't match IO a.
22:53:58 <bd_> dolio: Bool won't match Monad m => m a, in general
22:54:13 <dolio> Right.
22:55:06 <wolgo> ok so I need to work this out without a do
22:55:40 <hpaste>  bd_ annotated "Type mismatches" with "@wolgo" at http://hpaste.org/7824#a1
22:56:45 <wolgo> Oh I see
22:56:58 <wolgo> I did not know I could use a function in my case statement
22:57:03 <wolgo> OH YEAH!
22:57:13 <wolgo> any valid haskell expression can go there
22:57:20 <wolgo> Thanks guys
22:57:36 <bd_> :t null
22:57:39 <lambdabot> forall a. [a] -> Bool
22:57:44 <bd_> wolgo: but wait, there's more!
22:57:52 <wolgo> haah
22:57:59 <wolgo> OXYCLEAN!
22:58:14 <hpaste>  bd_ annotated "Type mismatches" with "one-liner!" at http://hpaste.org/7824#a2
22:58:31 * bd_ tries to see if he can make that pointfree as well
22:59:06 <bd_> er
22:59:26 <hpaste>  bd_ annotated "Type mismatches" with "fixed one-liner" at http://hpaste.org/7824#a3
23:00:39 <hpaste>  bd_ annotated "Type mismatches" with "going too far" at http://hpaste.org/7824#a4
23:01:21 <bd_> understanding how #a4 works may be a good exercise... but going that far to avoid variables is not generally recommended :)
23:01:29 <bd_> Removing the string variable's easy enough though
23:02:06 <hpaste>  bd_ annotated "Type mismatches" with "predicate constructor style?" at http://hpaste.org/7824#a5
23:03:06 <dolio> Mmm, light on points.
23:03:26 <Cale> bd_: That last one is ideal, I think.
23:03:50 <Cale> I'd have called the parameter p myself though ;)
23:04:05 <bd_> I didn't change the name wolgo picked :)
23:04:13 <Cale> oh, but look what this is :)
23:04:18 <bd_> I'd probably have just gone with f myself
23:04:29 <bd_> wait, don't tell me
23:04:36 <bd_> :t \p -> not . null . filter p
23:04:38 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
23:04:43 <bd_> @hoogle (a -> Bool) -> [a] -> Bool
23:04:45 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
23:04:45 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
23:04:45 <lambdabot> Data.List.any :: (a -> Bool) -> [a] -> Bool
23:04:47 <ziman> isn't it sufficient to write charComp = any ?
23:04:50 <bd_> oho
23:04:54 <Cale> exactly
23:05:04 <wolgo> what the hell haha
23:05:13 <wolgo> I have quite a ways to go
23:05:27 <geezusfreeek> wolgo: hand in there!
23:05:29 <geezusfreeek> err
23:05:31 <geezusfreeek> *hang
23:05:31 <bd_> hand?
23:05:32 <geezusfreeek> :P
23:05:44 <Cale> I don't think we're going to do better than 3 characters for this function ;)
23:05:46 <wolgo> in 10 mins you have written 5 solutions to what was taking me about 30 minutes
23:05:47 <geezusfreeek> man that didn't come out right at all
23:06:29 <bd_> wolgo: At least you thought to use filter, rather than writing a C for-loop in Haskell - you're on the right track :)
23:06:46 <wolgo> yeah I felt pretty l33t for that
23:06:56 * wolgo realizes his awesomeness
23:07:43 <wolgo> I am trying to make hangman using what I have learned.
23:08:56 <wolgo> Thinking in the functional style is different. Although as someone who has written a small amount of code it isn't too new since I do not have enough experience to think in anyway
23:09:00 <wolgo> err
23:09:21 <wolgo> "Think according to some dogma I was exposed to"
23:09:27 <wolgo> that is a better way of saying it
23:09:49 <dolio> Good. Now we can collect evidence that functional programming is actually easy. :)
23:10:17 <hpaste>  bd_ annotated "Type mismatches" with "C-style" at http://hpaste.org/7824#a6
23:10:46 <dolio> Hah, nice.
23:10:46 <wolgo> so not . null . filter bool composes three functions, null to filter and not negates the composition of (null . filter bool)?
23:10:49 <geezusfreeek> wolgo: saying that has now turned you into an experiment :P
23:10:57 <dolio> callCC for the non-local return.
23:11:17 <wolgo> geezusfreeek saying what?
23:11:26 <wolgo> I am not interested in C
23:11:30 <bd_> wolgo: Yep. . is sort of line the unix | backwards
23:11:32 <geezusfreeek> that you are relatively new to programming in general
23:11:48 <bd_> like*
23:11:50 <wolgo> oh
23:11:51 <wolgo> I am
23:12:07 <wolgo> I am only going to program in Haskell for the next 6 months
23:12:12 <bd_> wolgo: to be specific, f1 . f2 = \a -> f1 (f2 a)
23:12:30 <wolgo> a is a lambda function right?
23:12:32 <wolgo> \a
23:12:34 <wolgo> I mean
23:12:45 <geezusfreeek> most of the time new haskell programmers have imperative backgrounds and haskell seems to gain a reputation (unfair, in my opinion) of being difficult (because it is so different)
23:12:50 <bd_> \a -> (...)  makes a function, which takes some argument, calls it a, and evaluates the (...)
23:12:50 <dibblego> "given an a, ..."
23:13:12 <bd_> so, f1 . f2 becomes, "Take an argument a, then evaluate f1 (f2 a)"
23:13:24 <bd_> thus, (f1 . f2) something = f1 (f2 something)
23:13:35 <wolgo> right
23:13:36 <ziman> @src (.)
23:13:36 <lambdabot> (f . g) x = f (g x)
23:13:36 <lambdabot> -- In lambdabot, it's been generalised to:
23:13:36 <lambdabot> (.) = fmap
23:14:19 <dolio> You'll program in Haskell for more than 6 months. You won't be able to quit.
23:14:22 <dolio> You'll be hooked.
23:14:26 <wolgo> so f . g . h . i . j 3 means f(g(h(i(j3)))
23:14:36 <bd_> wolgo: the precedence is a bit different
23:14:46 <jaj> geezusfreeek: yeah when have an imperative background learning haskell involves forgetting everything you know so far and learning from scratch :)
23:14:52 <bd_> wolgo: (f . g . h . i . j) 3  is f (g (h (i (j 3))))
23:14:54 <dfranke> dolio: actually I think it takes somethnig more like a year for addiction to take hold.
23:15:07 <bd_> wolgo: f . g . h . i . j 3 is \a -> f (g (h (i (j 3 a))))
23:15:18 <wolgo> ohhhhhhhhhh
23:15:27 <bd_> because it becomes [...] . i . (j 3)
23:15:30 <geezusfreeek> jaj: i had a very strong imperative background when i first started learning haskell... while it was definitely very different, i still think its reputation is unfair
23:15:35 <dfranke> that's about how long you have to spend learning it before you can use it more effectively than the next-most-powerful-but-easier-to-learn language.
23:15:49 <wolgo> I see
23:16:00 <wolgo> > :t \a
23:16:01 <lambdabot>  Parse error at "\a" (column 4)
23:16:09 <wolgo> ...
23:16:11 <bd_> wolgo: the -> (expression) is needed
23:16:14 <bd_> :t \a -> a
23:16:16 <lambdabot> forall t. t -> t
23:16:31 <geezusfreeek> @djinn a -> a
23:16:31 <lambdabot> f a = a
23:16:32 <bd_> simplest function you can write
23:16:43 <bd_> @. t djinn a -> a
23:16:44 <lambdabot> Plugin `compose' failed with: Unknown command: "t"
23:16:46 <geezusfreeek> @pl f a = a
23:16:47 <lambdabot> f = id
23:16:49 <bd_> @. type djinn a -> a
23:16:51 <lambdabot> parse error on input `='
23:16:55 <bd_> :(
23:17:18 <geezusfreeek> denied
23:17:20 <ski_> @. djinn type \a -> a
23:17:22 <lambdabot> f a = a
23:17:38 <bd_> wolgo: anyway, \ [pattern] -> [expression] is built-in grammar, so you can't ask its type any more than you could ask the type of :: :)
23:17:51 <geezusfreeek> @. pl @. djinn type \a -> a
23:17:51 <lambdabot> Plugin `compose' failed with: Unknown command: "@."
23:17:54 <geezusfreeek> aw
23:17:59 <geezusfreeek> parens maybe?
23:18:02 <bd_> @. pl . djinn type \a -> a
23:18:04 <lambdabot> f = id
23:18:09 <geezusfreeek> oh, . composition
23:18:15 <ziman> metacomposition :)
23:18:39 <bd_> polish notation composition?
23:18:40 <ski_> `@' is just the initial prefix for the main command, to make lambdabot recognize it
23:18:42 <geezusfreeek> i didn't even know the associativity, let alone that it had its own composition operator as well
23:18:54 <bd_> geezusfreeek: it's prefix notation
23:19:05 <bd_> so, no associativity involved
23:19:25 <geezusfreeek> well, yeah, now i get it, and that it has its own composition operator which is not the same as the command
23:19:50 <geezusfreeek> crap why is my toe bleeding all over the place? brb
23:26:34 <wolgo> is there a difference between a quicksort and a qsort?
23:26:43 <wolgo> wikipedia here I come!
23:26:50 <ivanm> wolgo: the name? :p
23:26:51 <bd_> quicksort is a specific sorting algorithm
23:27:10 <bd_> qsort() is a function in the C library which usually implements quicksort (although it could implement something else instead)
23:27:25 <wolgo> hahah
23:27:28 <wolgo> one line
23:27:50 <wolgo> I saw an example in c that was like 35 lines
23:27:54 <wolgo> or something like that
23:28:04 <wolgo> things are pretty succinct
23:28:10 <bd_> oh dear, has wolgo found the horribly flawed quicksort example everyone uses for showing off haskell?
23:28:12 <geezusfreeek> yes quicksort in haskell is cute
23:28:23 <vixey> @@ @run @run fun "fun \"fun\" :: Expr"::Expr
23:28:25 <lambdabot>  fun
23:28:36 <wolgo> hahaha
23:28:44 <wolgo> I have a beginning haskell book
23:28:48 <wolgo> it is in there
23:28:50 <bd_> @src sort
23:28:51 <lambdabot> sort = sortBy compare
23:28:53 <bd_> @src sortBy
23:28:54 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
23:29:03 <bd_> @src insertBy
23:29:04 <lambdabot> insertBy _   x [] = [x]
23:29:04 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
23:29:04 <lambdabot>                                  GT -> y : insertBy cmp x ys'
23:29:04 <lambdabot>                                  _  -> x : ys
23:29:47 <geezusfreeek> that is the haskell98 definition
23:29:52 <geezusfreeek> i think ghc uses mergesort
23:30:05 <bd_> it does
23:30:12 <bd_> but that's too long for @src :)
23:31:59 <vixey> @@ @@ @run (\x -> fun (x++" "++x++" @quote")::Expr) "@@"
23:32:00 <lambdabot> Plugin `compose' failed with: Unknown command: ""
23:32:01 <vixey> @@ @@ @run (\x -> fun (x++" "++x++" @quote")::Expr) "@@"
23:32:02 <lambdabot> Plugin `compose' failed with: Unknown command: ""
23:32:03 <vixey> @@ @@ @run (\x -> fun (x++" "++x++" @quote")::Expr) "@@"
23:32:04 <lambdabot>   adam says: Lisp is like Ruby with an ugly syntax, impossible stdlib, and some macros that don't compensate for above shortcomings
23:32:35 <geezusfreeek> huh, i don't think i like that quote
23:32:40 <geezusfreeek> and i use ruby more than lisp!
23:37:56 <augur> ruby has no syntax, you code in parse trees. :P
23:38:03 <augur> erm, not ruby, lisp. lol
23:38:31 <lament> almost
23:38:48 <augur> which is partially why it's so powerful: you can manipulate parse trees from within the code
23:44:39 <wolgo> you know wikipedia only presents an imperative example of the quicksort implementation
23:44:45 <roconnor> > 200000 * 0.01 / 12
23:44:47 <lambdabot>  166.66666666666666
23:44:56 <wolgo> That is not NPOV :P
23:44:56 <roconnor> > 200000 * 0.02 / 12
23:44:57 <lambdabot>  333.3333333333333
23:45:13 <roconnor> > 200000 * 0.05 / 12
23:45:14 <lambdabot>  833.3333333333334
23:45:30 <Heffalump> wolgo: the elegant Haskell one isn't quicksort
23:45:41 <Heffalump> because it doesn't do in-place updates
23:45:51 <vixey> they only have recursive versions of quicksort
23:46:02 <vixey> I would much rather see the original implementation
23:46:40 <Heffalump> I didn't realise that wasn't recursive. How did it work?
23:47:10 <vixey> I have no idea but C.A.R. Hoare originally didn't use recursion, that's why it was so hard to program
23:47:11 <wolgo> Hey thanks for the help today.
23:47:16 <augur> er.. wolgo, there are haskell versions. o.o
23:47:27 <vixey> I've never been able to find his code though, It's probably lost
23:47:58 <augur> maybe not in the quicksort page itself, tho
23:48:02 <wolgo> http://en.wikipedia.org/wiki/Qsort
23:48:06 <wolgo> not on that page
23:48:13 <wolgo> not like it matters
23:48:23 <wolgo> I have a long way to go before I even begin to worry about that.
23:48:26 <wolgo> I just noticed it
23:48:45 <augur> well why dont you add the haskell versions of qsort?
23:48:46 <Heffalump> vixey: surely it's in his original paper?
23:48:49 <augur> it IS wikipedia afterall
23:49:04 <wolgo> I would have to figure out how to do it.
23:49:09 <vixey> Heffalump: no
23:49:12 <augur> uh
23:49:20 <augur> its quite simple and elegant in haskell, iinm
23:49:38 <wolgo> There is an example in this book that is one line
23:49:43 <wolgo> haha
23:49:49 <augur> qsort []     = []
23:49:50 <augur> qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs)
23:49:52 <augur> from the haskell wiki
23:50:36 <wolgo> oh ok
23:50:55 <wolgo> yeah that is the same thing I am seeing in  "Programming in Haskell"
23:51:02 <wolgo> why do all these guys use hugs?
23:51:06 <glguy> that example captures the spirit of quicksort
23:51:12 <augur> the haskell version is incredibly elegant in how it basically encapsulates the nature of qsort
23:51:12 <glguy> not necessarily the run time :)
23:51:24 <vixey> augur: I disagree
23:51:30 <augur> its like a text version of the visual patterns of the sort
23:51:30 <roconnor> treesort
23:51:48 <augur> vixey, why do you disagree?
23:52:22 <wolgo> man spiders creep me out
23:52:33 <augur> dude, ManSpiders creep me out too! :O
23:52:36 <vixey> augur: It's a nice bit of code but I think it's not quicksort in a few ways, like traversing the list twice rather than splitting it and this appending too
23:52:44 <wolgo> haha
23:52:44 <dibblego> wolgo, what about woman spiders? they're usually larger
23:53:05 <wolgo> I dont like large women.
23:53:09 <augur> traversing the list twice, i presume you mean the two filters?
23:53:21 <vixey> yes
23:53:46 <augur> that doesn't make it not quicksort, that just makes it a not-in-place quicksort
23:53:50 <wolgo> Time to watch NIGHT OF THE LIVING DEAD
23:53:58 <wolgo> Thanks for the help today guys.
23:53:59 <dmwit> You could traverse it once with partition.
23:54:01 <wolgo> I appreciate it.
23:54:06 <dmwit> But that still wouldn't make it quicksort, I think.
23:54:12 <wolgo> BRB MOVIE/SLEEP
23:54:26 <sjanssen> it is more of a tree sort than a quick sort
23:54:26 * wolgo|away waves
23:54:27 <ziman> nothing is in-place in haskell :)
23:54:29 <augur> the haskell version really is quicksort, it's just the _conceptual_ description of what quicksort is doing
23:54:32 <sjanssen> a deforested tree sort to be exact
23:54:34 <olsner> but that qsort only traverses twice unless the compiler can't optimize two parallell list traversals into one
23:54:50 <augur> the in-place q-sort algorithm does the exact same filtering only inplace
23:54:59 <sjanssen> olsner: I don't know any compilers that will make that traversal once
23:54:59 <augur> but the "semantics", if you will, are the same
23:55:12 <augur> everything sorted lower than an item, then the item, then everything sorted higher
23:55:37 <augur> and each of those two groups sorted the same
23:55:53 <olsner> sjanssen: neither do I... just trying to future-proof the discussion for future even smarter compilers :P
23:56:23 <sjanssen> anyway, I think using partition here is better style
23:56:42 <olsner> @djinn (a -> b) -> (a,a) -> (b,b)
23:56:42 <lambdabot> f a (b, _) = (a b, a b)
23:57:09 <sjanssen> qsort (x:xs) = qsort ls ++ x : qsort rs where (ls, rs) = partition (< x) xs
23:57:14 <olsner> hmm, but that's (a -> b) -> (a,c) -> (b,b)
23:57:42 <vixey> qsort' (x:xs) k = qsort' ls (x : qsort' rs k) where (ls, rs) = partition (< x) xs
23:57:47 <vixey> qsort list = qsort' list k
23:58:49 <vixey> :(
23:58:51 <vixey> qsort list = qsort' list [] *
23:59:08 <olsner> and qsort' [] = id
23:59:26 <sjanssen> nope, qsort' [] k = k
23:59:38 <sjanssen> sorry, have to be pedantic here :)
23:59:48 <vixey> I think we should use := in haskell
23:59:57 <sjanssen> for what?
