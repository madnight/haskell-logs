00:05:52 <solrize_> @seen cosmicray
00:26:27 <qebab> http://hpaste.org/7723 <- can anyone help me see how to make this tail recursive?
00:27:03 <solrize_> the last line has the wrong # of args?
00:27:05 <qebab> I *think* it should be simple, but I'm completely blocked
00:27:34 <qebab> yeah, I have no idea where that 1 came from (:
00:30:36 <solrize_> it's not completely obvious that the function can be written tail recursively while still doing the same computation
00:30:47 <solrize_> i.e. as opposed to calculating the same result a different way
00:31:12 <qebab> okay
00:31:13 <solrize_> well let's see, it's symmetric
00:32:15 <qebab> it's a combinatorial problem, so it can probably be written using factorials
00:32:46 <solrize_> ghunt 3 3 = ghunt 2 3 + ghunt 3 2 = ghunt 1 3 + ghunt 2 2 + ghunt 2 2 + ghunt 3 1
00:33:33 <solrize_> = 1 + 2*(ghunt 2 2) + 1 = 1 + 2*(1+1) + 1 =
00:33:38 <solrize_> 6
00:34:07 <solrize_> this looks sort of like binomial coefficients
00:38:35 <qebab> it is actually the mid row of pascals triangle :o
00:43:10 <glguy> dons: you about?
00:43:11 <qebab> that, I *think* means that ghunt (n + 1) (r + 1) = fac (n + r) `div` (fac n * fac r) ?
00:46:27 <AndreWe> Is there some code completion for Haskell in e.g. VI?
00:47:12 <dons> glguy: vaguely
00:47:24 <glguy> what did you have to do to use the ssh connection sharing
00:47:52 <dons> the -M option
00:48:00 <dons> google for ssh ControlMaster
00:48:05 <glguy> kk
01:08:06 <asmanian> hi all
01:12:29 <dolio> Note to self, don't blindly assume the formulae in a snazzy looking paper are correct.
01:13:07 <asmanian> hehe
01:13:19 <asmanian> is length on a list a O(n) operation?
01:13:27 <dolio> Yes.
01:14:21 <asmanian> hm for an imperative programmer these lists always seem a bad choice as the mostly used datatype ;)
01:16:43 <dolio> Most use of lists in functional programming don't involve finding their length all the time.
01:17:31 <olsner> and laziness makes the list more of a generator/iterator than an actual list
01:18:34 <asmanian> the point is: I'm trying to write a program that solves a puzzle simple by testing all possible tile comibnations & rotations
01:18:57 <asmanian> so often I need to access the last element of a list (the tiles so far) and compare it to the new tile
01:19:10 <asmanian> also I need some random access (2d puzzle)
01:19:23 <asmanian> maybe there is data type that is better suited for this case?
01:19:31 <asmanian> is there something like arrays in haskell?
01:19:41 <dolio> Yes, arrays.
01:20:25 <asmanian> thnx
01:20:29 <asmanian> ill google for that
01:21:05 <dolio> Although immutable arrays, which are what will cause the least changes in your code, may not be particularly efficient if you're updating them a lot.
01:21:13 <dolio> Although DiffArray might not be too bad.
01:21:29 <asmanian> well there is not much code atm
01:21:38 <asmanian> so changing it is not the problem
01:21:49 <asmanian> understanding how to do things in haskell is ;)
01:22:09 <mokomull> asmanian: but once it clicks, it's a wonderful revelation :)
01:22:17 <dolio> Oh, also, arrays aren't growable like lists.
01:22:18 <halberd> what would the the properties of an object whose only references are through variable names?
01:22:31 <halberd> what would they be, I mean
01:23:44 <halberd> the goal being that there is no way to obtain a reference to the object except through a variable name
01:24:02 <schee> Right. I've asked before.. maybe someone knows today; haskell on ovms. anyone know of an implementation?
01:25:39 <halberd> er, no way to obtain a reference to the object except through a variable name that _is_ a reference to the object
01:29:41 <pjdelport> halberd: Haskell doesn't really make that kind of distinction
01:33:14 <schee> Does anybody get the first example code on http://book.realworldhaskell.org/beta/find.html to actually work?
01:33:26 <paolino> halberd: you have only values
01:33:27 <schee> I get load failure.
01:34:28 <halberd> if you call a variable referring to that kind of object a "solitary" variable, then what are the ways to derive new solitary variables from a set of solitary and non-solitary variables?
01:35:24 <pjdelport> halberd: copying?
01:35:40 <halberd> that's one way
01:35:56 <pjdelport> well, it's either that, or eliminate the other references
01:36:05 <pjdelport> but what context is this in?
01:36:25 <halberd> ideally you would like to determine whether a variable is solitary or not statically, without having to walk references at runtime
01:36:48 <halberd> this isn't related to anything practical
01:37:34 <pjdelport> well, i'm wondering what this has to do with Haskell :)
01:37:46 <halberd> but if a variable is solitary and only is used once, then a destructive operation on it is referentially transparent
01:37:53 <paolino> halberd: are you talking of pointers ?
01:38:05 <halberd> no, wait, that's incorrect
01:38:25 <pjdelport> halberd: do you know of linear typing?
01:38:58 <halberd> I don't, I'll look it up
01:40:01 <pjdelport> halberd: also uniqueness typing
01:40:18 <pjdelport> http://homepages.inf.ed.ac.uk/wadler/topics/linear-logic.html
01:41:09 <pjdelport> also search http://home.pipeline.com/~hbaker1/ for "linear"
01:41:43 * pjdelport aways
01:42:22 <halberd> thanks
01:44:00 <moozilla> hello
01:44:02 <asmanian> waring dumb question ahead: how can I create a list of N times the same value?
01:44:29 <moozilla> asmanian: map (*n) list
01:44:42 <moozilla> > map (*4) [1..5]
01:45:00 <asmanian> err no what I want is simpler
01:45:13 <asmanian> for N = 3 I would want [a,a,a]
01:45:22 <asmanian> I already found repeat
01:45:24 <dons> :t replicate
01:45:31 <asmanian> but I dont know how to prune that stuff
01:45:31 <dons> no bot?
01:45:41 <schee> woh
01:45:43 <dons> its replicate, asmanian
01:45:43 <schee> ghci crash!
01:45:51 <asmanian> a fine
01:45:52 <dons> replicate :: Int -> a -> [a]
01:45:54 <asmanian> does the job
01:45:55 <asmanian> thanks
01:46:11 <schee> This real world haskell keeps getting better and better :P
01:46:30 <moozilla> I'm having an issue
01:46:31 <dons> schee: you should report crashes in the interpreter
01:46:34 <dons> ?bug
01:46:36 <dons> is the url.
01:46:42 <dons> grr
01:46:53 <dons> http://hackage.haskell.org/trac/ghc/wiki/ReportABug
01:47:09 <AndreWe> @t replicate
01:47:11 <dons> schee: and double check what happens if you compile the code instead
01:47:11 <schee> dons: Ok. It said out of memory when I was trying the  getRecursiveContents  in that there real world haskell book.  So I'm not so sure it is worth reporting :)
01:47:24 <dons> oh. well, that might be your fault then :)
01:47:26 <moozilla> if I both read then write to the same file in one do statement the write gets a permission denied on the file
01:47:38 <moozilla> even if i close and open a new handle between
01:47:39 <dons> moozilla: right. there's a lock on the file till you close it.
01:47:52 <dons> unless you open it ReadWrite mode.
01:48:09 <moozilla> I tried ReadWriteMode and it still didn't work :-/
01:48:20 <schee> dons: Well.. what I did is copy the code from the book, paste it in a file, :l it and   getRecursiveContents "/home/schme/wd"   and down it went.
01:48:27 <asmanian> oh dear I cant create a DiffArray of tuples?
01:48:28 <dons> you need to be careful doing mutable files, due to lazy io
01:48:42 <dons> schee: try compiling it.
01:48:55 <dons> maybe your directory tree is too big, or maybe there's a bug in the code, or a space leak.
01:49:05 <dons> hard to say. you'd have to provide more info
01:49:14 <moozilla> one sec i'll pastebin the code
01:49:20 <schee> dons: I dunno. it's just 65000 files or something there about. I'll try the compile there.
01:49:46 <dons> ghci is entirely unoptimised bytecode interpretation, btw, so its dog slow -- about 30x slower than compiled code.
01:49:49 <schee> oh.. I need to do one of those main things then. hrmmm.
01:49:50 <dons> so a bit faster than python
01:50:00 <schee> Right I need to figure this out :)
01:50:29 <schee> hahahah. "a bit faster than python" :)
01:50:33 <dons> moozilla: i'd try reading the contents strictly, closing the file,then writing it.
01:50:46 <moozilla> thats whaat i tried to do
01:50:53 <dons> schee: i'm not joking. python's in the 40-50x slower than compiled ghc code. ghci's about 20-30x.
01:50:58 <moozilla> i think i may have found the error
01:51:02 <dons> ok
01:51:18 <moozilla> i accidentally delted the line closing the handle in between :P
01:51:21 <dons> heh
01:51:27 <schee> dons: Ya python is not so well known for being fast :)
01:51:34 <dons> i'd just use bytestrings, moozilla
01:51:53 <moozilla> bytestrings?
01:52:04 <dons> strict, fast string library
01:52:05 <qebab> python was not made to be very fast
01:52:09 <dons> Data.ByteString
01:52:13 <qebab> pypy is interesting though
01:52:14 <dons> its in the core library set
01:52:28 <pjdelport> qebab: it's good at gluing fast things together, though
01:52:31 <solrize_> python programs tend to be written in a style that pushes the real work down to library modules written in C, which are fast
01:52:41 <qebab> pjdelport: that it is
01:52:53 <moozilla> how would i use a bytestring for file IO?
01:53:01 <dons> Data.ByteString.readFile
01:53:07 <qebab> I wish that they could fix the GIL though :(
01:53:09 <dons> do you have the standard library docs handy?
01:53:32 <dons> http://haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString.html
01:53:32 <schee> dons: Yup.. I compiled it. and I get out of memory.
01:53:42 <dons> schee: ghc -O ?
01:53:47 <pjdelport> qebab: the GIL isn't broken!
01:54:07 <dons> try it on smaller things, and see if you can work out if its due to the sheer size of what you're feeding it, or its a bug
01:54:14 <schee> What is -O?
01:54:15 <schee> haha
01:54:19 <dons> turn on optimisations.
01:54:21 <schee> that just says Compilation is NOT required.
01:54:21 <qebab> pjdelport: of course not, but I wish it wasn't there! :)
01:54:29 <dons> use -no-recomp schee
01:54:42 <dons> there's not much point compiling it unless you turn on all the optimisations
01:54:44 <schee> oh I remove the .o too
01:54:48 * dons thinks they should be on by default
01:54:51 <schee> Well..
01:55:04 <pjdelport> qebab: what i mean is that the GIL is generally a good thing
01:55:11 <dons> there's some seriously cool things that gets done to the code with -O and -O2 :)
01:55:11 <schee> I'm a more a bit baffled why there's code in a book and it just doesn't run at all :)
01:55:24 <schee> (dons. the optimization guy :P)
01:55:41 <dons> decide if 65k file input is a bug
01:55:45 <qebab> pjdelport: many times it is, but it's not a great thing in this age of manycore CPUs
01:55:48 <dons> i'm not sure. maybe it isn't.
01:56:02 <solrize_> 65k files isn't that many
01:56:08 <qebab> pjdelport: not if we continue getting more cores at least
01:56:17 <schee> out of memory
01:56:19 <dons> well, if you think it should work, please comment on the book chapter
01:56:27 <dons> since it probably shouldn't run out of memory
01:56:45 <dons> its important to report things like this before production
01:57:20 <schee> mmm.
01:57:28 <schee> This is on 32GB of memory too ;)
01:57:37 <pjdelport> qebab: that's under the assumption that Python interpretation is your bottleneck
01:57:47 <dons> i'm a little surprised then. does it actually try to allocate that much?
01:58:09 <solrize_> might be out of stack
01:58:16 <solrize_> which has a much smaller limit
01:58:23 <schee> I have no idea. It jeez crashes out of memory (requested 1048576 bytes)
01:58:41 <dons> ok, so stack it sounds like.
01:58:48 <dons> since that's the 10M stack limit
01:59:07 <schee> mmm.
01:59:18 <moozilla> dons, here is the problem i'm having: http://slexy.org/view/s2jY0FSF2B
01:59:29 <moozilla> error is described in the comments
01:59:42 <dons> pass +RTS -K100M
01:59:51 <dons> schee: to your program, when you run it
01:59:56 <dons> increases the maximum stack size.
02:00:07 <dons> maybe your 65k files bumps up against the 10M default
02:00:16 <schee> k..
02:00:32 <dons> moozilla: is gettxt strict?
02:00:48 <moozilla> i dont know?
02:00:56 <dons> ah, it is if you 'print' it. :)
02:01:01 <dons> otherwise its lazy io, hGetContents
02:01:06 <schee> out of memory.
02:01:07 <dons> so you close it before you demand any chars
02:01:12 <moozilla> ohh
02:01:19 <moozilla> how can i force it to be strict?
02:01:25 <dons> try, instead of print, length contents `seq` return ()
02:01:30 <schee> and top has it using not more than 3GB.. which is massive for listing files though.
02:01:30 <dons> or use one of the strict io modules
02:01:44 <schee> I mean 3GB is not much, but compared to find :)
02:01:46 <moozilla> like bytestrings?
02:02:07 <dons> schee: ok, report it on the book list. it might be just example code that no one thought to test on more than a few things.
02:02:18 <schee> ya.
02:02:23 <dons> moozilla: there's also one for strings. but in general, yeah, mutable files means don't use lazy io.
02:02:25 <schee> Makes sense.
02:02:28 <dons> since you end up writing before you read
02:02:39 <schee> It must be golden for book writing to have it online for people to review.
02:02:45 <moozilla> dons: which is the one for strings?
02:02:49 <dons> schee: or since you're reading the book, try writing your own version using bytestring io
02:02:56 <schee> eeh.
02:02:57 <dons> moozilla: its the 'strict' package on hackage.haskell.org
02:03:09 <moozilla> its not a built in one?
02:03:16 <dons> moozilla: but you can get away with: length xs `seq` return ()
02:03:25 <dons> moozilla: no, since its easy to roll your own from the lazy version
02:03:30 <schee> There is just no way I'll be writing a version of my own in any time soon. That is why I am reading the book.. to be able to write anything at all ;)
02:03:32 <dons> just by asking for the last character of input
02:03:57 <dons> schee: so just make sure your feedback gets back to the book comment page
02:04:50 <schee> Yeeep.
02:04:57 <schee> Oh ya it works like a charm on smaller dirs.
02:06:09 <moozilla> dons: by using interact?
02:06:47 <dons> moozilla: no, instead of 'print', which forces all the input to be read, use length content `seq` return ()
02:07:00 <dons> which forces the input to be read for its length, and throws the result away
02:07:10 <moozilla> oh
02:07:18 <moozilla> ok
03:03:58 <koninkje> @hoogle double
03:04:21 <Beelsebob> (*2)?
03:04:40 <koninkje> just seeing if it's taken :: Double -> Numeral Double t
03:29:37 <schee> Ok #haskell. What the bugger is `it' ?
03:29:50 <Beelsebob> huh?
03:30:03 <dmwit> schee: In ghci, it refers to the result of the last calculation.
03:30:25 <dmwit> schee: "it" has no pre-defined meaning outside of ghci.
03:30:45 <schee> dmwit: Thanks.
03:31:10 <dmwit> schee: For bonus points, try to guess what "it" is when you first start ghci (i.e. before you have done any calculations for it to refer to). ;-)
03:31:24 <Beelsebob> undefined surely
03:31:40 <dmwit> Beelsebob: Well, that depends on what you mean by undefined.
03:31:51 <olsner> > undefined
03:31:52 <Beelsebob> oh, it's *really* undefined
03:31:58 <Beelsebob> as in, it's not in scope
03:31:58 <dmwit> yeah =)
03:32:00 <osfameron> golly
03:32:13 <olsner> oh, that's another sense of undefined
03:32:33 <dmwit> Beelsebob: Surprised me, too, I had the same guess as you.
03:32:48 <dv\> has anyone used Network.Curl? I keep getting (CurlOK,"") back when I call curlGet. How could the server have returned ""?
03:33:20 <Beelsebob> dv\: because you're not looking at a very interesting URL?
03:33:43 <maltem> dmwit, it's intuitive if you think of it introduced by a let-binding
03:34:01 <Beelsebob> maltem: it is, and it isn't
03:34:07 <dmwit> maltem: Oh, yes, I agree that "not in scope" is the right behavior.
03:34:15 <maltem> Beelsebob, right :)
03:34:36 <dv\> Beelsebob: it's quite interesting actually
03:35:26 <dmwit> dv\: It dumps its result on stdout, according to the docs.
03:35:46 <dv\> ehm. oops. I'm using curlGetString
03:35:50 <dmwit> oh
03:39:49 <schee> What's this  >>= then?
03:40:17 <dmwit> That's composition, but for monads instead of functions.
03:40:44 <schee> Ok.. ?
03:40:49 <dv\> eg. getLine >>= putStr
03:41:34 <dcoutts> edwardk: you can use --haddock-options=
03:41:58 <Beelsebob> schee: it says, take the monadic result from the thing on the left, and hand the thing in the monad to the function on the right
03:42:21 <schee> k k.
03:42:22 <schee> sounds great
03:42:31 <Beelsebob> so (Just 5) >>= (\y -> return 2 * y)
03:42:35 <Beelsebob> takes 5 out of the Just
03:42:39 <Beelsebob> and hands it to the function
03:42:42 <Beelsebob> which gives back Just 10
03:46:29 <blarz> is there a isChar function somewhere? and where can I find it?
03:46:55 <dcoutts> @seen conal
03:47:00 <dcoutts> bah no lambdabot
03:47:12 <solrize_> isChar?  what would that do?
03:47:16 <Beelsebob> blarz: what would you expcet it to do?
03:47:27 <Beelsebob> do you mean isAlpha?
03:47:32 <dcoutts> isChar :: Char -> Bool = const True  :-)
03:47:36 <Beelsebob> hehe
03:48:34 <blarz> Beelsebob: I have a data type "data ListElement = IntElem Integer | CharElem Char deriving (Show)" and I have to write a function filtering all chars/ints out of a list of this ListElements
03:49:02 <blarz> so I thought I just take "filter isChar list" or something like that
03:49:02 <Beelsebob> blarz: okay, so write you isChar function yourself
03:49:23 <Beelsebob> isChar (IntElem _) = False; isChar (CharElem _) = True
03:50:54 <blarz> Beelsebob: d'oh, now that sounds simple :) thanks!
03:50:58 <Beelsebob> @hoogle (a -> b, c -> d) -> (a,c) -> (b,d)
03:51:16 <maltem> I noticed Data.ByteString.hGetLine explicitly fails if the input handle disables buffering. Is there a technical reason for this?
03:51:17 <Beelsebob> oh, \bot isn't here
03:51:31 <Beelsebob> where's she buggered off to?
04:00:32 <Baughn> maltem: None that I can think of, but adding code to do so is a bit..
04:01:57 <Baughn> maltem: Well, it seems to be because it optimizes things by stealing the buffer instead of copying it, so if there is no buffer it can't
04:02:09 <Baughn> maltem: But that's just missing code. Someone could fix it for the no-buffering case.
04:02:55 <Baughn> ..I'm not sure that's it, but at any rate the code /does/ assume the existence of a buffer. The non-buffered case would be considerably simpler, so...
04:03:37 <maltem> hm... I guess something like (until (/= '\n') hGet h 1) would be _too_ simple?
04:03:59 <maltem> ==, rather
04:04:23 <Beelsebob> why? do we need to write complex code instead of simple now?
04:04:54 <maltem> I was just wondering... if it's not implemented in the straight-forward way there should be some reason, being to inefficient or something
04:05:36 <maltem> (before somebody asks, the above was pseudo-code of course)
04:10:22 <Baughn> maltem: Yes. It would be inefficient.
04:10:30 <Baughn> maltem: But it beats /nonexistent/, so..
04:14:45 <maltem> Baughn, just wondering, why would it be inefficient?
04:15:10 <maltem> because you're reconstructing the string after getting it word for word?
04:15:58 <Baughn> maltem: You'd be reading in a list of bytes first, then packing it, so.. yeah
04:16:21 <Baughn> maltem: I'm counting three traversals in your version. One to build it, one to find the length, then one to copy it into a bytestring
04:16:55 <Baughn> You could at least cut that down to two. ;)
04:17:08 <maltem> yeah, you could count on-the-way
04:17:34 <Baughn> Still, anyone who expects high performance from non-buffered I/O is out of his mind, so any patch that enables it would no doubt be welcome
04:18:51 <maltem> we could just mimic GHC.hGetLineUnbuffered, it shows that I forgot to handle EOF
04:21:27 <maltem> right, I'll check out the bytestring repo
04:43:23 <schee> Hmm.. is there some list somewhere of how all these things like <-, -> >>= and what not are pronounced?
04:43:56 <dmwit> from, to, bound to
04:44:03 <dmwit> #haskell *is* the list
04:44:13 <schee> hahaha
04:44:22 <schee> Well thanks.
04:44:29 <schee> I wish it would list the other stuff I wonder about :P
04:44:36 <dmwit> wonder louder
04:44:38 <dmwit> ;-)
04:44:49 <schee> I have been. Not working :(
04:44:52 <schee> I'll wonder again.
04:44:57 <schee> Is there a haskell implementation for vms?
04:45:30 <dmwit> uh
04:45:36 <mattam> lambdabot has disappeared ?
04:45:40 <dmwit> http://en.wikipedia.org/wiki/OpenVMS
04:45:42 <dmwit> schee: That?
04:45:44 <dmwit> mattam: yes
04:45:45 <schee> dmwit: Yes.
04:45:59 <dmwit> schee: Likely no.
04:46:01 <schee> :(
04:46:13 <schee> I guess I'll have to go with the java or the python then. Bla! :(
04:46:13 <dmwit> schee: Especially if you've asked a few times and gotten no response.
04:46:46 <schee> Too bad really.. I guess sometime in the future when this language makes any sense whatsoever to me I'll have to look into porting ghc :)
04:46:52 --- mode: ChanServ set +o vincenz
04:47:02 --- mode: vincenz set -o vincenz
04:50:04 <edwardk> dcoutts: the problem with --haddock-options= is that i can't set it from a flag
04:53:50 <dcoutts> edwardk: it's a configure flag
04:54:08 <dcoutts> edwardk: cabal configure --haddock-option=
04:55:33 <lilac> @hoogle ([a], ([a], b)) -> ([a], b)
04:56:23 <edwardk> dcoutts: yeah but if haddock won't run to completion without the flag, it doesn't do me any good. i went back and just hacked a __GLASGOW_HASKELL__ > 609 check into the source file. i was using the flag to indicate whether or not they had a separate control.category
04:58:04 <dcoutts> edwardk: oh I see, you can do that check slightly more portably if you like, ie not based on ghc version but based on the version of the base package
04:59:04 <dcoutts> edwardk: but it's not just haddock right? I mean you need that just to compile the code no?
04:59:10 <edwardk> dcoutts: yeah i just don't know the exact base package number for it =)
04:59:23 <edwardk> dcoutts: sure, but -cpp-options doesn't work with haddock for some reason
04:59:29 <edwardk> er cpp-options:
04:59:32 <edwardk> ghc-options does
04:59:37 <dcoutts> hmm
04:59:47 <edwardk> but its a -D, so hackage pitches a fit if i try to pass it via ghc-options
05:00:04 <dcoutts> edwardk: I suspect it works for haddock 0.x and not 2.x
05:00:10 <dcoutts> edwardk: it sounds like a bug to me
05:00:27 <dcoutts> the interaction of cpp and haddock is a complete mess
05:00:34 * edwardk nods.
05:01:22 <dcoutts> edwardk: could you file a ticket, that cpp-options are ignored for haddock 2.x (which I presume you're using?)
05:01:33 <dcoutts> edwardk: or are you using haddock 0.x?
05:01:59 <edwardk> dcoutts: haddock 2.0, and will do
05:02:06 <schee> ok.. so what is const?
05:02:12 <dcoutts> @src const
05:02:13 <edwardk> @type const
05:02:17 <dcoutts> bah!
05:02:21 <dcoutts> no lambdabot
05:02:25 <schee> uh.
05:02:30 <schee> You're all my lamdbabot.
05:02:34 <lilac> const :: a -> b -> a
05:02:34 <dcoutts> hah hah
05:02:35 <edwardk> count :: a -> b -> a; const x y = x
05:02:41 <schee> dcouttsbot, edwardkbot: What is const? :P
05:02:43 <lilac> const a b = a
05:02:56 <schee> right..
05:03:05 <lilac> schee: use hoogle or hayoo
05:03:26 <schee> :(
05:04:05 <lilac> "if you give a man a fish, you feed him for a day. if you teach a man to fish, you give him a hobby for a lifetime"
05:04:06 <ndm> is there any way to stop GHC checking for duplicate instances
05:04:26 <lilac> ndm: i think there's a -X flag for that
05:04:28 <ndm> i.e. so I can give instance Eq Int twice
05:04:42 <dcoutts> ndm: wt!?
05:04:47 <schee> I'd love it if there was some easy way to do that @src thing from ghci though.
05:04:55 <dcoutts> ndm: and how is it supposed to pick?
05:04:56 <lilac> ndm: usually ghc tells you what the switch is when you try it
05:05:12 <ndm> dcoutts: i don't care how it picks, and i'm not actually going to r un the resulting code
05:05:19 <ndm> lilac: it doesn't hint at a switch at all
05:05:23 <dcoutts> ndm: perhaps it should pick non-deterministically :-)
05:05:27 <lilac> ndm: perhaps -XIncoherentInstances? check the docs
05:06:11 <ndm> lilac: nope, not enough
05:06:27 <ndm> dcoutts, for all i care, it can keep a local state and flip on every use
05:07:11 <dcoutts> ndm: that's probably why there's no such feature though, most people do care and want to be able to type check and run the code
05:07:33 <dcoutts> ndm: what if the duplicate instances had different requirements, like extra => constraints
05:07:37 <ndm> dcoutts, i just wondered, given there were so many other wacky type class stuff, if there was one that allowed even this
05:07:51 <dcoutts> then you even need to pick to be able to get deterministic typechecking
05:08:25 <ndm> i know...
05:08:33 <dcoutts> ndm: ghc tends to go for unsound but not non-deterministic typechecking :-)
05:08:46 <ndm> unsound and non-terminating
05:08:48 <dcoutts> erm, not unsound, non-terminating checking
05:09:06 <lilac> ndm: perhaps -XUndecidableInstances ?
05:09:23 <ndm> lilac: i have that one already
05:09:41 <dcoutts> in this case Undecidable means does not that it's not possible to decide between two instances
05:09:45 <lilac> ndm: http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id351320
05:10:19 <ndm> lilac: thanks, but i can't find anything that looks useful
05:10:29 <ndm> probably just isn't possible :(
05:10:33 <lilac> ndm: nope, nor me. what are you trying to achieve?
05:10:45 <ndm> type checking some code
05:10:55 <ndm> the more flexible GHC is, the less i need to massage the code before
05:11:22 <lilac> can you remove one of the instances?
05:11:40 <ndm> i will do
05:11:44 <ndm> just easier if i didn't have to
05:21:37 <schee> Right.. so in bracket (openFile path ReadMode) hClose $ \h -> do ...   what is this \h ?
05:22:16 <Botje> \h is the thing you get back from openFile
05:22:20 <Botje> in this case, a filehandle
05:22:26 <schee> Why the \ ?
05:22:37 <Botje> because it's a parameter
05:22:39 <Botje> :t bracket
05:22:42 <schee> and is it somehow related to    h   used in the do thang?
05:22:45 <Botje> gah, still no \bot?
05:22:51 <Botje> schee: yes.
05:23:00 <schee> I know :t bracket
05:23:00 <Botje> \h -> do ... is a function
05:23:05 <Botje> that takes one argument, h
05:23:09 <kpreid> schee: \var -> ... var ... is a lambda expression
05:23:11 <Botje> and then uses it to do stuff
05:23:19 <schee> I thought (\var   vas lambda?
05:23:28 <Botje> no, just \var -> ..
05:23:30 <schee> Hmm.
05:23:36 <schee> my god you people needs to fix the wiki :D
05:23:44 <dcoutts> sjanssen: you're a yi hacker right?
05:23:52 <schee> well that makes perfect sense then. thanks!
05:23:56 <Botje> schee: why? what's wrong with it?
05:24:16 <schee> Botje: It says (\var is lambda 'cause (\ looks like lambda
05:24:37 <kpreid> that would be wrong
05:24:42 <dcoutts> schee: which page?
05:24:44 <schee> Apperently
05:24:50 <schee> I'll see if I can find it again.
05:24:53 <kpreid> \ was chosen because it's the closest ascii to lambda
05:25:03 <kpreid> the ( isn't part of it's syntax, just ordinary parens
05:25:22 <schee> Well that is great.
05:25:22 <kpreid> :t (\x -> x) $ 1
05:25:35 <kpreid> er
05:25:55 <schee> ah hey yer right. it says the backslash. but the example has the stuff in a paren so it looks like it's part of the syntax.
05:25:58 <schee> grrr.
05:26:02 <kpreid> I was going to follow up with :t \x -> x $ 1, but evidently lambdabot is down
05:26:11 <schee> Seems easier to use the lambda character though :D
05:26:36 <dcoutts> schee: it's a bit hard to type on most keyboards :-)
05:26:39 <kpreid> anyway, you use parens around \... to make it not swallow everything on its right side
05:27:33 <dcoutts> actually I think it is a problem that there is not unicode lambda as a mathematical symbol, there is only the lower case greek letter
05:28:19 <dcoutts> because it means it's a bit rude for us to define that char as being special syntax and it'd prevent greek people using it in identifiers
05:28:37 <Beelsebob> I don't see why that's rude
05:28:46 <schee> Just as rude as using \
05:28:51 <Beelsebob> after all, we prevent british people using do, let, where and in
05:28:58 <schee> Prevents greek people from using \ in identifiers ;)
05:29:05 <dcoutts> Beelsebob: they're words not letters
05:29:54 <dcoutts> Beelsebob: try writing all your code with identifiers that miss one common letter :-)
05:30:00 <Beelsebob> ehehe
05:30:27 <Beelsebob> surely, identifiers that don't start with one common letter
05:31:08 <Beelsebob> of note, greeks didn't have the ability to use identifiers with lambda in them before adding unicode support
05:31:14 <Beelsebob> so I don't see why reserving it is that much of a problem
05:31:24 <Beelsebob> it's not like it would take away an ability that was already present
05:31:34 <dcoutts> Beelsebob: it works now
05:31:47 <Beelsebob> yeh, I know
05:31:55 <Beelsebob> I just think it was approached slightly oddly
05:32:10 <Beelsebob> lambda is a pretty significant character in any functional language
05:32:14 <Beelsebob> it deffinately is special
05:32:30 <Igloo> Only to academics
05:32:37 <Beelsebob> only to any functional programmer
05:33:05 <dcoutts> yeah, which is why I was initially surprised that unicode had all these other mathematical symbols (many of which duplicate greek or Hebrew letters) but not lambda
05:33:08 <Igloo> I wouldn't be surprised if there were Haskellers today who don't know that \ stands for lambda
05:33:22 <Beelsebob> dcoutts: oh, does it?
05:33:24 <schee> Igloo: I didn't know that :P
05:33:25 <Beelsebob> I didn't realise that
05:33:36 * Igloo rests his case  :-)
05:33:37 <dcoutts> yeah, check the maths range of unicode
05:34:09 <Beelsebob> dcoutts: the only letter-like one I see is the integral sign
05:34:20 <Beelsebob> oh, actually, there's a funny delta there
05:34:22 <Beelsebob> ∂
05:34:39 <Beelsebob> hmm, and ⋿
05:34:44 <Beelsebob> yeh, there's a good few of them
05:35:12 <skorpan> if i have data A = A { b :: B, c :: C } as my internal state (using the state monad), how do i do something like this: (b, c) <- get?
05:35:25 <skorpan> i can't quite figure out the syntax
05:35:42 <Beelsebob> skorpan: you're wanting to bind b and c to the inards of your A?
05:35:43 <Igloo> A b c <- get
05:35:50 <skorpan> yes Beelsebob
05:35:56 <Beelsebob> what Igloo said then :P
05:36:07 <Igloo> Or   A { b = b, c = c } <- get    if you like that sort of thing
05:36:21 <Igloo> Or better still, use different names (in both cases) to avoid shadowing
05:36:38 <edwardk> gets (b &&& c)
05:37:39 <edwardk> but yeah the destructuring assignment is better, misread the question as a literal request for (b,c) as output =)
05:37:43 <Beelsebob> gyah, ⌘W does not close the special characters window, it closes your IRC client
05:37:44 <Beelsebob> >.<
05:37:52 <schee> Is there some wikkid command for searching where I find stuff like ClockTime.. ghc-search maybe ?
05:38:06 <edwardk> schee: go to hoogle
05:38:23 <schee> edwardk: But honestly though. That's a shit solution :)
05:38:33 <schee> I mean something that works with the offline.
05:38:47 <edwardk> lambdabot has a hoogle module and runs offline iirc ;)
05:39:10 <schee> Ok.. so how do I use it here?
05:39:25 <edwardk> lambdabot is down at the moment i believe
05:39:34 <schee> Ok. lemme rephrase this.
05:39:59 <schee> When I am sitting at a computer with no internet access how do I find what I import to have the ClockTime?
05:40:04 <edwardk> i haven't done it just seen in the docs that it can
05:45:26 <vixey> so I'm a bit confused ..
05:46:22 <vixey> it make sense turning some abstract syntax tree into actual lambdas using SK[and other] combinators so that haskell can will evaluate that
05:46:41 <vixey> but why does the same method let you compile haskell efficiently?
05:46:57 <vixey> becuse for one thing.. you'd be compiling it into a struct language
05:47:28 <frwmanners> Anyone know the syntax for strictness flags within record syntax?
05:48:26 <schee> So there is no easy way to find which module has what stuff? :/
05:50:13 <dv\> unaploader: internal error: task 0x722c60: main thread 1 has been GC'd (GHC version 6.8.2 for x86_64_unknown_linux)
05:50:17 <dv\> o_O
05:51:44 <qebab> main thread got gc'd? that's confusing
05:55:53 <trez> > liftM2 (+) (Just 1) (Just 3)
05:56:04 <vixey> Just 4
05:56:26 <trez> > liftM2 (+) (Left 1) (Left 3)
05:56:29 <trez> :)
05:56:39 * vixey doesn't know that one :P
05:57:21 <paolino> No instance for Something Either a b
05:58:10 <paolino> mmhh, maybe it works actually
06:00:49 <paolino> is lambdabot on unhosted holiday ?
06:01:05 <vixey> @seen lambdabot
06:01:26 <vincenz> > liftM2 (+) (Right 2) (Right 4)
06:01:27 <paolino> this is tail recursive ?
06:01:32 <vincenz> @bot
06:01:48 <vixey> is what tail recursive?
06:01:57 <paolino> @seen lambdabot
06:02:25 <vixey> I think it gets compiled into a PRIVMSG
06:02:26 <vixey> :P
06:02:29 <ziman> 02:01:49 -!- lambdabot [n=lambdabo@72.249.126.23] has quit [Nick collision from services.]
06:03:25 <vixey> oh
06:03:36 <vixey> so to write a compiler:
06:03:45 <paolino> poor bot without hands to type a password
06:04:03 <vixey>  define a new language halfway between yours and your target, give it a denotation -and- operational semantics
06:05:32 <edwardk> hrmm, do you think a notation like :-> or :~> would be better for natural transformations than 'Nat' or 'Natural' which may be confusing to people expecting those to be numerical?
06:05:35 <vixey> (trying to figure out this Spineless tagless G-machine)
06:08:37 <edwardk> i.e. something like toRan :: (Composition (.), Functor k) => ((k . g) :~> h) -> (k :~> Ran g h)
06:10:40 <vixey> that looks fine
06:11:08 <vixey> I might write :-->:
06:12:33 <edwardk> yeah
06:13:10 <edwardk> though i also have to deal with 2-natural transformations and that would probably be :--> which is easier to disambiguate with ~ than -
06:13:31 <Philippa> vixey: which papers've you looked at so far?
06:13:46 <Philippa> oh, and heads-up: AIUI these days it has both a spine and tags...
06:14:29 <vixey> I read about hhi and some slideshow.. now reading about implmenting it on stock hardware
06:19:33 <Philippa> you might want to read the eval/apply paper as well
06:20:01 <vixey> SICP ?
06:20:32 <vixey> oh
06:23:10 <paolino> is there a way to have a logaritmic complex test for presence on infinite list, preordered , I checked Set.fromAscList, but that is not lazy (it seems)
06:25:55 <praseodym> read :: Int fails on "", is there a way to avoid this?
06:29:39 <edwardk> hrmm is there a flag to allow the use of infix type variables?
06:29:53 <edwardk> not infix types
06:30:57 <vixey> stuff like type b :<-: a = a -> b just works I think
06:31:01 <vixey> without flags
06:31:14 <edwardk> no, i mean stuff like class Foo (*) where ...
06:31:19 <vixey> oh sorry
06:31:25 <vixey> I don't know about that
06:31:47 <ehird> Hey guys. i found a bug in System.Directory!
06:31:51 <ehird> Prelude System.Directory> canonicalizePath ""
06:31:51 <ehird> "\132"
06:32:11 <ehird> And in fact it;s unpredictable
06:32:16 <ehird> each time you call it you get some different garbage
06:32:30 <edwardk> it would let me instead of  hassociateComposition :: (HFunctor f, HComposition o) => ((f `o` g) `o` h) a b -> (f `o` (g `o` h)) a b -- say
06:32:30 <edwardk> hassociateComposition :: (HFunctor f, HComposition (.)) => ((f . g) . h) a b -> (f . (g . h)) a b
06:32:31 <ehird> So I conclude that canonicalizePath, when called with "", accesses uninitialized memory and returns it.
06:32:38 <ehird> That's bad! :\
06:32:52 <Botje> heh
06:32:53 <Botje> indeed
06:32:54 <Botje> fun!
06:33:36 <ehird> Botje: so is this an actual bug? it's suprising to me.
06:34:07 <Botje> it doesn't seem to cause a segfault though
06:34:15 <nominolo> at least it's more random than debain
06:34:17 <ehird> Botje: indeed not
06:34:25 <ehird> it certainly gave me a crazy bug though!
06:34:31 <Botje> heh :)
06:34:36 <ehird> FWIW, the solution is prepending "./" to the path before feeding it in.
06:34:38 <ehird> Yikes ...
06:35:02 <Botje> that's what you get for trying to do IO :p
06:35:37 <nominolo> possibly an off-by-one error
06:40:06 <nominolo> ehird: what system are you on?
06:40:14 <Botje> hmm
06:40:18 <ehird> nominolo: Lunix debian stable.
06:40:25 <Botje> apparently it's because of the realpath() function it calls
06:40:27 <nominolo> canonicalizePath only calls a C function
06:40:28 <ehird> nominolo: Maybe it's MD_update's fault.
06:40:35 <Botje>  If   there   is   no   error,  realpath()  returns  a  pointer  to  the resolved_path.
06:40:43 <Botje> Otherwise it returns a NULL pointer, and  the  contents  of  the  array resolved_path are undefined.
06:40:54 <praseodym> is there a function to count the occurences of an element in a list?
06:41:06 <Botje> praseodym: length . filter ?
06:41:14 <nominolo> hm, the haskell wrapper doesn't explicitly check for errors
06:41:16 <Botje> length . group.sort ?
06:41:20 <Botje> indeed
06:41:28 <Botje> it just calls realpath but doesn't check the return
06:41:28 <nominolo> and it's an unsafe ccall
06:41:45 <Botje> while it DOES do so for findExecutable, for example
06:41:55 <praseodym> ultimately I want something like ('a',3) where 3 is the number of occurences of 'a', but for each element
06:42:17 <praseodym> I guess I'd need to map the filter then
06:42:17 <nominolo> hm, on OSX the doc says the result will be the input string
06:42:26 <Botje> praseodym: then you definitely want group . sort
06:42:29 <ehird> IMO:
06:42:33 <ehird> "" should be treated as "."
06:42:40 <ehird> for canonicalizePath
06:42:52 <praseodym> Botje: OK, I'll check it out
06:43:39 <nominolo> but group . sort is probably slower than a direct implementation
06:44:11 <praseodym> nominolo: simplicity is more important than speed
06:44:15 <nominolo> if the searched-for element is known
06:44:44 <nominolo> thinking about complexity is still useful
06:44:51 <Botje> ehird: care to file a bug?
06:45:39 <ehird> Botje: alright then
06:45:43 * ehird hunts around for the ghc tracker
06:45:44 <nominolo> hm, is there a standard library for failure injection?
06:45:59 <nominolo> ehird: or send it to libraries@haskell.org
06:46:01 <edwardk> hrmm does anyone know the fixity of ->
06:46:15 <ehird> nominolo: which would be preferable?
06:46:18 <nominolo> there are type-level fixitiies?
06:46:26 <edwardk> nominolo: for when you use infix type constructors
06:46:37 <nominolo> ehird: the preferably both
06:46:42 <edwardk> i want to set up a fixity for natural transformations to be the same as it
06:46:49 <nominolo> but, bug tracker is ok
06:46:54 <ehird> nominolo: I guess just send an email to libraries@ linking to the bug tracker?
06:46:55 <ehird> OK then
06:47:26 <ehird> aieee, they use trac
06:47:48 * ehird kills himself now so that he isn't alive to experience using trac
06:47:50 <ehird> okay, here goes
06:48:01 <edwardk> ah arrow is infixr 0
06:48:06 <nominolo> what's so bad about track?
06:48:26 <nominolo> or, rather, is there anything that sucks *less*?
06:50:02 <ehird> nominolo: I mean, trac is fine for a wiki & source view (I guess) but the bug tracker is painful
06:50:07 <ehird> darcs' tracker is quite nice
06:50:10 <ehird> whatever squeak uses too
06:50:17 <ehird> (Though bugtraq is not)
06:50:24 <ehird> hah
06:50:25 <ehird> Trac detected an internal error:
06:50:27 <ehird> and no explanation
06:50:30 <ehird> but it gives me a python traceback
06:50:40 <nominolo> ok, lighthouse is too minimal, bugzilla is really crappy, fogbugz costs money
06:50:43 <ehird> ... showing me that the DB is locked. Oh trac, paragn of exellence
06:50:47 <ehird> nominolo: mantis?
06:51:02 <nominolo> i don't know mantis
06:51:16 <ehird> http://bugs.darcs.net/?user=guest;pass=guest <-- this is using something called roundup
06:51:25 <ehird> i think mediawiki use it too
06:51:52 <ehird> oh, no
06:51:55 <ehird> mediawiki use bugzilla
06:52:16 <ehird> anyway, roundup and mantis look nice
06:52:22 <osfameron> RT ?
06:52:42 <nominolo> not a very readable design, but well
06:52:43 <osfameron> I quite liked bugzilla when I used it - but did hear it's hard to hack the code to improve it.
06:52:43 <ehird> osfameron: I haven't personally used rt much but yeah
06:52:55 <ehird> i've heard lots of good things abou rt
06:53:03 <osfameron> default RT install is slow and confusing... I really dislike it... but it wasn't in the list :-)
06:53:14 <matthew_-> osfameron: well, bugzilla is written in Perl. So yeah, hacking it is like pulling teetch
06:53:17 <Cale> btw, I'll restart lambdabot as soon as I can get back into my account on code.h.o
06:53:19 <matthew_-> or even, teeth
06:53:22 <ehird> matthew_-: so is RT
06:53:22 <ehird> :P
06:53:28 <osfameron> yup
06:53:41 <osfameron> I believe the problem is that bugzilla is in Perl 4...
06:54:04 <ehird> http://rt.perl.org/rt3/Public Hm if this is RT it's distinctly unimpressive
06:54:09 <ehird> ugly, slow and is that an sql query I see inthe url?
06:54:16 <ehird> Time to be bobby tables methinks;
06:54:18 <vixey> hi Cale
06:54:42 <osfameron> ehird: it looks like an SQL query, but it's parsed, so not at danger of injection.  Still a strange design decision IMO
06:54:54 <ehird> osfameron: very..
06:55:06 <ehird> http://rt.perl.org/rt3/Public/Bug/Display.html?id=49586 the actual bug pages look nice
06:55:10 <ehird> but I wouldn't go with rt.
06:55:23 <ehird> i've used mantis and roundup before, so I can say that they're nice
06:55:28 <ehird> you know what we need? a haskell bug tracker ;)
06:56:06 <nominolo> not without a clear killer feature
06:56:37 <ehird> nominolo: HASKELL.
06:56:38 <ehird> :-P
06:56:47 <ehird> ok, hm, it integrates with darcs? :P
06:56:54 <nominolo> the squeak bugtracker is ugly
06:57:09 <osfameron> right.  So write it in a language nobody uses, and integrate with a version control system noone uses. PROFIT!
06:57:12 <nominolo> those guys should go and read some tufte
06:57:30 <ehird> osfameron: I'm pretty sure that haskell & darcs is totally fine for haskell people ...
06:57:35 <ehird> Just a hunch, tho.
06:57:41 <osfameron> hehe, guess so
06:57:54 <nominolo> ehird: but you need a community to keep it usable
06:57:58 <osfameron> I think I downloaded darcs once, to get a haskell library that didn't have a tarball
06:58:06 <ehird> nominolo: Patches are welcome. :-P
06:58:10 <edwardk> vixey: re the earlier, apparently (.) (!) and (*)  are explicitly excluded. guess which 3 operators i tried ;)
06:58:18 <vixey> hehe
06:58:21 <ehird> really if I wrote it i'd end up using it for itself
06:58:21 <ehird> end
06:58:22 <ehird> :-P
06:58:37 <ehird> I love projects that exist because of themselves!
06:58:46 <edwardk> none of the remaining characters are appreciably clearer than `o`
06:59:23 <nominolo> @let (.) = fmap
06:59:30 <nominolo> oh, right, no bot
06:59:36 <ehird> sheesh
06:59:40 <ehird> I could just put a lambdabot in here
06:59:40 <ehird> :-P
06:59:42 <osfameron> what happened to the bot?
06:59:43 <vixey> what' was the other possibility for (.)
06:59:51 <vixey> something from Control.Category. ?
07:00:13 * ehird downloads lambdabot
07:00:19 <edwardk> vixey: class Category k where (.) :: k b c -> k a b -> k a c; id :: k a a
07:03:15 <mbz> does lambdabot have support for xmpp/jabber?
07:03:47 <edwardk> hah i think i just unified that with the (.) = fmap version
07:04:00 <edwardk> testing something real quick
07:06:45 <ari> @bot
07:06:45 <rahaskella> :)
07:07:58 <ehird> ari: oh sheesh
07:07:59 <edwardk> instance Functor (MyCategory a) MyCategory (->) where fmap f g = (f . g) -- would give you an instance of fmap for any category 'MyCategory'. one thought is instead of (.) = fmap, (.) = second, where second is defined as the bifunctor map on its second argument
07:08:01 <ehird> I was just downloading \bot
07:08:03 <ehird> :\
07:08:48 <edwardk> then you can make every bifunctor and category a 'qfunctor' that supports mapping over its second argument, and they become the same thing.
07:09:33 <edwardk> guess it'd be better if the entire library was built up using bifunctors though.
07:10:43 <twanvl> what about trifunctors?
07:10:54 <vincenz> or arbitrary N functors
07:10:56 <idnar> multifunctor!@$
07:11:20 <edwardk> twanvl: well, in some sense the bifunctor gives you a place to carry around 'other stuff' so its sufficient
07:11:43 <vincenz> edwardk: is that like saying "The cons-cell can be used to build up anything?"
07:11:54 <edwardk> vincenz: yeah =)
07:12:01 <edwardk> vincenz: i thought that same thing as i said it ;)
07:12:24 <vixey> lisping in the type system :o
07:13:00 <vixey> if we got kanren to resolve typeclasses..
07:14:08 <ehird> oh I am so going to make a type system lisp now
07:14:09 <ehird> :DDDDDDDDDDDDDDDd
07:14:11 <ehird> dddddddd
07:14:12 <ehird> d
07:14:17 <EvilTerran>  
07:14:37 <ehird> ‮EvilTerran - agreed.
07:14:53 <vincenz>  
07:15:11 <EvilTerran> that shouldn't be too hard, actually, although the syntax will be whole levels of eldritch horror
07:15:26 <ehird> hello‮worl‭dhowar‮eyou i wond‭er‮???
07:15:29 <edwardk> a nice metacircular definition for category/second: (.) = second; class (Category r, Category s) => QFunctor k r s where second :: r a b -> s (k c a) (k c b); class QFunctor k k (->) => Category k where id :: k a a
07:15:30 <ehird> (try highlighting that.)
07:15:47 * EvilTerran boggles
07:15:52 <vixey> :D
07:15:54 <edwardk> then (.) works like both Control.Category AND like Cale's =)
07:15:54 <EvilTerran> RTL marks are weird.
07:16:01 <ehird> EvilTerran: rtl override actually
07:16:12 <EvilTerran> ... what's the difference?
07:16:26 <ehird> EvilTerran: one doesn't do the above.
07:16:34 <EvilTerran> what does it do, then?
07:16:45 <ehird> oh, and, if this channel wasn't +c, i'd show you Fun With Colours, Formatting, And Unicode Control Characters
07:16:53 <ehird> it is trippy.
07:17:14 <vincenz> After Colorforth, now ColorHaskell
07:17:20 <ehird> vincenz: YES
07:17:34 <ehird> #haskell-c if you want to see haskell type-set over irc.
07:17:42 <EvilTerran> hmm
07:17:45 <vincenz> ehird: nono, color has semantic-meaning
07:17:53 <ehird> vincenz: but of course
07:20:18 <vixey> I get lost halfway through the stock hardware paper :[
07:20:52 <lilac> @hoogle m (m a) -> m a
07:20:52 <rahaskella> A Hoogle error occured.
07:20:58 <vixey> :t join
07:21:03 <rahaskella> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:21:07 <lilac> ta
07:24:37 <MyCatVerbs> Anyone seen this, out of curiosity? http://b.tinyurl.com/3pefvg
07:25:05 <vixey> MyCatVerbs: What's the url?
07:25:23 <vincenz> MyCatVerbs: I have out of curiousity after you just put that link up
07:25:30 <geezusfreeek> i had
07:25:31 <MyCatVerbs> http://obfuscatedcode.wordpress.com/2008/05/17/unstacking-monads-for-performance/?amp;preview=true <-- dis.
07:25:54 <MyCatVerbs> (Blog post on unstacking monad transformers for performance - apparently this only gained the author a short fraction performance improvement, rather than the more drastic speedup they'd been expecting.)
07:26:18 <geezusfreeek> it looks to me like they haven't profiled
07:26:31 * vixey hopes they had a backup of the code
07:26:56 <opqdonut> geezusfreeek: mhmm
07:26:57 <ehird> ?amp;preview=true <-- lol wut#
07:26:58 <rahaskella> Unknown command, try @list
07:27:00 <Philippa> heh
07:27:02 <opqdonut> forgetting the first rule of optimization
07:27:13 <Philippa> I'm guessing an awful lot of the transformer stuff got inlined away
07:27:36 <MyCatVerbs> Philippa: 6.8 being more aggressive about inlining than previous incarnations of GHC?
07:28:01 <MyCatVerbs> Like, sufficiently so that the advise to unroll deep MTL stacks no longer actually applies?
07:28:10 <MyCatVerbs> *advice, argh.
07:28:35 <Philippa> MyCatVerbs: in fairness, some of the codegen improvements might be more relevant. I believe unboxed tuples're more powerful now
07:29:29 <MyCatVerbs> Philippa: oooh, it can automatically find places to make use of those? Spiffy.
07:29:32 <Philippa> and that kind of thing really will work wonders for small stacks that end up as nested tuples on the inside
07:29:39 <MyCatVerbs> :t (>=>)
07:29:42 <rahaskella> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
07:30:52 <MyCatVerbs> rahaskella? That's a funny way of spelling \bot.
07:31:20 <vixey> I think it's a nice name
07:31:37 <vixey> It's lambabots sister or .. something anyway
07:32:54 <Philippa> hmm, the tagging stuff in 6.8.* will probably speed up the single pattern-match on Either rather a lot too
07:33:06 <Botje> vixey: is she hot?
07:33:13 <ehird> sclv: ping
07:33:35 <Lanken> I have some questions about programming languages
07:33:44 <Philippa> they all suck. Next?
07:33:45 <vixey> umm,
07:33:46 <opqdonut> fire away
07:33:54 <Lanken> Philippa: oh, then never mind.
07:34:04 <ari> MyCatVerbs: It's a pun on my last name that some good folks on a different channel came up with when I first started becoming a smug Haskell weenie ;)
07:34:04 <Lanken> err, so
07:34:14 <Lanken> I got reading about dataflow languages and functional languages today
07:34:18 <Lanken> I'd heard of haskell before
07:34:29 <ehird> ari: Rahikkala doesn't turn into Rashaskella very easily
07:34:31 <ehird> (/whois POWAH)
07:34:32 <Lanken> but I never read about lambda calculus, etc.
07:34:53 <Lanken> I remember reading that a purely functional language wouldn't be able to return its results
07:35:03 <Lanken> things are kind of starting to come together in my head a little....
07:35:22 <vixey> Lanken: A functional program is just a value
07:35:35 <Lanken> but I have some questions that are really simple, like...
07:35:55 <Lanken> ok, how does all this relate to the thing known as "machine language"?
07:36:04 <vixey> it doesn't
07:36:34 <Lanken> sure it does :)
07:36:52 <Lanken> a compiler converts source code into something more like machine language, right?
07:36:56 <Botje> there exist compilers that transform functional programs into imperative programs that can be transformed into machine code
07:36:56 <vixey> no
07:36:56 <geezusfreeek> not enough that it matters for most of us
07:37:33 <vixey> Lanken: A compiler transforms code in language A into language B, preserving the meaning
07:37:51 <MyCatVerbs> ari: surprisingly enough, this just confuses me more. Ah, well.
07:37:59 <vixey> Lanken: there's no reason for B to be machine code, but it's a possibility
07:38:21 <sw17ch> Lanken, it could very well be translated to English or French
07:38:34 <geezusfreeek> sw17ch: that would be something to see
07:38:39 <MyCatVerbs> ari: er, well, leaves me more mystified.
07:39:06 <ehird> Lanken: if you're thinking about the machine, 99% of the time ur doin' it rong.
07:39:09 <sw17ch> geezusfreeek, :) wouldn't it? the most interesting part would be the objdump -D for the English architecture
07:39:16 <Lanken> ok...in that case, a compiler from a functional language to an imperative-based language must be a huge achievement.
07:39:28 <Lanken> ehird: huh?
07:39:47 <ehird> <Lanken> ok...in that case, a compiler from a functional language to an imperative-based language must be a huge achievement.
07:39:50 <ehird> no, not really.
07:39:54 <sw17ch> Lanken, i can use C in a purely functional way
07:39:58 <ehird> Lanken: the point is that you *don't think about it* - it doesn't matter
07:40:05 <vixey> sw17ch: :/
07:40:06 <ehird> Lanken: the machine, the computation: it's inconsequental
07:40:14 <ehird> sw17ch: well you have to do some mallocing to get closures..
07:40:28 <Lanken> ehird: ah, I'm not coming from that background
07:40:33 <geezusfreeek> Lanken: the point is that haskell isn't based on machine architecture. there is a compiler, but the language was designed in an agnostic way
07:40:53 <Lanken> ehird: part of what's exciting about non-imperative-based languages is the potential for economies in multiple-core architectures
07:41:21 <MyCatVerbs> Lanken: effectively what people do is build something a little bit like a virtual machine, which works by performing something like lambda-calculus reductions.
07:41:21 <Lanken> geezusfreeek: ah, that's a useful observation
07:41:27 <sw17ch> not having to think about the underlying assembly is what's nice about high level languages like C/Ada/Haskell/Scheme
07:41:41 <EvilTerran> well, you could argue the point for C
07:41:43 <sw17ch> though knowing what has to happen for a computation to run is quite important
07:41:44 <opqdonut> well that doesn't really apply to C
07:41:49 <vixey> it does apply to C
07:41:57 <MyCatVerbs> Lanken: in practice, some bits and pieces are optimized down to things a bit more efficient than that, but that's the general gist of it.
07:41:57 <chessguy> @bot
07:41:58 <rahaskella> :)
07:42:09 <geezusfreeek> EvilTerran: C is based on machine language though
07:42:23 <MyCatVerbs> Lanken: does that make more sense?
07:42:46 <Philippa> geezusfreeek: funny, I've got a machine with no hardware stack where C's still the preferred language...
07:42:54 <sw17ch> geezusfreeek, but i use C for any number of different assemblies
07:43:04 <Lanken> computers are mind-blowingly complicated.
07:43:04 <sw17ch> Arm/ColdFire/Sparc/PPC/X86...
07:43:05 <vixey> C is based on a stack discipline/von neumann arch
07:43:17 <MyCatVerbs> geezusfreeek: well, close. C is an abstraction from von Neumann machines... or possibly even more like an abstraction from Harvard arch machines (given that it doesn't have a direct way of altering code at runtime).
07:43:17 <vixey> it's not based on "machine language" whatever that is
07:43:19 <sw17ch> and it doesn't matter which, as long as there is a compiler, it will work
07:43:25 <geezusfreeek> s/machine architecture/stack discipline on von neumann arch/
07:43:29 <Lanken> I got thinking about this after reading about the Big Kernel Lock thing
07:43:46 <vixey> Lanken: Yeah they break/crash a lot too :/
07:45:04 <Lanken> I teach high school physics, and the other day it occured to me to think of a microprocessor as something like an incredibly complicated pachinko machine that drops balls (electrons) when you apply a voltage across whatever terminals the power goes in through.
07:45:10 <chessguy> vixey: what's incredible is that they don't crash more
07:45:30 <ehird> Lanken: you should build that
07:45:31 <ehird> Lanken: now
07:45:34 <ehird> XD
07:45:54 <Lanken> the fact that microchips work is kind of incredible...
07:46:00 <sw17ch> chessguy, no kidding... i just spent a semester looking at the code generated by compilers...
07:46:14 <Lanken> you're talking about something like a veritable army of gnomes with buckets, throwing water to each other
07:46:22 <Philippa> sw17ch: code that's never had "being comprehensible to a human reader" as a goal
07:46:49 <Lanken> sw17ch: what led you to look at that code?
07:47:12 <ehird> oh well
07:47:14 <ehird> sclv died again
07:47:14 <ehird> :3
07:47:30 <sw17ch> Advanced Computer Architectures. 1) Learn how things like branch prediction work. 2) See how compilers take advantage of architecture differences/optimizations.
07:47:33 <EvilTerran> Lanken, except, instead of discrete balls, they're probability clouds. just to make things worse. ;)
07:47:52 <sw17ch> 3) Try and figure out the best method for unrolling loops... etc
07:47:56 <sw17ch> it was a great class
07:48:06 <Lanken> vixey: I know that programming languages aren't "based on" machine language, yeah.  But it would be right to say that any code that anyone writes is in some sense macros for delivering instructions to hardware.
07:48:11 <MyCatVerbs> EvilTerran: okay, that's just cruel. But at least they can be cleaned up to act more like discrete balls again. :P
07:48:47 <Lanken> EvilTerran: seriously?  how many electrons in a bucket these days?
07:48:51 <Lanken> at 40 nm or whatever
07:48:57 * geezusfreeek resists a fuzzy balls joke
07:49:21 <vixey> Lanken: no that's not at all true
07:49:25 <EvilTerran> IANA physicist, but i imagine the probability clouds aren't that much of a problem. just thought i'd put that out there for the heck of it.
07:49:26 <Lanken> geezusfreeek: at least all our balls are the same size?
07:49:49 <Lanken> vixey: my bad...thinking of non-academic programming here...ok...all commercial code?
07:50:41 <vixey> Lanken: if you s/hardware/software/ perhaps it's closer to correct
07:50:48 <Lanken> I'm a physicist (2007 BA from Princeton, now teaching physics at a high school in Shanghai to expat kids from Korea and Taiwan and Japan, nice to meet you)
07:51:06 <vixey> Lanken: we target the operating system.. common libs.. etc
07:51:07 <Lanken> and I'll do a back-of-the-envelope to check whether fuzzyness comes into play
07:51:16 * MyCatVerbs blinks. It's possible to get a BA in physics? oO
07:51:23 <Lanken> Princeton is weird
07:51:25 <EvilTerran> i vaguely recall hearing somewhere that it was getting difficult to make transistors much smaller because quantum effects started causing trouble, but whoever told me that may've been talking empty air
07:51:28 <Lanken> no BS there...
07:51:53 <EvilTerran> ox.ac.uk and cam.ac.uk are like that with their degrees, too. every B is a BA.
07:51:57 <MyCatVerbs> Lanken: hah! An educational establishment with no BS at all *would* be a weird thing indeed.
07:52:15 <chessguy> EvilTerran: except that in the quantum realm, air isn't empty...
07:52:33 <geezusfreeek> there is no air!
07:52:37 <opqdonut> didn't ibm push the size of transistor down to a few atoms a few years ago?
07:52:43 <opqdonut> *transistors
07:52:48 <chessguy> you think that's air you're breathing??
07:53:00 <EvilTerran> chessguy, ok, fine, zero-point air :P
07:53:01 * MyCatVerbs sniffs.
07:53:13 <MyCatVerbs> chessguy: yes. Well, that and car exhaust.
07:53:35 * EvilTerran is breathing nitrous oxide. which would explain why the room is spinning.
07:53:43 <Lanken> chessguy: yeah, might be "foamy" :)
07:54:05 <chessguy> @hoogle pure
07:54:05 <rahaskella> A Hoogle error occured.
07:54:22 <EvilTerran> Control.Applicative.Pure :: Applicative f => a -> f a
07:54:36 <EvilTerran> Control.Arrow.pure :: Arrow (~>) => (a -> b) -> (a ~> b)
07:54:44 <EvilTerran> er, s/Pure/pure/
07:54:44 <MyCatVerbs> EvilTerran: oh eck! Try mixing up with ether, too.
07:54:52 <Lanken> ok...
07:54:57 <MyCatVerbs> EvilTerran: hopefully that'll make the room spin the *other* way, and they'll cancel out.
07:55:00 <Lanken> 40 nm is 800 hydrogen radii
07:55:08 <Lanken> so... I don't think quantum effects are too huge
07:55:11 <EvilTerran> ok
07:55:21 <MyCatVerbs> Lanken: look up the sizes of quantum dots, though. :)
07:55:27 <Lanken> ?
07:55:38 <Lanken> do you mean the planck length
07:55:39 <Lanken> ?
07:56:07 <chessguy> @type intercalate
07:56:13 <lilac> electro-migration becomes a big deal long before quantum effects do
07:56:14 <rahaskella> forall a. [a] -> [[a]] -> [a]
07:58:00 <Lanken> lilac: would electromigration be like...wandering atoms of dopant?
07:58:33 <chessguy> if i have something like [1,1..] and [2,2..], is there something in prelude that will give me [1,2,1,2,...] ?
07:58:41 <chessguy> @type intersperse
07:58:46 <ehird> interesting
07:58:47 <MyCatVerbs> Lanken: http://en.wikipedia.org/wiki/Quantum_dot <-- industrially useful for various weird purposes, manifest various interesting effects, but large enough to act as colloids.
07:58:49 <rahaskella> forall a. a -> [a] -> [a]
07:58:49 <ehird> let me write that
07:59:09 <chessguy> > intersperse 1 [2,2..]
07:59:13 <vixey> > transpose [repeat 1 , repeat 2]
07:59:16 <rahaskella>  [2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1...
07:59:19 <rahaskella>  [[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,...
07:59:24 <ehird> > let f xs [] = xs; f (x:xs) (y:ys) = x : y : f xs ys in f (repeat 1) (repeat 2)
07:59:26 <vixey> > concat . transpose $ [repeat 1 , repeat 2]
07:59:29 <rahaskella>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
07:59:32 <rahaskella>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
07:59:33 <Lanken> for the unitiated, which would have included me until I taught a chapter on microelectronics this year, in solid state electronics (like transistors) the device is made by doping a silicon crystal with different things in different places, to get the electrons to do neat things
07:59:35 <ehird> heh
07:59:36 <ehird> vixey: you win
07:59:52 <chessguy> @src tranpose
07:59:53 <rahaskella> Source not found. Wrong!  You cheating scum!
08:00:02 <chessguy> @src transpose
08:00:03 <rahaskella> transpose []             = []
08:00:03 <rahaskella> transpose ([]   : xss)   = transpose xss
08:00:03 <rahaskella> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
08:00:10 <vixey> transpose = apply map list -- :P
08:00:20 <ehird> wow, that transpose definition is horribly complex
08:00:25 <ehird> @type transpose
08:00:28 <Lanken> oxygen makes it a resistor or insulator, aluminum makes it a good conductor, and different kinds of semiconductors do neat things
08:00:32 <rahaskella> forall a. [[a]] -> [[a]]
08:00:39 <ehird> oh
08:00:42 <MyCatVerbs> I wish more of the bots' commands would result in insults. :(
08:00:46 <ehird> stupid function: it is stupid
08:00:50 <ehird> @type apply
08:00:58 <rahaskella> Not in scope: `apply'
08:01:30 <vixey> > let interleave (x:xs) (y:ys) = x:y:interleave xs ys in repeat 1 `interleave` repeat 2
08:01:32 <paolino> MyCatVerbs: to what pro ?
08:01:35 <rahaskella>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
08:01:40 <ehird> vixey: that doesnt handle non-infinite lists
08:01:41 <ehird> mine does.
08:01:57 <ehird> > let interleave xs [] = xs; interleave (x:xs) (y:ys) = x : y : interleave xs ys in interleave (repeat 1) (repeat 2)
08:02:01 <rahaskella>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
08:02:05 <ehird> > let interleave xs [] = xs; interleave (x:xs) (y:ys) = x : y : interleave xs ys in interleave [] []
08:02:10 <rahaskella>  []
08:02:15 <ehird> > let interleave xs [] = xs; interleave (x:xs) (y:ys) = x : y : interleave xs ys in (interleave [1] [],interleave [] [1],interleave [1,2] [3])
08:02:20 <rahaskella>   Non-exhaustive patterns in function interleave
08:02:23 <ehird> Oh
08:02:29 <ehird> > let interleave xs [] = xs; interleave [] ys = ys; interleave (x:xs) (y:ys) = x : y : interleave xs ys in (interleave [1] [],interleave [] [1],interleave [1,2] [3])
08:02:33 <rahaskella>  ([1],[1],[1,3,2])
08:04:20 <ehird> @bawt
08:04:20 <rahaskella> Maybe you meant: fact part
08:04:22 <ehird> @bott
08:04:23 <rahaskella> Missing argument. Check @help <vote-cmd> for info.
08:04:26 <ehird> d'aww
08:04:37 <Lanken> damn...did anyone read anything I wrote just now?
08:04:41 <lilac> Lanken: electro-migration is where the electrons drag the interconnect along with them, breaking connections and making shorts
08:04:46 <vixey> > let interleave (x:xs) (y:ys) = x:y:interleave xs ys in (repeat 'x' `interleave` repeat 'y')`interleave`(repeat 'p' `interleave` repeat 'q')
08:04:50 <rahaskella>  "xpyqxpyqxpyqxpyqxpyqxpyqxpyqxpyqxpyqxpyqxpyqxpyqxpyqxpyqxpyqxpyqxpyqxpyqxpy...
08:04:57 <Saizan> > let interleave [] ys = ys; interleave (x:xs) ys = x : interleave ys xs in (interleave [1] [],interleave  [] [1],interleave [1,2] [3])
08:05:01 <rahaskella>  ([1],[1],[1,3,2])
08:05:05 <Lanken> lilac: what's the interconnect?
08:05:42 * ehird implements a markov chain in haskell for the laffs.
08:05:49 <lilac> the routing tracks connecting the cells together
08:05:59 <ehird> lessee... markov :: [a] -> [a]
08:06:02 <ehird> that's unhelpful
08:06:03 <ehird> oh
08:06:04 <ehird> Eq a
08:06:05 <xerox> ehird: I'm interested in the code, where can I find it when you're done? :)
08:06:12 <Lanken> lilac: a strip of conductive stuff?
08:06:16 <ehird> xerox: hpaste, probably. it'll just be a simple one
08:06:20 <lilac> Lanken: yep
08:06:40 <ehird> xerox: though I do have the scraps around for this thing called mvldo I was working on - basically, it was a bot that had one purpose and that was to convince people on irc that it was a real human
08:06:44 <ehird> xerox: it had some nifty ideas behind it
08:07:28 <Lanken> lilac: ok, so...to put this in a context that I'll understand well, a diode would stop working right if the electrons dragged the conductor far into, or through, the more resistive parts
08:08:19 <ehird> so let's see..
08:08:37 <lilac> Lanken: for instance, yes. as I understand it, it's usually the connections between components rather than within components which go first, though.
08:08:42 <ehird> markov = reapText . buildProbs
08:08:44 <ehird> well
08:08:48 <ehird> reap . analyze
08:08:58 <Lanken> lilac: that's the part that I don't get...isn't that a long distance?
08:09:14 <Lanken> (comparatively)
08:09:33 <lilac> Lanken: it depends. via stacks (vertical connections between routing layers) aren't typically very long.
08:09:45 <Lanken> oh, right...
08:09:48 <Lanken> it's a wafer
08:09:56 <ehird> analyze :: (Ord a) => [a] -> Map a Integer
08:10:00 <ehird> build a map of occurences.
08:10:00 <Lanken> I was thinking in two dimensions
08:10:04 <ehird> hm
08:10:10 <ehird> analyze is easiest to write an an imperative style :\
08:10:16 <Lanken> is 40 nm the thickness of a layer?
08:10:54 <ehird> well, let's try and specify it in a functional way
08:11:03 <Philippa> you'll get a fold
08:11:09 <ehird> collect the ocurrences of each unique word in it
08:11:10 <ehird> Philippa: yep
08:11:14 <ehird> a fold on a Map
08:11:20 <Lanken> yeah, so interconnects "run by each other" in close proximity all the time
08:11:20 <Philippa> no, a fold on the list
08:11:23 <ehird> Philippa: yes
08:11:26 <ehird> but also on a map
08:11:27 <Lanken> sometimes even parallel
08:11:38 <Saizan> ehird: the map will be the accumulator
08:11:43 <ehird> Saizan: exactly
08:11:58 * ehird picks a fold ... well, should be equiv. for any fold, so foldl'
08:12:03 <ehird> no need for laziness for this
08:12:13 <Philippa> ehird: that's an abuse of terminology. The fold's /on/ the list, and returns a map
08:12:22 <ehird> Philippa: yes, sorry
08:12:38 <ehird> foldl' :: (a -> b -> a) -> a -> [b] -> a
08:12:43 <ehird> so, the a is the mMap
08:12:45 <ehird> and the b the list element.
08:12:46 <ehird> simple enough
08:13:40 <lilac> Lanken: the routing layers are directional, so within a layer, there's a lot of parallel routing. but the routing tools have design rules applied to them to control the crosstalk effects.
08:14:03 <ehird> geh, I am reminded again that Data.Map has no simple 'update or insert'
08:14:09 <Saizan> @pl foldl' (\m k -> M.insertWith (+) k 1 m) M.empty
08:14:09 <rahaskella> foldl' (flip (flip (M.insertWith (+)) 1)) M.empty
08:14:16 <Saizan> :t foldl' (\m k -> M.insertWith (+) k 1 m) M.empty
08:14:23 <rahaskella> forall b a. (Ord b, Num a) => [b] -> M.Map b a
08:14:32 <ehird> Saizan: well thanks, I was kinda wanting to write my function myself there
08:14:39 <Lanken> lilac: you are blowing my mind.
08:15:01 <Lanken> (sorry for how offtopic this has gotten)
08:15:08 * ehird doesn't bother then
08:15:17 <vixey> Lanken: I just wish I understood it ..
08:15:18 <chessguy> @hoogle (a -> Bool) -> [a -> a] -> a
08:15:19 <rahaskella> A Hoogle error occured.
08:15:26 <Saizan> ehird: just to tell you map has a simple "update or insert"
08:15:27 <vixey> electrics always were against me
08:15:39 <ehird> Saizan: it's quite possible to do that without writing everything for me, thanks.
08:15:45 <chessguy> hm. i need an 'applyWhile'
08:16:12 <Bonus> make it with span?
08:16:13 <Saizan> ehird: ok, sorry
08:16:39 <ehird> Saizan: 'cause reaping is fairly trivial as opposed to the analyzing
08:16:42 <EvilTerran> chessguy, er, isn't that type empty? there's no (a)s coming in from anywhere
08:17:10 <chessguy> err, sorry
08:17:12 <Bonus> applyWhile p f = let (a,b) = span p in map f a ++ b
08:17:20 <Bonus> how does that look
08:17:31 <chessguy> (a -> Bool) -> [a -> a] -> a -> a
08:17:33 <vixey> bonus: what should it do?
08:17:41 <chessguy> @type span
08:17:44 <Bonus> wait no
08:17:48 <rahaskella> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:17:52 <chessguy> Bonus: i'm not familiar with span
08:17:59 <Bonus> applyWhile p f lst = let (a,b) = span p lst in map f a ++ b
08:18:11 <Bonus> let me just try that
08:18:23 <EvilTerran> applyWhile p [] x = x; applyWhile p (f:fs) x | p x = applyWhile p fs (f x) | otherwise = x --?
08:18:27 <Lanken> lilac: here's something that I'm still confused about.  The wikipedia article keeps talking as though an instance of electromigration will affect one IC, but I'm imagining an event where the electrons "go off-road" and drag the copper with them to another interconnect.  Wouldn't two fail, then?
08:18:46 <Bonus> yeah
08:18:51 <chessguy> EvilTerran: something like that, yeah
08:18:55 <Bonus> applyWhile p f lst = let (a,b) = span p lst in map f a ++ b
08:18:59 <Bonus> this works pretty well
08:19:03 <chessguy> except i'd rather avoid explicit recursion
08:19:10 <chessguy> on principle
08:19:11 <Bonus> basically it will apply f to lst while predicate p is true
08:19:27 <vixey> chessguy :S why?
08:19:36 <Lanken> oh, no...there's something called an "interconnect controller," and that's making me think I understand even less.  A wire wouldn't need a controller.
08:20:35 <ehird> will I be slapped if I say I don't like yi?
08:20:40 <chessguy> vixey: it's generally a good idea
08:21:08 <chessguy> Bonus: that's not quite right
08:21:08 <vixey> why?
08:21:12 <allbery_b> I'm unimpressed with yi so far, but then it's still an early alpha
08:21:16 <allbery_b> (IMO)
08:21:28 <EvilTerran> > scanl (flip ($)) x [f,g,h] :: [Expr]
08:21:29 <chessguy> vixey: because, recursive patterns have already been encapsulated
08:21:31 <ehird> i think the problem is that haskell is just kinda crap as far as an elisp replacement goes.
08:21:32 <rahaskella>  [x,f x,g (f x),h (g (f x))]
08:21:45 <Bonus> chessguy why not
08:21:59 <chessguy> Bonus: you're applying p to the functions (i think)
08:22:10 <Bonus> uhh no i just tried it out, it works pretty nimcely
08:22:11 <Lanken> lilac: I think I'm getting it now.  The problem isn't that a new connection gets formed (between two ICs), it's that an IC breaks because two many electromigration events occur in a given vicinity.
08:22:35 <Bonus> Prelude> applyWhile (<= 3) (* 3) [1,2,3,4,5,6,7]
08:22:35 <Bonus> [3,6,9,4,5,6,7]
08:22:38 <EvilTerran> ?type \p fs x -> find (not.p) $ scanl (flip ($)) x fs
08:22:45 <rahaskella> forall b. (b -> Bool) -> [b -> b] -> b -> Maybe b
08:22:54 <vixey> > zipWith ((<= 3) *** (* 3)) [1,2,3,4,5,6,7]
08:22:57 <rahaskella>  Couldn't match expected type `b -> c'
08:23:01 <chessguy> Bonus: take another look at the type i gave :)
08:23:01 <vixey> > zipWith ((<= 3) &&& (* 3)) [1,2,3,4,5,6,7]
08:23:04 <rahaskella>  Couldn't match expected type `b -> c'
08:23:31 <ehird> @src iterate
08:23:32 <rahaskella> iterate f x =  x : iterate f (f x)
08:23:52 <chessguy> Bonus: (a -> Bool) -> [a -> a] -> a -> a -- or some rearrangement
08:23:53 <Bonus> ah i see
08:24:05 <ehird> @type fix (\recur p f x -> if p x then x : recur p f (f x) else [])
08:24:12 <rahaskella> forall a. (a -> Bool) -> (a -> a) -> a -> [a]
08:24:14 <Bonus> so in that case
08:24:19 <Bonus> what do you expect applyWhile to do
08:24:24 <Bonus> im sorry if its already been said
08:24:31 <Bonus> i just tuned in recently
08:24:36 <ehird> > let iterateWhile p f x = if p x then x : iterateWhile p f (f x) else []; iterate = iterateWhile (const True) in iterate id 1
08:24:37 <EvilTerran> ?type \p fs x -> last . takeWhile p . scanl (flip ($)) x $ fs
08:24:40 <chessguy> Bonus: keep applying functions from the list until the predicate is not satisfied
08:24:42 <rahaskella>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:24:46 <rahaskella> forall b. (b -> Bool) -> [b -> b] -> b -> b
08:24:53 <EvilTerran> chessguy, how's that?
08:24:56 <Bonus> applying them to what?
08:25:19 <chessguy> Bonus: the third parameter
08:25:22 <Bonus> ah
08:25:49 <vixey> applyWhile p f (x:xs) = if p x then f x : applyWhile p f xs else x:xs
08:25:55 <vixey> applyWhile _ _ [] = []
08:25:59 <chessguy> EvilTerran: i like it
08:26:39 <chessguy> EvilTerran: except i'd tend to write it as \p x -> last . takeWhile p . scanl (flip ($))
08:26:55 <chessguy> with an x at the end
08:27:01 <EvilTerran> true
08:27:18 <EvilTerran> i was keeping to the type you gave initially :)
08:27:25 <ehird> @type (\x -> foldl (\f x -> fx ) x)
08:27:30 <ehird> @type (\x -> foldl ($) x)
08:27:33 <rahaskella> Not in scope: `fx'
08:27:39 <rahaskella>     Occurs check: cannot construct the infinite type: b = a -> b
08:27:39 <rahaskella>     Probable cause: `$' is applied to too many arguments
08:27:39 <rahaskella>     In the first argument of `foldl', namely `($)'
08:27:42 <EvilTerran> ehird, your ($) is the wrong way round
08:27:46 <EvilTerran> ?type foldl (flip ($))
08:27:47 <vixey> what if these patters just obscure things?
08:27:47 <ehird> @type (\x -> foldl (flip ($)) x)
08:27:53 <rahaskella> forall b. b -> [b -> b] -> b
08:28:00 <rahaskella> forall b. b -> [b -> b] -> b
08:28:07 <chessguy> vixey: how so?
08:28:08 <ehird> > let pipeline = foldl (flip ($)) in pipeline 1 [succ,succ,succ]
08:28:13 <rahaskella>  4
08:28:16 <ehird> Cute.
08:28:33 <vixey> personally .. this last . takeWhile p . scanl thing seems baffling
08:28:40 <ehird> @pl foldl (flip ($))
08:28:41 <rahaskella> foldl (flip id)
08:28:47 <ehird> @. unp pl foldl (flip ($))
08:28:47 <Lanken> lilac: ok, I'm getting it.  Electromigration does, in fact, result in a gradual blurring of all the microchip's features.  But it happens unevenly.  Statistical variation is significant enough that in a long skinny interconnect, conductivity will be reduced by different amounts in different areas, and there's a "runaway" aspect to it, because the less conductivity you have, the faster electromigration occurs.
08:28:48 <rahaskella> Plugin `compose' failed with: Unknown command: "unp"
08:28:50 <ehird> @. unpl pl foldl (flip ($))
08:28:51 <rahaskella> foldl (\ b c -> c b)
08:28:55 <ehird> @. pl unpl pl foldl (flip ($))
08:28:56 <rahaskella> pl foldl (flip id)
08:29:01 <ehird> its official
08:29:04 <ehird> foldl (flip id) for the win
08:29:05 <lilac> Lanken: that sounds about right
08:29:12 <Lanken> lilac: http://en.wikipedia.org/wiki/Image:Leiterbahn_ausfallort_elektromigration.jpg
08:29:15 <ehird> OooOOoooohhh... I have an evil idea
08:29:18 <ehird> I am about to write GotoM.
08:29:25 * chessguy gasps
08:29:33 <ehird> chessguy: :-DDDDDDDDDd
08:29:39 <vixey> so how do you write an efficient interpreter for a lazy language in a strict one?
08:29:52 <Lanken> this picture shows a spot where it's gotten bad enough that the interconnect doesn't "work" anymore
08:29:59 <ehird> chessguy: test = do label "hello"; goto "hello"
08:30:02 <vixey> it seems clear how to do it in a lazy language, and compile to a strict language
08:30:17 <ehird> test = do label "hello"; liftIO $ putStrLn "hello world"; goto "hello"
08:30:17 <vixey> but what about interpreting in a strict language?
08:30:25 <lilac> vixey: thunks?
08:30:35 <ehird> label :: (Ord a) => a -> GotoT m (), fwiw
08:31:06 <vixey> lilac: can you get sharing from let with that?
08:31:07 <EvilTerran> ehird, er... is that not kinda like ContT?
08:31:19 <ehird> EvilTerran: Yes .. but continuations are functional, safe-y, nice gotos.
08:31:20 <EvilTerran> except with a risk of label collision
08:31:23 <ehird> EvilTerran: This is **EVIL**
08:31:31 <EvilTerran> you need a comefrom as well
08:31:51 <ehird> EvilTerran: Hey, ais523 does quite well maintaining C-INTERCAL thankyouverymuch. I don't think a haskell rewrite is warranted ;)
08:31:53 <lilac> vixey: sure, if you have multiple references to the same thunk, when you replace that thunk with the actual value in WHNF, you can arrange for them both to use it
08:32:07 <EvilTerran> ehird, everything is better as a haskell EDSL :D
08:32:21 <ehird> EvilTerran: Not really - you can't embed intercal's quoting rules into haskell
08:32:25 <ehird> EvilTerran: And those are crazy.
08:32:33 <vixey> cool
08:32:50 <EvilTerran> ... dammit. STOP DISTRACTING ME, INTERNET
08:32:58 * EvilTerran hides so he can get some work done
08:33:06 <ehird> :t callCC
08:33:14 <rahaskella> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
08:33:22 <lilac> vixey: as I understand it, that plus amazing amounts of cunning optimization is how ghc works
08:38:25 <geezusfreeek> ehird: sounds like Cont, except with runtime labels
08:38:31 <chessguy> conal: ping?
08:39:13 <conal> chessguy: hi
08:39:39 <chessguy> conal: i think i'm getting close to comprehending what you were driving at last night
08:39:50 <conal> :)
08:40:17 <chessguy> conal: so a TraversalF is a TreeTraversal applied to a particular type
08:40:45 <ehird>     `ContT r m' is not applied to enough type arguments
08:40:46 <ehird>     Expected kind `*', but `ContT r m' has kind `* -> *'
08:40:46 <ehird> beh
08:40:47 <ehird> :-)
08:40:51 <chessguy> rather than parameterizing TreeTraversal, when none of its current constructors are dependent on the type
08:41:06 <conal> chessguy: i don't remember TraversalF
08:41:12 <praseodym> is there any guide for backtracking in haskell? I need to solve a knapsack problem, and display all solutions that fit exactly.
08:41:21 <chessguy> conal: it was your idea: type TraversalF a = (TreeTraversal, a)
08:41:21 <geezusfreeek> conal: i got futures all written up using the type system, but my test reveals a stack overflow somewhere :(
08:41:33 <conal> chessguy: got it.
08:42:06 <conal> geezusfreeek: i peeked at your new Reactive.hs.  it's beautiful!!
08:42:25 <geezusfreeek> :)
08:42:37 <ehird> Has anyone here used hvac?
08:42:53 <vixey> > do x <- [2..12] ; y <- [3..15] ; x*y == 49 ; return (x,y) -- praseodym
08:42:54 <rahaskella>  Couldn't match expected type `[t]' against inferred type `Bool'
08:43:03 <vixey> > do x <- [2..12] ; y <- [3..15] ; guard (x*y == 49) ; return (x,y) -- oops
08:43:07 <rahaskella>  [(7,7)]
08:43:26 <vixey> > [ (x,y) | x <- [2..12] , y <- [3..15] , x*y == 49 ] -- alternatively
08:43:28 <conal> chessguy: i wouldn't say "applied to a particular type", but now i know what you mean.  and yeah, that sounds like what geezusfreeek & i were driving at.
08:43:29 <rahaskella>  [(7,7)]
08:43:46 <vixey> praseodym: for simple depth first searching list monad is fine
08:43:54 <chessguy> conal: so what i wanted to write was something like data TreeTraversal a = Up | Down | ... | If (a -> Bool) TreeTraversal TreeTraversal, but i can actually accomplish this somehow with a TraversalF
08:44:14 <conal> chessguy: yes, i think so.
08:44:25 <chessguy> and it will be more compositional
08:44:38 <chessguy> but i haven't figured out yet exactly how to do it
08:44:39 <Lanken> lilac: can you confirm that electromigration damage to interconnects is the next barrier facing moore's law?
08:45:14 <chessguy> Lanken: perhaps the physics discussion would be better held in #haskell-blah?
08:45:38 <Lanken> lilac: the moore's law article doesn't mention electromigration, nor vice versa
08:45:45 <Lanken> chessguy: sorry, this is about wound down anyway.
08:46:02 <Lanken> chessguy: that was my last question, but if there are any further we'll take it out.
08:46:40 <conal> chessguy: yeah.  it'll compose nicely while leaving the TreeTraversal type as simple as possible.
08:48:03 <conal> chessguy: i don't see that you've defined the question yet.
08:48:09 <geezusfreeek> *sigh*
08:48:18 <ehird> let question = question?
08:48:37 <geezusfreeek> err, wrong channel sorry
08:48:39 <conal> chessguy: e.g., one simple specific function you'd like to implement.
08:48:55 <dcoutts> hia conal, I think you wanted to talk to me about frp and cabal make
08:49:16 <chessguy> conal: i want to be able to construct new traversal, over a tree with values of type a, from a predicate on a's, and two other traversals
08:49:24 <praseodym> vixey: I understand that one as well, but I need something where the sum of any combination within a list equals a certain number. so I'm stuck there
08:49:41 <conal> dcoutts: i don't think so anymore.  i talked with paolino and with Saizan, and my conclusion is that the questions i'm interested in are outside the scope of the project.
08:49:53 <vixey> > sequence ["xyz","uv","jkl"]
08:49:57 <rahaskella>  ["xuj","xuk","xul","xvj","xvk","xvl","yuj","yuk","yul","yvj","yvk","yvl","zu...
08:50:06 <dcoutts> conal: right'o
08:50:07 <conal> chessguy: great.  write down a function name and a type signature.
08:50:16 <praseodym> vixey: e.g. [3,2,1,4] equals five would return [[2,3],[1,4]]
08:50:19 <lilac> Lanken: i don't know that it's the next barrier. leakage power is becoming a pretty big deal, as well as new fabrication techniques being needed, etc. anyway.  and now back to our regular scheduled programming...
08:50:38 <praseodym> vixey: and [3,2,1] of course, etc.
08:50:44 <vixey> praseodym: oh ok
08:50:48 <dcoutts> conal: I expect you're right, we've only got 3 months and we need something that works with the existing tools that do mutative things like read/write files
08:50:51 <vixey> praseodym: are the numbers ever repeated?
08:51:00 <Lanken> lilac: thanks much
08:51:07 <praseodym> vixey: they might be, yes
08:51:10 <vixey> praseodym: like [3,2,1,4] = 9 might give [3,3,1,1,1,1,1,1,1,1,1,1,1,1]
08:51:16 <chessguy> conal: conditionalTraversal :: (a -> Bool) -> TraversalF a -> TraversalF a -> TraversalF a
08:51:19 <conal> dcoutts: i'll pursue my questions as a research project.
08:51:35 <vixey> praseodym: let's start by making 1 special case, and adding it on at the very end if its' needed
08:51:40 <praseodym> vixey: oh, no. just [2,2,3,1] = 5 might give [2,2,1]
08:51:51 <vixey> oh ok
08:52:00 <vixey> I thought you were talking products, no sums
08:52:05 <dcoutts> conal: do keep us informed :-)
08:52:10 <chessguy> conal: i suspect now that i'll want to modify traverse :: TreeTraversal -> (TreeLoc a -> TreeLoc a) to take a TraversalF
08:52:20 <dcoutts> conal: I don't have a great attachment to doing things the way cabal does them atm.
08:52:30 <vixey> praseodym: In that case, I think you want to use select/3
08:53:19 <conal> dcoutts: will do.  i'm pretty sure where i'm going would lead to starting from scratch, and recasting the whole problem functionally.
08:53:30 <praseodym> vixey: what's that?
08:54:05 <maltem> is there a Word8 equivalent of getChar somewhere? (except converting the character)
08:55:00 <conal> chessguy: i forget what traverse was. is it in the paste?
08:55:14 <chessguy> conal: yes, it's the interpreter
08:55:27 <chessguy> err, rather, it calls the interpreter
08:55:53 <conal> chessguy: oh -- i see it.
08:56:20 <EvilTerran> maltem, don't think so. either use ((toEnum.fromEnum) `fmap` getChar) or (BS.head `fmap` BS.get), i guess.
08:56:37 <lilac> @hoogle m [a] -> m [a] -> m [a]
08:56:37 <rahaskella> A Hoogle error occured.
08:56:56 <maltem> EvilTerran, do you have a guess which is the more efficient?
08:57:03 <EvilTerran> er, s/BS.get/BS.hGet stdin 1/
08:57:10 <lilac> @hoogle Monad m, MonadPlus p => m (p a) -> m (p a) -> m (p a)
08:57:11 <rahaskella> A Hoogle error occured.
08:57:15 <vixey> @let select [] = mzero ; select (x:xs) = return (x,xs) `mplus` do (e,ys) <- select xs ; return (e,x:ys)
08:57:17 <EvilTerran> no idea. i'd go for the first one, tbh.
08:57:18 <rahaskella> Defined.
08:57:26 <vixey> > select [2,2,3,1]
08:57:28 <rahaskella>   add an instance declaration for (Show (m (t, [t])))
08:57:29 <EvilTerran> unless you're already using ByteStrings
08:57:34 <conal> chessguy: maybe something a bit simpler.  are you going to use addZipper just once?
08:57:39 <vixey> > select [2,2,3,1] :: [(Integer,Integer)]
08:57:42 <rahaskella>  Couldn't match expected type `Integer'
08:57:51 <conal> chessguy: i expect you'll want to use addZipper once and getNode  a few times
08:57:56 <conal> chessguy: (many times)
08:58:02 <chessguy> conal: yes, conceivably
08:58:23 <conal> so how about a function that just combines interpret and getNode?
08:58:24 <maltem> EvilTerran, alright, thanks
08:58:32 <lilac> > select [2,2,3,1] :: [Integer, [Integer]]
08:58:33 <rahaskella>  Parse error at "," (column 29)
08:58:41 <conal> chessguy: since i bet you'll want to do that often
08:58:42 <lilac> > select [2,2,3,1] :: [(Integer, [Integer])]
08:58:46 <rahaskella>  [(2,[2,3,1]),(2,[2,3,1]),(3,[2,2,1]),(1,[2,2,3])]
08:59:53 <ehird> :t select
09:00:00 <rahaskella> forall t (m :: * -> *). (MonadPlus m) => [t] -> m (t, [t])
09:00:02 <vixey> @let nap n s = do (d,ss) <- select s ; guard (n`divides`d) ; res <- nap (n`div`d) ss ; return (d:res) where x `divides` y = x`mod`y == 0
09:00:03 <ehird> stupid slow rahaskella
09:00:05 <rahaskella> Defined.
09:00:14 <vixey> > nap 5 [2,2,3,1]
09:00:17 <rahaskella>   add an instance declaration for (Show (t [t1]))
09:00:25 <vixey> > (nap 5 [2,2,3,1]) :: [[Integer]]
09:00:29 <rahaskella>  []
09:01:22 <dejones> is there a way to do multi-line strings in Haskell?  I think Python uses """
09:01:27 <vixey> @let nap n [x] | x == n = return [x] | otherwise = [] ; nap n s = do (d,ss) <- select s ; guard (n`divides`d) ; res <- nap (n`div`d) ss ; return (d:res) where x `divides` y = x`mod`y == 0
09:01:29 <rahaskella> <local>:3:0:     Warning: Pattern match(es) are overlapped              In th...
09:02:11 <Armored_Azrael> Hey, does anyone know how to get 64-bit ghc to produce 32-bit output?
09:02:30 <Armored_Azrael> I have to link against a C program that won't compile 64-bit.
09:02:45 <lilac> @pl \a b -> (a >>= (++ b))
09:02:45 <rahaskella> (. flip (++)) . (>>=)
09:04:19 <dejones> is there a way to do multi-line strings in Haskell?  I think Python uses """  --- Yes, just use \ escape the end of the line and \ where you want the line to start again.  :)  From here: http://www.haskell.org/pipermail/haskell-cafe/2006-January/013911.html
09:04:48 <chessguy> conal: hm. i'm still going to want to make interpret take a TraversalF, right?
09:05:40 <conal> chessguy: i didn't think so, but right now, i'm not seeing where i was expecting this all to go yesterday.
09:06:52 <lilac> @pl \a b -> a >>= (\c -> b >>= return.(c++))
09:06:52 <rahaskella> liftM2 (++)
09:07:03 <conal> chessguy: i definitely wouldn't expect to make interpret take a TraversalF.
09:09:17 <lilac> > ((repeat 5) `liftM2 (++)` (repeat 3)) a
09:09:17 <rahaskella>  Parse error at "(++)`" (column 21)
09:09:20 <vixey> @let nap n xs = do (e,ys) <- select xs ; if e == n then [e] : nap n ys else if n > e then do es <- nap (n-e) ys ; return (e:es) else []
09:09:23 <rahaskella> <local>:1:24: Not in scope: `select'
09:09:34 <vixey> @let let select [] = [] ; select (x:xs) = return (x,xs) `mplus` do (e,ys) <- select xs ; return (e,x:ys)
09:09:35 <rahaskella>  Parse error
09:09:48 <lilac> > let +^+ = liftM2 (++) in ((repeat 5) +^+ (repeat 3)) a
09:09:49 <rahaskella>  Parse error at "+^+" (column 5)
09:09:56 <conal> chessguy: i'm having second thoughts about that TraversalF type.
09:09:58 <lilac> > let (+^+) = liftM2 (++) in ((repeat 5) +^+ (repeat 3)) a
09:10:01 <rahaskella>  Couldn't match expected type `t1 -> t' against inferred type `[t2]'
09:10:05 <vixey> @let select [] = [] ; select (x:xs) = return (x,xs) `mplus` do (e,ys) <- select xs ; return (e,x:ys)
09:10:08 <rahaskella> Defined.
09:10:09 <vixey> @let nap n xs = do (e,ys) <- select xs ; if e == n then [e] : nap n ys else if n > e then do es <- nap (n-e) ys ; return (e:es) else []
09:10:10 <conal> chessguy: do you know about the Writer monad?
09:10:12 <rahaskella> Defined.
09:10:16 <vixey> > nap 5 [2,2,3,1]
09:10:19 <rahaskella>  [[2,2,1],[2,3],[2,2,1],[2,1,2],[2,1,2],[2,2,1],[2,3],[2,2,1],[2,1,2],[2,1,2]...
09:11:01 <vixey> you could use (e:es) <- tails, rather than select too
09:11:32 <praseodym> :)
09:11:47 <praseodym> why does it give a lot of duplicates though?
09:12:02 <vixey> is [1,1,2] the same as [1,2,1]
09:12:25 <praseodym> good point. I'd consider it to be
09:12:31 <chessguy> conal: um, i've heard of it
09:12:39 <vixey> > select "xyz"
09:12:43 <rahaskella>  [('x',"yz"),('y',"xz"),('z',"xy")]
09:12:59 <vixey> < tails "xyz"
09:13:01 <vixey> [('x':"yz"),('y':"z")]
09:13:08 <vixey> oops
09:13:13 <vixey> [('x':"yz"),('y':"z"),('z':"")]
09:13:39 <vixey> soo that's the diference between select and tails or whatever it's called in this context
09:14:06 <lilac> why can't i put an arbitrary expression within ``? eg, `liftM2 (++)`
09:14:08 <vixey> there is still the issue of having duplicates in the input leading to duplicates in the output though
09:14:14 <vixey> but you can just nub there
09:14:19 <praseodym> 4
09:14:22 <praseodym> oops
09:14:32 <praseodym> I think that's the best thing to do indeed
09:14:36 <praseodym> thanks for the help!
09:14:37 <vixey> lilac: It's not haskell
09:14:54 <lilac> vixey: hmm. maybe it should be haskell' ? ;-)
09:14:58 <vixey> lilac: I agree
09:15:06 <vixey> lilac: but I haven't bothered ot write a parser yet
09:15:15 <vixey> wait
09:15:16 <vixey> no
09:15:23 <vixey> I didn't see that '
09:15:37 <vixey> I think it should be part of haskell, I don't care about haskell'
09:16:05 <conal> chessguy: the TraversalF i suggested is equivalent to the Writer monad.  guesing where you're going, i expect you'll want the State monad, just as you started with.  you can still probably keep the TreeLoc vocabulary you started with (down, up, turn).
09:17:00 <conal> chessguy: and i think the monadic framework will work very well for you *except* for the Show part.
09:17:17 <chessguy> hmm
09:17:36 <chessguy> so perhaps all i really need is a LabelledTraversal
09:17:50 <conal> chessguy: the reason is that (>>=) takes a function.
09:18:43 <chessguy> data LabelledTraversal = LT String Traversal
09:18:46 <conal> chessguy: if Applicative were enough for you, then Show isn't such a challenge.
09:18:46 <chessguy> or some such blather
09:19:09 <conal> chessguy: in other words LabelledTraversal = TraversalF String
09:19:09 <chessguy> conal: what do you mean?
09:19:32 <conal> chessguy: about Monad vs Applicative and the Show problem?
09:19:38 <chessguy> yes
09:20:04 <conal> chessguy: the basic Monad composition operator is (>>=), whose second argument has function type.
09:20:44 <conal> chessguy: which means that you can't Show it.  so you come up with an algebraic representation: TreeTraversal.
09:21:06 <conal> chessguy: but as you've noticed, a lot of flexibility is lost and must be regained.
09:21:16 <conal> chessguy: flexibility that comes from (>>=)
09:22:01 <chessguy> yes
09:22:14 <chessguy> and a similar issue with arbitrary
09:22:47 <chessguy> ^arb^Arb
09:23:18 <conal> chessguy: oh yeah!  arbitrary.  perhaps Arbitrary isn't really feasible.
09:23:41 <conal> chessguy: you can make an Arbitrary for some *subset* of TreeLoc->TreeLoc functions.
09:24:03 <chessguy> right
09:24:25 <conal> chessguy: but that Arbitrary isn't very arbitrary.
09:24:36 <conal> chessguy: it misses most of the possibilities.
09:24:44 * chessguy sighs
09:24:53 <conal> chessguy: oh! hm.  Arbitrary has a function instance.
09:25:00 <chessguy> i suspect i just need to go back to building domain-specific traversals
09:25:21 <conal> chessguy: maybe, but i doubt it.
09:25:49 <conal> chessguy: i think another angle on the problem will make things simple and still general.
09:25:56 <chessguy> oh?
09:26:15 <twobitsprite> howdy
09:26:27 <twobitsprite> how do you dynamically load modules in haskell?
09:26:42 <conal> chessguy: here's how i see what you're doing.  you already had a simple semantic model -- your state monad (though i'd change it a bit, now that i understand better what you're up to).
09:26:43 <twobitsprite> i.e., from a compiled program, not from ghci or whatever
09:26:54 <nolrai_> hey, I have a more complicated question. Um. I want a data type that represents the presense or absence of paths from the four sides of a square to each other,
09:27:17 <conal> chessguy: and you then defined a sort of "term language" (the algebraic type) with a semantic function that maps into your semantic model.
09:27:26 <conal> chessguy: (interpret)
09:27:32 <chessguy> yes
09:27:35 <nolrai_>  with the complication that I want paths to be transitive, e.g. if the top is conected to the left and the left is conected to the bottom then the top is conected to the bottom.  Is there a way to do this?
09:28:10 <conal> chessguy: the term language is interfering with the simplicity and/or generality that you had to start with.
09:28:28 <conal> chessguy: let's explore whether you can eliminate the term language without losing anything important.
09:28:58 <conal> chessguy: doing more of a pure Haskell embedding (dsel).
09:28:58 <chessguy> conal: ok. the purpose of the term language was to be able to instantiate Arbitrary and Show easily
09:29:09 <twobitsprite> I mean, I assume you can load modules dynamically because ghci does it... but how do you do it from a compiled program?
09:29:26 <conal> chessguy: ok.  i'm not sure about Show, so let's start with Arbitrary.
09:29:42 <conal> chessguy: are you sure that your original model isn't in Arbitrary?
09:29:52 <conal> chessguy: (i.e., *already* in Arbitrary)
09:30:09 <chessguy> umm, no
09:30:27 <conal> chessguy: me neither!
09:30:35 <chessguy> functions certainly are in Arbitrary
09:30:50 <conal> chessguy: yep.  :)
09:30:55 <gwern> @where wash
09:30:56 <rahaskella> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
09:32:10 <chessguy> conal: looks like there's little monadic support in Arbitrary: http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html#t%3AArbitrary
09:32:49 <conal> chessguy: what are you seeing?
09:33:09 <chessguy> seeing?
09:33:18 <conal> chessguy: what monadic support?
09:33:31 <chessguy> conal: very little
09:33:33 <conal> chessguy: i'm looking at that page and not seeing what you mean
09:33:43 <conal> chessguy: it doesn't matter.  we don't want monadic support
09:33:54 <conal> chessguy: we want support for the types used in your model
09:33:58 <gwern> I wonder if there are any more recent versions of wash
09:34:11 <chessguy> conal: i thought we wanted State (TreeLoc a) a to be Arbitrary
09:34:25 <chessguy> or are we staying with the TreeLoc -> TreeLoc
09:34:26 <conal> chessguy: yes.  and whether those types are Monad won't help or hurt.
09:34:36 <conal> chessguy: what's the definition of State?
09:35:31 <chessguy> well, it is a function, semantically
09:35:41 <chessguy> just not notationally
09:36:02 <conal> chessguy: yep.  so either (a) State is already declared as Arbitrary, or (b) it could be.
09:36:16 <chessguy> conal: ok, fair enough
09:36:31 <conal> chessguy: and since the *representation* of State is just a newtype wrapper around a function, an Arbitrary instance could probably be derived automatically.
09:36:45 <conal> chessguy: with the recent "standalone deriving" language feature
09:37:01 <chessguy> so we're back to the Show problem
09:37:22 <gwern> hey, could someone try to 'cabal install mersenne-random'?
09:37:32 <conal> chessguy: assuming this Arbitrary idea works out.  but yeah, sooner or later, we have to address Show.
09:37:59 <conal> chessguy: why do you want Show?
09:38:17 <conal> chessguy: (finding out more about the range of possibilities)
09:38:59 <chessguy> conal: because these values are the solution i'm looking for, so i have to be able to represent them somehow
09:39:32 <conal> chessguy: you're doing a search problem, and the traversals are the solutions?
09:39:43 <chessguy> conal: yes!
09:39:53 <conal> chessguy: okay.  i hadn't figure that part out yet.
09:39:58 <dcoutts> gwern: I've already got the latest version installed
09:40:04 <chessguy> conal: well, the traversals show how to derive the solution
09:40:18 <chessguy> conal: have you read the readme file on my project?
09:40:26 <conal> chessguy: when you say "represent them"  do you mean "present them" to a human.
09:40:30 <conal> chessguy: no, i haven't
09:40:34 <chessguy> oh!
09:40:37 <chessguy> well, silly me
09:40:40 <monochrom> What a stupid thread pretending to be "MD5 performance" but actually content-free bitching.
09:40:47 <chessguy> yes, that's what i mean
09:40:58 <conal> chessguy: you pointed me to the readme yesterday, i think.  i started reading it, got distracted, and forgot all about it.
09:41:03 <monochrom> And it's the longest, too.
09:41:15 <boegel> @seen gwern
09:41:16 <rahaskella> gwern is in #haskell. I last heard gwern speak 3m 53s ago.
09:41:16 <chessguy> conal:  no wonder you're not sure where i'm going :)
09:41:20 <chessguy> conal: http://code.haskell.org/ChessLibrary/README.txt
09:41:21 <boegel> gwern: ping!
09:41:35 <conal> chessguy: thx
09:41:57 <conal> chessguy: do you know how to make firefox line-wrap?
09:42:44 <conal> chessguy: if not, no problem.  i'll copy to an emacs buffer.
09:43:21 <chessguy> conal: i don't off-hand
09:44:18 <gwern> dcoutts: so it cabal-installed for yu? that's strange; it gave me an error like 'configure type declared but configure script not found'
09:44:24 <gwern> dcoutts: worked fine manually tho
09:44:28 <gwern> boegel: 'lo
09:44:47 <dcoutts> gwern: yeah, it did install ok for me it seems
09:45:42 <gwern> (annoyingly, the darcs mersenne-random uses build-type: simple, so I can't even report an error to dons)
09:46:09 <nolrai_> what is an inductive graph?
09:46:24 <conal> chessguy: okay.  read it now.
09:46:40 <chessguy> conal: so a traversal is essentially a chess engine
09:47:01 <conal> chessguy: i don't think my suggestion about using State's Arbitrary is a good one.
09:47:03 <chessguy> given a chess position, you can turn it into a tree, and apply the traversal to it
09:47:17 <conal> chessguy: because it'll generate really crazy state transitions.
09:47:31 <conal> chessguy: your TreeTraversal type makes more sense to me.
09:48:27 <chessguy> conal: oh, the other thing that just occurred to me is that TreeTraversal makes genetic evolution more possible, too
09:48:30 <conal> chessguy: one question i wonder is whether a TreeLoc->TreeLoc model is enough, rather than the State TreeLoc b
09:48:46 <conal> chessguy: evolution of what?
09:48:54 <chessguy> conal: traversals!
09:49:02 <chessguy> traversals/engines
09:49:26 <conal> chessguy: oh okay, which makes sense *if* the conditionals are in there.  right?
09:49:29 <nolrai_> if one wanted a data type that consisted of an unorderd pair of disjoint sets, what would you use?
09:49:37 <chessguy> conal: yes
09:49:43 <conal> chessguy: the nature of the BoolExpr is pretty critical then.
09:49:49 <chessguy> and other domain-specific stuff
09:49:54 <nolrai_> (very small sets, max of 4 between them).
09:50:10 <chessguy> conal: the nature of it?
09:50:21 <conal> chessguy: the define of the type BoolExpr
09:50:36 <chessguy> conal: ah. yes
09:50:40 <conal> chessguy: e.g., one choice is 'TreeLoc a -> Bool'
09:51:03 <conal> chessguy: which is a general as you'd want, but maybe challenging for Show and Arbitrary.
09:51:33 <chessguy> i was thinking that BoolExpr could just be another algebraic type
09:51:44 <chessguy> with domain-specific predicates
09:51:47 <conal> chessguy: sure.  assuming the predicates are adequate (somehow), do you really think you'll need any more extensibility?
09:53:05 <chessguy> conal: well, i'll want to allow the client to provide their own domain-specific algebraic type, i think
09:53:30 <conal> chessguy: for anything other than the BoolExpr?
09:53:40 <conal> chessguy: if not, i think there's a simple solution.
09:53:59 <conal> chessguy: but if so, i'm missing part of what you're wanting to accomplish
09:54:25 <chessguy> i think that may be it
09:54:36 <conal> chessguy: (which?)
09:55:05 <chessguy> i think BoolExpr may be the only thing i want the client to be able to extend. anything else can be built from what i have, i think
09:55:30 <conal> chessguy: great.  let's assume that's the case, for now.  revisit if necessary.
09:55:38 <chessguy> conal: fair enough
09:55:44 <conal> chessguy: then how about parameterizing your TreeTraversal type over BoolExpr?
09:56:07 <maltem> @tell Baughn I tried to come up with a simple patch for the hGetLine buffering issue and sent it
09:56:07 <rahaskella> Consider it noted.
09:56:17 <chessguy> hrm
09:56:33 <maltem> Uh, yet another lambdabot today
09:56:51 <chessguy> conal: but BoolExpr will need to be instances of Show and Arbitrary too
09:56:59 <conal> chessguy: exactly
09:57:20 <conal> chessguy: when you implement your TreeTraversal operations, some type constraints on BoolExpr will surface.
09:57:37 <chessguy> well, i _want_ those constraints
09:57:41 <chessguy> i'm just not sure how to make them
09:57:54 <conal> chessguy: those type constraints will tell clients what they have to provide in order to use your generic engine.
09:58:22 <conal> chessguy: it's like (==) on lists.
09:58:33 <lilac> @hoogle [Either a b] -> [a]
09:58:34 <rahaskella> A Hoogle error occured.
09:58:59 <conal> chessguy: if i want Eq on [a], i have to choose an 'a' in Eq.
09:59:33 <chessguy> conal: yes
09:59:51 <boegel> is rahaskella a port of lambdabot?
10:00:07 <chessguy> conal: i'm just not sure where i actually implement that constraint
10:00:12 <boegel> @vixen are you in any way related to lamdbabot?
10:00:13 <rahaskella> no, why? do i seem "botty"?
10:00:24 <conal> chessguy: same as with [].  you don't.  the client does.
10:00:26 <boegel> @vixen you do! is lambdabot your sister?
10:00:27 <rahaskella> why does everyone ask i'f on a bot?
10:00:51 <conal> chessguy: the [] functions define the constraints and the clients satisfy the constraints.
10:00:52 <boegel> @vixen please answer the question!
10:00:52 <rahaskella> maybe i don't know the answer?
10:00:56 <boegel> :)
10:01:06 <boegel> @vixen yes or no will do...
10:01:07 <rahaskella> no?
10:01:10 <boegel> lol
10:01:16 <ehird> @vixen what is vixen powered by?
10:01:17 <rahaskella> all women have a little vixen in them... just some more than others
10:01:22 <ehird> ok, women
10:01:26 <boegel> :)
10:01:27 <olsner> @bot
10:01:27 <rahaskella> :)
10:01:37 <chessguy> conal: so the constraint goes in interpret?
10:01:49 <conal> chessguy: yes!  in the type signature.
10:01:55 <chessguy> ah, got it
10:01:57 <boegel> ehird: lambdabot is female too, see http://www.cse.unsw.edu.au/~dons/lambdabot.html
10:02:07 <conal> chessguy: when you parameterize over BoolExpr and start implementing 'interpret' etc, ghc will be forced to discover and state all the constraints you need.
10:02:45 <conal> chessguy: if you write the type signature without the constraints, ghc will tell you what to add.
10:02:48 <chessguy> interpret :: (Show boolExpr, Arbitrary boolExpr) => TreeTraversal boolExpr -> (TreeLoc a -> TreeLoc a)
10:03:12 <conal> chessguy: yes, for starters.  you'll discover at least one more.
10:03:20 <chessguy> one more what?
10:03:24 <conal> constraint.
10:03:27 <chessguy> oh
10:03:42 <lilac> :t (==>)
10:03:50 <rahaskella> forall a. (Testable a) => Bool -> a -> Property
10:05:07 <conal> chessguy: one suggestion: come up with a replacement for "Expr" as that term will probably bias your thinking about that type argument.
10:06:09 <conal> chessguy: since it needn't be a kind of "expression".
10:06:25 <Baughn> maltem: Replacing the error branch I assume. And you /did/ test it on EOF, right? ;)
10:06:26 <rahaskella> Baughn: You have 1 new message. '/msg rahaskella @messages' to read it.
10:06:42 <ehird> @messages
10:06:42 <rahaskella> You don't have any new messages.
10:06:44 <ehird> :<
10:06:52 <Baughn> @messages
10:06:52 <rahaskella> You don't have any new messages.
10:06:57 <Botje> -- Module-internal state. Hang on to lambdabot's handles
10:06:59 * Botje giggles
10:07:15 <Baughn> Oh. Whee. It's not identified, and I've got filtering n.
10:07:18 <Botje> lambdabot has lambda handles!
10:07:20 * Baughn wonders what the message was
10:07:30 <gwern> huh. one of my emails to haskell-cafe is being held for moderation
10:07:37 <gwern> its crime is having 'suspicious headers'
10:07:43 <ehird> hm
10:07:52 <ehird> ReaderT is like StateT minus updating
10:07:53 <ehird> yes?
10:07:56 <ehird> WriterT vise versa
10:08:14 <luqui> i disagree with the WriterT part of that
10:08:24 <ehird> luqui: OK, just the readert part then
10:09:37 <chessguy> conal: http://hpaste.org/7731
10:10:06 <chessguy> (brb, dog needs a walk)
10:10:06 <vixey> gwern :D
10:10:11 <nolrai_> @pl \a b (a == A && b == B) || ( a == B && b == A)
10:10:12 <rahaskella> (line 1, column 9):
10:10:12 <rahaskella> unexpected "="
10:10:12 <rahaskella> expecting operator or ")"
10:10:21 <nolrai_> @pl \a b -> (a == A && b == B) || ( a == B && b == A)
10:10:22 <rahaskella> ap (ap . ((||) .) . (. (B ==)) . (&&) . (A ==)) ((. (A ==)) . (&&) . (B ==))
10:10:34 <conal> @localtime chessguy
10:10:56 <nolrai_> ugh.
10:12:51 <chessguy> conal 1:12
10:14:14 <conal> chessguy: where are you?
10:14:21 <chessguy> northern virginia
10:14:28 <conal> oh! :)
10:14:51 <conal> chessguy: let me know when you return from the walk
10:14:57 <chessguy> i'm back :)
10:15:07 <conal> oh :)
10:15:34 <conal> chessguy: the paste looks good, so far.  now add the conditional constructor.
10:15:34 <chessguy> it was just a potty walk, not an exercise walk :)
10:16:17 <conal> chessguy: do you live in city or country?
10:16:26 <chessguy> conal: i thought the client was supposed to add the constructor
10:16:46 <chessguy> conal: somewhere in between. i'm about 40 minutes outside DC
10:17:29 <conal> chessguy: the client will specify the *type* of conditional (BoolExpr) and the specific conditional value to go into a TreeTraversal value.
10:17:54 <conal> chessguy: you'll need a constructor to hold the conditional value
10:18:13 <conal> chessguy: the point of the parameterization is to allow that conditional type to be defined elsewhere
10:19:25 <chessguy> conal: oh, i see. like this? http://hpaste.org/7731#a1
10:20:18 <conal> chessguy: exactly!
10:20:43 <conal> chessguy: and what's missing still?
10:21:23 <chessguy> oh, the interpretation
10:21:39 <conal> chessguy: yeah.  btw, if you're not already doing it, use "{-# OPTIONS_GHC -Wall #-}" to get these clues from ghc.
10:22:10 <conal> chessguy: ghc with -Wall is my programming assistant.
10:22:46 <nolrai_> is there a nicer way to do: test a b = test' a b || test' b a; test' --lots of pattern matching--; I would realy like the test b a to be a pattern match but i cant see how to keep that from looping.
10:23:06 <schee_> shit. a whole chapter dedicated to parsing binary files :(
10:23:08 <vixey> nolrai:
10:23:15 <vixey> test Foo Foo = ...
10:23:22 <vixey> test Foo Bar = ..
10:23:29 <vixey> test x y = y x
10:23:35 <vixey> er test y x I meant
10:23:42 <vixey> if you put it last, it's always checked last
10:24:15 <vixey> (and I missed the Bar Bar case, but .. same idea)
10:24:30 <nolrai_> oh, right.
10:24:57 <luqui> I don't actually like that idiom very much, vixey.  It always makes me uneasy that if I missed a case I'll get into an infinite loop.
10:25:29 <vixey> luqui: which is exactly what I did :S
10:25:53 <vixey> maybe test' is smarter then
10:26:33 <chessguy> conal: hm, so i guess the client needs to supply a function from 'conditional' to Bool, too?
10:27:04 <schee_> What means    import qualified .... ?
10:27:17 <nolrai_> yeah and i whant a default case of test _ _ = False, too. So.. slight uneligance it is.
10:27:29 <conal> chessguy: yes, directly or via a type class.
10:27:46 <schee_> Also why can I not get the :type of import?
10:27:57 <dmwit> schee_: import is not a function
10:28:02 <schee_> ??
10:28:11 <vixey> nolrai: what does it test by that way?
10:28:11 <dmwit> schee_: "import" is a keyword that pulls in the functions from a module.
10:28:14 <schee_> dmwit: That's odd.
10:28:21 <chessguy> conal: is there a typeclass for that?
10:28:27 <schee_> dmwit: what means import qualified?
10:28:28 <dmwit> schee_: Think "#include" if you're from C, although they're not exactly the same.
10:28:40 <schee_> dmwit: Ya. It just rhymes bad with "purely functional" in my mind here.
10:28:41 <conal> chessguy: not yet (afaik)
10:29:04 <dmwit> schee_: It doesn't put things in the top-level namespace, it puts it in the "qualified" namespace, i.e. as the module name, followed by a dot, followed by the function name.
10:29:05 <shachaf> schee_: What is the type of "="?
10:29:08 <schee_> C :S
10:29:16 <vixey> = doesn't have a type
10:29:23 <schee_> shachaf: I have no idea. I can't seem to get ghci to tell me.
10:29:29 <shachaf> Nor does import. :-)
10:29:34 <chessguy> conal: well, that's silly
10:29:50 <schee_> Why it does not have a type though=
10:29:50 <chessguy> though it's a very simple class
10:29:51 <schee_> ?
10:29:54 <dmwit> schee_: So "import qualified Data.List" would get put "Data.List.nub" in scope, but not "nub".
10:30:21 <dmwit> schee_: ...because "=" is not a function!
10:30:25 <Saizan> schee_: purely functional don't require that everything is a function.. e.g. "=" is just syntax to define functions
10:30:31 <conal> chessguy: i define lots of these simple type classes, for flexibility+convenience.
10:30:34 <dmwit> schee_: It doesn't map inputs to outputs; it binds names to values.
10:30:40 <dmwit> schee_: They're completely different!
10:30:44 <schee_> Ugh. This is too confusing.
10:30:51 <dmwit> !
10:31:11 <ehird> schee_: what type COULD = have
10:31:13 <vixey> dmwit: that sounds like the same thing
10:31:15 <ehird> that makes NO SENSE
10:31:17 <dmwit> This is like complaining that "Int" is not a function.  It's a very confusing complaint.
10:31:23 <schee_> ehird: I have no idea. I'm not a haskell wiz.
10:31:24 <conal> chessguy: it's a nice way to define what your generic code needs from a type without overconstraining it.
10:31:35 <vixey> all lambda does it bind names
10:31:39 <ehird> schee_: there's nothing it could return
10:31:43 <ehird> nothing it could take as its first name param
10:31:45 <ehird> it makes no sense
10:31:51 <schee_> hmmm.
10:31:52 <ehird> its just syntax
10:31:55 <chessguy> conal: agreed. i'm just surprised there aren't more such classes in the library
10:32:20 <schee_> Very confusing :(
10:32:30 <ehird> schee_: err
10:32:32 <conal> chessguy: yeah.  type classes are i think discovered by noticing common patterns over time.
10:32:32 <ehird> not confusing at all
10:32:33 <ehird> :-)
10:32:39 <schee_> Well I'll give it another week or five and maybe it makes sense.
10:33:03 <dmwit> schee_: Well, for now, just remember that only identifiers can have a type.
10:33:14 <schee_> dmwit: What are identifiers?
10:33:24 <dmwit> schee_: Things that appear on the LHS of an = sign. ;-)
10:33:33 <schee_> Right.
10:33:42 <ehird> dmwit: now you'll get him thinking that (a -> a -> ?) is a good type for (=)
10:33:43 <ehird> :-)
10:33:46 <schee_> I'm used to assignment operators returning a value so this is all very strange.
10:33:56 <schee_> In my mind everything should return something :S
10:34:02 <schee_> but thanks for the helperoo!
10:34:11 <dmwit> schee_: There's a few other things that qualify as identifiers; for example, in "case" statements, the names in the LHS are identifiers, as well as the names on the LHS of "<-" clauses in do blocks.
10:34:19 <nolrai_> @pl \f x1 x2 a b -> f x1 a b || f x2 a b
10:34:20 <rahaskella> flip =<< (((.) . liftM2 (liftM2 (||))) .)
10:34:38 <dmwit> (But you probably get the idea: only things the programmer gets to name qualify as identifiers.)
10:35:21 <vixey> @pl \a b c d e f -> f a b c a b c + f d e d e + f a b c a b c
10:35:25 <rahaskella> ap (ap . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . ((((((+) .) .) .) .) .) . flip flip (flip ap id . (flip .) . join (flip . (flip .) . flip . flip id)) . (flip .) . (((.) .) .)
10:35:25 <rahaskella>  . (((.) .) .) . ((ap .) .) . ((((+) .) .) .) . flip flip id . (ap .) . ((flip .) .) . flip ap id . (flip .) . ((flip .) .) . ap (flip . (flip .) . ((flip .) .) . (flip .) . flip . flip id) id) (
10:35:25 <rahaskella> flip flip id . (ap .) . ((flip .) .) . flip ap id . (flip .) . ((flip .) .) . ap (flip . (flip .) . ((flip .) .) . (flip .) . flip . flip id) id)
10:35:25 <rahaskella> optimization suspended, use @pl-resume to continue.
10:35:41 <osfameron> "optimization"? ;-P
10:35:46 <vixey> haha
10:36:37 <nolrai_> what are you doing?
10:37:11 <nolrai_> @pl \f x1 x2 a -> f x1 a || f x2 a
10:37:12 <rahaskella> flip =<< (((.) . liftM2 (||)) .)
10:37:41 <chessguy> conal: ok, here goes: http://hpaste.org/7731#a2
10:38:14 <nolrai_> @pl \f1 f2 a b-> f1 a b || f2 a b
10:38:15 <rahaskella> liftM2 (liftM2 (||))
10:38:48 <conal> chessguy: yep!  do you like it?
10:39:30 <chessguy> i do. though at some point, i'll probably pull the Conditonal class out into a separate module
10:40:17 <conal> chessguy:  hey -- wait a minute ...
10:40:23 <chessguy> uh-oh
10:40:41 <conal> chessguy: what information does the c have access to?
10:40:48 <conal> chessguy: in Cond ?
10:41:00 <chessguy> ugh
10:41:04 <chessguy> none
10:41:08 <conal> oops
10:41:19 <conal> chessguy: what info would you like it to use?
10:41:30 <schee_> Right well ok. orbitz explained it all to me. Seems ghci is a special case so it makes more sense.
10:41:40 <schee_> I wish the book or the wiki would have presented it as well as she/he did :)
10:42:14 <chessguy> conal: info from the tree
10:42:51 <conal> chessguy: 'TreeLoc a' ?
10:42:55 <MyCatVerbs> vixey: surely that could never typecheck? How on Earth would you get (f d e d e) to have the same type as (f a b c a b c), given the differing arities?
10:43:06 <schee_> problem here to me is that = made no sense 'cause I could do let x = 5   show 5  on the repl and bam. Seems to me ghc allowed sideeffects right there. Turns out ghci is a "special case".
10:43:11 <schee_> :)
10:43:12 <chessguy> conal: yes
10:43:29 <conal> chessguy: okay, that's clear.  any ideas?
10:43:41 <vixey> MyCatVerbs: I'm not sure maybe typeclasses?
10:43:44 <maltem> Baughn:  't was me who used @tell above. Right, I replaced the error branch and included an EOF check
10:44:11 <MyCatVerbs> vixey: AFAIK, @pl does not do anything whatsoever towards making sure its input can ever typecheck.
10:44:18 <int-e> MyCatVerbs: the functions can be polymorphic. in particular, consider f = undefined
10:44:19 <Baughn> maltem: Congratulations. You're now an official GHC Developer (tm).
10:44:30 <Baughn> maltem: ..hmm, except they split out bytestring already. Whoops.
10:44:49 <maltem> heh
10:44:50 <vixey> int-e: oh which would work if f was let, but not bound by a lambad
10:45:02 <nolrai_> are where clauses inside of one pattern matched definition or the whole definition block for the function?
10:45:22 <MyCatVerbs> int-e: yyyyess, but is there a set of types for f, a, b, c, d and e which make (f a b c a b c) have the same type as (f d e d e)? I contend that there is not.
10:45:51 <MyCatVerbs> vixey: "let" isn't a function though, it's a syntactical form.
10:46:19 <chessguy> conal: maybe that branch of the interpreter needs to be something like \t -> if (evalPredicate c t) then t1 else t2
10:46:32 <chessguy> conal: with appropriate modifications to the class
10:47:02 <chessguy> conal: except that would mean parameterizing the TreeTraversal with a new parameter too, i think
10:47:09 <conal> chessguy: sounds good to me!
10:47:13 <vixey> @pl (\u-> u u)(\u-> u u)
10:47:16 <rahaskella> ap id id (ap id id)
10:47:16 <rahaskella> optimization suspended, use @pl-resume to continue.
10:47:18 <conal> chessguy: what other pmg?
10:47:23 <conal> chessguy: what other parameter?
10:47:28 <vixey> @pl-resume
10:47:34 <conal> (emacs abbrev-o)
10:47:34 <rahaskella> ap id id (ap id id)
10:47:34 <rahaskella> optimization suspended, use @pl-resume to continue.
10:47:36 <vixey> nice :D
10:47:41 <chessguy> conal: well, i'm thinking about the class modifications
10:47:43 <nolrai_> i.e. is it:
10:47:46 <vixey> I got a @pl fixed point
10:47:48 <nolrai_> f A = w
10:48:01 <nolrai_> f B = something else
10:48:12 <chessguy> oh, maybe i can just do evalPredicate :: c -> a -> Bool
10:48:13 <nolrai_> where w = something
10:48:28 <nolrai_> or:
10:48:30 <int-e> @type let f :: a; f = undefined; a = 1; b = 2; c = 3; d = 4; e = 5; test | True = f a b c a b c | False = f d e d e in test
10:48:39 <rahaskella> forall t. t
10:49:11 <vixey> int-e but the expressions was \a b c d e f -> f a b c a b c + f d e d e + f a b c a b c
10:50:14 <EvilTerran> ?pl \a b c d e f -> f a b c a b c + f d e d e + f a b c a b c
10:50:17 <nolrai_> vixey: that still works if f = undefined.
10:50:19 <rahaskella> ap (ap . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . ((((((+) .) .) .) .) .) . flip (flip . (flip .) . (((.) .) .) . (((.) .) .) . ((ap .) .) . ((((+) .) .) .) . flip (flip . (ap
10:50:19 <rahaskella> .) . ((flip .) .) . flip (ap . (flip .) . ((flip .) .) . ap (flip . (flip .) . ((flip .) .) . (flip .) . flip . flip id) id) id) id) (flip (ap . (flip .) . ap (flip . (flip .) . flip . flip id) id)
10:50:19 <rahaskella> id)) (flip (flip . (ap .) . ((flip .) .) . flip (ap . (flip .) . ((flip .) .) . ap (flip . (flip .) . ((flip .) .) . (flip .) . flip . flip id) id) id) id)
10:50:20 <rahaskella> optimization suspended, use @pl-resume to continue.
10:50:23 <EvilTerran> haha
10:50:33 <vixey> nolrai_: show me?
10:50:50 <ehird> ooh
10:50:52 <ehird> that gives me an idea
10:50:53 <vixey> :t \a b c d e f -> f a b c a b c + f d e d e + f a b c a b c
10:50:55 <ehird> you know utf-8 bombs?
10:50:56 <int-e> > let a = "%d %d %s %d %d", b = 2, c = 3, d = "%d %s %d", e = 4 in printf a b c a b c ++ printf d e d e ++ printf a b c a b c :: String
10:50:57 <rahaskella>  Parse error at "," (column 25)
10:51:00 <nolrai_> let me test on ghci
10:51:02 <ehird> one character that is many many bytes
10:51:04 <rahaskella>     Occurs check: cannot construct the infinite type: a = t -> t -> a
10:51:04 <rahaskella>     Probable cause: `f' is applied to too few arguments
10:51:04 <rahaskella>     In the second argument of `(+)', namely `f d e d e'
10:51:05 <ehird> (using combining marks)
10:51:07 <ehird> well... pl/unpl bombs
10:51:11 <ehird> a tiny expr that blows up on unpl
10:51:12 <ehird> and vise-versa
10:51:20 <ehird> we could GOLF them
10:51:30 <vixey> I think MyCatVerbs is right because it's a lambda
10:51:32 <int-e> > let a = "%d %d %s %d %d"; b = 2; c = 3; d = "%d %s %d"; e = 4 in printf a b c a b c ++ printf d e d e ++ printf a b c a b c :: String
10:51:35 <Saizan> nolrai_: lambda-bound variables are not polymoprhic unless you use RankNTypes and add an explicit signature
10:51:39 <rahaskella>  "2 3 %d %d %s %d %d 2 34 %d %s %d 42 3 %d %d %s %d %d 2 3"
10:51:59 <nolrai_> yeah my bad
10:52:02 <MyCatVerbs> That cannot be right. Surely it's just doing something stupid like not bothering to make sure that both invocations of f have the same type there?
10:52:08 <vixey> int-e: (\a b c d e f -> f a b c a b c + f d e d e + f a b c a b c) ... printf -- wont work though
10:52:14 <ehird> @pl \f x -> flip (f f f f) x
10:52:18 <rahaskella> flip . join (join (join id))
10:52:19 <int-e> vixey: true
10:52:49 <chessguy> conal: that worked: http://hpaste.org/7731#a3
10:52:59 <ehird> @type let foo f x = (f bar bar) x x x x fix; bar f x y z = x y (f foo) z in foo
10:53:10 <rahaskella>     Occurs check: cannot construct the infinite type:
10:53:10 <rahaskella>       t
10:53:10 <rahaskella>       =
10:53:22 <ehird> @type let foo f x = (f bar bar) x x x x fix; bar f x y z = x y (f z) z in foo
10:53:33 <rahaskella> forall t t1 t2 t3 t4 t5 t6 t7 t8 a t9. (((t -> t1) -> (t2 -> t1 -> t -> t3) -> t2 -> t -> t3) -> ((t4 -> t5) -> (t6 -> t5 -> t4 -> t7) -> t6 -> t4 -> t7) -> t8 -> t8 -> t8 -> t8 -> ((a -> a) -> a) ->
10:53:33 <rahaskella>  t9) -> t8 -> t9
10:53:41 <ehird> and finally...
10:53:41 <ehird> @pl let foo f x = (f bar bar) x x x x fix; bar f x y z = x y (f z) z in foo
10:53:47 <rahaskella> (id . fix . const . flip (flip . (flip .) . flip (flip . (ap .) . flip (flip . (ap .) . flip (flip . (ap .) . ap (flip . flip id) id) id) id) id) fix) (fix (const (flip (flip . (flip .) . ((ap .) .)
10:53:48 <rahaskella> . flip (flip . ((.) .))) id)))
10:53:48 <rahaskella> optimization suspended, use @pl-resume to continue.
10:53:52 <nolrai_> thats an impressive type
10:53:53 <ehird> hmph.
10:54:19 <ehird> @djinn (((t -> t1) -> (t2 -> t1 -> t -> t3) -> t2 -> t -> t3) -> ((t4 -> t5) -> (t6 -> t5 -> t4 -> t7) -> t6 -> t4 -> t7) -> t8 -> t8 -> t8 -> t8 -> ((a -> a) -> a) -> t9) -> t8 -> t9
10:54:21 <rahaskella> Plugin `djinn' failed with: Prelude.tail: empty list
10:54:24 <ehird> :\
10:54:44 <int-e> @djinn (a -> a) -> a
10:54:45 <rahaskella> Plugin `djinn' failed with: Prelude.tail: empty list
10:54:49 <int-e> oh.
10:54:51 <ehird> @djinn a -> a
10:54:53 <rahaskella> Plugin `djinn' failed with: Prelude.tail: empty list
10:54:56 <conal> chessguy: okay.  two comments:  one is stylistic.  write the Cond case using liftA3 and a (commonly useful) auxiliary function.
10:54:57 <MyCatVerbs> Aight. If you supply f via a lambda, as in ((\f -> (f a b c a b c) + (f d e d e)) undefined) then it forces f to unify to the same type on both sides, which fails. Hence, there's no possible f that will work there.
10:54:59 <int-e> the executable isn't there ...
10:55:08 <ehird> int-e: :|
10:55:18 <vixey> MyCatVerbs: yeah
10:55:21 <MyCatVerbs> If you do let f = undefined in... it basically cheats. :P
10:55:27 <MyCatVerbs> The gammy bastard.
10:55:29 <conal> chessguy: though first drop all the parens on the RHS and see how you like it.
10:55:32 <nolrai_> @t (\a b d f -> f a b a b + f d d + f a b a b)
10:55:34 <rahaskella> Maybe you meant: tell temp thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:55:36 <int-e> MyCatVerbs: you could still redefine + ;)
10:55:44 <nolrai_> @type (\a b d f -> f a b a b + f d d + f a b a b)
10:55:55 <rahaskella>     Occurs check: cannot construct the infinite type: a = t -> t -> a
10:55:55 <rahaskella>     Probable cause: `f' is applied to too few arguments
10:55:55 <rahaskella>     In the second argument of `(+)', namely `f d d'
10:56:07 <chessguy> conal: liftA3?
10:56:12 <chessguy> @hoogle liftA3
10:56:14 <rahaskella> A Hoogle error occured.
10:56:21 <MyCatVerbs> int-e: (+) = \a f -> a * (f 1 2) -- suppling more arguments! :)
10:56:46 <int-e> MyCatVerbs: or just _ + _ = 42
10:56:58 <MyCatVerbs> int-e: oh, your lawnmower.
10:57:13 <int-e> @t (\(+) a b d f -> f a b a b + f d d + f a b a b)
10:57:15 <rahaskella> Maybe you meant: tell temp thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:57:16 <vixey> hehehehehehe
10:57:21 <vixey> #haskell++
10:57:28 <int-e> :t (\(+) a b d f -> f a b a b + f d d + f a b a b)
10:57:33 <nolrai_> @pl (\a b d f -> f a b a b + f d d + f a b a b)
10:57:37 <chessguy> @type liftA3
10:57:39 <rahaskella>     Occurs check: cannot construct the infinite type: t = t1 -> t1 -> t
10:57:39 <int-e> @type (\(+) a b d f -> f a b a b + f d d + f a b a b)
10:57:40 <rahaskella>       Expected type: t -> t -> t2
10:57:40 <rahaskella> ap (ap . (flip .) . ((ap .) .) . ((((+) .) .) .) . flip (flip . ((.) .) . (ap .) . (((+) .) .) . flip (ap . (flip .) . ap (flip . (flip .) . flip . flip id) id) id) (ap (flip . flip id) id)) (flip (
10:57:40 <rahaskella>       Inferred type: t -> (t1 -> t1 -> t) -> t
10:57:40 <rahaskella> ap . (flip .) . ap (flip . (flip .) . flip . flip id) id) id)
10:57:42 <rahaskella> optimization suspended, use @pl-resume to continue.
10:57:51 <rahaskella> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
10:57:51 <chessguy> @type liftA3
10:57:56 <int-e> oh well.
10:57:57 <rahaskella> thread killed
10:58:03 <vixey> :t liftA2
10:58:08 <rahaskella> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
10:58:14 <rahaskella> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
10:58:17 <nolrai_> @pl (\a b d f -> f a b + f d + f a b)
10:58:23 <rahaskella> ap (ap . (flip .) . ((ap .) .) . ((((+) .) .) .) . flip flip (flip id) . ((.) .) . (ap .) . (((+) .) .) . flip . flip id) (flip . flip id)
10:58:23 <rahaskella> optimization suspended, use @pl-resume to continue.
10:58:33 <vixey> @pl-resume
10:58:37 <MyCatVerbs> :t let plus a b = 42 in ((\f -> (f a b c a b c) `plus` (f d e d e)) undefined)
10:58:42 <rahaskella> ap (ap . (flip .) . ((ap .) .) . ((((+) .) .) .) . flip flip (flip id) . ((.) .) . (ap .) . (((+) .) .) . flip . flip id) (flip . flip id)
10:58:43 <rahaskella> optimization suspended, use @pl-resume to continue.
10:58:47 <rahaskella> forall t. (Num t) => t
10:58:59 <olsner> hmm, (f a b + f d) sounds definitely wrong
10:59:09 <vixey> :t ap id id
10:59:09 <MyCatVerbs> int-e: that works, though I've thrown away the (+) symbol. :)
10:59:16 <rahaskella>     Occurs check: cannot construct the infinite type: a = a -> b
10:59:17 <rahaskella>     Probable cause: `id' is applied to too few arguments
10:59:17 <rahaskella>     In the second argument of `ap', namely `id'
10:59:23 <vixey> :t ap id
10:59:34 <rahaskella> forall a b. ((a -> b) -> a) -> (a -> b) -> b
10:59:38 <olsner> @ty (\a b d f -> f a b + f d + f a b)
10:59:49 <rahaskella>     Occurs check: cannot construct the infinite type: a = t -> a
10:59:49 <rahaskella>     Probable cause: `f' is applied to too few arguments
10:59:50 <rahaskella>     In the second argument of `(+)', namely `f d'
11:00:12 <conal> chessguy: liftA3 is from Applicative. we can come back to it.
11:00:37 <vixey> conal: what is liftA ?
11:00:43 <vixey> (in general)
11:00:43 <conal> chessguy: it's fmap
11:00:45 <chessguy> conal: yeah, i don't have any Applicative instances yet (i don't htink)
11:01:04 <conal> chessguy: no, but (->) does.
11:01:56 <conal> chessguy: if you ever see  '\ x -> w (f x) (g x) (h x)',  you can instead use 'liftA3 w'
11:03:21 <conal> chessguy: on functions, liftAn means composing an n-ary function with n other functions
11:03:29 <chessguy> so in this case it would be liftA3 if (evalPredicate c) (interpret t1) (interpret t2) ?
11:04:02 <conal> yes.  though you'd have to define an if function.  i'd call it "cond".  then your clause will be very pretty!
11:04:47 <conal> chessguy: notice the similarity in style with the Sequence case.  which, btw, i'd rename to Compose
11:05:25 <conal> chessguy: interpret (t1 `Compose` t2) = interpret t1 . interpret t2
11:05:31 <conal> nice, huh?
11:06:04 <chessguy> indeed
11:06:38 <conal> chessguy: now your interpret function is exactly in the "compositional" style of denotational semantics.
11:07:26 <chessguy> i'm not sure how 'if' needs to be re-written
11:08:16 <conal> chessguy: try cond c a b = if c then a else b
11:08:25 <conal> chessguy: really ought to be in the prelude!
11:08:27 <chessguy> oh!
11:08:28 <chessguy> if'
11:08:33 <conal> yeah
11:09:05 <conal> as perlis says, "syntactic sugar causes cancer of the semi-colon"
11:09:12 <chessguy> ok, let me try this
11:10:32 <MyCatVerbs> chessguy: case foo of { True -> what; False -> ever; } -- ?
11:10:46 <MyCatVerbs> chessguy: I've written that from time to time, for various bad reasons. Always deleted it later, though.
11:12:33 <chessguy> @hoogle liftA3
11:13:05 <vixey> It's in Control.Applicative
11:13:38 <conal> chessguy: http://haskell.org/hoogle
11:13:48 <chessguy> bah, i'm too lazy :)
11:14:12 <vixey> why does it say 3.1 ?
11:14:18 <chessguy> conal:  http://hpaste.org/7731#a4
11:14:47 <spainish> is stable the latest ghc?
11:14:54 <ehird> so
11:15:03 <ehird> I want to make an 8-bit-style platformer. I am going to do it in haskell.
11:15:04 <ehird> :3
11:15:08 <ehird> Are there sdl bindings?
11:15:18 <ari> Uh... if the lambdabot process is using 600 megabytes of memory (I killed rahaskella due to that)... what should I look into to make it not do that again?
11:15:23 <conal> chessguy: i like that style.  do you?
11:15:39 <monochrom> @botsnack
11:15:48 <chessguy> conal: yeah, it looks great
11:15:52 <monochrom> hrm, this is bad.
11:15:56 <vixey> :)
11:16:19 <Beelsebob> chessguy, that's rather beautiful
11:16:39 <conal> chessguy: okay, now the second comment, which is more substantial.
11:16:43 <chessguy> Beelsebob: blame conal, not me :)
11:17:28 <ehird> conal: MAKE THOSE ARROWS BIGGER!!
11:17:29 <ehird> much bigger
11:17:32 <ehird> same with the page numbers
11:17:33 <ehird> urgh
11:17:39 <ehird> big big BIG
11:17:42 <ehird> like 17px!
11:17:49 <ehird> i ca't tolerate it atm
11:18:03 <monochrom> O_O
11:18:42 <conal> chessguy: the second comment: the type you gave evalPredicate is going to be too hard to implement.
11:18:43 <ehird> monochrom: what, it's unusable
11:18:48 <monochrom> data BIGBIGBIG17pxARROW b c = ...
11:18:58 <conal> chessguy: but can be tamed
11:19:04 <ehird> monochrom: hahaha
11:20:00 <conal> chessguy: do you see what i mean about what evalPredicate would have to accomplish?
11:20:26 <Beelsebob> monochrom: surely data BIGBIGBIG17pxARROW b c = b :-------------------------------------------->: c
11:20:58 <ehird> @botsnack
11:20:58 <rahaskella> :)
11:21:01 <ehird> @rotsncak
11:21:02 <rahaskella> Unknown command, try @list
11:21:04 <ehird> @rotsnack
11:21:04 <rahaskella> :)
11:21:07 * ari just lazily ulimit -m'd it
11:21:18 <monochrom> hahahaha Beelsebob
11:22:16 <conal> chessguy: btw, i'd also finish renaming the LHSs and/or RHSs in interpret to match up better.  and align the "="s.
11:22:55 <conal> chessguy: and probably define "cond = liftA3 (\ c a b -> if c then a else b)".
11:23:27 <Beelsebob> <anal mode> (\c t e -> ...)
11:23:36 <Beelsebob> but that's probably just me
11:24:04 <conal> Beelsebob: i like those choices, too.
11:25:20 <Beelsebob> quick thought -- why the requirement for Show c?
11:26:34 <chessguy_> conal: sorry, i got booted.
11:26:37 <chessguy_> conal: let me catch up
11:26:59 <conal> chessguy_: sure.
11:27:47 <chessguy> ok, i'm back
11:27:59 <chessguy> not sure i get your point about evalPredicate
11:28:16 <MacGuges> Hello, I'm learning Haskell, and I tried a tutorial example which gave me a parse error.  The example was "numOf p xs = length (filter p xs)" and my error was "<interactive>:1:11: parse error on input `='"  Could someone explain why I got this error?
11:28:58 <ari> MacGuges: You need to prefix definitions with "let" in ghci
11:29:03 <conal> chessguy: as i understand your Conditional class, evalPredicate would have to evaluate a given conditional (of type c) on *any* type (a) of argument .
11:29:11 <MacGuges> ari: thank you!
11:29:23 <chessguy> conal: oh, right
11:29:49 <int-e> MacGuges: you can also put that line into a file (say, test.hs) and load it in ghci -- :load test.hs
11:30:02 <chessguy> conal: that's what i was saying before. but i'm not sure what to do about it
11:30:31 <conal> chessguy: which argument types do you really want to handle in a 'TreeTraversal a' ?
11:30:43 <MacGuges> int-e: alright; this is another of the differences between source file syntax and interactive syntax.
11:30:50 <int-e> yep
11:31:16 <MacGuges> this takes a little getting used to.  I wish there was one syntax, but I'll get the hang of it.
11:31:17 <Vq^> MacGuges: well, it's fairly similar to do-notation
11:31:30 <int-e> the interactive syntax works pretty much like a do block - but you probably don't know what that is yet.
11:31:45 <MacGuges> int-e: not quite, no.
11:31:59 <MacGuges> I'm reading http://www.haskell.org/haskellwiki/Why_Haskell_matters
11:32:21 <chessguy> conal: i'm not sure what you mean
11:33:07 <vixey> they should showe Hoares one
11:33:27 <vixey> does anyone have Hoares original implementation of quicksort?
11:33:51 <conal> chessguy: you're passing in the treeloc right, as evalPredicate's second argument?
11:35:10 <conal> chessguy: you could give Conditional a second type parameter, or you could make the 'c' argument be a type constructor.  I'd try the second option first.
11:36:17 <conal> chessguy: the first option is a little more flexible, but will require more type annotations, unless you use a type-class functional dependency.
11:37:49 <chessguy> conal: so you're saying (with the second option), to parameterize the conditional type too?
11:38:39 <ehird> Are there sdl bindings?
11:38:41 <conal> chessguy: for the second option, i mean just one type parameter, but evalPredicate :: c a -> a -> Bool
11:38:59 <conal> chessguy: for the first option, 'class Conditional c a where ...'
11:39:14 <ari> ehird: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/SDL
11:39:27 <ehird> ari: are they maintained? is there something like hsgame?
11:39:49 <conal> chessguy: first option: class Conditional c a where evalPredicate :: c -> a -> Bool
11:40:19 <conal> chessguy: first option probably: class Conditional c a | c -> a where ..
11:40:36 <chessguy> yeah, i understand the first option
11:40:37 <ari> ehird: Well, the latest version was uploaded April 13th this year, so I'd say yes...
11:40:44 <conal> ok
11:40:46 <chessguy> but i agree, i'd rather not resort to fundeps
11:40:58 <chessguy> unless necessary
11:41:26 <ari> ehird: As for this hsgame... what do you mean? What kind of API are you looking for?
11:41:28 <conal> the second option is more demanding, in that the client must use a parameterized type.
11:41:33 <ehird> ari: Something like pygame.
11:41:48 <chessguy> conal: and the TreeTraversal must expect one too
11:42:23 <conal> chessguy: yeah, which it would use at a particular type, namely 'TreeLoc a'
11:43:41 <conal> chessguy: the first option is probably the way to go, since it allows clients to define conditional types that understand treelocs rather than arbitrary types of values.
11:43:55 <lilac> > let match p v = case v of $p -> True; _ -> False in match [p|Just _|] Nothing
11:43:56 <rahaskella>  Parse error at "$p" (column 27)
11:44:10 <conal> chessguy: i don't know how to eliminate the fundep.  oh -- unless you use associated types.  big guns.
11:44:14 <vixey> is that template haskell
11:44:45 <lilac> vixey: yes, but it doesn't work (even with TH turned on...)
11:45:38 <ehird> oh jeez
11:45:39 <chessguy> conal: what if i just made it evalPredicate :: c -> TreeLoc a -> Bool
11:45:41 <ehird> SDL is all in IO
11:45:47 <ehird> instead of, say, SDL :-P
11:45:53 <chessguy> conal: kind of evil, but...
11:45:57 <lilac> doesn't appear to be any way to do what I want (mapping from pattern to predicate matching that pattern)
11:46:30 <conal> chessguy: yeah, you could.  i wouldn't, since otherwise, evalPredicate (theoretically) is more generally useful.
11:46:40 <conal> chessguy: but maybe that's a good choice.
11:46:50 <conal> chessguy: specific/focused now.  generalize lazily!
11:47:03 <conal> chessguy: and call it evalTree instead.
11:47:52 <ari> ehird: I don't see how it would be useful to get SDL out of IO... pretty much everything that it does is IO :p
11:48:07 <osfameron> 6fgg
11:48:31 <ehird> ari: I guess so. I guess I just have to abstract the nasty drawing and input out so I can have a functional core ;-P
11:48:41 <chessguy> conal: yeah, actually, in that case i'll probably make it take a Tree a instead of a TreeLoc
11:48:43 <conal> chessguy: or evalPosition
11:49:05 <conal> chessguy: whatever makes most sense in practice
11:50:23 <ari> ehird: You could use Cairo for drawing if it feels so dirty to you :p
11:50:32 <ehird> ari: Cairo is in IO, is it not? :P
11:50:45 <chessguy> conal: http://hpaste.org/7731#a6
11:50:55 <ari> ehird: http://haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.12/Graphics-Rendering-Cairo.html
11:51:25 <ehird> haha alright ari :-)
11:51:31 <ehird> but yeah, i'll just build game stuff on top of it
11:51:33 <ehird> and then abstract away it
11:52:03 <conal> chessguy: yeah.  that design makes a lot of sense to me.  how about you?
11:52:36 <conal> chessguy: do you plan to derive Show?
11:53:05 <chessguy> conal: probably
11:53:15 <conal> chessguy: oh, btw, try dropping the constraints from traverse and let ghc tell you what to put back.
11:53:25 <Beelsebob> chessguy: the Show c confused me actually -- why do you need that in interpret?
11:54:09 <Beelsebob> in fact, why Arbitrary in there too
11:55:18 <chessguy> hm, i assumed i would need those to get Arbitrary for TreeTraversal
11:56:07 <conal> chessguy: you'll need them elsewhere
11:56:13 <conal> chessguy: but not here
11:56:15 <Beelsebob> ah, okay, duh
11:57:13 <chessguy> conal: ok.  http://hpaste.org/7731#a7
11:57:47 <conal> chessguy: lovely.
11:57:56 <schee_> What is @ ?
11:58:08 <Beelsebob> schee_: it allows you to bind more than one pattern at once
11:58:24 <conal> chessguy: though i'd still rename turn to turnLeft, None to Id, etc and align the ='s.
11:58:32 <schee_> Beelsebob: Sounds complicated. Where do I find info on it?
11:58:36 <conal> chessguy: and move the liftA3 into the cond.
11:58:39 <schee_> @src @
11:58:40 <rahaskella> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:58:45 <Beelsebob> f x@(y:ys) = ... -- Binds x to the whole list, y to the first element, and ys to the rest
11:58:50 <Beelsebob> schee_: like that
11:59:01 <schee_> oh. k thanks.
11:59:15 <schee_> Too bad @src @ not be workin'! :)
11:59:24 <conal> chessguy: i guess i like my code to have a feel of inevitability about it.
11:59:39 <Beelsebob> schee_: there's no source code for it -- it's syntax
11:59:58 <schee_> Beelsebob: oh don't get me started on that again :D
12:00:35 <Deewiant> @djinn Maybe Int -> Int -> Maybe (Int, Int)
12:00:35 <rahaskella> Plugin `djinn' failed with: Prelude.tail: empty list
12:01:20 <Beelsebob> Deewiant: at a guess it'd tell you f Nothing x = Nothing; f (Just x) y = Just (x,y)
12:01:33 <Beelsebob> if it was working
12:01:50 <Deewiant> or maybe f _ x = Just (x, x) ? ;-)
12:01:54 <vixey> :t (>>=) (1,)
12:02:02 <rahaskella> parse error on input `)'
12:02:02 <Beelsebob> Deewiant: fair point, but I doubt it
12:02:02 <vixey> :t (>>=) ((,) 1)
12:02:06 <rahaskella> forall t b b1. (Num t) => ((t, b) -> b -> b1) -> b -> b1
12:02:12 <opqdonut> :t flip (liftM . (,))
12:02:17 <rahaskella> forall a1 (m :: * -> *) a. (Monad m) => m a1 -> a -> m (a, a1)
12:02:22 <opqdonut> there
12:02:24 <vixey> opqdonut++
12:02:31 <ddarius> @djinn f :: Maybe Int -> Int -> Maybe (Int, Int)
12:02:32 <rahaskella> Plugin `djinn' failed with: Prelude.tail: empty list
12:02:37 <Deewiant> Beelsebob: in general it seems to go for the simplest solution... but I don't know
12:02:42 <vixey> > (flip (liftM . (,))) Nothing 7
12:02:46 <rahaskella>  Nothing
12:02:47 <vixey> > (flip (liftM . (,))) (Just 2) 7
12:02:48 <thetallguy> conal: that's a great remark (inevitability)
12:02:49 <rahaskella>  Just (7,2)
12:02:52 <Deewiant> I was just interested in whether it would come up with what you said :-)
12:03:03 <conal> thetallguy: :)
12:03:04 <opqdonut> vixey: one can flip the (,) too
12:03:04 <chessguy> conal: better? http://hpaste.org/7731#a8
12:03:15 <opqdonut> vixey: if Just (2,7) is desired
12:03:15 <Beelsebob> Deewiant: indeed, an interesting question
12:03:15 <Frederick> folks I need help wwith category theory, if I have 2 do blocks and see each one of this as a cathegory can I see a cathegory with has the 2 actions executed on do blocks as morphisms?
12:03:44 <conal> chessguy: so beautiful, i could weep!  sigh ...
12:03:53 <Beelsebob> chessguy: now lay out your data type, so it doesn't break 80 characters :P
12:04:07 <ddarius> Frederick: That has nothing to do with category theory.
12:04:24 <chessguy> conal: lol
12:04:37 <Frederick> ddarius: in a sense it does im failing to formulate my question :/
12:05:23 <chessguy> why do i keep getting these messages? TreeTraversal.hs:36:11:
12:05:23 <chessguy>     Warning: This binding for `t1' shadows an existing binding
12:05:43 <conal> chessguy: like Michelangelo said, this thing of beauty was hiding in the code all along.
12:05:55 <chessguy> in interpret, cond, and if'
12:06:36 <conal> chessguy: hm.  t1 is bound somewhere else.
12:06:46 <conal> chessguy: t1 ??
12:06:51 <conal> oh.
12:06:51 <Frederick> ddarius: may I send you the link which contaisn the idea I want to use?
12:07:01 <conal> chessguy: using ghci?
12:07:05 <chessguy> oh!
12:07:07 <ddarius> Frederick: Just paste it here.
12:07:07 <chessguy> my fault
12:07:10 <conal> ok
12:07:13 <ddarius> (the link that is)
12:08:01 <chessguy> i had a tree defined called t, and one called t1 :)
12:08:07 <conal> :)
12:08:16 <Frederick> ddarius: it was written in latex it will brake
12:09:49 <chessguy> hm, wife's off the phone, i better darcs record and push while i can :)
12:10:02 <nolrai_> What's the syntax for guards? I'm having trouble finding it.
12:10:15 <vixey> nolrai: what's a guard?
12:10:27 <conal> chessguy: yeah -- go for it.
12:10:57 <conal> chessguy: the phone interferes with pushing?
12:11:04 <conal> chessguy: but not IRCing?
12:11:25 <chessguy> conal: no, but my wife may :)
12:11:25 <conal> chessguy: oh !  your wife wants your attention.
12:11:33 <conal> ! lol
12:11:34 <sjanssen> nolrai_: function pattern | boolean = expression
12:11:48 * conal chuckles
12:13:14 <chessguy> conal: thanks again! we'll definitely touch base later
12:14:24 <tibbe> @seen dons
12:14:24 <rahaskella> dons is in #haskell. I don't know when dons last spoke.
12:15:28 <tibbe> @tell dons I saw that you added a bunch of inlining to 'binary'. is GHC to conservative in adding inlining since all fast libraries I've seen use lots of it
12:15:28 <rahaskella> Consider it noted.
12:15:34 <noecksit> hello, does anyone have any idea why i can't install the opengl bindings in gentoo?
12:16:34 <noecksit> said "Could not match expected type `Maybe UserHooks` against inferred type `UserHooks`"
12:16:53 <Saizan> noecksit: mismatching cabal version
12:17:04 <ravi_master> hey folks - trying to learn Haskell over here. I know Java, Python, and Lisp well. What would be the best book/resource to start with?
12:17:26 <nolrai_> thanks
12:17:39 <vixey> ravi_master: check the library? hang about here and learn lots by osmosis too :)
12:17:44 <nolrai_> sjanssen: ^^^
12:17:53 <noecksit> Saizan: ok, how can i find out which version it needs?
12:18:09 <vixey> ravi_master: haskell.org has a metatutorial btw
12:18:11 <noecksit> i have 1.2.3.0
12:18:53 <ravi_master> vixey: was looking for stuff that suits developers moving from the languages that I already know (Java, Python, Lisp)
12:19:17 <vixey> forget everything you know
12:19:40 <vixey> the best way to learn is by choosing something to write, and writing it
12:19:42 <Saizan> noecksit: i'm not sure, where did you get the package from?
12:19:54 <vixey> and if you get stuck you can always ask here
12:20:11 <noecksit> Saizan: its in the default portage tree, i just typed "emerge opengl"
12:20:27 <noecksit> its opengl-2.2.1
12:20:48 <dcoutts> noecksit: if you're using ~$arch ghc then you need ~$arch libs too
12:21:10 <dcoutts> noecksit: it's no good unmasking the latest ghc but still using the older libs
12:22:17 <noecksit> dcouts: i am using ghc-6.6.1 which is not the masked one
12:23:25 <dcoutts> noecksit: ok but you are using a ~$arch cabal
12:23:35 <noecksit> however, my cabal version, 1.2.3.0 is unstable
12:23:37 <noecksit> yeah
12:23:44 <noecksit> so i should downgrade
12:23:44 <dcoutts> noecksit: yes, exactly
12:23:51 <dcoutts> noecksit: they come in consistent sets
12:24:06 <dcoutts> the stable versions all work together, the unstalbe all work together
12:24:13 <dcoutts> a mixture is not guaranteed to work
12:24:33 <pjdelport> ravi_master: Hudak's School of Expression might interest you
12:25:08 <dcoutts> noecksit: so yes, either downgrade cabal or upgrade everything else
12:25:20 <ravi_master> pjdelport: thanks for the tip
12:25:33 <pjdelport> ravi_master: the Haskell Wikibook is a pretty good tutorial too
12:26:28 <MyCatVerbs> @src inits
12:26:29 <rahaskella> inits []     =  [[]]
12:26:29 <rahaskella> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
12:26:32 <noecksit> ok, that worked, thanx
12:29:44 <Peaker> I wish those functions had more descriptive names (init -> nonTail, or withoutLast, or something like that)
12:29:58 <Peaker> init has so many connotations
12:30:14 <Peaker> s/nonTail/nonLast or excludingLast, oops
12:31:02 <MyCatVerbs> @src init
12:31:03 <rahaskella> init [x]    = []
12:31:03 <rahaskella> init (x:xs) = x : init xs
12:31:03 <rahaskella> init []     = undefined
12:31:08 <ari> OK, seems I'm going to have to figure out why runplugs's memory use isn't being limited properly
12:31:34 <MyCatVerbs> @pl \l -> zipWith const l (tail l)
12:31:34 <rahaskella> ap (zipWith const) tail
12:31:58 <ari> Someone just tried to solve the Project Euler problem 2 on rahaskella... except that instead of using takeWhile, they used filter, thus putting my box about a hundred megabytes into swap :(
12:32:22 <Peaker> ari, software is wonderful
12:32:27 <Deewiant> MyCatVerbs: or zipWith const <*> tail
12:32:40 <Zao> ari: Rumor has it that resource limits are good.
12:33:17 <MyCatVerbs> Deewiant: correct me if I'm wrong here, but is ap making use of the ((->) a) monad instance there?
12:33:25 <pjdelport> yep
12:34:07 <ari> Zao: Indeed, but the last time I installed lambdabot, it set up those limits by default (well, either that, or it was a more enlightened time, when nobody tried to fully evaluate infinite lists)
12:34:24 <jfredett> > last [1..]
12:34:26 <jfredett> :)
12:34:36 <rahaskella>  Exception: Time limit exceeded
12:34:59 <glguy> @seen dons
12:34:59 <rahaskella> dons is in #haskell. I don't know when dons last spoke.
12:35:00 <universa1> hello guys, i'm having a hard time with an "simulation" of lazy lists, i pastied my problem to: http://hpaste.org/7733
12:36:13 <Peaker> universa1, I think a function that takes () is kinda useless..
12:36:30 <jfredett> what specifically is giving you trouble? and why did you need to define lists like that?
12:36:59 <Deewiant> @djinn () -> Int
12:36:59 <rahaskella> Plugin `djinn' failed with: Prelude.tail: empty list
12:36:59 <jfredett> data List a = Nil | Cons a List a, as I recall
12:37:05 <universa1> Peaker: assignment ;
12:37:12 <MyCatVerbs> Deewiant: I'm not _entirely_ sure what the advantage is to using <*> over `ap`. ;)
12:37:24 <ari> ... and I also need to figure out how why djinn's broken :(
12:37:24 <jfredett> so it has to be ()->List, not just List?
12:37:29 <universa1> jfredett: assignment, the data type was given.
12:37:34 <jfredett> ah,
12:37:35 <jfredett> hmm
12:37:37 <MyCatVerbs> Deewiant: aside from one byte of source text, naturally, but I thought we weren't into golfing?
12:37:48 <Deewiant> MyCatVerbs: weren't we?
12:37:49 <Deewiant> ;-)
12:37:50 <jfredett> tell your professer he's dumb.
12:37:52 <universa1> i think i need the "result" of () -> "this side"
12:37:54 <pjdelport> MyCatVerbs: applicative functors are more general than monads
12:39:32 <Peaker> universa1, you can pattern-match in the argument of a function, you don't have to pattern match inside the "let" in the function body
12:39:41 <jfredett> also, in your defn of headL, why not do headL (Cons y _) = y
12:39:48 <jfredett> what Peaker said.
12:39:53 <universa1> Peaker: yeah, this works too
12:39:59 <pjdelport> > getZipList $ (+) <$> ZipList [2,3,5] <*> ZipList [1..]
12:40:02 <rahaskella>  [3,5,8]
12:40:22 <jfredett> so the problem is the type of tailL, it needs to be a list, but you're getting a ()->List?
12:40:33 <universa1> Peaker: but what should be possible is: headL(tailL ....) but i can't get tailL to return just a List and not () -> List
12:40:35 <universa1> yes
12:40:38 <pjdelport> (not the most motivating of examples, but still :)
12:40:47 <MyCatVerbs> pjdelport: oh yes of course.
12:40:57 <jfredett> try (id $! ys)
12:40:59 <MyCatVerbs> Deewiant: no, I always thought that that was a Perl hackers' thing.
12:41:10 <jfredett> i think that should undo it, but I don't run into this sort of thing much.
12:41:18 <Peaker> universa1, if you want to convert a value of type (a->b) to type b, how do you generally do it?
12:41:39 <pjdelport> MyCatVerbs: <$> and <*> also read more like application
12:41:51 <jfredett> IIRC, id $! (\() -> a) =~= a
12:42:00 <universa1> Peaker: use a function
12:42:10 <Peaker> universa1, (a->b) is already a function
12:42:18 <Peaker> universa1, you want its result 'b', how do you do it?
12:42:24 <Peaker> (of type b, that is)
12:42:46 <universa1> Peaker: well "execute" it? sry, kinda new to haskell
12:43:00 <jfredett> maybe it would be informative to say f :: a -> b
12:43:06 <jfredett> i want something of type b
12:43:15 <Peaker> universa1, you apply it, give its an argument of type a
12:43:35 <jfredett> so f (x::a) is of type b
12:44:14 <jfredett> so in your case, f is the second part of the "Cons" construct, what is the type of that value?
12:44:18 <Peaker> universa1, in your case, the a type is (), and b type is List.
12:44:33 <universa1> the second argument is a function
12:44:54 <jfredett> so then f :: () -> a means that (f ()) :: a
12:45:11 <universa1> yep
12:45:18 <universa1> so far i'm with you both
12:45:25 <jfredett> in your case, the second arguement has type () -> List a
12:45:32 <Peaker> universa1, if you apply tailL to a value, and you get a value of type (() -> List) then how can you "convert" it to a List?
12:45:54 <Peaker> universa1, note that () is both a value and a type, if that's confusing you
12:45:57 <jfredett> so consider (\() -> List a) ()
12:46:34 <jfredett> specifically () is the "unit" type, defined as "data () = ()"
12:46:47 <universa1> mhm, gimme a sec.
12:47:07 <Peaker> universa1, did you go through the Haskell tutorial?
12:47:12 <tensh> can someone explain to me how () as an argument can be useful when it's not wrapped in a monad?
12:47:26 <Peaker> tensh, its not useful - its a stupid assignment he has :-)
12:47:35 <jfredett> I don't think it is, it's just a mean ass professor
12:47:36 <tensh> oh, alright :)
12:47:43 <universa1> Peaker: not really, had some instructionary lessons
12:47:46 <thoughtpolice> where does XMonad.Prompt.Shell get the executable paths from?
12:47:54 <nolrai_> IIRC, memorry ghc wont keep the value around.
12:48:03 <Peaker> universa1, the YAHT tutorial is good.  The gentle introduction readable (sloowly :-)
12:48:04 <jfredett> i suppose it's a cheap way to create some binary functions from unary ones
12:48:09 <thoughtpolice> just $PATH? I have ff3rc1 in my ~/bin, but dmenu can't execute it either.
12:48:17 <nolrai_> err, thats to tensh.
12:48:32 <universa1> tensh: its just about how lazy evulation could be done in other languages. not that its beautiful or anything ;)
12:48:37 <sjanssen> thoughtpolice: #xmonad is better for these sorts of questions :)
12:48:44 <thoughtpolice> sjanssen: whoops
12:48:49 <tensh> ok
12:48:50 <sjanssen> thoughtpolice: but yes, it uses your $PATH
12:49:02 <universa1> Peaker: thanks for the tip.
12:49:03 <jfredett> so universa1, have you got it?
12:49:08 <thoughtpolice> sjanssen: thought i was on #xmonad, thanks :)
12:49:30 <universa1> jfredett: yes. finally. i think i understand a little bit.
12:49:47 <universa1> thanks for the help jfredett and Peaker :)
12:50:12 <jfredett> no problem, methinks Peaker was the one doing the hard work, I just cribbed off him. :P
12:50:16 <jfredett> Peaker++
12:50:17 <jfredett> :P
12:50:21 <universa1> :-
12:50:24 <universa1> :-)
12:50:48 <jfredett> I wish I could write Android code in Haskell instead of Java... :/
12:51:08 <vixey> why don't you?
12:51:11 <pjdelport> LambdaVM?
12:51:15 <Peaker> heh, extremely hard work. where's my $5000 cheque? :-)
12:51:31 <jfredett> because I'm required to write the code in Java
12:51:33 <vixey> hmm
12:51:33 <Peaker> jfredett, nobody implemented a Haskell compiler for the JVM yet? :)
12:51:34 <universa1> ;-)
12:51:38 <jfredett> dumb ass jobs... :/
12:51:39 <vixey> jfredett: no use wishing them
12:51:41 <jfredett> Peaker: probably.
12:51:42 <vixey> jfredett: no use wishing then*
12:51:50 <jfredett> i can dream, vixey
12:51:52 <Peaker> jfredett, are you required to generate readable Java code, or executable JVM code?
12:51:54 <vixey> jfredett: Just enjoy writing java
12:51:57 <jfredett> don't squash my dreams.
12:52:02 <jfredett> readable java.
12:52:08 <pjdelport> Peaker, jfredett: http://www.cs.rit.edu/~bja8464/lambdavm/
12:52:08 <Peaker> jfredett, then you're screwed :P
12:52:12 <jfredett> which seems oxymoronic,
12:52:48 <jfredett> yes, I've seen those things, pjdelport. and despite my best efforts to get my boss to let me use them
12:52:50 <jfredett> he wants java
12:52:54 <Peaker> jfredett, at least Java has usable IDE's?
12:52:58 <jfredett> and what bossman wans, bossman gets
12:53:06 <jfredett> Peaker: Eclipse keeps me from suicide
12:53:08 <jfredett> but only just
12:53:16 <pjdelport> jfredett: easy;  compile the Haskell to JVM bytecode, and decompile that to Java source
12:53:40 <jfredett> lol, pjdelport. Doubtful that will fly in code review... :P
12:53:53 <jfredett> I've gotten them to let me use scala for a few prototype things
12:54:18 <Peaker> jfredett, for "prototype thingies" or very short-term projects, why do you need to ask his permission about what to use? What kind of micromanager is he?
12:54:24 <jfredett> which is a step in the right direction, hopefully that will convince them to let me build the whole project out of it. but the stuff they have me on now.
12:54:38 <jfredett> The worst kind, Peaker
12:54:52 <Peaker> jfredett, there are many programming jobs :)
12:54:53 <jfredett> they're official prototypes,
12:55:01 <jfredett> not for a math major.
12:55:13 <jfredett> this was the only one who gave me the time of day
12:55:19 <jfredett> all in all it's a good job
12:55:42 <jfredett> they let me talk about scala and haskell and are generally receptive of my math-heavy musings.
12:55:42 <Peaker> jfredett, The good workplaces here don't look at your diploma at all
12:56:10 <jfredett> I wish that were the case w/ me.
12:56:38 <jfredett> its alright, the job is temporary till I finish my degree.
12:57:07 <jfredett> which isn't far off.
12:58:47 <Peaker> jfredett, I think that places that filter mainly by diploma are going to get mediocre people. The places who are looking for brilliant people can't use a diploma, its too weak a signal.  Also, many brilliant people can get jobs without a diploma so they don't bother to, so those who filter them out lose themt oo
12:59:00 <jfredett> i agree
12:59:42 <jfredett> I'm a pretty smart guy, but you wouldn't believe how many people send me off just because I'm oriented towards CS Theory and Math
13:00:23 <jfredett> I mean- they don't even let me interview. which if they did, they'd probably hire me. because while I'm not dumb, I am _really freaking charming_
13:00:42 <Peaker> jfredett, practical experience is more valuable in all the workplaces I've been in than theoretical knowledge and skills
13:00:55 <Peaker> (ofcourse the theory is very valuable too)
13:00:57 <MyCatVerbs> jfredett: the stereotypical assumption to make is that your theoretical background colours you as impractical.
13:01:04 <jfredett> yah
13:01:25 <Peaker> If you interview someone, and ask him practical questions, but he keeps answering theoretical answers, then maybe he's rightly branded as impractical
13:01:40 <jfredett> I make it a habit to bring a CD with the different things I've built, useful and less so, to any interview I go to.
13:01:41 <MyCatVerbs> Peaker: I still think it's hilarious when people attempt to do things that're provably impossible simply because they couldn't be arsed to look up the relevant theory, though.
13:02:06 <jfredett> they say, "Wow, you've studied math alot, can you code" I say, "Here's 700MB of my best work, enjoy."
13:02:10 <Peaker> MyCatVerbs, I think those who don't know the basics of theory rarely embark on such things. Could be amusing to hear some examples though :)
13:02:27 <Botje> jfredett: 700 MB of code?
13:02:29 <Botje> that's quite a lot :)
13:02:31 <Peaker> jfredett, that's pretty cool! What have you got on that CD?
13:02:45 <Peaker> I believe no single person on earth wrote 700MB of compressed code :)
13:03:02 <jfredett> Peaker, Botje: my lifes work, some of it is code, some of it is data that goes with the code
13:03:16 <Peaker> jfredett, what kind of stuff did you write?
13:03:40 <jfredett> i'd say theres about 500k-600k LOC on the whole disk
13:04:02 <jfredett> the rest is anything from pictures to midi files needed to run the software.
13:04:06 <MyCatVerbs> Peaker: mmm. You do see a lot of projects that just mysteriously fail to ever get anywhere.
13:04:08 <jfredett> Peaker: anything that pops in my head
13:04:08 <Botje> don't think i've written that much yet :/
13:04:26 <mercury^> jfredett: can you show us the code?
13:04:31 <jfredett> I've been writing since I was 8, and I still have every cheap-ass game I wrote in Basic.
13:04:38 <czShadoW> Send us teh codez.
13:04:40 <czShadoW> :-)
13:04:59 <jfredett> mercury^: I suppose. lol, I haven't had an interview in a while, I hope I can find the disk...
13:05:12 <jfredett> I have a copy compressed on my server.
13:05:12 <jfredett> hmm
13:05:13 <Peaker> MyCatVerbs, there are interesting halting problem projects that obviously solve only specific cases and not the general case
13:05:31 <Peaker> jfredett, cool -- I didn't keep all my old basic stuff :-(
13:05:32 <praseodym> vixey: remember the combinatorial problem of a few hours ago?
13:05:43 <vixey> praseodym: Yes
13:05:51 <MyCatVerbs> Peaker: things like ad-hoc parsers where a proper LL or LR parser generator would fix the problem in ten minutes flat, and (naturally) the halting problem. ;)
13:05:53 <praseodym> vixey: turns out you can do:
13:05:57 <praseodym> @let powerset = filterM (const [True, False])
13:06:00 <rahaskella> Defined.
13:06:10 <jfredett> However, to answer your question peaker, typically puzzle solutions, I have most of Project Euler in Haskell, Java, and VB6.
13:06:21 <praseodym> @let solve n xs = do x <- powerset xs guard (sum x == n) return x in solve 5 [1..5]
13:06:22 <rahaskella>  Parse error
13:06:33 <jfredett> I have one of my favorite apps, a Music Composition assistant
13:06:41 <praseodym> @let solve n xs = do x <- powerset xs; guard (sum x == n); return x in solve 5 [1..5]
13:06:42 <rahaskella>  Parse error
13:06:46 <gwern> jfredett: is it in haskell?
13:06:54 <jfredett> which is basically a hidden-heirarchical markov chain
13:06:55 <Botje> praseodym: do { ... }
13:07:05 <praseodym> @let solve n xs = do {x <- powerset xs; guard (sum x == n); return x} in solve 5 [1..5]
13:07:05 <rahaskella>  Parse error
13:07:06 <Peaker> MyCatVerbs, yeah, parsers are the only place I have encountered where there's a huge gap between known theory and implementors.. Virtually all of the regexp engines have horrible complexities rather than O(N) for matching, (when asked about it, the excuse is a rarely used feature)
13:07:13 <jfredett> which trains on midi files and then gives you hints on what to write as you write it
13:07:19 <praseodym> @let solve n xs = do { x <- powerset xs; guard (sum x == n); return x } in solve 5 [1..5]
13:07:20 <rahaskella>  Parse error
13:07:24 <dolio>  @let isn't for evaluating expressions.
13:07:28 <jfredett> gwern: no, java, though I'm going to be porting it eventually.
13:07:40 <praseodym> @let solve n xs = do { x <- powerset xs; guard (sum x == n); return x }
13:07:42 <rahaskella> Defined.
13:07:49 <praseodym> @solve 5 [1..5]
13:07:49 <jfredett> I have some of my more recent android hackery.
13:07:49 <rahaskella> Unknown command, try @list
13:07:50 <Peaker> jfredett, can you put all that stuff on googlecode or sourceforge or something like that?
13:07:55 <roconnor> > solve 5 [1..5]
13:07:56 <rahaskella>  [[1,4],[2,3],[5]]Resource limits set!
13:07:57 <pjdelport> praseodym: >, not @
13:07:58 <jfredett> Peaker someday.
13:08:03 <praseodym> pjdelport: :) ty
13:08:10 <praseodym> vixey: see above :)
13:08:19 <Peaker> jfredett, do people take a look at that stuff in your interviews?
13:08:21 <MyCatVerbs> Peaker: to be fair, I already have the paper on that (fast subexpression matching) lying somewhere around here, but am too lazy to have read it yet. ;)
13:08:22 <jfredett> whenever I port Orchestra (the comp assistant), I'll probably put it up somewhere
13:08:31 * gwern bahs! I only care about those programs of jfredett which are in haskell (and might be freely licensed)
13:08:37 <jfredett> Peaker: sometimes, its mostly nice to show them it exist.
13:08:41 <praseodym> vixey: I'm wondering if it'd be less efficient, since powerset is pre-generating everything
13:08:44 <mercury^> Peaker: just gzip all the code from the image on your server and give us a link
13:09:02 <jfredett> gwern: just about everything I do is BSD, sometimes GPL.
13:09:18 <jfredett> Orchestra is GPL, my game is GPL.
13:09:18 <Peaker> mercury^, that's for jfredett ?
13:09:20 <mercury^> that music composition program sounds nice, I'm eager to have a look at it
13:09:25 <mercury^> oh, yeah, sorry Peaker
13:09:28 <Peaker> MyCatVerbs, a simple FSM works for any regular language..
13:09:30 <vixey> praseodym: I don't know but there's no backtracking involved there
13:09:32 <Peaker> jfredett, what game did you write?
13:09:39 <jfredett> the game is in Haskell
13:09:44 <jfredett> it's not released yet
13:09:49 <Peaker> jfredett, what kind of game?
13:09:50 <jfredett> it's wicked theoretical, actually
13:10:01 <jfredett> it's a serverless persistent MMO
13:10:03 <MyCatVerbs> Peaker: er, it's capturing that's the issue.
13:10:05 <gwern> jfredett: oh really? now I'm interested - there aren't enough free haskell games
13:10:08 <Peaker> I wrote a cool game in Python.. real-time peer-to-peer network game, even :)
13:10:16 <gwern> jfredett: serverless? p2p then?
13:10:21 <gwern> is this based on barracuda?
13:10:21 <ari> Uhhh
13:10:24 <jfredett> gwern: kinda
13:10:34 <jfredett> no, it's based on nothing.
13:10:34 <MyCatVerbs> Peaker: especially when you really want good ol' fashioned POSIX-regex features like always capturing the longest possible matching sequence, for example.
13:10:39 <jfredett> I like building things from scratch
13:10:39 <Peaker> MyCatVerbs, isn't catching a trivial addition to the algorithm?
13:10:49 <praseodym> vixey: true, I could just filter over the powerset
13:10:50 <Peaker> capturing, that is
13:11:06 <ari> > solve 5 [1..5]
13:11:08 <rahaskella>  [[1,4],[2,3],[5]]Resource limits set!
13:11:12 <vixey> praseodym: I guess filter powerset is O(2^n)
13:11:15 <gwern> jfredett: sounds interesting though; if you ever decide to release it or otherwise make it public, I'd be interested in packaging it for hackage
13:11:16 <MyCatVerbs> Peaker: I don't know. I think it might not be, because AFAIK most capturing regex implementations are NFAs.
13:11:20 <jfredett> basically, right now, it's (barely) capable of keeping a marginally persistent world between an arbitrary number of clients
13:11:24 <ari> I thought I had removed that message...
13:11:37 <vixey> praseodym: and the backtracking one.. is it less? It couldn't be O(n^3) .. could it?
13:11:47 <praseodym> vixey: backtracking would be n^2 max
13:11:49 <Peaker> MyCatVerbs, that may be explained by lack of competence :)
13:11:56 <vixey> hmm
13:12:00 <jfredett> the goal is to create a system which automatically expands the world as needed
13:12:00 <praseodym> vixey: problem is that I need every solution, not just the best or so
13:12:08 <Peaker> MyCatVerbs, or laziness (as an NFA is truly required for a rare feature)
13:12:11 <MyCatVerbs> Peaker: last time I heard of someone building a capturing DFA engine, it had a quadratic worst case. I don't know if that's a fundamental issue or just silliness though.
13:12:13 <vixey> oh  n^2 for one solution
13:12:19 <vixey> so O(n^3) for all of them?
13:12:21 <jfredett> and as each client enters new terrain, he askes the rest of the world if someone else has been there
13:12:28 <jfredett> if so, the other clients send him the info.
13:12:30 <praseodym> vixey: backtracking should stop when it enters a un-solvable branch
13:12:30 <Peaker> MyCatVerbs, (so maybe they didn't want both an NFA and a FSM for the common case)
13:12:32 <ari> > solve 5 [1..5]
13:12:34 <rahaskella>  [[1,4],[2,3],[5]]
13:12:35 <vixey> yeah
13:12:39 <ari> There, that's better :)
13:12:51 <praseodym> :)
13:12:51 <vixey> ari++
13:12:53 <Peaker> MyCatVerbs, O(n^2) is still better than O(k^n) :-)
13:13:13 <MyCatVerbs> Peaker: well yeah. I'm still deeply curious as to whether it can be done in O(n) though.
13:13:14 <gwern> jfredett: interesting model. how does it handle disagrements on what the info is?
13:13:21 <jfredett> gwern: it won't be done for quite a while, in fact, I think I need to start again.
13:13:21 <mercury^> unless k=1 ;P
13:13:29 <jfredett> gwern: yes, democratically.
13:13:48 <jfredett> gwern: if there are multiple players with differing data on a location
13:13:57 <Peaker> MyCatVerbs, now I am going to think about it - and maybe try to do it - even though theory has already proven it impossible! :-)
13:14:05 <Peaker> (maybe it has, that is)
13:14:12 <MyCatVerbs> Peaker: I should read that paper already, huh? ;)
13:14:28 <Peaker> MyCatVerbs, Its interesting to try to solve a riddle, even if someone solved it already, though :)
13:14:29 <jfredett> then the most recent data is considered "best" and then the number of people with that particular copy of data weigh in it's favor
13:14:48 <gwern> majority rule, huh. hm. I guess that's the best you can do if there's no way to 'check' the info, although if your world is deterministic (generated from a seed?) I guess you could start toying with ideas like hash trees
13:14:48 <jfredett> some sample of the clients "vote"
13:15:11 <jfredett> gwern: haven't got that far in my thinking
13:15:14 <ravi_master> MyCatVerbs: sorry, can't dig out the original  problem you're talking about, what is the algorithm you're talking about for?
13:15:39 <jfredett> originally I wasn't designing a persistent world, i wasn't even designing a multiplayer game
13:15:45 <gwern> jfredett: no, no, I don't blame you. a mmo is a huge undertaking
13:15:54 <jfredett> then I said, "well that would be cool, scaling would be free!"
13:16:02 <jfredett> and thats why I need to restart... :/
13:16:08 <praseodym> vixey: http://www.randomhacks.net/articles/2007/03/12/monads-in-15-minutes uses a very simple monad for the actual backtracking. I wonder if I could rewrite your solution to that.
13:16:13 <Peaker> MyCatVerbs, thinking about algorithms after a long workday is not as fun :P
13:16:19 <gwern> it'd be too much to ask for a full advanced security model in addition to a working model, from a single coder, even if you're real goosd
13:16:23 * MyCatVerbs fires up evince.
13:16:35 <jfredett> I think I'm going to restructure it to have a central server that doesn't do much more than keep all the data from the world
13:16:45 <jfredett> kindof a central library
13:16:57 <gwern> I mean, a mmo with some sort of hash tree verified shared world? that sounds like a not too shabby master's or phd thesis to me, especially given application to single-player games
13:16:58 <jfredett> so a semi-decentralized game
13:17:16 <shepheb> is there any vague time to expect a 6.10 release by?
13:17:17 <gwern> (and it has obvious parallelization possibilities for multi-core)
13:17:29 <MyCatVerbs> Peaker: http://laurikari.net/ville/cv.html#thesis
13:17:32 <jfredett> gwern: they let you write games for a phd thesis?
13:17:46 <jfredett> I'm just a Undergrad... Thats freaking sweet...
13:17:49 <gwern> shepheb: doomsday/dnf release/hurd 1.0/haskell prime/etc.
13:17:50 <vixey> praseodym: I think it's the list monad with choose = id
13:17:58 <MyCatVerbs> Peaker: "Efficient submatch addressing for regular expressions" -- nice topic for a thesis.
13:18:02 <gwern> jfredett: look on Hackage; Frag, at they very least, was a master's thesis
13:18:10 <vixey> praseodym: A beautiful peice of code which is relevant is LogicT
13:18:12 <jfredett> I figure the hard part is getting the persistent world bit.
13:18:24 <Peaker> jfredett, you use a p2p network protocol? TCP or UDP?
13:18:25 <gwern> jfredett: I think the idea is you'd investigate properties of the data structure, with the mmo as proof it works :)
13:18:28 <MyCatVerbs> Peaker: hits it up in O(n) time and O(k) space, where k is determined by the regular expression. Not sure how big that gets, but anyway. The whole thing's single-pass.
13:18:31 <jfredett> that really informs the other areas that need persistance
13:18:52 <jfredett> Peaker: right now, the clients run on 1 machine, and communicate via stdio
13:19:00 <Peaker> MyCatVerbs, sounds great-  regexp implementors are thus either lazy or incompetent
13:19:13 <gwern> Peaker: or evil?
13:19:16 <MyCatVerbs> Peaker: or both?
13:19:21 <jfredett> the format is fairly easy to translate to TCP or whatever later on
13:19:22 <ari> @. djinn type maybe
13:19:25 <rahaskella> f a b c =
13:19:25 <rahaskella>     case c of
13:19:25 <rahaskella>     Nothing -> a
13:19:25 <rahaskella>     Just d -> b d
13:19:28 <Peaker> jfredett, I have some insights about a particular method of doing real-time networking in games, if you're interested
13:19:28 <MyCatVerbs> Peaker: or maybe they just -really- like having backreferences for some reason.
13:19:38 <ari> There... any other breakage?
13:19:55 <jfredett> Peaker: I'm interested in everything, put it on a blog and I'll subscribe... :)
13:20:03 <Peaker> jfredett, I'm too lazy for that :)
13:20:10 <gwern> your ideas intrigue me...
13:20:17 <jfredett> lol, Blogging is the laziest activities ever.
13:20:21 <praseodym> vixey: the LogicT pythagorean_triples is rather long, when a generator would be just one line
13:20:33 <jfredett> put ads on it and you're getting paid to give away your opinion
13:20:55 <MyCatVerbs> jfredett: ummm, no.
13:21:04 <gwern> jfredett: omg, you mean you can get *paid* to write stuff?
13:21:05 <MyCatVerbs> jfredett: reading blogs is even lazier.
13:21:14 <MyCatVerbs> gwern: SHUT UP SHUT UP SHUT UP
13:21:20 <jfredett> No, cause then you have to thing about it, MyCatVerbs
13:21:21 <gwern> why the hell have I been writing emails and stuff into #haskell for *free*??1
13:21:26 <jfredett> think*
13:21:27 <MyCatVerbs> gwern: keep it down, damn you, or the JOURNALISTS will catch wind of it!
13:21:33 <Peaker> jfredett, it is relevant to your game if you prefer to have the game stall all actions for a short period of time, rather than having a server (which increases latency and makes players lose sync with the server's state for significant whiles), or having "prediction" algorithms which make players lose sync with each other for short whiles (both of the latter causing quirky jumps, as in most FPS net games)
13:21:45 <gwern> MyCatVerbs: yeah, they'll steal our racket
13:21:46 <praseodym> gwern: you don't see the textual advertisments on the right side?
13:21:57 <MyCatVerbs> gwern: And goodness only knows what chaos will erupt once NOVELISTS start getting in on the idea. Oh, crap.
13:21:59 <newsham> whats the free market value of an uniformed opinion/
13:22:04 <newsham> i'm raedy to sell out
13:22:07 <jfredett> Peaker, my idea is to actually have the players act asynchronously
13:22:07 <gwern> praseodym: no...
13:22:13 <jfredett> unless they're near to each other
13:22:22 <gwern> MyCatVerbs: civilization would end under the weight of their turgid prose
13:22:22 <MyCatVerbs> newsham: depends on your standard of writing, and your skill at trolling.
13:22:28 <MyCatVerbs> newsham: quite a lot, I think.
13:22:34 <jfredett> so each client would periodicly poll to see if anyone is nearby
13:22:58 <jfredett> if so, then they would sync up, otherwise, it doesn't matter too much
13:22:59 <Peaker> jfredett, sounds like a difficult thing to implement though - how do you know when to make it synchronous because they are starting to get closer?
13:23:00 <vixey> > [ (2*u*v, u^2-v^2, u^2+v^2) | u <- [1..] , v <- [1..] , u`gcd`v == 1 , u > v , even (u+v) && not (odd u) ]
13:23:06 <rahaskella>  Exception: Time limit exceeded
13:23:07 <MyCatVerbs> gwern: forget civilization.
13:23:10 <Peaker> jfredett, what if syncing up needs to make retroactive changes?
13:23:12 <vixey> > [ (2*u*v, u^2-v^2, u^2+v^2) | u <- [1..] , v <- [1..] , u`gcd`v == 1 , u > v ]
13:23:18 <rahaskella>  Exception: Time limit exceeded
13:23:21 <MyCatVerbs> gwern: it would become impossible to get a decent sandwich! ;-;
13:23:23 <vixey> > [ (2*u*v, u^2-v^2, u^2+v^2) | u <- [1..] , v <- [1..] , u > v ]
13:23:25 <vixey> oh :/
13:23:30 <vixey> > [ (2*u*v, u^2-v^2, u^2+v^2) | u <- [1..] , v <- [1..u] , u`gcd`v == 1 , u > v , even (u+v) && not (odd u) ]
13:23:31 <Peaker> jfredett, Some games use that approach - I hate retroactive changes when I play :)
13:23:32 <rahaskella> Terminated
13:23:37 <rahaskella>  Exception: Time limit exceeded
13:23:44 <jfredett> Peaker: thats a ways out of the gate...
13:23:49 <Peaker> jfredett, I am totally frustrated and disoriented when Quake quirks and puts me completely elsewhere from where I was
13:23:55 <jfredett> Peaker: I don't think it will be a problem. :)
13:24:11 <Peaker> jfredett, Did you play Starcraft?
13:24:19 <praseodym> @let t n = [(x,y,z) | x <- [1..n], y <- [x..n], z <- [y..n], x^2 + y^2 == z^2]
13:24:21 <rahaskella> Defined.
13:24:28 <praseodym> t 10
13:24:34 <praseodym> > t 10
13:24:35 <rahaskella> Terminated
13:24:37 <jfredett> Peaker: the other thing, is that each game action will be sent for "verification" or a host of other clients. so ostensibly one could bundle location data with those
13:24:39 <praseodym> > t 5
13:24:41 <rahaskella> Terminated
13:24:45 <gwern> I personally find the asynchronoous ideas kind of interesting; we already have a good handle on how to handle asynchronoous changes to shared state, don't we?
13:24:48 <jfredett> Peaker: once upon a time
13:24:59 <gwern> let's apply game updates in accordance with the darcs patch theory! :)
13:25:13 <ari> praseodym: ... I see you found the "more breakage" I asked for :(
13:25:18 <gwern> *darcs lifestyle
13:25:20 <praseodym> ari: haha :)
13:25:32 <jfredett> gwern: well, my idea is effectively to model the brain, and have persistence and synchronity be emergent properties of the network of clients.
13:25:46 <jfredett> each client is like an ant in a colony,
13:25:58 <Peaker> jfredett, well if you don't mind having retroactive fixes to game state, anything is possible, I hate that though :)
13:26:04 <Peaker> jfredett, or can you achieve that without retroactive changes?
13:26:12 <praseodym> > t 50
13:26:14 <rahaskella> Terminated
13:26:14 <jfredett> Peaker: I think I'll be able to.
13:26:28 <jfredett> Peaker: but like I said, I haven't got that far in my thinking yet.
13:26:28 <gwern> oh yay, jfredett is of the school of thought: 'let's use brute force to solve problems'
13:26:38 <praseodym> ari: any idea why it's broken?
13:26:46 <jfredett> gwern: not brute force, _smart_ brute force.
13:26:59 <praseodym> aka backtracking?
13:27:04 <Peaker> jfredett, In Starcraft, do you remember the settings "low latency", "high latency", "extra high latency"?
13:27:12 <jfredett> vaugely
13:27:13 <ari> praseodym: No. At least it gets farther than the last time I installed lambdabot, though - back then it didn't even allow you to @let :p
13:27:26 <Peaker> jfredett, "extra high latency" lets you have a real-time game without delays, even if someone is 200ms away from you
13:27:36 <praseodym> ari: haha :) where did the 'real' lambdabot go though?
13:27:38 <conal> jfredett: "synchronity" in the jungian sense?
13:27:59 <jfredett> gwern: its like my father says, "You can have all the math in the world, but the best solution is still piss-elegant brute-force."
13:28:09 <jfredett> conal: I have _no freaking clue_.
13:28:14 <jfredett> I'm not a philosopher
13:28:20 <jfredett> i barely get away with math
13:28:31 * gwern disagrees. a solid algorithm is better than brute force!
13:28:31 <conal> jfredett: what do you have in mind with "synchronity"?
13:28:33 <ari> praseodym: I don't know, beyond 02:57  * edwardk apologizes for killing lambdabot
13:28:53 <vixey> > [ (2*u*v,u^2-v^2,u^2+v^2) | u <- [1..] , v <- [1..u] , (even u && odd v)||(odd u && even v) ]
13:28:56 <rahaskella>  [(4,3,5),(12,5,13),(8,15,17),(24,7,25),(20,21,29),(40,9,41),(12,35,37),(36,2...
13:29:02 <gwern> conal: in the jungian sense? no way
13:29:09 <conal> jfredett: your description description (ants, brain, synchronity, emergent properties) caught my attention & interest!
13:29:26 <jfredett> conal: are you the guy who does the FRP stuff?
13:29:32 <conal> jfredett: yep
13:30:02 <jfredett> conal: cool, i feel like I'm talking to a celebrity, I saw you on my TV (well, my computer, but it's kindof like my tv).
13:30:08 <Peaker> is there a logical xor operator?
13:30:11 <conal> jfredett: the google tech talk?
13:30:20 <gwern> conal: how would jungian synchronity even apply here?
13:30:21 <gwern> yes
13:30:27 <gwern> Peaker: =\?
13:30:40 <gwern> True =\ False, True =\ True...
13:30:42 <ari> Though, well, I don't think it was his fault... and I'll test it now:
13:30:43 <ari> @pl \f -> fmap (bimap f (fmap f))
13:30:43 <rahaskella> fmap . ap bimap fmap
13:30:43 <conal> gwern: i tuned into the middle of the show
13:30:49 <Peaker> gwern, is that in a module?
13:30:55 <jfredett> conal: i suppose I meant that synchronousness is not always required, and can be a special case of the system
13:31:10 <conal> jfredett: oh! synchronous/asynchronous !
13:31:15 <jfredett> conal: yah, I think it was the tech talk, it had pretty pictures, thats mostly what I remember.. :)
13:31:22 <conal> jfredett: :)
13:31:27 <chessguy> is there a standard data structure for something with a base that you add things to?
13:31:31 <praseodym> vixey: nicer than the backtracking using LogicT, but maybe not faster
13:31:38 <Peaker> jfredett, a completely asynchronous network game might not really be a network game :)
13:31:47 <conal> jfredett: if pretty pictures, it might have been an old talk on Pan (functional image synthesis)
13:31:49 <ziman> @src filterM
13:31:49 <rahaskella> Source not found. This mission is too important for me to allow you to jeopardize it.
13:31:56 <vixey> praseodym: I don't think you understand LogicT ..
13:32:17 <vixey> praseodym: It wasn't designed to calculate pythagorean triples
13:32:42 <gwern> (or whatever the actual not-equals function name is)
13:32:43 <gwern> consistent global state, maybe he means
13:32:43 <gwern> Peaker: a module? the Prelude, I suppose
13:32:43 <gwern> ah, it was (/=)
13:32:52 <jfredett> Peaker, conal: effectively, each ant can act asynchronously as long as it doesn't violate any rules, the points where synchronous activity are needed are few.
13:32:53 <Peaker> vixey, given logical xor,  I think your  even/odd expression there could be simply (even u `xor` even v)
13:32:57 <conal> jfredett: i got quite the mistaken picture from brain, persistence, synchronicity, emergent properties.  i thought you wer talking psychology
13:33:08 <conal> jfredett: neat!
13:33:33 <praseodym> vixey: I understand, but I don't like examples which aren't, well, real examples
13:33:38 <jfredett> conal: mind you, I have no idea if any of this is feasible. It only seems plausible... :)
13:33:40 <gwern> Peaker: xor in Data.Bits or whatever is for bits; /= is for everything else
13:33:45 <Peaker> jfredett, but in order to know which points need synchrony, you need general sync
13:33:58 <jfredett> Peaker: see, I think theres got to be a way around that.
13:34:00 <Peaker> gwern, yeah, dealing with booleans he could use that
13:34:03 <conal> jfredett: i hope you do pursue it.
13:34:16 <vixey> > (\(p,q)->(p&&q)||(not p&&not q),p`xor`q) [(False,False),(False,True),(True,False),(True,True)]
13:34:17 <rahaskella>  Couldn't match expected type `t1 -> t'
13:34:26 <vixey> > map (\(p,q)->(p&&q)||(not p&&not q),p`xor`q) [(False,False),(False,True),(True,False),(True,True)]
13:34:27 <rahaskella>  Couldn't match expected type `a -> b'
13:34:44 <vixey> > map (\(p,q)->((p&&q)||(not p&&not q),p`xor`q)) [(False,False),(False,True),(True,False),(True,True)]
13:34:45 <rahaskella>   add an instance declaration for (Bits Bool)
13:34:45 <rahaskella>     In the expression: p `xor` ...
13:34:53 <ari> @instance-importing Data.Bits Bits
13:34:54 <gwern> :t xor
13:34:54 <rahaskella> Int, Integer
13:34:57 <rahaskella> forall a. (Bits a) => a -> a -> a
13:35:03 <Peaker> jfredett, you might get away with less synchrony, for example, if all clients have sync'd timers, and know that it will take at least N ticks in the fastest case to require sync, then they can remain async for that amount of time
13:35:15 <chessguy> @hoogle MonadPlus
13:35:16 <rahaskella> A Hoogle error occured.
13:35:22 <vixey> Peaker: well, can you prove it?
13:35:28 <gwern> so, would 0 be True, or would it be False? :)
13:35:32 <Peaker> vixey, prove what?
13:35:47 <vixey> your statement
13:36:28 <jfredett> Peaker: recently, I've been leaning towards a minimal central server, having most of the game logic/real work being done on the client
13:36:32 <ari> Whoa, hoogle is an external binary, too? *installs*
13:36:43 <conal> jfredett: i bet the issues you're thinking about would apply to distributed FRP, which interests me a lot.
13:36:47 <jfredett> and having the server provide a reference clock, verifying client actions.
13:36:55 <Peaker> vixey, Isn't it self-evident? Maybe I missed some ground assumptions? Such as all clients have the full state and are sync'd before that async-period
13:37:13 <jfredett> conal: I feel smart now, I thought I was just hacking up a little game... :)
13:37:19 <Peaker> jfredett, my problem with a server is that it can easily double the latency, and in a real time game, that's a bitch :(
13:37:34 <gwern> ari: yep, it's a handy cli tool
13:37:36 <jfredett> Peaker: but maybe the server could act asynchronously
13:37:48 <jfredett> a client yells a the server for people near him
13:37:54 <jfredett> the server gets back to him when he can
13:38:10 <ari> @hoogle MonadPlus
13:38:11 <rahaskella> Control.Monad.MonadPlus :: class Monad m => MonadPlus m
13:38:13 <ari> There we go
13:38:18 <praseodym> can I use a guard instead of a if-then-else in a do?
13:38:27 <jfredett> if theres a fixed speed at which everything can travel, then you could calculate early enough to get the info you need
13:38:38 <jfredett> I wish IRC had whiteboards...
13:38:46 <gwern> Peaker: if you're willing to do stuff you could do optimistic p2p: 'ask peers what's going on, and the server too; if the peers reply first, trust them and update state; if the server replies with different state, throw the peer's state away and use the server's state'
13:38:55 <conal> jfredett: i've been wondering how to deal with some of these issues even locally, where they might be escapable, but in a distributed setting, they must be faced.  pure, and hence determinate, semantics is very important to me.
13:39:01 <gwern> jfredett: someone was working on a collaborative text editor in haskell which had similar issues to this discussion
13:39:05 <Peaker> jfredett, well, if all clients have the full state without the server, and the server transmits only forward-deltas, and not whole-states to clients, I am not sure it allows losing sync
13:39:07 <gwern> gobby, or something
13:39:14 <Peaker> jfredett, I mean I am not sure it helps
13:39:36 <jfredett> Peaker: i think thats the case
13:39:48 <Peaker> gwern, Yeah - but trying to avoid retroactive changes.. I can't stand a game that does retroactive changes on me :-)
13:39:58 <jfredett> the problem lies when a client tries to interact with another
13:40:10 <jfredett> and the question is, how does one client know when another is nearby
13:40:21 <jfredett> and how does any given method for solving that problem scale
13:40:39 <Peaker> jfredett, is it a massively-multiplayer thing?
13:40:42 <gwern> Peaker: well, that's what I meant by 'willing to do stuff'
13:40:44 <jfredett> Peaker: ideally
13:41:07 <Peaker> jfredett, oh, then my approach (which I think is the Starcraft approach) will not work well, at least without some major modification
13:41:48 <Peaker> gwern, I don't mind that lag makes everyone's game "stuck" for 200 ms or so, as long as it avoid retroactive changes
13:42:24 <jfredett> Peaker: right, so, this is good- the two fundamental problems are knowing when to sync and how to do it, and distributing state amongst clients and retrieving it
13:42:44 <Peaker> jfredett, WoW has something like that, doesn't it?
13:42:45 <jfredett> Peaker: and the fundamental problem with the game itself will be avoiding cheating on the part of any player
13:42:54 <jfredett> Peaker: no clue, whats WoW?
13:42:59 <Peaker> jfredett, world of warcraft
13:43:22 <jfredett> jfredett: warcraft, as in blizzard?
13:43:25 <Peaker> yeah
13:44:17 <jfredett> oh, WoW is an mmo, i didn't know they had MMO's at blizzard, i haven't played games in a while... :/
13:44:23 * jfredett googles
13:44:27 <conal> omg, my generalized derivatives code just got incredibly simple.  blog post to follow.
13:44:35 <Peaker> there's also everquest, not sure if its similar though
13:44:42 <jfredett> well thats an incredibly ugly game
13:44:51 <jfredett> everquest I remember
13:45:12 <jfredett> hadn't heard of WoW, which is surprising, given its prevalence on google.
13:46:26 <Peaker> WoW is (was?) huge
13:46:47 <jfredett> Peaker: I don't play games much, I only just got over Doom II...
13:47:07 <Peaker> I was seriously addicted to Starcraft :)
13:47:10 <jfredett> What I'm surprised at, is that my brother didn't tell me about this, he's a big gamer guy.
13:47:12 <Peaker> I still play once in a while
13:47:21 <jfredett> he tried to make me play counterstrike
13:47:30 <jfredett> things have come a long way since doom.
13:47:48 <Peaker> counterstrike is hard to get into, you get shot once, you die, you wait 3 minutes to respawn, and so on... take a long time to get good enough to enjoy it
13:48:02 <jfredett> i played one of the other ones, Day of Defeat
13:48:05 <jfredett> that was fun.
13:49:52 <Peaker> Call of Duty was fun (Single player). Historically accurate, mostly, too
13:50:06 <Peaker> except maybe German soldiers weren't THAT stupid
13:50:07 <chessguy> conal: care to take a look at another class that i want to refactor?
13:50:36 <jfredett> in any case, I need to get back to cleaning, this was supposed to be a 10 minute procrastination... :)
13:50:55 <jfredett> I'll have to think about that game some more, apparently it's interesting... :/
13:51:27 <jfredett> i should probably eat today too... I always forget..
13:52:30 <conal> chessguy: point me to it, and i'll see if i have any initial comments.
13:53:00 <chessguy> conal: http://code.haskell.org/ChessLibrary/Chessboard.hs
13:54:59 <Peaker> chessguy, I think you could factor out a lot of the common logic of the various pieces' moves, so you only have a single moves method, that is either inside a Piece class, or takes the piece as an argument
13:55:17 <chessguy> Peaker: agreed
13:55:39 <chessguy> Peaker: i suspect there's something more fundamental though
13:55:59 <cnwdup> I am toying around with threads trying to find a adequate model for a potential [common x11 notifier name] clone. I now have a piece of code which I expect to be most adequate (in relation to my earlier pieces), but somehow it doesn't produce *any* output.
13:56:24 <cnwdup> May someone take a look at the code? http://hpaste.org/7735 I was expecting to get the line "one two three hour" about every second.
13:57:15 <cnwdup> I hope the missing comments are ok. I can comment the file more if you want. Being new to haskell it's hard to estimate how readable my code is.
13:57:19 <conal> chessguy: a first superficial comment: in moveFromRays, move the third argument to the first.  then eta-reduce the default_fooMoves functions.  better yet, inline them at their uses (assuming just one).
13:57:52 <chessguy> ok
13:58:50 <conal> chessguy: i'm noticing that i start out giving you superficial suggestions, shuffling notation around.  i guess the first thing i do is reduce the surface complexity (increase regularity) so i can better see what's going on .
13:58:57 <sw17ch> cnwdup, i get it twice per second
13:59:41 <chessguy> oh, in that case, there's probably a lot of those kinds of changes i could make
13:59:45 <cnwdup> sw17ch: That's weird. I get just nothing. I am compiling with ghc --make Main -o main, right?
14:00:00 <sw17ch> cnwdup, i just ran it through ghci
14:00:01 <sw17ch> :)
14:00:06 <sw17ch> let me try compiling it...
14:00:28 <Peaker> chessguy, You've inspired me to write my own chess thingie :-)
14:00:32 * Peaker needs Haskell practice
14:00:34 <sw17ch> yeah, now it's hanging up on me
14:00:42 <conal> chessguy: yeah.  everywhere you see anything repetitious, try to refactor locally.  after a while, you may start seeing deeper patterns.
14:00:42 <cnwdup> Yeah, in ghci it's working fine. That's actually cool. (-: Though I'd like to know why it isn't running being compiled with ghc.
14:00:54 <sw17ch> it's output flushing i bet
14:01:04 <conal> chessguy: e.g.,, default_moves could probably be a one-liner
14:01:05 <chessguy> conal: yeah, i agree, i guess i just thought the more fundamental stuff should come first
14:01:28 <sw17ch> no, it's not... hmm
14:01:51 <chessguy> i suspect there's at least a Foldable hiding in there
14:01:52 <cnwdup> heh, in ghci it's working like a charm. (-=
14:02:49 <Peaker> is there an elegant stdlib way of repeating a function composition?  a . a . a . ... (n times)
14:02:49 <conal> chessguy: i get overwhelmed with complexity/noise, so first tidy up until i can look at the code calmly/clearly/deeply.
14:03:00 <cnwdup> Are there any compile flags I have to specify compiling threaded programs?
14:03:07 <conal> :type repeat
14:03:12 <conal> :type iterate
14:03:17 <vixey> (!!n) . iterate
14:03:36 <Torment> cnwdup: --threaded
14:03:36 <vixey> I would not call it elegant though
14:03:57 <chessguy> conal: fair enough. let me spend some time doing that kind of cleanup and get back with you later this week
14:03:59 <ddarius> foldr (.) id . replicate n
14:04:10 <sw17ch> cnwdup, yes...
14:04:11 <sw17ch> --threaded
14:04:15 <conal> chessguy: sounds good to me.
14:04:35 <Peaker> conal, vixey, ddarius Thanks
14:04:42 <sw17ch> err... -threaded
14:04:48 <cnwdup> hehe, thanks
14:05:06 <cnwdup> Great, with that it's working in ghc either. Thank you, guys!
14:05:11 <conal> Peaker: :)
14:05:57 <luqui> @bot
14:05:58 <rahaskella> :)
14:06:08 <sw17ch> in ghc also?
14:07:52 <sw17ch> hmm... weird... i didn't realize that you could have that kind of blocking in GHC
14:07:53 <cnwdup> sw17ch: yeah
14:08:02 <sw17ch> where a thread may never run
14:09:01 <sw17ch> cnwdup, i'm not sure if this will help you with your circumstance... but it looks like you could benefit from MVar's
14:09:16 <sw17ch> rather than polling the IORef
14:09:39 <sw17ch> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html
14:09:44 <cnwdup> sw17ch: I actually don't poll the IORefs but have a SampleVar (quite similar to MVar) for that. (-:
14:09:53 <sw17ch> oh, look at that...
14:09:54 <sw17ch> :)
14:10:05 * sw17ch graduated yesterday, perhaps he should go back....
14:10:52 <chessguy> err, what does eta-reduce mean?
14:10:55 <cnwdup> Hum, compiling with -threaded creates separate threads showing up in htop. That means I cannot benefit from ghc's light thread features, right?
14:11:04 <ddarius> \x.f x ~> f
14:11:05 <sw17ch> hah, type SampleVar a = MVar (Int, MVar a)
14:11:06 <Heffalump> chessguy: \x -> f x --> f  (if x not free in f)
14:11:17 <chessguy> oh, so making point-free
14:11:29 <sw17ch> cnwdup, run your program with the +RTS options
14:11:40 <ddarius> cnwdup: GHC threads are spread over multiple OS threads.
14:11:54 <sw17ch> ./main +RTS -N2
14:12:08 <sw17ch> where 2 is the number of *real* threads you want to use
14:13:04 <cnwdup> Could you give me a link to documentation about that? (-: By now I don't see the advantages and disadvantages yet and can I somehow specify RTS and -N at compile time?
14:13:43 <cnwdup> sw17ch: Oh, and +RTS -N2 doesn't minimise the threads actually being started for me. :D
14:14:04 <sw17ch> hehe, actually, i'm not sure how it works on the backend... but the -N option specifies the size of the threadpool to use
14:14:29 <cnwdup> I think I have to read those parts in ghc's manual.
14:14:42 <sw17ch> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#v%3AforkOS
14:14:54 <sw17ch> check out the last paragraph of the forkOS description
14:14:56 <awesame> is there a GHC equivalent to WinHUGS?
14:15:14 <awesame> er, WinHugs
14:15:56 <sw17ch> cnwdup, also see the bottom of that page on Pre-Emption
14:16:26 <chessguy> @pl \f -> r f c s
14:16:26 <rahaskella> flip (flip r c) s
14:17:22 <lilac> > runQ [| \l -> map (1:) l |]
14:17:23 <rahaskella>  Parse error at "|" (column 7)
14:20:30 <dmwit> awesame: No, ghci is the closest you get to WinHugs, I think.
14:20:37 <dmwit> (WinHugs is just the GUI front-end, right?)
14:20:51 <ndm_> dmwit: yes
14:21:04 <ndm_> no, nothing like WinHugs for GHC, yet - although i do intend to write it at some point
14:21:06 <nolrai_> whats WinHugs?
14:21:22 <ndm_> @google winhugs
14:21:24 <rahaskella> http://www-users.cs.york.ac.uk/~ndm/winhugs/
14:21:24 <rahaskella> Title: Neil Mitchell - WinHugs
14:21:27 <cnwdup> sw17ch: So because I lock the handle to the Sample Var in line 22 in the main thread no other threads will be called?
14:22:54 <sw17ch> cnwdup, honestly, i'm not sure. i was thinking that's why it wasn't running without the -threaded option earlier
14:22:55 <jaj> rahaskella? lambdabot underwent a gender change? :)
14:23:09 <dmwit> \bot has always been female
14:23:14 <dmwit> @vixen: asl?
14:23:15 <rahaskella> 19/f/California
14:23:18 <dmwit> See?
14:23:24 <jaj> :)
14:23:26 <cnwdup> Yeah. But thus I cannot make use of haskells internal threads which are more efficient than os threads?
14:23:32 <cnwdup> That'd be a pitty.
14:23:45 <sw17ch> cnwdup, i'm sure you still can... just need to do some digging
14:24:08 <sw17ch> (i'm relatively new to haskell also, about a year so far. i'm not the best person to ask these things, but i know a little.)
14:24:18 <cnwdup> sw17ch: Code changes or compile argument changes?
14:24:36 <cnwdup> Yeah, no problem that you are not quite sure with the answers you give. They're still very helpful. (-:
14:24:37 <sw17ch> actually, i *think* you're still okay
14:24:44 <cnwdup> ok
14:25:00 <sw17ch> are the read/write sampleVar's blocking like they are with MVar's?
14:25:07 <cnwdup> Yep
14:25:11 <sw17ch> alright, then you're okay
14:25:19 <cnwdup> In fact read is blocking, write is not.
14:25:30 <sw17ch> write is not blocking? hmm
14:25:32 <sw17ch> interesting
14:25:38 <Cale> That's the point of SampleVars
14:25:40 <sw17ch> the MVar's are blocking on both
14:25:45 <cnwdup> As SampleVar are MVars which won't block on writing as they overwrite the var if it isn't empty.
14:25:50 <cnwdup> Yeah, that's the only differance.
14:25:57 <sw17ch> very cool...
14:26:39 <sw17ch> well, then you're fine. i'm still not sure why it didn't work without the -threaded option.. my only guess is that you have a tight loop in here that doesn't need to block on anything
14:26:44 <sw17ch> and that was stealing all the resources
14:27:42 <cnwdup> Well, every loop at least sleeps for one second. There should be no tight loops. *shrug*
14:29:44 <sw17ch> odd
14:30:28 <Cale> Is the code pasted?
14:30:44 <cnwdup> cale: http://hpaste.org/7735
14:30:55 <Cale> grr, I wonder when Isaac is going to reenable my code account.
14:31:30 <Cale> any reason to be using sleep instead of threadDelay?
14:31:52 <sw17ch> cnwdup, yeah, sorry... offhand i'm not sure why it's not running well without the -threaded option
14:31:59 <cnwdup> I thought threadDelay was used to delay a thread from the main thread. Isn't that right?
14:32:12 <Cale> It delays the thread that it's called from
14:32:12 <cnwdup> sw17ch: (-: But thanks for all your help.
14:32:31 <Cale> sleep, well, I'm not even sure what effect sleep will have
14:32:32 <cnwdup> cale: Oh, then I can actually use it. Is sleep a foreign library call?
14:32:36 <Cale> yeah
14:32:53 <Cale> It'll probably block the OS thread which is running the current thread?
14:32:58 <cnwdup> Ah, okay. Then this might be the answer as they should block the thread. I mean, really block.
14:32:59 <Cale> That'll have confusing effects. :)
14:33:41 <Cale> Note that threadDelay's parameter is in microseconds
14:33:52 <cnwdup> Yeah. :D tm * 10^6 will do. (-:
14:34:04 <sw17ch> I've asked this before, but lets try it again. Are there any ways of playing audio with Haskell without writing to /dev/dsp?
14:34:12 <cnwdup> Great. Now it's working even without the -threaded switch!
14:34:49 <chessguy> if i have data Foo = Bar | Baz, can i have Bar and Baz be instances of classes?
14:34:56 <Botje> no
14:35:04 <Botje> Bar and Baz are data constructors
14:35:06 <chessguy> fooey
14:35:13 <Botje> only Foo (the type constructor) can partake in type parties
14:35:23 <ddarius> sw17ch: Look at what's on hackage and/or just FFI to something.
14:35:34 <sw17ch> ...sorry, FFI?
14:35:34 <jaj> Cale: I think libc sleep will delay the process, not the thread
14:35:44 <sw17ch> oh, foreign function interface
14:35:46 <sw17ch> :) ty
14:35:48 <Cale> jaj: That's also possible
14:35:57 <ddarius> @where ffi
14:35:58 <rahaskella> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
14:36:24 <Cale> sw17ch: iirc, there was a binding to OpenAL somewhere...
14:36:41 <sw17ch> Cale, OpenAL is much more than i need
14:36:45 <dons> sw17ch: openal, there's some other music generation libs that must bind to outputters as well.
14:36:50 <dons> just snoop around hackage.haskell.org
14:37:27 <sw17ch> dons, that's where I'm looking right now. if there's something lacking, would that be a project people would appreciate having? a (hopefully) cross platform sound library?
14:37:48 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/OpenAL
14:38:13 <Cale> sw17ch: More libraries are always good :)
14:38:20 <dons> sw17ch: sure. check what other languages provide (e.g. python) and see if there's something you can contribute
14:38:23 <dons> ?users
14:38:24 <rahaskella> Maximum users seen in #haskell: 456, currently: 440 (96.5%), active: 14 (3.2%)
14:38:29 <dons> 400+ users, should be writing 400+ libraries!
14:38:38 <dcoutts> @tell ndm the captcha on your blog is borked, the picture does not appear, it's a 404 link.
14:38:39 <rahaskella> Consider it noted.
14:39:10 <dcoutts> dons: see ndm's post on performance, it's basically spot on.
14:39:16 <dons> yeah, i was just going to say :)
14:39:26 <dcoutts> dons: we should put that advice on the haskell wiki performance pages
14:39:37 <dcoutts> with ndm's permission of course
14:39:43 <dons> yep. i'm sure he'd be happy to.
14:39:49 <dons> its more up to date than the old performance page
14:40:00 <dons> and there's low level things we know now, that have changed over the years
14:40:30 <dons> now, we just need to get people to think about what their code is really doing
14:40:46 <dons> and give them the skills to understand to whatever depth they need
14:40:46 <dcoutts> yeah, there's no substitute for that
14:41:44 <dcoutts> some people seem to give up thinking logically and flounder around assuming magic and sprinkling ! because they heard that strictness was related to performance
14:41:56 <dons> though i'd argue that neil was a bit conservative in his "
14:41:57 <roconnor> ndm's post suggests to me that we ought to make a Core viewing program
14:41:58 <dons> Low-level Haskell is competitive with C" section
14:42:01 <roconnor> of some kind
14:42:11 <dons> "If you use GHC, with unboxed operations, written in a low-level style, you can obtain similar performance to C."
14:42:15 <dcoutts> dons: I think one key problem with understanding performance is understanding the evaluation order
14:42:20 <dons> is too conservative. we can operate a level or two above that now
14:42:30 <dcoutts> dons: and personally I think that's best done by looking at strictness backwards
14:43:11 <dcoutts> dons: ie operational, we know that the result is demanded (otherwise the function would not be called) now what is demanded by asking for the result in WHNF...
14:43:15 <dcoutts> and trace it backwards
14:43:42 <dons> yep
14:44:06 <dolio> I'm definitely not using magic hash all over the place with my sorting stuff.
14:44:39 <dcoutts> dons: eg foo = Bar baz where baz = ...
14:45:03 <dcoutts> dons: as an example for a beginner, if Bar is an ordinary constructor then this only demands Bar, and not baz
14:45:36 <dcoutts> dons: I remember when I was learning, once I looked at it in demand order this way it all became much more obvious what was going on
14:45:46 <dons> dolio: right. while writing in core directly is guaranteed to work, working one level above and undestanding the demand patterns, and how they affect optimisations, also works
14:45:50 <dcoutts> manual backwards strictness analysis
14:47:00 <dons> the complaints of late have been particular individuals having no idea what is going on though, sadly
14:47:11 <dons> which is frustrating. too much noise
14:48:06 <dcoutts> aye
14:48:24 <dcoutts> some people are impatient :-)
14:49:27 <scodil> anyone ever benchmarked Data.IntMap vs Data.Sequence for dense key spaces? Which is a better "purely functional array"?
14:49:30 <ddarius> I agree that being able to do some basic manual strictness analysis is necessary.  If you can't, then you probably won't be able to figure out how to get what you want.
14:49:42 <dons> scodil: hmm, i think IntMap, but i can't remember what test i used
14:49:44 <dcoutts> scodil: I bet int map is
14:49:48 <dons> scodil: maybe i just tested insertion.
14:50:16 <scodil> ah ok. Yeah I was about to test but I'd figure I'd ask. Its hard to write benchmarks that actually tell you things
14:50:32 <dons> that would be really useful
14:50:35 <edwardk> chessguy you can make data Foo = Bar Bar | Baz Baz; data Bar = MkBar ...; data Baz = MkBaz ....; where then Bar and Baz can be instances of classes.
14:50:51 * edwardk realizes he has been scrolled back for 15 minutes.
14:51:04 <chessguy> edwardk: haha, that's ok, thanks :)
14:51:10 <shapr> edwardk: Strep throat sucks so much :-(
14:51:22 <edwardk> shapr: yeah
14:51:22 <chessguy> edwardk: it's the thought that counts :)
14:51:25 <ddarius> shapr: Don't get strep.
14:51:33 * shapr throws epimorphisms at edwardk (epidemic-morphisms)
14:51:48 * edwardk would dodge but is too tired and sick ;)
14:52:22 <scodil> antibodies are kind of like endomorphisms. Well, literally anyway
14:54:12 <edwardk> does anyone have any gadt based monad examples other than the couple of would-be set monads?
14:55:24 <dolio> IO? :)
14:55:30 <nolrai_> ddarius: what would you recomend to lern how to do "basic manual strictness analysis"?
14:55:52 <edwardk> dolio: heh
14:57:09 * dmwit ponders
14:57:14 <dmwit> Is there something like
14:57:35 <ddarius> nolrai_: It's something one should be able to do with an understanding of the semantics of Haskell constructs and a bit of logic.
14:57:44 <dmwit> data AlmostASet a = Setlike (Ord a => Set a) | Listlike [a] -- ?
14:57:57 <ddarius> nolrai_: Basically you just work backwards like dcoutts said earlier.
14:58:27 <edwardk> dmwit: those are the examples in question
14:58:32 <dmwit> oh, heh
14:58:41 * dmwit scrolls back a bit
14:59:36 <edwardk> lol. as usual anything interesting i work on was done (at least partially) by oleg 2 years earlier: http://okmij.org/ftp/Haskell/types.html#state-algebra is how i do monads in my untyped haskell =)
14:59:57 <Cale> I was thinking of using a GADT as the IO monad.
15:00:35 <edwardk> i kinda like the IO-as-free-monad run with the 'improving free monads' trick.
15:01:06 <vixey> aww
15:01:10 <ddarius> "'improving free monads' trick"?
15:01:13 <vixey> It's always annoying when that happens
15:01:16 <Cale> To really do it right and make it work with FFI, you'd need open GADTs :)
15:01:18 <edwardk> let me see if i can dig it up
15:01:32 <vixey> Cale: What is an Open GADT?
15:01:43 <Cale> One which you can add constructors to in a future module :)
15:01:47 <edwardk> http://wwwtcs.inf.tu-dresden.de/~voigt/mpc08.pdf
15:02:40 <Cale> Oh yeah, I saw that paper :)
15:03:23 <ddarius> roconnor, ski (I think) and I were discussing ideas similar to that paper following the last? ICFP contest.
15:03:40 <edwardk> iirc uses the monad you get from right kan extension of the free monad along itself, it just doesn't call it that
15:03:45 <edwardk> er iirc it
15:03:59 <roconnor> http://r6.ca/blog/20071028T162529Z.html
15:04:27 <roconnor> ddarius, ski and Saizan.
15:04:31 <dmwit> Needs more letters and numbers.
15:04:41 <dmwit> Especially in the domain name.
15:04:55 <roconnor> :)
15:06:21 <vixey> roconnor: wow!
15:06:55 <vixey> I guess the continuations get compiled into jumps in the G-machine ?
15:07:16 <roconnor> vixey: well, the case analysis is removed from bind
15:07:20 <edwardk> the 'monad generated by a functor f' is newtype Ran g h a = Ran { runRan :: forall b. (a -> g b) -> h b }; instantiated for Ran f f the one in the paper: newtype CTree a = CTree (forall b. (a -> Tree b) -> Tree b)
15:07:36 <roconnor> and things become fully associated to one direction
15:07:46 <roconnor> It's vaguely like using Dlists instead of lists
15:08:57 <edwardk>  i reinvented it the other day when playing with kan extensions (btw, damn you ddarius) =)
15:09:09 <noecksit> how would u be able to "cast" a value from MVar to its appropriate String datatype?
15:09:37 <dmwit> ?hoogle MVar
15:09:38 <rahaskella> Control.Concurrent.MVar :: module
15:09:38 <rahaskella> GHC.Conc.MVar :: data MVar a
15:09:38 <rahaskella> Control.Concurrent.MVar.MVar :: data MVar a
15:09:49 <Botje> noecksit: you don't "cast", you takeMVar or somesuch
15:09:49 <dmwit> :t takeMVar
15:09:55 <rahaskella> Not in scope: `takeMVar'
15:09:55 <noecksit> when u r using takeMVar
15:10:15 <noecksit> it return IO a
15:10:16 <roconnor> http://obfuscatedcode.wordpress.com/2008/05/17/unstacking-monads-for-performance/ didn't find a big performance boost in his code
15:10:31 <dmwit> noecksit: Yup, so you have to use it in the IO monad.
15:10:45 <dmwit> noecksit: All the techniques you use for using the result of (say) getLine apply here.
15:11:11 <noecksit> oh, i can use show
15:11:29 <ddarius> edwardk: You're the one I sent that crazy CT article, yes?
15:12:03 <edwardk> ddarius: yeah
15:12:20 <Peaker> computing chess moves is not all that easy, when you have all these weird exceptions (castling, the special pawn eating rule immediately after a pawn jump, etc)
15:12:21 <edwardk> ddarius: and whom you sent down the rabbit hole of kan extensions ;)
15:13:56 <dons> i'd like someone who's got an example where mtl isn't optimising properly to send it in
15:14:05 <dons> i'm happy to look at the inlining and optimisation of it.
15:14:39 <mike> I have a haskell exam tomorrow, the topics are List processing, Recursion, Algebraic Types and Higher order Functions. Anyone have some decent revision material?
15:15:01 <dons> hmm. should be links from haskell.org
15:15:05 <jfredett> I'd say review List processing, recursion, ...
15:15:06 <ddarius> edwardk: I ask because it mentions Lan_F F in relation to density (and so Ran_F F would relate to codensity).  The relation between Kan extensions and adjunctions may bring something up as well.
15:15:07 <jfredett> :P
15:15:19 <edwardk> ddarius: http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-KanExtension.html
15:15:30 <edwardk> i have a comonad for Lan as well
15:15:34 <jfredett> they seems to be pretty standard concepts, haskellwiki / the wikibook probably has pages on them.
15:15:57 * monochrom is tempted to suggest a wholesome Haskell textbook
15:16:12 <roconnor> dons: I thought we were using MonadLib nowadays
15:16:22 <dons> roconnor: are you?
15:16:24 <ddarius> monochrom: Textbooks don't have enough fiber as is?
15:16:38 <monochrom> haha
15:16:42 <dons> hpaste 2 uses monadLib, but yav's not too great at promoting it.
15:16:42 <mike> well I have textbooks , just looking for some short explanations I can try to remember if he asks me to explain anything
15:16:57 <roconnor> dons: I would for any new projects
15:16:58 <dons> mike: i remember that printing off a copy of the prelude is super useful
15:17:09 <dons> i did that 10 years ago for my comp 1A exam :)
15:17:34 <roconnor> largely because ContT Writer isn't a MonadWriter in the mtl.
15:17:35 <monochrom> "what is recursion?" does not take a lot to answer. :)
15:17:47 <dons> roconnor: though we've no info on how well monadLib optimises either
15:17:50 <Botje> "see recursion" ? :)
15:17:52 <dons> hmm, this might be a nice project actually
15:17:53 <ehird> Ah! I found the source of the 'it is very good use of my time'
15:17:54 <dons> mtl+perf
15:17:54 <monochrom> Yeah! :)
15:17:54 <ehird> "For personal reasons, I do not browse the web from my computer.  (I
15:17:54 <ehird> also have not net connection much of the time.)  To look at page I
15:17:54 <ehird> send mail to a demon which runs wget and mails the page back to me.
15:17:54 <ehird> It is very efficient use of my time, but it is slow in real time."
15:18:14 <jfredett> lol
15:18:20 <ehird> jfredett: real life rms email
15:18:22 <jfredett> Knuth, right?
15:18:24 <roconnor> dons: I'd rather see monadLib optimized over the mtl, if it were up to me.
15:18:25 <ehird> nope
15:18:26 <ehird> rms
15:18:27 <mike> do they teach haskell in many uk universities?
15:18:28 <jfredett> oh- RMS
15:18:33 <jfredett> RMS is a nutball.
15:18:36 <ddarius> edwardk: (Co)dense functors have continuity properties which lead to adjunctions which leads to (co)monads.
15:18:36 <mike> I'm at nottingham btw
15:18:37 <ehird> jfredett: I agree.
15:18:45 <ehird> jfredett: But it is very efficient use of his time.
15:18:56 <jfredett> Knuth is just old and cranky, RMS is nuts.
15:19:06 <edwardk> ddarius: hrmm i think maybe we're talking about different papers. i'm thinking of the short one you wrote
15:19:10 <monochrom> Very good idea. Most web pages are pointless.
15:19:17 <roconnor> jfredett: and Dijkstra?
15:19:24 <ehird> roconnor: Dijkstra is dead.
15:19:32 <dons> mike: yeah. oxford, nottingham, a fair few others.
15:19:40 <ehird> jfredett: knuth is also very, very religious
15:19:41 <ehird> :-)
15:19:43 <dons> mike, who'are your teachers?
15:19:52 <jfredett> roconnor: Dijkstra was Dijkstra.
15:20:00 <mike> Neil Ghani
15:20:06 <dons> cool. smart guy.
15:20:07 <vixey> mike: crazy crazy stuff in nottingham
15:20:15 <edwardk> i haven't found anything that builds up (co)density (co)monads from first principles on the net. i found a few passing references to them though
15:20:18 <mike> you actualy know him ? :)
15:20:24 <dons> sure.
15:20:28 <monochrom> I use Dijkstra as a metric for quality control.
15:20:33 <twobitsprite> so, I never found anything about dynamic haskell module loading... I know its possible because ghci does it...
15:20:41 <ehird> monochrom: Dijkstras are elitist factors, actually.
15:20:44 <spainish> i should use Algol67
15:20:45 <dons> twobitsprite: hs-plugins
15:20:45 <spainish> err
15:20:47 <ddarius> edwardk: Yeah, the short one I wrote doesn't go into that aspect of density.
15:20:47 <spainish> i should use Algol68
15:20:48 <vixey> spainish: hey
15:20:54 <ehird> Dijkstra was a grouchy elitist and probably very troubled, but he was RIGHT about so many things
15:20:56 <vixey> spainish: come to #algol ?
15:20:57 <twobitsprite> dons, ahh, I'll look for it, thanks
15:20:59 <vixey> mike: http://sneezy.cs.nott.ac.uk/fp/
15:21:13 <mike> if I who you and you are in some kind of travian channel, im going to go ahead and assume you are him
15:21:20 <ehird> he made imperative programming - probalistic imperative programming - formal and beautiful
15:21:35 <ddarius> edwardk: However, most of the ideas in that are based off of the "paper" "Basic Concepts of Enriched Category Theory" which does go a bit more into detail on that particular topic (albeit it doesn't explicitly mention any (co)monads)
15:21:44 <ddarius> http://www.emis.de/journals/TAC/reprints/articles/10/tr10abs.html
15:21:58 <edwardk> ddarius: nice
15:22:18 <conal> i'm looking for a darcs tip: i have three files that i'd like to move out of one repo into a new repo.  i want to retain the histories of those three files but nothing else from the old repo.  any ideas?
15:22:20 <edwardk> great another rabbit hole to try to turn into code ;)
15:22:27 <twobitsprite> dons, hmm... so how does ghci do it without hs-plugins?
15:22:49 <monochrom> I am elitist too, FYI.
15:22:50 <jfredett> twobitsprite: the hard way?
15:23:00 <twobitsprite> jfredett, what's the hard way?
15:23:02 <dons> twobitsprite: ghci and hs-plugins use the same runtime api
15:23:09 <edwardk> oh, ddarius, have you ever seen a coideal comonad being used for something? i built them up off dualizing adamek's ideal monads, but haven't come up with a purpose yet ;)
15:23:14 <twobitsprite> ahh, ok...
15:23:15 <jfredett> monochrom: your in good company, so is barack obam
15:23:17 <jfredett> a
15:23:29 <twobitsprite> so, hs-plugins links to ghc's api or something?
15:23:33 <mike> dons are you anything to do with nottingham uni?
15:23:49 <jfredett> twobitsprite: I was just being an ass, sorry if I led on that I actually knew something. :)
15:23:50 <edwardk> the nice thing is they have a baked in coideal comonad product, just like ideal monads get a baked in coproduct, so they seem like a nice way to build up some comonads
15:23:54 <monochrom> I am a pan-elitist. I believe that everyone should strive to become an elite, at least an elite in something.
15:24:00 <dons> mike: nope, just know some of the guys there (as many of us do)
15:24:21 <ddarius> edwardk: Section 4.4 in the above is I think the section I'm thinking of.
15:24:25 <monochrom> I disbelieve in "ordinary programmers can/cannot so-and-so".  No one should be "just an ordinary programmer".
15:24:26 <mike> thats interesting, are you ex-students or possibly someone from another university?
15:25:03 <monochrom> At least as long as you believe that programming is a profession, not a scam.
15:25:04 <dons> well, its a farily close knit community, the haskell world. i did a phd in sydney, and have been to conferences and hackathons with guys from nottingham
15:25:11 <edwardk> ddarius: the product comonad is coideal, so are stream comonads (and for that matter any cofree comonad)
15:25:16 <twobitsprite> jfredett, heh
15:25:37 <vixey> I would like to go study at nottingham
15:25:40 <vixey> I wonder if it's possible
15:26:11 <twobitsprite> edwardk, cowhat?
15:26:26 <monochrom> When you talk of professions, like medicine, law, accounting, engineering, ...  you don't talk in terms of "just an ordinary doctor", "just an ordinary engineer".  If programming is to be equally professional, there should not exist "just an ordinary programmer" either.  By definition we're already talking about elitism, like it or not.
15:26:29 <ehird> <monochrom> I am elitist too, FYI.
15:26:32 <ehird> I'm like a fluffy elitist
15:26:38 <Botje> monochrom: some people just *want* to be an "ordinary programmer" though
15:26:38 <ehird> I pretend to be an elitist with elitists
15:26:41 <ehird> :-)
15:26:50 <edwardk> twobitsprite: cowhat? oh then you already know the answer you just need me to tell you the question. ;)
15:26:54 <mike> I guess if i asked should i do advanced functional next year you guys would all say yes ? :)
15:26:56 <jfredett> edwardk: I think sometimes you people just start putting co on the front of fancy words and pretend it's math...\
15:26:57 <Botje> they see programming as strictly a day job and don't invest in new skills on their own time
15:27:05 <edwardk> jfredett: heh
15:27:06 <vixey> mike: Do you want to not?
15:27:06 <twobitsprite> :)
15:27:07 <jfredett> I'm bitter, I cling to guns.
15:27:18 <Botje> I see this my co-students too, which is pretty sad in a university :(
15:27:27 <monochrom> Oh, lots of people want to be "just an ordinary doctor", too.  They all fail.
15:27:30 <mike> well it's that or a web based module, not sure whats going to be more useful
15:27:30 <twobitsprite> is it a co-university?
15:27:33 <ehird> CO-students, eh?
15:27:42 <vixey> mike: forget "useful"
15:27:55 <Botje> ehird: heh.
15:27:57 <vixey> mike: anyway I'd definitely suggest fp over anything web related
15:28:05 <vixey> mike: web is a solved problem
15:28:13 <ehird> vixey: web+fp, on the other hand... :-)
15:28:21 <edwardk> actually the ideas involved there are rather simple. a free monad is basically taking a functor and wrapping it around itself, with a 'way out' at each level, basically you wrap a + f (a + f (a + f (...))))), the cofree comonad is similar but replace + with a product, *.
15:28:27 <mike> and does anyone hire haskell programmers ? :S
15:28:32 <ehird> mike: yes. a few
15:29:22 <Botje> continuations in web-based programming are rapidly becoming popular
15:29:26 <skorpan> if i have a [Data.Map.Map] and i want to update the value of an existing entry given the key, in the first matching element of the list, how would i do that easiest?
15:29:40 <dmwit> mike: Lots of people hire Haskell programmers, but only a few hire them to program in Haskell. ;-)
15:29:43 <monochrom> Anyway, my position aside, it's only logical to choose your belief between "programming should be a profession" and "programming should be just another job". Then your elitism or non-elitism follows.
15:30:04 <dons> i have to admit, haskell as your day job makes day jobs fun.
15:30:08 <edwardk> basically with the free monad >>= just performs substitutions at the spots where there are 'a's floating around in the resulting tree, while in the cofree comonad it redorates the trees
15:30:11 <ehird> Botje: doesn't fit in with haskells functional thinking tohugh
15:30:20 <ehird> Botje: if you can quickly bind steps together it's not hard
15:30:22 <ehird> e.g.
15:30:24 <ehird>     h step1
15:30:24 <ehird>     h step2
15:30:33 <ehird> isn't as bad as the boilerplate a lot of other languages have
15:30:33 <dmwit> skorpan: Sounds like a case for foldr.
15:30:38 <ehird> ofc the back button etc but still
15:30:38 <skorpan> dmwit: you think?
15:30:45 <dmwit> skorpan: Sure!
15:30:57 <Botje> ehird: that just calls for some kind of web-continuation-session-thingy monad :)
15:30:58 <skorpan> hm.
15:31:15 <ehird> Botje: yeah, but still writing in a DO a/DO b/DO c style as continuations permit, is unhaskelly.
15:31:19 <Botje> sequence [page1,page2,page3,confirmPage]
15:31:20 <Botje> >:)
15:31:25 <chessguy> is it possible to do case foo of X,Y,Z -> ...
15:31:30 <spainish> tips: haskell, miranda, clean use monads, i'm busy, i will come later.
15:31:42 <ddarius> Botje: That's how WASH works.
15:31:42 <dcoutts> mike: enough haskell jobs for there to be haskell consultants we think :-)
15:31:44 <ehird> Botje: even so. It's forced-strict and unhaskelly.
15:31:56 <Botje> but it's easy! :)
15:32:07 <ehird> Botje: well yes yes it is. the urls are also ugly
15:32:11 <dmwit> chessguy: Use "elem"?
15:32:12 <ehird> don't get me wrong i like web continuations
15:32:18 <ehird> but they're not a silver bullet
15:32:21 <geezusfreeek> chessguy: how is progress?
15:32:21 <dmwit> chessguy: But in general, no.
15:32:36 <chessguy> geezusfreeek: the code is in pieces all over my emacs buffer :)
15:32:38 <edwardk> ideal monads are just a monad where 'return' is separated out into its own constructor. 'Maybe', 'Either a', a probability monad, a bunch of others, all have the form a + f a with just a supplied law for how to collapse from f (a + f a) -> f a. coideal comonads have the form a * f a, and a law f a -> f (a * f a)
15:32:38 <dmwit> skorpan: I take it back, foldr might not be such a clear winner.
15:32:46 <twobitsprite> ehird, ohh come on... if XML can solve everything so can continuations... you just have to hype it up enough
15:32:49 <skorpan> dmwit: :)
15:33:03 <ehird> twobitsprite: cute
15:33:08 <dmwit> skorpan: How about using (break (M.elem x)) or so?
15:33:10 * geezusfreeek peeks at TreeTraversal.hs
15:33:13 <twobitsprite> Continuations will rapidly increase productivity and reduce total cost of ownership
15:33:18 <skorpan> dmwit: i've never used break.. i'll look into it
15:33:21 <ehird> twobitsprite: not cute any more
15:33:22 <dmwit> skorpan: (Or whatever Map's "contains" function is.)
15:33:32 <twobitsprite> ehird, bleh, you're just no fun
15:33:37 <conal> any advice about how to move files out of one darcs repo into a new one (to factor a repo)?
15:33:39 <skorpan> dmwit: that would be lookup :)
15:33:46 * edwardk shuts up.
15:34:02 <mike> dons:  have you ever spoken with Graham Hutton?
15:34:06 <skorpan> or maybe just member
15:34:11 <dmwit> skorpan: Surely it has a "containment" function that returns a Bool...
15:34:18 <Botje> conal: clone a new one, then remove files in the old & new one
15:34:19 <skorpan> that would be member
15:34:19 <dmwit> ?hoogle k -> Map k v -> Bool
15:34:20 <rahaskella> Data.Map.member :: Ord k => k -> Map k a -> Bool
15:34:20 <rahaskella> Data.Map.notMember :: Ord k => k -> Map k a -> Bool
15:34:24 <dcoutts> mike: I have, he's a nice guy :-)
15:34:29 <ehird> BRB
15:34:32 <dmwit> Okay, member, then. =)
15:34:33 <dons> mike: sure. nice guy.
15:34:40 <mike> hes doing the course next year
15:34:42 <skorpan> there should be a function called dismember...
15:34:43 <dons> he visited my work for a few months last year.
15:34:52 <dons> mike: do you have his textbook?
15:34:53 <geezusfreeek> conal: if it was git i would say import one project into a new branch of the other, then merge to the branch you want to files in, deleting the ones you don't want… perhaps there is a good equivalent in darcs
15:35:09 <dcoutts> mike: you're at Nottingham are you?
15:35:13 <mike> yes
15:35:14 <geezusfreeek> then again, that would put a ton of new diffs in the repository
15:35:34 <dons> Nottingham is something of a center of haskell expertise.
15:35:37 <dcoutts> mike: from what I hear Graham is a very good teacher
15:35:47 <conal> i'm hoping for an O(1) algorithm (assuming fixed number of moved files)
15:35:48 <mike> so I hear dons :)
15:36:02 <dcoutts> mike: have you got Graham's book yet?
15:36:24 <geezusfreeek> ah, so something like (not a real command) darcs pull repo some_file some_other_file?
15:36:33 <mike> ashamed to admit that I don't
15:36:45 <dcoutts> mike: start yearly, get it now :-)
15:36:50 <dcoutts> yearly/early
15:36:51 <conal> geezusfreeek: yeah!  followed by deleting just those files in the original repo.
15:36:53 * geezusfreeek has no idea
15:37:10 <conal> without having to remove N-3 files in the new repo.
15:37:16 <dcoutts> mike: you can read my review, it's linked from the book's website
15:38:16 <ichor_> Hi. I have a data type with two type arguments, which behaves like a monad for both of them. Is there a nice way to handle this, so that i can use monad stuff in both ways?
15:38:28 <edwardk> ?pl \m -> Ran (m >>=)
15:38:29 <rahaskella> Ran . (>>=)
15:39:20 <vixey> ichor_: I'm not sure if that makes sense, isn't a monad transformer stack suitable?
15:39:45 <vixey> is it the same monad .. or different ones?
15:39:46 <edwardk> ?pl \x -> runRan x return
15:39:46 <rahaskella> flip runRan return
15:40:22 <Cale> ichor_: You could newtype
15:40:35 <chessguy> geezusfreeek: w00t! it compiles again
15:40:53 <Cale> ichor_: I'm impressed though... I don't think I've ever seen such a type. What type is it?
15:40:53 <ichor_> vixey: The monad instances look rather different. I dont know how a monad transformer stack works, so I dont know it it fits.
15:41:07 <dmwit> edwardk: It's got a ring to it, kind of a poem... "flip runRan return"
15:41:08 <geezusfreeek> chessguy: yeah i hate that feeling of being in limbo during the time that a project doesn't compile
15:41:48 <edwardk> dmwit: lol
15:42:09 <ichor_> Cale: newtype might work. I'll play around with that. It is just some type catching error messages from evaluating expressions.
15:42:26 <edwardk> needs another runRan in it, flip runRan runRan return . flip runRan runRan return... gives it that doowop beat
15:42:29 <Cale> Oh, Either is such a type, silly me. :)
15:42:32 <monochrom> I have spoken with Graham Hutton in this channel. I asked him about Catherine Hope's work. :)
15:43:15 <Cale> Still, it's not so typical to want to flip the thing over very often.
15:46:34 <mike> dcoutts: sorry missed that, I will :)
15:50:14 <noecksit> @undo value <- takeMVar; write (show value)
15:50:15 <rahaskella>  Parse error at "<-" (column 7)
15:50:36 <ehird> noecksit: forgot yer do.
15:50:38 <ehird> anyway
15:50:41 <ehird> takeMVar >>= write . show
15:50:49 <ichor_> Cale: One of the arguments is entries in a list which is updated while doing monad stuff on the other argument. So the roles are flipped quite often.
15:51:20 <noecksit> ehird: yeah thats what i have but i get a type error
15:51:35 <ehird> :t takeMVar
15:51:39 <rahaskella> Not in scope: `takeMVar'
15:51:44 <ehird> noecksit: unrelated to >>= vs do
15:52:23 <sw17ch> if i have a long list of Int32's and i just want to write them to a file as raw bits, is there a slick way to do that?
15:52:36 <noecksit> says that . is applied to too many arguments
15:52:48 <dmwit> noecksit: You have to give "takeMVar" the mvar to take from...
15:52:48 <mauke> sw17ch: there is no "raw bits"
15:52:57 <sw17ch> well, there's Data.Bits...
15:52:58 <sw17ch> :)
15:53:02 <sw17ch> i was going to fall back on that
15:53:04 <mauke> that's not raw
15:53:09 <sw17ch> i know
15:53:09 <noecksit> oh
15:53:13 <dmwit> sw17ch: mapM_ put?
15:53:24 <sw17ch> put from Data.Binary?
15:53:31 <dmwit> I guess so.
15:53:31 <mike> say I have [(x,y)| x <-[1,2,3], y<-['a','b','c']] what order will it put them together in?
15:53:46 <dmwit> mike: Try it. =)
15:53:49 <dons> sw17ch: encodeFile "x" . runPut . mapM_ put $ xs
15:53:58 <dmwit> > [(x, y) | x <- [1..3], y <- "abc"]
15:54:00 <rahaskella>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
15:54:01 <dons> or you can use the standard serialisaiton, which writes the length as well
15:54:06 <dons> sw17ch: encodeFile "x" xs
15:54:07 <mike> well I know the outcome, but is there some rule that its the first list first? or?
15:54:12 <ehird> :t encodeFile
15:54:13 <dons> sorry, encodeFile should be writeFile in the first example
15:54:16 <rahaskella> Not in scope: `encodeFile'
15:54:16 <ehird> :t writeFile
15:54:20 <rahaskella> FilePath -> String -> IO ()
15:54:23 <dmwit> mike: In general, the lists vary faster as you go farther to the right in the list comprehension.
15:54:26 <dons> :t Data.ByteString.writeFile
15:54:30 <rahaskella> FilePath -> BSC.ByteString -> IO ()
15:54:45 <chessguy> ok, this is weird
15:54:48 <sw17ch> from [0x01,0x02,0x03] :: [Int32], i want 12 bytes to be written to a file...
15:55:02 <dmwit> mike: Would you like to know how it desugars?  It may demystify things for you, if you already understand the list monad.
15:55:03 <chessguy> firefox must be caching the response from the server, even though the response is a file
15:55:08 <vixey> mike: It's syntactic sugar for do notation, which is definable in terms of two operators >>= and return which have simple definitions
15:55:15 <mauke> sw17ch: little endian or big endian?
15:55:16 <mike> so if i have another list in there z, I would get (1,'a',10), (1,'a',20) ?
15:55:28 <chessguy> because when i click one one of my files at http://code.haskell.org/ChessLibrary/ , i'm seeing something different from when i cat the file on the file system
15:55:30 <sw17ch> hah, big endian
15:55:32 <dmwit> mike: Yes, if z <- [10,20] came last.
15:55:44 <dons> sw17ch: on a 32 bit machine?
15:55:46 <sw17ch> 0x01 => 00000001 in memory
15:55:47 <thetallguy> Anyone have ghc and base checked out from head, already built?  I have a couple of patches that I'd like to make sure compile and I'm feeling lazy...
15:55:49 <sw17ch> dons, yes
15:55:51 <dons> oh, they're Int32 .
15:55:52 <mike> right :)
15:55:54 <dons> so yeah, mapM_ put
15:56:11 <sw17ch> s/in memory/on disk/
15:56:24 <dmwit> mike: Are you groovy with the list monad?
15:56:41 <ehird> So. What do people do for writing 2d games with haskell? Is it very efficient use of their time?
15:57:04 <dmwit> ehird: Well, I guess there's that blog on functional programming and games.
15:57:27 <ehird> dmwit: I could internet-hear you wince before writing that. :P
15:57:29 <mike> havnt done monads
15:57:52 <mike> dont even know what they are, appart from unique to haskell right?
15:57:57 <dons> sw17ch: http://hpaste.org/7736
15:58:20 <dmwit> mike: Okay, then just keep the "later is faster" rule of thumb in mind for now. =)
15:58:31 <mike> :)
15:58:33 <dons> mike: they're more widely used than they used to be, outside of haskell, now. C# has them, python people use them sometimes.
15:58:46 <vixey> mike: Have you seen map?
15:58:53 <vixey> > map (+3) [8,6,3,1]
15:58:56 <rahaskella>  [11,9,6,4]
15:58:58 <DRMacIver> So, I
15:58:58 <mike> yes vixey
15:59:01 <DRMacIver> oops
15:59:02 <DRMacIver> I
15:59:03 <dmwit> ehird: http://prog21.dadgum.com/23.html
15:59:04 <vixey> mike: and concat map?
15:59:07 <vixey> oops
15:59:09 <vixey> concatMap
15:59:12 <mike> nope
15:59:19 <DRMacIver> ok I fail at eee. :)
15:59:26 <vixey> > concatMap (\x -> [x,x+3]) [8,6,3,1]
15:59:27 <ehird> vixey: i don't think he's ready for the list monad yet.
15:59:28 <rahaskella>  [8,11,6,9,3,6,1,4]
15:59:41 <mike> map, filter, list comprehension.
15:59:57 <vixey> mike: In the list Monad, x >>= f = concatMap f x ; return x = [x]
16:00:04 * dcoutts loves continuation monads
16:00:08 <chessguy_> geezusfreeek: see if you can get a fresh copy of http://code.haskell.org/ChessLibrary/Chessboard.hs ... if you see the Square definition right away, it's not fresh
16:00:21 <thetallguy> dcoutts: what are you using them for?
16:00:27 <chessguy_> (Square is the A1 | A2 | ... A8, etc.
16:00:30 <mike> sorry vixey that will just comfuse me for tomorrow
16:00:31 <mauke> > concatMap show [10,11,12]
16:00:33 <rahaskella>  "101112"
16:00:36 <vixey> mike: What's confusing?
16:00:43 <ehird> vixey: I think you are too assuming
16:00:52 <ehird> vixey: He is very new to haskell, he's not gonna get monads any time soon.
16:00:56 <mike> as in, I don't need to know it yet
16:01:02 <sw17ch> dons: thanks
16:01:05 <ehird> esp. since he's been using list comprehensions and you're bombarding him with >>=
16:01:11 <vixey> ok thought you were interested, nevermind
16:01:26 <dcoutts> thetallguy: as an alternative to mtl stacking and for converting imperative style to lazy demand driven
16:01:27 <mike> well I am, but best to chat about it another day
16:01:38 <geezusfreeek> chessguy_: if it's up to date then Square should be in ChessDefinitions?
16:01:43 <dmwit> mike: When you're ready, we'll enlighten you, don't worry. =)
16:01:46 <geezusfreeek> if so, then it's up to date
16:02:14 <thetallguy> dcoutts: That sounds good.  I'm not a fan of mtl.  I'll have to put it in my queue.
16:02:23 <dcoutts> thetallguy: in this case it's for my new cabal-install package dependency resolver. I'm using a cont monad with features of state, error and writer monads.
16:02:38 <dcoutts> newtype Search a = Search { unSearch :: Cont a (SearchState -> SearchResult) }
16:02:38 <dcoutts> type Cont a r = (a -> r) -> r
16:03:31 <geezusfreeek> chessguy_: woah, that Chessboard class is massive
16:04:07 <dcoutts> thetallguy: in particular overall it's a pure function but it supports producing intermediate progress so we can use a console spinner while the dep resolver runs
16:04:51 <thetallguy> dcoutts: interesting.  I have some similar challenges, so I'll have to investigate
16:05:01 <chessguy_> geezusfreeek: yes, that's correct
16:05:06 <chessguy_> geezusfreeek: on both counts :)
16:05:20 <Botje> @djinn (a -> r) -> r
16:05:21 <rahaskella> -- f cannot be realized.
16:05:35 <dcoutts> Botje: it's a very confusing type :-)
16:05:41 <chessguy_> geezusfreeek: but notice that i've provided defaults for most of the functions, so that you can get away with only defining a couple, but you can also override a lot
16:05:41 <geezusfreeek> chessguy_: do you have any specific questions about it or do you just want a quick review?
16:05:46 <Botje> dcoutts: pretty much, yes :p
16:05:48 <dcoutts> best not to use it directly, but hide it in a monad
16:05:56 <geezusfreeek> chessguy_: yeah i noticed that
16:06:10 <ehird> So.
16:06:12 <ehird> That decides it.
16:06:13 <chessguy_> geezusfreeek: any comments you have are welcome. it probably still needs some noise-removal
16:06:14 <dcoutts> Botje: especially when you instantiate r at (->) function types
16:06:18 <ehird> My 8-bit-style game will be written purely functional.
16:06:22 <ehird> With only minimal parts using SDL.
16:06:25 <dmwit> Botje: It's less confusing if you think of it as a closure over the type (a -> (a -> r) -> r).
16:06:26 <ehird> In haskell.
16:06:38 <geezusfreeek> chessguy_: why a class? what kinds of different instances might it have?
16:06:38 <dmwit> Botje: Though I guess that's not always how it's used.
16:06:52 <dcoutts> dmwit: hmm, I'm not sure I follow
16:07:02 <Botje> I read the hoogle page for Control.Monad.Cont and understood the examples
16:07:05 <Botje> but I skipped over the types
16:07:10 <Botje> perhaps I shouldn't have done that :)
16:07:25 <dcoutts> Botje: no, probably the right order to grok it
16:07:38 <dmwit> dcoutts: Well, I have to admit, I've never really used it, so I could be wrong.
16:07:41 <dcoutts> Botje: the types are initially unenlightening, seeing a real example helps
16:07:51 <dmwit> But in the end, doesn't an "a" value come from *somewhere*?
16:08:11 <Botje> the land of A!
16:08:22 <dmwit> Canada?
16:08:37 <Botje> that's the land of "Eh" *ducks*
16:08:40 <mauke> OH CANADIA
16:08:48 <monochrom> haha
16:08:50 <dmwit> MY HOME AND NATIVE LANDIA
16:09:06 <ddarius> dcoutts: Why do you have the arguments to Cont backwards?
16:09:08 <ehird> dmwit: canada is a nomic actually.
16:09:09 <chessguy_> geezusfreeek: different board representations
16:09:12 <ehird> it is played over irc over in #ircnomic.
16:09:17 <proqesi> take off eh?
16:09:26 <dcoutts> ddarius: do I? oh it was more convenient
16:09:31 <chessguy_> geezusfreeek: there are a lot of very different ways to represent a chessboard
16:09:40 <geezusfreeek> chessguy_: be more specific. how might different board representations benefit the client code?
16:10:11 <dcoutts> ddarius: I'll reverse it if that's the strong convention
16:10:46 <dmwit> "Motivation: Abuse of the Continuation monad can produce code that is impossible to understand and maintain."
16:10:48 <dmwit> hehe
16:11:08 <ddarius> dcoutts: Well for the purposes of making Cont a monad, the 'a' argument needs to come last.  Indeed your Search type is: type Search = Cont (SearchState -> SearchResult)
16:11:11 <chessguy> geezusfreeek: one of the goals of this project is to make it easy to develop new engines from this code. with this setup, clients can get a new board representation working with little effort, but customize it very deeply
16:11:45 <geezusfreeek> chessguy: i actually don't see how they could really customize it that much. with a class definition that large, the design constraints would be pretty tight
16:11:50 <dcoutts> ddarius: true true, though since I newtype it it has to be fully applied anyway. But I bow to convention. :-)
16:12:01 <SamB> geezusfreeek: how so?
16:12:11 <SamB> geezusfreeek: the constraints are mainly on WHAT must be possible
16:12:11 <chessguy> geezusfreeek: they would customize it by overriding the default methods
16:12:23 <SamB> not on HOW it must be done
16:12:34 <chessguy> geezusfreeek: i'm open to other ideas, of course
16:13:51 <geezusfreeek> chessguy: actually, i think samb is right
16:14:01 <geezusfreeek> chessguy: i change my opinion
16:14:09 <chessguy> heh
16:14:24 <dmwit> Spoken like a gentleman, sir!
16:15:12 <monochrom> @bot
16:15:12 <rahaskella> :)
16:15:28 <geezusfreeek> when i first looked at it i think i was mainly concerned that it looked very implementation driven, but going back to it again i see that i was mistaken
16:16:08 <chessguy> geezusfreeek: it's an unusual approach, to be sure
16:17:08 <SamB> makes perfect sense to me. not that I looked at it.
16:18:30 <thetallguy> If I want to build the base library from HEAD, do I need to build ghc from HEAD first?
16:18:43 <geezusfreeek> chessguy: not that unusual
16:19:27 <ddarius> thetallguy: You shouldn't.
16:19:31 <geezusfreeek> chessguy: ah i see you added a new constructor to TreeTraversal
16:19:40 <chessguy> geezusfreeek: show me another type class that has at least half as many member functions :)
16:19:48 <SamB> isn't base usually rather closely tied to GHC?
16:19:55 <chessguy> geezusfreeek: oh yes, conal and i were working on that earlier
16:20:05 <chessguy> it's looking pretty nice
16:20:10 <dmwit> return a = Cont ($ a) -- ?
16:20:16 <ddarius> dmwit: Yes.
16:20:22 <thetallguy> I get this error when I try and build with cabal: attempting to use module `System.IO' (System/IO.hs) which is not loaded
16:20:24 <dmwit> Okay, so my "closure" comment wasn't so far off.
16:20:25 <geezusfreeek> chessguy: well, you wouldn't find such a type class in the standard libs, probably, but i'm sure it's pretty common for more domain specific things
16:20:40 <chessguy> geezusfreeek: if you say so
16:20:51 <vixey> :t maybe
16:20:55 <rahaskella> forall b a. b -> (a -> b) -> Maybe a -> b
16:20:57 <vixey> :t either
16:21:01 <rahaskella> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
16:21:17 <vixey> Maybe a = 0+a ?
16:21:22 <vixey> or Maybe a = 1+a ?
16:21:22 <dcoutts> oooh, folds :-)
16:21:29 <geezusfreeek> chessguy: i like how you have the type class for the conditional type parameter of TreeTraversal
16:21:32 <vixey> and Either a b = a + b
16:21:32 <ddarius> dmwit: Cont seems related to Yoneda's lemma
16:21:39 <dcoutts> vixey: yep
16:21:40 <vixey> What's the fold for (,) ?
16:21:43 <vixey> I mean type of
16:21:47 <vixey> err
16:21:49 <vixey> (a,b) :)
16:21:58 <vixey> (a -> b -> z) -> (a,b) -> z ?
16:22:05 <chessguy> geezusfreeek: i think it will work nicely
16:22:06 <ddarius> vixey: Yes.
16:22:19 <geezusfreeek> chessguy: what is your most recent work on the project?
16:22:23 <ddarius> :t uncurry
16:22:26 <rahaskella> forall a b c. (a -> b -> c) -> (a, b) -> c
16:22:33 <chessguy> geezusfreeek: refactoring the Chessboard class
16:22:47 <lilac> suppose i want to be in two monads at once...
16:22:58 <dmwit> lilac: That's what monad transformers are for.
16:23:01 <chessguy> geezusfreeek: i moved the definitions out to a separate files, and reduced a lot of repetition
16:23:42 <geezusfreeek> chessguy: ah okay
16:23:57 <vixey> What's the cata type for a*b + c ?
16:24:09 <vixey> (a -> b -> z) -> (c -> z) -> a*b+c -> z ?
16:24:15 <ddarius> vixey: Yes.
16:25:46 <chessguy> dinner-time. back in a bit
16:26:52 <Peaker> whew! Finally got the chess move maker going (including all the intricate rules of chess, too, though!)
16:27:16 <geezusfreeek> Peaker: is your project related at all to chessguy's?
16:27:24 <vixey> for a*(b+c), is it (a -> b+c -> z) -> a*(b+c) -> z or (a -> (b -> z) -> (c -> z) -> z) -> a*(b+c) -> z ?
16:27:26 <Peaker> geezusfreeek, Well, he gave me the inspiration to do it :)
16:27:30 <geezusfreeek> ah :)
16:27:36 <Peaker> geezusfreeek, I thought it would take half an hour or so, but it took ~3 I think
16:27:49 <Peaker> geezusfreeek, I barely got my hands dirty at all with Haskell.. did a lot of reading though
16:28:01 <Peaker> so I decided to get my hands dirty with that simple example :)
16:28:04 <vixey> or even something else?
16:28:48 <vixey> a*(b+c) would be (a,Either b c) I guess
16:29:07 <ddarius> Yes, or you can distribute and get Either (a,b) (a,c)
16:29:15 <vixey> ooh
16:29:31 <vixey> the cata will be the same whether or not you distribute * over + ?
16:29:55 <ddarius> It will be equivalent, it doesn't need to be the same.
16:30:05 <lilac> dmwit: looks like there's no MaybeT?
16:30:10 <vixey> (a -> Either b c -> z) -> (a,Either b c) -> z .vs. (a -> (b -> z) -> (c -> z) -> z) -> (a,Either b c) -> z
16:30:14 <dmwit> lilac: import Data.Maybe?
16:30:23 <dmwit> lilac: Or possibly Control.Monad.Maybe?
16:30:48 <vixey> and for Either (a,b) (a,c), ((a,b) -> (a,c) -> z) -> Either (a,b) (a,c) -> z vs ((a -> b -> z) -> (a -> c -> z) -> z) -> Either (a,b) (a,c) -> z
16:30:53 <dmwit> lilac: I guess not.
16:31:11 <vixey> hmm :[
16:31:53 <vixey> they're equivalent in pairs!
16:32:00 <vixey> so that doesn't help me to decide which one
16:32:31 <vixey> ?djinn (a -> (b -> z) -> (c -> z) -> z)
16:32:31 <rahaskella> -- f cannot be realized.
16:32:38 <vixey> oops
16:32:41 <luqui> lilac, there is a MaybeT library on hackage
16:33:09 <vixey> no point asking djinn about this
16:33:12 <ddarius> vixey: You need to give the whole type.
16:33:28 <vixey> ?djinn (a -> Either b c -> z) -> (a,Either b c) -> z
16:33:28 <ddarius> a -> b -> z can't be realized either
16:33:28 <rahaskella> f a (b, c) =
16:33:28 <rahaskella>     case c of
16:33:28 <rahaskella>     Left d -> a b (Left d)
16:33:28 <rahaskella>     Right e -> a b (Right e)
16:33:32 <luqui> why rahaskella and not lambdabot?
16:33:39 <vixey> ?djinn ((a,b) -> (a,c) -> z) -> Either (a,b) (a,c) -> z
16:33:40 <rahaskella> -- f cannot be realized.
16:33:46 <vixey> ?djinn ((a -> b -> z) -> (a -> c -> z) -> z) -> Either (a,b) (a,c) -> z
16:33:47 <rahaskella> -- f cannot be realized.
16:33:48 <vixey> :(
16:34:00 <vixey> ?djinn (a -> (b -> z) -> (c -> z) -> z) -> (a,Either b c) -> z
16:34:00 <rahaskella> -- f cannot be realized.
16:34:02 <vixey> nooo
16:34:12 <ddarius> @djinn (a -> b -> z) -> (a -> c -> z) -> Eithe (a,b) (a,c) -> z
16:34:12 <rahaskella> -- f cannot be realized.
16:34:27 <ddarius> @djinn (a -> b -> z) -> (a -> c -> z) -> Either (a,b) (a,c) -> z
16:34:27 <rahaskella> f a b c =
16:34:27 <rahaskella>     case c of
16:34:27 <rahaskella>     Left (d, e) -> a d e
16:34:27 <rahaskella>     Right (f, g) -> b f g
16:34:29 <lilac> in do notation, is 'let x = y' equivalent to 'x <- return y' ? do they both use fail if the pattern fails?
16:34:42 <ddarius> lilac: No, they are not equivalent.
16:34:44 <vixey> hmm that looks good
16:34:58 <vixey> is that the cata for (a*b)+(a*c) ?
16:35:05 <ddarius> vixey: Yes.
16:35:09 <vixey> ok thanks
16:36:08 <ddarius> @djinn  (a -> (b -> z) -> (c -> z) -> z) -> (a, Either b c) -> z
16:36:08 <rahaskella> -- f cannot be realized.
16:36:26 <Peaker> print is to show as ??? is to read
16:36:37 <dmwit> readLn
16:36:37 <ddarius> readLn
16:36:45 <Peaker> thanks
16:36:54 <vixey> @quote fugue
16:36:55 <rahaskella> monochron says:  "Welcome to #haskell, where your questions are answered in contrapuntal fugues."
16:37:07 <vixey> and for (a+b)*(x+y), should it be ((a -> z) -> (b -> z) -> z) -> ((x -> z) -> (y -> z) -> z) -> (a+b)*(x+y) -> z ?
16:37:10 <mike> case expression, another word for pattrn matching? I have never heard this before
16:37:42 <vixey> ?djinn ((a -> z) -> (b -> z) -> z) -> ((x -> z) -> (y -> z) -> z) -> (Either a b,Either x y) -> z
16:37:42 <rahaskella> -- f cannot be realized.
16:37:43 <luqui> @djinn (a ->  b -> z) -> (a -> c -> z) -> (a, Either b c) -> z
16:37:44 <rahaskella> f a b (c, d) =
16:37:44 <rahaskella>     case d of
16:37:44 <rahaskella>     Left e -> a c e
16:37:44 <rahaskella>     Right f -> b c f
16:37:53 <Peaker> wow, seems like all the intricate chess logic I wrote works on the first attempt :-)
16:38:13 <vixey> ?djinn ((a -> z) -> (b -> z) -> (x -> z) -> (y -> z) -> z) -> (Either a b,Either x y) -> z
16:38:14 <rahaskella> -- f cannot be realized.
16:38:33 <vixey> ?djinn (a -> z) -> (b -> z) -> (x -> z) -> (y -> z) -> (Either a b,Either x y) -> z
16:38:33 <rahaskella> f a b c d (e, f) =
16:38:34 <rahaskella>     case e of
16:38:34 <rahaskella>     Left g -> case f of
16:38:34 <rahaskella>               Left h -> c h
16:38:34 <rahaskella>               Right _ -> a g
16:38:35 <rahaskella>     Right i -> case f of
16:38:37 <rahaskella>                Left _ -> b i
16:38:40 <rahaskella>                Right j -> d j
16:38:40 <vixey> oh it's that simple?
16:39:11 <luqui> that function is not unique
16:39:19 <vixey> huh?
16:39:22 <hardcopy> huh?
16:39:22 <vixey> should it be unique?
16:39:23 <ddarius> That's not a fold.
16:39:26 <vixey> aww :(
16:39:48 <hardcopy> anyone hear of AOP?
16:40:03 <twanvl> ?djinn (a -> x -> z) -> (b -> x -> z) -> (a -> y -> z) -> (b -> y -> z) -> (Either a b,Either x y) -> z
16:40:03 <rahaskella> f a b c d (e, f) =
16:40:03 <rahaskella>     case e of
16:40:03 <rahaskella>     Left g -> case f of
16:40:03 <rahaskella>               Left h -> a g h
16:40:03 <rahaskella>               Right i -> c g i
16:40:05 <rahaskella>     Right j -> case f of
16:40:07 <rahaskella>                Left k -> b j k
16:40:09 <rahaskella>                Right l -> d j l
16:40:22 <vixey> oh my
16:40:25 <vixey> this is complex
16:40:37 <luqui> the structure of the function arguments should mirror the structure of the data.  You have (a + b)(x + y), so your fold should be a sum of products.
16:40:49 <dmwit> hardcopy: Knuth?
16:41:00 <hardcopy> Aspect Oriented Programming
16:41:50 * luqui has
16:41:53 <twanvl> AOP is supposed to be very useful for adding logging of function calls to a Java program
16:42:02 <luqui> but I don't really consider it an -OP
16:42:04 <vixey> now I'm really confused :L
16:42:31 <twanvl> (at least, that is the only motivating example anyone gives)
16:42:34 <luqui> it's more like a fancy name to give to hacking code to pieces in an opportunistic way
16:42:39 <dmwit> vixey: (a + b) * (x + y) = ax + bx + ay + by
16:42:51 <ddarius> vixey: twanvl distributed (a+b)*(x+y) ~ ax + ay + bx + by
16:42:58 <vixey> dmwit: to figure out the type I *must* multiply out the expression
16:43:11 <dmwit> vixey: No, you don't *have* to, I guess.
16:43:13 <ddarius> dmwit: It's easier to deal with a sum of products.
16:43:15 <dcoutts> twanvl: yeah, my research group does a lot of AOP stuff and all their examples are dynamic assertion checking style things
16:43:39 <hardcopy> i am just reading about it
16:43:42 <dmwit> ddarius: misnick, or was that really at me?
16:43:43 <hardcopy> people are raving about it
16:43:44 <ddarius> s/dmwit/vixey
16:43:47 <dmwit> ok =)
16:43:48 <hardcopy> stating it's the future of programming
16:43:55 <dcoutts> twanvl: and for that it's not bad, being able to express properties separately from the code and applying them across an entire system
16:44:55 <ddarius> vixey: You may need rank-2 types to get it to work without distribution in general.
16:45:17 <twanvl> dcoutts: I guess I have just never seen a good example where it was actually *really* useful.
16:46:34 <monochrom> Eh? Aspect oriented programming?  8 year old already.  still not taking off.
16:46:59 <hardcopy> Took OOP a while
16:46:59 <luqui> the problem with AOP I see is that while it lets you specify properties separately from the code, those properties are entangled with the structure of the code.
16:47:02 <luqui> for each method such and such
16:47:08 <luqui> those details are not important to specification
16:47:09 <Pseudonym> I think we should make a "new programming paradigm" form response, like the suggested answer to spam form response.
16:47:22 * edwardk is sitting here debating about calling a class for FreeLike thinks Cheap. ;)
16:47:28 <dcoutts> monochrom: I guess it depends what one thinks it's for. From what I've seen people use it in house to analyse their code, but they don't use it to implement features.
16:47:36 <Pseudonym> Many of the objections about AOP also apply to intensional programming, for example.
16:47:37 <dcoutts> monochrom: so one never sees it in production code
16:47:41 <edwardk> but the idea of cheap monads and cocheap comonads is just silly
16:47:45 <vixey> what would a rank 2 fold look like?
16:48:10 <dmwit> edwardk: co-cheap = expensive ;-)
16:48:16 <edwardk> dmwit: lol
16:48:30 <luqui> vixey, the fold over this data structure perhaps:  data Foo a = Foo (a -> (a, Foo a))
16:48:36 <dcoutts> luqui: a chap in my group is working on that problem, that aspects don't respect abstraction very well.
16:48:40 <ddarius> vixey: Basically a fold church encodes a data structure.
16:48:45 <twanvl> are the monads free as in beer or free as in speech?
16:49:01 <edwardk> twanvl: free as in math ;)
16:49:18 <clanehin> perhaps, free as in yoga?
16:49:19 <Peaker> given a  data A = A {a::Int}  -- one can now use  (a::A){a=2}  to update it, right?  Is there something better than \x -> x{a=2} ?
16:49:20 <geezusfreeek> has anybody ever experienced the ghc linker being extremely slow on some machines?
16:49:41 <dmwit> Peaker: no =/
16:49:42 <luqui> Peaker, sadly not
16:49:47 <dcoutts> Peaker: sadly not, but you can write named update functions and use them later
16:49:50 <luqui> Peaker, without, say data-accessor
16:49:55 <dmwit> Peaker: But!
16:49:57 <ddarius> geezusfreeek: I've experienced ld being extremely slow attempting to link GHC
16:50:02 <jaj> @version
16:50:03 <rahaskella> lambdabot 4p629, GHC 6.8.2 (Linux i686 1800+)
16:50:03 <rahaskella> darcs get http://code.haskell.org/lambdabot
16:50:09 <geezusfreeek> ah yeah it would be ld
16:50:19 <dmwit> Peaker: See also http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
16:50:22 <geezusfreeek> ddarius: were you ever able to trace down why?
16:50:27 <jaj> can't you query rahaskella?
16:50:39 <vixey> jaj: yes
16:50:42 <dmwit> Peaker: And the author of that blog post is in here now, so if you have questions ask them fast. =)
16:50:43 <ziman> @pl \x -> x { a = 2 }
16:50:43 <rahaskella> (line 1, column 9):
16:50:43 <rahaskella> unexpected "{"
16:50:43 <rahaskella> expecting variable, "(", operator or end of input
16:50:52 <geezusfreeek> cabal-install has been linking for like 4 or 5 minutes so far
16:50:58 <geezusfreeek> seems like it won't be finishing
16:51:12 <twanvl> dmwit, Peaker: not for long
16:51:17 <dcoutts> geezusfreeek: hrm, not good
16:51:49 <geezusfreeek> it finished right when i ran top just now, so i didn't even get to see if it was working hard or not
16:51:56 <geezusfreeek> figures
16:52:22 <geezusfreeek> i think that has been replicatable behavior for me on machines that do that. whenever i run top the linker finishes
16:52:38 <geezusfreeek> which is really… weird
16:52:40 <dmwit> Learn to run top sooner. =)
16:53:35 <geezusfreeek> great advice
16:53:48 <luqui> could someone who has The Power ask rahaskella to @join #perl6 in lieu of lambdabot
16:54:47 <geezusfreeek> ari: i think that would be you? ^
16:56:10 <dmwit> You could also get newsham to send noBotE over to #perl6.
16:58:49 <monochrom> I think today's raving is about Haskell.
16:58:57 <edwardk> hrmm, does anyone know if anyone has done anything w.r.t indexed arrows ala indexed monads? (carrying around an extra couple of parameters, class IxArrow hom where arrr :: hom i i a a; (>>>>) :: hom j k b c -> hom i j a b-> hom i k a c) or something like that
16:59:43 <monochrom> Example. There are reddit trolls who target haskell posts. Slashdot once joked about "anything-but-haskell dept.".
16:59:53 <edwardk> and yes i realize arrr invites pirate jokes ;)
17:00:07 <dmwit> ?arrr!
17:00:07 <rahaskella> Swab the deck!
17:00:19 <monochrom> If you claim that X is being raved about, you should produce similar evidence.
17:00:21 <dmwit> Even rahaskella knows *that* joke! =)
17:00:31 <vixey> :t either
17:00:34 <rahaskella> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
17:00:38 <twanvl> edwardk: shouldn't that be idd?
17:01:07 <edwardk> twanvl: yeah
17:01:13 <edwardk> twanvl: you get the general idea though
17:01:23 * monochrom goes write social science paper, "naysayer activities as a measure of popularity and success".
17:01:35 <edwardk> i don't think it adds any value upon reflection, just curious
17:01:59 <Defty> has anyone been using hopengl on debian unstable lately?
17:03:02 <geezusfreeek> did it again. didn't link until i ran top
17:03:05 <geezusfreeek> really weird
17:03:53 <ari> rahaskella: @join #perl6
17:05:21 <luqui> ari, thx
17:07:31 * ari >>= bed
17:08:45 <mike> Hey can anyone just take a look at this insertion sort for me, I want to ask a question or two http://hpaste.org/7737
17:09:21 * vixey growl
17:09:25 <vixey> making theses types is hard
17:09:38 <mike> how can insertBy work on the list its given if that list dosnt look to be finsihed yet?
17:09:54 <vixey> the product rule specificially
17:10:09 <mauke> finished?
17:10:31 <luqui> mike, what is a?
17:10:42 <luqui> in otherwise = a (insertBy f n xs)
17:11:01 <mike> sorry x should be x
17:11:08 <mike> x :
17:11:09 <luqui> and presumably also with a :
17:11:17 <mike> yes sorry, typing error :P
17:11:41 <luqui> k.  could you rephrase the question?  I don't know what it means for a list to be finished.
17:11:57 <chessguy> @quote
17:11:57 <rahaskella> arirabkin says: [on the Visual Studio plugin for Haskell:] that's like having a rosary bead set for satan.
17:12:01 <mike> well the last line there
17:12:27 <edwardk> ?pl \k -> wrap (fmap (flip runRan k) t)
17:12:28 <rahaskella> wrap . flip fmap t . flip runRan
17:13:00 <mike> it says use insert, which takes the function, the first element, and a list and applies the function then puts the value in the right place in the list
17:13:10 <edwardk> ?pl \t -> Ran (wrap . flip fmap t . flip runRan)
17:13:10 <rahaskella> Ran . (wrap .) . (. flip runRan) . flip fmap
17:13:11 <mike> insertBy sorry
17:13:14 <edwardk> blech
17:13:41 <luqui> mike, yes, in the sorted rest of the list
17:14:08 <mike> but the list being passed to it is a recursive call to insortBy , It wont have worked that out yet right?
17:14:24 <luqui> wel, barring laziness, yes it will have
17:14:44 <luqui> it "first" calls insortBy f xs to sort the remainder, and then it inserts x into the result
17:15:25 * SamB wonders how to design a "disjoint union" type family
17:15:32 <luqui> by which I mean it returns a new list with the element inserted.  nothing is changed of course.
17:16:01 <mike> ok first run through, function is (-1) list [1,2,3,4], it passes (-1) 1 and ?? to insertBy?
17:16:53 <mike> or will it do (-1) 4 and [] first?
17:17:31 <luqui> it first passes [2,3,4] to itself to sort the rest
17:18:07 <luqui> (and will incidentally get [2,3,4] back this time).  Then it calls insertBy (-1) 1 [2,3,4]
17:19:08 <mike> so what tells it to run again after the 0 is put in the right place ? :S
17:19:27 <luqui> I would suggest doing a really simple example, like sortBy id [2,1], by rewriting
17:19:53 <mike> I can probably tell what will happen in most of the haskell I know, but I don't have a clue in what order or sometimes why
17:19:58 <luqui> insortBy id [2,1] = insertBy id 2 (insortBy id [1]) = ...
17:20:15 <luqui> well what order is natural.  Haskell tries not to make you think about that.
17:20:24 <luqui> but why is important to know ;-)
17:22:35 <mike> well hes basicly told us we need to know an example of  a sorting alorithm, which would be the best one to pick ?
17:22:43 <mike> quick merge or insert
17:23:31 <chessguy> conal: you'll be happy to know that {-# OPTIONS_GHC -Wall #-} has become my new best friend
17:23:47 <luqui> they're all recursive, doesn't matter.  quicksort and insertion sort have simpler implementations
17:25:40 <mike> ok thanks for the help
17:25:57 <chessguy> i'm down to 66 hours of scheduled work before my wife's vacation, when i do my really big push :)
17:26:41 <geezusfreeek> conal: it appears that the stack overflow occurs in the joinMM function (which i had shameless ripped from your email)
17:26:53 <vixey> basically
17:27:00 <vixey> catas for products of sums are hard :|
17:27:10 <geezusfreeek> well, at least it spits out the cost center stack when it overflows if i use -xc
17:27:37 <vixey> what would the type for 2*2 be ?
17:27:46 <geezusfreeek> i don't really understand that function definition yet ;)
17:27:47 <monochrom> alias ghc 'ghc -Wall'
17:27:56 <vixey> or (u+v)*(x+y)?
17:27:57 <chessguy> @type 2*2
17:28:01 <rahaskella> forall t. (Num t) => t
17:28:10 <vixey> the type of the catamorphism of (u+v)*(x+y)
17:28:25 <chessguy> @type \u v x y -> (u+v)*(x+y)
17:28:28 <rahaskella> forall a. (Num a) => a -> a -> a -> a -> a
17:28:53 <luqui> so (u+v)*(x+y) = (Either u v, Either x y)...
17:28:56 <dmwit> chessguy: He's talking about the *type* 2, i.e. Bool.
17:29:13 * vixey she ..
17:29:15 <chessguy> dmwit: oh. i missed the context
17:29:29 <chessguy> sorry vixey
17:29:33 <dmwit> luqui: The catamorphism for 2*2 is easy, it's the same as the catamorphism for 4.
17:29:36 <dmwit> err.
17:29:41 <dmwit> s/luqui/vixey
17:29:50 <vixey> but what if you don't use the distributive law?
17:30:00 <luqui> a -> a -> a -> a -> a
17:30:09 <vixey> I mean can you go directly from (u+v)*(x+y) into a type
17:30:13 <vixey> without multiplying anything out
17:30:46 <vixey> It's not possible is it
17:30:47 <vixey> ?
17:31:06 <dmwit> ((u, x) -> z) -> ((u, y) -> z) -> ((v, x) -> z) -> ((v, y) -> z) -> (u+v)*(x+y) -> z -- ?
17:31:08 <luqui> Probably it is.  I'm not that familiar with the algebraic manipulations, but let's try to do it inductively
17:31:10 <Saizan> vixey: without using Either/(,) ?
17:31:29 <dmwit> Saizan: Just let + be shorthand for Either, and * be shorthand for (,).
17:31:33 <geezusfreeek> conal: although as far as i can tell it's quite sane
17:31:34 <vixey> Saizan: yeah I don't think that there should be any Either or (,) in the catas type except at the very end?
17:31:40 <luqui> cata for u+v is (u -> z) -> (v -> z) -> z
17:31:48 <luqui> cata for u*v is (u -> v -> z) -> z
17:31:50 <monochrom> someone said he/she really want to multiply out. probably likes case analysis. each summand is one case.
17:32:04 <Saizan> dmwit: that much i know
17:32:11 <dmwit> ok, sorry =P
17:32:30 <luqui> so we need to know how to turn the cata for u and cata for v into the cata for u*v
17:33:00 <luqui> hmm
17:33:00 * monochrom plays devil's advocate and advocates for CNF, product of sum, ... :)
17:33:20 <luqui> monochrom, might be a good idea after thinking about this for a bit ...
17:33:26 <vixey> hmm
17:33:36 <vixey> drop zero = Void ; drop one = One
17:33:37 <vixey> drop (a + b) = Either (drop a) (drop b)
17:33:37 <vixey> drop (x * y) = Pair (drop x) (drop y)
17:33:49 <vixey> splat zero z k = z -> k
17:33:49 <vixey> splat one z k = (drop one -> z) -> k
17:33:49 <vixey> splat (a + b) z k = splat a z (splat b z k)
17:33:49 <vixey> splat (p * q) z k = (drop p -> drop q -> z) -> k
17:33:58 <vixey> I wrote that so far
17:34:01 <vixey> so like cataTy ty z = splat ty z (drop ty -> z)
17:34:02 <chessguy> splat?
17:34:13 <vixey> yeah I don't know what else to call it :P
17:34:15 <luqui> is this agda?
17:34:21 <vixey> but that works for everything except a product of sums
17:34:30 <vixey> (since drop is wrong in that cose)
17:34:31 <vixey> yeah
17:34:52 <vixey> I wrote a little thing in haskell that prints out folds
17:35:17 <vixey> but I thought I could do it in Agda as well, but actually generate the function rather than just a string that represents it
17:35:45 <vixey> ( my haskell is there http://hpaste.org/7682 .. probably will rewrite it sometime )
17:36:40 <vixey> sooo I am finding it impossible to do it for a product of sums anyway :/
17:37:39 <vixey> any ideas what splat (p * q) is ?
17:38:31 <monochrom> (u+v)*(x+y)*(a+b+c) says: you have three fields, you must choose one of u,v in the first field, you must choose one of x,y in the second field, and you must choose one of a,b,c in the third field. This is like you are presented with a dialog box and you make radio-button choices.
17:39:06 <monochrom> 20 years of Mac and Windows proves that dialog boxes must be intuitive. Therefore product-of-sum must be intuitive.  XDDDDD
17:39:13 <vixey> haha
17:40:03 <chessguy> wow
17:40:14 <chessguy> @quote windows
17:40:14 <rahaskella> sebazzz says: la vez que salimos, que vino erg0t de bsas, nos metimos en un ciber para contactarnos con tizoc, y erg0t no sabia manejar windows xp ...
17:40:23 <vixey> what's wow?
17:40:54 <chessguy> vixey: monochrom's lemma
17:41:10 <dcoutts> conal: do you have an account on code.haskell.org? I think we're being encouraged not to start new projects on darcs.haskell.org. It's now supposed to be more for core components.
17:41:29 <dcoutts> conal: we can certainly give you an account on code.haskell.org
17:41:53 <dcoutts> http://community.haskell.org/admin/account_request.html
17:41:55 <chessguy> by the way dcoutts, code.haskell.org has rocked for my project
17:42:03 <dcoutts> chessguy: great :-)
17:42:33 <chessguy> dcoutts: there are a couple of typos on http://community.haskell.org/admin/using_project.html , by the way
17:42:49 <dcoutts> oh, heh, oops :-)
17:43:11 <chessguy> pretty obvious what it's meant to be, but i thought i should point it out
17:44:13 <dcoutts> chessguy: what are they exactly? I'll fix them...
17:44:21 <chessguy> haksell instead of haskell
17:44:23 <chessguy> twice
17:45:04 <Botje> b
17:45:31 <chessguy> make that three times
17:46:10 <xif> anyone using Vim here?
17:47:08 <dmwit> Yep, lots of people.
17:47:25 <chessguy> even more in #vim
17:47:43 * vixey gives up ..
17:47:55 <monochrom> Strange influx of vim questions lately.
17:48:00 <xif> dmwit: they don't see to be ever responsing, unfortunately.
17:48:01 <tieTYT2> hello
17:48:04 <xif> *seem
17:48:13 <dmwit> Heh.
17:48:20 <vixey> xif: vimtutor
17:48:27 <xif> monochrom: not too many Vim answers though
17:48:31 <tieTYT2> when you guys think about a function, do you think about it in terms of lazy evaluation or do you mentally evaluate things in your head when it's convenient?
17:48:33 <dmwit> xif: Well, that's not our fault.
17:48:34 <xif> vixey: I _know_ vim
17:48:42 <Botje> tieTYT2: i generally work out the type first
17:48:54 <xif> I'm trying to get a sense of what people are using for syntax highlighting + indentation for Haskell in Vim
17:48:55 <tieTYT2> i'm reading real world haskell, and it's talking about lazy evaluation.  But it's yet to explain why it's relevant except for performance reasons
17:49:10 <xif> basically, what sort of .vim scripts people install for Haskell hacking.
17:49:11 <mauke> xif: :syntax enable, :set autoindent
17:49:13 <monochrom> Oh, haskell+vim questions are welcome!
17:49:13 <vixey> @src infixOf
17:49:13 <rahaskella> Source not found.
17:49:18 <vixey> @src isInfixOf
17:49:18 <rahaskella> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
17:49:26 <vixey> tieTYT2: look at isInfixOf
17:49:30 <Botje> okay
17:49:33 <Botje> everytime i press shift
17:49:35 <dmwit> xif: Highlighting worked out-of-the-box for me.
17:49:35 <Botje> i get a w
17:49:36 <Botje> wtf?
17:49:41 <dmwit> xif: Is it not working for you?
17:49:49 <monochrom> Just that yesterday we got some "how to open file in vim" in broken English and some of us got tired of it.
17:49:54 <xif> mauke: hm?  from what I've seen, Vim doesn't have indent out of the box for Haskell
17:49:57 <vixey> tieTYT2: it basically lists every possible tail of the list, and checks of the needle is a prefix of that
17:50:06 <mauke> xif: irrelevant
17:50:07 <xif> so :set autoindent won't exactly help
17:50:07 <vixey> tieTYT2: In a strict language that would be just ridiculous
17:50:13 <dmwit> xif: :set autoindent is about the closest you get.
17:50:22 <dmwit> xif: It turns out it's not as bad as you might think at first.
17:50:31 <mauke> xif: do you know what 'autoindent' is?
17:50:39 <xif> dmwit: I actually got an indent script, that works quite well.
17:50:50 <vixey> tieTYT2: but in a lazy language it's equivalent to generating and testing in a strict one, you only create the tails and test prefixes until the first successful match
17:50:53 <nolrai_> what does " Saint October
17:50:54 <dmwit> xif: Oh, really, where?
17:50:56 <nolrai_> Bad interface file: /usr/lib/haskell-packages/ghc6/lib/gtk-0.9.12/imports/Graphics/UI/Gtk.hi
17:50:56 <nolrai_>         mismatched interface file versions: expected 6082, found 6061
17:50:57 <luqui> tieTYT2, to me, lazy evaluation frees me from having to think about evaluation
17:51:01 <luqui> or rather evaluation order
17:51:08 <vixey> tieTYT2: that's one example of where you get a big performance difference
17:51:14 <nolrai_> um ignore the saint October.
17:51:15 <tieTYT2> vixey: that's fine
17:51:17 <xif> dmwit: http://www.vim.org/scripts/script.php?script_id=1968
17:51:36 <tieTYT2> and i'm not saying, "Who cares?" I'm saying, "If I don't care, will I misunderstand the meaning of things?"
17:51:44 <xif> dmwit: syntax highlighting works out of the box, but is it really sufficient?
17:51:56 <vixey> tieTYT2: I wasn't telling you who cares, just giving an example of performance difference
17:52:01 <dmwit> xif: What more are you looking for?
17:52:11 <vixey> tieTYT2: If you thouht about everything strictly you'd never write isInfixOf like that
17:52:11 <xif> I mean, for all other languages (Python, Ruby, Javascript) I ended installing better syntax files.
17:52:17 <nolrai_> tieTYT2: infinite data structures.
17:52:25 <xif> dmwit: (i.e. the vanilla support usually sucks)
17:52:26 <dcoutts> chessguy: fixed, thanks.
17:52:31 <nolrai_> i.e. [1..]
17:52:34 <tieTYT2> what i'm asking is, if I just think about evaluation in a way i'm comfortable with (not lazy evaluation), will it effect my understanding?
17:52:42 <monochrom> If you don't know lazy evaluation, you will be surprised at some programs taking unexpected time. unexpected includes both shorter than you expect and longer than you expect.
17:52:44 <vixey> tieTYT2: obviously
17:52:46 <tieTYT2> vixey: ok
17:52:47 <dmwit> xif: Dunno, I've never really considered highlighting to be an important part of the coding process.
17:52:52 <vixey> tieTYT2: You will have the completely wrong evaluation model
17:53:00 <dmwit> xif: It's just to delimit the major chunks, as far as I'm concerned.
17:53:08 <xif> dmwit: anyways, so you're writing a lot of haskell in Vim, and you're only using the stuff that comes pre-packaged with Vim 7?
17:53:11 <monochrom> But I'm just speaking a truism.
17:53:15 <dmwit> xif: right
17:53:24 <tieTYT2> unfortunately i can't really understand this function.  I donno about isPrevisOf or tails
17:53:27 <nolrai_> The diffrence in unexpected time can reach infinity.
17:53:31 <xif> dmwit: cool. I guess I should become more hardcore :)
17:53:42 <vixey> @src tails
17:53:42 <rahaskella> tails []         = [[]]
17:53:42 <rahaskella> tails xxs@(_:xs) = xxs : tails xs
17:53:49 <xif> non of this wussy syntax/indent files.
17:53:53 <vixey> > tails "blaaaaaaaa"
17:53:56 <rahaskella>  ["blaaaaaaaa","laaaaaaaa","aaaaaaaa","aaaaaaa","aaaaaa","aaaaa","aaaa","aaa"...
17:54:07 <tieTYT2> ah
17:54:07 <tieTYT2> ok
17:54:09 <vixey> > isPrefixOf "foo" "foobar"
17:54:11 <rahaskella>  True
17:54:15 <monochrom> OTOH I won't force anyone to learn things in any order. Skip anything you want, and re-visit anything you want.
17:54:17 <vixey> > isPrefixOf "quux" "foobar"
17:54:17 <tieTYT2> gotcha
17:54:19 <rahaskella>  False
17:54:26 <tieTYT2> thanks (examples are good :)
17:54:26 <dmwit> xif: I don't know, use whatever help you find useful.
17:54:35 <xif> dmwit: possibly the extent of Python and Ruby support for vim does spoil one.
17:54:39 <dmwit> xif: Just because *I* don't find it useful doesn't mean *you* should stop using it. =)
17:54:51 <dcoutts> conal: oh, I see you do have an account and you've requested space for the VectorSpace project, I'll go make that now...
17:54:53 <vixey> > map isPrefixOf "ab" (tails "abracadabra")
17:54:54 <rahaskella>  Couldn't match expected type `[a]' against inferred type `Char'
17:54:57 <vixey> :(
17:55:01 <vixey> > map (isPrefixOf "ab") (tails "abracadabra")
17:55:03 <rahaskella>  [True,False,False,False,False,False,False,True,False,False,False,False]
17:55:08 <vixey> @src any
17:55:09 <rahaskella> any p =  or . map p
17:55:09 <monochrom> I too skipped lazy evaluation for a while. Then the tutorial said "ones = 1 : ones" and I was enlightened.
17:55:19 <xif> dmwit: like, shouldn't it be expected that a <CR> will automatically indent you to the function guards level when writing function guards?
17:55:21 <vixey> or short circuits as soon as it can
17:55:28 <vixey> so you only generate as many tails as you have to
17:55:30 <vixey> no mor
17:55:33 <vixey> e
17:55:47 <tieTYT2> bah this is too advanced for me
17:55:54 <dmwit> xif: My guard level depends on the function name, and on the name of nearby functions.
17:56:05 <tieTYT2> anyway, i'll go back to reading, thanks
17:56:06 <chessguy> monochrom: as soon as you see a language that can handle [1..], lazy evaluation should be pretty apparent
17:56:14 <dmwit> xif: I don't really expect an indentation script to be sophisticated enough to match my preferred style.
17:56:33 <monochrom> Haha this is great material for those Buddhist Zen stories.
17:56:34 <dcoutts> conal: done! :-) so which is going to be the project space then? the one on darcs.h.o or code.h.o?
17:56:48 <chessguy> anyway, time for bed. g'night all!
17:56:55 <vixey> chessguy: [1..] is just new Range(new BigInteger(1), BigInteger.INFINITY)
17:56:59 <xif> dmwit: yeah, I guess I've been spoiled by ruby.vim and python.vim actually supporting that level of sophistication :)
17:57:09 <nolrai_> does ghci giving me a "mismached interface files" message mean I need to reinstall somthing?
17:57:15 <vixey> (I have no idea if that's valid ..)
17:57:19 <dmwit> xif: I doubt they do, I think you just don't understand what I'm talking about.
17:57:22 <vixey> but I know it could be
17:57:54 <dmwit> xif: Although I've been wrong before.
17:57:58 <xif> dmwit: surely you indent all guards to the same level?
17:58:05 <wolverian> are there docs for what I can put into .cabal/config? or, what should I put in there to change the local install target to something else than ~/.cabal?
17:58:12 <monochrom> A student asked his master whether lazy evaluation is important to learn. His master said nothing and just wrote 'zen = "zen" ++ zen' on the sandboard. At that point, the student was enlightened.
17:58:21 <dmwit> xif: All the guards in a single function, sure.  And <cr> does that just fine with :set autoindent.
17:58:35 <vixey> > zen = "zen" ++ zen
17:58:36 <rahaskella>  Parse error at "=" (column 5)
17:58:38 <vixey> :(
17:58:39 <dcoutts> wolverian: user-prefix:
17:58:40 <vixey> @let zen = "zen" ++ zen
17:58:41 <vixey> > zen
17:58:41 <rahaskella> Defined.
17:58:43 <rahaskella>  "zenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzen...
17:58:50 <wolverian> dcoutts, tghanks
17:58:54 <wolverian> s/tg/t/
17:59:04 <dcoutts> wolverian: it's not currently documented. Hopefully we'll make it self-documenting by adding the available fields but commented out
17:59:05 <nolrai_> :P
17:59:19 <vixey> It must have been so fun for the first lazy language to implement it's own show
17:59:33 <wolverian> "Parse of field 'user-install' failed." -- current darcs version
17:59:44 <wolverian> the field is Just True
17:59:55 <wolverian> which seems a bit.. redundant..
18:00:10 <dcoutts> wolverian: with a "Just"?
18:00:14 <wolverian> yes.
18:00:23 <wolverian> I removed it, seems to work now.
18:00:25 <dcoutts> wolverian: oh, weird. Change it to True
18:00:33 <xif> dmwit: k
18:00:35 <wolverian> the file was created by cabal, not me. :)
18:00:37 <dcoutts> wolverian: I'll have to check the code that writes out the default config
18:00:41 <wolverian> yeah. dcoutts++
18:00:55 <conal> dcoutts: thanks for setting up the project space.  i'd given up and made one on d.h.o
18:01:12 <conal> dcoutts: i'll see if i can move my repo to c.h.o
18:01:38 <conal> dcoutts: i ran into a blocking problem when i tried before.  to do with ssh stuff beyond my grasp
18:02:12 <dcoutts> conal: what was the problem exactly?
18:02:28 <conal> dcoutts: i'll have to try it again to find out
18:03:06 <dcoutts> conal: support at community.haskell.org
18:03:29 <dcoutts> conal: I think emails to that address go into our ticket system
18:03:58 <geezusfreeek> conal: i write a new instance for Monad (m :. t) and now instead of overflowing the stack it just sits there and processes without doing anything :(
18:04:07 <geezusfreeek> no space leak or anything at least though
18:04:08 <conal> geezusfreeek: eeep!
18:04:36 <dcoutts> conal: sorry about slowness of setting up new projects, it seems to be only me who does it.
18:05:22 <conal> dcoutts: would it be trouble to rename that project from "VectorSpace" to "vector-space"?
18:05:31 <geezusfreeek> conal: i now think the stack must have been overflowing because of a combination of bugs, one in the old Monad instance and one in my reactive library
18:05:35 <dcoutts> conal: no trouble, gimme a sec..
18:06:14 <conal> geezusfreeek: these hanging and leaking bugs drive me nuts.
18:06:14 <geezusfreeek> my library looping over that bind function for some reason, which in turn must have been building some kind of thunk somewhere
18:06:20 <geezusfreeek> yeah…
18:06:39 <geezusfreeek> i'm not really sure how to debug them properly
18:06:54 <conal> geezusfreeek: i wonder if anyone knows
18:07:03 <dcoutts> conal: done
18:07:15 <conal> dcoutts: thx!  i'll try using it now.
18:09:42 <vixey> how is () pronounced?
18:09:46 <dmwit> unit
18:10:02 <vixey> thanks
18:10:22 <geezusfreeek> i wish i could get some profiling output from a program that fails to terminate
18:10:54 <xif> dmwit: (thanks for discussing this with me :)
18:12:24 <dcoutts> does anyone have any idea who requested space on code.haskell.org for a project "euler" ?
18:12:43 <dcoutts> the person did not say who they were so it's impossible to create a project for them
18:12:50 <Zao> Sounds shifty.
18:13:28 <geezusfreeek> i don't suppose there is a way and i just didn't know this whole time?
18:13:31 <xif> what's wrong with Euler?
18:13:37 <dcoutts> I'll have to reject the request and hope the person re-submits a request with the proper info
18:13:39 <mm_freak> i'm trying to make a list [Object] of game objects, where (data Object = forall g. GameObject g => Object g), and the (class GameObject r) contains the functions (draw :: Object -> IO ()) and (fromObject :: Object -> r), and i'd like to write a function (drawObjects :: [Object] -> IO ())
18:13:53 <xif> Euler is a good guy.
18:13:55 <mm_freak> my initial idea doesn't work:  drawObjects objs = mapM_ (draw . fromObject) objs
18:14:04 <dmwit> xif: Project Euler is also a pretty fun thing. =)
18:14:20 <mm_freak> what am i missing?
18:14:28 <xif> dmwit: yeah, I wonder what that person wanted to do with the space.
18:14:55 <nolrai_> wasnt there some drama about the wiki and project Euler a way back?
18:15:18 <dcoutts> nolrai_: heh, oh yes
18:15:19 <dmwit> What, the thing with copyright infringement?
18:15:27 <dmwit> Or something more spectacular?
18:15:30 <dcoutts> flames all round
18:15:40 <nolrai_> that.
18:15:55 <nolrai_> Seemed kindof insane from the outside.
18:19:26 <dmwit> ?hoogle parMapM
18:19:27 <rahaskella> No matches found
18:19:40 <dmwit> Oh, that doesn't really make sense.
18:19:41 <dmwit> right
18:20:45 <nolrai_> On another topic, the Glade.hi (Interface file?) I have seems to be 6061 and somthing wants 6062, i think, any ideas?
18:21:06 <nolrai_> (I dont realy understand the error message)
18:21:06 <geezusfreeek> conal: dang, i take it back, it's also linearly growing in memory usage
18:21:08 <conal> dcoutts: progress!  i got my .ssh stuff working now, and i can ssh in.
18:21:20 <dcoutts> conal: great
18:21:42 <dcoutts> conal: were you affected by the great debian ssh security fiasco?
18:21:48 <dmwit> ?hoogle parMap -- this one could make sense though
18:21:48 <rahaskella> Hoogle Error: Parse Error: Unexpected character '-- this on'
18:21:53 <dmwit> ?hoogle parMap
18:21:54 <rahaskella> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
18:21:58 <dmwit> Nice!
18:22:05 <vixey> I have a feeling currying could be complicating things
18:22:10 <vixey> wrt fold types
18:23:35 <nolrai_> whats the par prefix
18:23:41 <dmwit> "parallel"
18:24:30 <nolrai_> ah, so parMapM wouldnt work on IO right?(or State)
18:26:23 <dmwit> Yeah, the whole point of monads is the sequencing.
18:26:32 <dmwit> So having a parallel version of a sequenced operation...
18:26:41 <dmwit> It's not really meaningful. =P
18:26:44 <mm_freak> data Object = forall g. GameObject g => Object g  -- is there anything wrong with using [Object] for heterogenous lists?
18:27:13 <mm_freak> up to now i can implement the list, but i cannot actually do anything with it
18:27:23 <vixey> It's not a hetrogenous list
18:28:02 <dmwit> mm_freak: Yeah, you can only do operations on it that are supported by GameObject.
18:28:27 <mm_freak> dmwit: i'm trying to, but it doesn't work…  see above, i get ambiguity errors
18:28:29 <geezusfreeek> ugh, okay, tired of this
18:28:32 <geezusfreeek> done for today
18:28:50 <dmwit> mmm
18:28:51 <Saizan> mm_freak: above where?
18:29:08 <Saizan> mm_freak: however you need to choose a specific type before packing it in the Object constructor
18:29:10 <mm_freak> and i'm asking myself, whether my idea is fscked up in the first place
18:29:50 <mm_freak> Saizan: about one screen page above in your backlog
18:30:21 <Saizan> your class is screwed
18:30:24 <geezusfreeek> conal: I think I may be best off starting completely from scratch, integrating things from this existing code base, and testing a bit at a time as I go.
18:30:49 <geezusfreeek> conal: so i guess that means expect some slower progress for the next little while
18:31:02 <conal> geezusfreeek: yeah. that's all i know to do, too.  groping in the dark
18:31:26 <geezusfreeek> conal: such is the downside of relying on the type system as much as i do
18:31:30 <Saizan> mm_freak: just use class GameObject r where draw  :: r -> IO (), then you can write mapM_ (\(Object o) -> draw o) objs
18:32:11 <Saizan> mm_freak: or you can make Object an instance of GameObject in the obvious way and then write mapM_ draw objs
18:32:12 <geezusfreeek> i wish the type system could tell me about bounds on time and space usage of my functions
18:32:41 <Saizan> s/or/additionally/
18:33:12 <mm_freak> http://hpaste.org/7739 ⇐ here is the full code
18:33:34 <nolrai_> can some one please tell me what "
18:33:35 <nolrai_> Bad interface file: /usr/lib/haskell-packages/ghc6/lib/gtk-0.9.12/imports/Graphics/UI/Gtk.hi
18:33:35 <nolrai_>         mismatched interface file versions: expected 6082, found 6061
18:33:40 <nolrai_> means
18:34:09 <mauke> probably that gtk was compiled with ghc-6.6.1, but you're using 6.8.2 now
18:34:15 <mm_freak> i get an error for the fromObject default implementation
18:34:18 <Saizan> mm_freak: your fromObject shouldn't even compile..
18:34:33 <mm_freak> yes, and i don't understand why
18:34:34 <nolrai_> so, should i install from source?
18:34:46 <nolrai_> mauke++
18:35:26 <Saizan> mm_freak: well, the 'g' inside Object is existentially quantified, so you lose information about what specific type it is, and you can't get that information back
18:35:57 <mm_freak> that was my impression…  is my idea messed up?  or am i just overlooking something?
18:36:38 <Saizan> mm_freak: your idea works fine if you only need to use methods of class GameObject on things contained in an Object
18:36:47 <dmwit> Suppose you're mapping a function that takes roughly 1ms over a list of 1000 elements.
18:36:50 <Saizan> mm_freak: but you don't need fromObject for that
18:36:53 <dmwit> Does it make sense to parallelize it?
18:37:05 <dmwit> (I can't answer this empirically, because I am stuck on a single-core machine.)
18:37:11 <mm_freak> Saizan: thank you, i'll try your suggestion above
18:37:36 <geezusfreeek> mm_freak: http://hpaste.org/7739#a1
18:37:53 <nolrai_> dmwit: each or total. (not that i know or anything)
18:38:04 <dmwit> Let's say the function takes 1ms for each call.
18:38:12 <dmwit> At what point does it make sense to start parallelizing it?
18:38:48 <dmwit> I assume it depends on the length of the list and the number of cores, but roughly how big would the list have to be for it to make sense on, say, 8 cores?
18:39:00 <nolrai_> hmm.
18:39:07 <mm_freak> geezusfreeek: thanks, i've just done exactly the same thing =)
18:39:33 <mm_freak> and it works now, thanks to both of you
18:39:47 <Saizan> mm_freak: http://hpaste.org/7739#a2 -- sligthly nicer
18:41:53 <mm_freak> Saizan: interesting idea
18:42:08 <mm_freak> that replaces my fromObject approach very well
18:47:21 <dmwit> ?hoogle TimeLocale
18:47:22 <rahaskella> System.Locale.TimeLocale :: data TimeLocale
18:47:22 <rahaskella> System.Locale.TimeLocale :: [(String, String)] -> [(String, String)] -> [(String, String)] -> (String, String) -> String -> String -> String -> String -> TimeLocale
18:47:22 <rahaskella> System.Locale.defaultTimeLocale :: TimeLocale
18:51:29 <dmwit> Hmmm.
18:51:58 <dmwit> Google Treasure Hunt says "The second puzzle will be appearing soon -- to be exact, 936266827 seconds before Y2K38."
18:52:02 <dmwit> But...
18:52:20 <vixey> > 936266827`div`(60*60)
18:52:22 <dmwit> Data.Time System.Locale> addUTCTime (negate 936266827) (readTime defaultTimeLocale "%Y" "2038")
18:52:22 <dmwit> 2008-05-01 13:52:53 UTC
18:52:22 <rahaskella>  260074
18:52:30 <vixey> > 936266827`div`(60*60*24)
18:52:32 <rahaskella>  10836
18:52:37 <vixey> > 936266827`div`(60*60*24*360)
18:52:39 <rahaskella>  30
18:52:44 <dmwit> ...is more than two weeks *before* the aforementioned blog post.
18:52:48 <vixey> oh
18:52:52 <vixey> :[
18:58:29 <nolrai_> > (60 * 60) * 24 * 7 * 2
18:58:31 <rahaskella>  1209600
19:03:10 <dmwit> > 365 * 24 * 60 * 60
19:03:12 <rahaskella>  31536000
19:03:19 <dmwit> > 936266827 - 31536000
19:03:22 <rahaskella>  904730827
19:04:11 <dmwit> Oh, that's stupid.
19:05:04 <nolrai_> what?
19:05:13 <dmwit> They don't actually mean 2k38.
19:05:16 <dolio> Woo! My heapsort finally competes with introsort on one benchmark.
19:05:33 <dmwit> They mean the moment in 2k38 when people using seconds-since-epoch will overflow a time_t.
19:06:00 <nolrai_> oh heh, i like it.
19:07:42 <gwern> dmwit: doesn't introsort use heapsort?
19:07:51 <dmwit> uhhh...
19:08:05 <dolio> gwern: Only when it thinks it's in a worst case scenario.
19:08:06 <dmwit> gwern: Are you responding to an hours-old conversation of which I was not even a member??
19:08:21 <dolio> Which most of my tests aren't.
19:08:38 <gwern> dmwit: ...yes, that's it. I was, uh, looking at my scrollback
19:08:53 <dolio> Introsort even beats it on the worst case scenario, because it does a little partitioning before handing things over to heapsort, so it sucks slightly less. :)
19:09:50 <conal> dcoutts_: i finished moving vector-space from d.h.o to c.h.o .
19:09:52 <dolio> It's possible I don't have my worst-case written correctly, though.
19:10:10 <conal> dcoutts_: thx for the nudge before i'd announced
19:10:38 <chessguy> conal: you're announcing a new project/release?
19:10:41 <dolio> Anyhow, the test they have parity on is sorting size-4 arrays repeatedly, where they both delegate to the optimal size-4 sort. :)
19:11:03 <conal> chessguy: not yet.  i want to write my blog posts first so people will know what it's about.
19:11:17 <Pseudonym> If you know your elements are size-4, and it's an inner loop, you're mad not to.
19:11:24 <chessguy> ah
19:11:29 <Pseudonym> (Useful if you're implementing AI for Mastermind.)
19:11:46 <conal> chessguy: it's an extension of the "beautiful differentiation" post
19:11:47 <Pseudonym> (Where there are generally a lot of evaluations in your inner loop.)
19:14:52 <chessguy> conal: sounds neat!
19:15:20 <conal> chessguy: it is!  i'm thrilled about how it worked out.
19:16:16 <dolio> I've been trying to improve the heapsort for a while without much success.
19:16:58 <dolio> I'm looking at a benchmark of heap, quick and merge sort in C, and the first two are comparable, and heapsort even wins with ICC.
19:17:25 <dolio> But my heapsort in haskell tends to be about 5 - 10 times slower than the quick/introsort.
19:17:30 <chessguy> conal: i think i've reduced a lot of the noise in http://code.haskell.org/ChessLibrary/Chessboard.hs , though i'm open to suggestions
19:17:39 <Pseudonym> How did you implement heapsort in Haskell?
19:17:56 <dmwit> Very carefully!
19:18:08 <dolio> What do you mean?
19:18:20 <dolio> They're all sorting MUArrs from Data.Array.Vector.
19:18:22 <dolio> In place.
19:18:25 <Pseudonym> Ah.
19:18:28 <Pseudonym> That's not idiomatic.
19:18:37 <dolio> It's fast, though. :)
19:18:45 <Pseudonym> More idiomatic would be to use a functional priority queue.
19:19:29 <Pseudonym> The quickest list sort in Haskell, AFAICT, is still bottom-up polyphase merge sort.
19:19:36 <Pseudonym> With the initial runs chosen cleverly.
19:20:47 <dolio> Well, I was originally concerned with making good sorts for these things specifically.
19:21:00 <dolio> Sorting lists is actually in the standard libraries.
19:21:22 <dmwit> Wow, there's a *lot* of discussion on proggit about Google's grid-bot problem.
19:21:24 <dolio> There aren't sort routines for ST arrays and the like, unless I've been blind for a while.
19:21:28 <dmwit> Like, hundreds of comments.
19:21:47 <conal> chessguy: better!  first comments: i see 'movesFromRays (dirs foo)' four times; parseCS has a lot of repetition; also isLegal
19:21:49 <dmwit> All kinds of comments about recursion, memoization, ..., when it's just a combinatorics problem.
19:22:44 <conal> chessguy: i wonder if movesFromRays would be prettier as a list comprehension
19:23:32 <chessguy> hm, the repetition in parseCS is largely due to the suckage of haskell records
19:23:46 <conal> chessguy: i guessed that.
19:24:13 <dolio> I was thinking about looking at what they do in the GNU implementation of the STL, but my initial impression of it was an impenetrable wall of templates.
19:24:16 <conal> chessguy: still, i bet you can do some factoring
19:24:23 <chessguy> hm, maybe
19:25:04 <gwern> chessguy: is ChessLibrary 6.9 only or something? I try compiling testharness and failed
19:25:07 <gwern> 'TestHarness.hs:22:19:
19:25:08 <conal> chessguy: default_enemyOn : 'liftM switchColor (Just curColor)'  hm.  can be simplified.
19:25:10 <gwern>     Ambiguous type variable `cb' in the constraint:
19:25:11 <gwern>       `Chessboard cb'
19:25:14 <gwern>         arising from a use of `perft' at TestHarness.hs:22:19-35
19:25:32 <chessguy> gwern: nah, it's just still in development
19:25:51 <dmwit> conal: Are you thinking like (Just (switchColor curColor)) or something?
19:25:54 <chessguy> testharness is the client code to what we're looking at now, and it sucks
19:25:59 <dmwit> or even s/Just/return/
19:26:00 <gwern> ah. this error was with a pull just now, btw
19:26:32 <conal> chessguy: yeah.
19:28:14 <chessguy> conal: this is the real reason i want to refactor Chessboard. i'm really not sure why the client code sucks so bad
19:28:16 <conal> chessguy: just to see, how about tentatively rewriting some of those filter/concatMap combos (and similar) as list comprehension.
19:28:42 <conal> sure
19:29:10 <chessguy> conal: there's only one filter/concatMap combo left
19:29:16 <swidgy> conal: your blog is the first in ages that i've subscribed to that's actually named after the author, rather than some puddle of pseudo-wit.  thank you for that ;)
19:30:08 <gwern> swidgy: you don't like lukewarm puddles of pseudo-wit?
19:30:15 <conal> swidgy: thx!  i might rename it if i come with something that really captures my intention.
19:30:40 <conal> chessguy: oh yeah
19:30:49 <conal> chessguy: then all one ;)
19:31:00 * Pseudonym now wishes he'd named his blog Pseudo-wit
19:31:03 <chessguy> conal: haha, fair enough
19:31:07 <chessguy> it's on my list :)
19:31:07 <swidgy> :)
19:33:07 <chessguy> gwern: the code is definitely not ready for anything but more work. thus the license, and lack of releases :)
19:33:35 <gwern> chessguy: nah, I was just wondering why it wasn't compiling
19:34:26 <chessguy> gwern: yeah, it's because i don't like my own interface, and can't figure out how to fix it :)
19:34:39 <gwern> bad jokes, lord how I love'em, bad jokes, can't get enough of'em - hey did you hear about the blog of the professional polemicist? No, what's it called? 'Bewittle'
19:34:57 * gwern groans at my own joke. 'Bewittle' would be a terrible blog title
19:35:00 <chessguy> should be sorted out this week, i hope
19:35:44 <dmwit> Bewhittle, the carver's blog.
19:36:24 <zooko> Heh heh.
19:36:36 <gwern> dmwit: that actually wouldn't be too bad.
19:36:53 <gwern> but perhaps it'd be more suited to a critic of carving/carpentry?
19:36:58 <dmwit> yeah =)
19:37:00 <gwern> so he can belittle their whittling...
19:37:38 <dmwit> But that wood be mean!
19:37:48 <chessguy> oh good grief
19:38:08 <dmwit> Sorry, I'm just such a sap for these puns.
19:38:47 <zooko> Ha!
19:38:48 <gwern> dmwit: that reminds me: http://simulatedcomicproduct.com/
19:39:10 <dmwit> I read that earlier this weekend, yeah. =)
19:39:16 <dmwit> That's what I was thinking of.
19:39:26 <gwern> zooko: it's so appropriate...
19:42:07 <dmwit> he
19:42:10 <dmwit> http://simulatedcomicproduct.com/2008/04/15/bubbles/
19:42:16 <dmwit> *tink* *tink*
19:49:09 <yaru1022> hi~
19:49:32 <yaru1022> I have a question about module/import stuff
19:49:32 <dmwit> Hiya, yaru1022!
19:49:50 <yaru1022> I did "import Text.ParsecCombinators.Parsec.Token as P"
19:49:59 <yaru1022> and defined whiteSpace = P.whiteSpace lexer
19:50:11 <yaru1022> but whenever I refer to whiteSpace later on in my code
19:50:17 <yaru1022> it says it's ambiguous occurrence...
19:50:37 <yaru1022> but why is it so? one is whiteSpace and the other is P.whiteSpace
19:50:38 <Cale> yaru1022: add the keyword "qualified" after import
19:51:05 <Cale> (which will require qualification to refer to members of the imported module)
19:51:34 <yaru1022> Cale, aha.. yeah that seems like solving the problem
19:51:35 <dmwit> yaru1022: "import qualified" and "import as" are orthogonal.
19:51:48 <dmwit> yaru1022: "import" always puts the fully-qualified name in scope.
19:51:51 <Cale> Without 'qualified', the module is imported normally, but ambiguous occurrences can be solved by qualifying with P rather than Text.ParsecCombinators.Parsec.Token
19:52:14 <dmwit> yaru1022: "import" with no "qualified" also puts an un-qualified name in scope.
19:52:35 <yaru1022> i c :)
19:52:41 <dmwit> yaru1022: "import" with an "as" clause puts a partially-qualified name in scope, where the qualification can be determined by the programmer.
19:52:57 <dmwit> yaru1022: So, if you "import Foo as Bar", you actually put *3* names in scope!
19:54:08 <yaru1022> why is it 3? not 2?
19:54:58 <dmwit> yaru1022: Because you get foo, Foo.foo, and Bar.foo.
19:55:22 <yaru1022> ah i c.. normal scope :) gotcha
19:55:49 <nolrai_> so the Foo.foo is always there?
19:56:00 <dmwit> Yes, no escaping that one.
20:00:50 <Taggnostr> http://www.linuxjournal.com/article/8850
20:02:08 <dmwit> Another monad tutorial?
20:03:40 <ddarius> Just what we needed!
20:04:36 <bd_> We need less monad tutorials and more comonad tutorials :(
20:05:57 <Taggnostr> I don't know haskell and I don't know what monad are, but I there is some python there and the article claims to be simpler than most of the other
20:06:36 <ddarius> Taggnostr: All "monad tutorials" claim to be simpler than all the others.
20:07:04 <Taggnostr> these monad should be really hard then
20:07:23 <shapr> edwardk made the point on the drive home friday that comonads are more commutative than monads, and thus more useful on multi-core architectures.
20:07:25 <ddarius> Taggnostr: No, most of the monad tutorials suck like hell.
20:07:44 <dmwit> Taggnostr: No, monads are really easy.  Here, let me tell you about them...
20:07:54 <Taggnostr> :D
20:09:01 <pjdelport> Taggnostr: many monad tutorials are written by people who are excited about just having started to grasp them
20:09:15 <OceanSpray> I still don't get monads.
20:09:24 <OceanSpray> Though I know how to use them.
20:09:27 <OceanSpray> Is that bad?
20:09:34 <dmwit> nah
20:09:37 <cjs> Yes.
20:09:39 <dmwit> They were brought in to be used.
20:09:40 <Taggnostr> uhm
20:09:42 <pjdelport> OceanSpray: they're just Functors with an extra operation or two
20:09:46 <mauke> I think it's good
20:10:04 <nolrai_> understanding is overrated.
20:10:22 <pjdelport> "Monads as a Design Pattern" is such a content-free statement
20:10:40 <nolrai_> (IMNSHO using something is the best way to lern it.)
20:10:49 <pjdelport> anything in CS is a design pattern, in that sense
20:10:57 <dmwit> nolrai_: Like keyboards? ;-)
20:11:10 <cjs> Well, I'm far from an authority on this, but it seems to me that making new instances of the various monad-related classes is a basic part of program design in Haskell.
20:11:25 <nolrai_> well..
20:11:32 <ddarius> cjs: Not really.
20:11:38 <cjs> No?
20:11:47 <dmwit> Mostly just using the existing monads is enough.
20:11:52 <dmwit> Especially with the MTL.
20:11:53 <ddarius> cjs: The vast majority of the time you can just combine monad transformers to get what you want.
20:12:19 <Taggnostr> I think I have to learn something about haskell before trying to understand what monads are, or maybe not?
20:12:28 <cjs> Ah, there's my failing. I know how to make a monad, but I don't know how to use a monad transformer. :-)
20:12:49 <dmwit> Taggnostr: It comes from math, so you don't need any Haskell to understand it.
20:12:56 <ddarius> Taggnostr: If you want to know how monads are used in Haskell, yes.  Monads existed long before Haskell though, so you -could- learn about them independently, but not so much in the context of programming.
20:13:02 <dmwit> Taggnostr: It's not so obvious how to use it in Haskell until you know a bit about Haskell, though.
20:13:11 <Taggnostr> I need math, and this is possibly worst :D
20:13:14 <pjdelport> Taggnostr: you can learn monads without any Haskell, but in the context of Haskell, you have to understand at least type classes first
20:13:14 <dmwit> ...I see that ddarius and I agree.
20:13:18 <cjs> Taggnostr, there are monad tutorials for other languages, e.g., Ruby. But what worked for me was to approach it on all fronts; when I get stuck on one thing, go learn about a different, related thing for a bit, and come back later to where I was stuck.
20:13:54 <pjdelport> Taggnostr: but learn functors first
20:14:25 <nolrai_> functors are what?
20:14:33 <pjdelport> @src Functor
20:14:34 <rahaskella> class  Functor f  where
20:14:34 <rahaskella>     fmap        :: (a -> b) -> f a -> f b
20:14:34 <Taggnostr> actually haskell is what I'd like to learn, if this means learn monads too I'll learn them too
20:15:20 <dmwit> nolrai_: Monads are functors with a meaningful "return".
20:15:30 <pjdelport> intuitively, a functor is any structure you can map a function across
20:15:44 <Taggnostr> in that article there's written "If a programming language doesn't teach you a new way to think about problems, it's not worth learning.", and that's why I'd like to learn some haskell
20:15:46 <pjdelport> (and join)
20:16:05 <pjdelport> Taggnostr: the most familiar example of a functor is lists
20:16:12 <nolrai_> yeah, i knew the concept but not the name.
20:16:13 <pjdelport> @src [] fmap
20:16:14 <rahaskella> fmap = map
20:16:29 <pjdelport> > fmap show [2,3,5]
20:16:32 <rahaskella>  ["2","3","5"]
20:16:45 <mauke> > fmap (/ 0) []
20:16:48 <rahaskella>  []
20:17:05 <nolrai_> @src Maybe fmap
20:17:06 <rahaskella> fmap _ Nothing       = Nothing
20:17:06 <rahaskella> fmap f (Just a)      = Just (f a)
20:17:13 <OceanSpray> what are lazy patterns good for again?
20:17:20 <mauke> Maybe is just a list with at most one element
20:17:35 <pjdelport> > fmap show (Just 5)
20:17:38 <rahaskella>  Just "5"
20:17:45 <pjdelport> > fmap show Nothing
20:17:47 <rahaskella>  Nothing
20:17:59 <mauke> > fmap (/ 0) (Just 5)
20:18:02 <rahaskella>  Just Infinity
20:18:02 <nolrai_> Whats the relation ship between fmap and the monad operators?
20:18:10 <mauke> liftM == fmap
20:18:23 <pjdelport> nolrai_: fmap/liftM is a monad operator :)
20:18:37 <nolrai_> doh.
20:18:44 <luqui> OceanSpray, usually when you're getting into infinite recursion because it's too strict
20:18:48 <sjanssen> or fmap f m = m >>= return . f
20:18:55 <mauke> @src liftM
20:18:56 <rahaskella> liftM f m1 = do { x1 <- m1; return (f x1) }
20:19:09 <mauke> @. undo src liftM
20:19:09 <rahaskella> ()
20:19:14 <mauke> wat
20:19:21 <sjanssen> or m >>= f = join (fmap f m)
20:19:42 <pjdelport> Taggnostr: do you understand the Functor type class's declaration above?
20:19:45 <dmwit> ?undo do { hey }
20:19:46 <rahaskella> hey
20:19:59 <sjanssen> mauke: undo only takes expressions
20:20:11 <Taggnostr> not really
20:20:15 <dmwit> ?undo do { x1 <- m1; return (f x1) }
20:20:15 <rahaskella> m1 >>= \ x1 -> return (f x1)
20:20:38 <ddarius> @pl m1 >>= \x1 -> return (f x1)
20:20:38 <rahaskella> f `fmap` m1
20:20:40 <pjdelport> Taggnostr: probably best to work through a Haskell tutorial, then :)
20:20:43 <ddarius> doh
20:20:51 <pjdelport> http://en.wikibooks.org/wiki/Haskell is good
20:20:55 <Taggnostr> yep
20:21:01 <Taggnostr> I still have to start
20:21:18 <pjdelport> Taggnostr: type classes start getting covered around "Intermediate"
20:21:56 <pjdelport> but briefly, it's a way to define a set of functions that are generic, with implementations (instances) for many data types
20:21:59 <Taggnostr> I just wrote an haskell program by trial and error
20:22:10 <pjdelport> @src Eq
20:22:10 <rahaskella> class  Eq a  where
20:22:10 <rahaskella>     (==), (/=)   :: a -> a -> Bool
20:22:19 <pjdelport> that should hopefully make sense
20:22:32 <pjdelport> @src [] (==)
20:22:33 <rahaskella> []     == []     = True
20:22:33 <rahaskella> (x:xs) == (y:ys) = x == y && xs == ys
20:22:33 <rahaskella> _xs    == _ys    = False
20:22:36 <sjanssen> so where is lambdabot?
20:22:46 <pjdelport> @src Maybe (==)
20:22:46 <rahaskella> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
20:22:57 <EvilTerran> ?seen Cale
20:22:57 <rahaskella> Cale is in #haskell. I last heard Cale speak 31m 6s ago.
20:22:58 <dmwit> sjanssen: Cale is waiting for access to code.h.o, last I knew.
20:22:59 <ddarius> sjanssen: Trapped on code.haskell.org
20:23:20 <sjanssen> dmwit, ddarius: ah, because of the weak SSH key fiasco, I assume
20:23:37 <dmwit> yeah
20:23:47 <pjdelport> Taggnostr: so any type that defines an Eq instance, you can use (==) and (/=) with
20:24:20 <pjdelport> Haskell has many other type classes for numbers, ordering, and so on
20:24:33 <pjdelport> @src (+)
20:24:34 <rahaskella> Source not found. My pet ferret can type better than you!
20:24:37 <Taggnostr> uhm
20:24:37 <mauke> preflex: seen lambdabot
20:24:37 <preflex>  lambdabot was last seen on #haskell 1 day, 3 hours, 34 minutes and 49 seconds ago, saying: forall (m :: * -> *) a. (Monad m) => String -> m a
20:24:39 <pjdelport> err
20:24:41 <pjdelport> :t (+)
20:24:44 <rahaskella> forall a. (Num a) => a -> a -> a
20:24:53 <EvilTerran> ?src Num
20:24:54 <rahaskella> class  (Eq a, Show a) => Num a  where
20:24:54 <rahaskella>     (+), (-), (*)           :: a -> a -> a
20:24:54 <rahaskella>     negate, abs, signum     :: a -> a
20:24:54 <rahaskella>     fromInteger             :: Integer -> a
20:25:49 <Taggnostr> how should I read the -> ?
20:26:10 <EvilTerran> (a -> b) = "function taking an (a) as a parameter and returning a (b)"
20:26:22 <ddarius> "to"
20:26:41 <EvilTerran> -> is right-associative, so (a -> b -> c) = (a -> (b -> c)) = "function from (a) to another function, from (b) to (c)"
20:26:47 <EvilTerran> ?type map
20:26:51 <rahaskella> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:26:55 <EvilTerran> ?type map (+1)
20:27:00 <rahaskella> forall a (f :: * -> *). (Functor f, Num a) => f a -> f a
20:27:04 <pjdelport> heh
20:27:16 <dmwit> ?type Prelude.map
20:27:20 <rahaskella> forall a b. (a -> b) -> [a] -> [b]
20:27:23 <EvilTerran> Cale, (-.-)
20:27:31 <Taggnostr> uhm
20:28:03 <Taggnostr> I can understand negate, abs, signum :: a -> a, but how about (+), (-), (*) :: a -> a -> a?
20:28:35 <luqui> ahh, haskell functions are curried.  basically multiple arrows means multiple arguments
20:28:44 <luqui> the rightmost thing is the result, the other ones are arguments
20:28:46 <pjdelport> Taggnostr: a rule of thumb is that the rightmost item is the return type, and the rest are arguments
20:29:11 <pjdelport> as EvilTerran said, that means the same as :: a -> (a -> a)
20:29:13 <Taggnostr> so I could read that as a, a -> a
20:29:14 <ddarius> :t return id
20:29:18 <rahaskella> forall a (m :: * -> *). (Monad m) => m (a -> a)
20:29:28 <pjdelport> yes, in fact:
20:29:30 <ddarius> :t curry
20:29:31 <pjdelport> :t uncurry (+)
20:29:36 <rahaskella> forall a b c. ((a, b) -> c) -> a -> b -> c
20:29:37 <rahaskella> forall a. (Num a) => (a, a) -> a
20:29:57 <Taggnostr> I see
20:29:58 <pjdelport> (a, a) -> a is the type (+) has in uncurried languages
20:30:33 <pjdelport> > map ((+) 1) [2,3,5]
20:30:36 <rahaskella>  [3,4,6]
20:30:41 <pjdelport> > map (1+) [2,3,5]
20:30:43 <rahaskella>  [3,4,6]
20:30:57 <EvilTerran> ?src curry
20:30:58 <rahaskella> curry f x y = f (x, y)
20:30:59 <EvilTerran> ?src uncurry
20:31:00 <rahaskella> uncurry f p = f (fst p) (snd p)
20:31:06 <vixey> bleh
20:31:09 <Taggnostr> > map (+1) [2,3,5]
20:31:11 <rahaskella>  [3,4,6]
20:31:12 <vixey> don't look at those src's
20:31:14 <vixey> :t curry
20:31:16 <dmwit> Taggnostr: Scream "STOP" if at any moment you are overwhelmed. ;-)
20:31:16 <vixey> :t uncurry
20:31:18 <rahaskella> forall a b c. ((a, b) -> c) -> a -> b -> c
20:31:21 <rahaskella> forall a b c. (a -> b -> c) -> (a, b) -> c
20:31:26 <vixey> the types are much clearer
20:31:40 <mxc> @hoogle forkIO
20:31:40 <rahaskella> GHC.Conc.forkIO :: IO () -> IO ThreadId
20:31:40 <rahaskella> Control.Concurrent.forkIO :: IO () -> IO ThreadId
20:31:42 <EvilTerran> ?djinn (a -> b -> c) -> (a, b) -> c
20:31:43 <rahaskella> f a (b, c) = a b c
20:31:46 <dmwit> (Actually, it's probably more useful to *type* STOP, but hey, scream if you want to.)
20:32:09 <nolrai_> eh, i think think the curry is very readable
20:32:20 <ddarius> uncurry f ~(x,y) = f x y
20:32:29 <vixey> nolrai: compare it with the types
20:33:03 <pjdelport> ddarius: why the irrefutable match, in that case?
20:33:07 <vixey> you need to understand currying to understand the function definition
20:33:32 <nolrai_> Oh, yeah.
20:33:39 <ddarius> pjdelport: Because otherwise it would be too strict.
20:33:41 <EvilTerran> pjdelport, so, if f isn't strict in either argument, you don't get an error
20:33:54 <pjdelport> oh, of course
20:33:54 <Taggnostr> what does curry mean?
20:33:56 <pjdelport> thanks
20:33:56 <gwern> @wn appurtaining
20:33:57 <EvilTerran> > uncurry (\x y -> "it works") undefined
20:33:58 <rahaskella> No match for "appurtaining".
20:33:59 <rahaskella>  "it works"
20:34:07 <dmwit> ?wn appertaining
20:34:08 <rahaskella> No match for "appertaining".
20:34:18 <ddarius> Taggnostr: It comes from a name in this context, namely Haskell Curry.
20:34:19 <EvilTerran> > let uncurry' f (x,y) = f x y in uncurry' (\x y -> "it breaks") undefined
20:34:22 <rahaskella>  "Exception: Prelude.undefined
20:34:31 <gwern> @wn appurtain
20:34:32 <rahaskella> No match for "appurtain".
20:34:34 <dmwit> appertain v : be a part or attribute of
20:34:44 <gwern> @wn appertain
20:34:46 <rahaskella> *** "appertain" wn "WordNet (r) 2.0"
20:34:46 <rahaskella> appertain
20:34:46 <rahaskella>      v : be a part or attribute of [syn: {pertain}]
20:35:06 <pjdelport> Taggnostr: http://en.wikipedia.org/wiki/Currying
20:35:12 <EvilTerran> Taggnostr, the definition of "to curry" in this context is pretty much wholly described by the type of the curry function
20:35:18 <gwern> ah, 'appurtain' is the archaic spelling. no wonder it wasn't showing up
20:35:24 <EvilTerran> ((a,b) -> c) -> (a -> b -> c)
20:35:31 <nolrai_> it means take an f on (x, y) and produce an f' on x that returns a f'' on y.
20:35:46 <nolrai_> err
20:35:50 <gwern> @djinn  ((a,b) -> c) -> (a -> b -> c)
20:35:51 <rahaskella> f a b c = a (b, c)
20:36:07 <Taggnostr> indeed it didn't seem related to http://en.wikipedia.org/wiki/Curry
20:36:23 <pjdelport> hmm, curry
20:36:43 <gwern> EvilTerran: you would seem to be correct about the wholly part :)
20:37:10 <EvilTerran> :)
20:39:59 <Taggnostr> it seems in some way related to python's decorators
20:40:53 <dmwit> Any hints on manually mangling a darcs patch?
20:40:59 <pjdelport> Taggnostr: not really
20:41:05 <dmwit> Specifically, how do I compute the new checksum?
20:41:22 <dmwit> md5sum, sha256sum both seem to not be it
20:41:53 <pjdelport> Taggnostr: in Python terms, "f = lambda a b: c" is uncurried, and "f = lambda a: lambda b: c" is curried
20:42:45 <Taggnostr> I see
20:43:25 <Taggnostr> let me try a thing
20:45:10 <Taggnostr> so if I have f(a,b) -> c I have to do f(a)(b) -> c where f(a) returns a function that accepts b as arg?
20:45:43 <Cale> that's not quite the syntax, but that's the idea
20:45:54 <vixey> looks like ML
20:45:59 <Cale> and you don't have to do that, since there are tuples
20:46:16 <pjdelport> Taggnostr: it's more accurate to say ((f a) b)
20:46:21 <Cale> But currying is the usual way to handle multiparameter functions
20:46:22 <vixey> Hi Cale
20:46:27 <Cale> hello
20:46:42 <pjdelport> Taggnostr: or ((((f a) b) c) ...), and so on
20:46:56 <Cale> Yeah, function application is left-associative
20:47:03 <dmwit> Taggnostr: Function application doesn't require any parentheses in Haskell, it's just whitespace.
20:47:05 <vixey> (...(((f a) b) c) ...)
20:47:08 <pjdelport> yes, so the above is identical to (f a b c ...)
20:47:12 <dmwit> Taggnostr: So, f(a) in another language is "f a" here.
20:47:23 <s1d>  /j #maemo
20:47:31 <s1d> whoops
20:47:53 <Taggnostr> uhm
20:47:55 <vixey> know any good puzzles? :[
20:48:03 <shepheb> can anyone think of a reason why I might see odd blocking behaviour in an STM and Network-using app on Windows but as-expected on Linux?
20:48:15 <Cale> vixey: Nurikabe?
20:48:24 <shepheb> I am using that withSocketsDo initialization thing
20:48:36 <vixey> thank you Cale
20:49:17 <Cale> http://www.janko.at/Raetsel/Nurikabe/ has lots of them :)
20:49:32 <pjdelport> Taggnostr: otherwise, what you said above is mainly correct:  currying means that you call a function with one parameter, and it gives you a function of the remaining parameters
20:50:09 <Taggnostr> does it happen automagically in haskell?
20:50:13 <pjdelport> yep
20:50:28 <pjdelport> Haskell is a curried by default
20:50:30 <dibblego> that's partial application
20:50:34 <dmwit> vixey: What kind of puzzles, programming puzzles?
20:50:38 <dibblego> -> is right-associative
20:50:48 <dibblego> a -> b -> c is the same as a -> (b -> c)
20:51:17 <pjdelport> Taggnostr: besides uncurry, though, you can still define your functions to take tuples if you want
20:51:19 <vixey> dmwit: any distractions
20:51:37 <Taggnostr> if I define the function add to take 2 args and return their sum and I do add 3 5 10, won't I end up with 8 10 ?
20:51:40 <pjdelport> which is more or less the equivalent of the default in uncurried languages
20:51:47 <dmwit> vixey: Project Euler, Ruby Quiz, write a sudoku solver, ...
20:51:48 <shepheb> vixey: Project Euler?
20:51:56 <dibblego> @go project euler
20:51:57 <rahaskella> http://projecteuler.net/
20:51:57 <rahaskella> Title: Project Euler
20:52:01 <pjdelport> Taggnostr: well, that will give you a type error
20:52:14 <pjdelport> Taggnostr: because (add 3 5) will be a number
20:52:34 <pjdelport> and you can't apply a number to a number :)
20:52:44 <Taggnostr> and if I want to add more numbers I have to tell it to return add again
20:52:52 <Taggnostr> right?
20:53:04 <pjdelport> well, you could have add3 a b c = a + b + c
20:53:10 <pjdelport> and so on
20:53:13 <mauke> > let add x y = x + y in add 3 5 10
20:53:14 <rahaskella>   add an instance declaration for (Num (t -> a))
20:53:29 <pjdelport> if you want to add any number of numbers, you'll want to take a list instead
20:53:30 <mauke> that error means: I don't know how to turn a number into a function
20:53:32 <pjdelport> :t sum
20:53:35 <rahaskella> forall a. (Num a) => [a] -> a
20:53:44 <pjdelport> > sum [3,5,10]
20:53:46 <rahaskella>  18
20:54:58 <pjdelport> (the "(Num a) =>" bit has to do with type classes:  it declares that a must be an instance of the Num type class)
20:55:22 <pjdelport> (so that type is Haskell's way of saying "a list of numbers to a number")
20:55:39 <nolrai_> > let add a b = a + b in add (add 3 5) 10
20:55:42 <rahaskella>  18
20:55:44 <mauke> oh, while we're at it
20:55:47 <mauke> > 8 10
20:55:48 <rahaskella>   add an instance declaration for (Num (t -> a))
21:02:42 <vixey> nurikabe is interesting
21:03:05 <Taggnostr> http://dpaste.com/51168/ :O
21:03:43 <vixey> What's a good way to reprsent a 2D grid of cells?
21:04:15 <gwern> a list of lists! :)
21:04:22 <Cale> Perhaps an Array indexed by (Int,Int)?
21:04:33 * gwern is kidding, unless you don't need great space/time characteristics
21:04:39 <Taggnostr> let's see if I can do add(n1)(n2)(nN)
21:05:04 <Cale> Sometimes a list of lists isn't a bad way to represent a 2D grid -- if you'll always process that grid in an order that conforms to the list structure
21:05:16 <sjanssen> Taggnostr: we generally write that as add n1 n2 nN
21:05:16 <mauke> Map Integer a
21:05:32 <mauke> where k = 2^x * 3^y
21:05:37 <Cale> heh
21:05:44 <Taggnostr> yep, I'm still use to call functions as f(args)
21:05:45 <Cale> Why not index with a pair?
21:05:52 <mauke> TOO OBVIOUS
21:06:01 <sjanssen> Taggnostr: stop, you're programming Haskell now :)
21:06:27 <Taggnostr> s/[()]// then
21:06:44 <Taggnostr> (well, actually I'm trying to do it in py)
21:07:08 <sjanssen> ah
21:07:27 <dmwit> vixey: In my Sudoku solver, I represent a 2D grid as [Constraint].  type Constraint = (Pos, Val), type Pos = (Int, Int), type Val = Int.
21:07:39 <Taggnostr> what I pasted works for f(n1)(n2)
21:07:53 <dmwit> Taggnostr: Please, spell that "f n1 n2".
21:08:07 <vixey> I saw a really wonderful Sudoku solver once
21:08:08 <Saizan> heh, in py you can easily have the uncurried n-adic version, but the curried seems tricky unless you allow a () at the end
21:08:15 <vixey> it wasn't in haskell though
21:08:32 <vixey> I learned Sudoku just to understand it
21:08:38 <dmwit> heh
21:08:40 <Taggnostr> Saizan, I was thinking to use the ()
21:08:43 <dmwit> vixey: Was it Norvig's?
21:08:47 <vixey> no
21:09:03 <Taggnostr> btw I'm off for breakfast, I will think about it while eating
21:09:07 <vixey> @src Enum
21:09:07 <rahaskella> class  Enum a   where
21:09:07 <rahaskella>     succ                     :: a -> a
21:09:07 <rahaskella>     pred                     :: a -> a
21:09:07 <rahaskella>     toEnum                   :: Int -> a
21:09:07 <rahaskella>     fromEnum                 :: a -> Int
21:09:09 <rahaskella> [3 @more lines]
21:12:30 <Taggnostr> Saizan, maybe I had an idea to do it without the ()! -- back to breakfast
21:17:50 <vixey> what's it called when an amoeba grows outwards?
21:19:03 <nolrai_> > ..
21:19:04 <rahaskella>  Parse error at ".." (column 1)
21:19:11 <vixey> (I'd like to name a function after this proccess)
21:19:22 <nolrai_> > :t (..)
21:19:22 <rahaskella>  Parse error at "..)" (column 5)
21:19:33 <vixey> :t enumFromTo
21:19:33 <nolrai_> :t (..)
21:19:39 <rahaskella> forall a. (Enum a) => a -> a -> [a]
21:19:40 <rahaskella> parse error on input `..'
21:20:04 <vixey> nolrai: [x..y] = enumFromTo x y
21:20:07 <nolrai_> hmm so .. is special sugar?
21:21:07 <dmwit> nolrai_: yes
21:21:17 <vixey> what's the name of the process of a trees roots growing out?
21:21:20 <dmwit> [a,b..c] is also sugar for enumFromThenTo a b c
21:21:24 <dmwit> vixey: Mitosis?
21:21:25 <vixey> (I think that matches my function better than aoemeba growth)
21:21:36 <ddarius> dmwit: No.
21:21:38 <vixey> ahhh mitosis is the word
21:21:47 <dmwit> ddarius: I was referring to the amoeba question.
21:21:47 <ddarius> @wn mitosis
21:21:48 <rahaskella> *** "mitosis" wn "WordNet (r) 2.0"
21:21:48 <rahaskella> mitosis
21:21:48 <rahaskella>      n : cell division in which the nucleus divides into nuclei
21:21:48 <rahaskella>          containing the same number of chromosomes
21:21:51 <dmwit> I was just too late.
21:22:04 <ddarius> dmwit: That's what I thought you were referring to.
21:22:07 <dmwit> um
21:25:16 <dmwit> vixey: Also, branch?
21:26:39 <dolio> Man, loops like 'for (int q = 0;++q < n;p++) ...' are great.
21:27:08 <dmwit> ouch
21:27:21 <dmwit> 1. this iterates n-1 times
21:27:42 <dmwit> 2. the fact that you're keeping p and q in synch in the "for" section suggests some subtle changes to either p or q in the body of the loop
21:27:48 <dolio> for (q = 1; q < n; p++, q++) is too easy.
21:27:57 <dmwit> 3. C(++) =/
21:28:33 <dolio> Not to mention, there are also loops like 'for (q = 0; q++ < n; p++)' mixed in.
21:28:41 <dolio> So pay attention to which one you're in. :)
21:33:21 <dolio> ++++b is cute, too.
21:35:08 <vixey> @src Ix
21:35:09 <rahaskella> class (Ord a) => Ix a where
21:35:09 <rahaskella>     range           :: (a,a) -> [a]
21:35:09 <rahaskella>     index           :: (a,a) -> a -> Int
21:35:09 <rahaskella>     inRange         :: (a,a) -> a -> Bool
21:35:09 <rahaskella>     rangeSize       :: (a,a) -> Int
21:35:22 <dolio> "for (p <<= 1; --b > 1; p <<= 1)  ;" is another good one.
21:35:44 <Taggnostr> my idea doesn't seem to work
21:37:05 <Taggnostr> not yet
21:41:27 <nolrai_> if I have some big structure in a IORef, and then update a part, does it copy the whole thing? i.e. would i gain anything by moving the IORef type contructor into the structure?
21:42:37 <dolio> Yes, it copies the whole thing.
21:42:54 <nolrai_> hmm.
21:45:13 <gwern> > 101 / ((24*5) + 10)
21:45:15 <rahaskella>  0.7769230769230769
21:46:19 <ac> What module is arcsin in?
21:46:28 <edwardk> dolio: feel like wrestling with a quirky morphism i'm trying to generalize?
21:46:29 <dmwit> ?index arcsin
21:46:30 <rahaskella> bzzt
21:46:33 <vixey> :t asin
21:46:36 <rahaskella> forall a. (Floating a) => a -> a
21:46:39 <dmwit> ?index asin
21:46:39 <rahaskella> Prelude
21:46:41 <ac> ah
21:46:58 <dolio> edwardk: I can try.
21:47:13 <dmwit> nolrai_: Don't do it unless you can prove you need to.
21:47:19 <edwardk> one sec, rebuilding so it'll have docs
21:47:43 <dmwit> nolrai_: Remember that it is basically just copying one pointer for each unchanged part of the record.
21:47:45 <edwardk> http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Algebra-Elgot.html
21:48:07 <dmwit> nolrai_: (i.e. it doesn't need to copy the entire value, immutability guarantees that we can just use the old copy of the value.)
21:48:21 <edwardk> my current desired generalization:  g_elgot :: (Comonad w, Functor f) => Dist f w -> GAlgebra f w a -> (b -> Either a (f b)) -> b -> a
21:49:03 <nolrai_> Oh, that makes things reasonable. OK.
21:49:11 <coffeemug> hello
21:49:11 <dmwit> nolrai_: So, "second (const []) ([some big, expensive list], [some other list])" is fast, even though the first list is slow to compute.
21:49:26 <dmwit> Hiya, coffeemug!
21:49:42 <nolrai_> hmm
21:50:20 <edwardk> basically it builds up a structure with the b -> Either a (f b) side of things, then tears it down with the algebra, but it can short circuit the infinite tail returning an answer, that then has to be folded down a finite number of steps with the algebra
21:52:23 <dons> http://reddit.com/info/6jw7n/comments/  interesting
21:52:26 <edwardk> the tricky part is that i need to be able to extract or not based on whether i gave back a value or a comonad, so my first thought was to try to build up a comonad 'E w' off of Either a (w a) that can lift a distributive law for f over w to one for f over E w
21:53:15 <vixey> ^C^C^C^C^C^C^C^CInterrupted.
21:53:15 <vixey> *Main> :l nurikabe
21:53:15 <vixey> InInInterInteIntIIntInterrIInterrupted.
21:53:16 <edwardk> there is also probably something tricky that can be done with callCC
21:53:20 <dibblego> ?hoogle BiFunctor
21:53:20 <rahaskella> No matches found
21:53:34 <edwardk> because you can just shortcircuit with the sub-answers
21:55:21 <edwardk> dolio: does the morphism make sense?
21:55:58 <dolio> Yeah, I think I'm seeing it now.
21:56:05 <twb> Is the hpaste.el maintainer about?  I found a trivial bug.
21:56:19 <edwardk> dolio: i thought it was neat, since it was a recursion pattern not captured by the foo-morphisms
21:56:23 <dolio> f b = Left a is the break out.
21:56:31 <edwardk> yeah
21:56:45 <edwardk> then what you broke out starts falling through the 'a' calls
21:56:52 <dolio> f b = Right (F b) is recurse.
21:58:05 <edwardk> so i figured its almost like a hylomorphism, so what can we do with those? well, we can add (co)monads ;)
21:58:15 <dolio> :)
21:58:25 <edwardk> the trick is that g_elgot is harder than it looks
21:58:38 <edwardk> because you want h to return a comonad, but if you short circuit you don't get one
21:59:27 <edwardk> normally with a ghylo that isn't a problem, there is no shortcircuit path
21:59:36 <edwardk> so you can keep 'reaching' for the comonad forever
22:00:14 <edwardk> the naive answer is to change the b -> Either a (f b) to a b -> Either (w a) (f b)  and make the end user give it to you, but thats cheating ;)
22:00:21 <dolio> What's GAlgebra again? f (w a) -> a?
22:00:25 <edwardk> yeah
22:00:48 <edwardk> it used to be AlgW, but i was running into a ton of half abbreviated names
22:00:52 <edwardk> so i widened them
22:01:36 <edwardk> my brain keeps wanting to pass a pair of  continuations in or something
22:04:29 <edwardk> the other generalization is to throw a monad on the 'b' side, but that one seems a lot easier
22:04:34 <edwardk> the comonad is the interesting one
22:06:36 <Taggnostr> Saizan: http://dpaste.com/51173/
22:06:40 <conal> hey all: new post: http://reddit.com/goto?id=6jw8w
22:06:56 <conal> "What is a derivative, really? Beautiful differentiation, part 2"
22:07:42 <thetallguy> conal: I haven't caught up to the last one yet.
22:08:26 <Heffalump> conal: that's not a post, that's a teaser ;-)
22:08:28 <conal> thetallguy: hurry up!  i have part 3 started.
22:09:19 <conal> the next post will describe my new derivative library
22:09:51 <conal> and part 4 will be some 3D shapes using derivatives for automatic normals (lighting)
22:11:47 <Heffalump> nice
22:15:59 <cjs> Hm...so my clever "withStack" idea in my parser to keep a list of where I am in the parse stack for error reporting purposes turns out to be quite expensive: 25% of the cost of my entire program!
22:15:59 <cjs> Can anybody think of something more efficient than pushing strings on and off a list?
22:15:59 <cjs> Basically, when I'm parsing, I just need to know which particular combinator failed, and how I got there. (As well as of course the failure point in the ByteString.)
22:15:59 <edwardk> hrmm the generalization for the monad case also seems to blow up
22:15:59 <Heffalump> lists should be an efficient stack structure; are you constructing the strings at the time you push them, or are they already built?
22:15:59 <cjs> That's an interesting question, Heffalump.
22:15:59 <edwardk> i need to get the 'Either' out of a m (Either a (f (m b))) but i don't know enough about m to do it
22:15:59 <Heffalump> cjs: although if they aren't demanded unless there is an error, that shouldn't actually matter
22:15:59 <cjs> My calls invariably look like this: 'skipChars n = withStack "skipChars" $ do { assertRemaining n; unsafeSkipChars n }'
22:15:59 <Heffalump> ok, so they are built (being literals)
22:15:59 <Heffalump> what's withStack?
22:15:59 <Heffalump> (the definition)
22:16:06 <dolio> edwardk: I think I'm drawing a blank, too.
22:16:11 <Heffalump> also check that your >>= is being inlined
22:16:50 <edwardk> i am pleased i was able to get the basic elgot stuff in and make sense of it though.
22:17:09 <cjs> Heffalump, http://hpaste.org/7742
22:17:14 <edwardk> i'mm leave the 'cheap' you can give me back a comonadic value stuff in for now
22:17:19 <edwardk> er i'll
22:17:29 <cjs> Heffalump, how do I check that?
22:18:04 <Heffalump> cjs: dunno :-) look at the GHC STG output?
22:18:12 <Heffalump> I would festoon withStack with inline pragmas
22:18:28 <Heffalump> It should be very fast, but I presume it's not being inlined so you're paying a lot for it to be called.
22:18:29 <cjs> Actually, it's 28.8% of 57.2 secs in that version, and if I comment out just the pushStack and popStck, it's 13.0% of 45.84 seconds. So it's still not trivial.
22:18:35 <cjs> "Festoon." I see. :-)
22:19:00 <Heffalump> do x <- action ; return x
22:19:05 <Heffalump> should be the identity function
22:19:19 <Heffalump> so you really must have an inlining problem if that still takes up a lot of time
22:19:26 <cjs> That would make sense.
22:19:33 <Kiago> Sup people
22:19:41 <Heffalump> is this Parsec?
22:19:45 <cjs> BTW, going back to the strings for a sec; that they're constants means that I don' t pay to build them at run time, at least not more than once, right?
22:19:52 <Heffalump> cjs: correct
22:19:54 <cjs> No, it's a parser I built myself.
22:20:07 <cjs> And so that's the stuff that gets allocated under CAF in the profiler output?
22:20:16 <Heffalump> cjs: ok, make sure you annotate your (>>=) with inline pragmas. Check the GHC manual, it describes how to do this for monads, IIRC.
22:20:28 * Kiago was kicked by cjs (THIS IS PARSER)
22:20:37 <Heffalump> cjs: Yeah. I doubt you will even pay for them once unless there is an actual error.
22:21:03 <Heffalump> Kiago: nice try.
22:21:14 <cjs> Right. So it seems, really, that those list operations should be darn quick, the strings are not a problem (never demanded, in this particular program run), and so inlining is about all that's left.
22:21:36 <Heffalump> you should probably get return inlined too, thinking about it.
22:21:46 <qebab> why is it that I wake up four hours early when I have exams :(
22:21:54 * Heffalump disappears
22:23:22 <cjs> Hey, Heffalump, do you think turning on any of the optimization flags for the compiler would help at all?
22:23:27 * cjs kicks himself, hard.
22:23:51 <Kiago> Finding this place online...without really looking at it...and trying to understand whats happening when you have no clue about programing language....is like walking into a brick wall
22:23:55 <Kiago> repeatedly
22:24:18 <cjs> Huh?
22:25:00 <qebab> Kiago: I think that applied mathematicians would like this place, really
22:25:05 <qebab> usually anyway
22:25:34 <vixey> fun one for anyone bored, given a grid with some filled in cells, enumerate every contiguous region of cells growing from that region by order of size (please don't tell me solutions yet, still thinking about it)
22:26:33 <dolio> edwardk: Seems like you need either Distrib (Either a) w or Distrib f (Either a)
22:26:46 <edwardk> dolio: yeah =/
22:27:12 <edwardk> i was playing around with what i could get from my comonadic costrength post
22:27:52 <Kiago> anyone know any RPG servers/chans.....or know where i can look.?
22:28:36 <edwardk> dolio: because mapM{Either a}  id :: Traversable f => f (Either a b) -> Either a (f b)
22:28:51 <edwardk> dolio: so we could limit us to traversable monads or something
22:28:56 <cjs> This is weird; withStack is still killing me. Could it be because it's also done 46.9% of the memory allocations in this program?
22:30:28 <dolio> edwardk: I might be inclined to look for Dist (Either a) w because the ordinary one doesn't require interaction between f and Either a.
22:30:54 <edwardk> in any event my current g_(co)elgot versions kinda suck, since they aren't g_ eneral enough. they only rederive the normal case by accident
22:31:06 <edwardk> (because identity is so well behaved)
22:32:11 <dolio> Although, what does that mean?
22:32:20 <dolio> You can pull context out of thin air, I guess? :)
22:32:30 <edwardk> yeah
22:32:45 <edwardk> identity lets you just throw an Identity there and poof a star is born ;)
22:33:23 <dolio> What's the signature for costrength?
22:34:24 <edwardk> mapM{Either a}  id :: Traversable f => f (Either a b) -> Either a (f b)  - but that would probably only work for g_coelgot
22:34:53 <dolio> Yeah, that's the reverse of what you'd want.
22:35:34 <edwardk> costrength :: Traversable f => f (Either a b) = Either (f a) b -- is what i have if i follow the standard CT argument order, but thats just flipped, not the contrapositive
22:35:55 <edwardk> er converse
22:36:34 <dolio> strength is (a, m b) -> m (a, b)?
22:36:37 <edwardk> at this point i'm just fitting the pieces together like puzzle pieces and trying to see what it doesn't work.
22:36:56 <edwardk> yeah
22:37:02 <Heffalump> cjs: :-) re optimisations
22:37:08 <edwardk> every functor in haskell is strong,
22:37:11 <Heffalump> and I think allocations would be very bad, inlining should remove them..
22:37:18 <Heffalump> well except for the (:) cell
22:37:59 <dolio> Clearly what we need are weak and coweak functors. :)
22:38:05 <edwardk> heh
22:39:59 <cjs> Hm. Adding INLINE pragmas to both the bind/return on my parser monad and to withStick itself seems to have made little difference.
22:40:37 <edwardk> i _think_ that it is imposible to do what we want because one of the comonads we could want to insert would be the cofree comonad
22:40:54 <edwardk> and that would want to be able to see down to the bottom of the computed result if it chose, but we cut it off.
22:41:50 <cjs> Taking out the push and pop gives me almost a 40% improvement in performance.
22:42:17 <cjs> So that's the real killer. I wonder what to do about that?
22:45:35 <vixey> cjs: is it actually slowing things down so much that you can't ignore it though?
22:45:52 <vixey> I mean is it taking like 2 seconds or 15 mins?
22:46:22 <cjs> It's painful. On just the first hour of a trading day, the analysis bloats from about 16s to almost 30s. And a full trading day is six hours and a bit.
22:46:32 <vixey> ohh I see
22:46:42 <cjs> So spending an hour or two on fixing this, if that's possible, is certainly worthwhile.
22:47:03 <cjs> And in the long run, when the actual trading app goes into production, we certainly have uses for that extra CPU.
22:48:05 <cjs> Hm. So anyway, with -O2, festooning with inlines makes little or no difference. (Maybe a second or so out of 30.) So the optimizer appears to be doing its job as far as inlining is concerned, anyway.
22:48:15 <newsham> ?bot
22:48:16 <rahaskella> :)
22:51:47 <cjs> So I'm just wondering if there's some way I can get this effect of knowing where I am in my tree of combinator calls when an error occurs without keeping this list of Strings that I'm keeping.
22:53:21 <cjs> Anyway, I suppose that the cheerful side of this is that my parser's so damn efficient that this overshadows it. :-)
22:55:46 <cjs> Like, perhaps I could have a fixed, constant set of lists, and just swap those in and out rather than building and unbuidling the lists all the time.
22:56:01 <cjs> Or build them once, and then re-use them as needed.
22:56:04 <cjs> Hmmm.
22:57:13 <tieTYT2> i'm very new here.  Why are type constructors and value constructors named differently?
22:57:25 <tieTYT2> like in java, when you define a class of X, you name its constructor X
22:57:43 <sjanssen> tieTYT2: a type may have more than one data constructor
22:57:49 <sjanssen> @source Bool
22:57:50 <rahaskella> Bool not available
22:58:01 <sjanssen> data Bool = False | True
22:58:08 <tieTYT2> ah I see
22:58:09 <cjs> tieTYT2, did you mean why are type names and their constructors named differently?
22:58:37 <cjs> If that answered your question, yes you did. :-)
22:58:42 <tieTYT2> so False and True are type constructors?
22:58:50 <nolrai_> no
22:58:51 <cjs> No, they construct values of type Bool.
22:58:55 <nolrai_> Bool is
22:59:02 <tieTYT2> sorry i meant value constructors
22:59:17 <nolrai_> (sort of)
22:59:26 <tieTYT2> hrm
22:59:44 <tieTYT2> @source False
22:59:44 <rahaskella> False not available
23:00:05 <tieTYT2> checked in ghci
23:00:31 <tieTYT2> ok thanks
23:01:08 <dibblego> ?instances Monad
23:01:09 <rahaskella> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:02:41 <thoughtpolice> if i wanted to represent a 2d-grid, like in a tetris game, what would probably be the easiest way to do it?
23:03:26 <Zao> thoughtpolice: [[Block]] or Array (Int,Int) Block, probably.
23:04:05 <Foloex> Hello World !
23:06:00 <Foloex> > :t union
23:06:01 <rahaskella>   parse error on input `:'
23:06:06 <Foloex> ?t union
23:06:07 <rahaskella> Maybe you meant: tell temp thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
23:06:12 <Foloex> :t union
23:06:16 <rahaskella> forall a. (Eq a) => [a] -> [a] -> [a]
23:06:34 <Foloex> > union [1,1,2] [2,3,4]
23:06:37 <rahaskella>  [1,1,2,3,4]
23:07:58 <Foloex> > (union [1,1,2] [2,3,4]) \\ [1..9]
23:08:01 <rahaskella>  [1]
23:08:15 <Foloex> > [1..9]
23:08:17 <rahaskella>  [1,2,3,4,5,6,7,8,9]
23:08:19 <tieTYT2> ah, the book later said it's normal to name the type/value constructor the same thing
23:08:47 <dibblego> tieTYT2, for a newtype perhaps?
23:09:09 <dibblego> tieTYT2, or in a data declaration with one constructor (since otherwise, trhe name distinguishes them)
23:09:12 <tieTYT2> ie: data Book = Book String
23:09:23 <dibblego> ah right
23:09:27 <Foloex> > ((union [1,1,2] [2,3,4]) \\ [1..9]) \\ union [1,1,2] [2,3,4]
23:09:29 <rahaskella>  []
23:09:29 <tieTYT2> actually that's not valid..
23:09:39 <dibblego> sure it is
23:09:46 <tieTYT2> i just tried it in GHCI
23:09:48 <Foloex> > union [1,1,2] [2,3,4] \\ ((union [1,1,2] [2,3,4]) \\ [1..9])
23:09:51 <rahaskella>  [1,2,3,4]
23:09:55 <dibblego> you can't use data declarations in ghci
23:10:03 <tieTYT2> oh
23:10:08 <dibblego> put it in a file and use :load File.hs
23:10:08 <tieTYT2> that explains it
23:11:08 <tieTYT2> i also can't do something like x = 1 ?
23:11:15 <tieTYT2> i thought i saw examples doing that earlier
23:11:49 <dibblego> let x = 1
23:11:56 <tieTYT2> oh right
23:11:58 <dibblego> or put x = 1 in a file
23:12:09 <tieTYT2> i hope there's a really good reason i need to do that
23:12:21 <tieTYT2> because i believe the book said that let x = 1 like that isn't normal haskell
23:12:35 <tieTYT2> like if i put that in a random place in a .hs file it won't work
23:12:37 <dibblego> I hope the book didn't say that ;)
23:13:01 <dibblego> not in a random place, no, but in certain places, sure
23:13:18 <tieTYT2> yeah i know in certain places it's valid
23:13:30 <tieTYT2> do you know why ghci doesn't let me say: x = 1 ?
23:13:37 <tieTYT2> where's the confusion there
23:13:43 <dibblego> effectively because it's in IO
23:14:09 <dibblego> to prevent these cases, I recommend using a source file then finding out why ghci is a little different later
23:14:27 <tieTYT2> are there a lot of cases like this?
23:14:44 <dibblego> significantly less than the hundreds in Java ;)
23:14:52 <tieTYT2> ok, thanks
23:14:54 <dibblego> it actually makes sense
23:15:13 <dibblego> it's just why that you needn't concern yourself with right now I expect
23:15:22 <sjanssen> tieTYT2: ghci takes expressions only, "x = 1" isn't an expression
23:15:27 <dibblego> unlike Java, you wouldn't say "it is a hack"
23:16:01 <sjanssen> (actually it allows do-syntax statements in the IO monad as well, but we'll ignore that for now)
23:17:18 <nolrai_> ^^^ thats why let x = 1 works
23:20:09 <dmwit> ?src union
23:20:09 <rahaskella> union = unionBy (==)
23:20:57 <dmwit> > union (nub [1, 1, 2]) (nub [2, 3, 4]) -- Foloex, maybe you wanted something like this?
23:20:59 <rahaskella>  [1,2,3,4]
23:22:28 <Foloex> > [1..9] !! 8
23:22:30 <rahaskella>  9
23:23:07 <dmwit> > [0..9] !! 8
23:23:10 <rahaskella>  8
23:23:21 <dmwit> It's zero-indexed. ;-)
23:24:40 <dmwit> > union [1,1,2] [2,3,3]
23:24:42 <rahaskella>  [1,1,2,3]
23:24:52 <dmwit> ...what
23:24:56 <dmwit> ?src unionBy
23:24:57 <rahaskella> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
23:25:10 <dmwit> That's... that's asymmetric! =/
23:27:46 <dmwit> Whoa, three articles about Haskell on the Erlang VM up on proggit right now.
23:30:07 <solrize_> you can do that????
23:30:21 <dmwit> What can I do?
23:30:25 <solrize_> i mean, how do they handle lazy evaluation
23:30:35 <solrize_> you can do that -> run haskell on erlang jvm
23:30:36 <solrize_> vm
23:30:40 <solrize_> freudian slip :)
23:30:44 <dmwit> With thunks, I guess, just like running it on the i386 VM. ;-)
23:30:56 <solrize_> gack!!!
23:31:18 <solrize_> i mean the x86 thunks self-mutate
23:31:25 <solrize_> which erlang values presumably can't
23:31:56 <sjanssen> solrize_: yes, this is right
23:32:17 <solrize_> i've been wondering for a while whether it's feasible to run a haskell-like language on the hedgehog lisp interpreter vm
23:32:25 <solrize_> sjanssen what do you mean?
23:32:27 <dmwit> http://www.haskell.org/haskellwiki/Yhc/Erlang/Proof_of_concept#Lazy_computations
23:32:57 <sjanssen> solrize_: the Erlang implementation doesn't implement laziness, but it does implement non-strict semantics (which is all Haskell requires)
23:33:46 <sjanssen> of course all other known Haskell systems use lazy evaluation more-or-less
23:33:49 <solrize_> ic, it's basically call by name with some strictness analysis to avoid some redundancy
23:34:09 <solrize_> i wonder how much monadic haskell code will break because it expects lazy evaluation
23:34:26 <sjanssen> solrize_: umm, none?
23:34:44 <sjanssen> the only thing I see having trouble is lazy IO -- which is an ugly hack anyway
23:35:18 <sjanssen> the big issue here is the performance implications
23:35:20 <dibblego> ?type liftM2 id
23:35:24 <rahaskella> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
23:35:34 <solrize_> sjanssen lazy io is what i had in mind
23:35:35 <dmwit> liftM2 id = ap?
23:35:38 <dmwit> :t ap
23:35:39 <dibblego> yes
23:35:41 <vixey> @src ap
23:35:41 <rahaskella> ap = liftM2 id
23:35:42 <rahaskella> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:36:18 <solrize_> the proof of concept page is interesting
23:36:21 <sjanssen> hmm, Erlang could use processes to simulate real thunks
23:37:01 <nolrai_> @pl f g h x = (g x, h x)
23:37:02 <rahaskella> f = liftM2 (,)
23:37:04 <sjanssen> each thunk is a process that accepts a message "eval" with a callback argument
23:37:11 <solrize_> wow yeah
23:37:14 <sjanssen> this is probably grossly inefficient
23:37:27 <solrize_> yeah, but super cheap processes is an erlang point of pride
23:37:50 <olsner> i.e. an excellent exercise for the erlang VM optimizers :P
23:37:51 <solrize_> maybe once memoized they could merge into other processes somehow
23:38:07 * sjanssen thinks Erlang's single assignment insistence is crap since side effects between processes aren't regulated at all
23:38:34 <solrize_> side effects between processes?
23:38:37 <sjanssen> hmm, when are Erlang processes garbage collected?
23:39:02 <sjanssen> solrize_: all code can send side messages to other processes
23:39:23 <solrize_> hmm, they are owned by supervisor processes and i guess they are collected by the supervisor's gc?
23:39:27 <sjanssen> making it trivial to emulate mutable variables in the way I've described
23:39:35 <sjanssen> solrize_: yes, but when?
23:39:47 <solrize_> after they exit they become reclaimable
23:39:52 <sjanssen> for my thunk idea to work, we need the process to terminate when there are no more references to it
23:39:53 <solrize_> processes can have local state
23:40:11 <solrize_> omg yeah i see what you mean
23:40:12 <nolrai_> :t ((+1),(*2)) <*>
23:40:16 <rahaskella> parse error (possibly incorrect indentation)
23:40:22 <solrize_> there would have to be cross process gc tracing
23:40:31 <solrize_> which sort of defeats the erlang philosophy
23:40:33 <nolrai_> :t (((+1),(*2)) <*>)
23:40:37 <rahaskella> forall a a1. (Monoid a, Num a1, Num a) => (a -> a, a1) -> (a -> a, a1)
23:40:53 <sjanssen> Erlang is a really poor choice to run Haskell, sadly :(
23:41:11 <nolrai_> hmm, thats not the type i want.
23:41:14 <nolrai_> :t (((+1),(*2)) <$>)
23:41:18 <rahaskella>     Couldn't match expected type `a -> b'
23:41:18 <rahaskella>            against inferred type `(a1 -> a1, a2 -> a2)'
23:41:18 <rahaskella>     In the first argument of `(<$>)', namely `((+ 1), (* 2))'
23:42:00 <solrize_> erlang (the language itself) looks kind of primitive from what i've seen, even if the implementation is super robust
23:42:32 <nolrai_> @pl \(g,h) x -> (g x, h x)
23:42:33 <rahaskella> uncurry (liftM2 (,))
23:43:11 <dmwit> :t uncurry (&&&)
23:43:14 <rahaskella> forall (a :: * -> * -> *) b c c'. (Arrow a) => (a b c, a b c') -> a b (c, c')
23:43:53 <dmwit> nolrai_: You just can't beat Arrows for (,) manipulations. ;-)
23:44:08 <tieTYT2> :t is short for :type ?
23:44:11 <rahaskella> parse error on input `type'
23:44:21 <solrize_> there's an #erlang channel with lots of idlers
23:44:22 <dmwit> tieTYT2: In ghci, yes; here on #haskell, it's short for ?type.
23:45:01 <sjanssen> dmwit: these multiple reddit postings are annoying -- which one should I comment on?!
23:45:15 <nolrai_> > ((+1) &&& (*2)) 3
23:45:18 <rahaskella>  (4,6)
23:45:25 <dmwit> sjanssen: YEAH!  No fair, dividing our votes like that!
23:45:25 <nolrai_> coolness
23:45:29 <sjanssen> I wish reddit would give an exact submission timestamp so I could be fair and comment on the first one
23:45:45 <nolrai_> dmwit++
23:46:03 <dmwit> sjanssen: As it is, it's probably best to just comment on the most popular one at the moment.
23:46:05 <dibblego> speaking of arrows, I was reading a paper that gave the first definition for -> as f x id, what does the x mean?
23:46:16 <dibblego> ?src first (->)
23:46:17 <rahaskella> Source not found. I am sorry.
23:46:30 <dmwit> :t first
23:46:34 <rahaskella> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
23:46:40 <sjanssen> dmwit: so http://reddit.com/r/programming/info/6jwbu/comments/ is out, because of grammar
23:46:56 <sjanssen> c'mon "Execution Haskell programs", what is this, amateur hour?
23:47:06 <dmwit> heh
23:47:34 <sjanssen> dons has the snappiest title, I'll go with his
23:50:15 <Pseudonym> sjanssen: I've heard "Execution program" before.  I think it's a transliteration from some language or other.
23:50:31 <olsner> sounds french
23:50:37 <Pseudonym> Maybe.
23:50:38 <sjanssen> Pseudonym: ah, perhaps
23:51:22 <Pseudonym> Quebecois, perhaps./
23:52:37 <nolrai_> * bangs head against gtk2hs docs
23:57:22 <dolio> @yow!
23:57:23 <rahaskella> I'm having a MID-WEEK CRISIS!
23:57:57 <nolrai_> on Sunday?
23:59:40 <dolio> Well, I've got a smooth sort that doesn't segfault.
