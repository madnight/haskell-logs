00:00:13 <ddarius> Armored_Azrael: What you need to do is use an MVar to communicate the result.
00:00:49 <Armored_Azrael> OK.
00:01:51 <edwardk> ddarius: just checking my sanity on something real quick. if we take our ealier definition data Coend f = forall i. Coend { runCoend :: f i i }. and we define LanT g h a b b' = LanT { (g m -> a, h m') } then Lan g h a = Coend (LanT g h a) is the derivation of Lan through the interpretation of (left) kan extensions as (co)ends right?
00:02:07 <edwardk> er s/b b'/m m'
00:02:49 <ddarius> parMapM f xs = mapM (\x -> do mvar <- newEmptyMVar; forkIO (f x >>= putMVar mvar); return mvar) xs >>= mapM takeMVar
00:03:06 <ddarius> Something like that and I probably misremember the function names/which to use.
00:03:21 <cjs> Trinithis, yes, I get that pretty well, and use it myself. I guess it's just in this case it didn't really strike me as being more "intentful."
00:03:22 <Armored_Azrael> thanks
00:03:36 <Trinithis> ;D
00:03:43 <cjs> What are typical uses of fmap, other than lists?
00:04:01 <Trinithis> fmap (+1) Nothing
00:04:13 <ddarius> cjs: It's used constantly in many guises.
00:04:14 <Trinithis> > fmap (+1) $ Just 5
00:04:15 <lambdabot>  Just 6
00:04:17 <roconnor> >  fmap (+1) Nothing
00:04:18 <lambdabot>  Nothing
00:04:46 <dobblego> cjs, the pattern that fmap represents is absolutely everywhere; whether it is written explicitly with fmap or not is another matter (especially in imperative languages)
00:04:47 <edwardk> cjs: lifting an operation into IO so you can use it on a file you just slurped in
00:04:52 <Trinithis> > fmap (+1) (2,3)
00:04:53 <lambdabot>  (2,4)
00:05:15 <roconnor> > ((+1) `fmap` (*2)) 3
00:05:17 <lambdabot>  7
00:06:07 <Trinithis> (fmap for functions is (.))
00:06:27 <Trinithis> and in this case, the Hugs definition makes more sense
00:07:53 <cjs> So is "applies f to whatever's 'in' the Functor" a reasonable intuition?
00:08:10 <edwardk> cjs: a great intuition
00:08:11 <Trinithis> quite reasonable
00:08:31 <solrize_> pretty good, though functors aren't containers
00:08:45 <ddarius> edwardk: Yes.  Lan_J D(A) = Int^X Hom(JX^-,A) (x) DX^+
00:08:47 <cjs> Now if someone could have just said that two months ago, instead of making me go read all this Prelude source, find examples of use, muck about with it....
00:08:50 <edwardk> true, but that intution can still carry you pretty far.
00:09:05 <solrize_> cjs, you should read the haskell wikibook article on category theory.  it demystifies this stuff.
00:09:16 <edwardk> ddarius: thought so just wanted to make sure that i had the derivation right
00:09:50 <edwardk> was going to drop that definition in as a comment along side my definition for Lan in the kan extension module
00:10:27 <edwardk> i won't actually USE it coz it requires an extra constructor to be dereferenced (damn the inability to use existential quantification over newtypes!) but still ;)
00:10:35 <ddarius> "RanT" would be RanT j d a x x' = (a -> j x) -> d x'
00:10:44 <edwardk> yeah i got that one too
00:11:08 * ddarius wonders where his Pink Pearl is.
00:11:20 <Trinithis> 'night
00:11:28 <cjs> solrize_, I suppose I could, but at a quick glance it doesn't look as if it will help me. I've read a fair amount about category theory already.
00:11:46 <cjs> Mostly I'm trying to figure out how it applies to program organization.
00:12:02 <wolgo> mult = \x y = x * y
00:12:27 <Deewiant> s/y =/y ->/
00:12:43 <wolgo> oh shit
00:15:20 <solrize_> cjs well it explains how fmap relates to functors...
00:15:49 <wolgo> Hey why does this work in ghci with let but not in my source file: mult = \x -> ( \y -> x * y)
00:16:18 <edwardk> > let mult = (*) in mult 3 2
00:16:20 <lambdabot>  6
00:16:21 <Deewiant> everything you put in ghci is in one big 'do' block
00:16:49 <cjs> solrize_, I may even get that. The question for me is, what do you *do* with the darn things?
00:16:52 <Deewiant> at the top level, you can't use 'let', whereas in a 'do' block, you need to, for such definitions.
00:17:32 <edwardk> wolgo: ghci is like you are 'executing the body of main', one big IO () action. each line in that is another line in a do block, as deewiant said.
00:17:43 <wolgo> I define it in my .hs as seen above, sans let. Only 5 * 1, 6 * 1 works though
00:17:49 <edwardk> this is why you can't define data types in ghci ( they don't make sense locally in a do block)
00:18:13 <solrize_> cjs, you mean functors?  i guess i don't know many interesting ones in haskell that aren't monads
00:18:20 * wolgo prepares to read and re-read the section on currying and lambda
00:18:36 <edwardk> solrize: sure there are there is (,)e.  =) thats a comonad =)
00:19:02 <solrize_> edwark, have you seen the book "conceptual mathematics" by lawvere and schanuel?  is it good?
00:19:27 <edwardk> solrize: they make good containers. if you don't have a good way to fold containers of containers you probably have a functor that isn't a monad.
00:19:36 <edwardk> never read it
00:20:01 <solrize_> hmm
00:20:19 <edwardk> ordering it now, but hadn't before =)
00:20:24 <ddarius> Almost every (parameterized) data type in Haskell is a functor.
00:20:34 <cjs> Control.Applicative actually defines a synonym for fmap: <$>
00:20:37 <ddarius> Certainly all the polynomial ones are.
00:20:50 <solrize_> http://ls.poly.edu/~jbain/Cat/index.htm  this looks interesting
00:20:50 <lambdabot> Title: Conceptual Mathematics Homepage
00:21:06 <solrize_> you're ordering it already???  wow, let me know how it is :)
00:21:14 <edwardk> its only when the parameter occurs on the left hand side of an odd number of (->)'s that it gets problematic
00:21:28 <ddarius> I haven't read it, but I don't think edwardk is in the target demographic.
00:21:39 <edwardk> i'm skimming it on google right now
00:21:44 <solrize_> lawvere is the guy who recast logic in terms of categories
00:21:52 <solrize_> topoi
00:22:00 <ddarius> solrize_: Among many other things (and not alone)
00:22:19 <edwardk> it does come across a bit hand wavy
00:22:33 <ddarius> edwardk: I suspect you'd find it too "low level"
00:22:41 <edwardk> yeah
00:23:36 <edwardk> i had skimmed the index by the time i had made the earlier comment. once i got into the contents i decided i probably won't be making that purchase =)
00:23:43 <solrize_> hehe
00:25:29 <solrize_> i hadn't realized the ToC was online
00:25:31 <solrize_> looking at it now
00:28:23 <cjs> Ah, so the point of ((,) a) being a Functor is to have a handy map for the values of an associative list?
00:28:48 <wolgo> So, \ is a lambda, \x is a lambda with argument x it seems.
00:28:56 <wolgo> I had things totally wrong
00:29:07 <[Justice]> correct
00:29:22 <edwardk> wolgo: yeah the \ is used as lambda because it looks kinda like the long 'bar' of the lambda.
00:29:47 <solrize_> http://www.math.ucr.edu/home/baez/topos.html
00:29:48 <lambdabot> Title: topos
00:30:02 <edwardk> cjs: actually the reason (,)e is a functor has to do with deeper category theory bits about the adjointness of hom and prod.
00:30:17 <wolgo> The reason we can use mult x y z is because mult is assigned the lambdas \x -> \y -> \z x * y * z
00:30:19 <wolgo> man
00:30:36 * wolgo feels less than intelligent at times
00:30:38 <[Justice]> addTwoNums = \ x -> \ y -> x + y
00:30:47 <edwardk> (,)e is left adjoint to (->)e -- and as usual in haskell its a Functor because well, the types just work ;)
00:31:14 <wolgo> Things are coming together slowly but surely
00:31:17 <cjs> Oh.
00:31:34 <edwardk> wolgo: hey the important part is you're making the effort and learning these things.
00:31:52 <wolgo> mult = \x -> ( \y -> x * y) demonstrates currying since there is partial application no?
00:32:03 <edwardk> wolgo: after a couple of years of haskell most other languages look like toys.
00:32:13 <edwardk> wolgo: yeah
00:32:27 <wolgo> two birds with one stone
00:32:28 <wolgo> :)
00:32:31 <edwardk> in fact Haskell takes the mult x y = x * y definition and turns it into that definition basically.
00:32:48 <[Justice]> there is always partial application (currying) for all functions
00:32:52 <cjs> Hm. Anybody got any particular clever day-to-day-handy applications of fmap? Or should I just move on to Monoids for an example or two?
00:33:35 <[Justice]> multByTwo = (\ x -> \ y -> x * y) 2
00:33:43 <[Justice]> demonstrates partial application
00:35:10 <cjs> Or "add1 = (+) 1".
00:35:41 <cjs> The typical examples of day-to-day use of partial application would be things such as
00:35:48 <wolgo> Ok, this really opens up things :) lzipper = \(x:xs) -> \(y:ys) -> (x,y) : lzipper xs ys
00:35:52 <cjs> > let doubleL = map (*2)
00:35:53 <lambdabot>  Parse error at end of input
00:35:59 <wolgo> I like this.
00:36:08 <cjs> Hm?
00:36:13 <cjs> > doubleL = map (*2)
00:36:13 <lambdabot>  Parse error at "=" (column 9)
00:36:30 <wolgo> > let doubleL = map (*2)
00:36:30 <lambdabot>  Parse error at end of input
00:36:30 <cjs> > let doubleL = map (*2) in doubleL [2,3,4]
00:36:31 <solrize_> i saw something pretty cute with fmap recently, it does get used in real code, i just don't remember exactly where
00:36:33 <lambdabot>  [4,6,8]
00:36:40 <dolio> @type fmap fmap fmap
00:36:41 <[Justice]> > let doubleL = map (* 2) in doubleL
00:36:43 <lambdabot>  Add a type signature
00:36:43 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
00:36:53 <wolgo> that is partial application
00:37:00 <cjs> Lambdabot really doesn't like me today.
00:37:02 <wolgo> section
00:37:02 <cjs> @vixen
00:37:02 <lambdabot> what are you
00:37:19 <edwardk> wolgo: yeah though you have to be careful coz the \ foo -> syntax doesn't do multiple patterns. so you need to use case statements to fully encode the rest of what you can do with the foo [] = ...; foo (x:xs) = ... syntax.
00:38:02 <wolgo> oh ok
00:38:14 <wolgo> so (x:y:ys) doesnt work?
00:38:16 <edwardk> cjs: about 20% of the executable lines in category-extras use fmap in wildly different contexts.
00:38:30 <edwardk> (x:y:ys) works. as long as you have an infinite list. what do you do when the pattern fails?
00:38:52 <cjs> You hope to heck you caught it with a different pattern before it hit that one. :-)
00:38:57 <[Justice]> deleteSecond = \ (x : y : ys) -> x : ys
00:39:02 <[Justice]> that will work
00:39:06 <wolgo> Oh yeah this throws an exception
00:39:19 <edwardk> hence the existence of case
00:39:24 <[Justice]> but if you try: deleteSecond [1] ... error
00:39:33 <wolgo> So do I have to say lzipper [] y = []?
00:39:41 <wolgo> and lzipper x [] = []
00:39:49 <wolgo> wait
00:40:01 <wolgo> it doesn't support multiple patterns so I cant do that
00:40:09 <wolgo> so I have to use | or case?
00:40:20 <wolgo> So that means it is best to not do that?
00:40:36 <edwardk> wolgo: lambdas are useful but they aren't the whole story.
00:40:50 <wolgo> Okay
00:40:55 <wolgo> That is good information.
00:41:01 <edwardk> wolgo: | doesn't solve it either, because you can't put one in a lambda the way you'd want
00:41:14 <[Justice]> the lambda-expression form is fairly primitive, and its useful when you have small functions without pattern matching
00:41:32 <edwardk> wolgo: but lzipper = \x -> case x of (a:as) -> ...; [] -> ... works
00:41:52 <edwardk> but its clunkier than the 'prolog style' declarative lzippper (a:as) = ...; lzipper [] = ...
00:42:08 <wolgo> Ahh I see
00:42:12 <edwardk> you tend to use lambdas when the definition is small enough that its not worth naming
00:42:21 <[Justice]> higher-level forms of expressing functions are compiled down to lambda-expressions internally as an intermediate stage
00:42:29 <wolgo> so I have a bunch of ridiculous foreplay as opposed to something that is more straightforward
00:42:36 <wolgo> wow
00:42:41 <edwardk> the compiler takes both definitions and internally munges them into the same form, so the surface syntax is more complicated but inside its all lambdas and cases anyways
00:42:49 <wolgo> that was not the analogy I wanted to think of
00:42:59 <wolgo> Oh okay
00:43:22 <edwardk> it is good to see that these things are all the same though. it gives you options for how you want to structure your code.
00:44:04 <edwardk> i.e. sometimes i use pointfree when it helps me make a point, sometimes lambdas if its small, sometimes 'prolog style' multiple declarations, etc.
00:44:19 <wolgo> what is prolog style?>
00:44:31 <wolgo> Oh wait that is that AI language right?
00:44:33 <edwardk> wolgo: the lzipper (x:xs) = ...
00:44:36 <edwardk> lzipper [] = ...
00:44:41 <wolgo> oh ok
00:45:02 <edwardk> that 'declarative' specification style that seems to alien to c programmers
00:45:12 <wolgo> @src zip
00:45:12 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
00:45:12 <lambdabot> zip _      _      = []
00:45:21 <edwardk> yeah
00:45:41 <edwardk> @src zipWith
00:45:41 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
00:45:41 <lambdabot> zipWith _ _      _      = []
00:45:57 <wolgo> @ty zipWith
00:45:59 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
00:46:09 <wolgo> oh yeah it takes a function
00:46:11 <edwardk> @ty zipWith (,)
00:46:13 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
00:46:39 <wolgo> (,) is a functor?
00:46:43 <edwardk> @ty zipWith (\a b -> (a, b))
00:46:44 <wolgo> or a tuple?
00:46:44 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
00:46:45 <Deewiant> > (,) 1 2
00:46:46 <lambdabot>  (1,2)
00:46:54 <edwardk> > (+) 1 2
00:46:55 <lambdabot>  3
00:47:12 <[Justice]> :kind (,,,,,,,)
00:47:16 <wolgo> @go functor haskell
00:47:17 <lambdabot> http://www.ninebynine.org/Software/Learning-Haskell-Notes.html
00:47:17 <lambdabot> Title: Learning Haskell Notes
00:47:18 <edwardk> you can surround infix functions with parentheses to make 'sections'. turning an infix function into a prefix function.
00:47:32 <[Justice]> does lambdabot do :kind?
00:47:47 <edwardk> (,) is a 'constructor' for tuples. constructors that aren't fully applied act like functions
00:47:58 <edwardk> when they are 'full' you can't use them as functions any more
00:48:09 <Deewiant> ?kind (,,,,,,,)
00:48:10 <edwardk> > (,) 1 2
00:48:11 <lambdabot> * -> * -> * -> * -> * -> * -> * -> * -> *
00:48:12 <lambdabot>  (1,2)
00:48:14 <edwardk> > (,) 1 2 3
00:48:15 <lambdabot>  Couldn't match expected type `t1 -> t'
00:48:18 <[Justice]> ty
00:48:24 <edwardk> @ty (,) 1
00:48:26 <lambdabot> forall t b. (Num t) => b -> (t, b)
00:48:27 <Deewiant> > (,,) 1 2 3
00:48:28 <lambdabot>  (1,2,3)
00:49:08 <[Justice]> ?kind (,(,),(,,),(,(,)))
00:49:09 <lambdabot> parse error on input `('
00:49:16 <Deewiant> > (((,).).(,)) 1 2 3
00:49:17 <lambdabot>  ((1,2),3)
00:49:32 <wolgo> > (,,(,) 1 2 3
00:49:32 <lambdabot> Unbalanced parentheses
00:49:36 <wolgo> > (,,(,)) 1 2 3
00:49:37 <lambdabot>  Parse error at "(,))" (column 4)
00:49:41 <wolgo> haah
00:49:42 <wolgo> > (,,(,)) 1 2 3 4
00:49:43 <lambdabot>  Parse error at "(,))" (column 4)
00:49:54 <Deewiant> > ((.(,)).(.).(,)) 1 2 3
00:49:55 <lambdabot>  (1,(2,3))
00:49:58 <edwardk> you cant use that in a section QUITe that way but you have the general idea.
00:50:19 <wolgo> oh you are composing them
00:50:32 <wolgo> wtf Deewiant
00:50:32 <wolgo> hahah
00:50:39 <Deewiant> @unpl ((.(,)).(.).(,))
00:50:39 <lambdabot> (\ g m d -> ((,)) g (((,)) m d))
00:50:41 <newsham> ?type (1, Just (2, Just (3, Nothing)))
00:50:43 <lambdabot> forall t t1 t2 a. (Num t2, Num t1, Num t) => (t, Maybe (t1, Maybe (t2, Maybe a)))
00:50:54 <Deewiant> @unpl (((,).).(,))
00:50:54 <lambdabot> (\ d g -> ((,)) (((,)) d g))
00:51:26 <wolgo> Oh I see how that works
00:51:28 * edwardk feels like his vision has gone blurry for some reason (((,))) (((,)))
00:51:35 <newsham> ?pl \a b c -> (a, Just (b, Just (c, Nothing)))
00:51:35 <lambdabot> (. ((Just .) . (. (Just . flip (,) Nothing)) . (,))) . (.) . (,)
00:51:48 <wolgo> heheeehhe
00:52:09 * wolgo is going to force himself to watch the movie he rented now
00:52:21 <wolgo> I keep saying I am going to watch this movie
00:52:27 <wolgo> It is 1:00AM now
00:52:32 <wolgo> ...
00:52:42 <skorpan> what movie?
00:53:04 <wolgo> the tripper
00:53:24 <wolgo> It is some type of horror movie
00:53:33 * wolgo is a fan of horror
00:53:43 <wolgo> well, horror movies at least
00:54:11 <wolgo> BRB MOVIE!
00:54:23 <skorpan> david arquette AND courteney cox?
01:34:38 <tieTYT> why won't this compile: append :: [a] -> [a] -> [a]
01:34:42 <tieTYT> append (x:xs) y = x : append(xs y)
01:35:05 <dolio> append(xs y) is wrong.
01:35:13 <tieTYT> what's wrong about it?
01:35:22 <dolio> That says that you should apply the function xs to the value y, and then apply append to the result.
01:35:36 <tieTYT> oh
01:36:10 <tieTYT> ok thanks
01:36:20 * dolio mutters about people calling for yet-more-monomorphism.
01:36:47 <cjs> Hm. We need  a ghci command that can take an hpaste URL and load the module contained in it.
01:37:11 <tieTYT> hm
01:37:13 <tieTYT> i wrote append
01:37:16 <tieTYT> but i didn't expect to
01:37:21 <tieTYT> thought this would break
01:50:19 <tieTYT> i'm trying to write myConcat, but I can't figure out how to pattern match on nested lists
01:50:46 <tieTYT> this doesn't seem to work: myConcat [[(x:xs)]] = x : myConcat xs
01:50:59 <tieTYT> Occurs check: cannot construct the infinite type: a = [a] When generalising the type(s) for `myConcat'
01:51:50 <jmg_> hi everyone
01:52:25 <dobblego> hello jmg_, how are things?
01:53:05 <dobblego> tieTYT, that pattern matching works, but the types do not align
01:53:18 <dobblego> [[(x:xs)]] is of type [[[X]]]
01:53:39 <tieTYT> this still fails: myConcat [(x:xs)] = x : myConcat xs
01:53:49 <tieTYT> same error
01:54:39 <dobblego> you don't want that anyway
01:54:45 <[Justice]> what are you trying to accomplish?
01:54:49 <Cale> tieTYT: Try writing down equations for  myConcat [] and myConcat (x:xs)
01:54:50 <dobblego> ?type concat
01:54:55 <Cale> where x is a list, and xs is a list of lists
01:54:57 <lambdabot> forall a. [[a]] -> [a]
01:55:01 <tieTYT> Cale: oh ok
01:55:13 <tieTYT> i thought about doing that
01:55:17 <Cale> tieTYT: You'll want to use (++)
01:55:24 <tieTYT> but then i thought that would lead to if's and elses
01:55:30 <Cale> nope :)
01:55:32 <tieTYT> and that i must be doing something wrong if i can't do it by pattern matching
01:55:35 <[Justice]> myConcat [x:xs] = x ++ myConcat xs
01:55:36 <tieTYT> ok let me try then
01:55:45 <Cale> [Justice]: not quite :)
01:56:11 <Cale> [x:xs] is a one element list, whose sole element is a list whose head is x, and whose tail is xs
01:56:54 <[Justice]> :t [1:[1,2]]
01:56:56 <lambdabot> forall t. (Num t) => [[t]]
01:57:01 <tieTYT> myConcat (x:xs) = x ++ myConcat xs
01:57:05 <tieTYT> which may be what he meant
01:57:15 <tieTYT> but first this: myConcat [] = []
01:57:21 <[Justice]> hmm yeah
01:57:56 <[Justice]> myConcat = foldr (++) []
01:57:58 <mix25> Hello if i have this : http://pastebin.egghelp-bg.com/61  code, how to make the with all elements of list ?
02:02:21 <edwardk> @seen ddarius
02:02:21 <lambdabot> I saw ddarius leaving #haskell, #haskell-blah, #haskell-overflow and #haskell-soc 1h 18m 19s ago, and .
02:03:22 <dobblego> tieTYT, you might be thinking of use if/then/else instead of pattern matching
02:04:07 <tieTYT> anything wrong with this: myReverse x = last x : myReverse (init x)
02:04:19 <dobblego> yes :)
02:04:24 <tieTYT> it seems to work
02:04:24 <dobblego> weren't you writing concat?
02:04:33 <dobblego> it will work; put a long list in there
02:04:34 <tieTYT> yeah but i finished concat
02:04:37 <dobblego> oh ok
02:04:47 <dobblego> you know, I run a functional programming/Scala course, right?
02:04:49 <tieTYT> so what's wrong with myReverse?
02:04:52 <tieTYT> yes
02:04:56 <dobblego> writing reverse is an exercise I do
02:05:04 <dobblego> *all* students write reverse that way at first
02:05:09 <dobblego> but it has a problem
02:05:21 <dobblego> it would help if you found that problem yourself
02:05:27 <dobblego> try putting in a reasonably long list
02:05:31 <dobblego> say, [1..1000]
02:06:02 <tieTYT> that seems tow ork
02:06:19 <dobblego> does it take a while?
02:06:21 <tieTYT> no
02:06:24 <tieTYT> very quick
02:06:29 <tieTYT> i tried 10000 and it was slower
02:06:36 <dobblego> was it 10 times slower?
02:06:43 <dobblego> add another 0
02:07:03 <tieTYT> yeah it gets exponentially slower i'd predict
02:07:25 <dobblego> that's a problem don't you think?
02:07:40 <tieTYT> yeah
02:07:42 <dobblego> last runs in time proportional to the list length (it's singly linked)
02:07:56 <dobblego> you can write that function as a tail recursive version
02:07:57 <edwardk> its n^2 in terms of the length of the list.
02:08:11 <dobblego> you add another argument; of the same type as the return type and use that as an accumulator
02:08:20 <dobblego> reverse' :: [a] -> [a] -> [a]
02:08:43 <tieTYT> ok so this needs a helper function?
02:08:49 <dobblego> then reverse :: [a] -> [a]; reverse x = reverse' [] x
02:08:59 <dobblego> yes, to write the tail recursive version
02:09:02 <tieTYT> ok
02:09:07 <tieTYT> i'll see if i can do this
02:09:13 <dobblego> g'luck ;)
02:09:17 <tieTYT> although i'm not sure what tail recursion is yet
02:09:34 <dobblego> it is a recursive function, where the last call is a call to itself
02:09:48 <dobblego> notice myReverse is not tail-recursive; the last call is to cons (:)
02:09:52 <tieTYT> ah, that makes sense
02:10:07 <dobblego> it means certain optimisations can be achieved
02:10:33 <dobblego> specifically, the stack will not grow proportionally to the list (as you'd expect, since an imperative version wouldn't either)
02:10:36 <jaj> The Haskell School of Expression explain this problem fairly well, starting from the naive implementation are working towards the definition used in Prelude
02:10:39 <HunterXHunter> namely it doesn't consume up all the stack space
02:11:19 <dobblego> so, reverse' will be tail recursive
02:11:42 <dobblego> it will be a bit like a loop, where the accumulator is not updated, but passed around the function
02:14:29 <Cale> I like reverse in terms of foldl
02:14:35 <dobblego> Cale, ssh!
02:16:17 <dolio> Hey Cale, you want to write a new standard library?
02:16:20 <dolio> With polymorphism?
02:16:22 <dolio> And hookers?
02:16:44 <Cale> Sounds awesome.
02:18:28 <Cale> I really would like to be able to rely on class aliases, in my ideal scheme for things.
02:18:46 <dolio> Yeah, it's too bad we don't have those.
02:20:45 <Cale> The most important thing in the Prelude are the basic algebraic frameworks onto which other libraries fit. Monoids need a more prominent place, for one.
02:21:36 <dolio> Yeah.
02:21:44 <dolio> More top-level categories might be handy.
02:21:53 <dolio> Besides Control, Data and System.
02:22:32 <Cale> ah, a new hierarchy :)
02:23:00 <dolio> Agda has Algebra.
02:23:04 <dolio> And Category.
02:23:26 <Cale> The Data hierarchy has two different kinds of things in it which don't seem like they should both be under Data.
02:23:49 <Cale> It has libraries that implement datastructures, and it has libraries which abstract over lots of datastructures.
02:27:04 <tieTYT> i think i did it
02:27:06 <tieTYT> i'll have to paste it
02:27:12 <dobblego> go for it
02:27:38 <tieTYT> http://pastebin.org/38360
02:27:41 <tieTYT> oops
02:27:44 <tieTYT> http://pastebin.org/38360
02:28:13 <dobblego> looks good
02:28:40 <tieTYT> cool
02:28:46 <dobblego> however, there is already a function for performing a tail-recursion function on a list
02:28:48 <tieTYT> i don't think i could have figured out to use a helper function though
02:29:05 <dobblego> that's a general rule for converting to a tail-recursive function
02:29:19 <dobblego> add an argument with an accumulator; same type as the return type
02:29:24 <Cale> myReverse' xs []     = xs
02:29:24 <Cale> myReverse' xs (y:ys) = myReverse' (y : xs) ys
02:29:46 <Cale> Is a perhaps somewhat more elegant way to write that
02:30:17 <dobblego> the function for performing tail-recursion on a list is called foldl
02:30:17 <tieTYT> ah thanks
02:30:38 <dobblego> it encapsulates the tail recursion so you don't have to write it
02:30:54 <dobblego> foldl is tail-recursive; you just pass in the missing parts for performing the function you need
02:30:58 <dobblego> ?type foldl
02:31:05 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
02:31:22 <dobblego> myReverse2 :: [a] -> [a]; myReverse2 xs = foldl ...
02:32:39 <tieTYT> ok i'll try to write that
02:32:47 <dobblego> righto; good luck again!
02:35:42 <tieTYT> actually i don't understand it's signature.  Can someone show me an unrelated usage of it?
02:35:55 <tieTYT> i'm confused that it returns a
02:36:23 <dobblego> well, it's going to return a list, right?
02:36:32 <tieTYT> yes, doe sthat mean a will be a list?
02:36:38 <dobblego> you can guarantee that from myReverse2 :: [a] -> [a]; myReverse2 xs = foldl ...
02:36:41 <dobblego> right
02:36:48 <tieTYT> ok
02:36:55 <dobblego> and the second argument (of type a) will be the beginning value for the accumulator
02:37:06 <dobblego> the function a -> b -> a will be applied for each b in [b]
02:37:29 <Cale> tieTYT: Did you see my diagrams by the way? I'm pretty sure I've shown them to you before, but maybe I'm confused.
02:37:36 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
02:37:37 <lambdabot> Title: Fold Diagrams - CaleWiki
02:37:38 <tieTYT> Cale: i'm not sure
02:37:50 <tieTYT> ah yeah i've seen these
02:38:29 <Cale> You can see how in the diagram for foldl, the elements which were at the end of the list end up at the top of the resulting tree.
02:39:51 <Cale> If you just flipped the diagram over from left to right, you'd almost have the reverse of the list already.
02:41:00 <tieTYT> isn't there another parameter that should be in that diagram?
02:41:08 <Cale> That's the list.
02:41:10 <tieTYT> i guess the [b] is the list itself
02:41:34 <Cale> I'm showing what the function foldl f z does to a list.
02:41:37 <dobblego> yes, that's x in myReverse2 x
02:42:50 <Cale> > foldr f z [1..5]
02:42:53 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
02:43:01 <Cale> > foldr (:) [] [1..5]
02:43:02 <lambdabot>  [1,2,3,4,5]
02:43:10 <Cale> > foldl f z [1..5]
02:43:11 <lambdabot>  f (f (f (f (f z 1) 2) 3) 4) 5
02:43:17 <Cale> > foldl (flip f) z [1..5]
02:43:18 <lambdabot>  f 5 (f 4 (f 3 (f 2 (f 1 z))))
02:43:43 <[Justice]> scanl f z [0..3]
02:43:44 <tieTYT> ok thanks that helps
02:43:46 <Cale> Some things to look at :)
02:43:50 <[Justice]> > scanl f z [0..3]
02:43:51 <lambdabot>  [z,f z 0,f (f z 0) 1,f (f (f z 0) 1) 2,f (f (f (f z 0) 1) 2) 3]
02:44:18 <tieTYT> > foldl f z [1..5]
02:44:19 <lambdabot>  f (f (f (f (f z 1) 2) 3) 4) 5
02:52:32 <tieTYT> why does lambdabot let me see foldl f z [1..5] but ghci doesn't?
02:52:35 <tieTYT> that would be convenient
02:53:18 <Cale> tieTYT: Because lambdabot has a SimpleReflect module which defines some fancy datatypes and machinery to do that.
02:53:27 <tieTYT> oh
02:53:30 <Cale> You can steal it out of the sourcecode to lambdabot.
02:53:43 <Cale> Or, perhaps someone's put together a package on Hackage for it.
02:54:14 <pejo> Can lambdabot be used through any ohter interface than irc?
02:54:49 <Cale> It has an offline mode.
02:55:10 <Cale> Also, there was something called GHCi on Acid, but I'm not sure if it's maintained.
02:56:34 <tieTYT> hrm...
02:58:24 <cjs> I've been meaning to try that, to have a lambdabot of my own.
02:58:32 <cjs> You can stick it in your editor, too.
02:59:19 <tieTYT> i can't figure out how to use foldl and get a list as a result.  I'm going to try this again tomorrow
02:59:30 <Cale> tieTYT: well, look at:
02:59:31 <tieTYT> see ya
02:59:36 <Cale> > foldr f z [1..5]
02:59:45 <Cale> > foldl (flip f) z [1..5]
02:59:51 <lambdabot>  thread killed
02:59:55 <Cale> d'oh
02:59:58 <Cale> > foldr f z [1..5]
02:59:58 <lambdabot>  f 5 (f 4 (f 3 (f 2 (f 1 z))))
02:59:59 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
03:00:04 <Cale> heh
03:00:05 <Cale> > foldr f z [1..5]
03:00:06 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
03:00:12 <Cale> > foldl (flip f) z [1..5]
03:00:13 <lambdabot>  f 5 (f 4 (f 3 (f 2 (f 1 z))))
03:00:20 <Cale> > foldr (:) [] [1..5]
03:00:21 <lambdabot>  [1,2,3,4,5]
03:00:24 <tieTYT> isn't that the answer?
03:00:29 <Cale> basically :)
03:00:40 <tieTYT> i didn't want that yet :P
03:00:46 <Cale> You just have to fill in f and z appropriately
03:00:50 <tieTYT> but i did write my own swap function
03:01:01 <tieTYT> @type flip
03:01:04 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
03:01:05 <tieTYT> @src flip
03:01:05 <lambdabot> flip f x y = f y x
03:01:22 <qwr> > foldl (flip (::)) [5..7] [1..4]
03:01:22 <lambdabot>  Parse error at "::))" (column 14)
03:01:26 <qwr> > foldl (flip (:)) [5..7] [1..4]
03:01:27 <lambdabot>  [4,3,2,1,5,6,7]
03:01:59 <tieTYT> ok this works: foldr (:) [] [1..5]
03:02:04 <tieTYT> but this doesn't: foldl (:) [] [1..5]
03:02:08 <tieTYT> why not?
03:02:12 <tieTYT> this is what i got stuck on
03:02:37 <Cale> because (:) doesn't like having a list as its first argument, and an element as its second?
03:02:51 <tieTYT> oh
03:02:51 <Cale> I suppose that's the basic idea behind it
03:03:03 <Cale> Stare at the diagram
03:03:10 <Cale> and imagine replacing f's with :'s
03:03:12 <tieTYT> these ghci errors are hard to decypher
03:03:29 <Baughn> > foldl f [1..5]
03:03:30 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [t])
03:03:40 <Cale> > foldl f z [1..5]
03:03:41 <lambdabot>  f (f (f (f (f z 1) 2) 3) 4) 5
03:03:51 <Cale> > foldl f z [1]
03:03:53 <lambdabot>  f z 1
03:04:01 <Cale> > foldl f [] [1]
03:04:01 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [a])
03:04:13 <Cale> Well, if z was [], and f was (:)
03:04:18 <Cale> that would be []:1
03:04:20 <Baughn> I keep forgetting. That chain looks.. like a recipe for stack overflow, to be honest
03:04:23 <Cale> which is already a problem
03:04:26 <Baughn> Are there any good uses of foldl?
03:04:31 <Cale> Sure.
03:04:43 <Cale> Once strictness analysis does its thing it's not so bad.
03:04:57 <dobblego> tieTYT, foldr and foldl have slightly different signature
03:05:02 <Baughn> So I have to depend on the optimizer. Godie.
03:05:17 <Cale> Baughn: If it really bothers you, there's foldl'
03:05:20 <dobblego> ?type foldl
03:05:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
03:05:24 <Cale> @src foldl
03:05:25 <lambdabot> foldl f z []     = z
03:05:25 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
03:05:26 <dobblego> ?type foldl (:)
03:05:28 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
03:05:28 <lambdabot>       Expected type: a -> [a] -> a
03:05:28 <lambdabot>       Inferred type: a -> [a] -> [a]
03:05:29 <Cale> @src foldl'
03:05:30 <lambdabot> foldl' f a []     = a
03:05:30 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
03:05:35 <qwr> Baughn: the foldl chain is inherently tail-recursive one ;)
03:05:46 <Baughn> Cale: I know all the usual arguments. I'm just wondering why foldl exists at all
03:06:04 <ivanm> Baughn: why shouldn't it?
03:06:16 <Cale> Because it was expected that the strictness analyser should be good enough to turn it into foldl' when required.
03:06:23 <Baughn> Well, when people say things like "It works if the optimizer turns it into foldl'"...
03:06:24 <ivanm> depending on what you want to do, foldl might do what you want
03:06:57 <Cale> Baughn: The Haskell report says nothing about evaluation order.
03:07:06 <Baughn> qwr: I get that, but tail recursion isn't all it's cracked up to be, with lazy evaluation thrown in. ;)
03:07:33 <Baughn> Cale: Seriously?
03:07:42 <Baughn> That's it, I'm going to have to read it.
03:07:42 <Cale> Of course, it defines seq, but it only does so semantically.
03:07:58 <qwr> Baughn: that's what the compiler has to do. haskell can be quite stupid without -O ;)
03:07:59 <Cale> (using  seq _|_ y = _|_ and seq x y = y otherwise)
03:09:02 <Baughn> ..that's an odd and bug-prone way of saying "seq evaluates one thunk of x"
03:09:12 <Cale> Haskell is defined to have non-strict semantics, which means you can evaluate things in any order so long as it has the same termination behaviour as lazy evaluation.
03:09:41 <Baughn> All right. So it's not allowed to go into infinite loops or overflow the stack if lazy evaluation wouldn't?
03:09:45 <Cale> (or outermost-first evaluation)
03:10:03 <Cale> The stack isn't considered, but it's not allowed to go into infinite loops.
03:10:34 <ivanm> Cale: isn't it that H98 doesn't require lazyness, but most people interpret "non-strict" as "lazy" because that's easier than eager, etc.?
03:10:43 <Cale> ivanm: right.
03:10:46 <Baughn> Crashing with a stack overflow sounds like different termination behaviour to me. ;)
03:11:04 <Cale> Baughn: Ideally, the stack is unbounded.
03:11:24 <Cale> (and failure to have an unbounded stack is an implementation bug)
03:11:47 <astrolabe> No language guarantees not to overflow your stack.
03:11:58 <ivanm> yeah.... doesn't everyone have infinite amounts of RAM?
03:12:29 <Baughn> Obviously, a conforming implementation should negotiate for internet storage of swap at need
03:13:24 <tieTYT> Cale: gf called.  I see the problem with : now
03:13:32 <tieTYT> and why flip would fix it
03:13:50 <Cale> The stack also has a very different meaning in most Haskell implementations than it does in strict languages too.
03:14:10 <tieTYT> ok i done did it
03:14:12 <tieTYT> let me paste
03:14:37 <tieTYT> http://pastebin.org/38366
03:14:43 <Cale> It's intuitively measuring the path from the top of the expression you're trying to evaluate down to the first reducible expression in it.
03:14:48 <tieTYT> i'm proud of myself for at least realizing that a flip/swap was necessary
03:14:50 <ivanm> Cale: what does it mean in Haskell? pancakes? :p
03:14:54 <Cale> (leftmost, outermost redex)
03:15:15 <Cale> tieTYT: You don't need two cases
03:15:25 <Cale> myReverse2 xs = foldl ...
03:15:53 <tieTYT> when i get rid of it it throws an exception on myReverse2 []
03:15:55 <qwr> tieTYT: FYI flip is exactly same as your swap
03:16:07 <Cale> tieTYT: that's because your second pattern is (x:xs) and not just xs
03:16:16 <tieTYT> qwr: yeah I know, actually i originally made my swap as swap x y = y x which wouldn't have worked
03:16:26 <tieTYT> but i understood in concept what i needed
03:16:54 <tieTYT> Cale: so you're saying i should do head/tail in the definition?
03:17:06 <Cale> tieTYT: note that   foldl (swap (:)) [] (x:xs) = foldl (swap (:)) (x:[]) xs
03:17:43 <tieTYT> ah yeah i see that
03:18:00 <Cale> (by one reduction involving the definition of foldl)
03:18:01 <tieTYT> so you think i should match on xs instead of x:xs?
03:18:04 <Cale> yeah
03:18:15 <tieTYT> but that means i gotta use head/tail inside the definition, right?
03:18:18 <Cale> no
03:18:23 <tieTYT> oh
03:18:24 <tieTYT> i get it
03:19:00 <tieTYT> ok
03:19:32 <Cale> (I'd never recommend swapping out a pattern match in favour of head/tail)
03:20:04 <Cale> (except possibly as an intermediate step in some simplification, I suppose)
03:20:13 <tieTYT> ok
03:20:19 <tieTYT> thanks for these notes on my "style"
03:20:41 <tieTYT> i can't tell when the stuff i write looks weird
03:20:50 <tieTYT> after it already functions the same
03:21:17 <dobblego> note that myReverse and myReverse2 do not "function the same"
03:21:29 <Cale> You begin to notice simplifications like this.
03:21:36 <Cale> It just takes time.
03:21:41 <Cale> dobblego: hm?
03:21:43 <tieTYT> dobblego: what's the difference?
03:21:49 <dobblego> tieTYT, as your discipline grows, you start spotting these recurring patterns
03:22:12 <dobblego> try this: head $ myReverse [1..]
03:22:27 <Cale> uh, that'll never work in either case
03:22:38 <dobblego> sorry, you're right
03:22:56 <dobblego> excuse: chess is distracting me!
03:23:25 <tieTYT> :)
03:23:34 <tieTYT> i donno what $ is yet
03:23:43 <dobblego> head (myReverse [1..])
03:24:44 <ionutz_99> ERROR - Undefined variable "toUpper"
03:24:49 <tieTYT> hrm
03:24:53 <dobblego> import Data.Char
03:24:54 <tieTYT> i thought that would happen automatically
03:25:04 <ionutz_99> tx man
03:25:26 <ionutz_99> but seems it doesn't work :(
03:25:35 <dobblego> ?info toUpper
03:25:35 <lambdabot> toUpper
03:25:38 <paolino> :t ($)
03:25:41 <lambdabot> forall a b. (a -> b) -> a -> b
03:25:41 <Cale> tieTYT: f $ x = f x
03:25:50 <Cale> tieTYT: But ($) has a low precedence
03:25:55 <astrolabe> @hoogle toUpper
03:25:55 <lambdabot> Data.Char.toUpper :: Char -> Char
03:26:11 <Cale> Er, low binding strength :)
03:26:31 <paolino> @src ($)
03:26:32 <lambdabot> f $ x = f x
03:26:33 <tieTYT> geez
03:26:34 <ionutz_99> i think my compiler has a problem :) (winhugs 98)
03:26:37 <Cale> So that sticking a $ between things is almost like wrapping what's on the left and right in parens
03:26:52 <tieTYT> i get really confused when the a of a signature gets bound to a function for some reason
03:27:03 <Cale> ionutz_99: I think you just haven't imported the Data.Char module
03:27:39 <tieTYT> based on the source of $, what's the point?
03:27:51 <Cale> ionutz_99: import declarations would have to go into a file
03:28:00 <ionutz_99> ok
03:28:05 <Cale> ionutz_99: if you're at the hugs prompt you can load that module with :also Data.Char
03:28:12 <Cale> tieTYT: To save parens
03:28:14 <paolino> tieTYT: it let you avoid parens
03:28:28 <paolino> not really always
03:28:57 <tieTYT> > head tail [1..5]
03:28:58 <lambdabot>  Couldn't match expected type `[a]'
03:29:01 <Cale> rather than writing something like  (map head . group . sort) (words "abra cad abra")
03:29:04 <tieTYT> > head $ tail [1..5]
03:29:06 <lambdabot>  2
03:29:09 <tieTYT> ok i get it now
03:29:18 <Cale> You can write  map head . group . sort $ words "abra cad abra"
03:29:59 <tieTYT> ok thanks
03:30:09 <tieTYT> i think i'll go to sleep now
03:30:15 <Cale> all right
03:30:18 <Cale> see you around
03:30:19 <tieTYT> see ya, thanks
03:30:22 <dobblego> seeya
03:33:07 <paolino> @babel it en orzo
03:33:08 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
03:35:36 <ionutz_99> tx for help.. now seems it works. I have a project(with GUI) for a class, and i need to choose between haskell, scheme and clips
03:46:38 <Cale> ionutz_99: There are some decent GUI libraries for Haskell, including Gtk2Hs and WxHaskell. I would recommend GHC over Hugs generally though.
03:51:13 <cinimod> Has anyone tried building data parallel haskell? I get the following error: http://www.haskell.org/pipermail/glasgow-haskell-users/2008-May/014793.html
03:51:13 <lambdabot> Title: Building ndp Problem, http://tinyurl.com/5grpuh
03:55:12 <ionutz_99> @<Cale> : do u think haskell is more easy to learn than scheme?
03:55:12 <lambdabot> Unknown command, try @list
03:55:32 <ionutz_99> because i have only a week for this project
03:56:00 <Cale> ionutz_99: I'm not sure. I would expect both of them to take much longer than a week to really learn.
03:56:39 <ionutz_99> ok
03:56:51 <Cale> Depending on what you're doing though, you might get by in either one.
03:57:02 <Baughn> ionutz_99: You _might_, if you already know similar languages, be able to get a useful understanding of scheme in a week. Haskell.. same, except you almost certainly don't have that pre-existing knowledge
03:57:30 <Cale> yeah
03:57:31 <ionutz_99> i know a few C and pascal
03:57:34 <Baughn> But I wouldn't think you'd be able to do that /and/ write something useful in either
03:57:54 <Baughn> ionutz_99: Then, not a chance. A week is far too short.
03:58:01 <ionutz_99> :| ok
03:58:14 <Cale> Well, what is the project?
03:58:40 <ionutz_99> a x & 0 game, n*n with AI
03:59:05 <Baughn> "x&o"? Tic-tac-toe?
03:59:06 <ionutz_99> n<6
03:59:09 <ionutz_99> yes
03:59:19 <Baughn> Oh, that should be doable
03:59:27 <ionutz_99> i though so
03:59:41 <Baughn> For "brute-force" values of "AI", of course
03:59:48 <ionutz_99> yep :p
04:00:41 <Cale> If you want it to have a GUI though, that will be more work to learn a GUI library. Probably simplest to focus getting things working with a purely text interface first.
04:00:52 <Baughn> Quite.
04:01:05 <Baughn> ionutz_99: Why do you want to do this, to begin with? And why a week?
04:01:07 <ionutz_99> that is what i try now :)
04:02:14 <ionutz_99> Baughn:because i have a class caled "programming paradigms", and we have to do a project
04:02:30 <ionutz_99> *called (sorry for my english)
04:02:41 <Baughn> ionutz_99: I'm betting you had more than a week, but that's not my business. Now, then..
04:03:10 <ionutz_99> i had a lot more other projects :(
04:03:25 <Baughn> ionutz_99: Scheme will be more similar to what you already know, and thus easier to learn. Haskell is (IMO, and obviously, since this is #haskell) more powerful and would allow you to write a shorter program. I'm not sure which would be easier, so..
04:03:45 <Baughn> ionutz_99: Go with haskell. ;)
04:03:58 <Baughn> ionutz_99: http://www.haskell.org/~pairwise/intro/intro.html <-- Here's one intro
04:03:58 <ionutz_99> tx Baughn, anyway :)
04:03:58 <lambdabot> Title: Haskell for C Programmers
04:05:15 <ionutz_99> tx, i will take a look ;)
04:22:08 <mbz> @yarr
04:22:09 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
04:22:18 <mbz> err
04:23:17 <Baughn> I don't think lb likes you
04:40:44 <Adamant> has anyone ever written a disassembler in Haskell? Does it offer any advantages like with developing compilers?
04:42:35 <ndm> Adamant: usually the compiler can quite happily write out code before its assmbled, so no need to do so
04:42:37 <ndm> Adamant: but someone has, Harpy, I think...
04:43:00 <Adamant> ndm: sometimes source is not available
04:43:12 <pejo> Isn't harpy the other way around?
04:43:13 <ndm> Adamant: if you are developing a compiler, then it is :)
04:43:14 <Adamant> security applications for instance
04:43:18 <ndm> pejo: i think harpy does both
04:43:19 <Adamant> fair enough. :)
04:43:41 <ndm> Adamant: yes, there are needs for disassembly, and its perfectly easy to do in Haskell
04:44:06 <pejo> Oh, nifty. Harpy.X86Disassembler.
04:44:37 <Heffalump> ooh
04:44:38 <Adamant> I meant more, are there any clear reasons to do disassembly in Haskell like there are if you want to mock up a language and compiler quickly if you're a language designer
04:45:06 <Heffalump> well, FP is good at program manipulation in general
04:45:17 <Heffalump> that can include binary programs, particularly if you are trying to recover structure
04:46:01 <ndm> Adamant: if you are going from code -> assembly, its unlikely you'll want an assembler
04:46:20 <ndm> but if you have bits that start as binary, it could be useful there
04:46:32 <ndm> or if you are using someone elses tool to do the code -> assembly
04:46:36 <Toxaris> Adamant: What compiler-specific features do you refer to? I see a number of clear reasons to do <software project of your choice> in Haskell.
04:51:48 <hpaste>  MarcWeber pasted "What am I doing wrong creating a simple ADT using template haskell?" at http://hpaste.org/7870
04:52:30 <MarcWeber> I'd like to create simple ADT data Test = Test { unTest :: String }
04:53:16 <Adamant> Toxaris - for instance, that creating ADT's in Haskell feels very much like doing BNF
04:55:10 <Adamant> mainly I'm thinking about writing Yet Another Disassembler and doing in Haskell would be interesting
04:55:55 <Toxaris> well, a compiler parses text into an ADT, does something, and prints the result as binary. A disassembler parses binary into an ADT, does something, and prints text
04:56:00 <hpaste>  jaj pasted "(no title)" at http://hpaste.org/7871
04:57:03 <jaj> isn't this supposed to work?
04:57:07 <Toxaris> Adamant: so instead of a text parser (e.g. Parsec) and a binary printer (e.g. Binary), you want a binary parser (e.g. Binary) and a text printer (e.g. PrettyPrint), so the interface part should be no problem
04:57:24 <Adamant> but I don't know if it makes sense to do it, for instance if I have to do a lot of imperative-esque programming or if I need to keep thing very eager, using Haskell doesn't really make sense
04:57:45 <MarcWeber> jaj: Isn't invOp :: (Term -> Term -> Term) enough ? (wihtout -> (T -> T -> T) ?
04:57:54 <Toxaris> Adamant: I don't know what the "does something" part of an disassembler is about, but I guess you have to recover structure which was lost in the compilation process
04:57:55 <MarcWeber> >t (+)
04:58:06 <Adamant> right
04:58:15 <Toxaris> Adamant: but that seems to be similiar to how a parser recovers structure which was lost in writing an ADT as concrete syntax
04:58:26 <jaj> MarcWeber: well (:+) is type Term -> Term -> Term
04:58:29 <Toxaris> probably more complicated, though :)
04:58:43 <Adamant> interesting point.
04:58:51 <Adamant> thanks Toxaris.
04:59:27 <MarcWeber> jaj: Sorry. I didn't get what you want to do.. You want haskell to match (Term -> Term -> Term) and return a funciton doing the oppsite..
05:00:30 <MarcWeber> jaj: But this can't work because haskell can't know the difference (T -> T -> T) (addition) and (T -> T -> T) (substraction).. All it "knows" is its a function taking two terms and returning another..
05:01:40 <MarcWeber> jaj: You need kind of phanom typing or such.. I'll give you an example in about 30min..
05:01:50 <Heffalump> if the only two options are (+) and (*) you can work out which is which by experimentation..
05:02:04 <Heffalump> or if Term is an instance of Num then you can have an abstract representation of both and then you can know
05:02:19 <jaj> MarcWeber: invOp should be returing :- when given :+, I don't ask it to magically know what the opposite operation is
05:02:33 <Heffalump> also, isn't :+ a constructor anyway, so you can match on it once it has some arguments?
05:05:28 <pastorn> @paste
05:05:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:07:26 <jaj> Heffalump: if I pattern match then I get a Term, I don't get a (Term -> Term -> Term) function. I think I'm trying to dynamically create a constructor and that doesn't seem to work
05:08:14 <Heffalump> hangon, I'll read what you're trying to do from the top
05:09:07 <hpaste>  pastorn pasted "is this an indentation error?" at http://hpaste.org/7872
05:09:35 <pastorn> please, could someone try to parse this
05:09:45 <pastorn> i can't see what i have done wrong...
05:09:45 <mauke> missing do in else
05:09:53 <pastorn> right...
05:10:36 <hpaste>  Heffalump annotated "(no title)" with "invOp" at http://hpaste.org/7871#a1
05:11:14 <Heffalump> bit of a hack, but it ought to have the effect you want..
05:11:49 <Heffalump> whether the effect you want is sensible is another matter :-)
05:13:21 <Beelsebob> Heffalump: not gonna work exactly sensibly - after all, 0 - 0 == 0 + 0
05:14:13 <Heffalump> what does - have to do with :- ?
05:14:25 <Beelsebob> oh, duh
05:14:27 <Beelsebob> I'm a moron
05:14:38 <Beelsebob> sorry
05:14:40 <Heffalump> :-)
05:15:02 <jaj> Heffalump: hmm the same error happens with your code, only delayed
05:15:22 <jaj> *Main> let a = (N 2) (invOp (:+)) (N 3)
05:15:46 <jaj> Couldn't match expected type `t1 -> t2 -> t' against inferred type `Term' In the expression: (N 2) (invOp (:+)) (N 3)
05:15:57 <Beelsebob> jaj (invOp (:+)) isn't infix any more
05:16:46 <jaj> Beelsebob: oh yeah right, how stupid of me :)
05:17:21 <jaj> yes works then, thanks Heffalump !
05:18:58 <Beelsebob> note, the other way to do this might be to make invOp :: Term -> Term
05:19:25 <Beelsebob> and have it work as invOp ((N 5) :+ (N 3)) == (N 5) :- (N3)
05:19:46 <Beelsebob> but that's not ideal either
05:20:30 <Beelsebob> in the mean time
05:20:30 * Beelsebob ponders why you can't pattern match on constructors
05:21:50 <Heffalump> Beelsebob: because pattern-matching is for values, not functions
05:22:32 <Heffalump> since equality of functions isn't decidable, it would be rather weird semantically to be able to do it
05:22:32 <Beelsebob> Heffalump: yeh, but constructors are very special functions
05:22:32 <Beelsebob> with which there is no danger of doing wierd shit
05:22:32 <Beelsebob> (unlike with functions in general)
05:22:38 <Heffalump> if f = (:+), then forall a b, f a b = a :+ b
05:22:49 <wjt> I'm trying to reduce http://hpaste.org/7873 to a smaller example that triggers http://hackage.haskell.org/trac/ghc/ticket/2164 on my x86.  If I replace 'parse' with some trivial function, the url with any other non-Twitter-feed URL I've tried, or reduce the xml in 'foo' passed to 'parse' any further, it doesn't die.  Pretty weird.  Any suggestions?
05:23:05 <Beelsebob> yeh, exactly -- equality on functions is undecidable, but equality on constructors *is* decidable
05:23:10 <Heffalump> and that's the only relevant property of f. But I could write a more complicated f which had that property but it was very hard to prove it.
05:23:21 <Heffalump> Beelsebob: only if you restrict yourself to constructors
05:23:39 <Heffalump> for a value of type Term, you can enumerate all the things it might be.
05:23:39 <Beelsebob> exactly
05:23:39 <Beelsebob> that's what I said at the start
05:23:40 <Beelsebob> why can't we pattern match on constructors too
05:23:49 <Heffalump> But for a function of type Term -> Term -> Term, you can't.
05:23:49 <Beelsebob> oh, duh
05:24:13 <Beelsebob> so yeh, it needs some kind of typing extention to say constructors of type Term -> Term -> Term instead of functions in general
05:24:41 <Heffalump> right, and I think that would be a rather odd extension in general
05:24:49 <Beelsebob> it would be quite odd, yes
05:24:57 <Heffalump> and not very useful :-)
05:25:01 <Beelsebob> I dunno
05:25:17 <Beelsebob> I can think of many situations where I want to replace constructors throughout a data structure
05:25:23 <Beelsebob> and this would do it rather more neatly
05:27:46 <Heffalump> why?
05:27:53 <Heffalump> If you have a data structure, you have a value
05:28:21 <Beelsebob> yep
05:28:29 <Heffalump> so just pattern-match on that..
05:28:32 <Beelsebob> doesn't make the code you posted neat
05:28:42 <Beelsebob> extensions aren't only about adding functionality
05:28:49 <Beelsebob> they're also about making the code look better
05:28:57 <Beelsebob> otherwise we'd all be using lambda calculus
05:30:59 <Heffalump> the code I posted was a hack because of the requirement of converting *functions* rather than *values*
05:31:28 <Heffalump> though actually, it could have been implemented differently, namely take the two arguments, apply them to the given function, then map :+ -> :- in the result value etc.
05:31:35 * Heffalump disappears
05:36:24 <doun> coi
05:36:28 <doun> uh
05:36:30 <doun> hi
05:41:26 <pastorn> wtf is this??
05:41:28 <pastorn> *Main> doesDirectoryExist "~/" >>= print
05:41:28 <pastorn> False
05:41:51 <wjt> you need to expand ~ yourself
05:41:56 <MarcWeber> jaj Yes you do. You ask ghc to know given any funciton (T -> T -> T) to know which it's opposite is. You can't pattern match against a function implementation. You can only pattern match against constructors or tuples..
05:42:02 <wjt> there is probably no directory called '~' in your current directory
05:43:09 <byorgey> hi doun
05:43:44 <pastorn> wjt: but ~ is my alias for /home/alexander/
05:43:50 <pastorn> isn't it?
05:43:52 <wjt> only in the shell
05:44:00 <pastorn> oh
05:44:06 <flux> pastorn, mkdir ~'/~' works too
05:44:15 <flux> and then you have a file called ~ in your home directory
05:44:24 <flux> s/file/directory/
05:51:12 <chessguy> @pl q n = m r $ q' n n
05:51:12 <lambdabot> q = m r . join q'
05:53:39 <schemelab> any examples of calculating 40 days from a certain date in Haskell?
05:56:00 <jmg_> hi
05:56:11 <schemelab> hi jmg_
05:56:36 <jmg_> anybody here, who can help me with a problem with a problem with type families and existential quantification
05:57:23 <hpaste>  jmg pasted "can't compile with type families and existential quantification" at http://hpaste.org/7874
05:57:53 <jmg_> hi schemelab
05:59:10 <hpaste>  jmg annotated "can't compile with type families and existential quantification" with "(no title)" at http://hpaste.org/7874#a1
06:02:19 <dolio> jmg_: Compiling on 6.8?
06:02:29 <dolio> Oh, never mind.
06:02:40 * dolio should read more closely.
06:03:20 <Heffalump> jmg_: the problem is that the compiler can't know for what foo, P foo = Elem1
06:03:26 <Heffalump> sure, there is one possibility, namely foo = AA
06:03:35 <Heffalump> but there could be others, since type functions are open
06:04:07 <jmg_> Heffalump: how can i fix that?
06:04:52 <Heffalump> jmg_: write a helper wrap that takes a parameter of type a as well as the P a, and pass some undefined value to it
06:05:21 <jmg_> Heffalump: i'll try that, thanks
06:05:41 <Heffalump> (I ran into precisely this problem some weeks ago and there was a fair bit of discussion on haskell-cafe about it)
06:06:07 * dolio still isn't seeing the problem...
06:06:37 <dolio> In that instance declaration, bar :: P AA -> GenericA.
06:06:41 <mehrheit> > let daysToSecs x = x*24*60*60; p = fromJust . parseTime defaultTimeLocale "%Y-%m-%d %H:%M:%S%Q %Z"; addDate a b = addUTCTime (fromRational . toRational $ a) b in addDate (daysToSecs 40) (p "2000-01-01 12:00:00 UTC")
06:06:42 <lambdabot>   Not in scope: `addUTCTime'
06:06:43 <jmg_> Heffalump: do you remember the subject of the thread?
06:07:04 <mehrheit> schemelab, there's an example, the functions are in Data.Time
06:07:36 <schemelab> mehrheit: thanks
06:07:44 * schemelab hauls out GHC :)
06:07:54 <Heffalump> jmg_: not off the top of my head, but if you look for posts by me (Ganesh Sittampalam) you'll probably find it fairly quickly
06:08:23 <Heffalump> dolio: but P AA = Elem1
06:08:34 <dolio> Right.
06:08:45 <Heffalump> and going back from Elem1 to P a, any a could be valid (if P a = Elem1)
06:08:53 <Heffalump> there's nothing to say that a must be AA
06:09:12 <dolio> Where does it have to do that?
06:09:51 <Heffalump> when it passes x to WRAP
06:10:17 <dolio> Hmm...
06:10:36 <Heffalump> unifying P AA with P a (as you need to do at that point) does not automatically give you a = AA
06:10:50 <dolio> jmg_: What happens if you write "WRAP (x :: P AA)"?
06:10:57 <Heffalump> it won't help
06:11:06 <Heffalump> (feel free to try in case I'm wrong, of course)
06:11:16 <jmg_> dolio: it doesn't help
06:11:21 <dolio> I'd try it myself, but I don't have 6.9.
06:11:26 <dolio> Ah well.
06:11:30 <Heffalump> you still need to unify P AA with P a :-(
06:11:56 <Heffalump> the only solution is to somehow directly specify a, and the only way you can do that (that I know of) is to have some extra parameter. It really sucks for writing nice code :-(
06:12:11 <jmg_> Heffalump: why  do i have to unify PAA with P a?
06:12:26 <edwardk> heff: hrmm when he calls WRAP there he is defining the existential, so i don't see what you mean.
06:12:31 <Heffalump> jmg_: because WRAP :: forall a . P a -> GenericA
06:12:45 * Heffalump is being dragged off for lunch, but will be back in 20 mins or so
06:12:58 <jmg_> Heffalump: i can't get it to work with an extra parameeter either
06:13:04 <jmg_> thanks
06:13:24 <Heffalump> I'm fairly sure I know how to do that, I'll have a go after lunch.
06:13:44 <jmg_> i'll still be here in 30 min
06:13:55 <Heffalump> edwardk: you still have to specify what a is, to put it in the existential (concretely, so you know what dictionary for the A class to wrap up in it)
06:14:24 * Heffalump gone
06:14:27 <edwardk> oh ah, i forgot there was a class involved
06:14:44 <dolio> Can't specialize WRAP?
06:14:57 <dolio> (WRAP :: P AA -> GenericA) x
06:15:19 <jmg_> i don't understand the compiler error, can anyone explain to me why ghc wants to specialize P AA -> GenericA to P AA -> GenericA and fails to do so?
06:16:11 <jmg_> dolio: i am afraid no, i really want to have a generic type for multiple concrete types
06:16:35 <dolio> I mean just where you're using it in bar there.
06:16:56 <dolio> You can still have GenericA as declared, but writing that might tell it what dictionary to use.
06:18:31 <jmg_> I am writing a set of datatypes which have naviagtions operations between them and some of those operations (bar, e.g) have a context depndent result type
06:18:53 <mix25> Hello Why this: f :: [[Int]] -> Bool <next_line:> f [[xs],[ys]] = False where ys = xs is returning True when invoke "f" with [[2,3],[2,3]] ?
06:19:26 <Deewiant> mix25: [[a],[b]] matches a list of length 2, containing two lists, each of which is length 1, and binds the elements of those lists to a and b, respectively
06:19:43 <Deewiant> mix25: you probably want [xs,ys] and not [[xs],[ys]]
06:21:19 <mix25> I want when f (xs:zss) , recieve a list of elements(lists) equals like, [[2,3],[2,3]], return False
06:21:46 <edwardk> dolio: the trick doesn't work
06:22:22 <dolio> Hmm, oh well.
06:22:55 <edwardk> hrmm. when you call bar :: P a -> GenericA it has no frame of reference for a does it?
06:23:00 <jmg_> i didn't understand the trick anyway
06:23:11 <mix25> I want exclue when there is elements who are repeated
06:23:28 <edwardk> that doesn't help either though
06:23:37 <mix25> Deewiant understand?
06:23:39 <edwardk> which i suppose is a separate issue entirely
06:23:40 <Deewiant> mix25: f xs = xs == nub xs
06:24:13 <jmg_> i could include a dependency that P a determines an a, would that help?
06:24:17 <edwardk> the typeclass you have defined you can't actually ever call bar  because bar is only based on P a. there is no mention of a outside of a call through a type family
06:24:21 <edwardk> so it can't dispatch
06:24:55 <edwardk> you can make bar :: a -> P a -> GenericA, but i still don't have this working. thats a separate issue pertaining to how to call this once you HAVE it working ;)
06:25:11 <jmg_> hmm
06:25:35 <edwardk> and just call bar (undefined :: AA) myElem1AA
06:25:47 <edwardk> so now how to fix the wrap
06:26:19 <mix25> Hugs says: nub undefined
06:26:41 <jmg_> ok, perhaps i should explain my original problem
06:26:59 <Deewiant> mix25: import Data.List
06:28:18 <jmg_> i wanted to a have a type class with two parameters, where either combination of two elements from the set of the type arguments and P a would determine the third type
06:28:34 <edwardk> fixed it one sec
06:29:23 <hpaste>  edwardk annotated "can't compile with type families and existential quantification" with "passing a phantom type to fix the type of AA" at http://hpaste.org/7874#a2
06:30:56 <jmg_> ok, you included the phantom in the existential data type
06:31:13 <edwardk> P a -> GenericA doesn't give you enough information to tell you the type a
06:31:25 <edwardk> you merely have the image of it under a type family.
06:32:00 <edwardk> the Phantom lets the GADT know what dictionary to pass in for A a.
06:32:32 <jmg_> thanks, now i think i understand the problem
06:32:32 <edwardk> you can call bar (undefined :: MyA)
06:32:40 <edwardk> where before you wanted to call bar, but bar was ill posed before. you could never write code that used it because it didn't know which a it was being used on.
06:33:17 <jmg_> ok
06:33:44 <jmg_> i have to think a bit about alternative designs now
06:33:52 <edwardk> kk
06:34:29 <jmg_> i have three types, every subset of two should determine the third one
06:35:05 <mix25> Deewiant there is other solution?
06:35:13 <jmg_> and i thould it would be nice to call one of thos
06:35:21 <mix25> This is make me wrong other cases
06:35:21 <jmg_> s/thould/thought/
06:35:23 <Deewiant> sure, plenty, that just came to mind
06:35:34 <edwardk> class Foo a b c | a b -> c, c a -> b, bc c -> a =)
06:35:42 <Deewiant> oh, do you want it to be true for [1,1,2] but false for [1,1,1]?
06:35:59 <jmg_> :-) i have a version with fundeps
06:36:12 <jmg_> but it needs five type paremeters to the class
06:36:29 <edwardk> you have the 3 mutual dependent things and what else?
06:36:49 <mix25> f [[2,3],[2,3]] = false, f [[1],[1,2],[2,3]] = true , and the solution with nub return false
06:36:57 <jmg_> and two other things which are determined by one the three ones
06:37:01 <edwardk> can the last two be made into class associated types from the first 3
06:37:32 <jmg_> i think so, yes
06:37:34 <Deewiant> > let f xs = xs == nub xs in f [[1],[1,2],[2,3]]
06:37:35 <lambdabot>  True
06:37:47 <edwardk> then that doesn't strike me as so bad
06:38:14 <jmg_> i hoped two would be enough
06:38:32 <jmg_> but i am proven wrong :(
06:38:49 <mix25> But my principal func doesnt return true for [[1],[1,2],[2,3]]
06:38:53 <edwardk> can each two determine the third in a uniform way?
06:39:04 <mix25> i need case when there is repeated elements
06:39:09 <jmg_> what do you mean by a uniform way?
06:39:42 <Deewiant> mix25: principal func? if you want f :: [[Int]] -> Bool to return false for repeated elements then f xs = xs == nub xs is what you want
06:39:56 <edwardk> i.e. does a b -> c, and b c -> a generate the same value for the 'odd term out'
06:40:01 * Heffalump reappears
06:40:07 <edwardk> heya heff
06:40:17 <edwardk> check scrollback, a phantom type fixed it
06:40:21 <Heffalump> I realised while having lunch that a helper function won't do, you'd actually need to put an a inside WRAP :-(
06:40:33 <jmg_> hi Heffalump
06:40:54 <mix25> but a element of [[Int]] is a list right? and maybe nub is delete the integer elements
06:40:57 <jmg_> edwardk: explained the problem to me and proposed a solution
06:40:59 <edwardk> heff: Phantom a -> P a -> GenericA. you don't need an a, just its type.
06:41:07 <Deewiant> mix25: nub works only at the top level, as you can see from its type.
06:41:13 <Heffalump> edwardk: oh, good point. Cunning.
06:41:16 <Deewiant> I have to go now, ask somebody else for more ->
06:41:26 <Heffalump> though in practice it probably has the same overhead as an undefined :: a
06:41:27 <mix25> bye and thanks
06:41:31 <hpaste>  (anonymous) annotated "various nub functions on unsafeperformio's blog won't work on streams" with "(no title)" at http://hpaste.org/7867#a1
06:41:35 <Heffalump> though perhaps not
06:42:49 <jmg_> edwardk: yes they determine everything in a uniform way
06:44:52 <edwardk> jmg: then one class Foo' a b c | a b -> c. and class (Foo' a b c, Foo' b c a, Foo' c a b) => Foo a b c
06:45:01 <edwardk> where Foo' does all the work
06:45:20 <jmg_> edwardk: if a b and c are the parameters, differenct c have the same shape for different b, therefore i wanted to share the datatype for c and parameterize it in b
06:45:55 <jmg_> edwardk: that's interesting
06:47:23 <jmg_> am i right that i would still define my functions in Foo, but Foo' would only provide the dependencies?
06:48:03 <edwardk> jmg: well depends on how you work. you could provide anything common to the ab -> c connection in Foo'
06:48:27 <edwardk> i use it a lot when doing type based 2s complement arithmetic
06:49:44 <edwardk> class TAdd a b c | a b -> c, a c -> b, b c -> a; instance (TAdd' a b c, TNeg b b', TAdd' c b' a, TNeg a a', TAdd' c a' b) => TAdd a b c
06:49:45 <jmg_> well, there aren't many operations i could define in Foo' since my types are to differetn
06:49:58 <edwardk> of course there i don't have any real member functions ;)
06:51:51 <jmg_> should class (Foo' a b c, Foo' b c a, Foo' c a b, c ~ T a) => Foo a b where { type T a} also work?
06:52:20 <edwardk> interesting idea i'd like to see it tried =)
06:52:31 <jmg_> i will try it soon
06:52:48 <jmg_> but i have to eat something first
06:53:12 <PeakerWork> what does "c ~ T a" mean?
06:53:16 <jmg_> thanks, for your help and the interesting discussion
06:53:29 <jmg_> PeakerWork: it's an equality constraint
06:53:46 <PeakerWork> type equality?
06:53:50 <jmg_> yes
06:53:59 <PeakerWork> then why not use (T a) in place of c in all those places?
06:54:41 <jmg_> then you would need the flexible contexts language extensions, but i'll try it
06:55:45 * jmg_ is away  
06:57:43 <doun> Arnia: durham university??
06:57:44 <PeakerWork> hmm.. the tunes project articles are so disconnected from ... everything
06:58:08 <Arnia> doun: yeah
06:58:23 <doun> Arnia: was the shower drains problem real or fake? =o
06:59:32 <Arnia> doun: The builders at both Butler College and Brooks House messed up the sewerage
06:59:46 <Arnia> doun: I'm at Brooks now actually
06:59:58 <doun> Arnia: ahh. hehe
07:01:03 <Arnia> (trying to read a book my supervisor wants me to by tomorrow)
07:32:03 <HairyDude> is it possible to write a function like:
07:32:04 <HairyDude> layouts :: [forall l. LayoutClass l a => l a] -> Choose l r a
07:32:37 <HairyDude> I tried that but ghc gave a parse error
07:32:40 <opqdonut> (LayoutClass l a) => (forall l. LayoutClass l a) -> Choose l r a
07:32:49 <opqdonut> that would be the correct typesig i think
07:32:59 <opqdonut> with relevant extensions enabled, of course
07:33:00 <HairyDude> erm, LayoutClass is a class
07:33:17 <HairyDude> not a type constructor
07:33:23 <opqdonut> asdf, i meant "(LayoutClass l a) => (forall l. l a) -> Choose l r a"
07:33:38 <opqdonut> no, wait, that's not right
07:33:44 <HairyDude> that wouldn't work, the l is quantified at two different places
07:34:13 <opqdonut> hmm
07:34:39 <HairyDude> I guess impredicative polymorphism only works for unconstrained types?
07:35:26 <opqdonut> might be
07:36:17 <opqdonut> no, the manual gives "g2 :: (forall a. Eq a => [a] -> a -> Bool) -> Int -> Int" as an example
07:37:42 <HairyDude> oh hang on, what I thought was a pragma was actually an ordinary comment :/
07:39:15 <HairyDude> unknown flags in  {-# OPTIONS #-} pragma: Rank2Types, ExistentialQuantification
07:39:17 <HairyDude> that's odd
07:39:24 <mauke> LANGUAGE
07:39:27 <HairyDude> oh, it should be LANGUAGE, doh
07:40:28 <HairyDude> hmm, seems foldr1's type can't deal with impredicativity
07:41:24 <Saizan> [forall l. LayoutClass l a => l a] <-- what do you intend this to mean?
07:42:07 <HairyDude> a list of things of type "l a" where l and a range over types that are instances of LayoutClass
07:42:31 <HairyDude> not sure if that was a satisfactory description
07:43:00 <Saizan> so, an heterogenous list?
07:43:06 <HairyDude> well in xmonad there is (|||) :: (LayoutClass l a, LayoutClass r a) => l a -> r a -> Choose l r a
07:43:08 <HairyDude> I just want to fold it
07:43:28 <HairyDude> Saizan: yes
07:43:47 <HairyDude> Saizan: but they are heterogenous to the extent that they are all instances of that class
07:43:58 <HairyDude> s/hetero/homo/
07:44:09 <Saizan> you need existential types for that.
07:44:11 <HairyDude> yes
07:44:15 <PeakerWork> what's the difference between (**) and (^)?  According to the types, it seems that ^ can only use integrals and Num's (*) so it probably uses those and (**) is a mathematical pow against anything - is that true?
07:44:32 <opqdonut> :t (**)
07:44:34 <vincenz> PeakerWork: yep
07:44:34 <lambdabot> forall a. (Floating a) => a -> a -> a
07:44:35 <opqdonut> :t (^)
07:44:37 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:44:41 <vincenz> > 5^5
07:44:43 <lambdabot>  3125
07:44:44 <vincenz> > 5^5.5
07:44:46 <lambdabot>  Add a type signature
07:44:47 <vincenz> > 5**5.5
07:44:48 <lambdabot>  6987.712429686842
07:44:55 <sclv> HairyDude: I guess you can just write foldr1 by hand. :-(
07:45:00 <opqdonut> PeakerWork: ^ is implemented using repeated squarings
07:45:01 <Saizan> and [forall l. LayoutClass l a => l a] is not a list of existentials, rather a list of polymorphic elements
07:45:01 <opqdonut> basically
07:45:08 <vincenz> > 5**(5.5)
07:45:09 <lambdabot>  6987.712429686842
07:45:11 <vincenz> > 5^(5.5)
07:45:12 <lambdabot>  Add a type signature
07:45:16 <vincenz> > 5^(5.5 :: Double)
07:45:17 <lambdabot>   add an instance declaration for (Integral Double)
07:45:17 <lambdabot>     In the expression: 5 ...
07:45:29 <PeakerWork> opqdonut, I see
07:45:31 <sclv> oh wait.
07:46:40 <sclv> yeah the polymorphism will only get applied once, no?
07:47:07 <Saizan> HairyDude: so you want data AnyLayout a = forall l. LayoutClass l a => AnyLayout (l a), then you can have [AnyLayout]
07:47:37 <sclv> then you have to manually coerce to existentials any time you want to use the function. yech.
07:47:49 <sclv> (sounds like a job for mapFromTuple!)
07:47:50 <Saizan> coerce?
07:47:57 <PeakerWork> @type mapFromTuple
07:47:59 <lambdabot> Not in scope: `mapFromTuple'
07:48:01 <sclv> sloppy writting -- wrap
07:48:29 <sclv> PeakerWork: mapFromTuple is my own hack. I find it v. convenient though it takes some work to set up.
07:48:41 <PeakerWork> you can also use a record of the things you need from each layout -- without existential types
07:49:21 <PeakerWork> sclv, Do you instantiate Functor on (), (a, a), (a, a, a), ...?
07:49:28 <sclv> http://fmapfixreturn.wordpress.com/2008/04/05/type-hackery-for-the-practical-programmer/
07:49:29 <lambdabot> Title: Type-hackery for the practical programmer  fmap fix return, http://tinyurl.com/6zyzwl
07:49:56 <sclv> its a bit fancier, but once you write the ugly boilerplate once, you can use it pretty generally.
07:50:10 <ski_> @src LayoutClass
07:50:10 <lambdabot> Source not found. My brain just exploded
07:50:14 <sclv> if anyone else actually finds the idiom useful I might turn it into a lib
07:50:29 <Saizan> sclv: is the Sat instance really useful? it seems like you could have just directly used another class
07:50:36 <sclv> the only really ugly bit is the onetuple.
07:51:02 <PeakerWork> There's a onetuple?  I thought (a) is a
07:51:11 <ski_> it is
07:51:23 <sclv> PeakerWork: no, there's not, that's why its ugly. you have to define your own.
07:51:29 <sclv> data Box a = Box a
07:51:58 <sclv> Saizan: hmm... Sat is how I managed to do it. if you think you can do it directly, give it a shot!
07:52:14 <PeakerWork> sclv, why do you need a one-tuple?
07:52:49 <sclv> what the Sat thing does (I think) is let you write the boilerplate once and then use it with many dictionaries for different mappings.
07:53:23 <sclv> PeakerWork: to distinguish an instance for one element from an instance for anything that's so general it swallows your other instances.
07:54:22 <Saizan> sclv: make MapFromTupleD a class and revert the explicit dictionary passing
07:54:38 <sclv> hmm... you might be right. I'll give that a try in my code.
07:55:21 <PeakerWork> sclv, when do you need mapFromTuple?
07:56:06 <sclv> any time you want to operate on a heterogenous set of things that share a typeclass
07:56:28 <sclv> (and hide the use of, eg, existentials, from your end user)
07:57:12 <PeakerWork> sclv, but a tuple is kinda clunky.. and repeats a lot of information in the type, and is difficult to manipulate, etc
07:57:19 <PeakerWork> (when used in place of a list)
07:57:32 <sclv> but that's the point of mapFromTuple
07:57:54 <Saizan> the point is to keep the type information about each element
07:58:01 <Saizan> which you lose with existentials
07:58:04 <sclv> It takes a tuple and turns it into a homogenous list. Then, after you've done your operations, if you know what you're doing, you can turn that back into a tuple.
07:58:19 <sclv> but that's never quite as simple.
08:01:06 <PeakerWork> I think the situations where you have "hetro lists" are mostly not ones you can put them in a tuple
08:03:11 <opqdonut> ?i MonadFix
08:03:11 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
08:03:16 <opqdonut> ?instances MonadFix
08:03:18 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:03:28 <opqdonut> sweet
08:03:45 <PeakerWork> @src MonadFix
08:03:45 <lambdabot> class (Monad m) => MonadFix m where
08:03:45 <lambdabot>     mfix :: (a -> m a) -> m a
08:04:07 <PeakerWork> @src State mfix
08:04:08 <lambdabot> Source not found. stty: unknown mode: doofus
08:04:20 <PeakerWork> @src Either mfix
08:04:20 <lambdabot> mfix f = let a = f $ case a of
08:04:21 <lambdabot>                         Right r -> r
08:04:21 <lambdabot>                         _       -> error "empty mfix argument"
08:04:21 <lambdabot>          in a
08:04:43 <sclv> Saizan: yeah, you were totally right about that sat cluttering everything up.
08:04:50 <sclv> So much nicer now. Thanks.
08:04:58 <Saizan> np :)
08:05:16 <sclv> you get too into an idea, you lose the forest for the trees
08:06:24 <sclv> PeakerWork: you'd be surprised actually by how much you can do with this though.
08:06:52 <PeakerWork> sclv, when is useful to hard-code a specific length of a tuple?
08:07:05 <sclv> when the user is doing it, not you.
08:07:28 <sclv> manly when marshalling data between formats -- validation, database queries, etc.
08:08:00 <Saizan> PeakerWork: anytime you use something like a record
08:08:23 <sclv> hlists are mainly used for records anyway, no?
08:09:13 <sclv> well, and for compile-time generics, but not in practice... I haven't seen them used for much else though.
08:09:18 <PeakerWork> hmm.. in that case you could say this is sort of a "record reflection"?
08:09:20 <Saizan> yeah, even if they support operations like append etc..
08:10:09 <sclv> its like 80% of the functionality you'd generally use at twice the boilerplate but 10% of the headexplote.
08:10:35 <sclv> s/explote/explode/
08:11:20 <HairyDude> what's the point in "let a = something in a"? why not just "something"?
08:12:37 <sclv> if its that simple I don't see a point, but in fancier things you can get types of sharing.
08:12:37 <Deewiant> HairyDude: so that you can refer to a within the something
08:12:37 <dcoutts> HairyDude: do you mean what's the point of let in general?
08:12:37 <dcoutts> it's about sharing the result of a computation
08:13:08 <dcoutts> or just for clarity
08:14:32 <HairyDude> ah right
08:14:32 <HairyDude> dcoutts: no, I was wondering about that particular case
08:14:47 <Heffalump> HairyDude: usually no point apart from code clarity or the result of some changes
08:15:13 <RayNbow> > let a = 1:a in a
08:15:26 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:16:52 <mux> > fix (1:)
08:16:54 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:17:07 <HairyDude> or even
08:17:11 <HairyDude> > [1..]
08:17:16 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:17:18 <mux> > [1,1..]
08:17:20 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:17:24 <HairyDude> @bot
08:17:27 <lambdabot> :)
08:17:27 <Deewiant> > repeat 1
08:17:28 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:17:30 <Deewiant> > cycle [1]
08:17:32 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:17:44 <HairyDude> fromEnum 1
08:17:50 <HairyDude> > fromEnum 1
08:17:52 <lambdabot>  1
08:18:06 <HairyDude> arr, what's [1..] sugar for
08:18:11 <HairyDude> > enumFrom 1
08:18:13 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:18:20 <mux> > enumFromThen 1 1
08:18:22 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:18:30 <HairyDude> that'S the one
08:18:40 <mux> since you wanted [1,1..] not [1..]
08:18:43 <HairyDude> yes
08:18:55 <HairyDude> TMTOWTDI :)
08:20:14 <mux> > [ 1 | _ <- [1..] ]
08:20:15 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:22:12 <OXIj> > repeat "x_X"
08:22:12 <lambdabot>  ["x_X","x_X","x_X","x_X","x_X","x_X","x_X","x_X","x_X","x_X","x_X","x_X","x_...
08:26:12 <RayNbow> > zipWith (-) [2..] [1..]
08:26:12 <mux> > concat $ intersperse " " (repeat "x_X")
08:26:17 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:26:17 <lambdabot>  "x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X...
08:26:17 <mauke> > intercalate " " (repeat "x_X")
08:26:17 <lambdabot>  "x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X x_X...
08:26:17 <Deewiant> > cycle "OM N"
08:26:17 <lambdabot>  "OM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM ...
08:27:42 <melkart> > [1,1.1..]
08:27:44 <lambdabot>  [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.50000000...
08:28:17 <vincenz> Cut the spam
08:31:41 <orbitz> > (\f x -> x : (f f x)) (\f x -> x : (f f x)) 3
08:31:42 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> a -> [a]
08:31:42 <lambdabot>     ...
08:31:48 <orbitz> drats
08:34:17 <Deewiant> > (\f x -> x ++ (f (f x))) (\f x -> x ++ (f (f x))) (++[1]) [0]
08:34:18 <lambdabot>  [0,1,0,0,0,1,1,0,0,1,1,1,1]
08:38:56 <litb> hello all
08:39:07 <litb> awesame: please add support for passing arguments to snippets :D
08:39:22 <litb> see how my program failed http://codepad.org/tJokRqJJ lol
08:40:17 <orbitz> this does't look like haskell..
08:41:09 <gubagem> line 74 you use a & and the rest of logical operators are ||
08:41:29 <litb> orbitz: codepaste understands haskell too. we would benefit from that too then =)
08:41:31 <edwardk> @seen ddarius
08:41:31 <lambdabot> I saw ddarius leaving #haskell, #haskell-blah, #haskell-overflow and #haskell-soc 7h 57m 42s ago, and .
08:41:45 <orbitz> gubagem: he also has ?: though
08:42:04 <litb> gubagem: yeah i just wanted to see whether there is any bit set, so the it equals to != 0 :)
08:42:16 <litb> err, then it means i mean
08:42:16 <orbitz> litb: i don't see the point. you can just pull th emain out and replace it with a call to yoru function wiht the testcase values
08:42:22 <lilac> line 75 contains a possibly-incorrect mix of &, || and <
08:43:02 <litb> lilac: it is just a test whether there is a bit set. i could aswell have done foo & DFRAC != 0
08:43:16 <gubagem> line 87, that looks a bit weird
08:43:18 <litb> but i wanted to keep it below a certan column width :D
08:43:23 <gubagem> but i guess you could do it
08:43:41 <orbitz> this is pretty gross C
08:43:45 <litb> gubagem: that is the horner scheme. not sure whether i did it right tho
08:44:16 <litb> orbitz: yeah, optimized for performance. i state on line 33 that it is not portable oO
08:44:41 <orbitz> litb: i don't tink your optimisations are the problem
08:44:43 <litb> anyway the math i use is not well chosen at all. i'm a math n00b oO
08:44:54 <orbitz> it's that the intentions o fthe code are ambigious
08:45:02 <litb> orbitz: oh
08:45:19 <litb> orbitz: you mean, chosing poor math on one side, but highly optimized code on the other side?
08:45:21 <orbitz> only on line 75 and already have a bunch of questsions on if you made a mitake or not
08:45:35 <orbitz> litb: no, in your codes intentions being am bigious
08:45:39 <gubagem> why dont you recode it in haskell :-)
08:45:39 <orbitz> one cannot tell if you made a mistake or not
08:46:05 <litb> orbitz: it means if the exponent is not maximal, but if any mantissa but is set, then it must be finite
08:46:13 <litb> orbitz: i forgot to comment that line oO
08:46:24 <orbitz> litb: some () would hav eben suficient to make yoru intentions clear
08:46:31 <lilac> orbitz: does it work?
08:46:34 <litb> orbitz: oh i see
08:46:39 <litb> indeed it works
08:46:43 <orbitz> lilac: what? i didn't uplad it
08:46:50 <lilac> orbitz: sorry, my bad :)
08:47:07 <litb> i forgot to return 0 at the end tho, missing the fact that gcc is not c99 by default
08:47:56 <litb> lilac: feel free to try it out. some code in it are from "P.J.Plauger C Standard Library"
08:48:06 <litb> be warned tho it may format your hard disk
08:48:46 <litb> the only line i'm not understanding yet is 218 :p
08:49:06 <litb> the code plauger did is highly smart i think
08:49:21 <lilac> code written by pjp tends to be that way
08:49:54 <litb> lilac: you mean smart, or do you mean cryptic?
08:50:18 <lilac> i'm sure he understands not only what it does, but also how and why.
08:50:28 <litb> lilac: sometimes it took me minutes to get what some lines do. i thought "hey i can optimize that" and later it turned out i'm wrong oO
08:53:32 <hpaste>  Zach Kozatek pasted "digit counting large numbers" at http://hpaste.org/7875
08:53:47 <gubagem> oh wow
08:53:50 <gubagem> it announces
08:54:09 <RayNbow> depends on whether you check a certain checkbox ;)
08:54:22 <gubagem> the thing stack overflows on count 1000000
08:54:34 <gubagem> so i am guessing its not tail recursive, which i have no idea how to do in haskell
08:54:54 <litb> orbitz: i believe that every platform dependend c code is gross :)
08:55:11 <gubagem> how long does stuff stay on hpase
08:55:37 <litb> hpaste souns like one hour :p
08:55:42 <lilac> gubagem: it overflows the stack because you're using foldr, i think
08:55:49 <Toxaris> gubagem: cheaters solution is length . show . yourNumber
08:55:59 <gubagem> no no
08:56:05 <gubagem> it counts each digit
08:56:12 <gubagem> and returns a tally of them
08:56:52 <gubagem> lilac: so would product [1..n] not overflow the stack?
08:57:11 <gnuvince_> gubagem: not if you compile with -O2
08:57:17 <gnuvince_> but in ghci, it will
08:57:32 <gubagem> mmmm
08:57:42 * gubagem comments on his code 
08:58:12 <gubagem> i did listmodify to get something like a one dimensional array
08:58:23 <Toxaris> gubagem: ok sorry, then I failed to understand your code
08:58:46 <gubagem> you have an 'array' of [0..9] all set to 0
08:59:01 <gubagem> everytime you get a digit from the head of the number
08:59:08 <gubagem> you add 1 to the proper slot in the array
08:59:41 <lilac> > let lg x = log x / log 10 in ceiling $ sum $ map lg [1..1000]
08:59:42 <lambdabot>  2568
09:00:14 <gubagem> factorial seems to give an even distriubtion over the digits once you go large enough, though the 0's are the exception, but im wondering if they would be 'normal' if i just chopped trailing 0's
09:00:22 <lilac> > length $ show $ product [1..1000]
09:00:24 <lambdabot>  2568
09:00:34 <gubagem> yea but how many 5's do you have
09:00:41 <gubagem> or 9's
09:00:49 <gubagem> or (insert digit here)'s
09:01:46 <gnuvince_> That sounds like a challenge :)
09:01:46 <Toxaris> gubagem: sounds like a job for accumArray
09:02:01 <Toxaris> gubagem: yes, there *are* arrays in Haskell :)
09:02:36 <Deewiant> > (\n -> let s = show n in [ length $ filter (== x) s | x <- ['0'..'9'] ]) (product [2..1000])
09:02:37 <lambdabot>  [472,239,248,216,229,213,231,217,257,246]
09:02:38 <lilac> you could probably write a lazy Integer which Did The Right Thing
09:03:08 <xerox> > map (id &&& length) . group . sort . show . product $ [1..1000]
09:03:09 <lambdabot>  [("0000000000000000000000000000000000000000000000000000000000000000000000000...
09:03:13 <gubagem> i was looking at Data.Array Data.Array(M?) and Data.Map
09:03:14 <xerox> yuck
09:03:20 <xerox> > map (head &&& length) . group . sort . show . product $ [1..1000]
09:03:21 <lambdabot>  [('0',472),('1',239),('2',248),('3',216),('4',229),('5',213),('6',231),('7',...
09:03:25 <Deewiant> > map (head &&& length) . group . sort . show . product [1..1000]
09:03:25 <lambdabot>        add an instance declaration for (Enum (f a), Num (f a))
09:03:28 <Deewiant> oops
09:03:34 <Deewiant> and slow, too
09:03:35 <Deewiant> :-P
09:03:41 <gubagem> Deewiant: did you just do it one line of code?
09:03:47 * gubagem blinks many times
09:03:48 <Deewiant> gubagem: as did xerox
09:03:56 <Deewiant> xerox's solution is better, though
09:04:20 <Deewiant> mine loops through the string 10 times to count each digit
09:05:22 <Toxaris> > accumArray (+) 0 ('0', '9') . flip zip (repeat 1) . show . product . enumFromTo 1 $ 1000
09:05:23 <lambdabot>  array ('0','9') [('0',472),('1',239),('2',248),('3',216),('4',229),('5',213)...
09:06:31 <gubagem> is Toxaris solution valid
09:07:03 <gubagem> ill guess it is
09:07:05 <Deewiant> seems to give the same results, at least :-P
09:07:12 <Toxaris> gubagem: well, all three solutions presented here produce the same result, so whats the problem?
09:07:30 <Toxaris> ok, that's not a strong definition of valid, I agree
09:07:35 <gubagem> none(im still waking up)
09:07:44 <gubagem> im amazed to say the least
09:08:02 * gubagem is a schemer
09:08:48 <paolino> show is abused ?
09:08:51 <gubagem> does lambdabot import some libraries, like my ghci doesnt have sort right out of the prelude
09:09:01 <b4taylor> It doesn't?
09:09:23 <xerox> yes
09:09:38 <b4taylor> Hmm, I guess it doesn't.
09:09:49 <Toxaris> gubagem: lambdabot imports a lot of libraries
09:09:54 <gubagem> ah
09:10:08 <Toxaris> gubagem: use http://www.haskell.org/hoogle/ to find out where funny functions live you learn about in #haskell
09:10:09 <lambdabot> Title: Hoogle
09:10:09 <Saizan> ?index sort
09:10:09 <lambdabot> Data.List
09:10:23 <gubagem> i know about hoogle
09:10:24 <xerox> gubagem, b4taylor - http://www.cse.unsw.edu.au/~dons/lambdabot/State/L.hs
09:10:29 * gubagem is truly lazy 
09:12:08 <lilac> i have a question...
09:12:33 <lilac> i want to write a function which returns a list, where the method of producing the next element depends on the caller
09:13:11 <mar77a> but you need a first element don't you
09:13:14 <lilac> i think i can do this by passing a list of instructions to the function, and somehow inserting the right element into that list when i want the next value, but i can't see how to make that work in general
09:13:16 <gubagem> pass in a function to the function
09:13:27 <mar77a> i think that's foldr :<
09:13:39 <mar77a> well something like that
09:14:13 <lilac> i think i need to have a pair of mutually-recursive lazy lists
09:16:43 <maltem> lilac, I think your description is too general for us to comment on it
09:17:47 <lilac> maltem: i agree. ok, more concretely. I want to compose two Parsec GenParsers: GenParser t1 s1 [t2] and GenParser t2 s2 x
09:18:32 <lilac> but i want to do so in a lazy, one-pass fashion
09:19:01 <maltem> how do you go from [t2] to x? A fold?
09:19:26 <lilac> no, a general parser over the t2's
09:19:40 <lilac> i'll run the first parser as many times as necessary to generate the input for the second
09:19:42 <maltem> Ah right
09:20:03 <Toxaris> lilac: the problem may be that Parsec is not lazy enough to produce a lazy token stream, but i'm not sure
09:20:22 <maltem> Parsec should be pretty lazy defaultwise?
09:20:31 <lilac> Toxaris: i've worked around that by calling runParser repeatedly, rather than calling runParser (many parser)
09:20:47 <maltem> oh, so it seems it isn't
09:21:04 <Toxaris> maltem: parsec doesn't return anything if there may be an error later
09:21:16 <lilac> no, sadly it returns an Either ParseError result, which means it needs to parse the whole thing in order to give any of the result
09:21:16 <maltem> I remember now
09:21:43 <lilac> ok, so that's the first problem, and my solution to that kind-of works.
09:21:59 <Toxaris> lilac: yeah sounds ok
09:22:04 <lilac> my second problem is that i actually have two GenParser t1 s2 [t2]s, and the one I want to use is context-dependent :(
09:22:49 <Toxaris> lilac: like "after this keywords, numbers are allowed in identifiers"?
09:22:50 <lilac> so I somehow want to create a list where the next member extracted by Parsec uses the right one of the two parsers
09:22:55 <lilac> Toxaris: exactly like that
09:23:36 <Toxaris> lilac: sounds like you really should considering writing only one big GenParser :)
09:23:55 <lilac> I'm thinking of something like: f parser:parsers t1s = let (result, t1s') = run parser t1s in result:f parsers t1s'
09:24:07 <lilac> and then somehow working out the parsers list as i parse
09:24:25 <lilac> Toxaris: that doesn't work very well. it'd be fine if my first parser was GenParser t1 s1 t2
09:24:43 <lilac> Toxaris: but parsers generating multiple tokens is not handled well by parsec
09:24:54 <lilac> Toxaris: or at least i've not figured out how to do that yet
09:25:03 <Toxaris> I see.
09:25:57 <Toxaris> there is no problem with mutually recursive lazy lists, of course, but how to extract the information out of the second parser which first parser he wants next
09:26:40 <lilac> yeah, i'm not entirely sure how i'd go about building the list on the fly in the second parser, or even whether that's possible
09:26:41 <Toxaris> is each chunk of t2 from one of first parsers completely processed by one call of the second parser, or is there a need for producing new t2 "in-between" the operation of the second parser?
09:27:49 <lilac> Toxaris: each chunk should be fully-consumed. (i think it's meaningless for the second pass to specify what sort of token it wants otherwise?)
09:28:37 <Toxaris> hmm yes. so make your second parser return (GenParser t1 s1 [t2], a) instead of just a?
09:29:08 <lilac> actually
09:29:11 <lilac> i take that back
09:29:50 <Toxaris> lilac: it is not meaningless, it's just hard to implement
09:31:33 <lilac> ok, returning [t2], a is not that hard. i think it's just something like p2 >>= (const getInput &&& id)
09:32:32 <Toxaris> yeah, or: fmap ((,) getInput) p2
09:33:20 <Toxaris> but does it help? I understand your "i take that back" so that the second parser has to communicate with the first-parser-choser even while parsing, which seems impossible because Parsec parsers can only communicate after parsing
09:33:43 <lilac> yes.
09:34:01 <lilac> i think i have to modify parsec to use something more interesting than a list as its token source
09:34:19 <Toxaris> sounds plausible :)
09:34:22 <Toxaris> isn
09:34:27 <Toxaris> isn't there someone doing exactly that?
09:34:39 <Toxaris> in the direction of ByteStrings and IO while parsing?
09:35:06 <paolino> ParsecT ?
09:35:36 <Saizan> lilac: see parsec 3
09:35:38 <lilac> data TokenSource state token = TokenSource { nextToken :: TokenSource -> state -> (state, token), tokenSourceState :: state }?
09:36:53 <Toxaris> where does parsec3 live?
09:37:07 <Saizan> hackage
09:38:40 <Toxaris> oh I confused the "other versions" field with "available version"
09:39:12 <wolgo> Should memoization be used with all recursive algorithms?
09:39:27 <lilac> wolgo: no
09:39:42 <wolgo> It would take lots of resources?
09:39:43 <lilac> wolgo: if they have repeated subproblems, maybe
09:39:45 <mauke> consider length
09:40:12 <wolgo> like fib
09:41:38 <wolgo> BRB INDIANA JONES!
09:47:22 <mix25> f [[Int]] -> Bool, f [[xs],[ys]] = False where ys = xs. Why when i invoke the func: f [[1,2],[1,2]] i get True?
09:48:03 <lilac> mix25: where clauses don't do that.
09:48:21 <mix25> How?
09:48:30 <lilac> mix25: where clauses are like let: the above defines ys to be xs within the function.
09:48:33 <mauke> because [[xs],[ys]] doesn't match [[1,2],[1,2]]
09:48:41 <mauke> this definition is never entered
09:48:56 <lilac> mix25: you can do what you want with pattern guards. f [[xs],[ys]] | xs == ys = False
09:49:08 <mauke> HELLO
09:49:14 <ddarius> Of course, that still wouldn't match.
09:49:17 <mix25> I dont use let here
09:49:21 <mix25> i'll try
09:49:25 <Botje> mix25: "where" is like let.
09:49:30 <Botje> and you compare lists by using ==
09:49:40 <mix25> hm
09:49:48 <Botje> so you probably want f [xs, ys] = xs /= ys
09:50:04 <Botje> unless you really want to pattern match on [[xs],[ys]]
09:50:15 <Botje> which means your function only accepts a list of lists with one element
09:50:23 <mix25> yes
09:50:30 <mix25> list of lists
09:50:34 <mix25> f [[Int]] -> Bool
09:50:53 <lilac> > let f [xs,ys] | xs == ys = False; f _ = True in f [[1,2],[1,2]]
09:50:54 <lambdabot>  False
09:52:00 <lilac> incidentally, has anyone thought about supporting: f [xs,xs] = True
09:52:17 <EvilTerran> lilac, it wouldn't be pretty
09:52:24 <lilac> i'm not sure it'd even work
09:52:28 <EvilTerran> although i guess it'd be a fairly simple transformation
09:52:30 <ddarius> lilac: Miranda did that.
09:52:34 <lilac> if it used Eq, which of the xs would you bind to?
09:52:41 <lilac> if it didn't use Eq, that'd be horrible
09:52:55 <EvilTerran> f (... x ... x ...) =  -->  f (... x ... x' ...) | x == x' =
09:53:19 <lilac> EvilTerran: so you'd arbitrarily bind to the first one? seems fair enough, i guess
09:53:24 <mix25> Damn it's still returning true
09:53:33 <EvilTerran> lilac, guess so, yeah
09:53:51 <EvilTerran> relying on the Eq instance to be sensible
09:54:15 <EvilTerran> that desugaring would mean there's a potential for large amounts of computation to sneak in via the implicit (==)
09:54:51 <mix25> Now is good :)
09:54:53 <mix25> Thanks
09:55:19 <EvilTerran> say, "let f x x = True in f [1..] [1..]" isn't obviously able to fail to terminate, but can
09:55:29 <mix25> Why [[xs],[ys]] /= [[1,2],[1,2]] ?
09:59:45 <EvilTerran> is xs = [1,2], then [xs] = [[1,2]]
09:59:51 <EvilTerran> *if xs = ...
10:00:07 <EvilTerran> [x] = x : []
10:00:17 <EvilTerran> ?type (\x -> [x])
10:00:21 <lambdabot> forall t. t -> [t]
10:01:52 <mix25> Ahm thanks
10:02:21 <Apocalisp> ?type Data.Foldable.foldM
10:02:22 <lambdabot> Not in scope: `Data.Foldable.foldM'
10:02:25 <Apocalisp> ?type Data.Foldable.foldMap
10:02:27 <lambdabot> forall a m (t :: * -> *). (Monoid m, Data.Foldable.Foldable t) => (a -> m) -> t a -> m
10:02:50 <Apocalisp> Does Monoid not take a type parameter?
10:03:11 <Apocalisp> ?src Monoid
10:03:11 <lambdabot> class Monoid a where
10:03:11 <lambdabot>     mempty  :: a
10:03:11 <lambdabot>     mappend :: a -> a -> a
10:03:11 <lambdabot>     mconcat :: [a] -> a
10:03:22 <EvilTerran> no. the closest thing that does is MonadPlus
10:03:25 <EvilTerran> (or Alternative)
10:03:45 <Apocalisp> ?src Monad
10:03:45 <lambdabot> class  Monad m  where
10:03:45 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
10:03:45 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
10:03:45 <lambdabot>     return      :: a -> m a
10:03:45 <lambdabot>     fail        :: String -> m a
10:04:47 <luite> I'm trying to install gtk2hs on windows, but the installer says that it cannot find a working ghc 6.8.1 installation. I have 6.8.2 installed, do I have to downgrade to 6.8.1 to use gtk2hs, or is there another way?
10:09:59 <lilac> what does the 'sometype' in this mean: class A b | sometype where ...
10:10:44 <lilac> it doesn't seem to be legal according to the report, so i'm guessing it's a ghc extension?
10:11:30 <Toxaris> lilac: that's functional dependencies
10:11:40 <Toxaris> lilac: the arrow in what you call "sometype" is not the normal function arrow
10:13:29 <Toxaris> class A a b | a -> b where ... means that for every a there is at most one b with instance A a b where ...
10:14:21 <Toxaris> this special knowledge can be used by the typechecker, e.g., if have a type (A Int b) => b -> b, and an instance A Int Bool is in scope, then the typechecker knows that b must be Bool
10:14:42 <lilac> ok, i see. so it says that the type b depends on the type a, but the value of b for a depends on the instance
10:14:50 <Toxaris> yes
10:15:11 <lilac> and presumably without it, things would be unnecessarily polymorphic
10:15:29 <Toxaris> if you write another instance A Int Char, the typechecker will complain that you've broken the functional dependecies.
10:15:31 <Toxaris> exactly
10:16:21 <lilac> ok, so the Stream s m t | s -> t in parsec3 is saying that the token type depends on (is uniquely determined by) the stream state type, for any instance of Stream. that makes sense. thanks!
10:22:18 <dcoutts> luite: here's a build for ghc-6.8.2: http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.12.1.exe
10:24:03 <luite> dcoutts: ah tnx, I was just trying to build it myself, but this seems to be less work ;)
10:25:01 <opqdonut> ghci now throws a type mismatch if i try to do "x <- m" where m is a non-IO monad action
10:25:23 <opqdonut> isn't this a known issue relating to 6.8 or something?
10:25:55 <EvilTerran> er... why should that work?
10:27:00 <opqdonut> it used to IIRC
10:27:25 <opqdonut> ah, yes, must be misremembering
10:27:53 <Baughn> It would be a bit neat, but..
10:29:59 <luite> dcoutts: hm, that one still complains about a non-working installation. do you know how I can check what's wrong?
10:32:36 <dcoutts> luite: it checks that the ghc detected reports the correct version
10:33:01 <dcoutts> luite: so check which ghc installation it found and make sure that's the one you expected
10:34:23 <dcoutts> luite: this is especially likely if you have an old ghc installation which still has the registry entries but no corresponding ghc installation
10:34:40 <luite> hm, I have only one ghc installation which reports: The Glorious Glasgow Haskell Compilation System, version 6.8.2
10:35:40 <dcoutts> luite: so the error message that says where the non-working version is installed is the one you expect?
10:36:44 <luite> it doesn't report any folder at all
10:36:49 <dcoutts> oh
10:37:08 <dcoutts> so it says "in the folder: "
10:37:12 <luite> yep
10:37:13 <dcoutts> luite: and it's just empty?
10:37:29 <luite> don't know whether there is a space after the colon though ;)
10:37:51 <dcoutts> it'd be on the following line
10:38:45 <dcoutts> so the installer is supposed to report that when calling ghc --numeric-version fails
10:39:31 <luite> ghc is in the path and seems to work fine from a cmd prompt
10:41:30 <dcoutts> luite: you can run the installer from a command prompt and get a log
10:41:37 <dcoutts> so you can see what it thinks its doing
10:41:55 <dcoutts> run it with /LOG=gtk2hs.log
10:44:30 <luite> ah. it does run the correct version, but says this: ExecOutput: running C:\Program Files\ghc\ghc-6.8.2\bin\ghc.exe failed, code: 1
10:44:59 <dcoutts> so it's the wrong path?
10:45:46 <dcoutts> luite: is there an obvious reason that should fail?
10:46:51 <obk> Where do you report a bug on a hackage package (specifically haskell-src)? E-mail directly to author or is there a standard place?
10:46:53 <luite> no the correct path. there are several executions of ghc.exe, the first one succeeds (or succeds ;) ): "ExecOutput: running ghc.exe succeded with output: C:/Program Files/ghc/ghc-6.8.2"
10:47:25 <obk> (Given the author is libraries@haskell.org anyway...)
10:47:29 <luite> dcoutts: I have no idea. I'm quite new to haskell and have only used ghci, not the compiler, but it's just a default installation in the default path
10:48:49 <dcoutts> luite: so does C:\Program Files\ghc\ghc-6.8.2\bin\ghc.exe exist?
10:49:01 <dcoutts> luite: or is that location of ghc.exe incorrect?
10:49:23 <luite> the location is correct. could it be a problem with spaces in the path?
10:49:27 <dcoutts> no
10:49:54 <mkemoor> any good hacker in here
10:50:03 <dcoutts> luite: so when you run C:\Program Files\ghc\ghc-6.8.2\bin\ghc.exe --numeric-version does it succeed?
10:50:54 <luite> dcoutts: only when I quote the first part, because of the space. it just prints 6.8.2 then
10:50:54 <dcoutts> mkemoor: lots
10:51:31 <dcoutts> luite: I dunno what's going on then. That's all the installer is doing, calling ghc to ask it the version number
10:52:03 <mkemoor> so tell me what u can do
10:52:09 <dcoutts> luite: do you know how to check the exit code of a program you run?
10:52:29 <dcoutts> luite: I can't remember, it's some windows command line env var
10:52:49 <dcoutts> luite: it might be that it's returning exit code 1 even though it does print 6.8.2
10:54:01 <dcoutts> mkemoor: perhaps you need to ask a more specific question :-)
10:54:16 <cinimod> I asked this earlier but there may be different people on #haskell now. Has anyone tried building data parallel haskell? I get the following error: http://www.haskell.org/pipermail/glasgow-haskell-users/2008-May/014793.html
10:54:17 <lambdabot> Title: Building ndp Problem, http://tinyurl.com/5grpuh
10:54:17 <mkemoor> ok
10:54:33 <mkemoor> do u do transfer
10:55:05 <dcoutts> cinimod: get happy and alex installed first
10:55:16 <dcoutts> cinimod: if the rpms don't work just install them manually
10:55:16 <cinimod> dcoutts: done
10:55:33 <cinimod> dcoutts: no problem with alex and happy
10:55:40 <luite> dcoutts: it exits with 0 when I use the --numeric-version option. with 1 without arguments
10:55:54 <dcoutts> cinimod: I don't know then, wait for one of the NDP hackers to reply
10:56:00 <luite> dcoutts: (had to look it up, the exit code is in the %ERRORLEVEL% environment variable)
10:56:01 <dcoutts> cinimod: did you send it to the ghc-users list?
10:56:12 <cinimod> dcoutts: when I do make make.library.ndp I get an error
10:56:33 <cinimod> dcoutts: yes but everyone must be washing their hair or maybe it's the bank holiday
10:56:42 <dcoutts> luite: I don't know what's going wrong then. It works for many other people with 6.8.2
10:57:12 <cinimod> dcoutts: I get make: *** No rule to make target `build.library.ndp', needed by `make.library.ndp'.  Stop.
10:57:17 <dcoutts> luite: and it was working with 6.8.1, I mean it was able to run ghc.exe to discover it was the wrong version.
10:57:52 <dcoutts> cinimod: problem is there are only really three people who work on ndp. Nobody else is going to be any better at debugging it that you are.
10:58:18 <dcoutts> cinimod: assume the instructions are out of sync and use your intuition
10:58:28 <cinimod> dcoutts: ok my "make" knowledge isn't good enough to debug quickly
10:58:42 <cinimod> dcoutts: I'll have a look tomorrow
10:59:00 <dcoutts> luite: the other odd thing is that it thought the path was ""
10:59:21 <luite> dcoutts: yes that's strange, but the log gives the correct paths
10:59:44 <dcoutts> luite: even the final log message about the non-working install at ...
11:01:34 * cinimod goes off to get a beer
11:01:48 <luite> dcoutts: I just tried to install it on my other pc (desktop), and it works fine there. The only differences I know of are that my desktop is vista x64, my laptop with the problems has x86. and ghc is installed in c:\ghc on my desktop
11:02:14 <dcoutts> luite: spaces in the path are no problem
11:02:28 <dcoutts> afterall the default location has a space in it
11:02:48 <luite> well, I'm not quite sure anymore that the default location of ghc is in program files, are you?
11:02:56 <dcoutts> luite: so it did work on vista x64? if so that's a first as far as I know :-)
11:03:06 <luite> yes did work, the installer at least
11:03:20 <dcoutts> luite: yeah, the default for ghc is under Program Files
11:04:27 <dcoutts> luite: in the log message is it still reporting the ghc install path as empty?
11:05:42 <dcoutts> luite: in the log message where it reports a non-woring installation of ghc
11:05:45 <luite> dcoutts: no it does log the correct location
11:05:54 <dcoutts> ok
11:07:04 <luite> the missing location in the gui could be a problem with my font settings though, I have a high resolution display in my laptop (150dpi) so I upped the dpi settings a bit to keep things readable. sometimes some text falls just outside the borders of textfields in programs that don't handle this correctly
11:07:18 <dcoutts> ah right
11:07:30 <dcoutts> luite: ok, try this...
11:08:23 <mauke> instance Default Spec where
11:08:24 <mauke>     def = Spec def def def def def
11:08:26 <mauke> whee
11:09:11 <Deewiant> def = fix . join . join . join . join $ Spec
11:09:24 <dcoutts> luite: command.exe /C C:\Program Files\ghc\ghc-6.8.2\bin\ghc.exe --numeric-version > tmp
11:09:38 <mauke> Deewiant: doesn't work, all of those defs have different types
11:09:50 <dcoutts> luite: that's what the installer is actually running, to capture the output. It then reads from the tmp file.
11:10:04 <Deewiant> mauke: sounds wonderful
11:10:38 <dcoutts> luite: actually I'm not sure if it's command.exe or cmd.exe
11:10:47 <Deewiant> cmd.exe
11:10:55 <Deewiant> and command.com in pre-NT windows
11:11:23 <dcoutts> the installer looks up some {cmd} name, so I dunno what it actually is
11:11:29 <Deewiant> (command.com still exists in later windows, though maybe not the 64-bit ones)
11:11:43 <luite> dcoutts: this only works when I quote the C:\Program Files part, because of the space
11:12:18 <dcoutts> luite: hmm, that's interesting. We do not quote anything.
11:13:17 <dcoutts> luite: I wonder why it works on other machines and not for you. You don't happen to have a C:\Program file or dir do you?
11:15:11 <luite> dcoutts: no (I also checked for hidden files)
11:15:56 <dcoutts> luite: I'm stumped
11:16:25 <dcoutts> luite: we probably should be quiting that arg but I can't explain why it doesn't work for one machine and works everywhere else
11:18:38 <luite> dcoutts: I just ran the ghc installer again and c:\ghc seems to be the default installation path. so there might be a remote change that it does have to do with my installation path after all? ;)
11:18:44 <luite> chance
11:19:16 <dcoutts> luite: actually yes, I guess it means for you that installing into a path without spaces might make it work
11:19:20 <RayNbow> luite: reliving the old days of DLL Hell? :p
11:19:39 <dcoutts> luite: though as I say, it does work on other machines for ghc installed in the default location
11:19:59 * dcoutts hates windows installers
11:20:02 * Baughn makes a fist at whoever decided to allow spaces in filenames
11:20:39 <dcoutts> Baughn: it's not so bad, except if you use stringy languages like... shells
11:20:50 <edwardk> @seen ddarius
11:20:50 <lambdabot> ddarius is in #haskell, #haskell-blah, #haskell-overflow and #haskell-soc. I last heard ddarius speak 1h 28m 22s ago.
11:21:02 * Deewiant makes a fist at whoever decided to put spaces in the default names of system directories
11:21:04 <Baughn> dcoutts: You're not being convincing here
11:21:17 <Baughn> Deewiant: The DOS name still works, doesn't it?
11:21:27 <Deewiant> sure
11:21:33 <luite> hm, changing the installation path in the registry to C:\PROGRA~1\ghc\gch-6.8.2 doesn't seem to fix it either, so I guess I'll just reinstall ghc then
11:21:36 <Deewiant> but I'd rather type "programs" than "progra~1" :-P
11:21:42 * Toxaris wants to throw in the fact that system directory names are localized on windows
11:21:45 <RayNbow> you can disable 8.3 support in XP if you want :p
11:21:48 <dcoutts> luite: that would work if ghc.exe was not on the path
11:22:05 <dcoutts> luite: since the installer looks for ghc.exe on the path first (to let you have multiple installs of ghc)
11:22:10 <Baughn> luite: Yep. Reinstall it to progra~1, and it might work
11:22:12 <luite> dcoutts: or if I also change the path to PROGRA~1 :)
11:22:20 <Apocalisp> What's the intent of foldMap?
11:22:22 <Deewiant> Toxaris: ugh, thanks for the reminder.
11:22:24 <Apocalisp> ?type foldMap
11:22:26 <lambdabot> Not in scope: `foldMap'
11:22:33 <Apocalisp> ?type Data.Foldable.foldMap
11:22:35 <dcoutts> luite: well, that's because ghc.exe --print-libdir returns a path with spaces
11:22:36 <lambdabot> forall a m (t :: * -> *). (Monoid m, Data.Foldable.Foldable t) => (a -> m) -> t a -> m
11:22:41 <luite> Baughn: argh I hate windows ;) or should I say program's that don't correctly handle spaces
11:22:58 <dcoutts> luite: but we only call ghc.exe --print-libdir for the case of ghc.exe on the path, not if we find the path via the registry
11:23:07 <Baughn> luite: But it's so incredibly easy to write them!
11:23:21 <Toxaris> well, to hate windows is one point, to tell that a software supports windows and it doesn't on my machine because it is, e.g., non-english, is another
11:23:22 <Baughn> I've found myself writing a little haskell script just to get rid of spaces in filenames
11:23:49 <Deewiant> and it only worked on filenames without spaces? ;-)
11:23:50 <dcoutts> luite: I wonder if XP->Vista changed the handling of parameters to cmd.exe
11:23:58 <Baughn> Deewiant: Initially. >_<
11:24:11 <Toxaris> XP->Vista changed AFAIK the handling of localized system directory names
11:24:16 <Baughn> Deewiant: That's why I switched it to haskell, actually
11:24:23 <Deewiant> heh
11:24:30 <Toxaris> the localized version is now a kind of magic link to the english one
11:24:38 <luite> too bad that vista hasn't changed the "Program Files" name to "Programs", it did change the "Documents and Settings" dir to "Users"
11:24:51 <Baughn> Toxaris: For "symlink" values of "magic"
11:24:53 <Deewiant> program files, at least, can be changed
11:24:57 <Baughn> The kludges are getting annoying
11:25:05 <Toxaris> Baughn: I don't understand links :)
11:25:17 <Deewiant> documents and settings I haven't managed to change since the kernel appears to depend on some files being there
11:25:18 <dcoutts> luite: I don't suppose you'vs got any old XP install around at all to test if it works to call: cmd.exe /C path with spaces in.exe
11:25:39 <Baughn> Toxaris: Neither does ms. They still haven't managed to make an OS where you can delete a file that's in use.
11:25:54 <dcoutts> luite: if that worked on XP and not Vista it'd explain the problem (I was only able to test on Win2k3)
11:26:14 <luite> dcoutts: I do have one xp install, without ghc though, I'll check
11:26:40 <Deewiant> dcoutts: doesn't work unless you wrap the path in quotes
11:27:08 <dcoutts> Deewiant: on XP?
11:27:18 <Deewiant> yep
11:27:21 <dcoutts> hmm
11:27:25 <Toxaris> the point is: I navigate to "c:\programme" (german for "program files") in my explorer using the mouse. The window says "c:\programme" and shows the contents of "c:\program files". now, i enter "c:\programme" by hand, and the explorer tells me that this directory doesn't exist. But if I enter "c:\program files" by hand, it is changed into "c:\programme" and the contents of "c:\program files" are shown.
11:27:41 <Toxaris> it's hard to figure out from this behaviour how the folder is actually named.
11:28:24 <luite> dcoutts: same error on xp yes
11:28:57 <dcoutts> luite: 'k
11:29:01 <Baughn> Toxaris: It /isn't/.
11:29:06 <dcoutts> luite: thanks for checking
11:29:31 <Baughn> Toxaris: They managed that trick by utterly mangling the appropriate syscalls.. and they did it differently for each of the three or so system calls capable of reading a directory
11:29:41 <Baughn> I think some of the code is in userspace, too
11:30:03 <dcoutts> luite: hopefully you can get it working with a ghc in a path without spaces. FIY, we'll be doing a new release soonish and the release manager this time has access to vista.
11:30:09 <Baughn> Toxaris: Now, if you want to know what'S actually on the disk, check it in linux
11:30:14 <Toxaris> Baughn: I would guess for "c:\program files", but it's just a guess. Why should I take the "keyboard input method" for real and the "mouse input method" not?
11:30:49 <Toxaris> Baughn: or do you mean "it isn't changed"? that was meant on the user-interface level. the location where I entered something shows something else after pressing enter.
11:31:15 <Baughn> Toxaris: No, I meant "it isn't named"
11:31:42 <Baughn> Toxaris: It does have a name on disk, obviously - though I wouldn't be surprised if they're hardlinking directories either - but there's no consistent name to use in software
11:31:58 <Toxaris> :(
11:32:11 <Baughn> @hoogle walk
11:32:11 <lambdabot> No matches found
11:32:26 <edwardk> @seen cale
11:32:26 <lambdabot> cale is in #ghc, #haskell and #haskell-overflow. I don't know when cale last spoke.
11:32:37 <Toxaris> interesting, my cmd.exe prompt shows no c:\programme, but I can cd into it and it is empty -- maybe leftovers of a failed pre-vista installer?
11:33:17 <Baughn> One can only hope
11:34:14 <luite> dcoutts: ok. the descenders (parts of letters below the base line, of 'g' etc) of the installation location of GHC where it reports the error are cut off, so the text field seems to be a bit small.
11:34:24 <luite> dcoutts: this is on my xp computer, with default dpi size
11:34:34 <RayNbow> I'm so glad the folder is still called "Program Files" in the Dutch version of XP :p
11:34:45 <ddarius> edwardk: What's up?
11:36:09 <edwardk> ddarius: i just realized that the 'monad generated by a functor' is just the codensity monad for that functor.
11:36:30 <ddarius> Yep.
11:37:01 <edwardk> ddarius: similarly the comonad generated by a functor is the density monad for the functor. it was a little obscured by the first term i encountered for the idea
11:37:06 <edwardk> er density comonad
11:37:21 <edwardk> anyways, Codensity is a much better monad transformer name ;)
11:37:48 <Baughn> > otherwise
11:37:50 <lambdabot>  True
11:37:52 <edwardk> going through and refactoring the (co)monad bits out of Control.Functor.KanExtension, like i did with the Yoneda bits
11:37:53 <wolgo> :t [1..]
11:37:54 <lambdabot> forall t. (Enum t, Num t) => [t]
11:38:00 <Baughn> > case False of True -> 1; otherwise -> 2 -- What?
11:38:01 <lambdabot>  2
11:38:23 <edwardk> that way codensity can be a monad transformer in a purer sense.
11:38:23 <wangor> hello, sorry I've got a function display :: [Char] -> DNap -> [Char], when I try to call this function like display "string" son, where son is of type DNap it tells me this:
11:38:33 <wangor> "*** Exception: drze.hs:17: Non-exhaustive patterns in function display
11:38:53 <Toxaris> > case False of True -> undefined; otherwise -> otherwise -- new binding!
11:38:55 <lambdabot>  False
11:38:59 <Deewiant> > let f [] = 1 in f "foo"
11:39:01 <lambdabot>   Non-exhaustive patterns in function f
11:39:04 <wangor> how can I explicitly tell him that parameter son is of proper type (that is DNap) ?
11:39:18 <ddarius> wangor: That's not the problem.
11:39:35 <ddarius> wangor: If it wasn't the correct type the code wouldn't have even compiled.
11:40:55 <luite> dcoutts: I reinstalled ghc into c:\ghc and it works fine now
11:40:58 <wangor> ddarius: well this type of parameter son is data DNap = Nil | Wezel String DNap DNap, prehaps this may be a problem ? it does compile, but I get exceptions in interpreter
11:41:07 <dcoutts> luite: great, sorry for the hassle
11:41:32 <luite> dcoutts: oh no problem. thanks for the help. I hope these things can now be fixed in the next release :)
11:41:42 <dcoutts> luite: me too :-)
11:42:37 <Toxaris> wangor: the error means that display is applied to the empty list, but only non-empty lists are processed; or that display is applied to Nil, but only Wezel is processed
11:42:55 * RayNbow hopes readline will be included in the Win32 distribution of GHC in the future :p
11:43:05 <ddarius> Toxaris: Or any of an infinite number of combinations
11:43:10 <Toxaris> wangor: so you have to think about which combinations of argument values are not handled by your patterns
11:43:52 <wangor> Toxaris: ok, thanks
11:45:12 <pgavin> has anyone here used the type-level library on hackage?
11:46:51 <Orphi> @yarr
11:46:52 <lambdabot> Swab the deck!
11:47:03 <Orphi> @seen dons
11:47:03 <lambdabot> dons is in #haskell, #xmonad, #haskell-soc and #ghc. I last heard dons speak 14h 23m 4s ago.
11:48:23 <Orphi> @seen dcoutts
11:48:25 <lambdabot> dcoutts is in #haskell, #gentoo-haskell, #haskell-soc, #haskell-overflow, #haskell-blah and #ghc. I last heard dcoutts speak 6m 42s ago.
11:48:32 <dcoutts> hello Orphi
11:48:33 <Orphi> getting warmer...
11:48:38 <Orphi> ...oh, there you are. :-)
11:48:44 <Orphi> hi Duncan
11:49:14 <wolgo> dualList ceiling = [[x] | x <- positiveList , x `mod` ceiling == 0]
11:49:36 <Orphi> I don't suppose you know the answer to this, but... ghc-core requires some random package called pcre-light, but it won't build. any ideas?
11:49:55 <dcoutts> Orphi: missing pcre.h?
11:50:04 <dcoutts> Orphi: try hpaste'ing your build error
11:50:07 <wolgo> factorsssss
11:50:12 <Orphi> dcoutts: er... ok.
11:51:06 <wolgo> YESSSSSS
11:51:11 <wolgo> oops
11:51:20 <hpaste>  Orphi pasted "pcre-light build error" at http://hpaste.org/7877
11:51:56 <wolgo> I finally solved one of these tests without looking at one of the previous answers to get an idea
11:52:17 <dcoutts> Orphi: the hint is:
11:52:23 <dcoutts> Text\Regex\PCRE\Light\Base.hsc:103:18:
11:52:23 <dcoutts>      pcre.h: No such file or directory
11:52:37 <ketil> I.e. install some pcre library?
11:52:37 <Orphi> dcoutts: Right. So what's pcre.h when it's at home?
11:52:51 <ketil> apt-cache search pcre?
11:52:53 <dcoutts> Orphi: it's the header file for the pcre library
11:53:23 <Orphi> dcoutts: Riiiight... OK. So this is a Haskell binding to some external library that I don't have?
11:53:29 <dcoutts> Orphi: so you need to make sure the pcre package is installed, including the development headers
11:53:52 <dcoutts> Orphi: exactly. Or at least you do not have the header files for it installed.
11:54:07 <Orphi> dcoutts: Did I mention that I'm on Windoze at this point?
11:54:24 <pgavin> dcoutts: I don't suppose you've used the type-level library, have you? :)
11:54:48 <dcoutts> Orphi: oh, then life is a bit harder. You'll have to find the pcre build for windows including the header files
11:54:52 <dcoutts> pgavin: nope
11:54:56 <pgavin> heh, ok :)
11:55:05 <Orphi> dcoutts: ah, sounds... nontrivial. :-}
11:55:18 <dcoutts> Orphi: sadly so
11:55:36 <Orphi> dcoutts: Still, this seems to be approximately what happens every single time I try to build any Haskell package... *sigh*
11:55:52 <dcoutts> Orphi: for packages that depend on C libs, yes.
11:56:10 <Orphi> dcoutts: I never did get libSDL to work - and I had the C lib installed! :-/
11:56:42 <Orphi> dcoutts: Still, I guess there's no denying that Unix is better set up for this kind of thing...
11:57:22 <dcoutts> Orphi: I'm afraid so, it's mainly the fact that all the C libs are available and in standard locations so that when they are installed we know where to look.
11:57:43 <dcoutts> Orphi: eg just installing libSDL on windows is not enough, we have to be able to find it to be able to use it.
11:58:12 <rizzix> ./join #scala
11:58:14 <wolgo> dualList ceiling = [[[x] | x <- (map negate negatedList) , ceiling `mod` x == 0]] This runs out of memory. I can avoid this by changing map negate negatedList to a list with a finite upper bound. Is there another technique?
11:58:26 <Orphi> dcoutts: So far, about the only C binding I've ever got to work is... Gtk2hs. ;)
11:59:01 <dcoutts> Orphi: and zlib works, but only because I bundle the entire zlib C source code for windows.
11:59:10 <wolgo> I assume that it happens because it creates a list of lists that goes to infinity and therefore running out of resources.
11:59:13 <dcoutts> most C libs are too complex to be able to do that
11:59:24 <wolgo> wait...
11:59:39 * Orphi abhors complex, brittle software
11:59:41 <wolgo> it keeps going after the number is >ceiling
11:59:45 <wolgo> nm
11:59:48 <Orphi> ah well, what can ya do?
12:00:23 <Orphi> http://gnuwin32.sourceforge.net/packages/pcre.htm
12:00:24 <lambdabot> Title: Pcre for Windows
12:00:31 <Orphi> wish me luck... :S
12:00:32 <wolgo> Oh. I can do [1..ceiling] :)
12:00:47 <luite> where does haskell look for the library files? I just installed the package 'binary' 0.4.2 with the cabal procedure, it ended up in C:\Program Files\Haskell\binary-0.4.2\ghc-6.8.2. but now another program that depends on this fails in ld because it cannot find -lHSbinary-0.4.2
12:01:27 <dcoutts> luite: there is a ghc package database that says where every package is installed
12:01:32 <luite> it really was the default location this time, I promise ;)
12:02:17 <dcoutts> luite: so if ghc-pkg knows about it then it should work. But it sounds like it is registered but the library file is missing for some reason
12:02:28 <Orphi> dcoutts: wanna take a while guess where I need to stick these files so Cabal will find them?
12:02:49 <Orphi> oo... I appear to have lost the ability to spell :/
12:02:51 <dcoutts> Orphi: if ghc can find them then Cabal can (since it calls ghc)
12:03:30 <Orphi> dcoutts: right... so where is GHC likely to look for C header files?
12:03:34 <dcoutts> Orphi: and ghc just calls gcc with any -I flags
12:04:21 <dcoutts> Orphi: you can hack the .cabal file and specify it, by adding include-dirs: and putting the dir where pcre.h lives.
12:04:44 <Orphi> dcouts: oh...kay...that sounds moderately scary... :-}
12:05:15 <dcoutts> Orphi: I say 'hack' because one shouldn't really have to change the .cabal file for different machines
12:05:37 <dcoutts> but in the version of Cabal you're using there's no way to pass in extra dirs to look in that might vary from one machine to another
12:05:48 <dcoutts> (there is such a feature in the latest version)
12:07:37 * Orphi unpacks multiple zip files
12:08:16 <Orphi> dcoutts: ok, pcre.h now lives in C:\Program Files\PCRE\include.
12:08:52 * Orphi stares at Cabal file in bewilderment
12:09:40 <shepheb> can someone recommend a next step theory-wise to someone with a decent handle on monads and functors, and a tenuous grip on the Bananas, etc. original *morphisms?
12:09:44 <dcoutts> Orphi: so add include-dirs: "C:\Program Files\PCRE\include"  to the library section
12:09:51 <dcoutts> Orphi: note the ""'s
12:10:22 <qwr> what that means: $* is no longer supported at /usr/lib/ghc-6.6.1/ghc-asm line 515.
12:10:43 <mauke> it means your perl is too new
12:11:03 <qwr> hmm, debian testing got some perl update
12:11:09 <qwr> HircBot.o:(.text+0x83): more undefined references to `__DISCARD__' follow
12:11:09 <qwr> collect2: ld returned 1 exit status
12:11:14 <mauke> 5.10, specifically
12:11:17 <mauke> 5.8.* is ok
12:11:27 <qwr> is that related to this perl error?
12:11:31 <mauke> probably
12:11:54 <qwr> lucky me :)
12:12:37 <wolgo> BRB!
12:12:45 <Orphi> dcoutts: well, I can see the file there, but Cabal still gives me exactly the same build error. :(
12:13:13 <Arnar_> good day folks..
12:13:59 <Arnar_> since my type theory book is still in the mail.. I was wondering if someone could give me examples of an additive type in Haskell..
12:14:09 <Arnar_> also.. what is Haskell's representation of a void type?
12:14:24 <Orphi> Arnar_: I'm guessing ()
12:14:28 <dcoutts> Orphi: so when you build with -v can you see Cabal calling ghc with -IC:\Program Files\PCRE\include ?
12:14:30 <Arnar_> Orphi: isn't that unit?
12:14:44 <dcoutts> Orphi: oh, clean first, then configure and try again
12:14:47 <[Justice]> (), which is the only value of type ()
12:14:59 <[Justice]> ()::()
12:15:03 <Arnar_> ok.. I thought () was the unit type
12:15:06 <mauke> Arnar_: data Void
12:15:09 <dcoutts> Orphi: I bet it's a .hsc file and so that would not get rebuilt
12:15:11 <[Justice]> it is the unit type
12:15:11 <mauke> (not H98)
12:15:18 <Arnar_> mauke: ah, thanks
12:15:36 <mauke> is an additive type the same as a sum type?
12:15:38 <[Justice]> that's what void is ...
12:15:39 <luite> dcoutts: I don't know what's wrong then, ghc-pkg describe gives the right library paths and the files are there.
12:15:41 * Orphi cleans the source tree
12:15:43 <Arnar_> mauke: yes.. I guess
12:15:50 <mauke> @src Either
12:15:50 <Arnar_> mauke: "additive" was my phrasing
12:15:50 <lambdabot> Source not found. My brain just exploded
12:15:54 <mauke> :(
12:15:59 <Arnar_> mauke: ok.. I know Either
12:16:02 * Orphi configures
12:16:02 <Arnar_> mauke: thanks
12:16:27 <Arnar_> mauke: so in terms of C, a product type is a struct and a sum type is union?
12:16:34 <mauke> I think so
12:16:36 <dcoutts> luite: the file you're looking for in particular is libHSbinary-0.4.2.a is in the library dir that ghc-pkg describe says
12:16:47 * Orphi builds verbosely
12:16:54 <Arnar_> mauke: makes perfect sense.. thanks
12:17:03 <Orphi> what the..........!! o_O
12:17:04 <[Justice]> ah that would make sense of the words "product type" and "sum type"
12:17:09 <lilac> Arnar_: if you think of types as sets of values, a product type is a set product, and a sum type is a set union
12:17:09 * Arnar_ is reading on the Curry-Howard isomorphism
12:17:10 <dcoutts> Orphi: works?
12:17:24 <Orphi> dcoutts: er... I *think* it might be confused by the space in the path...
12:17:26 <Arnar_> lilac: ah.. that explains
12:17:28 <mix25> Operator "/" in haskell returno this: 3/2 = 1 ?
12:17:41 <mauke> > 3/2
12:17:43 <lambdabot>  1.5
12:17:45 <dcoutts> Orphi: you did put the "" in the .cabal file right?
12:17:46 <mauke> that's a no
12:17:54 <[Justice]> :t (/)
12:17:55 <Orphi> dcoutts: yep, I quoted it.
12:17:56 <lambdabot> forall a. (Fractional a) => a -> a -> a
12:18:02 <Arnar_> lilac: rhymes perfectly with the logical counterparts of product = conjunction and sum = disjunction
12:18:11 <mix25> 3 `div` 2
12:18:15 <luite> dcoutts: yes, that dir contains the correct file.
12:18:17 <mix25> > 3 `div` 2
12:18:18 <lambdabot>  1
12:18:23 <hpaste>  Orphi annotated "pcre-light build error" with "More fun..." at http://hpaste.org/7877#a1
12:18:23 <mix25> :)
12:18:51 <mix25> :t @
12:18:53 <lambdabot> parse error on input `@'
12:18:59 <mix25> :i @
12:19:02 <[Justice]> what exactly are undecidable instances?
12:19:04 <dcoutts> Orphi: hmm, yes, that's not good :-)
12:19:15 <Orphi> dcoutts: I'll say...
12:20:04 <Orphi> dcoutts: silly question, but... has anybody ever tried paths with spaces before?
12:20:08 <andyjgill> Does anyone know a non-unix specific way of catching control-C inside (ghc) threading code?
12:20:14 <luite> Orphi: check ;)
12:20:51 <dcoutts> Orphi: depends. For ghc install, certainly. For other stuff, it's probably less tested. But we're not using silly stringy opps so it usually works.
12:21:18 <Orphi> dcoutts: should I post the edited Cabal file just so we can confirm I'm not going mad?
12:21:48 <EvilTerran> > {- mix25 -} let xs@(x:ys) = [1,2,3,4] in (xs, x, ys)
12:21:48 <luite> I'm afraid that my library-problem might be spaces-related again? is there a way to change the (default?) install location for cabal builds?
12:21:50 <lambdabot>  ([1,2,3,4],1,[2,3,4])
12:22:04 <dcoutts> Orphi: oh, wait, you'll need to use Haskell String syntax, so that means escaping the \\'s
12:22:15 <Orphi> dcoutts: ....!! o_O
12:22:16 <EvilTerran> it lets you name a part of a pattern as well as match inside it
12:22:22 <Orphi> dcoutts: OK, that makes a difference...
12:22:33 * Orphi escapes backslashes
12:22:36 <dcoutts> luite: you can set the --prefix when you configure
12:23:20 <Arnar_> [Justice]: undecidable instances are instances on which the type checker would loop indefinately, unless using some tricks (I think)
12:23:21 <Orphi> dcoutts: OK, now a get a completely different error. :-)
12:23:28 <Arnar_> [Justice]: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#undecidable-instances
12:23:31 <lambdabot> Title: 8.6. Class and instances declarations, http://tinyurl.com/245leb
12:23:33 <dcoutts> Orphi: heh :-) I guess that's good
12:23:52 <Orphi> dcoutts: It seems ld can't find something.
12:24:08 <Orphi> dcoutts: I guess I only told it where the headers are. *sighs*
12:24:29 <dcoutts> Orphi: yeah, you'll be having the equivalent problem with the lib
12:24:39 <dcoutts> Orphi: extra-library-dirs: ...
12:25:08 <luite> dcoutts: ok, thnx. it works now, in a new location without spaces
12:25:23 <[Justice]> ty
12:25:44 * Orphi does the clean/configure/build dance
12:25:51 <dcoutts> luite: so what do you think was wrong? we were passing the wrong path to ld?
12:26:57 <Orphi> dcoutts: uh... Cabal doesn't appear to like that field name. (Have I got it in the right section?)
12:27:30 <luite> dcoutts: I don't know, the old path was "C:\\Program Files\\Haskell\\binary-0.4.2\\ghc-6.8.2", the new one does not have the double backslashes, and the new path does not have a space. I'm not sure which of those caused the error
12:28:42 <Orphi> dcoutts: wait... it's "extra-lib-dirs", not extra-library-dirs :-P
12:29:27 <Orphi> OMG! It build something!! o_o
12:29:32 * Orphi sits down
12:30:09 <Orphi> prce-light is now installed. yay.
12:30:15 <dcoutts> luite: hmm
12:30:22 <Orphi> now let us see what other dependencies ghc-core is going to fail on...
12:30:44 <orbitz> Orphi: i can't wait!!
12:30:58 <Orphi> ...ah, hs-colour. obviously.
12:31:06 <edwardk> ddarius: finally got the density/codensity stuff factored out. i feel 'dense' for not proving that earlier.
12:31:18 <ddarius> edwardk: Code?
12:31:55 <edwardk> http://comonad.com/haskell/category-extras/src/Control/Monad/Codensity.hs
12:31:56 <lambdabot> http://tinyurl.com/5rb3ll
12:32:09 <edwardk> http://comonad.com/haskell/category-extras/src/Control/Comonad/Density.hs
12:32:09 <lambdabot> http://tinyurl.com/5pzotj
12:32:54 * Orphi gasps as hs-colour builds and installs flawlessly first time
12:32:57 <edwardk> i found it interesting that the term i was using 'monad generated by a functor' seems to have primacy over the more common 'codensity' term by a couple of years.
12:32:58 <edwardk> ;)
12:33:00 <dons> Orphi: you should install 'cabal-install', and let the tool resolve the dependencies for you. or at least become familiar with hackage.
12:33:03 <Orphi> obviously 100% pure Haskell ;-)
12:33:38 <Orphi> dons: ah, Don - the guy who suggested I should "just install ghc-core" in the first place :-}
12:33:42 <dcoutts> Orphi: heh, you'd get the privilege of testing cabal-install for us on Windows
12:33:54 <edwardk> ddarius: and the kan extension stuff (now simpler since the (co)density bits were factored out: http://comonad.com/haskell/category-extras/src/Control/Functor/KanExtension.hs
12:33:54 <lambdabot> http://tinyurl.com/5o84vg
12:33:55 <dons> Orphi: hang on, aren't you on windows?
12:33:56 <Orphi> dcoutts: er... yay for me! (?)
12:33:58 <dcoutts> dons: poor Orphi is stuck on windows
12:34:02 <dons> ghc-core's not going to run there anyway.
12:34:06 <dons>         x <- readProcess "sh" ["-c","ls /tmp/ghc*/*.s | head -1"] []
12:34:13 <Orphi> dons: oh, NOW you tell me! >_<
12:34:32 <dcoutts> dons: tut, you can do better than that
12:34:32 <dons>     bracket
12:34:32 <dons>         (openTempFile "/tmp" "ghc-core-XXXX.hcr")
12:34:41 <dons> dcoutts: well, tmpdir definitely
12:34:46 <dcoutts> and ls
12:35:11 <dons> but its up to one of the windows devs to sort out the details with pagers and where the .s files go
12:35:13 <dcoutts> dons: can't you direct ghc to output the core file somewhere specific anyway?
12:35:25 <dons> its not the core, that's fine. its the .s files
12:35:34 <dcoutts> dons: oh the assembler?
12:35:37 <dcoutts> dons: then use -o
12:35:40 <edwardk> i really like the 'Density' code, its er.. quite dense
12:36:04 <Orphi> bahahahahaha!
12:36:15 <Orphi> ghc-core builds and installs, but crashes instantly when run.
12:36:24 <Orphi> ...it can't find the DLL for pcre
12:36:29 * Orphi slaps head
12:36:36 <dcoutts> Orphi: that'd have to be on the %PATH%
12:36:46 <dcoutts> that's the other problem with windows and C libs
12:36:53 <Orphi> dcoutts: riiiiight... ok...
12:36:55 <edwardk> ddarius: i may factor limits/colimits out into another newtype as well so i can define what instances i can for them
12:37:03 <dcoutts> or it'd have to be in the same dir as the .exe you're running
12:37:09 * Orphi frobnicates environment variables
12:38:04 * Orphi attempts to guess which of several subfolders needs to be added
12:38:51 * Orphi guesses correctly
12:39:16 * Orphi facepalms
12:39:27 <Orphi> OK, this has got to go on hpaste...
12:40:29 <ddarius> edwardk: Do you have the (co)end stuff anywhere?
12:40:54 <hpaste>  Orphi pasted "ghc-core is fun" at http://hpaste.org/7878
12:41:04 <edwardk> i make a passing reference to End (LanT f g a) in a comment in KanExtension, and Control.Functor.End has definitions for Ends and Coends
12:41:25 <edwardk> i decided not to actually build Ran and Lan out of Ends and Coends because it would impose overhead on Lan.
12:42:09 * Orphi hunts around for some actual documentation
12:42:09 <shepheb> I'm wondering where to go next, theory-wise.
12:42:14 <ddarius> Yeah, I was more wondering if you have an End and Coend section, I wouldn't use them for Kan extensions.
12:42:47 <edwardk> yeah i have those, i have limits and colimits in as well using a trivial functor that serves the purpose of !.
12:43:05 <edwardk> its actually shaping up quite nicely as a library
12:43:17 <Orphi> dons: If ghc-core was actually working, how would I use it anyway?
12:43:26 <ddarius> I'm not sure if it's best, but you can get (co)limits easily from adjunctions.
12:43:43 <ddarius> Er I meant (co)ends.
12:43:50 <edwardk> right now they are type Limit = Ran Trivial
12:44:08 <edwardk> hrmm?
12:44:46 <ddarius> LimD = End_X(D(X))
12:45:21 <edwardk> ah sure.
12:45:51 <edwardk> i was actually thinking about since i was going to go through and newtype limits, they just become existential and universally quantified boxes more or less.
12:46:01 <Orphi> dcoutts: is there any documentation on getting C bindings to work under Windows?
12:46:05 <ddarius> Yep.
12:46:12 <Orphi> dcoutts: I surely can't be the first person to struggle with this...
12:46:13 <dcoutts> Orphi: not really
12:46:22 <edwardk> forall b. h b and exists b. a * h b
12:46:26 <dcoutts> Orphi: it's not a Haskell specific thing really
12:46:27 <Orphi> dcoutts: hmm... time for a wiki entry, eh?
12:46:31 <RayNbow> > scanl1 (*) [1,x,x,x,x] :: [Expr]
12:46:38 <Orphi> dcoutts: reconfiguring Cabal is.
12:46:48 <lambdabot>  thread killed
12:46:59 <dcoutts> Orphi: one improvement we've made is that you can now pass the extra include and lib dirs as flags to configure
12:47:07 <dcoutts> Orphi: rather than hackign the .cabal file
12:47:16 <Orphi> dcoutts: OK, well that's an improvement...
12:47:32 <Orphi> dcoutts: let me guess - next GHC release?
12:47:38 <edwardk> kind of troubled by the asymmetry of the a term there, but it makes sense because we're in a constructive setting and so can't reconstitute a in the Limit case.
12:47:57 <dcoutts> Orphi: Cabal-1.3.x
12:48:11 <dcoutts> Orphi: ie in the devel version of Cabal, and it'll be in 1.4
12:49:13 <Orphi> dcoutts: probably still merits a document somewhere explaining how to do this stuff ;-)
12:49:33 <Orphi> dcoutts: OOC, does Cabal have a manual as such?
12:49:41 <edwardk> Should the a term exist in the colimit? it drops out from the derivation in terms of ! anyways, because an 'existential' in a category with only one candidate lets you select a value.
12:49:52 <dcoutts> Orphi: yep, it's in the user guide
12:50:59 <edwardk> i find it somewhat odd that, say the colimit of a list gives you an 'a' even when the list is empty. and that the strength of haskell functors lets you go through and drop that singular 'a' into all the existential 'b' place holders in your structure. so you can view a colimit as a structure where all the placeholders contain the same value, and if the structure is empty still gives you a selected value
12:51:43 <edwardk> that says the colimit of some functors probably gives me a comonad. (it is at least always copointed)
12:52:56 <Orphi> dcoutts: ah, ok. I never noticed that was there...
12:53:47 <edwardk> ddarius: or am i making a mistake in my derivation of the colimit?
12:54:30 <hpaste>  morrow annotated "digit counting large numbers" with "(no title)" at http://hpaste.org/7875#a1
12:55:55 <mix25> >let x:xxs:xss in [1,2,3,4,5,6,7]
12:55:58 <mix25> > let x:xxs:xss in [1,2,3,4,5,6,7]
12:55:58 <lambdabot>  Parse error at "in" (column 15)
12:56:06 <ddarius> edwardk: Where is this 'a' coming from?
12:56:11 <mix25> > let (x:xxs:xss) in [1,2,3,4,5,6,7]
12:56:11 <lambdabot>  Parse error at "in" (column 17)
12:56:25 <edwardk> ddarius: thats what i was afraid you'd say =)
12:56:30 <sioraiocht> mix25: let statements have to be assignmengts
12:56:33 <sioraiocht> *assignments
12:56:37 <edwardk> ddarius: if we take the left kan extension definition from before:
12:56:48 <kaol> > let (x:xxs:xss) = [1,2,3,4,5,6,7] in (x,xxs,xss)
12:57:03 <lambdabot>  thread killed
12:57:07 <sioraiocht> weird...
12:57:16 <kaol> > let (x:(xxs:xss)) = [1,2,3,4,5,6,7] in (x,xxs,xss)
12:57:31 <lambdabot>  thread killed
12:57:37 <ddarius> edwardk: I see what happens.
12:57:38 <gwern> dcoutts: so there was a funny conversation on yi-devel the other day - 'I can't compile yi, it wants cabal 1.5.1 which doesn't exist'
12:57:45 <edwardk> data Lan f g a = forall b. Lan (f b -> a) (g b)   and we substitute in a trivial functor to a category with only one morphism and one object (!) for f, we get (!b -> a) (g b)
12:57:51 <sioraiocht> Prelude> let (x:xxs:xss) = [1..7] in (x,xxs,xss)
12:57:52 <sioraiocht> (1,2,[3,4,5,6,7])
12:57:56 <edwardk> well, i can pick b, coz i know it exists and there is only one candidate!
12:57:58 <orbitz> why did lambda bo not like that?
12:58:05 <sioraiocht> no idea...
12:58:40 <edwardk> ddarius: so is there a bug in my Lan or does that a term actually need to exist?
12:58:49 <dcoutts> gwern: they should really be depending on Cabal >= 1.3.10 && < 1.5
12:59:15 <dcoutts> gwern: I hope to get Cabal-1.4 out some time soon, but I need to test it pretty heavily
12:59:27 <dcoutts> gwern: I'm working on the testing infrastructure atm
12:59:35 <Peaker> I wonder if it is practical to have dependencies on certain features rather than specific versions - allowing more flexibility with backports/etc, and more descriptive dependencies
12:59:46 <ddarius> The issue is the Trivial functor is (or rather should be) Hask -> 1 not Hask -> Hask, so 'a' would have to come from that category
12:59:59 <ddarius> That's why LimD is an object not a functor.
13:00:12 <ddarius> ColimD
13:00:13 <lehka> :-*
13:00:23 <ddarius> via the Kan extension it is a functor 1 -> C
13:00:25 <edwardk> ah, so the a shouldn't be there and is only an artifact of the encoding
13:00:54 <lehka> 
13:01:08 <Beelsebob> nreeva?
13:01:46 <lehka>  Beelsebob hello
13:02:10 <edwardk> hrmm
13:02:37 <edwardk> but given a functor from 1 -> C, i can 'get the element in C' that is the image of the singular object in 1, can't I?
13:02:40 <edwardk> that would be 'a'
13:03:23 <ddarius> I'm saying ColimD (via the Kan extension) is a functor 1 -> C, i.e. Lan_! D(1) = ColimD
13:03:27 <edwardk> ok
13:03:32 <Beelsebob> lo lehka
13:03:38 <edwardk> so it should have the properties described then
13:03:39 <edwardk> ok
13:04:33 <ddarius> Hom(!X,1) is the unit set so Lan_! D(1) = Coend(Hom(!X,1)xDX) = Coend(1xDX) = Coend(DX) = ColimD
13:04:52 <lehka> Beelsebob mai frend      spik
13:05:54 <lehka> edwardk      mai frend
13:06:05 <edwardk> lehka: ?
13:06:07 <Beelsebob> you want a word in my ear?
13:07:05 <lehka> Beelsebob meny ear
13:07:10 <Peaker>      
13:08:05 <lehka> Peaker you     
13:08:15 <Beelsebob> lehka: as you can see, my Russian isn't great
13:08:21 <edwardk> lehka:    
13:08:23 <Peaker> I wrote in Hebrew: "what's with all the russian here"?
13:08:25 <Beelsebob> better than the average Scotsman's though
13:08:33 <gwern> Peaker: possible - that is how autotools does things
13:08:34 <gwern> is that good? well...
13:08:51 <ddarius> #haskell_ru / #haskell.ru
13:08:55 <edwardk> yeah
13:08:59 <sioraiocht> are we playing the talk in foreign languages game?
13:09:16 <lilac> naturallement
13:09:18 <arw__> anscheinend...
13:09:20 <edwardk> sioraiocht: I'd rather not =)
13:09:21 <lehka> edwardk good spik russian
13:09:30 <sioraiocht> hahha
13:09:36 * sioraiocht doesn't have any russian.
13:09:45 <Peaker> privet!
13:10:00 * sioraiocht only speaks useless languages.
13:10:11 <Beelsebob> Ik ben worknig op mijn vlams, but then, I've moved to Belgium
13:10:18 <ddarius> edwardk: Here's an small exercise.  Let P : S -> Set where S is a set considered as a discrete category.  Let K1 : S -> Set be the constantly 1 functor.  Describe what the left Kan extension of P along K1 is.
13:10:59 <lehka> Beelsebob      mai frend
13:11:06 <mix25> ? div
13:11:25 <edwardk> ddarius: my intuition for kan extensions at this point is pretty much purely 'how it fits into Haskell', but hrmm.
13:11:48 <lehka>   
13:11:52 <Armored_Azrael> Hey, does anyone know how to get ghc to work with a gcov'd .o file from C?
13:12:10 <ddarius> edwardk: It may be helpful to s/Set/Type
13:12:29 <obk> Is there any way to get Language.Haskell.Parse to respect operator precendence and associativity?
13:12:40 <lament> lehka: ne pizdi pozhalusta, ty haskell-hot' znaesh?
13:12:45 <lehka> hello hello hello 
13:12:47 <edwardk> lehka:       #haskell.ru
13:13:00 <lament> edwardk: he says nothing but dirty insults
13:13:06 <lilac> in parsec3, is there any point in having a 'user state'? can't the same be achieved by combining the ParsecT monad with the State monad?
13:13:10 <lament> i don't think he actually wants to talk about haskell in any language
13:13:12 <edwardk> then i guess it shouldn't be spoken at all ;)
13:13:33 <ddarius> @where ops
13:13:33 <lehka>  hello
13:13:33 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
13:13:44 <edwardk> @seen vincenz
13:13:45 <lambdabot> vincenz is in #haskell. I last heard vincenz speak 4h 45m 36s ago.
13:13:50 <dcoutts> hmm?
13:14:10 <dcoutts> ddarius: ?
13:14:21 <ddarius> lehka is spewing random Russian.
13:14:27 --- mode: ChanServ set +o allbery_b
13:14:52 <plutonas> about how long should i expect the ghc build on a pentium m 1.8? Is already running about an hour (with dependancies)
13:14:58 --- mode: allbery_b set +b *!*@89.112.19.44.pppoe.eltel.net
13:14:58 --- kick: lehka was kicked by allbery_b (allbery_b)
13:15:10 --- mode: allbery_b set -o allbery_b
13:15:19 <lament> those russians.
13:16:19 <Peaker> has anyone here implemented an iteratively deepening AI/algorithm in Haskell?
13:16:39 <edwardk> peaker: i have some iterative deepening haskell code somewhere
13:16:49 <Peaker> edwardk, I am toying with some chess AI
13:16:53 <Peaker> edwardk, I suppose that's the right way to do it
13:17:03 <Peaker> edwardk, I am wondering about an elegant way to put that into Haskell
13:17:27 <edwardk> using MTD(f) and zobrist hashing?
13:18:00 <Peaker> edwardk, I don't know what those are :)
13:18:10 <edwardk> @where zobrist hashing
13:18:10 <Peaker> I don't know anything about chess AI, but I have written AI's for other turn-games
13:18:10 <lambdabot> I know nothing about zobrist.
13:18:15 <edwardk> @google zobrist hashing
13:18:16 <lambdabot> http://en.wikipedia.org/wiki/Zobrist_hashing
13:18:26 <edwardk> @google MTD(f)
13:18:28 <lambdabot> http://www.cs.vu.nl/~aske/mtdf.html
13:18:28 <lambdabot> Title: Aske Plaat: MTD(f), a new chess algorithm
13:18:36 <edwardk> that should get you a starting point ;)
13:19:23 <Peaker> I don't want a fancy AI.. I wonder mainly how good a simple iterative deepening algorithm can be
13:19:43 <edwardk> tricky to code properly in haskell though coz your core speed trick requires bit twiddling on the transposition table.
13:20:33 <Peaker> edwardk, that does seem like its basically doing an iterative deepening
13:21:25 <edwardk> you can probably get a simple iterative deepening engine to run at ~1500 FIDE pretty easily.
13:21:49 <lilac> suppose i have "class X a b | a -> b", and i want "data (X a b) => Y a = Y a", how can i do this?
13:21:50 <Peaker> I mainly want it to be simple/small Haskell code :)
13:22:06 <edwardk> yeah MTD(f) is a little tricky though because it iteratively deepens, AND binary seerches for an expected board score.
13:22:32 <Peaker> edwardk, why does it binary search for an expected board score?
13:22:38 <edwardk> the binary search is where its speed comes from because it drastically cuts its branching factor, in exchange for requiring a fairly coarse scoring
13:22:53 <edwardk> how well do you know alphabeta/minimax/etc?
13:23:14 <edwardk> ddarius: i'll switch gears back momentarily i promise ;)
13:23:34 <Peaker> edwardk, I implemented them several times
13:23:47 <Peaker> edwardk, minimax, not sure about alphabeta
13:24:07 <Peaker> edwardk, (basically a recursion to some constant depth, and then returning a heuristic evaluation of the board there, and negating at each recursion level and max'ing between those)
13:24:33 <edwardk> ok, start with alphabeta because that gives you the first 'speed boost' and its trivial to upgrade. you can show that you don't need to consider certain branches any further because it can never give you a better score than a branch you've already considered.
13:24:54 <Peaker> edwardk, how can you show that when all you have is a heuristic evaluation?
13:25:12 <Peaker> edwardk, only if you got a win can you know that - but then you don't need to scan anymore
13:25:17 <edwardk> very simple actually. its just a property of min and max
13:25:27 <luite> Peaker: it's similar to branch and bound, maybe you know that from optimization
13:25:45 <edwardk> peaker: start here: http://en.wikipedia.org/wiki/Alpha-beta_pruning
13:26:01 <Peaker> I don't know branch and bound.  But in a complex game like chess - how can you have a min/max bound on the value of a move that is not heuristic (except for loss/win)?
13:27:11 <Peaker> If I understand  http://en.wikipedia.org/wiki/Alpha-beta_pruning   correctly, its something that I ofcourse already had done - stop scanning when I found a win (others are necessarily <= win) - is that all there is to it?
13:27:15 <luite> Peaker: think of it this way: what good is it to look at the other moves your opponent can make when there is one that makes him win immediately?
13:27:36 <phobes> Peaker:  It's more than just that
13:27:43 <edwardk> peaker: trust us, it works. its just the math based on the scoring function of the board positions. min(max(1,2),max(3,4)) ok, so we evaluate min(2,max(3,...)) does it matter what the ... is?
13:27:53 <Peaker> luite, Yes, that is clear - but wins are probably small parts of the search tree, usually
13:28:12 <edwardk> no because you'll get 2, no matter what the value is for ...
13:28:16 <Peaker> edwardk, no, but how can a scan result in such an expression?
13:28:17 <luite> Peaker: it's not only about wins, it's about the maximum and minimum 'bound' you can get in a certain part of the search tree
13:28:31 <edwardk> peaker: thats in essence what board scoring turns into as it rolls up the tree.
13:28:34 <Peaker> luite, how can you get such a bound in a game like chess, except for a win?
13:28:50 <Peaker> luite, min bound=lose/draw,  max bound=draw/win
13:29:34 <Peaker> edwardk, but its only good for these 3 options.. heuristic ones will sometimes be wrong
13:29:36 <luite> Peaker: ultimately, at the leafs of your search tree, you'd have some heuristic utility function that gives a numeric value
13:29:51 <phobes> Peaker:  It generalizes that.  Suppose I work out that one move gets score 10.  Then I'm working out the score of another move I might make.  If I find that one opponent response has a score of 5, I can stop searching on this move for me, since I know that at best this move will be score 5 for me
13:29:58 <SamB_XP_> not the "leaves" so much as the "leave offs"
13:30:06 <Peaker> luite, it will rule out a win that requires going through losing a queen if another path does not lose a queen
13:30:36 <Peaker> phobes, unless the heuristic is wrong
13:31:02 <luite> Peaker: you assume that it is right then ;)
13:31:02 <SamB_XP_> Peaker: meaning that it will consider them to be less desirable
13:31:03 <phobes> Peaker:  It doesn't matter - this is an optimization for computing the min-max to a certain depth
13:31:14 <edwardk> peaker: remember you aren't making the entire set of choices in the tree. so basically if your OPPONENT can checkmate you down one path when HE gets to make the choice it doesn't matter what your options are if he makes a different move. he'll never make a different move than the optimal play. so you can prune the evaluation of those.
13:32:00 <edwardk> peaker: your worst case is that your opponent plays suboptimally in which case your board evaluation is higher than your conservative heuristic based approximation.
13:32:01 <phobes> Peaker:  Once you decide  you're only going to compute the min-max to a max depth of 5, then you're stuck with whatever flaws your heuristic has at depth 5 - might as well optimize the min-max search
13:32:31 <Peaker> edwardk, I understand why you want to prune things below a max you found - if that max is win, but pruning things below a heuristic value you found, I am not sure that's a good idea
13:32:50 <Peaker> edwardk, Yeah, I understand that - I wrote some board game AI's
13:32:54 <edwardk> peaker: you need to design a heuristic function properly that is a separate issue =)
13:33:24 <edwardk> alphabeta has the benefit that it extends the depth your minimax algorithm can run out to quite a bit because it prunes many branches at each level, it gives you mathematically the EXACT same result as minimax. and runs asymptotically faster
13:33:39 <Peaker> phobes, but you can't prune the options after scanning them - so you have to prune them based on lower-depth use of the heuristic, right?
13:33:49 <SamB_XP_> Peaker: no
13:34:36 <edwardk> peaker; you prune them based on the info of at least one traversal to the maximum depth of your heuristic (iterative deepening is layered OVER this algorithm, it doesn't feed it numbers at first)
13:35:52 <phobes> Peaker:  Don't follow "prune the options after scanning them"
13:36:24 <edwardk> ok, so alpha beta basically gives you an algorithm with a pair of scores that say i can prevent the opponent from getting a score better than alpha and they can prevent me from getting a score better than beta.
13:36:40 <edwardk> so any time a branch can be proven to fall outside of those bounds you launch and don't scan it.
13:36:46 <edwardk> er laugh
13:36:58 <edwardk> using the appropriate bound on each person's turn
13:37:01 <SamB_XP_> edwardk: er, ITYM stop scanning it
13:37:09 <Peaker> edwardk, for weak meanings of "proven"  :)
13:37:09 <edwardk> yeah
13:37:13 <SamB_XP_> you do this by depth-first
13:37:14 <Peaker> edwardk, (given that you use a heuristic)
13:37:22 <phobes> Peaker:  This optimization is simply that max(10, min(5, ...)) = 10
13:37:31 <SamB_XP_> Peaker: well, you were already using the hueristic
13:37:43 <SamB_XP_> Peaker: unless you have a better idea than minimax?
13:37:53 <edwardk> peaker: for fairly strong meanings, your heuristic function is your heuristic function. if you lack an admissable heuristic thats your own issue. minimax won't give you a better answer!
13:38:03 <Peaker> phobes, yes - what I generally did is just scan - return the max you find. If you find a win, return it immediately.  I didn't return a (min,max)
13:39:10 <edwardk> peaker: sure thats all you can do witht he local information about the path you are investigating. but moves don't exist in isolation. alphabeta takes into account the moves leading up to here. does it matter if you can checkmate on the move after the other guy can checkmate you?
13:39:46 <edwardk> does it matter that if he completely randomly chose to give you his queen that you could mate in 5? no because you have no scoring motivation for him to do so
13:39:48 <Peaker> edwardk, if the scan saw that he can checkmate me, it won't scan his other possible moves
13:40:18 <phobes> Peaker:  Is your scan recursive?  Or do you mean you're just scanning with a heuristic?
13:40:24 <Peaker> I am not sure if I do need to keep track of a (min, max) or just a max.. Need to draw some diagrams on paper :)
13:40:28 <Peaker> phobes, recursive
13:40:31 <phobes> ok
13:40:35 <Peaker> phobes, and a heuristic is used when the depth runs out
13:41:05 <edwardk> peaker: then a correctly implemented alphabeta will give you the exact same results
13:41:24 <phobes> Peaker:  you don't need to return (Min, Max) - you return the value of the subtree
13:41:42 <phobes> You keep track of mins/maxes so far as part of the alpha beta though
13:42:00 <Peaker> phobes, why do you need the min, and not just the current max?
13:42:25 <edwardk> the power of alphabeta is that it gives you the exact same result with a lower branching factor. the power of MTD(f) is that log n applications of a function with a MUUUCH lower branching factor can find the board value.
13:42:42 <saml> how come i can use <- in ghci?  is ghci a giant do block?
13:42:45 <Peaker> phobes,   my_best_move(board) = max(-my_best_move(next_board) | next_board <- nexts(board))
13:42:48 <edwardk> peaker: because i know my opponent will never let me even play a move if he has a better option already.
13:43:53 <edwardk> your checkmate case is just a minimal form of pruning. you can prune more vigorously
13:43:55 <lehka> 8-)
13:44:47 <Peaker> edwardk,  in the above recursion - you can ofcourse prune the rest of the scan once you hit a maxBound value
13:44:52 <lehka> edwardk  ?      mai frend
13:44:59 <Peaker> edwardk, but I still cannot see what else you're allowed to prune (can you put it in terms of that code)
13:45:05 <Peaker> edwardk, this one:   my_best_move(board) = max(-my_best_move(next_board) | next_board <- nexts(board))
13:45:39 <edwardk> anyone feel like kicking the random russian insult spewing moron again?
13:46:09 <phobes> Peaker: is maxBound here "checkmate" (ie a global max)?
13:46:14 <Peaker> phobes, yeah
13:46:23 <phobes> ok, you can do more than that
13:46:39 <edwardk> peaker: your problem is your function doesn't take enough info. you need to know the best option your opponent has before coming into this move as well. thats why you pass both alpha and beta.
13:46:51 <phobes> right
13:47:02 <Peaker> my_best_move board giveUpIfLessThan =  .. ?
13:47:14 <lehka> Peaker   viktory!!!!!!!!!
13:47:27 <int-e> so alpha-beta becomes  my_best_move board giveUpIfLessThan beSatisfiedIfMoreThan ?
13:47:46 <int-e> (modulo a negation or two)
13:47:53 <Peaker> int-e, I don't think you should be satisfied if more than
13:47:56 <lehka>    
13:48:03 <Peaker> what's lehka saying?
13:48:48 <lehka> wat@
13:48:57 <Peaker> intuitively, I think that maybe its right to pass one bound to the function - not both bounds - edwardk, phobes : Can you define the function signature?
13:49:02 <int-e> Peaker: oh. that's the wrong function for that check I guess.
13:49:21 <Peaker> int-e, I might be wrong - I am not sure
13:49:22 <edwardk> alphabeta node depth alpha beta | terminal node || depth == 0 = heuristic node; alphabeta node depth alpha beta = ...
13:49:41 <edwardk> peaker: given that every major chess program on the planet uses some variation on this theme i'll smile and nod ;)
13:49:44 <sioraiocht> @src take
13:49:44 <lambdabot> take n _      | n <= 0 =  []
13:49:44 <lambdabot> take _ []              =  []
13:49:44 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
13:49:52 <lehka> Peaker goy to vodka drinkin
13:50:43 <lehka> edwardk -hello mai frend
13:50:51 <edwardk> @hpaste
13:50:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:50:58 --- mode: ChanServ set +o Saizan
13:51:07 --- mode: Saizan set +b *!*n=lehka@*.112.28.109.pppoe.eltel.net
13:51:07 --- kick: lehka was kicked by Saizan (Saizan)
13:51:08 <hpaste>  edwardk pasted "alphabeta i had lying around" at http://hpaste.org/7879
13:51:09 <mkemoor> do u do transfer
13:51:17 --- mode: Saizan set -o Saizan
13:51:21 <phobes> Peaker:  I think   bestMove board tooGood
13:51:23 <mkemoor> any good hacker in here
13:51:23 <phobes> Would work
13:51:37 <phobes> The point is you want to specify a cap on how good of a move you should bother finding
13:51:50 <phobes> If you find a move better than that, then your opponent is never going to let this subtree happen anyway
13:51:51 <edwardk> phobes: nah you want both an alpha and a beta or you only do half the pruning you can
13:52:01 <vixey> mkemoor: lots
13:52:03 <fxr> mkemoor: more than you can imagine
13:52:03 <edwardk> coz otherwise you can't prune the next guy's moving using past information about him
13:52:25 <phobes> edwardk:  ya, you're right
13:52:25 <Peaker> phobes, I see
13:52:51 <phobes> edwardk: well
13:52:59 <phobes> edwardk: I recall you're right, but I'm not seeing it... :)
13:53:01 <Peaker> how can tooBad be meaningful?
13:53:18 <Peaker> oh! you have to pass it down
13:53:22 <Peaker> you can't use it but the ones you call can
13:53:33 <edwardk> exactly!
13:53:49 <Peaker> great, thanks!
13:54:26 * edwardk just realized that using the Yoneda lemma on that code he supplied gives an asymptotically faster version ;)
13:54:35 <Peaker> Yoneda lemma?
13:54:35 <edwardk> coz of all the naive fmap negates
13:54:47 <Peaker> what's that?
13:54:47 <edwardk> category theory bit
13:55:12 <Peaker> can't fmap negate be inlined into non-naivity? :)
13:55:18 <edwardk> says f a and forall b. (a -> b) -> f b are isomorphic
13:55:19 <edwardk> sure
13:55:28 <edwardk> either version works
13:55:48 <edwardk> just was amused that my golden hammer of the evening was appropriate even here
13:56:03 <Peaker> I like the golden hammer of inlining :)
13:56:09 <Peaker> (I don't know category theory)
13:56:49 <edwardk> ok, so we understand alphabeta now?
13:57:11 <edwardk> so MTD(f) is just a driver around alphabeta.
13:57:52 <edwardk> since we have these alpha and beta values we know that if we set them artificially tight and we get the alpha or the beta that we pruned the actual solution.
13:58:42 <edwardk> so MTD(f) sets them up so that you have them like a 'too high' 'too low' indicator value. you start with an initial guess at what the score of the board will be, and it very quickly prunes away large swathes of boards.
13:59:03 <edwardk> if you get the exact number you guessed, great. then you are right and that is the scoring of the optimal move.
13:59:17 <edwardk> if you got 'too high' or 'too low' you try again by adjusting your guess.
13:59:44 <Peaker> I think I understand - pretty cool
13:59:55 <int-e> edwardk: oh you want to exploit negate . negate = id
14:01:16 <edwardk> the nice part is that the main 'cost' of alpha beta or minimax is the number of possible moves to consider. your depth costs you exponentially in terms of the branching factor. if you have n paths at each level you have n^d paths to consider for depth d. with MTD(f) you cut the n waaay down. in exchange for having to run the process log |s| times where s is the score and |s| is the size of the scoring function space. so you get log |s| * n^d
14:01:25 <edwardk> int-e: yeah
14:01:59 <edwardk> but in that MTD(f) case n is a much smaller number, so the log is a wash at worst ;)
14:02:20 <edwardk> then you use iterative deepening over that to let you keep increasing d until you run out of time.
14:02:56 <phobes> edwardk:  Is the log |s| factor not dominated by the increase in n as you widen alpha/beta?
14:03:05 <edwardk> since that may add maybe a 1/n to to your over all run time, but in exchange you get a better initial guess at the board value.
14:03:19 <phobes> I guess it might not be
14:03:42 <edwardk> phobes: the log s factor is cheap generally and you fix alpha to 1-2 points away from beta (depending on how you set up the inequalities)
14:04:13 <phobes> oh right
14:04:15 <edwardk> and also remember if you memoize the alphabeta search to begin with using a transposition table, a lot of the board positions you explore later will have already been considered.
14:04:23 <edwardk> also thats log |s| worst case =)
14:04:33 <edwardk> if you have a good initial guess often times you'll hit it spot on
14:04:43 <edwardk> and iterative deepening GIVES you a good guess for free
14:04:56 <edwardk> since you have the last best guess as a starting point.
14:05:49 <edwardk> so you trade down the size of an exponential term you have to pay for a worst case logarithmic term you may not have to pay.
14:06:44 * edwardk shuts up now. =)
14:06:55 <phobes> Peaker:  What game is this for?
14:07:01 <Peaker> phobes, chess
14:07:04 <phobes> ok
14:07:16 <edwardk> I wound up having to implement all of that when I was doing a graduate certificate in AI ;)
14:07:22 <phobes> I recall the other thing that's important for chess is variable depth search
14:07:28 <Peaker> edwardk, thanks for the explanations - I will need some actual messing around with all that to really grasp it well, but I have an intuitive idea of it now :)  (Alphabeta I fully grasp though)
14:07:38 <phobes> or I guess I should say an other thing
14:07:47 <edwardk> phobes: hence the iterative deepening
14:07:59 <phobes> edwardk:  is that good enough?
14:08:08 <Peaker> edwardk, I think you might also additionally "fix" the depth of "interesting" subtrees
14:08:17 <edwardk> phobes: its pretty damn good actually.
14:08:37 <edwardk> peaker, phobos: maybe not a bad idea. i seem to recall fritz, etc. use something along those lines.
14:08:38 <phobes> edwardk:  I think you don't want your termiantion condition to be "go to depth d"
14:08:39 <Peaker> edwardk, actually I guess this will happen naturally - it will get another pass in the next run if its interesting
14:08:49 <mix25> Why give me this error: http://pastebin.egghelp-bg.com/66 . I'm not sure if it's on line 5
14:09:09 <Peaker> phobes, when you go to depth d - if something is very "interesting" then next iteration to depth d+1 will explore that rather than other things
14:09:13 <phobes> I recall it's important to play out moves - particularly when there are checks involved, to a deeper depth
14:09:16 <edwardk> well, as i recall one of the tricks to get that is to consider trades as 'free moves'
14:09:26 <edwardk> so you automatically go deeper on attack lines.
14:09:49 <lehka> Peaker: ban 
14:09:50 <Peaker> maybe you want each sub-tree to be of the same size rather than the same depth
14:09:53 <edwardk> and that if you end in a 'capture position' you have to play it out.
14:10:00 <phobes> ok, so then what happens when you realize it's not interesting?
14:10:09 <phobes> because it works out after 100 moves
14:10:21 <lehka> edwardk mai frend
14:10:26 <phobes> Somehow you need to go back to a reasonable search on the rest of the tree, right?
14:10:39 <edwardk> @ops
14:10:39 <lambdabot> Maybe you meant: docs oeis pl
14:10:53 <Peaker> if you fix the scan of subtrees to be deeper when the tree if narrower (checks involved, for example) then maybe it is because of a more general principle: You want equally-sized subtrees being scanned
14:10:57 <lehka>  
14:11:04 <phobes> Peaker:  that's what I was talking about
14:11:28 <edwardk> @type ord
14:11:30 <lambdabot> Char -> Int
14:11:35 <lehka>        
14:11:46 <edwardk> > describeSequence $ map ord "lehka"
14:11:46 <Peaker> maybe each subtree scan itself should be iteratively deepening - and size-limited rather than depth-limited?
14:11:47 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
14:12:03 <edwardk> > describeSequence $ map (fromIntegral . ord) "lehka"
14:12:05 <lambdabot>  Nothing
14:12:07 <phobes> Peaker:  You might also want to incorporate the hueristic value in deciding the depth of the tree
14:12:39 <opqdonut> :t describeSequence
14:12:41 <lambdabot> SequenceData -> Maybe String
14:12:48 <opqdonut> OEIS lookup?
14:12:48 <Peaker> I gotta try to implement a simple alphabeta first and see how well it behaves.. without an opening book :)
14:13:01 <byorgey> opqdonut: yup
14:13:04 <edwardk> > describeSequence [1,11,21,1211]
14:13:04 <Peaker> I always wondered what a chess AI without an opening book would do :)
14:13:05 <lambdabot>  Just "Look and Say sequence: describe the previous term! (method A - initial...
14:13:11 <lehka> edwardk   nikom 
14:13:18 <Peaker> lehka, wtf are you talking about?
14:13:19 <byorgey> @where ops
14:13:19 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
14:13:21 <edwardk> yeah
14:13:42 <edwardk> peaker: quite badly
14:13:59 <Peaker> edwardk, hmm.. do they use a really slow AI to compute the opening book?
14:14:06 <dcoutts> lehka: if you don't mind, this channel is really only English
14:14:06 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
14:14:07 <Peaker> edwardk, (as in heavy/deep scan)
14:14:21 <Peaker> edwardk, I doubt long human chess traditions actually built the best possible opening books
14:14:24 <lehka> edwardk  
14:14:35 <ddarius> dcoutts: lehka has been banned twice
14:14:36 <dcoutts> lehka: please
14:14:40 --- mode: ChanServ set +o dcoutts
14:14:41 <edwardk> peaker: my general approach to beating chess software: do a fairly standard opening to a point, then punt a pawn that no professional chess player would. you're now outside of the opening book and its branching factor dominates its thoughts. play well, win, collect your prize money ;)
14:15:02 <ddarius> dcoutts: Perhaps get rid of the other two and do 89.112.*.* ?
14:15:08 <Peaker> edwardk, why not start weird from the start?
14:15:12 <lehka> mode (+o dcoutts ) by ChanServ
14:15:19 <dcoutts> ddarius: there's nothing wrong in principle with speaking Russian :-)
14:15:21 <edwardk> peaker: because the first few moves are too critical to long term survival
14:15:34 <edwardk> peaker: so build up a defense to you can lose the half move.
14:15:38 <edwardk> er to where
14:15:41 <ddarius> dcoutts: That wasn't the issue.
14:15:50 <edwardk> otherwise your weird opening costs you too much position and time
14:16:10 <dcoutts> ddarius: can you explain, I've missed this issue
14:16:17 <Peaker> edwardk, ah. I see :)  I can't beat gnu chess ("normal".. "easy" is pretty easy though, "hard" must be very hard..)
14:16:37 <Peaker> maybe if I try that
14:16:38 <lehka>     slip to nait
14:17:15 --- mode: ChanServ set +o dons
14:17:16 <lehka> slip slip mai frend
14:17:21 <phobes> If noone else in channel speaks Russian, I think you could mount an argument against it
14:17:29 <Peaker> edwardk, I am wondering if my chess move generator is completely correct...
14:17:37 <ddarius> dcoutts: [15:12] <lament> edwardk: he says nothing but dirty insults
14:17:47 <dcoutts> ah right'o
14:17:57 <ddarius> dcoutts: And he was referred to #haskell.ru before the first ban.
14:17:57 <Peaker> edwardk, A little GUI (hotseat playing) seems to show that it is
14:18:03 <dcoutts> lehka: no more insults please or we'll have to ban you
14:18:05 <lehka>  Peaker:good bai
14:18:29 <lehka> ddarius :good bai
14:18:35 <edwardk> peaker: anwyays presuming you can play a good solid 1500-1600 point game, that will beat most of the software out there that is intended for the casual player. i.e. battlechess stuff, stuff for the ps2, etc.
14:18:44 --- mode: dons set +b *!*n=lehka@89.112.22.*
14:18:44 --- kick: lehka was kicked by dons (dons)
14:18:46 --- mode: ChanServ set -o dons
14:18:50 <dons> check the logs, dcoutts
14:18:55 <Peaker> edwardk, I think I am generally 1400, but on good days I can get up to 1600 maybe
14:19:02 <edwardk> though now we've officially stepped outside of the realm of #haskell ;)
14:19:15 <edwardk> dcoutts: he's rejoined after being banned twice now.
14:19:16 <Peaker> edwardk, (Using Yahoo! chess ratings :-)
14:19:32 <dons> yeah, interesting.
14:19:40 <phobes>   ,      lehka
14:20:23 <lament> I speak russian
14:20:24 <dcoutts> phobes: apparently he was being insulting to people
14:20:27 <edwardk> I peaked just over 2000 when I played seriously, but its been a long time.
14:20:37 <dcoutts> phobes: it's not because he was speaking Russian
14:20:54 <Peaker> edwardk, I don't usually have the patience to spend serious thinking on every move
14:21:06 <lament> ohh you guys are talking about chess
14:21:23 <lament> how do i learn chess? :)
14:21:30 <snhmib> woo chess
14:21:40 <phobes> dcoutts: I know
14:21:45 <Peaker> lament, you can use my GUI to learn about the rules :)  And Yahoo! chess to play against beginners
14:21:46 <snhmib> lament: get a good book and play long matches at chess club =)
14:21:48 <mix25> it'll be hard :P
14:22:17 <lament> i know the rules, i want some kind of intuitive understanding of positions, so i guess i just need practice
14:22:18 <ddarius> As far as I'm concerned, ban evading is reason enough to be banned again.
14:22:26 --- mode: dcoutts set +b *!*n=lehka@85.249.252.170.pppoe.eltel.net
14:22:26 --- kick: lehk1 was kicked by dcoutts (dcoutts)
14:22:30 <opqdonut> heh
14:22:51 <hpaste>  int-e annotated "alphabeta i had lying around" with "some equational reasoning ..." at http://hpaste.org/7879#a1
14:22:54 <edwardk> My uncle was a grandmaster. He used to sit in the living room watching TV and call out his moves to me when I was a kid. I wish I'd taken better advantage of him as a resource at the time. ;)
14:22:55 <lament> but i don't know who to play with
14:23:07 <lament> FICS seems scary and unfriendly
14:23:17 <lament> is there something like KGS for chess?
14:23:18 <ddarius> You can try one on the lehka username as that has stayed the same throughout (though it is easy to change)
14:23:23 <Peaker> lament, Yahoo! chess is a crappy Java app but you can find lots of people from all levels there
14:23:23 <dons> that's awesome, edwardk
14:23:45 <byorgey> edwardk: he kept the board position in his head?  or he would glance over at the board and call out his moves?
14:23:53 <byorgey> still impressive either way =)
14:24:04 <edwardk> in his head. he used to do exhibition games at the local store and stuff
14:24:07 <ddarius> byorgey: He'd already decided on all his moves at the games outset.
14:24:11 <byorgey> wow =)
14:24:13 <byorgey> ddarius: hehe
14:24:21 <phobes> byorgey:  He had the computer crunching away in living room
14:25:17 <lament> does playing chess without thinking have any merit?
14:25:24 <edwardk> ddarius: heh as strange as that sounds, its probably true. i did have a penchant for trying variations on the same theme. so he probably didn't have to work hard.
14:25:58 --- mode: dcoutts set +b *!*n=lehka@89.112.21.*
14:26:20 <mix25> *!*lehka@*
14:27:04 <opqdonut> yeah that should do it
14:27:13 <edwardk> int-e: nice cleanup. i have another variation on the alphabeta bit that had that already rolled in. i just went into my user directory and started typing vim AlphaBeta.hs to write up an alphabeta example and tripped over that code coz it was already there ;)
14:29:36 <lehkav>       
14:29:56 <edwardk> i would say you probably shouldn't include the userid in the mask
14:30:11 <lehkav> edwardk
14:31:12 --- mode: ChanServ set +o Heffalump
14:31:33 <Heffalump> oh. I didn't realise I was still on the access list.
14:31:38 <opqdonut> :)
14:32:12 <Peaker> lament, my brother is quite a good chess player - and he started playing these 1-minute games (total 1 minute, not per move)
14:32:31 --- mode: dcoutts set +b <lenka*!lenka@*.pppoe.eltel.net>
14:32:33 <Peaker> lament, I don't think there is a lot of time to think in these games, they're mainly won/loss by lack of time, not check mates :)
14:32:38 --- kick: lehkav was kicked by dcoutts (dcoutts)
14:33:00 <mix25> Omg.
14:33:17 <int-e> dcoutts: wrong ban
14:33:35 <dcoutts> int-e: really?
14:33:40 --- mode: dcoutts set -b <lenka*!lenka@*.pppoe.eltel.net>
14:33:57 <dcoutts> int-e: I thought it has to match the name too
14:34:24 <phobes> Peaker:  I used to play those ... most of the time I'd pick my next move without seeing my opponents next move (only changing it if it would be catastrophically bad)
14:34:25 <mix25> lehka /= lenka
14:34:41 <Peaker> phobes, I am not sure why he plays those - what's fun about that? :)
14:34:45 <int-e> *!*@89.112.21.243 should do the trick?
14:34:53 --- mode: Heffalump set +b *!*@81.222.226.39
14:34:54 <dcoutts> mix25: oh yeah oops :-)
14:35:00 <phobes> Peaker:  And then at some point you decide whether the game is never going to be won by mate, and just make random stupid moves
14:35:17 <int-e> oh, IP change. ok, this is going to be ugly.
14:35:26 <Peaker> phobes, I guess you want to check him so he has to depend on your move to move
14:35:34 <Heffalump> int-e: seems to be a huge range, if the one you suggested is correct too..
14:35:36 <phobes> yes, checking just to stall is a useful strategy
14:36:43 <lament> doesn't sound like much fun
14:36:47 <dcoutts> int-e: what's the difference between the irc nick and username?
14:36:59 <Heffalump> dcoutts: the username is something you supply at connection time
14:37:15 <Heffalump> it often corresponds to the unix username on the system you are connecting from
14:37:26 <Heffalump> (e.g. if the client supplies it, or if an identd responds with it)
14:37:29 <edwardk> peaker: the basic goal in a timed game is to avoid forced error and play for time. then you can play for advantage once you have a sufficient reserve that you are making them sweat.
14:37:30 <lament> which is why people with username 'root' get made fun of
14:37:54 <Heffalump> bans are nick!username@host
14:38:19 <Peaker> edwardk, how often does a <2-minute-total (1+1 each side) game really end with a check-mate?
14:38:31 --- mode: dcoutts set +b <*!lehka*@*.pppoe.eltel.net>
14:38:41 <dcoutts> int-e, Heffalump: look right?
14:38:52 <Heffalump> no :-)
14:38:53 <NewBe> Is there a map function which allows me to map to every other element in a list?
14:38:58 <edwardk> peaker: 5% or so
14:39:00 <int-e> the <> are wrong
14:39:07 --- mode: dcoutts set -b <*!lehka*@*.pppoe.eltel.net>
14:39:12 <Heffalump> (a) it's out of date for the current connection, (b) it has spurious <>, and (c) it omits the n= bit
14:39:47 <lament> you don't need the n= bit
14:39:49 <edwardk> peaker: typically less if both are any good
14:39:51 <Heffalump> (btw, banning without kicking is useful as it reduces the total noise and still stops them speaking, I think)
14:39:54 <byorgey> NewBe: there is no one function in the standard libraries that allows you to do that, no
14:40:00 <Heffalump> lament: oh, even without a wildcard?
14:40:05 <dcoutts> I'm not familiar with the syntax, my client has some pre-made commands for standard kicks, but not for custom ones
14:40:15 <lament> Heffalump: i dunno, but he did have a wildcard
14:40:19 <byorgey> NewBe: but writing your own should not be too hard and might be a good exercise =)
14:40:23 <Heffalump> lament: only at the end, not the beginning
14:40:23 <mix25> *!*l*e*h*k*a*@*
14:40:33 <lament> Heffalump: *!lehka*@
14:40:37 <Heffalump> mix25: I was wondering about something a bit less vicious than that, but it seems dangerous
14:40:43 <int-e> Heffalump: fwiw, those are two separate /16 ranges, both assigned to eltel
14:40:44 <lament> the first character is the appropriate wildcard, no?
14:40:56 <Heffalump> the first character only wildcards on the nick
14:41:04 <mix25> I dont think have more than 1-2-3 people use this username
14:41:06 <Heffalump> you'd have to have a * after the ! to catch the n= in a wildcard
14:41:08 <lament> oh, n= is in the username
14:41:13 <lament> right
14:41:23 <lament> i bet you don't need a wildcard for it, for backwards compatibility
14:41:34 <Heffalump> I'm in favour of *!n=lehka*@*, I think
14:41:35 <lament> since otherwise, when freenode introduced that bit, all ban lists would stop working
14:41:44 <Heffalump> lament: possible, I guess.
14:41:47 <Peaker> lambdabot can extendSequences, use it to figure out a banmask!
14:41:57 <NewBe> byorgey, =/    ...this will be a challenge
14:41:59 <int-e> Peaker: hehe
14:42:01 <mix25> Put it then.
14:42:04 --- mode: dcoutts set +b *!n=lehka*@*.pppoe.eltel.net
14:42:09 --- mode: Heffalump set +b *!ganesh@urchin.earth.li
14:42:11 <Heffalump> wheee
14:42:18 <Heffalump> (did anyone see that/)
14:42:21 <edwardk> yeah =)
14:42:24 <dcoutts> Heffalump: yup
14:42:27 --- mode: Heffalump set +b *!n=ganesh@urchin.earth.li
14:42:29 <Heffalump> wheee
14:42:29 <mix25> all
14:42:34 <Heffalump> how about this?
14:42:36 <edwardk> yep
14:42:38 <mix25> too
14:42:39 <Heffalump> oh.
14:42:46 <schemelab> ping
14:42:48 --- mode: Heffalump set -o Heffalump
14:42:50 <dons> so he's actually reconnecting and getting a new IP in order to outstep the ban?
14:42:57 <edwardk> dons: yeah
14:43:03 <dons> that's pretty desperate..
14:43:09 <edwardk> or pretty bored
14:43:10 <int-e> oh yes, what was the ban list length limit again?
14:43:17 --- mode: ChanServ set -b *!n=ganesh@urchin.earth.li
14:43:20 <Heffalump> how about this?
14:43:26 <mix25> all
14:43:27 --- mode: ChanServ set +o dons
14:43:28 --- mode: dons set -b *!*n=lehka@*.112.28.109.pppoe.eltel.net
14:43:35 --- mode: dons set -b *!*n=lehka@85.249.252.170.pppoe.eltel.net
14:43:42 --- mode: dons set -b *!*@81.222.226.39
14:43:59 <dons> so we just want to keep, *!n=lehka*@*.pppoe.eltel.net ?
14:44:01 <byorgey> NewBe: do it by cases.  mapEveryOther f [] = ?  mapEveryOther f [x] = ?  mapEveryOther f (x:y:zs) = ?  (you fill in the ?'s)
14:44:05 <dcoutts> dons: yep
14:44:06 --- mode: ChanServ set +o Heffalump
14:44:09 <Heffalump> dons: we need the IP ones..
14:44:13 --- mode: dcoutts set -b *!*@89.112.19.44.pppoe.eltel.net
14:44:21 <Heffalump> since he's using the IPs at the moment
14:44:29 <byorgey> NewBe: the first two cases define the behavior on the empty list and a list of exactly one element
14:44:32 --- mode: Heffalump set -b *!ganesh@urchin.earth.li
14:44:32 <dons> looks ok now. there's a couple of specific IPs, and then the general domain.
14:44:38 <Heffalump> dons: ah, ok
14:44:48 <Heffalump> lament: I think my tests show that the n= is needed.
14:44:48 <dons> *!*n=lehka@89.112.22.*, *!*n=lehka@89.112.21.*, *!n=lehka*@*.pppoe.eltel.net
14:44:51 <lament> what a successful troll, he's not even in the channel yet he's in full control of the conversation
14:44:52 <dcoutts> dons: we don't need the specific ones
14:44:52 <byorgey> NewBe: the last case says what should happen on lists of at least two elements x and y, followed by the remainder of the list zs
14:44:57 <NewBe> byorgey, I think I may have just figured it out
14:45:00 <NewBe> =]
14:45:01 <lament> we can all learn from him!
14:45:02 <dons> we need #haskell-ops
14:45:03 <byorgey> NewBe: great! =)
14:45:10 --- mode: dcoutts set -b *!*n=lehka@89.112.21.*
14:45:14 --- mode: dcoutts set -b *!*n=lehka@89.112.22.*
14:45:16 <Peaker> hmm, wouldn't it be nice if the IRC client: A) used some MRU of activity to tab-complete the right nicks,  B) highlight lines from the nick you are writing to ?
14:45:41 <byorgey> NewBe: feel free to paste your code on hpaste.org if you'd like someone to take a look at it
14:46:29 <hpaste>  mix25 pasted "(no title)" at http://hpaste.org/7881
14:46:31 <astrolabe> Would it be possible for lambdabot to kick/ban people?
14:46:50 <mix25> Someone can see my code to help me ?
14:47:16 <mix25> astrolabe yes
14:47:40 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/7882
14:47:44 <astrolabe> I mean in a useful way.
14:48:00 <mix25> There is many tcl's for that
14:48:36 <mix25> Depend too of what do u want.
14:48:40 <sioraiocht> @src drop
14:48:41 <lambdabot> drop n xs     | n <= 0 =  xs
14:48:41 <lambdabot> drop _ []              =  []
14:48:41 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
14:49:05 <luite> I'm trying to build the unix-2.3.0.0 package using cygwin. the configure completes succesfully, but when I try to build, it cannot find the header files (like sys/times.h ) anymore, even though it could find them during configure. what could be wrong?
14:49:30 <Peaker> mix25, you put a signature that the first arg of func2 is a function but its a list
14:49:41 <Heffalump> we coudl add little Haskell functions to it to recognise banning behaviour :-)
14:49:58 <Peaker> mix25:  here you say its a function:  func2 :: (Int->[Int]) ...   here you say its a list: func2 (x:xs) =  ...
14:50:16 <mix25> yea i saw it
14:52:49 <hpaste>  schemelab pasted "date module problems" at http://hpaste.org/7883
15:01:26 <schemelab> what do I need to import to get this to work... what date module?  let daysToSecs x = x*24*60*60; p = fromJust . parseTime defaultTimeLocale "%Y-%m-%d %H:%M:%S%Q %Z"; addDate a b = addUTCTime (fromRational . toRational $ a) b in addDate (daysToSecs 40) (p "2000-01-01 12:00:00 UTC")
15:07:50 <hpaste>  schemelab annotated "date module problems" with "fromJust and defaultTimeLocale not defined" at http://hpaste.org/7883#a1
15:08:20 <schemelab> how can I get that code to have fromJust and defaultTimeLocale defined? http://hpaste.org/7883#a1
15:13:09 <Peaker> does ghc cache results of anything?  f x = (bigComputation x)*2 ;  e.g: f x + bigComputation x
15:13:51 <roconnor> not by default
15:14:39 <Peaker> but..
15:14:42 <Bonus> http://www.nasa.gov/55644main_NASATV_Windows.asx
15:14:47 <Bonus> fyi guys :D
15:14:51 <Bonus> phoenix landing atm
15:17:09 <mix25> (x:xs) = [1..3] => x = 1, xs = [2,3] right?
15:17:22 <roconnor> > 1:[2,3]
15:17:24 <lambdabot>  [1,2,3]
15:17:30 <Peaker> roconnor, is there a but?
15:18:10 <roconnor> Peaker: I'm not sure.  Possibly there is a way of convincing GHC to do it, or you can rewrite things to memoize explicitly
15:18:41 <hpaste>  NewBe pasted "Byorgey, I think this is very inefficient" at http://hpaste.org/7884
15:18:41 <mauke> you convince it with 'let'
15:19:02 <mauke> let cache = bigComputation x in cache * 2 + cache
15:19:36 <ddarius> NewBe: The most inefficient thing is the take (length x) which is completely unnecessary
15:20:06 <Peaker> mauke, yeah, but that breaks the abstraction of 'f', which in my case sits in another module
15:20:24 <ddarius> foo = sum . zipWith (*) (cycle [1,-1])
15:20:24 <mauke> no caching for you then
15:20:36 <Peaker> mauke, the soup nazi is nicer
15:21:43 <Peaker> I think having optimization annotations for cases like this could be nice - if those could be coupled with the code without cluttering it
15:23:26 <mauke> caching is hard if you want to avoid space leaks
15:23:29 <ddarius> As roconnor said, just write bigComputation explicitly using memoization if that is what you want.
15:24:11 <Peaker> ddarius, I see how I can do it - I wanna do it without breaking the abstraction though
15:24:16 <mix25> > drop (head(1:[2,3]) 1:[2,3]
15:24:17 <lambdabot> Unbalanced parentheses
15:24:22 <mix25> > drop (head(1:[2,3])) 1:[2,3]
15:24:23 <lambdabot>   add an instance declaration for (Num [a])
15:24:33 <ddarius> Peaker: You don't need to break an abstraction to do that.
15:24:49 <Peaker> ddarius, specifically, I have  isDraw :: Board -> Bool  which checks all possible moves (depth=0) and I want to use isDraw and also check these same moves myself
15:25:03 <mix25> > drop (head(1:[2,3])) (1:[2,3])
15:25:04 <lambdabot>  [2,3]
15:25:29 <Peaker> ddarius, how do you do it without breaking the abstraction?
15:26:27 <ddarius> So you want checkMove :: Move -> Board -> Something to be memoized?  If so, make it so.
15:29:14 <zloog> Hi
15:29:41 <zloog> Does anyone know what can cause: "Instance of Floating (Float -> Float) required for definition of perimeter" or point me at a buzzword so I can google it?
15:30:06 <dolio> You didn't apply some function to enough arguments.
15:30:37 <dolio> Or applied it to too many.
15:30:39 <dolio> Hard to say.
15:30:41 <zloog> Well that sounds pretty likely
15:30:42 <zloog> thanks
15:30:56 <Peaker> ddarius, for it to be memoized it has to be put into an explicit list or so, that isDraw and the func using it would both have to be using
15:30:59 <Peaker> ddarius, right?
15:31:26 <Peaker> ddarius, so you change isDraw to take this memoization data structure explicitly?
15:31:57 <Maciej123> @type foldr (\x acc -> x + 256 * acc) 0
15:32:00 <lambdabot> forall b. (Num b) => [b] -> b
15:32:12 <ddarius> No.
15:32:16 <Maciej123> Hi all!
15:32:50 <ddarius> Peaker: The signature of the "checkMove" or whatever wouldn't change at all.
15:34:18 <Maciej123> Why does GHC give me type "[Integer] -> Integer" for this function when binding it to a function name in my Haskell file?
15:34:28 <Peaker> ddarius, I am not sure which function you're referring to - the common one used by both?
15:34:59 <Peaker> ddarius, lets say you have a, calling c and b, and b also calls c[which is the big computation]
15:35:25 <Peaker> ddarius, how do you implement memoization without having the call from a to b look differently?
15:42:04 <Maciej123> No one who would like to help me?
15:42:28 <dibblego> Maciej123, what is the function body?
15:42:41 <dibblego> oh the foldr
15:42:41 <opqdonut> Maciej123: integer defaulting
15:42:53 <opqdonut> (Num a => a) gets "defaulted" into Integer
15:43:07 <opqdonut> give it an explicit typesig in ghci if you want it to be polymorphic
15:43:11 <Maciej123> The function is toUInt = foldr (\x acc -> x + 256*acc) 0
15:43:57 <roconnor> foldr (\x acc -> fromIntegral x + 256*acc) 0  ?
15:44:26 <Maciej123> roconnor, this gives the same result
15:45:18 <Maciej123> Is there a GHC flag to turn off this "defaulting"?
15:45:45 <EvilTerran> no monomorphism restriction?
15:46:01 <EvilTerran> (ie -XNoMonomorphismRestriction)
15:48:20 <augur> o.o
15:48:43 <augur> simon peyton-jones is apparently aware of the existence of this channel. :o
15:48:51 <Maciej123> EvilTerran, this makes it give the correct type. Thanks!
15:48:57 <SamB_XP_> augur: how does that surprise you?
15:49:07 <augur> i just think its cool. :P
15:49:16 <SamB_XP_> if one simon knows, don't you think the other would to?
15:49:18 <edwardk> augur: he signed on here for about 15 minutes a couple years back =)
15:49:19 <EvilTerran> we should get him in here occasionally
15:49:30 <augur> haha.
15:49:36 <edwardk> augur: to invite people to anglohaskell iirc
15:49:43 <augur> anglohaskell?
15:49:59 <SamB_XP_> it happened in england, I imagine
15:50:00 <edwardk> was back when igloo and some others were trying to get that ghc maintainership job
15:51:07 <augur> ack. gotta go. lol
15:51:08 <augur> ciao
15:51:54 <ddarius> Peaker: You have c memoize it's computation
15:53:18 <Peaker> ddarius, but c takes arguments
15:53:36 <ddarius> Yes, so?
15:53:46 <ddarius> Memoization is not sharing.
15:54:18 <Peaker> ddarius, The only memoization example I saw was that of fib, where it was converted from Int->Int,  into  [Int]
15:54:41 <Peaker> ddarius, Its a very special case though, how do you generalize memoization?
15:57:34 <ddarius> @wiki Memoization
15:57:34 <lambdabot> http://www.haskell.org/haskellwiki/Memoization
15:57:41 <hpaste>  NewBe pasted "Matrix Determinants and Pattern Matching -- Comments Please" at http://hpaste.org/7885
15:59:58 <hpaste>  morrow pasted "ghc/libraries/ghc-prim/cbits/longlong.c" at http://hpaste.org/7886
16:00:38 <Peaker> Lemmih, hey, do you intend on wrapping SDL's draw functions, and Surfarray stuff? (Creating surfaces from pixel arrays/etc)
16:01:09 <Peaker> @tell Lemmih hey, do you intend on wrapping SDL's draw functions, and Surfarray stuff? (Creating surfaces from pixel arrays/etc)
16:01:10 <lambdabot> Consider it noted.
16:11:43 <dibblego> ?check \x y -> x == (y :: [Int]) ==> x `compare` y == EQ -- how could you make this get fewer misses with the == premise?
16:11:44 <lambdabot>  Arguments exhausted after 83 tests.
16:13:32 <hpaste>  morrow pasted "ST.lhs" at http://hpaste.org/7887
16:14:11 <mauke> ?check \x y -> let c = compare x (y::[Int]) in all (\f -> f x y == f c EQ) [(==),(<),(>)]
16:14:12 <lambdabot>  Couldn't match expected type `Ordering'
16:14:16 <hpaste>  (anonymous) annotated "ST.lhs" with "(no title)" at http://hpaste.org/7887#a1
16:14:48 <mauke> blah, polymorphism
16:15:43 <mauke> ?check \x y -> let c = compare x (y::[Int]) in and [(==) x y == (==) c EQ, (<) x y == (<) c EQ, (>) x y == (>) c EQ]
16:15:44 <hpaste>  morrow annotated "ST.lhs" with "GHC.STRef" at http://hpaste.org/7887#a2
16:15:45 <lambdabot>  OK, passed 500 tests.
16:16:20 <dibblego> thanks mauke; I will take a look
16:16:39 <hpaste>  morrow annotated "ST.lhs" with "Data.STRef" at http://hpaste.org/7887#a3
16:17:50 <dibblego> mauke, that seems to rely on the fact that the codomain of compare is size 3; my more real example returns Int
16:18:30 <mauke> huh?
16:19:01 <tieTYT> hm: http://research.microsoft.com/~simonpj/Haskell/guards.html
16:19:13 <tieTYT> i guess some at MS are researching haskell
16:19:16 <dibblego> mauke, I have another example in my own code that does not use Eq/Ord, but Eq/SomethingElse
16:19:35 <dibblego> tieTYT, Simon Peyton-Jones (creator of Haskell), works for MSR
16:20:05 <tieTYT> oh he's the creator?
16:20:07 <tieTYT> hah damn
16:20:19 <arw__> and there are some features in later .net languages which suspiciously look like haskell :)
16:20:36 <ddarius> He's not the creator.
16:20:38 <tieTYT> there's F#
16:20:42 <tieTYT> i wonder if that's similar
16:21:09 <dibblego> sorry, co-conspirator
16:21:21 <tieTYT> is my choice of guards here stupid: http://pastebin.org/38499
16:21:31 <tieTYT> i could just have another pattern
16:22:30 <hpaste>  morrow annotated "ST.lhs" with "IORef, IOArray (in GHC.IOBase" at http://hpaste.org/7887#a6
16:22:39 <hpaste>  dibblego pasted "mauke, this is more like my actual example" at http://hpaste.org/7888
16:22:56 <hpaste>  morrow annotated "ST.lhs" with "Data.IORef" at http://hpaste.org/7887#a7
16:23:07 <saml> what's the difference between ErrorT Err (...)     and   ErrorT close to the core?
16:23:11 <dibblego> tieTYT, how would you do that with another pattern?
16:23:39 <dibblego> tieTYT, you could do it with if/then/else, but what you have done is very typical
16:23:57 <mauke> dibblego: wait, how can this property ever be false?
16:24:28 <dibblego> mauke, quite easily? I'm not sure why it can't be
16:24:33 <tieTYT> dibblego: ah you're right.  There's no way to say <0 in a pattern
16:24:50 <hpaste>  morrow annotated "ST.lhs" with "Unsafe IO operations (in GHC.IOBase)" at http://hpaste.org/7887#a9
16:24:52 <mauke> dibblego: can you show me a failing foo?
16:24:54 <dibblego> mauke, suppose I write a broken Eq
16:24:56 <tieTYT> originally i was just going to match 0 _
16:25:01 <tieTYT> but that's not correct
16:25:05 <mauke> oh
16:25:46 <mauke> but the instance for Int is already defined :-)
16:26:06 <dibblego> sorry, newtype T = T Int, then (y :: [T])
16:26:24 <mauke> you could write a custom Arbitrary instance
16:26:33 <dibblego> I could, but I'm not sure what to wreite
16:26:39 <dibblego> what would it do?
16:27:04 <mauke> generate a more useful selection of test values
16:27:23 <mauke> with more equal components
16:31:17 <hpaste>  morrow pasted "fixites and precedences" at http://hpaste.org/7889
16:34:36 <dibblego> mauke, thanks; that's what I thought I'd need to do, but wasn't sure there was a better way
16:39:28 <hpaste>  NewBe annotated "Matrix Determinants and Pattern Matching -- Comments Please" with "matrix determinants and pattern matching... efficiency problems" at http://hpaste.org/7885#a1
16:39:33 <NewBe> Hello All, can anyone comment on the efficiency of http://hpaste.org/7885? It takes about 10 seconds to compute a 10 by 10 matrix.
16:42:25 <edwardk> newbe: well its pretty much brute forcing it
16:45:29 <NewBe> edwardk, yes but am I carrying out unnecessary computations?
16:45:33 <edwardk> the easiest answer would be to switch from Laplace's formula which takes n! time with Gauss Jordan or LU decomposition, LU should take O(n^3) if i'm recalling correctly.
16:45:44 <edwardk> the short answer is yes, the long answer: hell yes ;)
16:46:36 <NewBe> hahaha
16:46:43 <hpaste>  morrow pasted "phantom type e.g." at http://hpaste.org/7890
16:46:56 <NewBe> I guess I'll need to rewrite it then
16:47:38 <Pseudonym> LU decomposition is almost always far more stable, too.
16:47:39 <Pseudonym> FWIW
16:47:49 <edwardk> actually i should rephrase that you should use LUP decomp, because you'll need to pivot occasionally
16:48:40 <edwardk> http://en.wikipedia.org/wiki/LUP_decomposition
16:49:22 <edwardk> the P matrix makes sure you don't get stuck dividing by (near) zero.
16:49:43 <edwardk> er P vector
16:49:59 <Pseudonym> Well it's logically a matrix.
16:50:01 <edwardk> er no wait, its actually a matrix, i just always store it as a vector
16:50:02 <edwardk> yeah
16:50:03 <Pseudonym> Even if it's physically a vector.
16:50:14 <edwardk> =)
16:50:29 <shepheb> anyone have a handy algorithm for turning a [[a]] into a [[a]] of its diagonals?
16:50:53 <edwardk> shepheb: word searching? =)
16:50:55 <shepheb> or of a square matrix in an array, for that matter
16:51:03 <shepheb> edwardk: PE 81, actually.
16:51:33 <edwardk> ?
16:51:43 <shepheb> Project Euler, problem 81
16:51:44 <NewBe> edwardk, your right. LU Decomp will be way more efficient
16:51:49 <Saizan> shepheb: listArray bounds . concat ?
16:51:50 <edwardk> shepheb: ah
16:52:13 <Saizan> > range (0,0) (3,3)
16:52:21 <lambdabot>  Couldn't match expected type `(t1, t2) -> t'
16:52:31 <Saizan> ?type range
16:52:42 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
16:52:55 <Saizan> > range ((0,0),(3,3))
16:52:56 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
16:53:07 <edwardk> newbe: LUP decomposition, SVD and eigen(vectors|values) are the main tools you get out of linear algebra that you can use to beat the snot out of problems in practice ;)
16:54:40 <NewBe> I haven't taken Linear Algebra yet. ..I really need to learn more math lol  =]
16:55:33 <edwardk> newbe: if you're using this for an assignment make sure you spot the difference between LU and LUP and use the right one =)
16:56:16 <NewBe> I will. Thanks =]
16:56:25 <Saizan> the obsession to reuse every little available space makes me hate those algorithms, at least that's the way they make us implement them
16:56:36 <Pseudonym> Having said that, if you're working in low dimensions (say, up to about 4x4), often brute force algorithms work just fine.
16:56:39 <Pseudonym> e.g. Cramer's rule for determinants
16:56:52 <edwardk> I _almost_ have operads ready for use in Haskell. Anyone have any use cases in mind? =)
16:56:59 <orbitz> wooo NASA Phoenix has landed successfully
16:57:10 <slarba> \o/
16:57:10 <Corun> Indeed
16:57:14 * Corun was watchin'
16:57:18 <Corun> They all seem very happy now
16:57:19 <roconnor> \o/
16:57:22 <Pseudonym> Oh, I'd add that congugate gradient has served me well in the past.
16:57:26 <Pseudonym> conjugate
16:57:30 <Pseudonym> Well, PCG, anyway.
16:57:31 <roconnor> Haskell on Mars!!
16:57:48 <edwardk> its a bit of a pain in the butt since you need to basically carry a ton of stuff around in an HList, but hey
16:57:54 * roconnor starts rumours
16:57:55 <Pseudonym> edwardk: Sorry,  what's an operad?
16:58:15 <slarba> me too :)
16:58:26 <orbitz> it must be pretty awesome to have a sucessful landing of somethingthat only has one chance
16:58:34 <orbitz> at my job we try, and if it fails fix
16:58:35 <NewBe> I want to be an astronaut
16:58:44 <orbitz> doens't quite work for sapcecraft:)
16:59:07 <orbitz> does NASA use haskell at all?
16:59:13 <Pseudonym> orbitz: To be fair, NASA's theory of Mars probes is rather than send one costing $100 million with a 95% success rate, send ten at a cost of $10 million each with a success rate of 80%.
16:59:35 <Pseudonym> Moreover, you can decide what to send on the next one based on what you find from the previous one.
16:59:37 <dons> its the erlang model of reliability :)
16:59:37 <mrd> isn't their success rate closer to 50%
16:59:38 <Pseudonym> More bang for buck.
16:59:43 --- mode: ChanServ set -o dons
16:59:52 <Pseudonym> mrd: If you include the European probes, then yes.
16:59:58 <orbitz> dons: hah
17:00:01 <mrd> silly euros
17:00:02 <Pseudonym> I'm not sure what NASA's success rate is.
17:00:24 <hpaste>  morrow annotated "phantom type e.g." with "kabloom" at http://hpaste.org/7890#a3
17:00:31 <edwardk> Pseudonym: basically an operad is more or less like a type-level circuit diagram for lack of a better explanation. you have an 'identity circuit' which passes its input through unchanged, and the ability to compose a bunch n {k_1, ... k_n}-ary operators into a {k_1 + ... + k_n}-ary operator. i'm adding positional composition (insert a subcircuit at position k) and 'ap' to apply the operad to values taking a k-ary operad down to a k-1-ary ope
17:00:37 <dons> they definitely have some theorem provers, who'd be familiar with haskell
17:01:14 <edwardk> Pseudonym: lets just say that the name monad as used by Saunders Mac Lane (and Haskell) came about because J.P. May wanted a name that sounded like Operad and convinced Mac Lane to switch.
17:01:15 <Pseudonym> So essentially, not satisfied with a type-level logic language, you're doing arbitrary arrows.
17:01:25 --- mode: ChanServ set -o dcoutts
17:01:43 * orbitz wants to be deoped too. i wanna fit in
17:01:56 --- mode: ChanServ set +o Pseudonym
17:01:57 * mauke sets mode: -o orbitz
17:01:58 --- mode: ChanServ set -o Pseudonym
17:02:00 <orbitz> yaay
17:02:01 <Pseudonym> OK, I feel better now.
17:02:05 <edwardk> kinda. i haven't figured out a great use for them. they basically define associative composition of k-ary operators
17:02:09 <saml> is it better to have ErrorT at the outer most of transformer stack?
17:02:11 --- mode: ChanServ set -o Heffalump
17:02:28 <Pseudonym> Hmm.
17:02:34 <saml> i see differences between ErrorT at the outer and inner
17:02:50 <edwardk> they get a lot of use in some other fields. i figured it was worth trying to ape the interface in Haskell.
17:02:52 <saml> i like the behavior of ErrorT at the outer.. but i can't reason why
17:02:57 <Pseudonym> The thing I'd like to see is a single type system for handling monads, idioms and arrows all the same way.
17:03:05 <Pseudonym> Without wrapping things in Kleisli and the like.
17:03:17 <Pseudonym> Seems to me that this might help a bit.
17:03:43 <edwardk> tricky, because you have overlapping instances with the 'default' -> case.
17:03:47 <Pseudonym> Right.
17:03:51 <Saizan> saml: roughly, you lose every layer outside of ErrorT when you throwError
17:04:02 <edwardk> i beat my head on it a year ago and the closest we came was the (.) as fmap thing =)
17:04:09 <Pseudonym> Monads and arrows don't play nicely.  I know!  Let's make them both harder to use!
17:04:16 <edwardk> heh
17:04:32 <edwardk> in kata i can actually apply a Kleisli arrow so the Kleisli notation doesn't make it harder to work with
17:04:37 <saml> Saizan: hrm that makes sense
17:04:39 <edwardk> otoh, its tricker to know what . will do
17:05:06 <saml> it's because i use fail function in some monads. when those actions are outside ErrorT, things get ugly.
17:05:18 <edwardk> because Kleisli a . Kleisli b works differently than composition of basic functions if i abuse that
17:08:09 <edwardk> i am curious what the wadler arrow sugar would look like as 'the basic form of lambda and application in the language' though.
17:08:27 <jleedev> @type mfix (+)
17:08:28 <edwardk> with a lower level lambda and application (maybe with # mangling?
17:08:29 <lambdabot> forall a. (Num a) => a -> a
17:08:59 <saml> :t runState (runErrorT (runStateT (return ()) 0)) ""
17:09:00 <lambdabot> forall s e. (Num s, Error e) => (Either e ((), s), [Char])
17:09:25 <saml> so the inner StateT Int is gone
17:10:04 <saml> no it's there. but because of Either, it might be Left blah
17:13:15 <saml> @pl runState (runErrorT (runStateT a 0)) ""
17:13:15 <lambdabot> runState (runErrorT (runStateT a 0)) []
17:13:36 <saml> @pl f (g (h a 0)) ""
17:13:36 <lambdabot> f (g (h a 0)) []
17:14:07 <saml> @pl b a = f (g (h a 0)) ""
17:14:07 <lambdabot> b = flip f [] . g . flip h 0
17:20:09 --- topic: set to 'moderating discussion - we reserve the right to kick idlers' by glguy
17:20:41 <hpaste>  (anonymous) annotated "Simple Life" with "(no title)" at http://hpaste.org/1757#a1
17:23:38 <glguy> oops
17:23:38 --- mode: ChanServ set +o glguy
17:23:54 --- topic: set to 'Haskell (topic to be fixed)' by glguy
17:24:08 * Cale replaces getLine with putStrLn "" >> threadDelay (10^5)
17:25:45 --- topic: set to '["The Haskell programming language" ,"http://haskell.org " ,"Paste: http://hpaste.org " ,"Logs: http://tunes.org/~nef/logs/haskell/ ","Call for papers: http://haskell.org/haskell-symposium/2008/CFP.html "]' by glguy
17:25:47 --- mode: ChanServ set -o glguy
17:25:54 <Cale> #haskell-ops?
17:26:12 <orbitz> do you use >> or >>= when you wan tto write a quick one liner without do notation?
17:26:21 <Cale> Both.
17:26:27 <dibblego> orbitz, whichever is most appropriate
17:26:34 <Cale> >> ignores the result of the first action
17:26:40 <dibblego> orbitz, >> is a specialisation of >>=
17:26:42 <mauke> do you use + or * when you want to calculate stuff?
17:26:51 <Cale> >>= passes the result of the first action to the function on its right
17:26:57 <dibblego> mauke, * of course, you get more cookies!
17:27:08 <orbitz> mauke: well i've only seen code in do notation so far, so i'm unsur eof what istuations warrant >> and >>=
17:27:08 <Cale> MOAR COOOKIES!
17:27:31 <dibblego> orbitz, it might help to learn what do-notation desugars to
17:27:32 <mauke> > let 2 + 3 = 6 in 2 + 3
17:27:34 <lambdabot>  6
17:27:36 <Cale> orbitz: Well, do-notation is translated like this:
17:27:52 <Cale> do { v <- x; <stmts> } = x >>= \v -> do { <stmts> }
17:28:00 <Cale> do { x; <stmts> } = x >> do { <stmts> }
17:28:09 <orbitz> i get that do noaiton translates to >> and >>= and what not, but i haven't really seen in the examples i've read someone doing what do desugars to
17:28:18 <Cale> do { let { <decls> } ; <stmts> } = let <decls> in do { <stmts> }
17:28:35 <Cale> and finally
17:28:36 <mauke> do { x } = x
17:28:38 <Cale> do { x } = x
17:28:39 <Cale> yes
17:29:38 <Cale> actually, the translation for the "v <- x" case is a little more complicated if v is a more complicated pattern, but that's not worth worrying about. (it uses the fail function if the pattern match fails, which is an awful wart)
17:30:20 <edwardk> heya cale. btw 'Gen' = 'Codensity' in standard literature. a longer name that works well.
17:30:33 <edwardk> and its now newtyped so it can be a monad transformer
17:41:31 <Cale> edwardk: cool :)
17:42:38 <dolio> @undo [ x | (x:xs) <- tails l]
17:42:38 <lambdabot> concatMap (\ a -> case a of { (x : xs) -> [x]; _ -> []}) tails l
17:44:19 <edwardk> @seen ddarius
17:44:19 <lambdabot> ddarius is in #haskell, #haskell-blah, #haskell-overflow and #haskell-soc. I last heard ddarius speak 1h 23m 42s ago.
17:51:46 <edwardk> @tell ddarius it would appear that your earlier question over the discrete should require an equality gadt, data Equal a b where Reflexive :: Equal a a; data Colim f c = forall b. Colim (Equal (Trivial b) c) (f b) which then says you can't recover an arbitrary 'c' because you need a proof that its equal to the existentially quantified value in the trivial category. so Colim f = exists b. f b should sufice
17:51:46 <lambdabot> Consider it noted.
17:53:42 <wolgo> @src map
17:53:42 <lambdabot> map _ []     = []
17:53:42 <lambdabot> map f (x:xs) = f x : map f xs
17:55:34 <wolgo> Hey edwardk are you one of the Haskell maintainers?
17:55:44 <edwardk> not by a long shot =)
17:56:05 <edwardk> i'm just a guy who likes to try to drag obscure bits of math into practice.
17:56:23 <wolgo> oh
17:56:56 <wolgo> @go gadt
17:56:57 <lambdabot> http://en.wikibooks.org/wiki/Haskell/GADT
18:03:01 <wolgo> Have you ever read the book taxicab geometry?
18:03:14 <ddarius> edwardk: You are thinking too Haskelly
18:03:27 <edwardk> ddarius: that i'll admit is a failing of mine =)
18:03:41 <ddarius> Just use the representation "definition" of a left Kan extension.
18:05:33 <edwardk> ddarius: (Lan_K T) c = \int^m C(K m, c) * T m ? no thats the coend one, is there one from your writeup?
18:05:47 <edwardk> I lack your representable functor intuitions
18:06:05 <ddarius> edwardk: There is one there as the definition of Kan extensions.
18:06:37 <edwardk> Nat(Lan_J D, _) =~ Nat(D,-J)
18:07:31 <edwardk> lost it in the sea that is your kan extension section =)
18:07:51 <ddarius> Yeah, I've clean the article up a bit more.  I'll finish some day.
18:09:28 <atp> has anyone ever thought of doing an idiomatic haskell entry for the language shootout?
18:09:57 <atp> by entry i mean, listed as a separate language for the purposes of the shootout
18:10:46 <atp> i think it would be interesting to see how high-level elegant haskell fares in the competition
18:10:49 <edwardk> atp: the main result would be people going oh, look haskell sucks at performance if you implement naive algorithms
18:10:52 <atp> i know
18:10:55 <atp> that's the annoying thing
18:11:07 <edwardk> ddarius: running through it again
18:11:14 <atp> well, it's not so much that the algorithms would be naive
18:11:26 <atp> just that they wouldn't be written so imperatively
18:11:37 <atp> (not all of them are, currently)
18:12:06 <atp> but from the perspective of someone who prefers haskell, it would be neat to see where we are
18:12:24 <atp> i suspect we'd still kick the crap out of python, ruby, perl & co
18:13:02 <atp> it also would give the compiler & optimization geeks some data
18:13:13 <ddarius> edwardk: The coend definition will work as well, but you need to think about what it means when using a different category.
18:13:25 <ddarius> (The coend definition is probably easier.)
18:13:28 <ddarius> actually
18:13:47 <ddarius> You have to try to lose to ruby.
18:14:06 <glguy> that could be an interesting competition
18:14:07 <atp> yes, i know
18:14:07 <Mekham1> http://digg.com/api/diggthis.php?u=http%3A%2F%2Fdigg.com%2Fpolitics%2FBring_Back_the_Fairness_Doctrine#
18:14:10 <glguy> write slower code than ruby
18:14:13 * edwardk is watching what little respect ddarius had for him fade away ;)
18:14:13 <atp> haha
18:15:16 <dons> atp, what would idiomatic mean?
18:15:18 <atp> but seriously, i suspect that as the compiler's ability to algebraically reason about code improves, we'll see the gap between imperative and idiomatic haskell performance narrow to essentially zero
18:15:24 <atp> dons, well, that's the hard thing to define
18:15:25 <dons> lists only?
18:15:31 <atp> no, of course not.
18:15:33 <dons> Integer only? :)
18:15:39 <atp> hm
18:15:39 <ddarius> edwardk: Well, the first question is what category is the coend being taken over?  Also there is a reason why an integral notation is used.
18:15:46 <dons> strictness hints disallowed?
18:15:58 <dons> must work in hugs?
18:16:01 <atp> haha
18:16:04 <dons> h98 only?
18:16:07 <dons> its an interesting question
18:16:12 <atp> you make a good point, of course
18:16:20 <dons> features only in ghc for 5+ years?
18:16:27 <edwardk> |Set|
18:16:32 <dons> like ST, unboxed values, and implicit parameters
18:16:32 <dons> :)
18:16:36 <ddarius> Actually let's start earlier.  Expand the left Kan extension definition using coends and substitute the particular functors in and simplify.
18:17:15 <atp> dons: haskell is a great typesafe C
18:17:19 <dons> solution must be implementable by a person with no more than 1 year's haskell experience?
18:17:39 <atp> dons: no argument from me, and i think that's one facet of the language that people sometimes unfairly overlook, or accuse of "not really being haskell", which is bs
18:17:49 <ddarius> We have P : S -> Set and K1 : S -> Set where S is a set viewed as a discrete category.  We're trying to see what Lan_{K1} P is.
18:18:01 <dons> i've been told that this one isn't idiomatic,
18:18:01 <dons>  http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=ghc&id=6
18:18:03 <lambdabot> Title: sum-file Haskell GHC #6 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comp ..., http://tinyurl.com/ys3ony
18:18:25 <dons> actually, most often people complain about impurity and strictness hints.
18:18:26 <edwardk> Ok, so we went with: Lan_K P = \Int^m Set(K1 m, c) * P m)
18:18:28 <atp> dons: wait, are you serious?
18:18:31 <edwardk> er Lan_K1
18:18:38 <dons> i.e. you can only write pure, lazy code to be idiomatic
18:18:49 <dons> atp, well, i have receieved complaints about that one. though i think it is fine.
18:19:01 <edwardk> where K1 is constantly 1
18:19:03 <edwardk> so
18:19:05 <dons> the ones with mutable arrays receive more complaints
18:19:07 <atp> i think that's fairly idiomatic.
18:19:13 <dons> i should rank them by how many complaints there are
18:19:29 <atp> but you know, i guess my angle on this is,
18:19:30 <edwardk> Lan_K1 P = \Int^m Set(1,c) * P m
18:19:32 <atp> we know haskell can be very fast
18:19:36 <dons> this one gets lots of complaints,
18:19:37 <dons>   http://shootout.alioth.debian.org/gp4/benchmark.php?test=nbody&lang=ghc&id=0
18:19:42 <dons> but the performance sucks anyway
18:19:43 <lambdabot> Title: n-body Haskell GHC program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer  ..., http://tinyurl.com/5ozrrj
18:19:48 <atp> how close is ghc to being the mythical "sufficiently smart compiler"?
18:19:56 <dons> this one sometimes gets complaints,
18:19:57 <dons>   http://shootout.alioth.debian.org/gp4/benchmark.php?test=spectralnorm&lang=ghc&id=3
18:19:58 <lambdabot> Title: spectral-norm Haskell GHC #3 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 ..., http://tinyurl.com/5nmlvz
18:20:00 <dons> but performance is also awesome
18:20:16 <atp> hm
18:20:16 <dons> we're beating gcc on that one.
18:20:18 <ddarius> edwardk: Crap.  I made a mistake that's going to make this more complicated.
18:20:22 <atp> wow.
18:20:28 <atp> with the C backend?
18:20:28 <edwardk> heh, ok
18:20:33 <dons> sure.
18:20:36 <ddarius> Er, that is part of the issue.
18:20:43 <atp> that's interesting, isn't it?
18:20:47 <ddarius> It should be Lan_P (K1)
18:20:48 <atp> pretty cool :)
18:20:50 <dons> we beat gcc on 4 or 5 benchmarks iirc
18:20:51 <edwardk> heh
18:20:51 <edwardk> ok
18:20:56 <atp> yeah
18:20:56 <dons> used to be 12. but gcc is catching.
18:21:09 <atp> or maybe people are writing smarter C programs
18:21:09 <atp> or both
18:21:23 <mauke> > showGFloat (Just 0) 1 ""
18:21:26 <lambdabot>  "1"
18:21:27 <edwardk> by constantly 1 did you mean maps everything onto 1 or did you mean the identity functor?
18:21:37 <mar77a> we?
18:21:42 <atp> i guess what i'm trying to get a handle on is how magic ghc is
18:21:44 <mar77a> since when do you developh GHC dons ?
18:21:45 <ddarius> K1X = {*}
18:21:50 <edwardk> k
18:22:00 <edwardk> alright so revisiting
18:22:14 <atp> like, how good is its strictness analysis?
18:22:30 <atp> and more importantly, how is it improving?
18:23:10 * ddarius doesn't too much care about GHC strictness analysis improving.
18:23:25 <atp> neither do i, personally
18:23:29 <edwardk> Lan_P K1 c = \Int^m Set(P m, c) * K1 m = \Int^m Set(P m, c) * {*} = \Int^m Set(P m, c)
18:23:36 <atp> i don't use haskell because it's fast
18:23:39 <atp> even though it is
18:23:48 <ddarius> edwardk: What category is m varying over?
18:23:58 <atp> i use it because it is both safe and expressive, and optimizes code reuse
18:24:06 <dons> mar77a: on and off for 5 or so years.
18:24:07 <edwardk> m is varying over |Set|
18:24:08 <atp> and because it's easy to reason about
18:24:17 <dons> atp, the strictness analysis really just works.
18:24:23 <edwardk> er S as you called it
18:24:29 <mar77a> nice
18:24:38 <dons> if its strict, ghc knows, basically.
18:24:51 <atp> dons: i heard someone (and maybe this is outdated now in 6.8), maybe neil mitchell, talking about how ghc is fairly conservative when it comes to strictness analysis
18:25:07 <atp> but i don't really know the details, if that's still true, or ever was
18:25:20 <dons> i'm not sure about that really.
18:25:50 <dons> its best to talk in specifics about this kind of thing, i find.
18:25:57 <dons> i'm not even sure what 'conservative' means here.
18:25:57 <ddarius> edwardk: Yes, except S is a particular set regarded as a category, not Set discretized.
18:26:09 <atp> yeah, you're right, and i don't really have any way to quantify it either, so it's probably not very productive.
18:26:43 <edwardk> oh, i missed the 'a' in a set viewed as a discrete category
18:26:53 <edwardk> i heard 'Set viewed as a discrete category'
18:27:08 <atp> btw, dons, i was meaning to ask (this is unrelated) but where can i find out exactly was galois does?
18:27:32 <atp> i looked at the website but it's not very specific, and some of your comments here and elsewhere about building a kernel in haskell have me wondering
18:27:43 <edwardk> ok, so m is some element of that set.
18:27:46 <dons> well, the web site. we develop software for clients that have high assurance of correctness/safety requirements.
18:27:58 <dons> the shiny new web site should hopefully be online soon
18:28:04 <atp> any particular kind of software?
18:28:10 <atp> or basically "anything they want"?
18:28:32 <dons> usually its driven by the kind of scenarios that require high assurance: low level things, but increasingly more high level things (like web apps)
18:28:44 <dons> compilers, network devices, os components, user land stuff
18:29:01 <dons> so yeah, anything that they need serious assurance properties about.
18:29:10 <ddarius> edwardk: Okay.  So now the issue is just interpreting the coend. There's a handwavy way or a slightly less handwavy way.
18:29:24 <edwardk> i
18:29:29 <edwardk> i'll take what i can get ;)
18:29:52 <atp> dons: how does it compare to grad school in terms of intelligence density?  are you working with a lot of brilliant folks?
18:30:22 <ddarius> The very handwavy way is to take the terms "integral" and "discrete" very seriously.  If you "integrate" over a discrete domain what do you end up with.
18:30:25 <dons> actually, more concentrated than grad school
18:30:28 <ddarius> ?
18:30:39 <edwardk> nada
18:30:57 <dons> instead of having 5 language experts, there are 5 professors, and 30 odd graduates, many of them serious experts in their area.
18:31:17 <orbitz> in what way are they odd?
18:31:19 <orbitz> 30 is an even number
18:31:23 <dons> its like a small uni dept where everyone is a haskell guy :)
18:31:28 <atp> dons: wow
18:31:40 <atp> dons: that sounds pretty sweet
18:31:54 <edwardk> ddarius: 0, zip, zilch, nothing
18:32:04 <dons> also, being in the US helps, just better connected. we get lots of interesting tech talk speakers, for example
18:32:20 <dons> i hope to get galois tech talk videos online later in the year, actually
18:32:23 <atp> edwardk: depends on the measure? :p
18:32:23 <ddarius> edwardk: The domain is discrete, not the function over a continuous domain (but this is rather handwavy).
18:32:37 <edwardk> oh ok, then you just get a sum
18:32:43 <ddarius> Yes.
18:32:57 <augur> orbits: 30 is SO not a number
18:33:01 <atp> dons: that would be pretty cool, i'd like to see those
18:33:28 <edwardk> that makes a lot more sense than my previous thought =)
18:33:30 <atp> dons: it's interesting that being in the US helps, because it often seems like a lot of the academic work in fp is happening in europe these days...
18:33:34 <ddarius> So the coend is in set (over S) and so we have a "sum" in Set.
18:34:21 <edwardk> so when S is a singleton the sum reduces to just a term
18:34:36 <ddarius> edwardk: Yes.
18:34:57 <ddarius> So we have a Set sum indexed by elements of another set S.
18:36:00 <edwardk> so we go from \Int^m Set(P m, c) down to Set(P_S_1,c) + Set(P_S_2,c) + ... Set(P_S_|S|,c) ?
18:36:34 <ddarius> Yes, and what do we call that construct on the right, particularly when we replace "Set" with "Type"?
18:36:47 <edwardk> ->
18:37:25 <edwardk> er well the Set part of it is -> and the rest is just a coproduct of ->'s
18:37:53 <ddarius> So how would you notate that in type theory?
18:37:54 <edwardk> (P_S_1 + P_S_2 + ... P_S_|S|) -> c
18:38:51 <ddarius> s:S. Ps -> c
18:39:02 <edwardk> so i would say exists s.  (P s -> c)
18:39:04 <edwardk> yeah
18:39:15 <edwardk> er yeah
18:39:21 <ddarius> It's not an existential because s doesn't scope over all types.
18:39:29 <edwardk> (exists s \in S. P s) -> c
18:40:28 <edwardk> or did i misparenthesize that by reflex
18:40:35 <edwardk> gah
18:40:36 <gwern> are there any unofficial haskell package repos for ubuntu, anyone know?
18:40:48 <ddarius> But the upshot is, coends in set over a discrete category are dependent sums.
18:41:40 <ddarius> It's not uncommon to see Lan_J notated _J and Ran_J _J
18:42:16 <edwardk> hrmm
18:42:37 <edwardk> so when S is a singleton set...
18:42:39 <ddarius> Connectedness of a category is pretty significant for (co)ends in much the same way as it is for integration.
18:42:51 <Lemmih> gwern: http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html
18:42:51 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
18:42:51 <lambdabot> Title: Haskell Unsafe
18:43:36 <gwern> Lemmih: thanx
18:44:02 <gwern> Lemmih: hm. will there be problems interoperating debian/ubuntu?
18:44:41 <Lemmih> gwern: I don't think so.
18:44:42 <ddarius> The particular example Lan_P (K1) comes from a paper on containers and is just a roundabout way of saying X. s:S. P s -> X
18:47:46 <edwardk> sztill trying to directly apply this in Hask. i lack a good model of the category S here.
18:48:11 <edwardk> I can fake it with a GADT or something but the encoding there is really clunky
18:48:16 <ddarius> edwardk: It's not going to work out cleanly in Haskell as we lack dependent types.
18:49:00 <edwardk> ok, so my earlier example using the equality GADT was using the equality GADT to ape dependent types
18:49:47 <ddarius> (Co)limits over a discrete index category are exactly dependent sums/products.
18:49:53 <edwardk> *nods*
18:50:41 <edwardk> now it clicks into place.
18:52:08 <edwardk> heh now i want to code this up in agda instead even more ;)
18:53:18 <ddarius> It would get you nice things like pairs as the limit over Bool.
18:53:35 <ddarius> In Haskell we can only get (a,a) that way.
18:55:24 <edwardk> the only question then is if you have a single type over which you are taking the existential you should be able to pigeonhole it so this shouldn't need a dependent type to encode the colimit
18:56:45 <edwardk> L = \c. Sig s : S. P s -> c  is just whatever P * is when S : {*}
18:56:52 <edwardk> er
18:56:56 <ddarius> That's what you get when in LimD or ColimD D = KX for some X.
18:57:29 <ddarius> Or yeah, when the discrete set is 1 then it's simply a particular instance.
18:57:38 <edwardk> L = \c. P * -> c
18:57:52 <edwardk> for whatever the expansion of P * is
18:58:58 <edwardk> the only case i care about at the moment is precisely that, i only have the discrete set 1 to worry about by the definition of colimits as kan extensions no?
19:00:14 <ddarius> edwardk: That's the wrong thing to trivialize.  The sums and products would become sums and products of one thing.
19:01:05 <ddarius> But you still can't talk about the 1 category in Haskell.
19:02:19 <edwardk> ok, so returning to the limits as kan extensions bit for a sec. did we do the functor the wrong way that we extended along? E : Set -> S, rather than S -> Set is the case we want no?
19:02:20 <ddarius> In the Kan extensions defining (co)limits, you are going C -> 1, not 1 -> C as this case would work out to be.
19:02:31 <edwardk> i accept the fact that it will still break, but yeah =)
19:06:47 <edwardk> So E : Hask -> 1, P : Hask -> Hask, Lan_E P c = \Int^m 1(E m, c) * P m = \Int^m 1(1, c) * P m = \Int^m P m = exists m. P m
19:06:55 <edwardk> since c = 1 is the only possibility no?
19:07:26 <ddarius> Yes.
19:07:42 <edwardk> so we come full circle to a definition for Colimit
19:08:12 <edwardk> and i can finally kill that spurious a term with a clear conscience ;)
19:08:41 <ddarius> Yes, this is what I was talking about with 'h', I think it was, going to the wrong category.
19:08:53 <ddarius> However, this isn't analogous to the dependent sum case though.
19:08:58 <edwardk> sure
19:09:03 <edwardk> the dependent sum case makes perfect sense
19:09:16 <edwardk> i was just carrying out the colimit derivation using the tools developed exploring the other
19:09:45 <ddarius> Okay, just making sure.  I was uncertain where this "full circle" was started.
19:10:02 <edwardk> well full circle started because i had this definition in the source file 7 hours ago ;)
19:10:11 <edwardk> now i have a clearer motivation =)
19:11:15 <ddarius> Going through (co)ends is often nice because you don't have the extra hom that using a representation based approach has and yet you can do quite a few manipulations.
19:11:26 <edwardk> *nods*
19:15:52 <ddarius> Thorsten Altenkirch looks like he has some new papers that look interesting.
19:16:08 <edwardk> ?
19:16:41 <ddarius> http://www.cs.nott.ac.uk/~txa/publ/
19:16:42 <lambdabot> Title: Thorsten Altenkirch's drafts and publications
19:20:16 <ddarius> edwardk: Incidentally, when working with this stuff, I tend to use J : I -> C and D : I -> E where I is mnemonic for "index category", and D for "diagram" (and J is also "indexing" related)
19:21:23 <edwardk> fair nuff, heretofore i'd been able to get away with all of those being Hask ;)
19:36:27 <vixey> I like that data Dictionary = [(Reference, Dictionary -> Value)]
19:46:43 <gwern> anyone know who Frederik Eaton is on #haskell?
19:48:36 <RandomTroll> Hello, I am here purely as a test.
19:48:44 --- mode: ChanServ set +o Pseudonym
19:48:49 --- mode: Pseudonym set -o+b RandomTroll RandomTroll!*@*!#haskell-ops
19:48:49 --- kick: RandomTroll was kicked by Pseudonym (Pseudonym did this)
19:49:03 <Pseudonym> Woo!
19:49:42 <vixey> sooo many people trolling #haskell recently :/
19:49:53 --- mode: Pseudonym set -b RandomTroll!*@*!#haskell-ops
19:50:24 --- mode: ChanServ set -o Pseudonym
19:51:40 <dons> it was a test of the emergency troll broadcasting system. please do not adjust your channel settings
19:52:30 <roconnor> RandomTroll == Pseudonym  ?
19:52:37 <ddarius> Yes.
19:52:38 <newsham> what FRP framework do people use?
19:52:59 <dons> yampa formerly, but lately seems to be conal's stuff is taking off
19:53:09 <newsham> is it public yet?
19:53:12 <Pseudonym> Yes, RandomTroll was me.
19:53:23 <Pseudonym> It was either that or pick a random real user.
19:53:29 <newsham> also did the frp irc thing get released publically yet?
19:53:47 <dons> newsham: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:FRP
19:54:02 <newsham> danke
19:54:29 <newsham> is 'reactive' the one described in conal's 2007 paper?
19:55:05 <ivanm> what _is_ FRP? I don't seem to get the point of it :s
19:55:06 <dons> i think so. check with conal
19:55:56 <dons> ivanm: http://en.wikipedia.org/wiki/Functional_reactive_programming
19:56:24 <ivanm> yes, I read that... but what does FRP offer that you can't do in plain old FP?
19:56:39 <dons> better primitives for building this kind of program
19:56:48 <newsham> seems like the framework will do the updates in an efficient manner for you
19:56:55 <newsham> leaving you to define your system in a simple way
19:56:58 <ivanm> dons: "this kind"?
19:57:05 <dons> reactive programs
19:57:41 <Maciej> Hi!
19:57:56 <newsham> letting you define "piecewise continuous" functions in an efficient way
19:58:00 <newsham> it seems
19:58:08 <Maciej> Does anyone know where GHCi read the .ghci file from on a windows system?
19:58:34 <ivanm> dons: but what _are_ reactive programs?
19:58:36 <doun> "C:/Documents and Settings/User"?
19:58:46 <newsham> ivan: programs that react to events?
19:59:09 <Maciej> newsham, I tried that but it doesn't work.
19:59:51 <Maciej> Reading the file from the current directory works fine.
20:01:22 <ivanm> newsham: don't most programs react to events?
20:01:31 <Maciej> doun, sorry I've meant you
20:01:45 <EvilTerran> Maciej, it mentions in the ghc manual
20:02:08 <newsham> i wish there was a simple lay-person intro to FRP because I know a lot of people I would like to share this stuff with but I dont think they want could grok a dense haskell research paper
20:02:24 <doun> random blog post I wrote before: http://chrisdone.com/blog/2008/05/26/clixra-php-haskell/ pretty messy but I haven't written anything in ages
20:02:25 <lambdabot> Title: 17 Chris Done&#8217;s Blog 20  Clixra, PHP and Haskell b
20:02:44 <Maciej> EvilTerran, where is it? It just says "$HOME/.ghci"
20:03:08 <newsham> ivanm: http://conal.net/papers/simply-reactive
20:03:08 <lambdabot> Title: Simply efficient functional reactivity
20:03:10 <doun> Maciej: can you view what $HOME is in cmd.exe? uh, echo $HOME or w/e?
20:03:45 <EvilTerran> Maciej, i have one, which works, in "C:\Documents and Settings\Me"
20:04:30 <EvilTerran> i think the equivalent to $HOME on 'doze is OMEPATH% or SERPROFILE%
20:04:45 <EvilTerran> er, %HOMEPATH% or %USERPROFILE%, even
20:05:05 <Maciej> EvilTerran, it was empty. I set it to my home path but it still doesn't work.
20:05:09 <ddarius> Conal's papers tend not to be dense...
20:05:17 <SamB> mathematical theorems can't be copyrighted can they?
20:05:27 <ivanm> SamB: don't think so...
20:05:39 <SamB> does that include types?
20:05:42 <vixey> you can copyright numbers cant you?
20:05:49 <ivanm> numbers, however, are a different story... :p (i.e. numeric representations of codes, programs, etc.)
20:05:51 <vixey> I think we should ignore copyrights
20:06:42 <newsham> ddarius: its very readable, but not for my non-hsakell friends
20:06:45 <ivanm> vixey: let me know how you get away with that :p
20:07:22 <newsham> (well, even for me, all monoids and functors and stuff,  stuff I should know better but am still requires some thinking)
20:07:59 <vixey> newsham: why don't you write it then
20:08:17 <newsham> vixey: I only know a very little on the topic so far
20:08:25 <newsham> it would be a very poor and probably misleading paper :)
20:08:41 <ivanm> OK, so FRP operates on streams of values rather than discrete values?
20:08:56 <ivanm> laziness extended to IO? :p
20:09:08 <SamB> it basically operates on signals
20:09:23 <newsham> ivanm: it mixes continuous functions and discrete events
20:09:29 <ivanm> *nod*
20:09:43 <newsham> (I think) resulting in a piecewise continuous output
20:10:16 <SamB> conceptually
20:10:22 <ivanm> OK
20:10:32 <newsham> (or perhaps many of them)
20:10:42 <SamB> newsham: heh
20:10:42 <ivanm> when I saw that vector graphics vs bitmap example in conal's paper, it made more sense ;-)
20:10:56 <SamB> that's isomorphic to a piecewise continuous tuple anyway
20:11:35 <newsham> the primitives of continuous functions, events and switchers seem pretty interesting
20:11:53 <Maciej> EvilTerran: Now it works. I had to omit the quotation marks :-) Thank you for helping!
20:12:04 <newsham> i would like to see a real world example to understand it better
20:12:09 <newsham> ircbot would be nice :)
20:12:12 * ivanm too
20:12:23 <SamB> ... ircbot?
20:12:40 <cjs> @vixen
20:12:41 <lambdabot> Would you dress in women's clothes for me?  That really turns me on ;)
20:12:46 <SamB> I bet FRP does not shine in IRC
20:12:55 <SamB> @vixen
20:12:56 <lambdabot> Guys who can speak latin really turn me on.
20:13:02 * glguy has seen FRP in action in an IRC bot
20:13:03 <cjs> I think it does. I recall reading somewhere about some sort of FRP-based bot.
20:13:03 <newsham> samb: apparently someone's writen a bot recently using frp
20:13:18 <cjs> @quote frp
20:13:18 <lambdabot> No quotes match. My pet ferret can type better than you!
20:13:25 <SamB> what's special about it?
20:13:46 <newsham> dont know.. but I want to see because i roughly know what a bot does and i want to see how frp is applied to it
20:15:02 <adu> hi
20:15:07 <vixey> hey adu
20:15:19 <newsham> isnt one of the benefits of frp that it can hide the IO in a more functional way than monads?
20:15:24 <adu> I've been reading up on the NumericPrelude
20:16:09 <newsham> I think it would take a four year program for me to understan the numeric prelude :)
20:16:33 <adu> and NumericPrelude is good in that it breaks "Num" into at least 2 classes, and renames RealFloat to Transcendental, makes more sense, but I still think that there could be more separations
20:16:46 <adu> newsham: I could teach you in a week
20:17:03 <newsham> that would be a fun week.
20:17:18 <adu> newsham: you wanna start now? :)
20:17:35 <newsham> if you wanna start explaining some stuff, I have some time now (not a week, but you know.. some time)
20:17:41 <newsham> i'm always up for learning something new
20:18:01 <SamB> me too, except when I have to do school ;-)
20:18:06 <newsham> hah
20:18:17 <SamB> well, sometimes even then
20:18:20 <newsham> i enjoy school except for the not making money part
20:18:29 <hpaste>  adu pasted "My super numeric prelude" at http://hpaste.org/7891
20:18:39 <adu> did you
20:18:44 <adu> oo it posted itself, n/m
20:18:59 <newsham> why "magma"?
20:19:14 <adu> newsham: because thats how math does it
20:19:15 <SamB> newsham: it's an algebraic structure
20:19:24 <newsham> ok, what's a magma?
20:19:38 * SamB doesn't remember WHICH algebraic structure, though
20:19:41 <ddarius> adu: NumericPrelude isn't trying to make as many distinctions as possible.
20:19:47 <adu> http://en.wikipedia.org/wiki/Magma_%28algebra%29
20:19:53 <doun> it's only the one substance that can destroy The One Ring
20:20:32 <ddarius> newsham: Free magmas are non-empty trees.
20:20:38 <newsham> see I dont know abstract algebra or category theory (which is why I said "4 yrs to learn")
20:20:53 <adu> newsham: Almost everything that has 2 operands could be considered a magma
20:21:11 <newsham> ok, its just a set and a binary op?
20:21:12 <ddarius> newsham: You are very familiar with many common examples of monoids, groups, fields, magmas, rings and many other things.
20:21:13 <SamB> adu: what's the point of it?
20:21:20 <ddarius> newsham: Yes.
20:21:21 <adu> newsham: so the domain of applicability is very large, but also that would be bad in terms of type inference
20:22:04 <newsham> ok, I think i understand AddMagma and MulMagma...  now what about thenext few?
20:22:21 <SamB> I would speak of a binary operation
20:22:29 <adu> well ExtMagma is anything with scalar multiplication
20:22:40 <adu> like 2*matrix and matrix*2
20:22:47 <newsham> got it
20:22:58 <newsham> where a is the vector and b is the scalar
20:23:05 <adu> yes
20:23:18 <newsham> whats the addquasigroup?
20:23:30 <adu> AddQuasiGroup is anything with \x,y -> x-y and \x,y -> y-x style subtraction
20:24:03 <newsham> why /+  and +\   ?
20:24:07 <adu> QuasiGroup is traditionally used for left/right division, for example, matrices require left/right division
20:24:17 <adu> newsham: I dunno, because nothing else used them
20:24:37 <newsham> but its going to be used (usually) to capture subtraction?
20:24:39 <adu> but it also goes with the convension we've been using at the Tetration Forum http://math.eretrandre.org/tetrationforum/index.php
20:24:40 <lambdabot> Title: Tetration Forum
20:24:42 <ddarius> adu: Do you have an example of something that you'd use in programming that is an additive quasigroup that isn't an additive group?
20:25:55 <adu> ddarius: Integers
20:26:28 <adu> n/m that is an addative group...
20:27:53 <SamB> is it?
20:28:02 <ddarius> Yes.
20:28:15 <adu> yes, its the natural number that don't form an additive group
20:28:46 <SamB> oh, apparantly they form a quasigroup over subtraction...
20:29:02 <adu> well, they also form a semigroup
20:29:18 <adu> which means it isn't really a good argument for using quasigroups
20:29:38 <ddarius> SamB: How do they form a quasigroup over subtraction?
20:30:01 <adu> hmm, they don't
20:30:11 <adu> at least I don't think so.
20:30:16 <SamB> well, I'm just going by this article you linked to!
20:30:30 <SamB> maybe I'm misunderstanding it, but you probably ought to fix it
20:30:43 <SamB> er, indirectly http://en.wikipedia.org/wiki/Quasigroup
20:31:19 <adu> oh Yes, the integers form a quasigroup, but they also form a group
20:31:43 <adu> I thought you were talking about naturals
20:32:22 <wolgo> You know
20:32:42 <wolgo> There are some things in this language that are SO much more clearer than in python
20:32:44 <wolgo> well
20:32:47 <wolgo> at least for me
20:33:05 <adu> wolgo: you're not the only one who thinks so :)
20:33:07 * wolgo is an unexperienced programmer though
20:33:26 <SamB_XP_> why do you suppose we's all here and not in #python?
20:33:43 <newsham> because the people in #python arent very helpful?
20:33:50 <SamB_XP> well, I mean, besides all the friendly faces
20:33:53 <EvilTerran> i suspect a fair few of us are in both
20:33:55 <vixey> iirc they talk about #python in there
20:34:03 <vixey> python in there*
20:34:10 <vixey> which seems like a good reason to avoid it ..
20:34:16 <wolgo> SamB_XP you make a great point.
20:34:25 <SamB_XP> vixey: pay attention, that was my point
20:34:47 <SamB_XP> though it I seem to remember it being better years back...
20:34:47 <newsham> this channel has an unusually high density of smart/helpful people
20:34:59 <newsham> its un-irc-like
20:35:19 <ddarius> newsham: They're especially unhelpful if you are seeking Haskell advice.
20:35:30 <SamB_XP> ddarius: well duh
20:35:37 <newsham> ddarius: i've never tried.  might put the fear of dog in em though
20:35:39 <SamB_XP> if they had any of that to offer, they'd be here!
20:35:47 <EvilTerran> this channel is a bit of a throw back to the (good old?) early days of the internet, when it was comprised mostly of procrastinating academics
20:36:06 <SamB_XP> except we are mostly just the wannabes
20:36:07 <arw__> hm, especially the "knows about weird mathematics" kind of people which is very rare on irc...
20:36:42 <newsham> et: i was on irc in 1992 and even back then there werent many rooms filled with helpful, friendly, clued people
20:36:55 <newsham> (in fact, usually the more clue the less friendly :)
20:36:59 <SamB_XP> ... or are undergrads still allowed to be procrastinating academics?
20:37:24 <arw__> SamB_XP: sometimes.
20:37:29 <EvilTerran> if they are, i'm in that category
20:38:09 <Pseudonym> I was briefly on IRC in 1992.  That was back in the day when it was considered an unacceptable bandwidth hog.
20:40:20 <dons> hehe
20:40:23 <newsham> i've been hogging bw for a long time :)
20:43:02 <wolgo> Is there a better way to do this: head $ head $ splitter (group "aaaabbaa")
20:43:09 <wolgo> Just for my own edification
20:43:26 <vixey> head . head . splitter $ group "aaaabbaa"
20:43:33 <dibblego> wolgo, look at function composition (.)
20:43:36 <wolgo> ahh yes
20:43:41 <wolgo> thanks guys
20:43:49 <newsham> ?type splitter
20:43:52 <lambdabot> Not in scope: `splitter'
20:43:56 <davidL> I want to add a haskell version to: http://en.wikipedia.org/wiki/Fork_bomb is this alright? forkBomb = forever $ forkProcess forkBomb
20:44:03 <dibblego> let f = head . head . splitter . group in f "aaaabbaa"
20:44:26 <doun> :t group
20:44:28 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
20:44:32 <newsham> davidl: test it out? ;-)
20:44:43 <doun> > group [1,1,2,2,3,3]
20:44:45 <davidL> newsham: I did :D
20:44:45 <lambdabot>  [[1,1],[2,2],[3,3]]
20:44:53 <doun> hum
20:45:11 <doun> > group "I danced like a banana!"
20:45:12 <lambdabot>  ["I"," ","d","a","n","c","e","d"," ","l","i","k","e"," ","a"," ","b","a","n"...
20:45:17 <davidL> had to hard reboot
20:45:36 <shachaf> > group "bookkeeper"
20:45:38 <lambdabot>  ["b","oo","kk","ee","p","e","r"]
20:45:46 <newsham> > group "mississippi"
20:45:48 <lambdabot>  ["m","i","ss","i","ss","i","pp","i"]
20:46:13 <doun> newsham: heheh
20:46:15 <wolgo> > group "aaaabbcc"
20:46:17 <lambdabot>  ["aaaa","bb","cc"]
20:46:26 <vixey> @src group
20:46:27 <lambdabot> group = groupBy (==)
20:46:30 <vixey> @src groupBy
20:46:30 <lambdabot> groupBy _  []       =  []
20:46:30 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
20:46:30 <lambdabot>     where (ys,zs) = span (eq x) xs
20:46:34 <vixey> @src span
20:46:34 <lambdabot> Source not found. My mind is going. I can feel it.
20:46:40 <doun> =o
20:46:40 <wolgo> haha
20:46:58 <wolgo> I like you lambdabot will you be my bottish friend
20:47:15 <shachaf> @vixen Will you be wogo's bottish friend?
20:47:15 <lambdabot> why does everyone ask i'f on a bot?
20:47:21 <EvilTerran> what
20:47:52 <wolgo> ahah
20:47:59 <vixey> span p (x:xs) | p x = let (ps,qs) = span p xs in (x:ps,pq) | otherwise = xs ?
20:48:17 <wolgo> @type span
20:48:19 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:48:21 <ddarius> A bot would never typo like that.
20:49:08 <shachaf> ddarius: Why not?
20:49:27 <ddarius> shachaf: Because computers are perfect and can't make human errors.
20:50:40 <ivanm> ddarius: I beg to differ... have you forgotten about GIGO?
20:50:41 <shachaf> Computers are perfect and can't make human errors, perhaps, but they can make computer errors.
20:50:54 <davidL> why doesn't wikipedia have syntax highlighting for haskell? :-[
20:51:12 <doun> davidL: they were waiting for you to do it
20:51:35 <davidL> hah
20:51:55 <shachaf> doun: Your nick is too similar to "dons".
20:52:06 <doun> oh, um
20:52:32 <ddarius> That's something dons would say though.
20:52:33 <shachaf> No need to change it, sorry. :-)
20:52:44 <shachaf> ddarius: That doesn't help. :-)
20:53:11 <kiris>  @_@
20:53:57 <kiris> I prefer kiris anyway, doun isn't valid lojban
20:54:27 <shachaf> I hijacked shapr's tab completion when I came here, anyway...
20:54:40 <gwern> davidL: the hawiki has haskell highlighting
20:54:49 <adu> kiris: I though it was logban?
20:55:08 <gwern> davidL: but I suspect bugging the Wikipedia devs won't get very far
20:55:23 <kiris> adu: perhaps you are thinking of loglan
20:55:52 <davidL> gwern: that's a shame, should I just do <source lang=text> ?
20:58:52 <adu> kiris: maybe
20:58:57 <newsham> wow.  http://conal.net/blog/posts/beautiful-differentiation/
20:58:58 <lambdabot> Title: Conal Elliott  Blog Archive  Beautiful differentiation
20:59:07 <newsham> 29loc.
20:59:48 <gwern> davidL: ah, actually, wikipedia does do syntax highlighting
20:59:48 <gwern> http://www.mediawiki.org/wiki/Extension:SyntaxHighlight_GeSHi
21:00:13 <gwern> but not haskell - https://secure.wikimedia.org/wikipedia/en/w/index.php?title=User:Gwern/Archive-bot.hs&oldid=214975109
21:00:14 <lambdabot> http://tinyurl.com/567z8c
21:00:15 <davidL> gwern: yeah but not haskell
21:00:48 <davidL> gwern: I choose text instead: http://en.wikipedia.org/wiki/Fork_bomb :)
21:01:00 <ddarius> newsham: You'd probably find most of Jerzy Karcmarczuk's (Haskell related) work interesting (but then so would just about anyone here.)
21:01:30 <newsham> i'll have to take a peek
21:01:42 <gwern> what does Jerzy do?
21:02:54 <gwern> bleh. haskell has been a request since 2007
21:02:56 <gwern> https://bugzilla.wikimedia.org/show_bug.cgi?id=10967
21:07:07 * gwern encourages people to vote on https://bugzilla.wikimedia.org/show_bug.cgi?id=10967
21:15:23 <shachaf> gwern: I would need to make an account.
21:25:06 <vixey> reverse . reverse = id !
21:25:39 <mrd> > reverse . reverse $ [1..]
21:25:39 <shachaf> > (reverse . reverse) [1..]
21:25:43 <lambdabot> Terminated
21:25:46 <lambdabot> Terminated
21:25:48 <vixey> wow!
21:25:49 <mrd> bahahah
21:25:51 <vixey> great minds
21:31:46 <Spazitive> http://www.FakeMagazineCover.com - Upload photo to fake magazine cover templates
21:31:48 <lambdabot> Title: Fake Magazine Cover Maker, Make Parody Covers With 500 Magazines Templates, Uplo ...
21:31:51 <Spazitive> http://www.ComedySearchEngine.com - Funny sites, days of fun
21:31:56 <lambdabot> Title: Comedy Search Engine - Funny Links To Humor Sites
21:31:58 <Spazitive> http://www.SillyWebcam.com - Play with webcam online (games, take pics, effects)
21:32:01 <lambdabot> Title: Silly Flash Webcam Tricks & Effects - Take Instant Photos Online For Free With W ...
21:32:02 <Spazitive> http://www.Is-A-Jerk.com - Random Insults/Anon Email
21:32:04 <lambdabot> Title: Who Is A Jerk? Random Insult Generator (DANGER/BEWARE)
21:32:05 <Spazitive> http://www.WHAK.com - W.H.A.K. Comedy Radio
21:32:06 <vixey> Spazitive: please don't ...
21:32:12 <lambdabot> Title: Get Whacked, WHAK Comedy Radio Is Now Online!
21:32:12 <Spazitive> http://www.SignGenerator.org - Sign generators (change letters on a church sign or...)
21:32:14 <lambdabot> Title: Sign Generator Fun, Over 500 Sign Generators
21:32:18 <Spazitive> http://www.BodySwitcher.com - Upload photo, put your face on a funny body
21:32:18 --- mode: ChanServ set +o Pseudonym
21:32:20 <lambdabot> Title: Body Switcher, Put Your Face On Another Body In A Funny Scene
21:32:22 --- mode: Pseudonym set -o+b Spazitive Spazitive!*@*!#haskell-ops
21:32:22 --- kick: Spazitive was kicked by Pseudonym (Pseudonym did this)
21:32:27 --- mode: ChanServ set -o Pseudonym
21:32:38 <Pseudonym> Woo!  I get to use my new macro on a real one!
21:34:07 <ohub_> what's that: "Spazitive!*@*!#haskell-ops" #haskell-ops doing there?
21:34:17 <vixey> "turn trolls into committers"
21:34:18 <vixey> :)
21:34:33 --- mode: ChanServ set +o Pseudonym
21:34:36 <vixey> or maybe Spazitive is a potential op
21:34:52 --- mode: Pseudonym set -b Spazitive!*@*!#haskell-ops
21:35:19 <vixey> ohub: (It redirects the user to that channel when they try to join this one, I don't know what that channel is for though)
21:35:39 <ohub_> vixey; ah, cool
21:36:35 --- mode: ChanServ set -o Pseudonym
21:36:48 <Pseudonym> Sorry, those with more ops experience than I: The -o is right or wrong?
21:37:04 <Pseudonym> I always figured it was extra insurance or something.
21:37:10 <gwern> shachaf: so? making an account isn't hard
21:37:11 <Pseudonym> But it came with the macro that I modified.
21:37:21 <vixey> Pseudonym: "-o" ?
21:37:27 <shachaf> gwern: Why don't they support OpenID?
21:38:01 <vixey> freenode policy is to not stay opped all the time
21:38:18 <Pseudonym> In the ban line.
21:38:32 <vixey> well that means you unbanned them
21:38:38 <Pseudonym> No, the -o.
21:38:48 <mrd> well
21:38:55 <mrd> if they had ops, then i think the ban might not mute them
21:39:02 <Pseudonym> Ah, right.
21:39:18 <Pseudonym> If an op misbehaves in #haskell, that's probably more serious than a mere redirect ban.
21:39:39 * dibblego pokes his bum out
21:39:49 <Pseudonym> That is acceptable.
21:40:05 <Pseudonym> Although someone sticking their bum out... it's really tempting to kick.
21:41:46 <gwern> shachaf: dunno. who does?
21:42:46 <shachaf> gwern: I support OpenID!
21:43:52 <gwern> excellent. now convince the mediawiki devs you are important, and that supporting openid has no undesirable security ramifications :)
21:44:53 <Pseudonym> Anything useful has possibly undesirable security ramifications.
21:45:30 <ddarius> Pseudonym: You're bad at this persuasive argument thing.
21:45:58 <Pseudonym> Not at all.  I'm just maintaining NPOV.
21:46:58 <arw__> Pseudonym: how dare you. this is wikipedia we are talking about :>
21:47:14 <gwern> this erlang history paper is really interesting
21:47:19 <gwern> I had no idea it started off as prolog
21:47:28 <ddarius> gwern: ?
21:48:02 <vixey> yeah that's a really good paper
21:48:32 <ddarius> My understanding was that it started off as an interpreter written in Prolog and more Prology than now.  Either way, looking at it's syntax should give you more than enough of a hint.
21:50:46 <gwern> I have never really looked at either prolog or erlang syntax
21:51:27 <vixey> Prolog is just lisp with infix operators
21:51:39 <obk> gwern: You didn't miss much. The Prolog suntax suck like a black hole.
21:51:40 <vixey> (and a different evaluation model)
21:51:52 <vixey> obk: black hole how
21:51:53 <gwern> although it does bug me how erlangers keep saying 'you need two computers to be fault tolerant
21:51:53 <obk> The evaluation model, on the other hand, rocks.
21:51:53 <newsham> that doesnt sound like something that belongs in parenthesis
21:52:19 <obk> Prolog syntax is a great example why mathematicians should nbot design programming languages ;-)
21:52:23 <vixey> obk: You know about op/3 ?
21:52:31 <obk> Yup
21:52:37 <obk> Using separators instead of terminators
21:52:40 <atp> i have to agree, prolog is the win, but the syntax is terrible
21:52:41 <vixey> not sure what you mean black hole then
21:52:44 <obk> Several levels of them at that
21:52:53 <ddarius> gwern: What if one of them catches on fire?
21:53:02 <obk> Ok, sucks like a Dyson vacuum cleaner then :-)
21:53:13 <vixey> obk: certainly not
21:53:17 <gwern> if prolog is lisp with different syntax, and a different evaluation model, does that mean fortran is also lisp? (just with different syntax and evaluation models...)
21:53:44 <obk> Hey, Church's lemma. *Everything* is lisp...
21:53:51 <vixey> obk, atp come to #prolog ? (I don't want to paste Prolog code here)
21:54:05 <obk> Sure, why not...
21:55:56 <newsham> hpaste?
21:55:58 <gwern> ddarius: what if the network connecting them catches on fire? obviously to be truly fault tolerant we need two networks of two computers each, one observing the other. But wait, what if an asteroid cracks the crust of the Earth? obviously we need two Earths with two networks with... (and then we're still vulnerable to CERN collapsing the false vacuum, so I guess we had better require two universes...)
21:56:27 <ddarius> gwern: Now you've got the spirit.
21:56:54 <gwern> and of course, just two computers does not seem to do much good if the power grid they are both attached to decides to go on vacation
21:57:17 <ddarius> That's why they have to be geographically separated.
21:57:24 <ddarius> (or else they'd both catch on fire together)
21:57:29 <gwern> so I do not really see why they wish to draw the line at one interpreter on one computer, and not, say, one computer running two interpreters
21:57:48 <arw__> the really evil part would be the arbiter which gets to device which one gives faulty results...
21:58:05 <ddarius> arw__: That's why you need three.
21:59:13 <arw__> but then you would need two, no, three arbiters, because they could fail, too
22:00:08 <gwern> three arbiters, and a fanatical devotion to the pope!
22:00:22 <gwern> wait, let me try that again...
22:01:28 <gwern> (our 5 weapons are three arbiters, a fanatical devotion to the pope, - and terror. no, our 6 - *amongst* our weapons....)
22:02:01 <glguy> What are you guys working out?
22:02:41 <arw__> world domination by reliable computers...
22:03:51 <gwern> '    It was now time to implement the JAM virtual machine emula-
22:03:51 <gwern> tor, this time not in Prolog but in C. This is where Mike Williams
22:04:55 <gwern> came in. I started writing the emulator myself in C but soon Mike interfered and started making rude comments about my code.
22:06:04 <gwern> hee hee. an object lesson about criticisng other people's code?
22:07:04 <vixey> I don't understand
22:08:41 <gwern>        Managements first reaction at the time was if weve done
22:08:41 <gwern> something good, we should keep quiet about it, quite the opposite
22:08:41 <gwern> to todays reaction to the open-source movement.
22:09:16 <gwern> vixey: how so?
22:10:18 <cjs> Where are the docs for :set prompt in GHCi?
22:10:48 <cjs> particularly, are there, e.g., substitutions for letting me keep the current scope indications, but doing them in a more pleasant way?
22:11:20 <cjs> Actually, what I'd really like is an Infocom-like status bar at the top of the window always showing the current scope, and maybe the last-evaluated result....
22:11:57 <cjs> Ah, found the docs....
22:17:05 <Dzlk> cjs: You'd need curses, I think. Or you could put it in xterm titlebar, which would be kind of cute.
22:17:36 <shachaf> Is there a Haskell interpreter for the Z-machine? :-)
22:17:57 <cjs> Hey, that's an idea.
22:18:04 <Dzlk> http://www.haskell.org/pipermail/haskell/2006-December/018871.html
22:18:06 <lambdabot> Title: [Haskell] ANNOUNCE: ZMachine 0.0, http://tinyurl.com/6gjtxz
22:18:09 <cjs> I could even write a ghci command to do that one. Thanks Dzlk!
22:18:20 <lament> if somebody writes one in inform 7....
22:18:26 <Dzlk> cjs: Welcome. :)
22:18:34 <shachaf> Dzlk: Oh, I meant the other way around. :-)
22:18:49 <Dzlk> Oh. :)
22:19:13 <lament> the z-machine is kinda dying, is it not
22:19:15 <ddarius> shachaf: Try talking to SamB.
22:19:22 <lament> with glulx taking over
22:20:10 <gwern> huh. so wadler tried to add a real type system to erlang
22:20:19 <gwern> spent a year doing it
22:20:24 <lament> he... BETRAYED HASKELL?
22:20:24 <ivanm> gwern: and?
22:20:30 <ivanm> lament: he's working on links now
22:21:19 <lament> he MODIFIED A VALUE
22:21:26 <ivanm> hmmm?
22:21:27 <gwern> ivanm: well, he failed obviously
22:21:27 <gwern>                                          To start with, only a sub-
22:21:27 <gwern> set of the language was type-checkable, the major omission being
22:21:27 <gwern> the lack of process types and of type checking inter-process mes-
22:21:27 <gwern> sages. Although their type system was never put into production
22:21:40 <lament> (LOL reference)
22:21:40 <ivanm> *nod*
22:21:59 <ivanm> erlang sounds cool.... but when I wanted to learn it the syntax scared me :s
22:22:00 <lament> (LOL, of course, means Land Of Lisp)
22:22:16 <ivanm> hopefully the haskell -> erlang translator someone announced recently will change this! ;-)
22:22:29 <ivanm> lament: as opposed to Laugh Out Loud?
22:31:32 <gwern> language -> language things have a big tendency to stagnate...
22:31:35 <gwern> I have seen many compilers and transltoers in haskell <-> something else come and go
22:32:16 <vixey> it's just silly
22:34:40 <wolgo> @type &&&
22:34:42 <lambdabot> parse error on input `&&&'
22:34:48 <vixey> :t (&&&)
22:34:50 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:34:50 <wolgo> @type (&&&)
22:34:52 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:35:00 <vixey> btw
22:35:06 <wolgo> ugh
22:35:16 <vixey> forall ((~>) :: * -> * -> *) b c c'. (Arrow (~>)) => b ~> c -> b ~> c' -> b ~> (c, c')
22:35:26 <vixey> forall ((~>) :: * -> * -> *) b c c'. (Arrow (~>)) => (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
22:35:29 <vixey> actually that's clearer
22:35:42 <wolgo> Hahah thanks vinc456 I do not know what Arrow is, and I do not know what ~> or ' means
22:35:44 <wolgo> oops
22:35:51 <wolgo> vixey
22:36:25 <vixey> ' is part of an identifier name
22:36:37 <wolgo> what is? '
22:36:43 <vixey> > let foo' = 3 in foo' + foo'
22:36:44 <lambdabot>  6
22:36:46 <vixey> > let foo = 3 in foo + foo
22:36:48 <lambdabot>  6
22:41:09 <dibblego> what's a left fold with a possible early break?
22:44:15 <newsham> "break" implies control flow.
22:44:51 <dibblego> how would you write and to run in constant stack space?
22:45:02 <vixey> @src and
22:45:03 <lambdabot> and   =  foldr (&&) True
22:45:15 <vixey> using a left fold?
22:45:24 <vixey> can't we maybe use callCC to do it?
22:45:24 <dibblego> a left fold traverses the whole list
22:45:34 <newsham> ?src (&&)
22:45:34 <lambdabot> True  && x = x
22:45:34 <lambdabot> False && _ = False
22:45:52 <vixey> I mean callCC to get the early out
22:46:51 <newsham> > foldr (&&) True [a,b,c,d]
22:46:53 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Expr'
22:47:14 <dibblego> foldr will build the stack
22:47:51 <vixey> what about
22:47:59 <vixey> foldl (flip (&&)) True ?
22:48:05 <vixey> :t foldl (flip (&&)) True
22:48:06 <lambdabot> [Bool] -> Bool
22:48:19 <vixey> does this work in constant space?
22:48:52 <newsham> foldr (&&) True [False,...] = (&&) False (foldr (&&) True ...)
22:49:03 <newsham> (&&) False _ = False
22:49:28 <_smg> vixey: what do you need to do?
22:49:52 <vixey> _smg: maybe I'm misunderstanding what dibblego was saying
22:49:57 <newsham> isnt that going to bail out immediately?
22:50:01 <_smg> i dunno
22:50:04 <_smg> i just joined the chat
22:50:18 <vixey> newsham: yes it is
22:51:54 <dibblego> > foldl (flip (&&)) True (False: repeat True)
22:51:56 <lambdabot>  out of memory (requested 1048576 bytes)
22:52:23 <newsham> > foldr (&&) True (False:repeat True)
22:52:24 <lambdabot>  False
22:52:30 <Cale> > foldl (flip (&&)) True (False: repeat True)
22:52:33 <lambdabot> Terminated
22:52:39 <Cale> okay, that's better :)
22:52:43 <smg> hi Cale
22:52:44 <dibblego> foldr will build the call stack
22:52:45 <Cale> hi
22:53:05 <smg> you prolly know "haskell - craft of functional programming (addison wesley)"?
22:53:13 <Cale> I know of it.
22:53:24 <vixey> > foldl ((&&)) True (False: repeat True)
22:53:28 <smg> is it good + advanced?
22:53:40 <lambdabot>  thread killed
22:53:41 <vixey> > foldr (flip (&&)) True (False: repeat True)
22:53:42 <lambdabot>  Exception: stack overflow
22:54:12 <smg> vixey: you're evil!
22:55:06 <Cale> smg: I haven't really read it myself... I think it's supposed to be reasonably good, but you can expect there to be some content which is dated.
22:55:18 <smg> k
22:55:40 <smg> i just need something for the formal stuff like lazyness, evaluation strategies etc
22:56:00 <vixey> what do you want to know ?
22:56:33 <smg> vixey: all about, type cheking, evaluation strategies and so on
22:56:58 <vixey> TAPL is the best book I know about type cheking
22:57:11 <vixey> for basics
22:57:21 <smg> tapl?
22:57:32 <vixey> I don't think there's much to evaluation strategies
22:57:41 <smg> what means tapl?
22:57:51 <dibblego> Types and Programming Languages
22:58:03 <smg> mh, is this haskell specific?
22:58:13 <dibblego> no
22:58:27 <vixey> first hit for http://www.google.com/search?q=TAPL
22:58:28 <lambdabot> Title: TAPL - Google Search
22:58:39 <smg> mhhh
22:59:31 <smg> maybe i lease both
22:59:36 <smg> tapl and craft of haskell
23:02:08 <smg> ty vixey and Cale
23:06:08 * ddarius finally figures out the right incantations to get a simple example to work in LolliMon.
23:06:36 <vixey> btw isn't Lambda Prolog a proper superset of LolliMon?
23:08:20 <ddarius> It should be.  It should be the intuitionistic fragment.
23:09:27 <ddarius> Hmm
23:09:34 * ddarius performs an experiment in affine logic.
23:21:06 <Dzlk> Hmm.
23:21:23 <vixey> hi Dzlk!
23:21:33 <Dzlk> Hi!
23:21:40 <vixey> (:
23:22:00 <Dzlk> @pl \x xs -> (Left x) : []
23:22:01 <lambdabot> const . return . Left
23:24:43 <Dzlk> @pl \x xs -> (Right x) : xs
23:24:44 <lambdabot> (:) . Right
23:24:45 <Dzlk> Foo.
23:24:59 <vixey> what are you coding?
23:25:24 <vixey> @pl \(x:xs) -> f x : xs
23:25:25 <lambdabot> ap ((:) . f . head) tail
23:25:27 <newsham> "I see FRP as being a viable alternative to imperative programming, especially with concurrency. Like the imperative programming model, FRP is about change. Unlike concurrent imperative programming, FRP has formally tractable.even simple.semantics."
23:26:23 <Dzlk> Ah, just fiddling.  and' (Left x) _ = (Left x):[] ; and' (Right x) xs = (Right x):xs
23:27:01 <vixey> and' (Left x) _ = [Left x] ; and' (Right x) xs = Right x : xs is another way to write that
23:28:58 <vixey> hmm
23:29:01 <vixey> @src Either >>=
23:29:01 <lambdabot> Source not found. I am sorry.
23:29:07 <vixey> @src >>= Either
23:29:07 <lambdabot> Source not found. stty: unknown mode: doofus
23:29:24 <dibblego> (Either e) is the monad
23:29:25 <vixey> bad bot
23:29:27 <Vq^> @src Maybe (>>=)
23:29:28 <lambdabot> (Just x) >>= k      = k x
23:29:28 <lambdabot> Nothing  >>= _      = Nothing
23:29:37 <vixey> @src (Either e) >>=
23:29:38 <lambdabot> Source not found. You untyped fool!
23:29:42 <vixey> @src Either e >>=
23:29:42 <lambdabot> Source not found. Where did you learn to type?
23:30:04 <Vq^> @src (Either e) (>>=)
23:30:05 <lambdabot> Source not found. :(
23:30:45 <Vq^> at least it didn't insult me
23:31:41 <qebab> @src Either (>>=)
23:31:41 <lambdabot> Left  l >>= _ = Left l
23:31:41 <lambdabot> Right r >>= k = k r
23:52:42 <Plareplane> @help
23:52:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:52:46 <Plareplane> @list
23:52:46 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
23:53:25 <vixey> ?where lambdabot
23:53:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
23:53:39 <vixey> hi jgracin
23:54:29 <hpaste>  plareplane pasted "is ghci mean to me or mean to threads" at http://hpaste.org/7892
23:55:43 <bos> Plareplane: you can't use gtk from multiple threads in an language.
23:56:27 <Plareplane> hmm, what would be the proper way of doing that example?
