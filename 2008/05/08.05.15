00:00:07 <dmwit> Okay, the first thing you need to do is find out what things are available for you in the Prelude.
00:00:12 <dmwit> That will help you a lot.
00:01:07 <dmwit> For example, you're using (Array.!), when you could just use (!!), you're doing your own String -> Int conversion, you're writing your own simple list recursions...
00:02:41 <dmwit> Also, it will help you a lot, I think, to convert your [Int] representation into one that's closer to the problem domain.
00:04:02 <sjanssen> gardy: you're writing C in Haskell :)
00:04:28 <dmwit> Take a look at these functions, for a start: take, drop, read, length, map
00:05:07 <dmwit> Also, bonus points for your definition of have_pattern. =)
00:06:20 <dmwit> You should be able to get a pretty elegant solution without ever touching Arrays.
00:06:56 <dmwit> (And probably without even using explicit list recursion -- i.e. without pattern matching on (h:t) anywhere.)
00:08:40 <gardy> Thanks. :-)
00:08:50 <gardy> I'll try this way.
00:09:43 <Vq^> gardy: stringarraytointarray = map strtoint
00:10:02 <Vq^> for a starter :)
00:11:11 <bd_> ... is it me or is list the identity function? XD
00:11:14 <bd_> @ xa.hs
00:11:34 <dmwit> bd_: There's a lot of wacky stuff in there.
00:12:00 <dmwit> Try looking at "input" and where it's used. =)
00:12:16 <sjanssen> :)
00:12:26 <gardy> pls don't laught at me... i started to program in haskell on last friday
00:12:26 <bd_> my head hurts
00:12:34 <dmwit> It's okay, we understand.
00:12:40 <dmwit> I wrote code like this at the beginning, too.
00:12:43 <bd_> gardy: we were all there once
00:12:48 <dmwit> It's hard to wrap your head around the new style.
00:12:57 <gardy> yes. it is.
00:16:01 <Vq^> gardy: http://undergraduate.csse.uwa.edu.au/units/230.301/lectureNotes/tourofprelude.html
00:16:04 <lambdabot> Title: A Tour of the Haskell Prelude, http://tinyurl.com/ywhnjx
00:16:24 <Vq^> gardy: look at the functions dmwit recomended in that page
00:18:18 <gardy> Thanks for all of you. You help a lot. I can't find function collections like this.
00:20:07 <dmwit> heh
00:20:09 <dmwit> ?quote vixen
00:20:10 <lambdabot> vixen says: If you see this, gentle sir, know that you are being trolled by a poorly configured VixenLove program
00:20:45 <lament> ?vixen how configured are you, baby?
00:20:45 <lambdabot> yes, i am
00:22:04 <Vq^> gardy: Haskell has a lot of what we call higher-order-functions, they take functions as arguments and encapsulates patterns like the one in your stringarraytointarray for example
00:52:53 <BeelsebobWork> Is there a hackage database that can be more easily parsed than the webpage?
00:53:23 <BeelsebobWork> ideally something that I can query and get back a string that can be "read"ed, to get a nice Haskell data structure of them
00:53:55 <glguy> BeelsebobWork: go to hackage.haskell.org
00:53:58 <glguy> and look for "raw data"
00:54:54 <BeelsebobWork> is anyone working on a hackage process that parses the tarbal of package descriptions and does the pkg management bit for you?
00:55:36 <glguy> cabal-install is something similar
00:55:52 <BeelsebobWork> ah, cool
00:55:54 <BeelsebobWork> win :)
01:02:47 <gardy> :) With your help I can make what I want in a half hour. I try to make it for 3 days... THANKS! bye
01:06:26 <pejo> swiert, noticed you were doing a writeup of your thesis - what is it about?
01:06:43 <swiert> pejo: Beauty in the Beast++
01:07:09 <swiert> pejo: How to give a total, pure specification of various effects in a dependently typed programming language.
01:08:41 <swiert> but there's various bits of work I've done over the last years that are definitely related (the recent TFP paper, Data types a la carte)
01:16:28 * dmwit smiles at gardy's comment
01:16:30 <dmwit> Great!
01:24:47 <quicksilver> swiert: so can we expect a practical effectful dependently typed language from you shortly?
01:25:18 <swiert> quicksilver: well... We're getting there. Agda and Coq are pretty amazing nowadays.
01:25:38 <swiert> both allow you to extract code to Haskell, for example.
01:25:42 * quicksilver nods
01:26:39 <swiert> and Agda even has FFI to Haskell that allows you to import IO functions.
01:28:47 <solrize> swiert what about really old-fashioned effectful code typed by something like hoare logic?
01:28:48 <Syzygy-> ?index fix
01:28:48 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
01:28:54 <Syzygy-> :t fix
01:29:02 <lambdabot> forall a. (a -> a) -> a
01:29:03 <Syzygy-> ?type fix
01:29:04 <lambdabot> forall a. (a -> a) -> a
01:29:07 <pejo> swiert, what can us mere mortals learn from it? :-)
01:29:16 <vixey> :t Control.Monad.Fix.fix
01:29:18 <lambdabot> forall a. (a -> a) -> a
01:29:31 <vixey> :t Control.Monad.State.fix
01:29:32 <swiert> solrize: Good point. There's some nice work by Greg Morrisett and Aleksandar Nanevski on YNot.
01:29:33 <lambdabot> forall a. (a -> a) -> a
01:29:40 <vixey> how come they are all the same?
01:29:57 <solrize> bah, i typed ynot into google and the first hit was a porn site
01:30:15 <vixey> try: ynot coq
01:30:18 <solrize> http://www.eecs.harvard.edu/~greg/ynot/  aha :)  thanks
01:30:19 <lambdabot> Title: Ynot
01:31:16 <swiert> solrize: There they give primitive side effecting (like say, writeIORef) a very rich type - that allows you to do Hoare logic reasoning.
01:32:07 <solrize> neat
01:32:15 <swiert> There's a relation between they're work and what we've worked on.
01:32:32 <swiert> But that's probably a bit complicated to explain over IRC.
01:32:35 * quicksilver confiscates some of swiert's apostrophes.
01:32:41 <solrize> conor had a blog post a while back about something sort of like monadically typed machine code
01:33:01 <swiert> You'll just have to wait for the Related work section of my thesis.
01:33:11 <dibblego> my 5 year old son just said out loud "porn site" reading from my IRC client
01:33:19 <opqdonut> :D
01:33:20 <dibblego> whichever of you said that!
01:33:21 <solrize> whoops, sorry :P
01:33:28 <opqdonut> i hope those weren't his first words
01:33:32 <solrize> lol
01:33:35 * quicksilver gets a sleeping bag and starts queuing outside swiert's thesis factory.
01:33:35 <dibblego> he knows porn from chess
01:33:47 <quicksilver> gah, he can't even spell then! :)
01:33:48 <dibblego> he doesn't know it's spelled pawn
01:33:54 <opqdonut> :D
01:33:56 <pejo> quicksilver, lets see if it is as popular as the last Harry Potter!
01:34:02 <swiert> quicksilver: oops. I shouldn't try to listen to the MeyerMeijerGurevich talk while not making an idiot of myself on IRC.
01:34:21 <quicksilver> dibblego: I imagine this was the pawn site we were talking about : http://en.wikipedia.org/wiki/Red_Hot_Pawn
01:34:53 <pejo> swiert, but your thesis is ground work for Epigram 2?
01:35:00 <quicksilver> swiert: I was only teasing ;) typing fast in IRC is more useful than being 100% accurate.
01:35:19 <swiert> pejo: could be. The approach works for Coq or Agda equally well.
01:35:30 <swiert> pejo: It's not specific to Epigram.
01:36:20 <pejo> Did that sentence make sense to the natives? I'm not certain of the meaning of 'ground work' all the sudden.
01:36:33 <swiert> pejo: I've done most of the implementation in Agda, as it's more usable than Epigram atm.
01:36:35 <opqdonut> well i'm not native but it did make sense :)
01:36:56 <quicksilver> pejo: yes.
01:37:12 <dibblego> if I could get motion to play sound from my webcam mic. I'd let you all listen to him read your derogatory remarks
01:37:58 <opqdonut> i'm kinda worried about my master's thesis, there's not really that much interesting research going on around here (helsinki univ.)
01:38:24 <solrize> swiert what do i use if i want to write type-safe machine code?
01:38:48 <solrize> ynot looks cool
01:38:57 <opqdonut> but it's nice to hear somebody's doing something cool :)
01:39:01 <pejo> opqdonut, isn't that one of the better universities there?
01:39:07 <opqdonut> well yeah
01:39:12 <swiert> solrize: As in really low-level stuff?
01:39:17 <solrize> yeah
01:39:29 <opqdonut> but we're really software engineering oriented
01:39:30 <swiert> swiert: very roughly speaking, Coq is great if you want to prove properties of your code;
01:39:35 <opqdonut> with some data analysis and algorithmics
01:39:43 <swiert> Agda is nicer if you want to write dependently-typed programs.
01:40:31 <opqdonut> i'd be kinda interested in doing something programming language theory related (surprise surprise)
01:41:18 <solrize> yeah i've been interested in coq for a while, i just saw bpierce's course notes about it, they look nice
01:41:20 <pejo> opqdonut, can't do your thesis abroad?
01:41:24 <solrize> there is a book about it that i've been thinking of getting
01:41:25 <solrize> coq'art
01:41:33 <opqdonut> pejo: that's what i'll probably do
01:41:45 <swiert> solrize: coq'art is actually very nice.
01:41:51 <solrize> cool
01:41:56 <swiert> Coq is far from perfect, but I got a lot out of reading it.
01:42:06 <opqdonut> isn't really that urgent right now, i'll probably be starting in a few years
01:46:47 <solrize> swiert i'm basically wondering what approaches can bring some safety assurance to highly optimized asm code programming, i.e. for when you want to write a small library function for the absolute max possible speed (which is usually several times faster than a C compiler can do)
01:48:58 <pejo> solrize, have you seen FFTW (written in OCaml)
01:49:17 <solrize> i haven't looked at fftw closely
01:49:27 <solrize> but i'm aware of it
01:49:47 <vixey> what's Epigram for ? sort of between Coq and Agda?
01:50:08 <quicksilver> epigram's clever bit is the interactive program construction part.
01:50:11 <quicksilver> AIUI.
01:50:53 <solrize> djb has a handwritten lib which he says is much faster than fftw
01:51:12 <solrize> http://cr.yp.to/djbfft.html
01:51:56 <swiert> solrize: I'd recommend Coq for that sort of thing. I think Adam Chlipala's done some work compiling lambda calculus to x86 assembly in Coq, but I'm not sure if he considered optimisations.
01:52:25 <swiert> vixey: There are some rather subtle differences between Epigram and Agda, but they're closely related.
01:52:40 <quicksilver> swiert: Does agda do the interactive construction thing?
01:52:53 <solrize> i guess writing out the machine model is a huge amount of work all by itself, and downloadable code isn't really out there for complicated machines like x86
01:53:44 <swiert> vixey: So dependently typed pattern matching is really very subtle. Agda takes it as a primitive; Epigram translates all the high-level code to a very low-level language (basically Martin-Lof type theory) where pattern-matching is written out using eliminators/folds.
01:54:05 <swiert> quicksilver: not quite yet. It will be implemented fairly shortly, apparently.
01:54:06 <vixey> ohh ok
01:54:31 <quicksilver> swiert: ah, interesting.
01:54:45 <quicksilver> swiert: I was always more intrigued by the UI aspects of epigram than the type theory :)
01:54:54 <swiert> quicksilver: Agda does support holes in your program (Conor calls them sheds).
01:55:25 <swiert> quicksilver: yeah. It's pretty wacky.
01:56:06 <vixey> I thought it uses OTT but.. no idea what it is
01:56:07 <solrize> so what is programming actually like in those languages?  is there no type inference at all, so you have to annotate everything?
01:56:51 <swiert> vixey: So Epigram 2 will use observational type theory - which is very cool.
01:57:19 <swiert> solrize: Type inference is overrated. Any interesting type system cannot have inference.
01:57:35 <vixey> can you prove f = g -> \x -> f x = g x in Epigram 2 though?
01:57:47 <vixey> I mean .... the reverse of that sorry
01:57:49 <swiert> solrize: So you need to write down a lot of types, but you get rewarded for doing so.
01:57:56 <swiert> vixey: sure.
01:58:19 <swiert> vixey: the idea behind OTT isn't all that complicated.
01:58:27 <quicksilver> swiert: I think your work has given you a very particular view of 'interesting' wrt type systems :)
01:59:14 <swiert> quicksilver: well, as soon as you start using interesting parts of ghc's type system (higher ranked types, etc.) you need to add type signatures as well.
01:59:19 <pejo> swiert, think you can get partial inference in an interesting type system?
01:59:41 <vixey> pejo: Coq certainly figures out some things
01:59:52 <vixey> pejo: the real fun is inferring -programs- rather than the types
02:00:10 <opqdonut> like djinn?-)
02:00:17 <swiert> pejo: Yes. There are quite a few places where you can omit parts of the type signature in Agda/Coq/Epigram, for example.
02:00:26 <vixey> djinn*a billion :P
02:00:33 <opqdonut> yeah :P
02:00:36 <swiert> pejo: so you only need to write the interesting parts of the type signature, for example.
02:00:48 <vixey> you can code new proof search methods in Coq itself using reflection, lots of amazing stuff
02:00:56 <vixey> still it's hard work
02:01:08 <solrize> zenon looks interesting
02:01:28 <vixey> what's that?
02:01:32 <pejo> vixey, I don't doubt that you, or swiert, or lots of people with a phd in this channel can write very complex and correct programs using very powerful tools. Someone (McKinna? Altenkirch?) mentioned that the dependently typed programming needs to be more user friendly though. :-)
02:01:33 <solrize> why should you need to code proof search methods in coq, i.e. isn't it an awful lot of work?
02:01:53 <solrize> it seems enough to have uncertified searches that result in checkable proofs
02:02:02 <earthy> those tend to be slow
02:02:15 <solrize> vixey, zenon is an automatic prover that plugs into coq, lemme find the page again
02:02:52 <solrize> http://focal.inria.fr/zenon/
02:02:53 <lambdabot> Title: The Zenon automatic theorem prover
02:03:02 <solrize> i got to that page by surfing from the ynot page
02:04:18 <vixey> I'm trying to figure out how this OTT works :)
02:06:19 <swiert> vixey: So there's a big debate about equality in type theory.
02:06:23 <swiert> @quote equality
02:06:23 <lambdabot> pkhuong says: you'll probably still want unsafeEquality or whatever, though
02:06:39 <swiert> damn. James McKinna has a nice quote about "equality divides us".
02:07:01 <vixey> swiert: yes, something like canonical forms, extentional equality, decideablity .. or some 3 things, which you can't have all of?
02:07:26 <swiert> The one idea underlying OTT is to define equality by structure over the types.
02:08:12 <swiert> So - equality between pairs (a,b) and (c,d) means a = c and b = d.
02:08:33 <swiert> Two functions are equal if they're equal pointwise, etc.
02:08:44 <pejo> swiert, is it an old idea that "recently" has been investigated, or something someone came up with recently?
02:08:45 <swiert> The devil is in the details, though.
02:08:58 <dibblego> ?type first
02:09:00 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
02:09:03 <vixey> having tuples equal.. that seems ok, it's just the eliminator
02:09:09 <dibblego> ?source first (->)
02:09:09 <lambdabot> first (->) not available
02:09:16 <dibblego> ?source (->) firt
02:09:17 <lambdabot> (->) firt not available
02:09:19 <dibblego> ?source (->) first
02:09:20 <lambdabot> (->) first not available
02:09:20 <swiert> pejo: The whole equality debate is as old as type theory.
02:09:22 <vixey> but is it really the same thing which gets you pointwise equality of functions?
02:09:57 <pejo> swiert, yeah, probably even older. I meant the one idea behind OTT?
02:10:52 <swiert> pejo: the related work section in the OTT paper probably says it all:
02:10:53 <swiert> http://www.cs.nott.ac.uk/~wss/Publications/ObsEqNow.pdf
02:11:27 <swiert> pejo: there's been a lot of work trying to find the "right" definition of equality.
02:11:36 <swiert> pejo: and OTT is the latest proposal.
02:12:14 <halloman> http://www.dasdeutschlandspiel.de/index.php?page=beg.php&id=4410
02:12:18 <pejo> Heh, sure - point me to a paper in type theory!
02:13:09 <vixey> I like desugaring pattern matching to eliminators though
02:13:35 <swiert> vixey: yes. So do I.
02:13:41 <vixey> it's straightforward for something like haskell .. (if the patterns are total), but yeah I bet it's much more complex with dependant types
02:13:59 <swiert> vixey: well, even for Haskell with GADTs it's already pretty tricky, I imagine.
02:14:07 <Heffalump> what's an eliminator?
02:14:15 <vixey> foldr, maybe, etc..
02:14:24 <vixey> the catamorphism for a type/
02:14:28 <swiert> Heffalump: a dependently-typed fold
02:15:13 <Heffalump> Is it only dependently-typed if the relevant type is?
02:15:27 <swiert> Heffalump: the fold over peano numbers has type : forall a . a -> (a -> a) -> Nat -> a
02:15:46 <swiert> Heffalump: the eliminator has type:
02:16:23 <vixey> Heffalump: I think the fold should be dependant for every type
02:16:42 <swiert> forall (P : Nat -> *) . (P Zero) -> (forall n . P n -> P (Succ n)) -> (n : Nat) -> P n
02:17:06 <swiert> So the branches of the fold can have different types.
02:17:57 <Heffalump> I see
02:19:28 <vixey> I guess that desugaring into eliminators is a good way to get a proof that any recursion is structural
02:20:37 <swiert> vixey: and also that you haven't omitted any cases.
02:24:51 <mm_freak_work> quicksilver: is the example solution from yesterday called a "language"?
02:27:23 <solrize> eliminator = inference rule?
02:27:32 <mattam> swiert: the GMM paper is so difficult to read... I can only imagine how the code would look like :)
02:27:39 <vixey> eliminator/fold/catamorphism
02:27:49 <swiert> mattam: GMM?
02:28:39 <mattam> Goguen/McBride/McKinna
02:29:25 <swiert> mattam: Yes - implementing the elaboration is pretty hard.
02:29:32 <solrize> halloman is spamming, someone please kick
02:29:43 <swiert> mattam: but you only need to get that right once.
02:29:45 <solrize> oh , gone
02:29:50 <vixey> solrize: maybe ask #freenode to kline they are being annoying in #scheme too
02:30:25 <solrize> done
02:30:33 <vixey> what's the shorted proof x \= S(x) ?
02:30:38 <vixey> shortest
02:30:46 <swiert> mattam: Plus - primitive pattern matching has its limitations when you want to program with eliminators. I talked with Nicolas about this recently.
02:31:03 <mattam> swiert: I know. But I would be the one implementing that in say Coq, so it seems _really_ hard :)
02:31:33 <vixey> what are the limitations?
02:31:56 <mattam> I don't think it matters for the translation, you can have eliminators in Coq too anyway.
02:32:30 <swiert> mattam: sure. I'm glad I'm not the one that needs to implement it :)
02:34:44 <mattam> I'd really like to get this done actually, then Coq would be on equal footing with Agda and Epigram for programming. But it'll have to wait.
02:34:55 <swiert> vixey: very roughly speaking, if you want to have a library that exports a type, but not its constructors, together with several different eliminators over that type - you run into problems because the eliminators are defined in terms of pattern matching over the constructors, which you were trying to keep abstract in the first place.
02:35:18 <swiert> mattam: that'd be very, very cool.
02:36:47 <swiert> mattam: I noticed you hadn't documented some of your top secret subtac_simpl tactics in the Program part of the 8.2 manual.
02:37:13 <swiert> mattam: will you still be doing  that? I have a vague idea of what's going on...
02:37:40 <mattam> swiert: are you suggesting you'd need to be able to export the eliminators plus their reduction rules without reference to constructors ?
02:38:28 <mattam> swiert: almost everything in theories/Program is documented now.
02:41:39 <swiert> mattam: yes.
02:43:11 <swiert> mattam: I couldn't find anything about subtac_simpl and destruct_ccall? Or are they not in 8.2?
02:44:00 <mattam> They are, but in the contrib/subtac/Utils.v file which is not easily accessible (and you probably got only the object file, not the source file installed).
02:44:50 <swiert> mattam: Ok. I'll have a closer look, but I couldn't find them in the tactics index of the reference manual.
02:45:00 <swiert> mattam: Sorry - I have to leave now. Ttyl.
02:50:51 <vixey> I'm wondering..
02:51:09 <vixey> It's much much easier to write a type checker for STLC in Prolog than Haskell (for me at least..),
02:52:03 <vixey> so I tried to embed logic vars in haskell but it seems like I can't use ST as a replacement for StateT in my stack
02:53:06 <vixey> maybe that (no logic variables) is why it's so hard to write a typechecker for dependant types
02:53:31 <vixey> (I know everybody -says- it's easy though)
02:54:58 <mattam> It really is. The essential difference is that you have to write a conversion test. But substitution should already be in place if you did STLC.
02:57:07 <vixey> the conversion test is tricky I think
02:57:50 <vixey> it seems dodgy, how can you beta reduce if you haven't typechecked yet?
02:58:14 <solrize> instead of prolog's built-in unification can you use some library?
02:58:24 <mattam> The things you convert have already typechecked
02:59:11 <vixey> solrize: I tried to copy the approach of Type Logical Variables in Haskell but it feels like ST is evil (wouldn't cooperate in my transformer stack)
02:59:25 <vixey> mattam: ok, I'm going to try again then, thanks
02:59:39 <vixey> attempt 6 or something ..
02:59:46 <mattam> Γ |- t : U    Γ |- T : s  T = U |===== Γ |- T : s. [U] and [T] are well-formed types here.
03:00:00 <vixey> oh I see, yeah of course
03:00:01 <mattam> well-typed even.
03:00:16 <vixey> and the test =
03:00:37 <vixey> do I just beta reduce them both into normal form? I saw augustuss code which used WHNF :S
03:01:01 <mattam> Your choice. Strong normalization gives you freedom over the strategy.
03:01:28 <vixey> ok seems quite clear now, maybe I'll have more luck :)
03:18:19 <vixey> > (+3) . Just 1
03:18:22 <lambdabot>  Just 4
03:21:04 <vixey> :t fromJust . lookup ?x ?y
03:21:06 <lambdabot> forall a a1. (Eq a1, ?y::[(a1, Maybe a)], ?x::a1) => Maybe a
03:21:31 <doun> functional references: how can I get them in my code and is there a standard library yet?
03:28:01 <cjs> I have a market state which consists of a few hundred stocks with various bits of information without them, and bits of this state need to be updated with every message I receive. What's a good data structure for the set of stocks, which I search for via a single identifier. Data.Map?
03:31:25 <yitz> cjs: sounds good
03:31:28 <sjanssen> cjs: Data.Map is a good choice
03:32:24 <cjs> Definitely a list wasn't. My program grew to 780 MB!
03:32:46 <solrize> hey does it make any sense to write a persistent database, by serializing something like data.map to disk?
03:35:38 <mxc> @src foldl
03:35:38 <lambdabot> foldl f z []     = z
03:35:38 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
03:35:41 <mxc> @src foldr
03:35:41 <lambdabot> foldr f z []     = z
03:35:41 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
03:36:26 <mxc> foldl is tail recursive, foldr is good with laziness and infinite lists etc
03:36:28 <mxc> it seems
03:36:50 <mxc> :t foldl
03:36:51 <mxc> :t foldr
03:36:53 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
03:36:54 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
03:37:01 <mxc> :t foldr
03:37:03 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
03:37:34 <mxc> was it intentional that the type of the fxn passed to foldl is flipped from foldr?
03:37:50 <vixey> mxc: it's not flipped
03:38:50 <mxc> yes it is, in foldr the first arg of the function is the head of the list and the second is the accumulator,
03:38:57 <vixey> a -> b -> a
03:38:58 <vixey> a -> b -> b
03:39:01 <mxc> in foldl its the other way
03:39:27 <vixey> :t flip (?x :: a -> b -> c)
03:39:30 <lambdabot>     Could not deduce (?x::a -> b -> c) from the context ()
03:39:30 <lambdabot>       arising from a use of implicit parameter `?x'
03:39:30 <lambdabot>                    at <interactive>:1:6-7
03:39:34 <vixey> :t flip (undefined :: a -> b -> c)
03:39:36 <lambdabot> forall a b c. b -> a -> c
03:39:51 <vixey> notice the last thing (the return type) does not change
03:41:11 <mxc> in foldl the function you pass in has the first arg as the accumulator, in foldr the function has the secord arg as the accumulator
03:41:16 <vixey> :t foldr :: (a -> b -> b) -> b -> [a] -> b
03:41:17 <vixey> :t foldl :: (b -> a -> b) -> b -> [a] -> b
03:41:19 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
03:41:20 <lambdabot> forall b a. (b -> a -> b) -> b -> [a] -> b
03:41:29 <vixey> ok yeah you're right actually, it is flipped
03:41:55 <mauke> > foldl (flip (+)) z [a,b,c]
03:41:58 <lambdabot>  c + (b + (a + z))
03:42:05 <mxc> :)
03:42:19 <mauke> > foldr (flip (+)) z [a,b,c]
03:42:20 <lambdabot>  z + c + b + a
03:42:24 <mxc> I think ocaml keeps them consistent
03:42:55 <mauke> # fold_right;;
03:42:55 <mauke> - : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b = <fun>
03:42:55 <mauke> # fold_left;;
03:42:55 <mauke> - : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a = <fun>
03:43:00 <mauke> (no)
03:43:27 <mxc> really?
03:43:39 <mxc> memory is shaky, but i'll accept the double semi colon as proof
03:45:00 <mxc> is there a standard function that goes like:
03:45:10 <mxc> a `app` f = f a?
03:45:21 <mxc> so that instead of something like:
03:45:41 <mxc> blah $ foo long_list_of_args $ bar bana $ boo
03:45:46 <mxc> you could write:
03:45:57 <Botje> >>> does that, i think
03:45:57 <mxc> boo `app`
03:46:04 <mxc> bar bana `app`
03:46:05 <Botje> > (+3) >>> (*2) $ 1
03:46:06 <mxc> ...
03:46:06 <mauke> >>> is .
03:46:07 <lambdabot>  8
03:46:14 <mxc> ty
03:46:15 <Botje> yup :)
03:46:17 <mxc> :t >>>
03:46:19 <lambdabot> parse error on input `>>>'
03:46:20 <Botje> it's in Control.Arrow
03:46:21 <mxc> :t (>>>)
03:46:23 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
03:46:54 <solrize> i think the idea is 9 `app` sqrt = sqrt 9
03:46:59 <mxc> yeah
03:47:17 <mxc> basically to make my crappily written newbie haskell a little less illegiblew
03:47:19 <solrize> let a `app` b = b a in 3 `app` sqrt
03:47:23 <solrize> > t a `app` b = b a in 3 `app` sqrt
03:47:23 <lambdabot>  Parse error at "=" (column 13)
03:47:27 <mxc> well, its easy to write, was wodnering if there is a standard
03:47:43 <quicksilver> no, there isn't.
03:47:43 <Botje> solrize: yeah, but can you chain multiple together that way?
03:47:47 <solrize> (flip $)
03:47:51 <solrize> :t (flip $)
03:47:53 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
03:48:01 <Botje> hmm, probably :p
03:48:06 <Botje> << train
03:48:54 <solrize> @hoogle a -> (a->b) -> b
03:48:59 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
03:48:59 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
03:48:59 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
03:51:42 <mxc> ($>) :: a -> (a -> b) -> b
03:51:42 <mxc> ($>) a f = f a
03:52:11 <mauke> just redefine (.), then you can use pseudo OO notation!
03:52:24 <mauke> x.abs.sqrt
03:53:03 <maltem> > let infixl 9 .; a . f = f a in (-3).abs.sqrt
03:53:04 <lambdabot>  1.7320508075688772
03:53:07 <mxc> is that like sticking #define true false somewhere in the middle of a long header file as a parting gift when leaving a company you hate?
03:53:24 <quicksilver> mxc: well there is already a definition of <$ and $> in Control.Applicative.
03:53:33 <mxc> ah
03:53:38 <quicksilver> but, on the other hand, the good operators names have mostly all been used
03:53:45 <mxc> yeah, i liked that one
03:53:45 <quicksilver> so you may well end up reusing something.
03:53:47 <mxc> @hoogle app
03:53:47 <lambdabot> Control.Arrow.app :: ArrowApply a => a (a b c, b) c
03:53:47 <lambdabot> Prelude.appendFile :: FilePath -> String -> IO ()
03:53:47 <lambdabot> System.IO.appendFile :: FilePath -> String -> IO ()
03:53:57 <mxc> @hoogle zap
03:53:57 <lambdabot> No matches found
03:54:01 <quicksilver> I'm not sure why you'd want to do what you're doing, really.
03:54:07 <maltem> mxc, that would be about right only if Haskell had no module system
03:54:11 <mxc> @hoogle (8=>)
03:54:11 <lambdabot> Hoogle Error: Parse Error: Unexpected character '8=>)'
03:54:31 <mxc> heh, sry about that
03:54:53 <mxc> @hoogle (#>)
03:54:54 <lambdabot> Prelude.(>>) :: Monad m => m a -> m b -> m b
03:54:54 <lambdabot> Control.Monad.(>>) :: Monad m => m a -> m b -> m b
03:54:54 <lambdabot> Control.Monad.Instances.(>>) :: Monad m => m a -> m b -> m b
03:55:00 <mxc> @hoogle (*>)
03:55:01 <lambdabot> Control.Applicative.(*>) :: Applicative f => f a -> f b -> f b
03:55:01 <lambdabot> Control.Applicative.(<*>) :: Applicative f => f (a -> b) -> f a -> f b
03:55:01 <lambdabot> Control.Applicative.(<**>) :: Applicative f => f a -> f (a -> b) -> f b
03:55:59 <mxc> @hoogle (||)
03:56:00 <lambdabot> Prelude.(||) :: Bool -> Bool -> Bool
03:56:00 <lambdabot> Data.Bool.(||) :: Bool -> Bool -> Bool
03:56:00 <lambdabot> Control.Arrow.(|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d
03:56:04 <mxc> @hoogle (||>)
03:56:05 <lambdabot> Text.ParserCombinators.Parsec.Perm.(<||>) :: PermParser tok st (a -> b) -> GenParser tok st a -> PermParser tok st b
03:56:18 <mxc> @hoogle (<@>)
03:56:19 <lambdabot> No matches found
03:56:24 <mxc> @hoogle (@>)
03:56:24 <lambdabot> No matches found
03:56:43 <mauke> > (@>)
03:56:43 <lambdabot>   Not in scope: `@>'
03:56:58 <mxc> @hoogle ($$$)
03:56:59 <lambdabot> No matches found
04:03:11 <quicksilver> mxc: you do know hoogle has a web page don't you? :)
04:03:42 <mxc> sry
04:03:52 <doun> no one deemed functional references that cool?
04:04:32 <Cale> doun: they seem cool enough
04:05:10 <solrize> by the way, there are a lot of ubuntu users here, do you all know that your ssh keys are possibly compromised?
04:05:22 <doun> Cale: seems they are hard to implement in a satisfactory way. I see lots of “umm, bit is it generic enough? perhaps we need categories...”
04:05:24 <osfameron> I'm going to an F# talk -- any recommendations for a) cool things to take away from it, b) annoying questions to troll^W^W^W inciteful comparisons to make wrt haskell for the Q&A part  ?
04:05:52 <Cale> doun: Hm? I've seen an implementation in a few lines.
04:06:15 <Philippa> osfameron: "inciteful comparisons" is just a smarter way of writing trolling, no? Unless you meant "insightful" :-)
04:06:19 <Cale> Perhaps we're not talking about the same thing?
04:06:35 <doun> Cake: but was it deemed satisfactory?
04:06:37 <doun> er
04:06:39 <doun> Cale...
04:06:50 <Cale> satisfactory for what?
04:07:03 <osfameron> Philippa: good point, I thought I'd caught that thinko before it travelled to my fingers :-(
04:07:12 <doun> a satisfactory implementation
04:07:21 * maltem goes fetch himself a cake
04:07:23 <doun> it seems like something that should be in a standard library, don't you think?
04:08:33 <doun> Cale: I am talking about these: http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
04:08:34 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
04:08:44 <Cale> yeah, that's what I was thinking of too
04:09:32 <doun> a generic way to get, set and update parts of structures in a composable way
04:10:21 <doun> Data.Map could potentially be implemented with it, or arrays, or whatever structure
04:10:30 <Cale> I wonder if there's something already like that on hackage.
04:10:36 <doun> er... an instance of this method could be implemented /for/ Data.Map, that is
04:11:12 <doun> I don't see anything in Hackage about it
04:12:11 <vixey> oh my :D
04:12:16 <vixey> Here's a fun one
04:12:28 <vixey> if anyone is bored
04:12:44 <vixey> http://rafb.net/p/BN6ksz44.txt
04:12:49 <vixey> spot the bug :P
04:13:00 <vixey> (I feel really silly after noticing this)
04:13:57 <doun> extra parenthesis
04:14:02 <vixey> no
04:14:02 <mauke> bum[b]
04:14:09 <vixey> yeah
04:14:43 <mauke> (human compiler)++
04:14:52 <Cale> doun: The DeepArrow package you might find interesting
04:15:16 <quicksilver> doun: I don't think there is.
04:15:28 <doun> I will look at it
04:15:59 <quicksilver> doun: try this: http://hpaste.org/7630
04:17:12 <quicksilver> it's mising the operator for composing two Lens-es
04:17:12 <Cale> Deus?
04:17:24 <quicksilver> just a module hierarchy I use for private stuff
04:19:09 <vixey> I think I have logical mistakes in that code too by the way
04:20:35 <doun> quicksilver: yeah, nice. presumably no one thinks there should be a standard. I'll see if there's anything I can do with this Deep Arrow. I think it's such a common abstraction in code that I don't want to use private utility libraries, if you know what I mean
04:20:51 <quicksilver> doun: it defintely should be standard.
04:21:03 <quicksilver> doun: but the design space hasn't been explored properly and they're not widely used enough yet.
04:21:13 <quicksilver> doun: so it's not quite clear the best code.
04:21:20 <doun> quicksilver: ahh. I see
04:21:26 <cjs> http://hpaste.org/7631 consumes more and more memory as the loop runs longer and longer. What do I need to do to fix this?
04:21:38 <quicksilver> doun: I'm working on that as I go along. I might upload something to hackage once I'm happy I have a good interface.
04:21:41 <cjs> Maybe I need a ! or a seq or something?
04:22:10 <doun> quicksilver: yeah. I will look out for it
04:22:29 <quicksilver> cjs: I don't see any memory leak in that.
04:22:41 <quicksilver> cjs: when you say 'more and more memory' how much do you mean?
04:22:50 <mxc> what would be the correct syntax for:
04:22:53 <cjs> The size of the Market should be constant after a short time; there are only a few hundred stocks in it, of fixed size, and I just update them a lot.
04:23:02 <mxc> instance Num (Maybe Num)
04:23:12 <cjs> As in, I get "stack space overflow" if I let it go long enough.
04:23:13 <vixey> > (+ 7) . Just 1
04:23:14 <doun> instance Num a => (Maybe a) where
04:23:15 <lambdabot>  Just 8
04:23:21 <vixey> > (+ 7) . Nothing
04:23:22 <lambdabot>  Nothing
04:23:23 <doun> or without the parentheses
04:23:52 <vixey> would you say, Pi Prop (Pi (Var 0) (Pi (Var 1) (Var 0))) and Pi Prop (Pi (Var 0) (Pi (Var 1) (Var 2))) are equal?
04:24:39 <cjs> quicksilver, I've just annotated it with the data structures and processNextMessage.
04:25:13 <cjs> Maybe something in processNextMessage is leaking?
04:25:35 <quicksilver> seems likely.
04:25:48 <quicksilver> stack space overflow?
04:25:49 <quicksilver> ack.
04:26:08 <quicksilver> that is odd.
04:26:15 <cjs> Oh, and I added the updateStock method, which is what's doing most of the changes to the market. In fact, everything that changes the market is up there.
04:27:50 <solrize> cjs, use insertWith' const   ?
04:28:09 <mxc> doun doesn't seem to work, I'm trying to make (Maybe a) an instance of Num where Num => a
04:28:29 <cjs> according to the Haddoc docs, "insert is equivalent to insertWith const."
04:28:36 <solrize> insertWith'
04:28:37 <quicksilver> solrize: but each time he called findWithDefault it should force the map anyway
04:28:38 <solrize> not insertWith
04:28:43 <solrize> hmm
04:28:49 <cjs> Oh, insertWith' !
04:29:00 <doun> mxc: oh. instance Num a => Num (Maybe a)
04:29:00 <quicksilver> the map isn't a thunk.
04:29:06 <mxc> yeah, jsut realized that myself
04:29:09 <mxc> thanks
04:29:12 <doun> np
04:29:18 <solrize> why does findwithdefault force anything?
04:29:20 <quicksilver> not for long, at least.
04:29:20 <vixey> bah
04:29:27 <quicksilver> solrize: because it has to search through the map.
04:29:28 <solrize> stock is a thunk
04:29:30 <solrize> no
04:29:32 <quicksilver> solrize: maps are spine-strict.
04:29:33 <solrize> it's lazy
04:29:33 <solrize> right?
04:29:35 <solrize> hm
04:29:36 <quicksilver> so the map gets forced.
04:29:37 <vixey> Another failed attempt http://rafb.net/p/xzToSd24.txt
04:29:50 <quicksilver> maybe it's the stock itself not the map that's the problem.
04:29:54 <cjs> A thunk meaning an unevaluated chunk of stuff to do?
04:30:02 <vixey> any ideas?
04:30:08 <vixey> why it doesn't work
04:30:18 <quicksilver> cjs: yes.
04:30:19 <solrize> hmm i'm not how to test that
04:30:21 <quicksilver> cjs: try this:
04:30:41 <cjs> Actually, possibly I should be making the ask and bid strict. Those are updated many, many times, and the old values are not useful.
04:30:43 <quicksilver> mktStocks = let newstock = update stock in newstock `seq` Map.insert sc newstock map
04:30:56 <cjs> Oops...bestAsk and bestBid.
04:31:14 <quicksilver> making bestAsk and bestBid strict wont' do what you hope it does.
04:31:24 <quicksilver> it will only make the 'Just' strict
04:31:27 <quicksilver> not the contents of the Just
04:31:36 <quicksilver> by the same token, my solution won't work either.
04:31:37 <cjs> Oh.
04:31:48 <quicksilver> OK, horrible horrible hack.
04:32:00 <quicksilver> mktStocks = let newstock = update stock in show newstock `seq` Map.insert sc newstock map
04:32:12 <quicksilver> 'show newstock `seq`' should force all the contents of it
04:32:22 <quicksilver> at the cost of doing stupid unecessary work formatting a string.
04:32:31 <quicksilver> but if you at least try that we can confirm if this is the problem or not.
04:33:09 <solrize> show newstock is a char list
04:33:16 <quicksilver> gah
04:33:21 <solrize> is that in whnf just from forcing the first char?
04:33:24 <quicksilver> length (show newstock) `seq`
04:33:29 * quicksilver slaps quicksilver 
04:33:32 <solrize> heh
04:33:44 <cjs> quicksilver, that blows up too.
04:34:03 <quicksilver> cjs: with length?
04:34:26 <cjs> Oh, wait, I was using the wrong thing; I was using your earlier one.
04:35:28 <quicksilver> the objective here is just to test if it really is runaway thinks in bestAsk bestBid which are you rproblem.
04:35:34 <cjs> Your second one blows up as well. "With length?"
04:35:35 <quicksilver> I'm a bit surprised if they can lead to stack overflows.
04:35:52 <quicksilver> length (show newstock) `seq`  Map.insert sc newstock map
04:36:41 <solrize> make it length (show (newstock, nc))  `seq` ...
04:36:58 <solrize> oops
04:37:04 <solrize> ignore that
04:37:10 <paolin1> what error is "module main:Control.Monad.CC is not loaded" ?
04:37:11 <solrize> sc is not the map
04:37:17 <Arnar> @hoogle [a] -> Int -> Maybe a
04:37:17 <cjs> Yeah, with length it blows up too. Interesting.
04:37:18 <lambdabot> No matches, try a more general search
04:37:26 <Arnar> ^^ nothing std. like that?
04:37:43 <quicksilver> cjs: ok, I don't think it's runaway thunks in bestBid bestAsk then.
04:37:46 <quicksilver> cjs: hmm. I wonder what it is.
04:37:56 <solrize> length (show (newstock, map)) `seq` ...
04:37:58 <paolin1> :t index
04:37:59 <Arnar> i.e. I want  (getit [1,2] 2) to return Nothing
04:37:59 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
04:38:11 <cjs> Will profiling it help? Maybe it's time for me to learn to use the profiler.
04:38:25 <paolin1> :t atIndex
04:38:27 <lambdabot> Not in scope: `atIndex'
04:38:29 <solrize> maybe this is a good time to read dons' post about looking at the ghc core output
04:38:33 <vixey> x!!0=do (e:_)<-x;return e
04:38:34 <Arnar> @index atIndex
04:38:34 <lambdabot> bzzt
04:38:52 <vixey> x!!(n+1)=do (_:xs)<-x; x!!n
04:38:54 <Syzygy-> x!!0 = head x
04:38:57 <Syzygy-> Isn't it?
04:38:59 <vixey> :t head
04:39:00 <lambdabot> forall a. [a] -> a
04:39:08 <vixey> you want Maybe a
04:39:16 <Arnar> Syzygy-: he's wrapping it in Maybe for me
04:39:18 <Syzygy-> :t (!!0)
04:39:20 <lambdabot> forall a. [a] -> a
04:39:20 <Arnar> vixey: thx
04:39:22 <vixey> Arnar: she
04:39:26 <Syzygy-> Arnar: Ah.
04:39:28 <Arnar> vixey: oh.. sorry :/
04:39:28 <vixey> Arnar: np :)
04:39:34 <vixey> :t let x!!0=do{(e:_)<-x;return e} x!!(n+1)=do{(_:xs)<-x; x!!n} in (!!)
04:39:36 <lambdabot> parse error on input `x'
04:39:39 <doun> blame the english language
04:39:39 <vixey> brr
04:39:45 <cjs> Stack space overflow: current size 8388608 bytes.
04:39:48 <cjs> You know, that's kinda small.
04:40:11 <vixey> :t let x!!0=do{(e:_)<-x;return e};x!!(n+1)=do{(_:xs)<-x; x!!n} in (!!)::Int -> [a] -> Maybe a
04:40:13 <lambdabot>     Couldn't match expected type `Int' against inferred type `t [t1]'
04:40:14 <lambdabot>       Expected type: Int -> [a] -> Maybe a
04:40:14 <lambdabot>       Inferred type: t [t1] -> t2 -> t t1
04:40:39 <Syzygy-> > x!!0=do{(e:_)<-x;return e} x!!(n+1)=do{(_:xs)<-x;x!!n} in (Just 2)!!1
04:40:39 <lambdabot>  Parse error at "=do{(..." (column 5)
04:40:49 <Syzygy-> > x!!0=do{(e:_)<-x;return e}; x!!(n+1)=do{(_:xs)<-x;x!!n} in (Just 2)!!1
04:40:49 <lambdabot>  Parse error at "=do{(..." (column 5)
04:40:51 <quicksilver> cjs: in a way it is, but your code shouldn't need much stack.
04:40:55 <praseodym> is there any function to check if the square root of a number is an integer?
04:41:02 <cjs> If I bump the stack size up to 256M it works ok, though I'm only doing the first hour of the recorded day.
04:41:03 <Arnar> heh.. don't worry about it, I get the picture :)
04:41:03 <praseodym> i.e. if something is an integer or a fraction
04:41:08 <cjs> Yes, indeed. Something is wrong.
04:41:10 <Arnar> praseodym: doing the Euler project eh? :)
04:41:19 <cjs> Oh, wait, am I doing the tail recursion properly?
04:41:32 <praseodym> Arnar: nah :) just trying some stuff
04:41:56 <cjs> Looks like it to me.
04:42:05 <quicksilver> cjs: How many of each of the three kinds of message (Dict, Limits, limitsrefresh) are they?
04:42:46 <paolin1> anyone can load Control.Monad.CC on ghci ?
04:43:19 <solrize> Prelude> :m Control.Monad.CC
04:43:19 <solrize> Could not find module `Control.Monad.CC':
04:43:47 <paolin1> it's in CC-delcont package
04:44:11 <vixey> x!!0=do{(e:_)<-return x;return e};x!!(n+1)=do{(_:es)<-return x;x!!n}
04:46:19 <mxc> cjs - looks like you're also using haskell in finance, when you're done with this specific issue, wld like to chat about that
04:46:41 <paolin1> it compiled nicely but ghci refuses to load it
04:47:26 <solrize> praseodym use properFraction
04:47:32 <solrize> :t properFraction
04:47:35 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> (b, a)
04:47:49 <solrize> check that the fractional part is zero
04:47:50 <quicksilver> properFraction is not very accurrate
04:47:52 <vixey> > denominator (sqrt 7)
04:47:53 <lambdabot>   add an instance declaration for (Floating (Ratio a))
04:47:58 <quicksilver> your fractional part may be 10^-16
04:48:00 <quicksilver> instead of 0
04:48:08 <Arnar> praseodym: you could yuse floor as well
04:48:28 <Arnar> isInt x = x == (floor x)
04:48:33 <solrize> that would mean sqrt is inaccurate in which case there's nothing to be done except round to the nearest integer, square the result and compare
04:48:48 <quicksilver> well sqrt is inaccurate.
04:48:53 <quicksilver> that's life in the floating point world :P
04:48:54 <solrize> yeah
04:48:58 <Arnar> I'm sure there are integer algorithms to test if a number is square
04:49:02 <cjs> quicksilver, there are 885166 messages total, about half of which are Limits, and the Dicts are only a few hundred entries at the beginning.
04:49:06 <vixey> > isSquare x = floor . sqrt . fromIntegral $ x == x in map isSquare [1..20]
04:49:06 <lambdabot>  Parse error at "=" (column 12)
04:49:10 <vixey> > let isSquare x = floor . sqrt . fromIntegral $ x == x in map isSquare [1..20]
04:49:10 <cjs> mxc, I'd love to.
04:49:11 <lambdabot>   add an instance declaration for (Integral Bool)
04:49:19 <vixey> > let isSquare x = (floor . sqrt . fromIntegral $ x) == x in map isSquare [1..20]
04:49:22 <solrize> dicts get big but they are in the heap, not the stack
04:49:25 <lambdabot>  [True,False,False,False,False,False,False,False,False,False,False,False,Fals...
04:49:32 <vixey> > let isSquare x = (floor . sqrt . fromIntegral $ x) == x in filter isSquare [1..]
04:49:39 <solrize> cjs, check for tail recursion?  where is your paste again?
04:49:43 <lambdabot>  [1Exception: Time limit exceeded
04:49:50 <quicksilver> http://hpaste.org/7631
04:49:56 <vixey> well that doesn't work..
04:50:04 <cjs> http://hpaste.org/7631#a3
04:50:11 <praseodym> solrize, Arnar: thanks
04:50:16 <cjs> Oops, but without the #a3.
04:50:18 <solrize> cjs if you haven't run the profiler yet yes you should do it
04:50:22 <quicksilver> technically processDay is not tail-recursive.
04:50:28 <quicksilver> but that doesn't actually matter (fortunately)
04:50:34 <quicksilver> otherwise infinite IO actions wouldn't work.
04:50:43 <vixey> > let square = join (*) ; isSquare x = (square . floor . sqrt . fromIntegral $ x) == x in filter isSquare [1..]
04:50:44 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
04:51:11 <cjs> Now this is bad. With a 256MB stack, it evaluates printMarket within a few seconds, but I get the header line (printing out the time and number of messages), and then it just sits there forever as it tries to go through the Stocks and print each one.
04:51:24 <vixey> > let square = join (*) ; isSquare x = elem x (map square [1..x]) in filter isSquare [1..]
04:51:34 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
04:52:25 <quicksilver> cjs: OK, so you are definitely building up a huge thunk somewhere
04:52:31 <quicksilver> cjs: which it is now trying to reduce.
04:52:39 <quicksilver> (that would give a stack overflow, when it reduces it)
04:52:47 <cjs> Yeah, looks like it.
04:53:09 <cjs> It's got to be the Stocks, doesn't it? That's what I generate a lot of.
04:53:09 <quicksilver> cjs: it's probalby just messageCount
04:53:23 <quicksilver> or did messageCount get successfully printed already?
04:53:40 <cjs> messageCount was successfully printed.
04:54:04 <quicksilver> not that then.
04:54:32 <solrize> how about adding strictness to processNextMessage
04:54:33 <Baughn> quicksilver: Stack overflows only happen when the thunks have to be evaluated strictly, right?
04:54:35 <solrize> return $! mkt' ...
04:54:59 <quicksilver> Baughn: well, stack overflows happen when the thunks reduce to a "single value" in a sense.
04:55:10 <quicksilver> Baughn: when you have to descend a lot of stack frames to get any result at all.
04:55:17 <Baughn> quicksilver: That's my intuition. I was hoping for something.. more formal
04:55:20 <quicksilver> (as apposed to each stack frame giving you one element of a list)
04:55:32 <Arnar> praseodym: it is interesting to think of an algorithm for this though..
04:55:49 <Arnar> praseodym: apparently, odd squares are congruent to 1 (modulo 8)
04:56:49 <quicksilver> Ah, I think it's simpler than I thought.
04:56:56 <quicksilver> cjs: make mktStocks a strict field.
04:57:20 <vixey> huh x^2 = 2k+1, x=2j+1, (2j+1)^2=4j^2+4j+1
04:57:21 <cjs> What's the syntax for that again?
04:57:25 <anne> mxc: Hey, I'm working on such a project too, though I have a long way to go... I'd love to know about your projects...
04:57:33 <vixey> 4j^2+4j+1 = 1 (mod 8) ?
04:57:38 <solrize> 1 mod 4
04:57:41 <vixey> Arnar: got a proof?
04:57:45 <quicksilver> cjs: ! Map StockCode Stock
04:58:09 <Arnar> vixey: no.. but the reference cited is Conway and Guy 1996)
04:58:16 <solrize> well hmm yeah
04:58:19 <quicksilver> vixey: 3^2 = 9 = 1; 5^2 = 25 = 1; 7^2 = 49 = 1
04:58:21 <quicksilver> vixey: QED.
04:58:24 <vixey> LOL
04:58:41 <solrize> (n+2)**2 - n**2 = 4n+4
04:58:41 <vixey> you know it's IF not IFF
04:58:43 <cjs> Unexpected strictness annotation: !Map In the data type declaration for `Market'
04:58:47 <vixey> so it's useless as a test
04:58:56 <quicksilver> it reduces the amount you need to test.
04:58:57 <cjs> 'mktStocks :: ! Map StockCode Stock' is not right?
04:59:04 <quicksilver> hrm
04:59:13 <quicksilver> maybe it needs parens
04:59:20 <quicksilver> ! ( Map StockCode Stock )
04:59:20 <quicksilver> ?
04:59:55 <Arnar> quicksilver: it reduces aleph_0 to aleph_0.. :)
05:00:04 <vixey> u_u
05:00:27 <mxc> anne - right now, its kind of experimental, like basic option pricing, binomial model etc
05:00:28 <quicksilver> Arnar: yes, but the question we're asking is "Is X a perfect square"
05:00:43 <quicksilver> Arnar: so we can check modulo 8. We may get an instant no.
05:00:45 <cjs> Yes, parens work. Thanks.
05:00:52 <Arnar> quicksilver: true..
05:00:54 <quicksilver> cjs: right. Does it fix the problem?
05:01:10 <quicksilver> Arnar: if it's even, of course, we can keep dividing by 4. makes the problem smaller.
05:01:17 <Arnar> quicksilver: ermm.. no, you'll only get "no, it is not an _odd_ square"
05:01:28 <Arnar> quicksilver: yeah. that was my idea too
05:01:31 <quicksilver> Arnar: yes. not to hard to check if it's even or odd, is it? :)
05:01:39 <Arnar> :)
05:01:51 <vixey> notProbablySquare x = if even x then 4`divides`x else 1==x`mod`8
05:01:51 <mxc> anne, cjs I think that even with super-secret nature of what we do, there are some shared areas that we could collaborate on.  a stat package, standardized types for various securities etc
05:01:54 <cjs> Hm. Seems not. It has now been running for 30 secs, and still no header line, and the process is growing...oh, wait, it settled down at 407 MB, and after 60 secs it gave me full output.
05:02:09 <vixey> isSquare x = if notProbablySquare x then False else difficultComputation x
05:02:16 <cjs> mxc, I wouldn't be surprised at all. And what I'm doing is actually not terribly secret, for the most part.
05:02:22 <quicksilver> cjs: cool. Sounds like we fixed it.
05:02:24 <vixey> oh
05:02:27 <mxc> cjs me niehter... yet..
05:02:29 <vixey> isSquare x = if not.notProbablySquare$x then False else difficultComputation x
05:02:31 <quicksilver> cjs: would you like to me explain what the problem was?
05:02:39 <Arnar> quicksilver: but dividing away the fours..
05:02:45 <Arnar> quicksilver: are you sure that will work?
05:02:46 <vixey> some combination of symbols .. anyway
05:02:48 <cjs> Yes, please.
05:02:57 <cjs> Old copies of the map hanging about?
05:03:00 <anne> mxc: Does it work on realtime data? I'm developing an analysis tool now (ok, very non-secretive, will be opensource) and it would be great if I could update the data without using an intermediate tool...
05:03:04 <quicksilver> not precisely.
05:03:11 <cjs> Or rather, a big unevaluated thunk of a map?
05:03:13 <quicksilver> Arnar: (even n is square iff n/4 is square)
05:03:22 <quicksilver> cjs: mktStocks was never been inspected, only added to.
05:03:30 <cjs> Right.
05:03:32 <vixey> oh neat
05:03:52 <quicksilver> cjs: so, it was turning into something of the form : Map.insert foo bar (Map.insert foo bar (Map.insert foo bar ( Map.insert foo bar
05:03:57 <Arnar> quicksilver: of course.. I need to wake up I guess :)
05:04:01 <mxc> anne, not yet.  I gotta run from the office soon, want to share email addresses and get a dialogue going?
05:04:02 <cjs> I see. Makes sense.
05:04:15 <quicksilver> cjs: a huge set of linked thunks is not a problem in itself. it takes memory but that's all.
05:04:20 <cjs> Wait, what about findWithDefault?
05:04:20 <quicksilver> then, when you finally do try to access it
05:04:26 <quicksilver> cjs: that was what confused me
05:04:32 <quicksilver> but, findWithDefault doesn't actually get called.
05:04:38 <cjs> Ah, I see.
05:04:43 <quicksilver> remember, updateStock is entirely lazy
05:04:46 <anne> mxc: Sure.
05:04:50 <quicksilver> that findWithDefault call is also deferred
05:04:57 <quicksilver> stored inside that big thunk.
05:05:13 <quicksilver> any all those thunks are only a problerm when you try to reduce them.
05:05:26 <mxc> anne, cjs - anyone else with an interest in haskell for finance, I gotta run, but pls email me cantor AT nyenburgh DOT com so we can keep in communication
05:05:27 <quicksilver> because Map is spine-strict, any attempt to access it at all reduces them all in one big thump
05:05:31 <quicksilver> which takes up O(n) stack space
05:05:35 <quicksilver> hence your problem.
05:05:48 <quicksilver> you don't access until the very end, then when you do, stack overflow.
05:06:14 <anne> mxc: gsan AT stillpsycho DOT net
05:06:32 <anne> See you...
05:06:43 <cjs> I'm cjs@starling-software.com, BTW.
05:07:11 <mxc> anne I really hope stillpsycho is the name of a hedge fund or something
05:07:13 <cjs> Ah.
05:07:20 <anne> lol
05:07:56 <mxc> if so, i'm in
05:08:08 <cjs> BTW, the process still grows to 700 MB with my original updateStock, and about 400 MB with your `seq` version.
05:08:16 <anne> mxc: Hehe, well, we can start one...
05:08:37 <mxc> done
05:09:13 <cjs> What on earth is eating all that memory?
05:09:54 <quicksilver> cjs: *shrug* haskell is big.
05:10:04 * quicksilver doesn't really worry as long as it's constant.
05:10:13 <quicksilver> it only matters if it keeps growing without bounds.
05:10:28 <quicksilver> you may have some little thunks inside the bestBid/bestAsk fields
05:10:32 <quicksilver> those could all add up
05:10:38 <quicksilver> they're not deep enough to be stack overflow issues
05:10:42 <cjs> I could see that.
05:10:44 <quicksilver> but they will take up memory until reduced.
05:11:00 <skorpan> instance QuadShow String where
05:11:00 <skorpan>   qshow = show
05:11:06 <skorpan> is there anything wrong with that?
05:11:20 <quicksilver> well, it needs FlexibleInstances
05:11:24 <skorpan> why?
05:11:25 <quicksilver> I don't think that's "Wrong" myself.
05:11:35 <quicksilver> haskell 98 forbids instances of the form [Char]
05:11:39 <cjs> I guess I really need to make updateStock entirely strict, don't I?
05:11:40 <skorpan> oh...
05:12:15 <cjs> Can I even do that?
05:12:21 <praseodym> I want to check if every element in a list is smaller than its predecessor -- something like adding (<) inbetween the elements, but foldl is not suited for that
05:12:45 <vixey> praseodym: watch this:
05:12:56 <vixey> > let x = [1,2,3,4,5] in zip x (tail x)
05:12:58 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
05:13:14 <solrize> yeah, what vixey says
05:13:16 <solrize> map and
05:13:22 <vixey> :t uncurry (<)
05:13:23 <solrize> i mean and map
05:13:24 <lambdabot> forall a. (Ord a) => (a, a) -> Bool
05:13:25 <cjs> There's got to be issues in my parsing code and whatnot, too, though. Even if I make updateStock do nothing but return its Market argument, I grow quite large.
05:13:28 <solrize> oh cool
05:13:35 <vixey> :t all
05:13:37 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
05:14:14 <solrize> > and (map (uncurry (>)) (zip x (tail x))) where x=[1..5]
05:14:14 <lambdabot>  Parse error at "where" (column 42)
05:14:32 <vixey> :t all (uncurry (<)) . (zip =<< tail)
05:14:33 <lambdabot> forall b. (Ord b) => [b] -> Bool
05:14:58 <cjs> Oh dear. Doing five hours, it keeps growing.
05:15:22 <vixey> (doesn't work :P)
05:15:28 <ToRA> > let f = all (uncurry (<)) . (zip `ap` tail) in f [5,4..1]
05:15:29 <lambdabot>  False
05:15:35 <ToRA> > let f = all (uncurry (<)) . (zip `ap` tail) in f [1..5]
05:15:37 <lambdabot>  True
05:15:53 <praseodym> nice one :)
05:16:12 <vixey> > (all (uncurry (<))) . (zip =<< tail) $ [3,2,1]
05:16:13 <lambdabot>  True
05:16:17 <vixey> > (all (uncurry (<))) . (zip =<< tail) $ [1,2,3]
05:16:18 <lambdabot>  False
05:16:50 <vixey> also palindrome = reverse >>= (==)
05:17:04 <vixey> this is probably abuse of >>=
05:17:42 <cjs> Oh, no, it does appear still to grow without bound. Ouch.
05:17:51 <yitz> > let f x = all $ zipWith (<) x (tail x) in f [1..7]
05:18:07 <lambdabot>  thread killed
05:18:36 <vixey> :t all . (zipWith (>) =<< tail)
05:18:38 <lambdabot>     Couldn't match expected type `a -> Bool'
05:18:38 <lambdabot>            against inferred type `[Bool]'
05:18:38 <lambdabot>     Probable cause: `zipWith' is applied to too many arguments
05:18:59 <vixey> :t ((.).(.)) all (zipWith (>) =<< tail)
05:19:01 <lambdabot>     Couldn't match expected type `a -> Bool'
05:19:01 <lambdabot>            against inferred type `Bool'
05:19:01 <lambdabot>       Expected type: [a1] -> [a1] -> [a -> Bool]
05:19:10 <ToRA> :t all . (zipWith (>) `ap` tail)
05:19:12 <lambdabot>     Couldn't match expected type `a -> Bool'
05:19:12 <lambdabot>            against inferred type `[Bool]'
05:19:12 <lambdabot>     Probable cause: `zipWith' is applied to too many arguments
05:19:19 <praseodym> wouldn't writing a recursive function actually be easier?
05:19:37 <yitz> @type \ x -> all $ zipWith (<) x (tail x)
05:19:39 <lambdabot>     Couldn't match expected type `a -> Bool'
05:19:39 <lambdabot>            against inferred type `[Bool]'
05:19:39 <lambdabot>     In the second argument of `($)', namely `zipWith (<) x (tail x)'
05:20:04 <yitz> > let f x = and $ zipWith (<) x (tail x) in f [1..7]
05:20:13 <lambdabot>  True
05:20:17 <yitz> whew
05:20:43 <ToRA> @type and . (zipWith (>) `ap` tail)
05:20:45 <lambdabot> forall a. (Ord a) => [a] -> Bool
05:21:15 * ToRA wonders how to make this smaller
05:21:48 <vixey> @src ap
05:21:49 <lambdabot> ap = liftM2 id
05:21:50 <cjs> quicksilver, why does "length (show newstock)" work, but not just "newstock"?
05:21:51 <yitz> cjs: sorry, I missed part of the discussion. are you using insertWith' (the strict version)?
05:21:58 <vixey> @src join
05:21:59 <lambdabot> join x =  x >>= id
05:22:11 <cjs> Not right now. I did try it, but it didn't seem to help.
05:22:26 <quicksilver> cjs: newstock `seq` only reduces newstock to whnf
05:22:37 <quicksilver> cjs: which is just the Stock constructor.
05:22:37 <cjs> whnf?
05:22:43 <quicksilver> cjs: weak head normal form
05:22:51 <quicksilver> cjs: basically, reduce to first constructor.
05:23:02 <quicksilver> it turns from <thunk> into Stock <thunk>
05:23:06 <cjs> Ah.
05:23:18 <quicksilver> yitz: don't think it will make much difference because his value type is a record.
05:23:33 <quicksilver> yitz: even insertWith' is just going to force it as far as the Stock constructor.
05:23:57 <vixey> @hoogle foldr1
05:23:59 <lambdabot> Prelude.foldr1 :: (a -> a -> a) -> [a] -> a
05:23:59 <lambdabot> Data.List.foldr1 :: (a -> a -> a) -> [a] -> a
05:23:59 <lambdabot> Data.Foldable.foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
05:24:07 <vixey> @hoogle foldl1
05:24:07 <lambdabot> Prelude.foldl1 :: (a -> a -> a) -> [a] -> a
05:24:07 <lambdabot> Data.List.foldl1 :: (a -> a -> a) -> [a] -> a
05:24:07 <lambdabot> Data.Foldable.foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
05:24:13 <yitz> so, that plus bangs on the record members?
05:24:16 <vixey> these are not useful
05:25:00 <mxc> how can one force strict evaluation?
05:25:03 <cjs> Holy crap! I put bangs on everything in Market and Stock, and now it runs in 10 MB of memory instead of 300.
05:25:19 <mxc> or hnf
05:25:28 <quicksilver> cjs: good.
05:25:29 <quicksilver> ;)
05:25:47 <cjs> Err...that's a bit of a cargo cult solution for me at the moment, but what the heck.
05:25:49 <quicksilver> cjs: I wonder what it was.
05:25:57 <quicksilver> cjs: if you have time and are bored, binary chop the bangs.
05:26:01 <quicksilver> and find out the critical one(S)
05:26:11 <quicksilver> if you are busy and have work to do, please continue ;)
05:26:13 <cjs> quicksilver, Yes, that quickly went on my list of things to do.
05:26:26 <cjs> I can't do it tonight, unfortunately.
05:26:30 <yitz> i.e., find out which one makes it go bang. (sorry)
05:27:01 <quicksilver> my understanding is that the bangs on the Maybes shouldn't be relevant
05:27:10 <quicksilver> because just forcing as far as the Just really doesn't help much.
05:27:31 <cjs> Well, I could see time or messageCount.
05:27:41 * quicksilver nods
05:27:47 <cjs> But stockCode and stockName are only ever set once.
05:33:53 <schme2_> Hey guys and gals. I was wondering something about this here haskell. Does it support hot swapping of code or anything of the sort?
05:35:00 <sclv> via hs-plugins, yes. but at the moment, plugins is in a not-well-supported limbo pending tighter integration with the GHC api.
05:35:35 <schme2_> :(
05:36:06 <sclv> 95% of the time you really can find another way though...
05:36:46 <schme2_> Another way?
05:38:04 <schme2_> I know two other ways ;)
05:38:09 <anne> sclv: Hi. I ended up deserializing TypeRep (if you remember the case). I sent the code to haskell-cafe.
05:38:21 <Baughn> schme2_: You might want a C-based plugin API anyway, so you don't force people to use haskell
05:38:27 <Baughn> schme2_: Or you could use the interpreter api
05:38:37 <vixey> or write an interpreter
05:38:56 <vixey> rather than using loading Haskell code, .. your own language
05:40:03 <schme2_> Hmmm.. I'm not quite following here.
05:40:23 <schme2_> What I want is to write some software that I can later modify without having to restart it. That's basically it.
05:40:43 <Baughn> Yes, GHC pretty much doesn't support that
05:40:43 <vixey> sounds like lisp
05:40:48 <Baughn> Or erlang
05:40:49 <vixey> SLIME
05:40:51 <schme2_> vixey: I do it in CL all the time, yes.
05:40:53 <mxc> isn't that kind of what GHCi does though?
05:40:55 <vixey> oh erlang cool
05:41:04 <sclv> anne: glad you got it to work!
05:41:05 <Baughn> mxc: Sure, the interpreter can do it
05:41:12 <Baughn> But that's a 10x slowdown (or so)
05:41:37 <schme2_> Well that was pretty much what I was wondering. I was thinking about it and it seemed that the type stuff made it kinda tricky and I was wondering if it was done. Guess not :(
05:41:37 <mxc>  oh, you want to be able to run compiled code?
05:41:53 <Baughn> schme2_: If you're okay with the interpreter for replacable code, fine. If not.. well, wait a year and it might work. ^^;
05:42:06 <Baughn> schme2_: Oh, and hs-plugins /does/ work, at least somewhat - lambdabot uses it
05:42:11 <Baughn> It's just not entirely convenient
05:42:22 <schme2_> Baughn: That is actually not okay at all with the interpreter :)  I'll have a look at the hs-plugins.
05:42:42 <vixey> schme: Why do you want this feature though?
05:42:48 <Baughn> schme2_: Make sure you read http://www.haskell.org/haskellwiki/GHC/As_a_library too
05:42:48 <lambdabot> Title: GHC/As a library - HaskellWiki
05:42:56 <pejo> schme2, it's a tricky problem in general. IBM has done something like it in K42 (research OS) for C++ iirc. The gist of it was that you get a jump table that you can patch so you can do 'live updates', basically.
05:43:12 <schme2_> vixey: For server side software to avoid downtime.
05:43:26 <schme2_> pejo: Well I do it all the time with CL really.
05:43:43 <Baughn> That's how erlang and lisp do it, too - erlang indirects every time you cross module boundaries, lisp.. well, sbcl... every time you call a function, I think
05:44:21 <Baughn> schme2_: I don't suppose you could just write it right the first time?
05:44:24 <schme2_> Seems a bit of a bitch with all the type safety stuff there.
05:44:26 <vixey> haha
05:44:29 <pejo> Heh, "Do you prefer a system that is a) fast, or  b) always running?".
05:44:38 <vixey> schme2: It's not related to type safety
05:44:42 <mxc> baughn - them's fightin' words
05:44:44 <schme2_> hmm ok.
05:44:45 <vixey> schme2: these issues are orthogonal
05:45:00 <sclv> on the other hand, if your software takes 2s to restart, as opposed to 2m, then it matters a great deal less...
05:45:06 <Baughn> schme2_: More seriously, if uptime is this important then you probably want a cluster, not a single machine. And then you can just upgrade one at a time
05:45:15 <mxc> wow, looks like one of the most helpful, newbie friendly communities has really turned a corner
05:45:48 <Baughn> mxc: It was a /joke/..
05:45:50 <schme2_> Baughn: Even if it is written right the first time it is a bitch to have not have the hot swapping or swank-like behaviour for random changes and upgrades. That's more the issue.
05:45:55 <schme2_> oh a joke.
05:45:57 <vixey> mxc what are you talking about
05:46:18 <pejo> sclv, you probably carry around some state, which might be tricky to handle for the restart case (open files/sockets, etc).
05:46:19 <schme2_> mxc: I don't get it. I find this channel extremely friendly :)
05:46:20 <ivanm> Baughn: looks like you have a similar problem to what I have... I often have to tell people that I'm being sarcastic :p
05:47:06 <sclv> i think hot-swapping matters more to things like java where i can eat lunch while websphere or whatever bootstraps...
05:47:07 <mxc> baughn - i knwo, and it was a really good one, I was just following along
05:47:14 <Baughn> schme2_: You've got a few options, but the simple fact is that haskell (okay, ghc) isn't quite mature enough for this yet. People keep trying, and GHC keeps changing the api, breaking it.. I /think/ 6.10 will be able to do this well. At least eight-ball says so.
05:47:31 <cjs> quicksilver: it was messageCount that was the issue.
05:47:40 <sclv> we have summer-of-code projects that relate...
05:47:55 <pejo> Baughn, that is a nice idea in theory, but waiting for the node to become available for an upgrade can take an awful long time.
05:48:33 <Baughn> pejo: You'd have to serialize the connection somehow and turn it over to another node, yes
05:48:34 <pejo> (Depending on the application domain, but this is typical 'enterprise':y stuff to my ears).
05:48:41 <schme2_> Baughn: Ya. Well Iwas mostly just wondering if it was part of the standard haskell stuff. I'll just use some other language for that project. :)
05:48:43 <cjs> Well, that and mktStocks.
05:48:48 <sclv> the problem is that for non-trivial updates, that state could well get tromped on anyway.
05:48:54 <cjs> But that to a lesser degree.
05:49:24 <sclv> schme2_: nooooo! not some other language! wait! come back! hs-plugins works perfectly, i tell you, perfectly!
05:49:36 <Baughn> Yep. Any upgrade that changes data structures has a great chance of breaking things; you'll want to do those offline anyway, so..
05:49:41 <schme2_> sclv: hahahah!
05:49:42 <Baughn> schme2_: At least CL has quite explicit support for this
05:49:46 <Baughn> Or CLOS, rather
05:50:21 <schme2_> Baughn: They only really break if you do stuff wrong :)
05:50:38 <solrize> unix usually has a way to pass open files around between processes
05:50:40 <cjs> Oh, and the "length (show newstock) `seq` Map.insert ..." thing, too.
05:50:41 <solrize> SCM_RIGHTS in linux
05:50:42 <Baughn> schme2_: But doing it wrong is so /easy/...
05:50:50 <Baughn> solrize: On different machines?
05:50:51 <schme2_> Baughn: Not if you're as good as me ;)
05:50:58 <schme2_> stuff just wants to be right when I touch it. yeah.
05:51:08 <quicksilver> cjs: cool. Odd, thouhg.
05:51:14 <solrize> no just on one machine, the question was about hot-patching which would imply a running image on one machine
05:51:20 <quicksilver> cjs: I thought we'd established it wasn't by the fact your final report was displaying it.
05:51:28 <solrize> otherwise you want to hot-patch the OS as well
05:51:36 <cjs> Yes, it seems odd.
05:51:50 <Baughn> Hum. Oh right, linux is hot-patchable now...
05:51:53 <pejo> solrize, or simply don't upgrade the OS.
05:52:52 <solrize> pejo if you only want to upgrade the application, multiple processes is the simplest way
05:53:06 <cjs> Oh, maybe making messageCount strict means that we don't keep around unevaluated thunks for previous market states, one for each of the hundreds of thousands or milions of messages I process.
05:55:59 <cjs> I dunno, it does seem strange, since it was printed.
05:56:23 <cjs> So is there a way to make updateStock completely strict?
05:59:11 <quicksilver> cjs: /me opens up your paste again,
05:59:26 <cjs> Like, using a $! somewhere?
05:59:36 <quicksilver> YES.
05:59:40 <quicksilver> cjs, you're a genius.
05:59:46 <quicksilver> messageCount = messageCount mkt + 1
05:59:48 <cjs> Like between the return and the mkt' ...?
05:59:52 <quicksilver> ^^ this is keeping the old mkt around.
05:59:56 <quicksilver> and that was your memory leak.
06:00:10 <cjs> ah ha!
06:00:12 <quicksilver> the messageCount thunk is not only a very deep nest of (...)+1)
06:00:19 <quicksilver> it also, at each level of the nest
06:00:23 <quicksilver> keeps alive the old 'mkt'
06:00:39 <quicksilver> so that's why making that strict makes such a huge difference.
06:01:13 <solrize> would return $! mkt' { time = ts, messageCount = messageCount mkt + 1}  have fixed that?
06:01:28 <quicksilver> solrize: no.
06:01:32 <cjs> I just checked; it doesn't.
06:01:38 <quicksilver> that would have made no difference at all.
06:01:46 <solrize> hm ok
06:01:51 <quicksilver> return $! is a common misapprehension.
06:01:55 <quicksilver> It doesn't work very often ;)
06:02:20 <quicksilver> the point in this particular case is that Market isn't strict in messageCount
06:02:23 <opqdonut> ah, memleak chasing
06:02:33 <opqdonut> my favourite sport right after optimizing haskell
06:02:33 <sioraiocht> if I'm trying to build a package, and get     Could not find module `Data.Array': it is a member of package array-0.1.0.0, which is hidden, what does "hidden" mean?
06:02:33 <lambdabot> sioraiocht: You have 1 new message. '/msg lambdabot @messages' to read it.
06:02:38 <opqdonut> ;)
06:02:54 <cjs> opqdonut: http://hpaste.org/7631
06:03:15 <pejo> sioraiocht, cabal hides stuff by default, so you need a dependency on the packages you want to use.
06:03:47 <sioraiocht> hrm...how do I do that?
06:03:54 <sioraiocht> this isn't a package I wrote, heh
06:04:25 <quicksilver> cjs: as to making updateStock completely strict, well
06:04:32 <cjs> So, quicksilver, where does it go?
06:04:43 <quicksilver> cjs: where does which go?
06:04:48 <cjs> The $!?
06:04:59 <cjs> It's too late at night for me; I can't manage the syntax.
06:05:11 <quicksilver> ;)
06:05:14 <quicksilver> don't use $!.
06:05:21 <quicksilver> it just confuses the issue
06:05:25 <quicksilver> use seq.
06:05:32 <cjs> Just use the ! on the declaration of messageCount?
06:05:35 <quicksilver> yes
06:05:39 <quicksilver> that's the simplest by far
06:05:40 <quicksilver> IMO
06:05:50 <quicksilver> ! on fields is often a sensible choice
06:05:57 <cjs> Except I have to spend valuable CPU cycles doing a show newstock.
06:05:59 <quicksilver> it's unusual that you want big thunks to build up inside fields.
06:06:40 <quicksilver> do you? does that still matter, now you've made the fields strict?
06:07:00 <cjs> Yes, that's still necessary.
06:07:40 <cjs> As is the ! on the Map, though it only grows to about 250 MB without that.
06:08:13 <cjs> Oh, and for some unknown reason, takes much, much longer to run without the ! on the map.
06:08:45 <cjs> I get the "3600 seconds, 885166 messages" right away, but then it sits there for, well, who knows how long? It used to finish in 50 seconds or so, and now it's at more than two minutes.
06:13:44 <mm_freak_work> i'm experimenting with Writer to do something weird, but somehow i get a stack overflow with the following code:
06:13:47 <mm_freak_work> calcSum c x = do when (isPrime x) $ tell [putStrLn $ "Prime: " ++ show x] calcSum (c+x) (x-1)
06:13:51 <mm_freak_work> aaaah
06:13:59 <mm_freak_work> sorry, auto-unwrapping
06:14:08 <mm_freak_work> calcSum c x = do when (isPrime x) $ tell [putStrLn $ "Prime: " ++ show x] >> calcSum (c+x) (x-1)
06:14:11 <opqdonut> chunks collecting in the argument?
06:14:50 <quicksilver> mm_freak_work: why writer [IO()] ?
06:14:58 <quicksilver> out of interest.
06:15:14 <mm_freak_work> quicksilver: i know i could do it a different way, just to test how well it would perform
06:15:45 <mm_freak_work> unfortunately for larger x, it runs out of swap-space…  my guess is that the (>>) is the last operation, and so the function is not tail-recursive
06:15:53 <mm_freak_work> is my thinking correct?
06:15:59 <mm_freak_work> uhm
06:16:00 <quicksilver> yes, that's quite true.
06:16:04 <quicksilver> but it doesn't normally matter.
06:16:04 <mm_freak_work> not swap-space, stack-space, sorry
06:16:18 <quicksilver> (monadic functions are not tail recursive but they still normally run OK)
06:16:26 <quicksilver> forever a = a >> forever a
06:16:29 <quicksilver> is not tail recursive
06:16:29 <opqdonut> how about the c+x argument?
06:16:31 <quicksilver> but it still works.
06:16:32 <opqdonut> nothing is forcing it
06:16:57 <quicksilver> and the (x-1) also.
06:17:01 <opqdonut> mhmm
06:17:07 <quicksilver> hmm isPrime probably forces that.
06:17:11 <quicksilver> I would imagine.
06:17:15 <mm_freak_work> opqdonut: GHC used to optimize that away properly, but maybe the function is too complex
06:17:19 <quicksilver> but yes, c+x isn't being forced.
06:17:20 <mm_freak_work> i'll try demanding it
06:17:25 <opqdonut> mm_freak_work: well try to ... yeah
06:17:40 <mm_freak_work> hmm
06:17:43 <mm_freak_work> that actually solved it
06:17:45 <mm_freak_work> ok, thank you =)
06:17:49 <sioraiocht> ugh, I have a module found in two packages, how can I force it to choose a particular package?
06:17:49 <opqdonut> :P
06:18:57 <mm_freak_work> so GHC properly optimizes sequences of bindings, when the last computation is a recursive call?
06:19:02 <mm_freak_work> in all cases?
06:20:11 <swiert> can anyone recommend a good paper/book explaining continuations?
06:20:23 <swiert> I have some vague intuition, but would like to read a bit more.
06:21:01 <sioraiocht> how can I fix this...   Could not find module `Data.ByteString.Lazy.Char8': it was found in multiple packages: fps-0.8 bytestring-0.9.0.1
06:22:08 <solrize> swiert, the lambda papers?
06:22:35 <solrize> also, hmm, http://okmij.org/ftp/Computation/Continuations.html
06:22:36 <lambdabot> Title: Continuations and delimited control
06:23:14 <swiert> solrize: yeah, I've been browsing through a few of those.
06:23:45 <swiert> I guess what I'm asking is "monads are to Wadler as continuations are to ..."
06:24:32 <quicksilver> swiert: continuations are considerably broader than that.
06:24:35 <solrize> hmm
06:24:46 <quicksilver> for example, you could read about the CPS transform as a compilation technique.
06:24:51 <quicksilver> which gives one kind of insight.
06:25:06 <quicksilver> or you could read about delimeted continuations as a general control structure
06:25:07 <solrize> (from wikipedia) Christopher Strachey, Christopher F. Wadsworth and John C. Reynolds brought the term continuation into prominence in their work in the field of denotational semantics that makes extensive use of continuations to allow sequential programs to be analysed in terms of functional programming semantics.
06:25:12 <quicksilver> which is a quite different kind of insight.
06:25:58 <swiert> quicksilver: sure, maybe I should be more precise in my question.
06:26:30 <swiert> A lot of Wadler's papers give nice, simple examples illustrating how common abstractions fit the same abstract notion of monad.
06:27:05 <swiert> Now I have some idea of CPS transforms, continuations in denotational semantics, etc.
06:27:14 <quicksilver> not many people write papers as well as Wadler :-/
06:27:35 <swiert> But every time someone uses the continuation monad in Haskell, for example, it has me stumped.
06:27:54 <swiert> I need to unfold a lot of the definitions to get some idea of what's going on.
06:28:11 <quicksilver> http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
06:28:12 <quicksilver> any use?
06:28:19 <solrize> http://portal.acm.org/citation.cfm?id=889232
06:28:24 <lambdabot> Title: Lambda: The Ultimate Imperative
06:30:54 <mm_freak_work> consider that i have an infinite list, and i want to extract a value by index, which takes some time…  what are your ways to output status messages?  i used to zip the list with IO actions or write a helper indexing function, but is there a cleaner way?
06:31:38 <swiert> Hmm. I'll have a look. Thanks for the tips you guys.
06:33:24 <cjs> quicksilver, replacing 'length (show newstock)' with what's essentially 'fromMaybe 0 (bestAsk s) + fromMaybe 0 (bestAsk s)' appears to result in about 30% performance improvement, while doing what we need as far as forcing evaluation goes.
06:34:43 <ari> :t trace
06:34:47 <lambdabot> Not in scope: `trace'
06:34:49 <cjs> But it's still an ugly hack. I'm disappointed.
06:34:53 <ari> @index trace
06:34:53 <lambdabot> Debug.Trace
06:35:39 <twobitwork> cjs: I thought you could force evaluation with strictness annotations
06:35:40 <ari> mm_freak_work: Debug.Trace.trace is useful for, well, debugging. If you want to actually release that program, you'll want something cleaner...
06:36:08 <twobitwork> :src show
06:36:47 <twobitwork> @src show
06:36:48 <lambdabot> show x = shows x ""
06:36:52 <twobitwork> @src shows
06:36:53 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:37:14 <twobitwork> how does show work?
06:37:19 <cjs> twobitwork, Apparently not, in some cases, or I don't know how to do it.
06:38:05 <mm_freak_work> ari: say, i want to check the mersenne number 2^P - 1 for primality…  for that i check whether (mersenneSeq !! (P-2)) is divisible by 2^P - 1
06:38:19 <cjs> If you look at http://hpaste.org/7631 , you'll note that Stock has a couple of Maybe Floats in it, and those are the issue. Making the field strict forces the Maybe, but not the Float, is the impression that I have.
06:38:20 <quicksilver> twobitwork: you can't easily force an evaluation through a maybe constructor.
06:38:25 <mm_freak_work> computing (mersenneSeq !! (P-2)) takes some time to compute, and i'd like to output status messages
06:39:14 <quicksilver> cjs: it's an interesting question and I don't claim to be an expert here. It might be instructive to post a summary of the issue on the -cafe and see if anyone smart steps up.
06:39:21 <cjs> You think that using a straight Float there would do the trick? I could use some other mechanism to signal that there's no value available, though it wouldn't be as clean, espcially when those values start going through a lot of processing.
06:39:22 <mm_freak_work> i like the idea of an infinite list, so i don't want to replace it by an iterative function, so to output status messages, i either write a helper function, or i zip the list with IO actions
06:39:43 <mm_freak_work> that looks ugly in code, so i wonder if there is a cleaner way
06:39:47 <cjs> yeah, I guess I need to join that list.
06:39:54 <quicksilver> cjs: one approach is rnf from Control.Parallel.Stragies
06:39:59 <quicksilver> cjs: Strategies.
06:40:08 <quicksilver> cjs: it gives you a typeclass for 'full seq'.
06:40:23 <quicksilver> Maybe Float should already be an instance.
06:40:36 <quicksilver> but you'll need to write your own for Stock
06:40:42 <quicksilver> but composing the instances for Stock's components.
06:40:43 <quicksilver> it's not hard.
06:42:14 <cjs> You're talking about NFData?
06:42:16 <saml> map f [100,90,85,53, ...] what should be f that preserves ordering of the list but makes all values above n ?
06:42:40 <opqdonut> saml: (+n) ?
06:42:56 <quicksilver> cjs: yes.
06:43:06 <cjs> So I need to write an rnf for it.
06:43:24 <saml> and it should not be above 100. i'm just trying to get a good grade curve algorithm that won't affect higher grades much.
06:43:34 <quicksilver> instance NFData Stock where rnf s = rnf (stockCode s) `seq` rnf (stockName s) `seq` rnf (bestAsk s) `seq` rnf (bestBid s)
06:43:48 <quicksilver> is pretty much all it is.
06:46:23 <Deewiant> saml: min 100 . (+n)?
06:47:47 <cjs> Hm. That's an interesting thought.
06:47:55 <cjs> I think I really need to do a bunch of reading about this, though.
06:49:31 <cjs> Oh, I just realized what might be contributing to this problem.
06:50:00 <cjs> I didn't mention it before, but the bid and ask prices are generated through a whole lot of parsing of the messages I'm processing.
06:50:48 <twobitwork> cjs: have you seen the movie "Pi: Faith in Chaos"?
06:50:54 <cjs> So I could see forcing the float to be forcing a whole lot of processing, back down to parsing the packet.
06:50:59 <cjs> twobitwork, No, I've not.
06:51:21 <twobitwork> cjs: ohh... it's a great movie. talking about programs which analyze bid/ask prices made me think of it
06:51:27 <cjs> Oh, I have. It was called just 'pi' for me.
06:51:31 <cjs> But I don't recall it very well.
06:51:39 <twobitwork> ahh :)
06:51:53 <twobitwork> I'm pretty sure the full title is what I cited, but I might be wrong
06:52:06 <quicksilver> cjs: yes, that sounds likely.
06:52:07 <cjs> Oh, it's starting to come back. It seemed to me that it was more numerology than math.
06:52:19 <quicksilver> cjs: if you don't do that then you're holding onto the original unparsed data
06:52:27 <quicksilver> cjs: and some big thunks which instructions on how to parse.
06:52:41 <twobitwork> cjs: well... it started out with this guy building a computer system to analyze the stock market
06:52:59 <saml> Deewiant: i think i want something like 1/e^(grade/lowerBound) or somethign similar.
06:53:02 <cjs> Well, I'm holding on to a great deal of it anyway, perhaps. I just realized, a lot of my stuff is just lazy bytestrings pulled up into things like Stock from where I originally read them.
06:53:36 <cjs> So possibly I want to convert any bits that might be hanging around for a while to strict bytestrings, so the rest of the message can be released.,
06:54:39 <quicksilver> well probably rnf-inf up the Stock type is the sane solution
06:54:43 <quicksilver> for this particular case.
07:04:52 <cjs> So I want 'Map.insert sc newstock map `demanding` rnf newstock'?
07:05:42 <cjs> Yes, that seems to do the trick.
07:06:08 <SamB> does anyone know how to get Emacs 21 to copy/paste utf-8 properly?
07:06:23 <cjs> Though it actually takes a few percent more time than doing the add!
07:07:43 <cjs> And my rnf is even ignoring the stockCode and stockName.
07:07:53 <cjs> quicksilver, any thoughts on why it might be a hair slower?
07:07:57 <SamB> my current method involes writing text out to files and then viewing it on a terminal...
07:08:47 <saml> how can I find lowest value in a list?
07:09:20 <saml> > let l = [35,2,6,68,35,7,3,757] in zipWith min l (tail l)
07:09:23 <lambdabot>  [2,2,6,35,7,3,3]
07:09:52 <tromp> :t min
07:09:54 <lambdabot> forall a. (Ord a) => a -> a -> a
07:09:54 <tromp> :t minimum
07:09:57 <lambdabot> forall a. (Ord a) => [a] -> a
07:10:03 <saml> > let l = [35,2,6,68,35,7,3,757] in minimum l
07:10:04 <lambdabot>  2
07:10:09 <saml> thanks tromp
07:10:59 <Bonus> beware though
07:11:06 <Bonus> for large lists minimum and maximum choke
07:11:42 <tromp> @src minimum
07:11:43 <lambdabot> minimum [] = undefined
07:11:43 <lambdabot> minimum xs = foldl1 min xs
07:12:41 <tromp> > foldl1 min [a,b,c,d]
07:12:43 <lambdabot>  min (min (min a b) c) d
07:13:12 <saml> > foldr1 (flip min) [a,b,c,d]
07:13:13 <lambdabot>  min (min (min d c) b) a
07:13:46 <saml> > foldr1 (flip min) [100000,99999,..,1]
07:13:47 <lambdabot>  Parse error at "..,1]" (column 33)
07:13:50 <saml> > foldr1 (flip min) [100000,99999,..1]
07:13:51 <lambdabot>  Parse error at "..1]" (column 33)
07:13:54 <saml> > foldr1 (flip min) [100000,99999,..]
07:13:54 <lambdabot>  Parse error at "..]" (column 33)
07:14:15 <saml> > foldr1 (flip min) [100000,99999..]
07:14:17 <lambdabot>  Exception: stack overflow
07:14:34 <saml> > minimum [100000,99999..]
07:14:44 <lambdabot>  Exception: Time limit exceeded
07:15:02 <conal> > minimum [100000,99999 .. 1]
07:15:03 <lambdabot>  1
07:15:41 <saml> arg i need to set limits properly or my pc chokes
07:16:12 <tromp> @src foldl1'
07:16:12 <lambdabot> Source not found. I feel much better now.
07:16:16 <tromp> @src foldl'
07:16:16 <lambdabot> foldl' f a []     = a
07:16:16 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
07:16:29 <cjs> Hm. Maybe I'll be back in a while.
07:17:44 <sioraiocht>     Duplicate instance declarations:
07:17:44 <sioraiocht>       instance Functor ((->) r)
07:17:45 <sioraiocht>         -- Defined at QuickCheckUtils.hs:(144,0)-(145,13)
07:17:45 <sioraiocht>       instance Functor ((->) r) -- Defined in Control.Monad.Instances
07:21:21 <sioraiocht> sorry guys
07:21:21 <sioraiocht> didn't mean to past that here
07:21:21 <sioraiocht> it was all my client's fault
07:21:25 <sioraiocht> @seen dcoutts
07:21:26 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #haskell-blah. I last heard dcoutts speak 16h 2m 39s ago.
07:21:31 <sioraiocht> @seen dcoutts_
07:21:32 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 20h 33m 8s ago.
07:21:39 <sioraiocht> @seen dcoutts__
07:21:39 <lambdabot> dcoutts__ has changed nick to dcoutts.
07:21:39 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #haskell-blah. I last heard dcoutts speak 16h 2m 53s ago.
07:23:46 <MarcWeber> http://hpaste.org/7632 Is there a good reason why this shouldn't be allowed? Of counse I can start adding a lot of new data types.. But isn't that just poilerplate code?
07:24:51 <quicksilver> MarcWeber: you can't use unapplied type synonyms.
07:25:07 <quicksilver> MarcWeber: I think higher-kinded type synonyms are OK, though.
07:25:18 <opqdonut> yeah "type RM1 = ReaderT R1 IO" should work
07:25:19 <quicksilver> try type RM1 = ReaderT R1 IO ?
07:25:41 <quicksilver> unapplied type synonyms sneak type level lambdas in via the back door.
07:25:48 <quicksilver> that opens a can of worms.
07:25:48 <quicksilver> AIUI.
07:27:43 <MarcWeber> You are right. I just can't see the difference yet. Thanks.
07:29:00 <quicksilver> it would be safe to only ever unapply rightmost parameters
07:29:07 <quicksilver> but that woudl be a strange rule and would confuse people.
07:29:15 <quicksilver> What is unsafe is:
07:29:24 <quicksilver> type Flip a b = X b a
07:29:31 <quicksilver> and then use "Flip a"
07:29:54 <quicksilver> so the simple rule is : type synonyms must be fully applied.
07:30:17 <MarcWeber> And my use case dos'nt make sense at all, right ? .. :)
07:30:23 <anne> ghci just told me: "My brain just exploded."
07:30:29 <dcoutts_> sioraiocht: yarr!
07:30:36 <sioraiocht> hey dcoutts_
07:30:48 <dcoutts_> hia :-)
07:32:21 <sclv_> type level lambdas would be awesome.
07:32:46 <opqdonut> yeah except they're kinda problematic wrt type inference
07:33:26 <sclv_> i wouldn't even use them for anything useful -- i'd just write point free types.
07:36:01 <sclv_> myfunc :: Flip :. Flip (:.) :. (([m a]->Int->Int) :.) -> a
07:36:04 <sclv_> or whatever
07:36:43 <sclv_> which is exactly why we don't have them...
07:43:35 <nornagon> sclv_: wf.
07:43:38 <nornagon> wtf, even.
07:43:57 <saml> data SourcePos      = SourcePos SourceName !Line !Column   -- what are ! ?
07:44:31 <mauke> strictness annotations
07:44:50 <saml> oh thanks
07:51:53 <cjs> Hey, it just occurred to me, anything assigned to an MVar has to be fully evaluated, right?
07:52:07 <cjs> Or can an MVar hold a reference to a thunk?
07:52:24 <cjs> Or hold things that hold references to a thunk?
07:52:31 <conal> cjs: i'm pretty sure the contents can be unevaluated
07:53:21 <conal> cjs: you could do an experiment, storing undefined in an mvar.
07:53:28 <mm_freak_work> http://hpaste.org/7633 -- sometimes haskell's laziness makes things hard
07:53:54 <conal> mm_freak_work: hard how?
07:54:01 <mm_freak_work> this function does what it's expected to do:  it displays all status messages first and then gets the element from the list
07:54:42 <mm_freak_work> i'd rather want it to display the status messages in parallel, so they're actually useful =)
07:55:12 <atsampson> you mean it displays the status messages before the things in the list are computed?
07:55:22 <mm_freak_work> yes
07:55:23 <atsampson> could you add some strictness annotations to fix that?
07:55:27 <lilac> mm_freak_work: put a 'return x' inside your do block?
07:55:28 <cjs> conal, that's a good idea. Thanks.
07:55:44 <lilac> hmm, that probably doesn't help
07:55:51 <kpreid> mm_freak_work: indexStatus doesn't ever do anything with x
07:55:52 <conal> mm_freak_work: *why* do you want the elements evaluated?
07:55:57 <quicksilver> conal: to time it.
07:56:03 <quicksilver> conal: to display gradual progress.
07:56:04 <atsampson> lilac: it doesn't need one, it tail-recurses
07:56:04 <kpreid> @hoogle evaluate
07:56:05 <lambdabot> Control.Exception.evaluate :: a -> IO a
07:56:09 <quicksilver> what mm_freak_work isn't telling you
07:56:16 <lilac> atsampson: i meant to force evaluation
07:56:16 <cjs> Actually, if my ps viewer could search in the Concurrent Haskell paper, that might tell me. But I can't find the part that mentions MVars and thunks.
07:56:17 <kpreid> mm_freak_work: I think evaluate is what you want
07:56:21 <quicksilver> is that each element in the list depends functionally on the previous one.
07:56:23 <mm_freak_work> i tried to, but where should i add them?  i tried demanding the result, in which case, the result is computed and then the status messages are printed — not very useful either
07:56:35 <quicksilver> mm_freak_work: x `seq` indexStatus....
07:56:42 <kpreid> mm_freak_work: put "evaluate x" in the do block
07:56:49 <quicksilver> mm_freak_work: force x to be calculated before you recurse.
07:56:56 <lilac> atsampson: but that doesn't work of course. "return (seq x ())" probably does the trick
07:57:06 <mm_freak_work> quicksilver: thanks a lot…  that solved it
07:57:08 <atsampson> lilac: ah, I was about to ask... ;)
07:57:08 <lilac> @src evaluate
07:57:09 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
07:57:09 <quicksilver> lilac: that won't work either.
07:57:11 <kpreid> lilac: it does? what's looking at the ()?
07:57:19 <quicksilver> lilac: nothing will inspect that ().
07:57:21 <conal> mm_freak_work: you want to evaluate because you're timing?
07:57:31 <mm_freak_work> conal: i'm not timing, just displaying progress
07:57:36 <quicksilver> evaluate considered harmful.
07:57:44 <quicksilver> and return $!
07:57:47 <mm_freak_work> it works now
07:57:54 <quicksilver> they just confuse people from learning about seq
07:57:58 <quicksilver> which is what they really want :)
07:58:12 <Vq^> quicksilver: how do you replace evaluate with seq?
07:58:14 <quicksilver> mm_freak_work: you are being dishonest about your problem.
07:58:16 <conal> mm_freak_work: why do you want to make progress?  i guess i'm wondering if you're in the functional mindset yet.
07:58:32 <quicksilver> conal: he has a big list. It turns out that each element uses earlier elements.
07:58:41 <quicksilver> conal: (think naive fibs, as a picture)
07:58:48 <quicksilver> conal: forcing the "Nth" element is rather slow.
07:58:58 <mm_freak_work> conal: the list is nontrivial to calculate (i.e. it takes time), and i want to show to the user, how for the calculation has come
07:58:59 <quicksilver> conal: so he wants a "status update" during the process
07:59:13 <quicksilver> conal: so he decides to force each element one at a time.
07:59:33 <quicksilver> conal: which worked, when we added another seq :)
07:59:48 <quicksilver> Vq^: by 'seq'ing the thing you actually want, just before a monad action which will be applied.
07:59:49 <mm_freak_work> btw, interestingly the forcing not only made the status messages display appropriately, but also made the actual calculation go faster =)
08:00:04 <quicksilver> reduces the amount of memory used
08:00:08 <quicksilver> and the stack depth
08:00:18 <quicksilver> deep stacks have a slightly negative effect on execution speed
08:00:26 <conal> quicksilver: i get it, thx.  if he just forced the last element, there would be a single long delay with no progressive info to the user.
08:00:32 <quicksilver> conal: exactly.
08:00:45 <quicksilver> conal: the way I feel he was being dishonest is suggesting this is a property of lists in general.
08:00:55 <quicksilver> conal: when really it's only a property of lists where each element depends on the one before :)
08:01:04 <quicksilver> otherwise the exercise of forcing woudl be pointless.
08:01:16 <mm_freak_work> yes =)
08:01:18 <conal> quicksilver: i'd s/dishonest/confused
08:01:23 <nominolo> @seen swiert
08:01:24 <lambdabot> swiert is in #haskell. I last heard swiert speak 1h 29m 45s ago.
08:01:31 <quicksilver> well I didn't mean to attribute malice :)
08:01:50 <conal> oh
08:01:59 <cjs> mm_freak_work, also, if it was *really* using a lot of memory, you stopped paging. :-)
08:02:29 <mm_freak_work> conal: btw, using the infinite list in the first place (instead of writing a function), is very functional thinking IMO =)
08:02:59 <mm_freak_work> if you're interested, this is the list i'm running it with: llSeq n = unfoldr (\x -> Just (x, mod (x^2 - 2) n)) 4
08:03:01 <conal> mm_freak_work: agreed!
08:03:05 <mercury^> http://rohanlean.de/pub/ghc_optimization/
08:03:06 <lambdabot> Title: Index of /pub/ghc_optimazation
08:03:16 <mercury^> can someone please help me figure out why _4 is so much faster?
08:03:25 <mm_freak_work> it's the lucas-lehmer-sequence for the mersenne primality check
08:03:30 <conal> mm_freak_work: now how about using a mapM_ ?
08:03:48 <mercury^> _4 *should* be slowest because it does unnecessary work at the end
08:03:51 <mm_freak_work> how?
08:04:43 <mm_freak_work> ah
08:04:57 <conal> oh -- mapM_ wouldn't quite do it, because of the final return x.
08:05:05 <conal> and you wouldn't want two passes
08:05:15 <gubagem> what do i need to import to get unfoldr
08:05:21 <mm_freak_work> i get it, but i think, it wouldn't make the function any easier anyway
08:05:40 <mm_freak_work> foldM with zipping might be an idea, though
08:06:02 <mercury^> gubagem: Data.List
08:06:07 <conal> mm_freak_work: yes, and i bet if you tinkered, the result would be prettier and have some reusable parts.
08:06:08 <mercury^> iirc
08:06:21 <conal> explicit recursion is the goto of functional programming.
08:06:31 <gubagem> is there a decent haskell ide ?
08:06:34 <mm_freak_work> i'll try something
08:06:44 <gubagem> i tried the eclipse plugin and it wasnt too pretty
08:07:05 <mercury^> what do you want the IDE to do?
08:07:39 <gubagem> let me edit files (syntax highlighting would be ok) and click a button or hit a key to compile or run the source
08:07:56 <mapreduce> gubagem: You can use emacs for that.
08:08:03 <DuClare> What does define an IDE?
08:08:05 <mapreduce> Or probably any programmers' text editor.
08:08:07 <mauke> or vim
08:08:09 <mauke> or anything
08:08:10 <conal> gubagem: i like haskell-mode in emacs
08:08:11 <earthy> gubagem: Visual Haskell is pretty nice
08:08:17 <mapreduce> DuClare: "does more than I think emacs does"
08:08:21 <earthy> if you can stand the windowsness of it.
08:08:28 <mercury^> hmm, I just use an editor that has haskell syntax highlighting and also have ghci and one shell to compile running
08:08:34 <DuClare> mapreduce, So I guess there are no IDEs in the world :)
08:08:50 <DuClare> It's quite a problem actually
08:08:57 <mapreduce> DuClare: Sure there are, it just depends on what you think emacs does. :)
08:09:00 <mercury^> does anyone have a clue about the performance issue I posted the link about?
08:09:12 <Vq^> mapreduce: that only leaves emacs with-a-sink-edition
08:09:13 <DuClare> People complain that they want an ide, not a text editor…  But what does the IDE do that the text editor doesn't?
08:09:16 <DuClare> mapreduce, Well emacs does everything
08:09:32 <mapreduce> DuClare: for varying values of 'you'
08:09:37 <DuClare> Un
08:09:40 <gubagem> yea thats the problem || good thing of emacs
08:09:46 <DuClare> But, that kind of an answer doesn't really help
08:10:21 <DuClare> I mean, what are those people actually looking for?  Last time it happened (somebody complaining they want a "full fledged ide, not text editor") he couldn't state what he wants from an IDE, or what makes something an IDE.
08:10:40 <DuClare> Quite an interesting question IMO, since there are excellent text editors out there.
08:10:49 <DuClare> Where do you pull the line...  What does an IDE do..
08:11:05 <quicksilver> An overview of the files in the project, background compilation, multiple file search and replace, refactoring, debug/production build settings.
08:11:08 <mapreduce> I've discussed it before with people and they too couldn't actually define it.
08:11:21 <quicksilver> in a haskell context particularly, add to that automatic type annotations and inferences
08:11:30 <cjs> Ah. So unevaluated thunks can go in MVars, and there's a strict-concurrency package on hackage that offers useful stuff. All very good to know.
08:11:31 <quicksilver> and type-sensitive code suggest.
08:11:51 <quicksilver> cjs: sory, I could have told you that I'd known that was your question :)
08:11:55 <DuClare> Do IDEs actually compile in the background?
08:12:00 <quicksilver> Yes.
08:12:12 <DuClare> Mmh.
08:12:20 <mrd> flymake-mode :)
08:12:22 <quicksilver> Almost all of the things above emacs can do, by the way.
08:12:29 <quicksilver> only type-sensitive code suggest it can't.
08:12:42 <quicksilver> and refactoring is pretty limited at the moment.
08:12:48 <DuClare> quicksilver, What is exactly this type-sensitive code suggest?
08:12:48 <mercury^> which is the most useful thing of all
08:13:03 <cjs> And strict-concurrency is written by, who else, dons! The man is amazing!
08:13:04 <quicksilver> DuClare: when you've type a partial line of code, it can suggest what comes next
08:13:06 <mercury^> DuClare: name completion that takes types into account
08:13:10 <quicksilver> based on the type you have so far.
08:13:58 <mrd> need an error-recovering haskell parser
08:14:02 <mm_freak_work> conal: that's not gonna work…  i'd need a takeM, too, and things would start to get complicated
08:14:08 <mercury^> if you gave a prior annotation for a value and then started typing the definition, it could suggest names that are functions "ending" in that type
08:14:27 <quicksilver> mrd: and an incremental parser.
08:14:36 <quicksilver> mrd: unless you want to re-parse after every key press.
08:14:37 <mm_freak_work> ah no…  one solution remains…
08:14:46 <mrd> yeah... haskell is rather tricky
08:14:48 <mercury^> anyway, thoughts on my performance issue? : )
08:14:52 <quicksilver> These things aren't "hard" problems. But they're fiddly problems.
08:14:54 <nominolo> quicksilver: yi is getting some of those features
08:15:03 <quicksilver> mercury^: I had a very brief look and was mstified like you :)
08:15:11 <quicksilver> mercury^: are you sure you used the same optimisation level?
08:15:14 <quicksilver> nominolo: I know ;)
08:15:15 <mercury^> yep
08:15:18 <nominolo> quicksilver: yi is starting to integrate all the visual haskell functionality
08:15:19 <quicksilver> nominolo: I look forward to it.
08:15:24 <cjs> Yi looks like the way to go, to me. At least for real programmers.
08:15:36 <nominolo> quicksilver: and i'll help out on the ghc api side ;)
08:15:42 <cjs> (Real programmers being those who write the features they miss. :-))
08:16:44 <ehird> Heffalump: I'm still interested in how you declare a table using your thingy.
08:16:54 <ehird> & how much work it would be to get it going with sqlite
08:16:57 <ehird> (sqlite3, that is)
08:19:46 <cjs> Oh, hey, you can use a ! on the argument of a function to make it strict?
08:20:09 <mm_freak_work> conal: http://hpaste.org/7634
08:20:10 <smg> cjs: positive
08:20:11 <swiert> nominolo: hi.
08:20:16 <mm_freak_work> it works, but i like the other version more
08:20:31 <ehird> :)
08:20:38 <conal> mm_freak_work: yeah -- not pretty yet.
08:20:42 <nominolo> swiert: nice early announcement for gsoc TMR
08:21:01 <swiert> nominolo: well, I thought I'd warn people early.
08:21:03 <conal> mm_freak_work: are you avoiding traversing the list twice?
08:21:12 <conal> mm_freak_work: i notice that you already know the length (p)
08:21:14 <mm_freak_work> conal: yes
08:21:15 <swiert> I usually get more articles from people by constantly badgering them.
08:21:32 <conal> mm_freak_work: how do know the length?
08:21:35 <nominolo> swiert: no, i really think it's a good idea
08:21:40 <mm_freak_work> it traverses it only once, at least that's my observation from its performance
08:21:59 <quicksilver> badgers++
08:22:07 <nominolo> swiert: other question, though.  it seems the french seem to have money for complinig dependently typed PLs
08:22:15 <mm_freak_work> conal: the length is the index i + 1…  i take (i-2) though, because it suits my needs
08:22:42 <swiert> nominolo: ok. Any group in particluar?
08:23:01 <mm_freak_work> in a more general application, i'd just take i+1 elements and fold them to the result
08:23:07 <conal> mm_freak_work: if you don't mind two traversals, you could done one pass that evals the elements and a second that extracts the last element.  and perhaps with stream fusion of the sort dons does, the compiler could fuse the two loops.
08:23:14 <ehird> Heffalump: no? :-)
08:23:36 <mm_freak_work> stream fusion?
08:24:31 <mm_freak_work> conal: could you point me to an example?
08:24:36 <conal> mm_freak_work: described in an icfp07 paper, perhaps plus some work-in-progress
08:25:18 <conal> mm_freak_work: http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
08:25:19 <lambdabot> Title: Stream Fusion: From Lists to Streams to Nothing at All
08:25:38 <mm_freak_work> but what's the point of traversing the list twice in this case?  the calculation itself is simple…  it's just "x" =)
08:26:20 <ehird> So.
08:26:25 <ehird> What should I use for databases, right now.
08:26:30 <ehird> If I want sqlite3.
08:26:35 <ehird> And table definitions in Haskell.
08:26:38 <ehird> Instead of SQL.
08:26:57 * SamB realizes that before he can use new Agda features, he must pull and rebuild...
08:27:01 <conal> mm_freak_work: i was thinking that without the final 'return x', there's probably a simpler formulation.
08:27:20 <conal> mm_freak_work: hence the idea of moving that last bit to a separate pass.
08:27:38 <conal> mm_freak_work: separation of concerns
08:28:00 <conal> mm_freak_work: for more modularity/reusability
08:28:43 <ehird> ;\
08:29:10 <mm_freak_work> conal: i need to at least force the x in the folding function
08:29:28 <mm_freak_work> so i can just as well return it in the same run
08:29:47 <mm_freak_work> less modular, but more senseful
08:30:22 <conal> mm_freak_work: suit yourself
08:32:18 <mm_freak_work> conal: i like other opinions, of course, but i view the progress messages to be directly related to the computation…  i'm sure there is a way to separate them, but whether it makes sense is another question, and a matter of view =)
08:32:33 <mm_freak_work> but i'll try something
08:34:22 <ehird> Does nobody use dbs and haskell? :p
08:35:44 <mm_freak_work> conal: http://hpaste.org/7635
08:36:56 <mm_freak_work> works well, but it's a bit less efficient
08:37:39 <quicksilver> ehird: not many people. I think haskelldb is the closest to what you asked for, I'm not sure.
08:38:14 <ehird> quicksilver: Is dead.
08:38:18 <ehird> And does not do haskell table definitions.
08:38:22 <Arnar> I'm a little confused about error handling... can't I use catch inside a do block?
08:38:31 <conal> mm_freak_work: evaluating the elements sequentially is a task that useful independently from what you're doing next, namely extracting the last element.  if you separate the two, i think you can simpler & more reusable code.  as for performance, automatic fusion is pretty good these days.
08:38:36 <quicksilver> Arnar: catch is completely orthogonal to "do blocks"
08:38:42 <quicksilver> Arnar: in fact do blocks are orthogonal to everything ;)
08:38:47 <quicksilver> they're only syntactic sugar.
08:38:51 <Arnar> quicksilver: yeah, that's what I thought..
08:38:56 <Arnar> quicksilver: I'm having some other problem then..
08:39:01 <quicksilver> the thing is just to make sure you're using the catch that suits the types you have.
08:39:11 <quicksilver> unless you're being tripped by a "trival" indentation thing.
08:39:14 <Arnar> I have a  "resp <- catch (function-that-throws ...) (const $ return "")"
08:39:33 <quicksilver> @hoogle catch
08:39:34 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
08:39:34 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
08:39:34 <lambdabot> System.IO.Error.catch :: IO a -> (IOError -> IO a) -> IO a
08:39:34 <Arnar> I just "throw $ AssertionFailed "xxx""
08:39:35 <mm_freak_work> conal: it has a noticable performance penalty, though
08:39:47 <conal> mm_freak_: unless it's fused
08:39:57 <quicksilver> Arnar: looks sane to me. What happenes?
08:40:06 <mm_freak_work> maybe i should try (last . take (i+1)) instead of (!! i)
08:40:14 <Arnar> quicksilver: the exception just shows up on the console (it is inside a forkIO)
08:40:15 <conal> mm_freak_work: the point of fusion is coexistence of modularity and performance
08:40:31 <quicksilver> @hoogle throw
08:40:31 <lambdabot> Control.Exception.throw :: Exception -> a
08:40:31 <lambdabot> GHC.Conc.throwTo :: ThreadId -> Exception -> IO ()
08:40:31 <lambdabot> Control.Exception.throwIO :: Exception -> IO a
08:40:44 <mm_freak_work> conal: yeah, i've got that, and i'm reading the paper currently
08:40:51 <twobitwork> how would you use an IO Bool? I can't do "if (fileExist "myfile") ..." or can I?
08:40:53 <quicksilver> Arnar: are you by any chance tring to catch with Prelude.catch but throwing with Control.Exception.throw?
08:40:58 <mm_freak_work> but how can i rewrite the code to eliminate the penalty?
08:41:00 <Arnar> quicksilver: yes.. precisely
08:41:05 <Arnar> :)
08:41:11 <quicksilver> twobitwork: exi <- fileExist "myfile"; if exi then
08:41:12 <conal> mm_freak_work: why still a fold?
08:41:16 <quicksilver> Arnar: well that won't work :P
08:41:22 <quicksilver> Arnar: use Control.Exception.catch
08:41:49 <conal> mm_freak_work: oh ... i see why -- for data dependency .
08:41:58 <Arnar> quicksilver: yeah.. works like a charm now :)
08:42:09 <Arnar> quicksilver: what is the difference?
08:42:23 <quicksilver> Prelude.catch can only catch IOErrors
08:42:23 <conal> mm_freak_work: no, on second thought, a fold ought to work
08:42:25 <mm_freak_work> conal: yeah, but now actually, a mapM_ would suffice, too
08:42:28 <quicksilver> (look closely at that type)
08:42:29 <Arnar> quicksilver: ah.. ok
08:42:39 <Arnar> :t Prelude.catch
08:42:43 <conal> mm_freak_work: yep -- that's what i meant mapM_
08:42:44 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
08:42:46 <Arnar> :t Control.Exception.catch
08:42:48 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
08:42:58 <conal> mm_freak_work: btw, do you know about annotate in hpaste?
08:43:27 <Arnar> thanks quicksilver++
08:43:45 <conal> mm_freak_work: why take (i+1) xs instead of just xs?
08:44:29 <quicksilver> Arnar: "error" in the IO monad throws and IOError
08:44:36 <quicksilver> Arnar: so "error" can be caught by Prelude.catch
08:44:44 <quicksilver> Arnar: but mostly you should use Control.Exception
08:44:55 <Arnar> quicksilver: ok.. which is why there is no Prelude.throw
08:44:59 <quicksilver> Arnar: and if you're diong much you should probably use throwDyn and catchDyn and you're own types.
08:45:03 <quicksilver> :t ioError
08:45:04 <lambdabot> forall a. IOError -> IO a
08:45:10 <quicksilver> well that is throw. Sort of.
08:45:20 <quicksilver> s/you're/your/
08:45:32 <Arnar> quicksilver: yeah.. just trying things out with throw/catch to experiment.. will change to throwDyn/catchDyn eventually
08:45:35 <quicksilver> damn, it's the apostrophes I confiscated from swiert this morning coming back to haunt me.
08:45:48 <Arnar> :)
08:46:07 <mm_freak_work> conal: because foldM and mapM consume the entire list
08:46:16 <Arnar> quicksilver: is there a more conscise way of saying "import Prelude hiding (catch) \n import Control.Exception (catch)" ?
08:46:20 <skorpan> assume that (x s) == 0 when the following is executed. which value will be returned? "put (s { x = (x s) + 1}); return (x s)"
08:46:22 <conal> mm_freak_work: and you don't want that?
08:46:26 <quicksilver> Arnar: no.
08:46:32 <Arnar> quicksilver: ok.. fair enough :)
08:46:38 <mm_freak_work> i have a working solution using mapM_ now, but the performance penalty is still there
08:46:43 <mm_freak_work> conal: the list is infinite =)
08:46:51 <conal> mm_freak_work: oh! okay
08:47:37 <conal> mm_freak_work: how about more functionally: use map instead of mapM.  yield a list of progress strings.
08:48:11 <ehird> :\
08:48:16 <mm_freak_work> conal: yeah, but that won't actually solve the efficiency problem =/
08:48:40 <conal> mm_freak_work: may play better with fusion though, which i think will take care of efficiency.
08:51:05 <mm_freak_work> well…  i'll look into streams tomorrow
08:52:02 <conal> ok
08:52:06 <mm_freak_work> for now, i'll go back to the folded variant…  IMO still the fold is more intuitive, because i'm reducing the list to the indexed element, and printing status messages at the same time
08:52:17 <ehird> First person to solve my DB woes gets luv.
08:56:17 <ehird> Hrm.
08:56:21 <ehird> Can GHC handle recursive imports?
08:56:28 <ehird> module A imports module B which imports module A.
08:56:41 <opqdonut> no iirv
08:56:43 <opqdonut> *iirc
08:57:11 <Cale> Pickles are great, but I imagine that you'd have a different definition of "great" if you were a pickle taste-tester. That's probably because they only have an English-French dictionary at the pickle factory.
08:57:14 <twobitwork> no? that's strange... it supports recursive everything else :P
08:57:29 <ehird> opqdonut: Sux!
08:57:43 <Cale> twobitwork: Yeah, it does support recursive imports somewhat poorly.
08:57:56 <Cale> You need to make hs-boot files.
08:58:01 <twobitwork> hmm....
08:58:04 <Cale> er, or something like that :)
08:58:28 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
08:58:29 <lambdabot> Title: 5.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
08:58:57 <Cale> It's usually not worth the trouble.
08:59:48 <twobitwork> I don't understand what an English-French dictionary has to do with pickles...
09:00:21 <Cale> I don't either. That's what makes it a mystery.
09:00:36 <twobitwork> more like nonsense :P
09:00:37 <Cale> (Note: I have had no sleep.)
09:01:20 <ehird> Cale: See, I have HaskellNomic.Actions, which imports HaskellNomic.Actions.*. But things in HaskellNomic.Actions.Foo probably want to use the helpers defined in HaskellNomic.Actions
09:01:42 <quicksilver> ehird: you probably want to put them in HaskellNomic.Helpers
09:01:50 <quicksilver> ehird: and or .Actions.Helpers
09:02:16 <quicksilver> I am told by smart people that I believe that there are good uses cases for recursive modules but I've never seen one.
09:02:28 <quicksilver> Apparently some smart people think the loch ness monster exists.
09:02:29 <quicksilver> :)
09:04:00 <ehird> quicksilver: yeah, good point
09:04:16 <ehird> Whee. HaskellNomic is fun. :P
09:04:46 <Cale> It still is something which should just work and doesn't :P
09:05:43 <ehird> quicksilver: HaskellNomic.Helpers would get messy I imagine.
09:05:48 <ehird> HaskellNomic.Actions.Helpers seems good.
09:06:05 <vixey> about Curry ... does anyone have an example of why Lazy logic programming is useful compared to strict
09:06:05 <vixey> ?
09:06:28 <Cale> vixey: I imagine for the same reason that lazy functional programming is useful compared to strict.
09:06:45 <ehird> quicksilver: Would it be reasonable to, e.g., re-export Network.CGI in .Actions.Helpers?
09:06:55 <ehird> that is, actions will use Text.XHtml and cgi and all that all the time
09:07:03 <ehird> but is it bad practice to have a 'polluting' package?
09:07:04 <Cale> There may be some especially logic-based use cases though, but I don't know.
09:07:54 <Cale> Having more programs terminate gives you more ways to decompose problems.
09:09:25 <vixey> Cale: yeah.. I haven't been able to come up with any example though
09:09:47 <vixey> I was thinking about stuff like threading infinite lists through something but .. I don't see much advantage yet
09:10:02 <vixey> so I'm not sure if curry is useful yet
09:10:17 <Cale> Well, isn't curry also a functional language?
09:11:13 <vixey> yeah
09:12:36 <quicksilver> ehird: I normally find re-exporting causes annoying problems. But YMMV.
09:13:42 <Cale> I'm not sure that curry has such an operation, but it would, for example, be possible to reify a tree of potential unifications as a (possibly infinite) datastructure, and regardless of that, I'm pretty sure you can go in the other direction.
09:16:12 <ehird> Is there a package that includes a mapping of http status codes to names?
09:16:15 <ehird> that is, 404 -> "Not Found"
09:16:55 <Cale> vixey: aha, yes it does
09:17:05 <vixey> huh?
09:17:18 <Cale> vixey: findall in the standard library provides a list of all the solutions to a search goal
09:18:40 <Cale> It's based on the primitive try :: (a -> Success) -> [a -> Success], which effectively does one step of nondeterministic computation in the search goal
09:20:16 <Cale> So lazy evaluation gives you a faithful reification of the search process.
09:20:58 <Cale> (whereas with strict datastructures, that sort of thing would sometimes diverge)
09:21:11 <ehird> :\
09:26:09 <ehird> GUESS I'LL JUST DO IT MYSELF HUH
09:26:52 <mercury^> ehird: I'm sure it has been done before
09:26:59 <ehird> mercury^: :)
09:27:05 <ehird> Hey, can I reexport a module qualified?
09:27:06 <ehird> like
09:27:07 <ehird> module A as B
09:27:24 <opqdonut> yes
09:27:37 <Cale> ehird: If I didn't find something on hackage quickly, I'd find a list somewhere and just parse it.
09:27:44 <ehird> opqdonut: is that the right syntax?
09:27:49 <opqdonut> import Blaa as Quux
09:27:57 <Cale> import A as B
09:27:59 <Cale> or
09:28:03 <Cale> import qualified A as B
09:28:04 <ehird> Cale: While re-exporting.
09:28:07 <Cale> oh
09:28:09 <opqdonut> qualified - as
09:28:10 <opqdonut> yeah
09:28:16 <Cale> Hmm, try it :)
09:28:23 <ehird> Cale: module X as Y didn't work
09:28:25 <Cale> You shouldn't have to use as
09:28:34 <Cale> Just export the name that you imported qualified.
09:28:38 <ehird> Cale: Oh, clever.
09:28:53 <ehird> src/HaskellNomic/Actions/Helpers.hs:5:6:
09:28:53 <ehird>     Warning: `Map' is exported by `module Map' and `Map'
09:28:56 <ehird> why is that a warning? :<
09:29:02 <opqdonut> heh
09:29:07 <ehird> import Data.Map (Map)
09:29:07 <ehird> import qualified Data.Map as Map -- just trying to re-export these
09:29:33 <mercury^> you export Map twice
09:29:45 <mercury^> once as Map.Map
09:29:49 <mercury^> and once as Map
09:30:07 <ehird> mercury^: correct
09:30:16 <ehird> oh, wait
09:30:17 <ehird> I see.
09:30:17 <ehird> Okay.
09:30:22 <ehird> Good thing I don't care. :D
09:30:46 <opqdonut> nothing matters anymore D:
09:31:16 <vixey> opqdonut: :(
09:31:35 <quicksilver> I'm not convinced that exporting qualified identifiers is sane.
09:32:35 <ehird> quicksilver: Yah well.
09:32:39 <ehird> Go and fix it. It's a nomic after all.
09:33:10 <vixey> I think quicksilver mentioned it for your possible benefit :P
09:33:18 <ehird> Benefit, bah.
09:33:22 <ehird> Benefit bach.
09:33:28 <quicksilver> maybe you can convinced me.
09:33:36 <quicksilver> it just off-hand seems like an odd thing to do.
09:33:47 <quicksilver> Mind you I'm not convinced haskell's import/export rules are entirely sane.
09:34:32 <mercury^> now I have no clue what exactly ehird is trying to do, but supposed that you use a qualified module in a lot of files
09:35:12 <mercury^> it saves some typing to import all the modules you need into one module and re-export them into all the modules that use them
09:35:17 <ehird> mercury^: exactly
09:36:21 <ehird> Hm.
09:36:26 <ehird> Now why does lighttpd give a 404 for my fcgi..
09:36:36 <quicksilver> mercury^: yes.
09:36:48 <quicksilver> I think it can be OK in the special case of a 'convenience re-exporter'
09:36:55 <quicksilver> which really does nothing except reexport.
09:37:02 <quicksilver> I think it might be confusing in general.
09:37:46 <ehird> OK, my re-exporter does not actually work.
09:42:21 <ehird> import HaskellNomic.Actions.Helpers
09:42:25 <ehird> but I don't get Map in the namespace.
09:42:29 <ehird> Well
09:42:33 <ehird> I get the Map type.
09:42:36 <ehird> But.
09:42:37 <ehird> src/HaskellNomic/Actions.hs:10:4: Not in scope: `Map.fromList'
09:42:44 <ehird> So mine isn't exporting the module properly. Odd.
09:45:15 <ehird> The two lines relevant:
09:45:16 <ehird> import Data.Map (Map)
09:45:16 <ehird> import qualified Data.Map as Map
09:45:21 <ehird>     , Map
09:45:21 <ehird>     , module Map
09:47:18 <ehird> :\
09:47:59 <masklinn> what's the command line to ask ghc to just run a haskell script (without created an executable binary)?
09:48:01 <mercury^> ehird: uhm, shouldn't Actions.hs import Data.Map as Map?
09:48:06 <masklinn> (creating)
09:48:09 <mercury^> masklinn: runhaskell
09:48:23 <EvilTerran> or runghc
09:48:28 <mercury^> ehird: what all does Actions.hs import?
09:48:57 <masklinn> mercury^, damn, was that simple... thanks a lot
09:49:28 <mercury^> masklinn: but for everything but the most trivial programs it would be faster to write a little script that makes ghc actually compile it, then runs the executable and finally deletes everything :>
09:49:59 <masklinn> mercury^, I'm writing a most trivial program so direct execution is exactly what I need :p
09:50:22 <ehird> mercury^: Actions.hs imports Actions/Helpers.hs, which re-exports Data.Map
09:50:23 <ehird> (as Map)
09:50:47 <mercury^> hmm, let my try something like that here
09:53:13 <twobitwork> so, if ghc has a --make option, what do you use for the equivalent of make clean?
09:54:17 <quicksilver> find . -name "*.o" -or -name "*.hi" -exec rm '{}'
09:55:48 <ehird> mercury^: any ideas?
09:56:20 <mercury^> ehird: trying to figure it out atm
09:56:35 <glguy> rm **/*.(o|hi)
09:57:26 <schme> lambdabot: so, lambdabot, how do I make you print the source off functions like I see you do for other people?
09:57:32 <glguy> ?help src
09:57:32 <schme> of too
09:57:32 <lambdabot> src <id>. Display the implementation of a standard function
09:57:42 <schme> glguy: I'm not talking to you :( :P
09:57:47 <schme> thanks :)
09:57:53 <schme> lambdabot: src error
09:58:21 <schme> I guess I broke it :(
09:58:36 <ehird> mercury^: any luck?
09:58:39 <ehird> schme: @
09:58:40 <ehird> or ?
09:58:44 <ehird> ?src error
09:58:44 <lambdabot> error s = throw (ErrorCall s)
09:58:45 <ehird> @src error
09:58:45 <lambdabot> error s = throw (ErrorCall s)
09:59:00 <schme> aah :)
09:59:07 <mercury^> ehird: hrm, are you sure that re-exports actually are possible?
09:59:11 <mercury^> :>
09:59:27 <hellige> schme: you can also do it privately, if you don't want to fill channel
09:59:36 <ehird> mercury^: Uhh, is the GHC manual lying to me?
09:59:36 <schme> hellige: cools.
09:59:37 <hellige>  /msg lambdabot @src error
09:59:39 <ehird> Of course you can re-export?
10:00:25 <Arnar> hey guys..
10:00:40 <mercury^> ehird: which chapter?
10:01:04 <ehird> mercury^: Hey, don't ask me.
10:01:19 <ehird> but of course you can re-export modules. I mean, that's why there's syntax for it. :P
10:01:19 <Arnar> \n -> (!! n) . transpose     <-- is there a better way (and how do I ask lambdabot)?
10:02:31 <vixey> Arnar: what does it do?
10:02:40 <Saizan> ?pl  \n -> (!! n) . transpose -- fsvo better
10:02:40 <lambdabot> (. transpose) . flip (!!)
10:02:46 <vixey> benny99: hey!
10:02:56 <Arnar> vixey: gives me the n-th column of a [[a]] list (if outer list represents lines)
10:03:04 <vixey> good job earlier with the lambda interpreter thing :)
10:03:09 <vixey> sorry I missed you befor, was asleep
10:03:45 <benny99> vixey: that thing on hpaste was bad :D, and even my current thingy is not correct and I guess not that 'well written'
10:03:47 <mercury^> ehird: I really cannot find that syntax you are referring to in the GHC manual
10:03:48 <vixey> Arnar: well I'd go with
10:03:54 <vixey> map (!!n)
10:04:05 <Arnar> vixey: ah.. of course
10:04:06 <Arnar> :)
10:04:23 <ehird> Someone please tell mercury^ that re-exports are not in fact a figment of my imagination?
10:04:30 <ehird> And that ghc(1) is, in fact, ghc over here?
10:04:33 <Arnar> vixey: knew there was something I wasn't thinking of..
10:04:40 <schme> There should be some wicked ass shell command that just looked source up and handed it to less or what not.
10:04:52 <vixey> Arnar: I like your way on second thoughts, it's actually quite descriptive
10:04:54 <Saizan> you can reexport a module with "module ModuleName" in your export list
10:04:58 <vixey> Arnar: I just didn't see it at first
10:05:44 <Arnar> vixey: descriptive.. true, so is yours :)
10:05:59 <ehird> Saizan: thank you.
10:06:02 <ehird> so why doesn't this work:
10:06:06 <ehird> import qualified Data.Map as Map
10:06:07 <ehird> and in the export list
10:06:09 <ehird> , module Map
10:06:14 <ehird> it compiles fine
10:06:15 <Arnar> vixey: this is a problem that is new to me I've not experienced in other programming languages.. "which should I pick.. they're both elegant!"
10:06:16 <ehird> but if you import it
10:06:18 <Arnar> :)
10:06:19 <ehird> you don't get the Map module
10:06:31 <Saizan> ehird: but you get Data.Map?
10:06:44 <vixey> Arnar: :D
10:06:44 <ehird> Saizan: Dunno. I'll try.
10:07:09 <ehird> Saizan: Nope.
10:07:33 <mercury^> Saizan: I didn't get Data.Map either, nor the names without qualification
10:07:46 <Saizan> ehird: i've already read here that re-exporting doesn't behave well with aliases
10:07:55 <ehird> Saizan: :( can I fix?
10:08:23 <mercury^> Actions.hs:1:16: Module `Helpers' does not export `Map'
10:08:28 <mercury^> Actions.hs:1:16: Module `Helpers' does not export `Data.Map'
10:08:43 <mercury^> Actions.hs:1:16: Module `Helpers' does not export `assocs'
10:08:52 <ehird> mercury^: Well, that's because you fail at importing.
10:09:02 <ehird> You can't specifically import a module.
10:09:05 <ehird> That is re-exported.
10:09:16 <ehird> Anyway, mercury^, re-exporting is definately possible as I do it with Network.CGI.
10:09:24 <Saizan> ehird: if you hack ghc, probably :), however "module Data.Map" works? or is there some problem with qualified too?
10:09:24 <ehird> It just is not working when I rename Data.Map.
10:09:27 <ehird> Which sucks.
10:09:35 <ehird> Saizan: Works, but exports it as Data.Map. Obviously.
10:09:45 <ehird> Renaming it in another module is more typing which is what i'm trying to avoid.
10:10:07 <Saizan> i see
10:10:36 <dmwit> Which is more work: renaming it in another module, or waiting around on IRC for an answer? ;-)
10:10:52 <Saizan> waiting is not work :)
10:11:06 <ehird> dmwit: Long-term
10:11:08 <ehird> :P
10:11:09 <ehird> Anyway.
10:11:15 <ehird> This is a really corner case, a nomic.
10:11:19 <ehird> So.
10:11:33 <Apocalisp> What's the category theory term for sequence?
10:12:30 <Apocalisp> I.e. what kind of morphism is [m a] -> m [a] ?
10:13:08 <dons> ?seen Igloo
10:13:09 <lambdabot> Igloo is in #haskell-soc, #darcs, #ghc and #haskell. I last heard Igloo speak 2h 24m 51s ago.
10:13:10 <Saizan> it's a distribute law between [] and m
10:14:03 <mercury^> dons: you have any idea why ghc optimizes so differently here? http://rohanlean.de/pub/ghc_optimization/
10:14:04 <lambdabot> Title: Index of /pub/ghc_optimazation
10:15:06 <Saizan> Apocalisp: http://en.wikipedia.org/wiki/Distributive_law_between_monads
10:15:16 <dons> mercury^: aren't they quite different implementations?
10:15:17 <Apocalisp> :-) I was just reading tha
10:15:28 <dons> there's a lot of abstraction in there, so I'm not too surprised there are differences
10:15:55 <mercury^> the odd thing is that _4 is so much faster than _2 and _3, although it performs more work
10:16:28 <ehird> Oh wells.
10:19:25 <dolio> dons: If I were going to put some of my sorting stuff into uvector, where would be a good place to put it in the hierarchy?
10:19:36 <dolio> It potentially contains several modules.
10:20:23 <dons> dolio: what kind of functions do they provide?
10:20:30 <dons> sort :: UArr a -> UArr a ?
10:20:45 <dolio> So far, MUArr a s -> ST s ()
10:21:05 <dons> right, i want to start on a separate modules for MUArr functions
10:21:15 <dons> to go along side direct UArr, and streamed UArr things
10:21:21 <dolio> I've got introsort, and I've been working on timsort.
10:21:36 <dons> dolio: i'd wait till you've got something you trust
10:21:39 <dons> then we can add it.
10:21:48 <dons> i won't change the representationns now
10:21:55 <dolio> All right.
10:22:17 <dolio> I was thinking that specializing the algorithm based on the representation could be fruitful, too.
10:22:50 <schme> This real world haskell book seems quite nice!
10:23:00 <Arnar> replicate 3 (newTVar 1)   <- will this give me three distinct TVars, or just three references to the same one?
10:23:05 <dolio> Like, sorting booleans you could do tricks to finish faster than any general sort.
10:23:19 <dolio> Although, I don't know how common that is.
10:23:24 <ehird> Arnar: Neither.
10:23:36 <Arnar> ehird: oh?
10:23:41 <ehird> Arnar: It'll give you 3 monadic actions which when executed will create a tvar.
10:23:42 <schme> I'm a bit confused about the scopeing in haskell though. It doesn't seem to mention much about it .(
10:23:49 <ehird> schme: Static, lexical.
10:23:55 <schme> ehird: great!
10:24:02 <Arnar> ehird: ah.. so each action will create one tvar
10:24:11 <ehird> Arnar: what is the type of newTVar?
10:24:20 <ehird> here, let me tell you
10:24:21 <ehird> :t newTVar
10:24:23 <lambdabot> Not in scope: `newTVar'
10:24:28 <ehird> ok, go to hell lambdabot
10:24:29 <Arnar> :t Control.Concurrent.newTVar
10:24:31 <lambdabot> Not in scope: `Control.Concurrent.newTVar'
10:24:34 <Arnar> :t Control.Concurrent.STM.newTVar
10:24:36 <lambdabot> Couldn't find qualified module.
10:24:41 <ehird> Arnar: Tell me and I'll explain.
10:24:43 <Arnar> :t GHC.Conc.newTVar
10:24:45 <lambdabot> forall a. a -> GHC.Conc.STM (GHC.Conc.TVar a)
10:24:48 <ehird> Aha.
10:24:49 <ehird> :t replicate
10:24:51 <lambdabot> forall a. Int -> a -> [a]
10:24:53 <ehird> So.
10:25:01 <ehird> Arnar: Think about it.
10:25:03 <ehird> You get:
10:25:14 <ehird> [GHC.Conc.STM (GHC.Conc.TVar Integer)]
10:25:21 <ehird> (Really stuff with Num but let's say Integer for simplicity)
10:25:27 <ehird> Arnar: So, those are just opaque monadic actions.
10:25:28 <Arnar> sure
10:25:29 <ehird> :t sequence
10:25:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:25:38 <Arnar> ah..
10:25:40 <ehird> Arnar: sequence $ replicate 3 $ newTVar 1
10:25:48 <ehird> gets you a list of TVars inside the STM monad.
10:25:51 <ehird> tadaa
10:25:55 <Arnar> that's just what the doctor ordered :)
10:26:01 <Arnar> thanks :)
10:26:15 <Apocalisp> Is there a function that does the opposite of sequence? m [a] -> [m a]
10:26:39 <Arnar> Apocalisp: doesn't that mean you are "unwrapping" the monad?
10:26:44 <Apocalisp> yea
10:26:50 <mercury^> Apocalisp: doesn't seem possible for every monad
10:26:51 <Deewiant> @ty liftM (Prelude.map return)
10:26:53 <lambdabot> forall a (m :: * -> *) (m1 :: * -> *). (Monad m1, Monad m) => m1 [a] -> m1 [m a]
10:27:04 <ehird> Apocalisp: Well, shure...
10:27:06 <Deewiant> that's the closest you can get in general
10:27:17 <ehird> Apocalisp: You'll have to get it in m though.
10:27:20 <ehird> :t map return
10:27:21 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Functor f, Monad m) => f a -> f (m a)
10:27:26 <dmwit> Arnar: See also: replicateM
10:27:27 <ehird> Heh.
10:27:30 <ehird> Opinionated lambdabot!
10:27:39 <Deewiant> ehird: I already did that.
10:27:53 <Arnar> :t replicateM
10:27:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
10:28:01 <Arnar> dmwit: ah.. cool, thanks
10:28:08 <Arnar> @src replicateM
10:28:08 <lambdabot> replicateM n x = sequence (replicate n x)
10:28:11 <Arnar> :)
10:28:17 <dmwit> =)
10:30:13 <Arnar> > replicateM 2 $ replicateM 2 $ Just 1
10:30:15 <lambdabot>  Just [[1,1],[1,1]]
10:30:20 <Arnar> excellent
10:30:30 <gubagem> whats the dollar sign mean
10:30:45 <Arnar> gubagem: "apply the function on the left to the argument on the right"
10:30:50 <Arnar> gubagem: could have written:
10:31:00 <Arnar> > replicateM 2 (replicateM 2 (Just 1))
10:31:01 <lambdabot>  Just [[1,1],[1,1]]
10:31:10 <Arnar> :t $
10:31:12 <lambdabot> parse error on input `$'
10:31:16 <Arnar> :t ($)
10:31:17 <mercury^> :t ($)
10:31:18 <lambdabot> forall a b. (a -> b) -> a -> b
10:31:19 <lambdabot> forall a b. (a -> b) -> a -> b
10:31:25 <gubagem> oh some syntatic sugar
10:31:40 <Arnar> gubagem: actually it's a proper function..
10:31:47 <Arnar> but yes, I guess it is often used as sugar
10:31:49 <mercury^> yes, you can use it in more places
10:31:57 <mercury^> in sections for example
10:32:08 * gubagem is slowly learning...
10:32:19 <mercury^> map ($ b) [id, transpose, ..]
10:33:04 <Deewiant> @src ($)
10:33:04 <lambdabot> f $ x = f x
10:33:09 <Arnar> > map ($ 10) [id, +2, *8]
10:33:10 <lambdabot>  Parse error at "+2," (column 17)
10:33:21 <Arnar> > map ($ 10) [id, (+ 2), (* 8)]
10:33:22 <lambdabot>  [10,12,80]
10:34:13 <gubagem> id=identity??
10:34:17 <Deewiant> @src id
10:34:17 <lambdabot> id x = x
10:34:17 <Arnar> yes
10:36:10 <orphi> @seen dcoutts
10:36:10 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #haskell-blah. I last heard dcoutts speak 19h 17m 23s ago.
10:39:07 <dcoutts_> @yarr!
10:39:07 <lambdabot> Well Ahoy! thar.
10:39:10 <dcoutts_> hia orphi
10:39:24 <orphi> lol @ dcoutts
10:39:27 <orphi> hi
10:39:49 <orphi> gtk2hs won't build for me. it says I'm not valid. :-(
10:39:52 <ehird> @yaaaaaaaaaaaaaarrrrrrrrr
10:39:52 <lambdabot> Unknown command, try @list
10:40:08 <dcoutts_> @arr?
10:40:09 <lambdabot> Yeh scurvy dog...
10:40:14 <ehird> @arrrrrrrrrrrr
10:40:14 <lambdabot> Unknown command, try @list
10:40:17 <ehird> Stoopid
10:40:24 <dcoutts_> heh heh
10:40:30 <czakey> @botsnack
10:40:30 <lambdabot> :)
10:40:39 <dcoutts_> orphi: what does it complain about?
10:41:05 <orphi> checking build system type... Invalid configuration `i686-pc-linux-': machine `i686-pc-linux' not recognized
10:41:56 <dcoutts_> hmm
10:42:43 <dcoutts_> orphi: were you using a tarball or did you have to run autoconf?
10:42:58 <orphi> I grabbed the tarball from the homepage.
10:43:14 <dcoutts_> ok
10:43:58 <orphi> I'm pretty sure I did this before and it worked. [I recently upgraded to a newer version of SuSE.]
10:44:29 <ehird> so ... a Nomic monad which is loads of stuff like databases & co layered on top of IO, and an App monad which is a CGIT of that
10:44:31 <ehird> good haskellnomic model y/n?
10:44:57 <ehird> (The actual nomic actions are almost always going to involve databases or files or similar, and the rest are covered by a pure function, so a 'dirty' monad like Nomic seems the best way to go)
10:45:07 <dcoutts_> orphi: so in the gtk2hs dir, run sh config.guess, what does it report?
10:45:15 <kpreid> I am suspicious of stuffing everything about an application in one monad type..
10:45:34 <ehird> kpreid: I don't really see a better model for this
10:45:50 <orphi> dcoutts_: i686-pc-linux-
10:46:16 <orphi> aww! my pizza is burnt. :-S
10:46:21 <dcoutts_> orphi: one hack is to use ./configure --build=i368-pc-linux or something like that
10:46:49 <dcoutts_> orphi: I suspect we have too old a version of config.guess
10:46:55 <orphi> dcoutts_: what does it need the info for anyway?
10:47:12 <dcoutts_> orphi: I dunno really, it's something that autoconf always checks
10:47:17 <ehird> Oh wells
10:47:26 <ehird> I'll just do it :-P
10:48:41 <orphi> dcoutts_: "no acceptable C compiler found in path"?
10:48:49 <orphi> dcoutts_: oh, wait, do I have gcc yet? hmm...
10:50:10 <dcoutts_> orphi: you'll need gcc
10:50:28 <dcoutts_> orphi: and ghc obviously (which should depend on gcc)
10:50:52 <ehird> Hm
10:50:58 <ehird> If I have a custom cgi handler how do I use runCGI and friends?
10:50:59 <orphi> dcoutts_: that's what I'm thinking - I definitely have GHC [6.8.2], so I'm not sure how I wouldn't have gcc... but let me check.
10:51:11 <ehird> do I write a CGI CGIResult which does the 'run' stuff to get a CGI out of it?
10:51:18 <ehird> Or do I do the run outside of it?
10:51:51 <ehird> that is, should my cgi main be a CGI CGIResult or an App CGIResult?
10:52:46 <orbitz> ehird: start your haskell tutorial?
10:53:03 <orphi> dcoutts_: well I'll be damned... no gcc installed. go figure...
10:53:19 <dcoutts_> orphi: I gotta go, good luck :-)
10:53:32 <orphi> kk, ty ;-)
10:57:28 <jgrimes> how can you derive instances of Data for non-haskell 98 constructors?
10:57:43 <orphi> @yarr
10:57:43 <lambdabot> I'll keel haul ya fer that!
10:58:27 <vixey> writing parsers is very unfun
10:58:41 <vixey> or at least writing ones you actually need
10:58:42 <ehird> vixey: totally
10:59:00 <geezusfreeek> yeah, the fun parsers are the most useless :(
11:00:06 <ehird> @hoogle FilePath -> IO [String]
11:00:07 <lambdabot> No matches, try a more general search
11:00:10 <ehird> @hoogle FilePath -> IO [FilePath]
11:00:11 <lambdabot> System.Directory.getDirectoryContents :: FilePath -> IO [FilePath]
11:00:13 <ehird> Yay
11:00:25 <vixey> http://people.cs.uu.nl/andres/LambdaPi/prelude.lp
11:00:45 <orphi> @vixen hello
11:00:46 <lambdabot> how're you?
11:01:03 <dons> dcoutts_: did you know gcc -O3 can resolve some of the computed jumps in ghc's backedn?
11:02:35 <dons> actually, even -O2 does it.
11:02:45 <ehird> Hmm.
11:02:55 * ehird finds out how to stop people browsing in PLACES THEY SHOULDN'T
11:02:57 <ehird> (Below cwd.)
11:03:13 <orphi> dons: how on earth did you work that out? you scary, scary person. ;-)
11:03:48 <dons> reading assembly :)
11:04:09 <orphi> dons: I bow to your superior 31337-ness
11:04:23 <dons> well, i'm writing a blog post about how to do it.
11:04:30 <dons> so everyone can share the goodness
11:04:37 <orphi> this is most optimal.
11:05:05 <orphi> I didn't actually know you had a blog, but somebody else found a link for me the other day
11:05:15 <orphi> "it has a flavour", shall we say...
11:05:24 <dons> i hope that's good
11:05:29 <dons> :)
11:05:49 <orphi> yeah, it's good.
11:06:18 <ehird> dons has a flavour. it is haskell.
11:06:31 <ehird> DONS IS HASKELL (wake up sheeple?)
11:06:38 <orphi> lol!
11:08:04 <Vulpyne> Soylent green is people. Peeeooooppppllleeee!
11:08:10 <schme_> ok.
11:08:13 <twobitwork> yum
11:08:30 <twobitwork> can you do pattern matching in a do block?
11:08:42 <vixey> twobitwork: yeS!
11:08:53 <Vulpyne> With let or <- or case, yeah.
11:09:00 <orphi> dons: IIRC, it was the one about "Haskell is really a strict language". But I found several posts interesting...
11:09:00 <vixey> Foo Bar (b,Quux) <- monadicCalulation
11:09:03 <schme_> I just hit chap 5 of the real world haskell book here and it seems I am starting to devolope more and more of a dislike of haskell for each chapter I read. :(
11:09:16 <Vulpyne> Runtime error if it fails to match though.
11:09:19 <schme_> I need another book.
11:09:21 <mux> twobitwork: and in case the pattern matching fails, it'd call the "fail" method of the Monad that was being used
11:09:27 <mux> Vulpyne: not ncessarily
11:09:34 <twobitwork> er... I mean of the "f Foo = ..." "f (Bar x) = ..." variety
11:09:37 <Vulpyne> Hmm, yeah, you are correct.
11:09:42 <vixey> twobitwork: yes
11:09:43 <dons> schme_: interesting. any thoughts why?
11:09:45 <Botje> schme_: read it in reverse order!
11:09:47 <Deewiant> > do { (x,y) <- return (1,2); return (y,x) } $ id
11:09:48 <lambdabot>  (2,1)
11:09:50 <mux> @src [] fail
11:09:51 <lambdabot> fail _      = []
11:09:54 <twobitwork> vixey: how?
11:09:58 <schme_> dons: I am wondering the same meself!
11:10:06 <schme_> Botje: Haha :)
11:10:13 <dons> schme_: if you could work out why, that would be really valuable information for the authors.
11:10:17 <ehird> schme: what bit is making you hate it?
11:10:25 <ehird> haskell is painful at first but it's kinda like this
11:10:29 <schme_> dons: I thought so too. I just can't figure out what it is.
11:10:30 <ehird>  __________________________________________
11:10:30 <ehird> |
11:10:31 <schme_> ehird: hahaha.
11:10:37 <ehird> learning curve!
11:10:40 <schme_> ehird: I have no idea what bit it is. I wish I did.
11:10:41 <ehird> if you could call it that
11:10:48 <gubagem> you call that a curve? this is a curve ~~~~~~~~~~~~
11:11:00 <ehird> So how do you pepole pronounce haskell
11:11:02 <gubagem> well i guess yours is more continous
11:11:02 <schme_> booooooooooooooo
11:11:04 <ehird> Me: Hask-ull
11:11:11 <schme_> Hask-ull ya
11:11:16 <ehird> But with a slightly higher u than normal.
11:11:21 <gubagem> s/pascal/hascal
11:11:22 <schme_> same
11:11:22 <ehird> So it has a hint of Hask-ell
11:11:24 <orbitz> ha-ask-el
11:11:37 <gubagem> ha-ask-hell
11:11:43 <ehird> h-as-kell!
11:11:55 <ehird> Hashull. Silent k!
11:11:58 <schme_> On part that I surely hate about this chapter 5 is the python code slammed right at the top. That's for sure. :)
11:12:03 <Vulpyne> SPJ says it like "Haskl".
11:12:04 <schme_> one
11:12:15 <schme_> (I don't own a python book)
11:12:25 <ehird> schme_: Wtf? Link?
11:12:25 <gubagem> python is mad simple
11:12:35 <Vulpyne> Python's pretty close to readable pseudocode.
11:12:42 <Vulpyne> Er, executable.
11:12:49 <vixey> Vulpyne: hardly
11:12:49 <orphi> lmao!
11:12:50 * gubagem agrees 100%
11:12:54 <schme_> ehird: http://book.realworldhaskell.org/beta/fp.html
11:12:54 <lambdabot> Title: Chapter 5. Functional programming
11:12:57 <saml> pronunciacing haskell is bottom
11:13:01 <schme_> gubagem: I'm sure it is if you know python :P
11:13:11 <vixey> Vulpyne: ad-hoc modifications to Pascal suit much better imo
11:13:19 <vixey> (or ALGOL)
11:13:32 <ehird> what's wrong with english?
11:13:40 <vixey> It's not formal
11:13:41 <orphi> ehird: too ambiguous.
11:13:42 <ehird> Print "Hello, world!\n" 3 times.
11:13:43 <Vulpyne> Eh, I don't think I'd consider Pascal closer.
11:13:48 <ehird> orphi: we want pseudocode though
11:14:07 <orphi> ehird: English is too pseudo and not enough code. ;-)
11:14:22 <Vulpyne> There's too much ambiguity in english for it to really be good as pseudocode, in my opinion.
11:14:34 <orphi> I still like the quote I saw somewhere: "Haskell isn't programming. It's cheating! You just write what you want and it DOES it!"
11:14:41 <vixey> orphi :D :D
11:14:50 <schme_> also I think specifically the chapter 5 bores me to death 'cause it just seems to be listing functions.
11:14:55 <vixey> @quote cheating
11:14:55 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
11:15:03 <vixey> @remember <orphi> I still like the quote I saw somewhere: "Haskell isn't programming. It's cheating! You just write what you want and it DOES it!"
11:15:03 <lambdabot> Done.
11:15:17 <ehird> Hmm.
11:15:29 <twobitwork> ehird: I have the number 3. if the number is less than 4 then if the number is greater than 2 then print "its 3" otherwise if the number is less than 2 print "not three" otherwise print "wtf?"
11:15:31 <ehird> If I have a FilePath, canonicalized.
11:15:36 <ehird> How can I tell if it is below the current directory?
11:15:44 <ehird> I don't want people using haskellnomic to snoop ;)
11:15:53 <mux> ehird: isPrefixOf ?
11:16:00 * orphi is now attempting to compile Gtk2hs
11:16:07 <Vulpyne> It would have .. components or a leading / I guess.
11:16:19 <ehird> twobitwork: N = 3. If N < 4 and N>2 print "its 3". Otherwise, if N<2 print "not three". Otherwise, print "wtf?"
11:16:23 <ehird> mux: Well, I guess.
11:16:26 <mux> if by canonicalized you mean without double slashes, .., and an absolute path
11:16:27 <Vulpyne> You could tell if it's potentially below the current directory.
11:16:35 <ehird> mux: Just whatever canonicalizePath does it.
11:16:39 <orphi> ehird: I think there's a library called FilePath or something for parsing filenames in a system-independant way...
11:16:42 <ehird> Vulpyne: Yeah, .. is the thought
11:16:52 <ehird> orphi: Using System.Directory, I am
11:16:54 <mux> > canonicalizePath "/foo/bar/../baz"
11:16:55 <lambdabot>   Not in scope: `canonicalizePath'
11:17:02 <ehird> mux: lern2System.Directory
11:17:03 <mux> > System.FilePath.canonicalizePath "/foo/bar/../baz"
11:17:04 <twobitwork> ehird: there have been numerous attempts at creating english like languages, all have failed
11:17:04 <lambdabot>   Not in scope: `System.FilePath.canonicalizePath'
11:17:11 <ehird> twobitwork: So? Use English.
11:17:45 <twobitwork> er, english like programming languages
11:18:12 <schme_> Why would anyone want that though ? :)
11:18:17 <mux> ehird: you'd better look in System.FilePath, there are probably more appropriate functions there
11:18:40 <ehird> Yeah, I am
11:18:41 <skorpan> ruby is the one programming language that has come closest to natural languages that i have sen
11:19:09 <orphi> skorpan: I just round Ruby really ad-hoc and lacking a clear structure.
11:19:11 <vixey> skorpan: what about lisp?
11:19:20 <IsoPallo> It could me fun programming in some of the uralic languages :)
11:19:23 <orphi> ...and Lisp is just ugly. :-S
11:19:34 <vixey> It's seems to lot closer to natural language than ruby to me
11:19:37 <orphi> "cdr", anyone? >_<
11:19:46 <geezusfreeek> Ruby is ad hoc precisely because it is meant to allow for whatever style is most natural for you
11:20:00 <geezusfreeek> i wish it had _more_functional features though
11:20:04 <IsoPallo> No conjunctions, no subordination, no words doing :)
11:20:06 <orphi> see, now to me that just makes it confusing...
11:20:08 <IsoPallo> +for
11:20:17 <mux> I'd rather see ruby getting faster
11:20:35 <twobitwork> ruby isn't designed for being fast
11:20:51 <mux> damn sure it isn't!
11:20:55 <schme_> orphi: My god lisp is not ugly :P
11:21:03 <mux> unfortunately, sometimes people need to *run* code :-)
11:21:11 <twobitwork> lisp is only ugly until you learn to use it
11:21:18 <orphi> schme_: is beauty not within the eye of the beholder?
11:21:32 <schme_> orphi: Not in this case! :P
11:21:44 <skorpan> mux: my bsc thesis was written completely in ruby :P
11:21:54 <orphi> I just find having to memorise archaic terms like "cdr" to be very irritating.
11:22:20 <mrd> then use "rest"
11:22:22 <twobitwork> orphi: the cdr/car thing is a bit unfortunate, but that's one of the few examples
11:22:30 <mux> they are supposed to improve the situation for ruby 2.0 though, I'm just hoping for that to happen, so that it's realistically usable in more production environments
11:22:32 <vixey> twobitwork: it's fine
11:22:34 <ehird> @hoogle (Monad m) => m Bool -> m a -> m a -> m a
11:22:35 <lambdabot> No matches, try a more general search
11:22:36 <twobitwork> and most most scheme compilers have first/rest defined
11:22:37 <ehird> :(
11:22:40 <Apocalisp> Memorizing cdr? It's three letters!
11:22:40 <ehird> :t (>>= when)
11:22:42 <lambdabot> forall (m :: * -> *). (Monad m) => (m () -> Bool) -> m () -> m ()
11:22:48 <mrd> the continued existence of "car/cdr" is due to the lack of satisfactory alternative names.  please come up with some.
11:22:53 <schme_> I can point to a couple of things in Common Lisp that is worse that car/cdr ;)
11:23:00 <orphi> yeah, but there's car and cdr, and you have to memorise which is which.
11:23:00 <schme_> pathnames, anyone?
11:23:02 <twobitwork> mrd: other than first/rest?
11:23:03 <vixey> mrd: the continued use is because they're fine
11:23:04 <Deewiant> caddadr
11:23:07 <ehird> :t (\b t e -> b >>= \v -> when v t e)
11:23:09 <lambdabot>     Couldn't match expected type `m b' against inferred type `()'
11:23:09 <lambdabot>       Expected type: t -> m b
11:23:09 <lambdabot>       Inferred type: t -> ()
11:23:14 <orphi> plus there's all the "shortcut" things like... what he just said. lol
11:23:15 <ehird> :t (\b t e -> b >>= \v -> if v then t else e)
11:23:17 <mrd> twobitwork: that makes sense in the context of lists, but cons cells can be [ab]used for more than that
11:23:17 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
11:23:22 <Apocalisp> orphi: car and cdr, in that order.
11:23:25 <Apocalisp> easy
11:23:27 <ehird> @pl (\b t e -> b >>= \v -> if v then t else e)
11:23:27 <lambdabot> (. (flip . flip if')) . (.) . (>>=)
11:23:30 <ehird> heh
11:23:39 <ehird> is this .. mif not in the stdlib somewhere?
11:23:40 <ehird> seriously?
11:23:50 <orphi> you're talking to somebody who can't remember whether to use a left or right fold :-P
11:24:10 <mrd> fst, snd implies that there's a "thd" which there isn't
11:24:17 <mrd> left, right implies directionality
11:24:24 <mux> fst and snd act on pairs
11:24:33 <orphi> besides, Lisp isn't statically-typed, which I highly dislike, and Lisp programmers seem to think self-modifying code is a *good idea*...
11:24:40 <mux> there are no functions in the base for triples, that I know of
11:24:41 <mrd> frankly, the nonsensicality of car, cdr makes it better than something with connotations
11:24:48 <idnar> I don't even know what thd would mean
11:24:57 <skorpan> idnar: third
11:25:01 <vixey> thrd (_,_,e) = e
11:25:10 <Apocalisp> orphi: LISP isn't statically anything. :-)
11:25:11 <idnar> yeah, but that would mean fst and snd operated on triples
11:25:15 <mux> the fact that there is fst and snd certainly doesn't imply any thd, given their tipes
11:25:15 <twobitwork> vixey: that implies that: fst
11:25:18 <mrd> also, there is first, second, third, fourth, already defined for basically (!!0) (!!1) ...
11:25:22 <mux> :t fst
11:25:24 <lambdabot> forall a b. (a, b) -> a
11:25:28 <idnar> which a) they don't, b) if you extend that train of thought, then the functions would have to operate on tuples of infinite size
11:25:32 <tromp> fst doesn't work on triples
11:25:44 <vixey> frst :: (a,b,c) -> a
11:25:50 <vixey> scnd :: (a,b,c) -> b
11:25:56 <mux> ouch
11:26:04 <dons> http://reddit.com/info/6jjhg/comments/ enjoy
11:26:08 <tromp> great, a new spelling for each n-tuple
11:26:14 <mux> we already have first and second for arrows, plus fst and snd for tuples, let's leave it to that
11:26:19 <dons> how to write Haskell that's as fast as gcc -O2
11:26:31 <dons> enjoy, peoplez!
11:26:35 <idnar> :t first
11:26:37 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
11:26:38 <Apocalisp> thanks don!
11:26:57 <mrd> there are much more interesting things to complain about in lisp than car, cdr.
11:27:17 <schme_> orphi: static typing is part of what I am really disliking about haskell. :)
11:27:19 <orphi> hmm, my poor little laptop... compiling Gtk2hs and downloading stuff and chatting on IRC at the same time really is too much for it :(
11:27:28 <orphi> schme_: er... why?
11:27:40 <vixey> schme_: try to start with a blank page
11:27:41 * Apocalisp can't help thinking of Don S as "the Don: il capo del tutti capi"
11:27:48 <schme_> vixey: huh?
11:27:56 <vixey> schme_: when learning new languages
11:27:57 <schme_> orphi: Izz a bit annoying to me :)
11:28:15 <orphi> schme_: "lzz"?
11:28:20 <ehird> orbitz: i
11:28:21 <ehird> izz
11:28:23 <ehird> orphi
11:28:34 <schme_> vixey: I can't start with a blank page. And to be honest I have not found static typing enjoyable in other languages.. so I dunno if a blank page would help much :)
11:28:50 <schme_> orphi: "is"
11:29:00 <orphi> schme_: ah, ok.
11:29:02 <orbitz> ehird: hi
11:29:08 * orphi mutters something about serif typefaces
11:29:09 <schme_> vixey: (eg. SML and ocaml)
11:29:46 <schme_> orphi: I think it's jus a matter of taste there. Like you don't like the lack of static typing in that other language.
11:29:48 <orphi> schme_: personally, what is annoying to *me* is running a large, complex program and watching it crash with an incomprehensible error message because I accidentally missed out an extra level of indirection somewhere.
11:29:59 <schme_> :)
11:30:11 <schme_> Yes.. that sounds like a bitch :)
11:30:32 <orphi> happens in Smalltalk all the time... and JavaScript... and probably Lisp if I had ever tried to use it...
11:30:38 <Vulpyne> ehird: http://hpaste.org/7638
11:30:50 <schme_> Btw is there some good tutorial for web programming with haskell? the real world haskell book seems not to have that chapter yet.
11:31:04 <orbitz> schme_: to be fair, how long have ou been programming in haskell?
11:31:13 <schme_> orbitz: a couple of days
11:31:32 <schme_> orbitz: why?
11:31:33 <orbitz> that's not that long, if you are coming from the rest of the world of lagnuages
11:31:52 <Apocalisp> schme_: Keep at it. You will learn to love the type system.
11:32:01 <schme_> Dunno what the rest of the world of languages is though.
11:32:09 <schme_> Apocalisp: That is what I am doing. keeping at it.
11:32:10 <orbitz> everything not-haskell
11:32:10 <Vulpyne> Imperative languages.
11:32:18 <Vulpyne> C, Pascal, Python, Ruby, etc.
11:32:29 <schme_> Vulpyne: I tend to very much avoid imperative coding though :)
11:32:34 <schme_> but anyway.
11:32:36 <orbitz> i doubt it
11:32:42 <orbitz> or atleast, not as much aso you probably think so
11:32:42 <geezusfreeek> any language that doesn't have hindley-milner type inferences
11:32:45 <schme_> orbitz: You doubt what?
11:32:52 <geezusfreeek> *inference
11:33:04 <schme_> Anyway. where is the web programming tutorial then?
11:33:20 <Apocalisp> The winning idea is that programs have their specification declared (implicitly, sometimes) in their types.
11:34:05 <ehird> > filter odd [2,3]
11:34:06 * orphi returns
11:34:11 <lambdabot>  [3]
11:34:17 <geezusfreeek> i heard recently that even perl 6 will have some degree of hendley-milner type system... i don't really understand how it applies to perl at all though
11:34:29 <Vq^> happs.org seems to be down :(
11:34:31 <orphi> does anybody *else* think "filter" should be "select", and filter p = select (not . p) ?
11:34:33 <vixey> > (1e9*(1e9+1))/(1e9*2)
11:34:35 <lambdabot>  5.000000005e8
11:34:39 <vixey> dons: :P
11:35:03 * orbitz can enver remember if filter is goign to keep those that are true or remove them
11:35:03 <vixey> very nice article though
11:35:06 <dons> vixey: i think i made that point.
11:35:11 <orbitz> you'd think it would remove those that are true
11:35:15 <dons> vixey: "lso, I don't care about smarter ways to implement this -- we're simply interested in understanding the compiler transformations involved in the actual loops involved."
11:35:16 <maltem> orphi, once you start that, they should be called select and reject
11:35:20 <QtPlatypus> geezusfreeek: perl6 is statically typed
11:35:23 <RayNbow> @djinn (a -> (b -> c)) -> (b -> (a -> c))
11:35:23 <lambdabot> f a b c = a c b
11:35:32 <orphi> maltem: well, it worked for Smalltalk...
11:35:33 <vixey> dons: yeah I think the using indices directly is cheating
11:35:39 <mux> QtPlatypus: no it's not, it just got optional types
11:35:42 <vixey> dons: but otherwise really interesting
11:36:02 <maltem> orphi, I think "filter" is FP tradition
11:36:03 <orphi> orbitz: I agree. ;-)
11:36:11 <schme_> Well I apologize if I upset you lot!
11:36:15 <orbitz> schme_: haskell certainly isn't for everyone, but i think a few days probably isn't enough to get a well rounded feel for it
11:36:39 <dons> ?users
11:36:39 <lambdabot> Maximum users seen in #haskell: 463, currently: 434 (93.7%), active: 31 (7.1%)
11:37:03 <ehird>     Warning: `liftIO' is exported by `module Network.CGI' and `module Control.Monad.Trans'
11:37:06 <ehird> Beh
11:37:13 <orbitz> schme_: and what i meant before was many people write code in those other 'functional' languages in a much more imperative way than they realize, and haskell doesn't let you do that, so it's a bgiger jump than many people realize
11:37:13 <Vulpyne> My advice is to dabble for a couple years and then dive in and force yourself to actually write some applications.
11:37:18 <ehird> yay fixed
11:37:20 <schme_> orbitz: No, I think I came across wrong there. For now I am finding the static typing very annoying. It brings back memories of SML and OCaml.. which I both disliked severly for the static typing. I am however writing a few apps in this and I will see how it works out.
11:37:50 <orbitz> schme_: really? I enjoy Ocaml in the most part due to its static typing. I'm curious, what problem do you have with it?
11:37:57 <mux> schme_: how is static typing being annoying for you?
11:38:05 <schme_> I have no idea.
11:38:17 <schme_> I generally don't have much reason for my irrational tastes :)
11:38:34 <schme_> But more to the point:where is ze web programming with haskell tutorial!=
11:38:35 <schme_> ?
11:38:35 <vixey> schme: You don't have to write the types down in your code
11:38:42 <orphi> 10 minutes of my CPU being pegged at 100% utilised, and Gtk2hs is still not yet compiled... ;-)
11:39:07 <Vulpyne> What sort of web programming? CGI?
11:39:19 <schme_> Ya CGI.
11:39:23 <dcoutts> orphi: a full build with optimisation takes about 30min
11:39:32 <schme_> I guess I could just make it spit out xml.
11:39:35 <dcoutts> orphi: a fast build without optimisation is ~5min
11:39:41 <ehird> :t all
11:39:42 <Vulpyne> http://www.haskell.org/ghc/docs/latest/html/libraries/cgi/Network-CGI.html
11:39:43 <lambdabot> http://tinyurl.com/yq53cj
11:39:43 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:39:50 <ehird> cgi is fail.
11:39:57 <orphi> dcouts: #1: oh, you're back. :-) #2: my laptop is slow.
11:39:57 <mux> there's also Network.FastCGI
11:39:58 <Vulpyne> It's what he asked for. :)
11:40:06 <ehird> Vulpyne: :)
11:40:16 <schme_> What?
11:40:17 <orphi> AMD Mobile Athlon XP 1400+
11:40:23 <schme_> It's not what I asked for :(
11:40:27 <schme_> oh.
11:40:32 <Vulpyne> CGi isn't what you asked for?
11:40:32 <schme_> I made a typo. nevermind.
11:40:40 <schme_> NO it seems I did.
11:40:46 <schme_> so it's ok.
11:40:46 <lilac> dons: typo: "original posters unpredictably" -> "original poster's unpredictability"
11:40:54 <Vulpyne> But not what you actually want? What do you want? :)
11:40:54 <orbitz> schme_: i think variants (in haskell) make any benefit dynamic typing preivious had disappear for the most part.  in languages like C++/java that kind of stuff i hard but variants make it easy to care less
11:40:58 <dons> lilac: thanks
11:41:19 <schme_> orbitz: What kind of stuff?
11:41:25 <Vulpyne> There are frameworks for it also, like hAPPs, but it seemed kind of scary.
11:41:41 <schme_> Vulpyne: Mostly generating html and xml actually.
11:42:07 <schme_> orbitz: I find C++ and Java more annoying than static typing so it all sounds good ;)
11:42:12 <orbitz> schme_: handling multiple types when you aren't erally sure what you'l lbe getting
11:42:28 <schme_> ok.
11:42:29 <Vulpyne> Well, there's Text.XHtml.
11:42:45 <Vulpyne> If you haven't already, looking at GHC's library list can be ver yhelpful.
11:42:48 <Vulpyne> It includes a lot of stuff.
11:42:59 <schme_> Where's that?
11:43:13 <Vulpyne> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
11:43:16 <schme_> Ugh.
11:43:21 <schme_> Is there some tarball?
11:43:52 <Vulpyne> Probably.
11:44:03 <orphi> schme_: on Windoze, the docs get installed along with GHC. Don't know about other platforms...
11:44:04 <schme_> hmmm
11:44:07 <schme_> ech I'll just curl it.
11:44:16 <Vulpyne> I've always just used the online docs.
11:44:29 <schme_> Ya. problem with online is it sucks when you have no online :)
11:44:42 <Vulpyne> *gasp* There are people not online?
11:44:47 <schme_> Uh yes.
11:45:01 <schme_> schme most of the time for example
11:45:10 <Vulpyne> :(
11:45:21 <schme_> nawww!
11:45:27 <Vulpyne> I'm just giving you a hard time.
11:45:28 <schme_> why the sad panda ?:P
11:45:37 <schme_> not doing such a good work at it there.
11:45:37 <schme_> hmm
11:45:56 <ehird> schme_: Use fastcgi.
11:46:04 <ehird> s/Network.CGI/Network.FastCGI
11:46:11 <ehird> s/runCGI/runFastCGI
11:46:13 <ehird> tada
11:46:33 <schme_> TADA
11:46:40 <Vulpyne> sed is hard. Let's go shopping!
11:47:35 <schme_> Hmm.
11:48:35 <lilac> dons: nice article, as ever. i could read your blog all day. you could be clearer earlier on that you mean tail recursion rather than simply recursion.
11:48:37 <schme_> oh
11:49:15 <schme_> I think me main problem with haskell is that it forces a certain way of doing things on me. :)
11:49:46 <Botje> no, it just makes it real hard to make imperative code pretty
11:49:51 <Botje> whereas functional code is pretty by default
11:49:59 <schme_> Ya. That's kinda shitty though.
11:50:05 <schme_> in my book anyway .)
11:50:13 <lilac> Botje: I have hundreds of lines of rubbish Haskell I wrote last weekend that begs to differ ;-)
11:50:22 <orphi> schme_: come to the light side. ;-)
11:50:23 <schme_> (mine too)
11:50:27 <schme_> orphi: What light side?
11:50:49 <orphi> schme_: in Haskell, imperative code is often considered "the dark side", so by duality... ;-)
11:50:57 <tieTYT> is there a haskell ide?
11:51:01 <tieTYT> and as a newb, should I use it?
11:51:06 <schme_> Well isn't imperative code considered the dark side in most languages though?
11:51:09 <schme_> so it kinda evens out!
11:51:15 <schme_> but it's all good.
11:51:18 <ehird> tieTYT: Emacs.
11:51:20 <ehird> Or yi if you're lame.
11:51:38 <schme_> I found emacs indented my haskell like an idiot.
11:51:48 <ehird> schme_: Only if you're using simple-indent.
11:51:52 <ehird> Which is .. ehm, simple.
11:52:00 <schme_> I dunno. I used haskell-mode
11:52:08 <ehird> schme_: It has two indent modes.
11:52:16 <tieTYT> i'm looking for features like autocomplete and immediate error feedback
11:52:17 <ehird> One is differently-abled.
11:52:20 <schme_> How do I switch?
11:52:23 <tieTYT> can emacs do that?
11:52:23 <orphi> tieTYT: there's Leksah - but it's very alpha.
11:52:25 <ehird> schme_: Dunno. Check the docs
11:52:26 <skorpan> (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
11:52:31 <ehird> skorpan: Yah
11:52:38 <schme_> I don't get why use emacs when you can use vim though :)
11:52:42 <schme_> skorpan: I try that.
11:52:44 <tieTYT> whatever, i'll just use notepad2 :P
11:52:45 <skorpan> hit TAB until you get the indentation you want
11:52:54 <skorpan> schme_: because emacs is freaking powerful
11:53:02 <schme_> skorpan: well so is vim
11:53:25 <lilac> to experienced haskellers: how often do you write more than 5-10 lines of haskell without hitting a compile error?
11:53:42 <schme_> lilac: All the time ?
11:54:00 <schme_> ok. I do hit compile errors 25% of the time atleast!
11:54:37 <skorpan> i make compile errors 80% of the time
11:54:53 <skorpan> if i *REALLY* try hard it's about 50% i think :P
11:54:55 <ehird> NETWORK.FASTCGI REQUIRES ME TO USE 'CGI'
11:55:03 <ehird> what if I want a custom CGIT monad :<
11:55:15 <Deewiant> then you're out of luck
11:55:42 <ehird> Deewiant: So basically, I can use fastcgi, as long as I don't want to use a database.
11:55:44 <ehird> Or StateT.
11:55:58 <ehird> Come on, there has to be something.
11:56:07 <orphi> lilac: I write modules that are 50 lines long or so, and hit only silly typos as compile errors.
11:57:02 <orphi> dons: a nice post, as ever, but it seems a pity you have to resort to non-declarative manual-fusion hackery to get nice performance...
11:57:24 <schme_> that haskell indent seems fucked up too.
11:57:28 <schme_> but in another way.
11:57:34 <lilac> orphi, schme_: ok, just checking that it does get easier ;-)
11:57:40 <ehird> schme_: hit tab multiple times
11:57:42 <ehird> to cycle indents
11:57:45 <schme_> I hit tab and it says Invalid syntx designator: ?\t
11:57:50 <ehird> schme_: You broke it.
11:57:54 <schme_> Great.
11:58:07 <orphi> lilac: any new language takes practice, and one as wildly unusual as Haskell takes *lots* of practice. ;-)
11:58:19 <ehird> Anyone know re: fcgi?
11:58:23 <schme_> vim just seems nicer!
11:58:51 <orphi> dons: I think the point, as you said on the mailing list, is not that mean has "unpredictable" performance, but rather "unexpected" performance unless you really understand how this stuff works.
11:59:06 <orphi> dons: mean was actually kind of a dumb example...
11:59:19 <orphi> OH MY GOD, COMPILING HAS FINISHED!!! :-o
12:01:31 <ehird> schme_: Vim due to its philosophy won't indent your hs properly.
12:01:36 <ehird> Just get haskell-mode working.
12:01:36 <orphi> oh you have GOT to be kidding me... the path to the build folder can't contain spaces?! :-S
12:01:55 <schme_> ehird: What philosophy?
12:01:59 <ozy`> ehird: I don't follow you there
12:02:16 <ehird> schme_: Emacs is 'change everything' -- which haskell-mode does as indentation & stuff is so gnarly
12:02:23 <ozy`> and schme_, I'd like to know what settings you use to make vim's haskell indent your bitch
12:02:28 <ehird> vim, on the other hand, does not let things like indentaiton to be customized to sucha degree
12:02:51 <schme_> ozy`: indent my bitch?
12:03:04 <schme_> I just hit tab to get to a nice indentation level that looks sweet to me.
12:03:18 <mrd> i don't use smart indent in emacs either, anymore
12:03:24 <orphi> finally Gtk2hs is installed!
12:03:25 <schme_> ehird: I have no idea what so ever how to fix this here haskell-mode though.
12:03:26 <mrd> just 2 space tabs
12:03:28 * orphi relaxes
12:03:37 <Arnar> I'm using vim with the haskell indentation script from vim.org - works very well
12:03:43 <schme_> ehird: I don't quite understand the "change everything" ?
12:03:46 <Arnar> and I don't have to press tab on every line to get to the correct spot
12:03:49 <ehird> anyway, who knows about my fcgi.
12:04:10 <ozy`> schme_: using what plugins?
12:05:20 <ehird> :|||||||
12:05:28 <mrd> i just use :set sts=2,sw=2,et in vim
12:05:45 <schme_> ozy`: ??   beats me.. eeh plugins indent on   ? ts=4 sw=4
12:05:58 <mrd> :set ai too i guess
12:06:09 <schme_> But sure I would love to use the emacs thingie.
12:06:19 <ehird> schme_: Learn to read READMEs.
12:06:32 <ehird> Anwyay, okay, seriously. How the hell do I use a custom monad with Network.FastCGI?
12:06:34 <schme_> ehird: The readme says nothing about it.
12:06:42 <ehird> schme_: Does so.
12:06:43 <ehird> I've read it.
12:07:13 <schme_> That's odd. it dun here
12:07:55 <ehird> /sigh -- surely SOMEONE uses fastcgi
12:08:19 <schme_> ehird: Maybe you have a better readme.. where'd you find it=
12:08:19 <schme_> ?
12:08:26 <ehird> schme_: Haskell mode package.
12:08:55 <schme_> same. nothing in it about my problem.
12:09:13 <mrd> you can turn on simple indent if you don't want the "smart" mode
12:09:34 <schme_> The simple indent is fucked up though.
12:09:39 <mrd> how so?
12:09:50 <schme_> It indents my code like it was a she pig.
12:10:06 <mrd> how sow?
12:10:56 <ehird> schme_: Get a better haskell-mode.
12:10:58 <ehird> Google for it.
12:11:16 <schme_> like if we have a case  and 5 ->'s it puts all the ->'s on different indentation levels.
12:11:18 <mrd> do you have an old version?
12:11:19 <schme_> ehird: I can only find one.
12:11:31 <ehird> schme_: Oh, that's not simple indent
12:11:32 <ehird> OK
12:11:33 <ehird> Press tab
12:11:35 <mrd> schme_: the "simple" mode does that? how? the simple mode is just straight up tabs
12:11:37 <ehird> When it indents wrong,
12:11:40 <ehird> press tab multiple times
12:11:44 <ehird> schme_: It can't do anythign else
12:11:52 <ehird> because haskell indentation IS NOT systematically decidable
12:11:56 <ehird> it just indents in as far as possible
12:11:56 <schme_> simple dose that ya. the other one just gives me a funky error.
12:11:59 <ehird> and a few hits of tab gets it right
12:12:03 <ehird> schme_: THAT IS NOT SIMPLE
12:12:05 <ehird> that is the real one
12:12:06 <schme_> I have the cvs version from http://www.iro.umontreal.ca/~monnier/elisp/#haskell-mode
12:12:07 <lambdabot> Title: Emacs Lisp packages
12:12:10 <ehird> it is just not 100% automatic
12:12:11 * orphi lols
12:12:12 <orphi> http://lukeplant.me.uk/blog.php?id=1107301645
12:12:13 <lambdabot> Title: Why learning Haskell/Python makes you a worse programmer
12:12:14 <mrd> your description doesn't sound like the simple indent
12:12:20 <ehird> it is IMPOSSIBLE to be 100% automatic indentation for haskell
12:12:30 <schme_> well when I did the setting of the haskell indent it just drops an error there anyway.
12:12:33 <mrd> your description sounds like the typical newbie question with haskell-mode "smart" indent
12:12:53 <mrd> which ehird answered, somewhat verbosely
12:13:12 <schme_> Ya right.  when I turn-on-haskell-indent it just drops an error.
12:13:28 <schme_> Which Igladly pasted above and was told the solution to that was in the README.
12:14:08 <schme_> BUt anyway.. this is better than using vim how... ?
12:14:22 <mrd> did you try C-c C-l?
12:15:07 <schme_> Sure.. it doesn't seem to do much.
12:15:22 <mrd> load your code?
12:15:27 <schme_> Yes.
12:15:31 <mrd> play with it in ghci
12:15:36 <mrd> jump to errors C-x `
12:15:49 <mrd> check type at point C-c C-t
12:16:01 <schme_> that's not defined though.
12:16:03 <mrd> really
12:16:17 <schme_> rly!
12:16:20 <mrd> in the Haskell source code buffer?
12:16:29 <schme_> Yes in the haskell source code buffer.
12:16:34 <mrd> there's something wrong with your copy
12:16:50 <schme_> This reminds me of the ocaml-mode for emacs.
12:16:56 <mrd> type C-h m
12:17:01 <mrd> read what it says
12:17:02 <Arnar> how can I find if an operator is left- or right associative?
12:17:05 <Arnar> like (!!) ?
12:17:22 <Arnar> @info (!!)
12:17:22 <lambdabot> (!!)
12:17:49 <schme_> ok..
12:17:50 <mrd> @src (!!)
12:17:50 <lambdabot> xs     !! n | n < 0 = undefined
12:17:50 <lambdabot> []     !! _         = undefined
12:17:50 <lambdabot> (x:_)  !! 0         = x
12:17:50 <lambdabot> (_:xs) !! n         = xs !! (n-1)
12:18:01 <mrd> probably have to look at source or docs
12:18:03 <mrd> or test it
12:18:10 <schme_> I'll just jump over to eshell and start up vim again ;)
12:18:16 <mrd> though left-assoc makes the most sense eh?
12:18:27 <Deewiant> > [[1,2,3],[4,5,6],[7,8,9]] !! 1 !! 2
12:18:28 <lambdabot>  6
12:18:31 <Deewiant> left
12:18:33 <mrd> schme_: get reinke's vim plugins
12:18:39 <EvilTerran> Arnar, :info in ghci will tell you
12:19:10 <schme_> mrd: k k. I'll look that up then.
12:19:24 <Arnar> EvilTerran: not for (!!)
12:19:26 <EvilTerran> ghci> :i +
12:19:26 <EvilTerran>   ...
12:19:26 <EvilTerran> infixl 6 +
12:19:30 <schme_> haskell-mode seems like poor mans slime really.
12:19:46 <mrd> schme_: it's actually more like ILISP back in the day, which slime replaced
12:19:47 <EvilTerran> Arnar, if it doesn't say, i think that means there is no fixity decleration, which means it'll be infixl 9
12:19:54 <schme_> mmm
12:19:56 <Arnar> EvilTerran: ah, ok.. thanks
12:19:56 <schme_> well.
12:20:04 <schme_> too bad it's in emacs. :)
12:20:08 <mrd> schme_: there is a slime like project called shim.  it's currently being integrated into Yi
12:20:35 <schme_> What is Yi?
12:20:38 <Arnar> > [[1,2],[3,4]] !! 0 !! 1
12:20:39 <lambdabot>  2
12:20:42 <mrd> i still use emacs for haskell because inferior-haskell mode is still worthwhile
12:20:50 <schme_> Mmm..
12:20:50 <mrd> @where yi
12:20:50 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
12:20:51 <EvilTerran> "Any operator lacking a fixity declaration is assumed to be infixl 9 (See Section 3 for more on the use of fixities)." - http://haskell.org/onlinereport/decls.html#fixity
12:20:51 <lambdabot> Title: The Haskell 98 Report: Declarations
12:20:56 <schme_> I mainly use emacs for running vi.
12:21:11 <mrd> but reinke's vim plugins are very neat
12:21:12 <schme_> and hacking on emacs. hahahaha
12:21:32 <schme_> (dun go gettin' me started on my emacs hacks :D)
12:21:36 <schme_> I'll check 'em out :)
12:21:39 <mrd> unfortunately duplicating inferior-haskell in vim is tricksy, and apparently, anti-vim.  but i hear someone was working on it.
12:22:03 <schme_> Yi seems cool.
12:22:15 <schme_> Well fuck inferior-haskell :)
12:22:27 <schme_> I can run that anyway though.
12:22:43 <schme_> copying text from the vim buffer to the inferior-haskell buffer seems like not so much work.
12:22:47 <schme_> eeh.
12:22:48 <twobitwork> how do you make sub-modules? like Foo.Bar?
12:22:50 <schme_> or just :l
12:22:51 <schme_> hahaha
12:22:58 <schme_> Foo/Bar ?
12:23:10 <mrd> twobitwork: yea, though its just syntactic
12:23:26 <twobitwork> schme_: as in "module Foo.Bar where"?
12:23:44 <twobitwork> or as in "vi Foo/Bar.hs"?
12:23:49 <EvilTerran> twobitwork, both
12:23:52 <schme_> twobitwork: mmm.. Thas' Foo/Bar.hs  :)
12:24:02 <mrd> GHC looks up Foo.Bar in Foo/Bar.hs by default
12:24:07 <twobitwork> EvilTerran: ok
12:24:18 <mrd> you can modify the search path with -i options
12:24:47 <schme_> well thanks for all the help there.
12:24:59 <twobitwork> ok... so if it looks for Foo.Bar in Foo/Bar.hs, can I put something in Foo/ such that Foo itself will have definitions?
12:25:02 <schme_> you guys are just dolls!
12:25:18 <MyCatVerbs> Okay, we need to get people to lay off the "Haskell just as fast as C" meme already before that one explodes in everyone's faces at once.
12:25:21 <schme_> Foo.hs ?
12:25:22 <twobitwork> like in python you do a similar thing with directories, but you have a __init__.py for the main module in the directory
12:25:28 <twobitwork> ahh, ok
12:25:43 <twobitwork> so you would have a Foo directory as well as a Foo.hs
12:25:46 <Cale> MyCatVerbs: It's only going to become more true though.
12:25:53 <EvilTerran> twobitwork, ./Foo.hs would be looked at for module Foo, and ./Foo/Bar.hs for module Foo.Bar
12:25:55 <MyCatVerbs> Cale: yyyyyess...
12:25:56 <schme_> Pfft.
12:26:04 <twobitwork> ok, thanks
12:26:11 <schme_> I was trying to do a mergesort yesterdi. The haskell version was tons less slower than the C version.
12:26:23 <twobitwork> tons less slower?
12:26:28 <schme_> TONS
12:26:31 <twobitwork> you mean, tons faster?
12:26:33 <schme_> think elephants.
12:26:36 <EvilTerran> "less slower"? what does that even mean?
12:26:50 <schme_> that it was really quite slow.
12:26:58 <MyCatVerbs> Cale: ...but could we possibly hold off on saying so until, say, after GHC gets a new register allocator et al? Like, when GHC's back end becomes high-quality, so to speak, rather than merely correct?
12:27:01 <EvilTerran> ah, so "tons slower", then
12:27:05 <schme_> English is not my native language, I might add.
12:27:19 <schme_> so things get a bit confused some of the time.
12:27:25 <EvilTerran> ok, we forgive you ;)
12:27:36 <twobitwork> it's ok, I just wanted to understand what you meant :)
12:27:38 <maltem> schme_, GHC's Data.List.sort is a mergesort, too
12:27:42 <mrd> schme_: yes, saying "less slow" might be interpreted as "fast"
12:28:01 <schme_> maltem: I will check that oot! :)
12:28:02 <Cale> MyCatVerbs: Who is saying it all that much?
12:28:10 <RayNbow> <schme_> TONS <-- metric tonnes?
12:28:20 <Apocalisp> imperial
12:28:21 <MyCatVerbs> Cale: dons, embarassingly enough. ;)
12:28:23 <Cale> MyCatVerbs: I've only heard it said when Haskell programs actually have managed to beat their C counterparts.
12:28:39 <Cale> And dons has written code that does that quite often.
12:28:44 <MyCatVerbs> Cale: http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/16#fast <-- "Write Haskell as fast as C", etc.
12:28:45 <lambdabot> Title: Haskell hacking
12:29:10 <MyCatVerbs> Cale: like Hell dons couldn't write a C equivalent to be faster again.
12:29:38 <schme_> maltem: I can't seem to figure out how to look at the source for that one :(
12:29:45 <Cale> MyCatVerbs: That's clearly not the point of the article. He doesn't say that his C code is nearly optimal, he just says that his Haskell code beats it.
12:29:57 <geezusfreeek> i think he is sometimes a bit misleading
12:31:03 <Cale> Not if you actually read the article.
12:31:10 <RayNbow> "Write Haskell as fast as C" <-- I'm a quick writer? :p
12:31:16 <geezusfreeek> i did read it
12:31:33 <geezusfreeek> misleading != outright lie
12:31:40 <maltem> schme_: Do you have a ghc source tree around?
12:31:42 <Cale> If you only read the headline and then assume that all Haskell code runs faster than carefully hand-optimised C, then sure, you've concluded something incorrect ;P
12:32:36 <maltem> Cale: That's the point of vague headlines
12:32:38 <geezusfreeek> well, for example, as was stated in a comment on reddit, he changed the problem in the section "Recursion kicks arse"
12:33:34 <maltem> schme_: If you have, it's in libraries/base/Data/List.hs
12:34:49 <monochrom> Every exposition is misleading to someone.
12:36:15 <monochrom> Heh, "write haskell as slow as C", as in, takes the programmer more time :)
12:36:15 <MyCatVerbs> geezusfreeek: to be fair, he changed it for both. Didn't compare an allocating C to a constant-space Haskell program or any such cheats.
12:36:41 * monochrom contemplates what should go under that title. :)
12:36:58 <MyCatVerbs> monochrom: writing Haskell while learning it.
12:37:03 <schme_> maltem: I don't think that I do, no :)
12:37:10 <schme_> maltem: I'll find it though! thanks!
12:37:40 <monochrom> Oh! Nice! That works!
12:38:31 <MyCatVerbs> monochrom: I regularly do that while exercising some idiom or part of the language that I don't really know too well.
12:39:13 <vixey> :(
12:39:19 <vixey> I wish there was a channel about dependant types
12:39:34 <MyCatVerbs> monochrom: the other way to write Haskell as slowly as you'd write C is to make the Haskell version multithreaded, and abusively so. That way, the time spent chasing down unsafe memory accesses in the C version just about equals the time spend hunting down open race conditions in the Haskell version. ;)
12:41:58 <nyanyanya> Hi!  Where does the Data/List/Utils.hs reside in Debian?
12:43:42 <MyCatVerbs> nyanyanya: hrmn? Sources aren't installed by default (AFAIK), but if you're after where the compiled copy is, try /usr/lib/ghc-6.8.2/ (that's where ubuntu hides its GHC installs).
12:44:02 <daf> you can do dpkg -S Data/List/Utils.hs
12:44:47 <nyanyanya> I did already and found nothing, also searching for it on packages.debian.org didn't show anything as well :(
12:44:53 <daf> I don't have one of those, but I do have a /usr/lib/hugs/packages/base/Data/List.hs and a /usr/lib/ghc-6.8.2/lib/base-3.0.1.0/Data/List.hi
12:46:49 <MyCatVerbs> nyanyanya: I suspect you need to grab the source tarball for GHC if you want to read the sources. Most distros just keep the .hi and .o files (compiled Haskell) rather than the .hs source files, when you install GHC and libraries for it.
12:47:50 <MyCatVerbs> nyanyanya: also, have you seen this? http://www.haskell.org/ghc/docs/6.8.2/html/libraries/
12:47:54 <nyanyanya> MyCatVerbs: "Failed to load interface for `Data.List.Utils':"
12:48:27 <MyCatVerbs> nyanyanya: ohhhh. Right, you have a problem. You need the .hi files.
12:48:52 <MyCatVerbs> nyanyanya: please do cat `which ghc` from a terminal, please? (It won't spit garbage at you, it's a shell script.)
12:49:56 <nyanyanya> MyCatVerbs: GHCBIN=/usr/lib/ghc-6.8.2/ghc-6.8.2 TOPDIROPT=-B/usr/lib/ghc-6.8.2 exec $GHCBIN $TOPDIROPT ${1+"$@"}
12:50:36 <Deewiant> data.list.utils doesn't come with GHC
12:50:42 <Deewiant> it's probably part of some package in hackage
12:51:30 <MyCatVerbs> Deewiant: oh really? Whoops.
12:51:52 <Deewiant> base contains Data.List but it has no submodules
12:52:39 <MyCatVerbs> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MissingH <-- possibly you want this, but it appears that it is broken.
12:52:43 <lambdabot> http://tinyurl.com/65nmjt
12:52:56 <MyCatVerbs> (That package contains a Data.List.Utils)
12:53:11 <nyanyanya> Right, libghc6-missingh-dev - Library of utility functions for Haskell, GHC6 package
12:53:18 <nyanyanya> Probably this is it, thanks
12:53:38 <MyCatVerbs> nyanyanya: Oh, there's a Debian package for it? Well, excellent.
12:54:30 <ADEpt> Hi. I wan to tap into #haskell overmind: what's the easiest way to obtain haddock-like index of all functions/modules in the Haskell project?
12:54:48 <vixey> ADEpt: using Haddock .. I imagine
12:55:25 <ADEpt> vixey: i tried --ignore-all-exports, but it seems like haddock skips definitions without haddock doc blocks
12:57:36 <ADEpt> vixey: oh wait. My haddock is two years old.
12:59:10 <Vq^> quicksilver++
13:00:49 <ADEpt> vixey: haddock 2.1.0 delivers all the goodies. Thanks!
13:01:04 <vixey> cool :)
13:11:06 <dons> ?users
13:11:06 <lambdabot> Maximum users seen in #haskell: 463, currently: 435 (94.0%), active: 15 (3.4%)
13:11:55 <Vq^> how is active users counted?
13:12:14 <Arnar> ?help users
13:12:14 <lambdabot> users [chan]. Report the maximum number of users seen in a channel, and active users in the last 30 minutes
13:12:53 <Vq^> i see
13:16:01 <MyCatVerbs> Vq^: same principle as how you guess how many UDP connections are open. ;)
13:16:40 <Vq^> MyCatVerbs: UDP connections? i didn't know there was such a thing
13:17:25 <dmwit> exactly
13:20:46 <vixey> @src fix
13:20:46 <lambdabot> fix f = let x = f x in x
13:21:11 <dmwit> The first few hundred times, fix is very mysterious.
13:21:32 <vixey> how the hell does that work :/
13:21:40 <vixey> x = f x ??
13:21:46 <dmwit> Yep!
13:21:52 <dmwit> It only works with guarded recursion.
13:22:01 <vixey> what's guarded recursion?
13:22:04 <dmwit> That is, f must return some constructor first, then the rest of the value.
13:22:06 <dmwit> So:
13:22:09 <dmwit> > fix (1:)
13:22:16 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:22:37 <dmwit> It works because f (here, it's (1:)) first returns part of the list, then recurses.
13:22:44 <EvilTerran> by "first", dmwit means "prior to examining the result of the recursive call"
13:23:00 <EvilTerran> > fix (const 1) -- so this is okay
13:23:01 <lambdabot>  1
13:23:16 <dmwit> vixey: It's called "guarded" recursion because the result is "guarded" by a constructor.
13:23:29 <dmwit> Although as EvilTerran shows, it might not be so obvious what that constructor is. =)
13:24:18 <vixey> > let f x = (let (1:x) = f (1:x) in (1:x)) in f undefined
13:24:33 <lambdabot>  thread killed
13:24:42 <dmwit> > fix (\f n -> if n < 1 then n else f (n - 1) + f (n - 2)) 5
13:24:43 <lambdabot>  -5
13:25:00 <dmwit> > fix (\f n -> if n < 2 then n else f (n - 1) + f (n - 2)) 5
13:25:01 <lambdabot>  5
13:25:10 <vixey> > let fix f = f (fix f) in fix (1:)
13:25:10 <dmwit> > fix (\f n -> if n < 2 then n else f (n - 1) + f (n - 2)) 7
13:25:13 <lambdabot>  13
13:25:13 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:25:46 <dmwit> > let f x = 1 : f x in f
13:25:47 <lambdabot>  Add a type signature
13:26:03 <dmwit> > let f x = 1 : f x in f 3
13:26:05 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:26:41 <dmwit> > let f = 1 : f in f -- the explicitly un-fixed version of fix (1:)
13:26:42 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:29:44 <vixey> oh ok
13:29:49 <vixey> I think I get it ... a bit
13:30:23 <vixey> @ let inspect list = case list of (x:xs) -> (x:inspect xs) ; [] -> [] in inspect (fix (1:))
13:30:26 <vixey> > let inspect list = case list of (x:xs) -> (x:inspect xs) ; [] -> [] in inspect (fix (1:))
13:30:27 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:30:51 <dmwit> inspect = id -- ?
13:31:00 <vixey> no
13:31:05 <dmwit> Well, really, inspect = map id.
13:31:09 <dmwit> But map id = id. =)
13:35:43 <EvilTerran> yeah, that's even the identity for strictness purposes
13:36:51 <EvilTerran> vixey, what did you expect inspect to do?
13:36:59 <vixey> exactly what it did
13:37:31 <EvilTerran> what, nothing?
13:41:21 <weel> Hello all, I have a pesky little linker problem for you. http://hpaste.org/7639
13:42:28 <weel> I'm not exactly sure how to even interpret the error message
13:44:45 <sjanssen> weel: do you have the pretty package installed?
13:44:49 <weel> Yes.
13:45:05 <weel> As a matter of fact, I double-checked. I did "cabal fetch pretty" just in case.
13:45:12 <weel> And as you can see, the compiler finds it:
13:45:13 <weel>   17  Loading package pretty-1.0.0.0 ... linking ... done.
13:45:28 <Botje> it looks like TH is compiled against a different version of pretty
13:46:00 <Botje> but the symbol also mentions pretty-1.0.0.0
13:46:02 <Botje> very weird indeed
13:46:14 <weel> That's the impression I get, too. I've had problems with this before. Before I installed pretty from cabal, the linker would complain that the pretty package was hidden. Not non-existent, but hidden, whatever that is.
13:46:57 <weel> The machine I'm doing this on is fairly fast, so I may end up just deleting all installed hackage packages and GHC and installing from scratch...
13:47:10 <weel> But I wondered if somebody had a more subtle approach
13:47:43 <dmwit> How many things show up under ghc-pkg list | grep pretty ?
13:48:00 <dmwit> (Or even just ghc-pkg list pretty.)
13:48:14 <weel> % ghc-pkg list | grep pretty
13:48:14 <weel>     Takusen-0.8.1, pretty-1.0.0.0
13:48:44 <weel> That's the other weird thing about this. As far as I can tell, there has only been one release of pretty since, what, 1996 or so.
13:48:54 <weel> It's not exactly a mighty complex library.
13:49:18 <dmwit> right
13:49:32 <weel> And it comes with GHC, but before I installed it with cabal, GHC would complain that it was "hidden."
13:49:48 <weel> I have ghc-6.8.2 installed from the tarball, BTW.
13:50:00 <dmwit> Heh, what if you now have two copies of it, one that is hidden, and one that is not?
13:50:07 <dmwit> That would be a funny joke.
13:50:11 <weel> Well, so I tried to unregister it.
13:50:17 <weel> Lemme try that again, though, and see what happens.
13:50:58 <weel> % sudo ghc-pkg unregister pretty-1.0.0.0
13:50:58 <weel> ghc-pkg: cannot find package pretty-1.0.0.0
13:51:00 <weel> Curious.
13:51:07 <weel> It must be well hidden.
13:51:27 <dmwit> Maybe it's installed locally and globally?
13:51:33 <Botje> weel: did you add the extra libs, too?
13:51:34 <weel> How would I find out?
13:51:44 <gwern> @tell boegel I'll add bsd3, but did the site disapear? http://www.elis.ugent.be/~kehoste/Haskell/HRay/darcs/hray doesn't seem to work. as for the patches: I think you just need to download the patch to ~/, and then in hray/ do 'darcs apply ~/the.patch'. as for upload, I mean Hackage of course!
13:51:44 <lambdabot> Consider it noted.
13:51:45 <weel> Botje, what do you mean?
13:52:10 <Botje> when installing from source, you need to unpack the extralibs tarball to add common libs to your install
13:52:18 <weel> I see
13:52:22 <Botje> but i don't think that's needed if you install from a binary tarball
13:53:19 <weel> Okay, I think I got something here. I noticed that pretty was registered in /home/weel/.ghc/x86_64-linux-6.8.2/package.conf:, not the global one
13:54:44 <weel> But when I unregister it, and then run sudo cabal fetch pretty again, it ends up in that same place again.
13:55:38 <weel> well, here, why don't I find out how to cleanly uninstall ghc and the associated libraries and start from scratch, because i think there are some other things messed up as well
13:56:16 <dmwit> Good luck!
13:57:18 <weel> Thanks, I'll mess with it for a bit longer and if it doesn't work again, I'll be back...
13:57:37 <holdy> when an error occurs in ghc, is there a way to print a stack trace?
13:59:38 <dons> holdy: using the ghci debugger, you can get a trace, yeah
14:01:48 <roconnor> @let f 1 = [2,3]; f 2 = [3]; f 3 = []
14:01:49 <lambdabot> Defined.
14:02:15 <roconnor> > let x = [1] ++ concat (takeWhile (not . null) (map f x)) in x
14:02:16 <lambdabot> Terminated
14:02:25 <roconnor> > let x = [1] ++ concat (takeWhile (not . null) (map f x)) in x
14:02:26 <lambdabot> Terminated
14:02:41 <holdy> dons: thx i'll check out the interpreter
14:02:58 <roconnor> > f 1
14:02:58 <lambdabot> Terminated
14:03:16 <vixey> @unlet
14:03:17 <lambdabot> Defined.
14:03:19 <vixey> @let f 1 = [2,3]; f 2 = [3]; f 3 = []
14:03:19 <lambdabot> <local>:3:0:     Warning: Pattern match(es) are overlapped              In th...
14:03:57 <roconnor> let f 1 = [2,3]; f 2 = [3]; f 3 = []; x = [1] ++ concat (takeWhile (not . null) (map f x)) in x
14:04:04 <roconnor> > let f 1 = [2,3]; f 2 = [3]; f 3 = []; x = [1] ++ concat (takeWhile (not . null) (map f x)) in x
14:04:05 <lambdabot>  [1,2,3,3]
14:05:04 <roconnor> > let f 1 = [2,3]; f 2 = [3]; f 3 = []; x = nub $ [1] ++ concat (takeWhile (not . null) (map f x)) in x
14:05:06 <lambdabot>  [1,2,3]
14:05:20 <roconnor> fuck, it works!
14:05:38 <vixey> this is a bad thing?
14:06:06 <vixey> why
14:06:14 <roconnor> it makes my head hurt
14:06:27 <roconnor> I have no idea about how it's efficency
14:06:42 <roconnor> but it must be efficent
14:07:15 <vixey> > let f 1 = [2,3,2]; f 2 = [3,3]; f 3 = [4]; f 4 = []; x = nub $ [1] ++ concat (takeWhile (not . null) (map f x)) in x
14:07:16 <lambdabot>  [1,2,3,4]
14:07:31 <vixey> > let f 1 = [2,3,2,2,2]; f 2 = [3,1,3; f 3 = [4]; f 4 = []; x = nub $ [1] ++ concat (takeWhile (not . null) (map f x)) in x
14:07:31 <lambdabot>  Parse error at ";" (column 36)
14:07:37 <vixey> > let f 1 = [2,3,2,2,2]; f 2 = [3,1,3] f 3 = [4]; f 4 = []; x = nub $ [1] ++ concat (takeWhile (not . null) (map f x)) in x
14:07:37 <lambdabot>  Parse error at "=" (column 42)
14:07:42 <vixey> > let f 1 = [2,3,2,2,2]; f 2 = [3,1,3]; f 3 = [4]; f 4 = []; x = nub $ [1] ++ concat (takeWhile (not . null) (map f x)) in x
14:07:44 <lambdabot>  [1,2,3,4]
14:07:48 <vixey> ok
14:07:52 <vixey> It makes my head hurt too
14:07:57 <roconnor> > let f 1 = [2,3,2,2,2]; f 2 = [3,1,3]; f 3 = [4]; f 4 = [1]; x = nub $ [1] ++ concat (takeWhile (not . null) (map f x)) in x
14:07:58 <vixey> oh nub
14:07:59 <lambdabot>  [1,2,3,4Exception: stack overflow
14:08:04 <vixey> > let f 1 = [2,3,2,2,2]; f 2 = [3,1,3]; f 3 = [4]; f 4 = []; x = [1] ++ concat (takeWhile (not . null) (map f x)) in x
14:08:05 <roconnor> oh well
14:08:06 <lambdabot>  [1,2,3,2,2,2,3,1,3,4,3,1,3,3,1,3,3,1,3,4,2,3,2,2,2,4]
14:08:11 <vixey> I like it without nub
14:08:33 <roconnor> vixey: depends on if you are interested in just the set of answers or not.
14:08:35 <vixey> > let f 1 = [2,3,2,2,2]; f 2 = [3,1,3]; f 3 = [4]; f 4 = []; x = [1,4] ++ concat (takeWhile (not . null) (map f x)) in x
14:08:36 <lambdabot>  [1,4,2,3,2,2,2]
14:08:45 <vixey> what :O
14:09:01 <roconnor> f represents a graph
14:09:03 <vixey> > let f 1 = [2,3,2,2,2]; f 2 = [3,1,3]; f 3 = [4]; f 4 = [1]; x = [1] ++ concat (takeWhile (not . null) (map f x)) in x
14:09:05 <lambdabot>  [1,2,3,2,2,2,3,1,3,4,3,1,3,3,1,3,3,1,3,4,2,3,2,2,2,4,1,4,2,3,2,2,2,4,4,2,3,2...
14:09:12 <roconnor> and x is the reachable nodes from the set [1]
14:09:17 <vixey> yes
14:09:46 <roconnor> but you don't want to compute the reachable nodes from a node you have already visited
14:09:48 <roconnor> hence the nub
14:12:08 <gwern> @tell boegel http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HRay-1.1 as I noted before, website is down? also, there's an odd haddock problem with HRayParser.y, but I dunno about that
14:12:08 <lambdabot> Consider it noted.
14:12:40 <ehird> Bacq.
14:12:53 <twobitwork> what is HSQL and HDBC?
14:13:04 <twobitwork> in reference to haskell database libraries...
14:13:55 <dons> twobitwork: they're libraries on hackage.haskell.org
14:16:54 <quicksilver> Vq^: why did I get a random ++ ?
14:17:53 <twobitwork> dons: thanks...... any idea what the differences between them are?
14:18:32 <dons> HDBC is the one we're talking about the the book, fwiw
14:19:36 <twobitwork> the book?
14:19:46 <dons> ?go real world haskell
14:19:47 <tahir_hhh> Hello, I am trying to install HDirect  and I get this::  ghc.exe: unknown package: lang
14:19:47 <lambdabot> http://www.realworldhaskell.org/blog/
14:19:47 <lambdabot> Title: Real World Haskell
14:19:48 <dons> sorry, that one.
14:20:00 <twobitwork> ahh, I see
14:20:00 <dons> tahir_hhh: oh wow. hdirect hasn't been in use for nearly 10 years
14:20:14 <dons> lang was merged into base and haskell98 packages a long time ago
14:20:26 <tahir_hhh> dons: yeah that is true but I would really like to get to know it :9
14:20:54 <dons> ok. so 'lang' doesn't  exist now
14:21:00 <dons> so you can remove any reference to it
14:21:01 <tahir_hhh> should I remove all references to it like some some newsgroup poster suggested?
14:21:05 <dons> yep
14:21:10 <tahir_hhh> thanks.
14:21:16 <dons> and investigate which libraries those modules are in
14:21:17 <dons> e.g.
14:21:19 <dons> ?hoogle List
14:21:19 <lambdabot> Data.List :: module
14:21:19 <lambdabot> Control.Monad.List :: module
14:21:19 <lambdabot> Control.Monad.List.ListT :: newtype ListT m a
14:21:23 <dons> is now in Data.List
14:22:03 <tahir_hhh> yeah that is quite smart
14:22:10 <Vq^> quicksilver: bevause of your arrow-[] tip :)
14:24:35 <Vq^> s/bev/bec/
14:24:58 <quicksilver> Vq^: glad it worked :)
14:25:42 <RayNbow> anyone here going to attend http://www.st.cs.ru.nl/AFP_TFP_2008/ ?
14:25:43 <lambdabot> Title: Home Page AFP/TFP 2008
14:26:01 <RayNbow> [I'm certainly not going to attend it... no money, no time... poor student that I am :p]
14:28:35 <twobitwork> dons: so, HDBC would be the prefered way to interface with a, i.e., sqlite3 database?
14:28:53 <dons> its a good interface, yeah
14:29:07 <twobitwork> alright, thanks
14:29:20 <ehird> So.
14:29:31 <ehird> FastCGI not allowing you to use any CGIT monad apart from CGI.
14:29:35 <ehird> Whut's up with 'dat.
14:30:24 <dons> its a bit weird
14:30:36 <dons> i think there's some design mistake to be extrapolated there
14:32:22 <sclv_> ehird -- you can use trix to fix it tho, see e.g. hvac
14:32:40 <ehird> sclv_: i'll take a look
14:32:44 <ehird> might even use hvac for this
14:32:58 <ehird> actually, i'll pretend that someone might have the patience to convert it to using hvac via the nomic at some point
14:33:01 <ehird> so i don't have to
14:33:24 <sclv_> I forget how exactly I did it -- the old version did some seperate bindings, but now it works with the existing fastcgi library.
14:35:05 <ehird> sclv: You'd probably rip my code apart, it's ugly as all hell
14:35:39 <tahir_hhh> ?Hoogle ST
14:35:39 <lambdabot> Maybe you meant: google hoogle
14:37:12 <sclv_> haha like mine is known for being pretty.
14:37:19 <dons> infamous
14:39:14 <BMeph> ehird: We all know you hang out in #esoteric. It's not going to be a surprise if wwe see you have code that's "a little hard to read"... ;)
14:40:51 <ehird> BMeph: ouch ;)
14:41:11 <osfameron> hmmm, F# looks very cool (and a little more approachable than haskell)
14:41:12 <RayNbow> hmm...
14:41:16 <vixey> :O
14:41:19 <vixey> I think I did it!
14:41:20 <dons> more approachable?
14:41:29 <RayNbow> osfameron: I hate the syntax :p
14:41:46 <vixey> seems to be a working type checker for CoC :D
14:42:38 * BMeph goes back to designing his FALSE interpreter...
14:42:51 <BMeph> ehird: Not like I'm one to talk. ;)
14:42:57 <osfameron> RayNbow: well, I didn't like the tuple syntax foo * bar, which I think is from ocaml?
14:42:57 <ehird> BMeph: FALSE is not particularly difficult. :P
14:43:02 <ehird> It's also pretty boring!
14:43:03 <RayNbow> hmm, when you use ghc --make, do you still have to specify -O2?
14:43:13 <osfameron> but with #light, it's pretty much the same sugar as haskell
14:43:17 <RayNbow> osfameron: yeah, F# is based on OCaml
14:43:28 * osfameron installs Mono to maybe play with F# at some point
14:43:46 <BMeph> ehird: I like FALSE because it's faithful to Forth, not because it's tough to read.
14:44:12 <QtPlatypus> BMeph: I thought faithful to forth implied tought to read.
14:44:14 <ehird> BMeph: I mean to implement
14:44:16 <tahir_hhh> I believe that it is unfortunate that the Windows support for Haskell is lacking
14:45:14 <BMeph> tahir_hhh: I believe that it's unfortunate that Windows support for Haskell caters more to supporting Windows than Haskell. :|
14:45:17 <osfameron> the 2 things that are very positive about F# (apart from dubious things like possible mutability, which is good/bad depending on various factors) are a) libraries, and b) the REPL seemed better than ghci - multiline support etc.
14:46:17 <tahir_hhh> But all the possible users that could have made Haskell the next Java... all lost
14:46:31 <dons> osfameron: ghci supports multiline input
14:46:35 <dons> introduce it with :{
14:46:48 <osfameron> I don't seriously believe haskell will become the next java.  F# might be (unlikely, but possible)
14:46:48 <tahir_hhh> I am still determined to get HDirect to work
14:46:54 <osfameron> dons: oh!  thanks, didn't know that
14:47:25 <tahir_hhh> osfameron: I would prefer Haskell but F# would be a massive improvement over c#
14:48:57 <Vq^> whats the issue with haskell on windows?
14:49:05 <dons> is there an issue?
14:49:07 <osfameron> tahir_hhh: C# does seem to have plenty of functional goodies though
14:49:14 <osfameron> I thought spj and others hacked primarily on windows?
14:49:24 * vincenz votes to remove joelr from ph
14:49:44 <dons> vincenz: ask ibid
14:49:44 <vincenz> I even wonder why the hell he's on there
14:49:51 <vixey> what's ph?
14:49:57 <osfameron> I think joelr's quite interesting
14:49:58 <tahir_hhh> osfameron: actually you are right.  I forgot that I still using version 2 of c# at work
14:49:59 <vincenz> dons: sure, but I doubt that'll happen without some kind of vote
14:49:59 <Vq^> dons: tahir_hhh suggested something along those lines
14:50:04 <vincenz> osfameron: he doesn't have a single haskell post
14:50:05 <vixey> planet haskell
14:50:24 <osfameron> vincenz: he used to.  And he writes about using FP in the real world, which is interesting to some people.
14:50:34 <RayNbow> <Vq^> whats the issue with haskell on windows?
14:50:34 <RayNbow> <dons> is there an issue?
14:50:36 <RayNbow> yes
14:50:37 <RayNbow> readline ;)
14:50:54 <vincenz> osfameron: I guess opinions vary :)
14:51:26 <Vq^> RayNbow: no terminal control?
14:51:37 <RayNbow> which reminds me, I still have to try recompiling ghc+readline with some flags... my last attempt from a few months ago resulted in link errors :p
14:51:45 <RayNbow> Vq^: hmm?
14:51:56 <vixey> I feel really stupid
14:52:01 <vixey> 7 attempts to write this in Haskell failed
14:52:08 <vixey> 1st attempt in Prolog it workedd :/
14:52:14 <RayNbow> well, there are no Win32 binaries for the Readline package
14:52:15 <Vq^> RayNbow: does ghc for windows lack readline?
14:52:16 <tahir_hhh> Vq^: suggested...?
14:52:20 <Vq^> ok
14:52:34 * RayNbow wanted to try out Djinn on Windows
14:52:38 <RayNbow> which required readline :p
14:52:39 <Vq^> tahir_hhh: you know what you said :P
14:53:35 <mattam> vixey: thought you had a working typechecker ?
14:53:39 <tahir_hhh> That Linux using Haskeller's should help us Windows users out?
14:54:07 <vincenz> vixey: what is it?
14:54:15 <vixey> mattam: I think I do now (it checks true,false : bool, zero and succ zero : nat) but my attempts in Haskell didn't work
14:54:24 <mattam> I really doubt you had it working in prolog, I'd like to see that.
14:54:29 <vixey> http://pastey.net/87889
14:54:32 <mattam> For the CoC right ?
14:54:36 <vixey> vincenz: it's supposed to type check CoC
14:54:38 <vixey> mattam yeah
14:55:06 <vincenz> CoC?
14:55:13 <BMeph> Couldn't you just set up a Linux emu, and run GHC there?
14:55:15 <vixey> vincenz: like Coq without datatypes
14:55:25 <Vq^> tahir_hhh: how should they do that?
14:55:35 <vincenz> so a dependently-typed system?
14:55:40 <vixey> yes
14:56:05 <vincenz> neat :)
14:56:21 <vixey> mattam: there is a big chance of some bugs.. but I haven't noticed any yet (with basics tests)
14:56:36 <BMeph> Off for home, see you-all tomorrow. :)
14:56:37 <tahir_hhh> By making the whole compilation process and so forth not *too* unix environment dependent (a little is ok though)
14:57:56 <vixey> (I used ? as Prop, ! as Set, * as Type)
14:57:59 <dejones> dons: your blog post (Write Haskell as fast as C: exploiting strictness, laziness and recursion) is awesome, your #1 post on reddit: http://reddit.com/r/programming/
14:58:20 <dons> good to know, dejones :)
14:58:23 <tahir_hhh> Vq^: but actually thinking about it, I am having a hard time because no one else is using HDirect
14:58:23 <lament> hopefully most people write haskell faster than C :)
14:58:35 <Vq^> tahir_hhh: whats that?
14:58:43 <RayNbow> well, C has the advantage that its name only consists of a single letter? :p
14:58:59 <tahir_hhh> HDirect is for com interoperability
14:59:20 <mattam> vixey: are you sure eval does realize beta-reduction ?
14:59:29 <Vq^> tahir_hhh: hmm, never used com...
14:59:52 <twanvl> RayNbow: That can be rectified by introducing U+21234: LATIN LIGATURE HASKELL
14:59:54 <ehird> sclv: I totally do not understand hvac's stuff for fastcgi monadic stuff.
14:59:55 <ehird> Whut I do.
15:00:06 <vixey> mattam: yeah it would, I freshen lambda terms to use Prolog variables, so beta reduction is done just by unification
15:00:07 <tahir_hhh> Vq^: yeah, that is the problem, no one does.  Makes me want to reevaluate my ambitions of using that technology
15:00:43 <Vq^> tahir_hhh: is that something dos specific?
15:00:46 <vixey> eval(?(X:_,B) $ X,V,yes) :- !, eval(B,V,_). % this does a beta reduction
15:01:15 <mattam> line 30 seems suspicious
15:01:17 <RayNbow> twanvl: well, let's convince everyone Haskell needs its own symbol in the Unicode table :)
15:01:36 <mattam> Why the same X ?
15:01:43 <RayNbow> the next step is to convince the keyboard manufacturers to add a Haskell key
15:02:23 <tahir_hhh> Vq^: All I wanted was to be able to write a plugin for Outlook just to learn something about real world Haskell but the writing of the code is much easier than the set up because I cannot say I know what I am doing
15:03:25 <vixey> mattam: The X bound by lambda is also used in the body, so when I bind it with eval, that does a rewrite in the body (just getting unification to do substitution for me)
15:04:16 <Vq^> tahir_hhh: thats a bit sad, here in gentoo haskell packages are a breeze
15:04:20 <mattam> Hmmm... ok. I'm not used to prolog :) That's a weird trick.
15:04:46 <vixey> hehe
15:04:50 <tahir_hhh> Vq^: But it is real world dammit! :0
15:05:31 <Vq^> tahir_hhh: doesn't the real world use mutt already? :o)
15:06:01 <osfameron> anyone here used f# on mono?  Having problems installing (I know this isn't on topic, apologies, I promise I'll shut up about F# now...)
15:06:29 <Vq^> osfameron: i have only failed my attempts
15:06:38 <tahir_hhh> Vq^: academia does not count as the real world, sorry but true
15:07:26 <ehird> sclv: An explanation would be lovely
15:07:45 <osfameron> ok
15:07:53 <mattam> vixey: [copy_term] ? What's [scoping] used for ?
15:09:46 <vixey> mattam: I have my concrete syntax (written in Prolog <name> := <term>) but to do beta substitution and all these things, I change all the names into variables (a bit like de bruijn but global), so lambda(x, lambda(y, x)) is changed into something like lambda(V1, lambda(V2, V1)) but scoping
15:10:28 <roconnor> @type maybe
15:10:31 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:10:32 <vixey> copy_term is so that any bindings I did down the road in type checking X and Y in X $ Y don't propagate out to interfere with typechecking other parts
15:11:10 <mattam> ok
15:11:32 <roconnor> @type fromJust
15:11:34 <lambdabot> forall a. Maybe a -> a
15:12:31 <mattam> What's difficult in translatiing this to Haskell ?
15:13:21 <mattam> Once you've settled for a representation of variables :)
15:16:04 <vixey> I think it's because I make a lot of use of logic variables
15:16:37 <vixey> not sure really
15:18:22 <vixey> I guess I'll read the simply easy paper again and try once more
15:19:30 <mattam> The hard part is really how do you handle variables. And you can't do the same trick in Haskell that you can do in Prolog, altough you can also get substitution for free using higher-order abstract syntax.
15:19:32 <ddarius> Or you could just implement logic variables in Haskell.
15:19:59 <vixey> ohh I never tried HOAS
15:20:06 <vixey> I've tried just about everything else though :)
15:20:38 <vixey> ddarius: I actually tried to copy the paper Typed Logic Variables in Haskell but I couldn't get ST to swap in for StateT and some other problems :/
15:21:04 <ddarius> What does "get ST to swap in for StateT" mean?
15:21:35 <mattam> I find de Bruijn indices easier to understand if not conceptually simpler :)
15:21:48 <ehird> sclv: no?
15:22:02 <vixey> you need a backtracking monad so I had put LogicT (StateT (Identity .. kind of thing, but It couldn't manage to replace ST for StateT
15:22:32 <Heffalump> ehird: I'm here now..
15:22:41 <ehird> Heffalump: Oh yay.
15:23:01 <ehird> Heffalump: I just wanted examples of table definition with your thingy.
15:23:06 <ddarius> What went wrong, LogicT (ST s) should work fine.
15:23:16 <Heffalump> what do you mean by table definition? As in actually creating a new table in the database?
15:23:43 <vixey> hmm some horrible mishmash with forall r. and such .. I guess I'll try again at some point
15:23:46 <Heffalump> I haven't done anything for that yet, but my idea is that you'd just take the same way you write a query that looks at a table, and annotate it in some way for indexes and that kind of thing.
15:24:20 <ehird> Heffalump: D'aww.
15:24:23 <ehird> That's what I need, y'see.
15:24:31 <ehird> Heffalump: What does a query look like?
15:25:04 <roconnor> @src intercalate
15:25:04 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
15:25:22 <ehird> Oh ho HO
15:25:26 <ehird> I have an >>EVIL<< idea.
15:25:32 <ehird> Use coerce :: a -> b to get runFastCGI to the type I want.
15:25:44 <Heffalump> ehird: well, you just write functions over Haskell datatypes, and then you compose queries with them
15:25:49 <ddarius> ehird: Go for it, it will end in tears.
15:25:53 <ehird> ddarius: :D
15:25:58 <ehird> Heffalump: Cool.
15:25:59 <Heffalump> e.g. project (\(x, y, z) -> (x+y, z)) $ ....
15:26:02 <koninkje> vixey: have you looked into Control.Monad.Logic? There're a few other papers on the topic of unification and logic variables too
15:26:07 <ehird> Heffalump: How does that compile to sql?
15:26:09 <Heffalump> except much of the time you'd work with records not tuples
15:26:10 <ehird> Special Num instances, etc?
15:26:15 <Heffalump> pretty much, yeah
15:26:27 <Heffalump> your function has to be overloaded
15:26:34 * koninkje reads back more, nm
15:26:35 <Heffalump> and this all requires type instance families
15:26:37 <vixey> koninkje: I've seen two papers, about logic vars
15:26:49 <vixey> koninkje: but I didn't know Control.Monad.Logic existed ty
15:27:05 <vixey> (any more stuff on logic vars I would like to see)
15:28:35 <vixey> (I found this too which uses Haskell http://citeseer.ist.psu.edu/coquand96algorithm.html )
15:28:37 <lambdabot> Title: An Algorithm for Type-Checking Dependent Types - Coquand (ResearchIndex)
15:29:00 <koninkje> A few to start with if you haven't read them yet:
15:29:01 <koninkje> http://web.cecs.pdx.edu/~sheard/papers/generic.ps
15:29:10 <koninkje> http://okmij.org/ftp/papers/LogicT.pdf
15:29:18 <koninkje> http://www.cs.chalmers.se/~emax/wired/documents/LP_HFL07.pdf
15:29:41 <vixey> cool, thanks
15:29:50 <koninkje> Which did you find?
15:29:56 * koninkje always looking for more
15:30:18 <vixey> ddarius showed me this one http://citeseer.ist.psu.edu/claessen00typed.html
15:30:19 <lambdabot> Title: Typed Logical Variables in Haskell - Claessen, Ljungl (ResearchIndex)
15:30:38 <vixey> also one other one..
15:30:53 <koninkje> ty :)
15:32:35 <vixey> this one is also really wonderful http://citeseer.ist.psu.edu/318776.html
15:32:42 <lambdabot> Title: Embedding PROLOG in HASKELL - Spivey, Seres (ResearchIndex)
15:34:56 <ehird> import Unsafe.Coerce
15:34:56 <ehird> runGenericFastCGIConcurrent :: (MonadIO m) => Int -> CGIT m CGIResult -> m ()
15:34:56 <ehird> runGenericFastCGIConcurrent = unsafeCoerce runFastCGIConcurrent
15:35:00 <ehird> WAMWANANAWMWAMAWHHABSAHAHASKDASAJHAHAHAHAHAHHAHAA
15:35:17 * ehird cackles like an evil maniac and eyeballs pop
15:35:33 <ehird> OH MY GOD IT COMPILES X.X
15:35:43 <ehird> OH MY GOD IT RUNS X.X
15:35:43 <ddarius> ehird: Of course it would compile.
15:35:47 <ehird> ddarius: It even RUNS.
15:35:49 <dmwit> Did you take your pills today?
15:35:58 <MyCatVerbs> dmwit: that's not the issue.
15:36:04 <MyCatVerbs> Oi! ehird!
15:36:10 <ehird> Oi! MyCatVerbs!
15:36:11 <MyCatVerbs> Did you take someone else's pills today?
15:36:17 <dmwit> hehehe
15:36:20 <ehird> Maybe not no.
15:36:22 <ehird> <__<
15:37:08 <ehird> But hahahahah/.
15:37:13 <ehird> A use of unsafeCoerce that works properly.
15:37:16 <ehird> And solves a problem.
15:37:29 <ddarius> Until your program mysteriously crashes.
15:37:53 <ehird> ddarius: Go and release a fastcgi library that is the same but without the type restriction.
15:37:56 <ehird> Then I'll stop using unsafeCoerce.
15:37:59 <vixey> koninkje: out of curiousity.. why are you interested in logic programming/embeddings of? :)
15:38:29 <ddarius> ehird: What type restriction?
15:38:38 <koninkje> vixey: I'm working on an implementation of a weighted logic pl
15:38:45 <ehird> ddarius: runFastCGI :: CGI CGIResult -> IO ()
15:38:46 <ehird> should be
15:38:54 <ehird> :: (MonadIO m) => CGIT m CGIResult -> m ()
15:38:56 <ddarius> "This is heavily true."
15:38:56 <vixey> koninkje: oh cool! Do you have some info about it anywhere?
15:38:59 <ehird> ddarius: like runCGI.
15:39:00 <koninkje> vixey: ...and trying to convince TPTB to let me use haskell instead of c++
15:39:08 <ehird> ddarius: 'cause right now you can't use a custom monad with it.
15:39:13 <ehird> unsafeCoerceing it to the right type works.
15:39:20 <ehird> So all you need to do is fix the type declaration.
15:39:25 <vixey> A very smart plan I think
15:39:30 <Heffalump> ehird: and you're unsafeCoercing that? Ewww!
15:39:38 <ehird> Heffalump: Yah.
15:39:38 <Heffalump> I can't imagine that'll work in general..
15:39:42 <Heffalump> what's the target type?
15:39:43 <ehird> Well, it does. Bizzarely.
15:39:49 <ehird> Heffalump: I'm actually coercing:
15:39:59 <ehird> runFastCGIConcurrent :: Int -> CGI CGIResult -> IO ()
15:40:01 <ehird> into
15:40:08 <ehird> runGenericFastCGIConcurrent :: (MonadIO m) => Int -> CGIT m CGIResult -> m ()
15:40:08 <ehird> runGenericFastCGIConcurrent = unsafeCoerce runFastCGIConcurrent
15:40:18 <dmwit> Why don't you just do
15:40:20 <ehird> And .. it compiles. And runs. And whoa.
15:40:20 <Heffalump> but that coercion introduces a dictionary argument that isn't present!
15:40:28 <koninkje> vixey: I'm working on version 2 of Dyna. You can find out about version one: http://www.cs.jhu.edu/~jason/research.html#fg06
15:40:28 <lambdabot> Title: Jason Eisner - Research Summary
15:40:33 <dmwit> runFastCGILifted x = liftIO (runCGI x) -- ?
15:40:34 <ehird> Heffalump: Something like that.
15:40:44 <ehird> dmwit: Um what?
15:40:45 <Heffalump> firstly I didn't even known unsafeCoerce could do that. Secondly how does it ever run?
15:40:53 <ehird> dmwit: The point is that my app is in App
15:40:55 <ehird> which is a CGIT over Nomic.
15:40:59 <ehird> It's not in CGI.
15:41:06 <dmwit> So... use runCGIT?
15:41:07 <Heffalump> dmwit: that wouldn't deal with the parameter
15:41:07 <ehird> Heffalump: I don't know! But it does.
15:41:14 <ehird> dmwit: runCGI works.
15:41:16 <Heffalump> ehird: I don't believe you're actually testing that code path.
15:41:20 <koninkje> vixey: Not much is available about the new version yet (we still have to write it yet, though we're close to finishing the details)
15:41:22 <ehird> dmwit: it's runFastCGI
15:41:31 <ehird> Heffalump: Uh, I just recompiled the code from scratch and got fastcgi to spawn it.
15:41:34 <ehird> It runs and works.
15:41:37 <ehird> It's the only entry point to my app.
15:42:01 <Heffalump> ehird: if you told me you'd invented a way of teleporting, I wouldn't believe you
15:42:10 <Heffalump> this is kind of similar only less extreme :-)
15:42:13 <ehird> Heffalump: I guess I'm just hallucinating then. :3
15:42:28 <ehird> Let's put it this way.
15:42:29 <vixey> cool stuff, good luck
15:42:31 <Heffalump> well, if you were claiming to have teleported I'd be very confident you were hallucinating.
15:42:34 <ehird> It wasn't compiling before in any way or form.
15:42:39 <ehird> I then compiled it now with the coerce.
15:42:40 <ehird> It compiles.
15:42:42 <Heffalump> Here I'm not so sure. But I'm still rather skeptical.
15:42:43 <ehird> And I restarted lighttpd.
15:42:43 <ehird> It runs.
15:42:51 <Heffalump> ehird: and what is m?
15:43:13 <ehird> Heffalump: Nomic.
15:43:14 <Heffalump> even with m = IO I have difficulty believing it would work given the dictionary.
15:43:23 <Heffalump> and what is Nomic defined as?
15:43:28 <ehird> newtype Nomic a = Nomic (IO a) deriving (Monad, ...) -- For now.
15:43:33 <ehird> But it will gain probably a reader of some sort.
15:43:34 <ehird> And a DB layer.
15:44:15 <dmwit> I could almost believe that it works, with a newtype wrapper around IO.
15:44:19 <ddarius> ehird: Your code may or may not work now, but will definitely fail later.
15:44:26 <Oz_Blueshoes> hey
15:44:35 <dmwit> But I am with Heffalump and ddarius; I don't think this will continue to work indefinitely.
15:44:39 <Heffalump> hmm. OK, so it really is IO.
15:44:39 <dmwit> Oz_Blueshoes: Hi!
15:44:41 <ehird> ddarius: Like I said. Go and change the type signature and upload a new version.
15:44:43 <ehird> Then I'll stop
15:44:50 <Oz_Blueshoes> I'm new to Haskell
15:44:50 <ehird> Heffalump: i'll add a phony statet in a sec to test.
15:44:53 <ddarius> ehird: Why don't you?  I don't maintain it.
15:44:55 <Heffalump> I still don't understand how the dictionary argument works out, but apart from that it doesn't really surprise me.
15:45:03 <ehird> BRB.
15:45:06 <ehird> ddarius: Nor I.
15:45:14 <Heffalump> who does maintain it?
15:45:22 <ddarius> @hackage fastcgi
15:45:23 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fastcgi
15:45:25 <dmwit> ehird: No, but you use it; ddarius (probably) doesn't.
15:46:15 <Saizan> Heffalump: well, the dictionary is given from the outside and never used?
15:46:33 <Heffalump> Saizan: umm, but it changes the way it gets called..
15:46:35 <Heffalump> doesn't it?
15:46:52 <Saizan> uhm, right
15:47:20 <ddarius> Heffalump: Perhaps it get specialized?
15:50:04 <ehird> Back
15:50:11 <ehird> dmwit: Guess so.
15:50:14 <vixey> are people invited to write these functional pearls or what?
15:50:18 <ehird> Heffalump: You must remember that:
15:50:22 <ehird> type CGI a = CGIT IO a
15:50:29 <ehird> Heffalump: So it's not that suprising, it has all the slots it needs.
15:50:33 <ehird> I'm just adding one parameter.
15:52:27 <monochrom> People invite themselves to write these functional pearls. Some are published after going through academic-grade review and revisions. The rest are rejected.
15:53:06 <ehird> @hoogle (a -> Bool) -> [a] -> ([a],[a])
15:53:07 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
15:53:07 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
15:53:07 <lambdabot> Data.List.span :: (a -> Bool) -> [a] -> ([a], [a])
15:53:13 <ehird> > span odd [1,2,3,4,5]
15:53:22 * ehird kicks lambdabot 
15:53:25 <lambdabot>  ([1],[2,3,4,5])
15:53:33 <ehird> > break odd [1,2,3,4,5]
15:53:34 <lambdabot>  ([],[1,2,3,4,5])
15:53:35 <Saizan> ehird: really, everything that's not a newtype of IO will crash, runFastCGI is going to use IO's >>=, unless unsafeCoerce is deeply magic
15:53:38 <ehird> Beh
15:53:47 <ehird> Saizan: Well, let's see shall we.
15:53:50 <ehird> I will add 1 (1) StateT.
15:54:12 <roconnor> @wn automata
15:54:15 <lambdabot> *** "automata" wn "WordNet (r) 2.0"
15:54:15 <lambdabot> automata
15:54:15 <lambdabot>      See {automaton}
15:54:15 <lambdabot>  
15:54:15 <lambdabot> *** "automata" wn "WordNet (r) 2.0"
15:54:17 <lambdabot> [6 @more lines]
15:54:54 <Heffalump> ehird: I still don't see how it would have had the dictionary argument before.
15:55:01 <ehird> 2008-05-15 23:56:15: (mod_fastcgi.c.1042) to be exact: it seg-fault, crashed, died, ... you get the idea.
15:55:04 <ehird> OK, a StateT breaks it/
15:55:06 <ehird> :-P
15:55:09 <Heffalump> ddarius: it's beyond me how the specialiser and unsafeCoerce would interact. Plausible, I guess.
15:55:12 <Heffalump> ehird: thank god for that.
15:55:23 <ehird> Heffalump: imagine if it worked
15:55:24 <ehird> :-)
15:56:22 <roconnor> @wn unary
15:56:22 <lambdabot> *** "unary" wn "WordNet (r) 2.0"
15:56:22 <lambdabot> unary
15:56:22 <lambdabot>      adj : consisting of or involving a single element or component;
15:56:22 <lambdabot>            "in a unary operation in a mathematical system one
15:56:22 <lambdabot>            element is used to yield a single result"
15:56:33 <ehird> @wn fudge
15:56:34 <lambdabot> *** "fudge" wn "WordNet (r) 2.0"
15:56:34 <lambdabot> fudge
15:56:34 <lambdabot>      n : soft creamy candy
15:56:34 <lambdabot>      v 1: fake or falsify; "Fudge the figures"; "cook the books";
15:56:34 <lambdabot>           "falsify the data" [syn: {manipulate}, {fake}, {falsify},
15:56:36 <lambdabot> [7 @more lines]
15:56:39 <roconnor> @wn recurses
15:56:39 <lambdabot> No match for "recurses".
15:56:44 <vixey> btw did anyone else find Omega doesn't build?
15:56:45 <roconnor> is recurses a word?
15:56:46 <ehird> @wn wordnet
15:56:46 <lambdabot> *** "wordnet" wn "WordNet (r) 2.0"
15:56:46 <lambdabot> wordnet
15:56:46 <lambdabot>      n 1: any of the machine-readable lexical databases modeled after
15:56:46 <lambdabot>           the Princeton WordNet
15:56:48 <lambdabot>      2: a machine-readable lexical database organized by meanings;
15:56:49 <ehird> roconnor: yes.
15:56:50 <lambdabot>         developed at Princeton University [syn: {Princeton WordNet}]
15:56:53 <ehird> It recurses amazingly!
15:57:11 <monochrom> recurse is a fine verb.
15:57:38 * ehird recurses monochrom, if you know what I mean.
15:57:40 <ehird> Wait, what?
15:58:09 * monochrom indulges in self-recursion
15:58:24 <ehird> Ooh.
15:58:55 * geezusfreeek prefers to practice mutual recursion
16:00:27 <ehird> geezusfreeek: Jesus, freak.
16:00:59 <monochrom> ehird: God damn.
16:01:42 <monochrom> we still need geezusfreeek to complete the cycle.
16:02:16 <joed> 55555q
16:02:52 <Heffalump> ehird: if it did I'd start believing in teleportation too
16:03:25 <ehird> Heffalump: :D
16:03:41 <monochrom> the mutual recursion is broken
16:09:47 <roconnor> We should make "head", "fromJust", etc, bright red in HsColour
16:09:54 <roconnor> and blinking too
16:10:25 <vixey> red for ..proof obligation ?
16:10:30 <ehird> .
16:10:40 <ehird> ANYWAY.
16:10:44 <roconnor> vixey: yeah.
16:10:52 <roconnor> maybe require a big comment block :P
16:11:04 <ehird> I am about to fix fastcgi.
16:11:07 <ehird> Any objections?
16:11:19 <monochrom> Every recursion should be marked as red and blinking too, since they're as bottom as head, fromJust.
16:11:39 <ehird> monochrom: Every function call!
16:11:54 <monochrom> Yeah.
16:12:31 <ehird> OK, Lemmih, I'm going to piss all over your package in a second, by fixing it.
16:12:35 <monochrom> The whole bloody source code should be in red and blinking, since it has a bug, or at least, it has not been proven that it has no bug.
16:12:46 <ehird> I'm not gonna change the copyright info because I am changing only a few characters.
16:12:58 <dons> ehird: you're not uploading changes are you?
16:13:02 <ehird> dons: no
16:13:02 <ehird> ;)
16:13:09 <ehird> Not unless people want me to!
16:13:23 <vixey> can I use newtype deriving Monad here? newtype Logic a = Logic (forall r r'. SG r (ST r') a)
16:13:31 <ehird> Because, you know, why would I share a sane FastCGI with you.
16:13:45 <vixey> it said Can't make a derived instance of `Monad Logic' (even with cunning newtype deriving.. so I'm not sure what to do
16:13:57 <monochrom> Probably not. Too complicated.
16:14:00 <dons> ehird: more to the point: don't break things
16:14:10 <ehird> dons: I don't think this can break anything.
16:14:14 <ehird> It's just making a type more specific.
16:14:24 <dons> well, talk it over with the maintainer. sounds fine
16:14:45 <monochrom> If you have monad M and then you newtype N a = N (M a), deriving Monad will work. Anything more complicated, the chance diminishes quickly.
16:15:35 <ehird> :t alloca
16:15:36 <lambdabot> Not in scope: `alloca'
16:15:39 <ehird> asdsdfsdfsdf.
16:16:18 <Vulpyne> There's stuff for manual memory management if you really want it.
16:16:43 <ehird> Vulpyne: I'm looking up alloca's type.
16:16:45 <ehird> Fastcgi uses it.
16:16:55 <monochrom> @index alloca
16:16:56 <lambdabot> Foreign.Marshal.Alloc, Foreign.Marshal, Foreign
16:17:11 <monochrom> try prepending module name
16:17:18 <ehird> monochrom: Didn't know the module name.
16:17:19 <ehird> Thanks.
16:17:27 <ehird> alloca :: Storable a => (Ptr a -> IO b) -> IO b
16:17:32 <ehird> Damnit .. need to stuff this into IO somehow ..
16:17:59 * monochrom grins. of course allocation is deep magic. :)
16:18:11 <Saizan> alloca :: ContT b IO (Ptr a)
16:18:17 <ehird> monochrom: Can I kill some babies? Thanks.
16:18:27 <travisbrady> can anyone tell me a better way to have Data.List.groupBy group by just the first elem in a tuple other than just using this? grouper (a,_) (b,_) = a==b
16:18:42 <travisbrady> :t grouper (a,_) (b,_) = a==b
16:18:43 <lambdabot> parse error on input `='
16:18:52 <Heffalump> @type (==) `on` fst
16:18:54 <lambdabot> forall a b. (Eq a) => (a, b) -> (a, b) -> Bool
16:19:01 <ehird> Okay. I give up! I switch to scgi
16:19:46 <travisbrady> @type grouper (a,_) (b,_) = a==b
16:19:48 <lambdabot> parse error on input `='
16:20:15 <dons> :t groupBy (equating fst)
16:20:17 <lambdabot> Not in scope: `equating'
16:20:21 <dons> :t groupBy (Data.Eq.equating fst)
16:20:23 <lambdabot> Not in scope: `Data.Eq.equating'
16:20:31 <dons> ah well, maybe that didn't make it in
16:20:53 <ehird> sclv: How do you do it in hvac?
16:21:17 <monochrom> The other day I thought HSP = haskell on a silver platter
16:24:11 <dons> haha we win. a oft-times critic sez, "They're damn near identical, modulo differences of syntax. I was surprised, actually - I'd expected a mess of strictness annotations. But apparently ghc -O can infer a lot of those for you, which is good to know."
16:24:34 * dons battles misconcepts with two swords!
16:24:46 <monochrom> who are "they", who are damn near identical?
16:25:19 <dons> programs.
16:25:25 <dons> haskell v C.
16:25:43 <Saizan> i hope it refers to the generated assembly, rather than code :)
16:25:44 <ehird> BRACKET IS IN IO.
16:25:45 <ehird> SUX.
16:25:48 <monochrom> haskell code identical to C code is horrifying :)
16:26:02 <ehird> SCGI is also broken.
16:26:03 <ehird> :|
16:26:04 <dons> ehird: and for good reason
16:26:12 <ehird> dons: Yessss but it breaks SCGI
16:26:15 <ehird> I cannot turn it generic
16:26:26 <saml> my haskell code is similar to C because i use do notation
16:26:29 <monochrom> but if it's meant conceptually the same, or lengthly the same, I guess that's normal.
16:26:53 * monochrom goes over to see the code for real
16:27:13 <Saizan> ?type bracket
16:27:15 <lambdabot> Not in scope: `bracket'
16:27:28 <saml> ?type E.bracket
16:27:29 <lambdabot> Couldn't find qualified module.
16:27:39 <Saizan> ?type Control.Exception.bracket
16:27:41 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
16:28:30 <monochrom> Oh I see, after hand-fusing sum / length, yeah the call-back you pass to foldl' is identical to the loop body in C.
16:28:54 <Saizan> uhm, yeah, we don't have a good solution for monadic HOFs like that, and no solution in the standard libraries
16:29:13 <ddarius> vixey: You shouldn't be universally quantifying the parameter to ST.
16:29:25 <vixey> Well I got this, which typechecks
16:29:25 <vixey> type Logic a = forall r r'. SG r (ST r') a
16:29:25 <vixey> runLogic :: Maybe Int -> Logic a -> [a]
16:29:25 <vixey> runLogic n m = runST (observe (bagofN n m))
16:29:37 <vixey> so I might be on the right track.. hard to tell..
16:29:39 <monochrom> ehird: You can't escape IO! :)
16:29:46 <ehird> monochrom: Tell me about it
16:29:59 <vixey> wait this is wrong
16:30:06 <coffeemug> hello
16:30:12 <vixey> so something like type Logic r' a = forall r. SG r (ST r') a -- instead?
16:30:19 <ehird> http://hpaste.org/7642
16:30:24 <ehird> Wub for whoever comes up with a good idea.
16:30:32 <ehird> -- This is the function that I cannot move away from IO.    <-- the bit to look for
16:30:32 <coffeemug> I have a somewhat theoretical question not quite related to Haskell, but I thought this may be a good place to ask. Does the fact that Prolog turn out to be a fully featured programming language somehow imply anything about Turing-completeness of first-order logic?
16:30:38 <ddarius> Yes.  I don't know what SG is so I don't know about that.
16:30:40 <ehird> coffeemug: It is, yes.
16:31:06 <monochrom> ehird: http://arcanux.org/lambdacats_2.html#entry2 :)
16:31:06 <lambdabot> Title: Lambdacats
16:31:30 <coffeemug> ehird: "yes" meaning this is a good place to ask, or "yes" meaning first-order logic is somehow isomorphic to a turing machine?
16:31:41 <monochrom> yes coffeemug. both. :)
16:31:48 <ehird> coffeemug: A quantum superposition of both!
16:31:54 <ehird> You'll have to look inside the box.
16:32:04 <coffeemug> :)
16:32:17 <vixey> A specific proof search mechanism for first-order logic is turing complete...
16:32:24 <ehird> But yes, first person to find a way to liftIO/stuff that one last function in scgi gets my wub forever.
16:32:26 <vixey> first-order logic is just a way to write statements
16:32:43 * monochrom traps ehird inside the quantum IO box. You have to look inside the box, and then you can't get out!
16:32:43 <coffeemug> is this related to Howard-Curry isomorphism?
16:32:58 <ehird> monochrom: Terribly helpful character, you are :P
16:33:07 <coffeemug> I am trying to find some information on this, but I am not quite sure what to look for
16:33:49 <ehird> coffeemug: Completely off-topic, but I like your essays.
16:34:19 <coffeemug> ehird: thank you, occassionally some of them are good :)
16:34:56 <saml> when did Dr. Howard and Dr. Curry become isomorphic?
16:35:05 <coffeemug> I'm actually writing one on Prolog, but I am stuck because I can't figure out what is the mathematical implication fo Prolog's ability to express arbitrary programs
16:35:08 <ehird> saml: Wioll haven been.
16:35:17 <vixey> coffeemug: ugh..
16:35:17 * qwr suspects, that thee is typo (reading dons post)
16:35:24 <ehird> coffeemug: That Prolog is able to express arbitary programs
16:35:26 <vixey> coffeemug: why did you pick Prolog?
16:35:44 <ehird> vixey: So you would go 'ugh'?
16:36:08 <coffeemug> vixey: I'm writing about AllegroCache, and AllegroCache databases can be queried with Prolog. So I'm doing a side note on Prolog.
16:36:59 <coffeemug> Querying AllegroCache and trying to figure out first-order logic and turning completeness isomorphisms are somewhat unrelated, but I like to learn as much as I can about things before I talk about them :)
16:37:28 <ehird> coffeemug: Beware. The lisp-hating #haskell denizens come out right about now.
16:38:15 <coffeemug> ehird: we all have a common ancestor - lambda calculus. We must learn to live together as brothers or perish together as fools :)
16:38:42 <ehird> coffeemug: lisp diverged from the lambda calculus fairly early on (epoch) ;)
16:39:03 <ehird> strict evaluation? zero-adic functions? (indeed, non-1 adic)? what is the meaning of this heresy?!
16:39:12 <vixey> ehird: evaluation order has nothing to do with lambda calculus
16:39:24 <ehird> vixey: oh, not this again
16:39:36 <ehird> aren't you the one who left #esoteric in a huff after a big peice of crap about this?
16:39:39 <coffeemug> yeah, that's a can of worms :)
16:39:40 <ehird> and then later /msg'd me
16:39:48 <ehird> calling me an idiot, IIRC
16:47:31 <dons> qwr: thansk
16:47:42 <qwr> :)
16:48:10 <dons> heya coffeemug. how's code?
16:48:46 <chessguy_> @type interact id
16:48:47 <lambdabot> IO ()
16:48:53 <coffeemug> hi dons! Long time no speak
16:48:58 <coffeemug> code is well
16:49:02 <chessguy_> @src interact
16:49:02 <lambdabot> interact f = do s <- getContents; putStr (f s)
16:50:10 <coffeemug> how's Galois treating you?
16:50:29 <chessguy_> am i understanding correctly that interact id will simply echo back whatever you type?
16:51:13 <edwardk> yes
16:51:25 <chessguy> hm, interesting
16:51:37 <vixey> how about this?
16:51:38 <vixey> type Logic s a = forall r. SG r (ST s) a
16:51:42 <vixey> runLogic :: Maybe Int -> (forall s. Logic s a) -> [a]
16:51:55 <vixey> I have no idea what that forall s. does but it typechecks.. :/
16:52:09 <chessguy> i suppose i could have just tried it :)
16:53:56 <ehird> Anyone have a fastcgi or a cgi library that does not have the type restriction?
16:54:02 <ehird> And I will love you, forever.
16:54:21 <Heffalump> I vaguely recall hacking cgi to have a MonadIO type
16:55:35 <dons> coffeemug: good. lots of fun and interesting stuff to do
16:56:37 <monochrom> vixey: One day you will understand. But simply put it is due to the type of runST, who imposes the very same forall s requirement.
16:56:45 <dcoutts> here's a nice cheap way of handling long running calculations:
16:56:46 <Saizan> vixey: it's so runLogic gets to choose 's' (and in turn provides this freedom to runST)
16:56:46 <dcoutts> data Progress step fail result = Progress step (Progress step fail result)
16:56:46 <dcoutts>                                | Fail fail
16:56:46 <dcoutts>                                | Done result
16:57:07 <coffeemug> monochrom, ehird: do you guys have anything else to say on the topic other than "yes"? :)
16:58:00 <Heffalump> ehird: no, I think I just arranged to run the CGI computation at the top-level and to unwrap the monad from inside it first.
16:58:23 <dcoutts> eg, dependencyResolver  :: Progress String String InstallPlan
16:58:26 <Heffalump> it probably doesn't make sense to have a more general type since the web doesn't actually support arbitrary monad transformers..
16:58:33 <ehird> Heffalump: Yeah, the problem is I have another function in that monad I want to execute at the start.
16:58:42 <ehird> Heffalump: And it does so. Look at runCGI's type.
16:58:45 <ehird> runCGI has it right.
16:58:48 <ehird> runFastCGI, runSCGI, don't.
16:59:31 <Heffalump> hmm, true
16:59:55 <monochrom> On the subject of forall, especially forall inside parentheses, I recommend learning higher-rank polymorphism and/or predicate logic.
17:00:35 <ehird> Heffalump: So yah. I want a runFastCGI like runCGI.
17:00:42 <ehird> If you can do that, I may have to arrange either wub or moneys.
17:00:48 <ehird> Though I don't know how much moneys. :P
17:05:30 <monochrom> Oh, coffeemug means on the subject of Prolog's Turing-completeness. Use first-order logic to do a bit of Peano arithmetic, and you'll run into the same difficulty as the halting problem.
17:06:01 <chessguy> i need to add an accumulator to foldl'. do i want scanl' or something?
17:06:06 <chessguy> @type foldl'
17:06:08 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:06:30 <dcoutts> chessguy: foldl has an accumulator, that's kind of the point of it
17:06:42 <Heffalump> ehird: I don't use fastcgi, sorry.
17:06:47 <chessguy> err, i need another accumulator
17:06:54 <ehird> Heffalump: scgi
17:06:55 <dcoutts> chessguy: (,) ? :-)
17:06:57 <Heffalump> why can't you just hack it locally for now?
17:07:01 <Heffalump> I don't use that either
17:07:08 <ehird> and 'cause it uses a lambda inside alloca to run the app, Heffalump
17:07:12 <ehird> there's no way it can do anything but IO
17:07:43 <Heffalump> inside *alloca*? As in memory allocation?
17:08:11 <dcoutts> @type alloca
17:08:13 <lambdabot> Not in scope: `alloca'
17:08:17 <dcoutts> bah
17:08:20 <Heffalump> and the only reason for your newtype is so you can run something else first, but inside the lambda?
17:08:54 <dcoutts> @type Foreign.Marshal.Alloc.alloca
17:08:55 <lambdabot> forall a b. (Foreign.Storable.Storable a) => (GHC.Ptr.Ptr a -> IO b) -> IO b
17:09:57 <Heffalump> you could at least hack it to allow an extra parameter that does get run inside the lambda, if so
17:11:00 <chessguy> @type repeat
17:11:02 <lambdabot> forall a. a -> [a]
17:12:00 <chessguy> @type iterate
17:12:02 <lambdabot> forall a. (a -> a) -> a -> [a]
17:12:49 <coffeemug> ok, thanks for the help everyone!
17:14:43 <travisbrady> how does one convert an Integer to an Int?  i need an Int for replicate
17:15:01 <Trinithis> anyone know category theory references for newbies?
17:15:09 <spainish> hello :)
17:15:25 <vixey> :t fromIntegral :: Integer -> Int
17:15:27 <lambdabot> Integer -> Int
17:15:27 <Trinithis> genericReplicate
17:15:43 <Trinithis> :t genericReplicate
17:15:44 <ehird> <Heffalump> inside *alloca*? As in memory allocation?
17:15:45 <ehird> yes
17:15:45 <lambdabot> forall i a. (Integral i) => i -> a -> [a]
17:15:48 <ehird> alloca is CPS
17:15:53 <ehird> alloca (\ptr -> ...)
17:15:59 <ehird> it runs the prog in there
17:16:01 <ehird> but it must be in IO.
17:18:08 <Saizan> ehird: use malloc/free
17:18:20 <ehird> Saizan: It's fastcgi's code.
17:18:32 <ehird> How can I emulate alloca with malloc/free?
17:19:26 <cjb> hm.  alloca() allocates on the stack, right?
17:19:33 <chessguy> @pl parseBoard fen board = snd (flip (foldl' place) fen (x, board))
17:19:34 <lambdabot> parseBoard = (snd .) . (. (,) x) . flip (foldl' place)
17:19:37 <travisbrady> thanks Trinithis
17:19:37 <cjb> and malloc() allocates on the heap, so I don't see how you could emulate one with the other.
17:20:28 <Trinithis> travisbrady: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#26
17:20:29 <lambdabot> http://tinyurl.com/yhrw65
17:20:37 <Saizan> cjb: the documentation doesn't say anything about that
17:20:39 <dcoutts> cjb: actually alloca allocates on the ghc heap
17:20:42 <Saizan> in fact allocaBytes size  = bracket (mallocBytes size) free
17:20:56 <Saizan> for $COMPILER /= GHC
17:21:29 <ehird> saiam: and for $COMPILER == GHC?
17:21:34 <cjb> dcoutts: Oh!  I thought we were talking libc.
17:21:51 <Saizan> ehird: http://haskell.org/ghc/docs/latest/html/libraries/base/src/Foreign-Marshal-Alloc.html#alloca <-- weird primitives
17:21:52 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6gk6h7
17:21:53 <cjb> Sorry, I didn't realize it was a question in context.
17:22:05 <dcoutts> cjb: it acts in a similar way to the C alloca in that it's block structured
17:22:26 <Saizan> ehird: so your problem is still bracket/catch
17:22:58 <ehird> Saizan: Ha!
17:23:01 <ehird> Saizan: So what can I do?
17:23:07 <ehird> Can I do something with catch, for example?
17:23:09 <chessguy> @pl \s -> iterate f s !! n
17:23:09 <ehird> @src bracket
17:23:10 <lambdabot> bracket before after thing = block $ do
17:23:10 <lambdabot>     a <- before
17:23:10 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
17:23:10 <lambdabot>     after a
17:23:10 <lambdabot>     return r
17:23:11 <lambdabot> (!! n) . iterate f
17:23:16 <Saizan> ehird: forget about exceptions?:)
17:23:20 <ehird> I can implement bracket for non-IO, Saizan, right?
17:23:23 <ehird> Well.
17:23:27 <ehird> I can implement bracket for MonadIO
17:23:27 <ehird> that is
17:23:36 <Saizan> can you?
17:23:44 <chessguy> @pl \f n -> (!! n) . iterate f
17:23:44 <lambdabot> flip ((.) . flip (!!)) . iterate
17:24:02 <chessguy> @pl \n f -> (!! n) . iterate f
17:24:03 <lambdabot> (. iterate) . (.) . flip (!!)
17:24:12 <ehird> saiam: Can I?
17:24:14 <ehird> saizan
17:24:58 <Saizan> i don't see how, with only MonadIO
17:26:11 <ehird> Saizan: what else do I need? monaderror?
17:26:13 <Saizan> you need something like unlift :: m a -> IO a, quicksilver wrote a class like this, there should be a -cafe post or something with hpaste but i can't find anything since the class was called With iirc
17:26:45 <ehird> Saizan: I'm sure I dont' really need an unlift like that.
17:26:49 <Saizan> ah right, monaderror should work
17:26:50 <ehird> Because that amounts to 'run' for Nomic.
17:26:57 <ehird> Saizan: OK.
17:27:04 <ehird> genericBracket - next project.
17:27:11 <Saizan> ?type catchError
17:27:13 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
17:27:22 <ehird> :t Control.Exception.bracket
17:27:25 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
17:27:42 <Saizan> the problem is block/unblock now :)
17:28:30 <ehird> :t block
17:28:31 <ehird> :t unblock
17:28:32 <lambdabot> Not in scope: `block'
17:28:33 <lambdabot> Not in scope: `unblock'
17:28:33 <ehird> Asdasd
17:28:37 <ehird> :t Control.Exception.block
17:28:41 <lambdabot> forall a. IO a -> IO a
17:29:00 <ehird> @src Control.Exception.block
17:29:00 <lambdabot> Source not found. Are you on drugs?
17:29:54 <Trinithis> block (IO io) = IO $ blockAsyncExceptions# io
17:31:34 <ehird> Trinithis: Oh dear. #
17:31:56 <Trinithis> ehird: are # variables primitives?
17:32:16 <Saizan> Trinithis: yup, GHC's internals
17:32:40 <ehird> Trinithis: Yep
17:35:27 <Saizan> ehird: do you really need to be in your custom monad after runFastCGI returns?
17:37:21 <ehird> Saizan: No. Just before.
17:37:27 <ehird> And I only want to 'run' it once.
17:37:31 <ehird> (Because it connects to a db and stuff.)
17:40:49 <ehird> Saizan: Why do you ask?
17:42:25 <Saizan> ehird: because with a function :: (m CGIResult -> IO CGIResult) -> CGIT m CGIResult -> CGIT IO CGIResult, you could use the normal runFastCGI
17:42:54 <Saizan> or you can write a runFastCGI that takes that function as parameter
17:43:22 <ehird> Saizan: ok that amounts to runNomic.
17:43:28 <Saizan> yeah
17:43:36 <ehird> Saizan: but Nomic is designed to be long-running.
17:43:42 <ehird> Or rather, it performs better the longer it lasts.
17:43:51 <ehird> Which is why I'd like to have one runNomic, around the whole of main
17:44:32 <Saizan> ah, ok, so runFastCGI is not roughly at the top of your main
17:46:01 <ehird> Saizan: nope
17:46:04 <ehird> it looks like this, basically:
17:46:13 <ehird> main = runNomic $ do nomicInit; runFastCGI nomicMain
17:46:21 <ehird> nomicMain is in App, which is a CGIT over Nomic
17:46:24 <ehird> runCGI lets that type
17:46:26 <ehird> runFastCGI does not.
17:47:49 <Saizan> well that can written as runFastCGI runNomic (nomicInit >> nomicMain)
17:48:36 <ehird> Saizan: No it cannot. Then nomicInit is run on each request.
17:48:43 <ehird> ... Which defeats the point of a long-running process.
17:49:32 <petekaz> Anyone read dons most recent blog post?  I have a question.
17:49:39 <djd2tq> Hi everyone,  I'm new to haskell; working through YAHT and I'm stumped by exercise 4.7.  Can anyone give me a hint on how to implement that function to convert the Tuple data type to a Haskell tuple?
17:50:01 <Saizan> petekaz: many have
17:50:26 <vixey> djd2tq: pattern matching maybe
17:50:53 <petekaz> In the section "Lazy lists are OK", doesn't that tail recursive loop just generate a bunch of thunks?  go (s+x) (l+1) xs??
17:51:18 <chessguy> @docs
17:51:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
17:51:37 <petekaz> I would have thought go would be defined using bang annotations:  go !s !l (x:xs)
17:52:09 <petekaz> What am I missing?
17:52:19 <chessguy> @hoogle separateBy
17:52:20 <lambdabot> No matches found
17:52:26 <petekaz> + is not strict right?
17:52:49 <Saizan> (+) is strict but that's not the point
17:53:11 <Saizan> what's the other equation for go?
17:53:34 <ddarius> You're missing the fact that (with -O or -O2) GHC does strictness analysis
17:53:53 <Saizan> djd2tq: well first of all, think about which type your function should have
17:54:40 <petekaz> go s l [] = s / fromIntegral l
17:55:06 <petekaz> ddarius: I didn't know that.
17:55:07 <Saizan> petekaz: so yes, the strictness is fully inferred by GHC
17:55:44 <petekaz> ddarius: Is it a good idea to assume this will be done?  Wouldn't it be best to use ! patterns to make it clear?
17:57:06 <djd2tq> Saizan: yeah so my function should take in a Tuple type and return a haskell tuple.  The Tuple type is of the form "Tuple a b c d" and I have constructors "Single a", "Double a b" etc.  But I'm not sure how convert that to a haskell tuple "a, (a, b)..."
17:57:57 <djd2tq> I tried create a datatype like "Either a b c d = a | (a, b)..." but that produces an error because of missing constructor names right?
17:58:07 <Saizan> right
17:58:35 <Saizan> but, you've already seen an Either a b = Left a | Right b, right?
17:58:39 <djd2tq> so I tried pattern matching with the function "htuple(Single a) = a ; htuple(Double a b) = (a, b)"
17:59:01 <djd2tq> but I get an error on that about Show
17:59:05 <Saizan> djd2tq: that can't work since "a" and "(a,b)" have different types
17:59:14 <djd2tq> right.. so I'm confused :)
17:59:16 <Saizan> in general
17:59:30 <Saizan> ok
17:59:43 <Saizan> so, your Either a b c d idea was fine
17:59:52 <ddarius> petekaz: I don't like relying on strictness analysis, though in some cases you can be pretty certain it will be done (and you can always check)
18:00:34 <Saizan> but you indeed need constructors. so it will look like data Either a b c d = First a | Second (a,b) | Third (a,b,c) | Fourth (a,b,c,d)
18:01:15 <Saizan> djd2tq: so you see how to write a function of type Typle a b c d -> Either a b c d ?
18:01:20 <djd2tq> Saizan: ok so what am I missing then? "htuple(Single a) = First a" ?
18:01:29 <Saizan> yeah.
18:01:43 <djd2tq> but I thought the point of the exercise was to get "htuple(Single a) = a"
18:01:56 <vixey> try
18:02:03 <vixey> htuple(Single a) = North a
18:02:05 <Saizan> djd2tq: the point of the exercise is to make you realize that's impossible :)
18:02:19 <vixey> htuple(Double a b) = East (a,b)
18:02:20 <vixey> ...
18:02:21 <djd2tq> ok! :)
18:02:33 <djd2tq> cause it seemed like that
18:02:43 <Saizan> djd2tq: because all the equations of a function must return a value of the same type
18:02:55 <djd2tq> geez ok that's for the thunk on the head.. gotcha..
18:03:20 <djd2tq> coming from languages like ruby and c... this is different
18:03:38 <djd2tq> Saizan, vixey: thanks for clarifying
18:03:42 <vixey> anyone got a pdf of Algebra of programming using dependent types ?
18:03:42 <ddarius> functions have to return values of the same type in C too
18:03:49 <ehird> djd2tq: thunk on the head! hahaahha
18:03:59 <Saizan> the commond solution to that exercise is actually fromTuple :: Tuple a b c d -> Either (Either a (a,b)) (Either (a,b,c) (a,b,c,d)) with Prelude's Either
18:04:05 <djd2tq> ddarius: you're right
18:05:39 <petekaz> ddarius: how does one check?  do you mean just run and see if it crashes?  or is there some other means of checking?
18:06:17 <Saizan> petekaz: reading the core :)
18:06:50 <GavinMcG> Hi all. I'm reading Yet Another Haskell Tutorial (successfully and enjoyably, so far) and came to the recursion example of how to find a list's length:
18:06:56 <GavinMcG> my_length (x:xs) = 1 + my_length xs
18:06:59 <petekaz> Okay.  So I would see lots of 'let's?
18:07:01 <GavinMcG> I understand how it works, and what is happening (the tail of the list is being passed along to the next recursion) but I am not sure how to read or use (x:xs). What does it mean?
18:07:26 <vixey> GavinMcG: [1,2,3] = (1:(2:(3:[])))
18:07:32 <vixey> GavinMcG: It's just two ways to write the same thing
18:07:53 <ehird> :\
18:07:55 <vixey> GavinMcG: so you have (head:tail), head is one element from the list, nad tail is everything else
18:09:30 <GavinMcG> vixey: so when I declare a function using (x:xs) as an argument, it's as though I'm not only expecting a list as an argument, but I'm preemptively splitting it into head and tail, so to speak?
18:09:38 <vixey> yes exactly
18:10:02 <GavinMcG> vixey: is (x:xs) used in ways other than function declaration?
18:10:11 <vixey> yes
18:10:23 <ehird> GavinMcG: yes
18:10:24 <ehird> you can do this
18:10:25 <ehird> 1:2:[]
18:10:29 <ehird> try it
18:10:36 <ehird> [1,2,3] is just sugar for 1:(2:(3:[]))
18:10:55 <Saizan> GavinMcG: have you learned about pattern matching in general?
18:11:01 <ddarius> petekaz: There's a notation that GHC uses that states the strictness of arguments to functions in one of its intermediate outputs.
18:11:16 <GavinMcG> ehird: I understand consing and the sugar, but is the actual representation "(x:xs)" used outside of function declaration?
18:11:28 <ehird> GavinMcG: Yep
18:11:35 <ehird> data [] a = [] | a : [a]
18:11:49 <ehird> GavinMcG: Read as 'A list of a is either [] or an a : [a]'
18:11:57 <ehird> GavinMcG: So lists are linked lists, defined recursively.
18:12:02 <GavinMcG> ok
18:12:09 <GavinMcG> thanks ehird, vixey
18:12:13 <ehird> np :)
18:19:32 <ari> @djinn b -> (a -> b) -> Maybe a -> b
18:19:33 <lambdabot> f a b c =
18:19:33 <lambdabot>     case c of
18:19:33 <lambdabot>     Nothing -> a
18:19:33 <lambdabot>     Just d -> b d
18:20:20 <geezusfreeek> :t maybe
18:20:36 <lambdabot> thread killed
18:20:44 <geezusfreeek> ...
18:20:51 <geezusfreeek> :t maybe
18:20:54 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:21:00 <geezusfreeek> ari: ^
18:28:37 <vixey> how do you write an efficient evaluator for a lazy language?
18:30:55 <bd_> vixey: by making things strict when you can't tell the difference :)
18:32:09 * SamB curses Agda for using capital sigma instead of a sum symbol for the main type exported by Data.Product
18:32:50 <bd_> vixey: for example: http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/04#strict
18:32:51 <lambdabot> Title: Haskell hacking
18:33:25 <ddarius> vixey: How efficient is "efficient" in this context?
18:33:55 <vixey> well one step away from the most naive possible implementation
18:34:35 <bd_> http://www.cse.unsw.edu.au/~dons/blog/2008/05/16#fast "Writing Haskell as fast as C" might be of interest as well
18:34:38 <lambdabot> Title: Haskell hacking
18:34:56 <vixey> bd_: It's cool stuff I just saw that earlier today
18:36:06 <mxc> was actually just reading dons post about that
18:38:11 <mxc> am curious though, say I have something of the type [(int, ByteString, a,[b],[c])] or something arbitrarily complex like that, is there a simple way to force the entire thing to be strictly evaluated?
18:38:39 <mxc> without resorting to using putStrLn . show or something like htat
18:38:45 <dons> sure, `seq` .
18:38:54 <dons> but i'd probably define a strict pair for that
18:39:21 <dons> data T a b c = T !Int !ByteString !a [b] [c]
18:39:22 <dons> or some such
18:39:34 <mxc> its actually a [MyRecord] type, so if I !bang all of the fields then they will always be hnf?
18:39:37 <twanvl> You should never use tuples that complex
18:39:51 <dons> yeah, but banging everything may be a pessimism.
18:40:02 <mxc> twanvl agree, and I dont, was only for an example
18:40:08 <ddarius> vixey: "Compiling" to supercombinators is a possibility
18:40:09 <dons> typically, it only makes sense to bang atomic types , like Int or Double.
18:40:21 <ddarius> forcing forced things is not free
18:40:50 <SamB> dons: pessimisation
18:40:57 <alson> anyone know why happs.org is down?
18:41:03 <dons> no, i think its a pessimism :)
18:41:20 <ehird> dons: Is this the place for a lewd joke?
18:41:23 <SamB> maybe a leading cause of pessimism
18:41:44 <ehird> <dons> typically, it only makes sense to bang atomic types , like Int or Double.
18:42:01 <mxc> ehird: i've been resisting that urge, very diffcult
18:42:03 <vixey> when you have a program text made of supercombinators
18:42:07 <vixey> how do you evaluate that?
18:42:12 <vixey> in a lazy fashion?
18:42:23 <mxc> "dons> yeah, but banging everything may be a pessimism" is a classic
18:42:30 <ddarius> vixey: Yes.
18:42:32 <spainish> what uses Haskell? SKI supercombinators or Landin evaluator?
18:42:47 <vixey> ok
18:42:51 <vixey> I might give this a try then
18:42:52 <ddarius> Haskell is a programming language.
18:42:52 <vixey> thank you
18:43:31 <ehird> mxc: indeed
18:44:17 <dons> is that you, gschuett?
18:44:26 <mxc> one thing that amazes me is how its such a small group and how accessible 'patriarchs' of the language are
18:44:33 <mxc> dons - have a ton of respect for your blog and book
18:44:44 <dons> mxc :)
18:45:18 <ehird> dons is involved in real-world haskell?
18:45:20 <ehird> yeah, i'm out of touch
18:45:30 <ddarius> ehird: dons, bos and CosmicRay
18:45:49 <ehird> I will have to give that book a read then
18:46:11 <mxc> oh, dons is the only one I could figure out from the name/IRC nick
18:48:21 <ehird> haskell peeps are all totally awesome, of course.
18:48:45 <ehird> i wish the lisp community was like this, but (and lament has explained why) they're all a bunch of grumpy, bitter people ;)
18:58:00 <dmwit> ?remember dons yeah, but banging everything may be a pessimism
18:58:01 <lambdabot> It is stored.
18:59:21 <fatalerrorx> hey anyone know what up with www.happs.org
18:59:23 <fatalerrorx> ?
18:59:30 <fatalerrorx> down a few days now
19:01:21 <mxc> hm, i'm reading about a 100 MB psv file (csv, but '|' instead of commas) and parsing a subset of the fields on each line to a record of basically Maybe Doubles and ByteStrings but this seems to swallow up 1 GB of memory, any suggestions?
19:01:40 <mxc> made every field of the record strict, which helped a bit
19:02:06 <mxc> it still seems like 10 times the ram as is the filesize means i'm doing something wrong
19:02:16 <dmwit> What are you using for parsing, and have you done any profiling to see where the memory is going?
19:02:38 <monochrom> Note 100MB = 1GB / 10.
19:03:03 <mxc> right, seems strange
19:03:39 <lispy> mxc: I just got here so I prolly missed something.  Are you using bytestring?
19:03:43 <lispy> mxc: and if so, lazy or strict?
19:04:16 <mxc> bytestring
19:04:17 <mxc> ah
19:04:19 <mxc> that could be it
19:04:35 <dons> mxc, seems like a good use of splitAt, take and drop should do that in linary space.
19:04:44 <dons> use bytestrings, yeah, if you're not.
19:04:46 <monochrom> It suggests that records are not throw away.
19:08:22 <ehird> cally Maybe Doubles and ByteStrings but t
19:08:24 <ehird> 'bytestrings'.
19:11:43 <spainish> forget bytestrings, use wordstrings.
19:12:00 <spainish> for unicode 16-bit
19:13:11 <chessguy> @bot
19:13:11 <lambdabot> :)
19:13:21 <dmwit> Unicode is not 16 bit.
19:13:36 <chessguy> ok folks, i'm trying to figure something out, and i need a hint. not the answer, but just a nudge in the right direction
19:14:02 * ddarius pushes chessguy over.
19:14:30 <monochrom> @bothacked
19:14:30 <lambdabot> Unknown command, try @list
19:14:33 <monochrom> @bothack
19:14:33 <lambdabot> :)
19:14:55 <chessguy> i have runTest :: Test -> IO C, showC :: C -> String, createTest :: String -> Test. i want to write a main that uses these to continually take lines of input, turn them into tests, and run the tests
19:16:03 <dmwit> And you want a one-liner for this, or what?
19:16:25 <chessguy> i'll settle for a working function, but i suspect it will be a one-liner when i'm done :)
19:17:29 <dmwit> getLine seems to be the only other function you need.
19:17:59 <monochrom> forever (getLine >>= createTest >>= runTest >>= (return . showC) >>= putStrLn)
19:18:06 <dmwit> createTest . runTest
19:18:22 <dolio> putStrLn . showC, too.
19:18:33 <Saizan> runTest . createTest
19:18:33 <chessguy> thanks for not giving away the answer, monochrom
19:18:39 <monochrom> Haha
19:19:00 <monochrom> Oops, I forgot to hide the answer, sorry.
19:19:06 <dmwit> Well, what kind of a nudge do you want?
19:19:12 <chessguy> @type interact $ unlines . map ?f . lines
19:19:20 <lambdabot> (?f::String -> String) => IO ()
19:20:23 <chessguy> @type forever (getLine >>= createTest >>= runTest >>= (return . showC) >>= putStrLn
19:20:25 <lambdabot> parse error (possibly incorrect indentation)
19:20:45 <chessguy> @type forever (getLine >>= createTest >>= runTest >>= (return . showC) >>= putStrLn)
19:20:47 <lambdabot> Not in scope: `createTest'
19:20:47 <lambdabot> Not in scope: `runTest'
19:20:47 <lambdabot> Not in scope: `showC'
19:21:03 <dmwit> ?type forever (getLine >>= runTest . createTest >>= putStrLn . showC)
19:21:04 <lambdabot> Not in scope: `runTest'
19:21:04 <lambdabot> Not in scope: `createTest'
19:21:04 <lambdabot> Not in scope: `showC'
19:21:19 <dmwit> ?type \runTest createTest showC -> forever (getLine >>= runTest . createTest >>= putStrLn . showC)
19:21:21 <lambdabot> forall a a1. (a -> IO a1) -> (String -> a) -> (a1 -> String) -> IO ()
19:24:05 <chessguy> @pl \g (a,b) -> g a b
19:24:06 <lambdabot> (`ap` snd) . (. fst)
19:24:25 <vixey> :t \g (a,b) -> g a b
19:24:29 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t, t1) -> t2
19:24:31 <vixey> :t \g -> curry g
19:24:33 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
19:24:40 <vixey> :t \g -> uncurry g
19:24:42 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
19:24:59 <vixey> :t uncurry -- better still
19:25:00 <chessguy> @type uncurry
19:25:02 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
19:25:03 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
19:25:05 <chessguy> :)
19:25:08 <vixey> that should maybe be part of @pl
19:25:19 <vixey> then again, I have no idea how pl works
19:25:25 <dmwit> I'm surprised it's not.
19:28:53 <dons> petekaz: you had a question?
19:29:17 <dons> ah i see you had it answerred
19:36:13 <mxc> what is the difference between "maximum residency" and "total memory in use" in the SSDTERR output?
19:39:01 <Apocalisp> ?src Maybe.(>>=)
19:39:01 <lambdabot> Source not found. You untyped fool!
19:39:11 <Apocalisp> hmm... how does that work again?
19:39:15 <vixey> @src Maybe (>>=)
19:39:16 <lambdabot> (Just x) >>= k      = k x
19:39:16 <lambdabot> Nothing  >>= _      = Nothing
19:39:20 <Apocalisp> ah!
19:39:24 <Apocalisp> thanks
19:39:37 <vixey> I expected to have to try a few things :)
19:39:45 <ddarius> mxc: Presumably effectively the difference between the working set and the live set.
19:40:07 <Apocalisp> ?type (>>=)
19:40:17 <mxc> :t (>>=)
19:40:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:40:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:40:31 <mxc> is what you wnat apocalisp
19:40:34 <Apocalisp> botty is a bit slow today
19:41:30 <mxc> apocalisp:  its lazy
19:42:04 <Apocalisp> :)
19:43:31 <dons> mxc, maximum at any one time, versus total number of allocations
19:44:59 <schme_> mornin'
19:45:06 <dmwit> hiya
19:45:16 <schme_> I must say this haskell stuff kinda grows on ya.
19:47:44 <mxc> i thought that was "40,000,000,000 bytes allocated on the heap"
19:47:52 <mxc> schme_ its like a fungus in that way
19:50:13 <schme_> mxc: eeew!
19:53:03 <hexpuem> are there any win32 builds of GHC with SplitObjs enabled?
19:53:10 <mxc> i wonder what the feasibility of an H# (haskell for .Net, like F#) is
19:53:22 <mxc> dont get me wrong, I hate windows, but am kind of stuck with it
19:53:31 <schme_> Why do you hate it?
19:53:43 <mxc> windows?
19:53:47 <schme_> Yes.
19:53:54 <mxc> really want to start this?
19:54:02 <schme_> Huh. I was just wondering.
19:54:24 <schme_> I don't think I have ever run across anyone that does before. That all :)
19:54:35 <mxc> i guess my biggest issue with it is that it all feels very kludge-ish
19:54:36 <dmwit> Oh, really?
19:54:45 <hexpuem> youve never met anyone that hates windows? haha
19:54:47 <dmwit> You must not have met many eunuchs guys. =)
19:55:17 <schme_> eunuchs!?
19:55:21 <schme_> you's all crazy!
19:55:21 <mxc> you want a gui - OSX/Aqua, if you dont care about a gui, osx/linux is so very much easier
19:55:23 <mxc> simpler
19:55:30 <mxc> so much mroe available and open source support
19:55:36 <mxc> stronger, more open communities
19:55:36 <dmwit> s/eunuchs/Unix/
19:55:41 <hexpuem> why do you want to integrate with .NET anyway
19:56:01 <mxc> my firm is a very c# based firm
19:56:08 <schme_> hexpuem: Most people I meet do not have own a computer in the first place and couldn't tell a mouse from a keyboard ;)
19:56:18 <schme_> horray
19:56:21 <ozy`> mxc: everyone knows real programmers use xenix with a 110 baud terminal
19:56:31 <hexpuem> yea most people just use the pc to browse the web and check email
19:56:47 <hexpuem> no reason for them to have anything newer than a pentium 1 really haha
19:57:18 <ozy`> hexpuem: sure there is, they need multicore processors to play the multiple simultaneous flash ads in ten windows
19:57:24 <hexpuem> lol
19:57:39 <mxc> flashblock is a wonderful ff plugin
19:57:54 <schme_> I work with a windows computer. It does not seems so bad.
19:58:12 <dmwit> Don't you ever miss having control over your computer?
19:58:23 <mxc> have you used linux/os x significantly in the past?
19:58:34 <mxc> schme_
19:58:59 <schme_> control over the computer? I don't see why it matters. It's just there so software can run on it so I can get mah work done.
19:59:03 <mxc> were one to have only driven piece of sh1t yugos, one would consider them passable
19:59:21 <mxc> the control isn't the issue for me as much as the quality of the system and the ability to get work done
19:59:22 <schme_> mxc: I have never used os X. and linux I have been on since hmm.. 94 or thereabouts.
19:59:23 <ozy`> schme_: what apps do you use on windows, then?
19:59:30 <ozy`> ah
19:59:35 <schme_> ozy`: Well at work I use autocad.
19:59:47 <schme_> ozy`: at home I haven't really used windows since 2.0
19:59:50 <mxc> oh ok, thats legit then
20:00:02 * ozy` calls off the hits on schme_
20:00:08 <schme_> ??
20:00:08 <ozy`> you're good to go then
20:00:09 <mxc> if you need domain specific windows only software
20:00:11 <schme_> you's all crazy!
20:00:17 <ozy`> no u
20:00:47 <dmwit> Man, don't call off the hits.
20:01:05 <dmwit> Just because he's used Windows for a long time... Windows is still kind of sucky about control.
20:01:27 <schme_> Well as I said the place I work at has machines running windows for us. I don't especially miss any of the control. It's not like it matters, it's just there to run autocad.
20:01:32 <dmwit> Where control includes control of your software's use, code, etc.
20:02:02 <dmwit> I'm always really sad when I have to use Windows' chosen window manager, file browser, etc...
20:02:13 <schme_> right.
20:02:16 <schme_> I just use autocad.
20:03:27 <schme_> Which is just a great piece of software anyhoo :) I couldn't care less about not having source access.
20:03:30 <schme_> but oh well.
20:03:40 <schme_> I know I had some haskell related question here anyway.
20:03:43 <schme_> I forgot :(
20:04:06 <dmwit> ?faq
20:04:06 <lambdabot> The answer is: Yes! Haskell can do that.
20:04:30 <schme_> haha. if that was only the case :)
20:04:48 <schme_> dons: Someone on mah MSN sent me a link to your write haskell as fast as C thing.
20:04:56 <jdrake> I had an idea that I would like to implement, but I would like to know how one might do it in haskell (or as applicably in ocaml). I am not worrying about display right now, only theory. The idea involves a 'blueprint' can contains objects/properties. You might have a grid with certain parameters, various geometric objects such as circles. The challenge in my mind, comes when you want to change something like remov
20:04:56 <jdrake> e an object (could be a child in a recursive data structure) or change the parameters of the grid.
20:04:58 <monochrom> The proof is non-constructive. Therefore this answer is utterly useless.
20:05:03 <schme_> dons: It's odd. I have no idea why she would even have found it, or think I wanted it :)
20:05:35 <ddarius> schme_: reddit?
20:06:51 <schme_> ddarius: who?
20:07:03 <dmwit> reddit.com
20:07:08 <schme_> hmm. I'll look at that.
20:07:09 <dmwit> It was on the programming section today.
20:07:16 <ddarius> Cripes dmwit, I certainly wasn't going to corrupt him.
20:07:22 <dmwit> heh, whoops!
20:07:30 <dmwit> jdrake: Sure, what's the question?
20:08:06 <schme_> siht. what an ugly site! :)
20:08:22 <dmwit> Yep.
20:08:34 <dmwit> Best you don't ever go there again. =)
20:08:35 <jdrake> dmwit: The last sentence involves operations. How might you do them? For example, if you had a tree data structure representing your 'blueprint'; how might you remove an object that is a few levels deep, or even replace the single grid object that is there with a new one.
20:08:36 <schme_> I'll just steer clear of that one.
20:08:48 <schme_> dmwit: I'm not planning to. I didn't quite "get" it.
20:08:58 <jdrake> I don't exactly have mutability :-)
20:09:14 <dmwit> jdrake: Typically you write a function that takes the old version and produces a new, modified version.
20:09:43 <jdrake> That part I would figure. If you had more than one circle object, how might you identify the right one?
20:09:51 <vixey> jdrake: [1,2,3,4,5] is a list if you stuff it in a zipper ([],2,[3,4,5]) you can go left, right, modify or delete items from it all in O(1)
20:10:00 <dmwit> jdrake: You can use the Eq class, for example.
20:10:03 <dmwit> :t (==)
20:10:18 <lambdabot> thread killed
20:10:20 <jdrake> dmwit: That doesn't mean anything to me
20:10:25 <dmwit> jdrake: Or, you could specify a number that was an index into a list, or any of the usual things to specify which one you want.
20:10:39 <vixey> jdrake: how come you're never at the cafe anymore? :p
20:10:50 <dmwit> jdrake: Types that are an instance of Eq can be compared for equality with (==).
20:11:08 <jdrake> vixey: busy :p
20:11:41 <dmwit> Are you pretty new to Haskell?
20:11:45 <jdrake> hmm, I think what I am going to do tomorrow is implement a basic datatype.
20:12:05 <jdrake> dmwit: Yes, I have had more and more success with it each time I have delved into it a little more.
20:12:26 <jdrake> This would be the third time, the last time about a months time or more back, I did pretty good with the IO monad.
20:12:27 <dmwit> ok! =)
20:12:28 <ddarius> data BASIC = GOTO Int | LINE Int BASIC | REM String | PRINT String
20:12:37 <jdrake> ddarius: IT HURTS!
20:12:44 <jdrake> But I will likely be needing a refresher...
20:13:07 <vixey> [LINE 10 (PRINT "LAMBDA")
20:13:08 <vixey> , GOTO 10
20:13:40 <jdrake> vixey: My word!
20:13:49 <jdrake> Its GW-BASIC all over again!
20:14:00 <dmwit> jdrake: See if you can implement delete.
20:14:16 <dmwit> ddarius: Line 10 (Line 20 (Line 30 (Print "WHAT")))
20:14:33 <dmwit> jdrake: delete should take a list, and an element, and delete that element from the list.
20:14:35 <dmwit> :t delete
20:14:37 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
20:14:46 <dmwit> (You'll have to call it something other than delete.)
20:14:53 <dmwit> Here's an example of how it might be used:
20:14:57 <dmwit> > delete 'l' "hello"
20:15:00 <lambdabot>  "helo"
20:15:39 <jdrake> Could I call it delete in its own module?
20:15:48 <dmwit> No, it's in the Prelude.
20:15:54 <dmwit> So you have to play games to call it that.
20:16:00 <dmwit> Just call it "remove" or something like that.
20:18:42 <bd_> jdrake: You could actually, but you'd need to prefix all accesses with the module name
20:18:51 <bd_> (or an alias thereof)
20:19:20 <bd_> eg, Main.delete vs Prelude.delete
20:19:35 <monochrom> BASIC <3
20:20:05 <jdrake> I must sleep now
20:20:12 <jdrake> Good night; I will see you all tomorrow.
20:23:05 <schme_> Oh wait I remember.
20:23:19 <schme_> Is there a way to get Haskell more hrm... how do you say.. low level?
20:23:42 <dmwit> Like, down to pointers, or what?
20:23:50 <dmwit> There's all kinds of low-level stuff.
20:23:57 <jdrake> How about asm {   }  :p
20:24:01 <dmwit> Unboxed types, strictness annotations, IORefs.
20:24:07 <schme_> Ya. and disable the automagic memory handling
20:24:09 <ddarius> jdrake: Look at harpy.
20:24:15 <dmwit> jdrake: Well, you can use the FFI. =)
20:24:19 <schme_> jdrake: That would work ya. How do I do that?
20:24:24 <monochrom> depends on why. for performance - use performance advice. for talking to OS or hardware - use FFI.
20:24:25 <dmwit> You don't.
20:24:41 <schme_> Oh ok.
20:25:38 <schme_> We have some machines at work and at the moment the control software for them is mostly assembly and a bit of C. I thought it would be interesting to get it up to date with a more modern language.
20:25:50 <monochrom> for being low-level for the sake of low-level, no other reason - write your own haskell compiler
20:26:03 <schme_> But I seem to remember that automatic GC and such wreaks havoc on RT.
20:26:03 <dons> yeah, people have written OS kernels in haskell, you just dive in to Foreign.* , get all the low memory fiddling you want
20:26:08 <dmwit> Yeah, you should probably just go ahead and use the FFI to interface to the current controllers.
20:26:39 <schme_> dmwit: seems kind of a waste. I could just leave it as it is then :)
20:26:52 * dmwit nods
20:26:55 <schme_> dons: sounds quite interesting with the OS kernel!
20:27:56 <schme_> dons: Is it just x86 and how is the latency for it?
20:29:02 <dmwit> ?go house haskell operating system
20:29:03 <lambdabot> No Result Found.
20:29:06 <dmwit> Lies!
20:29:11 <geezusfreeek> @where house
20:29:11 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
20:29:16 <schme_> My god! it's already 5:30. I'm running late here. Well thanks for the chat there. Have a good one :)
20:30:05 <schme_> dmwit: Thank you. I'll bookmark it for later :)
20:30:32 <dmwit> That's geek code for "I will never look at this again." ;-)
20:31:00 <monochrom> @timezone
20:31:00 <lambdabot> Unknown command, try @list
20:31:04 <monochrom> @local
20:31:04 <lambdabot> Maybe you meant: localtime localtime-reply docs eval keal lojban
20:31:08 <dmwit> ?localtime monochrom
20:31:09 <lambdabot> Local time for monochrom is Thu May 15 23:31:10
20:31:09 <monochrom> @localtime schme_
20:31:11 <lambdabot> Local time for schme_ is Fri May 16 05:30:10 2008
20:31:18 <ddarius> dmwit: The stuff I do actually bookmark, I rarely look at again.
20:32:42 <schme_> dmwit: No. It's code for I'm heading off to work so I bookmark it so I can read it later.
20:32:48 <schme_> 'course I'm no geek ;)
20:32:55 <schme_> ta ta :)
20:50:34 <chessguy> my first code drop for my new Chess Library is up at code.haskell.org/ChessLibrary
20:50:40 <chessguy> comments welcome!
20:52:20 <vixey> oh excellint
20:52:29 <vixey> must havea  proper look at this tommorow
20:54:04 <swidgy> given an instance declaration "instance Whatever ((->) a) where", what would I refer to that use of -> as in order to google it
20:54:23 <vixey> why do you want to google it?
20:54:39 <vixey> just look up "Whatever" in the documentation
20:54:41 <swidgy> you know... to learn... and... stuff
20:54:49 <vixey> well what do you want to learn?
20:55:12 <swidgy> to understand what is happening with ((->) a) used in that manner
20:55:27 <swidgy> i somewhat understand, but figured some reading material would help.  can't figure out what to search for, though
20:55:30 <ddarius> :k (->) a
20:55:32 <lambdabot> Not in scope: type variable `a'
20:55:34 <ddarius> :k (->) Int
20:55:35 <vixey> (((->) a) b) = a -> b
20:55:36 <lambdabot> ? -> *
20:55:51 <chessguy> isn't that called the Reader monad or something?
20:56:01 <vixey> :t (==0) :: (((->)Int)Bool)
20:56:02 <swidgy> ahh... that rings a bell
20:56:03 <lambdabot> Int -> Bool
20:56:08 <vixey> :t (==0) :: Int -> Bool
20:56:10 <lambdabot> Int -> Bool
20:56:45 <chessguy> swidgy: could easily be the wrong monad though :)
20:56:52 <swidgy> monoid, not monad
20:57:27 <chessguy> Reader is a monad
20:57:28 <vixey> It's not a Monad
20:57:32 <vixey> It's a "Whatever"
20:58:42 <dolio> WarmFuzzyThing?
20:58:43 <swidgy> ((->) a) is an instance of Applicative, but I've seen it elsewhere.  figured there had to be an english language term for the use of -> in that context, though
20:59:00 <chessguy> swidgy: maybe this will help you get started: http://www.alpheccar.org/en/posts/show/61
20:59:01 <lambdabot> Title: A newbie in Haskell land : The (->) monad
21:00:17 <dolio> @type runReader
21:00:19 <lambdabot> forall r a. Reader r a -> r -> a
21:00:44 <swidgy> that makes sense.  (->) a b is infix for a -> b
21:02:04 <dolio> dons: My in-progress sorting stuff is in a repository at http://code.haskell.org/~dolio/usort/ if you want to run it on some more impressive hardware than I have and get some more exciting numbers.
21:02:05 <lambdabot> Title: Index of /~dolio/usort
21:04:07 <dolio> The Main.hs compiles a program that tests the introsort with random, sorted, reverse-sorted and random 0-1000 data sets.
21:06:46 <dolio> It's at around 4 seconds CPUTime to fill and sort an array of 10 million random numbers on my machine.
21:11:02 <mriou_> hi, I have a certainly dumb, n00b haskell question
21:11:18 <mriou_> the following doesn't work (error to come): readExpr = do { p <- readOrThrow parseExpr; putStrLn "abc" ; return p }
21:11:36 <mriou_> however just removing the putStrLn "abc" part fixes it
21:11:54 <mriou_> I just can't figure out why
21:12:21 <mriou_> the error is: Couldn't match expected type `(->) [Char]' against inferred type `IO'
21:12:23 <mxc> :t readOrThrow
21:12:38 <mriou_> if someone has an idea, that'd be really helpful
21:12:38 <lambdabot> thread killed
21:12:42 <mxc> :t readOrThrow
21:12:43 <lambdabot> Not in scope: `readOrThrow'
21:12:57 <mxc> @hoogle readOrThrow
21:12:58 <lambdabot> No matches found
21:13:04 <mriou_> not in scope?
21:13:07 <mxc> what is readOrThrow?
21:13:37 <monochrom> doOrDie
21:13:54 <mriou_> readOrThrow parser input = case parse parser "lisp" input of
21:13:59 <mxc> try:
21:14:03 <mriou_>   Left err -> throwError $ Parser err
21:14:10 <mriou_>   Right val -> return val
21:14:11 <mxc> do { p <- (readOrThrow parseExpr) ; putStrLn "abc" ; return p
21:14:18 <mxc> i doubt tha that will help
21:14:38 <mxc> oh
21:14:39 <mxc> what
21:14:40 <mxc> wait
21:14:45 <mriou_> doesn't help :(
21:14:45 <mxc> readOrThrow takes two arguments
21:14:45 <dolio> The problem is that readOrThrow isn't an action in the IO monad.
21:15:05 <mxc> yeah, that too
21:15:09 <mxc> :)
21:15:11 <dolio> Is it some custom parser monad you're implementing?
21:15:29 <mriou_> yes
21:15:36 * mxc is a super newbie
21:15:51 <swidgy> alright, so i think i have this ((->) a) thing figured out.  and interestingly, Applicative ((->) a) ends up abstracting SK combinatorics with pure = K and <*> = S.  i don't yet know where that leads, but that's pretty cool
21:16:21 <swidgy> i heart haskell
21:16:26 <dolio> swidgy: Also, fmap is composition.
21:16:40 <dolio> Which is what leads Cale to want to define (.) = fmap.
21:17:24 <mriou_> dolio: so basically I can't mix the IO monad and the parser monad?
21:17:44 <dolio> mriou_: Well, in a single do expression, you can more or less only use one monad. readorThrow being your monad, and putStrLn being in the IO monad won't work.
21:17:49 * mxc hums "transformers... more than meet the eye"
21:17:59 <mxc> meets
21:18:05 <mriou_> dolio, mxc: thanks for the help
21:18:12 <dolio> mriou_: Right. What you'd need to do is use a monad transformer over IO, and lift putStrLn into the transformed monad.
21:18:14 <mriou_> much appreciated
21:20:05 <swidgy> dolio: so it does.  endlessly fascinating!
21:26:15 <newsham> i'm trying to use the agda emacs interface and not getting it.  anyone know how to use this?
21:26:41 <dolio> What aren't you getting?
21:27:09 <dolio> Although, apparently SamB has already learned more of its shortcuts than I have.
21:27:26 <newsham> dolio: I do "add : Nat -> Nat -> Nat" and "add = ?" and load.
21:27:41 <newsham> then i click on the green box and select "case" and it wants me to enter some variable.
21:28:00 <newsham> but I dont know what to type there.
21:28:13 <dolio> Oh. I think you're supposed to write, like, 'add m n = ?'
21:28:23 <newsham> if I do "add a b = ?" and do the same, and enter "a" it says "Panic: passAVar: got a"
21:28:42 <dolio> Then you type in m, and it expands to 'add zero n = ... \n add (succ m) n = ...'
21:28:52 <dolio> Oh, well, that's not good.
21:29:06 <gwern> @wn furtherworse
21:29:06 <lambdabot> No match for "furtherworse".
21:29:59 <newsham> wait..yours worked with "m"?
21:30:17 <dolio> I haven't actually used that feature. I just saw people talking about it on the mailing list.
21:30:37 <dolio> Let me try now...
21:30:45 <newsham> i read the agda1 emacs page and it kind of describes this
21:30:49 <newsham> but the syntax was different
21:31:23 <dolio> Yeah, I get the same panic.
21:31:37 <newsham> (I got this panic on my own machine, but i also tried the "liveCD" from the types summer school..  so I know its not just my setup)
21:32:17 <user317> are there any examples of Data.Graph library?  its not obvious ot me how to use labels
21:32:55 <dolio> Maybe it was recently fixed...
21:32:58 <dolio> @seen SamB_XP
21:32:58 <lambdabot> SamB_XP is in #haskell-blah and #haskell. I last heard SamB_XP speak 2d 1h 9m 42s ago.
21:33:04 <dolio> @seen SamB
21:33:04 <lambdabot> SamB is in #perl6, #darcs, #ghc and #haskell. I last heard SamB speak 2h 51m 40s ago.
21:35:05 <dolio> Ooo, sections have been added.
21:37:47 <newsham> sections as in (+5) ?
21:37:59 <dolio> I assume so.
21:38:32 <dolio> I wonder if you can do stuff like 'if_then foo else bar' too.
21:39:01 <dolio> "* Added support for sections and "closed" mixfix operators."
21:40:11 <dolio> Okay, well, the emacs mode still doesn't seem to be working.
21:40:35 <newsham> so i'm doing the right thing and the emacs mode code is just outdated?
21:42:10 <dolio> I think so. Maybe I need to recompile agda, too.
21:42:37 <newsham> i'm using the livecd from types summer school
21:42:42 <newsham> i doubt its built incorrectly :)
21:43:06 <dolio> Well, the emacs mode has to talk to agda somehow, I think.
21:43:43 <newsham> this live cd came with emacs, agda-mode and agda2 all preinstalled
21:43:51 <dolio> Surely they didn't re-implement all of agda's type checking and stuff in elisp. :)
21:44:08 <dolio> Yeah. I don't know. I'll let you know if I figure it out.
21:44:25 <newsham> i think you can invoke agda in some way on files with ?'s in them
21:44:31 <newsham> to get info about the goals
21:44:36 <dolio> I need to check out these sections, too.
21:44:40 <newsham> also agda -I seems to let you do it, but i couldnt figure out the syntax
21:45:39 <dolio> --type-in-type might be handy, too.
21:47:14 <monochrom> agda has its own live cd?!
21:47:15 <newsham> so not so much ready for "interactive proof assistant" at the moment.
21:47:31 <dolio> Since agda's lack of universe polymorphism can be grating.
21:47:31 <newsham> http://typessummerschool07.cs.unibo.it/courses/binary.iso
21:47:44 <newsham> has mizar, matita, isabelle, epigram, coq and agda
21:47:53 <monochrom> this is a strange world :)
21:48:08 <dolio> I think if you want a proof assistant, you'd probably better off with coq or isabelle.
21:48:10 <newsham> now you can try em all out without installing :)
21:48:36 <newsham> i've played with isabelle a bit.  i'm still not yet into coq although i've had some false starts
21:48:40 <dolio> The agda mode is more along the lines of epigram.
21:48:53 <newsham> *nod*  although Ithinkthat makes agda a better starting point
21:49:02 <newsham> better to do it all by hand before using the shortcut tactics
21:49:16 <dolio> Although epigram almost needs the functionality, because the 2-d syntax is a pain to write by hand.
21:49:24 <newsham> i havent played with epigram yet, but now that i have livecd i think that'll be a good jupming off point
21:51:07 <newsham> although honestly the idea of being tied to a particular editor isnt that appealing
21:51:10 <newsham> (re: epigram)
21:51:25 <dolio> newsham: Okay, I've got it working with a fresh build of agda and grabbing the latest emacs mode from the repository.
21:52:12 <dolio> I typed in 'add m n = { m }0' and hit C-c C-c and it expanded to 'add zero z = { }0\n add (suc z) z' = { }1'
21:54:30 <dolio> I think one of the goals for epigram2 was to make it more editor independent.
21:54:46 <monochrom> I avoided PVS because it was also tied to emacs.
21:55:11 <newsham> hmm.. I got my "agda-mode" from the Agda2 src tree I downloaded
21:55:25 <newsham> I think it was a .tgz release.  did you grab from darcs or something?
21:56:51 <dolio> Yeah. Back when I started, the latest stable release wouldn't build, so I've been running it from darcs.
21:57:10 <solrize_> zgg
21:57:11 <solrize_> oops
21:59:26 <monochrom> this channel turns into a dependently typed channel during wee hours, when all the children are put to sleep, and the adults indulge in... adult programming.
21:59:40 <Apocalisp> :)
22:00:03 <vixey> I still wish there was a deptype channel
22:00:09 <Apocalisp> start one
22:00:42 <monochrom> A 24/7 adult channel would pose parental control problems.
22:00:54 <Apocalisp> hehe
22:01:44 <bos> @pl (\c -> b >> return c)
22:01:44 <lambdabot> (b >>) . return
22:03:40 <gwern> http://www.hackerdashery.com/2008/05/how-not-to-handle-streams.html <-- ironic given how most haskellers I've seen hate lazy io
22:03:41 <lambdabot> Title: hackerdashery: How Not to Handle Streams, http://tinyurl.com/5cqmx7
22:05:29 <awesame> haskellers hate lazy IO?
22:05:31 <awesame> that's interesting
22:05:33 <bos> well, lazy I/O isn't the answer there.
22:05:35 <awesame> why?
22:05:47 <dolio> Sections don't seem to work yet.
22:05:52 <bos> awesame: leads to nasty resource management issues.
22:06:08 <awesame> interesting
22:06:36 <awesame> so a non-lazy "read n bytes" function would be more typical in haskell?
22:06:52 <koninkje> Is there some zip-like function which returns an indication that one list was longer than the other?
22:07:11 <awesame> is there a popular example of one of those that I could look at?
22:08:16 <bos> awesame: depends on the circumstances. the built-in I/O code is either lazy or chunked, but not strict.
22:08:36 <bos> koninkje: no
22:09:00 <adu> I just found a website that called Haskell an obfuscated programming language
22:09:23 <awesame> it does remind me of perl in some ways
22:09:25 <koninkje> bos: alas. Thanks though
22:10:00 <bos> awesame: the usual solution to the read-it-all vs read-it-lazy conundrum is to read-it-via-a-left-fold.
22:10:29 <bos> haskell is like perl in the same way that nuclear missiles are like bent forks.
22:10:30 <awesame> ah, that makes sense
22:10:40 <adu> bos: lolol
22:10:47 <bd_> Hey, you can put an eye out with a bent fork.
22:10:57 <bd_> Gotta be careful.
22:10:59 <awesame> in haskell, the line noise often enables interesting new ways of expressing important concepts
22:11:08 <adu> and they're both made of atoms
22:11:13 <adu> er, i mean metal
22:11:13 <awesame> in perl it's more just new ways to shoot yourself in the foot
22:11:34 <OceanSpray> I thought that was C.
22:11:38 <dolio> Oh, maybe that darcs changelog was only talking about adding sections to the document that talks about new syntax ideas.
22:11:38 <awesame> but perl hackers feel like it's providing the same kind of expressiveness that I feel like haskell provides
22:11:41 * dolio is disappointed.
22:11:50 <adu> I love how Haskell makes it next to impossible to shoot yourself, mainly because your food is poorly typed
22:12:05 <adu> s/food/foot/
22:13:04 <OceanSpray> do you guys think there'll be a second edition of "Types And Programming Languages"?
22:13:15 <bd_> main = shoot (unsafeCast foot)
22:13:21 <adu> How would you type a foot?
22:13:44 <OceanSpray> foot :: Appendage
22:14:11 <adu> but shoot takes Target, and Appendage is not compatible
22:14:27 <adu> Target /= Appendage
22:14:57 <adu> i suppose that is where unsafeCast comes in
22:15:14 <mxc> does haskell have anything ocaml's packed binary marshalling/unmarshalling?
22:15:32 <monochrom> @hackage binary
22:15:32 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
22:15:40 <monochrom> Perhaps that's similar.
22:16:55 <Zao> There's always the Storable class too.
22:17:41 <adu> I think ByteString meets most of my needs
22:17:49 <adu> except for bits
22:18:09 <adu> which reminds me, I wrote an implementation of "class Bits ByteString" a while back
22:18:53 <adu> would anyone use that?
22:22:18 <mxc> monochrom: i see that its v. 0.4.2, does that mean that the format, or package is liable to change or still be buggy?
22:40:46 <mxc> is it safe to assume that show . read = id?
22:41:04 <Apocalisp> what's fold for the io monad?
22:41:14 <dolio> show . read is ambiguous.
22:41:33 <mxc> (show::t) . (read::t)
22:41:46 <mxc> :t foldM
22:41:47 <mxc> :t foldM_
22:41:48 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
22:41:49 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m ()
22:41:57 <mxc> for apocalisp
22:42:00 <Apocalisp> thanks mate
22:42:02 <dolio> I think it's recommended that it's id.
22:42:32 <dolio> > show (read "4%6" :: Rational)
22:42:34 <lambdabot>  "2%3"
22:42:35 <Apocalisp> :t Data.Foldable.fold
22:42:37 <lambdabot> forall (t :: * -> *) m. (Monoid m, Data.Foldable.Foldable t) => t m -> m
22:43:10 <Apocalisp> :t fold
22:43:12 <lambdabot> Not in scope: `fold'
22:43:16 <Apocalisp> :t foldr
22:43:18 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:44:42 <dolio> I guess it's more that 'read . show :: t -> t = id'.
22:46:46 <Apocalisp> wait, foldM is a fold on lists
22:47:11 <Zao> Apocalisp: Since we have the list monad, among other things, yes.
22:47:20 <Apocalisp> fold is to [] as what is to IO?
22:48:06 <mxc> as foldM is to IO [a]
22:48:34 <Apocalisp> fold is to [a] as what is to IO a?
22:48:47 <dolio> There's no catamorphism for IO. You're not supposed to get stuff out.
22:49:07 <mxc> @define catamorphism
22:49:09 <lambdabot> Undefined.
22:52:26 <petkau> I was reading the recent round of blog posts about how "avg xs = sum xs / length xs" blowing up does or does not mean that Haskell perf is hard to predict, and I thought I'd try something simpler...
22:52:41 <petkau> so I tried just plain "sum [1..1e9]"
22:52:44 <dolio> If you want to be evil, you could maybe say unsafePerformIO.
22:52:48 <petkau> That blows up too.
22:53:14 <petkau> Looking at the standard prelude, sure enough, sum uses foldl rather than foldl'
22:53:32 <maltem> petkau: -O2 should manage that
22:53:50 <petkau> Yes, but that's relying on super-clever optimization for basic correctness
22:54:01 <maltem> Sure, we're in Haskell land :)
22:55:25 <petkau> I was wondering if there was a good reason for foldl vs. foldl' there. (Since I think relying on super-clever optimziation for basic correctness is bad, even with GHC, since I tested it with GHCI and so it done blowed up on me.)
22:55:48 <Apocalisp> ?type (>=>)
22:55:50 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
22:55:54 <dolio> foldl' isn't in haskell98.
22:56:07 <Apocalisp> is >=> pronounced "fish"?
22:56:11 <maltem> btw, dons said in his blog post that he would discuss a recursive solution, and then also approaches using higher-order functions, but didn't he forget the latter then?
22:56:23 <petkau> ah, well that would be a good reason then.
22:56:35 <dolio> He's writing a sequel.
22:56:46 <maltem> Ah, that would explain it :)
22:58:14 <maltem> d'oh, it's stated in the last sentence of that post
23:00:06 <petkau> Seems like that could be the source of a lot of the complaints about performance unpredictability. There should be a warning in tutorials: "never use reverse, sum, product, maximum, or minimum on potentially large lists, unless you have enormous faith in the optimizer, because they use foldl instead of foldl' and they will make your poor computer swap 'til it dies"
23:01:11 <dolio> It swaps?
23:01:18 <dolio> Oh, I guess that makes some sense.
23:01:41 <dolio> It doesn't make it to the stack overflow. :)
23:02:18 <petkau> I assume one some intermediate-sized list it would barf on stack overflow instead.
23:02:25 <petkau> ..."on some"...
23:02:27 <dolio> Yeah.
23:02:41 <petkau> actually let me try that...
23:03:03 <spainish> Hello, Donald E. Knuth has not time for MMIX or TeX because he's dieing ... , good bye :)
23:03:28 <petkau> yup, 10^6 element list it stack overflows. 10^9 it runs out of memory.
23:04:33 <sjanssen> petkau: huh? reverse should be fine
23:04:43 <sjanssen> @src reverse
23:04:44 <lambdabot> reverse = foldl (flip (:)) []
23:04:50 <sjanssen> that is perfectly okay
23:05:18 <petkau> I just grepped for 'foldl' through the standard prelude and listed everything I found
23:05:24 <mxc> petkau - isn't foldl better if you need to run the hold list since its tail recursive?
23:05:33 <mxc> @src foldl
23:05:33 <lambdabot> foldl f z []     = z
23:05:33 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:05:33 <mxc> @src foldr
23:05:34 <lambdabot> foldr f z []     = z
23:05:34 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:05:40 <sjanssen> petkau: the foldl for reverse is okay since it is a direct constructor application
23:06:10 <sjanssen> but yes, sum, product, maximum and minimum have problems as they're written in the Haskell '98 report
23:06:33 <petkau> I apologize for my sloppy greppage.
23:06:37 <mxc> @src sum
23:06:37 <lambdabot> sum = foldl (+) 0
23:06:46 <petkau> Hopefully reverse will forgive me.
23:06:49 <mxc> isn't that as good as you can get?
23:07:00 <sjanssen> petkau: no problem, knowing that foldl (flip (:)) is okay is fairly deep knowledge :)
23:07:10 <sjanssen> mxc: you'll want foldl'
23:07:22 <mxc> oh ok
23:07:40 <maltem> You may of course argue that foldl should be the strict fold, and foldl' (or something) the lazy one, and similar for sum etc.
23:08:02 <mxc> then thats an argument about strict vs lazy
23:08:05 <mxc> evaluation
23:08:28 <sjanssen> reverse is just about the only worthy use of foldl
23:08:48 <maltem> On the other hand, the rule "everything is lazy, and if there's a ' version, that should be a stricter variant" is fairly easy to remember
23:09:39 <dolio> What about 'the one without a prime is the one you always want to actually use'? :)
23:10:02 <maltem> That would raise the question "why they're not swapped, then?"
23:10:03 * sjanssen tries to think of other functions with '
23:10:06 <petkau> I'd worry more about sum/product/min/max. If my program is blowing up at least various docs warn about the behavior of foldl, while I haven't read anything that warns about sum
23:10:27 <petkau> Hope that gets changed for Haskell'.
23:10:32 <dolio> There's foldr', but no one uses that for obvious reasons.
23:10:34 <maltem> petkau, right
23:10:47 <sjanssen> @hoogle foldr'
23:10:52 <lambdabot> Data.Foldable.foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b
23:10:52 <lambdabot> Data.ByteString.foldr' :: (Word8 -> a -> a) -> a -> ByteString -> a
23:10:52 <lambdabot> Data.ByteString.Char8.foldr' :: (Char -> a -> a) -> a -> ByteString -> a
23:11:05 <sjanssen> dolio: foldr' isn't in Data.List
23:11:07 <dolio> Oh right, that's only in Foldable.
23:11:20 <sjanssen> and it actually makes some sense for Foldable
23:11:32 <dolio> @hoogle scanl
23:11:32 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
23:11:32 <lambdabot> Data.List.scanl :: (a -> b -> a) -> a -> [b] -> [a]
23:11:32 <lambdabot> Data.ByteString.scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
23:12:43 <dolio> @hoogle mod'
23:12:44 <lambdabot> Data.Fixed.mod' :: Real a => a -> a -> a
23:12:44 <lambdabot> Data.Fixed.divMod' :: (Real a, Integral b) => a -> a -> (b, a)
23:12:50 <dolio> Woo!
23:14:55 <dolio> @hoogle insert'
23:14:55 <lambdabot> No matches found
23:15:20 <dolio> @hoogle insertWith'
23:15:21 <lambdabot> Data.Map.insertWith' :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
23:16:12 <dolio> I think I'm out.
23:16:40 <dolio> Of course, mod' has nothing to do with strictness.
23:16:42 <bd_> hm, insertWith isn't strict already?
23:17:02 <dolio> Nope.
23:17:25 <dolio> The map structure is strict, but it doesn't force the elements.
23:17:37 <bd_> weird. Wouldn't just about any operation on a (insertWith whatever undefined undefined ssomeMap) explode?
23:18:08 <dolio> It's strict in the key, I imagine.
23:18:20 <dolio> But not the value.
23:18:26 <sjanssen> as strict as compare on that type is, at least
23:18:45 <dolio> Yeah.
23:19:18 <dolio> So 'insertWith whatever k undefined map' will probably work.
23:19:24 <bd_> ah
23:29:16 <dolio> Timsort is pretty complicated.
23:29:25 <dolio> It's still easier to understand than smoothsort, though.
23:46:48 <Trinithis> what is timsort good for?
23:47:05 <jfredett> sorting tims?
23:47:49 <Trinithis> oh. didn;t know a tim was an object.
23:48:10 <jfredett> its not, I was being a snarky bastard... I have no idea what timsort is good for.
23:48:13 <jfredett> :)
23:48:55 <jfredett> odd, it seems that Yi is complaining about a dependency that doesn't exist. It wants Cabal v1.5.1 or better, this changelog from the dev version only goes to 1.3...
23:50:55 <dolio> It's fast, apparently.
23:51:44 <dolio> It's designed to take advantage of patterns in the data without having to write lots of special cases.
23:51:54 <jfredett> nifty
23:52:14 <dolio> Plus, it's stable, which my current introsort isn't.
23:57:04 <Trinithis> ah ok. well night
