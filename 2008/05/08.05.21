00:27:32 <wolgo|away> Man this type business is pretty darn important
00:27:50 <augustss> of course :)
00:29:08 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/7786
00:29:39 <hpaste>  thetallguy annotated "(no title)" with "RecountingRationals.hs" at http://hpaste.org/7786#a1
00:30:54 <thetallguy> Mark Dominus blogged about a paper called Recounting the rationals
00:31:33 <thetallguy> I pasted my implementation of it, which lists out the rationals in an infinite list.
00:32:00 <pejo> I can't resist this: Was the previous papers off by one?
00:32:12 <thetallguy> lol
00:34:46 <vixey> > let n = (1+) ; d = (1+).(1/).(1+) ; stratus l = map n l ++ map d l ; q e = e ++ stratus e ++ q (stratus e) in q [1] :: [Ratio Integer]
00:34:57 <lambdabot>  [1%1,2%1,3%2,2%1,3%2,3%1,5%2,4%3,7%5,3%1,5%2,4%3,7%5,4%1,7%2,7%3,12%5,5%4,9%...
00:35:25 <vixey> > let n = (1+) ; d = (1+).(1/).(1+) ; stratus l = map n l ++ map d l ; q e = stratus e ++ q (stratus e) in 1 : q [1] :: [Ratio Integer]
00:35:26 <lambdabot>  [1%1,2%1,3%2,3%1,5%2,4%3,7%5,4%1,7%2,7%3,12%5,5%4,9%7,10%7,17%12,5%1,9%2,10%...
00:36:56 <vixey> > let n = (1+) ; d = (1/).(1+).(1/) ; stratus l = map n l ++ map d l ; q e = e ++ stratus e ++ q (stratus e) in q [1] :: [Ratio Integer]
00:36:57 <lambdabot>  [1%1,2%1,1%2,2%1,1%2,3%1,3%2,2%3,1%3,3%1,3%2,2%3,1%3,4%1,5%2,5%3,4%3,3%4,3%5...
00:37:11 <thetallguy> still not quite there
00:39:09 <vixey> > let n = (1+) ; d = (1/).(1+).(1/) ; stratus l = map n l ++ map d l ; q e = stratus e ++ q (stratus e) in 1 : q [1] :: [Ratio Integer]
00:39:10 <lambdabot>  [1%1,2%1,1%2,3%1,3%2,2%3,1%3,4%1,5%2,5%3,4%3,3%4,3%5,2%5,1%4,5%1,7%2,8%3,7%3...
00:39:15 <schme> and mornin' hasell
00:39:18 <schme> haskell too
00:39:20 <thetallguy> That looks right
00:39:29 <thetallguy> Evenin', shme
00:39:41 <thetallguy> ^                                                         c
00:39:56 <thetallguy> what is stratus?
00:40:19 <vixey> > let n = (1+) ; d = (1/).(1+).(1/) ; stratus l = map n l ++ map d l ; q e = stratus e : q (stratus e) in [1] : q [1] :: [[Ratio Integer]]
00:40:20 <schme> oops
00:40:24 <lambdabot>  [[1%1],[2%1,1%2],[3%1,3%2,2%3,1%3],[4%1,5%2,5%3,4%3,3%4,3%5,2%5,1%4],[5%1,7%...
00:40:48 <thetallguy> Ooh, that's nice vixey, gets the tree structure.
00:41:10 <vixey> we start with the number 1
00:41:17 <thetallguy> Oh, I answered my own question
00:41:26 <thetallguy> stratus is the level of the tree
00:41:36 <vixey> It's no coincidence that every generated number has numerator/denominator GCD = 1
00:41:46 <thetallguy> Right.
00:42:00 <vixey> mapping n and d over each stratum is in effect the euclidean algorithm running backwards
00:46:41 <thetallguy> interesting observation
00:47:47 <thetallguy> I still haven't sorted out where the hyperbinary form comes from, though.
00:53:06 <ski_> > let n = (1+); d = (1/).(1+).(1/) in fix $ \xs -> do return 1 `mplus` do x <- xs; return (n x) `mplus` return (d x) :: [Rational]
00:53:07 <lambdabot>  [1%1,2%1,1%2,3%1,2%3,3%2,1%3,4%1,3%4,5%3,2%5,5%2,3%5,4%3,1%4,5%1,4%5,7%4,3%7...
00:53:41 <vixey> mm nice :)
00:54:11 <ski_> i like how that traverses the tree breadh-first :)
00:59:47 <vixey> I like this http://www.cs.st-andrews.ac.uk/%7Ejames/RESEARCH/Compiler_Pearl-submitted.pdf
00:59:49 <lambdabot> http://tinyurl.com/5mv7e9
01:22:29 <tilarids> hi 2 all. i am new to haskell, but i have some experience in python.
01:22:44 <tilarids> I'm unable to compile this module with ghc
01:22:44 <tilarids> module Test where
01:22:44 <tilarids> import Array
01:22:44 <tilarids> fact n = foldl (*) 1 [1..n]
01:22:44 <tilarids> get_p0_imp 0 n a ro res = res
01:22:44 <tilarids> get_p0_imp x n a ro res = get_p0_imp (x-1) n (a*ro/(n-x)) ro (res+a)
01:22:46 <tilarids> get_p0 n ro = get_p0_imp n n+1 1 ro 0
01:22:48 <tilarids> p_map ro p0 x = (/) ((ro ** x)*p0) (fact x)
01:22:50 <tilarids> get_p m l n id =
01:22:52 <tilarids>     let ro = l / m
01:22:54 <tilarids>         p0 = 1/(get_p0 n ro)
01:22:56 <tilarids>         p = map (p_map ro p0) [1..n] -- error on this line
01:22:58 <tilarids>         in  1
01:23:00 <tilarids>         
01:23:02 <tilarids> Error:
01:23:04 <tilarids>    Occurs check: cannot construct the infinite type:
01:23:06 <tilarids>       a = a -> a -> a -> a
01:23:08 <tilarids>     Probable cause: `n' is applied to too many arguments
01:23:10 <tilarids>     In the expression: n
01:23:12 <tilarids>     In the second argument of `map', namely `[1 .. n]'
01:23:14 <tilarids> I can compile this module, when I use p0 = 1 instead of p0 = 1/(get_p0 n ro) . Can someone help me with this trouble?
01:23:17 <pejo> Please use hpaste.org when pastng large chunks of code.
01:24:06 <tilarids> sorry :0
01:24:41 <vixey> tilarids: can you paste again .. but here http://hpaste.org/new ?
01:24:45 <hpaste>  tilarids pasted "Test module" at http://hpaste.org/7787
01:24:46 <mxc> wow, haskell mode for vim is great
01:25:41 <vixey> tilarids: You must use parens, get_p0 n ro = get_p0_imp n (n+1) 1 ro 0
01:26:01 <vixey> tilarids: Without get_p0 n ro = get_p0_imp n n+1 1 ro 0, is treated as (get_p0_imp n n)+(1 1 ro 0)
01:26:16 <vixey> tilarids: In general functions are binding tighter than operators
01:27:35 <tilarids> wow, thanks! it works :)
01:28:47 <vixey> Lambda* is the PTS with Type : Type?
01:28:57 <vixey> * :: *
01:31:12 <vixey> what is a non-functional PTS?
01:31:48 <ski_> maybe one in which Girards paradox can be formed in ?
01:37:01 <mattam> vixey: a PTS where the rules relation is not functional. Typically PTS with universes + a cumulativity relation are not functional.
01:37:52 <flux> hmm, often it has been said that s-expressions and xml are somewhat equivalent, but what would (foo (())) be in xml?
01:43:47 <dolio> <foo><()></()></foo>
01:44:37 <dolio> Or something of the sort.
01:44:56 <eek> I'd go for <foo><><></></></foo>
01:45:17 <dolio> Yeah, it all depends on what you think the s-expression means.
01:45:38 <vixey> <list><atom>foo</atom><list><list></list></list></list>
01:46:00 <flux> yeah, I suppose vixey's way would be it: give labels to the "empty" structures
01:46:43 <eek> I'd prefer <sexp>(foo (()))</sexp>.  it's more compact.
01:46:46 <eek> ;)
01:47:57 <osfameron> ooo, did Haskell go all XML in an attempt to woo Java programmers?
01:48:06 <tieTYT2> it's amazing to me in real world haskell how whenever i'm confused, there's a comment clarifying it
01:48:18 <tieTYT2> this is a really good way to write a book :)
01:48:59 <tieTYT2> does anyone know if the beta is generated by a haskell web framework?
01:49:35 <quicksilver> tieTYT2: no, it's not.
01:50:03 <tieTYT2> aw
01:50:08 <tieTYT2> oh well, no biggy
01:52:36 <cjs> In a situation such as (B.length s > 6 && B.index s 6 == 'F'), what's a good way to ensure that B.length is always evaluated before B.index?
01:52:53 <vixey> @src (&&)
01:52:54 <lambdabot> True  && x = x
01:52:54 <lambdabot> False && _ = False
01:53:21 <cjs> Ah, so left is always evaluated first, for the pattern match.
01:53:24 <vixey> yes
01:53:29 <cjs> Thank you.
01:53:33 <vixey> also, I wonder if it might be nice to have
01:53:43 <vixey> B.maybeIndex s 6 == Just 'F'
01:53:58 <cjs> Yes, it would be wonderful.
01:58:39 <wolfgangbeck> is there any sane reason why ghc's Networking library doesn't allow a connect after a bindSocket ?
02:07:03 <kaol> because bind (and then listen) is what the server does and connect is for clients
02:07:59 <kaol> but this is hardly specific to ghc, you can find about this in any C/UNIX network coding reference
02:12:10 <wolfgangbeck> kaol: that's wrong. if you have more than one ip address, bind lets you choose which one the connect will use as source
02:12:29 <tieTYT2> i'm a little confused here
02:12:42 <tieTYT2> hm, nm
02:12:48 <tieTYT2> i'm confused but i think i'll figure it out
02:13:29 <wolfgangbeck> if you have a private and a public ip address, your os might choose the private address as source. your code will not work unless you bind your socket to the public address.
02:15:26 <wolfgangbeck> and why does ghc try to be smarter than the underlying os anyway?
02:15:49 <cjs> What's the clever way of doing this?
02:15:52 <hpaste>  cjs pasted "nested ifs" at http://hpaste.org/7788
02:17:07 <glguy> case () of | not k2Prefix ->  … | isFuture -> … | isOption -> … | otherwise -> …
02:17:09 <wjt> It's kind of a shame that Text.Printf doesn't have a format string for instances of Show
02:17:10 <glguy> err
02:17:17 <glguy> case () of _ | not k2Prefix ->  … | isFuture -> … | isOption -> … | otherwise -> …
02:17:31 <cjs> Oh, is *that* how you do those kinds of case statements? I've been dying for that.....
02:17:47 <vixey> (-->) = (,)
02:17:48 <vixey> cond ( (p , q) : pqs ) = if p then q else cond pqs
02:17:57 <vixey> cond [ foo --> bar
02:18:04 <vixey>      , othewise --> quux
02:18:07 <vixey>      ]
02:18:14 <dmwit> vixey: You must come from lisp-land... =P
02:18:54 <vixey> I think that I stole this from chessguy
02:19:16 <hpaste>  yitz annotated "nested ifs" with "Use guards" at http://hpaste.org/7788#a1
02:20:51 <cjs> glguy, I get "Parse Error in input: |" for yours, or without the |s, "Parse error in pattern" for the first pattern.
02:21:10 <yitz> cjs: you don't need case here, just use guards. see paste.
02:21:15 <EvilTerran> there's a proposal to have the structure (case | p -> ... | q -> ... | ...) in haskell'
02:21:46 <glguy> cjs: the correction is on the second line (and yeah, in this case you can use guards on the function without the case)
02:22:00 <yitz> EvilTerran: why would we need that - yet another variation on the theme
02:22:13 <EvilTerran> yitz, er, because we like sugar
02:22:18 <yitz> yummy
02:22:23 <vixey> I don't like that
02:22:44 <EvilTerran> and having to do an extraneous pattern-match on () for no reason is a bit un-satisfying
02:22:51 <yitz> but I think our syntax is heavy enough - and flexible enough - as it is.
02:23:13 <cjs> Actually, I rather like vixey's one, too; I've always liked that in scheme.
02:23:17 <EvilTerran> there's also a proposal for (case of ...) --> (\x -> case x of ...), which definitely strikes me as nice
02:23:29 <vixey> EvilTerran: yeah that's cool
02:23:38 * EvilTerran doesn't like having to introduce single-shot variable names like that
02:24:14 <yitz> EvilTerran: ok, I'd accept that one. It's not even really an extension conceptually, just makes legal something you might anyway expect to work.
02:24:58 <yitz> > let question = "Why not, EvilTerran?" in question
02:25:00 <lambdabot>  "Why not, EvilTerran?"
02:26:12 <EvilTerran> because using a variable causes a jump in data flow from the definition of it to the use of it, which (i find) often makes code harder to follow
02:27:33 <EvilTerran> if you think of data flow in code as being mostly the directed graph yielded by following the edges of the abstract syntax tree upwards, variables introduce cross-edges and such
02:27:44 <cjs> The guards are the prettiest, I guess. I keep forgetting about them.
02:27:52 <yitz> EvilTerran: It is a jump, but it allows you to control sharing, and to simplify and modularize the expression. It's a technique that is a part of every natural language, and missing from most programming languages other than Haskell and friends.
02:28:30 <tieTYT2> can anyone recommend a good haskell editor for windows?  No i don't want to use vi or emacs
02:28:34 <EvilTerran> yitz, i'm not saying variables are unequivically bad, just that there are often cases where you have to use a variable which doesn't provide any modularity or improve sharing
02:28:37 <EvilTerran> tieTYT2, i use SciTE
02:29:06 <tieTYT2> is it easy to use?  I'd use notepad if i could configure tabs to be 1 space
02:29:13 <EvilTerran> yitz, the usual example that springs to mind being writing stuff like (\x -> case x of ...)
02:29:17 <tieTYT2> so i don't want to invest much time in to making it work well with Haskell
02:29:39 <wolfgangbeck> /leave (used mkSocket /fdSocket to fool ghc's stupid Network.Socket implementation)
02:29:39 <EvilTerran> tieTYT2, indeed. it's shockingly configurable if you can be bothered, but it has fairly sensible defaults. and there's a haskell highlighting mode available somewhere.
02:30:31 <yitz> tieTYT2: Yi. Well, someday, maybe.
02:32:39 <EvilTerran> yitz, as you've probably gathered, i'm a great proponent of pointsfree style, when it makes things cleaner. probably caught the PF bug off richard bird when he was lecturing us. :)
02:33:30 * tieTYT2 found this: http://www4.informatik.tu-muenchen.de/~haftmann/resources/haskell.properties
02:33:31 <lambdabot> http://tinyurl.com/6rygt9
02:33:41 <yitz> EvilTerran: yeah. I like pointfree - when it makes things more readable. My guide is, will this be simpler even for someone who isn't in the PF habit, and help convince them to use it more?
02:34:05 <EvilTerran> indeed, that makes sense
02:34:26 <yitz> and surprisingly, the answer is "yes" more often than you might think
02:34:30 <EvilTerran> i think bird mostly likes it 'cos it makes his equational reasoning obsession easier :P
02:34:59 <yitz> I guess it would be easier to convince someone who wants to do eq. reasoning. :)
02:35:25 * EvilTerran also caught a bit of that obsession off Bird
02:35:29 <quicksilver> I think it's fairly obvious that naming something which is only used once is not always helpful.
02:35:42 <quicksilver> naming something which is only used once is, at most, a piece of documentation.
02:35:48 <quicksilver> if it helps to give it a name, then it's worth doing.
02:35:48 <yitz> not always, but often it is
02:35:54 <EvilTerran> indeed. it doesn't improve sharing, nor does it make the code shorter.
02:36:11 <quicksilver> naming something which is used twice is, of course "the main point" of naming things at all :)
02:36:15 <EvilTerran> but, if giving an intermediate result a self-documenting name makes things clearer, i'm all for it
02:36:21 <quicksilver> I wouldn't bother to name my son if I never planned to talk about him again.
02:36:28 <EvilTerran> o.ó
02:37:11 <quicksilver> but sometimes the pointfree version is horrific.
02:37:31 <quicksilver> foo <- some long action; bar <$> nested (expression (foo)) <*> baz
02:37:49 <EvilTerran> i say, if the pf version is horrific, we need better pf combinators :P
02:38:18 <quicksilver> maybe. I'm not convinced you're right ;)
02:38:30 <EvilTerran> (ha ha only serious)
02:38:39 <quicksilver> arbitrarily deep holes in expressions which use infix operators
02:38:43 <quicksilver> is quite unpleasant.
02:38:47 <flux> let's call the better combinator "the name combinator" ;)
02:39:01 <quicksilver> arbitrarily deep holes in expressions which strictly use prefix notation is slightly more approachable.
02:39:12 <tsuwabuki> > (flip (!!)) 10000 $ map head . iterate (\s -> [x | x <- tail s, x `mod` (head s) /= 0]) $ 2:[3,5..]
02:39:17 <quicksilver> that's why I use <$> and <*> in my example.
02:39:20 <lambdabot> Terminated
02:39:28 <tsuwabuki> > (flip (!!)) 1000 $ map head . iterate (\s -> [x | x <- tail s, x `mod` (head s) /= 0]) $ 2:[3,5..]
02:39:29 <lambdabot>  7927
02:39:42 <quicksilver> @pl \x -> a <$> foo (bar z x y) <*> baz c
02:39:42 <lambdabot> (a <$>) . (<*> baz c) . foo . flip (bar z) y
02:39:53 <flux> scheme has a macro called 'cut', used like: (cut (* (/ _ 42) 2)); I could see that at times being much more readable than pf..
02:40:09 <quicksilver> flux: and we have lambda for that :)
02:40:17 <quicksilver> flux: replace cut with lambda and _ with x :)
02:40:17 <vixey> cut is awful
02:40:23 <flux> quicksilver, true, but you still need to give a name ;)
02:40:33 <vixey> _ is a name
02:40:40 <flux> but you don't need to repeat it ;)
02:40:41 <EvilTerran> and cut isn't scalable to multiple placeholders
02:40:52 <flux> at times one place holder is all you need
02:40:52 <vixey> It's just awful
02:40:52 <Dae> hi...
02:41:09 <EvilTerran> if it used something like de brujin notation, that would scale
02:41:31 <EvilTerran> (cut (cut (/ (+ x #0) #1))
02:41:36 <quicksilver> yes, and once you start scaling it
02:41:53 <quicksilver> you essentially get back to lambda notation
02:41:56 <ski_> (cut (repeat))
02:41:59 <EvilTerran> (this is not a serious suggestion. de brujin notation is not fit for human consumption, it's just nice for proving things)
02:42:12 <vixey> what's repeat?
02:42:14 <EvilTerran> (well, and executing things and whatnot)
02:42:16 <EvilTerran> ?src repeat
02:42:17 <lambdabot> repeat x = xs where xs = x : xs
02:42:28 <ski_> vixey : er, just `repeat. repeat :- repeat.'
02:42:37 <Dae> anyone got time for a newbie question? (yes, monads...)
02:43:12 <ski_> (or possibly `(and (repeat) (<= (repeat) (repeat)))' in sexprs)
02:43:28 <ski_> Dae : what about them ?
02:43:51 <EvilTerran> Dae, there's 428 people (424 if you don't count you or the bots) all sitting around on IRC. go ahead, i'm sure *someone*'s free (or at least procrastinating :P)
02:44:10 <EvilTerran> (like myself, for instance. although i have to go for a class shortly.)
02:44:42 <tieTYT2> does anyone here know how to make it so that tab in scite does 4 spaces?
02:44:51 <tieTYT2> i found a property file for haskell, but it doesn't include this feature
02:44:59 <EvilTerran> tieTYT2, "options/change indentation settings"
02:45:09 <tieTYT2> ah so built into the editor, not properties file
02:45:10 <tieTYT2> thanks
02:45:25 <Dae> I'm trying to create a function that returns a list of random numbers. This function will be called a lot, from all sorts of places. I could carry a StdGen around everywhere, but I'm given to belive that it can be done neatly with monads
02:45:57 <tieTYT2> this editor is pretty good
02:45:59 <EvilTerran> tieTYT2, to change it permanently, stick a file called SciTEUser.properties in your home directory (C:\Documents and Settings\tieTYT2 on windows), and there'll be a setting you can stick in there
02:46:00 <tieTYT2> i like how configurable it is
02:46:32 <EvilTerran> tieTYT2, have a look in SciTEDoc.html in the folder you installed to to see what the setting is
02:46:34 <paolino> Dae, you can use the State monad
02:46:42 <tieTYT2> ok thanks
02:47:09 <paolino> Dae, there is a random monad on the wiki also
02:47:23 <Dae> I know... I just spend 4 hours trying to figure this out :p
02:48:03 <Dae> randomList n = do
02:48:04 <Dae>   x <- randomRIO (1,10)
02:48:07 <Dae>   y <- x:(randomList (n-1))
02:48:08 <Dae>   return y
02:48:10 <Dae> Is what I got to. It doesn't compile (as I'm sure you'll all see immediatly)
02:48:31 <paolino> why use IO ?
02:48:49 <Dae> because the monad was already there?
02:49:02 <paolino> anyway, randomList is monadic
02:49:08 <malcolmw> gwern: in what way does hmake need updating?
02:49:31 <dmwit> Dae: This line:
02:49:32 <quicksilver> flux , EvilTerran : http://www.haskell.org/pipermail/haskell-cafe/2007-July/027848.html
02:49:33 <lambdabot> Title: [Haskell-cafe] Haskell's "partial application" (not currying!) versus Business O ..., http://tinyurl.com/32bckl
02:49:37 <dmwit> y <- x:randmList...
02:49:40 <paolino> you can*t (x:) on in
02:49:41 <quicksilver> and the following reply from Conor
02:49:42 <tieTYT2> EvilTerran: fyi, didn't seem to be necessary
02:49:44 <dmwit> Dae: Should become
02:49:51 <dmwit> y <- randomList (n - 1)
02:49:58 <dmwit> Dae: Then you can return (x:y).
02:49:59 <tieTYT2> i just changed the global properties file in the same dir as the .exe
02:50:12 <dmwit> Dae: You'll need a randomList 0 case, too.
02:50:18 <Dae> *blinks* That makes sense
02:50:41 <Dae> dimwit: yes, figured that. I had an early implementation using StdGen
02:51:06 <dmwit> Dae: There's not much you can do with things on the RHS of a (<-) until you understand exactly what's going on.
02:51:21 <dmwit> Dae: So try to keep that side small, and do all your combining in other ways. =)
02:51:44 <dmwit> Dae: As a side note: you may be interested in replicateM.
02:51:46 <dmwit> :t replicateM
02:51:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
02:52:27 <dmwit> randomList n = replicateM n (randomRIO (1, 10))
02:53:08 <Dae> Ohh, very nice :) Unfortunately the final implementation will need each of the random numbers to be in a different interval
02:53:38 <ski_> > let tick = do modify succ; get in replicateM 10 tick `evalState` 0
02:53:39 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
02:54:08 <yitz> Dae: here is a state monad already specialized for your use: http://haskell.org/haskellwiki/New_monads/MonadRandom
02:54:09 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
02:54:39 <tieTYT2> let me just say again
02:54:42 <tieTYT2> i'm glad this channel is so active
02:54:46 <tieTYT2> i'm an IRC guy
02:54:59 <yitz> Dae: even if you don't use it, it will give you some ideas :)
02:55:02 <tieTYT2> it sucks for me when a mailing list is where the community hangs out
02:55:13 <dmwit> Mail is too slow!
02:55:27 <paolino> opinable eh
02:55:30 <yitz> tieTYT2: we have one of those too
02:56:08 <yitz> dmwit: think of your statement in the context of the history of mail delivery
02:56:21 <tieTYT2> paolino: like i said before, i wouldn't have tried haskell if the community wasn't active and helpful
02:56:40 <dmwit> Ah, damn!  Your comment distracted me from my game and I lost.
02:56:44 <b_jonas> tieTYT2: I agree
02:56:46 <Dae> yitz: Hmm, ok... I'll look into that :)
02:56:51 <dmwit> =P
02:56:59 <b_jonas> the community and the libraries already available are good points of haskell and perl
02:57:12 <tieTYT2> #java is very active too
02:57:13 <b_jonas> (though some people disagree with this)
02:57:19 <tieTYT2> unlike #c (I just lucked out there)
02:57:23 <yitz> dmwit: my fault again, boo.
02:57:24 <dmwit> yitz: Yeah, I guess I really meant, "mail is too asynchronous".
02:57:31 <ttmrichter> The community surrounding Haskell is, ironically, why I'm using Erlang these days.
02:57:32 <Dae> Btw, are there anyone else mad enough to use Haskell for numerical methods?
02:57:34 <b_jonas> #c guys are awsomely fast
02:57:42 <tieTYT2> ttmrichter: meaning?
02:57:43 <b_jonas> and usually they can answer any C question
02:57:44 <paolino> tieTYT2: I think complicate things are better handled in mailing list, and you can have a nice googling in it
02:57:47 <ttmrichter> If I relied only on the Erlang community to learn functional programming I'd have given up a LOOOOOONG time ago.  :D
02:58:14 <b_jonas> ttmrichter: oh sure, I have posted lots of ruby code to perlmonks and even asked ruby questions on #perl
02:58:32 <tieTYT2> paolino: about the google comment, I disagree.  That was my main problem with the last web framework I tried.  All answers were in the mailing list.  Nobody links to mailing list threads.  Google was worthless
02:58:40 <yitz> paolino: I agree. both #haskell and the lists are essential resources. I'm glad that they're *all* so active.
02:58:49 <quicksilver> tieTYT2: the haskell mailing lists are pretty well crawled.
02:58:55 <quicksilver> tieTYT2: I often find things there with google
02:59:04 <quicksilver> (crawled, and social-bookmarked, and stuff)
02:59:07 <tieTYT2> that's good
02:59:20 <tieTYT2> that's not usually my experience
02:59:26 <quicksilver> I quite often post mailing list URLs to answer complex questions here ;)
02:59:59 <dmwit> Yeah, there's a few mailing list answers that were so good I bookmarked them.
03:00:23 <paolino> tieTYT2: haskell is also so coincise that this channel is not abused by code, so it's correct that this channel is very usable
03:00:28 <yitz> tieTYT2: there was actually a problem with that a while back with the wiki, and somebody did some research and fixed it so that google would crawl it.
03:00:37 <tieTYT2> paolino: true
03:00:45 <tieTYT2> in #java, i gotta use pastebin a lot
03:00:59 <tieTYT2> yitz: nice
03:01:28 <ttmrichter> tieTYT2: Meaning that I find the Haskell community far more responsive to fundamental theoretical issues.
03:02:11 <tieTYT2> they're responsive to annoying newbs like me :)
03:04:39 <tieTYT2> hm
03:04:56 <tieTYT2> perhaps i just figured out why you gotta say data Type _a_ ...
03:05:14 <tieTYT2> it shows that when you do a :t on a method that returns it
03:05:30 <Taggnostr> what is the ::?
03:05:50 <tieTYT2> Taggnostr: is this related to what i said?
03:05:56 <Taggnostr> nope
03:06:07 <paolino> mmhh #java is less than 300 people
03:06:19 <paolino> :: declare a signature
03:06:30 <tieTYT2> paolino: yeah but that doesn't matter
03:06:41 <tieTYT2> #mysql is huge and it's generally dead in there
03:06:47 <tieTYT2> #postgresql is totally active
03:06:51 <Taggnostr> and what is a signature? :D
03:06:56 <quicksilver> the type of something
03:06:56 <tieTYT2> the regulars matter more than the size of the channel
03:06:58 <paolino> for the left side, it forces a type
03:06:58 <quicksilver> 1 :: Integer
03:07:14 <quicksilver> (\x -> x) :: String -> String
03:07:40 <Taggnostr> I was looking at http://www.zvon.org/other/haskell/Outputprelude/readLn_f.html
03:07:41 <lambdabot> Title: Haskell : readLn
03:07:45 <b_jonas> is there even an evalbot for java?
03:08:01 <Vq^> b_jonas: yes
03:08:08 <b_jonas> good
03:08:10 <paolino> tieTYT2: java users should be 10000 times haskell ones
03:08:12 <Taggnostr> there's written getDouble :: IO Double and getDouble = readLn
03:08:14 <b_jonas> most languages have one these days
03:08:25 <quicksilver> Taggnostr: yup, that gives getDouble the type "IO Double"
03:08:53 <tieTYT2> paolino: *shrug*
03:09:03 <Taggnostr> and getDouble = readLn won't overwrite this thing?
03:09:07 <tieTYT2> quicksilver: what does  (\x -> x) :: String -> String mean?
03:09:10 <tieTYT2> i've never seen the lhs before
03:09:16 * paolino plays voodoo on the #java
03:09:36 <quicksilver> Taggnostr: no, it doesn't override. But it has to be compatible / consistent, or there is an error.
03:09:45 <quicksilver> tieTYT2: \x -> x is the funciton which, when given x, returns x.
03:10:24 <Taggnostr> when I do that thing, it means that readLn has to return an IO Double?
03:11:17 <tieTYT2> quicksilver: why did it decide it's signature is String -> String then?
03:11:20 <quicksilver> Taggnostr: well, readLn has to "be" an IO double.
03:11:21 <tieTYT2> shouldn't it be a -> a?
03:11:28 <quicksilver> tieTYT2: It didn't decide that. I did.
03:11:32 <tieTYT2> oh
03:11:47 <Taggnostr> isn't readLn a function?
03:11:56 <ski_> @type readLn
03:11:58 <lambdabot> forall a. (Read a) => IO a
03:11:59 <quicksilver> everything is a function.
03:12:01 <quicksilver> sort of.
03:12:07 <quicksilver> the distinction isn't too meaningful.
03:12:08 <ski_> do you see a `->' in the type ?
03:12:14 <quicksilver> readLn doesn't take any parameters.
03:12:15 <b_jonas> well, it has no parameters (it reads from stdin always)
03:12:22 <b_jonas> so no, it's not a function
03:12:33 <ski_> it's an (IO-)action
03:12:39 <Taggnostr> uhm
03:12:43 <b_jonas> what's funny is that it's polymorphic
03:12:51 <b_jonas> but that's what you get in haskell's type system
03:13:14 <Taggnostr> so, hwo can I use it to read something from the stdin?
03:13:19 <Taggnostr> how*
03:13:57 <ski_> do n <- readLn; print (n/2)
03:14:07 <quicksilver> main = foo <- getDouble; putStrLn ("I read the number " ++ show foo)
03:14:17 <quicksilver> oops, missing do ;)
03:14:21 <quicksilver> main = do foo <- getDouble; putStrLn ("I read the number " ++ show foo)
03:14:30 <quicksilver> normally you'd use a newline instead of a ';' semicolon
03:15:37 <Taggnostr> why I can't simply do n <- readLn?
03:15:45 <quicksilver> you can
03:15:55 <quicksilver> I was giving you an example using their getDouble that you pasted.
03:16:19 <Taggnostr> if I try n <- readLn in the interpreter I get an error
03:16:37 <quicksilver> in ghci you won't.
03:16:48 <quicksilver> I think hugs can't do IO in the interpreter but I'm not sure, I've never used it.
03:17:40 <quicksilver> the problem you will have (in the intepreter) is that readLn has an ambiguous type which will default to Integer, so you won't be able to read Doubles this way.
03:17:55 <quicksilver> in a real program the compiler has more information around to deduce types and it will often not be a problem.
03:18:28 <Taggnostr> I see
03:19:10 <tieTYT2> will f _ = ...    match a call to f a b c ?
03:19:16 <tieTYT2> i guess that's easy to test
03:19:24 <quicksilver> sort of, yes.
03:19:43 <quicksilver> but in a particular set of equations they must all have the same number of physical actual parameters
03:19:53 <quicksilver> (which is sometimes debated)
03:20:06 <mbz> hiya
03:20:23 <RayNbow> f a b c == (((f a) b) c)   -- tieTYT2
03:20:33 <tieTYT2> RayNbow: i think i just figured that out
03:20:38 <RayNbow> ok :)
03:20:43 <tieTYT2> so i should have said...
03:20:59 <tieTYT2> how the heck do i say what i meant?
03:21:38 <quicksilver> I don't know.
03:21:41 <tieTYT2> i want it call f with 3 parameters
03:21:41 <quicksilver> What do you mean?
03:21:52 <hpaste>  cjs pasted "Help with this error?" at http://hpaste.org/7789
03:21:52 <tieTYT2> so that f a b c = ... would be matched
03:22:02 <Dae> you can use if-the-else structures in monads...right?
03:22:06 <ski_> > let f = id in f id id 3
03:22:12 <matthew_-> Dae: yep
03:22:21 <lambdabot>  thread killed
03:22:26 <quicksilver> tieTYT2: "it" doesn't call f at all.
03:22:37 <quicksilver> tieTYT2: you're defining a function not calling one.
03:22:50 <tieTYT2> how do I call f with 3 parameters
03:22:55 <quicksilver> f 1 2 3
03:22:56 <cjs> Oh, never mind that one.
03:22:58 <tieTYT2> oh ok
03:23:05 <tieTYT2> oh ok
03:23:08 <tieTYT2> oops
03:23:11 <Dae> That's what i thought... so theoreticly this should work:
03:23:13 <Dae> randomList i xs a b = do
03:23:15 <Dae>  let
03:23:16 <Dae>      (li,ui) =  bounds a
03:23:18 <Dae>  if  (i < li) then
03:23:20 <Dae>      return xs
03:23:22 <Dae>  else
03:23:24 <Dae>      r <- randomRIO (a!i,b!i)
03:23:26 <Dae>      y <- randomList (1-i) (r:xs) a b)
03:23:28 <Dae>      return y
03:23:29 <Dae> ?
03:23:31 <quicksilver> Dae: don't do that thanks :P
03:23:33 <dmwit> Dae: hpaste.org
03:23:34 <matthew_-> Dae: don't flood
03:23:40 <quicksilver> it's an indentation problem
03:23:45 <matthew_-> but, you just want a do block in the else I think
03:23:47 <quicksilver> push the else in one space more.
03:23:51 <Dae> ohh, sorry guys
03:23:57 <quicksilver> and put a do block in the else
03:24:11 <tieTYT2> quicksilver: i did this: f _ = 1
03:24:12 <matthew_-> if you use { ; } then you can lay it out how you want
03:24:18 <tieTYT2> and then called it like this: f 1 2 3
03:24:20 <tieTYT2> and got an exception
03:24:33 <Taggnostr> why do { n <- readLn ; print (n^2) } works but if I remove the ^2 I get an error?
03:24:37 <quicksilver> yes, because you defined a function of type a -> Int
03:24:41 <dmwit> tieTYT2: An exception?  Not a compilation error?
03:24:46 <quicksilver> and tried to call it with 3 parameters.
03:24:53 <tieTYT2> dmwit: you're right
03:24:53 <quicksilver> you need f _ _ _ = 1 in that case.
03:25:05 <quicksilver> tieTYT2: because the ^2 helps pin down the type.
03:25:06 <tieTYT2> quicksilver: ok that's what i thought
03:25:13 <quicksilver> Taggnostr: because the ^2 helps pin down the type.
03:25:20 <tieTYT2> yet the book says that a pattern of _ is irrefutable
03:25:21 <quicksilver> Taggnostr: without that, it has no idea what type n is.
03:25:30 <quicksilver> irrefutable doesn't mean 'never a compile error'
03:25:31 <tieTYT2> i guess that means in the context of passing one param
03:25:37 <Taggnostr> can't it just print it as it is?
03:25:41 <quicksilver> no, it just doesn't mean what you think it is.
03:25:43 <dmwit> tieTYT2: Yes, it is.  It always matches (exactly) one parameter.
03:25:46 <quicksilver> irrefutable is a technical term.
03:26:00 <quicksilver> Taggnostr: haskell is strongly typed. All values have types.
03:26:09 <dmwit> Taggnostr: It doesn't know what it is.
03:26:09 <quicksilver> Taggnostr: when it compiles your code it has to decide what those types are.
03:26:10 <Dae> ok, thanks... was getting used to emacs handling the indention, but I guess it's not perfect
03:26:14 <dmwit> Taggnostr: It could be any instance of Read.
03:26:17 <tieTYT2> i thought the book was trying to tell me that if i used f _, it would match any call to it
03:26:31 <tieTYT2> but i guess it wasn't trying to tell me that
03:26:32 <quicksilver> Dae: kuribas' alternative indentation engine is much better.
03:26:45 <quicksilver> Dae: in particular I think it gets this one right.
03:26:51 <Taggnostr> so when I do ^2 it chose an instance that support that operation?
03:26:54 <dmwit> tieTYT2: The _ matches any parameter.  Then the RHS of the definition comes in to play.
03:26:57 <dmwit> tieTYT2: So:
03:27:04 <quicksilver> Taggnostr: yes, then it knows its  a number
03:27:12 <quicksilver> Taggnostr: and there is a special rule which defaults numbers to Integer
03:27:17 <quicksilver> for convenience.
03:27:24 <Taggnostr> I see
03:27:31 <quicksilver> (unless you've done something obviously fractional in which case it defaults to Double)
03:27:36 <Dae> :quicksilver Hadn't heard of that one at all.... I'll give it a whirl :)
03:27:46 <dmwit> tieTYT2: let f _ = 1 in f 1 2 3; f 1 2 3 --> (f 1) 2 3 --> 1 2 3; now, how do we treat 1 as a function and apply it to the arguments 2 3?
03:28:13 <tieTYT2> gotcha
03:28:16 <tieTYT2> i get why it broke
03:28:19 <tieTYT2> and i expected it to broke
03:28:25 <quicksilver> answer : we look for a Num instance for (a -> b) and throw out a totally incomprehensible error :)
03:28:27 <dmwit> Ah, okay then. =)
03:28:28 <tieTYT2> i was just trying to nail down the definition of irrefutable
03:28:38 <tieTYT2> i thought it meant, "matches anything"
03:28:42 <quicksilver> irrefutable means 'this pattern will match any value'
03:28:46 <tieTYT2> oh
03:28:48 <tieTYT2> you're right
03:28:50 <quicksilver> but, three parameters isn't a value
03:28:52 <quicksilver> it's three values :)
03:28:59 <tieTYT2> as dmwit just showed, it still matched
03:29:13 <dmwit> Right, f did get applied to 1 there. =)
03:29:13 <quicksilver> actually the technical definition of irrefutable is slightly more subtle.
03:29:28 <quicksilver> it means "the compiler will assume this pattern matches any value without checking"
03:29:39 <quicksilver> and then throw a runtime error later if it's wrong
03:29:44 <tieTYT2> i see
03:29:47 <quicksilver> as in the following example:
03:29:53 <quicksilver> > let Just a = Just 5 in a
03:29:55 <lambdabot>  5
03:29:58 <quicksilver> > let Just a = Nothing in a
03:30:00 <lambdabot>   Irrefutable pattern failed for pattern Data.Maybe.Just a
03:30:29 <tieTYT2> dmwit: actually, i now realize i didn't "get why" but i did expect it to break.  You taught me more than I expected with that example, thanks
03:31:26 <tieTYT2> quicksilver: what was irrefutable there?
03:31:27 <quicksilver> tieTYT2: happens surprisingly often with haskell questions :)
03:31:32 <quicksilver> tieTYT2: the pattern 'Just a'
03:31:56 <dmwit> _ is not the only way to get an irrefutable pattern.
03:31:56 <tieTYT2> ok i'm getting confused her
03:31:58 <tieTYT2> e
03:31:59 <quicksilver> it would look more like your example if I wrapped it up in a function.
03:32:11 <quicksilver> > let f (Just a) = a in f (Nothing)
03:32:13 <lambdabot>   Non-exhaustive patterns in function f
03:32:15 <tieTYT2> i don't think i ever learned that you can do let Value Constructor
03:32:24 <dmwit> > let f ~(Just a) = a in f Nothing
03:32:24 <tieTYT2> i've only been taught you can do let function or let variable
03:32:25 <lambdabot>   Irrefutable pattern failed for pattern (Data.Maybe.Just a)
03:32:29 <Taggnostr> what about do { n <- readLn ; print (n=="foo") }, if I write 2 instead of "foo" it understand that is a number and return True or False, why it fails with "foo"? can't it understand that I'm comparing it with a string so n has probably to be a string?
03:32:29 <quicksilver> thanks dmwit .
03:33:01 <dmwit> tieTYT2: Yes, you can do arbitrary patterns in a let.
03:33:06 <quicksilver> Taggnostr: yes, that should work.
03:33:28 <edwardk> @seen sclv
03:33:28 <lambdabot> sclv is in #haskell, #xmonad, #haskell-soc, #haskell-blah, #darcs and #ghc. I last heard sclv speak 3h 35m 25s ago.
03:33:29 <Taggnostr> it says *** Exception: user error (Prelude.readIO: no parse)
03:33:33 <tieTYT2> so was that let funky ghci stuff or is that legit haskell?
03:33:38 <quicksilver> Taggnostr: right. That's a runtime error. not an error with your code.
03:33:45 <quicksilver> tieTYT2: legit haskell.
03:33:49 <quicksilver> Taggnostr: your code is fine.
03:33:51 <dmwit> Taggnostr: To read a string, it has to be wrapped in quotes.
03:33:56 <quicksilver> Taggnostr: and then you typed something which wasn't a string.
03:33:57 <dmwit> > read "wrong" :: String
03:33:59 <quicksilver> (to readLn)
03:33:59 <lambdabot>  "Exception: Prelude.read: no parse
03:34:06 <dmwit> > read "\"right\"" :: String
03:34:07 <lambdabot>  "right"
03:34:12 <Taggnostr> I see
03:34:18 <edwardk> sclv: Right now my Stream monad is Cofree Identity. I've been debating about adding a simpler one for expository purposes with instances for cofree identity.
03:34:32 <edwardk> sclv: but i need to get around to adding all the traditional stream machinery.
03:34:43 <dmwit> tieTYT2: A handy way to define several variables of the same type is to pattern match on a list:
03:34:48 <ski_> Taggnostr : `getLine' is useful to just grab the next line of characters from standard input
03:34:57 <dmwit> let [a, b, c, d] = [5..8] in ...
03:35:05 <quicksilver> in fact, readLn is mostly useful with numbers.
03:35:17 <quicksilver> it's mostly only numbers you need to extra "parsing" on for which read is useful.
03:35:34 <quicksilver> obviously in a real program you wouldn't want your user needing quotes around his strings.
03:35:41 <tieTYT2> oh
03:35:44 <tieTYT2> i got really confused there
03:35:45 <Taggnostr> ok
03:35:49 <tieTYT2> so the let Just a = ...
03:35:55 <tieTYT2> a is a variable there
03:36:00 <dmwit> yes
03:36:07 <ski_> dmwit : though in some cases i really'd like a `local' in haskell ..
03:36:11 <tieTYT2> i got confused.  I thought it was somehow related to polymorphism
03:36:15 <quicksilver> tieTYT2: patterns vary fromt he simple to the very complex.
03:36:23 <quicksilver> tieTYT2: "_" and "a" are very very simple patterns
03:36:29 <dmwit> tieTYT2: Ah, a failing of idiomatic Haskell.
03:36:49 <quicksilver> tieTYT2: Just (a,Left (Just c),[x,y,Just d]) is a more complex pattern
03:36:54 <dmwit> tieTYT2: We use "a" for type variables, polymorphic values, and as a preposition when we speak. =P
03:37:02 <quicksilver> tieTYT2: patterns are allowed to nest constructors arbitrarily deep
03:37:06 <tieTYT2> what's wrong with saying let a = Just 5 ?
03:37:11 <quicksilver> tieTYT2: and use any number of "_" for bits they don't care about
03:37:12 <tieTYT2> why let Just a = Just 5?
03:37:19 <quicksilver> and any number of variables for bits they do.
03:37:23 <ski_> > let a = Just 5  in  a
03:37:24 <lambdabot>  Just 5
03:37:27 <ski_> > let Just a = Just 5  in  a
03:37:28 <lambdabot>  5
03:37:32 <ski_> > let Just a = Nothing  in  a
03:37:33 <dmwit> tieTYT2: Because in "let Just a = Just 5", the "a" is "unwrapped" from the Maybe type.
03:37:34 <lambdabot>   Irrefutable pattern failed for pattern Data.Maybe.Just a
03:37:48 <yitz> > let a = Just 5 in a
03:37:49 <lambdabot>  Just 5
03:38:06 <pip> lambdabot, Hi
03:38:09 <vixey> @xeal
03:38:09 <lambdabot> tomorrow i share next mathematical secrety
03:38:11 <tieTYT2> i see
03:38:21 <vixey> @xeal
03:38:22 <lambdabot> i changed my user od
03:38:30 <dmwit> pip: Try directing your flirts @vixen, she's more responsive. ;-)
03:38:30 <tieTYT2> kinda..
03:38:32 <dmwit> @vixen hi!
03:38:33 <lambdabot> how're you?
03:38:45 <ski_> @brain
03:38:45 <lambdabot> Well, I think so, Brain, but I can't memorize a whole opera in Yiddish.
03:38:46 <dmwit> @vixen I'm okay, but I'm a little lonely.
03:38:47 <lambdabot> ok
03:38:53 <tieTYT2> so it's like if I said let a = [1, 2, 3] in a, it would be [1,2,3]
03:38:57 <pip> dmwit, :D
03:39:02 <quicksilver> win 20
03:39:04 <yitz> @arr
03:39:04 <lambdabot> I want me grog!
03:39:05 <quicksilver> :(
03:39:05 <pip> @vixen
03:39:05 <lambdabot> If I was looking for anonymous casual sex, I wouldn't be sitting here behind my computer talking to you!
03:39:08 <tieTYT2> but if I said let [a, b, c] = [1, 2, 3] in a it would be 1
03:39:13 <quicksilver> tieTYT2: exactly
03:39:17 <ski_> tieTYT2 : yes, if you say `a' would be equal to that list, then it would be equal to that list
03:40:17 <vixey> ?vixey
03:40:17 <lambdabot> so, what made you want to message me?
03:40:21 <tieTYT2> some how this is not clicking.  I feel like there's an epiphany in this convo that i haven't reached yet
03:40:43 <quicksilver> tieTYT2: are you happy with 'case' ?
03:40:45 <vixey> tieTYT2: No, you understand it fine
03:41:03 <tieTYT2> vixey: yeah but i don't think i'll be able to apply it to new concepts
03:41:05 <vixey> @protontorpedo
03:41:06 <lambdabot> is functional ebtter than oo?
03:41:23 <dmwit> ?. vixen protontorpedo
03:41:24 <lambdabot> where on a map is Panama?
03:42:09 <tieTYT2> ok now I think i get it
03:42:14 <vixey> @xeal
03:42:14 <lambdabot> all i know is i have experienced my own death unhappening...
03:42:50 <dmwit> vixey: Any particular reason you type xeal instead of keal?  Just for fun?
03:43:20 <dmwit> ?steal
03:43:20 <lambdabot> Maybe you meant: keal spell tell
03:43:27 <tieTYT2> do i have this right: The let Just a gives you the power to pick what part of the RHS you want to be a variable
03:43:28 <vixey> the keys are next to each other
03:43:37 <vixey> I'm still using dvorak
03:43:46 <quicksilver> tieTYT2: yes.
03:44:22 <dmwit> It also allows you to claim some invariants about the RHS.
03:44:41 <tieTYT2> but it seems i can't do this: f = let a b = Just 5 in b
03:44:52 <dmwit> In the code "let Just a = <some calculation> in ...", I am claiming that <some calculation> always results in a non-Nothing value.
03:45:06 <tieTYT2> in that, i'd expect a to bind to the Value Constructor
03:45:32 <dmwit> tieTYT2: Ah, pattern matching doesn't *quite* work that way.
03:45:47 <dmwit> You have to be slightly more specific, and use the actual names of constructors.
03:45:55 <ski_> tieTYT2 : but  Just 5  =  (\f -> f 5) Just  so why wouldn't `a' be `\f -> f 5' and `b' be `Just', then ?
03:46:30 <tieTYT2> ski_: i haven't learned what \f and ` do
03:46:41 <dmwit> tieTYT2: Here's a motivating example of why what you just wrote would be a bad thing to allow.
03:46:48 <Dae> if my code is full of "fromIntegral"s, Im doing something wrong, correct?
03:46:49 <dmwit> tieTYT2: Do you know about the Either type?
03:46:53 <tieTYT2> nope
03:47:02 <dmwit> Okay, well:
03:47:08 <dmwit> data Either a b = Left a | Right b
03:47:15 <ski_> tieTYT2 : ok then take  Just 5  =  (Just . (10 -)) 5
03:47:33 <tieTYT2> donno what . does :P
03:47:41 <tieTYT2> and i've never seen something like (10 -) before
03:47:57 <tieTYT2> dmwit: ok i get it
03:47:59 <dmwit> tieTYT2: So, now, let c w = <some computation yielding an Either> in w.
03:47:59 <ski_> (tieTYT2 : the "`" and "'" were just meta-syntax for quoting, btw (as `"' was in the begininng of this sentence))
03:48:02 <Deewiant> > (10 -) 8
03:48:03 <lambdabot>  2
03:48:10 <dmwit> tieTYT2: Notice that you can't pin a type on "w".
03:48:14 <Deewiant> > ((5 +) . (10 -)) 8
03:48:16 <lambdabot>  7
03:48:19 <ski_> > (Just . (10 -)) 8
03:48:20 <lambdabot>  Just 2
03:48:22 <ski_> > (Just . (10 -)) 5
03:48:23 <lambdabot>  Just 5
03:48:27 <dmwit> tieTYT2: Since it could be either a value of type "a" or a value of type "b".
03:48:41 <tieTYT2> right
03:48:41 <dmwit> tieTYT2: You need the constructor (Left or Right) to pin down which one it is.
03:49:14 <tieTYT2> what are the ramifications of allowing that?
03:49:34 <dmwit> You drop into dynamic-typing.
03:50:07 <tieTYT2> but more direct; you don't know what type that function ended up returning?
03:50:13 <dmwit> exactly
03:50:28 <vixey> > Left . Right . Left . Right $ '?'
03:50:29 <lambdabot>  Left (Right (Left (Right '?')))
03:50:51 <dmwit> tieTYT2: So, the language simply requires that you match your patterns against constructors.
03:51:26 <dmwit> (Incidentally, let c w = <some Either> in ... is valid, but it defines a function "c" that takes a parameter "w" and yields <some Either>.)
03:52:03 <tieTYT2> hmmmm
03:52:24 <tieTYT2> so on the RHS i gotta define that function?
03:52:52 <dmwit> I think I may have to stop explaining this stuff, I'm damn near confusing myself.
03:52:54 <tieTYT2> oh right i already learned that
03:53:04 <hpaste>  cjs pasted "What's my type error?" at http://hpaste.org/7790
03:53:04 <tieTYT2> that's just a round-about way of saying you can define a function in a let
03:53:11 <dmwit> yeah
03:53:21 <cjs> Anybody have any clues for me on that? I'm missing something here....
03:53:51 <quicksilver> cjs: well, updateQuote is class-polymorphic
03:54:07 <quicksilver> cjs: so, there is a different updateQuote for each different 'Instrument' a, right?
03:54:26 <cjs> Oh, I have to do a different one? Ok, that makes sense.
03:54:40 <quicksilver> well you don't have to do anything
03:54:49 <quicksilver> but in principle there are 'separate' ones
03:54:57 <quicksilver> in the same sense that Int (+) and Double (+) are 'separate'
03:55:12 <cjs> Well, different versions.
03:55:15 <tieTYT2> something i don't think i learned is how to get the 5 out of this: let Just a = Just 5 in a
03:55:15 <quicksilver> yes.
03:55:29 <quicksilver> now the compiler has to be able to tell which.
03:55:35 <quicksilver> which it does by inferring types
03:55:37 <tieTYT2> i assume Maybe is defined in record syntax and there's some function to get it
03:55:37 <tieTYT2> ?
03:55:47 <mauke> > let Just a = Just 5 in a
03:55:48 <dmwit> What?
03:55:48 <lambdabot>  5
03:55:48 <cjs> Ah, I can use type inference on the two definitions.
03:55:50 <mauke> what?
03:55:56 <tieTYT2> sorry
03:55:57 <tieTYT2> i meant to say
03:56:02 <tieTYT2> let a = Just 5 in a
03:56:07 <cjs> So my problem is that it's currently, "updateQuote = undefined".
03:56:11 <quicksilver> cjs: the only clue it has is the (Quote a -> Quote a) parameter.
03:56:23 <quicksilver> to help it choose which "a" it is.
03:56:24 <tieTYT2> how do i get the 5 out of that
03:56:30 <tieTYT2> > let a = Just 5 in a
03:56:32 <lambdabot>  Just 5
03:56:42 <dmwit> > let f (Just x) = x in f (Just 5) -- ?
03:56:43 <lambdabot>  5
03:56:57 <Deewiant> > let f = fromJust in f (Just 5)
03:56:58 <lambdabot>  5
03:56:59 <quicksilver> unfortunately the (Quote a -> Quote a) is fully polymorphic
03:57:04 <quicksilver> so it still doesn't know which "a"
03:57:06 <dmwit> Of course, you wouldn't write that function, since fromJust already exists.
03:57:15 <dmwit> But that's what pattern matching is all about.
03:57:31 <tieTYT2> oh
03:57:34 <tieTYT2> there's nothing built in for that?
03:57:40 <tieTYT2> oh
03:57:44 <Baughn> http://haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt <-- Is this example missing the implementation of Succ, or do GADTs in fact work by pretending to have a Term Int when it's actually a Term (Term Int)?
03:57:45 <lambdabot> Title: 8.4. Extensions to data types and type synonyms, http://tinyurl.com/3czedj
03:57:47 <tieTYT2> ok gotcha
03:57:55 <cjs> So if I have two versions of updateQuote, once of which assumes that a is a Future, and the other of which assumes that it's an Option, it will then know?
03:58:02 <quicksilver> no.
03:58:11 <tieTYT2> yeah i didn't realize i already had the knowledge to answer that
03:58:19 <tieTYT2> that sucks :T  It'll click eventually :)
03:58:41 <tieTYT2> anyway, going to sleep.  See ya
03:58:47 <dmwit> tieTYT2: As another resource, consider taking a look at the Gentle Intro's section on patterns.
03:58:51 <cjs> Hm. My market has mktOptions and mktFutures, which are maps of Quote Option and Quote Future, respectively.
03:58:54 <dmwit> http://www.haskell.org/tutorial/patterns.html
03:58:55 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
03:59:00 <dmwit> tieTYT2: Sleep well!
03:59:27 <tieTYT2> ok i'll check this out tomorrow
03:59:30 <cjs> updateQuoteLimit doesn't care whether the Instrument is an option or a future, because it only touches the bestAsk and the bestBid, which are part of every Quote, separate from the a.
04:00:28 <cjs> only updateQuote cares.
04:00:29 <Taggnostr> what is the Integral type?
04:00:34 <cjs> So I wonder how I get myself out of this hole?
04:00:45 <quicksilver> cjs: I think I'm failing the explain the problem ;)
04:00:46 <Baughn> Taggnostr: Integers, basically
04:00:47 <dmwit> Taggnostr: Integral is a class, not a type.
04:01:06 <dmwit> Taggnostr: Int and Integer are basically the two interesting instances of Integral.
04:01:18 <Taggnostr> I see
04:01:24 <Baughn> @instances Integral
04:01:25 <dmwit> (There's also (Int|Word)(8|16|32|64).)
04:01:25 <lambdabot> Int, Integer
04:01:27 <cjs> quicksilver, No, I'm just failing to comprehend what I've just done to myself. :-)
04:01:35 <dmwit> ?instances-importing Data.Word Integral
04:01:35 <lambdabot> Int, Integer, Word, Word16, Word32, Word64, Word8
04:01:45 <quicksilver> cjs: can I give you a "simpler" example using Num?
04:01:50 <cjs> Yes, please.
04:01:57 <quicksilver> suppose you had a function:
04:01:58 <Baughn> cjs: It might just be because I only read about them five minutes ago, but this looks like a nice use for GADTs. ;)
04:02:09 <quicksilver> foo :: Num a => String -> (a -> a) -> String
04:02:34 <quicksilver> cjs: this says "for any particular Number type a, give me a string, and a function a -> a, and I'll give you a string.
04:02:58 <quicksilver> cjs: I can't call that as 'foo "hello" (+1)'
04:03:12 <quicksilver> cjs: because (+1) doesn't pin down the *particular* number type a.
04:03:21 <quicksilver> cjs: (+1) is fully polymorphic in Num.
04:03:31 <quicksilver> and then it doesn't know which version of foo to call.
04:03:45 <quicksilver> foo "hello" ((+1) :: Int -> Int) would pin it down.
04:04:02 <quicksilver> cjs: No, I'm going to go out on a limb and say that 'updateQuote' has the wrong type :)
04:04:08 <cjs> Hm. So I have to pin it down from "outside" as it were.
04:04:10 <quicksilver> because, I'm not sure that type is sensible.
04:04:22 <cjs> Yes, I would not be surprised if it has the wrong type.
04:04:27 <quicksilver> what use it is for updateQuote to have a generic (Quote a -> Quote a) ?
04:04:34 <quicksilver> it can't possibly do anything interesting with it
04:04:39 <quicksilver> since it has "no idea what a is"
04:04:46 <dmwit> cjs: Yes, pinning it down from outside is often the right approach.
04:04:49 <quicksilver> it has no values of type Quote a to apply it to
04:04:53 <cjs> But it never touches the a!
04:04:56 <quicksilver> and no way of getting one, I suspect.
04:05:02 <quicksilver> well it's got to do something with that function.
04:05:10 <cjs> It makes a new Quote using the same a as came out of the old quote.
04:05:14 <quicksilver> which old quote?
04:05:18 <quicksilver> (I think we're getting there)
04:05:28 <quicksilver> I think you don't want a *generic* a
04:05:37 <quicksilver> you want "the same a as this StockCode refers to"
04:06:17 <cjs> updateQuote finds a Quote in the Market via the StockCode. It then passes this to the (Quote a -> Quote a) to get back a new Quote, which it then drops back into the same map to replace the old one.
04:06:31 <dmwit> Oh ho!
04:06:43 <cjs> (There are two maps, one for Quote Futures and one for Quote Options, as I mentioned. How I get which one disturbs me a little.)
04:06:48 <quicksilver> cjs: exactly.
04:06:48 <dmwit> StockCode is not parameterized, but Quote is?
04:06:55 <quicksilver> cjs: how is it going to get the 'right' type of Quote?
04:06:59 <quicksilver> from a plain old StockCode?
04:07:07 <quicksilver> this is exactly what I meant by your type being wrong.
04:07:22 <cjs> Look at 'em all and find out which quote is indexed by that StockCode. :-)
04:07:23 <quicksilver> StockCodes probably need to be tagged with the Instrument Type they refer to.
04:08:06 <quicksilver> then your type would become Instrument a => Market -> (Quote a -> Quote a) -> StockCode a -> Market
04:08:10 <quicksilver> which looks more plausible
04:08:12 <cjs> Unfortuantely, I can't do that, because I don't know the Instrument when I get a StockCode. That's data I have squirreled away from earlier.
04:08:33 <quicksilver> cjs: you can't have static stuff depending on dynamic stuff
04:08:35 <quicksilver> I speak loosely.
04:08:44 <quicksilver> but the type of Quote a is known statically.
04:08:56 <quicksilver> all the code which works with it has to, in principle, know statically what a is.
04:09:05 <quicksilver> it can be fully polymorphic in a when it doesn't care
04:09:14 <quicksilver> but some bit of code somewhere *is* going to care.
04:09:17 <cjs> But yes, I think we're hitting on the basic problem now. Early on I'll get messages that give me a StockCode and various other stuff that let me identify it as associated with a Future or an Option. Later, I get just the StockCode, with no indication of whether it's a Future or an Option.
04:09:20 <quicksilver> and that part needs the static ingo.
04:09:32 <quicksilver> so what type do we give
04:09:47 <quicksilver> fetchStock :: Market -> StockCode -> a ?
04:09:56 <quicksilver> if we try
04:09:59 <cjs> quicksilver: Exactly!
04:10:06 <quicksilver> fetchStock :: (Instrument a) =>  Market -> StockCode -> a ?
04:10:10 <quicksilver> then we don't get what you want
04:10:22 <quicksilver> because that says the *caller* gets to choose if it's a Future or an Option
04:10:29 <quicksilver> and the function has to supply.
04:10:36 <quicksilver> I doubt that's what you mean.
04:10:53 <quicksilver> it may be you mean an existential here, which is the solution to that particular question
04:10:59 <quicksilver> but I don't know enough about what you're doing to be sure.
04:11:15 <cjs> I think you've hit the nail on the head by expressing the problem, "So what type do we give to fetchStock :: Market -> StockCode -> a ?"?
04:11:38 <cjs> I dunno. I have only a StockCode, with no indication of what it might be.
04:11:52 <cjs> Except information I've received earlier during the run of the program.
04:12:31 <cjs> So does this leave me any way to statically separate Futures and Options?
04:13:09 <cjs> I keep thinking I want to do something like a Java cast, which makes me really feel I'm attacking this in the wrong way.
04:14:01 <vixey> if it's the right solution you should just go with it
04:14:01 <dmwit> Why not have separate stock codes for Futures and Options?
04:14:10 <dmwit> You're looking them up in separate maps anyway.
04:16:20 <wjt> Any HTTP.Browser folks around?  Having set up an authority generator and logged into a web service, I want to capture the Browser state so I can reuse it later.  Is using browse (setup authority >> log in >> getBS), then later saying browse (alterBS (const savedState) >> other stuff) the best way?
04:17:21 <quicksilver> cjs: you probably should try to statically separate them.
04:17:33 <quicksilver> cjs: there are "pseudo-dynamic" tricks you can play, though.
04:17:38 <doun> someone wrote a web browser in haskell? is it awesome? (y/n)
04:18:04 <wjt> doun: it's more like a curl-alike
04:18:14 <doun> oh I see
04:18:38 <cjs> Hm. That was what I was worried about.
04:18:57 <cjs> When I didn't have them statically separated, other things started to get difficult.
04:19:20 <cjs> I.e., opportunities for stuff to blow up started happening all over the place.
04:19:35 <cjs> Do you have any references to demonstrations of these sort of "pseudo-dynamic" tricks?
04:20:03 <dmwit> :browse Data.Dynamic ?
04:21:07 <cjs> Hm. Are there any papers on it?
04:21:26 <quicksilver> no, it's much easier than that
04:21:28 <quicksilver> in this case.
04:21:50 <quicksilver> you store a map which holds Either Future Option
04:21:56 <quicksilver> and you statically look up
04:21:57 <quicksilver> erm
04:22:03 <quicksilver> sorry, you check on lookup.
04:22:25 <quicksilver> and you just throw an exception if the types don't match.
04:23:04 <quicksilver> dynamic isn't hard if it's just a finite list of known types.
04:23:33 <cjs> Hm, yes, that sounds like the general direction I was thinking in.
04:24:11 <quicksilver> you need a reification of your types.
04:24:22 <quicksilver> data InstrumentType = ITFuture | ITOption.
04:24:31 <quicksilver> and a class method of Instrument which reifies.
04:24:42 <cjs> As in, my "data K2Type = K2None | K2Future | K2Option"? :-)
04:24:54 <quicksilver> instance Instrument Future where itType a = ITFuture
04:24:56 <quicksilver> yes.
04:25:07 <quicksilver> then you can check in the lookup function
04:25:22 <quicksilver> (this is a mini-verision of Typeable and TypeRep for your case only)
04:26:08 <cjs> Ah, so I can iType an Instrument, and I'll get back the appropriate type, which I can then pattern match.
04:26:50 <quicksilver> yes.
04:27:13 <quicksilver> it may be simpler just to distinguish fetchFuture from fetchOption
04:27:20 <quicksilver> but, I'm not quite sure what you're trying to do :)
04:27:58 <cjs> Well, when I get a message with a new bestBid and bestAsk, I don't care whether it applies to a Quote Future or Quote Option, since all Quotes have this.
04:28:16 <anX> > let foo = "Hello, world!":foo in foo
04:28:17 <lambdabot>  ["Hello, world!","Hello, world!","Hello, world!","Hello, world!","Hello, wor...
04:28:28 <anX> Damn!
04:28:32 <Deewiant> > fix ("OM N" ++)
04:28:33 <lambdabot>  "OM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM ...
04:28:48 <cjs> data (Instrument a) => Quote a = Quote { instrument :: a, bestAsk :: Maybe Float, bestBid :: Maybe Float }
04:30:21 <vixey> > let q = "quackology" ; foo  = q ++ interleave foo (drop (length q `div` 2) foo) ; interleave (x:xs) (y:ys) = x:y:interleave xs ys in foo
04:30:25 <lambdabot>  "quackologyqoulaocgkyoqloouglyaqoocuglkayoocqglkoyoouqglloyoauqgoloycauqgolo...
04:30:49 <quicksilver> cjs: yes for this kind of thing having a typeclass and also a reification of the types sounds like the right approach to me.
04:31:10 <cjs> What does "reification" mean in this context?
04:31:21 <vixey> @let interleave (x:xs) (y:ys) = x:y:interleave xs ys
04:31:22 <lambdabot> Defined.
04:31:24 <cjs> Making a concrete type from an abstract?
04:33:23 <vixey> > let iota n = n : iota (n+1) `interleave` repeat n in iota 1
04:33:32 <lambdabot>  [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,2...
04:35:08 <dmwit> > expr . fun . fix $ ("su de" ++)
04:35:10 <lambdabot>  su desu desu desu desu desu desu desu desu desu desu desu desu desu desu des...
04:35:36 <quicksilver> cjs: making a value out of type
04:35:55 <pastorn> dmwit: graet
04:36:10 <cjs> quicksilver: I see.
04:36:13 <pastorn> @src expr
04:36:14 <lambdabot> Source not found. Are you on drugs?
04:36:18 <dmwit> expr = id
04:36:30 <dmwit> expr = id :: Expr -> Expr
04:36:34 <vixey> > let r = repeat in foldr interleave (r ' ') (map r "_-^")
04:36:41 <lambdabot>  "_-_^_-_ _-_^_-_ _-_^_-_ _-_^_-_ _-_^_-_ _-_^_-_ _-_^_-_ _-_^_-_ _-_^_-_ _-_...
04:36:44 <pastorn> dmwit: fun?
04:37:07 <dmwit> > foldr (fun "named function") x [a, b, c]
04:37:09 <lambdabot>  named function a (named function b (named function c x))
04:38:11 <dmwit> pastorn: More info here: http://twan.home.fmf.nl/blog/haskell/
04:38:12 <lambdabot> Title: 21 thoughts
04:41:36 <vixey> > expr expr
04:41:37 <lambdabot>  Couldn't match expected type `Expr'
04:41:39 <vixey> :L
04:45:40 <vixey> > let r = repeat in foldr interleave (r ' ') (map r "_.-^|")
04:45:41 <lambdabot>  "_._-_._^_._-_._|_._-_._^_._-_._ _._-_._^_._-_._|_._-_._^_._-_._ _._-_._^_._...
04:46:54 <mbz> OT: does erlang support some imperative features like ocaml does?
04:47:29 <Syzygy-> > expr . fun . fix $ ("do su" ++)
04:47:30 <lambdabot>  do sudo sudo sudo sudo sudo sudo sudo sudo sudo sudo sudo sudo sudo sudo sud...
04:49:09 <ski_> mbz : yes, in some sense
04:49:36 <ski_> (you can simulate state cells with processes, or use dictionaries if you insist)
04:49:53 <mbz> thanks
04:58:25 <vixey> > let blum _ _ 0 = 2 ; blum blum' shub x = (blum blum' shub (x-1))^2`mod`(blum'*shub) in map (blum 27 23) [1..]
04:58:28 <lambdabot>  [4,16,256,331,265,52,220,583,202,439,211,430,463,124,472,466,427,376,409,232...
04:58:41 <hpaste>  beelsebob pasted "Odd error" at http://hpaste.org/7791
04:59:03 <BeelsebobWork> bugger, the unicode didn't come out well in that
04:59:33 <BeelsebobWork> The first ??? is ∷, the second is →
04:59:40 <mauke> that's just ghci failing at unicode output
04:59:47 <BeelsebobWork> possiby
04:59:49 <BeelsebobWork> oh
04:59:52 <BeelsebobWork> I see what's wrong
04:59:56 <BeelsebobWork> type is reserved >.<
05:02:16 <mm_freak_work> > unfoldr (\x -> Just (x, mod x (23*29))) 2
05:02:17 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
05:02:26 <mm_freak_work> > unfoldr (\x -> Just (x, mod (x^2) (23*29))) 2
05:02:27 <lambdabot>  [2,4,16,256,170,219,604,634,422,662,25,625,430,141,538,633,489,335,169,547,3...
05:03:00 <vixey> @pl (\x -> return (x, mod (x^2) (23*29))
05:03:00 <lambdabot> (line 1, column 37):
05:03:00 <lambdabot> unexpected end of input
05:03:00 <lambdabot> expecting variable, "(", operator or ")"
05:03:03 <vixey> @pl (\x -> return (x, mod (x^2) (23*29)))
05:03:04 <lambdabot> return . ap (,) (flip mod 667 . (^ 2))
05:03:14 <mm_freak_work> vixey: it's a very common misunderstanding that the BBS generator takes its last state - 1…  it just squares it
05:03:21 <vixey> > unfoldr (return . ap (,) (flip mod 667 . (^ 2))) 2
05:03:22 <lambdabot>  [2,4,16,256,170,219,604,634,422,662,25,625,430,141,538,633,489,335,169,547,3...
05:03:55 <vixey> o_______o
05:04:15 <hpaste>  tilarids pasted " No instance for (Floating Int)" at http://hpaste.org/7792
05:04:17 <tilarids> Can anyone help me with one more compile error?
05:04:37 <Deewiant> without looking at the code: you're probably using (/) when you should be using div
05:04:40 <Deewiant> @ty (/)
05:04:45 <quicksilver> right.
05:04:51 <lambdabot> forall a. (Fractional a) => a -> a -> a
05:04:54 <Deewiant> @ty div
05:04:55 <lambdabot> forall a. (Integral a) => a -> a -> a
05:04:57 <quicksilver> (/) is for Floatings, div for ints
05:06:47 <mm_freak_work> > unfoldr (\x -> Just (x, mod (x^2) (23*37))) 2  -- the last one wasn't actually a BBS generator =)
05:06:48 <lambdabot>  [2,4,16,256,9,81,604,588,238,478,416,303,752,440,423,219,305,266,123,662,830...
05:07:22 <vixey> excellent
05:07:34 <vixey> > drop 300 (unfoldr (\x -> Just (x, mod (x^2) (23*37))) 2)
05:07:35 <lambdabot>  [715,625,16,256,9,81,604,588,238,478,416,303,752,440,423,219,305,266,123,662...
05:07:49 <vixey> > drop 300 (map fromEnum (unfoldr (\x -> Just (x, mod (x^2) (23*37))) 2)) :: String
05:07:50 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
05:07:53 <vixey> :??
05:07:58 <vixey> > drop 300 (map toEnum (unfoldr (\x -> Just (x, mod (x^2) (23*37))) 2)) :: String
05:07:59 <lambdabot>  "\715\625\DLE\256\tQ\604\588\238\478\416\303\752\440\423\219\305\266{\662\83...
05:08:11 <pip> @lambdabot
05:08:11 <lambdabot> Unknown command, try @list
05:08:18 <vixey> > drop 300 (map (toEnum.(`mod`127)) (unfoldr (\x -> Just (x, mod (x^2) (23*37))) 2)) :: String
05:08:19 <lambdabot>  "Pu\DLE\STX\tQ`Poa#1u;*\\3\f{\ESCD<Hv6\SYNT\ETB(VPu\DLE\STX\tQ`Poa#1u;*\\3\f...
05:08:26 <vixey> this is good
05:08:33 <mauke> puddlesticks
05:08:37 <vixey> :D
05:08:42 <mm_freak_work> vixey: you'll want to add (map (.&. mask)) with a suitable mask
05:09:06 <tilarids> quicksilver: thanks :) Now I'll just find, why it use Int instead of Float
05:09:13 <mm_freak_work> you must not return more than log m / log 2 bits of the state, where m is the modulus
05:09:42 <mm_freak_work> > map (.&. 7) . unfoldr (\x -> Just (x, mod (x^2) (23*37))) 2
05:09:43 <lambdabot>   add an instance declaration for (Integral (f a))
05:09:45 <quicksilver> tilarids: using "length"
05:09:49 <quicksilver> tilarids: which returns an Int
05:09:57 <mm_freak_work> > map (.&. 7) . unfoldr (\x -> Just (x, mod (x^2) (23*37))) $ 2
05:09:59 <lambdabot>  [2,4,0,0,1,1,4,4,6,6,0,7,0,0,7,3,1,2,3,6,6,1,5,6,4,3,7,4,3,4,3,1,0,0,1,1,4,4...
05:10:06 <Deewiant> > let a = [1,2,4,8,16,32] ++ map (\n -> let x = a !! n in 2^x + 2*x + 1) [4..] in a
05:10:07 <lambdabot>  [1,2,4,8,16,32,65569,4294967361,17210191055309123083156650148738226043138695...
05:11:16 * quicksilver laughs as someone reddit's okasaki's 1995 paper
05:11:46 <mauke> ah, that reminds me
05:12:18 <mauke> what's the usual solution for including code in LaTeX so things line up correctly?
05:12:51 <Anthraxx> lhs2tex ?
05:13:06 <tilarids> quicksilver: thanks. I just forget to use i and j for subscripting
05:13:10 <mauke> not haskell code
05:13:14 <Anthraxx> Oh
05:13:19 <Anthraxx> I just use a verbatim environment for that.
05:13:48 <mauke> but I need bold for keywords and other special effects
05:13:54 <wjt> mauke: listings.sty and \lstset{basicstyle=\footnotesize\ttfamily} \lstset{columns=fixed} made me happy
05:13:56 <Anthraxx> Ah :)
05:14:04 <Anthraxx> Can't help you with that.
05:14:23 <wjt> mauke: throw in some \lstset{emph={your,list,of,keywords}} \lstset{emphstyle={\textbf}}
05:14:38 <quicksilver> more generically, yes, the listings package solves the problem.
05:14:39 <wjt> mauke: you might want \usepackage{bold-extra} to make bold tt work
05:15:18 <mm_freak_work> mauke: depends
05:15:23 <Deewiant> luximono is a nice font
05:15:33 <mauke> thanks
05:15:33 <mm_freak_work> tables, tabulars, arrays, depending on context
05:15:35 <vixey> Deewiant: yeah I use it
05:16:10 <mm_freak_work> mauke: usually \begin{tabular} is the way to go, but in math context, there are a few more options like \begin{array}
05:16:25 <mm_freak_work> and no, you don't need any additional packages for that
05:16:39 <mauke> math source code‽
05:17:18 <mm_freak_work> a, code…  \begin{verbatim} is an option here
05:17:26 <mm_freak_work> i thought you mean table data
05:20:48 <quicksilver> I recall from the fingertree paper that you can do clever stuff with measures on the fingertrees
05:21:15 <quicksilver> can you devise a structure which has the properties of a priority queue and a map at the same time?
05:21:46 <quicksilver> so you can access elements by key but also get efficient access to the 'most important'
05:21:47 <quicksilver> and bump things up and down by priority
05:24:59 <Baughn> How do you pronounce "GADT"? Gad-tee?
05:25:54 <Deewiant> gad-dit?
05:26:16 <yitz> Baughn: there was a fun thread on the cafe. I rhyme it with "I've had it!"
05:26:29 <Deewiant> gee-addit?
05:26:38 <Deewiant> gee-a-dit?
05:26:54 <Deewiant> there are many options. :-P
05:27:42 <Baughn> Ooh..kay. I'll stick to "gad-tee", I think. ;)
05:28:11 <Deewiant> I think I prefer yitz's of all those, i.e. "gad-dit" (or "gadd-it"?)
05:29:37 <yitz> http://www.haskell.org/pipermail/haskell-cafe/2008-March/040665.html
05:29:40 <malebria> Hello there.
05:29:40 <lambdabot> Title: [Haskell-cafe] "GADT" rhymes with "cat", http://tinyurl.com/6zym63
05:29:53 <vixey> Hi
05:30:02 <Deewiant> ah, silent "d" works, of course. "gat"
05:30:19 <malebria> Why don't a data type like Data = DataC Bool Bool can derive Enum?
05:30:48 <Deewiant> is the succ of DataC 0 0: DataC 0 1, DataC 1 0, or DataC 1 1
05:31:04 <Deewiant> my guess is that the compiler doesn't want to make that choice for you
05:31:08 <Deewiant> er
05:31:13 <Deewiant> replace 0 with False and 1 with True, of course.
05:31:25 <malebria> Deewiant: hum...
05:31:40 <malebria> Ok, but then I've tried to do my own instance, but it doesn't work as I want...
05:31:58 <Deewiant> what doesn't work
05:33:23 <malebria> just a moment..
05:33:37 <Deewiant> you can paste your code at hpaste.org for reference
05:33:46 <quicksilver> malebria: (Bool,Bool) can derive Enum
05:33:53 <qebab> are there manpages for libghc anywhere?
05:33:58 <quicksilver> malebria: custom constructors you have to write your own instance.
05:34:11 <Deewiant> > succ (False, False)
05:34:12 <lambdabot>   add an instance declaration for (Enum (Bool, Bool))
05:34:12 <qebab> I am without internet these days, so the webpage is a bit impractical
05:34:12 <lambdabot>     In the expression: ...
05:34:58 <quicksilver> hmm, I'm wrong.
05:35:09 <malebria> My problem is with enumFrom
05:35:30 <malebria> instance Enum Data where
05:35:31 <malebria>   toEnum i = DataC (toEnum $ div i 2) $ toEnum $ mod i 2
05:35:31 <malebria>   fromEnum (DataC a b) = (fromEnum a * 2) + fromEnum b
05:35:45 <malebria> The problem is that enumFrom False works:
05:35:55 <malebria> [False,True]
05:36:08 <malebria> But enumFrom $ DataC False False goes like this:
05:36:15 <malebria> [DataC False False,DataC False True,DataC True False,DataC True True,DataC *** Exception: Prelude.Enum.Bool.toEnum: bad argument
05:36:22 <malebria> It goes after bounds.
05:36:35 <malebria> But enumFromTo (minBound :: Data) (maxBound :: Data) works...
05:36:50 <Baughn> @src enumFrom
05:36:51 <lambdabot> Source not found. You untyped fool!
05:36:55 <malebria> Why do enumFrom False stops, and enumFrom (minBound :: Data) doesn't?
05:37:08 <Deewiant> enumFrom     x   = enumFromTo     x maxBound
05:37:31 <Deewiant> what's minBound :: Data
05:37:32 <ddarius> qebab: You can download the GHC user guide in various formats.
05:37:51 <malebria> DataC False False
05:38:02 <Deewiant> hm, odd
05:38:13 <malebria> Deewiant: these two results I pasted are from enumFrom minBound and enumFromTo minBound maxBound.
05:38:15 <malebria> Different..
05:38:16 <qebab> ddarius: yeah, I found it
05:38:28 <qebab> ddarius: I'd like manpages more, but this works fine :)
05:38:29 <Deewiant> malebria: yeah, but they shouldn't be. :-P
05:38:54 <quicksilver> malebria: but where is your definition of enumFrom ?
05:38:54 <cjs> quicksilver, you have so saved my ass!
05:38:57 <ddarius> Typing man ghc does something on my machine.
05:39:02 <cjs> (Again.)
05:39:09 <malebria> quicksilver: In GHC.
05:39:11 <malebria> =)
05:39:18 <Deewiant> quicksilver: I pasted the default above
05:39:36 <Deewiant> (straight from GHC-Enum.html)
05:39:39 <quicksilver> Deewiant: but you didn't.
05:39:54 <quicksilver> enumFrom x          = map toEnum [fromEnum x ..]
05:39:55 <Deewiant> didn't I?
05:40:05 <Deewiant> aha
05:40:06 <quicksilver> in my version of GHC-Enum.html, at least.
05:40:10 <Deewiant> I appear to have copied it from a comment
05:40:13 <quicksilver> malebria: you need to define enumFrom yourself.
05:40:26 <quicksilver> malebria: the default method is only sensible for infinite types.
05:40:51 <quicksilver> malebria: the one that Deewiant suggested is a suitable definition
05:41:01 <quicksilver> (if you insance Bounded)
05:41:11 <malebria> map toEnum [fromEnum False ..] :: [Bool]
05:41:11 <malebria> [False,True,*** Exception: Prelude.Enum.Bool.toEnum: bad argument
05:41:37 <malebria> quicksilver: this definition does not work for Bool..  Does it have another definition of enumFrom?
05:41:44 <Deewiant> malebria: Bool has enumFrom     = boundedEnumFrom
05:41:50 <Deewiant> maybe you can try that
05:42:17 <lilac> @src enumFrom
05:42:18 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:42:28 <Deewiant> @src Enum enumFrom
05:42:28 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
05:42:35 <malebria> Deewiant: but when I define a data like book, say data Foo = Foo | Bar deriving (Enum), it also works like bool.
05:42:49 <tchakkazulu> @type fromEnum
05:42:50 <malebria> Then deriving make a different enumFrom than when I do a instance but don't define it?
05:42:55 <lambdabot> forall a. (Enum a) => a -> Int
05:42:59 <quicksilver> malebria: yes.
05:43:04 <Deewiant> malebria: I guess deriving is smart enough to tell a finite data type from an infinite one.
05:43:09 <quicksilver> malebria: just write the instance.
05:43:12 <tchakkazulu> @type \x -> [fromEnum x ..]
05:43:15 <lambdabot> forall a. (Enum a) => a -> [Int]
05:43:16 <Deewiant> or it always uses the finite one just in case, I don't know.
05:43:25 <quicksilver> one possible approach is the one deewiant copied
05:43:31 <quicksilver> [fromEnum x .. maxBound]
05:43:35 <quicksilver> but that only works if you instance Bounded
05:43:36 <vixey> > []
05:43:40 <lambdabot>  []
05:43:40 <quicksilver> but that's probably a good idea.
05:43:47 <vixey> > [0] . [0]
05:43:50 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
05:43:55 <malebria> quicksilver: Data is deriving Bounded
05:43:57 <Deewiant> > [(+1)] . [0]
05:43:58 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
05:44:13 <lilac> malebria: what is maxBound :: Data?
05:44:14 <tchakkazulu> Yeah, that's where [fromEnum x ..] goes wrong. It creates an infinite list of ints.
05:44:26 <tchakkazulu> And for later values, toEnum will crash.
05:44:33 <vixey> > (+1) . [5,3,6,8]
05:44:36 <lambdabot>  [6,4,7,9]
05:44:48 <malebria> DataC True True
05:45:07 <quicksilver> malebria: then [fromEnum x .. maxBound] should work
05:45:39 <tchakkaway> Nope, it won't.
05:45:41 <Lemmih> [fromEnum x .. fromEnum (maxBound `asTypeOf` x)] ?
05:45:46 <tchakkaway> That's use the Int instance of maxBound.
05:45:50 <vixey> > (liftM (.)) [(+1)] [5,3,6,8]
05:45:52 <lambdabot>  Couldn't match expected type `t -> a -> b'
05:45:53 <quicksilver> ah
05:45:54 <quicksilver> doh.
05:45:57 <quicksilver> thanks tchakkaway
05:46:03 <quicksilver> Lemmih has it right :)
05:46:28 <malebria> quicksilver: or simply enumFrom x = enumFromThen x maxBound
05:46:43 <malebria> enumFromTo
05:46:46 <malebria> not then
05:47:18 <quicksilver> yes.
05:47:48 <quicksilver> Enum is a pretty godawful mixup of concepts :P
05:48:01 <EvilTerran> yeah =/
05:48:10 <Lemmih> *enumFromTo
05:48:17 <Lemmih> Tsk, I'm slow.
05:49:12 <vixey> > 1000000000000000000000000000000
05:49:15 <lambdabot>  1000000000000000000000000000000
05:49:45 <quicksilver> really the .. sugar is handy but the price we pay is fierce
05:49:54 <quicksilver> I think .. should be banished to a typeclass of its own
05:50:05 <sw17ch> :t (..)
05:50:09 <lambdabot> parse error on input `..'
05:50:12 <vixey> :t enumFromTo
05:50:13 <sw17ch> hehe
05:50:16 <lambdabot> forall a. (Enum a) => a -> a -> [a]
05:50:23 <quicksilver> :t \x y -> [x..y]
05:50:23 <vixey> :t \x y -> [x..y]
05:50:27 <lambdabot> forall t. (Enum t) => t -> t -> [t]
05:50:29 <malebria> I never use such things as [1 ..]
05:50:30 <lambdabot> forall t. (Enum t) => t -> t -> [t]
05:50:37 <quicksilver> I use them quite often actually
05:50:39 <quicksilver> I do find them useful.
05:50:46 <quicksilver> but they really don't belong in Enum.
05:50:47 <Deewiant> quicksilver: how should Enum be split up, isn't it already essentially just for ..?
05:50:57 <vixey> > let e = [ () | x <- [e] ] in e
05:50:57 <sw17ch> quicksilver, i as well... i use [1..] quite frequently
05:51:00 <quicksilver> Deewiant: it should be for enumerable types
05:51:03 <lambdabot>  [()]
05:51:06 <quicksilver> Deewiant: as its name woudl suggest.
05:51:11 <vixey> > let e = [ () | x <- e ] in e
05:51:22 <Deewiant> and isn't .. just a method of enumerating all (or a subset of) the values of a type
05:51:26 <quicksilver> no
05:51:28 <Deewiant> an enumerable type, that is
05:51:30 <lambdabot>  thread killed
05:51:30 <quicksilver> it's a godawful hack
05:51:31 <vixey> > let e = [ () | x <- [e,e] ] in e
05:51:33 <quicksilver> [1.5..5.5]
05:51:35 <quicksilver> > [1.5..5.5]
05:51:44 <lambdabot>  [(),()]
05:51:45 <lambdabot>  [1.5,2.5,3.5,4.5,5.5]
05:51:54 <quicksilver> Deewiant: look upon that "enumeration", ye mighty, and despair
05:52:01 <vixey> > let e = [ () | x <- [e] ; y <- e ] in e
05:52:02 <Deewiant> well, I don't think that should be an Enum :-)
05:52:09 <lambdabot>  Parse error at ";" (column 25)
05:52:12 <vixey> > let e = [ () | x <- [e] , y <- e ] in e
05:52:24 <Deewiant> I think the class is fine, some instances are wrong
05:52:29 <lambdabot>  thread killed
05:53:27 <quicksilver> I think enum should have succ and pred.
05:53:37 <quicksilver> and, on suffereance, toEnum and fromEnum although I don't really like those much.
05:53:52 <quicksilver> there could be clever sugar for repeated application of succ, if wanted.
05:53:56 <SamB_XP> I think toEnum and fromEnum should use an arbitrary-precision type
05:54:22 <quicksilver> 'enumFromThenTo' belongs in some other class. IMO.
05:54:40 <SamB_XP> why should it be in a class?
05:54:45 <quicksilver> I'd call it 'sequenceFromThenTo' or 'rangeFromThenTo' or something.
05:54:49 <Deewiant> IMO enumFromThenTo shouldn't be in a class, it should just be takeWhile (< max) (iterate succ min)
05:54:52 <Deewiant> or something
05:55:01 <quicksilver> only if you think the notation [8,10.54..] is worth saving
05:55:06 <quicksilver> > [8,10.54..]
05:55:10 <SamB_XP> Deewiant: that doesn't use a "then"
05:55:16 <SamB_XP> that would be just enumFromTo
05:55:20 <quicksilver> i'm not sure it is worth it personally :)
05:55:20 <lambdabot>  [8.0,10.54,13.079999999999998,15.619999999999997,18.159999999999997,20.69999...
05:55:31 <Deewiant> SamB_XP: yeah, I know, I was making things simple :-)
05:55:35 <SamB_XP> quicksilver: I'd just try to come up with an alternative way to do that
05:55:37 <Deewiant> hence 'or something'
05:55:49 <SamB_XP> probably using a named method
05:55:57 <quicksilver> I can just about imagine using [1,3..]
05:55:57 <SamB_XP> or just plain function
05:56:05 <quicksilver> but I have never done so
05:56:09 <vixey> > [1,3..]
05:56:12 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
05:56:14 <quicksilver> I almost always start with [0..] or [1..]
05:56:16 <vixey> primes!
05:56:27 <quicksilver> and then, if necessarily, multiply up
05:56:29 <qebab> odds, you mean!
05:56:33 <vixey> @let primes = [1,3..]
05:56:44 <Deewiant> enumFromThenTo should maybe only work for Num
05:56:45 <quicksilver> [a*2 + 1 | a <- [0..] ]
05:56:50 <lambdabot> thread killed
05:56:51 <quicksilver> seems to me perfectly fine
05:56:58 <quicksilver> possibly it's even more clear, actually.
05:57:36 <qebab> > let sieve (p:ps) = p : sieve [ x | x <- ps, x `mod` p /= 0] in sieve [2..]
05:57:40 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
05:57:50 <qebab> I learnt a trick!
05:57:56 <vixey> qebab o-o
05:58:13 <qebab> I really liked that when I worked it out
06:00:56 <quicksilver> "It is not known whether the boundary of the Mandelbrot set has positive planar Lebesgue measure."
06:01:00 <quicksilver> I find that very surprising.
06:01:08 <quicksilver> (very surprising that it's unknown)
06:01:39 <idnar> I don't even know what that means
06:01:50 <ddarius> As opposed to zero?
06:03:02 <quicksilver> yes.
06:03:14 <quicksilver> I would personally be very, very surprised if it had positive measure.
06:03:22 <ddarius> As would I.
06:03:24 <quicksilver> it doesn't feel remotely spacefilling to me.
06:03:34 <quicksilver> but I'm also surprised its unknown.
06:04:11 <quicksilver> idnar: it means, is the boundary really just a 'thin line' or does it some how double back itself like a scribble to such an extent it actually covers a finite area. Roughly.
06:04:14 <Syzygy-> I'm not VERY surprised it's unknown. My guess would be for measure 0, but a >0 answer sounds like it might be cool.
06:05:56 <idnar> quicksilver: interesting
06:07:31 <quicksilver> idnar: http://en.wikipedia.org/wiki/Space-filling_curve are the opposite extreme, being curves that definitely have finite measure.
06:08:02 <lilac> > [1,1,2,3,5,8,..]
06:08:04 <lilac> :)
06:08:06 <lambdabot>  Parse error at "..]" (column 14)
06:08:15 <mauke> @oeis 1 1 2 3 5 8
06:08:15 <vixey> > extendSequnce [1,1,2,3,5,8]
06:08:19 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
06:08:19 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
06:08:19 <lambdabot>   Not in scope: `extendSequnce'
06:08:23 <vixey> >:|
06:08:49 <Deewiant> > extendSequence [1,1,2,3,5,8]
06:08:51 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
06:09:14 <mauke> > extendSequence [0]
06:09:17 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
06:09:21 <mauke> what
06:09:22 <SamB> huh.
06:09:31 <Deewiant> > extendSequence [0,0]
06:09:31 <lilac> > extendSequence [2,3,5]
06:09:36 <lambdabot>  [0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,1,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0...
06:09:36 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
06:09:47 <SamB> I don't think I've ever had firefox/iceweasel tell me there was an update available for anything before!
06:10:06 <SamB> now if only the update would actually download and install!
06:10:18 <lilac> SamB: really? it nags me about updates about once a day
06:10:28 <SamB> (on Linux, I mean)
06:10:47 <Deewiant> if your settings are set to automatically install them then I guess it won't say a thing
06:11:04 <SamB> well, I guess I never really had installed any extensions within the purview of my own *nix account before?
06:11:07 <vixey> > describeSequence [12]
06:11:11 <lambdabot>  Just "Euler totient function phi(n): count numbers <= n and prime to n."
06:11:17 <vixey> OH!
06:11:23 <vixey> > describeSequence [32]
06:11:25 <Deewiant> > describeSequence [42]
06:11:29 <lambdabot>  Just "Catalan numbers: C(n) = binomial(2n,n)/(n+1) = (2n)!/(n!(n+1)!). Also ...
06:11:29 <lambdabot>  Just "Euler totient function phi(n): count numbers <= n and prime to n."
06:11:32 <vixey> lol
06:11:37 <lilac> > describeSequence [6]
06:11:41 <lambdabot>  Just "Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n."
06:12:01 <SamB> I sense an unsafePerformIO
06:12:02 <vixey> > map ((liftM (take 20)).describeSequence) [2,5..]
06:12:04 <lambdabot>   add an instance declaration for (Num SequenceData)
06:12:05 <lambdabot>     In the expression: 2
06:12:14 <vixey> > map (describeSequence) [2,5..]
06:12:18 <lambdabot>   add an instance declaration for (Num SequenceData)
06:12:18 <lambdabot>     In the expression: 2
06:12:22 <SamB> hmm, why does it use the Maybe monad rather than the [] monad?
06:12:24 <vixey> o_o?
06:12:32 <vixey> > map (describeSequence) [2,5,8,3,46,8,74]
06:12:33 <lilac> > let ones = 1:ones in describeSequence ones
06:12:33 <lambdabot>   add an instance declaration for (Num SequenceData)
06:12:34 <lambdabot>     In the expression: 2
06:12:37 <vixey> HUH???
06:12:38 <Deewiant> > map (describeSequence . return) [0..]
06:12:41 <vixey> :t describeSequence
06:12:46 <lambdabot> Terminated
06:12:47 <lambdabot> SequenceData -> Maybe String
06:12:55 <lambdabot>  thread killed
06:13:00 <vixey> > 1 :: SequenceData
06:13:01 <SamB> vixey: I assume SequenceData is a type synonym
06:13:03 <lambdabot>   add an instance declaration for (Num SequenceData)
06:13:04 <lambdabot>     In the expression: 1...
06:13:08 <vixey> >_<
06:13:14 <mauke> vixey: what's wrong with you?
06:13:24 <orbitz> SamB, mauke hai
06:13:30 <SamB> > describeSequence "Hello"
06:13:32 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Char'
06:13:47 <SamB> vixey: apparantly for [Integer]
06:13:51 <orbitz> > describeSequence [1, 2, 4]
06:13:55 <lambdabot>  Just "Powers of 2: a(n) = 2^n."
06:14:03 <Deewiant> http://hackage.haskell.org/packages/archive/oeis/0.1/doc/html/Math-OEIS.html
06:14:06 <lambdabot> http://tinyurl.com/2krqpv
06:14:08 <orbitz> > describeSequence [1, 3, 6, 1, 6, 32]
06:14:12 <lambdabot>  Nothing
06:14:13 <mauke> > describeSequence [1,2,4,7]
06:14:16 <orbitz> cool
06:14:17 <lambdabot>  Just "Tribonacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3)."
06:14:31 <vixey> mauke: why do you ask
06:14:37 <orbitz> > describeSequence [1, 1, 1, 1, 1]
06:14:40 <lambdabot>  Just "The simplest sequence of positive numbers: the all 1's sequence."
06:14:50 <twobitwork> does hs-plugins allow for type definitions to be used in the host program?
06:14:50 <Syzygy-> > describeSequence [0,0,0,0,0]
06:14:51 <mauke> vixey: because you repeatedly try to use numbers as lists
06:14:53 <lambdabot>  Just "The characteristic function of 0: a(n) = 0^n."
06:15:36 <vixey> > map (describeSequence.(:[])) [17,21..]
06:15:57 <quicksilver> twobitwork: sort of.
06:16:07 <lambdabot>  [Just "The prime numbers.",Just "Fibonacci numbers: F(n) = F(n-1) + F(n-2), ...
06:16:13 <quicksilver> twobitwork: the host program can pass around the unknown types without understanding them
06:16:27 <quicksilver> twobitwork: but it can't actually work with them, because haskell needs to know types at compile time to work with them.
06:16:35 <twobitwork> quicksilver: like, if I define a class in the host, and the plugin defines an instance... can my host functions use values of types defined in the plugin?
06:16:36 <vixey> > unwords . concatMap words . catMaybes . map (describeSequence.(:[])) [17,21..]
06:16:40 <lambdabot>  Couldn't match expected type `[Maybe String]'
06:16:49 <quicksilver> twobitwork: if you pass it over as an existential package
06:16:54 <quicksilver> twobitwork: and only use class methods, it will work
06:17:05 <quicksilver> (well class methods are all you could possibly use, since that's all you have at compile time)
06:17:07 <twobitwork> cool
06:17:13 <twobitwork> I think that's all I need
06:17:25 <twobitwork> and what do you mean by existential package?
06:18:28 <quicksilver> twobitwork: http://www.haskell.org/haskellwiki/Existential_type
06:18:30 <lambdabot> Title: Existential type - HaskellWiki
06:22:34 <twobitwork> very interesting
06:23:28 <vixey> % (1+x)^999
06:25:17 <nornagon> nuts, maple actually solves that.
06:27:24 <twobitwork> quicksilver: ok... so I think I understand existential types, but what do you mean by existential package?
06:27:24 <nornagon> 1 + 999x + 498501x² + 165668499x³ + 41251456251x⁴ + 8209039793949x⁵ + 1359964259197551x⁶ + ... + 665593793332633327557499850498189059836970931324281784516558563977249855798840991957212153322719870830022845244925927286800962436950904775783995863474272896732802820762424590569904899746396700897174802838034416590233897872882577483482982536478777179124893225406205298784232558799575293171611339065x⁴⁴⁸ + ...
06:28:04 <vixey> > describeSequence []1,999,498501,165668499]
06:28:04 <quicksilver> twobitwork: when you send an existential type around the compiler is packaging up the class instance with it
06:28:06 <lambdabot>  Parse error at "]" (column 42)
06:28:08 <vixey> > describeSequence [1,999,498501,165668499]
06:28:09 <quicksilver> twobitwork: that's all I meant
06:28:14 <lambdabot>  Nothing
06:28:21 <twobitwork> ahh
06:29:00 <vixey> > describeSequence [999]
06:29:05 <lambdabot>  Just "10^n - 1."
06:29:22 <tromp_> > describeSequence [1,57]
06:29:26 <lambdabot>  Just "Triangle of Eulerian numbers T(n,k) read by rows."
06:29:38 <tromp_> > describeSequence [1,57,12675]
06:29:40 <vixey> > describeSequence [10,9,8,7,6,5,4,3,2,1]
06:29:41 <twobitwork> that function is very interesting
06:29:43 <lambdabot>  Just "Number of legal position in Go played on an n X n grid (each group mus...
06:29:43 <Nonel> /server globalirc.zapto.org
06:29:44 <lambdabot>  Just "Triangle T(n,k) = n-k, n >= 0, 0<=k<=k. Integers m to 0 followed by in...
06:31:08 <twobitwork> > describeSequence [1,3,6,10,15,21]
06:31:10 <lambdabot>  Just "Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n."
06:31:23 <vixey> > describeSequence [10,9,8,7,6,5,4,3,2,1]
06:31:28 <lambdabot>  Just "Triangle T(n,k) = n-k, n >= 0, 0<=k<=k. Integers m to 0 followed by in...
06:31:56 <twobitwork> > describeSequence [1,3,6]
06:31:58 <lambdabot>  Just "Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n."
06:32:08 <vixey> > describeSequence [1111111]
06:32:11 <vixey> rrepunty
06:32:12 <lambdabot>  Just "Repunits: (10^n - 1)/9. Often denoted by R_n."
06:32:36 <twobitwork> > describeSequence [1.61]
06:32:38 <lambdabot>   add an instance declaration for (Fractional Integer)
06:32:38 <lambdabot>     In the expression:...
06:32:47 <jgrimes> > describeSequence [1, 11, 21, 1211, 111221]
06:32:48 <twobitwork> aww
06:32:54 <lambdabot>  Just "Look and Say sequence: describe the previous term! (method A - initial...
06:33:09 <twobitwork> > describeSequence [3,1,4,1,5,9,2,6]
06:33:11 <lambdabot>  Just "Decimal expansion of Pi."
06:33:32 <vixey> > map (length &&& head) . map group . show "1211"
06:33:35 <lambdabot>  Couldn't match expected type `f [a]' against inferred type `Char'
06:33:37 <vixey> > map (length &&& head) . map group . show $ "1211"
06:33:40 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
06:33:45 <vixey> > map (length &&& head) . map group . show $ 1211
06:33:47 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
06:33:49 <twobitwork> > describeSequence [2,7,1,8,2,8]
06:33:51 <lambdabot>  Just "Decimal expansion of e."
06:34:41 <twobitwork> this function knows everything
06:34:43 <vixey> > iterate (concatMap (\(x,c)->show x ++ [c]) . map (length &&& head) . group) "1"
06:34:48 <lambdabot>  ["1","11","21","1211","111221","312211","13112221","1113213211","31131211131...
06:35:03 <nornagon> nice
06:35:06 <vixey> > describeSequence (map read (iterate (concatMap (\(x,c)->show x ++ [c]) . map (length &&& head) . group) "1"))
06:35:19 <lambdabot>  Exception: Time limit exceeded
06:35:21 <vixey> ahaha
06:35:23 <nornagon> heh
06:35:31 <twobitwork> heh
06:35:31 <vixey> > describeSequence (take 20 (map read (iterate (concatMap (\(x,c)->show x ++ [c]) . map (length &&& head) . group) "1")))
06:35:44 <lambdabot>  Nothing
06:35:48 <vixey> :(
06:36:10 <Deewiant> > (take 20 (map read (iterate (concatMap (\(x,c)->show x ++ [c]) . map (length &&& head) . group) "1")))
06:36:26 <lambdabot>  [Exception: Prelude.read: no parse
06:36:56 <jgrimes> vixey: that is pretty nice.
06:37:07 <vixey> jgrimes++
06:37:23 <Deewiant> > describeSequence [1, 11, 21, 1211]
06:37:25 <lambdabot>  Just "Look and Say sequence: describe the previous term! (method A - initial...
06:37:30 <dcoutts_> @seen matthew_-
06:37:32 <lambdabot> matthew_- is in #haskell and #ghc. I last heard matthew_- speak 3h 13m 18s ago.
06:38:00 <dcoutts_> matthew_-: I've lost the page with the details of the meet-up tomorrow, can you remember the link?
06:38:41 <vixey> > describeSequence [-314654154]
06:38:45 <lambdabot>  Nothing
06:39:25 <vixey> > describeSequence []
06:39:28 <lambdabot>  Just "Exception: MathNon-exhaustive patterns in function combineConts
06:39:33 <ari> > describeSequence [1..]
06:39:43 <lambdabot> Terminated
06:39:47 <ari> ):
06:39:56 <vixey> ohohoho
06:40:00 <Apocalisp> ?type r0
06:40:01 <vixey> It's not lazy
06:40:04 <lambdabot> forall a. a -> Done
06:40:07 <vixey> > describeSequence [1..5000]
06:40:11 <lambdabot>  Nothing
06:40:26 <ari> > describeSequence [1..10]
06:40:29 <lambdabot>  Just "The natural numbers. Also called the whole numbers, the counting numbe...
06:42:08 <vixey> > 1000000000000000000000004*100008645465
06:42:11 <lambdabot>  100008645465000000000000400034581860
06:44:41 <MyCatVerbs> @djinn (a,[a]) -> [a]
06:44:42 <lambdabot> f (_, a) = a
06:45:02 <vixey> :t uncurry (:)
06:45:07 <lambdabot> forall a. (a, [a]) -> [a]
06:45:15 <MyCatVerbs> @pl \(a,b)->a:b
06:45:17 <lambdabot> uncurry (:)
06:45:20 <MyCatVerbs> vixey: sweet.
06:47:02 <tsuwabuki> > :quit
06:47:03 <lambdabot>   parse error on input `:'
07:02:51 <mbz> @src iterate
07:02:55 <lambdabot> iterate f x =  x : iterate f (f x)
07:03:46 <vixey> iterate f x = x : map f (iterate f x)
07:07:10 <vixey> @o e i s 4684684
07:07:15 <lambdabot> Maybe you meant: oeis offline oldwiki . ? @ v
07:07:36 <mbz> @oe 8,4,6
07:07:38 <lambdabot> Decimal expansion of Pi.
07:07:38 <lambdabot> [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1,...
07:07:46 <vixey> pi
07:07:52 <vixey> > pi ::CReal
07:07:57 <lambdabot>  3.1415926535897932384626433832795028841972
07:08:08 <lilac> @oeis [2,7,1,8]
07:08:11 <lambdabot> Sequence not found. That's something I cannot allow to happen.
07:08:14 <mbz> @oe 3,1,3,3,7
07:08:19 <lambdabot> 2^A000120(n)-1.
07:08:20 <lambdabot> [0,1,1,3,1,3,3,7,1,3,3,7,3,7,7,15,1,3,3,7,3,7,7,15,3,7,7,15,7,15,15,31,1,3,3,...
07:08:46 <tromp_> iterate f x = fix ((x:) . map f)
07:09:41 <mbz> @src fix
07:09:43 <lambdabot> fix f = let x = f x in x
07:09:47 <lilac> > exp 1.0
07:09:51 <lambdabot>  2.718281828459045
07:10:30 <vixey> > (exp 1)::CReal
07:10:33 <lambdabot>  2.7182818284590452353602874713526624977572
07:16:12 <mbz> how can I write 'myPred x = if x == A || x == B then True else False' shorter?
07:16:31 <vixey> myPred x = x == A || x == B
07:16:46 <Igloo> Or x `elem` [A, B]
07:16:50 <vixey> myPred = (`elem'[A,B])
07:17:52 <tromp_> @src elem
07:18:04 <lambdabot> elem x    =  any (== x)
07:18:31 <mbz> thanks
07:18:32 <tromp_> @src any
07:18:36 <lambdabot> any p =  or . map p
07:18:41 <vixey> @src or
07:18:44 <lambdabot> or    =  foldr (||) False
07:18:49 <vixey> @src foldr
07:18:51 <lambdabot> foldr f z []     = z
07:18:51 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:23:21 <vixey> @src (>>=) State
07:23:25 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:23:30 <vixey> @src State (>>=)
07:23:36 <lambdabot> Source not found. You untyped fool!
07:23:38 <vixey> @src State >>=
07:23:43 <lambdabot> Source not found. Are you on drugs?
07:23:44 <vixey> @src >>= State
07:23:46 <lambdabot> Source not found. Do you think like you type?
07:23:51 <vixey> :/
07:26:43 <doun> is it possible to compile a module not Main as an executable?
07:27:27 <doun> I have a few source files and sometimes they will be composed together and sometimes used by themselves as indivudal programs
07:28:38 <doun> should I create seperate Main modules for each of them?
07:30:38 <hpaste>  Orchid pasted "Abandon hope!!" at http://hpaste.org/7793
07:30:45 <lilac> doun: -main-is in ghc may help you.
07:35:58 <lilac> that's a pretty funny RNG...
07:38:10 <hpaste>  lilac annotated "Abandon hope!!" with "(no title)" at http://hpaste.org/7793#a1
07:41:33 <sclv_> looks like nothing a few threadDelay calls couldn't have fixed up. :-)
07:56:11 <mm_freak_work> is it safe to use GMP's mpn_* functions from haskell?  they don't use the memory manager
07:57:25 <BMeph> ?src (>>=) MonadState
07:57:38 <lambdabot> Source not found. Where did you learn to type?
07:57:54 <BMeph> ?src MonadState (>>=)
07:57:57 <Saizan> ?src State (>>=)
07:57:59 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:57:59 <lambdabot> Source not found. There are some things that I just don't know.
07:58:10 <mm_freak_work> ?src MonadState
07:58:12 <Saizan> BMeph: MonadState is not a type, anyhow
07:58:12 <lambdabot> Source not found. Are you on drugs?
07:58:14 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-State-Lazy.html
07:58:16 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6nnf3q
07:59:40 <doun> lilac: thanks
07:59:51 <BMeph> ?help src
08:00:05 <twobitwork> I'm trying to build hs-plugins, but it complains that it can't find Data.Array.Base, even though I can load it in ghci...
08:00:11 <lambdabot> src <id>. Display the implementation of a standard function
08:00:15 <quicksilver> wrong version of hs-plugins.
08:00:25 <quicksilver> @where hs-plugins
08:00:27 <lambdabot> http://code.haskell.org/~dons/code/hs-plugins
08:00:31 <BMeph> ?src (>>=) State Int
08:00:36 <lambdabot> Source not found. That's something I cannot allow to happen.
08:00:53 <universa1> hello, i'd like to read a string using getLine and parse that as an int, which "works" with read/reads, but if it can't parse anything, i'd like to "catch" the error. do you have a hint where to look, or what do to do?
08:00:55 <twobitwork> quicksilver: that's the one I downloaded
08:01:23 <BMeph> ?src (>>=) (State Int)
08:01:33 <lambdabot> Source not found. Sorry.
08:01:41 <quicksilver> twobitwork: that's odd then. Which GHC version are you using?
08:01:49 <quicksilver> twobitwork: and how are you trying to compile it?
08:02:39 <twobitwork> 6.8
08:02:54 <twobitwork> I'm following the README
08:03:10 <twobitwork> as in... ./Setup.lhs configure; ./Setup.lhs build
08:03:28 <twobitwork> and it passes the configure, but fails on the build
08:05:50 <paolino> :t read
08:05:53 <lambdabot> forall a. (Read a) => String -> a
08:06:32 <paolino> > read "a" :: Int
08:06:35 <lambdabot>  Exception: Prelude.read: no parse
08:08:39 <kaol> > read "\"a\"" :: String
08:08:42 <lambdabot>  "a"
08:10:17 <twobitwork> > read "[\"asdf\",\"qwer\"]" :: [String]
08:10:18 <lambdabot>  ["asdf","qwer"]
08:10:43 <twobitwork> > read "[4,4]" :: [Int]
08:10:45 <lambdabot>  [4,4]
08:11:37 <paolino> universa1 : use catch in the IO monad probably
08:12:07 <quicksilver> universa1: no no no don't do that
08:12:17 <quicksilver> never try to catch exceptions from pure computation.
08:12:18 <DRMacIver> Huh. What's the reason for the functional dependency in the vector space library?
08:12:27 <universa1> we tried catch
08:12:29 <quicksilver> :t reads
08:12:34 <lambdabot> forall a. (Read a) => String -> [(a, String)]
08:12:36 <quicksilver> use reads
08:12:50 <universa1> tried that too, but this returns the same error,
08:12:56 <quicksilver> no it doesn't.
08:13:00 <quicksilver> reads gives you an empty list
08:13:02 <quicksilver> if it can't parse.
08:13:02 <universa1> if i expect an int, and theres none in the string
08:13:11 <universa1> i try again
08:13:12 <universa1> .
08:13:17 <universa1> thanks for the help :)
08:13:20 <quicksilver> ;)
08:13:39 <doun> mapMaybe <333
08:13:48 <quicksilver> case reads s of [(x,"")] -> putStr "Got it" ; _ -> putStr "Parse failed"
08:14:01 <quicksilver> :t mapMaybe
08:14:05 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
08:14:17 * quicksilver nods
08:14:25 <universa1> thanks quicksilver, you were indeed right :)
08:14:27 <doun> perfect for filtering a list of strings with a regex and getting the matched value
08:14:32 <paolino> quicksilver: why read exists ?
08:14:34 <quicksilver> doun: if you like that you'll probably find catMaybes handy in general.
08:14:44 <quicksilver> paolino: to prompt people to give incorrect answers in IRC channels
08:14:53 <doun> quicksilver: ahh, indeed. very nice
08:14:54 <quicksilver> and to lure people into incorrect usage of exceptions.
08:15:16 <paolino> it should be documented
08:15:26 <quicksilver> I'm sure it is.
08:15:44 <quicksilver> read is handy for simple cases where you either know there can't be a parse error or don't care.
08:16:17 <DuClare> (Oh yeh, if anybody can help me with utf-8, I'm waiting.)
08:16:22 <DuClare> Err.
08:16:33 <DuClare> IT happened again :]
08:16:54 <twobitwork> I hate it when IT happens
08:17:15 <doun> Prelude Data.Maybe Text.Regex> map head $ mapMaybe (matchRegex (mkRegex "([a-z]+)")) ["foo","123","---","bar"]
08:17:18 <doun> ["foo","bar"]
08:17:20 <doun> :D
08:17:25 <paolino> yeah, pure computations should never throw exceptions
08:17:43 <stwange> what does it mean for a turing machine to be partial? That not every state has a next state function for every possible character of input? If that's right, what about a total function? How can it always have a next state function even for a string that is not in the language?
08:17:48 <quicksilver> 'error' is fine for programming errors.
08:17:59 <quicksilver> but don't try to catch them, that's all.
08:18:25 <paolino> mmhh, failing a parse is not a programming error
08:19:19 <twobitwork> quicksilver: so, any idea why I can't build hs-plugins?
08:20:01 <quicksilver> paolino: it might be in certain cases.
08:20:19 <quicksilver> paolino: for example if you have in the program serialised a Double to a String.
08:20:25 <quicksilver> Cale: ?
08:20:26 <quicksilver> dons: ?
08:20:32 <quicksilver> twobitwork: no, seems odd...
08:20:56 <universa1> got it working, thanks again quicksilver :)
08:21:45 <twobitwork> it says:  it is a member of package array-0.1.0.0, which is hidden
08:22:02 <paolino> ok, read is a debugging function then ?
08:22:29 <sclv_> reading some more about clojure now. the commute primitive is really neat.
08:23:08 * sclv_ wonders if something like that wouldn't be a solution to the TVar caching problem that was being discussed the other week.
08:23:28 <quicksilver> paolino: I didn't say that. But I do agree it's not a very useful function.
08:23:42 <edwardk> @seen sclv
08:23:45 <sclv_> its a nice pun too -- "this op is commutative" or "i commute your sentence"
08:23:47 <quicksilver> paolino: however, imagine you have already used regexp filtering to prove something is syntactically a number
08:23:52 <lambdabot> sclv is in #haskell, #xmonad, #haskell-soc, #haskell-blah, #darcs and #ghc. I last heard sclv speak 1h 50m 18s ago.
08:23:54 <quicksilver> paolino: or, a parsec parser
08:23:56 <edwardk> lol, heya
08:24:01 <quicksilver> paolino: then it is perfectly safe to call 'read' on it.
08:24:14 <edwardk> sclv_: did you get my earlier message?
08:24:15 <sclv_> hey edwardk
08:24:40 <sclv_> yeah -- I found the right instances in Cofree' (under Cofree.Alt)
08:25:08 <edwardk> yeah, Cofree Alt actually should go away, I had thought I'd deleted it =) Cofree Identity does the same thing conceptually.
08:25:35 <sclv_> playing with comonads over channels a bit, but i think i'm just rediscovering a very well known wheel.
08:26:15 <sclv_> but Cofree' in Alt has the comonad instance, while I didn't see one for the new Cofree ?
08:26:20 <edwardk> i think what i'll do is create a Control.Comonad.Stream with type Stream = Cofree identity
08:26:54 <edwardk> sclv: they are there but they are subtle. Cofree is a Fix'd Biff. and Biff is a parameterized comonad. the fixed point of a parameterized comonad is a comonad
08:27:16 <edwardk> to avoid orphan instances the definitions for PComonad for Biff are buried in Control.Functor.Combinators.Biff
08:27:36 <paolino> quicksilver: right
08:27:42 <sclv_> headpalm
08:27:44 <edwardk> the cofree comonad can then be seen as an instance of the more general construction.
08:27:53 <edwardk> just as the free monad
08:28:07 <sclv_> Right -- I sort of vaguely see what you're doing with it.
08:28:07 <edwardk> in fact if f is an instance of Functor plus the cofree comonad is also a monad ;)
08:28:47 <edwardk> i wanted to do that to basically roll up neil ghani and patricia johann's sumtype and prodtype p(co)monads
08:28:53 <sclv_> I'm not using your code directly, just looking to it for inspiration at the moment.
08:29:14 <edwardk> let me know if you are having any trouble building it. i think i may have some issues before 6.9 i need to address.
08:29:15 <sclv_> I have a sinking feeling that doing something interesting I might need to move to a parameterized comonad though, at which point I'll have to tackle it seriously.
08:29:39 <edwardk> keep in mind there are 2 forms of parameterized comonad in the library, parameterized and indexed.
08:29:39 <doun> any got a nice way to get from ["foo","bar"] to ("foo","bar")?
08:29:46 <edwardk> the latter is a lot more interesting in some ways
08:30:07 <Jedai> doun: toPair [x,y] = (x,y)
08:30:41 <Jedai> I don't see anything "nicer" with the way n-uplet are set up in Haskell now
08:30:51 <doun> Jedai: yeah, I wrote that. just wondering if there was a function to do it perhaps
08:30:51 <gwern> malcolmw: for starters, hmake's make scripts are broken under 6.8.2 - '-package lang' and what not
08:30:55 <doun> Jedai: ah
08:31:01 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
08:31:07 <edwardk> sclv: anyways i've been doing that a lot. building up the painfully general and making specialized instances out of it. i.e. type Yoneda = Ran Identity, etc.
08:31:07 <sclv_> Right now I have instance comonad (Thing a) where data Thing a b = Thing (Chan a) (a->b). but that's sort of dull and I don't know if it's actually buying me anything over just a plain instance Comonad (Chan a)
08:31:43 <edwardk> heh, you can prove it doesn't with a quick look at the yoneda lemma =)
08:31:46 <gwern> @messages
08:31:47 * quicksilver thinks edwardk should design a haskell web services toolkit where the central execution method is Yoneda lemmas.
08:31:48 <lambdabot> malcolmw said 5h 34m 12s ago: I don't know - is there anything that needs updating in hmake?
08:32:02 <quicksilver> that would show people that haskell applies to real world problems ;)
08:32:32 <sclv_> edwardk: well, what it does get me though is a cheap way to get a functor, since (Chan a) isn't one.
08:32:45 <MyCatVerbs> quicksilver: who's Yoneda, and what set of lemmas is associated with'm?
08:32:58 <sclv_> but what it doesn't get me is a way to work with the type of a and b at once, which might actually be able to produce something somewhat interesting.
08:33:04 <edwardk> type CoYoeneda = Lan Identity, Lan Identity f ~ exists b.. (Identity b -> a) (f b). which is ismorphic to f a
08:33:13 <gwern> @seen malcolmw
08:33:15 <lambdabot> malcolmw is in #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell. I last heard malcolmw speak 5h 35m 38s ago.
08:33:24 <ski_> edwardk : oh, you're thinking of coyoneda, too ?
08:33:29 <MyCatVerbs> quicksilver: (also, sure, why not? It's not like monads weren't considered ridiculously abstract, until someone worked out that you could do IO with'm.)
08:33:33 <stwange> I have a past exam question "What's the different between a computable function and a turing-computable function"; that's a trick question, right? ie. there is no difference assuming the church-turing thesis is true
08:33:34 <edwardk> drop the identity and existential and its the same thing you have
08:33:45 <stwange> *s:/different/difference
08:33:57 <gwern> one day, 'to haskell' will be a verb denoting applying a ridiculously powerful theoretical tool to obliterate some prosaic problem >.<
08:34:02 <gwern> @tell malcolmw for starters, hmake's make scripts are broken under 6.8.2 - '-package lang' and what not
08:34:05 <lambdabot> Consider it noted.
08:34:09 <edwardk> MyCatVerbs: basically he says that f b and (forall a. (a -> b) -> f b) are isomorphic
08:34:50 <edwardk> ski: i blogged on kan extensions the other night including everything but coyoneda (and mentioned the connection to it via Lan Identity as an exercise for the reader)
08:34:55 <MyCatVerbs> edwardk: k. Isomorphic how?
08:35:12 <ski_> `Lan' ?
08:35:32 <edwardk> mycatverbs: check a f = fmap f a goes one way, and uncheck t = t id goes the other.
08:36:06 <mattam> Left kan extension i worry
08:36:07 <edwardk> ski: left Kan extension. its like an existentially quantified context comonad transformer. http://comonad.com/reader/2008/kan-extensions/ talks about Lan and Ran
08:36:11 <lambdabot> Title: The Comonad.Reader  Kan Extensions
08:36:13 <MyCatVerbs> edwardk: as in you can define functions that map any (f b) onto a (forall...) and another one that performs the reverse mapping?
08:36:42 <ski_> exists s. (s,s -> f a)
08:36:42 <edwardk> mycatverbs yeah such that check . uncheck = id and uncheck . check = id.
08:37:12 <ski_> hm
08:37:12 <edwardk> exists s. (f s, f s -> a) no?
08:37:14 * mattam reads happily. comonad is my number one procrastination place since I started writing my thesis.
08:37:20 <ski_> lemme see
08:37:30 <MyCatVerbs> edwardk: check :: Functor f => f b -> ((forall a. (a->b)->f b) -- or am I reading this backwards?
08:37:31 <ski_> (a -> b) -> (f a -> f b)
08:37:44 <ski_> forall a. (f a,a -> b) -> f b
08:37:52 <ski_> (exists a. (f a,a -> b)) -> f b
08:37:58 <edwardk> mycatverbs: http://sigfpe.blogspot.com/2006/11/yoneda-lemma.html is a great explanation.
08:37:59 <lambdabot> Title: A Neighborhood of Infinity: Reverse Engineering Machines with the Yoneda Lemma
08:38:00 <ski_> edwardk : yes, i remembered wrong
08:38:19 <MyCatVerbs> edwardk: also result #2 on Google. Heh.
08:38:20 <edwardk> ski: no problem i had to reconstruct it more recently
08:38:46 <ski_> edwardk : so, we get these by reformulating the type of `fmap' in two directions
08:39:02 <sclv_> MyCatVerbs: That's nice that all the Yoneda Lemma SEO googlespam hasn't driven it off the front page :-)
08:39:21 <ski_> edwardk : we can of course use same kind of reformulation for type of `cata' and `ana' instead :)
08:39:46 <edwardk> ski: i was meaning to add coyoneda to the category-extras, i just didn't come up with a good name for toCoYoneda which looks really ugly ;)
08:40:07 <ski_> forall a. (a -> f a) -> (a -> Nu f)
08:40:12 <edwardk> ski: did you see my post the other day about Elgot coalgebras?
08:40:13 <ski_> forall a. (a,a -> f a) -> Nu f
08:40:21 <ski_> (exists a. (a,a -> f a)) -> Nu f
08:40:37 <ski_> newtype Nu f = forall a. MkNu (a,a -> f a)
08:40:43 <edwardk> ah thats a nice formulation
08:40:44 <ski_> edwardk : no
08:40:58 <ski_> (edwardk : i.e. didn't see it)
08:41:34 <ski_> this must be some dual of church encoding
08:41:52 <sclv_> On the possible utility of these other recursion schemes, I actually wonder if we haven't gotten bits of them in the wild, since they seem like partial CPS transforms over standard schemes..
08:42:08 <edwardk> heh i'm tempted to write an 'ana' for (forall a. Context a (f a)) -> Nu f ;)
08:43:40 <edwardk> ski: and yeah i've done the existential Nu before for an alternative approach to cofree comonads
08:44:04 <edwardk> ski: http://comonad.com/reader/2008/elgot-coalgebras/
08:44:19 <edwardk> its a recurstion scheme i tripped over one way, dualized and found the dual to be quite powerful
08:44:46 <edwardk> i wanted some form of feedback on the idea, since no one else seems to have read it or at least bothered to reply ;)
08:44:53 <lambdabot> Title: The Comonad.Reader  Elgot (Co)Algebras
08:45:21 <chessguy> edwardk, you do realize it's way over the heads of even most haskellers, right?
08:45:24 <MyCatVerbs> sclv_: I sense... sarcasm?
08:46:13 <edwardk> chessguy: the rabbit hole isn't that deep, its just a little off to the side of what you usually wrestle with
08:46:47 <sclv_> on the googlespam yeah, on the question about cps transforms no...
08:47:32 <edwardk> wow, its been almost 2 months i've been playing with category theory since i ran into a roadblock with HOAS and turned here to try to solve it
08:48:00 <edwardk> i was going to say i'd only been playing with this stuff for a couple of weeks, but i guess i'd be lying then ;)
08:48:10 <mattam> edwardk: I sure read it. Here's one question: is Elgot a pun in some sense ? :)
08:48:26 <edwardk> Mattieu Sozeau: Elgot is named after Calvin Elgot
08:48:50 <sclv_> There's this part of me that thinks there's some 60 yr. old scheme guru who'll look at a chronomorphism or whatever and say "oh, yeah, I wrote a macro for that called loop-ex in 1982"
08:48:55 <edwardk> who noticed that the category of elgot algebras is the eilenberg-moore category for a completely iterative monad, iirc.
08:50:10 <mattam> Ok. I'm still strugling with there recursion schemes sadly... I actually read vene's thesis to understand some of your posts :)
08:50:15 * twobitwork waves his hand over his head
08:50:20 <ski_> edwardk s/(forall a./forall a. (/
08:50:25 <quicksilver> sclv_: of course there is, but he doesn't post on blogs :P
08:50:45 <edwardk> mattam: heh then at least it goes to show someone is reading them ;)
08:51:40 <edwardk> i pretty much exhausted all the haskell category theory literature, so now i'm stuck learning more category theory and dragging it down kicking and screaming into haskell.
08:52:07 <edwardk> hence my obsession with ideal monads and elgot (co)algebras.
08:52:36 <edwardk> i was just really pleased when i took an Elgot algebra and dualized it I got something more powerful (in Haskell) than the original
08:53:02 <mattam> If find your expositions very entertaining, I just wish you'd write them in Agda or Coq so that the laws would support the code and the explanations :)
08:53:03 <edwardk> mainly because of the asymmetry of how haskell is evaluated. we don't have first class continuations
08:53:22 <edwardk> mattam: i've been thinking about doing so in Coq, actually.
08:53:45 <mattam> I've not grasped the "lazy enough"/not strict enough point about elgot.
08:54:00 <edwardk> mattam: the thing is that widens my audience to include you and smerdyakov and maybe 2 others ;)
08:54:09 <mattam> Hehehe
08:54:10 <edwardk> mattam: take a look at the post on costrength
08:54:15 <mattam> I did
08:54:30 <edwardk> if you think about it costrength is basically a decidability question
08:54:40 <edwardk> but strength follows naturally from laziness.
08:54:59 <edwardk> so while they are categorical duals, the semantics of haskell make one trivial and the other hard.
08:55:07 <mattam> Oh yeah right I got that one. No way you can inhabit W (A + B) -> W A + B
08:55:15 <edwardk> exactly.
08:55:26 <ski_> edwardk : right !
08:55:27 <edwardk> now, look at how i make a elgot coalgebra emulate a paramorphism
08:55:28 <orbitz> strength from laziness
08:55:32 <orbitz> i'll tel lmy mom that one
08:55:36 <ski_> because haskell is assymetric !
08:55:42 <edwardk> i have to use monadic strength.
08:55:49 <mattam> Right.
08:55:53 <orbitz> gonadic strength
08:56:07 <edwardk> to do the same thing to get an elgot algebra to emulate its dual, vene's apomorphism, you need comonadic costrength
08:56:15 <edwardk> but there the asymmetry of haskell shuts you down.
08:56:25 * ski_ ponders about a `W (A (+) B) -> W A (+) B' for a multiplicative disjunction `(+)'
08:56:25 <edwardk> ski: exactly =)
08:56:52 <edwardk> ski: i think i saw a bit on that in a paper by cockett and seely
08:57:04 <edwardk> ski: i don't remember which one though
08:57:17 <mattam> So the point is that + should be lazy ?
08:57:41 <edwardk> sozeau: nah, the point is mostly that Elgot algebras are less useful in Haskell than my construction, Elgot coalgebras ;)
08:57:44 <ski_> mattam : yes, the `+' in there possibly should be lazy, like `->' is
08:58:17 <edwardk> ski: yeah the problem comes in from the impact of that on the semantics of the language and its reduction strategy
08:59:00 <ski_> (mattam : we need both the more known strict one ("either") (additive disjunction), and the lazy one ("par") (multiplicative disjunction) .. at least that's my hunch)
08:59:05 <mattam> A semi-decidable + ? Is there a formal system where costrength would make sense ?
08:59:14 <edwardk> basically in order to use costrength in general you have to admit the devil's bargain.
08:59:32 <edwardk> sozeau: sure, in filinksi's dual calculus it works fine
08:59:35 <twobitwork> @seen dons
08:59:36 <lambdabot> dons is in #haskell, #xmonad, #haskell-soc and #ghc. I last heard dons speak 16h 23m 58s ago.
08:59:39 <edwardk> er mattam
08:59:56 <mattam> There you go, one more thing to learn :)
09:00:20 <ski_> mattam : a value in `a (+) b' is a "linked" pair of values in `a' and `b', such that collapsing of structure in either of them may determine things in the other one (i.e. they may communicate)
09:00:28 <edwardk> mattam: the thing is you basically need to be able to pass around continuations as first class values
09:00:56 <mattam> Ok. I got that from your remark on call-cc
09:01:23 <edwardk> as ski is saying evaluating one will give you more information, exposing that you have a value to plug into that continuation, so you then go down that path.
09:01:23 <ski_> e.g. `a -> b' is basically `(Not a) (+) b', if you destruct the `Not a' part (by providing a value in `a'), the `b' can get determined (but also in the other direction, as evidenced by haskell)
09:02:07 <sclv_> so I guess you'd all recommend tackling vene's stuff seriously as a good starting point? The low code/diagrams ratio makes it tough going for me...
09:02:59 <mattam> ski_: ah great, I was thinking about that yesterday. I had  no clear idea how this -> decomposition was explained operationally.
09:03:13 <ski_> (there's also the slight matter that haskell functions (and values in general) can be reused, so you need to get a fresh instance of a `a -> b' before you get `Not a (+) b')
09:03:29 <edwardk> sclv: mostly vene's stuff can be summed up by saying that an apomorphism can give you back a structure containing either more seeds or the entire infinite tail of the structure. done ;)
09:03:37 <twobitwork> how do you send someone a note with the bot?
09:03:50 <edwardk> -- @tell soandso something
09:03:53 <sclv_> that includes the "essence of dataflow" stuff ?
09:03:54 <ski_> by "but also the other direction" i mean that if you force part of the output `b', then that may propagate demand backwards
09:03:58 <twobitwork> thanks
09:04:09 <edwardk> sclv: nah that actually has substance ;)
09:04:15 <ski_> s/force/force or select/
09:04:29 <sclv_> good to know.
09:04:40 <edwardk> you said vene, the dataflow stuff was uustalu and vene ;)
09:04:52 <twobitwork> @tell dons I'm having a problem with building your hs-plugins... says "src/Language/Hi/Binary.hs:90:7: \n  Could not find module `Data.Array.Base': \n  it is a member of package array-0.1.0.0, which is hidden"
09:04:52 <lambdabot> Consider it noted.
09:04:53 <mattam> ski_: I'm not sure about the b/call-by-name part. What eliminators do you have on (+) ?
09:06:13 <mattam> sclv_: If found Vene's thesis quite readable, the code is less documented than the diagrams but once you get there you need less explanations.
09:06:48 <ski_> mattam : i'm not aware yet of a nice and also expression-centered inference system including `(+)'
09:06:51 <edwardk> mattam: p7 of http://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf discusses the devil's bargain which relates ~~~a to ~a which is sufficient to allow the kind of backtracking needed to use costrength
09:07:17 <mattam> Seems like excluded-middle all over again indeed :)
09:07:34 <ski_> mattam : in two-sided linear classical sequent calculus, it's simple, however
09:07:38 <mattam> I guess linear logic.
09:07:55 <ski_> mattam : "excluded-middle" (though malnamed) is basically `a -> a', yes
09:08:09 <edwardk> an asymmetric system like http://research.microsoft.com/~simonpj/papers/not-not-ml/index.htm with a first class continuations is sufficient to encode it. and that system there can be easily made substructural. (i've done the construction twice now)
09:08:14 <lambdabot> Title: Haskell is not not ML, http://tinyurl.com/ffv6s
09:08:18 <mattam> Yeah, I'll give it a fresh look.
09:09:04 <mattam> Thanks for the references. Now I know what to do before the football match begins :)
09:09:51 <chessguy> hrm, that paper looks interesting
09:10:08 <edwardk> chessguy: the not not ml?
09:10:15 <chessguy> edwardk, yeah
09:10:54 <edwardk> i love that paper. i ambushed simon peyton jones at ICFP 06 about it and found out that its almost entirely Ben's idiosyncratic brainchild though. I was sad. I had so wanted to talk to him about my then obsessed over substructural variant ;)
09:12:25 <malcolmw> @tell gwern thanks - good point.  I've fixed the build and released hmake-3.14
09:12:26 <lambdabot> Consider it noted.
09:12:44 <edwardk> i found it a lot of fun to take that paper and do the same translation to wadler's paper on 'Down with  the Bureaucracy of syntax!' paper to get an explicitly continuation oriented linear logic.
09:14:08 <edwardk> another enlightening thing you can do is take the ~~ml approach and go through and reformulate a class pure type system into one that has only sigma types. this gives you a pure type system that has a very operational feel. you pass a value and a continuation into a continuation and they annihilate. the value is your input to the function the continuation you pass is where you want the output to go. thats exactly what you do on the stack!
09:14:33 <edwardk> so you can read off directly the semantics for your stack machine
09:14:47 <ski_> edwardk : hm, `elgot_apo' and `apo' seems like the difference between incrementing at the start contra the end of a loop
09:14:51 <edwardk> if you make the resulting construction substructural, including ordered continuations then you can read them off exactly.
09:15:12 <edwardk> ski: yeah the differences between them are fairly minor
09:15:32 <edwardk> though elgot apo is weaker than elgot.
09:15:54 <edwardk> i mostly was using elgot apo to try to show an elgot algebra as like something familiar
09:17:53 <edwardk> anyways the reason i mentioned elgot (co)algebras is because there is a nice category of elgot (co)algebras and they have fusion laws too.
09:19:57 <ski_> (hm <http://homepages.inf.ed.ac.uk/wadler/topics/linear-logic.html#dual-revolutions> looks interesting ..)
09:19:59 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/topics/linear-logic.html#dual-revolutions>
09:21:18 <edwardk> ski: i loved that paper. i don't think it ever got published, but it really shaped my thinking.
09:21:56 <edwardk> ski: i had assumed you'd read it years ago
09:22:23 <ski_> i might have skimmed it (or some similar one)
09:22:56 <edwardk> a slightly more asymmetric version in the style of haskel is not not ml isn't bad to code in though.
09:23:33 <edwardk> i might even have a copy of a calculus of that form lying around. if i find it i'll post it up or something
09:23:59 <edwardk> i may have 'kitchen sinked it' with a bunch of unrelated junk though.
09:24:01 * ski_ should try to type up his ideas in this area sometime, and see if it's useful ..
09:25:01 <edwardk> oh, another bit, the down with bureacracy of syntax approach works with other substructural connectives. you can do it with affinity, relevance, uniqueness. and its not not ml construction also works that way.
09:25:14 <edwardk> the trick is how do you publish something when one of its lynchpins is an unpublished paper ;)
09:25:26 <ddarius> You just publish it.
09:25:34 <edwardk> ddarius: fair nuff
09:25:56 <ddarius> You can cite unpublished papers
09:26:07 <edwardk> i suppose i should dust it off and finish it one of these days
09:26:19 <edwardk> i just got so sick of the notation =)
09:27:00 <edwardk> too many connectives, too many types. thats why i was so pleased when lippmeier did DDC so someone else had as many if not more symbols floating around in their type annotations as i did ;)
09:27:22 <quicksilver> you can cite unpublished papers and it's probably not too heinous if the paper is on a web page
09:27:37 <conal> geezusfreeek: ping
09:27:42 <quicksilver> if it's not even available on the web it's a bit harsh to your readers if it's anything more than an acknowledgement
09:28:03 <edwardk> i'll see if i can bring myself to write it up once i get over my current category theory and kata kick ;)
09:28:16 <matthew_-> anyone received icfp comments yet? I know it's not due until 9pm BST, just wondering if any have gone out early.
09:29:09 <ski_> edwardk : `DDC' ?
09:29:25 <edwardk> http://www.haskell.org/haskellwiki/DDC
09:29:27 <edwardk> @where ddc
09:29:27 <lambdabot> Title: DDC - HaskellWiki
09:29:29 <lambdabot> I know nothing about ddc.
09:29:35 <ddarius> Disciplined Disciple Comipler
09:29:36 <edwardk> @where+ ddc http://www.haskell.org/haskellwiki/DDC
09:29:44 <ski_> ok
09:29:46 <lambdabot> It is forever etched in my memory.
09:29:56 <edwardk> is the stuff from those slides we talked about maybe a year ago
09:30:34 <edwardk> explicit region annotations, constant and mutable regions, mutable regions allow for safe effectful destructive updates, et.
09:31:02 <edwardk> unfortunately as usual region semantics destroy the ability to use laziness so its strict.
09:33:44 <edwardk> ddarius: wanted to pick your brain for a sec
09:34:35 <ddarius> shoot
09:34:49 <edwardk> ddarius: data End s e = End (e -> forall a. s a) ((x -> forall a. s a) -> x -> e) -- is the type i'm currently kicking around for ends
09:35:06 <edwardk> er wait a sec
09:35:08 <edwardk> i think i typod
09:36:23 <edwardk> data End s e = End (e -> forall a. s a) (forall x. (x -> forall a. s a) -> x -> e)
09:36:33 <pip> Is lazy evaluation implementation dependent ?
09:37:33 <edwardk> er whoa i think i screwed that up completely, nm =)
09:37:34 <ddarius> lazy evaluation is an implementation strategy
09:37:50 <pip> I see
09:37:53 <ddarius> edwardk: Glad I could help.
09:39:00 <quicksilver> ddarius: although not a particularly well-defined one.
09:39:34 <quicksilver> ddarius: there are things like the 'full laziness transform' which GHC doesn't do, AIUI.
09:39:35 <edwardk> data End s e = End (e -> forall a. s a a) (forall x. (x -> forall a. s a a) -> x -> e) -- is the version i'm playing with, using the idea that given newtype Const k a b = Const k) i can view type Dinatural f g = forall a. f a a -> g a a -- with Dinatural (Const e) s as (e -> forall a. s a a)
09:39:59 <quicksilver> and the details of let floating are part of your evaluation strategy but not necessarily understood as part of the phrase 'lazy evaluation'
09:40:34 <edwardk> and then the right hand term is just the sort of 'end subtraction' law.  that says that if i have any other dinatural transformation of that form, then i can subtract it leaving x -> e
09:42:16 <pip> How to pronounce Haskell ?
09:42:37 <edwardk> as in eddie haskell ;)
09:43:15 <kaol> take cue from any of SPJ's videos
09:43:40 <quicksilver> hass (with ss like kiss) kell
09:43:47 <edwardk> ddarius: i was wondering if you cared to shoot holes in that implementation
09:43:58 <osfameron> stress on hass?
09:43:59 <quicksilver> pretty natural but it's a softish ss like kiss not a hard one like english has
09:44:02 * ddarius has a whole drawer full of sharpened pencils.
09:44:03 <pip> how about 'a' ?
09:44:13 <quicksilver> like 'happy'
09:44:21 <pip> bag ?
09:44:37 <quicksilver> yes
09:44:37 <osfameron> and is 'kell' like 'well' or an unstressed schwa?
09:44:38 <pip> I see, thanks guys
09:44:46 <edwardk> schwa
09:44:52 <quicksilver> osfameron: I prounce it as a schwa but I'm lazy in my speaking.
09:45:05 <quicksilver> it wouldn't sound "wrong" to me if you did a proper 'e'.
09:45:15 <quicksilver> Most of my 'e's sound like schwas being from the London area.
09:45:28 <osfameron> but it's more ambiguous with pascal if you say "HAS-KELL" will equal stress :-)
09:45:46 <quicksilver> True. I say HASSkull
09:46:02 <matthew_-> aol
09:46:30 <matthew_-> though I think I'm more like HASSkawl or even HASSkool
09:47:01 <Apocalisp> HAS-kl
09:47:50 <Apocalisp> like you would say high-school if you were from west texas.
09:47:55 <edwardk> ddarius: witht he definition for 's' in the above requiring that S be contravariant in its first argument and covariant in the second. so in the terminology of category-extras there is an instance Bifunctor s (Op k) k k requirement
09:48:13 <edwardk> er Bifunctor s (Op k) k Hask, since i use Hask as Set.
09:49:33 <edwardk> if i didn't have to interoperate with the mtl, etc. i'd go through and include the category k in the type and replace most of the ->'s
09:49:53 * edwardk shuts up.
09:50:32 <edwardk> when shapr showed up here he used to say ha-SKEL until we teased him into stopping ;)
09:51:08 <edwardk> because he used such an exaggerated emphasis in the second syllABLE ;)
09:51:14 <ddarius> edwardk: What's 'e' for?
09:51:42 <Eelis> Igloo: thanks for fixing the setResourceLimit bug!
09:51:45 * ddarius tends to pronounce it like Pascal.
09:52:21 <edwardk> ddarius: was following: http://en.wikipedia.org/wiki/End_(category_theory)
09:52:36 <edwardk> (e -> forall a. s a a) is my 'omega' from their definition.
09:53:09 <edwardk> which entails the e is in the type of End unless i am mistaken
09:53:47 <edwardk> or is it existentially quantified away so that you don't get to know what it is?
09:54:32 <edwardk> i.e.  data End s = forall e. End (e -> forall a. s a a) (forall x. (x -> forall a. s a a) -> x -> e)
09:55:18 <ddarius> edwardk: Usually we call what 'e' is, the end.
09:55:56 <edwardk> ddarius: yeah, but i have no way to encapsulate all the misc. machinery for getting there from \int_C S
09:56:47 <roconnor> > sort "*+"
09:57:04 <lambdabot>  thread killed
09:57:21 <Peaker> > sort [1,3,2]
09:57:21 <roconnor> lambdabot: it isn't that hard.
09:57:37 <lambdabot>  [1,2,3]
09:57:42 <Peaker> seems that it is ! :)
09:58:03 <roconnor> someone has replaced the sorting algorithm with randomsort
09:58:05 <Botje> > reverse $ sort "*+"
09:58:06 <edwardk> so what i have there is more like the meaning of \int_C S than the end itself?
09:58:07 <lambdabot>  "+*"
09:58:11 <ddarius> (a -> End f) ~ (forall i. a -> f i i) ~ (a -> forall i.f i i)
09:58:12 <Peaker> someone define sort as a  head $ filter isSorted $ allPermutations ... or something? :-)
09:58:17 <Peaker> s/define/defiend
09:58:27 <roconnor> > sort "*+"
09:58:27 <smg> btw tail recursion is always better?
09:58:29 <Botje> PRAISE THE SORTER!
09:58:30 <lambdabot>  "*+"
09:58:39 <Botje> smg: better than regular recursion? of course
09:58:53 <smg> Botje: yes
09:59:03 <Peaker> In Haskell - tail-recursion is not supposed to be better is it?
09:59:11 <ddarius> edwardk: You have the whole morphism (which is the actual end) whereas oftentimes, in this context, the object is separate from the morphisms.
09:59:13 <Botje> sure it is
09:59:31 <ddarius> E.g. we call (a,b) the pair, but it's actually the two projections.
09:59:38 <Peaker> Botje, even with lazy evaluation?
09:59:45 <edwardk> ddarius: hrmm
10:00:06 <edwardk> ddarius: trying to find a useful operational definition for End f
10:00:08 <Botje> Peaker: it's better when forcing, right?
10:00:17 <basvandijk> \leave
10:00:25 <Botje> when you're doing lazy evaluation .. i don't see why you'd see a difference with recursion
10:00:30 <edwardk> so right now i get newtype End f = End { runEnd :: forall i. f i i }
10:01:01 <Peaker> Botje, I believe people here told me that tail-recursion is even discouraged in a lazy language..
10:01:16 <ddarius> As a start, the end of hom(f-,g-) should be a natural transformation and indeed, type HomFG f g a = f a -> g a; End (HomFG f g) is Nat f g
10:01:26 <roconnor> Botje: under lazy evaluation, tail-recursion tends to create huge chains of thunks
10:02:18 <Botje> hmm
10:02:21 <Botje> i (think i) see
10:02:42 <edwardk> hrmm but End expects its argument to be in C^op * C right? is it just because HomFG discards one of those?
10:02:42 <smg> thunks was a redex?
10:02:55 <roconnor> > foldl f [1..4]
10:03:24 <Botje> "HomFG": the sound uttered by a haskell programmer when his/her program works at first try
10:03:39 <roconnor> lambdabot is running on a ZX81
10:03:44 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [t])
10:04:01 <roconnor> > foldl f 0 [1..4]
10:04:02 <lambdabot>  Add a type signature
10:04:18 <ddarius> edwardk: It doesn't discard one.  (->) is contravariant in it's first arg.
10:04:21 <roconnor> > foldl f a [b,c,d,e]
10:04:23 <lambdabot>  f (f (f (f a b) c) d) e
10:04:28 <Peaker> roconnor, sorting 3 ints would take something much worse to take 15 seconds ;-)  Like a lego brick turing machine or something
10:04:48 <Peaker> did anyone build a Turing Machine computer from Lego parts?
10:04:50 <Peaker> that could be cool
10:04:58 <Peaker> s/Turing Machine/Turing Complete
10:05:31 <edwardk> just trying to fit this into my understanding, wouldn't that then make type HomFG f g a b = f a -> g b to make for type End f = forall i. f i i, the notion of End (HomFG f g) well typed?
10:05:34 <ddarius> HomFG f g a uses 'a' both covariantly and contravariantly (assuming f and g are both covariant functors)
10:05:53 <ddarius> Yes, that's better.
10:06:39 <edwardk> ok, now i believe it =)
10:07:00 <edwardk> hrmm, so now coends?
10:07:55 <edwardk> existential under this formulation?
10:08:04 <roconnor> Botje: see that foldl produces f (f (f (f a b) c) d) e ?
10:08:14 <ddarius> (Coend f -> a) ~ (forall i. f i i -> a) ~ ((exists i. f i i) -> a) I guess.
10:08:29 <roconnor> Botje: the outer f is run first with lazy evaulation
10:08:47 <edwardk> that fits my understanding
10:08:57 <roconnor> Botje: typically the outer f will want to do something with both it's first and second parameter "e"
10:09:08 <gal_bolle> Peaker: http://www.mapageweb.umontreal.ca/cousined/lego/5-machines/turing/turing.html
10:09:09 <roconnor> Botje: but that "e" occurs at the end of our input list.
10:09:11 <lambdabot> Title: Turing machine, http://tinyurl.com/62qrm5
10:09:30 <gal_bolle> although i'm not sure about the turing completeness claim
10:09:35 <roconnor> Botje: so lazy evaluation will store a gian thunk as it consumes the entire input list to get at that e.
10:09:42 <Peaker> gal_bolle, the first sentence on that link gets like 3 different facts wrong ;-)
10:10:26 <gal_bolle> I count only 2, but I guess it's a matter of definition of computer
10:10:27 <edwardk> the only thing is this seems slightly less useful than the other formulation which could be used to factor out the end of other dinatural transformations
10:12:21 <edwardk> by that token should i deconstruct my nascent notion of universal morphisms: data Universal a f x = Universal (f x -> a) (forall z. (f z -> a) -> z -> x)
10:12:46 <edwardk> which were constructed similarly to how i was tackling Ends?
10:13:39 <edwardk> by explicitly packaging up the operational machinery needed to use them to clip functions?
10:14:39 <Botje> roconnor: sorry, dozed off there for a sec
10:14:55 <Botje> and yeah, i see
10:15:33 <Botje> so that's why foldr is preferred for known-finite lists?
10:15:48 <Botje> @pl \x r -> f x : r
10:15:49 <lambdabot> (:) . f
10:15:54 <Botje> excellent
10:16:00 <roconnor> Botje: foldr works well when f is lazy enough
10:16:22 <Botje> roconnor: thanks for the explanation, got a resource where i can read more?
10:16:26 <edwardk> the nice thing about that universal morphism formulation is you can rebuild the original function. after universalizing it:
10:16:26 <edwardk> universalize :: Universal a f x -> (f z -> a) -> z -> x ;; then f = extractU u . fmap (universalize u f)
10:16:53 <edwardk> the 'wordier End' would give you the ability to box up that same kind of law for dinatural transformations.
10:17:10 <Saizan> ?wiki stack overflow
10:17:12 <lambdabot> http://www.haskell.org/haskellwiki/stack_overflow
10:18:45 <elliottt> edwardk: great post yesterday!
10:18:56 <edwardk> elliottt: thanks! =)
10:21:22 <mauke> > length "２"
10:21:35 <smg> my teacher told, that let f = const 23 and then f BOTTOM will fail :(
10:21:36 <augur> lambdabot doesnt like you, mauke.
10:21:45 <mauke> @bot
10:21:54 <edwardk> ddarius: oh, in category-extras-speak: type HomFG = Lift (->)
10:21:58 <augur> > length "2"
10:22:07 <augur> i dont think lambda bot likes that statement
10:22:10 <augur> is it len?
10:22:13 <augur> > len "2"
10:22:13 <lambdabot>  1
10:22:14 <lambdabot> :)
10:22:17 <lambdabot>  1
10:22:19 <lambdabot>   Not in scope: `len'
10:22:19 <edwardk> er rather your first version is Lift (->0
10:22:26 <edwardk> my second one is Biff (->)
10:22:26 <augur> oic.
10:22:31 <augur> lambdabot is delayed
10:22:53 <edwardk> > let f = const 23 in f undefined
10:22:54 <augur> is lambdabot an actual bot or is it some nerd whos just sitting behind a haskell interpreter
10:22:55 <augur> lol
10:22:58 <lambdabot>  23
10:22:59 <mauke> > filter isDigit "abc789²³¹߀߁߂߃߄߅߆２３٣٤٥๙໐໑xyz"
10:23:00 <lambdabot>      lexical error in string/character literal at character '\1984'
10:23:06 <mauke> what
10:23:07 <edwardk> smg: your instructor was whole =)
10:23:08 <Peaker> augur, that question is one of science's biggest mysteries yet
10:23:13 <edwardk> er wrong
10:23:14 <smg> whole?
10:23:17 <smg> hehe.
10:23:22 <augur> @bot is you real!? :o
10:23:24 <smg> edwardk: i know but i didn't want to blame him
10:23:32 <smg> but all students agreed :)
10:23:39 <lambdabot> :)
10:23:39 <mauke> > filter isDigit "abc789²³¹߁߂߃߄߅߆２３٣٤٥๙໐໑xyz"
10:23:42 <lambdabot>      lexical error in string/character literal at character '\1985'
10:23:54 <Botje> SNOWMAN IS NOT A DIGIT? ZOMG
10:23:56 <edwardk> smg: i find that running the counterexample is a great way to silence inadequate instruction ;)
10:24:01 <mauke> it's not a snowman :(
10:24:17 <mauke> why the hell is that a lexical error?
10:24:34 <smg> edwardk: hehe, also in his FIRST lecture he introduced type chechking and howard-isomorphism, i don't think that's a proper introduction to haskell ;))
10:24:42 <Botje> mauke: what's the thing to the right of epsilon, then?
10:24:51 <edwardk> smg: fair nuff
10:24:52 <mauke> epsilon‽
10:25:15 <mauke> U+0664 (d9 a4): ARABIC-INDIC DIGIT FOUR [٤]; U+0665 (d9 a5): ARABIC-INDIC DIGIT FIVE [٥]
10:25:26 <edwardk> smg: curry howard i wouldn't be too afraid of introducing right off, deeper aspects of type checking? definitely i'd hold off a few class sessions on ;)
10:25:37 <Botje> it looks like an epsilon in my font :)
10:26:05 <smg> edwardk: he first introduced the type checking system in about 30 mins... then the isomorphism, and after that he explained us recursion, i had a laugh then :)
10:26:06 <Elly> it looks like a dashed box in my apparently-inadequate font
10:26:22 <smg> edwardk: i knew all that stuff already, so it was fun for me because all the other students where really shocked hehe
10:26:29 <edwardk> smg: what level course?
10:26:47 <smg> edwardk: the lecture is called "basic instruction to haskell and functional programming"
10:26:48 <smg> :))
10:27:11 <orbitz> what elvel class is that?
10:27:13 <mauke> > filter isDigit "abc789²³¹\1985\1984２３٣٤٥๙໐໑xyz"
10:27:15 <lambdabot>  ghc-6.8.2: panic! (the 'impossible' happened)
10:27:21 <lambdabot>   (GHC version 6.8.2 for i386-...
10:27:22 <edwardk> smg: i'd make sure to circle back and demo the f undefined bit to him if only to make sure he doesn't make the same pedagogical mistake in the future
10:27:23 <orbitz> i remember the horror my fellow students had when recursion was introduce din CS101 hafl way throuhg the semester
10:28:18 <smg> edwardk: hehe i heard from students which are in a higher semester that he does his lecture always this style
10:28:34 <smg> edwardk: really bad, because haskell should be fun, for me it is still, for 90% in the course it's not
10:29:03 <Elly> sounds like your teacher is pretty bad
10:29:38 <smg> he is sadly, but i learned all that haskell basics on my own so i can solve all exercises
10:29:39 <smg> :)
10:29:45 <Elly> ahh
10:30:02 <Elly> I had an excellent teacher for our intro type theory/functional programming class (which is taught in SML)
10:30:12 <smg> hehe
10:30:18 <b4taylor> SML FTW
10:30:37 <smg> Elly: you will have a laughter if i tell you what the topic of 2nd lesson should be :)
10:30:46 <Peaker> why can a newtype have a tuple type inside it, but not a record type inside it?
10:31:06 <Elly> SML is indeed a big win
10:31:09 <Elly> I like it a lot :)
10:31:25 <smg> Elly: it will be category theory
10:31:25 <Elly> it saves you having to explain monads along with type theory :P
10:31:28 <edwardk> peaker: you mean newtype foo = Foo ( Bar, Baz) but not newtype foo = Foo { bar :: Bar, baz :: Baz } ?
10:31:42 <Peaker> edwardk, yeah
10:31:46 <smg> very challenging first two lessons :)
10:31:51 <Peaker> edwardk, it seems like a superficial/syntatic difference
10:31:57 <edwardk> peaker: because haskel doesn't have 'record types'. (Bar,Baz) is a first class value in its own right you could construct.
10:32:31 <edwardk> the latter is syntactic sugar for Foo Bar Baz, bar (Foo x _) = x; baz (Foo _ y) = y
10:32:47 <edwardk> note the two terms in the constructor Foo, so now its no longer a value newtype.
10:33:47 <edwardk> the point of a newtype is that it is strict in the label, it doesn't introduce bottoms. newtypes wrapped around ()'s mean that the () is the place where the bottom occurs
10:33:54 <Peaker> edwardk, ok, but in an ideal world, a tuple and a "record" are just syntactic formations of same thing.  A tuple is a record where the names are 0, 1, etc
10:34:02 <edwardk> newtype Foo = Foo (Bar,Baz) is isomorphic to data Foo = Foo Bar Baz
10:34:44 <edwardk> peaker: yeah but generally if you are using a newtype to wrap a () you aren't getting any benefit out of the newtype other than labeling.
10:35:16 <Peaker> edwardk, I can use deriving
10:35:16 <edwardk> newtypes are intended primarily for when you have something like newtype Nat = Nat Int and you don't want to pay any overhead relative to using a native Int
10:35:58 <Peaker> edwardk, A performance hack?
10:36:11 <edwardk> that said i tend to use newtypes around tuples so that i can use pointfree notation on their contents easier ;)
10:36:41 <ski_> pointless records ftw !
10:36:49 <edwardk> peaker: yeah a newtype is purely a performance/semantics hack to avoid incurring overhead for allowing different operations to be performed on the same type
10:38:37 <edwardk> er same base representation
10:40:09 <Peaker> edwardk, I think I've been abusing newtypes when I should have used "data" then :)
10:40:32 <ski_> newtypes are for when you don't want an additional bottom
10:41:12 <edwardk> peaker: data types are strictly more powerful. you can use them for disjunctions, you can use them for existential quantification, all sorts of stuff that newtypes aren't allowed to do.
10:41:33 <dbueno> newtypes also bless an existing type with a new identity, so for instance you can declare distinct typeclass instances over the same base type, but you use the newtype identity to do so.
10:42:30 <dbueno> For instance if you have a type that admits several reasonable monoids, you can write each reasonable instance by using a newtype over the base type that admits those instances.  Then all the different monoid definitions can coexist.
10:43:30 <ski_> (that's still a kind of hack, though, imo)
10:43:58 <Peaker> dbueno, couldn't do that with a Data?
10:44:19 <dbueno> Peaker, I should have appended, "without incurring runtime overhead."
10:44:42 <edwardk> peaker: you can, but then you introduce a bottom if your data type only contains one value.
10:44:43 <ski_> you could (at least in common cases), but you get the extra bottoms
10:45:15 <edwardk> data Foo = Foo Bar; and newtype Foo' = Foo' Bar are different, because _|_ = Foo' _|_, but _|_ and Foo _|_ are distinguishable.
10:45:16 <ski_> and you need to write explicit constructors / destructors conversion for the members
10:45:52 <edwardk> because in the data type case you have a 'layer to peel off' that may be a bottom
10:46:23 <Peaker> edwardk, a newtype forces me to "peel it off" too.. where's the expressive penalty?
10:46:35 <ski_> (s/distinguishable/semi-distinguishable/ .. or something)
10:46:50 <thetallguy> >describeSequence [1,2,1,3,2,3,1,4,3,5,2,5,3,4,1]
10:46:52 <ski_> Peaker : you don't express the exact same semantics
10:46:56 <dbueno> Peaker, in the runtime representation there's an extra layer, he means.
10:47:11 <dbueno> Peaker, newtypes get stripped away at compile-time.
10:47:13 <edwardk> peaker; you peel it off but you can't make a function where you can return _|_ if given a Foo' _|_ and won't if given a_|_
10:47:27 <edwardk> newtypes have no operational overhead. data types force a case evaluation basically
10:47:35 <Peaker> is it possible to import qualified, but import some specific things (e.g (!) ) non-qualified?
10:47:42 <ski_> yes
10:47:56 <edwardk> import Prelude ((!)); import qualified Prelude
10:47:59 <ski_> just use several import statements
10:48:00 <edwardk> you an import twice
10:48:01 <Deewiant> > describeSequence [1,2,1,3,2,3,1,4,3,5,2,5,3,4,1]
10:48:02 <lambdabot>  Just "Stern's diatomic series: a(0) = 0, a(1) = 1; for n >= 0, a(2n) = a(n),...
10:48:05 <edwardk> or more than twice if you want
10:48:08 <Peaker> oh, double ()
10:48:31 <ski_> @type describeSequence
10:48:41 <lambdabot> SequenceData -> Maybe String
10:48:47 <edwardk> the first parens say you are listing the things you want inside of them, and to import an operator it must be surrounded in parens
10:48:48 <thetallguy> Hmm... The bot seems to be ignoring me.  Has it been protected somehow?
10:48:57 <augur> > decribeSequence [0,1,2,1,2,3,2,3,4,3,4,5,4,5,6,5,6,7,6,7,8,7,8,9]
10:49:09 <lambdabot>   Not in scope: `decribeSequence'
10:49:13 <ski_> thetallguy : are you identified to the network ?
10:49:14 <augur> ah, see? lambdabot aint that smart now is it
10:49:15 <Peaker> hmm, I am trying to define my own ! in terms of Map.(!)  but I can't import (!) non qualified (conflicts my own) and  Map.(!) is invalid syntax
10:49:21 <augur> oh whoops.
10:49:24 <edwardk> what is describeSequence? something that hits OEIS or something?
10:49:27 <elliottt> edwardk: is it just coincidence that the diagram for a right kan extension looks similar to that of the fundamental theorem on homomorphisms?
10:49:28 <augur> > describeSequence [0,1,2,1,2,3,2,3,4,3,4,5,4,5,6,5,6,7,6,7,8,7,8,9]
10:49:35 <ski_> edwardk : probably
10:49:35 <lambdabot>  Just "a(n) = a(n-3) + 1."
10:49:35 <Deewiant> edwardk: exactly that.
10:49:40 <edwardk> beautiful =)
10:49:41 <Deewiant> @where oeis
10:49:44 <lambdabot> http://hackage.haskell.org/packages/archive/oeis/0.1/doc/html/Math-OEIS.html
10:49:46 <ski_> > describeSequence []
10:49:47 <elliottt> edwardk: nevermind, it is :)
10:49:50 <lambdabot>  Just "Exception: MathNon-exhaustive patterns in function combineConts
10:49:53 <ski_> !
10:49:55 <dbueno> Peaker: use Map.!
10:49:56 <thetallguy> ski: probably not.  I've never really sorted that out.  TIme for some googling
10:50:13 <augur> :o
10:50:16 <augur> lambdabot is smarts!
10:50:17 <augur> :o
10:50:26 <Peaker> dbueno, thanks
10:50:37 <augur> > describeSequence [1,4,8,7,9,0,3,4]
10:50:42 <edwardk> elliottt: glad i could help ;)
10:50:48 <Peaker> its a pain to repeat  (Ord k1, Ord k2)  in all of my type signatures (Making a bidirectional map one-to-many)
10:50:54 <Peaker> any way to avoid that?
10:50:59 <tromp_> > extendSequence [1,57,12675]
10:51:19 <augur> omg did i break lambdabot? :X
10:51:29 <Peaker> > describeSequence [0,1,1,2,3,5,8,13]
10:51:48 <edwardk> augur: more likely ski did ;)
10:52:08 <augur> did he?
10:52:13 <ski_> errps, that could have been it
10:52:20 <augur> ski! fix lambdabot. :|
10:52:27 <elliottt> edwardk: i realized that one of the arrows was going the wrong way :)
10:52:33 <ski_> lambdabot: fix yourself!
10:52:44 <lambdabot>  Nothing
10:52:49 <ski_> see :)
10:52:53 <augur> lol
10:52:53 <lambdabot>  [1,57,12675,24318165,414295148741,62567386502084877,83677847847984287628595,...
10:52:59 <tchakkazulu> > fix error
10:52:59 <lambdabot>  Just "Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = ...
10:53:10 <paolino> Peaker make a class to write only one constraint
10:53:25 <smg> lambdabot: i <3 u
10:53:33 <lambdabot>  thread killed
10:53:42 <tchakkazulu> Awww :(
10:53:43 <augur> > describeSequence [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4]
10:53:48 <lambdabot>  Just "Binary order of n: log_2(n) rounded up to next integer."
10:54:15 <tromp_> >(extendSequence [1,57,12675])!!16
10:54:25 <Peaker> paolino, how?
10:54:33 <conal> twanvl: ping
10:54:33 <ski_> > extendSequence [1,2,4,8]
10:54:41 <augur> > describeSequence [0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0]
10:54:41 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
10:54:42 <Peaker> paolino, I am defining:
10:54:43 <lambdabot>  Just "Expansion of zeta(3) in base 2."
10:54:46 <Peaker> data (Ord k1, Ord k2) => MapManyToOne k1 k2 = MapManyToOne { forward :: Map.Map k1 k2,
10:54:46 <Peaker>                                                                backward :: Map.Map k2 (Set.Set k1) }
10:55:37 <ski_> class (Ord k1,Ord k2) => OrdOrd k1 k2
10:55:41 <paolino> class (Ord k1,Ord k2) => Ordk k1 k2
10:55:49 <ski_> instance (Ord k1,Ord k2) => OrdOrd k1 k2
10:55:57 <Peaker> ah thanks - that doesn't save that much though
10:56:54 <conal> i'd like to play with twanvl's Expr code.  is in a repo? on hackage?
10:57:47 <augur> lulz
10:57:49 <augur> watch this
10:57:53 <augur> > describeSequence [0]
10:57:58 <lambdabot>  Just "Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = ...
10:58:33 <augur> > describeSequence [4]
10:58:37 <lambdabot>  Just "Euler totient function phi(n): count numbers <= n and prime to n."
10:58:49 <augur> i think lambdabot is a bit weird. lol
10:59:06 <augur> > describeSequence [3]
10:59:14 <lambdabot>  Just "The prime numbers."
10:59:17 <sclv_> enough botspam. take it to privmsg please.
10:59:26 <augur> :P
10:59:28 <tromp_> >(extendSequence [1,57,12675])!!8
11:01:15 <RayNbow> hmm, has anyone here seen that Intel demo of a multicore machine doing some physics/rendering stuff?
11:01:21 * RayNbow can't find the video of it...
11:03:31 <RayNbow> ah n/m, found it :)
11:03:38 <RayNbow> http://www.tgdaily.com/content/view/36758/135/
11:03:45 <lambdabot> Title: TG Daily - People probably wont need discrete graphics cards anymore  Intel
11:04:43 <conal> intel and nvidia are battling for mindshare
11:04:58 <smg> "discrete"?
11:05:17 <Vulpyne> As a seperate card, I'm assuming.
11:05:29 <conal> yeah-- separate from motherboard
11:08:03 <tromp_> > :t fmap const
11:08:05 <lambdabot>   parse error on input `:'
11:08:11 <tromp_> :t fmap const
11:08:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> f (b -> a)
11:08:23 <tromp_> :t fmap return
11:08:27 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Functor f, Monad m) => f a -> f (m a)
11:13:31 <Dzlk> Hm. With hoogle, is there a trick to look for functions in a specific module that match a given type?
11:14:30 <augur_> hrmph.
11:19:51 <twanvl> conal: the SimpleReflect code is only in the lambdabot repo. I really ought to put it on hackage, though.
11:20:05 <conal> twanvl: thx.
11:22:47 <MarcWeber> Can I use template haskell to get to know the return type of a function after applying it to a value of type T ?
11:26:13 <thetallguy> conal: I'm a little confused about the end of post 2
11:26:59 <Dzlk> Hm. Of course it may be the reason I'm not finding what I want is that it isn't there.
11:27:27 <thetallguy> conal: you introduce  type a :-* b =..., but you don't seem to use it.
11:28:17 <conal> thetallguy: oops.  let me look ...
11:28:57 <conal> thetallguy: oh darn.  i renamed one (:->) to (:-*) but not the other.  thx!  fixing now.
11:29:04 <thetallguy> Whew
11:32:33 <thetallguy> conal: thank you, much better.  I was cruising along smoothly and then my brain jumped the tracks
11:33:34 <fophillips> Does anyone happen to recall the name/author of the paper about mathematics in education, how the current model of examination is broken which was discussed in here a couple of months ago?
11:35:06 <thetallguy> fophillips: no, but you might search through the logs
11:35:25 <fophillips> Easier said than done.
11:35:40 <thetallguy> fophillips: I
11:35:44 <thetallguy> 'll have a go
11:35:48 <tchakkazulu> Should be a few links from here: http://wadler.blogspot.com/2008/03/lockharts-lament.html
11:35:50 <lambdabot> Title: Wadler's Blog: Lockhart's Lament
11:36:00 <fophillips> Ah, thanks.
11:36:43 <fophillips> http://www.maa.org/devlin/LockhartsLament.pdf
11:36:55 <thetallguy> oh, that one.  I didn't find that one to be very useful.
11:37:34 <fophillips> Really?
11:37:52 <lament> is that the one about how much math sucks?
11:38:09 <fophillips> About how much mathematics education sucks.
11:38:16 <BMeph> I found it very "Hmm"-worthy. :)
11:40:23 <Dzlk> Hm. Is there a library somewhere that has a Parsec parser for pcre regexps that I can use?
11:41:45 <Dzlk> Yow. Accidentally hit return before finished editing the line. Er, "that I can use in mine".
11:42:17 <Apocalisp> ?yow
11:42:20 <lambdabot> Here we are in America ... when do we collect unemployment?
11:43:53 <thetallguy> fophillips: no, I read a review of that article that was not helpful.  Apparently I never got to the primary source.  That pdf looks much more interesting.
11:43:53 <Dzlk> (Except that I decided that was verbose and unclear and went back to change it to "is there a library that exposes a". But then hit return instead of delete at the '?'. Rgh.)
11:44:38 <fophillips> thetallguy: The paper itself is very thought‐provoking.
11:45:08 <augustss> @seen conal
11:45:09 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 6m 56s ago.
11:46:31 <conal> augustss: hi!
11:46:35 <thetallguy> fophillips: I'll have to read it fully.  At first glance, it still looks like it focuses on complaints rather than solutions
11:47:04 <augustss> conal: I was playing with your new library today
11:47:07 <thetallguy> fophillips: but then, I've been thinking a bunch about this area recently, so maybe I'm just jaded.
11:47:07 <fophillips> thetallguy: Solutions aren’t really that easy to come by.
11:47:13 <fophillips> :)
11:47:15 <conal> augustss: yay!
11:47:29 <augustss> conal: it's very neat
11:47:36 <conal> augustss: :)
11:47:43 <conal> augustss: have you combined AD and Expr?
11:47:51 <conal> augustss: i have a vague memory but can't find it on your blog
11:48:13 <augustss> I've combined AD and Symbolic
11:48:23 <conal> augustss: what's Symbolic?
11:48:57 <augustss> Numbers where you are allowed variables, like var "x"
11:49:05 <conal> augustss: i want to see some higher derivatives.  i think there's a big inefficiency in the formulation we've been using (Jerzy's).
11:49:11 <augustss> very handy to see what is going on
11:49:27 <conal> augustss: in a library somewhere?
11:49:29 <gwern> @tell malcolmw ok, hmake compiles for me now, thanks. maybe I'll cabalize it later
11:49:39 <lambdabot> Consider it noted.
11:49:54 <augustss> conal: hackage, numeric
11:50:05 <conal> augustss: i'll grab it.  thanks.
11:50:30 <augustss> conal: I have one complaint about your library as it is right now, though
11:50:39 <conal> augustss: shoot
11:50:52 <augustss> it makes functions an instance of Num
11:50:59 <conal> augustss: numeric-prelude?  i don't see a numeric.
11:51:02 <augustss> which forces Eq and Show
11:51:17 <conal> augustss: sadly, as usual with Num
11:51:39 <conal> augustss: what's the complaint?
11:51:57 <augustss> That it makes functions an instance of Num
11:52:13 <augustss> I don't want that.  It makes error messages obscure
11:52:17 <Syzygy-> augustss: Saw your IOCCC byte code interpreter today.
11:52:27 <Syzygy-> It got linked in from a completely different IRC channel...
11:52:32 <augustss> And I often want my own Show for functions
11:52:36 <augustss> Syzygy-: :)
11:52:44 <conal> augustss: i don't get it.  you don't want functions in Num?  what messages, e.g.,?
11:53:16 <augustss> conal: sorry, the package is called numbers
11:53:42 <conal> augustss: ah, i do see that package
11:53:43 <doun> does anybody have a page about using XPath in Haskell to find something in an XML document? I don't want to have to read five papers about combinators just to parse and find something in a simple document
11:54:08 <dons> doun: go to hackage.haskell.org
11:54:10 <conal> augustss: hey!  i totally missed this package.  very glad to know about it.
11:54:11 <dons> look at the xml libs.
11:54:22 <dons> doun: nothing to do with papers.
11:55:17 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
11:55:38 <conal> augustss: oops -- i overlapped your lib considerably.
11:55:55 <augustss> conal: yeah, but your's is nicer
11:56:32 <conal> augustss: you also have the C (constant) case in Dif, which probably helps perf.
11:56:34 <BMeph> conal, augustss: Collaborate, and re-publish! ;)
11:56:45 <augustss> conal: btw, the extra constructor for constants makes a huge difference for efficiency in many cases
11:57:00 <augustss> BMeph: it's already been published
11:57:15 <conal> augustss: sigh.  i thought so.  too bad it blows up the code.
11:57:22 <BMeph> ...thus the "re-" part. ;)
11:57:45 <conal> augustss: oh, you did (* 0) as well
11:58:08 <MarcWeber> doun: Goto the homepage of HaXml there are same examples. Or take any tutorial about the xpath query language
11:58:25 <conal> augustss: maybe much of the constant-handling can be absorbed in a chain rule & similar.  some of it looks regular.
11:58:58 <augustss> conal: probably
11:59:17 <conal> augustss: Symbolic doesn't manage precedence, does it?
11:59:22 <doun> MarcWeber: I don't see any examples on the home page
11:59:41 <augustss> conal: it prints with precedence
12:00:01 <conal> augustss: oh -- sure enough!
12:00:32 <conal> augustss: wonderful.  i was just about to hack together the same functionality (Symbolic).  i'll use yours instead.
12:00:34 <geezusfreeek> conal: oh hi
12:00:41 <geezusfreeek> conal: sorry, i must have been in the other room
12:00:42 <conal> geezusfreeek: hi
12:00:55 <conal> geezusfreeek: np.  i emailed you instead.
12:01:06 <geezusfreeek> i only just noticed this as i was closing windows to leave for work
12:01:10 <augustss> conal: Symbolic is great for debugging these kind of things
12:01:15 <geezusfreeek> conal: ah, well i have responded to that
12:01:21 <conal> @localtime geezusfreeek
12:01:33 <geezusfreeek> conal: yes, it's a bit late for me
12:01:44 <geezusfreeek> huh, i have no localtime apparently
12:01:48 <conal> no lambdabot?
12:01:55 <conal> @yow
12:01:57 <geezusfreeek> conal: 2pm (CST)
12:02:03 <lambdabot> ... I have read the INSTRUCTIONS ...
12:02:03 <lambdabot> Local time for geezusfreeek is 2008-05-21 14:01:57 -0500
12:02:07 <conal> oh
12:02:09 <conal> !
12:02:18 <doun> the lack of straight-forward documentation makes me depressed
12:02:19 <conal> out-of-order execution
12:02:48 <MarcWeber> doun: Sorry I've mixed up Xtract and the xpath function.. but the first one beeing an example for the second one.. :) You can find it in the source distribution
12:02:54 <geezusfreeek> i have come to believe, without looking at the source, that lambdabot creates a new thread for each command it executes
12:02:59 <thetallguy> doun: yes, it is, but I've taken that to be a function of XML's bad design
12:03:06 <svein_> I did something a bit silly, and.. um, is it possible to use lambdabot admin privileges to run any shell commands?
12:03:08 <geezusfreeek> and sometimes takes a long time
12:03:15 <conal> augustss: please say more about functions & error messages.  i don't know whether you dislike having function Nums in itself, or you're concerned about error messages specifically, or both, or ...
12:03:15 <thetallguy> doun: you might look at HSP
12:03:17 <geezusfreeek> anyway, off to work, i will be back
12:03:29 <thetallguy> http://www.cs.chalmers.se/~d00nibro/hsp/
12:03:32 <lambdabot> Title: HSP - Haskell Server Pages
12:03:36 <conal> geezusfreeek: oh yeah!  with the time-out.
12:03:55 <thetallguy> It requires installing a bunch of stuff, but the handling of xml in code is pretty elegant
12:04:39 <thetallguy> geezusfreeek: where in the mid-west are you?
12:04:45 <augustss> conal: first, I think making any kind of instances for -> must be done with great care since they have big impact, so I object to -> being in Num just because it makes your implementation convenient.  I might not want that instance.
12:05:22 <conal> augustss: oh!  i get it.  haskell doesn't let one localize the effect of instance declarations.
12:05:39 <augustss> conal: making -> a Num means that, e.g., 'f + 1' is now a correct subexpression, when I really meant 'f x + 1'
12:05:44 * monochrom lols at bos's haskell-cafe post on prion proteins and typeclass constraints.
12:05:52 <augustss> conal: exactly
12:06:27 <monochrom> In fact, IO is also like prion proteins. :)
12:06:45 <augustss> The mad cowstraint disease
12:07:03 <conal> augustss: yeah.  sigh.  has anyone addressed the general problem?  making instances more managable, rather than avoiding them?
12:07:03 <augustss> Or maybe the mad cowtext disease
12:07:38 <augustss> conal: I've not seen anything worked out properly that guarantees coherence
12:08:21 <conal> augustss: i wonder whether anyone cares enough to work it out, or if it's just one of the warts people get used to.
12:08:51 <augustss> conal: I fear the latter
12:09:24 <conal> augustss: me too.
12:09:25 <augustss> conal: I think there's a solution, though.
12:09:53 <augustss> Oleg has some stuff that can simulate local instance declarations, if I remember right
12:12:53 <thetallguy> augustss, conal: I don't quite follow the 'local instance' bit.  would local instance declarations let you have multiple instances of the same class and type, e.g., additive and multiplicative groups over the integers?
12:13:35 <conal> thetallguy: that or additive instance and *no* instance.
12:14:04 <conal> thetallguy: i've given a Num instance for functions, and lennart would rather get error messages.
12:14:19 <thetallguy> conal: so, I could import instances piecewise, just like module components?
12:14:22 <conal> thetallguy: or sometimes, *different* error messages.
12:14:38 <conal> thetallguy: something like that, i guess.
12:14:39 <tchakkazulu> A problem to local class instances is what you'd do with functions that use them.
12:14:55 <tchakkazulu> They invariable have Class a => contexts, but outside of the module, this instance isn't known :-/
12:14:59 <tchakkazulu> *invariably
12:15:06 <conal> thetallguy: now you're getting into the answer, while i don't even know how to state the question precisely.
12:15:59 <christastrophe> hmm. is there a way to make Data.IntMap.lookup return a Maybe instead of an exception when the key is not found?
12:16:00 <thetallguy> conal: gotcha.  It seemed fuzzy to me, but I thought it was clearer for you guys.  I think I understand what I don't understand now.
12:16:18 <tchakkazulu> And if you don't expose any of the things that use the local instance, you might just as well use different names only for that module.
12:16:40 <christastrophe> it seems it used to have that behavior... but it was changed... I don't understand clearly why
12:17:25 <augustss> christastrophe: it returns Maybe if that's what you demand
12:17:38 <thetallguy> christastrophe: findWithDefault?
12:17:57 <christastrophe> I don't understand monads well enough yet, how can I demand it return in the Maybe monad?
12:18:04 <thetallguy> oh, right, lookup already has the monad type
12:18:15 <augustss> christastrophe: just put the lookup in a case and match on Nothing and Just
12:18:26 <christastrophe> oh neat
12:18:57 <christastrophe> so it will then automatically return inside a Maybe, just by setting up case analysis for a Maybe result? that is cool
12:19:35 <svein_> christastrophe: The type-checker uses unification, yeah. Think prolog - if there /is/ a solution, it will find one.. though there are truly perverted programs that can force it into a loop
12:19:48 <thetallguy> christatrophe: this is sort of sneaky in ghci.  Since you're in the IO monad there, it will fail, but if you do 'lookup ... :: Maybe YourType', then you will get what you are looking for
12:20:06 <augustss> svein_: no loops unless you ask for it
12:20:54 <christastrophe> cool. testing inside a case will work just fine for me.
12:21:10 <svein_> christastrophe: Or you could use ghc's very neat pattern guard extension
12:23:10 <christastrophe> i thought that could only be used when defining a function...
12:24:44 <stwange> sorry to bother you, but in set notation what does an upside down A mean? eg. 'upside-down-A'x  L1*
12:25:10 <Zao> For all.
12:25:21 <stwange> thasnks Zao
12:25:27 <stwange> thanks*
12:26:06 <augur_> its not set notation
12:26:11 <augur_> its propositional logic notation
12:26:30 <Baughn> Yay. Nothing quite like blindly editing sshd configurations using a keyboard after locking yourself out of the server.
12:26:32 <Saizan> stwange: btw, it's called universal quantifier
12:26:38 <ksandstr> followup question: what's the natural key combination to bind that to? what about \exists ?
12:26:39 <augur_> it's a statement about items
12:26:40 <stwange> is that what turing reductions come up?
12:26:46 <stwange> sorry, I can speak English... come under
12:26:55 <augur_> for for instance Ax.(x is red) says something like
12:27:01 <augur_> "everything is red"
12:27:10 <stwange> Baughn I was switching ssh client the other day on my server and typed killall sshd :(
12:27:25 <Baughn> stwange: Ow. Well, at least a reboot would fix that
12:27:30 <stwange> ah that explains what the . meant :)
12:27:32 <Baughn> stwange: I had a debian update stop all logins
12:27:50 <stwange> Baughn - I found a web access terminal luckily :))
12:27:58 <augur_> the x, btw, is just an empty variable thats used to represent any thing
12:28:08 <augur_> the backwards E says "there is some ..."
12:28:10 <augur_> so for instance
12:28:14 <augur_> Ex.(x is red) says
12:28:20 <augur_> there is some x such that x is red
12:28:22 <roconnor> oh Joe Hurd works at Galois
12:29:19 <augur_> these are simple quantifiers
12:29:34 <stwange> ok I can't find the symbols but I think I understand the notation in front of me now. Thanks a lot augur :) Assuming I'm right: Ax  E1* . x  L1 iff f(x)  L2 - means for all combinations from the alphabet, the combination is only a member of L1 if f(combination) is a member of L2?
12:29:50 <augur_> what's the pound sign??
12:30:11 <stwange> the closest I could find. Member of I think it means
12:30:20 <augur_> you mean element of?
12:30:25 <augur_> just use haskellian <-
12:30:28 <stwange> yeah
12:30:29 <wjt> € looks closer :)
12:30:58 <stwange> wjt maybe on your client but on this one it's a weird a followed by 
12:30:59 <ksandstr> so twenty years later, we would actually have a good use for one of those crazy 11-modifier keyboards
12:31:04 <augur_> so what you mean to say is.. for all x, such that x <- E1, x <- L1 iff f(x) <- L2
12:31:06 <augur_> well
12:31:26 <augur_> im not sure if you can use quantifiers with sets. i suppose you oculd
12:31:27 <stwange> yeah, there's a * after E1
12:31:32 <augur_> ok.
12:31:37 <augur_> but yeah, sure
12:31:42 <augur_> thats what it says.
12:32:09 <stwange> thanks a lot :) all this greek just gets confusing
12:33:13 <augur_> prop. log. quantifiers are nice and simple
12:33:19 <augur_> you try doing quantifiers in natural language
12:33:21 <augur_> whoa boy.
12:33:45 <augur_> keep in mind that quantified statements are still statements
12:34:09 <monochrom> You probably mean pred. log. quantifiers. prop. log. has no quantifier.
12:34:28 <augur_> doesn't it? whatever. i always confuse them. :P
12:34:38 <augur_> i mean what i mean! :P
12:34:45 <monochrom> Oh, and all hail the ambiguity of "." in "this is an abbreviation" and "this is the end of a sentence". :)
12:35:19 <monochrom> everyone loves someone
12:35:33 <augur_> but yeah, stwange, Ax<-E1* doesn't mean all elements of E1*
12:35:42 <augur_> its not a set
12:35:56 <augur_> rather, it' a statement. or part of a statement.
12:36:03 <monochrom> Actually "everyone loves someone" isn't all that bad because somehow we have a consensus or convention on what it means.
12:36:19 <augur_> do we? :p
12:36:33 <monochrom> But "there is y such that |y|>=x for all x" is ridiculous.
12:36:42 <augur_> Ax.Ey.x loves y
12:37:04 <augur_> which is definitely not the same as Ey.Ax.x loves y
12:37:26 <augur_> monochrom, do you know much about semantics?
12:37:35 <monochrom> I think we agree that "everyone loves someone" is Ax.Ey.x loves y.
12:37:46 <monochrom> Depends on which semantics.
12:37:49 <augur_> i think thats the convention, yeah.
12:37:50 <ski_> reset ((\x y -> loves x y) (shift c0. forall x0. c0 x0) (shift c1. exists x1. c1 x1))
12:37:57 <lament> monochrom: i think that's because the second meaning is clearly nonsense, and not because this reading is somehow preferred
12:37:58 <augur_> semantics of natural languages. :P
12:38:19 <monochrom> I deplore natural languages. I guess I know little.
12:38:25 <lament> so we determine that one of the readings is clearly nonsense, and assume the other meaning is what was actually meant
12:38:29 <augur_> thats a shame. natlangs are cool.
12:38:38 <augur_> lament: actually no
12:38:42 <augur_> both meanings are sensible
12:38:46 <augur_> for instance
12:38:55 <stwange> sorry i went to the toilet, what do you mean Ax<-E1* doesn't mean all E1*? what does it mean then?
12:39:10 <augur_> Ax<-E1* by itself doesnt mean _anything_
12:39:20 <augur_> its like asking what "fo" means in the word "food"
12:39:38 <augur_> the way it works is like this
12:39:54 <augur_> Qx.statement
12:39:58 <lament> augur_: in that particular sentence, without context, the reading "there's someone who's loved by everyone" is clearly nonsense so we disregard it
12:39:59 <augur_> Q being the quantifier
12:40:05 <augur_> like A or E
12:40:19 <ski_> <http://www.cs.bham.ac.uk/~hxt/cw04/barker.pdf> Continuations in Natural Language
12:40:20 <augur_> x being your variable (or your element of x <- E1*)
12:40:27 <augur_> and statement being any statement
12:40:32 <augur_> Qx.statement is also a statement
12:40:35 <augur_> its not a set of things
12:40:43 <augur_> but rather a statement ABOUT things
12:40:48 <augur_> think of it like this
12:41:09 <augur_> is "all cats" a collection of cats?
12:41:19 <augur_> you might want to say yes
12:41:24 <augur_> but what about "some cats"?
12:41:28 <augur_> or "no cats"?
12:41:40 <ski_> or "any cats" :)
12:41:45 <augur_> any cat*
12:41:47 <augur_> :P
12:41:58 <augur_> any selects a singular DP complement ;)
12:41:58 <ski_> .right
12:42:08 <christastrophe> is there an idiomatic way of writing (\_ -> a), meaning a function that discards its argument and returns a constant?
12:42:09 <augur_> the same is sort of true of pred-log quantifiers. they're not really collections of things
12:42:14 <stwange> yeah I'd say it's a set of cats, that could be empty?
12:42:25 <ski_> christastrophe : `const a'
12:42:25 <augur_> they relate a collection of things and a statement about that collection
12:42:45 <augur_> how can it be a set of cats thats empty?
12:42:49 <augur_> thats just an empty set
12:42:50 <augur_> {}.
12:42:54 <augur_> no cats = {}
12:42:55 <christastrophe> ah. makes sense.
12:42:56 <christastrophe> thanks
12:43:01 <augur_> but thats obviously not right
12:43:18 <augur_> "No cats are green" might be true, but it doesnt mean that nothing is green.
12:43:29 <augur_> the predicate logic quantifiers are relational terms
12:43:40 <augur_> they relate the thing to the left of the . to the thing on the right of the .
12:44:00 <augur_> another way of looking at the pred-log quantifiers is like this:
12:44:00 <ski_> forall x. x `elem` {} => green x
12:44:03 <augur_> if i say something like
12:44:16 <augur_> Ax<-Birds.x flies
12:44:21 <augur_> meaning "all birds fly"
12:44:28 <augur_> what i'm really saying is something like this
12:44:44 <augur_> the set of Birds is a subset of the set of Fliers
12:45:18 <Zao> augur_: So what about penguins?
12:45:27 <augur_> i never said the statement was TRUE
12:45:39 <augur_> just like 1 == 2 is a statement about 1 and 2
12:45:43 <augur_> its a FALSE statement
12:45:47 <augur_> but its a statement none-the-less
12:46:10 <augur_> thats why i stress the nature of quantifiers
12:46:22 <augur_> "Ax<-Birds.x flies" is not a SET
12:46:24 <augur_> its a STATEMENT
12:46:27 <augur_> its either true or false
12:46:40 <augur_> and which it is depends on the environment you evaluate it in
12:47:51 <augur_> the same is true of E
12:48:03 <ski_> `E' ?
12:48:09 <augur_> the existential quantifier
12:48:28 <augur_> ∃ if you can see unicode.
12:48:28 <ski_> (augur_ : forgot to ask .. `DP' is ?)
12:48:29 <Saizan> ascii art logic :)
12:48:53 <augur_> DP is a determiner phrase. its from chomskyan syntactic theory. :P
12:49:07 <augur_> for most purposes you can just replace DP with NP/Noun-phrase
12:49:17 <ski_> ok
12:49:23 <ski_> what's the difference ?
12:49:29 <augur_> the details. ;)
12:49:38 <ski_> being ?
12:49:49 <augur_> but yeah, stwange, if you want the SET of all things like ~, then what you want to say instead is
12:49:57 <augur_> { x: x is ... }
12:50:00 <augur_> so for instance
12:50:08 <augur_> { x: x <- E1* }
12:50:14 <augur_> is the set of all elements of E1*
12:50:21 <augur_> which is just E1*
12:50:35 <ski_> (eta-reduction)
12:50:50 <ski_> @pl \x -> e1 x
12:50:54 <lambdabot> e1
12:51:14 <augur_> ski_ the details being the predictive power that each model has. but in more concrete terms, its about headedness of a phrase, e.g. what is the core item in the phrase.
12:51:21 <augur_> in an NP the core item is a noun
12:51:24 <augur_> in a DP the core item is a determiner
12:52:09 <tieTYT2> what's a "boolean guard"?
12:52:10 * ski_ is not exactly sure what counts as determiners ..
12:52:14 <stwange> I'm even more confused than I was now :(
12:52:20 <augur_> "the" is a determiner
12:52:23 <augur_> "all" is a determiner
12:52:26 <augur_> "this"
12:52:28 <augur_> "my"
12:52:40 <augur_> stwange: why confused?
12:53:06 <alfredr> augur_ i would imagine you've overloaded him =)
12:54:09 <ski_> augur_:
12:54:10 <ski_> er
12:54:21 <augur_> lol.
12:54:22 <Eiler> whats continuations in natural language...? like "i do something AND ..."?
12:54:42 <ski_> augur_ : so if i build a phrase about `bob', that's not a DP, then ?
12:54:53 <stwange> it's 2 questions out of 3... maybe I'll just ignore reductions :)
12:54:55 <doun> damn power cuts! dang!
12:55:09 <augur_> actually it would be a DP if you said "bob likes pizza"
12:55:10 <ski_> Eiler : continuations can be used for nat.lang.sem. for modelling quantifications
12:55:11 <monochrom> Eiler: I saw an example of continuation in natural language recently. Let me find it. will take a few minutes.
12:55:45 <ski_> augur_ : any example where the use is not as a `DP' (say `NP' instead) ?
12:55:59 <augur_> yes, inside of DP. :p
12:56:12 <augur_> its kind of weird
12:56:13 <augur_> you see
12:56:31 <augur_> NPs are presumed to just be bare semantics, they encode concepts
12:56:40 <augur_> DPs select things in the world
12:56:54 <augur_> when you say "Bob" in "Bob likes pizza"
12:57:11 <augur_> you have a DP that selects "Bob" by using an NP to specify the semantics
12:57:17 <augur_> so that sentence might look partially like this:
12:57:32 <ski_> maybe you mean something like `NP's are referentially transparent, while `DP's have (linguistic) side-effects ? .. is that it ?
12:57:45 <ski_> (/me guesses somewhat wildly :)
12:57:50 <augur_> [DP [D ε] [NP "Bob"]] likes pizza
12:58:10 <augur_> eh, not really.
12:58:21 <ski_> `?' ?
12:58:31 <augur_> are you seeing [D ?]
12:58:32 <augur_> ??
12:58:43 <augur_> ok, if so then:
12:58:47 <mauke> U+03B5 (ce b5): GREEK SMALL LETTER EPSILON [ε]
12:58:52 <ski_> (not seeing unicode, if that's what you're asking, no ..)
12:58:53 <augur_> [DP [D e] [NP "Bob"]] likes pizza
12:59:00 <ski_> ok
12:59:02 <augur_> with a phonologically empty determiner
12:59:26 <augur_> the idea is that the NP contributes the abstract notion of Bob
12:59:29 <tromp_> @oeis 1,5,15,41
12:59:29 <Eiler> might not be related but i was just thinking of "operators" in a language like english, if someone says "i would like a pizza AND a coke OR icecream", does that mean "i would like (a pizza AND a coke) or icecream" or "i would like (a pizza) AND (a coke OR icecream)"?
12:59:31 <lambdabot> a(n+1) is smallest number with a(n+1)^n > (a(n)+1)^(n+1), with a(1)=1.
12:59:31 <lambdabot> [1,5,15,41,107,276,708,1811,4629,11827,30214,77182,197159,503632,1286495,3286...
12:59:36 <monochrom> Eiler: http://article.gmane.org/gmane.comp.lang.haskell.cafe/39955/match=endianess  note every once in a while it aborts the current thought and starts a new one.
12:59:39 <augur_> and the determiner picks out something in the world
12:59:40 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/5z4x4p
12:59:55 <monochrom> (and never returns to the previously suspended thoughts)
13:00:02 <augur_> so you can combine a D and an NP to pick out something in the world that matches the abstract notion
13:00:12 <ski_> Eiler : depends on pauses, and stressing, i think
13:00:46 <augur_> eiler: it does depend on stress
13:00:47 <Eiler> well i wrote "says" but i mainly meants "written"
13:00:52 <augur_> ignoring stress it's ambiguous
13:01:03 <tromp_> @oeis 1,5,15,41,113
13:01:05 <lambdabot> Number of legal Go positions on a 1 X n board (for which 3^n is a trivial upp...
13:01:06 <lambdabot> [1,5,15,41,113,313,867,2401,6649,18413,50991,141209,391049,1082929,2998947,83...
13:01:31 <Eiler> oh, so there is like no rule that you evaluate from the left or something?
13:01:37 <augur_> nope.
13:01:41 <ski_> augur_ : how do you combine the semantics of `DP' and `VP' into the semantics of `S' ?
13:01:45 <augur_> natural language is like that
13:01:56 <augur_> well, in the theories that have DP, there is no S.
13:02:18 <Eiler> okay, guess i could solve it by using "," in like: "i would like pizza and coke, or icecream"?
13:02:36 <augur_> furthermore, those theories combine a single DP onto multiple structures in different places depending on what the DP is in the sentence
13:02:43 <ski_> augur_ : i assume you have some kind of "proposition" category, no ?
13:02:47 <augur_> eiler: yeah.
13:02:54 <Eiler> oki
13:03:03 <augur_> eh.. no, no proposition category.
13:03:25 <augur_> ill explain this in PM, i dont think ops want linguistics junk here :p
13:03:35 <ski_> ok, forget i said `S' :) .. i just wonder how you combine the semantics
13:03:46 <augur_> #chomskyan-intro
13:03:56 <ski_> (though possibly you can't answer that without explaining large parts of your framework ..)
13:03:57 <augur_> for anyone whos interested
13:04:17 <augur_> does that room link work?
13:04:33 <ski_> yes
13:04:47 <augur_> ok, cause i dont see you in there :p
13:05:00 <Eiler> now we see you
13:05:29 * edwardk hears linguistics, plugs his ears and gos lalalalala not listening ;)
13:05:36 <augur_> :p
13:06:44 <edwardk> augur_: my wife is a computational linguist, and while she was doing her masters i got bored and audited a bunch of her courses, and worked for LINGUIST for a year. I'm quite happily not working in linguistics now ;)
13:07:09 <Syzygy-> edwardk: Coooool.
13:07:25 <Syzygy-> edwardk: My wife starts working for LINGUIST this autumn.
13:07:42 <edwardk> Syzygy-: ah nice
13:07:52 <Syzygy-> Yeah
13:08:01 <edwardk> Syzygy-: I'd offer condolences, but I think that wouldn't be politically correct ;)
13:08:08 <edwardk> j/k
13:08:18 <roconnor> edwardk: I thought she was a computational archeolinguist.
13:08:29 <Syzygy-> I'm trying desperately to get myself a postdoc within vaguely decent commuting distance from Ypsilanti. The best I have secured right now is Germany, and the best I'm hoping for is Bay Area....
13:08:33 <wolgo> So String and [Char] are synonymous?
13:08:36 <edwardk> roconnor: heh
13:08:38 <wolgo> It seems so
13:08:50 <sjanssen> wolgo: yep, type String = [Char]
13:08:54 <sjanssen> @src String
13:08:58 <lambdabot> type String = [Char]
13:09:09 <wolgo> cool
13:09:16 <edwardk> Syzygy-: hrmm. not much in the ann arbor area except for university of michigan post-doc wise.
13:09:18 <wolgo> >
13:09:19 <tieTYT2> my boss should be the poster boy for why you should use functional languages
13:09:40 <edwardk> Syzygy-: I know all the computer science folks over at EMU where Linguist is, but its not really a research school.
13:09:40 <Syzygy-> edwardk: Yeah. And Ann Arbor didn't want me.
13:09:53 <edwardk> I felt a bit like a square peg there
13:09:54 <tieTYT2> he abuses the worst shit in his code.  He actually uses work variables in his methods.  Defines a variable called List and through out the method, reuses it for completely unrelated things
13:09:56 <Syzygy-> edwardk: Note that I'm a mathematician, not a computer scientist. :P
13:10:12 <edwardk> Syzygy-: I also did a masters in math there and know all the math profs too ;)
13:10:13 <Syzygy-> My current best shot seems to be Stanford. And hoping that my salary'll allow for frequent cross-country flights.
13:10:19 <Syzygy-> Nice!
13:10:25 <edwardk> Syzygy-: same problem though
13:10:32 <Syzygy-> Yeah
13:10:49 <Syzygy-> And there doesn't seem to be very many doing my brand of mathematics thereabouts (computational homological algebra)
13:10:59 <Syzygy-> There are a few cool topologists at Notre Dame and across the border....
13:11:23 <edwardk> yeah. i seem to recall that walter parry there at EMU did some homological algebra a while back but he hops fields like ever 5 years.
13:12:53 <edwardk> I mostly browbeat them into letting me do my thesis on computational geometry (stabbing line problems, Pluecker and Study coordinates), so there isn't much there in the way of computational in the math department
13:15:40 <edwardk> Syzygy-: is she doing her degree at EMU?
13:15:46 <Syzygy-> edwardk: Yeah.
13:16:15 <edwardk> does she know the area of linguistics she is interested in?
13:16:37 <Syzygy-> She has one in ... "allmän språkvetenskap" at Stockholm U, and wants to get a comp.ling. degree to figure out what she wants to do for a phd.
13:17:22 <Syzygy-> General linguistics? Things like typology and semantics...
13:17:31 <edwardk> fair enough
13:21:16 <conal> augustss: i want to add operator precedences and rewrite rules to those in Data.Number.Symbolic, but without forking your source code.  i wonder how your module could allow extension.  any ideas?
13:29:17 <tieTYT2> ok i just learned what guards are
13:29:28 <Beelsebob> :)
13:29:36 <tieTYT2> is it true to say you can do anything with a case that you could with a guard, but you'd use a guard to make the code more readable?
13:29:42 <tieTYT2> is there any other advantage to guards?
13:30:00 <Beelsebob> tieTYT2: no, there are things you can do with guards that you can't do with case
13:30:13 <Beelsebob> f x | x > 2 = jam -- for example
13:30:25 <tieTYT2> why can't you do that with a case?
13:30:32 <Beelsebob> how would you do that in a case?
13:30:56 <tieTYT2> f x = case x > 2 of otherwise -> jam  ?
13:30:57 <tieTYT2> didn't test
13:31:03 <Beelsebob> nope
13:31:09 <Beelsebob> actually, yes
13:31:11 <Beelsebob> that works
13:31:13 <Beelsebob> but...
13:31:28 <Beelsebob> f x | x > 2 = jam; | x < 5 = ham
13:31:30 <Beelsebob> now do that
13:31:54 <Beelsebob> it can be done by nesting cases
13:31:59 <Beelsebob> but not in a single one
13:32:39 <tieTYT2> f x = case x of x > 2 -> jam ; x < 5 -> ham  ?
13:32:39 <roconnor> who is responsible for hpaste?
13:32:52 <tieTYT2> doesn't that work?
13:32:54 <tieTYT2> let me try
13:32:58 <Beelsebob> tieTYT2: no
13:33:09 <Beelsebob> the LHS in a case is a patern match
13:33:12 <Saizan> roconnor: sorear/glguy/shapr
13:33:15 <Beelsebob> what you can do is put guards in cases
13:33:34 <conal> augustss: related: binOp requires Num (because it has Num rewrite rules wired in), which prevents it from working in other situations, such as VectorSpace.
13:33:42 <roconnor> Saizan: who should I tell bug reports to?
13:33:51 <Beelsebob> so... f x = case x of _ | x > 2 -> jam; _ | x < 5 -> ham
13:34:19 <Beelsebob> (of course you can then combine that with actually using pattern matching in the case expression, which makes it really quite powerful)
13:34:35 <dons> Cale: this guy needs to find #haskell http://blog.finiteimprobability.com/2008/05/21/i-quit/
13:34:37 <lambdabot> Title: Finite Improbability  I Quit
13:35:11 <tieTYT2> Beelsebob: when you say the LHS of the case, you mean the LHS of this part: x < 2 -> jam ?
13:35:16 <roconnor> @seen sorear glguy shapr
13:35:17 <Beelsebob> yes
13:35:18 <lambdabot> I haven't seen sorear.
13:35:21 <Saizan> roconnor: i don't think anyone actually maintains the code, it's written against an unspecified version of happs
13:35:24 <tieTYT2> ok thanks, that took me a sec to figure out
13:36:12 <tieTYT2> i'm a lil confused because this book just explained to me that an if/then/else is a special case "case"
13:36:17 <tieTYT2> but now i don't see the correlation
13:36:48 <tieTYT2> but i think i understand your example
13:36:57 <Saizan> if b then x else y == case b of True -> x; False -> y
13:37:06 <tieTYT2> ah there it is
13:37:09 <tieTYT2> ok thanks
13:37:45 <tieTYT2> ok that's kinda tricky.  I gotta remember that LHS of cases do pattern matching
13:37:59 <tieTYT2> as opposed to in Java, it seems to compare the value
13:38:38 <Beelsebob> tieTYT2: sorry, I pinged out there
13:38:45 <tieTYT2> what's the last thing you saw?
13:38:51 <tieTYT2> well i got answered
13:39:03 <tieTYT2> <tieTYT2> ok that's kinda tricky.  I gotta remember that LHS of cases do pattern matching <tieTYT2> as opposed to in Java, it seems to compare the value
13:39:07 <Beelsebob> yeh, you asking whether I meant the LHS of the -> bit
13:39:15 <Beelsebob> yep
13:39:36 <Beelsebob> but as I said, if you want to do direct comparisons, *and* pattern matching, you can combine case and guards into one
13:39:47 <tieTYT2> right
13:39:58 <Beelsebob> f y = case g y of (a,b) | a > 2 -> b
13:39:59 <Beelsebob> etc
13:40:34 <Beelsebob> I would post you a nice example of this, but hpaste will asplode at the unicode in my source
13:40:55 <tieTYT2> i more than likely will see something i haven't seen before
13:40:58 <tieTYT2> still a complete newb
13:42:02 <hpaste>  beelsebob pasted "For tieTYT2" at http://hpaste.org/7796
13:42:23 <Beelsebob> doom, and I just realised a missed a case in there
13:42:24 <tieTYT2> now i'm on: http://book.realworldhaskell.org/beta/fp.html
13:42:24 <Beelsebob> >.<
13:42:30 <lambdabot> Title: Chapter 5. Functional programming
13:42:47 <tieTYT2> never seen this stuff: :->:
13:42:52 <tieTYT2> :=:
13:43:07 <tieTYT2> yeah i won't get this yet :P
13:43:21 <Beelsebob> ah, they're infix data constructors
13:43:53 <Beelsebob> you can define infix operators like this... x >->-> y = ...
13:44:06 <Beelsebob> or you can define infix data constructors by starting them with a colon
13:44:23 <Beelsebob> so :->: is just like Just, or Left
13:48:55 <Eiler> ski_: what was the channel name?
13:50:42 <edwardk> given that all of maybe 2 people are using category-extras do you think I'd be alienating everyone if I had it redefine Functor and Monad? =)
13:50:55 <ski_> Eiler : #chomskyan-intro
13:51:37 <edwardk> this would let me do things like define a memoizing context comonad over the kleisli IO category, etc.
13:52:13 <edwardk> and it would let most monads work directly over arrows
13:54:26 <edwardk> or more likely just make a CFunctor, CMonad for categorical functor and categorical monad(even though CMonad and Comonad look way too similar)
13:54:59 <elliottt> actually, i read those two as the same word while reading your message :)
13:55:15 <edwardk> it would basically lift the whole of the library to work over a lot of categories other than just Hask.
13:55:22 <Peaker> @src Data.Set.valid
13:55:24 <lambdabot> Source not found. stty: unknown mode: doofus
13:55:30 <Peaker> what's that?
13:55:33 <edwardk> maybe not CFunctor then, Functor' is too easy to miss. alternative names?
13:56:07 <edwardk> RealFunctor RealMonad? =)
13:56:18 <sclv_> edwardk: I like Functor' actually.
13:56:43 <edwardk> sclv: the idea of litering code with fmap's is scaring me ;)
13:56:50 <edwardk> er fmap' s.
13:56:51 <edwardk> =)
13:56:56 <sclv_> Assuming that your lib doesn't use Functor or Monad anymore, then something lightweight an inobtrusive is nice. but yeah, fmap' is ugly.
13:57:16 <edwardk> hell i use functor enough I'd be willing to call it F =)
13:57:26 <sclv_> what's the typeclass of your CFunctor anyway?
13:58:13 <edwardk> class Category c d => F f c d where map :: c a b -> d (f a) (f b)
13:58:32 <edwardk> er (Category c, Category d) =>
13:59:00 <sclv_> regular functors are instances of cfunctor, right?
13:59:28 <edwardk> yeah every regular functor f could be an instance of CFunctor f (->) (->) with map = fmap
13:59:33 <edwardk> but i can't make the default instance
13:59:52 <edwardk> because you'd get ambiguous instance heads all over the place.
14:00:11 <edwardk> oh wait
14:00:13 <edwardk> my mistake
14:00:15 <sclv_> you can't do instance (Functor a) => CFunctor a where...
14:00:16 <sclv_> ?
14:00:38 <edwardk> class (Category c, Category d) => F f c d | f c -> d, f d -> c where map :: c a b -> d (f a) (f b)
14:00:41 <edwardk> forgot the fundeps
14:01:03 <edwardk> unfortunately not. then you can't have any other instance heads for CFunctor Foo
14:01:11 <edwardk> you've just thrown away all the extra power you gained
14:01:42 <sclv_> Oh, I gotcha... c and d imply one another, but they're free of f.
14:01:49 <edwardk> you can make instance (Functor a) => CFunctor (WrappedFunctor a) (->) (->)
14:01:59 <edwardk> but that introduces noise like WrappedMonad does with applicative.
14:02:50 <sclv_> The awful way to do it: Write CFunctor as a strict generalization of functor and override the fmap function, then fill in the instances for all standard functors by hand. I wouldn't wish that on anyone though...
14:02:53 <edwardk> one thought is i just define a more pedantic functor and monad class then just define instances for all the junk in the standard library and never look back
14:03:15 <edwardk> yeah well i already had to redefine half the standard library anyways ;)
14:03:15 <roconnor> > "hello">>"*"
14:03:17 <lambdabot>  "*****"
14:03:23 <ski_> (:
14:03:27 <sclv_> edwardk: you need to hire a research assistant to write boring instances for you.
14:03:45 <edwardk> sclv: i'll get right on that as soon as I become an academic ;)
14:03:49 <ski_> sclv_ : it's called graduate student
14:03:56 <ziman> > "haskell" >> "-*"
14:03:58 <lambdabot>  "-*-*-*-*-*-*-*"
14:03:59 * sclv_ wonders idly about Amazon mechanical turk for Haskell boilerplate.
14:04:01 <edwardk> I lost my access to those when I stopped teaching ;)
14:05:00 <edwardk> sclv: i already gave in and made my bifunctor class the more general version (to the point where i had to split it into PFunctors and QFunctors, so that it could be inferred everywhere)
14:05:08 <edwardk> so doing functor/monad isn't that big of a shift.
14:06:16 <sclv_> CategorialPrelude :-)
14:06:30 <edwardk> (there were some cases where you had dangling left or right sides of a bifunctor type that would mean that you'd have to add too many parameters to an unrelated type, hence the bit about P and Q functors, for things that support 'first' and 'second' style maps.
14:07:00 <edwardk> sclv: i have a Control.Category.Prelude already in my in-progress folder ;)
14:07:31 <edwardk> the trick is getting benefit out of this rather than just wasting effort
14:07:58 <edwardk> the pros of this include that you can then use monads over arrows or over even weaker categories if they don't need many features.
14:08:23 <edwardk> i.e. the reader comonad works even if your category doesn't have exponentials.
14:09:07 <edwardk> http://comonad.com/haskell/categories/src/Control/Category/Transformer/Reader.hs was my first cut at that in my older categories library
14:09:07 <lambdabot> http://tinyurl.com/5essvu
14:09:12 <MarcWeber> What happens when doing foo{bar = "new value"} ( Foo = Foo { bar :: String, bar2::String, ... } ) is the whole foo structure copied or is only the one value updated in place? I guess the first one because you can't know wether foo is used in another thread, right?
14:09:26 <edwardk> copied.
14:10:12 <roconnor> @type interact
14:10:15 <lambdabot> (String -> String) -> IO ()
14:10:17 <edwardk> its just like doing quux (Foo _ bar)  = Foo "new value" bar
14:11:08 <edwardk> marc: that said, if you're lucky the compiler will be smart and you may never actually construct a full data structure and things will just get plumbed where they need to go when you optimize.
14:11:55 <MarcWeber> edwardk: When using unboxed stuff ? Sure .. then there is no foo at all..
14:12:39 <edwardk> marc: or if it goes through and transforms it internally into a church representation and makes the constructors disappear, because you only wrap it to unwrap it again.
14:13:39 <edwardk> so do Functor and Monad become F and M and I close my ears and ignore the prelude ones? or something? =)
14:14:08 <edwardk> i guess better names than F and M are merited but gah
14:14:28 <edwardk> mostly want to avoid having to qualify all the standard imports
14:14:46 <quicksilver> MarcWeber: well the "whole structure" isn't copied
14:14:52 <quicksilver> MarcWeber: just the top level constructor
14:15:01 <quicksilver> MarcWeber: just one constructor and a bunch of pointers
14:15:14 <quicksilver> (which point to data which is shared with the old)
14:15:14 <twanvl> import Prelude hiding (Monad,Functor) -- not that bad
14:15:21 <quicksilver> in particular, bar2 is shared.
14:15:28 <edwardk> twanvl: remember i use Control.Category so hiding (id,(.))
14:15:39 <ketil> Anybody use Network.CGI with a textarea form?
14:16:08 <edwardk> oh and my Control.Category.Cartesian.Closed so hiding (fst, snd, curry, uncurry...)
14:17:26 <edwardk> ok, so writing the 'right' functor class has more support than not doing so at least
14:17:28 <MarcWeber> quicksilver: I think I got this. But th top level constructor holding the pointers will be allocated and the pointers will be copied (except the replaced one of course)..
14:18:02 <MarcWeber> quicksilver: I've been thinking about wether it would make sense to write some relational data management in haskell
14:18:05 <twanvl> edwardk: will you also have PointedFunctor and Applicative, or whatever nice categorical alternative there is, between Functor and Monad?
14:18:19 <yitz> hi Peaker
14:18:22 <MarcWeber> quicksilver: But I start to see why no one has already done it .. :)
14:18:26 <edwardk> i already have a pointed functor in category-extras. i'll just move it over to the new definition
14:18:33 <Peaker> hi yitz
14:18:34 <hpaste>  christastrophe pasted "do error" at http://hpaste.org/7797
14:18:38 <christastrophe> im getting an error using 'do' notation
14:18:39 <edwardk> it also means that all my parameterized and higher order functors, etc. will pick up category arguments
14:18:51 <edwardk> it lets me then do adjunctions between different categories, etc. properly once more
14:19:08 <christastrophe> I'm trying to make an instance of Data.Binary...
14:19:23 <MarcWeber> quicksilver: May I show you my attempt and do you have some minutes to discuss it?
14:19:43 <yitz> Peaker: Data.Set.valid is for debugging. If you mess with the internals of a set, checks if it's still valid. Normal mortal humans shouldn't need it, I think.
14:19:48 <christastrophe> my codes nearly a complete copy paste from the Data.Binary docs. anyone see something I'm doing wrong?
14:19:58 <Peaker> yitz, ah, thanks
14:20:08 <MarcWeber> christastrophe: If you add the error as well it's easier to follow your code
14:20:26 <edwardk> gah, i'm rapidly losing the ability to use the built-in MTL stuff coz next i'll need to have the monad use the right exponential for its category ;)
14:20:29 <shapr> roconnor: hpaste did what?
14:20:31 <shapr> !paste
14:20:31 <hpaste> Haskell paste bin: http://hpaste.org/
14:20:35 <edwardk> heya shapr
14:20:38 <hpaste>  (anonymous) annotated "do error" with "(no title)" at http://hpaste.org/7797#a1
14:20:43 <twanvl> christastrophe: the 'case' keyword must have the same indentation as "tag <- getWord8"
14:20:50 <shapr> hiya edwardk
14:20:51 <edwardk> shapr: http://comonad.com/edwardk-southpark.png
14:20:55 * shapr looks
14:20:58 <roconnor> shapr: raw is served up as text/html instead of text/plain
14:21:03 <shapr> edwardk: bwahaaa
14:21:26 <roconnor> shapr: needs more types
14:21:26 <christastrophe> twanvl: haha. well that was easy! thanks
14:21:29 <christastrophe> d'oh
14:21:33 <shapr> roconnor: Hm...
14:21:41 <edwardk> roconnor: hard to do dependent types toony ;)
14:22:00 <roconnor> edwardk: are dependent types needed for this.
14:22:06 <edwardk> fair nuff
14:22:08 <roconnor> ... hmm possibly
14:22:12 <shapr> roconnor: Do you have an example?
14:22:38 <roconnor> shapr: http://hpaste.org/7797/0/plain
14:22:50 <shapr> oh
14:22:51 <shapr> hmm
14:23:27 <shapr> That's probably a question for glguy or other hpaste maintainer, I think it's likely the mime types are set in the hpaste source.
14:24:22 <quicksilver> MarcWeber: you're not hte first ;)
14:24:35 <quicksilver> MarcWeber: quite a few people think about the mapping between relational and haskell
14:24:50 <quicksilver> Someone did someting very very clever with type-directed projections and joins
14:24:58 <b_jonas> relational databases?
14:24:59 <quicksilver> although from my perspective it was a bit of an abuse of type classes
14:25:11 <MarcWeber> quicksilver: coddfish?
14:25:19 <quicksilver> b_jonas: well relational models rather than concrete RDBMSes
14:25:32 <quicksilver> MarcWeber: no, that's another one too :)
14:26:28 <yitz> some of it has even been added to list comprehensions in ghc. frankly, i was apalled.
14:27:02 <roconnor> ;(
14:27:22 <MarcWeber> quicksilver: What do you mean by mapping here? Using Postgresql etc is nice and it works well. However it would be cool to have such features without having to think about SQL or how to map haskell values to database.
14:27:36 <quicksilver> MarcWeber: yes, I didn't mean SQL
14:27:51 <roconnor> glguy: if only we had nix
14:27:54 <quicksilver> MarcWeber: I meant building up haskell types which represent relations and haskell operators which represent relational algebra
14:30:00 <MarcWeber> quicksilver: Do you remember anything which could help me find this package?
14:31:38 <shapr> edwardk: Did you get that added to the canonical #haskell southpark user's page?
14:44:03 <awesame> how can I change the working directory in which a program run by System.Posix.executeFile will run?
14:44:38 <MarcWeber> awesame: I've never sen executeFile before. Maybe you want to have a look at System.Process
14:45:12 <awesame> probably this just involves changing haskell's current working directory
14:45:19 <awesame> is there a chdir function somewhere?
14:46:19 <twanvl> ?hoogle CurrentDirectory
14:46:19 <lambdabot> System.Directory.getCurrentDirectory :: IO FilePath
14:46:19 <lambdabot> System.Directory.setCurrentDirectory :: FilePath -> IO ()
14:46:19 <lambdabot> System.Directory.makeRelativeToCurrentDirectory :: FilePath -> IO FilePath
14:46:55 <awesame> thanks
14:50:31 <tchakkazulu> ?type unfoldM
14:50:33 <lambdabot> Not in scope: `unfoldM'
14:50:37 <tchakkazulu> ?type unfoldrM
14:50:39 <lambdabot> Not in scope: `unfoldrM'
14:51:06 <tchakkazulu> ?hoogle (s -> m (Maybe (a,s))) -> s -> m [a]
14:51:07 <lambdabot> No matches, try a more general search
14:53:50 <Heffalump> tchakkazulu: what would it do with the returned s? Throw it away?
14:54:01 <Heffalump> oh, I see, sorry.
14:55:04 <dibblego> tchakkazulu, you can write unfoldr on MonadPlus
14:55:19 <Peaker> what would be the equivalent of a format-string function or a cout<< formulation in Haskell?  Using lots of putStr (show ..)  or a single-item-per-line print seems tedious
14:55:39 <dibblego> ?type let unfold f b = case f b of Just(a, b') -> mplus (return a) (unfold f b'); Nothing -> mzero in unfold
14:55:41 <lambdabot> forall t t1 (m :: * -> *). (MonadPlus m) => (t -> Maybe (t1, t)) -> t -> m t1
14:56:00 <tchakkazulu> Yeah, I just wrote it myself. I didn't need MonadPlus though, only Monad.
14:56:29 <tchakkazulu> Oh, wait, in that way.
14:57:09 <Heffalump> google for unfoldM finds an old haskell-cafe thread on the subject
14:57:10 <ddarius> > printf "%0.5f" pi :: String
14:57:11 <lambdabot>  "3.14159"
14:57:43 <Heffalump> Peaker: putStr (show x ++ "foo" ++ show y ++ "foo" ++ show z) isn't too painful
14:58:00 <Heffalump> but as ddarius says you can use printf if you really want
14:58:23 <ddarius> Often concat is used: putStr $ concat ["Hello ", name, " you are ", show age, " years old."]
14:58:27 <edwardk> shapr: i messaged boegel about it, but hadn't seen a response yet
14:58:48 <ddarius> There are several different ways of getting formatted output.
14:58:55 <dibblego> concatMap show ["Hello ", name, " you are ", age, " years old."]
14:59:13 <dibblego> show =<< ["Hello ", name, " you are ", age, " years old."]
14:59:17 <Peaker> @hoogle printf
14:59:18 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
14:59:18 <lambdabot> Text.Printf :: module
14:59:18 <lambdabot> Text.Printf.PrintfType :: class PrintfType t
14:59:20 <ddarius> > concatMap show ["Hello ", name, " you are ", age, " years old."]
14:59:21 <lambdabot>   Not in scope: `age'
14:59:48 <ddarius> dibblego: That most likely wouldn't type check and would lead to extraneous escaped characters.
15:00:03 <Peaker> Heffalump, ddarius : Ok, thanks
15:00:41 <Peaker> Given the Enum class, how can I alternate between 2 values, or cycle through more?
15:01:08 <dibblego> ?type concatMap
15:01:10 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
15:01:14 <dibblego> ?type concatMap show
15:01:16 <lambdabot> forall a. (Show a) => [a] -> [Char]
15:01:30 <dibblego> ?type let age = 7 in concatMap show ["Hello ", name, " you are ", age, " years old."]
15:01:32 <lambdabot> Not in scope: `name'
15:01:33 <ddarius> > cycle $ map toEnum [1..2] :: [Ordering]
15:01:34 <lambdabot>  [EQ,GT,EQ,GT,EQ,GT,EQ,GT,EQ,GT,EQ,GT,EQ,GT,EQ,GT,EQ,GT,EQ,GT,EQ,GT,EQ,GT,EQ,...
15:01:40 <dibblego> ?type let age = 7; name = "Fred" in concatMap show ["Hello ", name, " you are ", age, " years old."]
15:01:42 <lambdabot>     No instance for (Num [Char])
15:01:42 <lambdabot>       arising from a use of `age' at <interactive>:1:75-77
15:01:42 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
15:02:02 <dibblego> gah, I'm thinking of Scala again
15:02:14 <Peaker> ddarius, I mis-stated what I wanted to do:  I want a "succ" or "pred" that is cyclic
15:02:38 <Peaker> ddarius, in my case there are just two values I can manually write one, but..
15:02:40 <rabbit64> Hi. When converting term \x y z. f y (\t. t g x) (\u . u (g y)); where f and g are constants to supercombinator term, you can use S and K also, how many additional supercombinators are needed?
15:02:50 <dolio> > cycle [EQ .. GT]
15:02:51 <lambdabot> Terminated
15:03:06 <idnar> heh
15:03:11 <idnar> :t cycle
15:03:13 <lambdabot> forall a. [a] -> [a]
15:03:33 <idnar> wait, what
15:03:34 <Peaker> dolio, how do you get the cyclic successor value though?
15:03:44 <dolio> > [EQ .. GT]
15:03:44 <lambdabot> Terminated
15:03:55 <idnar> > [EQ]
15:03:57 <lambdabot>  [EQ]
15:04:00 <idnar> > [LT .. EQ]
15:04:02 <lambdabot>  [LT,EQ]
15:04:07 <idnar> > [EQ .. GT]
15:04:08 <lambdabot> Terminated
15:04:15 <idnar> what's up with that?
15:04:18 <dolio> Huh, weird.
15:04:24 <Peaker> sucks to have      otherPlayer White = Black  ;  otherPlayer Black = White
15:04:27 <idnar> > [LT .. GT]
15:04:28 <lambdabot> Terminated
15:04:30 <dolio> > [GT .. GT]
15:04:31 <lambdabot> Terminated
15:04:33 <Botje> grrrr
15:04:35 <ddarius> > [LT ..]
15:04:36 <lambdabot>  [LT,EQ,GT]
15:04:38 <dolio> I'm confused.
15:04:40 <idnar> :t succ
15:04:41 <dibblego> Peaker, otherPlayer = not
15:04:42 <lambdabot> forall a. (Enum a) => a -> a
15:04:44 <dibblego> ?Type not
15:04:46 <lambdabot> Bool -> Bool
15:04:48 <Botje> i'm trying to use teh compiling with continuations book to write my compiler
15:04:48 <dibblego> ?type not
15:04:48 <idnar> > succ EQ
15:04:51 <lambdabot>  GT
15:04:51 <lambdabot> Bool -> Bool
15:04:54 <idnar> > succ GT
15:04:54 <lambdabot> Terminated
15:04:58 <Botje> but they don't describe how to transform let statements :[
15:05:13 <Peaker> dibblego, not on a non-bool?
15:05:21 <idnar> @instances Enum
15:05:21 <Peaker> > not GT
15:05:22 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
15:05:22 <lambdabot> Terminated
15:05:26 <ddarius> Botje: Recursive or non-recursive ones?
15:05:26 <idnar> > succ ()
15:05:27 <lambdabot>  Exception: Prelude.Enum.().succ: bad argument
15:05:29 <dibblego> Peaker, have you newtyped bool or something?
15:05:32 <idnar> hmm
15:05:33 <Botje> ddarius: neither :(
15:05:37 <Botje> they do describe FIX
15:05:39 <idnar> :t GT
15:05:40 <Peaker> dibblego, no no I just use:  data Player = White | Black
15:05:41 <Botje> which is like letrec for functions
15:05:41 <lambdabot>     Ambiguous occurrence `GT'
15:05:41 <lambdabot>     It could refer to either `Data.Ord.GT', imported from Data.Ord
15:05:41 <lambdabot>                           or `Data.Generics.GT', imported from Data.Generics
15:05:45 <idnar> :t EQ
15:05:47 <lambdabot> Ordering
15:05:53 <Botje> i think that can be expanded to handle variables too, but i'm at a loss how
15:05:54 <idnar> > GT
15:05:54 <dibblego> Peaker, ok, never mind then
15:05:54 <ddarius> Botje: I'm asking do you want the rules for recursive or non-recursive ones?
15:05:55 <lambdabot> Terminated
15:06:00 <idnar> GT is borked :P
15:06:06 <Peaker> dibblego, I want to be able to take a player and get the other player
15:06:13 <ddarius> @undefine
15:06:14 <Botje> ddarius: ah.
15:06:14 <lambdabot> Undefined.
15:06:15 <Peaker> dibblego, I thought "deriving Enum" could help
15:06:17 <ddarius> > GT
15:06:18 <lambdabot> Terminated
15:06:23 <Botje> ddarius: non-recursive, i think
15:06:30 <dibblego> Peaker, you're just writing the not function; maybe you want a type-class? class Not a where not :: a -> a
15:06:46 <idnar> Peaker: what about something like, uhm
15:06:48 <dolio> > let cycSucc n = head . tail dropWhile (/= n) . cycle $ [minBound ..] in cycSucc LT
15:06:48 <lambdabot>  Couldn't match expected type `[a]'
15:06:59 <Peaker> dibblego, I thought an Enum had the lowest/highest values then I could implement a cyclic succ/pred that work on all Enums
15:07:01 <dolio> > let cycSucc n = head . tail . dropWhile (/= n) . cycle $ [minBound ..] in cycSucc LT
15:07:03 <lambdabot>  EQ
15:07:13 <Peaker> like that!
15:07:13 <dolio> > let cycSucc n = head . tail . dropWhile (/= n) . cycle $ [minBound ..] in cycSucc EQ
15:07:15 <lambdabot>  GT
15:07:16 <Peaker> ;)
15:07:22 <idnar> hrm, bleh
15:07:22 <dibblego> Peaker, Enum is not cyclic iirc
15:07:25 <ddarius> Botje: Okay, good.  That's the easy case.  CPS[let x = M in N]k = CPS[M](\x.CPS[N]k)
15:07:25 <dolio> > let cycSucc n = head . tail . dropWhile (/= n) . cycle $ [minBound ..] in cycSucc $ cycSucc EQ
15:07:25 <dibblego> > succ True
15:07:28 <lambdabot>  LT
15:07:28 <lambdabot>  Exception: Prelude.Enum.Bool.succ: bad argument
15:07:52 <ddarius> That's assuming you want strict evaluation.
15:08:02 <idnar> Peaker: cyclicSucc x = if (x == maxBound) then minBound else (succ x)
15:08:21 <Peaker> idnar, But not all enums are instances of Bounded?
15:08:35 <Botje> ddarius: yeah, i want strict eval
15:08:55 <dolio> The bounded ones should be, which are the only ones where you'll get wrap around, no?
15:08:59 <idnar> Peaker: right
15:09:15 <idnar> Peaker: an unbounded enum doesn't need to wrap
15:09:35 <idnar> Peaker: and a bounded enum that doesn't have a Bounded instance is just broken ;)
15:10:05 <Peaker> idnar, I see, ok thanks
15:10:47 <Botje> ddarius: it is correct that x is never used in the body?
15:10:59 <dolio> I suppose it's still a problem that one function can't give you successors for both bounded and non-bounded enums, if you care about that.
15:11:45 <ddarius> Botje: Huh?
15:12:23 <Botje> CPS[M](\x.CPS[N]k) -- CPS-converts M, binds the result to x, and then does nothing with it?
15:12:37 <Botje> oh, wait
15:12:39 <ddarius> x is (presumably) used in N
15:12:41 <dolio> x can be used in N.
15:12:49 <yitz> @seen Cale
15:12:49 <lambdabot> Cale is in #haskell, #haskell-overflow and #ghc. I last heard Cale speak 19h 15m 55s ago.
15:12:57 <Botje> yeah, the lambda just dropped :)
15:12:58 <Botje> thanks!
15:13:08 <Cale> hello
15:13:21 <yitz> hi Cale. have you seen this:
15:13:24 <yitz> > GT
15:13:25 <lambdabot> Terminated
15:13:31 <Cale> hmm
15:13:33 <yitz> @type GT
15:13:35 <lambdabot>     Ambiguous occurrence `GT'
15:13:35 <lambdabot>     It could refer to either `Data.Ord.GT', imported from Data.Ord
15:13:35 <lambdabot>                           or `Data.Generics.GT', imported from Data.Generics
15:13:39 <Cale> ah, okay
15:13:44 <yitz> > LT
15:13:46 <lambdabot>  LT
15:13:50 <idnar> @type LT
15:13:51 <lambdabot> Ordering
15:13:55 <ddarius> :t Data.Generics.GT
15:13:57 <lambdabot> (forall a. (Data a) => a -> a) -> GenericT'
15:13:59 <roconnor> > negate LT
15:14:00 <lambdabot>   add an instance declaration for (Num Ordering)
15:14:00 <lambdabot>     In the expression: negat...
15:14:28 <ddarius> Who decided to name that GT?
15:15:04 <idnar> heh
15:15:15 <Cale> > GT
15:15:16 <lambdabot>  GT
15:15:19 <Cale> there you go
15:15:21 <idnar> woo
15:16:03 <yitz> thanks Cale!
15:16:10 <Cale> no problem
15:16:38 <ddarius> @let x = 3
15:16:39 <ddarius> :t x
15:16:40 <lambdabot> Defined.
15:16:41 <lambdabot>     Ambiguous occurrence `x'
15:16:41 <lambdabot>     It could refer to either `L.x', defined at <local>:1:0
15:16:41 <lambdabot>                           or `SimpleReflect.x', imported from SimpleReflect at State/imports.h:71:0-32
15:16:47 <ddarius> @undefine
15:16:48 <lambdabot> Undefined.
15:21:14 <Peaker> how do I debug an infinite computation loop? Can I get some automatic traces of what functions are being called?
15:21:51 <ddarius> Peaker: You could use the debugger.
15:22:17 <Peaker> ddarius, what Haskell debuggers are there?
15:22:27 <ddarius> Peaker: There's one built into GHCi.
15:22:36 <Peaker> I think a language like Haskell, at least for the pure part, can do much better than an imperative language, as far as debugging goes (should be much easier to go backwards/forwards/etc)
15:22:43 <dons> there's a few standalone ones, but the main one is built into ghci
15:22:52 <dons> Peaker: that's right. most haskell debuggers allow time travel
15:23:06 <ddarius> Peaker: Well there are a lot of other debugging tools, but most of them are restricted to Haskell 98.
15:23:29 <Peaker> how do I use the debugger built into ghci?
15:24:03 <ddarius> Peaker: Just load your code interpreted into GHCi (which requires removing any .o/.hi files that might be there from compilation).
15:24:14 <Peaker> a trace which shows you which recursion[s] are prominent in a run should really help debug hangings in an instant
15:26:34 <Peaker> import Chess
15:26:34 <Peaker> module main:Chess is not loaded
15:26:57 <Peaker> why does it refuse to load an .hs file in the same directory in ghci?
15:27:15 <monochrom> I don't know details, but you can tell ghci's debugger to set breakpoints. Then, when your program is interrupted, you can examine variable bindings. Using this you can do your own cycle-detection.
15:28:21 <Peaker> I can't seem to load the code to ghci even - it refuses
15:28:31 <monochrom> You can also use Debug.Trace.trace. Inserting calls to it at crucial points will cause messages (of your choice) printed to stderr. Using this you can verify control flow and even variable bindings.
15:29:36 <monochrom> "import Chess" is not a valid command to give to ghci, if I understand you correctly.
15:29:37 <nburlett> hey all
15:29:47 <thoughtpolice> Peaker: http://www.haskell.org/pipermail/glasgow-haskell-bugs/2007-February/007300.html
15:29:47 <lambdabot> Title: [GHC] #1125: "module main:Foo is not loaded" when trying to load a module from a ..., http://tinyurl.com/6xcmqm
15:30:30 <nburlett> I'm trying to follow http://haskell.cs.yale.edu/haskellwiki/Practical_web_programming_in_Haskell, specifically the section on Extending the CGI Monad with Monad Transformers
15:30:31 <lambdabot> Title: Practical web programming in Haskell - HaskellWiki, http://tinyurl.com/2s6jj3
15:30:56 <nburlett> but it doesn't seem to work nicely for me
15:31:02 <Peaker> thoughtpolice, not sure what is the right way to load an .hs file then?
15:31:13 <Peaker> thorkilnaur, I don't know what packages are
15:31:16 <nburlett> I get Can't make a derived instance of `MonadReader Connection (AppT m)',  (`MonadReader Connection' is not a class...
15:31:20 <thoughtpolice> Peaker: the easiest is just to move out of the directory
15:31:37 <thoughtpolice> then import
15:32:04 <thoughtpolice> Peaker: but if you just want to load a file from the current dir, you can use :load
15:32:11 <thoughtpolice> which shouldn't cause any problem
15:32:22 <Peaker> ah, great, thanks
15:32:33 <lstor> I want to implement an array in Haskell (yes, I know it is ridiculous. Don't ask why :-) ). I want to be able to call add, remove and contains on this array, as well as retrieve the element at a given index. Does anyone have any thoughts about how I should define this data type? Data.Array.Diff seems interesting, but how should I use it?
15:32:58 <lstor> I mainly need help with defining the data type itself, I think I will be able to write the functions once I've got the data type
15:33:08 <ddarius> Peaker: Once you load it, execute:  :set -fbreak-on-exception
15:33:16 <ddarius> Peaker: Then run your code and hit Ctrl-C
15:33:25 <augustss> @seen conal
15:33:25 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 1h 59m 49s ago.
15:34:08 <Peaker> ddarius, thanks
15:35:11 <Peaker> I get a prompt: [<exception thrown>] *Main>  -- what can be done with it?
15:35:44 <ddarius> Try :trace
15:36:48 <ddarius> Actually you may want to do :trace <expr> and then hit Ctrl-C
15:36:53 <thoughtpolice> iirc you start by doing :trace main
15:36:55 <thoughtpolice> then ctrl-c
15:37:04 <ddarius> and then use :history
15:37:06 <thoughtpolice> and afterwords just use :history to see a traceback
15:37:12 <Saizan> nburlett: you need an extension for that to work
15:37:33 <Peaker> only says e = GHC.IOBase.DynException (Data.Dynamic.Dynamic (Data.Typeable.TypeRep ...)
15:37:33 <Peaker>                                                     ghc-6.8.2:Panic.Interrupted)
15:37:43 <Saizan> nburlett: -XExtendedNewtypeDeriving iirc, or -fglasgow-exts
15:37:48 <Peaker> history is good! thanks
15:38:08 <vixey>  * Users on #haskell.jp: vixey lambdabot
15:38:09 <vixey> :(
15:38:27 <ddarius> @seen lambdabot
15:38:27 <lambdabot> Yes, I'm here. I'm in #haskell.cz, #haskell, #haskell-hac4, #gentoo-uy, #friendly-coders, #dreamlinux-es, #thunks, #haskell-hac07, #haskell_ru, #haskell.dut, #haskell.de, #haskell.es, #haskell.fi, #
15:38:27 <lambdabot> haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell-books, #rosettacode, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #
15:38:27 <lambdabot> parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #darcs, #jhc and #ghc
15:38:40 <vixey> I'm really confused!
15:38:51 <vixey> It seems like everyone that programs ... speaks english
15:39:01 <lstor> vixey: And that's how it should be.
15:39:03 <Peaker> Can't see the cycle in the history. it seems like a very partial history, weird. I guess unsafePerformIO prints to the rescue :-(
15:39:03 <ddarius> Among other things.
15:39:07 <vixey> why?
15:39:25 <ddarius> Peaker you can get up to 50 levels back.
15:39:41 <lstor> vixey: Because if I comment in Norwegian and you in Japanese (I assume), we'd have a hard time understanding eachother's code
15:39:42 <Peaker> ddarius, are those levels as in a strict-language's traceback?
15:39:53 <ddarius> Peaker: You can also put a breakpoint on a suspect function and/or step the execution.
15:40:03 <ddarius> Peaker: There whatever GHC records.
15:40:08 <ddarius> s/There/They're
15:40:15 <monochrom> "unsafePerformIO print" is Debug.Trace.trace.
15:40:15 <vixey> huh...
15:40:35 <vixey> ok so programming is an English language thing
15:40:53 <vixey> are there pastimes which are only non-english?
15:41:21 <lstor> "pastimes"? What do you mean?
15:41:28 <vixey> like programming
15:41:32 <Peaker> :step seems to wait until the function returns?
15:41:37 <monochrom> Debug.Trace.trace is preferred because its source code has all the pragmas to ensure correct inlining/noinlining. Your own unsafePermIO print may get them wrong and optimized away.
15:41:58 <vixey> doesn't it seem bizarre though?
15:42:02 <Peaker> thanks
15:42:08 <nburlett> woah: ld: atom sorting error for _HDBCzmsqlite3zm1zi1zi4zi0_DatabaseziHDBCziSqlite3ziTypes_CSqlite3_closure_tbl and _HDBCzmsqlite3zm1zi1zi4zi0_DatabaseziHDBCziSqlite3ziTypes_CStmt_closure_tbl in /Users/nburlett/.cabal/lib/HDBC-sqlite3-1.1.4.0/ghc-6.8.2/libHSHDBC-sqlite3-1.1.4.0.a(Types.o)
15:42:22 <lstor> vixey: That programming is mainly in English?
15:42:29 <vixey> yes
15:42:33 <Peaker> Could be nice to have a visual/interactive tree-view of my program's execution and expand it to see what happened
15:42:37 <ddarius> vixey: No.
15:42:43 <lstor> I don't think so. Most people speak it
15:42:47 <Peaker> given that its a functional language, there is huge potential to make debugging easier, not harder than imperative languages
15:42:49 <vixey> there is like .. no online communities in other languages
15:42:56 <ddarius> Peaker: That's what Hat does more or less.
15:43:07 <ddarius> Peaker: Buddha also does something vaguely like that.
15:43:16 <Peaker> cool I'll try those out
15:43:16 <vixey> but there's hundreds of people in other countries why do they all speak a foriegn language?
15:43:17 <lstor> vixey: As I implied, I'm not a native English-speaker myself, but I still prefer English when talking about programming
15:43:50 <vixey> sorry probably not haskell related .. but this is just really confused me
15:44:16 <lstor> Then I don't have to worry about confusing "tree" (English), "tre" (Norwegian), "baum" (German), etc.
15:44:24 <lstor> And translations become a non-issue
15:44:26 <lstor> Etc.
15:44:44 <vixey> if -everyone- spoke japanese it wouldn't be a problem either
15:44:48 <ddarius> vixey: What's confusing?  Programming and the internet both were largely developed in America first.
15:45:32 <vixey> I was led to beleive we can contact the entire world .. but it seems like a US/UK clique
15:45:43 <yitz> ddarius: programming originated in England (early 1800s), but that's also English.
15:45:44 <lstor> Even if they were Norwegian (like the Simula programming language!), I'd still prefer English
15:45:58 <ddarius> yitz: I'm talking about practically, not "theoretically"
15:46:07 <lstor> vixey: Hello, I'm from Norway. Norway is neither US nor UK
15:46:15 <monochrom> programming originated on Mars.
15:46:23 <conal> augustss: i'm here
15:46:35 <monochrom> This is why programmers all speak Martian. At least as far as "ordinary people" are concerned. :)
15:46:40 <vixey> lstor: then US/EU clique or something
15:46:49 <vixey> lstor: I'm just saying this is utterly bizarre
15:46:51 <lstor> vixey: Norway isn't a part of EU either
15:47:03 <augustss> conal: I'll see if I can figure out some reasonable way to extend Symbolic.  Unless you do it first. :)
15:47:06 <yitz> ddarius: I'd say turing and von neumann's work was pretty fundamental also. And not just theoretical.
15:47:18 <ddarius> vixey: Do you consider it utterly bizarre that English is spoken almost everywhere, but not, say, Japanese.
15:47:23 <augustss> Or rather, figure out how to make it extensible.
15:47:26 <yitz> well, anyway, it's still English.
15:47:47 <bos> dons: ping
15:48:04 <dons> bos: pong
15:48:08 <conal> augustss: okay.  i ran into another serious program.  the representation assumes that all arguments have the same type
15:48:17 <vixey> ddarius: exactly what I find strange is that there's an entire country of people whos native language is X but they all speak english and inhabit english speaking communities wrt programming rather than having their own language X community
15:48:18 <conal> augustss: which is not the case, e.g., scalar multiplication
15:48:27 <bos> dons: is there an immutable modification interface for uvector?
15:48:37 <augustss> conal: yes.  it works for numbers
15:48:54 <bos> dons: i.e. something like (Int -> a -> UArr a -> UArr a)
15:49:11 <dons> oh, is that a write?
15:49:13 <bos> dons: because if there is, i can't find it
15:49:16 <conal> augustss: i'll brew up something else.
15:49:22 <bos> dons: yep.
15:49:27 <augustss> conal: ok
15:49:27 <Peaker> does anyone here use hat? seems to depend on hmake which seems to be quite b0rked
15:49:40 <dons> bos,that'd be a take / cons /drop combo.
15:49:46 <dons> as for bytestrings
15:49:46 <ddarius> vixey: If they had their own language X community, they'd essentially lose access to vast quantities of libraries, expertise, jobs, tools.  There are a few localized languages and from what I can tell they don't seem very popular or successful even within the countries they are localized to.
15:49:51 <lstor> vixey: I held lectures in Norway, for Norwegian students, speaking Norwegian, about programming, but the code/identifiers/comments were still in English.
15:49:55 <dons> bos, or, you drop into MUArr, write and freeze
15:50:18 <bos> dons: would all the take/cons/drop muckery be likely to fuse?
15:50:38 <lstor> vixey: And when people who are non proficient in English ask about programming, I always say: "Learn English first."
15:50:42 <dons> hmm, hard to say. if you're doing a lot of writes, then MUArr makes more sense
15:50:56 <bos> dons: ideally, i'd like to be able to start with an initial vector and fold over it, with it getting modified in place along the way.
15:51:02 <ddarius> vixey: A similar thing happens in the research community, though to a much lesser extent.  I can find papers written in English by non-native speakers on topics such as physics, mathematics and computer science (and no doubt others).
15:51:02 <vixey> this is really awful
15:51:17 <dons> bos, yeah, an unfold would work.
15:51:36 <ddarius> vixey: It's this or the tower of Babel.
15:51:39 <dons> guaranteed in place means using MUArr though
15:51:40 <bos> dons: yes, i'm already using an unfold.
15:51:43 <Cale> Sigh. So many people need to be disabused of the notion that it's possible to have array accesses which are O(1).
15:52:23 <Cale> There must be a systematic flaw in the education of computer science, I think.
15:52:24 <bos> dons: i have a bloom filter with unfold for construction, mutability in the ST monad, and an immutable interface for probes.
15:52:27 <ddarius> Cale: I don't think we need to worry about the non O(1)ness any time particularly soon.
15:52:28 <dolio> Heh, I saw that.
15:52:49 <lstor> ddarius, vixey: Exactly. Most of my professors write papers in English. Many of the books used at the University are written in English, by Norwegian professors.
15:53:00 <Cale> ddarius: But for the same reason, we shouldn't be worrying about the non O(1)ness of lookups in binary balanced trees, for instance.
15:53:16 <bos> dons: i had this perverse hope that i could construct one in pure code without copies, and also without going through the unfold or fromList interfaces
15:53:24 <vixey> it still doesn't explain why there's no casual lisp/haskell/ml channel where people just talk in their native language
15:53:37 <vixey> (other than english)
15:53:38 <ddarius> Cale: Um... I disagree.
15:53:38 <glguy> there isn't?
15:53:39 <yitz> vixey: there are
15:53:49 <Cale> ddarius: Why? It's the same thing.
15:53:52 <dolio> Isn't there #haskell.es or something?
15:53:54 <yitz> @seen lambdabot
15:53:55 <lambdabot> Yes, I'm here. I'm in #haskell.cz, #haskell, #haskell-hac4, #gentoo-uy, #friendly-coders, #dreamlinux-es, #thunks, #haskell-hac07, #haskell_ru, #haskell.dut, #haskell.de, #haskell.es, #haskell.fi, #
15:53:55 <lambdabot> haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell-books, #rosettacode, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #
15:53:55 <lambdabot> parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #darcs, #jhc and #ghc
15:53:59 <monochrom> Translating highly specialized programming terms from English to X is hard. It's much easier to just go with English.
15:54:01 <ddarius> vixey: There are like 10 localized channels that lambdabot is on right now.
15:54:02 <dons> bos, it might be possible. it depends on the algorithm.
15:54:06 <dolio> Oh, several.
15:54:10 <lstor> #haskell.no is empty.
15:54:15 <vixey>  * Users on #haskell.jp: vixey lambdabot
15:54:15 <dons> if you can write it as a function on Streams then, yeah.
15:54:15 <Cale> ddarius: The only reason that memory accesses are O(1) is that you have a finite amount of memory and so addresses are a constant size.
15:54:19 <Peaker> all the Haskell debuggers seem to be stagnated from years ago
15:54:25 <dons> or as a composition of stream functions
15:54:31 <dons> Peaker: except ghci's new one.
15:54:35 <monochrom> For example few Chinese haskellers bother to translate Functor to Chinese.
15:54:40 <ddarius> Cale: The constant factors are important.
15:54:42 <glguy> What IRC mode do they set on lambdabot to enable it to join extra channels?
15:54:49 <Cale> ddarius: Sure.
15:54:50 <Peaker> dons, Any manual for that? I couldn't figure it out from the :help
15:54:52 <glguy> +6 means you can get unfiltered PRIVMSGs for example
15:54:54 <Cale> ddarius: They're always important.
15:55:02 <SamB> monochrom: it's not easy
15:55:15 <Cale> But if you're going to use asymptotic notation, they're irrelevant to that discussion.
15:55:21 <dons> Peaker: the ghc user's guide has full docs
15:55:22 <Peaker> dons, I have an infinite recursion or such hanging my program, and I'd like to know what functions are involved in the recursion
15:55:24 <SamB> does chinese even have capital letters, or Haskell a mechanism by which to translate, and is there even a chinese word for that?
15:55:31 <dons> glguy: they have a whitelist
15:55:35 <dolio> @quote estoy
15:55:35 <lambdabot> sebazzz says: <sebazzz> vos no te diste cuenta, pero cuando estas en pedo, y si yo estoy, te saco del alcanse todo objeto contundente
15:55:50 <Cale> Obviously, since the whole point of asymptotic notation is to ignore what happens for small n and to ignore constant factors.
15:56:04 <glguy> +L is the mode for large channels
15:56:08 <monochrom> Chinese does not have capital letters.
15:56:21 <ddarius> Cale: I suspect that most O(log n) structures would not be O(log n) if array/memory access was itself considered O(log n).
15:56:47 <bos> i wonder if basing this code on uvector is worth the added inconvenience of using a non-core library.
15:57:13 <vixey> so do they teach programming in say a japanese school?
15:57:23 <vixey> and everyone just speaks english ...
15:57:25 <monochrom> We call uppercase "big case" and lowercase "small case".
15:57:28 <dons> bos, you might want to just use STUArray ?
15:57:32 <ddarius> vixey: I imagine.
15:57:42 <dons> if you only need get/set on mutable arrays
15:57:43 <vixey> I find that really mind boggling
15:57:45 <bos> dons: probably
15:57:57 <lstor> vixey: As I said, in Norway, we speak Norwegian, but use English code, commentaries, technical terms and text books.
15:57:58 <bos> well, it's been fun to poke at the uvector internals.
15:58:00 <dons> and don't need, say, unboxed complex numbers et all
15:58:06 <dons> or zip/filter etdc
15:58:22 <SamB> vixey: I expect they speak japanese with a large number of "english" words mixed in
15:58:22 <ddarius> Yeah, the discourse will be in the native language.
15:58:28 <Cale> ddarius: I think we probably should stop making the mistake of considering it to be O(1).
15:58:40 <monochrom> English jargons like "functor" and "debug" are embedded into language X discussions.
15:58:55 <Peaker> A GUI debugger could have a much lower learning curve, I can't seem to use the ghci one.. seems harder to use than imperative-language debuggers :(
15:59:00 <ddarius> monochrom: That's often true quite outside of programming.
15:59:07 <vixey> this is just odd
15:59:19 <vixey> does nobody else find that at all strange?
15:59:29 <monochrom> define "strange"
15:59:43 <SamB> for instance, I expect japanese category theorests use the "english" terms too
15:59:43 <ddarius> vixey: Not many since how it came to be that way is pretty clear and there are clear benefits.
15:59:48 <glguy> dons: found it, +u is MORECHANS
15:59:55 <monochrom> If something emerges from evolution, it can't be strange.
16:00:05 <ddarius> Cale: I don't think there is much to be gained from it.
16:00:07 <monochrom> If something is intelligently designed, it can't be strange either.
16:00:17 <vixey> monochrom: thats' not true look at Australia
16:00:19 <SamB> vixey: when it comes down to it, the choice of whether to re-use an existing word or make up a new "native" word is easy to make
16:00:29 <lstor> vixey: Not at all. Is it not better to have the effort focused on developing something new, rather than translating existing work into another language?
16:00:30 <SamB> obviously, it's easier to just re-use
16:00:34 <Cale> ddarius: That, or adopt soft-O notation, which ignores logarithmic factors.
16:01:06 <vixey> anyway sorry for all the off topic stuff I brought up
16:01:18 <dmwit> vixey: I hear that people in the maths and sciences in other countries are required to be able to read English.
16:01:23 <SamB> I do hope they translate the word "tree" into the native-languagee word for tree, though
16:01:33 <vixey> dmwit that seems really terrible
16:01:38 <dmwit> vixey: So I doubt that this phenomenon is restricted to computer jargon.
16:01:39 <ddarius> vixey: As an exercise, consider limiting yourself only to languages, tools, texts, webpages, articles, etc. in a non-English language of your choice.
16:01:39 <monochrom> I can make a GUI debugger with high learning curve.
16:01:49 * dmwit doesn't find having a shared language to be terrible
16:02:05 <monochrom> In fact numerous GUI frontends to gdb do that. :)
16:02:20 <vixey> no being forced to learn a new natural language just to program
16:02:23 <SamB> vixey: consider what would happen if only 1/n of the material was in a given language, out of n languages in use
16:02:34 <yitz> in math, it used to be that you needed to know English, French, German, and Russian. I'm not sure that's true anymore though.
16:02:38 <vixey> natural language like english, japanese, french .. etc are VERY hard to learn for some people
16:02:46 <SamB> and everybody only knew 1-3 languages
16:02:56 <dmwit> vixey: The alternative is to have to learn *many* natural languages just to program.
16:03:01 <Peaker> monochrom, but I think a GUI debugger for Haskell can look very much like Subtext -- could be so easy to learn and use
16:03:19 <Peaker> why does :step hang? Its pretty useless at discovering what is hanging when it hangs itself :-(
16:03:32 * Peaker is disappointed with Haskell debugging facilities :-(
16:03:43 <yitz> vixey: knowing enough of a language to get by technically is usually not too hard. of course, it's good to know it better than that.
16:03:43 <SamB> how come nobody is complaining about everyone having to learn C?
16:03:47 <monochrom> Usually non-English people have to learn some English for some other reasons in addition to programming, e.g., they want to, um, watch porn sites? :)
16:03:58 <glguy> oops
16:04:01 <ddarius> Peaker: The GHCi debugger is new in 6.8
16:04:07 <Cale> Peaker: Up until recently, there were none at all. The reason is that you don't tend to debug things in the same way.
16:04:20 <dmwit> "oops"?
16:04:25 <Peaker> Cale, How do you debug a "hang"/infinite recursion?
16:04:28 <dmwit> glguy: Was that your fault? O_o
16:04:30 <ddarius> dmwit: glguy tripped over the cord
16:04:35 <dmwit> heh
16:04:38 <monochrom> What is :step supposed to do?
16:04:44 <vixey> look
16:04:45 <vixey> http://www.amazon.co.jp/exec/obidos/ASIN/4872805054/chikusekitasy-22/ref=nosim/
16:04:47 <lambdabot> http://tinyurl.com/6ngkmy
16:04:52 <vixey> a book about subversion in japanese
16:04:55 <Peaker> monochrom, continue the computation until the next breakable point
16:05:16 <Cale> Peaker: Usually if I don't know what function it's in, I'll just use the profiler to find it.
16:05:28 <monochrom> That sounds like you have narrowed down your region of non-termination. Between two breakpoints.
16:05:41 <SamB> vixey: really, the only question is "which language should be the common technical language"
16:05:42 <Peaker> Cale, I know one of the functions that's involved, but its probably a mutual recursion across multiple functions
16:05:43 <glguy> phew
16:05:46 <SamB> when you get down to it
16:06:09 <dolio> Lojban, clearly.
16:06:16 <monochrom> IOW :step may hang legitimately after all. Not a bug. Not a barrier to entrance. Just doing its advertised job.
16:06:19 <yitz> dolio: lojban
16:06:19 <vixey> Haskell!!
16:06:40 <Cale> Peaker: Try running the profiler on it and see which functions have a lot of entries.
16:06:42 <SamB> and you can't base the answer soley on the structure of the language
16:06:44 <dmwit> yitz: Case matters?
16:06:49 <doun> dolio: .ie
16:06:51 <yitz> no caps in lojban
16:07:05 <dmwit> lojban++
16:07:07 <ddarius> yitz: Then we can't do Haskell in it!
16:07:08 <monochrom> If you want something that guarantees to not hang, look for something that says "do one reduction only".
16:07:33 <monochrom> Or if you really like :step, insert more breakpoints.
16:07:36 <yitz> ddarius: otoh, you don't need any unicode. :)
16:07:43 <Peaker> Cale, It fails to compile with -prof.. looking for the profile-able lib packages...
16:07:50 <ddarius> yitz: I don't need any unicode anyway.
16:08:06 <Cale> Peaker: mm... that's annoying then.
16:08:52 <Cale> If the code is sufficiently short, you could paste it on hpaste, and we can see if we spot anything.
16:08:55 <Peaker> Cale, Have you seen subtext? It seems to me like that kind of inspection of a running Haskell program should be possible too
16:08:56 <vixey> but there are definitely enthusiast like us all around the world
16:09:05 <vixey> but.. only english speaking communities
16:09:16 <Cale> Peaker: I'm thinking something more like HOPS would be appropriate :)
16:09:17 <ddarius> vixey: Start your own community then.
16:09:29 <vixey> ddarius: I can't speak any language other than english
16:09:30 <Peaker> Cale, what's HOPS?
16:09:38 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/
16:09:39 <lambdabot> Title: HOPS
16:09:49 <monochrom> I actually don't see how a GUI makes this paradigmatically easier.  Marginally easier yes.  Analoguely specify breakpoints on a 2D screen.  A big red button for interrupting the program.   ...  All just marginal, cosmetic improvements.  Nothing new.
16:09:51 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
16:09:51 <lambdabot> Title: HOPS - Animations
16:09:56 <SamB> vixey: so what's your problem?
16:10:24 <vixey> just confused
16:10:39 <doun> .i ro do na kansa mi lo nu tavla ne'i le lojbau tcana .oi.zo'o
16:10:41 <SamB> frankly, I am already annoyed by the amount of technical information inaccessible to me due to language barriers, as a speaker of the dominant language!
16:10:46 <Peaker> Cale, thanks for the reference, looks interesting
16:11:16 <lament> you know it's Lojban when your first thought is "it must be written backwards"
16:11:27 <nolrai_> lojban!?
16:11:32 <SamB> I imagine this would be several orders of magnitude more annoying if technical information was equally distributed between languages
16:11:46 <doun> hehe
16:11:50 * monochrom looks at HOPS screenshot and thinks "it's all cliques to me".
16:12:23 <yitz> doun: tcana? he
16:12:26 <Peaker> Cale, yay, profiling now works - what can I do with the .prof file?
16:12:33 <hpaste>  thoughtpolice pasted "(no title)" at http://hpaste.org/7798
16:12:41 <augustss> Peaker: hp2ps
16:12:45 <doun> yitz: station/channel/node/communication
16:12:53 <doun> yitz: aka #lojban
16:12:55 <Cale> Peaker: After letting the infinite loop run for a bit, look in the .prof for the functions with a large number of entries.
16:13:00 <yitz> ah
16:13:04 <Cale> (there's a column labelled 'entries')
16:13:08 <augustss> Oh, .prof.  You can stare at it
16:13:25 <lament> .be da uxr ind e .,mi ne pa'r ol'a .s loj ban'
16:13:41 <Peaker> Cale, it makes a 0-byte .prof file
16:13:52 <Cale> oh, run the program with  +RTS -p
16:14:02 <Cale> (on the commandline)
16:14:10 <Peaker> Cale, oh, thanks
16:14:37 <SamB> honestly, I think it would make more sense to use ELVISH if it weren't for the lack of Unicode allocation...
16:14:42 <vixey> http://d.hatena.ne.jp/bowmoq/20080205
16:14:43 <lambdabot> Title: 2008-02-05 - bowmoq
16:14:44 <Peaker> total alloc = 564,900,008 bytes  (excludes profiling overheads) ???
16:14:55 <yitz> SamB: how about Klingon?
16:14:55 <lament> SamB: i'm all for using russian
16:15:07 <Pseudonym> Esperanto!~
16:15:09 <Peaker> Cale, it seems to only show stuff at the module level
16:15:16 <SamB> yitz: klingons would break things too much
16:15:20 <hpaste>  thoughtpolice annotated "(no title)" with "FIX: session types example involving newtypes" at http://hpaste.org/7798#a1
16:15:25 <doun> {.i ro do na kansa mi lo nu tavla ne'i le lojbau tcana .oi.zo'o} => "each of you are not with me in the act of talking within the lojbanic channel [complaint] [joking]” :)
16:15:43 <Pseudonym> Mi ne parolas Logxbanon.
16:15:44 <SamB> that would only be appropriate for ASM/C/C++ and so forth
16:16:14 <jaj> if I want to try out yi, should I use the tarball from hackage or should I go for the darcs version?
16:16:57 <doun> jaj: I think I used the darcs version. seem to remember hackage not being up to date in some aspect... be prepared for a couple of issues but the Wiki page addresses the ones I had
16:17:02 <Pseudonym> doun: Does Lojban really have a sarcasm marker?
16:17:18 <doun> Pseudonym: yeah
16:17:22 <Pseudonym> Man.
16:17:25 <doun> Pseudonym: well, "comical"
16:17:25 <SamB> doun: that is SICK
16:17:33 <Pseudonym> That would be both cool, and also ruin a lot of jokes.
16:17:43 <SamB> is it mandatory?
16:17:44 <Cale> Peaker: that's total allocation, it doesn't count deallocation :)
16:17:49 <doun> SamB: no, optional
16:17:53 <monochrom> Nice. Normative. Narrative. Sarcastive. :)
16:17:56 <SamB> oh, okay.
16:18:05 <SamB> so why didn't they just use :-)
16:18:12 <Pseudonym> Sarcastive or sardonic?
16:18:13 <Peaker> Cale, But even knowing that the program dealt with 0.5GB of memory in 2 seconds of operation is dazzling
16:18:17 <SamB> or what have you
16:18:26 <yitz> SamB: illegal characters in lojban.
16:18:44 <SamB> yitz: what is this, windows file names or something?
16:18:47 <Pseudonym> BTW, it also makes it meta-logical.
16:18:53 <Cale> Peaker: could you put the .prof on hpaste?
16:18:58 <yitz> SamB: just about
16:19:03 <doun> well, anything that you can say in person has a word that can be written, and vise versa
16:19:05 <Pseudonym> If you write a sentence that doesn't say what you mean, then that's not logical.
16:19:07 <lament> Pseudonym: .sedvi po',vus im iti logx banan .en ia'l ingv'
16:19:13 <Pseudonym> Woo, paradox!
16:19:16 <hpaste>  thoughtpolice annotated "(no title)" with "removed sselect/offer from example since it was unnecessary" at http://hpaste.org/7798#a2
16:19:38 <SamB> how do you pronounce "."
16:19:45 <SamB> how do you pronounce ","
16:19:50 <doun> SamB: that is a vocal pause
16:19:51 <roconnor> dot
16:19:53 <roconnor> comma
16:19:55 <Peaker> Cale, it seems to have only 3 lines - no function information
16:20:05 <Cale> Peaker: oh, that's strange...
16:20:09 <Peaker> Cale, 5 lines in the table
16:20:19 <Pseudonym> Lojxbano estas mallogika.
16:20:37 <doun> I'm guessing mallo- something means derogative
16:20:47 <Pseudonym> mal- is the universal not-
16:20:53 <lament> un-
16:20:54 <lament> rather
16:20:58 <Vulpyne> Not logical?
16:21:01 <Pseudonym> Yes.
16:21:03 <lament> illogical
16:21:13 <Pseudonym> Esperanto has half the adjectives of most languages because of mal.
16:21:24 <lament> 'mal-' means 'un-', as in "ungood" - "malbona"
16:21:25 <Pseudonym> nova = new, malnova = old
16:21:29 <Cale> Peaker: when you compiled for profiling, did you include -auto-all?
16:21:34 <jaj> are there people who speak lojban fluently? I've been told that it sounds really artificial
16:21:38 <Peaker> Cale, nope, I thought just -prof ?
16:21:45 <Vulpyne> jaj: Some, not a whole lot.
16:21:45 <Pseudonym> Perhaps we should take this discussion to -blah.
16:21:50 <SamB> jaj: it sure LOOKS it!
16:21:55 <doun> in lojban malglico means "damn english" as in mabla and glico
16:21:56 <Cale> -prof will require you to annotate the things you want profiled in the source
16:22:08 <Peaker> Cale, ah! thanks, now I get a real profile
16:22:50 <lament> oh well, damn lojban them back!
16:22:55 <hpaste>  Peaker pasted "Profile" at http://hpaste.org/7799
16:23:01 <lament> (how come english doesn't have a word for 'damn lojban'?)
16:23:29 <doun> jaj: there are a few people who speak it fluently. there are probably 20 peopl I'd estimate that can have casual noncomplex conversations (on Teamspeak). it sounds like spanish and perhaps arabic
16:23:33 <Peaker> the 5KB limit is way too small
16:23:58 <Cale> Peaker: so the problem is in isThreatened for sure
16:24:06 <doun> lament: I'd say the best word in English is defenestrate
16:24:15 <Pseudonym> Compare this with several million for Esperanto.
16:24:48 <Peaker> Cale, why?
16:24:49 <Cale> Peaker: oh, it got cut off...
16:24:52 <doun> Pseudonym: millions of people watch pop idol and vote for bush
16:24:52 <ddarius> Compare this with on the order of a billion or so for English.
16:25:12 <Pseudonym> doun: I suspect it's a different few millions we're talking about there.
16:25:14 <Cale> Peaker: at least, if there's nothing else which comes close to the 6235 entries that isThreatened has.
16:25:42 <Cale> I suppose it could come from myArmyInCheck calling isThreatened infinitely many times.
16:25:50 <Peaker> http://pastebin.org/37629
16:25:58 <doun> Pseudonym: I suspect the numbers aren't relevant
16:26:38 <Cale> ah, okay, this is quite a different picture :)
16:26:40 <lament> doun: i like many english words, for example lambent
16:26:51 <doun> hehe
16:27:10 <Peaker> A OneToMany map implementation I wrote/use in there: http://pastebin.org/37630 (I doubt it has the infinite recursion)
16:27:21 <glguy> !seen shapr
16:27:27 <glguy> @seen shapr
16:27:29 <lambdabot> shapr is in #haskell-soc, #haskell-blah, #scannedinavian and #haskell. I last heard shapr speak 1h 15m 4s ago.
16:27:31 <Pseudonym> doun: I agree.  I know I sound like a Java advocate when I say this, but Lojban is not a practical language for communication.
16:27:34 <glguy> @get-shapr
16:27:35 <lambdabot> shapr!!
16:27:41 <ddarius> glguy: Don't stop now.
16:27:43 <ddarius> #seen shapr
16:27:44 <Peaker> Cale, this is probably the problematic code: http://pastebin.org/37631
16:28:03 <Pseudonym> Why this is different from a Java advocate is that for programming languages, there are as many "listeners" as you want, assuming you know how to install compilers.
16:28:03 <lament> ¿seen shapr?
16:28:11 <mar77a> if i compile a haskell source file to an exe using ghc --make, will the executable work on other computers without installing ghc or anything related (like a run-time lib)?
16:28:12 <Peaker> Cale, there's a board hard-coded in there - the one that causes the infinite loop
16:28:13 <vixey> I'm kind of disappointed I thought there was a whole world out there but I guess not
16:28:30 <ddarius> mar77a: Yes.
16:28:32 <Cale> Peaker: There are some very long function definitions there.
16:28:38 <Pseudonym> Installing a new language on a human is much harder, even than installing programs on Windows.
16:28:45 <Peaker> Cale, would be glad to get feedback about how to make it nicer!
16:28:50 <ddarius> mar77a: A gmp library may or may not need to be provided.
16:28:57 <Pseudonym> I sometimes wish my brain had a package manager.
16:28:58 <doun> Pseudonym: well if you have a friend that speaks lojban then it is kind of fun
16:29:16 <Cale> Peaker: from the profile, we know that 'moves' is entered 48222 times. Does that seem reasonable?
16:29:29 <ddarius> Pseudonym: Until that day you do the equivalent of rm -rf . /
16:29:36 <Peaker> Cale, nope
16:29:37 <vixey> > fix ("zen"++)
16:29:41 <lambdabot>  "zenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzenzen...
16:29:43 <Pseudonym> doun: Actually, I have a friend whose website is in eight languages, including Classical Greek, Lojban, Esperanto and Latin.
16:29:53 <doun> Pseudonym: nick nicholas?
16:29:57 <Pseudonym> Yup.
16:30:07 <doun> Pseudonym: he's one of the fluent lojbanists. the first, apparently
16:30:07 <Peaker> Cale, it only causes a moves recursion in weird cases, appearantly (that specific chess board configuration, for example)
16:30:58 <lament> my biggest problem with lojban is that you can only use it to talk to a bunch of geeks
16:31:05 <Pseudonym> Nick Nicholas also was my lab demonstrator for functional programming back in 1992.
16:31:07 <ddarius> Are Egyptian heiroglyphs in Unicode?
16:31:14 <Pseudonym> So there.
16:31:17 <vixey> ddarius: I think not
16:31:22 <doun> my biggest problem with BSL is you can only use it to talk to a bunch of deaf people
16:31:32 <Pseudonym> doun: There are more than 20 deaf people.
16:31:35 <lament> deaf people are more fun to talk to than geeks
16:31:42 <ddarius> doun: You can talk to more than deaf people.
16:31:46 <Pseudonym> There's a whole deaf culture.
16:31:50 <Pseudonym> Geek culture I already know.
16:31:56 <lament> exactly
16:32:07 <lament> apparently a whole bunch of people got into lojban at sci-fi conventions
16:32:12 <ddarius> Joining #deaf anytime?
16:32:25 <Peaker> Cale, I'd love to see the cycle/recursion in which "moves" is, but I can't figure that out from the .prof file
16:33:04 <Pseudonym> I remember talking to Nick when we was translating "As You Like It" into Klingon.
16:33:10 <Pseudonym> s/we/he/
16:33:25 <Peaker> what about the protoss language?
16:34:24 <Cale> Peaker: what does the board position look like? Is one side in check?
16:34:50 <wolgo> I am working through YAHT. What does the notation let foo (x:xs) mean, specifically the argument portion. The "let foo" part I understand.
16:35:15 <dibblego> wolgo, it's called pattern matching
16:35:18 <ddarius> wolgo: What does YAHT say it means?
16:35:23 <Peaker> Cale, yeah "myArmy" is in check (uppercase is my army)
16:35:30 <wolgo> It does not explain the usage
16:35:30 <Peaker> http://hpaste.org/7800
16:35:47 <wolgo> wait
16:35:57 <wolgo> I can kind of understand the code.
16:36:06 <wolgo> Lets see if I can figure it out don't tell me
16:36:37 <shapr> glguy: Yes?
16:36:40 <doun> Pseudonym: was there anything interesting about that anecdote or were you just stating that you once spoke to nick nicholas?
16:36:58 <Pseudonym> Well, I've spoken to him a lot.
16:37:08 <Pseudonym> But on this occasion, he was trying to translate "jealousy".
16:37:13 <Pseudonym> Because Klingon didn't have a word for it.
16:37:22 <glguy> shapr: could you restart hpaste? I killed it to unlink it from my nickserv registration to get a /bot cloak
16:37:26 <shapr> sure
16:37:28 <Pseudonym> And get it to rhyme.
16:37:36 <glguy> or even give me sudo to do that
16:37:45 <Pseudonym> He ended up saying "I feel acid".
16:37:51 <Cale> Peaker: Could you let it run for a little longer before killing it? Do the numbers just scale up?
16:37:58 <lilac> :t \f a -> a >>= (\a' -> return $ f a')
16:38:00 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a -> a1) -> m a -> m a1
16:38:04 <lilac> :t fmap
16:38:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:38:18 <doun> Pseudonym: that's not what he wanted to express at all!
16:38:31 <Cale> Peaker: We could maybe determine the cycle simply by looking at which functions had their entry count go up :)
16:38:39 <ddarius> ACid is tingly.
16:38:46 <Peaker> Cale, or maybe I'm wrong and its just _very very_ slow and not a cycle :)
16:39:01 <Cale> Peaker: The first thing I'd probably do though, is to try to decompose things into simpler definitions.
16:39:01 <Pseudonym> I think he was trying to get the corrosive bit across.
16:39:05 <Peaker> Cale, it seems like maybe its doing an unnecessary depth-1 search of the board
16:39:11 <doun> Pseudonym: yes
16:39:13 <shapr> glguy: done
16:39:23 <Peaker> Cale, though that's just hundreds of options, at worst, I think
16:39:34 <glguy> shapr: thank you
16:39:36 <Peaker> Cale, what stuff can be decomposed nicely?
16:39:48 <Cale> Definitions which are longer than 10 lines are too complicated, and should be broken into something simpler.
16:40:01 <Cale> 'moves' in particular is very long, and likely hard to test on its own
16:40:25 <Peaker> Cale, Number of moves possible: Stack space overflow: current size 8388608 bytes.  here's the .prof http://pastebin.org/37634
16:40:51 <Peaker> Cale, If moves had been a pattern match on each piece - would you consider each pattern match its own definition?
16:40:59 <glguy> woot, try /whois hpaste
16:41:08 <lament> Pseudonym: perhaps he was on acid.
16:42:52 <Cale> Peaker: Maybe just factor it so that moves is some function applied to myArmy board MapManyToOne.! pos
16:43:17 <Cale> hmm
16:45:57 <Peaker> Cale, http://pastebin.org/37635  (Now only the Pawn case is huge)
16:46:20 <Cale> yeah, I was just looking at that :)
16:46:34 <Peaker> Cale, I think its a complete chess move thingie, btw :-)
16:47:02 <Peaker> (aside for this annoying bug)
16:47:57 <Peaker> Cale, would it help you to be able to run it?
16:48:03 <Cale> possibly, yeah
16:48:19 <ddarius> I have a program that solves all the problems of the world, except that it doesn't work.
16:48:41 <Peaker> Cale: The OneToManyMap: http://pastebin.org/37630
16:49:06 <Peaker> Cale, and main.hs: http://pastebin.org/37637
16:49:34 <Peaker> Cale, should run, I think (these 3 files)
16:52:39 * Cale does some debugging.
16:53:02 <Peaker> Cale, thanks!
16:53:44 <Cale> heh, that's interesting, the debugger treats your excessive parens as additional entries in the history :)
16:54:19 <ddarius> You mean I have a reason to be anal about superfluous parens now?
16:54:46 <Peaker> hehe, I am just unsure about precedence!
16:55:10 <Peaker> Cale, I removed the enemy's king and that makes it not so bad anymore - I guess its the castling of hisArmy that is the problem
16:55:25 <Peaker> (not so bad -> does not hang :-)
16:56:13 <lament> chess is so hard
16:56:19 <Cale> I think it's caught in shortMoves
16:56:36 <lament> Peaker: sorry, forgot, are you the guy who wants to revolutionize UI?
16:56:48 <vixey> what's going on ?
16:56:50 <Peaker> Cale, oh! I think its testing if the king is threatened to know if checked - so it tests all enemy moves - which tests castling of the enemy as one move, which tests if HE is threatened (if castling is allowed) and so on!
16:56:58 <Peaker> lament, yeah :)
16:57:01 <Cale> Peaker: that makes sense
16:57:30 <Cale> Chess has such arbitrary-seeming rules :)
16:57:37 * Cale is a go player ;)
16:57:39 <dibblego> they have evolved
16:58:10 <Cale> Though to be honest, things like the Japanese rules for Go also have arbitrary annoyances too.
16:58:32 <Cale> The New Zealand rules are the best.
17:00:10 * Cale wonders how to set the number of logged breakpoints in ghci
17:01:05 <Cale> GHCi remembers the last 50 steps in the history (perhaps in the future we'll make this configurable).
17:01:08 <Cale> damn it.
17:01:22 <lament> Cale: my friends complain that go is too abstract, as compared to chess. I think i'm beginning to understand what they mean
17:01:35 <Cale> Oh?
17:01:52 <Cale> I suppose the meaning of a piece is much more abstract.
17:02:26 <sw17ch> Would any one be concerned if Haskell were used for avionics software?
17:02:30 <dibblego> I don't see either more or less abstract; do your friends play chess blind-folded?
17:02:39 <ddarius> Cale: You can't (currently).
17:02:58 <vixey> sw17ch: not really
17:03:06 <Cale> ddarius: yeah, that's rather annoying :)
17:03:50 <lament> Cale: yes, that's it
17:04:08 <lament> Cale: you can take chess at "face value", as a puzzle with complex rules
17:04:10 <sw17ch> i have the distinct pleasure to be working on the software verification process for the Boeing 787... C is scary some times
17:04:24 <monochrom> (rude joke) "the impossible has happened! my plane has exploded!"
17:04:28 <Cale> It's somewhat like there are almost arbitrarily many "pieces" in go.
17:04:35 <lament> Cale: it's abstract, mathematical, but not more so than any other such puzzle, and it's pretty clear what to do (in chess)
17:04:39 <lament> Cale: yeah
17:04:50 <Cale> As it's not really about any one stone, but the relationship that each stone has to the others.
17:04:51 <sw17ch> monochrom: it's a little like that :)
17:05:04 <lament> of course, that probably applies to chess only at a very low level of play
17:05:15 <lament> but it doesn't apply to go at all, outside 3x3 boards
17:05:37 <Cale> One thing I like about chess though is that a relative beginner can watch a pro game and take *something* away, even without the same ability to read ahead.
17:05:46 <Cale> er, go
17:05:47 <Cale> rather
17:06:11 <Cale> chess has the problem that everything is founded on reading ahead and tactical sequences
17:06:24 <sw17ch> now, I can see Haskell and higher level languages being very useful in avionics.... but it will never happen
17:06:28 <monochrom> If you use haskell for such high-assurance software, there are two verifications to do. Verify software written in haskell according to haskell semantics. Verify the compiler.
17:06:33 <Cale> You can't understand a strategy without being able to understand the sequences which make it work.
17:06:44 <Peaker> Cale, it works now. Thanks for all the help!
17:06:48 <Cale> Whereas with go, things like influence and territory are somewhat obvious.
17:07:01 <ddarius> Cale: The board is more mutable in chess.
17:07:16 <Cale> That too :)
17:07:16 <sw17ch> monochrom: considering that the verification process for a compiler is expensive to the point of the GDP of small countries... :)
17:07:46 <lament> Cale: yeah, exactly, it's a puzzle :)
17:07:56 <sw17ch> but yeah, if some one would cough up the dough to get the FAA to verify GHC...
17:08:07 <Peaker> sw17ch, do they verify gcc?
17:08:13 <bd_> sw17ch: what about latency issues?
17:08:23 <Peaker> sw17ch, or do they verify the machine code output?
17:08:27 <lament> Cale: but it does have appeal, it's more intellectual somehow
17:08:29 <Cale> Peaker: great!
17:08:33 <bd_> avionics would seem to need to have some level of latency guarentees
17:08:33 <lament> Cale: brute-force Western kind of intellectual
17:08:40 <lament> cold logic etc
17:08:49 <sw17ch> Peaker: GCC has sorta been verified
17:08:55 <Peaker> sw17ch, how?
17:09:22 <Cale> lament: Yeah, it has a bit too much of that for me (and I'm a mathematician, so what does that say?)
17:09:29 <sw17ch> I believe the company name is Tornado. they did some stuff to GCC, paid to get their version verified, and sell a huge set of vxWorks libraries that sit along side of it
17:09:41 <wagle> all sorts of undefined / implementation specific behavior in C
17:09:43 <sw17ch> licences are ungodly expensive... and this is not just the regular expensive
17:09:48 <Cale> I like how in go, you have to get your emotions and logic to cooperate. :)
17:09:52 <lament> Cale: yeah, same experience, but i still feel stupid for not getting it :)
17:09:57 <yitz> Cale: often in go, a boring-looking move is based on the knowledge that a joseki would turn out badly.
17:10:10 <ddarius> Stone 33, I knew him well.
17:10:23 <Cale> yitz: well, yes, I'm not saying that go is devoid of tactics either.
17:10:30 <sw17ch> one of the other things about avionics that makes is hard is often times, dynamic memory is banned, threads are banned, and you need to work inside the bounds of a RTOS
17:10:37 <Cale> yitz: But you can go quite a long way on intuition alone.
17:10:41 <sw17ch> this is all to combat bad software practice
17:11:31 <sw17ch> actually, the rules for C are wrapped up in a large (read, thousands of rules) document known as DS1004 which states how you may program in C
17:11:45 <sw17ch> ...the overhead of bringing a language into avionics ... is enormous
17:11:54 <lament> go obviously has tactics and chess obviously has strategy
17:12:19 <Cale> lament: yeah, it's just the relationship between the two which is different in each
17:12:23 <ksandstr> "how you may program in C"... that sounds very nice. as in, "never use the short datatype, never use pointers"
17:12:36 <Peaker> sw17ch, Seeing lots of investigations into known plane crashes (on National Geographic :-) It seems like stupid design bugs cause crashes, as they seem to have managed to squash implementation bugs
17:12:49 <yitz> lament: they both also have aesthetics. but go has a lot more.
17:13:20 <wagle> sw17ch, i dont appear to get any google hits for DS1004 for "programming in C" rules
17:13:23 <lament> chess is combat, it's not supposed to be pretty :)
17:13:57 <sw17ch> wagle: /me tries to find it
17:14:05 * sw17ch prepares to eat crow
17:14:06 <Peaker> sw17ch, for example, a "feature" on one of the modern planes that disables the auto-pilot A) if a control is used for a long period of time  B) the auto-pilot is split per-control and it only disables the specific control used  C) notification that the auto-pilot was disabled is not emphasized
17:15:13 <Peaker> this caused russian pilot who did not know the plane to crash - as the pilot let his child "play" with the controls (auto pilot was on, the child was not supposed to make a difference) and he pressed a control for 30 seconds straight which disabled autopilot on that control - which confused the hell out of the pilot who lost control
17:15:34 <sw17ch> Peaker: yep, sounds familiar :)
17:15:49 <Peaker> sw17ch, the auto-pilot which is split per-control sounds like a horribly stupid design idea
17:15:50 <Cale> Has anyone here played shogi?
17:16:08 <ksandstr> or that chinese chess variant with cannons and advisors and generals
17:16:22 <yitz> Peaker: the stupidest part was that the pilot didn't know the aircraft.
17:16:31 <Cale> I think it's an interesting twist on chess. I like the idea of being able to drop captured pieces back into play as your own :)
17:17:09 <ksandstr> Cale: there's also the drop chess 4-player variant, 2 boards, 2 teams
17:17:18 <sw17ch> hehe, long story short, i think that a lot of Haskell's rules fit very well into the problems we're forced into in avionics
17:17:26 <sw17ch> i'd love to see GHC 6.8.X verified
17:17:42 <sw17ch> along with linux 2.6.x
17:17:55 <sw17ch> err... linux 2.6 with the RTOS patch set
17:18:14 <Peaker> yitz, I think pilots sometimes switch to fly other kings of planes
17:18:16 <yitz> Cale: wouldn't that make captures so dangerous that the game would turn into epee fencing - two players nervously twitching at each other, afraid to move?
17:18:26 <Peaker> yitz, a uniform interface for safety-related things could be nice
17:18:40 <Cale> yitz: well, it does take a turn to put a piece back into play.
17:19:10 <yitz> Peaker: switching aircraft in the military happens also - but the pilot must know the aircraft cold before flying it.
17:19:15 <Cale> yitz: and I think there are restrictions on where it can be placed
17:19:42 <dibblego> a bit like the dogma around programming languages
17:20:10 <vixey> what dibblego?
17:20:15 <dibblego> nothing
17:20:31 <vixey> huh..
17:21:10 <lament> shogi and other chess variants seem like they're mostly just chess variants
17:21:20 <sw17ch> so, any one have a few billion dollars to verify a compiler? :)
17:21:20 <lament> more similar than different
17:21:29 <vixey> sw17ch: compcert
17:21:31 <yitz> @faq programming language dogma
17:21:31 <lambdabot> The answer is: Yes! Haskell can do that.
17:21:32 <lament> but that's a superficial view and i never played shogi
17:21:47 <wagle> sw17ch, didnt find anything?
17:22:01 <sw17ch> wagle, i see lots of references ot it, but i can't find the document
17:22:17 <sw17ch> not that you'd want to read it...
17:22:39 <vixey> sw17ch: this is #haskell
17:23:45 <sw17ch> vixey: ...good point...
17:24:41 <edwardk> @pl \f v -> leftAdjunct f . runIdentity v
17:24:42 <lambdabot> (. runIdentity) . (.) . leftAdjunct
17:24:44 <edwardk> blech
17:25:10 <vixey> :t liftM2 (.)
17:25:11 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Monad m, Functor f) => m (a -> b) -> m (f a) -> m (f b)
17:25:22 <wagle> haha..  found a webpage with someone named sw17ch mentioning it 3 months ago...
17:25:36 <tchakkazzzzz> :liftM2 (Prelude..)
17:25:44 <tchakkazzzzz> ...
17:25:48 <tchakkazzzzz> :t liftM2 (Prelude..)
17:25:50 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m (b -> c) -> m (a -> b) -> m (a -> c)
17:27:22 <edwardk> @pl \f -> Ran (\a -> Identity (rightAdjunct a f))
17:27:23 <lambdabot> Ran . (Identity .) . flip rightAdjunct
17:28:23 <wagle> sw17ch, i guess i'd be worried about programs-in-haskell operating sensibly with corrupted (memory errors, etc) data
17:28:59 <wagle> if it type checks, its assumed to aways be/remain correct
17:30:17 <sw17c1> wagle: i found it... and as it turns out, it's not official FAA, it's internal to the Aerospace company in question
17:30:30 <wagle> sw17ch, i guess i'd be worried about programs-in-haskell operating sensibly with corrupted (memory errors, etc) data
17:30:33 <wagle> if it type checks, its assumed to aways be/remain correct
17:30:49 <wagle> cool..  you have an url?
17:30:49 <sw17c1> wagle: very good point
17:31:05 * SamB realizes why the law of excluded middle doesn't actually make sense
17:31:26 <sw17c1> wagle: well, i would... but i just looked on the bottom and there's all sorts of fun legal warnings from sending it any where...
17:32:04 <dolio> Because Platonism is lame sauce?
17:32:28 <SamB> dolio: because some things are undecidable
17:32:43 <wagle> Andrew Appel had a grad student hold a 150 watt lightbulb up to a java card to introduce errors which broke the type system, and allowed exploits
17:33:07 <wagle> well, if there's an url, then ...
17:33:09 <edwardk> woot. i got adjunctions working as right and left kan extensions.
17:33:13 <SamB> wagle: was he too lazy to do it himself?
17:33:26 <sw17c1> wagle: it's not a url
17:33:35 <sw17c1> i had to jump through a few VPN's to find it
17:33:38 <wagle> ah..  oh well
17:33:51 <sw17c1> i can see what you say about the type checking though
17:33:58 <sw17c1> but, that same mantra is held in the C stuff too
17:34:00 <sw17c1> only it's worse
17:34:05 <sw17c1> "Well, it compiles. Lets check it in."
17:34:21 <sw17c1> with a few 1000 engineers over nearly a decade
17:34:26 <sw17c1> when it comes to verification...
17:34:33 <edwardk> i.e. that f -| g iff Ran g Identity exists and preserves a bunch of crap we don't care about. similarly f -| g iff Lan f Identity exists with a bunch of side conditions
17:35:04 <wagle> i keep planning to grok self-stablizing code, but i never get a round-tuit
17:35:20 <tchakkazzzzz> Some day, I might actually understand all this category theory stuff.
17:35:43 <tchakkazzzzz> Until then, I'll just look at it and go "Wow. This could make sense and be beautiful if I knew a bit more about it."
17:35:59 <wagle> in c, you know you are in trouble..  dunno if knowing that helps, though
17:36:01 <edwardk> tchakkazzzzz: i'll blog up a bit on this probably later tonight if i can think of something to go with it
17:36:17 <sw17c1> wagle: actually though, the hardware i'm dealing with has 16 independent processors doing the exact same thing to guard against corruption
17:36:34 <sw17c1> which is much muore interesting when you are in the upper atmosphere :)
17:37:02 <ddarius> tchakkazzzzz: Learn complex analysis.
17:37:09 <tchakkazzzzz> edwardk: Yeah, I've been reading your recent blog posts about it. Neat stuff.
17:37:12 <SamB> tchakkazzzzz: I think it doesn't have to make sense before it becomes beautiful
17:37:29 <tchakkazzzzz> ddarius: No, thanks. I'm allergic to analysis.
17:38:31 <tchakkazzzzz> SamB: True, true. The symmetry of <something> and co<something> is quite neat, even if you have no clue what <something> is about.
17:38:41 <wagle> i tried once to write a "help!  i've been hacked!" error handler that was robust vs malicious code overwriting my memory...  best i got was to assume that the malicious code couldnt overwrite the memory page the SP register was pointing into
17:38:54 <SamB> tchakkazzzzz: I was thinking also of the diagrams with arrows
17:39:00 <ddarius> SamB: It's way way more beautfiul if you know what's going on.
17:39:10 <SamB> ddarius: I'm sure
17:39:11 <edwardk> tchakkazzzzz: yeah, i find it particularly interesting when the symmetry breaks down though. those always show you where the abstraction leaks.
17:39:12 <tchakkazzzzz> SamB: Oh, they are nifty, yes.
17:39:13 <MarcWeber> sw17c1: Do you also have 16 independant busses and memory slices?
17:39:45 <tchakkazzzzz> edwardk: In the Haskell implementation, or in the theory itself?
17:39:49 <wagle> penrose's new book has a primer on complex analysis
17:40:08 <sw17c1> MarcWeber: i'm sorry, 48
17:40:08 <hpaste>  Wolgo pasted "Is this readable?" at http://hpaste.org/7801
17:40:10 <tchakkazzzzz> edwardk: Because I can see a whole lot of newtype (un-)wrappers make stuff ugly.
17:40:17 <ddarius> wagle: Title? Or do you mean "The Road to Reality"?
17:40:17 <edwardk> tchakkazzzzz: well, in the Haskell implementation usually. there is no truly symmetric language for practical programming.
17:40:22 <sw17c1> 48 processors, 16 independent cards with 3 procs per
17:40:30 <monochrom> The Road to Imaginary :)
17:40:33 <wagle> ddarius, yeah, sounds right
17:40:34 <sw17c1> these cards are paired and checked
17:40:39 <wolgo> Anyone willing to look at that and tell me how I could improve the readability?
17:40:43 <sw17c1> each of the pairs are paired with another pair and checked
17:40:46 <tchakkazzzzz> edwardk: As well as a lot of arbitrary classes, just to satisfy some otherwise obvious laws.
17:40:48 <wolgo> (if you have time)
17:40:53 <vixey> wolgo: yes
17:40:59 <sw17c1> the hardware is actually quite bullet proof
17:41:08 <wolgo> thanks vixey
17:41:14 <ddarius> wagle: It's an impressive popular science book and well worth reading, but I dislike his love of complex numbers and his Platonism.
17:41:18 <edwardk> tchakkazzzzz: yeah, one reason why i spend the time i'm not spending on category theory working on my toy language with no typeclasses ;)
17:41:20 <wolgo> err, yes it is readable or yes you will look?
17:41:43 <edwardk> i get stuck with the equivalent of newtype wrappers a lot though.
17:41:55 <edwardk> nothing will ever be as pure as one would like
17:42:35 <cpst> ddarius: what's wrong with complex numbers?
17:42:42 <sw17c1> wagle: Rule 95 "Self modifying code is prohibited."
17:42:46 <sw17c1> :)
17:42:57 <ddarius> @google Imaginary numbers are not real
17:42:58 <lambdabot> http://www.mrao.cam.ac.uk/~clifford/introduction/intro/intro.html
17:42:58 <lambdabot> Title: Imaginary Numbers are not Real - the Geometric Algebra of Spacetime
17:43:25 <cpst> oh no, geometric algebra cranks :-D
17:43:50 <wagle> sw17c1, haha..  self-stabilizing is (static) code that recovers from having data corrupted..
17:44:14 <cpst> complex numbers mean the spectrum of every operator is non-empty
17:44:16 <cpst> that's a real plus
17:44:17 <ddarius> @google "Peter Van Roy" Selfman
17:44:18 <lambdabot> http://www.ist-selfman.org/
17:44:38 <Pseudonym> To be fair, David Hestenes is no crank.
17:44:43 <ddarius> cpst: I don't mind complex numbers in math.  I mind uninterpreted ones in physics.
17:44:55 <Pseudonym> He's arguing, and I think quite correctly, that... yeah, what ddarius says.
17:45:27 <Pseudonym> The "shut up and calculate" interpretation of classical physics is unsatisfying.
17:45:28 <sw17c1> wagle: hehe, i know :) i was hoping to find something similar, that's the best i could do
17:45:58 <cpst> Pseudonym: it's just that geometric algebra as a field seems to breed cranks ;-)
17:46:03 <lament> Pseudonym: shut up, and calculate :)
17:46:11 <cpst> Pseudonym: and that's from a friend of mine who wrote one of the textbooks on the subject
17:46:17 <Pseudonym> You're referring to the late Pertti Lounesto?
17:46:23 <cpst> Pseudonym: more than that
17:46:26 <Pseudonym> Amongst others?
17:46:26 <wagle> some recent intro to geometric algebra books are pretty good
17:47:29 <wolgo> Assume that this rule is a portion of a case statement:  ("Simon" || "John" || "Phil") -> putStrLn "Haskell is a great FPL" . I know this does not work. Is there a way to make it work?
17:47:45 <wolgo> on one line
17:47:52 <edwardk> ddarius: i'm currently forming an intuition on something, if Ran g Identity exists then Ran g Identity -| g right? Is there any obvious connection between the monad given by the adjunction g `Comp` Ran g Identity and the monad Ran g g generated by g?
17:47:54 <sw17ch> wolgo: no :(
17:47:57 <wolgo> (sorry for the spam)
17:48:04 <wolgo> sw17c1 oh ok thanks :)
17:48:13 <Pseudonym> wolgo: There are several ways to fix it, though.
17:48:26 <vixey> wolgo: foo`elem`["Simon",...]
17:48:52 <wolgo> ooh I do not know about elem yet
17:48:53 <Pseudonym> If you like pattern matching, you can use a view, which in this case can just be a Bool.
17:49:05 <Pseudonym> likesHaskell "Simon" = True
17:49:05 <wolgo> :t elem
17:49:07 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
17:49:10 <Pseudonym> likesHaskell "John" = True
17:49:14 <Pseudonym> likesHaskell _ = False
17:49:26 <Pseudonym> I left out Phil of brevity, since he's a Java guy now.
17:49:33 <wagle> ah..  a closed world assumption
17:49:43 <ddarius> Pseudonym: He is?  Isn't he a Links guy now?
17:49:43 <Pseudonym> Then: case likesHaskell person of { ... }
17:49:47 <wolgo> Thanks for the alternate view.
17:49:48 <Pseudonym> Oh, you're right.
17:49:54 <wagle> 8)
17:50:07 <Pseudonym> In this case, likesHaskell is a view.
17:50:09 <hpaste>  (anonymous) annotated "do error" with "(no title)" at http://hpaste.org/7797#a2
17:50:24 <Pseudonym> A degenerate example of one, but one nonetheless.
17:50:25 <wolgo> case likesHaskell person of {} what is in the {}? a list of names?
17:50:38 <Pseudonym> No.  likesHaskell returns a Bool.
17:51:12 <Pseudonym> { True -> putStrLn "Haskell is great"; False -> putStrLn "FAIL" }
17:51:14 <monochrom> case l p of { True -> 10; False -> 10+1 }
17:51:43 <hpaste>  (anonymous) annotated "do error" with "(no title)" at http://hpaste.org/7797#a3
17:51:53 <monochrom> > case map id [] of { [] -> "hello"; x:xs -> "hey" }
17:51:55 <lambdabot>  "hello"
17:51:56 <wolgo> so the type I could use is: likesHaskell :: String -> Bool?
17:52:13 <wolgo> I kind of get it
17:52:21 <hpaste>  (anonymous) annotated "do error" with "(no title)" at http://hpaste.org/7797#a4
17:53:47 <Pseudonym> You can imagine that this generalises.
17:53:58 <edwardk> ddarius: i ask because it seems to work for the obvious cases i'm seeing. i.e. ((->)e) `Comp` Ran ((->)e) Identity ~= e -> forall b. (a -> e -> b) -> b while Ran ((->)e) ((->)e) ~= forall b. (a -> e -> b) -> e -> b
17:54:14 <wagle> what kind of crackpottery do you get with geometric algebra?
17:54:18 <Pseudonym> data Relationship = Likes | Dislikes | Indifferent
17:54:20 <Pseudonym> etc
17:54:21 <edwardk> which just has its arguments flipped
17:54:27 <Pseudonym> And then, views can contain data.
17:54:45 <edwardk> wagle: ?
17:55:06 <wagle> <cpst> Pseudonym: it's just that geometric algebra as a field seems to breed cranks ;-)
17:55:14 <edwardk> wagle: whats wrong with geometric algebra other than no one having an intuition for anything in the field. ;)
17:55:25 <edwardk> heh
17:55:45 * edwardk is labeled a crank and disappears in a puff of logic ;)
17:55:47 <Pseudonym> In that respect, it's no worse than Lie algebras, which was the previous cool new formulation ofr physics.
17:55:51 <ddarius> edwardk: If F -| U then F ~ Ran_U Id and UF ~ U Ran_U Id ~ Ran_U U
17:56:09 <wagle> edwardk, oops, sorry about that...
17:56:12 <Pseudonym> Nobody has any intuition for that either.
17:56:14 <edwardk> wagle: sok ;)
17:56:38 <ddarius> So likely, though that result doesn't mean that it is the same monad.
17:56:38 <edwardk> ddarius: thats what i wanted thanks, it seemed to be working in general i just wanted to make sure i wasn't making it up
17:56:41 <Saizan> so, no one has an intuition for anything in physics?
17:56:56 <edwardk> ddarius: just isomorphic
17:57:04 <Pseudonym> Saizan: Probably not, no.
17:57:22 <Pseudonym> Contrary to popular opinion, modern physics isn't hard to understand, it's just hard to believe.
17:57:38 <ddarius> edwardk: It's not that.  You can have multiple monads that share a functor.
17:57:51 <hpaste>  (anonymous) annotated "Is this readable?" with "(no title)" at http://hpaste.org/7801#a1
17:57:53 <edwardk> wagle: to be fair i just use clifford algebras. i think the geometric algebra/calculus folks tend towards the the whackjob end of the spectrum ;)
17:57:56 <edwardk> ddarius: ah true
17:58:13 <hpaste>  (anonymous) annotated "Is this readable?" with "ha" at http://hpaste.org/7801#a2
17:58:27 <ddarius> edwardk: What context do you use Clifford algebras in?
17:58:53 <edwardk> ddarius: i used them for plucker and study constructions for stabbing line problems a while back
17:59:17 <edwardk> with them i can take 100 pages of my thesis designed to be read by people without a Clifford/GA background and express it in a 10 pager ;)
18:00:14 <ddarius> edwardk: That's (part of) why I like GA.  There are many people who use GA in large part because it's a more efficient notation.
18:00:36 <edwardk> its awesome notation, its hard to understand a proof because its so dense though.
18:01:10 <ddarius> edwardk: I tend to find it both much shorter and much more understandable than most approaches.
18:02:25 <ddarius> edwardk: For example, I see no benefit to most of the other (differential) forms of Maxwell's laws.
18:02:33 <edwardk> I agree re GA in the shallow waters, but once you head out towards geometric calculus it starts to feel a little forced to me. maybe thats my own personal version of the 'no one sees a need for a language more powerful than their own' paradox speaking.
18:03:07 <ddarius> edwardk: I very much like the geometric calculus and would find GA much less useful and interesting without it.
18:03:41 <edwardk> ddarius: then maybe i'll give it a shot next time i feel the need to get back in touch with computational geometry
18:04:13 <edwardk> i think mostly in my case it was the wrong tool for the job i was trying to use it for
18:04:20 <ddarius> edwardk: I don't know how much it will benefit you in computational geometry (it could be a lot, I'm just not very familiar with that field.)
18:05:51 <edwardk> i was mostly using clifford algebras and plucker coordinates to solve stabbing line problems as part of a visible surface determination problem in 3d. i designed the algorithm about 13 years ago back when i was still putzing around licensing stuff in the 3d game industry, and when it came time to do my masters thesis i plucked it out of my butt and proved it correct. ;)
18:07:13 <edwardk> along the way i found that plucker coordinates and the coordinate system defined by eduard study back 100 and some odd years ago are the same thing (just different bases) and that for computational geometry problems the study coordinates said some more interesting things
18:07:26 <edwardk> at least they are the same thing in an oriented projective geometry
18:09:54 * edwardk realizes he managed to kill the talk of Haskell on #haskell and apologizes
18:10:29 <ddarius> edwardk: Actually it was me.
18:10:40 <vixey> I'm not quite dead yet
18:10:58 <Saizan> sp, any nice functional ways to store a DAG?
18:11:28 <vixey> [(Node,[Node])] could have cycles
18:11:37 <vixey> not sure that you can express acyclic in the type system
18:12:04 <edwardk> so, so far what i have is that i have a natural transformation from a monad m to Ran m m and one from Ran m m to m `Comp` Ran m Identity, similarly from a comonad w to Lan w w to Lan w Identity `Comp` w
18:12:32 <edwardk> in the case of the free monad on m, we get nice properties that let us improve asymptotic performance by moving to the Ran m m representation
18:12:48 <Saizan> i don't need to enforce that in the type system, i'm more interested in an implementation with good performance, but i guess that depends on the operations i need
18:14:52 <edwardk> i will admit that i don't know in general that its safe to operate on the transformed structure and say that it is equivalent to the one you came from, but we can do something like, ensure that there is a class like FreeLike that lets you say what operations you are allowed to perform on the monad you have, and box it up with a universal quantifier to keep you from doing anything untowards to enforce the monad agnosticism of your code.
18:15:21 <edwardk> er and say that it is equivalent to operating on the one you came from
18:16:40 <edwardk> ah shucks. i'd hoped to get away with something that typeclasses won't let me do.
18:17:38 <edwardk> i'd hoped to be able to say instance (Adjunction f g, MonadReader e f) => MonadReader e (Ran g Identity)  -- but the f doesn't occur in the instance head.
18:17:51 <edwardk> even though f <-> g
18:18:39 <edwardk> you can do it with class associated types though
18:19:57 <hpaste>  jaj pasted "(no title)" at http://hpaste.org/7802
18:20:25 <jaj> jaj: could anybody give me some pointers on this?
18:21:22 <wolgo> So when I use let foo = baz in do stuff I need the do to allow foo to be part of the scope of the do?
18:21:51 * wolgo receives the lack of clarity award.
18:22:09 <vixey> jaj: is that (liftIO $ dbPut) =<< buildQuery or liftIO $ (dbPut =<< buildQuery) ?
18:22:09 <edwardk> wolgo: no
18:22:23 <edwardk> wolgo let foo = baz in return foo works fine too
18:23:12 <edwardk> @undo do x <- foo; return x
18:23:12 <lambdabot> foo >>= \ x -> return x
18:23:42 <edwardk> do just does some stuff to support ;'s as syntactic sugar
18:24:23 <jaj> vixey: the end result should be of type CGI. I tried with brackets in different positions but I always got a type error
18:25:23 <vixey> @undo do dbdata <- buildQuery ; liftIO $ dbPut dbdata
18:25:23 <lambdabot> buildQuery >>= \ dbdata -> liftIO $ dbPut dbdata
18:25:40 <vixey> buildQuery >>= (liftIO $ dbPut)
18:25:47 <vixey> (liftIO $ dbPut) =<< buildQuery
18:25:57 <vixey> oh wait
18:26:00 <vixey> (liftIO . dbPut) =<< buildQuery
18:27:11 <jaj> vixey: oh, it works with function composition, thanks :) although I don't really understand it
18:27:42 <vixey> jaj well does the @undo step make sense?
18:28:13 <jaj> vixey: yes
18:28:18 <vixey> ok so
18:28:23 <vixey> \ dbdata -> liftIO $ dbPut dbdata
18:28:25 <vixey> is the same as
18:28:28 <vixey> \ dbdata -> liftIO (dbPut dbdata)
18:28:34 <edwardk> dbPut takes a value and returns an IO action right?
18:28:40 <vixey> (f . g) x = f (g x)
18:28:43 <jaj> edwardk: yes
18:28:43 <vixey> so
18:28:51 <edwardk> the trick is you wanted buildQuery >>= \c -> liftIO (dbPut c)
18:28:52 <vixey> (liftIO . dbPut)
18:29:08 <edwardk> but \c -> liftIO (dbPut c) can be rewritten to pointfree as liftIO . dbPut
18:29:27 <jaj> ok I get it, thank you both!
18:29:40 <edwardk> @pl \c -> liftIO (dbPut c)
18:29:40 <lambdabot> liftIO . dbPut
18:29:43 <jaj> I tend to get confused with . and $
18:30:08 <jaj> or when I should compose 2 functions and when I should give one as an argument to another
18:30:09 <edwardk> think of $ as starting parentheses that run until they can't gobble up anything else. $ is great at getting rid of parenthesis.
18:31:27 <edwardk> typically when i doubt, write the function, get a bunch of parens, replace parens with $'s where you can, then look to see if you can strip off a parameter by ripping it off the end of the argument list and of the last expression you $'d, by replacing the $ with a ., and rinse wash repeat. then look to see if you have foo $ bar $ baz and you can replace all but the last $ with a .
18:31:29 <vixey> $ is a weird one
18:31:33 <edwardk> after a while it becomes habit
18:31:49 <vixey> f $ x = ($) f x = (($) f) x = f x
18:32:22 <jaj> vixey: yeah it just kind of abuses the fixity of operators
18:32:24 <vixey> it doesn't do anything, it's just the fixity that it's used for
18:33:15 <jaj> edwardk: thank you, I'll store this somewhere so I don't get confused in the future :)
18:33:43 <vixey> :t (.) $ (.)
18:33:44 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
18:33:46 <edwardk> so if you start with \x -> foo (map toQuux (bar (baz x))) go to \x -> foo $ map toQuux $ bar $ baz x    you can replace all but the last $ with . getting \x -> foo . map toQuux . bar $ baz x, then you can realize that you just have a 'tunnel for the x to run through. so you can go to foo . map toQuux . bar . baz and not deal with the name for x.
18:34:29 <monochrom> "f . g . h" is more abstract than "f (g (h x))". How do you make abstract things more natural to you? By practice. Like when you were young you slowly transitted from the concrete "10 apples" to the abstract "10". With practice, there does not exist "this abstraction cannot be natural".
18:36:24 <jaj> yes I think I'm beginning to get a feeling for currying. It's just when all those abstractions add up that it begins to get somewhat complex when you don't have enough practice
18:37:34 <jaj> thank you all for clarifying it to me!
18:37:56 <monochrom> Perhaps adults have much less time for learning than children do.
18:38:50 <mxc> @hoogle arg
18:38:50 <lambdabot> Distribution.Simple.Args :: type Args
18:38:50 <lambdabot> System.Console.GetOpt.ArgOrder :: data ArgOrder a
18:38:50 <lambdabot> System.Console.GetOpt.ArgDescr :: data ArgDescr a
18:46:26 <vixey> @steal
18:46:26 <lambdabot> Maybe you meant: keal spell tell
18:46:29 <vixey> @keal
18:46:29 <lambdabot> 99% of my book has been erased by faulty hdd's
18:46:33 <vixey> @keal
18:46:33 <lambdabot> need 1 to do a while 0 does !a. need 1 to do a while 0 does !a
18:46:41 <edwardk> @pl \e f -> f
18:46:42 <lambdabot> const id
18:46:45 <edwardk> duh
18:46:57 <vixey> flip const = const id
18:46:59 <vixey> ?
18:47:16 <vixey> :t flip const
18:47:18 <lambdabot> forall a b. b -> a -> a
18:47:20 <vixey> :t const id
18:47:21 <lambdabot> forall a b. b -> a -> a
18:47:37 <Pseudonym> ?free flipconst :: b -> a -> a
18:47:37 <lambdabot> g . flipconst x = flipconst (f x) . g
18:54:28 <jaj> @type (flip const) id
18:54:30 <lambdabot> forall a. a -> a
18:57:03 <gwern> @quote
18:57:03 <lambdabot> syntaxfree says: <Bourbaki> the best thing i have ever read in economy is a statement of some guy "i have never met the homo oeconomicus" <syntaxfree> I have never met a catamorphism, either.
18:57:42 <gwern> @quote
18:57:43 <lambdabot> pjd_: says: clearly you lack pessimism
18:58:14 <Saizan> @quote
18:58:14 <lambdabot> nomeata says: Haskell is basically Swiss: Small, Efficient, and it’s fun to explore the higher parts.
18:58:30 <gwern> @quote
18:58:31 <lambdabot> phobes says: Just Nothing :: Maybe Maybe Not
18:58:58 <vixey> @quote
18:58:58 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
18:59:12 <vixey> @quote
18:59:13 <lambdabot> greentea says: it's actually been proved that there a situations in which we can't know whether a person's stupidity will ever terminate.
19:02:04 <gwern> @quote
19:02:04 <lambdabot> newsham says: over here in america we take people with all sorts of names (except mohammed)
19:05:16 <dolio> dons: Have you considered a zipMU for uvector?
19:07:53 <wolgo> So when I define a new data type say data Foo = Bar (Int, Int) do I have to define the function Bar?
19:08:29 <leimy> So I've been reading a little bit about arrows... is the jury still out regarding how general they are compared to monads?
19:08:38 <Zao> wolgo: No, the constructor is defined right there.
19:08:54 <wolgo> Zao: ok
19:08:56 <Zao> wolgo: Some make mkFoo/mkBar functions to make things.
19:09:07 <wolgo> I think I am confused about this type business
19:09:14 <Zao> You can say let x = Bar (42,3) later on.
19:09:15 <ddarius> leimy: No.  The jury was never out.
19:09:20 <chessguy> leimy: arrows are more general than monads
19:09:33 <leimy> ah
19:09:43 <leimy> I've heard some people say arrows aren't worth learning
19:09:54 <leimy> perhaps that's where I got that impression
19:10:00 <leimy> that monads are sufficient
19:10:17 <Zao> After a while, you get into academic language fappery, but I'd say that arrows are useful for everyday work.
19:10:27 <vixey> don't use them if they don't fit your problem
19:10:41 <wolgo> so, when I do let baz = Bar (Int, Int) I get an error
19:11:12 <Zao> You need values, not types.
19:11:17 <wolgo> where Bar (Int, Int) is actually Bar (1,3)
19:11:34 <chessguy> wolgo: a 'let' needs an 'in'
19:11:41 <leimy> Well then it does make sense to learn them I'd say
19:11:47 <leimy> because I won't know where they make sense otherwise.
19:11:49 <chessguy> i.e., let bax = Bar (1,3) in baz
19:11:53 <chessguy> s/z/x
19:13:10 <vixey> @keal
19:13:11 <lambdabot> ghc need to have plugin that allow copy paste in xp
19:14:02 <chessguy> @quote
19:14:02 <lambdabot> ##C++ says: [asking about C++ rules] vincenz: how should we know what those rules mean ?
19:14:43 <vixey> @qoote
19:14:43 <lambdabot> olsner says: hmm, so perl basically has all harmful features ever invented?
19:14:50 <wolgo> hmm
19:14:54 <bd_> Perl doesn't have register_globals!
19:15:01 <bd_> or magic_quotes!
19:15:13 <vixey> C++ Perl and Haskell
19:16:30 <vixey> @protontorpedo
19:16:30 <lambdabot> is there an oo db in haskell?
19:16:38 <chessguy> haha
19:16:45 <vixey> lol
19:16:49 <vixey> @protontorpedo
19:16:50 <lambdabot> im such an asshole
19:17:04 <chessguy> @quote perl
19:17:05 <lambdabot> olsner says: hmm, so perl basically has all harmful features ever invented?
19:17:33 <ddarius> @quote lwall
19:17:33 <lambdabot> No quotes match. That's something I cannot allow to happen.
19:19:04 <wolgo> Sorry for beating a dead horse. So if I have defined a datatype Foo with Foo = Bar (Int, Int) I should be able to show(blah) where blah is of type foo no?
19:19:21 <ddarius> No.
19:19:25 <jaj> wolgo: you need to derive Show
19:20:26 <wolgo> oh snap
19:21:03 <wolgo> Because I am using a pair (Int, Int) I cannot do IO () or anything that is not allowed on my type because it is not of the right type?
19:21:20 <wolgo> well, I didn't define it correctly
19:21:26 <wolgo> right?
19:21:27 <wolgo> haha
19:21:43 <wolgo> Sorry guys I am just trying to get a grasp of this.
19:22:16 <bd_> wolgo: in order to Show, you'd need to tack on 'deriving (Show)' to the definition, or write a Show instance manually.  You can have IO Foo without that. I'm not sure what you mean by 'do IO () [...] on my type'
19:22:22 <SamB> wolgo: pairs are fine for "show"
19:22:30 <SamB> > show (1, 1)
19:22:31 <lambdabot>  "(1,1)"
19:22:37 <pjdelport> :t show
19:22:38 <lambdabot> forall a. (Show a) => a -> String
19:23:06 <bd_> SamB: He's defining a data Foo though, so he'll need a Show Foo instance
19:23:07 <leimy> :t returnA
19:23:09 <lambdabot> forall (a :: * -> * -> *) b. (Arrow a) => a b b
19:23:15 <wolgo> The issue is that I cannot print out my coordinates.
19:23:17 <SamB> bd_: just so
19:23:25 <wolgo> so I need show
19:23:30 <pjdelport> wolgo: you'll learn more about type classes later, but basically, the above means that show takes any type that defines an instance of Show
19:23:43 <jaj> wolgo: you need to append 'deriving Show' to your type definition
19:23:51 <wolgo> ok
19:23:53 <wolgo> I will try that
19:24:19 <pjdelport> there are two ways to do that:  manually, or by deriving, which makes the compiler automatically generate a usable instance for you
19:24:53 <pjdelport> you can use deriving with several of the built-in type classes:  Show, Read, Eq, Ord
19:25:57 <jaj> I think #haskell is one of the most friendly channels around :)
19:25:58 <wolgo> Ahh I see
19:26:03 <bd_> Bounded and Enum work too, if all your constructors have zero arguments
19:26:08 <wolgo> No kidding
19:26:09 <bd_> (IIRC?)
19:26:20 <wolgo> I would have been kicked out of most places by now hehe
19:26:33 <wolgo> Aha
19:26:49 <wolgo> now I get show(quzz)   Point (1,3)
19:26:49 <pjdelport> wolgo: by the way, you don't have to define an entirely new data type in this particular case
19:27:00 <jaj> wolgo: http://en.wikibooks.org/wiki/Haskell/Class_declarations
19:27:44 <pjdelport> wolgo: you can say type "type Point = (Int, Int)", which defines a type synonym
19:28:01 <bd_> pjdelport: but then the compiler won't catch when you mix up Point and Vector :)
19:28:02 <jaj> this will give you a free show by the way :)
19:28:04 <edwardk> @type uncurry id
19:28:05 <lambdabot> forall b c. (b -> c, b) -> c
19:28:16 <edwardk> @type uncurry (flip id)
19:28:18 <lambdabot> forall a c. (a, a -> c) -> c
19:28:21 <pjdelport> bd_: right, depends on what you want :)
19:28:37 <pjdelport> @src String
19:28:38 <lambdabot> type String = [Char]
19:28:43 <wolgo> Ok. So all my types should have Show, Eq and Ord :)
19:29:11 <pjdelport> wolgo: as you can see, the built-in String is actually just a synonym for [Char]
19:29:12 <wolgo> The reason I could not "print" out my coordinates was because I was the incorrect type to "print"
19:30:02 <wolgo> Hey so this will protect me (a noob) from having incorrect types then. Like trying to sum a string and an int.
19:30:19 <edwardk> @type \f -> uncurry (flip f)
19:30:20 <lambdabot> forall b a c. (b -> a -> c) -> (a, b) -> c
19:30:22 <wolgo> Thanks for explaining that to me.
19:30:28 <wolgo> I appreciate it.
19:30:32 <jaj> wolgo: that's what strong typing is all about
19:31:00 <wolgo> Oh okay.
19:31:15 <wolgo> This will be the first language I have used
19:31:20 <wolgo> Well, kind of.
19:31:23 <wolgo> but close enough.
19:31:24 <edwardk> @pl \(e,f) -> (e, g . f)
19:31:24 <lambdabot> second (g .)
19:31:55 <edwardk> @pl \(e,f) -> f (g e)
19:31:55 <lambdabot> uncurry (flip id . g)
19:31:58 <wolgo> jaj: Thanks :)
19:32:18 <wolgo> pjdelport: thanks :)
19:35:59 * edwardk sits here wrestling with obscure instances just in case someone some day really wants to use (,)e `ACompF` (->)e as a context comonad ;)
19:36:22 <vixey> hehe
19:36:33 <vixey> wdat is ACompF though?
19:37:04 <shapr> @yow !
19:37:04 <lambdabot> YOU!!  Give me the CUTEST, PINKEST, most charming little VICTORIAN
19:37:04 <lambdabot> DOLLHOUSE you can find!!  An make it SNAPPY!!
19:37:09 <edwardk> CompF is functor composition. the thing is there are a number of ways to build monads and comonads with functor composition, so i have a bunch of composition newtypes. ACompF is adjunction oriented composition.
19:37:23 <edwardk> so if you use it to compose two halves of an adjunction it gives you a monad or comonad.
19:37:24 <vixey> ohh ok
19:37:29 <vixey> that actually makes sense!
19:37:40 <vixey> cool
19:37:48 <edwardk> as opposed to various PointedCompF's that do composition of monads and pointed endofunctors, etc.
19:37:56 <edwardk> which would otherwise give you an ambiguous instance head
19:38:38 <jaj> @where comonad
19:38:39 <lambdabot> http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
19:38:48 <edwardk> now for MonadState for (->)e `ACompF` (,)e  =)
19:39:12 <monochrom> victorian dollhouse :)
19:39:18 <edwardk> jaj the version i'm working with is in http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/
19:39:18 <lambdabot> http://tinyurl.com/58ftkr
19:40:55 <Saizan> i can imagine an use for a naked state monad, but hardly why i'd like to use one built from ACompF
19:41:07 <jaj> I always feel scared when people start talking about comonads, endofunctors and other strange terms :) I just begin understanding monads somehow
19:41:26 <edwardk> saizan: the main reason at this point has to do with the fact that i can't define adjunctions between monad transformers and comonad transformers.
19:41:41 <vixey> jaj: I think edwardk is breeding some kind of mutants
19:42:53 <jaj> oh right 'bikleisli arrow' is also a scary word :)
19:43:01 <edwardk> i.e. if I have a ReaderT wrapped around something and a CoreaderT wrapped around something else, even though Reader and Coreader are adjoint i can't make an adjunction there. because instead i need something like f1 -| g1, f2 -| g2    then f1 . f2 -| g2 . g1, that means that the adjoint parts are in the wrong positions.
19:43:20 <edwardk> so basically if you want to let adjunctions do a lot of your work for you transformers are the wrong tool
19:43:51 <edwardk> jaj: heh, sok, i've only been here for maybe a couple of years now. it comes fast
19:44:22 <edwardk> jaj endofunctor = Functor, the functor you've come to know and love. nothing scarier than that ;)
19:44:44 <edwardk> endo just means its from the same category onto itself. and in haskell you only deal with one category, the category of types.
19:45:37 <jaj> but I thought Functors were meant to link categories between each other
19:45:54 <jaj> so why would you need functors in haskell? :)
19:46:01 <edwardk> saizan: anyways i went to go and define some relationship between ReaderT and CoreaderT, realized i couldn't, but that i could between composed adjunctions and went from there.
19:46:20 <pjdelport> jaj: the categories don't have to be different
19:46:27 <pjdelport> :t map
19:46:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:46:41 <edwardk> jaj: a functor maps objects to objects and arrows to arrows from one category to another. if they are the same category, then it just maps them onto different objects and arrows.
19:47:03 <edwardk> jaj almost everything in haskell can then be viewed as a Functor. the [] around [a] is actually an instance of functor.
19:47:17 <edwardk> it maps functions on elements, to functions on lists elementwise
19:47:24 <edwardk> > fmap (+1) [2,3,4]
19:47:26 <lambdabot>  [3,4,5]
19:47:40 <jaj> I found out that fmap is quite handy when you try to use some things together which don't really match
19:47:54 <Zao> Functional duct tape?
19:48:02 <edwardk> zao: very much so =)
19:48:17 <jaj> (,) <$> [1,2,3] [1,2,3]
19:48:40 <Saizan> edwardk: and so you're going to use adjunctions in place of transformers? i know almost nothing on adjunctions
19:48:53 <ddarius> type F a = a -> a
19:48:54 <lament> "apply a function to all objects in a container" is far less fancy than "functor"
19:49:17 <lament> this channel just uses fancy terminology to fake knowledge!
19:49:24 <pjdelport> lament: that captures some of the intuition, but not all of it
19:49:26 <edwardk> saizan: not entirely, but i want to have them available as a way to construct a monad/comonad when possible. because in certain contexts you can use them that you can't use transformers.
19:49:29 <wolgo> woot finished with the haskell basics wikibook!
19:49:52 <jaj> instead of writing 'real world haskell' they should be writing 'the haskell dictionary' :)
19:49:56 <edwardk> wolgo: so are you glad you decided to try out haskell?
19:50:09 <pjdelport> :t show `fmap` (+1)
19:50:12 <lambdabot> forall a. (Num a) => a -> String
19:50:47 <jaj> what's the difference between a monad and a comonad?
19:51:13 <pjdelport> jaj: the one is upside down
19:51:39 <wolgo> edwardk: Yeah, it is pretty neat so far. It seems like if I focus on this for a while I will be able to understand other programs and languages. I also like the way the code looks.
19:51:45 * jaj tries to imagine an upside down monad
19:51:59 <ddarius> jaj: You just turn all the arrows around.
19:52:01 <pjdelport> jaj: actually, they are categorical duals of one another
19:52:03 <lament> jaj: one is a weird, strange object that makes no sense unless you're a professional mathematician, and the other is its dual.
19:52:03 <edwardk> jaj well, monads are usually seen as a kind of container that you can make containers of containers and squish down to a new container. i.e. >>= takes a list of a's and a function from an a to a list of b's and generates one list of b's using that function over all the a's so it squishes containers together right?
19:52:11 <wolgo> I think that the layout stuff and types will just take practice.
19:52:42 <pjdelport> jaj: another example of duals are foldr and unfoldr
19:52:53 <edwardk> a comonad works differently. each 'comonadic action' uses the entire comonad to generate a single naked value, then the 'extend' of the comonad, rewraps it up in the comonad so you can keep working with it.
19:52:58 <wolgo> I think I am going to do the elementary haskel tutorial or maybe work through some of this book I have
19:53:01 <edwardk> so while with a monad
19:53:03 <edwardk> @type (>>=)
19:53:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:53:34 <edwardk> in a comonad you have (=>>) :: Comonad w => w a -> (w a -> b) -> w b
19:54:02 <wolgo> First I am going to go participate in the Bestselling MMORPG called Outside!
19:54:04 <wolgo> see you in a few
19:54:37 <lament> i hated Outside
19:54:42 <SamB> man does Agda have a lot of AST types ...
19:54:44 <lament> it just seems so pointless
19:54:50 <lament> pure grind
19:55:10 <pjdelport> jaj: instead of return :: (Monad m) => a -> m a, you have coreturn :: (Comonad w) => w a -> a
19:55:10 <lament> no aim except to get better toys than others
19:55:13 <jaj> edwardk: thank you for the explanation but I think I'm not quite there yet. I'll have to find some 'category theory in a nutshell' guide
19:55:15 <edwardk> jaj: comonads typically make sense when you want 'one thing' to be shared a lot. monads typically make sense when you want to be able to smash similar things together. comonads tend to model things in parallel, monads in sequence. there are a lot of generalities, but really it comes down to looking at the laws for them and seeing what applies where
19:55:19 <pjdelport> (also called extract)
19:55:25 <pjdelport> and so on
19:55:40 <Saizan> i need a little ML help in reading a paper, what's the "val" keyword for? specify fields of a record?
19:55:44 <lament> i, too, would like a "category theory, as practiced in haskell, in a nutshell" guide and i think edwardk should write it. :)
19:56:05 <edwardk> lament: heh, talk dan piponi into writing it with me and you have a deal ;)
19:56:23 <edwardk> otherwise i think i'll need to spend some more time building up content ;)
19:56:31 <jaj> edwardk: like when you'd like to have some kind of environment of values which you can read an write and it keeps the state?
19:57:13 <edwardk> jaj: yeah, state can be implemented in a monad, but its a little funny, the monad becomes a function of the form s -> (a,s), threading the state through the monad
19:57:17 <SamB> lament: ITYM "in the vicinity of"
19:57:32 * pjdelport imagines "Abstract Nonsensical Haskell", to go with "Real World Haskell"
19:57:44 <ddarius> Saizan: It's let
19:57:44 <edwardk> in a comonad you get (s -> a, s) you have a function that takes a state, and a state lying around. when working with the monad you don't have the state at all until you run the monad.
19:58:03 <edwardk> once you have the comonad you can 'toss the wrapper' in this case, just by applying the function to the state.
19:58:25 <edwardk> with the monad you 'can't toss the wrapper' because you haven't filled in all the holes. you need to give it an s to start the chain!
19:58:26 <lament> pjdelport: there's _plenty_ of that
19:58:40 <lament> pjdelport: for example, edwardk's blog
19:58:48 <pjdelport> lament: not in handy book form
19:59:07 <edwardk> so its easy to 'return' into a monad, in the state example you can just define return a = \s -> (a,s)
19:59:27 <edwardk> pjdelport: i've been leaning towards 'Real World Category Theory'
19:59:28 <ddarius> @let extract = head
19:59:29 <lambdabot> Defined.
19:59:35 <edwardk> since thats about as nonsensical of a title you can get.
19:59:43 <pjdelport> edwardk: that would be awesome
20:00:32 <ddarius> @let (=>>) = (. tails) . map
20:00:33 <lambdabot> Defined.
20:00:36 <ddarius> :t (=>>)
20:00:38 <lambdabot> forall a b. ([a] -> b) -> [a] -> [b]
20:00:57 <edwardk> ddarius: the poor man's stream comonad?
20:02:12 <jaj> edwardk: that's interesting. I'm writing a blog software for my website in haskell, nothing really ambitious, just out of fun. And I have some variables that I have to move around the different modules like the currently logged in user. I was thinking about storing this environment in a central place and then read from it when needed. I didn't know how to do it, I thought a State Monad would be appropriate.
20:02:37 <edwardk> a state monad is great for that
20:02:38 <gwern> a Read monad maybe?
20:03:42 <edwardk> you can go a long way in haskell with just a StateT MyState IO monad or something like that especially if you really want to get the goat of the purists around here ;)
20:04:06 <jaj> edwardk: yeah but the State Monad uses the concept that the State is constantly updated and it seems a bit artificial to use a state monad for a state that hardly changes
20:04:11 <pjdelport> @where Reader
20:04:11 <lambdabot> I know nothing about reader.
20:04:19 <edwardk> jaj: if it never changes then use the reader monad
20:05:03 <jaj> I never looked into the reader monad, I'll take a look at it, thanks!
20:05:55 <edwardk> whee netsplit
20:06:52 <jaj> edwardk: from what you said about comonad I thought it may be useful for this kind of environment, though it might be overkil
20:07:32 <pjdelport> > liftA2 (/) sum genericLength $ [1..10]
20:07:33 <lambdabot>  5.5
20:07:34 <edwardk> jaj to be quite honest i'd defer learning comonads for a while. i'm pretty much the guy around here buried in them up to his eyeballs and I have yet to find a compelling reason to use them in day-to-day haskell.
20:08:04 <pjdelport> jaj: that's the simplest example of a reader monad
20:08:30 <pjdelport> (actually just Applicative, in this case)
20:08:51 <Pseudonym> edwardk: I think that there are a lot of useful structures that are naturally comonads, but without a monad-like syntax, they're unnecessarily hard to use.
20:10:54 <Pseudonym> In fact, I'll go out on a limb here and suggest that there's probably a good do-like notation waiting to be found for the arrow W a -> M b that isn't as horrid as normal arrow notation.
20:11:07 <Pseudonym> And monad do-notation will be found to be a special case.
20:11:12 <edwardk> woot, after all that i now got the system to acknowledge that ACompF ((,)e) (ACompF` ((,)e) ((->)e)) is left adjoint to ACompF (ACompF ((->)e) ((,)e)) ((->) e)
20:11:25 <jaj> pjdelport: currently the environment doesn't change after it is defined, however once the software gets a little more complex perhaps there will be cases where I will have to update the environment so I don't know if it's right to assume that it is static. but I will definetely look into the reader monad
20:11:26 <edwardk> Pseudonym: I think the W a -> M b arrow is a slight misstep.
20:11:31 <Pseudonym> Why?
20:11:49 <edwardk> Pseudonym: well, lets take a step back from it, and think about the more general construction.
20:12:00 <pjdelport> jaj: you can run Reader with locally-modified environments
20:12:06 <Pseudonym> OK
20:12:23 <edwardk> one more commonly interesting case is comonads over the kleisli category of some monad, and monads over the cokleisli category of some comonad. both of those look like w a -> m b but act very differently.
20:12:44 <Pseudonym> In what sense are you using "interesting" here?
20:12:51 <Pseudonym> I don't mean to be facetious.
20:12:51 <edwardk> when you talk about them in terms of comonads and monads over a DIFFERENT CATEGORY the distinction is obvious. when you talk about them over distributive laws they are very hard to tell apart.
20:13:18 <Pseudonym> I'm thinking in terms of practical programming issues.
20:13:23 <edwardk> well, a good example off the top of my head is you can take a context comonad and make it memoize if its built over the kleisli IO category.
20:13:35 <Pseudonym> OK, that's a good example.
20:14:00 <edwardk> then you get an environment in which you can run memoized experiments, in which composition of experiments, composes memotable lookups, etc.
20:14:03 <SamB_XP> edwardk: hey, what is your blog anyway?
20:14:11 <edwardk> http://comonad.com/reader
20:14:14 <lambdabot> Title: The Comonad.Reader
20:14:36 <Pseudonym> Hmm.
20:14:44 * SamB_XP is just trying to make sure he's subscribed to the feed...
20:14:56 <edwardk> Pseudonym: and if you look at sigfpe's pointer comonad example, really he just wants a pointer comonad over the IO kleisli category.
20:14:57 <ddarius> jaj: That's one of the benefits of monadic style.  If you change your mind and need a different monad later, it is not very painful (unless you do thing horribly wrong0
20:15:34 <Pseudonym> See, the thing I'm thinking of is just that things passed top-down seem to be more naturally expressed as comonads.
20:15:43 <SamB_XP> unlike most languages, where you have exactly no monads
20:15:52 <Pseudonym> And things passed bottom-up, or state-type things are more naturally expressed as monads.
20:16:00 <Pseudonym> Real programs contain both.
20:16:09 <edwardk> yeah. another good example would be a monadic parser written over the cokleisli category of unique supply.
20:16:21 <Pseudonym> Yes.
20:16:30 <Pseudonym> Unique supply was a specific example that I was thinking of.
20:16:43 <Pseudonym> Also, random numbers, which are essentially unique supply.
20:16:45 <edwardk> yeah
20:16:49 <Pseudonym> Only they may not be unique.
20:17:09 <pjdelport> jaj: if you know State, it's simple to translate to Reader:  get -> ask, gets -> asks
20:17:33 <edwardk> nanevski's modal necessity is a valid indexed comonad except for the fact that haskell lacks an initial object =/ i wasn't able to complete the translation
20:17:45 <edwardk> i could get a 90% hack though if i wanted it
20:17:50 <Pseudonym> The reason I'm thinking of W a -> M b is that I think that the notation would be more natural if (>>>) is (.)
20:18:00 <pjdelport> jaj: there's no put, but instead of modify, you have local
20:18:08 <Pseudonym> Certain complications to do with binding names in arrow notation would be avoided completely.
20:18:16 <edwardk> parallel play games work out fairly naturally as comonadic actions over a comonad with values for each player.
20:18:21 <Pseudonym> But if there's a useful generalisation, I'd be happy with that.
20:18:39 <edwardk> Pseudonym: in 6.9 Control.Category makes (<<<) into (.)
20:19:04 <Pseudonym> Yeah, but I still want do-notation, and I don't want its desugaring to be as horrid as proc.
20:19:27 <edwardk> yeah i'm curious to see if wadler et al's arrow calculus can be turned into nice sugar.
20:19:37 <edwardk> its infinitely preferable to the proc stuff
20:19:45 * Pseudonym nods
20:19:48 <Pseudonym> That's a thought.
20:19:53 <Pseudonym> I didn't think of that as sugar.
20:19:56 <edwardk> if nothing else i'm thinking about it for kata.
20:20:50 <edwardk> of course there i can actually apply kleisli arrows by abusing my overapplied constructors as functions stuff
20:20:55 <edwardk> so its not so rough
20:22:17 <Pseudonym> W a -> M b really needs a name.
20:22:25 <Pseudonym> cokleisli + kleisli = ?
20:22:32 <ddarius> It's similar to a dialgebra
20:22:38 <Pseudonym> dikleisli
20:22:40 <Pseudonym> I like that.
20:22:41 <edwardk> Pseudonym: i use BiKleisli
20:22:42 <ddarius> In fact, it almost certainly is a dialgebra
20:22:50 <edwardk> but yeah its a dialgebra
20:22:52 <saml> M f >>= g  -- g's type is M b.  can I say g is a function that takes b and returns M b?
20:22:59 <edwardk> so its probably more correctly a dikleisli arrow
20:23:15 <Pseudonym> Right.
20:23:29 <edwardk> er its not a dialgebra correctly is it, doesn't have a common carrier a
20:26:39 <edwardk> heh one way to make sure you know your basic category theory, rederive the context comonad 13 different ways, explicitly, implicitly, as a left kan extension of the context comonad along itself, through adjoint composition, ....
20:27:07 <Pseudonym> We're getting into etymology problems.  It's usually not "done" to mix words from different origins.
20:27:16 <Pseudonym> So "bi" would be for Greek words, and "di" for Latin ones.
20:27:21 <Pseudonym> But "algebra" is Arabic.
20:27:39 <edwardk> for now since uustalu and vene and dan piponi all called it a BiKleisli arrow i think i'll stick to the name
20:27:46 <edwardk> it has primacy in literature
20:27:51 <edwardk> no sense adding a competing name
20:28:02 <Pseudonym> ithnan-algebra doesn't really work.
20:30:04 <ddarius> edwardk: Now work from the perspective of Eilenberg-Moore algebras.
20:30:54 <edwardk> ddarius: you're probably right in that setting
20:31:30 * ddarius doesn't know what he is probably right about.
20:32:09 <edwardk> ddarius: i assumed you meant the dialgebra stuff. i basically added it to my 'things to check' list ;)
20:32:36 <ddarius> Oh, well yeah, I'm pretty certain it is relevant there.
20:33:16 <saml> http://haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-State-Lazy.html#(line104)   what is type of k?  how can I call (k a) ?
20:33:17 * edwardk laughs. after i got all through wrestling with it, i realized that i'd already defined the combinators to simplify my function.
20:33:18 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6fo2zn
20:33:44 <edwardk> instance ComonadContext e m => Comonadcontex e (Lan m m) where getC = getC . lowerLan; modifyC f = modifyC f . lowerLan
20:33:44 <vixey> :t (>>=)
20:33:45 <edwardk> done
20:33:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:33:53 <vixey> k is type a -> m b
20:33:54 <edwardk> er ComonadContext
20:34:04 <vixey> has*
20:34:12 <saml> vixey: ah right i thought it was type m b.. and confused
20:34:58 <ddarius> edwardk: You have composition of Kan extensions?
20:35:19 <edwardk> ddarius: i saw i can do it, but haven't added it yet
20:35:30 <hpaste>  (anonymous) annotated "do error" with "aah!" at http://hpaste.org/7797#a5
20:36:40 <edwardk> ddarius: its about 3 items down my list =)
20:36:41 <edwardk> ddarius: Lan f (Lan g h) = Lan (f `o` g) h ?
20:36:51 <ddarius> Pretty much.
20:37:51 <edwardk> i need to go through and make sure that all my lifted MonadFoo and ComonadFoo lifted instances can be correctly lifted into this setting and that i don't conflict with the adjunction stuff, etc.
20:38:03 <edwardk> hence why i'm taking it slow
20:38:25 <edwardk> so much stuff that should just work causes ambiguous instance heads
20:41:11 <edwardk> So Lan f (CoYoneda f) = Lan f (Lan Identity f) = Lan (f `o` Identity) f = Lan f f = f  says i should make sure that all the MonadFoo/ComonadFoo stuff properly propagates up that tower.
20:41:52 <hpaste>  (anonymous) annotated "wget" with "(no title)" at http://hpaste.org/7782#a1
20:43:06 <edwardk> well, at this point just ComonadFoo stuff, since we're talking Lan. and its just stuff that lifts over the context comonad transformer that works over Lan.
20:43:50 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/7802#a1
20:44:01 <edwardk> (I realize i'm developing an exceedingly eccentric view of the source material)
20:44:31 <edwardk> I should fix that before too long, but its useful for now
20:51:19 <luqui> Is there a library somewhere which allows me to use something like IORefs but not in IO (or ST)
20:51:30 <luqui> some sort of 'heterogeneous map'?
20:51:38 <bd_> Map Int Dynamic?
20:51:48 <luqui> well-typed though
20:51:53 <bd_> Then have an incrementing counter to name the type
20:52:16 <ddarius> luqui: HList allows something like that.
20:52:22 <edwardk> lol, the Lan proof above is i believe, the first thing that i have needed the fact that i'm taking Lan along a Functor instance for this entire time.
20:52:31 <bd_> you could make a newRef :: Dynamic t => t -> HMap -> (HMap, Ref t)
20:52:37 <luqui> HList frightens me.  Is it worth looking into?
20:52:48 <luqui> bd_, aye, Dynamic isn't even necessary
20:52:52 <ddarius> luqui: I'd say no.
20:52:59 <ddarius> (Depending on what you are going for.)
20:53:19 <luqui> I have an implementation of this that I was going to polish up and hackageify, but I'd like to use an already existing library if I can
20:53:25 <luqui> if not, I'll just do that :-)
20:53:28 <ddarius> Ultimately, you can't implement an IO/STRef like interface in Haskell without unsafeCoerce.
20:53:37 <luqui> indeed, I need unsafeCoerce
20:53:51 <luqui> but hide it behind a small well-behaved library
20:54:08 <bd_> luqui: it's necessary, as otherwise you could do:   let (_, ref) = newRef () myMap; (m', _) = newRef True myMap; return getRef ref myMap
20:54:15 <bd_> and thus get type unsafeness :)
20:54:49 <bd_> St avoids this by keeping you in a monad, and using type hackery to keep you from carrying the references between monads
20:55:17 <luqui> I key the map on unique; the idea is that each unique is associated with a type
20:55:37 <luqui> so either it will return Nothing or it will return Just (value of correct type)
20:55:41 <bd_> luqui: The thing is, if your map's not in a monad, I can use a stale map, create a new accessor key, and bam.
20:55:51 <luqui> not bam
20:55:58 <luqui> Nothing
20:55:58 <bd_> If you need to dip into IO to create a new Unique though, then what's the point?
20:56:09 <luqui> no, the library dips inside IO
20:56:15 <luqui> the interface doesn't
20:56:26 <luqui> I'll have to double-check that it doesn't violate ref.trans.
20:56:46 <bd_> luqui: unsafePerformIO to get uniques? Yerk, sounds dangerous :/
20:56:46 <luqui> (in fact I think it does, so I'll have to come up with some clever trick)
20:56:51 <luqui> bd_, why?
20:57:16 <bd_> because you'll have let myKey = newKey someMap in ...   and later it'll turn out that's evaluated two times
20:57:29 <bd_> because GHC decided to inline it, or because of thread silliness
20:58:06 <luqui> hmm, this requires thought
20:58:29 <luqui> it's not quite as simplistic as you're making it, but such problems can still be hiding
20:58:45 <bd_> luqui: can you hpaste the type signatures for the public interface or something?
20:58:55 <bd_> I'll see if I can implement unsafeCast with it :D
20:59:01 <edwardk> woot, ok Lan composition complete. next, Ran composition.
20:59:33 <luqui> bd_, ok I'll show you the sketch
20:59:33 <edwardk> ddarius: http://comonad.com/haskell/category-extras/src/Control/Functor/KanExtension.hs bottom of source file
20:59:34 <lambdabot> http://tinyurl.com/5o84vg
21:00:09 <luqui> oh this is why these issues came up:  I implemented it wrapped in a monad
21:00:17 <luqui> so I'll hpaste what I'm planning rather.
21:00:35 <luqui> (monad transformer rather)
21:00:44 <luqui> I guess STT does rather the same thing :-)
21:00:46 <bd_> (I'll be asleep later, but I'm sure someone else will be around :)
21:00:54 <bd_> luqui: the key with St is the extra type variable
21:00:56 <bd_> :t runSt
21:00:59 <lambdabot> Not in scope: `runSt'
21:01:06 <bd_> :t Control.Monad.St.runSt
21:01:08 <lambdabot> Couldn't find qualified module.
21:01:10 <bd_> grr
21:01:19 <bd_> :t Control.Monad.ST.runSt
21:01:21 * luqui understands ST
21:01:22 <lambdabot> Not in scope: `Control.Monad.ST.runSt'
21:01:25 <bd_> bah
21:01:30 <luqui> :t runST
21:01:34 <lambdabot> forall a. (forall s. ST s a) -> a
21:01:38 <bd_> ... orz
21:02:00 <bd_> anyway
21:02:01 <luqui> it is acceptable for this to return Nothing if there is no such key, which I thought made it okay
21:02:07 <luqui> anyway, I'll paste my proposed interface
21:02:27 <bd_> luqui: the problem is what happens if the key has the wrong type - ie, the key thinks it's type A, and the map thinks it's type B
21:02:37 <bd_> because there's a type-B key with the same Unique backing it
21:03:53 <luqui> that's impossible
21:03:58 <luqui> in theory at least
21:04:18 <bd_> luqui: when you start using unsafePerformIO to generate uniques it's hard to guarentee that :)
21:05:10 <luqui> I'm with you there, didn't think of that previously.
21:05:19 <luqui> though hard and impossible are occasionally different
21:06:01 <bd_> well, I'll stop handwaving and wait to see the interface I guess :)
21:08:05 <agentzh> wow...Data.ByteString is amazing...the time taken by my minisql compiler while processing a 139KB sql input reduce from 2.6 sec to 950 ms! :D
21:08:19 <agentzh> *reduced
21:09:54 <wolgo> hi
21:10:03 <edwardk> @pl \r -> Ran (\f -> runRan f (decompose . f) id)
21:10:03 <lambdabot> const (Ran (flip (ap runRan (decompose .)) id))
21:12:54 <hpaste>  luqui pasted "bd_ was right" at http://hpaste.org/7803
21:13:39 <luqui> I don't think there is anything logically wrong with the interface, I just think it is impossible to implement
21:13:59 <leimy> :t >>>
21:14:01 <lambdabot> parse error on input `>>>'
21:14:05 <luqui> :t (>>>)
21:14:06 <leimy> :t (>>>)
21:14:08 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
21:14:09 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
21:14:14 <luqui> echo
21:14:20 <bd_> luqui: lookup k' m vs lookup k m would be interesting
21:14:42 <bd_> luqui: also, make the second "foo" some other type - it's difficult to ensure that you can't cast by writing with one key and reading with the other
21:14:47 <mxc> @src groupBy
21:14:48 <lambdabot> groupBy _  []       =  []
21:14:48 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
21:14:48 <lambdabot>     where (ys,zs) = span (eq x) xs
21:14:54 <mxc> @src span
21:14:55 <leimy> :t (<<<)
21:14:55 <lambdabot> Source not found. Just what do you think you're doing Dave?
21:14:56 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> a b c -> a b d
21:15:11 <mxc> :t span
21:15:13 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
21:15:21 <bd_> luqui: I mean, you can implement this safely with (Int, (Int)Map Int Dynamic) - where the first Int is a counter to hold the next key index
21:15:30 <luqui> bd_, I believe I did ensure that
21:15:38 <luqui> bd_, it's just that I meanwhile violated referential transparency
21:16:26 <luqui> since the two newKeys would come up with different uniques
21:16:35 <bd_> aah
21:16:37 <bd_> yes
21:16:38 <lstor> I have a self-defined list, defined as: data List x = Empty | Cons { car :: x, cdr :: List x }  . I want to be able to display such a list, so I try to write instance (Show a) => Show (List a) where show (Cons x xs) = show x ++ " " ++ show xs, but GHC complains that it gets a List but wants a String.
21:16:38 <luqui> but of course that means that they were different when they should have been the same
21:16:51 <bd_> and GHC can secretly duplicate expressions thanks to ref. transparency
21:16:57 <lstor> How do I fix this? I thought (Show a) implied that this should work?
21:17:02 <bd_> the threaded RTS takes advantage of this fact
21:17:20 <bd_> lstor: parenthesis around (show x), possibly
21:17:38 <lstor> bd_: I already tried that
21:17:39 <luqui> I'll have to do something clever with typeclasses to solve my problem them
21:17:41 <luqui> *then
21:17:45 <lstor> Didn't work :(
21:17:49 <edwardk> ok right kan extension composition complete
21:17:49 <luqui> I don't think this heteromap approach is viable
21:18:01 <bd_> lstor: can you paste your entire code and the error message into hpaste.org?
21:18:10 <lstor> bd_: Yup, one sec
21:19:37 <vixey> lstor: I think the first thing to do is define the fold for you List type
21:21:00 <hpaste>  Lstor pasted "Problem with show" at http://hpaste.org/7804
21:21:55 <vixey> (show x) ++ " " ++ (show xs)
21:21:57 <vixey> is the same as
21:22:02 <vixey> show x ++ " " ++ show xs
21:22:12 <vixey> by the way, since functions application binds tighter than operators
21:22:58 <mxc> ah, groupBy needs the elements sorted first
21:23:04 <lstor> vixey: Yeah, I know. It was just to show that incorporating bd_'s suggestion didn't work :-) (And that I actually listened to the suggestion)
21:23:11 <mxc> or at least, in a,a,a,a,f,f,f,f,c,c,c,b,b,b order
21:23:14 <Cale> lstor: that's the problem in that code?
21:23:23 <Cale> what's*
21:23:43 <mxc> got it
21:24:13 <alson> hey, anyone know how to profile hs-plugins?
21:24:29 <alson> I'm getting :src/System/Plugins/Load.hs:75:7:
21:24:29 <alson>     Could not find module `TcRnMonad':
21:24:29 <alson>       Perhaps you haven't installed the profiling libraries for package ghc-6.8.2?
21:24:29 <alson>       Use -v to see a list of the files searched for.
21:24:39 <lstor> I get this:   Couldn't match expected type `List t' against inferred type `Prelude.String' In the first argument of `(++)', namely `(show x)'
21:24:56 <mxc> rebuilding that library for profiling too
21:24:59 <mxc> did you install via cabal?
21:25:00 <bd_> lstor: You've hidden the prelude's (++), so you're using your own (++) with the prelude's list type.
21:25:03 <alson> no
21:25:10 <lstor> bd_: Ahh
21:25:11 <alson> actually, yes
21:25:17 <alson> [sorry, sleepy]
21:25:23 <bd_> lstor: add a  import qualified Prelude  and use Prelude.++
21:25:33 <Cale> ah, yeah, missed that :)
21:25:37 <lstor> Yeah, got it to work now :)
21:25:38 <lstor> Thank you!
21:25:44 <lstor> Guess I'm too tired ;)
21:25:59 <vixey> ?vixen abstracting the night away
21:26:00 <lambdabot> you sound like an awesome guy... are you single?
21:26:00 <mxc> alson - had that problem yesterdya
21:26:13 <mxc> alson - i think all I did was change the configure command fron
21:26:22 <mxc> runghc Setup.lhs configure
21:26:28 <alson> mxc: looks as though libHSghc needs to be compiled for profiling or HSghc.o needs to be compiled for profiling.
21:26:31 <mxc> to  runghc Setup.lhs configure -p
21:26:53 <mxc> well adding the -p to the libraries I was building with cabal solved it for me
21:27:11 <alson> mxc: I'm doing -   runghc Setup.lhs configure --enable-library-profiling
21:27:21 <mxc> oh
21:27:23 <Saizan> mxc: yeah, but you don't just compile "ghc-6.8.2" with cabal.
21:27:37 <mxc> ok, then your past my level of experience, I didn't realize it was ghc itself
21:27:53 <mxc> sry
21:28:07 <alson> '... -p' throws the same error.
21:28:11 <vixey> > 99^99^99
21:28:24 <lambdabot> Terminated
21:28:25 <edwardk> hrmm is Adjunction f g clearer or f :-| g    ?
21:28:36 <alson> Saizan: I'm rebuilding the Deb package right now
21:28:39 <vixey> looks like a smiley
21:28:44 <edwardk> yeah it does
21:28:46 <wolgo> the do keyword is only for IO actions right?
21:28:47 <vixey> f :-|: g
21:28:48 <edwardk> happy adjunctions
21:28:52 <wolgo> and that is it.
21:28:54 <edwardk> :-|: would work
21:28:58 <alson> mxc: did you get profiling to hs-plugins to work?
21:29:04 <wolgo> :-)
21:29:16 <mxc> not sure what you mean
21:29:24 <edwardk> my only worry would be when i add the category terms, i guess i should stick to adjunction
21:29:26 <Saizan> alson: check if you need to add some configure flags for ghc to enable profiling
21:29:27 <edwardk> talked myself out of it
21:29:41 <mxc> but i gotta run
21:29:42 <alson> mxc: are you able to profile hs-plugins?
21:29:50 <mxc> so will be back in about 90 min
21:29:54 <mxc> didn't try
21:30:02 <mxc> was only profiling some sh1tty code that I wrote
21:30:02 <luqui> wolgo, no, it's for any monad
21:30:29 <mxc> anyway, sry i couldn't be more helpful
21:30:31 <alson> Saizan: I'm just doing a straight build right now.  I'll add the profile flags after the build completes.
21:30:34 <wolgo> Oh ok
21:30:36 <luqui> > do { x <- [1,2,3]; y <- [4,5,6]; return (x,y) }  -- not IO
21:30:37 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
21:30:41 <wolgo> I have not studied monads yet
21:30:43 <mxc> if you want to go nuclear, just clean everyting and rebuild all w/ profiling
21:30:47 <alson> Saizan: do you know what flags are needed to enable profiling on GHC?
21:30:55 <luqui> wolgo, oh, then for your purposes for the short term, yes, for IO actions :-)
21:31:06 <wolgo> How do you all pronounce it. I have been pronouncing it - mah-nad
21:31:23 <luqui> I say MAH-nad.  SPJ and many others say MOE-nad.
21:31:26 <wolgo> or is it moan-ad
21:31:39 <wolgo> ok
21:32:16 <luqui> but when I say the former I get fewer gross puns from peers
21:32:32 <wolgo> I think making a solution to the queens problem would be a good exercise
21:32:41 <wolgo> I think I am going to try that.
21:32:47 <vixey> wolgo: N-queens?
21:32:55 <wolgo> yeah
21:33:04 <luqui> vixey, get as many queens as possible on a chessboard without any threatening any other
21:33:22 <wolgo> It seems like a good noob exercise
21:33:43 <wolgo> I like chess too.
21:33:53 <luqui> yeah, it probably wouldn't be too bad
21:35:15 <wolgo> technically since this is functional though shouldn't I be able to find any solution if one solution works?
21:35:32 <Saizan> alson: no :\
21:35:32 <vixey> wolgo: that doesn't make much logical sense
21:35:44 <luqui> uh.  do you have this confused with logic language.
21:35:57 <alson> Saizan: i assume that this addresses it - http://www.haskell.org/haskellwiki/GHC/As_a_library
21:35:58 <lambdabot> Title: GHC/As a library - HaskellWiki
21:36:14 <wolgo> Probably.
21:36:34 <alson> GHC just takes a long time to build...
21:36:36 <wolgo> I have been reading this book about logic actually. Called "Introduction to First Order Logic"
21:36:54 <wolgo> anyhow, that is off topic
21:36:56 * luqui suspects there are many books by that name
21:37:30 * wolgo confirms luqui's suspicion, 243 at my local borders to be exact. At least in their database.
21:37:44 <Saizan> alson: it can take hours, depending on hardware
21:38:05 <Saizan> alson: so you should just build it with the GhcCompilerWays=p
21:38:14 <Saizan> already set.
21:38:23 <alson> Saizan: yeah, I'd forgotten how delightful building GHC is...
21:38:32 <alson> Saizan: what do you mean 'already set'?
21:39:07 <wolgo> Does anyone here use hugs?
21:39:37 <alson> Saizan: never mind.  I see the line got cut off...
21:39:42 <edwardk> only on my nieces and nephews ;)
21:39:49 <wolgo> edwardk haha
21:40:03 <vixey> @src guard
21:40:04 <lambdabot> guard True  =  return ()
21:40:04 <lambdabot> guard False =  mzero
21:41:34 <sjanssen> wolgo: in my experience, very few serious Haskellers use Hugs
21:42:15 <wolgo> sjanssen oh ok
21:42:27 <wolgo> I wonder why.
21:42:35 <wolgo> I guess I will find out later
21:42:50 <mwc> wolgo: it seems more of the cutting edge features (associated types, gadts, etc) come to GHC first
21:43:02 <mwc> wolgo: there's also the performance aspect, when you get to that point
21:43:02 <edwardk> GHC gets a lot more developer attention
21:43:05 <EvilTerran> ghci supports more extensions and provides more technical error messages
21:43:10 <alson> Argh... looks as though building with GhcCompilerWays is broken...
21:43:18 <EvilTerran> and ghc-compiled code is a *lot* faster than interpreted code
21:43:46 <vixey> wolgo: Let's compare solutions when we are both finished
21:44:07 <sjanssen> wolgo: in addition to the reasons others have mentioned, GHC's error messages tend to be much better
21:44:22 <wolgo> Okay. It will take me more time. I am still learning.
21:44:34 <wolgo> Oh yeah.
21:44:46 <wolgo> It seems like most of the errors are pretty good.
21:45:05 <cjs> It's hard to compete with ghc.
21:46:34 <sjanssen> how could it?  GHC has three people (more if you include interns) paid full time to hack on it, while Hugs seems to have less than one person hacking on it
21:51:21 <alson> Ah.  need to use GhcLibWays=p  (instead of GhcCompilerWays=p)
21:51:26 <cjs> Hmm. And if we compare that to the number of people paid full time to hack on gcc?
21:52:09 <sjanssen> gcc only half counts, due to -fasm
21:53:42 <EvilTerran> gesundheit
21:54:01 <hpaste>  vicky pasted "a solution to N-queens" at http://hpaste.org/7805
21:54:53 <vixey> :(
21:54:57 <vixey> It's wrong
22:12:26 <hpaste>  vicky annotated "a solution to N-queens" with "(fixed)" at http://hpaste.org/7805#a1
22:15:38 <thetallguy> interesting style, null case first, then semi-colon, then general case
22:16:42 <bd_> where's that new array library?
22:23:56 <vixey> I really dislike 'acceptable'
22:24:19 <vixey> cannot think how to express it better though
22:24:34 <dolio> http://code.haskell.org/~dons/code/uvector I think.
22:24:34 <lambdabot> Title: Index of /~dons/code/uvector
22:26:22 <bd_> dolio: thanks
22:30:53 <dolio> If you want to test out my sorting for the mutable vectors, it's at http://code.haskell.org/~dolio/usort
22:30:53 <lambdabot> Title: Index of /~dolio/usort
22:33:57 <Trinithis> @pl \w -> \_ -> extract w
22:33:58 <lambdabot> const . extract
22:34:20 <dolio> Although it isn't a library really, I guess.
22:34:38 <dolio> Not cabalized, at least.
22:36:59 <olsner> hmm, someone said something to me
22:38:27 <olsner> aha, I was just quoted :)
22:44:40 <thetallguy> vixey: peaceful
22:44:47 <thetallguy> no queens fighting
22:57:11 <pip> Hello,does Haskell support concurrence ?
22:57:16 <Zao> Quite.
22:57:20 <pip> : )
22:58:13 <pip> Zao, Does it support being a first programming language for a young eager mind ?
22:58:43 <Zao> Quite possibly, given the right learning resources.
22:58:47 <wolgo> Hey I have a question about this wiki book
22:59:32 <wolgo> Why does it want you to do multiplucation recursively for instance mult x y = (mult x (y -1)) + x
22:59:44 <dejones> pip: Are you a bot?  Didn't you ask these same exact questions recently?
22:59:46 <wolgo> I would just do mult x y = x * y and be done with it
23:00:06 <Cale> wolgo: What if multiplication wasn't defined at all yet?
23:00:13 <TSC> Probably just to demonstrate recursion
23:00:29 <wolgo> Well then you could define it in terms of addition
23:00:29 <pip> dejones, I'm going to write a bot in Haskell : )
23:00:34 <Cale> right :)
23:00:43 <wolgo> So that is the reason.
23:00:51 <wolgo> I do not know why that bothers me.
23:00:54 <Cale> Similarly, you can define addition in terms of the successor function
23:01:07 <wolgo> But let it be dually noted that it does bother me.
23:01:18 <Cale> conoted.
23:01:26 <dejones> lol
23:01:46 <wolgo> what like addition x y = (addition x (y - 1)) x ?
23:01:50 <dejones> Cale: corecursively noted?
23:01:51 <dejones> ;)
23:02:25 <Cale> > let add 0 y = y; add (x+1) y = succ (add x y) in add 4 5
23:02:26 <lambdabot>  Parse error in pattern at "in" (column 47)
23:02:29 <pip> dejones, Have you tried such a bot who can write another smarter bot ?
23:02:33 <Cale> oh, right, no n+k patterns :)
23:02:40 <Cale> > let add 0 y = y; add x y = succ (add (x-1) y) in add 4 5
23:02:41 <lambdabot>  9
23:03:01 <dejones> pip: I've not tried writing any bots.
23:03:01 <EvilTerran> church numerals!
23:03:07 <wolgo> hmm
23:03:26 <Cale> wolgo: That looks nicer if you use the datatype   data Nat = Zero | Succ Nat
23:03:32 <wolgo> succ means to do the next of something?
23:03:36 <Cale> yeah
23:03:41 <dejones> :t succ
23:03:43 <lambdabot> forall a. (Enum a) => a -> a
23:03:58 <vixey> successor
23:03:58 <Cale> add Zero y = y; add (Succ x) y = Succ (add x y)
23:04:01 <dejones> I find the :type so helpful.  :)
23:04:07 <wolgo> I dont know what Enum is yet.
23:04:14 <vixey> @Src Enum
23:04:14 <lambdabot> Maybe you meant: rc src
23:04:20 <vixey> yes I meant src
23:04:25 <wolgo> A collection of types?
23:04:25 <dons> cute, http://reddit.com/info/6kc7i/comments/ :)
23:04:29 <dons> the lazy universe
23:04:43 <Cale> wolgo: yeah
23:04:58 <Cale> types whose members can be enumerated, roughly
23:05:11 <Cale> There are some funky instances which don't really fit in so well... like Float
23:05:21 <Cale> But otherwise, it's for enumerated things.
23:05:57 <wolgo> what is x in succ (x - 1) y
23:06:02 <wolgo> in your example?
23:06:04 <wolgo> 3?
23:06:25 <wolgo> :t succ
23:06:27 <lambdabot> forall a. (Enum a) => a -> a
23:07:29 <thetallguy> dons: isn't that sort of the tree falls in the forest => nobody hears model?
23:08:09 <Cale> wolgo: well, I applied it to 4...
23:08:18 <Cale> wolgo: er..
23:08:31 <Cale> let add 0 y = y; add x y = succ (add (x-1) y) in add 4 5
23:08:45 <Cale> add 4 5 -> succ (add (4-1) 5)
23:09:02 <Cale> -> succ (add 3 5)
23:09:14 <Cale> -> succ (succ (add (3-1) 5))
23:09:20 <Cale> -> succ (succ (add 2 5))
23:09:29 <Cale> -> succ (succ (succ (add (2-1) 5)))
23:09:33 <Cale> -> succ (succ (succ (add 1 5)))
23:09:41 <dons> thetallguy: hmm :)
23:09:42 <Cale> -> succ (succ (succ (succ (add (1-1) 5))))
23:09:42 <wolgo> ohhhh
23:09:43 <thetallguy> no, I changed my mind.
23:09:46 <Cale> -> succ (succ (succ (succ (add 0 5))))
23:09:47 <dons> the zen of laziness eh?
23:09:52 <Cale> -> succ (succ (succ (succ 5)))
23:10:04 <dons> the tree doesn't fall till someone needs to see the result
23:10:22 <Taggnostr> hey Cale
23:10:23 <dejones> Cale: That's a fun example of recursion with succ.  :)
23:10:23 <wolgo> This exposes a lack of understanding
23:10:27 <wolgo> Thanks cale
23:10:31 <vixey> yeah that's why the framerate slows down when lots is happening
23:10:36 * Cale wonders if black holes are where the universe waited too long to evaluate an expression and had a stack overflow.
23:10:44 <dons> heh.
23:10:45 <Cale> wolgo: no problem
23:10:48 <Cale> Taggnostr: hey
23:11:03 <vixey> doesn't te G machine have black holes
23:11:14 <dons> maybe they're just black holes..
23:11:18 <dons> > let x = x in x
23:11:34 <lambdabot>  thread killed
23:11:39 <thetallguy> wikipedia says nobody knows who first proposed the falling tree
23:11:45 <Cale> In the G machine, black holes are what currently evaluating expressions point to before their values are set.
23:12:13 <Cale> (or at least the STG machine, I haven't really looked at the original G machine)
23:12:23 <vixey> grr
23:12:34 <vixey> I really want to print out some code to get an overview of
23:12:40 <vixey> so annoying to not be able to do that
23:13:31 <thetallguy> dons: months ago you mentioned a paper on  some structures that were less...sequential than monads, that were being used to improve parallelism.  Does that ring a bell?
23:14:05 <Cale> thetallguy: Maybe parallel arrays?
23:14:12 <ski_> applicative functors ?
23:14:15 <quicksilver> Cale: someone was having difficultly yesterday compiling hs-plugins
23:14:18 <thetallguy> Cale: doubtful
23:14:20 <EvilTerran> hey, who was it who was asking about arranging the natural numbers in an unbounded binary tree a while back?
23:14:23 <thetallguy> ski: definitely not
23:14:43 <quicksilver> Cale: was getting Data.Array.Base errors but I thought that was supposed to be fixed ages ago
23:14:49 <quicksilver> Cale: (darcs hs-plugins, GHC 6.8.2)
23:14:57 <Cale> quicksilver: They probably had the wrong version.
23:15:09 * quicksilver nods
23:15:14 <quicksilver> @where hs-plugins
23:15:14 <lambdabot> http://code.haskell.org/~dons/code/hs-plugins
23:15:17 <quicksilver> that's the right one?
23:15:28 <Cale> yes
23:15:50 <thetallguy> Perhaps the universe IS lazy and Heisenberg found the limit of the computational resources.
23:15:51 <quicksilver> that's what they said they had. Odd.
23:16:02 <Cale> To check if a version is the wrong one, just ask them if they have a Language directory under src/
23:16:10 <Cale> If they do, it's the old version.
23:16:37 <thetallguy> There's just no enough bandwidth to get you the answer in time.
23:16:59 * EvilTerran opens his log for #haskell and makes his RAM scream
23:17:34 <dolio> Cale: What's the point of the O(log n) array argument? Don't sweat log factors?
23:17:47 <thetallguy> EvilTerran: we were playing with something like that for the rationals last night.  Is that what you mean?
23:17:52 <Cale> dolio: In large part, yes.
23:18:28 <EvilTerran> aha: "Apr 27 20:19:05 <cpoucet>	edwardk: how do I distribute the natural numbers over a binary tree <edwardk>	as in so that you get a unique number in each node?"
23:18:30 <Cale> dolio: It just annoys me that people claim array indexing is O(1) when they don't claim indexing into a binary balanced tree is O(1) as well, when it succumbs to the exact same argument.
23:18:39 <EvilTerran> ... that's quite a lot longer ago than i thought
23:18:49 <EvilTerran> ?seen cpoucet
23:18:49 <lambdabot> Last time I saw cpoucet was when I left ##logic, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07, #haskell-hac4, #
23:18:49 <lambdabot> haskell-overflow, #haskell-soc, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #
23:18:49 <lambdabot> jtiger, #parrot, #perl6, #rosettacode, #scala, #scannedinavian, #thunks, #unicycling and #xmonad 13d 8h 13m 20s ago, and .
23:18:54 <EvilTerran> eek
23:19:05 * thetallguy likes the fact that wikipedia illustrated the 'If a tree falls in the forest...' article with a picture of a tree.
23:19:55 <vixey> what is the sound of one thunk clapping ?
23:20:07 <thetallguy> thunk
23:20:14 <thetallguy> too easy
23:20:58 <vixey> If a lambda falls in an oasis and no-ones there's to see it will it ever reach weak head normal form
23:21:05 <vixey> :[
23:21:12 <vixey> lambda is already WHNF isn't it
23:21:30 <EvilTerran> anyway, i solved it. given "data Tree = Branch Tree Integer Tree", take "build n = Branch (build $ 2*n) n (build $ 2*n + 1)", and (build 1) is your tree
23:21:54 <vixey> hey EvilTerran: been reading PAIP?
23:22:18 <EvilTerran> to find a specific number, convert it into binary, and take each digit less significant than the most significant 1, in order. for a 0, follow the left branch. for a 1, follow the right branch.
23:22:22 <ski_> @wtf PAIP
23:22:22 <lambdabot> Maybe you meant: bf ft wn
23:22:40 <vixey> Paradaigms of AI Programming (looks like it's being translated into Haskell)
23:22:41 <EvilTerran> vixey, i have no idea what that is, so probably not
23:22:49 <ski_> ty
23:22:53 <thetallguy> vixey: yes, when a coconut falls on it, causing a weakened skull
23:22:56 <dolio> Oh, really?
23:23:12 <EvilTerran> this particular solution came to me on my own when drifting down the cherwell on a punt :D
23:23:13 <vixey> dolio: I meant by EvilTerran but it seems not the case
23:23:16 <vixey> sorry
23:23:23 <dolio> Oh, okay. :)
23:23:23 <EvilTerran> vixey, :P
23:23:47 <dolio> I would have had to go to comp.lang.lisp and sneer at the people there with Jon Harrop or something.
23:25:41 <dons> OT, but might be inspiring, knowing some of the people in here.... http://www.dyers.org/blog/beards/beard-types/
23:25:42 <lambdabot> Title: 1e The Quest For Every Beard Type 3 - 15 Jon Dyer&#8217;s Blog 4a
23:26:49 <dolio> Wow, those are impressive.
23:27:09 <thetallguy> dons: I like the Federation Standard.  Instantly recognizable
23:27:32 <dons> oh, also awesome, http://www.dyers.org/blog/beards/beard-type-chart/
23:27:33 <lambdabot> Title: 19 Expanded Beard Type Chart 3 - 15 Jon Dyer&#8217;s Blog 4a
23:28:10 <thetallguy> I wonder if he wrote a program to optimize growing/shaving
23:29:04 <vixey> EvilTerran: What question was that a solution to?
23:29:50 <thetallguy> vixey: ﻿EvilTerran: hey, who was it who was asking about arranging the natural numbers in an unbounded binary tree a while back?
23:30:01 <vixey> not me
23:30:08 <vixey> We talked about the rationals though
23:30:22 <thetallguy> Note the double reference
23:30:28 <vixey> ?
23:30:53 <thetallguy> That's what EvilTerran was working on
23:31:23 <wolgo> How the hell is this multiplying? There is no * mult x y = (mult x (y - 1)) + x
23:31:35 <wolgo> I do not see why I keep getting the right answer
23:31:43 <vixey> wolgo: 6 * 3 = 6 + 6 + 6
23:32:02 <wolgo> I understand that
23:32:08 <wolgo> I do not understand the execution
23:32:14 <vixey> wolgo: 6 * 3 = 6 * 2 + 6
23:32:40 <vixey> mult 6 3 = mult 6 2 + 6
23:32:58 <wolgo> Where is the multiplication implied?
23:33:07 <ski_> > let mult x 0 = 0; mult x y = mult x (y - 1) + x  in  mult 6 x
23:33:11 <vixey> It's not impled, it's defined
23:33:17 <lambdabot>  Exception: Time limit exceeded
23:33:23 <ski_> er
23:33:29 <ski_> > let mult x 0 = 0; mult x y = mult x (y - 1) + x  in  mult x 3  -- of course
23:33:31 <lambdabot>  0 + x + x + x
23:33:34 <Cale> wolgo: want me to carry out the execution?
23:33:57 <vixey> > let mult x 0 = 0; mult x y = mult x (y - 1) + x  in  mult x 89
23:33:57 <ski_> > let mult x 0 = 0; mult x y = x + mult x (y - 1)  in  mult x 3  -- of course
23:33:58 <wolgo> If you have a minute please do.
23:33:59 <lambdabot>  0 + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + ...
23:34:00 <lambdabot>  x + (x + (x + 0))
23:34:08 <EvilTerran> > let mult x y = sum (replicate x y) in 6 `mult` 3
23:34:09 <lambdabot>  18
23:34:10 <wolgo> there are no *'s
23:34:24 <vixey> wolgo: * is just a name
23:34:46 <ski_> wolgo : that's because the standard `(*)' in *not* called, here
23:35:04 <Cale> mult 6 3 -> mult 6 (3-1) + 6 -> mult 6 2 + 6 -> mult 6 (2-1) + 6 + 6 -> mult 6 1 + 6 + 6 -> mult 6 0 + 6 + 6 + 6 -> 0 + 6 + 6 + 6
23:35:21 <ski_> (s/->/=/ :)
23:35:58 <Cale> The reason that the equation is correct is that  (x * (y-1)) + x = (x*y - x) + x = x * y
23:36:24 <wolgo> so mult 6 is chopped off after the second argument reaches 0?
23:36:35 <Cale> So it expresses the product in terms of a product of smaller numbers
23:37:22 <Cale> and so eventually it'll reach the mult x 0 case, at which point it will not recurse any further, giving 0
23:38:24 <wolgo> So when it has nothing to recurse on it will give a 0
23:39:07 * edwardk sighs. finally done adding all the misc. higher order functor instances for the mtl
23:39:26 <Cale> Yeah, because 0 multiplied by anything is 0, and it has an equation for that as a special case.
23:39:38 <edwardk> not sure what you'd want to swap out the inner monad in a monad transformer with, but you can do it now coz the types say you can ;)
23:40:05 <roconnor> edwardk: aren't we switching to monadLib?
23:40:37 <edwardk> roconnor: *shrug* the instances are in category-extras
23:40:55 <edwardk> i hadn't really heard much of the mtl vs. monadLib noise
23:41:17 <wolgo> I need to map this out on paper
23:44:21 <edwardk> roconnor: hrmm, monadlib doesn't appear to suck ;)
23:44:40 <edwardk> i'll have to rename some stuff if i want to work with it though
23:45:16 <wolgo> Ok
23:45:22 <wolgo> so factorial n = n
23:45:26 <wolgo> doh
23:46:14 <Cale> I think monadLib should flip the pairs in State and Writer while there's still time :)
23:46:26 <wolgo> factorial 3 = 3 * factorial ( 3 - 1 ) -> factorial 2 = 2 * factorial ( 2 - 1) -> factorial 1 = factorial 0 = 1 so 3 * 2 * 1 * 1
23:47:10 <vixey> @index identifier
23:47:10 <roconnor> Cale: make a fork
23:47:10 <lambdabot> Text.Html, Text.ParserCombinators.Parsec.Token
23:47:16 <roconnor> I'll pull from you
23:47:27 <paolino> Cale , in the runners ?
23:47:31 <edwardk> the main name i don't like in there is 'Lift'
23:47:34 <ski_> @type State
23:47:37 <lambdabot> forall s a. (s -> (a, s)) -> State s a
23:47:39 <Cale> paolino: yeah.
23:47:46 <Cale> paolino: and the constructors
23:47:47 <ski_> Cale : why flip ?
23:47:57 <Cale> (,) s  is a functor
23:48:06 <Cale> rather, an instance of Functor
23:48:24 <ski_> er, right
23:48:51 <edwardk> if you flip them then you get the ((,)s) ((->)s) adjunction deriving the definition exactly.
23:49:32 <Cale> Are the data constructors in monadLib not exposed?
23:49:33 <ski_> *nod*
23:49:52 <ski_> (for some reason i was reading the type the opposite way of what i thought)
23:51:22 <Cale> Wow, the library doesn't expose the data constructors for the various monads...
23:51:54 <edwardk> thats one way to keep people from tying themselves to your implementation details i guess
23:52:32 <ski_> x0 : t0 , G |- e : t1
23:52:43 <ski_> ----------------------
23:52:51 <ski_> G |- \x0. e : t0 -> t1
23:52:57 <ski_> as god intended it !
23:53:43 <Cale> It should at least expose equivalents, I think.
23:54:48 <Cale> I've found idioms like  runFoo . f . Foo  rather handy.
23:55:35 <ski_> withFoo = (runFoo .) . (. Foo)  -- ?
23:55:54 <vixey> @index haskell
23:55:54 <lambdabot> Text.ParserCombinators.Parsec.Language
23:56:00 * EvilTerran notes that that use of (.) sections is remarkably legible to him
23:56:57 <paolino> @pl \f -> runFoo . f . Foo
23:56:57 <lambdabot> (runFoo .) . (. Foo)
23:57:29 <EvilTerran> ?unpl (. Foo) . (runFoo .)
23:57:29 <lambdabot> (\ e h -> runFoo (e ((Foo) h)))
23:57:34 <EvilTerran> eeew
23:58:04 <EvilTerran> ?. pl unpl (. Foo) . (runFoo .)
23:58:04 <lambdabot> (runFoo .) . (. Foo)
23:58:16 <EvilTerran> iiinteresting. ish.
23:58:21 <paolino> glom
23:58:24 <tieTYT2> i'm rewriting list functions as an exercise
23:58:34 <tieTYT2> this seems to work, i'm wondering if it's how you guys would do it: myLast x = if length(x) == 1 then head(x) else myLast(tail x)
23:58:37 <ski_> are `pl' and `unpl' pseudo-inverses ?
23:58:53 <EvilTerran> tieTYT2, not exactly, no
23:58:54 <Cale> tieTYT2: length is something to be avoided
23:59:00 <Cale> tieTYT2: Use pattern matching :)
23:59:02 <roconnor> ski_: is the term adjuctions?
23:59:11 <tieTYT2> Cale: i tried that route first, but failed
23:59:11 <Cale> myLast [x] = x
23:59:12 <tieTYT2> i'll try again
23:59:13 <EvilTerran> tieTYT2, in general, what is "myLast [x]"?
23:59:21 <EvilTerran> ah, Cale gave the game away =/
23:59:25 <tieTYT2> yeah :P
23:59:33 <EvilTerran> bad cale! no cookie!
23:59:38 <tieTYT2> ok but i wouldn't have thought of that myself
