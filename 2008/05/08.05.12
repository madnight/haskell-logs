00:00:55 <maltem> encryptio: also, cabal-install maintains a cache in ~/.cabal
00:06:22 <encryptio> maltem: thanks
00:08:41 <mxc> @hoogle weekend
00:08:43 <lambdabot> No matches found
00:08:45 <mxc> @hoogle Saturday
00:08:45 <lambdabot> System.Time.Saturday :: Day
00:18:12 <mxc> @hoogle week
00:18:12 <lambdabot> Data.Time.Calendar.WeekDate :: module
00:18:12 <lambdabot> Data.Time.Calendar.OrdinalDate.mondayStartWeek :: Day -> (Int, Int)
00:18:12 <lambdabot> Data.Time.Calendar.OrdinalDate.sundayStartWeek :: Day -> (Int, Int)
00:18:13 <mxc> @hoogle weekday
00:18:14 <lambdabot> No matches found
00:41:11 <dmwit> This code is impenetrable.
00:41:16 <dmwit> What was I thinking?
00:49:20 <mxc> @hoogle double
00:49:20 <lambdabot> Language.Haskell.TH.PprLib.double :: Double -> Doc
00:49:20 <lambdabot> Prelude.Double :: data Double
00:49:20 <lambdabot> GHC.Exts.Double :: data Double
00:49:31 <mxc> what code?
00:49:49 <dmwit> Some code I wrote a while ago for solving Sudoku.
00:49:56 <dmwit> I was considering going back and finishing it.
00:50:18 <dmwit> But it's taking me a while to read it and see what I've already done. =P
00:50:20 <mxc> hm
00:50:30 <mxc> how cna I get a double out of an int
00:50:35 <mxc> fromInt?
00:50:41 <mxc> @hoogle fromInt
00:50:41 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
00:50:41 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
00:51:34 <ski_> `fromIntegral', yes
00:53:08 <dancor> > (fromInteger (2 :: Int)) + 0.5
00:53:11 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
00:53:17 <dancor> > (fromIntegral (2 :: Int)) + 0.5
00:53:19 <lambdabot>  2.5
00:53:29 <dancor> > (fromInt (2 :: Int)) + 0.5
00:53:30 <lambdabot>   Not in scope: `fromInt'
01:19:39 <boegel> gwern: ping
01:27:31 <scook0> is there an implementation floating around for an "ordered set", i.e. where elements remember the order in which they were inserted?
01:27:54 <flux> it's called a list?-)
01:27:56 <dmwit> [], or ([], Set) for efficiency.
01:29:21 <bd_> Or Data.Seq
01:30:05 <scook0> I could implement one; I'm just trying to save myself the effort by finding a nicely-packaged implementation
01:30:10 <hexpuem> is there a 3 state version of left / right?
01:30:30 <dmwit> scook0: No, there is no implementation.
01:30:50 <dmwit> hexpuem: Well, (Either (Either a b) c). ;-)  Or write your own data declaration.
01:31:06 <hexpuem> k haha
01:32:14 <dmwit> :t sortBy
01:32:16 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
01:32:49 <dmwit> Is there a sortBy' :: (Ord b) => (a -> b) -> [a] -> [a] ?
01:34:00 <dmwit> :t \f xs -> map fst . sortBy snd . zip xs . map f $ xs
01:34:01 <lambdabot>     Occurs check: cannot construct the infinite type:
01:34:01 <lambdabot>       b = (a, b) -> Ordering
01:34:01 <lambdabot>     Probable cause: `snd' is applied to too many arguments
01:34:10 <funktio> sortBy (compare `on` f)   where f :: a -> b
01:34:19 <dmwit> :t \f xs -> map fst . sortBy (comparing snd) . zip xs . map f $ xs
01:34:21 <lambdabot> forall a b. (Ord b) => (a -> b) -> [a] -> [a]
01:34:41 <scook0> map (f *** id) >>> sortBy (compare `on` fst) >>> map snd
01:34:46 <dmwit> funktio: Yeah, but suppose the function were expensive, and I only want to calculate it once for each element.
01:34:49 <scook0> (if f is expensive)
01:35:07 <dmwit> Oh, (f *** id) is a cute way to say it.
01:35:18 <scook0> wait, make that f &&& id
01:35:24 <dmwit> yeha
01:35:26 <scook0> *** is wrong here
01:35:42 <funktio> dmwit: ah, ok
01:36:28 * dmwit adds another definition to module Dmwit
01:37:12 <ToRA> compare `on` = comparing
01:37:13 <scook0> map/sortBy/map is the Haskell equivalent of a Schwartzian transform :)
01:37:27 <dmwit> It's DSU from Python.
01:37:33 <dmwit> decorate-sort-undecorate
02:06:14 <dmwit> ?pl flip (any S.null . A.elems .)
02:06:14 <lambdabot> flip (any S.null . (A.elems .))
02:06:31 <maltem> DSU could be called sortOn in Haskell
02:07:16 <quicksilver> the correct name is 'Schwartzian Transform' :P
02:07:58 <maltem> quicksilver, I mean, as a name for the function, in anology to sortBy and on
02:08:38 <dmwit> It was known as DSU before it was known as the Schwartzian Transform.
02:08:43 <quicksilver> I was joking.
02:08:58 <maltem> alright alright :)
02:08:59 <quicksilver> However, wikipedia makes the canonical name of the page Schwartzian, and makes DSU merely a redirect.
02:09:06 <quicksilver> so clearly I'm right, even though joking :)
02:09:12 <dmwit> =)
02:17:03 <mxc> anyone know of any examples of lazy maps for pseudo-dynamic programming?
02:18:57 <dmwit> Data.Map is lazy in the values.
02:19:13 <dmwit> It's hard to do better than that, since you kind of need to build the spine of the tree for your map.
02:19:59 <Beelsebob> well, you could always use a list instead
02:20:06 <Beelsebob> and then you don't need to evaluate the spine
02:20:08 <Beelsebob> but you're way slower
02:20:21 <Beelsebob> or rather, you don't always need to evaluate the spine
02:21:19 <Beelsebob> you also don't need to evaluate the key until you actually do a search
02:22:15 <Saizan_> you can go crazy with a lazy immutable trie
02:22:58 <Saizan_> http://sigfpe.blogspot.com/2007/09/tries-and-their-derivatives_08.html
02:22:59 <lambdabot> Title: A Neighborhood of Infinity: Tries and their Derivatives, http://tinyurl.com/yw3gll
02:28:21 <mxc> yeah, but sicne I suck at haskell, I was trying to think about how to even go about creating one
02:28:39 <mxc> i'm basically looking for a 'pure' dynamic programming solution
02:29:12 <dmwit> Heh, we were discussing this yesterday.
02:29:24 <mxc> i brought it up a while ago
02:29:29 <dmwit> Somebody was maintaining that dynamic programming was pretty much un-Haskellic.
02:29:36 <mxc> started a threat on how you should be able to get 'free' memoization
02:29:43 <mxc> er thread
02:29:52 <mxc> at the compiler level
02:29:54 <dmwit> Have you seen this -cafe post?
02:29:59 <dmwit> http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737
02:30:01 <lambdabot> Title: Gmane -- Mail To News And Back Again
02:30:07 <dmwit> It's very nearly compiler-level memoization.
02:31:07 <dmwit> dynamicFix :: Ix a => (a, a) -> ((a -> b) -> (a -> b)) -> (a -> b)
02:31:18 <dmwit> Compare with fix :: (a -> a) -> a
02:45:50 <mxc> @hoogle array
02:45:50 <lambdabot> Data.Array.IArray.array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
02:45:50 <lambdabot> Foreign.Marshal.Array :: module
02:45:50 <lambdabot> Data.Array :: module
02:48:26 <mxc> @hoogle fix
02:48:26 <lambdabot> Data.Function.fix :: (a -> a) -> a
02:48:27 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
02:48:27 <lambdabot> Control.Monad.Fix :: module
02:49:37 <mxc> i've seen that array example, I'm wondering if there is a general way to do that for maps
02:49:57 <mxc> since the array method seems to be based on list comprehensions, which dont really exists for maps
02:55:20 <Baughn> Can I embed ghci (the interpreter, anyhow) in another haskell program somehow? Is there an api?
03:03:54 <Baughn> Ah. I found something.
03:07:20 <cjs> Can parsec parse non-strings? E.g., ByteStrings?
03:07:56 <Saizan_> cjs: parsec 3.0 can
03:08:16 <dmwit> ?pl \f -> (forcedGroup . f) board
03:08:16 <lambdabot> flip (forcedGroup .) board
03:09:14 <cjs> Hm. Where does one get that? And, given that I've got pretty simple parsing needs, is it worth dragging it in, or should I just write what I need?
03:09:51 <dmwit> cjs: Parsec (any version) can parse lists of any token type.
03:09:58 <dmwit> Dunno where to get Parsec 3.0, though.
03:10:19 <dmwit> Anecdotally, ByteString doesn't give much boost for Parsec.
03:10:23 <cjs> Yes, but a ByteString isn't a list.
03:10:32 <dmwit> I know.
03:10:50 <cjs> Really? I'd imagine one would get a fair amount, assuming you read your inputs as ByteString in the first place. Saves you unpacking them all.
03:11:45 <dmwit> May 11 23:42:31 <olsner>        I think I tried parsec-bytestring-ing my C lexer, it gave something like 10% iirc (i.e. no amazing orders-of-magnitude improvements, but definitely better)
03:12:09 <cjs> Especially if you're actually ignoring a lot of the data you're parsing, or re-using it just as ByteStrings.
03:12:35 <quicksilver> that's one anecdote.
03:12:43 <dmwit> right
03:12:52 <quicksilver> According to another anecdote it was a speed increase of 666% and it cured his grandfather's gout.
03:12:55 <quicksilver> YMMV>
03:13:06 <dmwit> Anecdotally, caveat lector, etc. etc.
03:13:25 <cjs> I'm definitely going to have a number of cases where I need to parse the data to a minimal degree, but just to skip past it and ignore it.
03:14:07 <cjs> Other cases include extracting some ByteStrings from a ByteString read from the network, and shipping them straight back out over the network. I'd think that staying away from Strings there would help.
03:14:22 <Twey> quicksilver: Hahaha
03:14:30 <cjs> Anyway, so no ByteString parsing for Parsec 2?
03:14:45 <quicksilver> correct.
03:14:47 <quicksilver> AFAIK.
03:15:02 <cjs> Well, good thing I've got my copy of Hutton handy. :-)
03:15:40 <quicksilver> bytestring parsec ought to yield pretty large memory use improvements.
03:15:48 <quicksilver> even if the speed improvments aren't.
03:16:00 <Baughn> cjs: For my parsing of TIFF files, where I do in fact ignore/pass-through a lot of the data, I got a speed improvement of 2.3x
03:16:19 <cjs> You think? I'd imagine that it's handing back a lot of tails of lists, which wouldn't need a copy, right?
03:16:33 <cjs> Baughn: what do you use for parsing?
03:17:32 <quicksilver> cjs: btu lists have an overhead of 24 bytes per byte.
03:17:38 <quicksilver> cjs: that's pretty big, no? :)
03:18:57 <cjs> Ouch!
03:19:11 <Baughn> *24 bytes*? Are you serious?
03:19:25 <Baughn> Oh, three pointers? That would make it 12 bytes here. :P
03:19:42 <cjs> 6, on my PDP-11!
03:19:56 <Baughn> cjs: Um? I'm parsing tiff files, as I said. mmap the file, wrap it in a bytestring, parse...
03:20:11 <quicksilver> that's on top of the fact that Char is bigger than one byte, itself.
03:20:11 <cjs> Oh, you wrote your own parser.
03:20:18 <Baughn> cjs: Actually, at the moment I'm only extracting the tags and ignoring the image data
03:20:46 <Baughn> Which would explain the speedup. With parsing mmaped bytestrings, it's a zero-copy scheme.
03:21:07 <quicksilver> copying is faster than most people think :)
03:21:19 <quicksilver> the real time savings are in not building up complex heap structures and then GC'ing them.
03:21:21 <Baughn> Call it an exercise. :P
03:21:37 <Baughn> It's also 1.3x faster than the C version, so I'm happy
03:21:56 <cjs> Baughn: is this open source code? Or viewable, anyway?
03:22:26 <cjs> quicksilver: Maybe building up complex heap structures and GC'ing them is just *really* slow.
03:22:29 <mxc> @src foldl
03:22:29 <lambdabot> foldl f z []     = z
03:22:29 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
03:22:31 <mxc> @src foldr
03:22:31 <lambdabot> foldr f z []     = z
03:22:31 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
03:22:33 <Baughn> cjs: I'd have to ask. It's for a uni assignment of sorts.
03:23:06 <cjs> Or I'll take any other examples. Mine is definitely not a uni assignment.
03:26:55 <quicksilver> cjs: well, yes, it is sort of. But the point is that copying chunks is a common operation and it's really fast.
03:27:02 <quicksilver> cjs: especially relative to file IO time.
03:27:20 <quicksilver> if you're reading from disk anyway, the cost of a second in memory copy is tiny, relative to that.
03:27:39 <Baughn> Sure. Bulk copy rates on modern memory chips are approaching L2 cache speeds, which is quite impressive really
03:27:57 <mbz> hello everybody
03:28:09 <cjs> quicksilver: But, if you need to do a lot of processing, that can eat up the CPU you want to use for that processing.
03:28:52 <cjs> I agree that if you're, e.g., reading data from a network and writing it to disk, or vice versa, a few memory copies probably aren't going to make much difference.
03:29:41 <quicksilver> the other upshot of this is that haskell is impressively fast now, even with obvious deficiencies in its code generation.
03:29:48 <quicksilver> how fast will it be with the new codegen plans? :)
03:37:35 <Bonus> if I read a file
03:37:41 <Bonus> and then make a list of it and run sort on that list
03:37:46 <Bonus> will it load the whole file into memory?
03:37:54 <Baughn> Yes. Has to, to sort it.
03:38:03 <Baughn> If that's an issue, you can implement some sort of filesort
03:38:23 <mxc> so i'm in singapore and this isn't an option, but I think smoking marijuana could make one a seriously better haskell programmer
03:38:29 <mxc> at least in the beginning
03:38:33 <Baughn> Bonus: Oh, but don't use that to force it into memory. There are better ways.
03:38:35 <mxc> and I mean that in all honesty
03:39:03 <mxc> like I think i'm just grokking dynamic programming and lazy maps, and I think couple of hits could have helped
03:39:28 <mxc> need to 'free my mind' and just think like "what if i dont do dynamic programming, I just program and it just happens"
03:39:36 <mxc> thats my random thought for the day
03:52:42 <lilac> mxc: pff, up to evaluation order, dynamic programming is just a fancy way of saying memoization, which is just a fancy way of saying use a cache.
03:54:16 <lilac> mxc: the interesting part is finding a solution which is amenable to a cache with a high enough hit-rate. for which a couple of hits might help but might hinder...
03:56:16 <Saizan_> dynamic programming is about sharing computation of subproblems instead of plain recomputing them as a naive divide et impera would do, memoization is just a sledgehammer for this purpouse
03:57:09 <visq> > ((2::Int64) * (-2147483648))
03:57:13 <lambdabot>  0
03:58:46 <mux> > (2::Word64) * (-2147483648)
03:59:01 <lambdabot>  thread killed
03:59:09 <mux> > (maxBound,maxBound) :: (Word64,Int64)
03:59:19 <lambdabot>  (18446744073709551615,9223372036854775807)
03:59:45 <mbz> what are you doin?
03:59:55 <visq> is this a bug ?
04:02:05 <mux> it does look like a bug
04:02:05 <funktio> I think Words are unsigned and Ints signed
04:02:19 <mux> I can reproduce this in ghci
04:02:22 <funktio> (-42,-42) :: (Word64,Int64)
04:02:26 <funktio> > (-42,-42) :: (Word64,Int64)
04:02:29 <lambdabot>  (18446744073709551574,-42)
04:02:43 <mux> yes of course
04:03:02 <mux> but that doesn't explain why ghc would return 0 for (-2^31) * 2 :: Int64
04:05:32 <mux> ah
04:05:40 <mux> only seems to happen with ghci, not when I compile the code
04:06:10 <mux> that's definitely weird, probably there's a bug in ghci that causes this
04:06:46 <Saizan> \bot doesn't use ghci though
04:07:03 <mux> it's nearly the same though
04:07:11 <mux> it uses the GHC API
04:09:26 <scook0> anyone know the O() time of (GHC's) Prelude.sortBy?
04:09:38 <Saizan> n log n
04:09:46 <scook0> cool
04:09:56 <scook0> is that an upper bound?
04:10:33 <scook0> (not that I really care that much)
04:11:22 <mercury^> the bot is much faster than ghci :)
04:12:03 <Saizan> it's a mergesort, so yes iirc
04:14:43 <visq> The bug isn't ghci specific on my machine
04:15:00 <mehrheit> Sunsim/Bodies.hs:92:46: Not in scope: `'
04:15:07 <mehrheit> how does one correct such errors?
04:15:14 <visq> C (using int64_t) gives the correct result
04:16:00 <mxc> any idea why Debug.Trace.trace would print out its first argument but not the second?
04:17:42 <mux> mxc: because that's how it is supposed to work :)
04:17:58 <mux> the first argument is the string to print, the second argument is the value returned to continue with the computation
04:18:01 <mux> :t trace
04:18:03 <mxc> oh, okk, then i'm an idiot
04:18:04 <lambdabot> Not in scope: `trace'
04:18:05 <cjs> mxc: You wrap it around a function where you want to trace something, and it returns the value of that function.
04:18:07 <mxc> i thought i printed both
04:18:10 <mxc> my bad
04:18:19 <mux> mxc: nah, these kind of things are surprising at first when you're used to FP
04:18:23 <mxc> was like (Show a) => String -> a -> a
04:18:31 <mux> yep
04:18:33 <cjs> s/used/not used/, mux, I think.
04:18:33 <mxc> well, strict FP
04:18:38 <mxc> been doing ocaml for years
04:18:40 <mux> :t Debug.Trace.trace
04:18:42 <lambdabot> forall a. String -> a -> a
04:18:43 <mux> cjs: err, yes
04:19:05 <mux> same goes for seq
04:19:07 <mux> :t seq
04:19:08 <lambdabot> forall a t. a -> t -> t
04:19:10 <cjs> Now WTF did my IRC client decide to colour both mux and mxc green? It's confusing.
04:20:47 <mux> > trace "QUIT" 42
04:20:47 <lambdabot>   Not in scope: `trace'
04:20:54 <mux> > Debug.Trace.trace "QUIT" 42
04:20:54 <lambdabot>   Not in scope: `Debug.Trace.trace'
04:20:59 <mux> hopefully :)
04:22:36 <visq> http://hpaste.org/7560
04:23:09 <mux> visq: you can reproduce that with compiled code?
04:23:45 <mux> I tried to, but wether I used -O0, -O or -O2, I got the correct results
04:25:52 <visq> Yes, look at the paste.
04:26:08 <visq> I'm on a 32-bit machine.
04:26:52 <mux> me too
04:28:55 <visq> The Glorious Glasgow Haskell Compilation System, version 6.8.2
04:29:06 <mux> same here
04:29:24 <visq> darwin 9.2.2, i386
04:29:26 <mux> you definitely need to open a GHC ticket about this, I think
04:29:29 <quicksilver> darwin9/i386 is not a true 32 bit machine, is it?
04:29:38 <quicksilver> aren't intel core duos 64 bit capable?
04:29:43 <matthew_-> yes
04:29:46 <matthew_-> em64t
04:29:51 <quicksilver> it's still a bug, though.
04:29:54 <mux> quicksilver: that's even more reasons for this code not to fail !
04:29:55 <cjs> I thought only core 2 duos were 64-bit capable.
04:30:11 <quicksilver> it's a bug either way, anyhow.
04:30:18 <visq> I have an old mac book pro; core duo
04:30:26 <mxc> @src foldl
04:30:27 <lambdabot> foldl f z []     = z
04:30:27 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:30:27 <mxc> @src foldr
04:30:28 <lambdabot> foldr f z []     = z
04:30:28 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:30:29 <matthew_-> cjs: oh, sorry, you may be right. I always forget to distinguish between the two
04:30:30 <Deewiant> exact same results here
04:30:41 <Deewiant> athlon64 on 32-bit windows XP
04:31:12 <mux> I'm baffled at it returning 0 in ghci, and the correct result when I compile the code, hmm
04:34:02 <cjs> So I'm doing the Hutton Functional Parsers thing here, and I've got at the moment "type Parser a = ByteString -> Either String (a, ByteString)". How do I set this up so I can use do-notation?
04:34:21 <cjs> It's frustrating; I'm sure I'd figured this out a few weeks ago.
04:35:02 <quicksilver> mux, visq: do you think it could be this: http://hackage.haskell.org/trac/ghc/ticket/2223
04:35:03 <lambdabot> Title: #2223 (Int64.toInteger) - GHC - Trac
04:35:20 <ibid> cjs: you probably need to make that a newtype, and then you need to make it an instance of Monad
04:35:44 <Baughn> http://hpaste.org/7561 <-- So I've got a test opengl program. It works fine when compiled, showing a teapot, but when called inside ghci (just :main), it doesn't.
04:35:49 <Baughn> Any ideas why?
04:35:51 <cjs> Oh, I can make a newtype into an instance?
04:35:57 <ibid> cjs: yes
04:36:06 <quicksilver> cjs: yes. Or you could just use the MTL recipe for that
04:36:11 <cjs> But I can't use the "->" in the newtype.
04:36:17 <ibid> cjs: of course you can
04:36:18 <cjs> MTL recipe?
04:36:28 <quicksilver> ErrorT String (State Bytestring a)
04:36:29 <quicksilver> I think?
04:36:34 <ibid> cjs: just remember to parenthesize properly
04:36:38 <quicksilver> @unmtl ErrorT String (State Bytestring) a
04:36:38 <lambdabot> Bytestring -> (Either String a, Bytestring)
04:36:44 <quicksilver> oops,
04:36:58 <quicksilver> @unmtl StateT Bytestring  (ErrorT String) a
04:36:58 <lambdabot> err: `ErrorT String (a, Bytestring)' is not applied to enough arguments.
04:37:00 <cjs> Really? "newtype Parser a = ByteString -> Either String (a, ByteString)" gives me "parse error on input `->'".
04:37:12 <quicksilver> you forgot to name the constructor
04:37:19 <cjs> Bah. I always do that. Thanks.
04:37:52 <quicksilver> @unmtl StateT Bytestring (ErrorT String) a
04:37:53 <lambdabot> err: `ErrorT String (a, Bytestring)' is not applied to enough arguments.
04:38:01 <Saizan> "Either"
04:38:11 <cjs> What's the syntax for naming the constructor in this case?
04:38:26 <ibid> cjs: newtype parser a = Parse (Bytestring -> ...)
04:38:28 <quicksilver> @unmtl StateT Bytestring (Either String) a
04:38:28 <lambdabot> Bytestring -> Either String (a, Bytestring)
04:38:32 <quicksilver> Saizan: thanks.
04:38:33 <ibid> cjs: expand the ellipsis :)
04:38:40 <ibid> cjs: and fix my typos
04:38:48 <quicksilver> cjs: the point I'm making is that what you want is already in the standard MTL family.
04:38:55 <quicksilver> cjs: that saves you having to write your own monad instance
04:39:04 <quicksilver> and gets you the handy MonadState and MonadError instances.
04:39:07 <quicksilver> On the other hand...
04:39:07 <Saizan> cjs: if it's not for fun there are already parsec combinators libraries that work with ByteString
04:39:14 <quicksilver> writing this stuff yourself can be instructive
04:39:15 <ibid> cjs: yeah, fot real work, use the MTL
04:39:15 <Saizan> "parse"
04:39:16 <quicksilver> so that's fine too :)
04:39:20 <visq> quicksilver: seems right, as (-4294967296) = 0xffffffff00000000
04:39:31 <ibid> cjs, quicksilver: but for learning purposes, writing it yourself is commendable :)
04:39:32 <cjs> Instructive is helpful.
04:40:02 <quicksilver> agreed
04:40:05 <cjs> I probably only have to write it myself eight or ten times before I get it, too.
04:40:07 <quicksilver> writing your own monad instance is a good thing to do.
04:40:27 <ibid> cjs: did you get the newtype right?
04:41:17 <cjs> Yes. But now I'm loaded up with other errors.
04:41:50 <cjs> Presumably because I have to pattern match with the type constructor to undo it in all of my parser functions, now.
04:42:10 <ibid> yes
04:44:51 <cjs> Hm. I'm not clear on how to deal with this, actually, because I no longer have arguments, as it were. I used to have "p :: Parser (); p bs = ..." where ... mucked about with bs, and returned a Right ((), L.drop 1 bs).
04:45:19 <Saizan> p = Parser $ \bs -> ...
04:46:14 <ibid> yeah, newtype makes it messier
04:47:36 <Saizan> the hope is that you can write a minimal set of combinators and build everything else from that without having to deal with the newtype contructor
04:50:12 <cjs> I've also lost my ability to run the darn thing.
04:53:38 <cjs> So "parse p bs = p bs" won't work any more; what's up with that?
04:54:24 <cjs> Because of the newtype, a "ByteString -> Either String (a, ByteString)" is no longer the same type as a "Parser a", of course.
04:54:48 <mux> don't you have to just add a Parser constructor around your expression?
04:56:03 <cjs> How, exactly?
04:56:26 <mux> parse p bs = Parser (p bs) or something
04:56:31 <mux> I haven't been following that whole discussion
04:56:50 <mux> but if you went and changed to a newtype, you may have to wrap stuff with your newtype constructor
04:57:39 <wjt> runParser (Parser p) bs = p bs
04:57:53 <wjt> adding runStateT or whatever if you defined it that way
04:58:38 <cjs> Yes, I just got that. Thanks.
04:59:55 <quicksilver> cjs: the general technique is to create a small number of combinators which futz around with the innards
05:00:02 <quicksilver> (your lefts and rights and drops)
05:00:09 <quicksilver> and then everything else just uses them
05:00:42 <cjs> Yes, I think that might be managable.
05:02:05 <mux> Control.Applicative comes to mind
05:09:26 <cjs> Hm. So what's got me all confused here is that last time I tried this, I wasn't using a type that was a function.
05:10:25 <cjs> So, "return" returns what? A "Parser a"?
05:11:01 <cjs> Agh, it's forgetting that damn type constructor again.
05:11:58 <quicksilver> well you return the thing (the 'a')
05:12:05 <quicksilver> and what you get from the return is Parser a
05:12:09 <quicksilver> return :: a -> Parser a
05:12:59 <cjs> Yes. I've got that working now. There's hope for me yet. Now on to (>>=).
05:15:23 <mux> monadic parsers are overrated
05:16:32 <cjs> Not as a learning experience! :-)
05:16:44 <mux> heh, agreed
05:18:08 <ibid> yeah, i find that do notation actually makes parsers less readable :)
05:18:17 <ibid> (i like my own interface better)
05:18:38 <quicksilver> monadic parsers /= do notation, though.
05:19:12 <quicksilver> do { keyword "if" ; e1 <- expr ; keyword "then" ; e2 <- expr; keyword "fi" ; return (If e1 e2) }
05:19:14 <mux> I find my parsec parsers are more readable once rewritten to use Control.Applicative
05:19:15 <quicksilver> is not too bad, though.
05:19:40 <quicksilver> mux: how would you write that example?
05:20:50 <mux> mmm If <$> (expr <* keyword "then") <*> (expr <* keyword "fi")
05:20:53 <mux> I suppose
05:21:23 <mux> err
05:21:33 <mux> missing the first keyword
05:21:50 <mux> mmm If <$> (keyword "if" *> expr <* keyword "then") <*> (expr <* keyword "fi")
05:22:16 <ibid> my preferred interface is used in eg. http://www.mit.jyu.fi/antkaij/opetus/fo-1/2008/luennot/08/Parser.hs
05:22:18 <lambdabot> http://tinyurl.com/5wvq55
05:22:34 <ibid> (a trivial implementation at http://www.mit.jyu.fi/antkaij/opetus/fo-1/2008/luennot/08/ParComp.hs)
05:22:35 <lambdabot> http://tinyurl.com/682sk8
05:23:19 <ibid> the advantage is that parsers look just like the attribute grammars, only less beautiful
05:24:14 <cpoucet> ibid: use something less opaque than @ :)
05:25:04 <cpoucet> ibid: what is this "get Caret" ?
05:25:08 <cpoucet> ibid: you're using a lexer too?
05:25:42 <quicksilver> mux: yes I suppose that is quite nice although I suppose it takes a while to get used to the notions of *> and <*
05:26:07 <mux> quicksilver: it only annoyed me because I'm still not always sure where to put parenthesis and stuff
05:26:10 * quicksilver nods
05:26:13 <cpoucet> ibid: another suggestions..
05:26:23 <ibid> cpoucet: that particular example uses a lexer, yes
05:26:27 <cpoucet> ibid: why not simply do (ini Lexer)  "Kw String"
05:26:47 <cpoucet> so you can have 'KW "if"'
05:27:12 <mux> quicksilver: the thing is that we typically don't need to feed the results of a parser to another one, so >>= is nearly useless and always used to pass to "return" because we want to parse other things in between, where <* and >* feel more intuittive
05:27:33 <quicksilver> ibid's version is very monadic.
05:27:36 <ibid> cpoucet: i prefer to use tokens that don't require complex comparison :)
05:27:44 <ibid> quicksilver: it's not at all monadic
05:28:03 <quicksilver> I should be more careful with my words.
05:28:08 <quicksilver> it's very like the monadic style.
05:28:24 <ibid> quicksilver: it's similar, yes
05:28:27 <quicksilver> it's just you have to write these annoying (\a _ b _ c -> If a b c) things
05:28:40 <quicksilver> instead of putting labels in the grammer
05:28:48 <quicksilver> as in (a <- expr) ... (b <- expr)
05:28:50 <cpoucet> it is, you have try @|
05:28:54 <quicksilver> that's the main thing do notation gives you.
05:28:56 <ibid> quicksilver: in monadic style, you'd just intersperse the lambdas inside the grammar. imo that's less elegant
05:28:58 <cpoucet> and you have sequenceing @>
05:29:00 * Philippa suspects we could use sugar for Applicatives that does binding as well
05:29:28 <quicksilver> the advantage of do notation (for grammars) is the ability to label the results in the grammar
05:29:31 <ibid> quicksilver: and that's the precise thing i hate about do notation in parsing context
05:29:38 <quicksilver> I used to write grammers like ibid's (in ML)
05:29:39 <Philippa> I've a design in mind, and it'd make the result generation much neater
05:29:50 <quicksilver> and I got pissed off with all the (\a _ b _ c -> If a b c) noise
05:30:01 <quicksilver> although to be fair, I was using ML, so it was worse
05:30:02 <Philippa> ibid: I find the pointless alternatives pretty unpleasant when trying to understand the results as opposed to the grammar
05:30:04 <ibid> quicksilver: it makes the connection with the grammar less obvious
05:30:16 <quicksilver> it was \((((a,_),b),_),c) -> If a b c )
05:30:22 <ibid> Philippa: econtext?
05:30:38 <quicksilver> ibid: how does adding a few labels make the connection less obvious?
05:30:46 <quicksilver> as long as the label noise is fairly minimal
05:30:49 <Philippa> ibid: once you're generating a non-trivial result, you've got to either go about it in a pointless manner or use labels
05:30:51 <ibid> quicksilver: they interfere with the grammar
05:30:52 <quicksilver> (and I don't think a<- is very noisy)
05:30:59 <quicksilver> yes, they do, slightly.
05:31:01 <Philippa> the pointless approach seriously obscures the semantics
05:31:14 <quicksilver> but so do the @@ lines every other line :)
05:31:19 <ibid> Philippa: i still don't understand what your point is wrt to my code
05:31:20 <quicksilver> you have to choose your poison.
05:31:32 <Philippa> ibid: my point's about do notation and the like
05:31:38 <ibid> quicksilver: i could have them on the same lines, except the lines are too long for most editors
05:31:39 <quicksilver> mux: I like that explanation of the issue, by the way.
05:31:46 <ibid> quicksilver: but the @@ stuff are attributes
05:32:08 <quicksilver> and you need to count along to work out which is which
05:32:12 <quicksilver> quite annoying IMO.
05:32:27 <ibid> quicksilver: and a standard (mis)feature of this sort of a grammar
05:33:07 <Philippa> having to specify the semantics separately leads to its own engineering problems anyway
05:33:29 <Philippa> here, attributes're just another way of attacking the same problem - not everyone's using CFGs to start with
05:34:03 <ibid> (of course, it's not a general attribute grammar, there's just one synthetic attribute and that's it, of course the attribute can be structured)
05:34:44 <Philippa> *nod*
05:35:06 <ibid> cpoucet: as to the naming of the operators, i'm not wedded to it, but @ was available, and having a common prefix is useful :)
05:35:10 <Philippa> I do think it's normally a good idea to factor out any processing on intermediate parsing results rather than do it in place - or else do it via a combinator that explains what's happening
05:35:44 <ibid> yes, anything more complex than creating a parse tree node should be moved out
05:36:42 <Philippa> but not necessarily any further than the bottom of the same parser. It's not infrequent for a little minor preprocessing to be necessary, and having to write a pseudo-CST->AST pass afterwards is a pessimisation IMO
05:37:04 <ibid> that's what i mean
05:37:20 <Philippa> FWIW, what I'm suggesting with applicatives'd force that
05:37:23 <ibid> move out by naming a fucntion, or postpone into an AST->x pass
05:37:28 <quicksilver> one of the things which haskell really sucks at is the kind of partial types you get in multi-pass AST algorithms.
05:37:42 <quicksilver> like a type for 'AST except the binary fixities haven't been resolved'
05:37:43 <Philippa> not necessarily by naming a function. Just by having the final return ... become let ... in return ...
05:37:47 <quicksilver> and then another pass for when they have
05:37:55 <Philippa> quicksilver: yeah, that aggravates me no end
05:38:16 <ibid> Philippa: okay, so you're saying that sort of processing should *not* be moved out
05:38:17 <quicksilver> that encourages all kinds of unpleasant hacks to stop types multiplyig
05:38:22 <quicksilver> (let's just parse to sexps!)
05:38:32 <Philippa> ibid: I'm saying it should be moved out of the 'grammar' part of the parser
05:38:44 <cpoucet> quicksilver: what you want is a partially typed tree :)
05:38:55 <ibid> Philippa: which sounds to me like you want to name it as a function :)
05:39:15 <Philippa> ibid: why on earth would I want to be forced to do that for one-offs?
05:39:27 <ibid> Philippa: nobody's forcing anything
05:39:37 <Philippa> especially one-offs that I don't have a more descriptive name for than the code itself?
05:39:49 <ibid> Philippa: but large semantic actions obscure the grammar
05:40:03 <Philippa> ...no, not the way I'm proposing
05:40:08 <ddarius> cpoucet: What he wants is refinement types.
05:40:32 <Philippa> the way I'm proposing, the semantic action part comes lexically after the grammar
05:40:40 <ibid> Philippa: they do, if i understand your proposal right. though we probably have different aesthetic standards here
05:40:55 <ibid> Philippa: no it doesn't, if you're putting lets before the return
05:41:06 <cpoucet> ddarius: sounds like subtyping
05:41:13 <Philippa> I'm not though
05:41:17 <Philippa> I'm putting one let around it
05:41:17 <ibid> Philippa: the grammar contains more than the one alternative :)
05:41:23 <ibid> Philippa: huh?
05:41:26 <ddarius> cpoucet: Subtyping is usually a convenient thing to have with refinement types.
05:41:27 <ibid> Philippa: example?
05:42:14 <Philippa> okay, you've a point re alternatives that yield completely different results. There're ways of handling that too though
05:42:29 <Philippa> but the general form is {blah; blah; blah; let ... in return ...}
05:42:44 <ibid> (and also a grammar usually has more than one nonterminal:)
05:42:46 <Philippa> factor out the alternatives and name those if you're got a worry
05:43:08 <Philippa> my informal notation, let me show you it
05:43:37 <cpoucet> ddarius: I don't think refinement types alone sufficce
05:43:49 <cpoucet> ddarius: you want unrefined types, not more refined ones :)
05:44:05 <Philippa> cpoucet: they suffice if you declare a mother-of-all-types and refine it
05:44:14 <Philippa> the problem is that you probably want to extend it as well
05:44:32 <ibid> Philippa: factoring out is cool, but putting a let (or where) around a single parser function will obscure the larger grammar, imo
05:44:32 <ddarius> cpoucet: You have: data Exp = Atom Atom | Ops [Exp] | Bin Exp Exp and have two refinements one with Ops and one with Bin.
05:44:53 <Philippa> ibid: if I want code folding, I know where to find it
05:44:55 <cpoucet> Philippa: that sounds like a pain :)
05:45:05 <cjs> Ok, I'm stuck. My usual typing problem with: http://hpaste.org/7563
05:45:06 <cpoucet> and I'm thinking furthre than just non-parsed binaries
05:45:13 <ibid> Philippa: so you're not solving the problem i want to solve. fair enough.
05:45:17 <cpoucet> you have "parsed, resolved, typed ... expressions"
05:45:31 <quicksilver> Philippa: "my informal notation, let me show you it" <-- that is just dying to be made into a lambdacat :)
05:45:52 <cjs> Once again I've got a Parser b when I need a ByteString -> Either String (b, ByteString); how do I deal with this?
05:46:08 <quicksilver> cjs: in the right case you just want 'f v'
05:46:17 <quicksilver> erm
05:46:21 <cpoucet> yes
05:46:24 <cpoucet> in the wrong case yo want fail
05:46:24 <Philippa> yeah. I also don't consider it a big enough problem to warrant the contortions you're likely to have to go through - from my POV, obscuring the semantic aspect is also a problem and at least my style gives me a pattern I can scan-read quickly enough
05:46:24 <cjs> That's what I thought.
05:46:32 <cpoucet> cjs: the Either String == ErrorMonad
05:46:33 <Philippa> and yeah, I've had to debug my own parsers :-)
05:46:44 <wjt> @index (*>)
05:46:44 <lambdabot> bzzt
05:46:48 <wjt> @index ((*>))
05:46:49 <lambdabot> bzzt
05:46:57 <cjs> But then it expects "Either String (b, ByteString)" and has a "Parser b".
05:47:03 <quicksilver> cjs: sorry, you want runParser (f v) bs'
05:47:16 <quicksilver> or something like that.
05:47:34 <Philippa> possibly relevant: in most cases, my semantic actions are either trivial or v.close to it. But naming the intermediate results becomes a significant aspect in checking that I've got them right, especially when I've got more than one intermediate of the same type hanging around
05:47:35 <cjs> Right! That's it.
05:47:37 <cpoucet> quicksilver: what's v?
05:47:58 <Philippa> I could introduce more type structure, but that exacerbates the syntactic problem no end
05:47:58 <cjs> I must remember that one uses runParser to get the function out of the parser.
05:48:33 <quicksilver> cpoucet: cjs's paste.
05:49:52 <maltem> wjt, Control.Applicative
05:50:37 <wjt> maltem: that's the badger!
05:50:56 <Philippa> incidentally, I find having to work with <*> more obscure than ;-or-newline. YMMV :-)
05:51:34 <Philippa> (and yes, I've written the do {foo; r <- bar; baz; return r;} one-liner parser before - I should probably put the return on its own line though)
05:51:41 <quicksilver> Philippa: yes, that part definitely isn't the win.
05:51:53 <cpoucet> ibid: under the hood your parser is muchc like a monadic one
05:51:53 <quicksilver> Philippa: but having the constructor at the beginning does look quite nice.
05:52:12 <Philippa> quicksilver: agreed, I'm open to that in an applicative sugar
05:52:42 <mux> I found Control.Applicative quite obscure too at first, but you really get into it fast
05:52:48 <quicksilver> I think "foo *> bar <* baz" is quite cool.
05:52:53 <quicksilver> but obviously it's more combinators to learn.
05:53:04 <quicksilver> once you've learnt them, though, it makes the point quite well.
05:53:06 <Philippa> I'd rather not have to memorise a pile of 'cool' patterns like that myself
05:53:11 * quicksilver nods
05:53:23 <Philippa> far too prone to misparsing on my end
05:53:23 <quicksilver> well the incentive here is to avoid naming something you only use once.
05:53:31 <quicksilver> that's always an interesting goal to think about.
05:53:41 <Philippa> yep. Personally I tend to think this is a case where naming is a net win
05:53:50 <cpoucet> let's argue some more :)
05:53:52 <ibid> cpoucet: yes, it is. i was talking about the interface
05:54:02 <EvilTerran> liftM2 const!
05:54:04 <mux> also, with sufficient plumbing, you can use pretty much any parser package with the Applicative style
05:54:07 <mux> be it monadic or not
05:54:08 <cpoucet> ibid: oh that wasn't an argument, just an observation :)
05:54:30 <maltem> I do find *> and <* pretty to use for parsers, as in, say,  identifier <* optional whitespace
05:54:50 <maltem> The angle points to what I care about
05:54:50 <quicksilver> (munch the whitespace in the lexer!)
05:54:52 <mux> when I want naming, I break the parser out into smaller bits
05:54:52 <quicksilver> but, yes.
05:55:05 <maltem> right, let's say this is the lexer .)
05:55:17 <mux> ie:
05:55:26 <mux> parseMatrix file = either (error . show) id <$> parseFromFile parser file
05:55:26 <mux>   where parser = manyTill nums eof
05:55:26 <mux>         nums   = sepBy (read <$> many digit) (char ',') <* string "\r\n"
05:55:44 <mux> still pretty clear, isn't it?
05:55:56 <cpoucet> meh
05:56:47 <cpoucet> legible yes, but not an example I'd show off :)
05:56:58 * mux shrugs
05:57:03 <Philippa> maltem: what I'd /really/ like is a text editor that'd let me teach it which parts appear in the result and which just get munched and highlight them differently :-)
05:57:10 <quicksilver> nums `manyTill` eof
05:57:26 <cpoucet> quicksilver: that's a rather minor nit :)
05:57:54 <Philippa> one I'm indifferent to, as well
05:57:56 <mux> are you concerned with the unsafe parts, error, and read? :)
05:58:03 <cpoucet> digits `sepBy` comma <* newline
05:58:04 <quicksilver> ;)
05:58:05 <mux> this is quick and dirty code.
05:58:06 <cpoucet> would be clceaner :)
05:58:07 <Philippa> manyTill as "many with an extra parm" makes sense
05:58:26 <mux> well I was more talking about the applicative stuff rather than prefix vs infix :)
05:58:34 <mux> Philippa: I find too
05:58:37 <cpoucet> mux: if you don't know wnat <* does..
05:58:43 <quicksilver> one of the things I don't like about parsec combinators
05:58:51 <mux> cpoucet: it means sequence two things, keeping the result of the left one
05:58:52 <cpoucet> mux: I'm lucky that this example is rather trivial so I can guess it, but <* is not intuitive
05:58:58 <mux> cpoucet: whereas *> takes the result from the right
05:59:00 <quicksilver> is that they aren't visually distinguished from nonterminals.
05:59:02 <cpoucet> mux: yes thank you for shaping my model and then telling me the cocde is legible
05:59:07 <cpoucet> mux: that's' cheating :)
05:59:11 <mux> cpoucet: it's very intuitive when you know :)
05:59:19 <Philippa> cpoucet: hardly any glyph is intuitive when you don't know what it means
05:59:28 <Philippa> what matters is whether you get it after the first time you've looked it up
05:59:35 <quicksilver> one of the reasons I like the applicative line noise
05:59:46 <quicksilver> is that at least line noise doesn't look like a non-terminal
06:00:04 <quicksilver> there is a clear lexical distinction.
06:00:15 <mux> you can think of *> as >> even though it's more generic
06:00:29 <Philippa> quicksilver: lex, have token parsers that don't take parms. Problem solved.
06:01:31 <cpoucet> Philippa: what about `followedBy` ..
06:01:42 <quicksilver> Philippa: manyTill is an example of what I object to.
06:01:49 <quicksilver> it's not a strong objection, by the way :)
06:01:57 <ibid> cpoucet: or rather, both mine and the basic monadic parser share the same implementation technique - the list of successes
06:02:00 <quicksilver> it's just one of the things that makes it uncomfortable.
06:02:09 <Philippa> quicksilver: yeah, but your objection as stated doesn't work if non-terminals are all single identifiers
06:02:19 <cpoucet> ibid: yep, which is what I intended ;)
06:02:21 <quicksilver> In variations of BNF you'd use some symbol like '*' for manyTill.
06:02:27 <Philippa> you recover the lexical distinction
06:02:44 <Philippa> that's more about Haskell not doing unary operators though, no?
06:02:47 <ibid> cpoucet: (LoS predates monads, as i'm sure you know:)
06:02:54 <cpoucet> ibid: LoS?
06:02:59 <Philippa> (the real problem being postfix ones)
06:03:01 <ibid> cpoucet: list of successes
06:03:07 <quicksilver> Philippa: maybe, maybe.
06:03:10 <cpoucet> ibid: erm, no I didn't, now I do :)
06:03:31 <quicksilver> Philippa: there are ways to hack around these things. I'm not wedded to the concrete syntax of BNF.
06:03:46 <ibid> cpoucet: the original paper is from mid-80's, should be online somewhere. "how to replace failure with a list of successes" or similar
06:03:53 <Philippa> also, manytill isn't * and the distinction matters. Granted I'm not going to tell you off for complaining about Parsec's semantics being clunky - that's why you need manyTill at all
06:04:03 <cpoucet> ibid: Thanks
06:04:07 <Philippa> ...actually no, no it isn't
06:04:11 <quicksilver> it's just nice to have a clear lexical distinction between 'generic combinators which are part of your parsing metalanguage' and 'particular non-terminals in this grammar'
06:04:18 <Philippa> at least, not the aspect I consider clunky
06:04:29 <quicksilver> and that's one thing that's nice about using symbols for parser combinators.
06:04:30 <quicksilver> IMO.
06:04:44 <Philippa> quicksilver: "if it's being applied, it's a combinator" works for me :-)
06:04:50 <cpoucet> from what year are monads?
06:04:57 <Philippa> cpoucet: in what context?
06:05:05 <cpoucet> Philippa: CS?
06:05:10 <maltem> quicksilver, you may import qualified ;)
06:05:18 <Philippa> Moggi's use was '87 IIRC
06:05:26 <cpoucet> so only 2 years after the LoS paper
06:05:37 <Philippa> nope, 88
06:05:46 <quicksilver> maltem: that regains the distinction at considerable syntactic cost.
06:05:49 <Philippa> yeah, but Moggi wasn't working in the same context
06:05:54 <quicksilver> maltem: but I quite like that approach nonetheless.
06:05:57 * cpoucet nods
06:06:41 <Philippa> Moggi's paper has set-of-successes instead
06:07:01 <Philippa> actually, just set-of-results
06:07:14 <maltem> quicksilver, it's the cost of distinguishing sub-languages where you program in only the Haskell language, I suppose
06:07:15 <Philippa> because when you're working in denotational semantics, a failure'd better be a result too
06:07:18 * MyCatVerbs wonders. With a name like Moggi, does he or she keep cats?
06:07:22 <quicksilver> maltem: yes, it is.
06:08:44 <ddarius> quicksilver: You should write the combinators in bold.
06:08:48 <MyCatVerbs> Philippa: would it not have to always follow the rule that a failure is never followed by anything else? Like, data LoS element failure = Succeed element (LoS element failure) | AllDone | Fail failure
06:09:01 <quicksilver> ddarius: that would help a lot, yes.
06:09:11 <quicksilver> ddarius: or zapf chancery, perhaps.
06:09:19 <byorgey> MyCatVerbs: what has the name 'Moggi' to do with cats?
06:09:45 <Philippa> MyCatVerbs: it wouldn't, no. Failure'd just be _|_
06:10:16 <cpoucet> byorgey: it starts with an M, just like MyCatVerbs
06:10:18 <MyCatVerbs> Philippa: oh, okay.
06:10:21 <ToRA> byorgey: Moggi is a british colloquial term for a cat
06:10:39 <ToRA> s/Moggi/Moggie/
06:10:51 <Philippa> not sure the gs are pronounced the same
06:11:06 <byorgey> aha
06:11:20 <MyCatVerbs> byorgey: "Moggy" is a UK-ian term for cat. More specifically, a cat of distinctly non-pedigree descent. Connotations include a whole range properties related to fuzziness and huggability.
06:11:29 * byorgey is not british, in case anyone couldn't tell
06:11:33 <byorgey> MyCatVerbs: hehe, I see =)
06:12:08 <Philippa> anyone know whether it's specifically UKian as opposed to Commonwealth these days?
06:12:27 <maltem> Philippa, the italian name includes the sound of gym
06:12:40 * ibid sometimes wants a list where the empty list can be annotated
06:12:48 <quicksilver> they are pronounced very much the same
06:12:48 <Philippa> maltem: in "moggy"/"moggie" the gs are hard
06:13:01 <quicksilver> Moggi and Moggie.
06:13:02 <cpoucet> maltem: no it doesn't
06:13:13 <cpoucet> maltem: not with 2 gs
06:13:26 <MyCatVerbs> Philippa: good question. I should track down and interrogate some Kiwis.
06:13:59 <quicksilver> in fact, I pronounce them precisely the same.
06:14:05 <MyCatVerbs> ...except that all the NZ-ers I know are (sensibly enough) asleep right now.
06:14:15 <kwaazy> any aussies round here?
06:14:33 <Philippa> FCVO NZer I know one who's awake, but she lives near Bristol
06:14:40 <Svrog> kwaazy: yes
06:14:45 <maltem> cpoucet, you're sure on that, leaving me the right not to distinguish sound differences that are subtle to a German's ear?
06:14:55 <kwaazy> good man :)
06:14:57 <ibid> cpoucet: wadler's comprehending monads dates from 1992
06:15:04 <cpoucet> ibid: thanks :)
06:15:06 <ToRA> http://hpaste.org/7564 - can anyone spot what the parse error is, I'm being blind
06:15:17 <cpoucet> maltem: I know that 'oggi' has the 'gym' 'sound, but I doubt 'moggi' would have it, but then again it's not a word so it's hard to say
06:15:19 <MyCatVerbs> Philippa: FCVO?
06:15:23 <kwaazy> any1 find haskell really hard to get around ya head after learning object oriented stuff first?
06:15:32 <kwaazy> cos IAM !!! :S:SS:S
06:15:35 <cpoucet> maltem: and I have a belgian ear, we're very susceptible to g's of different flavours, and I grew up in italy :)
06:15:39 --- mode: ChanServ set +o cpoucet
06:15:41 <ibid> cpoucet: 1990, actually
06:15:43 <MyCatVerbs> Heh, "for certain values of."
06:15:54 <scook0> http://paste.lisp.org/display/60623
06:16:12 <scook0> ("Data.OrderedSet: a set type that preserves insertion order")
06:16:15 <maltem> cpoucet, heh. well it's not a hard g anyways then?
06:16:16 <cpoucet> ibid: thanks, sadly I lack some of the history of CS, given my EE background
06:16:27 <cpoucet> maltem: 'oggi' isn't, not sure of moggi tho
06:16:37 <maltem> right
06:16:53 <ibid> cpoucet: i'm self-taught in this area, having devoured a lot of fp literature when i learned haskell in 1999-2000
06:17:03 <cpoucet> ibid: :)
06:17:17 --- mode: cpoucet set -o cpoucet
06:17:45 <cjs> Phew! I'm on my way!
06:17:54 <cjs> Damn, that took four hours to get started, though.
06:18:06 <cpoucet> ibid: still have some catching up to do, but hve a lot of other things to do as well
06:18:27 <kwaazy> finch
06:19:40 <ibid> cpoucet: http://portal.acm.org/citation.cfm?doid=91556.91592 seems to be the earliest publication of monads in a programming context
06:19:54 <cjs> So presumably if I want more information about what's going wrong when I'm parsing stuff, I can replace that mere ByteString that's the remainder with some sort of state object that keeps track of the original message, where I am in parsing it, and so on, right?
06:19:54 <lambdabot> Title: Comprehending monads
06:19:58 <Philippa> kwaazy: I didn't find it too hard, but I was something of an OO cynic. Monads took me a while, but that was back before the monad tutorial industry sprang up
06:20:01 <ibid> cpoucet: and the LoS method is http://portal.acm.org/citation.cfm?id=5288
06:20:08 <lambdabot> Title: How to replace failure by a list of successes
06:20:26 <cpoucet> ibid: 1985, yeah I found that one by google (no acm access)
06:20:57 <ibid> cpoucet: acm dl helps a lot :)
06:21:05 <ibid> (my university is a subscriber)
06:21:05 <MyCatVerbs> Philippa: IMO, the monad tutorial industry mostly makes it harder, with a few gleaming exceptions.
06:21:19 <Philippa> MyCatVerbs: this was before things like Monads As Containers though
06:21:26 <cpoucet> ibid: I had IEEE :)
06:21:33 <cpoucet> I wonder if starbucks is open on holidays
06:21:44 <Philippa> so back before the community really had much experience in teaching them to people who weren't already PLT geeks
06:22:04 <quicksilver> cpoucet: are you sure the 'g' in oggi is soft? soft as in a 'g' sound?
06:22:11 <ibid> i find the containers analogy mostly confusing
06:22:17 <Philippa> once I got my head round them I was one of the more vocal advocates for (and especially explainers-in-terms-of) what's know known as Monads As Computations
06:22:18 <ibid> and have stopped teaching it
06:22:18 <quicksilver> my italian is not very good but I was sure that was hard.
06:22:22 <Philippa> *now known
06:22:35 <MyCatVerbs> Philippa: ah, I see. The fun part of Monads As Containers is turning it around to Containers As Monads. ;)
06:22:53 <Philippa> ibid: me too for the most part, though coming up via Applicatives it'd make better sense
06:23:17 <cpoucet> quicksilver: "oggi" is like gym
06:23:41 <Philippa> cpoucet: that's distinct from "oggy" as in "moggy"
06:23:45 <ibid> Philippa: as MyCatVerbs says, containers-as-monads is the more useful way of thinking about that analogy imo:)
06:23:48 <Philippa> no "j" to it
06:23:48 <ibid> but bus time, bbl
06:24:19 <quicksilver> cpoucet: then it seems very odd that moggi would be a hard G. However, I've met him and I could swear that's how he pronounced it.
06:24:20 <MyCatVerbs> Philippa: mmm. When I read YAHT's monads as computations, I had trouble with it. Possibly because they developed the idea *before* showing that it was actually just monad, and I lacked the imagination to pick up on what on Earth it was good for as a result.
06:24:29 <quicksilver> It's entirely possible my memory is at fault.
06:24:37 <Spark> memtest86
06:24:52 <Philippa> MyCatVerbs: yeah, I've not read YAHT through
06:24:55 <pjd_> monads as computations has always only made sense to me in retrospect
06:25:19 <Philippa> pjd_: I find it's not helped by the label being a misnomer
06:25:20 <MyCatVerbs> ibid: well, no. Monads As Containers is much easier as a way to pick up what's going on, it's just that shortly after you've properly understood M-as-C then it'll occur to you that C-as-M is what actually applies.
06:25:33 <cpoucet> quicksilver: is moggi italian?
06:25:39 <quicksilver> cpoucet: yes.
06:25:43 <cpoucet> quicksilver: and no it's not that odd
06:25:46 <cpoucet> quicksilver: the 'm' shortens the o
06:26:04 <cpoucet> quicksilver: seems reasonable to me
06:26:26 <cpoucet> quicksilver: I on't have an explanation for it, but my gutfeeling on pronounciation is usually right, I did think moggi would be hard, and oggi -is- sot
06:26:29 <cpoucet> soft
06:26:43 * MyCatVerbs thinks that part of the problem was that type classes on constructors with kinds other than plain ol' * didn't stick properly in his head at first.
06:27:11 <Philippa> MyCatVerbs: yeah, one of the big problems with monads is that they stress-test your understanding of the Haskell98 type system
06:27:21 <maltem> quicksilver, cpoucet: if the name does not follow standard orthography (oggi, appoggiatura, ...), then maybe the name follows the orthography of some italian dialect?
06:27:28 <Philippa> if you don't quite get type constructors or type classes, you're stuck
06:28:35 <Philippa> it helps a bit if you can manage to explain modulo type classes, but that can expose people to some nasty error messages
06:28:57 <Philippa> the one where you forget to use return with another monadic type ([] being the usual offender) is pretty nasty
06:29:40 <quicksilver> pu
06:29:42 <quicksilver> yup
06:29:48 <quicksilver> typeclasses lead to horrible messages.
06:29:57 <quicksilver> adding overloading makes more expressions type-checkable
06:30:10 <quicksilver> and then they check with increasingly bizarre types until you hit a contradiction.
06:30:22 <quicksilver> but the error message relates to the specific contradiction GHC found, not the original problem.
06:30:25 <quicksilver> I think this is hard to solve.
06:30:39 <cpoucet> I propose c++
06:30:42 <pharm> quicksilver: yup. Been there (in another language)
06:30:45 <cpoucet> much easier system, oh wat... templates
06:30:59 <pharm> cpoucet: Don't go there...
06:31:01 <Svrog> what is glength supposed to return given a list as a parameter? it seems regardless of list size it returns 2
06:31:13 <lilac> cpoucet: recent c++ compilers are at least now getting good at error messages
06:31:17 <Philippa> quicksilver: In theory you can actually do better in this case - especially if you allow some form of user annotation for type errors
06:31:30 <cpoucet> lilac: yeah, I only get about 20 lines nowadays for template errors :)
06:31:45 <cpoucet> thankgod for vim, :make and :cn
06:31:54 <maltem> oh btw, the name of a footballer also called Moggi is transliterated as  in Japanese Wikipedia
06:32:10 <quicksilver> Svrog: well (1) : ([2,3,4]) has two immediate subterms
06:32:15 <Philippa> here we know that the 'sane' model is to treat the LHS as supplying the 'expectation', and we can say "[] doesn't match the monad IO" or similar
06:32:15 <quicksilver> Svrog: being (1) and ([2,3,4])
06:32:21 <Svrog> ooh
06:32:21 <quicksilver> Svrog: so glength = 2
06:32:25 <Svrog> yeah that makes sense
06:32:26 <Svrog> heh
06:32:29 <lilac> cpoucet: 20 lines for one error? the only time i get that these days is when i'm missing an overload for << or similar, and the compiler thinks it's helpful to tell me about all the overloads which are in scope
06:32:29 <Svrog> haha
06:32:33 <scook0> 'Some people, when confronted with a problem, think "I know, I'll use C++". Now they have -2147483648 problems.' :)
06:32:46 <lilac> scook0: integer underflow!
06:32:54 <cpoucet> lilac: with templates?
06:33:07 <lilac> cpoucet: sometimes with templates. then there's the "within this context" bit
06:33:36 <quicksilver> the fully expanded type for Map String String in C++ is quite a few lines, on its own.
06:33:50 <quicksilver> once you get an error in that type, you get a real mess.
06:34:10 <lilac> quicksilver: yes, but any decent modern compiler won't tell you that type, they'll tell you the typedef name you used for it (unless they can't).
06:34:29 <quicksilver> but why shuold I be forced to typedef it.
06:34:37 <quicksilver> std::map<string,string> is OK
06:34:44 <MyCatVerbs> quicksilver: wouldn't it just be something along the lines of std::BinaryTree< std::string , std::string > ?
06:34:49 <quicksilver> I don't want to typedef every possible map I might use.
06:34:54 <scook0> speaking of C++, I do wish Haskell had something along the lines of Koenig lookup
06:34:56 <Philippa> MyCatVerbs: *fully* expanded
06:34:58 <quicksilver> MyCatVerbs: it's the expansion of string which makes it really horrid :)
06:35:05 <MyCatVerbs> Philippa: ohhhh.
06:35:09 <Philippa> complete with implicit parms
06:35:11 <lilac> quicksilver: yep, and if you say that then recent g++'s will say std::map<std::string, std::string, std::less<std::string, std::string> >, which isn't so bad given what the fully-expanded name is
06:35:13 <cpoucet> basic_string<blablablabla>
06:35:16 <MyCatVerbs> Doesn't it look up the typedefs made along the way to avoid fully expanding?
06:35:29 <scook0> so I could use sets and maps without qualified names or per-function typeclasses
06:35:30 <quicksilver> MyCatVerbs: string expands to something involving allocators and stuff.
06:35:31 <lilac> quicksilver: and i believe g++4.<something> is going to drop the std::less in that case too
06:35:38 <quicksilver> lilac: ah, ok, that's a bit better.
06:35:48 * quicksilver doesn't use C++ all that often these days.
06:35:50 <quicksilver> for some reason.
06:35:56 <MyCatVerbs> quicksilver: ugh. Kinda defeats a large chunk of the whole encapsulation thing.
06:38:05 <lilac> quicksilver: c++0x concepts will allow compilers to give better error messages in some templated cases.
06:38:32 <quicksilver> lilac: c++0x concepts will be fatally flawed in ways which we can't get imagine.
06:38:42 <quicksilver> lilac: I'm a pessimist, or a soothsayer, you choose :P
06:38:53 <quicksilver> s/get/yet/
06:39:16 <lilac> quicksilver: i think you've seen c++ features before. but concepts are pretty similar to haskell type classes, and the theory seems to be sound
06:39:54 <pharm> I look at the wikipedia page for C++0x and wince. C++ is already a *huge* language & even experts have trouble keeping track of all the nuances. And they're making it bigger...
06:40:08 <quicksilver> you only have to read the STL docs (which was AGES ago) to see that there was some higher-order notion of type.
06:40:29 <quicksilver> I don't have much confidence they'll manage to get it right, and less confidence that the commercial compilers will adopt it any time soon.
06:40:37 <quicksilver> C++ compilers are hard to write and hard to extend.
06:40:46 <quicksilver> but, I'll be delighted to be proved wrong :)
06:41:23 <lilac> quicksilver: i think ms are reasonably committed to c++0x, and a (prototype) implementation of concepts for g++ has already been done
06:42:01 <MyCatVerbs> quicksilver: I have plenty of confidence that they'll get the ideas right.
06:42:21 <lilac> quicksilver: and you just know that EDG are going to want to say "We are the first to be fully C++0x compliant" as soon as they can
06:42:33 <cpoucet> heh, to show how comcplicated c++ is, it took them 5 years from -standard- to proper implementation, and usually people startw orking on that stuff prior to a standad...
06:42:51 <cpoucet> lilac: afaik the first std compliant one for the 95 was vc++2003
06:42:58 <cpoucet> erm 98 even
06:43:01 <MyCatVerbs> quicksilver: after all, there are working implementations to lift those ideas from - ML and Haskell, for example. It's just that it's unlikely that they won't find nasty edge cases where those features interact with all the other features in the language.
06:43:08 <mauke> is 'export' in C++0x?
06:43:21 <Deewiant> C99 still isn't completely implemented in any compiler I know of
06:43:30 <lilac> cpoucet: even that isn't fully ISO C++98 compliant. plus there's been a TR and a TC since then
06:43:33 <Deewiant> and it's not that complicated
06:43:42 <MyCatVerbs> quicksilver: and, of course, I'd be amazed if we saw a commercial C++0x complier that was both complete and un-buggy enough for actual use.
06:43:46 <Baughn> Does C++0x still require headers?
06:43:47 <lilac> mauke: i don't believe export is being dropped in 0x
06:43:54 <mauke> hahahahaha
06:44:04 <mauke> we'll never get a C++0x compiler
06:44:09 <lilac> Baughn: a module system is being considered, but it looks like it's not going to make it in time
06:44:20 <MyCatVerbs> Deewiant: weeeell... some parts of it require an awful lot of legwork. Like all the numerical stuff, I think.
06:44:23 <lilac> mauke: EDG supports export, I think
06:44:58 <mauke> and who uses that?
06:45:12 <lilac> MyCatVerbs: a free-standing implementation might be easier
06:45:26 <Deewiant> MyCatVerbs: possibly. Still, it's been almost ten years.
06:45:40 <Valodim> [](int x, int y) { return x + y }
06:45:41 <Valodim> haha
06:45:47 <MyCatVerbs> Deewiant: possibly they don't care very much. x_x
06:45:55 <Deewiant> MyCatVerbs: probably not. It's all C++ these days.
06:46:43 <MyCatVerbs> Deewiant: "We'll implement $foo when people start complaining about the lack of $foo in our C compiler." "Well, damn. $foo isn't available in our C compiler, let's just hack around it using $bar instead." Repeat for a few hundred iterations and watch the apathy grow.
06:47:08 <Deewiant> Yep. :-/
06:47:10 <MyCatVerbs> Eventually lack-of-$foo becomes a well-understood problem, and people just solve it instead of implementing $foo. :P
06:47:23 <Deewiant> Or more likely, they just don't care about the two people that complain about $foo.
06:47:28 <quicksilver> example : $foo = semantics
06:47:32 <Deewiant> Hell, most C programmers don't even know about C99.
06:48:24 <ivanm> Deewiant: isn't C defined by that K&R book?
06:48:24 <scook0> real men don't need semantics, they pipe meaning directly into their compilers!
06:48:35 <ivanm> lol
06:48:44 <ivanm> @remember scook0 real men don't need semantics, they pipe meaning directly into their compilers!
06:48:44 <lambdabot> Nice!
06:49:44 <Deewiant> ivanm: there are two ISO standards and one ANSI standard, K&R predates them.
06:49:55 <Deewiant> (C99 might be both ISO and ANSI, actually, I'm not sure.)
06:50:05 <lilac> mauke: EDG is used by icc, Sun's C++ compiler, Comeau, Lucent (IIRC). Probably others too.
06:50:19 <cpoucet> lilac: IMEC uses EDG I believe
06:50:47 <ivanm> Deewiant: yes, I know :p
06:51:03 <lilac> Deewiant: aren't ANSI C89 and ISO C90 the same?
06:51:23 <Deewiant> I think there are a few differences... not 100% sure though.
06:52:42 <Deewiant> the Internet claims they're the same
06:53:36 <lilac> if they were different, i'd guess that the ISO std includes ISO-10646-1 and the silly wordy alternate tokens
06:54:07 <MyCatVerbs> Philippa: one datum just came in: apparently "moggy" isn't widespread in Canada.
06:54:09 <Deewiant> isn't ISO 10646-1 a part of C99 only?
06:54:28 <Valodim> haha, they plan to add a type "long long int"
06:54:45 <Valodim> great
06:54:46 <Deewiant> Valodim: that's been in C99 for ten years now.
06:54:49 <lilac> Valodim: #define very long
06:55:00 <Deewiant> "very very int"?
06:56:19 <MyCatVerbs> Deewiant: #define EXTREMELY(x) x x
06:56:37 <cpoucet> MyCatVerbs: lol
06:56:38 <MyCatVerbs> Deewiant: EXTREMELY(long) unsigned int probablysixtyfourbitsormore;
06:56:39 <Deewiant> EXTREMELY(const *) int;
06:56:53 <lilac> To compare C and Haskell, one only need look at what the following line means in each language: "double x = x * 2;"
06:57:00 <opqdonut> GADTs save the day \o/
06:57:14 <opqdonut> i just realised the easiest solution to allow arbitary annotations on my AST
06:57:15 <MyCatVerbs> lilac: hahah, beautiful.
06:57:15 <Valodim> what a bunch of patchwork
06:57:23 <opqdonut> add a constructor:     Annotate :: ann -> AST ann a -> AST ann a
06:57:43 <opqdonut> would've required loads of work and uglyness with a plain old DT
06:59:12 <visof> can i write c code in haskell ?
06:59:38 <visof> is this logical ?
06:59:46 <visof> or stupidity?
07:00:07 <Baughn> visof: If you want to call C functions, you can. If you want to write C in haskell.. stop.
07:00:35 <Baughn> ..you really should try writing it as idiomatic haskell first, though. C code is very rarely needed.
07:00:38 <visof> yes, call c function
07:00:49 <Baughn> Look at the foreign function interface
07:01:00 <visof> okay
07:01:15 <Svrog> visof: http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html
07:01:17 <Svrog> hehe
07:01:25 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2948p6
07:02:57 <scook0> the "main" purpose of C-in-Haskell is to let you write your foreign marshalling code in Haskell instead of C
07:03:08 <saml> all monadic actions in a monad are sequenced?  do { a1; a2; a3; .. } ?
07:03:19 <saml> can I say a1 is done first before a2?
07:03:25 <Baughn> saml: To whatever degree the monad implements sequencing, sure
07:03:29 <dolio> Depends on the monad.
07:04:02 <Baughn> It's the logical thing to do, but there's nothing stopping you from newtyping IO into something that flips >> around
07:04:07 <Svrog> hi conal
07:04:13 <saml> how would you implement a1 >> a2 so that a2 is excuded first?
07:04:28 <Baughn> saml: >> is a function. Just flip the arguments.
07:04:40 <dolio> The obvious example is the reader monad.
07:04:46 <lilac> Baughn: that'd return a monad of the wrong type
07:04:58 <dolio> > (do { undefined ; return 3}) 4
07:05:00 <lambdabot>  3
07:05:06 <Baughn> lilac: Well, it might take a little more work
07:05:12 <dolio> Obviously the 'undefined' isn't executed first.
07:05:19 <dolio> Or at all.
07:05:33 <saml> what's that do block in ? IO moand?
07:05:37 <lilac> dolio: which monad was that?
07:05:53 <dolio> lilac: The reader monad (->) r
07:06:18 <dolio> > runReader (do { undefined ; return 3}) 4 -- newtyped version
07:06:19 <lambdabot>  3
07:06:27 <lilac> d'oh. it's applied as a function, that was obvious ;-)  (for a suitable value of obvious)
07:07:03 <quicksilver> lilac: that's how the type-checker knew, yes :)
07:07:15 <quicksilver> lilac: and that's how ghc knew what code to generate.
07:10:24 <dolio> "How Reddit Will (Maybe) Save Software Development"
07:10:29 <dolio> I'm holding my breath for that one.
07:10:40 <Botje> don't hold it too long
07:11:44 <saml> > runReader (do { undefined; undefined; a <- ask; return a; }) 42
07:11:52 <lilac> > ((1/) >> (+)) 0.1
07:11:54 <lambdabot>  42
07:11:54 <lambdabot>  <Double -> Double>
07:12:12 <lilac> > ((1/) >>= (+)) 0.1
07:12:14 <lambdabot>  10.1
07:12:20 <lilac> :)
07:12:38 <lilac> @pl \x -> x + 1/x
07:12:39 <lambdabot> ap (+) (1 /)
07:12:39 <dolio> The reverse state monad might be an example of something that runs backwards.
07:12:50 <Philippa> <dolio> "How Reddit Will (Maybe) Save Software Development" <- Nothing
07:13:04 <dolio> Heh.
07:14:31 <dolio> http://panicsonic.blogspot.com/2007/12/backwards-state-or-power-of-laziness.html
07:14:32 <lambdabot> Title: FS: Backwards State, or: The Power of Laziness, http://tinyurl.com/3acj9w
07:16:00 <mauke> hey, someone stole my idea!
07:16:10 <dolio> Of course, I don't know if I've seen a good use of backwards state.
07:16:21 <dolio> Unless you think writing infinite loops is worthwhile.
07:16:56 <mauke> and he did it in 1992 while my idea is from 2007
07:17:07 <mauke> truly, he understands the concept of backwards state
07:20:48 <Philippa> dolio: bidi computations?
07:25:30 <hkBst> how deos one do multithreading in haskell?
07:25:49 <dolio> Control.Concurrent.*
07:26:08 <conal> Svrog: hi!
07:26:31 <conal> @localtime Svrog
07:26:32 <lambdabot> Local time for Svrog is 2008-05-13 00:26:32 +1000
07:26:36 <Baughn> Control.Parallel*, too
07:27:10 <conal> Svrog: still in au?
07:27:29 <dolio> I'm not sure that's exactly multithreading as you'd usually think of it, but if it achieves your aims, it's probably better.
07:30:11 <hkBst> dolio: how do I turn such a module name into an explanation of itself?
07:30:37 <cpoucet> dons: ping
07:30:45 <dolio> Look at the docs and type it in manually?
07:31:02 <dolio> You won't need the entire hierarchy.
07:31:05 <quicksilver> hkBst: http://www.haskell.org/ghc/docs/latest/html/libraries/
07:31:38 <SamB_XP> @doc Control.Concurrent
07:31:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
07:31:40 <Svrog> conal: yup, still in au
07:31:58 <SamB_XP> @doc Control.Parallel
07:31:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Parallel.html
07:31:59 <dolio> For instance, the Control.Concurrent.STM hierarchy duplicates some functionality of the rest of the hierarchy, only using transactional memory.
07:32:33 <quicksilver> SamB_XP: ooh, didn't that used to be broken? looks like someone fixed it.
07:44:57 <mercury^> @localtime mercury^
07:45:01 <lambdabot> Local time for mercury^ is Mon May 12 14:44:57 2008
07:45:13 <mercury^> does it try geolocation?
07:45:55 <Deewiant> it uses CTCP TIME
07:46:10 <Deewiant> CTCP TIME reply from mercury^: Mon May 12 14:46:00 2008
07:47:21 <pmdboi> hey folks, could someone help me out with a linking error?
07:47:21 <pmdboi> http://paste.lisp.org/display/60626#1
07:47:29 <pmdboi> i was running through http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/errorcheck.html
07:47:30 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/6mrh6q
07:47:54 <mauke> pmdboi: try ghc --make Parsing.hs
07:47:56 <Deewiant> pmdboi: suggestion: use ghc --make
07:48:13 <pmdboi> ah, huh, looks like that did it
07:48:15 <Deewiant> pmdboi: alternatively, -package mtl might help
07:48:28 <Deewiant> (without knowing what -package does, hence 'might')
07:48:41 <Deewiant> but in general, just use --make and be done with it.
07:48:52 <pmdboi> looks like that does it too
07:48:53 <pmdboi> thanks :)
07:51:31 <Botje> giggle
07:52:01 <Botje> i'm reading a paper that says it can "quite efficiently" unlaunch missiles without stopping any part of the system *G*
07:52:13 * Botje reads on
07:58:09 <ibid> yeah, just send a third salvo :)
08:18:12 <ehird> What should I do on debian stable if I want ghc 6.8?
08:19:12 <quicksilver> compile it yourself, perhaps?
08:19:19 <quicksilver> from the source packages, if you like.
08:19:32 <Igloo> Yeah, I don't think there's a backport
08:20:01 <ehird> quicksilver: Awlrighty I gues.s
08:20:04 * SamB wonders how typeclasses ought to work in Agda
08:20:10 <ehird> How long does it take to compile ghc these days
08:20:21 <SamB> how fast a CPU do you have?
08:20:33 <ozy`> ehird: about three hours on a brand-new machine, I hear
08:20:34 <SamB> and how much RAM?
08:20:36 <quicksilver> between 15 minutes and 10 hours.
08:20:42 <ozy`> (more like eight on mine)
08:21:00 <SamB> and, er, what compile settings do you use, and are you starting from scratch?
08:21:21 <ehird> SamB: Slow, crap, and lame.
08:21:27 <xd> it took me a couple hours on a newish macbook pro recently
08:21:28 <ehird> I'll go for a binary :-)
08:21:30 <SamB> how slow is slow?
08:21:38 <SamB> is 1.4 GHz slow yet?
08:21:55 <ehird> SamB: When it says 1.8ghz, it means 0.9ghz.
08:21:57 <ehird> That's my experience.
08:22:02 <SamB> wait, my CPU is 1.7 GHz
08:22:02 <ehird> It's nothing near 1.8ghz.
08:22:05 <ehird> Yet it claims to be.
08:22:16 <ehird> It is unbelivably craptastic
08:22:32 <SamB> hmm, it seems to be faster than my old 450 MHz PII and my 600 MHz PIII
08:23:12 <ehird> So, what binary should I use?
08:23:17 <ehird> x86, linux, craptastic.
08:23:20 <ehird> Debian stable.
08:23:26 <SamB> ???
08:23:28 <ozy`> ehird: what "it" are you talking about? I mean, sure, clockspeed matters more for some processors than others, but that doesn't mean all of them are lying about their speed
08:23:51 <SamB> I'm fairly certain that /proc/cpuinfo doesn't lie about MHz
08:24:07 <SamB> or bogomips, though *their* bogosity is unquestionable
08:24:22 <ehird> SamB: I just know that this machine acts like it's from 2002, except more craptastic.
08:24:26 <ehird> But yeah, what binary should I use?
08:24:44 <SamB> ehird: what do you mean, which binary?
08:25:22 <ehird> SamB: ghc binary
08:25:29 <SamB> there are choices?
08:26:33 <ehird> eh?
08:27:06 <ozy`> http://hpaste.org/7565 <== speaking of compiling stuff, this doesn't look good...
08:27:50 <ehird> Jump - island out of range
08:27:52 <ehird> Fell into ocean
08:27:55 <ehird> Please report as a bug
08:28:11 <ozy`> yes, I saw that part
08:29:27 <ozy`> http://hpaste.org/7566 <== eh, what the heck. here's the whole thing
08:30:07 <quicksilver> ozy`: you've got to admit that's a cool error.
08:30:36 <quicksilver> @remember ghc jump island out of range
08:30:36 <lambdabot> It is forever etched in my memory.
08:30:49 <quicksilver> sounds like you downloaded ghc-rainbow-islands
08:31:07 <ozy`> I understand unconditional branches, but what the hizazzy is a jump island? O_o
08:31:07 <ozy`> heh
08:31:13 <ozy`> I guess so
08:32:20 <ozy`> ah well
08:32:28 <desp> Were there any news recently about Haskell gaining more recognition at Microsoft?
08:33:45 <Bonus> i thought they had their F# thingie going on
08:34:02 <osfameron> I'm going to a talk about F# on thursday at the local .Net usergroup
08:34:05 <Bonus> f# just looks rly ugly to me
08:34:15 <ehird> ozy`: I was joking
08:34:22 <ehird> I was seperating '(jump island) out of range'
08:34:35 <ehird> into 'I jumped, but the island was out of range. .... I feel into the ocean. This is a bug.'
08:35:38 <ehird> So, I'm writing a wiki in haskell. Just in case anyone cares - yeah, yeah I know there's too many wikis out ther.e
08:36:48 <IsoPallo> We'll care if it's better than the rest obvously.
08:38:04 <conal> i'll care if it's mostly functional
08:39:07 <quicksilver> ehird: what markup/down are you using?
08:39:21 <ehird> quicksilver: either pandoc, or something else
08:39:22 <ehird> ;)
08:39:27 <ehird> conal: hopefully
08:39:33 <ehird> based on fastcgi
08:39:37 <conal> ehird: :) !
08:39:39 <ehird> but can use cgi or whatever too
08:39:40 <ehird> hopefully
08:39:48 <conal> yay markdown, btw
08:41:31 <ehird> i hate markdown
08:41:33 <ehird> personally
08:41:38 <ehird> textile is far more intuitive
08:41:45 <ehird> but i'm probably gonna go and invent my own wonderful format
08:41:45 <ehird> ;)
08:42:19 <conal> ehird: decompressed to html on the server or client?
08:42:36 <ehird> conal: um, server, are you mad?
08:42:41 <ehird> I don't know of one SINGLE wiki doing it client-side
08:42:47 <ehird> especially since that'd break every browser not doing js
08:43:15 <conal> ehird: i have a peeve about the internet working by doing decompressing before transmission instead of after.
08:43:20 <twobitwork> I'm looking to move from ocaml to haskell (just grokked monads the other day)...
08:43:23 <conal> (decompression)
08:43:41 <ehird> conal: So you'd prefer to require everyone to support JS, and make the client do work that it has no reason to do.
08:43:53 <ehird> Riight... check that up as another person I'm going to ignore when it comes to web stuff.
08:44:08 <twobitwork> but in Ocaml, there's a nice library for allowing scheme "plugins" sort of... it's a scheme interpreter writen in ocaml that you can load and interface with... is there any such thing for haskell?
08:44:31 <ehird> twobitwork: Most of the scheme interps are toys.
08:44:32 <ehird> but ..
08:44:38 <ehird> 1. why do you want that? why not give your users haskell? ;)
08:44:42 <ehird> 2. why not write it? :)
08:44:48 <twobitwork> ehird: I just need a sort of scripting interface for my ap, so toy is fine
08:45:23 <ehird> twobitwork: You can just provide people with haskell by hooking into ghc.
08:45:23 <ehird> :P
08:45:33 <twobitwork> ehird: 1. because I want it a bit more user friendly, 2. why reinvent the wheel?
08:46:06 <ehird> Haskell is pretty user friendly :|
08:46:11 <ehird> at least as much as scheme
08:46:23 <ehird> and as for 2. well ... why not? A toy scheme interp can be written in less than a day.
08:46:38 <twobitwork> bleh, look, I'm not looking for mindless advocacy, I'd rather just be able to have scheme as my scripting language
08:47:07 <mauke> twobitwork: I don't know of such a library
08:47:21 <twobitwork> mauke: ok, thanks :)
08:47:33 <twobitwork> I mean, I don't mind implementing it, I was just wondering if such a thing existed
08:49:13 <quicksilver> it's not clear that haskell is as good a scripting language as scheme.
08:49:21 <quicksilver> It will certainly be interesting to see how the projects turn out.
08:50:32 <conal> the two languages seem to appeal to very different creative styles.
08:50:54 <christastrophe> im trying to get my head around IO in haskell today
08:51:04 <christastrophe> so I tried out this simple example
08:51:11 <christastrophe> main =
08:51:11 <christastrophe>   do
08:51:11 <christastrophe>     putStr "Hi "
08:51:12 <christastrophe>     x <- getLine
08:51:12 <christastrophe>     putStr x
08:51:16 <mauke> aIIRRR
08:51:52 <christastrophe> but when I compile in ghc, the first putStr isn't evaled until after the getLine... which seems counter to every IO tutorial I've seen...
08:51:58 <quicksilver> christastrophe: it is evaled.
08:52:03 <quicksilver> christastrophe: you just can't see it.
08:52:06 <Baughn> christastrophe: It's also line-buffered
08:52:09 <quicksilver> christastrophe: because your OS buffers by the line, by default.
08:52:16 <Bonus> tri putStrLn
08:52:17 <christastrophe> ah
08:52:17 <mauke> christastrophe: http://tnx.nl/sfb
08:52:19 <lambdabot> Title: Suffering from Buffering?
08:52:20 <Deewiant> christastrophe: it'll behave the same in any other language, probably.
08:52:30 <quicksilver> (This incidentally is not a property of haskell, but of your OS and most languages will behave the same)
08:52:42 <Baughn> christastrophe: Also, in the future, *please* don't paste this much here. hpaste.org exists for a reason.
08:52:59 <christastrophe> oh damn. I didn't realize what hpaste was for. so sorry...
08:53:06 <christastrophe> i must say now that site make a lot ore sense!
08:53:20 <Baughn> christastrophe: Or write it all on one line; "main = putStrLn "foo "; a <- getLine; putStrLn a" would also work
08:53:49 <Baughn> christastrophe: Oh, and for prompts and such, might want to grab hFlush and stdout from System.IO
08:54:09 <quicksilver> or just turn off buffering entirely
08:54:15 <quicksilver> which is fine for an interactive program
08:54:21 <quicksilver> hSetBuffering stdout NoBuffering
08:54:23 <Baughn> Yeah, but bad style
08:54:31 <quicksilver> how is that bad style?
08:54:45 <mauke> I don't want a write(2) call for every single character
08:54:51 <Baughn> You never know when someone will decide to run your "interactive" program noninteractively
08:55:02 <christastrophe> cool. I hadn't encountered those bits before
08:55:12 <mauke> it looks horrible in strace
08:55:36 <quicksilver> I think an hFlush after every call looks far worse.
08:55:48 <quicksilver> does hPutStr really do a write for each char, though?
08:55:59 <christastrophe> i must say that all the IO tutorials I've come across so far completely ignore the buffering, even when doing examples that have prompting.
08:56:03 <christastrophe> thanks for the pointers
08:56:08 <byorgey> quicksilver: I think mauke was referring to turning off buffering entirely.
08:56:19 <mauke> quicksilver: with NoBuffering, yes
08:56:32 <Baughn> quicksilver: That's what functions are for..
08:56:50 <Baughn> You can define one that flushes for you. Even that reads input, for that matter. ;)
08:59:34 * byorgey bakes up a batch of macadamia-white chocolate-lambda cookies
09:04:25 * cpoucet invites himself to byorgey's housee
09:05:02 * Baughn eats excessively chocolate icecream
09:05:11 <byorgey> it's kind of far away, but you would be welcome =)
09:05:45 <Baughn> @src join
09:05:45 <lambdabot> join x =  x >>= id
09:07:38 <twobitwork> do haskell application generally use Makefiles, or is there some other more haskellish way to build?
09:08:01 <saml> data B = B { getFoo :: (MonadA m) => String -> m Int }   why is this wrong?
09:08:06 <Baughn> twobitwork: Cabal, if possible
09:08:23 <Baughn> twobitwork: If cabal turns out not to be possible, then you're supposed to complain so we can fix it. ;)
09:08:23 <cpoucet> twobitwork: or just plain ghc --make
09:08:36 <Baughn> ghc --make works great for small projects, yeah
09:08:44 <saml> Illegal polymorphic or qualified type: forall (m :: * -> *). (MonadA m) => String -> m Int
09:08:47 <Baughn> cabal has the advantage that you get to be cabal-installed later
09:10:30 <quicksilver> saml: in haskell98, you can't really embed type classes into data structures in a useful way.
09:10:40 <ehird> ehird@debian:~/cabal-1.2.3.0$ sudo make install
09:10:42 <ehird> --> NO CABAL BINARY
09:10:44 <ehird> D:
09:10:46 <saml> quicksilver: is there an extention i can use?
09:11:13 <quicksilver> saml: yes
09:11:18 <quicksilver> saml: what do you want that to mean.
09:11:21 <quicksilver> saml: which m is it?
09:11:26 <quicksilver> saml: is it the same m for all Bs?
09:11:30 <quicksilver> is it a fixed m for a given B?
09:11:35 <quicksilver> can the caller choose which m?
09:11:41 <twobitwork> interesting that ghc has a built in make... what are the cases in which it isn't usable?
09:12:12 <twobitwork> I mean, what are the limitations which might give someone reason to use cabal instead?
09:12:20 <saml> i just want to store functions in B. the function uses computation in MonadA class
09:15:05 <quicksilver> saml: ok. in that case you want a true higher order component.
09:15:11 <quicksilver> saml: you should be OK with -XRankNTypes
09:15:24 <quicksilver> data B = B { getFoo :: forall m . (MonadA m) => String -> m Int }
09:15:30 <quicksilver> is I *think* the correct syntax.
09:15:47 <saml> quicksilver: thank you
09:15:52 <quicksilver> twobitwork: cabal handles dependencies between packages.
09:16:09 <quicksilver> twobitwork: and can also be used to build the non-haskell parts (e.g. C library wrapper stubs or something)
09:16:49 <Baughn> twobitwork: ghc will tell you when you're missing a module, but not what package that module is in, and it has no notion of versions
09:17:33 <ehird> Help with the cabal installing?
09:17:43 <Baughn> ehird: What about it?
09:17:52 <ehird> Baughn: <ehird> ehird@debian:~/cabal-1.2.3.0$ sudo make install
09:17:52 <ehird> <ehird> --> NO CABAL BINARY
09:17:52 <ehird> <ehird> D:
09:18:07 <Baughn> ehird: I feel I should mention, the cabal binary is in the cabal-install package. The cabal package only contains the cabal library.
09:18:09 <Saizan> ehird: why do you use make to install cabal?
09:18:26 <lesshaste> hi
09:18:29 <ehird> Baughn: Oh. Duh.
09:18:31 <ehird> Saizan: It tells me to.
09:18:46 <thetallguy> conal: regarding order of decompression/transmission, yet one more reason for a plugin
09:19:08 <Saizan> ehird: probably out of date doc, the classic runghc Setup {configure,build,install} works
09:19:16 <conal> thetallguy: definitely!
09:19:16 <lesshaste> I am trying to come up with some interesting simple haskell programs whose correctness can be proved by induction
09:19:20 <lesshaste> any help much appreciated ;)
09:19:39 <mauke> Saizan: so you need cabal to build cabal?
09:19:52 <conal> thetallguy: i wonder why i don't hear about this decompress-then-transmit issue.  it's pervasive on the net.
09:20:06 <Saizan> mauke: it simply bootstraps from the sources
09:20:17 <lesshaste> basically a groovy simple recursive haskell program
09:20:20 <lesshaste> :)
09:20:26 <conal> thetallguy: maybe people don't look at it, because they don't know an alternative.
09:20:26 <ehird> Bootstrapping works because bootstrapping works because bootstrapping works because bootstrapping works ...
09:20:33 <Baughn> mauke: ghc --make Setup, in cabal.. doesn't seem to use the system cabal
09:20:37 <thetallguy> conal: I was just scribbling a blog the other day about how people come to see blocks of software as fixed and make decisions that are obviously wrong because of that.
09:20:42 <mauke> any idea why haddock doesn't want to turn 'XMonad.Operations.mkAdjust' into a hyperlink?
09:21:15 <conal> thetallguy: like money: it's just an invention, but now it runs the show.
09:22:06 <quicksilver> Baughn: actually ghc does have a notion of versions
09:22:13 <quicksilver> Baughn: it versions all the symbols in the packages.
09:22:23 <quicksilver> Baughn: but it doesn't have a notion of 'this source file requires this binary version'
09:22:51 <thetallguy> conal:  Interesting.  I've often had discussions with Jeremy (stepcut) about how a good business focuses on providing services rather than making money.
09:23:35 <thetallguy> conal:  the subtle difference being that money is a measure of the services you provide.
09:23:36 <lesshaste> I suppose a set of haskell programs with their corresponding proofs of correctness would do
09:23:45 <conal> thetallguy: check out joe firmage, btw.  e.g., http://www.barbaramarxhubbard.com/images/JoeFirmage.mp3
09:23:58 <thetallguy> conal: My example was terminal I/O
09:24:17 <thetallguy> conal: going back to our discussion about seeing the world functionally
09:25:13 <thetallguy> conal: it occurred to me that everyone views putStr/getStr as the quintessential imperative necessity
09:25:41 <byorgey> mauke: is this in a module in xmonad-contrib?
09:25:52 <conal> thetallguy: that's what i hear also
09:25:59 <thetallguy> conal: but that was only really true with paper terminals.
09:26:02 <byorgey> mauke: I'm still not sure how to make it do cross-package hyperlinks correctly
09:26:37 <vixey> lesshaste: Has to be haskell?
09:26:53 <conal> thetallguy: right putStr/getStr is not a requirement, but rather a solution artifact.
09:27:01 <thetallguy> conal: xterm is effectively  just (tail t)
09:27:31 <gwern> @seen boegel
09:27:32 <lambdabot> I saw boegel leaving #haskell-blah and #haskell 5h 47m 18s ago, and .
09:27:33 <thetallguy> conal: hence my desire to start with the bootloader...
09:27:35 <lesshaste> vixey, yes.. were you thinking miranda?
09:27:38 <vixey> lesshaste: http://www.iis.sinica.edu.tw/~scm/pub/countdown704.ps.gz
09:28:09 <vixey> lesshaste: Here's one Algebra of Programming is great, lots of program derivation stuff you might be interested in but its gopher not haskel
09:28:11 <thetallguy> conal: I did not succeed in porting simple-reactive, by the way.
09:28:23 <conal> thetallguy: to js?
09:28:38 <lesshaste> vixey, :)
09:28:43 <ddarius> thetallguy: If a business could make money without providing any services or products would that not be good business (at least for them?)
09:28:49 <thetallguy> conal: yes.  I upped the estimate significantly
09:29:24 <thetallguy> ddarius: well, that's what Jane Street Capital does
09:29:26 <conal> btw, related to the world as functional vs world as OO/imperative, i made some comments at http://reddit.com/info/6iv5u/comments
09:29:43 <thetallguy> ddarius: they have private capital and they play the market
09:29:49 <conal> one point is that imperative languages cannot express nearly enough state.
09:30:25 <lesshaste> vixey, I only came up with foldr (+) 0 (map log (x:xs)) == log (foldr (*) 1 (x:xs))
09:30:29 <conal> maybe more accurately, not enough "mutation".
09:30:34 <thetallguy> ddarius: It certainly makes them money, but ultimately, that's not what builds an economy
09:30:39 <lesshaste> vixey, anything that is slightly surprising will do
09:31:06 <vixey> lesshaste: gotta be careful with inductive proofs in haskell
09:31:16 <vixey> lesshaste: Not all data in haskell is inductively defined, e.g.
09:31:19 <thetallguy> conal: got both links, will read in a bit.
09:31:20 <vixey> > fix (1:)
09:31:24 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:31:36 <gwern> ddarius: it'd be bad business in as much as it sounds like they're arbitraging and the market erases arbitrage opportunities?
09:31:50 <lesshaste> vixey, ok that seems subtle :)
09:31:54 <thetallguy> ddarius: but it's really a question of understanding why people are willing to send you money
09:31:58 <lesshaste> vixey, I am working over lists though
09:32:14 <conal> thetallguy:  i like joe firmage's insight about how the fundamental goal of our economic model is at odds with collective well-being.
09:32:20 <thetallguy> ddarius: given that we were working at a Linux distribution, it was an important question
09:32:25 <vixey> lesshaste: If you take the precondition that data is inductive, then foldr f z (reverse l) = foldl (flip f) z l
09:32:32 <Apocalisp> ddarius: To "make money", you have to _make_ money. The currency itself is just a thunk.
09:32:38 <conal> thetallguy: and so is inherently non-sustainable.
09:32:43 <lesshaste> vixey, :)
09:32:59 <thetallguy> conal: interesting.  I ordered the bicameral mind book as soon as I read the blog on it.
09:33:24 <gwern> thetallguy: oh, it's great
09:33:25 <lesshaste> vixey, I wonder if the channel bot can evaluate those functions for me
09:33:34 <thetallguy> conal:  I think our collective conciousness is even younger than our personal ones.
09:33:41 <thetallguy> gwern: glad to hear it.
09:33:48 <vixey> > foldr f z (reverse [a,b,c,d])
09:33:51 <Deewiant> @check \x -> foldr (+) 0 (map log x) == log (foldr (*) 1 x)
09:33:51 <lambdabot>  f d (f c (f b (f a z)))
09:33:52 <lambdabot>  Falsifiable, after 1 tests: [-1.0,2.0]
09:33:58 <Shimei3> Heya. Anyone read the transcription of the talk Steve Yegge gave on dynamic languages?
09:34:04 <vixey> > foldl (flip f) z [a,b,c,d]
09:34:05 <lambdabot>  f d (f c (f b (f a z)))
09:34:09 <vixey> it can :P
09:34:12 <cpoucet> Shimei3: yep
09:34:22 <Shimei3> cpoucet: What'd you think about it?
09:34:24 <Deewiant> @check \x -> all (>=0) x ==> foldr (+) 0 (map log x) == log (foldr (*) 1 x)
09:34:26 <lambdabot>  Falsifiable, after 33 tests: [0.4,4.5]
09:34:33 <gwern> thetallguy: I'm still skeptical, since it seems to me that there are chronology problems (and testing jaynes's theory would be a bitch), but it's wonderful just as 'conspiracy theory'
09:34:35 <cpoucet> Shimei3: he could've cleaned up the transcript a bit :)
09:34:46 <lesshaste> vixey, what is going on? :)
09:34:49 <cpoucet> Shimei3: some interesting links, nothing really mind boggling
09:35:14 <lesshaste> vixey, it's claiming that the two things are different?
09:35:16 <tromp> @src reverse
09:35:17 <lambdabot> reverse = foldl (flip (:)) []
09:35:17 <gwern> thetallguy: once you finish it, you might want to track down Neal Stephenson's _The Big U_ which draws on it
09:35:21 <gwern> Shimei3: I've just started reading it
09:35:23 <vixey> > foldr f z (reverse [a,b,c,d])
09:35:24 <vixey> > foldl (flip f) z [a,b,c,d]
09:35:25 <lambdabot>  f d (f c (f b (f a z)))
09:35:26 <lambdabot>  f d (f c (f b (f a z)))
09:35:32 <vixey> ^ both have the same result
09:35:36 <lesshaste> I meant mine
09:35:36 <vixey> this doesn't prove anything though
09:35:36 <Shimei3> Yeah, it was interesting. But I'm not so sure of his points on type systems being so bad -- not much back up there aside from "cryptic errors suck"
09:35:37 <thetallguy> gwern: yeah, I expect that might be so, but such ideas are often the most interesting.
09:35:53 <lesshaste> the sum of the log being the log of the products
09:35:57 <vixey> the proof is prettly simple induction
09:36:03 <thetallguy> gwern: alas, I'm not really a Stephenson fan.  Not sure why.
09:36:16 <lesshaste> vixey, why did it say it was falsiable?
09:36:20 <lesshaste> falsifiable
09:36:30 <cpoucet> Shimei3: I think in certain domains there''s some value to it
09:36:35 <gwern> thetallguy: but ignore my criticism: it's still an awesome book - it's rare to come across a book which could, if you let it, totally rewrite your view of history and the universe
09:36:38 <Deewiant> > (sum . map log $ [0.4,4.5], log . product $ [0.4,4.5])
09:36:39 <lambdabot>  (0.5877866649021192,0.5877866649021191)
09:36:52 <lesshaste> ah... founding errors
09:36:53 <lesshaste> round
09:36:56 <lesshaste> rounding
09:37:20 <thetallguy> gwern: yes.  The Space Elevator was great that way
09:37:36 <vixey> > (sum . map log $ [0.4,4.5], log . product $ [0.4,4.5]) :: (CReal, CReal)
09:37:36 <gwern> @tell boegel great; the darcs repo downloads and compiles fine, although foo.ppm from './HRayMain scenes/circles.hry foo.ppm'  is kinda ugly :) maybe I'll cabalize it this week
09:37:36 <lambdabot> Consider it noted.
09:37:38 <lambdabot>  (0.5877866649021190081897311406188637697694,0.587786664902119008189731140618...
09:37:41 <cpoucet> gwern: which book?
09:37:53 <vixey> CReal++
09:38:03 <Deewiant> what's CReal
09:38:07 <vixey> > (uncurry (==)) (sum . map log $ [0.4,4.5], log . product $ [0.4,4.5]) :: (CReal, CReal)
09:38:08 <lambdabot>  Couldn't match expected type `(CReal, CReal)'
09:38:10 <gwern> cpoucet: Julian Jaynes's The Origin of Consciousness in the Breakdown of the Bicameral Mind
09:38:13 <vixey> > (uncurry (==)) ((sum . map log $ [0.4,4.5], log . product $ [0.4,4.5]) :: (CReal, CReal))
09:38:14 <gwern> iirc
09:38:15 <lambdabot>  True
09:38:30 <lesshaste> vixey, err... how did it do that?
09:38:30 <thetallguy> cpoucet: http://blog.plover.com/brain/Jaynes.html
09:38:31 <lambdabot> Title: The Universe of Discourse : The Origin of Consciousness
09:38:43 <lesshaste> vixey, i mean it can't have evaluated the irrational numbres
09:38:45 <lesshaste> numbers
09:38:50 <vixey> lesshaste: why not?
09:39:01 <lesshaste> vixey, it would take for ever
09:39:03 <vixey> lesshaste: did you see the countdown thing I linked?
09:39:16 <lesshaste> the ps.gz file?
09:40:05 <lesshaste> vixey, I have it
09:40:07 <lesshaste> it's quite long :)
09:40:33 <lesshaste> I don't understand what Haskell has done with two real numbers... has it evaluated them to some fixed precision?
09:40:51 <ddarius> thetallguy: As far as being a good corporate citizen, yes providing value is desirable.  As far as the corporation's selfish ends, you want to maximize profit and minimizing costs is one part of doing that.
09:41:16 <cpoucet> thetallguy: where does this guy get any evidence whatsoever, seeing all these people are dead..
09:41:17 <ddarius> thetallguy: It's just that providing something people want is usually the best way of maximizing profit.
09:41:34 <vixey> oh
09:41:52 <vixey> not that I understand the proof
09:41:59 <vixey> lesshaste: but there's http://www.lri.fr/~sozeau/research/russell/fingertrees.en.html
09:42:01 <lambdabot> Title: Matthieu Sozeau :: Dependent Finger Trees in Coq
09:43:19 <lesshaste> vixey, sorry what is that about?
09:43:23 <IsoPallo> ddarius: I think it's even better for the profit if you have friend in the right places end can skip the responsible productin habits part...
09:43:26 <lesshaste> Is a finger tree like a finger search tree?
09:43:41 <ddarius> IsoPallo: Indeed
09:43:46 <IsoPallo> Like Nokia and the likes do.
09:43:47 <ehird> HTTP >=3000.0&&<3001.2, zlib >=0.3
09:43:49 <ehird> FLARGLE
09:43:52 <lesshaste> vixey, and does it address how haskell can know whether two irrational numbers are the same :)
09:43:55 <ehird> @hackage HTTP
09:43:55 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP
09:43:57 <ehird> @hackage zlib
09:43:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib
09:43:59 <ehird> kthx lambdabot
09:44:08 <conal> lesshaste: the finger paper explains the relationship.
09:44:16 <conal> lesshaste: (finger tree paper)
09:44:43 <lesshaste> conal, ok.. there seem to be a few papers there.. which one?
09:45:13 <vixey> lesshaste: bbl, if you find some more program derivation/correctness stuff tell me :p
09:45:26 <conal> lesshaste: i think this one: http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
09:45:28 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
09:45:52 <lesshaste> conal, hmm... I don't see anything about irrational numbers there.. it just seems to be about finger search trees :)
09:46:18 <vixey> > pi :: CReal
09:46:25 <lambdabot>  3.1415926535897932384626433832795028841972
09:46:36 <lesshaste> so it's fixed precision
09:46:36 <vixey> That's CReal
09:46:46 <lesshaste> so what has that paper got to do with it?
09:46:55 <vegai> > pi :: Rational
09:46:56 <lambdabot>   add an instance declaration for (Floating Rational)
09:46:56 <lambdabot>     In the expression: ...
09:47:01 <vegai> damn
09:47:04 <lesshaste> not that it isn't interesting in it's own right
09:47:07 <vixey> why must the paper have something to do with CReal
09:47:31 <vixey> I just mentioned finger trees because it's a bigger example of correctness proofs
09:47:34 <thetallguy> ddarius: yes, exactly.  That thought gets lost in the open source world, sometimes.
09:47:45 <IsoPallo> ddarius: But eventually that should hurt your image and make you lose profit as we as responsible consumers keep ourselves informed of the technical and production details of the products we buy.
09:47:54 <lesshaste> vixey, oh! :)
09:48:02 <lesshaste> vixey, I had completely the wrong end of the stick
09:48:14 <thetallguy> cpoucet: I don't know, haven't read the book yet, just read Dominus' blog and ordered.
09:48:14 <vixey> actually though it's not out just yet, CReal should have correctness proofs too
09:48:32 <vixey> but yeah anyway hope some of that stuff is interesting, see you later
09:48:43 <thetallguy> cpoucet: but I'm guessing you'd be in the 'he's a crackpot' camp... ;-)
09:49:22 <lesshaste> vixey, thanks
09:49:54 <cpoucet> thetallguy: potentially
09:50:05 <cpoucet> thetallguy: mostly a "where the hell would he even get evidence" ccamp
09:50:46 <MyCatVerbs> ...ahhh, fecksake. It *is* possible to upgrade Cabal without needing to upgrade Cabal first, right? :/
09:54:02 <gwern> 'And I point to my friend Barry [pretending it's him], and I'm like: "Let's say they want to do something in a programming language that's not one of the supported Google languages. You know, like what if they wanted to use, you know, Haskell?"
09:54:06 <gwern> What I really wanted to do at the time was use Lisp, actually, but I didn't say it. And [Alan] goes, "Well!" He says, "Well... how would you feel if there was a team out there who said they were gonna use... LISP!" [(laughter)]'
09:57:40 <twobitwork> do darcs repos use a trunk/brances/tags directory structure like subversion?
09:57:48 <opqdonut> no
09:57:56 <opqdonut> each darcs repo is a "branch"
09:57:58 <twobitwork> or are branches and tags etc built into darcs somehow?
09:58:03 <opqdonut> tags are built-in
09:58:06 <opqdonut> (they're just patches)
09:58:34 <opqdonut> if you want to branch, you clone the repo
09:58:46 <opqdonut> so merging between branches becomes push/pull between the repos
09:58:53 <twobitwork> ok, I see
09:59:09 <gwern> 'Instead, they introduced generics, right, which is this huge, massive, category-theoretic type system that they brought in, where you have to under  to actually use it you have to know the difference between covariant and contravariant return [and argument] types, and you have to understand why every single mathematical... [I tail off in strangled frustration...]' <-- well, it's fairly clear why yegge isn't thrilled with haskell :)
09:59:25 <thetallguy> cpoucet: psychologists always seem a little vague on that point
09:59:45 <opqdonut> gwern: and besides, generics are a really lightweight extension
09:59:55 <bos> dear #haskell, your friendly authors seek suggestions: http://www.realworldhaskell.org/blog/2008/05/12/wanted-a-small-portable-useful-c-library/
09:59:55 <lambdabot> bos: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:59:57 <lambdabot> Title: Real World Haskell  Blog Archive  Wanted: a small, portable, useful C library, http://tinyurl.com/5al64q
10:00:23 <bos> @seen dcoutts
10:00:23 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #haskell-blah. I don't know when dcoutts last spoke.
10:00:25 <bos> @seen dcoutts_
10:00:25 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I don't know when dcoutts_ last spoke.
10:00:27 <bos> huh.
10:00:42 <gwern> opqdonut: makes one wonder how he'd react to oleg's stuff
10:01:07 <Shimei3> I wasn't too clear what Yegge's problem was with Java generics. The covariance stuff can be explained to first year undergrads. Unless there's more to it than that.
10:01:37 <gwern> Shimei3: too restrictive, it seems
10:01:45 <mrd> java is messed up because they didn't understand the difference between covariant and contravariant when designing it
10:03:15 <gwern> 'We overflowed a "long" at Google once. Nobody thought that was possible, but it actually happened. I'll tell you about that later if you want to know.'
10:03:19 <opqdonut> gwern: heh yeah
10:04:20 <vixey> :t fix `ap` fix
10:04:23 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
10:04:24 <lambdabot>     Probable cause: `fix' is applied to too few arguments
10:04:24 <lambdabot>     In the second argument of `ap', namely `fix'
10:04:53 <cpoucet> > sort "evilterran" == sort "irrelevant"
10:04:55 <lambdabot>  True
10:04:57 <opqdonut> :D:D
10:05:15 <EvilTerran> :D
10:05:23 <vixey> nice !
10:05:23 <vixey> permutation = (==)`on`sort
10:07:24 <byorgey> > sort "evilterran" == sort "relentivar"
10:07:25 <lambdabot>  True
10:07:31 <SamB> > iterate ((==)`on`sort) "hello"
10:07:32 <lambdabot>  Couldn't match expected type `[a]'
10:07:44 <twobitwork> bos: there you go, I gave my suggestion... let me know what you think
10:07:52 <SamB> @t iterate
10:07:52 <lambdabot> Maybe you meant: tell temp thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:07:55 <SamB> @ty iterate
10:07:57 <lambdabot> forall a. (a -> a) -> a -> [a]
10:08:07 <SamB> :t ((==)`on`sort) "hello"
10:08:09 <lambdabot> Not in scope: `on'
10:08:19 <bos> twobitwork: i don't think it's too likely, but thanks.
10:08:23 <SamB> > ((==)`on`sort) "hello"
10:08:24 <lambdabot>  <[Char] -> Bool>
10:08:33 <SamB> oh.
10:08:35 <SamB> okay...
10:08:45 <vixey> @src on
10:08:46 <lambdabot> (*) `on` f = \x y -> f x * f y
10:08:48 <byorgey> maybe a better name for (==)`on`sort would be 'isPermutation' =)
10:09:02 <SamB> permutation of what?
10:09:06 <byorgey> > ((==)`on`sort) "evilterran" "vileranter"
10:09:07 <lambdabot>  True
10:09:15 <vixey> True == permutation "foo" X --> X == "oof" ; X = "ofo" ; ... :P
10:09:18 <byorgey> or better yet, 'isPermutationOf'
10:09:21 <twobitwork> bos: alright... thought it was worth a try :)
10:09:23 <SamB> oh. wait. I still had the hello there ;-)P
10:09:40 <byorgey> > let isPermutationOf = ((==)`on`sort) in "evilterran" `isPermutationOf` "vileranter"
10:09:41 <lambdabot>  True
10:10:06 <SamB> :t sortBy
10:10:08 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
10:10:56 <oerjan> @users
10:10:56 <lambdabot> Maximum users seen in #haskell: 463, currently: 436 (94.2%), active: 21 (4.8%)
10:11:56 <Bonus> if an operator is infixr
10:12:02 <Bonus> that means that
10:12:23 <Bonus> ((b `op` c) `op` d) = b `op` c `op` d
10:12:27 <Bonus> or is it the other way around
10:12:30 <byorgey> other way.
10:12:35 <Bonus> ah, right
10:12:39 <twobitwork> my ghci doesn't have `on`
10:12:41 <byorgey> the R in infixr is for 'right'
10:12:44 <vixey> @src on
10:12:45 <lambdabot> (*) `on` f = \x y -> f x * f y
10:12:56 <Bonus> so function application is infixl then?
10:13:01 <byorgey> i.e. the innermost parens are on the right.
10:13:13 <byorgey> Bonus: well, it's not infix
10:13:18 <byorgey> but it does associate to the left, yes
10:13:24 <oerjan> twobitwork: Data.Function module iirc
10:13:24 <Bonus> ah yeah
10:13:33 <Igloo> It is infix, it's just invisible
10:13:43 <byorgey> ah, right, it's ' '
10:14:08 <vixey> I think lambdabots definition is much more attractive than "import Data.Function" though
10:14:16 <oerjan> > (+)2(3) -- what ' '? :)
10:14:17 <lambdabot>  5
10:14:24 <ehird> ThreadId 30: user error (FCGX_Accept_r failed with error code: -88)
10:14:25 <ehird> halp?
10:14:38 <ehird> byorgey: it's ''
10:14:43 <ehird> it would be () but that's taken
10:14:44 <byorgey> this is why ($) ought to be infixl.
10:14:52 <ehird> () :: (a -> b) -> a -> b
10:15:19 <Igloo> No, it's why it ought to be infixr - we already have an infixl apply
10:16:07 <byorgey> well, that depends on whether you think the point of ($) is to provide function application with a different precedence or a different associativity than ''.
10:16:10 <byorgey> currently it does both.
10:16:38 <Bonus> i use it mostly for f . g . h $ x
10:21:46 <ehird> ThreadId 39: user error (FCGX_Accept_r failed with error code: -88)
10:21:49 <ehird> :(
10:25:01 <schme> Ok. So I have been hackin' around with haskell for a few days. I might be missin' something but I'm not getting the omg! this is awesome!-rush I have been told about. :(
10:25:34 <Bonus> hmm
10:25:45 <Bonus> i got it AFTER learning haskell
10:25:53 <schme> Ok.
10:25:57 <byorgey> schme: sometimes it takes more than a few days.
10:26:01 <Bonus> i tried to learn it 2 times and gave up
10:26:08 <Bonus> then the 3rd time it just clicked
10:26:12 <Bonus> and i was like: WOWOW
10:26:16 <byorgey> schme: but we can also help with it.
10:26:22 <schme> Great. :)
10:26:29 <Bonus> try using it to solve some projecteuler.net problems
10:26:33 <Bonus> and hanging around here a bit :)
10:26:35 <byorgey> schme: what have you been using in order to learn, and what kinds of things have you been hacking on?
10:27:07 <schme> My issue now is that I was doing a mergesort thingie and it struck me that I can't for the life of me figure out how to efficiently split a list into two, and arrays Ihave no idea at all how to work with here.
10:27:30 <schme> byorgey: Well I have been doing some random exercises and porting a backgammon client I wrote in another language some time ago.
10:27:54 <vixey> schme: split in two, which two?
10:28:26 <dcoutts_> bos: pong
10:28:27 <schme> vixey: good call. split in two at half way I'd say.
10:28:46 <vixey> mm this is a trick one :P
10:28:56 <vixey> I think it's possible in n+n/2 steps
10:29:22 <vixey> http://www.iis.sinica.edu.tw/~scm/2007/zipping-half-of-a-list-with-its-reversal/
10:29:24 <lambdabot> Title: Zipping Half of a List with Its Reversal | for the few of us., http://tinyurl.com/6lbuy3
10:29:29 <dcoutts_> MyCatVerbs: yes, it is possible to bootstrap Cabal without any existing version of Cabal (indeed it always bootstraps itself without using any existing version)
10:29:52 <schme> vixey: I'll take a looksy at that
10:29:59 <vixey> this is really cool :)
10:30:31 <dolio> Heh, convolute.
10:31:04 <schme> It just seems bad to me that you have to traverse the whole thing just to split it at midpoint.
10:31:10 <byorgey> schme: also, I should point out that porting something written in another language will probably not give you the 'omg! this is awesome!-rush', since you will most likely be trying to shoehorn the particular way you did things with the other program into Haskell.
10:31:22 <byorgey> whereas the natural way to do it in Haskell would probably be very different.
10:31:24 <vixey> of course, otherwise how would you know you're at the middle?
10:31:30 <schme> byorgey: No, I'm not especially doing it that way no.
10:31:33 <MyCatVerbs> dcoutts_: ah, ignore me, I was just whining.
10:31:45 <schme> vixey: Normally I'd use indexed arrays.
10:31:50 <dcoutts_> MyCatVerbs: did it work?
10:31:52 <byorgey> schme: mergesort is a case in point; this algorithm doesn't particularly lend itself to a functional approach.
10:31:57 <byorgey> schme: ok, fair enough.
10:32:07 <MyCatVerbs> dcoutts_: I thought it was impossible to install Filepath without a current version of Cabal. Actually it compiled and installed just fine.
10:32:20 <MyCatVerbs> dcoutts_: s/whining/panicking/, actually, come to think of it.
10:32:36 <schme> byorgey: I'm even trying to use that there wxhaskell thang. So it's added bonus with learning a graphics toolkit I have no idea how to use.
10:32:38 <byorgey> if I were to write mergesort, however, I'd split the list in half by taking every other element
10:32:41 <dcoutts_> MyCatVerbs: ah yes, that was a bit tricky since we started depending on filepath, so it does make bootstrapping a little harder
10:32:48 <byorgey> schme: hehe
10:33:05 <schme> That's the problem there though. It seems very hard to escape the functional approach to things.
10:33:09 <dcoutts_> MyCatVerbs: in the worst case one can ghc --make Setup.hs -i../filepath-1.0/
10:33:19 <schme> byorgey: That's how I splat it too!
10:33:28 <dolio> Bottom-up mergesort should be fine, no?
10:33:36 <MyCatVerbs> dcoutts_: except that whoever wrote filepath was kind enough to make sure it doesn't rely on anything on Earth, or even require a version of Cabal newer than, say, the last The Who album. ^^
10:33:46 <dcoutts_> MyCatVerbs: heh, right :-)
10:33:47 <MyCatVerbs> dcoutts_: oooh, thanks, I'll have to remember that one.
10:33:58 <byorgey> dolio: what's that?
10:34:21 <dcoutts_> MyCatVerbs: though that'd be used to make a setup that can be used to install filepath, since Cabal will still want an installed filepath package
10:34:24 <dolio> byorgey: Instead of dividing by half, sorting and merging, you start by turning everything into singleton lists, and then merging pair-wise.
10:34:51 <dolio> Or, use something more clever to divide up the list into chunks initially, perhaps.
10:34:56 <byorgey> schme: but you almost never need to escape the functional approach.  Thinking that you need to 'escape' is a sign that you have not yet fully embraced the functional way =)
10:35:21 <oerjan> dolio: i was just going to suggest that
10:35:36 <schme> byorgey: Eh. I need to escape it when there is a faster way though.
10:35:39 <byorgey> aha, clever
10:35:40 <schme> byorgey: That's the problem.
10:36:24 <byorgey> schme: well, the 'omg! this is awesome!-rush' usually corresponds to when you begin to think functionally and see how nice it can be.
10:36:39 <byorgey> schme: hang in there, you will get it =)
10:37:03 <schme> byorgey: Oh. it's just the FP-rush then? haha :)
10:37:25 <schme> I thought there was sumthin' special about haskell here. I have been hearing great ravings about it.
10:37:39 <vixey> there is
10:37:39 <schme> (apart from the darned nice wm) :)
10:37:46 <byorgey> schme: well, there ARE other components, but if you've never used any FP languages before, that's the major part of it
10:37:59 <schme> hmm ok.
10:38:09 <schme> Well that's nice.
10:38:17 <byorgey> but there certainly are reasons why haskell compares favorably in many ways to other functional languages.
10:38:17 <oerjan> laziness, static types
10:38:42 <schme> Oh I don't need a list of good stuff! don't get me wrong here :)
10:39:58 <schme> Well I'll see how stuff works out with this.
10:40:12 <schme> thanks for ze help there
10:40:23 <vixey> where did the list come from? (the one you want to split in half)
10:40:40 <schme> from my keyboard.
10:41:53 <schme> (where all good lists come from)
10:45:08 <schme> vixey: Does it really matter though?
10:45:15 <ehird> anyone?
10:46:39 <vixey> not really, just that sometimes there are extra things to exploit
10:46:40 <MyCatVerbs> dolio: dcoutts_ gave me this a while back: { snap (a:b:cs) = let (foo,bar) = snap cs in (a:foo,b:bar); snap a = (a,[]); } which can be used recursively like...
10:46:45 <wolverian> what are lifted arrays in ndp?
10:47:25 <dcoutts_> wolverian: I presume they're arrays of boxed things, so they're polymorphic, as opposed to unboxed arrays
10:47:30 <schme> vixey: ah ok :)
10:47:45 <wolverian> dcoutts_, ah.
10:48:47 <MyCatVerbs> dolio: ...using that for mconcat on commutative monoids: { abcat [] = mempty; abcat [a] = a; abcat l = let (links,recht) = snap l in (abcat links) `mappen` (abcat recht); }
10:52:37 <MyCatVerbs> dolio: ...and then newtype SortMePlease a = Sorty [a]; instance (Ord a) => Monoid (SortMePlease a) where mempty = Sorty []; (Sorty l) `mappend` (Sorty m) = merge l m, and let sort l = unSorty (abcat . map Sorty $ l)
10:53:26 <schme> Hmm. Maybe I should just take a break from this for a year or two and come back and see if it works better for me then. Too bad. seems a nice channel here :)
10:54:19 <ehird> schme: nooooooo!
10:54:38 <schme> :(
10:54:44 <vixey> scheme: aww what's wrong?
10:54:54 <schme> heh. izza just not working so well for me :)
10:55:11 <vixey> code? or something else
10:56:04 <vixey> well one possibility is to use naive algorithims/methods and optimize for speed once things are working and need improvement
10:56:07 <schme> vixey: No, I meant Haskell in general. the language. It's not working for me.
10:56:20 <vixey> using GHC?
10:56:30 <schme> Haha. Yes, I am using GHC.
10:59:21 <schme> vixey: I doubt it would make much difference :)
11:00:27 <dolio> http://hpaste.org/7568
11:01:23 <dolio> That might not be stable. replace (<) with (<=) and so on as necessary until it is. :)
11:01:39 <byorgey> schme: of course, you should make your own decision.  But I would like to point out that anything worthwhile is likely to be difficult and frustrating at first.
11:02:00 <schme> byorgey: hahah :)
11:02:21 <schme> byorgey: You are indeed very right there.
11:02:28 <Bonus> or you can just come back to it later
11:02:32 <Bonus> like i said i gave up 2 times
11:02:36 <byorgey> that doesn't necessarily mean that it doesn't/can't/won't work for you.  you just might have to work hard and force your way through the initial frustration.
11:02:39 <Bonus> i didnt see the point
11:02:46 <schme> Mmm..
11:02:47 <Bonus> and then it dawned on me and now its my favourite language
11:02:54 <schme> Bonus: congrats.
11:02:57 <vixey> well I read this book about Haskell maybe 2 years ago?
11:02:57 <Bonus> heh
11:03:02 <vixey> and I thought, this is rubbish :P
11:03:20 <vixey> but yeah I came back and wrote actual programs in it which changed my mind a lot
11:03:36 <Bonus> hehe i loaded up hugs
11:03:41 <Bonus> and i didnt know how to define a function
11:03:44 <Bonus> i was like wtf
11:03:51 <vixey> lol
11:03:56 <Bonus> a lot of tutorials miss that part out though
11:03:59 <schme> It has certain characteristics that I'm not so fond off though.
11:03:59 <schme> vixey: What changed yer mind about it then?
11:04:11 <Bonus> they say: we have a function that's like fac a = ...
11:04:33 <Bonus> but lots of them dont say how you define it in a file and load the file into the interactive interpreter
11:05:07 <byorgey> Bonus: yeah, that's an unfortunate omission =(
11:05:17 <schme> I did run across a few tutorials that seemed to leave essential stuff out.. like how to actually do anything interesting.
11:06:01 <byorgey> yeah, writing good tutorials is hard.
11:06:09 <byorgey> ...let's go shopping! ;)
11:06:16 <vixey> :)
11:06:29 <saml> all `operators` are binary?
11:06:30 <Bonus> the introduction in dons' book is really good though
11:06:33 <Bonus> i wish i had read that earlier
11:06:46 <vixey> saml: no
11:06:46 <byorgey> saml: technically, they don't have to be.
11:06:53 <byorgey> saml: but kind of useless otherwise.
11:06:58 <Bonus> yeah
11:07:00 <vixey> > let (`foo` x) = x in (`foo` 7)
11:07:01 <lambdabot>  Parse error in pattern at "in" (column 19)
11:07:03 <vixey> :/
11:07:07 <thief_grr> any book recommendations for denotational semantics of functional and/or logic programming?
11:07:13 <byorgey> > let foo x = x in (`foo` 7)
11:07:14 <lambdabot>  Add a type signature
11:07:14 <Bonus> > let foo a b c = a + b + c
11:07:15 <lambdabot>  Parse error at end of input
11:07:29 <Bonus> 3 `foo` 2 3
11:07:36 <saml> > let a `op'` b c = a + b + c in 1 `op'` 2 3
11:07:36 <lambdabot>  Parse error in pattern at "in" (column 29)
11:07:42 <dcoutts_> @seen bos
11:07:42 <lambdabot> bos is in #haskell and #ghc. I last heard bos speak 59m 23s ago.
11:07:46 <schme> Anyways. My issue is this; my mind does not like static typing . I can't seem to getting around to finding it anything but very frustrating.
11:07:53 <vixey> > let foo x = x in (7 `foo`)
11:07:55 <lambdabot>  7
11:07:57 <schme> any ideas how to solve that one?
11:08:00 <swiert> thief_grr: http://www.amazon.com/Domain-theoretic-Foundations-Functional-Programming-Streicher/dp/9812701427
11:08:01 <lambdabot> swiert: You have 1 new message. '/msg lambdabot @messages' to read it.
11:08:02 <bos> dcoutts_: i got rid of the use of tags from that example.
11:08:02 <lambdabot> http://tinyurl.com/6noqh8
11:08:10 <dcoutts_> bos: great
11:08:18 <bos> dcoutts_: but if tags are so useless, they should presumably be eliminated entirely.
11:08:19 <twanvl> > let (!) x = product [1..x] in (5!)
11:08:20 <lambdabot>  120
11:08:21 <saml> > let op a b c = a + b + c in 1 `op` 2 3
11:08:22 <lambdabot>   add an instance declaration for (Num (t -> t1))
11:08:26 <dcoutts_> bos: I'd argue so, yes
11:08:32 <byorgey> schme: ah, I can see how that would be a big block indeed.
11:08:38 <saml> oh parens
11:08:43 <byorgey> schme: what in particular has frustrated you about it?
11:08:46 <thief_grr> swiert: fresh!
11:08:58 <schme> byorgey: I had the same problem when playing around with SML and other statics.
11:09:08 <saml> > let op a b c = a + b + c in (1 `op` 2) 3  -- so syntactically, `op` takes one arguemtn from left and one from right
11:09:10 <lambdabot>  6
11:09:12 <megeria> schme: type inferences helps a lot with the static typing
11:09:12 <schme> byorgey: hmm.. Idon't know really. That's a very good question.
11:09:34 <schme> megeria: horray for inferences. :)
11:09:35 <thief_grr> swiert: thanks ;)  was trying to find lloyd's on logic programming but it seems to be really hard to find..
11:09:39 <byorgey> schme: when I was first learning Haskell I was very frustrated by all the different numeric types, and I felt like I was always having to fromIntegral this and round that and blah blah.
11:10:05 <schme> great.
11:10:13 <schme> byorgey: Yes that is a pain.
11:10:42 <schme> ech. I'll just try to finish this one app then I'll see how I'll feel.
11:11:00 <byorgey> schme: static typing really shines when you define your own data types and manipulate data in more complicated ways.
11:11:14 <byorgey> schme: many bugs which would otherwise be runtime errors turn into type errors.
11:11:31 <schme> runtime errors are quite ok :)
11:12:15 <byorgey> schme: but they're not, because they might not turn up until after you think your program has been tested thoroughly. =)
11:12:17 <schme> You seem to be an extremely helpful channel though. That's a good bonus.
11:12:30 <vixey> runtime errors are not ok :|
11:12:31 <schme> a bit obsessed with playing with the bot! but helpful. :)
11:12:47 <vixey> lol
11:12:55 <vixey> @botsnock
11:12:55 <lambdabot> :)
11:12:56 <schme> ech. runtime error drops into the debugger. user enters new value and continues. all is well :)
11:13:07 <Bonus> did anyone else snortle a little when they read Those who would give up essential type safety, to purchase a little temporary liberty, deserve neither liberty nor type safety.
11:13:11 <Bonus> on dons' blog
11:13:17 <Bonus> i did
11:13:23 <byorgey> schme: you know as well as I do that the cause of a runtime error is often very non-obvious.
11:13:36 <schme> Bonus: where is that blog?
11:13:40 <byorgey> schme: have you ever spent a half an hour tracking down some bug which turned out to be some silly mistake?
11:13:42 <vixey> Haskell is capable of runtime errors of course :P
11:13:44 <Bonus> http://www.cse.unsw.edu.au/~dons/blog/2008/05/12#rewriting-classes
11:13:46 <lambdabot> Title: Haskell hacking, http://tinyurl.com/64mle5
11:13:53 <schme> byorgey: much much more than half an hour.
11:14:21 <s_clv> @quote liberty
11:14:21 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
11:14:36 <lispy> ?quote safety
11:14:37 <lambdabot> sigfpe says: Haskell is so strict about type safety that randomly generated snippets of code that successfully typecheck are likely to do something useful, even if you've no idea what that useful
11:14:37 <lambdabot> thing is.
11:14:40 <byorgey> schme: indeed.  Well, I think I have done that approximately once or twice, ever, since I started using Haskell.  It just happens much more rarely.  And it isn't because I am some sort of amazing superhuman programmer.
11:14:51 <s_clv> @remember dons Those who would give up essential type safety, to purchase a little liberty, deserve neither liberty nor type safety.
11:14:51 <lambdabot> I will remember.
11:15:13 <lispy> ?quote safety
11:15:14 <lambdabot> qwe1234 says: the only reason for 'dispatching, polymorphism and parametrization' to exist at all is for enforcing safety.
11:15:21 <schme> byorgey: that is good though.
11:15:42 <dolio> I didn't really get that blog entry. Shouldn't GHC do that optimization itself?
11:15:59 <schme> that's about it. the no-way to escape FP, the static typing, and the syntax. If I just get over those three all should be well I guess.
11:16:09 <wjt> dons' hack is just a nice observation, not something that type classes and GHC's other optimizations can't do, right?
11:17:22 <dons> wjt: right.
11:17:32 <dons> type classes are already statically resolved when possible
11:18:07 <dons> it does illustrate a useful technique though -- compile time replacement of known functions base on their type (i.e. for specialisation), when there's no type class handy
11:18:55 <wjt> dons: hmm, when might you not have a type class handy?
11:19:33 <dons> say i want to specialise fromIntegral for some type
11:19:36 <s_clv> there's also the specialize pragma, no?
11:19:38 <dons> :t fromIntegral
11:19:40 <lambdabot> forall a b. (Num b, Integral a) => a -> b
11:19:52 <dons> yeah, there's SPECIALIZE, but it doesn't let you do ad hoc specialisation
11:20:12 <dons> i.e. i can't specialise round :: Float -> Float to c_round
11:20:34 <dons> so its like the difference between auto-deriving, and writing your own instance
11:20:40 <wjt> @src fromIntegral
11:20:41 <lambdabot> fromIntegral = fromInteger . toInteger
11:20:43 <dons> specialising via rules, or via the pragma
11:20:45 <s_clv> ah, gotcha.
11:20:48 <wjt> ah, okay, i see
11:20:55 <dons> so i might write:
11:21:05 <dons> RULE fromIntegral = id :: Int -> Int
11:21:14 <dons> which also wouldn't be a specialisation pragma result
11:21:21 <dons> its domain knowledge specialisation
11:21:29 <wjt> can you write RULE fromIntegral = id :: a -> a  ?
11:21:50 <dons> i think its a bit fragile, but there are some rules like that
11:27:19 <vixey> looks like a typo
11:27:22 <vixey> http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
11:27:24 <lambdabot> Title: 8.13. Rewrite rules, http://tinyurl.com/y7rk9g
11:27:28 <vixey>   "loop"        forall x,y.  f x y = f y x
11:27:34 <vixey> shouldn't have a , there should it?
11:28:02 <dons> right. that's a typo
11:28:05 <dons> i'll fix it.
11:28:26 <ehird> Nobody?
11:28:33 <vixey> If I do ghc -O3 -fglasgow-exts --make tmp.hs
11:28:43 <vixey> should rules fire? because it's not looping forever for me
11:29:00 <dons> what's in tmp.hs ?
11:29:01 <vixey> actually nevermind, I will just try the code in that paste
11:29:07 <vixey> f = undefined
11:29:11 <vixey> {-# RULES
11:29:11 <vixey>     "loop"        forall x y.  f x y = f y x
11:29:11 <vixey>   #-}
11:29:15 <vixey> main = putStrLn (f 1 2)
11:29:17 <vixey> just that much
11:29:19 <dons> vixey: i just pushed a patch for your typo
11:29:23 <vixey> cool :)
11:29:47 <dons> you might need to control the inlining of 'f'
11:29:54 <dons> {-# NOINLINE f #-}
11:30:06 <vixey> yay
11:30:07 <vixey> :D
11:30:11 <vixey> thank you dons
11:30:16 <dons> that was it?
11:30:19 <vixey> yes
11:30:36 <dons> in general, you should disable until later the inlining of functions whose names you wish to match on
11:32:40 <byorgey> ehird: ?
11:32:59 <ehird> byorgey: ThreadId 27: user error (FCGX_Accept_r failed with error code: -88)
11:33:09 <ehird> it always exits with that error
11:33:15 <byorgey> oh, ouch
11:33:45 * byorgey suggests disabling thread #27 since there is clearly something wrong with that one  ;)
11:34:56 <dcoutts_> dons: can we not write rules that match on types like RULES "fromIntegral::a->a" forall a. (fromIntegral :: a -> a) = id
11:35:15 <dcoutts_> dons: ghc tells me it's not of the form (f a b c) where f is not forall'ed over
11:35:25 <ehird> byorgey: Very amusing.
11:35:29 <ehird> That was just one example.
11:35:30 <dons> what if the type is attached to id?
11:35:33 <ehird> It's just that fcgi just doesn't work
11:35:46 <dons> fromIntegral = id :: a -> a
11:35:46 <dcoutts_> dons: then 'a' does not appear in the rule LHS and ghc complains
11:35:49 <dons> ah
11:36:00 <dons> but there *are* some rules like this in ghc/base
11:36:18 <dcoutts_> dons: for constant types or for forall'ed ones?
11:36:40 <dcoutts_> dons: for constant ones it's ok to put the :: annotation on the RHS
11:36:51 <dons> ah,
11:36:52 <dons> "fromIntegral/a->Int32"      fromIntegral = \x -> case fromIntegral x of I# x# -> I32# (narrow32Int# x#)
11:37:09 <dons> "fromIntegral/Int32->a"      fromIntegral = \(I32# x#) -> fromIntegral (I# x#)
11:37:32 <dcoutts_> mm, so what about fromIntegral = id
11:37:40 <dcoutts_> that can only have the type a -> a for some a
11:37:59 <ehird> dcoutts: presumably, that if you have a fromIntegral from a -> a, it's id
11:38:38 <dcoutts_> ehird: you might hope so but it's not guaranteed so we cannot actually use such a rule, I was just wondering if we could write it at all though
11:38:51 <ehird> dcoutts: well i'd use it anyone who does anything else is broken ;)
11:38:58 <ehird> & hard to imagine
11:39:10 <dcoutts_> yes, but doesn't mean they cannot do it
11:39:11 <ehird> If optimizations break when you don't follow the rules .. well .. suprise?.
11:39:21 <dcoutts_> ehird: then the compiler is broken, sadly
11:39:35 <ehird> dcoutts: I sure wouldn't accuse it of anything :-)
11:43:53 <lilac> In this blog entry: http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/12  can one not apply the same rewrite rules to ==, and get the EqDict-style lookup in the case where the rule fails to fire for whatever reason?
11:43:55 <lambdabot> Title: Haskell hacking
11:53:13 <schme> right.
11:53:49 <saml> newtype Foo a = Foo { runFoo :: Monad1T (Monad2T IO) a} deriving(MonadIO, Monad, Functor, Monad1, -- why can't I put Monad2 here?
11:53:56 <lilac> although presumably in such cases any decent compiler would  do that for you?
11:54:13 <lilac> in which case, every time the optimization fires, it's redundant?
11:54:27 <saml> ah i see why i need to make Monad1T instance of Monad2
11:54:53 <schme> Well #haskell. It was a nice week here. Maybe I'll pop by some time. I'll go back to the ()'s now. Ta ta, thanks for the help :)
11:56:42 <tero-> hm. who should I report that libghc6-hsql-sqlite3-dev does not work in ubuntu?
11:57:11 <tero-> for some reason it does not link against libsqlite3
11:58:26 <saml> /usr/lib/ghc-6.8.2/lib/mtl-1.1.0.0/Control/Monad/State  is a directory. how can I import Control.Monad.State ?
12:00:37 <dolio> There should be .../Control/Monad/State.hs, too.
12:00:56 <saml> ah indeed!
12:22:50 <saml> module Foo (module FooClass) where ...  is there a way to export some modules and all toplvel definitions?
12:24:11 <mauke> try exporting yourself (module Foo)
12:24:53 <saml> mauke: hoa thanks!
12:25:17 <twobitwork> Setup.hs (in a cabal package) complains that it cannot match type "GHC.IOBase.ExitCode"
12:27:04 <twobitwork> I have the debian package "libhugs-cabal" installed...
12:29:13 <ehird> So. Does nobody want to halp with fastcgi?
12:30:10 <gwern> twobitwork: that's interesting. shouldn't ExitCode be coming from System.Exit?
12:31:11 <twobitwork> gwern: I don't know :P ... I just downloaded this package and tried installing it :)
12:31:23 <gwern> twobitwork: which one is't?
12:31:46 <twobitwork> the Yaml reference implementation
12:32:28 <gwern> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/YamlReference ?
12:32:31 <lambdabot> http://tinyurl.com/5v2k59
12:32:39 <twobitwork> http://www.ben-kiki.org/oren/YamlReference/
12:32:40 <lambdabot> Title: YamlReference
12:32:48 <roconnor> @kind []
12:32:54 <twobitwork> that's the one that's linked to from the yaml website
12:32:58 <lambdabot> * -> *
12:33:16 * gwern needs dlist first.
12:33:39 <roconnor> @kind WriterT (Product Double) []
12:33:41 <lambdabot> * -> *
12:33:46 <twobitwork> but yeah, the page you pointed to, points to the page I got it from
12:33:47 <gwern> twobitwork: while I'm looking at it, why not paste the terminal transcript into hpaste?
12:33:52 <twobitwork> k
12:34:00 <ehird> <gwern> twobitwork: that's interesting. shouldn't ExitCode be coming from System.Exit?
12:34:00 <ehird> no
12:34:02 <ehird> ghc has it internally
12:34:04 <ehird> and re-exports it
12:34:12 <ehird> Just like IO is really GHC.IOBase.IO
12:34:35 <gwern> ehird: hm, but then why is the error tracking it all the way back? and isn't twobitwork using hugs?
12:34:51 <twobitwork> http://hpaste.org/7569
12:35:09 <gwern> he said he's using 'libhugs-cabal'
12:35:27 <ehird> gwern: Obviously he's using hugs but used ghc for that
12:35:29 <twobitwork> ahh.. right... I didn't see a libghc-cabal...
12:35:29 <ehird> maybe runhaskell is runghc
12:35:45 <twobitwork> I'll try using hugs to install
12:36:05 <Igloo> Things are generally a lot simpler if you compile Setup
12:36:24 <roconnor> 5 + 6 :: Product Double
12:36:26 <gwern> ehird: well ok, I just thought that if he's using hugs, then perhaps the package was being bad and specifically importing the GHC originals
12:36:30 <roconnor> > 5 + 6 :: Product Double
12:36:31 <lambdabot>        add an instance declaration for (Num (Product Double))
12:36:36 <gwern> since I couldn't see how a GHC module could ever pop up as a hugs error
12:36:39 <ehird> twobitwork: no
12:36:40 <ehird> I'd use ghc.;
12:36:45 <ehird> Use libghc-cabal.
12:36:47 <ehird> Or whatever.
12:36:56 <ehird> Hugs sucks. In my opinion. :P
12:37:08 <ehird> Now. Regarding fastcgi...
12:37:13 <roconnor> > 5 `mappend` 6 :: Product Double
12:37:14 <lambdabot>        add an instance declaration for (Num (Product Double))
12:37:21 <ehird> ThreadId 28: user error (FCGX_Accept_r failed with error code: -88)
12:37:33 <roconnor> oooh
12:37:38 <twobitwork> ehird: which one should I use http://hpaste.org/7570
12:37:49 <twobitwork> I don't have a libghc-cabal, but I have a libghc-cabal-dev
12:37:59 <ehird> twobitwork: libghc6-cabal
12:38:06 <gwern> twobitwork: the issue here is that Setup.hs in Yaml* is doing some testing and cleaning, which doesn't seem strictly necessary. so you *could* nuke the Setup.hs and copy in a simpler Setup.hs from somewhere else
12:38:08 <ehird> and remove the hugs one
12:38:15 <Igloo> Cabal is in ghc6, assuming this is Debian-like
12:38:15 <ehird> gwern: No.
12:38:16 * gwern is just sayin'
12:38:20 <ehird> The issue is that he doesn't have the right ghc package.
12:38:25 <ehird> Igloo: Oh, of course!
12:38:28 <ehird> twobitwork: you don't need anything
12:38:31 <ehird> you already have cabal
12:38:33 <ehird> so remove the hugs package
12:38:47 <twobitwork> ok
12:39:04 <gwern> ehird: he has some sort of cabal package working; the error looks to me like a cabal version mismatch
12:39:11 <gwern> the hooks and stuff bitrot easily
12:39:16 <saml> how do you determine order of transformer stack?
12:39:28 <ehird> SamB: Magick
12:39:33 <ehird> @mtl a -> (a,b)
12:39:33 <lambdabot> Maybe you meant: ft map msg pl unmtl url
12:39:39 <ehird> unmtl but no mtl?
12:39:40 <ehird> Shame
12:40:09 <saml> i have TIT (type inference transformer), EvalT, ErrorT
12:40:48 <saml> when I have ErrorT at the top, it can't derive MonadEval, which is my custom class
12:41:21 <twobitwork> ok, I removed libhugs-cabal, and I get the same error
12:41:57 <gwern> twobitwork: now try nuking the Setup.hs and replacing with a simpler one?
12:42:10 <twobitwork> where would I get a "simpler" one?"
12:42:42 <twobitwork> the pone provided seems pretty simple
12:42:54 <twobitwork> one*
12:43:07 <gwern> twobitwork: oh, there are setup.hses all over the place.  eg http://hpaste.org/7571
12:43:25 <ehird> Nobody?
12:43:45 <gwern> heck, two liners could work, if you didn't mind compiling it, I suppose
12:44:53 <ehird> Hmmmm wait
12:45:13 <ehird> WTF
12:45:18 <ehird> fcgiapp doesn't define the error code -88
12:45:29 <ehird> What is UP??
12:45:39 <gwern> unpossible!
12:45:54 <ehird> gwern: Pretty much, WTF is goig on
12:46:06 <ehird> Wait a sec.........
12:46:25 <twobitwork> simpleUserHooks not in scope... I changed it with the defaultUserHooks from the original and get:
12:46:28 <twobitwork> Setup.hs: YamlReference.cabal:1215: 'Executable' stanza starting with field 'library
12:46:31 <twobitwork> exposed-modules'
12:46:36 <gwern> aha
12:46:42 <gwern> wait, nm
12:47:15 <ehird> Hm nope
12:47:18 <ehird> I cannot get it fixed
12:47:23 <ehird> gwern: You knwo anything about fastcgi?
12:47:39 <mauke> twobitwork: that usually means your Cabal is too old
12:47:39 <gwern> hm. that *could* be an outdated cabal library you have installed
12:47:39 <gwern> which would also explain the previous setup.hs problem
12:47:44 <gwern> twobitwork: ask apt-get what version of cabal it installed?
12:48:09 <gwern> ehird: sry nope; all I know about fastcgi is it's some sort of way to serve webpages through apache?
12:48:20 <ehird> gwern: not really.
12:48:40 <ehird> OK I have no idea
12:48:43 <ehird> Who knows fcgi?
12:50:09 <Saizan> ehird: try on -cafe maybe
12:50:43 <twobitwork> I have ghc version 6.6.1-2 installed... you said cabal comes with ghc, right?
12:50:45 <ehird> Saizan: Uh it's about the haskell binding.
12:51:44 <Saizan> ehird: i mean the haskell-cafe mailing list.
12:51:56 <gwern> twobitwork: *6.6.1*? oh man. you're in for a world of hurt if you try to use anything recent with that
12:52:05 <ehird> Saizan: oh
12:52:07 <ehird> Well.
12:53:02 <twobitwork> hmm.. what's the current?
12:53:13 <gwern> twobitwork: long story short, 6.6.1 is very old, most if not all packages have broken compatibility with it, and I can only advise proceeding with it if you are lvl 20 or above
12:53:18 <gwern> preferably with some epic loot handy
12:54:00 <twobitwork> lol
12:54:18 <twobitwork> ok, so I should get the current from upstream and build it myself?
12:55:34 <twobitwork> ok, so 6.8.2 is current?
12:55:37 <gwern> twobitwork: why does your debian provide such an outdated one?
12:56:21 <roconnor> @pl (\h t->t++map(h:)t)
12:56:21 <lambdabot> ap (++) . map . (:)
12:56:31 <gwern> twobitwork: yeah
12:56:42 <twobitwork> gwern: not sure... I just did an update and it still shows 6.6.1-2
12:56:52 <gwern> it works fine on 6.8.2 btw
12:56:57 <roconnor> @hoogle ap
12:56:57 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
12:56:57 <lambdabot> Prelude.appendFile :: FilePath -> String -> IO ()
12:56:57 <lambdabot> System.IO.appendFile :: FilePath -> String -> IO ()
12:57:23 <gwern> twobitwork: hm. on debian stable? you could try adding some testing or unstable repos and pinning ghc to a newer version
12:58:21 <pejo> gwern, Debian provides quite a stable environment - things rarely break in updates.
12:58:36 <gwern> pejo: that's because there are so few updates
12:58:36 <twobitwork> gwern: I'm on testing
12:58:44 <pejo> gwern, exactly. :-)
12:58:59 <twobitwork> well... testing is usually fairly up to date
12:59:04 <Saizan> twobitwork: best to pick the statically linked linux binary from the ghc site
12:59:13 <twobitwork> but it depends on the package and how motivated the maintainer is for the package
12:59:25 <twobitwork> Saizan: I'm trying the debian repo linked from the ghc site
12:59:51 <Saizan> oh, i didn't know there were one
13:00:28 <gwern> personally, I feel a little embarassed that haskell support on debian and ubuntu seems so crappy
13:00:41 <gwern> (we don't get these kinds of problems for arch or gentoo)
13:01:00 <twobitwork> http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html
13:01:00 <lambdabot> Title: Haskell Unsafe
13:01:45 <gwern> well, at least the core issue is resolved
13:01:51 * gwern goes back to cabalizing hray
13:01:58 <twobitwork> gwern: thanks
13:02:59 <twobitwork> hmm... looks like the 3rd party repo has the same version as the debian one
13:08:36 <gwern> @tell boegel the link on http://trappist.elis.ugent.be/~kehoste/Haskell/HRay/ to the wiki is broken - shouldbe http://haskell.org/haskellwiki/HRay
13:08:37 <lambdabot> Consider it noted.
13:15:39 <saml> @pl \x -> liftM f (g x)
13:15:40 <lambdabot> fmap f . g
13:16:44 * gwern edits hray. man, I hate projects where the files are literate, but it's done so they can add single line comments sporadically
13:21:42 <s_clv> semi-literate?
13:22:39 * gwern supposes so. I wish they'd just use haddock from the start!
13:27:19 <vixey> :t fmap ?f . ?g
13:27:22 <lambdabot> forall a b (f :: * -> *) a1. (?g::a1 -> f a, Functor f, ?f::a -> b) => a1 -> f b
13:27:24 <vixey> :t (?f .) . ?g
13:27:26 <lambdabot> forall b c a a1. (?g::a1 -> a -> b, ?f::b -> c) => a1 -> a -> c
13:27:29 <vixey> :t (. ?f) . ?g
13:27:32 <lambdabot> forall b c a a1. (?g::a1 -> b -> c, ?f::a -> b) => a1 -> a -> c
13:27:56 <vixey> odd
13:49:09 <gwern> @tell boegel I've sent the cabalization patches; all that's stopping me from uploading to hackage is that there doesn't seem to be any mention of a license? that's bad
13:49:09 <lambdabot> Consider it noted.
14:26:13 <Bonus> if i want a maximum function that works on very big lists, which fold is it best to implement it with?
14:26:15 <Bonus> foldl' ?
14:26:37 <Saizan> yes
14:32:16 <ehird> @src foldl'
14:32:17 <lambdabot> foldl' f a []     = a
14:32:17 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:32:22 <ehird> @src foldl
14:32:22 <lambdabot> foldl f z []     = z
14:32:22 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:32:27 <ehird> hurm
14:40:48 <Beelsebob> @users
14:40:48 <lambdabot> Maximum users seen in #haskell: 463, currently: 447 (96.5%), active: 16 (3.6%)
14:58:59 <dons> interesting, http://reddit.com/info/6j4j8/comments/
15:00:46 <dons> a bit of a headline day for haskell for some reason
15:05:18 <ddarius> What did you find interesting about that?
15:05:53 <dons> ddarius: the general spike in haskell stuff?
15:06:16 <ddarius> Okay.
15:06:23 <dons> oh, not so much the article itself :)
15:06:47 <dons> though always interesting to see OO-ish people dig around with type classes
15:06:59 <ddarius> Well we have Monads For Mort crap, so...
15:07:09 * Nafai has the typeclasses chapter of RWH open in his browser
15:07:36 <hkBst> dons: type classes are just the Haskell way to do OO, no?
15:07:36 <olsner> it's time for people to start realizing that OO isn't any silver bullet either
15:07:54 <ddarius> hkBst: No.
15:07:59 <ddarius> Haskell doesn't do OO.
15:08:37 <Saizan> unless you count OOHaskell
15:08:48 <ddarius> Saizan: Which proves my point.
15:08:56 <Saizan> yeah :)
15:11:11 <tromp> http://www.crunchgear.com/2008/04/30/secret-for-popular-programming-languages-revealed/
15:11:13 <lambdabot> Title: CrunchGear  Archive  Secret for popular programming languages revealed, http://tinyurl.com/6z543c
15:12:06 <tromp> i only recognize 1 in the top 6 photos...
15:14:19 <Zao> tromp: Apparently, Matz (top right, ruby lad) grew his after reading the first article in the series :)
15:15:43 <saml> it's time for a female developer to create a programming language
15:15:48 <wjt> Is there a standard name for either (const Nothing) Just ?
15:16:06 <saml> :t either
15:16:08 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
15:16:22 * edward1 waves hello.
15:16:25 <tromp> thx, zao, i suspected that might be matz...
15:16:59 <olsner> ... but it'll only be a hit if she grows a beard first! :P
15:17:26 <olsner> (or co-authors it with someone who has a beard for two)
15:17:37 <ddarius> 3http://en.wikipedia.org/wiki/Barbara_Liskov
15:19:13 <Zao> ddarius: Your URI scheme is malformed.
15:19:19 <olsner> hmm, unfortunately, since none of the languages she wrote/invented/(co-)authored are very widespread, that does not disprove anything
15:19:23 <solrize> @seen cosmicray
15:19:23 <lambdabot> I saw cosmicray leaving #darcs and #haskell 43m 44s ago, and .
15:19:43 <ddarius> Zao: Your browser just doesn't support Web 3.0
15:20:00 <saml> > let id = fromJust . either (const Nothing) Just . Right in id "hello world"
15:20:04 <lambdabot>  "hello world"
15:20:08 <Zao> ddarius: A scheme name must begin with a letter.
15:20:10 * RayNbow suddenly notices ChanServ
15:20:23 <ddarius> Zao: In your Web <3.0 world.
15:20:26 <RayNbow> how long has ChanServ been in the channel? :p
15:20:51 <Zao> ddarius: Yes, in my RFC 3986 world :P
15:20:53 <dolio> Almost always.
15:24:21 <saml> @src fix
15:24:21 <lambdabot> fix f = let x = f x in x
15:25:38 <RayNbow> @src lambdabot
15:25:38 <lambdabot> Source not found. :(
15:25:40 <RayNbow> aww :p
15:25:57 <ddarius> @version
15:25:57 <lambdabot> lambdabot 4p629, GHC 6.8.2 (Linux i686 2.40GHz)
15:25:57 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:27:06 <RayNbow> ddarius: there's no fun in getting the source code from an external resource :p
15:54:15 <chessguy> @quote
15:54:16 <lambdabot> sebazzz says: <sebazzz> vos no te diste cuenta, pero cuando estas en pedo, y si yo estoy, te saco del alcanse todo objeto contundente
15:54:19 <chessguy> 'evening, haskell
15:55:11 <roconnor> is bytecode one word?
15:55:40 <chessguy> looks like it: http://en.wikipedia.org/wiki/Bytecode
15:56:17 <roconnor> good, that reduces the number of words in my essay by 1
15:56:36 <roconnor> now 302 words
15:56:38 <dobblego> numberofwords is one word
15:56:40 <roconnor> with a 300 word limit
15:58:53 <dmwit> 127.0.0.1 is one double word
15:59:22 <chessguy> double-wide word?
16:05:58 <edwardk> @seen dolio
16:05:59 <lambdabot> dolio is in #haskell-blah and #haskell. I last heard dolio speak 1m 29s ago.
16:06:09 <edwardk> lol
16:07:06 <dmwit> Uh?
16:07:18 <dmwit> I'm in those two channels, and I didn't hear him speak so recently...
16:08:02 <allbery_b> @seen dolio
16:08:02 <lambdabot> dolio is in #haskell-blah and #haskell. I last heard dolio speak 3m 33s ago.
16:08:23 <allbery_b> hm.  did he leave a third channel then, maybe?
16:08:49 <dolio> I had a personal discussion with lambdabot.
16:08:59 <allbery_b> heh
16:09:27 <edwardk> she tattles
16:09:30 * allbery_b was actually wondering if it was a suffix collision, hence his check ("m" can mean "month" or "minute" in that output)
16:09:35 <Saizan> remember that she's underage.
16:09:36 <allbery_b> @activity
16:09:36 <lambdabot> 0*total
16:10:05 <monochrom> /msg lambdabot You are my sun, moon, star.
16:10:27 <dolio> Yes, exactly 1 month and 29 seconds ago. :)
16:11:54 <dmwit> ?seen monochrom
16:11:55 <lambdabot> monochrom is in #haskell. I last heard monochrom speak 1m 49s ago.
16:12:01 <dmwit> Oh, but that doesn't count.
16:12:09 <dmwit> He actually did say it in channel...
16:12:35 <dmwit> ?seen dmwit
16:12:35 <lambdabot> You are in #xmonad, #haskell-blah and #haskell. I last heard you speak just now.
16:13:13 <aoesunthsoneuah> ?seen dmwit
16:13:14 <lambdabot> dmwit has changed nick to aoesunthsoneuah.
16:13:14 <lambdabot> You are in #xmonad, #haskell-blah and #haskell. I last heard you speak just now.
16:13:23 <aoesunthsoneuah> *sigh*
16:13:49 <monochrom> You shouldn't change nick right under her nose.
16:17:02 <ehird> Hello, aoesunthsoneuah.
16:17:08 <ehird> Can I be  aoesunthsoneuah?
16:17:34 <dmwit> Just type /nick aoesunthsoneuah
16:17:46 <ehird> dmwit: Is it registered?
16:17:55 <dmwit> NickServ didn't complain at me.
16:18:09 <nominolo> dvorak ftw!
16:18:15 <nominolo> aoeuidhtns!
16:18:21 <aoesunthsoneuah> aoesunthsoneuah.
16:18:29 <dmwit> nominolo: =)
16:19:02 <nominolo> though, vim-users may disagree
16:19:22 <saml> is [] pattern?
16:19:34 <nominolo> yes
16:19:39 <dmwit> I'm a vim user.
16:19:55 <dmwit> It only takes ~1 week to relearn the binding positions.
16:20:18 <lament> vim on dvorak is actually nicer than vim on qwerty
16:20:26 <lament> because jkhl on qwerty is absolutely retarded
16:20:41 <Beelsebob> heh
16:20:55 <lament> on dvorak it's really convenient :)
16:21:01 <Beelsebob> indeed
16:21:05 <nominolo> i had problems typing  "ls" because it's both right pinky and it was completely undertrained since i rarely used it on querty
16:21:13 <Beelsebob> other than being a character to the left
16:21:35 <lament> yeah, ls is annoying to type
16:21:41 <Beelsebob> hmm, I type ls with right most finger, then pinky
16:21:41 <lament> i always alias ls to "u"
16:21:49 <nominolo> heh
16:22:41 <lament> Beelsebob: that's... really strange
16:22:47 <Beelsebob> it is?
16:23:00 <lament> i can't figure out how you do that
16:23:01 <Beelsebob> actually, come to think of it -- I don't use my pinky on the top row at all
16:23:14 <Beelsebob> I only just realised that I type ? with rightmost finger too
16:23:21 <Beelsebob> similarly +
16:23:22 <dons> anyone remember the justification for CAFs generating worse code?
16:23:22 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
16:23:22 <dons> e.g.
16:23:24 <dons>   returnP a = return a
16:23:24 <dons>   returnP = return
16:23:25 * dmwit doesn't really use jkhl that much in vim
16:23:34 <lament> Beelsebob: on _my_ right hand, pinky is the rightmost finger.
16:23:39 * RayNbow can't think about typing :p
16:23:54 <Beelsebob> lament: haha, sorry, I was making a distinction between pinky and finger
16:24:00 <RayNbow> if I start to think about typing, my typing speed decreases enormously :p
16:24:11 <aoesunthsoneuah> I just use crazy-qwerty-crap.
16:24:14 <aoesunthsoneuah> It's an erratic style.
16:24:24 <aoesunthsoneuah> It's kind of like touch-typing, 'cept without a home row. I don't know. It's frenzied.
16:24:39 <Beelsebob> aoesunthsoneuah: yeh, that's what qwerty encourages you to do
16:24:41 <lament> i think the only error i consistently make is typing 0 with my ring finger
16:24:50 <Beelsebob> becaues crap all is on the home row
16:24:56 <lament> i'm trying to correct that, though
16:25:11 <chessguy> lament, bah, as long as you can do it, and do it fast, who says it's an error?
16:25:12 <Beelsebob> lament: what's wrong with typing o with your ring finger?
16:25:13 <lament> (ring finger is for 9)
16:25:22 <Beelsebob> oh, 0, not o
16:25:30 <RayNbow> http://www.scientia.demon.nl/Keyboard.png <-- my keyboard
16:25:40 <aoesunthsoneuah> I am one of the fastest typers I know, though.
16:25:42 <Beelsebob> and that's not your ring finger -- your ring finger's on your left hand!
16:25:43 <aoesunthsoneuah> Really, the fastest.
16:25:44 * chessguy wonders if Beelsebob is showing us his '0' face
16:25:45 <aoesunthsoneuah> I am very fast when I try.
16:25:49 <aoesunthsoneuah> HOWEVER, I'm a slow coder.
16:25:59 <aoesunthsoneuah> I can't just spew out some code, every few lines I have to stop and think about stuff
16:26:05 <lament> chessguy: it's inconsistent
16:26:15 <nominolo> piano players seem to be extremely fast typists :)
16:26:16 <aoesunthsoneuah> So actually beyond the basic features editors have very little effect on me, since I'm not going to be tapping for more than 20 seconds at a time
16:26:21 <Beelsebob> lament: hang on, are you claiming that 0 should be typed with your pinky?
16:26:26 <lament> chessguy: it makes typing other digits less natural. Yes.
16:26:28 <saml> (def map (f l) (if (isEmpty l) l (cons (f (head l)) (map f (tail l)))))   -- my typechecker says map :: (a -> a) -> [a] -> [a] ..  i think it's because of (if (isEmpty l) l ...   is this normal?
16:26:44 <Beelsebob> lament: I type 0 with my *middle* finger
16:26:47 <lament> chessguy: 7 with the index finger, 8 with middle finger, and so on
16:27:16 <Beelsebob> saml: l :: [a], so it's output must be [a]
16:27:28 <chessguy> lament, so? again, as long as it's fast, who cares if it's "inconsistent"?
16:27:30 <Beelsebob> replace l in the then branch with a generic empty list instead
16:27:39 <saml> l :: t1 , (cons (f (head l)) (map f (tail l))) :: t2  .. so when I unify them t1 = t2
16:27:51 <lament> chessguy: inconsistent means slow
16:27:57 <Beelsebob> lament: I type all of 890 with my middle finger
16:28:06 <saml> Beelsebob: hah yeup that solved it!! thanks!
16:28:08 <lament> Beelsebob: we've already established your typing is really werid
16:28:10 <lament> weird
16:28:25 <Beelsebob> but... how on earth do you get your pinky squezed up for 0
16:28:30 <Beelsebob> that makes no sense at all
16:28:37 <Beelsebob> that requires moving your entire hand
16:28:45 <Beelsebob> your entire arm even
16:28:47 <aoesunthsoneuah> I type 0 with my MIND
16:28:51 <saml> i was just translating haskell code to that language.. map _ [] = []  .. the first [] was pattern
16:28:55 <aoesunthsoneuah> lambdabot: so is yours apparently
16:29:02 <lament> Beelsebob: your hand is positioned really strangely
16:29:10 <lament> Beelsebob: i don't understand what the hell you're doing
16:29:13 <chessguy> saml, what is that, some kind of lisp?
16:29:21 <dmwit> Beelsebob: I used to type 0 with my fourth finger, it's perfectly fine.
16:29:22 <lament> Beelsebob: if you can write 'ls' using the ring finger for l
16:29:31 <aoesunthsoneuah> Who here uses one of those ergonomic two-pits-of-fiery-hell keyboard things?
16:29:31 <dmwit> lament: dvorak
16:29:32 <Beelsebob> lament: my right hand is positioned over htns
16:29:34 <lament> Beelsebob: your hand is it some really weird angle
16:29:36 <aoesunthsoneuah> Those have always interested me.
16:29:38 <dmwit> aoesunthsoneuah: I do.
16:29:45 <aoesunthsoneuah> dmwit: YOU'RE MAD
16:29:48 <aoesunthsoneuah> In a good way
16:29:58 <lament> Beelsebob: is your forearm almost perpendicular to the keyboard?
16:29:59 <saml> chessguy: my language. kinda parenthesisy
16:30:14 <chessguy> saml, implemented in haskell?
16:30:31 <Beelsebob> lament: yes -- but in order to type 0 with my pinky, I'd need to cross my pinky over my right-most-non-pinky-finger
16:30:31 <saml> chessguy: yes. to learn haskell.
16:30:36 <chessguy> saml, nice
16:30:41 <Beelsebob> either that, or move my entire hand
16:30:55 <lament> Beelsebob: your arm is at a bad angle, then
16:31:13 <lament> Beelsebob: the angle between my forearms is about 60 degrees
16:31:22 <Beelsebob> lament: yep, that's about right
16:31:27 <lament> odd
16:31:33 <Beelsebob> body and two arms are making a roughly equilateral triangle
16:31:50 <lament> at that angle, your pinky shouldn't cross anything to get to 0
16:32:10 <saml> n> let map f l = if null l then l else f (head l) : map f (tail l) in map show [1,2,3]
16:32:12 <lament> i can leave the other fingers on htn and put the pinky on 0 at the same time
16:32:17 <lament> it's perfectly natural
16:32:21 <Beelsebob> lament: maybe our keyboards have the keys in margionally different positions
16:32:28 <Beelsebob> I can do that for [, but not for 0
16:32:58 <lament> Beelsebob: admittedly, my current keyboard is http://www.maplin.co.uk/images/Full/A46GA.jpg
16:33:06 * EvilTerran mostly uses standard QWERTY, but i've swapped backspace and capslock
16:33:12 <lament> Beelsebob: but i do the same at home on a regular rectangular keyboard
16:33:36 * dmwit has swapped ESC and Caps, as well as ~ and Delete.
16:33:36 <Beelsebob> lament: yeh, but even "regular" keyboards have the keys in subtly different places
16:33:39 <EvilTerran> makes *far* more sense for backspace to be on your home row and capslock well out of the way. that particular swap makes even more sense for lefties.
16:33:55 <lament> Beelsebob: true. The standard mac keyboard, then :)
16:33:56 <Botje> EvilTerran: pah. I have _TWO_ escape keys
16:33:57 <Beelsebob> as dell proved with their weird british keyboard with the lower row shifted an *entire* character out of place
16:34:04 <dmwit> But then, I also have space/backspace under my two thumbs, so that swap wouldn't make sense for me. =)
16:34:08 <lament> EvilTerran: CapsLock is where Ctrl used to be, historically
16:34:09 <Beelsebob> lament: that's very odd then -- I'm on a MacBook keyboard
16:34:11 <EvilTerran> Botje, um, i didn't mention escape keys. but okay.
16:34:20 <Botje> oh
16:34:26 <Botje> misread backspace as escape :)
16:34:30 <EvilTerran> am i right in thinking you use emacs?
16:34:40 <Botje> me? no :)
16:34:45 <Beelsebob> lament: actually -- that picture you linked illustrates it perfectly
16:34:54 <EvilTerran> oh, ok. just trying to figure out why you'd want two escape keys.
16:34:57 <lament> it's a nice keyboard, i really like it :)
16:35:05 <Botje> EvilTerran: vim :)
16:35:07 <Beelsebob> if you draw a line across htns (jkl; on that keyboard), and then draw a perpendicular line through the 0 key
16:35:10 <EvilTerran> true
16:35:12 <dmwit> EvilTerran: Vim is the escape-heavy one, not emacs.
16:35:13 <Beelsebob> that intersects l, not ;
16:35:26 <Beelsebob> so why on earth would you cross your pinky over to type it
16:35:46 <lament> strange
16:36:02 <lament> well, according to wikipedia, in some countries they teach to use ring finger for 0
16:36:02 <dmwit> Beelsebob: I type 0 with my pinky now, try that perpendicular trick on here:
16:36:02 <EvilTerran> dmwit, i thought emacs used tapping escape before a key combo as a modifier, too?
16:36:05 <dmwit> http://www.kinesis-ergo.com/images/kb_adv-wht720x442.jpg ;-)
16:36:16 <Beelsebob> dmwit: hehe, yeh, I want one of them
16:36:21 <Beelsebob> but they cost about 400
16:36:21 <lament> 7,8 index, 9 middle, 0 ring, [ pinky
16:36:25 <dmwit> yeah =/
16:36:31 <Beelsebob> lament: oh, okay, now you're making sense
16:36:43 <Beelsebob> that's pretty much what I do
16:36:49 <lament> (but i'm trying to do 7 index, 8 middle, 9 ring, 0, [ pinky)
16:36:58 <Beelsebob> lament: but why
16:37:01 <lament> 8 middle seems very natural for one
16:37:03 <Beelsebob> why cross your pinky over for 0?
16:37:23 <lament> just extending the middle finger without pointing it at anyone gets it directly to 8
16:37:31 <dmwit> On a slightly more related note: who wants to swap starter modules?
16:37:35 <Beelsebob> I know I get it wrong, but I type 7 index, 8,9,0 middle, [,] ring
16:37:45 <lament> that's just weird :)
16:37:51 <Beelsebob> lament: for me that gets me to 9
16:38:07 <Beelsebob> lament: here's something to try
16:38:08 <lament> my middle finger doesn't stretch that far sideways
16:38:16 <dmwit> I'll go first: http://hpaste.org/7572
16:38:24 <Beelsebob> heh, my middle fingr stretches all the way to backspace sideways
16:38:38 <lament> anyway i think this conversation officially proves that dvorak users are nuts
16:38:44 <Beelsebob> maybe that's to do with playing piano, and needing to make big stretches that way
16:38:45 <dmwit> Nuh-uh!
16:38:50 <dmwit> We're the only sane ones!
16:39:07 <lament> i've been playing piano for ~10 years...
16:39:09 <dmwit> Incidentally, "sane ones" is entirely home-row.
16:39:21 <Beelsebob> lament: odd that your middle finger doesn't stretch the same way
16:39:23 <lament> everything is entirely home-row on dvorak :)
16:39:24 <dino-> Not sure if anyone mentioned this but you can use ctrl-[ to generate ESC
16:39:28 <Beelsebob> dmwit: hehe
16:39:36 <dmwit> dino-: Yep, that's a great trick.
16:39:38 <Beelsebob> everything is not entirely home row
16:39:38 <Pseudonym> I've been playing piano for 30 years, and my middle finger doesn't stretch that far.
16:39:39 <Beelsebob> y is off it
16:39:40 <Beelsebob> :P
16:39:44 <dino-> Put that together with non-crazy UNIX ctrl key mapped to that useless caps lock and you've got home key heaven
16:39:46 <lament> Pseudonym wins
16:39:48 <Beelsebob> so is v
16:39:51 <dmwit> and r
16:39:53 <Beelsebob> so is g
16:39:58 * EvilTerran randomly points out that you can type "database" with one hand on QWERTY
16:40:08 <Beelsebob> in fact, everything is a *really* bad example of why dvorak is good
16:40:13 <dino-> Reaching down to the bottom left corner for ctrl == wrong
16:40:14 <Zao> EvilTerran: And stewardesses
16:40:18 <dmwit> EvilTerran: And lollipops!
16:40:24 <dmwit> oops
16:40:25 <lament> Pseudonym: that's alltogether too long a time to be playing piano. You should switch to something else :)
16:40:26 <EvilTerran> dmwit, um, S?
16:40:27 <dmwit> lollipop
16:40:30 <Pseudonym> I don't have a problem with Dvorak.  It's Dvorak enthusiasts I find weird.
16:40:31 <Beelsebob> although actually everything does almost perfectly alternate left and right hands
16:40:48 <dmwit> th, ng
16:40:55 <dmwit> But yeah, pretty close.
16:41:21 <Beelsebob> Pseudonym: I don't usually enthuse -- I confuse, I have qwerty key caps on the physical keyboard, but the OS set to dvorak with the option to change it hidden
16:41:51 <ptolomy2> Hm. When I try to profile my (ghc-compiled with proper flags) code with "+RTS -p", there are no ticks, so everything is 0% of runtime. This only happens sometimes.
16:42:02 <dmwit> Nobody wants to share useful functions they find themselves writing over and over? =(
16:42:07 <lament> Beelsebob: my home keyboard: http://users.z3.ca/~lament/keyboard.html
16:42:21 <Pseudonym> A lot of people have shell scripts that call xmodmap (or equivalent) with names "asdf" and "aoeu".
16:42:29 <Beelsebob> lament: sec, I should show you my one of them
16:42:32 <Beelsebob> purely for comedy value
16:42:33 <EvilTerran> lament, is that a mac keyboard?
16:42:48 <lament> EvilTerran: yes
16:42:55 <dmwit> But with no keycaps. =)
16:42:58 <EvilTerran> those're quite nice
16:43:12 <dmwit> s/no/blank/
16:43:21 <lament> it's okay, it gets dirty quickly and very visibly
16:43:37 <lament> and of course it's ridiculously expensive
16:43:58 * EvilTerran has a Model M sitting around somewhere waiting for him to get round to getting a USB-PS/2 adapter
16:44:17 <lament> those are like five bucks, you must not want it quite so badly :)
16:44:23 <EvilTerran> meh. takes effort.
16:44:24 <ptolomy2> The discussions over Haskell optimization seem to not make a distinction between "not making code run slow" and "making code run really fast". The first is not hard if you understand laziness, but the second is pretty trick, IMHO.
16:44:38 <dons> agreed.
16:44:45 <dons> there's phase 1: learn what the hell you're doing.
16:44:51 <EvilTerran> i'll buy it the next time i do a bulk order from farnell or whoever.
16:44:55 <dons> and phase 2: learn core, and understand the compilation process
16:45:05 <dons> some people don't get past phase 1.
16:45:14 <Beelsebob> lament: http://www.cs.kent.ac.uk/people/rpg/tatd2/keyboard.jpg
16:45:21 <dons> they write list accumulators and complain their gcc -O 'for loops' outperform
16:45:26 <Beelsebob> (backwards because it's taken with my MacBook)
16:45:31 <ptolomy2> phase 2 is non-trivial.
16:45:35 <Pseudonym> You know you understand things when you start proposing optimisations to Simon.
16:45:44 <dons> right. its getting easier to get into phase2
16:45:52 <dons> its way easier than it was 5 years ago, imo.
16:46:01 <dons> we actually have articles about phase 2 hacking now
16:46:29 <EvilTerran> (also one of these - http://uk.farnell.com/239720/industrial-controls-automation/product.us0?moeller-fak-r-v-kc11-1 :P)
16:46:32 <lambdabot> Title: MOELLER | FAK-R/V/KC11/1Y | Control Gear & Switch Gear | Industrial Controls & A ..., http://tinyurl.com/63bmhd
16:46:33 <ptolomy2> I have some code where a two or three line function ends up being a few dozen lines of code with almost no recognizable similarity.
16:46:37 <dons> btw, there's a fast uvector implementation of AC's 'mean'
16:46:42 <dons> i was happy to notice
16:46:48 <Pseudonym> ptolomy2: Have you read the STG paper?
16:46:50 <dons> (i should hope so too)
16:47:07 <ptolomy2> Pseudonym: Ooh. No. I really should.
16:47:08 <Pseudonym> It really helps, though I think there should be a more modern tutorial paper.
16:47:17 <Pseudonym> ?go spineless tagless g machine
16:47:18 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
16:47:18 <lambdabot> Title: Implementing lazy functional languages on stock hardware: the Spineless Tagless  ...
16:47:24 <dons> using ghc-core instead of ghc is a good way too
16:47:33 <Pseudonym> Perhaps rather than writing a monad tutorial, some kind person would like to write a Core tutorial.
16:47:34 <dons> get the asm and core in your face on every compile
16:47:36 <dons> and you pick it up
16:48:18 <dons> anyone got a nice way to calculate the mean of a list/array using a zip?
16:48:41 <Pseudonym> Why a zip?
16:48:46 <EvilTerran> that sounds clunky
16:48:56 <roconnor> dons: I had one on the wiki
16:49:02 <dons> well, folds are easy
16:49:03 <vixey> zip as in [a] -> [b] -> [(a,b)] ?
16:49:09 <EvilTerran> i'd be tempted to tie the knot in some weird implausible way
16:49:15 <dons> but you've got this pair of length/sum being accumulated
16:49:22 <dons> mean arr = sum / fromIntegral len
16:49:22 <dons>   where
16:49:22 <dons>     len :*: sum = foldlU k (0 :*: 0) arr :: (Int :*: Double)
16:49:22 <dons>     k (n :*: s) a = n+1 :*: s+a
16:49:27 <dons> fuses nicely
16:49:31 <ptolomy2> I'm getting the impression that monad transformers muck up the resulting core a bit.
16:49:34 <dons> but i suggest not so pretty
16:49:44 <dons> ptolomy2: hmm. mtl needs more aggressive inlining, for one
16:50:02 <ptolomy2> dons: use-threshold=16?
16:50:07 <ptolomy2> (s'what I'm currently using)
16:50:25 <dons> i think some things need manual {-# INLINE #-}
16:50:33 <dons> since you should never really see mtl droppings in your code
16:50:40 <dons> on a good day, anyway
16:50:45 <dmwit> > let mean xs = uncurry (/) . last $ zip (scanl (+) 0 xs) [1..]
16:50:45 <lambdabot>  Parse error at end of input
16:50:50 <dmwit> > let mean xs = uncurry (/) . last $ zip (scanl (+) 0 xs) [1..] in mean [1, 2, 3]
16:50:57 <lambdabot>  1.5
16:51:00 <dons> last . zip . scan. i can do that.
16:51:14 <dmwit> err...
16:51:18 <dmwit> That answer is wrong.
16:51:24 <dmwit> > scanl (+) 0 [1, 2, 3]
16:51:26 <lambdabot>  [0,1,3,6]
16:51:28 <dmwit> Oh.
16:51:32 <dons> it puts that stupid prefix inn
16:51:36 <dmwit> > let mean xs = uncurry (/) . last $ zip (scanl (+) 0 xs) [0..] in mean [1, 2, 3]
16:51:37 <lambdabot>  2.0
16:51:56 <dmwit> off-by-one--
16:52:03 <ptolomy2> Lots of "right (right (inst (inst (trans (sym" and so on..
16:52:08 <Pseudonym> let mean xs = sum / fromIntegral len  where (sum,len) = foldl (\(s,l) x -> (s+x,l+1)) (0,0) xs
16:52:13 <Botje> dons: is there something special about :*: or is it just a nice way of constructing pairs?
16:52:16 <dons> ptolomy2: oh, that's just type junk though
16:52:24 <dons> Pseudonym: right. same as above
16:52:26 <Pseudonym> @pl f x (s,l) = (s+x,l+1)
16:52:27 <lambdabot> f = (`ap` snd) . (. fst) . flip flip (1 +) . (((.) . (,)) .) . (+)
16:52:31 * Beelsebob ponders... it would be interesting to let patterns include application of functions, not just constants, so you could do wierd shit like f (x + y) = x -- of course, this would break referential transparency, but it would be fun all the same
16:52:32 <Pseudonym> Eek.
16:52:37 <ptolomy2> dons: Oh. same with "`cast`"?
16:52:40 <Pseudonym> @pl f x (l,x) = (l+1,s+x)
16:52:40 <lambdabot> f = const ((1 +) *** (s +))
16:52:42 <Pseudonym> Better!
16:52:45 <dons> ptolomy2: yep.
16:52:56 <dons> 'cast' generally comes from newtypes
16:53:05 <EvilTerran> ?type let f x (l,x) = (l+1,s+x) in f -- error
16:53:06 <dons> its the  System Fc type coercion witness stuff
16:53:07 <lambdabot>     Conflicting definitions for `x'
16:53:07 <lambdabot>     In the definition of `f'
16:53:18 <dmwit> Pseudonym: That binds x twice.
16:53:28 <Pseudonym> Right.
16:53:35 <dmwit> :t \s -> succ *** (+s)
16:53:37 <lambdabot> Not in scope: `***'
16:53:49 <dmwit> :t \s -> succ Control.Arrow.*** (+s)
16:53:50 <lambdabot> forall a b'. (Num b', Enum a) => b' -> (a, b') -> (a, b')
16:54:19 <Pseudonym> @pl f x (l,s) = (l+1,s+x)
16:54:20 <lambdabot> f = (`ap` snd) . (. fst) . flip ((.) . (,) . (1 +)) . (+)
16:54:22 <EvilTerran> but it's (\x -> (+x) *** (+1)), which is ((*** (+1)) . (+))
16:54:30 <EvilTerran> ?type ((*** (+1)) . (+))
16:54:32 <lambdabot> Not in scope: `***'
16:54:36 <EvilTerran> buh?
16:54:46 <vixey> @unlet
16:54:47 <lambdabot> Defined.
16:54:49 <EvilTerran> ?type ((*** (+1)) . (+))
16:54:50 <vixey> :t (***)
16:54:52 <lambdabot> forall b' a. (Num a, Num b') => a -> (a, b') -> (a, b')
16:54:53 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:55:11 <EvilTerran> > ((*** (+1)) . (+)) x (y,z)
16:55:12 <lambdabot>  (x + y,z + 1)
16:55:50 <sarehu_> > extendSequence [1,1]
16:55:52 <Pseudonym> I like \s -> succ *** (+s)
16:55:52 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
16:55:55 <vixey> :t (snd *** const 1)
16:55:57 <lambdabot> forall a b t b'. (Num t) => ((a, b), b') -> (b, t)
16:55:59 <Pseudonym> I think that's the most expressive.
16:56:01 <dons> hmm, interesting
16:56:07 <dons> we get slightly worse code with the zip/scan
16:56:10 <dons> than with the fold
16:56:13 <dons> looks like something broke.
16:56:16 <sarehu_> I convinced somebody that extendSequence brute forced math operations :D
16:56:37 <dons> $s$wfold :: Double# -> Double# -> Int# -> (# Int, Double #)
16:56:44 <dons> is what the fold defn turns into, nicely
16:56:45 <EvilTerran> ?let (f .: g) x y = f (g x y)
16:56:46 <lambdabot> Defined.
16:56:56 <roconnor> @bab nl en uittreksel
16:56:57 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
16:57:03 <ptolomy2> It would be awesome if someone made a tool that uses core output to generate annotations for functions in a readable way.. perhaps by generating html of the highlighted code with mouseovers giving arity/strictness/number of non-trivial whatnots..
16:57:07 <roconnor> crap
16:57:08 <EvilTerran> > (right (+1) .: left . (+)) x (y,z)
16:57:09 <lambdabot>      precedence parsing error
16:57:09 <lambdabot>         cannot mix `(.:)' [infixl 9] and `(.)' ...
16:57:14 <EvilTerran> > (right (+1) .: (left . (+))) x (y,z)
16:57:15 <lambdabot>  Couldn't match expected type `Either Expr d'
16:57:32 <EvilTerran> > (second (+1) .: (first . (+))) x (y,z) -- er...
16:57:34 <lambdabot>  (x + y,z + 1)
16:58:05 <vixey> > uncurry (snd *** const 1) x (y,z)
16:58:05 <roconnor> @bab en nl abstract
16:58:06 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
16:58:06 <lambdabot>  Couldn't match expected type `b -> c'
17:00:24 <ptolomy2> phase-1 question: In GHC profile output, the percentage results show what function created a lazy thunk that took time, not the function that evaluated the thunk, correct?
17:00:28 <Botje> dons:  I just saw your blog post about typeclass hacking, the second-to-last paragraph has "irregardless", that's probably wrong, no? :)
17:00:46 <dons> i got some flac at work about that today too
17:00:55 <Botje> hehe, sorry :)
17:01:05 <EvilTerran> you got some free lossless audio codec?
17:01:09 <dons> "Irregardless is a term that has caused controversy since it first appeared in the
17:01:12 <dons> early twentieth century"
17:01:16 <EvilTerran> whoa... deja vu. *pokes his brain*
17:01:24 <dons> "It is generally listed in dictionaries as "incorrect" or
17:01:24 <dons> "nonstandard"."
17:01:52 <slava> hi dons
17:02:01 <dons> an australian linguist claims that it has become fetishised
17:02:11 <dons> as a word cited mostly for the fact it is incorrect
17:02:13 <dons> heya slava
17:02:16 <chessguy> really? 'irregardless' doesn't seem so bad to me
17:02:20 <lament> if i saw 'irregardless' in something dons wrote, i would assume irony
17:02:51 <dons> heh
17:03:20 <dons> mm, strict pairs.
17:03:25 <dons> they really improve accumulators
17:03:31 <dons> death to lazy tuples!
17:03:40 <lament> death to lazy!
17:03:51 <dons> no no, we need some. just in the right places
17:06:23 <slava> dons: ever done much with ssl?
17:06:32 <dons> slava: only a little
17:06:44 <ptolomy2> The hardest part about optimizing haskell code for me is that you have to pander to the compiler instead of pandering to the machine, and that means that imperative hacks that I might normally try are probably less efficient than the cleaner functional equivalent.
17:07:13 <dons> ptolomy2: to an extent.
17:07:25 <Pseudonym> I think there's one place where you're wrong on that.
17:07:27 <dons> once you know what the compiler does, you pander to the machine again
17:07:33 <ptolomy2> To an extent that I don't know.
17:07:46 <Pseudonym> In a sense, optimising Haskell is about performing optimisations that the compiler doesn't do.
17:08:01 <Pseudonym> In that sense, and that sense only, is it pandering to "the compiler".
17:08:31 <Pseudonym> It's not pandering to "the compiler" in the sense that an optimisation intended for one compiler is almost certainly an optimisation that will also work on another compiler.
17:08:41 <jmob> Presumably, you shouldn't ever /need/ to optimize haskell code.  If a haskell function is the definition of a solution, what can be done to optimize it.
17:08:44 <dons> uvector is destroying lists on this mean() benchmark
17:09:10 <Pseudonym> (There are a few exceptions.  Optimisations involving lambda dropping will be undone on some compilers.)
17:09:11 <dons> 10x over my best hand rolled list recursion, which does no better than a good fold
17:09:37 <Pseudonym> (Not GHC, but G machine or GRIN-based compilers _might_ undo them.)
17:10:33 <vixey> jmob: well algorithmic optimizations like doin something O(n) rather than O(n^n)
17:11:17 <Pseudonym> vixey: I've written optimisation passes that turn exponential algorithms into polynomial ones.
17:11:31 <vixey> :o
17:11:42 <vixey> by memoization? or what
17:11:59 <Pseudonym> No, it was generate-and-test transformations for logic languages.
17:12:27 <Pseudonym> Essentially, consider a list comprehension:
17:12:45 <Pseudonym> [ f x y | x <- xs, y <- ys, some_guard_mentioning x y ]
17:13:17 <dons> http://hpaste.org/7573
17:13:22 <Pseudonym> If you can break open the guard and move part of it inbetween the x <- xs and the y <- ys, you can get a superexponential speedup.
17:13:28 <dons> some different ways of computing the mean of a huge list of doubles
17:13:50 <dons> the uvector fused solution is 20x faster than a good list.
17:14:09 <dons> anyone got some other thoughts on the matter}
17:14:16 <slava> i like arrays :)
17:14:31 <dons> arrays are good. bow to the machine and its mighty cache!
17:15:06 <Pseudonym> So this is also data parallel?
17:15:17 <Pseudonym> The foldU version?
17:15:17 <ptolomy2> liftIO (modifyIORef (\x -> x { intField = (intField x) + 1 } ) -- any guesses to the number of instructions this would compiled down to (well, order of magnitude)?
17:15:21 <dons> Pseudonym: nope
17:15:31 * Pseudonym pfffs
17:15:44 <vixey> Pseudonym: what logic language?
17:15:45 <dons> its the stream fusion though, it turns into a good loop
17:15:51 <Pseudonym> vixey: Mercury.
17:15:52 <dmwit> dons: Any idea what was wrong with the wrong/nice definition?
17:15:53 * dons wonders how well C does at this.
17:16:00 <wy> @src (++)
17:16:01 <lambdabot> []     ++ ys = ys
17:16:01 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
17:16:01 <lambdabot> -- OR
17:16:01 <lambdabot> xs ++ ys = foldr (:) ys xs
17:16:01 <lambdabot> -- In lambdabot, this is generalised to:
17:16:02 <dmwit> Oh, overflow of (+1), I guess.
17:16:03 <lambdabot> (++) = mappend
17:16:07 <dons> dmwit: doesn't scan give the wrong results?
17:16:16 <Pseudonym> You can in theory do it in Prolog, but in practice you REALLY need the mode information.
17:16:36 <dmwit> dons: No, not if the [x..] starts with x = 0, not x = 1.
17:16:39 * ptolomy2 has this predjudice that Haskell is slow for explicit mutation, but isn't sure if it is justified or not.
17:16:54 <dons> no, that's not true. mutation is cheap.
17:17:01 <dons> there's just not many libs that encourage that style
17:17:02 <dmwit> dons: Though I would guess at some point it becomes [..., x, x+1, x+1+1 = x+1, ...]
17:17:14 <Pseudonym> There are also lots of algorithms that don't depend on explicit mutation.
17:17:17 <dmwit> > 1e9 + 1 == 1e9
17:17:18 <lambdabot>  False
17:17:24 <dmwit> huh
17:17:44 <dmwit> > any (\x -> x == x + 1) [0..1e9 :: Double]
17:17:51 <lambdabot> Terminated
17:18:03 <wy> @src (:)
17:18:04 <lambdabot> Source not found. stty: unknown mode: doofus
17:18:40 <wy> So... (:) is primitive?
17:18:57 <dmwit> yes
17:19:16 <ptolomy2> (:) is a type constructor.
17:19:29 <dmwit> Although that's not a safe conclusion just from the fact that ?src can't find it. =)
17:19:29 <vixey> wy: : is just like any old (infix) Type constructor
17:19:36 <dmwit> ptolomy2: (:) is a *value* constructor, no?
17:19:36 <vixey> @src []
17:19:37 <lambdabot> data [] a = [] | a : [a]
17:19:37 <dobblego> data [] a = [] | (:) a ([] a)
17:19:48 <wy> Hmmm... I just found that scheme will do (append '(1 2) '3) while Haskell doesn't.
17:19:49 <vixey> you may define data Equation a b = a :=: b -- etc..
17:20:04 <Pseudonym> > 1e+16 == 1e+16+1
17:20:06 <lambdabot>  False
17:20:07 <dmwit> wy: Right, that's not well-typed.
17:20:10 <Pseudonym> > 1e+17 == 1e+17+1
17:20:11 <lambdabot>  False
17:20:14 <Pseudonym> > 1e+17 == 1e+17 + 1
17:20:15 <lambdabot>  False
17:20:21 <Pseudonym> > 1e+18 == 1e+18 + 1
17:20:22 <lambdabot>  False
17:20:28 <dmwit> wy: If you want to do that, you have to define a recursive type that allows nested lists of arbitrary depth.
17:20:31 <vixey> wy: You could do this is Haskell, data Value = I Integer | Pair Value Value
17:20:35 <Pseudonym> > 1e+19 == 1e+19 + 1
17:20:36 <lambdabot>  False
17:20:38 <Pseudonym> Hmm.
17:20:41 <Pseudonym> It's somewhere around there.
17:20:42 <vixey> oops
17:20:43 * ptolomy2 perhaps had his terminology wrong.
17:20:47 <vixey> data Value = I Integer | Pair Value Value | Nil
17:21:13 <monochrom> 1e19 is pretty close.
17:21:20 <dmwit> data NestedList a = Cons a (NestedList a) | List (NestedList [a]) | Nil
17:21:24 <Pseudonym> > 1e+20 == 1e+20 + 1
17:21:25 <lambdabot>  True
17:21:26 <Pseudonym> There 'tis.
17:22:12 <dmwit> dons: So, yeah, I don't understand what's wrong with the zip version.
17:22:25 <Pseudonym> What's interesting is that it isn't what I thought it would be.
17:22:28 <wy> vixey: Then it's not *->* any more?
17:22:30 <Pseudonym> I thought it would be around 1/epsilon.
17:22:51 <Pseudonym> But in fact, it's not _quite_ that simple.
17:22:51 <monochrom> Some devious "implicit 1" business, probably.
17:23:09 <vixey> wy: which?
17:23:20 <wy> data Value = I Integer | Pair Value Value | Nil
17:23:33 <vixey> the kind of Value is *
17:23:52 <dmwit> But you could easily make it (* -> *).
17:24:08 <monochrom> > 1e19
17:24:09 <lambdabot>  1.0e19
17:24:47 <monochrom> > map (2^) [53,54,55]
17:24:49 <lambdabot>  [9007199254740992,18014398509481984,36028797018963968]
17:25:03 <monochrom> > map (length . show . 2^) [53,54,55]
17:25:04 <lambdabot>        add an instance declaration for (Num (f a), Num (f Int))
17:25:06 <dmwit> data NestedList a = Leaf a | Branch [NestedList a]
17:25:10 <monochrom> > map (length . show . (2^)) [53,54,55]
17:25:12 <lambdabot>  [16,17,17]
17:25:39 <wy> I see
17:26:00 <dmwit> I actually don't like that version.
17:27:12 <wy> dmwit: why not?
17:27:25 <dmwit> What should (Branch [] == Branch [Branch []]) return?
17:27:38 <vixey> It's not very useful in Haskell anyway
17:28:35 <wy> dmwit: Why don't you have head and tail?
17:28:59 <dmwit> wy: I'm just playing with different representations.
17:29:49 <wy> dmwit: oh. I see.
17:29:57 <wy> [NestedList a] is a list...
17:30:11 <dmwit> But "data NestedList a = Cons a (NestedList a) | Nested (NestedList [a]) (NestedList a) | Nil" could be good.
17:30:37 <wy> That's getting weird
17:30:47 <dmwit> Not so weird.
17:30:51 <dmwit> It's your standard linked list.
17:31:01 <dmwit> You could write it this way, too:
17:31:04 <vixey> if you're looking at Scheme I'd just go with data Value = I Integer | D Double | B Bool | ... | Nil | Cons Value Value
17:31:15 <wy> Why do you have 4 cases?
17:31:19 <dmwit> data NestedList a = Cons (Either a (NestedList [a])) (NestedList a) | Nil
17:31:41 <dmwit> err...
17:31:52 <dmwit> Either a (NestedList a)
17:32:03 <dmwit> I think that's my favorite one so far.
17:32:28 <wy> What's the completed version?
17:32:40 <dmwit> data NL a = Cons (Either a (NL a)) | Nil
17:32:41 <vixey> data NestedList a = Thap [Either a (NestedList a)] -- how about that?
17:33:03 <wy> :t Either
17:33:05 <lambdabot> Not in scope: data constructor `Either'
17:33:09 <vixey> :t Left
17:33:10 <lambdabot> forall a b. a -> Either a b
17:33:11 <vixey> :t Right
17:33:13 <lambdabot> forall b a. b -> Either a b
17:33:14 <dmwit> ?src Either
17:33:14 <lambdabot> Source not found. I've seen penguins that can type better than that.
17:33:22 <dmwit> data Either a b = Left a | Right b
17:33:40 <dmwit> vixey: I like that, too.
17:36:00 <wy> That seems to be good
17:37:30 <dmwit> I like this the best so far:
17:37:51 <dmwit> data NestedList a = Elem a | Nested [NestedList a]
17:38:19 <dmwit> The only drawback to that one is you get the possibility of not even having the top-level list.
18:09:44 <Boney> @t chr
18:09:44 <lambdabot> Maybe you meant: tell temp thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:09:58 <Boney> @type char
18:10:00 <Boney> @type chr
18:10:13 <lambdabot> Char -> Doc
18:10:15 <lambdabot> Int -> Char
18:10:28 <Boney> @where chr
18:10:28 <lambdabot> I know nothing about chr.
18:10:32 <Boney> @help
18:10:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:12:35 <wjt> @index chr
18:12:36 <lambdabot> Data.Char
18:27:36 <dolio> Anyone up for some category theory?
18:27:46 <mxc> no
18:27:52 <mxc> but i speak only for myself
18:29:41 <vixey> you can never have too much category theory
18:32:17 <Pseudonym> It's occurred to me that there really is no place on the 'net for recreational category theory.
18:32:37 <Pseudonym> Especially people learning.
18:33:14 <Pseudonym> It's almost all in the Haskell community, which is fine, because we actually use it in anger.
18:33:44 <Pseudonym> And all of the other resources are heavy on the topology, which makes sense if you want to learn history rather than category theory.
18:33:56 <dolio> Heh.
18:34:09 <Pseudonym> That's not an original thought, BTW.
18:34:22 <Pseudonym> Lots of academics have noticed that a lot of textbooks are really history books in disguise.
18:34:33 <Pseudonym> You learn things in historical order rather than logical order.
18:34:49 <Plareplane> ...use it in anger?
18:36:09 <dolio> My concern is that when I do exercises, I have a hard time telling whether I'm doing them right.
18:36:11 <Pseudonym> Pareplane: I mean it in the John Osborne sense.
18:36:17 <dolio> Since I don't have a teacher to grade me anymore.
18:36:30 <Pseudonym> Anger implies harsh reality, rather than escapism.
18:36:41 <Pseudonym> It's the same sense as "angry young men".
18:42:16 <dolio> Perhaps I'll just ask, and anyone can chime in if I'm doing it wrong.
18:43:28 <dolio> The problem is to prove that if an object (F, in) is initial in the category F-Alg, in is an isomorphism.
18:44:39 <shepheb> main = do
18:44:39 <shepheb> inputChannel <- atomically newTChan
18:44:39 <shepheb> forkIO $ listenerThread inputChannel
18:44:39 <shepheb> forever $ getLine >>= \str -> atomically (writeTChan inputChannel str)
18:44:39 <shepheb> listenerThread inputChannel = atomically (readTChan inputChannel) >>= putStrLn
18:44:45 <shepheb> damn it, sorry
18:45:03 <dolio> So, being initial, that means that for each (A, a) there's exactly one morphism cata_a : F -> A such that the relevant diagram commutes.
18:45:33 <shepheb> http://hpaste.org/7574  -- weird linker errors, apparently STM related
18:46:46 <dolio> So, my thought was that (FF, Fin) is an F-algebra, giving cata_Fin : F -> FF, which is, type-wise, a suitable candidate for the inverse to in : FF -> F
18:46:50 <TSC> shepheb: Are you using "ghc --make" ?
18:47:20 * shepheb puts his face in his hands
18:47:35 <shepheb> TSC: thanks, that fixed it. thought that was only necessary if I had multiple modules of my own.
18:47:39 <TSC> I've done the same thing a few times (:
18:49:54 <dolio> And  in . cata_Fin = id_F, because id_F is the unique cata_in given by initiality.
18:50:56 <dolio> And I think  cata_Fin . in = id_FF for similar reasons (if there were other f : FF -> FF there would be other g : F -> F).
18:51:32 <roconnor> @wn epiphenomenom
18:51:34 <lambdabot> No match for "epiphenomenom".
18:51:59 <TSC> @wn epiphenomenon
18:52:00 <lambdabot> *** "epiphenomenon" wn "WordNet (r) 2.0"
18:52:00 <lambdabot> epiphenomenon
18:52:00 <lambdabot>      n : a secondary phenomenon that is a by-product of another
18:52:00 <lambdabot>          phenomenon
18:52:00 <lambdabot>      [also: {epiphenomena} (pl)]
18:53:33 <edwardk> dolio: looks good to me
18:53:40 <sgillespie> Can someone help me figure this out?
18:53:47 <dolio> Sweet.
18:54:03 <pjd_> sgillespie: don't ask to ask, ask :)
18:54:32 <sgillespie> The following type signature is apparently invalid without -fglasgow-exts
18:54:45 <sgillespie> typeof :: (Eq (LamType t)) => Lambda (LamType t) b -> LamType
18:55:05 <sgillespie> ghci tells me:  Non type-variable argument in the constraint: Eq (LamType t
18:55:32 <sgillespie> I have
18:55:54 <sgillespie> data Lambda t v = ... and data LamType t = ...
18:55:57 <sgillespie> both deriving Eq
18:56:15 <vixey> so then you should be able to just remove (Eq (LamType t)) => ?
18:56:40 <Saizan> just Eq t => .. probably works
18:56:47 <sgillespie> ok...
18:57:32 <sgillespie> !pastebin
18:57:52 <Saizan> @pate
18:57:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:58:17 <sjanssen> does anyone know when Data.Foldable was added to base?
18:59:24 <sgillespie> http://hpaste.org/7575
18:59:34 <sgillespie> Maybe that will explain more
19:00:09 <sgillespie> I think i got it
19:00:26 <sgillespie> Saizan was right...just didn't understand at first
19:00:49 <Saizan> :)
19:01:46 <Saizan> you could had just removed the signature and asked ghci for the one it infers
19:02:20 <TSC> Or you can remove the context, and GHC will say "I couldn't infer context (Eq t)", or something like that
19:07:27 <sgillespie> Saizan: I did, and it gave me what I originally had (which is where i got it from)
19:14:01 <Saizan> sgillespie: heh, GHC's typechecker is quite lazy in resolving instances :)
19:19:39 <EvilTerran> incidentally, sgillespie, the more specific flag for that particular extension is -XFlexibleContexts
19:26:26 <hexpuem> where would be the best place to cry about parsec3 performance haha
19:30:41 <obijywk> i'm having an issue with HOpenGL, I think the strings I pass to uniformLocation are not getting null terminated
19:31:00 <obijywk> my program works great when I specifically write "variablename\0"
19:31:24 <obijywk> but if I leave off the "\0" it often does totally wrong things
19:31:39 <daveux> Oooh, is someone taking a late day? :)
19:32:28 <saml> :t uniformLocation
19:32:29 <lambdabot> Not in scope: `uniformLocation'
19:33:03 <obijywk> its part of HOpenGL, i don't know if lambdabot knows about that library
19:33:04 <obijywk> hi dave
19:33:17 <daveux> Hey, obijywk.
19:33:27 <obijywk> we're not taking a late day, I just thought we'd try to report the issue if it is a bug, we worked around it in our project
19:34:08 <daveux> Oh, I was just kidding. I know I encountered a lot of different string libraries -- uniformLocation just takes [Char]?
19:34:34 <obijywk> uniformLocation :: Program -> String -> GettableStateVar UniformLocation
19:34:51 <daveux> And isn't \& the null char in Haskell?
19:34:54 <obijywk> Program and GettableStateVar and UniformLocation are HOpenGL stuff
19:35:06 <obijywk> i don't know, "\0" seems to fix the issue quite nicely
19:35:40 <daveux> Oh, I see -- it works when you add "\0"
19:35:48 <obijywk> right
19:36:09 <obijywk> internally HOpenGL is using withCAStringLen
19:36:12 <daveux> I bet haskell doesn't null-terminate strings just because it has a safe list implementation.
19:36:15 <obijywk> which is supposed to take care of the null termination
19:37:00 <obijywk> yeah usually haskell doesn't null terminate, but when you marshal to a foreign interface you need to, so you use withCAStringLen or something like that I think
19:37:27 <obijywk> which the bindings are doing, you can see it in Shaders.hs in the OpenGL bindings
19:38:17 <dons> ?users
19:38:18 <lambdabot> Maximum users seen in #haskell: 463, currently: 416 (89.8%), active: 15 (3.6%)
19:40:27 <mwc> dons: how's the community building going?
19:41:26 <obijywk> :t withCAStringLen
19:41:28 <lambdabot> Not in scope: `withCAStringLen'
19:42:14 <dons> hard to say, mwc.
19:42:50 <mwc> 463 seems respectable
19:42:50 <SamB> what community is he supposed to be building?
19:43:05 <SamB> does he have shapr's old job now?
19:43:36 <mwc> SamB: I've observed him acting in that capacity.
19:44:28 * SamB wonders if anyone is confused about which of shapr's old jobs he is referring to
19:44:36 <ddarius> dolio: You should be able to convince yourself that what you are doing is correct.
19:47:04 <cdsmithus> Has anyone used the midi package on Hackage?  I'm looking for basic info, like units for all the Int values all over the place.
19:47:23 <daveux> obijywk: http://davebsd.com/haskore-live.mov
19:47:40 <daveux> saml ^ (Haskore Live)
19:49:51 <daveux> cdsmithus, what a coincidence
19:49:57 <daveux> See the link I just posted
19:50:13 <cdsmithus> daveux: Okay, thanks
19:50:53 <dolio> ddarius: Well, I'm not sure what exactly made me uneasy about that particular problem.
19:51:53 <dolio> I suppose it was that FF and Fin : FFF -> FF formed a proper F-algebra.
19:52:24 <dolio> Although there's no reason why they wouldn't.
19:52:46 <obijywk> daveux: lol, very nice
19:53:00 <obijywk> daveux: do you do different pitches at all, or is it just beats
19:53:10 <daveux> it's beat-oriented
19:53:14 <daveux> there are different pitches
19:53:24 <daveux> the user can configure the keyboard to make any sounds
19:53:47 <obijywk> but like, when you use bagpipe, how do you choose which note the bagpipe is playing
19:53:59 <daveux> it's just some default
19:55:08 <obijywk> but when you set up the key mapping you can specify notes?
19:55:12 <daveux> yes
19:55:24 <obijywk> cool
19:55:32 <daveux> each key can be assigned an arbitrary Music (Haskore type)
19:55:57 <obijywk> how did you stream midi in the end... i remember there were issues with writing out a MIDI file and playing it for every note
19:56:07 <daveux> but the beat command just maps a beat string "---o-o-" to a sequence of notes, then wraps that in a constructor specifying an instrument
19:56:07 <wadcom> hi
19:57:00 <daveux> obijywk: keyboard mapped Music types are written to disk only at startup to make interactive music speedy
19:57:40 <daveux> We created a typeclass to generalize the idea of a MIDI performer in case we found a better way than System.system "pmidi".
19:57:42 <wadcom> I need to parse this kind of strings with Parsec, but can't figure out how: ["some string"]. If I use do { string "[\""; many anyChar; string "\"]"; } it doesn't parse, since 'many anyChar' is greedy and consumes final "\"]"
19:57:48 <obijywk> daveux: and are you still forking processes to play back each track?
19:57:57 <daveux> obijywk, yeah
19:58:03 <wadcom> I must be missing something simple :-)
19:58:39 <cdsmithus> daveux: That's a pretty interesting tool.  Not quite what I'm looking for, but I'll poke around with it later.
19:58:43 <daveux> obijywk, but on a modern PC w/ 2gb of ram, that's not really a heavy task. I wrote a custom executable to play MIDI on OS X. The binary is like 50 bytes.
19:59:00 <gwern> @wn plaint
19:59:01 <lambdabot> *** "plaint" wn "WordNet (r) 2.0"
19:59:01 <lambdabot> plaint
19:59:01 <lambdabot>      n 1: a written statement of the grounds of complaint made to
19:59:01 <lambdabot>           court law asking for the grievance to be redressed
19:59:01 <lambdabot>      2: a cry of sorrow and grief; "their pitiful laments could be
19:59:03 <lambdabot>         heard throughout the ward" [syn: {lament}, {lamentation},
19:59:05 <lambdabot>         {wail}]
19:59:14 <obijywk> daveux, yeah but if you have separate processes playing each midi track how do you keep them in sync
19:59:24 <daveux> with hope and prayer
19:59:30 <obijywk> daveux, and is that also why there are timing issues syncing recording and playback
19:59:32 <daveux> oh, the tracks are merged
19:59:44 <gwern> daveux: I didn't know you could get binaries that small be valid and useful
19:59:55 <daveux> obijywk, no, that was a problem with Date.Time.Clock
20:00:04 <daveux> and funky timestamp diffs
20:00:23 <daveux> gwern, yes, thanks to the power of dynamically linked libraries.
20:00:38 <obijywk> daveux, we had funny timestamp diffs also when we were trying to time our matrix multiplications... timing lazy things turns out to be hard
20:01:11 <daveux> ah, so that's what the deal was!
20:02:13 <obijywk> daveux, probably. my best explanation for our bizarre timing data is that our calls to get and difference the clock times weren't evaluated until we printed the times
20:03:04 <sjanssen> obijywk: if the time getting calls are in IO, that wasn't your problem
20:03:52 <obijywk> sjanssen, i think they were. another one of my group members was actually working with that stuff, i never saw how he resolved it
20:04:30 <obijywk> :t getClockTime
20:04:34 <lambdabot> Not in scope: `getClockTime'
20:04:57 <sjanssen> all of the standard time libraries use IO, which guarantees sequencing
20:05:45 <obijywk> sjanssen, yeah that makes sense, i'm not sure exactly what was going on
20:07:51 <dolio> ddarius: I suppose due to the specific nature of that question I could have improved my confidence by playing with catamorphisms in haskell.
20:08:32 <dolio> To verify that cata (fmap InF) does appear to be the same as outF.
20:09:32 <ddarius> I was actually talking fairly generally.
20:10:14 <gwern> 'At ITA you just use whatever language you feel like, which we probably are too lax about. One guy was going to use Prolog for an access control subsystem, but not for any really good reason, so we squelched that.'
20:18:07 <Korollary> ITA=?
20:37:52 <shapr> SamB: heh, my old job :-)
20:38:58 <SamB> obviously I'm not talking about lambdabot maintainer, since dons has had that job as far back as I can remember and Cale has it now...
20:40:55 * SamB wonders what "the eastern colonies of Generalized America" refers to
20:43:06 <sjanssen> @google "eastern colonies of generalized america"
20:43:07 <lambdabot> http://strictlypositive.org/
20:43:07 <lambdabot> Title: Conor's Staring out the Window
20:43:42 <dobblego> what's a good real world example of proof by contraposition?
20:44:23 <shapr> SamB: Actually, I am doing community organizing...
20:44:36 <shapr> Just not for #haskell these days.
20:44:50 <dobblego> all mammals lay eggs
20:44:58 <orbitz> excep tthe platapus
20:44:59 <SamB_XP> ... which was the job I was referring to
20:45:08 <shapr> SamB_XP: Ok then.
20:45:31 <shapr> hi jamby
20:45:49 <SamB_XP> so is there a rule of succession, like when you retire from lambdabot maintainer you get that job ?
20:46:00 <shapr> I dunno :-)
20:46:20 <shapr> SamB_XP: You want to be next?
20:46:24 <SamB_XP> no!
20:46:31 <shapr> Why not? It's an awesome job.
20:46:51 <SamB_XP> I think I have classes starting again on monday
20:48:00 <SamB_XP> ... it depends on whether or not we can find me a full load, I guess
20:48:35 <orbitz> SamB_XP: have you heard of this website, lambda-the-ultimate? i think you migh tlike it
20:48:48 <SamB_XP> I have indeed heard of LtU
20:49:08 <orbitz> SamB_XP: good to know you are keeping up with the trends
20:49:09 <SamB_XP> but I can't even keep up with sequence.complete.org
20:49:48 <SamB_XP> orbitz: I can't tell if you are being sarcastic or if you just found out about LtU yourself ;-)
20:50:05 <orbitz> SamB_XP: go with what your heart tells you
20:50:40 <SamB_XP> wait, planet haskell is different from sequence.complete.org...
20:50:58 <orbitz> SamB_XP: have you seen this website, thedailywtf?  it has some silly posts
20:51:11 <SamB_XP> indeed it does
20:51:20 <dolio> sequence.complete.org just gets HWN, doesn't it?
20:51:49 <SamB_XP> dunno
20:52:13 <SamB_XP> but I'm subscribing to the feed either way
20:53:50 <SamB_XP> have you seen this one? http://www.google.com/reader/view/feed/http%3A%2F%2Fwww.citeulike.org%2Frss%2Fgroup%2F3445%2Flibrary
20:53:51 <lambdabot> Title: Google Reader -CiteULike: Group: functional programming - library [9 articles], http://tinyurl.com/64vyr3
20:56:11 <bos> @hoogle Either a b -> Maybe b
20:56:17 <lambdabot> No matches, try a more general search
20:56:21 <bos> @djinn Either a b -> Maybe b
20:56:24 <lambdabot> f a =
20:56:24 <lambdabot>     case a of
20:56:24 <lambdabot>     Left _ -> Nothing
20:56:24 <lambdabot>     Right b -> Just b
20:59:14 <edwardk> hrmm, do you think (f  g) or [f, g], er where  renders like /\ would be clearer notation for 'either' in a more category theoretic-style notation. the former looks less natural to a CT guy, but works more nicely with my overloading syntax, the latter requires me to give up eventually adding back in [1,2,3] style lists
20:59:52 <edwardk> er like \/ sorry
20:59:56 <SamB> ?
21:00:05 <SamB> that's what Agda 2 uses...
21:00:23 <edwardk> yeah. i'm used to ||| for it myself by now ;)
21:00:33 <SamB> |||?
21:00:40 <edwardk> @type (|||)
21:00:41 <SamB> what uses |||
21:00:46 <dolio> Agda uses that for tagged union.
21:00:51 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
21:00:52 <edwardk> this little language called haskell than no one uses.
21:00:53 <SamB> oh, sorry, I was thinking of Either
21:01:04 <SamB> either is [ f , g ]
21:01:16 <edwardk> yeah
21:01:43 <nuncanada> wow, github is the beggining of a new era for open source
21:01:52 <SamB> nuncanada: eh?
21:01:54 <nuncanada> Finally dynamic meritocracy will prevail
21:01:56 <SamB> shitty as anything?
21:02:11 <nuncanada> Read Amartya Sen's article about meritocracy
21:02:13 <dolio> You might as well use /\ and \/ I guess, since you can.
21:02:14 <Shimei3> nuncanada: github? Link?
21:02:17 <edwardk> doing [f, g] means no unicode required for the common case, but requires a [_] operator with precedence such that , can sit inside it
21:02:26 <dolio> Since you're all evil and dynamically typed. :)
21:02:31 <nuncanada> You will see that open source is mostly a "static" meritocracy
21:02:35 <SamB> edwardk: does it now?
21:02:46 <SamB> agda uses [_,_]
21:03:00 <edwardk> that works too
21:03:01 <nuncanada> github.com
21:03:34 <Shimei3> Yeah, just googled it. Very interesting. Web 2.0 of open source project management?
21:03:49 <SamB> nuncanada: one small problem I have
21:03:54 <edwardk> dolio: bah. the goal is to see how far supero-style inlining and contract checking can go, we'll see ;)
21:03:56 <SamB> that little word "git"
21:04:39 <nuncanada> With dvcs and specially sites/applications like github that actually make forking look good things are going to change
21:04:43 <edwardk> er supero-style specialization
21:04:45 <nuncanada> forks are the future :)
21:04:59 <nuncanada> SamB, which?
21:05:02 <nuncanada> ahh
21:05:06 <nuncanada> hehehe
21:05:28 <edwardk> so , next point of syntax,  or return? =)
21:05:32 <nuncanada> you dont like it? darcs is much more friendly, but doesnt seem they have got it right still
21:05:39 <SamB> edwardk: I'd go with return
21:05:42 <nuncanada> it's time to market is passing
21:05:52 <nuncanada> its
21:06:04 <edwardk> samb: boring. ;) next you'll be saying i should go with Nil or Nothing instead of  ;)
21:06:06 <SamB> edwardk: or possibly unitM
21:06:32 <SamB> well, I don't think a greek letter fits too well with >> and >>=
21:06:33 <edwardk> but yeah i'm already pretty sold on return
21:06:34 <dolio> eta, all the way.
21:06:47 <edwardk> well i can replace >>= with * if i have to =)
21:06:48 <SamB> eta reminds me of eta-reduction/expansion
21:07:03 <edwardk> it is the multiplication of the monad after all
21:07:29 <edwardk> (i'll admit the precedence on that gives me fits though)
21:07:59 <SamB> I honestly don't think the greek letter fits with * either
21:08:04 <edwardk> yeah
21:08:15 <SamB> a lone greek invokes the idea of "variable" in my mind
21:08:23 <edwardk> well, i suppose you could make everyone work with eta and mu ;)
21:08:31 <gwern> github makes me sad. I could've invented such a thing, since I was thinking about how to carry through on the promise of dvcs - what good is being able to cheaply branch if no one can 'see' it? also: uses git
21:08:47 <SamB> unless, of course, it is immediately followed by an identifier with no intervening whitespace
21:09:05 <edwardk> samb: yeah whereas my syntax rules currently require the whitespace there
21:09:38 <ddarius> SamB: Just stop using (>>=) and start using 
21:09:56 <SamB> well, anyway, , , and  are probably exceptions in my mind...
21:10:38 <edwardk> samb: of course thats because you've been working in a system that uses them heavily. do more explicit recursion and you start using mu and nu that way, etc.
21:10:38 <SamB> oh, and I now think of  as fix
21:11:03 <dmwit> But, but!
21:11:28 <dmwit> Mathematicians and theoreticians use single-character Greek because it is fast to write as a name in proofs.
21:11:39 <dmwit> But when coding, that's not what it's all about!
21:11:53 <edwardk> dmwit: point, but they also have a certain visual clarity
21:12:01 <nuncanada> gwern, :) - But that's probably just the beginning, i can see people wanting to cherry pick patches from multiple branches for production... You could work on that :)
21:12:56 <SamB> edwardk: and which system have I been working in that uses them heavily?
21:13:02 <gwern> nuncanada: too hard. I'm totally demoralized witnessing github. if it takes an entire startup of coders better than I to get that far...
21:13:45 <edwardk> samb: i'd presume just doing work with haskell, and reading papers that talk about system F_whatever
21:14:17 <SamB> first of all, Haskell doesn't use any of those characters ;-)
21:14:29 <edwardk> samb: yeah but every paper on it does ;)
21:14:42 <SamB> edwardk: not 
21:14:52 <SamB> not EVERY paper
21:14:57 <SamB> surely!
21:15:14 <edwardk> =)
21:15:16 <SamB> though honestly at this point I probably would not notice
21:15:24 <dmwit> ?index Complex
21:15:25 <lambdabot> Data.Complex
21:15:30 <SamB> \, , it all looks the same to me ;-)
21:16:16 <edwardk> thanks for pointing that out though,  makes a nice bifunctor fixpoint constructor ;)
21:17:48 <SamB> and I think only system F & similar use , and I haven't seen too many systems that actually use /
21:18:21 <SamB> though notably when debugging horrible JHC bugs you tend to see a lot of those, as well as 
21:18:22 <edwardk> PTS-based system use Pi
21:18:48 <SamB> (because, you guessed it, JHC uses a PTS-based IR)
21:19:10 <edwardk> yeah, it was one of the ways i got my head around them =)
21:19:12 * gwern reads 'Lambda, The Ultimate TA'. sounded like a fun course to take, although hard on the lecturer :)
21:19:13 <SamB> (and has few enough developers that they aren't afraid to use Unicode)
21:19:16 <ddarius> LF based systems tend to use  a lot.
21:19:50 <Samy> Ok.
21:20:03 <SamB> ddarius: except they also have a strange tendency to use brackets or keywords to convey that information even if unicode is liberally used in that language
21:20:14 <SamB> ASCII brackets, even!
21:20:16 <ddarius> Many do.
21:20:41 <SamB> ... except of course they tend to revert to the greeky notation for papers ;-)
21:20:49 <ddarius>  is obviously oft used in the  calculus
21:20:50 <edwardk> yeah. i'll admit i still find the automath-style () {}'s to be distracting
21:21:44 <SamB> what was the  calculus again?
21:21:46 <edwardk> of course when i tried to replace them with a 'pi' keyword it didn't help much, and confused the hell out of everyone who wasn't me.
21:21:56 <edwardk> samb: pure parallel processing calculus
21:22:17 <edwardk> messages over channels and whatnot
21:22:19 <Samy> Give me a logician, please.
21:22:19 <SamB> for some reason I am thinking of functional nets
21:22:53 <SamB> @go petri nets
21:22:54 <lambdabot> http://en.wikipedia.org/wiki/Petri_net
21:22:59 * edwardk kinds one roaming about the halls and gives him to Samy.
21:23:44 <orbitz> SamB: have you ever been to google.com? they are a new search engine technology that is really impressive
21:23:55 <dmwit> kinds: funny typo, or planned horrible pun?
21:23:59 <edwardk> ok, so now i gave up eta for return should i give up mu for 'fix' also? ;)
21:24:11 <dmwit> Yes, please.
21:24:16 <edwardk> bah
21:24:19 <SamB> orbitz: I am aware of this fact, being the original implementor of @google...
21:24:19 <edwardk> you guys are no fun ;)
21:24:43 <orbitz> SamB: i gotta keep up
21:24:46 <dmwit> Score one for readability!
21:24:50 <edwardk> dmwit: typo, but came across as the other ;)
21:25:03 * edwardk watches all his pretty unicode vanish from his prelude.
21:25:30 <edwardk> can i at least keep  as overloaded nil/nothing/empty set? =)
21:25:40 <ddarius> edwardk: You should rewrite you Prelude in Bengali.
21:25:48 <SamB> why oh why does Wikipedia's syntax for -calculus not include !
21:25:49 <edwardk> 1 : 2 :  doesn't suck
21:25:57 <ddarius> Yes it does.
21:26:18 <edwardk> ddarius: and [] is more intuitive somehow? =)
21:26:31 <SamB> how about just 'nil' for the empty list?
21:26:47 <ddarius> pi isn't actually a binder in the pi-calculus
21:27:01 <dmwit> For once, I don't find "nil" better than .
21:27:02 <edwardk> because: view-maybe (x + ) = x looks very clean =)
21:27:20 <SamB> ddarius: yes, but you'd think it would appear in the syntax for the calculus at some point wouldn't you?
21:27:26 <conal> Are memo tries in a hackage package?
21:27:34 <dmwit> The problem I have is with very in-joke style notations; both nil and  strike me as such.
21:28:05 <ddarius> SamB: Only because you are used to the lambda calculus and the lambda-mu calculus, and the sigma calculus and the rho calculus.
21:28:24 <ddarius> joke?
21:28:39 <dmwit> I guess "jargon" is close to the word I'm looking for.
21:29:17 <edwardk> dmwit: well, any convention is 'jargon' to someone from outside of that background.
21:29:17 <dmwit> i.e. fix-point could be understood by somebody who has taken some classes (but not read any papers), whereas mu is much less descriptive unless you already associate it with the fix-point for some reason.
21:29:22 <dmwit> Yes, I know.
21:29:31 <dmwit> It's a judgment call, definitely.
21:29:44 <SamB> why do you think nil is an in-joke?
21:30:23 <SamB> it's about as familiar as cons, I should think...
21:30:23 <edwardk>  works for me because of the clear analogue to the empty set.
21:30:25 <dmwit> Where is it used outside of Lisp?
21:30:36 <dmwit> SamB: Cons is insider, too.
21:30:39 <dolio> Ruby.
21:30:59 <dmwit> But then, (:) and [] are pretty insider, too.
21:31:00 <SamB> doesn't everybody have to learn lisp during their hazing?
21:31:20 <dmwit> Nope, I never heard of Cons until I saw it in a tutorial that was "explaining" Haskell lists.
21:31:26 <edwardk> dmwit: at the end of the day my toy language is an untyped haskell-analogue with agda syntax. my 'niche' is already 2-3 levels removed from the general population ;)
21:31:35 <SamB> dmwit: you must have missed your hazing!
21:31:40 <dmwit> =)
21:31:46 <ddarius> And by 2-3 levels, he means like 5-6.
21:31:52 <edwardk> ddarius: hahahaha
21:32:08 <SamB> ddarius: he was of course referring to the general PROGRAMMER population
21:32:19 <ddarius> Okay. 4-5
21:32:24 <SamB> hah
21:32:27 <SamB> which levels?
21:32:31 <edwardk> i'm sure that my one other user (since we all know it being a haskell project, gwern will check it out of the darcs repo long enough to build it) will appreciate the lack of in-references ;)
21:33:04 <dmwit> gwern++
21:33:34 <ddarius> Programmers -> Haskell Users -> Haskell Users who care about type theory -> Agda Users -> Agda Users who care what edwardk is doing
21:33:40 * gwern hears my name
21:34:11 <SamB> ddarius: wait, justify that second arrow?
21:34:15 <gwern> edwardk: ln pls kthnxbai
21:34:34 <edwardk> gwern: not ready yet, but forthcoming once i resolve some issues
21:35:00 <ddarius> SamB: Some Haskell users write programs other than interpreters.
21:35:10 <edwardk> ddarius: heretics!
21:35:21 <SamB> ddarius: but ... surely ... they care about type theory in some sense?
21:35:34 <SamB> maybe I don't know what type theory actually means?
21:36:43 <edwardk> mostly i'm just enjoying working in an untyped setting that requires more thought about types than the typed setting
21:36:59 <ddarius> edwardk: Isn't that always the case?
21:37:09 <edwardk> ddarius: fair nuff.
21:37:16 <gwern> @wn gyve
21:37:17 <lambdabot> No match for "gyve".
21:37:57 <edwardk> ddarius: but being able to share constructors between a bunch of monads is kinda interesting. it points to what a language with real subtyping could do with them.
21:38:02 <SamB_XP> the worst part is that an untyped setting also makes the types much harder to think about
21:39:05 * SamB_XP would like subtyping just because it could make things prettier...
21:39:16 <bos> is there any way to have the scope of an existential type range over multiple constructors?
21:39:32 <SamB_XP> bos: what the ???
21:40:10 <edwardk> back to earlier, i think () wins because it doesn't give up [] notation for lists, and leaves open the 'arc trick' for applying arrays and lists as functions, since that fits with my overapplied constructors as functions model.
21:40:17 <bos> SamB_XP: http://hpaste.org/7577
21:40:33 <edwardk> bos: use one constructor and wrap a nested type?
21:40:35 <bos> SamB_XP: GHC is quite reasonably convinced that the two uses of a have nothing in common
21:40:35 <SamB_XP> bos: I don't understand the question at all
21:40:51 <SamB_XP> it makes no sense to me...
21:41:09 <bos> edwardk: probably, yes.
21:41:44 <dolio> SamB_XP: He wants 'data Foo = forall a. (Constructor1 a | Constructor2 a | ...)'
21:42:21 <dmwit> data HttpResponse' = RespSuccess [String] | RespClientError [String]
21:42:41 <dmwit> data HttpResponse = forall a. JSON a => Response HttpResponse' a
21:42:48 <edwardk> dmwit: exactly
21:42:58 <edwardk> bos: i presume you wanted that so you could do case analysis?
21:43:12 <bos> edwardk: yes
21:43:45 <bos> dmwit: the usual trick with existentials, in other words
21:44:01 <edwardk> bos: yeah, that should work fine unless you have a bigger problem =)
21:47:05 <edwardk> ok, last one for the philistine crowd to shoot down: * as >>= ?
21:47:14 <dmwit> I like it!
21:47:52 <edwardk> i need to see how bad my precedence gets mucked up by it but that was my reaction as well
21:48:21 <ddarius> edwardk: Is it going to be postfix and flipped?
21:49:03 <dolio> Use 
21:49:06 <edwardk> ddarius: i'd just been thinking Just foo * \x -> ...
21:49:08 <dolio> Just to mess with people.
21:49:30 <ddarius> f :: a -> m b; f* :: m a -> m b
21:50:34 <edwardk> ddarius: thought about it, that and that could also work for other uses like map if you want to go that way as well.
21:50:58 <edwardk> hrmm
21:51:29 <edwardk> thinking seriously about what the postfix * would look like. interesting because then you pointfree *'d operations, but i think it gets noisy with ()'s
21:56:43 <dobblego> what is the method of proof called, where you find a counter-example to a universally quantified statement?
21:58:44 <dolio> Disproof?
21:59:33 <bos> it doesn't have a name, and it's not a method of proof. it's a method of refutation.
21:59:46 <Pseudonym> I think you're referring to a special case of proof by contradiction.
21:59:47 <OceanSpray> > eval "1 + 1"
21:59:48 <bos> it's usually just called "proof by counterexample".
21:59:48 <lambdabot>   Not in scope: `eval'
21:59:53 <dobblego> what is it called when QC falsifies a property?
21:59:54 <OceanSpray> hmm.
21:59:56 <Pseudonym> Right, proof by counter-example.
22:00:02 <glguy> fail by counter-example?
22:00:02 <dobblego> yes I thought so, thanks
22:00:04 <Pseudonym> dobblego: A bug.
22:00:08 <OceanSpray> @index eval
22:00:08 <lambdabot> bzzt
22:00:28 <OceanSpray> Haskell is very, VERY different from Lisp, aye.
22:00:33 <glguy> OceanSpray: we are fortunate enough not to have an eval
22:01:04 <OceanSpray> you say "fortunate"
22:01:08 <OceanSpray> why?
22:01:18 <SamB_XP> eval is ... really messy
22:01:21 <ozy`> OceanSpray: because all dynamic code is oooovil
22:01:23 <ddarius> Haskell is very very different from Lisp.
22:01:57 <glguy> eval tell you your program isn't finished
22:03:24 <gwern> eval says to me, like using randomness, 'your program is still too stupid'
22:04:26 <OceanSpray> huh.
22:04:28 <sm> ah now.. all programs tackling hard problems are too stupid, and it can't really be otherwise
22:04:56 <OceanSpray> and here I was trying to imagine a Haskell-Lisp hybrid.
22:04:57 <bos> lisp programmers don't use eval, anyway.
22:05:05 <OceanSpray> (Yes, I've already seen Liskell)
22:05:13 <sm> there's something to be said for constant evolution
22:05:14 <gwern> OceanSpray: liskell... ah nm
22:05:19 <bos> macros are far more interesting and useful than eval.
22:05:28 <gwern> well, you could look at the successor to qi
22:05:28 <OceanSpray> bos, indeed.
22:05:41 <OceanSpray> but a lisp isn't lisp unless it has eval and apply.
22:05:43 <dolio> Qi has a successor?
22:05:50 <OceanSpray> Qi II?
22:05:56 <gwern> bos: now what we need is compile-time stuff which doesn't drive you nuts
22:05:56 <OceanSpray> I saw that already, too.
22:06:13 * gwern glares in the direction of Template Haskell and type-level programming
22:06:36 <gwern> 'Statically Typed Macros For Mortals', maybe
22:06:41 <SamB_XP> gwern: type-level programming is compile-time?
22:06:44 <OceanSpray> gwern, that's exactly why I've been thinking of lisp-haskell-hybrids.
22:07:10 <sm> what about plt typed-scheme ?
22:07:14 <gwern> SamB_XP: that's when the type-checking takes place, no?
22:07:30 <OceanSpray> with dependent typing, things can get a bit iffy, no?
22:08:19 * gwern finishes up for the night
22:09:15 * ozy` clears his throat
22:09:19 <ozy`> so uh
22:09:38 <dmwit> I wonder if Data.Set.filter *really* needs that Ord restriction.
22:09:42 <dmwit> Not that it really matters.
22:09:44 <ozy`> what editors do you guys use?
22:09:48 <dmwit> vim
22:09:50 <cjb> emacs!
22:09:54 <Pseudonym> gvim
22:10:04 <dmwit> I think those two shouldn't surprise you much. =)
22:10:10 <ozy`> yeah, not really
22:10:22 <Pseudonym> dmwit: Ord is a restriction on Data.Set, so it probably does.
22:10:29 <Pseudonym> But probably only transitively.
22:10:37 <ozy`> so, then, would the vim people mind pointing me towards useful plug-ins? :p
22:10:55 <dmwit> Pseudonym: Hmm, I think the Ord instance is only on functions using Set.
22:11:12 <ozy`> (I'm afraid indentation is about the only thing I like about emacs)
22:11:13 <dmwit> data Set a = Tip | Bin Size a (Set a) (Set a) -- Defined in Data.Set
22:11:17 <Pseudonym> :t Data.Set.filter
22:11:20 <lambdabot> forall a. (Ord a) => (a -> Bool) -> S.Set a -> S.Set a
22:11:26 <sm> *emacs*!
22:11:28 <dolio> filter might have to rebalance the tree.
22:11:30 <OceanSpray> emacs!
22:11:42 <dmwit> ah
22:11:46 <dolio> Although, strictly speaking, I suppose the ordering is already encoded in the set structure.
22:11:52 <Pseudonym> dolio: I was about to say, yes.
22:11:56 <Pseudonym> Rotations don't need Ord.
22:12:08 <dmwit> Yeah, that was the original reason I was wondering. =P
22:12:13 <dolio> Using that might be hard.
22:12:26 <Pseudonym> The thing is, not putting the Ord in the type might expose an implementation detail.
22:12:42 <Pseudonym> And might make later internal changes difficult.
22:12:59 <dmwit> hm
22:13:07 <dmwit> I could believe that.
22:13:27 <Pseudonym> Filter on Patricia tries would, I think, need the appropriate Integral constraint, for example.
22:14:15 <Pseudonym> If IntMap were made generic, for example.
22:16:54 <edwardk> ok, one last random syntax question. i've been thinking about using 'ok' instead of return in the same vein that erlang uses ok, its shorter, and less noisy
22:17:31 <OceanSpray> define a macr- oh.
22:18:10 <dobblego> why is that a syntax question?
22:18:22 <dmwit> edwardk: Hmm.
22:18:52 <dmwit> edwardk: Is this return as in the monad-version of return?
22:18:59 <edwardk> dobblego: er i suppose i was wondering about objections/thoughts
22:19:00 <OceanSpray> ok = return ?
22:19:02 <edwardk> dmwit: yeah
22:19:11 <dmwit> OceanSpray: He's writing his own language.
22:19:12 <dobblego> edwardk, in fact, I prefer it
22:19:17 <dobblego> oh
22:19:23 <OceanSpray> oh, I see now.
22:19:23 <dobblego> then, I prefer it even more
22:20:05 <OceanSpray> hey edwardk, if it doesn't trouble you much,
22:20:06 <Pseudonym> How about U HAZ?
22:20:16 <OceanSpray> could you describe your language?
22:20:47 <dobblego> has someone aliased the Prelude functions with stuff like U HAZ before?
22:20:50 <dmwit> Ord a implies Eq a, right?
22:21:07 <dmwit> ?src Ord
22:21:08 <lambdabot> class  (Eq a) => Ord a  where
22:21:08 <lambdabot>     compare      :: a -> a -> Ordering
22:21:08 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
22:21:08 <lambdabot>     max, min         :: a -> a -> a
22:21:54 <edwardk> oceanspray: the short version is its an untyped haskell-like syntax with open variants, basically you can call any function with any variant, but to compensate and since i can't rederive typeclasses in that setting you have to be able to extend any function from any module (whee there goes modularity and separate compilation!) and that changes the pattern matching rules to be 'most specific first'
22:22:41 <OceanSpray> huh.
22:22:43 <OceanSpray> interesting.
22:23:13 <edwardk> to recover overloading for most operators i have to cheat, if you need something to have a specific type you have to 'view' it through a view function. i.e. so 'if' takes its first argument and calls the 'bool' view function on it that reduces it to true or false. this is tricky for == , so there you have to explicitly pass it a view to compare on.
22:24:01 <dmwit> And to implement the view, you have to use a view... =P
22:24:28 <edwardk> @hpaste
22:24:29 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:26:17 <edwardk> dmwit: nah http://hpaste.org/7579
22:26:30 <edwardk> er wow, hpaste ddoesn't like unicode =)
22:26:34 <dmwit> yeah, heh
22:27:38 <edwardk> dmwit: view-boolean is just a function that transforms its argument to a valid boolean value of true of false assuming it is constructed using a valid set of operations.
22:27:43 <OceanSpray> Oh little black question marks...
22:27:54 <OceanSpray> what mysteries do you hide in your bosoms?
22:28:08 <OceanSpray> What secrets lurk within your hexagonal shell?
22:28:35 <edwardk> anyways you get the idea
22:28:59 <roconnor> OceanSpray: change to iso-latin-1 to get rid of the question marks
22:29:03 <edwardk> so an int function goes down and monomorphizes applications of + and * etc.
22:29:25 <roconnor> OceanSpray: , , , etc.
22:29:31 <roconnor> :P
22:29:32 <edwardk> roconnor: which for me trades them in for other noise ;)
22:31:07 <edwardk> lines like: boolean-algebra (True  a)      = a -- work because you view the boolean algebra through a catamorphism so by the time you get down to the  constructor, you've already reduced everything underneath it to True or False
22:31:10 <SamB_XP> OceanSpray: he's teasing you, btw
22:32:14 <SamB_XP> edwardk: you make a lot of assumptions about boolean algebras ;-)
22:32:16 <edwardk> btw- i was rather amused that the initial algebra in question for bool was the laws for boolean algebra. ;)
22:32:34 <edwardk> samb: sure
22:32:41 <edwardk> i was looking for a classic haskell Bool type ;)
22:33:17 <edwardk> you can go through and derive a version for a heyting style derivation
22:34:09 <roconnor> edwardk: I think SamB_XP's point is that there are other boolean algerbras other than the 2-element one.
22:34:10 <edwardk> anyways the reason the reason the algebra is so large is because i let most operators be constructors so i can overload pretty much anything
22:34:32 <edwardk> roconnor: sure. technically this is a 'Bool'-algebra, not a general boolean algebra ;)
22:34:44 <SamB_XP> the usual name is "2"
22:34:54 <roconnor> I see the confusion
22:35:05 <edwardk> fair nuff, but people were giving me crap about wanting to use eta before for return ;)
22:35:46 * SamB_XP wonders if his logic design teacher knows any of this ;-)
22:35:47 <edwardk> if i start having if use the 2-view on its arguments i think there'd be a mass exodus of interest leaving on samb in the room ;)
22:36:12 <OceanSpray> logic... design?
22:36:38 <SamB_XP> OceanSpray: EE 230 at widener.edu
22:36:49 <OceanSpray> please do explain, for the juxtaposition of these terms intrigues me.
22:36:51 <edwardk> er leaving only
22:38:29 <SamB_XP> OceanSpray: covers the design of simple combinational and extremely simple sequential circuits, as well as the basics of number representation
22:38:35 <edwardk> my biggest issue at this point is == really, which since i don't have typeclasses i can't rely on a 'newtype deriving' kind of mechanism, which means to get anything practical i need a sort of 'generic kata' before i even release the base language ;)
22:38:43 <SamB_XP> in short, rather boring
22:39:01 <OceanSpray> I sort of get what that course teaches now.
22:39:25 <dmwit> http://hpaste.org/7580
22:39:41 <SamB_XP> you know, with logic gates and such
22:40:08 <SamB_XP> and the 2-element boolean algebra
22:40:51 <SamB_XP> (though it wasn't referred to as such)
22:41:06 <roconnor> SamB_XP: what did they call it?
22:41:11 <SamB_XP> boolean algebra
22:41:45 <SamB_XP> not sure if that's what they call it in the book, and a classmate accidentally took mine home...
22:42:00 <roconnor> I decree that a Boolean algebra is a 2-element boolean algebra.
22:42:15 <SamB_XP> so I won't see it until summer classes start at least
22:42:19 * roconnor ends that confusion
22:42:21 <SamB_XP> ... which is next monday
22:42:24 <SamB_XP> roconnor: hah
22:42:28 <SamB_XP> yeah right
22:42:32 <SamB_XP> that's not going to help much!
22:42:47 <SamB_XP> anyway, to bed with me...
22:42:48 <roconnor> B vs b
22:42:56 <OceanSpray> still, the "design" part is sort of misleading.
22:42:57 <roconnor> a whole bit difference
22:43:06 <SamB_XP> yes, case distinctions tend to be rather confusing!
22:43:23 <OceanSpray> more like "utilization of logic in computer and software engineering"
22:43:30 <OceanSpray> or something.
22:43:32 <OceanSpray> I don't know.
22:43:45 <OceanSpray> Good night, and God bless.
22:43:53 <SamB_XP> OceanSpray: well, the fact that it's an EE course should be a clue ;-)
22:44:38 <cjs> Now this is what I like about Haskell: you get to be evil: http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/12
22:44:39 <lambdabot> Title: Haskell hacking
22:45:56 <dons> cjs: :)
22:46:11 <dons> in other languages, evil is so common, no one notices. but here, its fun, because its *so* abnormal
22:46:24 <roconnor> dons: it needs more unsafePerformIO.
22:46:36 <cjs> I particularly like that bit about one non-termination being as good as another.
22:46:40 <dons> oh, right at  the end it hints at the unsafeCoerce# implementation
22:47:03 <dons> cjs: hehe. seems fine to me. i was so happy it worked. :)
22:47:19 <cjs> You'll get people complaining about gcc having poor error messages again....
22:47:33 <cjs> (And that's about as poor as it gets.)
22:48:11 <sjanssen> dmwit: how does that look?
22:48:33 <dmwit> ooo
22:48:40 <dolio> dons: Seems you guys need to work on your C skillz. They're not up to snuff for writing a Haskell book. :)
22:49:17 <cjs> But more seriously, this kind of stuff gives me a warm and fuzzy feeling because the room is there to do the "shit you sometimes have to do" when you're writing commerical programs.
22:49:22 <edwardk> @hpaste
22:49:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:49:45 <dmwit> sjanssen: Pretty nice, thanks!
22:49:46 <cjs> hpastes still aren't showing up here; is that ever going to be fixed?
22:50:19 <edwardk> hey can someone take a look at http://hpaste.org/7581 and figure out what i'm doing wrong in the syntax for my type family?
22:51:18 <dmwit> I think the "very evil" solution is nicer than the non-terminating compiler solution.
22:51:36 <dmwit> This is a very cool post, though, does it have an accompanying reddit link to upvote? =)
22:52:05 <edwardk> nevermind
22:52:06 <cjs> dmwit: That's just evil tempting you to the dark side.
22:52:13 <dons> dmwit: it was yesterday, http://reddit.com/r/programming/info/6j0mb/comments/
22:52:18 <dolio> edwardk: {-# -fglasgow-exts #-} isn't a pragma?
22:52:30 <edwardk> yeah
22:52:36 <edwardk> fixed thanks =)
22:53:22 <edwardk> i realized i could do type level power series with the automatic differentiation trick. wanted to see how far i could take it
22:55:35 <edwardk> i think it only works with type families though. can't see how type classes would work
22:55:49 <edwardk> since you need to be able to recurse on a function of the type each time
22:56:16 <solrize_> @seen cosmicray
22:56:17 <lambdabot> I saw cosmicray leaving #darcs and #haskell 8h 20m 37s ago, and .
23:02:44 <sjanssen> dmwit: and you can be somewhat confident the implementation is correct, if that matters :)
23:03:00 <dmwit> Yeah, it's more obvious.
23:03:26 <dmwit> It makes slightly more assumptions about the input, but those assumptions are true anyway, so that's fine with me. =)
23:03:41 <dmwit> (i.e. it assumes no repetitions in either list)
23:04:13 <sjanssen> ah
23:04:17 <sjanssen> I just assumed they were sets
23:04:27 <sjanssen> dmwit: did you see the quickchecks?
23:04:30 <dmwit> They are. =)
23:04:43 <dmwit> ...no
23:05:03 <sjanssen> what happened to the hpaste bot?
23:05:04 <dmwit> Ah, another annotation.
23:07:47 <sjanssen> they point out an interesting fact -- your function is just a fused version of intersect and difference
23:07:56 <dmwit> Yeah,
23:08:22 <dmwit> I sort of knew that going in, but I didn't think there was a convenient "fuse" function. =P
23:08:35 <sjanssen> yes, I'm not sure if there is either
23:08:40 * sjanssen ponders
23:08:53 <dmwit> And the ordered-ness means we can make intersect and (\\) more efficient.
23:09:12 <sjanssen> right
23:09:21 <dmwit> I would be fine with (intersect &&& (\\)), if it were efficient versions of each.
23:11:03 <cjs> You know what's a pain? When you're refactoring something, and there's a zillion tons of code you have to change to get it to compile, so it's really hard to test out little bits of the change as you go.
23:11:24 <dmwit> I often start over in that case.
23:11:36 <dmwit> But yeah.
23:12:12 <cjs> Well, at this point I'm trying out commenting out most of my module, and then changing bit by bit, uncommenting as I go, and loading in ghci to test.
23:12:44 <cjs> I can't use my unit test framework because once I start changing this module, it won't link until I fix everything.
23:13:13 <cjs> And boy am I now in love with nesting comments.
23:22:24 <dons> Igloo: something wrong with -cafe@? the queue seems backed up
23:27:43 <sjanssen> dmwit: my last annotation makes the fusion pretty clear, I think (but it is ugly as hell)
23:29:02 <dmwit> I guess it's intersect' ms.
23:29:15 <dmwit> (Just a typo ys -> ms.)
23:29:59 <sjanssen> oh, yeah
23:30:07 <dons> http://hpaste.org/7582 nice little program where ghc beats unoptimised C.
23:30:08 <dmwit> Yeah, that's interesting.
23:30:53 <dons> sadly, optimised still wins. a couple of instructions shorter.
23:30:55 <dons> ?bug
23:30:55 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
23:31:00 <sjanssen> dons: so how many responses to Mr. Coppin's email are backed up on -cafe? :P
23:31:05 <sjanssen> I know I responded
23:31:06 <dons> 2 :)
23:31:20 <dons> I wrote one, midday, and assumed that i forgot to send it
23:31:25 <dons> so i sent another, oh well
23:31:44 <solrize_> -fvia-C  ?  what does the intermediate C code look like?
23:31:45 <sjanssen> dons: that is actually pretty amazing
23:32:06 <sjanssen> I wonder how ghc manages that?
23:32:19 <dons> no GC runs either.
23:32:26 <dons> i'll add the asm
23:34:07 <solrize_> if it's via C, that means ghc is generating better C code than the handwritten C program ?
23:34:18 <solrize_> or it's compiling its output with gcc -O i guess
23:34:27 <dons> yeah
23:34:43 <dons> they should generate pretty much the same assembly
23:34:45 <sjanssen> dons: are you using gcc -O?
23:34:52 <dons> nope.
23:35:00 <sjanssen> that isn't fair
23:35:04 <dons> right.
23:35:09 <dons> unoptimised C.
23:35:22 <sjanssen> so how does ghc do against gcc -O
23:35:24 <dons> i figure is the benchmark, to be competitive
23:35:31 <dons> gcc -o is 1.8s
23:35:33 <dons> -O
23:35:42 <dons> though i can't see why, the asm is almost the same
23:35:46 <dons> so i'm going to file a bug report
23:35:54 <dons> to the native codegen ticket
23:35:55 <sjanssen> how does -fasm do?
23:36:06 <solrize_> is ghc using gcc -O ?
23:36:13 <dmwit> yes
23:36:45 <sjanssen> dons: are you on x86-64?
23:37:17 <solrize_> i'm interested in seeing the asm
23:37:28 <dons> on its way.
23:37:31 <solrize_> cool
23:37:42 <dons> sjanssen: yeah
23:38:01 <solrize_> what cpu?
23:38:49 <dons> core 2 duo
23:38:53 <solrize_> hmm
23:39:07 <solrize_> i can test on an athlon-64 if you want
23:39:26 <sjanssen> dons: Int is 64 bits, while int is 32
23:39:28 <sjanssen> does that explain it?
23:39:32 <dons> ah. hmm
23:39:45 * dons always forgets
23:39:59 <dons> $ time ./a.out
23:39:59 <dons> 500000000.067109
23:39:59 <dons> ./a.out  4.57s user 0.00s system 100% cpu 4.568 tota
23:40:02 <dons> for C. pretty much the same
23:40:17 <dons> and same result optimised.
23:40:20 <dons> $ time ./a.out
23:40:20 <dons> 500000000.067109
23:40:21 <dons> ./a.out  3.61s user 0.00s system 99% cpu 3.616 total
23:40:26 <dons> hmm, so that means ghc and gcc win hereE :)
23:40:35 <dons> ok. so now that's interesting.
23:41:14 <dmwit> whoa
23:41:25 <dmwit> Oh.  So that means GHC wrote better C code than you did.
23:41:47 <sjanssen> dons: the first result is C with a 64 bit int, and second is ghc?
23:42:05 <solrize_> $ time ./a.out
23:42:06 <solrize_> 500000000.067109
23:42:06 <solrize_> real    0m6.508s
23:42:06 <solrize_> user    0m6.510s
23:42:06 <solrize_> sys     0m0.000s
23:42:28 <solrize_> (gcc, athlon 64 2000 mhz)
23:43:00 <dons> sjanssen: yeah.
23:43:04 <dons> just about to paste all the code.
23:43:58 <dons> i like how ghc uses an unboxed tuple for the strict pair return type
23:44:37 <dons> http://hpaste.org/7583
23:45:23 <solrize_> a.hs:3:7:
23:45:24 <solrize_>     Could not find module `Data.Array.Vector':
23:45:29 <solrize_> hackage?
23:45:40 <dons> code.haskell.org/~dons/code/uvector
23:46:26 <dons> maybe i can write the partial sums shootout program this way. hmm
23:46:26 <solrize_> oh ok
23:47:06 <mercury^> dons: how does ghc do without -fvia-C?
23:47:30 <dons> good question
23:47:42 <Deewiant> and how about -O2 for GCC
23:47:52 <Deewiant> (much more common than plain -O)
23:48:23 <solrize_> that asm doesn't look like c ouptut
23:48:32 <dons> ah, no xmms instructions
23:48:41 <dons> in -fasm
23:48:44 <dons> but the code looks better
23:49:17 <dons> mercury^: http://hpaste.org/7583#a1
23:49:56 <mercury^> nice
23:49:57 <mercury^> :)
23:50:19 <dons> no computed jumps.
23:50:24 <dons> i'm surprised how well -fasm does there.
23:50:27 <solrize_> i see the ghc version adds xmm0 into xmm5, then uses xmm5 in the very next instruction which may be a pipeline stall
23:50:39 <dmwit> GHC does better than GHC -fvia-c does better than gcc -O?
23:50:41 <dmwit> Wow!
23:51:02 <dons> well gcc -O still wins, doesn't it?
23:51:07 <dons> by a fraction
23:51:20 <dons> ah,
23:51:23 <dons> but gcc -O2 is way better
23:51:24 <dons> $ time ./a.out
23:51:24 <dons> 500000000.067109
23:51:24 <dons> ./a.out  2.22s user 0.00s system 100% cpu 2.217 total
23:51:26 <dons> oh well
23:51:30 <dons> now i might be able to make a bug report
23:51:34 <dmwit> Oh, sorry, yes.
23:51:46 <solrize_> http://www.agner.org/optimize/   this site is amazing
23:51:46 <lambdabot> Title: Software optimization resources. C++ and assembly. Windows, Linux, BSD, Mac OS X
23:51:54 <dons> while -optc-O2 doesn't help ghc much
23:52:24 <solrize_> the guy went to extreme lengths to time all the x86 instructions and identify the pipeline hazards, much more thoroughly than the intel/amd manuals
23:52:25 <mercury^> the plan is to ditch -fvia-C anyway, isn't it?
23:52:43 <mercury^> good plan imo
23:52:46 <dons> mercury^: yeah, normal ramsey et al are just starting up on a state of the art code generator
23:52:51 <dons> i saw some commits today actually
23:53:11 <solrize_> wow
23:53:37 <dons> sjanssen: these vector stream fused array ops sure are great for smacking down little programs on -cafe@ :)
23:53:44 <dons> i need to get it released
23:57:10 <dons> solrize_: did you have a go building uvector? should be pretty easy
23:57:20 <olsner> vector stream fused array ops? that sure sounds amazing, although it could mean anything to me :P
23:57:34 <dons> ?go stream fusion
23:57:35 <lambdabot> http://stream-fusion.oldiblog.com/
23:57:35 <lambdabot> Title: streaming films sries mangas gratuit
23:57:41 <dons> hmm
23:57:44 <dons> ?go stream fusion lists
23:57:45 <lambdabot> No Result Found.
23:57:49 <dons> you suck google
23:57:59 <dons> olsner: the thing that turned the arrays into a tight loop
23:58:17 <dons> big time optimisation via transformation
23:58:22 <olsner> ;-)
23:59:07 <solrize_> dons i'm just browsing uvector, i will try to build it
23:59:25 <dons> should build fine with 6.8.2 or later
23:59:32 <dons> uses associated types
23:59:53 <solrize_> woah, wget is going berserk
