00:00:04 <glguy> no
00:00:31 <glguy> my nick doesn't really mean anything anymore
00:01:41 <cjs> Huh, if you did, *that* would be cool.
00:02:06 <cjs> Since I'm currently writing a Haskell interface to GLTrade. If that's the GL you were thinking of.
00:02:38 <glguy> GaLoisGul?
00:02:41 <glguy> y*
00:11:33 <mxc> cjs - oh really?
00:11:51 <mxc> happen to have a haskell wrapper for bloomberg lying around?
00:15:26 <pastorn> @hoogle Integral
00:15:30 <lambdabot> Prelude.Integral :: class (Real a, Enum a) => Integral a
00:15:30 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
00:16:00 <pastorn> @hoogle (Integral b) => a -> b
00:16:01 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
00:16:01 <lambdabot> Data.Generics.Aliases.unGM :: GenericM' m -> Data a => a -> m a
00:16:01 <lambdabot> Control.Monad.Error.Class.throwError :: MonadError e m => e -> m a
00:17:11 <cjs> mxc, no, sorry. :-/
00:17:44 <cjs> I still mean to set up a haskell-finance list or something like that, at some point.
00:17:53 <mxc> cjs - i'm with you on that
00:18:05 <mxc> someone named anne who lurks around here was interested
00:18:09 <mxc> as is a guy at DB
00:18:19 <cjs> Right; I still have both of your e-mail addresses (you and anne).
00:18:34 <mxc> ah, you were the other, was wondering if it was you
00:18:42 <mxc> i lost the paper I wrote it down on
00:18:47 <cjs> It might be interesting to share packages to dealing with various common components. E.g., calculating maturity dates can be quite interesting.
00:18:48 <mxc> which is pretty lame and pathetic
00:19:12 <mxc> agree
00:19:15 <mxc> all the bullsh1t
00:19:33 <mxc> have been working on a simple stats package since there doesn't seem to be anything thats being used
00:19:43 <mxc> mean, moments, cdf's, pdf's etc
00:21:20 <hpaste>  morrow annotated "oh snap!" with "(no title)" at http://hpaste.org/7908#a3
00:21:24 <cjs> Though I wonder how similar these sorts of calculations are between various groups. We've got this strange and intresting calculation of t that involves the amount of time left in the trading day, but for the days after that, various factors depending on whether they're trading days, weekend days, local holidays (where other exchanges are open), global holidays, etc. etc.
00:22:40 <mxc> that'd definitely be helpful for us
00:23:07 <mxc> especially since the bloomberg calendar doesn't let you copy and paste, so maintaining holiday lists by hands is a pain
00:23:34 <mxc> right now i just count weekdays, in a naive way
00:23:41 <hpaste>  obk pasted "Im/possible to place monadic function inside state monad?" at http://hpaste.org/7910
00:23:57 <mxc> who do you work for in japan?
00:24:38 <cjs> http://www.starling-software.com
00:24:44 <cjs> This trading project is one of our clients.
00:25:18 <cjs> Jeez, yeah, even just a standard way to share lists of holidays and the like for the various major exchanges would be cool.
00:26:02 <mxc> i had written an ocaml version of that for my previous firm
00:26:10 <mxc> which is in chiba and uses ocam extensively
00:26:17 <mxc> cool firm, jane street capital
00:26:29 <cjs> Oh, I've heard of them. I might even know someone who works for them.
00:26:33 <mxc> rob marlow?
00:26:42 <mxc> he was a former big haskeller
00:26:50 <mxc> they're pretty big in the ocaml world
00:26:55 <cjs> Mmmm, name sounds familiar, but this would have been before I got into Haskell.
00:28:06 <obk> Is it posible to place, inside the state of a state monad, a function that is in that monad? (hpaste 7910)
00:30:53 <sjanssen> obk: do you understand the error given?
00:31:09 <obk> Yes
00:31:17 <obk> It makes sort of sense
00:31:17 <sjanssen> type TransformState a = State (Transform, Integer) a
00:31:27 <sjanssen> type Transform = Integer -> TransformState Integer
00:31:45 <sjanssen> so those are obviously cyclic, and they form an infinite type which isn't allowed in Haskell
00:32:18 <sjanssen> the usual solution is to make one of your type declarations into a newtype
00:32:36 <sjanssen> obk: are you using GHC?
00:32:48 <obk> sjanssen: Ok... but as a matter of practivcality, is it possible to work around it (yes, using GHC)
00:33:03 <sjanssen> obk: yes, you can work around this with a newtype
00:33:04 <obk> I want a state monad for transforming complex data structures (trees etc.)
00:33:07 <obk> Ah
00:33:44 <sjanssen> newtype TransformState a = TS (State (Transform, Integer) a) deriving (Monad, MonadState (Transform, Integer), Functor)
00:36:13 <obk> Hah, GHC is too smart for that:
00:36:44 <obk>  Can't make a derived instance of `Monad TransformState' (even with cunning newtype deriving: the newtype may be recursive)  In the newtype declaration for `TransformState'
00:36:58 <obk> Nice try though....
00:37:07 <sjanssen> hmm
00:37:17 <sjanssen> it should be able to generate the instance
00:37:21 <sjanssen> it isn't hard to write it yourself
00:37:35 <obk> It required the -XGeneralizedNewtypeDeriving flag BTW
00:37:51 <sjanssen> of course, as we're using generalized newtype deriving
00:38:06 <cjs> Did that error message really say, "(even with cunning newtype deriving)"?
00:38:16 <opqdonut> :D
00:38:17 <obk> cjs: yes! :-)
00:38:37 <sjanssen> instance MonadState (Transform, Integer) TransformState where get = TS get; put = TS . put
00:38:39 <cjs> Wow, no compiler has ever called me cunning.
00:39:01 <sjanssen> cjs: it isn't calling you cunning, it is calling the newtype deriving system cunning
00:39:21 <cjs> Oh.
00:39:30 * cjs is even more sad, now.
00:40:20 <sjanssen> obk: maybe it would be simpler to give (Int, Transform) a name
00:40:44 <obk> Sure
00:41:01 <sjanssen> newtype IntAndATransformOrPerhapsABetterName = IAATOPABN Int Transform
00:41:25 * obk doesn't quite get the instance approach
00:41:48 <sjanssen> the approach isn't really about that instance
00:42:34 <sjanssen> we have to make something in our cycle a newtype, usually it is convenient to make newtypes of the various Monads with GHC's newtype deriving feature
00:42:39 <sjanssen> but obviously that fails us here
00:43:16 <mxc> god, our software at my current firm is such shit
00:43:28 <mxc> woohoo all C# crash happy, shitty trading software
00:43:43 <mxc> my time writing ocaml/haskell has spoiled me on reliability assumptions
00:43:46 <vixey> It's a common attribute of software written by people
00:43:53 <obk> sjanssen: Making Transform a newtype doesn't work either. Strange.
00:44:35 <sjanssen> obk: "doesn't work"?
00:44:52 <mxc> vixey - static typing, functional programming, and required exhaustive pattern matching eliminates a huge class of runtime errors
00:45:16 <obk> I get a syntax error on the '->' in it
00:45:19 <vixey> mxc: almost all!
00:45:26 <obk> Hmmm... Maybe if I wrap it in something...
00:45:32 <sjanssen> obk: you probably forgot parens around your type
00:49:25 <obk> Hey, almost working
00:49:33 <obk> By making Transform a newtype
00:49:34 <obk> Thanks!
00:49:50 * obk still needs to wrestle with some minor typing issues but it seems like it will work
01:01:01 <obk> Nope
01:01:21 <obk> Nothing seems to work, and the compiler error messages are, well... cryptic
01:02:22 <obk> maybe I should just give up and pass the function around explicitly. Sigh...
01:02:41 <vixey> obk: Why not
01:02:54 <vixey> obk: Maybe you could add ReaderT after that works
01:03:03 <obk> Hmmm
01:03:07 <obk> Now that's an idea
01:03:48 <obk> Makes sense, and "no reason" it shouldn't work
01:04:04 <obk> Too late an night for this anyway. I'll try again after a good night sleep
01:04:11 <obk> vixey: thanks!
01:04:34 * obk goes to gram some zs and recharge his brain ;-)
01:05:44 * ivanm passes obk a power cable to plug into his brain
01:12:36 <vixey> Cryptol looks cool
01:13:01 <vixey> wb Cale
01:13:05 <vixey> hi JaffaCake
01:14:21 <JaffaCake> hi!
01:14:21 <lambdabot> JaffaCake: You have 3 new messages. '/msg lambdabot @messages' to read them.
01:14:41 <JaffaCake> msg lambdabot @messages
01:15:03 <JaffaCake> cut n pasto :)
01:16:11 <opqdonut> :)
01:18:49 <vixey> wow views are cool
01:20:32 <qebab> oh man
01:22:22 <swiert_> vixey: what's that you're reading?
01:22:35 <vixey> Teh Power of Pi
01:22:39 <vixey> The Power of Pi*
01:23:31 <swiert_> It sounded familiar :)
01:24:01 <vixey> swiert: this stuff is really interesting, thank you
01:24:43 <swiert_> vixey: no problem. I really enjoyed writing that paper.
01:27:20 <wolgo> What would be a good way to grab a random line from a file that is about 100,000 lines long?
01:27:37 <wolgo> I do not want to put the entire file in a list line by line
01:27:50 <wolgo> wait
01:27:59 <wolgo> I could seek a random number of bytes
01:28:07 <wolgo> and make that range small
01:28:08 <wolgo> nm
01:28:17 <[Justice]> do you know how long the file is, in lines?
01:28:21 <wolgo> 98569
01:28:29 <vixey> jumping to a random byte seems wise
01:29:11 <vixey> you don't have even probability of each line though
01:29:22 <wolgo> right
01:29:31 <[Justice]> yeah, getting an even distribution is tricky
01:29:33 <cjs> Generally, you seek to a random point, then read forward looking for a line delimiter.
01:29:41 <wolgo> the last bytw would be a \n though right?
01:29:46 <wolgo> byte
01:29:47 <cjs> That's the Q&D way.
01:29:58 <wolgo> ywah
01:30:00 <wolgo> wow
01:30:04 <wolgo> I cannot type tonight
01:30:21 <wolgo> What do you think the totally cool way would be?
01:30:32 <cjs> If you're more serious, you have to read the entire file at least once. But you can build an index which is basically just an array of offsets, and the next time pick a random offset from the index file and then seek to that in the data file.
01:31:26 <wolgo> That is an interesting idea
01:31:36 <[Justice]> two obvious algorithms: calculate what you need on the fly each time you need it, or pre-calculate and store what you can pre-calculate and store
01:32:12 <cjs> That type of simple index is pretty much exactly what namazu (the full-text search engine) uses all over the place for its data files that have variable-length data in them.
01:32:23 <wolgo> Oh ok
01:32:42 <wolgo> I think that might prove to be a little more difficult for me but I think that would prove to be a good exercise
01:32:55 <wolgo> I think I will try the set of offsets
01:33:02 <wolgo> That sounds more interesting
01:33:06 <cjs> Sure. It's not actually a very difficult programming job.
01:33:21 <wolgo> Well, maybe for someone with some experience.
01:33:29 <cjs> I guess I have a bit. :-)
01:33:35 <[Justice]> to have an even distribution with on-the-fly, get a random from 0 to (1 - len), count that number of '\n's, and there's your line
01:33:40 <wolgo> The limit of my experience is with <100 line python scripts
01:34:27 <cjs> Hm? That doesn't work; you have to count all of the '\n's in the file. Or is that what you meant?
01:34:31 <wolgo> err, python scripts < 100 lines
01:34:51 <cjs> Well, I did some code to read and generate just these files in Ruby, and it was a few dozen lines.
01:34:52 <wolgo> The offset position would be the \n no?
01:35:07 <cjs> No, the offset is the byte after the \n.
01:35:11 <wolgo> err, \n + 1
01:35:15 <cjs> Because the first offset is 0, of course.
01:35:24 <[Justice]> [04:27] <[Justice]> do you know how long the file is, in lines?
01:35:24 <[Justice]> [04:27] <wolgo> 98569
01:35:45 <wolgo> It is /usr/share/dict/words
01:36:07 <cjs> Actually, you could probably do some pretty clever and speedy stuff by reading from a lazy ByteString and counting the sizes of takeUntils.
01:36:20 <wolgo> oooo
01:36:32 <wolgo> 1:36 am is too late for hoogle
01:36:37 <wolgo> I will write that down though
01:36:49 <wolgo> Thanks for the ideas
01:36:56 <cjs> Huh? It's 17:36! :-)
01:37:01 * wolgo is creating the best hangman game EVER!
01:37:05 <wolgo> haha
01:37:19 <vixey> no no you're both wrong, it's 09:37
01:37:52 <cjs> Ok, ok, it's 1211877465.
01:38:16 <solrize_> if it's /usr/dict/words just read it into an intmap.
01:38:44 <solrize_> if it's a big file there is a cute trick for picking a line randomly without having to read the file twice to count the liines
01:38:57 <vixey> what's that?
01:39:08 <wolgo> Well, this is an exercise for me hahah.
01:39:26 <cjs> Hm? Twice? You just read once and fseek.
01:39:30 <wolgo> I am trying to learn and understand what I am doing. But I am all ears on that trick for future use.
01:40:24 <solrize_> cjs the lines may not be all the same length.  so if you fseek to a random location you're more likely to pick a line that happens to be longer.
01:40:42 <cjs> solrize, right. But you read the full file, then fseek. It's still only one file read plus a wee bit.
01:40:52 <cjs> (On the first read you build the index of line starts.)
01:41:06 <solrize_> now you're using O(n) memory, you may as well read the whole file
01:44:23 <solrize_> anyway the trick is (in imperative terms): for i = 1,2,3,....: read a line, and with probability 1/i set x to that line.
01:44:25 <Feuerbach> where can I find out fixities of standard Prelude operators, like (+)?
01:44:33 <solrize_> :t (+)
01:44:35 <lambdabot> forall a. (Num a) => a -> a -> a
01:44:42 <vixey> :i (+)
01:45:31 <cjs> Ah, that trick!
01:45:35 <solrize_> repeat until input is exhausted.  then x is one of the lines, selected with equal probability
01:45:41 <solrize_> cjs yeah
01:46:41 <vixey> solrize: ah very nice, I think that works for averaging the lengths too
01:47:44 <cjs> > EQ `mappend` GT `mappend` LT
01:47:47 <lambdabot>  GT
01:47:57 <Feuerbach> found it: http://www.haskell.org/onlinereport/standard-prelude.html
01:47:58 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
01:49:55 <qebab> :t mappend
01:49:57 <lambdabot> forall a. (Monoid a) => a -> a -> a
01:51:24 <vixey> :t (++)
01:51:26 <lambdabot> forall m. (Monoid m) => m -> m -> m
01:54:59 <^Someone^> A question that suddenly occured to me while reading something...
01:55:41 <^Someone^> define function f1(x) = f1(x+1)
01:56:42 <^Someone^> define function f2(x) = (x<=1? 1 : x*f2(x-1))
01:57:19 <^Someone^> When we look at f1, we know it's infitively recursive
01:57:30 <^Someone^> And we can also see that f2 is not
01:58:36 <vixey> f' x = f' (x+1) ; f1'' x = if x <= 1 then 1 else x * f'' (x - 1)
01:58:40 <^Someone^> Is it possible to write an algorithm using which a computer could determine this?
01:58:52 <solrize_> that's called the halting problem, someone :)
01:58:59 <vixey> certainly
01:59:03 <vixey> f1 and f2 are trivial
01:59:18 <vixey> but when things get harder, it's not something you can automate
01:59:25 <^Someone^> Ah
02:00:13 <cjs> But when you've finished that, do you mind writing me something that can compare two arbitrary functions for equality?
02:00:56 <^Someone^> Is that also possible?
02:01:05 <vixey> > let f1 = goldbachConjecture ; f2 = const True in f1 == f2
02:01:06 <lambdabot>   Not in scope: `goldbachConjecture'
02:01:48 <^Someone^> Hmmm
02:02:04 <^Someone^> How can a computer know that f1 is infinitely recursive?
02:02:36 <vixey> ^Someone^: Can you give a more precise definition of infinitely recursive?
02:02:57 <solrize_> ^someone^ you mean whether the recursion will ever terminate?  That's the halting problem, and the answer is that there is no algorithm for it, the problem is undecidable
02:03:06 <^Someone^> Oh
02:03:10 <^Someone^> That is what I meant
02:03:19 <^Someone^> So there is no algorithm, okay
02:03:31 <vixey> You could certainly write a program that takes "f1(x) = f1(x+1)" and outputs "that function is infinitely recursive"
02:03:48 <^Someone^> How??
02:04:06 <solrize_> right, you can encode any of those functions as a number N  for example by concatenating the decimal values together
02:04:08 <vixey> Just like you can write a program that analyzes a C program and most of the time tells you whether or not it has any memory trashing
02:04:32 <solrize_> and you can write a haskell interpreter function interp(n) which computes the value of function #n
02:04:43 <solrize_> let's see, what's the next step of this
02:04:48 <vixey> ^Someone^: What class of functions are you taking as input and what is your definition of infinitely recursive?
02:05:08 <^Someone^> By infinitely recursive, I meant non-terminating, yes
02:05:22 <solrize_> so now let's say you've got a function h(n) which is true if function n terminates and false otherwise
02:05:33 <^Someone^> And mm what class of functions??
02:05:52 <^Someone^> Okay solrize_
02:06:02 * solrize_ still thinking
02:06:07 <vixey> I mean any f : N -> N which is composed of +,-,*,/  ?: and what else?
02:06:13 <vixey> what is your language
02:07:02 <vixey> anyway since you have general recursion it's probably universal which means your' totality checking will print Yes No or Maybe
02:07:02 <^Someone^> Any given language
02:07:06 <^Someone^> Say Haskell
02:07:12 <vixey> ?where catch
02:07:13 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
02:08:33 <^Someone^> Like, say, I want to write a Haskell interpreter which would stop executing and throw an error as soon as I try calling a non-terminating recursive function
02:08:45 <^Someone^> Instead of crashing
02:09:07 <vixey> ^Someone^: Instead of Haskell you could choose a language which you know every program that typechecks will termiate
02:09:27 <solrize_> ok, anyway, let's say g(n)=if h(n) then loop forever else False
02:09:29 <[Justice]> such a language is not Turing complete
02:09:53 <[Justice]> and Turing complete languages would not be reducible to such a language
02:10:09 <vixey> [Justice]: THat's ok though, we don't need to be Turing complete to compile one Turing complete language into another
02:10:21 <pastorn> doesn't this end in the halting problem?
02:10:35 <[Justice]> of course, the question posed is exactly the halting problem
02:10:43 <Adamant> vixey: is that established?
02:10:52 <solrize_> http://en.wikipedia.org/wiki/Halting_problem
02:11:01 <Adamant> what automata do you need to compile from one Turing-comp language to another?
02:11:25 <vixey> Adamant: compcert and lambda tamer are two examples I know of, I would be interested to hear about any more
02:11:33 * ^Someone^ takes a look at the halting problem
02:12:29 <[Justice]> the ghc compilers from Haskell to Haskell Core, from Haskell Core to C, etc
02:12:39 <vixey> Adamant: all you really want is to be able to denote the semantics of both languages and provide a constructive proof that there's an injective mapping from A to B
02:12:53 <pastorn> ^Someone^: this is a different, but cool way to look at it: http://www.bemuzed.com/lucasd/halting-poem.html
02:12:54 <lambdabot> Title: lucas dixon : Scooping the Loop Snooper
02:13:04 <vixey> (or did I mean surjective :s)
02:13:28 <Adamant> cool vixey, I didn't know about those
02:13:59 <vixey> Adamant: I say "all you need to do" but it's actually really really hard :P
02:14:21 <Adamant> haha. well if Xavier Leroy is working on it, I'm pretty sure it's Not Easy
02:14:27 * vixey nods
02:15:19 <solrize_> heh that poem is great
02:15:27 <^Someone^> Wow pastorn
02:15:37 <^Someone^> I like that :)
02:19:04 <pastorn> ^Someone^: a while back (being new to this) i was thinking about the length function
02:19:23 <pastorn> and about how Inf is something that exists in haskell (in some weird way)
02:19:44 <pastorn> so i was thinking that length [0..] should return inf
02:19:54 <^Someone^> Oh yes
02:20:13 <pastorn> but that will result in the halting problem as well
02:20:29 <vixey> pastorn sure
02:20:35 <EvilTerran> > length [0 :: Word8 ..]
02:20:37 <lambdabot>  256
02:20:40 <EvilTerran> ERROR
02:20:59 <vixey> > let l = if goldbachConjecture then [1..] else [42] in length l
02:20:59 <lambdabot>   Not in scope: `goldbachConjecture'
02:21:25 <pastorn> UNLESS you maybe bind length to the list comprehension thingamojig, but then you would probably just push the problem to somewhere else in the language
02:21:43 <pastorn> and probably break it
02:22:22 <EvilTerran> if the enumFrom*s were represented concretely instead of abstractly, it'd be possible
02:22:29 <pastorn> resulting in http://arcanux.org/lambdacats/brain.jpg
02:23:01 <^Someone^> Hehe
02:23:18 * pastorn geos and hides in his 6502 ASM corner of the world again
02:23:21 <pejo> EvilTerran, but length doesn't take enumFrom*, it takes an arbitrary expression - so you would have different behaviour for some non-terminating programs and some other behaviour for others.
02:23:26 <EvilTerran> indeed
02:23:36 <EvilTerran> if the typesystem differentiated between data and codata, OTOH...
02:23:42 * EvilTerran pokes Agda
02:23:52 <pastorn> EvilTerran: see image link above
02:24:05 <vixey> how do you do codata in Agda?
02:24:12 <vixey> I've never seen that
02:24:28 <pejo> Yes, plenty of academics advocating dependently typed languages.
02:26:56 <EvilTerran> vixey, dunno the specifics, but i'm sure you can
02:27:10 <vixey> codata is confusing and evil :((((
02:29:27 <EvilTerran> and AWESOME
02:29:46 <vixey> lol
02:30:55 <joey`> Would it always be safe to replace an occurance of map with liftM?
02:44:01 <eek> the halting theorem only holds for infinite size programs (a finite state space is possible to iterate and see if it loops) and the definition is as far as I can tell based on a recursive definition that seems unsound.  determining if a program halts is only possible with program + input; I can easily do the equivalent of "read a; if a == 0 then loop forever else halt".  the self-recursive definition of program in this case seems to make the program infinite
02:44:01 <eek> in itself, and the infinity is what leads to the problem.  is there any formulation of the proof that actually takes this issue into account?
02:45:02 * eek has been sceptical of this for years, and figured that this is a place with enough people knowing theory that somebody might point out where/how/if he goes wrong in his thinking here
02:45:47 <vixey> eek: goldbach conjecture is a good example, "every natural > 2 is the sum of two primes", suppose it's false and we write a program that prints out the first number which is not expressible as two primes
02:46:07 <vixey> eek: It'll take say 300 years to compute but it'll only use finite space and time
02:46:10 <profmakx> what do you mean by "infinite program"
02:46:21 <profmakx> a program is by definition finite
02:46:32 <vixey> eek: only if the conjecture was false would it take unbounded space and time
02:46:43 <ivanm> profmakx: is it?
02:46:44 <vixey> eek: the problem is you don't know whether or not a program is finite
02:46:51 <ivanm> how bout a program that computes an inifinite loop?
02:47:00 <profmakx> then the program is finite
02:47:02 <vixey> (program size is always finite, space and time may be unbounded)
02:47:04 <profmakx> the state space is infinite
02:47:06 <ivanm> e.g. main = print infinite where infinite = infinite + 1
02:47:07 <eek> profmakx, but the moment you self-recurse the definition by including the program itself in the input, it would end up being infinite in size
02:47:09 <profmakx> oh
02:47:11 <profmakx> not even that
02:47:15 <vixey> I think "infinite" is a bad word
02:47:20 <ivanm> ahhh, OK
02:47:26 <vixey> It's really not infinite, it's just that it'll always need more
02:47:28 <profmakx> I think one should say what you mean by "program" anyways
02:47:49 <vixey> eek: did that answer your question or did I misunderstand you?
02:48:06 <ivanm> profmakx: first of all, there's no such word as "program"... "programme" however... :p
02:48:33 <eek> vixey, uhm, I don't see how that's a proof that we can't prove if a program terminates - it only shows that proving that a program terminates is equivalent to proving the goldbach conjecture...  - ah, but that means we hit Goedel, I guess
02:48:34 <profmakx> eek used the word first
02:48:36 <ziman> eek, there are finite programs that print out their own source code
02:48:42 <eek> ziman, sure
02:48:46 <^Someone^> (((Goldbach conjencture example)))
02:49:14 <vixey> eek: oh I wasn't trying to prove anything, just trying to elucidate
02:49:26 <profmakx> one could always say that a program is (insert Turing machine definition here)
02:49:27 <vixey> eek: exactly what did you want to prove/disprove?
02:49:50 <profmakx> and then you should always note the difference between a program/algorithm/whatever and the computation
02:49:53 <profmakx> i guess
02:50:46 <eek> vixey, I was saying that as I read it I find the standard proof of the halting theorem to be unsound - because including the program "as its own input" seems unsound to me, given that programs *obviously* behave different with different inputs, so the input has to be considered part of the program for determining halting - otherwise you can only say "will halt sometimes, won't halt sometimes".
02:51:15 <vixey> I see
02:51:41 <eek> argh - real world intrusion at a bad time - I'll be back in 5 mins
02:53:55 <profmakx> i just think eek didn't quite get it
02:54:38 <vixey> no it's a good point
02:54:49 <vixey> programs taking input and "closed" programs
02:55:08 <mbz> closed?
02:55:17 <vixey> (I'm defining closed as not taking input)
02:55:18 <mbz> programs w/o input?
02:55:33 <mbz> hm
02:55:36 <vixey> somewhat like a term with no free variables
02:55:46 <vixey> although more like the exact opposite :S
02:55:50 <mbz> okay, every 'open' program requires some kind of input
02:55:52 <^Someone^> Hehe
02:55:59 <mbz> for example, odd natural number
02:56:08 <mbz> in this case we can say it will halt
02:56:14 <profmakx> um
02:56:21 <profmakx> i don't think so
02:56:53 <mmorrow> epicly trying to extract ghc's parser from it's clutches...ahhhhhhhhsdfg
02:57:08 <yitz> vixey: you don't need input to prove the halting thm. it's just an easy way to remember how to construct the contradiction.
02:57:16 <vixey> mmorrow rather than use parseModule?
02:57:25 <vixey> mmorrow: it just goes String -> AST
02:57:38 <mmorrow> i want to be able to parse haskell with *all* extensions
02:58:02 <mmorrow> in paritcular th syntax and quasiquotes
02:58:09 <ivanm> mmorrow: have you tried haskell-src-exts?
02:58:16 <Dzlk> Think of the set of all program-input pairs for a program as the space of possible behaviors of the program(?)
02:58:36 <mmorrow> yeah, been hacking on it for about a week now
02:58:57 <vixey> http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH.html
02:58:57 <lambdabot> http://tinyurl.com/62bwzj
02:58:57 <ivanm> what are you trying to do with it?
02:59:01 <vixey> what about this?
02:59:15 <vixey> oh it doesn't have a parser
02:59:21 * ivanm is going to be needing to parse haskell src for a project later this year
02:59:32 <^Someone^> Hmmmm
02:59:34 <^Someone^> http://tinyurl.com/62bwzj
02:59:56 <^Someone^>  http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH.html
02:59:57 <lambdabot> http://tinyurl.com/62bwzj
03:00:02 <mmorrow> wanna be able to deal with template-haskell syntax + quasiquote syntax in a haskell quasiquoter (-XQuasiQuotes) i'm working on
03:00:44 <^Someone^> Where exactly did that tinyurl come from...?
03:00:46 <mmorrow> hope to eventually release it on hackage
03:01:06 <ivanm> ^Someone^: lambdabot has a tinyurl plugin
03:01:15 <^Someone^> Oh, okay
03:01:18 <^Someone^> Ty
03:02:01 <^Someone^> I thought lambdabot only returned the title of a page, but the tinyurl wasn't anywhere in the page source
03:03:14 <ivanm> ^Someone^: if the url is long enough, she also creates a tinyurl
03:03:29 <^Someone^> Ah
03:04:44 <mbz> ivanm, also? i'd say instead of giving title she gives only tinyurl
03:05:20 <hpaste>  max cantor pasted "hgnuplot" at http://hpaste.org/7911
03:05:30 <^Someone^> http://www.bemuzed.com/lucasd/halting-poem.html
03:05:30 <lambdabot> Title: lucas dixon : Scooping the Loop Snooper
03:05:32 <ivanm> mbz: maybe... :p
03:05:34 <^Someone^> See, title :)
03:05:43 <mxc> oh, uh no one look at that
03:05:51 <mxc> its pretty ugly :)
03:05:58 <ivanm> too late! :p
03:06:38 <^Someone^> Excuse me while I experiment with this
03:06:39 <^Someone^> http://www.example.com/podcasts/everything/index.html
03:06:48 <^Someone^> Not long enough?
03:06:56 <ivanm> ^Someone^: if you want to experiment, /msg lambdabot instead
03:07:06 <^Someone^> Will it do the same?
03:07:18 <ivanm> yes
03:07:26 <^Someone^> Ty :)
03:08:25 <^Someone^> She hates me :\
03:08:29 <mbz> ivanm, she ignores my urls =)
03:08:34 <^Someone^> Mine too
03:08:47 <^Someone^> At least in /msg :D
03:08:57 <mbz> she is naughty
03:09:09 <^Someone^> Oh? How naughty? ;)
03:09:09 <vixey> /j #haskell-jp
03:09:36 <ivanm> *shrug* ask dons or Cale ...
03:09:43 <ivanm> vixey: were we meant to see that?
03:10:21 <mxc> ivanm - viewing that code impliest agreeing to clean it up and write a real gnuplot interface :()
03:10:22 <mxc> :)
03:10:27 <mxc> implies
03:10:28 <mxc> ugh
03:11:51 <ivanm> I didn't actually read it ;-)
03:11:56 <ivanm> just opened the link
03:12:24 <mxc> damn
03:12:49 <eek> yitz, do you easily know any place where the theorem is proved without recursing on the program code?
03:14:13 <vixey> I shoudl probably learn Oleg
03:14:24 <vixey> or Lego
03:14:33 <yitz> eek: no, self-reference is the key.
03:15:17 <eek> yitz, OK, then the problem with the proof is still present, though I'd guess Goedel's Incompleteness Theorem would lead to the same conclusion
03:15:28 <eek> problem with the proof as far as I can understand, at least
03:16:02 <yitz> eek: i don't get what's bothering you
03:18:34 <eek> yitz, it's only possible to prove halting/non-halting for a particular set of inputs, and as far as I can tell the "self-reference" makes this set of inputs infinite & ill-defined.
03:19:14 <vixey> nothing ill-defined about it
03:19:29 <vixey> if I define data N = Z | S N
03:19:32 <yitz> vixey, eek: not ill-defined, but itself not computable
03:19:40 <vixey> has f :: N -> _ an ill defined input?
03:21:43 <yitz> eek: you can write a program that decides halt/non-halt on a large class of inputs. but the thm says that for some inputs you'll fail. what the bad set is depends on your particular implementation of course - and determining that set in general is also not computable.
03:25:05 <hpaste>  morrow pasted "progressing..." at http://hpaste.org/7912
03:25:48 <hpaste>  morrow annotated "progressing..." with "(no title)" at http://hpaste.org/7912#a2
03:27:20 <mxc> @hoogle array
03:27:21 <lambdabot> Data.Array.IArray.array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
03:27:21 <lambdabot> Foreign.Marshal.Array :: module
03:27:21 <lambdabot> Data.Array :: module
03:29:32 <hpaste>  morrow annotated "progressing..." with "note" at http://hpaste.org/7912#a4
03:30:33 <mmorrow> ivanm, vixey: i pasted some progress: http://hpaste.org/7912
03:31:13 <vixey> looks like hard work :)
03:35:31 <dcoutts> @seen Saizan
03:35:31 <lambdabot> I saw Saizan leaving #haskell-blah, #haskell-overflow, #haskell.it and #haskell 3h 38m 54s ago, and .
03:35:50 <^Someone^> How do I use the lambda calculus interpreter again?
03:36:02 <mmorrow> vixey: mostly frustrating!
03:36:04 <^Someone^> Of lambdabot
03:37:06 <qebab> @help lambda calculus
03:37:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:37:11 <qebab> aww
03:37:28 <^Someone^> Nope, it's not listed in the commands :\
03:37:40 <smg> @book
03:37:41 <lambdabot> Unknown command, try @list
03:37:44 <smg> @list
03:37:44 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
03:38:19 <smg> @wiki book
03:38:19 <lambdabot> http://www.haskell.org/haskellwiki/book
03:38:33 <^Someone^> Ah
03:38:44 <ziman> @unlambda \x y -> x + y
03:38:45 <lambdabot>  fd:33: hClose: resource vanished (Broken pipe)
03:38:56 <Deewiant> @pl \x y -> x + y
03:38:56 <lambdabot> (+)
03:39:09 <ziman> was that the Unlambda language intepreter?
03:40:04 <ziman> @unlambda `r```````````.H.e.l.l.o. .w.o.r.l.di
03:40:05 <lambdabot>  fd:33: hClose: resource vanished (Broken pipe)
03:45:48 <oldsalt> @seen shag
03:45:49 <lambdabot> I saw shag leaving #gentoo-haskell and #haskell 12h 57m 27s ago, and .
03:46:43 <mbz> @seen me
03:46:43 <lambdabot> I haven't seen me.
03:47:21 <^Someone^> lambdabot: http://haskell.org/sitewiki/images/1/13/Lambdabot.png
03:48:04 <sioraiocht_> does smallcheck have a main website?
03:48:07 <sioraiocht_> @where smallchecdk
03:48:07 <lambdabot> I know nothing about smallchecdk.
03:48:09 <sioraiocht_> @where smallcheck
03:48:09 <lambdabot> http://www.cs.york.ac.uk/fp/smallcheck0.2.tar
03:51:56 <mxc> @hoogle seq
03:51:57 <lambdabot> Prelude.seq :: a -> b -> b
03:51:57 <lambdabot> Data.Sequence.Seq :: data Seq a
03:51:57 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
03:52:34 <mbz> @seen leopard
03:52:34 <lambdabot> I saw leopard leaving #haskell 2d 42m ago, and .
03:52:40 <mbz> and what?
03:54:21 <mmorrow> and . repeat $ True  --??
03:54:38 <smg> ziman: haha
03:54:39 <eek> yitz, the problem I see with it is that it is infinite through self-recursion in the definition.  the input in question is illusory.   it does not exist, cannot exist.   there may well be other ways of formulating proofs, but the self-recursive variant seems to me "obviously" wrong because you can't define the self-recursion properly (at a encode-as-these-executable-bytes-and-these-input-bytes level).  the input bytes are infinite and undefined (because this
03:54:39 <eek> is self-referential)
03:56:18 <yitz> eek: no, that's the whole point of the proof. goedel numbering says that it is not infinite, a program can refer to itself, in any sufficiently powerful language. and that in turn is the very reason that you can't decide halting.
03:56:28 <^Someone^> eek, I'm trying to investigate and idea similar to vixey's Goldbach conjuncture idea here...
03:56:38 <yitz> (or rather an abstraction of itself)
03:56:47 <^Someone^> We want to know whether the halting problem is undecidable or not
03:56:58 <^Someone^> Suppose there is /some/ undecidable problem P
03:58:12 <eek> yitz, seems like I have to investigate Goedel numbering, then.  thanks!
03:58:21 <yitz> eek: a concrete way to see it is to write a program that prints a copy of its own source code. that uses the same technique.
03:58:43 <eek> yitz, I have written such programs - I still don't see that those are relevant
03:59:18 <mxc> with haskell case statements, is it possible to let one action match several cases?  for example in ocaml:
03:59:27 <mxc> match myVal with
03:59:29 <^Someone^> And suppose I write a program Q: while(output(P)==false) {print("F")}
03:59:38 <mxc> | 1 -> blah
03:59:45 <mxc> |2 | 3 | 4 -> boo
03:59:47 <yitz> eek: it shows you that a program that references its own source code is not necessarily "infinite" or "invalid".
03:59:50 <mxc> | _ -> bac
04:00:17 <^Someone^> What happens when we feed Q to h? (if h is our program to decide whether a program halts or not)
04:00:57 <mmorrow> mxc: case myVal of  1 -> ...; v | v `elem` [2..4] -> ...; _ -> ...;
04:01:08 <mxc> mmorrow> thank you
04:01:11 <eek> yitz, no, but that doesn't mean that it is possible to point back at "itself" in the case for the halting theorem, as far as I can tell.  then again, I tend to start feeling fuzzy fast when I try to wrap my mind properly around this...
04:01:53 <yitz> eek: it's not pointing back at itself. it's pointing at it's own source code, and interpreting it.
04:01:54 <mmorrow> ;)
04:02:02 <mxc> mmorrow> ah, so not really you still have to type out the ... part for each match
04:02:15 <^Someone^> If there is /some/ undecidable problem, then the halting problem is also undecidable
04:02:21 <yitz> s/it's own/its own/
04:02:32 <mmorrow> mxc: huh?
04:02:59 <mxc> mmorrow> so you can't do something like match myVal with Foo | Bar | Boo -> function1 | _ -> function2
04:03:15 <mxc> (using the '|' in the ocaml sense, not haskell sense)
04:03:52 <byorgey> mxc: no, you can't really do that
04:03:56 <eek> yitz, I still feel there's a problem in this, I think - but I'll let it rest for a little while and see if I wrap my head around it more concretely in either direction
04:04:01 <yitz> ^Someone^: if (any proposition) then the halting problem is undecidable
04:04:11 <byorgey> mxc: but as mmorrow pointed out, you can do essentially the same thing in some special cases.
04:04:21 <mmorrow> mxc: ah. i guess you could wrap the multiple matches in a function => isFooBarOrBoo
04:04:32 <byorgey> but you can't have multiple arbitrary pattern-matches.
04:04:38 <mmorrow> yeah
04:04:39 <byorgey> (which variables would get bound?)
04:05:03 <eek> ^Someone^, I agree that having some undecidable proposition should lead to the halting problem, after vixey's suggestion above
04:05:31 <mxc> in the ocaml world you can, but any variables that you use need to be bound in each of the patterns
04:05:51 <byorgey> I see, interesting
04:05:53 <mxc> so something like match a with | Foo x | Bar -> x+2 would fail
04:05:59 <mxc> but you could do:
04:06:09 <mxc> match a with Foo x | Bar x -> x + 2
04:06:38 <mxc> assuming you had some type which was type Fubar = Foo Int | Bar Int
04:06:43 <byorgey> right
04:06:46 <mxc> (syntax is wrong, i forget the exact syntax)
04:06:55 <mmorrow> that is interesting. you could simulate that with isFooBarOrBoo by having that function return that shared value
04:06:59 <byorgey> yeah, you can't do that in Haskell, unfortunately =)
04:07:19 <mxc> you could simulate it all with C, but there is a reason we're not in the #C channel
04:07:36 <mmorrow> well...
04:07:39 <mxc> :)
04:07:43 <mmorrow> heh
04:08:00 <vixey> you can do it in ocaml
04:08:14 <vixey> oooo
04:08:20 <vixey> I think you could use a view to do this :D
04:08:28 <mxc> i'm not trying to dump on haskell, i'm starting to like haskell more
04:08:32 <vixey> let's say you have data Fubar Foo Int | Bar Int | Baz Quux
04:08:41 <vixey> data Fubar = Foo Int | Bar Int | Baz Quux*
04:08:53 <mxc> whats the meaning of '*'?
04:08:59 <vixey> correction
04:09:05 <vixey> then we defin data Fubar' = Foo/Bar' Int | Bar' Quux
04:09:13 <vixey> view (Foo x) = Foo/Bar' x
04:09:16 <vixey> view (Bar x) = Foo/Bar' x
04:09:26 <vixey> view (Baz q) = Baz' q
04:09:28 <vixey> then
04:09:45 <vixey> case view fubar of Foo/Bar' x -> x + 2 | Baz' q -> ...
04:09:55 <vixey> (but you can't use / in a constructor name sadlY)
04:10:34 <mxc> interesting
04:10:38 <mxc> never heard of view's
04:10:41 <mxc> will have to look it up
04:10:45 <vixey> mxc: I just read about it today
04:11:12 <mmorrow> mxc: you could use a GADT that has Foo, Bar, Baz, and possibly other constructors. Then have a class HasParticularInt where theInt :: a -> Int,  make Foo Int, Bar Int, Baz Int instances of that class, then just call theInt on them
04:11:38 <mxc> ah
04:11:38 <mxc> yeah
04:11:44 <mxc> GADTs are on my reading list too
04:11:56 <mxc> ok, next question, in the field update syntax of records, if you have something like: newRec = oldRec {fldToUpdate=x}, is there a way to programmatically pass in the field to update?
04:12:52 <mxc> like if you have something like data Rec = Rec {x :: Int, y :: Int} and you want a function updateXOrY xOrY newVal
04:13:08 <mxc> without doing a case statement foreach field?
04:13:09 <danish> hey guys need some help regarding hugs in linux
04:13:24 * mxc gives danish a hug
04:13:26 <mmorrow> have a function update :: (RecType -> RecType) -> RecType -> RecType
04:13:46 <mmorrow> then pass it the function that modifed Rec how you want
04:14:04 <mxc> yeah, was wondering if there is a slicker way
04:14:05 <yitz> mxc: no. record syntax is limited.
04:14:06 <mmorrow> depending on the context though, that may be redundamt
04:14:07 <mxc> oh well, thanks
04:14:13 <mmorrow> yeah
04:14:34 <vixey> hehe
04:14:58 <yitz> there have been many proposals to improve it. none have yet been agreed upon or implemented. this has been an issue since the early days of Haskell.
04:15:35 <danish> im am using ubuntu and i am new to linux, i want to use hugs interpreter and i have this ide named "Heat" which requires an interpreter but unfortunately i dont know what interpreter file to look for. any help would be appreciated
04:16:10 <danish> f
04:16:41 <pejo> danish, the executable is usually just called 'hugs'.
04:17:06 * DuClare *hugs* somebody.
04:17:26 <^Someone^> Somebody as distinct from ^Someone^, right/
04:17:26 <Botje> "It's a disaster trying to use Word to edit programs. You have to use a program editor"
04:17:32 <danish> yes but that is under windows and under ubuntu i cant find it.. its a .sh file isnt it
04:17:32 <Botje> people do that? O_o
04:17:39 <BeelsebobWork> danish: indeed -- you need to install either hugs or ghci, and then point Heat at the executable for the command line version of your interpretter
04:17:48 <Botje> danish: type "which hugs" into a shell
04:18:07 <danish> okay
04:18:09 <Bonus> hmm, i need to do an 8 bit xor between two numbers
04:18:15 <Bonus> is there such a function defined?
04:18:23 <danish> done it and it shows me the path for hugs folder
04:18:25 <DuClare> ^Someone^, Well, I'm sure you'd make a good hug.
04:18:27 <yitz> Bonus: Data.Binary and Data.Word
04:18:30 <Bonus> ah
04:18:31 <Bonus> kewl
04:18:32 <Bonus> thanks
04:19:03 <Botje> danish: input that path
04:19:21 <danish> into the HEAT thing?
04:19:30 <Bonus> hmm wait i can't seem to find data.binary
04:20:50 <pejo> Bonus, available on hackage.
04:20:57 <Bonus> aha, cool
04:21:05 <danish> yep done it thank you soo much it seems to work :D
04:23:30 <^Someone^> DuClare, only if you're one of the female gender ;)
04:23:34 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/7913
04:24:29 <danish> thanks alot Botje :)
04:25:34 <smg> hello.
04:26:24 <smg> if i have functions, when do i say that they are mutual recursive? do they need to be both direct recursive? or may they also be indirect mutual recursive?
04:27:02 <ski_> the latter
04:27:39 <malebria> What library can I use to play a .wav file?
04:28:05 <malebria> I'm looking at WAVE, but it seems that it only treat data, but don't play the files.
04:28:26 <smg> ski_: was this for me?
04:31:08 <mbz> smg, I guess it was for you
04:31:20 <smg> mbz: thank you
04:32:53 <edwardk> smg: in haskell any function can reference any other function that is in scope. you don't need any kind of explicit 'mutual' declarations. all lets are 'letrecs'
04:33:21 <smg> edwardk: yeah it was just a question for exercises.
04:34:29 <Philippa> smg: if they form a call graph with a cycle of length >1 in it, they're mutually recursive
04:36:23 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/7914
04:36:29 <smg> http://hpaste.org/7914
04:36:32 <smg> look at the paste
04:36:38 <smg> do you think that is true?
04:37:02 <edwardk> smg: this sounds suspiciously like homework ;)
04:37:18 <smg> edwardk: no university.
04:37:20 <vixey> {f1,f3,f4} are mutually recursive
04:37:35 <smg> vincenz: f1,f3,f4?
04:37:42 <Deewiant> smg: high school, then. ;-)
04:37:45 <smg> hehe :P
04:37:55 <smg> so my answer is wrong at the paste?
04:38:03 <edwardk> vixey: no one recurses back to f1
04:38:17 <edwardk> vixey my bad f4 does
04:38:29 <smg> so it's only {f1,f3,f4} ?
04:38:47 <smg> not {f1,f3},{f1,f4} and {f3,f4} ?
04:41:35 <trez> skorpan: did you finnish the cc-lab?
04:43:55 <smg> edwardk: the exercise is stupid!
04:44:03 <smg> edwardk: i need to mention all pairs which are mutual recursive
04:44:08 <smg> so my solution is right, is it? :)
04:47:37 <smg> haha lol
04:51:13 <skorpan> trez: i couldn't get ifac() in core001.quadr to work and i knew why and everything, but i was far too tired to fix it (that was 5 am) so i submitted it. bernardy actually accepted it and i got 30 points :)
04:51:42 <skorpan> trez: how about you?
04:53:30 <malebria> I need to use openAL to play a single wav file?
04:54:33 <BeelsebobWork> what's wrong with that?
04:54:52 <BeelsebobWork> the whole point of OpenAL is to play audio
04:54:52 <malebria> With using openAL?
04:54:56 <malebria> hum..
04:55:29 <malebria> I thought it was designed for 3d audio, and maybe that there was a more simple solution.
04:55:47 <BeelsebobWork> it's designed for audio in general
04:55:55 <BeelsebobWork> in the same way as OpenGL isn't designed for 3D graphics
04:55:59 <BeelsebobWork> but for graphics in general
04:56:08 <malebria> I see.
04:56:25 <trez> skorpan: hehe, nice. also got my lab accepted :)
04:58:15 <dblhelix> niksnut: nee, joh, tfp is voor...
04:58:22 <dblhelix> ... amiddelk :-)
04:59:06 <amiddelk> wrong channel dblhelix :P
04:59:21 <dblhelix> amiddelk: indeed; see the other one :-)
05:04:01 <mm_freak_work> BeelsebobWork: though i'd say that openal is especially designed for 3D audio
05:04:41 <mm_freak_work> there is no simple playback functionality…  you need to place audio sources and the listener in 3-dimensional space
05:14:05 <Philippa> BeelsebobWork: in that you have to do some fairly special things to make OpenGL behave 'sensibly' for a lot of 2D graphics applications?
05:14:16 <BeelsebobWork> eh?
05:14:18 <BeelsebobWork> you do?
05:14:35 <BeelsebobWork> you give it a boring modelview matrix and get on with drawing shit
05:15:04 <malebria> mm_freak_work: is there a library for haskell with simple playback functionality?
05:15:34 <vixey> Well you have to implement line drawing and such if you want predictable results
05:15:47 <BeelsebobWork> vixey: ?
05:16:06 <vixey> I don't know what you're asking when you say "?"
05:16:11 <yitz> malebria: what does hmp3 use?
05:16:23 <BeelsebobWork> why would the results of drawing lines with OpenGL be unpredicable vixey?
05:16:32 <BeelsebobWork> the whole point of OpenGL is that it has a predictable result on all systems
05:16:44 <vixey> no that's absolutely not true
05:16:54 <mm_freak_work> malebria: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Sound
05:16:55 <lambdabot> http://tinyurl.com/yqov7f
05:17:01 <vixey> Probably better information here than I'd be able to explain http://homepage.mac.com/arekkusu/bugs/invariance/
05:17:01 <lambdabot> Title: OpenGL Invariance
05:17:27 <malebria> mm_freak_work: I'm looking there.
05:17:44 <mm_freak_work> BeelsebobWork: opengl doesn't specify exactly how it looks like…  there are just some so-called invariance rules, which guarantee repeatable results on the _same_ drawing context
05:18:02 <malebria> yitz: I thought it call mpg123, but I'll check here.
05:18:11 <mm_freak_work> but doing 2D graphics with opengl is easy, and you can get fairly predictable results
05:28:46 <ndm> now i have a code.haskell.org account, how do i use it?
05:29:02 <ndm> i.e. i want to create and host Hoogle on the darcs there - how?
05:29:11 <ndm> how do i control who else can commit to Hoogle?
05:29:38 <ndm> dcoutts - you may know ^^^
05:30:22 <dcoutts_> ndm: see http://community.haskell.org/admin/ using and administering your project
05:30:22 <lambdabot> Title: Haskell Community Server
05:30:32 <malebria> yitz: it seems to me that it uses mpg321.
05:30:44 <ndm> ah, i hit code.haskell.org - too many top level domains!
05:32:08 <yitz> malebria: hmm. so not much help. so far, it looks like the fast way will be to call some external program, like sox play (linux) or something.
05:34:32 <malebria> yitz: or using openAL. =(
05:34:51 <yitz> your choice :)
05:34:55 <vixey> I've not got OpenAL working with Haskell actually
05:35:03 <vixey> does anyone have a small example ?
05:35:43 <dcoutts_> ndm: does that answer all your questions?
05:36:45 <ndm> dcoutts_, yep!
05:36:55 <dcoutts_> @yarr!
05:36:55 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
05:36:57 <mm_freak_work> malebria: SDL has an easier sound interface than openal
05:37:02 <ndm> I have requested hoogle as a project just now :)
05:37:23 <sioraiocht_> @seen dcoutts
05:37:24 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #haskell-blah. I last heard dcoutts speak 1h 18m 29s ago.
05:37:32 <sioraiocht_> @seen dcoutts_
05:37:32 <lambdabot> dcoutts_ is in #haskell, #gentoo-haskell, #haskell-overflow and #ghc. I last heard dcoutts_ speak 37s ago.
05:37:41 <malebria> mm_freak_work: I couldn't compile SDL-mixer
05:37:42 <dcoutts_> sioraiocht_: yello
05:38:36 <mm_freak_work> malebria: you won't need SDL_mixer for that
05:39:04 <mm_freak_work> hmm
05:39:31 <mm_freak_work> ok, wrong…  seems like the SDL interface of haskell isn't quite complete
05:39:35 <malebria> mm_freak_work: actually I could, I have made a confusion..
05:40:24 <mm_freak_work> yeah, seems like you _do_ need SDL_mixer
05:40:38 <mm_freak_work> but having that, playing audio should be fairly simple
05:41:35 <malebria> What I'm not liking very much is that I'm writing a GTK app, and I'd prefer not to use a lot of libraries.
05:41:46 <malebria> It would be good to have a simples library to play a WAVE file.
05:42:24 <malebria> If I'll use SDL-mixer, then it would be better to use SDL for everything, instead of GTK.
05:42:35 <mm_freak_work> nope
05:42:44 <mm_freak_work> SDL is not a GUI library
05:43:27 <malebria> mm_freak_work: it's a graphical library.
05:43:50 <mm_freak_work> it's a multimedia library, which is _not_ meant for GUI building
05:44:10 <mm_freak_work> you would have to build it yourself, since SDL doesn't know any concept of widgets or such
05:44:25 <atsampson> it depends if your application's doing any GUI stuff, or if you're just using GTK as a canvas -- if the latter, then SDL is entirely appropriate
05:44:53 <mauke> I think I need an algorithm for intersection . map (unionMap substrings)
05:44:59 <mm_freak_work> it's overkill for simple canvas usage
05:45:24 <mm_freak_work> SDL is appropriate, where low-level drawing is needed
05:45:40 <malebria> hum..
05:45:44 <flux> however SDL doesn't even provide things like drawing lines. but then there are libraries to do that with sdl.
05:45:47 <mm_freak_work> if you just want to plot a graph or something, GTK+ will be _much_ more convenient
05:46:12 <malebria> I didn't no SDL was so low-level.
05:46:51 <mm_freak_work> it's called "simple _direct_media layer" for some reason ;)
05:46:53 <flux> I don't know if the libraries for SDL can make any use of hardware acceleration though
05:47:06 <vixey> yes they can
05:47:16 <mm_freak_work> flux: they can, where appropriate (like moving rectangular areas or such)
05:47:24 <flux> but if you're drawing lots of lines, perhaps opengl is the way to go
05:47:57 <malebria> No, it's a simple GUI program.
05:48:04 <malebria> I think it'll be better in GTK.
05:49:12 <vixey> does anyone know some intro texts for Lego/Oleg online?
05:50:47 <mattam> flux: I think Conor mentions Oleg is not documented in his thesis.
05:51:23 <vixey> mattam: aww ok :)
05:52:18 <mattam> But Lego should be I guess.
05:54:27 <kaol> is there a shuffle function ready in some library?
05:55:54 <kaol> I know that there's a number of ready implementations in the wiki and I could just cut and paste one
05:59:29 <lilac> kaol: you want a [a] -> [[a]] providing all permutations? or a randomized shuffle?
06:00:05 <kaol> a randomized shuffle
06:01:03 <idnar_> @type intercalate
06:01:05 <lambdabot> forall a. [a] -> [[a]] -> [a]
06:01:16 <Deewiant> > let rs = randoms . mkStdGen $ 42 in sortBy (comparing (rs !!)) [1,2,3,4,5]
06:01:17 <lambdabot>  [2,5,4,3,1]
06:04:41 <lilac> i'm not sure whether an O(n) randomized shuffle is possible on a singly-linked list. if you want O(n), you could convert to array, do Knuth's randomized shuffle algorithm there, and convert back.
06:05:27 <smg> Deewiant: cool
06:05:49 <Deewiant> but not very efficient and only works with integers :-)
06:06:20 <smg> Deewiant: who cares, badass solution
06:06:26 <Deewiant> heh
06:07:11 <kaol> I'm happy with O(n log n). In my case, n is fixed and less than 100.
06:09:43 <malebria> Loading package SDL-mixer-0.5.2 ... linking ... <interactive>: /usr/local/lib/SDL-mixer-0.5.2/ghc-6.8.2/HSSDL-mixer-0.5.2.o: unknown symbol `Mix_LoadWAV'
06:09:43 <malebria> ghc-6.8.2: unable to load package `SDL-mixer-0.5.2'
06:09:46 <Deewiant> > let rs = randoms . mkStdGen $ 123; shuffle as = map snd . sortBy (comparing ((rs !!) . fst)) . zip [0..] $ as in shuffle ["foo", "bar", "baz", "qux"]
06:09:47 <lambdabot>  ["bar","foo","qux","baz"]
06:10:05 <malebria> I'm getting this when trying to run something that imports SDL-mixer
06:10:16 <malebria> I get the same error when trying to compile hbeat.
06:11:10 <tchakkazulu> > map snd . sortBy (comparing fst) $ zip (randoms . mkStdGen $ 435) [1..5]
06:11:11 <Deewiant> kaol: that should work... look at the docs for Random if you need a different shuffle every time you run the program (my example uses a static seed, 123)
06:11:12 <lambdabot>  [4,5,3,1,2]
06:11:28 <Deewiant> tchakkazulu++
06:11:43 <Deewiant> silly me :-)
06:11:45 <tchakkazulu> For avoiding the !!, which can get expensive.
06:12:39 <luite> tchakkazulu: hoi Joeri ;)
06:12:40 <Deewiant> given that his lists were less than 100 elements long, I wasn't worried about that... but that's a cleaner solution anyway
06:12:51 <tchakkazulu> 'lo luite.
06:14:34 <phlpp_> bogosort is fucking slow :_
06:14:42 <mauke> o rly
06:14:42 <Deewiant> don't use it :-P
06:14:44 <phlpp_> :D
06:15:12 <phlpp_> sorting 20 elements since ~16h
06:15:58 <phlpp_> for 16h, for ffs
06:16:10 <Deewiant> > let expectedNumberOfSwaps n = (n-1) * product [1..n] in expectedNumberOfSwaps 20
06:16:11 <lambdabot>  46225138155356160000
06:16:26 <Deewiant> now how many swaps can your computer do in an hour :-P
06:17:08 <augur> good morning haskellians! :D
06:23:43 <phlpp_> o_O
06:24:13 <phlpp_> even if i got around 10^9 swaps/sec it'd take me 1465 years
06:25:00 <Deewiant> and that's not even counting comparisons ;-)
06:25:04 <augur> goodness, man, what are you computing?
06:25:11 <Deewiant> he's bogosorting something of length 20
06:25:26 <augur> oh.
06:25:36 <augur> only 1465 years to bogosort it?
06:25:36 <cjs> Someone's chipper this morning!
06:25:40 <augur> thats fast.
06:26:01 <Deewiant> > let expectedNumberOfSwaps n = (n-1) * product [1..n] in expectedNumberOfSwaps 20 `div` 10^9 `div` 60 `div` 60 `div` 24 `div` 365
06:26:02 <lambdabot>  1465
06:26:14 <Deewiant> like said, assuming 10^9 swaps per second
06:26:23 <Deewiant> and not including comparisons
06:28:05 <Deewiant> > let expectedComparisons n = (exp 1 - 1) * product [1..n] in expectedComparisons 20
06:28:06 <lambdabot>  4.18041131107144e18
06:28:11 <Deewiant> :-)
06:29:33 <phlpp_> O_o
06:29:37 <Deewiant> > let expectedComparisons n = (round (exp 1 - 1) :: Integer) * product [1..n] in expectedComparisons 20
06:29:38 <lambdabot>  4865804016353280000
06:29:46 <Deewiant> have fun
06:33:31 <cjs> You know, maybe the bogosort just has a bad rep due to current hardware being somewhat inappropriate for it. What if you built an FPGA or something that made a swap an O(1) operation?
06:33:48 <mauke> swap is O(1)
06:33:59 <Deewiant> swap and compare are both O(1) :-)
06:34:08 <cjs> Oh, is it? Oh, right, in your calculation....
06:34:11 <Deewiant> or at least they're assumed to be in that
06:34:22 <opqdonut> yeah, uniform memory access
06:34:27 <opqdonut> is assumed
06:34:43 <dolio> What if they were O(0)?!
06:34:43 <augur> what about bogoswap? bogoswap should be like O(2^n) :P
06:35:10 <cjs> dolio, That's it!
06:35:55 <augur> maybe if you were using a quantum computer
06:36:03 <augur> that can perform infinitely many computations at once
06:36:07 <BeelsebobWork> audreyt: bogoswap is O(infinity)
06:36:19 <augur> then on average a swap would be O(0)
06:36:31 <augur> audreyt?
06:37:11 <yitz> BeelsebobWork: bogoswap is O(fiddlesticks)
06:37:21 <BeelsebobWork> hehe
06:37:57 <lilac> bogosort is O(n) in a quantum computer, isn't it?
06:38:59 <BeelsebobWork> I thought bogosort was O(inf) on all computers
06:39:01 <yitz> lilac: wikipedia claims that it could be O(n), but it will eat O(n log n) or quantum randomness. go figure
06:39:12 <yitz> s/or/of/
06:41:47 <lilac> yitz: sounds about right. presumably you construct all n! possible orderings into the same O(n) qbits, then force it to resolve to a sorted solution
06:43:18 <lilac> BeelsebobWork: on classical computers, it is unbounded, yes. but it's amortized O(n!) (or something like that -- i think the 'check' step is essentially free, since it usually fails very fast)
06:45:37 <dolio> I don't think it's amortized.
06:45:53 <Deewiant> http://www.tcs.ifi.lmu.de/~gruberh/data/fun07-final.pdf
06:45:58 <BeelsebobWork> dolio: it can not be bounded without being amortized
06:46:06 <dolio> It's just that at each step, there's a certain probability (1/n! ?) that it's done.
06:46:09 <BeelsebobWork> simply because you can keep chosing the same unsorted list forever
06:46:53 <dolio> So you could work with the expected number of comparisons by that probability.
06:46:59 <^Someone|Away^> > factr 45
06:47:04 <lambdabot>  119622220865480194561963161495657715064383733760000000000
06:47:12 <^Someone|Away^> Ah
06:47:25 <^Someone|Away^> > factr 45
06:47:26 <lambdabot>   Not in scope: `factr'
06:47:28 <^Someone|Away^> :)
06:47:40 * ^Someone|Away^ hugs lambdabot
06:52:01 <dolio> That's more like probabilistic analysis than amortized analysis, though.
06:54:11 <lilac> dolio: yes, that's true. but if you make certain assumptions about your RNG, you can probably make it amortized :)
07:23:31 <BMeph> dcoutts: ping
07:23:42 <dcoutts_> BMeph: pong
07:24:23 <BMeph> Do you have anything to do with the Cabal site on haskell.org?
07:24:30 <dcoutts_> BMeph: yep
07:25:50 <BMeph> Okay, because I just started grabbing and compiling Cabal from the repo, and noticed that we're at 1.5.1, even though the site still has 1.2.3 as the stable release (at least, that's what the big blue letters say).
07:26:01 <BMeph> Is there a 1.4 release?
07:26:44 <dcoutts_> BMeph: not yet, we've branched for 1.4 and we're up to 1.3.10 at the moment
07:27:01 <dcoutts_> BMeph: the head branch has indeed moved onto 1.5.x
07:27:44 <BMeph> That could be...distracting. :)
07:28:11 <Mr_You> I'm a haskell/functional programming newb.  For the most part, I've stayed out of programming since Perl was the most popular (except for php here and there), mostly because of having to deal with other programmers messes. Been trying to find a new language to get into, JavaFX (declarative) might be interesting, but haskell looks appealing so far.
07:28:44 <dcoutts_> BMeph: it does seem confusing at first, but it's a pretty sensible way to manage things if you think about it
07:29:01 <dcoutts_> we cannot branch for 1.4 and call it 1.4 straight off
07:29:08 <dcoutts_> we want to test it etc
07:29:15 <Mr_You> I'm mostly interested in distributed computing and GPGPU programming.
07:29:20 <dcoutts_> but otoh, new stuff still has to go somewhere
07:30:46 <BMeph> dcoutts_: Hmm, well, as long as 1.4 is getting "confirmed" as 1.4, I guess that works. It just looks "odd," if you get my drift. ;)
07:31:18 <dcoutts_> BMeph: there will be a 1.4, fear not
07:31:39 <BMeph> dcoutts_: If I can help with a Windows build example for 1.4, let me know? :)
07:31:50 <dcoutts_> Mr_You: my tip is make sure you grok the basics first, before tackling distributed or gpu programming. It takes a little while to fully understand the functional style.
07:31:59 <dcoutts_> BMeph: oh testing would be very helpful
07:32:11 <Mr_You> dcoutts: thanks, will definitely do that.
07:32:13 <dcoutts_> BMeph: that's what I've been doing recently for unix
07:32:33 <dcoutts_> BMeph: I'll let you know when I've got the tools to do more exhaustive testing
07:32:46 <BMeph> dcoutts_: Cool, I'll check it out then. :)
07:33:01 <Mr_You> is Vim the favored "IDE"?  Wondering if anyone is working on or considered a NetBeans plugin or even building an IDE out of NetBeans or Eclipse.
07:33:12 <dcoutts_> BMeph: my approach is basically to test all of hackage. Frist build everything with Cabal-1.2 and for the ones that work with 1.2, see if they still build with 1.4.
07:33:35 <dcoutts_> BMeph: but given that there are ~600 packages it needs some automation... called cabal-install!
07:34:28 <dcoutts_> Mr_You: vim and emacs have decent haskell modes as do gedit, nedit and kate I think.
07:34:28 <BMeph> dcoutts_: Which calls for testing c-i, to ensure that it'll give good data when you test cabal. :)
07:34:45 <Mr_You> dcoutts: I'm guessing with GPGPU programming Haskell, I would have to (I forget the word) use C to actually get worked done on the GPU.  (just guessing).
07:35:01 <dcoutts_> BMeph: yes, so it does involve cabal-install working and in particular being able to make install plans for very large numbers of packages.
07:35:55 <BMeph> dcoutts_: Sounds like a project-and-a-half... :)
07:35:56 <dcoutts_> BMeph: one issue I've seen with c-i on windows but not tracked down yet is failures when deleting the temp dir in which we built a package, as if there was a program still running that had an open file in there.
07:36:16 <dcoutts_> BMeph: well I got it working for yi today
07:36:35 <dcoutts_> it makes a valid install plan that avoids the dreaded diamond dependency problem
07:36:47 <BMeph> dcoutts_: Yes, I've also noticed that I get an error message, after a successful build/install. Troubling, that. :|
07:36:52 <dcoutts_> BMeph: doing it for the whole of hackage is a bit harder, and is probably impossible
07:37:21 <dcoutts_> BMeph: right, perhaps you can get us a detailed bug report on that including a log with -v3
07:37:44 <mxc_> is it possible to take something off of hpaste.org?
07:37:57 <BMeph> dcoutts_: Sure, I'll check my screen log now.
07:38:01 <dcoutts_> mxc_: not easily
07:38:08 <mxc_> hm
07:38:23 <dcoutts_> mxc_: you'd have to ask one of the people who admin it
07:38:39 <mxc_> glguy?
07:38:48 <mxc_> i'll ask tomorrow
07:43:56 <cjs> Oh, hell.
07:44:05 <mxc_> ?
07:44:20 <cjs> I just spent over an hour debugging a tiny error that would have been caught right away had I added that second unit test that I'd thought about adding.
07:45:00 <cjs> I think I spent more time debugging today than I have anything in the last few months. Ouch.
07:46:30 <ndm> cjs: you should probably know (if you hadn't already figured out) that Bulat isn't the most sensitive soul, and sometimes has a problem with tact...
07:46:30 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
07:46:36 <ndm> @messages
07:46:36 <lambdabot> nominolo said 2h 40s ago: The FAX number is fine; however, you might not get through at all times, and be sure to find the proper translation of the leading +. i sent it from the university and had
07:46:36 <lambdabot> to use 0000.
07:47:29 <cjs> Oh, that's not a big deal. After a couple of decades of usenet, I'm used to that sort of thing.
07:47:44 <ndm> just making sure :)
07:47:45 <cjs> I'm just annoyed because the discussion doesn't seem terribly productive.
07:47:50 <cjs> And I'm contributing to it. :-)
07:48:02 <ndm> indeed, two people with different opinions forged from years of experience
07:48:31 <ndm> FWIW, I think you are wrong :) - or at least wrong in general but not in exceptional circumstances
07:49:20 <cjs> Well, it depends on what you consider the desired end state, I suppose.
07:49:37 <cjs> I'll admit that my circumstances are the exception, but that's just because most people are so bad at software developement.
07:49:56 <saml> software development is not soft at all
07:50:14 <cjs> It is! It's soft and squishy! :-)
07:50:15 <ndm> i tend to have more projects on the go at once, so if something breaks them all, it may be a while before i get round to updating them all
07:50:23 <cjs> How many?
07:50:28 <ndm> at least 25
07:50:43 <cjs> Hm. More than me; we tend to have about 10-15 in production at any particular time.
07:50:47 <cjs> But not that much more than me.
07:51:14 <ndm> i have 25 active and alive, probably ~50 haskell projects that are either on the back burner, or no longer in active use
07:51:15 <cjs> But do you need to update so quickly? Why not just use the old compiler version for the non-updated ones?
07:51:38 <ndm> i don't have enough disk space to install two copies of GHC
07:51:59 <cjs> That's pretty tight for disk space.
07:52:09 <ndm> but even if i did, if i upgrade 6.6 -> 6.8 its easy enough, but 6.4 -> 6.8 is more work, and as time goes by, unless you hit every project every year, you get left behind
07:52:22 <cjs> Sure, but you just keep using the old ones, then.
07:52:26 <ndm> yeah, i need a new machine!
07:52:39 <ndm> yes, but then they get so far behind that they become very hard to update
07:52:53 <cjs> Actually, $100 on a new hard drive will make you much happier.
07:52:55 <ndm> well, technically i no longer own any computers :(?
07:53:02 <ndm> yeah, i don't have a computer to put it in!
07:53:04 <cjs> Sure, but that's life. I've got projects like that, too.
07:53:44 <ndm> i know, i don't mind doing it when something improves drastically, but i'd like people to at least be reluctant to break things
07:54:01 <cjs> Maybe they don't need to be updated, some of them. But unless you've got tons of old projects, and do little new development, the savings of having better libraries for most of your day-to-day work far outweigh the costs of not updating old projects or having to update them.
07:54:05 <ndm> in general, i have a policy that if i upgrade a library, and break your code, and your code is in a public darcs repo, i'll send a patch
07:54:11 <cjs> Oh, reluctant to break things I have no problem with.
07:54:20 <ndm> oh, totally
07:54:34 <ndm> its the balance, i want people who break libraries to suffer some pain
07:54:54 <ndm> not sufficient pain to make them not do it, but enough to make them not do it too often or without a very good reason
07:55:20 <cjs> I don't think they should suffer, so long as what they're doing is The Right Thing. But yeah, doing it, not even for no good reason, but for not-good-enough reasons, is bad.
07:55:31 <edwardk> Does anyone know of a theorem linking f -| g and Cofree f -| Free g or Free f -| Cofree g ?
07:55:35 <cjs> I just don't want to see another Java here.
07:55:46 <ndm> i don't think you will :)
07:56:02 <edwardk> I haven't been able to find anything in literature
07:57:52 <edwardk> bah who needs to support existing users ;) refactor refactor refactor ;)
08:07:46 <dcoutts_> @seen sioraiocht_
08:07:47 <lambdabot> sioraiocht_ is in #haskell-blah and #haskell. I last heard sioraiocht_ speak 2h 30m 14s ago.
08:07:54 <sioraiocht_> oh hai
08:08:06 <dcoutts_> sioraiocht_: you were after me earlier
08:08:15 <sioraiocht_> yeah, can we actually just meet tomorroW?
08:08:19 <dcoutts_> sure
08:08:28 <dcoutts_> I'll be in
08:08:32 <sioraiocht_> w00t, thanks
08:09:30 <edwardk> so no answer on the adjunction question above?
08:09:58 * edwardk sighs and sets off to prove/disprove the connection himself.
08:14:19 <twobitwork> how do you read x bytes from a file?
08:16:48 <dcoutts_> twobitwork: binary files?
08:16:54 <Deewiant> fmap (take x) $ System.IO.hGetContents =<< System.IO.openBinaryFile "file" System.IO.ReadMode
08:18:29 <dcoutts_> twobitwork: are you trying to read bytes from the same open file repeatedly?
08:19:53 <dcoutts_> hGet :: Handle -> Int -> IO ByteString
08:20:36 <b_jonas> hi,
08:23:08 <b_jonas> is there a good comprehensive open test-suite for containers like Map and Seq?
08:23:34 <b_jonas> that is, if I wanted to write an implementation of a data structure with an interface similar to those, how could I test it well?
08:24:24 <dcoutts_> b_jonas: the containers package has some tests
08:24:31 <dcoutts_> there may be more in the ghc testsuite
08:24:52 <b_jonas> dcoutts_: do you mean the containers package that's in the ghc core?
08:25:01 <dcoutts_> yep
08:25:02 <b_jonas> because that has almost no tests
08:25:07 <b_jonas> I just looked at it
08:25:09 <b_jonas> it's minimal
08:25:12 <dcoutts_> aye
08:25:24 <b_jonas> otoh there was some other, larger container library in hackage
08:25:27 <b_jonas> what was that?
08:25:50 <b_jonas> I think that library was related to Okasaki's book
08:26:01 <b_jonas> but maybe not
08:27:50 <b_jonas> aha, this was it I think: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/EdisonCore
08:27:52 <lambdabot> http://tinyurl.com/3bnhme
08:30:10 <b_jonas> that one has no tests either
08:30:13 <b_jonas> hmm
08:30:40 <b_jonas> I'd be interested in tests in a non-haskell language too
08:31:29 <b_jonas> by the way, I just looked up the Okasaki book
08:31:49 <b_jonas> and it seems I'll be able to borrow it from a department library
08:32:04 <b_jonas> it's one of the libraries with saner rules about outsiders
08:32:10 <gubagem> whats the okasaki book
08:32:25 <orbitz> Funcional Data Structures
08:32:40 <orbitz> histhesis (which appears to be the book, or what the book is based on) is available free onlien as well
08:32:52 <b_jonas> http://books.google.com/books?id=SxPzSTcTalAC&printsec=frontcover&dq=okasaki&sig=fVZkWIz7LYqhmCxgifwS-HeVJQ0
08:32:55 <lambdabot> Title: Purely Functional Data Structures - Google Book Search, http://tinyurl.com/5sfrol
08:33:12 <b_jonas> yep, the thesis is available online for free
08:33:17 <b_jonas> I've already read some of the thesis
08:33:29 <b_jonas> but the book is an extended version so I'm interested about it too
08:33:31 <orbitz> b_jonas: do you know if the book is just the thesis, but laymanned out a bit?
08:33:47 <b_jonas> orbitz: I don't know, but the book has more pages
08:33:58 <orbitz> bigger font?
08:34:04 <b_jonas> book has 220 pages, thesis has 162
08:34:20 <b_jonas> rather smaller paper
08:34:39 <b_jonas> thesis are usually printed in a large font and in onehalf line spacing, but on large paper as well
08:34:39 <EvilTerran> in the book or the paper?
08:34:51 <b_jonas> but I can only guess
08:35:11 <b_jonas> I'll check in the google preview of the book
08:35:16 <EvilTerran> i'd expect the book to contain any stuff that got cut for word-limit reasons or whatever
08:35:19 <b_jonas> the contents or the intro must tell
08:35:47 <b_jonas> word-limit reasons? I thought you can always get over the word limit of a thesis by pusing proofs to an appendix
08:36:07 <b_jonas> and it's a phd thesis, not a masters one
08:36:17 <dcoutts_> Someone should really make a erlang style process abstraction for distributed stuff. It'd be interesting to see how much of how it works is based on the untyped nature of erlang.
08:36:21 <b_jonas> also, the book is form 1998, the thesis from 1996
08:36:28 <b_jonas> anyway, I'll check the google book
08:37:46 <EvilTerran> ah. that does make it entirely possible that more research was done in that time and got included in the book
08:39:35 <b_jonas> but the dead-tree book is easier to read anyway
08:40:36 <ndm> EvilTerran: phd thesis has virtually no word limit, 220 pages would be nothing too much
08:40:49 <BMeph> dcoutts_: Is there a devel-faq, or mail list thread for converting projects from older versions of Cabal?
08:40:55 * ndm has 196 pages of thesis...
08:41:08 <dcoutts_> ndm: too much surely?
08:41:33 <dcoutts_> well, more than necessary anyway
08:41:34 <ndm> dcoutts_: i hope not :)
08:41:43 <ndm> 30 pages is proof
08:41:53 <ndm> plus the formatting restrictions call for quite a lot of margin
08:42:20 <dcoutts_> BMeph: http://haskell.org/haskellwiki/Upgrading_packages
08:42:21 <lambdabot> Title: Upgrading packages - HaskellWiki
08:42:33 <profmakx> I don't think that word or even less page count is any sign of quality for a thesis ;)
08:42:35 <dolio> It's on the high end of the theses I have on my hard drive.
08:42:46 <dolio> But not the highest.
08:42:48 <dcoutts_> ndm: aye, I'm constantly surprised by the wide margins
08:43:22 * ndm wants ICFP/HW style...
08:43:24 <b_jonas> for my master's thesis, they recommend 35 to 60 pages of length, but I'm quite sure those limits aren't enforced strictly
08:43:32 <Igloo> Mine was 200 pages, 7 of which were appendix. I think that was one of the official bounds for Oxford theses
08:43:45 <b_jonas> but a phd thesis can be much longer
08:43:52 <Igloo> But I can't remember if it was 100-200 or 200-300
08:43:54 <ndm> my masters thesis was 70 pages limit, and i had to reduce the font size to get that
08:44:07 <dolio> Theoretical Foundation of Regular Expressions and Text Editors is 321.
08:44:09 <ndm> York has an upper limit, but its insane
08:44:09 <profmakx> hm. i read something about 80.000 words for phd thesis in St. Andrews
08:44:20 <BMeph> dcoutts_: Sweet! Vielen Dank! :)
08:44:21 <Igloo> (being exactly 200 was just coincidence, though)
08:44:24 <b_jonas> ndm: really?
08:44:30 <ndm> profmakx: that's well over 300,000
08:44:39 <ndm> profmakx: i mean over 300 pages
08:44:42 <b_jonas> couldn't you instead put some proofs in an appendix
08:44:50 <shepheb> speaking of papers, I'm looking for a next step through the theory with a decent grokking of monads and a handle on the Bananas,... paper.
08:44:56 <ndm> b_jonas: no, it was 70 page limit, in total
08:45:05 <b_jonas> ndm: now that's wierd
08:45:16 <profmakx> ndm: I have absolutely no feeling how many pages 80.000 words are
08:45:22 <vixey> shepheb theory of what?
08:45:23 <b_jonas> weird
08:45:37 <ndm> profmakx: my thesis is around 50,000 words and 200 pages
08:45:49 <shepheb> vixey: the theoretical parts of Haskell. monads, arrows, functors, morphisms.
08:46:00 <shepheb> I'm just not really sure where to go next. Kleisli monads and arrows?
08:46:05 <profmakx> but i alsso don't know if it is strictly enforced. i will not come around to write anything down before in two years or so ;)
08:46:25 <ndm> profmakx: are you currently doing a PhD in St Andrews?
08:46:44 <b_jonas> my masters thesis has 48 pages
08:46:45 <profmakx> well I will start
08:46:46 <profmakx> soon
08:46:57 <ndm> ah, i move to St Andrews for the summer at the end of next week
08:46:58 <profmakx> so i think perhaps its even 2.5 years until then
08:47:22 <profmakx> nice ;) what will you do there?
08:47:40 <ndm> Google summer of code, i'm not in any way affiliated to the uni or anything
08:47:42 <BMeph> shepheb: Have you read Bananas in Space? :)
08:47:54 <ndm> but if you have any interesting talks etc, i will pop along
08:48:22 <shepheb> BMeph: no. is that a recommendation then?
08:49:02 <BMeph> shepheb: Sure - I haven't read it yet, but it's on my "pile of papers to peruse" ;)
08:49:09 <BMeph> shepheb: http://citeseer.ist.psu.edu/293490.html
08:49:10 <lambdabot> Title: Bananas in Space: Extending Fold and Unfold to Exponential Types - Meijer, Hutto ...
08:49:59 <shepheb> I'm eager to learn more of what I might call the "applied theory" behind Haskell. By which I mean not pure category theory, but the Haskell-touching parts of it, and so on.
08:50:10 <RayNbow> http://citeseer.ist.psu.edu/cache/papers/cs/15038/http:zSzzSzwww.cs.nott.ac.ukzSz~gmhzSzzSzbananas.pdf/bananas-in-space-extending.pdf <-- backwards pdf?
08:50:14 <shepheb> but I can't really find a clear path laid out.
08:50:49 <ndm> profmakx: are you in St Andrews over the summer?
08:51:16 <profmakx> ndm: I dont know yet. probably i will be moving there in august
08:51:30 <ndm> i think i move out at the end of august
08:51:42 <profmakx> was it difficult to find accomodation there?
08:52:05 <ndm> no idea, my girlfriend is in halls, and i'll be sharing with her
08:52:18 <profmakx> ah, ok
08:52:29 <profmakx> my prof told me that i should not move into university accomodation
08:53:13 <ndm> who is your prof?
08:54:16 <b_jonas> I think I'll ask the ##c++ guys, they might have tests for maps
08:54:18 <profmakx> Nik Ruskuc is his name
08:54:22 <b_jonas> bye now
08:57:50 <ndm> not heard of him - if you are around over the summer, let me know :)
08:58:52 <gh_> Hello, I would like to "undefine" the + and - operators of Haskell and use them as data constructors. I think I got the undefine part right ( import Prelude hiding ( (+) , (-) ) ) , but i have a syntax error in ghc 6.8.2 at the line where I use them as constructors
08:59:07 <saml> gh_: data constructors start with :
08:59:10 <gh_> i don't want to use them infixed
08:59:14 <profmakx> ndm: will do
08:59:19 <gh_> oh
08:59:32 <profmakx> ndm: I will be doing semingroup theory so thats not at all haskell related ;)
08:59:36 <gubagem> are you doing peanno arithimitec or something like that
08:59:52 <gh_> SamB, I still have a parse error even with :+ and :-
09:00:13 <saml> gh_: could you show your data constructor declaration?
09:00:34 <gh_> data Literal = :+ Int | :- Int
09:00:48 <saml> data Foo = String :+ Int
09:01:06 <gh_> you mean they have to be infixed ?
09:01:34 <saml> data Foo = (:+) String Int
09:01:53 <saml> data Foo = (:+) Int is ok too
09:02:42 <saml> (2 :+)  works
09:02:59 <gubagem> you can redefine the operators and use them prefix in scheme quite easily :-/
09:03:00 <saml> but i think  it's   expr op expr
09:03:27 <gh_> ok , thanks for the constors, ghc parses this
09:03:38 <gh_> now, can I do something like :
09:03:39 <gh_> +,- :: Int -> Literal
09:03:40 <gh_> + = (:+)
09:03:40 <gh_> - = (:-)
09:03:46 <vixey> gh_: It would be better to use Add and Subtract
09:04:08 <vixey> > let x + y = (x,y) in    7 + 3
09:04:11 <lambdabot>  (7,3)
09:04:24 <vixey> data Term = Add Int Int | Subtract Int Int
09:04:28 <gh_> vixey, it's the signs that I want to use, not the math operations
09:04:29 <vixey> let (+) = Add in ...
09:04:32 <saml> > let x + y = undefined in 7 Prelude.+ 3
09:04:34 <lambdabot>  10
09:04:42 <vixey> gh: It would *still* be better to use Add and Subtract
09:05:00 <qwrx> or Plus and Minus, since they are for signs
09:05:11 <vixey> gubagem: this is trivial in haskell too
09:05:23 <gh_> ok but ideally i would like to have something concise
09:05:32 <vixey> gh_: Did you see my example above?
09:06:28 <vixey> (it might have been clearer to write let x + y = Add x y in ... but anyway, these are equivalent)
09:06:49 <gh_> vixey, yes but i want to use them as unary operators
09:06:57 <vixey> You can't do that
09:07:09 <gh_> :(
09:07:18 <vixey> just write  Add and Subtract
09:07:25 <gh_> because + and - are reserved in the language ?
09:07:37 <vixey> no because there are no unary operators in Haskell
09:07:37 <gubagem> could he do m+ and m-
09:07:42 <vixey> (except - which is horrible)
09:07:56 <vixey> > let m+ x = 1+x in m+ 6
09:08:01 <gubagem> whats the difference between a function and an operator in haskell
09:08:11 <lambdabot>  thread killed
09:08:12 <vixey> gubagem: It's only syntax
09:08:14 <vixey> > let m+ x = 1+x in m+ 6
09:08:15 <qwrx> operators get infixy
09:08:19 <gh_> hmm
09:08:29 <lambdabot>  thread killed
09:08:31 <qwrx> since unary operators are prefix
09:08:36 <qwrx> and haskell functions are prefix
09:08:49 <vixey> lambdabot should have said m is not in scope
09:08:52 <gh_> well, then  what i wanted since the beginning was a function (sorry)
09:08:52 <vixey> since that is not valid
09:09:04 <qwrx> I don't know if you can have a function called +
09:09:05 <EvilTerran> > let plus = (+) in let m + x = 1 `plus` x in m + 6
09:09:07 <lambdabot>  7
09:09:07 <qwrx> or if it has to be (+)
09:09:09 <vixey> gh_: Data constructors are functions too
09:09:29 <EvilTerran> vixey, m was in scope. what you were writing was "let f m x = f 1 x in f m 6"
09:09:35 <EvilTerran> > m + 6
09:09:36 <lambdabot>  m + 6
09:09:38 <gh_> ok, let's forget about data constructors, can i call a function "+" ?
09:09:41 <vixey> > let m+ x = 1+x in m+ 6
09:09:52 <hpaste>  ok pasted "ko" at http://hpaste.org/7919
09:09:53 <vixey> m is not in scope in there
09:09:56 <lambdabot>  thread killed
09:10:01 <qwrx> > let (+) = \x->(x+1) in ((+) 3)
09:10:01 <lambdabot>      Occurs check: cannot construct the infinite type: t = t1 -> t
09:10:01 <lambdabot>     Probab...
09:10:05 <EvilTerran> gh_, you can, but you have to either use it infix or surround it in ()s, because punctuation names are operators
09:10:14 <EvilTerran> ?type m -- vixey, yes it is
09:10:17 <lambdabot> Expr
09:10:23 <vixey> ok ...
09:10:28 <gh_> EvilTerran, even if I import Prelude hiding (+) ?
09:10:39 <qwrx> 's in the grammar I think
09:10:49 <vixey> the point I was trying to make is that you can't have a function called "m+"
09:10:49 <EvilTerran> gh_, punctuation names are operators, regardless of any definitions which may or may not be in scope
09:10:59 <qwrx> all the punctuation things end up being parsed to operators
09:11:15 <EvilTerran> and non-punctuation names are not operators, and you can't have names containing a mixture of punctuation and non-punctuation
09:11:28 <gh_> ok then, i see why it won't work
09:11:32 <mauke> eh'
09:12:21 <gh_> thanks for the help
09:15:31 <shepheb> can someone enlighten the reason for using the term f-algebra for a function f a -> a ?
09:16:08 <dolio> It comes from Omega-algebras, or something like that.
09:16:48 <dolio> In an Omega algebra, you have a carrier set A, and a set of operations Omega...
09:17:16 <dolio> And each omega \in Omega has an associated a_omega, which is an integer denoting the arity of omega.
09:17:38 <gubagem> dolio: what is omega algebra
09:17:56 <dolio> So, like, you might have Omega = {+, -, *, negate}
09:18:10 <dolio> a_+ = a_- = a_* = 2, a_negate = 1
09:18:57 <dolio> And then you also have for each omega, an evaluation function, f_omega : A^a_omega -> A
09:20:30 * gubagem starts drawing unintellgible scribbles in the dirt 
09:20:37 <dolio> But, it turns out, that you can instead represent all those functions as a single function f : Coproduct(A^a_omega) -> A.
09:21:01 <gubagem> whats it good for?
09:22:08 <dolio> Where the coproduct is over all the omegas.
09:23:06 <dolio> Which is like 'f (+ a1 a2) = ... ; f (* a1 a2) = ... ; f (- a1 a2) = ... ; f (negate a) = ...'
09:23:49 <dolio> So, you'll note that that looks distinctly like an algebraic datatype. You have a sum of products.
09:24:16 <dolio> data Omega A = + A A | * A A | - A A | Negate A
09:24:23 <dolio> And f : Omega A -> A
09:25:02 <dolio> So, F-algebras are just a generalization of that to arbitrary functors F, instead of just a coproduct of products.
09:25:45 <dolio> An F-algebra is the functor F paired with the evaluation function f : F A -> A.
09:26:15 <Syzygy-> So [], head forms an algebra?
09:26:29 <Syzygy-> No wait, it doesn't. You need to guarantee an element for that to work.
09:27:14 <dolio> Yeah, it's an algebra, since every A contains bottom.
09:27:19 <Syzygy-> Ah.
09:27:20 <Syzygy-> Ok.
09:27:25 <dolio> I think, at least.
09:29:00 <dolio> And then ([], foldr) is a special []-algebra.
09:30:11 <Syzygy-> How does foldr work?
09:30:11 <dolio> Or, not foldr per-se...
09:30:19 <Syzygy-> Don't you need (foldr a op) ?
09:31:04 <dolio> Actually, I messed up.
09:31:09 <gubagem> > let factorial n=foldr (*) 1 [1..n] in factorial 10
09:31:11 <lambdabot>  3628800
09:31:54 <dolio> The F for lists is F X = 1 + A*X
09:32:07 <dolio> Where A is the element type of the lists.
09:32:50 <Syzygy-> So, my comment about lists needing to be non-empty for head to work really is an issue?
09:33:26 <dolio> Then, an F algebra is 'F A -> A'
09:33:39 <dolio> Er, F B -> B, 1 + A*B -> B
09:35:17 <dolio> And there's a special one, with carrier [A], where the function is 'in : 1 + A*[A] -> [A]'
09:35:41 <hpaste>  malebria pasted "Implicit type in where" at http://hpaste.org/7920
09:36:03 <malebria> I thoght that the type was inferred the most general as possible.
09:36:19 <malebria> thought
09:36:29 <dolio> Which is, of course: 'in (Left ()) = [] ; in (Right (a,as)) = a:as'
09:37:05 <dolio> Which is the initial algebra with signature F.
09:37:42 <dolio> And being initial, there's an F-algebra homomorphism 'cata' to any other F-algebra.
09:38:12 <malebria> It's strange to have to declare type explicity to make code work.
09:39:12 <shepheb> dolio++: thanks, I learned a lot from that
09:39:14 <dolio> If your other F-algebra is f : F B -> B, then cata_f : [A] -> b
09:39:49 <dolio> So, when you translate to Haskell, you get: cata f : [A] -> B, and f : F B -> B...
09:40:10 <dolio> f : 1 + A*B -> B
09:40:35 <dolio> So, cata : (1 + A*B -> B) -> [A] -> B
09:41:01 <dolio> Which you can work around to be: cata : (A -> B -> B) -> B -> [A] -> B
09:41:04 <dolio> Which is foldr.
09:41:35 <malebria> What's a simple way to convert from Double to Int?
09:41:49 <dolio> floor, ceiling, round...
09:41:49 <shepheb> :t truncate
09:41:51 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
09:42:15 <malebria> thanks.
09:43:35 <tchakkazulu> :O
09:43:38 <tchakkazulu> ... misfire.
09:44:06 <dolio> Syzygy-: ([], head) is a []-algebra, I'm pretty sure. As long as the category it's over is Hask, and bottom is part of every type.
09:44:16 <Syzygy-> Aight
09:44:17 <malebria> So in inferring types in where (and let), is not the most general type assumed?
09:44:26 <hpaste>  morrow pasted "reify" at http://hpaste.org/7921
09:44:36 <dolio> I was just momentarily confused between []-algebras and F-algebras where F is the shape of [].
09:46:20 <dolio> In that above construction, [A] is the fixed point of F.
09:46:46 <dolio> Because you can show that there's an isomorphism between [A] and F[A].
09:47:25 <dolio> So, more or less, [A] = F[A].
09:48:43 <shepheb> dolio: would that isomorphism be: concat :: F [A] -> [A], map (:[]) :: [A] -> F [A]  ??
09:48:50 <shepheb> just trying to check my understanding
09:49:12 <shepheb> hm, I probably mean fmap there.
09:49:24 <dolio> Well, in : F[A] -> [A] gives you one direction.
09:50:02 <dolio> The other direction you get from fmap in : FF[A] -> F[A] ...
09:50:11 <dolio> fmap in is an F-algebra.
09:50:44 <dolio> So, since (F, in) is initial, there's the unique cata (fmap in) : [A] -> F[A].
09:51:07 <mxc_> are there any hpaste admins here at the moment?
09:51:13 <shepheb> sorry, I don't know what makes an initial algebra
09:51:31 <edwardk> @seen ddarius
09:51:31 <lambdabot> I saw ddarius leaving #haskell, #haskell-blah, #haskell-overflow and #haskell-soc 1m 29s ago, and .
09:51:46 * edwardk laughs.
09:51:53 <dolio> An initial object has exactly one morphism going from it to every other object.
09:52:33 <mxc_> swing and a miss
09:54:10 <dolio> So, cata (fmap in) is the only morphism [A] -> F[A], is what that says, I believe.
09:54:10 <edwardk> dolio: glad i re-read that i thought you'd said fmap was an F-algebra =), i overlooked the 'in'. NB: you'd need to name in 'inF' or something to avoid clashing with the keyword from  let foo in ...
09:54:26 <BMeph> edwardk: (Holds up a minute-and-a-half measure) Missed 'im, by 'that' much... :)
09:54:36 <edwardk> dolio: thats lambek's lemma
09:55:18 <twobitwork> ghc doesn't use the C stack for function calls? i.e., I don't see any call or ret ops in the asm files
09:55:29 <edwardk> says that in and cata (fmap in) are inverses establishing the isomorphism between F (mu F) and mu F
09:55:34 * shepheb wonders when he'll reach the critical mass where an explanation is unlikely to require me to learn something else :P
09:57:21 <bos> twobitwork: right.
09:57:24 <dolio> Anyhow, also, id = cata in : [A] -> [A] must be the only morphism of that type, too.
09:57:32 <dolio> By initiality.
09:57:53 <dolio> So, in and cata (fmap in) must be inverses and whatnot, so you have an isomorphism.
09:58:04 <twobitwork> bos: so it manually manages its own stack? what does it gain by doing that?
09:58:21 <bos> twobitwork: it often doesn't use a stack at all.
09:58:55 <bos> twobitwork: the evaluation model is completely different from C, so the C stack isn't exactly much help.
09:59:00 <twobitwork> bos: well... I was compairing tail-iteration with recursion and expected to find call/ret somewhere, so it has to be managing some sort of stack, no?
09:59:07 <twobitwork> ahh, true... laziness
09:59:26 * dolio goes to get some food.
09:59:34 <twobitwork> I treid grokking the asm, but..... :P
09:59:37 <twobitwork> tried*
09:59:48 <edwardk> FYI: http://comonad.com/haskell/category-extras/src/Control/Functor/Lambek.hs has lambek's lemma coded up
09:59:49 <lambdabot> http://tinyurl.com/683lku
09:59:52 <edwardk> and its dual
10:00:37 <edwardk> i don't have any way to prove uniqueness in haskell, but otherwise its there ;)
10:07:22 <dcoutts_> twobitwork: another reason is to have 1000's of threads each with a small and expandable stack
10:08:16 <dcoutts_> actually more like 10,000's of threads
10:08:34 <bos> you can easily run a few hundred thousand threads on a laptop.
10:08:45 <bos> with millions, things get slow.
10:09:30 <vixey> lol http://static.metal-archives.com/images/2/7/6/4/2764_logo.jpg
10:13:40 <smg> how can i get a float to an Integer?
10:14:14 <hpaste>  sclv pasted "IsFunction fun and games" at http://hpaste.org/7922
10:14:37 <sclv_> The above took me way too long to figure out.
10:15:46 <BMeph> sclv_: Too long to figure out why it works, or how to get it working? :)
10:15:52 <sclv_> the latter.
10:16:00 <smg> someone knows?
10:16:01 <sclv_> Sadly I actually wrote this because I want to use it in real code.
10:16:10 <^Someone^> I don't know
10:16:13 <^Someone^> :D
10:16:22 <sclv_> of course if I knew how it worked to begin with, it wouldn't have taken me nearly as long.
10:16:27 <BMeph> smg: float, round, ceiling, or truncate will all do what you ask. :)
10:16:47 <shepheb> BMeph: I'm pretty sure you mean 'floor'?
10:16:49 <smg> mh
10:16:52 <smg> floor?
10:17:11 <shepheb> floor, ceiling, round, truncate.
10:17:26 <BMeph> sclv_: I just got through reading McBride's _Faking It_ paper, where he does that with vectors.
10:17:31 <sclv_> what I don't understand fully is that it seems to be idempotent? I.e. it rotates the last arg to the first, which is what I wanted, but if you apply it multiple times, it has doesn't keep shuffling things.
10:18:07 <BMeph> shepheb: Hmm? Ah, yes, good call. :)
10:19:29 <smg> mh i do (x `mod` y == (x / y))
10:19:32 <smg> but this fails
10:19:45 <smg> also if i say x `mod` y == (floor(x/y)) it fails
10:20:07 <sclv_> I keep thinking there must be an easier way to do what I want. (Which is what took me the time -- I spent most of it trying to avoid the two-typeclass solution but to no avail)
10:21:28 <BMeph> smg: It fails because (/) doesn't take the types that you think it does. :)
10:21:30 <Deewiant> smg: use `div` instead of (/)
10:21:46 <newsham> also divMod
10:22:42 <sclv_> Oh yeah, I also was spending a bit of time playing guessing games with funDeps.
10:22:44 <newsham> ?pl \x y -> let (d,m) = x `divMod` y in d == m
10:22:44 <lambdabot> (line 1, column 13):
10:22:44 <lambdabot> unexpected "("
10:22:44 <lambdabot> expecting "()", natural, identifier or "in"
10:22:54 <Deewiant> @pl \x y -> uncurry (==) $ divMod x y
10:22:54 <lambdabot> (uncurry (==) .) . divMod
10:23:17 <smg> yeah stupid exercie
10:23:27 <blarz> hi :)
10:23:48 <smg> i should define a think called nine-test on integers, and in the exercise is told i should implement it for + - * and / but / will be fractional so i use (div) :)
10:24:55 <Arnar> hey there...
10:25:56 <Arnar> does this sound sensible (in a formal text): "the [generic, non-commutative] monoid maintains element order"
10:25:59 <Arnar> ?
10:26:37 <BMeph> sclv_: Maybe the McBride paper will explain it better for you? :)
10:28:30 <Mr_You> if I'm wanting to learn a functional language for the purpose of distributed computing, GPGPU access via C, and Web Services (and we might as well through in their client side desktop/web interfaces) should I focus on Haskell only or also pickup Lisp and O-Caml?
10:28:52 <Mr_You> s/through/throw/
10:29:15 <vixey> It's definitely a mistake not to learn Lisp at some point
10:29:29 <Mr_You> ;-)
10:29:55 <Vq^> and it would be missing out of something interesting not to implement lisp at some point in time
10:29:58 <Vq^> :o)
10:30:37 <twobitwork> ?pl \f y -> f y
10:30:38 <lambdabot> id
10:30:39 <ddarius> There are a lot of other (and more interesting) languages to write a crappy interpreter for other than Lisp.
10:30:50 <Mr_You> well, for new development, I prefer not to move between languages because of the minor syntax differences.
10:31:11 <Botje> foldM is a foldl, right?
10:31:23 <Deewiant> @src foldM
10:31:23 <lambdabot> foldM _ a []     = return a
10:31:23 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
10:31:27 <gubagem> vixey: does me learning scheme excuse me from learning lisp proper?
10:31:38 <vixey> gubagem: not imo
10:31:50 <gubagem> vixey: what am I missing out on
10:31:55 <mehrheit> isn't scheme a lisp?
10:32:00 <Botje> gubagem: but you'll miss out on the horror^Wfun that is ALL UPPERCASE ERRORS!
10:32:00 <twobitwork> gubagem: a bunch of antiquated crap
10:32:16 <gubagem> scheme is like the son of lisp
10:32:45 <gubagem> there is a haskell tutorial somewhere that shows how to write scheme in haskell in 48 hours
10:32:58 <twobitwork> I tried learning CL once after learning scheme, and found it to be very ugly
10:33:48 * gubagem has been looking over some of his old scheme code and noticed how "difficult" it is to read (func arg1 arg2 ...) style code 
10:33:59 <gubagem> its just sort of unnatural
10:34:19 <twobitwork> depends on what you're used to fo course
10:34:28 <twobitwork> do enough scheme code and the paren's disappear
10:34:44 <gubagem> ive almost been there
10:36:05 <gubagem> is there a syntax for multiline comments in haskell/ghc
10:36:11 <vixey> {-
10:36:14 <vixey>  -}
10:36:18 <gubagem> {- and -}
10:36:20 <gubagem> k thx
10:38:10 <sclv_> BMemph: been looking at the mcbride paper, not quite sure of the parallels yet.
10:38:33 <vixey> I thought the point of the paper was that this isn't a great approach ?
10:40:34 <EvilTerran> gubagem, there's also the "literate haskell" syntax which may be more suitable, depending on the situation
10:41:00 <BMeph> vixey: I thought the point of the paper was that Haskell needs more type manipulation support. ;)
10:41:17 <EvilTerran> gubagem, it's described here: http://haskell.org/onlinereport/syntax-iso.html#literate
10:41:18 <lambdabot> Title: Haskell 98 Syntax
10:42:08 <sclv_> hmm... ok, I see how the nthFront section relates.
10:42:15 <edwardk> I keep meaning to switch to literate haskell but never get around to it.
10:42:58 <mm_freak> i'm trying to implement a neural network from scratch…  speed is of importance, but i don't need indexed element access…  do you suggest [Double] or (UArray Int Double) for the weights?
10:43:21 <sclv_> The point of what I'm doing though is that it operates over a function of any arity. Maybe decomposing it into two would help however -- one function to determine the arity, and a second to apply nthFront...
10:43:32 <Dzlk> I do a lot of notetaking in Bird-style literate syntax. It's great for that.
10:43:45 <mm_freak> in the learning phase, the weights will be adjusted a lot, but after that, the weights won't be changed anymore
10:43:49 <edwardk> mm_freak: how big is your hidden layer?
10:43:57 <dons> mm_freak: if speed matters, definitely STUArray Int Double / UArray
10:44:05 <dons> possibly uvector if you're happy to use a new library
10:44:06 <mm_freak> edwardk: i'm not sure yet…
10:44:27 <mmorrow> edwardk: i can't stand using the bird variety for anymore than a few lines of code
10:44:36 <dons> lists would only be a win for prototyping, i think.
10:44:38 <mm_freak> dons: mutable arrays are inconvenient =/
10:44:45 <edwardk> mm_freak: i agree with dons if you want speed (ST)UArray it.
10:44:47 <dons> right, there's uvector for immutable arrays
10:44:57 <dons> you might want to play with that -- though its quite new.
10:45:08 <byorgey> @seen ivanm
10:45:08 <lambdabot> ivanm is in #gentoo-haskell, #xmonad and #haskell. I last heard ivanm speak 2h 8m 44s ago.
10:45:09 <dons> I'd just use STUArray , which you can freeze.
10:45:27 <mm_freak> actually i don't need mutable arrays, since when i change the weights, i change all of them
10:45:38 <dons> we'll have some nice unboxed immutable arrays soon.
10:45:41 <twobitwork> I never understood "literate" programming... seems like it makes things even _less_ legible
10:45:48 <edwardk> twobit: =)
10:45:58 <mm_freak> the garbage collector should take care of dropping the old array
10:46:07 <mm_freak> dons: "soon"?
10:46:24 <dons> code.haskell.org/~dons/code/uvector <-- fast immutable arrays based on STUArray
10:46:30 <twobitwork> I mean, I guess it could be useful if you were writing a research paper where your code is intended to be converted to pdf or ps... but for real applications it doesn't make any sense to me
10:46:31 <Dzlk> mmorrow: If it helps you can borrow your editor's "quote email" function to quote your code after writing it. I wouldn't like doing all the > by hand.
10:46:34 <dons> you could use hmatrix too, i guess.
10:46:38 <edwardk> Sometimes I wish haddock had a less wikilike markup. I never have gotten used to the arcane rules of 'what is markup' for haddock.
10:46:52 <mm_freak> i'll give uvector a shot, sounds interesting
10:46:53 <mm_freak> thanks
10:47:02 <vixey> to memo fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n-2) + fib (n-1)
10:47:05 <mmorrow> twobitwork: (joking aside) if you use the \begin{code} ... \end{code} latex stylee, the output from latex is *pretty*
10:47:12 <vixey> I can just rewrite as
10:47:14 <vixey> fib 0 = 0 ; fib 1 = 1 ; fib n = fib' (n-2) + fib' (n-1)
10:47:14 <vixey> fib' = (fibs !!) ; fibs = map fib [0..]
10:47:20 <twobitwork> mmorrow: why should code be pretty?
10:47:22 <mmorrow> Dzlk: nice!
10:47:23 <vixey> but is there a generic way to do that?
10:47:56 <mmorrow> twobitwork: ok, *insert something that describes something you enjoy looking at*
10:48:03 <edwardk> The problem is that I also like generating haddock, which kinda steps on the latex \begin{code} styling
10:48:07 <twobitwork> I prefer looking at text code :)
10:48:33 <mmorrow> well, i have nothing then :)
10:48:39 <twobitwork> heh
10:48:43 <mmorrow> ha
10:48:50 <twobitwork> unless it can make code look like a pair of tits
10:49:07 <edwardk> @type (.).(.)
10:49:11 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
10:49:14 <mmorrow> heh, i was gonna add "(non sexual)" to the *...*
10:49:22 <twobitwork> heheh
10:49:31 <mm_freak> > unfoldr (\(a,b) -> Just (b, a+b)) (0,1)
10:49:32 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t, t)
10:49:33 <lambdabot>       Expec...
10:49:46 <mm_freak> > unfoldr (\(a,b) -> Just (a, (b, a+b))) (0,1)
10:49:48 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:50:17 <vixey> > map fst . iterate (\(a,b) -> (b, a+b)) $(0,1)
10:50:17 <twobitwork> hey, wow
10:50:18 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:50:27 <Elly> mm_freak: that's crazy
10:50:52 <rizzix> yea that's pretty cool
10:50:53 <mm_freak> vixey's one is crazy, too =)
10:50:53 <tromp> > let f=0:scanl(+)1:f in f
10:50:53 <lambdabot>   add an instance declaration for (Num ([a] -> [a]))
10:51:01 <tromp> > let f=0:scanl(+)1 f in f
10:51:03 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:51:12 <dons> > fix ((0:) . scanl (+) 1)
10:51:14 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:51:17 <vixey> @let fib 0 = 0 ; fib 1 = 1 ; fib n = fib' (n-2) + fib' (n-1)
10:51:17 <vixey> @let fib' = (fibs !!) ; fibs = map fib [0..]
10:51:21 <lambdabot> <local>:1:32: Not in scope: `fib''  <local>:1:45: Not in scope: `fib''
10:51:21 <lambdabot> <local>:1:30: Not in scope: `fib'
10:51:24 <vixey> :[
10:51:37 <vixey> @let fib 0 = 0 ; fib 1 = 1 ; fib n = fib' (n-2) + fib' (n-1) ; fib' = (fibs !!) ; fibs = map fib [0..]
10:51:44 <dons> http://haskell.org/haskellwiki/The_Fibonacci_sequence
10:51:44 <lambdabot> Title: The Fibonacci sequence - HaskellWiki
10:51:46 <edwardk> you'd think by now the channel would be sick of fibs ;)
10:51:46 <vixey> > fibs
10:51:47 <lambdabot>   Not in scope: `fibs'
10:51:50 <lambdabot> Defined.
10:51:59 <vixey> heh
10:52:03 <mm_freak> @src fix
10:52:04 <lambdabot> fix f = let x = f x in x
10:52:06 <vixey> > fibs
10:52:07 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:53:50 <mauke> > liftM2 (,) (fibs !!) (^2) 12
10:54:05 <lambdabot>  thread killed
10:54:35 <pastorn> @hoogle (a -> b -> c) -> a -> b
10:54:37 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
10:54:37 <lambdabot> Prelude.curry :: ((a, b) -> c) -> a -> b -> c
10:54:37 <lambdabot> Data.Tuple.curry :: ((a, b) -> c) -> a -> b -> c
10:54:43 <vixey> (555565404224292694404015791808,144) ?
10:54:48 <pastorn> @type cont
10:54:50 <mauke> > liftM2 (,) (fibs !!) (^2) 12
10:54:51 <lambdabot> Not in scope: `cont'
10:54:52 <lambdabot>  (144,144)
10:54:56 <pastorn> @type cons
10:54:58 <lambdabot> Not in scope: `cons'
10:54:59 <twobitwork> how can something use logrithmic number of ops but work in linear time?
10:55:08 <twobitwork> :t (:)
10:55:11 <lambdabot> forall a. a -> [a] -> [a]
10:55:12 <pastorn> what's the name of the function that will do
10:55:17 <pastorn> f x y = f x
10:55:22 <vixey> @src const
10:55:23 <lambdabot> const x _ = x
10:55:29 <pastorn> thank you :D
10:55:29 <mm_freak> is there a zipWith for arrays?
10:55:43 <vixey> @hoogle zipWithU
10:55:44 <lambdabot> No matches found
10:55:56 <edwardk> @type arrayList
10:55:59 <lambdabot> Not in scope: `arrayList'
10:56:07 <mauke> :t let f x y = f x in f
10:56:09 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
10:56:09 <lambdabot>     Probable cause: `f' is applied to too few arguments
10:56:09 <lambdabot>     In the expression: f x
10:56:16 <mm_freak> @hoogle UArray i e -> UArray i e -> UArray i e
10:56:19 <mauke> pastorn: that function is ill-typed
10:56:19 <lambdabot> No matches, try a more general search
10:56:51 <mm_freak> @hoogle (IArray a e, Ix i) => a i e -> a i e -> a i e
10:56:53 <lambdabot> Prelude.asTypeOf :: a -> a -> a
10:56:54 <lambdabot> Prelude.const :: a -> b -> a
10:56:54 <lambdabot> Prelude.seq :: a -> b -> b
10:57:14 <edwardk> @type \f -> zipWith f `on` elems
10:57:17 <lambdabot> forall c i e. (Ix i) => (e -> e -> c) -> Array i e -> Array i e -> [c]
10:57:28 <twobitwork> @src seq
10:57:29 <lambdabot> Source not found. I am sorry.
10:57:36 <pastorn> @src const
10:57:36 <lambdabot> const x _ = x
10:57:49 <twobitwork> :t const
10:57:51 <lambdabot> forall a b. a -> b -> a
10:57:53 <bd_> mauke: it's const void, really, to use unlambda terminology. Haskell doesn't allow infinite types though (as they're more or less useless)
10:58:00 <EvilTerran> seq :: !a -> b -> b; seq _ = id -- surely?
10:58:09 <edwardk> then run that through listArray with the bounds?
10:58:54 <edwardk> @type \f a b -> listArray (bounds a) $ (zipWith f `on` elems) a b
10:58:57 <lambdabot> forall i e c. (Ix i) => (e -> e -> c) -> Array i e -> Array i e -> Array i c
10:59:31 <edwardk> though i'm sure there is a faster way with the unsaferead/write stuff that i've forgotten how to use
11:03:09 <EvilTerran> altho http://haskell.org/onlinereport/standard-prelude.html#$vseq says "seq :: a -> b -> b; seq = ...       -- Primitive"
11:03:10 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
11:07:10 <dolio> !a -> b -> b isn't a Haskell type.
11:08:18 <dolio> And you can't implement it as 'seq !a b = b', since bang patterns are defined in terms of seq (I believe).
11:08:48 <dolio> (And bang patterns aren't H98, of course.)
11:11:49 <EvilTerran> bang patterns must've been what i was thinking of
11:12:17 <EvilTerran> i forgot they weren't H98
11:14:15 <visq> hi
11:14:37 <visq> what is the meaning of 'Illegal binding of built-in syntax' (ghc HEAD) ??
11:14:58 <dolio> H98 might have bangs in constructors, but that's defined in terms of seq, too, I think.
11:15:16 <dolio> Like data Foo = Foo !Bar !Baz.
11:15:39 <visq> on 6.8.2: The impossible happened:  lookupVers1 main:Language.C.AST.AST $tCTypeSpec{v}
11:15:57 <dolio> Were you trying to define (:)?
11:16:07 <visq> (when standalone deriving Data and Typeable)
11:16:35 <mauke> you win! proceed to level 2
11:22:55 <sclv_> hah irritating monomorphic kind restriction makes all my cutesy isFunction stuff nearly useless. :-(
11:26:59 <orbitz> what does isFunction do?
11:27:02 <dons> sclv_: polymorphic kinds woot!
11:29:09 <hpaste>  morrow pasted "harpy fib" at http://hpaste.org/7923
11:29:09 <sclv_> orbitz: its oleg type hackery that you can do cute (if fragile and confusing) things with, for example moving the last arg of any function to the first...
11:29:26 <orbitz> sclv_: ohhh scawwwy
11:29:35 <mmorrow> that earlier fib stuff made me realize how to do it in asm
11:30:55 <edwardk> sclv: yeah i thought about implementing the operad stuff that way
11:31:11 <edwardk> would yield a more natural programming style for them anywyas
11:31:16 <sclv_> no polymorphic kinds available now, are there?
11:31:23 <edwardk> sclv: nope =(
11:31:40 <mmorrow> :(
11:32:04 <sclv_> ah well. it was a horrible idea to try to use IsFunction for real code anyway. :-)
11:32:54 <conal> mmorrow: neat!  do you know how your perf compares with ghc at various optimization levels?
11:33:12 <edwardk> meh the idea lets you get away with some interesting automatic monadification of code bits at the expense of costing everyone the ability to reason about how your code works ;)
11:33:30 <mmorrow> conal: i haven't compared but plan to
11:34:34 <conal> mmorrow: thx.  i'd love to hear the conclusions.  do you blog?
11:35:16 <sclv_> as I have it now, it creates odd quirks. For example -- rotArgs myFunc (12::Int) "foo" "bar" -- gives a type error, but if I add the last param and call --rotArgs myFunc (12::Int) "foo" "bar" "baz" it works!
11:35:43 <mmorrow> conal: no, but been meaning to start for months now, i may now. either way, i'll write something somewhere and let you know (where)
11:35:49 <sclv_> So it works, but only for fully applied functions, which sort of defeats the whole reason I wanted it...
11:35:55 <conal> mmorrow: great!
11:36:35 <mmorrow> harpy seems like it could be put to amazing use
11:37:49 <conal> mmorrow: i'm playing with functional geometry, including parametric surfaces with generated normals via automatic differentiation.  code generation with harpy might be useful in getting faster surface & normal evaluation.  ditto for a new implementation of Eros (tangible functional programming).
11:37:59 <thetallguy> Howdy folks.  I have the sense that someone has been working on using checksums to make an equality class.  Anyone know about that?
11:38:56 <mmorrow> conal: cool! it would be perfect for image manipulations a la ImageMagick as well.
11:39:27 <conal> mmorrow: totally!  have you seen Pan?  it also used code generation for image manipulation.  http://conal.net/Pan
11:39:27 <lambdabot> Title: The Pan Home Page
11:39:55 <conal> mmorrow: seriously bit-rotten, though.  i'd like to update it.
11:40:20 <conal> and use for texture synthesis with the functional 3d geometry.
11:40:53 <mmorrow> conal: i've semi-read a paper about how pan uses th for optimization, but haven't seen it's harpy stuff. i'll check it out.
11:41:24 <conal> mmorrow: that was a Pan follow-on.  probably sean seefried's PanTHeon
11:41:53 <conal> mmorrow: Pan+harpy is just an idea.  hasn't been implemented.
11:42:01 <mmorrow> conal: ahh, yeah.
11:42:27 <mmorrow> conal: cool, from the demo output images i've seen of pan it looks sweet.
11:42:30 <conal> mmorrow: the Pan implementation did lots of algebraic manipulation & code motion and then generated C++ code
11:43:02 <mmorrow> conal: whoa. why C++ instead of C?
11:43:04 <conal> mmorrow: yeah.  so fun.  there's also a version with a java back-end at http://conal.net/Pajama
11:43:04 <lambdabot> Title: Pajama
11:43:40 <conal> mmorrow: C++ was more convenient in places.  nothing essential, though.
11:44:21 <conal> mmorrow: what makes more sense these days, though is generating GPU code, since GPUs are so much faster than CPUs, and image & geometry synthesis has *so* much inherent parallelism
11:44:39 <conal> mmorrow: as in http://conal.net/Vertigo
11:44:39 <lambdabot> Title: The Vertigo GPU compiler
11:45:13 <mmorrow> conal: interesting
11:45:36 <MyCatVerbs> conal: oh cool! How aggressive is it?
11:46:50 <conal> MyCatVerbs: very!
11:47:12 <conal> MyCatVerbs: check out the paper
11:47:29 <joey`> Where can I find the monad instance definition for Control.Monad.State?
11:48:11 <dolio> @docs Control.Monad.State
11:48:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
11:48:26 <dolio> Hmm, not there.
11:48:39 <dolio> Oh, actually, yes, there.
11:49:00 <dolio> Go there, click on the link to C.M.S.Lazy...
11:49:26 <dolio> Then scroll down to the 'newtype State s a' line, and click on the 'Source' link all the way to the right.
11:49:40 <joey`> Thanks dolio
12:25:08 <MyCatVerbs> conal: sweet. I'ma drop that on the top of my "to-read" stack.
12:28:29 <orbitz> hrm, why is Maybe a monadic type?  I think I don't understand what it means to be a monad, but it seems like Maybe is just a polymorphic algebraic type?
12:29:00 <mauke> a monadic type is a type that implements the Monad interface
12:29:13 <opqdonut> a monadic type is a type for which monadic operations "make sense"
12:29:28 <mauke> where the Monad interface consists of return and (>>=)
12:29:44 <opqdonut> Maybe is just a very simple monad, with it's constructors exposed
12:29:49 <opqdonut> as opposed to, say, IO
12:31:09 <orbitz> normally i use Nothing and Just explicilty, can I use Maybe with do notation to drop the Just?
12:31:17 <orbitz> like do foo <- lookup mymap key?
12:31:23 <vixey> yes
12:31:27 <vixey> @src Maybe (>>=)
12:31:27 <lambdabot> (Just x) >>= k      = k x
12:31:27 <lambdabot> Nothing  >>= _      = Nothing
12:31:46 <vixey> > do foo <- Just 7 ; return foo+1
12:31:49 <lambdabot>   add an instance declaration for (Num (Maybe t))
12:31:50 <vixey> > do foo <- Just 7 ; return (foo+1)
12:31:52 <lambdabot>  Just 8
12:32:16 <orbitz> > do foo <- Nothing; return (foo + 1)
12:32:18 <lambdabot>  Nothing
12:32:59 <orbitz> how would i handle that error in surrounding code?
12:33:19 <vixey> which error?
12:33:26 <dmwit> More monadic code!
12:33:36 <dmwit> Or use runMaybe. ;-)
12:33:45 <dmwit> :t fromMaybe
12:33:47 <dmwit> :t maybe
12:33:48 <lambdabot> forall a. a -> Maybe a -> a
12:33:49 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:35:59 <orbitz> when i do > do foo <- Nothing; return foo, is the return peice being reached?
12:36:22 <vixey> no
12:36:23 <MyCatVerbs> dmwit: ...this raises the question, does \bot enforce any sort of ordering in her responses?
12:36:33 <vixey> well.. yes and no ..
12:36:45 <mauke> just plain no
12:37:05 <vixey> do foo <- Nothing ; unsafeLaunchNuclearMissles ; return foo
12:37:05 <dmwit> MyCatVerbs: No, she does not.
12:37:18 <vixey> Nuclear missles wont be launched
12:37:24 <vixey> but,
12:37:26 <dmwit> > do { foo <- Nothing; undefined; return foo }
12:37:27 <lambdabot>  Nothing
12:37:28 <vixey> @undo do foo <- Nothing ; unsafeLaunchNuclearMissles ; return foo
12:37:28 <lambdabot> Nothing >>= \ foo -> unsafeLaunchNuclearMissles >> return foo
12:37:49 <vixey> the bit of code is evaluated, just since we're lazy and Nothing is the result it's never touched
12:38:01 <MyCatVerbs> orbitz: what you asked there will get you back a (Monad m) => m (Just a), which probably isn't what you want.
12:38:05 <mauke> vixey: how is it evaluated?
12:38:19 <vixey> well it's not evaluate :p
12:38:22 <orbitz> MyCatVerbs: hrm i think so
12:38:40 <mauke> > Nothing >>= error "wat"
12:38:41 <lambdabot>  Nothing
12:38:55 <orbitz> for instance, if i wanted to do a lookup taht returns Just value or Nothing if it's not present, where would i 'catch' the branch that Nothing hapepend
12:38:57 <dmwit> mauke: That proves nothing...
12:39:03 <dmwit> > Just 3 >>= error "wat"
12:39:03 <mauke> dmwit: yes, it does
12:39:05 <lambdabot>  Exception: wat
12:39:10 <dmwit> Oh, never mind.
12:39:15 <dmwit> I was thinking of "fail".
12:39:20 <dmwit> sorry
12:40:21 <maltem> orbitz: What to catch if noone is throwing things?
12:41:02 <orbitz> maltem: not even feces?
12:41:45 <maltem> hey
12:41:49 <orbitz> hi
12:44:38 <byorgey> @type do { foo <- Nothing ; return foo }
12:44:39 <lambdabot> forall a. Maybe a
12:46:36 <Elly> dons: your blog fills me with a warm, glowy feeling :)
12:47:54 <object01> ok, I must be doing something really dumb. I run ghci and type x = 1 and ghci gives me a parse error on =
12:48:04 <mauke> yes
12:48:07 <vixey> object01: no that's valid haskell
12:48:09 <mauke> x = 1 is not a valid expression
12:48:15 <vixey> object01: in ghci you should put let before it though
12:49:14 <object01> is there an interpreter you don't have to put let in front of everything on?
12:49:29 <object01> it appears you need let for function defintiions in ghci also
12:49:32 <orbitz> is it a big deal?
12:49:44 <vixey> object01: you can just write expressions in ghci without typing let
12:50:19 <Sadache> Is this a valid Haskell code? data Value= OR Int Button
12:50:24 <byorgey> object01: function definitions in ghci are a pain since you have to put everything on one line.
12:50:31 <mauke> Sadache: yes
12:50:39 <Sadache> what does it mean?
12:50:42 <byorgey> object01: I suggest putting definitions in a file (where you don't have to use 'let') and then load them into ghci with :load
12:50:55 <orbitz> make an abstract type Value, whos constructor is OR Int Button
12:51:10 <mauke> Sadache: it creates a type called 'Value', having one constructor 'OR' that wraps an Int and a Button
12:51:14 <byorgey> then play around with your definitions, change the file, save it, and reload in ghci with :reload (which can be abbreviated as :r)
12:51:23 <mauke> where Button is hopefully defined elsewhere
12:51:23 <object01> byorgey: thanks
12:51:54 <Sadache> sorrz i wanted to write type Value= OR Int Button
12:51:56 <holst> I wounder if Haskell can be used to implement finite difference schemes and dense (and sparse) matrix equation solvers
12:52:03 <orbitz> object01: i use :load all the tiem (:l if i'm feeling randy). it's great
12:52:11 <byorgey> object01: sure, feel free to ask in here if you have more questions, and welcome =)
12:52:12 <orbitz> Sadache: no
12:52:23 <holst> and do this in a efficient way both in implementation and in compiled code
12:52:24 <mauke> Sadache: that makes Value an alias for the type OR Int Button
12:52:31 <orbitz> err i'm wrong clearly
12:52:35 <mauke> Sadache: this requires OR to be a type constructor with two parameters
12:52:43 <Sadache> I found it in a paper Paul Hudak did about EDSL
12:52:54 <mauke> like type Table = Map String Int
12:52:57 <Sadache> ok i see, thats it then
12:53:14 <orbitz> mauke: you would like that
12:53:26 <tchakkazulu> @hpaste
12:53:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:53:58 <[Justice]> if you have 'data Button = ...' and 'data OR a b = OR a b' somewhere, then 'type Value = OR Int Button' would be legal
12:54:13 <dmwit> That's AND, not OR.
12:54:22 <mauke> heh
12:54:27 <sclv_> holst: I'm no expert in that particular domain, but the general answer is that haskell is about as efficient as "high-level" languages get.
12:54:53 <sclv_> If you need C speed, then you need C, and even then some people have written fancy matrix libraries in C and wrapped them up in haskell for ease of use
12:55:06 <Sadache> but is there in specific trick to do for defining a union of two types?
12:55:21 <orbitz> Sadache: Either?
12:55:23 <vixey> Sadache: It's already done, called Either
12:55:42 <hpaste>  Tchakkazulu pasted "Multi-line GHCi bindings:" at http://hpaste.org/7924
12:55:48 <dmwit> Sadache: Unions are done with | like this:
12:55:54 <Sadache> how to use it please, or can you better point me to an example
12:55:55 <dmwit> data Either a b = Left a | Right b
12:56:07 <Sadache> ok
12:56:10 <orbitz> Sadache: it has 2 constructs, Left, Right
12:56:13 <dmwit> If you have more possible types, use more |s. =)
12:56:14 <orbitz> @src Either
12:56:14 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:56:20 <vixey> > Left 7 :: Either Int String
12:56:21 <lambdabot>  Left 7
12:56:42 <sclv_> > [Left 12, Right "hi dere"\
12:56:42 <lambdabot>  Parse error at "\" (column 26)
12:56:43 <[Justice]> then you can say, 'valL = Left 1' and 'valR = Right (Just 3)'
12:56:44 <sclv_> > [Left 12, Right "hi dere"]
12:56:45 <lambdabot>  [Left 12,Right "hi dere"]
12:56:55 <sclv_> ?ty [Left 12, Right "hi dere"]
12:56:57 <lambdabot> forall t. (Num t) => [Either t [Char]]
12:57:13 <sclv_> ?ty [Left (12::Int), Right "hi dere"]
12:57:15 <lambdabot> [Either Int [Char]]
12:57:17 <[Justice]> or 'valL = if True then Left 1 else Right (Just Nothing)'
12:57:30 <mauke> :t Right (Just Nothing)
12:57:31 <lambdabot> forall a a1. Either a1 (Maybe (Maybe a))
12:57:43 <dmwit> In general, types can be nested to any depth, yes.
12:57:58 <[Justice]> Just Nothing is ... something you shouldn't ever use :P
12:58:02 <vixey> :t (Left (Just (Left (Just (Nothing)))))
12:58:04 <lambdabot> forall a b b1. Either (Maybe (Either (Maybe (Maybe a)) b)) b1
12:58:04 <Sadache> ok, thats good
12:58:06 <Sadache> thanks
12:58:13 <dmwit> [Justice]: What if it's the right thing for your application?
12:58:20 <byorgey> Sadache: in your particular case you could either say  'type Value = Either Int Button', or (probably better) you could say  data Value = VInt Int | VButton Button
12:58:21 <[Justice]> rewrite your application
12:58:39 * dmwit disagrees with [Justice]
12:58:53 <[Justice]> Just Nothing means ... the presence of the absence of a value
12:59:00 <dmwit> right
12:59:01 <byorgey> exactly.
12:59:14 <dmwit> Think of a double pointer.
12:59:26 <dmwit> If your pointer points to NULL, that's a pretty similar thing.
12:59:33 <[Justice]> i'm thinking of a double pointer
12:59:36 <[Justice]> now i'm thinking of a segfault
12:59:55 <dmwit> Now enforce NULL checks at every use. ;-)
13:00:06 <dmwit> And eliminate pointer arithmetic...
13:00:55 <[Justice]> sure, gonna patch that mem allocator for school to not use pointer arithmetic ...
13:01:08 <dmwit> I think you're being purposely obtuse.
13:01:12 <mauke> nah, pointer arithmetic is ok
13:01:20 <holst> Meep - Meep (or MEEP) is a free finite-difference time-domain (FDTD) simulation software package developed at MIT to model electromagnetic systems.
13:01:31 <holst> written in haskell
13:02:07 <Sadache> has anyone here already read Hudak's Building Domain-Specific Embedded Languages
13:02:47 <Sadache> there is something there that i dont guess, and i thought someone here might clear things up for me
13:03:02 <Sadache> http://www.cs.yale.edu/homes/hudak-paul/hudak-dir/ACM-WS/position.html
13:03:03 <lambdabot> Title: Hudak: Building Domain-Specific Embedded Languages, http://tinyurl.com/y6no6s
13:03:12 <^Someone^> Don't look at me
13:03:15 <^Someone^> I have no idea
13:03:32 * orbitz looks at someone
13:03:38 <^Someone^> :O
13:03:41 * ^Someone^ hides
13:04:41 <dmwit> Sadache: Just go ahead and ask the question.
13:05:43 <Sadache> in the paper, Hudak starts discussing a Modular Monadic Interpreter
13:05:44 <sclv_> holst: we also, as I recall, have a haskell SoC project for a parallel high-performance physics library, which will certainly have some interesting matrix stuff as well.
13:05:58 <holst> cool, thank you I will check it out
13:06:29 <Sadache> then he gives an example of the Monadic Interpreter and gives it a type of interp :: Term -> InterpM Value
13:07:25 <Sadache> then he gives examples of several configurations of this monad, confuguring Term, InerpM and Value
13:08:31 <Sadache> so Value can be type Value   = OR Int Bottom
13:08:43 <Sadache> or type Value   = OR Int (OR Function Bottom)
13:09:14 <byorgey> ah, ok, so OR should be interpreted as Either in modern-Haskell-speak
13:09:39 <Sadache> in the same way Term can be  type Term    = TermA or type Term    = OR TermF TermA or
13:09:53 <Sadache> modern haskell speak?
13:10:56 <Sadache> anyway this makes more sence
13:12:32 <wolverian> sense
13:12:41 <byorgey> essentially, saying Value = OR Int (OR Function Bottom) just means that Value is a union of Int, Function, and Bottom
13:13:37 <Sadache> ok thank you, this way it makes senSe to me
13:14:03 <Sadache> I have a last question before I go
13:16:32 <Sadache> I try to run : fs !! 100 where fs@(h,tail)= zipWith (+) fs tail   on GHC but it causes an infinitive loop, where it runs perfectly on WinHugs, any explaination?
13:17:10 <dmwit> You need a first value.
13:17:21 <dmwit> You actually need two first values, I guess.
13:17:32 <Sadache> sorry the code is fs !! 100 where fs@(h,tail)= 1:1:zipWith (+) fs tail
13:17:37 <mauke> Hugs.Base> let fs@(h:tail) = zipWith (+) fs tail in fs
13:17:38 <mauke> zsh: segmentation fault  hugs
13:17:52 <dmwit> > let fs@(h:tail) = 1:1:zipWith (+) fs tail
13:17:53 <lambdabot>  Parse error at end of input
13:17:55 <dmwit> > let fs@(h:tail) = 1:1:zipWith (+) fs tail in fs
13:18:02 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
13:18:05 <mauke> Sadache: no, it isn't
13:18:13 <dmwit> Sadache: Runs fine here.
13:19:01 <Sadache> it runs fine on WinHugs but not on GHCi
13:19:10 <dmwit> \bot runs GHC
13:19:32 <dmwit> And like I said, it runs fine here (on my computer).
13:19:35 <dmwit> So... try again?
13:19:49 <dmwit> Make sure you're getting the two base cases in there.
13:19:57 <Sadache> i ll try then
13:20:01 <Sadache> i ll try again
13:20:36 <Sadache> maybe i missed the first value as i did forget it here
13:24:04 <Sadache> itit gives me parse error on input 'where'
13:25:01 <dmwit> There's no "where" in the code you pasted here...
13:25:11 <dmwit> Maybe you should post the code you're actually trying?
13:25:14 <orbitz> dmwit: yes ter eis
13:25:14 <mauke> yes, there is
13:25:14 <dmwit> ?where hpaste
13:25:14 <lambdabot> http://hpaste.org/
13:25:18 <orbitz> fs !! 100 where
13:25:21 <mauke> but the code he pasted doesn't typecheck
13:25:23 <dmwit> whoop
13:25:43 <Sadache> fs !! 100 where fs@(h,tail)= 1:1:zipWith (+) fs tail
13:25:46 <orbitz> he is tryign to put it in ghci i iamgine
13:25:49 <byorgey> Sadache: try just defining fs in a file, then load that into ghci and type fs!!100 at the prompt
13:25:52 <mauke> you can't use 'where' in expressions
13:25:57 <mauke> use 'let' instead
13:26:12 <dmwit> Also, use (:), not (,).
13:26:22 <dmwit> fs@(h:tail) -- in here
13:26:43 <Sadache> ok, but why where does not work in expression?
13:26:49 <byorgey> (h,tail) is a tuple (a pair of values), whereas (h:tail) is a list with first element h and remainder tail
13:27:10 <mauke> Sadache: why is 'panzerfaust' not a keyword in haskell?
13:27:21 <byorgey> Sadache: just because that's how it is =)
13:27:23 <Sadache> byorgey: yes, i always make this mistake
13:27:49 <byorgey> panzerfaust SHOULD be a keyword in Haskell!
13:28:03 <byorgey> I will go make a ticket on the ghc trac
13:28:09 <[Justice]> > let fs = 1 : 1 : zipWith (+) fs (tail fs) in fs !! 100
13:28:13 <lambdabot>  573147844013817084101
13:28:51 <Sadache> but with where it works just fine with winHugs
13:28:52 <byorgey> > let fs@(_:xs) = 1 : 1 : zipWith (+) fs xs in fs !! 100
13:28:53 <lambdabot>  573147844013817084101
13:29:16 <lokathor> question: is there a "standard" way to turn a Float or Double into an Int or Integer?
13:29:17 <byorgey> Sadache: ah, if so that is special Hugs syntax
13:29:36 <roconnor> @type realToFrac
13:29:38 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
13:29:42 <roconnor> @type fromIntegral
13:29:44 <lambdabot> forall a b. (Num b, Integral a) => a -> b
13:29:45 <Botje> lokathor: floor/round/ceiling
13:29:51 <byorgey> just as GHC allows the special syntax let foo = bar  to define local bindings at the prompt
13:29:58 <Sadache> but doesnt where exist in haskell? isnt it a keyword of Haskell?
13:30:08 <[Justice]> doing fs@(_:xs) is not really an optimization, considering there is a single, very fast call to 'tail', coupled with hundreds of operations to do the sum
13:30:26 <byorgey> Sadache: yes, but you can only use it when defining something, as in,  foo = bar where baz
13:30:39 <byorgey> i.e. only after declarations
13:30:52 <Sadache> ok, i see thank you byorgey
13:32:07 <byorgey> [Justice]: sure, I wasn't suggesting the pattern-matching was an optimization, just making the connection to Sadache's original code
13:32:35 <byorgey> if I were writing it I would use the call to tail as well
13:32:38 <[Justice]> my comment was about Sadache's code
13:33:26 <byorgey> ah, well in that case your comment strikes me as premature newbie-optimization ;)
13:34:53 <bd_> let foo = tail x  <-- is likely to be exactly as efficient as let (_:foo) = x
13:35:39 <bd_> ie, it's likely to produce the same machine code
13:36:11 <[Justice]> perhaps, it certainly looks like it ought to, although i don't think it's specified to be exactly as efficient and it would ultimately depend on the compiler
13:36:59 <[Justice]> maybe it's more efficient in ghc ... anybody tested it?
13:37:03 <bd_> Sure, it's not specified in the spec :) But I'm fairly sure GHC force-inlines tail
13:37:10 <vixey> testing it would be ridiculous
13:37:21 * bd_ gets a dump of the GHC core
13:37:33 <vixey> the difference in speed cannot possibly be negligible
13:37:53 <dmwit> s/negligible/non-negligible/
13:38:26 <[Justice]> either way, a single pattern match vs a single call to tail is negiligible in cost compared to evalutating the 100th element of a list
13:38:31 <bd_> oho, that's interesting
13:38:39 <bd_> Test.test2 = \r srt:(0,*bitmap*) [eta_s9e] GHC.List.tail eta_s9e;
13:38:48 <bd_> ^^^ It /didn't/ inline it, in this trivial test thing
13:38:58 <[Justice]> use GHC with optimizations
13:39:04 <bd_> that's -O2
13:39:05 <[Justice]> ?
13:39:10 <bd_> ghc -ddump-stg -c -O2 Test.hs <-- the command
13:39:20 <[Justice]> interesting
13:39:28 <bd_> SRT(Test.test2): [GHC.List.tail] <-- there is this though
13:39:32 <bd_> I have no idea what that meaans
13:41:01 <[Justice]> couldn't tell ya, i'm no Haskell expert
13:41:31 <bd_> GHC experts would be needed really :P
13:41:37 <bd_> STG output is far from standard haskell
13:41:38 <BMeph> Man, what IS it with the Float -> Int questions today? =8*O
13:41:46 <bd_> @hoogle Float -> Int
13:41:48 <lambdabot> No matches, try a more general search
13:41:51 <bd_> tsk
13:41:59 <dmwit> ?hoogle Floating a => a -> Int
13:42:00 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
13:42:00 <lambdabot> Prelude.fromEnum :: Enum a => a -> Int
13:42:00 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
13:42:05 <dmwit> yuck
13:42:05 <byorgey> [Justice]: hehe, by 'premature newbie-optimization' I actually meant 'prematurely optimizing a newbie', not 'premature optimization by a newbie'.  i.e. whether there is a difference in speed or not, pointing it out to Sadache probably does not accomplish much. =)
13:42:18 <glguy> :t (truncate, ceiling, floor)
13:42:20 <dmwit> :t floor
13:42:20 <lambdabot> forall a b a1 b1 a2 b2. (Integral b2, RealFrac a2, Integral b1, RealFrac a1, Integral b, RealFrac a) => (a -> b, a1 -> b1, a2 -> b2)
13:42:21 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
13:42:22 <byorgey> but I do enjoy questions of optimization.
13:42:23 <bd_> :i RealFrac <--
13:42:37 <dmwit> yup
13:43:30 <Sadache> byorgey: but i find the discussion quite interesting
13:43:55 <byorgey> ah, well, in that case, feel free to ignore me =)
13:44:44 * BMeph wants to find a band named "Spineless Tagless G-Machine"
13:44:45 <[Justice]> but there's no time like the past and the present for getting others to write more readable code ...
13:44:59 <Sadache> and it really matters for me if it is faster or not, but if i get it right, removing the head pattern matching is better? cant the compiler optimize it as it sees that it is not used?
13:45:53 <[Justice]> maybe, values are evaluated lazily
13:47:02 <newsham> the lazy bottom boys band?
13:47:13 <[Justice]> so in 'x@(h:t)' if 'h' is never used, the compiler binds the name, and if it outputs code to evalute 'h', that code hopefully won't be executed
13:47:34 <Sadache> ok
13:47:38 <bd_> hmm, it seems that if you actually use the result of tail in the function, it gets optimized away
13:48:19 <bd_> [Justice]: if h is never used, the compiler shouldn't force it, correct. I say shouldn't, because it's technically allowed to as long as any error or nontermination conditions do not affect the rest of the program
13:48:24 <bd_> but in practice it won't force it
13:48:42 <[Justice]> exactly
13:48:50 <Sadache> I was trying two days ago to implement lazy pattern matching in C# using a monad abstraction, i almost got there exept for performane
13:49:06 <vixey> I think Qi should be removed from http://www.haskell.org/haskellwiki/Dependent_type
13:49:06 <lambdabot> Title: Dependent type - HaskellWiki
13:50:31 <dons> vixey: why's that?
13:51:00 <vixey> I think blaise should be removed too
13:51:08 <dons> since Qi is not dependently typed?
13:51:11 <Sadache> Except for performance, I hate my keyboard, I ve got a qwertz keyboard at home, a qwerty on my laptop and a azerty at work!
13:51:27 <[Justice]> hah
13:52:11 <dmwit> Sadache: Time to carry around your own keyboard. =P
13:52:16 <dons> vixey: so Qi isn't dependently typed, and Blaise doesn't exist?
13:52:25 <dons> or what is the argument for their removal?
13:52:34 <vixey> dons: actually on a closer look I think Qi is
13:52:44 <Sadache> Thanks guys for help
13:52:49 <dons> they're a bit vague about what their type system actually is
13:53:43 <sclv_> From what I've read I'm pretty totally unsure...
13:53:54 <sclv_> which I know is a very helpful thing to add. :-)
13:53:58 <vixey> dons: I'm just not sure if it qualifies
13:54:05 <dons> its strangely unspecified, for a type system
13:54:07 <vixey> since it's just dynamic typing
13:54:15 <vixey> everything is checked at runtime
13:54:18 <dons> oh?
13:54:25 <vixey> 'types' are just predicates passed around at runtime
13:54:29 <dons> removed.
13:54:36 <dons> serious candidates only.
13:54:45 <vixey> and blaise is obviously just a vaporware pet project
13:54:51 <vixey> like arc :D
13:54:59 * vixey shuts up
13:55:11 <Elly> arc has code though :P
13:55:21 <vixey> ty dons++
13:55:49 <frogger> hi everyboby. i'm searching for a nanorc file to highlight the syntax of  *.hs files in nano.
13:56:16 <dons> i think nano already comes with haskell syntax highlighting
13:56:26 <dons> at least it did 10 years ago, last time i used nano.
13:56:32 <frogger> does it?
13:56:39 <frogger> how can i aktivate it?
13:56:42 <frogger> c
13:56:51 <dons> maybe from the syntax menu?
13:57:20 <dons> maybe you need extra files?
14:00:58 <jgrimes> it
14:01:15 <sclv_> oh speaking of which, I've been seeing some pretty bizzare uses of "Dependent Type" lately vis a vis both scala, and ruby (!!)
14:01:36 <sclv_> anyone have any sense what ppl are talking about in these contexts?
14:01:45 <sclv_> The ruby usage I think is just a totally backwards way to talk about polymorphism.
14:02:10 <frogger> dons, yes, but i can't find it in the web
14:02:53 <dons> sclv_: oh no.
14:03:01 <dons> sclv_: like 'generics' eh?
14:08:52 <Dzlk> I don't even understand what dependent could mean in a dynamically-typed language.
14:09:24 <vixey> Dzlk: passing predicates around
14:09:41 <vixey> Dzlk: although it's really not dependant typing .. just plain old dynamic typing
14:10:29 <dolio> Ruby?
14:11:46 <sclv_> I really hope this trend doesn't keep up, because its so confusing.
14:12:10 <Dzlk> vixey: That's what I'd have thought. Taking dynamic to mean "only values have type", saying that a value's type depends on its contents is really just a tautology.
14:12:13 <pastorn> getDirectoryContents "/" >>= filterM doesDirectoryExist
14:12:31 <pastorn> why does that return [".",".."]+
14:12:32 <pastorn> ?
14:12:51 <dolio> Dependent typing is already not particularly well defined.
14:13:05 <bd_> pastorn: because /. and /.. exist?
14:13:23 <pastorn> bd_: but "/" contains a LOT more
14:13:43 <bd_> @hoogle getDirectoryContents
14:13:45 <lambdabot> System.Directory.getDirectoryContents :: FilePath -> IO [FilePath]
14:13:47 <pastorn> getDirectoryContents "/"
14:13:47 <pastorn> [".","..","bin","dev","etc","lib","mnt","opt","srv","tmp","sys","var","usr","boot","home","proc","sbin","root","cdrom","media","initrd.img.old","initrd.img","initrd",".suspended","vmlinuz.old","vmlinuz"]
14:13:56 <bd_> oh
14:14:03 <Liskni_si> yeah, / contains, but current dir doesnt
14:14:12 <bd_> pastorn: you're passing things like 'opt' to doesDirectoryExist, which checks in the current dir :)
14:14:25 <pastorn> opt?
14:14:36 <bd_> completely random example
14:14:36 <pastorn> right! not the absolute filepath
14:14:40 <bd_> getDirectoryContents "/" >>= filterM (doesDirectoryExist . ("/"++)) <-- should work better
14:25:51 <chessguy> @src filterM
14:25:51 <lambdabot> Source not found. Wrong!  You cheating scum!
14:25:59 * chessguy hangs his head
14:26:49 <bd_> filterM fm = liftM concat . mapM (\e -> fm e >>= \r -> if r then [e]; else [])
14:26:58 <bd_> ^^^ one possible implementation
14:27:02 <bd_> :t liftM concat . mapM (\e -> fm e >>= \r -> if r then [e]; else [])
14:27:04 <lambdabot> parse error on input `;'
14:27:16 <bd_> :t \fm -> liftM concat . mapM (\e -> fm e >>= \r -> if r then [e] else [])
14:27:18 <lambdabot> forall a. ([a] -> [Bool]) -> [[a]] -> [[a]]
14:27:24 <bd_> or... not
14:27:38 <chessguy> @hoogle filterM
14:27:39 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
14:28:09 <bd_> :t \fm e -> fm e >>= \r -> if r then [e]; else []
14:28:11 <lambdabot> parse error on input `;'
14:28:15 <bd_> :t \fm e -> fm e >>= \r -> if r then [e] else []
14:28:17 <lambdabot> forall b. (b -> [Bool]) -> b -> [b]
14:28:32 <vixey> :t \p l -> concat . sequence . map (\x -> if p x then [x] else []) $ l
14:28:34 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
14:28:44 <vixey> hmm :[
14:29:17 <bd_> oh
14:29:17 <bd_> doh
14:29:26 <bd_> :t \fm -> liftM concat . mapM (\e -> fm e >>= \r -> if r then return [e] else return [])
14:29:28 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
14:29:42 <bd_> that's better :)
14:32:52 <gubagem> :t getContents
14:33:01 <lambdabot> IO String
14:36:39 <byorgey> chessguy: http://byorgey.wordpress.com/2007/06/26/deducing-code-from-types-filterm/  =)
14:36:40 <lambdabot> Title: Deducing code from types: filterM  blog :: Brent -> [String], http://tinyurl.com/6k4uuu
14:38:46 <chessguy> ah yes, i remember that post
14:41:01 <Bonus> is there already a function like: maybeToMonad (Just x) = return x; maybeToMonad Nothing = fail "whatever"
14:41:26 <vixey> byorgey, very nice
14:41:26 <Zao> return.guard or something?
14:41:45 <vixey> :t (return=<<)
14:41:47 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> m a
14:42:20 <vixey> I guess it can't be done in general
14:42:29 <dmwit> Sure it can.
14:42:30 <Zao> :t return . fromJust
14:42:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
14:42:47 <chessguy> @src fromJust
14:42:47 <lambdabot> fromJust Nothing  = undefined
14:42:47 <lambdabot> fromJust (Just x) = x
14:42:50 <dmwit> :t maybe
14:42:52 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:43:02 <chessguy> fromJust Nothing doesn't 'fail' though
14:43:09 <dmwit> :t maybe return (fail "whatever")
14:43:11 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => Maybe a1 -> a -> m a
14:43:11 <Bonus> hmm yeah
14:43:20 <dmwit> whoops, backwards
14:43:29 <dmwit> :t maybe (fail "whatever") return
14:43:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
14:43:35 <vixey> dmwit: I mean (Monad m) (Monad n) => m a -> n a
14:43:46 <dmwit> vixey: Oh, yeah, that's not possible in general.
14:44:07 <dmwit> Bonus: But prefer this:
14:44:11 <dmwit> :t maybe mzero return
14:44:13 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
14:44:16 <Bonus> ooh
14:45:03 <dmwit> vixey: (>>= return) === id -- a Monad law
14:50:03 <^Someone^> > tan(3.14)
14:50:05 <lambdabot>  -1.592654936407223e-3
14:50:28 <vixey> > ( (sqrt 5 + 1)/2 )::CReal
14:50:29 <lambdabot>  1.6180339887498948482045868343656381177203
14:51:32 <^Someone^> > Pi
14:51:32 <lambdabot>   Not in scope: data constructor `Pi'
14:51:42 <^Someone^> > pi
14:51:43 <lambdabot>  3.141592653589793
14:51:48 <dmwit> > pi :: CReal
14:51:49 <lambdabot>  3.1415926535897932384626433832795028841972
14:51:58 <mar77a> > exp 1 :: CReal
14:51:59 <lambdabot>  2.7182818284590452353602874713526624977572
14:52:02 <hpaste>  Botje pasted "CPS fun!" at http://hpaste.org/7925
14:52:03 <dmwit> That's a lot of digits.
14:52:26 <Botje> uh
14:52:29 <Botje> don't look at that
14:52:32 <Botje> you'll probably go blind.
14:52:46 <^Someone^> @let tand x = tan(pi*x/180)
14:52:47 <dmwit> It's all one long line!
14:52:48 <lambdabot> Defined.
14:53:14 <^Someone^> > 8*tand(3.5)*tand(9)/(tand(9)-tand(3.5))
14:53:16 <Botje> yeah
14:53:18 <lambdabot>  0.7971220735406169
14:53:19 <^Someone^> @undefine
14:53:23 <lambdabot> Undefined.
14:53:32 <Botje> i'm too lazy/stupid (probably the first) to define a proper Text.Pretty for my ADT
14:54:49 <^Someone^> Good to have the Haskell channel right next to the math channel :D
14:55:13 <mar77a> ^Someone^: i think there's a haskell-bot channel if you want to spam it up
14:55:16 <mar77a> (there)
14:55:19 <Botje> they're really loud at night.
14:55:30 <dmwit> mar77a, ^Someone^: You can /msg lambdabot
14:55:33 <Botje> from time to time they work out theorems and proofs and shout eureka
14:55:36 <^Someone^> Oh yeah, I forgot
14:55:49 <dmwit> Everything there is the same, except you have to use ?ty instead of :t and ?kind instead of :k.
14:56:08 <^Someone^> Ah
14:56:34 * ^Someone^ is new here
14:59:40 <dons> "There is a choice here between convenience and safety.  What would
14:59:41 <dons> Haskell choose?"
15:00:49 <dmwit> That seems like an easy question.
15:00:59 <dons> Those who would give up essential type safety, to purchase a little temporary
15:00:59 <bos> is there any LANGUAGE extension that turns on unboxed values, e.g. I# and (# #), or is there just -fglasgow-exts?
15:00:59 <dons> liberty, deserve neither liberty nor type safety.
15:01:11 <dons> bos, no. there are two.
15:01:17 <dons> MagicHash, and UnboxedTuples
15:01:30 <bos> ah, cool.
15:01:32 <dons> the former for I#, the latter for (# x, y, z #) et al
15:02:05 <bos> dons: getting all the unnecessary tests out of the bloom filter code sped it up by about 10%, btw.
15:02:14 <dons> awesome.
15:02:19 <dons> did you have to do that by hand?
15:02:22 <bos> yep.
15:02:29 <dons> did you try the newer compiler?
15:02:43 <dons> oh, by dropping into primops, or wrapping up unchecked ones?
15:02:45 <bos> no.  i don't build HEAD recreationally.
15:02:49 <dons> heh
15:02:56 * dons admits his secret addiction
15:03:01 <bos> yes, straight into primops.
15:03:17 <dons> well, that's the easiest route.
15:03:25 <bos> there aren't any unchecked shifts exported to the outside world.
15:03:32 <dons> its simply a matter of training the compiler after that.
15:03:47 <dons> I was thinking you could write your own shifts, et al
15:03:51 <dons> without tests
15:03:59 <bos> yes, that's what i did.
15:04:08 <bos> shiftL (W64# x#) (I# i#) = W64# (x# `uncheckedShiftL64#` i#)
15:04:13 <dons> ah yes, that's what I mean.
15:04:25 <dons> one step up from using `uncheckedShiftL64#` directly
15:04:30 <dons> i had to do similar inside Binary
15:04:31 <vixey> what does # mean?
15:04:41 <Botje> "sharp edges, don't touch"
15:04:42 <dons> it indicates it is of unlifted kind, vixey
15:04:54 <dons> i.e. strict values that are represented unboxed
15:04:57 <bos> i.e. unboxed.
15:05:02 <dons> guaranteed not to contain bottom
15:05:12 <bos> "lifted" is ghc special moon language for a boxed value.
15:05:17 <dons> they have the nice property that machines actually operate on them directly
15:05:29 <dons> and even have special things called registers for values of such types :)
15:06:41 <dmwit> My machine has no registers for (#Int, Int#)... ;-)
15:06:48 <dons> sure it does.
15:06:51 <dons> r1 and r2
15:07:07 <dons> that's just syntax for describing a set of registers
15:07:18 <dons> actually, my boss wrote a paper on this.
15:07:19 <malebria> It'd be good to have MonadIO m => m () in gtk2hs functions, instead of IO ().  Is it very complicated?
15:07:44 <dons> http://citeseer.ist.psu.edu/jones91unboxed.html
15:07:45 <lambdabot> Title: Unboxed Values as First Class Citizens in a Non-Strict Functional Language - Jon ...
15:08:06 <malebria> like in: onToggled :: ToggleButtonClass self => self -> IO () -> IO (ConnectId self), have: onToggled :: (ToggleButtonClass self,, MonadIO m ()) => self -> m () -> m (ConnectId self)
15:08:16 <malebria> Or event self -> m () -> IO (ConnectId self)
15:08:43 <pastorn> > map f [x,y,z]
15:08:44 <lambdabot>  Add a type signature
15:08:50 <pastorn> simple reflect?
15:09:04 <EvilTerran> yes?
15:09:13 <pastorn> what do i need?
15:09:14 <EvilTerran> > map f [x,y,z] :: [Expr]
15:09:14 <Saizan> > map f [x,y,z] :: [Expr]
15:09:16 <lambdabot>  [f x,f y,f z]
15:09:16 <vixey> > map f [x,y,z] :: [Expr]
15:09:17 <lambdabot>  [f x,f y,f z]
15:09:18 <dcoutts> malebria: there are ways to do that kind of thing without changing gtk2hs
15:09:19 <lambdabot>  [f x,f y,f z]
15:09:22 <EvilTerran> oh snap!
15:09:38 <Elly> wow, lambdabot is really useful
15:09:42 <pastorn> thanks :D
15:09:55 <Elly> I wonder how hard it would be to write a similar thing for SML
15:10:14 <malebria> dcoutts: How could I do that?  I want to have my program in a StateT monad, but I don't know how to make a function of this monad be called from onToggled, for instance.
15:10:26 <dons> 1500 patches, 18 months part time, Elly :)
15:10:35 <dons> but you've a model now, so likely easier to start from
15:11:29 <dcoutts> malebria: there was a post about it, the basic trick is to stash the state into an IORef
15:11:56 <Elly> dons: where can I get the source for it?
15:12:00 <dons> ?source
15:12:01 <lambdabot>  not available
15:12:04 <ddarius> @version
15:12:04 <dons> oh.
15:12:04 <lambdabot> lambdabot 4p629, GHC 6.8.2 (Linux i686 2.40GHz)
15:12:04 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:12:06 <dons> ah
15:12:13 <ddarius> @source Data.Tree
15:12:13 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tree.hs
15:12:15 <dcoutts> malebria: I seem to recall Cale wrote about it, or if not he might remember who did
15:12:18 <malebria> dcoutts: that's how I used to make this with gtk2hs..
15:12:27 * Elly watches darcs go
15:12:33 <vixey> @source Foo.Bar.Baz.Quux
15:12:33 <lambdabot> Foo.Bar.Baz.Quux not available
15:12:37 <vixey> @source Foo.Bar
15:12:37 <lambdabot> Foo.Bar not available
15:12:39 <malebria> dcoutts: I was just wondering if it's possible to use the state monad, instead.
15:12:43 <Elly> hm...maybe I should learn to use darcs
15:12:45 <dcoutts> malebria: sure and it's the same trick but nicely hidden so you can use StateT
15:12:49 <Cale> Wrote about what?
15:13:07 <Bonus> i always thought haskell should have just stolen the import system from python
15:13:11 <ddarius> Elly: ?  Just copy and paste that line.
15:13:17 <Bonus> from Blah import f, g, x
15:13:18 <Cale> Bonus: Why?
15:13:24 <malebria> dcoutts: do you have the link?
15:13:25 <Bonus> i think its better
15:13:26 <bos> Bonus: you can do that.
15:13:33 <bos> import Blah (f,g,x)
15:13:34 <Cale> import Blah (f,g,x)
15:13:38 <Bonus> yeah i know but the whole package system
15:13:39 <Bonus> thingy
15:13:46 <Bonus> so if you have
15:13:47 <bos> huh?
15:13:51 <Bonus> Foo.Bar.Baz
15:13:53 <Bonus> you can do
15:13:56 <Bonus> from Foo.Bar import Baz
15:13:59 <Bonus> and then you do
15:14:01 <Bonus> Baz.f
15:14:10 <Cale> You can do that too, in a sense :)
15:14:11 <vixey> ?where Report
15:14:11 <lambdabot> http://www.haskell.org/onlinereport/
15:14:16 <bos> Bonus: haskell's package system is very similar to python's that way, too.
15:14:19 <Cale> import Foo.Bar.Baz as Baz
15:14:19 <dons> import qualfied X as Y (f)
15:14:20 <glguy> rather than import qualified Foo.Bar.Baz as Baz?
15:14:20 <Elly> ddarius: nah, I did that; I mean learn how to use it for my own projects :)
15:14:21 <^Someone^> Bye vixey et al
15:14:31 <EvilTerran> import qualified Text.ParserCombinator.Parsec as P
15:14:32 <Bonus> yeah but the thing is the subpackages
15:14:45 <Bonus> can i import just ParserCombinator from Text
15:14:46 <Bonus> and then do
15:14:51 <Bonus> ParserCombinator.Parsec.f
15:14:52 <Bonus> etc
15:14:57 <ddarius> Wouldn't it have been hard to steal python's import system in 1989?
15:15:05 <Bonus> haha
15:15:06 <Bonus> true that
15:15:09 <Bonus> i was thinking like
15:15:11 <Bonus> they should steal it now
15:15:21 <dons> they're pretty similar. the ML guys look on smugly.
15:15:23 <ddarius> Elly: It's very easy to use.
15:15:23 <vixey> how is it better than haskell?
15:15:35 <Elly> ddarius: yeah; I usually use bzr, but nobody else seems to :P
15:15:42 <dmwit> vixey: Which, Python or ML?
15:15:50 <Elly> dons: mmm, ML :)
15:16:29 <dons> its ok, type classes, gadts, type families, purity, parallelism and a large community make up for the module system
15:16:40 <Bonus> yeah, haskell owns
15:16:41 <Bonus> i was just sayin
15:17:09 <dcoutts> malebria: this might be relevant http://www.haskell.org/pipermail/haskell-cafe/2008-January/038047.html
15:17:09 <lambdabot> Title: [Haskell-cafe] MonadPrompt + Gtk2Hs = ?, http://tinyurl.com/6fmtuz
15:17:19 <Elly> dons: you and your type classes :(
15:17:28 <Elly> dons: I want sprintf in SML really badly :(
15:19:43 <Elly> sigh
15:19:51 <Elly> I mean, there's a reason I decided to learn Haskell after learning SML :P
15:21:02 <chessguy> @where lambdabot
15:21:02 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
15:21:09 <chessguy> @seen lambdabot
15:21:09 <lambdabot> Yes, I'm here. I'm in #haskell.cz, #haskell, #haskell-hac4, #gentoo-uy, #friendly-coders, #dreamlinux-es, #thunks, #haskell-hac07, #haskell_ru, #haskell.dut, #haskell.de, #haskell.es, #haskell.fi, #
15:21:09 <lambdabot> haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell-books, #rosettacode, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #
15:21:09 <lambdabot> parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #darcs, #jhc and #ghc
15:21:31 <MyCatVerbs> Why do unicyclists need a lambdabot?
15:21:45 <Elly> MyCatVerbs: I don't know; why?
15:21:53 <lament> MyCatVerbs: that channel mainly consists of lambdabot and shapr.
15:22:00 <byorgey> to get to the other side?
15:22:06 <yitz> MyCatVerbs: because it keeps them off balance
15:22:08 <chessguy> anybody got a simple (practical) example of too much laziness?
15:22:11 <MyCatVerbs> lament: I must investigate!
15:22:23 <dmwit> #unicycling `subset` #haskell ?
15:22:29 <byorgey> chessguy: sure: foldl (+) 0 [1..1000000]
15:22:49 <MyCatVerbs> lament: shapr isn't in there.
15:23:06 <lament> that's because he's not online at the moment
15:23:23 <byorgey> @seen shapr
15:23:23 <lambdabot> shapr is in #haskell-soc, #haskell-blah, #scannedinavian and #haskell. I last heard shapr speak 20h 34m 59s ago.
15:23:27 <chessguy> > foldl f 0 [1..5] :: Expr
15:23:29 <lambdabot>  f (f (f (f (f 0 1) 2) 3) 4) 5
15:24:09 <chessguy> byorgey: so because it has to build up all those thunks, it blows out the stack?
15:24:22 <byorgey> chessguy: due to laziness, that just builds up a huge thunk 1 + 2 + 3 + 4 + 5 + .... + 1000000 which blows the stack when it finally gets evaluated
15:24:25 <byorgey> exactly
15:24:42 <byorgey> which is why we have foldl' .
15:24:44 <chessguy> > foldl' f 0 [1..5] :: Expr
15:24:45 <lambdabot>  f (f (f (f (f 0 1) 2) 3) 4) 5
15:24:53 <chessguy> which does the same thing, but strictly
15:24:59 <MyCatVerbs> lament: oh, huh. Heh, explains a lot.
15:24:59 <chessguy> @src foldl'
15:25:00 <lambdabot> foldl' f a []     = a
15:25:00 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:25:02 <byorgey> yup.
15:25:14 <malebria> dcoutts: I not very fast with reading monads..
15:25:20 <chessguy> @src foldl
15:25:21 <lambdabot> foldl f z []     = z
15:25:21 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:26:13 <malebria> malebria: but thanks, anyway... I think IORefs are good enough.
15:26:20 <Elly> wait, does haskell get run through cpp or something? I see #if and #ifdef in the lambdabot source
15:26:20 <MyCatVerbs> Hrmn.  Is there any particular reason why type Flip f a b = f b a; isn't in the standard library anywhere?
15:26:38 <chessguy> byorgey: so too much laziness can't give the wrong result, though, right? it can only be un-optimized
15:26:41 <MyCatVerbs> Elly: if you pass the --cpp option to ghc, yes.
15:26:53 <Elly> oh, wow
15:26:53 <dmwit> chessguy: right
15:26:58 <Jedai> MyCatVerbs:
15:27:03 <MyCatVerbs> Er, -cpp, even.
15:27:43 <vixey> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
15:27:43 <lambdabot> http://tinyurl.com/f9umb
15:27:54 <MyCatVerbs> Jedai: ?
15:27:54 <vixey> see you are required to write  heteroList = [SB (), SB 5, SB True]
15:27:58 <Jedai> Oops sorry... Well cpp is useful but on the other hand I don't like it because it's hard on source transformers or this kind of thing...
15:28:04 <vixey> is it possible to have [(), 5, True] instead?
15:28:27 <byorgey> vixey: nope, that isn't well-typed
15:28:36 <Jedai> I would prefer a more structured alternative which is not simply a text preprocessor
15:29:12 <MyCatVerbs> Jedai: weeeeell...
15:29:19 <dmwit> [exists a. a] -- heh
15:29:46 <dmwit> Jedai: There's TH and friends.
15:29:47 <byorgey> vixey: actually, I guess you could do that if you made instance Num () and instance Num Bool  =)
15:29:52 <MyCatVerbs> Jedai: to be fair, most of the stuff that cpp is used for is low-level boilerplate, and it's pretty rare to want to attempt source transformations on that.
15:30:10 <dmwit> byorgey: Not even then, right?
15:30:15 <byorgey> vixey: but that's just a silly hack that wouldn't do what you want, at all.
15:30:15 <Jedai> dmwit: Yes, but the objectives aren't the same
15:30:18 <dmwit> byorgey: () doesn't unify with Bool
15:30:44 <vixey> I do want to do it
15:30:45 <byorgey> dmwit: ah, er, you're right of course
15:30:49 <MyCatVerbs> Jedai: the more interesting stuff where you really would want to use source-level transformations almost never, ever uses cpp anyway, so it's not a total loss.
15:31:08 <byorgey> I don't know what I was thinking =)
15:31:25 <dmwit> Well, either of them alone would work.
15:31:26 <byorgey> even if you have a list of type Num a => [a], they still have to all be the same a =)
15:31:27 <Jedai> MyCatVerbs: It's true and false (if you could do easy source transformation on those, you could find applications)
15:31:37 <dmwit> [(), 5] and [5, True] could both happen with silly instances.
15:31:42 <byorgey> right.
15:32:40 <byorgey> vixey: looks like you're stuck with existential wrappers, or tagged unions.
15:33:25 <MyCatVerbs> Jedai: I honestly doubt it, since those are almost always compiler-specific and practically never even remotely portable. Things like the code in Control.Concurrent, for example.
15:33:36 <Jedai> dmwit: Right, because the 5 would become an unit or a bool, but out of num constants (and now string constant ?) you can't do thing like that, and anyway the list would still contains only one type
15:33:55 <dmwit> yep
15:34:49 <hpaste>  vicky pasted "format" at http://hpaste.org/7926
15:35:32 <vixey> I see no reason why format [(), 7, "+", ()] cannot type
15:35:48 <vixey> the only difference is it uses : and [] rather than ::: and Nil
15:36:22 <vixey> oh I guess the type of elements in the list is instantiated at a different level
15:36:25 <Jedai> vixey: What would be the type of the list ?
15:36:55 <vixey> I was hoping [forall s. Format s => s] would work
15:37:06 <Jedai> vixey: data [a]  = [] | a : [a]
15:37:33 <vixey> so who don't I get, [] | forall s. Format s => s : [forall s. Format s => s] ?
15:37:59 <byorgey> vixey: in a list of type [forall s. Format s => s], all the list elements must have type forall s. Format s => s.  () does not have this type, neither does 7, and so on.
15:37:59 <vixey> it links every element of the list to the same s?
15:39:02 <byorgey> If I give you a value of type  forall s. Format s => s, YOU get to choose what s is.
15:39:12 <malebria> dcoutts: actually, I think I'll have to do something like one of the solutions in this e-mail.
15:39:19 <Jedai> vixey: a value of type (forall s. Format s => s) is a value that can be used as any type of the type class Format... 5 isn't one
15:39:27 <malebria> dcoutts: I want to do something as hbeat, but in Gtk.
15:39:39 <malebria> http://dockerz.net/twd/hBeat
15:39:40 <lambdabot> Title: hBeat - twd
15:40:19 <vixey> I guess p^q = format p ++ format q is better then
15:40:27 <malebria> dcoutts: but hbeat has it's own main loop, and I don't know how to do this in GTK.  I wonder about using timeoutAdd, but in the doc it sais:
15:40:30 <vixey> I can write > 1^()^2^3^()^() --> "1()23()()"
15:41:04 <malebria> Note that timeout functions may be delayed, due to the processing of other  event sources. Thus they should not be relied on for precise timing.
15:41:37 <malebria> dcoutts: So I'm not sure if it's gonna work ok.
15:42:51 <lodi> Hi all... is this the right place to ask a Yampa question?
15:43:05 <mar77a> what's yampa!
15:43:31 <lodi> http://www.haskell.org/yampa/
15:43:32 <lambdabot> Title: Yampa
15:44:36 <ddarius> @where yampa
15:44:37 <lambdabot> http://www.haskell.org/yampa/
15:45:44 <hpaste>  glguy annotated "format" with "Using existential quantification" at http://hpaste.org/7926#a2
15:45:57 <byorgey> lodi: you're perfectly welcome to ask, maybe someone here will be able to help
15:46:15 <glguy> vixey: That's one way to do what you were trying to do
15:47:56 <lodi> alright... I was just wondering if there's some way to save a signal function?  As in, serialize any internal state to disk (and restore it later), not just hold on to the closure via 'freeze' etc.
15:50:17 <dmwit> Are signal functions plain old functions?
15:50:30 <dmwit> In general, it's not really convenient to serialize Haskell functions.
15:50:54 <dmwit> However, if it's your own custom Arrow, you could probably write your own (de)serialization functions.
15:51:19 <lodi> looking through the source, it looks to me as if it's not possible... something like the 'integral' SF works by continually capturing the old integral into a new integral sf, that's evaluated next time... so it's closed over immediately and I can't get to it
15:51:22 <dmwit> Making it an instance of Show and Read is probably the cheapest in terms of programmer effort.
15:52:56 <ddarius> dmwit: You can model them that way.  (Or are you asking about a particular implementation?  In Yampa, they aren't quite if I'm not misremembering.)
15:53:35 <dmwit> I was asking about lodi's particular implementation, I guess.
15:55:34 <lodi> dmwit: the way it is in yampa, a signal function is just a data type, with a reference to a function inside of it... you 'run' the signal function on an input, and it gives you an output and also a new instance of the datatype with a (possibly new) function inside of it
15:56:16 <dmwit> Okay, then serialization is probably out of the question, unless you want to invest some serious time understanding the internals of your compiler.
15:57:06 <dmwit> I don't know for sure, but that's a pretty educated guess.
15:59:48 <petekaz2> question on Real World Haskell chapter on programming with monads ... they define "newtype Supply s a = S (State [s] a)" and then say rather than writing the boilerplate code, we'll use "derving
15:59:55 <petekaz2> Monad instead
16:00:12 <petekaz2> can someone show me how return and >>= are defined the manual way?
16:00:24 <dibblego> ?src (>>=) State
16:00:25 <lambdabot> Source not found. :(
16:00:25 <dmwit> return x = S (return x)
16:00:31 <petekaz2> they make it sound obvious but I am not grokkng it
16:00:33 <byorgey> petekaz2: they are just defined in terms of return and >>= for State.
16:00:34 <lodi> right... so my thinking was, why was it not designed so that the internal state is stored inside the SF data type, that way you could read/write it and get/put your own values
16:00:39 <dmwit> S m >>= f = S (m >>= f)
16:01:01 <petekaz2> dmwit, that's it?
16:01:05 <dmwit> yes
16:01:20 <dmwit> petekaz2: i.e. just unwrap the S constructor, use the underlying return and (>>=), then rewrap.
16:01:33 <petekaz2> I was confused because I thought 'f' is a function that returns Supply not, State
16:01:42 <byorgey> yeah, that >>= is not quite well-typed, dmwit
16:01:47 <dmwit> Oh, whoops.
16:01:49 <petekaz2> so using it as you have in >>= was confusing to me
16:03:13 <lodi> and I think I just answered my own question... gah... there's no way to grab a reference to a signal function from inside another sf, so it's irrelevant
16:04:23 <dmwit> petekaz2: Anyway, the idea is that you just unwrap the S constructor, do the operation, and wrap it back up.
16:04:55 <petekaz2> right, that's what they say in the book too, but what does it actually look like?
16:05:08 <petekaz2> I'm having a hard time trying to figure it out.
16:05:11 <dmwit> unS (S x) = x
16:05:25 <dmwit> S m >>= f = S (m >>= unS . f)
16:05:33 <dmwit> Something like that, maybe?
16:05:51 <byorgey> yeah, that ought to work
16:05:52 <petekaz2> ahh
16:05:56 <petekaz2> cool
16:06:15 <vixey> is that very first S meant to be there?
16:06:16 <petekaz2> I was missing the part where you unbundled the reslut from f
16:06:21 <dmwit> vixey: yes
16:06:27 <vixey> I don't understand it
16:06:34 <vixey> is
16:06:34 <dmwit> vixey: It parses as
16:06:41 <dmwit> (>>=) (S m) f = ...
16:06:59 <vixey> S (S n) >>= f = S (f n)
16:07:02 <vixey> equivalent?
16:07:27 <dmwit> I... don't think so.
16:07:32 <byorgey> no
16:07:39 <byorgey> that would be f . unS
16:08:18 <dmwit> unS . f, surely
16:08:24 <dmwit> oh, hm
16:08:31 <dmwit> It's not either of them, really.
16:09:07 <dmwit> S . f . unS . unS
16:09:50 <dmwit> > 300 / 720.
16:09:50 <lambdabot>   parse error on input `}'
16:09:51 <dmwit> > 300 / 720.0
16:09:53 <lambdabot>  0.4166666666666667
16:13:07 <petekaz2> dmwit, thanks for the explanation.  I can now move past that section. My brain won't me move forward until all questions have been answered unfortunately.
16:13:21 <dmwit> *nods*
16:15:21 <ivanm> @seen byorgey
16:15:22 <lambdabot> byorgey is in ##logic, #haskell-blah, #xmonad and #haskell. I last heard byorgey speak 7m 42s ago.
16:15:33 <ivanm> byorgey: I'm mailing my code to you now
16:16:35 <mapreduce> In Haskell's I/O stuff how is it ensured that resources are safely closed?
16:16:50 <dons> mapreduce: it depends on the IO operations you're doing.
16:17:12 <dons> lazy file IO, strict file IO, foreign resources, network things?
16:17:29 <mapreduce> Strict file IO.
16:17:52 <dons> well, strict IO is easy, the resource is generally closed as soon as it is read.
16:18:02 <dons> typically with the 'bracket' function
16:18:14 <dons> which ensure the resource is closed, even with exceptions.
16:18:17 <mapreduce> :type bracket
16:18:23 <dons> :t bracket
16:18:25 <lambdabot> Not in scope: `bracket'
16:18:31 <dons> :t Control.Exception.bracket
16:18:33 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
16:18:40 <dons> ?docs Control.Exception
16:18:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
16:19:02 <Pseudonym> Unfortunately, that does make resources nested, and structures your program around the lifetimes of resources.
16:19:03 <dons> it takes an action to allocate some resource, an operation on that resource, and an action to run to finalise it
16:19:16 <Pseudonym> Which is unfortunate.
16:19:40 <mapreduce> So if you want two operations on that resource you compose two actions?
16:20:15 <dons> right. you just compose things in the blob passed in to bracket
16:20:24 <dons> IO actions are first class, so you can glue them together
16:20:31 <mapreduce> Ok, thanks.
16:22:17 <byorgey> ivanm: thanks!
16:22:26 <mapreduce> Would it be unusual to use bracket twice nested?  E.g., if writing from one resource to another
16:22:46 <hpaste>  dons pasted "resource scoping" at http://hpaste.org/7927
16:23:02 <mapreduce> Also, what would 'c' typically be in the type of bracket?
16:23:02 <dons> not really, if there are two resources.
16:23:15 <dons> usually it would be ()
16:23:24 <mapreduce> Ah.
16:23:58 <mapreduce> Oh, I got my parameter order wrong when I read the type sig for bracket.
16:24:58 <mapreduce> I would now think b would be (), and c would be anything.  Except that you just said c would be ()
16:25:27 <dons> b would also be ()
16:25:35 <dons> a would be the resource itself
16:26:05 <mapreduce> So it's unusual to use the result of bracket for anything?
16:27:08 <EvilTerran> ?hoogle bracket
16:27:09 <lambdabot> Control.Exception.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
16:27:09 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
16:27:09 <lambdabot> Control.Exception.bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
16:27:14 <dons> well, no, 'c' would sometimes be the  result you care about
16:27:21 <dons> for example, the file contents
16:28:05 <Pseudonym> Generally speaking, you use monads when you care about the result of the computation.
16:28:19 <Pseudonym> If you don't, then you don't need the full power of monads.
16:29:37 <chessguy> @type mplus
16:29:39 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
16:29:45 <mapreduce> How do you know whether the action you gave to bracket (a -> IO c) worked?
16:29:51 <mapreduce> s/worked/happened/
16:30:02 <Itkovian> Hi gang. Any chance of seeing a HaXR that uses the latest HaXml stuff?
16:30:22 <dmwit> mapreduce: You don't get an exception if it worked.
16:30:42 <chessguy> conal: ping?
16:30:48 <chessguy> @seen conal
16:30:49 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 4h 43m 36s ago.
16:31:17 <atp> sigh, proggit is turning into the rest of reddit
16:31:22 <atp> or slashdot
16:31:34 <roconnor> atp: I was thinking that today
16:31:41 <mapreduce> Are exceptions typed as strongly as monads?
16:31:49 <roconnor> atp: that it is usenet all over again.
16:31:49 <dmwit> ?hoogle IOException
16:31:50 <lambdabot> Control.Exception.IOException :: IOException -> Exception
16:31:50 <lambdabot> Control.Exception.IOException :: data IOException
16:32:00 <roconnor> atp: except this time stupid comments bubble to the top
16:32:00 <atp> roconnor: yeah.  the september that never ends...
16:32:16 <dmwit> mapreduce: Of course. =0
16:32:21 <dmwit> s/0/)/
16:32:27 <atp> the worst thing is, there seems to be a decided anti-intellectual bent among moderators
16:32:47 <dibblego> atp, are you referring to the other users as the moderators?
16:32:47 <roconnor> atp: moderators?
16:32:55 <atp> yep
16:33:04 <atp> the plebian masses, if you prefer :)
16:33:06 <dons> there's definitely a move from 1 year ago
16:33:08 <mapreduce> Is there a version of bracket that doesn't expose exceptions, e.g., by using Maybe or Either to tell you about errors instead?
16:33:14 <dons> pdfs were regularly at the top
16:33:23 <dons> mapreduce: no, but you can write that yourself
16:33:24 <dibblego> yes, the general definition of a programmer is also an anti-intellectual
16:33:29 <mapreduce> dmwit: So why have both exceptions and monads?
16:33:34 <roconnor> atp: I'm a bit surprised that there is more of them than us in proggit.
16:33:37 <dons> mapreduce: via handle or catch
16:33:46 <roconnor> atp: so much for humanity.
16:33:46 <Pseudonym> If you want intellectual, keep coming here.
16:33:52 <atp> yeah, i used to get lots of interesting functional programming news on reddit
16:33:53 <Pseudonym> We're so bloody intellectual we hurt our own brains.
16:33:54 <dmwit> mapreduce: I don't know. =/
16:34:01 <roconnor> Pseudonym: I fear it is just a matter of time for #haskell
16:34:05 <dmwit> mapreduce: I really wish somebody would just decree one of them to be the standard.
16:34:08 --- mode: ChanServ set +o Pseudonym
16:34:11 <dibblego> let's keep #haskell open to curious minds
16:34:14 <Pseudonym> roconnor: Say that again.
16:34:19 <Pseudonym> I dare you.
16:34:19 <roconnor> Pseudonym: I fear it is just a matter of time for #haskell
16:34:23 --- mode: ChanServ set -o Pseudonym
16:34:26 <Pseudonym> Nah, too scared to.
16:34:31 <atp> the only problem with irc is that i can't waste time learning stuff on irc at work
16:34:31 <kiris> say `what' one more time
16:34:34 <atp> reddit was good for that :)
16:34:35 <roconnor> Pseudonym: :)
16:34:38 <dons> aggressively down mod bad stuff, and upmod good stuff
16:34:50 <Pseudonym> Seriously, we're pretty good at keeping the tone up here.
16:34:58 <atp> that interesting series on kan extensions on comonad.com?  no love
16:34:58 <roconnor> atp: I learn stuff on irc at work.
16:35:01 <dmwit> mapreduce: There are a dozen different ways of reporting errors, and none of them are really interchangeable. =/
16:35:02 <roconnor> atp: for work even.
16:35:08 <atp> you're lucky :/
16:35:11 <Pseudonym> LtU has maintained itself pretty well.
16:35:17 <atp> yeah, LtU is pretty good.
16:35:18 <Pseudonym> It's lower bandwidth than many would like, though.
16:35:21 <atp> yeah.
16:35:24 <atp> that's the main issue, really.
16:35:25 <mar77a> math question: lim n->inf An = 0, lim n->inf Bn = +inf, lim n->inf An/Bn = ?
16:35:26 <mapreduce> dmwit: Well, outside of Haskell, is there any reason to have both?
16:35:28 <roconnor> Pseudonym: perhaps we have good moderators here.  Maybe that will save #haskell.
16:35:42 <Dzlk> LtU's moderators are very good.
16:36:03 <byorgey> mar77a: it depends.
16:36:05 <vixey> other than letting that "History of Logic Programming" rubbish through
16:36:15 <mar77a> byorgey: indetermined form?
16:36:18 <byorgey> mar77a: it could be 0, or +inf, or anything in between.
16:36:21 <dmwit> mar77a: 0, always
16:36:27 <dmwit> byorgey: What are you talking about?
16:36:27 <byorgey> mar77a: exactly.  try using L'Hopital's rule
16:36:29 <wagle> whats wrong with #haskell (not finding the original of that thread of conversation in the scrollback)
16:36:34 <mar77a> well it's a multiple choice
16:36:39 <byorgey> oh! haha
16:36:39 <mar77a> very similar to that i just wrote
16:36:47 <mar77a> don't have An or Bn :p
16:36:51 <mar77a> where can i find
16:36:55 <mar77a> ALL indetermined forms
16:37:06 <chessguy> the term is 'indeterminate'
16:37:14 <byorgey> it's 0/inf
16:37:19 <byorgey> not inf/0
16:37:29 <rizzix> hmm 0/inf is indeterminate?
16:37:35 <dmwit> no
16:37:38 <mar77a> it's not 0/inf
16:37:39 <byorgey> no, I am on crack
16:37:41 <mar77a> it's ->0/->inf
16:37:46 <mar77a> 0/anything is 0
16:37:52 <mar77a> cept 0 :)
16:37:54 <rizzix> 1/inf = 0
16:38:00 <rizzix> -> 0 mb
16:38:07 <atp> mar77a: you can't make a generalization about those sequences
16:38:21 <mar77a> i'll take byorgey's words
16:38:22 <atp> it depends on how fast they converge and diverge
16:38:28 <mar77a> that's what i thought
16:38:43 <atp> this is why we have d/e proofs :)
16:38:48 <mar77a> d/e?
16:38:52 <atp> delta/epsilon
16:38:57 <mar77a> rrr
16:39:11 <ddarius> wagle: #haskell is an online community
16:39:17 <dmwit> oh... it may actually be indeterminate.
16:39:37 <dmwit> mar77a: Do you have something like lim n->inf An = +0?
16:39:48 <roconnor> wagle: nothing is wrong with #haskell ... yet
16:39:53 <dmwit> Bah, never mind me.
16:40:12 <Saizan> eh? 0/Inf -> 0*1/Inf -> 0*0
16:40:18 * dmwit returns to his previous stance: it's 0, always.
16:40:31 <roconnor> > 0/(0/0)
16:40:32 <lambdabot>  NaN
16:40:37 <roconnor> > 0/(1/0)
16:40:38 <lambdabot>  0.0
16:40:43 * Saizan supports dmwit 
16:41:13 <roconnor> > 0/(-1/0)
16:41:14 <lambdabot>  -0.0
16:41:58 <roconnor> > -0
16:41:59 <lambdabot>  0
16:42:06 <roconnor> > -0.0
16:42:07 <lambdabot>  -0.0
16:42:08 <ddarius> dmwit is undefined for values outside of Saizan
16:43:03 <wagle> roconnor, why might there be a problem?
16:43:05 <atp> man it's a beautiful day today
16:43:14 <ddarius> atp: Go for a walk.
16:43:34 <atp> ddarius: can't, gf is taking a shower, she'd kill me if i just left... but i sure would like to :)
16:43:34 <ddarius> wagle: Because there is more of them than there are of us.
16:43:49 <wagle> ddarius, "them"?
16:43:49 <roconnor> wagle: because every other (programming?) channel in the history of mankinds has gone that way.
16:44:04 <ddarius> atp: Go finish the shower with your girlfriend and then you two together go take a walk.
16:44:05 <roconnor> because of what ddarius said
16:44:05 <atp> the lisp folks keep theirs clean, but at too high a price
16:44:24 <vixey> roconnor: scheme and prolog are fine
16:44:33 <roconnor> vixey: really?
16:44:36 <ddarius> "Avoid success at all costs."
16:44:47 <vixey> I like them
16:45:11 <Saizan> we just need a more obscure language when this real world haskell is on sale
16:45:28 <ddarius> Saizan: We have several.
16:45:31 <vixey> how about Erlang!
16:45:32 <vixey> :p
16:45:44 <Dzlk> disciple?
16:45:54 <atp> we just need a total dialect of haskell with a meaningful data/codata distinction built into the type system
16:46:00 <Saizan> ddarius: with a channel?
16:46:02 <vixey> atp: Coq
16:46:06 <atp> that'll keep'em at bay
16:46:18 <ddarius> Saizan: Probably.  If not, it's easy enough to make a channel.
16:46:42 <atp> vixey: hm, would you really describe coq that way?
16:46:46 <roconnor> Epigram or Agda
16:46:52 <vixey> atp: no not at all
16:46:57 <atp> vixey: me neither :)
16:47:16 <hpaste>  chessguy pasted "I know there's an uncurry hiding in here somewhere..." at http://hpaste.org/7928
16:47:34 <Dzlk> All we'd need then is an X window manager that uses Coq proofs for configuration.
16:47:43 <Bonus> how do you use let within do syntax
16:47:50 <vixey> do foo
16:47:53 <vixey>    let x = 3
16:47:55 <vixey>    bar
16:48:01 <atp> bar x
16:48:01 <Bonus> no in?
16:48:03 <atp> :P
16:48:04 <atp> no in
16:48:07 <Bonus> ah
16:48:10 <Bonus> cause i tried
16:48:12 <atp> of course you can do
16:48:20 <atp> let x = 3 in do ...
16:48:33 <Bonus> what if i have multiple variables to let
16:48:39 <atp> indent them
16:48:41 <Bonus> just on the same column as x?
16:48:41 <vixey> Bonus: that's fineo
16:48:45 <atp> yep
16:48:46 <Bonus> aha kewl
16:48:48 <Bonus> yeah i was using
16:48:53 <Bonus> do foo
16:48:58 <Bonus>    let blah = 3
16:49:02 <Bonus>        htt = 3
16:49:07 <Itkovian> re: the channel, all I can say is that since I stopped visiting here a while ago, the level/complexity of the topics discussed has risen the last time I checked in here.
16:49:08 <Bonus>    in print something
16:49:14 <Bonus> and it whined at me
16:49:17 <Elly> yeah
16:49:18 <atp> yeah, that doesn't wokr
16:49:22 <atp> work.
16:49:33 <Elly> as a frequent visitor to other languages' channels, this one is consistently the best :)
16:49:51 <Pseudonym> You all suX0rz!
16:49:52 <Bonus> haskell owns
16:49:56 <dons> Itkovian: that's interesting.
16:50:07 <atp> as haskell becomes more mainstream (a good thing, of course), that will change, i fear
16:50:13 <dons> you think the quality/level of discussion has improved?
16:50:29 <atp> i think it depends on the day
16:50:45 <Pseudonym> Actually, I don't think that ##C++ has necessarily become worse over time.
16:50:58 <atp> yesterday ddarius and someone.. edwardk?  were talking about kan extensions, which was pretty neat
16:50:59 <Itkovian> dons: well, I know I could not follow a lot of things, yet when I first dropped in, I could explain or at least follow almost everything
16:51:01 <Pseudonym> Even though there's a theory-heavy elite in the C++ community.
16:51:08 <Pseudonym> And a popular pleb group.
16:51:19 <dons> Itkovian: we have a comonadic reactionary faction now
16:51:20 <wagle> yeah, i hang out here for the intellectual stimulation
16:51:21 <dons> :)
16:51:46 <atp> we need to keep the hardcore CS on this channel
16:51:52 * Itkovian picks up his dictionary
16:51:54 <dons> but yeah, we got bored with monads several years ago
16:51:59 <Pseudonym> Surely functional reactions are best modelled with arrows?
16:52:09 <ddarius> It's rare for there to be particularly hardcore CS on this channel.
16:52:15 <Pseudonym> dons: You wait until someone comes up with a good syntax for arrow calculus.
16:52:19 <dons> heh
16:52:32 <Pseudonym> Seriously.  I give it three months at the most.
16:52:36 <dons> ddarius: i agree. we also get booed at if the code goes into low level stuff too much
16:52:38 <atp> arrows are less sexy than applicative functors, monads, comonads, etc, imho
16:52:42 <atp> i don't really know why
16:52:44 <dons> at least, its happeend to me sometimes.
16:52:45 <atp> they just turn me on less
16:52:48 <Pseudonym> atp: It's the syntax.
16:52:52 <Dzlk> (I'm not even a frequent visitor to other language channels. I'm here because I kept seeing #haskell logs in google results and being impressed by the level of the conversation.)
16:52:55 <Pseudonym> Hence my remarks about arrow calculus.
16:53:17 <Pseudonym> Nobody really likes programming in pointless style.  I'm convinced of this.
16:53:24 <atp> Pseudonym: but comonads don't have a nice syntax... and let's face it, they're not particularly useful... and yet they're much more sexy than arrows
16:53:28 <vixey> I like it
16:53:33 <vixey> only when it's easy though
16:53:34 <Dzlk> Me too.
16:53:38 <atp> pointfree is nice.
16:53:39 <Dzlk> On both. ;)
16:53:39 <Pseudonym> atp: See my earlier remarks about arrow calculus.
16:53:48 <ddarius> Dzlk: What are you searching for that leads to #haskell logs being high hits?
16:53:53 <wagle> s/pointless/triathalon/  ?
16:53:57 <dons> we dont' even have a comonad package on hackage , do we?
16:53:59 <Pseudonym> I think that in the very near future, we'll be using W a -> M b a lot.
16:54:09 <atp> dons: i don't think so.  mostly i just define the class myself in my code
16:54:18 <ddarius> Pseudonym: That'd be nice.
16:54:22 <dons> edwinb: could you upload http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
16:54:25 <dons> or a variant thereof?
16:54:28 <Saizan> dons: category-extras
16:54:37 <dons> unfortunate name
16:54:38 <vixey> I think that's edwardk's stuff
16:54:40 <Saizan> has comonads and much more
16:54:41 <dons> co-mtl
16:54:42 <Pseudonym> A number of new libraries seem to be implicitly comonadic, even if they're not explicitly so.
16:54:42 <dons> :)
16:55:03 <atp> have we all decided on haskell names for counit and cobind yet?
16:55:07 <Pseudonym> Generally speaking, things are monadic if they're bottom-up state-transforming and comonadic if they're environment-like.
16:55:09 <dons> that'll do, http://hackage.haskell.org/packages/archive/category-extras/0.52.0/doc/html/Control-Comonad.html
16:55:10 <lambdabot> http://tinyurl.com/58qhck
16:55:11 <Pseudonym> top-down
16:55:27 <Pseudonym> So, for example, arrays are monadic, but random number generation is comonadic.
16:55:39 <Dzlk> ddarius: I don't really recall specifically. Sometimes if I'm stuck on a certain error I'll google it, that probably accounts for most of them.
16:55:40 <atp> also, has the referential transparency issue in the OI comonad ever been resolved?
16:55:53 <hpaste>  dmwit annotated "I know there's an uncurry hiding in here somewhere..." with "like this?" at http://hpaste.org/7928#a1
16:55:54 <Pseudonym> atp: Not to anyone's satisfaction.
16:56:00 <Pseudonym> Dick Kieburtz never got back to me.
16:56:01 <atp> not that it matters, of course
16:56:07 <atp> Pseudonym: oh, that was you?
16:56:10 <atp> hehe
16:56:10 <Pseudonym> Yeah.
16:56:14 <atp> didn't know that
16:56:15 <kiris> import Blogging -- lolol am I xkcd yet? P.S. use Haskell! importing a module only takes one line of code!!1
16:56:16 <dmwit> :t uncurry
16:56:18 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
16:56:26 * Pseudonym has selective underground fame
16:56:32 <wagle> the problem with pointless code for me is that i want to mix it with pointed code, and the mix seems ugly
16:57:12 <Pseudonym> And where is FLM then, hmm?  shapr?
16:57:28 <dmwit> ?pl \c -> uncurry (createTests c) . parseEPD
16:57:28 <lambdabot> (. parseEPD) . uncurry . createTests
16:58:21 <ddarius> Pseudonym does have selective underground fame.
16:58:21 <chessguy> dmwit: i just tried that
16:59:39 <chessguy> dmwit: this types correctly, i know that much: fenToTest fen = \c -> uncurry (createTests c) (parseEPD fen)
17:00:03 <dmwit> Yep, did you see my annotation?
17:02:14 <chessguy> ah, now i did
17:02:26 <chessguy> not sure what you mean about a "flip'd" version
17:02:38 <dmwit> That one types correctly, but the usage is different.
17:02:44 <dmwit> fenToTest' = flip fenToTest
17:02:48 <edwardk> @seen ddarius
17:02:48 <lambdabot> ddarius is in #haskell, #haskell-blah, #haskell-overflow and #haskell-soc. I last heard ddarius speak 4m 27s ago.
17:02:52 <chessguy> oh, ok
17:02:57 <chessguy> yeah, i need the type signature i gave
17:02:59 <edwardk> oh heh
17:03:13 <dmwit> chessguy: Well, you could always
17:03:21 <chessguy> @pl fenToTest fen c = uncurry (createTests c) $ parseEPD fen
17:03:21 <lambdabot> fenToTest = flip (uncurry . createTests) . parseEPD
17:03:26 <dmwit> err, never mind
17:03:32 <edwardk> ddarius: do you know of any sort of well known connection between f -| g and Cofree f -| Free g or Free f -| Cofree g ?
17:04:27 <chessguy> dmwit: i could always let @pl solve the whole mess for me :)
17:04:33 <dmwit> yep =)
17:04:51 <chessguy> such lovely pain :)
17:05:02 <chessguy> now there's an elevator pitch for haskell
17:05:27 <dmwit> "good automated tools"?
17:05:41 <dmwit> djinn, pl, hoogle, etc.
17:05:42 <chessguy> "lovely pain" :)
17:05:45 <dmwit> oh =)
17:06:24 <ddarius> edwardk: You may want to look at "Category Theory as Coherently Constructive Lattice Theory"
17:06:25 <dolio> Pseudonym: All those concatenative people seem to disagree with you about pointlessness.
17:06:34 <ddarius> @google "Category Theory as Coherently Constructive Lattice Theory"
17:06:36 <lambdabot> http://citeseer.ist.psu.edu/269479.html
17:06:36 <lambdabot> Title: Category Theory as Coherently Constructive Lattice Theory - Backhouse, Bijsterve ...
17:06:48 <edwardk> will do
17:07:52 <ddarius> dolio: And they are nut jobs.  Every. Last. One. Of. Them.
17:08:07 * edwardk sometimes wonders if ddarius just randomly googles category theory, jumps to page 12 and then hands me the link ;)
17:08:13 <MyCatVerbs> ddarius: that sounds a bit... mean. Why do you say that?
17:08:25 <dolio> Heh.
17:08:37 <edwardk> looks like a good link though
17:09:27 <ddarius> MyCatVerbs: As discussed on #haskell-blah, it's because I'm a heartless bastard who cares nothing for the potential emotional harm I may cause to others.  And because I'm very rarely serious.
17:09:45 * ddarius was the person who implemented a joy intepreter in a lambda calculus interpreter in lambdabot.
17:10:11 <ivanm> using lambdabot's haskell interpreter?
17:10:11 <edwardk> ddarius: the concatenative languages folks?
17:10:16 <vixey> oh my,...
17:10:24 <ddarius> ivanm: That didn't exist at the time.
17:10:27 <vixey> that's terrific
17:10:57 <ivanm> heh
17:11:08 <vixey> ddarius: do you have any code/repo online?
17:11:12 <ddarius> edwardk: If I understand your question right, "they" does equal the concatenative folks.
17:11:12 <ivanm> so, which interpreter did you implement using joy?
17:11:20 <MyCatVerbs> ddarius: fair enough, but I'm not interested in that. What I'm curious about is why you think they're crazy.
17:11:22 <vixey> I want to track any linear logic stuff that happens :p
17:11:41 <ddarius> MyCatVerbs: I don't I was just being dramatic.
17:11:52 <edwardk> ddarius: ok, then i concur ;)
17:12:00 <MyCatVerbs> Oh right, sorry, I totally missed the silliness.
17:12:11 * MyCatVerbs throws a cookie at ddarius' head by way of apology.
17:12:30 <chessguy> FOOD FIGHT!!!!
17:12:31 * ddarius falls to the ground clutching his eye and rolling about.
17:12:48 <MyCatVerbs> \o/ direct hit for maximum frendship points!
17:12:49 <ddarius> vixey: It may happen as the lollimon interpreter is more of a toy than I was hoping.
17:13:22 * MyCatVerbs launches an au gratin potato at chessguy's centre of mass.
17:13:42 <vixey> cool :D
17:13:46 <lament> luckily for chessguy, his centre of mass is outside of him!
17:13:54 <jsnx> that gratin will kill...
17:13:54 <vixey> I read about lolli and some things on pfennings site
17:13:57 <chessguy> i'm a very convex guy :)
17:14:58 <ddarius> ivanm: To answer your question, I was very limited to what I could do by IRC line lengths.
17:15:31 <MyCatVerbs> ddarius: ahahhaha, 512 character limit. I take it the first step always involved a bunch of single-character combinators? ;)
17:16:50 <ddarius> 512 is a lot of characters.
17:17:12 <Pseudonym> It's half a screenful at 40x25.
17:18:30 <Itkovian> until next time. which will be soon, I think.
17:19:25 * dcoutts fires off a job to try to construct an install plan for each package on hackage individually
17:19:54 <dcoutts> as distinct from simultaneously, which is a good deal harder
17:20:03 <MyCatVerbs> ddarius: well, 512 minus roughly or so for "PRIVMSG lambdabot :" overhead.
17:20:22 <edwardk> ddarius: in any event the reason I asked about the adjunction bit was I was able to show that my 'zapWith' combinator from a few posts ago could be defined in terms of an adjunction after I noticed a bit about adjunctions and representability, but i was able to derive that 'Zap' f g => Zap (Cofree f) (Free g) and Zap (Free f) (Cofree g).
17:20:24 <MyCatVerbs> *minus roughly twenty or so, I mean.
17:20:50 <edwardk> otoh, i don't know of any theorem linking adjunctions and adjunctions over their (co)free monads.
17:20:55 <travisbrady> can anyone point me at a simple web client written in haskell?
17:21:08 <dons> client side only?
17:21:46 <dons> there's a twitter client, that uses the curl package,
17:21:47 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/twitter
17:21:49 <lambdabot> http://tinyurl.com/5lonhu
17:21:52 <travisbrady> dons: yes, i'd like to be able to post to a url and retrieve the result
17:21:54 <dons> and illustrates also json use, xml
17:21:55 <dons> et al
17:22:04 <edwardk> so if an adjunction is sufficient to represent zapWith i suppose my next question is it necessary, and if so then i have a connection between adjunctions and adjunctions of their (co)free (co)monads.
17:22:24 <edwardk> er s/question is/question is is
17:22:31 <dons> travisbrady: just use tagsoup
17:22:39 <dons> chttp://hackage.haskell.org/packages/archive/tagsoup/0.6/doc/html/Text-HTML-Download.html
17:22:40 <lambdabot> http://tinyurl.com/6xfan2
17:22:56 <dons> otherwise, check out the curl binding
17:22:57 <TomMD> Is anyone here involved in or dealing with Xen (xen.org)?  I started making FFI bindings to xen_ctrl.h but don't think I'll have time to use them.  Figured if I can convince myself that someone else would use them then I might finish.
17:23:10 <dons> TomMD: i can think of one person
17:23:13 <TomMD> (this is not to say I have gotten very far yet)
17:23:15 <travisbrady> dons: i was hoping to use something built with the basics, i can't seem to get minihttp, HTTP et al installed
17:23:28 <dons> travisbrady: HTTP is the main one to use.
17:23:30 <dons> curl also is ok.
17:23:33 <travisbrady> the twitter stuff uses Network.Curl
17:23:35 <dons> tagsoup is another optoin
17:23:45 <TomMD> dons: Yeah, I thought you would speak up.
17:23:50 <ddarius> edwardk: I remember some relatedish results in that paper or a related one, but I'll see what I can come up with on my own.
17:23:52 <travisbrady> dons: yeah, i'm not able to get any of those installed unfortunately
17:23:59 <dons> TomMD: maybe you can just release it to code.h.o?
17:24:04 <dons> travisbrady: why not?
17:24:09 <travisbrady> dons: i'd like something similar to your "roll your own irc bot"
17:24:13 <edwardk> I'm going through the section on adjunctions now
17:24:15 <dons> ah. hmm.
17:24:19 <TomMD> dons: That would be the plan upon completion.
17:24:19 <dons> there is probably a tut floating around
17:24:29 <dons> TomMD: well, a repo could go up prior to completion?
17:25:04 <edwardk> zapWith :: Adjunction f g => (a -> b -> c) -> f a -> g b -> c; zapWith f a b = uncurry (flip f) . counit . fmap (uncurry (flip strength)) $ strength a b --- was the forward connection I was able to come up with to establish sufficiency
17:25:05 <travisbrady> dons: in trying to install HTTP-3001.0.4 i get "Setup.lhs: Error: Could not find module: Network.Stream with any suffix: ["hi"]"
17:25:14 <TomMD> This requires me to re-acquire access to community.h.o, but I'll need to do that anyway.
17:25:19 <dons> are you using cabal-install to resolve dependencies, travisbrady ?
17:25:22 <edwardk> which i thought was a nifty use of an adjunction in a category where every functor is strong.
17:25:31 <dons> if not, you have to collect the deps by hand, by looking in the .cabal file
17:25:39 <dcoutts> that's not a dep error
17:25:40 <dons> hackage.haskell.org lists all the deps
17:25:52 <edwardk> otoh, the use of strength there tells me this probably only holds in general for traversable (costrong) functors in Haskell.
17:25:52 <dons> oh, is Network.Stream a package error?
17:26:03 <edwardk> for the reverse
17:26:22 <travisbrady> dons: i suppose i'm not since i'm just trying to do "runhaskell Setup.hs install"
17:26:31 <dcoutts> travisbrady: you need to build first
17:26:43 <dcoutts> before you can install
17:26:50 <dons> http://www.haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
17:26:51 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki, http://tinyurl.com/2ack74
17:28:43 <travisbrady> dcoutts and dons: thank you
17:30:13 <dcoutts> woo!
17:30:35 <dcoutts> out of 573 hackage packages, my new dep resolver can make install plans for all but 12 of them
17:31:12 <edwardk> btw- thanks for the link, its quite readable
17:31:25 <chessguy> what's wrong with the other 12?
17:31:26 <dons> dcoutts: awesome. what are the last 12?
17:31:35 <dcoutts> dons: just checking...
17:31:46 <dons> 573 is up on recent numbers
17:31:48 <dcoutts> some are ones where it's a genuine failure, eg deps on non-existant packages
17:31:58 <dons> i hope someone notices when we hit 1000 haskell packages
17:32:13 <dons> the number is big enough it should be listed on hackage itself.
17:32:35 * kiris makes a hackage package to monitor the number of hackage packages
17:32:39 <dcoutts> there are well over 1000 if you count different versions of the same package
17:32:42 <dons> great, kiris
17:32:56 <dcoutts> dons: tags are a problem for two packages
17:33:08 <dcoutts> gnutls and a package that deps on that
17:33:45 <dcoutts> we do not know how to order packages with tags wrt others of the same version, so we just ignore such packages completely atm
17:34:09 <dcoutts> a couple are due to not using a sensible ordering when making choices
17:34:30 <dcoutts> eg in one case we decide to make a choice for the QuickCheck package
17:34:41 <dcoutts> and pick version 2 and later discover we really needed version 1
17:35:20 <dcoutts> so we should make the decision in the other order, if A depends (indirectly) on B then pick A first
17:35:42 <dcoutts> dons: hackage2hwn is still borked
17:35:51 <dcoutts> cannot configure hackage2hwn-0.2.1. It requires xml ==1.2.3
17:35:51 <dcoutts> There is no available version of xml that satisfies ==1.2.3
17:36:49 <dons> dcoutts: ok. i'll upload a new version
17:37:08 <dons> and is it yet impossible to upload things whose real deps aren't on hackage? :)
17:37:40 <dcoutts> dons: we can't do that yet because of some packages that are not yet cabalised, like gtk2hs
17:37:53 <dons> ah yes.
17:37:57 <dons> slacker maintainers
17:37:59 <dcoutts> and the ghc package and base are also funny exceptions
17:38:12 <dcoutts> dons: ;-)
17:38:31 <dcoutts> but we should start enforcing it
17:38:31 <dons> great work though. we'll see this in 6.10's release?
17:38:40 <dcoutts> sooner hopefully
17:39:00 <vixey> hmm
17:39:01 <dons> and the plan is to have cabal-install come with ghc 6.10
17:39:03 <dcoutts> every package should have an install plan on at least one major platform
17:39:03 <dons> ?
17:39:31 <dcoutts> dons: well, as part of the platform at any rate if not with ghc itself. Remember ghc releases are getting smaller
17:39:40 <dons> yep, fair enough
17:39:52 <dcoutts> so we need to start planning platform releases
17:40:07 <dcoutts> deciding what should go in
17:43:20 <tchakkazulu> Are there any specific invariants or laws for instances of MonadState and MonadWriter?
17:43:31 <tchakkazulu> Like the monad laws for instances of Monad.
17:44:44 <dmwit> Probably nothing formally agreed upon.
17:44:47 <TSC> I guess if you "put" a value and then "get" it, you should get the same value back.
17:44:49 <dmwit> I would guess some things like
17:45:00 <dmwit> put s >> get === put s >> return s
17:45:00 <roconnor> Ha
17:45:01 <mar77a> another math q: why is 1^inf indeterminate?
17:45:03 <roconnor> Those who would give up essential type safety, to purchase a little
17:45:03 <roconnor> temporary liberty, deserve neither liberty nor type safety.
17:45:06 <mar77a> byorgey? :)
17:45:30 <dmwit> mar77a: Because 1.001^something big /= 1.
17:45:44 <mar77a> ...?
17:45:47 <roconnor> quote from dons
17:45:47 <mar77a> it's 1 not ->1
17:45:55 <mar77a> wait
17:45:56 <mar77a> it's not 1
17:45:58 <mar77a> it's ->1
17:46:01 <mar77a> hmmmm
17:46:03 * dmwit winks
17:46:18 <tchakkazulu> dmwit: Okay, that makes sense.
17:46:24 <mar77a> ty
17:46:31 <mar77a> dmwit++
17:46:32 <mar77a> ;)
17:47:10 <tchakkazulu> dmwit: And for MonadWriter, you'd have to do something with listen (tell w).
17:47:30 <tchakkazulu> Should be of type m ((),w), would return ((),w) do it?
17:47:35 <dmwit> Yeah, I'm trying to imagine what the right law would be.
17:48:17 <TSC> Also for MonadState, repeated successive calls to get should give the same value every time
17:49:10 <tchakkazulu> TSC: Good one, thanks :)
17:49:43 <tchakkazulu> I'm writing a library for shared state/writer monads over multiple threads.
17:50:19 <tchakkazulu> Now I think I've got the implementation right, but I'm not sure if the laws hold.
17:50:40 <tchakkazulu> (Of course, concurrency adds a load of nondeterminism, but first try to get it right without any of the forked stuff ;))
17:50:49 <dibblego> ?hoogle (a -> Bool) -> [a] -> Bool
17:50:50 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
17:50:50 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
17:50:50 <lambdabot> Data.List.any :: (a -> Bool) -> [a] -> Bool
17:58:13 <tchakkazulu> listen (tell w) == tell w >> return ((),w)
17:58:18 <tchakkazulu> Seems like that would work.
17:59:46 <malebria> Wouldn't it be good to include stockId options in gtk2hs documentation?
18:00:14 <dcoutts> malebria: the list is in the gtk+ docs along with the pictures
18:01:25 <malebria> dcoutts: Sorry, I found it now.  I didn't saw it because in buttonNewFromStock, the first parameter is a String, and not a StockId.
18:03:24 <malebria> http://www.haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-General-StockItems.html There's something wrong with the images..
18:03:25 <lambdabot> http://tinyurl.com/5tee2o
18:04:08 <dcoutts> malebria: mm, so there is
18:04:25 <dcoutts> malebria: check the gtk+ docs
18:05:57 <malebria> dcoutts: Shouldn't buttonNewFromStock has StockId as a parameter?
18:06:37 <dcoutts> malebria: I'm not sure really, they have string names and one can add extra ones with string names
18:06:46 <dcoutts> malebria: file a bug if you like
18:12:08 <malebria> dcoutts: what about these broken links for images in haddock?
18:15:06 <dcoutts> malebria: seems the image syntax was new in 0.9 but we were using version 0.8
18:15:20 <dcoutts> @seen gwern
18:15:21 <lambdabot> I saw gwern leaving #haskell 1d 3h 34m 9s ago, and .
18:15:32 <dcoutts> seems it got removed again in 2.x
18:15:35 <dcoutts> which is odd
18:16:13 <malebria> dcoutts: Should I file a bug for this too?
18:16:36 <dcoutts> malebria: if you like, sure
18:19:21 <chessguy> heh. translation: sure, but nothing's going to be done about it any time soon :)
18:22:41 <chessguy> @quote cabal
18:22:41 <lambdabot> musasabi says: combining Cabal and autoconf is an evil and complex art.
18:23:33 <dcoutts> it might all just work next time we generate the docs since we'll be using a different version of haddock
18:29:29 <mar77a> > 1/3
18:29:32 <lambdabot>  0.3333333333333333
18:29:38 <mar77a> > 1/3 :: CReal
18:29:39 <lambdabot>  0.3333333333333333333333333333333333333333
18:29:47 <mar77a> > 1/3 :: Integral
18:29:48 <lambdabot>      Class `Integral' used as a type
18:29:48 <lambdabot>     In the type `Integral'
18:29:48 <lambdabot>     In an exp...
18:29:52 <mar77a> > 1/3 :: Int
18:29:53 <lambdabot>   add an instance declaration for (Fractional Int)
18:29:53 <lambdabot>     In the expression: 1 /...
18:29:56 <mar77a> > 1/3 :: Integer
18:29:56 <lambdabot>   add an instance declaration for (Fractional Integer)
18:29:56 <lambdabot>     In the expression:...
18:30:08 <chessguy> @quote hadd
18:30:09 <lambdabot> No quotes match. My mind is going. I can feel it.
18:30:13 <malebria> I'll go to bed now... Good night.
18:33:58 <ddarius> My pencil has gone where the woodbine twineth.
18:34:35 <chessguy> ...
18:34:41 <dons> ?users
18:34:41 <lambdabot> Maximum users seen in #haskell: 480, currently: 422 (87.9%), active: 7 (1.7%)
18:35:06 <chessguy> 480, wow
18:37:17 <[Justice]> @seen [Justice]
18:37:17 <lambdabot> You are in #haskell. I last heard you speak just now.
18:37:54 <noecksit> hello, i have a beginner question about the State monad, could u use evalState in a pure function and then preserve the purity of the function?
18:38:23 <noecksit> since it doesnt return m (a,s) as oppossed to evalStateT
18:38:37 <Zao> :t evalState
18:38:40 <lambdabot> forall s a. State s a -> s -> a
18:38:44 <Zao> Looks sound to me.
18:39:25 <noecksit> hmm, i thought that each time you call a monad, you encapsulate that function within a monad
18:39:42 <dmwit> noecksit: You should observe that for certain values of purity, State monad operations are also pure.
18:39:51 <noecksit> i remember reading it somewhere
18:39:59 <dmwit> "call a monad"?
18:40:35 <noecksit> call a "monadic" function (one that uses monads for its computations)
18:42:14 <noecksit> i guess that doesn't break the purity of the function since only the called function has state, but not the calling function
18:42:46 <chessguy> noecksit: right, the monad doesn't bleed into the type of the calling function, if that's what you're asking
18:43:17 <noecksit> chessguy : yeh
18:43:22 <ddarius> It's just a data structure, nothing magical is happening.  There is no "bleeding" or "encapsulating" or anything else.
18:43:52 <chessguy> noecksit: note that there are some monads which you can "get" the value out of, like state, and some monads which you can't, like IO
18:44:25 <chessguy> there's nothing inherently one-way about monads, the class just happens to only define one direction
18:45:02 <noecksit> chessguy : u mean, without making it a monad like in a do notation? yeah i see
18:45:20 <noecksit> such is the difference between evalState and evalStateT i think
18:45:28 <dmwit> eh?
18:45:31 <chessguy> huh?
18:45:41 <chessguy> noecksit: i think you're confused now :)
18:45:42 <dons> "bleeding" sounds curious
18:46:01 <chessguy> dons: i'm talking about IO creep
18:46:10 <chessguy> except generalized :)
18:46:22 <noecksit> well, evalStateT returns m (a,s), so in order to get access to a, you would have to turn the calling function into a monad by using do notation or >>=
18:46:51 <noecksit> or rather m a, sorry
18:46:57 <dmwit> noecksit: ...or run the enclosed monad, just like you ran the StateT monad.
18:47:36 <noecksit> but evalState return just a, so u dont need to use a do notation on the calling function
18:51:36 <noecksit> dmwit: i see what u mean, can u run any monad?
18:51:50 <dmwit> Nope, only ones that supply a function to run them.
18:52:05 <dmwit> Notably, IO cannot be "run" to get its value from a pure environment.
18:52:17 <noecksit> oh ok
18:52:38 <dmwit> I think chessguy and I are saying the same thing here.
18:52:59 <chessguy> agreed
18:53:10 <chessguy> you're just saying it much more eloquently than i :)
18:55:39 <hpaste>  dogdrool pasted "cards data definition" at http://hpaste.org/7931
18:55:54 <dogbite> how can that definition be shorted up?
18:56:12 <chessguy> by deriving Eq?
18:56:15 <vixey> doesn't deriving Eq Ord do what you want?
18:56:34 <dogbite> maybe... i didn't know
18:56:38 <atp> i think deriving Enum makes more sense
18:56:43 <dogbite> i didn't know if Ord would rank the Number Int correctly
18:56:50 <chessguy> atp: i was just thinking that
18:56:54 <vixey> I can't imagine deriving Enum getting the right walues
18:57:03 <chessguy> atp: or at least instantiating it
18:57:07 <dmwit> data Rank = Ace | Number Int | Jack | Queen | King deriving (Eq, Ord, Show, Read) -- ?
18:57:31 <atp> deriving (Enum, Show)
18:57:46 <chessguy> @src Enum
18:57:46 <lambdabot> class  Enum a   where
18:57:46 <lambdabot>     succ                     :: a -> a
18:57:46 <lambdabot>     pred                     :: a -> a
18:57:46 <lambdabot>     toEnum                   :: Int -> a
18:57:46 <lambdabot>     fromEnum                 :: a -> Int
18:57:48 <lambdabot> [3 @more lines]
18:57:51 <dmwit> I'm with vixey on Enum, write that instance yourself.
18:58:07 <chessguy> yeah, probably slo
18:58:10 <dogbite> and just derive the others?
18:58:11 <chessguy> s/l//
18:58:23 <atp> i guess that makes sense actually, if you're going to use Number like that
18:58:33 <dogbite> what's the magic behind what it will do with Number Int
18:58:48 <dmwit> dogbite: Yeah, but change the order of the constructors to match the order you want it to sort in.
18:59:13 <dmwit> (For example, maybe what I suggested above.)
18:59:18 <dogbite> so I should put Number Int first, followed by Jack
18:59:19 <dogbite> ?
18:59:20 <atp> also, dogbite, even doing this the long way,
18:59:31 <chessguy> dmwit: depends on if you want to play aces high or aces low :)
18:59:40 <atp> you don't need to define compare Jack Ace and also compare Ace Jack
18:59:46 <dmwit> chessguy: Right, hence the "maybe". =)
19:00:00 <dogbite> i don't care about low or high ace... that logic will be elsewhere
19:00:17 <dmwit> dogbite: Oh, what do you want the Ord instance for, then?
19:00:19 <dogbite> i don't need to compare Jack Ace and Ace Jack?
19:00:35 <dmwit> ?hoogle Ordering -> Ordering
19:00:35 <atp> i mean, once you've defined each pair once, you can define compare x y in terms of compare y x
19:00:35 <lambdabot> No matches, try a more general search
19:00:47 <dogbite> well I'm not sure I want it but I figured I could at least compare the Number ones easily
19:00:52 <dogbite> i might use it sometimes but not for Ace
19:01:16 <dogbite> atp: oh, okay
19:01:40 <atp> dogbite: you don't incur a penalty for that sort of definition, the compiler will optimize it away
19:02:23 <dogbite> atp: okay, gotcha
19:02:48 <atp> in this particular case though i don't think it's necessary, deriving Ord ought to work?
19:03:09 <atp> (but i'm not actually sure of that)
19:03:23 <chessguy> seems like a case for TIAS
19:03:25 <dogbite> okay, i'll give it a whirl and let you know
19:03:32 <dmwit> I'm mildly surprised there's no reverseOrdering.
19:03:42 <dmwit> ?go TIAS
19:03:44 <lambdabot> http://www.tias.com/
19:03:44 <lambdabot> Title: Antique and Collectible Mall: TIAS.com: Antiques and Collectibles
19:03:49 <chessguy> heh
19:03:56 <chessguy> @vera TIAS
19:03:57 <lambdabot> No match for "TIAS".
19:04:01 <chessguy> boo
19:04:11 <chessguy> TIAS = Try It And See
19:04:13 <dmwit> The other Google hits are not helpful, either.
19:04:19 <dmwit> ah =)
19:04:32 <dmwit> ?instances Ordering
19:04:33 <lambdabot> Couldn't find class `Ordering'. Try @instances-importing
19:04:39 <dmwit> Oh, it only goes one way.
19:04:40 <chessguy> @go TIAS acronym
19:04:41 <lambdabot> No Result Found.
19:04:59 <dmwit> Hmm, Bounded+Enum.
19:05:24 <dmwit> > map fromEnum [LT, EQ, GT]
19:05:25 <lambdabot>  [0,1,2]
19:05:43 <mar77a> > 150 / 4
19:05:45 <lambdabot>  37.5
19:06:03 <dmwit> > let reverseOrdering = toEnum . (2-) . fromEnum in map reverseOrdering [LT, EQ, GT]
19:06:04 <lambdabot>  [Exception: Prelude.Enum.().toEnum: bad argument
19:06:10 <mar77a> > 37.5 / 4
19:06:11 <chessguy> d'oh
19:06:12 <lambdabot>  9.375
19:06:18 <dmwit> > let reverseOrdering = toEnum . (2-) . fromEnum in map reverseOrdering [LT, EQ, GT] :: [Ordering]
19:06:19 <lambdabot>  [GT,EQ,LT]
19:06:33 <dmwit> Sweet, no case statement! =P
19:06:42 <atp> i think you can do it with Monoid
19:06:48 <dmwit> Oh yes?
19:06:49 <atp> iirc
19:06:51 <atp> yeah
19:06:57 <dmwit> I would be very surprised.
19:07:12 <chessguy> them's fightin' words!
19:07:15 <dmwit> ?src Monoid
19:07:15 <lambdabot> class Monoid a where
19:07:15 <lambdabot>     mempty  :: a
19:07:15 <lambdabot>     mappend :: a -> a -> a
19:07:15 <lambdabot>     mconcat :: [a] -> a
19:07:22 <dmwit> > mempty :: Ordering
19:07:23 <lambdabot>  EQ
19:07:27 <dogbite> atp: yes, deriving Ord worked.
19:07:39 <atp> dogbite: cool, thanks for letting us know.
19:08:08 <dmwit> > [(x, y, mappend x y) | x <- [LT..GT], y <- [LT..GT]]
19:08:09 <lambdabot>  Parse error at "LT..G..." (column 30)
19:08:17 <dmwit> > [(x, y, mappend x y) | x <- [LT .. GT], y <- [LT .. GT]]
19:08:18 <lambdabot>  [(LT,LT,LT),(LT,EQ,LT),(LT,GT,LT),(EQ,LT,LT),(EQ,EQ,EQ),(EQ,GT,GT),(GT,LT,GT...
19:08:30 <atp> mappend x y gives the first LT or GT in the chain
19:08:32 <saml> > succ LT
19:08:34 <lambdabot>  EQ
19:08:39 <dmwit> atp: Right.
19:08:43 <saml> > LT - EQ
19:08:44 <lambdabot>   add an instance declaration for (Num Ordering)
19:08:44 <lambdabot>     In the expression: LT - ...
19:08:52 <dmwit> > succ GT
19:08:54 <lambdabot>  Exception: Prelude.Enum.Ordering.succ: bad argument
19:09:03 <atp> i can't recall how i did this... there was an elegant way
19:09:14 <atp> it may not have been monoid, but i can't recall now.
19:09:43 <saml> > iterate succ LT
19:09:44 <lambdabot>  [LT,EQ,GT,Exception: Prelude.Enum.Ordering.succ: bad argument
19:09:55 <dmwit> > [LT..] -- the preferred way
19:09:55 <lambdabot>  Parse error at "LT..]" (column 2)
19:10:04 <dmwit> > [LT ..] -- the correct preferred way
19:10:05 <lambdabot>  [LT,EQ,GT]
19:10:06 <atp> but Monoid is really useful on an ordering
19:10:12 <dmwit> Definitely.
19:10:14 <saml> w00t it stops!
19:10:27 <saml> > [GT ..]
19:10:28 <lambdabot>  [GT]
19:10:42 <dmwit> :t lookup
19:10:44 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
19:10:55 <saml> i bet lookup is linear
19:11:01 <dmwit> It sure is!
19:11:09 <ddarius> It must be.
19:11:24 <MyCatVerbs> saml: it would be impossible to make it better, and silly to make it any worse. ;P
19:11:55 <dmwit> > let pairs xs = ap zip reverse; reverseOrdering = fromJust . flip lookup (pairs [LT ..]) in map reverseOrdering [LT ..]
19:11:55 <lambdabot>  Couldn't match expected type `[(a, b)]'
19:12:16 <ddarius> > [ compare LT x | x <- [LT ..] ]
19:12:17 <lambdabot>  [EQ,LT,LT]
19:12:24 <dmwit> oooo
19:12:41 <dmwit> > [compare x EQ | x <- [LT ..]]
19:12:42 <lambdabot>  [LT,EQ,GT]
19:12:52 <dmwit> > [compare EQ x | x <- [LT ..]]
19:12:54 <lambdabot>  [GT,EQ,LT]
19:12:56 <dmwit> pretty!
19:12:59 <ddarius> There you go.
19:13:19 <thetallguy> ﻿> [ x | x <- [LT ..]]
19:13:22 <atp> you could maybe use the Dual monad
19:13:24 <atp> monoid
19:13:26 <atp> rather
19:13:36 <atp> because the Dual of Ordering would be reversed :)
19:13:41 <ddarius> reverseOrdering = compare EQ
19:13:44 <dmwit> atp: That's okay, I'll just use (compare EQ), it can't get much prettier than that. =)
19:13:45 <chessguy> @undo do c <- r; return (s c)
19:13:45 <lambdabot> r >>= \ c -> return (s c)
19:14:01 <dmwit> fmap s c
19:14:25 <dmwit> Well, (liftM s c) if you want to be truly pedantic.
19:14:39 <chessguy> dmwit: you mean r, not c, right?
19:14:45 <dmwit> I sure do!
19:19:02 <chessguy> @bot
19:19:02 <lambdabot> :)
19:19:08 <totimkopf> aw
19:19:12 <totimkopf> such affection
19:19:56 <chessguy> @quote
19:19:57 <lambdabot> nomeata says: Haskell is basically Swiss: Small, Efficient, and it’s fun to explore the higher parts.
19:20:06 <noecksit> is there a better way to write an if statement rather than "if and [cond1,cond2] then dothis else dothat"? i mean is there some other and function where i dont have to put the conditions in a list?
19:20:34 <vixey> cond1 && cond2
19:20:58 <vixey> noecksit: You might find a tutorial or the haskell report useful
19:21:21 <vixey> also if && didn't exist you could define it very easily
19:21:28 <vixey> True && True = True
19:21:31 <vixey> _ && _ = False
19:21:40 <noecksit> yeah i know its simple, i couldnt find it in wikibooks though
19:21:41 <vixey> then just use that
19:21:45 <vixey> ?where report
19:21:45 <lambdabot> http://www.haskell.org/onlinereport/
19:21:51 <vixey> this is a good source
19:21:56 <MyCatVerbs> ?where wally
19:21:56 <lambdabot> I know nothing about wally.
19:21:58 <dmwit> ?where prelude
19:21:58 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
19:22:02 <dmwit> This is also a good source.
19:22:14 <MyCatVerbs> DAMN YOU, NOW HOW AM I SUPPOSED TO FIND THAT BLASTED STRIPEY GIT?
19:22:21 <vixey> lol
19:22:42 <vixey> that would spoil the fun
19:23:37 <chessguy> @hoogle readLine
19:23:38 <lambdabot> No matches found
19:23:46 <vixey> :t getLine
19:23:48 <lambdabot> IO String
19:23:49 <chessguy> bah
19:24:00 <MyCatVerbs> chessguy: System.Console.ReadLine.readLine :: String -> IO String, I think.
19:24:33 <dmwit> readLn :: Read a -> IO a -- ?
19:24:47 <dmwit> err.
19:24:49 <MyCatVerbs> The string it takes as a parameter is the prompt to use. e.g. readLine "c:\\> " puts up a prompt that might give a few people a nostalgia shot.
19:24:56 <dmwit> Read a => IO a -- wrong type of arrow
19:25:05 <noecksit> hah, the entire prelude source, few languages would post that on their webpage
19:25:24 <chessguy> MyCatVerbs++
19:25:29 <dmwit> noecksit: Well, that's only a specification.  The actual source is quite a lot longer. =P
19:25:46 <MyCatVerbs> chessguy: danke.
19:25:49 <chessguy> anyone that makes a DOS reference for nostalgia purposes is ok in my book :)
19:26:00 <MyCatVerbs> \o/
19:26:31 <totimkopf> MyCatVerbs, are you dutch?
19:26:35 <chessguy> hm. i can't imagine i'm the first to write something like main = forever $ getLine >>= f >>= print
19:26:45 <Elly> chessguy: yeah
19:26:47 <dmwit> :t interact
19:26:49 <lambdabot> (String -> String) -> IO ()
19:26:54 <Elly> damn you dmwit
19:26:58 <Elly> you beat me to it :P
19:27:02 <chessguy> dmwit:  read again
19:27:08 <dmwit> chessguy: I don't have to.
19:27:15 <chessguy> f isn't String -> String
19:27:20 <dmwit> Oh, bah.
19:27:24 <dmwit> I did have to. =(
19:27:26 <chessguy> i think you do :)
19:27:44 <ddarius> @where Waldo
19:27:45 <lambdabot> I know nothing about waldo.
19:28:14 <dmwit> chessguy: bracket ;-)
19:28:18 <MyCatVerbs> totimkopf: no, British.
19:28:37 <MyCatVerbs> totimkopf: I just kinda like the German language, despite knowing exceedingly little of it.
19:28:37 <ddarius> I guess you can do
19:28:40 <ddarius> @where's waldo
19:28:40 <chessguy> @hoogle bracket
19:28:40 <lambdabot> Maybe you meant: where where+
19:28:41 <lambdabot> Control.Exception.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:28:41 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
19:28:41 <lambdabot> Control.Exception.bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:28:45 <ddarius> Curses!
19:29:28 <chessguy> hrm, that doesn't look or sound right
19:29:47 <dmwit> :t bracket getLine print
19:29:48 <lambdabot> Not in scope: `bracket'
19:30:00 <dmwit> :t Control.Exception.bracket getLine print
19:30:03 <lambdabot> forall c. (String -> IO c) -> IO c
19:30:20 <dmwit> Not quite right, no.
19:30:30 * dmwit has had a lot of "not quite right" moments tonight.
19:30:40 <vixey> aww
19:31:22 * chessguy still likes dmwit for trying :)
19:34:06 <dogbite> could somebody help me understand how to make a class an instance of the Read class?
19:34:16 <dogbite> I don't understand readsPrec
19:35:05 <hpaste>  dogdrool pasted "attempt at Read instance" at http://hpaste.org/7932
19:35:26 <dogbite> clearly that didn't work because 'read' isnt' the function
19:35:27 <dolio> Yeah, you don't define read.
19:35:36 <dogbite> what is this business of taking in an Int?
19:35:37 <dolio> You define reads or readsPrec or something.
19:36:51 <dmwit> The Int is a precedence number from 1-9 (0-9?).
19:37:04 <dmwit> I don't think I've ever seen a hand-written instance that used it in a meaningful way.
19:37:14 <dmwit> But then, I don't think I've ever seen a hand-written instance of Read.
19:37:36 <dmwit> You almost certainly want to write a function that is not called Read for general parsing purposes.
19:37:48 <dolio> It's so you can read things according to the precedence when they're not fully parenthesized or something, I guess.
19:37:48 <dogbite> okay
19:37:53 <dmwit> Show/Read are supposed to be reserved for showing and reading in a Haskell-readable format.
19:37:55 <ddarius> @pl \g b f p -> (g `b` f) `b` p
19:37:56 <lambdabot> ap (.) . flip id
19:38:06 <dogbite> oh, you know now that you mentino that
19:38:13 <dogbite> i remember reading that when i first started learning haskell
19:38:20 <dogbite> thanks, i'll backtrack on that course then
19:38:24 <ddarius> @pl \g p f -> (g `b` f) `b` p
19:38:24 <lambdabot> flip . (b .) . b
19:38:28 <chessguy> @type flip id
19:38:30 <lambdabot> forall b c. b -> (b -> c) -> c
19:38:33 <dogbite> still curious about read instances but i'll defer
19:38:35 <dmwit> dogbite: I common name is "prettyPrint" or some abbreviation thereof.
19:38:49 <dmwit> (and "parse" or some variation thereof.)
19:38:57 <augur> oh hey parse?
19:39:00 <augur> parsers
19:39:01 <ddarius> @pl \g f p -> (g `b` f) `b` p
19:39:02 <lambdabot> (b .) . b
19:39:05 <augur> lemme tell you about parsers
19:39:06 <dogbite> dmwit: thanks!
19:39:08 <augur> parsers are some sexy shit
19:39:24 <chessguy> ...
19:39:29 <dmwit> augur: ...the !$#*?  Didn't you join the room after that conversation ended?
19:39:35 <augur> yes :)
19:39:42 <augur> but thats not the point, dmwit
19:39:45 <augur> i saw the word parse
19:39:48 <augur> thats all that matters
19:40:02 <dmwit> So, I take it you take Parsec on hot dates from time to time?
19:40:18 <dmwit> "MMMmm, show me how you replicateM..."
19:40:34 <dogbite> dmwit: funny
19:40:41 <dmwit> "I'll stroke your backtracking if you stroke mine."
19:40:45 <ddarius> What special relativity has to say about synchronicity seems relevant here.
19:46:23 <augur> Parsec? why thats about 3 lightyears!
19:47:12 <dmwit> ddarius: So, you're suggesting that augur is moving very quickly, relative to me?
19:47:31 <dmwit> seems reasonable
19:47:53 <roconnor> @go 1 parsec in lightyears
19:47:53 <lambdabot> http://en.wikipedia.org/wiki/Parsec
19:47:58 <roconnor> *sigh*
19:48:16 <augur> hahaha
19:48:20 <dmwit> 3.26163626
19:48:30 <dmwit> Every other digit is a 6!
19:48:32 <augur> roconnor: i think lambdabot wants you to do your own research ;)
19:49:11 <vixey> hehe
19:49:12 <roconnor> augur: lambadbot used to be more informative
19:49:49 <TomMD> @tell lambdabot bad bot, be more informative again.
19:49:49 <lambdabot> Nice try ;)
19:49:50 <augur> then it decided that its not your bitch
19:50:07 <augur> watch out, soon lambdabot will decide that humans need to be exterminated
19:50:17 <augur> you keep pushing, dmwit
19:50:22 <augur> keep pushing and you'll kill us all
19:50:34 <augur> IT KNOWS LAMBA CALCULUS, DMWIT
19:50:36 <augur> ITS UNSTOPPABLE
19:50:42 <Elly> aw man, I don't want to be exterminated :(
19:50:56 <dmwit> I, for one, welcome our new, robotic overlords.
19:51:21 <TomMD> dmwit: You are not a news anchorman
19:51:47 <mxc> augur, just calm down, all you need to do is give it a viagra...
19:51:50 * dmwit does not actually know the reference, and hence TomMD's reply is completely wasted
19:51:57 <mxc> augur: because, it can't handle the side effects
19:52:08 <dmwit> mxc++
19:52:27 <augur> hahahahaha
19:52:27 <mxc> ty
19:52:30 <augur> <3you
19:55:04 <jaj> unsafePerformIO very dangerous
19:55:20 <dmwit> yes yes
19:55:36 <dmwit> Only to be used if your first name is Simon. =)
19:56:02 <chessguy> @hoogle intercalate
19:56:02 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
19:56:02 <lambdabot> Data.ByteString.intercalate :: ByteString -> [ByteString] -> ByteString
19:56:02 <lambdabot> Data.ByteString.Char8.intercalate :: ByteString -> [ByteString] -> ByteString
19:56:04 <araujo> and the last name The Sorcerer
19:56:11 <jaj> not to be used when your first name is lambdabot and you have bad objectives concerning realWorld#
19:56:13 <chessguy> @hoogle interweave
19:56:14 <lambdabot> No matches found
19:56:31 <jaj> @hoogle fire
19:56:32 <lambdabot> No matches found
19:56:35 <chessguy> hm
19:57:01 <chessguy> what's the function to take turns taking items from two different lists
19:57:25 <chessguy> e.g., f [1,1..] [2,2..] = [1,2,1,2,...]
19:57:30 <dmwit> ?quote monochrom unsafePerformIO
19:57:30 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice.  Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.
19:57:31 <lambdabot> Licence to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
19:58:23 <jaj> oh yeah
19:58:26 <dmwit> > join $ zipWith (\x y -> [x, y]) [1,1..] [2,2..]
19:58:28 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
19:58:39 <dmwit> s/join/concat/ is probably more readable
19:59:01 <dmwit> ?hoogle [a] -> [a] -> [a]
19:59:01 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
19:59:01 <lambdabot> Data.List.(++) :: [a] -> [a] -> [a]
19:59:01 <lambdabot> Data.List.deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
19:59:10 <chessguy> @hoogle+
19:59:11 <lambdabot> Data.List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
19:59:11 <lambdabot> Data.List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
19:59:11 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
19:59:34 <vixey> > transpose [repeat 1 , repeat 2] -- is a nice way to do it as well
19:59:35 <lambdabot>  [[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,...
19:59:37 <vixey> oops
19:59:43 <vixey> concat .*
19:59:50 <chessguy> @type concat . transpose
19:59:51 <lambdabot> forall a. [[a]] -> [a]
20:00:18 <dmwit> vixey: Oh, I like that.
20:00:41 <vixey> @let (x:xs)`interleave`(y:ys) = x:y:(xs`interleave`ys)
20:00:42 <lambdabot> Defined.
20:00:47 <dmwit> :t \xs ys -> concat (transpose [xs, ys])
20:00:49 <lambdabot> forall a. [a] -> [a] -> [a]
20:00:49 <vixey> > repeat 1 `interleave` repeat 2
20:00:50 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
20:01:20 <chessguy> @pl \x y -> concat (transpose [x,y])
20:01:21 <lambdabot> ((join . transpose) .) . (. return) . (:)
20:01:27 <chessguy> heh
20:01:34 <dolio> > [] interleave []
20:01:35 <lambdabot>  Couldn't match expected type `([t1] -> [t1] -> [t1]) -> [a] -> t'
20:01:39 <dolio> > [] `interleave` []
20:01:40 <lambdabot>  Exception: <local>:2:0-48: Non-exhaustive patterns in function interleave
20:01:45 * dmwit is horrified to realize he can actually read that
20:01:56 <augur> uh oh
20:01:59 <augur> watch out dmwit
20:02:10 <dmwit> I need to learn a new language, STAT!
20:02:20 <mxc> cobol?
20:02:22 <vixey> dmwit: ocaml :p
20:02:31 <dmwit> vixey: Too similar.
20:02:32 <augur> prolog!
20:02:38 <dmwit> I'm thinking smalltalk, prolog, or erlang.
20:02:43 <vixey> (I just started ocaml)
20:02:50 <augur> prolog is sexy
20:02:51 <vixey> (I am implementing Prolog in it :P)
20:02:54 <mxc> dmwit - just think about it, if you get good at Cobol, then everytime they reference 'the lords of cobol' on battlestar, they'll be talking about you!
20:03:08 <dmwit> huh
20:03:11 <dmwit> *heh
20:03:15 <mxc> since everyone else that knows it is dead
20:03:19 <vixey> dmwit: well Art of Prolog or Craft of Prolog are some great booxs
20:03:37 <dmwit> Oooh, a fellow Dvorak-er.
20:03:43 <vixey> dmwit: oh! and The Reasoned Schemer if you are interested in Logic programming
20:03:46 <augur> hahaha
20:03:48 <augur> mxc
20:03:50 <augur> stop please
20:03:51 <augur> lol
20:03:56 <vixey> yeah a rubbish one :p
20:04:06 <dmwit> Typos can be very telling. =)
20:04:16 <jaj> us.dvorak.swapctrlcaps
20:04:44 <chessguy> i'm surprised there's not a standard version of interleave
20:05:12 <vixey> > [1,2,3]`mplus`[4,5,6]
20:05:13 <lambdabot>  [1,2,3,4,5,6]
20:05:21 <vixey> well mplus is unfair
20:06:17 <dolio> interleave is in logict.
20:06:20 <chessguy> @type \x y -> x:[y]
20:06:22 <dolio> Even for [].
20:06:22 <lambdabot> forall a. a -> a -> [a]
20:06:50 <chessguy> @pl \x y -> x:[y]
20:06:50 <lambdabot> (. return) . (:)
20:07:31 <chessguy> @type concat . zipWith ((. return) . (:))
20:07:33 <lambdabot>     Couldn't match expected type `[[a]]'
20:07:33 <lambdabot>            against inferred type `[a1] -> [[a1]]'
20:07:33 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
20:08:15 <dmwit> ?type (concat .) . zipWith ((. return) . (:))
20:08:17 <lambdabot> forall a. [a] -> [a] -> [a]
20:08:19 <chessguy> @hoogle interleave
20:08:20 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
20:08:20 <lambdabot> Control.Monad.ST.unsafeInterleaveST :: ST s a -> ST s a
20:08:20 <lambdabot> Control.Monad.ST.Lazy.unsafeInterleaveST :: ST s a -> ST s a
20:08:28 <chessguy> @hoogle+
20:08:43 <chessguy> dmwit:  that's just sick
20:09:41 <dmwit> chessguy: Pretty soon, chains of ((f .) .) . will melt away before your eyes...
20:10:20 <olsner> @. pl unpl (concat .) . zipWith ((. return) . (:))
20:10:21 <lambdabot> (join .) . zipWith ((. return) . (:))
20:10:26 <ddarius> > let interleave xs ys = concat . transpose $ [xs,ys] in interleave "abc" "123"
20:10:26 <vixey> I only know (.).(.)
20:10:27 <lambdabot>  "a1b2c3"
20:10:30 <olsner> @unpl (concat .) . zipWith ((. return) . (:))
20:10:31 <lambdabot> (\ e k -> concat (zipWith (\ h n -> ((:)) h (return n)) e k))
20:11:36 <dmwit> vixey: ((f .) .) === (.) . (.) $ f
20:11:51 <vixey> oh cool
20:14:35 <jdrake> How does one do a multiline if expression? (for example, if ... then \n  blah \n else \n blah   else seems to give a parse error.
20:15:41 <ddarius> jdrake: You just stick another if expression in the else branch
20:15:54 <ddarius> if a then b else if c then d else e
20:16:03 <ddarius> Or better yet, use guards/pattern matching.
20:16:13 <rizzix> indent the then by one...
20:16:31 <ddarius> if's don't utilize layout.
20:16:34 <tieTYT> jdrake: it's ambiguous what you're confused about.  You asking how to do an if/else if/else?
20:16:46 <rizzix> oh
20:17:03 <jdrake> if ... then \n  blah \n else \n blah
20:17:59 <tieTYT> not sure if you can do that.  I know you can if \n then \n else
20:18:11 <tieTYT> and when you do that, make sure the then and the else are indented
20:18:27 <rizzix> :s
20:18:55 <tieTYT> also, you can wrap it in {...} and indent it however you like
20:19:33 <jdrake> Hmm, it doesn't even like it if I put it on the same line
20:19:45 <tieTYT> show us your real code
20:19:50 <tieTYT> in a pastebin
20:19:53 <ddarius> Again, if/then/else don't introduce new blocks
20:20:16 <tieTYT> ddarius: I always indent mine, i donno what the difference between indentation and new blocks are
20:20:18 <jdrake> I am hesitant to post such code, it is quite ugly :-)
20:21:07 <jdrake> ok, I am going to post the code, but I don't want criticism of my method, just the syntax error. I want to try to work out the proper recursion (which will become obvious) myself.
20:21:18 <vixey> what code?
20:21:46 <hpaste>  jdrake pasted "else syntax error" at http://hpaste.org/7936
20:22:49 <tieTYT> i think you should start the if on the line above
20:23:09 <tieTYT> if that's NOT necessary, then you may have to indent the then/else more than the if
20:23:26 <dibblego> jdrake, your parentheses do not align on the second-last line
20:23:39 <ddarius> jdrake: What error are you getting?
20:23:42 <dibblego> add another )
20:23:49 <ddarius> Yes, what dibblego said.
20:23:49 <tieTYT> ah
20:23:50 <jdrake> ddarius: parse error on the else
20:24:00 <tieTYT> is his indentation fine?
20:24:06 <dibblego> yes
20:24:13 <tieTYT> ah
20:24:14 <ddarius> tieTYT: Indentation is completely irrelevant in that example.
20:24:24 <tieTYT> in that case, i should write a comment on RWH
20:24:24 <jdrake> man, that was annoying
20:24:28 <tieTYT> cause apparently it didn't teach me very well
20:24:45 <ddarius> Layout is not even in effect (except for the top-level declarations, but it hard to unindent from the 0th column)
20:25:09 <ddarius> jdrake: The only parentheses you need in that function are the ones around the two occurrences of m - 1.
20:25:18 <ddarius> All the others are superfluous.
20:25:25 <vixey> > [1..60]
20:25:26 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:25:42 <vixey> > filter ((==0).(60`mod`)) [1..60]
20:25:43 <lambdabot>  [1,2,3,4,5,6,10,12,15,20,30,60]
20:25:50 <ddarius> jdrake: And again, a guard would be prettier and more idiomatic.
20:26:00 <jdrake> ddarius: ocaml has bitten me badly in the past, so I am usually careful in this :-)
20:26:12 <jdrake> ddarius: quite possibly, but I am 'not there yet'
20:26:13 <vixey> ocaml doesn't have guards ..
20:26:33 <ddarius> jdrake: The ML families type syntax is atrocious.
20:26:36 <ddarius> +'
20:26:48 <vixey> I kind of like it :(
20:27:01 <dlomsak> ocaml has guards
20:27:08 <vixey> dlomsak: huh ?!
20:27:24 <augur> who wants to feel better by making fun of javascript?
20:27:28 <augur> ok here goes
20:27:50 <dlomsak> http://code.google.com/p/ocaml-patterns/wiki/PatternGuards
20:27:50 <augur> in js, the "in" keyword doesnt test array membership, it tests hash key membership.
20:27:54 <lambdabot> Title: PatternGuards - ocaml-patterns - Google Code
20:28:06 <vixey> cool cheers
20:28:10 <jdrake> ddarius: You are right, it has no concept of 'where', that is why I left for haskell immediately when I found that out :-)
20:28:19 <augur> so 5 in [5] is false.
20:28:38 <augur> moral: be greatful you use haskell, which isnt completely idiotic.
20:28:39 <augur> :P
20:28:52 <vixey> jdrake where and let are equivalent
20:29:04 <augur> grateful? grateful.
20:29:24 <tieTYT> augur: i didn't even know there was an in keyword in js
20:29:26 <jdrake> vixey: equivalent is not enough :-)
20:29:36 <augur> there is
20:29:37 <augur> and its stupid
20:29:42 <dmwit> where and let are not equivalent
20:29:44 <tieTYT> *shrug*
20:29:53 <augur> it makes sense in, say, for...in loops
20:29:58 <tieTYT> i can't compare javascript to haskell, but compared to the other things i know, i think JS is pretty cool in general
20:30:10 <vixey> dmwit: I thought they were exactly the same
20:30:11 <augur> but theres no convenient way of testing array membership
20:30:20 <augur> not even a method on the array!
20:30:23 <tieTYT> disclaimer: I am not fluent in any functional languages yet
20:30:23 <dmwit> do { x <- m; let y = f x; return y } -- can't be converted to "where" syntax
20:30:26 <vixey> oh well I guess where can't go in as many places
20:30:27 <augur> you have to do array.indexOf(item) == -1
20:30:30 <vixey> yeah, good point
20:30:36 <vixey> didn't realize that
20:30:43 <augur> theres no build in member(item) function
20:31:01 <ddarius> augur: Do you plan on talking about Haskell at any point?
20:31:24 <augur> im providing a morale boost, not like its needed. :P
20:32:38 <jdrake> Does haskell have any nice pages documenting various parts of the language in a nice accessible way? (monads are not required) I liked the way http://code.google.com/p/ocaml-patterns/wiki/PatternGuards presented its information, but of course is ocaml.
20:32:39 <lambdabot> Title: PatternGuards - ocaml-patterns - Google Code
20:32:58 <dmwit> jdrake: Like the Haskell Report?
20:33:04 <dmwit> ?where report
20:33:05 <lambdabot> http://www.haskell.org/onlinereport/
20:33:30 <jdrake> dmwit: No, I already am reading it.
20:33:50 <jdrake> It is 'good enough', but I would like something less specification
20:33:52 <dons> yeah, lots of stuff on the wiki
20:33:56 <dons> under Idioms
20:34:05 <sclv> ?seen ndm
20:34:05 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 4h 53m 29s ago, and .
20:34:07 <sclv> @bot?
20:34:07 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
20:35:47 <tieTYT> man, break/span's functionality is kinda hard for me to remember
20:36:21 <ddarius> :t break
20:36:22 <ddarius> :t span
20:36:23 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:36:24 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:36:29 <tieTYT> :)
20:36:32 <dmwit> I just remember span.
20:36:43 <tieTYT> yeah i figured i'd do the same
20:36:43 <dmwit> Then break is "the other one." =P
20:36:49 <edwardk> ddarius: i went through the lattice paper twice (nice paper btw), but no tie to free/cofree
20:36:54 <tieTYT> ha
20:37:04 <ddarius> edwardk: A free monad is usually an algebra.
20:37:22 <edwardk> *nods*
20:37:26 <dibblego> hello tieTYT, how is Haskelling?
20:37:42 <edwardk> one sec then
20:38:22 <tieTYT> dibblego: alright
20:38:30 <tieTYT> it's gonna slow down
20:38:37 <tieTYT> i just got a beta book on stripes (java web framework)
20:38:40 <dibblego> tieTYT, learning anything interesting? why slow down?
20:38:40 <tieTYT> and i'm supposed to review it
20:38:49 <dibblego> tell them to wait :)
20:39:00 <tieTYT> maybe i'll just skim it
20:39:04 <tieTYT> but their deadline is june 9th
20:39:25 <edwardk> hrmm then maybe there is some connection in the beautiful theorm area
20:40:16 <ddarius> 6.11 seems potentially useful
20:40:34 <tieTYT> it's a good framework though.  It's the only java web framework that actually makes web development simplier.  What a concept
20:41:06 <dibblego> tieTYT, remember though, the act of abandoning Java makes web development significantly more simpler than all those frameworks
20:41:22 <tieTYT> so there are some good haskell web frameworks out there?
20:41:28 <dibblego> I have a web application written in Scala; it is 15 characters long
20:41:31 <dibblego> sure!
20:41:33 <tieTYT> rather, great ones?
20:41:46 <tieTYT> well i'm not using scala
20:41:49 <dibblego> maybe not great (or maybe so), but definitely *more great*
20:41:51 <tieTYT> but i may use Haskell
20:42:01 <dibblego> Scala is just watered down Haskell
20:42:02 <edwardk> aha
20:42:14 <sclv> tieTYT: filters in web.xml files are just watered down monads, for that matter. :-)
20:42:16 <dibblego> @go practical web programming in Haskell
20:42:17 <edwardk> that should do it then, i'll give it a try after i bang something for work
20:42:18 <lambdabot> http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell
20:42:18 <lambdabot> Title: Practical web programming in Haskell - HaskellWiki
20:42:27 <edwardk> er bang on
20:42:37 <tieTYT> i'll read that much later
20:42:45 <tieTYT> i don't know what a monad is yet (nor do I want to know at this point)
20:42:56 <edwardk> i think i have the swap law in question
20:43:02 <sclv> Do you know webwork/struts2?
20:43:11 <dibblego> tieTYT, you just need to know that the Java guys are using them all day, in an impoverished form
20:43:23 <dibblego> (and with a euphemism attached)
20:43:33 <edwardk> its not quite right because i have a relationship between an algebra and a coalgebra though
20:43:34 <tieTYT> sclv: a bit
20:43:39 <tieTYT> sclv: i don't know why i said that
20:43:44 <edwardk> but its the right general direction
20:43:45 <sclv> you know how each step down the filter chain you're passing a request, and embellishing it?
20:43:47 <tieTYT> no, i don't.  I know struts1 (unfortunately)
20:43:57 <tieTYT> yes
20:44:49 <sclv> imagine that the request passing was implicit and first-level instead of in some funny xml config, and that your access to the environment was controlled in a strongly typed fashion instead of with these <String,Object> maps.
20:44:50 <dibblego> you know Java/C where you're going down a chain updating a system state using semi-colons as separators?
20:44:52 <rizzix> there aren't any good webframeworks for haskell
20:44:57 <sclv> look! its the cgi monad.
20:45:10 <sclv> rizzix: have you seen hvac? :-)
20:45:21 <sclv> (ok, ok, I need to finish the hackage release...)
20:45:42 <rizzix> someone should create one
20:45:48 <tieTYT> dibblego: no...?
20:46:01 <dibblego> tieTYT, you've not used a semi-colon in Java or C before?
20:46:05 <sclv> rizzix: I did!
20:46:34 <sclv> dev repo: http://code.haskell.org/~sclv/hvac/
20:46:34 <tieTYT> yes, but i'm not updating system state down a chain when i use it
20:46:35 <lambdabot> Title: Index of /~sclv/hvac
20:46:42 <dibblego> setState1(); setState2(); setState3(); // sometimes programmers use line separators
20:47:17 <dibblego> tieTYT, not always, but quite a lot (when you aren't, you're using an existing library usually)
20:47:28 <tieTYT> yeah, the framework takes care of it for me
20:47:36 <tieTYT> but i am using like 3 filters
20:47:43 <tieTYT> so indirectly i'm doing that i guess
20:48:11 <dibblego> tieTYT, the point is, you're chaining transformations inside "some kind of world" (HTTP filters, system state updates)
20:48:32 <dibblego> ; is a monad, but don't tell the Java guys, they seem to get upset about it
20:48:46 <dibblego> (though, it's missing some crucial parts that make it truly a monad)
20:49:01 <cjs> Does it obey the monadic laws?
20:49:06 <dibblego> no
20:49:13 <cjs> ; is closer to a Monoid, no?
20:49:23 <cjs> Ah, a Monoid without mzero!
20:49:30 <dibblego> semigroup
20:49:35 <bd_> cjs: ; has a mzero
20:49:35 <cjs> What do you call something with only mappend?
20:49:39 <bd_> eg, this is legal: ;;;;;;;
20:49:46 <bd_> in C at least
20:49:46 <dibblego> cjs, a semi-group
20:49:57 <edwardk> doh, nevermind, switching categories
20:49:58 <cjs> dibblego: Yeah, I hit return just as that came up. Thanks!
20:50:21 <cjs> bd_: Wouldn't that just be something along the lines of "nothing `mappend` nothing `mappend` ..."
20:50:48 <bd_> nothing = mempty, right?
20:51:05 <cjs> No, mempty is an operation.
20:51:16 <bd_> mempty `mappend` x = x
20:51:17 <cjs> nothing is just a statement, like any other java statement.
20:51:22 <bd_> x `mappend` mempty = x
20:51:30 <cjs> Oh, yeah, but the point is, you don't have the mzero operation.
20:51:35 <bd_> since  foo();;  is defined as being equivalent to foo(); ...
20:51:51 <cjs> A semicolon always does the same thing: mappend. If you mappend some mempties, that's fine; I guess.
20:52:18 <bd_> cjs: why not? It might not /look/ like mzero, but if foo() is allowed to be an element of the monoid, then why not allow read "0" :: CMonoid be mzero?
20:52:26 <bd_> or read "" even
20:52:35 <bd_> foo() ; 0 ; <-- also equivalent
20:52:40 <cjs> Hang on, I'm confused; I need to look up the docs.
20:52:41 <bd_> it's just a matter of syntax :)
20:52:54 <bd_> in my C-alike I've literally parsed an extra ; as a null statement
20:53:06 <bd_> ie, a string of only whitespace is mzerpo
20:53:08 <bd_> mzero*
20:53:20 <cjs> Sure, but a null statement is a statement like anything else.
20:53:41 <bd_> cjs: with semantics identical to mzero
20:53:43 <bd_> right?
20:53:46 <cjs> Right.
20:53:52 <bd_> therefore, it's mzero
20:53:55 <cjs> It's mconcat that's missing.
20:54:04 <bd_> mconcat isn't a primitive operation
20:54:11 <bd_> just fold over with mappend
20:54:11 <dibblego> mconcat is not part of a monoid
20:54:16 <cjs> Oh, yeah. Sorry.
20:54:16 <bd_> @src mconcat
20:54:17 <lambdabot> Source not found. :(
20:54:20 <bd_> @src mconcat Monoid
20:54:20 <lambdabot> Source not found. There are some things that I just don't know.
20:54:23 <bd_> bah
20:54:31 <cjs> So you're right; mzero is the empty statement; there are other statements; and ";" is mappend.
20:54:50 <bd_> mconcat = foldl' mappend mzero <-- there we go
20:54:58 <bd_> foldr possibly
20:55:00 <dibblego> I believe mconcat uses foldr
20:55:12 <dibblego> since the monoid is not necessarily commutative
20:55:14 <Cale> uh, ; is mappend in what?
20:55:28 <bd_> cjs: what about statements which may or may not be illegal in context?
20:55:29 <bd_> eg,
20:55:39 <bd_> read "int x" `mappend` read "x = 42"
20:55:43 <dibblego> Cale, it's not :)
20:55:54 <bd_> the latter can't be the bottom, but it's not meaningful in itself
20:59:05 <dolio> It's more like Java is the subset of Haskell where everything is in do-notation in the IO monad.
20:59:16 <cjs> bd_: dunno. I've gone about as far as I care to thinking about this, since I'm simultaneously dealing with the pain of programming in C# right now.
20:59:38 <bd_> dolio: and liftM(n)s are automatically inserted?
21:00:13 <dolio> Or, ContT r IO, with callCC wrapped around each named computation for non-local return.
21:00:33 <bd_> eh, you can implement that with exceptions :)
21:00:38 <dolio> Yeah, something like that.
21:00:40 <bd_> </bad idea>
21:00:58 <dolio> Yeah, you could... :)
21:01:15 <cjs> Man this shit is verbose. How can anybody read it?
21:04:45 <tieTYT> yes or no question: is it possible to implement splitAt without going throught he list twice?
21:04:55 <tieTYT> once to find the take and once to find the drop?
21:05:11 <Pseudonym> Yes.
21:05:13 <bd_> sure
21:05:17 <bd_> @src splitAt
21:05:17 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
21:05:18 <tieTYT> ok i'll try to figure it out
21:05:25 <bd_> well, that implementation is not it obviously
21:05:36 <tieTYT> i said "yes or no question" cause i didn't want to know how :P
21:05:40 <tieTYT> luckily, i didn't see that
21:05:53 <edwardk> cjs: c# is generally a lot more verbose than haskell. with LINQ its not so bad though
21:06:08 <sclv> the real splitAt in GHC doesn't do that -- its quite efficient, actually.
21:06:26 <sclv> (the tuples it works with are even unboxed by the compiler, as we discovered the other day)
21:06:36 <bd_> Yes, @src usually uses the haskell report definitions, which are usually horribly inefficient (but easy to demonstrate to be correct)
21:06:39 <bd_> @src sort
21:06:39 <lambdabot> sort = sortBy compare
21:06:43 <bd_> @src sortBy
21:06:43 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
21:06:45 <bd_> O(n^2) :3
21:07:18 <sclv> @src nub
21:07:19 <lambdabot> nub = nubBy (==)
21:07:23 <sclv> @src nubBy
21:07:23 <lambdabot> nubBy eq []             =  []
21:07:23 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
21:07:34 <sclv> sadly the real one ^^
21:07:48 <bd_> nubBy can't be better than O(n^2) though, since it doesn't even have Ord
21:08:27 <sclv> true.
21:09:04 <tieTYT> what's the O(x) of ++?
21:09:13 <sclv> you could always do a "sorta nub" with pointer equality. :-)
21:09:27 <bd_> sclv: worst case remains O(n^2)
21:09:29 <vixey> > let nubBy' eq (x:xs)         =  x : nubBy' eq (filter (\ y -> not (eq x y)) xs) in nubBy' (==) [3,5,6,8,4,3,2,1,5]
21:09:30 <lambdabot>   Non-exhaustive patterns in function nubBy'
21:10:07 <bd_> > let nubBy' _ [] = []; nubBy' eq (x:xs)         =  x : nubBy' eq (filter (\ y -> not (eq x y)) xs) in nubBy' (==) [3,5,6,8,4,3,2,1,5]
21:10:08 <lambdabot>  [3,5,6,8,4,2,1]
21:10:14 <sclv> ++ is O(m) as I recall? somewhere thereabouts.
21:10:19 <tieTYT> ok
21:10:29 <sclv> bd_: if you use ptr equality you can always sort the pointers though...
21:11:00 <bd_> ++ is complicated though, if you stack it deep enough, then the important factor might be the number of times you ++'d (ie, indirect calls to resolve one list element out of it)
21:11:05 <sclv> the results will be highly impure however.
21:11:09 <bd_> sclv: sure, but that doesn't help you if all the pointers are different
21:11:30 <sclv> sortaNub :: [a] -> IO [a] --hah
21:11:54 <dolio> You don't need IO, actually.
21:11:56 <bd_> It doesn't need IO - but not even in IO can you ensure that (a == b) => (pointerOf a == pointerOf b)
21:12:19 <bd_> so, you can easily end up with a list of all identical elements, with all different pointer values
21:12:23 <bd_> which next GC all become the same :)
21:12:25 <sclv> but in IO you're allowed to not care.
21:12:45 <bd_> sclv: you're not, really - even in IO pointer values can - and will - change under you
21:13:08 <bd_> I mean, GHC uses a copying collector, after all :)
21:13:14 <sclv> exactly! but because you're in IO you can be not ref. transparent. I never said this was a sane function, mind you...
21:14:05 <sclv> sortaNub = nubOnOccasionWhenSoInclined
21:14:06 <tieTYT> ok trying to implement splitAt.  It's easy to get to the point where you "do something with the result" but I can't figure out how to return both results as a tuple.  (x : mySplitAt (n - 1) xs, ... is easy for the left side and , mySplitAt (n - 1) xs) is easy for the right, but how do I put them together without iterating the list twice?
21:14:43 <tieTYT> i don't want the solution
21:14:45 <tieTYT> i just want a hint
21:14:46 <sclv> tieTYT: try writing the base case first and then the recursive one...
21:14:56 <tieTYT> ok
21:14:57 <sclv> also remember "let"
21:15:03 <tieTYT> hrm...
21:15:19 <sclv> as in "let x = (y+y+y) in x * x"
21:16:06 <sclv> or "let (a,b) = funcReturningTuple in (a+1,b+1)"
21:17:16 <tieTYT> that let can't be replaced with a helper function?
21:17:57 <sclv> depends what you mean...
21:18:39 <tieTYT> actually i don't know what that means: let (a,b) = funcReturningTuple in (a+1,b+1)
21:18:51 <tieTYT> does that pass a+1, b+1 to funcReturningTuple?
21:19:12 <sclv> it means call funcReturningTuple and pattern-match (i.e. destruct) the tuple it returns, giving you two values, a and b.
21:19:29 <sclv> then, pass those two values into the stuff after the "in" and execute it.
21:19:36 <tieTYT> won't it need params?
21:19:39 <sclv> (i'm being handwavy, here, but you get the point)
21:19:44 <tieTYT> ok
21:19:59 <sclv> you also have where, which is like let... in... but comes after the main body.
21:20:18 <sclv> > x * x where x = (23*2)
21:20:18 <lambdabot>  Parse error at "where" (column 7)
21:20:37 <sclv> > let x = 23 * 2 in x * x
21:20:39 <lambdabot>  2116
21:21:03 <sclv> 23 * 2 is only executed once, and assigned to x, and then x*x is called...
21:21:23 <sclv> think of it as manual common subexpression extraction...
21:35:32 <bos> @seen dons
21:35:32 <lambdabot> dons is in #haskell, #xmonad, #haskell-soc and #ghc. I last heard dons speak 1h 1m 37s ago.
21:42:41 <tieTYT> sclv: still confused about this.  How can I do something like x : myFunc xs  if that needs to return the result of a tuple
21:43:14 <sclv> you mean if myFunc returns a tuple?
21:43:16 <tieTYT> myFunc that is
21:43:17 <tieTYT> yeah
21:43:27 <sclv> let (a,b) = myFunc xs in ...
21:43:48 <tieTYT> what happens to x?
21:44:09 <sclv> whatever you want?
21:44:33 <sclv> oh, you mean if you have func (x:xs)...
21:44:39 <tieTYT> yeah
21:44:58 <sclv> func (x:xs) = let (a,b) = myFunc xs in (x:a,b)... or whatever.
21:45:09 <dmwit> func (x:xs) = let (a, b) = func xs in g x a b -- ?
21:45:18 <sclv> try writing it tail recursively though...
21:45:36 <dmwit> ?src partition
21:45:36 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
21:45:36 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
21:45:36 <lambdabot>                               | otherwise = (ts, x:fs)
21:45:40 <sclv> i.e. don't keep modifying what you return, but rather pass ongoing results as you go.
21:45:56 <dmwit> Ignore the '~' for now.
21:46:10 <tieTYT> sclv: that's what i'm trying to do, but I don't know how to keep adding to the end of a list, only to the front of it
21:46:26 <dmwit> Add at the front, then reverse it. ;-)
21:46:44 <sclv> you don't want to add to the end... it gets slow quickly, follow dmwit's advice. that's the standard idiom
21:46:56 <dmwit> Building a list by adding to the end is O(n^2), n the length of the list.
21:46:56 <tieTYT> dmwit: oh... i thought of that
21:46:58 <tieTYT> but i thought it would be bad
21:47:07 <dmwit> Building a list by adding to the front, then reversing, is O(n).
21:47:08 <tieTYT> let me write it that way
21:47:13 <tieTYT> and you can tell me how i fucked up
21:47:15 <tieTYT> :)
21:47:33 <dmwit> But it's even better if you can either fold the other direction or write your surrounding algorithm so that you don't need to reverse the list.
21:47:34 <vixey> which is way is up?
21:48:21 <augur> that way ::points::
21:48:40 <tieTYT> "the other direction"?
21:49:07 <tieTYT> let me just write this as straight foreward as i can think of it (it'll probably be imperative-like)
21:49:13 <dmwit> Good idea.
21:49:45 <sclv> its good practice to just write the most obvious version and progressively refine.
21:51:12 <tieTYT> my straightforeward try is simply this: mySplitAt n xs = (take n xs, drop n xs)
21:51:33 <sclv> @src take
21:51:33 <lambdabot> take n _      | n <= 0 =  []
21:51:33 <lambdabot> take _ []              =  []
21:51:33 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
21:51:34 <tieTYT> i've already implemented take/drop myself so i feel i earned the write to "cheat" there
21:51:46 <tieTYT> but i bet this isn't good as it is
21:51:52 <dmwit> ?src splitAt
21:51:52 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
21:51:53 <dmwit> ;-)
21:51:59 <tieTYT> oh....
21:52:01 * tieTYT cries
21:52:12 <sclv> try turning your take into a function that returns both what you've taken and the rest...
21:52:16 <dmwit> The actual implementation is slightly better.
21:52:17 <dolio> @src drop
21:52:17 <lambdabot> drop n xs     | n <= 0 =  xs
21:52:17 <lambdabot> drop _ []              =  []
21:52:17 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
21:52:26 <dolio> Notice any similarities?
21:53:04 <tieTYT> yes
21:53:15 <dmwit> tieTYT: It's actually a pretty small price to pay in practice, based on how often splitAt is used and how big the index that's usually passed to splitAt is.
21:53:23 <bd_> hmm, apart from all the unnecessary #s the GHC.List.splitAt implementation is surprisingly straightforward
21:53:36 <tieTYT> what's #?
21:53:37 <tieTYT> is that a comment?
21:53:46 <bd_> tieTYT: dark magic! :)
21:53:50 <dmwit> It's a type-attachment internal to GHC.
21:53:54 <dolio> It's a naming convention for unboxed stuff.
21:53:59 <sclv> don't worry about it for a while yet.
21:54:02 <dolio> Or, primitive operations.
21:54:05 <tieTYT> dmwit: what's a small price to pay?
21:54:09 <bd_> only GHC hackers need to know about # :)
21:54:14 <tieTYT> ok
21:54:34 <dmwit> tieTYT: Writing it the straight-forward way is worse than writing it the good way by O(k), k the index argument.
21:54:44 <dmwit> tieTYT: That O(k) price is small, in my opinion.
21:54:44 * bd_ wonders if using all those primops in splitAt is really any more efficient...
21:54:53 <tieTYT> oh
21:55:01 <tieTYT> what was all that let stuff?
21:55:10 <tieTYT> sclv: i couldn't figure it out your way
21:55:14 <pastorn> from uncyclopedia: "While it is possible to do IO in Haskell, this is only spoken of in whispers, and there is only one function to do IO: System.IO.Unsafe.unsafePerformIO."
21:55:16 <bd_> dmwit: snd . splitAt 100000 <-- with the naive implementation, this may keep the entire list referenced until you force it...
21:55:20 <dmwit> tieTYT: Dunno, it's clear we didn't understand your question correctly.
21:55:31 <bd_> which is worse than the cpu hit imo
21:55:39 <tieTYT> oh
21:55:45 <dmwit> bd_: Sure, but nobody writes that.
21:55:53 <dmwit> bd_: They just write drop 100000.
21:56:05 <dmwit> bd_: If they're using splitAt, they want both parts anyway.
21:56:31 <bos> maybe they like to keep the gc busy.
21:56:46 <bos> because it's, you know, lonely.
21:56:56 <sclv> base case: splitAt 0 xs = ([],xs); recursive case = splitAt n (x:xs) = let (a,b) = splitAt (n-1) xs in ????
21:56:59 <vixey> how goes GHCs GC work?
21:57:01 <bd_> dmwit: true, but even after you unreference the first part, you have the suspended drop
21:57:08 <bd_> dmwit: the snd was just to make it more obvious :)
21:57:34 <sclv> tieTYT: now fill in the question marks, knowing that a and b are the two parts of the tuple returned by the n-1 call... imagine you're writing it only for a one element list.
21:58:10 <sclv> i.e. that your call is to splitAt 1 (x:[])
21:59:20 <tieTYT> hrm, confusing to me...
21:59:21 <tieTYT> (x:[], xs:[]) ?
21:59:32 <tieTYT> i'm not sure if i should be working with a/b or x/xs
21:59:49 <tieTYT> wait that's not even valid
22:00:00 <tieTYT> let me try again
22:00:35 <bd_> tieTYT: you can use any names you want :)
22:00:45 <sclv> > x:[]
22:00:46 <lambdabot>  [x]
22:00:46 <bd_> x:xs <-- is a common convention - think xs = plural of x
22:01:05 <bd_> but it's just a convention, you can spurn it if you want :)
22:01:07 <tieTYT> nod, i know that
22:01:12 <sclv> : is really a constructor that takes two arguments -- a single object and the rest of the list.
22:01:24 <sclv> [] is the null list, which terminates a list.
22:01:34 <sclv> [1,2,3,4] is really sugar for 1:2:3:4:[]
22:01:40 <sclv> @src (:)
22:01:40 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
22:01:55 <sclv> eh, was worth a shot.
22:01:57 <dmwit> I doubt that the notation is what tieTYT is confused about.
22:02:16 <dmwit> He just needs a few minutes to think it through. =)
22:02:51 <tieTYT> is it cheating to try it in ghci?
22:02:55 <tieTYT> is that going to be less helpful to me?
22:02:57 <sclv> not at all!
22:03:00 <tieTYT> ok
22:04:06 <tieTYT> mySplitAt n (x:xs) = let (a,b) = mySplitAt (n-1) xs in (x:a, b)
22:04:09 <tieTYT> that is freaking weird btw
22:04:36 <tieTYT> until now, i didn't know you could use a let to call yourself
22:05:35 <dmwit> Yep, pretty weird!
22:05:38 <dmwit> Also, nice work. =)
22:05:41 <tieTYT> thanks
22:06:20 <tieTYT> on one hand, I don't get it.  On the other hand, that was the second thing I came up with so I must get it.
22:07:12 <tieTYT> is this the GHC way?
22:07:15 <dibblego> tieTYT, that happens for many people
22:08:00 <dons> hehe, "Haskell and this book are not just for people who can't learn C (there is Java for them), but for people who find ANY imperative language hard to grasp."
22:08:05 <dons> that's a new spin i had not thought of.
22:08:19 <dons> haskell -- because imperative programming is too hard!
22:08:28 <Dzlk> Hi!
22:08:32 <tieTYT> apparently i'm unlearning
22:08:40 <tieTYT> cause that splitAt impl is very unintuitive to me
22:08:51 <dibblego> tieTYT, that's very important too :)
22:09:17 <tieTYT> dibblego: i find it hard to imagine that one day i'll think of this as the straightforeward way to do it :)
22:09:52 <Dzlk> dons: It's true, declarative programming is way easier, for me.
22:09:52 <dibblego> tieTYT, do you have a girlfriend? mine is a midwife; I ask her to explain things like that all the time and she comes up with a solution like the one you did
22:09:55 <tieTYT> but that might be true
22:10:03 <tieTYT> dibblego: interesting
22:10:06 <tieTYT> dibblego: yeah i do
22:10:09 <dons> yeah, imperative programming makes programming look hard.
22:10:15 <dibblego> tieTYT, this suggests that you are unlearning (you have preconceived ideas that you are applying)
22:10:44 <vixey> hey Dzlk
22:10:47 <tieTYT> hopefully
22:11:04 <dibblego> tieTYT, you'll have to believe me and all the others who have walked the road you are on, it will come :)
22:11:14 <vixey> what's going on
22:11:23 <tieTYT> i hope
22:11:43 <tieTYT> i hope i stick with it.  Cause this RWH is a tutorial that really suits me
22:11:46 <dmwit> darcs revert
22:11:50 <dmwit> err... sorry
22:11:54 <tieTYT> that was my main problem my first attempt
22:14:48 <Apocalisp> rm -rf *
22:14:53 <Apocalisp> oh, sorry
22:15:18 * Apocalisp watches as #haskell gets sucked into null
22:16:09 <dmwit> /part #haskell zsh: command not found: ls
22:16:15 <dmwit> ;-)
22:16:20 <dons> No instance for (Show (IO ())
22:16:34 <Dzlk> tieTYT: out of curiosity, have you read any of the Haskell tutorials, and if so which ones?
22:16:39 <sjanssen> > return () :: IO ()
22:16:41 <lambdabot>  <IO ()>
22:16:46 <tieTYT> i read YAHT
22:16:58 <dmwit> The whole thing? wow
22:17:00 <tieTYT> no
22:17:05 <tieTYT> like til chapter 3
22:17:07 <tieTYT> or 4
22:17:53 <dibblego> @where arrows
22:17:53 <lambdabot> http://www.haskell.org/arrows/
22:18:21 <tieTYT> sclv: btw, your impl of mySplitAt doesn't return ([],[]) if you pass in a negative
22:18:26 <dibblego> @go hughes arrows
22:18:27 <lambdabot> http://www.haskell.org/arrows/
22:18:27 <lambdabot> Title: Arrows: A General Interface to Computation
22:18:43 <dmwit> tieTYT: It shouldn't.
22:18:53 <dmwit> tieTYT: It should return ([], <the whole list>).
22:19:30 <tieTYT> oh right
22:19:33 <tieTYT> but it doesn't do that eitehr
22:19:37 <sclv> as it is now though, it probably croaks with a pattern match failure.
22:19:39 <dmwit> yeah =P
22:19:46 <dmwit> No, infinite loop.
22:19:52 * dmwit guesses
22:19:55 <tieTYT> ([1,2,3*** Exception: mySplitAt.hs:(4,0)-(5,62): Non-exhaustive patterns in function mySplitAt
22:20:11 * dmwit fails
22:20:13 <sclv> tieTYT: on the other hand, you should be able to figure out how to fix it now!
22:20:21 <tieTYT> yeah
22:20:25 <tieTYT> just a guard i assume
22:20:39 <sclv> add a third case, just like the drop and take functions have...
22:20:42 <sclv> @src drop
22:20:42 <lambdabot> drop n xs     | n <= 0 =  xs
22:20:42 <lambdabot> drop _ []              =  []
22:20:42 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
22:21:10 <sclv> (a _ in a pattern means "anything at all, and I'm not naming it, because I won't use it")
22:21:47 <sclv> or a guard, yeah, that works too...
22:25:15 <tieTYT> besides the clarity, are there performance benefits to _?
22:25:34 <dmwit> No, it's only clarity.
22:25:50 <dmwit> It avoids namespace clutter in the function, and is a clue to human readers.
22:26:12 <tieTYT> ok thanks
22:26:23 <Dzlk> Is it operationally equivalent to a named binding?
22:26:25 <thetallguy> > [LT ..]
22:26:26 <lambdabot>  [LT,EQ,GT]
22:26:30 <tieTYT> @src break
22:26:30 <lambdabot> break p =  span (not . p)
22:26:36 <sjanssen> Dzlk: yes
22:26:37 <dmwit> Actually, now that I'm saying it, that might not be true.
22:26:43 <dmwit> It could be a clue to the GC.
22:26:46 <tieTYT> interesting, this is mine: myBreak f xs = (myTakeWhile f xs, myDropWhile f xs)
22:26:55 <dmwit> Luckily, sjanssen knows for sure. =)
22:26:58 <thetallguy> @src sequence
22:26:58 <lambdabot> sequence []     = return []
22:26:58 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
22:26:58 <lambdabot> --OR
22:26:58 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
22:27:05 <sjanssen> Dzlk: a fresh name that is not used anywhere else
22:27:12 <tieTYT> is my impl "bad"?
22:27:13 <thetallguy> oops
22:27:35 <dmwit> tieTYT: Yes, it doesn't match the specification.
22:27:51 <dmwit> > break isUpper "aaaBREAKS HERE"
22:27:52 <lambdabot>  ("aaa","BREAKS HERE")
22:28:20 <sjanssen> dmwit, Dzlk: well, in theory, a Haskell compiler could behave differently (operationally, not denotationally), but it would be very silly
22:28:30 <tieTYT> how do i get isUpper?
22:28:36 <dmwit> import Data.Char
22:28:43 <Dzlk> sjanssen: Ah, I was wondering about f'rex, what dmwit mentioned, that it could hint the GC.
22:28:47 <dmwit> Or, in ghci, :m + Data.Char.
22:28:48 <tieTYT> hm
22:28:49 <sjanssen> I don't think it makes a difference in any of the Haskell compilers in use
22:28:51 <bos> has anyone worked simultaneously with phantom types and existentials?
22:29:31 <sjanssen> phantoms and existentials almost seem like opposites
22:29:31 <tieTYT> dmwit: ah, i misunderstood the definition
22:29:56 <bos> sjanssen: i know, and i'm having a smidge of trouble :-)
22:30:09 <bos> data Hidden a = forall b. Hidden (MVar b)
22:30:17 <bos> mkHidden :: MVar a -> Hidden a
22:30:18 <tieTYT> dmwit: wait a sec, look at this from RWH
22:30:26 <tieTYT> the functions break (which we already saw in the section called Warming up: portably splitting lines of text) and span  tuple up the results of takeWhile and dropWhile.
22:30:32 <bos> now the question is, what should the type of a function "reveal" be?
22:30:36 <bos> reveal (Hidden a) = a
22:30:50 <dmwit> tieTYT: It's true, but break and span treat the predicate oppositely.
22:30:51 <bos> so that i can recover what's hidden behind the existential.
22:30:59 <sjanssen> reveal :: MVar b -> (forall a. MVar a)
22:31:02 <dmwit> tieTYT: You should maybe leave a comment suggesting that they clarify that.
22:31:32 <tieTYT> oh i see
22:31:38 <bos> sjanssen: doesn't work.
22:31:39 <tieTYT> their example usage of break is terrible
22:31:44 <dmwit> tieTYT: For span, the first part of the tuple should all satisfy the predicate; for break, none of the first part of the tuple should satisfy the predicate.
22:31:44 <tieTYT> gives no indication of what it really does
22:31:45 <sjanssen> bos: reveal is pretty much useless, isn't it?
22:31:52 <sjanssen> what can you actually do with that MVar?
22:32:00 <tieTYT> dmwit: did i create span and name it break on accident?
22:32:09 <dmwit> tieTYT: yup =)
22:32:12 <tieTYT> ok good
22:32:16 <tieTYT> not a waste of time then
22:32:26 <Dzlk> I suppose _ could mean "there's no harm in throwing this away now" but I don't know enough about the compiler to know if that'd be useful.
22:32:26 <dmwit> Yeah, you're understanding the language.
22:32:40 <tieTYT> at least i made what i intended :)
22:32:41 <bos> sjanssen: ideally, one could have a modifyMVar that had rank-2 type.
22:33:20 <dmwit> Dzlk: It's known at compile time if a bound variable is unused in the function body...
22:33:25 <bos> so that you could safely acquire a nested bunch of MVars in a type-safe manner.
22:33:49 <bos> but i'm not oleginous enough to figure it out.
22:33:58 <Dzlk> dwmit: Oh, that's true. So it's moot.
22:34:36 <sclv> modify :: Hidden a -> (a->a) -> Hidden a ??
22:34:44 <sjanssen> bos: oh, I don't think you can write reveal
22:34:57 <bos> sjanssen: i can't think of a way to, at any rate.
22:34:58 <sclv> Hidden a -> (a->b) -> Hidden b
22:35:07 <sjanssen> bos: because we only have 'forall' and not 'exists'
22:35:28 <sjanssen> reveal :: Hidden a -> exists b. MVar b
22:35:31 <sclv> what am I missing that makes that less sane and obvious than I think?
22:36:00 <sclv> one solution is to wrap a modifyMVar function up with the Hidden in the first place?
22:37:17 <sjanssen> bos: what purpose does the phantom serve?
22:37:30 <sclv> data Hidden a = Hidden ((a->b) ->Hidden b)
22:37:38 <tieTYT> myBreak f xs = let n = not . f in (myTakeWhile n xs, myDropWhile n xs)
22:37:39 <bos> sjanssen: gives us a monomorphic container so we can put them in a list.
22:37:55 <tieTYT> how's that?
22:38:14 <bos> anyway, it was just a thought experiment.
22:38:28 <tieTYT> i don't really know what . is for.  I haven't officially learned it but I see it's necessary to "chain" functions
22:38:32 <sjanssen> bos: but isn't data Hidden = forall b. Hidden (MVar b) the same thing?
22:38:33 <bos> the problem i was trying to solve was lock order inversion.
22:38:41 <tieTYT> is there a way to do this without . ?
22:38:59 <bos> which we can approximate in haskell with modifyMVar order inversion.
22:39:39 <sclv> ?src (.)
22:39:39 <lambdabot> (f . g) x = f (g x)
22:39:39 <lambdabot> -- In lambdabot, it's been generalised to:
22:39:39 <lambdabot> (.) = fmap
22:40:00 <sjanssen> boo
22:40:02 <bos> so i idly wondered if i could write a function that takes a list of MVars, and tries to safely modifyMVar-alike the list.
22:40:12 <sclv> @unpl not . f
22:40:12 <lambdabot> (\ c -> not (f c))
22:40:17 <sclv> ^^
22:40:32 <tieTYT> sclv: but i don't have an argument to pass it in the let
22:40:50 <sclv> tieTYT: That's what the \c is -- its a lambda.
22:41:05 <dmwit> Welcome to closures!
22:41:12 <sclv> > (\a b c -> a + b + c) 1 2 3
22:41:13 <lambdabot>  6
22:41:15 <tieTYT> o_O
22:41:16 <dibblego> tieTYT, ever wanted to convert a T to a V, but only had methods that convert T to U and U to V?
22:41:41 <tieTYT> probably, but I don't yet think in those terms :)
22:41:49 <newsham> what's the "| a -> b" restriction thing called again?
22:41:54 <tieTYT> i probably do it all the time and don't consider it a pain in the ass, yet
22:42:08 <vixey> functional dependancy
22:42:10 <dmwit> newsham: Functional dependency.
22:42:35 <dibblego> tieTYT, I bet you already think in those terms; replace T with InputStream, V with Iterator<Byte> and U with Buffer
22:43:14 <sclv> right. if you ever have foo(bar(baz(x)))
22:43:15 <tieTYT> that's true
22:43:21 <vixey> anyone know of some good examples of views?
22:43:39 <sclv> I'm fond of the new york skyline myself *rimshot8
22:45:18 <roconnor> vixey: like the ones in McKinna-McBride?
22:45:25 <vixey> yes
22:45:37 <roconnor> vixey: the ones in McKinna-McBride.
22:45:45 <vixey> thanks :P
22:46:01 <roconnor> I've make a sorta view
22:46:12 <vixey> what is it?
22:46:15 <roconnor> although James McKinna says it isn't what he had in mind.
22:46:22 <vixey> :o
22:46:30 <roconnor> I view two step functions has having a common partition.
22:49:35 <newsham> anyone have an example of using arrowstate?
22:49:39 <newsham> > (arr (+1) >>> fetch)
22:49:40 <lambdabot>   add an instance declaration for (Show (a b d))
22:49:48 <newsham> > (arr (+1) >>> fetch) 5
22:49:48 <lambdabot>   add an instance declaration for (ArrowState d (->))
22:50:21 <dmwit> :t fetch
22:50:23 <lambdabot> forall (a :: * -> * -> *) e s. (ArrowState s a) => a e s
22:50:40 <newsham> http://hackage.haskell.org/packages/archive/arrows/0.4/doc/html/Control-Arrow-Operations.html
22:50:41 <lambdabot> http://tinyurl.com/5zrafd
22:50:42 <dmwit> ?instances ArrowState
22:50:43 <lambdabot> Couldn't find class `ArrowState'. Try @instances-importing
22:50:52 <dmwit> ?instances-importing Control.Arrow.State
22:50:52 <lambdabot> Couldn't find class `Control.Arrow.State'. Try @instances-importing
22:50:55 <dmwit> ?instances-importing Control.Arrow
22:50:55 <lambdabot> Couldn't find class `Control.Arrow'. Try @instances-importing
22:50:59 <dmwit> um
22:51:04 <dmwit> oh
22:51:12 <dmwit> ?instances-importing Control.Arrow.State ArrowState
22:51:12 <lambdabot> Couldn't find class `ArrowState'. Try @instances-importing
22:51:22 <dmwit> ?instances-importing Control.Arrow.State Control.Arrow ArrowState
22:51:23 <lambdabot> Couldn't find class `ArrowState'. Try @instances-importing
22:51:28 <dmwit> hmph
22:55:01 <newsham> Array a => ArrowState s a | a -> s where...
22:55:19 <newsham> that just means that all arrows are also ArrowState's, and that there's only one s per a, right?
22:55:43 <sclv> nope
22:55:55 <newsham> ok, can you explain please?
22:55:56 <sclv> think of MonadState in the mtl
22:56:04 <newsham> i dont know fundeps really
22:56:15 <sclv> its a class -- look at the instances below it in the haddocks, just like any class...
22:56:59 <sclv> along with all the fancy ones you have the StateArrow, which is your basic instance.
22:57:09 <newsham> instances:  Arrow a => ArrowState s (StateArrow s a)
22:58:18 <sclv> right. and you run it with a runState.
22:59:28 <newsham> ahh i see it now
22:59:57 <newsham> > runState (arr (+1) >>> fetch) (3,5)
22:59:57 <lambdabot>        add an instance declaration for (ArrowState a State, Num (t, t1))
23:00:36 <sclv> lambdabot is using the runState from the state monad, not the state arrow though.
23:00:43 <sclv> I don't think it imports the other. :-(
23:00:59 <newsham> > Control.Arrow.Transformer.State.runState (arr (+1) >>> fetch) (3,5)
23:01:00 <lambdabot>   Not in scope: `Control.Arrow.Transformer.State.runState'
23:01:03 <newsham> guess not
23:01:20 <newsham> weird that it has Control.Arrow.Operations.ArrowState
23:03:58 <newsham> ahh got it to work in runhaskell
23:38:49 <jaj> @src (->) first
23:38:50 <lambdabot> first f = f *** id
23:38:59 <jaj> @src (***)
23:38:59 <lambdabot> f *** g = first f >>> second g
23:39:10 <jaj> isn't that a circular definition?
23:39:17 <dmwit> ?src (->) (***)
23:39:18 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
23:39:21 <dmwit> Nope.
23:39:22 <^Someone^> lambdabot is so frustrated it's swearing...
23:39:33 <ski_> @src first
23:39:34 <lambdabot> Source not found. You type like i drive.
23:39:37 <^Someone^> *she's
23:39:43 <jaj> dmwit: oh right :)
23:39:53 <jaj> thanks
23:40:01 <ski_> the `@src (***)' one is a default definition
23:40:26 <dmwit> So is the `@src (->) first' one, but for a different reason. =)
23:43:09 <a13x> sqrt (-1) = NaN ;              Now how do I express NaN?
23:46:03 <cjs> Is a comma after the last thing in an export list ("module Foo (a, b,) where ...") legal?
23:47:58 <dmwit> > NaN
23:47:58 <lambdabot>   Not in scope: data constructor `NaN'
23:48:03 <dmwit> > (0/0)
23:48:04 <lambdabot>  NaN
23:48:17 <a13x> Prelude> NaN
23:48:17 <a13x> <interactive>:1:0: Not in scope: data constructor `NaN'
23:48:18 <dmwit> a13x: You can use "error" or (0/0).
23:48:38 <dmwit> cjs: As a convenience, yes.
23:48:49 <a13x> 0/0?
23:49:25 <dmwit> > error "sqrt of negative number" -- I would prefer this way
23:49:26 <lambdabot>  Exception: sqrt of negative number
23:49:33 <dmwit> Or, this way:
23:49:44 <dmwit> sqrt :: Double -> Maybe Double
23:49:54 <a13x> is there any more 'cosmetic' way doing this?
23:50:04 <dmwit> sqrt x | x >= 0 = {- whatever -} | x < 0 = Nothing
23:50:21 <dmwit> Or, if generalization is your thing...
23:50:35 <dmwit> sqrt :: MonadPlus m => Double -> m Double
23:50:53 <dmwit> sqrt x | x >= 0 = return {- whatever -} | x < 0 = mzero
23:52:00 <jaj> are there any NaN or Infinity constructors?
23:52:24 <sjanssen> > read "NaN" :: Double
23:52:25 <dmwit> I often define "ensure p x = guard (p x) >> return x", so sqrt :: MonadPlus m => Double -> m Double would become "sqrt x = ensure (>= 0) x >>= {- primitive, non-error-checking sqrt -}".
23:52:26 <lambdabot>  NaN
23:52:43 <Trinithis> a13x: perhaps just make a variable nan = 0/0
23:53:35 <sjanssen> > decodeFloat (read "NaN")
23:53:36 <lambdabot>  (-6755399441055744,972)
23:53:47 <sjanssen> > decodeFloat (read "NaN" :: Float)
23:53:48 <lambdabot>  (-12582912,105)
23:54:29 <jaj> weird stuff
23:55:43 <sjanssen> the RealFloat class ought to have NaN, but it doesn't
23:56:22 <dmwit> > decodeFloat (read "NaN" :: Double)
23:56:24 <lambdabot>  (-6755399441055744,972)
23:56:31 * dmwit feels his sanity return
23:57:02 <sjanssen> dmwit: c'mon, you don't know the numeric defaults by heart? :P
23:59:07 <sjanssen> > uncurry encodeFloat . decodeFloat $ read "NaN"
23:59:10 <lambdabot>  -Infinity
23:59:19 <dmwit> waugh!
23:59:35 <sjanssen> > uncurry encodeFloat . decodeFloat $ (read "NaN" :: Float)
23:59:36 <Trinithis> > 1/0
23:59:38 <lambdabot>  -5.104235503814077e38
23:59:40 <lambdabot>  Infinity
