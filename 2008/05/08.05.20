00:08:25 <schmer> mornin' #haskell. Is there some haskell based webapplication framework around, and is it possible to get haskell stuff hosted anywhere?
00:09:10 <Anthraxx> You could try Haskell Server Pages: http://www.cs.chalmers.se/~d00nibro/hsp/
00:09:11 <lambdabot> Title: HSP - Haskell Server Pages
00:09:19 <Anthraxx> But I'm not familiar with it.
00:10:45 <Cale> There's HAppS
00:10:52 <Trinithis> @ty (>=>)
00:10:56 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
00:10:56 <Cale> I wonder how it's coming along...
00:11:04 <Korollary> I think happs is more popular. see http://hackage.haskell.org/packages/archive/pkg-list.html
00:11:09 <schmer> Thanks. I'll take a look at that. :)
00:12:06 <Cale> schmer: Depending on what you need, there's also some basic CGI stuff that's included with GHC.
00:12:28 <Cale> (it's not exactly a framework, but for sufficiently simple applications it might do)
00:13:22 <schmer> Cale: Thanks.. that won't quite do though :)
00:23:38 <pejo> Is cabal-install in any stable release of cabal?
00:35:51 <dmwit> pejo: No, I think it's its own package.
01:02:39 <tieTYT2> hello
01:02:43 <Cale> hi
01:02:52 <tieTYT2> RWH asked me to make a tree data type with one constructor
01:03:00 <Cale> okay
01:03:04 <tieTYT2> i think i did it, could someone check my work? data Tree a = Node a (Maybe (Tree a)) (Maybe (Tree a))
01:03:18 <Cale> That looks good to me.
01:03:23 <tieTYT2> cool :)
01:03:29 <tieTYT2> thanks
01:03:37 <Cale> No problem.
01:03:52 <tieTYT2> my OO background tells me this is a better definition than the two constructor one that uses a new value constructored named Empty
01:04:11 <tieTYT2> because it reuses code (the Maybe)
01:04:22 <tieTYT2> am i right in that?
01:04:27 <tieTYT2> let me show you the one that was used before that
01:04:40 <tieTYT2> data Tree a = Node a (Tree a) (Tree a) | Empty
01:04:59 <Cale> Somewhat. There's a downside too though, in that you'll end up with some extraneous Just constructors compared to the other one.
01:05:15 <tieTYT2> ah good point
01:05:22 <tieTYT2> so it's iffy
01:05:28 <glguy> you'll have to wrap your definition in a Maybe at the top level
01:05:32 <glguy> so you can express "no tree"
01:05:36 <glguy> like you can with the Empty
01:05:44 <tieTYT2> i mentioned my OO background because the former seemed like code reuse
01:05:50 <sjanssen> you can also express non-empty tree
01:06:00 <Cale> It is code reuse, you're right about that. :)
01:06:01 <sjanssen> the Maybe definition is more expressive
01:06:28 <sjanssen> though I bet the Empty constructor version is generally more convenient
01:06:44 <tieTYT2> yeah
01:06:57 <tieTYT2> can you explain something else to me?  I don't have enough of a vocab to come up with a good example here but
01:07:04 <tieTYT2> this is invalid: data Tree a = Node a (Just (Tree a)) (Just (Tree a))
01:07:20 <tieTYT2> now OBVIOUSLY it's stupid, but what's the general rule that's preventing me from using Just there?
01:07:24 <quicksilver> data Tree f a = Node a (f (Tree a)) (f (Tree a))
01:07:25 <glguy> Just is a data-constructor
01:07:27 <glguy> and it makes values
01:07:31 <quicksilver> is quite a fun one.
01:07:32 <glguy> Maybe is a type constructor
01:07:36 <sjanssen> tieTYT2: yes, 'Just' is a data (value) constructor, while an type constructor is expected in that spot
01:07:44 <quicksilver> if you set f = Identity you're forced to have infinite trees
01:07:53 <quicksilver> if you set f = Maybe you get what you started
01:07:55 <sjanssen> quicksilver: ooh, neat
01:07:55 <tieTYT2> is it like, "The only value constructor you can use in a value constructor is the first one?"
01:08:06 <quicksilver> if you set f = Either Int, you get something else interesting :P)
01:08:10 <Cale> Or just  data Tree f a = Node a (f (Tree a))
01:08:17 <quicksilver> yes.
01:08:20 <dmwit> tieTYT2: No, value constructors just plain aren't allowed in data statements.
01:08:26 <sjanssen> Cale: that isn't kind correct "Tree a"
01:08:31 <Cale> er
01:08:33 <Cale> Or just  data Tree f a = Node a (f (Tree f a))
01:08:34 <tieTYT2> dmwit: isn't "Node" a value constructor?
01:08:37 <Cale> right :)
01:08:44 <dmwit> tieTYT2: "Just" and "Nothing" are value constructors; "Maybe" is the corresponding type constructor.
01:08:54 <glguy> tieTYT2: the Node data constructor and Node value constructor are distinct things that share the same name
01:08:59 <tieTYT2> right but "Node" is a value constructor right?
01:09:02 <Cale> quicksilver's has the same kind problem :)
01:09:02 <dmwit> tieTYT2: Oh, well, okay.  Yes.
01:09:20 <tieTYT2> what's a data constructor?  I don't think that's been defined to me.  I know of type and value constructors
01:09:24 <dmwit> tieTYT2: Fine, you get to use exactly one for each '=' and '|' that appear.
01:09:26 <tieTYT2> does type = data?
01:09:27 <dmwit> =)
01:09:30 <sjanssen> my apologies for attacking Cale first :)
01:09:32 <sjanssen> tieTYT2: no
01:09:37 <tieTYT2> dmwit: ok, cool
01:09:48 <tieTYT2> and that means that Int and String, etc are type constructors
01:09:50 <dmwit> tieTYT2: Usually "data constructor" means "value constructor" restricted to non-newtypes.
01:09:53 <Cale> tieTYT2: probably value = data in this case
01:09:55 <dmwit> tieTYT2: right
01:10:01 <glguy> Int and String are *types*
01:10:06 <tieTYT2> ah
01:10:14 <glguy> Maybe String is a type
01:10:14 <dmwit> glguy: They can also be thought of as nullary type constructors.
01:10:50 <tieTYT2> i see
01:10:58 <tieTYT2> ok i hope this sticks :)
01:11:31 <tieTYT2> are data and value constructors synonymous or are their subtle differences?
01:11:42 <tieTYT2> there
01:12:00 <dmwit> tieTYT2: I'm not sure.  They're *probably* synonymous.
01:12:01 <tieTYT2> oh you said restricted to non-newtypes
01:12:15 <glguy> tieTYT2: I had a typo earlier:
01:12:18 <dmwit> tieTYT2: But yeah, if they're using both, then they are probably making a distinction between data and newtype.
01:12:22 <glguy> tieTYT2: the Node data constructor and Node *type* constructor are distinct things that share the same name
01:12:47 <tieTYT2> glguy: there was no Node type constructor
01:12:56 <tieTYT2> if i typed one, it was a typo on my part too
01:13:09 <glguy> Oh, double typo then
01:13:21 <tieTYT2> *high five*
01:13:24 <glguy> you said something about using Node somewhere and I assumed you used the same name twice
01:13:43 <tieTYT2> perhaps I did
01:13:44 <Cale> tieTYT2: Normally I only use the terms "data constructor" and "type constructor".
01:13:48 * glguy is too tired to be misleading new people
01:13:50 <tieTYT2> hard for me to distinguish these things now
01:13:51 <glguy> goodnight
01:13:54 <tieTYT2> nite
01:14:09 <tieTYT2> Cale: doh, well this book only seems to use type and value
01:14:13 <Cale> A type constructor is something which takes some types and produces a new type.
01:14:19 <Cale> For instance, Maybe is a type constructor
01:14:30 <tieTYT2> that's really confusing
01:14:34 <tieTYT2> don't you mean produces a new value?
01:14:42 <tieTYT2> or a new "data" (that sounds weird)
01:14:49 <Cale> Maybe Integer  is a type
01:15:08 <Cale> If you want,  Integer  is a nullary type constructor
01:15:08 <tieTYT2> oh
01:15:39 <Cale> Either Integer String  is again a type
01:15:49 <Cale> Either Integer  is a type constructor
01:16:09 <tieTYT2> haven't learned Either
01:16:12 <Cale> You can ask for the "kind" of a type constructor with :k at the GHCi prompt
01:16:14 <Cale> :k Maybe
01:16:18 <lambdabot> * -> *
01:16:25 <Cale> (or in lambdabot)
01:16:28 <Cale> :k Integer
01:16:30 <lambdabot> *
01:16:35 <Cale> :k Maybe Integer
01:16:36 <lambdabot> *
01:16:40 <Cale> :k Either
01:16:42 <lambdabot> * -> * -> *
01:16:45 <Cale> :k Either Integer
01:16:50 <lambdabot> * -> *
01:16:52 <Cale> :k Either Integer String
01:16:54 <lambdabot> *
01:16:55 <tieTYT2> what does * mean?
01:16:55 <glguy> If constructor constructors construct constructors who constructs constructor constructors?
01:17:02 <glguy> ok, goodnight
01:17:08 <vixey> tieTYT2: Any Type
01:17:09 <Cale> * is the kind of all types.
01:17:13 <tieTYT2> oh
01:17:23 <vixey> just like Integer means Any Integer
01:17:24 <Cale> * -> * means something which takes a type and produces another type
01:17:34 <tieTYT2> haven't learned this stuff.  I've learned that a represents any... value?
01:17:41 <tieTYT2> i'm confused about my own terminology now
01:17:44 <Cale> any type
01:17:49 <vixey> 7 :: Integer
01:17:52 <Cale> values have types, and types have kinds
01:17:52 <vixey> Integer :: *
01:17:56 <Cale> If you want
01:18:31 <Cale> (all the actual types that are populated with values have kind *)
01:18:38 <Baughn> There are only two kinds, though: Types, and type functions
01:18:51 <tieTYT2> heh
01:18:56 <tieTYT2> my head is gonna explode
01:19:00 <Cale> hehe
01:19:01 <tieTYT2> i'll get to this eventually in the book
01:19:05 <Cale> okay
01:19:06 <tieTYT2> (i hope)
01:19:13 <Cale> well, it's sort of a subtle point anyway
01:19:28 <Cale> But that's not really what I wanted to say...
01:19:34 <Cale> Maybe is a type constructor
01:19:40 <Cale> Just is a data constructor
01:19:41 <Baughn> I suppose if you add type arithmetic you'd want more types of kinds?
01:20:04 <quicksilver> more sorts of kinds :)
01:20:12 <Cale> Baughn: Yeah. You could have kinds like  Integer -> *
01:20:35 * sjanssen would really like to see numeric kinds in GHC
01:21:18 <tieTYT2> can you give me a hint on how to define this in record syntax? data Tree a = Node a (Maybe (Tree a)) (Maybe (Tree a))
01:21:26 <Baughn> quicksilver: Right, you. The type of a type is called kind; the type of a kind is called sort. What's the type of a sort called?
01:22:00 <Cale> tieTYT2: hmm, a hint... I suppose I could give you another similar type in record syntax?
01:22:02 <tieTYT2> wait i'll give it a shot
01:22:09 <tieTYT2> well first of all
01:22:15 <tieTYT2> where does the opening bracket start
01:22:20 <tieTYT2> after the first a or before it?
01:22:24 <Cale> after the data constructor
01:22:35 <quicksilver> Baughn: a variety, occasionally.
01:22:35 <Cale> That is, after 'Node'
01:22:39 <quicksilver> Baughn: or just a metasort.
01:22:41 <tieTYT2> ok
01:22:53 <Baughn> quicksilver: ..I shouldn't have asked
01:22:56 <Cale> an algebraic variety? ;)
01:23:15 <quicksilver> no, a Heinz (51) variety
01:23:29 <quicksilver> if you have more than 51 varietys of sort, your language is unsound
01:23:33 <quicksilver> it runs out of baked beans
01:23:55 <tieTYT2> hrm, came up with this: data Tree a = Node {a leftNode :: (Maybe (Tree a)), rightNode :: (Maybe (Tree a))}
01:23:57 <tieTYT2> but it doesn't work
01:24:05 <Baughn> quicksilver: Got a better reference for that one? Heinz 51 is ungooglable
01:24:07 <tieTYT2> does a need a type?
01:24:13 <sjanssen> tieTYT2: you have to give the first element a name too
01:24:25 <yitz> Cale: agda will allow only abelian varieties.
01:24:26 <tieTYT2> oh
01:24:27 <tieTYT2> sjanssen
01:24:29 <sjanssen> tieTYT2: 'a' is a type, it needs a name
01:24:31 <Baughn> tieTYT2: Everything has to be typed for the program to compile
01:24:33 <tieTYT2> but it doesn't seem like that's true
01:24:36 <Cale> It's supposed to be 57
01:24:40 <tieTYT2> this worked: data Tree a = Node {a, leftNode :: (Maybe (Tree a)), rightNode :: (Maybe (Tree a))}
01:24:41 <quicksilver> apparently it was 57. I have a poor memory for advertising campaigns that date from before my birth :)
01:25:13 <sjanssen> tieTYT2: that doesn't mean the same thing
01:25:19 <Baughn> Cale: That worked. Sadly... ;_;
01:25:25 <tieTYT2> why does it work?
01:25:32 <tieTYT2> is that like a partial record syntax?
01:25:37 <tieTYT2> where there's no function to get the parent?
01:25:48 <Baughn> tieTYT2: You're passing in a as a type variable. Also, yes.
01:26:13 <Baughn> tieTYT2: Incidentally, you usually don't want a parent pointer in haskell - it gets really expensive to update the tree, since you end up having to change all of it
01:27:13 <tieTYT2> Baughn: hmmmmm
01:27:22 <sjanssen> tieTYT2: "a, leftNode :: Maybe (Tree a)" means two fields of type "Maybe (Tree a)" named "a" and "leftNode"
01:27:45 <sjanssen> tieTYT2: but you want a field named "foobar" that has type "a"
01:28:06 <tieTYT2> sjanssen: oh that wasn't what i expected
01:28:13 <quicksilver> I never knew that :)
01:28:15 <Baughn> tieTYT2: http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf <-- This is more advanced stuff, but you'll want to browse it at some point
01:28:38 <tieTYT2> so with that syntax I had, I could get the parent by doing a (Node ...) ?
01:28:47 <sjanssen> tieTYT2: it's a handy little syntax if you have many fields of the same type, eg. data Coord3d = C3d {x, y, z :: Integer}
01:29:08 <sjanssen> tieTYT2: I don't understand why you're asking about parents?
01:29:15 <tieTYT2> Baughn: i'll bookmark
01:29:16 <quicksilver> sjanssen: amazing they supported that little syntax and didn't support function-style definitions for record members.
01:29:18 <sjanssen> tieTYT2: AFAICT, your mistake has nothing to do with parent pointers
01:29:39 <tieTYT2> i'm not sure what a parent pointer is
01:29:48 <tieTYT2> i'm considering the first a to be a parent node
01:30:00 <sjanssen> oh
01:30:07 <sjanssen> I generally wouldn't call that a parent
01:30:19 <tieTYT2> root?
01:30:27 <quicksilver> I'd call it "this node"
01:30:30 <quicksilver> it's not always the root :)
01:30:30 <Baughn> tieTYT2: In a tree.. if you have a parent pointer, you could follow said pointer all the way up to the root
01:30:37 <quicksilver> when you're deeper in the tree, it's that node there
01:30:49 <Vq^> i'd call it contents
01:31:00 <Baughn> tieTYT2: Given how functional languages work, being able to do that also means you have to update the entire tree if anything changes. There are ways around this - zippers, say.
01:31:33 <tieTYT2> Baughn: hm
01:32:14 <sjanssen> anyway, we're not intentionally talking about parent pointers :)
01:32:20 <tieTYT2> ok i realize i don't know how to use record syntax for a type with two value constructors
01:32:29 <tieTYT2> data Tree a = Node {thisNode :: a, leftNode :: Tree a, rightNode :: Tree a)} | Empty
01:32:32 <tieTYT2> what am i missing
01:32:39 <sjanssen> nothing
01:32:52 <quicksilver> an extra )
01:32:57 <tieTYT2> oh
01:32:59 <Baughn> The possibility of having a finite tree
01:33:00 <tieTYT2> thanks
01:33:02 <tieTYT2> just noticed that
01:33:07 <Baughn> Oh, wait. Empty.
01:33:39 <Vq^> finite trees are overrated :o)
01:34:36 <tieTYT2> ok from that exercise, i predict that if the second constructor had arguments, i'd wrap it around its own set of {} to use record syntax on it
01:34:46 <sjanssen> tieTYT2: correct
01:34:50 <tieTYT2> thanks
01:35:10 <tieTYT2> what % of people in here are newbs like me trying to learn?
01:35:29 <sjanssen> I don't really know
01:35:35 <yitz> tieTYT2: nearly 100% used to be
01:35:37 <tieTYT2> it's hard for me to imagine using this professionally since it's so different to what I'm used to
01:36:03 <tieTYT2> it would be sweet if i could make something useful with Haskell at work
01:36:03 <sjanssen> but we certainly get a decent amount of newbie/learning related traffic at any given time
01:36:15 <nominolo> @seen dons
01:36:15 <lambdabot> dons is in #haskell, #xmonad, #haskell-soc and #ghc. I last heard dons speak 3h 15m 13s ago.
01:36:16 <sjanssen> yitz: huh, how recently was this?
01:36:28 <sjanssen> @users
01:36:28 <lambdabot> Maximum users seen in #haskell: 463, currently: 425 (91.8%), active: 13 (3.1%)
01:36:30 <quicksilver> sjanssen: that varies on the person :)
01:36:53 <tieTYT2> anyway i'm glad this channel is active and helpful.  It's literally the main reason I picked haskell over another functional language :)
01:37:14 <sjanssen> yitz: nevermind, I understand now.  All people in #haskell must have been Haskell newbies at some time
01:37:25 <yitz> sjanssen: i meant that nearly 100% of people on this channel used this channel as newbies at some point
01:37:32 <cjs> dons was never a Haskell newbie. :-)
01:37:35 <sjanssen> I thought you were saying there was a time when nearly 100% of the channel were newbies simultaneously
01:37:35 <Baughn> tieTYT2: I can claim with some confidence that once you get used to it, haskell becomes a superior language even for classes of programs where performance matters, and certainly most others. (In these days of multi-core CPUs.. have to thank intel for that someday)
01:37:57 <Baughn> sjanssen: There was. 1980 or so?
01:38:11 <yitz> cjs: he was born at some point
01:38:12 <tieTYT2> Baughn: even if that's true, the problem is i'd be the only one at work that could understand the code i write if I write it in haskell
01:38:15 <nominolo> sjanssen: maybe in 1990
01:38:28 <tieTYT2> luckily, that means 50% of the people at my company would know haskell :)
01:38:32 <cjs> I'm sure he was born understanding Lambda the Ultimate.
01:38:35 <tieTYT2> well 50% of the programmers
01:38:47 <sjanssen> Baughn, nominolo: times before freenode and #haskell existed don't count :)
01:39:03 <tieTYT2> is dons a contributor to the language?
01:39:15 <Baughn> tieTYT2: Let's just call it job security.
01:39:20 <tieTYT2> haha
01:39:39 <Baughn> tieTYT2: What do you mostly use now?
01:39:45 <tieTYT2> java
01:39:47 <cjs> It's hardly job security for the five programmers you replace.
01:39:49 <tieTYT2> which i like :P
01:40:07 <Baughn> Hm. Well, a doubling of productivity is hardly that unlikely, so you might end up ahead. :P
01:40:22 <tieTYT2> talking to me?
01:40:27 * Baughn nods
01:40:32 <tieTYT2> dude i'm already twice as productive
01:40:43 <Baughn> So double it again
01:40:52 <tieTYT2> the other guy sucks :)
01:41:10 <yitz> tieTYT2: what product space are you in?
01:41:16 <nominolo> sjanssen: when did freenode go online?
01:41:18 <cjs> And if he didn't suck, he'd be learning Haskell. :-)
01:41:49 <tieTYT2> yitz: www domains
01:42:11 <sjanssen> nominolo: the predecessor called 'linpeople' started in 1995
01:42:18 <sjanssen> #haskell was way after that
01:42:39 <yitz> tieTYT2: ok
01:42:48 <nominolo> i see
01:43:29 <sjanssen> late 90s, and started becoming popular in 2001
01:47:37 <tieTYT2> so far i'm really liking Real World Haskell
01:47:55 <tieTYT2> i especially like how if i'm confused, i find there's 2+ comments elaborating on what confused me
01:51:17 <quicksilver> tieTYT2: if might be helpful to the authors if you added a commment to the effect "this was confusing, but this comment cleared it up for me"
01:51:38 <tieTYT2> you think?
01:51:41 <tieTYT2> ok i'll do that in the future
01:51:51 <tieTYT2> i would have thought it would add too much noise
01:52:42 <Baughn> tieTYT2: He'll be writing those comments into the book eventually. Knowing which ones are useful would help
01:53:10 <tieTYT2> k
01:57:28 <tieTYT2> ok, so if i understand this right
01:57:40 <tieTYT2> the error function should generally be avoided because you can't recover from it
01:57:57 <tieTYT2> it seems analgous to a Java RuntimeException
01:58:10 <tieTYT2> "an error that requires programmer intervention"
01:58:53 <cjs> Yes.
01:58:55 <Baughn> tieTYT2: You /can/ catch such errors, but you usually /shouldn't/. There's no way of differentiating them
01:59:09 <cjs> "error" is like an assertion failure in C or C++.
01:59:23 <Baughn> LB does it, though, I think. The less said about that..
01:59:23 <tieTYT2> k
01:59:34 <tieTYT2> what's LB?
01:59:37 <Baughn> lambdabot
01:59:59 <czakey> @botsnack
02:00:00 <lambdabot> :)
02:00:49 <Baughn> tieTYT2: For throwing errors that can actually be caught, there's.. two or three sets of machinery, actually. Look in Control.Exception to begin with.
02:01:07 <Baughn> tieTYT2: (You usually want dynami exceptions when making your own)
02:01:11 <Baughn> *dynamic
02:01:15 <tieTYT2> the book is teaching me i could use Maybe for it
02:01:45 <Baughn> You could. Exceptions can only be caught in IO, so there's a god deal of machinery for returning errors as values
02:01:58 <cjs> You need to be careful with the performance of some of that, though.
02:02:23 <tieTYT2> i typically only worry about performance when I realize I *need* to care about it
02:02:39 <tieTYT2> otherwise, i just try to make my code as readable/maintainable as possible
02:03:09 <Baughn> Typing something like "Maybe a" /will/ break laziness, if the function making it needs to do all the work just to decide whether it should return Nothing or a value
02:03:29 <cjs> Some of the stuff I was doing to keep information I used for "exceptions" (parse errors, basically) reduced my parser speed from 7 MB/sec to 4 MB/sec, or something of that order.
02:03:35 <titusg> anyone know about setting up xmobar?
02:04:12 <cjs> But yeah, probably not a big deal in a real trading app; just when I was trying to parse a full day's worth of market data as quickly as possible.
02:04:38 <tieTYT2> Baughn: i see
02:04:44 <Baughn> tieTYT2: There's also Control.Monad.Error, but you don't want to read about that just yet
02:05:30 <Baughn> tieTYT2: Well, if you're returning data lazily - especially streamishly - you could encode the error into the data instead.
02:07:32 <dmwit> instance Foo (a, b) where ... -- this is not valid H98?
02:07:33 <yitz> tieTYT2: I agree with your approach that maintainability comes before optimization :)
02:07:35 <sjanssen> titusg: yes
02:07:43 <ketil> Baughn, I think lambdabot is a good example where catching "error" is sensible.  You don't want it to crash, just because a subsystem (e.g. running code submitted on a command line) encounters some trouble.
02:07:44 <tieTYT2> that laziness will be the death of me
02:07:48 <tieTYT2> i think i kinda didn't get it and moved on
02:07:53 <ketil> It's the Erlang way - let it crash, then restart :-)
02:07:56 <sjanssen> dmwit: that is fine
02:08:02 <tieTYT2> i mean in theory I get it: haskell only evaluates when it has to
02:08:18 <tieTYT2> but I kinda left it at that
02:08:21 <dmwit> sjanssen: Oh.  Quite.  I need to learn to read error messages better.
02:08:35 <vixey> tieTYT2: Have you looked at datatypes?
02:08:35 <Baughn> ketil: Code submitted on a command line runs in another process, though. No, it catches errors produced by the /plugins/
02:08:46 <tieTYT2> i have an unrelated question.  there's part of a function defined like this: tidySecond (_:x:_) = Just x
02:08:59 <tieTYT2> and the sentence describing it says: The first pattern only matches if the list is at least two elements long
02:09:13 <tieTYT2> but isn't that checking that the list is 3 elements long?
02:09:21 <tieTYT2> is the :_ at the end matching : [] every time?
02:09:24 <vixey> (_:x:_:[])
02:09:30 <vixey> would check it's 3 elements long
02:09:42 <cjs> The last underline matches [].
02:09:44 <tieTYT2> vixey: or (_:x:_:_) ?
02:09:47 <tieTYT2> i thought so
02:09:49 <vixey> no
02:09:52 <tieTYT2> i'll put a comment he should clarify it
02:09:55 <Baughn> The last underline matches /anything/
02:09:55 <tieTYT2> vixey: why not?
02:09:57 <vixey> (_:x:_:_) checks it's 3 or more
02:10:06 <tieTYT2> oh
02:10:13 <tieTYT2> that's what I meant to say
02:10:15 <vixey> (_:x:_:_:[]) checks it's exactly 3
02:10:18 <tieTYT2> gotcha
02:10:19 <vixey> as does
02:10:23 <tieTYT2> anyway about datatypes
02:10:26 <tieTYT2> yeah i know a bit about them
02:10:27 <Baughn> > case [1,2,3,4] of (_:x:_) -> x
02:10:37 <lambdabot>  2
02:10:46 <vixey> > repeat 4 (Just 2)
02:10:47 <lambdabot>  Couldn't match expected type `Maybe t1 -> t'
02:10:50 <vixey> :/
02:10:52 <tieTYT2> i mean, a data type is when you use: data TypeConstructor = ValueConstructor ... right?
02:10:55 <Syzygy-> > case [1,2,3,4] of (a:b:c) -> (a,b,c)
02:10:55 <vixey> > replicate 4 (Just 2)
02:10:57 <Baughn> vixey: replicate
02:10:58 <lambdabot>  (1,2,[3,4])
02:10:58 <lambdabot>  [Just 2,Just 2,Just 2,Just 2]
02:11:00 <yitz> tieTYT2: laziness is cool, that's why we're all here.
02:11:27 <tieTYT2> yitz: that comment is a little vague
02:11:37 <yitz> it was meant to be :)
02:11:39 <vixey> tieTYT: anyway.. what I was going is if you had some expression like.. we can think about  tidySecond (replicate 4 (Just 2))
02:11:39 <Baughn> tieTYT2: Might want to open that link I gave you earlier - it talks a lot about how to use laziness
02:12:41 <vixey> tieTYT: If you needed to evaluate it lazyly, you'd want to take the weak head normal form of it, which just means rather than have tidySecond at the start, you want Just, or (:) or something like that (a data constructor)
02:13:19 <vixey> tieTYT: but without evaluting anything you don't need to, to get that, meaning tidySecond will tug on replicate, getting it's weak head normal form until it can pattern match
02:13:41 <tieTYT2> hm
02:13:43 <tieTYT2> i'm confused :P
02:13:48 * Baughn is confused too. o_O
02:14:02 <vixey> tieTYT: so tidySecond will get this far evaluting its argument (Just 2:Just 2:Just 2:replicate 1 (Just 2))
02:14:04 <tieTYT2> makes me feel better
02:14:12 <vixey> tieTYT: before pattern matching it, and giving Just 2
02:14:57 <zeroflag> hey everyone.
02:14:58 <tieTYT2> as opposed to evaluating 4 "Just 2"'s and the replicate?
02:15:07 <vixey> yes exactly
02:15:12 <yitz> hi zeroflag
02:15:15 <Baughn> > let fibs = 0:1:zipWith (+) fibs (tail fibs) -- tieTYT2: Do you understand how this one works?
02:15:16 <lambdabot>  Parse error at end of input
02:15:23 <zeroflag> I'm looking for an example on how functional programming is different to procedural programming. can anyone help me?
02:15:43 <Baughn> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs -- zeroflag: Well, for one you can write this
02:15:44 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:15:55 <vixey> zeroflag: one cool example is parsec
02:16:24 <cjs> So if I've got a function with "where foo = (pack "Foo")" appended, is the compiler going to calculate that at compile time, or at least only once, or will it do it every time I enter the function? (Just curious.)
02:16:39 <vixey> zeroflag: You can write small programs that parse certain things (as you could procedurally), but you can combine programs them together in a variety of ways since they're functions
02:16:45 <quicksilver> cjs: depends if it gets lifted.
02:16:55 <zeroflag> Baughn: for one, I'm not familiar with haskell (especially not when it gets confusing) and two, I was looking for "for example if you have X, you can do Y as opposed to Z in procedural".
02:17:09 <Baughn> cjs: Whatever it does, it will do it every time it enters the function - but that might just be returning a reference to a precomputed foo
02:17:22 <quicksilver> cjs: I'm not sure what the rules are. I would expect that to get lifted to top-level and hence only done once.
02:17:22 <tieTYT2> Baughn: it's a lil confusing, i donno what zipWith is
02:17:25 <vixey> zeroflag: there's some cool examples http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
02:17:28 <tieTYT2> but i'm super tired
02:17:35 <quicksilver> cjs: it's also very likely to get inlined
02:17:41 <cjs> You mean by the optimizer, renaming if necessary.
02:17:43 <tieTYT2> i gotta go to sleep
02:17:44 <quicksilver> (and there are some optimisation rules which fire on pack)
02:17:45 <cjs> Ok.
02:17:49 <tieTYT2> i hope we can talk about this later
02:17:59 <cjs> I need to learn how to read the what's-it-called output one day.
02:18:02 <Baughn> tieTYT2: zipWith takes a function and two lists, using the function to combine elements two by two to produce a third one
02:18:12 <cjs> quicksilver, really? Cool.
02:18:13 <zeroflag> does anyone know of a website/tutorial that demonstrates how functional is different from procedural?
02:18:18 <vixey> Baughn: fibs zipWith is a really good example of lazy evaluation vs normal order
02:18:20 <cjs> Data.Binary is my favourite friend ever.
02:18:44 <Baughn> vixey: It's very blatant about it, at least
02:18:51 <Vq^> zeroflag: you have the qsort example on the Haskell page
02:19:01 <vixey> since it tells you exactly how big the recomputations at each stage are
02:19:25 <Vq^> zeroflag: http://haskell.org/haskellwiki/Introduction#What.27s_good_about_functional_programming.3F
02:19:26 <lambdabot> Title: Introduction - HaskellWiki, http://tinyurl.com/jbwo6
02:19:29 <zeroflag> mmh, thanks for the pointer.
02:19:41 <vixey> I think that qsort is a terrible example
02:19:49 <zeroflag> a quick google on "qsort haskell" got me a page with implementations of quicksort in different languages. ;)
02:19:56 <Baughn> vixey: ..shouldn't you be addressing this to tieTYT2?
02:20:02 <cjs> Oops, I mean Data.ByteString.
02:20:11 <vixey> Baughn: addressing what?
02:20:16 <zeroflag> mmmh, thanks guys.
02:20:20 <zeroflag> this should get me started. :)
02:20:27 <Baughn> vixey: Never mind
02:20:46 <tieTYT2> anyway i gotta go to sleep.  thanks for the help
02:20:49 <tieTYT2> see ya
02:20:49 <Baughn> zeroflag: You do realize that you have to actually /learn/ haskell to understand what's good about it, I hope?
02:21:02 <Baughn> zeroflag: Well, or another language with similar functionality, or the equivalent math, but..
02:21:17 <zeroflag> Baughn: I'm not exactly looking to learn/understand haskell, I'm trying to understand the functional programming paradigm.
02:21:26 <tieTYT2> Baughn: do you think that I can learn a lot more about haskell and take advantage/learn lazy evaluation later?
02:21:43 <Baughn> tieTYT2: Not really; it's such a basic concept.
02:22:06 <Baughn> tieTYT2: You should at least understand the zipWith example above, and probably also how fix works. There are more subtleties, but you can learn /those/ later
02:22:16 <zeroflag> Baughn: I do know about lambda expressions and all sorts of basic functional programming constructs (as found in C# and other trying-to-add-functional-features languages), but the core concept still eludes me.
02:22:38 <vixey> zeroflag: did you look at the stuff I linked for you?
02:23:07 <tieTYT2> hm i see
02:23:08 <Baughn> zeroflag: There isn't a single core concept - not one that would be dramatic, at least. The usefulness of functional languages results from probably dozens of factors, all fitting together..
02:23:22 <zeroflag> vixey: all tabs still open, I'll read through it until I "get it". ;)
02:23:25 <tieTYT2> ok, nite
02:23:47 <Baughn> zeroflag: Now, laziness is a dramatic concept, but most functional languages don't use it by default, so.. :/
02:24:28 <zeroflag> Baughn: so "functional programming" isn't like object oriented programming where you HAVE to understand THE concept in order to use it properly, but rather a set of advanced programming ideas joined together to form an easier way of programming?
02:25:06 <Baughn> zeroflag: Right. Which is very appropriate, really, since one of the core concepts is to combine many small functions to get large effects. :D
02:25:29 <zeroflag> mmhhmhh...
02:25:37 <Baughn> zeroflag: That's why you more or less have to learn one to understand. YOu /could/ write a paper on it - a rather large paper - but by the time the reader understands the paper he'll already have done most of the work of learning any given functional language..
02:25:42 <zeroflag> so there isn't actually THAT much that I missed from understanding FP...
02:26:14 <zeroflag> so it isn't actually "OOP vs FP" because you can use FP inside an OOP design, right?
02:26:22 <Baughn> Or the other way around, yes
02:26:29 <zeroflag> mmhh, good.
02:26:46 <zeroflag> because I'm looking to provide FP concepts on objects.
02:26:58 <Baughn> But a language that hasn't been designed from the ground up for FP is typically very bad at it. You /could/ use FP methods in Java or C, but you wouldn't like it
02:27:00 <zeroflag> sortof "every function is an object".
02:27:52 <vixey> zeroflag: unless you start with a blank canvas when approaching a new language you will miss a lot
02:27:56 <Baughn> zeroflag: One thing people will keep telling you is that OO only fits maybe 20-30% of a typical program. The standard deviation there is large, so.. quite often you're better off without any at all
02:28:18 <Baughn> zeroflag: You shouldn't try to force functions to fit some OO mold without a very good reason for it
02:28:21 <zeroflag> vixey: that's why I love OOP designs. if you're good, you can have them as extensible as you want. :)
02:28:51 <Vq^> zeroflag: you make it sound like OOP is better than the alternatives for extensibility
02:28:51 <Baughn> zeroflag: And if you're good with FP, you can make /those/ designs just as extensible with less code and less headache
02:29:27 <Baughn> zeroflag: OOP has one big idea. FP has many small ones - including OO - and encourages you to pick the one that fits right now.
02:29:43 <zeroflag> Baughn: the reason is that functional programming is (IMO) THE way to implement parallelism (threading) but it's not suited (again IMO) for large application design (note, design. you can very well write large applications in FP, but for design purposes OOP is easier to understand/implement).
02:30:23 <quicksilver> OOP? Easy to understand?
02:30:30 <Baughn> zeroflag: I'd have to disagree. Anyway, what's stopping you from mixing them?
02:30:33 <zeroflag> quicksilver: I could say the same thing about FP. ;)
02:30:34 <vixey> quicksilver: that's why they teach it to kids
02:30:37 <quicksilver> excuse me while I splutter my coffee all over the monitor.
02:30:41 <quicksilver> I have taught it kids.
02:30:44 <quicksilver> to kids.
02:30:49 <quicksilver> It's a bloody nightmare.
02:30:52 <vixey> hehe
02:30:52 <zeroflag> Baughn: the design of said languages that weren't designed for FP.
02:30:55 <quicksilver> (and not only because of my teaching)
02:31:10 <Baughn> zeroflag: So use CL, O'Caml, Haskell or something
02:31:22 <zeroflag> I think once you wrap your head around OOP it's very easy to implement.
02:31:31 <Vq^> zeroflag: large application is all about modules of functionallity
02:31:40 <Vq^> zeroflag: thats not specific to OOP
02:31:40 <pejo> zeroflag, nothing is hard once you've understood it.
02:31:41 <vixey> zeroflag: not sure where you got the idea that fp isn't suitable for large applications but I'm pretty certain that's false
02:31:52 <zeroflag> FP on the other hand let's you "discover" things rather than having the one point from which on you understand it, and before that it's a mess.
02:32:18 <Baughn> True dat. Hm, I really need to get down with arrows one of these days..
02:32:23 <Vq^> zeroflag: only if we invent new abstractions
02:32:32 <Vq^> zeroflag: with OOP you don't even have that choice
02:32:37 <zeroflag> I am beyond that point in OOP and I am now "discovering" FP - and I like both concepts, but not the way they are separated.
02:32:48 <vixey> Vq^: yes you do
02:32:57 <cjs> zeroflag, One thing that will give you a good feel for part of FP is _The Little Schemer_. A bit of it.
02:32:59 <zeroflag> OOP is all about abstraction.
02:33:07 <zeroflag> it is THE core purpose of OOP to abstract.
02:33:14 <Baughn> zeroflag: They're /not/ separated. I keep telling you - you can do OOP just fine in most functional languages.
02:33:17 <solrize> zeroflag, google "why functional programming matters" if you don't mind examples that are a bit mathematical
02:33:18 <vixey> Vq^: You can embed languages via a collection of objects and stuff like that
02:33:36 <cjs> I've just made the Big Switch like two months ago, and I can tell you, OOP doesn't do half the abstraction you can do in FP.
02:33:44 <Vq^> vixey: well, it falls a bit short in my opinion
02:33:53 <vixey> Vq^: (I find it rather clunky compared to doing it with higher order functions though)
02:34:00 <Vq^> vixey: just look at all things constructed with arrows
02:34:12 <cjs> OOP does an extremely poor job of control abstraction. For a simpler example than arrows, how about the lack of fold?
02:34:26 <zeroflag> Baughn: yes, you can do OOP in functional languages. but you can't do object oriented programming with functional programming - or actually, more the other way around. they're still separate concepts; they just don't conflict with each other so they can be used in the same language.
02:34:39 <vixey> cjs: different paradaigm
02:35:07 <cjs> Yes, different, but fold to me was a lot easier to grasp at first.
02:35:17 <Baughn> zeroflag: If they don't conflict, then you /can/ combine them. Trust me on this; I'm working on a rather large haskell program right now, I've been using OOP quite a lot, and they combine very well.
02:35:23 <zeroflag> solrize: I almost failed math... but I'll give it a try anyway. ;)
02:35:37 <solrize> http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
02:35:37 <lambdabot> Title: Why Functional Programming Matters
02:35:39 <zeroflag> Baughn: you don't see my point.
02:36:02 <zeroflag> Baughn: I don't want to use functional programming in objects or the other way around. I want to use functional programming ON objects.
02:36:15 <Baughn> zeroflag: Also, this might be a low blow, but.. you said it yourself: Threading is easier in functional languages. Given that threading is almost a requirement to get good performance now, doesn't that mean you should prefer FP over OO if you have to make a choice?
02:36:22 <solrize> zeroflag, maybe you want erlang?
02:36:26 <zeroflag> Baughn: imagine you do functional programming, but instead of functions you have objects, and objects that have functions.
02:36:32 <solrize> erlang processes are sort of like objects
02:36:53 <Baughn> zeroflag: I don't have to imagine it; I've been doing that. Oh, but of course I still have plain old functions.
02:37:26 <zeroflag> solrize: in fact, some of my inspiration comes from erlang. but erlang is kind of an "underground language". what I want is a similar concept implemented for one of the (industry's) major OOP languages (C++, C#, Java).
02:37:30 <cjs> zeroflag: you can get a bit of part of the feel by using a lot of value objects, and instead of using mutator methods, having methods return new value objects.
02:37:40 <solrize> python?
02:37:48 <cjs> I used to do a lot of that in Ruby.
02:37:48 <solrize> scala?
02:37:56 <Baughn> zeroflag: That's not going to happen. It would require a major rewrite, and retraining..
02:38:10 <zeroflag> Baughn: that's what I'm trying to investigate.
02:38:13 <Vq^> zeroflag: but those languages are procedural
02:38:29 <pejo> zeroflag, Erlang is probably one of the most used functional naguages in the industry though.
02:38:46 <vixey> hehe
02:38:49 <vixey> pejo++
02:38:50 <Baughn> zeroflag: There are haskell compilers targeting the jvm, (Or was it .net? Or both?) but of course that just means a better FFI to those particular languages
02:39:06 <zeroflag> I think I have to add a term to this conversation to make it more clear: Tasks. otherwise known as the "command pattern" in OOP.
02:39:43 <cjs> pejo, So well used that the training course I'm taking from John Hughes next month is in Erlang!
02:40:03 <zeroflag> my idea is to have Tasks as a replacement of functions, allow functional programming constructs to be formed with those tasks, but have those tasks behave like objects as well.
02:40:53 <cjs> zeroflag, That's admirable, but you do have to realize you're only going to get a second-rate, less powerful version of what we do in FP doing that.
02:41:37 <zeroflag> cjs: the integration of Objects with Functions is more important to me right now than having EVERY FP feature implemented. ;)
02:42:02 <zeroflag> in fact, I think having EVERY FP feature might be impossible because, as you said, FP is not one concepts, it's dozens of them.
02:42:13 <cjs> Fair enough. Though you should qualify that integration: you want to do it in an OO language.
02:42:28 <zeroflag> yes.
02:42:32 <zeroflag> in C# actually.
02:42:45 <zeroflag> which offers "functions" and some functional programming constructs...
02:42:55 <zeroflag> but they're separated from objects.
02:42:58 <zeroflag> which annoys me.
02:43:34 <zeroflag> I was actually trying to implement a _simple_ threading library that can put function/method-calls on different threads.
02:43:53 <vixey> it seems like you should get acquainted with fp (by writing something substantial in haskell) and then design and implement your own language
02:44:09 <zeroflag> while I was on the topic of "functions" I investigated some FP concepts and now I want to allow (some of) them on those "Tasks" of mine.
02:44:41 <vixey> zeroflag: Have you heard of CLOS by the way?
02:44:42 <zeroflag> so, to get back to why I came here in the first place, I just wanted to make sure I understand at least some of those concepts before I start to implement them. ;)
02:44:45 <Baughn> zeroflag: Don't underestimate that handiness of being able to say "map munge l" at some arbitrary point
02:44:50 <cjs> I'd definitely say you want to spend a few full-time months writing something substantial in Haskell if you really want to understand what you're trying to do, and do a good job at it.
02:44:53 <zeroflag> mmh, no. never heard of that.
02:45:28 <vixey> zeroflag: You should certainly get the book Art of the Meta-Object Protocol
02:45:31 <mm_freak_work> i didn't follow the entire discussion, but zeroflag, your mistake is to _compare_ FP with OOP
02:46:02 <vixey> zeroflag: It's a description and meta circular definition of a functional object system
02:46:08 <zeroflag> cjs: I have to agree. problem with that is that I also have to watch language/OOP constraints. and some things (especially syntax constructs) conflict with those constraints from the start.
02:46:23 <vixey> (and more importantly the metaobject protocol)
02:46:28 <zeroflag> vixey: mmh, I didn't know there was such a thing.
02:46:44 <vixey> but anyway if you're into OO this should be pleasingly mind bending :)
02:47:33 <cjs> zeroflag, Sure you do. But that seems orthogonal to the point.
02:47:43 <zeroflag> I think this "meta-object protocol" is quite similar to what I know as "reflection".
02:48:11 <zeroflag> cjs: to be honest, I thought about it but 1) I'm a lazy bastard and 2) I have time constraints. ;)
02:48:24 <cjs> zeroflag, not really, no. But you are familiar with the Smalltalk/Ruby paradigm, where a Class is just an Object, right?
02:48:47 <cjs> zeroflag, Well, you're probably not going to do a great job at it, then. Not much you can do about that if you don't have the time.
02:48:54 <zeroflag> cjs: and 3) there's an actual application for that Task library and my priority has to be the requirements of that application.
02:49:07 <zeroflag> cjs: afraid so. :/
02:49:45 <zeroflag> cjs: I wish I could do "more" (from the FP-person's point of view), but I must not scare off the OOP crowd.
02:50:16 <vixey> that's not something you should worry about
02:50:16 <cjs> In your case, you might be better off sticking to the usual Design Patterns stuff.
02:50:45 <zeroflag> anyway, I'll have a look at the things you guys mentioned.
02:51:14 <zeroflag> I think I'll find some way to keep my system extensible enough to allow some of these features, in the future.
02:51:17 <zeroflag> thanks a lot. :)
02:51:18 <Vq^> and maybe switching to a .net language that thinks of functions as objects
02:51:35 <Vq^> or combining with one
02:51:42 <zeroflag> Vq^: all .NET languages have a function-"object". it's called a "delegate". ;)
02:52:00 <vixey> delegates are very different imo
02:52:10 <Vq^> zeroflag: yes, but in some you can write a function and it's directly an object
02:52:23 <Vq^> zeroflag: check out IronPython
02:52:39 <zeroflag> Vq^: Boo, for example, allows a bit more on those delegates, but it's still just a struct that can't be inherited or extended.
02:53:40 <pjdelport> <zeroflag> I was actually trying to implement a _simple_ threading library that can put function/method-calls on different threads.
02:53:41 <cjs> I am annoyed by the way I keep wanting to use "Unknown" as a constructor for about six different data types.
02:53:47 <cjs> Or rather, annoyed by the way I can't do it.
02:54:13 <pjdelport> zeroflag: in Python, for example, you can just deferToThread(f, ...)
02:54:18 <Vq^> zeroflag: so basicly you want to extend functions by inheritance instead of HOF?
02:54:39 <nominolo> cjs: that's what some people call a functional anti-pattern
02:54:42 <zeroflag> pjdelport: I could do that in C# as well with a little helper class. but I want something different.
02:54:47 <pjdelport> (that's from Twisted, specifically)
02:55:00 <nominolo> use a maybe or similar type
02:55:08 <zeroflag> Vq^: not exactly... I want to extend functions by composition.
02:55:29 <cjs> nominolo, as in, I should be doing something different? Got any suggestions?
02:55:38 <pjdelport> cjs: type class?
02:55:50 <pjdelport> a la mzero/mempty
02:56:03 <nominolo> if you have the same concept in several types it may be useful to extract that concept
02:56:27 <Vq^> zeroflag: thats certainly worth striving towards
02:56:47 <cjs> pjdelport, Can I use a type class to polymorphise (is that a word?) a constructor?
02:56:54 <Vq^> zeroflag: i guess it can get a bit awkward in C# thought
02:56:57 <pjdelport> cjs: sure
02:57:14 <zeroflag> Vq^: the idea is... in OOP a good programmer will build a tree of objects that describe the program. I want to be able to do the same for the execution... which is based on Tasks. I want to build a tree (at runtime) from the tasks provided by the objects, combine and modify that tree but, essentially, execute it as parallel (threaded) as possible.
02:57:26 <nominolo> cjs: don't be afraid of wrapping.  you can "reach inside" with fmap
02:57:29 <nominolo> for example:
02:57:49 <nominolo> > (++"foo") <$> Just "bar"
02:57:53 <cjs> Hmmm. Ok, I'll put that on my list to experiment with.
02:57:58 <nominolo> @bot?
02:57:58 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
02:58:00 <lambdabot>  Just "barfoo"
02:58:29 <pjdelport> cjs: think of return
02:58:59 <pjdelport> mempty and mzero from Monoid and MonadPlus are just nullary analogs of that
02:59:02 <pjdelport> :t mempty
02:59:05 <lambdabot> forall a. (Monoid a) => a
02:59:06 <pjdelport> :t mzero
02:59:08 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
02:59:26 <cjs> The issue there, I guess, is just that it's bringing a monad into something that otherwise doesn't really need one; I'm dealing with things such as stock types of Future, Call Option, Put Option, or Unknown and Don't Care.
02:59:26 <pjdelport> or, for that matter
02:59:31 <pjdelport> :t minBound
02:59:32 <lambdabot> forall a. (Bounded a) => a
02:59:34 <pjdelport> and so on
03:00:07 <pjdelport> cjs: i just meant return as an example of a polymorphic constructor
03:00:13 <cjs> Although, come to think of it, I can see ways I can get more clever in my processing chain by using monads, and get rid of a load of case statements.
03:00:15 <cjs> Hmmm.
03:00:32 <cjs> pjdelport, Oh, I see! I was thinking a constructor starting with a capital letter, if you know what I mean.
03:01:04 <cjs> Which I'm still not convinced should be so special, but whatever.
03:01:29 <pjdelport> yeah, those are monomorphic
03:05:19 <snies> Hello, I am new to Haskell (Python and C++ background). Where could i find a nice overview of haskell data structures and their respective efficiencies (like list read nth element O(n), array read nth element O(1) etc. ?
03:05:35 <dmwit> Okasaki's book is good.
03:06:25 <ToRA> most of the documentation for Data.Map/Data.Set/Data.Sequence etc. tell you the complexity of the operations, and link to the papers documenting them
03:06:32 <ToRA> eg http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Sequence.html
03:06:33 <lambdabot> http://tinyurl.com/3dzkp8
03:07:02 <snies> @dmwit: Paper or online Book ?
03:07:02 <lambdabot> Unknown command, try @list
03:07:09 <mm_freak_work> zeroflag: if you want to make intelligent use of parallelism, FP is just for you, but maybe OOP isn't
03:07:29 <dmwit> snies: It's a dead-tree thing, though I think his thesis (an early version of the book) is online.
03:07:53 <snies> Thank you.
03:08:06 <mm_freak_work> in FP, the parallelism can be made pretty implicit, while (as i've understood) you want to think in threads and processes, and control them explicitly
03:08:08 <dmwit> ?hoogle Set (Set a) -> Set a
03:08:09 <lambdabot> No matches, try a more general search
03:09:59 <zeroflag> mm_freak_work: zeroflag: if you want to make intelligent use of parallelism, FP is just for you, but maybe OOP isn't <-- exactly my point - and what I'm trying to change. ;)
03:11:35 <mm_freak_work> zeroflag: i said 'maybe' intentionally…  a lot of people coming from the imperative world like to control every detail…  that includes me, too, and i had to make a big change in my way of thinking (i'm coming from C and C++)
03:12:15 <mm_freak_work> if you can change your mind, then FP will work amazingly for you
03:12:46 <zeroflag> mm_freak: well, coming from C# and having a FP-fanatic cousin (/me kicks mauke), I hope it won't be too tough for me. ;)
03:14:47 <cjs> Wow, Debug.Trace.trace works amazingly well with HUnit.
03:16:04 <yitz> @type Data.Set.unions . Data.Set.toList
03:16:07 <lambdabot> forall a. (Ord a) => S.Set (S.Set a) -> S.Set a
03:16:40 <dmwit> yitz: Thanks, but I realized I'm going about this all wrong, anyway. =P
03:16:47 <yitz> :)
03:18:48 <cjs> WTF do I keep writing non-monadic parsers? I'm a moron.
03:18:54 <vixey> heh
03:19:59 <lilac> cjs: sometimes Parsec is too constraining?
03:20:57 <_sk> hi guys, i am just wondering, how often do you fight with haskell the language? i do it quite often :(
03:21:14 <cjs> That's true, but that's no reason for me to write a non-monadic one. I just get into a big hairy, undebugabble mess of taking and dropping from ByteStrings, and end up re-doing it.
03:21:35 <vixey> _sk: why do you feel like you are fighting?
03:21:41 <cjs> _sk, Lots. then again, I spend much less time fighting with my unit tests.
03:22:08 <lilac> cjs: depends on what sort of parsing you're doing. sometimes, a simple stream processing task is most elegantly phrased as a simple recursive function
03:22:17 <yitz> _sk: I fight with myself. Programming languages are only there to help.
03:22:21 <_sk> because compared to languages like ruby, you really need to know the language damn well to use it
03:22:26 <cjs> But I'd give it a couple of hundred hours of programming, and a couple of thousand lines of code, before you even think about giving up. It gets easier.
03:22:39 <_sk> that's what i think, to use haskell you need to know it rather well
03:23:20 <cjs> lilac, Hmm, there's an idea! Mine ends up being a series of functions that are basically a big pile of ifs, many cases returning "Not parsable," but it could be fairly clean given what I'm parsing.
03:23:25 <yitz> _sk: ruby is easy to get started with because it is similar to the languages we grew up with
03:24:09 <lilac> _sk: i fight with haskell rather a lot (i'm a relative newbie). but i'm coming to the realisation that when i fight, it's mostly because i haven't fully thought through what i want to do, and my initial conception was subtly wrong
03:24:36 <_sk> yitz: i do agree, i am only few months into haskell maybe that
03:24:45 <_sk> 's y i feel the way i do
03:24:48 <qwr> _sk: but haskell has very simple core language. just the implications of it are many.
03:25:08 <yitz> _sk: other than getting used to a whole new way of looking at things, you can do a lot with a simple subset of Haskell just like Ruby.
03:25:14 <_sk> qwr: i do agree with u, the core is rather simple
03:25:17 <lilac> cjs: i'm writing a c preprocessor. the early stages ("\\\n" -> "", trigraphs, comments -> " ", etc) phrase really nicely as recursive functions which I can elegantly compose together. for the actual tokenization I use parsec.
03:25:26 <pjdelport> learning the type system is probably the big thing
03:25:52 <yitz> pjdelport: that also has a simple core that's good enough for a lot of things.
03:26:30 <_sk> i was looking at the newtype vs data thing, then I realized that Prelude.undefined when passed into any functions, it wouldn't have it's type checked, or it matches any type, is my understanding correct?
03:26:34 <dcoutts> SamB: do you want to report a feature request for cabal to track whether the profiling version of libs are available, so that it could go and build the profiling version of deps etc
03:26:34 <lambdabot> dcoutts: You have 3 new messages. '/msg lambdabot @messages' to read them.
03:26:56 <lilac> cjs: but i'm wondering whether i should have written them monadically -- currently, dealing with illegal input such as a missing trailing newline, unclosed comment, etc is a little fiddly
03:26:56 <cjs> lilac, have you considered a monadic version? I wrote a monadic parser last week, and though very bottom level stuff was a bit clunky, after that everything composes like a dream.
03:27:07 <yitz> _sk: right
03:27:08 <qwr> _sk: undefined has free type variable as result type
03:27:18 <yitz> @type undefined
03:27:21 <lambdabot> forall a. a
03:27:40 <vixey> :t undefined + 1
03:27:40 <cjs> lilac, for me, having the state flow through most stuff without trouble was quite nice.
03:27:41 <lambdabot> forall a. (Num a) => a
03:27:44 <_sk> yitz: qwr: icic, and I didn't know about that @@
03:28:00 <vixey> :t undefined ++ "foo"
03:28:02 <lambdabot> [Char]
03:28:09 <yitz> > sqrt undefined
03:28:11 <lambdabot>  Exception: Prelude.undefined
03:28:24 <qwr> > head ("foo" ++ undefined)
03:28:26 <lambdabot>  'f'
03:28:28 <cjs> And errors are easy, just 'parseError "foo is broken"'.
03:28:42 <lilac> cjs: writing a multi-pass lexer like CPP using Parsec is too hard, if you want Haskell to be able to fold them together into a single pass... and I'm not up to writing my own parser combinator at this point
03:29:08 <_sk> qwr: yitz: thanks a lot for pointing that out...
03:29:38 <_sk> i guessed as much but I totally forgot about using :type in ghci :D
03:29:57 <lilac> cjs: but my code is becoming increasingly monadic, so i think that means i'm learning
03:30:04 <cjs> lilac, it's actually not as hard as you'd think, once you've studied the parsing chapter in Hutton a bit.
03:30:08 <mm_freak_work> > 0 * undefined
03:30:09 <lambdabot>  Exception: Prelude.undefined
03:30:14 <mm_freak_work> > undefined * 0
03:30:15 <lambdabot>  Exception: Prelude.undefined
03:30:20 <mm_freak_work> hmm
03:30:21 <lilac> cjs: the trouble is the various stacked source->source translations
03:30:35 <mm_freak_work> > const 3 undefined
03:30:36 <lambdabot>  3
03:30:37 <cjs> Hm, yes, those could be nasty.
03:30:54 <cjs> Serves you right for writing cpp. :-)
03:30:58 <lilac> heh
03:31:12 <qwr> mm_freak_work: you are forcing the undefined thunk
03:32:12 <mm_freak_work> qwr: for (*) i thought, maybe if one parameter is 0, then it doesn't force the other, which seems to be wrong
03:32:44 <vixey> > 0 * (1/0)
03:32:45 <lambdabot>  NaN
03:34:07 <lilac> cjs: trouble is, there's lots of them, and they all cause pain. plus, i want a single-pass compiler, and parsec does not appear to compose with itself (there's no GenParser t1 st t2 -> GenParser t2 st t3 -> GenParser t1 st t3)
03:34:30 * lilac wonders how hard such a thing might be to write
03:36:10 <qwr> lilac: if your syntax isn't complicated, the rec-descent parsing should be quite easy
03:38:46 <lilac> qwr: i've been looking for better ways of doing it, and i'm sure there is one, but i've not found it yet.
03:40:04 <yitz> lilac: try m4 instead
03:41:00 <lilac> yitz: the macro language m4?
03:41:03 <eu-prleu-peupeu> hello haskell
03:41:25 <yitz> yeah, just trying to be contrary :)
03:41:40 <yitz> hello eu-prleu-peupeu
03:42:40 <quicksilver> mm_freak_work: all the arithmetic operators are strict in both sides.
03:42:56 <quicksilver> mm_freak_work: they defer to the underlying machine capabilities, hopefully.
03:45:00 <mm_freak_work> true
03:45:50 <mm_freak_work> > atan2(-1, undefined)
03:45:51 <lambdabot>   add an instance declaration for (RealFloat (a, a1))
03:46:18 <mm_freak_work> > atan2(-1, 0)
03:46:21 <lambdabot>   add an instance declaration for (RealFloat (a, t))
03:46:24 <mm_freak_work> ?!
03:46:24 <lambdabot> Maybe you meant: . ? @ v
03:46:35 <mm_freak_work> uhm
03:46:37 <mm_freak_work> lol
03:46:44 <eu-prleu-peupeu> im going to name my son "haskell"
03:46:46 <mm_freak_work> > atan2 (-1) undefined
03:46:48 <lambdabot>  Exception: Prelude.undefined
03:47:33 <mm_freak_work> my C origins =)
03:48:23 <ToRA> > uncurry atan2 (-1, undefined)
03:48:25 <lambdabot>  Exception: Prelude.undefined
03:50:51 <mm_freak_work> > sum [1..] + undefined^2
03:51:03 <lambdabot>  Exception: Time limit exceeded
03:51:18 <mm_freak_work> hah!  bottom + undefined = bottom =)
03:58:16 <mm_freak_work> > merge [1..3] [4..6]
03:58:17 <lambdabot>   Not in scope: `merge'
03:58:33 <mm_freak_work> > Control.Concurrent.merge [1..3] [4..6]
03:58:34 <lambdabot>   Not in scope: `Control.Concurrent.merge'
04:05:58 <cjs> Home time. Ciao.
04:06:04 <BeelsebobWork_> for the sake of infix/prefix functions, does ∪ count as a symbol, or a letter?
04:06:17 <BeelsebobWork_> i.e. is ∪ infix, or prefix?
04:06:37 <yitz> BeelsebobWork_: I can't see that character. What is it?
04:06:54 <mauke> U+222A (e2 88 aa): UNION [∪]
04:06:54 <BeelsebobWork_> yitz: unicode union symbol
04:07:01 <Taggnostr> /charset utf-8
04:17:14 <ToRA> win
04:17:15 <ToRA> Prelude> let (∪) = (+) in 3 ∪ 4
04:17:15 <ToRA> 7
04:17:20 <ToRA> Prelude> let ∪ = (+) in ∪ 3 4
04:17:21 <ToRA> <interactive>:1:4: parse error on input `*'
04:17:26 <ToRA> :o
04:18:11 <mauke> > 0x222A `mod` 256
04:18:12 <lambdabot>  42
04:18:19 <mauke> > chr (0x222A `mod` 256)
04:18:20 <lambdabot>  '*'
04:19:23 <matthew_-> now, use this fact to create a unicode source file that when loaded fails type checking and the error message resembles a huge fuzzy green lambda
04:21:28 <BeelsebobWork_> ahahahahahahaha
04:29:48 <Axman6> wow, i didn't expect this chan to be anywhere near this big
04:30:36 <vegai> might be the biggest programming language channel in freenode
04:30:37 <yitz> Axman6: Actually, there are a few overflow channels.
04:30:56 <Axman6> excellent
04:31:25 <Axman6> pitty i didn't have a look for this while we were still doing haskell at uni. moved on to java now. yay...
04:32:41 <Zao> Axman6: Languages are not mutually exclusive.
04:32:48 <Axman6> i know
04:33:11 <Axman6> and i plan to keep using haskell when i can. so much fun
04:33:29 <yitz> Zao: they may be mutually exclusive on homework assignments, though.
04:34:04 <Axman6> well, we're doing the same assignment twice, once in haskell, once in java
04:34:06 <quicksilver> you could always write a haskell interpreter in Java, and the do the rest of your homework in haskell.
04:34:11 <quicksilver> That might not be easier though :)
04:34:15 <Axman6> heh
04:34:36 <yitz> we already have one for JavaScript
04:34:51 <yitz> oh, and Erlang now
04:35:55 <yitz> I'm not sure what grades you'll get if you hand in the code they produce, even if it works.
04:37:02 <Axman6> if it's haskellified, my lecturer will like it. he does a lot of research in haskell, and there's some stuff in ghc from him too
04:37:31 <yitz> how about if it's illegible gibberish?
04:37:45 <Axman6> not so much
04:37:54 <kaol> can anyone think of an easy way to colorize putStrLn output?
04:38:05 <Axman6> hilighter
04:38:17 <Axman6> sorry
04:38:24 <mauke> ansi escapes, assuming your terminal supports them
04:38:58 <kaol> I'm using regular xterm, it should
04:39:35 <osfameron> dammit, code-plumbing is so dull :-(
04:40:24 <yitz> @google ansi color escape codes
04:40:25 <lambdabot> http://en.wikipedia.org/wiki/ANSI_escape_code
04:43:55 <xpika> does labmdabot work the same still?
04:44:15 <xpika> > 2
04:44:16 <lambdabot>  2
04:46:47 <yitz> xpika: a few things are a little weird now
04:46:55 <yitz> > (+2) . Just 4
04:46:57 <lambdabot>  Just 6
04:47:41 <kaol> > putStrLn $ ((toEnum 27):"[32m") ++ "hello"
04:47:42 <lambdabot>  <IO ()>
04:47:54 <snies> One question about lazy evaluation: Do I understand correctly that when doing this:
04:47:55 <mauke> > "\e"
04:47:55 <lambdabot>  Illegal escape sequence at ""\e"" (column 1)
04:48:00 <snies>     fib :: Int -> Int
04:48:01 <mauke> > "\ESC[32m"
04:48:02 <lambdabot>  "\ESC[32m"
04:48:12 <kaol> yay. (use 39 to reset back to gray on black)
04:48:21 <snies> HAskell memoizes the intermediate results ?
04:48:26 <mauke> kaol: what if the default color isn't gray on black?
04:48:42 <mauke> kaol: use "\ESC[m" to reset
04:48:48 <mauke> snies: no
04:48:48 <quicksilver> snies: no.
04:49:00 <snies> Why?
04:49:08 <mauke> because it doesn't
04:49:12 <quicksilver> http://www.google.com/search?client=safari&rls=en&q=automatic+memoization+haskell&ie=UTF-8&oe=UTF-8
04:49:13 <lambdabot> Title: automatic memoization haskell - Google Search, http://tinyurl.com/6av8r6
04:50:44 <yitz> snies: sometimes it does, if the compiler decides to reuse a value. When to do that is up to each compiler.
04:50:59 <snies> ok, but call fib often like: forM_ [0..35] $ \i ->
04:51:31 <quicksilver> existing haskell compilers will never memoize functions.
04:51:35 <quicksilver> under no circumstances.
04:51:40 <quicksilver> there is no such optimisation.
04:51:42 <snies> ok, thanks
04:51:51 <quicksilver> you can imagine optimisations but they don't exist.
04:52:01 <quicksilver> however, it's simple enough to memoize if you choose to.
04:54:29 <SamB> hmm, I went to write a safe coercion function for Agda, and found that the function I was about to write was already there under another name
04:54:59 <kosmikus> hehe. let's rewrite Hoogle for Agda :)
04:56:06 * SamB wonders why they called it ≡₁-subst
04:56:57 <kosmikus> hmm, I can't read that character on my terminal.
04:57:13 <mauke> U+2261 (e2 89 a1): IDENTICAL TO [≡]; U+2081 (e2 82 81): SUBSCRIPT ONE [₁]; U+002D (2d): HYPHEN-MINUS [-]
04:57:20 <SamB> that was just the "equal" symbol with three lines
04:57:30 <SamB> mauke: uh
04:57:40 <SamB> why the heck did you include the dash in that?
04:57:59 <idnar> maybe he couldn't read it :P
04:58:20 <mauke> I wasn't sure whether it was - or – :-)
04:58:25 <SamB> hehe
04:59:07 <SamB> why would they go to all the trouble of using nonstandard dashes, when they usually look indistinguishable from the ordinary one in fixed-width fonts?
04:59:28 <SamB> ... and when they would cause major confusion
04:59:40 <mauke> ｄｏｎ＇ｔ ａｓｋ ｍｅ
05:00:08 <SamB> heh
05:00:12 <kosmikus> SamB: the function is called =-subst because it allows you to substitute an y for an x in any context P
05:00:14 <SamB> I should use those sometime
05:00:31 <SamB> kosmikus: I still think the name "coerce" is clearer
05:00:57 <SamB> though now that I think of it...
05:01:02 <kosmikus> no, I wouldn't find it clearer ;)
05:01:48 <SamB> I think maybe the original application I had in mind would work better with ≡-subst...
05:01:58 <SamB> kosmikus: why not?
05:02:39 <kosmikus> matter of taste, I guess
05:03:05 <mattam> It's the leibniz substitution principle.
05:03:40 <mattam> So I guess the name is pretty well established now.
05:03:42 <SamB> it seems like it does the main thing you can do with unsafeCoerce, except you have to prove it in code, rather than just being trusted to prove it on your own
05:04:05 <kosmikus> mattam: yes, I think the Leibniz reference is probably the reason why I think of it as substitution
05:21:03 <snies> I am just reading through first pages of okasaki's "Purely Functional Data Structures" and he makes a big point in "that lazy evaluation is necessary to implement amortized data structures purely functionally" but he considers lazy to also mean memoizing. But I just learned from this channel that haskell compilers don't memoize, now I am a bit puzzled.
05:21:31 <snies> any comments on that?
05:21:31 <mauke> no, he doesn't
05:21:34 <kristofer> memoize?
05:21:43 <mauke> kristofer: caching of return values
05:21:51 <kristofer> yeah.. found it :)
05:22:05 <mauke> snies: okasaki is talking about repeated evaluation of the same variable
05:22:26 <mauke> i.e. not f 42 + f 42, but let x = f 42 in x + x
05:22:36 <mauke> in the latter case f will only be called once
05:24:38 <snies> ok so when i use datastructures like map f(x) on say [1,2,3,2] then would it compute f(2) twice ?
05:25:20 <mauke> yes
05:27:21 <snies> but i think thats just not what okaski expects for his armortized data structures.
05:28:20 <snies> qoute: Hence, we must find a way to guarantee that if the first  application of to is expensive, then subsequent applications of to will not be.
05:28:45 <snies> quote: But now consider call-by-need (i.e., lazy evaluation with memoization). If contains some  suspended component that is needed by , then the first application of to will force the  (potentially expensive) evaluation of that component and memoize the result. Subsequent op-  erations may then access the memoized result directly. This is exactly the desired behavior!
05:32:37 <mauke> yes
05:32:38 <yitz> snies: I think he is referring to something like let x=2+3 in [1,x,2,x] where x is only computed once.
05:32:43 <mauke> that's a different kind of memoization
05:33:26 <snies> mauke,yitz: ok, thanks
05:35:18 <yitz> or perhaps: let x = fibs in (fibs !! 4, fibs !! 2) where fibs !! 2 was already computed when you did fibs !! 4.
05:39:32 <lilac> does haskell have any lazy, potentially-infinite associative containers? like a hash table from all possible strings to computed values for each?
05:40:28 <mauke> you mean like functions?
05:40:40 <lilac> yes, except memoized
05:40:52 <mauke> what
05:42:06 <MyCatVerbs> > take 5 $ iterate tail [1..5]
05:42:08 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5]]
05:42:09 <lilac> ok, better question: is there a good way to memoize in haskell, for an arbitrary (hashable or Ord) argument type?
05:42:34 <Zao> Memoizing on hashes sounds dangerous.
05:42:45 <MyCatVerbs> lilac: AFAIK, the only way you'd ever be able to do proper memoization would be to use unsafePerformIO.
05:43:09 <MyCatVerbs> lilac: and maybe weak pointers, or some other clever cache-eviction policy (do we have weak pointers? I can't remember.)
05:43:44 <MyCatVerbs> Hrmn, System.Mem.Weak - yes. So anyway.
05:43:51 <lilac> MyCatVerbs: I'm happy to never purge anything from the cache. would unsafePerformIO actually be unsafe in this case?
05:44:11 <lilac> i don't see how it would violate referential transparency
05:44:21 <MyCatVerbs> lilac: no, it'd be fine, because it'll never violate referential transparency anyway.
05:44:34 <mauke> this sounds like a massive space leak
05:44:39 <MyCatVerbs> lilac: also, never purging anything from the cache is dangerous.
05:44:44 * MyCatVerbs waves at mauke.
05:44:54 * mauke surfs MyCatVerbs
05:45:01 <MyCatVerbs> lilac: indiscriminate cacheing is one of the most common sources of space leaks in industrial Java programs, AFAIK.
05:46:43 <lilac> i'm sure i'll eventually want a cache eviction policy, but for the moment this isn't a long-running process, so i really don't care
05:50:06 <MyCatVerbs> lilac: also I guess you'll want to parameterize on things like the eviction policy, the comparison method, etc.
05:55:35 <ehird> sclv: Pingerific
05:55:46 <sclv> dude.
06:00:53 <ehird> sclv: Duderific.
06:01:02 <sclv> 'sup?
06:01:55 <MyCatVerbs> @type \phi psi -> let h = phi . fmap h . psi in h
06:01:57 <lambdabot> forall b a (f :: * -> *). (Functor f) => (f b -> b) -> (a -> f a) -> a -> b
06:02:13 <ehird> sclv: the sky!
06:02:19 <ehird> instance Monad Sky
06:02:27 <sclv> for this you ping me?
06:02:36 <sclv> :-P
06:02:46 <MyCatVerbs> @let hylo phi psi = let h = phi . fmap h . psi in h
06:02:48 <lambdabot> Defined.
06:03:11 <MyCatVerbs> > hylo sum (enumFromTo 1)
06:03:13 <lambdabot>  <Integer -> Integer>
06:03:14 <ehird> sclv: that and me wondering about a possible hvac tutorial and progress thereof :-P
06:03:19 <MyCatVerbs> > hylo sum (enumFromTo 1) $ 5
06:03:22 <lambdabot>  Exception: stack overflow
06:03:41 <sclv> I'll try to get something up this weekend. Been pretty busy...
06:03:57 <MyCatVerbs> > hylo (\x -> 0 : sum x : []) (enumFromTo 1) $ 5
06:04:00 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]
06:04:00 <lambdabot>       Expected...
06:04:04 <ehird> sclv: the only really confusing bit is how you do strngtemplate, as well as, well, main
06:04:13 <ehird> sclv: the config record thingy
06:04:17 <MyCatVerbs> > hylo (\x -> (0,sum x)) (enumFromTo 1) $ 5
06:04:18 <lambdabot>      Occurs check: cannot construct the infinite type: b = (t, b)
06:04:18 <lambdabot>       Expec...
06:04:26 <sclv> the config record thingy is typical record update syntax.
06:04:33 <MyCatVerbs> Oh wait, need something lazier.
06:04:37 <ehird> sclv: duh
06:04:37 <ehird> ;0
06:04:39 <ehird> *;)
06:05:15 <sclv> the standard config is generally fine except you need to put a hdbc connector function in, wrapped in the HVDB existential, like the demos do.
06:05:17 <ehird> sclv: I am talking more the fields and what should og in them
06:05:19 <ehird> *go
06:05:32 <ehird> sclv: the demos are a bit dense
06:06:25 <sclv> and stringtemplate is just the renderf function -- it needs a funny join at the front which looks weird if you want to put your lifted functions directly in as params.
06:06:38 <MyCatVerbs> > hylo (\x -> 0:map sum x:[]) (enumFromTo 1) $ 5
06:06:39 <lambdabot>      Occurs check: cannot construct the infinite type: a = f a
06:06:39 <lambdabot>       Expected...
06:07:06 <ehird> sclv: the unsafeGroup (or w/e) stuff you do to get the directory is kinda confusing
06:08:34 <sclv> yeah, it looks a little funny i guess. you can just copypasta and it should be pretty intuitive though -- the haddocks are pretty complete.
06:09:13 <ehird> sclv: OK
06:09:26 <ehird> See, HaskellNomic good a bit too tedious with manual fcgi
06:09:27 <ehird> :-P
06:09:45 <ehird> sclv: Is it easy enough to use hvac without the v part?
06:09:58 <sclv> i.e. without stringtemplate?
06:09:59 <sclv> sure.
06:10:38 <ehird> sclv: 'cause seperation of concerns is pretty pointless for a nomic
06:12:37 <sclv> just don't call renderf, and use the standard CGI output function instead.
06:12:51 <ehird> sclv: okay.
06:13:15 <sclv> and you can ignore the cache stuff too -- that's all for tuning.
06:14:03 <orbitz> does anyone wish haskell was really called Haskull and a Skull and Lambda was the flag?
06:14:59 <sclv> conceptually you're in a CGI monad with some database and session and other stuff baked in, but with IO "hidden" behind an STM transaction.
06:17:07 <ehird> orbitz: Yes
06:17:33 <orbitz> ehird: let's make this happen
06:17:35 <cjay> @yarr
06:17:36 <lambdabot> Har de har har!
06:17:58 * shepheb hoists the Jolly Lambda
06:18:29 <dbueno> @seen dcoutts
06:18:30 <lambdabot> dcoutts is in #haskell, #gentoo-haskell, #haskell-soc, #haskell-overflow, #haskell-blah and #ghc. I last heard dcoutts speak 2h 51m 50s ago.
06:18:38 <ivanm> @seen dcoutts_
06:18:39 <lambdabot> dcoutts_ is in #haskell, #gentoo-haskell, #haskell-overflow and #ghc. I don't know when dcoutts_ last spoke.
06:18:42 <dcoutts_> @yarr!
06:18:42 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
06:18:53 <dbueno> hahaha...
06:19:00 * dcoutts_ fetches a coffee
06:19:03 <cjs> lambdabot is one weird guy.
06:19:11 <ivanm> @slap cjs
06:19:11 * lambdabot will count to five...
06:19:19 <ivanm> lambdabot is of the feminine gender!
06:19:25 <cjs> Iee!
06:19:27 <dbueno> dcoutts_ I should have checked before I sent the email, but, where do I find the list of flags whose values need to be solved for?
06:19:37 <ehird> @vixen Lambdabots gender is?
06:19:38 <lambdabot> why don't you guess?
06:19:41 <ehird> ha!
06:19:44 <ehird> uncanny
06:19:58 <ivanm> @vixen Lambdabot's gender is?
06:19:58 <lambdabot> why don't you guess?
06:20:07 <ivanm> @vixen What is lambdabot's gender?
06:20:08 <lambdabot> whoa whoa whoa, one question at a time!
06:20:11 <ivanm> heh
06:20:31 <dcoutts_> dbueno: in the GenericPackageDescription
06:20:48 <saml> is A in ADT Abstract or Algebraic?
06:21:13 <orbitz> Awesoem
06:21:15 <dbueno> dcoutts_ So if a Flag is in there and *not* assigned a value by the partial assignment in the UnresolvedDep, it's a variable.
06:21:36 <saml> haskell.org/tutoril says Abstract. but i hear Algebraic too
06:21:54 <ehird> @vixen What is lambdabot's gender?
06:21:55 <lambdabot> i'll hafta plead the fifth on that one.
06:22:02 <ehird> @vixen What is lambdabot's gender.
06:22:02 <lambdabot> f
06:22:07 <ehird> Well.
06:22:10 <ehird> It's right
06:22:26 <ehird> @vixen What is not lambdabot's gender.
06:22:26 <lambdabot> Do you think you would pass a Turing test?  I have.
06:22:45 <Vq^> :)
06:22:51 <dcoutts_> dbueno: right.
06:23:00 <dbueno> dcoutts_ Thanks for the help.
06:23:06 <dcoutts_> dbueno: np :-0
06:23:15 <shepheb> @vixen what gender are you?
06:23:15 <lambdabot> i truely am
06:23:24 <czakey> @vixen is lambdabot meeting someone?
06:23:24 <lambdabot> who's to say?
06:23:29 <czakey> :d
06:23:32 <saml> would you be able to represent a tree structure without ADT ? let's say you only have type inference, list, and lambda.
06:24:00 <czakey> @vixen is there any gammabot or thetabot?
06:24:01 <lambdabot> i'm sure there is
06:24:03 <saml> something recursive. like parenthesized expression. using only list and lanbda
06:24:19 <czakey> @botsnack
06:24:20 <lambdabot> :)
06:24:32 <dcoutts_> dbueno: usually the partial assignments will be empty, but we do let users specify them on the command line, cabal configure -f +foo -f -bar etc
06:25:10 <dcoutts_> dbueno: so the partial assignments don't really make the task any harder or easier
06:25:42 <Saizan> saml: church encoding
06:25:46 <dbueno> dcoutts_ Sure; I just want to make sure I'm taking into account all the stuff I'm supposed to. =]
06:25:55 <dcoutts_> @arr
06:25:55 <lambdabot> Har de har har!
06:26:00 <saml> Saizan: thank you. /me looks it up
06:26:04 <shepheb> @brain
06:26:05 <lambdabot> Uh, I think so Brain, but this time, you wear the tutu.
06:26:26 <dcoutts_> dbueno: you've perused the existing naive solver I suppose
06:26:41 <dbueno> dcoutts_ O.o actually no.
06:26:49 <dbueno> Naive?
06:27:33 <dcoutts_> dbueno: lemme check I've pushed all the patches...
06:27:43 <dcoutts_> before I direct you to things that might not exist
06:27:50 <dbueno> dcoutts_ You said there was a complete solver, but, Naive "often makes installation plans with inconsistent deps", so I figured I'd not look at it.
06:28:19 <dcoutts_> dbueno: Hackage/Dependency/Naive.hs
06:28:21 <dcoutts_> right
06:28:32 <dcoutts_> but it at least shows the types to play with
06:28:34 <ovnicraft> hi, how ser editor hugs98 (user linux)
06:28:34 <ovnicraft> s/ser/set
06:28:50 <dbueno> dcoutts_ All right, I'll have a look at it, then.
06:29:20 * shepheb hopes someone actually does create a Jolly Lambda flag
06:30:04 <dcoutts_> ovnicraft: I think hugs looks at the $EDITOR environment variable
06:30:27 <lilac> shepheb: valve sell some decent t-shirts with lambdas on them ;-)
06:32:26 <ovnicraft> set value from hug or edit any file
06:33:43 <saml> > [[1,[2,3]],4]
06:33:47 <lambdabot>   add an instance declaration for (Num [[t]], Num [t])
06:36:09 <needbeer> http://www.dasdeutschlandspiel.de/index.php?page=beg.php&id=4410
06:39:12 <saml> > [\f x -> x, \f x -> f x, \f x -> f (f x)]
06:39:20 <lambdabot>  Add a type signature
06:40:15 <ehird> Hmm.
06:40:28 <ehird> sclv: Can hvac be plugged into different webservers?
06:40:51 <ovnicraft> :set -Eemacs, in the prompt
06:41:24 <sclv> ehird: anything with a fastcgi interface.
06:41:30 <sebasmagri> Hi people... need some help with ghc-pkg...
06:41:37 <ovnicraft> how invoke 'pi', is in any prelude?
06:41:43 <sclv> an hvac program just compiles to a single fastcgi app
06:41:57 <ehird> sclv: I mean aprat from fcgi
06:41:58 <ehird> :-P
06:41:59 <ehird> *apart
06:42:00 <sebasmagri> where should be the correct argument to ghc-pkg register?
06:42:22 <sioraiocht> @seen dcoutts_
06:42:23 <lambdabot> dcoutts_ is in #haskell, #gentoo-haskell, #haskell-overflow and #ghc. I last heard dcoutts_ speak 12m 19s ago.
06:42:31 <dcoutts_> hia sioraiocht
06:42:34 <sioraiocht> hi!
06:42:35 <lambdabot> sioraiocht: You have 1 new message. '/msg lambdabot @messages' to read it.
06:42:50 <sclv> not as its written... one could build a bridge to a native server like minihttpd, but I haven't gotten around to it yet... on the other hand, any modern server can run fcgi.
06:44:29 <BMeph> So, would a minihttpd server running fcgi be an mf'ing cgi server? ;p
06:45:38 <sclv> bmemph -- not if it didn't actually run fcgi, but directly just provided a runCGI method for anything in the CGI typeclass...
06:46:10 <sclv> so no fcgi or cgi protocol, no ipc, etc.
06:47:12 <sclv> oh... punz.
06:51:11 <ehird> hah
06:51:12 <ehird> ".and in my opinion OOP IS always the best style. It allows u to reuse code without having to reinvent the weel every time u meet the same problem!!!"
06:51:18 <ehird> someone hasn't heard of function
06:51:19 <ehird> s
06:52:21 <smtms> ehird, you may ask him what other styles beside OOP he knows about
06:52:41 <quicksilver> someone simply hasn't got the faintest idea about programming in any way shape or form.
06:52:41 <MyCatVerbs> smtms: s/knows about/has actually used/
06:52:54 <saml> OOP, functional.. all coding styles are the same. type -> try -> fix
06:53:01 <ehird> smtms: this is an ooold post on a forum
06:53:04 <MyCatVerbs> smtms: because otherwise 'e'll just rattle off names of concepts 'e doesn't actually understand. :P
06:53:23 <ehird> smtms: but hes also a php developer, so I think we can chalk it off as a 14 year old guy who's just discovered oop
06:53:26 <smtms> MyCatVerbs, but he knows OOP is best, that should be as a result of comparison
06:53:27 <ehird> or rather, had just discovered it when posting it
06:55:06 <MyCatVerbs> smtms: I'd be surprised if 'e'd seen anything other than OO and spaghetti, all told.
06:55:38 <eek> one of my coworkers/friends referred to properly structured code as "object oriented" for a decade
06:55:46 <eek> no matter whether there was an object in sight or not
06:56:09 <eek> used as in "that code is fairly object oriented"
06:57:04 <MyCatVerbs> eek: out of curiosity, did you ever ask him to define exactly what the term -meant- to him?
06:57:17 <ehird> wow. I used to indent the somethingsmiths style.
06:57:18 <ehird> if (x)
06:57:19 <ehird>     {
06:57:20 <ehird>     ...
06:57:22 <ehird>     }
06:57:26 <ehird> what was I thinking
06:58:32 <MyCatVerbs> ehird: perhaps you secretly hated K&R? Past-tense-you was evil, by the way.
06:58:53 <ehird> MyCatVerbs: at least its not gnu
06:58:55 <ehird> right?
06:58:57 <eek> MyCatVerbs, I tried to coax it out of him, but he was a bit sensitive about the implication that he might not know this area too well...
06:59:53 <mercury^> ehird: gnu would indent inside of the braces again
07:00:09 <ehird> mercury^: xactly
07:00:14 <ehird> mercury^: painful
07:00:15 <ehird> :-)
07:00:23 <mercury^> I actually like it :)
07:00:30 <eek> what's a bit surprising is that he is, in most ways, a quite good developer in practice.
07:00:38 <MyCatVerbs> eek: weird.
07:00:42 <mercury^> I usually don't stick to conventions and use whatever layout seems nice at hand
07:00:50 <MyCatVerbs> ehird: mmmm, IMO that's actually worse than GNU.
07:00:55 <mercury^> sometimes indenting the braces makes things a lot clearer
07:01:14 <ehird> k&r are gods, apart from that twixt-misguided use of the 'fiver-space'
07:01:15 <eek> mercury^, I stick to a base convention and then vary the layout is there is a strong reason for it
07:01:28 <ehird> but we must not blame them for be living in the imperfeckt times.
07:01:42 <MyCatVerbs> ehird: at least it isn't: if (x)\n{\t...\n}
07:02:09 <ehird> MyCatVerbs: may god
07:02:11 <ehird> *my
07:03:04 <MyCatVerbs> ehird: http://hpaste.org/7767
07:03:10 <cjs> Is there a native (i.e., not using the C library) FastCGI module for Haskell?
07:03:32 <MyCatVerbs> ehird: http://hpaste.org/7767#a1 <-- or even...
07:03:44 <ehird> MyCatVerbs: I can make something more frightening
07:03:51 <ehird> and I WILL!
07:03:52 <MyCatVerbs> ehird: designed for packing lines onto lecture slides, naturally. I don't think -anyone- uses that on purpose.
07:04:07 <cjs> I suppose it really depends so much on what interface you want, anyway.....
07:04:54 <ehird> Hm.
07:04:59 <ehird> I need a literal tab character for this evil.
07:06:33 <ehird> MyCatVerbs: http://hpaste.org/7767#a2
07:06:36 <ehird> Be afraid, very afraid
07:06:54 <ehird> I could use that in an IOCCC entry
07:09:21 <ehird> MyCatVerbs died of horror
07:09:50 <smtms> if you ignore the first column, the rest uses Haskell/Python indentation
07:10:30 <ehird> smtms: indeed, but in a very disturbing way
07:10:39 <ehird> because that noise is still to the side
07:10:54 <ehird> i think compilers should be allowed to reject that
07:11:23 <mar77a> is it possible to specify the type of the lambda in a lambda expression?
07:11:31 <cjs> I kinda like that last one.
07:11:47 <cjs> If you could get an auto-formatter to do it. An Emacs mode or something.....
07:13:14 <ehird> @. slap slap cjs
07:13:15 * lambdabot will count to five...
07:13:31 <ehird> @. slap . slap slap cjs
07:13:32 * lambdabot pulls /me pushes /me karate-chops cjs into two equally sized halves
07:13:32 <lambdabot>  from his chair
07:13:32 <lambdabot>  through the Evil Mangler
07:13:38 <ehird> Wow.
07:13:59 <cjs> Ouch!
07:14:24 <ehird> Lambdabot pulls. Lambdabot pushes. Lambdabot karate-chops cjs into two equally sized halves -- from his chair. Through the evil mangler!
07:15:05 <cjs> Lambdabot does need to learn how to send those as separate messages to the IRC server, though. :-)
07:15:23 <ehird> @. slap . slap . slap . slap . slap slap cjs
07:15:24 * lambdabot throws some pointy lambdas at /me pushes /me pushes /me orders her trained monkeys to punch /me loves /me karate-chops cjs into two equally sized halves
07:15:24 <lambdabot> , so no slapping
07:15:24 <lambdabot>  
07:15:24 <lambdabot>  from his chair
07:15:24 <lambdabot>  from his chair
07:15:30 <ehird> OK, I'll stop.
07:15:34 <ehird> But that's definately a bug. :-P
07:15:47 <cjs> Anyway, before you get all excited, just think of it as a way to compensate for the lack of a preprocessor option to insert braces based on indentation.
07:17:46 <sclv_> mar77a: You need a GHC extension to do it, as I recall, but yes.
07:18:28 <ehird> umm
07:18:33 <ehird> ((\ ...) :: ...)
07:18:55 <sclv_> right but if you want \ (x::Int) ->
07:19:30 <ehird> oh.
07:20:30 <mar77a> yeah
07:20:52 <mar77a> > (\(x::Int) -> x * x) 1.5
07:20:52 <lambdabot>  Parse error in pattern at "->" (column 12)
07:21:00 <mar77a> :<
07:21:19 <saml> type Stack = [Val];  data Val = Term Int | Op String | Quoted Stack; [Term 1, Quoted [Term 3, Quoted [Op "+"]]]  represent this using list and lambda only
07:21:44 <ReinoDios> > 1.5 * 1.5
07:21:59 <lambdabot>  thread killed
07:22:16 <saml> > 1.0 * 0.0
07:22:17 <lambdabot>  0.0
07:22:54 <saml> > 1.5 * 1.5
07:22:56 <lambdabot>  2.25
07:23:05 <ReinoDios> why thread killed?
07:23:20 <saml> it was someone else's
07:25:38 <quicksilver> ReinoDios: just bad luck.
07:25:46 <quicksilver> ReinoDios: it was swapped out and/or the machine is busy.
07:25:50 <quicksilver> it over-ran the time limit.
07:26:54 <sclv_> mar77a: LANGUAGE PatternSignatures I think does it.
07:27:52 <mar77a> > 0 ** 0
07:27:56 <cjs> Is there an easy and simple way, in ghci, to serialize a value to a file on disk and read it back later?
07:27:59 <lambdabot>  1.0
07:28:02 <mar77a> all lies
07:28:37 <mar77a> isn't 0 ** 0 undefined?
07:29:26 <qwrx> depends
07:29:48 <qwrx> in analysis yes
07:29:53 <ReinoDios> mar77a, i though for all x in Reals , x**0 = 1
07:30:14 <ReinoDios> i wanna weird exceptions
07:30:31 <mar77a> lim x->0 x^x = 0?
07:30:44 <qwrx> yeah, that's the analysis view
07:30:50 <qwrx> if you want exp(x) to be continuous
07:30:50 <mar77a> er 1
07:31:36 <Baughn> mar77a: I'd very much prefer to leave that one undefined
07:31:52 <qwrx> makes things like d/dx x^n work properly
07:32:33 <roconnor> @hoogle fileSize
07:32:34 <mar77a> hm
07:32:42 <lambdabot> System.IO.hFileSize :: Handle -> IO Integer
07:32:42 <lambdabot> System.IO.hSetFileSize :: Handle -> Integer -> IO ()
07:33:20 <qwrx> if you are a combinatorix person like me you would say 0^0 is the number of ways of drawing a sequence of no elements from the set of no elements
07:33:29 <qwrx> there is one way to do that :)
07:33:32 <roconnor> @hoogle withFile
07:33:32 <lambdabot> System.IO.withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
07:33:41 <mar77a> yeah
07:33:49 <Kamina> i've always seen 0^0 being defined as 1
07:34:05 <mar77a> depends how you approach it apparently
07:34:12 <mar77a> 0^x or x^x
07:34:27 <mar77a> or 0^x
07:34:29 <qwrx> I'm sure there's a good reason in analysis to make 0^0 undefined but I can't remember it
07:34:31 <roconnor> @hoogle IOMode
07:34:32 <lambdabot> System.IO.IOMode :: data IOMode
07:34:47 <mar77a> 0^x would be 0 for x = 0
07:34:56 <mar77a> but x^0 would be 1 for x = 0
07:35:13 <mar77a> if those two were defined in 0 :)
07:35:19 <mar77a> (x=0)
07:35:19 <qwrx> oh yeah, kind of depends which way you come at it
07:35:23 <ReinoDios> for all x!=0 in Reals, 0^x = 0
07:35:42 <mar77a> but if you use limits
07:36:01 <mar77a> lim x->0 0^x = 0 , lim x->0 x^0 = 1
07:36:02 <ReinoDios> for all x!=0 in Reals, x^0 = 1
07:36:09 <lilac> ReinoDios: nope. forall x > 0 in Reals, 0^x = 0
07:36:11 <ReinoDios> 0^0 = ???
07:36:24 <lilac> ReinoDios: but forall x, x^0 = 1
07:36:29 <mar77a> can you re-define 0 ** 0?
07:36:37 <mar77a> to say 0 or 1 or undefined?
07:36:54 <lilac> ReinoDios: that's why 0^0 = 1
07:36:59 <qwrx> it kind of ruins the gradient of x^1 to let it be undefined
07:37:43 <mar77a> how so o_O
07:38:02 <qwrx> well
07:38:06 <lilac> qwrx: you mean x^0?
07:38:22 <qwrx> I mean 0^0
07:38:45 <qwrx> it's nice to have ddx x^n = nx^(n-1)
07:38:58 <mar77a> ah
07:39:05 <qwrx> rather than ddx = x^n = nx^(n-1) unless x=0,n=1
07:39:16 <ReinoDios> what about     for all x < 0 in Reals,    0^x = infinite  ?
07:39:20 <mar77a> f''
07:39:28 <qwrx> and you end up with some weird discontinuity in y=x
07:39:36 <mar77a> yeah i get it
07:40:02 <qwrx> not to say you can't have one but I think it'd be quite unnerving
07:40:04 <lilac> ReinoDios: "= infinite" has no meaning.
07:40:04 <saml> i don't think i can represent recursive data structure with list and lambda. http://okmij.org/ftp/Computation/list-representations.txt
07:40:27 <mar77a> > :t ()
07:40:28 <lambdabot>   parse error on input `:'
07:40:38 <mar77a> :t ()
07:40:40 <lambdabot> ()
07:40:58 <saml> value of () is itself a type
07:41:22 <lilac> ReinoDios: but it's true to say that forall x < 0 in odd integers, (y ^ x) -> inf as y -> 0 from above
07:41:51 <lilac> ReinoDios: further, forall x < 0, y ^ x diverges as y -> 0
07:42:43 <ReinoDios> x>0,   0^(-x) = 1 / (0^x) = 1 / 0
07:42:45 <lilac> saml: that's no different from data X = X
07:43:18 <saml> @src ()
07:43:18 <lambdabot> data () = ()
07:43:30 <ReinoDios> > 0 ** -1
07:43:32 <lambdabot>      precedence parsing error
07:43:32 <lambdabot>         cannot mix `(**)' [infixr 8] and prefix...
07:43:39 <ReinoDios> > 0 ** (-1)
07:43:42 <lambdabot>  Infinity
07:43:47 <lilac> ReinoDios: except if x == 0, when it's 1
07:44:23 <lilac> ReinoDios: anyway, that doesn't show anything, because 1/0 isn't "infinity", its undefined, because infinity is not a number (speaking here mathematically, rather than about, say IEE754)
07:44:34 <quicksilver> saml: the point oleg makes in that paper is about types.
07:44:44 <quicksilver> saml: the traditional church encoding is in an untyped language
07:44:47 <ReinoDios> lilac, Haskell said Infinity instead of undefined.
07:45:23 <quicksilver> saml: in which recursive types are fine
07:45:30 <MyCatVerbs> ReinoDios: programming languages tend to use IEEE754, in which (+1/+0) is explicitly defined as infinitity.
07:45:39 <quicksilver> lilac, ReinoDios : == Infinity has meaning in IEEE floating point settings.
07:45:46 <quicksilver> however inconvenient that may be
07:45:52 <quicksilver> > 2/0 == 1/0
07:45:54 <lambdabot>  True
07:46:05 <MyCatVerbs> ReinoDios: er, for floating point arithmetic, anyway. For extra lulz, try (+1 / (negate 0))
07:46:06 <ReinoDios> is not there here "division by zero"?
07:46:13 <lilac> quicksilver: i'd say it's convenient. but my point was about mathematics rather than about IEEE754
07:46:44 <MyCatVerbs> ReinoDios: yes, but division by zero is only considered an error for integral types. On IEEE754 floating point numbers, 1/0 is explicitly defined as infinity.
07:46:44 <ReinoDios> is not there here "division by zero" exception?
07:46:49 <quicksilver> lilac: agreed.
07:47:01 <quicksilver> ReinoDios: IEEE decided having an answer 'Infinity' was better than an exception.
07:47:03 <MyCatVerbs> > (1::Integer) `div` 0
07:47:04 <lambdabot>  Exception: divide by zero
07:47:04 <quicksilver> *shrug*
07:47:09 <MyCatVerbs> ReinoDios: see?
07:47:15 <cjs> ReinoDios: It's the exception, not the rule.
07:47:42 <cjs> :-)
07:47:48 <ReinoDios> (0::Integer) ** (-1::Integer)
07:48:11 <MyCatVerbs> ReinoDios: put a > in front, so that lambdabot will know to interpret it.
07:48:12 <lilac> > 0 ** 0 :: Integer
07:48:15 <lambdabot>   add an instance declaration for (Floating Integer)
07:48:15 <lambdabot>     In the expression: 0...
07:48:16 <ReinoDios> > (0::Integer) ** (-1::Integer)
07:48:17 <lambdabot>   add an instance declaration for (Floating Integer)
07:48:17 <lambdabot>     In the expression: (...
07:48:26 <Toxaris> is it possible to express an anonymous type function in Haskell, i.e., simulate type-level lambda binder?
07:48:29 <lilac> > 0 ^ 0 :: Integer
07:48:30 <lambdabot>  1
07:48:38 <ReinoDios> > (0::Integer) ** ((-1)::Integer)
07:48:39 <lambdabot>   add an instance declaration for (Floating Integer)
07:48:39 <lambdabot>     In the expression: (...
07:48:42 <MyCatVerbs> Toxaris: yes, it's been done.
07:48:44 <tchakkazulu> :t (**)
07:48:47 <lambdabot> forall a. (Floating a) => a -> a -> a
07:49:11 <MyCatVerbs> ReinoDios: (**) is only defined on floating-point numbers. (^) is defined for integers.
07:49:14 <tchakkazulu> :t ((^),(^^))
07:49:16 <lambdabot> forall a b a1 b1. (Integral b1, Fractional a1, Integral b, Num a) => (a -> b -> a, a1 -> b1 -> a1)
07:49:35 <ReinoDios> :(
07:49:38 <Toxaris> MyCatVerbs: great! can you give me a pointer?
07:49:48 <ReinoDios> > (0::Integer) ^ ((-1)::Integer)
07:49:50 <lambdabot>  Exception: Prelude.^: negative exponent
07:50:12 <MyCatVerbs> Toxaris: http://tinyurl.com/6lj3lz
07:50:13 <lambdabot> Title: Type arithmetic - HaskellWiki
07:50:44 <MyCatVerbs> Toxaris: under the "really advanced" section, they explain how to implement lambda calculus in the type checker.
07:51:21 <ehird> it's really evil though
07:51:22 <ehird> :-)
07:51:43 <Saizan> i don't thing that's what Toxaris was talking about
07:51:47 <Toxaris> MyCatVerbs: I see.
07:52:20 <Toxaris> Saizan, MyCatVerbs: while this was indeed not was I was talking about, it may be good enough for my use case
07:53:30 <Saizan> things like (\x -> (x,x)) are not expressibile anyhow, you need a type synonym
07:53:37 <MyCatVerbs> I wouldn't use that myself, anyway. It's evil.
07:53:44 <ehird> :t (\x -> (x,x))
07:53:46 <lambdabot> forall t. t -> (t, t)
07:53:48 <MyCatVerbs> Well, not unless there was some really good reason to need it.
07:53:48 <ehird> :-P
07:53:49 <ehird> Joking ofc.
07:53:51 <MyCatVerbs> ehird: hush, you.
07:53:55 <ehird> Hmm.
07:53:56 * MyCatVerbs throws a banana at ehird.
07:54:03 <ehird> A unified-type-and-value-haskell..
07:54:11 <ehird> I think (\x -> (x,x)) at the type level would be:
07:54:16 <ehird> $[\x -> (x,x)]$
07:54:22 <ehird> let's say $[..]$ goes up one meta level
07:54:35 <qwrx> hmm
07:54:38 <ehird> and, errr, $>...<$ goes down one
07:54:42 <ehird> you could have type functions taking values
07:54:52 <ehird> like, MyThingy 3
07:54:53 <ehird> would be
07:55:01 <Toxaris> ehird: well, that goes beyond what I want, but that would be no problem, of course
07:55:04 <ehird> $[\$>i<$ -> ...Some type thing ...]
07:55:07 <mar77a> > map (\x -> x ** x) [0.01,0.001,0.0001,0.0001]
07:55:09 <lambdabot>  [0.954992586021436,0.9931160484209338,0.9990793899844618,0.9990793899844618]
07:55:24 <mar77a> > map (\x -> 0 ** x) [0.01,0.001,0.0001,0.0001]
07:55:26 <lambdabot>  [0.0,0.0,0.0,0.0]
07:55:32 <mar77a> > map (\x -> x ** 1) [0.01,0.001,0.0001,0.0001]
07:55:33 <lambdabot>  [1.0e-2,1.0e-3,1.0e-4,1.0e-4]
07:55:44 <Toxaris> I just want to be able to say    type f = /\ a . (a, a)   instead of   type f a = (a, a)
07:56:01 <Toxaris> because I want to use type constructors such as f "inline" in type expressions
07:56:11 <lilac> mar77a: did you mean x ** 0?
07:56:34 <Toxaris> and want to avoid the definition of a lot of small types in the top-level namespace (and vertical filespace). unfortunately, there are no local type definitions.
07:56:51 <mar77a> hm yeah
07:58:00 <ReinoDios> > (1::Integer) div (0::Integer)
07:58:00 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t'
07:58:04 <Toxaris> ehird: why do you use these explicit level annotations? wouldn't the "type system" of that language (I assume its hypothetical?) figure what the levels automatically?
07:58:18 <ReinoDios> > (1::Integer) `div` (0::Integer)
07:58:19 <lambdabot>  Exception: divide by zero
07:58:28 <ReinoDios> > (1::Integer) `div` (0.0)
07:58:29 <lambdabot>   add an instance declaration for (Fractional Integer)
07:58:37 <mar77a> :t div
07:58:39 <lambdabot> forall a. (Integral a) => a -> a -> a
07:58:44 <Saizan> Toxaris: with that much polymorphism type inference is no more decidable
07:58:47 <lilac> > 1 / -0
07:58:47 <lambdabot>      precedence parsing error
07:58:47 <lambdabot>         cannot mix `(/)' [infixl 7] and prefix ...
07:58:50 <ReinoDios> > 1.0 / 0.0
07:58:52 <lambdabot>  Infinity
07:58:52 <ehird> Toxaris: well, not really
07:58:57 <lilac> > 1. / (-0.)
07:58:57 <lambdabot>  Parse error at "/" (column 4)
07:59:01 <ehird> Toxaris: otherwise you could have Integer as a value at runtime!
07:59:03 <ehird> that'd be .. bad.
07:59:06 <lilac> > 1.0 / (-0.0)
07:59:08 <lambdabot>  -Infinity
07:59:11 <lilac> > 1.0 / (0.0)
07:59:12 <lambdabot>  Infinity
07:59:19 <mar77a> > 0.0 / 0.0
07:59:21 <lambdabot>  NaN
07:59:22 <mar77a> :>
07:59:29 <mar77a> NaN? more like undefined
07:59:40 <ReinoDios> > 1.0 / (-0.0)
07:59:40 <lilac> mar77a: that's pretty much what NaN means
07:59:41 <mar77a> it could be a number! :(
07:59:41 <lambdabot>  -Infinity
07:59:58 <ReinoDios> hahaha
08:00:07 <Bonus> in which situations would this behaviour actually be significant?
08:00:09 <lilac> mar77a: it's not a number, it's all numbers;-)
08:00:17 <mar77a> heh
08:00:21 <mar77a> fair enough
08:00:27 <tchakkazulu> NaN :: AllExceptNum a => a
08:00:38 <mar77a> :t NaN
08:00:40 <lambdabot> Not in scope: data constructor `NaN'
08:00:51 * tchakkazulu was kidding, btw.
08:01:01 <mar77a> :)
08:01:01 <Kamina> :t (0.0/0.0)
08:01:03 <lambdabot> forall t. (Fractional t) => t
08:01:10 <mar77a> lazy!
08:01:33 <ehird> @src Fractional
08:01:34 <lambdabot> class  (Num a) => Fractional a  where
08:01:34 <lambdabot>     (/)             :: a -> a -> a
08:01:34 <lambdabot>     recip           :: a -> a
08:01:34 <lambdabot>     fromRational    :: Rational -> a
08:01:35 <ehird> @instances Fractional
08:01:35 <lambdabot> Double, Float
08:01:38 <ehird> @src Double
08:01:39 <lambdabot> data Double = D# Double#
08:01:41 <ehird> @src Float
08:01:41 <lambdabot> data Float = F# Float#
08:01:48 <ehird> Ah. They'll use machine-NaN then
08:03:02 <ReinoDios> > Infinity / (-0.0)
08:03:17 <lambdabot>  thread killed
08:03:25 <Deewiant> > Infinity / (-0.0)
08:03:26 <lambdabot>   Not in scope: data constructor `Infinity'
08:03:59 <ReinoDios> > ((1.0) / (0.0)) / (-0.0)
08:04:02 <lambdabot>  -Infinity
08:04:09 <roconnor> maxBound :: Double
08:04:15 <roconnor> > maxBound :: Double
08:04:16 <lambdabot>   add an instance declaration for (Bounded Double)
08:04:16 <lambdabot>     In the expression: max...
08:04:20 <roconnor> oh right
08:05:20 <ReinoDios> > ((1.0) / (0.0))         /         ((1.0) / (0.0))
08:05:21 <lambdabot>  NaN
08:06:16 <quicksilver> NaN is very different indeed from Prelude.undefined.
08:06:25 <quicksilver> it's rather like mathemetical 'undefined' though
08:07:24 <MyCatVerbs> It's more of a numerical analysist's way of saying "bugger off".
08:07:51 <mar77a> how would i go around writting:
08:07:57 <mar77a> > map (+1) [0,1,2,3]
08:07:59 <lambdabot>  [1,2,3,4]
08:08:05 <mar77a> but substracting one instead of adding?
08:08:10 <mm_freak_work> NaN is a real value, while undefined is rather a computation, which throws an exception
08:08:16 <mm_freak_work> > NaN + NaN
08:08:17 <lambdabot>   Not in scope: data constructor `NaN'
08:08:28 <mar77a> > map (+(-1)) [0,1,2,3]
08:08:29 <lambdabot>  [-1,0,1,2]
08:08:32 <mar77a> got it!
08:08:39 <mar77a> how odd
08:08:44 <quicksilver> mar77a: or (subtract 1)
08:08:54 <mar77a> what's up with hs and the unary minus
08:08:56 <mm_freak_work> mar77a: the 'right' way is to use 'subtract'
08:09:20 <mar77a> kinda inconsistent with the unary addition :<
08:09:32 <lilac> > map (-1+) [0,1,2,3]
08:09:33 <lambdabot>  [-1,0,1,2]
08:09:35 <quicksilver> unary minus breaks the nice simple rules
08:09:39 <quicksilver> it's a shame.
08:09:49 <Toxaris> mar77a: unary minus is broken from a formal languages point of view
08:10:03 <ReinoDios> > (\x -> x / x) 2.0
08:10:04 <lambdabot>  1.0
08:10:08 <quicksilver> quite a lot of people would favour ditching unary minus from the language.
08:10:10 <lilac> could the - be made part of the lexeme for a number?
08:10:10 <ReinoDios> > (\x -> x / x) 0.0
08:10:11 <lambdabot>  NaN
08:10:47 <ReinoDios> > (\x -> x / x) 0.01
08:10:48 <lambdabot>  1.0
08:10:53 <mar77a> map (\x -> x / x) [0.1,0.01,0.001,0.0001,0.0001]
08:10:55 <ReinoDios> > (\x -> x / x) -0.01
08:10:56 <lambdabot>   add an instance declaration for (Fractional (a -> a))
08:11:01 <mar77a> > map (\x -> x / x) [0.1,0.01,0.001,0.0001,0.0001]
08:11:03 <lambdabot>  [1.0,1.0,1.0,1.0,1.0]
08:11:10 <mm_freak_work> > map (+ (4294967297 :: Int32)) [0,1,2,3]
08:11:11 <lambdabot>  [1,2,3,4]
08:11:12 <tchakkazulu> Possible, but in that case, 2-3 could be parsed as <number><number>, while it should be <number><operator><number>.
08:11:15 <mm_freak_work> > map (+ (4294967295 :: Int32)) [0,1,2,3]
08:11:17 <lambdabot>  [-1,0,1,2]
08:11:22 <quicksilver> lilac: yes, it could be, that's another possible way to go.
08:11:29 <quicksilver> lilac: then (-x) doesn't work though.
08:11:35 <lilac> i'm ok with that
08:11:47 <mm_freak_work> > map (+ fromIntegral (4294967295 :: Int32)) [0,1,2,3] :: [Integer]
08:11:48 <lambdabot>  [-1,0,1,2]
08:11:54 <mar77a> tchakkazulu: 2+-3?
08:12:00 <mar77a> :)
08:12:48 <ReinoDios> > (\x -> x / x) (-0.01)
08:12:49 <lambdabot>  1.0
08:12:58 <ReinoDios> > (\x -> x / x) (-0.00)
08:12:59 <lambdabot>  NaN
08:13:24 <mm_freak_work> > 0 ** 0
08:13:25 <lambdabot>  1.0
08:14:57 <ReinoDios> map (\x -> 0 ** x) [-0.01,-0.001,-0.000,0.001,0.01]
08:15:28 <ReinoDios> > map (\x -> 0 ** x) [-0.01,-0.001,-0.000,0.001,0.01]
08:15:29 <lambdabot>  [Infinity,Infinity,1.0,0.0,0.0]
08:15:39 <ReinoDios> > map (\x -> x ** 0) [-0.01,-0.001,-0.000,0.001,0.01]
08:15:40 <lambdabot>  [1.0,1.0,1.0,1.0,1.0]
08:16:42 <lilac> @let a +- b = a - b
08:16:58 <lambdabot> thread killed
08:17:11 <lilac> > let a +- b = a - b in map (+-1) [1,2,3,4]
08:17:12 <lambdabot>  [0,1,2,3]
08:29:28 <edwardk> heh, does anyone remember the right syntax to access (.) in Prelude when Prelude is qualified?
08:29:45 <Deewiant> @ty (Prelude.(.))
08:29:46 <Riastradh> Prelude..
08:29:47 <lambdabot> Not in scope: data constructor `Prelude'
08:29:50 <Deewiant> @ty (Prelude..)
08:29:52 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:29:56 <Deewiant> indeed
08:29:59 <edwardk> hrmm will try that again.
08:30:19 <edwardk> that fixed it. forgot the surrounding parens
08:30:56 <poucet> Hi, does 6.8.2 ship with cabal?
08:31:06 <Baughn> Yes, though not the newest version
08:31:07 <edwardk> going back and building all the category stuff with 6.6 and 6.8 so i can be sure its a bit more portable
08:33:34 <edwardk> when were control.monad.foo.lazy and control.monad.foo.strict added?
08:33:38 <cjs> For the obvious Enum I've defined, '[Jan..Dec]' gives me 'Failed to load interface for `Jan'' in ghci. What am I doing wrong?
08:35:08 <poucet> bleh, need to install so many packages just to install cabal-install
08:35:12 <Stwange> sorry for asking here, I know it's not haskell related but I couldn't think where to ask, and you guys tend to know about general things. How do distributed hash tables work if a node goes down? The links I can find say they have to cope with this, but then go onto say each node is responsible for some set of nodes. What if the node goes down? Do they use duplication of everything? What if they both go down?
08:35:13 <poucet> sort of defeats the purpose of cabal-install
08:36:19 <Baughn> Stwange: http://www.google.com/search?q=%22distributed+hash+table%22+%22fault+tolerance%22&ie=utf-8&oe=utf-8&aq=t&rls=org.mozilla:en-US:official&client=firefox-a
08:36:20 <lambdabot> Title: "distributed hash table" "fault tolerance" - Google Search, http://tinyurl.com/5mwcsl
08:36:22 <edwardk> Stwange: you need to perform replication
08:36:46 <poucet> even worse, all the libghc6 packages in hardy require 6.6.... although hardy ships with 6.8.2
08:36:47 <edwardk> stwange: usually you want to replicate 3+ times
08:37:21 <Saizan> cjs: put a space after Jan
08:37:25 <cjs> Stwange: if this is not just a one-off question, you really want to buy yourself a copy of _In Search of Clusters_, by Gregory Pfister.
08:37:42 <cjs> Saizan: Thanks!
08:37:45 <dcoutts_> poucet: oh it's not that many, it's two right?
08:38:04 <Stwange> replication makes sense, and if one goes down all its values are re-replicated
08:38:07 <poucet> Setup.hs: dist/installed-pkg-config: openFile: permission denied (Permission denied)
08:38:07 <Stwange> thanks guys :)
08:38:22 <poucet> dcoutts_: zlib, network, HTTP, and that's without going further
08:38:38 <dcoutts_> poucet: oh, I think of network as being part of the basic install
08:38:53 <poucet> dcoutts_: how come I'm getting that perm denied when running as sudo?
08:39:16 <pejo> poucet, it's an nfs-mounted filesystem?
08:40:07 <dcoutts_> poucet: I'm not sure, unless as pejo says. You can try a per-user install, without sudo.
08:41:25 <poucet> pejo: my home is
08:41:28 <poucet> pejo: the rest not
08:42:08 <edwardk> You know your install is screwed up when ...: `fmap' is not a (visible) method of class `Functor'
08:42:10 <poucet> pejo: that fixed it :)
08:43:51 <poucet> seems that some packages of ghc6* on hardy work with 6.8, some don't
08:44:03 <poucet> and sadly they're all named ghc6*-, which makes it confusing
08:49:46 <eek> cjs, has "In Search Of Clusters" been updated with information about distributed hash tables?  I can't remember that from the edition I've read.  I remember it as a very good book, though, and second the recommendation in general :) (DHTs are generally used for loosely connected networks, peer to peer).
08:51:00 <poucet> cabal: /tmp/TMPlambdabot-4.1TMP/lambdabot-4.1/Plugin/State.hs: openFile: resource busy (file is locked)
08:51:17 <poucet> reinvoke cabal install seems to fix that
08:52:03 <saml> printStr f x = do ...   Non-exhaustive patterns in function printStr   wtf?
08:52:15 <saml> shouldn't that match any thing?
08:52:20 <cjs> I don't recall; I've not read it since the '90s. But it gives you the tools you need to analyze these sorts of questions.
08:52:31 <dcoutts_> poucet: so running the exact same command again and it behaved differently?
08:52:48 <poucet> dcoutts_: indeed
08:52:53 <poucet> dcoutts_: I guess the filelock got liberated
08:53:02 <cjs> Hey, so what's with not being able to use a '?' at the end of a function name. Even Ruby allows that! :-)
08:53:02 <poucet> dcoutts_: probably poor closure of a file handle?
08:53:15 <poucet> this was "cabal install lambdabot"
08:53:18 <poucet> when it started with lambdabot
08:53:26 <twanvl> saml: it is possible to use pattern matches that can fail inside a do block
08:54:13 <cjs> Anyway, what's the Haskell tradition, if I can't use the scheme one? isFoo? foop?
08:54:52 <MyCatVerbs> cjs: foop isn't anywhere. isFoo seems most common in the standard libraries.
08:55:12 <saml> twanvl: printStr _ _ =  error "hi"   then I do make clean && make.. then I call printStr  and it prints
08:55:19 <MyCatVerbs> cjs: isLower, isUpper, etc in Data.Char. isEmptyMVar in Control.Concurrent.MVar, etc.
08:55:28 <cjs> Darn, I'd really liked that question mark thing in Scheme. Though Ruby rather mucked it up.
08:55:57 <cjs> Anyway, isFoo it is, though it makes me feel as if I'm programming in Java.
08:56:00 * cjs shudders.
08:56:05 <dcoutts_> poucet: what phase did it give the error? was it before, after or during the compile phase?
08:56:23 <MyCatVerbs> cjs: agreed. This is one of the things I find a bit peevish about Haskell syntax myself.
08:56:31 <dcoutts_> poucet: I wonder for example if it was during deleting the temp directory
08:56:53 <saml> quicksilver: yup. so in a typed lambda calculus, i can't represent recursive data type
08:57:09 <quicksilver> saml: it's a bit like functional recursion, AIUI.
08:57:16 <quicksilver> you either need "fix" or explicit recursion
08:57:22 <quicksilver> to do recursive functions with types
08:57:30 <quicksilver> (without types you can write a Y combinator)
08:57:41 <quicksilver> Then you have exactly the same issue at the type level.
08:57:54 <quicksilver> You either need 'Fix' (Mu) or explicit recursion in types.
09:00:51 <saml> twanvl: oh my bad. i was using old binary. i forgot i changed my makefile
09:00:58 <mar77a> is it possible to write all imperative code in haskell
09:01:04 <mar77a> but take advantage of the functional stuff
09:01:08 <saml> mar77a: yes
09:01:11 <mar77a> like, writting a compiled program
09:01:39 <poucet> dcoutts_: sadly out of my buffer and I don't know how to scroll
09:01:41 * poucet has to go though
09:01:57 <poucet> dcoutts_: the very first phase when starting with lambdabot, basically
09:02:01 <dcoutts_> poucet: if you ever reproduce it, report it. Thanks!
09:02:04 <poucet> will do
09:06:29 <pafcu_> How would one implement a residual class data type? I want a datatype where addition and multiplication is "automatically" done modulo some number. The only way I can think of is creating types like Residual1, Residual2, Resiudal3, etc. Any way to make it more general?
09:07:04 <mauke> @where configuration
09:07:04 <lambdabot> I know nothing about configuration.
09:08:31 <EvilRanter> @go number-parameterised types
09:08:31 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2006-June.txt
09:08:39 <mauke> http://okmij.org/ftp/Haskell/number-parameterized-types.html
09:08:39 <lambdabot> Title: Haskell Programming: Types that depend on numbers
09:09:04 <EvilRanter> pafcu_, thus ^
09:10:12 <pafcu_> Thanks, I'll look at that
09:10:32 <EvilTerran> beware: it's hairy. Oleg's stuff usually is.
09:12:56 <mauke> see also http://okmij.org/ftp/Haskell/types.html#Prepose
09:12:56 <lambdabot> Title: Haskell Programming: Types
09:13:28 <mauke> crap, link to the paper is broken
09:15:13 <mauke> http://web.archive.org/web/20070324090425/www.cs.rutgers.edu/~ccshan/prepose/
09:15:16 <lambdabot> Title: Index of /~ccshan/prepose, http://tinyurl.com/5n3cgt
09:24:47 <lstor> I have a Tree defined as an element, a right subtree and a left subtree, where each subtree is Maybe (Tree element). I want to find the size of the tree by adding the size of both subtrees with one, but I'm not allowed to take size on a Maybe Tree. How do I "unpack" the Tree from the Maybe? I thought of using 'case', but if that is the answer, how do I check both subtrees at the same time?
09:25:12 <lstor> I tried reading about it on Wikibooks, but didn't find anything. Am I going about this all wrong?
09:25:53 <maltem> > liftA2 (+) (Just 2) (Just 3)
09:25:56 <quicksilver> you can case both at once if you want.
09:25:57 <lambdabot>  Just 5
09:26:10 <maltem> > liftA2 (+) (Just 2) Nothing
09:26:12 <lambdabot>  Nothing
09:26:12 <quicksilver> what kind of answer are you expecting if the subtree is Nothing?
09:26:19 <quicksilver> > fromMaybe 0 Nothing
09:26:20 <lambdabot>  0
09:26:31 <quicksilver> "fromMaybe 0" may be useful, if that is what you want.
09:26:52 <lstor> Sounds interesting, I'll try. Thanks :-)
09:27:00 <maltem> ah, I thought lstor wanted to fail on any subtree that is Nothing
09:28:21 <EvilTerran> the other way would be (case left of Nothing -> 0; Just t -> size t) + (case right of Nothing -> 0; Just t -> size t) + 1, or whatever
09:28:34 <EvilTerran> ?src fromMaybe
09:28:35 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
09:28:35 <maltem> because otherwise, I'd wonder why he worries about casing both "at once"
09:28:38 <EvilTerran> comes to the same thing
09:28:43 <ddarius> maybe 0 size
09:29:48 <lstor> maltem: If at least one subtree is Nothing, I want size otherSubtree + 1, but I still don't know if otherSubtree is Nothing.
09:29:52 <ziman> > liftM2 (+) (Just 2) (Just 3)
09:29:54 <lambdabot>  Just 5
09:30:58 <maltem> lstor: Just define the size of Nothing to be 1
09:31:24 <tchakkazulu> What if both are Nothing?
09:31:46 <Deewiant> > maybe 0 length Nothing + maybe 0 length (Just [1..10])
09:31:47 <lambdabot>  10
09:31:48 <lstor> maltem: I guess that could work (with 0 instead of 1), but fromMaybe did exactly what I wanted, so now I'm happy :-)
09:31:50 <Deewiant> > maybe 0 length Nothing + maybe 0 length Nothing
09:31:51 <lambdabot>  0
09:32:12 <maltem> lstor: Ah, I was already wondering why 1 :)
09:33:19 <lstor> maltem: If you're thinking about my "size otherSubtree + 1": The size of a tree is the current node (1) plus the size of both subtrees
09:33:20 <tantalum> I worte this code http://pastebin.com/d5503d79e but I get a parse error on line 17 at "module". Can some one tell me why?
09:33:44 <Igloo> tantalum: Each module must be in its own file
09:33:45 <maltem> lstor, ah, of course
09:33:58 <lstor> :)
09:38:26 <ddarius> size (Node _ l r) = 1 + maybe 0 size l + maybe 0 size r
09:38:36 <tantalum> Igloo: Awsom! some one should fix http://www.haskell.org/tutorial/modules.html because it has source where it looks like two modules are in the same source file
09:38:37 <lambdabot> Title: A Gentle Introduction to Haskell: Modules
09:41:00 <lispy|web> Igloo: oh, in the 11.1 example?
09:41:24 <Igloo> ITYM tantalum?
09:42:07 <lispy|web> Igloo: oh yes, I'm not used to this irc client yet, you are correct
09:42:20 <tantalum> yes also there is the "There is no formal connection between a Haskell module and the file system that would (typically) support it. In particular, there is no connection between module names and file names, and more than one module could conceivably reside in a single file (one module may even span several files)." part
09:45:26 <BMeph> tantalum: I think this is one of those "difference between the language, and an implementation of the language" issues.
09:46:09 <quicksilver> tantalum: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html
09:46:09 <lambdabot> Title: 5.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
09:46:42 <BMeph> Speaking of implementation issues, does anyone know why I'm getting this error:
09:46:44 <BMeph> ghc-core: /tmp: openTempFile: does not exist (No such file or directory)
09:47:03 <ddarius> tantalum: The report says nothing about files.
09:47:05 <tromp> > 0
09:47:06 <lambdabot>  0
09:47:08 <ddarius> s/files/source files/
09:47:10 <tantalum> Yes I understand that but that is the first place some one new to haskell would look
09:48:01 <lispy|web> BMeph: can you create a file in /tmp?
09:48:10 <lispy|web> BMeph: i mean, outside of ghc can you do it?
09:48:16 <tantalum> it should be a little clearer on the fact the some (most?) compilers require each module to be a seperate file
09:48:24 <ddarius> tantalum: all
09:50:06 <BMeph> lispy|web: I can when I go to the directory.
09:50:23 <tantalum> All? damn!... Any way that was my little rant and I'll be nicer now
09:50:48 <tantalum> touch /tmp/somefile
09:51:38 <lispy|web> BMeph: what is your command that gives this error?
09:51:54 <quicksilver> tantalum: it shouldn't be anything other than what it is.
09:51:56 <BMeph> lispy|web: Running ghc-core. :p
09:52:03 <quicksilver> tantalum: the report is not user documentation, it's a language specification.
09:52:09 <lispy|web> BMeph: I wondering if it's trying to use literally "/tmp" as the temp file
09:52:20 <quicksilver> tantalum: it's not expected to be updated after the fact to accomodation specific implementations.
09:52:29 <quicksilver> tantalum: there is much better user documentation out there
09:52:38 <quicksilver> tantalum: including the gentle introduction you originally referred to.
09:52:44 <lispy|web> BMeph: hmm...I've never used ghc-core before.  Is this a sub part of ghc that compiles core files?
09:53:02 <BMeph> lispy|web: Not as the file, but as the directory. At least, that's my "guess," since the program compiles.
09:53:26 <tantalum> quicksilver: That is true
09:53:46 <BMeph> lispy|web: ghc-core is a utility dons wrote that shows what your programs look like when translated into Core.
09:53:53 <lispy|web> ah
09:54:09 <lispy|web> perhaps best to ask dons then i guess
09:54:17 <lispy|web> Or look at the source yourself and see if you can find it
09:54:28 <twobitwork> what's the haskell equivalent to sprintf?
09:54:31 <lispy|web> I'm of no more use certainly
09:54:35 <quicksilver> twobitwork: printf
09:54:37 <lispy|web> ?hoogle sprintf
09:54:37 <lambdabot> No matches found
09:54:40 <lispy|web> ?hoogle printf
09:54:40 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
09:54:40 <lambdabot> Text.Printf :: module
09:54:40 <lambdabot> Text.Printf.PrintfType :: class PrintfType t
09:54:44 <twobitwork> ahh, thanks
09:54:49 <ddarius> BMeph: ghc-core just displays core more prettily.
09:54:51 <quicksilver> > printf "%0.4f" 1.5 :: String
09:54:53 <lambdabot>  "1.5000"
09:54:53 <lispy|web> > printf "%d" 1
09:54:53 <lambdabot>  Add a type signature
09:55:02 <quicksilver> not that I much like printf in haskell
09:55:03 <quicksilver> but it works :)
09:55:05 <BMeph> lispy|web: Thanks for the interest. :)
09:55:15 <twobitwork> quicksilver: is there a better way?
09:55:30 <quicksilver> depends what you're trying to do :)
09:55:41 <quicksilver> for simple stuff I just concatenate strings with ++
09:55:53 <quicksilver> for complex stuff there are a couple of rather fancy pretty printer libraryes around
09:55:55 <twobitwork> well... I want to do in-string replacing
09:56:06 <lispy|web> We should have a google translation service between languages.  It helps you find replacements in your target language for standard functions in the source language
09:56:09 <ddarius> @hackage hstringtemplate
09:56:10 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hstringtemplate
09:56:24 <twobitwork> I'll just use printf :)
09:57:12 <ddarius> @hackage HStringTemplate
09:57:13 <quicksilver> if you want "hello %s how are you %s how %s to see you","twobitwork","today","nice"
09:57:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HStringTemplate
09:57:17 <quicksilver> then maybe printf is fine.
09:57:21 <quicksilver> although personally I'd write
09:57:34 <quicksilver> "hello " ++ "twobitwork" ++ " how are you " ++ "today" ....
09:57:47 <quicksilver> (or, actually, I'd use concat but that's probably not the point)
09:57:48 <BMeph> ddarius: What do you mean by yhat statement?
09:57:59 <BMeph> s/yhat/that/
09:58:07 <Deewiant> I prefer the format string as you can see the whole sentence at once, which is IMHO more clear
09:58:12 <ddarius> BMeph: GHC is what translates your code to core.
09:58:46 <orbitz> The Core? The best movie of thecentury?
10:01:58 <BMeph> ddarius: Oh, well, yes, that's true - ghc-core calls GHC, and then massages the results more from there - at least, that's my bare understanding
10:01:58 <EvilTerran> > printf "%d" "error?" :: String
10:01:58 <lambdabot>  "Exception: Printf.printf: bad argument
10:01:58 <EvilTerran> is the trouble with format strings. less runtime safety.
10:01:58 <ddarius> EvilTerran: It's a heck of a lot better than C.
10:01:58 <wjt> > printf "%d" "error?" :: Maybe String -- would be nice to have
10:01:58 <lambdabot>        add an instance declaration for (PrintfType (Maybe String))
10:01:58 <lambdabot>     In the...
10:03:21 <EvilTerran> ddarius, eh, true. altho most C implementations i know of check the parameters of functions they know to be printf-esque at compile time
10:03:21 <EvilTerran> and issue a warning if they're wrong
10:03:21 <ddarius> And if the string isn't available at compile-time...
10:03:21 <EvilTerran> *then* you're sunk. but the same applies to the haskell one.
10:03:26 <MyCatVerbs> ddarius: functional unparsing!
10:03:27 <ddarius> EvilTerran: No, the Haskell version won't corrupt your memory if you give it a bad format string.
10:03:33 <MyCatVerbs> ddarius: functional unparsing! Functional unparsing!
10:03:40 <EvilTerran> but it will give you an exception
10:03:52 <EvilTerran> it's a less unpleasant error, but it's still an error
10:04:17 <Deewiant> and doesn't it just call 'error'? in which case you can't even handle it
10:04:18 <ddarius> EvilTerran: Giving an exception for an exceptional case seems quite reasonable.
10:04:29 <EvilTerran> yes.
10:04:33 <ddarius> Deewiant: The String version does.  The IO version presumably uses IOError
10:04:33 <MyCatVerbs> ddarius: er, actually, I think vprintf and family use sentinel values to prevent the thing from swiping too much or too little data from the stack.
10:04:44 <Deewiant> ddarius: aye, hence wjt's comment, I imagine.
10:05:00 <EvilTerran> but not using format strings when you don't have to in the first place gets rid of that problem
10:05:03 <MyCatVerbs> ddarius: they take va_lists rather than plain ol' variable numbers of arguments.
10:05:07 <MyCatVerbs> EvilTerran: functional unparsing! <3
10:05:27 <EvilTerran> MyCatVerbs, care to stop just saying that over and over and explain what the hell you're talking about?
10:05:42 <twobitwork> is there something like unwords which allows you to specify what to use to join them besides a space?
10:05:48 <MyCatVerbs> EvilTerran: http://www.brics.dk/RS/98/12/ <-- functional unparsing!
10:05:49 <lambdabot> Title: Functional Unparsing
10:05:50 <mauke> twobitwork: yes, intercalate
10:05:58 * ddarius has probably read the paper before MyCatVerbs even heard of Haskell.
10:06:16 <lispy|web> > intercalate ["a","b","c"] ";"
10:06:16 <lambdabot>  Couldn't match expected type `[[Char]]'
10:06:20 <MyCatVerbs> ddarius: almost certainly true.
10:06:23 <lispy|web> :t intercalate
10:06:25 <lambdabot> forall a. [a] -> [[a]] -> [a]
10:06:26 <Deewiant> > flip intercalate ["a", "b", "c"] ";"
10:06:27 <twobitwork> mauke: thanks
10:06:27 <lambdabot>  "a;b;c"
10:06:29 <MyCatVerbs> ddarius: it's just that it was a really cool name.
10:06:32 <twobitwork> @hoogle intercalate
10:06:32 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
10:06:32 <lambdabot> Data.ByteString.intercalate :: ByteString -> [ByteString] -> ByteString
10:06:32 <lambdabot> Data.ByteString.Char8.intercalate :: ByteString -> [ByteString] -> ByteString
10:07:45 <MyCatVerbs> EvilTerran: effectively a printf-like EDSL that embeds quite nicely into anything that resembles ML (Haskell included). Abuses continuation-passing cleverly, turned out to be about 30% faster than their ML's implementation of string-printf, all told.
10:07:45 <mauke> preflex: seen augustss
10:07:45 <preflex>  augustss was last seen on #haskell 18 hours, 6 minutes and 48 seconds ago, saying: tessier: with an FPGA you pay to have a digital abstraction.  With ASIC and even more custom design you have to do a lot of analog stuff.
10:08:02 <EvilTerran> sounds good
10:08:06 <Arnar> > let split delim = takeWhile (not . null) . unfoldr (Just . (second $ drop 1) . break (== delim)) in concat $ zipWith (++) (split '%' "Count %, % and %!") ["one", "two", "three"]
10:08:08 <lambdabot>  "Count one, two and three"
10:10:02 <pcc1> how do I "specify that explicitly" ref: http://tuukka.iki.fi/tmp/haskell-2007-12-16.html#02:17:10
10:10:03 <lambdabot> Title: haskell-2007-12-16
10:10:50 <cjs> Is there a way to match on the constructor name only, without having to specify the number of fields that you're ignoring anyway? E.g., Instead of "isOption (Call _ _ _ _) = True", I just want to match the "Call" part, and not have to change the number of "_" parts every time I add or delete a field.
10:11:29 <mauke> Call{}
10:12:08 <encryptio> cjs: declare the type and use _ by itself, a la: isOption :: Call -> Bool; isOption _ = True
10:13:29 <Deewiant> encryptio: what if he's got data Foo = Call Int Int | Bar Double | Baz Char Char Int
10:13:51 <Deewiant> or rather, that's what I figured he's got
10:14:05 <cjs> What Deewiant said.
10:14:10 <Deewiant> cjs: what mauke said
10:14:12 <encryptio> then my explicit code is has undefined types
10:14:14 <cjs> mauke, you're a genius!
10:14:23 <mauke> yes
10:14:39 <pcc1> more specifically: how do I tell hs-plugins to load the haskell98 package?
10:14:42 <encryptio> Deewiant: in that case, it'd be Foo -> Bool
10:14:51 <cjs> Also, "urusai"! (That's Japanese for genius.)
10:15:00 <mauke> uruk-hai
10:15:09 * encryptio shrugs. "bugs bugs bugs."
10:15:11 <Deewiant> encryptio: yeah, but the pattern match wouldn't work, because he wants to handle Call separately from the rest
10:15:13 <pcc1> cjs: that means "annoying" or "shut up"
10:15:29 <Deewiant> I guess he's after "tensai"?
10:16:04 <cjs> Damn, well, my Japanese is pretty bad. Shou-ga-nai.
10:17:04 <cjs> But I probably would never have figured out the {} syntax by myself. It's too sensible, and I'm too conditioned to Ruby making me do things weird ways.
10:18:44 <cjs> encryptio: for the details, see http://hpaste.org/7770
10:18:54 <encryptio> indeed.
10:18:59 <cjs> It probably wasn't completely clear from my initial description.
10:19:13 <lstor> cjs: I'm just about writing my first Ruby program. Please be slightly more motivating ;-)
10:19:23 <lstor> *just about to
10:19:30 <cjs> Err..."give up now, before it's too late." :-)
10:19:34 <eek> lstor, I personally find Ruby to mostly be friendly
10:19:45 <lstor> "Mostly harmless"? ;)
10:20:22 <cjs> It's not too bad, really. It's got a *lot* of quirks, but I certainly don't regret moving to it from Java a few years ago.
10:20:54 <pcc1> pcc1: loadPackage "haskell98"
10:21:05 <eek> lstor, whether it is reasonable syntax-wise or does things "weird ways" probably depends on your prior experience - I found most things in it reasonable (the different types of function objects and the @@-variables are weird, though)
10:21:54 <cjs> eek, There are a lot of nice syntax bits that you'd never figure out on your own, from knowing how things work in general; someone has to tell you about them.
10:22:55 <cjs> But that kind of stuff really isn't too much of a bother until you're maintaining thousands, or perhaps even tens of thousands, of lines of Ruby code.
10:24:10 <eek> cjs, maybe - I'm not sure what syntax bits you find weird, so it's hard for me to say if I agree with you or not.  I've written a few thousand lines of Ruby, possibly 10 thousand, but not dealt with it for significant amounts of time and haven't maintained things over very long
10:25:39 <BMeph> pcc1: Sorry for resurrecting an old convo, but didn't you mean "urusei"?
10:26:15 <pcc1> BMeph: I believe urusei is a "crude" way of saying urusai, but I'm not an expert
10:27:33 <BMeph> pcc1: Hm, good point; Japanese has a lot of constructs like that.
10:28:13 <pcc1> wrt my problem, unfortunately loadPackage "haskell98" appeared to do nothing, strace reveals that the package isn't even looked for
10:28:40 <Arnar> what language are the .cmm files in the GHC source?
10:29:30 <dmwit> A relative of c minus minus.
10:29:56 <dmwit> I don't remember exactly what it's called.
10:30:06 <Arnar> dmwit: it's compiled by gcc?
10:30:10 <sebaseba> pcc1: that's correct
10:30:18 <Arnar> dmwit: or is there some translation tool included with ghc?
10:30:19 <dmwit> Arnar: No, it's compiled internally.
10:30:27 <Arnar> ok..
10:32:42 <cjs> BMeph: that would be "uruse" with a little "tsu" after the end.
10:33:30 <twobitwork> I've found myself doing a lot of "do { db <- connectDb foo; doSomething db; somethingElse db bar; moreToDo db otherStuff}" ... is this the sort of thing which can be simplified with a state monad?
10:33:41 <cjs> eek, I'm maintaining somewhere around 15,000 lines of Ruby code in various production systems, including stuff like a small SIP stack, which I guess means I've probably hacked out 100,000 or so in the last three years. (I do lots of refactoring and rewriting.)
10:33:43 <twobitwork> i.e., so I don't have to explicitly pass in db for every call?
10:33:54 <BMeph> cjs: Why not "uruse" with an "i" on the end? ;)
10:33:55 <dmwit> twobitwork: That looks more like the Reader monad unless db is actually changing.
10:34:11 <twobitwork> dmwit: no it's not... how would that look in the Reader monad?
10:34:16 <cjs> BMeph, because then it wouldn't be crude any more. :-)
10:34:37 <BMeph> cjs: BWAHAHA! Good one! :)
10:34:43 <twobitwork> and well... the database is changing, but the db reference isn't
10:34:53 <eek> cjs, so, any particular syntactic constructs you think of as weird/hard to understand?
10:35:04 <dmwit> twobitwork: You would actually probably want some kind of ReaderT, since you are already within a monad.
10:35:12 <Saizan> cjs: little tsu? don't they use something like a '~' for wovels?
10:35:15 <cjs> Sorry, I can't type Japanese into this client as it's set up now, but if you could listen to it it makes complete sense. Anyway, any more Japanese goes to that off-topic channel, I think, whatever it is....
10:35:32 <twobitwork> dmwit: its in the IO monad, but I'm not sure if I need to be in the IO monad...
10:35:45 <dmwit> twobitwork: Then, in the ReaderT, it would look like "flip doSomething; flip doSomethingElse bar".
10:35:50 <eek> cjs, I'm considering doing a little language design, and I'd like to avoid falling into whatever things people feel as traps in Ruby
10:35:55 <cjs> eek: Well, I never would have figured out myself that you can use a rescue without a begin if it's a, sort of, what would you say, "end of method definition" rescue.
10:36:22 <dmwit> s/flip doSomething/doSomething/
10:36:36 <cjs> Eg: def foo; begin blah; rescue ...; end; end   becomes  def foo; blah; rescue ...; end.
10:36:43 <eek> cjs, right.
10:36:52 <dmwit> twobitwork: The odd thing about the Reader monad is that the shared argument must come last.
10:37:06 <twobitwork> dmwit: right... I see
10:37:25 <twobitwork> well... they're all my functions, so I can rewrite them to accept the db last
10:37:30 <cjs> The "you have one special block as a parameter" thing is annoying. Smalltalk doesn't have that, and that's why they don't need a syntatic if.
10:37:30 <eek> cjs, there's even weirder places you can use rescue, just attaching it to a statement.  I'll agree that's weird - easy to understand when you know it, hard to find out to become an optimal programmer
10:37:56 <twobitwork> i.e., all wrapper/convenience functions
10:38:28 <eek> cjs, I find the fact that that block is implictly declared inconvenient, at least.  yield should just be  a call on block passed with &block at the end of the list
10:38:28 <cjs> Oh, don't talk to me about attaching it to a statement. Every time I try to use that I get nailed, because I really should be rescuing only the crap I expect. Rather than, say, NameErrors when I mispell a function name.
10:39:08 <cjs> Hey, I'll do more Ruby and Japanese stuff on #haskell-overflow, ok?
10:39:55 <twobitwork> is --... a valid operator in haskell?? vim seems to think its an op rather than a comment
10:39:56 <cjs> Oh, but I will say here, the Ruby libraries suck. And it wasn't 'till I started using Haskell that I realized how clean libraries can be.
10:40:11 <EvilTerran> > let (--...) = (,) in 1 --... 2
10:40:12 <lambdabot> Unbalanced parentheses
10:40:24 <dmwit> Sources say no.
10:41:17 <EvilTerran> > let x --... y = (x,y) in 1 --... 2
10:41:19 <lambdabot>  (1,2)
10:41:21 <EvilTerran> or, yes
10:41:32 <EvilTerran> i think that's just Language.Haskell being wrong
10:41:34 <twobitwork> ahh.. heh
10:41:43 <twobitwork> hmm
10:42:17 * twobitwork tries it in compiled code
10:42:35 <laz0r> hi, can i use haddock to generate some kind of standard documentation without inserting special formatted comments into the source?
10:42:50 <laz0r> just a listing of all functions with its type for example
10:42:56 <EvilTerran> you can get a page listing all the exports with their types, i think
10:43:09 <laz0r> ok
10:43:12 <Saizan> just annotate your functions with their type
10:43:37 <twobitwork> ok, compiled code treats it as a valid oop
10:43:38 <twobitwork> op*
10:44:53 <pcc1> hmm, turning on debugging for hs-plugins reveals that haskell98 package's list of object files is empty
10:47:32 <laz0r> mmh, ok, works fine with normal haskell source files, but i wanted to generate haddock docs for the hsdl package
10:47:43 <doun> has anyone considered a well typed html library? e.g. putting a block-level element inside an inline element makes a compile error (e.g. <a href=''><p>whut</p></a>)
10:48:10 <laz0r> and that uses mostly .hsc files, which i assume are haskell spiced up with some C code
10:48:14 <Zao> doun: WASH had one.
10:48:34 <doun> Zao: did it help programming at all?
10:48:50 <Zao> I suppose.
10:49:49 <Zao> doun: http://www.acc.umu.se/~zao/Blag.MakeHTML.hs
10:50:07 <Zao> doun: For an example, see the main at the bottom. Makes composition of documents from parts really easy.
10:51:03 <laz0r> oh, instead of using hsdl, i guess i'll better use hsSDL
10:51:29 <MyCatVerbs> laz0r: hsdl doesn't have enough esssssses to be considered usable.
10:52:31 <doun> Zao: hmm. interesting
10:52:54 <Bonus> what's the most idiomatic way to get the last two elements of a list?
10:53:04 <Bonus> (last . init $ t):[last t] ?
10:53:11 <Deewiant> reverse . take 2 . reverse?
10:53:23 <Zao> I had to apply some mangling to the wash/html source to get it to compile on modern GHCs and to get it to output valid XHTML.
10:53:25 <Bonus> hmm yeah or that
10:53:43 <doun> Zao: do you have an opinion of that in comparison to Text.Html?
10:54:10 <doun> (or indeed, Text.XHtml)
10:54:47 <Zao> doun: No idea. Text.XHtml didn't exist when I evaluated the alternatives.
10:54:53 <doun> Zao: right
10:57:00 <Zao> doun: I like this one for two reasons. It gets really noisy when doing something wrong, and it's supposedly very effective.
10:57:25 <doun> Zao: my only Haskell web app has been a simple poll creation web site: http://poller.mine.nu/ (and source: http://rtfs.ath.cx/poller/ ), but I had to create a few utils to do it. other than having to write some utils, I found writing a web app in Haskell quite enjoyable so I am thinking of writing a simple library for myself
10:57:25 <MyCatVerbs> @src return ((->) r)
10:57:26 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:57:36 <doun> Zao: indeed. I would presume that would be useful
10:57:39 <MyCatVerbs> ...damn electricity. :(
10:57:47 <Zao> doun: The code I linked is the main part of my static blog system by the way.
10:58:02 <Zao> I generate the xhtml and rss offline and serve static pages with apache.
10:58:05 <doun> Zao: I don't know of it. Link?
10:58:18 <doun> Zao: yeah, that is a nice approach
10:58:34 <Zao> I have no public link for it, I wrote it for having somewhere to put my progress reports for my thesis.
10:58:48 <Zao> It's all backed by sqlite3 through hdbc.
10:58:51 <doun> ahh
10:58:59 <doun> indeed, I used the same library and sqlite3
10:59:03 <Zao> I may clean it up and reuse it later.
10:59:38 <Zao> doun: The result is something along the lines of http://www.cs.umu.se/~c03lvd/blagoblag.png
11:00:23 <doun> Zao: very nice
11:01:00 <doun> Zao: would you share the whole source?
11:03:17 <MyCatVerbs> Hmrn. Are all monads that you can extract the values from also comonads?
11:03:26 <Zao> doun: http://www.acc.umu.se/~zao/blag_source
11:03:27 <lambdabot> Title: Index of /~zao/blag_source
11:03:51 <doun> Zao: thanks. much appreciated
11:04:07 <Zao> doun: The Text.* parts are my modified WASH/HTML code, the Blag.* parts is mine.
11:04:24 <doun> ah
11:04:45 <Zao> The XHTML part may be slightly too generously accepting, since I do not know the whole XHTML spec :)
11:09:44 <Apocalisp> ?pl \f xs -> join $ fmap f (fmap sequence xs)
11:09:44 <lambdabot> (join .) . (. fmap sequence) . fmap
11:12:40 <Apocalisp> Am I missing a shortcut here: join $ fmap f (fmap sequence xs)
11:12:53 <vixey> (:
11:13:07 <fons> does anyone know how haddock checks for the ghc installation (where to look for the ghc libraries directory?)
11:13:24 <vixey> :t join (?f . (sequence . ?xs))
11:13:33 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) a1. (Monad m, Functor m, ?xs::m [m1 a1], Monad m1, ?f::m1 [a1] -> m a) => m a
11:14:08 <doun> is there a function like Monad m => m Bool -> m a -> m a -> m a
11:14:21 <doun> like `if' but for the return value of a monadic function?
11:15:26 <twobitwork> point-free notation seems like its more confusing than its worth in most cases
11:15:49 <ReinoDios> what is exactly a monad?
11:16:11 <twobitwork> ReinoDios: http://www.haskell.org/haskellwiki/Monads_as_Containers
11:16:14 <lambdabot> Title: Monads as containers - HaskellWiki
11:16:21 <doun> well I mean for example
11:16:48 <doun> myIf (Just True) (Just "yay") (Just "aww") => Just "yay"
11:16:49 <dcoutts_> twobitwork: once you get into (f .) . g  then yes, but for many things, point free, or nearly point free is very elegant
11:16:52 <doun> or something like that
11:17:03 <twobitwork> dcoutts_: right.. it can be
11:17:23 <dcoutts_> twobitwork: if your whole function is a single pipeline then it's really clear from looking at it what the structure is
11:17:59 <twobitwork> dcoutts_: right... something like: f = g . h . i
11:18:26 <dcoutts_> twobitwork: right, but even if it's f x y z = g x . h x y . i z
11:18:45 <dcoutts_> twobitwork: that's not technically point free, but it's still really nice and clear
11:18:51 <twobitwork> true
11:19:00 <ReinoDios> http://www.haskell.org/ is fallen and it says "Red Hat Enterprise Linux Test Page"
11:19:01 <lambdabot> Title: Haskell - HaskellWiki
11:19:05 <dcoutts_> @pl \x y z = g x . h x y . i z
11:19:06 <lambdabot> (line 1, column 8):
11:19:06 <lambdabot> unexpected "="
11:19:06 <lambdabot> expecting pattern or "->"
11:19:12 <dcoutts_> @pl \x y z -> g x . h x y . i z
11:19:12 <lambdabot> ap ((.) . (.) . (.) . g) (flip flip i . (((.) . (.)) .) . h)
11:19:19 <geezusfreeek> conal: haha, nice looking operator in your vector-space package: ^-^
11:19:20 <EvilTerran> doun, i don't think there is such a thing, but, if there were, it'd probably be called ifM
11:19:35 <twobitwork> ReinoDios: are you sure? works fine for me
11:20:14 <conal> geezusfreeek: oh! i hadn't noticed the kitty-ears
11:20:15 <ReinoDios> i thought it's one fallen of the balanced load http servers
11:20:42 <dcoutts_> ReinoDios: there's only one haskell.org server. I don't think it uses any load balancing proxies.
11:20:46 <EvilTerran> doun, there's probably no standard definition as it's not apparent from the type whether "ifM p t e = do p' <- p; if p' then t else e" or "ifM p t e = do p' <- p; t' <- t; e' <- e; return (if p then t else e)"
11:20:48 <conal> geezusfreeek: btw, just pushed a new version.   fixed bug & changed derivative tower rep.
11:20:52 <geezusfreeek> you have kisses too: :-*
11:21:02 <doun> EvilTerran: I suspected it would be called that. there IS a whenM somewhere, I believe... so I guessed, maybe an ifM?
11:21:02 <EvilTerran> er, (if p' then t' else e')
11:21:13 <twobitwork> dcoutts_: the dns record shows 4 addresses
11:21:19 <ReinoDios> is haskell.org IP 128.36.229.215 ?
11:21:21 <conal> about to push new haddock docs
11:21:26 <doun> EvilTerran: hmm
11:21:30 <EvilTerran> i'd go for the former of those two definitions, incidentally. it strikes me as both simpler and more generally useful
11:21:35 <geezusfreeek> conal: oh there must be a public repo i'm not seeing. i'm looking in hackage
11:21:39 <dcoutts_> ReinoDios: yep
11:21:46 <geezusfreeek> conal: oh, linked from the wiki page, i see
11:21:52 <EvilTerran> http://downforeveryoneorjustme.com/haskell.org
11:21:53 <lambdabot> Title: It's just you.
11:22:04 <conal> geezusfreeek: yep.  both will be updated in a couple of minutes
11:22:22 <EvilTerran> heh. nice co-ordination between downforeveryone and lambdabot there.
11:22:41 <dcoutts_> twobitwork: hmm? I don't see that. dig says just one.
11:22:42 <twobitwork> very nice
11:22:53 <twobitwork> dcoutts_: yeah, sorry... I was looking at the Authority section :P
11:23:02 <ReinoDios> i though my connection to haskell.org is being damned filtered
11:23:03 <dcoutts_> ah, yes
11:23:21 <dcoutts_> ReinoDios: it's subversive material ;-)
11:23:24 <EvilTerran> doun, as i said, i'm pretty sure it's not defined anywhere in the stdlibs. but, if you call it ifM, people will probably know what you mean :)
11:23:58 <EvilTerran> compare mapM, forM, zipWithM, foldM, replicateM, ...
11:24:20 <vixey> why would you ever want ifM?
11:24:45 <dcoutts_> it's a fairly trivial >>= \x -> if x ...
11:24:47 <vixey> :t \x y z -> x >>= (if x then y else z)
11:24:48 <EvilTerran> i've wanted it in the past
11:24:52 <ReinoDios> i won't forget it damned web filtering
11:24:58 <vixey> @undef
11:25:02 <EvilTerran> dcoutts' version is fine, but very pointy
11:25:02 <lambdabot> thread killed
11:25:05 <vixey> :t \x y z -> x >>= (if x then y else z)
11:25:08 <lambdabot>     Couldn't match expected type `Bool' against inferred type `m a'
11:25:08 <lambdabot>     In the predicate expression: x
11:25:08 <lambdabot>     In the second argument of `(>>=)', namely `(if x then y else z)'
11:25:14 <lambdabot> thread killed
11:25:17 <dcoutts_> EvilTerran: heh :-)
11:25:24 <dcoutts_> EvilTerran: could use the Bool natural fold
11:25:32 <conal> geezusfreeek: updated repo, wiki, hackage.  working on blog post
11:25:37 <EvilTerran> you can write some lovely if'-esque pointsfree stuff with an ifM
11:25:40 <geezusfreeek> conal: sweet
11:25:40 <maltem> I think I once defined ifM, and exactly like that
11:25:42 <EvilTerran> dcoutts_, tell me more?
11:25:54 <vixey> \x y z -> x >>= (\x -> if x then y else z)
11:25:55 <dcoutts_> EvilTerran: well, what is the fold for Bool?
11:26:13 <EvilTerran> bool x y False = x; bool x y True = y --?
11:26:18 <dcoutts_> right
11:26:42 <dcoutts_> so ifM c t e = m >>= bool t e   (right?)
11:26:45 <ReinoDios> Today, 20th  May 2008, http://www.haskell.org/ said "Test Page for the Apache HTTP Server on Red Hat Enterprise Linux"
11:26:46 <lambdabot> Title: Haskell - HaskellWiki
11:26:49 <EvilTerran> and ifM p x y = bool y x =<< p, by those definitions
11:26:59 <EvilTerran> that'd do nicely
11:27:08 <dcoutts_> aye, so no need for ifM :-)
11:27:19 <EvilTerran> true
11:27:22 <EvilTerran> you win :P
11:27:27 <lispy|web> http://downforeveryoneorjustme.com/downforeveryoneorjustme.com
11:27:28 <dcoutts_> heh heh heh
11:27:28 <lambdabot> Title: It's just you.
11:27:31 <EvilTerran> now we just need "bool" in the stdlib
11:27:33 <lispy|web> they think they are down
11:27:45 <EvilTerran> lispy|web, heh. fnord.
11:27:46 <dcoutts_> EvilTerran: I quite likes the convention of a fold named after the type
11:27:59 <EvilTerran> yeah, i took it from "maybe" and "either"
11:28:07 <dcoutts_> EvilTerran: right exactly
11:28:18 <EvilTerran> ... and the other definition of ifM i mentioned above would be (isomorphic to) liftA3 bool
11:28:23 <dcoutts_> clearly we need list, bool, int etc :-)
11:28:41 <EvilTerran> although i prefer to think of those functions as deconstructors rather than folds
11:28:59 <EvilTerran> so "list f e [] = []; list f e (x:xs) = f x xs"
11:29:10 <dcoutts_> no no, list = foldr
11:29:22 <EvilTerran> er, list f e [] = e,
11:29:37 <EvilTerran> dcoutts_, but we already have foldr, and i keep wanting my version of list :P
11:29:52 <dcoutts_> EvilTerran: I might call that uncons
11:29:59 <pcc1> I eventually "solved" my problem by manually loading all the dependencies using loadRawObject.  this can't be the right way to do it?
11:30:24 <EvilTerran> hm... that kinda works. bit funny to have a case for [] in a function called uncons, though
11:30:47 <cjs> No, no, call it 'rad'.
11:30:56 <EvilTerran> ... what for?
11:31:02 <dcoutts_> the alternative definition is uncons [] = Nothing; uncons (x:xs) = Just (x, xs)
11:31:04 <cjs> Oops, 'rac'. Never mind. Doesn't sound as good that way.
11:31:13 <EvilTerran> "rac"?
11:31:17 <dcoutts_> in which case one can use uncons and maybe
11:31:23 <cjs> > reverse "rac"
11:31:24 <lambdabot>  "car"
11:31:26 <EvilTerran> ah
11:31:39 <EvilTerran> "unlist" would work, too
11:31:40 <cjs> @lambdasnack
11:31:41 <lambdabot> Unknown command, try @list
11:31:50 <cjs> @botsnack
11:31:51 <lambdabot> :)
11:32:04 <dcoutts_> EvilTerran: bytestring has an uncons
11:32:19 <geezusfreeek> conal: just in case you hadn't thought of it, your lift2 function is the same as Control.Arrow.(***)
11:32:19 <dcoutts_> it saves one comparison vs head, tail
11:32:25 <tieTYT> dibblego: are you there?
11:32:38 <geezusfreeek> conal: i don't think that can help you with lift3 though, unfortunately
11:32:39 <tieTYT> no doubt this channel will be biased, but how do you guys feel about haskell vs erlang?
11:32:46 <tieTYT> i googled the topic but keep coming up with the same article
11:32:49 <EvilTerran> i quite like the CPS-esque-ness of it, tho, which you lose withe uncons. and it doesn't introduce that use of the Maybe type
11:32:54 <dcoutts_> EvilTerran: indeed unpack = unfoldr uncons :-)
11:32:57 <EvilTerran> ...
11:32:59 <tieTYT> this one, more or less: http://www.wagerlabs.com/blog/2005/12/haskell-vs-erla.html
11:33:00 <lambdabot> Title: Tenerife Skunkworks: Haskell vs Erlang
11:33:02 <geezusfreeek> tieTYT: i love erlang, actually, but i think it's just not quite as useful in general as haskell
11:33:05 * EvilTerran un-overlaps "with" and "the"
11:33:09 <int-e> dcoutts: do you have an opinion about http://hackage.haskell.org/trac/hackage/ticket/277 ?
11:33:11 <lambdabot> Title: #277 (add data-dir field) - Hackage - Trac
11:33:22 <tieTYT> this article seems to say that networking is way easier in erlang
11:33:27 <geezusfreeek> tieTYT: but for certain things, especially fault tolerant applications, erlang all the way
11:33:32 <dcoutts_> int-e: reading...
11:33:37 <cjs> Hm, tieTYT, just a point of information, but I'm doing a QuickCheck course next month in Erlang from John Hughes.
11:33:42 <tieTYT> and people are saying that haskell has a performance problem compared to erlang when it comes to concurrency
11:33:54 <dons> people are?
11:34:10 <dons> oh, joelr did, 3 years ago. heh
11:34:11 <twobitwork> does haskell support concurency?
11:34:12 <geezusfreeek> tieTYT: that's not true at all
11:34:18 <tieTYT> well here: http://reddit.com/r/programming/info/2330q/comments/
11:34:18 <dons> twobitwork: for the last 20 years.
11:34:25 <EvilTerran> twobitwork, in about six different ways, too
11:34:31 <twobitwork> ok :)
11:34:44 <cjs> Huh? Haskell I would think would be generally always way faster than Erlang, at least if you're using ghc.
11:34:47 <EvilTerran> well, we've got Control.Parallel, which isn't concurrency in the conventional sense
11:35:06 <EvilTerran> Control.Concurrent, with channels and shared variables and whatnot
11:35:09 <dons> we have an smp parallel runtime system, transactional memory, lightweight threads and a parallel garbage collector
11:35:09 <dcoutts_> int-e: it's a pretty neat patch. Do you think that covers all cases?
11:35:13 <dons> all compiled to native code.
11:35:17 <EvilTerran> and STM, which is weird and wonderful
11:35:17 <dcoutts_> @yarr!
11:35:17 <lambdabot> This is the END for you, you gutter-crawling cur!
11:35:22 <cjs> Oh, but do remember to turn on -O. I forgot that, and was disappointed at first. :-)
11:35:37 <dons> two public concurrency benchmarks,
11:35:39 <dons>  http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneosredux&lang=all
11:35:40 <lambdabot> Title: chameneos-redux benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer L ..., http://tinyurl.com/36jgbe
11:35:46 <cjs> Yeah, STM. that's one of the reasons I'm here.
11:35:52 <geezusfreeek> tieTYT: basically, i'd say erlang is the absolute best choice in its domain, but haskell is better as a general purpose language
11:35:55 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=threadring&lang=all
11:35:56 <lambdabot> Title: thread-ring benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Langu ..., http://tinyurl.com/2lyngq
11:36:01 <conal> geezusfreeek: which lift2?
11:36:09 <dons> erlang's not necessarily a great choice for shared memory multicore machines
11:36:19 <dons> for distribution, its unsurpassed
11:36:20 <halberd> why?
11:36:26 <tieTYT> geezusfreeek: what's its domain?
11:36:28 <tieTYT> telco apps?
11:36:40 <geezusfreeek> conal: oh there's more than one? Data.NumInstances is the one i noticed
11:37:00 <roconnor> erlang supposedly has fault tolerance
11:37:02 <geezusfreeek> conal: lift2 exp exp = exp *** exp
11:37:23 <tieTYT> what does fault tolerance mean?
11:37:28 <tieTYT> afaik, haskell has exceptions
11:37:36 <dons> erlang has libraries for monitoring multiple systems
11:37:39 <conal> geezusfreeek: no.  i just didn't remember where it was.  i've written so many kinds of liftings for various things.  thx
11:37:42 <cjs> roconnor, Yeah, amazing fault tolerance.
11:37:43 <twobitwork> failover, etc... no?
11:37:44 <dons> so if one fails, another can pick up
11:37:48 <geezusfreeek> tieTYT: it means that if a server goes down or there is some other kind of fatal error other parts of the system will revive and/or compensate for it
11:37:56 <tieTYT> ah i see
11:37:58 <int-e> dcoutts_: I've tested sdist, installing, and running in place (using the FOO_datadir environment variable ... set according to the datadir field.) Hmm, I missed "setup makefile".
11:37:58 <tieTYT> that's pretty cool
11:38:04 <roconnor> cjs: have you used it?
11:38:05 <geezusfreeek> tieTYT: haskell certainly could be _made_ to do that, but erlang is designed for it
11:38:08 <tieTYT> someone could make a lib for that in haskell i assume
11:38:14 <dcoutts_> erlang has clearly put a lot into their lib and deisigns for distributed stuff. I'm not sure there's anything fundamental that could not be replicated with some nice lib in Haskell
11:38:23 <dcoutts_> eh their process abstraction
11:38:23 <cjs> Though it did disturb me a bit than when I was talking with my Erlang friends about building an air traffic control system, their philosophy was, "let it crash." :-)
11:38:23 <dons> regarding haskell's shared memory concurrency, parallelism et al, http://haskell.org/haskellwiki/Applications_and_libraries/Concurrency_and_parallelism has an overview
11:38:24 <lambdabot> Title: Applications and libraries/Concurrency and parallelism - HaskellWiki, http://tinyurl.com/2u95za
11:38:25 <dcoutts_> eh/eg
11:38:35 <cjs> roconnor, A bit. And I'll be using it a bunch more soon.
11:38:36 <tieTYT> dcoutts: well you can say the same thing with any language
11:38:41 <geezusfreeek> tieTYT: fault tolerance is different from exception handling
11:38:43 <tieTYT> it's still really hard to do, usually
11:38:50 <dons> fault tolerance is different to high assurance
11:38:59 <dcoutts_> tieTYT: but some are no good for building abstractions, Haskell is approximately the best for building abstractions.
11:39:09 <tieTYT> dcoutts: I see
11:39:12 <conal> geezusfreeek: yeah, sigh.  there's so much library bias toward binary tuples among all of the tuples.  i have a hunch we'd be better off having only pairs and eliminating all of the others.
11:39:17 <roconnor> cjs: I've read a few blog posts about it, but I'm still concerned that erlang process will end up in crash-restart cycles
11:39:20 <int-e> dcoutts_: but 'makefile' already has limitations. "Setup.lhs: makefile: can't cope with multiple hs-source-dirs yet, sorry". anyway, I'll have a look at that.
11:39:23 <dcoutts_> int-e: ignore setup makefile
11:39:23 <cjs> roconnor, I honestly don't think you're going to find a lot of bad thing said here about it. It's got its problems as a language, at least compared to Haskell, but it does some stuff really really well.
11:39:33 <tieTYT> and honestly, the apps that require fault tolerance are in the minority
11:39:35 <int-e> dcoutts_: oh. fine. if you say so.
11:39:37 <tieTYT> some would be cool with it
11:39:50 <geezusfreeek> conal: making (a, b, c) = (a, (b, c)) ?
11:40:02 <tieTYT> anyway, i'm just learning a functional language as a hobby ATM.  I'll stick with haskell since this channel is so active
11:40:03 <conal> geezusfreeek: or ((a,b),c)
11:40:03 <cjs> roconnor, I don't think that that's any more of a worry than Haskell programs dying. Probably less, actually. The key there: use the libraries.
11:40:06 <geezusfreeek> conal: yeah
11:40:08 <dcoutts_> int-e: yeah. If it continues to work for the few ghc libs that use setup makefile that's enough. It does not need to acquire new features.
11:40:11 <conal> geezusfreeek: as in ML originally, iirc
11:40:14 <tieTYT> and real world haskell seems to be real easy to learn from
11:40:23 <cjs> They have libraries for a lot of the concurrency and control patterns that help a lot.
11:41:25 <geezusfreeek> conal: it would better fit the idea of cartesian product to do something like that i think, but i can't help but wonder what sorts of issues i might introduce (haven't done much ML)
11:41:38 <roconnor> cjs: well, my concern is that restart-cycle crashes would be the norm.
11:41:41 <cjs> roconnor, What are you trying to build, anwyay?
11:41:44 <roconnor> cjs: but I don't know.
11:41:46 <twobitwork> what's the general approach to application design in haskell? i.e., in OO you design from a clas-heirarchy/object-relation perspective with UML type charts/diagrams...
11:41:52 <dcoutts_> int-e: for some reason I don't like it, but I have no actual arguments against it, and your patch is very clean and straightforward. :-)
11:41:59 <roconnor> cjs: I'm not trying to build anything.
11:42:21 <cjs> roconnor, I doubt it, unless you used it badly. If that were the case, we probably wouldn't be talking right now, due to ATM switches crashing and restarting. :-)
11:42:24 <geezusfreeek> twobitsprite: in haskell you just think of what kinds of abstractions (or DSLs, if you prefer the term) you want and make them :)
11:42:27 <int-e> dcoutts_: it's almost purely cosmetical. maybe that's what you don't like?
11:42:45 <twobitwork> on a larger scale, are there best-practice recipies for designing and implementing systems in haskell, like you find for OO stuff?
11:42:56 <cjs> Well, then you're just playing, so whatever happens is fine. (I don't mean that in a bad way.)
11:43:08 <dcoutts_> int-e: it's so we can bung all the data files in data/ in the build tree and yet put them directly into the $datadir upon install.
11:43:27 <tieTYT> twobitsprite: i would say MOST OO projects don't use UML
11:43:31 <tieTYT> (and thank god)
11:43:32 <twobitwork> geezusfreeek: I'm trying to think of how a corporation would go about making apps in haskell as opposed to say java or c++
11:43:33 <dcoutts_> int-e: not that there is anything wrong with cosmetic stuff
11:43:41 <geezusfreeek> twobitsprite: i haven't done any "large scale" haskell applications, but i would think that as long as you don't have any leaky abstractions it should be pretty easy
11:43:42 <cjs> So do what's fun. And when you get an app where you get smacked over the side of the head if it doesn't work, then you can start to look at some of the issues involved, and make your compromises.
11:43:58 <geezusfreeek> twobitwork: i don't think most large corporations do java/c++ the best way either ;)
11:44:14 <twobitwork> geezusfreeek: true :) ... I never said they did...
11:44:27 <cjs> twobitwork, First, fire 90% of their programmers. And all of their managers. :-)
11:44:29 <geezusfreeek> twobitwork: likely the way a large corporation _would_ write a haskell program is the exact same way they do java/c++
11:44:30 <dcoutts_> int-e: perhaps if I ask you to add the documentation in doc/Cabal.xml then I'll shut up and apply it ;-)
11:44:34 <conal> geezusfreeek: my guess is that n-ary tuples were an accommodation to performance.  if so, i bet compiler optimization can now eliminate the inefficiency, as with curried functions.
11:44:36 <twobitwork> cjs: ha! :)
11:44:55 <tieTYT> ok yesterday I was talking to Baughn about this
11:44:57 <twobitwork> geezusfreeek: yeah, because all the managers would be used to doing things the same old way
11:45:01 <tieTYT> i don't really "get" lazy evaluation very well
11:45:02 <int-e> dcoutts_: there are two patches in that bundle
11:45:07 <dcoutts_> int-e: oh..
11:45:16 <tieTYT> i figure I'll just continue learning haskell and go back to it later
11:45:18 <dcoutts_> int-e: heh, yes ok :-)
11:45:37 <tieTYT> atm, i know so little about the haskell libraries that anything I read about the topic will probably be hard for me to understand
11:45:45 <twobitwork> tieTYT: for the most part, don't worry about it... in most cases it acts the same either way
11:45:46 <tieTYT> i just don't have a big enough haskell vocab yet
11:45:57 <geezusfreeek> conal: it has probably been brought up to the haskell' crew already (and probably was shot down since it seems they are being a bit more conservative than i would like)
11:46:07 <cjs> tieTYT, Just wait until you discover your simple little "pipe the data through" program uses 800 MB of memory, then drives your system into swap, and you can't do anything any more. Then you'll be motivated to figure it out. :-)
11:46:11 <edwardk> @seen ddarius
11:46:12 <lambdabot> I saw ddarius leaving #haskell, #haskell-blah, #haskell-overflow and #haskell-soc 1h 22m 9s ago, and .
11:46:33 <tieTYT> cjs: so until then, it's cool to just keep learning other things?
11:46:42 <conal> geezusfreeek: maybe a haskell2 issue, then
11:46:50 <cjs> tieTYT, Yes.
11:47:18 <xerox> why not changing name instead of appending digits
11:47:53 <xerox> "for this new version of the language you get to vote for the best new name", not that there's anything wrong with this one ;)
11:49:16 <geezusfreeek> conal: another thing i keep wishing i had with n-ary tuples is curry/uncurry!
11:49:40 <geezusfreeek> time for work
11:50:37 <brad_larsen> I'm writing a small toy compiler in Haskell for one of my courses.  I'm using Parsec to do the parsing.  I'm looking for hints on how to organize my datatypes, so that I have access to the source locations for later analysis/code gen phases.
11:50:55 <brad_larsen> Right now I don't pass that information on to the later phases.
11:51:13 <brad_larsen> I have an Expression datatype and a Statement datatype.
11:51:27 <brad_larsen> A program is a Statement list.
11:51:42 <Philippa> attach positions to all the constructors, it's easiest
11:51:51 <Philippa> if you've got a use for them then start and end
11:52:29 <Philippa> it's got the advantage that it's easier to flag up a whole subexpression or similar as broken when you're error-checking, stuff like that
11:52:45 <brad_larsen> That was my first thought, but I didn't know if there is a more general way to do it.
11:52:45 <Philippa> really the later phases only care for reporting back to the user though, no?
11:52:54 <brad_larsen> I have this phobia of boilerplate code ;-)
11:53:09 <laz0r> halp, neither hsdl nor hssdl seem to work on my system... sometimes it just segfaults, sometimes it does nothing but exits right away, and sometimes i get the error: 'SDL message: Unable to make GL context current'
11:53:10 <brad_larsen> yes.  and if the language requires error reporting at runtime, e.g. for division by zero
11:53:16 <Philippa> using the record syntax can help a bit. Beyond that you're getting into pretty high-powered stuff that's probably a bigger PITA than it's worth
11:53:17 <laz0r> maybe this is a known issue?
11:53:26 <brad_larsen> Philippa: thank you
11:53:48 <conal> can anyone think of a simple & familiar term for functions with a higher-dimensional (non-scalar) domains, other than "multi-variate"?
11:53:50 <edwardk> ok, naming convention: should universal arrows go in Control.Arrow.Universal? or Control.Morphism.Universal, since they aren't Arrows in the John Hughes sense, and are really just special morphisms?
11:53:52 <Philippa> eg parameterising on a "decoration" type and making your AST a functor
11:54:11 <edwardk> otoh, no one i know of calls then universal morphisms in category theory
11:54:26 <cjs> brad_larsen: that doesn't have to be boilerplate code, though I do it badly enough myself that I'd hesitate to give you hints.
11:54:28 <brad_larsen> Philippa: yeah, for this tiny thing that sounds like a PITA
11:54:31 <Philippa> edwardk: do they fit the Arrow class?
11:54:40 <Philippa> (I'm guessing not)
11:54:43 <edwardk> Philippa: nope.
11:54:49 <Philippa> not Control.Arrow.*, then
11:54:53 <edwardk> Philippa: hence why i'm leaning towards control.morphism.universal
11:55:23 <Philippa> the problem you've got from here is that really the right category doesn't exist and you're wary about creating one, no?
11:55:31 <cjs> brad_larsen, but you might take a look at HaRe, that Haskell refactoring tool; it had an even worse problem: preserve the source formatting when doing transformations on the parse tree.
11:55:55 <edwardk> Philippa: i have a ton of Control.Morphisms right now. Hylo, Cata, Ana, Apo, Futu, etc.
11:55:56 <cjs> (Admittedly, I understood barely a word of the Hare source code.)
11:55:58 <edwardk> so its not so bad
11:56:30 <brad_larsen> cjs:  Maybe I'll look into that.  For now I just need to get something working that isn't too horrible.  :-)
11:57:07 <edwardk> mostly was just looking for a natural name and the Control.Noun.Adjective pattern was ambiguous there. going with Control.Morphism.Universal
11:57:10 <conal> edwardk: maybe not in Control at all, since they're more general than control
11:57:46 <edwardk> conal: otoh, i build up a bunch of stuff for them out of Control.Functor.*
11:58:15 <conal> edwardk: yeah.  my comment applies to functors etc as well
11:58:34 <BMeph> dons: Do you have any "thicker" documentation or ghc-core? :)
11:58:37 <twobitwork> hmm there has to be a better way to do: f Nothing = "some long-ish string " ++ something; f (Mayby st) = "some long-ish string " ++ st --using a where clause for the shared long string...
11:58:40 <BMeph> s/or/for/
11:58:46 <twobitwork> but how?
11:58:48 <edwardk> not sure what the most appropriate place for then 90% of category-extras would be ;)
11:59:07 <conal> edwardk: really to type classes in general, since they're all about abstracting away from uses.
11:59:55 <conal> edwardk: more of a philosophical consideration than a serious suggestion
12:00:13 <edwardk> mostly i just started fitting into Control, because i needed a place for comonads, and monad is in control. then i needed a place for commonalities between the monad and comonad side, so control.functor
12:00:24 <edwardk> yeah
12:00:49 <conal> edwardk: btw, have you read clay shirky's ontology article?
12:00:51 <Philippa> fmap's at least analogous to what the imperative crowd know as a structured loop
12:01:03 <mar77a> is there any way to clear the screen with hs?
12:01:07 <mar77a> well with the def lib
12:01:13 <mar77a> std*
12:01:14 <vixey> mar77a: which screen?
12:01:16 <Philippa> so it's a sensible generalisation of one control structure
12:01:16 <mar77a> console
12:02:00 <vixey> putStrLn (unlines . replicate 5000 $ "")
12:02:03 <vixey> idk :?
12:02:31 <mar77a> isn't there something like import conio IO.cls :p
12:06:49 <dejones> in this line of Haskell, "[f] <- getArgs" does is the value of f all of the strings in the list?
12:07:02 <dejones> s/does//
12:07:13 <Heffalump> dejones: no, it asserts that there is precisely one argument and puts that in f
12:07:20 <Heffalump> if there is more than one argument, you will get a runtime failure
12:07:45 <dejones> Heffalump: ahh, ha.  :)  so [f,g] <- getArgs is for two arguments?
12:07:52 <Heffalump> right
12:08:08 <Heffalump> and if you want to be flexible, fs <- getArgs
12:08:48 <Heffalump> (when I say "more than one" above I also should have included the zero-argument case)
12:08:49 <dejones> Heffalump: so, the point is that you only expect one argument and if you want to use it right away, doing [f] allow for that without having to do "head fs" to get the value?
12:09:08 <Heffalump> right
12:09:14 <dejones> cool, thanks Heffalump.  :)
12:09:25 <Heffalump> if you want to get the first argument but not error out if there are others, f:_ <- getArgs
12:09:45 <vincenz_> re
12:10:00 * Heffalump uses the [...] <- getArgs pattern all the time for throwaway code, though
12:10:34 <BMeph> twobitwork: What's wrong with f str = "some longish string" ++ (maybe "nothing-string" id str)? :)
12:10:37 <tieTYT> yo
12:10:45 <tieTYT> do you guys know the title of that MIT book
12:10:58 <tieTYT> about programming, uses scheme to teach programming languages?
12:11:00 <geezusfreeek> tieTYT: SICP?
12:11:02 <tieTYT> yes
12:11:03 <dejones> tieTYT: Structure and the Interpretation of Programs?
12:11:05 <tieTYT> what's that stand for?
12:11:05 <tieTYT> thanks
12:11:15 <BMeph> Well, aside from its inherent clunkiness, anyway.
12:11:16 <tieTYT> geezusfreeek: yes to you
12:11:28 <dmwit> BMeph: The problem is that you're not using fromMaybe.
12:11:29 <dejones> tieTYT: ... of Computer Programs, sorry.
12:11:31 <dmwit> ?src fromMaybe
12:11:32 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
12:11:37 <dmwit> waugh!
12:11:51 <dmwit> fromMaybe def m = maybe def id m
12:12:01 <dejones> tieTyT: http://mitpress.mit.edu/sicp/
12:12:02 <lambdabot> Title: Welcome to the SICP Web Site
12:12:08 <tieTYT> thanks
12:13:50 <tieTYT> now
12:13:52 <tieTYT> i read some of this book
12:13:59 <BMeph> dmwit: Thanks, I went to the Maybe page a little late for that. :)
12:14:02 <tieTYT> and it did a really good job of explaining step by step how things get evaluated
12:14:06 <edwardk> conal: fraid not
12:14:10 <tieTYT> my question is, was it explaining lazy evaluation when it did that?
12:14:18 <tieTYT> if so, i may use this to re-learn what i forgot
12:14:32 <geezusfreeek> tieTYT: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-27.html#%_sec_4.2
12:14:33 <lambdabot> http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-27.html#%_sec_4.2
12:14:37 <edwardk> and yeah every ontology is flawed =)
12:14:48 <tieTYT> thanks
12:15:16 <twobitwork> BMeph: well... the string thing was just an example... I'm mostly wondering how you would share "where" clauses between different instances of a function :)
12:15:22 <geezusfreeek> tieTYT: and the direct answer to your question is no. most of the book is about strict evaluation
12:15:29 <tieTYT> oh
12:15:36 <edwardk> my wife is a computational linguist she spends most of her day in the Sisyphean task of making and breaking ontologies to organize information ;)
12:15:43 <twobitwork> BMeph: without some hokey "f = \a -> ... ; where ..."
12:15:48 <geezusfreeek> tieTYT: the section i just linked you to is about implementing a lazy interpreter though
12:16:12 <BMeph> twobitwork: where applies over the whole function, no fancy footwork needed.
12:16:12 <tieTYT> oh
12:16:14 <conal> edwardk: http://www.shirky.com/writings/ontology_overrated.html
12:16:14 <lambdabot> Title: Shirky: Ontology is Overrated -- Categories, Links, and Tags
12:16:19 <twobitwork> BMeph: oooh :)
12:17:56 <kosmikus> 33
12:18:15 <BMeph> twobitwork: Yes, very useful when you have guards in your definition. :)
12:18:19 <edwardk> conal: i agree with pretty much everything he says
12:18:38 <twobitwork> BMeph: ahh yes... I always forget about guards :)
12:19:33 <edwardk> conal: and having worked briefly on the GOLD linguistic ontology back when I was at LINGUIST i have no desire to ever engage in a series ontological effort again. ;) hence why i'm decidedly neutral on where junk gets placed in control.* ;)
12:19:39 <edwardk> er serious
12:20:11 <cjs> edwardk: :-)
12:20:26 <lament> i'm impressed that some people still take ontological efforts seriously (*cough* semantic web)
12:20:40 <conal> edwardk: yep -- there are no compelling answers to these ontological questions.  the problem comes from insisting on the question instead of letting it go.
12:20:44 <bos> they are semantic weebles.
12:20:51 <bos> they wobble, but they don't fall down.
12:20:56 <cjs> Hey, ontology progetchinates phenology!
12:21:14 * conal chuckles
12:21:20 <twobitwork> hmm... @pl doesn't like type constructors, does it?
12:21:29 <vincenz> @seen tibbe
12:21:29 <lambdabot> I saw tibbe leaving #ghc, #haskell and #xmonad 6h 48m 14s ago, and .
12:21:33 <vincenz> dons: ping
12:21:38 <vincenz> Or anyone that has worked with lambdabo
12:21:46 <geezusfreeek> twobitwork: pattern matching in general can't be point free
12:21:52 <BMeph> geezusfreeek: I'd be happy with n-ary tuples... ;)
12:21:54 <vincenz> so I got lambdabot installed, but when I try like '> 1 + 1' I get an hClose error.
12:21:59 <vincenz> Anyone know what that might be due to?
12:22:00 <twobitwork> geezusfreeek: yeah, I guess that makes sense
12:22:17 <BMeph> Sigh. NM. :)
12:22:20 <trontonic> > 1 + 1
12:22:22 <cjs> vincenz, "You're too close!"
12:22:24 <lambdabot>  2
12:22:45 <geezusfreeek> twobitwork: you can write some functions that equivalently extract data from some structure and use it to write point free functions though
12:23:13 <edwardk> conal: heh of course that begs the question of how one could implement a tag-based module hierarchy ;)
12:23:16 <geezusfreeek> twobitwork: fromMaybe, for example
12:23:42 <geezusfreeek> woah, a tag-based module hierarchy?! what are you guys talking about?
12:23:46 <conal> edwardk: though it has implications for the question of "whether"
12:23:57 <edwardk> true
12:24:00 <conal> edwardk: tag-based folksonomy
12:24:19 <edwardk> *nods*
12:24:45 <conal> edwardk: i'd like to get to the heart of what the current hierarchy accomplishes and then find solutions that don't impose the inherent problems of ontology.
12:24:55 <vincenz> DRMacIver: you around?
12:25:25 <edwardk> mostly is just lets you get newsgroup-like adjective.noun.verb.verb.verb structure ;)
12:25:41 <DRMacIver> vincenz: What's up?
12:25:56 <vincenz> DRMacIver: I found some code of yours n the web and had a couple of questions regarding it
12:26:29 <DRMacIver> Sure
12:26:38 <conal> edwardk: anyway, i doubt that the question has been explored much and would perhaps be an interesting & valuable research project & publication
12:26:39 <DRMacIver> Which one?
12:26:46 <BMeph> So, do you guys use something like Tullsen's Zip Calc for n-ary tuples, or what?
12:27:00 <vincenz> DRMacIver: the json parser
12:27:10 <DRMacIver> Oh, that.
12:27:17 <DRMacIver> I barely remember how it works. :)
12:27:20 <DRMacIver> But go on
12:27:26 <vincenz> First: do you have a recent file version
12:27:41 <vincenz> Second: how come you parse keys as identifiers and not as strings which is what it should be apparently
12:27:46 <edwardk> conal: well, to solve it i think you'd want to identify modules uniquely by url or something so they can be 'named'. another thought is i always thought relative urls would be a nice way to structure code compositionally. so you can add a new 'outer layer' to any namespacing at any time.
12:28:00 <edwardk> but thats orthogonal to the issue of folksonomy
12:28:30 <lilac> geezusfreeek: i think there's a pointfree case proposal kicking around: "case x of ..." == "\x -> case of ..."
12:28:53 <geezusfreeek> lilac: oh?
12:28:55 <DRMacIver> vincenz: You can grab the most recent version from http://freehg.org/u/DRMacIver/misc/ but I don't think I've changed it much
12:28:55 <lambdabot> Title: Miscellaneous code summary - freeHg.org
12:29:08 <DRMacIver> vincenz: Second: Because I misunderstood the JSON spec.
12:29:38 <MarcWeber> Which is the way to end a process from within another thread? Non working example : http://rafb.net/p/dwUHqu62.html
12:29:41 <conal> edwardk: probably useful ideas for a solution, but first i'd like a lot more clarity on what the question (requirements).
12:29:43 <lambdabot> Title: Nopaste - No description
12:29:48 <MarcWeber> do I need to throw an Exception at the main thread?
12:30:06 <DRMacIver> vincenz: There is much better JSON parsing code out there, including one from Galois in hackage. That thing is really a "Hm. I need to learn parsec. What's an easy thing I could do?"
12:30:06 <vincenz> DRMacIver: ok, thanks
12:30:25 <lilac> geezusfreeek: http://haskell.org/pipermail/haskell-cafe/2007-August/030576.html
12:30:25 <lambdabot> Title: [Haskell-cafe] Syntax for lambda case proposal could be "\of"
12:30:57 <conal> edwardk: and maybe fit into a broader question to do with expressing and accessing values of all types, not just software modules.
12:30:58 <edwardk> conal: yeah, plus i haven't been convinced yet of the utility of the idea. what does it mean to be able to locate modules by tags? we can do that now (hackage), what value does it add? sure it helps you find the module, but it doesn't seem at first glance to provide a mechanism for naming links to the module in code.
12:33:06 <conal> edwardk: on a related topic, i've been noticing how our assumptions/habits around software modules are deeply imperative, no less for functional languages than imperative ones.
12:33:42 <geezusfreeek> lilac: this still doesn't seem point free... it's just allowing more complex pattern matches in lambda expressions
12:34:21 <conal> edwardk: modules are assumed to be in a mutable store, and refer to each other via global variable names.
12:34:35 <edwardk> conal: on that note, i've been meaning to ask you this. would it make sense to consider a formulation of FRP in terms of a zippered list rather than a list? i realize this is a slightly more imperative notion of now, but it might give you a perspective on when you are that gets rid of some of your need for unambiguous choice.
12:34:52 <Philippa> conal: I suspect this has a lot to do with working with imperative OSes
12:34:59 <edwardk> conal: well, the unique uri thing if you did something like NixOS would store them based on a hash of their contents
12:35:13 <geezusfreeek> lilac: i think the only way it could truly be made point free is if, for every data structure, there automatically existed some function which has a parameter for each constructor of the type
12:35:15 <lilac> geezusfreeek: right you are.
12:35:25 <Philippa> also, because it's in some sense a /good idea/ - we really do want the key/value setup
12:35:26 <conal> Philippa: working on without abstracting from
12:35:35 <lilac> geezusfreeek: arguably, in the true lambda calculus, even those functions would be points ;-)
12:36:05 <Philippa> conal: or to put it another way, not writing own own OS on top. Not that I haven't given thought to this in the context of seriously persistant systems
12:36:17 <conal> edwardk: about frp & zipper, yes certainly.  i think i mention doing that in my "simply" paper.  unless i took it out.
12:36:23 <geezusfreeek> lilac: so for some type like data Foo a b = Foo a | Bar a b, the function would have type (a -> c) -> (a -> b -> c) -> Foo a b -> c
12:36:34 <edwardk> ah i must have missed it then
12:36:56 <Philippa> thing is, it's a practical problem - we know what happened to the old lisp and smalltalk systems, and not a lot of us want to put the effort into building something that goes the same way
12:36:59 <edwardk> i'd been thinking that since i first saw FRP, but hadn't seen it written down anywhere
12:37:02 <conal> Philippa: it's easy to abstract over file systems and other OS events, frp-style.
12:37:17 <Philippa> it's not a theoretical issue - hell, version control's all about emulating the immutable situation
12:38:03 <lilac> geezusfreeek: sure, that'd do the trick.
12:38:03 <Philippa> what's not easy is rewriting all the tools we work with. So there's your task: find a way of avoiding that while retaining the working model
12:38:24 <Philippa> hell, there's an obvious answer: write a new filesystem
12:38:47 <edwardk> venti is a nice start in that direction
12:38:49 <Philippa> except that leaves you attached to the existing naming scheme as the main interface
12:38:51 <edwardk> its already persistent
12:38:59 <edwardk> at least at the block level
12:40:02 <geezusfreeek> conal: wouldn't you say that Event works like lists and Reactive works (more or less) like zippered lists?
12:40:28 <twobitwork> @hoogle [(a, b)] -> a -> b
12:40:29 <lambdabot> No matches, try a more general search
12:40:32 <conal> geezusfreeek: semantically or operationally?
12:40:33 <geezusfreeek> conal: with the main difference being that Reactive has temporal significance but simple zippered lists wouldn't?
12:40:36 <twobitwork> @hoogle a -> [(a, b)] -> b
12:40:37 <lambdabot> No matches, try a more general search
12:40:51 <twobitwork> are there no functions for association lists?
12:41:10 <geezusfreeek> conal: hmm, that one made me stop and think about it :)
12:41:12 <dmwit> twobitwork: lookup
12:41:21 <dmwit> :t lookup
12:41:23 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
12:41:31 <twobitwork> ahh... stupid Maybe messing up my hoogle :P
12:41:40 <vixey> @hoogle a -> [(a, b)] -> _
12:41:41 <lambdabot> No matches, try a more general search
12:41:49 <vincenz> twobitwork: it makes sense, if there's no answer...waht do you return?
12:41:49 <Baughn> tieTYT: You /really/ want to understand the fibs-zipWith example before doing anything serious with haskell, though. I could walk you through it, if you like?
12:41:57 <conal> geezusfreeek: events are as temporal as reactive values.  zippers in the implementation traversing both would give more flexibility.  even efficiently in time, though not space.
12:41:58 <orbitz> there is a debate going in the ocaml mailing list about concurency and one person made a wild comment about STM and it being too difficult for real world applications.  Is STM more complex than it should be? Or it can be for real world apps?
12:41:59 <twobitwork> vincenz: right... I just wasn't thinking ahead :P
12:42:09 <tieTYT> sure
12:42:15 <geezusfreeek> conal: i think i worded my question badly
12:42:29 <tieTYT> let me startup ghci
12:43:33 <conal> geezusfreeek: never do that again!  ;)
12:43:43 <conal> geezusfreeek: (as my son Patrick says)
12:43:50 <Baughn> orbitz: I would say it's more complex than it has to be. It looks to me like it was written to explore the design space, and could be streamlined now
12:43:51 <tieTYT> ok i figured out zipWith: zipWith [1,2] [3,4]
12:43:53 <tieTYT> err
12:44:00 <tieTYT> zipWith (+) [1,2] [3,4]
12:44:06 <tieTYT> returns [4, 6]
12:44:13 <tieTYT> tell me that function definition again?
12:44:20 <orbitz> Baughn: interesting
12:44:28 <Baughn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
12:44:30 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:44:50 <bos> orbitz: STM is very easy to use.
12:44:50 <tieTYT> i haven't learned in yet
12:44:52 <tieTYT> IN
12:45:05 <Baughn> tieTYT: If it helps, try to think in terms of graph reduction instead of strict evaluation
12:45:06 <tieTYT> isn't there an easier example? :P
12:45:11 <twobitwork> tieTYT: its just part of the "let" syntax
12:45:14 <vixey> > let x = 7 in x + 1
12:45:15 <Baughn> tieTYT: let..in is just..
12:45:16 <lambdabot>  8
12:45:20 <Baughn> Yeah, that
12:45:30 <twobitwork> tieTYT: as in "let x = something in doSomething"
12:45:37 <Baughn> > let (*) = (+) in 2*3 -- Works for functions too, of course
12:45:38 <lambdabot>  5
12:45:45 <geezusfreeek> conal: i'm thinking of it as more of a metaphor. <*> on Events works like the List monad. <*> on Reactives works as though you have two parallel signals in time, and each operation happens at the same points in time on the two signals, which i guess i just envision simarly to zipWith, exchanging the idea of time with indices
12:46:10 <Baughn> twobitwork: Er, though that one doesn't use x
12:46:12 <tieTYT> can't we just remove that let?
12:46:17 <tieTYT> i don't really get it
12:46:21 <Baughn> tieTYT: Sadly, no.
12:46:25 <orbitz> bos: i'm reading teh blog on computationalthoughts, it looks concise althouhg i don't knwo what it's realy doing yet
12:46:26 <twobitwork> Baughn: yeah, I was just going to put "... with x"
12:46:26 <dejones> http://www.boallen.com/random-numbers.html -- anyone see this on reddit?  Interesting visual image of what PHP's rand() function produces.
12:46:27 <lambdabot> Title: Computer Random vs. True Random : See the difference in how random numbers are g ...
12:46:43 <tieTYT> ok so the in fibs executes fibs?
12:46:55 <Baughn> Returns the value of fibs, rather
12:46:58 <conal> geezusfreeek: oh, i see.  thx.
12:47:00 <tieTYT> ok
12:47:02 <dejones> I wonder if Haskell's random might be any better?
12:47:03 <tieTYT> then i think i can move on
12:47:07 <Baughn> Nothing particularily /executes/ anything, except functions in IO
12:47:17 <conal> geezusfreeek: so kind of like [] vs ZipList
12:47:18 <tieTYT> ok now i'm starting to get this
12:47:24 <bos> dejones: haskell's random is probably bad.
12:47:24 <geezusfreeek> conal: exactly
12:47:27 <vixey> dejones: very pretty
12:47:34 <tieTYT> can we take this in msg?
12:47:45 <tieTYT> just so i don't have to scroll up to see the function definition when i ask questions
12:47:56 <tieTYT> or lets go to #haskell-whatever
12:47:57 <Baughn> tieTYT: join #haskell-blah, instead
12:48:06 <dejones> bos, vixey: It would beat neat to see a visual image comparison of many languages rand() functions to see the differences.  :)
12:48:11 <dejones> * be neat, that is
12:49:33 <Philippa> Baughn: no, -blah is for off-topic...
12:49:38 <Philippa> -overflow would be better
12:50:12 <orbitz> dejones: neat way to visualzie, although I'm never quite sure what to make of these since I hope nobody consiers them powerful enough for anything but trivialitie sin teh first place
12:50:48 <dejones> orbitz: Yah, I sure hope they don't...  /dev/random is my friend in Linux.  :)
12:50:54 <vixey> what is === in PHP?
12:51:02 <orbitz> vixey: it's liek soem sort of super comparison
12:51:14 <orbitz> i think it takes type into account (or it doesn't take tpe into account?)
12:51:28 <orbitz> we haev a similar retarded on in erlang, =:=
12:51:56 <vixey> most Prolog has =:=
12:52:05 <pizza_> dejones: check out this (old) analysis of operating systems' TCP ISN number generators: http://lcamtuf.coredump.cx/newtcp/
12:52:07 <lambdabot> Title: Strange Attractors and TCP/IP Sequence Number Analysis - One Year Later
12:52:13 <sclv_> but is standard erlang or prolog == non-transitive?
12:52:19 <pizza_> it may be somewhat along the lines of what you mention
12:52:33 <mauke> @let a === b = cast a == Just b
12:52:34 <lambdabot> Defined.
12:52:53 <geezusfreeek> mauke: oh yuck!
12:52:53 <mauke> > ('x' === (), 'x' === 'y', 'x' === 'x')
12:52:53 <lambdabot>  (False,False,True)
12:52:59 <lilac> :t cast
12:53:00 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
12:53:05 <vixey> sclv: = is an equivalence relation in Prolog
12:53:05 <sclv_> :ty (===)
12:53:16 <sclv_> ?ty (===)
12:53:18 <lambdabot> forall a b. (Typeable a, Typeable b, Eq b) => a -> b -> Bool
12:53:27 <dejones> pizza_: thanks
12:53:33 <sclv_> vixey: and == is?
12:53:55 <orbitz> > cast 'y'
12:53:57 <lambdabot>  Nothing
12:54:06 <vixey> sclv: also
12:54:18 <orbitz> cast 'x' == Just 'b'
12:54:30 <orbitz> > cast 'x' == Just 'b'
12:54:32 <lambdabot>  False
12:54:56 <lilac> ~src cast
12:54:58 <dejones> I wish that the http://www.boallen.com/random-numbers.html would have posted the image generated in the Linux environment.  I'd like to see how /dev/random compared visually.
12:54:59 <lilac> @src cast
12:54:59 <lambdabot> Source not found. You untyped fool!
12:54:59 <lambdabot> Title: Computer Random vs. True Random : See the difference in how random numbers are g ...
12:55:17 <orbitz> dejones: shouldn't be too ahrd to write up
12:55:27 <tibbe> anyone have a shortest common substring for ByteStrings lying around?
12:55:32 <tibbe> @seen dons
12:55:32 <lambdabot> dons is in #haskell, #xmonad, #haskell-soc and #ghc. I last heard dons speak 1h 16m 42s ago.
12:55:34 <dejones> orbitz: Yah, true... just think he should have done it.  ;)
12:55:38 <tibbe> dons: ping
12:55:55 <dejones> orbitz: especially since he says in the post that he did generate it and it was a lot better!  :)
12:55:59 <orbitz> dejones: i wonder how pythons is, doesn't it use some whacked out algo that is suppose dto be good
12:56:07 <dejones> orbitz: no clue ;)
12:56:23 <lilac> orbitz: probably a Tim Peters Special :)
12:56:25 <yitz> orbitz: python uses mersenne twister
12:56:54 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mersenne-random if anyone wants it
12:56:56 <Philippa> I've seen worse...
12:56:58 <lambdabot> http://tinyurl.com/5vuy5g
12:57:08 <orbitz> yitz: is it good or no?
12:57:19 <Philippa> a friend of mine wrote Conway's Life as an 80x4 shell script, using the OS RNG to initiate it
12:57:32 <Philippa> random()%2 or equivalent
12:57:51 <Philippa> one version of solaris yielded a rather too regular result:
12:57:51 <yitz> orbitz: mt is pretty standard, well tested and well known.
12:57:56 <Philippa> 010101010101010101010101...
12:58:02 <vixey> haha
12:58:35 <pip> Why so many folks in here ?
12:58:43 <dejones> pizza_: http://lcamtuf.coredump.cx/newtcp/ --- They definitely have some cool images comparing the random number generators of the OSes.
12:58:44 <lambdabot> Title: Strange Attractors and TCP/IP Sequence Number Analysis - One Year Later
12:58:45 <augustss> why not?
12:58:48 <lilac> Philippa: that'll be the bottom bit of a fairly well-known linear congruent RNG
12:58:53 <dons> we all got rich with haskell, and now spend our days in the sun, chatting on irc, pip
12:58:57 <dejones> pizza_: Some of the OSes are truly sad!
12:59:08 <pip> dons, Really ?
12:59:09 <orbitz> dons: dont' forgetthe pretty women
12:59:17 <pip> :O
12:59:17 <dons> yes, we're also all pretty women.
12:59:20 <augustss> pip: almost rich
12:59:25 <sclv_> and hunky bearded guys, if yr. tastes swing that way.
12:59:41 <pip> what's the difference between rich and almost rich ?
12:59:42 <pizza_> dejones: i know, the results are quite interesting; and the visualization method is excellent
12:59:57 * pip wants to learn Haskell
13:00:02 <dmwit> pip: Not much!  A few dollars here, a few cents there.
13:00:25 <yitz> dmwit: they've got the dollars, we've got the sense.
13:00:25 <dejones> dons: yep, here are the women, we were discussing them yesterday as they come included with the purchase of Real-World Haskell book: http://a1.vox.com/6a00e398aeb836000400fad68807510005-pi
13:00:26 <augustss> pip: a factor of 10 difference
13:00:29 <pip> Do you use Haskell at work ?
13:00:36 <augustss> pip: I do
13:00:39 <dons> pip, yeah.
13:00:46 <pip> Wow~~~
13:00:47 <sclv_> a hundered thou here, a hundered thou there, pretty soon you're talking about real money.
13:00:49 <dejones> pizza_: Yes, the visualization is excellent.  :)
13:00:56 <pip> Nearly nobody use Lisp a work
13:01:04 <twobitwork> pip: I do, but not for my employer :P
13:01:06 <twobitwork> (shh)
13:01:12 <pip> hehe
13:01:20 <sclv_> for some values of nearly
13:01:28 <augustss> twobitwork: getting rich on your own, eh?
13:01:36 <twobitwork> augustss: I wish
13:01:38 <pejo> pip, the selection in here is somewhat skewed.
13:02:00 <pip> You guys might rich indeed, so relax
13:02:06 * Philippa is coding in haskell but not making money, for example...
13:02:12 <Philippa> ...but not exactly for 'typical' reasons
13:02:17 <pip> *relaxed
13:02:18 <augustss> pejo: yes, what do you expect from a haskell irc? :)
13:02:20 <twobitwork> Philippa: what reasons then?
13:02:43 <Philippa> twobitwork: it'd be nice for employment to be a practical thing for me at all, basically
13:02:46 <mauke> what's a good name for an alternative printf module?
13:02:54 <dons> Text.Printf.Mauke
13:02:56 <pip> pejo, what's meaning ?
13:03:04 <mauke> dons: seriously?
13:03:08 <augustss> mauke: sprintf
13:03:17 <mauke> augustss: not a valid module name
13:03:18 <Philippa> mauke: yeah. As in "mauke's printf"
13:03:35 <Philippa> cf the various Regex implementations
13:03:54 <augustss> or the spj&rjmh pretty printer
13:03:55 <orbitz> mauke: Format
13:04:03 <pejo> augustss, oh - I'm not complaining, just makign a note!
13:04:17 <dejones> pizza_: It's funny that they say, "Linux used a satfisfactory ISN generator ..." and still uses the same, so we don't have to re-evaluate them, haha.
13:04:55 <augustss> mauke: replacing printf, eh?
13:04:58 <pejo> pip, people who work with Haskell will come in here to a greater extent compared to those who work with Java.
13:05:01 <pizza_> dejones: see the original paper for more: http://lcamtuf.coredump.cx/oldtcp/
13:05:01 <lambdabot> Title: Strange Attractors and TCP/IP Sequence Number Analysis
13:05:07 <mauke> augustss: yeah
13:05:14 <dejones> pizza_: thanks.
13:05:15 <mauke> Text.Printf is unmaintained
13:05:21 <augustss> mauke: it's not
13:05:29 <mauke> since when?
13:05:41 <augustss> I fixed a number of problems recently
13:05:53 <dvekravy> hi, is any lambdabot's master online?
13:06:07 <dvekravy> is possible to join lambdabot to #haskell.cz?
13:06:12 <augustss> mauke: And I'd be happy to fix more if someone tells me about them
13:06:28 <pip> Haskell isn't standardized, why ?
13:06:31 <Arnar> @seen dons
13:06:31 <lambdabot> dons is in #haskell, #xmonad, #haskell-soc and #ghc. I last heard dons speak 3m 38s ago.
13:06:41 <Zao> pip: Haskell98 is quite authorative.
13:06:42 <augustss> pip: what counts as standardized?
13:06:51 <Arnar> dvekravy: ^^ dons is at least one of them
13:07:46 <dvekravy> hm, but it seems he's not listening right now..
13:07:48 <dvekravy> @localtime dons
13:07:50 <lambdabot> Local time for dons is Tue May 20 13:07:48 2008
13:07:56 <dvekravy> ah..
13:08:02 <mauke> augustss: http://hackage.haskell.org/trac/ghc/ticket/1548 ?
13:08:02 <lambdabot> Title: #1548 (printf bugs) - GHC - Trac
13:08:39 <Philippa> pip: there's work to standardise things since Haskell98, but it's complicated - not least because haskell has a higher proportion of genuinely-new features spread among its various implementations
13:08:52 <Philippa> it'll get finished though
13:09:07 <Philippa> (not that the addition of new features to eg GHC will suddenly stop)
13:09:17 <vixey> Philippa, Do you think you will release any of the CHR stuff you were doing?
13:09:32 <dejones> pizza_: It seems Cisco IOS and Netware, etc. listened to that report and patched their systems.  :)  They went from 90%+ to 0%
13:09:52 <pip> Cool
13:10:06 * pip is going to learn about Haskell
13:10:34 <Philippa> vixey: heh, way to spill the beans :-) Yeah, once I've actually got something interesting I intend to. I didn't get masses done at the time though, it's something to go back to - something SPJ said in a mail while missing my point's set me off on another useful track for now
13:10:36 <Botje> .. but the millionaire's island is already getting overcrowded!
13:10:58 <vixey> Philippa, oh, I'm sorry!
13:11:43 <Philippa> vixey: not a problem, if I were really trying to keep stuff dead sekrit then you wouldn't have known as much as you did :-) But I don't want to get too many people dead excited about things I may do - I'm pretty slow at getting stuff done
13:15:06 <Lemmih> Is it safe to run untrusted code in a chroot jail as an unprivileged user?
13:15:33 <Lemmih> (with CPU and memory limits enabled)
13:15:37 <Baughn> Lemmih: No
13:15:47 <Baughn> Lemmih: chroot *IS NOT A SECURITY MECHANISM*
13:16:07 <Lemmih> Is it reasonably safe then?
13:16:39 <Heffalump> it's fairly safe if you don't give people root within the chroot
13:16:54 <dons> a pure implementation of the mersenne random gen, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mersenne-random-pure64, just uploaded
13:16:55 <lambdabot> http://tinyurl.com/5jfqg7
13:16:56 <Heffalump> then so long as there isn't a vulnerability letting them escalate to root, it'll do what you expect
13:17:02 <dons> thanks to int-e this one almost matches the impure version
13:17:05 <Heffalump> if they are root inside the chroot, escaping is trivial
13:17:11 <dons> and several magnitudes faster than System.Random
13:17:32 <Heffalump> you'll have to make your own judgement about the likelihood of a local root hole though
13:17:48 <dmwit> dons: Several magnitudes? O_o
13:17:50 <dolio> Ooo, I can stop using unsafeIOToST.
13:17:59 <dons> dolio: try it out, anyway.
13:18:15 <dons> though i wonder, strict pairs might be useful here too, to doubly ensure we dont' get heap checks in the main loop
13:18:16 <ReinoDios> imagine boxes,    a guest box inside of a host box
13:18:18 <dons> hmm
13:18:19 <BMeph> dons: Do you have any documentation to go along with ghc-core? :)
13:18:20 <dolio> I actually never tried pure-64.
13:18:29 <Heffalump> dons: but it must be completely deterministic if it's pure?
13:18:41 <dons> Heffalump: it is, yes. given a seed.
13:18:47 <ReinoDios> chroot does for userland guest box, not complete OS guest box.
13:19:04 <dons> Heffalump: and it generates the same results given a seed as the impure one.
13:19:09 <dmwit> Heffalump: ...just like every other RNG I've ever used.
13:19:09 <Heffalump> ah, right. So you used to need impurity even to generate pseudo-random numbers fast?
13:19:12 <dons> you just get to see the previous states
13:19:21 <dons> right, it mutated a buffer
13:19:26 <dons> but now we can preserve the old stae
13:19:30 <Lemmih> Heffalump: Excellent, thanks.
13:19:33 <dons> so regaining purity
13:19:49 <dons> BMeph: not really. ghc-core --help
13:20:01 <Heffalump> so RWH says that DiffArrays are too slow to be usable. What needs doing to make them fast?
13:20:09 <ReinoDios> it's as a jail with possible escaping.
13:20:09 <BMeph> Hmm, oh well. Thanks, then.
13:20:34 <dolio> dons: Speaking of ghc-core, do you usually look at it with inlining enabled (when applicable)?
13:20:44 <dons> dolio: inlining enabled?
13:20:48 <dons> its always enabled :D
13:21:02 <mauke> can I tell haddock to document instances defined in my new module?
13:21:02 <dolio> Well, you could comment out INLINE pragmas.
13:21:25 <mauke> this module defines a new class and several instances for standard types, but they don't show up in the documentation
13:22:16 <BMeph> dons: Just curious - do you have an idea of what would be causing this response in ghc-core:
13:22:38 <BMeph> ghc-core: /tmp: openTempFile: does not exist (No such file or directory)
13:23:18 <mauke> I'd try strace
13:24:27 <dons> BMeph: hmm. full tmpdir?
13:26:51 <BMeph> dons: Better not be. Hmm, I just noticed, it's getting reset to 755 for some reason - I'll keep poking.
13:32:58 <Japsu> @index par
13:32:58 <lambdabot> GHC.Conc, Control.Parallel, Graphics.HGL.Utils, Graphics.HGL
13:38:32 <geezusfreeek> dejones: your wish that there had been an image representing Linux's /dev/random stuff is about to be answered
13:38:50 <dejones> geezusfreeek: thank you.  :)
13:38:55 <geezusfreeek> dejones: i just have to figure a way to build some entropy
13:39:00 <Trinithis> is every MonadPlus an Alternative?
13:39:02 <geezusfreeek> any suggestions anybody?
13:39:09 <dejones> geezusfreeek: move your mouse around a lot, browser the web!  ;)
13:39:29 <Bonus> haha oh man i'm doing this euler problem
13:39:32 <geezusfreeek> dejones: also, haskell's random gen looks pretty good to me
13:39:32 <Bonus> and by my estimation
13:39:35 <Bonus> it will take 2 hours to solve
13:39:38 <Bonus> welp, i got time
13:39:41 <dejones> geezusfreeek: cool.  I'm anxious to see.
13:39:41 <Bonus> :]
13:39:46 <geezusfreeek> i'll just make a short blog post
13:39:51 <dejones> geezusfreeek: nice.
13:39:55 <dejones> put it on reddit too?
13:40:05 <BMeph> Trinithis: "MonadPlus m => Alternative (WrappedMonad m)" suggests yes. :)
13:40:11 <geezusfreeek> dejones: i could do so
13:40:12 <Trinithis> k
13:40:36 <geezusfreeek> man, entropy takes a whil
13:40:37 <geezusfreeek> e
13:40:48 <BMeph> Especially taking into account: "Monad m => Applicative (WrappedMonad m)"
13:40:52 <edwardk> @pl \a -> Ran (\f -> fmap (runIdentity . f) a)
13:40:52 <lambdabot> Ran . flip (fmap . (runIdentity .))
13:41:28 <edwardk> @seen dolio
13:41:28 <lambdabot> dolio is in #haskell-blah and #haskell. I last heard dolio speak 20m 26s ago.
13:41:32 <Trinithis> BMeph: What's WrappedMonad's general usage?
13:41:42 <lilac> geezusfreeek: if we all flood you with privmsgs, that should generae some entropy, right?
13:41:45 <edwardk> Trinithis: to dumb down a monad to an applicative
13:41:56 <Trinithis> hah ok
13:42:17 <geezusfreeek> lilac: :P
13:42:18 <edwardk> Trinithis: that way if you don't have an instance of applicative for your monad you can use functions that expect an applicative, or in case your applicative instance differs operationally from that of the monad
13:43:04 <Trinithis> edwardk: so it's to avoid making a monad an instance of Applicative and use it in an Applicative setting anyway?
13:43:05 <dejones> geezusfreeek: http://www.number.ch/wiki/index.php/LinuxEntropySources
13:43:13 <BMeph> edwardk FTW. :)
13:43:17 <geezusfreeek> dejones: sweet thanks
13:43:20 <dejones> :)
13:43:33 <dejones> geezusfreeek: I told you move your mouse!  hehe
13:43:40 <edwardk> Trinithis: yeah
13:43:47 <Philippa> Trinithis: right, because that'd block off things
13:43:48 <geezusfreeek> dejones: yeah i knew the mouse would do it
13:43:56 <geezusfreeek> dejones: but it's still not very much :P
13:44:00 <edwardk> BMeph: heh, i didn't even see the 'BMeph:' on the beginning of his query ;)
13:44:12 <Arnar> what is the difference between MonadPlus and Monoid?
13:44:14 <dejones> dejones: maybe download some random files from the internet to get the IDE disks working... bittorrent?
13:44:24 <dejones> dejones: or play some music?
13:44:35 <Arnar> dejones: speaking to yourself?
13:44:36 <sclv_> I think cat on the keyboard is a preferred method of entropy generation.
13:44:40 <edwardk> Arnar: monoid is defined for some particular 'a', MonadPlus says that for every 'a' 'm a' acts like a monoid.
13:44:53 <Arnar> edwardk: ah, ok.. thanks
13:44:54 <BMeph> edwardk: Hey, as long as you have the knowledge, it's all good.
13:45:01 <dejones> geezusfreeek: above was meant for you, not for dejones.
13:45:03 <edwardk> arnar: the type system doesn't let you put 'forall' qualifiers in type classes so they are both needed.
13:45:10 <dejones> Arnar: umm, noooooo...  (hides)
13:45:10 <wolgo> Hi, I am new to functional programming and programming in general. Would Haskell be a good start for me?
13:45:13 <Arnar> I see..
13:45:19 <wolgo> I do not have much of a background in mathematics.
13:45:30 <BMeph> I did mean "FTW," not "WTF," by the way. ;)
13:45:35 <edwardk> wolgo: you don't need a math background. you kinda pick it up by osmosis around here ;)
13:45:37 <Trinithis> @faq Can haskell be  a good starting languiage?
13:45:37 <lambdabot> The answer is: Yes! Haskell can do that.
13:45:38 <geezusfreeek> dejones: well, i just realized i haven't turned off buffering, so i think i should do that first ;)
13:45:41 <wolgo> But I can figure stuff out (I have written some simple python scripts)
13:45:42 <edwardk> BMeph: kinda figure d=)
13:45:45 <dejones> wolgo: You don't have to have a background in mathematics to learn Haskell.
13:46:10 <Trinithis> Haskell teaches you the math as you learn it
13:46:14 <wolgo> Hmm ok
13:46:19 <wolgo> Well I want to learn
13:46:19 <dejones> wolgo: http://en.wikibooks.org/wiki/Haskell/YAHT
13:46:22 <ReinoDios> wolgo, buy Haskell books or download it from google
13:46:30 <Arnar> wolgo: Haskell is a fine language for learning functional programming. I fyou wan't some perspective, have a look at scheme to
13:46:34 <Arnar> too*
13:46:48 <Trinithis> is scheme dynamically typed?
13:46:49 <edwardk> wolgo: i personally recommend haskell to just about anyone looking to learn to program who wants a good solid language under them that helps them get stuff written right the first time =)
13:47:01 <wolgo> I already bought two books. One is The Haskell School of Expression and the other is The Craft of Functional programming
13:47:16 <wolgo> One uses ghc the other uses Hugs
13:47:28 <Arnar> Trinithis: yes..
13:47:33 <edwardk> wolgo: YAHT is a pretty decent start, another source is the book being written by a few of the folks around here, 'Real World Haskell'
13:47:33 <wolgo> It seems that ghci is the more used. Should I only use ghc?
13:47:39 <Arnar> Trinithis: quick googling shows there are static dialects though
13:47:49 <dejones> wolgo: I hear those are great books.  :)
13:47:52 <wolgo> edwardk: Oh ok.
13:47:52 <Trinithis> Arnar: ok.
13:47:53 <edwardk> ghc is the compiler, ghci is sort of a command line interface to the compiler that lets you try stuff out
13:48:00 <wolgo> Oh ok
13:48:07 <wolgo> I think I am going to learn Haskell then.
13:48:15 <dejones> wolgo: I used Haskell School of Expression some and YAHT and beta version of Real-World Haskell..  I am still learning, of course.  :)
13:48:33 <lilac> i'm trying to make parsec parsers composable, and i'm in serious need of help...
13:48:37 <wolgo> dejones: Do you have any code that is publicly available?
13:48:40 <edwardk> ghc: kinda like how you can try out python from the command line to interact with it, or you can use it to run a script.
13:48:44 <wolgo> I would like to look at some noob code
13:49:02 <Arnar> lilac: composable how?
13:49:05 <wolgo> Actually I can find that somewhere else
13:49:06 <lilac> i want a compose :: GenParser a () b -> GenParser b st c -> GenParser a st c
13:49:28 <wolgo> Ok so real world haskell and yaht
13:49:32 <dejones> wolgo: nope, sorry..  I started learning Haskell by implementing some of the library code by myself.  It helped to know how some of the basic worked in order to use them later.
13:49:34 <geezusfreeek> alright, now it's going without buffering...
13:49:48 <edwardk> wolgo: the main reason i stuck around here was because of the community. The folks here are probably the most helpful bunch of over-educated whackjobs you're likely to meet on the internet ;)
13:49:59 <dejones> wolgo: I think it is very helpful to look at the source code of the functions in the Haskell libraries.
13:50:27 <wolgo> dejones: oh ok
13:50:29 <Arnar> lilac: GenParser a () b returns a single value of type b -- GenParser b st c needs a list of tokens of type b
13:50:32 <Philippa> lilac: as in parse . lex? Just do it the long way
13:50:41 <lilac> hmm. actually, that's not quite right.
13:50:54 <lilac> Philippa: the long way requires multiple passes
13:50:57 <wolgo> Ok I guess I will get started then.
13:51:25 <wolgo> I considered scheme but I don't like the way it looks
13:51:30 <lilac> Philippa: hence it has a high space cost -- it needs to parse the whole input before it returns anything, because it needs to know whether the result is success or error
13:51:50 * edwardk watches as the Yoneda lemma finally clicks. Its the right Kan extension along the identity functor.
13:52:01 <dejones> wolgo: as edwardk said, #haskell is very helpful, so don't hesitate to ask for help... http://hpaste.org/ is very useful for posting your code for people in here to see / analyze.
13:52:12 <Trinithis> wolgo: hoogle is a good source
13:52:28 <trontonic> A beautiful quote from Wittgenstein that could be applicable to Haskell: "The limits of my language mean the limits of my world"
13:52:33 <lilac> Arnar: yeah, actually i'm not sure exactly what i want. GenParser a () [b] isn't right (at least not in the current implementation) since that's just as bad as doing it the long way
13:52:36 <edwardk> http://comonad.com/haskell/category-extras/src/Control/Functor/Yoneda.hs which then means that Yoneda works as a higher order functor, etc al for free.
13:52:38 <lambdabot> http://tinyurl.com/5aywzm
13:52:48 <geezusfreeek> edwardk: yay i totally get it too from that obvious explanation
13:52:54 <Arnar> lilac: what are a and b in your case (roughly speaking)?
13:53:05 <Philippa> lilac: your compose would end up with the same semantics, no?
13:53:30 <edwardk> geezusfreeek: a right kan extension is kind of a generalized ContT.
13:53:41 <geezusfreeek> edwardk: that actually sounds interesting
13:53:41 <Philippa> you can't do anything like 'run a parser' without finding out whether it succeeds or not
13:54:09 <lilac> Arnar: various things for different passes. (a,b) are: [(Char, Char), (Char, Token), (Token, Token), (Token, ParseTree)]
13:54:11 <Philippa> which reminds me, I still need to send ddarius that patch adding a 'lazy many' that both returns success straight away and doesn't build the whole list at once
13:54:25 <geezusfreeek> edwardk: i find category theory in general interesting really. i just haven't "gotten it" yet...
13:54:39 <edwardk> newtype Ran g h a = Ran { runRan :: forall b. (a -> g b) -> h b; then the Yoneda lemma is just instantiating that for Ran Identity
13:54:55 <lilac> Philippa: yes, but you don't need to do all of pass 1 before doing any of pass 2.
13:55:21 * geezusfreeek thinks about installing an entropy gathering daemon
13:55:27 <Arnar> lilac: hmm.. now (Token, ParseTree) makes sense.. but (Token, Token) (and the others)?.. sure it is not something like (Token,[Token]) ?
13:55:29 <edwardk> i'm using right and left kan extensions as my 'gateway' to understanding the deeper parts of category theory. since mac lane said 'all concepts are kan extensions' i figured its a decent approach.
13:55:47 <dons> ?bug
13:55:47 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
13:55:56 <edwardk> wolgo: i had the same reaction to scheme. haskell syntax LOOKS very clean. its a language i don't mind thinking in.
13:56:02 <lilac> Arnar: yes, you're right. it's (Token, [Token]) and (Char, [Char]). an example: C preprocessor: I have certain tokens which expand to multiple tokens. I want to compose this pass with my lexer and my parser.
13:56:35 <Arnar> lilac: ok.. in that case you should be able to compose them I guess
13:57:25 <dejones> geezusfreeek: how's the blog post coming?  ;)
13:57:26 <lilac> What I'm doing at the moment is to run my Token parser multiple times, generating an Either ParseError Token at each step, then from that form a ([ParseError], [Token]), and feed the token list to the next stage
13:57:51 <geezusfreeek> dejones: still working on this entropy!
13:57:56 <Arnar> lilac: ok..
13:58:01 <lilac> and repeat this for each level. but it's really messy.
13:58:10 <geezusfreeek> dejones: just set up an infinite loop to run some ide stuff...
13:58:36 <lilac> basically, i'm looking for a better way to get the same result.
13:58:43 <geezusfreeek> dejones: /dev/urandom was so fast! :P
13:58:53 <dons> man, i want more registers.
13:59:10 <lilac> dons: stuck on an x86?
13:59:13 <dons> no, amd64
13:59:34 <dons> but still. there's noticeable slow down if i need more than 4 values to return in registers.
13:59:38 <dejones> dons: more registers for what?
13:59:44 <dons> and these days my haskell code's doing a lot of that.
14:00:04 <lilac> dons: i'm imagining a bunch of intel engineers sitting around looking smug right now
14:00:09 <Arnar> lilac: I think you'd have to have a way of combining Either..
14:00:20 <Arnar> lilac: shortcutting if you get a Left in the same way Maybe shortcuts on Nothing
14:01:15 <dons> actually, hmm. division. maybe that's what's screwing things up
14:01:15 <lilac> Arnar: actually, I'm pretty happy for my parser to keep going (recovering by skipping input tokens etc) on an error, looking for further errors. and I have a collect :: [Either a b] -> ([a], [b])
14:01:16 <Arnar> @src Either (>>=)
14:01:16 <lambdabot> Left  l >>= _ = Left l
14:01:16 <lambdabot> Right r >>= k = k r
14:01:31 <Arnar> seems like it already does the right thing..
14:01:43 <Arnar> lilac: oh ok..
14:01:53 <Arnar> lilac: thought you wanted to stop if there was an error early in the chain
14:02:03 <lilac> Arnar: doesn't using that defeat the point? ie, i need to parse the input once in order to find whether the result is left or right, and i need to do that before i can start phase2 parsing
14:02:23 <lilac> Arnar: I'm looking for a solution which runs in constant space
14:02:26 <Arnar> lilac: I'm not 100% sure, but I guess the lazyness will take care of that
14:03:12 <Arnar> but I'm a noob still..
14:03:35 <lilac> well, it needs to check that the input will parse before it can decide whether to return Left or Right at the top level, and that's nearly as expensive as actually parsing
14:03:57 <Arnar> right..
14:04:12 <Leimy> > 2560x1600
14:04:13 <Arnar> but your GenParser Token () [Token] will do that anyways.. right?
14:04:15 <lambdabot>   Not in scope: `x1600'
14:04:22 <Leimy> oops!
14:04:27 <Arnar> > 2560 * 1600
14:04:27 <Leimy> > 2560 * 1600
14:04:29 <lambdabot>  4096000
14:04:29 <lambdabot>  4096000
14:04:39 <mauke> I can't remember my hackage password :/
14:04:41 <pip> Is haskell a turing completeness ?
14:04:42 <lilac> Arnar: I need to be clearer, i think. My GenParser Token () [Token] will be something like:
14:04:58 <vixey> pip: yes
14:04:58 <Arnar> pip: yes
14:05:13 <vixey> :D
14:05:18 <vixey> @quote fugue
14:05:18 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
14:05:28 <Arnar> vixey: make a whish :)
14:05:32 <vixey> hehe
14:05:40 <pip> Um.... what if it is not , will it be more powerful ?
14:05:52 <lilac> preprocessToken = do i <- token; case lookupMacro i of Just (Macro m) -> return m; Nothing -> return [i]
14:06:15 <Arnar> pip: hmm.. being Turing complete means it is as powerful as any algorithmic language
14:06:26 <lilac> then that will get run multiple times until we hit EOF, the results concat, and parsed
14:06:44 <Arnar> lilac: ok, so it is a simple rewrite that will never fail.. right?
14:07:11 <Arnar> pip: if it wasn't Turing complete, it would be much *less* powerful
14:07:14 <lilac> Arnar: sadly no. the actual rule is harder, involving paren matching etc. it can fail.
14:07:33 <lilac> Arnar: and I want failures propagated to the combined parser
14:07:56 <Arnar> lilac: meaning you want the combined parser to fail as soon as any parser in the chain fails?
14:08:04 <pip> Arnar, You mean it is as powerful as C
14:08:10 <Arnar> pip: yes..
14:08:17 <Arnar> pip: you can simulate C in Haskell and vice versa
14:08:27 <vixey> pip: "powerful" is a bad metric
14:08:30 <lilac> Arnar: well, what I *really* want is a stateful parser which accumulates a number of errors and attempts to carry on where possible ;-)
14:08:50 <Arnar> lilac: ahh.. I see! :)
14:08:54 <pip> vixey, Yes, so give me an OS written in haskell
14:08:59 <Arnar> lilac: well.. I guess you need something more sophisticated for that
14:09:02 <vixey> pip: The is a huge difference between "what class of functions can you computable" and "what class of programs can you implement"
14:09:14 <vixey> pip: exactly
14:09:22 <vixey> pip: (there is one by the way)
14:09:24 <Arnar> lilac: given the definition of (>>=) for either.. regular parsec failures won't give you that..
14:10:43 <lilac> Arnar: i think you're right. so, my current approach is messy, but it sounds like i can't do better with a totally parsec-based solution. thanks!
14:10:54 <Leimy> pip: there's actually more than one Haskell OS.
14:10:55 <lilac> Arnar: i feel a lot better about my current code now, at least ;-)
14:11:11 <Arnar> pip: when we talk about "power" in the context of turing machines, Turing completeness means that we can encode the workings of a Turing machine.. theoretically, you could encode an operating system as a Turing machine (or lambda calculus expression) - but these languages are not expressive enough so that we'd have a chance about comprehending that encoding
14:11:17 <Leimy> Kinetic and Haskell
14:11:36 <Leimy> http://intoverflow.wordpress.com/kinetic/
14:11:36 <lambdabot> Title: Kinetic  Integer Overflow
14:11:42 <dejones> I know this is waayyy off topic, but I thought maybe some of you might know more about Physics and Blackholes than I do...  http://www.misunderstooduniverse.com/France_Builds_Doomsday_Machine.htm -- This article is suggesting that the particle accelerator they are building in France will create black holes that will destroy the Earth?
14:11:44 <Leimy> http://programatica.cs.pdx.edu/House/
14:11:44 <lambdabot> Title: France builds Doomsday Machine - The Misunderstood Universe: Your Guide to the U ..., http://tinyurl.com/yp5r5j
14:11:44 <lambdabot> Title: House
14:11:58 <Arnar> lilac: :) In any case, if you want to handle errors cumulatively, you'd need to bypass parsec's error mechanism and implement your own (with some sort of recovery)
14:12:09 <pip> :O
14:12:28 <Arnar> dejones: don't know anything about this except movies have been made about that :)
14:13:05 <dejones> Arnar: Yah, I don't know enough physics to know whether or not it is just a "scare tactic" or possible..
14:13:06 <lilac> Arnar: yep. but with a stateful parser and only minimal modifications to parsec, i think that is possible.
14:13:07 <geezusfreeek> grr, still can't generate enough entropy
14:13:17 <Arnar> pip: in terms of "expressivenes" - which is very hard to measure - I'd guess that Haskell is even more expressive than C
14:13:47 <Leimy> You have to guess ?
14:13:47 <lilac> dejones: the majority opinion is that it's phenomenally unlikely for the LHC to create either a micro-black-hole or a strangelet
14:13:54 <Arnar> lilac: I'm sure it is.. be sure to show it to me when you're done :)
14:13:57 <geezusfreeek> > 512*512 -- number of chars i am generating because i was too lazy to write the code to extract more bools from each char
14:13:59 <lambdabot>  262144
14:14:12 <geezusfreeek> does that seem too high to be feasible to anybody?
14:14:19 <dejones> lilac: Thank you.  Can you explain why it is so unlikely?
14:14:26 * geezusfreeek has not done much with /dev/random before
14:14:46 <Peaker> hey, is there a doubly-directional map?
14:14:56 <pip> Arnar, Is Haskell hard to learn compared with C ?
14:15:15 <Arnar> pip: depends on your mindset.. it is surely different
14:15:19 <Trinithis> is there a way to allow overloaded declarations in GHC? aka fst for pairs and fst for triples?
14:15:28 <sclv_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bimap
14:15:31 <Arnar> pip: for me it was harder, yes - but much much more interesting
14:15:33 <sclv_> peaker ^^
14:15:38 <geezusfreeek> Trinithis: type classes
14:15:41 <dejones> pip: I think both languages have features that can be complicated, such as pointers in C and monads in Haskell.
14:15:57 <Peaker> sclv, thanks. I think it should be rather simple to build one on top of Map, if that's not good enough
14:16:03 <pip> I see
14:16:07 <Trinithis> geezus: ok
14:16:23 <sclv_> as i recall, it is built on top of map. but rather neatly.
14:16:32 <Peaker> sclv, that's a 1-to-1 mapping.. I need 1-to-many
14:16:33 <edwardk> @seen ddarius
14:16:34 <lambdabot> I saw ddarius leaving #haskell, #haskell-blah, #haskell-overflow and #haskell-soc 3h 52m 31s ago, and .
14:16:45 <Peaker> sclv, so you get a list if you lookup in the other direction
14:16:59 <Peaker> sclv, I guess I could build that, but for now I'll just do a naive search of the map
14:17:00 <Arnar> pip: the important thing to realize about programming langages is that they're not like natural languages.. each programming language is suited to particular types of problems, runtime settings etc.
14:17:09 <sclv_> ah so the other side is now many to one.
14:17:21 <pip> Arnar, I was astonished by the number of folks in here , more than other functional languages'
14:17:24 <Arnar> pip: I love Haskell, but if I were to write an operating system that was to be used for something more than an interesting excercise - I'd use C
14:17:26 <sclv_> yeah, i don't think there's a package for that...
14:17:35 <lilac> dejones: i believe one argument goes "cosmic rays hitting the earth do pretty much the same thing and they haven't created a major black hole"
14:17:37 <Arnar> pip: Haskell is pretty popular, yes - for a good reason
14:17:46 <dejones> lilac: this is hilarious post from Kiran on that page, "And lets face it...destroying the world by turning it into strange matter would be quite an impressive achievement."
14:18:01 <lilac> dejones: another goes "even if a black hole was created it would evaporate pretty darn quickly"
14:18:11 <Arnar> pip: I'm writing programs as part of my studies that I couldn't dream of writing in a language that didn't have lazyness, pattern matching, abstract data types etc.
14:18:21 <dejones> lilac: Yah, Kiran's comment said that it is expected that black holes would evaporate quickly.
14:18:25 <Arnar> pip: so.. different problems call for different languages
14:18:26 <Peaker> Arnar, what langauge does not have ADT's?
14:18:34 <vixey> Peaker: C
14:18:35 <Arnar> Peaker: assembly
14:18:43 <vixey> Arnar: what sort of things are you writing?
14:18:45 <Peaker> vixey, C has them if you want em :-)
14:18:45 <Philippa> pip: learning the language C is probably easier than learning all of the language Haskell. Learning to write good programs in Haskell is probably easier.
14:18:50 <lilac> Peaker: untyped lambda calculus
14:19:07 <Peaker> vixey, place just the right stuff in your .h file, hiding whatever you want to hide
14:19:10 <Arnar> pip: if you wan't to become a proficient programmer, my advice is learn as many languages as you can - and then pick two or three to become a master of
14:19:28 <Philippa> Peaker: A=Algebraic or A=Abstract?
14:19:32 <Philippa> (C doesn't have either per se)
14:19:34 <Peaker> Philippa, abstract
14:19:55 <dejones> lilac: So many of the comments on that article post are frustrating ridiculousness... I want an actual intelligent response.
14:19:55 <Arnar> vixey: currently I'm writing a) simulators for process algebra, including parsers and "state machines" to execute operational semantic rules -- and b) messing with transactional memory
14:20:16 <pip> Thanks
14:20:17 <dejones> lilac: Even the comments seem to suggest that it is just extremist propaganda...
14:20:17 <Peaker> Having an opaque forward-declared struct and a bunch of "methods" on that struct in an .h file passes all meaningful tests for ADT I believe
14:20:18 <Arnar> Peaker, Philippa: I was referring to algebraic data types
14:20:27 <pip> Haskerllers rock
14:20:48 <Leimy> Haskell is also a good choice for writing other languages when Haskell isn't the right answer :-)
14:20:48 <pip> *Haskellers
14:21:00 <Leimy> DSLs ftw!
14:21:05 <Peaker> dejones, if I am correct about what you're talking about - then the real answer I heard was that these reactions happen all the time so are not dangerous
14:21:30 <Arnar> pip: and when I say "as many languages" - I mean many _different_ languages. java and c# are not that different for example
14:21:43 <Philippa> Arnar: yeah, algebraic datatypes're wonderful if you've got an algebraic problem
14:21:46 <pip> I see
14:22:09 <Philippa> which AST manipulation is
14:24:46 <Arnar> Philippa: surprisingly many problems boil down to algebraic structures
14:24:46 <pip> Make sense Arnar : )
14:24:46 <Peaker> Interesting languages to know IMO: C, Haskell, Scheme, Python, Smalltalk
14:24:46 <Philippa> nested pattern-matching is a hell of a lot nicer than having to kludge simple pattern-matching via tags and a switch statement
14:24:46 <dejones> Peaker: http://www.misunderstooduniverse.com/France_Builds_Doomsday_Machine.htm -- I was talking about this post.
14:24:46 <lambdabot> Title: France builds Doomsday Machine - The Misunderstood Universe: Your Guide to the U ..., http://tinyurl.com/yp5r5j
14:24:46 <Philippa> Peaker: I'm not sure Python really belongs in that list on grounds of being 'interesting' the same way
14:24:46 <dejones> Peaker: I was hoping some Physics guru might be in here and could tell me that it was just ridiculousness.  ;)
14:24:46 <Leimy> pip: The languages I'm glad I've learned are Haskell, C, Erlang, Common Lisp, Scheme, and at least one assembly language :-)
14:24:46 <lilac> dejones: as i understand it, practically no-one apart from the people suing believe there's any credible risk. and the people suing are not nuclear physicists; they have an agenda of their own.
14:24:46 <Leimy> I suppose Python is in there too
14:24:46 <pip> Leimy, Um,you live functional very much
14:24:46 <pip> *like
14:24:46 <Leimy> I'm actually doing Erlang at work :-)
14:24:46 <dejones> pip: I also agree that C, Haskell are great languages to learn.  Lisp/Scheme also.  As for what I think of as more "scripting languages" I think Ruby and Python are useful to learn.
14:24:46 <Leimy> because it was an obvious choice for a small team with a short schedule on a concurrent management platform.
14:24:46 <lilac> pip: i found that Haskell, much more than lisp, was worth learning for the brain-expandy feeling when i finally started to get it.
14:24:46 <Peaker> Philippa, Python has some interesting features..   Novel syntax, generators, nice type system, good abstract protocols, etc
14:24:46 <Leimy> lilac: I found Scheme to be more mind expanding than Lisp :-)
14:24:46 <Arnar> pip: my list would be C, C++, Python (twice), JavaScript (there's more to it than you think), Scheme, Postscript (besides Haskell of course) -- I also really like cooperative processes like in stackless python, newsqeak, erlang
14:24:46 <dejones> lilac: I see. What agenda do they have?  ;)
14:24:46 <lilac> Leimy: call/cc, etc?
14:24:46 <Peaker> IMO Common Lisp is a mess
14:24:46 <pip> lilac, Wow~~ which book should I pick up first ?
14:24:48 <Leimy> Scheme is a good example of a smaller language that can compose much bigger stuff.
14:24:57 <Leimy> and complicated things with cool primitives
14:25:03 <vixey> How can you say that ..
14:25:12 <dejones> pip, lilac: I felt the same way about Haskell compared to Lisp.
14:25:16 <Arnar> dejones: shame on you for calling Python a scripting language :)
14:25:38 <Leimy> Yeah Python's Y combinator isn't all that bad :-)
14:25:40 <dejones> Arnar: haha... just being honest.  :P  Don't get me wrong, it is powerful!  I wrote a very simple compiler with Python.
14:25:46 <geezusfreeek> dang, i have to leave in fifteen minutes
14:25:53 <geezusfreeek> i hope i have gathered enough entropy by then
14:25:53 <pip> Well, I have been learning Lisp, found it a bit confusing
14:25:54 <dejones> geezusfreeek: blog post ready???
14:25:57 <dejones> lol
14:26:04 <Leimy> pip: what have you been using to learn lisp?
14:26:05 <pip> Easy to be wrong
14:26:14 <geezusfreeek> dejones: i had no idea it would take _this_ long!
14:26:17 <Arnar> dejones: I've written my biggest systems using Python, most in production..
14:26:25 <Leimy> pip: I very very highly recommend the book Practical Common Lisp.
14:26:30 <pip> Leimy, Books ?
14:26:42 <pip> Leimy, OK,that's it
14:26:43 <Leimy> pip: you can get it for free online, legally :-)
14:26:57 <Arnar> (subtext: man are we geeks or what?)
14:27:00 <dejones> geezusfreeek: you are really poor at generating entropy :P
14:27:15 <geezusfreeek> dejones: except in bed
14:27:29 <dejones> pip: are you trying to choose a language to learn as your first programming language?
14:27:55 <dejones> geezusfreeek: keep that entropy to yourself :P
14:27:55 <dejones> haha
14:28:08 <pip> Arnar, Python is influenced by Haskell
14:28:15 <Arnar> pip: and vice versa
14:28:17 <dejones> Arnar: we're in a programming language IRC chatroom, of course we are geeks.  ;)
14:28:25 <pip> Arnar, Oh
14:29:05 <lament> is python actually influenced by haskell?
14:29:13 <lament> aside from list comprehensions?
14:29:16 <Leimy> list comprehensions :-)
14:30:01 <dejones> pip: are you trying to choose a language to learn as your first programming language?
14:30:08 <pip> dejones, No, I have learned some before, I was reading a C book where I found lisp so I entered the world of functionals, and then of course I can't miss Haskell
14:30:15 <Arnar> lament: open source (or "open spec") languages that popular must seek inspiration from each other.. I'm not sure I could enumerate the ways though
14:30:19 <lilac> dejones: fyi, one of the two plaintiffs sued CERN over their previous particle accelerator (the RHIC). same concerns.
14:32:06 <Arnar> python may not have influenced the core haskell language much, but associated concepts such as cabal..
14:32:26 <lament> Arnar: python is under pretty tight control
14:32:38 <lament> Arnar: and i don't think guido cares about haskell much
14:32:58 <Arnar> lament: well.. while GvR has the final say in things, he's not the origin of all ideas
14:33:03 <Leimy> people tend to cherry-pick features of languages they like when making new ones.
14:34:06 <dejones> pip: I think that the simplest functional language to learn first is Scheme (of the Lisp family).  I am not a Scheme/Lisp expert, but I learned the basics, then moved onto Haskell, which I am still learning and interested in advanced concepts.
14:34:45 <Arnar> I'd second that.. Scheme shows you the thought-process of functional programming without the bells and whistles
14:34:56 <pip> dejones, I see, do you suggest if I can learn two at the same time ?
14:35:01 <Leimy> pip: Scheme can be "frustrating" in that it seems like you won't be doing anything practical right away.
14:35:08 <Leimy> but things like Scheme Shell make it a little easier :-)
14:35:33 <Arnar> pip: I'd use Scheme to learn about lists and list operations, how to use recursion instead of looping, the benefits of tail recursion
14:35:46 <dejones> pip: Yep, I think you can.  But, honestly, I would focus one at a time.  Basically, as soon as I got the concept of treating code and data interchangeably in Lisp, I moved on.  :)
14:35:53 <Arnar> pip: and the concepts of closures
14:35:53 <Mr_Awesome> you can do practical things with dr scheme
14:36:07 <vixey> I would suggest that Prolog is a good environment to learn about writing recursive programs by induction
14:36:08 <dejones> pip: But the fact that code and data are the same in Lisp/Scheme is mind expanding.
14:36:12 <Leimy> Mr_Awesome: yeah that's very true.
14:36:13 <Mr_Awesome> or some crazy form of plt scheme
14:36:21 <Arnar> pip: after fully groking those concepts.. I'd move to haskell and read a book or two (including Real World Haskell)
14:36:32 <Leimy> vixey: I've a good prolog book I found at a used book store in Redmond, WA for 8 bucks :-)
14:36:43 <vixey> Leimy: which one is it?
14:36:50 <pip> I see
14:36:53 <Leimy> Unfortunately I shelved it for later.
14:36:54 <vixey> Leimy: I'm re-reading Craft of Prolog just for fun
14:36:57 <Leimy> and have forgotten the name
14:36:58 <Leimy> :-)
14:37:05 <pip> functional guys really nice
14:37:29 <Arnar> speaking of prolog.. does anyone know about an implementation of a simple theorem prover in haskell and/or an interpreter for some kind of a logic language?
14:37:37 <wagle> i had the impression that with increasing R in R<n>RS, scheme programs were being separated from data
14:37:52 <wagle> s/R/n/
14:37:56 <geezusfreeek> Arnar: look at the logict package on hackage
14:38:01 <Arnar> geezusfreeek: thanks..
14:38:06 <Arnar> @hackage logict
14:38:06 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/logict
14:38:07 <vixey> LogicT is not a theorem prover
14:38:13 <geezusfreeek> Arnar: i think there is also a theorem prover called Igor hanging around somewhere
14:38:13 <Arnar> what is it?
14:38:17 <Leimy> pip: a cool website to read occasionally is Lambda the Ultimate
14:38:21 <wolgo> How different is hugs from ghc?
14:38:24 <Leimy> pip: http://lambda-the-ultimate.org
14:38:24 <lambdabot> Title: Lambda the Ultimate | Programming Languages Weblog
14:38:28 <geezusfreeek> vixey: no, but he asked an either/or question :P
14:38:38 <mar77a> how would i go around using something like...arrays in haskell
14:38:39 <Arnar> @where Igor
14:38:39 <lambdabot> I know nothing about igor.
14:38:44 <mar77a> actually, maps
14:38:46 <lilac> Arnar: lambdabot's @djinn is a theorem prover, if you squint
14:38:52 <geezusfreeek> Arnar: it's just a library though, not a whole language
14:39:01 <vixey> Arnar: abstracting fair backtracking search as a monad transformer, and various implementations of it
14:39:03 <mar77a> or any sort of associative container
14:39:12 <vixey> ?where Ivor
14:39:12 <lambdabot> I know nothing about ivor.
14:39:21 <Arnar> vixey: ok, that sounds useful to study anyways
14:39:22 <geezusfreeek> oh, i think ivor was it, right
14:39:24 <wagle> ?where iavor
14:39:25 <lambdabot> I know nothing about iavor.
14:39:30 <wolgo> let f x = x^2 in map f [1,2,3]
14:39:32 <vixey> ?where + Ivor http://www.dcs.st-and.ac.uk/~eb/ivor.php
14:39:33 <lambdabot> I know nothing about +.
14:39:35 <vixey> ?where+ Ivor http://www.dcs.st-and.ac.uk/~eb/ivor.php
14:39:35 <lambdabot> It is forever etched in my memory.
14:39:40 <geezusfreeek> yeah ivor is a proof engine
14:39:43 <wolgo> Kamina shows me that.
14:39:45 <pip> Leimy,thanks
14:39:51 <wolgo> showed
14:39:53 <wagle> oh
14:40:00 <Arnar> mar77a: do you mean map (apply a function to every element of a list) or Map (an associative datastructure, like a hashtable)?
14:40:08 <mar77a> Map :)
14:40:17 <Leimy> pip: no problem... this was very strange new territory for me a few years back.. Functional Programming may feel like you're waking up from a bad dream, but it can be really confusing too :-)
14:40:40 <vixey> Arnar: I'd like to see more logic languages implemented in terms of LogicT though
14:40:40 <lilac> mar77a: http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
14:40:41 <lambdabot> http://tinyurl.com/2mpwee
14:40:49 <Leimy> pip: especially if you cut your teeth on something like I did... TI-99/4a BASICC
14:41:00 <wolgo> Will my commands in ghci be interchangeable with hugs? What about source code files?
14:41:02 <vixey> Arnar: I didn't have much luck trying to mix typed logical variables in
14:41:10 <wolgo> Will they be compiled and run the same?
14:41:46 <Arnar> mar77a: the important difference, if you come from the imperative world, is that you don't "update" a map.. updating a map conceptually means "using this map as a starting point, make these changes and give me the result"
14:41:54 <pip> Leimy, hehe
14:41:54 <Arnar> vixey: ok..
14:41:57 <Arnar> vixey: do you know GDL?
14:42:00 <Saizan> wolgo: yes, if you stick to the haskell98 standard
14:42:18 <vixey> Arnar: GNU Data Language? no
14:42:30 <Arnar> vixey: no, sorry.. Game Description Language
14:42:32 <wolgo> Saizan ok thanks :) I am learning and I have two books. One uses hugs, the other uses ghci
14:42:35 <wolgo> and ghci
14:42:37 <mar77a> ouch i'm having problems reading the docs
14:42:44 <mar77a> might be a bit too soon to use this
14:42:46 <vixey> Arnar: Heard of it before, never used it
14:42:50 <Arnar> vixey: used in generic game playing to represent the rules of perfect-information games
14:43:03 <Arnar> vixey: ok.. it is basically a first-order logic language with some restrictions on recursion etc.
14:43:08 <Saizan> wolgo: the user interface at the repl is a bit different
14:43:22 <dejones> geezusfreeek: did you get the blog post done?  or did you have to leave?
14:43:41 <geezusfreeek> dejones: i'm posting my half finished stuff
14:43:48 <geezusfreeek> dejones: still not enough entropy for /dev/random
14:43:54 <dejones> geezusfreeek: cool, cool.  ahh...  thanks for trying.  :)
14:43:58 <Arnar> vixey: people are using generic prolog theorem provers to generate possible moves from a game state - I was wondering if Haskell could be a good tool to write a simpler/more specialized theorem prover for it
14:44:13 <Arnar> vixey: the goal being improved performance
14:44:13 <geezusfreeek> dejones: http://geekrant.wordpress.com/2008/05/20/more-computer-random-vs-true-random/
14:44:14 <lambdabot> Title: More Computer Random vs. True Random  Geek Rant, http://tinyurl.com/5hba58
14:44:30 <geezusfreeek> dejones: if you are wanting to put it on reddit, it would appreciate waiting until i get the last image up
14:45:05 <Arnar> mar77a: check out http://book.realworldhaskell.org/beta/data.html
14:45:06 <lambdabot> Title: Chapter 14. Data Structures
14:45:07 <dejones> geezusfreeek: sure, I won't post it on reddit til you're ready... or you can post it when you are ready.  :)
14:45:23 <geezusfreeek> dejones: i really don't care either way, i just think it'd be nicer that way
14:45:24 <dejones> geezusfreeek: you said "somebody had linked..." that was me!  :P
14:45:35 <geezusfreeek> dejones: should i say "dejones"?
14:45:36 <dejones> geezusfreeek: I understand.  You can just post it when you are ready.
14:45:43 <dejones> geezusfreeek: hehe, if you want.. it really doesn't matter :P
14:45:45 <vixey> Arnar: I'd like to see any results you get in coding this :)
14:46:08 <vixey> Arnar: this kind of work often spawns interesting subprojects
14:46:09 <dejones> geezusfreeek: you can say dejones and link to http://claimid.com/donniejones18
14:46:10 <lambdabot> Title: claimID.com/donniejones18 - Manage your online identity
14:46:12 <dejones> geezusfreeek: if you want
14:46:20 <geezusfreeek> dejones: i'll do that
14:46:24 <dejones> cool :)
14:46:30 <Arnar> vixey: excellent, I'll try to remember. I won't find time for this myself anytime soon though
14:46:31 <Sadache> hello all
14:46:37 <vixey> Hi Sadache
14:47:21 <dejones> geezusfreeek: the images look just as good as random.org  :)
14:47:23 <Sadache> i have a problem i am trying to solve in haskell, it is not much about haskell syntax as much as finding an effecient way to do it
14:47:48 <geezusfreeek> dejones: apparently, at least
14:47:48 <Arnar> dejones, geezusfreeek: is either of you boallen.com ?
14:47:49 <vixey> Sadache: What problem is it?
14:47:56 <geezusfreeek> Arnar: not i
14:48:10 <dejones> Arnar: not me
14:48:12 <bos> @seen dons
14:48:13 <lambdabot> dons is in #haskell, #xmonad, #haskell-soc and #ghc. I last heard dons speak 46m 58s ago.
14:48:16 <geezusfreeek> dejones: This account is hidden or does not exist. at that url you gave me
14:48:27 <Arnar> geezusfreeek: ok.. just found it weird that I was reading www.boallen.com/random-numbers.html just before coming here and then hearing your conversation
14:48:57 <geezusfreeek> Arnar: our conversation is actually about that article
14:49:11 <dejones> geezusfreeek: retry it
14:49:18 <Arnar> geezusfreeek: ah.. then I feel better - thought I was in the twilight zone
14:49:20 <dejones> geezusfreeek: I had to set it as "public"
14:49:25 <geezusfreeek> dejones: ah
14:49:29 <Sadache> I have a hierarchy of n level, and i have some information for the members of this hierarchy, however the information I have it as several lists, a list for each level in the hierarchy
14:49:32 <dejones> geezusfreeek: let me know if it did not work
14:49:32 <geezusfreeek> dejones: okay it works
14:49:39 <dejones> geezusfreeek: ty
14:49:53 <Sadache> i want to reconstruct the hierarchy with new types that include the information
14:50:07 <Arnar> Sadache: can you give an example of the lists?
14:50:12 <Sadache> I am not sure i was clear enough
14:50:20 <Sadache> ok
14:50:40 <vixey> Sadache: Exactly what do you want to decscribe with types ?
14:50:42 <Arnar> Sadache: http://hpaste.org if it is long
14:50:43 <wolgo> How would I say this in english: let squares = [ x^2 | x <- numbers] where numbers is a list [1,2,3,4]
14:51:01 <dons> bos?
14:51:11 <vixey> wolgo: collect every x^2, where x is in the list numbers
14:51:22 <Sadache> for example i have several levels, regions, zones,cities
14:51:29 <Arnar> wolgo: "let squared be the list of the numbers 1-4 squared"
14:51:46 <Arnar> Sadache: ok
14:51:51 <Sadache> and i have a constructed hierarchy of these levels
14:52:02 <bos> dons: i need to build a bloom filter.
14:52:12 <bos> dons: so i need a nice vector of unboxed integers.
14:52:18 <wolgo> good!
14:52:18 <dons> ah
14:52:30 <bos> dons: i'm torn between the known (STUArray) and the unknown (UVector)
14:52:36 <wolgo> I am being influenced by the effect of novelty.
14:52:37 <Sadache> then i have 3 lists of information, like population, and other statistics data, one list per level
14:52:43 <dons> bos, who's the audience?
14:52:44 <bos> bloom filters are destructive in nature.
14:52:45 <wolgo> I am not going to express how excited I am by this.
14:52:56 <dons> ah, then STUArray and uvector are identical
14:52:58 <Sadache> and i want to reconstruct the hierarchy adding the information
14:52:59 <bos> dons: me initially, hackage eventually.
14:53:02 <dons> they have the same destructive interface.
14:53:13 <dons> uvectors have a pure layer on top for transforms
14:53:19 <bos> i see.
14:53:23 <geezusfreeek> alright, going home now
14:53:32 <dons> but if you need mutation, you drop into ST, and use get/set/fill
14:53:36 <dons> much as for STUArray
14:53:38 <bos> it would be nice to provide a pure bloom filter interface that gets turned into destructive underneath.
14:53:49 <Arnar> Sadache: not exactly sure what you mean by "one list per level" -- say there is a country "UK", and regions "Scotland" and "Wales"
14:54:14 <dons> so if you had a sequence of map/filter/ etc , then uvector streams those together, using mutation underneath. or, you drop into ST and freeze them
14:54:21 <Arnar> Sadache: and some cities in both.. is the information for the cities all in one list, or one for Scotland and one for Wales?
14:54:21 <mar77a> Prelude> import qualified Data.Map as Map
14:54:21 <mar77a> <interactive>:1:0: parse error on input `import'
14:54:25 <mar77a> what's wrong with that
14:54:33 <Arnar> mar77a: import doesn't work in ghci
14:54:38 <dons> bos, it sounds like a nice test case
14:54:40 <Arnar> mar77a: use :load Data.Map
14:54:42 <MyCatVerbs> mar77a: use :m Data.Map instead
14:54:50 <Arnar> mar77a: sorry.. what MyCatVerbs said
14:54:55 <Arnar> mar77a: mine was wrong
14:54:55 <bos> dons: i'll try doing it pure with uvector, then, and we'll see what happens
14:54:55 <Sadache> the information for all the cities are in one list, all countries in another list and so on
14:55:02 <mar77a> i think i'm going to have to use files
14:55:04 <mar77a> er, modules
14:55:14 <dons> bos, sure. you have the url?
14:55:20 <bos> i can find it.
14:55:22 <Arnar> Sadache: ok.. and how do you associate each list item with a city, for example?
14:55:29 <dons> code.haskell.org/~dons/code/uvector
14:55:44 <dons> usual alpha warnings apply, though its getting pretty solid.
14:56:01 <Sadache> a new type called TerritoryPerformanceContainer
14:57:03 <Sadache> it take the name of the (city, country, ...) and takes a list of the same type as its children
14:57:47 <Arnar> Sadache: no, I mean the list you have already.. say the one for the "cities" level.. how do you know to which city an item in that list belongs?
14:58:22 <Sadache> the item has the name of the city
14:59:02 <Arnar> Sadache: ok.. so you'd need a function that traverses a tree, and for each item - depending on its level - chooses a list and does a lookup on the name
14:59:21 <Sadache> so i need a lookup right?
14:59:25 <mar77a> http://hpaste.org/7773#a0 help!
14:59:40 <Arnar> Sadache: at least.. yes
14:59:41 <mar77a> sorry if i'm annoying, for some reason i really want to learn haskell despite how hard it might seem for my poor brain
15:00:44 <Sadache> Arnar: I know that it is not obvious to get into the context, but can i share with you more of the context to be sure that i didnt miss something?
15:00:53 <dejones> mar77a: Don't give up.  :)
15:01:30 <dejones> mar77a: I think learning Haskell is quite enlightening.  I was mostly a C programmer before Haskell.
15:01:45 <mar77a> it's not the first time i pick it up (again)
15:01:50 <mar77a> this must be the 7th :(
15:01:53 <Arnar> Sadache: I think I understand..
15:01:53 <tchakkazulu> mar77a: putStrLn wants a string, but Map.keys returns a list of the keys, which is in this case a list of Strings.
15:01:56 <int-e> mar77a: did you try  print  instead of  putStrLn?  The mistake is that putStrLn wants a string (a list of characters) but you're giving it a list of strings.
15:02:03 <Arnar> Sadache: but if you could paste what you have.. I could have a look
15:02:28 <mar77a> what does print expect?
15:02:40 <Arnar> @type print
15:02:41 <dejones> mar77a: I find it very useful to use :type function_name in ghci
15:02:46 <lambdabot> forall a. (Show a) => a -> IO ()
15:02:55 <mar77a> mk
15:02:57 <Arnar> mar77a: print takes anything that is "showable"..
15:02:57 <dejones> mar77a: I do that quite often so I can understand what the compiler expects for each function.
15:03:03 <Arnar> @instances Show
15:03:04 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
15:03:15 <int-e> mar77a: print works with all types that provide a 'Show' instance, which is basically a means of converting the value to a string representation.
15:03:21 <mar77a> well
15:03:24 <Arnar> this says that if a is showable, [a] is showable.. and strings are showable
15:03:26 <mar77a> at least haskell and c++ have something in common
15:03:34 <mar77a> cryptic error messages from the std lib
15:03:44 <int-e> mar77a: it'll work on many things. a notable exception is functions.
15:03:47 <tchakkazulu> mar77a: About anything is "Showable", except for functions, IO actions, and some other stuff.
15:03:54 <mar77a> yeah i got it know
15:04:07 <mar77a> thanks
15:04:12 <int-e> mar77a: haskell's cryptic messages are shorter. They're also easier to get used to, in my opinion.
15:04:29 <tchakkazulu> mar77a: And most of "some other stuff" is often some sort of function in disguise ;)
15:04:45 <mar77a> char_traits<<constructor>>->>> FROM IO() double error <- check exception raised on protocol violation
15:05:06 <Arnar> woops
15:05:57 <dejones> mar77a: putStrLn (show (Data.Map.keys ages))
15:06:01 <dons> int-e: i uploaded the mersenne-pure package with your changes
15:06:03 <dons> (finally!)
15:06:05 <mar77a> ah
15:06:07 <tchakkazulu> mar77a: In the error, the "expected type" is what it wants, the "inferred type" is what you give it.
15:06:18 <mar77a> mmm
15:06:21 <tchakkazulu> mar77a: That's an important realisation for reading GHC type error messages.
15:06:23 <mar77a>  map putStrLn (Map.keys ages)
15:06:46 <wolgo> This is invalid because it is mixed: [[1,2],3,[4,5]], but [1,2],[3],[4,5]:[] would make it work no?
15:07:02 <dejones> mar77a: add the "show" for the list, as I pasted above.
15:07:11 <wolgo> oops
15:07:16 <wolgo> , should be :
15:07:27 <magthe> @ [a] -> Int -> Maybe a
15:07:52 <dejones> mar77a: http://hpaste.org/7773#a1
15:07:57 <int-e> dons: I saw that. I'm half tempted to make you upload another version ...
15:08:15 <mar77a> what's the $, dejones ?
15:08:28 <dejones> mar77a: you can use $ to replace ()'s
15:08:34 <magthe> @hoogle [a] -> Int -> Maybe a
15:08:34 <lambdabot> No matches, try a more general search
15:08:42 <dejones> mar77a: syntactic sugar, it's easier to read the $ instead of a bunch of ()'s
15:08:46 <magthe> @hoogle Int -> [a] -> Maybe a
15:08:46 <lambdabot> No matches, try a more general search
15:09:08 <mar77a> what
15:09:10 <mar77a> how?
15:09:20 <tchakkazulu> mar77a: 'show $ Map.keys ages' is the same as 'show (Map .keys ages)'
15:09:28 <Arnar> mar77a: actually.. $ is not just syntactic sugar - it is a function that says "take the function on the left and apply it to the argument on the right"
15:09:36 <tchakkazulu> mar77a: If you ignore the space after Map, that was a typo.
15:09:36 <magthe> is there a version of !! (indexing a list) that returns a Maybe a?
15:09:42 <dejones> gotta go to the gym, cya everyone.
15:09:49 <dejones> Arnar: thank you for the clarification.  :)
15:09:50 <mar77a> kind of like the opposite of (show . Map.keys) ages ?
15:09:57 <mar77a> well not the opposite but you get it
15:10:07 <mar77a> like reverse currying or something
15:10:10 <magthe> or do I have to go down the route of catching the exception that's thrown when I ask for an index that doesn't exist?
15:10:29 <tchakkazulu> mar77a: f $ x is defined as f x, but with low precedence.
15:10:39 <tchakkazulu> mar77a: (show . Map.keys) ages would work as well.
15:10:47 <ndm> magthe: if you use the Safe library, its in there as 'atMay'
15:10:47 <mar77a> smooth
15:10:58 <mar77a> anyways i'm trying a different method now
15:11:03 <mar77a> map putStrLn (show (Map.keys ages))
15:11:06 <dejones> mar77a: http://hpaste.org/7773#a2
15:11:08 <dejones> gotta go
15:11:08 <dejones> cya
15:11:10 <ndm> magthe: and Hoogle already will permute the argument order automatically
15:11:11 <mar77a> later
15:11:12 <mar77a> thanks
15:11:14 <dejones> np
15:11:28 <tchakkazulu> mar77a: Also: show $ Map.keys $ ages, show . Map.keys $ ages ;)
15:11:51 <mar77a> heh
15:11:55 <tchakkazulu> mar77a: Is all the same thing :)
15:12:08 <tchakkazulu> mar77a: Ah, with the map. There's a tricky part there.
15:12:10 <Botje> putStrLn . show is generally called print
15:12:15 <ndm> magthe: http://hackage.haskell.org/packages/archive/Safe/0.1/doc/html/Safe.html#v%3AatMay
15:12:17 <lambdabot> http://tinyurl.com/5fo6pd
15:12:25 <mar77a> what's the trick?
15:12:28 <mar77a> is my reasoning faulty
15:12:29 <Peaker> why is there no maybe equivalent of Map.(!)
15:12:34 <tchakkazulu> mar77a: Because map putStrLn (show (Map.keys ages)) is a list of IO actions
15:12:35 <Sadache> calculatePerformanceFor [City] (City -> String) -> [PerformanceResult]
15:12:55 <dibblego> tieTYT, I am now :)
15:12:58 <ndm> tchakkazulu: i'm still not convinced that the all $ one isn't clearer
15:13:03 <magthe> ndm: thanks, didn't know hoogle would do that
15:13:04 <tchakkazulu> :type map putStrLn (show ["One","Two","Three"])
15:13:04 <Sadache> how can i paste something?
15:13:07 <Botje> mar77a: mapM_ print $ Map.keys ages
15:13:10 <tchakkazulu> :t map putStrLn (show ["One","Two","Three"])
15:13:15 <Arnar> Sadache:
15:13:16 <Peaker> do I have to explicitly wrap member/(!) to get a Maybe result on a lookup?
15:13:17 <Arnar> @paste
15:13:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:13:20 <tchakkazulu> @type map putStrLn (show ["One","Two","Three"])
15:13:21 <lambdabot>     Couldn't match expected type `String' against inferred type `Char'
15:13:21 <lambdabot>       Expected type: [String]
15:13:21 <lambdabot>       Inferred type: String
15:13:23 <lambdabot>     Couldn't match expected type `String' against inferred type `Char'
15:13:25 <lambdabot>       Expected type: [String]
15:13:27 <lambdabot>       Inferred type: String
15:13:28 <dibblego> tchakkazulu, fmap
15:13:43 <dibblego> oh wait, lambdabot's map probably is fmap
15:14:03 <dibblego> @type map
15:14:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:14:08 <tieTYT> sup dibblego
15:14:13 <Arnar> @type Prelude.map
15:14:13 <dibblego> @type map putStrLn
15:14:15 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
15:14:17 <lambdabot> forall (f :: * -> *). (Functor f) => f String -> f (IO ())
15:14:23 <dibblego> hello tieTYT
15:14:25 <tchakkazulu> dibblego: Yeah, map == fmap == (.), according to lambdabot.
15:14:52 <tieTYT> can i msg you?
15:14:57 <dibblego> tieTYT, sure
15:15:16 <mar77a> so, what's the catch, in english?
15:15:28 <tchakkazulu> mar77a: It's a cool idea to map the 'putStrLn' function over the list of strings.
15:15:38 <tchakkazulu> mar77a: However, you'll end up with a list of IO action.
15:15:41 <Arnar> mar77a: well.. putStrLn "somestring" produces an IO action that prints the string
15:15:55 <Arnar> mar77a: using map will give you [IO ()] -- a list of IO actions
15:16:05 <mar77a> isn't that what main = do expects?
15:16:12 <Peaker> @hoogle Map k a -> k -> Maybe a
15:16:13 <lambdabot> No matches, try a more general search
15:16:14 <Bonus> it expects IO ()
15:16:15 <dibblego> tchakkazulu, you prolly want mapM_
15:16:16 <Peaker> :-(
15:16:19 <Arnar> mar77a: no.. main = do expects IO somehting
15:16:19 <dibblego> ?type mapM_
15:16:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
15:16:25 <Bonus> IO something yase
15:16:27 <dibblego> ?type mapM_ putStrLn
15:16:29 <lambdabot> [String] -> IO ()
15:16:30 <Arnar> mar77a: that's where mapM and mapM_ come in handy
15:16:35 <mar77a> and those are?
15:16:36 <tchakkazulu> dibblego: Yeah, I know. mapM_, or sequence_ . map, which are the same.
15:16:40 <Sadache> Arnar: http://hpaste.org/7774
15:16:53 <dons> int-e: thanks
15:16:54 <ndm> rather than mapM_ putStrLn, why not putStr . lines
15:16:57 <Arnar> mar77a: mapM will do the same as map, but it will combine the IO actions into one.. so you'll get IO [x] instead of [IO x]
15:17:01 <ndm> that way you are doing a lot more pure computation
15:17:10 <dons> and O(n) less handle locks too
15:17:12 <mar77a> ah that's great
15:17:12 <ndm> less scary (and evil) monads
15:17:21 <ndm> and possibly more fusion
15:17:23 <mar77a> what about mapM_
15:17:32 <mar77a> sorry, ndm , "lines"?
15:17:33 <Arnar> mar77a: mapM_ will combine the actions -- but just give you IO ()  -- which is what you want here as you don't care about the return value.. you just want to perform the actions
15:17:35 <Sadache> an example of what i want to do, i want to structure results as a hierarchy, the levels order is the selectors order
15:17:39 <dons> ndm, hmm, mapM_ is a foldr, so that'll fuse, while lines won't.
15:17:40 <dons> ah well
15:17:41 <ndm> mar77a: i meant unlines
15:17:44 <Arnar> @type Prelude.map
15:17:46 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
15:17:46 <Arnar> @type mapM
15:17:49 <Arnar> @type mapM_
15:17:49 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:17:50 <mar77a> what's unlines?
15:17:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
15:17:54 <mar77a> so much to learn :<
15:17:57 <ndm> dons: then upgrade your compiler :) - Streams can do unlines surely?
15:17:59 <dons> ?src sequence_
15:17:59 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
15:18:00 <Arnar> mar77a: the opposite of lines..
15:18:08 <Arnar> > unlines ["one","two","three]
15:18:08 <lambdabot>  Improperly terminated string at ""thre..." (column 22)
15:18:10 <tchakkazulu> mar77a: 'unlines' takes a list of strings and pasts them together with newlines after everything.
15:18:10 <dons> ndm, that's true. so if by 'maybe' you meant, with streams, :)
15:18:10 <ndm> > unlines ["hello","people"]
15:18:14 <Arnar> > unlines ["one","two","three"]
15:18:15 <Sadache> Arnar: If you dont have time. it is not problem :)
15:18:17 <dibblego> *almost* the opposite (inverse) of lines
15:18:20 <dons> its one of the more complicated streams
15:18:21 <lambdabot>  "hello\npeople\n"
15:18:21 <lambdabot>  "one\ntwo\nthree\n"
15:18:33 <mar77a> ah that's nice
15:18:33 <Arnar> Sadache: actually.. I need to run soon - hopefully someone will pick it up
15:18:37 <ndm> dons: streams or supercompilation, supercompilation gives it for free, with an ordinary recursive version
15:18:48 <dons> i've yet to see the paper :)
15:18:52 <dibblego> @check lines . unlines == id
15:18:53 <Sadache> nevermind, thanks for your help
15:18:54 <ndm> (with the obvious disclaimer that supercompilation is decidedly not "for free")
15:18:57 <tchakkazulu> mar77a: lines does the opposite, splitting a string up into lines
15:18:58 <mar77a> what does line use as the tokenizer?
15:19:05 <lambdabot>        add an instance declaration for (Eq ([String] -> [String]))     In the...
15:19:05 <mar77a> yeah i was just testing in the interpreter
15:19:11 <tchakkazulu> > lines "Hello\nPeople\n"
15:19:13 <lambdabot>  ["Hello","People"]
15:19:19 <ndm> dons: http://www-users.cs.york.ac.uk/~ndm/supero/ - the draft one
15:19:20 <lambdabot> Title: Neil Mitchell - Supero
15:19:30 <mar77a> i did the exact same thing tchakkazulu :D
15:19:33 <ndm> which has been accepted and will be appearing in LNCS shortly
15:19:35 <ndm> (i should update the website)
15:19:37 <mar77a> > lines "hello\r\npeople"
15:19:37 <dons> http://hpaste.org/7775 fusible unlines
15:19:39 <lambdabot>  ["hello\r","people"]
15:19:43 <dons> ndm, oh, where'd you get it in?
15:19:51 <ndm> dons: post proceedings of IFL
15:19:55 <dons> good work!
15:20:03 <ndm> dons: it also won the best paper award :)
15:20:04 <ReinoDios> did exist supercompilation in Russian
15:20:22 <ndm> ReinoDios: it is the Russian born supercompilation, yes
15:21:00 <tchakkazulu> mar77a: So, if 'Map.keys ages' is a list of Strings, then using 'unlines' with that will add the intermediate newlines.
15:21:13 <tchakkazulu> mar77a: Then you can use putStr, because it's a String.
15:21:30 <mar77a> that's a niftier solution
15:21:33 <mar77a> so many useful functions
15:21:50 <Arnar> Sadache: basically, if you have the hierarchy built already and need to add the info.. write a function that you give a list of the lists - with the broadest level one first - and the root of the hierarchy. for each node, this function should use the first list to look up info, attach it and recurse into the child nodes. when recursing, just send down the tail of the list-of-lists, that way - at each level, the head will be the correct list to look up the in
15:21:55 <tchakkazulu> mar77a: Yeah, there's a lot of ways to do this kind of thing.
15:22:22 <tchakkazulu> mar77a: And there are many useful function in the standard libraries that, at first, you'd write yourself over and over again.
15:22:24 <ReinoDios> http://www.refal.org/   Recursive functions algorithmic language
15:22:25 <dcoutts> ndm: congratulation!
15:22:25 <lambdabot> Title: C "/"
15:22:38 <tchakkazulu> mar77a: At least, that's how it worked for me :P
15:22:43 <vixey> ReinoDios: what about it?
15:22:53 <mar77a> yeah happens in all more or less high level languages though
15:22:57 <ReinoDios> vixey, supercompilation
15:23:17 <ndm> dcoutts, thanks :)
15:23:34 <ndm> dcoutts, i'll also be moving to cambridge in october
15:23:43 <dcoutts> ndm: oh yes?
15:23:46 <ndm> was going to say hi at FITA, but no you or Ian
15:23:55 <dcoutts> ndm: I was teaching OOP :-(
15:23:58 <ndm> dcoutts, yes, my g/f starts a PhD there
15:24:02 <Peaker> whew! All the rules of chess seem to work.. That took about 8 hours work [a lot more than I thought, chess is nuanced]... http://hpaste.org/7776
15:24:03 <ndm> hahahaha!
15:24:07 <dcoutts> ndm: cool, and what will you be doing?
15:24:33 <Peaker> doh its truncating it
15:24:36 <ndm> dcoutts, still no idea yet...
15:24:38 <dons> ndm, in the paper, you talk about reboxing unnecessarily in getchar
15:24:44 <dons> do you have an example that illustrates that in ghc?
15:24:47 <dons> i'm surprised.
15:25:02 <int-e> dons: meh, how sloppy. there's also a ) missing at the end of the description.
15:25:04 <Sadache> i have code that looks like http://hpaste.org/7774 and i want to contruct a hierarchy of results, the hierarchy is the order of the selectors (cityF,zoneF,regionF) any idea of an effecient way to do that?
15:25:09 <ndm> dons: yes, its a GHC bug number
15:25:22 <dons> the heap check issue is also possible to work around -- don't allocate
15:25:24 <ReinoDios> http://refal.net/doc/turchin/dag/dag.html
15:25:26 <lambdabot> Title: Metacompilation:Metasystem Transitions
15:25:33 <int-e> dons: (mersenne-random-pure64 again)
15:25:37 <Botje> Sadache: uh, does that typecheck? :)
15:25:40 <ndm> dons: yes, its a clear bug though the way its currently done
15:25:48 <dons> there's a new ticket to fix nested cpr to produce more cases where it doesn't allocate too.
15:25:51 <ndm> dons: but in this particular case, you could eliminate the return boxing, and get rid of it all
15:25:54 <dons> ndm, yeah, let me find what SPJ said yesterday
15:26:00 <ndm> dons: i saw it
15:26:04 <Sadache> Botje: I am not sure
15:26:08 <dons> ndm, so the ticket has the example code that illustrates the reboxing?
15:26:17 <ndm> dons: in this case, if you just pushed the heap check down, which is really trivial, you get the win
15:26:18 <Sadache> thats why i told, it looks like
15:26:19 <Botje> Sadache: you mean you want to sort by cityF, then zoneF, then regionF ?
15:26:41 <ndm> dons: yes, but it involves the FFI, and apparently the reboxing may be essential to get lazy IO with the FFI, or some other fairly involved reason
15:26:48 <Sadache> they are selectors that take a City as a parameter and return a string
15:27:12 <Sadache> they select a grouping to calculate performance for the grouping
15:27:16 <dons> hmm. do you have the ticket handy?
15:27:39 <ndm> dons: http://hackage.haskell.org/trac/ghc/ticket/1592
15:27:40 <Peaker> oh wait, pawns becoming stuff I haven't implemented... arrg!
15:27:40 <lambdabot> Title: #1592 (Unexpected boxing in generated code) - GHC - Trac
15:27:42 <Elly> w00t! I'm working for green hills this summer in the compilers group :D
15:27:47 <ndm> the ticket number is actually in the paper :)
15:27:55 <Peaker> chess is more complicated once you enumerate its actual entire set of rules
15:27:55 <vixey> Elly, ooh
15:28:01 <Sadache> a simple example is population, I group cities by country name (using countryF) and then sum their population
15:28:04 <conal> i'm looking for some shell magic (bash, i think).  when i run firefox on a url, the return comes back as if failure.  how can i make it look like a success, so make will keep running.  i don't want to use 'make -k', since i do want to abort on real errors.  perhaps there's some kind of trick with '||' ?
15:28:12 <Botje> Sadache: then you're probably best off writing a function to partition your dataset according to certain predicate
15:28:23 <Botje> conal: firefox blah; true
15:28:23 <conal> Elly: sweet!
15:28:27 <Elly> yeah :D
15:28:29 <vixey> Elly, How did you land that?
15:28:31 <Peaker> conal, you can use a '-' prefix on make commands to ignore their failures
15:28:35 <vixey> hi shapr
15:28:35 <Elly> vixey: I applied :P
15:28:42 <Peaker> conal, e.g:  a clean rule:  -rm *.o
15:28:48 <conal> Botje, Peaker:  thanks!
15:28:52 <vixey> hi audreyt
15:29:10 <shapr> hiya vixey
15:29:19 <shapr> vixey: Are you a bot?
15:29:27 <vixey> sharp: :(
15:29:29 * shapr grins
15:29:33 <Peaker> chessguy, you've inspired me to write a chess implementation (just the rules, not AI) in Haskell, and it took much longer than I thought! Did you end up implementing the entirety of chess?
15:29:39 <dons> ndm, hmm. there's no .hs example there though. just fragments. hmm
15:29:41 <chessguy> hi #haskellers
15:29:46 <shapr> vixey: I'm jus teasing you because I used to greet people as soon as they join the channel, and I got called a bot all the time!
15:29:49 <shapr> hiya chessguy
15:30:02 <lilac> when my program hangs in ghci, can i find out where it is?
15:30:05 <ndm> dons: http://hackage.haskell.org/trac/ghc/attachment/ticket/1592/4.hs
15:30:07 <lambdabot> Title: #1592: 4.hs - GHC - Trac
15:30:08 <vixey> hehe shapr in #io they have in the topic "please ignore our greeter bot" but there is no bot
15:30:12 <shapr> hah
15:30:12 <chessguy> Peaker: by 'the entirety', do you mean all the rules?
15:30:17 <Sadache> Botje: I want to yield groups of cities, using a City-> String function i can do that then calculate each group
15:30:23 <conal> Botje, Peaker:  both worked :) :)
15:30:27 <shapr> Hm, do I go to the gym, or do I unicycle?
15:30:32 <shapr> I could code instead!
15:30:32 <chessguy> hiya conal
15:30:41 <ddarius> shapr: Do all three!
15:30:42 <shapr> So hard to choose!
15:30:43 <Peaker> chessguy, yeah - including when you are allowed to castle, pawn eating a just-jumped pawn, etc
15:30:44 <dons> ndm, ah
15:30:44 <shapr> ooh, yeah!
15:31:00 <chessguy> Peaker: i haven't implemented all of that yet, no. but i intend to
15:31:05 <ddarius> Unicycle to the gym then code while doing leg presses.
15:31:19 <shapr> haha
15:31:25 <chessguy> Peaker: it's very tedious
15:31:35 <Botje> Sadache: so you need to write a partition-like function, then
15:31:35 <shapr> I wish I could do that sort of coding... spoken programming with a visual interface would work.
15:31:40 <shapr> Too bad nothing like that exists.
15:31:44 <Botje> probably a fold + Data.Map
15:31:45 <Peaker> chessguy, Yeah, I have implemented most rules, and have just remembered a new one that doesn't work in my model (so I'll have to expand it yet again)
15:31:48 <shapr> Makes me want to try spoken Aardappel
15:31:52 <dons> ndm, this guy, f60_rz3 :: State# RealWorld -> Int -> Int
15:31:53 <dons>  ?
15:32:05 <dons> isn't that interesting.
15:32:08 <dons> mm
15:32:09 <chessguy> Peaker: i guarantee you that serious testing would reveal bugs in what you already have, too
15:32:17 <Peaker> chessguy, A pawn "becoming" a different thing is not supported in my thing (because I need to be able to show the possible moves)
15:32:23 <dons> ndm, did you try unlifted ffi types?
15:32:26 <Peaker> chessguy, Guarantee?? :-)
15:32:36 <chessguy> Peaker: trust me
15:32:38 <Peaker> chessguy, I am surprised by how smoothly everything seems to work.. :-)
15:32:41 <ndm> dons: no, i use Yhc as a front end, so that would definately not have worked
15:32:54 <Peaker> any non-truncated paste site?
15:32:55 <dons> you know of -XUnliftedFFITypes though?
15:32:56 <vixey> :(
15:33:01 <ndm> Supero is kind of limited by taking Haskell through Yhc and skipping half of GHC's optimisations
15:33:07 <chessguy> Peaker: how are you testing it?
15:33:08 <shapr> ndm: yhc is really cool!
15:33:09 <ndm> dons: nope...
15:33:17 <dons> ah. so its a language flag you can turn on.
15:33:21 <ndm> shapr: its a little unmaintained
15:33:22 <Sadache> Botje: I need a fold + Data.Map for build a hierarchy of several result groups?
15:33:23 <Peaker> chessguy, playing with it
15:33:24 <mar77a> does runghc compile and run?
15:33:31 <shapr> ndm: Is there any way to turn yhc into something to run on the bare metal? That is, without an os?
15:33:34 <Peaker> chessguy, With a tiny command-line interface that pretty-prints a board
15:33:34 <chessguy> Peaker: heh.
15:33:40 <ndm> shapr: we really need an Igloo for it, but no one has any money or time
15:33:42 <Peaker> chessguy, http://pastebin.org/37400
15:33:46 <chessguy> Peaker: there are still bugs :)
15:33:49 <Botje> Sadache: no, to partition your input
15:33:55 <ndm> shapr: have you seen Reduceron? that runs without a CPU even :)
15:33:58 <shapr> Well, GHC had a Simon.. or two.
15:34:01 <Peaker> chessguy, what bugs for example?
15:34:15 <shapr> ndm: Yeah, not sure if I could do that same sort of thing on an ATMega168P though.
15:34:15 <ndm> shapr: should be easily possible, for someone who knows what they are doing
15:34:21 <Peaker> chessguy, run my thingie - try to find em :-)
15:34:25 <shapr> With 16k of ram..
15:34:32 <ndm> there just aren't enough Simon's to go round...
15:34:34 <shapr> Hm, I could try it though.
15:34:38 <chessguy> Peaker: you need a real test harness, trust me
15:35:19 <conal> chessguy: hi there!  how's it going?
15:35:26 <Peaker> chessguy, what kind of bugs are you talking about?
15:35:30 <chessguy> conal: going alright
15:35:53 * chessguy sighs
15:36:06 <Sadache> Botje: calculatePerformanceFor  works well, what I want is to build a hierarchy afterwords of results, i have calculated for cityF, zoneF and countryF, now i want to use that to build a hierarchy of results of country - zones - cities
15:36:34 <Peaker> chessguy, I kept finding model bugs where my model wasn't good enough to accomodate the weirdness of chess rules (dependencies on weird things on board, then about position moved to not being what's being eaten, and so on)
15:36:42 <Botje> Sadache: i still haven't got a clue what you're trying to do, sorry
15:36:53 <Peaker> chessguy, but the implementation seems to work as soon as the type system checks work
15:36:59 <chessguy> Peaker: generating chess moves correctly is not trival. not until you generate all the moves to a particular depth, and compare the number of positions to a known quantity, and do so for a LOT of positions, will you have found them all
15:37:21 <Botje> chess positions: gotta catch 'em all!
15:37:25 <Sadache> Botje: nevermind, thanks anuway
15:37:30 <chessguy> but hey, what do i know, i've only been studyng this stuff for 5 years
15:37:43 <Peaker> chessguy, we're not talking about a chess AI right, just move generator
15:37:52 <tromp_> connect-4 sure is a lot easier:)
15:37:57 <chessguy> Peaker: i'm well aware of what we're talking about, thanks
15:38:06 <Peaker> chessguy, I was making sure I am synchronized :)
15:38:12 <Peaker> chessguy, and not misunderstanding
15:38:16 <chessguy> conal: i think i got rid of all the noise we discussed in http://code.haskell.org/ChessLibrary/Chessboard.hs
15:38:26 <chessguy> conal: or a lot of it anyway
15:38:39 <Peaker> chessguy, can you describe some of the bugs you encountered, I am wondering if I have them too
15:38:43 <chessguy> Peaker: i've talked to dozens of chess authors, run tournaments, etc, etc.
15:39:04 <Peaker> chessguy, btw: The Gnome chess thing gets the chess rules all wrong :-(
15:39:18 <chessguy> Peaker: Gnome chess?
15:39:31 <mm_freak> http://hpaste.org/7777   -- can anyone tell me, why GHC complains "<<loop>>" here?  i'm really sure that there is no endless loop  (interesting hpaste entry number btw =) =
15:39:32 <conal> chessguy: better!  you could still tidy setCastleStatus, e.g., setCastleStatusChar 'K' = foo (\x -> x{wk=True})
15:39:44 <Peaker> chessguy, Ubuntu comes with a Chess GUI it names "Gnome chess" in the menu - and doesn't let you pick a non-queen for the pawn end line, for example
15:39:46 <conal> chessguy: where you choose "foo"
15:39:55 <ndm> mm_freak:   let cfg = cfg { surface = sf }
15:40:06 <ndm> mm_freak: let's are recursive, so this defines cfg in terms of itself
15:40:15 <conal> chessguy: but that's the only one that jumps out at me this time.
15:40:18 <Peaker> Hey I'd appreciate code-review feedbacks too! at  http://pastebin.org/37400
15:40:29 <ndm> mm_freak: cfg <- return $ cfg{surface = sf}  -- doesn't have the self-binding issue
15:40:30 <dibblego> Peaker, that's extraordinarily broken if it is true
15:40:46 <Peaker> dibblego, yeah, it sucks. I think some other rules were broken too
15:41:05 <Peaker> dibblego, the must-be-a-queen is a common misconception I think
15:41:18 <chessguy> conal: i was running into a ghc bug around that, so i didn't quite clean that up as much as i wanted to
15:41:19 <mm_freak> ndm: really?  i always thought, in a do a redefinition would shadow an already existing definition (which would be quite handy)
15:41:22 <dibblego> Peaker, there are many positions where selecting a Queen results in a draw, while another piece results in a win; it's very common in tournament play
15:41:28 <conal> chessguy: yoiks!
15:41:43 <chessguy> conal: yeah, it was hanging when i tried to interpret it
15:41:51 <ndm> mm_freak: it does, from the begining of that line onwards
15:41:52 <Sadache> does someone have a link to simple examples of EDSLs or a tutorial about that
15:42:03 <ndm> mm_freak: the problem is you use the same variable to the LHS of that line
15:42:14 <ndm> do let a = 1; let a = 2 -- fine
15:42:17 <Peaker> chessguy, hey, where's your paste/chess implementation? I'd like to take a look
15:42:20 <mm_freak> ndm: indeed, you are right…  it solved the problem
15:42:26 <mm_freak> thank you
15:42:27 <ndm> do let a = 1; let a = a+1 -- not find
15:42:27 <conal> chessguy: even without UndecidableInstances?
15:42:31 <ndm> no probs
15:42:45 <chessguy> conal: yeah, the only flag i'm using is wAll
15:42:53 <chessguy> conal: apparently it's an issue that's fixed in head
15:43:09 <chessguy> Peaker: http://code.haskell.org/ChessLibrary
15:43:09 <lambdabot> Title: Index of /ChessLibrary
15:43:31 <Peaker> chessguy, are you implementing a chess AI too?
15:43:44 <chessguy> Peaker: check out the readme :)
15:44:20 <Peaker> chessguy, do you know if "iteratively deepening" approaches are commonplace in chess AI's?
15:44:26 <mm_freak> (i wonder why that 'while' function i wrote in that post, is still not in the Control.Monad…  that would be very handy, so i wouldn't have to reinvent the wheel all the time)
15:44:42 <Sadache> anyone has links to sampls of DSLs in haskell
15:44:43 <chessguy> Peaker: they are
15:44:45 <Sadache> ?
15:45:23 <dcoutts> dons: does that unlines fuse well? I thought we had problems with putting streams into stream states.
15:45:29 <vixey> Sadache: Look at Seres et all embedding of logic programmin and parsec
15:45:42 <dcoutts> dons: I mean I bet it does fuse, but does it optimise well after that?
15:47:41 <ddarius> Sadache: I think there is a page full of those on haskell.org
15:48:46 <Sadache> ddarius: i am not finding it
15:48:59 <Peaker> chessguy, nice code. I have a slightly different approach I believe makes it a bit simpler, perhaps - I have an asymmetric view of the board - which has "myArmy" and "hisArmy" rather than white and black, and its reversed for each move, so I don't have to have a current color and functions that compare the color/etc
15:49:12 <dons> dcoutts: haven't checked recedntly
15:49:21 <dcoutts> mm, ok
15:49:34 <ddarius> http://www.haskell.org/haskellwiki/Research_papers/Domain_specific_languages
15:49:35 <lambdabot> Title: Research papers/Domain specific languages - HaskellWiki, http://tinyurl.com/2e9pgq
15:49:47 <dons> ndm, interesting. so there's definitely something funny there.
15:50:03 <dons> i can get the ffi call to be unboxed, but not the return value
15:50:07 <dons> so you can't avoid a heap check
15:50:20 <ndm> dons: yes, the charcount version is fine, the linecount version isn't
15:50:21 <Peaker> chessguy, I'd be glad if you found bugs in my implementation: http://pastebin.org/37400  (conal if you have time I'd love feedback too)
15:50:25 <Sadache> ddarius: thanks
15:50:26 <chessguy> Peaker: that will be a royal mess if you ever want to implement AI
15:50:29 <ndm> dons: how do you get the ffi call unboxed?
15:50:31 <Peaker> chessguy, why?
15:50:40 <ndm> dons: that flag you mentioned earlier?
15:50:40 <dons> hang on.
15:50:43 <dons> no flags. no.
15:50:53 <Peaker> chessguy, in the AI recursion you just reverse your perspective of the board
15:51:02 <dons> $wccall_r1bT :: State# RealWorld -> (# State# RealWorld, Int# #)
15:51:07 <dons> is what I get. which looks right ?
15:51:07 <ndm> i was loosing some on the heap check, but the boxing/unboxing every time lost me more
15:51:09 <Peaker> chessguy, you make moves - and making moves reverses it anyway
15:51:14 * chessguy sighs
15:51:14 <lilac> you know you're in trouble when your parser says: expecting any token or end of input
15:51:22 <chessguy> i know how it would work
15:51:39 <Peaker> chessguy, I'm just trying to understand why you think it will make the AI a mess...
15:52:37 <chessguy> Peaker: why are you differentiating between RightRook and LeftRook?
15:52:41 <ndm> dons: i think in that example the getchar is already unboxed, but the accumulator is still boxed
15:52:47 <conal> does anyone know offhand how to get suppress section numbering (TOC and body) on a haskell wiki page?
15:52:53 <dons> ah, and the return type stays boxed due to the lack of nested CPR
15:52:59 <Peaker> chessguy, it makes it easier to tell if the rooks moved - to disallow castling
15:53:17 <ndm> quite possibly
15:53:30 <ndm> i'm most interested in removing the boxed accumulator
15:53:33 <int-e> Peaker: that check is easy either way - just check the source square
15:53:36 <ndm> but removing the boxed return would be even better
15:53:44 <ndm> i think even the charcount has a boxed return
15:54:10 <Peaker> int-e, yeah, I guess, it would be less hacky :)
15:54:15 <dons> well, the boxed return only affects the heap check
15:54:23 <dons> since boxing there forces the heap check into the main loop
15:54:35 <ndm> dons: without the boxed return, bug 1498 would no longer bite
15:54:45 <ndm> i guess for your purpose, 1498 is a bigger deal?
15:55:44 <dons> http://hpaste.org/7779
15:55:51 <chessguy> conal: any thoughts on how to make the client code for testing this Chessboard not hideous?
15:56:31 <dons> ndm, so what was interesting was the accumulator needed some explicit strictness to unbox. normally, an Int accumulator would be fine on its own.
15:56:46 <dons> and the return value is boxed up, but that's separate.
15:57:16 <dons> so maybe you just need to guide the strictness analysis a bit more in the yhc core. add some bangs to things to ensure they're spotted as strict?
15:57:39 <vixey> hi grahamhutton
15:57:46 <ndm> dons: in my charcount example, it managed to unbox the accumulator, but not the result
15:57:52 <grahamhutton> hi vixey!
15:57:56 <vixey> uh oh
15:57:56 <ndm> dons: i.e. i don't think it needed the strictness at all
15:57:58 <chessguy> shouldn't the optimization stuff be discussed in ghc?
15:58:10 <vixey> that CTCP is a trick incase anyone didn't realize
15:58:11 <chessguy> it's not very friendly to newbies to be always doing it in here
15:58:20 <vixey> I wonder if anyone else got that
15:58:35 <Peaker> No more LeftRook/RightRook: http://pastebin.org/37405
15:58:40 <vixey>  * [got] (n=Rats@12.150.6.66): Rats
15:58:40 <vixey>  * [got] #haskell
15:58:44 <tieTYT> hah, i can't believe i fell for that
15:58:48 * got pops a paper bag behind vixey
15:58:49 <got> POP
15:58:51 <got> :)
15:58:51 <vixey> tieTYT: yeah I did once as well!
15:59:12 <tieTYT> it's not the first time someone's tried to trick me like that, but it's the first time i fell for it
15:59:20 <dons> ndm, where's the accumulator in your example?
15:59:23 <conal> chessguy: not immediately.  i'm absorbed in writing a blog post
15:59:33 <chessguy> conal: oh, quite fine. we can chat another time
16:00:21 <dons> ndm, re 1498, yeah. i'd like that. since everything else is working, mostly
16:00:22 <mm_freak> how do i get an array to the screen pixels of an SDL surface?  there is a function (surfaceGetPixels :: Surface -> IO Pixels), but i can't find any information about the 'Pixels' type
16:00:35 <ndm> dons: this would be the charcount one, not sure the full code is anywhere
16:01:17 <vixey> grahamhutton: I think http://www.cs.nott.ac.uk/~gmh/ is down?
16:01:18 <lambdabot> Title: Graham Hutton
16:01:24 <dons> so basically getchar in a loop till EOF?
16:01:27 <dons> with an accumulator?
16:01:35 <vixey> or maybe just not loading for me I gues..
16:01:39 <ndm> dons: yes
16:01:46 <grahamhutton> i just tried, and it works OK for me :-)
16:01:50 <ndm> then a single boxing on the return
16:01:51 <dons> mm, get better code under 6.9
16:01:57 <dons> ok. let me try that.
16:02:00 <ndm> but unfortunately a heap check for every single iteration
16:02:06 <ndm> my results were 6.8.2, i think
16:02:08 <conal> chessguy: that'd be great.  i printed and will noodle over it when i'm looking for a break.
16:02:17 <Peaker> how do I throw something for IO's catch to catch?
16:02:18 <chessguy> conal: sounds good
16:02:23 <dons> yes, if it boxes the return,y you'll get the heap check
16:02:28 <ndm> @type ioError
16:02:29 <lambdabot> forall a. IOError -> IO a
16:02:30 <grahamhutton> our servers are definitely up, so it may be a local problem at your end
16:02:31 <dons> ndm, but you can avoid the boxed  return i think.
16:02:39 <vixey> oh it works now!
16:02:42 <ndm> dons: with an annotation, or automatically?
16:02:43 <Peaker> thanks
16:02:52 <dons> gimme a sec.
16:03:03 <ndm> dons: remember this code has gone through a lot to get to where it does! it starts at print . length . lines =<< getContents
16:03:08 <dons> yep.
16:03:12 <dons> :)
16:03:59 <ddarius> chessguy: This isn't a newbie channel.
16:04:00 <conal> i got an irc "*** Undefined CTCP query received. Silently ignored".  does that message usually mea someone not registered tried to IM me?
16:04:14 <chessguy> ddarius: i never said it was
16:04:20 <vixey> conal: actually it was a prank
16:04:37 <conal> vixey: yours?
16:04:42 <vixey> conal: no "got"
16:04:53 <vixey>  * Received a CTCP NOTICE You have (1) unread messages, please type "/server messages receive" to receive them. from got (to #haskell)
16:04:57 <Peaker> chessguy, would it be right to say that in chess, you are allowed to make moves only if they don't leave you in check, and that you lose if no moves are left (and king is under threat)?
16:05:07 <vixey> conal: they do this kind of regularly
16:05:17 <chessguy> Peaker: those are the rules, yes
16:05:37 <conal> vixey: oh, thx.  i'm such an irc newbie.
16:05:58 <Peaker> chessguy, I have always had the rules formulated a bit differently in my head and implementing this simplified/formalized the understanding a bit :)
16:06:15 <vixey> conal: I think  * [got] (n=Rats@12.150.6.66): Rats should get a temporary ban ..
16:06:29 <conal> vixey: yep!
16:07:52 <vixey> (btw if someone who didn't register tried to PM you it would silently ignored, or it would get through if you set unfiltered on)
16:13:10 <dons> ndm: ok, i concede defeat.
16:13:15 <dons> i can't get it to unbox the return.
16:13:35 <dons> for pure code, using a specialised strict return type works (one that turns into (# Int#, Int# #) for example
16:13:39 <ndm> dons: i couldn't either, in fact, i didn't even realise GHC could unbox the returns - or else i would have reported it as a bug
16:13:42 <dons> but IO doesn't want to be friendly
16:13:56 <dons> no, it definitely does. that's the CPR analysis
16:14:01 <dons> but it doesn't work for nested things
16:14:11 <ndm> ah, well in that case the CPR analysis is lacking...
16:14:15 <dons> so return Int will work in registers, or (# Int, Bool #)
16:14:18 <ndm> (but we already knew that)
16:14:19 <dons> but not Pair Int Int
16:14:33 <dons> yes, its that nested cpr issue
16:14:43 <ndm> well Supero2 will do its own unboxing, which will solve all these problems
16:14:58 <dons> yeah, if you just generate your own strict values
16:15:08 <dons> then no need to massage the ghc optimiser
16:15:11 <ndm> yep, well at the moment Supero knows Int = Int
16:15:21 <ndm> if it knew Int = I# Int#, it would happily remove them
16:15:26 <dons> otherwise, the wc loop looks good.
16:15:44 <ndm> but if you get an unboxed Int# then the type checker no longer works :(
16:15:54 <ndm> or at least, you need type annotations in some places
16:16:35 <ndm> yeah, i was particularly happy with the wc loop
16:16:56 <dons> so hmm, so what is the issue on the original ticket we looked at
16:17:12 <dons> http://hackage.haskell.org/trac/ghc/ticket/1592
16:17:14 <lambdabot> Title: #1592 (Unexpected boxing in generated code) - GHC - Trac
16:17:36 <dons>  oh, somewhere in there the accumulator wasn't being spotted as unlifted
16:18:11 <dons> so i don't understand then why my getchar is unlifted
16:18:27 <ndm> you have a simple loop
16:18:30 <dons> oh, you used exitWith
16:18:34 <tieTYT> dons: are you a ghc contributor?
16:18:36 <ndm> for a simple loop, my getchar was unlifted
16:18:45 <dons> right. I see.
16:18:50 <ndm> nope, no exitWith - but GHC was worried it might possibly be somewhere near
16:18:57 <dons> tieTYT: yeah
16:19:01 <tieTYT> cool
16:19:19 <ndm> i still don't quite get why a simple loop works but a complex one doesn't - i still have a suspicion about an analysis pass
16:19:42 <ndm> i don't quite believe the explanation in the ticket, but really don't  understand much of it either...
16:20:56 <dons> so the statement in the paper about 'strictness for functions that use the FFI' doesnt' seem to be right. its to do with exceptoin throwing things, not FFI things
16:21:09 <dons> any exception will do. whether or not FFI is involved, no?
16:21:17 <ndm> there is no exception being raised
16:21:26 <ndm> but GHC believes the getchar may throw an exception
16:21:38 <lilac> @hoogle [a] -> a -> Int
16:21:39 <lambdabot> No matches, try a more general search
16:21:45 <ndm> although in the charcount it doesn't seem to worry, but in linecount it really gets upset
16:21:51 <ndm> @type findIndex
16:21:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
16:22:08 <dons> so your text makes it sound like a general thing though. this is really specifici to having exceptions nearby
16:22:12 <ndm> lilac: that's probably what you want ^^^
16:22:23 <lilac> ndm: ty
16:22:27 <dons> you can happily, for example, write a line counter that has an unboxed accumulator.
16:22:39 <ndm> dons: using getchar?
16:22:48 <ndm> dons: if that is the case, then the bug report is wrong
16:23:02 <Peaker> yay, I added support for pawns becoming whatever they want - AFAIK my chess move generator is complete (ignoring ties/wins)
16:23:09 <ndm> dons: that text isn't what i believe is happening, its what the Simon's believe is happening
16:23:25 <dons> http://hpaste.org/7779#a1 ?
16:23:32 <gwern> @seen nomeata
16:23:32 <lambdabot> I saw nomeata leaving #darcs, #xmonad and #haskell 1h 46m 11s ago, and .
16:23:52 <dons> unboxed accumulator. boxed return (due to nested CPR)
16:23:57 <gwern> @ask nomeata Heya; what's the license on frakview?
16:23:58 <lambdabot> Consider it noted.
16:24:05 <ndm> dons: its all in 1592
16:24:31 <ndm> the accumulator loop is two co-recursive functions, and it doesn't unbox
16:24:44 <gwern> wadler sailed the ocean blue?
16:24:46 <ndm> i suspect some analysis goes wrong, the simons think its due to exceptions
16:25:33 <dons> well, can you come up with an example without exceptions that fails?
16:25:45 <dons> the above was an example with the ffi that worked.
16:25:46 <Peaker> chessguy, where can I find information regarding number of moves/etc so I can test my solution?
16:25:57 <dons> which makes me thing that yes, you do need something 'bottom' to mess it up
16:26:35 <gwern> oh, dons, do you know that hs-plugins fails with various cabals from darcs?
16:26:47 <dons> The phrase about "marking an FFI function as not generating an exception" wouldn't help here.
16:27:14 <dons> which is the section of the paper text i think is inaccurate. It can't be the FFI, or my getchar would also be troublesome.
16:27:31 <vincenz> Peaker: do you deal with proper castling?
16:27:38 <Peaker> vincenz, yeah
16:27:40 <vincenz> Peaker: that requires history
16:27:42 <dons> ndm, but there's definitely an issue with bottom-throwing things
16:27:45 <Peaker> vincenz, yeah
16:27:49 <vincenz> Peaker: even stuf like castle through chec?
16:27:54 <vincenz> Peaker: and en passant?
16:28:09 <Peaker> vincenz, as in pawn eating diagonally another pawn which just jumped?
16:28:12 <vincenz> yep
16:28:15 <Peaker> vincenz, yep
16:28:23 <vincenz> spiffy
16:28:35 <vincenz> Peaker: so how od you store the fact the king didn't move?
16:28:38 <ndm> dons: yes, i agree, i think the paper has a reasonable chance of being wrong
16:28:42 <vincenz> (or ther ook for that matter)
16:28:45 <Peaker> vincenz, http://pastebin.com/m2841c12c
16:29:02 * vincenz will have to look later, firefox won't load since he's upgrading his OS
16:29:07 <ndm> dons: agreed - the fact that charcount works suggests its not the getchar (or exceptionness of it) that is causing linecount a problem
16:29:12 <Peaker> vincenz, #
16:29:12 <Peaker> data MoveHistory = MoveHistory {kingMoved :: Bool, leftRookMoved :: Bool, rightRookMoved :: Bool}
16:29:19 <ndm> my guess is its the nested loop and more complex recursion
16:29:25 <dons> ndm, for mutual recursion, it might be the boxed return getting in the way
16:29:27 <dons> for example
16:29:33 <ndm> dons: quite possibly
16:29:35 <Peaker> vincenz, and each player has one
16:29:36 <dons> or exceptions, as the simons thought
16:29:46 <vincenz> Peaker: neat
16:29:54 <ndm> but as you said, if it was exceptions, we shouldn't be able to do it for charcount
16:30:08 <dons> anyway, good. we're down to the pointy end.
16:30:12 <dons> those damn heap checks.
16:30:25 <Peaker> vincenz, its about 200 lines of Haskell -- took about 10 hours of work, I thought I was embarking on a 30 minute thingie :-)
16:30:39 <vincenz> Peaker: lots of corner cases (:
16:30:59 <Peaker> vincenz, and each one broke my types and I had to refine them.. last one I had to add is pawn becoming things - my type describing a move couldn't describe that
16:31:09 <ndm> dons: does that mean you've beefed up the CPR?
16:31:30 <ndm> pushing the heap checks down will get a benefit in this case, but not all
16:31:31 <Peaker> vincenz, I could have Board->Board as a description of a move, but then I would not be able to show the user what moves are possible concisely
16:31:35 <augustss> dons: every call graph cycle needs a heap check, really
16:31:37 <vincenz> Peaker: regarding the history, why not store full history?
16:31:59 <dons> augustss: well, not if its not allocating in the main loop
16:32:01 <Peaker> vincenz, I could do that - but it would probably not be the way I check whether rook/king moved, that's simply harder
16:32:07 * vincenz nods
16:32:18 <augustss> dons: and how do you time slice without it?
16:32:30 <dons> well, ghc doesn't.
16:32:42 <dons> -fdenial-of-service :)
16:32:56 <Peaker> vincenz, I am relatively new to Haskell (I didn't write much yet) so I am sure my code can be tidied up made nicer some
16:33:02 <augustss> right, so depending on what you want, you may need those heap checks or not
16:33:08 <vincenz> Peaker: looks decent from a first galnce
16:33:13 <augustss> it's tricky
16:33:16 <Peaker> vincenz, thanks
16:33:30 <vincenz> reboot tme
16:33:34 * SamB_XP_ thinks they really ought to implement -fno-denial-of-service *AND* make it the default
16:33:39 <dons> augustss: yeah. if they were consistently removable, you might want some flag to disable their removal
16:33:43 <Peaker> vincenz, did you fix firefox?
16:34:08 <ndm> augustss: GHC decided that is not necessary, and that unboxed computation does not need to timeslice
16:34:30 <ndm> augustss: there is an example in the manual which shows thread starvation
16:34:30 <vixey> I want to go study fp
16:34:33 <augustss> ndm: i don't think that was really a deep decision
16:34:41 <ndm> augustss: no, me neither :)
16:34:43 <vixey> maybe write some useful code
16:34:48 <SamB_XP_> augustss: probably only because GHC sucks at doing unboxed computation for extended periods of time in a useful way ;-P
16:34:49 <dons> no, it just happened. and no one complained
16:35:17 <ndm> well, and GHC puts heap checks in lots of places - if it makes the compiler efficient enough, it might start to become an issue
16:35:38 <dons> right. some of these array fusion programs only allocate at the end, on a print $ ..
16:35:38 <augustss> ndm, dons: there are ways to fix it, but they are not very nice
16:36:42 <SamB_XP> ways to fix it?
16:36:49 <augustss> for instance, if there's a cycle you can unroll it until the heap check has been amortized enough
16:37:45 <augustss> or you can make the code interruptible at any point
16:38:04 <Bonus> hey guys
16:38:07 <augustss> which can be done
16:38:08 <vixey> hi Bonus
16:38:12 <Bonus> has anyone ever thought of like
16:38:14 <Bonus> making a wsgi
16:38:17 <Bonus> but only for haskell
16:38:19 <Bonus> that would pwn
16:38:40 <Bonus> i think it also fits the whole functional thingy quite well
16:38:45 <Bonus> request goes in, response comes out
16:39:35 <ndm> Yhc guarantees a heap check at the beginning of every linear block
16:39:39 <vincenz> Peaker: last thing I forgot to ask before I go to sleep
16:39:41 <ndm> so gets reliable threading
16:39:46 <vincenz> Peaker: do you draw checks on board repetitions
16:39:52 <vincenz> can''t remember the exact rule
16:40:02 <augustss> ndm: which is ok if you don't care about top performance
16:40:17 <Peaker> vincenz, I don't compute win/lose/draw yet -- just the moves
16:40:36 <Peaker> vincenz, though the check rules I do compute and they may prevent you from having any move (if you lose)
16:40:45 <ndm> augustss: yes, we still case on 'otherwise' lots, so still have a while to go before it matters
16:40:49 * vincenz nods
16:41:08 <Peaker> btw: Gnome chess also doesn't draw on 3 repetitions of the board
16:43:55 <Peaker> chessguy, hey maybe you missed my question above? How do I test that generate correct moves? Do you have the total move counts at each depth, etc?
16:44:46 <chessguy> Peaker: http://code.haskell.org/ChessLibrary/perftsuite.epd
16:45:55 <Peaker> chessguy, reverse engineer that format? :-)
16:46:11 <chessguy> Peaker: or you could do some basic googling
16:46:36 <Peaker> chessguy, well a trivial one didn't work so I was hoping you could help
16:47:34 <chessguy> Peaker: http://www.very-best.de/pgn-spec.htm
16:47:38 <lambdabot> Title: Portable Game Notation (PGN): Specification
16:53:28 <gwern> hm.
16:53:38 <gwern> who is Malcolm Wallace on #haskell?
16:53:55 <bos> malcolmw
16:54:06 <gwern> @seen malcolmw
16:54:06 <lambdabot> I saw malcolmw leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 6h 44m 55s ago, and .
16:55:22 <gwern> @ask malcolmw would there be any point in updating hmake?
16:55:22 <lambdabot> Consider it noted.
16:58:11 <lilac> how can i make ghc do a clean build?
16:58:38 <dcoutts> gwern: I'm trying to obsolete hmake, but it's going to take a while
17:01:06 <vixey> hi jorick
17:01:57 <jorick> :)
17:07:30 <Peaker> vincenz, if you get a chance to take a look and give me some feedback about how to improve the code, I'd be glad
17:07:36 <Saizan> i actually had a bash script called hmake which called setup configure/build/install, but cabal took it for the real hmake essentially generating a fork-bonb
17:08:01 <dcoutts> Saizan: hah
17:08:40 <Peaker> how do you convert a character to its ascii/unicode code?
17:08:58 <Saizan> ?type Data.Char.ord
17:09:04 <lambdabot> Char -> Int
17:09:06 <Peaker> Thanks
17:09:13 <dcoutts> Saizan: mm, yes that's an interesting one :-). Though not really a forking fork bomb, only an iterative one.
17:10:05 <Saizan> dcoutts: yeah, just linear, not exponential :)
17:13:13 <gwern> cabal supports hmake?
17:13:38 <dcoutts> gwern: for the nhc98 support yes
17:14:03 <dcoutts> gwern: as you know, for ghc cabal uses --make, and for nhc98 it uses hmake
17:14:11 <Saizan> uhm, this was with only ghc installed
17:14:29 <dcoutts> Saizan: it always looks for all progs it knows about
17:14:49 <dcoutts> because cabal does not yet have a .hs dependency chasing system so it relies on --make/hmake whatever
17:15:18 <Saizan> heh
17:16:19 <wolgo> Are the indenting rules the same as python?
17:16:37 <dcoutts> wolgo: to a first approximation, yes
17:16:57 <wolgo> Thanks.
17:17:37 <geezusfreeek> wolgo: we tend to call them "layout rules" rather than "indentation rules," i suspect because you can start a new "block" without having to start it on a new line
17:17:58 <chessguy> @hoogle toUpper
17:17:59 <lambdabot> Data.Char.toUpper :: Char -> Char
17:20:21 <wolgo> hpaste is down :(
17:20:28 <wolgo> or being hammered
17:20:31 <cjay> @yow
17:20:32 <lambdabot> I can't decide which WRONG TURN to make first!!  I wonder if BOB
17:20:32 <lambdabot> GUCCIONE has these problems!
17:22:19 <shapr> @yow
17:22:19 <lambdabot> Yow!  Am I having fun yet?
17:22:25 <shapr> wolgo: I could go fix hpaste...
17:22:38 <shapr> ooh, it's down.
17:23:44 <shapr> Or not?
17:23:48 <shapr> @seen hpaste
17:23:48 <lambdabot> I haven't seen hpaste.
17:24:27 <vixey> shapr: can you juggle?
17:24:45 <shapr> vixey: Somewhat, why?
17:24:50 <shapr> wolgo: fixed!
17:25:07 <vixey> just wondered, cause I found unicycling impossible but I can juggle quite well
17:25:22 <shapr> Juggling seems harder for me.
17:25:43 <shapr> Something still strange going on with hpaste host.
17:26:11 <shapr> !paste
17:26:11 <hpaste> Haskell paste bin: http://hpaste.org/
17:26:13 <shapr> hmm
17:26:28 * shapr shrugs
17:26:53 <vixey> I'm trying to figure out what to do
17:27:13 <vixey> I really want to do something fp or type theory
17:28:59 <Elly> mmm, type theory
17:29:15 <Peaker> what does "lex" do?
17:29:30 <shapr> vixey: Go for it!
17:29:58 <vixey> shapr: ty :)
17:30:18 <ddarius> Peaker: lexes
17:30:49 <Peaker> ddarius, with arbitrary lexiing rules?
17:32:17 <tchakkazulu> @type lex
17:32:19 <lambdabot> String -> [(String, String)]
17:32:20 <ddarius> Peaker: It lexes Haskell (more or less)
17:32:36 <tchakkazulu> Testing follows.
17:32:42 <tieTYT> about how many web frameworks does haskell have?
17:32:55 <shapr> tieTYT: Depends on your definition of a web framework.
17:33:07 <tieTYT> well
17:33:13 <tieTYT> ok
17:33:29 <shapr> If you mean a full-on web application server like Zope/Plone, then only one.
17:33:39 <tieTYT> does haskell have something analogous to JSPs and servlets?
17:33:47 <shapr> But if you mean web templating and database bindings, there are several of both.
17:33:54 <tieTYT> yeah i mean the latter
17:34:01 <tieTYT> ok cool
17:35:00 <noecksit> hello, i have a question concerning monad transformations
17:35:30 <noecksit> i know that to convert an IO monad to some other monad, you would use liftIO to lift it into the new monad
17:35:54 <hpaste>  wolgo pasted "Learning Haskell Indentation" at http://hpaste.org/7780
17:36:01 <noecksit> but what if the monad is of some other form, and you want to lift it into the IO monad?
17:36:18 <ddarius> You don't lift things into the IO monad.
17:36:38 <wolgo> http://hpaste.org/7780 - possibly incorrect indentation
17:37:18 <noecksit> well, i want to use forkIO on a monad, but the parameter for forkIO is of the form IO (), and my monad is not IO ()
17:37:54 <EvilTerran> ?type forkIO
17:37:56 <lambdabot> Not in scope: `forkIO'
17:38:01 <EvilTerran> ?hoogle forkIO
17:38:01 <lambdabot> GHC.Conc.forkIO :: IO () -> IO ThreadId
17:38:01 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
17:38:09 <EvilTerran> hmm
17:38:11 <noecksit> it is Net (), and I would like to make it IO ()
17:38:30 <EvilTerran> that will require some kind of escape function to be provided for Net, or a wrapped version of forkIO
17:38:34 <EvilTerran> forkNet or something
17:39:03 <EvilTerran> but you can't do it without extra knowledge of the Net monad beyond the monad laws
17:39:40 <noecksit> Net is just a synonym for ReaderT Bot IO
17:40:05 <geezusfreeek> noecksit: you will want runReaderT
17:40:44 <EvilTerran> ?unmtl ReaderT Bot IO a
17:40:45 <lambdabot> Bot -> IO a
17:40:59 <geezusfreeek> woah, never seen unmtl before
17:41:01 <EvilTerran> yeah, you'll need to get the (IO a) out of that
17:41:20 <geezusfreeek> :t runReaderT
17:41:22 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
17:41:39 <ddarius> geezusfreeek: Lambdabot is full of secrets.
17:41:46 <EvilTerran> geezusfreeek, yeah, it's quite handy. you give it a (this is important) fully-applied type with monad transformers, and it spits out an equivalent (modulo newtyping) one without the transformers
17:41:50 <geezusfreeek> ddarius: yeah, i need to look at @help a bit more
17:42:34 <noecksit> EvilTerran: what do u mean by getting the (IO a) out of the way?
17:42:36 <EvilTerran> ?unmtl StateT Int (ReaderT String IO) a
17:42:36 <lambdabot> Int -> String -> IO (a, Int)
17:42:43 <geezusfreeek> EvilTerran: i assume it only works on the mtl transformers though? meaning if you already know those (not that many) you don't really need it outside of demonstration purposes
17:42:56 <noecksit> do u mean in the forkIO call?
17:43:02 <EvilTerran> noecksit, not getting it out of the way, extracting it from the ReaderT-transformed value
17:43:15 <geezusfreeek> noecksit: you have the IO monad wrapped, so you need to unwrap it
17:43:23 <EvilTerran> geezusfreeek, indeed, i think it's just MTL. it's mostly useful for demonstration purposes.
17:43:41 <geezusfreeek> EvilTerran: well, it's still cool
17:43:55 <geezusfreeek> lambdabot++
17:44:22 <wolgo> Ahh I see
17:44:27 <noecksit> geezusfreeek: ok, how would i start?
17:44:57 <geezusfreeek> :t runReaderT -- for noecksit
17:44:58 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
17:45:30 <geezusfreeek> noecksit: you use runReaderT, pass it a Bot, and pass to that your value of type ReaderT Bot IO a
17:45:41 <wolgo> Why can't I put areasq (f 4) in the end of my source file and run it in ghci?
17:46:08 <geezusfreeek> wolgo: you can say foo = areasq (f 4), and then run foo in ghci
17:46:20 <geezusfreeek> wolgo: but ghci will not automatically _run_ anything
17:46:36 <geezusfreeek> wolgo: and at the top level haskell expects mostly function definitions, not code to be executed
17:47:36 <geezusfreeek> wolgo: just noticed you pastie above. didn't see a response. was your question answered?
17:47:52 <noecksit> geezusfreeek : ok, i already did that, actually the function where i need to do the fork on gets called as a result of me executing runReaderT
17:48:00 <wolgo> yes
17:48:06 <geezusfreeek> wolgo: okay good
17:48:07 <wolgo> you answered it
17:48:25 <wolgo> AHA
17:48:27 <geezusfreeek> noecksit: maybe you should hpaste your code
17:48:31 <wolgo> I have to compile it with ghc
17:48:36 <wolgo> THAT IS WHY!
17:48:40 <wolgo> Thanks geezusfreeek
17:48:51 <geezusfreeek> wolgo: ghci should work without compiling, actually
17:49:02 <wolgo> my .hs source
17:49:03 <geezusfreeek> wolgo: unless you are just thinking out loud about something else
17:49:06 <wolgo> yeah
17:49:09 <wolgo> thinking outloud
17:49:10 <wolgo> sorry
17:49:12 <geezusfreeek> okay
17:49:13 <Trinithis> all monads are arrows right?
17:49:24 <EvilTerran> all monads generate an arrow
17:49:28 <geezusfreeek> Trinithis: well, they can all be treated as arrows
17:49:38 <EvilTerran> it's not like saying all monads are functors
17:49:40 <geezusfreeek> more accurately what EvilTerran said
17:49:43 <hpaste>  noecksit pasted "forkIO woes" at http://hpaste.org/7781
17:49:49 <geezusfreeek> all arrows are monads though
17:49:56 <Trinithis> oh
17:49:59 <ddarius> No they aren't.
17:50:01 <EvilTerran> but, given a monad, there is an arrow that falls out naturally, namely the kleisli arrow
17:50:03 <geezusfreeek> err
17:50:03 <EvilTerran> geezusfreeek, what?
17:50:21 <ddarius> geezusfreeek: Missed a "not" ?
17:50:30 <noecksit> im having trouble at line 48
17:50:34 <geezusfreeek> ddarius: yes
17:50:43 <geezusfreeek> ^ not the case
17:50:56 <geezusfreeek> fingers too fast
17:51:19 <Trinithis> EvilTerran: Do you know any good sources to learn more about Kleisli arrows?
17:51:42 <idnar> if you only have kleisli arrows, there's not much point in using arrows instead of monads afaict
17:51:49 <EvilTerran> no, not really... try the wikibook?
17:51:54 <geezusfreeek> noecksit: liftIO converts your nested monad into your outer monad
17:51:59 <EvilTerran> noecksit, you're going to need to unwrap and re-wrap the ReaderT aspect of the monadic action to pass it to forkIO
17:52:01 <hpaste>  (anonymous) annotated "Learning Haskell Indentation" with "(no title)" at http://hpaste.org/7780#a1
17:52:05 <geezusfreeek> you can remove that inner liftIO
17:52:31 <Trinithis> :t liftIO
17:52:33 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
17:52:45 <wolgo> geezusfreeek: with my code in the paste, why will areasq( f 3 ) not run?
17:52:46 <noecksit> geezusfreeek : yeah, i was just trying random stuff out there
17:52:54 <wolgo> Is it because of that monad stuff?
17:52:59 <Cale> liftIO converts an IO action into an action in any monad which supports IO.
17:53:00 <EvilTerran> noecksit, but it seems you don't particularly need listen to be in Net - why not just make listen :: Handle -> IO ()?
17:53:11 <Trinithis> is liftIO safe?
17:53:15 <Cale> Yes.
17:53:16 <geezusfreeek> wolgo: you code doesn't even seem syntactically valid to me
17:53:29 <Cale> :t liftIO
17:53:31 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
17:53:32 <geezusfreeek> wolgo: you can only define functions at the top level like that, not run code
17:53:45 <wolgo> Yeah it will not reload in ghci
17:54:04 <noecksit> EvilTerran : can I? i used dons guide as a starting point and just stuck with it
17:54:08 <geezusfreeek> wolgo: change that line to say foo = areasq (f 3)
17:54:08 <wolgo> the part that kills it is areasq ( f 3)
17:54:19 <geezusfreeek> wolgo: then in ghci you can execute foo
17:54:23 <wolgo> right
17:54:26 <wolgo> You answered that part
17:54:35 <EvilTerran> noecksit, well, as it stands, you don't do anything with the ReaderT aspect of the monad in listen
17:54:37 <geezusfreeek> oh, so the paste is not up to date then?
17:54:38 <Cale> wolgo: You might want something like   main = print (areasq (f 3))
17:54:53 <wolgo> What rule am I breaking when I try to do areasq (f 3) in the pasted code
17:55:01 <EvilTerran> ?type runReaderT
17:55:14 <Cale> wolgo: You're breaking the rule that only declarations occur at the top level of a Haskell source file.
17:55:16 <lambdabot> thread killed
17:55:19 <EvilTerran> ?type runReaderT
17:55:21 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
17:55:40 <geezusfreeek> wolgo: that line is not a function
17:55:42 <Cale> wolgo: areasq (f 3) is an expression, it evaluates to a number
17:56:06 <Cale> wolgo: If you want to print that number, you have to define a main IO action, which says to print it.
17:56:51 <Cale> (it's not actually an indentation problem in case that's what the compiler said)
17:57:11 <geezusfreeek> yeah the compiler claims a lot of things might be indentation when they really aren't
17:57:17 <wolgo> Ok
17:57:21 <wolgo> I see
17:57:22 <noecksit> is says Couldn't match expected type 'ReaderT Bot IO t' against inferred type 'IO ()'
17:57:27 <ddarius> It could in theory be an indentation problem.
17:57:31 <wolgo> So because I had no io action.
17:57:35 <wolgo> Thanks guys :)
17:57:43 <noecksit> however, i did put a "listen sock >> return ()
17:57:43 <wolgo> This is a very helpful crowd.
17:57:54 <tieTYT> lets give them a hand
17:58:02 <Cale> Yeah, if you put in   main = print (areasq (f 3))   you should be able to compile the program and have it run
17:58:12 <EvilTerran> noecksit, if you want to keep the type of listen, you'll need to write something like "liftIO . forkIO . runReaderT (listen sock)
17:58:12 <EvilTerran>  =<< ask"
17:58:34 <EvilTerran> er, ignore the stray line break
17:58:51 <EvilTerran> and i'm not sure if that's necessarily quite right
17:58:55 <noecksit> yeah, this is my sole way of learning haskell, if it wasnt for this channel i wouldve given up a long time ago
17:59:05 <EvilTerran> ?type \m -> runReaderT m =<< ask
17:59:07 <lambdabot> forall a (m :: * -> *) b. (MonadReader a m) => ReaderT a m b -> m b
17:59:39 <EvilTerran> yeah, that looks like the way to unwrap the ReaderT from the IO action
17:59:58 <noecksit> why would I need to do "runReaderT (listen sock)"?
18:00:12 <EvilTerran> to get an IO () out of the ReaderT ... IO ()
18:00:36 <geezusfreeek> :t runReaderT
18:00:39 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
18:01:14 <EvilTerran> but you need to pass the environment value to runReaderT, which is the result of running the action "ask" in the outer monad
18:01:19 <EvilTerran> hence (=<< ask)
18:01:19 <noecksit> not only that, wouldn't it need another parameter, the initial state?
18:01:34 <noecksit> oh ok
18:01:51 <noecksit> thats the socket that i would get into the argument
18:01:51 <hpaste>  (anonymous) annotated "WGET" with "(no title)" at http://hpaste.org/7672#a4
18:01:57 <EvilTerran> so i think "liftIO . forkIO . runReaderT (listen sock) =<< ask" should work. not 100%, but fairly confident
18:02:26 <ddarius> :t liftIO . forkIO . runReaderT (listen ?sock) =<< ask
18:02:28 <lambdabot> Not in scope: `forkIO'
18:02:36 <ddarius> :t liftIO . Control.Concurrent.forkIO . runReaderT (listen ?sock) =<< ask
18:02:37 <EvilTerran> ?type forkIO
18:02:39 <lambdabot>     Couldn't match expected type `()' against inferred type `(a, w)'
18:02:39 <lambdabot>       Expected type: ReaderT a1 IO ()
18:02:39 <lambdabot>       Inferred type: ReaderT a1 IO (a, w)
18:02:40 <lambdabot> Not in scope: `forkIO'
18:02:50 <tchakkazulu> ?hoogle forkIO
18:02:51 <lambdabot> GHC.Conc.forkIO :: IO () -> IO ThreadId
18:02:51 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
18:04:11 <geezusfreeek> :t \m -> Control.Concurrent.forkIO . runReaderT m =<< ask
18:04:12 <lambdabot> forall a. (MonadReader a IO) => ReaderT a IO () -> IO GHC.Conc.ThreadId
18:04:58 <EvilTerran> well, i think that looks plausible, anyway
18:04:58 <geezusfreeek> :t \m -> liftIO . Control.Concurrent.forkIO . runReaderT m =<< ask
18:05:00 <lambdabot> forall (m :: * -> *) a. (MonadReader a m, MonadIO m) => ReaderT a IO () -> m GHC.Conc.ThreadId
18:07:48 <noecksit> whew, seemed to work, when listen returns Net ()
18:08:26 <noecksit> so in this case, did it return IO because the argument that it passed from ask was IO?
18:08:59 <geezusfreeek> noecksit: what is "it" in that question?
18:09:19 <noecksit> geezusfreeek : "it" is the runReaderT function
18:09:50 <geezusfreeek> noecksit: runReaderT returns an IO action because your ReaderT is around the IO monad
18:10:35 <noecksit> geezusfreeek : how does it now that? does it infer that from the forkIO function before that?
18:10:41 <noecksit> *know
18:11:01 <EvilTerran> runReaderT :: Monad m => ReaderT r m a -> r -> m a
18:11:13 <geezusfreeek> noecksit: because listen sock is of type ReaderT Bot IO ()
18:11:23 <EvilTerran> this specialises to "ReaderT Bot IO () -> Bot -> IO ()"
18:11:43 <EvilTerran> ie, "Net () -> Bot -> IO ()"
18:12:12 <EvilTerran> but "ask :: Net Bot", so we need a =<< in the Net monad to get the Bot out to pass to runReaderT
18:14:05 <noecksit> oh ok, i see, Net () is a synonym for "ReaderT Bot IO" and that is the return value of listen, and by that, runReaderT's initial argument is ReaderT Bot IO ()
18:14:59 <noecksit> thats cool, thank u very much
18:15:11 <geezusfreeek> :)
18:23:49 * EvilTerran wonders if there'd be sufficent utility in an "unReaderT m = runReaderT m =<< ask" to warrant trying to get it in the stdlibs
18:27:30 <ddarius> I suspect not.  I don't recall ever wanting it or anyone asking for it.
18:32:26 <khafra> There's no #functional, so I thought I'd ask here--javascript has some fairly functional features, but does it have a way to handle input and output in a purely functional manner?
18:34:45 <ddarius> No.
18:35:11 <EvilTerran> you could write such a thing, but you can't really enforce it
18:35:15 <EvilTerran> and it'd be brutally ugly
18:35:24 <ddarius> You could build something on top and discipline yourself to not use "impure" functions directly.
18:35:25 <EvilTerran> actually, there is a way - the javascript backend to YHC :P
18:35:55 <ddarius> You may be interested in flapjax
18:36:34 <EvilTerran> ... functional something asynchronous pseudo-javascript and xml?
18:36:54 <augur> khafra
18:36:59 <augur> purely functional in what sense?
18:37:25 <augur> i mean, there are no non-functional aspects to IO in JS.
18:38:30 <augur> ignoring things like DOM manipulation which i wouldnt consider IO
18:45:39 <khafra> Hrm. DOM manipulation it is! Which brings up a subtle subpoint: Is use of innerHTML morally upstanding?
18:46:52 <EvilTerran> i'd say it isn't, but it's probably sufficiently useful for that to outweigh the bacchian decadence it entails
18:46:55 <EvilTerran> :P
18:47:18 <augur> khafra: yes. using innerHTML is ok.
18:47:30 <augur> but not every browser has it
18:47:50 <EvilTerran> using the proper DOM manipulation functions will probably be significantly more verbose, but  more portable, and probably a bit faster too
18:47:53 <augur> and conversely, not every browser supports W3C standard DOM creation methods
18:48:08 <EvilTerran> plus they'd give you the moral high ground :P
18:48:12 <augur> innerHTML also doesnt let you manipulate an element cleanly before you insert it into the tree
18:49:02 <khafra> Yeah, document.fragment is a surer way to keep everything correct, but the shortcut of innerHTML is so gosh-darn tempting.
18:49:49 <khafra> Speaking of standards, I sure wish 1.6 and 1.7 were widely supported, so I could use all the array methods to which I've become accustomed.
18:49:50 <augur> the big javascript DOM manip libs use innerHTML all the time.
18:49:53 <augur> its not bad to use it.
18:50:14 <augur> which array methods?
18:51:04 <khafra> Oh, y'know.  map, for each in, fold, that sort of thing.
18:52:02 <Cale> Wasn't there someone in this channel who was working on the next Javascript?
18:52:03 <augur> ah. most of those are supported by FF and Saf
18:52:34 <ddarius> Cale: Probably.
18:53:16 <khafra> augur: Yup. I'd throw a few definitions in for them, but I like to stick to native features as much as possible.
18:53:42 <augur> why??
18:54:05 <augur> you define functions all the time in JS, so why not add these?
18:54:23 <augur> Array.prototype.map = Array.prototype.map || function(){ ... }
18:54:47 * khafra dithers
18:55:08 <augur> theres no harm in bootstrapping modern JS stuff onto older versions of JS
18:55:18 <tieTYT2> can someone help me?  On http://book.realworldhaskell.org/beta/deftypes.html search for "Shadowing"
18:55:19 <lambdabot> Title: Chapter 4. Defining Types, Streamlining Functions
18:55:28 <tieTYT2> is this first example ever worth doing?
18:55:41 <khafra> augur: Awright, I'm convinced :D Array.map away!
18:56:05 <augur> i suggest you refer to the MDC's reference implementation of map, etc.
18:56:19 <Cale> tieTYT2: hm? You mean relative to including both definitions in the same let?
18:56:24 <tieTYT2> yes
18:56:37 <Cale> There's no difference.
18:56:58 <tieTYT2> ok so you're saying: always define all local variables in a single let
18:57:20 <Cale> let a = 1 in let b = 2 in a + b  is exactly the same thing as  let {a = 1; b = 2} in a + b
18:57:28 <tieTYT2> i know
18:57:34 <tieTYT2> what i'm asking is if you'd ever want to do the former
18:57:44 <tieTYT2> or maybe you're saying, "Who cares"
18:57:48 <Cale> You usually wouldn't. I can't think of a good reason.
18:57:51 <roconnor> > let a = b in let b = 2 in a
18:57:55 <lambdabot>  b
18:58:02 <Cale> However, you might have a case inside a let, which contains another let
18:58:05 <roconnor> ha
18:58:22 <tieTYT2> Cale: why?
18:58:23 <Cale> Oh.
18:58:46 <tieTYT2> couldn't you do that in one let too?
18:58:51 <Cale> > let xs = 1 : ys in let ys = 2 : xs in xs
18:58:51 <lambdabot>   Not in scope: `ys'
18:58:56 <Cale> > let xs = 1 : ys; ys = 2 : xs in xs
18:58:58 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
18:59:03 <Cale> there is a difference :)
18:59:07 <roconnor>  > let {a = b; b = 2} in a
18:59:20 <roconnor> > let {a = b; b = 2} in a
18:59:22 <lambdabot>  2
18:59:49 <roconnor> well, Cale's example is better
19:00:01 <Cale> tieTYT2: Nested let blocks can't have definitions which are mutually recursive, but single let blocks can.
19:00:07 <EvilTerran> yeah, simplereflect isn't obfuscating things so much :P
19:00:30 <tieTYT2> i see
19:00:39 <tieTYT2> and you'd nest to prevent accidental errors?
19:01:04 <EvilTerran> i wouldn't bother, it seems an unlikely sort of error to make
19:01:10 <Cale> Well, usually we completely avoid shadowing variables.
19:01:19 <tieTYT2> ok so shadowing is considered bad?
19:01:40 <EvilTerran> yeah, it's generally just confusing for little benefit
19:01:42 <roconnor> for the most part shadowing is bad
19:01:50 <Cale> Yeah. Usually if I'm about to shadow a variable, I'll use a prime (') to differentiate between the different values.
19:01:51 <tieTYT2> k
19:01:52 <tieTYT2> thanks
19:02:18 <Cale> > let x = 1 in let x = 2 in x
19:02:19 <lambdabot>  2
19:02:22 <Cale> > let x = 1; x = 2 in x
19:02:23 <lambdabot>      Conflicting definitions for `x'
19:02:23 <lambdabot>     In the binding group for: x, x
19:03:51 <EvilTerran> > let x = [1] in let x = 2 : x in x -- beware, here be dragons
19:03:52 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
19:04:36 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
19:04:37 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
19:04:58 <vixey> very nice
19:05:26 <EvilTerran> ... that's another hazard of shadowing - in the definition that does the shadowing, that's the definition in scope, not the one being shadowed
19:05:37 <tieTYT2> ah
19:05:41 <tieTYT2> just learneda bout the where clause
19:05:44 <vixey> > let evens = 0 : map (+1) odds; odds = map (+1) evens in zip odds evens
19:05:45 <lambdabot>  [(1,0),(3,2),(5,4),(7,6),(9,8),(11,10),(13,12),(15,14),(17,16),(19,18),(21,2...
19:06:12 <dibblego> I'm the same as Cale; I'll use a prime'
19:06:58 <EvilTerran> likewise.
19:07:11 <dolio> Haskell performance tip: manually inlining stuff isn't always a good idea.
19:07:28 <SamB_XP> dolio: no freakin' duh
19:07:32 <SamB_XP> that's what INLINE is for
19:07:50 <tieTYT2> do haskell people normally care that much about performance?
19:07:56 <tieTYT2> i care more about maintanence
19:08:03 <SamB_XP> tieTYT: we would like to have SOME performance, yes ;-)
19:08:04 <dibblego> yes, we care about both
19:08:10 <tieTYT2> i hate that word
19:08:10 <tieTYT2> maintenance
19:08:45 <tieTYT2> well i don't consider them 50/50, i put preference over maintenance
19:08:46 <dolio> Well, I was doing a lot of stuff where I'd do 'do r <- m ; let foo = <stuff with r> ; foo ...', so that foo would have direct access to r.
19:09:17 <dibblego> tieTYT, so does Haskell (we usually resort to C when performance becomes critical)
19:09:19 <dolio> Because code like 'foo r ... = ... foo r ...' is slow.
19:09:22 <tsuwabuk_> print [1,2,3]
19:09:41 <tieTYT2> good
19:09:44 <dolio> But I bit the bullet and broke a lot of it up, and it actually gained me performance.
19:10:42 <SamB_XP> dolio: wouldn't the let be just as slow?
19:10:48 <SamB_XP> or worse?
19:11:25 <dolio> SamB_XP: Well, the secret is to write it as 'foo r = loop where loop ... = ... loop ...'.
19:11:30 <EvilTerran> it'd be more prone to space leaking...
19:11:42 <EvilTerran> (i think)
19:11:54 <dolio> I thought writing just 'loop' inline in the do block would be the same, but perhaps not.
19:12:37 <tieTYT2> can someone explain this sentence: Here might be a good chance to say that the difference between "let" and "where" is largely a matter of style, except that "let" is better at restricting the scope to one in a sequence of patterns whereas "where" applies to all patterns.
19:12:43 <tieTYT2> i don't understand what the scope content means
19:12:58 <vixey> where doesn't apply to all patterns
19:13:38 <vixey> foo False = x
19:13:39 <vixey> foo True = x + 1
19:13:39 <vixey>  where x = 3
19:13:45 <vixey> 1:12: Not in scope: `x'
19:13:46 <EvilTerran> > case [1,2,3] of { [] -> foo; x:xs -> x:foo } where foo = [4,5,6]
19:13:46 <lambdabot>  Parse error at "where" (column 46)
19:14:05 <EvilTerran> er
19:14:18 <EvilTerran> apparently not, even in case blocks
19:14:34 <ddarius> where scopes over guards
19:14:37 <tieTYT2> i donno what case/of are yet
19:14:40 <dolio> You can do 'f x | y == z = ... | y == j = ... where z = ...'
19:14:56 <tieTYT2> and first of all, by patterns you're talking about function pattern matching?
19:14:56 <EvilTerran> tieTYT2, if you have guards in a definition (or a branch of a case), definitions in the attached where block are visible across all branches of the guards
19:15:07 <dolio> 'let ... in ...' being an expression can only go inside one branch of the guards, of course.
19:15:16 <tieTYT2> dolio: ok i think i get it
19:15:26 <dolio> Can't really be used inside the guard, either, unless you're willing to write some truly massive guards.
19:15:44 <tieTYT2> where variables can be accessed anywhere in the function
19:16:01 <EvilTerran> it lets you have some definitions visible in the guards, but made with the variables from the pattern in scope
19:16:02 <dolio> Yeah, in a single clause.
19:16:02 <shapr> So, anyone in Boston want to come to a CHUG not this weekend, but the weekend after?
19:16:07 <tieTYT2> but with a let, you CAN put the let in, for example, a if/then so it's only accessible in the then and not the else
19:16:24 <dolio> So 'f pat1 = ... ; f pat2 = ...' is two clauses, so they each get their own where.
19:16:58 <tieTYT2> ok
19:17:05 <tieTYT2> you just taught me the definition of a clause too
19:17:22 <tieTYT2> so can I put a let anywhere an expression is expected?
19:17:30 <Cale> They don't each get their own 'where' keyword if you mean what I think you do...
19:17:35 <dolio> Yeah, let is an expression. 'let <defs> in <expr>' evaluates to the value of <expr> with the local definitions.
19:17:49 <Cale> Oh, I see what you're saying, yes
19:17:55 <tieTYT2> ok cool
19:18:11 <dolio> 'where' is a part of the syntax of definitions.
19:18:15 <Cale> Each clause has its own where for local definitions that scope over it.
19:18:22 <dolio> Right.
19:18:29 <tieTYT2> i see
19:18:39 <tieTYT2> ok thanks
19:18:53 <tieTYT2> do people usually use lets?
19:18:59 <tieTYT2> i don't see many here use where's
19:18:59 <EvilTerran> usually wheres, i find
19:19:02 <tieTYT2> oh
19:19:03 <Cale> Sure, I use let.
19:19:15 <Cale> I also use where quite often :)
19:19:24 <EvilTerran> although let is more often useful in lambdabot, as she evalutes expressions rather than definitions
19:19:27 <dolio> So a definition is something like, 'defn ::= <name> <args> = <expr> [where <defns>]'
19:19:33 <Cale> You'll see a lot more 'let' around here, because lambdabot wants an expression.
19:19:40 <dolio> With some stuff in there for guards, too, but you get the idea.
19:19:44 <tieTYT2> oh that may explain it
19:19:51 <tieTYT2> ok i gotta go now
19:19:52 <tieTYT2> ttyl
19:20:31 <dibblego> seeya tieTYT
19:22:08 <chessguy> @src on
19:22:09 <lambdabot> (*) `on` f = \x y -> f x * f y
19:24:12 <chessguy> @pl \x y n -> n >= abs (x-y)
19:24:12 <lambdabot> ((flip (>=) . abs) .) . (-)
19:24:16 <chessguy> whee
19:24:17 <vixey> on is like the BEST combinator
19:24:19 <edwardk> @seen ddarius
19:24:19 <lambdabot> ddarius is in #haskell, #haskell-blah, #haskell-overflow and #haskell-soc. I last heard ddarius speak 9m 46s ago.
19:24:34 <orbitz> ddarius is a bit of a haskell whore
19:24:46 <edwardk> ?
19:24:57 <orbitz> 4 haskell channels
19:25:00 <orbitz> get that boy a condom
19:25:26 <edwardk> are you saying his polychannelry is out of control?
19:25:32 <orbitz> yes
19:25:36 <roconnor> chandom
19:25:39 <hpaste>  (anonymous) annotated "WGET" with "(no title)" at http://hpaste.org/7672#a5
19:25:42 <orbitz> specially his haskkell pollychanary
19:26:01 <orbitz> but i'm refusing to call it haskell from now on. i'm calling it haskull
19:26:09 <edwardk> i wanted to pick his brain regarding indexed (co)limits
19:26:10 <orbitz> and a skull and lambda crossbones is my logo
19:26:13 <orbitz> who' with me?!
19:26:24 <edwardk> crossed lambdas?
19:26:33 <hpaste>  dragos pasted "wget" at http://hpaste.org/7782
19:26:34 <orbitz> a lambda made of bones
19:27:15 <edwardk> snap one off to get the lambda shape?
19:27:24 <orbitz> yup
19:27:32 <chessguy> orbitz: are you causing problems again
19:27:37 <augur> orbitz, i'd like to book a trip to maui
19:27:37 <orbitz> Haskull isn't for functional langage pansies
19:27:41 <orbitz> chessguy: again? i'm not sure i stopped
19:27:58 <chessguy> for once, i must agree
19:28:07 <orbitz> augur: ok, I've booked you a ticket to lameville at the "heard that one 10 million times" hotel
19:28:36 <SamB_XP> orbitz: haskull, does that have the MagicHash extension enabled by default?
19:28:40 <augur> noone made you use that nick. so you forfeited the right to bitch. :P
19:29:02 <orbitz> i had it before the company!  not my fault those cock goblins have good taste in names
19:29:07 * SamB_XP drinks orbitz 
19:29:12 * SamB_XP says "ewww"!
19:29:17 <augur> i liked that drink
19:29:17 <augur> :|
19:29:33 <SamB_XP> I only tried one of the flavours
19:29:46 <augur> well you're a lameface. :P
19:29:57 <SamB_XP> but I betcha it was one of the better ones, after reading the reviews on that site that orbitz linked to a while back in ##c
19:30:03 <orbitz> if you play your cards right you might get a try at a third flavor tonight
19:30:13 <augur> whoa now
19:30:35 <SamB_XP> orbitz: ... whoa, what? I haven't actually tried a second flavour!
19:30:44 <SamB_XP> IRC eating doesn't actually count
19:31:04 <SamB_XP> or drinking
19:31:41 <augur> sam: it was a euphemism.
19:31:49 <augur> he means he's going to ejaculate into your mouth.
19:32:05 <SamB_XP> augur: but orbitz claims to be female
19:32:17 <augur> ok, SHE'S going to ejaculate into your mouth.
19:32:46 <SamB_XP> augur: that, and I don't get why it's a THIRD flavour
19:32:52 <SamB_XP> rather than a second
19:32:56 <augur> magic, that's why.
19:33:05 <chessguy> uh, how about we keep it family-friendly. this is not ##c++ after all
19:33:11 <orbitz> maybe not ejaculate
19:33:14 <orbitz> i could just let you go down on me
19:33:18 <orbitz> front and rear = 2 flavors
19:33:24 <augur> this is family friendly.
19:33:34 <augur> i said ejaculate not some vulgar term.
19:33:34 <augur> :P
19:33:57 <SamB_XP> augur: it's sexually explicit language though
19:34:05 <SamB_XP> of course, they also do that in bio textbooks...
19:34:13 <augur> sex is a natural part of life.
19:34:27 <wolgo> Wow
19:34:29 <Cale> http://reddit.com/r/programming/info/6k66h/comments
19:34:42 <wolgo> I wish I would have found this when I was a kid
19:34:44 <augur> wolgo didnt know that sex was natural.
19:34:50 <wolgo> I would have been in a lot less trouble
19:34:55 <wolgo> hahah
19:35:03 <SamB_XP> wolgo: found what?
19:35:21 <augur> the word "ejaculate
19:35:31 <wolgo> This language.
19:35:35 <augur> english?
19:35:37 <SamB_XP> Haskell?
19:35:40 <orbitz> augur: what i said is natural too!
19:35:43 <wolgo> Yes Haskell.
19:35:47 <orbitz> forelay is very natural
19:35:56 <Cale> Please try to stay on topic.
19:35:58 <SamB_XP> ... how would Haskell have kept you out of trouble?
19:35:58 <orbitz> SamB_XP: Haskull
19:36:00 <augur> wolgo got spanked for coding in C++
19:36:00 <Cale> This channel is about Haskell.
19:36:12 <SamB_XP> would it have prevented you from looking at so much porn?
19:36:20 <augur> haskell IS porn.
19:36:34 * SamB_XP isn't teasing wolgo, is serious question!
19:36:40 <Cale> (and I will start kicking people if this discussion doesn't move elsewhere ;)
19:36:52 <wolgo> No, it would have prevented me from spending too much time playing street fighter 2
19:37:05 <SamB_XP> wolgo: that was my second guess
19:37:06 <edwardk> wb: dolio
19:37:18 <orbitz> the topic is Haskull, discuss
19:37:21 <dolio> Thankee.
19:37:26 <SamB_XP> games, I mean, not specifically SF2
19:37:27 <augur> wolgo spent his youth getting in trouble with the authorities in the street fighter universe
19:37:28 * Cale posted edwardk's recent blog post to the programming reddit
19:37:36 <edwardk> cale: what did you think?
19:37:39 <wolgo> I am looking forward to learning more about this language
19:37:39 <augur> cale's link didn't work.
19:37:48 <orbitz> worked here
19:37:59 <SamB_XP> wolgo: so when were you a kid?
19:38:02 <augur> there are no results here
19:38:03 <Cale> edwardk: It looks rather cool :)
19:38:05 <augur> is what it says
19:38:21 <edwardk> i wanted to add indexed (co)limits, but i didn't get around to it
19:38:24 <wolgo> I was a kid about 15 years ago
19:38:30 * wolgo is 28
19:38:36 <SamB_XP> note that I've been in "computer savings time" for pretty much my entire life, so video games don't tell me that
19:38:50 <orbitz> wolgo: legally
19:38:53 <edwardk> cale; you'll notice i used the partially applied type alias trick you mentioned ;)
19:39:11 <wolgo> brb going to participate in the awesome mmorpg called "Outside"!
19:39:30 <SamB_XP> I assume the "O" stands for "outdoor" or "offline"?
19:39:39 <wolgo> haha
19:39:40 <wolgo> yeah
19:39:43 <wolgo> outdoor
19:41:01 <SamB_XP> hmm, my sister thinks the R should stand for "running"
19:41:02 <edwardk> cale: i've been looking for other practical uses of kan extensions. i tripped over the monad generated by a functor bit when i was working up some llvm bindings (before i found that lennart and bos already had them, so it seems to come up a lot)
19:41:15 <Cale> edwardk: I did have to adjust my browser settings to read some of the code properly though -- if the font size is large enough, the text gets cut off underneath your sidebar.
19:41:16 <dejones> Cale: what is edwardk's blog post?  link?
19:41:26 <Cale> http://reddit.com/r/programming/info/6k66h/comments
19:41:32 <Cale> http://comonad.com/reader/2008/kan-extensions/
19:41:32 <edwardk> http://comonad.com/reader/2008/kan-extensions/
19:41:34 <lambdabot> Title: The Comonad.Reader  Kan Extensions
19:41:35 <lambdabot> Title: The Comonad.Reader  Kan Extensions
19:41:38 <edwardk> i'll tweak the examples
19:41:48 <SamB_XP> @quote c-a-l-e
19:41:49 <lambdabot> No quotes match. I feel much better now.
19:41:56 <SamB_XP> Cale: I bet you are so happy!
19:42:06 <Cale> SamB_XP: heh
19:42:22 <SamB_XP> lambdabot has finally forgotten ALL about that quote
19:42:32 <dejones> Cale: Complex stuff, eh?
19:42:36 <edwardk> cale: better?
19:43:01 <edwardk> dejones: its not all that complicated, just a type most people haven't seen in haskell before and a bunch of applications of it
19:43:02 <Cale> yeah, that's better
19:43:19 <edwardk> if any are still being cut off lemme know
19:43:35 <dejones> edwardk: Hmm, I doubt I am going to understand it very well since I don't completely understand the theory behind Monads or Functors.
19:43:53 <Cale> Nope, that's good at least at my default settings.
19:44:47 <dejones> edwardk: But, the code does look fine for my browser / screen settings.  :)
19:46:05 <dejones> edwardk: Yep, I need to understand Monads and Functors better before your post will make much sense to me.
19:46:33 <dolio> Interestingly enough, all that stuff about Ran being a functor/monad independent of what it's parameterized by applies to ContT, as well.
19:46:33 <edwardk> dejones: no problem. if you have any questions about them, feel free to ask.
19:46:50 <edwardk> dolio: yep. ContT really doesn't care about the monad.
19:46:58 <edwardk> ContT = Cont modulo types
19:46:58 <dejones> edwardk: can you suggest a good paper or document to read about Monads and Functors?
19:47:02 <dolio> The only thing it needs it for is lift.
19:47:35 <dolio> So the mtl instances are, technically, overly restrictive.
19:47:56 <edwardk> dejones: hrm i learned from the all about monads tutorial for the most part. that and reading a bunch of the early wadler papers to get a feel for the motivation behind them
19:48:06 <dejones> edwardk: do you think this is sufficient?  http://en.wikibooks.org/wiki/Programming:Haskell_monads
19:48:30 <Cale> edwardk: So when you say that the monad Ran f f doesn't care that f is a functor, are you implying that one can prove the monad laws for Ran f f without using the functor laws for f?
19:48:37 <edwardk> dejones: http://www.haskell.org/all_about_monads/html/index.html
19:48:37 <lambdabot> Title: All About Monads
19:48:50 <Cale> er, hmm...
19:48:51 <edwardk> cale: yep. you only need that f has kind * -> * to make the types work.
19:48:55 <Cale> I suppose it doesn't use fmap
19:49:00 <Cale> right
19:49:04 <Cale> That's interesting.
19:49:09 <ddarius> edwardk: What's up?
19:49:20 <dejones> edwardk: Thanks -- All About Monads seems packed with info!  :)
19:50:22 <SamB_XP> Cale: clearly the Functor laws don't come into play when fmap is unused
19:50:25 <edwardk> most of the Ran and Lan stuff doesn't care about validity as a haskell functor. I left out of the post the bits about natural transformations and to{L|R}an/from{L|R}an because it adds a lot of noise and not much understanding
19:50:39 <Cale> SamB_XP: right. I just noticed that after asking.
19:51:05 <edwardk> ddarius: posted up a bit about left and right kan extensions, was going to try to play with indexed limits which i know are your favorite toy, but haven't really figured out how to type them correctly in haskell.
19:51:35 <Cale> dejones: If you're interested in the theoretical background, I recommend reading the wikipedia articles for the definition of a category and functor, and then perhaps watching some of The Catsters' videos here: http://www.youtube.com/profile_play_list?user=TheCatsters
19:51:36 <lambdabot> Title: YouTube - TheCatsters's Playlists
19:51:54 <Cale> (start with the section on natural transformations)
19:52:41 <dejones> Cale: Thanks.  I like the theory stuff.  :)
19:52:45 <Cale> Eugenia also has some good introductory notes on category theory on her website, let me get a link.
19:53:13 <Cale> http://www.math.uchicago.edu/~eugenia/catnotes/categorynotes-cheng.pdf
19:53:14 <lambdabot> http://tinyurl.com/28sclm
19:53:57 <ddarius> Cripes.  Why is my crap changing on me?
19:54:12 <SamB_XP> ddarius: dietary changes?
19:54:35 <agentzh> hi, i saw the following line in Parsec's source: data SourcePos  = SourcePos SourceName !Line !Column
19:54:43 <agentzh> what does the prefix ! do?
19:54:52 <agentzh> i haven't seen it elsewhere yet :P
19:55:06 <Cale> agentzh: It means that whenever the constructor is pattern matched, the fields will be evaluated immediately.
19:55:12 <dejones> Cale: Is Eugenia the same girl that does the youtube videos?
19:55:12 <dibblego> agentzh, it is a strictness annotation; makes the argument into weak head normal form
19:55:15 <Cale> dejones: yeah
19:55:22 <dejones> Cale: I knew I recognized her!
19:55:22 <dejones> :)
19:55:26 <Cale> http://www.cheng.staff.shef.ac.uk/
19:55:27 <lambdabot> Title: Eugenia Cheng
19:55:50 <agentzh> Cale, dibblego: thanks :)
19:56:32 <Cale> agentzh: Basically, it prevents expressions from hanging around unevaluated in those fields.
19:56:50 <agentzh> Cale: to defeat laziness?
19:56:54 <Cale> yeah
19:56:58 <agentzh> got it :)
19:57:07 <ddarius> edwardk: I'm not registered.  Anyway, indexed (co)limits are special cases of Kan extensions, so...
20:00:53 <edwardk> ddarius: that much i got, i'm just looking for the right way to describe them in types. i have newtype Ran g h a = Ran { runRan :: forall b. (a -> g b) -> h b } for right kan extensions, just trying to figure out what a useful view is of indexed (co)limits.
20:01:05 <ddarius> edwardk: Also, since all our Functors are over "set" (Hask), {F,G} is just type IndexedLimit f g = forall a. f a -> g a
20:01:42 <edwardk> ddarius: so it looks just like a natural transformation in the type system.
20:02:06 <hpaste>  dibblego pasted "cabal install lambdabot" at http://hpaste.org/7783
20:02:07 <edwardk> i got that, then figured i must be doing something wrong because it collapsed to just a natural transformation.
20:02:09 <ddarius> edwardk: It -is- just a natural transformation.
20:02:14 <edwardk> lol
20:03:25 <tsuwabuk_> (flip (!!)) 10000 $ map head . iterate (\s -> [x | x <- tail s, x `mod` (head s) /= 0]) $ 2:[3,5..]
20:03:41 <edwardk> hrmm, ok, now to make them do some real work for me =)
20:03:56 <tsuwabuk_> > (flip (!!)) 10000 $ map head . iterate (\s -> [x | x <- tail s, x `mod` (head s) /= 0]) $ 2:[3,5..]
20:04:06 <lambdabot>  Exception: Time limit exceeded
20:04:24 <ddarius> edwardk: Unfortunately, Kan extensions and indexed colimits really benefit from being able to use functors from/to other categories.
20:04:53 <edwardk> yeah, so in haskell, since i can only see the way objects and morphisms in haskell play out i get no real power out of it
20:06:01 <ddarius> edwardk: There should be some results that produce interesting things/relationships in Haskell, but the constructs themselves are much less useful.
20:06:47 <ddarius> Having -x= be Ran_! where ! : 1 -> 1+1 is very pretty, but you can't do that in Haskell (at least without reifying many things much more)
20:07:58 <ddarius> (er switch 1 and 1+1
20:08:38 <ddarius> )
20:09:53 <edwardk> ah, btw- was going to say something re your sampler, you said in there F -| U <=> -U -| -F, but all i could work out was that if F -| U, G -| V then FG -| VU which is just the composition of adjunctions. did i misparse what you wrote?
20:11:16 <edwardk> or basically: instance (Adjunction f1 g1, Adjunction f2 g2) => Adjunction (CompF f2 f1) (CompF g1 g2) where counit = counit . fmap (counit . fmap decompose) . decompose; unit = ...
20:11:16 <edwardk>         
20:13:10 <edwardk> also on p7 of the sampler, is the definition for ! flipped?
20:13:45 <ddarius> What was intended was: F -| U <=> \H.H o U -| \K.K o F if that's clearer.
20:14:08 <ddarius> edwardk: Yes it is.
20:14:10 <edwardk> should we take this off to a smaller channel?
20:14:14 <ddarius> Same mistake I made above actually.
20:14:27 <edwardk> ok, good. then i don't feel bad that i worked out the opposite =)
20:15:43 <edwardk> i've had trouble following a few of the uses of lambdas in your write up. probably reader error, its very dense stuff.
20:16:20 <ddarius> edwardk: Nah, some of it can be very ambiguous as I warn at the beginning.
20:16:49 <edwardk> yeah the pacing goes in fits and starts. i can read along for half a page then stop cold for half an hour on a sentence.
20:18:08 <edwardk> but its been a great way to kickstart me into thinking about certain questions. i've been reading along with this and a 2-category companion by stephen lack for the last couple of days because i've been stuck home sick with not much else to do
20:18:17 <edwardk> er at home sick
20:18:52 <edwardk> so in short when you write {F,G} i can just parse that as forall a. F a -> G a ?
20:19:18 <ddarius> G over "Set", yes.
20:19:32 <edwardk> yeah with that caveat of course.
20:19:51 <ddarius> That is one of the early results introduced for indexed limits.
20:19:51 <edwardk> and F*G?
20:19:52 <Nyenburgh> good day all
20:20:21 <mxc> good dya, so getting a strange error
20:20:41 <edwardk> ddarius: i'm still wrestling a bit with your prose. i mostly have been pattern matching out understanding as well as I can. Its hard to do from first principles.
20:20:43 <mxc> where a compiled piece of haskell code, call it Main.exe does some processing and spits out the following:
20:20:50 <mxc> "Main.exe: <<loop>>"
20:21:04 <mxc> there's nothing in my code that could possibly generate that
20:21:17 <edwardk> mxc: ghc was able to detect an infinite loop you were causing and stop.
20:23:32 <ddarius> edwardk: Some of the wording is just horrible and I still need to format most of it.
20:23:34 <mxc> is there a simple way to get it to spit out the function thats looping ?
20:24:20 <edwardk> ddarius: no problem. its forcing me to look up the material to try to substantiate most of the results. I'm using it mostly like a set of cribbed notes taken from someone else.
20:24:31 <ddarius> mxc: Try compiling with profiling and using -xc.  Check the GHC user manual for details.
20:24:39 <mxc> ty
20:24:59 <ddarius> edwardk: Yeah, you may want to ignore the proofs and rederive them yourself.
20:26:06 <ddarius> I was considering a minute ago moving the proofs to an appendix at the end, but the proof style is one of the purposes of it.
20:26:51 <edwardk> ddarius: still not sure how to parse the -U -| -F , am i off by a level of types instead of * -> *, (* -> *) -> * -> * ?
20:27:34 <edwardk> er that much i guess of course i am
20:28:54 <trontonic> This boggles my mind. Kudos to anyone who understands it straight away. :) http://comonad.com/reader/2008/kan-extensions/
20:28:56 <lambdabot> Title: The Comonad.Reader  Kan Extensions
20:29:11 <edwardk> trontronic: so far so good here =)
20:29:27 <trontonic> edwardk: well... kudos :)
20:29:41 <trontonic> edwardk: I'm not well enough versed in Haskell and that type of maths yet :)
20:29:48 <edwardk> trontonic: might help that i wrote it though i guess
20:29:58 <trontonic> edwardk: :D
20:30:18 <trontonic> edwardk: Well, thanks for writing it. I'm glad the web is filled with interesting mind-teasers ;)
20:30:27 <ddarius> If U : C -> D then -U would be [D,E] -> [C,D] where [C,D] is the category of functors from C to D.
20:31:16 <edwardk> ddarius: aha! now it parses.
20:31:37 <trontonic> edwardk: your article is pretty high up reddit.com/r/programming, btw :)
20:32:02 <edwardk> ddarius: then i should be able to make a 'higher order functor' instance and define a 'higher order adjunction' that way. using my existing type classes.
20:33:31 <ddarius> I guess [D,E] should be [D,C] since -F will be have the opposite type.
20:34:20 <edwardk> in my case C=D=E=Hask so its all good ;)
20:37:52 <chessguy> @type liftM2
20:37:54 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
20:38:06 <chessguy> @type liftM2 (/=)
20:38:08 <lambdabot> forall a1 (m :: * -> *). (Monad m, Eq a1) => m a1 -> m a1 -> m Bool
20:38:33 * edwardk chuckles. of course jerf had to post a negative bit on the kan extensions article, if only coz its about haskell and obscure types ;)
20:39:15 <dolio> Is he someone I should have heard of?
20:39:23 <edwardk> ddarius: just wish that the -F stuff had the types the other way around then I could just use my built-in CompH type =)
20:40:04 <edwardk> dolio: He worked with/for me a few years back at an ISP back in my CTO days.
20:40:13 <SamB_XP> so how did the category come to be called Hask?
20:40:17 <chessguy> > liftM2 (/=) (Just 2) Nothing
20:40:18 <lambdabot>  Nothing
20:40:24 <edwardk> I think ndm started it
20:40:24 <SamB_XP> (and how does Hask differ from Haskell?)
20:40:33 <orbitz> SamB_XP: haskull
20:40:41 <orbitz> where does the 'cast' function come from?
20:40:45 <orbitz> @src cast
20:40:46 <lambdabot> Source not found. There are some things that I just don't know.
20:40:48 <dolio> Haskell is a programming language, and Hask is (allegedly) a category?
20:40:48 <SamB_XP> @hoogle cast
20:40:49 <lambdabot> Data.Typeable.cast :: (Typeable a, Typeable b) => a -> Maybe b
20:40:49 <lambdabot> Foreign.StablePtr.castStablePtrToPtr :: StablePtr a -> Ptr ()
20:40:49 <lambdabot> Foreign.StablePtr.castPtrToStablePtr :: Ptr () -> StablePtr a
20:40:53 <edwardk> it just follows the naming conventions of the category theory community. it writes succinctly on a blackboard.
20:40:56 <orbitz> oh typeable
20:41:09 <edwardk> just like Ab instead of Abelian.
20:41:31 <SamB_XP> edwardk: is there only one Abelian thing?
20:41:42 <edwardk> Hask is also slightly idealized. I don't think most people consider it to include seq, etc.
20:42:00 <SamB_XP> what do they call Galois Field Hockey?
20:42:06 <chessguy> leave it to category theory to be concerned with how well it writes on a blackboard :)
20:42:14 <edwardk> samb: yeah Ab is the category of abelian groups and group homomorphisms.
20:42:16 <SamB_XP> edwardk: I suspected that that was omitted
20:42:26 <ddarius> chessguy: That's mathematics, not CT.
20:42:42 <chessguy> but CT is quintessential mathematics
20:42:46 <chessguy> @quote category
20:42:46 <lambdabot> bos says: it looks like an interesting book, although i find the idea that software engineers might be ready for category theory this side of the 22nd century charmingly naive
20:42:47 <agentzh> hmm, parsec 3.0.0 seems to have performance issues. my sql compiler slows down significantly (from 2.7 sec to 3.8 sec) when upgraded from parsec 2.1.0 to 3.0.0 :((
20:42:56 <SamB_XP> chessguy: quintessential in what sense?
20:43:10 <orbitz> does cast let you actualy cast an object to something or is it ony the identity type?
20:43:27 <edwardk> lol
20:43:29 <ddarius> agentzh: That's known.  parsec3 significantly generalizes parsec2 and hasn't yet been performanced tuned at all.
20:43:32 <SamB_XP> orbitz: it only lets you cast an object to the dynamically same type
20:43:40 <chessguy> SamB_XP: it's all about speaking precisely, proving and using theorems, etc.
20:43:42 <agentzh> ddarius: thanks for the info :)
20:43:56 <orbitz> SamB_XP: what is 'dynaically same type'?
20:44:02 <edwardk> the funny thing is i was more pleased with the results of the Elgot coalgebra post than I was of the Kan extension post, but no one even seemed to notice that one.
20:44:06 <clanehin> I wonder if there is a portable way to get the number of CPUs on a system to pass to +RTS -N
20:44:25 <SamB_XP> orbitz: it means the compiler doesn't know that the types are the same, but Dynamic checks that they have the same TypeRep
20:44:39 <SamB_XP> at runtime, you know?
20:44:55 <SamB_XP> like in those "dynamic" languages, or Java, or what-have-you
20:45:12 <edwardk> then again i guess a lot more people have heard of kan extensions without having a lifeline to hold onto
20:45:17 <mxc> clanehin - you could distribute dual quad-core machines with your software, then just need +RTS -8 no matter what
20:45:34 <mxc> other than that, can't help
20:46:04 <SamB_XP> clanehin: include in the README directions to change the number in the shell script
20:46:06 <orbitz> SamB_XP: do you have a useful example?
20:46:11 <SamB_XP> that is portable, but not reliable
20:46:17 <chessguy> @pl@type \x y -> isJust y && x /= y
20:46:17 <lambdabot> Unknown command, try @list
20:46:33 <chessguy> @type \x y -> isJust y && x /= y
20:46:35 <lambdabot> forall a. (Eq a) => Maybe a -> Maybe a -> Bool
20:46:36 <clanehin> mxc: Maybe not.
20:46:51 <edwardk> oh, ddarius, i'm still trying to figure out what f * g translates to in Hask.
20:46:54 <chessguy> @pl \x y -> isJust y && x /= y
20:46:54 <lambdabot> liftM2 (&&) isJust . (/=)
20:47:06 <mxc> :)
20:47:15 <clanehin> SamB_XP: Worst case, I read from /proc/cpuinfo on linux and sysctl on BSD, which I don't have installed to test . . .
20:47:23 <edwardk> f * Y ~= f gives me a bit of an insight, but hasn't fixed it for me
20:47:51 <chessguy> @type liftM2
20:47:52 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
20:49:22 <chessguy> @pl \x y -> (isJust y) && (x /= y)
20:49:22 <lambdabot> liftM2 (&&) isJust . (/=)
20:49:25 <SamB_XP> clanehin: and include in the readme instructions for anyone else?
20:49:28 <chessguy> huh.
20:49:38 <chessguy> is that right?
20:49:46 <clanehin> SamB_XP: I guess so . . .
20:50:22 <edwardk> in Hask then, I have Y :: ( * -> *) -> * -> *, and f : * -> *, then f * Y = Y f ~= f works but that definition doesn't work for F * G ~ G * F for set valued G, so i'm a bit at a loss.
20:50:56 <chessguy> @type liftM2 ((&&) isJust . (/=))
20:50:57 <lambdabot>     Couldn't match expected type `Bool'
20:50:57 <lambdabot>            against inferred type `Maybe a -> Bool'
20:50:57 <lambdabot>     In the first argument of `(&&)', namely `isJust'
20:51:36 <chessguy> @type liftM2 ((&&) isJust) . (/=)
20:51:38 <lambdabot>     Couldn't match expected type `Bool'
20:51:38 <lambdabot>            against inferred type `Maybe a -> Bool'
20:51:38 <lambdabot>     In the first argument of `(&&)', namely `isJust'
20:52:06 <swidgy> @type liftM2 (&&) isJust . (/=)
20:52:08 <lambdabot> forall a. (Eq a) => Maybe a -> Maybe a -> Bool
20:52:32 <chessguy> swidgy: yeah, but my brain can't parse that. what's getting lifted, and what's getting composed
20:52:58 <swidgy> kinda spiffy.  the maybe monad is abstracting the short circuiting of the logical operator
20:53:41 <edwardk> Hom(F*G,-)~= {F, Hom(G,-)} = forall a. F Hom(G,a) ? or am i misparsing the - again?
20:53:43 <chessguy> i understand what its doing, i just can't figure out how it's doing it
20:54:10 <orbitz> chessguy: magix
20:54:28 <chessguy> orbitz: go start a travel agency or something
20:55:16 <orbitz> chessguy: next?
20:55:36 <ddarius> edwardk: That is somewhat an exception.  Hom(F*G,-) ~ Nat(F,Hom(G,-)) = forall a. Hom(Fa, Hom(Ga,-))
20:55:41 <orbitz> chessguy: go play some matheamticaly solved game or something
20:56:04 <chessguy> oh wait
20:56:18 <vixey> guys
20:56:23 <chessguy> @type *liftM2 (&&)) isJust . (/=)
20:56:25 <lambdabot> parse error on input `*'
20:56:28 <chessguy> bah
20:56:43 <chessguy> @type (liftM2 (&&)) isJust . (/=)
20:56:45 <lambdabot> forall a. (Eq a) => Maybe a -> Maybe a -> Bool
20:57:59 <chessguy> > Just 3 /= Just 2
20:58:00 <lambdabot>  True
20:58:07 <chessguy> ...
20:58:23 * chessguy is not getting it
20:58:56 <vixey> :t (liftM2 (&&)) isJust
20:58:58 <lambdabot> forall a. (Maybe a -> Bool) -> Maybe a -> Bool
20:58:59 <edwardk> ddarius: so transliterating to Hask phi :: ((f*g) a -> b) -> f a -> g a -> b and phi^-1 :: (f a -> g a -> b) -> (f * g) a -> b ?
20:59:31 <ddarius> I think that's right.
20:59:50 <ddarius> Only, f*g is a type not a type constructor.
20:59:55 <chessguy> :t ((liftM2 (&&)) isJust) . (/=)
20:59:56 <lambdabot> forall a. (Eq a) => Maybe a -> Maybe a -> Bool
21:00:00 <chessguy> oh!
21:00:10 <edwardk> got it its basically like currying and uncurrying functors?
21:00:39 <edwardk> *nods*
21:00:51 <chessguy> nope, still don't get it
21:00:52 <chessguy> huh
21:00:57 <edwardk> mostly just trying to figure out how to say it in haskell in an understandable form.
21:01:09 <ddarius> Well, there's also the issue that f should be contravariant.
21:01:13 <vixey> :t \x -> ((liftM2 (&&)) isJust) (x /=)
21:01:14 <swidgy> it's the ((->) r) monad
21:01:15 <lambdabot> forall a. (Eq a) => Maybe a -> Maybe a -> Bool
21:01:28 <swidgy> which liftA2 should work as well
21:01:32 <vixey> :t \x -> (liftM2 (&&)) isJust (x /=)
21:01:33 <swidgy> @type liftA2 (&&) isJust . (/=)
21:01:35 <lambdabot> forall a. (Eq a) => Maybe a -> Maybe a -> Bool
21:01:36 <lambdabot> forall a. (Eq a) => Maybe a -> Maybe a -> Bool
21:01:39 <swidgy> yep
21:01:47 <chessguy> oh, no wonder. that always screws me up
21:02:01 <solrize> @seen edwardk
21:02:01 <lambdabot> edwardk is in #haskell-blah and #haskell. I last heard edwardk speak 1m 5s ago.
21:02:06 <chessguy> there's a hidden monad
21:02:18 <edwardk> so phi :: ContraFunctor f => (Lift (,) f g a -> b) -> f a -> g a -> b
21:02:21 <edwardk> heya solrize
21:02:23 <ddarius> phi^-1 :: (forall a. f a -> g a -> b) -> (f * g) -> b
21:02:42 <edwardk> hrmm, what does f * g do with the a?
21:02:52 <solrize> hey edwardk.  i was just looking at your post about kan extensions and was wondering if maclane's book was still worth reading.  it's a really old book iirc
21:02:55 <edwardk> it boxed up in the type somehow?
21:03:15 <ddarius> solrize: Definitely.
21:03:19 <edwardk> solrize: its old, but its a great starting point. you can't get much better than the guy who founded the discipline
21:03:37 <ddarius> solrize: You can find most of the information online spread about, but it's a very nice introduction.
21:03:40 <solrize> ddarius, edwardk, thanks, i may try to get hold of a copy.
21:03:41 <edwardk> especialy since unlike most areas of math it hasn't drifted far notationally from its origins
21:04:05 <ddarius> solrize: I got a used paperback copy from some online bookstore for about 25 dollars (US)
21:04:27 <solrize> ddarius, i'm an even bigger cheapskate than that, i'll probably get it from the library :)
21:04:31 <lokathor> in the case of a deck of normal cards, if i have an enum for all suits, and an enum for all ranks, and a card is something like "data Card = Card Rank Suit deriving (Show, Eq)", is there a concise way to define a list that contains all cards?
21:05:29 <bd_> lokathor: [ Card r s | r <- [minBound..maxBound], s <- [minBound..maxBound] ]
21:05:31 <ddarius> solrize: If you can (and if it's a university library, you probably can) then that's fine.
21:05:34 <bd_> @hoogle Enum x => [x]
21:05:35 <lambdabot> Prelude.repeat :: a -> [a]
21:05:35 <lambdabot> Data.List.repeat :: a -> [a]
21:05:35 <lambdabot> Prelude.tail :: [a] -> [a]
21:05:39 <bd_> @hoogle Enum x, Bounded x => [x]
21:05:40 <lambdabot> Prelude.repeat :: a -> [a]
21:05:40 <lambdabot> Data.List.repeat :: a -> [a]
21:05:40 <lambdabot> Prelude.tail :: [a] -> [a]
21:05:58 <bd_> lokathor: you'll need to derive Bounded for Rank and Suit as well
21:06:11 <edwardk> so we just call f * g the indexed colimit of g by f or am i slightly off?
21:06:14 <bd_> (or manually insert the appropriate constructor)
21:06:41 <solrize> before i got interested in haskell i paid no attention to categories b/c i thought they existed mainly to have something for the collection of all sets to live inside of
21:07:00 <lokathor> okay, so then it'll just loop the suits over and over until it's out of ranks?
21:07:05 <edwardk> solrize: heh, likewise. now i wish i hadn't wasted my math degree on all that geometry ;)
21:07:16 <bd_> lokathor: basically. You can reverse the two <- clauses to transpose the order
21:07:21 <solrize> anyway i don't have direct access to a university library, but my local public library is linked up with several of them and can get books from them
21:07:27 <lokathor> very cool
21:07:42 <bd_> lokathor: note that this is basically a use of the list monad; that's the same as:  do { r <- [minBound..maxBound]; s <- [minBound..maxBound]; return $ Card r s }
21:08:07 <bd_> Unfortunately(?), list comprehensions only work on the List monad :)
21:08:28 <solrize> but, it really does seem to me that categories make haskell easier to understand
21:09:39 <lokathor> makes sense. would the resulting list be infinite by default? would i then do " take 52 [ Card r s | r <- [minBound..maxBound], s <- [minBound..maxBound] ]"
21:10:03 <edwardk> solrize: and vice versa
21:10:08 <solrize> yeah :)
21:10:08 <swidgy> lokathor: it's finite
21:10:13 <vixey> > 7*13
21:10:14 <lambdabot>  91
21:10:15 <vixey> > 4*13
21:10:17 <lambdabot>  52
21:10:25 <bd_> lokathor: The list is finite, since it's a product of finite lists
21:10:28 <vixey> It'll be exactly 52 long
21:10:39 <vixey> since there's 4 ranks and 13 suits
21:10:40 <lokathor> okay. Many thanks bd and swidgy
21:11:24 <ddarius> edwardk: If (exists a. f a) -> b ~ forall a. f a -> b then type IndexedColimit f g = exists a. (f a, g a) maybe ?
21:12:04 <dolio> Well, my heap sort seems to beat the STL heap sort on random data, but it gets crushed on the cases that matter.
21:12:13 <ddarius> It seems appropriately dual to IndexedLimit, but there are sticking points that I'm not sure about.
21:12:47 <edwardk> data IndexedColimit f g = forall a. IndexedColimit (f a) (g a) -- the forall outside the data constructor makes it existential
21:12:57 <ddarius> It's close at least.  It specializes appropriately when f and g are constant functors.
21:12:59 <solrize> dolio, on collections bigger than the cpu cache, doesn't heapsort always get crushed?
21:14:22 <edwardk> yeah its tricky because you are currying an quantified value. that always goes where.
21:14:24 <edwardk> er weird
21:14:30 <dolio> That's what I've heard, but all the things I've tried that are supposed to make it more cache friendly have been slower than my ordinary (trinary) heap sort.
21:15:13 <ddarius> dolio: You may be interested in cache oblivious algorithms.
21:16:00 <solrize> dolio, i'd have thought that heapsort is inherently cache unfriendly no matter what you do
21:16:18 <solrize> i don't know of more modern sorting references than knuth vol 3 though
21:17:05 <dolio> solrize: Well, I found one paper that that suggested clustering parts of several layers together, so that parents and children are typically closer than they are in ordinary heapsort.
21:17:57 <edwardk> ddarius: are we sure that a is existential and not universal?
21:18:31 <dolio> That wasn't obviously faster than what I had, though.
21:18:54 <solrize> dolio i wonder if you could make heapsort guarantee runtime <= k*n lg n with probability 1-epsilon for arbitrary small epsilon, where k depends on epsilon, by randomly sampling some of the data and choosing the median of the random sample as the pivot
21:19:33 <edwardk> phi :: ((forall a. (f a, g a)) -> b) :<->: (forall a. f a -> g a -> b)
21:19:39 <dolio> Pivot?
21:20:17 <edwardk> where type f :<->: g = (f -> g, g -> f)
21:20:35 <ddarius> edwardk: If that works than that works.
21:21:06 <edwardk> ddarius: will wrestle with it
21:21:11 <bd_> solrize: you mean quicksort?
21:21:20 <solrize> bd whoops yes
21:21:28 <dolio> Ah, that makes more sense.
21:21:47 <bd_> heapsort already has guarenteed worst cast O(n lg n) after all :)
21:22:39 <ddarius> edwardk: forall a. f a -> g a -> b ~ forall a. (f a, g a) -> b should be isomorphic to (classically) (exists a. (f a, g a)) -> b was my logic.
21:23:08 <dolio> I suppose I could add that to my introsort. It might result in less defaulting to the (slower) heapsort.
21:23:37 <edwardk> ddarius: i'll see if i can make the types work. i'm going to head to bed coz my wife would like some time with me, but i'll definitely pick this up tomorrow some time.
21:23:46 <dolio> Or, at least, less predictable.
21:23:52 <ddarius> I need to head to sleep as well.
21:24:23 <bd_> dolio: Where will you get the randomness?
21:24:32 <edwardk> thank you very much for all your help though =)
21:24:32 <dolio> Pass in a generator.
21:24:42 <bd_> ugly :/
21:24:43 <dolio> Or I could cheat and use unsafeIOToST. :)
21:24:51 <bd_> heh :)
21:25:25 <dolio> Maybe I should just go and finish my timsort implementation.
21:25:40 <bd_> I mean, wrapping it in unsafePerformIO to grab a generator probably won't hurt anything, but you /would/ perturb the global RNG state in a non-pure way...
21:28:21 <dolio> Oh, wait. Even unsafeIOToST won't work.
21:28:24 <sclv> what did the lambdacat say to his category theory professor?
21:28:34 <sclv> Kan I has extension!
21:28:44 * Korollary keels over
21:28:55 <dolio> Because the fast (mersenne twister) random library requires you to pass a token around.
21:29:04 <dolio> And you can only get the token once per program.
21:32:13 <dolio> I guess the pure one will work.
21:35:00 <solrize> i guess you could use the input set to initialize the RNG.  then the adversary would have to do a huge computation to select a bad input set for you.
21:35:24 <solrize> while your function would still be pure
21:36:22 <dolio> Heh.
21:44:26 <dolio> Well, this appears to be a lot slower.
21:44:56 <solrize> which?
21:47:28 <sclv> edwardk: looking through category-extras now... do you have a simple stream comonad at the moment?
21:48:03 <dolio> Cofree Identity :)
21:50:15 <sclv> I'm not sure where I even see the comonad declaration for cofree though...
21:51:02 <sclv> all this other lovely extra plumbing makes it harder to poke around for more basic stuff that I'm still working on trying to get a handle on.
21:55:30 <sclv> ah... Cofree' Identity!
21:56:44 <dolio> Oh, is Cofree some kind of higher order thing?
21:56:53 <dolio> I haven't gone and looked at it lately.
21:57:44 <sclv> Cofree is related to the strength posts I think...
22:04:56 <sclv> my silly notion is to try to ram together the stream comonad with concurrent channels and see if I can't come up with a cute representation of a join-calculus type thing.
22:07:16 <sclv> outside of "comonads and codata" I don't know if anyone's looked at comonads for concurrency modeling as opposed to dataflow modeling...
22:23:48 <roconnor> @type randomRIO
22:23:51 <lambdabot> forall a. (Random a) => (a, a) -> IO a
22:25:31 <roconnor> > chr 49
22:25:33 <lambdabot>  '1'
22:25:42 <roconnor> > chr 54
22:25:43 <lambdabot>  '6'
22:29:21 <roconnor> @hoogle replicateM
22:29:21 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
22:29:21 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
22:30:55 <roconnor> oh god, is replicateM not Haskell 98?
22:39:45 <roconnor> @unpl ((partition$u(==)).).
22:39:46 <lambdabot> (\ b g j -> partition (u (==)) (b g j))
22:40:04 <roconnor> @unpl ((partition$u(==)).).zip
22:40:04 <lambdabot> (\ d i -> partition (u (==)) (zip d i))
22:52:41 <OceanSpray> how much are type classes grounded in type theory?
22:53:33 <hpaste>  roconnor pasted "Mastermind" at http://hpaste.org/7784
22:53:57 <roconnor> oh
22:54:00 <roconnor> hpaste is back
22:54:25 <OceanSpray> is that meant to be unreadable?
22:56:32 <roconnor> OceanSpray: nope
22:56:50 <roconnor> http://okmij.org/ftp/Haskell/index.html#mastermind
22:56:50 <lambdabot> Title: Haskell Programming: Miscellanea
22:56:52 <OceanSpray> are you being sarcastic?
22:56:59 <roconnor> er
22:57:00 <roconnor> sorry
22:57:02 <roconnor> yes
22:57:10 <roconnor> I didn't parse the "un"
22:57:59 <roconnor> @unpl ((partition$uncurry(==)).).zip
22:57:59 <lambdabot> (\ d i -> partition (uncurry (==)) (zip d i))
23:01:25 <roconnor> @pl f x=(x\\).(x\\)
23:01:25 <lambdabot> (line 1, column 4):
23:01:25 <lambdabot> unexpected "="
23:01:25 <lambdabot> expecting variable, "(", operator or end of input
23:01:35 <roconnor> @pl \x->(x\\).(x\\)
23:01:35 <lambdabot> (line 1, column 7):
23:01:35 <lambdabot> unexpected "\\"
23:01:35 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
23:01:49 <roconnor> @pl \x->(del x).(del x)
23:01:49 <lambdabot> liftM2 (.) del del
23:01:58 <roconnor> @unpl \x->(del x).(del x)
23:01:59 <lambdabot> \ x c -> del x (del x c)
23:02:34 <roconnor> x\\(x\\c)
23:04:57 <roconnor> @type unzip
23:04:59 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
23:08:09 <hpaste>  (anonymous) annotated "Mastermind" with "(no title)" at http://hpaste.org/7784#a1
23:13:10 <roconnor> > intersect [2,2,2] [2,2]
23:13:11 <lambdabot>  [2,2,2]
23:14:21 <conal> Blog post: http://reddit.com/goto?id=6k6q0 -- Higher-dimensional, higher-order derivatives, functionally: Beautiful differentiation, part 3
23:21:22 <hpaste>  jaj pasted "sql error" at http://hpaste.org/7785
23:21:59 <jaj> oh hpaste is back :)
23:23:43 <jaj> well I get "SQL logic error or missing database" from HDBC with sqlite with the code pasted above. It can certainly find the database because other actions succeed and I can't see any sql logic error...
23:23:54 <jaj> does anybody know how I could debug this?
23:26:46 <roconnor> > [1]\\[1]\\[1]
23:26:47 <lambdabot>      precedence parsing error
23:26:47 <lambdabot>         cannot mix `(\\)' [infix 5] and `(\\)' ...
23:27:18 <conal> g'night all!
23:31:34 <sclv> jaj: do the other actions insert or just query?
23:31:55 <jaj> sclv: just query
23:32:18 <sclv> hmm.. check you have write permissions from the binary?
23:32:21 <jaj> but it works from within ghci
23:32:45 <sclv> right, ghci runs as you.
23:32:58 <sclv> the binary is a cgi.
23:33:06 <dibblego> which structure in EdisonCore is the "Purely Functional Random-Access List"?
23:33:08 <sclv> run with permissions of the server.
23:33:53 <jaj> sclv: yeah your right... it's 644
23:36:40 <sclv> glad to help.
23:37:16 <jaj> but changing it to 666 doesn't help
23:37:30 <sclv> oh.. hmm
23:38:31 <dejones> does anyone know which book covers more advanced topics with Haskell either "Programming in Haskell" or "Haskell: The Craft of Functional Programming"  ?
23:39:32 <dibblego> dejones, the former, just
23:39:53 <dejones> dibblego: just what?
23:40:01 <dibblego> only just
23:40:09 <dibblego> only by a slight margin
23:40:45 <dejones> dibblego: I see.  I'm not sure if I should just wait for "Real-World Haskell"  ;)
23:40:57 <dibblego> dejones, depends how advanced you are already
23:41:20 <dibblego> Graham Hutton was in here earlier
23:41:49 <dejones> dibblego: Well, I'm interested in learning better the usage of monads, but so far I haven't had a need for writing my own monad.
23:42:08 <dibblego> dejones, you won't find that in either book; just a beginner explanation
23:42:40 <dejones> dibblego: I'll wait for Real-World Haskell then.  I'm a CS Master's student... so I want something close to the grad-level.
23:42:47 <jaj> sclv: thank you anyway for pointing me to the permission error!
23:42:49 <dejones> Otherwise, I'll just read research papers.
23:45:19 <sclv> hmmm.... is the enclosing directory writable too as well?
23:47:50 <jaj> sclv: no it wasn't but after fixing the permissions on the directory it works now!
23:48:04 <jaj> sclv: thank you very much and sorry for bugging you with this...
23:48:11 <sclv> ah, now I can say I'm glad to help :-)
23:49:22 <jaj> sclv: yes, thanks, typical pebkac :)
23:50:36 <sclv> I dunno. getting all the fiddly bits and permissions and protocols to work right is usually harder than the programming bit for me.
23:51:19 <sclv> we need an operating system that typechecks permissions and protocols.
23:51:35 <pejo> dejones, try checking the old papers from summer schools
23:51:46 <dejones> pejo: thank you.
23:52:05 <dejones> pejo, dibblego: this link was suggested to me earlier: http://www.haskell.org/all_about_monads/html/index.html
23:52:07 <lambdabot> Title: All About Monads
23:57:35 <jaj> sclv: hmm an operating system written in haskell perhaps with a corresponding file system where files and represented in haskell datatypes :)
23:58:03 <sclv> there's a proof of concept shell in clean that comes close.
23:59:30 <solrize> house + zipperfs?
