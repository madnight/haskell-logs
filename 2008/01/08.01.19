00:05:04 <levi> So, I have a tokenizing function that stores line, column, and remaining string information in a State monad.  I want to be able to create a list of tokens with this function now, but I'm having trouble constructing a generator for the list.
00:05:19 <jsnx> Cale: cool
00:05:43 <jsnx> Cale: if i find more, i'll let you know -- the professor is at your school, right?
00:05:48 <Cale> no
00:05:53 <jsnx> oh
00:05:59 <Cale> jsnx: It's just a book which I found online :)
00:06:12 <ddarius> levi: How do you decide when you are done lexing tokens (i.e. what's the end of list case?)
00:06:13 <Cale> You might want to contact him directly though
00:06:23 <levi> token :: State (Int, Int, String) (Token, Int, Int)
00:06:33 <levi> ddarius: an EOF token
00:06:34 <Cale> http://www.indiana.edu/~mathwz/
00:06:34 <lambdabot> Title: Personal Web Page
00:06:35 <jsnx> Cale: aye
00:09:17 <levi> ddarius: And the EOF token is generated when the String is empty.
00:09:36 <jsnx> Cale: bug report submitted
00:15:01 <ddarius> @hoogle unfold
00:15:02 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
00:15:02 <lambdabot> Data.ByteString.unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
00:15:02 <lambdabot> Data.ByteString.unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
00:16:04 <jsnx> jfredett: ciao
00:16:10 <gio123>  Cale:hi can u pm please only for a minute
00:17:19 <adamjones> Coming in to irc to ask a question just helped me find the answer.
00:17:24 <adamjones> thanks guys!
00:17:26 <gio123> Cale: I found 1 bug but dont know hoe to handle
00:17:43 <ddarius> levi: One approach is to parse a token, check if it's the EOF token and if not recurse.  Accumulate the tokens as you parse.
00:21:43 <levi> Well, then this whole monad exercise hasn't bought me anything.
00:25:09 <ddarius> levi: There's another approach if you use a different monad.
00:25:43 <ddarius> levi: But what are you aiming for?
00:32:54 <levi> ddarius: I simply want to turn a String into a list of pairs of (Token, Position)
00:35:05 <levi> I have a working function that turns a String into a list of Tokens, but I want to somehow keep the position information with the tokens, so I can use it later in the parsing phase.
00:36:06 <ddarius> levi: Why do you think the monad approach hasn't bought you anything?  My intent was to you your monadic tokenize functions.
00:36:35 <levi> ddarius: Well, I haven't figured out how to use my monadic tokenize function to create a list.
00:36:51 <sjanssen> dons: any reason why the shootout just doesn't use "--make" rather than "-package" flags?
00:37:12 <sjanssen> it'd avoid some of these 6.8 breakages
00:37:25 <dons> i've emailed isaac about that.
00:37:25 <ddarius> levi: You just use it repeatedly.
00:37:33 <levi> Unless I run the token function, extract the state manually, and pass it to the recursive call.
00:37:34 <dons> he should be adding --make to fix up most of those breakages
00:37:57 <levi> ddarius: It's automation of the 'use it repeatedly' that's catching me up.
00:38:12 <ddarius> levi: How would you just read lines from the console until the user typed "done" say?
00:38:41 <levi> ddarius: I'm not sure how I'd do that, either.
00:39:07 <levi> (this is my second day of working with Haskell, so I'm still a bit intimidated by it)
00:39:13 <ddarius> levi: Okay.
00:40:05 <levi> My non-monadic tokenizer just conses recursive calls, but I haven't figured out how to do that with the monadic one.
00:40:28 <ddarius> Well, that example would look like: readLinesUntilDone = do l <- getLine; if l == "done" then return () else readLinesUntilDone
00:44:47 <ddarius> If you wanted to keep the lines (making this a bit more useful) you could write: readLinesUntilDone = do l <- getLine; if l == "done" then return [] else do ls <- readLinesUntilDone; return (l:ls)
00:45:12 <ddarius> However, that code is not tail-recursive and would potentially cause a stack overflow on large input.
00:45:25 <ddarius> To solve that, you apply the standard trick.
00:49:06 <gio123> Cale:  the problem what i have is reg1 |_| reg2 --> ????
00:49:42 <gio123> Cale:  in inequlaity when we get something like lhs<rgs < reg1 |_| reg2  then how is proccced computation
00:53:36 <levi> ddarius: Ahh, I was missing the 'ls <- readLines etc.' part.
00:55:00 <levi> ddarius: Thanks!  I can now stop bashing my head into my table and go to sleep.
00:58:34 <bparkis> ddarius: wouldn't matter if it's tail recursive since it stores the lines anyway so it must use linear memory
01:00:06 <sjanssen> bparkis: most compilers have a small stack limit and a very large heap limit
01:00:27 <bparkis> you have a point
01:00:50 <sjanssen> shouldn't be a problem unless you've got heaps and heaps of lines
01:16:57 * hgolden is away: sleep
01:17:10 <lakupuu> k
01:30:00 <bparkis> does the concept of a type predicate have much popularity outside of Lisp? is there another name for it?
01:31:20 <Tac-Tics> isinstanceof?
01:31:22 <bparkis> and is there anything wrong with the following interpretation for the I combinator which has type a -> a:  "For all values x, y, for all type predicates a, (I x) = y and (a x) implies (a y)"
01:31:29 <bparkis> is that normal?
01:32:31 <bparkis> I don't know much type theory so I may be missing some problem with that interpretation
01:34:42 <sclv> bparkis: it seems like a way of formalizing dynamic type checking. so very lispy to make it first-class.
01:35:18 <bparkis> it's not dynamic it's expressing a static type as a guarantee about the input and output values
01:35:49 <bparkis> just taking the type predicate thing from lisp but not using it dynamically
01:36:15 <sieni> bparkis: I guess you can do something similar with algebraic data types and pattern matching
01:36:40 <sieni> bparkis: like data Foo = MyInt Int | MyString String etc.
01:36:42 <sclv> have you looked at qi's sequent calculus?
01:37:10 <sieni> bparkis: perhaps this wasn't what you were asking...
01:39:32 <bparkis> i have visited the qi site sclv a few months ago
01:42:31 <sclv> bparkis: this may be too basic too, but you are familiar with the curry-howard isomorphism?
01:43:11 <bparkis> well, with the wikipedia article on it
01:43:22 <bparkis> that is where I was starting from
01:43:39 <bparkis> reconciling type predicates with the curry howard isomorphism
01:45:26 <bparkis> I want to interpret function type signatures as arbitrary preconditions and postconditions
01:46:24 <sclv> hmm... type predicates as i understand them in lisp are generally much more about the dynamic-to-static issue. there was an interesting ltu thread where not only embedding an untyped in a typed language was demonstrated but the reverse as well.
01:47:11 <sclv> bparkis: preconditions and postconditions imply sequencing. type signatures are more like declarative constructs.
01:47:14 <sclv> i think?
01:47:30 <bparkis> a type predicate in lisp is just a predicate that returns true when the value passed to it is of the required type
01:47:50 <bparkis> the type being defined by some condition on that value, such as the property of being a string
01:48:10 <sclv> right: so you use them for "typing" dynamic values.
01:48:34 <sclv> like at least in scheme, 3 matches rational and integer both, no?
01:48:48 <sclv> and a 3 derived from 3.3 - 0.3 also matches integer.
01:49:19 <sclv> so you can't formalize what its type is going to be until runtime.
01:49:40 <bparkis> but i mean if you have K of type a->b->a then that is basically a precondition/postcondition contract stating that if the first argument is of type a and the second argument is of type b, the return value is of type a
01:50:51 <sclv> no. its a proposition that if (a and b), a
01:51:26 <bparkis> if the function were represented in some concrete types instead of parametric types, like f::Int->Int, then this could be expressed with type predicates as a contract that if the first argument satisfies the int predicate, then the return value also satisfies the int predicate
01:51:48 <sclv> but since we're using static typing, the first argument can't not satisfy the int predicate.
01:52:41 <bparkis> well you could attempt to call f "abc" and fail, which would not satisfy the precondition
01:53:13 <sclv> you may want to think about this in the context of djinn and free theorems.
01:53:16 <bparkis> and it's a lesser point that this failure is caught at compile time instead of with a runtime assertion
01:53:49 <bparkis> with a sufficiently complex type system you can't always catch all type errors at compile time
01:54:11 <sclv> bparkis: but its not. because these are fundamentally different things. runtime assertions aren't about types in the same sense.
01:55:02 <sclv> f "abc" if f :: Int->Int in a static language is more than just an error -- its an ill-formed proposition.
01:55:28 <bparkis> from one way of looking at it the difference between catching type errors at compile time and catching them with runtime checks, is simply one of optimization
01:55:45 <sclv> it depends what you mean by type though.
01:56:00 <bparkis> so long as you don't ever try to catch a mismatched type exception or anything though
01:56:41 <bparkis> well as I mentioned I don't know much type theory... so I  naively consider a type to be a set of values
01:57:15 <bparkis> a->b->a being the set of all functions that satisfy that signature, for example
01:57:23 <sclv> well then what do you mean by value. i.e., is 3.0 the same as 3 the same as (succ (succ (succ (zero))) ?
01:59:18 <bparkis> by value perhaps i mean, normal form of an expression
01:59:50 <bparkis> in a real computer i mean value is a sequence of bits
02:00:35 <sclv> ok but 97 and 'a' are the same sequence of bits. are they the same value?
02:01:58 <bparkis> well, I guess I'd say yes, although then it gets a bit sticky
02:01:59 <sclv> i'm feeling too tired and not-really expert to hold forth on this, but from what i understand about category theory the standard way to look at types is sort of like sets but fancier.
02:02:38 <sclv> a small category is a collection of objects and arrows between them.
02:03:05 <bparkis> but you could avoid type conflicts between 97 and 'a' because it would usually be hard to prove that 97 is a valid input for a function that needs a character
02:03:09 <sclv> so an "object" is a really abstract notion, but it forces you to specify what it means in any particular context rather than get hand wavey about it.
02:04:04 <bparkis> so if you had a function that took an int, and you pass it 'a', then you would have no guarantee (prior to runtime) whether the function would work
02:04:10 <bparkis> you couldn't prove your program correct
02:04:21 <sclv> bparkis: but its equally hard to prove that a function that subtracts floats might be able to give an int to a function that operates on ints becaue you pass it 3.3 and 0.3
02:04:47 <bparkis> at least you couldn't prove your program correct without delving deeper into the implementation of 97 and of 'a'
02:05:42 <sclv> you're thinking too low level i suspect. a type is an order that we impose on the world by making a set of propositions about what morphisms exist for it.
02:07:49 <sclv> the guarantees that we can and can't prove are completely dependent on the types that we define and the morphisms we define for them.
02:08:29 <sclv> so its easy, for example, to define a type for natural numbers as long as you, for example, don't give them a subtraction operation.
02:08:37 <bparkis> you could think of a "typesafe function" as a function that you have proved to always return a value of the claimed type, assuming the inputs are of the requisite types
02:09:37 <bparkis> (or not terminate)
02:10:05 <sclv> i don't even know what a typesafe function means exactly. in a strongly typed language all functions are "typesafe" by definition.
02:11:11 <sclv> in a weakly typed language, or one that lets you mess around with casting, "typesafe" in your sense means i suppose that you can show that where, e.g., in Java you have HashMap of Objects that these Objects are always inserted and removed as strings, i suppose.
02:11:24 <bparkis> well suppose you have a function whose type is very hard to prove
02:11:57 <sclv> ok. not sure i follow, but go on.
02:11:58 <bparkis> like you might claim it returns the primes
02:12:11 <bparkis> or rather, returns a value that is prime
02:12:20 <Tac-Tics> Like nthPrime :: Int -> Prime?
02:12:25 <bparkis> yeah
02:12:42 <bparkis> then it would not be really "typesafe" until you have proved that it does indeed always return a Prime
02:12:52 <bparkis> and it would be nontrivial to prove that
02:13:20 <Tac-Tics> And it certainly would be tricky and worthless to automate such a proof
02:13:34 <bparkis> yes, proving that function typesafe should probably be done by hand
02:14:57 <bparkis> and perhaps machine checked
02:15:26 <sclv> ok i see where you're going. i just wouldn't think of that as "typesafe" in the same sense.
02:16:30 <sclv> the way wadler described typesafety in his recent talk, for example was that if you boil everything down to lambda calculus, you have a guarantee that you never attempt to apply an atom as a function.
02:17:36 <sclv> but to go beyond that is to get into more general issues of dependent types which i'm not so conversant with. I think one of the main Coq guys hangs out here a bunch though.
02:17:56 <bparkis> well I'd be in over my head with that stuff before doing some more reading on type theory
02:18:24 <sclv> same here. :-) nytol.
02:22:27 <glguy>  Is something VIOLENT going to happen to a GARBAGE CAN?
02:24:09 <sjanssen> @yow?
02:24:09 <lambdabot> I just had a NOSE JOB!!
02:33:29 <Tac-Tics> @vixen
02:33:29 <lambdabot> I have a goldfish named Ernie
02:37:24 <C-Keen> @wtf?
02:37:24 <lambdabot> Unknown command, try @list
02:37:39 <C-Keen> @list
02:37:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
02:38:29 <czShadoW> @protontorpedo
02:38:29 <lambdabot> is there an oo db in haskell?
02:40:39 <profmakx> @users
02:40:39 <lambdabot> Maximum users seen in #haskell: 454, currently: 396 (87.2%), active: 11 (2.8%)
02:44:15 <integral> @djinn (t -> Bool) -> t -> t -> Bool
02:44:15 <lambdabot> f a b _ = a b
02:48:04 <QuietPurple> hello, can anyone please tell me what is the difference between Int and Integer, and how do i stop ghci from assuming [[1,2,3],[4,3,2]] is [[Integer]] when i want it to be [[Int]]?
02:50:17 <jethr0> Int is the machine's physical type (like 32 or 64 bits), Integer is an unbounded type
02:50:18 <ski_> `Integer' is arbitrary precision, `Int' is fixed
02:50:32 <QuietPurple> ok, but they behave the same
02:50:33 <jethr0> > [[1,2,3],[4,3,2]] :: [[Int]]
02:50:35 <lambdabot>  [[1,2,3],[4,3,2]]
02:50:48 <QuietPurple> cool, so i could do that
02:51:01 <QuietPurple> or change my functions so they take [[Integer]]
02:51:02 <ski_> if you pass `[[1,2,3],[4,3,2]]' into a context expecting a `[[Int]]' then it will be that
02:51:06 <jethr0> QuietPurple: not the same. for values < 2^32 they behave similarly, but Int overflows and Integer doesn't
02:51:33 <ski_> > 2^30 :: Int
02:51:35 <lambdabot>  1073741824
02:51:35 <QuietPurple> well my program will only need to deal with no.s less than 300 say
02:51:47 <ski_> > 2*(2^30 - 1) :: Int
02:51:47 <lambdabot>  2147483646
02:51:53 <ski_> > 2*(2^30 - 1) +2 :: Int
02:51:53 <lambdabot>  -2147483648
02:52:09 <Vq^> QuietPurple: you could also make your function general enough to handle both
02:52:21 <QuietPurple> i'm not sure how to do that
02:52:47 <Vq^> @type [[13,7],[3]]
02:52:48 <lambdabot> forall t. (Num t) => [[t]]
02:52:52 <jethr0> QuietPurple: if you function is short paste it here, otherwise @paste
02:52:58 <ski_> myFunction :: Num n => [[n]] -> ...
02:53:32 <QuietPurple> its quite long, actually i think i will just use :: [[Int]]
02:53:39 <QuietPurple> that seems easiest
02:53:58 <QuietPurple> thanks for the help
02:55:50 <desegnis> QuietPurple: The better strategy, in my eyes, would be to always use Integer, and only refactor to Int (which would just mean, change the type signatures) when you experience performance problems
02:57:00 <QuietPurple> yes, i think in future i will
02:57:13 <Vq^> you can also use ghc to figure out the type for you
02:57:32 <Vq^> ghc is very good at giving the most general type
02:57:41 <QuietPurple> it's just this program has to be finished really soon, so it's most important that it works
02:57:54 <jethr0> QuietPurple: ^_^
02:58:00 <QuietPurple> how do you do that
02:58:02 <QuietPurple> ?
02:58:28 <Vq^> you exclude the type in your file, read the file with ghci and check it's type with the :t command
02:58:40 <desegnis> @type \x -> x `mod` 3
02:58:42 <lambdabot> forall a. (Integral a) => a -> a
02:58:47 <QuietPurple> ok
03:00:13 <Vq^> very useful :)
03:15:07 <ac> yeah, I do that frequently
03:26:33 <Saul_> :t hEnd
03:26:34 <lambdabot> Not in scope: `hEnd'
03:59:03 <pjd> Vq^, QuietPurple: just remember -fno-monomorphism-restriction
04:13:09 <Tac-Tics> @src Traversable mapM
04:13:09 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
04:13:17 <Tac-Tics> @src Traversable.mapM
04:13:17 <lambdabot> Source not found. Where did you learn to type?
04:13:29 <Tac-Tics> @src Data.Traversable mapM
04:13:29 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
04:13:50 <Tac-Tics> @src mapM
04:13:51 <lambdabot> mapM f as = sequence (map f as)
04:13:59 <Tac-Tics> @src sequence
04:13:59 <lambdabot> sequence ms = foldr k (return []) ms
04:14:00 <lambdabot>     where
04:14:00 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
04:14:40 <Tac-Tics> @src liftM2
04:14:40 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
04:14:51 <Tac-Tics> @src ap
04:14:51 <lambdabot> ap = liftM2 id
04:49:23 <EvilTerran> connection trouble, Quiet_Purple?
05:11:14 <cinimod> This is haskell related. I need to compile a load of C files on windows.
05:11:35 <cinimod> I've got a makefile but make doesn't seem to exist on windows.
05:12:15 <cinimod> I recall that someone wrote a "make" in haskell. I can't find it so I may just have imagined it.
05:12:45 <Lemmih> hmake isn't a make replacement.
05:13:05 <cinimod> I know. I wanted a real make that takes makefiles.
05:13:22 <Lemmih> cinimod: Tried wingw or cygwin?
05:13:25 <resiak> hrm, is building a regular C project with cabal feasible?
05:13:37 <resiak> or rather, does anyone do it?
05:13:56 <cinimod> Lemmih: I didn't really want to go there but I may have to
05:13:59 <Lemmih> Should be possible but I wouldn't recommend it.
05:14:31 <resiak> why not?
05:15:36 <resiak> i mean, obviously it would be a bit perverse, but it might be nicer than autotools :)
05:16:45 <EvilTerran> cinimod, what about, say, nmake?
05:17:23 <EvilTerran> or the mingw32 make?
05:17:40 <cinimod> EvilTerran: I'll have a look at nmake
05:17:44 <Lemmih> resiak: Cabal just calls GHC on a list of .c files.
05:18:02 <cinimod> EvilTerran: doesn't mingw32 install a lot of other stuff as well?
05:18:19 <resiak> fair enough
05:19:45 <EvilTerran> well, MinGW itself is a set of headers and libraries intended to make compiling programs expecting a POSIX environment possible on 'doze
05:20:44 <Botje> @tell levi you probably have to import Control.Monad.State first for advance to work
05:20:44 <lambdabot> Consider it noted.
05:21:00 <EvilTerran> but ISTR these have been used to build GNU Make on windows, as a standalone download
05:21:08 <EvilTerran> (i may be wrong)
05:21:16 <ac> how does zlib indicate failure of decompression?
05:25:02 <mux> it'll return Z_ERRNO or Z_STREAM_ERROR or some other constant for errors
05:25:17 <ac> in the ByteString it returns?
05:25:53 <mux> oh, no idea
05:26:52 <ac> the interface for the Haskell zlib is idiotically simple
05:29:33 <roconnor> eric's channel 9 interview was quite nice.
05:29:51 <roconnor> He made the point that Haskell doesn't remove side-effect, but rather adds lazy evaluation.
05:30:14 <roconnor> Side effects are still there; only the type signatures change.
05:31:19 <ac> I was a litle disappointed with how little was covered
05:33:05 <roconnor> yeah, perhaps I should say that I don't recommend the video so much for experienced Haskellers, but I did enjoy watching it because I had some time.
05:33:36 <ac> I feel flattered at your implication that I'm experienced
05:34:49 <ac> I did like his "honestly typed" term
05:35:06 <ac> Yet another dimension for types
05:36:20 <ac> static/dynamic, strict/weak, inferred/explicit, honest/dishonest ...
05:38:19 <ac> C must be the king of dishonest types
05:38:29 <roconnor> :)
05:39:25 <Valodim_> what's "honest typing"?
05:39:29 <Valodim_> google proved unhelpful :(
05:39:41 <ac> Yeah, I think Eric just came up with the term
05:39:41 <phlpp> hmm, it's a pity that SPJ isn't here right now. i would wish him the very best, and perhaps 50 more years (determined by haskell :D)
05:39:59 <ac> Valodim_: It's about a type signature really meaning what it says
05:40:15 <Valodim_> what would be a negative example?
05:40:19 <ac> Valodim_: C is very dishonest, because you can type cast anything to anything and it may or may not segfault
05:40:27 <Valodim_> aah
05:40:30 <Valodim_> ok
05:40:31 <mauke> actually, you can't :-)
05:40:40 <roconnor> ac: that wasn't what eric meant
05:41:14 <roconnor> C is dishonest because random returns different values when called with the same input
05:41:23 <byorgey> phlpp: I don't think SPJ really hangs out here, which is too bad =)
05:41:37 <ac> roconnor: that doesn't make sense, because how would Python be honestly typed?
05:41:53 <roconnor> ac: it is honest because it has no types
05:42:00 <roconnor> ac: so python isn't lying
05:42:11 <byorgey> hehe, "you have the right to remain silent..."
05:42:18 <Valodim_> "dishonest"? I'd have called that imperative... :P
05:42:25 <ac> So his definition of an honest type system is basically no type system, or a pure language
05:42:47 <roconnor> ac: yep
05:42:57 <roconnor> ac: but he says that Java is more honest than C
05:43:08 <roconnor> because exceptions are listed in Java types
05:43:25 <ac> Are you sure? Because then it's not a new dimension (as he portrayed it) at all, because it's not orthogonal to pure/imperative
05:43:51 <flux> except runtime exceptions. I wonder though why there isn't a (semi)functional language with exceptions with exception inference.. (is there?)
05:44:20 <flux> I'm thinking properly typed exceptions (with inference) would reduce the problems there are with checked exceptions..
05:44:31 <roconnor> ac: I'm not sure.
05:44:46 <pejo> byorgey, I'm guessing that he gets more research done by not hanging on irc. :-)
05:45:34 <byorgey> pejo: what are you saying? ;)
05:45:57 <Sizur> that we dont do any research ;)
05:46:01 <ac> good thing I don't have to worry about getting research done
05:47:15 <ac> mauke: what do you mean you can't?
05:47:48 <pejo> byorgey, that irc is one of those processes that consume all your available time. But it's fun!
05:48:45 <ac> pejo: it's especially dangerous when you run IRC servers as gateways to other protocols like IM and email
05:48:58 <ac> you find yourself spending more and more time in your IRC client...
05:48:59 <byorgey> pejo: oh, do I ever understand!
05:49:23 * byorgey has apparently uttered 1,275 lines of text on #haskell since January 1  o.O
05:49:54 <pejo> byorgey, that's nearly a full research paper!
05:49:58 <olsner> byorgey: where did you get those stats?
05:50:07 <ac> 50 lines a day isn't that much
05:50:34 <byorgey> pejo: you're right!  hmm... just needs a bit of editing, and I should have a nice submission for JFP...
05:50:36 <pejo> There are people who advocate that if you spend 15 minutes a day writing you can have a book by the end of the year.
05:50:43 <byorgey> olsner: http://www.cse.unsw.edu.au/~dons/irc/haskell-08.html
05:50:44 <lambdabot> Title: #haskell @ freenode.org stats by dons
05:51:09 <olsner> @where stats
05:51:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
05:51:59 <Valodim_> I like how the second most used word is "think" :)
05:52:02 <olsner> I've been offline most of january though...
05:53:11 <byorgey> hmm, "monad" usually makes it on the list of most-used words, I guess not this time...
05:53:47 <Valodim_> we should say monad more often, then
05:54:00 <ac> woo I'm 15th
05:54:21 <byorgey> monad monad monad!
05:54:35 <ac> my random quote was me complaining about filters in the PNG spec
05:54:47 <olsner> seems this statistics script is having trouble with zero uses of foul language though
05:55:01 <Valodim_> hehe, yeah
05:55:14 <Valodim_> the case seems just too unlikely
05:55:21 <byorgey> or it could just be less than 1 word in 1000
05:55:30 <byorgey> which seems likely
05:55:45 <olsner> hmm, yeah, that could be it
05:55:57 <Valodim_> which is still pretty good
05:56:08 <olsner> that would explain anyone ending up in a top list
05:56:10 <byorgey> guess we all need to curse more
05:56:30 <ac> ...or not
05:56:36 <byorgey> dagnabit
05:56:38 <mauke> ac: you can't cast to array, function, struct or union types
05:56:57 <Valodim_> ass
05:56:57 <Valodim_> sucker
05:56:57 <Valodim_> shit
05:56:57 <Valodim_> ...there, that will basically guarantee me a place in the stats next time >:)
05:57:26 <byorgey> @slap Valodim_
05:57:26 * lambdabot slaps Valodim_
05:57:33 <Valodim_> haha
05:57:48 <ac> figures somebody would rise to the bai
05:57:51 <ac> t
05:58:37 <ac> mauke: that's interesting. I guess a miss-casted function could be disastrous
05:59:08 <Valodim> what possible use could that ever have
06:00:08 <Valodim> casting arguments and the return value is all that's needed in any case I can think of
06:00:47 <olsner> you can cast between function pointers
06:01:51 <ac> so who is this dons fellow, who seems to be the most prominent member here?
06:02:41 <Valodim> he's the one who makes the stats
06:03:11 <ac> well, even if he's doctored them, which I doubt, I still here about him a lot
06:03:36 <olsner> I guess he's a "prominent haskell hacker"
06:03:52 <Valodim> oh I didn't imply that at all
06:04:22 <roconnor> roconnor seems to be sad at the moment: 1.7% lines contained sad faces. :(
06:06:21 <Valodim> there's another one
06:06:37 <roconnor> :(
06:06:42 <Valodim>  monad
06:06:55 <Valodim> aren't we subtle
06:07:28 <EvilTerran> yes monad, i guess monad we are monad monad
06:08:11 <ac> > replicate 1000 "monad"
06:08:15 <lambdabot>  ["monad","monad","monad","monad","monad","monad","monad","monad","monad","mo...
06:08:22 <Saul_> roconnor: Hey dude, I saw you last week at the FP-dag in Utrecht
06:09:06 <Saul_> >concat . repeat $ "monad"
06:09:08 <olsner> @quote monad
06:09:08 <lambdabot> Saizan says: yesterday i was so drunk i was trying to typecheck the people at the party.. "what's your monad!?"
06:09:15 <Saul_> > concat . repeat $ "monad"
06:09:15 <olsner> @quote monad
06:09:15 <lambdabot> EvilTerran says: if three of those lines aren't import Control.Monad; import Control.Arrow; import Control.Applicative;, you can make it shorter ;]
06:09:15 <lambdabot>  "monadmonadmonadmonadmonadmonadmonadmonadmonadmonadmonadmonadmonadmonadmonad...
06:10:05 <roconnor> Saul_: my slides are up on the web
06:10:20 <Saul_> roconnor: Yeah I saw them already
06:10:39 <Saul_> I'm actually trying to do some type hacking myself at the moment
06:10:49 <roconnor> Saul_: in what language?
06:10:54 <Saul_> In haskell
06:11:12 <roconnor> fun
06:11:33 <Saul_> I want to be able to make vectors, but only be able to add them to one another when they are the same size
06:11:52 <roconnor> Saul_: that can be done to a certain extent.
06:12:00 <Saul_> and probably add matrices as well
06:12:27 <byorgey> you have to know at compile time the sizes of all the vectors, though.
06:12:51 <roconnor> exactly, you are restricted to compile time knowledge
06:13:08 * byorgey tried that once, and learned a lot =)
06:13:12 <roconnor> but, it is a useful in many situations.
06:13:21 <hpaste>  Saul_ pasted "type hacking by noob" at http://hpaste.org/5095
06:13:36 <Saul_> This is basically what I have right now
06:14:04 <Saul_> Not much to do with vectors right now
06:14:20 <roconnor> good start
06:14:37 <Saul_> This compiles, but I don't know how to actually add stuff together
06:15:26 * byorgey suggests adding an "asInt" method to class Nat, for reifying Nat types as Int values
06:15:29 <Saul_> so I can't check if it works properly
06:16:30 <Saul_> byorgey: vectors aren't going to have negative sizes, so what's the added value of that?
06:16:48 <byorgey> Saul_: for testing.
06:17:17 <Saul_> oh right, I didn't see the type to value part
06:21:08 <phlpp> > 5:[]
06:21:15 <lambdabot>  [5]
06:21:35 <LoganCapaldo> > [5]:[]
06:21:36 <lambdabot>  [[5]]
06:21:53 <phlpp> 5:[[]]
06:22:00 <phlpp> > 5:[[]]
06:22:01 <lambdabot>   add an instance declaration for (Num [a])
06:22:04 <phlpp> :>
06:22:18 <LoganCapaldo> @type [[]]
06:22:19 <lambdabot> forall a. [[a]]
06:22:25 <LoganCapaldo> @type 5
06:22:26 <lambdabot> forall t. (Num t) => t
06:22:32 <LoganCapaldo> @type (:)
06:22:33 <lambdabot> forall a. a -> [a] -> [a]
06:22:38 <olsner> how wonderfully confusing that would have been if you had a Num instance for [a] :P
06:22:43 <Saul_> byorgey: How would I make the asInt function for the instance (Nat a) => Nat (Succ a) case?
06:23:04 <LoganCapaldo> (Num t) => t not unifyiable with [a]
06:23:17 * LoganCapaldo makes up words
06:24:10 <byorgey> Saul_: asInt _ = 1 + asInt (undefined :: a)
06:24:22 <Saul_> byorgey: ok thanks
06:25:34 <Saul_> *Main> asInt (undefined :: (Succ (Succ (Succ Zero))))
06:25:35 <Saul_> 3
06:25:38 <Saul_> :)
06:26:40 <Saul_> byorgey: And how do I test my Plus class?
06:26:45 <LoganCapaldo> what about fromInt?
06:28:22 <byorgey> Saul_: first make some constants, zero = undefined :: Zero, one = undefined :: Succ Zero, and so on
06:28:41 <byorgey> Saul_: then make a function plus :: (Plus x y z) => x -> y -> z -> Int
06:29:07 <byorgey> Saul_: then define things like test1 = plus zero one one and so on
06:29:23 <byorgey> Saul_: then you test it by seeing whether correct addition facts typecheck.
06:29:30 <byorgey> and incorrect ones don't.
06:29:38 <Saul_> ok
06:29:51 <phlpp> hm
06:29:56 <Saul_> that makes sense
06:32:43 <Sizur> @users
06:32:43 <lambdabot> Maximum users seen in #haskell: 454, currently: 399 (87.9%), active: 14 (3.5%)
06:33:58 <ac> first time I've seen it under 400
06:34:06 <byorgey> LoganCapaldo: what do you mean, what about fromInt?
06:34:16 <ac> the Haskell community is dying!
06:35:06 <Botje> ohnoes!
06:35:08 <byorgey> LoganCapaldo: haskell doesn't have dependent types, so it's possible to reify a type as a value but not to go the other way.
06:35:13 <Botje> quick, get some clones here!
06:35:55 <LoganCapaldo> a man can dream, can't he?
06:36:15 <ac> someday I will understand dependent types. Please, no one explain them to me, as I feel you'd be wasting your time
06:36:44 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5096
06:36:44 <roconnor> ac: check out my slides :P
06:37:05 <ac> roconnor: link?
06:37:14 <byorgey> LoganCapaldo: well, of course =)
06:37:25 <Sizur> @go roconnor's slides
06:37:25 <lambdabot> http://www.nachi.org/forum/showthread.php?t=3457
06:37:36 <roconnor> http://r6.ca/FewDigits/FPdag2008.pdf
06:37:53 <phlpp> :t flip
06:37:54 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
06:38:08 <Sizur> ocular is not that bad
06:38:26 <phlpp> :t zip
06:38:26 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
06:38:48 <phlpp> :t flip.zip
06:38:49 <lambdabot>     Couldn't match expected type `b -> c'
06:38:49 <lambdabot>            against inferred type `[(a, b1)]'
06:38:49 <lambdabot>     In the second argument of `(.)', namely `zip'
06:39:10 <LoganCapaldo> you know what I wanted to lean that I didn't "get", that whole "taking the derivatives of types" thing
06:39:15 <phlpp> :t flip zip
06:39:15 <lambdabot> forall a b. [b] -> [a] -> [(a, b)]
06:39:24 <phlpp> great
06:39:38 <roconnor> ac: actually, I'm not sure how great slides are without a speaker to go with them.
06:39:41 <LoganCapaldo> @type zipWith flip
06:39:41 <lambdabot> forall a b c. [a -> b -> c] -> [b] -> [a -> c]
06:39:50 <byorgey> Saul_: did you just paste http://hpaste.org/5096 ? looks good
06:40:17 <Saul_> byorgey: Yes that was mine
06:40:18 <ibid> roconnor: isn't the usual rule that good slides won't work out of context
06:40:21 <ibid> ?
06:40:49 <phlpp> :t zipWith
06:40:50 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
06:40:54 <roconnor> ibid: is it?
06:41:13 <LoganCapaldo> @type zipWith (\a b -> (a, b))
06:41:14 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
06:41:32 <phlpp> ah, thanks
06:41:35 <phlpp> :)
06:41:39 <LoganCapaldo> :)
06:41:45 <LoganCapaldo> @botsnack
06:41:46 <lambdabot> :)
06:41:52 <resiak> your slides are absolutely destroying evince :-/
06:42:19 <ibid> roconnor: some people say that
06:43:07 <ac> resiak: my evince is handling them just fine ;)
06:43:27 <phlpp> @index unique
06:43:27 <lambdabot> bzzt
06:43:29 <ibid> roconnor: it's sometimes told as guidance for talk preparation
06:43:32 <phlpp> @index uniq
06:43:32 <lambdabot> bzzt
06:43:37 <phlpp> hm
06:43:40 <Saul_> byorgey: Something is going wrong though
06:43:54 <phlpp> :t dropBy
06:43:55 <lambdabot> Not in scope: `dropBy'
06:43:59 <wolverian> my evince is having problems too
06:44:01 <LoganCapaldo> > nub [1,2,3,2,1]
06:44:03 <lambdabot>  [1,2,3]
06:44:05 <byorgey> Saul_: what's the problem?
06:44:08 <phlpp> ah ;)
06:44:10 <Saul_> byorgey: The plus doesn't seem to work properly
06:44:13 <phlpp> you know what i'm looking for
06:44:13 <wolverian> works, but took some time changing zoom levl
06:44:14 <Toxaris> Saul_, byorgey: Saul_'s code may look nice, but it doesn't work
06:44:16 <phlpp> :D
06:44:18 <wolverian> s/levl/level/
06:44:40 <wolverian> oh, wait, no, it's still rendering. can't change pages.
06:44:58 <wolverian> here we go. must have been all these gradients. ;)
06:44:59 <Saul_> Toxaris: What's wrong with it?
06:45:00 <phlpp> @index nub
06:45:00 <lambdabot> Data.List
06:45:01 <roconnor> I blame open office
06:45:07 <roconnor> http://r6.ca/FewDigits/FPdag2008
06:45:08 <Toxaris> Saul_: I have no clue.
06:45:14 <byorgey> hehe
06:45:14 <roconnor> ^^ for the open office file
06:45:28 <LoganCapaldo> @type (nubBy, deleteBy)
06:45:29 <Toxaris> Saul_: I just tried it because I found it nice that it looked so easy
06:45:30 <lambdabot> forall a a1. ((a -> a -> Bool) -> [a] -> [a], (a1 -> a1 -> Bool) -> a1 -> [a1] -> [a1])
06:45:47 <phlpp> argh ;)
06:46:07 <phlpp> @source nubBy
06:46:07 <lambdabot> nubBy not available
06:46:14 <LoganCapaldo> @src nubBy
06:46:14 <lambdabot> nubBy eq []             =  []
06:46:14 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
06:46:15 <byorgey> Saul_: oh, wait, I see, your Plus instances are not organized correctly
06:46:26 <phlpp> eh :>
06:46:31 <Saul_> Toxaris: :)
06:46:55 <LoganCapaldo> @src nub
06:46:55 <lambdabot> nub = nubBy (==)
06:46:55 <Saul_> byorgey: What's wrong with them exactly?
06:47:03 <byorgey> Saul_: you don't want to have a (Succ _) on both the left and right of the =>
06:47:33 <byorgey> all the Succ's should be on the right of the => so it can match on those, and then check the contraints on the left of the =>, which should be simpler
06:47:48 <byorgey> otherwise you don't get a well-founded recursion
06:49:24 <Saul_> instance (Plus x y z) => Plus x (Succ y) (Succ z)
06:49:27 <Saul_> This works
06:49:29 <Saul_> thanks
06:49:34 <Toxaris> Saul_: consider "append Nil ys = ys". Nil :: List Zero a, so n = Zero. (the n from the type of append). we need to prove (m == k) for the type to work out. so we need (Plus Zero m m) to make use of the functional dependency. both your instances doesn't apply :(
06:49:38 <byorgey> Saul_: right, that's it =)
06:49:50 <Toxaris> Saul_: (this is probably just what byorgey said. I was just proud to work it out myself)
06:50:06 <LoganCapaldo> > let nub' [] = [] ; nub' (x:xs) = x : nub' (filter (/= x) xs) in nub' [1,2,2,3,1]
06:50:07 <lambdabot>  [1,2,3]
06:50:36 <byorgey> Toxaris: that's another way to look at it, yes
06:51:03 <byorgey> Toxaris: so now the instance (Plus x y z) => Plus x (Succ y) (Succ z) will apply there
06:51:08 <phlpp> LoganCapaldo: hmm, hwo to do a nub which drops values (tuples (a, b)) in a list when there fst element is equal?
06:51:35 <LoganCapaldo> Well
06:51:37 <byorgey> phlpp: nubBy?
06:51:45 <phlpp> byorgey: yeah, exactly
06:51:49 <LoganCapaldo> you want to do == but on the first part of the tuple right?
06:51:52 <byorgey> @type nubBy
06:51:53 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
06:51:55 <phlpp> byorgey: and writing the lambda is my problem ;)
06:52:05 <LoganCapaldo> @type fst
06:52:05 <lambdabot> forall a b. (a, b) -> a
06:52:08 <mauke> > nubBy ((==) `on` fst) []
06:52:09 <lambdabot>  []
06:52:27 <phlpp> LoganCapaldo: exactly. look here: [('A',4),('B',2),('A',3),('C',1),('A',2),('B',1),('A',1)] should become the same without the doubled entries for 'A' and 'B'
06:52:30 <mauke> > nubBy ((==) `on` fst) [(1,2),(1,3),(2,3),(3,2),(2,1)]
06:52:31 <lambdabot>  [(1,2),(2,3),(3,2)]
06:52:49 <byorgey> > nubBy (\x y -> fst x == fst y) [(1,3), (1,4), (2,5), (3,2), (2,2)]
06:52:51 <lambdabot>  [(1,3),(2,5),(3,2)]
06:52:52 <phlpp> :t (on)
06:52:53 <lambdabot> Not in scope: `on'
06:52:57 <byorgey> ^^ if you don't have on
06:52:59 <phlpp> ah ok
06:53:07 <byorgey> on is easy to write yourself though
06:53:13 <phlpp> ah, i see my problem :D
06:53:15 <mauke> @src on
06:53:15 <lambdabot> (*) `on` f = \x y -> f x * f y
06:53:22 <phlpp> i tried to do the lambda with only one arg..
06:53:25 <davidL> @src comparing
06:53:25 <lambdabot> Source not found.
06:53:45 <byorgey> phlpp: ah, yes, that would be a problem =)
06:53:54 <phlpp> :D
06:55:17 <mauke> > nubBy (\x -> (fst x ==) . fst) [(1,2),(1,3),(2,3),(3,2),(2,1)]
06:55:18 <lambdabot>  [(1,2),(2,3),(3,2)]
06:56:17 <phlpp> @pl \s -> nubBy ((==) `on` fst) (zip s (p s))
06:56:17 <lambdabot> nubBy ((==) `on` fst) . ap zip p
06:56:33 <Toxaris> :t Data.Map.toList . foldr (uncurry $ Data.Map.insertWith const) Data.Map.empty -- if you don't care for the ordering of the result
06:56:34 <lambdabot> forall a a1. (Ord a) => [(a, a1)] -> [(a, a1)]
06:57:04 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/5096#a1
06:57:19 <Toxaris> (and have Ord, and don't need laziness)
06:59:01 <LoganCapaldo> what is that, a list  with a statically checked length?
06:59:26 <byorgey> yep
06:59:35 <LoganCapaldo> madness
07:00:18 <mauke> MADNESS?!
07:00:32 <byorgey> uh-oh, you made mauke mad
07:01:15 <phlpp> hmm, p (x:xs) = [((+1) $ length $ filter (==x) xs)] ++ p xs where p [] = [] seems to be quite ugly
07:01:29 <phlpp> anyone got a neater solution?
07:02:08 <LoganCapaldo> @type count
07:02:10 <lambdabot> Not in scope: `count'
07:02:14 <LoganCapaldo> blast
07:02:19 <phlpp> :D
07:02:28 <Botje> phlpp: is tehre a good reason for the [] ?
07:03:11 <Toxaris> phlpp: on the surface level: use succ instead of (+1), use (... : ...
07:03:15 <phlpp> actually, no :>
07:03:27 <Toxaris> phlpp: (... : ...) instead of ([...] ++ ...)
07:03:47 <Botje> and you could use 1+sum (fromEnum . (==x)) xs
07:04:02 <byorgey> > let p (x:xs) = [((+1) $ length $ filter (==x) xs)] ++ p xs; p [] = [] in p [1,3,3,4,6,6,2,1,1,6,5]
07:04:06 <lambdabot>  [3,2,1,1,3,2,1,2,1,1,1]
07:04:34 <byorgey> phlpp: what is p supposed to do?
07:04:54 <phlpp> counting probabilites for every a in [a].. that's why i asked for the nubBy stuff
07:05:10 <Toxaris> phlpp: maybe use a foldr over tails
07:05:21 <LoganCapaldo> > let p [] = [] ; p as@(x:xs) = sum . map (const 1) $ filter (==x) as : p xs in p [1,3,3,4,6,6,2,1,1,6,5]
07:05:27 <lambdabot>   add an instance declaration for (Num [[t]])
07:05:27 <lambdabot>     In the expression:
07:05:27 <lambdabot>         ...
07:05:28 <phlpp> in another function, the 'real' function its like \s -> nubBy ((==) `on` fst) $ zip s (p s)
07:05:37 <LoganCapaldo> mmm
07:05:43 <byorgey> phlpp: well, that version doesn't seem to work correctly (?)
07:05:46 <Botje> LoganCapaldo: map (const 1) . filter (==x) ~~ map (fromEnum . (==x))
07:06:12 <LoganCapaldo> tru that
07:06:13 <phlpp> byorgey: why?
07:06:32 <byorgey> phlpp: well, unless I'm not understanding what p is supposed to do
07:06:40 <byorgey> phlpp: what should p [1,1,1] be?
07:07:13 <LoganCapaldo> > let p [] = [] ; p as@(x:xs) = (sum . map (fromEnum . (==x)) as) : p xs in p [1,3,3,4,6,6,2,1,1,6,5]
07:07:14 <lambdabot>  Couldn't match expected type `a -> [a1]'
07:07:31 <Botje> sum $ map
07:07:33 <LoganCapaldo> > let p [] = [] ; p as@(x:xs) = (sum $ map (fromEnum . (==x)) as) : p xs in p [1,3,3,4,6,6,2,1,1,6,5]
07:07:34 <lambdabot>  [3,2,1,1,3,2,1,2,1,1,1]
07:07:36 <LoganCapaldo> i know
07:07:36 <Botje> yeah :)
07:07:41 * LoganCapaldo is an idiot
07:07:49 * Botje is not fully awake yet
07:08:03 <phlpp> byorgey: the problem is the following: imagine a string or sth. like that, and now you want to count the probability of each char. p was the first step to get a solution, but i soon noticed, that it counts the probabilites for every char, no matter if the entry is already there
07:08:33 <phlpp> so if we have "ABACABA", the second 'A' entry would only count 3 'A's
07:08:44 <phlpp> (because of the recursion, it doesn't recognize the "head")
07:08:46 <byorgey> phlpp: right
07:08:54 <Botje> phlpp: why not use group . sort ?
07:09:03 <Botje> > group $ sort "ABACABA"
07:09:04 <lambdabot>  ["AAAA","BB","C"]
07:09:26 <Botje> then just divide the length of each list by the total length of your string, and you have the probability
07:09:29 <byorgey> > (head &&& length) . group . sort $ "ABACABA"
07:09:29 <phlpp> so i thought that i just need sth. like unique (so in haskell nubBy) to drop the other 'A' entries
07:09:30 <lambdabot>  ("AAAA",3)
07:09:37 <byorgey> > map (head &&& length) . group . sort $ "ABACABA"
07:09:38 <lambdabot>  [('A',4),('B',2),('C',1)]
07:09:40 <phlpp> because i can be _sure, that the first entry for an 'A' is always the right one
07:09:50 <phlpp> right = correct
07:10:14 <mauke> > M.fromList []
07:10:15 <lambdabot>  fromList []
07:10:21 <phlpp> Botje: hehe, thanks
07:11:23 <mauke> > M.fromListWith (+) . map (flip (,) 1) $ "ABACABA"
07:11:23 <lambdabot>  fromList [('A',4),('B',2),('C',1)]
07:11:28 <mauke> > M.toList . M.fromListWith (+) . map (flip (,) 1) $ "ABACABA"
07:11:29 <lambdabot>  [('A',4),('B',2),('C',1)]
07:12:23 <phlpp> > (\s -> zip s (map length $ group $ sort s)) "ABACABA"
07:12:23 <lambdabot>  [('A',4),('B',2),('A',1)]
07:12:46 <phlpp> ah
07:12:59 <phlpp> > (\s -> zip (group$sort s) (map length $ group $ sort s)) "ABACABA"
07:13:04 <lambdabot>  [("AAAA",4),("BB",2),("C",1)]
07:14:14 <byorgey> ivanm: cool
07:15:30 <byorgey> > map (id &&& length) . group . sort $ "ABACABA"
07:15:32 <lambdabot>  [("AAAA",4),("BB",2),("C",1)]
07:16:07 <phlpp> > (\s -> zip (take 1$group$sort s) (map length $ group $ sort s)) "ABACABA"
07:16:09 <lambdabot>  [("AAAA",4)]
07:16:41 <phlpp> > (\s -> zip (map (take 1) group$sort s) (map length $ group $ sort s)) "ABACABA"
07:16:42 <lambdabot>  Couldn't match expected type `[[a]]'
07:16:49 <byorgey> phlpp: see above, &&& from Control.Arrow makes this a lot nicer
07:17:28 <phlpp> :t id&&&length
07:17:30 <lambdabot> forall a. [a] -> ([a], Int)
07:17:33 <LoganCapaldo> > map (\x -> (x, length x)) . group . sort $ "ABACABA"
07:17:34 <lambdabot>  [("AAAA",4),("BB",2),("C",1)]
07:17:50 <phlpp> LoganCapaldo: ah...
07:18:01 <byorgey> phlpp: it's a general Arrow combinator, but in this case (for the (->) instance of Arrow), we have f &&& g = \x -> (f x, g x)
07:18:03 <EvilTerran> > (zip <$> map (take 1) <*> map length) . group . sort $ "abracadabra"
07:18:03 <lambdabot>  [("a",5),("b",2),("c",1),("d",1),("r",2)]
07:18:21 <phlpp> byorgey: arrow reminds me of: "continue readinng 'conceptual mathematics'" :D
07:18:50 <EvilTerran> if you'd rather bludgeon Applicative than Arrow into doing your bidding ;)
07:18:51 <byorgey> phlpp: well, yes, that's its inspiration, but you don't need to understand category theory to understand Arrow =)
07:19:26 <byorgey> phlpp: a value of type (Arrow a) => a b c   represents a computation which has input type b and output type c
07:19:33 <byorgey> that's all there is to it =)
07:19:41 <EvilTerran> > f &&& g = (,) <$> f <*> g, ish
07:19:41 <lambdabot>  Parse error at "=" (column 9)
07:19:44 <phlpp> byorgey: yeah, that's maybe true. but nevertheless, category theory is interesting, at least the book is
07:19:48 <phlpp> :>
07:19:53 <byorgey> phlpp: oh, definitely =)
07:20:18 * byorgey is currently reading "category theory for the working mathematician"
07:20:39 <phlpp> hehe
07:21:23 <LoganCapaldo> @check (\xs -> all ((/=0) . length) (group xs)) :: [String] -> Bool
07:21:24 <lambdabot>  OK, passed 500 tests.
07:21:43 <LoganCapaldo> > group []
07:21:44 <lambdabot>  []
07:21:50 <LoganCapaldo> > []group []
07:21:50 <lambdabot>  Couldn't match expected type `([a] -> [[a]]) -> [a1] -> t'
07:21:58 <LoganCapaldo> > group [[]]
07:21:58 <lambdabot>  [[[]]]
07:22:27 <LoganCapaldo> I *guess* you can use head &&& length
07:22:36 <LoganCapaldo> if you want
07:22:42 <Saizan> ?src groupBy
07:22:42 <lambdabot> groupBy _  []       =  []
07:22:42 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
07:22:42 <lambdabot>     where (ys,zs) = span (eq x) xs
07:23:01 <phlpp> ok, thanks!
07:23:40 <LoganCapaldo> Saizan, proof by source code eh? :)
07:31:36 <Saizan> LoganCapaldo: yeah :)
07:31:49 <Saul_> byorgey: That append function at http://hpaste.org/5096#a1 doesn't work for some reason
07:33:04 <LoganCapaldo> It's funny, adts make me feel more confident about the "integrity" of my reasoning on such thaings. No such thing as an unitialized variable or a null pointer really makes life much simpler
07:34:00 <Saul_> byorgey: The Nil case is going wrong, it can't unify m and k for some reason
07:35:05 <byorgey> Saul_: hmm
07:35:07 * Saizan has always used a class for that append
07:36:33 <byorgey> Saul_: heh, I thought I had gotten this to work before, so I went and looked at the file where I did this stuff
07:36:47 <desegnis> LoganCapaldo, (/=0).length = not.null; but please, use the latter :-)
07:36:49 <byorgey> Saul_: and I found this comment above my (unfinished) append function:
07:37:02 <byorgey> -- bah! this doesn't work.
07:37:12 <Saul_> Well that's helpful :)
07:37:36 <LoganCapaldo> desegnis: you I thought of it like right after i wrote it
07:37:50 <LoganCapaldo> didn't seem to be worth running thetest again
07:37:56 <desegnis> hehe
07:38:09 <LoganCapaldo> s/you/yeah
07:38:37 <byorgey> Saul_: it may be possible to get it to work somehow, I'm not sure
07:38:55 <LoganCapaldo> it would be neat if there was some syntax to turn a "pattern" into a boolean function
07:38:58 <byorgey> Saul_: but ultimately to do this sort of thing properly you really want a language with dependent types.
07:39:14 <Saul_> This may be the result of the hack the haskell creators used to avoid higher order unification
07:39:37 <desegnis> LoganCapaldo, pattern guards are a little related
07:39:58 <byorgey> Saul_: what's that?
07:40:00 <LoganCapaldo> yeah but too verbose for that situation
07:40:09 <desegnis> yea
07:40:41 <Saul_> byorgey: I'm not sure what they did exactly, but they talked about it in Being Lazy with Class, a history of Haskell
07:40:42 <LoganCapaldo> something like all (~~[]) heh
07:40:54 <byorgey> Saul_: oh, ok
07:41:01 * byorgey goes to dig that out
07:41:08 * LoganCapaldo doesn't want to be the one to writ e that parser extension
07:41:33 <byorgey> Saul_: do you know what page?
07:41:39 <Saizan> however it works if you define append as a method of Plus
07:42:03 <Saul_> No it's been a while ago since I read it, I think it was the part about functional dependencies
07:45:25 <Saul_> byorgey: It actually had to do with higher-kinded polymorphism, my bad :)
07:45:40 <Saul_> page 19
07:46:27 <byorgey> Saul_: what section number?  I have a dead tree copy here and it doesn't have page numbers =)
07:47:10 <Saul_> I already closed it :(
07:47:18 <byorgey> oh, 6.4, I found it
07:47:23 <Saul_> ok
07:48:36 <byorgey> hm, I have no idea whether that's related to what we're seeing or not
07:48:58 <byorgey> Saul_: but anyway, did you try Saizan's suggestion?
07:49:12 <EvilTerran> LoganCapaldo, there's a proposal called "lambda match" that might be relevant
07:49:25 <Saul_> byorgey: Which one?
07:49:42 <Saul_> oh putting it in a class?
07:49:59 <Saizan> yeah, the Plus one
07:50:01 <Saul_> no I haven't, I'll try right now
07:50:17 <Saizan> you also need Nat c => as superclass
07:50:33 <phlpp> :t (~~)
07:50:35 <lambdabot> Not in scope: `~~'
07:53:49 <Saul_> Saizan: I'm not sure how, can you spell it out for me?
07:57:05 <Saizan> k
07:57:36 <hpaste>  Saizan annotated "(no title)" with "like this, with the rest untouched" at http://hpaste.org/5096#a2
08:01:02 <Saul_> Saizan: Thanks, that works
08:01:19 <LoganCapaldo> phlpp: i made it up
08:04:09 <oskarM> Saizan, Saul: could you hpaste complete code? I can't make it to work.
08:04:56 <hpaste>  Saizan annotated "(no title)" with "complete code" at http://hpaste.org/5096#a3
08:06:56 <phlpp> LoganCapaldo: ah ok
08:07:27 <LoganCapaldo> (since I was pretty sure it wasn'ta real symbol, as you discovered :))
08:08:14 <LoganCapaldo> > let (~~) = (++) in [1,2] ~~ [3,4] -- don't think it can be either
08:08:17 <lambdabot>  [1,2,3,4]
08:08:26 <LoganCapaldo> ah I gues sit can
08:11:45 <desegnis> Is anyone here at least barely familiar with the NumericPrelude?
08:12:19 <LoganCapaldo> @type (||) <$> (> 2) <*> (< 4)
08:12:20 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
08:12:55 <LoganCapaldo> > (||) <$> (> 2) <*> (< 4) $ 3
08:12:56 <lambdabot>  True
08:13:00 <LoganCapaldo> > (||) <$> (> 2) <*> (< 4) $ 2
08:13:01 <lambdabot>  True
08:13:09 <Saul_> Saizan: append doesn't seem to be the only function that has a different type for the Nil case than it does for the Cons case
08:13:19 <Saul_> reverse is also problematic
08:13:19 <oskarM> Saizan: thanks. Works.
08:13:19 <LoganCapaldo> > (&&) <$> (> 2) <*> (< 4) $ 2
08:13:19 <lambdabot>  False
08:13:38 <LoganCapaldo> mm methinks I like applicative
08:14:32 <olsner> LoganCapaldo: looks like perl code
08:14:40 <Saizan> Saul_: well, most of them need a class
08:14:43 <LoganCapaldo> bah
08:14:52 <LoganCapaldo> perl can't get nearly that consie ;)
08:14:56 <LoganCapaldo> *concise
08:15:06 <EvilTerran> > liftA2 (&&) (>2) (<4) 2
08:15:09 <lambdabot>  False
08:15:25 <olsner> liftA2 = liftM2 in this case?
08:15:29 <EvilTerran> <$> and <*> are all well-and-good in theory, but they are quite line-noisy
08:15:49 <desegnis> So, if anyone here *were* familiar with NumericPrelude, what would she answer if I asked why it names some classes "C", as opposed to something less cryptic?
08:15:50 <EvilTerran> olsner, yes; in most cases, in fact
08:16:06 <olsner> @ty <$>
08:16:06 <lambdabot> parse error on input `<$>'
08:16:10 <olsner> @ty (<$>)
08:16:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:16:12 <byorgey> olsner: yes
08:16:15 <EvilTerran> (in most cases where your Applicative is also a Monad, anyway)
08:16:24 <LoganCapaldo> desegnis: what is it, C, N, Z, etc.?
08:16:27 <Saul_> Saizan: It does make sense actually, since if you change the length of a list, the type changes
08:16:29 <LoganCapaldo> R?
08:17:02 <desegnis> LoganCapaldo, no, it is C, C, C etc.
08:17:05 <desegnis> in different modules
08:17:15 <LoganCapaldo> well so much for my theory :)
08:17:19 <desegnis> So you have Additive.C, Ring.C, ...
08:17:21 <olsner> @ty (<*>)
08:17:22 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:17:41 <EvilTerran> <$> = fmap = liftM
08:17:43 <EvilTerran> <*> = ap
08:17:47 * LoganCapaldo thought they migh be using the symbols like Z for the integers, |R for the reals, etc.)
08:18:14 <desegnis> yea I guessed that. but it seems they use C for class
08:18:56 <desegnis> maybe they thought that Ring.Ring would be even worse than Ring.C...
08:19:24 <desegnis> But then they would have to introduce Map.T, to be consequent :)
08:20:32 <olsner> hmm, is there a functional lanugage/haskell dialect with functions as a type class?
08:21:27 <LoganCapaldo> How'd you write instances for that?
08:21:47 * vincenz doesn't even know what that means
08:22:29 <LoganCapaldo> class Function f where apply :: how do you not write the type of apply in terms of Function?
08:22:49 <LoganCapaldo> I may be totally misunderstanding ofc
08:22:49 <olsner> I think you'd need some kind of primitive for RawFunction
08:22:56 <LoganCapaldo> I usually am, in here :)
08:24:37 <LoganCapaldo> also, what's the utility? why not pass around (apply nonRawFunction) and not need the type class?
08:25:02 <vincenz> there's a way to do this, olsner
08:25:04 <olsner> I'm thinking you'd use it to overload ordinary function application for Functor, so that the above line would become just (&&) (> 2) (< 4) 2
08:25:08 <vincenz> olsner: defunctionalize the unction
08:25:13 <vincenz> function even
08:25:19 <vincenz> then make a typeclass for the data type
08:25:27 <LoganCapaldo> olsner: oah
08:25:54 <olsner> and function application (f x) would be sugar for (f $ x) or (apply f x) where apply or $ comes from the type class
08:26:00 <LoganCapaldo> that makes sense, but in my otally uninformed opinion seems liek it would hurt the type checker
08:26:26 <olsner> probably would
08:26:36 <LoganCapaldo> how do you know I didn't just screw up and didn't mean to use the functor instance hwhen I do something liek (&&) (< 2) ..
08:27:50 <desegnis> Well, you could define ($$) = ($) :: (a -> b) -> a -> b
08:28:06 <desegnis> but debugging could still be fun then
08:29:53 <ski_> f x
08:29:56 <ski_> f $ x
08:30:10 <ski_> ($) $ f $ x
08:30:33 <ski_> ($) $ (($) $ ($) $ f) $ x
08:30:40 <ski_> ad nauseum
08:31:40 * ski_ dislikes `<*>' being a symmetric operator
08:32:17 <EvilTerran> i'm guessing "f x would be shorthand for apply f x" in the same way "12 is shorthand for fromInteger 12" works ATM
08:32:19 <EvilTerran> (or whatever it is)
08:33:16 <EvilTerran> in that, in the second case, the appearance of "12" in "fromInteger 12" doesn't literally mean that token, but the actual Integer value represented by it
08:33:25 <idnar> :t apply
08:33:27 <lambdabot> Not in scope: `apply'
08:33:38 <EvilTerran> it doesn't exist, we're speaking in hypotheticals here ;)
08:35:17 <ski_> [< [> (> 2) <] && [> (< 4) <] >] 2
08:35:23 <byorgey> roconnor: is there a video of your talk?
08:35:36 <ski_> [< ( [> (> 2) && [> (< 4) ) 2
08:35:41 <ski_> or something there-alike
08:35:43 <EvilTerran> what
08:35:52 <byorgey> my eyes!
08:36:12 <ski_> (yes, i *know* the concrete syntax is not the best !)
08:36:24 <EvilTerran> i have no idea what that's meant to mean
08:36:44 <ski_> reify ( reflect (> 2) && reflect (< 4) ) 2
08:36:54 <ski_> is that easier for your eyes ?
08:36:57 <EvilTerran> ah, i see. you're trying to use []s as parts of operators.
08:37:06 <roconnor> byorgey: nope :(
08:37:16 <byorgey> roconnor: oh, too bad =(
08:37:19 <EvilTerran> or as magic syntax or something
08:37:37 <ski_> this would be new syntax, yes
08:37:53 <byorgey> roconnor: your slides look really interesting, but there's not quite enough detail for me to infer the content of your talk =)
08:38:00 <ski_> (> 2) :: (Int -> ) Bool
08:38:11 <EvilTerran> @let infixl 1 <|, |>; (<|) = flip (<$>); (|>) = (<*>)
08:38:12 <lambdabot> <local>:19:17:     Multiple declarations of `L.<|'     Declared at: <local>:1...
08:38:20 <EvilTerran> @undef
08:38:21 <ski_> reflect (> 2) :: Bool  -- with effect `(Int ->)'
08:38:22 <lambdabot> Undefined.
08:38:23 <EvilTerran> @let infixl 1 <|, |>; (<|) = flip (<$>); (|>) = (<*>)
08:38:23 <lambdabot> <local>:1:29: Not in scope: `<$>'  <local>:1:43: Not in scope: `<*>'
08:38:30 <byorgey> roconnor: but perhaps I just need to use a better talk-inference algorithm
08:38:32 <EvilTerran> whaa
08:39:29 <EvilTerran> @let infixl 1 <|, |>; (<|) = flip (Control.Applicative.<$>); (|>) = (Control.Applicative.<*>)
08:39:29 <lambdabot> <local>:1:29: Not in scope: `Control.Applicative.<$>'  <local>:1:63: Not in s...
08:39:33 <roconnor> byorgey: I think the takahashi method doesn't lend itself to slides than can be read by themselves.
08:39:38 <roconnor> too bad
08:39:43 <EvilTerran> @let infixl 1 <|, |>; (<|) = flip fmap; (|>) = ap -- weird...
08:39:43 <lambdabot> <local>:1:29:     Ambiguous type variable `f' in the constraint:       `Funct...
08:39:56 <EvilTerran> oh, sod it.
08:39:58 <EvilTerran> @undef
08:39:58 <lambdabot> Undefined.
08:40:36 <byorgey> roconnor: indeed. I'm not complaining, the slides look great, and I hate presentations where people just read their slides =)
08:40:44 <ski_> EvilTerran : anyway, the idea being to have side-effecting expressions
08:40:53 <EvilTerran> the plan was that (>2) <| (&&) |> (<4) $ x, say, would work
08:40:58 <roconnor> Maybe I can use my camera to record my talks ...
08:41:11 <roconnor> actually I can certainly use it to record the audio
08:41:17 <roconnor> I should do that from now on.
08:41:46 <EvilTerran> or [1,2,3] <|(+)|> [4,5,6]
08:41:55 <roconnor> or maybe I can use my laptop itself
08:42:13 <gio123> ski_: could u pm for 1 minute
08:42:13 <ski_> roconnor : john hughes used some kind of software to record audio, and screen capturing
08:42:15 <LoganCapaldo> that looks like a doomsday device
08:42:19 <mattam> roconnor: good idea
08:42:23 <EvilTerran> or even [1,2,3] <|(,,)|> [4,5,6] |> [7,8,9], altho that's abusing it a bit
08:42:56 <swiert> if I have QuickCheck 1 and QuickCheck 2 installed on my machine, how can I make sure that a file imports a specific version of QC?
08:43:14 <swiert> I realize that I can write a cabal file, but I just want to run some simple tests.
08:43:42 <LoganCapaldo> > (,,) <$> [1,2,3] <*> [4,5,6] <*> [7,8,9]
08:43:43 <lambdabot>  [(1,4,7),(1,4,8),(1,4,9),(1,5,7),(1,5,8),(1,5,9),(1,6,7),(1,6,8),(1,6,9),(2,...
08:43:53 <roconnor> ski_: oh nice
08:44:00 * hgolden is back
08:44:07 <mattam> roconnor: But you may consider putting less function definitions in your slides...IIRC the types 06 talk you made had 20 or so
08:44:28 <mattam> hi swiert
08:44:37 <swiert> hi mattam.
08:44:40 <swiert> how are you?
08:44:59 <ski_> roconnor : he also use some kind of "scratch-pen", in powerpoint, iirc, to mark and draw arrows and things while talking
08:44:59 <mattam> fine, i'm enjoying portland right now.
08:45:09 <mattam> and you ?
08:45:23 <swiert> mattam: ah, of course! I forgot you were there now.
08:45:29 <syscrash> ski_: what would probably be a tablet pc or something
08:45:33 <gio123> ski_: i pasted output in ur pm
08:45:35 <swiert> mattam: What are you working on with Andrew?
08:47:08 <mattam> He's shown me how he used Program to define garbage collectors in Coq and do proofs on them.
08:47:23 <byorgey> mattam: are you at Galois?  or PSU?
08:47:29 <mattam> They're written in simply-typed, monadic style.
08:47:30 <mattam> PSU
08:47:44 <swiert> mattam: cool! Does he extract code?
08:48:26 <mattam> Yep, and with an unsafe extraction he gets really imperative code.
08:48:54 <swiert> mattam: Did I mention that I've used Program to write (the easy parts of) XMonad in Coq?
08:49:11 <swiert> mattam: and prove a few of their QuickCheck properties :)
08:49:11 <pejo> mattam, what kind of things do you prove for the GC's? And how much work is it?
08:49:42 <byorgey> swiert: hey, that's pretty cool =)
08:50:08 <mattam> Problem is, he always asserted that his recursive definitions were ok using Program and admitting obligations but then with the current form of his programs it is not really ok to do that.
08:50:13 <mattam> swiert: sweet !
08:51:02 <mattam> pejo: currently they prove partial correctness. And it's a lot of work I think, but I don't have numbers.
08:51:13 <swiert> mattam: yeah, the Haskell code extraction isn't too bad...
08:51:48 <mattam> swiert: it's not that good either. I anticipate I'll have to look at that for a correct typeclasses extraction.
08:51:54 <swiert> mattam: but I'd like it to be even better.
08:52:13 <olsner> regarding the continuous expansion of ($) $ (($) $ ($) $ f) $ x, sooner or later you should end up with the $ instance for "raw functions" which invokes some primitive operation
08:52:17 <olsner> I haven't entirely figured this out in detail, but there's definitely compiler magic in the bottom ;-)
08:52:24 <swiert> mattam: It can't really compete with hand-written Haskell. I'd like to specify things like strict constructor fields, for example.
08:53:45 <mattam> They had these gcs written in assembly that they certified and now they move to c-minor like languages. The main tool is separation logic in the specs and some tactics to sort it out in your proofs.
08:54:11 <mattam> swiert: Extraction directives...
08:54:39 <swiert> mattam: there's some stuff you can customize already, but not enough.
08:54:48 <mattam> Actually I'd find it cleaner than specifying that directly in the constructors.
08:55:37 <mattam> Indeed. But the extraction code is ok I think, it should not be too hard to extend.
08:56:30 <swiert> mattam: so how long are you in Portland for? Will you be coming to the dep typed workshop in Notts?
08:56:36 <mattam> swiert: I'll be in Nottingham...
08:56:41 <mattam> next month
08:56:57 <mattam> maybe I'll stay a bit more
08:57:12 <mattam> I'm leaving for Boston tomorrow
08:57:13 <swiert> mattam: it should be fun. I'm quite looking forward to it.
08:57:40 <mattam> Yep indeed. Should be exciting.
08:58:19 <mattam> I hope 8.2 will be released by this time.
08:59:49 <swiert> mattam: coq?
09:00:07 <mattam> Yes.
09:01:27 <swiert> mattam: with type classes :)
09:01:38 <mattam> Yeah.
09:02:36 <mattam> Dependent type classes ftw !
09:04:13 <swiert> hehe.
09:04:34 <swiert> mattam: did I tell you Nils Anders just started in Nottingham last week?
09:04:38 <mattam> I've extended the idea quite a bit and now you can write things like " forall A B [ Eq (A -> B) ] (f g : A -> B), f == g. "
09:05:13 <mattam> swiert: I just got an email back from him saying he started with Graham. I guess you know about his parsers too.
09:05:27 <swiert> mattam: the dependently typed programmers are flocking to Nottingham :)
09:05:43 <swiert> mattam: I've heard of the parsers, but never seen any code.
09:05:48 <mattam> hehe
09:06:02 <mattam> They're actually very nice.
09:08:11 <mattam> There's some great type hackery to make the thing terminating.
09:09:25 <mattam> You have to know if a non-terminal may be empty or not to know if you can do left recursion basically.
09:11:31 <swiert> mattam: yes, so I gather. It's a nice idea; I should ask him about it some time.
09:16:15 * hgolden is away: 1 hour
09:17:52 <swiert> mattam: have to run, ttyl.
09:20:14 <EvilTerran> is it possible to have a partially applied type synonym in an instance head?
09:20:34 <EvilTerran> thinking of type O f g a = f (g a), in particular
09:20:53 <twanvl> no
09:20:57 <litb> ok, so pattern matching does always cost somewhat at runtime?
09:21:16 <litb> but if i ahve another datatype, it doesn't cost at runtime?
09:24:44 <Saizan> litb: can you explain better? types are erased at compile time if that's what you're asking
09:24:59 <integral> @hoogle Data.Set.Set (Data.Set.Set x) -> Data.Set.Set x
09:24:59 <lambdabot> No matches, try a more general search
09:25:18 <byorgey> litb: pattern matching does cost something at run time, except in cases where data constructors can be optimized away
09:25:31 <litb> ah, i see
09:25:35 <byorgey> for example, with newtypes or strictness analysis+unboxing
09:25:52 <litb> well, i have two constructors to distinguish form a non-deriverable function and a deriverable one
09:26:27 <byorgey> litb: are they newtypes?
09:27:12 <EvilTerran> integral, (fold union empty)?
09:27:19 <litb> byorgey: i haven't looked into newtypes yet, byorgey
09:27:26 <integral> ah, that's a handy one
09:27:34 <litb> i intended to place a String (name) and a Double->Double (function) there
09:27:36 * integral really wants Set.concatMap
09:27:38 <EvilTerran> ?type Data.Set.fold Data.Set.union Data.Set.empty
09:27:39 <lambdabot> forall a. (Ord a) => Data.Set.Set (Data.Set.Set a) -> Data.Set.Set a
09:27:53 <litb> and, if it is deriverable, place another Double->Double (deriverative) there
09:28:16 <EvilTerran> ?type Data.Set.unions . Data.Set.toList
09:28:17 <lambdabot> forall a. (Ord a) => Data.Set.Set (Data.Set.Set a) -> Data.Set.Set a
09:28:23 <byorgey> litb: oh, I see.  newtype really isn't applicable then.
09:28:35 <byorgey> litb: why are you worried about the runtime cost of pattern-matching?
09:28:43 <litb> byorgey: or would two datatypes better then?
09:28:43 <EvilTerran> integral, hankering for a Set Monad?
09:28:50 <integral> oh yes.
09:29:12 <litb> byorgey: i'm still new to haskell, and i wonder whether there are better ways, i.e whether i'm doing it wrong
09:29:27 <EvilTerran> integral, i believe you can get that in ghc with -XNoImplicitPrelude and a bit of hackery
09:29:40 <byorgey> litb: I very much doubt you're doing it "wrong" =)
09:29:40 <EvilTerran> the problem is the Ord constraint on elements
09:29:45 <integral> erk.  I was hoping to stick to non-GHc extensions :-)
09:29:48 <litb> byorgey: because pattern matching seem to be a way to react at runtime to something
09:30:06 <byorgey> litb: sure, that's one way to look at it.
09:30:09 <litb> but in my case, whether or not a function is deriverable can be determined at compile time
09:30:10 <integral> the Ord constraint is annoying anyway.  My objects can be ordered, but shouldn't really be thought of as
09:30:27 <EvilTerran> class Return m where return :: a -> m a; class Bind m where (>>=) :: m a -> (a -> m b) -> m b
09:30:28 <araujo> hello
09:30:28 <larmeh_> main = do str <- getLine <-- why wouldn't this work? i get an error "the last statement in a 'do' construct must be an expression"
09:30:41 <kpreid> larmeh_: you need to do something after that
09:30:54 <EvilTerran> er... waitaminute
09:30:57 <Saizan> EvilTerran: you need mptcs
09:30:58 <litb> larmeh_: you don't have an expression
09:31:06 <EvilTerran> class Return m a where return :: a -> m a; class Bind m a b where (>>=) :: m a -> (a -> m b) -> m b
09:31:15 <larmeh_> kpreid: e.g. recursively calling 'main'?
09:31:25 <kpreid> larmeh_: sure, you could do that
09:31:37 <EvilTerran> instance Return Set a where return = singleton; instance (Ord a, Ord b) => Bind Set a b where ...
09:31:38 <kpreid> or just 'return ()'
09:31:39 <litb> larmeh_: str<-getline is similar to "getline >>= " .. and then it requires an exception to know where to bind that into
09:31:42 <litb> AFAIK
09:31:47 <byorgey> seems kind of pointless though. =)  How about 'print str' ?
09:31:48 <litb> i hope i got it right this time :)
09:32:03 <byorgey> litb: an exception?
09:32:13 <larmeh_> kpreid: main = do str <- getLine main <-- this produces the same error
09:32:15 <litb> errm, expression
09:32:15 <EvilTerran> instance Monad m => Return m a where return = Prelude.return; instance Monad m => Bind m a b where (>>=) = (Prelude.>>=)
09:32:24 <byorgey> litb: ah, right =)
09:32:35 <kpreid> larmeh_: you have do syntax wrong. you need a semicolon or a line break
09:33:53 <litb> i think that is translated to "getLine >> return ()" which becomes "getLine >>= \_ -> return()"
09:34:08 <oskarM> > let main = do str <- getLine; putStrLn str
09:34:08 <lambdabot>  Parse error at end of input
09:34:08 <litb> errm, \str -> return() of course
09:34:27 <byorgey> litb: another idea would be to have something like data Func = Func String (Double -> Double) (Maybe (Double -> Double))
09:34:46 <litb> byorgey: ah, yes. i did that too before
09:34:59 <byorgey> litb: since otherwise it seems to me that you're going to basically end up re-implementing the functionality of Maybe =)
09:35:02 <larmeh_> kpreid: alright, a semicolon works but a line break yields the same error... i'm guessing 'main' needs to be indented, right?
09:35:23 <litb> byorgey: but somehow i disliked that, since it also would require pattern matching to error out if one passes a non-deriverable to derive
09:35:36 <litb> byorgey: oh i see
09:35:38 <byorgey> larmeh_: yes, 'main' needs to be indented to the same column as the 'str'
09:35:44 <litb> byorgey: maybe that Maybe stuff is right here
09:36:04 <litb> and i could always use fromMaybe to get the function and it would error out itself
09:36:28 <byorgey> litb: you could do it via pattern-matching, but there is also lots of machinery to let you use Maybe in nice ways, e.g. the Maybe monad
09:36:29 <larmeh_> byorgey: that cleared things up, thanks
09:37:03 <byorgey> > do x <- Just 3 ; y <- Just 5 ; return (x + y)
09:37:05 <lambdabot>  Just 8
09:37:10 <byorgey> > do x <- Just 3 ; y <- Nothing ; return (x + y)
09:37:11 <lambdabot>  Nothing
09:37:16 <litb> byorgey: uh, i'm a very monad beginner. i hope it's not too hard to fiddle with Monad Maybe a
09:37:17 <radix> anyone know of a haskell ray tracer that can take advantage of concurrency in one of the common haskell implementations?
09:37:38 <byorgey> litb: no, in fact, it's probably a good way to ease into monads.
09:37:49 <byorgey> > liftM2 (+) (Just 3) (Just 5)
09:37:50 <lambdabot>  Just 8
09:37:55 <byorgey> > liftM2 (+) (Just 3) (Nothing)
09:37:55 <lambdabot>  Nothing
09:38:12 <litb> 3 + Nothing is Nothing ? lol
09:38:30 <byorgey> litb: exactly! the Maybe monad allows you to build up computations which may fail, out of smaller computations which may fail.
09:38:41 <Tac-Tics> > 3 + Nothing
09:38:41 <lambdabot>   add an instance declaration for (Num (Maybe a))
09:38:41 <lambdabot>     In the expression: 3 + ...
09:38:45 <byorgey> litb: if any of the component computations fail, so does the entire computation.
09:39:25 <litb> hm, that would be (Just 3) >>= \x -> (Just 5) -> \y -> return (x + y) .
09:39:31 <byorgey> well, of course 3 + Nothing isn't *literally* Nothing, but that's the right intuition -- since the computation of the second argument to + failed, so does the + computation
09:39:32 <litb> @src Monad Maybe a
09:39:32 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:39:35 <litb> darn
09:39:42 <byorgey> @src Maybe return
09:39:42 <lambdabot> return              = Just
09:39:42 <litb> @src Maybe a Monad
09:39:43 <lambdabot> Source not found. I am sorry.
09:39:45 <litb> ah
09:39:50 <byorgey> @src Maybe (>>=)
09:39:50 <lambdabot> (Just x) >>= k      = k x
09:39:50 <lambdabot> Nothing  >>= _      = Nothing
09:40:18 <Cin> what's a good way to write a dynamic web page in haskell?
09:40:34 <Tac-Tics> @where happs
09:40:35 <lambdabot> http://happs.org
09:40:54 <Japsu> @where wash
09:40:54 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
09:41:02 <litb> i see. that's nice
09:41:09 <Japsu> @where cgi
09:41:09 <lambdabot> I know nothing about cgi.
09:41:17 <Japsu> @go haskell cgi
09:41:18 <lambdabot> http://www.geocities.com/laitenberger/haskell/CGI/
09:41:18 <litb> but i don't see yet how monads can help with my integration stuff =)
09:41:18 <lambdabot> Title: Haskell CGI Library
09:41:25 <Japsu> @go haskell fastcgi
09:41:26 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fastcgi
09:41:27 <litb> maybe i need to think about it littl longer
09:42:02 <Cin> i see
09:42:08 <Cin> has anyone actually tried any of this?
09:42:29 <byorgey> litb: well, suppose you have the function add :: (Double -> Double) -> (Double -> Double) -> Double -> Double which adds two functions together
09:42:58 <byorgey> litb: then to add two values of type Maybe (Double -> Double), you can just say liftM2 add
09:43:03 <litb> perhaps in my integrate function, i make a helper function which accepts (Double -> Double) . then i call that helper function with "deriveration >>= h" , h is the helper
09:43:07 <scodil> is there a way to sort of lump together type constraints? Like if I have a bunch of functions that need Eq, Ord, and Show, can I define some auxiliary class, call it EOS, so that if I make type x an instance of EOS then it automatically gets Eq, Ord and Show? Just to cut down on typing?
09:43:19 <litb> and then, it will return Nothing if the user pass a non-integratable function to it
09:44:13 <Lemmih> scodil: Not really.
09:44:23 <scodil> bummer
09:44:25 <byorgey> litb: that's the right idea, I think.
09:44:30 <resiak> Can't you do it with instance EOS a => Eq a ?
09:45:15 <scodil> isn't that overlapping?
09:45:22 <Lemmih> Cin: HAppS isn't very usable right now.
09:45:52 <litb> or maybe deriveration >>= (return . h); to make it comply with (>>=) (it needs to return m a i think)
09:47:21 <byorgey> litb: that's right.
09:47:33 <litb> yeah, i seem to get into it, finally.
09:47:35 <byorgey> litb: which is the same as liftM h derivation.
09:47:37 <gio123> if if we remove from calculus subsumption rules does it affects to soundness of calculus?
09:47:50 <litb> oh, i see
09:47:53 <byorgey> litb: i.e. it applies h "inside" the monad
09:48:19 <byorgey> which is also the same as fmap h derivation =)
09:48:30 <litb> lolz
09:48:41 <litb> can i somehow let it call error if the result is Nothing?
09:48:55 <byorgey> litb: why would you want it to call error?
09:49:18 <Tac-Tics> case x of Nothing -> error "Result was nothing"; Just x -> x
09:49:24 <litb> or should i let the caller do this? but i mean, if the caller "tries" to deriverate a non-deriveratable function, i consider that as a logical error
09:49:43 <byorgey> litb: then let it return Nothing.
09:49:57 <litb> ok, i see. maybe that is the right thing to do.
09:50:11 <Tac-Tics> Always opt for maybe over partial functions
09:50:19 <Tac-Tics> errors in pure Haskell code are gross
09:50:26 <litb> ah i see
09:50:59 <Tac-Tics> Use maybe whenever you'd have a NULL return value in a C-like language
09:51:06 <gio123> if if we remove from calculus subsumption rules does it affects to soundness of calculus?
09:51:25 <olsner> heh, mod_rewrite's rewrite rules are probably turing complete if you allow an infinite number of redirects
09:51:30 <litb> Tac-Tics: in this case, i would better call assert in a C-like language
09:53:05 <Tac-Tics> If that's the case, then error might be the better choice. But depending on what you're doing, it might be better practice to use a maybe, and then error if the result is nothing
09:53:08 <byorgey> litb: having a program crash when you make a logic error is very un-haskell-like.
09:53:44 <radix> hmm. HRay doesn't seem to be concurrent.
09:53:51 <byorgey> litb: usually you would rather (a) have the possibility of error explicitly encoded in the return type (i.e. Maybe), or (b) do something in the type system to make that sort of logic error a type error that will be caught at compile-time instead of run-time.
09:53:56 <Tac-Tics> litb: there's fromJust to do what you want
09:54:06 * hgolden is back
09:54:12 <gio123> if if we remove from calculus subsumption rules does it affects to soundness of calculus?
09:54:26 <Tac-Tics> @let myHead [] = Nothing; myHead (x:_) = x
09:54:29 <lambdabot> Defined.
09:54:31 <byorgey> hi hgolden
09:54:39 <Tac-Tics> > fromJust (myHead [1,2,3])
09:54:39 <lambdabot>   add an instance declaration for (Num (Maybe a))
09:54:40 <lambdabot>     In the expression: 3
09:54:47 <Tac-Tics> bah
09:54:58 <Tac-Tics> @let myHead [] = Nothing; myHead (x:_) = Just x
09:54:58 <lambdabot> <local>:2:36:     Occurs check: cannot construct the infinite type: a = Maybe...
09:55:09 <Tac-Tics> well damn
09:55:31 <byorgey> Tac-Tics: maybe it's confused because of the previous definition of myHead?
09:55:36 <Tac-Tics> yeah, maybe
09:55:38 <Tac-Tics> @unlet
09:55:39 <lambdabot> Defined.
09:55:53 <Tac-Tics> I suck at lambdabot today =-(
09:56:01 <litb> Tac-Tics: ah, thxx
09:56:10 <Tac-Tics> > fromJust (Just 6)
09:56:11 <lambdabot>  6
09:56:13 <Tac-Tics> > fromJust Nothing
09:56:13 <lambdabot>  Exception: Maybe.fromJust: Nothing
09:56:39 <litb> i wonder whether it is hard to do exceptions. but for now, i will avoid to learn it
09:56:42 <Tac-Tics> that will throw the error for you, but keep it out of your function's logic
09:57:01 * byorgey has never bothered learning about exceptions
09:57:04 <Tac-Tics> exceptions are something you really only want to do in IO, and even then, you don't want to use them
09:57:29 <Tac-Tics> @where awkward squad
09:57:29 <lambdabot> I know nothing about awkward.
09:57:36 <byorgey> the only place you should really need exceptions is for dealing with FFI code and that sort of thing.
09:57:40 * Tac-Tics totally fails at lambdabot today
09:58:15 * byorgey pats Tac-Tics's shoulder sympathetically
09:58:17 <sclv> oh, speaking of which, library api question.
09:58:59 <sclv> hstringtemplate has some functions to generate stringtemplates from i.o., which involve doing the usual directory and file reads.
09:59:14 <sclv> this means that these functions can potentially throw the usual IO exceptions.
10:00:14 <sclv> the proper behavior is to let the exceptions propagate, right? because it's a library, we don't know how the user wants to deal with them.
10:01:18 <sclv> i'm tempted to catch them and wrap the result in an Either, which is what i'd do if it were just for me (or actually, just swallow them in a Maybe) but for a more general purpose API this seems like a bad idea, correct?
10:02:12 <byorgey> sclv: why not provide both?
10:02:38 <sclv> hmm... because if a user wants the second behavior, they can just wrap the thing in a catch block themselves?
10:02:55 <sclv> but if i only give the first and not the second, then they can't go the other way.
10:03:01 <BMeph> Morning, all, what's the topic today? :)
10:03:05 <sclv> s/second/first
10:03:09 <zipola> Evening, how do I use lists in pattern matching? Eg. I have a list a = [1,2,3] and then declare the two parameters function fun _ a = foo. Is is just like that or is there some magic?
10:03:09 <byorgey> but as a user who wanted that behavior I might not know how to properly wrap it in a catch block.
10:03:47 <byorgey> zipola: you mean you want function fun to return foo only if its second parameter is equal to [1,2,3]?
10:03:58 <zipola> byorgey, yes.
10:04:00 <sclv> byorgey: hmm, yeah, i guess, but what i'm really worried about is falling into the 8-ways-to-signal-errors trap.
10:04:06 <zipola> byorgey, actually no :D
10:04:07 <byorgey> zipola: ok, then that will not work.
10:04:17 <byorgey> zipola: ok, what would you like to do? =)
10:04:41 <zipola> byorgey, I want it to happen if the second parameter eg. Integer in this case is in the list.
10:04:44 * BMeph waves to zipola as he goes flying off of the Sphinx-guarded bridge...
10:04:47 <Codex_> zipola: fun (a : r) = f a : fun r
10:05:01 <byorgey> sclv: true.  I don't know, just a suggestion off the top of my head.  I've never written any such libraries myself...
10:05:31 <gregm> zipola: fun lis a | elem a lis = foo ?
10:05:35 <byorgey> zipola: in that case you might want something like  fun _ x | x `elem` a  = foo
10:05:52 <sclv> byorgey: i'm just sort of feeling my way through as i go myself. :-)
10:06:13 <zipola> byorgey, thanks, that looks something that should work.
10:06:27 <byorgey> sclv: hstringtemplate looks pretty cool though, I look forward to trying it out next time I need some sort of templating functionality. =)
10:07:21 <byorgey> zipola: note that if you use a variable name as a pattern, it matches anything, and shadows any previous definitions of that name.
10:07:41 <byorgey> zipola: so if you have a = [1,2,3];  fun a = foo;  the two different a's have nothing to do with each other.
10:08:02 <byorgey> the a in fun a = foo wouldn't even have to be a list.
10:08:31 <gio123> if if we remove from calculus subsumption rules does it affects to soundness of calculus?
10:08:33 <zipola> I'll be careful.
10:08:47 <byorgey> gio123: try #math.
10:26:51 <litb> is there some helper function to fix the Nth parameter to x ?
10:27:14 <litb> errm, no i think that doesn't exist
10:30:43 <RayNbow> <roconnor> eric's channel 9 interview was quite nice. <-- I just downloaded the file, which took quite some time (Channel9's servers aren't really fast at the moment)
10:32:29 <Nafai> RayNbow: I thought it was an interesting interview
10:37:03 <oskarM> litb: flip flip x does it for N=2
10:38:00 <s1d> -> Int -> Int -> Int
10:38:10 <MyCatVerbs> @hoogle [a] -> a -> [[a]]
10:38:11 <lambdabot> No matches, try a more general search
10:38:17 <MyCatVerbs> @hoogle a -> [a] -> [[a]]
10:38:18 <lambdabot> No matches, try a more general search
10:39:32 <RayNbow> Nafai: I'm currently watching it...
10:39:56 <Nafai> I finished watching it last night
10:40:12 * BMeph surfs over to channel9.msdn.com to see what the hubbub is about...
10:40:17 <RayNbow> oooh, Erik mentions SKI combinators... cute little things :)
10:42:10 <litb>  [("bisektion: ", \a b c -> bisektionMethode a b c (0, 2)), ("newton: ", \a b c -> newtonMethode a b c 2) ]
10:42:13 <litb> for example that
10:42:31 <MyCatVerbs> :t break
10:42:33 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
10:44:10 <MyCatVerbs> Is there an un-intersperse, please?
10:44:47 <litb> flip (flip (flip 2))  -- i suppose like this?
10:45:01 <olsner> intercalate <-> extracalate?
10:45:02 <Tac-Tics> flip (flip f) = f
10:45:21 <litb> oh
10:45:27 <Tac-Tics> I tried that already myself =-P
10:45:46 <litb> i did that wrong. darn it causes a headache to make that flipping right :)
10:47:22 <oskarM> > flip flip 3
10:47:23 <lambdabot>  Add a type signature
10:47:29 <oskarM> > :t flip flip 3
10:47:29 <lambdabot>   parse error on input `:'
10:47:46 <litb> @type flip flip 3
10:47:47 <lambdabot> forall a b c. (Num b) => (a -> b -> c) -> a -> c
10:47:50 <allbery_b> :t flip flip 3
10:47:51 <lambdabot> forall a b c. (Num b) => (a -> b -> c) -> a -> c
10:47:54 <litb> :p
10:48:06 <allbery_b> just showing proper use of :t
10:48:11 <oskarM> thx
10:48:17 <litb> heh, good to know
10:49:00 <allbery_b> general commands, "@" or "?"; run code, "> "; ":t" type, ":k" kind (others ignored)
10:49:20 <allbery_b> "> " is @run, ":t" is @type, ":k" is @kind
10:50:37 <oskarM> so we know how to fix the second parameter, but I can't scale it up for higer N
10:50:47 <litb> hm, it should rather be "a -> b -> c -> d"
10:50:58 <Tac-Tics> I'm sure it can be done with flips and uncurrying
10:51:08 <litb> but i guess i should stay with the lambda expression
10:51:12 <litb> oh
10:51:54 <litb> that's the type of question for people with IQ>140 o.O
10:53:06 <oskarM> :t curry . flip flip 3 . uncurry
10:53:07 <lambdabot> forall b c a b1. (Num b) => (a -> b1 -> b -> c) -> a -> b1 -> c
10:53:44 <oskarM> :t curry . curry . flip flip 3 . uncurry . uncurry
10:53:44 <lambdabot> forall b c b1 a b2. (Num b) => (a -> b2 -> b1 -> b -> c) -> a -> b2 -> b1 -> c
10:54:39 <mauke> :t uncurry.uncurry
10:54:40 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
10:55:24 <litb> i'm out of that guru game :D
10:56:00 <oskarM> it seems to do the job, but is it really simpler than just lambda-and-pointrwise code?
10:56:01 <Tac-Tics> I think I found fix3rd
10:56:43 <Tac-Tics> @let fix3rd f = (\x -> curry (flip (uncurry f) x) )
10:56:45 <lambdabot> Defined.
10:57:03 <Tac-Tics> > fix3rd foldr [1,2,3] (+) 0
10:57:03 <mauke> @pl  fix3rd f = (\x -> curry (flip (uncurry f) x) )
10:57:04 <lambdabot> fix3rd = (curry .) . flip . uncurry
10:57:10 <lambdabot>  6
10:57:19 <litb> lol
10:57:42 <litb> oskarM: no, you are right
10:57:49 <Tac-Tics> If you can do it for 2 and 3, I'm sure you can generalize it
10:58:39 <oskarM> @let fix4th x = curry . curry . flip flip x . uncurry . uncurry
10:58:41 <lambdabot> Defined.
10:59:16 <sclv> litb: if you find yourself constantly wanting to set the same nth parameter, maybe you put your function arguments in the wrong order to begin with ?
10:59:26 <oskarM> > fix4th 4 (,,,) 1 2 3
10:59:27 <lambdabot>  (1,2,3,4)
11:01:43 <allbery_b> sclv: but what if  it's a prelude or library function?
11:01:52 <allbery_b> (I've actually encountered that once or twice)
11:02:23 <litb> no, it's my pwned one
11:02:50 <BMeph> allbery_b: E.g., lookup? ;)
11:02:59 <oerjan> lessee...
11:03:25 <litb> the problem is that newton works with one initial point, but bisection and secant method work with two startpoints
11:03:32 <oerjan> fixNthPlus1 v f x = fixNth v (f x), no?
11:03:48 <litb> so i could put the inverfal ((y,x) or x) to the beginning of the function
11:04:01 <litb> maybe that is the solution. but i feel bad  about that
11:04:03 <czakey> @src curry
11:04:03 <lambdabot> curry f x y = f (x, y)
11:04:16 <czakey> @src uncurry
11:04:16 <lambdabot> uncurry f p = f (fst p) (snd p)
11:04:27 <Tac-Tics> uncurry f (a, b) = f a b
11:04:54 <Tac-Tics> Where does the source for lambdabot come from?
11:05:32 <jfredett> @where lambdabot
11:05:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
11:05:46 <oerjan> @pl \fx v f x -> fx v (f x)
11:05:46 <lambdabot> ((.) .)
11:06:05 <Tac-Tics> I mean the definition sources for @src
11:06:34 <Tac-Tics> hmm
11:06:40 <jfredett> the haddock docs have "view source" links, I'd assume there in the same place as those
11:08:04 <oerjan> @pl \fx v f x y -> fx v (f x y)
11:08:04 <lambdabot> (((.) . (.)) .)
11:10:27 <oerjan> > ((.).(.).(.).flip id) (,,,) 4 1 2 3
11:10:29 <lambdabot>        add an instance declaration for
11:10:29 <lambdabot>       (Num (a
11:10:29 <lambdabot>             -> a1
11:10:29 <lambdabot>       ...
11:11:55 <oerjan> > ((.).(.).(.).flip id) 4 (,,,) 1 2 3
11:11:57 <lambdabot>  (1,2,3,4)
11:14:04 <litb> what is that (,,,,) for?
11:14:17 <oerjan> testing
11:14:27 <litb> looks like it makes a tuple out of the arguments?
11:14:31 <oerjan> yep
11:14:54 <mauke> :t (,,,,,,,,,,)
11:14:55 <lambdabot> forall a b c d e f g h i j k. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> (a, b, c, d, e, f, g, h, i, j, k)
11:15:03 <litb> lolz :)
11:15:11 <mauke> :t (,,,,,,,,,)
11:15:12 <lambdabot> forall a b c d e f g h i j. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (a, b, c, d, e, f, g, h, i, j)
11:15:16 <mauke> weird
11:15:26 <mauke> :t (,,,,,,)
11:15:27 <lambdabot> forall a b c d e f g. a -> b -> c -> d -> e -> f -> g -> (a, b, c, d, e, f, g)
11:15:31 <mauke> that one is ok
11:15:38 <oerjan> a bug!
11:15:41 <LoganCapaldo> (,) = \a b -> (a, b), (,,) = \a b c -> (a, b, c) , (,,,)  = \a b c d -> (a, b, c, d) and so on
11:15:42 <ricky_clarkson> :t (,) . (,)
11:15:43 <lambdabot> forall b a b1. a -> b -> (b1 -> (a, b1), b)
11:15:49 <ricky_clarkson> :t (,,)
11:15:50 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
11:21:32 <LoganCapaldo> @pl \x -> case x of (a, (b, c)) -> (a, b, c)
11:21:32 <lambdabot> (line 1, column 29):
11:21:32 <lambdabot> unexpected ">" or "-"
11:21:32 <lambdabot> expecting variable, "(", operator or end of input
11:22:40 <LoganCapaldo> @pl \(a, (b, c)) -> (a, b, c)
11:22:41 <lambdabot> uncurry ((`ap` snd) . (. fst) . (,,))
11:24:32 <litb> @pl (\x a b c -> x a b c)
11:24:33 <lambdabot> id
11:26:09 <BMeph> ?pl \f c a b -> f (a b c)
11:26:09 <lambdabot> (. flip flip) . (.) . (.)
11:26:44 <BMeph> ?pl \f d a b c -> f (a b c d)
11:26:44 <lambdabot> (. flip (flip . (flip .))) . (.) . (.) . (.)
11:33:43 <litb> @pl (\f q a b c -> f a b c q)
11:33:43 <lambdabot> flip . ((flip . (flip .)) .)
11:39:23 <kuribas> Can a context declaration contain a function arrow (->)?
11:40:10 <conal> kuribas: for instance?
11:40:47 <oerjan> in H98 i think contexts only can be on variables
11:41:16 <oerjan> but with extensions it should be possible
11:41:41 <kuribas> class (something -> something) => MyClass ...
11:42:09 <oerjan> :t sin >>= return
11:42:10 <lambdabot> forall a. (Floating a) => a -> a
11:42:14 <conal> kuribas: i think FlexibleInstances is the extension you want
11:42:16 <oerjan> bah
11:42:37 <kuribas> conal: I am only interested in the syntax.  I need to know it for the indentation engine I am writing.
11:43:04 <kuribas> So I have to know if it will need to recognise a -> token inside the class declaration.
11:43:18 <oerjan> don't you mean class (SomeClass (something -> something)) => MyClass ...
11:43:32 <conal> kuribas: oh!
11:43:40 <oerjan> which definitely should be possible
11:43:41 <conal> oerjan: aren't those parens optional for a single constraint?
11:43:54 <oerjan> probably
11:44:16 <conal> btw, i think i noticed uncurried contexts checked in.
11:44:37 <conal> class Foo a => Bar b => Baz c where ...
11:44:37 <oerjan> conal: what's that?
11:44:51 <conal> i've been wanting that for a while.
11:44:55 <byorgey> conal: why?
11:45:20 <conal> byorgey: more uniform.
11:45:25 <kuribas> oerjan: Yes something like that.
11:45:41 <litb> why does ghci show this?
11:45:45 <litb> Prelude Maybe> :t (>>=) []
11:45:46 <litb> (>>=) [] :: (a -> [b]) -> [b]
11:45:47 <conal> sometimes my fingers type it by themselves.  e.g., when adding a constraint.
11:45:51 <oerjan> hm...
11:45:54 <litb> i thought the definition is another one?
11:46:29 <byorgey> litb: that shows the type of the expression (>>=) [], which applies the function (>>=) to the empty list [].
11:46:34 <byorgey> litb: what did you expect it to show?
11:46:53 <litb> m a -> (a -> m b) -> m b
11:46:55 <ddarius> :t ([]>>=)
11:46:55 <lambdabot> forall a b. (a -> [b]) -> [b]
11:46:58 <oerjan> :t sin + cos
11:46:58 <lambdabot> forall a. (Floating a, Num (a -> a)) => a -> a
11:47:03 <oerjan> ah
11:47:04 <byorgey> litb: then just type :t (>>=)
11:47:04 <litb> but i see now. m is [] while b is b and a is a
11:47:07 <oerjan> kuribas: ^^
11:47:21 <byorgey> litb: right.
11:47:23 <litb> ah, thx
11:48:14 <kuribas> oerjan: Ah yes, I see!
11:48:48 <oerjan> my first try didn't work because :t simplified it as the instance actually existed
11:49:51 <oerjan> hm...
11:50:04 <oerjan> > sin >> get
11:50:05 <lambdabot>        add an instance declaration for (MonadState b ((->) a))
11:50:11 <oerjan> argh
11:50:20 <oerjan> :t sin >> get
11:50:20 <lambdabot> forall a b. (Floating a, MonadState b ((->) a)) => a -> b
11:50:37 <oerjan> kuribas: that shows a partially applied case
11:51:54 <ddarius> @users
11:51:54 <lambdabot> Maximum users seen in #haskell: 454, currently: 438 (96.5%), active: 11 (2.5%)
11:52:01 <oerjan> :t sin ||| cos
11:52:04 <lambdabot> forall a. (Floating a) => Either a a -> a
11:52:16 <oerjan> hm not that
11:52:21 <Japsu> :t sin &&& cos
11:52:22 <lambdabot> forall a. (Floating a) => a -> (a, a)
11:52:24 <Japsu> that? ;)
11:52:30 <oerjan> nope
11:52:32 <Japsu> :O
11:52:34 <kpreid> :t sin +++ cos
11:52:35 <lambdabot> forall a a1. (Floating a, Floating a1) => Either a a1 -> Either a a1
11:52:56 <kpreid> that?
11:53:00 <kpreid> hmm, not what I was thinking of
11:53:11 <byorgey> :t (+++)
11:53:12 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
11:53:13 <oerjan> i am trying to get a context with (->) alone
11:53:15 <ddarius> If you're trying to get Arrow (->) it's not going to happen.
11:53:25 <oerjan> ddarius: i know
11:53:36 <oerjan> i thought maybe ArrowChoice would give it
11:53:54 <kpreid> hmm.
11:53:55 <oerjan> but -> actually has that instance
11:54:09 <ddarius> oerjan: There should be a (->) instance for all the arrow classes.
11:54:36 <oerjan> oh wait...
11:54:44 <oerjan> er no
11:55:25 <oerjan> what classes of kind * -> * -> * are there?
11:55:51 <kpreid> :t \a -> a &&& id
11:55:51 <ddarius> oerjan: Probably all of them with that kind have (->) as an instance.
11:55:52 <lambdabot> forall b c. (b -> c) -> b -> (c, b)
11:56:36 <kpreid> ddarius: MonadError
11:56:47 <kuribas> oerjan: Alright, I'll treat -> as a function inside a class/instance construct.
11:56:55 <ddarius> :t throwError
11:56:56 <kpreid> @instances MonadError
11:56:56 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
11:56:56 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
11:57:05 <kpreid> @instances MonadState
11:57:06 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
11:57:07 <BMeph> :t sin *** cos
11:57:07 <lambdabot> forall a a1. (Floating a, Floating a1) => (a, a1) -> (a, a1)
11:57:20 <oerjan> no
11:57:30 <oerjan> Monads have kind * -> *, you won
11:57:36 <ddarius> kpreid: No dice.  Neither e nor m have that kind.
11:57:36 <oerjan> 't get it there
11:57:53 <ddarius>  (m is (SomeMonad e))
11:58:01 <kpreid> er...
11:58:03 <kpreid> I see
11:58:09 <ddarius> Well, SomeParameterizedMonad
11:58:38 <oerjan> hm wait
11:58:46 <ddarius> If we had a bifunctor class ...
11:59:14 <oerjan> -> is ArrowApply? O_O
11:59:21 <ddarius> oerjan: Of course.
11:59:35 <oerjan> but, i didn't think -> arrow came from a monad *scratches head*
11:59:41 <esnip_> people does any one ave an idea how can i check if a function is equal to id without checking values?
12:00:00 <byorgey> esnip_: it isn't possible, in general.
12:00:02 <Toxaris_> esnip_: in general you cannot.
12:00:28 <ddarius> Arrows model Freyd categories which are inclusions from a "pure" category into an "effectful" one.  (->) is the trivial Arrow.
12:00:45 <Toxaris_> byorgey, ddarius: IArray
12:00:45 <esnip_> tks
12:00:46 <esnip_> :\
12:00:46 <byorgey> esnip_: however, if you are going to be dealing with functions on a limited domain/built out of a limited set of combinators, you could reify it as a data structure
12:01:01 <ddarius> @src IArray
12:01:01 <lambdabot> Source not found. My pet ferret can type better than you!
12:01:04 <oerjan> ddarius: does that mean it comes from Identity monad?
12:01:07 <byorgey> esnip_: then you could implement simplification rules for your data structure and check whether it is id
12:01:34 <esnip_> that's what i'm trying to do
12:01:39 <oerjan> hm makes sense
12:01:45 <ddarius> oerjan: The Kleisli category of the Identity monad is isomorphic to (->) though that's more round-about than necessary.
12:02:01 <byorgey> esnip_: what exactly are you trying to do?  what's the context?
12:02:03 <Toxaris_> hm sorry IArray was for oerjan of course
12:02:08 <esnip_> using gadt's
12:02:27 <ddarius> :t readArray
12:02:29 <lambdabot> Not in scope: `readArray'
12:02:42 <byorgey> :t array
12:02:43 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
12:02:43 <esnip_> whel i'm trying to proof that a rule is a representation
12:02:51 <esnip_> checking if from . to = id
12:03:14 <ddarius> I would think we would be able to make functions an instance of IArray actually, though I doubt it's there.
12:03:21 <ddarius> MArray though, wouldn't work.
12:03:36 <byorgey> esnip_: I see.  So you'd like some sort of mechanical/automated way to prove that from . to = id?
12:03:50 <oerjan> yay
12:03:51 <esnip_> yes
12:04:01 <esnip_> check Rule with proof
12:04:46 <oerjan> :t Data.Array.IArray.bounds succ
12:04:46 <lambdabot> forall a. (Enum a, Data.Array.Base.IArray (->) a, Ix a) => (a, a)
12:04:56 <oerjan> :)
12:05:11 <byorgey> esnip_: well, one nice thing about Haskell is that purity/referential transparency means you can easily reason about things like that
12:06:03 <byorgey> esnip_: e.g. you can substitute definitions without worrying about side effects happening more than once, etc.
12:06:13 <byorgey> esnip_: this technique is known as 'equational reasoning'.
12:06:25 <Codex_> oh, I have a question about exponentiation/currying: What steps (starting from id_a^b) are needed to get currying?
12:06:34 <byorgey> esnip_: as for automating the proof process, you may want to look at things like Coq and Isabelle.
12:06:42 <esnip_> :\
12:07:39 <byorgey> esnip_: do you have code showing the definitions of from and to you could paste?
12:07:44 <larmeh_> "import MyModule" won't work... ghci says: "Could not find module `MyModule'" although "MyModule" is in the same directory as the one containing the import statement, why?
12:07:48 <cjb> n
12:07:51 <cjb> oops.
12:08:05 <byorgey> larmeh_: is it in a file called MyModule.hs?
12:08:12 <Saizan> larmeh_: does it have module MyModule where at the top?
12:08:14 <larmeh_> byorgey: yes.
12:08:23 <larmeh_> Saizan: yes.
12:08:41 <Saizan> well then it's not in the include path..
12:08:44 <byorgey> larmeh_: did you start ghci from this same directory?
12:09:14 <larmeh_> byorgey: i'm not sure, eclipse starts a ghci session for me...
12:09:26 <byorgey> Codex_: what do you mean?
12:11:36 <RayNbow> hmm, that new channel 9 vid was not really interesting
12:11:41 <RayNbow> only a few small bits
12:12:00 <RayNbow> and the last panning scene showing how Erik's office looks like
12:12:57 <Codex_> byorgey: I mean, I have a book that says currying is the following rule: XxY->Z / X->Z^Y, now you can insert id_a^b in place of X->Z^Y by substitution X=Z^Y.
12:13:54 <Codex_> I'm just trying to understand how currying works in math :)
12:14:16 <LoganCapaldo> larmeh_: an you run :!pwd in the ghci started for you by eclpse. if the working directory is not same as the MyModule.hs file, and its its not in one of the othe rplaces ghc ooks for files it's not going to work
12:14:32 <litb> oh, can i code haskell with eclipse?
12:14:38 <LoganCapaldo> the import is not going tork that is
12:14:50 <litb> not that i want to leave emacs...
12:15:42 <litb> something like emacs,but coded with haskell. that would be nice
12:15:42 <gwern> 'Emacs: "Comes with one of everything".' 'Not true! there are two irc clients in emacs 22!' 'And both were added during a feature freeze!'
12:15:50 <gwern> litb: yi, you mean?
12:15:53 * LoganCapaldo can't type apparently
12:16:30 <gwern> litb: funnily enough, I just wrote a little assessment of yi on proggit - see http://programming.reddit.com/info/65uwx/comments/
12:17:09 <oerjan> Codex_: the corresponding element of (Z^Y)xY -> Z should be function application, at least
12:17:16 <oerjan> (just musing)
12:17:16 <litb> oh, nice
12:17:28 <Codex_> oerjan: yes.
12:17:31 <litb> gwern: is it good?
12:17:47 <gwern> litb: depends on your needs and inclinations...
12:18:05 <oerjan> Codex_: and indeed in haskell ($) = id, just with a less general type...
12:18:28 <oerjan> :t uncurry id
12:18:30 <lambdabot> forall b c. (b -> c, b) -> c
12:18:44 <Tac-Tics> gwern: how long have you been working on Yi?
12:18:51 <gwern> I mean, for xmonad I can say - 'if you like keyboard driven tiling window managers, you should definitely use xmonad!' and I can say for haskell 'if you like functional programming, you should definitely use haskell!', but I'm not yet sure what I can say for yi. it's early days yet. an editor is a hard thing
12:19:14 <gwern> Tac-Tics: not terribly long. a few weeks, or so. But I do have reverse isearch to show for my troubles!
12:19:21 <Tac-Tics> heh
12:19:25 <cjb> (reverse isearch)++
12:19:27 <Tac-Tics> I've been looking at the source for 3 days
12:19:40 <Tac-Tics> I've never really worked on a big haskell or open source project, and Yi seemed neat enough
12:19:42 <cjb> I can't believe that most of the terminal emulators we use don't have reverse isearch
12:19:44 <cjb> it is ridiculous.
12:19:55 <oerjan> @karma isearch)
12:19:55 <lambdabot> isearch) has a karma of 1
12:19:59 <cjb> Konsole does, as of KDE4.  So I'm using that now.
12:20:09 <gwern> cjb: reverse isearch is the shell
12:20:12 <gwern> 's business no?
12:20:20 <cjb> no
12:20:26 <cjb> I want to search through the output of programs I've run
12:20:28 <litb> cjb: u use konsole4? is KDE4 ready?
12:20:32 <Tac-Tics> I'm still trying to wrap my head around the basic architecture, but mulling over some of the bug reports has given me a basic idea of how Yi works
12:20:35 <cjb> which I don't think the shell knows anything about
12:20:51 <cjb> litb: konsole4 is, KDE4's still pretty rough though.
12:20:52 <Codex_> oerjan: is the rule XxY->Z / X->Z^Y somehow derivable from definition of a category, or does it need to be provided separately?
12:20:57 <gwern> probably not. so run in screen, I think it has reverse isearch
12:21:05 <litb> hm
12:21:16 <oerjan> Codex_: i think it may require cartesian closed categories
12:21:24 <gwern> Tac-Tics: did you read the dynamic apps from ground-up paper? the architecture has gotten more complicated, but the basic idea is still there
12:21:26 <cjb> gwern: it doesn't have very good reverse isearch, and I don't want to run every terminal in screen, and if I'm on a laggy ssh connection that means my reverse-isearch is going to be lagged and I hate that.
12:21:26 <oerjan> and that means it's really over my head :)
12:21:56 <Tac-Tics> gwern: Yes, I read it a while ago. The concept is really cool, and I was sad when I found out that the library used in the paper has since become deprecated
12:22:11 <gwern> Tac-Tics: hs-plugins?
12:22:14 <Tac-Tics> yeah
12:22:26 <gwern> what was deprecated about it?
12:22:41 <oerjan> Codex_: i don't remember exactly but that isomorphism may be part of the definition of a cartesian closed category
12:22:42 <Tac-Tics> well, it didn't work when I tried it a while ago. Maybe it's not deprecated
12:23:10 <gwern> Tac-Tics: works for me
12:23:14 <gwern> which repo did you try?
12:23:24 <LoganCapaldo> lambdabot uses hs-plugins. hs-plugins hans't been ported to ghc 6.8 yet htough
12:23:36 <Tac-Tics> this was a few months ago. It was probably something in configuration
12:23:36 <oerjan> LoganCapaldo: it has
12:23:39 <LoganCapaldo> (or it has and I blinked when it happened)
12:23:42 <gwern> LoganCapaldo: sure it has. I just recompiled and reinstalled it under 6.8.2
12:23:48 <Tac-Tics> getting Yi to work was the hardest thing I've ever done =-P
12:23:58 <roconnor> Is a solution to an NP problem verifiable in poly-time in terms of the length of the proble, or in terms of the length of the witness?
12:24:05 <oerjan> LoganCapaldo: and some lambdabots use 6.8 already
12:24:08 <roconnor> problem
12:24:25 <oerjan> roconnor: problem
12:24:26 <gwern> Tac-Tics: everyone says they have trouble installing yi, but I've never had a problem. what exactly went wrong?
12:24:28 <Codex_> oerjan: my book only lists this as property of ccc, but does not tell how to build it from more primitive parts.
12:24:50 <oerjan> the witness has to be polynomial size in the problem
12:25:15 <roconnor> oerjan: ah, thanks
12:25:37 <oerjan> Codex_: ok.  i should defer to the actual CT gurus here :)
12:25:59 <Tac-Tics> Well, I had problems with 0.2. I got it working, but never quite figured out how I did it. I gave up after a few days anyway. But earlier this week, I tried 0.3, and was having trouble because 0.3 doesn't work with ghc 6.6 (which is the highest packaged version available with Ubuntu and a few other Linuxes)
12:26:28 <roconnor> oerjan: right, that would be implied because otherwise there would be no time to read the witness.
12:26:35 <gwern> oh, 0.2 >.<
12:26:35 <gwern> you got that from hackage, didn't you?
12:26:48 <Tac-Tics> I installed GHC 6.8 by source (which isn't straightforward either), and I started running into occasional problems where it would configure, but error on builds (usually Vty wasn't installed properly)
12:26:59 <Tac-Tics> gwern: yeah
12:27:39 <Tac-Tics> But I want to start hacking it, because the idea of Emacs is really awesome, and Haskell is awesome, and the two together would be better than sex
12:27:50 * gwern *told* bernardy we should have another hackage release
12:28:13 <gwern> .2 dates back to like march of last year, which I think was even before bernardy started maintainig it
12:28:23 <Tac-Tics> yeah, it seemed to be somewhat of an unloved project
12:28:27 <Tac-Tics> but the idea is just so cool
12:28:39 <oerjan> roconnor: the argument works both ways i think.  if the witness is polynomial in the problem then checking polynomial in the witness is itself polynomial in the problem
12:29:15 <gwern> writing an editor which can compete with emacs is an incredibly monumental task
12:29:22 <Tac-Tics> yeah
12:29:44 <roconnor> oerjan: yeah, but perhaps the witness would be allowed to not be polynomial in the length of the problem.
12:29:47 <oerjan> gwern: you'll end up like Ozymandias :)
12:29:58 <roconnor> oerjan: which would be weird.
12:30:58 <pejo> gwern, oh yeah, just replacing Gnus and w3m is a huge thing.
12:31:08 <pejo> gwern, nevermind writing an editor on top of that!
12:31:24 <pejo> Err, I mean w3.
12:31:25 <oerjan> roconnor: i think in the non-deterministic formulation the witness is simply the sequence of non-deterministic choice taken by the turing machine
12:31:26 * roconnor tries to remember what happend to Ozymandias
12:31:34 <oerjan> *choices
12:31:51 <Lycurgus_> somebody fucked him up
12:31:55 <Lycurgus_> time I think
12:32:00 <roconnor> oerjan: good point
12:32:29 <oerjan> roconnor: forgotten ruins
12:32:34 <ddarius> The isomorphism between XxY -> Z and X -> Z^Y is exactly the information that needs to be provided for a category to have currying.
12:33:47 <ddarius> Or rather currying is all that needs to be provided to support higher-order functions.
12:33:56 <byorgey> "Look on my works, ye mighty, and despair!"
12:34:06 <byorgey> http://en.wikipedia.org/wiki/Ozymandias
12:34:07 <lambdabot> Title: Ozymandias - Wikipedia, the free encyclopedia
12:34:14 <Codex_> ddarius: thanks.
12:35:40 <gwern> oerjan: not so much ozymandias as that forlorn traveler
12:36:08 <gwern> pejo: I think we'll stick at replacing gnus and w3m - it's a better idea to put the editor in everything than everything in the editor, if you follow
12:36:42 <BMeph> BBL - rebotting
12:36:51 <gwern> Tac-Tics: it's unloved in part because it's necessarily so complex and large, and most haskellers already have an editor they love to death, imo
12:37:38 <gwern> (which was not true of window managers or languages or revision control)
12:38:05 <Tac-Tics> have you worked with overlays in Yi at all?
12:38:59 <gwern> nope
12:39:12 <gwern> too irritated by the state of isearch
12:39:19 <Tac-Tics> heh
12:39:22 <gwern> yi need transient mode!
12:40:11 <gwern> years ago, transient-mode was one of the very first things I learned how to customize in emacs
12:40:43 <Tac-Tics> I was wondering if there's a way to hilight individual characters in a buffer. It looked like the transient mark hilighting and the syntax hilighting where tightly integrated into the buffer logic
12:41:03 <Nafai> I'd really just like Yi to be a great Haskell IDE
12:41:18 <Tac-Tics> I write a cute script to close all open parenthesis
12:41:27 <Tac-Tics> But I wanted to see how hard it would be to hilight matching parens
12:41:33 <cjb> transient-mode is for n00bs.  :)
12:42:17 <gwern> cjb: uh yeah, because I want to select half the freaking buffer everytime I look round for something
12:43:21 <cjb> how else would you do something like vim's "d/foo"?
12:43:32 <cjb> (delete from current position to the next occurence of "foo")
12:43:40 <gwern> no idea what that does
12:44:07 <daf> delete to next occurrence of "foo"
12:44:24 <gwern> C-space, C-s foo, C-w
12:44:33 <cjb> daf: phew, my English-to-English translator has arrived :)
12:44:35 <gwern> not enabling transient-mode would only remove the C-space
12:44:52 <daf> cjb: :)
12:45:24 <cjb> hm
12:57:46 <grahamhutton> @users
12:57:46 <lambdabot> Maximum users seen in #haskell: 454, currently: 440 (96.9%), active: 23 (5.2%)
12:58:33 <thetallguy> checking the Haskell pulse again, eh?
12:58:48 <thetallguy> You keeping a chart?
12:58:50 <grahamhutton> indeed.  it seems to be getting more rapid these days!
12:59:10 <ddarius> Oh no!  Arryhthmia!
12:59:11 <grahamhutton> i think dons does that
12:59:53 * ddarius debates between calling the project 'parsec3' or just 'parsec'
13:00:39 <LoganCapaldo> ParsecNG, ParsecEx, Parsec II :)
13:01:00 <ibid> ddarius: it's not arrhythmia if the pulse is responding to exercise :)
13:01:05 <olsner> what's new-parsec supposed to do better?
13:01:18 <ibid> (speaking as someone who recently went through a FA episode)
13:01:50 <Philippa> olsner: this is the one that's a monad transformer and doesn't need its input to be a list of tokens
13:01:58 <ddarius> olsner: It's a new version of the old parsec.  Parsec is now a monad transformer ParsecT and it's usable with various different "String" types, in particular, bytestrings.
13:02:08 <grahamhutton> http://www.cse.unsw.edu.au/~dons/irc/
13:02:09 <lambdabot> Title: Haskell IRC Activity
13:02:13 <olsner> ah, that'll be nice
13:03:38 * olsner should learn how to use monad transformers some day
13:04:10 <C-Keen> hm Data.ByteString.Internal does not seem to be available on my system
13:04:38 <tyrke> larmeh_: test
13:04:57 <ddarius> C-Keen: It just recently moved there, so if you aren't using the latest GHC it will be somewhere else (Data.ByteString.Base) unless I'm mistaken.
13:05:05 <Philippa> ddarius: I think branching the name's probably a good idea at this point, not least because it allows making interface changes that aren't backwards-compatible
13:05:22 <C-Keen> ddarius: ah ok
13:05:36 <shapr> Yay #haskell!
13:09:21 <litb> one question
13:09:38 <ddarius> Make it good.
13:09:57 <litb> in my integrate function i map numbers 1..N to their integral values (i integrate interval-parts) and then sum them uo
13:10:00 <litb> *uo
13:10:00 <litb> up
13:10:01 <litb> darn
13:10:08 <olsner> dons: your blosxom blog looks nice, which blosxom plugins/flavour are you using?
13:10:14 <litb> but i fear that they will all be in memory then
13:10:44 <litb> tho in principle there only have to be one number and one integral value in memory each time, and be added to the sum value immediately
13:11:02 <ddarius> You have sum . map f effectively?
13:13:34 <ddarius> Now all I need to do is figure out how to use what's available on code.haskell.org
13:13:48 <dons> olsner: none.
13:14:32 <olsner> you must be using another version of blosxom or something, mine looks like crap
13:14:43 <HelgeS> Anybody there using Ubuntu, and who has managed to load SOEGraphics (import SOEGraphics)?
13:16:09 <EvilTerran> HelgeS, I think it might be under a different name
13:16:14 <EvilTerran> Graphics.SOE?
13:21:25 <HelgeS> EvilTerran: Yes, that seems to work. Thank you!
13:22:12 <C-Keen> hm, I am trying to get the darcs version of hmp3 running, but it seems my ghc and ByteString API is too old
13:22:57 <ddarius> C-Keen: Install GHC 6.8.2
13:23:14 <EvilTerran> :)
13:23:34 <C-Keen> ddarius: there is no package for my system yet and I don't like to build my own w/o the testsuite
13:23:36 <mauke> .oO( Helge Schneider? )
13:24:38 <C-Keen> I should give it a try tomorrow
13:24:43 <C-Keen> gnite gentlemen
13:34:53 * EvilTerran curses Thompson's Construction
13:35:05 <ddarius> Why?
13:35:52 <EvilTerran> one of the excercises in this problem sheet is "construct the NFA for (a*|b*)* by thompson's construction, and convert this into a DFA by the subset constuction"
13:36:10 <EvilTerran> that regex is clearly equivalent to (a|b)*, which has a 1-node DFA
13:36:51 <EvilTerran> but thompson's construction, applied mechanically, gives a 12-node NFA, and the DFA's only gonna be bigger
13:37:15 <Saizan> EvilTerran: apply minimization later than :)
13:37:17 <EvilTerran> (well, (a|b)* would be a two-node DFA, if you count the "failure" node)
13:37:32 <EvilTerran> we "haven't been taught" minimization.
13:37:56 <ddarius> Write a program to do it for you.
13:43:26 <conal> olsner & dons: i'm pretty happy with my new wordpress-based blog.  i have it set up to use markdown and do auto highlighting & linking for haskell code.
13:44:16 <Lemmih> Linking?
13:45:00 <conal> Lemmih: to haddock docs
13:45:16 <conal> via geshi.
13:45:49 <conal> same as the haskell wiki, i think, though i've added Monoid, Applicative & Arrow.
13:46:43 <Lemmih> Was it easy to add those wordpress plugins?
13:46:58 <conal> very
13:47:01 * olsner is interested
13:47:02 <conal> to my surprise
13:47:52 <gio123> @Cale
13:47:52 <lambdabot> Unknown command, try @list
13:48:00 <gio123> @ Cale
13:48:50 <oerjan> surprisingly, Cale is not a lambdabot command.  afaik he may even be human.
13:49:03 <gio123> EvilTerran: hi
13:49:12 <EvilTerran> hi?
13:49:17 <Lemmih> oerjan: No, I think he's Canadian.
13:49:26 <gio123> EvilTerran: do u know antimirov algorithm?
13:49:27 <oerjan> Lemmih: ah.
13:49:44 <EvilTerran> never heard of it
13:49:48 <Tac-Tics> @quote surprisingly, Cale is not a lambdabot command.  afaik he may even be human.
13:49:48 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
13:49:52 <gio123> oerjan: are u sure?
13:49:53 <Tac-Tics> bah
13:50:09 <gio123> EvilTerran: subtyping on regular expression
13:50:09 <olsner> Tac-Tics: @remember person quote
13:50:18 <gio123> EvilTerran: did heard?
13:50:23 <BMeph> @quote oerjan surprisingly, Cale is not a lambdabot command. afaik he may even be human.
13:50:23 <oerjan> gio123: i have no conclusive proof either way, if that's what you mean.
13:50:24 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
13:50:27 <Lemmih> conal: How did you do it? Do you have the urls for the plugins?
13:50:33 <BMeph> @quote+ oerjan surprisingly, Cale is not a lambdabot command. afaik he may even be human.
13:50:33 <lambdabot> No quotes match. I feel much better now.
13:50:45 <EvilTerran> @remember oerjan surprisingly, Cale is not a lambdabot command.  afaik he may even be human.
13:50:45 <lambdabot> It is forever etched in my memory.
13:50:59 <BMeph> Yay. :)
13:51:00 <EvilTerran> BMeph, olsner explained already; pay attention ;)
13:51:01 <Tac-Tics> It better be etched. That took 3 people to get it right
13:51:13 <gio123> oerjan>: try by unduction
13:51:26 <gio123> EvilTerran: did heard?
13:51:35 <gio123> EvilTerran: subtyping on regular expression?
13:51:38 <oerjan> gio123: i have some problems with the base case
13:51:45 <EvilTerran> gio123, yes, yes, okay. i'l looking it up now.
13:51:49 <EvilTerran> *i'm
13:52:02 <conal> Lemmih: it's mostly described on the first post of my new blog: http://conal.net/blog/posts/switching-blog-engines/
13:52:03 <lambdabot> Title: ConalBlog  Blog Archive  Switching blog engines
13:52:15 <gio123> oerjan: then try by coinduction
13:52:19 <dons> gio123: still asking about subtyping and regexes eh?
13:52:31 --- mode: ChanServ set +o dons
13:52:33 --- kick: gio123 was kicked by dons (dons)
13:52:42 <dons> its gschuett
13:52:44 --- mode: ChanServ set -o dons
13:52:53 <conal> Lemmih: if that post turns out to be incomplete, i'd be glad to help with missing details.
13:52:55 <oerjan> gio123: but bisimulating Cale can only be done if he _is_ a bot, i think
13:52:59 <EvilTerran> dons, who?
13:53:20 <gio123> somebody kicked me why?
13:53:21 --- mode: ChanServ set +o dons
13:53:22 --- mode: dons set -b *!*n=fsafasf@89.191.106.*
13:53:52 <olsner> I happened to get sidetracked in mod_rewrite when installing blosxom, so ended up writing a blog post about implementing a string rewriting system with mod_rewrite rather than writing about installing a blog :P
13:54:05 <gio123> dons: i even implemented algorithm which does not work :))
13:54:28 <gio123> * You were kicked by dons (dons)  why u did?
13:54:35 <dons> stop repeating questions about 'subtyping regular expressions' and 'antimirov algorithm'. or you'll be banned as a troll
13:55:02 <gio123> ok, I will leave this chanell
13:55:04 <gio123> bye
13:55:18 <dons> great. thanks.
13:55:44 <gio123> dons: fuck u! and fuck all ur family
13:55:48 <phlpp> first time i see a troll in here :\
13:55:50 --- mode: dons set +b *!*n=sdasd@193.186.177.*
13:55:50 --- kick: gio123 was kicked by dons (dons)
13:55:52 <phlpp> gio123: piss off, pls.
13:56:12 <dons> check the logs for the last few days, btw.
13:56:16 <jfredett> lol
13:56:17 <EvilTerran> ... protontorpedo?
13:56:23 <dons> i don't think so. but very very close
13:56:33 <EvilTerran> (going by http://www.cse.unsw.edu.au/~dons/lambdabot/Plugin/Quote/Text.hs)
13:57:00 <dons> yeah, quite similar. almost kealish.
13:57:06 <olsner> #haskell gets the weirdest trolls
13:57:15 <jfredett> yah
13:57:24 <paczesiowa> how can I search for smth in #haskell logs? http://ircbrowse.com/search.html doesn't work:/
13:57:26 <lambdabot> Title: IRC Browse Channels
13:57:28 <jfredett> antimirov trolls, :/
13:57:29 <dons> he's jus been asking,
13:57:30 <dons> 20:31:55 <gio123> Cale: usfulness of <_0
13:57:31 <dons> 20:32:18 <gio123> Cale: can u pm please?
13:57:37 <dons> over and over for several days.
13:57:52 <jfredett> what does that even mean?
13:57:58 <EvilTerran> dons, i'm confused now; that .hs suggests that gschuett = protontorpedo, and you said that he's gschuett...
13:58:01 <jfredett> <_0?
13:58:29 <dons> EvilTerran: i was wrong , on further inevestigation. gio123 isn't gschuett.
13:58:34 <jfredett> look, I can make vaugly asiatic ASCII pictograms which are supposedly theoretical!
13:58:35 <dons> but does a passing imitation
13:58:37 --- mode: ChanServ set -o dons
13:59:07 <EvilTerran> from those quotes, i see what you mean
13:59:35 <Saizan> jfredett: quick, write a paper full of korean smilies!
13:59:49 <dons> also, the repetitive nature. the same questions are getting repeated, with typos, over several days
14:00:04 <jfredett> ^_^ -_- ^_- <(-_-)>!
14:00:17 <dons> btw, if you guys haven't seen the shootout running 6.8, its worth checking out.
14:00:22 <dons> a few breakages i'm fixing
14:00:28 <dons> but the results are very exciting
14:00:29 <EvilTerran> if you use . instead of _, some of those'd be valid operators...
14:00:34 <dons> sum-file jumped way up. binary-trees is $1
14:00:44 <olsner> perhaps someone should add a @troll command to lambdabot that does some random selection of keal, protontorpedo, and other trolls
14:00:47 <jfredett> dons: cool
14:00:51 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=binarytrees&lang=all
14:00:53 <jfredett> @keal
14:00:53 <lambdabot> all i know is i have experienced my own death unhappening...
14:00:56 <lambdabot> Title: binary-trees benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/zx84m
14:02:14 <EvilTerran> @. vixen protontorpedo
14:02:14 <lambdabot> church is my favourite computer scientist.
14:02:58 <oerjan> hm... can @@ be pushed to help?
14:03:28 <oerjan> is there some way to construct a command name...
14:03:41 <oerjan> oh...
14:04:01 <EvilTerran> the best i've come up with is
14:04:26 <Tac-Tics> some of these quotes had to have been worked out in advance.... or at least put through an English word misspelling algorithm
14:04:35 <oerjan> perhaps with some combination of @. and @@
14:04:47 * Tac-Tics ponders the usefulness of a English to n00b spelling translator
14:04:51 <EvilTerran> @@ @run let s = (@show @yow) in (s, (@show @vixen s))
14:04:53 <lambdabot>  ("In Newark the laundromats are open 24 hours a day!\n","i'm a huge baseball...
14:05:07 <Lemmih> Didn't we have a better reverse-complement once?
14:05:09 <EvilTerran> hehe... beautifully truncated :D
14:05:29 <oerjan> that runs both commands always though
14:05:41 <oerjan> however, hm
14:06:17 <EvilTerran> oh, sorry, i thought you meant to make my "@. vixen protontorpedo" clearer (by making the question visible)
14:06:50 <oerjan> no i meant for simulating a @troll command
14:07:09 <Sizur> > 20345345345 :: Int
14:07:09 <lambdabot>  -1129491135
14:07:27 <EvilTerran> @list quote
14:07:27 <lambdabot> quote provides: quote remember forget ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
14:07:34 <ddarius> Wow.  Clean kicks ass and takes names on sum-file.
14:08:20 <EvilTerran> @@ @run [(@show @keal),(@show @protontorpedo),(@show @palomer),(@show @girl19)] !! (length (@show @quote) `mod` 4)
14:08:21 <lambdabot>  "nobody can catch me"
14:08:26 <olsner> even Java beats us on sum-file!
14:08:50 <EvilTerran> length (@show @quote) -- high-quality random numbers, there :D
14:08:56 <oerjan> yay
14:09:12 <EvilTerran> @list show
14:09:12 <lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack thanks thx thank you wiki oldwiki docs source fptools hackage
14:09:12 <Tac-Tics> What does @@ do?
14:09:17 <olsner> I remember hacking a bit on that benchmark, I wonder if I got any good results out of that
14:09:18 <EvilTerran> @help eval
14:09:18 <lambdabot> eval. Do nothing (perversely)
14:09:21 <oerjan> but still runs all commands i think
14:09:27 <EvilTerran> @help read
14:09:27 <lambdabot> read "<foo>". Print <foo>
14:09:28 <phlpp> hm, does anyone here use xmonad + xmobar?
14:09:31 <EvilTerran> aha
14:09:48 <EvilTerran> @help dummy
14:09:48 <lambdabot> dummy. Print a string constant
14:09:59 <oerjan> i think only @@ and @. run subcommands
14:10:05 <oerjan> @list @
14:10:06 <lambdabot> compose provides: . compose @ ?
14:10:53 <EvilTerran> @eval testing
14:11:05 <EvilTerran> @dummy testing
14:11:05 <lambdabot> dummy
14:11:11 <BMeph> Holy Moley! I LIKE Brian Beckman's monad explanation.
14:11:24 <ddarius> BMeph: Which?
14:11:41 <monochrom> It may be a good thing to have a million different monad explanations.
14:11:47 <BMeph> ddarius: I'm watching "Don't fear the Monads" now.
14:12:01 <oerjan> hm nesting @@'s should be possible
14:12:03 <ddarius> BMeph: It's almost content free (at least as far as monads go)
14:12:04 <EvilTerran> @@ @. id @read @run words "keal protontorpedo palimer girl19" !! (length (@show @quote) `mod` 4)
14:12:06 <lambdabot> Plugin `compose' failed with: Unknown command: ""
14:12:15 <EvilTerran> @run words "keal protontorpedo palimer girl19" !! (length (@show @quote) `mod` 4)
14:12:15 <lambdabot>  Parse error at "@show" (column 55)
14:12:18 <Tac-Tics> Don't fear monads? Sounds neat, can has link?
14:12:20 <EvilTerran> @@ @run words "keal protontorpedo palimer girl19" !! (length (@show @quote) `mod` 4)
14:12:20 <lambdabot>  "protontorpedo"
14:12:26 <EvilTerran> @@ @read @run words "keal protontorpedo palimer girl19" !! (length (@show @quote) `mod` 4)
14:12:26 <lambdabot>  protontorpedo
14:12:28 <ddarius> Tac-Tics: It's horrible.
14:12:35 <monochrom> I think people like content-free stuff.
14:12:44 <ddarius> monochrom: You may have a point there.
14:13:00 <monochrom> haha
14:13:09 <olsner> IIRC, this solution http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=ghc&id=4 using ByteString lines and getContents instead of the standard versions pwned
14:13:10 <lambdabot> Title: sum-file Haskell GHC #4 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comp ..., http://tinyurl.com/2ebcxc
14:13:10 <EvilTerran> @@ @. id protontorpedo
14:13:11 <lambdabot>   and is haskell ez to debug?
14:13:12 <BMeph> The point is not to explan at all what Monads are, just how to use them. That's not the worst thing.
14:13:30 <EvilTerran> @@ @. id @read "protontorpedo"
14:13:31 <lambdabot> Plugin `compose' failed with: Unknown command: ""
14:13:34 <EvilTerran> hmm
14:13:46 <EvilTerran> @@ @. (@read "protontorpedo") id
14:13:46 <lambdabot> Plugin `compose' failed with: Unknown command: ""
14:14:12 <EvilTerran> @@ @@ (@read "@protontorpedo")
14:14:13 <lambdabot>  can u build things fast in haskell?
14:14:16 <EvilTerran> aha!
14:14:16 <ddarius> BMeph: He doesn't do that.  Practically the entire video is spent talking about how to match types up with no examples of use, no explanation of where or why you'd use monads except some nonsensical buzzing about compositionality.
14:14:47 <EvilTerran> @@ @@ @read @run words "@keal @protontorpedo @palimer @girl19" !! (length (@show @quote) `mod` 4)
14:14:48 <lambdabot>  I've always found myself unequal to the intellectual pressure of programming
14:14:53 <EvilTerran> cha-ching!
14:15:11 <ddarius> BMeph: It's '90s OO-style hype plus "functional languages are slow" at the end.
14:15:29 <oerjan> @@ @. id(@read "protontorpedo")
14:15:29 <lambdabot>  is ghc bad for learning?
14:15:50 <Lemmih> EvilTerran: Neat.
14:16:09 <BMeph> ddarius: I'll keep watching, then.
14:16:34 <olsner> does that use @quote as a random number generator?
14:16:50 <ddarius> BMeph: That's fine, just don't expect much but confusion.
14:16:59 <monochrom> Confidence is a feeling, pure emotion. Sometimes people talk of "understanding" without realizing that they mean confidence. (We still do not understand what is "understanding", but sometimes it is confused with confidence.) Thus, "I can do anything with monads" and "I am confident I can do anything with monads" are not always synchronized.
14:17:04 <ddarius> BMeph: The weird thing is that his blog/webpage is actually decent.
14:18:56 <monochrom> Sometimes, if you already possess an ability, but lack confidence, you don't need content anymore, but you need some charming persuasion to perk up your confidence.
14:19:26 <ddarius> monochrom: That may well be true, but in this case his target audience is people who lack ability and confidence.
14:20:06 <monochrom> Before a great army marches out, the great commander gives a great speech. It is content-free. But it is necessary. The soldiers already have the ability after all those years of training. They need morale now.
14:20:21 <monochrom> Actually perhaps the soldiers don't have the ability either. :)
14:21:12 <monochrom> Sometimes you lack the ability, but if you perk up confidence, you start practicing eagerly and then you may develop ability.
14:21:28 <ddarius> monochrom: You have to know what to practice!
14:22:13 <EvilTerran> @@ @@ @read @run (++) <*> (": @"++) $ words "keal protontorpedo palomer girl19" !! (length (@show @quote) `mod` 4)
14:22:14 <lambdabot>  protontorpedo: what is a good way to handle the ftp transfer and reading of files to mysql?
14:22:19 * EvilTerran stops fiddling now
14:22:35 <ddarius> Back to work! *whip crack*
14:23:09 * shapr gets back to work
14:23:11 <oerjan> oh, ": @"++ actually works inside @@ ?
14:23:49 <monochrom> Anyway I say all this as my current understanding of human psychology. I completely dislike it, but I accept it as how other people behave and can't help it. I myself couldn't care less about confidence or even "understanding", at least as far as intellectual activities are concerned.
14:24:02 <Nafai> shapr: Work?  On a Saturday?
14:24:19 <Philippa> I suspect that's because you don't appreciate how they play into most people's working
14:24:34 <EvilTerran> oerjan, it seems to. i was all set to use ": \x40", but it doesn't seem necessary
14:24:38 <Philippa> I got a long way by having a certain amount of confidence in my ability to play around with things in a very abstract manner
14:24:55 <Philippa> I've gone a /long/ way on being confident in my ability to examine systems without having had to write a whole one myself
14:25:09 <dons> shapr's focused like a laser these days :)
14:25:16 <Lemmih> shapr: How is working C# coming along?
14:25:35 <dons> just updated nsieve, spec-norm and rev-comp on the shootout -- all faster than in 6.6
14:25:36 * Nafai fights spammers and is losing
14:26:00 <Philippa> monochrom: how do you pick what to explore next?
14:26:16 <dons> shapr: classic "research community is our secret weapon" result, http://shootout.alioth.debian.org/gp4/benchmark.php?test=binarytrees&lang=all  -- spj's new constructor specialisation wipes the floor
14:26:18 <lambdabot> Title: binary-trees benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/zx84m
14:26:26 * EvilTerran notes that a command to show the output of one command, feed it into another command, and show the output of that command as well, would be quite cool
14:26:34 <EvilTerran> @ap?
14:26:34 <lambdabot> Maybe you meant: ? arr ask map pl
14:26:42 <monochrom> I don't know yet. LtU and #haskell do have influence.
14:27:26 <ddarius> I'd say mostly due to some application or by following references for me.
14:27:49 * EvilTerran would like to be able to, say, do @ap vixen yow, instead of having to faff around with nested @@s or whatever
14:28:12 <ddarius> E.g. I have a paper on tonemapping operators because I wanted to build an HDR image last night though I'd come across them before in the context of HDR rendering (raytracing).
14:28:30 <glguy> dons: have the 5 error programs been corrected yet?
14:28:54 <dons> glguy, 1 fixed, 4 submitted to be fixed. others broken, but older, non-broken defaults got used.
14:29:07 <dons> its very easy to update. basically bytestring imports change, and -fvia-C goes in the options pragma
14:29:13 <dons> glguy: eg. sum-file is fixed -- and faster!
14:29:23 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all
14:29:24 <lambdabot> Title: sum-file benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language ..., http://tinyurl.com/o8pll
14:29:29 <dons> bytestring's kick gcc's butt :)
14:29:47 <glguy> is clean still 2 seconds faster?
14:29:52 <olsner> but clean is still twice as fast!
14:29:57 <dons> (and it got faster because checking for Nothing/Just got a lot lot cheaper)
14:30:08 <glguy> http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=clean&id=0
14:30:09 <lambdabot> Title: sum-file Clean program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/37h63e
14:30:11 <thetallguy> seems to be the day for dons to be takin' names
14:30:12 <glguy> Clean's solution is
14:30:20 <Philippa> ddarius: yeah, I tend to influence how I follow references by whether I have any clue what they appear to be talking about though, for example. And sometimes I drop a trail because it's going to be lots of work and may well not pay off
14:30:20 <dons> yep. clean's doing some magicks. there's a handunrolled bytestring program that's about wice as fast again though
14:30:21 <Nafai> Wow, the Free Pascal memory use on those is impressive
14:30:23 <dons> so we can revisit it.
14:35:46 <BMeph> ddarius: Bah, I got to the end of it. You were entirely right, and it pretty much ruins the whole talk for me. :|
14:36:47 <monochrom> haha
14:37:16 <ddarius> My himistu bako is jammed or something.
14:37:19 <dons> pointer tagging is really very interesting.
14:37:37 <dons> it makes the Just/Nothing special syntax for bits packed into pointers.
14:37:49 <dons> and the cost becomes almost nothing to case on smaller ADTs now.
14:38:16 <dons> I think it makes the use of Maybes, and Eithers, in highh performance code, much more feasible than formerly.
14:38:29 <monochrom> Has pointer tagging slowed down a significant benchmark?
14:38:44 <dons> not that i'm aware of.
14:38:51 <monochrom> That's nice. :)
14:38:55 <dons> *everything* seems to be faster so far, or at worst, the same.
14:39:18 <monochrom> Even if it's 1% slower in a rare case I don't mind. :)
14:39:19 <ddarius> dons: Wouldn't this have an impact on the way the Parallel Array stuff represents arrays of Maybe and such.
14:39:24 <dons> binary-trees, sum-file, all faster due to pointer tagging (inner loops doing tag inspectoin). recursive much faster due to spec-constr.
14:39:28 <dons> ddarius: right. and other fusion stuff.
14:39:50 <dons> though actually, the inner loops should have the constructors removed anyway
14:40:20 <dons> the 'recursive' benchmark goes from 2.671 to 1.916 on my box.
14:40:24 <litb> any book/tutorial that trains me with currying and such?
14:40:36 <dons> due to,
14:40:36 <dons>     2 SPEC Main.fib
14:40:36 <dons>     2 SPEC Main.tak
14:40:36 <dons>     1 SPEC Numeric.showFFloat
14:40:42 <dons> which didn't exist in ghc before.
14:40:42 <ddarius> It may be at least interesting to consider using a direct representation parallel arrays of Maybe.  I believe currently it's split into two arrays.
14:40:55 <litb> for example, how i can fastly build (flip.) and such and see what they do without trail and error?
14:41:21 <dons> you can effecitvely treat data types with 8 constructors or less as bit packed values now
14:41:28 <ddarius> litb: That's not a very useful skill...
14:41:30 <dons> not int tags.
14:41:57 <litb> ddarius: why not?
14:42:19 <litb> if you see what type relations happen behind an expression isn't that good?
14:43:29 <ddarius> The top was just sticking.
14:43:46 <Lemmih> I wonder what effect a decent register system will have. The register allocator have always seemed to be an important part of most compilers.
14:44:13 <ddarius> Lemmih: A big one.
14:45:03 <monochrom> Bird's intro FP book may be a good one on point-free style. Not sure if it teaches it explicitly with hand-holding guidance, but certainly it uses point-free so pervasively that just by immersion, sink-or-swim, bombardment you are forced to learn it.
14:45:29 <dons> Lemmih: yeah, there's still a big jump waiting in the code gen.
14:45:42 <dons> so once the codegen's as good as clean, we win with all the new optimisations in the compiler and runtime
14:45:48 <jethr0_> hi, can anyone help me with an array question?
14:45:48 <litb> monochrom: =)
14:46:11 <ddarius> litb: I'd recommend Bird's book period and I haven't even read it.
14:46:44 <jethr0_> i've been trying to do some image handling in haskell using arrays to represent the image data. but initialization of the arrays ("UArray (Int,Int) Double" in my case) seemed to take forever...
14:46:57 <monochrom> A great bootcamp for point-free is category theory itself. Totally fearsome bootcamp. Effective for some people, but some trauma cases are also rumoured. :)
14:47:02 <dons> i'd suck it into a Ptr Double array
14:47:24 <dons> jethr0_: maybe even start as a bytestring, then coerce to a Double array
14:47:26 <jethr0_> monochrom: i loved category theory, but i've got this feeling that my brain is simply not made to grasp that stuff ;)
14:47:55 <jethr0_> dons: i was just disturbed by *how slow* array initialization was.
14:48:21 <monochrom> I myself, I started out with unix shell-scripting a long time ago. "f | g -i 10 | h".  And so, at the basic level, "h . g 10 . f" is immediate to me.
14:48:28 <Philippa> jethr0_: you don't really need to grasp it in the abstract though
14:48:49 <ddarius> There is some "pure" category theory stuff that's very useful.
14:48:50 <dons> jethr0_: well, you did something wrong :) its a memory fill in the usual case.
14:48:51 <jethr0_> btw, is there an easy way to "map" over an array? sth along the lines of "mapArray (+1) arr" or "zipArraysWith (+) arr1 arr2"? going via intermediate lists can't be fast...
14:49:05 <dons> you have to use a different array lib currently. like bytestring, or the ndp arrays
14:49:07 <Philippa> ddarius: yeah, but most of the time it's enough to grasp its application to functional programming
14:49:13 <dons> this should be fixed this year, meaning faster, flexible pure arrays
14:49:25 <ddarius> Philippa: Well, yeah, if FP is what you are using it for.
14:49:45 <ddarius> Philippa: That said, many categorical concepts map very, very nicely into typed functional programming.
14:49:58 <monochrom> And next, my love of formal equational reasoning of programs algebraically also helps. It is swifter to do "f . g = g . h" than "f(g(x)) = g(h(x))". It also puts the spotlight on the more important thing.
14:50:11 <Philippa> yep. Enough so that it's often reasonable to learn 'through' that mapping
14:50:20 <jethr0_> Philippa: well, yes. i loved functors and going from category b, solving the transformed problem and going back to category b. but as with higher maths in general, i have a hard time keeping it all in my head ;)
14:50:27 <ddarius> Philippa: In this particular case, yes.
14:50:35 <olsner> wow, the current haskell rev-comp implementation is astonishingly slow
14:50:52 <ddarius> jethr0_: There is only a small core to (pure) category theory.
14:50:55 <jethr0_> dons: k, i didn't know bytestring was considered as an array lib. i always saw it as a string replacement
14:50:55 <Philippa> jethr0_: so don't, just keep references?
14:50:58 <monochrom> And all this is topped up by practice, practice, practice. At the very beginning I secretly did "f(g(x)) = g(h(x))", too. I too needed some practice to drop the x.
14:51:04 <jethr0_> ;)
14:51:16 <idnar> huh, Java is pretty fast on sumcol
14:51:30 <Philippa> I still see better pointed a lot of the time
14:51:44 <olsner> weird, considering rev-comp is really just map f . lines =<< getContents
14:51:54 <dons> jethr0_: well, they're arrays of bytes.
14:51:54 <ddarius> idnar: The Java server implementations are actually pretty skippy.
14:51:54 <jethr0_> i am planning to come back to category theory. it's a definitely a fascinating and useful topic!
14:51:58 <Philippa> I think it's partly because of occasions when you then need to look at the types just to look up arities
14:52:11 <jethr0_> dons: i know. i'll try it with bytestring...
14:52:16 <litb> ddarius: yeah, i will look into it, thanks in advance
14:52:46 <jethr0_> is there any plans for some basic imaging libraries for haskell? everybody writing his own "ppm" reader can't be right...
14:53:03 <jethr0_> but then again i might just write it myself and publish
14:54:03 <monochrom> When I read categorical stuff, I still secretly imagine set theory and functional programming.
14:54:16 <dons> jethr0_: do you know of a good C lib to bind to?
14:54:32 <dons> i think there could be enough people interested, that we could do a good job
14:55:56 <vincenz> imagemagic?
14:56:00 <vincenz> or does that come with a k
14:56:14 <jethr0_> i guess imagemagic would be a possibility, but i'm not really into that. i wonder if perl/python/ruby used some library in the past
14:57:01 <dons> dcoutts: which version of bytestring is distributed on gentoo?
14:57:51 <paczesiowa> 0.9.0.4
14:58:01 <dcoutts_> dons: several, lemme check
14:58:33 <dcoutts_> dons: in portage it's just 0.9.0.1, the .0.4 is in the overlay
14:59:43 <dcoutts_> dons: let me know if it's important to get an update into portage
14:59:57 <idnar> < dons> its very easy to update. basically bytestring imports change, and -fvia-C goes in the options pragma
15:00:04 <BMeph> Does anyone know if the fingertree package on Hackage is the same as what's used in the Data.Sequence module?
15:00:13 <idnar> I don't see -fvia-C in the sum-file program
15:00:26 <dcoutts_> BMeph: the Data.Sequence is a finger tree that has been specialised for performance
15:00:49 <BMeph> dcoutts_: Whereas the fingertree package is more general?
15:00:50 <dcoutts_> BMeph: but other than that, yes it's the same. So the fingertree provides the generic version.
15:01:06 <dons> dcoutts_: so that would mean the bytestring version on the shootout would be 0.9.0.1?
15:01:07 <dcoutts_> BMeph: yes, parametrised by the monoid and measure
15:01:12 <dcoutts_> dons: yes
15:01:16 <dons> ok.
15:01:41 <BMeph> dcoutts_: Excellent, thank you. :)
15:04:42 <kuribas> jethr0_: It would be interesting to make a functional front-end for gegl: http://www.gegl.org/
15:04:42 <lambdabot> Title: GEGL-0.0.14
15:07:00 <jethr0_> kuribas: looks nice
15:08:00 <kuribas> Yes, I think a combinator library is nicer than "GeglNode *gegl = gegl_node_new ();".
15:08:01 <jethr0_> i would be happy if there existed simple things like import/export (ppm,png,gif,jpg) and a sane data type, together with some basics like (convolving, mapping, zipping two images) and if possible a data type that would make lazy operations and lazy output possible.
15:08:27 <jethr0_> even if written from scratch or using very basic libraries this should be only a few hundred lines of code
15:09:20 <dons> jethr0_: would you like to sketch the ideal api, and some possible C libs we could bind to that would provide that, (or stuff we can ourselves)?
15:09:34 <jethr0_> i guess there's libraries like libjpeg, libpng. so, all that's needed is a sensible data type and bindings to those libraries to get started on some cool image manipulation
15:10:00 <kuribas> jethr0_: You could perhaps reuse the code from netpbm?
15:10:58 <jethr0_> for example, i've just written "convolve" in 3 lines on a "[[Double]]" data type and that makes edge detection filters like "sobel" only 4 lines. with a good datatype, real advanced image manipulation might be a breeze
15:11:05 <jethr0_> netpmg?
15:11:10 <jethr0_> netpbm?
15:11:55 <kuribas> jethr0_: You would make a pure haskell library?
15:12:09 <kuribas> netpbm is here http://netpbm.sourceforge.net/
15:12:10 <lambdabot> Title: Netpbm home page
15:13:14 <jethr0_> kuribas: i don't really care. but seeing how easy sampling, convolving and edge detection were to implement it might be an option. but binding to a cool library is definitely a faster started. and one solution doesn't have to preclude the other.
15:14:03 <jethr0_> didn't know about netpbm. but it and imagemagick seem to be good candidates to bind to. and even if it's only a partial bind to import/export functions
15:15:02 <nominolo> monads are evil! i KNEW it! - "Too late to intercept the fledgling Warlock, they were forced to battle the Monad, a creature of pure evil created during a previous visit to the era by Torquemada."
15:15:49 <dons> heh
15:16:11 <thetallguy> Monads are evil.
15:16:39 <thetallguy> They're just better than many of the other things out there.
15:16:56 <jethr0_> > "monads" >> "are" >> "evil"
15:16:58 <lambdabot>  "evilevilevilevilevilevilevilevilevilevilevilevilevilevilevilevilevilevil"
15:17:05 <thetallguy> lol
15:17:12 <nominolo> rofl
15:17:21 <thetallguy> Haskell the Video Game.  I like it.
15:17:27 <nominolo> :t "monads" >> "are" >> "evil"
15:17:28 <lambdabot> [Char]
15:17:45 <sjanssen> @remember jethr0 "monads" >> "are" >> "evil"
15:17:45 <lambdabot> It is stored.
15:17:47 <sjanssen> @flush
15:18:21 <jethr0_> > reverse "murder"
15:18:22 <lambdabot>  "redrum"
15:18:30 <kuribas> jethr0_: gegl looks cool to me, and I think it can load many file formats.  I am not sure how well it supports a functional interface.
15:19:47 <jethr0_> kuribas: neither do i. but as much as i like pure, functional interfaces, right now i think there's a major need for basic import/export functionality and you could always write your own framework on top of that if you don't want to use gegl afterwards
15:21:19 <kuribas> jethr0_: Yes, I agree.
15:21:55 <kuribas> Even a decent PPM library would be nice :)
15:22:49 <jethr0_> yes, and that's like 100 lines of code. i just wrote one. but it's a hack, doesn't have a sane datatype and so on.
15:22:58 <RayNbow> > "monads" >> "are" >> "evil!" -- and now for some punctuation :p
15:22:58 <lambdabot>  "evil!evil!evil!evil!evil!evil!evil!evil!evil!evil!evil!evil!evil!evil!evil!...
15:23:11 <RayNbow> oh crap, stupid lambdabot is truncating the string :p
15:23:14 <jethr0_> maybe i'll work some more on it and then "release" it to the eager public
15:23:20 <jethr0_> RayNbow: lol
15:23:40 <thetallguy> "...and then this thunk came and stole all my memory!"
15:23:41 <kuribas> jethr0_: Count me to be part of it :)
15:24:43 <jethr0_> hmm, i guess binding to a library would be better though, even if it adds annoying dependencies. maybe if i'll find some time i'll have a look at binding some basic functions from gegl or netpbm or imagemagick. but currently time is not what i have too much of
15:25:19 <jethr0_> gegl doesn't seem to be very mature though. the galleries look like a pretty young project
15:46:25 <BMeph> I'm not looking forward to using C# for any serious programming - Delegates sound clunky, when you're used to using first-class functions.
15:47:06 <ddarius> BMeph: They are syntactically heavy and having to declare their types is annoying, but C# 3.0 has a much lighter weight notation.
15:48:00 <litb> i find it easy to say delegate() { ... } but frankly i only have done that not more with them
15:48:17 <BMeph> ddarius: That sounds... mildly encouraging.
15:48:30 * EvilTerran glares at Java
15:48:38 <BMeph> Like saying that the slave drivers hardly even whip anyone to death these days... ;p
15:48:39 <ddarius> BMeph: delegates are first class functions
15:49:28 <ddarius> BMeph: C# 3.0's syntax is completely reasonable.  It doesn't get much lighter weight than that.  If I understand correctly, it even includes some type inference.
15:50:06 <BMeph> ddarius: I thought that was the point - are functions generally first-class in C#? I wouldn't think so, since you have to support the whole OO paradigm.
15:52:22 <johnnowak> BMeph: many OO languages have had blocks for quite some time
15:52:23 <ddarius> BMeph: The only issue I had with delegates was that you can't use yield inside them.
15:52:36 <ac> is there a function in the standard libraries for printing numbers in base N?
15:52:41 <ddarius> I don't know if C# 3.0 changed that.
15:52:58 <dons> wow, reddit's got some weird ideas, "which is superior: turing machines or lambda calculus"
15:53:01 <ddarius> ac: There is a showIntAtBase or something like that in Numerics
15:53:26 <BMeph> ac: There sure is - and someone will likely tell you where, while I go poking around in my library listing... ;)
15:53:29 <ddarius> ac: It's ridiculously overgeneralized.
15:53:48 <ddarius> :t Numeric.showIntAtBase
15:53:50 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
15:53:57 <litb> wtf?
15:54:04 <litb> lol :)
15:54:07 <BMeph> dons: Wait - isn't it the whole point that they're equivalent?
15:54:14 <ac> yeah no kidding. Shouldn't that be: Int -> Int -> String?
15:54:15 <dons> yeah :)
15:54:29 <ddarius> ac: How do you show 1000 in base 624?
15:54:34 <dons> the church-turing thesis, and all that :)
15:54:40 <ac> right, right. I just want base 16
15:54:51 <ddarius> ac: Ah, that's a different question, then there is showHex
15:54:55 <ddarius> :t Numeric.showHex
15:54:56 <lambdabot> forall a. (Integral a) => a -> String -> String
15:55:00 <ac> sweet
15:55:32 <Big_Red> is there a map command where map f = foldr ((:) . f) []
15:55:38 <dons> mm. knuc got 15% faster. 10.486s before, 8.990s in 6.8
15:55:49 <dons> i should package up the hashtable in that entry, its snappy
15:55:52 <litb>  Big_Red looks like (>>=) []
15:55:53 <ac> I don't have Numeric
15:56:03 <Big_Red> bind?
15:56:15 <litb> @src [] (>>=)
15:56:15 <lambdabot> m >>= k     = foldr ((++) . k) [] m
15:56:18 <ddarius> ac: Numeric is a Haskell 98 library
15:56:27 <ddarius> @src map
15:56:27 <lambdabot> map _ []     = []
15:56:28 <lambdabot> map f (x:xs) = f x : map f xs
15:56:39 <litb> whaz is the difference between (:) and ++ anyway?
15:56:46 <ddarius> :t (:)
15:56:46 <lambdabot> forall a. a -> [a] -> [a]
15:56:51 <litb> both concatenates lists afaik
15:56:53 <ddarius> :t (++)
15:56:53 <lambdabot> forall a. [a] -> [a] -> [a]
15:57:12 <nanothief> litb: : doesn't concat lists, it concat an element to a list
15:57:13 <litb> ah, now i finally get that
15:57:14 <johnnowak> litb: (++) is a silly name for append, (:) is a silly name for cons
15:57:21 <BMeph> litb: cons (:) adds an element to the front of a list of such. Append (++) puts two entire lists together.
15:57:48 <ddarius> johnnowak: The names seem rather sensible to me.
15:58:20 <vincenz> @let cons = (:)
15:58:22 <lambdabot> Defined.
15:58:23 <vincenz> > cons 1 [2]
15:58:24 <lambdabot>  [1,2]
15:58:29 <BMeph> And snoc is where you put an element on the "back" end of a list.
15:58:30 <vincenz> @let append = (++)
15:58:31 <lambdabot> Defined.
15:58:32 <dons> ?users
15:58:32 <lambdabot> Maximum users seen in #haskell: 454, currently: 426 (93.8%), active: 12 (2.8%)
15:58:43 <ddarius> What is Daan Leijen's email address these days?
15:59:10 <vincenz> > append [1] [2]
15:59:10 <lambdabot>  [1,2]
15:59:33 <Philippa> ddarius: probably listed on his web site?
15:59:34 <litb> seems like the haskell community grows fastly
16:00:01 <ddarius> Philippa: Neither the uu.nl nor the microsoft.com one seem to work.
16:00:58 <BMeph> ddarius: Now I wish someone would take that Monad talk of Brian's and just chop off the final third. Seriously, Java is in the list of "performance-biased" languages, and Algol is one of the "languages that are thought of as slow"?
16:02:06 <BMeph> I hope someone mentioned to him that maybe all of the other languages are slow because they're used in an interpretive environment, and not compiled.
16:02:33 <conal> ddarius: try his first name at equational.org
16:02:36 <litb> after all, c and c++ tend to be the fastest available
16:02:43 <cu3edweb> What is a simple starter program to help learn haskell?
16:02:59 <litb> cu3edweb: isn't it fact ?
16:03:11 <ddarius> cu3edweb: What do you find interesting?
16:03:16 <litb> cu3edweb: ah, maybe you mean ghci
16:03:31 <cu3edweb> I was playing with ghci a little
16:03:47 <nornagon> so, like, when is ohloh getting darcs support? :-D
16:04:01 <litb> but beware, it is misleading since all of your commands are executed in a do { ...} block and so behave differently than in a real program
16:04:12 <litb> nornagon: lol
16:04:34 <cu3edweb> I was think I have a simple python program that changes the vol up and down. Would that be very hard in haskell?
16:05:01 <ddarius> cu3edweb: Probably not unless you are using some python specific library to do it.
16:05:03 <litb> cu3edweb: i suppose you first have to read about Monads
16:05:34 <cu3edweb> I will start reading about monads then. Thanks
16:05:54 <Botje> poor guy
16:06:05 <cu3edweb> Who me?
16:06:26 <Botje> monads aren't exactly the easiest concept in the world to grasp
16:06:34 <Botje> even though the way you use them for IO is pretty straightforward
16:06:51 <ddarius> You can use IO without even having heard of monads.
16:07:03 <Botje> yeah
16:07:05 <Philippa> right up until the typechecker complains, anyway
16:07:19 <Botje> writing code in the IO monad is in fact easier if you don't know the first thing about monads :D
16:07:37 <litb> it will confuse the heck out of you as soon you read a program that uses monads tho. at least it is like that for me
16:08:02 <cu3edweb> Can you do anything you want to haskell or is only good for certain things?
16:08:23 <Botje> haskell is a generic language, but it's a bit lacking in the libraries department
16:08:28 <Botje> though there's new libs every day :)
16:08:43 <litb> cu3edweb: to see a nice thing done with haskell, you could visit #geordi
16:08:58 <conal> litb: what's #geordi?
16:09:11 <litb> imho, haskell needs more object orientation paradigm
16:09:19 <ddarius> litb: Why?
16:09:32 <Botje> litb: but objects are all about mutating state?
16:09:32 <litb> conal: it's a bot that compiles and executes c++ for irc channels
16:09:44 <conal> litb: neat.  thx.
16:09:47 <Botje> which kind of conflicts with haskells purity approach :)
16:10:11 <glen_quagmire> :t snoc
16:10:13 <lambdabot> Not in scope: `snoc'
16:10:37 <glen_quagmire> @hoogle snoc
16:10:38 <litb> ddarius: i found it cumbersome to write my Function datatype. ideally i would want to derive my DeriverableFunction from Function . but haskell doesn't like that, or at least i didn't get it to work
16:10:38 <lambdabot> Data.ByteString.snoc :: ByteString -> Word8 -> ByteString
16:10:38 <lambdabot> Data.ByteString.Char8.snoc :: ByteString -> Char -> ByteString
16:10:38 <lambdabot> Data.ByteString.Lazy.snoc :: ByteString -> Word8 -> ByteString
16:10:48 <paczesiowa> snoc :: :: a -> [a] -> [a]
16:11:08 <RayNbow> <dons> wow, reddit's got some weird ideas, "which is superior: turing machines or lambda calculus" <-- lol
16:11:10 <ddarius> litb: Which suggests that you do things in a different way; it is a different paradigm.
16:11:31 <litb> ddarius: yes, that's because i know oop langs too tho
16:11:42 <litb> hehe
16:11:44 <Botje> litb: try to forget everythin you learned with oo langs
16:11:55 <ddarius> litb: If you want an OO language or an OO functional language there are plenty.  Haskell is not one of them though.
16:12:05 <faxathisia> This reddit thing is for real?
16:12:14 <RayNbow> faxathisia, yes
16:12:15 <RayNbow> http://programming.reddit.com/info/65zuz/comments/
16:12:17 <litb> faxathisia: reddit?
16:12:47 <faxathisia> wtf...
16:13:05 <litb> oh i see
16:13:07 <BMeph> RayNBow: It reminds me of a reviewer of Lua that hated the fact that Lua doesn't treat integers differently than floating-point. Drove him nuts, but it was funny to read.
16:13:15 <olsner> wow! I must've done something extraordinarily stupid now... my haskell reverse-complement is 1200 times slower than the C++ version
16:14:16 <RayNbow> BMeph: I'm not familiar with Lua
16:14:25 <RayNbow> does Lua only know a single, numeric type?
16:14:45 <johnnowak> RayNbow: yes, doubles
16:14:55 <BMeph> RayNbow: Yes. Internally, Lua just uses floating point for everything.
16:15:21 <BMeph> You can hack the source code and change it (which floks do for embedded platforms).
16:15:29 <BMeph> s/floks/folks/
16:15:46 <glguy> (similar to JavaScript)
16:18:39 <BMeph> It was funny, to me, because he'd write about how he needed to do something with integers, not numbers, and I'd always tell him, "but integers ARE numbers." :)
16:18:55 <RayNbow> woah, the reddit thread now contains a link to the Sipser book
16:19:04 <faxathisia> Sipser?
16:19:12 <RayNbow> http://www.amazon.com/Introduction-Theory-Computation-Michael-Sipser/dp/053494728X
16:19:14 <lambdabot> http://tinyurl.com/kfhcr
16:19:48 <EvilTerran> ISTR IEEE guarantees accuracy in the case of would-be integer operations, anyway
16:19:57 <Botje> levi: are you back yet?
16:20:15 <RayNbow> hmm, although I have a different edition of the book
16:20:20 <olsner> what's "ISTR" stand for?
16:20:27 <Botje> "i seem to remember"
16:20:33 <Botje> doesn't \bot have an acronym db?
16:20:37 <olsner> ah
16:20:46 <EvilTerran> (addition, subtraction, multiplication - in the cases where the operands and result can be represented exactly in the floating-point representation, anyway)
16:20:49 <EvilTerran> (i may be wronG)
16:20:55 <EvilTerran> @alldict ISTR
16:20:55 <lambdabot> *** "istr" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
16:20:55 <lambdabot> ISTR
16:20:55 <lambdabot>      I Seem To Recall / Remember (telecommunication, Usenet, IRC)
16:20:55 <lambdabot>  
16:21:04 <EvilTerran> @help vera
16:21:04 <lambdabot> I perform dictionary lookups via the following 13 commands:
16:21:04 <lambdabot> all-dicts ... Query all databases on dict.org
16:21:04 <lambdabot> devils ...... The Devil's Dictionary
16:21:04 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
16:21:04 <lambdabot> elements .... Elements database
16:21:06 <lambdabot> [9 @more lines]
16:21:12 <EvilTerran> buh
16:22:15 <ddarius> He may have wanted to rely on wrapping behavior.
16:22:33 <olsner> whyever that's an improvement over floats
16:22:56 <EvilTerran> ddarius, ew.
16:23:24 <EvilTerran> the only valid concern i can think of would be performance, if you're doing a lot of number crunching
16:23:36 <EvilTerran> but then i'd not be using lua
16:24:26 * RayNbow blinks at the price of the US version of the Sipser book...
16:24:37 <ddarius> Interfacing might be another aspect.
16:25:05 <paczesiowa> is there any other interesting thing about folds, except that foldl (when strict) is fast, and foldr is great for generating lists?
16:25:10 <RayNbow> http://www.amazon.co.uk/Introduction-Theory-Computation-Michael-Sipser/dp/0619217642 <-- International edition is cheaper
16:25:12 <lambdabot> http://tinyurl.com/3297wu
16:25:15 <EvilTerran> if lua has inter-language bindings, i'm sure it'll be able to convert appropriately
16:25:25 <ddarius> EvilTerran: Presumably.
16:25:36 <olsner> paczesiowa: folds eliminate many uses for explicit recursion, so produce shorter and sweeter programs
16:26:06 <ddarius> paczesiowa: folds are guaranteed to terminate when applied to finite input and if the functions passed in terminate on all inputs.
16:26:11 <BMeph> EvilTerran: Right - Lua made, to replace both a scripting language and a data formatting language. Doing high-level processing in it is kind of silly. Possible, but silly.
16:26:36 <ddarius> paczesiowa: Folds also dualize into unfolds which have dual properties.  There is tons of research on properties of folds.
16:26:54 <RayNbow> hmm
16:26:55 <RayNbow> http://www.realworldhaskell.org/blog/2008/01/19/happy-50th-birthday-simon-peyton-jones/
16:26:56 <lambdabot> Title: Real World Haskell  Blog Archive  Happy 50th birthday, Simon Peyton Jones!, http://tinyurl.com/2rhuqd
16:27:10 <paczesiowa> and how about folds inside IO monad?
16:27:42 <dons> hehe, part way through updating the shootout entries,
16:27:46 <dons>  check out the scores... http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
16:27:47 <lambdabot> Title: Create your own Ranking | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lan ..., http://tinyurl.com/lepfo
16:27:49 <dons> :)
16:28:01 <dons> we're kicking it.
16:28:09 <ddarius> paczesiowa: There are papers about monadic folds.
16:28:23 <glguy> dons: and with 3 errors remaining??
16:28:41 <dons> yep :)
16:28:44 <dons> i'm on those.
16:28:59 * dons wonders if we'll catch clean 
16:29:08 <glguy> So 6.8.2 is a "win"?
16:29:16 <dons> its made of win and awesome
16:29:17 <jfredett> dons, is -O2 still the highest optimization? or does -O3 work now?
16:29:24 <dons> no. -O2 is always what we want.
16:29:27 <jfredett> okay
16:29:34 <dons> i've turned it on by default across the shootout
16:29:34 <paczesiowa> ddarius: I mean, that computation inside IO monad is strict, so what are pros and cons of both folds?
16:29:39 <dons> and will update the last couple of programs now.
16:30:12 * RayNbow once was amazed that evaluating certain expressions were damn fast in ghci...
16:30:17 <faxathisia> Very funny, http://www.realworldhaskell.org/blog/wp-content/themes/mistylook-101/img/profile.jpg
16:30:18 <lambdabot> http://tinyurl.com/39xd9w
16:30:22 <RayNbow> turned out that ghci loaded an old compiled version :p
16:30:34 <dons> :)
16:30:51 <dons> beating gcc on a range of benchmarks
16:30:53 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=spectralnorm&lang=all
16:30:54 <lambdabot> Title: spectral-norm benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lan ..., http://tinyurl.com/bruf8
16:31:02 <ddarius> paczesiowa: There is only a "left" monadic fold in the standard libraries.
16:31:18 <pejo> dons, any idea if 6.10 will help the shootout even more?
16:31:21 <glguy> So Pascal is quite speedy too, eh?
16:31:58 <kuribas> I finally have my emacs indentation mode in a usable state.
16:32:02 <dons> beating ocaml on a bunch of things too
16:32:06 <ddarius> dons: I imagine we'll come closer to Clean when the register allocation code is improved.
16:32:20 <dons> ddarius: i think that's a *definite* now.
16:32:25 <dons> since we're almost there.
16:32:35 <glguy> Is there a shootout page that uses a 64-bit processor?
16:32:43 <glguy> since that's where ghc's register allocation comes in?
16:32:46 <sjanssen> we're handily beating OCaml too
16:33:16 <sjanssen> glguy: 64 bit benchmarks are usually a mixed bag, due to the 2x memory use
16:33:57 <glguy> the other language implementations don't make use of the 64-bit sized stuff?
16:34:05 <sjanssen> not universally like GHC does
16:34:23 <sjanssen> eg. C int is still 32 bits on AMD64
16:34:32 <dons> pointer tagging is a great optimisation for purely functional programming
16:34:42 <dons> True/False , Nothing/Just, packed into the lower end bits of the thunk pointer
16:34:56 <dons> only works if you're pure. otherwise its too expesnive
16:35:24 <glguy> Does that mean that a standard boxed Bool can no compete with an unboxed one?
16:35:33 <glguy> (is there an unboxed one?)
16:35:37 <glguy> now*
16:35:49 <dons> its a good question.
16:35:57 <olsner> how about unevaluated thunks? is there another bit for telling if it's evaluated or not, or how does it work?
16:36:01 <sjanssen> GHC can't unbox types with more than one constructor (unless Bool is a special case?)
16:36:02 <dons> yep
16:36:05 <dons> olsner: that's right.
16:36:15 <olsner> ah
16:36:25 <glguy> olsner: if the tag is "0" then it's unknown and needs ot be evaluated
16:36:31 <glguy> if it's larger then it knows the constructors
16:36:43 <glguy> (roughly, I don't know the exact implementation details)
16:37:18 <litb> question:
16:37:47 <EvilTerran> answer:
16:37:48 <litb> if i have a function that produces a result out of a number N (N from 1 ..) and i want to sum up all the results
16:37:51 <litb> what should i do?
16:38:10 <glguy> all the results of what
16:38:11 <paczesiowa> why does "main = 100000000 `replicateM_` randomRIO ('a', 'z')" eat so much memory?
16:38:18 <twanvl> sum (map f [1..n])
16:38:19 <litb> could i map the number to the function  and then use sum?
16:38:31 <glguy> yeah
16:38:49 <litb> twanvl: i do that currently. but i wonder about the efficiency of that (those numbers could get really big)
16:38:53 <dons> btw, we jumped 14 places up the language scale by fixing 4 programs :)
16:39:01 <EvilTerran> woo
16:39:24 <kuribas> Would anyone like to try out my new emacs indentation-mode?
16:39:25 <twanvl> litb: in that case the numbers will be really big no matter how you do it
16:39:51 <dons> we're ahead of gcc in 4 programs now
16:39:59 <glen_quagmire> do you have a short haskell program that can be redirected to /dev/dsp and it sounds nice?
16:40:08 <dons> all naive, thread-ring, sum-file, spectral-norm (not naive), binary-tress
16:40:14 <glen_quagmire> like, ./Main > /dev/dsp    #and weeeeeeeeeeeeeee
16:40:37 <ddarius> dons: The guy let ruby run for about an hour and a half on thread-ring.
16:40:39 <litb> twanvl: i mean, if the number that is currently being mapped is p (1<=p<=n) , are the numbers <p all saved?
16:40:41 <dons> we're no worse than 3.9x slower than gcc, for nbody (a mutable array/double benchmark)
16:40:45 <dons> ddarius: :)
16:41:11 <litb> twanvl: since ideally it would need constant memory space. but if they are all saved, then it needs linear memory
16:41:15 <dons> regex-dna might be hard to fix. it needs an external library (e.g. pcre-light)
16:41:22 <dons> so i'll have to ask igouy nicely to install that.
16:41:30 <EvilTerran> litb, that's an implementation detail. also premature optimisation.
16:41:45 <EvilTerran> unless you know you're dealing with a *lot* of data, don't worry about it :)
16:41:54 <litb> ok, i see
16:41:57 <ddarius> glen_quagmire: There are some really cool things that can be very easily implemented using lazy lists for sound synthesis.  It would be easy to output it in a format /dev/dsp likes.
16:42:36 <glen_quagmire> ddarius: yah it should play happy birthday to you song.
16:42:44 <EvilTerran> i think, in ghc, fusion may remove the imtermediate list
16:42:50 <Toxaris_> litb: due to laziness, the result of (map f [1..n]) should never be fully constructed
16:42:54 <ddarius> glen_quagmire: That could be done.
16:43:23 <ddarius> litb: EvilTerran and Toxaris_ have explained that either way you should get constant time behavior.
16:43:38 <ddarius> Er constant space
16:43:57 <EvilTerran> the optimiser's not quite *that* good ;)
16:44:19 <Toxaris_> litb: if you feel that it is constructed, try (foldl' (+) 0) instead of sum :)
16:44:47 <glguy> paczesiowa: the problem is that all 100000000 numbers must be generated
16:44:52 <glguy> before the computation can continue
16:46:40 <kuribas> quicksilver: ping
16:47:16 <kuribas> No emacs users here?
16:47:29 --- mode: ChanServ set +o dons
16:47:33 --- topic: set to '["Happy 50th Birthday Simon!", "GHC 6.8 is made of win and awesome", "The Haskell programming language" ,"http://haskell.org " ,"http://www.jobs-in-fp.org/" ,"Paste: http://hpaste.org " ,"Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
16:47:37 --- mode: ChanServ set -o dons
16:47:43 <ddarius> glen_quagmire: pluck freq = outpt where output = take (round $ samplingRate / freq) whiteNoise ++ zipWith (\a b -> (a+b)/2) output (tail output) -- this will produce a noise like a guitar pluck
16:47:58 <dcoutts_> dons: pcre might not be the fastest for regex-dna if it doesn't need the pc parts of pcre. A DFA might be fastest. That might be something like regex-tre.
16:48:12 <litb> kuribas: i code with emacs
16:48:30 <ddarius> glen_quagmire: Just mix together one of these properly shifted for each note and you can have it play happy birthday.
16:48:37 <dons> dcoutts_: yeah, regex-tre should be better, but its harder to get the dependencies on the shootout box
16:48:45 <dons> while i know libpcre is there (and is reasonable)
16:48:54 <dons> dcoutts_: btw, did you see the partially updated shootout scores? :)(
16:49:01 <litb> kuribas: it works like a charm
16:49:09 <kuribas> litb: what does?
16:49:10 <glen_quagmire> ddarius: i'll try. i'm not sure what format /dev/dsp takes. in the program i have to writeFile or putChar  and redirect to /dev/dsp
16:49:24 <dcoutts_> dons: ah yes, we've got regex-tre in the overlay but not in portage. Shout if you need it (or anything else) in portage.
16:49:28 <litb> kuribas: emacs
16:49:40 <dons> dcoutts_: ok. sweet. i'll look at the regex one last of all.
16:49:43 <kuribas> litb: Not without my indentation-engine!
16:49:49 <kuribas> I'll paste it
16:49:53 <dcoutts_> dons: I've not seen them yet, no. I just noted that several needed updating. Are they much better?
16:49:59 <dons> i just updated a bunch...
16:50:13 <dons> we jumped 14 places. every program got faster. some a *lot*
16:50:24 <dons> pointer tagging mostly, but spec constr also fired a fair bit.
16:50:49 <dons> ahead of C in 4 programs, beating ocaml a lot. ahead of all strict functional languages now.
16:50:57 <paczesiowa> glguy: but the computation "is" generating them, so I don't understand how does it continue
16:51:16 <glguy> paczesiowa: it generates them all and stores their values
16:51:20 <glguy> that's a lot of values to store
16:51:29 <dcoutts_> dons: nice :-)
16:51:33 <litb> kuribas: meh, please don't hope that i can help with lisp issues :)
16:51:37 <dons> and we're not done. we *might* catch Clean.
16:51:38 <glguy> paczesiowa: if what you want is a random lazy list
16:51:43 <glguy> :t randoms
16:51:45 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
16:51:47 <litb> or elisp issues or something o.O
16:51:53 <glguy> something like that is much better
16:52:00 <kuribas> litb: No, I just need people to find bugs :)
16:52:02 <dons> pointer tagging is just such an awesome Haskell secret weapon
16:52:02 <glguy> so that they aren't all stored in memory
16:52:13 <dcoutts_> dons: does -O2 still imply -fvia-C ? I know -O doesn't any more.
16:52:16 <paczesiowa> glguy: thx!
16:52:23 <glguy> :t randomsR
16:52:24 <lambdabot> Not in scope: `randomsR'
16:52:29 <Toxaris> glguy: why doesn't produce replicateM_ the actions to be performed lazily, since replicateM_ n == foldr (>>) (return ()) . take n . repeat
16:52:29 <litb> kuribas: where is it? maybe i find time to try it out :D
16:52:30 <ddarius> dcoutts_: The docs don't say it does.
16:52:30 <dons> dcoutts_: it doesn't. i have to set -fvia-C explicitly on a few
16:52:35 <glguy> is there a bounded random lazy generator?
16:52:35 <dons> double math ones, in particular.
16:52:40 <litb> althogh the default one works quite good for me
16:52:43 <faxathisia> I think SBCL does pointer tagging
16:52:48 <dons> glguy: oh curious questoin. bounded by ?
16:52:56 <dons> faxathisia: it does, but not the kind ghc does
16:52:59 <glguy> dons: in the spirit of randomRIO
16:52:59 <ddarius> glguy: take n . randoms?
16:53:09 <ddarius> :t randomRs
16:53:11 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
16:53:13 <dons> faxathisia: types are tagged at runtime, not values
16:53:24 <glguy> ddarius: yeah, that, I had the last two letters switched
16:53:27 <glguy> paczesiowa: that's what you want
16:53:30 <dons> faxathisia: in ghc now, whether something is True/False, Just/Nothing, are packed into the pointer to the thunk
16:53:31 <kuribas> litb: I am trying to paste it...
16:53:36 <dcoutts_> dons: that's interesting. Will have to bear floating point perf in mind when ghc ditches the registerised C backend.
16:53:39 <dons> so using ADTs got really cheap
16:53:41 <faxathisia> Ahh, I see
16:53:47 <faxathisia> That's cool
16:53:49 <dons> dcoutts_: definitely. i think SimonM is accutely aware
16:54:05 <dons> faxathisia: and you need purity, or its not worth it -- you'd have to flip the bits whenever you mutated the value
16:54:16 <dons> but in a pure language, you set it once when you  evaluate it, and you're done
16:54:25 <ddarius> We need to dig up some grad student who'd be interested in backend compiler implementation.
16:54:47 <glen_quagmire> i just made an unsigned 8bit mono pcm  called audio.wav.  cat audio.wav > /dev/dsp   plays it soooooo slow and low pitched. i can't even recognize if it's the same thing.
16:54:48 <dons> we've got a few, did you see the ghc entry in the hcar, ddarius ?
16:55:16 <glen_quagmire> so, i guess it's related to speed of IO redirection and cat
16:55:26 <kuribas> litb: http://paste.lisp.org/display/54504
16:55:41 <ddarius> dons: I've only skimmed the HC&AR.
16:56:08 <dons> there's a 'what we're going to do with the codeGen' section for ghc
16:56:27 <kmcallister> glen_quagmire, you have to use ioctls to set the format on /dev/dsp
16:56:33 <kmcallister> it might be expecting something other than 8 bit mono
16:56:40 <ddarius> glen_quagmire: Are the sampling rates the same.  If the wav file is at 22150 hz, say, and /dev/dsp is at 8000 it's going to sound 3 octaves lower (roughly)
16:56:41 <pheaver2> is this the right channel for cabal questions?
16:57:09 <litb> nice, thxx i have saved it and use it if i get time :D
16:57:34 <kuribas> Is there a mailing list for general announcements?
16:57:51 <mauke> haskell@
16:57:55 <litb> kuribas: have you written that whole stuff?
16:57:59 <dons> pheaver2: yeah
16:57:59 <kuribas> yes
16:58:17 <litb> nice indeed
16:58:19 <pheaver2> heh, thanks dons :)
16:58:29 <dons> this is crazy stuff, 'fasta' goes from 34.507s to 26.790s with 6.8
16:58:41 <dons> just take all the old scores, and knock 15-25% off them.
16:58:46 <pheaver2> dons: you know I am phil, right?
16:58:51 <dons> pheaver2: i know :D
16:58:59 <dons> hey everyone, its phil! <--
16:59:01 <pheaver2> all rightee
16:59:07 <dons> he's a commercial haskell hacker.
16:59:11 <dons> you may now express awe :)
16:59:17 <pheaver2> ...
16:59:20 <glguy> TV commercials?
16:59:21 <dons> !!!
16:59:28 <dons> oh its glguy
16:59:39 <pheaver2> ya know, i don't know if i am being mocked :)
16:59:44 <dons> no no. :)
16:59:55 <dons> what's your cabal issue, pheaver2. we can plug you into dcoutts_, who knows all about the cabal
16:59:56 <pheaver2> oh ok
17:00:10 <pheaver2> ah, I tried install yi on arch linux
17:00:20 <dons> ah. yi eh.
17:00:25 <pheaver2> heh
17:00:39 <pheaver2> the build command just says...
17:00:51 <pheaver2> "Package yi-0.3 can't be built on this system"
17:00:57 <pheaver2> this is the darcs version with ghc-6.8.2
17:00:58 <ddarius> dons: Cool (re GHC section in HC&AR except the "generalized" list comprehensions)
17:01:07 <glguy> pheaver2: You have 64-bit?
17:01:13 <pheaver2> nope, 32
17:01:23 <dons> ddarius: yeah, 'cept that bit.
17:01:31 <litb> i have a datatype Naeherung which saves a approximation of some calculation. and now i want that it supports (-) and (+) and maybe others.
17:01:32 <dons> ddarius: did wadler jump the shakr? ;)
17:01:33 <pheaver2> it's running in a virtual machine
17:01:37 <dons> shark.
17:01:58 <pheaver2> it's just a little disappointing that the error message is so... vague
17:02:00 <litb> do i need to write a instance declaration for Num Naherung then? and implement (-) (+) and all others i want to use ?
17:02:09 <ddarius> litb: Yes.
17:02:12 <mauke> hehe, 300955 threads
17:02:31 <ddarius> pheaver2: -v3 ?
17:02:56 <litb> ddarius: (just one another silly question o.O) is it considered bad style if one writes an instance of Num and only implement (-) ?
17:03:02 <pheaver2> ddarius: didn't help much :p
17:03:15 <litb> ( i want to use it to get the difference to an exact value )
17:03:30 <clanehin> litb: use a function named subtractMyThingie
17:03:31 <ddarius> litb: Yes, but it's done all the time because the numeric heirarchy isn't in the ideal factoring.
17:03:40 <pheaver2> it just outputted one extra line when trying to build: ("/usr/bin/ghc",["--print-libdir"])
17:04:41 <pheaver2> oh, my bad... I build Setup.hs using ghc --make, so I was passing -v3 to that executable.  I see I am supposed to do "runhaskell -v3 Setup.hs build
17:04:41 <pheaver2>  
17:05:19 <litb> ddarius: you mean haskell does it wrong with naming the classes?
17:05:37 <pheaver2> well, i see a lot of information, but it all looks normal until it suddenly says that the package can't be built on this system
17:07:34 <Cale> hmm... who was I talking with the other day about class constraints in data declarations using the GADT syntax?
17:07:37 <pheaver2> gotta run, though, later
17:08:16 <Cale> In any event, I just checked, and I'm not crazy, they don't work in 6.6.1, but do work in 6.8.2
17:08:41 <Cale> (In the sense that they actually store a dictionary along with the data.
17:08:43 <Cale> )
17:15:55 <ddarius> litb: Haskell groups the numeric functions in a somewhat crazy way.
17:18:53 <airport> hello, I have a newbie question
17:20:23 <EvilTerran> @quote meta-ask
17:20:23 <lambdabot> meta-ask says: Don't ask to ask, just ask!
17:20:25 <airport> how do you use the Read class to unmarshall a date
17:20:47 <mauke> by calling read
17:20:58 <dons> are dates Readable? to which type?
17:20:58 <airport> how do you call read?
17:21:10 <airport> I've been trying that
17:21:44 <Cale> > read "5" :: Integer
17:21:47 <lambdabot>  5
17:22:00 <EvilTerran> > read "\"ooga booga\"" :: String
17:22:01 <lambdabot>  "ooga booga"
17:22:27 <mauke> > read "'\"'" :: Char
17:22:27 <lambdabot>  '"'
17:22:55 <EvilTerran> > read "War and Peace" :: Book
17:22:55 <lambdabot>   Not in scope: type constructor or class `Book'
17:22:56 <Cale> hmm
17:22:58 <airport> ah! works
17:23:05 <Toxaris> > read "Just [42]" :: Maybe [Int]
17:23:06 <lambdabot>  Just [42]
17:23:10 <airport> read (show ct)::CalendarTime
17:23:17 <airport> that worked for me
17:23:20 <Cale> > read "2008-01-01" :: Day
17:23:20 <lambdabot>   Not in scope: type constructor or class `Day'
17:23:33 <EvilTerran> ?index CalendarTime
17:23:33 <lambdabot> System.Time, System.Time
17:23:40 <Cale> > read "2008-01-01" :: Data.Time.Calendar.Day
17:23:40 <lambdabot>      Not in scope: type constructor or class `Data.Time.Calendar.Day'
17:23:52 <EvilTerran> > read "2008-01-01" :: System.Time.CalendarTime
17:23:52 <lambdabot>      Not in scope: type constructor or class `System.Time.CalendarTime'
17:23:56 <Cale> No new date libraries in \bot apparently.
17:24:07 <paczesiowa> :t randomRs
17:24:08 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
17:24:11 <gnuvince_> Hello
17:24:15 <Cale> Hello
17:24:19 <EvilTerran> Hello
17:24:30 <gnuvince_> I need to get convert a floating value to an integral value
17:24:37 <hpaste> Hello
17:24:38 <gnuvince_> (the return value of sqrt)
17:24:41 <gnuvince_> How would I do that?
17:24:48 <EvilTerran> ?hoogle (RealFrac a, Integral b) => a -> b
17:24:49 <glen_quagmire> hpaste: hello
17:24:50 <lambdabot> Prelude.truncate :: (RealFrac a, Integral b) => a -> b
17:24:50 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
17:24:50 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
17:24:53 <Cale> round?
17:24:56 <hpaste> Hello
17:24:58 <EvilTerran> ?hoogle+
17:24:58 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
17:24:58 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
17:24:58 <lambdabot> Data.Generics.Aliases.unGM :: GenericM' m -> Data a => a -> m a
17:25:03 <gnuvince_> Thank you
17:25:08 * EvilTerran blinks
17:25:12 * EvilTerran looks at hpaste
17:25:57 <airport> could any one explain read's signature?
17:26:03 <Toxaris> hpaste: tell me. did you dream tonight?
17:26:04 <EvilTerran> ?type read
17:26:05 <lambdabot> forall a. (Read a) => String -> a
17:26:07 <paczesiowa> what's wrong with haddock's docs for randomRs ? http://haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html#v%3ArandomRs it has wrong type (no Random constraint for a)
17:26:09 <airport> read :: (Read a) => String -> a
17:26:09 <lambdabot> http://tinyurl.com/2xxbhl
17:26:19 <airport> what is the => stand for?
17:26:34 <Cale> paczesiowa: That's implied
17:26:50 <Cale> paczesiowa: Note that it's inside the documentation for  'class Random a'
17:27:05 <Toxaris> airport: the signature means: for every type a, wich is an instance of type class Read, read can have type String -> a
17:27:11 <Cale> airport: It separates typeclass constraints from the rest of the type
17:27:14 <EvilTerran> "read :: for all a, 'a' is a 'Read' type => String -> a"
17:27:22 <EvilTerran> it means "implies". ish.
17:27:23 <Cale> airport: You could read it as "implied"
17:27:24 <paczesiowa> Cale: sorry, getting blind this late:/
17:27:28 <Cale> "implies"*
17:27:32 <ddarius> airport: It would probably be useful to read something more substantial about this e.g. http://www.haskell.org/tutorial/
17:27:32 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
17:27:56 <hpaste>  Tac-Tics pasted "How can I fix this error with RWS?" at http://hpaste.org/5099
17:28:02 <Cale> airport: First of all, you already understand type variables?
17:28:26 <airport> thank you very much
17:28:36 <EvilTerran> ?hoogle rws
17:28:37 <lambdabot> Control.Monad.RWS :: module
17:28:37 <lambdabot> Control.Monad.RWS.Lazy.RWS :: newtype RWS r w s a
17:28:37 <lambdabot> Control.Monad.RWS.Lazy.RWS :: (r -> s -> (a, s, w)) -> RWS r w s a
17:28:38 <Cale> Like in  length :: [a] -> Integer, the a refers to the fact that length doesn't care what type of elements the list contains.
17:28:38 <Toxaris> Tac-Tics: you need to add type signatures :)
17:28:42 <airport> yeah i understand type variables, but the => confused me
17:28:43 <ddarius> Tac-Tics: It tells you.
17:29:03 <Cale> airport: Okay, well, typeclasses give a way to restrict which types those type variables range over.
17:29:17 <Cale> airport: and in so doing, specify that certain functionality has to be present
17:29:18 <Toxaris> Tac-Tics: try (1 :: Int) instead of 1
17:29:19 <litb> it tells you to what class a variable belongs to
17:29:35 <EvilTerran> Tac-Tics, it's probably the Dreaded Monomorphism Restriction or something
17:29:53 <faxathisia> Oh
17:29:59 <Cale> For example, Eq is a typeclass that tells you that (==) can be used to compare values for equality.
17:30:10 <glguy> :t let cool = do x <- get; put (x + 1); tell x; cool in cool
17:30:15 <lambdabot> forall (t :: * -> *) t1 t2. (Num t1, MonadWriter t1 t, MonadState t1 t) => t t2
17:30:17 <litb> it's somewhat identical to c++0x concepts i think
17:30:29 <Cale> :t (==)
17:30:30 <lambdabot> forall a. (Eq a) => a -> a -> Bool
17:30:38 <Tac-Tics> I tried adding a type signature, but it still yells ago me. But I'll play around with it a bit more
17:30:39 <Toxaris> Tac-Tics: or maybe you need braces? let cool = do { ... }
17:30:43 <ddarius> litb: The writings on C++ concepts explicitly reference type classes.
17:31:00 <litb> ah, good to know
17:31:07 <duaneb> hey haskell peeps
17:31:13 <Cale> duaneb: hello
17:31:18 <hpaste> Hello
17:31:22 <litb> hello duaneb
17:31:23 <airport> cale: thanks
17:31:24 <faxathisia> I was wondering.. Why is lamba binding not the same as let? Would there be some bad repercussions to type-checking?
17:31:31 <faxathisia> lambda*
17:31:39 <duaneb> is there a function that just takes two lists and compares same entrie
17:31:40 <Philippa> yes
17:31:42 <ddarius> faxathisia: You mean polymorphism-wise/
17:31:46 <duaneb> s/entrie/entries
17:31:49 <duaneb> /
17:31:51 <faxathisia> Yes
17:31:56 <Philippa> let tells the typechecker "you can generalise here"
17:31:58 <ddarius> faxathisia: Then as Philippa said, yes.
17:32:00 <Cale> duaneb: you want to see if every member of xs is a member of ys?
17:32:03 <hpaste>  Tac-Tics annotated "How can I fix this error with RWS?" with "Added type signature of failure." at http://hpaste.org/5099#a1
17:32:03 <Philippa> with a lambda, it never have a safe place to generalise
17:32:07 <faxathisia> duaneb: ==
17:32:09 <duaneb> faxathisia: do you stalk me?
17:32:09 <Toxaris> > zipWith (==) [1, 2, 3] [2, 2, 3] -- duaneb like this?
17:32:10 <lambdabot>  [False,True,True]
17:32:14 <Philippa> so it has to assume the type's monomorphic
17:32:16 <Cale> duaneb: Or just check that the two lists are exactly the same?
17:32:26 <duaneb> Cale: == is pretty much what I want
17:32:49 <paczesiowa> what should I do if I need two lists ([Int] and [Char]) of random things? can I initialize them with the same generator?
17:32:54 <ddarius> Tac-Tics: You need to fix t1, you can't do that by giving a type to the whole term as that only fixes t and t2.
17:33:24 <litb> what does it mean if i get a1 or so by ghci when i do ":t someExpression" ?
17:33:38 <Philippa> that's a type variable
17:33:57 <litb> because usually it says a...z but sometimes it says a1 or b1 or so (i.e with a number beside the alpha character)
17:34:13 <litb> i mean, does the number have a special meaning?
17:34:16 <ddarius> No
17:34:34 <faxathisia> Iambda introducing foralls would make type inference undecideable?
17:34:36 <Toxaris> litb: ghc(i) tries to reuse the names the programmer used, but sometimes has to add numbers to produce unique names
17:34:39 <EvilTerran> ?type id :: yhjulwwiefzojcbxybbruweejw -> yhjulwwiefzojcbxybbruweejw
17:34:40 <lambdabot> forall yhjulwwiefzojcbxybbruweejw. yhjulwwiefzojcbxybbruweejw -> yhjulwwiefzojcbxybbruweejw
17:34:50 <EvilTerran> type variables can be anything you like :)
17:34:56 <litb> Toxaris: ah, thanks
17:35:11 <litb> i see
17:35:18 <paczesiowa> ?type id :: A -> A
17:35:19 <lambdabot> Not in scope: type constructor or class `A'
17:35:19 <lambdabot> Not in scope: type constructor or class `A'
17:35:22 <EvilTerran> (as long as they start with a lowercase letter (or a punctuation character other than (:), given ghc extensions)
17:35:23 <paczesiowa> ?type id :: aA -> aA
17:35:24 <lambdabot> forall aA. aA -> aA
17:35:41 <EvilTerran> ?type id :: ($#!+) -> ($#!+)
17:35:41 <lambdabot> forall $#!+. $#!+ -> $#!+
17:35:46 <paczesiowa> ?type id :: ....1.... -> ....1....
17:35:47 <lambdabot> parse error on input `....'
17:35:47 <EvilTerran> ooh, that's broken
17:35:56 <glguy> What happens if I kick chanserv from the channel? are their repercussions?
17:36:05 <paczesiowa> ?type id :: (....1....) -> (....1....)
17:36:06 <lambdabot> parse error on input `1'
17:36:13 <litb> glguy: do you have op?
17:36:24 <glguy> I would if I decided to kick
17:36:29 <glguy> just curious
17:36:34 <litb> i see :)
17:36:56 <faxathisia> It just denies that you tried to
17:37:07 <faxathisia> Nothing happens
17:37:09 <litb> maybe it goes wild then
17:37:17 <Tac-Tics> ah, the correct answer was to do "tell [x]" instead of "tell x"
17:37:37 <Tac-Tics> and add the type signature on top of that
17:37:50 <faxathisia> Am I right that would make type inference undecideable?
17:38:02 <glguy> Tac-Tics: that's only the correct answer if the question "how do  Imake the Monoid instance a list"
17:38:04 <ddarius> faxathisia: I forget what exactly the problem is.
17:38:45 <faxathisia> If lambda binding was polymorphic, like let
17:38:49 <Toxaris> Tac-Tics: you could use a (Num a, Monoid a) => a  as type for the numbers.
17:39:02 <ddarius> faxathisia: I mean I forget what the problem with it is, just that there is one.
17:40:11 <Tac-Tics> glguy: It's also the correct answer for "how can I get my code to typecheck without puling out my hair" ;-)
17:40:16 <faxathisia> I was thinking.. You'd maybe have to do higher order unification?
17:40:47 <Toxaris> why is there no instance Num a => Num (Sum a)?
17:42:58 <EvilTerran> good question. Product, too.
17:44:29 <faxathisia> Haskell isn't really System-F_omega is it?
17:45:20 <Philippa> no, but GHC haskell is a large fragment of it by now
17:45:37 <Philippa> all of System F plus the things it can do with type constructors
17:46:39 <Philippa> faxathisia: it'd probably be undecidable without let, yeah. You'd never know when it's safe to generalise
17:46:49 <Philippa> and that's just for basic hindley-milner inference
17:47:04 <faxathisia> I see
17:47:40 <ddarius> If you try to generalize all lambda bound terms you quickly get higher-rank types.
17:50:33 <duaneb> gah
17:50:45 <duaneb> CURSE haskell's damn type system
17:50:51 <Valodim> ?
17:51:00 <Valodim> if it's too strong, you're too weak
17:51:10 <duaneb> I don't have time to track down float/int problems
17:51:21 <Cale> duaneb: What's the problem? Perhaps I can help.
17:51:27 <EvilTerran> i never have to; i'm gonna have to side with Valodim, here
17:51:30 <faxathisia> Valodim, lol
17:51:35 <duaneb> Cale: not a problem per se, just an annoyance
17:51:45 <ddarius> duaneb: You'd rather do it later by trying to figure out why your result is 0.2 off what it should be?
17:51:54 <Cale> duaneb: Float/Integer conversions are a big source of bugs.
17:52:15 <faxathisia> duaneb: Why not hpaste your code?
17:52:21 <duaneb> Cale: not if you program well
17:52:24 <Cale> You really only need to know a few functions to handle most of them in Haskell.
17:52:28 <duaneb> !paste
17:52:29 <hpaste> Haskell paste bin: http://hpaste.org/
17:52:32 <Cale> fromIntegral
17:52:41 <Valodim> duaneb: yeah if you code well, ideally your code has no bugs :P
17:52:43 <duaneb> Cale: the trick is finding out where to use it
17:52:44 <Cale> goes from any Integral type to any numeric type at all
17:53:04 <Cale> realToFrac  -- this converts between various fractional types
17:53:25 <Cale> and then  floor/ceiling/round
17:53:32 <EvilTerran> duaneb, the problem with implicit conversions is that they have a tendency to happen where you don't expect 'em
17:53:39 <ddarius> duaneb: byorgey wanted to "solve" this "problem" to.  You can read about his saga here: http://www.haskell.org/pipermail/haskell-cafe/2007-June/027092.html
17:53:41 <lambdabot> Title: [Haskell-cafe] Perl-style numeric type, http://tinyurl.com/ytoxkb
17:53:55 <duaneb> I'd rather not feel foolish
17:53:59 <EvilTerran> and they may not be the *right* conversion; as Cale mentions, there's more than one in some places
17:54:05 <EvilTerran> er, s/places/cases/
17:54:20 <duaneb> I understand the pros of said type system, but tracking down where to convert the types is a problem
17:54:29 <duaneb> ghc has EVIL error messages
17:54:34 <Cale> duaneb: Usually in a where clause is a good bet :)
17:54:39 <faxathisia> It's not a problem
17:54:40 <Cale> a' = fromIntegral a
17:54:44 <Cale> and so on
17:55:52 <Cale> You need to convert integral types prior to applying fractional division (/), sqrt, trig functions, log or exp, etc.
17:56:10 <Philippa> duaneb: you'll find a little practice goes a long way. Trace back where the relevant constraints came from
17:56:23 <Philippa> this is the sort of thing an IDE could be helpful for though
17:56:34 <Cale> If you want integer division, that's `div`
17:56:40 <duaneb> Philippa: yea, I'm very new to haskell
17:56:42 <Cale> > 5 `div` 3
17:56:44 <lambdabot>  1
17:56:49 <Cale> > 5 `mod` 3
17:56:49 <lambdabot>  2
17:57:00 <Philippa> the other worthwhile habit is compiling often so that you've only got a small amount of code that could be responsible for new errors at any given time
17:57:14 <Philippa> type errors have a habit of accumulating too
17:57:30 <Cale> Thankfully, if GHC reports an error, it's usually a real issue.
17:57:59 <ddarius> Provide explicit type signatures.  That makes a massive difference in the quality of type errors and in localizing them.
17:58:08 <Cale> (and not just internal confusion caused after the first error)
17:58:11 <scook0> if you rely too much on type inference, the reported error site can sometimes be quite far from the actual problem
17:58:41 <Cale> If an error is confusing, make sure to note the line number before anything else.
17:59:27 <ddarius> A general theme of Haskell is: the more information you can provide the compiler, the more it can help you.
17:59:29 <Cale> (sometimes just going to that location in the code and staring at it for a bit will help make sense of why GHC is complaining)
17:59:45 <EvilTerran> if i get an inexplicable type error, i generally start adding type sigs to things
18:00:11 <Philippa> yep. You can go a long way just by taking a binary cut approach to that
18:00:17 <Tac-Tics> commenting out functions sometimes helps as well, if it's not too much of a pain
18:00:48 <Tac-Tics> and using "undefined" to fill in parts you're not quite sure how to type, since undefined :: forall a. a
18:01:43 <hpaste>  duaneb pasted "Wiretap" at http://hpaste.org/5100
18:01:58 <duaneb> btw, that is the program I'm working on
18:02:31 <duaneb> anyway, that timeName is a mess
18:02:37 <duaneb> how would y'all clean it up?
18:03:14 <Tac-Tics> foldl (+) 0 is sum
18:03:27 <Valodim> ...what does it do?
18:03:35 <Valodim> (the timeName function, not sum)
18:03:44 <Tac-Tics> breaking up with a where clause would be useful
18:04:41 <faxathisia> if elem char "AOEUI"
18:04:43 <Valodim> filter \x -> x?
18:05:06 <duaneb> Valodim: what's wrong with that? :P
18:05:07 <Valodim> ?src id
18:05:07 <lambdabot> id x = x
18:05:16 <faxathisia> @pl filter \x -> x
18:05:17 <lambdabot> (line 1, column 8):
18:05:17 <lambdabot> unexpected "\\"
18:05:17 <lambdabot> expecting variable, "(", operator or end of input
18:05:23 <faxathisia> @pl filter (\x -> x)
18:05:23 <lambdabot> filter id
18:05:28 <Valodim> :)
18:05:46 <duaneb> > id False
18:05:48 <lambdabot>  False
18:05:52 <duaneb> > id True
18:05:53 <lambdabot>  True
18:05:56 <duaneb> nifty
18:05:57 <ddarius> duaneb: You can write 'zip [1..] victims', zip will automatically stop at the shorter list.
18:06:04 <duaneb> ddarius: thanks
18:06:08 <Valodim> manual smartcheck of id?
18:06:12 <Valodim> sweet
18:06:30 <sioraiocht> > zip [1..] [1..10]
18:06:30 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
18:07:23 <Cale> > zip [0..] "hello"
18:07:24 <lambdabot>  [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
18:07:27 <faxathisia> > if elem 'a' "AOEUI" then 1 else 0
18:07:27 <lambdabot>  0
18:08:05 <ddarius> length (filter id ...) could be reduced to a fold, and even with your current code, fromIntegral (length ...) can be replaced with just genericLength
18:08:08 <duaneb> > let timeChar num char = 1.0 + if elem char "AEOUI" then if even num then 1.5 else 0.0 else if odd num then 1.0 else 0.0 in timeChar 2 'f'
18:08:08 <lambdabot>  1.0
18:08:26 <duaneb> gotta go
18:08:27 <duaneb> thanks all
18:08:57 <Cale> > sum [2 | (x,y) <- zip (primeFactors (length str) (primeFactors n)), x == y]
18:08:57 <lambdabot>   Not in scope: `n'
18:09:06 <Valodim> ?pl (\c -> timeChar n c)
18:09:06 <lambdabot> timeChar n
18:09:08 <Cale> er, I didn't mean to type > :)
18:09:22 <Cale> But that expression will replace (2.0 * (fromIntegral (length (filter (\x -> x) (zipWith (==) (primeFactors (length str)) (primeFactors n))))))
18:09:58 <Cale> You won't even need a fromIntegral :)
18:10:15 <faxathisia> Cale, I should say.. The last language he used is Scheme
18:10:17 <ddarius> Cale: You're missing a ) I suspect
18:10:27 <Cale> er, yes
18:10:35 <Cale> well, one is out of place
18:10:40 <Tac-Tics> Yeah, that example had a few too many parens for Haskell
18:10:43 <Cale> sum [2 | (x,y) <- zip (primeFactors (length str)) (primeFactors n), x == y]
18:11:25 <Cale> That's kind of a strange operation though...
18:11:33 <Cale> Is it really what you wanted to write?
18:11:40 <ddarius> He's gone.
18:11:42 <Cale> oh
18:11:50 <monochrom> strange people ask strange questions.
18:12:05 <EvilTerran> (2*) . genericLength . filter id . zipWith (==) (primeFactors $ length str) . primeFactors $ n
18:12:09 <BMeph> So, what is the point of that "filter (\x -> x)" part? And why not just double the length of the zipped lists instead? ;)
18:12:27 <Cale> BMeph: filter id will kill off all the False elements of the list
18:12:41 <Cale> > filter id [True, False, True, False, False]
18:12:42 <lambdabot>  [True,True]
18:12:47 <Cale> Then they can be counted.
18:13:02 <Cale> > sum . map fromEnum $ [True, False, True, False, False]
18:13:03 <EvilTerran> it seems to me that there'd be use in having a count :: (a -> Bool) -> [a] -> Int
18:13:04 <lambdabot>  2
18:13:16 <ddarius> Yeah, I guess length . filter is the shortest way of implementing count
18:13:19 <Cale> > length . filter id $ [True, False, True, False, False]
18:13:20 <lambdabot>  2
18:13:30 <BMeph> Cale: Ah - that's actually clever.
18:13:34 <ddarius> EvilTerran: I've rarely (never?) wanted it.
18:13:38 <EvilTerran> as it could possibly be implemented more efficiently than length.:filter
18:13:47 <EvilTerran> ddarius, oh right; i've wanted it a few times
18:13:48 <Cale> > sum [1 | x <- [True, False, True, False, False], x]
18:13:49 <lambdabot>  2
18:14:14 <Tac-Tics> > sum [1 | True <- [True, False, True, False, False]]
18:14:14 <lambdabot>  2
18:14:25 <BMeph> EvilTerran: Isn't that example for count mentioned on the wiki, under "Things to avoid"? ;)
18:14:36 <Cale> Interestingly, those are the exact same length :)
18:14:41 <EvilTerran> hm?
18:14:57 <Cale> (my last line, and Tac-Tics')
18:14:59 * EvilTerran likes the latter
18:15:17 <Cale> Yeah, it's nice :)
18:15:41 <EvilTerran> > foldr ((+).fromEnum) 0 [True, False, True, False, False]
18:15:42 <lambdabot>  2
18:15:55 <ddarius> BMeph: length is something to avoid in most circumstances.
18:16:32 <ddarius> BMeph: Luckily, avoiding length is a benefit both performance-wise and, usually, elegance-wise too.
18:16:35 <BMeph> ddarius: Well, it is if you're not really using it.
18:16:39 <faxathisia> @botsnack
18:16:39 <lambdabot> :)
18:16:44 <EvilTerran> > foldr (bool succ id) 0 [True, False, True, False, False]
18:16:45 <lambdabot>   Not in scope: `bool'
18:17:07 <EvilTerran> @let bool t f True = t; bool t f False = f
18:17:09 <lambdabot> Defined.
18:17:12 <EvilTerran> > foldr (bool succ id) 0 [True, False, True, False, False]
18:17:12 <lambdabot>  2
18:17:14 <Tac-Tics> > sum . (map fromEnum) $ [True, False, True, False, False]
18:17:15 <lambdabot>  2
18:17:29 <Cale> That bool is kind of backwards, isn't it?
18:17:43 <Cale> Then again, so is foldr.
18:17:45 <EvilTerran> what, the t and f parameters? or the Bool one?
18:17:52 <Tac-Tics> > do x <- [True, False, True, False, False]; return $ fromEnum x
18:17:52 <ddarius> Cale: and maybe and either ...
18:17:52 <Cale> The t and f parameters.
18:17:52 <lambdabot>  [1,0,1,0,0]
18:17:59 <EvilTerran> I wrote it as in if/then/else
18:18:00 <Tac-Tics> d'oh, missed the sum
18:18:08 <Cale> I don't think either is
18:18:09 <EvilTerran> rather than as in the data decl
18:18:10 <Cale> :t either
18:18:12 <EvilTerran> @src Either
18:18:16 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:18:16 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
18:18:18 <monochrom> Hard to say what is forward.
18:18:19 <ddarius> Cale: I thought you were referring to something else.
18:18:26 <Cale> er...
18:18:29 <faxathisia> @let count p = length . filter p
18:18:30 <lambdabot> Defined.
18:18:40 <Cale> wow
18:18:46 <EvilTerran> ?
18:18:49 <Cale> It didn't find the source of a Prelude function.
18:18:56 <Cale> er
18:18:57 <faxathisia> > count (==True) [True, False, True, False, False]
18:18:57 <lambdabot>  2
18:19:01 <EvilTerran> well, a Prelude type
18:19:04 <Tac-Tics> count [True, False, True, False, False]
18:19:04 <Cale> oh
18:19:09 <Cale> I misread things
18:19:12 <Cale> never mind :)
18:19:26 <Cale> I asked for the type anyway :)
18:19:28 <BMeph> ?src maybe
18:19:28 <lambdabot> maybe n _ Nothing  = n
18:19:28 <lambdabot> maybe _ f (Just x) = f x
18:19:41 <BMeph> ?src bool
18:19:41 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:19:54 <BMeph> ?src either
18:19:55 <lambdabot> either f _ (Left x)     =  f x
18:19:55 <lambdabot> either _ g (Right y)    =  g y
18:20:08 <Cale> Yeah, maybe takes things in constructor-order too.
18:20:19 <Cale> > Left 0 < Right 0
18:20:19 <lambdabot>  True
18:20:29 <ddarius> At any rate, while foldr's debatable, I think EvilTerran's bool definition is by far the right way to go
18:20:32 <Cale> > Nothing < Just undefined
18:20:33 <lambdabot>  True
18:21:05 <Cale> Yeah, with foldr, I think it's just the pressure of wanting to be able to partially apply the thing.
18:21:12 <pastorn> @src undefined
18:21:12 <lambdabot> undefined =  error "Prelude.undefined"
18:21:16 <ddarius> Cale: Which is a good enough reason.
18:21:18 <Cale> With bool though, I'm not sure.
18:21:20 <pastorn> @type error
18:21:20 <lambdabot> forall a. [Char] -> a
18:21:28 <pastorn> @src error
18:21:28 <lambdabot> error s = throw (ErrorCall s)
18:21:36 <pastorn> @src throw
18:21:36 <lambdabot> throw exception = raise# exception
18:21:39 <EvilTerran> as i said, i figure following then/else order is more mnemonic than constructor order
18:21:44 <pastorn> this never ends...
18:21:56 <Cale> pastorn: hehe
18:21:58 <pastorn> @src raise
18:21:58 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
18:22:01 <pastorn> @src raise#
18:22:01 <lambdabot> Source not found. Are you on drugs?
18:22:06 <pastorn> @type raise#
18:22:06 <lambdabot> Not in scope: `raise#'
18:22:08 <pastorn> @type raise
18:22:09 <lambdabot> Not in scope: `raise'
18:22:10 <ddarius> raise# is a GHC primitive
18:22:11 <Cale> It's internal.
18:22:14 <pastorn> oh
18:22:24 <ddarius> The source of @src is ecclectic.
18:22:34 <Cale> Prelude GHC.Exts> :info raise#
18:22:34 <Cale> raise# :: forall a b. a -> b    -- Defined in GHC.Prim
18:22:39 <EvilTerran> ... like an eccles cake?
18:22:50 <paczesiowa> :t take
18:22:51 <lambdabot> forall a. Int -> [a] -> [a]
18:22:54 <monochrom> If raise# gives you "raise# _ = undefined", that will truely be endless. :)
18:22:57 <BMeph> ddarius: Yeah, the worst thing about it, is how it's sometimes useful... ;p
18:22:59 <Cale> :t eccles cake
18:23:00 <lambdabot> Not in scope: `eccles'
18:23:00 <lambdabot> Not in scope: `cake'
18:23:21 <EvilTerran> > cake :: Lie
18:23:22 <lambdabot>   Not in scope: type constructor or class `Lie'
18:23:34 <Cale> Lie algebra?
18:23:44 <Tac-Tics> :t (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.)
18:23:45 <lambdabot> forall a a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16 b c a17. (b -> c) -> (a -> a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> a10 -> a11 -> a12 -> a13 -> a14 -> a15 -> a16 -> a17 -
18:23:45 <lambdabot> > b) -> a -> a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> a10 -> a11 -> a12 -> a13 -> a14 -> a15 -> a16 -> a17 -> c
18:23:46 <EvilTerran> the cake is a lie algebra?
18:23:53 <glguy> EvilTerran: we do whatwe must because we can
18:23:54 <pastorn> Cale: have you studied that?
18:24:02 <Tac-Tics> lambdabot doesn't clip output on types, it seems
18:24:04 <Cale> pastorn: Lie algebras? A little.
18:24:22 <pastorn> i'm taking a course in modern algebra/algebraic structures
18:24:24 * EvilTerran wonders if this presents a potential DoS issue
18:24:32 <pastorn> do you think i will come across it?
18:24:33 <ddarius> It will if the output is long enough.
18:24:42 <Cale> pastorn: Probably not in a first course.
18:24:51 <Cale> pastorn: But you never know...
18:25:12 <pastorn> Cale: good, cause it appears to be really difficult
18:25:13 <ddarius> My experience has been that Lie algebras are "less interesting" to an abstract algebraist.
18:25:40 <pastorn> or at least that's what i've heard
18:25:49 <Cale> They don't have as nice structure as many other things, but are tied in with some very fundamental stuff.
18:25:58 <faxathisia> It's not a problem, You have to do @more
18:26:03 <ddarius> They come up in differential geometry.
18:26:08 <faxathisia> if the type is that larde
18:27:03 <faxathisia> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
18:27:05 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
18:27:05 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102 t103 t104 t105 t106 t107 t108 t109
18:27:05 <lambdabot> t110 t111 t112 t113 t114 t115 t116 t117 t118 t119 t120 t121 t122 t123 t124 t125 t126 t127 t128 t129 t130 t131 t132 t133 t134 t135 t136 t137 t138 t139 t140 t141 t142 t143 t144 t145 t146 t147 t148
18:27:05 <lambdabot> t149 t150 t151 t152 t153 t154 t155 t156 t157 t158 t159 t160 t161 t162 t163 t164 t165 t166 t167 t168 t169 t170 t171. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q ->
18:27:07 <lambdabot> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 ->
18:27:10 <lambdabot> [10 @more lines]
18:27:19 <pastorn> wtf?
18:27:22 <EvilTerran> impressive
18:27:33 <faxathisia> So it's not a DoS issue
18:27:34 <byorgey> hehe, nice
18:27:41 <byorgey> @more
18:27:41 <lambdabot> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> t70 -> t71 -> t72 -> t73 -> t74 -> t75 -> t76 -> t77 ->
18:27:41 <lambdabot> t78 -> t79 -> t80 -> t81 -> t82 -> t83 -> t84 -> t85 -> t86 -> t87 -> t88 -> t89 -> t90 -> t91 -> t92 -> t93 -> t94 -> t95 -> t96 -> t97 -> t98 -> t99 -> t100 -> t101 -> t102 -> t103 -> t104 -> t105
18:27:41 <lambdabot> -> t106 -> t107 -> t108 -> t109 -> t110 -> t111 -> t112 -> t113 -> t114 -> t115 -> t116 -> t117 -> t118 -> t119 -> t120 -> t121 -> t122 -> t123 -> t124 -> t125 -> t126 -> t127 -> t128 -> t129 ->
18:27:41 <lambdabot> t130 -> t131 -> t132 -> t133 -> t134 -> t135 -> t136 -> t137 -> t138 -> t139 -> t140 -> t141 -> t142 -> t143 -> t144 -> t145 -> t146 -> t147 -> t148 -> t149 -> t150 -> t151 -> t152 -> t153 -> t154 ->
18:27:42 <ddarius> If you know a little bit of category theory, then Lie groups are just groups in a category of manifolds.  From there Lie algebras are a functor away.
18:27:44 <lambdabot>  t155 -> t156 -> t157 -> t158 -> t159 -> t160 -> t161 -> t162 -> t163 -> t164 -> t165 -> t166 -> t167 -> t168 -> t169 -> t170 -> t171 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t,
18:27:47 <lambdabot> [5 @more lines]
18:27:50 * EvilTerran was trying to think of some class of expressions with O(n^2) types
18:27:52 <Cale> I like how the syntax is screwed up
18:27:58 <monochrom> Why does it start from t28 not t27? :)
18:28:04 <Cale> "... t169 t170 t171. -> b -> c -> ..."
18:28:05 * Tac-Tics wonders if mathematics has studied any algebraic structures for which it has not actually found a concrete example of that structure
18:28:38 <faxathisia> > let a = (b,b) ; b = (c,c) ; c = (,) in a
18:28:39 <lambdabot>  Add a type signature
18:28:42 <monochrom> There is a joke about not have a concrete example.
18:28:43 <Cale> Tac-Tics: Well, sets :)
18:28:50 <faxathisia> gr
18:28:51 <monochrom> Hahahaha :)
18:28:51 <byorgey> Tac-Tics: it... kind of depends what you mean by "concrete example" =)
18:29:11 <EvilTerran> you can find examples of most things in other branches of abstract maths :D
18:29:54 <Cale> I wonder how long it was before a concrete implementation of the axioms for the reals was found. I should really learn a bit more about the history there.
18:30:04 <ddarius> EvilTerran: There are expressions with O(2^n) types.
18:30:29 <EvilTerran> ddarius, i figured; doesn't mean i could think of one, tho
18:30:32 <byorgey> ddarius: awesome.  like what?
18:30:40 <Tac-Tics> Good point. I guess I mean an algebraic structure for which no example is known where the elements are basic mathematical entities (where those base entities might include something like sets, integers, and functions)
18:30:43 <EvilTerran> oh, wait, 2^n? that's cool
18:30:43 <nbarterd> is there some class that is kind of like Num, but less powerful?
18:30:53 <nbarterd> I think I just need addition.
18:30:56 <Cale> :t let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x) in f3
18:30:57 <lambdabot> forall t. -> ((((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t,
18:30:57 <lambdabot>  t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t,
18:31:00 <lambdabot> t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t,
18:31:02 <monochrom> Monoid :)
18:31:03 <lambdabot> t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))), (((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t,
18:31:06 <lambdabot>  t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), (
18:31:08 <EvilTerran> whoa
18:31:09 <lambdabot> (t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t,
18:31:11 <faxathisia> Wheeee!
18:31:11 <EvilTerran> trippy
18:31:12 <lambdabot>  t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))))
18:31:12 <nbarterd> something like "vector" in the prelude or out on hackage or...
18:31:19 <ddarius> nbarterd: No, but that's a common request.
18:31:32 <dons> yeah yeah, H-M is fun.
18:31:43 <glguy> dons: switched OSs yet?
18:31:52 <ddarius> It's a known problem with the way the numeric hierarchy is setup.  That said, you can completely hide the Prelude versions and make your own.
18:31:56 <idnar> yikes
18:32:09 <glguy> dons: Has Trevor mentioned any issues with GHC 6.8.2 on ArchLinux?
18:32:14 <dons> glguy: nope. its a good question. i need a 40G disk space to back up to first.
18:32:17 <nbarterd> hm, guess I just write a class with method myplus or something
18:32:18 <dons> glguy: nope.
18:32:25 <dons> things work well, afaik
18:32:40 <glguy> the ArchLinux maintainer was reporting problems building (linker errors)
18:32:47 <glguy> so I'm just poking around
18:32:55 <dons> i've not heard anything, xmonad/arch guys seem happy enough.
18:33:14 <ddarius> http://www.haskell.org/haskellwiki/Mathematical_prelude_discussion
18:33:16 <lambdabot> Title: Mathematical prelude discussion - HaskellWiki, http://tinyurl.com/2m3jx5
18:33:48 <hpaste>  glguy pasted "ghc build errors (linker)" at http://hpaste.org/5101
18:33:56 <glguy> ideas?
18:34:29 <dons> a partially built ghc/libraries, that got restarted?
18:35:29 <paczesiowa> :t let f x = (x,x); f1 x = f . f $ f x; f2 x = f1 . f1 $ f1 x; f3 x = f2 . f2 $ f2 x in f3
18:35:35 <lambdabot> <command line>:
18:35:35 <lambdabot>     Could not find module `L':
18:35:35 <lambdabot>       Use -v to see a list of the files searched for.
18:36:29 <faxathisia> Cale.. Interesting, I've only seen one impl. of the Real Axioms
18:37:14 <paczesiowa> after 20s of intensive typing I hit ctrl-c, and it aborted but didn't release memory, right now ghci uses over 1gb of memory, is it a bug or feature?
18:37:35 <glguy> I've had issues with ghci in 6.8
18:37:39 <glguy> ^C being ignored
18:37:47 <glguy> the history been less useful
18:37:51 <glguy> forgetting what module I was in
18:37:52 <faxathisia> It seems like a strange thing to have in a computer.. since they're mostly uncomputable
18:38:00 <glguy> "Interrupted" messages instead of results
18:38:24 <ddarius> faxathisia: You can implement some constructive approaches to the reals, but that's not the real Reals.
18:39:43 <EvilTerran> i think there will always be a class of reals that cannot be represented as a finite expression in any given notation of finite grammar
18:41:12 <faxathisia> :t let u x = (u x, u x) in u
18:41:13 <lambdabot>     Occurs check: cannot construct the infinite type: t = (t, t1)
18:41:13 <lambdabot>       Expected type: t2 -> t
18:41:13 <lambdabot>       Inferred type: t2 -> (t, t1)
18:41:27 <EvilTerran> there's probably a horrible little proof for that
18:41:31 <EvilTerran> (or big proof)
18:42:10 <EvilTerran> :t let f g x = (g f x, g f x) in f
18:42:10 <lambdabot>     Occurs check: cannot construct the infinite type:
18:42:11 <lambdabot>       t = (t -> t1 -> (t2, t3)) -> t1 -> t2
18:42:11 <lambdabot>     Probable cause: `g' is applied to too many arguments
18:42:16 <EvilTerran> eeh
18:42:26 <EvilTerran> :t let f g x = (g (f x), g (f x)) in f
18:42:26 <lambdabot>     Occurs check: cannot construct the infinite type:
18:42:26 <lambdabot>       t = (t -> (t1, t2)) -> t1
18:42:26 <lambdabot>     Probable cause: `g' is applied to too many arguments
18:42:38 * EvilTerran wtfs
18:42:46 <EvilTerran> i'm stupid. never mind.
18:43:05 <ddarius> EvilTerran: There are uncountably many reals, there are at most countably many symbol strings.
18:43:19 <Cale> EvilTerran: Uh, how many grammars are there?
18:43:22 <Cale> :)
18:43:24 <EvilTerran> ddarius, okay then; elegant little proof :)
18:43:36 <EvilTerran> Cale, er, countably many?
18:43:40 <Cale> right :)
18:43:48 <EvilTerran> well, finite grammars
18:43:52 <Cale> (ddarius beat me to the punch :)
18:44:10 <EvilTerran> :t join (&&&)
18:44:10 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
18:44:31 <EvilTerran> :t join (.)
18:44:32 <lambdabot> forall b. (b -> b) -> b -> b
18:44:41 <EvilTerran> hm.
18:45:00 <Cale> In fact, the same sort of argument can be used to show that there are more real numbers than there are definitions of real numbers (that is, proofs of existence and uniqueness of a real number satisfying a given condition)
18:45:18 <EvilTerran> the set of proofs is countable?
18:45:22 <Cale> right
18:45:26 <EvilTerran> (indeed, the set of definitions of reals, likewise)
18:45:36 <ddarius> EvilTerran: They're symbol strings too.
18:45:46 <EvilTerran> that's quite a snazzy method of proof
18:46:09 <faxathisia> :t ?a :: (a -> (a -> ((a -> a) -> a))))
18:46:09 <lambdabot> parse error on input `)'
18:46:15 <faxathisia> :t ?a :: (a -> (a -> ((a -> a) -> a)))
18:46:16 <lambdabot>     No instance for (?a::a -> a -> (a -> a) -> a)
18:46:16 <lambdabot>       arising from use of implicit parameter `?a' at <interactive>:1:0-1
18:46:16 <lambdabot>     Possible fix:
18:46:18 <Cale> It's also the easiest way to show that there are transcendental numbers.
18:46:26 <faxathisia> aw....
18:46:46 <Cale> (that is, real numbers which are not the roots of any polynomial with rational coefficients)
18:47:45 <dons> dcoutts: what's the best way to get regex-base-0.93.1 and regex-posix-0.93.1 onto a gentoo system?
18:48:04 <dons> that's the last breakage, the regex-dna entry depends on those two, which aren't in the ghc default set.
18:48:58 <dons> fancy, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fec-0.1 , `Forward error correction of ByteStrings'
18:48:59 <lambdabot> http://tinyurl.com/298j58
18:49:56 <faxathisia> :t (\x y f -> const x (y==f x)) :: (Eq a) => (a -> (a -> ((a -> a) -> a)))
18:49:57 <lambdabot> forall a. (Eq a) => a -> a -> (a -> a) -> a
18:50:20 <paczesiowa> why haskell's random number generation is slower than C's ?
18:50:46 <faxathisia> See in this, What do you think is a good way to print something without paranthesis?
18:50:46 <Botje> because haskell is not C :)
18:50:59 <dons> paczesiowa: its a short, clean example random generator.
18:51:12 <dons> paczesiowa: i'm working on one that is much faster than C's default (its a mersenne twister C binding)
18:51:25 <dons> what do you need randoms for?, perhaps you'd like to try the experimental lib?
18:52:09 <ddarius> EvilTerran: The Lowenheim-Skolem theorem is interesting in that regard.
18:52:12 <dons> paczesiowa: summary, System.Random is slower because the algorithm is slower, and its also unecessarily inefficient. this is being fixed.
18:52:15 <paczesiowa> generating argv!!0 lines of random length (< argv!!1) of characters 'a'..'z'
18:52:28 <dons> lines of random length, how large?
18:52:39 <dons> can you hpaste the program?
18:52:47 <dons> i'd like to try it with my randoms lib. see if its a lot faster.
18:53:28 <paczesiowa> I'll just translate var names and hpaste it
18:53:31 <ddarius> dons: Any shootout programs use random numbers?
18:53:39 <dons> ddarius: yes, but they define the generator
18:53:43 <monochrom> I like meaningless var names.
18:53:47 <dons> paczesiowa: cheers
18:54:49 <monochrom> I like meaningless var names. They make sure I read the author's program rather than the author's wish. You know there is a difference - not all wishes come true. :)
18:55:03 <dons> heh
18:55:28 <ddarius> let primes = [1..] in myFastFactorer
18:55:43 <hpaste>  Paczesiowa pasted "Print random number of random lines" at http://hpaste.org/5102
18:55:50 * monochrom recalls someone's fibonacci homework where the code does factorial.
18:57:05 <faxathisia> Has anyone written a reversible parser generator/combinator?)
18:57:27 <ddarius> Probably.
18:57:32 <monochrom> You using the same generator for two sequences?
18:57:50 <monochrom> Methinks you should at least split...
18:58:02 <faxathisia> Where?
18:58:02 <paczesiowa> dons I usually tested it with ./test 1000000 100 (on of those "I hate your c#/c/python so I'll write it in haskell and ask dons to tweak it so I can prove that I'm better than you) :P
18:58:15 <monochrom> (The quality of split is not known, either)
18:58:15 <dons> did you check its actually the randoms that are the problem?
18:58:52 <monochrom> Anyway, I guess it's beside the point of speed.
18:59:02 <dons> paczesiowa: what input numbers did you use ?
18:59:17 <faxathisia> sorry, I mean a haskell one
18:59:27 <paczesiowa> yes, generating with randomRs, taking 10 millions charachers >>= print is still so much slowe than c
18:59:34 <paczesiowa> dons: I usually tested it with ./test 1000000 100 (on of those "I hate your c#/c/python so I'll write it in haskell and ask dons to tweak it so I can prove that I'm better than you) :P
19:00:07 <dons> ah ok. :)
19:00:17 <dons> we can solve the number generatoin problem.
19:12:41 <dons> paczesiowa: i'm working on it, btw.
19:13:57 <_frederik_> hello, i have code that uses Distribution.Package, has it moved to a different package?
19:14:09 <zeno> @src fmap
19:14:09 <lambdabot> Source not found. I am sorry.
19:14:09 <_frederik_> libghc6-cabal-dev: Depends: ghc6 (< 6.4.2) but 6.8.2-1 is to be installed
19:15:13 <allbery_b> fmap is a class function
19:15:23 <allbery_b> @src (->) fmap
19:15:23 <lambdabot> fmap = (.)
19:15:29 <allbery_b> @src [] fmap
19:15:29 <lambdabot> fmap = map
19:16:06 <hpaste>  Paczesiowa pasted "haskell's vs c's random" at http://hpaste.org/5103
19:17:23 <paczesiowa> dons: I think this is testing just random implementation, right?
19:17:55 <dons> yeah, but we know the result :) and we've code already that's equiv to C.
19:18:44 <dons> $ time ./number-fast 1000000 100 > /dev/null
19:18:44 <dons> ./number-fast 1000000 100 > /dev/null  0.63s user 0.04s system 96% cpu 0.692 total
19:19:01 <dons> 1000000 random ints between 1 .. 100, in 0.6s ? is that ok?
19:19:18 <dons> yeah, that should be C's rand().
19:19:28 <faxathisia> Anyone know a nice language you can describe relations between text and structural data with, as well as derive a showsPrec and parser for?
19:19:52 <gnuvince_> @hoogle (%)
19:19:53 <lambdabot> Did you mean: (%)
19:19:53 <lambdabot> Prelude.undefined :: a
19:19:53 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
19:19:57 <monochrom> XML? :)
19:20:10 <byorgey> gnuvince_: that's in Data.Ratio
19:20:22 <paczesiowa> dons: I don't know, I was just curious, I don't really need that code
19:20:23 <byorgey> gnuvince_: it's for constructing a Ratio value.
19:20:27 <byorgey> > 3 % 5
19:20:29 <lambdabot>  3%5
19:20:36 <byorgey> > 3%5 + 2%7
19:20:36 <lambdabot>  31%35
19:20:36 <hpaste>  dons annotated "haskell's vs c's random" with "its the algorithm, not the language" at http://hpaste.org/5103#a1
19:20:52 <dons> paczesiowa: ^ that's the same thing, but using the mersenne-random package
19:21:26 <hpaste>  dons annotated "haskell's vs c's random" with "time" at http://hpaste.org/5103#a2
19:21:51 <dons> paczesiowa: so now we can use that to generate random-packed bytestrings, or strings,
19:23:06 <byorgey> dons: any particular reason you used a recursive function 'go', rather than some sort of mapM_ ?  is it for efficiency?
19:23:30 <dons> habit
19:23:43 <byorgey> heh, ok =)
19:24:14 <paczesiowa> dons: can I download that library?
19:24:29 <dons> paczesiowa: yep. sure. code.haskell.org/~dons/code/mersenne-random
19:24:39 <paczesiowa> dons: thx
19:24:51 <dons> if you're not using a cpu supporting sse2, you'll need to comment that out of the .cabal file
19:24:59 <dons> (and the code will be a little slower)
19:26:02 <paczesiowa> so I'll have to test that code (versus c# version) on sse2 machine:D
19:27:16 <dons> well, it goes a little slower without sse2, but not too bad
19:27:22 <dons> (i.e. 2x)
19:27:28 <byorgey> replicateM_ numLines (print =<< mod <$> mersenneNext <*> pure maxChars)
19:27:48 <byorgey> something like that =)
19:28:21 <dons> :)
19:29:04 <_frederik_> when i compile some old code, it says "Cannot match a monotype with `forall t. ..."
19:29:22 <_frederik_> does anyone know what this entails?
19:29:37 <dons> paczesiowa: my first go at doing the full problem, 5.098s, for ./number-fast 1000000 100
19:29:42 <dons> that's faster than the C one, isn't it?
19:29:50 <byorgey> :t replicateM_ 10 (print =<< mod <$> return 200 <*> pure 10)
19:29:53 <lambdabot>     Ambiguous occurrence `pure'
19:29:53 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
19:29:53 <lambdabot>                           or `pure', imported from Control.Arrow
19:29:58 <byorgey> :t replicateM_ 10 (print =<< mod <$> return 200 <*> return 10)
19:29:59 <lambdabot> IO ()
19:30:21 <hpaste>  Chad pasted "Calling a Haskell library from C" at http://hpaste.org/5104
19:31:05 <pastorn> :t <$>
19:31:06 <lambdabot> parse error on input `<$>'
19:31:09 <Chad> This compiles easily enough using GHC, but is there a nice way to present a library like this to non-haskell c people?
19:31:13 <byorgey> pastorn: it's fmap
19:31:13 <pastorn> :t (<$>)
19:31:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:31:33 <hpaste>  dons annotated "Print random number of random lines" with "super simple version" at http://hpaste.org/5102#a1
19:31:47 <byorgey> _frederik_: maybe paste the code?
19:31:50 <pastorn> @hoogle Functor
19:31:51 <byorgey> !hpaste
19:31:51 <dons> paczesiowa: ^ we can do a lot better here though, its a good problem :)
19:31:51 <lambdabot> Prelude.Functor :: class Functor f
19:31:51 <lambdabot> Control.Monad.Functor :: class Functor f
19:31:51 <lambdabot> Control.Monad.Instances.Functor :: class Functor f
19:32:44 <dons> paczesiowa: got mersenne-random to build?
19:32:45 <ddarius> http://upload.wikimedia.org/wikipedia/commons/thumb/2/27/Lattice_wave.svg/300px-Lattice_wave.svg.png
19:32:46 <lambdabot> http://tinyurl.com/244poo
19:35:05 <ddarius> Chad: Other than having to initialize and finalize the runtime, what's the problem?
19:36:02 <Chad> problem is handing something to a C person and saying, "here, use ghc to compile this". Maybe I just don't understand the compiling/assembling/linking process well enough...
19:36:43 <dons> Chad: you'd have to do a wrapper that set up all the flags
19:36:49 <dons> you can see the flags used with ghc -v
19:36:53 <dons> (or higher )
19:37:12 <hpaste>  _frederik_ pasted "the error" at http://hpaste.org/5105
19:37:16 <Chad> Ok, so how do I tell what their machine would need to have on it?
19:37:38 <Chad> I mean, they need some ghc bits, right? But I'd like to avoid making them install all of GHC
19:38:03 <_frederik_> i think that some of this code may have had to change the last time i updated ghc as well
19:38:08 <hpaste>  dons annotated "Print random number of random lines" with "twice as fast" at http://hpaste.org/5102#a2
19:39:13 <dons> paczesiowa: ^ using rem, twice as fast. down to 2.5s for 1M lines
19:39:51 <paczesiowa> dons: first version - 8.5s versus c's 2.5s
19:39:59 <paczesiowa> dons: I'll try snd version
19:40:52 <dons> looks like it has a few bugs, wrt. the spec
19:40:55 <paczesiowa> dons: 4.7s
19:41:14 <dons> ok. now we can think a bit harder.
19:41:26 <dons> where's the C program?
19:41:57 <hpaste>  (anonymous) annotated "Print random number of random lines" with "c version" at http://hpaste.org/5102#a3
19:42:32 <hpaste>  _frederik_ annotated "the error" with "a working version" at http://hpaste.org/5105#a1
19:42:47 <paczesiowa> dons: just hpasted
19:42:55 <dons> ok. we can fill mutable buffers. but that's a bit lower level.
19:44:37 <paczesiowa> that's faster than python and c# versions, so it should be enough to impress all those "haskell is slow so I use python" guys
19:45:10 <dons> yeah.
19:45:36 <paczesiowa> btw, you're great!
19:45:46 <dons> who thinks python is faster than haskell these days, anyway?
19:46:05 <dons> paczesiowa: see the shootout, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=python  :)
19:46:06 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/2deng4
19:46:12 <aFlag> hm was haskell ever slower than python?
19:46:17 <dons> yeah, i doubt it.
19:46:30 <aFlag> python is about the slowest language I know
19:46:47 <paczesiowa> dons: you would be suprised
19:46:50 <aFlag> not that speed is that much important nowadays
19:47:09 <dons> paczesiowa: i'd just ask them to explain the shootout stats, across all those different benchmarks
19:47:18 <dpn`> dons: since when has python been faster than anything?
19:47:24 <dpn`> doh aFlag beat me
19:47:45 <dpn`> mostly speed is determined by the quality of the code with python
19:47:46 <paczesiowa> dons: they don't know what shootout is, they just "know" that haskell is slow and python is uberfast
19:48:09 <aFlag> who are those people?
19:48:14 <dpn`> paczesiowa: they are hardly real pythonistas if they think it is fast
19:48:16 <aFlag> why are their opinion relevant?
19:48:21 <dons> anyway :)
19:48:24 <dpn`> any python hacker worth his salt knows it's slow
19:48:24 <dpn`> :P
19:48:26 <dons> let's just write fast code.
19:48:39 <paczesiowa> aFlag: bad programmers!
19:48:52 <dpn`> dons: let write fun code. then profile it.
19:48:55 <dpn`> then write fast code
19:48:56 <dpn`> :)
19:49:20 <paczesiowa> aFlag: and they outnumber us (or you, I'm stupid)
19:49:58 <Chad> dons: Is the MersenneTwister library available somewhere? All I could find was a haskell implementation by Lennart Augustsson
19:50:38 <paczesiowa> darcs get http://code.haskell.org/~dons/code/mersenne-random
19:50:39 <lambdabot> Title: Index of /~dons/code/mersenne-random
19:50:51 <dons> Chad: on haskell.org, but super beta (only a couple of days old, api will change)
19:51:08 <Chad> ok cool, thanks! :)
19:57:22 <ddarius> Hey, python has ruby to make it look fast.
19:57:52 <byorgey> and ruby has befunge.
19:58:07 <ddarius> byorgey: Is befunge slower than ruby?
20:00:34 <byorgey> ddarius: I guess it depends what problem you're trying to solve =)
20:01:45 <monochrom> Every language has Turing machine to make it look fast.
20:02:31 <monochrom> Should I submit Turing machine entries to the Shootout? :)
20:02:53 <monochrom> Just to make sure no other language is left behind? :)
20:02:57 <Tac-Tics> Why not? Submit some SKI calculus entries too
20:03:20 <Chad> what about monkeys on typewriters?
20:03:36 <monochrom> That one is harder.
20:03:45 <Tac-Tics> monkeys constitute some sort of a probabilistic turing complete system no doubt
20:03:46 <Chad> yeah, expensive hardware
20:04:16 <monochrom> It's hard to turn "monkeys on typewriters" into a language...
20:04:46 <BMeph> Not to mention, they don't like to "submit" to anything... ;)
20:05:01 <sclv> well, just try it without typewriters, then you'll appreciate what you've got.
20:05:24 <Tac-Tics> I always thought it would be cool to build a turing complete system out of magic the gathering cards.
20:05:28 <paczesiowa> dons: will you instance that mersenne thingie to Random class?
20:05:31 <monochrom> They like to eat bananas. Now, if only they also liked to eat lenses, barbed wires, ...
20:05:38 <Tac-Tics> One that would remove all player-created choice functions
20:05:57 <monochrom> Aren't there only finitely many cards?
20:06:24 <BMeph> monochrom: Don't tell that to WotC. ;)
20:06:24 <sclv> well, you only need two...
20:06:26 <byorgey> monochrom: doesn't your computer have a finite amount of memory?
20:06:40 <monochrom> My computer is not Turing complete.
20:06:45 <Tac-Tics> where you'd generate an unbound amount of mana through some combo, toss it into an activated ability, and the amount of damage done through triggered abilities constitutes the output of some numeric function
20:06:55 <dons> paczesiowa: yeah, or something very like it. the current Random is quite inefficient
20:07:02 <Tac-Tics> (mana and damage are not bound, unlike memory)
20:07:06 <byorgey> monochrom: well, neither is anything actually built out of physical objects. =)
20:07:50 <monochrom> The practical criterion is "can reach many states with ease"
20:11:03 <_frederik_> http://htoolkit.sourceforge.net/
20:11:04 <lambdabot> Title: HToolkit Home
20:11:17 <_frederik_> is HSQL still at 1.7?
20:11:27 <_frederik_> the timezone stuff was completely broken, i submitted a patch a long time ago
20:11:47 <monochrom> Likely a sleeping project.
20:11:51 <INeeDHelp> i can open this page: http://flasharhive.tk/ , can some 1 helo me why ??? at Windows i can au ubuntu i cant ???
20:11:52 <lambdabot> Title: flasharhive.tk
20:12:18 <monochrom> seems like a trap or a spam or ...
20:12:27 <_frederik_> shouldn't the maintainer be seeking a replacement maintainer then?
20:12:42 <_frederik_> people will waste their time trying to use the software
20:12:46 <monochrom> perhaps no replacement shows up
20:12:55 <hpaste>  dons annotated "Print random number of random lines" with "correct, pretty version" at http://hpaste.org/5102#a4
20:13:09 <dons> paczesiowa: ^ there's a nice version, that works properly
20:13:16 <_frederik_> i don't see any solicitation for a replacement here:
20:13:17 <_frederik_> http://htoolkit.sourceforge.net/
20:13:17 <lambdabot> Title: HToolkit Home
20:13:34 <monochrom> Then we need a replacement killer. :)
20:13:39 <_frederik_> ... or any indication that there are major outstanding bugs
20:14:28 <_frederik_> and now i'm having to update their code because someone thought it would be cute to change Int to Verbosity in the cabal libs
20:15:14 <ddarius> Text.Parsec.Combinators now has Haddock documentation for most entries.
20:15:22 <monochrom> Nice!
20:16:57 <dons> paczesiowa: so a final speedup from 27.644 to 3.329s on my box, by switching random libs, seems pretty good
20:17:16 <dons> also highlights how System.Random should *never* be used when performance matters
20:17:19 <ddarius> dons: Now get those libraries into the base libs.
20:17:33 <dons> ddarius: got to work out a haskellish api first
20:17:54 <monochrom> The singletonness is still thorny.
20:18:21 <dons> yep, but that's not too hard to solve
20:18:34 <dons> the main thing will be duplicating all of System.Random's instances so they don't suck
20:18:49 <dons> so it won't be just new RandomGen instances, but a new Random class that's fast.
20:19:00 <monochrom> Ah.
20:19:13 <dons> the whole 'thread the generator manually' paradigm that System.Random has is a bit awkward
20:19:34 <dons> but i'm not sure i want to require running in a random monad. so we'll likely be threading generator state manually
20:20:44 <dons> these days lennart probably would have just done it in a Random monad, I guess.
20:20:59 <glguy> RandomT?
20:21:29 <dons> its just a StateT though. which feels heavy for this task
20:21:42 <dons> maybe you can run in the monad, or do a unsafeInterleave infinite list thing
20:21:47 <dons> whichever you prefer.
20:22:02 <dons> like Chans
20:22:32 <dons> IO-based Randoms are a bit like Chans, you can read from a randomgen, or get lots of results purely as an infinite list
20:22:45 <dons> System.Random does that but with explicit randomgens being passed
20:23:24 <dons> monochrom: so that might work. but i've got to do the uniqueness hacking first
20:25:33 <ddarius> All of Text.Parsec.Combinators is haddocked.  The greatest bang for the buck is done...
20:26:07 <dons> yay
20:26:46 <glguy> Text.Parsec.Combinators?
20:27:06 <ddarius> It's just the documentation from the Parsec reference guide, which for this module can be used more or less verbatim as I doubt the code has actually changed meaningfully in over eight years.
20:27:24 <glguy> But is that some new set of combinators?
20:27:31 <glguy> I've not heard of that namespace before
20:27:35 <ddarius> glguy: No.  It's a new parsec, same combinators.
20:27:50 <faxathisia> Does haddock do anything other than generate HTML?
20:27:55 <ddarius> Paolo seemed to want to move it out of Text.ParserCombinators, which others have wanted as well.
20:28:01 <ddarius> faxathisia: It generates Hoogle stuff too.
20:28:06 <ddarius> And indices etc.
20:28:22 <glguy> ddarius: same implementation in a new namespace then?
20:29:06 <ddarius> glguy: For that particular module, yes.  For parsec as a whole, no.  New implementation with a similar interface in a new namespace.
20:29:20 <glguy> To what end? efficiency?
20:29:32 <glguy> memory or speed performance?
20:29:44 <glguy> make use of new language extensions? :)
20:30:03 <ddarius> glguy: This is parsec as a monad transformer and with a parameterized input type allowing, in particular, bytestrings.
20:30:39 <glguy> parsec was parameterized on input type, wasn't it? (though the transformer sounds useful)
20:30:54 <glguy> GenParser tok state result
20:31:02 <ddarius> glguy: It was parameterized on "token" type, but it still used a list of tokens internally.
20:31:11 <glguy> ohh
20:31:12 <ddarius> glguy: This is parameterized on the "stream" type.
20:31:12 <glguy> I see
20:31:42 <glguy> Does the transformer include State? or is that left for the user to add with StateT?
20:32:02 <glguy> (Is there a link to the new code so I can just find out for myself?)
20:32:07 <ddarius> There is still user state carried around by Parsec, though you could now run it over a State(T) as well.
20:32:43 <ddarius> glguy: It was Paolo Martini's Summer of Code project and the source code is somewhere on that site, but I should be putting up a darcs repository of it soon.
20:32:46 <chessguy> i thought the new parsec stuff was supposed to be an SOC project?
20:33:03 <monochrom> SOC projects take a year to complete :)
20:33:05 <ddarius> chessguy: That SoC ended several months ago.
20:33:13 <chessguy> ddarius, my point exactly
20:33:28 <chessguy> oh, so it is done then?
20:33:56 <chessguy> @where soc
20:33:57 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
20:34:17 <aFlag> I wish the summer of code wasn't during the winter
20:34:25 <ddarius> chessguy: For the most part.  Or enough so that releasing it is worthwhile.  Philippa and I are making it releasable.
20:34:51 <chessguy> what happened to Paolo?
20:35:00 <paczesiowa> dons: about this version: http://hpaste.org/5102#a2 (it's faster than the last one) why does it print non-alpha characters?
20:35:05 <ddarius> chessguy: He's just busy with stuff.
20:35:16 <chessguy> oh ok
20:35:21 <chessguy> worse could happen to a guy :)
20:35:21 <ddarius> chessguy: Philippa would know more.
20:35:50 <ddarius> Philippa was his "mentor" for the SoC.
20:35:55 <chessguy> aha
20:36:05 <dons> paczesiowa: because its wrong :)
20:36:23 <ddarius> dons: Always a good reason
20:36:25 <chessguy> dons, that's a good reason for it to not work :)
20:36:32 <dons> paczesiowa: its using Ints and `rem` then char gives more 0s
20:36:35 <Tac-Tics> How does GHC get by with using #'s in variable and type identifiers? You can't use Int# in your haskell source, can you?
20:36:47 <dons> Tac-Tics: you can.
20:37:00 <dons> its a ghc extension for literals of unboxed kind (and other things)
20:37:13 <ddarius> Tac-Tics: GHC is the implementation.  It can do whatever it likes.
20:37:16 <Tac-Tics> so you probably need a flag to turn it on, I'm guessing?
20:38:09 <dons> yep. -fglasgow-exts is one flag, i think there's a specific flag for it now too
20:38:18 <dons> btw, guys, the shootout is mostly updated now.
20:38:26 <paczesiowa> dons: why more zeroes? and why does it print chars like '^' or '['
20:38:27 <dons> regex-dna still isn't, but everything else is.
20:38:50 <dons> paczesiowa: its using Int, so produces bogus values when modding/rand things due to overflow
20:39:22 <dons> you can either take the 'abs' or convert the random Int to a Word
20:39:36 <glguy> @shootout
20:39:36 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
20:39:50 <dons> now, i think its faster overall becaues 'i' is often <= 0, so less data gets generated.
20:39:58 <dons> anyway, its wrong, doesn't do any magic, so you can ignore it :)
20:40:07 <ddarius> There's a @shootout command?
20:40:11 <dons> huh
20:40:18 <dons> someone was obsessed
20:40:19 <paczesiowa> dons: I fogot that rem can result in negative number
20:40:20 <glguy> dons: whatever you did made GHC lose a spot to Eiffel?
20:40:38 <dons> glguy: yeah, apparently having less programs is sometimes better, than more but worse ranked
20:40:52 <dons> knuc and fasta aren't ranked very highly, so adding them affected the overall average
20:41:07 <dons> so do it well, or not at all :)
20:41:36 <dons> ah, fasta is too slow
20:41:42 <dons> k-nucleotide isn't too bad
20:41:56 <dons> oh, they're both 4x C.
20:48:23 <dons> paczesiowa: we can be smarter with the math, i notice.
20:50:00 <aFlag> is there lambdabot openbsd binaries somewhere by any chance?
20:51:48 <paczesiowa> dons: i shadows over i, but those c-like type casts make up for it:P
20:51:51 <dons> paczesiowa: down to 1.336s
20:51:59 <dons> and much shorter.
20:52:21 <dons> ah sorry, 3.392. so much the same. just nicer code.
20:52:59 <hpaste>  dons annotated "Print random number of random lines" with "use MT's standard method for [0..n-1] distribution" at http://hpaste.org/5102#a5
20:53:11 <dons> paczesiowa: ^ that requires a patch to the code.haskell.org repo i just pushed
20:53:30 <dons> generating random floating point numbers directly, and scaling them up, rather than the funky rem business
20:53:54 <zeno> when designing functions how do you know whats a good order to put the arguments in
20:54:11 <dons> and you can remove the default(Word) stuff, paczesiowa
20:54:24 <dons> zeno: the argument you'd most likely partially apply the function as is good
20:54:37 <dons> i.e. which arguments are most likely to vary -- they should be at the end
20:55:14 <zeno> ah thanks
20:55:24 <dons> for data structures, taking the data structure as second argument can be good
20:55:28 <dons> or the last  argument, i mean.
20:55:33 <dons> :t Data.Map.lookup
20:55:35 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
20:55:41 <dons> :t Data.ByteString.map
20:55:42 <lambdabot> (Word8 -> Word8) -> Data.ByteString.Base.ByteString -> Data.ByteString.Base.ByteString
20:55:53 <dons> data structure last.
20:57:03 <paczesiowa> dons: this version is slower than last one (6s vs 10s)
20:57:25 <bos> dons: are you using a ByteString-like technique for your mersenne twister interface?
20:57:48 <dons> nope. but probably will do a Chan-like interface (yield a infinite lazy list )
20:58:06 <dons> i can't see how we can make it pure :)
20:58:19 <dons> while bytestring is pure, if we treat it as an alternative ST monad
20:58:21 <ddarius> dons: You can hack some C.
20:58:32 <bos> yeah.  it would be nice to get something with the properties of MonadRandom.
20:58:45 <bos> @seen dcoutts
20:58:45 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I don't know when dcoutts last spoke.
20:59:24 <bos> on an unrelated note, we need to come up with some community standard for declaring a package orphaned, so someone else can start maintaining it.  witness recent discussions of HSQL.
21:00:11 <ddarius> Text.Parsec.Char haddocked
21:00:26 <dons> paczesiowa: strange. the new one based on truncate is faster here.
21:00:43 <dons> bos, i think you're supposed to just tell libraries@ you're taking over. and ask for any objections
21:00:46 <dons> wait a week, then hack.
21:00:52 * dons did that for X11
21:01:04 <bos> yeah.
21:04:41 <aFlag> hey dons, is plugins >=1.0, fps >=0.7 required by lambdabot's core or is requirement for some plugin?
21:05:06 <paczesiowa> dons: 10.5s vs <6s, maybe lack of those sse2 instructions (perhaps float thingies) results in slowing down?
21:05:10 <dons> you're not using the lambdabot on code.haskell.org
21:05:12 <dons> paczesiowa: ah could be.
21:05:58 <paczesiowa> dons: could you check withose sse2, if it's possible?
21:06:06 <paczesiowa> *without
21:06:12 <dons> yep, ok.
21:06:32 <aFlag> yeah, I'm not using the darcs version
21:07:17 <aFlag> I'm using 4.0.1 from your site
21:07:17 <dons> grab it first, its going to build on 6.8 (with darcs hs-plugins)
21:07:19 <dons> but not on openbsd...
21:07:55 <aFlag> hm
21:08:45 <dons> paczesiowa: no, same speed. i'm not sure why it would be slower on your machine.
21:09:41 <dons> oh, maybe i know, paczesiowa
21:09:47 <dons> let me check on a 32bit machine
21:10:28 <aFlag> ghc 6.8 doesn't compile on openbsd?
21:10:41 <dons> yeah , should be fine.
21:10:45 <dons> its in the package system too
21:11:05 <aFlag> why did you say not on openbsd then?
21:11:29 <dons> oh, hs-plugins isn't working on openbsd
21:11:35 <aFlag> oh I see
21:12:57 <dons> so the eval plugin won't work.
21:14:06 <aFlag> I played a little with eval once, I think that might be one of the downsides of strong typing, working with eval is not as easy.
21:14:28 <dons> metaprogramming in general is hard if things are typed :)
21:14:51 <aFlag> yeah, it's really easy on lisp
21:15:24 <dons> paczesiowa: wow, much slower on 32 bit machines
21:15:28 <dons> even with similar clocks
21:16:24 <paczesiowa> dons: bug or feature?
21:16:50 <dons> yeah, i get your results on a pentium4, 6.510s for the int version,  13.566s for the truncate version
21:16:59 <dons> on my core2 duo, its 3.2 and 3.3s
21:17:09 <dons> so the core2's rock the floating point world :)
21:17:26 <dons> paczesiowa: hardware feature, i guess we'll have to say
21:17:46 <nominolo> dons: yep, they improved a lot
21:19:13 <paczesiowa> on that c2d system is 64bit?
21:20:20 <dons> my system is 64bit, yeah.
21:20:30 <dons> so it generates 64bit Doubles and Int
21:20:37 <dons> you get the 32bit version.
21:21:36 * dons explains to gf what he's doing, something about mersenne primes, random numbers, and floating points
21:21:51 <faxathisia> hehe
21:23:22 <aFlag> hm, where does floating point connect to mersenne primes?
21:23:49 <ddarius> What's the haddock markup to reference an operator?  For other identifiers 'foo' works.
21:24:25 <ddarius> Ah, it's probably the <
21:24:58 <nominolo> @where Language.GHC
21:24:58 <lambdabot> I know nothing about language.ghc.
21:25:45 <dons> aFlag: MT is a random number generator that produces numbers with period 2^(large mersenne prime)
21:26:31 <dons> sorry, 2^N-1  :)
21:27:01 <aFlag> hm
21:27:22 <dons> > 2^19937-1
21:27:24 <lambdabot>  4315424797388162648055235516337919839053935043226711505165250541403330680137...
21:27:36 <nominolo> @where GHC
21:27:37 <lambdabot> http://haskell.org/ghc
21:27:42 <aFlag> when you said 2^(large mersenne prime) you meant 2^N - 1 (large mersenne prime), right?
21:27:46 <dons> :)
21:27:50 <nominolo> @ho GHC
21:27:50 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
21:28:06 <dons> oh, paczesiowa , i see in the generator's C code, "Note added in 2004/3: on 1998, usually MT was much faster than rand(), but the algorithm for rand() has been substituted, and now there are no much difference in speed.)"
21:28:08 <nominolo> @hoogle GHC
21:28:08 <lambdabot> Distribution.Simple.GHC :: module
21:28:08 <lambdabot> Distribution.Compiler.GHC :: CompilerFlavor
21:28:08 <lambdabot> Distribution.Simple.GHC.PackageConfig.GHCPackageConfig :: data GHCPackageConfig
21:28:46 <aFlag> I don't really know much about the random number generation theory, though :(
21:29:14 <dons> me neither. seems fun though
21:29:17 * faxathisia neither..
21:29:20 <aFlag> so I don't really see the advantage of having a large pseudoprime as a period
21:29:33 <dons> the point is to have a large period
21:29:48 <aFlag> oh, I see
21:34:26 <ddarius> Text.Parsec.Perm haddocked
21:35:58 <ddarius> 3 down, 7 to go
21:36:59 <bos> ddarius++
21:39:08 * bos is glad to see this being voted up: http://programming.reddit.com/info/65zy8/comments/
21:41:29 * bos has begun to wish for a dual-socket quad-core-per-socket system purely for compilation purposes.  sigh.
21:42:17 * faxathisia looks at the reddit site.. heehe.. "The Church-Turing thesis: lambdas and infinite tapes are equivalent"
21:44:11 * clanehin has begun to wish for this purely for no purpose in particular: http://htop.sourceforge.net/128.png
21:52:10 * derekv wishes he could dance electric boogaloo style
22:09:34 <Cale> clanehin: that's... are those 128 separate cores?
22:10:25 <dons> that's too many!
22:10:37 <hpaste>  mmorrow pasted "Database.HSQL.Utils" at http://hpaste.org/5106
22:10:42 <Cale> and that's quite a lot of ram as well
22:11:02 <Cale> > 882834/1024
22:11:05 <lambdabot>  862.142578125
22:11:10 <Cale> > 882834/1024/1024
22:11:11 <lambdabot>  0.8419361114501953
22:11:32 <Cale> 0.84 of a terabyte.
22:13:11 <Cale> Where did they get this machine of the not-so-distant future? :)
22:14:09 <dons> and are those haskell threads running on the cores?
22:14:16 <dons> a glimpse of the golden age!
22:17:21 <Cale> The next step will be having so many cores that displaying all their individual usage statistics at once will be visually challenging.
22:17:33 <faxathisia> An impressive setup -- htop running on a machine with 128 cores and 1TB of RAM
22:18:21 <ddarius> @src sort
22:18:22 <lambdabot> sort = sortBy compare
22:18:36 <ddarius> There is some odd stuff in this code.
22:18:58 <dons> Cale: we'll need to do coloured pixels :)
22:19:02 <dons> like a heat map
22:19:04 <dons> over the cpu cloud
22:21:31 <dons> 'split' is really interesting.
22:21:44 <dons> it purely-functionally 'intialises' a new random generator.
22:21:53 <dons> but that means it actually has to compute it from the initial generator
22:22:06 <dons> and its very hard to avoid correlations between the two streams then
22:23:15 <dons> e.g. the default StdGen split sez, '-- no statistical foundation for this!'
22:24:35 <Cale> Heh, and people will speak of megacores like they currently talk about megapixels in digital cameras :)
22:25:21 * faxathisia wonders what they will compute?
22:25:44 <ddarius> The same thing they compute today.
22:26:06 <faxathisia> 4! and a list of primes? :S
22:26:09 <Lycurgus_> p0rn?
22:26:29 <Lycurgus_> facebook and myspace?
22:26:54 <Cale> dons: hmm... if the effect of split is to produce generators which result in the even and odd elements of the original stream, then I think there's a little statistical foundation
22:27:12 <Cale> dons: Most generators worry about correlation in multiple dimensions.
22:27:15 <ddarius> Cale: For some, that should work.
22:27:31 <ddarius> Of course if you repeatedly split ...
22:27:46 <Cale> Then the number of dimensions gets large fast :)
22:28:18 <dons> what's the relationship to purity here? if i've a gen, and its theoretically splittable, couldn't it just initialise a new generator with unsafe* and return that instead?
22:28:26 * Lycurgus_ seems to recall that there have been a few computing system with physical random number generation
22:28:33 <dons> the side condition is that 'i could have split it, you can't tell if i did or didn't'
22:28:45 <Cale> dons: But you always want it to split to the same two generators.
22:28:57 <dons> yeah, so for deterministic results
22:29:13 <dons> when randoms are not so random
22:29:58 <dons> it really has to be the same split generator each time.
22:30:01 <Cale> Then there are things like Blum Blum Shub, which I bet is pretty safe to split even/odd.
22:31:21 <Cale> (It's not very fast, but figuring out which generator you have from the outputs is as hard as integer factorisation.)
22:31:37 <dons> yep
22:33:02 <ddarius> haddock needs better error messages
22:35:07 <ddarius> Er, nevermind (kind of).  It doesn't do instances.
22:40:57 <Cale> dons: http://en.wikipedia.org/wiki/Diehard_tests -- might be fun to implement these :)
22:40:58 <lambdabot> Title: Diehard tests - Wikipedia, the free encyclopedia
22:41:42 <dons> yeah, i was hoping to reuse a C lib for that.
22:41:54 <dons> though my little searching only found a cdrom you can buy
22:41:58 <dons> with lots of randoms, and the tests, on it
22:43:29 <Cale> http://www.phy.duke.edu/~rgb/General/dieharder.php
22:43:29 <lambdabot> Title: Robert G. Brown's General Tools Page
22:44:11 <dons> ah ha!
22:45:02 <Cale> ah, and it's a library and program in ubuntu
22:47:03 <ddarius> I'm pretty sure I've used that before.
22:47:44 <dons> yeah, looks like the right hting
22:55:32 <ddarius> This is the one I used: http://www.fourmilab.ch/random/
22:55:38 <lambdabot> Title: Pseudorandom Number Sequence Test Program
22:56:43 <ddarius> Here's me on the Internet shortly before I heard of Haskell: http://www.programmersheaven.com/mb/x86_asm/144483/144483/ReadMessage.aspx
22:56:44 <lambdabot> Title: Random numbers - x86 Assembly - Forums at ProgrammersHeaven.com, http://tinyurl.com/222zl6
22:59:52 <dons> :)
23:01:10 <faxathisia> this is quite amusing :p
23:17:37 <kuribas> quicksilver: ping
23:22:12 <Cale> ddarius: haha
23:40:50 <pheaver2> When I try to cabal build Yi (the latest version from darcs) on ghc-6.8.2, I get a "package can't be built on this system"... I get this message on both archlinux 32-bit and FreeBSD 64-bit.  Any thoughts?
23:49:18 <ramza3> If I have this code, "class WordFreq2 a where ... wordFreq2 :: a -> b"  ... where would I specify the type for 'b'
23:50:57 <bos> ramza3: what's b supposed to represent?
23:52:10 <ramza3> bos: lets say a string
23:53:06 <pheaver2> ramza3: well, if you know it's always a String, then just use that instead of "b" in the definition of the class?
23:53:10 <bos> ramza3: i don't understand what idea you're trying to express with that type signature.
23:53:17 <pheaver2> ramza3: me neither :)
23:53:23 <ramza3> me either
23:53:29 <pheaver2> heh
23:54:09 <faxathisia> wordFreq2 :: a -> String
23:54:27 <ramza3> yea, I was using String as a hypothetical
23:54:41 <faxathisia> wordFreq2 :: a -> Hypothetical
23:55:26 <faxathisia> Or you could do, class WordFreq2 a b where ... wordFreq2 :: a -> b
23:55:26 <pheaver2> ramza3: if 'b' could be different for each instance of WordFreq2, then it should be a parameter to the class, as in: class WordFreq2 a b where ... :: wordFreq2 :: a -> b
23:55:38 <pheaver2> ramza3: otherwise, if you know it's always the same type, then use that one
23:55:53 <pheaver2> i suppose :)
23:56:24 <ramza3> pheaver2: that is what I was looking for;  so I might have this instance; instance WordFreq2 Char String ...
23:56:36 <pheaver2> yes, like that
23:56:54 <ramza3> just didn't know how to describe what I was trying to accomplish
23:56:59 <pheaver2> ah
23:57:51 <ddarius> ramza3: That uses an extension called Multi-Parameter Type Classes.
23:57:54 <pheaver2> ramza3: just out of curiosity, might 'b' always be [a], as was the case in your example
23:57:56 <pheaver2> ?
23:58:03 <ramza3> using your pheaver2 no
23:58:31 <ramza3> no I mena
23:58:36 <pheaver2> ah ok :)
23:58:54 <ramza3> it is late on my side of the globe
23:59:16 <pheaver2> heh
