00:00:00 <mgsloan> yeh, tuples are anonymous product types.  It'd be cool if there were anonymous summation types (the equivalent of A | B | C in data decls)
00:00:45 <conal> mgsloan: that'd be nifty.  and we'd want a nice syntax for patterns.
00:01:03 <conal> maybe (a||),(|b|),(||c)
00:01:26 <mgsloan> yep, would certainly be interesting anyway
00:01:37 <conal> oh. for expressions as well as patterns.
00:02:24 <kmcallister> yeah, in this case we have a collision with sections
00:02:48 <conal> and of course it'd have the same problems we were just discussing for tuples.
00:02:56 <conal> inconsistent library support
00:03:21 <wagle_> > (,,) 1 2 3
00:03:23 <lambdabot>  (1,2,3)
00:03:42 <wagle_> > (,2,) 1 3
00:03:42 <lambdabot>  Parse error at "2,)" (column 3)
00:03:46 <wagle_> awwww
00:06:38 <lispy> anyone know dons current email addy?
00:06:52 <lispy> does he have a gmail or does he still use his cs.unsw addy?
00:07:05 <wagle_> check his webpage
00:07:21 <wagle_> @src lambdabot
00:07:22 <lambdabot> Source not found. You speak an infinite deal of nothing
00:08:18 <wagle_> @where lambdabot
00:08:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
00:10:10 <yurinotigor> where can I download cabal?
00:10:54 <yurinotigor> I am trying to install it from macports but it doesnt work: "configure: error: GHC is required unless bootstrapping from .hc files."
00:11:38 <yurinotigor> nevermind.... found it
00:11:39 <sarehu> cabal comes with GHC, no?
00:11:54 <yurinotigor> humm, how can I check?
00:12:11 <yurinotigor> ghc-pkg list
00:12:17 <wagle_> oh he works for galois, now
00:12:20 <yurinotigor> you are right... its there
00:12:28 <yurinotigor> grazie: sarehu
00:23:08 <kmcallister> what's a good way to serialize a Data.Set?
00:24:36 <lispy> http://files.codersbase.com/haskell-logs/haskell-current.png  <-- the haskell social network with no temporal decay as mined from the log files
00:24:59 <lispy> As you can tell, their graph drawing algorithm is flawed for an image that size
00:26:22 <kmcallister> ah, Data.Binary does it
00:27:42 <lispy> actually, if i just make it bigger it's not so bad
00:28:39 <kmcallister> @hoogle ByteString -> String
00:28:43 <lambdabot> No matches, try a more general search
00:30:51 <Cale> whoa, that's a large rendering
00:31:29 <Cale> lispy: I wonder how well graphviz would fare.
00:31:29 <wagle_> darn, dont have a wheel mouse on this machine
00:35:58 <kmcallister> i've seen graphviz do much larger graphs decently
00:36:19 <kmcallister> i don't know if you can weight edges though
00:43:53 <ADEpt> kmcallister: you can, sort of
00:58:08 <ketil> lispy: what is it based on? (ie. what do links represent?)
00:59:47 <lispy> ketil: communication between people, based on some inference heurstics
01:00:00 <lispy> ketil: it's generated by a piespy bot
01:00:23 <lispy> Cale: yeah, we need something else, I was just thinking applying a hyperbolic transformation would help
01:00:31 <lispy> Cale: stretch the center, ya know
01:00:39 <Cale> mm, yeah
01:01:27 <lispy> it seems like the algo they use is to just evenly space the nodes
01:01:36 <lispy> but, that doesn't really work when you're drawing so many connections
01:02:09 <lispy> Cale: if this were haskell code do you think you could improve the rendering?
01:02:16 <lispy> maybe something vector based like cairo would help?
01:02:26 <lispy> it definitely seems like the output should be vector not bitmap
01:02:49 <Cale> I must admit I don't know a whole lot about graph layout algorithms.
01:03:13 <lispy> right, and i'm sure it's a tedious subject
01:04:36 <lispy> I should take one of the hard to read ones into my sci. vis. graphics professor and ask for advice
01:04:51 <lispy> I'm sure he'd have great input
01:05:05 <lispy> well, assuming he finds it interesitng
01:05:28 <Cale> Well, I suspect it has a lot to do with planarity testing/finding. It's quite a bit like finding a planarity when you might not be able to do it, and there are some conflicting goals as well :)
01:12:35 <sizur> i dont remember talking to some of the ppl i'm connected according to that graph
01:12:49 <sizur> "the big brother is drawing"
01:15:27 <sizur> dang, there's too much information that can be deduced...
01:21:10 <kmcallister> has anyone here done shader programming with OpenGL in haskell?
01:22:32 <kmcallister> cool, it looks like the requisite bindings exist now
01:31:22 <Taejo> what is the "con2tag_Play#" function that's showing up in my profiles? (using GHC)
01:31:22 <dancor> is it possible to generate a random production of a parsec parser
01:33:32 <Cale> dancor: no, not of a Parsec parser.
01:33:49 <paczesiowa> dancor: should be, everything in haskell is 1st class citizen
01:33:53 <Cale> You'd have to store your parsers differently
01:33:55 <paczesiowa> Cale: why not?
01:34:07 <Cale> Because it's internally a function, and functions aren't observable.
01:34:29 <Cale> You could design a combinator parser library which had that ability.
01:34:40 <Cale> But it wouldn't be monadic.
01:34:56 <paczesiowa> how about creating list of char parsers [parser 'a'..parser 'z'] and then fold it with bind or <|> randomly
01:35:37 <Cale> paczesiowa: That's different.
01:35:51 <Cale> paczesiowa: He wants a random string which is accepted by a given parsec parser.
01:35:59 <Cale> (at least, that's how I took it)
01:36:03 <dancor> Cale: yeah
01:36:23 <dancor> i guess i want to make a combinator parser that can do that
01:36:32 <dancor> is parsec the best starting point
01:36:55 <dancor> s/combinator parser/\0 library/
01:37:13 <paczesiowa> ok, I get it now
01:37:25 <mgsloan> woo, editing
01:37:35 <quicksilver> kmcallister: No, I don't think anyones has really played with that
01:37:46 <quicksilver> kmcallister: conal suggested he might have a go but he cruelly disappointed us.
01:38:15 <quicksilver> kmcallister: the bindings are there but you still have to use that ghastly C-like language for the actual shader. A DSL to generate that would be lovely.
01:38:51 <paczesiowa> it should be easy if we could decompose parsers, right?
01:38:56 <Cale> paczesiowa: yeah
01:39:13 <kmcallister> quicksilver, i worked on such a DSL last year
01:39:25 <kmcallister> maybe i should revive the project
01:39:30 <nominolo> quicksilver: there is a research project for this
01:39:49 <quicksilver> it would be relatively easy to add an 'intermediate layer' above parsec which retained full structure and was introspectable
01:39:57 <quicksilver> just an AST for parsec's concrete syntax
01:39:59 <kmcallister> nominolo, i saw the project to generate CUDA for array ops, but i'm interested in graphics rather than GPGPU (in this particular case)
01:40:08 <nominolo> quicksilver: i just got the MSc thesis, it's similar to Lava's ideas
01:40:18 <nominolo> kmcallister: oh, ok
01:40:19 <quicksilver> nominolo: is that one of conal's?
01:40:23 <nominolo> quicksilver: no
01:40:24 <quicksilver> or something different
01:40:25 <Cale> The hard part with monadic parser combinator libraries is that they have arbitary functions embedded inside them.
01:40:35 <kmcallister> and GLSL isn't a terrible language, as C-like languages go it's quite reasonable
01:40:44 <Cale> (because of the type of bind, this is pretty unavoidable)
01:40:45 <kmcallister> i would like to see more functional shader languages though, given how functional the task is
01:40:45 <paczesiowa> maybe just changing parser type (and it's monad instance) would work
01:41:00 <Cale> But maybe with an applicative parsing library, it would be easier.
01:41:03 <nominolo> kmcallister: maybe you can give it a shot and adopt some ideas from that MSc thesis
01:41:06 <quicksilver> kmcallister: I was indulging in a bit of hyperbole :)
01:41:15 <quicksilver> kmcallister: but a functional approach would be nicer.
01:41:33 <quicksilver> kmcallister: I imagine the hard part would be working around all the bugs in graphics cards and areas where they incompletely implement the spec.
01:41:42 <kmcallister> yeah, i've run into a lot of those
01:41:43 <quicksilver> incompletely and or incorrectly
01:42:05 <kmcallister> maybe targeting Cg rather than GLSL would help, it adds another layer of compilation
01:46:52 <visof> hello
01:47:00 <Cale> hi
01:47:17 <quicksilver> kmcallister: Cg is not nvidia-specific?
01:47:47 <visof> for defining our own types we use data
01:48:01 <visof> data Bool = False | True
01:48:04 <quicksilver> that's right
01:48:19 <visof> data point a = pt a a
01:48:21 <dancor> Cale: so i should look at Control.Applicative and go from there?
01:48:21 <kmcallister> quicksilver, it can compile to GLSL and HLSL, as well as various card-specific assembly languages
01:48:26 <visof> i can't understand this
01:48:29 <quicksilver> kmcallister: oh, interesting.
01:48:35 <kmcallister> it's an nvidia product but designed to be usable on any hardware
01:48:35 <Cale> dancor: perhaps try that :)
01:48:36 <quicksilver> visof: well it's not correct as written
01:48:39 <dcoutts_> kmcallister: I've not heard of anyone porting gtk2hs to hildon, but I don't expect it'd be too hard, the harder part would be getting ghc working there
01:48:47 <kmcallister> CUDA is, to my knowledge, only usable on nvidia hardware, and new cards at that
01:48:55 <kmcallister> it solves a much different problem than Cg though
01:48:58 <Cale> dancor: It seems like an Applicative parsing library would have a better shot at analysis to me anyway.
01:49:00 <dcoutts_> kmcallister: or porting gtk2hs to work with yhc
01:49:21 <kmcallister> dcoutts_, ghc has issues on ARM?
01:49:43 <dcoutts_> kmcallister: it worked on 6.6, I dunno if anyone has tried it
01:49:52 <visof> data point a = Pt a a
01:50:07 <dcoutts_> koeien: tried it with 6.8 or on th N800 specifically
01:50:10 <kmcallister> visof, type constructors have to be capitalized
01:50:32 <visof> data Point a = Pt a a
01:50:33 <kmcallister> data Point a = Pt a a
01:50:54 <mgsloan> visof - it's sort of like a function.  the type (Point Double), will have the constructor Pt :: Double -> Double -> Point
01:51:15 <quicksilver> visof: yeah :) capital letters matter, in types and constructors.
01:51:17 <ski> Pt :: Double -> Double -> Point Double  -- !
01:51:27 <mgsloan> err right!
01:51:32 <quicksilver> visof: so that says, you have a new type "Point"
01:51:35 <mgsloan> it's nearly 2 am here ;)
01:51:43 <quicksilver> visof: and the type is parameterised over a variable type "a"
01:51:54 <quicksilver> visof: and the constructor is "Pt", which takes two parameters
01:51:59 <quicksilver> visof: both being of type "A"
01:52:02 <mgsloan> it's like generics in other languages
01:52:06 <quicksilver> visof: so, you'd have the type "Point Double"
01:52:20 <quicksilver> visof: with values like "Pt 1.5 3.5"
01:52:31 <quicksilver> visof: whiles "Point Int" would ahve values like "Pt 8 4"
01:52:40 <mgsloan> haskell's lists are an example of such a parameterized type.
01:52:45 <quicksilver> visof: and apaprently less usefully, Point String with values like Pt "foo" "bar"
01:52:55 <quicksilver> mgsloan: I don't believe visof knows any other languages...
01:53:06 <mgsloan> oh, ok
01:53:06 <ski> `Point' is a function on types, given any type `a' it gives the type `Point a' with constructor `Pt' having type `a -> a -> Point a'
01:53:14 <kmcallister> visof, for that matter you can do things like Pt (Pt 1 2) (Pt "foo" "bar"), which could have type Point (Point Int) (Point String)
01:53:20 <mgsloan> Point (IO Double) :)
01:53:47 <ski> Fix Point
01:53:51 <kmcallister> haha
01:53:58 <quicksilver> Cale: I believe you could have a 'monad-like' thing which used an explicit version of bind
01:54:18 <ski> quicksilver : explicit ?
01:54:24 <quicksilver> Cale: didn't permit arbitrary functions but rather some ADT for functions
01:54:27 <Cale> You'd maybe end up with something rather like an Arrow :)
01:54:36 <quicksilver> well, yes and no
01:54:42 <quicksilver> it wouldn't admit "pure"
01:54:49 <quicksilver> because pure allows you to inject arbitrary functions
01:54:56 <quicksilver> everything would have to be abstract
01:55:00 <kmcallister> ski: data Fix (t :: * -> *) = Fix (t (Fix t)) ?
01:55:05 <Cale> On the result type, but not arbitrary parsing effects.
01:55:05 <ski> down with `pure' !
01:55:09 * quicksilver nods
01:55:23 <ski> kmcallister : basically, though i prefer s/data/newtype/
01:55:29 <kmcallister> oh right, that is a newtype
01:55:47 <Cale> If the analysis you're doing doesn't involve the actual result of the parser, but only if it succeeded or failed, you can ignore pure :)
01:56:05 <quicksilver> that's true
01:56:09 <visof> i can do this type   data  X [a] = Y a a a  ??
01:56:16 <quicksilver> No
01:56:22 <quicksilver> not sure what that would mean
01:56:23 <visof> why?
01:56:23 <ski> visof : no, you can't pattern-match on the type arguments
01:56:27 <quicksilver> data X a = Y a a a
01:56:28 <quicksilver> is fine
01:56:33 <kmcallister> data X a = Y [a] [a] [a]
01:56:35 <quicksilver> that declares 'a' to be a type-parameter
01:56:39 <quicksilver> kmcallister's is fine too...
01:57:02 <kmcallister> the thing to the left of the = will be a single type name (capitalized) followed by zero or more type variable names (lowercase)
01:57:21 <kmcallister> no type patterns, sadly :/
01:57:29 <ski> Cale : `parseBool >>= \b -> if b then foo else bar'
01:57:37 <visof> can i define a lot of type parameters ?
01:57:44 <kmcallister> visof, as many as you like
01:57:48 <ski> visof : yes, as many as you like
01:57:59 <Cale> ski: I'm talking about arrow libraries.
01:58:02 <visof> data X a b = Y a b
01:58:02 <kmcallister> with ghc extensions you don't even have to use them, i.e. data X a b c d e = X a
01:58:05 <visof> ?
01:58:08 <kmcallister> although this is only useful in certain advanced situations
01:58:10 <kmcallister> visof, yes
01:58:15 <visof> hehe
01:58:25 <kmcallister> in fact you can call X and Y both X, since types and values live in disjoint namespaces
01:58:25 <visof> i understood now
01:58:32 <ski> Cale : oh, i though you were including "an explicit version of bind", there ..
01:58:42 <kmcallister> this can get confusing though... i generally do this when and only when the type has only a single constructor
01:58:48 <Cale> ski: yeah, it's not clear how that would work
01:58:53 <Cale> kmcallister: uh, are you sure that's an extension?
01:58:58 <kmcallister> Cale, phantom types?
01:58:58 <kmcallister> maybe not
01:59:07 <Cale> I'm pretty sure unused type parameters are allowed in H98
01:59:19 <ski> indeed
01:59:31 <Cale> (there'd be no good reason not to support them)
01:59:52 <kmcallister> true
02:00:23 <Cale> Then again, multiparameter typeclasses were left out entirely.
02:00:38 <visof> kmcallister you meant that   data X a b = X a b ??
02:00:44 <kmcallister> yeah
02:00:49 <ski> X :: a -> b -> X a b
02:00:56 <kmcallister> the two X are in different namespaces
02:00:58 <kmcallister> so there's no collision
02:01:07 <visof> oh
02:01:15 <kmcallister> if you write X in a type, it knows you mean the X that takes two types and produces another type, and similarly for values
02:01:38 <visof> nice
02:02:45 <kmcallister> the four namespaces are (type, value) x (constructor, variable)
02:02:53 <kmcallister> plus more for operators i guess
02:03:33 <visof> can anyone define for me function with that type :
02:03:46 <visof> data Point a = Pt a a
02:04:01 <kmcallister> visof, that's not a type, it's a declaration of a type
02:04:23 <visof> with type Point
02:04:26 <visof> sorry
02:04:32 <kmcallister> also not a type, you need to specify what a is
02:04:35 <lispy> ?djinn Point a -> a
02:04:36 <lambdabot> -- f cannot be realized.
02:04:40 <kmcallister> "Point a" is a type
02:04:43 <kmcallister> for any type a
02:04:43 <lispy> oh, it's immpossible
02:05:12 <kmcallister> when you declare Point like that, you automatically get the function Pt :: a -> a -> Point a
02:05:30 <kmcallister> which you can use to construct other things returning Points
02:05:35 <kmcallister> you can also go the other direction by pattern matching
02:06:02 <kmcallister> if we define "f (Point x y) = x" then f :: Point a -> a
02:06:52 <quicksilver> Cale: MPTCs were left out entirely because most obvious uses of them require fundeps or some equivalent hint for the type inferrer.
02:06:58 <quicksilver> Cale: or that was my understanding :)
02:07:15 <quicksilver> [actually it's always sufficient but very messy to add lots of phantom parameters, I think]
02:07:28 <kmcallister> f (Point x y) = x ++ y     -- f :: Point [a] -> [a]
02:08:06 <kmcallister> note how the type becomes specialized (the things in the point must be lists), but not fully specified (they can be lists of anything, as long as it's the same for both)
02:08:19 <visof> kmcallister you said Pt is a function right?
02:08:26 <kmcallister> visof, yes
02:08:46 <quicksilver> kmcallister's example was slightly inconsistent
02:08:55 <quicksilver> it should have been f (Pt x y) ....
02:08:59 <kmcallister> oh damn
02:08:59 <visof> data Bool = True | False is True or False functions here?
02:09:02 <quicksilver> if we're sticking to Pt for the constructor.
02:09:04 <kmcallister> good catch, thanks
02:09:09 <quicksilver> visof: "nullary" functions
02:09:10 <kmcallister> yeah, sorry for the confusion
02:09:12 <quicksilver> visof: i.e. constants
02:09:24 <quicksilver> (functions which take no parameters are still sort of functions, in a generalised sense)
02:09:46 <kmcallister> data Foo = Bar a b .. z   -- Bar :: a -> b -> ... -> z -> Foo
02:09:47 <sizur> visof, they are constructors that take no arguments and produce a Bool type value
02:09:48 <visof> so True and False are functions too
02:10:01 <kmcallister> visof, they're values, and functions are values
02:10:06 <quicksilver> well, in a sense
02:10:16 <quicksilver> sometimes it's convenient to think of a value as a 'function with no parameters'
02:10:21 <quicksilver> sometimes that's a silly thing to think :)
02:10:32 <quicksilver> but it can help when trying to show that things are consistent
02:10:49 <kmcallister> or the other direction, each constructor is a value, and in some cases the value's type is a function type
02:11:29 <sizur> functions are values in functional programming
02:11:38 <visof> ok
02:20:06 <shag> i am trying to install the bzlib package from hackage on a debian system and  when dogin "runhaskell Setup.hs build" it fails with cc1: error: unrecognized command line option "-fno-toplevel-reorder" -- any ideas?
02:20:45 <mux> you probably have a somewhat old GCC version, removing this build flag should be enough to get you going
02:21:18 <shag> gcc (GCC) 4.1.2 20061115 (prerelease) (Debian 4.1.1-21)
02:21:49 <mux> just remove this flag from the cabal file
02:21:55 <shag> ok
02:22:47 <mux> now that raises an interesting question: I don't know if it's easily possible to have build flags depending on a specific GCC version in a cabal file
02:23:01 <shag> hm, i don't see the flag in the cabal file
02:23:10 <mux> ah
02:23:21 <mux> that's more annoying then :-)
02:23:28 <shag> yes, indeed :)
02:25:43 <int-e> does removing -fvia-C help? (I don't know whether bzlib builds without that flag, but if I remember a recent discussion about this on #ghc correctly, ghc adds the -fno-toplevel-reorder flag in that case, if ghc was built with a gcc newer than 4.2.0)
02:26:36 <shag> that worked
02:28:19 <shag> but GHC shouldn make the depending on the gcc version used to build itself but rather the gcc version on the system
02:28:36 <shag> the cases were these things differ are probably rare, but not impossible
02:29:04 <int-e> hmm, there should be an  extra-gcc-opts  file in the ghc installation, which contains the offending flag. older gccs need  -fno-unit-at-a-time  instead.
02:29:36 <int-e> (/usr/lib/ghc-6.8.2/extra-gcc-opts  would be my guess)
02:30:36 <shag> youre saying i should replace -fno-toplevel-reorder with -fno-unit-at-a-time in that file?
02:30:42 <int-e> yes
02:30:47 <shag> ok
02:36:52 <int-e> I guess ghc should come with a script to regenerate that file on the target machine.
02:37:20 <shag> uh. and were could i possibly find that?
02:37:27 <quicksilver> 'should' not 'does'
02:37:50 <quicksilver> there are many many problems with ghc if target machine is different...
02:37:51 <quicksilver> ;)
02:38:08 <shag> quicksilver, well, i also said "there should be an extra-gcc-opts file" and it was there :)
02:38:20 <quicksilver> and also if gcc has changed, which amounts to something simlar
02:38:25 <shag> not i but he
02:39:29 <int-e> well, in this case such a script doesn't exist (unless you count the configure script in the source tarball)
02:40:09 <bringert> anyone looking for a FP PhD position: http://www.cs.chalmers.se/~koen/phdad.html
02:40:10 <lambdabot> Title: PhD Positions in Functional Programming at Chalmers
03:01:39 <sizur> @pl \f g a -> f a || g a
03:01:40 <lambdabot> liftM2 (||)
03:02:04 <quicksilver> :t or
03:02:06 <lambdabot> [Bool] -> Bool
03:02:10 <quicksilver> :t any
03:02:10 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
03:02:15 <quicksilver> hmm
03:03:45 <sizur> @pl \ps as -> filter (\a-> any (p a) ps) as
03:03:45 <lambdabot> filter . flip (any . p)
03:05:07 <sizur> @pl \ps as -> filter (\a-> any (\p->p a) ps) as
03:05:08 <lambdabot> filter . flip (any . flip id)
03:05:27 <sizur> @pl \as ps -> filter (\a-> any (\p->p a) ps) as
03:05:28 <lambdabot> flip (filter . flip (any . flip id))
03:05:47 <sizur> :t filter . flip (any . flip id)
03:05:47 <lambdabot> forall a. [a -> Bool] -> [a] -> [a]
03:06:20 <sizur> :t flip id
03:06:21 <lambdabot> forall b c. b -> (b -> c) -> c
03:06:37 <sizur> :t id
03:06:38 <lambdabot> forall a. a -> a
03:06:45 <sizur> :t flip
03:06:46 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
03:07:05 <sizur> what does flip id mean?
03:08:01 <idnar> @unpl flip id
03:08:02 <lambdabot> (\ b c -> c b)
03:08:33 <idnar> it might be easier to think of as flip ($)
03:08:51 <sizur> take an argument and then apply it to the next argument. i see
03:09:02 <sizur> nifty
03:09:54 <doserj> sizur: no. take an argument and apply the next argument to it
03:10:03 <sizur> @djinn f :: (Monad m) => m (a->Bool) -> m a -> m a
03:10:03 <lambdabot> Cannot parse command
03:10:26 <idnar> @djinn (Monad m) => m (a->Bool) -> m a -> m a
03:10:48 <idnar> I don't think djinn does monads anyway
03:11:32 <sizur> @djinn m (a->Bool) -> m a -> m a
03:11:32 <lambdabot> f _ a = a
03:11:36 <sizur> lol
03:11:39 <idnar> @hoogle m (a->Bool) -> m a -> m a
03:11:40 <lambdabot> No matches, try a more general search
03:11:47 <idnar> I'm not sure I understand what that function is supposed to do
03:12:09 <sizur> doserj, right, you apply functions to arguments, not vice versa.
03:13:30 <sizur> :t filter . flip (any . flip id)
03:13:31 <lambdabot> forall a. [a -> Bool] -> [a] -> [a]
03:14:05 <sizur> it does not make sense outside of lists anyway
03:14:49 <sizur> :t flip 5
03:14:49 <lambdabot> forall a b c. (Num (a -> b -> c)) => b -> a -> c
03:16:41 <quicksilver> http://trevion.blogspot.com/2007/02/snowball-chance.html
03:16:41 <lambdabot> Title: Nonlinear: A Snowball&#39;s Chance
03:16:48 <quicksilver> is this someone here?
03:16:49 <sizur> :t flip 5 succ
03:16:50 <lambdabot>     Ambiguous type variable `a' in the constraint:
03:16:50 <lambdabot>       `Enum a' arising from use of `succ' at <interactive>:1:7-10
03:16:50 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
03:17:31 <sizur> :t flip (5::Int) succ
03:17:32 <lambdabot>     Couldn't match expected type `a -> b -> c'
03:17:32 <lambdabot>            against inferred type `Int'
03:17:32 <lambdabot>     In the first argument of `flip', namely `(5 :: Int)'
03:20:34 <sizur> one must be feeling exceptionally bad when one puts in a year of work and it turns out to be a failure :(
03:27:15 <dcoutts_> @seen byorgey
03:27:15 <lambdabot> byorgey is in #haskell-blah, #oasis, #xmonad and #haskell. I last heard byorgey speak 7h 51m 8s ago.
03:29:33 <RayNbow> hmm...
03:29:40 <RayNbow> :t generate
03:29:42 <lambdabot> Not in scope: `generate'
03:29:54 <RayNbow> :t Test.QuickCheck.generate
03:29:55 <lambdabot> forall a. Int -> StdGen -> Test.QuickCheck.Gen a -> a
03:29:58 <nominolo> anyone know of a usable Curry->Haskell compiler?
03:33:23 <byorgey> hi dcoutts_
03:33:35 <byorgey> I just woke up =)
03:33:40 <dcoutts_> byorgey: :-) I was looking at the patch
03:34:01 <byorgey> dcoutts_: cool, any ideas?
03:34:35 <dcoutts_> byorgey: I've not tested it yet, so I'm not quite sure what you mean about getting the x- flags from the build info
03:35:10 * dcoutts_ tries it in ghci
03:36:03 <byorgey> dcoutts_: well, the biggest problem is that if you put an x- field somewhere in, say, a library section, and then print out the parsed GenericPackageDescription, the x- field doesn't show up in the output
03:36:07 <visof> can i have haskell debugging tutorial ??
03:36:33 <dcoutts_> byorgey: I don't trust the pretty printer in the slightest :-)
03:36:45 <byorgey> dcoutts_: and I'm not quite sure how to make it appear
03:36:49 <byorgey> dcoutts_: fair enough =)
03:38:28 <byorgey> dcoutts_: so, putting x- fields in the main PackageDescription works fine, I've tested that
03:38:49 <dozer> can I have a hand using darcs2?
03:38:51 <byorgey> dcoutts_: but I don't know how to test whether it works to put an x- flag in a library or executable section.
03:39:03 <dcoutts_> byorgey: I'm trying it in ghci...
03:39:04 <dozer> I have a darcs (non-hashed) view of the hxt repo
03:39:21 <dozer> I need to make it hashed to be able to apply a troublesom patch
03:39:40 <dozer> I made a hashed copy of my copy of the hxt repo
03:39:58 <dcoutts_> byorgey: yep, works
03:40:01 <dozer> but of course, the hashed one couldn't see any patches as it's looking at my un-hashed repo for patches
03:40:06 <dozer> where now?
03:40:16 <byorgey> dcoutts_: cool. =)  how did you test it?
03:40:48 <byorgey> dcoutts_: I just don't understand the whole CondTree thing very well and how all that information gets put together by the parser.
03:40:52 <dcoutts_> byorgey: fmap (library.flattenPackageDescription) $ readPackageDescription Distribution.Verbosity.normal "Cabal.cabal"
03:41:37 <dcoutts_> byorgey: a GenericPackageDescription contains a PackageDescription, but it's just teasing you, you really have to finalise or flatten to get a proper PackageDescription
03:42:39 <nominolo> byorgey: is that one more vote for me documenting or simplifying the CondTree stuff?
03:42:53 <byorgey> dcoutts_: ah, got it
03:43:03 <byorgey> dcoutts_: yep, I see, that works, I tried it too
03:43:21 <byorgey> nominolo: yes, I suppose it is =)
03:43:54 <nominolo> byorgey: what exactly is going wrong?  just getting the overview, or do you have some specific questions?
03:44:13 <dcoutts_> nominolo: nothing is wrong it's just confusing :-)
03:44:34 <nominolo> dcoutts_: confusing it is, yes.
03:44:42 <nominolo> let's see what i can do about that
03:45:09 <dcoutts_> nominolo: people get confused by the fact that the GenericPackageDescription contains a PackageDescription which it turns out it just there to taunt you :-)
03:45:22 <dcoutts_> because it doesn't contain the info you expect
03:45:29 <byorgey> dcoutts_: ok, so the parsing works, but it definitely breaks the read/show idempotency property in ticket #155 (i.e. r . s . r == r)
03:45:32 <nominolo> dcoutts_: yeah, that's because some code needed that
03:45:37 <byorgey> dcoutts_: I don't know how much anyone cares about that
03:45:50 <dcoutts_> byorgey: no, that's borked anyway
03:45:55 <byorgey> dcoutts_: ok =)
03:45:57 <nominolo> byorgey: no-one except kolmodin
03:46:02 <byorgey> hehe
03:46:17 <dcoutts_> it'd be nice if it worked, but it's not going to with the current style
03:46:26 <dcoutts_> I think the pretty printing should go back via the same route as the parsing
03:46:29 <byorgey> well, I did get it to work for PackageDescriptions, at least =D
03:46:30 <dcoutts_> so they are kept in sync
03:47:07 <byorgey> dcoutts_: that would be nice, but for that to work with this new x- field stuff, the whole parsing framework would need an overhaul
03:47:19 <dcoutts_> byorgey: aye, it does need an overhaul :-(
03:47:27 <nominolo> true, and i don't think that's a good idea
03:47:35 <dcoutts_> not at this point
03:48:18 <dcoutts_> when we reorganise the generic / package description stuff perhaps
03:49:02 <nominolo> but we have this two-phased parsing
03:49:33 <dcoutts_> which is a good thing imho
03:49:40 <nominolo> so, the pretty-printers would have to emit this intermediate structures?
03:49:44 <dcoutts_> yes
03:49:53 <nominolo> dcoutts_: yes, for the problem at hand it's best
03:50:17 <zerny> @pl a -> a
03:50:17 <lambdabot> (line 1, column 3):
03:50:17 <lambdabot> unexpected ">" or "-"
03:50:17 <lambdabot> expecting variable, "(", operator or end of input
03:50:23 <dcoutts_> byorgey: I can't help feeling the patch could be simpler
03:50:32 <nominolo> ok, that would be some effort, but with little obvious use
03:51:02 <byorgey> dcoutts_: that's quite possible.  I feel that way too.
03:51:03 <zerny> hmmm, how does the type to function search thing work?
03:51:10 <dcoutts_> nominolo: you don't think writing package files is useful? what about ides etc?
03:51:14 <zerny> if that is what it is...
03:51:14 <byorgey> zerny: that's @hoogle
03:51:23 <zerny> hmmm
03:51:25 <dcoutts_> nominolo: or automaticly adjusting package descriptions, eg in hackage.
03:51:58 <nominolo> well .. if you put it that way .... ;)
03:52:02 <zerny> byorgey: I tried searching for "(Monad m) => m a -> m b -> m b" on hoogle... did not show >>
03:52:22 <byorgey> zerny: yeah, it doesn't work well when type classes like Monad are involved =(
03:52:33 <zerny> byorgey: too bad
03:52:38 <quicksilver> it's supposed to
03:52:51 <quicksilver> I thought
03:52:57 <zerny> I was looking for a type (Monad m) => m a -> b -> m b
03:53:05 <zerny> would like to get rid of a return
03:53:39 <dcoutts_> byorgey: eg, the fact that we have to repeat the UnrecFieldParser four times, for package description, lib, exe and bi
03:53:57 <byorgey> dcoutts_: yes, that definitely bothered me
03:54:02 <dcoutts_> byorgey: for lib and exe I'd hope we could just lift it from the BuildInfo
03:54:16 <byorgey> dcoutts_: I couldn't see a way around it with the types
03:54:28 <quicksilver> ah
03:54:33 <quicksilver> for "type classes like monad"
03:54:35 <quicksilver> read
03:54:39 <quicksilver> "higher kinded type classes"
03:54:39 <zerny> to get: e1 >> return e2 to something like e1 `op` e2. Is there anything build in?
03:55:06 <quicksilver> hoogle copes fine with * kind type classes
03:55:13 <byorgey> quicksilver: ah. we'll just pretend that's what I meant in the first place =)
03:55:21 <quicksilver> zerny: there is const e2 <$> e1
03:55:27 <quicksilver> that's not actually any shorter
03:55:35 <quicksilver> what's wrong with e1 >> return e2?
03:55:36 <quicksilver> ;)
03:55:38 <quicksilver> seems fine to me
03:55:38 <zerny> quicksilver: hehe nope.
03:55:40 <byorgey> zerny: I don't think there's anything built in
03:55:58 <zerny> quicksilver: nothing much, just curious :)
03:56:12 <nominolo> zerny: <**>
03:56:20 <quicksilver> :t (<**>)
03:56:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
03:56:39 <byorgey> dcoutts_: it would work really nicely with FRefs for the record fields =)
03:56:51 <nominolo> maybe not
03:56:51 <dcoutts_> byorgey: FRef?
03:56:57 <quicksilver> nominolo: that's just flip <*> afaik
03:57:01 <byorgey> dcoutts_: functional references
03:57:07 <idnar> @pl \e1 e2 -> e1 >> return e2
03:57:08 <lambdabot> (. return) . (>>)
03:57:23 <byorgey> dcoutts_: http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
03:57:24 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
03:57:43 <idnar> :t (<$)
03:57:44 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
03:58:22 <idnar> hmm, no
03:58:40 <quicksilver> actually that's quite close
03:58:45 <quicksilver> :t (>$)
03:58:46 <lambdabot> Not in scope: `>$'
03:58:48 <byorgey> dcoutts_: the problem is it's easy to pass a 'getter' function for a record field to a higher-order function, but 'setter' functions suck
03:58:52 <quicksilver> :t ($>)
03:58:53 <lambdabot> Not in scope: `$>'
03:59:13 <quicksilver> zerny: e2 <$ e1
03:59:14 <zerny> nominolo: hmm, i don't follow how that works.
03:59:17 <quicksilver> zerny: it looks like.
03:59:27 <zerny> quicksilver: yes, that does
03:59:29 <dcoutts_> byorgey: they do rather: (\s v -> s { f = v })
03:59:33 <visof> can i define this function :  foo [] = " "
03:59:47 <nominolo> zerny: no, sorry, got that confused
03:59:51 <idnar> > let foo [] = " " in foo []
03:59:52 <lambdabot>  " "
04:00:00 <idnar> > let foo [] = " " in foo [5]
04:00:00 <visof> foo (x:xs) = ([x] ++ [x] , [x] ++ foo xs)
04:00:00 <lambdabot>   Non-exhaustive patterns in function foo
04:00:02 <dcoutts_> byorgey: that's the system we use in Simple.Setup for the command line flag mappings
04:00:04 <byorgey> dcoutts_: and it's even worse, actually, because in this case we want to do update rather than set
04:00:26 <idnar> oh
04:00:40 <dcoutts_> byorgey: ah yes, in the command line stuff we use Monoid to do the update
04:00:58 <quicksilver> > 4 <$ "abcde"
04:00:58 <lambdabot>  [4,4,4,4,4]
04:01:01 <quicksilver> funky
04:01:02 <byorgey> dcoutts_: oh, I see
04:01:05 <dcoutts_> byorgey: rather than doing it directly in every setter function
04:01:16 <idnar> visof: no, that won't typecheck
04:01:23 <dcoutts_> byorgey: so update is done generically as get, mappend and set
04:01:36 <byorgey> dcoutts_: right
04:01:51 <visof> idnar how can i solve this?
04:01:52 <zerny> <$ works like a charm :)
04:02:04 <dozer> :t <$
04:02:05 <lambdabot> parse error on input `<$'
04:02:13 <dozer> @type <$
04:02:14 <lambdabot> parse error on input `<$'
04:02:18 <idnar> :t (<$)
04:02:19 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
04:02:48 <idnar> visof: if the result is going to be a tuple, then your [] case also needs to be a tuple
04:02:51 <jedbrown> bgr
04:03:02 <idnar> visof: I don't really understand what that function is trying to do, though
04:03:09 <byorgey> zerny: and if you wanted, you could make your own  ($>) = flip (<$) if you like the order e1 $> e2 better
04:03:52 * quicksilver fires off YA anti-hGetContents rant to the -cafe
04:03:53 <zerny> byorgey: that would make more sense as it resembles the correct order
04:04:15 <dcoutts_> nominolo: btw, you may be interested to know that I got a reply back from Sun about some collaboration to do a student project to get ghc on sparc working again
04:04:16 <byorgey> dcoutts_: I don't know if that Monoid approach would work here...?
04:04:24 <zerny> byorgey: I just don't know if the hole thing makes the code a lot less readable...
04:04:59 <dcoutts_> byorgey: probably, fields in a config file are rather like flags on a command line, but it'd mean a major reorganisation
04:05:02 <visof> idnar i did foo ([])  = " " and i have the same result
04:05:03 <visof> ?
04:05:14 <quicksilver> dcoutts_: ghc on 64-hyperthread T1s, yummy
04:05:26 <idnar> visof: no, I mean, you'd need to have something like: foo [] = (" ", " ")
04:05:34 <dcoutts_> quicksilver: exactly, though the low end ones are 24 threads, T2 goes up to 64
04:05:39 <visof> oh
04:05:39 <idnar> visof: but then [x] ++ foo xs still won't work
04:05:41 <visof> ok
04:05:59 <idnar> visof: because foo xs gives you a tuple, and you need a list for (++)
04:06:02 <dcoutts_> quicksilver: <$3,000 for a 6-core 4-thread-per-core, 2Gb T1 box
04:06:05 <idnar> visof: can you explain what foo is supposed to do as a whole?
04:06:31 <quicksilver> dcoutts_: yes, I'm currently running my real work on cheap-ass 2-core AMD sun boxes but we keep an eye on the T1s as an upgrade path :)
04:06:42 <quicksilver> dcoutts_: the longer we wait the cheaper they get, though.
04:07:01 <dcoutts_> quicksilver: :-) so clearly we need the sparc native backend working again
04:07:29 <visof> idnar it's determine all of the strings that can i generate form A and B as :
04:07:46 <dcoutts_> quicksilver: so I'm hoping we can get Sun to donate one and we get a student to make it work
04:08:03 <mux> dcoutts_: I can provide access to an UltraSPARC IIe box to anyone serious about getting this work done
04:08:20 <visof> foo ['A', 'B']  = ("AB" , "AA", "BA", "BB")
04:08:27 <mux> I don't have Niagara boxes though, I wish I did :)
04:08:34 <visof> idnar understand what i mean?
04:08:44 <idnar> visof: ["AB" , "AA", "BA", "BB"] perhaps?
04:08:45 <dcoutts_> mux: me too, I've got a UltraSparcIIe on my desk
04:08:49 * EvilTerran is thinking about "both :: (forall a. f a -> g a) -> (f b, f c) -> (g b, g c); both f (x,y) = (f x, f y)" again
04:08:49 <lambdabot> EvilTerran: You have 1 new message. '/msg lambdabot @messages' to read it.
04:08:51 <Zao> So the current sparc build is via-C?
04:08:55 <mux> dcoutts_: do you use it as your mouse pad as well? ;-)
04:09:00 <EvilTerran> and why "both concat" can't work
04:09:10 <Beelsebob> This is actually a place where I'd really like a nice abstraction... I have a lot of functions of type [a] -> (b,[a]), where the output list is shoved into a similar function, and the 'b's are combined in some way
04:09:36 <dcoutts_> mux: actually, I run gentoo linux on it as my office desktop
04:09:50 <dozer> Beelsebob: that sounds like "StateT []" or something very similar
04:10:04 <Beelsebob> dozer: 'state' certainly doesn't describe it in any way
04:10:11 <jedbrown> dcoutts_: It really costs peanuts to them to donate one, but if GHC can generate good parallel code, it might help them sell more boxes.
04:10:12 <EvilTerran> @seen glguy
04:10:12 <lambdabot> glguy is in #haskell and #ghc. I last heard glguy speak 7h 48m 2s ago.
04:10:13 <dcoutts_> mux: but much more interesting is to get some good multi-core benchmarks from a T1 donated box
04:10:13 <Beelsebob> there's deffinatly nothing stateful going on
04:10:24 <dcoutts_> jedbrown: exactly
04:10:26 <mux> dcoutts_: *nods*
04:10:46 <dozer> Beelsebob: where do the values of b come from? calculated from the a?
04:10:47 <Beelsebob> the classic example would be a na√Øve implementation of a parser dozer replace a with Token, and b with CST
04:10:48 <mux> dcoutts_: Sun has been nice enough to donate the FreeBSD project one or two of those, so maybe they'll be nice enough to donate one for Haskell
04:10:53 <doserj> > replicateM =<< length $ "AB"
04:10:54 <lambdabot>  ["AA","AB","BA","BB"]
04:10:55 <Beelsebob> dozer: from a number of as, yes
04:11:07 <dcoutts_> mux: I'm hoping so, they have one to gentoo too
04:11:13 <dcoutts_> have/gave
04:11:27 <lispy> ya know how with partial application you can have f :: a -> b -> c, and do (f a) :: b -> c, ((f a) b) :: c.  Is there a way to do this like, data Box a b where Box :: (a -> b) -> Box a b, so that you can do (Box (Box f)) :: Box (Box a b) c  ??
04:11:37 <dcoutts_> mux: could make quite a nice community server too :-)
04:11:44 <dcoutts_> great for parallel builds
04:12:05 <nominolo> dcoutts_: nice
04:12:16 <dozer> Beelsebob: and the new [a] is computed from the old one?
04:12:49 <Beelsebob> dozer: yes, so in the parser example the new [a] would be the remaining unparsed section, while the b would be the syntax tree for the section parsed
04:13:00 <dcoutts_> nominolo: I was thinking perhaps if it works out we could get it done for a SoC project, or a MS internship
04:13:15 <dcoutts_> nominolo: and I was wondering if you might be at all interested
04:13:22 <nominolo> dcoutts_: sure!
04:13:23 <dozer> Beelsebob: right, so that sounds like the computation is stateful in [a] and has results of type b
04:13:26 <quicksilver> lispy: data Box a b where Pure :: (a -> b) -> Box a b ; Compose :: (Box a b) -> (Box b c) -> Box a c ?
04:13:37 <Beelsebob> dozer: I don't see how this is stateful at all
04:13:43 <Beelsebob> unless you view a program as a list of states
04:13:48 <Beelsebob> which makes no sense to me at all
04:13:51 <lispy> quicksilver: Compose is questionable to me
04:13:55 <nominolo> dcoutts_: i thought you were thinking about an oxford student
04:13:57 <quicksilver> lispy: well I had to choose a name for it
04:14:03 <lispy> quicksilver: I want to take things for higher arity and box them up
04:14:03 <quicksilver> lispy: what you wrote didn't type check :P
04:14:04 <idnar> Beelsebob: the state is the list of unparsed tokens at each step, I guess
04:14:11 <dcoutts_> nominolo: no, under the haskell.org umbrella, not oxford
04:14:19 <lispy> quicksilver: but you want me to compose them
04:14:20 <idnar> er, unparsed whatever
04:14:21 <dozer> idnar: right
04:14:35 <idnar> isn't that more like the writer monad or something, though?
04:14:39 <quicksilver> lispy: it was a kind of boxing. Maybe not the kind you meant.
04:14:45 <idnar> hmm, no
04:14:52 <quicksilver> lispy: in Box (Box f), what is the type of f?
04:14:53 <dcoutts_> nominolo: as a partnership between sun and haskell.org, good press for sun helping open source etc
04:14:54 <idnar> wrong way around
04:14:54 <lispy>    Box :: (a -> b) -> Box a b
04:14:54 <lispy>    Box2 :: (a -> b -> c) -> Box (Box a b) c
04:15:06 <Beelsebob> idnar: I wouldn't regard that as a state in any way... in that it's merely an artifact of the order in which you happen to parse -- that "state" can be constructed by parsing the front of the token stream in all cases
04:15:11 <lispy> quicksilver: that's what i want, but i want to be able to define it recursively instead of needing Box2, Box3, etc
04:15:14 <nominolo> dcoutts_: now that they bought MySQL :)
04:15:18 <quicksilver> lispy: that doesn't look right to me
04:15:29 <quicksilver> lispy: looks like you're confusing a -> b -> c and (a -> b) -> c
04:15:33 <nominolo> dcoutts_: i think it'd be nice for both sides
04:15:48 <EvilTerran> "<Beelsebob> This is actually a place where I'd really like a nice abstraction... I have a lot of functions of type [a] -> (b,[a]), where the output list is shoved into a similar function, and the 'b's are combined in some way" <- looks like Writer to me
04:16:01 <idnar> EvilTerran: [a] is shrinking, not growing
04:16:11 <EvilTerran> i mean "the 'b's are combined in some way"
04:16:13 <Beelsebob> idd
04:16:14 <dcoutts_> nominolo: http://www.sun.com/servers/coolthreads/t1000/get_it.jsp
04:16:14 <quicksilver> that's the Supply monad
04:16:15 <lambdabot> Title: Sun Fire T1000 Server - Get It
04:16:16 <Beelsebob> ah, I see
04:16:25 <quicksilver> Beelsebob, EvilTerran : that looks like the Supply monad
04:16:29 <quicksilver> IIUC
04:16:37 <quicksilver> it can be modelled as State [a]
04:16:42 <lispy> quicksilver: I know that Box (Box f), has the arrows in the normal way and my Box2 reverses them
04:16:51 <quicksilver> bu the constraint is that you treat the [a] as a 'pop-only stack'
04:16:55 <Beelsebob> quicksilver: interesting, I'll look that up...
04:16:57 <quicksilver> i.e. just a stream of supplied values
04:17:02 <idnar> http://www.haskell.org/haskellwiki/New_monads/MonadSupply -- that one?
04:17:04 <lambdabot> Title: New monads/MonadSupply - HaskellWiki
04:17:16 <EvilTerran> is the [a] is always shrinking, yeah, it's something like WriterT b (Supply a)
04:17:17 <quicksilver> yes
04:17:19 <lispy> quicksilver: I was just hopping to find a way to combine the constructors so that I can apply them recursively
04:17:22 <Beelsebob> the reason I don't like saying it's "State" is that it's conceptually not stateful
04:17:28 <nominolo> dcoutts_: i know it's an awesome machine ;)  i'd be eager to work with it
04:17:32 <Beelsebob> but supply sounds like it fits the concept much better
04:17:34 <lispy> quicksilver: and not have any arrows in the end
04:18:06 <lispy> quicksilver: so i was hoping for something that maybe gives Box (Box f) :: Box a (Box b c)
04:18:07 <quicksilver> lispy: but surely it woudl be Box a (Box b c)
04:18:17 <quicksilver> not Box (Box a b) x
04:18:20 <quicksilver> not Box (Box a b) c
04:18:22 <dcoutts_> nominolo: so a low end one is not that expensive for sun to donate, I'd aim for a 6 core, one with 8Gb memory, that gives more reasonable memory per thread
04:18:22 <quicksilver> ;)
04:18:22 <EvilTerran> I was thinking of having your functions as being [a] -> Writer b [a] explicitly, but Supply could well be better abstracted
04:18:45 <dcoutts_> > 8 * 1024 / 24
04:18:46 <lambdabot>  341.3333333333333
04:19:15 <dcoutts_> rather than just 85M per thread
04:19:32 <quicksilver> EvilTerran, Beelsebob : see also example of supply use at http://www.haskell.org/haskellwiki/FoldableAndTraversable
04:19:32 <lambdabot> Title: FoldableAndTraversable - HaskellWiki
04:19:32 <nominolo> dcoutts_: do you know the cashes?
04:19:41 <nominolo> *cache sizes
04:19:43 <quicksilver> in the definition of zipwithTM
04:20:09 <dcoutts_> nominolo: 16 KB instruction, 8 KB primary data cache, 3 MB integrated L2
04:20:27 <Beelsebob> cheers quicksilver
04:20:32 <nominolo> per cpu + L2 shared, i presume
04:20:57 <dcoutts_> nominolo: yes
04:21:23 <dcoutts_> nominolo: per core, and there are 4 threads sharing each core
04:21:30 <dcoutts_> nominolo: http://www.sun.com/processors/UltraSPARC-T1/specs.xml
04:21:40 <dozer> Gha! darcs hashed format seems to have made a pigs ear of this merger
04:22:51 <nominolo> dcoutts_: ok.  so what would be the stated goal of this project?  get the ghc backend+runtime to work.  what else?
04:23:40 <dcoutts_> nominolo: the native code gen, and then demo some ghc SMP scaling results, basically the same tests JaffaCake did on their multi-core amd64 box
04:23:54 <nominolo> ok
04:23:59 <nominolo> yes, sounds good to me
04:24:37 <dcoutts_> nominolo: then we keep the box and use it as a community & hackage build server :-)
04:24:56 <nominolo> sure, if sun doesn't mind ...
04:25:06 <dcoutts_> and let anyone who wants to do sparc perf or compatibility tests use it
04:25:20 <dcoutts_> nominolo: they've donated boxes permanently to other open source projects
04:25:23 <nominolo> i wonder if there are any phd positions to work with Sun on Fortress
04:25:27 <lispy> quicksilver: what i want is a wrapper type that can hold the place of a function's parameter while storing, and preferable is combinable with itself so that it works on any kind via recursive applications
04:25:31 <dcoutts_> nominolo: I'm sure there are
04:25:42 <lispy> while storing the type*
04:26:03 <lispy> works on any kind should have been any arity...
04:26:08 <dcoutts_> nominolo: we keep getting emails from sun about things like that, or phd students to try new high performance VM ideas etc etc
04:26:11 <lispy> i shouldn't be at the keyboard :)
04:26:15 <nominolo> dcoutts_: that seems something i could have fun in doing for long enough time
04:26:27 <dcoutts_> nominolo: aye
04:26:49 <nominolo> i guess i'll just try and send Guy an e-mail :)
04:27:40 <nominolo> though, what scares me a little, is that their current fortress interpreter is written in Java
04:28:14 <nominolo> OTOH, the problems are difficult to solve in any language
04:28:31 <byorgey> wow, the social network graph is craaaaazy this morning =)
04:28:57 <opqdonut> where is it?
04:29:12 <byorgey> opqdonut: it's in the topic
04:29:13 <nominolo> byorgey: can you post the link again?  i accidentally edited my topic line
04:29:27 <byorgey> http://tinyurl.com/ytzeab
04:29:29 <opqdonut> oh, nice
04:29:31 <lispy> http://files.codersbase.com/haskell/haskell-current.png
04:29:48 <nominolo> niice
04:29:58 <lispy> I also did one that is a snap shot of the 27th with no decay: http://files.codersbase.com/haskell-logs/haskell-current.png
04:30:03 <nominolo> big, integrated community we have here
04:30:34 <byorgey> nominolo: indeed =)
04:30:47 <byorgey> lispy++
04:32:42 <scook0> @hoogle runReaderT
04:32:45 <lambdabot> Control.Monad.Reader.runReaderT :: ReaderT r m a -> r -> m a
04:32:51 <jedbrown> lispy: heh, it's easy to find my topology discussion with roconnor.
04:33:59 <lispy> heh yeah
04:34:44 <shag> how do i match a list with exactly one element (sorry for the dump question...)?
04:34:55 <shag> dumb, even
04:34:56 <quicksilver> [x] ?
04:35:06 <lispy> x:[]
04:35:14 <ToRA> > let f [x] = "hi" in f [2]
04:35:14 <shag> really? dosnt it have to be something like x:[]?
04:35:16 <lambdabot>  "hi"
04:35:22 <ToRA> > let f x:[] = "hi" in f [2]
04:35:22 <lambdabot>  Parse error in pattern at "in" (column 19)
04:35:27 <ToRA> > let f (x:[]) = "hi" in f [2]
04:35:28 <lambdabot>  "hi"
04:35:45 <shag> okay ... :)
04:35:56 <quicksilver> shag: magic list syntax is, well, magic
04:36:01 <quicksilver> shag: it works in patterns too :)
04:36:19 <quicksilver> shag: it's like a single special case of quasiquoting
04:36:33 <quicksilver> [x,y,z] is equivalent to x:y:z:[] even on the LHS of a pattern
04:37:36 <byorgey> lispy: so it seems you can use this PieSpy thingy to make animations too?
04:37:46 <byorgey> hint hint ;)
04:37:47 <quicksilver> I don't beliecve it's builtin
04:37:58 <quicksilver> but you can use a tool to make an animation out of a bunch of pngs
04:38:02 <byorgey> oh, I see
04:38:19 <lispy> plus, the nodes can jump pretty drastically between frames
04:38:34 <lispy> and a frame is created everytime someones says something
04:38:35 <quicksilver> lispy: what information does a Box a (Box b c) hold, then?
04:38:44 <quicksilver> lispy: does it actaully contain a function a -> (b -> c)
04:38:45 <quicksilver> or not?
04:38:46 <lispy> quicksilver: just the types of the arguments
04:38:56 <quicksilver> it contains no information at all?
04:39:01 <lispy> Oh, right i forgot to hold the function, but I just put it back in later
04:39:08 <quicksilver> ok, then whats' wrong with data Box a b = Box a b ?
04:39:14 <quicksilver> if you don't have any information :)
04:39:23 <quicksilver> or, for that matter data Box a b = Box
04:39:45 <lispy> are you trying to miss the point?
04:39:46 <lispy> :)
04:39:48 <quicksilver> no
04:39:53 <quicksilver> I'm trying to understand the point
04:40:06 <quicksilver> if it has the function, how is it different from just using the function type?
04:40:16 <lispy> it will hold the functions once the types work out...that's orthognal to actually getting the mechanics working
04:40:18 <quicksilver> if it doesn't have the funciton, how is it different from a totally phantom type
04:40:54 <quicksilver> what can you do with a Box a (Box b c) that you couldn't do with just a -> (b -> c) ?
04:41:09 <lispy> suppose you had composite :: [a -> a] -> a, right?
04:41:15 <quicksilver> right
04:41:29 <quicksilver> a.k.a foldr (.)
04:41:51 <lispy> right, so now hang on while i type the type of a new type of list (type type type)
04:42:30 <lispy> data FL a x z where (:>:) :: a x y -> FL a y z -> FL a x z
04:42:36 <lispy> NilFL :: FL a x x
04:42:54 <lispy> Now, that's a list where the types of adjacent elements have to match up
04:42:59 <lispy> just like in function application
04:43:21 <quicksilver> if adjacent elements match up then all elements match up
04:43:27 <quicksilver> I don't think that's quite what you mean? :)
04:43:33 <byorgey> wow, three different meanings of 'type', all in one sentence!
04:43:34 <lispy> so now, instead of [a -> a] -> a, you could have x -> [FL a x y] -> y
04:43:50 * byorgey gives lispy the typeful typer type award
04:44:13 <quicksilver> I think that's just a list which remembers the types of its 'ends'
04:44:19 <lispy> quicksilver: so you could have an elements [a -> b, b -> c, c -> d], and the FL would have (the last two types) a d
04:44:23 * quicksilver nods
04:44:35 <quicksilver> OK, it's a list which respects 'domino composition'
04:44:41 <quicksilver> like matrix multiplication
04:44:41 <lispy> sure
04:44:45 <quicksilver> or, indeed, function composition
04:44:46 <lispy> or darcs patches
04:44:49 <quicksilver> yes
04:44:54 <lispy> which is what i use it for
04:45:03 <quicksilver> I might have guessed :)
04:45:12 <lispy> but, i had this idea that if i could box up (->) then I could also do domino composition
04:45:28 <lispy> it's nearly 5am so mabye i'm just brain dead
04:46:03 <lispy> FL (->) a b
04:46:06 <lispy> what would that holD?
04:46:25 <lispy> I mean, is that valid haskell?
04:46:29 <quicksilver> yes
04:46:32 <quicksilver> AFAIK it is
04:46:42 <quicksilver> that's what the arrow insance for
04:46:46 <lispy> if that's true, then FL may actually be complete already
04:46:46 <quicksilver> (->) look slike
04:46:55 <jedbrown> @remember quicksilver "Whatever you do, just don't use hGetContents."  Print this out onto a T-shirt transfer and apply it to the front of your monitor.
04:46:55 <lambdabot> Okay.
04:46:55 <quicksilver> I mean, you can write the arrow instance for (->) in valid haskell
04:47:03 <quicksilver> this is a related thing
04:47:07 <quicksilver> although this is data not class
04:47:33 <lispy> NilFL would have to be id
04:47:35 <lispy> somehow
04:48:00 <quicksilver> NilFL would be interpreted by id
04:48:07 <quicksilver> when you chose to interpret your FLs as functions
04:48:20 <quicksilver> interpret :: FL (->) a b -> (a -> b)
04:48:24 <lispy> yeah
04:48:27 <quicksilver> interpret NilFL = id
04:48:48 <quicksilver> interpret (f :>: ff) = f . (interpret ff)
04:49:15 <quicksilver> that's polymorphic recursion, or whatever they call it.
04:49:18 <quicksilver> it would be illegal in ML
04:49:23 <lispy> id :>: NilFL :: forall a. FL (->) a a
04:49:24 <quicksilver> lucky we're haskell programmers!
04:49:51 <lispy> these forward lists are more general than I realized
04:49:56 <lispy> thanks to putting (->) in a type
04:50:52 <lispy> now I will try (again) to sleep
04:50:56 <lispy> good night
04:52:06 <quicksilver> good night
04:52:08 <quicksilver> and good luck
05:05:10 <visof> @paste
05:05:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:05:33 <jedbrown> When slicing a multi-dimensional array, is (start,stride,end) for each dimension general enough, or should it take a list of indices?
05:06:00 <quicksilver> the most general slice woudl take a function on indices
05:06:09 <quicksilver> but start/stride/end is a very useful special case
05:06:19 <quicksilver> (and I can imagine circumstances in which it might be faster?)
05:07:01 <jedbrown> Well, the general case would be a list of indices, but then I can't do bounds checking without evaluating the whole list a-priori, or doing bounds checking in the inner loop.
05:07:20 <hpaste>  visof pasted "what is the problem?" at http://hpaste.org/5341
05:08:49 <jedbrown> This isn't a problem when the dimensions are, say 50^4, but would be when they are 2 x 100000.
05:09:46 <EvilTerran> visof, you have to indent the body of a do-block more than the line it starts on
05:10:04 <quicksilver> jedbrown: function on indices is a much nicer choice of general case, I think?
05:10:19 <hpaste>  EvilTerran annotated "what is the problem?" with "reformatted" at http://hpaste.org/5341#a1
05:10:22 <quicksilver> jedbrown: clearly function and list are isomorphic, but I'd rather design an API around the function.
05:10:53 <jedbrown> quicksilver: Are we talking about the same thing?
05:11:12 <EvilTerran> visof, also, you don't need to indent the body of a module after the "module Foo where" line
05:11:32 <EvilTerran> visof, modules're the one special case in that regard - most multi-line constructs require their bodies to be indented
05:11:49 * EvilTerran wracks his brain
05:12:02 <quicksilver> jedbrown: I think so.
05:12:17 <jedbrown> I'm talking about having one array and producing another one which is a regular subset of the original.
05:12:27 <quicksilver> jedbrown: you have an array with a set of indices I, you want to access it via indices in a different index set J.
05:12:40 <EvilTerran> grr... I'm trying to come up with a nice concrete representation of a context-free grammar and the associated parser, but it's remarkably fiddly
05:12:40 <quicksilver> jedbrown: you're talking about specifying the mapping via pairs (i,j) in I and J
05:12:41 <visof> EvilTerran thank you
05:12:46 <EvilTerran> :)
05:12:49 <jedbrown> Are you suggesting a function which takes the index into the new array and produces the index into the old array.
05:12:53 <quicksilver> jedbrown: I'm suggesting it's more elegant to specify it directly as a function J -> I
05:12:58 <quicksilver> jedbrown: exactly.
05:13:27 <quicksilver> (actually you were only specifying one half of the pair, an assumign the other pair via its ordering, but the idea is the same)
05:13:46 <jedbrown> Ah, okay.
05:14:06 <EvilTerran> abstract representations're fairly straightforward if you throw enough closures at the problem, but it seems difficult to do concretely without a lot of boilerplate
05:14:56 <jedbrown> Presumably your implementation would have an unsafe version for efficiency.
05:16:45 <roconnor> @src scanl
05:16:46 <lambdabot> scanl f q ls = q : case ls of
05:16:46 <lambdabot>     []   -> []
05:16:46 <lambdabot>     x:xs -> scanl f (f q x) xs
05:16:49 <roconnor> @src scanr
05:16:49 <lambdabot> scanr _ q0 []     =  [q0]
05:16:49 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
05:16:49 <lambdabot>     where qs@(q:_) = scanr f q0 xs
05:16:58 <quicksilver> jedbrown: probably, yes.
05:17:31 <quicksilver> jedbrown: you could optionally have a helper which tried every inbounds value of J and confirmed it produced an inbounds value of I.
05:17:57 <roconnor> @src unfold
05:17:58 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
05:18:00 <roconnor> @src unfoldr
05:18:01 <lambdabot> unfoldr f b  = case f b of
05:18:01 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
05:18:01 <lambdabot>    Nothing        -> []
05:20:22 <jedbrown> That is also nice for the multi-dimensional case since I don't have to explicitly deal with the dimensions, and it can even produce a result with different rank.
05:20:58 <jedbrown> I think the special case I mentioned is still useful though.
05:21:02 <resiak> hrm.  ./Setup.lhs haddock is choking because haddock needs to be run against the generated .hs, not the .chs source.  Is there a standard way to tell Cabal this?
05:22:55 <dcoutts_> resiak: cabal should pre-process everything before calling haddock
05:23:05 <quicksilver> jedbrown: yes, it's helpful for the cross-rank stuff
05:23:15 <quicksilver> jedbrown: which is quite hard to write a generic syntax for :)
05:23:18 <dcoutts_> resiak: and as far as I know, it does do that.
05:25:08 <resiak> oh, hmm, you're right
05:25:26 <resiak> the parse error message mentions the .chs file because of LINES directives I guess
05:26:32 <resiak> heh, if I remove all the LINES directives, the parse error goes away >_<
05:29:03 <hpaste>  resiak pasted "comment before module breaks haddock" at http://hpaste.org/5342
05:29:50 <Tobsan> how do i typecast an Int to a Double?
05:30:04 <resiak> > fromIntegral (3::Int) :: Double
05:30:07 <lambdabot>  3.0
05:30:20 <Tobsan> resiak: thanks :o
05:30:34 <quicksilver> Tobsan: fromIntegral and realToFrac are the two lossless cast operators you need
05:30:34 <idnar> > fromIntegral 3
05:30:35 <lambdabot>  3
05:30:37 <quicksilver> as a rule
05:30:39 <idnar> heh
05:30:42 <mauke> it's not a typecast, it's a conversion
05:30:54 <Tobsan> well yes
05:30:56 <idnar> :t fromIntegral
05:30:57 <lambdabot> forall a b. (Num b, Integral a) => a -> b
05:30:59 <Tobsan> that's what i needed :)
05:31:02 <quicksilver> Tobsan: there are lossy ones for the other way (round, floor, ceiling)
05:31:02 <idnar> oh, yes, right
05:31:12 <Tobsan> quicksilver: ah
05:31:21 <quicksilver> actualy realToFrac isn't guaranteed lossless, I gues.
05:31:27 <quicksilver> but it certainly can be.
05:31:37 <mauke> > realToFrac 1
05:31:38 <lambdabot>  1.0
05:31:51 <mauke> > realToFrac (0/0) :: Rational
05:31:52 <lambdabot>  (-26965397022934738615939577861835371004269654684134598591014512173659901370...
05:31:56 <quicksilver> mauke: on what grounds would you say that is not a typecast?
05:32:11 <jedbrown> quicksilver, is this the type sig you have in mind?  genSliceWithInd :: (Ix i, Ix i', IArray CArray e, IArray CArray e') => (i',i') -> (i' -> i) -> (i -> e -> e') -> CArray i e -> CArray i' e'
05:32:46 <scook0> quicksilver: perhaps because it's closer to a coercion than a cast?
05:32:50 <mauke> quicksilver: because "typecast" implies to me "same value just with a different type"
05:33:01 <mauke> this includes reinterpretation of bits
05:33:07 <quicksilver> mauke: and "fromIntegeral 1" is still the same value
05:33:11 <quicksilver> in my mind :)
05:33:22 <jedbrown> quicksilver: Or maybe with (i -> e -> i' -> e')  ?
05:33:24 <quicksilver> to most people 'typecast' means '(double)' from C
05:33:28 <quicksilver> and that is the same.
05:33:47 <mauke> or *(double *)&
05:33:53 <scook0> but C confuses coercion and reinterpretation
05:34:03 <quicksilver> jedbrown: yes, although I wasn't thinking of changing the elements at the same time
05:34:14 <quicksilver> jedbrown: I'd normally do that in a separate logical step. But yes, otherwise.
05:34:17 <idnar> mauke: if you say "cast to double", you generally do not mean *(double *)&
05:34:30 <jedbrown> quicksilver: May as well allow it all at once.
05:34:35 <quicksilver> scook0: of course it does. But C is the domain which in 'typecast' is most often used.
05:34:35 <mauke> (Double)(Object)(new Integer(1))
05:34:57 <zooko> Good morning (Mountain Time, North America)!
05:35:03 <quicksilver> scook0: so therefore it seems appropriate to use the usage there as the basis for a definiton
05:35:05 <jedbrown> quicksilver: Is this at least a sensible choice of order in terms of partial evaluation?
05:35:12 <quicksilver> and int a = 1; double b = (double) a; is a typecast.
05:35:14 <quicksilver> IMO.
05:35:21 <scook0> yeah, I'm more arguing that usage should change to reflect distinct concepts
05:35:25 <mauke> yes
05:35:36 <scook0> *because* the currant usage conflates two separate concepts
05:35:40 <quicksilver> true
05:35:43 <mauke> on the other hand, b = a; would just work in C
05:35:55 <quicksilver> but that's not necessarily a useful guideline when answering questions posed in IRC :)
05:36:04 <zooko> Took 96 minutes to build ghc 6.8.2 including extras.
05:37:06 <moonlite> i never understood what scanr does really... until now.
05:37:20 <scook0> incidentally, I think that in Java, all object casts are (safe) reinterpretations, whereas all primitive casts are coercions
05:37:21 <moonlite> putStr $ unlines $ reverse $ scanr (:) [] ['a'..'z'] -- a pretty good example :)
05:38:32 <idnar> scook0: where "safe" means "doesn't segfault"?
05:39:17 <idnar> also, I wouldn't call them reinterpretations
05:39:24 <scook0> idnar: more or less ... I'm distinguishing polymorphic reinterpretation from bit-level reinterpretation
05:39:26 <jedbrown> zooko: Nice.  Do you have cabal-install yet?
05:39:45 <idnar> you can't do that kind of cast to a type that isn't on the line of ancestry between Object and the actual type of the object
05:40:00 <idnar> but ok, I guess you can call that "polymorphic reinterpretation"
05:40:15 <scook0> or perhaps we should call it "type cast" ;)
05:40:21 <idnar> hee hee
05:41:07 <quicksilver> idnar: there was a buggy reinpretation in java to do with the array contravariance problem
05:41:19 <quicksilver> idnar: I think they fixed it but it persisted for a surprisingly long time :)
05:44:37 <zooko> jedbrown: I tried "cabal-install" on my bash cmdline and it said "command not found".
05:45:11 <scook0> zooko: it's "cabal install"
05:45:20 <scook0> i.e. the executable is cabal
05:45:46 <scook0> (though the package name is cabal-install)
05:46:04 <zooko> bash: cabal: command not found
05:46:14 <jedbrown> zooko: darcs get http://darcs.haskell.org/cabal-install
05:46:15 <lambdabot> Title: Index of /cabal-install
05:46:34 <zooko> What's the easiest way to run a few regression tests of GHC itself, to assure myself that I didn't mis-compile it or get a buggy version?
05:46:42 <zooko> I ran "make test" to no avail.
05:46:56 <jedbrown> zooko: (I think it's worth being bleeding edge on this package, because it will make hackage really nice.)
05:47:42 <jedbrown> zooko: http://hackage.haskell.org/trac/ghc/wiki/Building/RunningNoFib
05:47:43 <lambdabot> Title: Building/RunningNoFib - GHC - Trac
05:48:07 <zooko> What's the relation between cabal and Hackage?
05:48:44 <jedbrown> zooko: Cabal is a library for building packages.  It comes with GHC, and is used by the Setup.lhs file.
05:49:30 <jedbrown> zooko: Hackage is a database for packages.  It has the latest released version of pretty much all haskell packages, much like CPAN for perl.
05:50:11 <jedbrown> zooko: cabal-install is one such package which provides the `cabal' executable.  This makes installing hackage packages as easy as `cabal install package-name'.
05:53:00 <zooko> jedbrown: excellent.  Thanks!
05:54:39 <zooko> What does the GHC download mean when it says that the Windows x86 standalone GHC also includes support for compiling C++ files?
05:54:55 <mauke> maybe it comes with mingw?
05:55:37 <roconnor> is there a debian package for cabal for GHC 6.8?
05:56:17 <zooko> mauke: I'm intending to find out what happens when I try to build ghc 6.8.2 with cygwin's gcc.
05:56:34 <jedbrown> roconnor: Cabal or cabal-install?
05:56:54 <zooko> So can someone tell me how to run the ghc regression tests?
05:57:14 <jedbrown> roconnor: It's probably worth using the darcs version of cabal-install until the next release.
05:57:35 <jedbrown> zooko: ^^^ look at that page about running nofib.
05:57:35 <zooko> jedbrown: having darcs gotten cabal-install, now how do I build and install it?
05:57:41 <zooko> jedbrown: thanks
05:58:58 <jedbrown> zooko: move into the directory and: runhaskell Setup.lhs configure, runhaskell Setup.lhs build, runhaskell Setup.lhs install
05:59:36 <jedbrown> zooko: You may want to specify a prefix.  Use --help for more info.
06:00:16 <zooko> Setup.lhs: At least the following dependencies are missing:
06:00:17 <zooko>     Cabal >=1.3.3, zlib >=0.3, HTTP >=3000.0&&<3001.1
06:00:22 <zooko> How do I resolve dependencies?
06:00:52 <zooko> In Python world, dependencies can be resolved automatically if they were also packaged with the install tool.  :-)
06:01:15 <roconnor> jedbrown: nevermind I was being dumb.  Cabal comes with ghc.
06:01:17 <jedbrown> zooko: Oh, I forgot about those.  Get them from hackage.haskell.org.
06:01:17 <zooko> Looks like I'll have to install a binary Cabal to bootstrap?
06:01:31 <zooko> Get them by downloading a source tarball over HTTP?
06:01:53 <jedbrown> zooko: You are installing the package tool.
06:02:04 <roconnor> where is QuickCheck 2.0?
06:02:08 <zooko> jedbrown: I realize that.
06:02:27 <zooko> Oh, I see, you're pointing out that I can't expect automatic resolution of dependencies in this case.  Good point.
06:02:38 <jedbrown> zooko: It's not (yet) bundled with GHC.  It's still very new.
06:03:02 <zooko> FWIW, the Python package tool automatically downloads and installs a binary of itself when needed.
06:03:11 <zooko> Convenient, but a bit too magical for the taste of many people...
06:03:17 <jedbrown> roconnor: It's the new QC.  No release yet.  It makes it possible to do things like:
06:03:42 <jedbrown> @check ((\f x -> f x == f x) :: (Double -> Int) -> Double -> Bool)
06:03:45 <lambdabot>  Exception: Prelude.(!!): negative index
06:04:11 <jedbrown> roconnor: Actually, this is just a bug in QC-1 ;)
06:04:29 <jedbrown> roconnor: But it separates Arbitrary from CoArbitrary, which is a good thing.
06:06:59 <jedbrown> zooko: cabal-install only really became usable a few months ago.  It's being developed quite actively and will hopefully come with GHC soon (or at least have binaries for everyone's platform).
06:07:27 <nominolo> zooko: you need cabal from darcs, too
06:07:44 <nominolo> zooko: and you need to manually install HTTP and zlib
06:08:23 <nominolo> zooko: the plan is to have cabal-install be distributed with HTTP and zlib (and possibly a new cabal), once it's released
06:08:47 <nominolo> zooko: so, if you can wait a few more weeks, it'll all work automagically
06:12:10 <czakey> @seen oscarM
06:12:10 <lambdabot> I haven't seen oscarM.
06:12:21 <roconnor> is there an Agda application?
06:15:43 <ehird> no
06:15:50 <ehird> there are no adga applications whatsoever
06:15:57 <ehird> :)
06:17:15 <roconnor> Ah, found it
06:25:19 <zooko> Hm.  "unknown package: unix"
06:26:29 <zooko> So where does ghc look for packages which are specified as "-package PACKAGENAME" on the ghc command-line?
06:27:34 <doserj> "ghc-pkg list" will show you all installed packages
06:28:23 <zooko> doserj: thanks
06:28:31 <mux> anyone using safari?
06:28:54 <mux> neverind
06:29:12 <zooko> Does anyone know if there is a "unix" package that works on cygwin?
06:30:51 <zooko> I doubt it.  So I'm going to see if I can tell it to proceed without the "unix" package.
06:30:55 <bringert> why does Hoogle "Data.Array" (http://www.haskell.org/hoogle/?q=Data.Array) not give a link to the docs for that module?
06:30:57 <lambdabot> Title: Data.Array - Hoogle
06:31:10 <zooko> There was no mention of "unix" in the configure output, so I wonder where it got the idea that it needed "unix".
06:31:48 <sizur> bringert, i think the haskell report talks in depth about Array
06:31:57 <quicksilver> bringert: cos that's not what hoogle does, I guess.
06:32:09 <doserj> bringert: you get a link if you search for "Array", though...
06:32:16 <bringert> sizur: I know where to find the docs, it was a question about whether hoogle should find it
06:32:50 <bringert> doserj: interesting. perhaps it can't handle dots in module names
06:32:52 <doserj> bringert: hoogle doesn't work on modules, but on types and functions
06:33:10 <bringert> doserj: well, as you said it finds the Array module
06:33:30 <doserj> indeed
06:33:58 <bringert> so it seems like it does work on modules, you just can't search for hierarchical module names
06:34:06 <bringert> now where's neil when you need hom
06:34:09 <bringert> him
06:37:27 <zooko> Hm.  There is a libraries/unix here.  I wonder if I have to build it manually.
06:37:42 <zooko> I would expect './configure && make' to build it if needed.
06:39:09 <bringert> zooko: what do you ned the unix package for?
06:39:23 <bringert> zooko: you may be able to get away with the unix-compat package
06:39:46 <zooko> bringert: I'm trying to compile ghc, and the compilation stops because of the absence of unix.
06:39:55 <bringert> ah
06:39:57 <zooko> So one plausible solution is change the configuration so that it doesn't require that package to build.
06:40:04 <zooko> But I haven't figured out how to do that, either.
06:40:09 <sieni> bringert: well, then install unix :-)
06:40:24 <sieni> s/bringert/zooko/
06:40:27 <bringert> you probably need to convince configure that you are on windows
06:40:40 <zooko> I actually *am* running on a unix, but it is a fringe unix that suffers from platform bigotry.  :-(
06:40:49 <zooko> bringert: no, I want to convince it that I am on unix.
06:40:59 <bringert> Cygwin is not unix
06:41:05 <zooko> Sure it is.
06:41:18 <zooko> At least, inasmuch as ghc needs unix to build, cygwin provides that.
06:41:27 <bringert> ghc doesn't need unix to build
06:41:35 <EvilTerran> um, i don't think it does need unix to build...
06:41:37 <bringert> it builds under windows, af far as I understand
06:41:43 <EvilTerran> seeing as i have a native windows binary right here
06:41:56 <zooko> Okay, so I'm attempting in parallel two different ways to get it to build, 1. tell it to please proceed even though it can't find the "unix" package, or 2. build the unix package on my platform.
06:42:20 <bringert> I doubt that either of these are easy
06:42:32 <bringert> zooko: why do you want to build ghc under cygwin?
06:42:34 <zooko> Do you know how it decided to include the "unix" package in the list of packages for the
06:42:59 <zooko> big ghc command-line.
06:43:04 <EvilTerran> @quote pcrs
06:43:04 <lambdabot> pcrs says: Premature carriage ret
06:43:18 <bringert> zooko: it probably wants the unix package because it believes that you are compiling under Unix
06:43:22 <bringert> zooko: see http://hackage.haskell.org/trac/ghc/wiki/Building/Windows
06:43:23 <lambdabot> Title: Building/Windows - GHC - Trac
06:43:29 <zooko> bringert: because I like cygwin, and I would like to be able to build Haskell programs for cygwin, and help others to do so.
06:43:33 <zooko> bringert: thanks,.
06:43:37 <bringert> ah ok
06:43:46 <bringert> you are porting it then
06:43:54 <zooko> I have read that page before.
06:44:28 <zooko> bringert: yes, I am seeing what it takes to port ghc-6.8.2 to cygwin.
06:44:41 <bringert> zooko: ask in #ghc
06:44:56 <bringert> zooko: porting ghc counts as ghc development
06:45:11 <earthy> the mingw ghc-6.8.2 works fine in a cygwin env...
06:45:22 <zooko> bringert: thanks!
06:45:34 <zooko> earthy: I know, but I'm interested in a cygwin ghc.
06:45:48 <earthy> ah.hm.
06:45:51 <earthy> tough. :)
06:46:31 <zooko> Thanks, folks!  I'll be back.
06:53:21 <gbacon> ?go scrap your boilerplate
06:53:23 <lambdabot> http://www.cs.vu.nl/boilerplate/
06:53:23 <lambdabot> Title: Scrap your boilerplate ... in Haskell
06:57:36 <mattam> shapr: bah, I'm leaving boston today, I would have loved to see some haskellers around here :(
06:59:00 <BMeph69>  ?go hoogle something
07:12:52 <vegai> argh, I hate Debian
07:17:02 <ehird> so what's the haskeller's choice for an easy-to-use gui toolkit? most gui toolkits are hideously complex
07:17:11 <ehird> [gtk not being an option, for OS Xness]
07:17:55 <BMeph69> I haven't heard of anyone trying a Flex binding - that could be fun... ;p
07:18:14 <pejo> ehird, I kind of doubt you'll find a simple gui toolkit that spans 3 platforms.
07:18:38 <pejo> ehird, OSX has an x-server though, and someone was working on a native port of gtk iirc. dcoutts surely knows more.
07:18:47 <ehird> pejo: well, I don't give a damn about windows. does that help?
07:18:55 <ehird> pejo: also, I'm aware of the gtk situation. it's not acceptable.
07:19:20 <ehird> the UI conventions and semantics are wildly different -- and not even a theme can change that (and indeed a theme acn't make it look native either)
07:19:31 <ehird> the native gtk is just to Quartz. it's highly unstable and suffers from the same problem.
07:21:03 <vegai> I think I saw a haskell qt lib recently
07:21:14 <ehird> wxhaskell seems ok
07:21:17 <ehird> but is it actively maintained?
07:21:25 <ehird> also, is it as simple as it looks? ;)
07:22:36 <vegai> http://qthaskell.sourceforge.net/
07:22:42 <lambdabot> Title: qtHaskell
07:22:46 <vegai> "This is the first preview release of qtHaskell." meh
07:23:39 <matthew_-> if you're using Haskell, you really ought to be of the opinion that GUIs are both unnecessary and undesireable
07:23:43 <ehird> full of docs isee.
07:23:51 <ehird> matthew_-: hardcore man!
07:23:53 <radix> matthew-_: yeah, obviously the web is the way to go
07:24:06 <ehird> radix: lynx only
07:24:10 <byorgey> no, text interfaces!  in morse code!
07:24:16 <radix> ehird: what, isn't there a haskell text-mode browser? :)
07:24:18 <ehird> guis are both unnecessary and undesirable, remember!
07:24:24 <matthew_-> radix: yeah, from a commercial pov, a web browser is a damn cheap and fast gui
07:24:40 <matthew_-> otoh, I am a command line fan
07:24:42 <ehird> matthew_-: Quite the idaelist.
07:24:45 <ehird> *idealist
07:24:52 <mauke> oh, that reminds me
07:24:56 <mauke> I want STFS
07:25:07 <ehird> You know I hate people who use actual rich interfaces, why can't they type things ina line at a time and get lovely ascii art. grrrr!!!!
07:25:23 <mauke> software transactional file system
07:25:42 <matthew_-> oh right, yeah, just add transactions to the DMA controller, should be a piece of cake...
07:26:04 <quicksilver> ehird: if you are of the opinion that UI conventions and semantics are important
07:26:14 <mauke> as long as I don't have to use lock files anymore
07:26:16 <quicksilver> ehird: which you presumably are, if you think GTK/Mac is not acceptable.
07:26:32 <quicksilver> ehird: then you come to the conclusion that there is no such thing as a X-platform GUI.
07:26:49 <matthew_-> thus invent one yourself ;)
07:26:51 <quicksilver> ehird: it's not possible to paper over the conventional and semantic differences between platforms.
07:26:53 <radix> Being someone who doesn't really care about UI conventions, I can say that GTK/Mac is *still* unacceptable :)
07:27:04 <radix> it's really really annoying to use a gtk program on OS X
07:27:13 <radix> mostly because of the X11 thing.
07:27:20 <matthew_-> s/a gtk program on//
07:27:36 <radix> matthew-_: I'd remove one of the "really"s for the general case
07:27:48 <matthew_-> and replace it with a '+' ?
07:27:57 <sizur> radix, which one? the left or the right?
07:28:04 <radix> no matter how bad it is to use OS X in the first place, it's worse to use a GTK program on OS X :)
07:28:22 <ehird> quicksilver: mostly, an app designed well on a mac tends to be good on other platforms
07:28:27 <ehird> even before i used a mac i found this to be true
07:29:06 <sizur> anyways, for purists: why are you still on mac/win/*ix??? dont you want to go all the way haskell?
07:29:40 <ehird> sizur: there are places in the world for non-haskell things, i find ;)
07:29:47 <radix> does haskell give me wobbly windows?
07:30:08 <sizur> ehird, strangely, i came to the same conclusion ;)
07:30:12 <ehird> radix: ugh, please don't remind me of compiz/beryl
07:30:19 <ehird> makes me want to scream :)
07:31:09 <quicksilver> ehird: I think that just indicates that you enjoy the OSX conventions and semantics, and don't get upset on another platform when *their* semantics are discarded in favour of the mac one.
07:31:25 <quicksilver> ehird: which is perfectly fair, as an opinion, but important to be clear that's what you mean :)
07:32:18 <ehird> quicksilver: it's worth noting that on the other platforms the semantics are all over the place between apps anyway so there's not much standard to adhere to ;)
07:32:35 <ehird> though i find OS X-y apps generally fit in quite well with other OS'
07:32:37 <sizur> correction: between linux apps
07:32:38 <quicksilver> ehird: it's easy to say, and even amusing to say so.
07:32:49 <quicksilver> but actually I find windows to be much much more consistent than the mac
07:33:01 <quicksilver> (and I say this being someone who despises windwos with a burning passion)
07:33:03 <osfameron> do osx apps maximize properly when used on other windowing systems?
07:33:06 <ehird> quicksilver: if you use crap mac programs yeah
07:33:08 <quicksilver> but MS developers actually stick to their UI guidelines.
07:33:21 <matthew_-> RISC OS had quite a nice gui
07:33:21 <ehird> osfameron: uh, that makes no sense. OS X doesn't use x11. I'm talking about portable apps, but designed for a mac.
07:33:24 <quicksilver> whereas Apple invents a new UI concept for every new program they bring out.
07:33:25 <matthew_-> it was almost useable...
07:33:32 <quicksilver> quicktime: completely new UI
07:33:37 <ehird> and in that case: yes
07:33:38 <quicksilver> iTunes : completely new UI, several time.
07:33:46 <ehird> because they're designed for good resizing most of the time
07:33:48 <quicksilver> Mail.appl : completely new set of widgets
07:33:53 <ehird> quicksilver: agreed, a lot of apple-shipped products are a mess
07:33:57 <quicksilver> although now adopted by some other apps.
07:34:11 <quicksilver> despite all this mess, OSX manages to look nice
07:34:21 <osfameron> ehird: I want web browser or full document editor to be full screen when maximized.  osx doesn't.  fuck osx, it's my machine.
07:34:28 <quicksilver> but it's is definitely *despite* inconsistency, rather than because of consistency.
07:34:30 <osfameron> yeah, it does look pretty:-)
07:34:36 <ehird> osfameron: so use a different os
07:34:39 <quicksilver> Whereas windows manages to look ugly, despite being consistent :)
07:34:40 <ehird> also, you can do that.
07:35:01 <ehird> it's called having a window the size of the screen, and my irc client is doing that riight now
07:35:01 <osfameron> ehird: yeah I do.  But I sometimes have to put up with osx to support gf's laptop
07:35:33 <MyCatVerbs> This is why xmonad rules.
07:35:44 <sizur> MyCatVerbs, are you on it?
07:35:45 <roconnor> @bab nl en opvangen
07:35:45 <MyCatVerbs> Sure, my apps aren't quite fullscreen. But only because I installed dzen, too. ^_^
07:35:47 <lambdabot>   to catch
07:36:10 <MyCatVerbs> sizur: indeed. It's spiffy, though I've yet to go about getting it to drive dzen.
07:36:18 <sizur> i will stick with beryl candy
07:36:43 <ehird> but anyway
07:36:48 <ehird> i think the topic was gui toolkits? :P
07:36:56 <sizur> nothing better than cli terminal on beryl ;)
07:37:08 <ehird> sizur: i
07:37:13 <ehird> 've always wanted a wobbly terminal.
07:37:42 <matthew_-> I'm sorry, but xmonad does not rule. IMHO, xmonad is a cut down version of a Windows "Wizard", trying to tell me how I want my screen laid out.
07:37:52 <sizur> perfect marriage of the beauty and the beast
07:38:16 <ehird> matthew_-: it's a good thing you can configure it and manually control it then?
07:38:30 <MyCatVerbs> matthew_-: except that a Windows Wizard for laying screens out wouldn't give you a plugin system, nor the source code to configure it how you want.
07:38:41 <matthew_-> MyCatVerbs: yes, all fair points
07:38:54 <matthew_-> can you prevent windows in the current workspace from being visible without reverting to full screen?
07:39:01 <MyCatVerbs> matthew_-: nor would it configure on the fly using a bizarre collection of hotkeys.
07:39:20 <matthew_-> can you add windows to the current workspace without the workspace magically changing its layout?
07:39:32 <mauke> depends on the layout
07:39:38 <matthew_-> (not fullscreen)
07:39:44 <MyCatVerbs> No and no by default, but if you actually want either, find or write a layout plugin that does it.
07:39:59 <matthew_-> yeah, I just can't be arsed to rewrite ratpoison in haskell
07:40:08 <byorgey> @remember quicksilver Lazy IO gremlins bite once again.
07:40:09 <lambdabot> I will remember.
07:40:11 <MyCatVerbs> And what's with the assumption that switching workspaces is a hassle?
07:40:32 <matthew_-> I'm quite comfortable with 9 workspaces in ratpoison thank you
07:40:38 <matthew_-> 30 odd xterms tend to be enough
07:40:53 * MyCatVerbs blinks.
07:40:58 <byorgey> hehe
07:41:04 <matthew_-> (I don't close windows)
07:41:09 <elias`> 1 urxvt is enough with screen :)
07:41:14 <don_montana> jel ima neki balkanac ovdje
07:41:33 <matthew_-> also, I don't use bookmarks in firefox - I just keep about 40 tabs open all the time. Turns out firefox has some memory issue ;P
07:42:12 <MyCatVerbs> matthew_-: I can't do either well myself.
07:42:25 <sizur> mathrick, 40 tabs? i have to keep 3-4 windows open for 10 tabs in each
07:42:26 <quicksilver> byorgey: that single thread appers to have provided most of my quotes now :)
07:42:30 <quicksilver> @quote quicksilver
07:42:30 <lambdabot> quicksilver says: "Whatever you do, just don't use hGetContents."  Print this out onto a T-shirt transfer and apply it to the front of your monitor.
07:42:34 <quicksilver> @quote quicksilver
07:42:34 <lambdabot> quicksilver says: Lazy IO gremlins bite once again.
07:42:36 <quicksilver> @quote quicksilver
07:42:36 <lambdabot> quicksilver says: <jatqceer> i love them.  Double is my friend <quicksilver> You think he is, sure <quicksilver> he says nice things about you <quicksilver> but one day, when your back is turned, he
07:42:36 <lambdabot> will stab you in the back with a mantissa
07:42:39 <MyCatVerbs> matthew_-: I find having that many things open at once causes me to compulsively waste time looking through them to remember which one I'm chasing at the time.
07:42:58 <mauke> yeah, firefox seems to run out of resource handles or something
07:43:06 <matthew_-> MyCatVerbs: are you not doing a PhD?
07:43:08 <matthew_-> ;)
07:43:27 <MyCatVerbs> matthew_-: no, thank goodness. I'm only an undergrad, so far. :)
07:43:29 * byorgey uses a garbage-collecting window management algorithm
07:43:45 <matthew_-> MyCatVerbs: you'll get better at wasting time then...
07:43:45 <dylan> byorgey: ooh?
07:44:25 <matthew_-> quicksilver: what's wrong with hGetContents (other than it being lazy)?
07:44:25 <Botje> byorgey: does that mean you close windows you don't need ? :)
07:44:26 <ehird> byorgey: is that the kind of garbage collector that sometimes frees memory you're going to use later? ;)
07:44:43 <ehird> i had an idea for a short url site garbage collector
07:44:46 <byorgey> yes, I just mean that every now and then I go through all my workspaces and close a bunch of windows =)
07:44:50 <ehird> it's a copying GC
07:44:53 <quicksilver> matthew_-: what's wet about the sea (other than the water)?
07:44:58 <ehird> first, you go through every page on the web
07:45:07 <matthew_-> quicksilver: toche
07:45:09 <ehird> for each link to a short url you find, you copy it over to the other heap
07:45:10 <matthew_-> (sp!)
07:45:12 <ehird> then, you free the first heap.
07:45:16 <ehird> tada!
07:45:18 <sizur> quicksilver, other liquids than the water ;)
07:45:36 <quicksilver> matthew_-: this particular thread involved someone bitten because of hGetContents.
07:45:51 <quicksilver> matthew_-: about once a month that happens to someone (that, or readFile)
07:45:55 <matthew_-> quicksilver: could have been me!
07:45:57 * mux wonders who wasn't bitten by hGetContents or readFile
07:46:08 <sizur> i waznt
07:46:09 <quicksilver> matthew_-: each time I traditionally post a rant suggesting it be removed from the default API
07:46:12 <matthew_-> I find hGetContents is fine so long as you never try to close a file handle...
07:46:13 <sizur> because i never used it ;)
07:46:20 <quicksilver> or renamed unsafeLazyHGetContents
07:46:22 * dylan wasn't bitten by readFile
07:46:22 <MyCatVerbs> matthew_-: ...SHIT.
07:46:31 <byorgey> @remember quicksilver <matthew_-> what's wrong with hGetContents (other than it being lazy)?  <quicksilver> what's wet about the sea (other than the water)?
07:46:31 <lambdabot> Good to know.
07:46:33 <MyCatVerbs> matthew_-: I'm already far too good at that. :(
07:46:34 <dylan> but I read the documentation first
07:46:43 <matthew_-> MyCatVerbs: nah, I think it's called hClose ... ;)
07:46:49 <mux> lazy IO is a mixed blessing
07:47:07 <MyCatVerbs> matthew_-: procrastrinating, I mean.t
07:47:07 <Cin> is it possible that because i have a "writer" thread for a socket, that this socket could be closed and accepted again as a new client but my writer thread doesn't realise it and sends unrelated data to the new client? (do i need to provide more details or do you know what i mean?)
07:47:07 <matthew_-> it's only lazy I
07:47:10 <MyCatVerbs> *meant.
07:47:11 <matthew_-> it's strict O
07:47:12 * byorgey likes lazy IO for silly ten-line throwaway programs
07:47:28 <matthew_-> MyCatVerbs: ahh I see
07:47:39 <matthew_-> lazy O would really be terrifying
07:47:40 * MyCatVerbs uses lazy IO in situations where he's going to consume the entire input file anyway.
07:47:50 <ehird> lazy O would be hilarious
07:48:01 <matthew_-> would kinda remind me of STM too...
07:48:02 * matthew_- ducks
07:48:11 <ehird> in fact, with enough laziness on the part of haskell we could write a program that prints out the inputted line, then reads it in
07:48:13 <ehird> :D
07:48:15 <MyCatVerbs> readFile >>= return . parseConfig, etc.
07:48:49 <Cin> -_-
07:48:57 <matthew_-> ehird: Cannot satisfy temporal anomaly at line 13
07:49:39 <byorgey> ertai: yes, that was going to be my next suggestion.
07:49:45 <byorgey> sorry, mischan
07:49:49 <ehird> matthew_-: aww :(
07:50:02 <ehird> we should put that in ghc
07:50:07 <matthew_-> ehird: raise a bug for it for ghc 6.10
07:50:13 <quicksilver> MyCatVerbs: this one was quite an interesting example of how trying to write a naive network program over lazy IO
07:50:14 <ehird> it gives you a binary, then demands to know what it just compiled
07:50:26 <Cin> well
07:51:10 <Cin> it seems to me like the fd would be re-used when a new connection is accepted, so my writer thread would actually write data to the new connection without ever knowing. how do people avoid this?
07:52:09 <quicksilver> Cin: no
07:52:25 <quicksilver> Cin: the writer socket would give an error after than point
07:52:30 <quicksilver> 'closed handle' or something
07:54:06 <Cin> quicksilver: what if i haven't closed the socket in time?
07:57:18 <quicksilver> Cin: erm, if you haven't closed the socket, then you can still write.
07:57:23 <quicksilver> Cin: what's the problem then? :)
07:59:16 <Cin> quicksilver: because the remote host can close the socket
08:00:16 <Cin> quicksilver: what if the remote host closes the socket, and a new connection is accepted on the same fd?
08:04:59 <quicksilver> Cin: if the remote host closes the socket, your program will explode
08:05:05 <quicksilver> Cin: you need to catch SIGPIPE.
08:05:08 <quicksilver> (or ignore it)
08:05:10 <Cin> quicksilver: i am
08:05:17 <quicksilver> ok, that coevers that part.
08:05:24 <quicksilver> new connection can't be accepted on the same handle
08:05:29 <quicksilver> handles don't work like that
08:05:31 <quicksilver> it's not possible
08:05:39 <quicksilver> new connectin will always be a new handle
08:05:45 <Cin> quicksilver: good
08:06:12 <Cin> quicksilver: so a handle kind of "reserves" an fd until it leaves scope?
08:06:19 <Cin> quicksilver: (or when hClosed)
08:06:27 <quicksilver> I'm actually not sure what happens down at the FD level
08:06:35 <quicksilver> but a Handle is more than just an FD
08:06:47 <quicksilver> i suspect the OS doesn't recycle FDs until integer wraparound though
08:07:06 <quicksilver> never investigated that
08:07:07 <flux-_> I think linux recycles FDs very rapidly
08:07:10 <dylan> usually you cannot have that many fds open
08:07:20 <Cin> quicksilver: it does, i've tested it. i've accepted a connection and printed the fd, and closed it, re-accepted, same fd
08:07:31 <quicksilver> hmm
08:07:34 <allbery_b> it's "recycled" immediately on last close, on unix
08:07:34 <mauke> a fd stays valid until you close it
08:07:41 <mauke> a new fd will get the lowest unused number
08:07:47 <quicksilver> mauke: but if another thread has a reference to the old fd?
08:07:49 <flux-_> quicksilver, it is better to have low-numbered file descriptors open due to select, which are O(max_fd)
08:08:04 <flux-_> (are->is)
08:08:08 <quicksilver> and in this context is a Handle more than an FD, in a useful way?
08:09:07 <allbery_b> an fd is just an Int, and is per-process (not per thread) so unless the haskell runtime does it an hClose will close it for everyone and subsequent references that are held on to will get EBADF (unless the fd gets reused)
08:09:43 <allbery_b> ideally the haskell runtime keeps track of threads' references to Handles and does something sane when the Handle is hClose-d
08:09:51 * allbery_b has no idea if it does so
08:10:12 <Cin> ie can two handles refer to the same fd, where one Handle is a new accepted connection and the other is a closed connection, and will writing to either Handle refer to the new fd?
08:10:12 <quicksilver> allbery_b: the question here is, assume the FD does get reused
08:10:26 <quicksilver> allbery_b: because flux-_ 's program is always accept() ing new connections.
08:10:34 <quicksilver> flux-_: I think I have misinformed you.
08:10:52 <quicksilver> flux-_: I think bad things will happen, and you better keep track of your writing threads and kill them at close time.
08:11:03 <allbery_b> that would be the safe assumption
08:11:05 * quicksilver apologies
08:11:12 * quicksilver apologises for his spelling.
08:11:49 <flux-_> quicksilver, I think I wasn't the one having such issues :)
08:11:54 <allbery_b> like I said, unless the haskell runtime itself tracks the Handles / FDs, nothing prevents a stale fd from being reused
08:15:00 <Cin> well i have no idea how to stop it doing that
08:16:07 <matthew_-> mauke: is that true even with the gresecurity patches?
08:16:59 <quicksilver> Cin: kill the thread
08:17:07 <quicksilver> flux: sorry :)
08:17:10 <matthew_-> oh, I meant grsecurity and it seems that's only 2.4. I clearly keep up with these things...
08:17:24 <quicksilver> Cin: keep a record of which writers are attached to each FD, and kill them.
08:17:26 <mauke> matthew_-: no idea
08:17:37 <quicksilver> If you have more than one thread writing to a given FD you program is broken, by the way.
08:17:48 <quicksilver> Hmm. I wonder if the type system could enforce that statically.
08:17:49 <quicksilver> Discuss.
08:18:17 <matthew_-> ownership types
08:18:26 <matthew_-> the problem is the number of threads may be unbounded
08:18:33 <quicksilver> I was thinking of something slightly less static than that.
08:18:49 <Cin> quicksilver: i'd probably also have to kill the reader thread, i mean, its Handle could just read from the new fd
08:18:55 <quicksilver> Cin: yup.
08:19:23 <Cin> quicksilver: sounds like a bad solution, but the only one i can think of
08:19:31 <matthew_-> I would imagine you might be able to get close with strong updates and linear logic types...
08:19:31 <quicksilver> matthew_-: I always imagine you must be this matthew I knew, given the things you discuss. But you're not. You're another one.
08:19:45 <quicksilver> Cin: I don't think it's a bd solution :)
08:20:07 <matthew_-> quicksilver: I see. I always imagine you're this pirate I knew, given ...
08:20:26 <quicksilver> ARRR
08:20:32 <quicksilver> this one http://www.cl.cam.ac.uk/~mjp41/
08:20:33 <lambdabot> Title: Matthew Parkinson, Computer Laboratory, University of Cambridge
08:20:39 <quicksilver> he discusses ownership types
08:20:41 <quicksilver> or he used to
08:20:46 <quicksilver> and linear logic types
08:20:51 <quicksilver> who knows what he discusses now :)
08:21:04 <matthew_-> oh him. yes, I'm generally aware of him
08:21:06 <Cin> quicksilver: i still think it leaves room for joe blogs to one day connect to my server and receive a line of bogus data because the writer thread wasn't killed quickly enough
08:21:09 <matthew_-> others in my office know him too
08:21:46 <quicksilver> Cin: not if you kill the thread before you hClose the FD.
08:21:47 <Cin> quicksilver: or worse, for the reader thread to read a line from the _new_ socket and update the state, before being killed..
08:22:26 <quicksilver> again, that's OK if you kill first, ask questions later.
08:22:46 <quicksilver> s/ask questions/close FD/
08:23:10 <matthew_-> quicksilver: also, I don't look like Matthew Parkinson.
08:24:55 <Cin> quicksilver: so on the accept() thread, it accepts a new connection, looks up the fd in some map and says "ahh it already exists!" and kills the threads associated with that old fd and updates the state, then continues to add the new connection to the state and launch the new threads?
08:25:31 <Cin> quicksilver: (i'm just talking about how it would be implemented here)
08:26:01 <LordMetroid> That radio interview was quite so nice!
08:26:39 <flux> (that sounds awfully complicated for a server to do, maybe I'd better scroll back to see the context..)
08:27:13 <byorgey> LordMetroid: the SPJ one on 'dot net rocks'?
08:27:14 <flux> if the remote host closes a socket, it doesn't get closed for you
08:27:39 <Cin> flux: are you 100% sure about that?
08:27:40 <LordMetroid> I listened to the dot net rocks interview... I had no idea SPJ had one as well...
08:27:47 <flux> cin, yes
08:27:57 <flux> cin, well, not in the context of haskell
08:28:07 <flux> but in the context of bsd sockets
08:28:10 <Cin> flux: but in the context of the socket library working with the fds?
08:28:14 <Cin> flux: okay, hm
08:28:40 <flux> cin, if the peer closes the socket, you need to do that also
08:28:44 <Cin> flux: well then if that's the case i can just catch the exception when it's closed
08:28:46 <LordMetroid> Is there an URL to the SPJ interview as well?
08:28:52 <flux> (after receiving an error while reading/writing it)
08:29:01 <Cin> flux: right
08:29:49 <byorgey> LordMetroid: http://www.dotnetrocks.com/default.aspx?showNum=310
08:29:50 <Cin> flux: well that's brilliant
08:29:55 <lambdabot> Title: .NET Rocks!
08:30:13 <Cin> flux: do you know where i might read about this to be sure?
08:30:15 <byorgey> LordMetroid: which one did you listen to then?
08:30:23 <ricky_clarkson> .NET rocks, as in "is unstable"?
08:30:29 <Cin> flux: i generally like to refer to documentation pages in my comments about things
08:30:36 <LordMetroid> That was the one
08:30:55 <flux> cin, I don't think it reads anywhere. documentation seldom suggests what it _doesn't_ do :-)
08:30:56 <LordMetroid> DOH, I misread your first sentence...
08:30:59 <matthew_-> ricky_clarkson: as in ".NET rocks can be used to hurt the unsuspecting"
08:31:06 <byorgey> LordMetroid: hehe
08:31:07 * LordMetroid smacks his head against the keyboard hb
08:31:26 <Cin> flux: heh. well, i'll take your word for it. actually, i could write a test program to prove it
08:31:28 <flux> cin, I think there is tons of documentation on how sockets etc work; you can infer that from any socket application which doesn't need to do that kind of trickery..
08:31:43 <Cin> flux: true
08:31:53 <byorgey> LordMetroid: yes, SPJ is always entertaining and informative... I dunno about the interviewers though, they seemed kinda clueless. ;)
08:31:59 <mux> oh yeah
08:32:09 <Cin> flux: it kind of makes sense that it wouldn't be closed for me otherwise we would indeed have this horrible issue
08:32:15 <matthew_-> SPJ does also know *nothing* about the non functional world, by all accounts.
08:32:18 <LordMetroid> I agree, I was thinking "they call themself programmers?"
08:32:37 <mux> a lot of times during this interview you hear the guy say clueless stuff, and SPJ being nice 'oh yes, I guess we could say that'
08:32:41 <radix> matthew-_: he seemed pretty conscious in the talk of his that I watched
08:33:05 <matthew_-> radix: conscious is quite a basic requirement though for a talk...
08:33:15 <radix> matthew-_: "of the larger programming world" :P
08:33:19 <matthew_-> oh!
08:33:29 <LordMetroid> Either they play dumb for achieveing a conversation at the level of thier listeners or they really are that clueless
08:34:05 <flux> hm, don't you need to know something about imperative programming to write a compiler, cpu's being imperative?
08:34:18 <flux> or is SPJ doing stuff above that code generation level
08:34:52 <matthew_-> flux: yeah, but I don't think you need to know about OO or the details of Java's exception model or annotations in C# or...
08:35:11 <flux> who would, except a java- or C#-programmer :)
08:35:44 <matthew_-> apparently he did ask my supervisor, when she was giving a talk, if classes in Java were like modules in ML
08:36:01 <mux> I like how one of the guys keeps saying throughout the interview that the future is implicit paralellism, despite SPJ trying to explain him that you can't go very far without explicit parallelism
08:37:31 <byorgey> mux: heh, yes, and how he kept being like, "oh, and laziness is great for that!" and SPJ was like "um, actually... no, it's the purity that's important".
08:38:03 <matthew_-> I wonder whether he was "asked" to do that interview as a member of MSR
08:38:04 <radix> hooray DPH
08:38:15 <mux> byorgey: haha yes :-)
08:38:44 <cjb> matthew_-: nah.
08:39:04 <flux> maybe the future is writing extremely parallel programs, but executing them efficiently in sequence :)
08:39:06 <mux> now to be honest, I would have probably been as clueless as they sound if I had to interview SPJ while knowing nothing about Haskell
08:39:28 <pejo> matthew, I can see why people don't bother to learn the details of classes in Java though.
08:39:37 <byorgey> mux: fair. =)
08:39:58 <Gnezdo> does anybody know of a good set of regexps to give to etags for haskell files?
08:40:12 <matthew_-> pejo: yeah, the fact is that an *awful lot of (awful) code* does get written in Java. A basic knowledge really isn't asking too much...
08:40:16 <Gnezdo> hasktags is, um, limited
08:41:44 <matthew_-> it's like a basic knowledge of the Bible is generally good fun so that you can have really animated discussions with the folks that come to your front door, trying to convince you...
08:42:14 <pejo> matthew, "Thanks, I'd love to read your material. Good bye!".
08:43:03 <matthew_-> pejo: but I think that might be lying. It's more fun to try and convince them that they're mistaken
08:43:10 <matthew_-> depends really how bored you are...
08:44:44 <ehird> hmm
08:44:51 <ehird> 'printf' is untypeable, correct?
08:44:59 <mux> :t printf
08:45:12 <ehird> no such thing, in ghci
08:45:12 <ehird> :P
08:45:15 <lambdabot> thread killed
08:45:17 <mux> in Text.Printf
08:45:28 <matthew_-> ehird: you can type it in cayenne or omega
08:45:31 <mux> you can type printf with HOFs, you don't necessarily need dependent typing
08:45:39 <mux> otherwise we wouldn't have printf in Haskell
08:46:01 <ehird> i was trying to make a printf-alike which just returned a function when it needed more, which obviously didn't work
08:46:01 <ehird> "_
08:46:03 <ehird> *:)
08:46:13 <ehird> though that is a clever printf type
08:46:30 <Deewiant> Is there a standard function like 'group' which works regardless of whether the list is sorted?
08:46:35 <quicksilver> Cin: you don't check on next accept.
08:46:39 <quicksilver> Cin: you check on close
08:46:46 <Deewiant> I.e. f [1,2,1,2] = [[1,1],[2,2]]
08:46:51 <quicksilver> Cin: where close is either a decision you made, or one that a SIGPIPE made for you.
08:47:04 <quicksilver> Deewiant: group . sort :)
08:47:05 <flux> quicksilver, I've found it better to SIG_IGN SIGPIPE
08:47:15 <Deewiant> quicksilver: I don't have an Ord instance on the type, can't sort
08:47:17 <quicksilver> flux: but that doesn't solve this particular problem
08:47:21 <flux> quicksilver, I think SIGPIPE is just for software that don't have proper io error handling.
08:47:30 <flux> no it doesn't, but it's still good to have in a server :)
08:47:32 <Saul_> Is there a function like (!!), but one that maybe returns the value?
08:47:42 <quicksilver> flux: yeah, so you catch SIGPIPE
08:47:47 <quicksilver> flux: instead of ignoring it
08:47:50 <quicksilver> and close the threads on that fd
08:47:54 <Cin> quicksilver: according to flux the fd isn't closed if the remote host disconnects
08:47:54 <quicksilver> Saul_: yes
08:47:58 <mux> you get SIGPIPE if you write on a closed fd
08:47:58 <quicksilver> :t findIndex
08:47:59 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
08:48:04 <quicksilver> :t find
08:48:04 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
08:48:05 <flux> quicksilver, and do what? how do you know which fd caused the error?
08:48:07 <quicksilver> erm
08:48:11 <quicksilver> :it index
08:48:11 <mux> you get an error and EPIPE in errno if you read on a closed fd
08:48:16 <quicksilver> :t index
08:48:17 <flux> quicksilver, when you ignore SIGPIPE, writing to a socket causes a write error
08:48:17 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
08:48:18 <flux> not SIGPIPE
08:48:21 <Cin> indeed, i've got it ignoring sigpipe and then an exception is thrown when i try to write to it
08:48:23 <flux> which is swell
08:48:27 <quicksilver> ah that's true
08:48:31 <quicksilver> not thinking clearly.
08:48:33 <quicksilver> that's better.
08:48:38 <quicksilver> when you catch EPIPE
08:48:44 <quicksilver> then you close the other thread
08:48:48 <quicksilver> (as well as this one)
08:48:50 <Saul_> quicksilver: those aren't what I need
08:48:55 <quicksilver> Saul_: I know
08:49:01 <quicksilver> Saul_: I'm sure it's there somewhere :)
08:49:18 <mux> :t findIndex (const True)
08:49:18 <lambdabot> forall a. [a] -> Maybe Int
08:49:27 <mux> err, no, makes no sense, sorry
08:49:37 <ehird> > printf "%s"
08:49:37 <ehird> *** Exception: Printf.printf: argument list ended prematurely
08:49:38 <lambdabot>  Add a type signature
08:49:39 <ehird> wtf
08:49:40 <ehird> :)
08:49:50 <ehird> That should return a function! We need curryable printf!
08:49:55 <mux> > printf "%s" "Hello world!" :: String
08:49:56 <lambdabot>  "Hello world!"
08:49:58 <quicksilver> Saul_: no, weirdly not.
08:50:03 <ehird> not good enough :(
08:50:07 <Cin> so basically the writer thread can just closed when it gets an exception upon writing to the Handle, and the reader thread can hClose the handle when it gets an error upon hGetLine and cleanup the state
08:50:17 <Cin> sounds good?
08:50:17 <quicksilver> ehird: we do have a curryable printf :)
08:50:18 <Cin> s/closed/end
08:50:18 <quicksilver> > printf "%s" :: String -> String
08:50:20 <lambdabot>  <[Char] -> [Char]>
08:50:22 <ehird> hah
08:50:26 <Saul_> quicksilver: That is weird indeed
08:50:27 <ehird> it's like typecasting!
08:50:38 <ehird> of function pointers
08:50:38 <ehird> in C!
08:50:39 <mux> I love how printf can do IO or not depending on the typing context
08:50:44 <quicksilver> Saul_: you could try listToMaybe . drop n
08:50:45 <mux> no need for sprintf :)
08:50:48 <quicksilver> Saul_: ;)
08:51:02 <flux> > printf "%s" :: Int -> String
08:51:03 <lambdabot>  <Int -> [Char]>
08:51:09 <Saul_> quicksilver: On the other hand there is also no read that maybe returns a parse
08:51:10 <flux> darn, foiled
08:51:14 <Cin> mux: kind of reminds me of CL's FORMAT, but more elegant because context implies how it should work
08:51:19 <quicksilver> Saul_: well there is reads
08:51:38 <flux> > printf "%d" :: String -> String
08:51:38 <lambdabot>  <[Char] -> [Char]>
08:51:43 <flux> ..right
08:53:51 <Saul_> quicksilver: Yeah but converting that is really not simple, since that doesn't return staright parses
08:54:09 <quicksilver> Saul_: yes, I often recommend wrapping it
08:54:20 <Saul_> quicksilver: listToMaybe . map fst . reads is just not very intuitive
08:54:33 <quicksilver> :t \x -> case reads x of [(y,"")] -> Just y ; _ -> Nothing
08:54:34 <lambdabot> forall a. (Read a) => String -> Maybe a
08:54:57 <matthew_-> flux: if you just replaced all the %x with empty types and did some other magic it might work thoughh
08:55:07 <Saul_> :t listToMaybe . map fst . reads
08:55:07 <lambdabot> forall a. (Read a) => String -> Maybe a
08:56:36 <matthew_-> yeah, you could do it - the format string would a type-level list. I'm sure oleg or others must have been down this route.
08:57:08 <quicksilver> Saul_: that's not even a good idea :)
08:57:21 <quicksilver> Saul_: it doesn't check that the whole string is consumed.
08:57:38 <quicksilver> matthew_-: yes you can do it with magic. Not even that hard. Just a DSL instead of a format string.
08:57:46 <Saul_> quicksilver: That's true
08:57:49 <quicksilver> matthew_-: ends up much less 'concise' than a format string.
08:57:57 <matthew_-> quicksilver: boo hoo ;)
08:58:37 <quicksilver> matthew_-: "Your name is " <: PFString <: " and you are " <: PFInt <: " years old" ::PrintfFormatSpecifier
08:58:40 <quicksilver> or something
08:58:43 <matthew_-> yep.
08:58:52 <quicksilver> but one of the main positives about printf is the conciseness
08:58:55 <matthew_-> reminds me of a lot of html template systems
08:58:59 <quicksilver> otherwise you might just as well write
08:59:12 <matthew_-> quicksilver: well, it's not like it has many positives to choose from...
08:59:15 <quicksilver> \n a -> "Your name is " ++ n ++ " and you are " ++ show a ++ "years old"
08:59:29 <matthew_-> "if we think *really* hard, we can find one thing we like about it..."
08:59:41 <mattam> The previous version is not type safe...
08:59:46 <mattam> with a DSL
08:59:47 <resiak> cf. people using printf rather than iostreams in C++
09:00:30 <mattam> You can have a first-class printf (curryable) with continuations: http://www.haskell.org/pipermail/haskell/2007-December/020034.html
09:00:30 <lambdabot> Title: [Haskell] Genuine shift/reset in Haskell98, http://tinyurl.com/26z6zp
09:00:49 <quicksilver> mattam: I was simplifying
09:01:03 <quicksilver> mattam: I thought the extension to make it type safe would be obvious
09:01:11 <mattam> !
09:01:28 <quicksilver> mattam: it woudl have type PFCons String (PFCons Int PFNil)
09:01:32 <quicksilver> or something like that.
09:01:55 <quicksilver> and it doesn't even need overlapping instances, I don't think.
09:01:59 <Cin> does spj ever come to irc?
09:02:04 <mattam> ow... gadts come into the picture then ?
09:02:08 <quicksilver> unlike the heavywieght HList stuff.
09:02:12 <quicksilver> mattam: that's not a gadt.
09:02:16 <matthew_-> quicksilver: I'm going to use that in a paper: " the extension to make it type safe is obvious and thus omitted for brievity"
09:02:26 <quicksilver> mattam: just an ordinary nested data type
09:02:37 <quicksilver> mattam: compare it to Either String (Either Int ())
09:02:46 <mattam> ok
09:03:13 <quicksilver> matthew_-: sure, but you have to reference #haskell/quicksilver in a footnote
09:03:30 <matthew_-> quicksilver: np ;)
09:03:36 <mattam> Can you write the run function ?
09:04:28 <mattam> PFCons A B -> A -> (PFCons B ? -> String)
09:04:35 <mattam> ??
09:05:05 <matthew_-> mattam: yeah, that looks a lot like parameterized monads
09:05:12 <quicksilver> you have a one-step run function.
09:05:36 <matthew_-> eg state monad where the type of the state can vary, thus you track "from" and "to"
09:05:36 <quicksilver> PFCons a b -> a -> c
09:05:41 <Lemmih> Cin: Yes.
09:05:43 <quicksilver> and you use a typeclass
09:05:45 <quicksilver> like in printf
09:05:54 <quicksilver> to resolve 'c' :)
09:05:56 <Cin> lemih: groovy :)
09:07:00 <mattam> Hmmm. that seems bizarre, i'll just have to think about it :)
09:07:21 <mattam> matthew_-: indeed, it's a nice one. I've tried to explain how this works here: http://www.lri.fr/perso/~sozeau/repos/coq/misc/shiftreset/GenuineShiftReset.html
09:07:22 <lambdabot> Title: GenuineShiftReset, http://tinyurl.com/2ywh6h
09:08:37 <slarba_> http://brucio.blogspot.com/2008/01/arc-is-out.html <- I just don't get these guys
09:08:38 <lambdabot> Title: Lisp at Light Speed: Arc debarks
09:09:45 <osfameron> what don't you get?
09:12:19 <slarba_> I seem to miss the whole point of the existence of Arc
09:14:19 <kalven> no one is going to use it anyway
09:14:36 <dolio> That blog post seems kind of silly.
09:14:57 <slarba_> very.
09:15:14 <dolio> First he talks about how great it is that Arc is a compiler, and then he talks about all the bloat of Common Lisp, including "native code generation."
09:15:52 <slarba_> "Another remarkable thing about Arc is what Mr. Graham has been able to strip away."
09:16:28 <slarba_> ...to be implemented again and again?
09:17:35 <Botje> ... badly?
09:18:37 <dolio> To be fair, I thought some of the early stuff Paul Graham wrote about going back to Lisp's roots of, "what is the minimal set of constructs that one can use to implement everything else," was kind of interesting.
09:19:07 <dolio> For instance, when he was talking about what you'd need to implement typing yourself and such.
09:21:11 <dolio> But, you know, "fn instead of lambda" is somewhat less impressive.
09:21:49 <pejo> Shorter than 'fun' atleast.
09:22:05 <Deewiant> But longer than '\'. ;-)
09:22:37 <vincenz> lol
09:22:42 <vincenz> joelr: RIP Hardcore Erlang. My publisher has been notified. I will not be the Erlang expert sought for web apps. Trading systems are my future.
09:23:45 <sebell> *sigh* what a strange case of medium-term ADD he has
09:24:12 <alex-4> I don't understand one thing about haskell: why is there no compiler in the implementation, if a partially-evaluated functions could be returned from the other functions?
09:24:28 <dolio> I also don't see the typing stuff on the "axioms" on that blog post, but maybe I'm missing something.
09:25:02 <doserj> alex-4: you are mixing partial evaluation and partial application
09:25:15 <slarba_> dolio: but axiom's don't get you far. arc may be very elegant at the bottom with its "axioms", but you need a lot more obviously to be usable
09:25:15 <pejo> vincenz, where did you see that?
09:25:49 <alex-4> dolio: Ok. But the jit part of question will still be valid, right?
09:26:07 <Philippa> nope. Look at currying again - all you're doing is filling in a tuple until it's full, then running
09:26:12 <slarba_> dolio: like untyped lambda calculus won't take us very far
09:26:41 <Philippa> or at least, it's isomorphic to that and that's one of the standard ways of implementing it
09:26:46 <dolio> slarba_: Yeah. I just think it's sexy to define all that stuff in a minimal set of operations, even though nobody implements it that way. :)
09:26:54 <doserj> alex-4: ?
09:26:54 <quicksilver> alex-4: the natural way to have a haskell implementation does have a "representation of code at runtime"
09:27:05 <quicksilver> alex-4: but, it's not like source code which needs compiling
09:27:08 <vincenz> pejo: reddit and his twiter
09:27:11 <quicksilver> alex-4: it's like a pointer to a block of machine code
09:27:14 <slarba_> dolio: of course it's sexy and theoretically interesting :)
09:27:28 <quicksilver> alex-4: a "partially applied" function is a pointer to a block of code to JMP to once you have all the parameters filled it.
09:27:34 <quicksilver> approximately :)
09:27:47 <dolio> slarba_: I can't figure out where PG actually talks about that typing stuff on his page, either... Maybe I dreamt it up.
09:28:09 <slarba_> dolio: compare: what if haskell implemented natural numbers as church numerals? :D
09:28:20 <pejo> vincenz, sigh. What is twitter, some kind  of rss?
09:28:31 * desegnis does not get what alex-4 means by ¬ªno compiler¬´ and, consequently, doesn't follow the answers either.
09:28:32 <alex-4> quicksilver: How is the block of that machine code computed?
09:28:43 <vincenz> pejo: http://twitter.com/wagerlabs/statuses/659726302
09:28:43 <lambdabot> Title: Twitter / wagerlabs: RIP Hardcore Erlang. My pub...
09:29:15 <dolio> slarba_: Well, you know, ndm's super optimizer actually works by Church encoding a lot of data types. :)
09:29:17 <radix> I don't see what partially-evaluated functions have to do with having a compiler... or source code representation in the language
09:29:56 <pejo> vincenz, hm, twitter is the name of a website?
09:30:02 <hpaste>  zooko pasted "(no title)" at http://hpaste.org/5343
09:30:10 <vincenz> pejo: it's a place to send messages
09:30:19 <vincenz> pejo: like an ultra-ADD short-version of a blog
09:30:22 <vincenz> pejo: twitter has the answer
09:30:24 <vincenz> erem
09:30:25 <vincenz> google
09:30:29 <quicksilver> alex-4: by the compiler, at compile-time.
09:30:32 <quicksilver> alex-4: (not at run time)
09:31:48 <alex-4> quicksilver: Perhaps I missed something. I thought that I could consider a functor a sort of macro. Is that correct?
09:32:09 <alex-4> quicksilver: Rather "analogous to", not "sort of".
09:32:12 <ehird> so did anybody ever actually suggest a  gui lib? :P
09:32:15 <Philippa> functor in haskell doesn't mean what it does in C++
09:32:21 <Philippa> nor the usual usage in ML
09:32:32 <alex-4> ok
09:32:34 <hpaste>  zooko pasted "(no title)" at http://hpaste.org/5344
09:32:52 <Philippa> I assume you meant "function being passed around as a value"?
09:32:59 <alex-4> Yes, exactly.
09:33:07 <CosmicRay> Igloo: what has happened to libghc6-regex-compat-dev?
09:33:17 <Philippa> functions in haskell do behave a little like macros sometimes in that the language is pure so you can reason about them by rewriting...
09:33:23 <CosmicRay> Igloo: oh never mind
09:33:44 <CosmicRay> Igloo: it seems that its version number changed or something?
09:33:46 <Philippa> there's nothing special about functions that're being treated as values though - in fact that's the whole point
09:34:09 <pejo> dolio, what was ndm's reason for church encoding stuff instead of just extending the language supero works over?
09:34:38 <quicksilver> alex-4: a function in haskell, as compiled by GHC, is a block of code in memory, together with a bit of metadata.
09:34:41 <hpaste>  zooko pasted "ghc build failure on cygwin" at http://hpaste.org/5345
09:34:52 <CosmicRay> Igloo: actually the question stands.  the package is gone and ghc6 isn't providing it
09:35:02 <quicksilver> alex-4: a value which represents a function, possibly partially applied, is a pointer to that memory plus "some" parameters
09:35:11 <dolio> pejo: He church encodes the data types, and then does aggressive optimization on functions. At least, that's what I gather from what he's said about it.
09:35:12 <alex-4> Philippa: Let's take an example. Some string (say, regex) which is compiled, thus transformed into a corresponding function. So compile(regex) returns another function. It seems to me that such functionality does require compiler or a kind of jit in the run-time to be efficient.
09:35:15 <quicksilver> alex-4: once you have "all" the parameters you can actually run the code.
09:35:23 <quicksilver> alex-4: and get to the next value.
09:35:44 <alex-4> quicksilver: But, that only covers very simple cases. What about that regex example?
09:35:51 <dolio> pejo: So, the better your optimization of functions, the better your optimization of data types.
09:35:59 <quicksilver> alex-4: it's a bit hard to explain very concretely
09:36:09 <quicksilver> you end up with a lot of very small blocks of code joined together by pointers
09:36:16 <quicksilver> its less inefficient than it sounds
09:36:30 <alex-4> very small blocks of machine code, right?
09:36:31 <quicksilver> although it is certainly not a fast as a true JIT to a single lump of contiguous code.
09:36:32 <mauke> alex-4: I dunno, regexec() seems efficient enough
09:36:33 <Philippa> aleator: depends on your value of 'efficient'
09:36:39 <Philippa> alex-4, even
09:36:42 <quicksilver> yes
09:37:01 <Philippa> if you do that in haskell you'll end up with a lot of unnecessary indirection in most implementations because it's not actually JITted
09:37:12 <quicksilver> A nice diagram of this would be a useful tool for people trying to understand haskell's operational semantics.
09:37:17 <alex-4> Is there a particularly good reason why jit wasn't used?
09:37:18 <Philippa> but it's not /that/ bad, especially if it all fits in the cache still
09:37:25 <Philippa> because it costs coding time
09:37:39 <quicksilver> I have been thinking about it recently because I'm trying to implement something rather like your regex compiler.
09:37:46 <alex-4> Ok, I see.
09:37:51 <quicksilver> and I find it slightly hard to reason about the speed it will run at :)
09:37:53 <Philippa> additionally, most people would rather have a staging facility
09:38:02 <quicksilver> someone did write a JIT for one haskell compiler
09:38:06 <quicksilver> (not ghc though)
09:38:12 <quicksilver> I believe it was moderately successful.
09:38:13 <alex-4> What about a text editor which uses haskell programs for its configuration (a la emacs, but in Haskell)?
09:38:26 <quicksilver> alex-4: then you definitely need to embed the c ompiler
09:38:28 <Philippa> yi? It uses hs-plugins to call an actual compiler and link
09:38:33 <quicksilver> alex-4: people are doing exactly that
09:38:35 <quicksilver> > 1 + 4
09:38:37 <lambdabot>  5
09:38:50 <quicksilver> alex-4: lambdabot here uses the compiler too
09:38:50 <Philippa> thankfully because you rarely need to recompile much it's pretty fast
09:38:56 <Philippa> but hs-plugins is still to a large extent a hack
09:39:04 <Philippa> ("pretty fast" = faster than elisp, btw!)
09:39:05 <alex-4> Philippa: So, what do they actually call? Just using system shell, or... ?
09:39:17 <quicksilver> alex-4: no, they link to the compiler "as a library"
09:39:27 <alex-4> Ok
09:39:28 <Philippa> because GHC's written in Haskell that's not so hard to do
09:39:31 <quicksilver> ghci itself (ghc's interpreter) works the same way
09:39:42 <quicksilver> it can link compiled code together to interpreted code
09:39:45 <quicksilver> and "run" both happily
09:39:58 <quicksilver> indeed, hs-plugins is really just re-using ghci's functionality
09:40:17 <quicksilver> but not using the interpreter bit.
09:40:23 <Philippa> one reason you'd have to use JIT or staging is that you can't tell in advance how higher-order functions are going to be used - because it's code building "code", you run into the halting problem
09:40:25 <alex-4> If I wanted to write an experimental implementation with a particular form of jit, where would I need to look for "underwater stones" (since nobody seems to have written one already).
09:40:34 <Philippa> hs-plugins is effectively staging
09:40:43 <quicksilver> alex-4: somebody has written one, although it was ages ago
09:40:54 <quicksilver> malcolmw: are you there? what was that haskell JIT you were telling me about?
09:41:25 <Philippa> I have to admit, JITting in DSL-heavy code is probably a win
09:41:33 <Philippa> probably a rather big one on occasion
09:41:47 <malcolmw> quicksilver: here, but marking exam papers
09:41:57 <alex-4> Philippa: But, hs-plugins is seems to be a bit "inelegant", since you'd explicitly have to use a very special interface, right.
09:41:58 <quicksilver> malcolmw: alex-4 is asking about haskell JIT
09:42:06 <quicksilver> malcolmw: I'm sure you talked about one the other day
09:42:21 <malcolmw> quicksilver: do you mean the JIT written by David Wakeling for hbc, about 10 years ago
09:42:38 <quicksilver> yes
09:42:41 <quicksilver> that's the one I mean
09:43:00 <malcolmw> CR also has a student project writing a JIT for yhc at the moment - results due in a couple of months
09:43:21 <alex-4> quicksilver: And, is there an analog of eval and/or compile in Haskell?
09:43:21 <Philippa> alex-4: not knowing how efficient things're going to be isn't wonderfully elegant either. Also, hs-plugins can introduce new types, stuff like that. Really you'd want an equivalent mechanism in anything that runs long enough anyway
09:43:28 <Philippa> that's what hs-plugins does
09:43:29 <malcolmw> quicksilver: I'm not sure if the hbc JIT was every published, or released
09:43:51 <quicksilver> alex-4: only via hs-plugins
09:43:53 <quicksilver> http://citeseer.ist.psu.edu/15162.html
09:43:54 <lambdabot> Title: A Throw-away Compiler for a Lazy Functional Language - Wakeling (ResearchIndex)
09:43:55 <alex-4> malcolmw: not even papers, etc?
09:43:59 <quicksilver> would appear to be Wakeling's paper
09:44:08 <monochrom> throw-away?
09:44:27 <newsham> is everyone downgrading to arc today?
09:44:35 <Philippa> malcolmw: I imagine that's going to make JHC rather nifty for DSL-heavy work, especially in guaranteed-terminating DSLs, ones without higher-order computations etc
09:44:37 <malcolmw> quicksilver: that's the one
09:44:53 <quicksilver> looks like he worked with Runciman
09:45:02 <quicksilver> alex-4: I bet you could email runciman for pointers.
09:45:07 <malcolmw> Runciman is the CR I referred to
09:45:18 <quicksilver> Researchers normally respond pleasantly to questions about research they are interested in
09:45:22 <quicksilver> even if it was 10 years ago :)
09:45:38 <alex-4> From the theoretical perspective (and, I'm not an expert), how much would adding compile and/or eval would break?
09:45:41 <alex-4> If at all.
09:45:44 <ddarius> malcolmw: You are one of the people that handles project requests for code.haskell.org?
09:46:05 <Philippa> alex-4: nothing, so long as it's added in the IO monad and you do a fair amount of work with the runtime system
09:46:06 <quicksilver> alex-4: hs-plugins demonstrates that it can be done in a type-safe way.
09:46:06 <malcolmw> ddarius: I usually deal with user account reqs, not project reqs
09:46:08 <Igloo> CosmicRay: Arjan will be maintaining it
09:46:10 <monochrom> Is arc a downgrade? How come? (I haven't looked.)
09:46:24 <CosmicRay> Igloo: ah ok
09:46:25 <ddarius> malcolmw: Who usually does the project requests?
09:46:31 <quicksilver> alex-4: whilst you can disagree with the details of hs-plugins, the general architecture is probably right.
09:46:47 <Philippa> alex-4: you'd probably benefit from actually trying the language for a while rather than asking questions from a lisp-and-java-and... perspective
09:46:47 <quicksilver> better structured explicit staging might be nice
09:46:50 <newsham> mono: from haskell...
09:46:51 <malcolmw> quicksilver: alex-4: none of the JIT work I'm aware of does dynamic compilation, just runtime expansion of statically-compiled bytecode
09:46:56 <newsham> arc == lisp
09:46:58 <quicksilver> (rather than forcing you to stage via strings)
09:47:06 <malcolmw> ddarius: I think usually dcoutts or igloo
09:47:14 <alex-4> quicksilver: So, having it as an [implementation-specific] extension to the language won't cause the problems and could be done in a type-safe way?
09:47:25 <quicksilver> has already been done.
09:47:27 <quicksilver> :)
09:47:39 <ddarius> malcolmw: Igloo is who I thought too, and conveniently he's right here.
09:47:40 <alex-4> malcolmw: That's fine
09:47:50 <ddarius> malcolmw: Thanks.
09:48:04 <Philippa> alex-4: is there a particular reason you're interesting in JIT?
09:48:17 <monochrom> Ah, I now see arc is paul graham's new project
09:48:21 <Philippa> because you might be better off asking questions about how particular kinds of code can be made to perform
09:48:25 <ddarius> monochrom: New?
09:48:37 <Philippa> rather than assuming that implementation strategies carry over
09:48:40 <alex-4> Philippa: Yes. Mainly, elegant way to read config files
09:48:48 <ddarius> Igloo: Do you deal with project requests?
09:48:48 <alex-4> Philippa: And learning, of course ;-)
09:48:50 <monochrom> ok, change "new" to "I find out for the first time"
09:49:16 <ddarius> Arc is executable over-hyped vapourware.
09:49:25 <Philippa> do you actually want config files with computational content, or just to read in data? Because there are other ways of doing the latter
09:49:34 <CosmicRay> does anybody know where I can find gentoo's patches to wash?
09:49:37 <Philippa> while it's not the fastest, deriving Read over some datatype generally works nicely
09:49:42 <Gwern-away> by definition, can't be vaporware if its public
09:50:08 <Igloo> ddarius: Can't right now, sorry
09:50:12 <dolio> CosmicRay: Are you running Gentoo?
09:50:13 <Gwern-away> malcolmw: didn't the synthesis kernel do dynamic jit compilation of running asm?
09:50:17 <alex-4> quicksilver: So, your suggestion would be staging?
09:50:18 <Philippa> if you're happy in theory with writing a parser, doing so in Haskell's generally pretty quick and easy
09:50:32 <ddarius> Igloo: I'm just wondering about it.
09:50:44 <CosmicRay> dolio: no
09:50:45 <malcolmw> Gwern-away: I was talking about haskell JITs
09:50:51 <Philippa> lambdabot and yi use .hs for config, but most haskell apps don't
09:50:56 <Gwern-away> oh. nm then
09:51:02 <Gwern-away> Philippa: don't forget xmonad :)
09:51:11 <alex-4> Philippa: It'll apply to any config.
09:51:20 <ddarius> Gwern-away: xmonad is a bit different.
09:51:48 <alex-4> Philippa: Very big config possibly; the one that modifies the behavior greatly. In fact, it's a particular instance of DSL. You see what I mean, right?
09:52:01 <quicksilver> turing complete config is a mistake, in most applications
09:52:06 <quicksilver> but I'll leave that aside for the moment.
09:52:21 <quicksilver> alex-4: I only meant to say that staging gives the most support for interesting thoughts about optimisation
09:52:44 <quicksilver> for just reading config files I wouldn't expect optimsation to be a worry.
09:52:50 <quicksilver> and I'd think hs-plugins works just fine.
09:53:06 <Gwern-away> turing tarpit configs are bad, absolutely, but for xmonad and emacs turing complete configs have worked great
09:53:29 <alex-4> quicksilver: I meant config as complex as a DSL. Say, description of a plugin, etc
09:53:44 <quicksilver> Gwern-away: in both cases they're more like customisation programming than pure config.
09:53:47 <alex-4> Not necessarily turing-complete.
09:53:57 <quicksilver> Gwern-away: not that I'm tryin to suggest there is a black line between the two.
09:54:05 <Philippa> alex-4: you can get a free parser for any haskell datatype, and writing parsers is easy
09:54:07 <FrustratedSalad> what's a turing tarpit? =)
09:54:10 <quicksilver> Gwern-away: but xmonad actually lets you program your own layout algorithms
09:54:24 <quicksilver> Gwern-away: which is a little more than 'ordinary config'
09:54:26 <Philippa> so most of us would avoid using hs-plugins for config unless the architecture suggests it (as in yi, lambdabot et al)
09:54:34 <Gwern-away> FrustratedSalad: beware the turing tarpit, where everything is possible but nothing of interest is easy
09:54:42 <quicksilver> while emacs lets you program your own web browser :)
09:54:42 <Gwern-away> https://secure.wikimedia.org/wikipedia/en/wiki/Turing_tarpit
09:54:51 <alex-4> Philippa: But parsers create data-structures, not compiled code.
09:54:54 <monochrom> Here be undecidability.
09:55:00 <Philippa> alex-4: yes, so?
09:55:02 <FrustratedSalad> :)
09:55:08 <quicksilver> monochrom: Here might be undecidability. I just can't decide.
09:55:14 <Philippa> separate out parsing from interpreting
09:55:17 <monochrom> But I can!
09:55:26 <Philippa> if you want to shove those structures through a compiler, go for it
09:55:26 <quicksilver> you're a better man than I, then.
09:55:44 <Philippa> oh, and: actually parsec parsers can create code (or at least function values)
09:55:58 <quicksilver> I think that's where alex-4 came in :)
09:56:00 <alex-4> Philippa:  What if a result of config is a specific type of function? Now, I'd have to worry about too many things within the ap.
09:56:07 <quicksilver> wondering if 'creating function values' is as good as creating code.
09:56:25 <ddarius> quicksilver: Depends on how well you create the code.
09:56:31 <quicksilver> right
09:56:37 <Philippa> alex-4: actually that's easier
09:56:39 <quicksilver> and how clever your haskell compiler is, too
09:57:15 <Philippa> if there's one thing Haskell is really good at, it's writing interpreters and compilers
09:57:45 <alex-4> But that resulting compiler isn't a first-class value!
09:57:55 <Philippa> yes it is
09:58:04 <alex-4> Not efficiently!
09:58:11 <Philippa> define "efficiently"
09:58:22 <Philippa> not with maximum efficiency without running in the IO monad, sure
09:58:41 <Philippa> but once you're there you can generate something to hand off to hs-plugins if you insist
09:58:59 <alex-4> Ok. I see.
09:59:09 <alex-4> Thank you all for help.
09:59:13 <Philippa> however, most of the time things run faster than you'd expect without doing that
09:59:46 <Philippa> so unless you're actually interpreting number-crunching code that'll work on big blocks of data or something like that, it tends not to matter
10:00:04 <ehird> anyone?
10:00:13 <alex-4> Philippa: yes, it was for number-crunching.
10:00:23 <alex-4> s/was/intended\ for/
10:00:39 <Philippa> right. It's a good idea to tell people the constraints you're trying to work with up-front
10:00:40 <alex-4> *was being intended for
10:00:55 <alex-4> Ok.
10:01:01 * quicksilver thinks Philippa's suggestion would take all the fun out of IRC.
10:01:16 * Philippa thinks quicksilver must be lacking in imagination - plenty of other ways to have fun on IRC
10:01:19 <quicksilver> ;)
10:01:22 <alex-4> quicksilver: :-D
10:01:45 <Philippa> alex-4: if you're mostly intending to interpret 'glue' with all the operations already in place then the overhead probably isn't that significant anyway though
10:02:45 <CosmicRay> anybody know where CompilerPath went with the cabal in ghc 6.8?
10:03:02 <CosmicRay> err make that compilerPath
10:04:27 <dons> http://reddit.com/r/programming/info/674qv/comments/ Visualising a fold: Reflecting expressions in Haskell (twan.home.fmf.nl)
10:04:32 <dons> nice work Cale, twanvl
10:07:26 <dons> so.. anyone reimplemented arc in haskell yet? :)
10:07:39 <dons> seems like a good way to get ghc on more machines..
10:07:47 <hpaste>  Cin pasted "channel joining code" at http://hpaste.org/5346
10:07:55 <Cin> oops
10:08:42 <mrsolo> why arc? :-) arc is getting flamed
10:09:18 <RayNbow> twanvl, I haven't read all the details, but nicely done :)
10:09:28 <twanvl> thank you
10:09:33 <monochrom> Term algebra, Hebrand model/universe.
10:09:45 <Cin> dons: sneaky
10:09:48 <monochrom> err, Herbrand.
10:10:24 <monochrom> "arc is fluid and changing"...
10:10:38 <Philippa> "arc is whatever I just said it is"
10:11:07 <RayNbow> hmm, dons, that reddit submission already got a downvote
10:11:33 <monochrom> There is a short interval during which it is stable and you can reimplement it.
10:11:42 <kaol> they want to talk about arc today
10:12:10 <monochrom> The real money is probably in: every time it is changed, your reimplementation follows in a matter of hours.
10:13:24 <ehird> arc's just 1000 lines of crappy scheme
10:13:27 <ehird> with a crappy stdlib
10:13:33 <ehird> so it isn't exactly hard to implement
10:13:37 <ddarius> Philippa: It's not even that.  Arc isn't even what he said it was, no matter how you intepret that previous clause.
10:14:00 <Cin> am i using too many `where' clauses in my code? i think the code is straight-forward but it seems like every single function i write involves "this is x where this is y where this is z where..." can anyone follow that code? i can because i wrote it but i wonder how it looks to other people
10:15:05 <Deewiant> personally I don't use where clauses unless something is referenced from multiple locations
10:15:41 <slarba_> I find code easier to read, when you have a "toplevel" implementation where you immediately see what is computed, and then a set of where:s doing the details
10:15:44 <Deewiant> it looks like there are at least a few I'd remove from that, then
10:15:55 <doserj> Cin: you don't have to nest the where clauses
10:16:42 <Cin> doserj: well i'm not nesting them as such, i meant that's how i read them
10:16:52 <Cin> Deewiant: which?
10:17:30 <kuribas> I prefer a set of small, simple expressions, rather than one big complicated one.
10:17:58 <kuribas> The variable name can serve as documentation of what is computed.
10:18:50 <Cin> kuribas: that's what i had in mind
10:19:20 <dons> seriously, anyone want to whip up an arc clone? ..
10:19:26 <dons> i bet it doesn't take 6 years to do, either.
10:19:53 <doserj> well, if it takes 48 hours to write a scheme...
10:20:20 <dons> this who arc/lisp/pg fan base thing is a mystery to me.
10:20:45 <Cin> dons: heh, yeah. the #arc channel already has 50 users just from the hype
10:20:56 <dons> i don't get it.
10:21:03 <dons> the world needs more schemes?
10:21:12 <Cin> pg is a nice guy
10:21:16 <kuribas> dons: arc is not scheme.
10:21:20 <Cin> dons: well i think pg would call it a lisp
10:21:31 <dons> it compiles to mzscheme...
10:21:33 <Cin> he insists on calling procedures "functions"
10:21:54 <Philippa> dons: haskell is not a C
10:22:27 <vincenz> twanvl: nice code
10:22:28 <Philippa> Cin: that's common usage unless you're a pure functional programmer though
10:22:45 <vincenz> twanvl: one thought on it tho
10:22:51 <ehird> Cin: it wouldn't be a sin if it were more like idiomatic scheme (which treats stuff as immutable)
10:23:16 <kuribas> dons: I doubt that people in the scheme world will take arc seriously.
10:23:22 <dons> i agree.
10:23:40 <sjanssen> is anyone taking arc seriously?
10:23:41 <lambdabot> sjanssen: You have 3 new messages. '/msg lambdabot @messages' to read them.
10:23:47 <dons> its just good for further diluting the lisp/scheme community :/
10:25:18 <sjanssen> the only cool thing I saw was the lightweight f:g composition syntax
10:25:24 <twanvl> vincenz: ...?
10:25:31 <vincenz> twanvl: oh, I posted a blog-comment
10:25:38 <vincenz> twanvl: 21 thoughts is yours, right?
10:25:41 <ehird> sjanssen: not that cool. what about packages?
10:25:42 <twanvl> yes
10:25:43 <vincenz> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details#comments
10:25:45 <lambdabot> Title: Simple reflection of expressions - 21 thoughts, http://tinyurl.com/2yeszc
10:25:46 <ehird> package:name is the cleanest, for lisps
10:25:47 <Cin> sjanssen: horribly lispy..
10:25:50 <sjanssen> ehird: I probably didn't get that far
10:25:58 <ehird> it doesn't have them yet
10:25:59 <ehird> amusingly
10:26:04 <sjanssen> ah
10:26:11 <Cin> sjanssen: i would have preferred (: f1 f2 f3 ...)
10:26:13 <vincenz> dons: it's rather silly
10:26:13 <sjanssen> just like it refuses to use Unicode :P
10:26:19 <RayNbow> <sjanssen> is anyone taking arc seriously? <-- no idea, I have only seen the name popping up @ reddit, but I couldn't be bothered to click on the links :p
10:26:29 <vincenz> dons: it's like me "reinventing" Haskell to be Noah, and renaming 'class Monad' to 'class WarmAndFuzzy'
10:26:43 <ehird> vincenz: no, that would be a good change
10:26:44 <ehird> arc is not
10:26:45 <slarba_> vincenz: :))
10:26:56 <sjanssen> vincenz: you forget the part where your write lofty essays about it for 10 years
10:27:08 <vincenz> sjanssen: right :) Have to keep the audience's appetite whetted
10:27:14 <dons> write your own arc in 48 hours...
10:27:19 <Cin> dons: haha
10:27:32 <dons> then we can ponder why it took 6 years
10:27:33 <dolio> That's probably closer to doable than Scheme, really.
10:27:36 <vincenz> dons: hmm, I'm tempted to write a haskell implementation now :)
10:27:47 <dons> very very much so.
10:27:52 <slarba_> me too
10:27:54 <dolio> Since to get a Scheme, technically, you have to do all the stuff in the report.
10:27:57 <dons> its 4k lines of scheme
10:27:58 <slarba_> someone darcs init
10:28:03 <dons> so that's 3k lines of haskell...
10:28:05 <dons> maybe less.
10:28:24 <slarba_> someone must have a sexpr parser ready
10:28:27 <kuribas> dolio: the scheme report is quite small (the old one).
10:28:33 <vincenz> slarba_: that's an hour of work tops
10:28:40 <slarba_> vincenz: true
10:29:19 <vincenz> dons: I dunno, 10 linesat most for the AST
10:29:25 <vincenz> dons: 100-200 lines tops for the parsec parser
10:29:38 <vincenz> 20 lines for statemonad and some nice combinators
10:29:45 <Cin> "write yourself a scheme in 48 hours" should have the sexp parser already :)
10:29:52 <vincenz> < 1000 lines imo
10:29:55 <twanvl> vincenz: You are right that the Eq/Ord instances are dangerous, for instance "gcd 1 2 :: Expr" will diverge.
10:30:11 <vincenz> twanvl: I wish there were a solution for that
10:30:23 <vincenz> twanvl: same thing irked me with Sym that augustss made
10:30:37 <vincenz> slarba_: you good at haskell?
10:30:46 <twanvl> You could try putting the expression in some normal form
10:31:08 <slarba_> vincenz: I speak it :)
10:31:11 * vincenz would be willing to gobby it with someone
10:31:32 <Cin> vincenz: link to darcs repo NAO :P
10:31:41 <slarba_> I just fired emacs and started jotting down the sexpr type & parser
10:32:02 * vincenz checks time
10:32:06 <vincenz> let me go home and I'll join in
10:32:36 <vincenz> slarba_: we should name the post "Build your own Arc in ..."
10:32:45 <slarba_> :D yeah
10:33:06 * sjanssen can see the headline now: "Five #haskellers accomplish in 6 hours what PG accomplished in 6 years" :P
10:33:11 <dons> :)
10:33:35 <sjanssen> in other news, "Static typing not good for exploratory programming, says PG"
10:34:02 <dolio> I'm not sure that's news.
10:34:19 <sjanssen> it's a crock, is what it is
10:34:26 <vincenz> "Noah meant to the next generation Haskell platform, due date 2018, Monads will finally cease to be"
10:35:02 <vincenz> If noah can build it, so can you
10:35:05 <dons> so, who's got the arch repo going?
10:35:15 <dons> arc/ . want something on code.haskell.org ? :)
10:35:20 * vincenz wonders if gobby isn't better idea
10:35:25 <vincenz> this is prolly going to fit in a single file
10:35:43 <ehird> dons: hah, fine, i'll do it
10:35:49 <vincenz> I noticed serious productivity boosts when gobbying during icfpc
10:35:51 <ehird> aww
10:35:53 <ehird> people already started
10:35:54 <ehird> :'(
10:35:58 <Philippa> sjanssen: there're still times it manages to get in my way. I'm usually doing something fairly weird though
10:36:30 <ehird> i always arrive late
10:36:30 <ehird> :P
10:36:39 <vincenz> bbiaba
10:37:00 <dons> seriously, cloning arc in haskell, compiling to ghc (with type erasure..) is a super nice project.
10:37:02 <Cin> philippa: as a haskell newb i've found i simply experience more problems at compile time than runtime (coming from scheme)
10:37:06 <dons> its very cheeky, and you'll learn a lot
10:37:11 <ehird> dons: oh, compiling to ghc?
10:37:15 <ehird> I was just going to interpret
10:37:22 <dons> yeah, get the interpreter first
10:37:29 <dons> then i'd try spitting out haskell code
10:37:36 <Cale> Cin: Which is a better time to have problems, right? :)
10:37:39 <ehird> a compiler written in tempalte haskell
10:37:40 <ehird> :D
10:37:43 <Cin> cale: definitely
10:37:45 <ehird> $(arc "...")
10:37:55 <dolio> Huh, he removed parentheses in let, too.
10:38:15 <ehird> dolio: Yes, it only takes one value now. And you have to do (with (a b c d) ... ) for multiple.
10:38:17 <ehird> It's crazy :P
10:38:21 <Cin> dolio: probably because lets generally only consist of two list items per binding
10:38:58 <Cin> </captain obvious>
10:39:20 <dolio> Heh, and "print" was too long.
10:39:48 <ehird> Cin: no -- it's (let name val ...)
10:39:54 <Valodim> >_<
10:40:01 * Valodim changes nickalert string
10:40:08 <ehird> dolio: also, 'set' is far too verbose
10:40:17 <ehird> let's forget about comparing numbers
10:40:18 <dolio> Yeah, I saw that.
10:40:32 <dolio> Let alone "set!".
10:40:41 <sarehu> note that (let (x y . z) '(1 2 3) ...) puts 1 in x, 2 in y, '(3) in z.
10:41:50 <dolio> Heh, and "not" was too long, too.
10:42:00 <mauke> the problem with let is not the parens around (name val), it's the parens around the whole let
10:42:26 <sebell> mauke: ?
10:42:46 <mauke> I'd prefer something like (block (let x 1) (let y 2) ... (print (+ x y))
10:42:47 <sarehu> Heh, "no:" was too long, too.
10:43:38 <sebell> mauke: DEFINE
10:44:18 <mauke> hmm, a bit long
10:44:38 <sebell> mauke: Oh gosh, just use Arc then ;)
10:45:00 <hpaste>  (anonymous) pasted "conv" at http://hpaste.org/5347
10:45:05 <mauke> what problems does arc solve?
10:45:32 <ehird> to be honest
10:45:37 <sebell> mauke: None that I can immediately see, I was joking because DEFINE is too long for you to type
10:45:42 <ehird> (let (var val var2 val2) ...) is the sanest..
10:45:53 <sarehu> mauke: scheme's names are too long (serious)
10:45:54 <monochrom> arc solves the personal problem of wanting a slightly different language. :)
10:45:56 <mauke> ehird: for the compiler maybe
10:46:06 <ehird> no mauke, that's harder for the compiler
10:46:15 <roconnor> (let let 5)
10:46:20 <ehird> but the paren-fest you get with most lets is crazy
10:46:27 <ehird> still, arc's let is NOT a solution
10:46:45 <mauke> you get a paren-fest if you don't have implicit nesting
10:47:33 <kuribas> The good thing about the (let ((a b) ...)) is that it makes refactoring easy.
10:48:05 <sebell> Especially if you are using a quasi-structural editor, which you should be.
10:48:07 <sarehu> (let ((a b) ...)) is really just fine
10:48:10 <sclv_> arc also includes some network bindings, etc. as i understand it. so a haskell arc would have to be able to run, e.g., the example bog app.
10:48:14 <sclv_> s/bog/blog/
10:48:17 <shag> is there something like the update function from IntMap for ordinary lists?
10:48:52 <ehird> sebell: a quasi-structural editor could determine stuff about let
10:48:57 <mauke> (block (my $foo 41) (incf $foo) (print "foo = $foo"))  ;; hah!
10:49:10 <sarehu> shag: what's the intmap update function?
10:49:13 <dolio> So, "is" tests for value equality, except on lists, where you have to use "iso"?
10:49:14 <ehird> is anyone actively working on an arc in haskell? if not, who wants to help me? just for the ridiculousness of it :P
10:49:25 <sclv_> interpreted would have to provide its own REPL, and also do tail recursion (rewrites to continuation passing style maybe?)
10:49:38 <ehird> sclv_: and provide continuations
10:49:38 <dolio> Arc strings are mutable, right?
10:49:39 <ehird> since arc has them
10:49:41 <scodil> sarehu: there isn't one i don't think. IntMap's interface lags. I wish it was better kept up.
10:49:42 <ehird> it's called ccc
10:49:43 <sarehu> dolio: yes
10:49:51 <ehird> i'll set up a darcs repo? :-)
10:49:51 <kuribas> ehird: I am interested in writing a sexp parser in haskell.
10:49:56 <ehird> kuribas: trivial
10:49:57 <shag> sarehu: i just found exactly what i need: mapMaybe. But it is in the maybe module and i only searched in Data.List ...
10:50:14 <kuribas> ehird: yes, but one conforming to r5rs.
10:50:30 <ehird> kuribas: also trivial
10:50:32 <ehird> (same for arc)
10:50:39 <dons> ehird: ok. so the first thing is to get a repo in place
10:50:43 <ehird> dons: yes
10:50:44 <dons> that people can commit to.
10:50:51 <dons> can you host something that's publically pullable?
10:50:51 <ehird> astonishing logic there
10:50:53 <ehird> how do you do it? ;)
10:50:57 <ehird> dons: yes
10:51:03 <dons> since it takes a day to get something on code.haskell.org
10:51:04 <ehird> but pushable only via ssh accounts, but that's ok
10:51:17 <dons> once a bit of code lands for the parser, it'll quickly grab people
10:51:18 <sarehu> shag: well, [keep idfn (map f _)] is sort of like (mapMaybe f)
10:51:20 <kuribas> The scheme in 48 hours scheme parser doesn't parse R5RS scheme.
10:51:28 <ehird> dons: i'll work on that once i've got  repo up
10:51:30 <dons> but its a good place to start
10:51:40 <dons> the resulting code should read like a tutorial for haskell..
10:51:44 <ehird> hm, need to name the repo... just 'arc' for now, i guess
10:51:51 <ehird> dons: non-linear tutorial. sounds nice ;)
10:52:00 <dons> hmm.
10:52:13 <ehird> -- well, as long as it doesn't have to be literate haskell
10:52:14 <ehird> heh
10:52:17 <dons> circle? (it completes the arc)
10:52:32 <ehird> that's ridiculous, i like it
10:53:03 <taruti> There is no libghc6-network-dev for ghc 6.8 in debian on i386? Or am I missing some repository?
10:53:19 <ehird> http://elliotthird.org/circle/
10:53:20 <lambdabot> Title: Index of /circle/
10:53:28 <ehird> will be the publically pullable darcs repo url.
10:53:31 <sarehu> either that or chord
10:53:50 <radix> tangent? that probably already exists
10:53:54 <ehird> dons: i think a multiple-file way might be better, so the newbie can navigate through everything simply
10:54:09 <ehird> + it would demonstate the use of modules in haskell
10:55:42 <ehird> a simple structure, though, to make things easy for them...
10:56:35 <ehird> so something like: circle/README (etc.), circle/src/Main.hs (the main program, obviously), circle/src/Circle.hs (core stuff like the value type), circle/src/Circle/* (the modules)
10:57:18 <dolio> > insertWith (<) 4 [1,2,3,5,7,9]
10:57:19 <lambdabot>   Not in scope: `insertWith'
10:58:03 <sarehu> > insertBy compare 4 [1,2,3,5,7,9] -- prays
10:58:05 <lambdabot>  [1,2,3,4,5,7,9]
10:58:20 <dolio> Ah, there we are.
10:58:35 <sarehu> > insert 4 [1,2,3,5,7,9]
10:58:36 <lambdabot>  [1,2,3,4,5,7,9]
10:58:47 <Deewiant> @src insert
10:58:47 <lambdabot> insert e ls = insertBy (compare) e ls
10:58:57 <dolio> I like Arc's name for that. "insort"
10:59:05 <ehird> insnort
10:59:17 <sarehu> introsort
10:59:23 <ehird> introsnort
10:59:26 <mauke> storin
10:59:35 <ehird> hey, i just realised!
10:59:40 <ehird> we can get away without implementing a lot
10:59:45 <ehird> because the stdlib is written in arc
10:59:47 <ehird> >:D
10:59:55 <Cin> idsFromChans chans = nub . concat . map (channelIds . (chans Map.!))
11:00:00 <Cin> i love function composition so much
11:01:07 <Deewiant> @pl idsFromChans chans = nub . concat . map (channelIds . (chans Map.!))
11:01:07 <lambdabot> idsFromChans = ((nub . join) .) . map . (channelIds .) . (.!) . ($ Map)
11:01:36 <dons> ehird: oh good
11:01:43 <mauke> @unpl idsFromChans chans = nub . concat . map (channelIds . (chans Map.!))
11:01:43 <lambdabot> idsFromChans chans d = nub (concat (map (\ j -> channelIds ((Map.!) chans j)) d))
11:02:14 <ehird> dons: basically we have to implement ac.scm, but moreso since we can't compile to scheme or use its parser, etc
11:02:24 <dons> can we make our arc support utf8 from the start??
11:02:28 <ehird> 1094 lines of code, with comments and blank lines
11:02:29 <ehird> so.
11:02:36 <dons> that would be a key differentiation point...
11:02:44 <ehird> dons: but then it isn't snarky commentary on how much Arc is trivial suckiness..
11:02:51 <ehird> :)
11:02:59 <dons> well, it would be. and snarkier since we have utf8
11:03:00 <dons> :)
11:03:03 <ehird> this is a good point
11:03:07 <dons> use the utf8-string and internal Char/String types
11:03:09 <ehird> String is utf-8 isn't it? by default
11:03:18 <dons> its a 32 bit unicode value.
11:03:22 <ehird> ah
11:03:24 <dons> so if you do utf8 io, then its fine.
11:03:25 <dolio> Hey, you don't even need to make hygienic macros. :)
11:03:28 <Deewiant> it's utf-32? O_o
11:03:32 <ehird> dons: and how do we do that? ;)
11:03:39 <dons> you just use Char for everything
11:03:42 <ehird> dolio: it's like how Pascal was designed to be easy to compile! :D
11:03:52 <ehird> dons: so default I/O using Char and String is utf-8?
11:03:54 <ehird> awesomecakes
11:03:56 <dons> and instead of putStr/ etal use the utf8-string package's IO ops
11:03:59 <ehird> ah
11:04:05 <dons> ehird: no. the utf8-string I/O is utf8
11:04:10 <sclv_> utf-8 should come for free, yeah. if you want to make it snarky, you could write an additional library and explain "if you want a *real* arc you need to add this extra code to disable utf-8 support"
11:04:10 <ehird> better get cabal install on here
11:04:11 <dons> so use that package for io
11:04:18 <dons> sclv_: :)
11:04:22 <ehird> sclv_: no no, a patch!
11:04:23 <ehird> :D
11:04:27 <vincenz> re
11:04:28 <ehird> a patch adding 50 lines of code
11:04:41 <sclv_> absolutely!
11:04:44 <dolio> ehird: The correct way to do things is to discourage the noob illusion that you shouldn't have to have all your macros memorized.
11:04:48 <vincenz> slarba_: ping
11:04:49 <dons> http://mooseyard.com/Jens/2008/01/96-characters-ought-to-be-enough-for-anyone/ more stuff
11:04:50 <lambdabot> Title: 96 Characters Ought To Be Enough For Anyone &mdash; Thought Palace, http://tinyurl.com/2hnuzh
11:04:55 <dons> (about arc)
11:05:14 <ehird> dons: cool utf8-string mauls up System.IO
11:05:18 <ehird> So we don't have to do anything!
11:05:21 <ehird> Just import it. Right?
11:05:23 <dons> ehird: right.
11:05:29 <Deewiant> "mauls up" :-P
11:05:31 <Cin> i am laughing out loud at the channel right now
11:05:36 <dons> hide Prelude's putStr/getContents et al
11:05:37 * Cin wipes tears from eyes
11:05:45 <vincenz> Cin: why?
11:05:50 <vincenz> slarba_: ping ping
11:05:56 <ehird> dons: hm, I think the module should be Arc, not circle
11:06:00 <ehird> but the repo can be circle
11:06:01 <dons> #haskell is a punk movement. we like throwing stones and molotov cocktails
11:06:04 <ehird> just to be snarky
11:06:07 <dons> ehird: :)
11:06:10 <ehird> because we can then have the Arc package actually utf-8
11:06:15 <Cin> vincenz: " < ehird> sclv_: no no, a patch!" "< ehird> a patch adding 50 lines of code"
11:06:21 <ehird> question: do you think reddit will get the joke? I think not!
11:06:34 <vincenz> lol
11:06:36 <dons> hopefully they see it as a faster, cleaner, utf8 friendly arc:)
11:06:38 <ehird> even better: if paul graham congratulates us
11:06:41 <ehird> :D
11:06:44 <dons> and we further divide and conquer the lisp community
11:06:48 <vincenz> ehird: fanboy
11:06:51 <dons> dragging more over to haskell as a result
11:06:52 <ehird> vincenz: no, but amusing
11:06:54 <dons> :)
11:06:56 <ehird> dons: evil, very evil :)
11:06:57 <Cale> hehe
11:07:06 <Cin> dons: the funny thing is mzscheme gives you UTF8 support by defalt, so why Arc doesn't support UTF8 is because pg is mad
11:07:06 <vincenz> so who do I need to join?
11:07:08 <ehird> maybe paul graham will switch to haskell, and proceed to ruin it with his code
11:07:21 <vincenz> ehird: I told you
11:07:28 <vincenz> ehird: Noah, the New Optimized Alternative Haskell
11:07:34 <vincenz> ehird: 2018 is the release date
11:07:38 <ehird> vincenz: brilliant
11:08:03 <ehird> I think that once we get the sample blog app running under our implementation, we should put it online with loads of japanese and other languages articles
11:08:07 <Cale> vincenz: hahaha
11:08:12 <ehird> snarky :D
11:08:15 <vincenz> who's working on arc in haskell?
11:08:26 <ehird> vincenz: me, other people once i've got the base structure down
11:08:33 <vincenz> ehird: gobby it
11:08:43 <ehird> > gobby
11:08:44 <lambdabot>   Not in scope: `gobby'
11:08:44 <ehird> oh
11:08:47 <ehird> the collab editor?
11:08:47 <ehird> naw
11:09:19 <Cale> gobby is fun :)
11:09:23 <olsner> gobby it, you'll get all of #haskell hacking simultaneously :P
11:09:23 <vincenz> yeah
11:09:23 <ehird> hey, my first cabal file that the rest of the world will see! ;)
11:09:36 <ehird> olsner: does gobby play well on os x?
11:09:40 <ehird> + with haskell?
11:09:43 <Cale> ehird: yeah, it should
11:09:45 <dolio> Well, that was an entertaining document.
11:09:51 <olsner> it plays well with any kind of text afaik
11:09:52 <ehird> gobby is gtk, isn't it? :P
11:09:53 <vincenz> Cale: want t gobby?
11:10:01 <ehird> yep
11:10:01 <ehird> x11
11:10:02 <ehird> xD
11:10:09 <vincenz> ehird: hving only you do the base structure is kind of sequentialising the #haskell channel
11:10:19 <vincenz> ehird: we did gobby for the launch of modules in our team, and it was really efficient
11:10:20 <ehird> vincenz: i meant directory structure
11:10:23 <ehird> heh
11:10:27 <vincenz> you mean src?
11:10:32 <vincenz> seriously
11:10:35 <vincenz> arc-in-haskell.lhs
11:10:38 <vincenz> that's all you need
11:10:45 <ehird> vincenz: see above
11:10:50 <monochrom> where is arc-in-haskell.lhs ?
11:10:52 <Cale> I actually have to do something for an econ course, but I'll join in once that's done :)
11:11:02 <vincenz> Cale: well I am portblocked :|
11:11:06 <ehird> vincenz: well, way above
11:11:07 <ehird> :)
11:11:19 <olsner> ehird: sudo port install gobby ;-)
11:11:42 <ehird> hm
11:11:47 <monochrom> #haskell is a sequencing monad.
11:11:48 <ehird> version number 0.1, i think that's a bit hard on us
11:11:53 <ehird> i'm sure that pg's is 0.1
11:11:55 <ehird> and ours is 5.4
11:12:11 <vincenz> 3.14
11:12:13 <vincenz> that's a proper arc
11:12:15 <ehird> Author:             #haskell -- heh
11:12:22 <monochrom> This is your last chance to establish some kind of "3.14159" version numbering!
11:12:26 <ehird> vincenz: our version should approach pi
11:12:26 <vincenz> yeah!
11:12:32 <ehird> hm
11:12:34 <monochrom> @fugue
11:12:34 <lambdabot> Unknown command, try @list
11:12:38 <monochrom> @quote fugue
11:12:38 <lambdabot> monochron says: "Welcome to #haskell, where your questions are answered in contrapuntal fugues."
11:12:40 <ehird> pick a crappy method of calculating pi, step through that each version?
11:12:54 <monochrom> hahahaha
11:13:00 <ehird> 'continually approaching the perfect arc!'
11:13:02 <vincenz> ehird: yes, preferably something that requires a lot of runtime to calculate
11:13:06 <ehird> vincenz: haha
11:13:07 <vincenz> you know
11:13:08 <ehird> and write it in arc
11:13:12 <vincenz> 6 years for 10 digits
11:13:27 <monochrom> That's hard to do.
11:13:34 <ehird> but aren't we trying to show we can do in a day what PG took years to do? :P
11:13:41 <vincenz> well sure
11:13:43 <vincenz> for version 3.14
11:14:02 <Maddas> ehird: But copying something bad doesn't make it good, no matter how long it took to become so bad...
11:14:05 <vincenz> but do you -really- want to go past 64 bits in the next 100 years?!?
11:14:14 <sarehu> this is kind of silly... it took years not for the implementation, but for coming up with names like 'fn' and 'do'
11:14:30 <ehird> sarehu: that's kind of silly too :D
11:14:32 <ehird> Maddas: this is true
11:14:35 <ehird> hmm, Leibniz series
11:14:36 <monochrom> Naming is hard. Let's go numbering!
11:14:39 <ehird> all agreed?
11:14:43 <vincenz> ehird: yah
11:14:43 <sarehu> monochrom++
11:14:58 <vincenz> sarehu: especially if your language has macros :)
11:15:09 <vincenz> oh-noes-, I don't want car
11:15:17 <vincenz> i want teh-first-element-from-tha-lists
11:15:23 <ehird> calculated with a silly JS calculator to show we don't care about version numbers! anarchic.
11:15:23 <vincenz> (define teh-first-element-from-tha-lists car)
11:15:24 <ehird> http://sethborders.googlepages.com/Calculatepi.html
11:15:25 <lambdabot> Title: aproximate &pi;
11:15:37 <dolio> vincenz: Nah, that's Scheme.
11:15:37 <monochrom> "keyword493 name293 name3944 = name2933 | name2934 name3944 (name293 name3944)
11:15:40 <ehird> i think we should just use the first 2 decimal places of all of those :P
11:16:01 <ehird> hmm, does cabal break if version numbers go DOWN?
11:16:10 <vincenz> how can they go down
11:16:13 <vincenz> if you add digits, they go up
11:16:33 <monochrom> can-haz-first-element
11:16:33 <vincenz> ehird: otherwise, take the uneven versions
11:16:34 <vincenz> they go up
11:16:44 <vincenz> after all, arc -is- odd
11:16:46 <olsner> hmm, so what's the difference between set, def and = in arc?
11:16:50 <ehird> good idea
11:16:56 <ehird> so
11:16:58 <ehird> version one: 2.66
11:17:10 <ehird> (Author: #haskell, of course)
11:17:16 <dolio> Does arc have set?
11:17:16 <vincenz> ehird: we had 6 years and 12 months
11:17:20 <ehird> dolio: it's called =
11:17:21 <vincenz> ehird: so 72*2+1
11:17:25 <vincenz> > 72*2+1
11:17:25 <lambdabot>  145
11:17:28 <dolio> Right, that's what I thought.
11:17:45 <vincenz> ehird: 3.1347
11:17:49 * olsner is just reading through the arc "prelude"
11:18:04 <vincenz> olsner: I love his deep comments at the top
11:18:09 <vincenz> olsner: mostly syntax related
11:18:12 <vincenz> or just plain naming :)
11:18:16 <ehird> vincenz: 3.13, surely ;)
11:18:49 <vincenz> data Arxpr = AIf Arxpr [Arxpr]
11:18:52 <vincenz> | ..
11:19:10 <slarba_> uh
11:19:32 <vincenz> want me to roll 0.1 of the datatype and stick it on hpaste for review?
11:19:35 <jedbrown> #haskell spends 5 hours discussing what the version number should be, then one hour writing an Arc compiler.
11:19:43 <sebell> vincenz: Go for it
11:19:57 <monochrom> @remember jedbrown #haskell spends 5 hours discussing what the version number should be, then one hour writing an Arc compiler.
11:19:57 <lambdabot> Done.
11:20:06 <slarba_> data ArcExpr = ArcList [ArcExpr] | ArcInt Int | ArcChar Char | ArcReal Double | ArcSymbol String | ArcString String
11:20:38 <ehird> jedbrown: Wrong: 5 hours writing cabal file
11:20:40 <olsner> remember - after the discussion of the version number is complete, we have *one hour* to complete this thing, or the quote is wrong!
11:21:07 <slarba_> would that be a good start?
11:21:13 <jedbrown> ehird: heh, mkcabal?
11:21:25 <ehird> jedbrown: sure, what's the darcs url again? :P
11:21:31 <dons> hackage.haskell.org
11:21:34 <dons> grab mkcabal
11:21:38 <dons> populate the dir
11:22:03 <olsner> does ArcList [ArcExpr] properly handle dotted lists?
11:22:17 <slarba_> nah.
11:22:19 <slarba_> no
11:22:23 <slarba_> so we change that
11:22:37 <ehird> simple:
11:22:47 <ehird> ArcList [ArcExpr] | ArcDotted [ArcExpr] ArcExpr
11:22:56 <slarba_> yep
11:23:22 <hpaste>  vincenz pasted "Arc Expr" at http://hpaste.org/5348
11:23:47 <vincenz> you can easily quote and quasiquote my version
11:23:50 <slarba_> hey, why control structures are in that type?
11:23:53 <ehird> yeah
11:23:55 <ehird> you don't need that
11:23:56 <ehird> :|
11:24:10 <slarba_> would it just be better to have plain symbols "if"
11:24:11 <slarba_> etc
11:24:15 <ehird> yes
11:24:17 <ehird> anyway
11:24:19 <ehird> cabal is almost done ;)
11:24:31 <vincenz> slarba_: I like ASTs
11:24:37 <ehird> vincenz: not for lisp
11:24:42 <ehird> it would make the compiler more verbose.
11:24:42 <Nucleo> @pl \x -> x+1
11:24:42 <lambdabot> (1 +)
11:24:49 <ehird> @hackage zlib
11:24:49 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib
11:24:54 <ehird> stoopid fresh ghc install
11:24:54 <slarba_> and quote and quasiquote come from the parser '(..) => (quote (..)) and `(..) => (quasiquote (..))
11:25:10 <vincenz> slarba_: not if you quote in a macro
11:25:16 <slarba_> otherwise macros become hard to implement
11:25:19 <ehird> vincenz: yes they do
11:25:22 <vincenz> make macros first-class :)
11:25:26 <ehird> vincenz: they are, in arc.
11:25:41 <ehird> (Just to be so superior to arc we should have a configurable readtable.. but later, because parsec will be easier for now)
11:25:57 <vincenz> just cause everything is a list in lisp doesn't mean you have to stoop to that level in a haskell implementation
11:26:11 <cjb> Sorry, newbie question:  is there a way to see the definition of a function (lambdabot's 'src') in ghci?
11:26:21 <ehird> @hackage HTTP
11:26:21 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP
11:26:36 <monochrom> cjb: sorry, no.
11:26:37 <pjd> cjb: besides just looking up the source?
11:26:47 <cjb> pjd: yes.
11:26:49 <cjb> monochrom: ah
11:26:51 <sjanssen> cjb: you can use :info to see the module it is defined in
11:27:01 <ehird> Network/HTTP.hs:149:7:
11:27:01 <ehird>     Could not find module `Data.Array.MArray':
11:27:01 <ehird>       it is a member of package array-0.1.0.0, which is hidden
11:27:02 <ehird> what the HELL
11:27:03 <ehird> :|
11:27:05 <sjanssen> cjb: and keep a copy of the library source to read it
11:27:26 <sjanssen> ehird: that version of HTTP has probably not been updated for GHC 6.8
11:27:30 <Cin> pretty sure you can get a lambdabot mode for ghci
11:27:57 <ehird> sjanssen: well cabal-install depends on it.
11:28:10 <desegnis> Cin, that's ghci on acid, but you need to be able to compile lambdabot in order to use it...
11:28:11 <dons> something that's underappreciated about haskell ---
11:28:18 <dons> when you're a commercial dev, and you have some big project
11:28:21 <sjanssen> ehird: which version are you using?
11:28:32 <dons> you can safely, and intentionally, *break* it, and let the type checker guide you through the next iteration
11:28:32 <ehird> sjanssen: the cabal-install tarball from hackage
11:28:45 <ehird> Configuring cabal-install-0.4.0...
11:28:46 <ehird> runhaskell SSetup.lhs: At least the following dependencies are missing:
11:28:46 <ehird>     zlib >=0.3, HTTP >=3000.0&&<3001.1
11:28:56 <monochrom> Get HTTP-3001.0.4 for ghc 6.8.2
11:29:06 <RayNbow> dons: intentionally break it?
11:29:07 <sjanssen> HTTP-3001.0.4 built fine here
11:29:25 <ehird> @hackage hTTP
11:29:26 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hTTP
11:29:48 <monochrom> @hackage IDontExist
11:29:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/IDontExist
11:29:54 * monochrom giggles
11:30:09 <olsner> dons: you mean like refactoring and letting the typechecker tell you when you've done it right?
11:30:24 <monochrom> @hackage HaltingProblemSolver
11:30:25 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HaltingProblemSolver
11:30:33 * monochrom giggles more
11:30:34 <ehird> heh
11:30:53 <Taejo> monochrom: whut?
11:31:06 <monochrom> @faq Can Haskell solve the Halting Problem?
11:31:06 <lambdabot> The answer is: Yes! Haskell can do that.
11:31:18 <olsner> Taejo: did you miss it? monochrom wrote it last week
11:31:43 <Taejo> olsner: damn, it must have paradoxed itself out of existence before I saw it
11:31:52 <ehird> okay, almost got the base repo up
11:31:54 <ehird> sheesh, stuypid ghc
11:32:02 <Taejo> ok, own up: who ran the halting solver on itself?
11:32:12 <ehird> me
11:32:55 <ehird> dhsfglhdjklsfgldfghslhjkdfgshjlkdfgshjfdghkljfdhfjkdfhjksdgldfhskglfhkdjgshfkdjdfghjs
11:33:02 <ehird> mkcabal doesn't want to build because it uses a regexp lib
11:33:05 <ehird> which doesn't want to
11:33:09 <hpaste>  slarba_ pasted "Arc expression, suggestion 2" at http://hpaste.org/5349
11:33:11 <ehird> Base.hsc:103:18:  error: pcre.h: No such file or directory
11:33:11 <ehird> oh
11:33:27 <ehird> seriously people i'm sure we can handle a lisp value type ourselves, i don't think we need hpastes
11:33:28 <ehird> :P
11:33:28 <monochrom> need a C lib perhaps
11:33:41 <ehird> good thing pcre is quick to compile
11:34:17 <monochrom> Nothing can handle design by committee.
11:34:53 <vincenz> slarba_: suggestion, break out literals
11:34:58 <ehird> argh i need to make cabal see my libs
11:35:30 <ehird> OK
11:35:32 <ehird> to hell with mkcabal
11:35:33 <ehird> :|
11:36:22 <ehird> OK finally
11:36:29 * monochrom attempts "bug-directed programming"
11:36:33 <ehird> I'm about to push. Who wants darcs access?
11:36:51 <ehird> also
11:36:55 <ehird> your people's ArcExprs are BROKEN
11:37:04 <ehird> All that stuff needs to be mutable.
11:37:09 <yrlnry> Hi, folks.  Suppose I have   foo (Con x) = bar (baz x).  If I were defining foo for a raw x value, I might use point-free style and write  foo = bar . baz.   But foo is not a function of x directly, but of (Con x), where Con is a constructor.  What can I do instead?  The best solution I have thought of is  foo (Con x) = bar . baz $ x  .
11:37:13 <vincenz> no it doesn't, use state monad
11:37:23 <ehird> vincenz: it does if we want the interpreter to look sane
11:37:35 <Deewiant> @pl foo (Con x) = bar (baz x)
11:37:35 <lambdabot> (line 1, column 13):
11:37:35 <lambdabot> unexpected "="
11:37:35 <lambdabot> expecting variable, "(", operator or end of input
11:37:38 <jedbrown> ehird: darcs pull http://59A2.org/code/circle
11:37:45 <ehird> Well
11:37:45 <Deewiant> meh
11:37:48 <ehird> jedbrown: uh
11:37:49 <ehird> too late.
11:37:54 <ehird> i already set up a repository, years ago
11:38:13 <jedbrown> ehird: Then put it wherever you want.  (I ran mkcabal.)
11:38:14 <yrlnry> I could do deCon (Con x) = x  and then foo = bar . baz . deCon, but that seems somewhat obscure.
11:38:15 <Deewiant> yrlnry: I think foo (Con x) = bar $ baz x is the best you can do
11:38:27 <jedbrown> ehird: My repo won't take public commits anyway.
11:38:29 <EvilTerran> yrlnry, can you change the data type definition?
11:38:37 <yrlnry> Sure, I can change anything I want to.
11:38:59 <yrlnry> But really my question is more "What do people do in this sort of situation," and the answer can't always be "don't use type constructors".
11:39:15 <EvilTerran> so you've got something like data Foo a = Con a
11:39:21 <ehird> Okay, who wants darcs push access?
11:39:23 <monochrom> My first attempt would be "don't point-free".
11:39:28 <ehird> Then we can get the ball rolling..
11:39:43 <olsner> Jedai: invalid repository?
11:39:48 <EvilTerran> if you make that data Foo a = Con { getCon :: a }, it's just like the old definition, except you also get a function getCon :: Foo a -> a
11:39:51 <monochrom> My second attempt would be "write a 'fold' aka 'catamorphism' for my data type, then I can point-free"
11:39:55 <ehird> olsner: wrong repo anyway
11:40:00 <ehird> i've committed cabal files and everything
11:40:07 <olsner> jedbrown* that was intended for
11:40:10 <desegnis> yrlnry: You might consider having a Functor instance, though that will change the type of foo
11:40:14 <EvilTerran> yrlnry, and then foo = Con . bar . baz . getCon
11:40:22 <ehird> (By the way, using a state monad is silly. Since all of our functions can do IO at any time (yum, lisp), we just use (IORef ArcExpr)s, since we are in the IO monad anyway.)
11:40:23 <yrlnry> EvilTerran: Is that a ghci extension or something?
11:40:32 <EvilTerran> no, it's fully h98
11:40:34 <monochrom> You don't need "Con ."
11:40:47 <jedbrown> olsner, ehird: sorry, that's fixed.
11:40:47 <Deewiant> yrlnry: you could also make a function that applies a function to the value within a Con
11:40:48 <cjb> Is goa (the ghci lambdabot extension) still maintained/working?
11:40:56 <EvilTerran> monochrom, er, true. mis-read the original there ;)
11:40:57 <dolio> ehird: That sounds terrible. :)
11:41:01 <yrlnry> Okay, thanks all.
11:41:33 <ehird> dolio: best solution when interpreting an ugly language like this
11:41:41 <monochrom> The fun begins when it's "data Foo a = Con a | Snd a (Foo a) Int Bool" or more cases.
11:41:45 <conal> yrlnry: i like the deCon & (.) approach.  "unCon" or "getCon" seem to be popular choices.  and you can define it directly in your newtype.
11:41:47 <EvilTerran> yrlnry, have a look at http://haskell.org/onlinereport/exps.html#field-ops
11:42:02 <monochrom> Thus my catamorphism suggestion predates anyone's attention.
11:42:03 <desegnis> yrlnry: also, if you have data Foo a = Con a, most people would use a newtype instead of an algebraic data type
11:42:03 <yrlnry> My next question is: I want to sum up only the even-index elements of a list.  Right now I am using foldr (+) 0 . zipWith (*) (cycle [0,1])  lst   which I do not like, because it is too indirect.
11:42:08 <yrlnry> What's a better way to do this?
11:42:12 <ehird> So:
11:42:19 <ehird> Who wants push rights?
11:42:26 <yrlnry> EvilTerran: thanks very much for the reference.
11:42:34 <EvilTerran> yrlnry, i think the normal way would be to define mutually-recursive functions "evens" and "odds"
11:42:44 <mauke> yrlnry: foldr (+) 0 == sum
11:42:46 <ehird> nobody? ;)
11:42:49 <monochrom> I would write a list function mapping a list to the list of even-indexed elements.
11:42:57 <yrlnry> mauke: Oh, right.  I was going to do that, and I forgot to.  Thanks.
11:43:14 <EvilTerran> evens [] = []; evens (x:xs) = x : odds xs; odds [] = []; odds (x:xs) = evens xs -- or something
11:43:21 <yrlnry> So there's no clever way to use something in the standard prelude to do this?
11:43:29 <conal> yrlnry: or a function that returned both the evens and the odds.  if you don't want the odds just compose with fst or snd.
11:43:29 <yrlnry> I mean, I do know how to write a recursive function.
11:43:33 <EvilTerran> well, there's dubious hacks
11:43:35 <monochrom> Not off my head.
11:43:37 <Deewiant> Well, "clever" is a matter of opinion
11:43:57 <yrlnry> Okay, that's fine.  I just thought there might be some straightforward list comprehension solution or something.
11:44:11 <Deewiant> > (sum . map snd . filter (even.fst) . zip [0..]) [1..10]
11:44:12 <lambdabot>  25
11:44:13 <EvilTerran> > map head . takeWhile (not.null) . iterate (drop 2) $ [0..]
11:44:14 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
11:44:15 <Deewiant> or something
11:44:38 <Deewiant> > (map snd . filter (even.fst) . zip [0..]) [0..]
11:44:39 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
11:44:43 <Deewiant> shorter, I win
11:44:58 <vincenz> ehird: gimme
11:44:59 <yrlnry> Okay, I didn't mean to start everyone playing golf.
11:45:01 <mauke> > map snd . filter fst . zip (cycle [True, False]) $ [0..]
11:45:01 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
11:45:19 <EvilTerran> Deewiant, mine is probably more efficient, tho
11:45:26 <vincenz> ehird: I still think gobby's better for something this small, higher interaction speed
11:45:29 <Deewiant> Probably, ye
11:45:32 <jedbrown> > map head . iterate (drop 2) $ [0..]
11:45:32 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
11:45:33 <monochrom> The evens and odds list functions are the most efficient.
11:45:37 <Deewiant> Yep.
11:45:57 <EvilTerran> and map(take n).takeWhile(not.null).iterate(drop m) is a pretty common pattern
11:46:11 <EvilTerran> (used slightly modified in my version)
11:46:20 <Deewiant> It is? What does it do in general?
11:46:36 <monochrom> Obtain n elements in every m-element chunk
11:46:47 <EvilTerran> > map (take 3) . takeWhile (not.null) . iterate (drop 3) $ [1..10]
11:46:48 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
11:46:49 <Deewiant> Cool
11:47:02 <EvilTerran> > map (take 2) . takeWhile (not.null) . iterate (drop 3) $ [1..10] -- not quite so handy, but still occasionally useful
11:47:03 <lambdabot>  [[1,2],[4,5],[7,8],[10]]
11:47:05 <ehird> vincenz: okies
11:47:11 <ehird> just a sec
11:47:25 <Deewiant> > iterate (drop 3)
11:47:25 <lambdabot>  Add a type signature
11:47:34 <Deewiant> @ty iterate (drop 3)
11:47:35 <lambdabot> forall a. [a] -> [[a]]
11:47:40 <EvilTerran> > iterate (drop 3) [1..10]
11:47:41 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[4,5,6,7,8,9,10],[7,8,9,10],[10],[],[],[],[],[],[],[...
11:48:18 <vincenz> takeWhile (not . null)
11:49:00 <EvilTerran> > unfoldr ((>>)<$>guard.not.null<*>return.splitAt 3) [1..10]
11:49:01 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
11:49:17 <Deewiant> ew
11:50:30 <EvilTerran> yeah, in most cases, if it looks like you're going to need unfoldr, it's generally better to just use explicit recursion, imo
11:50:40 <ehird> *Arc> ArcDotted [ArcInt 1, ArcInt 2] (ArcChar 'h')
11:50:40 <ehird> (1 2 . #\h)
11:50:42 <ehird> not bad ;)
11:50:48 <vincenz> ehird: linky?
11:51:05 <ehird> vincenz: just pushing now
11:51:09 <ehird> then i'll add an account for you
11:51:13 <vincenz> okies
11:52:44 <hpaste>  vincenz pasted "vincenz's pubkey" at http://hpaste.org/5350
11:53:12 <slarba_> where's the rep?
11:53:23 <slarba_> I missed it
11:53:29 <monochrom> Yay, test case for my new factorer!
11:54:00 * vincenz thinks monochrom smokes a lot
11:54:09 <monochrom> haha
11:54:23 <vincenz> happy-weed :)
11:54:38 <ehird> slarba_: do you want push access or just pull
11:55:10 <ehird> beh
11:55:12 <ehird> darcs push is breaking
11:55:15 <ehird> let me recreate the repo.
11:55:43 * byorgey thinks everyone in #haskell has been smoking a lot.
11:55:53 * halides *coughs*
11:55:53 <dcoutts> @arr!
11:55:53 <lambdabot> I'll crush ye barnacles!
11:56:06 <Nafai> Not me!
11:56:17 <slarba_> ehird: well push would be nice
11:56:31 <dons> ehird: the mkcabal issue is because youu don't have pcre.h installed
11:56:42 <byorgey> hi dcoutts, Nafai, halides =)
11:56:54 <dcoutts> hia byorgey
11:57:04 <dcoutts> dons: so when are you going to integrate mkcabal into cabal-install? :-)
11:57:07 <ehird> dons: yeah, i do, just cabal doesn't want to look at it
11:57:09 <dcoutts> $ cabal init
11:57:10 <ehird> slarba_: okay
11:57:20 <dons> dcoutts: yeah. good idea.
11:57:27 <dons> i can toss that into the hackage hacking i think
11:57:36 <dcoutts> dons: http://hackage.haskell.org/trac/hackage/ticket/171
11:57:38 <lambdabot> Title: #171 (Add command to automagically create an initial cabal package) - Hackage -  ...
11:57:43 <dons> ok. awesome
11:58:00 <ehird> modules imported in X are available from X.Y
11:58:01 <ehird> true/false
11:58:15 * byorgey promises dons a ++ for 'cabal init' =)
11:58:17 <mauke> false
11:58:19 <vincenz> ehird: no bools/
11:58:22 <ehird> kay
11:58:31 <ehird> vincenz: there are none in arc, iirc
11:58:34 <ehird> nil == () == false
11:58:36 <ehird> but there might be a true
11:58:39 <ehird> if its wacky
11:58:46 <BMeph69> yrlnry: I took a page out of the "divMod" book, and 1) made a function that splits a list into a pair of lists, then pick which one of the pair I want.
11:59:12 <BMeph69> unriffle [] = ([],[]); unriffle (y:ys) = let (p,q) = unriffle ys in (y:q,p)
11:59:15 <ehird> yikes
11:59:17 <ehird> arc has #f
11:59:19 <ehird> for no reason at all
11:59:19 <ehird> :|
11:59:23 <hpaste>  vincenz pasted "arc proposal" at http://hpaste.org/5352
11:59:24 <ehird> scheme blah.
11:59:28 <vincenz> ehird: look at that
11:59:30 <slarba_> ah!
11:59:36 <EvilTerran> ehird, does it have #t ?
11:59:38 <vincenz> ehird: can I push that?
11:59:39 <slarba_> booleans are missing from ArcExpr
11:59:43 <ehird> vincenz: absolutely no need
11:59:45 <ehird> this way is a lot easier
11:59:52 <ehird> slarba_: yes
11:59:54 <vincenz> ehird: I always split up literals and usually easy
11:59:59 <vincenz> ehird: atom? becomes trivial
11:59:59 <ehird> vincenz: there's no reason to
12:00:07 <ehird> does arc even have atom?
12:00:13 <ehird> answer: no
12:00:29 <vincenz> ehird: not to mention
12:00:33 <vincenz> ehird: quoting literals => literal
12:00:39 <ehird> vincenz: that's simple too
12:00:41 <ehird> :|
12:00:43 <vincenz> seriously
12:00:51 <ehird> yours just makes things more complicated.
12:01:09 <ehird> Anyway
12:01:09 <vincenz> literals also self-evaluate
12:01:11 <ehird> just pushed booleans
12:01:14 <vincenz> so can be reused for values
12:01:14 <ehird> oops, forgot a Show instance
12:01:20 <desegnis> vincenz: You may prefer defining shows, instead of show, to show off you're familiar with the ShowS optimization
12:01:59 <ehird> pushing show instance for booleans
12:02:17 <vincenz> desegnis: I'm not, what is that?
12:02:42 <Deewiant> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AShowS
12:02:42 <lambdabot> http://tinyurl.com/ovjef
12:02:57 <ehird> the 'optimization' would be of little gain here
12:03:04 <desegnis> vincent, oh wait, I'm not exactly sure whether it will help here... but good to learn about it anyway
12:03:08 <olsner> heh, gobby comes with haskell highlighting
12:03:15 <desegnis> s/vincent/vincenz
12:03:18 <ehird> hm, i should add an Eq instance
12:03:25 <vincenz> desegnis: ...
12:03:28 <ehird> the default one should do
12:05:41 <hpaste>  dpd annotated "(no title)" with "(no title)" at http://hpaste.org/5351#a1
12:05:43 <desegnis> vincenz, well you would write shows (ArcList e) = showChar '(' . showList e . showChar ')' -- and that should be more efficient for showing lists of lists
12:05:47 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/5351#a2
12:05:56 <vincenz> desegnis: that code wasn't mine
12:05:58 <ehird> desegnis: fine i'll do that ;)
12:05:59 <vincenz> desegnis: and I know about shows :)
12:06:21 <vincenz> besides
12:06:26 <vincenz> ('(':) ..
12:06:29 <vincenz> will do the same :)
12:06:44 <desegnis> right
12:06:54 <ehird> actually
12:06:58 <ehird> it looks ugly with shows
12:07:04 <ehird> its not as if this is going to be blazing fast anyway
12:09:08 <olsner> I can host gobby if there's interest
12:09:22 <ehird> olsner: probably not, the darcs repo works
12:09:23 <ehird> and is underway
12:09:40 <ehird> pushing an instance Eq ArcExpr...
12:10:08 <vincenz> olsner: yes thanks
12:10:14 <vincenz> since darcs seems to be ehird only :)
12:10:15 <desegnis> vincenz, ehird: well it has vincenz' name on it, so I was right to get confused, weren't I? :)
12:10:25 <ehird> vincenz: you have repo access
12:10:27 <ehird> :/
12:10:28 <vincenz> ehird: I do
12:10:35 <ehird> so... use it! ;)
12:10:37 <vincenz> ehird: but if all suggestions are turned down ..
12:10:39 <desegnis> (speaking of the hpaste, obviously)
12:10:43 <ehird> i didn't turn down all suggestions
12:10:49 <ehird> just commit anything ;)
12:10:53 <ehird> co-ordination is for wussies!
12:11:00 <vincenz> this works better with gobby
12:11:03 <olsner> vincenz: gobby to www.olsner.se:6522
12:11:35 <vincenz> thx
12:12:03 <vincenz> olsner: you firewalled?
12:12:07 <vincenz> or blockported
12:12:11 <ehird> vincenz: why don't you just commit changes? :/
12:12:36 <vincenz> ehird: cause writing code in an uncoordinated way to a darcs repo is a rife way to code 'next' to each other
12:12:37 <ehird> it's not like i'm stopping you
12:12:40 <vincenz> onyl causing clashes
12:12:46 <ehird> vincenz: so... co-ordinate
12:12:51 <vincenz> that only works if a project has enough maturity
12:13:08 <ehird> so, co-ordinate
12:13:23 <olsner> vincenz: bah, I have the port forwarded in the router, so it *should* work
12:13:31 <vincenz> olsner: ain't conneting
12:13:41 <ehird> oh well
12:13:49 * ehird continues working on the darcs repo, which is open to changes if anyone wants an account
12:14:06 <vincenz> ehird: olsner and I can collab and then push to repo ;)
12:14:16 <ehird> only if you have the files from the repo.
12:14:21 <ehird> which then makes gobby redundant
12:14:52 <olsner> I think gobby's either lying about listening to the port, or lying about which port it listens to
12:15:12 <vincenz> ehird: gobby is better for something small like this
12:15:12 <EvilTerran> netstat?
12:15:17 <ehird> vincenz: not really, no.
12:15:19 <vincenz> ehird: I've tried both in our team lazybottoms
12:15:23 <ehird> vincenz: we have to write a reader, for instance.
12:15:33 <ehird> anyway, there's nothing 'slow' about darcs development
12:15:35 <ehird> if you co-ordinate properly.
12:15:52 <ehird> (slarba_ now has push access, anyone else want it?)
12:15:56 <EvilTerran> polar or cartesian? :D
12:16:02 <ehird> EvilTerran: ;)\
12:17:05 * shachaf thinks #haskell should have an associated Gobby session.
12:17:50 <ehird> Pushing macro data type and argspecs for macros and procedures to darcs repo now! \o/
12:18:46 <shachaf> Are you people still talking about Arc?
12:18:59 <gwern> shachaf: extend hpaste to have embedded sessions of gobby
12:19:00 <ehird> shachaf: Writing an interpreter for it in Haskell, to show how silly it is ;)
12:20:00 <shachaf> gwern: I don't know if Gobby is the best protocol for this, but something like this would be great.
12:20:12 <olsner> hmm, I forgot about the *other* firewall, but gobby should be up now
12:20:30 <ehird> Pushing fixed environments to darcs now! \o/
12:20:52 <ehird> vincenz: See! Rapid development :D
12:21:30 <ehird> @docs Continuation
12:21:30 <lambdabot> Continuation not available
12:21:34 <ehird> hmph
12:21:47 <desegnis> Would Gobby be compatible with using a vim or emacs (not session-aware) for editing?
12:22:08 <ehird> desegnis: Nope.
12:22:11 <ehird> It's dumb :D
12:22:32 <ehird> And I could plug the darcs repo again as being better, but I won't :)
12:22:36 <desegnis> Then I think I have a new proposition for a project :-)
12:22:37 <shachaf> desegnis: Emacs has some sort of Obby support.
12:22:46 <shachaf> ehird: Where's the darcs repository?
12:22:48 <gwern> it does?
12:22:52 <shachaf> gwern: Yes.
12:22:56 <shachaf> @go emacs obby
12:22:57 <lambdabot> http://www.mail-archive.com/obby-users@list.0x539.de/msg00143.html
12:22:57 <lambdabot> Title: Re: [obby-users] Emacs implementation
12:23:11 <ehird> shachaf: http://elliotthird.org/arc -- i assume you want push rights?
12:23:11 <lambdabot> Title: Index of /arc/
12:23:20 <desegnis> shachaf, being a vim-addict, I only added in ¬ªor emacs¬´ for safety
12:23:41 <ehird> hm, what module is the continuation monad in in haskell?
12:23:50 <Saizan> Control.Monad.Cont
12:24:08 <ehird> thanks
12:24:16 <gwern> oh, so the protocol is named Obby, and the program Gobby?
12:24:24 <ehird> shachaf: so, want push rights?
12:24:27 <shachaf> desegnis: I wish vim supported it.
12:24:55 <shachaf> ehird: Control.Monad.Cont
12:24:58 <mfp> olsner: is the gobby thing open to other ppl? cannot help, but I'd love to see you guys at work (I'm also tracking ehird's repos)
12:25:01 <shachaf> ehird: I'll look through it first. :-)
12:25:06 <shachaf> mfp: Yes.
12:25:10 <olsner> mfp: open to #haskell, of course
12:25:12 <shachaf> gwern: Yes.
12:25:23 <shachaf> mfp: Make sure you use 0.4.
12:25:27 * ehird is writing an ArcMonad now
12:25:28 <ehird> \o/
12:25:34 <ehird> see, gobby people aren't that far! ;)
12:25:38 <slarba_> we'll use StateT a IO for evaluator?
12:25:43 <ehird> slarba_: nuh uh
12:25:45 <ehird> you need continuations
12:25:49 * shachaf wishes Gobby had undo.
12:25:55 <slarba_> right
12:25:59 <ehird> also, StateT is worthless, we'll pass around IORefs for simplicty, why?
12:26:02 * mfp just apt-get installed it ... [checks]  0.4.6-2 :-))
12:26:05 <ehird> because we are going to be in the IO monad anyway
12:26:06 <ehird> so.
12:26:09 <slarba_> ok
12:26:24 <desegnis> shachaf: alas, C and vimscript are definite barriers for potential vim contributors
12:26:30 <shachaf> I don't know if that's a limitation of the protocol or the program.
12:26:40 <desegnis> (especially vimscript, I guess)
12:26:46 <shachaf> desegnis: Yes -- it's an awful language to do things in.
12:26:55 <shachaf> Someone add Obby to Yi! :-)
12:27:00 <slarba_> ehird: ContT on top of I?
12:27:01 <desegnis> heh
12:27:02 <slarba_> IO
12:27:07 <sieni> well, emacs lisp is almost equally horrible
12:27:10 <Deewiant> one can extend Vim in other languages as well
12:27:21 <gwern> shachaf: I was just thinking that myself, but I'm still looking for the Obby protocol details
12:27:24 <Deewiant> Python, Ruby, Perl, possibly others
12:27:24 <ehird> slarba_: Yes
12:27:34 <shachaf> gwern: It's on the website, isn't it?
12:27:49 <ehird> hm
12:28:04 * gwern always starts with wikipedia
12:28:05 <ehird> type ArcMonad = ContT (IORef ArcExpr) IO
12:28:06 <ehird> or
12:28:06 <shachaf> Are all these implementations going to be using arc.arc eventually (when the primitives are done)?
12:28:12 <ehird> type ArcMonad = ContT ArcExpr IO
12:28:14 <Deewiant> MzScheme, Perl, Python, SNiFF+ (the hell is that?), Tcl, OLE, Ruby.
12:28:20 <ehird> shachaf: Yes, and hopefully apparently the gobby will be pushed to the repo.
12:28:34 <ehird> But I hope you guys keep track of the repo or you won't have much look pushing
12:28:47 <desegnis> Deewiant, now we'd need a Haskell interpreter written in Perl
12:28:47 <ehird> slarba_: opinions on either ArcMonad?
12:28:54 <gwern> http://debaday.debian.net/2007/04/04/gobby-a-collaborative-text-editor/ <-- interesting
12:28:56 <lambdabot> Title: Debian Package of the Day ª Blog Archive ª Gobby: A Collaborative Text Editor, http://tinyurl.com/yppg6b
12:29:02 <Deewiant> desegnis: :-)
12:29:09 <gwern> desegnis: use pugs, then it can go right back to haskell :)
12:29:16 <slarba_> ehird: IORef ArcRep could be a safer bet maybe?
12:29:39 <desegnis> gwern, :)
12:29:58 <ehird> slarba_: ArcRep?
12:30:06 <slarba_> ArcExpr :D
12:30:13 <ehird> ah
12:30:19 <ehird> anyone have an opinion on that?
12:30:21 <gwern> ' ¬∂
12:30:21 <gwern> obby is the foundation of Gobby, providing the whole framework to synchronise changes within a text document to other participants of a session. New clients and plugins for existing applications could be written using it. It is written in C++ and C wrappers have yet to be created. '
12:30:22 <ehird> for the ContT
12:30:48 <shachaf> gwern: Yes, there's a library also.
12:31:05 <litb> so, i'm going to give a haskell presentation to the class
12:31:18 <litb> what example could i show that is easily to understand even by haskell novices?
12:31:22 <ehird> nobody? :)
12:31:32 <Deewiant> factorial n = product [2..n]
12:31:53 <EvilTerran> ?type product [2..10]
12:31:54 <lambdabot> forall t. (Enum t, Num t) => t
12:32:07 <litb> > let product n = [2..n]  in product 1
12:32:07 <lambdabot>  []
12:32:11 <litb> hm
12:32:14 <litb> > let product n = [2..n]  in product 6
12:32:15 <lambdabot>  [2,3,4,5,6]
12:32:22 <EvilTerran> ?src product
12:32:22 <lambdabot> product = foldl (*) 1
12:32:36 <ehird> aww come on, surely someone knows
12:32:36 <ehird> :)
12:32:39 <litb> oh i fail
12:32:52 <slarba_> ehird: arc strings are mutable, right?
12:33:01 <ehird> slarba_: everything in arc is mutable pretty much
12:33:06 <litb> > product [2..4]
12:33:07 <lambdabot>  24
12:33:09 <slarba_> we could simulate that by having mutable results?
12:33:11 <EvilTerran> ehird, we don't care about your crummy little language. wheesht. :P
12:33:13 <ehird> so we PASS AROUND IORefs, but that doesn't mean the FINAL CONTINUATION value has to be an IORef
12:33:14 <litb> ah, show them that and then show them:
12:33:19 <litb> the code of product?
12:33:21 <gwern> arc itself is mutable
12:33:31 <ehird> EvilTerran: not our language, and considering loads of people are gathering around the gobby one, i would say some people do
12:33:40 <litb> i think it will be kind of difficult to explain them how foldl works within 5 minutes
12:33:43 <Deewiant> litb: foldl might be a bit tricky to explain, depends on how deep you want to go
12:33:56 <litb> i have a 5 to 10 limit timeframe
12:34:00 <EvilTerran> ehird, "... :P" <- the last bit is important
12:34:05 <ehird> still ;)
12:34:41 <litb> i thought i should show fact n = if n==0 = 1 else n * fact (n+1) and show them something to do with laziness
12:34:47 <Deewiant> litb: this thing dons posted might be handy: http://reddit.com/r/programming/info/674qv/comments/
12:34:54 <litb> but i can't think of something lazy what would be interesting
12:35:00 <Deewiant> infinite lists?
12:35:10 <ehird> So, helpless poor third parties:
12:35:17 <ehird> type ArcMonad = ContT (IORef ArcExpr) IO -- or -- type ArcMonad = ContT ArcExpr IO
12:35:18 <dolio> litb: Fibonacci numbers are pretty standard.
12:35:36 <rekso> Is it to be expected that adding "module Main where" to the beginning of my source file should make the (compiled) program take 10x longer to run?
12:35:42 <dolio> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib
12:35:43 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:36:09 <Deewiant> dolio: but again, that's a bit tricky to explain
12:36:10 <Deewiant> IMHO, anyway
12:36:18 <mauke> rekso: whoa. what happens if you use "module Main (main) where"?
12:36:47 <dolio> Yeah, it is, I suppose.
12:36:59 <rekso> mauke: I haven't tried. Will try it now.
12:37:28 <slarba_> hmm
12:37:58 <EvilTerran> litb, i'd start with xs = 1:xs, xs = 1 : map (+1) xs, and working up
12:38:05 <EvilTerran> if you want to focus on laziness in particular
12:38:13 * BMeph69 starts lurking on Gobby, too
12:38:18 <litb> Deewiant: oh that is really great what dons made there
12:39:10 <ehird> nobody? :P
12:39:23 <litb> > let xs = 1:xs in xs
12:39:23 <Cale> ehird: Hi, where is the gobby session?
12:39:23 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:39:31 <shachaf> ehird: www.olsner.se
12:39:36 <shachaf> s/ehird/Cale/
12:39:40 <ehird> Cale: Don't ask me, I don't approve of it. I own the darcs repo.
12:39:43 <Deewiant> > repeat 1
12:39:43 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:39:44 <shachaf> Cale: Port 6522, I think.
12:39:57 <ehird> Which is further on.
12:40:07 <litb> let xs = 1 : map (+1) xs in xs -- should give 1, 2, 3, 4, 5 i suppose?
12:40:07 <olsner> heh, we're already splintered ;-)
12:40:22 <ehird> olsner: Well, I don't see the point of the gobby. the darcs development is going perfectly.
12:40:29 <EvilTerran> > let xs = 1 : map (+1) xs in xs -- litb, exactly
12:40:29 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
12:40:45 <litb> great at least i understand it basicially hehe
12:41:07 <litb> but that fibonacci thing with zip is not that hard at all i think
12:41:11 <desegnis> Eh folks, you were supposed to debate about the version number, not the collaboration method!
12:41:20 <ehird> desegnis: I
12:41:22 <ehird> 'm not debating.
12:41:27 <desegnis> :)
12:41:32 <ehird> I'm coding in the darcs version, slarba_ is too, anyone who wants an account can have one.
12:41:35 <litb> the two list are just one number apart from each other so we always get a new one each time and can continue to do stuff
12:41:37 <dolio> litb: It might help if you explain 'ones = 1:ones' first.
12:41:44 <ehird> We're doing well as far as development pace goes.
12:41:47 <litb> dolio: oh yeah
12:42:00 <jstanley> Anyone care to help me with a super simple "can't find a module" problem? I'm trying to get the School of Expression (SOE) gfx library to work, and since upgrading to 6.8.2 it doesn't seem to be able to find the library.
12:42:28 <litb> haskell will make a reference there, and if it is evaluated, it will actually get the list ones until it gets as many items as it wishes i suppose?
12:42:41 <litb> > let ones = 1:ones in take 10 ones
12:42:41 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
12:42:51 <jstanley> so "ghc -o mygfx mygfx.hs -ISOE/src" doesn't find the module, even though ./SOE/src/SOE.hs is where the module exists.
12:43:04 <jstanley> Er, -iSOE/src above.
12:43:35 <EvilTerran> > iterate (concatMap ((:) <$> length <*> return.head) . group) [1]
12:43:44 <lambdabot>  [[1],[1,1],[2,1],[1,2,1,1],[1,1,1,2,2,1],[3,1,2,2,1,1],[1,3,1,1,2,2,2,1],[1,...
12:43:47 <rekso> mauke: No, with 'module Main (main)' it runs at full speed.
12:44:11 <Lemmih> jstanley: s/SOEGraphics/Graphics.SOE/
12:44:28 <shachaf> > fix ((1:) . scanl (+) 1)
12:44:28 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:44:47 <shachaf> jstanley: You'll have to reinstall it if you're using a new GHC.
12:45:04 <jstanley> Lemmih/shachaf: Okay, thanks.
12:45:58 <mauke> rekso: what optimization options are you using?
12:46:05 <rekso> mauke: -O2
12:46:28 <mauke> I can only guess that it has something to do with not exporting certain symbols
12:46:52 <rekso> any idea why that might make a difference then?
12:47:47 <mauke> better inlining/specialization, maybe?
12:48:06 <jstanley> so ghc-pkg list shows that I have the GLFW-0.1 package installed, but doing a ghc-pkg unregister or hide claims that it can't find the package. ideas?
12:48:20 <EvilTerran> > unwords . map (map intToDigit) . iterate (concatMap ((:) <$> length <*> return.head) . group) $ [1]
12:48:20 <lambdabot>  "1 11 21 1211 111221 312211 13112221 1113213211 31131211131221 1321131112311...
12:48:27 <EvilTerran> @oeis 1 11 21 1211 111221 312211 13112221
12:48:28 <lambdabot> Look and Say sequence: describe the previous term! (method A - initial term i...
12:48:29 <lambdabot> [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,13211311123113...
12:48:32 <mauke> jstanley: --user
12:48:33 <shachaf> jstanley: How are you running the command?
12:48:35 <EvilTerran> :)
12:48:39 <shachaf> Oh.
12:48:39 <jstanley> mauke: doh, thanks.
12:50:49 <rekso> Ah yes, it could be that exporting screws up the specialisation. I bet that's it, thanks mauke!
12:51:27 <BMeph69> litb: Do Oleg's version of the "real" Sieve of Eratosthenes; that'll take ten just explaining it! ;)
12:52:53 <jstanley> Lemmih: New version installed with ghc 6.8.2, but I'm getting the same error.
12:54:07 <ehird> All state is accounted for the darcs repo now
12:54:12 <ehird> Evaluator coding starts now.
12:54:15 <ehird> How's Gobby doing?
12:55:25 <litb> BMeph69: lolz :)
12:55:36 <litb> can i say that function in haskell have no side effects?
12:55:36 <BMeph69> litb: :)
12:56:01 <BMeph69> It's one of the few things from Oleg that I have no problems understanding. :)
12:56:06 <shachaf> ehird: Join and see. :-)
12:56:08 <litb> and call the functions that return IO a "monads" ? or is that too misleading?
12:56:35 <ehird> shachaf: I can't.
12:56:37 <ehird> I don't have Gobby.
12:56:45 <desegnis> litb: No, IO is a monad.
12:56:56 <desegnis> (it's the algebraic structure)
12:57:21 <litb> ah, ok. i say that functions can return special values called IO t Monads that when used specially will cause defined sideeffects
12:57:24 <shachaf> ehird: Install Gobby. :-)
12:57:35 <shachaf> ehird: (Very nice program to have available.)
12:57:56 <jstanley> shachaf: So I've reinstalled SOE, but have the same problem. Clearly I have the files in the wrong directory hierarchy or something, as the out-of-the-box .zip file contents don't seem to make ghc happy.
12:57:56 <ehird> shachaf: No. It's gtk.
12:57:56 <desegnis> litb: ¬ªIO t Monads¬´?
12:58:13 <ehird> shachaf: So how is the Gobby Arc doing?
12:58:27 <ehird> And I thought vincenz said he was going to push changes from it to my repo..
12:58:30 <roconnor> If paul graham sumbitted a paper about Arc to POPL, would it get passed the referees?
12:58:59 <desegnis> litb: Note that IO is a type constructor and is a monad, but IO values are not monads (they are often called actions)
13:00:36 <conal> litb: IO and monads are independent ideas.  you can understand either without the other.
13:01:47 <gwern> roconnor: I doubt it. it has some nice syntax, even a bit of haskell there, but I haven't seen anything really new
13:01:52 <Mitar> how can i define a function with multiple patterns in ghci?
13:01:58 <shachaf> litb: Semicolonds.
13:02:02 <shachaf> s/d//
13:02:04 <EvilTerran> Mitar, separate lines with semicolons
13:02:07 <shachaf> s/litb/Mitar/
13:02:16 <shachaf> > let f 0 = 1; f 1 = 2 in f 3
13:02:20 <lambdabot>   Non-exhaustive patterns in function f
13:02:22 <gwern> (it has a quirky M-expression syntax which uses _ in defning lambdas in the same way haskell does, iirc)
13:02:33 <Mitar> let qsort (pivot:list) = qsort smaller ++ [pivot] ++ qsort bigger where smaller = filter (<pivot) list; bigger = filter (>=pivot) list; qsort [] = []
13:02:36 <EvilTerran> Mitar, or, if your ghci is modern, the line ":{" lets you type across several lines, closed by the line ":}"
13:02:48 <EvilTerran> (6.8 onwards, iirc)
13:03:03 <desegnis> lol. If I had given an example for Mitar's question, I'd have begun with ¬ªf 0 = 1¬´, too, for sure!
13:03:18 <ehird> Anyone want darcs push access?
13:04:03 <litb> i see
13:04:39 <litb> so the thing that causes side effects is IO , but not monads . monads are only used by IO to make the distinction of IO and normal functions clearer
13:05:05 <sebell> ehird: What's the repo URL?
13:05:17 <desegnis> litb, right up to the full stop
13:05:17 <byorgey> EvilTerran: o.O
13:05:25 <EvilTerran> byorgey, what?
13:05:39 <byorgey> EvilTerran: I didn't know about the :{  :} thing
13:05:46 * byorgey tries
13:05:48 <ehird> sebell: http://elliotthird.org/arc
13:05:49 <lambdabot> Title: Index of /arc/
13:05:54 <ehird> but that's not with push access obvioously
13:05:57 <EvilTerran> yeah, it's cool. i make a habit of reading changelogs of software i use, so i catch these things :_
13:05:59 <EvilTerran> er, :_
13:06:01 <EvilTerran> ...
13:06:02 <EvilTerran> :)
13:06:06 <allbery_b> litb: also to make I/O the Haskell way a bit easier.  cf. http://www.ece.cmu.edu/~allbery/IOHack.hs which is (working!) "unrolled" I/O in ghc
13:06:10 <desegnis> litb, a monad is used for I/O because monads are useful for a lot of things, I/O being one of them
13:06:31 <Mitar> how could i define this quicksort inline in ghci?
13:07:09 <Nafai> ehird: Is that an implementation of Arc or just a parser for it?
13:07:13 <EvilTerran> Mitar, you need to restrict the scope of the where
13:07:16 <ehird> Nafai: No parser right now
13:07:17 <EvilTerran> er, range of
13:07:21 <ehird> It's a WIP interpreter+parser
13:07:21 <EvilTerran> it's currently parsing as
13:07:25 <EvilTerran> let qsort (pivot:list) = qsort smaller ++ [pivot] ++ qsort bigger where { smaller = filter (<pivot) list; bigger = filter (>=pivot) list; qsort [] = [] }
13:07:27 <ehird> I'm working on eval now
13:07:37 <EvilTerran> let qsort (pivot:list) = qsort smaller ++ [pivot] ++ qsort bigger where { smaller = filter (<pivot) list }; bigger = filter (>=pivot) list; qsort [] = []
13:07:41 <EvilTerran> Mitar, try that /\
13:07:41 <Nafai> Interesting
13:07:58 <EvilTerran> er, move that } over to the right place. you get the idea. ;)
13:08:03 * byorgey thinks it's silly
13:08:04 <litb> i understand now
13:08:06 * byorgey ducks
13:08:12 <grahamhutton> @users
13:08:12 <lambdabot> Maximum users seen in #haskell: 463, currently: 449 (97.0%), active: 26 (5.8%)
13:08:27 <litb> well it's stuck at 463
13:08:37 <Mitar> yes, thanks
13:08:39 <byorgey> hi grahamhutton
13:08:45 <ehird> byorgey: thinks what is
13:08:52 <litb> i saw a screeny last week where it was at around 200 and one guy said "wel, haskell is growing very quickly"
13:08:56 <litb> lol
13:08:56 <conal> litb: in other words, Monad is a *generalization* of the specific type (constructor) IO.  If you want to understand IO, I recommend forgetting about monads as follows, and instead focus on "actions" as values.  Later, you'll see that some of your IO tools actually have a more general type and apply to other things as well.
13:08:58 <byorgey> ehird: implementing Arc, of course =)
13:09:04 <ehird> byorgey: it's meant to be
13:09:11 <ehird> we're showing how ridiculous arc is by doing it in less than 6 years
13:09:14 <byorgey> ehird: well, yes, I know =)
13:09:16 <conal> s/as follows/at first/  (emacs abbrev)
13:09:17 <ehird> a near-impossible feat, you must understand
13:09:17 <desegnis> Mitar: easiest just to move the where clause to the very end
13:09:26 <grahamhutton> hi byorgey!
13:09:38 <byorgey> ehird: surely it will take you at least 4 though! ;)
13:09:43 <ehird> byorgey: probably!
13:09:43 * Cin peeks in to see how Arc is going
13:10:03 <kuribas> If I have a datatype with fields that may be uninitialised during certain phases of my program, should I use data MyType = MyType (Maybe Int) (Maybe Int)?  (for example).
13:10:05 <ehird> Cin: horrid mean non-cuddly people forked into gobby, development on the darcs version is still going strong
13:10:21 <Cin> ehird: aha, okay :P
13:10:29 <EvilTerran> kuribas, that's probably a good idea, yes
13:10:29 <ehird> Cin: want push access? ;)
13:10:31 <Cin> ehird: you seem to ahve moved your darcs repo. where is the url?
13:10:36 <ehird> Cin: elliotthird.org/arc
13:10:40 <Cin> thanks
13:10:57 <Cin> ehird: i'm working on my ircd at the moment. i doubt i'd be able to contribute anyway at your level :P
13:11:45 * Cin peers over the code
13:11:51 <jstanley> Has anyone had problems with ghc 6.8.2 and GLFW-0.3? I'm getting parse errors on a 'foreign import' when building from the source.
13:12:30 <lispy> Cin: arc makes me sad
13:12:42 <kuribas> EvilTerran: And if I later want a complete dataType, I should use another one, Like MyPartialType and MyType?
13:13:12 <Cin> lispy: arc itself looks mostly silly to me, but implementing it to be snarky and as a good example of haskell is awesome :D
13:13:22 <EvilTerran> kuribas, depending on how fancy you're feeling, that would work, yes
13:13:22 <dcoutts> lispy: what is arc and why are people talking about it so much all of a sudden?
13:13:42 <ehird> dcoutts: something ridiculous! :D
13:14:06 <dolio> dcoutts: It's Paul Graham's magnum opus.
13:14:15 <EvilTerran> kuribas, if you wanted to do something fancy-but-overkill, you could have data MyType f = MyType (f Int) (f Int), and then you could use (MyType Maybe) or (MyType Identity) depending on whether you wanted to allow missing values
13:14:17 <dolio> The ultimate Lisp dialect.
13:14:38 <dcoutts> Yet Another Lisp Implementation?
13:14:51 <byorgey> dcoutts: oh no no, it's THE Lisp Implementation!!
13:14:51 <lispy> dcoutts: do you know who Paul Graham is?
13:14:51 <Cin> dcoutts: yet another lisp dialect, and implementation
13:15:03 <dcoutts> lispy: the lisp advocate
13:15:09 <EvilTerran> kuribas, and this'd open doors to such potentially interesting things as (MyType []), which'd allow multiple values in each spot, or (MyType (Either String), which'd allow you to tack in an error message in place of a missing value
13:15:26 <EvilTerran> dcoutts, you forgot "rabid" :P
13:15:30 <dcoutts> heh heh
13:15:37 <byorgey> dcoutts: http://paulgraham.com/arc0.html
13:15:38 <lambdabot> Title: Arc's Out
13:15:41 <lispy> dcoutts: yeah, so he wrote on his blag for a while about how cool of a programming language he could make, with frist class types, putting profiling tools in the spec, and by not being a blub lnaguage
13:16:04 <ehird> lispy: it took him 6 years to release it
13:16:05 <ehird> and in the end
13:16:06 <lispy> dcoutts: he call the language "Arc", because like lisp, it would be meta-circular
13:16:14 <ehird> we get some crappy small names for scheme primitives
13:16:17 <ehird> and only 1000 lines of scheme
13:16:22 <Trinithis> @src fix
13:16:22 <lambdabot> fix f = let x = f x in x
13:16:26 <lispy> dcoutts: and then when he finally releases it, it's php on top of MzScheme
13:16:27 <ehird> seriously. he considers 1000 lines + crappy stdlib good enough
13:16:29 <desegnis> so, according to the repo, arc is a language where Doubles are immutable, but lists of Doubles are mutable?
13:16:31 <ehird> for 6 years
13:16:38 <ehird> desegnis: Um, sure.
13:16:38 <Cin> ehird: but Small Names are a Big Win
13:16:41 <ehird> Why would you be able to mutate a double?
13:16:43 <ehird> That's ridiculous
13:16:49 <lispy> dcoutts: but, not even a good php, it's just crap
13:16:58 <ehird> (morph 2.0 3.0) ; MWAHAHAHAHa!
13:16:58 <desegnis> ehird, why mutate a list then?
13:17:07 <ehird> desegnis: Because Lisp pairs are mutable
13:17:15 <EvilTerran> desegnis, because it's lisp
13:17:22 <radix> I really don't want to defend arc or PG, because I think it's all stupid, but I don't think that he was really "working up" to this release; AIUI he's been using it as the language for his projects for a while
13:17:23 <dcoutts> lispy: so not even an interesting lisp variation? from the language perspective even (if not impl)
13:17:28 <Cin> ehird: PLT4 (mzscheme) will have immutible lists, iirc
13:17:37 <ehird> Cin: Sure. But Arc doesn't.
13:17:43 <desegnis> EvilTerran, point taken. ehird, well I'm not a lisper, myself
13:17:48 <Cin> ehird: i just thought i'd trow that in
13:17:54 <byorgey> dcoutts: nope.
13:18:53 <jua> he should just give up and endorse Qi or something. only he proably hates type systems if his ASCII inclination is an indication
13:19:27 <dolio> I don't think there's any doubt he dislikes type systems.
13:19:30 <kuribas> I'd like to see a haskell like lisp with staticly typed hygienic macros.
13:19:41 <gbacon> 2^8 characters should be enough for anybody!
13:19:42 <shachaf> kuribas: Liskell, possibly?
13:19:51 <shachaf> kuribas: There's also TH.
13:19:56 <kuribas> shachaf: Minus the staticly typed macros.
13:20:25 <lispy> the big problem with TH as a hygenic macro system is that we don't have a good Haskell parser built into TH
13:20:27 <dolio> TH isn't really on par with lisp macros.
13:20:37 <lispy> there is an H98 parser, but that's only H98
13:20:56 <lispy> if ghc exposed (perhaps via ghc-api) more goodies to TH then it would be just as good as lisp macros
13:21:11 <dolio> Is the macro system for OCaml typed?
13:21:33 <litb> would it make sense if i did "fac :: (Num n) => n -> n" or would that confuse people?
13:21:53 <lispy> note, though, I did use TH + H98 parser to generate code at run time in one of my projects: http://blog.codersbase.com/2006/09/01/simple-unit-testing-in-haskell/
13:21:54 <shachaf> litb: On more than Integral?
13:21:54 <lambdabot> Title: dagit.o ª Blog Archive ª Simple Unit Testing in Haskell, http://tinyurl.com/h6k97
13:21:56 <litb> i could say "see, if n is a number, then it fac is the following: ..."
13:22:08 <desegnis> litb: What would be fac pi?
13:22:17 <litb> shachaf: oh i see. i take Integral then
13:22:23 <shachaf> litb: (Unless fac is (gamma . (+1)).... :-) )
13:22:25 <litb> there is Int and Integer in Integral or?
13:22:31 <shachaf> litb: Yes.
13:22:34 <litb> i wonder whether there is Natural too
13:22:43 <desegnis> there should be.
13:22:56 <litb> but then again i'm not sure about 0
13:22:58 <lispy> dcoutts: yes, boring and unoriginal language...he removed cons and was bragging that [] == false
13:23:02 <desegnis> not in Integral probably, but there should be.
13:23:09 <desegnis> but there isn't.
13:23:23 <lispy> dcoutts: sorry not cons, but cond
13:23:23 <litb> you mean there is no Natural in Integral?
13:23:39 <ehird> hahahahahaha arc:
13:23:40 <ehird> arc> ()
13:23:40 <ehird> ()
13:23:41 <ehird> arc> '()
13:23:43 <ehird> nil
13:23:44 <dolio> lispy: My favorite part of his overview was the "is" predicate.
13:23:44 <shachaf> litb: No.
13:23:47 <desegnis> litb, there ain't no Natural at all in the standard libs
13:23:49 <dcoutts> lispy: I was going to say, without cons lists are nice and simple since they're always empty :-)
13:23:53 <Tac-Tics> I don't see why everyone is so worked up over arc... Graham promised to do the impossible and now everyone's in a huff because he didn't invent a Silver Bullet
13:23:54 <shachaf> ehird: I said that in the Gobby session already. :-)
13:24:22 <ehird> shachaf: If I was able to get in there..
13:24:30 <shachaf> ehird: Why can't you?
13:24:31 <ehird> Could you aspte the current code they have somewhere?
13:24:32 <lispy> Gobby session?
13:24:37 <ehird> And because I don't have gobby/can't have gobby
13:24:48 <Tac-Tics> The idea of a 100 year language is an interesting one, but it was foolish of him to promise to deliver it
13:24:48 <Cale> ehird: Why can not has gobby?
13:24:59 <desegnis> litb, the topic of the numeric parts of the Prelude being quite broken comes up fairly frequently on #haskell ;-)
13:25:05 <ehird> Cale: OS X, slooow buuild too
13:25:23 <jeffz> interesting choice for a name... gobby.
13:25:26 <litb> meh
13:25:32 <litb> i would like to have a new prelude
13:25:33 <shachaf> litb: www.olsner.se:6522
13:25:38 <Cale> It's in macports.
13:25:41 <shachaf> s/tb/spy/
13:25:42 <EvilTerran> Tac-Tics, it's infuriating to see someone you respect for his writings fall into the traps he himself identified and wrote about at length
13:25:47 <litb> that is that shachaf ?
13:25:51 <cjb> jeffz: it's the gnome client to "obby", I think.
13:25:53 <EvilTerran> in this case, "the blub paradox"
13:26:08 <ehird> Cale: Slow build.
13:26:12 <ehird> Now iwll somebody please paste?
13:26:23 <shachaf> ehird: It's being actively changed.
13:26:27 <shachaf> ehird: Get a binary. :-)
13:26:30 <jeffz> cjb: ah, it's slang for "something else" here.
13:26:30 <ehird> Paste the version /right now/ then.
13:26:37 <Tac-Tics> He's a good writer for sure. But he's fallible, and despite his success in coding, he's not a language designer
13:27:09 <desegnis> jeffz, what, here? oh, you mean there
13:27:25 <Cale> I always thought his articles were kind of fluffy.
13:27:37 <Tac-Tics> Graham got everyone's hopes up, but what they were hoping for was a miracle
13:27:41 <jeffz> desegnis: oh over there -> http://www.urbandictionary.com/define.php?term=gobby
13:27:41 <lambdabot> Title: Urban Dictionary: gobby
13:27:57 <Tac-Tics> And it's the reader's own responsibility to be realistic and critical of the author's ideas
13:28:02 <ehird> Nobody? :|
13:28:21 <litb> @src Num
13:28:21 <lambdabot> class  (Eq a, Show a) => Num a  where
13:28:21 <lambdabot>     (+), (-), (*)           :: a -> a -> a
13:28:21 <lambdabot>     negate, abs, signum     :: a -> a
13:28:21 <lambdabot>     fromInteger             :: Integer -> a
13:28:22 <ehird> Tac-Tics: I wasn't.
13:28:30 <ehird> I expected something not very good, but ... Arc is worse.
13:28:34 <EvilTerran> Tac-Tics, and that's what we're doing. being critical of his ideas. :P
13:28:41 <Tac-Tics> heh
13:28:43 <litb> i suppose the type classes weren't written by mathematicians o.O
13:28:53 <byorgey> litb gets a prize!!
13:29:00 <dolio> Not yet!
13:29:22 * byorgey presents litb with a golden lambda, inscribed with mathematical formulae
13:29:24 <Cale> litb: However, you don't want the standard mathematical hierarchy either.
13:29:27 <desegnis> jeffz, Australia then - would have even guessed that probably. Interesting denotation, though
13:29:28 * litb eyes his second proze won in #haskell
13:29:34 <ehird> :/
13:29:38 <litb> s/proze/prize/ indeed
13:30:01 <litb> oh well i've two golden lambdas now :)
13:30:23 <Tac-Tics> EvilTerran: yeah. But there's a side effect there... and that side effect is countless angry randoms are flooding my Reddit with their complaints about lack of Unicode support
13:30:25 <litb> Cale: oh yes i believe you. i'm sure i would be lost
13:30:27 <jonaskoelker> help, I'm having unfun with Parsec; I'm trying to use chainl but I fail horribly.  Blood and guts at http://rafb.net/p/NZrfM546.html
13:30:27 <lambdabot> Title: Nopaste - No description
13:30:42 <litb> i don't understand one thing
13:30:44 <jonaskoelker> (hm, I gotta fix rafbcat.sh)
13:30:48 <litb> a b =  2*b
13:30:49 <EvilTerran> Tac-Tics, well, that's reddit for ya. at least they're not complaining about lack of Ron Paul support.
13:30:49 <Cale> litb: It's not so much that you'd be lost, it's that it doesn't apply very well to the kinds of numbers which are available on computers.
13:30:51 <litb> is possible
13:31:02 <litb> and when * is not defined for b it raises an error
13:31:12 <dons> augustss: so is there going to be a Credit Suisse summer of Haskell code? :)
13:31:17 <Cale> litb: a type error
13:31:17 <litb> why should i put (Num a) => a -> a above it then?
13:31:21 <dons> can't let  the Jane Street guys have all the fun
13:31:23 <Tac-Tics> They need a temperary Arc Complaint Subreddit
13:31:29 <Cale> litb: that's the inferred signature.
13:31:32 <litb> if it doesn't crash anyway and exits with a nice type error?
13:31:36 <desegnis> litb: For (*) for it to be defined.
13:31:53 <Cale> litb: You might want to put that signature as documentation of the function's type.
13:31:58 <desegnis> litb, type errors are compile-time errors.
13:32:00 <litb> but if it also errors out without that line, why should i put it at all?
13:32:05 <Cale> what?
13:32:08 <Philippa> dons: good question given that Heffalump volunteered to run this year's :-)
13:32:14 <EvilTerran> litb, documentation
13:32:19 <EvilTerran> also clarity of error messages
13:32:20 <Philippa> oh, wait. brainfart. This year's AngloHaskell
13:32:24 <Cale> You'll also get better type errors in general if you add more explicit type signatures to your code.
13:32:28 <dons> Philippa: this years SoC?
13:32:35 <dons> ah
13:32:44 <Philippa> that'll teach me to alt-tab without taking a moment to context-switch
13:32:47 <Cale> Haskell can use those to help figure out what it was that you intended.
13:32:49 <Philippa> (except it probably won't)
13:32:52 <desegnis> litb, ah that's what you meant
13:33:09 <tautologico> is debian a good distro for haskell?
13:33:21 <litb> say i have this: "foo a = a*2" and do "foo NotOfNum" it errors out of course. and if i have "foo :: (Num a) => a -> a \n foo a = 2*a" and "foo NotNum" it also errors out
13:33:22 <Cale> tautologico: It's all right.
13:33:25 <litb> so there is no difference
13:33:28 <sarehu> works for me; I don't run debian's ghc of course
13:33:39 <Cale> litb: yes.
13:33:43 <litb> so why put the (Num a) => at all?
13:33:51 <gbacon> tautologico: debian's ghc is w-a-a-a-a-a-a-y behind the curve
13:33:57 <Cale> litb: You're documenting the type of the function.
13:33:58 <litb> only for documentation?
13:34:04 <litb> ah i see
13:34:06 <shachaf> gbacon: I thought they were up to 6.8 in unstable?
13:34:07 <EvilTerran> litb, well, the type is too general if you put the type signature in without the Num a =>
13:34:12 <Cale> litb: You can leave out almost any type signature and it'll be inferred.
13:34:13 <tautologico> I thought it was 6.6
13:34:24 <dylan> it's 6.8 here
13:34:27 <gbacon> 6.6 in stable
13:34:36 <Cale> litb: Oh, if you write  foo :: a -> a, well, that's just wrong in and of itself.
13:34:36 <dylan> nobody uses stable.
13:34:51 <Cale> litb: (with just the definition of foo there)
13:35:16 <jonaskoelker> hey, can anyone help me a bit with Parsec?
13:35:23 <litb> Cale: hm, but it compiles
13:35:24 <Cale> jonaskoelker: sure, what's the problem?
13:35:31 <Cale> litb: No it won't.
13:35:34 <litb> darn
13:35:36 <Cale> litb: if you write:
13:35:38 <Cale> foo :: a -> a
13:35:43 <jonaskoelker> Cale: this code doesn't work: http://rafb.net/p/NZrfM546.html
13:35:43 <lambdabot> Title: Nopaste - No description
13:35:46 <Cale> foo a = 2*a
13:35:54 <tautologico> funny that they are so fussy to release something as stable, but no one uses it
13:36:10 <jonaskoelker> Cale: and I've copied it as closely as I could from the chainl1 example in the parsec docs
13:36:12 <Cale> then you'll get an error regarding foo's implementation being insufficiently general for its type
13:36:24 <sarehu> jonaskoelker: what's the error?
13:36:57 <jonaskoelker> http://rafb.net/p/AhuofY76.html
13:36:58 <lambdabot> Title: Nopaste - No description
13:37:00 <litb> i get a warning telling me "Could not deduce (Num a) from the context ()"
13:37:05 <litb> i see i'll put it in
13:37:18 <litb> that is what i wanted to know
13:37:42 <litb> looks like it's not completely documentation but somehow considered bad style when i don't write it
13:38:14 <Cale> litb: It's checked documentation.
13:38:21 <Cale> litb: All types are.
13:38:29 <Cin> :D
13:38:36 <Cale> litb: The "(Num a) => " part of the type isn't optional though.
13:38:58 <Cale> litb: Because without it, you're saying that the function would work *for any* type a
13:39:07 <Cale> When that is patently false.
13:39:38 <Cale> jonaskoelker: You're not applying chainl to enough parameters.
13:39:46 <eugman|work> http://www.haskell.org/haskellwiki/GHC_under_WINE Is that what I'd have to do if I wanted to compile haskell for windows on a linux computer?
13:39:47 <lambdabot> Title: GHC under WINE - HaskellWiki
13:39:54 <Cale> jonaskoelker: You may want chainl1
13:40:00 <litb> Cale: hm, but i cannot only put "(Num a) =>" there.
13:40:09 <litb> then i have to put the whole signature
13:40:15 <sethk> eugman|work, you can cross compile it natively in windows
13:40:32 <Cale> litb: Of course, that'd be a syntax error.
13:40:34 <sethk> eugman|work, depending on your distro, the cross compiler may be available as a package, if not, you can build the cross compiler
13:41:04 <Cale> litb: The "(Num a) =>" serves to restrict the type variable "a" in the type that follows.
13:41:29 <Cale> (Specifically, 'a' can only refer to a type which is an instance of the class Num)
13:41:40 <litb> Cale: i see
13:41:48 <tautologico> so do you people recommend using unstable or testing?
13:41:54 <sarehu> testing
13:42:19 <jonaskoelker> Cale: hmmm... I think I may, but I get (virtually) identical error messages
13:42:20 <eugman|work> Sethk, what's the cross compiler called?
13:42:26 <jonaskoelker> Cale: I think I'm screwing up on the type of factor
13:42:35 <jonaskoelker> (that bit in the error message didn't change)
13:42:42 <Cale> tautologico: I used unstable for 5 years or so -- there would be problems with certain packages from time to time, but never for all that long. I suppose it depends on how much tolerance you have for that sort of thing.
13:42:46 <sethk> eugman|work, depends on the distro.
13:42:48 <paczesiowa> jonaskoelker: I'd suggest using Expr module and use operator tables
13:43:05 <eugman|work> Well, ubuntu for me but i assumed it had a general name.
13:43:31 <sarehu> tautologico: depends on if you get any benefit by being in unstable
13:43:43 <Cale> jonaskoelker: ah!
13:43:45 <jonaskoelker> paczesiowa: okay... I'm stumped at how to make `function call' an operator, though...
13:43:48 <jonaskoelker> Cale: ah?
13:44:03 <sethk> eugman|work, package names are pretty arbitrary for each distro.  searching for gcc in synaptic will find it.  Building from source, there is only one tarball that's used to build both native compilers and cross compilers
13:45:09 <paczesiowa> jonaskoelker: I don't see funcalls in your code, if you need regular funcalling convention f(x,y) then you make it instance of factor parser, not an operator
13:45:26 <Cale> jonaskoelker: It's saying that the definition you gave for factor has (essentially) type Parser Expression, but somehow from context, it wants Parser ((Expression -> Expression -> Expression) -> (Expression -> Expression -> Expression) -> (Expression -> Expression -> Expression))
13:46:22 <olsner> @src Applicative
13:46:22 <lambdabot> class Functor f => Applicative f where
13:46:23 <lambdabot>     pure  :: a -> f a
13:46:23 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:47:58 <tautologico> I'm using ubuntu, but I'm not completely satisfied with it
13:48:23 <Cale> jonaskoelker: Note that, for example, mulop :: Parser (Expression -> Expression -> Expression)
13:48:39 <Cale> tautologico: I am too. I just use the binary GHC package.
13:48:42 <gbacon> dylan: which repo has 6.8? aptitude reports no match for ghc6 in unstable
13:49:04 <dylan> the normal ones?
13:49:20 <eugman|work> tautologico, do you know anything about being able to compile for windows from buntu?
13:49:26 <dylan> gbacon: % ghc --version
13:49:27 <dylan> The Glorious Glasgow Haskell Compilation System, version 6.8.2
13:50:10 <Cale> eugman|work: Why do you want to do that? You have an extremely powerful linux machine you want to use to compile GHC? Are you hacking on GHC, or is there some other reason you want to compile it?
13:50:33 <gbacon> dylan: I believe you, but where'd you find the package?
13:52:04 <dylan> gbacon: I dunno, aptitude upgrade just decided to upgrade ghc
13:52:45 <jonaskoelker> Cale: but, isn't mulop supposed to have that type?
13:52:48 <hpaste>  Paczesiowa pasted "for jonaskoelker" at http://hpaste.org/5353
13:52:53 <Trinithis> how does the fix function work?
13:52:53 <eugman|work> Cale, you msi understand me. I wish to compile programs written in haskell on a linux computer to run on a windows computer
13:53:04 <paczesiowa> jonaskoelker: check that code http://hpaste.org/5353
13:54:00 <Cale> eugman|work: ah, okay
13:54:10 <paczesiowa> eugman|work: why not do only final compilation on windows machine?
13:54:11 <hpaste>  litb pasted "i think that's enough" at http://hpaste.org/5354
13:54:12 <ehird> r6rs
13:54:16 <litb> or?
13:54:17 <jonaskoelker> paczesiowa: looking at it
13:54:27 <litb> or do you have some nice idea what i could change?
13:55:00 <eugman|work> Paczesiowa, well short story is i have admin access to the linux computer but none of the windows ones. The real situation is just a little more complicated.
13:55:30 <eugman|work> And I can mainly test only ont he windows comps.
13:55:32 <paczesiowa> eugman|work: you cant compile software without admin on windows?
13:55:59 <eugman|work> Pacezsiowa, well I'd need to install the compiler and these are school computers.
13:56:04 <Cale> litb: I'm not sure what the goal is :)
13:56:16 <eugman|work> If I could find a compiler that would runn off my flash drive that'd be sweet.
13:56:59 <jonaskoelker> paczesiowa: can you extend the expression parser to include function calls?
13:57:00 <paczesiowa> eugman|work: install it at home and copy ghc dir on usb stick, it should work with proper $PATH
13:57:25 <Zao> paczesiowa: Which is hard.
13:57:45 <Zao> paczesiowa: Either the stick is fat32, and you're lacking symlinks and case sensitivity.
13:57:45 <nayru> hello. i am trying to find out what something like the following does: foo x = \bar y -> x + y ... i'm not really sure how to call something like that? (foo 5) 5?
13:57:49 <paczesiowa> jonaskoelker: add funcalls to factor parser (or give me appropiate data type, and gramma)
13:57:58 <Zao> paczesiowa: Or it's a native format that your admins most likely will restrict mounting of.
13:58:11 <Zao> Mounting it noexec or worse.
13:58:25 <Cale> jonaskoelker: mulop is, but you want to combine factors with mulop, not mulops with factor, no?
13:58:33 <eugman|work> I'll give it a try but any info on other options would be good in case any one thing doesn't work. Ghc under wine looks like it might work.
13:58:59 <Cale> nayru: or just foo 5 5, which is the same thing
13:59:00 <paczesiowa> Zao: you can't install ghc without ntfs on windows?
13:59:27 <paczesiowa> foo x = \bar y -> x + y === foo x y = x + y
13:59:38 <Cale> er
13:59:42 <nayru> Cale: oh, okay. in this book i'm reading, the author is making a parser, and he does something like that
13:59:45 <Zao> paczesiowa: I assumed you were talking about linux.
13:59:52 <Cale> foo x = \bar y -> x + y = foo x bar y = x + y
14:00:04 <Zao> Well, I misread eugman's line.
14:00:14 <Cale> d'oh :)
14:00:20 <Cale> foo x = \bar y -> x + y === foo x bar y = x + y
14:00:22 <eugman|work> zao, my bad?
14:00:54 <Zao> eugman|work: I snuck in a no before "admin access" :)
14:01:20 <nayru> Cale: return v = \inp -> [(v, inp)] ... why doesn't it say: return v inp = [(v, inp)] ?
14:01:25 <Cale> where the equivalence is not technically exact, but essentially you have the same thing (you can only tell the difference using seq, if you know what that is)
14:01:29 <paczesiowa> my bad with that foo
14:01:50 <Cale> nayru: Possibly the author wanted to emphasise the fact that it was producing a function.
14:01:50 <eugman|work> Ok so, ghc under wine, install at home and copy to usb and some mysterious cross compiler are the three options I'm aware of so far.
14:02:05 <paczesiowa> I'm sure it has nice name like alpha/beta/eta expansion/reduction
14:02:21 <nayru> Cale: aah. thanks
14:02:22 <Cale> nayru: you're thinking of \inp -> [(v,inp)] as a single parser computation
14:02:37 <Zao> eugman|work: Download a binary blob from haskell.org and install onto your stick?
14:02:42 <Zao> Provided you have download rights.
14:03:25 <jonaskoelker> Cale: got ya
14:03:28 <jonaskoelker> Cale: duh :\
14:03:29 <jonaskoelker> :)
14:03:33 <Cale> nayru: (the one which always produces a single result v, without eating any of the input)
14:03:47 <shachaf> paczesiowa: The name for (\x y -> x + y) --> (\x -> \y -> x + y)), you mean?
14:04:14 <paczesiowa> shachaf: yeah
14:04:15 <Cale> It's just expansion of the lambda syntax.
14:04:15 <shachaf> paczesiowa: That's called "syntax sugar". :-)
14:04:30 <byorgey> well, that's currying, isn't it?
14:04:50 <shachaf> byorgey: Currying is (\(x,y) -> x + y) --> (\x -> (\y -> x + y)).
14:04:52 <Cale> not quite, (\x y -> x + y) is already representing a curried function
14:05:06 <byorgey> well, ok, in Haskell it does.
14:05:09 <hpaste>  Paczesiowa annotated "for jonaskoelker" with "my expr parser" at http://hpaste.org/5353#a1
14:05:39 <paczesiowa> jonaskoelker: check that code, it parses funcalls
14:05:50 <eugman|work> zao, no. Paceze seemed to suggest installing on my windows copy at home and then moving it to usb.
14:05:53 <byorgey> but you could imagine using the (non-Haskell) syntax \x y -> x + y to represent a function of a tuple.
14:06:06 <byorgey> I didn't know how precise paczesiowa was being with notation.
14:06:13 <jeffz> eugman|work: wine should work fine, hello world does atleast and so does ghci, just make sure you get an up to date release of wine from http://winehq.org/download
14:06:15 <lambdabot> Title: Wine HQ - Wine Binary Downloads
14:06:21 <litb> hm, is there a graph showing the popularity of haskell?
14:06:26 <nayru> Cale: i see. i've finally come to the point where i'm learning about practical haskell. i've been reading definitions for a long time now
14:06:33 <jeffz> eugman|work: if you run into a bug, be sure to report it to the wine project
14:06:58 <jonaskoelker> thanks, paczesiowa
14:07:42 <eugman|work> jeffz, sure thing. Do you think wxHaskell or gtk will work too?
14:08:07 <Cale> http://www.haskell.org/haskellwiki/Image:Nick-activity.png -- litb: there's this graph of unique nicks in #haskell
14:08:08 <lambdabot> Title: Image:Nick-activity.png - HaskellWiki
14:08:38 <Cale> (obviously in need of a little updating soon :)
14:08:41 <jeffz> eugman|work: they should but if you do any complex stuff with custom listviews or treeviews you might notice some anomalies
14:09:14 <litb> thanks cale
14:09:36 <litb> oh that's nice it growing quickly
14:10:11 <litb> that littl grey thing is the estimate for 2008 ?
14:10:21 <Cale> litb: no, the estimate for 2007
14:10:32 <Cale> vs. the observed number at the time the graph was produced
14:10:40 <litb> ah i see
14:10:58 <Cale> There's also a graph somewhere of mailing list activity
14:13:01 <desegnis> There's also a funny pseudograph in SPJ's ¬ªtaste of Haskell¬´
14:13:25 <shachaf> ehird: Why do you have List/DottedList, rather than just Cons?
14:14:27 <Cale> http://dir.gmane.org/gmane.comp.lang.haskell.cafe
14:14:28 <lambdabot> Title: Gmane -- Mail To News And Back Again
14:14:42 <Cale> http://gmane.org/details.php?group=gmane.comp.lang.haskell.cafe
14:14:43 <lambdabot> Title: Gmane -- Detailed statistics
14:15:38 <RayNbow> too bad Google Trends can't determine the popularity of Haskell...
14:15:58 <jeffz> there's tiobe too, if it hasn't been mentioned yet
14:16:00 <Cale> Heh, is it just me, or do the detailed stats there need updating?
14:16:33 <dons> Cale, the irc stats on my page should be up to date
14:16:43 <dons> but gmane hasn't recomputed graphs since october
14:16:51 <Cin> according to ircbrowse.com, haskell's activity pretty much skyrocketted since 2005
14:16:56 <ehird> shachaf: simplicity in pattern matching
14:18:15 <shachaf> ehird: Can you join our Gobby session? :-)
14:19:16 <Cale> ah, http://www.cse.unsw.edu.au/~dons/irc/
14:19:17 <lambdabot> Title: Haskell IRC Activity
14:19:44 <Cale> That is quite a projection for unique nick count :)
14:21:55 <dons> the model is a bit wobbly early on in the year :)
14:22:43 <BMeph69> litb: Graph e^x with x going from 0 to 10. This approximates Haskell's popularity from 1988 to 2008. ;)
14:23:18 <dons> yeah, if anyone wants to do some curve fitting on the data
14:23:24 <davidL> > map exp [0..10]
14:23:25 <lambdabot>  [1.0,2.718281828459045,7.38905609893065,20.085536923187668,54.59815003314423...
14:23:25 <ehird> shachaf: No. I don't have Gobby and I think it's cleaner as multiple files.
14:23:25 <dons> to make predictions about what happens this year..
14:23:30 <shachaf> BMeph69: Popularity in what?
14:23:32 <ehird> Also, I already have code.
14:23:35 <litb> @src take
14:23:35 <lambdabot> take n _      | n <= 0 =  []
14:23:36 <lambdabot> take _ []              =  []
14:23:36 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
14:23:36 <ehird> I don't want to throw that away.
14:23:36 <shachaf> ehird: Gobby supports multiple files.
14:23:44 <shachaf> ehird: The Gobby code is based on yours, I think. :-)
14:23:47 <litb> BMeph69: lol
14:23:58 <ehird> shachaf: Yes, the very first revision.
14:24:02 <ehird> Since then it's changed a lot.
14:24:17 <shachaf> ehird: So come fix it! :-)
14:24:31 <ehird> No, the other will have diverged too much.
14:24:34 <shachaf> ehird: Make your own documents, and nobody will meddle with it without permission.
14:24:42 <ehird> Plus I don't like the Gobby style of interaction.
14:24:42 <shachaf> s/it/them/
14:25:00 <dolio> Anybody know off hand how to build/install the haddock from the GHC source tarball?
14:25:20 <roconnor> > scanl (\x->x+cos x) 0
14:25:20 <eugman|work> I'm having trouble finding anything. Are there libraries for printing? if not just producing pdf's should be sufficient.
14:25:21 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
14:25:21 <lambdabot>     Probabl...
14:25:37 <dons> eugman|work: printing what kind of stuff? to devices?
14:25:46 <Jiten> is there a way to specify more than one pattern in lambda function? I just got: *** Exception: <interactive>:1:5-26: Non-exhaustive patterns in lambda
14:25:47 <BMeph69> shachaf: Let's see, normalized for x=(year-1998)/2, result*10 = persons interested.
14:25:47 <dons> eugman|work: there are .pdf generation libraries
14:25:54 <dons> Jiten: nope. you have to use case
14:25:59 <dons> \x -> case x of ...; ...;
14:26:02 <eugman|work> dons, Like I want to get something to com out of the printer onto paper.
14:26:05 <roconnor> @type unfoldr
14:26:06 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:26:21 <dons> eugman|work: so generate pdf, then call some system util to print it?
14:26:29 <Jiten> dons: the lambda looks more like this: (\(x:xs) -> map (*x) xs)
14:26:31 <roconnor> > iterate (\x->x+cos x) 0
14:26:31 <lambdabot>  [0.0,1.0,1.5403023058681398,1.570791601024261,1.5707963267948966,1.570796326...
14:26:36 <eugman|work> dons, something of that sort, yes.
14:26:50 <davidL> > sqrt 2
14:26:50 <lambdabot>  1.4142135623730951
14:27:01 <roconnor> >pi/2
14:27:01 <Jiten> ... I guess I'll try the patterns in case :)
14:27:04 <shachaf> > pi / 2
14:27:05 <lambdabot>  1.5707963267948966
14:27:18 <eugman|work> Ah, I see the advantage of literate programming thatnks to this chat room
14:27:29 <shachaf> > iterate (\x -> x + sin x) 0 -- :-)
14:27:30 <dons> Jiten: it'll fail on the empty list though
14:27:32 <lambdabot>  [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0...
14:27:50 <Jiten> dons: that's what it's failing on
14:28:20 <dons> Jiten: right. \x -> case x of []-> e1 ; x:xs -> e2)
14:29:55 * lispy tweaks the piespy settings
14:30:09 <Jiten> dons: thank you, though I managed to write that myself before I saw you reply :)
14:30:21 <hrehf> so this is the reason for type aliases: std::pair< std::pair<int,int>, int> line_assoc = std::pair< std::pair<int,int>, int>( line_id, (m_lineIdx.size() - 1) )
14:30:23 <hrehf> ;)
14:30:30 <lispy> hrehf: yes
14:30:43 <lispy> hrehf: why java lacks them, we'lle never nknow
14:30:47 <hrehf> (not my code, just saw it pasted somewhere ;))
14:30:57 <dons> urgh. send 'em back to language design 1A
14:30:58 <Pseudonym> hrehf: That's not the only reason for them, but that's a pretty good argument.
14:31:09 <Pseudonym> And why Java lacks them, I know.
14:31:16 <Pseudonym> Because it didn't have generics.
14:31:24 <hrehf> true
14:31:24 <davidL> lispy: is piespy running on this channel?
14:31:29 <Pseudonym> No generics, no reason for type synonyms.
14:31:37 <lispy> davidL: yes, http://files.codersbase.com/haskell/haskell-current.png
14:31:47 <lispy> davidL: but i just restarted it, so it's a bit boring
14:31:55 <Pseudonym> And TBH, there's an argument for no type synonyms in Haskell if you've got newtype.
14:31:56 <davidL> neat :)
14:32:12 <Cale> lispy: why such a ridiculously large image?
14:32:26 <sebell> Cale: for fun!
14:32:35 <lispy> Cale: you want smaller? the default is 800x600, i bumped it to 1600x1200 because it's hard to read
14:32:41 <sebell> lispy: Sorry, I just wanted to be on the diagram ;)
14:32:42 <Pseudonym> That argument is much weaker if you don't have a really good module system, mind.
14:32:44 <litb> hm, anyone knows a good template for OpenOffice impress i could use?
14:32:49 <Pseudonym> As opposed to Haskell's merely adequate module system.
14:33:05 <Cale> lispy: I suppose it depends on how many people are talking.
14:33:15 <lispy> maybe 1200x900 is better?
14:33:24 <osfameron> who has a really good module system?
14:33:30 <Pseudonym> Modula-3.
14:33:31 <Pseudonym> O'Caml.
14:33:35 <sebell> lispy: As large as necessary is better...
14:33:35 * Pseudonym thinks
14:33:37 <Pseudonym> Ada, probably.
14:33:38 <Cale> 1024x768?
14:33:43 <sebell> Pseudonym: No SML?
14:33:45 <lispy> Cale: too small i think
14:33:50 <Cale> Really?
14:33:53 <Pseudonym> Does SML even HAVE a module system?
14:33:59 * Pseudonym can't remember
14:34:01 <Cale> How many users ever talk at the same time here?
14:34:05 <Cale> @users
14:34:05 <lambdabot> Maximum users seen in #haskell: 463, currently: 452 (97.6%), active: 29 (6.4%)
14:34:23 <sebell> Pseudonym: Yes, it does, and it's good ;0
14:34:27 <Cale> Maybe 40 or 50 at most?
14:34:31 <Pseudonym> OK, I believe you.
14:34:38 <dons> yeah. 'active' has been as high as 73, iirc
14:34:39 <Pseudonym> The ML family is known for decent module systems.
14:34:45 <Pseudonym> I didn't know if SML specifically did or not.
14:35:02 <dons> F# doesn't have a module system does it?
14:35:10 <Pseudonym> No, it has the .NET package system.
14:35:10 <monochrom> SML has a very advanced module system.
14:35:11 <Pseudonym> Which is... uh...
14:35:11 <dons> none of that academic mumbo jumbo
14:35:12 <jeffz> how many never talk?  they could be a crowd for hire for all we know....
14:35:13 <lispy> Cale: so, now I bumped down the size a bit and added a tiny bit of decay back
14:35:14 <Pseudonym> Kind of a module system.
14:35:24 <mauke> hrehf: couldn't the RHS be simplified to std::make_pair(line_id, m_lineIdx.size() - 1)?
14:35:48 <hrehf> mauke i have no idea, it was code someone pasted in c++
14:36:16 <Pseudonym> C++, in typical C++ fashion, has a language on which you can implement a nice module system if you're sufficiently well-disciplined.
14:36:20 <monochrom> SML's module system and OCaml's module system are very similar. Probably identical.
14:36:26 <Pseudonym> monochrom: Right.
14:36:33 <Pseudonym> I mentioned O'
14:36:42 <Pseudonym> Caml because not mentioning an ML would be a serious omission.
14:37:01 <lispy> one of the cool things about C++ typedefs is that you can put them inside something which takes a type as a parameter (inside a template definition) and thus your type is no longer hard coded.
14:37:14 <osfameron> isn't haskell in the ML family?
14:37:21 <monochrom> No. :)
14:37:22 <Pseudonym> osfameron: Kind of.
14:37:24 <lispy> and you can make that typedef public so users of your class can access your type variables
14:37:37 <paczesiowa> osfameron: no, it's pure and lazy
14:37:38 <Pseudonym> The common ancestor is ISWIM.
14:37:38 <osfameron> it looks very similar...
14:37:39 <noteventime> lispy: In my experience it tends to lead to problems though
14:37:40 <monochrom> Let's say some kind of cousin.
14:37:43 <sebell> I would say that Haskell is definitely not in the ML family of languages.
14:37:55 <Philippa> osfameron: it's not an ML, but there's a common ancestor and a Lazy ML was one of the influences
14:37:58 <noteventime> lispy: You have to add some keyword every time you use that typedef from ourside the class
14:38:15 <Pseudonym> Miranda (Haskell's ancestor) borrowed ML's type system.  That's the main similarity.
14:38:29 <noteventime> The syntax is also rather similar :-)
14:38:31 <monochrom> Distant relative.
14:38:45 <Pseudonym> More like a younger cousin who kept borrowing clothes.
14:38:58 <Pseudonym> The syntax is similar because it's all lambda calculus.
14:39:01 <monochrom> Like Bilbo Baggins and Frodo Baggins.
14:39:06 <Cale> "Can I have your hair shirt?"
14:39:23 <Pseudonym> Apart from that, ML has a very 70s syntax.  Haskell has a very modern syntax.
14:39:36 <dons> what syntax does Arc have?
14:39:44 <Pseudonym> ML is a similar age to Prolog and SQL.  And it shows.
14:39:45 <osfameron> oh well, I know bits of C-like languages like Perl, SQL, Lisp, etc., and haskell *looks* superficially very much like the ML examples I've seen, compared to, well, everything else
14:40:02 <noteventime> dons: A lot like scheme
14:40:06 <dons> Pseudonym: and Erlang too, I guess.
14:40:08 <sarehu> SQL is a C-like language??
14:40:10 <Pseudonym> Yeah.
14:40:11 <noteventime> From the little I've seen
14:40:13 <Pseudonym> Well.
14:40:14 <dons> weirdly timecapsuled syntax
14:40:15 * monochrom avoids picking osfameron :)
14:40:16 <Pseudonym> Erlang is younger.
14:40:26 <monochrom> err, picking on osfameron :)
14:40:26 <Pseudonym> But it borrows most of its syntax from Prolog et al.
14:41:00 <monochrom> Anyway, why would anyone classify notation by "c-like" vs "not c-like"?
14:41:00 <osfameron> er, I think I meant to separate SQL and Lisp out with ";" rather than ","
14:41:17 <lispy> yeah, I would think SQL is closer to functional than C
14:41:18 * monochrom thinks the right classification should be haskell-like and not-haskell-like
14:41:33 <monochrom> E.g., ML is haskell-like. C is not-haskell-like.
14:41:34 <osfameron> monochrom: because a vast number of popular languages: C, C++, Java, Perl, Javascript, have superficially C-like syntax
14:41:41 <lispy> who said that about monkies? the universe is just bananas and non-bananas?
14:42:01 <monochrom> the universe is just bananas, lenses, barbed wires, ...
14:42:23 <Pseudonym> The Turner syntax (Miranda/Haskell) owes more to... well, it's pretty much as close a rendering of standard mathematical notation as you can get in ASCII.
14:42:27 <Pseudonym> With a bit of Occam thrown in.
14:42:46 <wagle_> is python haskell-like?  8)
14:42:54 <Pseudonym> wagle_: Yes.
14:43:00 * cjb votes yes too.
14:43:03 <Pseudonym> Python is also heavily influenced by Occam.
14:43:09 <Pseudonym> But it's borrowed a LOT from Haskell.
14:43:14 <monochrom> python has too many "def" and parenthesis to be non-haskell-like IMO
14:43:35 <Pseudonym> Yeah.
14:43:41 <Pseudonym> That's the 70s influence there.
14:43:44 <monochrom> E.g., "def f(a): " instead of "f a ="
14:43:54 <dons> Pseudonym: they dispute that though. only list comprehensions are officially from haskell, afaik.
14:44:04 * Pseudonym nods
14:44:13 <osfameron> bah, python dispute being influenced by Perl too
14:44:36 <Pseudonym> To be honest, it's probably more the vibe of the thing.  Python is of a similar age to Haskell, so it got a similar syntax from its environment.
14:44:36 <monochrom> revisionist history disputes all influences.
14:45:25 <Pseudonym> Let me try to get the family tree right.
14:45:26 <Pseudonym> ML family:
14:45:27 <jedbrown> If anyone is interested, the Arc obby session is now at vawpc50.ethz.ch:6522
14:45:33 <Pseudonym> Lisp -> ISWIM -> ML -> modern MLs
14:45:38 <Pseudonym> Turner family:
14:45:46 <Pseudonym> Lisp -> ISWIM -> SASL -> KRC -> Miranda -> Haskell
14:45:56 <osfameron> obby?
14:45:59 <kuribas> Pseudonym: where comes scheme?
14:46:04 <Pseudonym> I was getting to that.
14:46:06 <Pseudonym> Lisp -> Scheme
14:46:08 <Pseudonym> :-)
14:46:23 <jedbrown> osfameron: multi-user editing session.  Gobby is the normal client.
14:46:25 <Pseudonym> Miranda can be thought of as KRC with an ML-like type system.
14:46:31 <kuribas> Scheme was created the same time as ML?
14:46:36 <dons> would be nice to get a KRC bot in here ..
14:46:39 <Pseudonym> Similar ages, yeah.
14:46:41 <osfameron> jedbrown: ah, I think I've bookmarked gobby at some point.  ta
14:47:05 <Pseudonym> ML and Scheme both date from the time when people were really thinking about semantics formally.
14:47:30 <ddarius> Nowadays people just sling semantics around willy-nilly.
14:47:49 <dons> they decided semantics was too hard :)
14:47:49 <Pseudonym> I did have some KRC code once.
14:47:56 <dons> it was easier to go shopping for features
14:48:01 <Pseudonym> My task was to port it to Miranda.
14:48:23 <Pseudonym> SASL is was also from around the same time as Scheme and ML.
14:48:28 <Pseudonym> But it wasn't as influential at the time.
14:49:04 <olsner> shachaf: ping
14:49:59 <tautologico> ML's modules are also a very 70s thing
14:50:08 <dpiponi> Hi Pseudonym
14:50:08 <lambdabot> dpiponi: You have 1 new message. '/msg lambdabot @messages' to read it.
14:50:20 <Pseudonym> Hi dpiponi.
14:50:57 <Philippa> tautologico: no more so than classes
14:51:15 <dpiponi> Just started trying to read up on that category theory stuff you pointed out to me on my blog
14:51:19 <tautologico> classes started with simula in the 60s
14:51:31 <dpiponi> (I assume pseudonym=Pseudonym)
14:51:35 <tautologico> but it was not very famous in the 70s
14:51:36 <monochrom> boolean algebra is very 1600's.
14:51:42 <tautologico> module systems were all the rage
14:51:47 <idnar> hmm
14:51:48 <tautologico> modula, modula-2, etc
14:51:48 <Pseudonym> dpiponi: Well, stricmp("pseudonym","Pseudonym") == 0, anyway.
14:52:19 <dpiponi> Pseudonym: it's going to take a little while though
14:52:22 * idnar ponders a type constructor syntax like b <- a -< c
14:52:34 <Pseudonym> Could you remind me which blog entry that was?
14:52:51 <dpiponi> The one about U=U->Bool
14:52:55 <Pseudonym> Ah!
14:52:56 <Pseudonym> Right.
14:53:19 <dpiponi> You got me worried that pseudonym/=Pseudonym for a moment there!
14:54:51 <ehird> Is there an IRC *library* for Haskell?
14:55:16 <ehird> (Random lambdabot question: how does it keep track of karma when nick changes happen?)
14:55:30 <dpiponi> What's the deal with some GHC flags being of the form -Xxxx and some being of the form -fxxx?
14:55:40 <davidL> @hackage irc
14:55:40 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/irc
14:55:43 <cjb> dpiponi: ghc hates you.
14:55:57 <byorgey> dpiponi: -Xxxx are for langauge extensions.
14:56:05 <byorgey> dpiponi: -fxxx is for everything else.
14:56:18 <Pseudonym> -Xglasgow-exts
14:56:25 <monochrom> -fffffffi
14:56:28 <ehird> dpiponi: Does that have an IRC monad?
14:56:33 <ehird> If not, to hell with it. :D
14:56:39 <ehird> ircmonad is an awesome name
14:56:45 <dpiponi> Is that new in 6.8? And how do I switch on 'extensions' as a pragma in a comment
14:56:57 <byorgey> ehird: grab the lambdabot source and see for yourself =)
14:57:00 <byorgey> @version
14:57:00 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
14:57:00 <lambdabot> darcs get http://code.haskell.org/lambdabot
14:57:13 <byorgey> ehird: (translation: I don't know)
14:57:24 <monochrom> {-# LANGUAGE RankNTypes, NoMonomorphismRestriction #-}
14:58:24 <dpiponi> monochrom: Excellent. Thanks!
14:58:35 <ehird> -- |The type of nicknames isolated from a message.
14:58:35 <ehird> data Nick
14:58:35 <ehird>   = Nick {
14:58:35 <ehird>         nTag :: !String, -- ^The tag of the server this nick is on
14:58:35 <ehird>         nName :: !String -- ^The server-specific nickname of this nick
14:58:36 <ehird>   }
14:58:39 <ehird> @karma ehird
14:58:39 <lambdabot> You have a karma of 0
14:58:42 <ehird> hrm
14:58:46 <ehird> someone change my karma so i can test this :P
14:58:50 <davidL> ehird++
14:58:54 <monochrom> -X is new in 6.8.  -XRankNTypes -XNoMonomorphismRestriction
14:58:55 <Pseudonym> Is it just me, or is !String kind of useless?
14:59:22 <Pseudonym> Woo!  My first cons cell is strict!
14:59:23 <monochrom> Yes, !String is usually useless alone.
14:59:39 <ehird> @karma ehird
14:59:40 <lambdabot> You have a karma of 1
14:59:48 <totallynotehirdi> hmph
14:59:48 <TomMD> @karma monochrom
14:59:49 <lambdabot> monochrom has a karma of 19
14:59:52 <totallynotehirdi> i wanted totallynotehirdimeanreally
14:59:54 <totallynotehirdi> @karma totallynotehirdi
14:59:54 <lambdabot> You have a karma of 0
14:59:56 <monochrom> But you can combine with other things or other self-disciplines to make it useful.
15:00:00 <totallynotehirdi> @karma+ ehird
15:00:00 <lambdabot> ehird's karma raised to 2.
15:00:05 <ehird> @karma
15:00:05 <lambdabot> You have a karma of 2
15:00:09 <ehird> well
15:00:14 <ehird> that totally isn't crazy :)
15:00:17 <dejones_> @karma
15:00:17 <lambdabot> You have a karma of 0
15:00:25 <ehird> @karma+ davidL
15:00:25 <lambdabot> davidL's karma raised to 0.
15:00:28 <ehird> haha
15:00:28 <kuribas> Does anyone have a good idea to rename my haskell-indent.el file? I was thinking of haskell-indentation.el, or haskell-tab-indent.el.
15:00:33 <dejoens> @karma
15:00:33 <lambdabot> You have a karma of 0
15:00:41 <dejoens> :(
15:00:41 <dejoens> hehe
15:00:43 <kuribas> @karma
15:00:43 <lambdabot> You have a karma of 0
15:00:55 <dejoens> I can't type today
15:00:57 <davidL> raised to 0? :[
15:01:01 <ehird> Basically, lambdabot hates our freedom to change nicknames. :-)
15:01:03 <monochrom> For example if you also make sure that all your string-producing functions are deeply eager, then !String will trigger the whole process.
15:01:09 <ehird> So don't try and use it with a different nick!
15:01:19 <dejones> @karma
15:01:19 <lambdabot> You have a karma of 0
15:01:21 <Cale> kuribas: tab indent?
15:01:40 <kuribas> because it treats indentation as virtual tabs.
15:01:45 <litb> hm, what does !String mean?
15:01:50 <Cale> ah
15:01:50 <litb> i.e the ! before String?
15:01:55 <byorgey> litb: it's a strictness annotation
15:02:12 <kuribas> Cale: At least for the keys TAB, DEL and BACKSPACE.
15:02:17 <byorgey> litb: it means that field/argument/whatever should be strict
15:02:30 <litb> meaning that it should not hold a lazy list?
15:02:41 <ehird> You know what I hate about most IRC libraries?
15:02:46 <ehird> They're only designed for one server.
15:02:53 <ehird> You can't create something uniform across multiple servers.
15:02:57 <ehird> easily.
15:03:14 <dolio> litb: It's not quite that strict.
15:03:29 <Botje> ehird: select() is hard, let's go shopping.
15:03:42 <dolio> litb: What it will ensure is that the list isn't bottom.
15:03:55 <litb> oh i see
15:03:58 <litb> will it error out then?
15:04:02 <Philippa> ehird: that shouldn't happen too much in Haskell so long as you're using concurrency appropriately - you might have to manually shove messages all down the same pipe at some point, I guess
15:04:06 <litb> (i tried a bottom list and it locked ghci)
15:04:15 <dolio> (Or, if it is bottom, the entire datatype will be bottom.)
15:04:37 <litb> i see
15:04:45 <litb> is there a function to test for bottom-ness?
15:04:56 <monochrom> Not perfectly.
15:05:09 <mauke> isBottom x = x `seq` False
15:05:10 <ehird> What i mean is,
15:05:20 <ehird> you have callbacks belonging to servers
15:05:21 <ehird> and all that
15:05:36 <ehird> The best solution is to have a Client, which has a list of Servers, but also a list of Callbacks.
15:05:40 <ehird> And they are applied uniformly.
15:05:41 <Cin> ehird: then i will make my ircd work across servers
15:05:47 <monochrom> All these are mathematically grouped into "bottom": infinite loops, errors, missing cases in pattern-matching.
15:05:50 <ehird> Also, nicknames should be considered to be identical over networks
15:06:01 <ehird> 'foo' in freenode is 'foo' in efnet,.
15:06:05 <ehird> So karma etc. can persist.
15:06:11 <ehird> This stuff is trivial, but not so with most IRC libs.
15:06:14 <monochrom> So, some of them you can catch as exceptions, some of them you can try a time-out but can't be perfect.
15:06:15 <mauke> I think that's a bad idea
15:07:09 <litb> > let isBottom x = x `seq` False in isBottom (let q = zipWith (+) q q in q)
15:07:10 <lambdabot>  Exception: <<loop>>
15:07:21 <litb> hm
15:07:26 <idnar> > let isBottom x = x `seq` False in 5
15:07:26 <lambdabot>  5
15:07:27 <ehird> litb: you can't solve the halting problem
15:07:29 <litb> i fail
15:07:33 <idnar> :t seq
15:07:34 <lambdabot> forall a t. a -> t -> t
15:07:34 <ehird> but nice try
15:07:40 <idnar> > let isBottom x = x `seq` False in isBottom 5
15:07:41 <lambdabot>  False
15:07:44 <idnar> (oops *blush*)
15:07:52 <litb> isn't "let q = zipWith (+) q q in q" a bottom list?
15:07:58 * monochrom points you to the @faq session several hours ago :)
15:08:05 <idnar> litb: it is
15:08:06 <ehird> litb: You cannot solve the halting problem.
15:08:10 <idnar> litb: which is why you got an infinite loop there
15:08:19 <litb> oh. i see
15:08:41 <litb> i thought that that function was supposed to test for bottomness thus i tried
15:08:42 <phobes> wow, there's like 100 people in #arc
15:08:45 <idnar> that isBottom function returns False if it's not bottom, and bottom if it is (afaict)
15:08:54 <dolio> litb: isBottom is bottom when the argument is bottom, and False when the argument is not bottom.
15:09:06 <dolio> Oops, too late.
15:09:18 <litb> oh i see
15:09:19 <monochrom> It would be funny if in a few weeks #arc size surpasses #haskell size. :)
15:09:43 <litb> > let isBottom x = x `seq` False in isBottom (let q = 1 : zipWith (+) q q in q)
15:09:43 <lambdabot>  False
15:09:48 <litb> nice
15:09:57 <dolio> Most people seem fairly negative about it, so the only way that'd probably happen is if #arc is filled with people complaining about it.
15:10:07 <litb> and if it is bottom it throws
15:10:08 <ddarius> monochrom: That would ensure that in a few weeks more it's size will then dramatically reduce.
15:10:23 <Cale> litb: If there was an isBottom which gave True reliably whenever its argument was bottom, and False otherwise, then it would be a solution to the Halting problem :)
15:11:00 <ddarius> halts = not . isBottom
15:11:00 <idnar> > let q = 1 : zipWith (+) q q in q
15:11:00 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
15:11:07 <byorgey> I wrote a solution to the Halting problem like a year ago
15:11:14 <byorgey> unfortunately it is still compiling
15:11:14 <idnar> oh duh
15:11:35 <idnar> haha
15:11:54 * ehird starts working on IRCMonad!
15:11:59 <ddarius> byorgey: That's what you get for using JHC.
15:12:00 <dolio> litb: Anyhow, what 'seq x y' does is say, "whenever you want to evaluate some of y, evaluate x first" where "evaluate" means evaluate enough to get a top level constructor.
15:12:22 <wagle_> there is a real number that encodes the solution to the halting problem
15:12:24 <byorgey> ddarius: haha!
15:12:47 <wagle_> so all you need in your programming language is real real-numbers
15:12:59 <byorgey> wagle_: what, Chaitin's Omega?
15:13:25 <dolio> So, when you have a data type like "data Foo = F !Bar Baz", the constructor becomes something like "F bar baz = bar `seq` RealF bar baz".
15:13:33 <Cale> The expression (seq x y), when evaluated, will cause x to be evaluated up to determining its top-level constructor before resulting in y.
15:13:36 <wagle_> dunno, i've never actually gotten around to reading chaitin yet..  8(
15:13:59 <wagle_> he'd do something like that, i expect
15:14:02 <byorgey> wagle_: well, unfortunately it is not computable ;)
15:14:34 <wagle_> use an analog computer..  8)
15:14:41 <idnar> I have a truly marvelous solution to the Halting problem; unfortunately this IRC channel is too narrow to contain it.
15:15:07 <Japsu> @remember idnar I have a truly marvelous solution to the Halting problem; unfortunately this IRC channel is too narrow to contain it.
15:15:07 <lambdabot> Good to know.
15:15:59 <monochrom> And if you write it out, this universe is too short-lived to execute it.
15:16:56 <dolio> Maybe he has an oracle based on nullity.
15:17:27 <kuribas> If I name my mode haskell-virtual-tab.el, is it clear that it is an indentation mode?
15:17:29 <paczesiowa> I read that as nudity
15:18:21 <ddarius> paczesiowa: Nudity too is an important ingredient.
15:18:34 <wagle_> sounds like it has tabs, but not really..  like maybe they havent been computed yet
15:18:45 <wagle_> 8)
15:19:06 <kuribas> wagle_: yeah, that's right actually.
15:19:23 <dolio> Oh, Perspex machine is the name.
15:19:36 <byorgey> dolio: eh? what's that?
15:19:51 <shepheb> info
15:19:58 <shepheb> whoops, sorry
15:20:14 <dolio> It's a machine invented by the same guy as nullity that was allegedly more powerful than a Turing machine (and buildable, I guess).
15:20:29 <monochrom> great
15:21:00 * byorgey googles
15:21:05 <monochrom> could he ever stop naming his inventions funny?
15:22:01 <dolio> Nullity being the answer to "what is 0/0".
15:22:58 <LoganCapaldo> is Cale gonna do a post about the Perspex machine to match his post about nullity?
15:23:13 <Cale> LoganCapaldo: I haven't really read about that.
15:24:18 <byorgey> dolio: oh, that guy
15:24:31 <dolio> Exactly.
15:27:26 <TomMD> Hackage needs the new Haddock installed.  Anyone here admin?
15:28:10 <ehird> hmm, is the program lambdabot uses for safe evaluation available somewhere?
15:28:58 <byorgey> ehird: eh?
15:29:10 <TomMD> @where lambdabot
15:29:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
15:29:16 <ehird> byorgey: the sandboxy thing it does, is it available OUTSIDE of lambdabot?
15:29:27 <ehird> that is, outside of the lambdabot libraries and stuff that it probably depends on
15:29:36 <LoganCapaldo> it's called not letting you do things in IO :)
15:29:39 <byorgey> ehird: I think it just sets OS resource limits and things like that, I'm not sure
15:29:49 <byorgey> ehird: there's a wiki page describing it somewhere
15:30:00 <ehird> LoganCapaldo: Sure. But I don't want to rewrite all of it :P
15:30:00 <LoganCapaldo> security thru types!
15:30:51 <TomMD> LoganCapaldo: Only once types can limit memory, CPU computation, and perhaps even instructions at the ASM level.
15:30:57 <TomMD> :-)
15:31:07 <LoganCapaldo> I feel like types could do that
15:31:15 <TomMD> It would be an awesome and... completely unusable... typesystem that could do all that!
15:31:40 <LoganCapaldo> the instructions at the assempbly level already sort of exists
15:31:43 <edwardk> only once meaning linear?
15:31:50 <LoganCapaldo> there are priveleged instructions in most archs
15:31:53 <litb> hm, is there a good book about haskell and FB that you could recommend me and my listeners?
15:32:05 <LoganCapaldo> that's arguably "typing"
15:32:13 <litb> looks like the one by Richard Birds is good?
15:32:30 <byorgey> ehird: http://haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
15:32:30 <lambdabot> http://tinyurl.com/3alo2u
15:32:55 <byorgey> litb: FB? listeners?
15:33:12 <litb> errm, i mean FP
15:33:14 <litb> indeed
15:33:37 <ehird> runplugs is what i want
15:33:42 <ehird> does it depend on lambdabot?
15:33:58 <conal> litb: i second bird.
15:34:39 <dibblego> what pragma allows me to use a file containing #ifdef?
15:35:05 <dibblego> er, ghc option
15:35:08 <conal> litb: i really liked "a gentle introduction to haskell"
15:35:33 <monochrom> Ha, the gentle introduction enjoys a resurgence of interest recently!
15:35:42 <LoganCapaldo> i'm  not sure I actually made it all the way thru any of the tutorials
15:35:52 <LoganCapaldo> i think I grazed at all of them
15:36:07 <ddarius> The Gentle Introduction is pretty good if brisk.
15:36:09 <conal> "gentle" was my introduction to haskell.  got me fired up!
15:36:29 <ehird> > newtype X = X
15:36:30 <lambdabot>  Parse error at "newty..." (column 1)
15:36:34 <LoganCapaldo> but I'm still learning, obviously
15:36:41 <shepheb> it requires a certain type of background, though.
15:36:41 <ehird> > stToIO
15:36:42 <ddarius> Yep, the Gentle introduction was the thing I read to get started with Haskell.
15:36:42 <lambdabot>   Not in scope: `stToIO'
15:36:44 <ehird> bah
15:36:45 <ehird> :)
15:36:50 <LoganCapaldo> ehird: even if lb let you do declarations, that does not compute
15:36:54 <ehird> > unsafeCoerce#
15:36:54 <lambdabot>   parse error on input `}'
15:36:59 <ehird> goddamn
15:37:00 <ehird> :D
15:37:11 <monochrom> For years the consensus has been saying "it is the worst, go read something else - anything else". Now we come out of the closet and say "I learned from the gentle introduction!"
15:37:43 <ddarius> monochrom: I've always recommended the Gentle Introduction.
15:38:15 <LoganCapaldo> ddarius: we thought you  were being sarcastic!
15:38:23 <monochrom> I do too. But last year and before, my voice was ignored.
15:38:25 <Mr_Awesome> i liked the gentle introduction
15:38:41 <Philippa> I learned from it. I don't know that I'd recommend it, but it was decent as an "if you half know what you're doing" intro
15:38:51 <TomMD> I liked yaht (believe it!)... and several books.
15:39:01 <monochrom> For every voice for it, there were 10-20 voices saying "YAHT".
15:39:12 <Mr_Awesome> what i really didnt like at all was the scheme in 48 hrs
15:39:12 <ehird> hm
15:39:12 <monochrom> I'm glad now the tide has turned.
15:39:16 <ehird> how do I get System.Eval.Haskell
15:39:16 <ehird> ?
15:39:18 <ddarius> I never finished reading YAHT.  It didn't exist when I first started learning Haskell.
15:39:22 <conal> @where yaht
15:39:22 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
15:41:45 <ehird> src/Language/Hi/Binary.hs:90:7:
15:41:45 <ehird>     Could not find module `Data.Array.Base':
15:41:45 <ehird>       it is a member of package array-0.1.0.0, which is hidden
15:41:47 <ehird> what does this error mean?
15:42:22 <paczesiowa> you have to add array to cabal file
15:42:26 <NF9> I found YAHT excellent. Also helped to have learned ML beforehand.
15:42:39 <ehird> paczesiowa: how? <.<
15:42:50 <byorgey> ehird: add it to the build-depends: field
15:43:07 <paczesiowa> ehird: there is cabal file somewhere with dependancy line, add array there
15:44:03 <resiak> so how would i go about writing quickcheck properties for this libtracker binding?  should it be something like "run random queries against both the command-line client and the binding and check they're the same" ?
15:44:25 <LoganCapaldo> that doesn't sound very quickchecky
15:44:53 <BMeph> ehird: Remember, when your program build craps out, look to the build-depends... ;p
15:44:58 <Cin> NF9: i liked that yaht had exercises. helped me take it in better
15:45:04 <resiak> it doesn't.  maybe this is the kind of thing i should just not bother quickchecking.  :-)
15:47:08 <ehird> byorgey: but i used cabal install
15:47:08 <ehird> :(
15:47:24 <byorgey> ehird: what did you install
15:47:26 <byorgey> ?
15:47:34 <ehird> hs-plugins
15:47:38 <ehird> for language.haskell.evak
15:47:39 <ehird> l
15:47:41 <paczesiowa> ehird: fix cabal file, reconfigure rebuild and reinstall
15:47:49 <ehird> paczesiowa: i cabal install'd
15:47:51 * byorgey backs away slowly
15:48:09 <byorgey> I don't know anything about hs-plugins...
15:48:45 <byorgey> ehird: you got that error while cabal install was trying to build it?
15:50:05 <ehird> yes
15:50:38 <byorgey> ehird: I assume you do have the array package installed?
15:51:11 <ehird> i think so? :
15:51:12 <ehird> |
15:51:16 <Saizan> ?hackage hs-plugins
15:51:16 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hs-plugins
15:51:16 <paczesiowa> if it says it's hidden then I think he has it
15:51:25 <byorgey> paczesiowa: I think you're right.
15:51:28 <ehird> % sudo cabal install array
15:51:28 <ehird> Password:
15:51:28 <ehird> All requested packages already installed. Nothing to do.
15:52:25 <Saizan> ehird: the hs-plugins package on hackage won't work on 6.8.2 anyway
15:52:47 <Saizan> ehird: grab it from code.haskell.org/~dons/code/hs-plugins
15:57:50 <ehird> hm
15:57:54 <ehird> how do i get ghc to link properly
15:58:46 <LoganCapaldo> syupid quetion, didja use --make?
15:58:52 <LoganCapaldo> wow
15:58:55 <LoganCapaldo> I can't type
15:58:56 <opqdonut> nice typos
15:58:59 <opqdonut> :)
16:00:31 <ehird> hm
16:00:31 <ehird>     Failed to load interface for `ShowQ':
16:00:31 <ehird>       Use -v to see a list of the files searched for.
16:01:12 <LoganCapaldo> @index ShowQ
16:01:12 <lambdabot> bzzt
16:01:27 <LoganCapaldo> it doesn't exist! run
16:01:32 <LoganCapaldo> @hoogle ShowQ
16:01:32 <lambdabot> No matches found
16:01:43 <TomMD> @karma lambdabot
16:01:43 <lambdabot> lambdabot has a karma of 56
16:01:45 <LoganCapaldo> @go haskell ShowQ
16:01:46 <lambdabot> http://tuukka.iki.fi/tmp/haskell-2007-11-21.html
16:01:46 <lambdabot> Title: haskell-2007-11-21
16:02:06 <Saizan> ShowQ is from lambdabot..
16:02:22 <ehird> ah
16:02:22 <dons> ehird: ensure you use the ./build script
16:02:25 <Saizan> ehird: have you used the build script?
16:02:35 <LoganCapaldo> I was wondering why that search result felt recursive
16:02:48 <ehird> Saizan: No. I don't want lambdabot -- I want runplugs
16:02:49 <ehird> :)
16:03:11 <dons> you can remove the ShowQ stuff from RunPlugs.hs then
16:04:20 <ehird> Won't that lose me prettyprinting though?
16:06:27 <dons> probably
16:06:30 <dons> > ord
16:06:31 <lambdabot>  <Char -> Int>
16:06:32 <dons> that stuff
16:06:35 <ehird> yeah
16:07:07 <ehird> heh:
16:07:08 <ehird> runplugs:
16:07:08 <ehird> unknown symbol `___stginit_haskell98_Random_'
16:07:08 <ehird> runplugs: user error (resolvedObjs failed.)
16:09:11 <Saizan> ehird: remove the haskell98 modules, or find a way to link the haskell98 package when building
16:10:11 <dons> no 'hardcore erlang'. hmm
16:10:37 <ehird> dons: did you expect something else from him?
16:10:44 <ehird> Saizan: okies
16:10:47 <dons> i'm not sure what I expected.
16:10:56 <ehird> this guy changes languages every week, dons
16:11:00 <ehird> look at his twitter log
16:11:06 <ehird> on the same page he switches languages 2 or 3 times
16:11:07 <ehird> seriously
16:11:15 <ehird> http://twitter.com/wagerlabs
16:11:18 <lambdabot> Title: Twitter / wagerlabs
16:11:39 <dons> that's a scary insight into something we previously only suspected
16:11:45 <ehird> he used Haskell jan 28-29
16:11:52 <ehird> long live haskell, RIP haskell
16:12:18 <dons> i think he must be the first person *ever* to abandon haskell for factor :)
16:12:19 <ehird> then jan 29-30 was factor
16:12:20 <ehird> now it's K
16:12:21 <dons> slava'll be happy
16:12:25 <dons> oh K. interesting
16:12:36 <ehird> it's hilarious reading that page
16:12:40 <ehird> it's such a tiny snapshot
16:12:42 <ehird> but it says so much
16:12:47 <dons> its an amazing snapshot
16:12:50 <dons> we should archive it.
16:12:55 <ehird> yes
16:13:01 <ehird> hm
16:13:07 <ehird> how do you tell wget to get a page+its dependencies
16:13:13 <dons> anyone know what " Haskell has acquired quasiquotations now" is about?
16:13:17 <ehird> well, immediate dependencies
16:13:19 <ehird> stylesheets etc
16:13:22 <ehird> dons: beats me
16:13:26 <ehird> but he mentioned caml4p
16:13:27 <byorgey> dons: template haskell maybe?
16:13:29 <ehird> so some kind of macro thing
16:13:30 <ehird> template haskell?
16:13:37 <dons> so hmm. but he knew about that.
16:14:25 <byorgey> dons: well, that twitter page is not the log of a fully rational being.
16:14:25 <EvilTerran> "haskell is complexity" sayeth the guy apparently jumping into TH on his second day using a language
16:14:54 <dons> well, he's been poking haskell with a stick for the last 3 years
16:15:03 <dons> if it kicks back,he runs :)
16:15:19 <byorgey> poking haskell with a stick is not recommended =)
16:15:27 <jonaskoelker> Hey all; I could use little (more) help with parsec :)
16:15:33 <jonaskoelker> My code's at http://rafb.net/p/SRnURQ49.html
16:15:33 <resiak> could it be said to be unsafe?
16:15:33 <_alf_> who is this? was he writing a book on erlang/
16:15:34 <lambdabot> Title: Nopaste - No description
16:15:40 <byorgey> much better to pet it and feed it lambdas
16:15:48 <ehird> byorgey: awww
16:16:17 <jonaskoelker> Here's an example of the code I want to parse: http://rafb.net/p/SRnURQ49.html
16:16:17 <lambdabot> Title: Nopaste - No description
16:16:28 <byorgey> "who's a good language? you're a good language!  yes you ARE!"
16:16:52 <byorgey> _alf_: yes, he was.  now, he's... not.
16:16:52 <jonaskoelker> at line 4, col 11, I get unexpected "=", expected "("
16:17:13 <BMeph> ?wiki Quasiquotations
16:17:13 <lambdabot> http://www.haskell.org/haskellwiki/Quasiquotations
16:17:27 <byorgey> very funny BMeph =)
16:17:29 <opqdonut> :)
16:17:48 <Pseudonym> Yeah, it's a good language.  Never a GREAT language.
16:18:02 <Pseudonym> (New Yorker joke for those who get it.)
16:18:10 <paczesiowa> jonaskoelker: you pasted the same url twice
16:18:19 <jonaskoelker> oh yeah, crap
16:19:00 <jonaskoelker> http://rafb.net/p/qwrrvs89.html
16:19:00 <lambdabot> Title: Nopaste - No description
16:19:09 <BMeph> byorgey: Not that funny, it's what - 3-5 years old, if not older? Maybe in his Speed Dating languages, he stumbled on it... ;)
16:19:33 <paczesiowa> jonaskoelker: don't read /dev/input ! use getContents
16:20:02 <BMeph> Never mind, I know I've seen that paper somewhere, I just have to recall right...
16:20:38 <byorgey> BMeph: I meant, using the ?wiki command was funny
16:20:52 <byorgey> ?wiki BMephIsFunny
16:20:52 <lambdabot> http://www.haskell.org/haskellwiki/BMephIsFunny
16:21:06 <ehird> ?wiki
16:21:06 <lambdabot> http://www.haskell.org/haskellwiki/
16:21:10 <ehird> helpful.
16:21:21 <ehird> question about packaging: is having two cabal files in a project root OK?
16:21:29 <ehird> i have IRCMonad and a bot based on it..
16:21:32 <ehird> so ircmonad.cabal and thing.cabal
16:21:34 <ehird> is that okay?
16:21:43 <paczesiowa> jonaskoelker: I don't know if this is you problem, but I think you have big problem with factor and statement parsers
16:21:43 <davidL> @. wiki run ['a'..'z']
16:21:44 <lambdabot> http://www.haskell.org/haskellwiki/_"abcdefghijklmnopqrstuvwxyz"
16:21:47 <BMeph> byorgey: I think it's even funnier usong "?go" to find stuff:
16:21:52 <BMeph> ?go hoogle something
16:21:53 <lambdabot> http://www.haskell.org/pipermail/cabal-devel/2007-January.txt
16:22:00 <byorgey> BMeph: hehe, indeed
16:22:11 <opqdonut> isn't ?go google?
16:22:12 <ehird> @. wiki run replicate"a"
16:22:12 <lambdabot> http://www.haskell.org/haskellwiki/_Couldn't_match_expected_type_`Int'_against_inferred_type_`[Char]'
16:22:17 <ehird> hahahahahah
16:22:20 <paczesiowa> jonaskoelker: you choose between various parsers, but <|> works only if first parser fails without consuming any input
16:22:23 <ehird> @. wiki run replicate'a'
16:22:24 <lambdabot> http://www.haskell.org/haskellwiki/__Not_in_scope:_`replicate'a''
16:22:30 <ehird> @. wiki run replicate('a')
16:22:31 <lambdabot> http://www.haskell.org/haskellwiki/_Couldn't_match_expected_type_`Int'_against_inferred_type_`Char'
16:22:34 <ehird> sheesh
16:22:38 <davidL> @. wiki run repeat 'a'
16:22:38 <lambdabot> http://www.haskell.org/haskellwiki/_"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
16:22:43 <ehird> brilliant
16:22:56 <paczesiowa> jonaskoelker: so you have to explicitly "try" parsers that can fail later than first character
16:23:10 <ehird> @quote <davidL> @. wiki run repeat 'a' <lambdabot> http://www.haskell.org/haskellwiki/_"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
16:23:11 <lambdabot> No quotes for this person. Have you considered trying to match wits with a rutabaga?
16:23:21 <ehird> hrmph
16:23:26 <ehird> @quoteadd <davidL> @. wiki run repeat 'a' <lambdabot> http://www.haskell.org/haskellwiki/_"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
16:23:26 <lambdabot> Unknown command, try @list
16:23:28 <dons> bit noisy ...
16:23:33 <dons> maybe take it to a privmsg
16:23:36 <ehird> yeah ok
16:23:38 <opqdonut> remember is the command
16:23:40 <sclv> ehird: the command is @remember
16:23:42 <ehird> thanks
16:23:42 <opqdonut> and thanks for the spam
16:24:28 <BMeph> Oh, how about that - it's a Mainland paperfrom the SIGPLAN last year:
16:24:50 <ehird> but yeah -- anyone re: my cabal thing?
16:24:56 <BMeph> Harvard link: http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/mainland07quasiquoting.pdf
16:24:57 <lambdabot> http://tinyurl.com/yo9sa3
16:25:50 <dons> very interesting email from a category theorist/maths guy on -cafe
16:25:57 <dons> for the maths/Hask category fans
16:26:00 <ehird> dons: i thought you said conspiracy theorist
16:26:01 <opqdonut> link?
16:26:02 <ehird> that would be cool
16:26:16 <ehird> HASKELL WAS AN INSIDE JOB DESIGNED TO OPRESS MIRANDA PROGRAMMERS WITH MONADS
16:26:31 <opqdonut> o_O
16:26:44 <ehird> hmm, i think IRCMonad might have to include generated code for each irc command defined, to be type-safe ;)
16:26:50 <Pseudonym> Conspiracy theory studies submorphisms, which are hidden relationships between objects.
16:26:57 <opqdonut> :)
16:27:07 <Pseudonym> cryptomorphisms
16:27:09 <Pseudonym> That's it.
16:27:15 <BMeph> ROFL! " I will not be the Erlang expert sought for web apps. Trading systems are my future. "
16:27:40 <Pseudonym> You can read my paper on bananas, lenses, cloaks and daggers.
16:27:43 <ehird> BMeph: Yep
16:27:44 <wagle_> what do you call "finding patterns in random data"
16:27:47 <wagle_> ?
16:27:56 <Tac-Tics> impossible. It's clearly not random then
16:28:04 <matthew-_> BMeph: is this Joel Raymont?
16:28:07 <ehird> wagle_: it has a pretentious name like fufufudoalcmopohagianda
16:28:24 <ehird> yes, matthew-_
16:28:29 <BMeph> Because, we all know how badly Erlang does at communication passing between multiple distributed sites... :p
16:28:31 <ehird> http://twitter.com/wagerlabs
16:28:31 <lambdabot> Title: Twitter / wagerlabs
16:28:41 <Saizan> wagle_: data mining?
16:28:49 <paczesiowa> jonaskoelker: statements = many statement :>
16:28:49 <matthew-_> ehird: gosh, odd that I can identify who it is just from 1 quote!
16:29:02 <wagle_> uhhh.. no..  plot dots on the screen randomly, and your eye will find patterns (clusters, etc)..  plot what looks like random to the eye, and it is not random
16:29:06 <BMeph> matthew-_: Yeah, the one and (Thank G*d!) only. :p
16:29:24 <jonaskoelker> paczesiowa: ah yeah :)
16:29:28 <matthew-_> BMeph: that's just an implementation detail though... sites shouldn't *really* be distributed ;)
16:29:39 <BMeph> ROFL!
16:29:45 <paczesiowa> jonaskoelker: and you shouldn't "abuse" lexeme, use it only on "basic" parsers, like char and symbol, every other whitespace should be consumed by subparser
16:30:07 <dons> http://twitter.com/donsbot  i got a twitter if anyone knows how to use this thing
16:30:07 <lambdabot> Title: Twitter / donsbot
16:30:08 <matthew-_> also, I've actually met Joe Armstrong and he too is rather nutty
16:30:14 <dons> matthew-_: oh really?
16:30:20 <dons> i found him fairly normal :)
16:30:33 <matthew-_> I found him more nutty than SPJ
16:30:33 <jonaskoelker> paczesiowa: not identifier or decimal?
16:30:44 * Nafai follows donsbot
16:30:47 <ehird> anyone re: my multiple .cabal files in the root?
16:31:48 <matthew-_> dons: other than academics, he's probably the nuttiest I've met
16:31:50 <Saizan> ehird: you'd have to release as two separated packages e.g. in hackage, but i don't see why not
16:31:53 <paczesiowa> jonaskoelker: if identifier and decimal come from Language module then they already skip trailing whitespace (but it's just a matter of style and efficiency, it's not the source of your problems)
16:32:00 <dons> jerzy's pretty wacky
16:32:15 <ehird> Saizan: hmm, i wouldn't like to do that. itd be a pain to filter out the two directories
16:32:17 <dons> there's lots of wacky people around here
16:32:32 <ehird> basically, i have ircmonad.cabal and mybot.cabal
16:32:37 <ehird> and src/IRCMonad/... and src/MyBot/...
16:32:39 <ehird> etc
16:32:44 <matthew-_> dons: you are in .us
16:32:50 <Saizan> ehird: if the set of files is disjoint cabal sdist should just work
16:32:52 <jonaskoelker> paczesiowa: got ya
16:32:56 <ehird> because IRCMonad is pretty much  going to be developed to suit the needs of the bot
16:33:21 <ehird> Saizan: mm, but then the only person with a dir structure like that is me :-)
16:33:22 <paczesiowa> jonaskoelker: and try first parseTest various statements, then carry on tu functions
16:33:27 <ehird> Also:
16:33:30 <ehird> One Setup.lhs
16:33:45 <dons> matthew-_: i am.
16:33:52 <dons> is that ok?
16:34:06 <paczesiowa> jonaskoelker: is it interpreter/compiler for uni classes? do you have bnf for it?
16:34:06 <Saizan> ehird: with Build-Type: Simple you don't need a Setup.lhs, assuming you don't do anything fancy in it
16:34:23 <matthew-_> well, I'm stereotypically suggesting that affects the degree of nuttiness
16:34:35 <BMeph> dons: But to admit, you are in a high-nut-content part of the country... ;)
16:34:49 <ehird> Saizan: well, it's convenient for my use ;)
16:34:50 <dons> BMeph: certainly :)
16:34:53 <dons> its cool
16:34:54 <ehird> It's just, otherwise I'm going to have:
16:35:09 <ehird> ~/Code/Something/ircmonad/{ircmonad.cabal,IRCMonad/...}
16:35:15 <ehird> and ~/Code/Something/mybot/{...}
16:35:19 <ehird> which seems unweildy
16:35:20 <Philippa> matthew-_: did you really find SPJ all that nutty? Enthusiastic, sure
16:35:35 <ehird> plus the lack of instantly being able to fill in 'something' suggests it's a bad idea to me :-)
16:35:36 <matthew-_> Philippa: not scary nutty, no
16:35:41 <BMeph> dons: In the interests of "full disclosure," my wife's from the same general area, so I know the wackiness first-hand. ;)
16:35:50 <dons> heh
16:35:52 <dons> i love it.
16:35:58 <dons> i think that means i'm wacky too. hmm.
16:36:04 <matthew-_> whereas Joe struck me as being so unaware of the rest of the world that it was to his and Erlang's detriment
16:36:07 <Saizan> ehird: maybe you should just have one cabal file then?
16:36:16 <davidL> Oregon is wacky?
16:36:24 <dylan> oh yeah
16:36:24 <jonaskoelker> paczesiowa: the language is used for a class, but writing a compiler isn't the assignment
16:36:35 <ehird> Saizan: they're distinctly seperate things
16:36:41 <jonaskoelker> paczesiowa: and I don't think I have a bnf for it, but it's basically C
16:36:54 <ehird> right now the best solution seems to be the ~/Code/Something one, but then again when I can't name something quickly it usually means it shouldn't exist
16:37:25 <matthew-_> dons: are you a wannabe wacky?
16:37:31 <matthew-_> ;)
16:37:42 <byorgey> matthew-_: yes.
16:38:06 * BMeph Googles for any connetion b/t "wagerlabs" and "occam"...
16:38:12 <byorgey> lol!
16:38:25 <byorgey> no one will ever believe how I actually meant that.
16:39:20 <byorgey> see, matthew-_ asked another question a long time ago about Joel Reymont, but I had forgotten to scroll my window down so I typed "yes", and then went "oops", and scrolled down only to find that matthew-_ had just asked a DIFFERENT question... =)
16:39:25 <ehird> though any name suggestions are welcoe ;)
16:39:48 <paczesiowa> jonaskoelker: next time use hpaste.org it knows haskell's syntax
16:39:51 <matthew-_> byorgey: yeah yeah, I don't believe you...
16:40:11 <jonaskoelker> paczesiowa: will do :)
16:40:12 <BMeph> davidL: THe whole "Cascadia" region - Washington, Oregon, N. California - is chock full of "wack". ;)
16:40:33 <matthew-_> s/wack/crack/
16:40:47 <davidL> is that just programmers or everyone?
16:41:20 <BMeph> davidL: Oh, no, non-programming Cascadians are whacked-out, too.
16:41:47 <BMeph> Er,... I mean "yes - everyone is". ;)
16:41:51 <davidL> heh
16:42:00 <jonaskoelker> paczesiowa: so, in my `ifthen' where I apply both `reserved "if"' and `expression', do I need to try only if, or both, or ...?
16:42:40 <BMeph> Of course I'm prejudiced - I find it exceedingly odd that in Oregon, you're not allowed to fuel up your own vehicle.
16:43:05 <ehird> Hrm.
16:43:43 <paczesiowa> jonaskoelker: I wouldn't try anything, I use try in e.g. factor = choice [...
16:44:25 <jonaskoelker> paczesiowa: as in factor = [try nullptr, try varname, try funcall, ...]?
16:44:56 <matthew-_> BMeph: I see. Apparently in some parts of caneda you can't carry your beer from one table to another
16:45:19 <paczesiowa> jonaskoelker: yes, because single parser shouldn't try anything (it's slower) but later when you have two parsers who accepts input with common prefixes then you have to try one of them
16:45:37 <wagle_> when i first drove out to oregon, i tried to fill up my truck..  the guy got pissed at me..  fortunately i was wandering around, outside the truck, and noticed when he didnt put the gascap back on
16:46:22 <matthew-_> O.o
16:46:27 <paczesiowa> jonaskoelker: like foo can be a variable or beginning of function call, you don't know until you read (or not) opening paren
16:47:15 <matthew-_> dons: so I get to meet Phil Wadler tomorrow. Is he more or less wacky?
16:47:19 <paczesiowa> jonaskoelker: so it's important to choose correct order for parsers inside choice
16:47:22 <dons> oh, super wacky
16:47:27 <matthew-_> oh super
16:47:38 <dons> he's captain wacky
16:47:45 <dons> or lambda man.
16:47:48 <dons> one of them
16:47:54 <jonaskoelker> paczesiowa: the order would be [funcall, varname], right?
16:48:00 <monochrom> Œªman
16:48:19 <jonaskoelker> paczesiowa: (all valid varname is a prefix of funcall)
16:48:53 <paczesiowa> jonaskoelker: if funcall doesn't try then you have to use [try funcall, varname], because if funcall fails it already ate "foo" so varname will fail too
16:49:28 <dons> it'd be cool if we could call twitter from lambdabot
16:49:37 <dons> like @remember
16:49:39 <ddarius> dons: Get some newbie on it.
16:50:49 <paczesiowa> jonaskoelker: you could also left-factorize that, and have single parser funcallOrVarname which would parse identifier, then depending on single char '(' return varname or parse rest of funcall
16:51:19 <BMeph> jonaskoelker: Just curious, but are you making an interpreter for Factor, the language, or is this more fun with algebra? ;)
16:52:22 <jonaskoelker> BMeph: don't know Factor by name
16:52:53 <jonaskoelker> BMeph: I know the language by the name Tip, it's for my static analysis course (http://www.brics.dk/~mis/static.html)
16:52:54 <lambdabot> Title: Static Analysis
16:52:56 <BMeph> Okay, never mind, then. :)
16:54:11 <BMeph> Well, never mind about the language; carry on with the analysis! :)
16:54:33 <jonaskoelker> hey cool, I parse all the test programs
16:54:35 <BMeph> Except... oh-noes! They stick lambdas in a JAR!!!
16:54:42 <jonaskoelker> now I can get started on the funny algorithms :)
16:55:09 <BMeph> All course material will be available on-line. The lectures are mainly based on the following: *Lecture Notes on Static Analysis (slides)  *TIP implementation ( JavaDoc). *The Lambda Calculus (lambda.jar).
16:55:15 <paczesiowa> jonaskoelker: what was the problem?
16:55:27 <jfoutz> has anyone run the HAppS Allin.hs example? if so, could you give me a hint as to what the urls passed in should look like?
16:55:28 <brian`> if I want to draw L-System, I need to store variable angle.. right? Is using state monad the only way to deal with it?
16:55:40 <brian`> or are there smart ways to do it without storing angle to avariable?
16:55:40 * BMeph starts working on "Free Lambda" picket signs...
16:55:44 <jonaskoelker> paczesiowa: well, mapping try over factor = choice [...] and similarly for Statement did the trick
16:56:20 <paczesiowa> jonaskoelker: that's ugly:P
16:56:20 <byorgey> brian`: you can also just pass the state around as a function parameter, which can sometimes make more sense.  it depends.
16:56:31 <monochrom> "jar -x lambda.jar" will free the lambda within.
16:56:33 <byorgey> brian`: there's nothing magical about the State monad, it just hides all the parameter-passing
16:56:47 <dons> monads are magical though
16:56:57 <Pseudonym> No, they're sufficiently advanced technology.
16:57:00 <Saizan> the object mapping part of an endofunctor is just an arrow, right?
16:57:01 <Pseudonym> But I understand the confusion.
16:57:30 <matthew-_> there is no confusion, just like there is no spoon
16:57:45 <paczesiowa> jonaskoelker: but if you need it as a tool and it's not a goal itself, than do whatever seems easiest
16:57:45 <matthew-_> on the grounds that I've finished the ice cream and thus have no need for a spoon
16:57:56 <Pseudonym> There is no ice cream.
16:57:58 <monochrom> fixed point theorems are magical too
16:58:03 <ehird> monads are warm and fuzzy
16:58:13 <matthew-_> ah yes, they're more magical than monads IMHO
16:58:14 * byorgey <3 monads
16:58:43 <monochrom> there is no state
16:58:58 <monochrom> recently I read that there is no time either.
16:59:11 <matthew-_> not after #haskell, anyway
16:59:18 <Botje> > let foo "#" = "# #"; foo " " = " " in iterate (concatMap foo) "#" !! 2
16:59:19 <vincenz> so you mean
16:59:19 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
16:59:21 <vincenz> data Timee;
16:59:32 <Botje> > let foo '#' = "# #"; foo ' ' = " " in iterate (concatMap foo) "#" !! 2
16:59:33 <lambdabot>  "# # # #"
17:00:00 <Botje> > let foo '#' = "# #"; foo ' ' = "   " in iterate (concatMap foo) "#" !! 9
17:00:02 <lambdabot>  "# #   # #         # #   # #                           # #   # #         # #...
17:00:14 <Botje> yay, one-dimensional fractal.
17:00:56 <ricky_clarkson> .. ..
17:01:08 <ehird> silly haskell function idea:
17:01:17 <_alf_> how cantor set of you
17:01:20 <ehird> compute some wolfram 1-dimensional cellular automata, but infinitely
17:01:27 <ehird> not just running one step
17:01:30 <ehird> but returning every single step
17:01:31 <jonaskoelker> paczesiowa: yeah... well, right about now, I'm more interested in traversing the tree, not building it fast
17:01:33 <ehird> :)
17:01:38 <jonaskoelker> paczesiowa: the inputs are always small anyways :)
17:01:46 <Botje> ehird: like iterate does?
17:01:47 <jonaskoelker> paczesiowa: "and n is usually small" :)
17:01:53 <ehird> Botje: yeah, but without just wrapping over it :(
17:01:57 <Pseudonym> > let foo '#' = "# #"; foo ' ' = " " in iterate (>>=foo) "#" !! 2
17:01:57 <lambdabot>  "# # # #"
17:01:59 <Botje> :)
17:02:01 <Pseudonym> Hmm.
17:02:09 <Pseudonym> Ooops, low oxygen alarm.
17:02:09 <Pseudonym> BBS
17:02:13 <Pseudonym> Yeah, seriously;
17:02:17 <Pseudonym> We have a low oxygen alarm.
17:02:39 <ehird> haskell needs to breathe a lot, it's just a poor little lambda :(
17:02:48 <ehird> it's huffing and puffing and blowing your types down
17:03:10 <dylan> low oxygen alarm!?
17:03:11 <byorgey> let foo '1' = "0"; foo '0' = "10" in iterate (>>=foo) '0' !! 20
17:03:20 <byorgey> > let foo '1' = "0"; foo '0' = "10" in iterate (>>=foo) '0' !! 20
17:03:21 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
17:03:33 <dylan> Pseudonym: low oxygen, really? Where do you live?
17:03:45 <byorgey> > let foo '1' = "0"; foo '0' = "10" in iterate (>>=foo) "0" !! 20
17:03:45 <lambdabot>  "010100101001001010010100100101001001010010100100101001010010010100100101001...
17:03:46 <jonaskoelker> paczesiowa: is there a nice way of decorating the tree?  I'm thinking adding type parameters to every node type will do the work, and will be reasonable, but it smells like there should be something slightly more elegant
17:04:00 <BMeph> Haskell: The Little Lambda that Could. Foreward by Simon L. Jones Peyton ;)
17:04:22 <_alf_> > let foo '1' = "0"; foo '0' = "10" in iterate (>>=foo) "1" !! 20
17:04:22 <lambdabot>  "100100101001001010010100100101001001010010100100101001010010010100100101001...
17:04:44 <Pseudonym> OK, false alarm
17:04:51 <EvilTerran> > iterate (concatMap ((:) <$> length <*> return.head) . group) [1]
17:04:51 <lambdabot>  [[1],[1,1],[2,1],[1,2,1,1],[1,1,1,2,2,1],[3,1,2,2,1,1],[1,3,1,1,2,2,2,1],[1,...
17:04:57 <eugman> Sorry for my continual barrage of questions, but Wouldn't state control be an issue if one made a text adventure in haskell?
17:04:58 <Pseudonym> dylan: The building I work in says "applied chemistry".
17:04:59 <_alf_> they only differ in two places
17:05:15 <byorgey> eugman: yes, probably.
17:05:17 <Pseudonym> We have a lot of large liquid nitrogen tanks around the place.
17:05:17 <Botje> EvilTerran: heh, nifty.
17:05:43 <Pseudonym> If you happen to be in a room next to one that's leaking a lot, the first you'll know about it is when you pass out.
17:05:46 <Botje> eugman: you could just pass it around, it's no big deal.
17:06:02 <byorgey> Pseudonym: yikes.
17:06:02 <Pseudonym> Occasionally, the low-oxygen sensors go off for no reason, though.
17:06:17 <ddarius> Saizan: No.  The object mapping is a (set) function (interpreting your question one way).
17:06:41 <paczesiowa> jonaskoelker: I would create another type for decorated trees, maybe it's a little verbose, but it makes things clear. if you add another parameter to e.g. statement than you are going to assign to it smth stupid during parsing. and I think that parsing and that static analysis magic should be two different and separeted things
17:06:45 * EvilTerran went cross-eyed when reading a sign near where he goes for lectures... it says "Faculty of Applied Science" or something, which I naturally mis-read as "... Aperture Science" :D
17:06:46 <Pseudonym> Hey, the cool part is, when people ask what I do for a living, I can truthfully say "nanotech".
17:06:53 <Pseudonym> It's worth it for the odd alarm to go off randomly.
17:07:05 <byorgey> oooooOOOOOooooh, nanotech!
17:07:07 <jonaskoelker> paczesiowa: well, I can always just add ()
17:07:19 <jonaskoelker> paczesiowa: seems like a fairly reasonable dud
17:07:25 <_alf_> Pseudonym: or chemistry as it was previously known
17:07:27 * EvilTerran crashes face-first into some unresolvable overlapping instances
17:07:28 <EvilTerran> ow
17:07:29 * byorgey channels little green three-eyed aliens from Toy Story
17:07:33 <Saizan> ddarius: can you explain?
17:07:42 <EvilTerran> byorgey, hah :D
17:07:52 * Pseudonym has been chosen!
17:07:55 <byorgey> use the wand of power!
17:08:04 <ddarius> Saizan: If I interpreted your question correctly, there's nothing to explain.  That's just what it is.
17:08:08 <Pseudonym> My monitor buddy is one of those.
17:08:09 <paczesiowa> jonaskoelker: s/things/phases. yes you can add () but it makes you code less modular, parser should parse not annotate tree structure.
17:08:17 * EvilTerran blinks
17:08:29 <Pseudonym> The marketers call them LGMs, but I call it a "zealot".
17:08:37 <Pseudonym> The movie uses the line "Get away from me, you zealots!"
17:08:38 <Saizan> ddarius: ah, because an arrow is something from an object to another, but the mapping of a functor goes from all objects to others, i see
17:08:44 <paczesiowa> jonaskoelker: if you decide you need two parameters later you'll have to change parser
17:08:48 <byorgey> Pseudonym: heh
17:09:29 <jonaskoelker> paczesiowa: two parameters?  Wouldn't I just map the tree into one with the annotation type being an n+1-tuple?
17:10:27 <paczesiowa> jonaskoelker: so you can "map" it in the first place from pure parse tree to whatever you want/need
17:11:01 <ddarius> Saizan: There is a notion of a "strong" functor, where the action of the functor is internal to the category.
17:12:23 <eugman> Out of curiousity, what kinds of programs do you guys use Haskell to make?
17:12:38 <Maddas> Pseudonym: Old hat! Genomics is the new nanotechnology.
17:12:52 <shag> eugman:  i am writing a distributed web search engine as part of my masters thesis
17:13:09 <ddarius> eugman: Whatever I feel like.
17:13:57 <monochrom> I wrote a factorer (gets prime factors).
17:14:26 <monochrom> In fact I'm now running it to factor 10100101001001010010100100101001001010010100100101001010010010100100101001
17:14:49 <davidL> how long has it been since you started?
17:15:04 <Maddas> I write programs that uses distributed web search to retrieve prime factors generated by other haskell programs.
17:15:15 <monochrom> Absolutely under 10 minutes.
17:15:27 <Maddas> (I wish ;-))
17:15:30 <Pseudonym> Crappy webcam shot of my zealot: .357243824834982482489
17:15:39 <Pseudonym> Err.
17:15:41 <Pseudonym> http://andrew.bromage.org/zealot.jpeg
17:15:57 <monochrom> I obtained that number from someone's command that resulted in <lambdabot>  "100100101001001010010100100101001001010010100100101001010010010100100101001...
17:16:17 <monochrom> I treated that as decimal and gave it to my factorer.
17:16:25 <Pseudonym> And?
17:16:37 <ddarius> Pseudonym: Wow, that is crappy.
17:16:57 <Pseudonym> The webcam in question is worth precisely what I paid for it.
17:17:23 <shag> nothing?
17:17:29 <Pseudonym> Precisely.
17:17:33 <monochrom> It is not done yet. It will take a long time. But so far it has got these prime factors: 41 593 28283 7875073 113684371. It is now working on the rest: 16406137294619367077026530223987034867629461006193, which is much much harder.
17:17:34 <shag> ;)
17:17:38 <ehird> Hmm, is it possible to make lambdabot generate the number 1101001000100001...?
17:17:39 <eugman> Heh, someon paid YOU to take it
17:17:45 <BMeph> I always think of StarCraft when I hear about "zealots." I makes US news programs all the more entertaining... >;)
17:17:48 <byorgey> monochrom: that was me, I'll be interested to see what the factors are =)
17:17:59 <BMeph> s/I/It/
17:18:01 <Maddas> BMeph: I was about to mention that this is not what I remembered zealots to look like ;-)
17:18:15 <BMeph> Maddas: "My Life for Aiur!" ;)
17:18:21 <dolio> > concatMap show $ iterate (*10) 1
17:18:21 <lambdabot>  "110100100010000100000100000010000000100000000100000000010000000000100000000...
17:18:22 * Maddas grins
17:18:23 <byorgey> Pseudonym: heh, awesome =)
17:18:27 <TomMD> > 1101001000100001
17:18:27 <lambdabot>  1101001000100001
17:18:29 <monochrom> The algorithms I have coded up are too slow for that remaining part. I give it a spin nonetheless.
17:18:39 <Maddas> Pseudonym: Is that a Futurama reference?
17:18:40 <davidL> > product [41,593,28283,7875073,113684371,721295018396817374378657,22745391103746124446436049]
17:18:41 <lambdabot>  10100101001001010010100100101001001010010100100101001010010010100100101001
17:18:54 <Pseudonym> Maddas: No.
17:19:01 <monochrom> I'm beaten.
17:19:19 <monochrom> > 721295018396817374378657*22745391103746124446436049
17:19:20 <lambdabot>  16406137294619367077026530223987034867629461006193
17:19:34 <dolio> Is davidL a savant?
17:19:43 <byorgey> hahaha
17:19:46 <ehird> dolio: no
17:19:50 <monochrom> Anyway, the part about 41,593,28283,7875073,113684371 is instantaneous.
17:19:50 <ehird> that's a string, sorry
17:20:24 <monochrom> The rest, I have only coded up "elliptic curve". It's still too slow. Need quadratic sieve at least.
17:20:34 <dolio> > read . concatMap show $ iterate (*10) 1 :: Integer
17:20:37 <lambdabot>  Terminated
17:21:02 <monochrom> > length "721295018396817374378657"
17:21:03 <lambdabot>  24
17:22:08 <byorgey> davidL: OOC, what did you use to do that factoring?
17:22:23 <monochrom> I want to know the secret too. :)
17:22:31 <davidL> mathematica :P
17:22:43 <byorgey> that's what I thought =)
17:22:46 <ehird> so, yes! who can generate it as an actual integer!
17:22:56 <_alf_> >10100101001001010010100100101001001010010100100101001010010010100100101001 / 41
17:23:07 <monochrom> One day I will implement "general number field sieve" and beat even mathematica.
17:23:12 <Pseudonym> So, monochrom, what algorithm are you using?
17:23:25 <ehird> Psht.
17:23:28 <ehird> You all suck. ;P
17:23:40 <monochrom> trial division, then Pollard's rho, then Pollard's p-1, then elliptic curve.
17:23:51 * Pseudonym nods
17:23:56 <monochrom> Later I'll add quadratic sieve.
17:24:02 <ddarius> monochrom: Then you can sell it to Wolfram Research and say you rewrote Mathematica in an afternoon while mountain climbing and watching two young children.
17:24:07 <Pseudonym> Quadratic sieve is fairly easy, I would have thought.
17:24:15 <Pseudonym> In principle, anyway.
17:24:28 <dolio> ehird: You're going to have trouble getting it to display an integer with an infinite number of digits. :)
17:24:37 <monochrom> All advanced algorithms are highly parallelizable. I plan to use Haskell's par for that. Then mathematica will look slow, if you have 4 cores or something. :)
17:24:44 <ehird> dolio: so pass it into show
17:24:44 <ehird> ;)
17:25:02 <Pseudonym> So just curious.
17:25:04 <ehird> alternatively, just prove to me that some code generates it
17:25:11 <Pseudonym> You say it's instantaneous up to 113684371.
17:25:18 <Pseudonym> That's the trial division bit?
17:25:24 <monochrom> Somehow I have an irrational fear about the gaussian elimination stage of quadratic sieve.
17:25:40 <Pseudonym> Pfft.  It's only QF(2).
17:26:12 <Pseudonym> Perhaps your fear is based entirely in it being not parallelisable easily.
17:26:21 <monochrom> trial division by all primes below 500,000, then rho and p-1. They got up to 113684371. (Or rather, I preset parameters to allow them to go up to that much.)
17:26:26 <dolio> ehird: Well, that's tough, too, because you need infinite memory to hold the integer.
17:26:35 <Pseudonym> Which parameters did you use for rho?
17:26:50 <ehird> dolio: Didn't say a non-turing-machine had to be able to run it.
17:26:53 <ehird> :)
17:27:03 * Pseudonym is curious to try hot his impl
17:27:08 <Pseudonym> s/hot/out/
17:27:47 <dolio> ehird: Unless I'm allowed to do 'data MyInteger = EhirdNumber | I Integer ; instance Show MyInteger where show EhirdNumber = concatMap show $ iterate (*10) 1 ; show I i = show i"
17:27:50 <monochrom> in "x^2+c" I try c in {1,2,3,5,7}U{five randomly chosen small primes}. I run each for 500000 iterations.
17:28:30 <ehird> naw, i just want a haskell function that given infinite time and memory produces 1101001000100001... :)
17:28:35 <Pseudonym> Thanks.
17:28:40 * Pseudonym checks it out
17:28:43 <davidL> monochrom: are you trying to get EFF's $100,000 reward for finding the first 10 million digit prime?
17:29:07 <monochrom> No, that's beyond my reach. See, I even have problem factoring a 50-digit number!
17:29:30 <dons> http://www.xent.com/pipermail/fork/Week-of-Mon-20080128/048241.html poor Arc.
17:30:30 <davidL> I bet if folding@home stopped folding for a few minutes and looked for primes instead, they could get it
17:30:40 <eugman> ehird, turn that into a put a 0. infront of that and I think that is a transcendtial number
17:30:46 <ehird> davidL: in between 2 clock cycles of the server ;)
17:30:54 <ehird> eugman: correct, iirc
17:30:56 <ddarius> davidL: Luckily they have better things to do.
17:32:21 <byorgey> dons: what's that?  it isn't loading for me.
17:33:18 <dons> oh, just someone yawning about yet another lisp variant
17:34:20 <wagle_> yeah, i had mt ultimate variant, but i dont go around telling anyone about it...  uh...  oops
17:34:29 <wagle_> s/mt/my/
17:35:32 <ddarius> dons: The issue was that Arc was "sold" as something much bigger than it is, then Paul Graham took several years to apparently write a weeks worth of code.
17:36:16 <ricky_clarkson> A complete non-issue.. it was pretty predictable as to what it would be.
17:36:28 <vincenz> He's a serious prick
17:36:31 <dons> ddarius: i know.
17:36:33 <dons> its insane
17:36:37 <vincenz> Sending emails around to lots of people to ask for advice
17:36:47 <vincenz> (the suggestions list on the arch home page was cause he emailed people)
17:36:49 <vincenz> and then delivering nothing
17:36:59 <jeffz> isn't it version 0 too? why is everyone attacking something which isn't anything
17:37:15 <soduko> whats wrong with ? (\l t-> (show l )++ (show t)) (8,'a')  if i want to see 8a ?
17:37:28 <brian`> :t show
17:37:29 <lambdabot> forall a. (Show a) => a -> String
17:37:31 <ricky_clarkson> Because there's something to attack now.
17:37:32 <vincenz> jeffz: cause of all the hype and bs
17:37:42 <EvilTerran> > show 'a'
17:37:42 <lambdabot>  "'a'"
17:37:50 <byorgey> soduko: just do 8 'a'  insteand of (8,'a')
17:37:54 <brian`> >(show 8) ++ (show 'a')
17:38:01 <dons> yet another 1 week scheme isn't a 100 year language, basically. the mismatch between 6 years of words, and deeds. and hah, lisp is silly
17:38:07 <soduko> byorgey: but i need to map it across a list of tuples
17:38:10 <byorgey> > (\l t -> (show l)++(show t)) 8 'a'
17:38:10 <lambdabot>  "8'a'"
17:38:21 <EvilTerran> > (\(l,t) -> show l ++ show t) (8,'a')
17:38:22 <lambdabot>  "8'a'"
17:38:22 <byorgey> soduko: ok, then you need to pattern match on a tuple.
17:38:24 <vincenz> dons: heh, I'm not as antilisp as you but ok :)
17:38:28 <vincenz> dons: I actually like scheme ;)
17:38:29 <byorgey> soduko: like EvilTerran showed above.
17:38:32 <soduko> this is the RLE example on dons's blog
17:38:35 <EvilTerran> soduko, if you want to pass it a tuple, have it pattern-match on a tuple :)
17:38:46 <soduko> oh yeah i get it.  input is a tuple
17:38:50 <soduko> thanks
17:38:51 <EvilTerran> :)
17:39:01 <dons> vincenz: its a useful teaching language. it'd be better if it was pure and had types.
17:39:09 <dons> then it would be a perfect teaching language
17:39:15 <vincenz> dons: different pareto-point
17:39:17 <jeffz> dons, what do you think of typed scheme?
17:39:20 <vincenz> and plt has types
17:39:23 <vincenz> now
17:39:24 <dons> a good start :)
17:39:34 <EvilTerran> dons, sounds like liskell
17:39:43 * vincenz wrinkles his nose
17:39:56 <soduko> how to lose the ' ?
17:39:58 <ddarius> ricky_clarkson: Predictable to some, most perhaps, but there was a significant subset that wanted to believe.
17:39:58 <ricky_clarkson> I kinda like how SICP isn't concerned with types.
17:40:20 <dons> ricky_clarkson: that made sense in the early 80s, but types are kinda important now
17:40:21 <soduko> show 'a' Gives "'a'"
17:40:22 <EvilTerran> soduko, with difficulty; the show function creates a snippet of haskell code
17:40:31 * ddarius wouldn't recommend a pure language as a teaching language.
17:40:34 <EvilTerran> that would evaluate to the value you started with
17:40:54 <byorgey> > putChar 'a'
17:40:54 <lambdabot>  <IO ()>
17:41:00 <EvilTerran> soduko, do you know that the second element of the pair will always be a Char?
17:41:36 <ricky_clarkson> dons: There's some value in getting stuff wrong at runtime, I think people can learn stuff faster that way than through compile errors.
17:41:42 <soduko> nope, actualy for it to be polymorhic  it can be anything.
17:41:50 <vincenz> ricky_clarkson: right, cause they come earlier?
17:41:52 <dons> ricky_clarkson: they don't learn that they just made an elementary type error
17:41:53 <hpaste>  kmcallister pasted "yi build error" at http://hpaste.org/5356
17:41:57 <dons> its invaluable to learn to think in types
17:41:58 <ricky_clarkson> But I agree that types are important; I just don't think they need to be first.
17:41:59 <EvilTerran> soduko, well, in that case you're going to need your own typeclass, i think
17:42:09 <EvilTerran> soduko, as Show doesn't do what you want
17:42:24 <EvilTerran> perhaps Stringy a where stringify :: a -> String
17:42:25 <dons> and its only with decent understanding of types do you see how to rule out large classes of errors from your code
17:42:25 <vincenz> dons: be nice to have a slimmed down 'scheme' (in size) like version of haskell
17:42:37 <EvilTerran> with stringify having the behaviour that you want
17:42:39 <kmcallister> does anyone know how to resolve the above error when building yi?
17:42:42 <idnar> ricky_clarkson: I think people are more used to getting stuff wrong at runtime; I don't think that necessarily means it's easier to learn that way if you're starting from scratch
17:42:42 <dons> like with purity -- until its forced on you, you don't even think about the concept of 'effects'
17:42:53 * vincenz effects dons
17:43:00 <dons> vincenz: yeah, i used a MiniHS for the uni course i helped run
17:43:02 <soduko> EvilTerran: thanks. ill skip that part for now.  and try some IO stuff :)
17:43:05 <dons> like MinML at cmu
17:43:07 <vincenz> dons: where do I find that?
17:43:11 <ricky_clarkson> idnar: Perhaps that depends largely on the quality of learning materials.
17:43:12 <dons> i wrote it for the course
17:43:14 <vincenz> ah
17:43:21 <vincenz> dons: wht did it contain?
17:43:21 <byorgey> kmcallister: those versions of regex-* are too new
17:43:23 <EvilTerran> okay :)
17:43:26 <idnar> ricky_clarkson: it also depends on the quality of the compiler errors, of course
17:43:38 <soduko> it sucks that i get only a few minutes a week , that too not continuous to practise programs in Haskell :(
17:43:45 <kmcallister> byorgey, they satisfy the deps listed for yi... which ones do i want?
17:43:45 * EvilTerran pokes his large and elaborate class heirarchy
17:43:56 <byorgey> kmcallister: they do?
17:43:59 <byorgey>  build-depends: regex-base>=0.72 && <0.73
17:43:59 <ricky_clarkson> idnar: It seems impossible to make them always easy to understand.
17:44:04 <soduko> On the brighter side, i read some code every day!
17:44:23 <dons> ricky_clarkson: i think that's a furphey. runtime errors are even harder
17:44:25 <ddarius> vincenz: There is also Helium (albeit probably not as slimmed down as you intend)
17:44:28 <dons> that's called 'debugging'
17:44:41 <dons> i'll take some kind of reasonable type error over random context-dependant failures
17:44:42 <vincenz> ddarius: something bite-sized would be nice
17:44:54 <vincenz> ddarius: so students get a sense of accomplishment and don't feel like they're just dealing with a small patch
17:45:01 <byorgey> kmcallister: I'm looking in yi.cabal
17:45:07 <kmcallister> byorgey, you're right
17:45:07 <ricky_clarkson> dons: I agree, but runtime errors are your fault, you can step through the code to see the problem.
17:45:13 <soduko> "random context-dependant failures"  STL erorrs come to mind
17:45:15 <ddarius> vincenz: Are we talking about implementing a language?
17:45:17 <vincenz> ricky_clarkson: if you know what to look for
17:45:19 <kmcallister> but in that case what is it trying to do when i type "cabal install" in the yi dir
17:45:23 <idnar> ricky_clarkson: the same is true of runtime errors
17:45:27 <ricky_clarkson> dons: Type errors depend on you understanding the type system well enough.
17:45:30 <vincenz> ddarius: no, just learning, but implementing would be neat ;:)
17:45:35 <kmcallister> also how do i install older versions of packages?
17:45:35 <ricky_clarkson> idnar: I was talking about those.
17:45:41 <vincenz> dons: did minihs have kinds?
17:45:45 <vincenz> dons: did minihs have TCs?
17:45:49 <dons> ricky_clarkson: right. which means teaching types. runtime errors require an understanding of runtime representations and the runtime system.
17:45:50 <Eelis> is there a way to tell (in code) the GHC RTS to garbage collect?
17:45:52 <ddarius> vincenz: Why would you "feel like you are dealing with a small patch"?
17:45:52 <dons> vincenz: yeah
17:45:55 <idnar> ricky_clarkson: sorry, I was responding to your comment about making them easy to understand
17:45:56 <soduko> ricky_clarkson: i never found it useful to depend on the compiler to get the programs right.  the complier's job is to translate into machien code.
17:46:01 <dons> TCs and only simple kind checking
17:46:02 <soduko> any error reporting is a bonus
17:46:03 <byorgey> kmcallister: good question.  hm, when you do cabal install it should say what versions of things it is choosing... what does it say?
17:46:11 <vincenz> dons: does it still exist?
17:46:16 <kmcallister> nothing, it seems to think the deps are already installed
17:46:22 <ricky_clarkson> soduko: It is useful to do that, I'm questioning whether it is useful as a first introduction to programming.
17:46:35 <dons> the students implemented an interpreter, then the static semantics
17:46:37 <ricky_clarkson> I'm open-minded on this, but opinionated.
17:46:43 <vincenz> dons: including the type-checker?
17:46:48 <dons> they wrote the type checker
17:46:49 <kmcallister> so maybe it's grabbing the yi off of hackage
17:46:50 <byorgey> kmcallister: you can give a particular version to cabal install: just say cabal install regex-base-0.72.0.1
17:46:52 <vincenz> dons: with kinds ?
17:46:55 <vincenz> dons: and TCs?
17:46:57 * vincenz whistles
17:47:02 <dons> TCs were an extension
17:47:04 <dons> bonus points.
17:47:04 <soduko> ricky_clarkson: i firmly believe students should learn without recourse to error info from teh compiler
17:47:09 <kmcallister> byorgey, gives "All requested packages already installed. Nothing to do."
17:47:10 <dons> but we're kinda serious at UNSW
17:47:12 <kmcallister> so i think i have both versions?
17:47:24 <byorgey> kmcallister: what does ghc-pkg list show?
17:47:27 <kmcallister> when i do "cabal info regex-base" it lists 0.93.1
17:47:27 <ddarius> soduko: Should they get error info from the run-time system?
17:47:28 <dons> we just give them the type system rules too
17:47:29 <idnar> ricky_clarkson: obviously you don't want to be staring at output like this: http://rafb.net/p/usiB8u64.html
17:47:29 <lambdabot> Title: Nopaste - No description
17:47:30 <Cin> how's that arc implementation?
17:47:31 <dons> as the assignment spec.
17:47:34 <dons> just the symbols :)
17:47:39 <ricky_clarkson> idnar: Or this:
17:47:46 <ricky_clarkson> > \f x -> f f x
17:47:47 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
17:47:47 <lambdabot>     ...
17:47:51 <kmcallister> byorgey, it shows both 0.9x and 0.7x versions of all 3 regex packages
17:47:58 <byorgey> kmcallister: oh, those should be OK then.
17:48:07 <dons> vincenz: general rule of thumb: do the hardest courses possible
17:48:10 <byorgey> kmcallister: did you just try to do 'cabal install yi'?
17:48:11 <idnar> ricky_clarkson: that's at least in the realms of comprehensibility
17:48:21 <kmcallister> byorgey, i want to install yi from darcs rather than from hackage
17:48:22 <soduko> ddarius: yes. that will teach how to think better before coding.  when i started learning fortran, i got only 30 minutes a week for all my programs, and if there was an error, tough luck. That taught me discipline.
17:48:25 <dons> ?users
17:48:25 <lambdabot> Maximum users seen in #haskell: 463, currently: 425 (91.8%), active: 23 (5.4%)
17:48:27 <kmcallister> can i do that with cabal install?
17:48:30 <byorgey> kmcallister: right, yes, that's a good idea
17:48:40 <byorgey> kmcallister: I doubt it
17:48:46 <idnar> ricky_clarkson: (but you can construct scenarios that are just as bad as the C++ templates one)
17:48:52 <ricky_clarkson> The difference is that runtime errors can be expressed in terms of your code, the state it has, etc., whereas type errors often require learning further terms.
17:48:52 <vincenz> dons: oh, I know, though we got less choice
17:48:53 <wagle_> ?bots
17:48:53 <lambdabot> :)
17:49:03 <ddarius> soduko: Why should they get error information from the run-time system and not the compiler?  Why not use C or assembly?  (In fact, I heartily recommend teaching assembly.)
17:49:07 <idnar> ricky_clarkson: the meaning of your own code is dependent on the language, though
17:49:08 <vincenz> dons: but analogy design, or transistor physics, or electro-magnetic waves aren't easy either :)
17:49:09 <wagle_> its a sekrit plot!
17:49:14 <ricky_clarkson> idnar: Yes.
17:49:26 <idnar> ricky_clarkson: so it seems to me like it's all the same thing
17:49:47 <ricky_clarkson> Ok, you've convinced me that it's subjective, not technical.
17:49:57 <soduko> when learning to program, its a new paradigm.. So the best thing one can do to improve their skill is to think.  and not depend on the compiler to tell them what is wrong.
17:50:03 <kmcallister> byorgey, is it possible it's using the wrong regex-* versions, even though both are installed? can i remove or temporarily mask out some of them?
17:50:09 <ricky_clarkson> When I started programming at age 5, SYNTAX ERROR was ok.
17:50:15 <monochrom> I see clearly that "only 30 minutes a week" is the key. "has error checking / no error checking / compile time /run time" is not.
17:50:25 <byorgey> kmcallister: I wouldn't use cabal install, I think the yi build process uses make
17:50:26 <ricky_clarkson> Occurs check: Cannot construct the infinite type.. would have sent me back to my TV.
17:50:31 <ddarius> soduko: And I'm saying, taking that to an extreme suggests not letting the run-time tell them their mistakes either.
17:50:46 <byorgey> kmcallister: try doing a 'make all' in the yi directory.
17:51:04 <kmcallister> "config.mk: No such file or directory"
17:51:07 <soduko> ddarius: thats not possible,  the purpose of running the program is to see the output. and then it is obvious if it ran fine or not.
17:51:16 <idnar> soduko: the compiler's job is to translate valid source code into machine code (or some other executable form)
17:51:21 <ddarius> soduko: What happens when I write (1 3) in Scheme?
17:51:26 <monochrom> Todays kids write sloppy programs because they're allowed 26 hours a day to access computers. They tend to take the unintelligent design approach.
17:51:38 <LoganCapaldo> soduko: it's not obvious
17:51:51 <byorgey> kmcallister: oh, that's right, you have to start by copying config.sample to config.mk, and edit it to put in the right directories etc.
17:51:53 <idnar> soduko: the most logical way for the compiler to handle invalid code is to give up and report an error
17:51:54 <soduko> is it not obvious if your program did what you thought it had to do?
17:52:02 <LoganCapaldo> unless it's hello world or some other equally trivial thing where you already know the answer
17:52:03 <jfoutz> monochrom: and they should get off my lawn.
17:52:13 <kmcallister> byorgey, interesting.  so cabal is not the preferred way to build yi?
17:52:21 <monochrom> Restrict them to 30 minutes per week of computer access, and they will develop intelligent design, too, python or fortran or haskell, static or dynamic typing, s-expression or infix notation, IDE or text terminal.
17:52:22 <soduko> idnar: yes.  but that only works as crutches to a beginner
17:52:26 <byorgey> kmcallister: apparently not.
17:52:28 <ddarius> jfoutz: Shotgun shells and a little elbow grease always got them off my lawn.
17:52:31 <idnar> soduko: "works"
17:52:31 <ricky_clarkson> soduko: Testing only shows that your code worked for the cases you tried.
17:52:47 <ricky_clarkson> soduko: It doesn't show that your code will work for the next case.
17:52:52 <idnar> soduko: I don't see how having the compiler silently do some random thing instead of erroring out would be any more useful
17:53:01 <byorgey> kmcallister: someone posted a good guide to getting started with yi (including all this stuff, which is how I know) just a month or so ago
17:53:13 <byorgey> kmcallister: I'll see if I can find it, I don't quite remember where/how I found it
17:53:14 <soduko> ricky_clarkson: exaclty!! so you have to make sure before you submit the job that it is going ot handle all data.
17:53:18 * EvilTerran wishes "data Foo a => Bar a = ..." did what he'd expect
17:53:41 <byorgey> kmcallister: heh, that was easy: http://www.nobugs.org/developer/yi/
17:53:41 <lambdabot> Title: Getting started with Yi, the haskell editor
17:53:43 <ricky_clarkson> soduko: It would be nice if the language helped you to do that.
17:53:58 <soduko> and for a beginner, getting into a habit of depending on the compiler to help them identify mistakes is counter productive ot gaining mastery over the languge and programming in general
17:53:59 <kmcallister> byorgey, i was working off of this doc
17:54:22 <ricky_clarkson> soduko: I'll agree with that bit.
17:54:29 <idnar> soduko: it's not about depending on the compiler
17:54:34 <soduko> which is why i keep coming back to haskell. you can "prove"  that your code will do what it is intended to do
17:54:37 <byorgey> kmcallister: oh, you were? well, that's where I learned to use 'make' instead of cabal
17:54:47 <idnar> soduko: I don't "depend" on my editor to help me write code
17:54:55 <monochrom> getting into the habit of depending on execution and debuggers to find mistakes is a mistake, too.
17:54:56 <byorgey> kmcallister: guess you should read more carefully =)
17:54:57 <kmcallister> byorgey, i missed that part, but anyway it looks like "make all" just runs the cabal setup
17:54:58 <ddarius> ricky_clarkson: I don't.  Learning how to get the compiler to help identify your mistakes is one of the crucial steps of mastering Haskell programming.
17:55:02 <kmcallister> i get the same error
17:55:22 <ddarius> (or "typeful" programming in general and other things too)
17:55:26 <idnar> soduko: but it sure is useful when I can use my editor to write code more easily
17:55:28 <soduko> no kidding, i hate debuggers!! in fact when i used to teach, i actively discouraged them from using one.
17:55:44 <brad_larsen> hello haskellers.  perhaps someone can help me with performance tuning for a program I'm writing?
17:56:05 <jfoutz> have you tried C?
17:56:08 * jfoutz ducks
17:56:10 <brad_larsen> I'm using Data.Array.IArray to represent part of the world in a search problem
17:56:13 <brad_larsen> heh
17:56:19 <monochrom> Summary. The habit of depending on compiler, executor, debugger, experimentation, ... to find programming mistakes is a mistake.
17:56:21 * Botje quacks
17:56:21 <soduko> idnar, that is a specious argument.  an editor's job is to help you write code. a compiler's job is to interface to the machine.  depending on non primary jobs is not good for beginners.
17:56:24 <LoganCapaldo> i must be super lazy or super dumb. I'll take any tool I can get that helps me produce, better, correct programs
17:56:39 <ddarius> monochrom: Instead we should rely on our infallible human reasoning skills.
17:56:40 <soduko> it is useful once the student knows what they are doing.
17:56:41 <monochrom> The vision of Dijkstra is right.
17:56:41 <byorgey> kmcallister: hm... let me go try to compile it myself
17:56:46 <idnar> soduko: a compiler's job is to implement the language
17:56:54 <LoganCapaldo> including, editors, debuggers, compilers and runtime sytems
17:56:58 <byorgey> kmcallister: I haven't actually pulled any new patches in a few days, maybe it's broken
17:57:06 <kmcallister> byorgey, thanks
17:57:14 <monochrom> In Dijkstra's first-year programming class, you never touch a computer.
17:57:29 <kmcallister> i have to go now but you can leave a message with \bot if you figure it out
17:57:32 <wagle_> the programming system's job is to help my little brain keep track of things
17:57:37 <EvilTerran> hm... under a GADT, if you had "data Bar a = Bar :: Foo a => a -> Bar a", it's impossible to create a non-bottom value of (Bar a) for non-Foo a, right?
17:57:47 <idnar> soduko: if a particular bit of code is an invalid use of the language, it is the compiler's job to report the error
17:57:50 <soduko> ddarius: "infallible human reasoning skills."  was that sarcastic or serious??
17:58:08 <jfoutz> brad_larsen: is the array working? what part is slow?
17:58:19 <soduko> yes and it is to the student's job to use that info to gain confidence on what they are giving to the machine
17:58:20 <idnar> soduko: the better the error reporting from the compiler is, the easier it is to fix the error, thus it is useful for the compiler to have good error reporting
17:58:50 <ddarius> soduko: Are your reasoning skills infallible?
17:58:54 <soduko> idnar: i dont disagree with that at all. just that that useful feature is actually an impediment to learning for beginners.
17:59:22 <wagle_> i think the student needs ALL those skills
17:59:36 <soduko> ddarius: :) i cant prove it either way.  becuase potentially we have a our life time to reason something out. by which time it is meaning less
17:59:52 <ddarius> soduko: You've never made a mistake?
17:59:54 <idnar> soduko: I don't see how having the compiler output "HAHA your code is invalid and I'm not going to tell you why" is helpful to beginners learning
18:00:06 <brad_larsen> jfoutz: it's a 2-dimensional array that stores grid cells.  an array (==) function gets called in the main loop... seems to be comparing each element
18:00:09 <jeffz> it really comes down to the type of person, some people will flail about with a debugger instead of reasoning about how to write a correct program, others will use a debugger after thinking, instead of before.
18:00:16 <wagle_> i sometimes find that the compiler isnt doing what i think its doing..
18:00:30 <soduko> as a kid, did you ever learn anything with an adult constantly interfering and correcting every single mistake you made?
18:00:40 <idnar> soduko: it's like saying that using a calculator is an impediment to learning how to do arithmetic
18:00:56 <cjb> idnar: it is.
18:01:05 <wagle_> you have to be able to check your model of what the computer is doing with your program..  but you also have to design good programs to start with
18:01:16 <brad_larsen> jfoutz: i was expecting the (==) function to be constant-time almost always
18:01:25 <idnar> cjb: that's certainly not my personal experience
18:01:28 <soduko> idnar: it sure is an impediment to doing math on paper! or in your head. which is where things should be right for a program
18:01:34 <jfoutz> brad_larsen: i haven't used arrays extensively, i would hazard a guess that lazyness prevented the array from even being built... the == is the first use, making things slow. but that's just a guess.
18:01:37 <ddarius> soduko: I was never taught anything that way.  That said, I also was never taught anything without something there to point out when I made a mistake as well.
18:01:39 <brad_larsen> jfoutz: because I am very rarely updating elements
18:01:48 <ricky_clarkson> ddarius: Yes, using the compiler is good for mastering Haskell, of course, but for beginning programming in general, I think not being able to see things go wrong at runtime errors is a bad thing.
18:01:49 <cjb> idnar: find a high school student, ask them to do non-trivial arithmetic in their head.  :)
18:01:53 <ricky_clarkson> s/errors //
18:02:05 <ddarius> ricky_clarkson: Things still go wrong at runtime with Haskell.
18:02:07 <soduko> ddarius:  ofcourse i have made several mistakes in life so far.
18:02:15 <idnar> cjb: I don't believe that has anything to do with the use or non-use of calculators
18:03:08 <LoganCapaldo> who cares if I can do arithmetic in my head or not? it lets me concern myself with the things the calculator can't do
18:03:09 <brad_larsen> jfoutz:  this is my first time with haskell arrays.
18:03:19 <jfoutz> brad_larsen: or do you mean you're comparing two different arrays?
18:03:27 <soduko> ddarius: isnt the dscussion about how much info about your mistake is given back to you? i say less. some seem to say more.  remember ths for a beginner not an experienced programmer
18:03:28 <ricky_clarkson> Someone asked yesterday how long 500 minutes is.. I said 8 hours 20 minutes immediately, and someone looked up from their calculator 20 seconds later and said "no, 8.33 hours"
18:03:31 <brad_larsen> jfoutz:  i'm comparing two arrays
18:04:09 <idnar> soduko: coming back to what you said just now, I find it a lot easier to learn something if I have an expert hovering over my shoulder, pointing out where I'm potentially making mistakes
18:04:12 <ray> someone's calculator only gives 2 decimal places?
18:04:13 <jfoutz> brad_larsen: i think == by default is deep. it doesn't memoize
18:04:24 <brad_larsen> jfoutz:  my program implements a bunch of graph search algorithms.  i do duplicate detection to prevent cycles.
18:04:26 <ricky_clarkson> ray: I think it was on a mobile phone.  Retardation by default.
18:04:50 <brad_larsen> jfoutz:  any idea if there is some way to tell ghc to memoize my arrays?
18:04:52 <byorgey> @tell kmcallister well, it builds OK for me.  I'm not sure why you're seeing that error, unfortunately.
18:04:52 <lambdabot> Consider it noted.
18:05:00 <ray> oh, a mobile phone calculator would be one where you type 500 lol 60
18:05:05 <jfoutz> brad_larsen: one way out is to make a datatype with an id and your array, implement Eq such that you just compare ids
18:05:40 <soduko> that works for things like learning an API or a new framework  etc.. where you know something and can gain from others' experience.
18:06:02 <brad_larsen> jfoutz:  i was thinking of something like that, but i'm hoping there's a simpler way, strictness annotation or something
18:06:07 <soduko> eventually every one has to get help to improve.. not all knowledge can be self discovered!!
18:06:18 <idnar> I find it highly irritating when I have to reinvent the wheel all by myself because none of the previous wheel inventors want to tell me how the heck it works ;P
18:06:20 <wagle_> in my stats class, the prof would write columns of numbers on the board to ask things about..  then add them up on his calculator to compute various things..  i added them in my head with 100% accuracy 2-4 times faster than he with his calculator, and he got the right answer only about a third of the time..  he seemed very troubled, and insisted on adding them himself before going to me for the right answer
18:06:36 <jfoutz> brad_larsen: Stuff = Stuff Int Array; instance Eq Stuff where (Stuff id1 _) == (Stuff id2) = id1 == id2 that's about the best i know how to do...
18:06:41 <ricky_clarkson> > let lol x y = x/y in 500 `lol` 60
18:06:42 <lambdabot>  8.333333333333334
18:06:51 <idnar> sure, it's still useful to understand how they invented the wheel, and in time you might decide to invent a better wheel on your own
18:07:32 <wagle_> the robotics guys have some pretty odd wheels
18:07:35 <idnar> but it's stupid to force someone to reinvent the wheel independently before allowing them to, say, design a sports car
18:07:36 <brad_larsen> jfoutz:  yeah, then it just gets a bit tricky to assign ids correctly.  i'll consider it.
18:07:47 <basti_> > cyle "lol"
18:07:48 <lambdabot>   Not in scope: `cyle'
18:07:52 <basti_> argh
18:07:55 <basti_> > cycle "lol"
18:07:56 <lambdabot>  "lollollollollollollollollollollollollollollollollollollollollollollollollol...
18:08:00 <dolio> > let lol = divMod in 500 `lol` 60 -- should have used this
18:08:01 <lambdabot>  (8,20)
18:08:13 <soduko> it just struck me.  i keep popping in here and ask really simple questions, like the tuple matching earlier..  but most of the time, i feel just a wee bit guilty after asking for help like that. those are things one could potentially have figured out by thinking straight in the first place
18:08:52 <idnar> soduko: that's true of everything, just in different degrees
18:09:18 <idnar> soduko: ultimately, there are very few things that someone else has figured out, that you yourself couldn't figure out given enough time
18:09:23 <ricky_clarkson> soduko: Don't worry too much about that.
18:10:40 <ricky_clarkson> #haskell doesn't seem to get annoyed at newbie questions, which imo makes it very pleasant.
18:10:45 <soduko> but on several ocassions , resisting the urge to ask and try has helped.  especially with the IO monad
18:11:01 <idnar> ricky_clarkson: well, there are two categories of newbie question
18:11:04 <soduko> yes thats true.
18:11:26 <ricky_clarkson> idnar: Why doesn't Haskell use duck typing like all good languages?
18:11:28 <ricky_clarkson> :)
18:11:43 <idnar> ricky_clarkson: the "I'm new to this, please help me understand what the heck is going on" category, and the "I don't know how to do this, please do it for me so I can hand in my homework / finish my project at work / whatever" category
18:11:45 <dolio> Like OCaml?
18:11:52 <brad_larsen> can anyone tell me about strict arrays in haskell (specifically ghc)?
18:11:56 <idnar> ricky_clarkson: #haskell doesn't seem to get much of the latter
18:12:13 <ricky_clarkson> #scala gets a few of those, but it asks for it with the OO label.
18:12:16 <idnar> ricky_clarkson: (although obviously there's a grey area where the two categories overlap)
18:12:34 <qwr> ricky_clarkson: in some ways, it does use duck typeing ;) but it's quite fundamental type system issue.
18:12:51 <idnar> ricky_clarkson: I guess it has something to do with the fact that people who ask those kinds of questions probably aren't going to try write Haskell code
18:13:09 <Pseudonym> Hanging around #math lately, there is a real sense of being nasty to newbies.
18:13:17 <Pseudonym> The thing is, you have to do maths.
18:13:18 <ricky_clarkson> qwr: You probably know, but I was joking.
18:13:34 <qwr> mhmh
18:13:37 <idnar> #haskell is hands-down the most awesome programming-language-channel I've ever been in
18:13:39 <Pseudonym> The wannabe maths community doesn't care.
18:13:45 <Pseudonym> But #haskell wants people.
18:13:55 * EvilTerran fights with his MPTC-as-relation
18:14:11 * Pseudonym hands EvilTerran a fundep
18:14:22 <EvilTerran> that won't help, it's many-to-many :P
18:14:30 <idnar> but I'm not sure you could replicate that experience in a channel named #python or #ruby or #c or whatever
18:15:08 <soduko> Pseudonym: apparently people who are interested in haskell are nice, and want more nice people.  some how your statement was open to be mis construed as "they need peoplpe, so they are nice"
18:15:15 <EvilTerran> i'm trying to piece together type-indexed heterogeneous collections based on my partial understanding of the HList paper
18:15:18 <Pseudonym> Partly, newbies in #haskell have such damned interesting questions.
18:16:09 <EvilTerran> currently, i'm trying to work out why ((X :+ Y :+ ()) `SubRec` r) doesn't imply (X `Elem` r, Y `Elem` r), even tho the instances would suggest it did
18:16:22 <Tac-Tics> idnar: this channel is the coolest on the wub
18:16:59 <ricky_clarkson> It's not on the web.
18:17:01 <EvilTerran> (specifically, instance (r `SubRec` s, a `Elem` s) => (a :+ r) `SubRec` s
18:17:09 <EvilTerran> ... ph33r.)
18:17:09 <ricky_clarkson> And no, I'm not a pendant, I'm a pedant!
18:17:39 <Tac-Tics> Surely, we're on the wub
18:18:06 <EvilTerran> pedants will insist that the wub is only the http bits of the intertubes.
18:18:17 <soduko> hmm my time is up. i spent it all on discussing:) i wanted to tinker with the RLE program.. but will do so some time next week..
18:19:13 <idnar> EvilTerran: what about pendants?
18:19:49 <EvilTerran> don't be ridiculous, pens can't dance!
18:21:07 <wagle_> EvilTerran, and Pe's can?
18:21:26 <Pseudonym> According to my inbox, pen!s can do all sorts of things.
18:21:37 <wagle_> besides, is it the angels dancing on the pen, or the pen dancing on the angels?
18:22:07 <glguy> anyone played with Arc yet?
18:22:07 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
18:22:18 <glguy> (ideally who can explain what it actually brings to the party)
18:22:40 <EvilTerran> glguy, from the conversation here, it seems to bring nothing interesting at all
18:22:49 <ddarius> glguy: Plenty of people on the internetz have.  They suggest that, unsurprisingly, Arc brings less than nothing.
18:23:02 <usamebinladin> heLLO
18:23:03 <usamebinladin> xD
18:23:06 <usamebinladin> mUAHuahuha
18:23:31 <ricky_clarkson> It's the quality of the spammers that bring me back to #haskell every time.
18:23:48 <glguy> Who is spamming?
18:23:53 <Pseudonym> @keal
18:23:53 <lambdabot> what is the max amount of operands haskell can handle in a single expression?
18:24:02 * Pseudonym is reading the Arc blurb
18:24:15 <Pseudonym> "It doesn't have strong typing, or even type declarations; it uses overlays on hash tables instead of conventional objects; its macros are unhygienic; it doesn't distinguish between falsity and the empty list, or between form and content in web pages; it doesn't have modules or any predefined form of encapsulation except closures [...]"
18:24:16 <ddarius> Pseudonym: Set your face to underwhelmed.
18:24:27 <Pseudonym> You know, Arc sounds a hell of a lot like Perl.
18:24:31 <Pseudonym> Going by this blurb.
18:24:39 <ddarius> Pseudonym: That comment has already been made.
18:24:43 <Tac-Tics> (perl was the 100 year language after all!)
18:24:47 * Pseudonym is never original
18:24:54 <ricky_clarkson> Arc's just another lisp, with the intention of not restricting much.
18:25:09 <Pseudonym> Allow me to propose a use for Arc.
18:25:09 <ricky_clarkson> There seems to be more anti-fuss than fuss.
18:25:13 --- mode: ChanServ set +o glguy
18:25:17 <mauke> perl has a very weak form of type declarations; perl objects aren't hash tables; perl has no macros; perl doesn't allow lists as booleans; perl has modules
18:25:22 <Tac-Tics> I'm surprised no one has defaced the PG article on Wikipedia yet
18:25:24 <Pseudonym> It could be the language that you write your throw-away copy ni.
18:25:54 <Pseudonym> And the reason is that if you value your profession, you would never, ever ship code written in Arc.
18:26:09 <Pseudonym> glguy: What are you waiting for?
18:26:15 <glguy> you clowns filled the list
18:26:22 --- mode: ChanServ set +o Pseudonym
18:26:25 --- mode: glguy set -b thundergirl!*@*
18:26:28 <UnLimitedBOY> xD
18:26:31 --- mode: glguy set +b UnLimitedBOY!*@*
18:26:31 --- kick: UnLimitedBOY was kicked by Pseudonym (Pseudonym)
18:26:37 <Pseudonym> Woo!
18:26:38 --- mode: glguy set -b unlimitedboy!*@*
18:26:40 <Pseudonym> Simultaneous!
18:26:41 --- mode: glguy set +b *!*@adsl-072-148-044-011.sip.rmo.bellsouth.net
18:26:48 <mauke> why a nick ban?
18:26:55 <glguy> because it was fast
18:26:57 --- mode: ChanServ set -o Pseudonym
18:27:00 <glguy> and then I'd follow with that hostban
18:27:13 * Pseudonym has macros for such purposes now
18:27:27 <glguy> well... let's get the ban list cleaned up so
18:27:31 <Pseudonym> Also useful, I wrote a copy of kickban which manipulates the ChanServ access list.
18:27:33 <glguy> so that I don't sit there banning him
18:27:37 <glguy> wondering why its not working
18:28:06 <brad_larsen> on http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays, under the section about unboxed arrays, it says "You can even implement unboxed arrays yourself for other simple types, including enumerations."  Can someone elaborate?
18:28:07 <lambdabot> http://tinyurl.com/2288uq
18:28:15 <qwr> mauke: perl allows lists as booleans
18:28:23 --- mode: glguy set +o glguy_
18:28:25 <mauke> qwr: no
18:28:33 <glguy_> (xchat is easier for ban list editing I think..)
18:28:40 <Pseudonym> But yes, we like to think we have a better class of troll here in #haskell.
18:28:43 <qwr> mauke: though they are implicitly converted through numbers ;)
18:28:48 <mauke> qwr: no
18:29:16 <ricky_clarkson> Pseudonym: I'll take that to mean Jon Harrop isn't here.
18:29:38 --- mode: glguy_ set -b palomer!*@*
18:29:48 * Pseudonym checks the ban list
18:30:01 --- mode: glguy_ set -b GoMittGo!*@*
18:30:11 <wagle_> wow..  i think i remember palomer being banned years ago
18:30:25 <glguy> I'm just killing off the chanserv autorem list dups
18:31:04 <qwr> mauke: perl -e 'print(((3) ? "t" : "f"), (() ? "t" : "f"), "\n")'
18:31:20 --- mode: glguy_ set -b *!n=palomer@*
18:31:21 <mauke> qwr: so?
18:31:34 --- mode: glguy_ set -b %*!*@bas3-montreal02-1096682424.dsl.bell.ca
18:31:37 <Pseudonym> So it would be fair to say that Arc's philosophy is "never do anything right"?
18:31:49 <mauke> (3) better written as 3, btw
18:31:53 <Pseudonym> Or "What Paul wants, Paul gets"?
18:31:54 <Tac-Tics> more like never do anything new, I think
18:32:10 <qwr> mauke: same result with (3,4). which is array in perl
18:32:10 <wagle_> where's the url for arc?
18:32:18 <mauke> qwr: no, it isn't
18:32:19 <Pseudonym> arclanguage.org, IIRC
18:32:46 <ddarius> Pseudonym: The latter.  Or hopefully the latter otherwise Paul is just completely insane.
18:32:56 <nitrateX> glguy fuck you all
18:32:59 <nitrateX> :D
18:33:00 <jcharum> Hi guys/ladies, newbie to Haskell (and IRC for that matter) here, so apologies in advance for any unintentional ignorance.  I'm trying to use HXT for an XML file format for my toy program and am figuring out the deserialization part.  The file is basically a tree - should I just directly traverse the NTree to rebuild my Data.Tree structure?
18:33:02 <nitrateX> vÁˆcxzˆz.Áˆz.Áˆvz.Á
18:33:07 --- mode: ChanServ set +o Pseudonym
18:33:18 --- mode: Pseudonym set -o+b nitrateX *!*n=KLBKSo*@88.237.18.*
18:33:18 --- kick: nitrateX was kicked by Pseudonym (troll)
18:33:29 --- mode: ChanServ set -o Pseudonym
18:33:38 <ricky_clarkson> -o+b?
18:33:42 <brad_larsen> I need to make an instance for (Data.Array.Base.IArray UArray GridElem).
18:33:42 * Pseudonym shrugs
18:33:52 * Pseudonym checks that...
18:33:54 <glguy> ricky_clarkson: hollow-point rounds
18:33:58 <glguy> ricky_clarkson: for taking down ops
18:34:09 <Pseudonym> Ah, yes.
18:34:18 <qwr> mauke: hmm, what it is then?
18:34:18 <Pseudonym> Well, it was in the macro that I modified.
18:34:23 <brad_larsen> data GridElem = Void | Dirt | Obstacle
18:34:37 <mauke> qwr: (3,4) is the comma operator applied to 3 and 4
18:34:39 * EvilTerran notes that he got it in the /24 that time
18:34:45 <mauke> what it does depends on its context
18:35:35 <Pseudonym> Was that good or bad?
18:35:38 --- mode: glguy set +b *!*=KLBKSohb@*
18:36:04 <Pseudonym> I don't object to modifying my macros if they're inappropriate.
18:36:20 <EvilTerran> well, it'd stop him coming back by resetting his 'net connection to get a fresh IP
18:36:21 <mauke> 1) perl has no syntax for literal lists.  2) the only way to get a list is to evaluate something in list context.  3) boolean context <: scalar context
18:36:27 <Pseudonym> Yeah.
18:36:45 <EvilTerran> mauke, er, perl does have literal lists...
18:36:54 <mauke> EvilTerran: no
18:37:05 <EvilTerran> not linked lists, but lists all the same
18:37:10 <mauke> no
18:37:15 --- mode: glguy set -b *!*@adsl-072-148-044-011.sip.rmo.bellsouth.net
18:37:22 <cjb> ($a, $b) = @_; # what's this?
18:37:25 <EvilTerran> (1,2,3) -- look, ma, a list in perl
18:37:31 <EvilTerran> mauke, okay, now you justify your side.
18:37:33 * ddarius is glad he knows no such details about perl.
18:37:39 <cjb> I think mauke has a point, I just don't know what it is.
18:37:44 <mauke> EvilTerran: no, that's the comma operator applied to 1 and the comma operator applied to 2 and 3
18:37:50 <mauke> cjb: list assignment
18:38:04 <cjb> mauke: Please elaborate, since you've obviously confused us.
18:38:22 <mauke> cjb: you're right in that ( ) = is a special case
18:38:31 <Maddas> mauke: I'm not disagreeing, but it doesn't help that perldoc perldata says that EvilTerran's code constructs a "list value".
18:38:43 <Maddas> (Which may be where the terminology confusion stems from.)
18:38:49 <idnar> "In a context not requiring a list value, the value of what appears to be a list literal is simply the value of the final element"
18:38:50 <mauke> anything constructs a list value if you put it in list context
18:39:37 <EvilTerran> mauke, it seems like we're arguing semantics here. given that perl's semantics are wooly at best and utterly broken at worst, this seems unproductive
18:39:41 <idnar> so eg. $foo = (1,2,3); gives you the scalar 3, not a list
18:39:51 <mauke> EvilTerran: you just don't understand what's going on
18:39:54 <EvilTerran> however, i say (1,2,3) acts enough like a list literal in perl for me to call it one
18:40:22 <EvilTerran> what does it do that's distinct from what a Genuine List Literal would do?
18:40:34 <mauke> EvilTerran: that kind of muddy thinking leads to people complaining that "nested lists don't work" or "lists automatically flatten" or similar nonsense
18:40:37 * qwr has just understood that, perl implicitly converts list to list length in scalar context
18:40:47 <mauke> qwr: wrong
18:40:52 <idnar> qwr: no, that's arrays
18:41:03 <mauke> a perl "list" is multiple values
18:41:03 <Nafai> The whole "context" part of Perl always bothered me
18:41:09 <ricky_clarkson> I can make Scala do that.
18:41:15 <mauke> if you know common lisp, that would be a good start
18:41:28 <EvilTerran> i know enough lisp-in-general to get by
18:41:42 <mauke> the only way to get a list is to evaluate an expression in list context
18:41:43 <Pseudonym> Is it possible to "get by" in Lisp?
18:41:54 <mauke> conversely, if it isn't in list context, it's not a list
18:42:13 <mauke> the comma operator does two different things, depending on context
18:42:19 <Pseudonym> I know enough lisp to be able to scoff convincingly about Paul Graham essays.
18:42:25 <dolio> Pseudonym: Did you read the whole arc tutorial, with the code snippets and whatnot?
18:42:33 <Pseudonym> dolio: Skimmed it.  And scoffed.
18:42:35 <dolio> It's pretty amusing.
18:42:38 <EvilTerran> so perl has funny semantics for its list literals (ie implicit flattening). i say they're close enough to list literals to, in the absence of any sort of formal semantics, happily call them list literals.
18:42:39 <Pseudonym> Yeah.
18:42:46 <ddarius> Pseudonym: You don't need to know any lisp to scoff at Paul Graham's articles.
18:42:47 <mauke> in scalar context, A,B evaluates A in void context (and throws the result away), then evaluates and returns B
18:42:52 <Pseudonym> I liked the translation example, after boasting about how Arc only handled ascii.
18:42:54 <EvilTerran> you don't. we disagree. oh well.
18:42:55 <mauke> this works like in C
18:43:00 <qwr> hmm, mauke seems to be correct. perl has exceeded my expectations again with weirdness ;)
18:43:05 <EvilTerran> life's like that. :)
18:43:12 <mauke> in list context, A,B evaluates A and B in list context, then concatenates them
18:43:27 <mauke> let me repeat that: THE COMMA OPERATOR CONCATENATES LISTS
18:43:50 <Pseudonym> qwr: Apart from the lunatic fanboys, everyone seems to concede that this is a wart in Perl.
18:43:51 <EvilTerran> there's no need to shout. i'm trying to move on here.
18:44:04 <mauke> this is the reason why (((1,2),3),4) is the same as ((1,2),(3,4)) or (1,(2,(3,4)))
18:44:19 <mauke> , is associative
18:44:41 <radix> holy crap
18:44:59 <mauke> now, you could argue that 1 and 2 and 3 and 4 are list literals there
18:45:02 <EvilTerran> trouble in paradise, radix?
18:45:05 <mauke> but I doubt that's what you meant
18:45:11 <radix> EvilTerran: no, just watching #haskell :)
18:45:26 <shepheb> Perl is one of those things that's totally natural while you're using it, but when you step away for a while, you think "wtf?"
18:45:55 <EvilTerran> in the absence of any kind of rigour, i'm tempted to appeal to duck semantics a la duck typing
18:46:10 <EvilTerran> "if it looks like a list literal, and quacks like a list literal, it's a list literal"
18:46:20 <mauke> but it doesn't quack like a list literal
18:46:29 <EvilTerran> it may not be right if you're determined to be pedantic, but if you're determined to be pedantic, perl is not the language for you
18:46:44 <ricky_clarkson> If it looks like a Ruby program, and performs like a Ruby program, what do you mean, quacks?
18:46:57 --- mode: glguy set -o glguy
18:47:00 <EvilTerran> ricky_clarkson, "performs like a Ruby program"? what, slowly?
18:47:21 <ricky_clarkson> EvilTerran: I'll get back to you on that.
18:47:30 <EvilTerran> :D
18:47:39 <glguy> I was wondering what arc offered beyond what ruby does. Paul Graham seemed interested in "quick and dirty" and it seems like we already had one of those ;)
18:47:40 <ddarius> "Lisp dialects like Arc have a data type most languages don't: symbols.  We've already seen one: + is a symbol.  Symbols don't
18:47:40 <ddarius> evaluate to themselves the way numbers and strings do.  They return
18:47:40 <ddarius> whatever value they've been assigned."
18:48:13 <glguy> (was wondering that as I was reading earlier at least)
18:48:33 <glguy> ddarius: aka "constants"?
18:48:40 <mauke> EvilTerran: $x = sub { my @tmp = 5 .. 9; return (1, 2, @tmp); }->(); # what does this set $x to?
18:49:18 <ddarius> glguy: I don't know what he means.  Symbols in Lisps do evaluate to themselves.  What he describes sounds like a variable which of course almost every language has.
18:49:32 <ricky_clarkson> At least Arc won't get any coverage in ##java.  That might be the channel's greatest advantage right now.
18:49:56 <jfoutz> mauke: 7?
18:50:06 <mauke> why 7?
18:50:16 <radix> so... can anyone explain what the best practice tools for doing network programming in Haskell are? Imagine I want to write a TCP server that does some web requests in response to certain commands, or something
18:50:16 <jfoutz> scalar context, length of the list
18:50:24 <EvilTerran> mauke, 9 (last element) or 7 (length of the list). it won't be 1, because it's scalar context not list context
18:50:28 <ddarius> @perl $x = sub { my @tmp = 5 .. 9; return (1, 2, @tmp); } ->();
18:50:28 <lambdabot> Maybe you meant: keal part pl spell tell url vera
18:50:29 <mauke> jfoutz: bzzt. there are no lists in scalar context
18:50:38 <idnar> jfoutz: I think you're confusing arrays and lists
18:50:45 <radix> Does everyone just use blocking sockets and OS threading, or is there a common asynchronous networking library, or something else?
18:50:45 <glguy> radix: have you read the irc bot tutorial?
18:50:52 <radix> glguy: nope!
18:51:02 <mauke> EvilTerran: nope
18:51:07 <radix> glguy: thank you for notifying me of its existence.
18:51:28 <EvilTerran> mauke, i'm not having this conversation any more, we're getting nowhere.
18:51:28 <glguy> I'd send you the link but I don't know it off hand
18:51:33 <mauke> EvilTerran: there is no list in that code
18:51:52 <jfoutz> mauke: wow. ok, crazy.
18:52:00 <radix> glguy: I found it easily enough with google. I should start using haskell.org more seriously when I want to learn about stuff, instead of just googling for "haskell sockets" or whatever.
18:52:29 <ricky_clarkson> radix: I need to take your self-advice too.
18:52:41 <mauke> there are a few simple evaluation rules. if you follow them, you get 5 as a result
18:52:55 <qwr> radix: i think easist is to use Network module and threads
18:53:05 <EvilTerran> i tried to do that more subtly around 10min ago with "<EvilTerran> there's no need to shout. i'm trying to move on here.", but that clearly didn't work
18:53:21 <dolio> Wait, 5?
18:53:39 <mauke> EvilTerran: that sounds like "la la la I can't hear you" to me
18:53:53 <EvilTerran> mauke, I repeat, "we're getting nowhere."
18:53:57 <brian`> @src flip
18:53:57 <lambdabot> flip f x y = f y x
18:54:03 * glguy builds a pillow fort
18:54:18 <ddarius> Great idea glguy!
18:54:26 <glguy> I have 10 pillows in my room
18:54:38 <mauke> (if anyone wants to know why the result is 5, say so in #haskell-blah)
18:54:40 <EvilTerran> sure, there may be no lists in the strict, technical look-at-me-i-understand-all-perl's-corner-cases sense
18:55:19 <EvilTerran> but there's something that i will call a list literal, because that's what it looks like. and i am perfectly capable of calling it that and still knowing how they work, thankyou very much;.
18:55:41 <glguy> :-/
18:55:54 <EvilTerran> i'm not aware of an instance of someone being confused by me using the terminology this way
18:56:04 <mauke> except your mental model doesn't match reality
18:56:19 <EvilTerran> hell, i wouldn't be surprised if the documentation uses that terminology somewhere
18:56:19 <ricky_clarkson> He just said he knows how it works.
18:56:22 <Maddas> It does match the perl documentation, though, which may be a more helpful match when talking to other people.
18:56:35 <EvilTerran> mauke, *you* do *not* know *my* mental model
18:56:48 <ricky_clarkson> It involves lots of asterisks.
18:56:57 <radix> hmm, yeah, it looks like the IRC bot example uses blocking sockets (I think?) and doesn't have any explicit concurrency, so I guess it wouldn't mix well with other I/O going on at the same time.
18:57:16 <EvilTerran> *my* mental model of "list literals" is *nothing like* that of, say, lisp
18:57:47 * glguy urges the Perl battle along to #haskell-blah :)
18:57:47 <EvilTerran> because my mental model of "perl list literals" is exactly built around how perl works. surprisingly.
18:57:56 <glguy> radix: blocking IO sounds normal
18:58:11 <glguy> if you need concurrency, forkIO gets you pretty far with threads
18:58:13 <radix> glguy: I feel very uncomfortable with it, I am used to non-blocking I/O and an event loop :)
18:58:49 <radix> glguy: mostly in other stateful imperative languages I avoid threads for I/O concurrency like the plague, but maybe it's not so bad when you don't have any mutable state
18:58:49 <EvilTerran> mauke, capiche?
18:59:00 <wagle_> EvilTerran, i'm intending to stay neutral here, but you are confusing your audience here with your use of the phrase (and i blame myself when i confuse my audience)
18:59:13 <idnar> glguy: does forkIO create OS threads?
18:59:18 <glguy> idnar: no
18:59:22 <EvilTerran> wagle_, oh, mauke wasn't confused, he was just being picky
18:59:31 <idnar> glguy: I don't understand how you can use that with blocking IO, then
18:59:36 <EvilTerran> and the rest of you weren't my audience, just hapless passers-by ;)
18:59:36 <radix> glguy: hmm, that's ...
18:59:38 <radix> yeah, what idnar said
18:59:39 <glguy> forkOS does though
18:59:43 <mauke> EvilTerran: I don't need to know your mental model to see how it fails to match the results of my code
18:59:46 <glguy> radix: it's blocking to you
18:59:51 <glguy> it's not a blockign ffi call
18:59:54 <radix> presumably if those calls are mapping directly onto BSD C calls on blocking sockets, then forkIO wouldn't be enough.
18:59:54 <radix> Oh.
19:00:00 <radix> glguy: So there's some event loop hidden away from me?
19:00:02 <Saizan> radix: internally it uses select or equivalent
19:00:03 <glguy> yeah
19:00:06 <radix> oh.
19:00:07 <wagle_> yeah..  mauke  is just flaming now
19:00:20 <EvilTerran> mauke, so i haven't done perl for a while, and my mental model of my so-called "perl's list literals" is a bit fuzzy. so sue me.
19:00:33 <glguy> In the special olympics...
19:00:39 <Maddas> Hah.
19:00:45 <glguy> I think there's more to that
19:01:08 <Sgeo> G'night all
19:01:13 * glguy waves
19:01:40 <EvilTerran> now, if you're quite done being blatantly inflammatory (see: "<mauke> EvilTerran: that sounds like "la la la I can't hear you" to me" after i tried to cut this conversation off)...
19:02:10 <Saizan> i'd just say that perl is OT and end it here?
19:02:31 <EvilTerran> ...I'm going to be the big man and ignore any attempt to continue this conversation now.
19:02:35 <EvilTerran> :D
19:03:29 <glguy> It's not fair that making fun of the parties involved would just be contributing to the off-topic nature of the conversation :(
19:03:49 <radix> Do the "sleep" and process I/O primitives also integrate with this hidden event loop, to allow other stuff to happen at the same time?
19:04:17 <glguy> process I/O primitives?
19:04:21 * radix hasn't even found sleep or a scheduling API yet, so searches on haskell.org
19:04:26 <mauke> threadDelay
19:04:33 <radix> mauke: you are a saint
19:04:36 <glguy> threadDelay doesn't block the other threads
19:04:38 <mauke> haha
19:04:43 <Saizan> radix: e.g. waitForProcess will block all the threads if you don't use -thraded
19:05:01 <Saizan> "-threaded"
19:06:17 <hpaste>  EvilTerran pasted "type-indexed collections - could not deduce blah blah blah?" at http://hpaste.org/5357
19:06:17 <radix> If I have a library which exposes a file descriptor, is there a way to register it with the low-level event loop with callbacks for reading and writing?
19:06:37 <mauke> radix: well, you could just use fdRead and fdWrite
19:06:48 <mauke> they'll do the Right Thing(tm)
19:07:11 <EvilTerran> anyone feel like earning themselves some Olegs?
19:07:17 <radix> ah, ok. What if I want to avoid buffering too much? is there a way to get notifications of buffer availability? (In other systems this is sometimes called producers and consumers)
19:07:43 <radix> i.e., I want to avoid writing a 5 gigabyte file into an internal buffer; I just want to send it as fast as the other side can read it.
19:07:45 <ddarius> EvilTerran: I don't.
19:07:59 <monochrom> In other systems you spawn a thread to read-with-blocking, don't you?
19:08:05 <wagle_> whats an oleg?
19:08:13 <monochrom> or write-with-blocking
19:08:26 <Saizan> EvilTerran: what do you need?
19:08:28 <EvilTerran> @where oleg
19:08:28 <lambdabot> http://okmij.org/ftp/
19:08:31 <idnar> monochrom: not if you're doing asynchronous I/O
19:08:38 <EvilTerran> wagle_, he does hairy things in the typesystem
19:08:47 <EvilTerran> Saizan, see my paste a minute ago
19:09:01 <wagle_> oh him..  thats right
19:09:08 <EvilTerran> wagle_, he's so noted for this that some of us use "oleg" as a unit of type-hackery
19:09:12 <radix> hmm. so I guess I should just use a smallish fixed buffer in a loop that reads from the file and writes to the socket.
19:09:32 <radix> except in 20 years that buffer will be way too small and my application will perform horribly ;-)
19:10:29 <monochrom> I still think I'm right.
19:10:31 <wagle_> the petapixel million frames a second full 11-dimesional data feeds will get you every time
19:10:44 <radix> heh heh
19:11:14 <radix> Out of curiosity, does ghci use something more efficient than select() (like poll or epoll or whatever) when available?
19:11:49 <monochrom> By having one thread blocked for reading/writing, another thread going on with other business, the whole program behaves asynchronous.
19:11:55 <wagle_> grep --color epoll haskell-src/
19:12:10 <wagle_> grep --color -r epoll haskell-src/
19:12:20 <radix> monochrom: sorry, I was unaware that we were in disagreement about something
19:12:35 <monochrom> No, I'm with disagreement with idnar.
19:12:39 <radix> Oh.
19:13:13 <radix> monochrom: I think idnar's point is that in asynchronous systems you don't "spawn a thread to write-with-blocking"
19:13:36 <radix> monochrom: for some certain particular definition of "asynchronous systems", of which Twisted is an example
19:13:42 <radix> (a Python networking library)
19:13:53 <radix> but I'm not too concerned with that, I guess.
19:14:02 <monochrom> But I'm in #haskell.
19:14:10 <radix> monochrom: Hi! I like it here.
19:14:18 <monochrom> Oh, I said "in other systems" too.
19:14:20 <radix> Yeah.
19:14:33 <monochrom> By that I mean such as Java.
19:14:46 <monochrom> There is no "select" in Java.
19:15:17 <Saizan> EvilTerran: add a method to SubRec where it extracts the subpart from the second argument, then you can use !
19:15:23 <wagle_> i never got that far in java..  what -does- it have?
19:15:42 <monochrom> threading and choice of blocking read/write.
19:15:45 <radix> monochrom: I think there is.
19:15:48 <monochrom> exactly like haskell
19:15:49 <jfoutz> wagle_: threads. shared objects.
19:15:56 <idnar> I don't know anything about network I/O in Java; but having to spawn an OS thread(?) every time you want to write some data sounds horribly slow
19:16:25 <radix> monochrom: the major difference is that Java uses OS threads.
19:16:36 <idnar> I have heard rumours that a thing called "NIO" exists, and provides asynchronous I/O
19:16:37 <radix> But you can also use select.
19:16:38 <monochrom> I mean programmer's interface.
19:16:58 <idnar> but anyhow, let me not push the discussion even further off-topic
19:17:05 <radix> Good idea. Hooray haskell!
19:17:13 <wagle_> jfoutz, i meant "instead of select"
19:17:14 <jfoutz> idnar: nio got added pretty late. like java 1.5
19:17:23 <EvilTerran> Saizan, hmm... cool, i'll try that
19:17:59 <idnar> so now I'm curious; is the select() hidden in the IO monad or something?
19:18:03 <ddarius> "(map (fn (x) (+ x 10)) '(1 2 3)) -> (11 12 13 . nil)" Huh?
19:18:22 <jfoutz> wagle_: well... if you want to handle many client connections, say for a chat, you make one thread for each connection. and a shared object for communicating state between them.
19:18:41 <monochrom> Yes, ghc links your code to a runtime system that calls select.
19:19:12 <byorgey> ddarius: is this arc?
19:19:26 <mauke> ddarius: isn't . nil redundant?
19:19:26 <monochrom> IMO select is very hard to use.
19:19:34 <radix> monochrom: absolutely
19:19:40 <radix> monochrom: I would hate to have to use it, myself :)
19:19:51 <byorgey> yes, the . nil seems correct but it's silly to show it.
19:20:53 <Saizan> idnar: yes, java.nio has a select-like interface for that
19:22:13 <dolio> One of his examples doesn't have the . nil.
19:22:16 <dolio> Though two do.
19:23:07 <idnar> hmm, so I guess Haskell threads will only share state that you pass into them (IORefs or whatever)
19:23:17 <glguy> ideally MVars
19:23:29 <glguy> or something built on them
19:23:59 <idnar> glguy: well, yeah; the ability to *avoid* shared state is what I was thinking about :)
19:24:22 <radix> well, this is pretty satisfying
19:24:37 <radix> I appreciate all the input you guys have given me. thanks very much.
19:24:38 <mauke> you're talking about mutable state, right?
19:24:43 <jfoutz> *sigh* happs is frustrating.
19:24:50 <idnar> mauke: yeah
19:24:54 <radix> hmm. happs, that's something I need to check out
19:25:11 <Saizan> idnar: or channels for message passing
19:25:36 <glguy> channels being an examle of something built of mvars
19:25:41 <idnar> it seems like what CSP calls a "channel" is an MVar in Haskell
19:25:57 <glguy> (you need *some* shared state if you want to communicate a result back
19:26:03 <jfoutz> radix: it's undocumented, the examples don't work. They make extensive use of template haskell.
19:26:06 <glguy> mutable shared*
19:26:16 <radix> jfoutz: I have a lot to look forward to, then :)
19:26:20 <idnar> glguy: right
19:26:24 <ddarius> byorgey: Apparently it only shows it in that example.
19:26:24 <jfoutz> radix: i really really want it to work
19:26:43 <wagle_> jfoutz, that wasnt my question, but never mind
19:26:50 <dolio> idnar: I've not read up on CSP, but there's also Chan.
19:26:51 <idnar> HAppS seems to do some really crazy stuff
19:26:54 <ddarius> I don't know what is different about that example.
19:27:00 <dolio> idnar: Unless writing to a channel in CSP overwrites old values.
19:27:10 <glguy> someone should introduce Paul G to J
19:27:48 <radix> idnar: the persistence stuff looks the weirdest :)
19:27:59 <idnar> dolio: when you write to a channel, your "thread" blocks until another "thread" reads from that channel
19:28:11 <idnar> dolio: and vice-versa; when you read from a channel, you block until someone else writes to the channel
19:28:24 <radix> idnar: I get that feeling that in this channel, you don't have to quote that word to indicate that you mean the userspace kind :)
19:28:41 <idnar> radix: I was quoting it beacuse I think CSP uses the term "process"
19:28:45 <radix> ahhh, ok
19:29:01 <Saizan> yeah, since they don't share state
19:29:04 <idnar> but I only really know about CSP because of Stackless Python, so I'm not sure what's Stackless-specific terminology, and what's CSP terminology
19:30:06 <radix> whoah. happs-dns. ok, so this is more than a web server. this looks more like haskell analog of Twisted.
19:30:16 <idnar> radix: the two main things that stuck out when I was looking at HAppS were the persistence stuff, and the fact that XSLT was mentioned all over the show
19:30:18 <radix> oh wait, resolver, not server.
19:30:25 <Saizan> is there a version of map that works with ranges rather than single elements?
19:30:35 <idnar> radix: HAppS certainly seems to be the closest to Twisted out of anything I've seen, though
19:30:36 <Saizan> err Map, as in Data.Map
19:30:38 <radix> idnar: really!? the only thing I see about xslt on the web page is that they say you can use it if you want because they don't offer any templating libraries
19:30:44 <Nafai> radix: shapr would be one to teach you about Happs. He worked on it before he moved to this job
19:30:50 <radix> Nafai: oh, sweet
19:30:59 <radix> hopefully I will meet up for dinner with him this weekend
19:31:15 <idnar> radix: well, it seems like there's all sorts of crazy XSLT stuff you can use if your service talks XML
19:31:18 <wagle_> which job?
19:31:22 <idnar> radix: and I ended up reading a lot of that, or something
19:31:34 <radix> wagle_: he's got some C# programming job where he programs torture devices for the military, or something
19:31:43 <Saizan> idnar: there's not a particular support for xslt, even if there's some special support for XML
19:31:44 <wagle_> ewww
19:32:00 <radix> wagle_: I am exaggerating, of course
19:32:09 <EvilTerran> Saizan, blah... that didn't work
19:32:23 <wagle_> torture devices for the non-military then?
19:32:23 <EvilTerran> all it did was move the "could not deduce" to the "instance (r `SubRec` s, a `In` s) => SubRec (a :+ r) s
19:32:23 <EvilTerran>  where" line
19:32:35 <radix> wagle_: heh heh.   it's something in the defense contract industry, I don't think he's actually working on tools of harm :)
19:32:36 <idnar> Saizan: I guess I'm thinking of stuff like: http://code.google.com/p/happs/wiki/WhyXslt
19:32:36 <lambdabot> Title: WhyXslt - happs - Google Code
19:32:46 <Saizan> EvilTerran: how did you write it?
19:32:56 <monochrom> Perhaps C# is a torture device.
19:33:04 <radix> monochrom: hmm. good point :)
19:33:19 <idnar> I had a hard time finding HAppS documentation of any kind, though
19:33:20 <lispy> CTortureSharp
19:33:45 <Maddas> Guess why they sharpened it.
19:34:15 <idnar> also I can't even find some of the stuff I was looking at before, so anyhow
19:34:28 <hpaste>  EvilTerran annotated "type-indexed collections - could not deduce blah blah blah?" with "(no title)" at http://hpaste.org/5357#a1
19:34:39 <lispy> is there a way to make GHC dump the types of everything in your where clause as it infered it (whether it ended up failing or not)?
19:35:10 <EvilTerran> Saizan, actually, this one's really odd; "Could not deduce (NotIn a r) from the context (...Rec (a :+ r)...)"
19:35:25 <lispy> EvilTerran: using hlist?
19:35:52 * lispy found that HList is obnoxious with type errors
19:36:06 <EvilTerran> didn't go away even after i made "instance Rec (a :+ r)" into "instance (a `NotIn` r) => Rec (a :+ r)" and added all the other bits to contexts that made necessary
19:36:12 <EvilTerran> lispy, well, re-implementing part of hlist :P
19:36:19 <lispy> EvilTerran: oh, why is that?
19:36:20 <monochrom> the error messages were not designed for type-level programming
19:36:26 <lispy> monochrom: right
19:36:36 <lispy> well, and we don't have a type tracer
19:36:41 <lispy> I want to trace through the inference
19:36:42 <EvilTerran> to aid my understanding, mostly
19:36:48 <lispy> EvilTerran: cool
19:37:01 <wagle_> lispy, not that i know, but tim sheard had a technique of sticking probes into various points to get the types at various points.  darn, but i cant remember the details
19:37:05 <EvilTerran> also to put off going to bed for a little while longer
19:37:38 <lispy> wagle_: I insert 'undefined' sometimes, but it's not really enough when using higher kinds and existential types
19:37:51 <lispy> usualyl I just have to get out pen and paper and type check it by hand
19:37:55 <lispy> this is very time consuming
19:38:47 <lispy> And also, since ghc and I use a different algorithm to name our exitstential types it can be confusing to talk to each othere.
19:39:14 <lispy> "Wait, y1?  I thought taht was u?
19:39:25 * ddarius has never type checked something with pencil and paper.
19:39:37 <lispy> ddarius: really?
19:39:46 <wagle_> yeah..  i've wanted a probe to ask "what type did you think THIS was"
19:39:55 <lispy> ddarius: how about i show you the chunk of code I'm trying to get to type check
19:39:58 <monochrom> I sometimes type-check with keyboard and screen.
19:40:04 <EvilTerran> Saizan, ah, i've kinda got it working. needs lots of explicit types, tho.
19:40:49 <wagle_> i type check in my head..  but my head doesn't always cooperate..  i keep at it because i think my head could use the exercise
19:40:53 * BMeph looks around for shapr, then starts tossing anonymous C-Sharpened lambdas
19:40:54 <ddarius> lispy: I usually just add more type annotations.  Sometimes I type check in my head.
19:41:01 <hpaste>  lispy pasted "hard to type check" at http://hpaste.org/5358
19:41:30 <lispy> ddarius: because ghc cannot infer kinds i have to add more type signatures, that's the main thing I'm doing
19:41:35 <lispy> ddarius: but it's hard sometimes
19:41:50 <ddarius> lispy: I never said it was always easy.
19:42:14 * EvilTerran ponders reformulating a bit
19:42:16 <lispy> how would you do that one without pen and paper? it contains multiple type errors is the where clause of patchset_complement
19:42:24 <jfoutz> i sorta shy away from really big where clauses. so hard to quickcheck.
19:42:42 <lispy> jfoutz: on refactor at a time :)
19:42:45 <lispy> er one
19:42:50 <jfoutz> ehh
19:42:54 <jfoutz> er, heh
19:43:02 <jfoutz> stupid fingers :)
19:43:07 * lispy nods
19:43:24 <EvilTerran> there's got to be some way i can, say, express In in terms of SubRec
19:43:32 <EvilTerran> without overlapping instance hell
19:43:55 <EvilTerran> but i think it's gonna end up with undecidable instances :(
19:44:01 <lispy> ddarius: I think this is especially annoying when ghc is giving me error messages about my types being less polymorphic than expected
19:44:14 <EvilTerran> this is an interesting exercise in writing guarded-recursive algorithms, tho
19:44:15 <brian`> :src (++)
19:44:19 <ddarius> lispy: That should give you an idea what the problem is.
19:44:19 <brian`> @src (++)
19:44:19 <lambdabot> (++) []     ys = ys
19:44:20 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
19:44:27 <lispy> ddarius: BTW, this is the same function i was trying to fix the other day when I gripped about less polymorphic than expect...i still haven't solved it
19:44:32 <EvilTerran> xs ++ ys = foldr (:) ys xs
19:44:46 <brian`> is (:) an expensive operation?
19:44:52 <ddarius> No.
19:44:54 <Cale> brian`: it's as cheap as can be
19:45:01 <EvilTerran> @check \xs ys -> (xs ++ ys) == (foldr (:) ys xs :: [Int])
19:45:01 <lambdabot>  OK, passed 500 tests.
19:45:02 <ddarius> Cale: Not as cheap as id.
19:45:02 <lispy> ddarius: only in that it complains about an existential type...the only trick i have at the moment is to shut it up with a Sealed type, but i'm not sure nthat' the solution
19:45:11 <Cale> ddarius: but almost :)
19:45:44 <EvilTerran> @check liftM2 (==) (flip (++)) (foldr (:)) -- one more time, with less point!
19:45:44 <lambdabot>   add an instance declaration for (Eq ([a] -> [a]))
19:45:55 <EvilTerran> @check liftM2 (==) (flip (++)) (foldr (:)) :: [Int] -> Bool -- ahem
19:45:56 <lambdabot>   add an instance declaration for (Eq ([Int] -> [Int]))
19:46:17 <Saizan> EvilTerran: have you tried putting NotInt a r as context?
19:46:31 <EvilTerran> @check uncurry $ liftM2 (==) (flip (++)) (foldr (:)) :: ([Int],[Int]) -> Bool -- i can get this, i can get this!
19:46:32 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `Bool'
19:46:38 <EvilTerran> oh, sod it
19:46:44 <EvilTerran> Saizan, where?
19:47:11 <EvilTerran> when i said i'd finally got it kinda-working, i did so by adding it to the SubRec (a :+ r) s instance
19:47:19 <Cale> brian`: (xs ++ ys) takes O(length xs) steps to compute, as you can see from the code for (++), so you want to avoid situations where you're applying it with small right hand lists and larger left hand ones.
19:47:22 <EvilTerran> "instance (a `NotIn` r, r `SubRec` s, a `In` s) => SubRec (a :+ r) s where ..."
19:47:44 <Saizan> yeah, there
19:47:59 <Cale> brian`: But (x:xs) itself is cheap, it doesn't copy x or xs, just forms a cell with pointers to each.
19:48:08 <EvilTerran> Saizan, it works, but i need to explicitly type the return value of subRec everywhere
19:48:18 <brian`> Cale, ah.. that clears all my questions :) thanks Cale
19:48:56 <hpaste>  EvilTerran annotated "type-indexed collections - could not deduce blah blah blah?" with "this works" at http://hpaste.org/5357#a2
19:49:38 <EvilTerran> (i put in the `SubRec` both ways round 'cos record type equivalence was part of the original point)
19:50:43 <brian`> hm..? can context has function? i.e. wh :: (WH `SubRec` r, r `SubRec` WH) => r -> (Int,Int)
19:51:36 <EvilTerran> SubRec is a two-parameter class. infix classes is a ghc extension, but a pretty handy one wrt legibility for cases like this
19:51:59 <brian`> ah.. ok
19:58:58 * EvilTerran notes that he could provide an equivalence proof and switch on incoherent+undecidable instances to get it working, but it wouldn't help without a typechecker that breadth-first'ed the instance space
19:59:20 <EvilTerran> and ghc's, i have determined in the past, doesn't
20:00:48 <lispy> Cale: in set theory, does it make sense to compute a complement from two sets?
20:00:57 <EvilTerran> ... i should be programming in Coq, shouldn't i? :P
20:01:08 <lispy> Cale: like if I gave you two sets and asked for the complement, would it be obvious what I was asking for?
20:01:32 <Cale> lispy: If you have a set, and a subset of it, then you can ask for the complement of the subset in the whole set.
20:01:35 <EvilTerran> lispy, you can construct { x in S | not(x in T) }
20:02:02 <Cale> That's usually given the notation S \ T
20:02:05 <lispy> Cale: then maybe that's what this function wants to computer
20:02:07 <lispy> er compute
20:02:08 <EvilTerran> or { x `in` union(S,T) | not(x `in` intersect(S,T)) }
20:02:40 <EvilTerran> which some write S (+) T, iirc
20:02:45 <lispy> well, i compute both a union and an intersection, so probably that latter definiton EvilTerran
20:02:57 <EvilTerran> it depends on what you want
20:03:03 <Cale> EvilTerran's definition is known as the symmetric difference
20:03:07 <EvilTerran> http://en.wikipedia.org/wiki/Symmetric_difference
20:03:08 <lambdabot> Title: Symmetric difference - Wikipedia, the free encyclopedia
20:03:19 <Cale> another common notation for that is a triangle
20:03:25 <EvilTerran> http://en.wikipedia.org/wiki/Complement_%28set_theory%29#Relative_complement
20:03:25 <lambdabot> http://tinyurl.com/2p9z5g
20:03:31 <EvilTerran> compare :)
20:04:26 <lispy> thanks
20:05:09 <lispy> I have a hunch this is supposed to implement relative complement
20:08:47 <nanothief> Does Text.Regex depend on an external library? As I got this error message when using it: undefined reference to `__stginit_regexzmcompatzm0zi71zi0zi1_TextziRegex_'
20:09:27 <Saizan> nanothief: compiled with --make?
20:09:56 <nanothief> Saizan: *sigh* I always forget to do that
20:09:59 <nanothief> thanks :P
20:12:21 <monochrom> external libs have less horrendous names than __stginit_regexzmcompatzm0zi71zi0zi1_TextziRegex_ :)
20:12:38 <cdsmithus> I'm back to trying to list all cycles in a graph.  I thought I had something, but it's incorrect.  Anyone here have an idea how to approach it in Haskell?
20:13:24 <ddarius> Define "graph"
20:13:55 <cdsmithus> The Graph type from Data.Graph.  Directed, no parallel edges, but loops are allowed (and anti-parallel edges)
20:17:41 <jfoutz> cdsmithus: oh... maybe put all the edges in a finiteMap. remove them after you show all the cycles the're involved in.
20:19:15 <brad_larsen> jfoutz:  i've been thinking about my earlier troubles with performance of array comparison.  i've been thinking imperatively.
20:19:19 <cdsmithus> jfoutz: Hmm.  I'm not seeing what you mean.  Can you elaborate?
20:21:24 <jfoutz> cdsmithus: maybe something like... take the first edge, call reachable on the first edge's starting vertex from it's ending vertex. remove that edge from the graph.
20:21:58 <brad_larsen> jfoutz:  i was working with the notion that data outside of IO/ST monads has identity, and was expecting ghc to do some optimization magic so that (==) and (`compare`) on arrays would be done in constant time in my program (since I don't do update operations on  them much)
20:22:15 <jfoutz> cdsmithus: you have to be more clever than that, because one edge can particpate in multiple cycles...
20:22:19 <cdsmithus> jfoutz: Huh.  But I need to know all of the cycles containing that edge;
20:22:47 <cdsmithus> jfoutz: Yep.  I'm thinking of doing a separate depth-first search for each vertex, but then I'll get duplicates...
20:23:04 <jfoutz> cdsmithus: one way is to recursively remove the children of the edge in question.
20:23:31 <jfoutz> brad_larsen: ah. yeah. it's tempting to think == is pointer compare.
20:23:49 <TomMD> @hoogle FileMode
20:23:49 <lambdabot> System.Posix.Types.FileMode :: type FileMode
20:24:39 <radix> so, in a type like   "fmap                  :: (a -> b) -> f a -> f b", how should I read "f a" and "f b"? "Effy a"? :)
20:24:44 <ddarius> jfoutz: It is?
20:25:31 <brad_larsen> jfoutz: i'm going to change things some.  adding an ID to my types that contain arrays is a good idea, but tricky to get right.  i'm probably going to change my code so my arrays are _never_ updated---the information that does change will be separate, and that'll be used for comparison purposes.
20:25:38 <jfoutz> ddarius: if you come from java, or C or perl... i think so, yeah.
20:25:49 <jfoutz> heck even scheme does eq
20:26:45 <brad_larsen> jfoutz:  or, i'm sure there's some way to do what I want using a state monad, or some other monad.  but that frightens me. ;-)
20:27:17 <jfoutz> it frightens me too.
20:28:59 <jfoutz> brad_larsen: i'm pretty sure there's a clever way to have a counter i'm not thinking of... just have each array have the next id.
20:29:28 <brad_larsen> jfoutz:  what do you mean more precisely?
20:30:32 <jfoutz> it would be neat if there was a makeArray function. you'd give makeArray your data, it would hand you back a datatype with an id = 1+lastIDHandedOut
20:30:56 <lispy> ?hoogle makeArray
20:30:56 <lambdabot> No matches found
20:31:13 <brad_larsen> jfoutz:  but to do that in a purely functional way?  or that would only be called, for example, from inside the IO monad?
20:32:14 <brad_larsen> jfoutz:  doing that would probably push all my search code into the monad...
20:33:14 <jfoutz> what if you push all of your array changes to the IO monad? every time you make a change up a counter.
20:34:02 <brad_larsen> jfoutz:  yeah, that would work, but then all the code for my search algorithms would have to be non-pure.
20:34:19 <brad_larsen> jfoutz:  it just seems like there is a better way to do it
20:34:29 * jfoutz nods
20:36:02 <jfoutz> I'm not sure when you need to compare two arrays
20:36:11 <jfoutz> or, why.
20:36:39 <brad_larsen> my program is a school assignment :)  implementing a bunch of search algorithms for ``vacuum-world''
20:36:47 <brad_larsen> from norvig+russell book
20:36:59 <jfoutz> oh, i remember that.
20:37:01 <brad_larsen> a vacuum robot travels around an environment, sucking up dirt
20:37:15 <jfoutz> yeah, there may be dirt
20:37:17 <brad_larsen> i'm modeling the environment in part with a 2d array
20:37:39 <brad_larsen> the array contains elements of an enumeration
20:37:54 <brad_larsen> data GridElem = Void | Dirt | Obstacle | RechargeStation
20:38:08 <brad_larsen> when the vacuum robot sucks up dirt, this environment changes
20:38:19 <jfoutz> oh, i see.
20:38:21 <brad_larsen> so when vacuuming is done, i update that cell in the array
20:38:40 <brad_larsen> my searches work, but the performance is awful, because of the array compare function
20:38:52 <brad_larsen> it's getting hammered in the main loop, for duplicate detection
20:39:09 <jfoutz> ... another way to go, would be to have a finiteMap of dirt locations...
20:39:18 <brad_larsen> i'm storing visited states in a Data.Set
20:39:43 <brad_larsen> yeah, that's what I was thinking.  the ``environment'' would still be partially modeled by an array
20:39:56 <brad_larsen> but the array wouldn't know which cells have dirt.
20:40:02 <brad_larsen> that way, the array comparison could be skipped.
20:40:29 <jfoutz> i don't think you even need an array.
20:41:06 <jfoutz> your vaccume bot has a current address, various checks to ensure 0<x<width, 0<y<height
20:41:12 <brad_larsen> i need to determine somehow which moves are valid at a given location
20:41:27 <brad_larsen> yes.  some grid cells can be obstacles though
20:41:27 <jfoutz> valid?
20:41:30 <brad_larsen> or places to recharge
20:41:48 <jfoutz> map of obstacles?
20:41:49 <lispy> brad_larsen: when i've done this stuff before I found a layered approach helped performance.  My cause was knights tour.
20:42:08 <lispy> brad_larsen: so I stored the visited nodes in a list instead of updating the graph to mark things as visited
20:42:09 <jfoutz> validMove(robot,obstacles)
20:43:18 <jfoutz> if(hasElement(address robot, obstacles)) False else true
20:43:21 <jfoutz> something like that
20:44:37 <brian`> @src group
20:44:38 <lambdabot> group = groupBy (==)
20:44:47 <brian`> :t groupBy
20:44:48 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
20:44:49 <brad_larsen> yes, that would be better.  a sparse way of storing the environment
20:45:05 <brian`> which module should I import to use groupBy or group?
20:45:16 <ddarius> @index group
20:45:16 <lambdabot> Data.List
20:45:17 <jfoutz> data.list,
20:45:20 <jfoutz> i think.
20:45:26 <brian`> ok
20:46:00 <lispy> > group . fix $ show
20:46:00 <lambdabot>  ["\"","\\","\"","\\\\\\","\"","\\\\\\\\\\\\\\","\"","\\\\\\\\\\\\\\\\\\\\\\\...
20:46:23 <lispy> group requires the list to be sorted
20:46:25 <jfoutz> brad_larsen: well, you get fast updates, fast lookups.
20:46:32 <lispy> (that's what i was trying to show with that line)
20:46:38 <jfoutz> ahhh.
20:46:52 <ddarius> lispy: Only if you expect more from it than it means.
20:46:54 <jfoutz> sort, also in data.list.
20:47:16 <ddarius> > group "aabbaaa"
20:47:17 <lambdabot>  ["aa","bb","aaa"]
20:47:43 <jfoutz> > group . sort "lispy: Only if you expect more from it than it means."
20:47:44 <lambdabot>  Couldn't match expected type `a -> [a1]'
20:47:45 <lispy> ddarius: well the standard implementation should be named groupAdjacent in my opinion
20:47:49 <jfoutz> darn.
20:48:00 <lispy> > group . sort $ "lispy: Only if you expect more from it than it means."
20:48:00 <lambdabot>  ["          ",".",":","O","aa","c","eeee","ff","h","iiii","ll","mmm","nnn","...
20:48:52 <lispy> > map head . group . fix $ show
20:48:55 <lambdabot> Terminated
20:48:59 <lispy> > take 10 . map head . group . fix $ show
20:48:59 <lambdabot>  "\"\\\"\\\"\\\"\\\"\\"
20:49:10 <jfoutz> what is fix?
20:49:14 <jfoutz> @src fix
20:49:15 <lambdabot> fix f = let x = f x in x
20:49:15 <ddarius> @src fix
20:49:16 <lambdabot> fix f = let x = f x in x
20:49:19 <lispy> jfoutz: i'm glad you asked
20:49:21 <ddarius> fix f = f (fix f)
20:49:32 <brian`> fix (*)
20:49:34 <brad_larsen> fixpoint?
20:49:35 <brian`> > fix (*)
20:49:35 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
20:49:35 <lambdabot>     Probabl...
20:49:38 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
20:49:38 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
20:49:42 <jfoutz> yeah
20:50:22 <lispy> jfoutz: imagine you take a function and call it again on itself
20:50:52 <lispy> jfoutz: lots of fun things can now happen
20:50:57 <jfoutz> yeah... i'm used to the applicative order Y combinator.
20:51:15 <lispy> my favorite is fix show
20:51:19 <jfoutz> lazy languages are strange.
20:51:24 <lispy> > fix show
20:51:25 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
20:51:37 <lispy> you just keep getting more quotes
20:51:39 <jfoutz> > show
20:51:40 <lambdabot>  <Integer -> [Char]>
20:51:46 <lispy> but to show a quote you have to escape it
20:51:53 <lispy> and to escape an escape...
20:52:05 <lispy> you can get powers of two from this
20:52:11 <jfoutz> you're a sick man lispy.
20:52:14 * jfoutz grins
20:52:17 <lispy> hehe
20:52:37 <lispy> > take 10 . map length . group . fix $ show
20:52:38 <lambdabot>  [1,1,1,3,1,7,1,15,1,31]
20:53:12 <cjb> lispy: *blink*
20:54:00 <monochrom> You can prove it.
20:54:15 <lispy> cjb: I'll leave it as an excercise to the reader to transform the output of (map length . group . fix $ show) into fibs :)
20:55:16 <cjb> lispy: I'm still trying to work out what it's doing :)
20:55:17 <lispy> I would rarely ever do this is real code, but it's fun to replace 'let' with fix
20:55:38 <lispy> cjb: start with equational reasoning
20:55:48 <lispy> cjb: start with (fix show)
20:55:52 <lispy> > fix show
20:55:53 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
20:56:04 <lispy> ?src fix
20:56:04 <lambdabot> fix f = let x = f x in x
20:56:17 <lispy> fix show = let x = show x in x
20:56:22 <cjb> oh, silly.  okay.
20:57:17 <lispy> fix show = let x = show x in x = show (show ...))
20:57:26 <lispy> :t show
20:57:26 <brad_larsen> jfoutz:  you mention finiteMap.  Is that different from Data.Map?
20:57:27 <lambdabot> forall a. (Show a) => a -> String
20:58:53 <lispy> cjb: what's interesting to me, is that the first show can actually do anything...it just knows that it's getting called on something of type String
20:59:01 <jfoutz> brad_larsen: no, that's what you want
20:59:12 <brad_larsen> jfoutz:  thank you
20:59:16 <lispy> cjb: and, since that's the case, it gives us a starting double quote
20:59:20 <dolio> FiniteMap is the old version, more or less.
20:59:37 <cjb> lispy: oh, wow.  :)
20:59:57 <wagle_> > show . show . show
20:59:58 <lambdabot>  <Integer -> [Char]>
21:00:04 <TomMD> Is the author of Control.Timeout here?
21:00:47 <lispy> > iterate show ""
21:00:47 <lambdabot>  ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\...
21:00:56 <ddarius> Of course it knows it's getting called on something of type String
21:01:20 <dons> TomMD: isn't that Adam Langley?
21:01:22 <wagle_> > show . show . (show :: String -> String)
21:01:23 <lambdabot>  <[Char] -> [Char]>
21:01:25 <dons> (if so, he's not in here)
21:01:35 <TomMD> dons: yes, ok
21:01:37 <wagle_> > show . show . (show :: String -> String) ""
21:01:38 <lambdabot>  Couldn't match expected type `a -> b'
21:01:45 <wagle_> > show . show . (show :: String -> String) $ ""
21:01:45 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\"\\\"\""
21:01:47 <TomMD> I just figured if he is here I didn't know his nick.
21:01:55 <lispy> > take 10 . map length . group . concat . iterate show ""
21:01:56 <lambdabot>  Couldn't match expected type `a -> [[a1]]'
21:02:16 <lispy> :t concat
21:02:17 <lambdabot> forall a. [[a]] -> [a]
21:02:22 <wagle_> > show . show . show $ ""
21:02:23 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\"\\\"\""
21:02:29 <jfoutz> > take 10 $ zipWith (+) (map length . group . fix $ show) (drop 1 $ map length . group . fix $ show)
21:02:29 <lambdabot>  [2,2,4,4,8,8,16,16,32,32]
21:02:48 <lispy> jfoutz: very good
21:02:59 <jfoutz> almost., need to filter odd elements.
21:03:07 <jfoutz> or something.
21:03:15 <wagle_> group $ take 10 $ zipWith (+) (map length . group . fix $ show) (drop 1 $ map length . group . fix $ show)
21:03:19 <lispy> actually, there is a really complicated version that does the powers of 2 pretty well
21:03:25 <lispy> it was in HWN once
21:03:27 <wagle_> > group $ take 10 $ zipWith (+) (map length . group . fix $ show) (drop 1 $ map length . group . fix $ show)
21:03:28 <lambdabot>  [[2,2],[4,4],[8,8],[16,16],[32,32]]
21:03:43 <jfoutz> well... nub.. but that would be cheating.
21:03:45 <jfoutz> :)
21:03:46 <wagle_> > map fst $ group $ take 10 $ zipWith (+) (map length . group . fix $ show) (drop 1 $ map length . group . fix $ show)
21:03:47 <lambdabot>  Couldn't match expected type `(a, b)' against inferred type `[Int]'
21:04:15 <lispy> > init . map snd . filter fst . zip (fix ([True, False] ++)) . ap (zipWith (+)) tail . map length . group . fix $ show
21:04:18 <wagle_> > map head $ group $ take 10 $ zipWith (+) (map length . group . fix $ show) (drop 1 $ map length . group . fix $ show)
21:04:20 <lambdabot>  [2,4,8,16,32]
21:04:22 <lambdabot> Terminated
21:04:31 <lispy> > take 10 . init . map snd . filter fst . zip (fix ([True, False] ++)) . ap (zipWith (+)) tail . map length . group . fix $ show
21:04:32 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024]
21:04:41 <cjb> :)
21:04:44 <jfoutz> fix true false. hahaha
21:04:59 <wagle_> > fix true false
21:05:00 <lambdabot>   Not in scope: `false'
21:05:09 <ddarius> @index fix
21:05:09 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
21:05:17 <lispy> > fix ([True, False] ++)
21:05:17 <lambdabot>  [True,False,True,False,True,False,True,False,True,False,True,False,True,Fals...
21:05:19 <wagle_> > fix fix fix
21:05:19 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
21:05:19 <lambdabot>     Probabl...
21:05:28 <jfoutz> > take 10 $ fix ([True,False] ++)
21:05:30 <lambdabot>  [True,False,True,False,True,False,True,False,True,False]
21:05:35 <ddarius> > fix error -- more interesting in GHCi
21:05:36 <lambdabot>  Exception: <<loop>>
21:05:47 <dons> what happens in ghci?
21:05:53 <dons> no blackholing?
21:05:58 <ddarius> dons: Yes.
21:06:17 <jfoutz> take 10 $ mapM (const [True,False])
21:06:24 <dons> oh, cute.
21:06:27 <jfoutz> > take 10 $ mapM (const [True,False])
21:06:28 <lambdabot>  Couldn't match expected type `[a]'
21:06:33 <dons> *** Exception: *** Exception: *** Exception: *** Exception: *** Exception:
21:06:36 <dons> :D
21:06:42 <lispy> nice
21:06:52 <dons> haskell's lovely
21:06:57 <dolio> > map (sum . take 2) . iterate (drop 2) . map length . group . fix $ show
21:07:01 <lambdabot> Terminated
21:07:02 <lispy> ?index fix
21:07:02 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
21:07:42 <jfoutz> > take 10 $ filterM (const [True,False]) [1..10]
21:07:43 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,10],[1,2,3,4,5,...
21:08:01 <wagle_> > map ( % 4) . sum $ group $ take 10 $ zipWith (+) (map length . group . fix $ show) (drop 1 $ map length . group . fix $ show)
21:08:02 <lambdabot>   add an instance declaration for (Num [Int])
21:08:11 <wagle_> > map $ ( % 4) . sum $ group $ take 10 $ zipWith (+) (map length . group . fix $ show) (drop 1 $ map length . group . fix $ show)
21:08:12 <lambdabot>  Couldn't match expected type `a -> b'
21:08:20 <sarehu> > 1
21:08:20 <lambdabot>  1
21:08:33 <wagle_> > map (( % 4) . sum) $ group $ take 10 $ zipWith (+) (map length . group . fix $ show) (drop 1 $ map length . group . fix $ show)
21:08:34 <lambdabot>  [1%1,2%1,4%1,8%1,16%1]
21:08:41 <lispy> > fix . const $ 1
21:08:44 <lambdabot>  1
21:09:01 <jfoutz> > fix (const 1)
21:09:03 <lambdabot>  1
21:09:08 <ddarius> @check \x -> fix . const $ x = id $ x
21:09:08 <lambdabot>  Parse error at "=" (column 23)
21:09:15 <ddarius> @check \x -> fix . const $ x == id $ x
21:09:15 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Bool'
21:09:34 <lispy> probably need parens on the lambda
21:09:37 <ddarius> @check liftM2 (==) (fix . const) id
21:09:38 <lambdabot>  Add a type signature
21:09:48 <ddarius> @check liftM2 (==) (fix . const) (id :: Int -> Int)
21:09:49 <lambdabot>  OK, passed 500 tests.
21:09:50 <lispy> @check \x -> (fix . const $ x) == (id $ x)
21:09:51 <lambdabot>  Add a type signature
21:09:59 <lispy> @check \x -> (fix . const $ x) == (id $ x) :: Int -> Bool
21:09:59 <lambdabot>  Couldn't match expected type `Int -> Bool'
21:10:21 <lispy> @check (\x -> (fix . const $ x) == (id $ x)) :: Int -> Int
21:10:21 <lambdabot>  Couldn't match expected type `Int' against inferred type `Bool'
21:10:27 <lispy> @check (\x -> (fix . const $ x) == (id $ x)) :: Int -> Bool
21:10:28 <lambdabot>  OK, passed 500 tests.
21:10:30 <lispy> heh, stupid me
21:10:42 <lispy> well, that's all the proof I need!
21:10:48 <lispy> quickcheck never lies
21:11:08 <wagle_> @check False
21:11:09 <lambdabot>  Falsifiable, after 0 tests:
21:11:48 <wagle_> @check this
21:11:49 <lambdabot>   Not in scope: `this'
21:12:46 <MagicDuck> hi, I have 2 files, one containing the Main module and the other containing a module I made and am importing in Main. When I try to compile with ghc it says it failed to load interface for 'MyModule'
21:13:05 <sarehu> MagicDuck: what if you compile MyModule first?
21:13:07 <brad_larsen> try ghc --make
21:13:14 <sarehu> MagicDuck: also, what brad said
21:13:17 <MagicDuck> thx
21:13:30 <jfoutz> >take 10 $ zipWith (+) (map length $ filter (=="\"") group . fix $ show)
21:13:50 <MagicDuck> bingo
21:13:55 <jfoutz> night.
21:14:53 <lispy> > take 10 $ zipWith (+) (map length $ filter (=="\"") group . fix $ show)
21:14:53 <lambdabot>  Couldn't match expected type `[[Char]]'
21:15:32 <sarehu> how does zipWith (+) make sense on that list?
21:15:36 <sarehu> it takes two lists
21:15:48 <sarehu> also, s/group/. group/
21:16:13 <lispy> > take 10 . ap (zipWith (+)) tail . map length . group . fix $ show
21:16:14 <lambdabot>  [2,2,4,4,8,8,16,16,32,32]
21:16:29 <lispy> that zipWith?
21:16:33 <wagle_> > group . show . show . show $ ""
21:16:33 <lambdabot>  ["\"","\\","\"","\\\\\\","\"","\\\\\\","\"","\\","\"\""]
21:16:44 <wagle_> > map length . group . show . show . show $ ""
21:16:45 <lambdabot>  [1,1,1,3,1,3,1,1,2]
21:17:12 <lispy> :t ap (zipWith (+)) tail
21:17:12 <lambdabot> forall a. (Num a) => [a] -> [a]
21:17:21 <lispy> sarehu: the magic is in ap
21:17:22 <lispy> :t ap
21:17:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:17:35 <wagle_> length "\\"
21:17:39 <lispy> > ap (+1) (return 1) :: Maybe Int
21:17:40 <lambdabot>      The section `(+ 1)' takes one argument,
21:17:40 <lambdabot>     but its type `Maybe (a -> In...
21:17:40 <wagle_> > length "\\"
21:17:41 <lambdabot>  1
21:17:56 <lispy> > ap (return (+1)) (return 1) :: Maybe Int
21:17:56 <lambdabot>  Just 2
21:18:45 <lispy> :t \x -> ap x tail
21:18:46 <lambdabot> forall b a. ([a] -> [a] -> b) -> [a] -> b
21:19:09 <lispy> to be honest, I don't remember now how that zipWith works :)
21:19:53 <lispy> I think that might be the 'ap' using the arrow instance of monad or something?
21:19:56 <lispy> or maybe reader
21:20:20 <lispy> > ap (+1) (const 1)
21:20:21 <lambdabot>   add an instance declaration for (Num (a -> b))
21:20:56 <lispy> wish i could remember
21:21:23 <scook0> > ap (+) (const 1) $ 0
21:21:23 <lambdabot>  1
21:21:53 <lispy> what monad instance is that?
21:22:00 <lispy> :t ap (+) (const 1)
21:22:00 <lambdabot> forall a. (Num a) => a -> a
21:22:08 <lispy> :t ap
21:22:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:22:25 <lispy> a is (Int -> Int)
21:22:30 <lispy> well, c -> Int
21:23:18 <lispy> m (c -> Int -> b) -> m (c -> Int) -> m b, we give it (+), so that sets c = Int
21:23:39 <lispy> m (Int -> Int -> Int) -> m (Int -> Int) -> m Int, but then the m disappears
21:23:41 <lispy> so what monad is that?
21:24:55 <allbery_b> ((->) r)?
21:25:28 <lispy> allbery_b: yeah, i think that is it
21:25:36 <lispy> > ap (+) (+1) 2
21:25:37 <lambdabot>  5
21:25:58 <lispy> ap f g a = a `f` (g a)
21:26:28 <lispy> a `zipWith (+)` (tail a)
21:26:52 <lispy> > fix $ \fibs -> 1 : 1 : ap (zipWith (+) tail
21:26:52 <lambdabot> Unbalanced parentheses
21:26:57 <lispy> > fix $ \fibs -> 1 : 1 : ap (zipWith (+)) tail
21:26:57 <lambdabot>  Couldn't match expected type `[a -> t]'
21:27:44 <lispy> > fix $ \fibs -> 1 : 1 : ap (zipWith (+)) tail fibs
21:27:55 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:28:12 <lispy> How's that for confusing newbies!
21:29:00 * Cin seizures
21:29:43 <lispy> fix $ \fibs -> 1 : 1 : ((zipWith (+)) `ap` tail) fibs -- I like this too
21:30:15 <lispy> ?pl fix $ \fibs -> 1 : 1 : ((zipWith (+)) `ap` tail) fibs
21:30:15 <lambdabot> fix ((1 :) . (1 :) . (zipWith (+) `ap` tail))
21:30:23 <wagle_> @pl \x y . show x ++ "+" ++ show y
21:30:23 <lambdabot> (line 1, column 6):
21:30:24 <lambdabot> unexpected "."
21:30:24 <lambdabot> expecting pattern or "->"
21:30:42 <wagle_> @pl \x y -> show x ++ "+" ++ show y
21:30:43 <lambdabot> (. (('+' :) . show)) . (++) . show
21:31:43 <davidL> @unpl fix((1:).scanl(+)1)
21:31:43 <lambdabot> fix (\ d -> 1 : (scanl (+) 1 d))
21:31:45 <wagle_> ap ((. (('+' :) . show)) . (++) . show) show "1"
21:31:51 <wagle_> > ap ((. (('+' :) . show)) . (++) . show) show "1"
21:31:51 <lambdabot>  "\"1\"+\"\\\"1\\\"\""
21:32:50 <wagle_> > ap ((. (('+' :) . id)) . (++) . id) id "1"
21:32:51 <lambdabot>  "1+1"
21:33:37 <wagle_> > QED
21:33:37 <lambdabot>   Not in scope: data constructor `QED'
21:34:39 <lispy> wagle_: nice one
21:35:48 <wagle_> @pl  ap ((. (('+' :) . id)) . (++) . id) id "1"
21:35:48 <lambdabot> "1+1"
21:35:59 <wagle_> @pl  ap ((. (('+' :) . id)) . (++) . id) id
21:35:59 <lambdabot> (++) `ap` ('+' :)
21:36:07 <wagle_> oh good
21:36:28 <lispy> it almost seems like "flip ap id" should be in the standard libs
21:36:35 <lispy> :t flip ap id
21:36:36 <lambdabot> forall b a. (a -> a -> b) -> a -> b
21:37:25 <lispy> oh i see how that simplified one works
21:39:09 <wagle_> @pl  flip $ ap ((. (('+' :) . id)) . (++) . id) id
21:39:09 <lambdabot> flip ((++) `ap` ('+' :))
21:40:01 <Cin> where is the gobby thingie for the arc implementation?
21:40:13 <Cin> anybody working on that still awake?
21:40:14 <wagle_> gobby thingie?
21:40:25 <bos> arc implementation?
21:40:27 <Cin> yeah, it's some development thing
21:40:37 <bos> is someone doing a "write your own arc in 48 minutes"?
21:40:44 <Cin> bos: precisely
21:40:46 <bos> gobby is a collaborative editor.
21:40:46 <lispy> bos: clever
21:40:59 <Cin> bos: dons brought it up and a few people started it
21:41:06 <bos> @seen dons
21:41:06 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 31m 13s ago.
21:41:17 <bos> that's pretty amusing.
21:41:21 <lispy> dons is such an instigator ;)
21:41:54 <jcreigh> little known fact: dons started the industrial revolution.
21:42:14 <wagle_> didnt he also invent al gore?
21:42:22 <lispy> we need a typed revolution
21:42:35 <lispy> one that won't be televised
21:45:33 <shachaf> Cin: I just came back.
21:45:39 <Cin> shachaf: well hello :)
21:45:55 <shachaf> Cin: The server is at vawpc50.ethz.ch:6522 -- it seems pretty empty, though.
21:46:09 * shachaf was not particularly involved.
21:46:39 <sjanssen> how far have you all gotten on it?
21:46:55 <shachaf> sjanssen: When I left it was all pretty messy.
21:47:28 <shachaf> There also seems to be a (separate) darcs repository at http://elliotthird.org/arc .
21:47:29 <lambdabot> Title: Index of /arc/
21:48:12 <lispy> messy seems to suit arc
21:48:22 <lispy> so, what is the specification of reimplementation?
21:48:26 <shachaf> lispy: But not Haskell code. :-)
21:48:28 <lispy> PG has said there is no official spec yet
21:49:00 <lispy> Is it just a scheme you're building with some of the quirks mentioned in his tutorial?
21:49:29 <Maddas> You'll have to leave away the useful parts, though
21:49:29 <shachaf> lispy: Ask the people who were involved in it. :-)
21:49:37 <shachaf> lispy: But it looks like it, roughly.
21:50:18 <shachaf> lispy: Probably just a few primitives need to be implemented -- it seems that a lot can be reused.
21:53:00 <lispy> Maddas: ironically and sadly, yes
22:03:37 <sm> evening all
22:07:29 <brad_larsen> yay!  i changed my vacuum-world code so instead of using arrays to represent the world, it uses a few Data.Set.  WAY faster now.
22:10:35 <nanothief> is there any way to change the default search path with ghc using an environmental var or similar?
22:14:04 <lispy> brad_larsen: that's great
22:24:00 <bos> @pl \a b -> a <|> ch b
22:24:00 <lambdabot> (. ch) . (<|>)
23:03:48 <sm> haskell on mac osx users: should I download latest source or use the port, given that I want to build current stuff from hackage ?
23:05:23 <mikmik> last time i checked the port was 6.6
23:05:55 <sm> yes, or ghc_devel which is 6.7
23:06:10 <sarehu> I would just use latest source
23:06:16 <sm> I suspect 6.8.2 tarball and extralibs + cabal-install is the way to go
23:06:17 <johnnowak> sm: don't use port
23:06:18 <sarehu> assuming you have ghc to compile it with :)
23:06:31 <johnnowak> snagging the binaries is the easiest
23:06:39 <sm> perhaps I'll need the leopard binary of ghc too
23:06:49 <wagle_> why not use (mac)port(s)?  i was about to do that
23:07:11 <johnnowak> it has 6.6
23:07:44 <mikmik> compiling 6.8 from source was pretty straight forward
23:10:05 <z> Hello. Is there a haskell kernel?
23:10:37 <dons> yes. there are several, actually.
23:10:39 <z> I don't mean the syntactic kernel
23:10:52 <z> but rather, an operating system kernel and full support like memory manager, etc
23:10:56 <dons> yes, several. :)
23:11:00 <z> where?
23:11:05 <z> please tell me good name !
23:11:18 <dons> research kernels. http://haskell.org/haskellwiki/Applications_and_libraries/Operating_system#Standalone_operating_systems
23:11:18 <lambdabot> http://tinyurl.com/2wcptv
23:11:23 <z> cool
23:11:27 <z> thank you
23:11:35 <dons> House is the standard one. but there's an L4 kernel in haskell too
23:12:37 <dons> more useful may be the papers published about haskell kernels, http://haskell.org/haskellwiki/Research_papers/Program_development#Operating_systems
23:12:37 <lambdabot> http://tinyurl.com/y4929f
23:14:31 <sm> thanks all, building all from latest source
23:15:27 <z> is Haskell capable of being as fast as a C kernel ?
23:15:28 <sm> oh, the readme recommends I don't build ghc from c
23:15:35 <sm> guess I'll get the binary as well
23:15:55 <mikmik> regarding ghc on mac osx, anyone compiled gtk2hs on mac osx?
23:16:13 <Tac-Tics> z: the question to ask in this channel is "Is C capable as being as reliable as Haskell?" ;-)
23:16:18 * sm will be soon
23:16:37 <z> Okay, I'll rephrase my question:
23:16:41 <dons> z, its not going to be as fast.
23:16:52 <wagle_> mikmik, i started installing macos10.5 today..  havent gotten to that yet, but it sounds like the next thing to do
23:17:08 <z> Is a Haskell kernel capable of being as fast as a C kernel, while being much more reliable than C.
23:17:18 <dons> z, the benefit is in the safety guarantees -- you can create a very reliable system. while being usefully fast
23:17:31 <wagle_> well, given that haskell compiles to C...
23:17:41 <z> usefully fast scares me
23:17:54 <z> I'm addicted to speed / an asm guy
23:18:18 <mikmik> wangle_ - next step will be to use ghc from sources. port does have a ghc 6.6 + gtk2hs that should support it, but it's "old"
23:18:23 <Tac-Tics> z: in most practical settings, the only speed that matters is in speed of development
23:18:40 <z> so are we talking 5 times slower
23:18:42 <Cin> z: what about your development speed?
23:18:43 <z> or 10% slower
23:18:50 <Tac-Tics> Haskell is faster than popular scripting languages, sometimes by several hundred fold
23:18:50 <dons> z, well, i'd say 1.5 - 4x
23:18:58 <z> My development speed is perfectly good
23:19:00 <dons> z, you'd use C or asm for critical paths
23:19:04 <z> I use Lua to generate ASM
23:19:10 <z> Lua is my assembler
23:19:27 <z> i have all high level constructs, it can redefine itself in any way
23:19:39 <dons> might be a good idea to read the papers on House and the haskell L4 kernel
23:20:27 <z> can pop off first-class function objects with asm inside
23:20:43 <dons> right.
23:20:54 <z> assemble static, or assemble from Lua vm into memory and execute that page as it runs
23:20:55 <dons> or C functions, which in turn have asm :)
23:21:08 <dons> lua's a lot slower, for what its worth. and more unsafe
23:21:20 <dons> so using haskell as glue would make sense. and haskell for device drivers and other fragile components
23:21:31 <dons> there's lots of research into this. but its not a light undertaking
23:21:55 <siti> having a haskell kernel would rock (that's usable ;))
23:21:59 <z> http://shootout.alioth.debian.org/gp4sandbox/benchmark.php?test=all&lang=ghc&lang2=luajit
23:21:59 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Extra!, http://tinyurl.com/35pc42
23:22:04 <dons> House is entirely useable.
23:22:04 <siti> I'm sure it would be so much easier to develop
23:22:07 <z> dons: The lua doesnt run the code.
23:22:11 <z> The asm runs.
23:22:14 <siti> I mean replace a main stream OS level
23:22:20 <siti> obviously that takes years
23:22:21 <dons> oh, you just have an edsl in lua
23:22:34 <siti> house is pretty cool though
23:22:43 <Tac-Tics> Lua in this context isn't the scripting language, is it?
23:23:10 <z> in this context it's the assembler
23:23:25 <Tac-Tics> ok. I was confused there for a second
23:23:42 <z> im just replying about development speed
23:23:46 <mikmik> z: you mean you use Lua scripts to build assembly code?
23:23:57 <z> Yes, at assemble time or runtime
23:24:15 <mikmik> makes sense. what's the target?
23:24:18 <z> x86
23:24:30 <z> 32bit atm
23:24:37 <z> however.
23:24:51 <z> Those are just my macros. Everythings built out of something built on top of something.
23:25:12 <z> As I learn new optimizations from Agner Fog, I go back into the ASM a few levels down and optimize in a new way
23:25:55 <z> The thing about GCC, is it's so complex, I can't understand it
23:26:08 <dolio> @where harpy
23:26:08 <lambdabot> http://uebb.cs.tu-berlin.de/harpy/
23:26:24 <dons> yeah, generating x86 asm from haskell is one thing you could try
23:26:27 <dons> using the harpy library
23:26:52 <z> cool dons
23:27:07 <z> See, now I think this is a more appropriate way to do a haskell kernel
23:27:39 <mikmik> z: are you familiar with HLA? the high-level assembly lang?
23:27:43 <z> why suffer the "almost fast" ness
23:27:52 <dons> because the reliability is so important
23:28:09 <z> mikmik: HLA is very limited, the macro syntax is not even a smidgeon flexible as Lua
23:28:13 <dons> the haskell kernels are aimed at very high assurance systems
23:28:21 <z> HLA cant do pretty much anything
23:28:27 <z> except what they hard coded it to do.
23:29:22 <mikmik> hmmm, are you using lua as a DSL?
23:29:30 <z> yea
23:30:11 <mikmik> Lua has some functional programming capabilities, familiar with those?
23:30:22 <z> at the lowest level of abstraction, its like f = asm(x, y)[[ mov eax, x ]]
23:30:45 <siti> dons: is a haskell OS actually getting used on a real world system?
23:32:06 <dons> siti, yeah
23:32:25 <siti> awesome
23:32:36 <dons> ?faq :)
23:32:36 <lambdabot> The answer is: Yes! Haskell can do that.
23:32:40 <siti> lol
23:32:41 <mikmik> according to the web site it has not been updated for a while now
23:33:32 <siti> what kind of function is the OS used for? obviously an area that needs a high level of assurance but what part?
23:35:20 * sm make install of the ghc binary for osx intel fails with:
23:35:22 <sm> Installing: /usr/local/lib/ghc-6.8.2/lib/OpenGL-2.2.1.1
23:35:22 <sm> installPackage: Error: Could not find module: Graphics.Rendering.OpenGL.GL.PixelRectangles.PixelStorage with any suffix: ["p_hi"]
23:36:41 <z> Do you guys use Haskell fonts which have special characters, such as a real lambda for \ ?
23:36:54 <z> Or even further, an IDE which would show <- as a connected arrow
23:37:03 <siti> lol that would be awesome
23:37:09 <siti> is that possible?
23:37:17 <z> why not
23:37:33 <dons> well, you can just use unicode keywords
23:38:22 <mikmik> sm: sorry, i misled you - i installed the binary version for mac osx intel from site
23:38:57 <sm> np mikmik, that's what I'm doing
23:38:58 <sarehu> z: I picked up some haskell-unicode procedure that does just that in Emacs... but I don't use it
23:39:18 <mikmik> sm: if that's the case, no opengl prob. there
23:41:10 <sm> I'm getting this error all the same
23:42:10 <wagle_> oh, so you cant bootstrap ghc 6.8?
23:42:38 <sm> right, installation of the binary package is failing
23:42:47 <sm> not bootstrap
23:43:20 <wagle_> yeah, i was apparently being silly, and trying to bootstrap it  (trying to build it right now)
23:43:43 <dolio> I think some people rig up emacs to change \ -> <- to display nice unicode stuff.
23:44:44 <wagle_> look at Thomas Hallgren's stuff..  i think i saw him doing stuff with unicode/etc
23:45:03 <sm> ./libraries/OpenGL/dist/build/Graphics/Rendering/OpenGL/GL/PixelRectangles/PixelStorage.p_hi0000644 seems to be the only one with such a numeric suffix.. perhaps that's why
23:45:42 <mikmik> are you make-ing as root?
23:46:28 <sm> sudo-ing
23:47:13 <sm> yep, removing the numeric suffix fixed installation
23:48:04 <mikmik> interesting, maybe the package was modified since i used it
23:48:56 <sm> ghc 6.8.2 installed! and the extralibs, it looks like
23:49:26 <wagle_> grats
23:50:08 <wagle_> how'd you compile it so fast?
23:50:28 <olsner> 64-core machine? :P
23:50:48 <sm> I didn't compile it, I used the binary package for osx
23:51:06 <goalieca> 64-core machine are slow to compile on
23:51:09 <goalieca> still held up by disk
23:51:11 <goalieca> :P
23:51:14 <goalieca> i've tried it myself
23:51:55 <sm> next, I guess I should download cabal-install manually from hackagedb and build
23:51:57 <olsner> shouldn't any 64-core machine have enough ram to not have to use the disks much?
23:52:14 <goalieca> can i download the files into ram?
23:52:29 <olsner> you could move things to a tmpfs, compile, then copy back the results when done
23:52:31 <goalieca> actually its quite fast. .but far from instant
23:52:36 <goalieca> not a linear speedup
23:53:22 <sm> ..and all it's dependencies.. :/
23:53:48 <goalieca> well some programs are like that
23:53:51 <goalieca> others aren't
23:58:00 <sm> well that was actually not bad.. just needed zlib and HTTP from hackage before cabal-install
23:58:05 <sm> cabal-install installed!
23:59:14 <sm> nice, nice.. a new high-watermark of haskell setup for me
