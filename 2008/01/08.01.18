00:00:22 <olsner_> I suppose it shouldn't be *too* hard to add support for tuples with left-out fields becoming functions, like (,c,) => \x y -> (x,c,y)
00:01:19 <jedbrown> I think that would be convenient.  Haskel'  ??
00:01:56 <tibbe> @seen dcoutts
00:01:56 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 11h 13m 17s ago.
00:02:11 <tibbe> dcoutts: ping
00:11:09 <quicksilver> jedbrown: the reason is far from compelling
00:11:19 <quicksilver> jedbrown: the "reason" is that extra commas are often typos.
00:13:02 <funktio> quicksilver: seriously?
00:17:25 <jedbrown> quicksilver: I don't think the lambda form is too ugly, but there are plenty of other places where single characters change the meaning.  But I'm much too new to Haskell for bickering over language changes, especially when they break consistency.
00:18:05 <lechglowiak> Hello. i'm having trouble with "type". How to be able to "show" some type?
00:18:48 <jedbrown> lechglowiak: The type must be an instance of `Show'.
00:18:50 <ac> lechglowiak: I think you just make sure all the types on the right derive Show
00:19:20 <quicksilver> funktio: that's the only reason as far as I know, yes.
00:19:47 <quicksilver> funktio: if you're writing a long tuple, one field per line (foo,\n bar,\n baz,\n)
00:19:47 <ac> lechglowiak: for example: type Thingy = Either String Int -- That should be showable
00:20:29 <quicksilver> funktio: it's easy to leave an extra comma on, an accidentally turn a syntax error into a section...
00:20:50 <quicksilver> funktio: I don't find that convincing, but I think that's it
00:27:08 <funktio> quicksilver: ok, thanks for the example; now the rule makes a bit more sense
00:31:43 <bbjwerner> Hi all
00:35:27 <sizur> hi bbjwerner
00:39:08 <quicksilver> I find Set.unions to be the wrong name
00:39:21 <quicksilver> important function, but 'unions' is a slightly wrong name
00:40:28 <sizur> quicksilver: why?
00:40:43 <sizur> seems consistent to me. 's' adds plurality
00:41:49 <sizur> although it seems to be redundant as one can simply fold with union
00:43:00 <sizur> you mean it can mislead to believe the function returns a list?
00:48:09 <quicksilver> sizur: it's only one union
00:48:12 <quicksilver> sizur: it's not many unions
00:48:35 <quicksilver> sizur: the mathematical concept 'union' is n-ary not binary.
00:48:57 <quicksilver> (you're right that it's redundant but that wasn't my point. redundancy can be convenient :)
00:49:43 <sizur> yeah, mathematically you'd want the domain to be a set of sets, but will that be convinient?
00:50:28 <quicksilver> I don't mind it being list of sets instead of set of sets
00:50:33 <quicksilver> that is convenient, as you say.
00:50:37 <quicksilver> I just mind the name :)
00:50:46 <quicksilver> it should just be called union, I guess
00:50:53 <quicksilver> and the binary one called union2
00:50:55 <quicksilver> I dunno :)
00:50:59 <Cale> I actually do mind that there's no set of sets union
00:51:13 <sizur> i'd like to have sets built into the language ;)
00:51:48 <Cale> It would be nice if the monad operations were represented, even if we can't make it an instance.
00:51:48 <quicksilver> sizur: why? lists aren't built into the language...
00:51:57 <sizur> currently lists play the role of sets, but lists are not sets
00:52:20 <sizur> quicksilver: lists are not part of haskell?
00:52:25 <osfameron> lists have built-in sugar
00:52:28 <quicksilver> Cale: that operation, which is a generalisation of 'concat' in a sense, is present in all Foldable Monoids
00:52:34 <quicksilver> lists has some very trivial built in sugar
00:52:41 <quicksilver> but they are really in no way special
00:52:46 <osfameron> and presumably a lot of optimization (which is pretty much the distinction between "builtin" and "library")
00:53:06 <quicksilver> I disagree.
00:53:23 <quicksilver> the distinction between 'builtin' and 'library' is, whether or not it's possible to implement them as a library :)
00:53:32 <quicksilver> it is possible to implement lists as a library.
00:53:34 <sjanssen> sizur: lists don't play the role of sets, lists play the role of loops ;)
00:53:36 <Cale> quicksilver: I suspect there's a way to take advantage of the tree structure and ordering to improve the efficiency of union when you already have all the sets inside a set.
00:53:45 <quicksilver> apart from some fairly unimportant syntax
00:53:53 <sizur> sjanssen: i just lists a lot like sets
00:53:59 <quicksilver> Cale: Yes, I'm sure that's true.
00:54:03 <sizur> for their simplicity
00:55:17 <Cale> What's the current instance of Ord for Set? Lexicographic after sorting?
00:56:14 <sizur> quicksilver: well, it's possible to implement integers using peano types, but we still have built-in integers. but i'm just being picky here
00:56:29 <Cale> It's interesting how Data.Set has toList and toAscList. I wonder if at some point they'll ever behave differently.
00:57:36 <Cale> Not to mention elems.
00:58:33 <jedbrown> sizur: However, every machine architecture use has built-in support to manipulate integers.
00:59:15 <dons> oh man, System.Random needs massive tuning
00:59:28 <dons> its 20x slower than it needs to be.
01:00:07 <glguy> dons: you ready for value fair '08?
01:00:19 <dons> i've got the mersenne-random haskell generating random 10000000 Int64s in 0.264s, while the C code does it in 0.245s
01:00:24 <dons> glguy: yeah i guess..
01:00:58 <glguy> What about long weekend?
01:01:00 <glguy> plans?
01:01:41 <dons> its a long weekend?
01:01:52 <dons> oh, for australia day? :)
01:02:33 <glguy> is it?
01:02:54 <glguy> weren't we supposed to bbq and play outside games?
01:03:06 <dons> so the new Random does 10M Int64s in 0.264s, old System.Random does 3.538 s :(
01:03:17 <dons> > 0.264 / 3.538 * 100
01:03:20 <lambdabot>  7.461842849067271
01:03:24 <jedbrown> dons: excellent!
01:03:26 <dons> glguy: its next weekend.
01:03:43 <dons> some i'm not just going to patch System.Random, i'll just replace it i think.
01:04:05 <glguy> is it a similar distribution? (/me doesn't know much about random number sources)
01:04:26 <dons> the mersenne one should be better.
01:04:49 <dons> this one, http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/index.html
01:05:21 <dons> ok. at least we know we can do a *lot* better. time for bed.
01:05:23 <dons> nytol
01:11:22 <sizur> nite dons
01:33:01 <jedbrown> Under what conditions would Complex be binary compatible with C99 complex (eqivalent to `typedef double complex[2]' with real part first)?
01:34:09 <roconnor> @src Complex
01:34:09 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
01:34:21 <oerjan> perhaps with unbox-strict-fields? </wild guess>
01:34:24 <Cale> I suppose you could try it and see if it is...
01:34:40 <Cale> Oh, it won't be binary compatible without a little work.
01:34:56 <jedbrown> Cale: what work?
01:35:08 <Cale> Well, defining an instance of Storable at least.
01:35:43 <jedbrown> Yes, but I want to reduce marshalling overhead.
01:35:45 <Cale> Even then, I'm not sure if the operations will produce exactly the same results, or if they'll differ in not-so-significant bits.
01:35:50 * jedbrown is thinking about FFTW bindings.
01:35:56 <Cale> ah
01:36:08 <oerjan> hm, unbox-strict-fields cannot work with polymorphic fields, can it?
01:36:22 <Cale> Well, it's easy to make a Complex value from two floating point values, and vice-versa.
01:37:00 <Cale> oerjan: unless it does some kind of strange specialisation of code, which I doubt.
01:38:23 <jedbrown> It's easy to write my own Complex class, specialized for double.  (FFTW needs to be compiled separately for different precision anyway.)
01:38:37 <jedbrown> *Complex datatype
01:39:32 <Cale> Well, you'll probably have to unpack the thing to do the marshalling anyway, so unboxing won't really help much, I don't think.
01:39:57 <jedbrown> Cale: I was thinking of basing it on StorableVector.
01:40:40 <quicksilver> sizur: right. We *do* have built-in integers.
01:40:44 <Cale> Hey, that's not in Hackage yet :)
01:40:47 <quicksilver> sizur: but we don't have built-in lists.
01:40:52 <Taejo> what's the difference between `let pat = val in x' and `case val of { pat -> x}'?
01:40:54 <quicksilver> sizur: the syntactic sugar for lists is front-end only
01:40:56 <Cale> sjanssen ^^ :)
01:41:01 <quicksilver> Taejo: strictness
01:41:12 <Taejo> why?
01:41:20 <quicksilver> sizur: in GHC Core a list is no different from any other ADT
01:41:30 <quicksilver> Taejo: because that's how it works :)
01:41:40 <quicksilver> case is how haskell programs actually make progress
01:41:44 <quicksilver> case actually checks a constructor
01:41:50 <quicksilver> and thus actually forces a thunk
01:42:04 <Cale> (of course, it only does so when it's actually evaluated)
01:42:06 <quicksilver> let is completely lazy. It does no work until you try to access a variable you bound with it.
01:42:13 <Taejo> ok
01:42:39 <oerjan> Taejo: unless you use one of the new-fangled ! patterns
01:42:48 <Taejo> ok
01:42:51 <Cale> The reason that pattern bindings are lazy is that the language spec actually says that they behave as if there's a ~ stuck onto the front of the pattern.
01:43:24 <koeien> oerjan: ! patterns?
01:43:25 <Cale> I doubt that ! patterns would do much in pattern bindings, but I might be wrong about that.
01:43:26 <koeien> how do they work?
01:43:54 <dcoutts_> tibbe: pong
01:44:02 <quicksilver> Taejo: this difference between case and let is not explained in enoguh detail in the common haskell tutorials, IMO
01:44:04 <Cale> koeien: They stick some seqs in at the top level of your function to make the marked parameters strict.
01:44:15 <quicksilver> Taejo: on the other hand, intuitively it doesn't matter much for total programs.
01:44:16 <oerjan> koeien: !p where p is a pattern has the same meaning but is strict
01:44:29 <Taejo> quicksilver: tutorials are for noobs :)
01:44:32 <tibbe> dcoutts_: I'm converting my web server to the monoid style flags and had some design decision and I was curious if you considered them too
01:44:41 <quicksilver> Taejo: it's sort of "not important" for basic denotational semantics.
01:44:42 <Cale> oerjan: hmm, what does that strictness mean in this case?
01:44:43 <jedbrown> Cale: Actually, it may be useful to have a multi-dimensional array format based on ForeignPtr so we can get O(1) conversion to StorableVector.  I think I'm not familiar enough with ByteArray# to know why we can't have O(1) StorableVector -> UArray.
01:44:47 <dcoutts_> tibbe: oh right
01:44:52 <quicksilver> it's important for operational semantics though.
01:44:53 <koeien> yeah like f !x !y = x
01:45:15 <Cale> koeien: then that's translated to  f x y = x `seq` y `seq` x
01:45:15 <koeien> then f 37 _|_ = _|_
01:45:22 <oerjan> Cale: hm now i'm not sure about pattern bindings, that was just my impression
01:45:26 <Taejo> the problem with tutorials, is that I read a bit of one, and then went and hacked a bit, and forgot which one I was reading, and then when I got to the next tutorial, I knew half the stuff in it, so it was boring
01:45:48 <koeien> ok but you can do that like f x (A !y) as well?
01:46:04 <Cale> oerjan: it seems like at the top level of the pattern in a pattern binding, it'll do nothing, but nested deeper, it might
01:46:26 <Cale> Like, if you had  (!x, !y) = foo bar
01:46:32 <tibbe> dcoutts_: namely that if you have an option for logFile that would be logFile :: Flag FilePath in the Flags record. However the default would probably be something like stderr which is a Handle. Would you convert your Flags record to a Config record and in the Config record have logHandle :: Handle instead? or would you just create the handle on the fly somewhere?
01:46:41 <Cale> vs. (x,y) = foo bar
01:46:43 <koeien> ok
01:46:46 <koeien> thanks
01:47:02 <tibbe> dcoutts_: I guess the deeper question is: Would you convert Flags to Config where config is more appropriate to use in the program?
01:47:13 <jedbrown> Taejo: I worked through the Gentle Intro while running on solar power without internet in Greenland so there was no problem of getting a different tutorial by accident.
01:47:16 <Cale> err...
01:47:17 <dcoutts_> tibbe: yes, I think so
01:47:21 <quicksilver> tibbe: yes, I would
01:47:21 <glguy> monoid style flags?
01:47:27 <oerjan> Cale: never mind
01:47:27 <Cale> I'm not even sure what that would mean, come to think of it.
01:47:35 <tibbe> dcoutts_: I looked through cabal and I couldn't see it being done there
01:47:38 <quicksilver> tibbe: I've had some unfocussed thoughts about convenient ways to build Config objects out of Flags-like-things
01:47:39 <tibbe> glguy: yes
01:47:42 * Cale goes off to do some experiments :)
01:47:43 <Taejo> jedbrown: are you a Greenlander? I'm guessing not, from the name
01:47:56 <quicksilver> or, in general, going from semi-structured data to 'strongly typed data'
01:47:58 <tibbe> quicksilver: me too
01:48:00 <dcoutts_> tibbe: well we do it when we convert the ConfigFlags to the LocalBuildInfo
01:48:18 <jedbrown> Taejo: Nope, but I study ice dynamics, so I was doing field work there.
01:48:28 <Cale> Prelude> let (!x,!y) = (undefined, 5) in y
01:48:28 <Cale> *** Exception: Prelude.undefined
01:48:28 <Cale> Prelude> let (x,y) = (undefined, 5) in y
01:48:28 <Cale> 5
01:48:30 <tibbe> dcoutts_: does LocalBuildInfo have all the info from ConfigFlags? in what file?
01:48:33 <Taejo> jedbrown: sounds interesting
01:48:45 <dcoutts_> tibbe: no, a subset and in a slightly different format
01:48:48 <jedbrown> Taejo: I'm from Alaska, but doing a PhD at ETH Zurich now.
01:48:51 <tibbe> dcoutts_: right
01:49:05 <tibbe> jedbrown: I'm in Zurich too :)
01:49:18 <vincenz> tibbe: !
01:49:23 <dcoutts_> tibbe: the .Configure module is the one that consumes the ConfigFlags and passes the info on to other places
01:49:27 <vincenz> tibbe: I will be joining you :)
01:49:35 <tibbe> vincenz: oh really?
01:49:37 <tibbe> :D
01:49:49 <dcoutts_> tibbe: and Simple.LocalBuildInfo has the other structure which gets used internally
01:50:01 <jedbrown> tibbe: and vincenz.  We'll be the new Portland!
01:50:05 <doserj> somebody should start a zurich hug...
01:50:09 <tibbe> hehe
01:50:21 <vincenz> zuhug
01:50:23 <Cale> Prelude> let !(x,y) = (1:y,0:x) in y
01:50:23 <Cale> <interactive>:1:4:
01:50:23 <Cale>     Recursive bang-pattern bindings aren't allowed:
01:50:23 <Cale>         { !(x, y) = ((GHC.Base.:) @ t_aWn 1 y, (GHC.Base.:) @ t_aWq 0 x) }
01:50:26 <Cale> haha
01:50:26 <Taejo> is Map.toAscList lazy? if I only take k elements, will it only do k*logn work?
01:51:17 <radetsky> is the conjure client actively developed, as far as anyone here knows?
01:51:48 <Cale> radetsky: I haven't heard any news for quite a while.
01:51:51 <jedbrown> Taejo: toAscList t   = foldr (\k x xs -> (k,x):xs) [] t -- looks lazy
01:53:03 <quicksilver> :t foldr (\k x xs -> (k,x):xs) []
01:53:06 <lambdabot>     Occurs check: cannot construct the infinite type:
01:53:06 <lambdabot>       t = [(a, t -> t1)]
01:53:06 <lambdabot>       Expected type: [(a, t -> t1)]
01:53:09 <jedbrown> Taejo: should by O(k) work though.
01:53:13 <quicksilver> jedbrown: looks badly typed to me :P
01:53:23 <Taejo> jedbrown: even beter
01:53:34 <Cale> Note that this is not the Prelude foldr
01:53:37 <jedbrown> quicksilver: toAscList :: Map k a -> [(k,a)] -- It's from the source.
01:53:47 <quicksilver> that's odd
01:54:12 <jedbrown> @src Map.foldr
01:54:13 <lambdabot> Source not found.
01:54:23 <Cale> the foldr it's referring to looks tail-recursive
01:54:34 <Cale> hmmm
01:54:50 <Cale> ah, but only to the first Tip
01:54:51 <quicksilver> oh
01:54:54 <quicksilver> that's harsh
01:54:57 <quicksilver> (local definition of foldr)
01:55:00 <quicksilver> I don't like that much
01:55:06 <quicksilver> no wonder I was confused!
01:55:19 <jedbrown> quicksilver: But we always import Map qualified.
01:55:22 <Cale> Well, it obviously can't be the Prelude foldr :)
01:55:35 <quicksilver> that's what I thought, which is why I type-checked it
01:55:41 <quicksilver> in case I had missed a trick ;)
01:55:52 <jedbrown> quicksilver: Local defs of lots of things (map, filter, ...)
01:56:35 <Cale> foldi looks like it would be better for lazy operations.
01:56:37 <quicksilver> I suspect it may do slightly more than O(k log n) work
01:56:48 <quicksilver> if I had to guess, I'd say worst case might be
01:56:50 <Cale> hmm
01:56:51 <quicksilver> O(k log n log k)
01:56:56 <Cale> oh, maybe it's okay
01:56:58 <quicksilver> it doesn't look to bad
01:57:03 <quicksilver> there certainly isn't an "n" factor
01:57:20 <jedbrown> quicksilver: It states that it uses O(n) to generate the whole list.
01:57:30 <Cale> It'll walk all the way down to the first Tip and return an application of f to some parameters including a continuation of the fold
01:57:46 * quicksilver nods
01:58:02 <quicksilver> OK, I revise my suggestion
01:58:09 <quicksilver> I think it's bounded above by O(k log n)
01:58:14 <quicksilver> tending to O(k) as k -> n
01:58:27 <jedbrown> quicksilver: That sounds right.
01:59:26 <quicksilver> It does log n work to get the first Tip, as Cale points out
01:59:36 <quicksilver> but that work gets amortized as you continue
02:14:37 <ac> how come there's no put for ByteString in Data.Binary?
02:14:47 <dcoutts_> I think there is
02:15:09 <ac> yeah you're right
02:28:38 <tibbe> dcoutts_: could you help me understand what happens in Command.commandParseArgs? I'm a bit confused.
02:28:53 <dcoutts_> ok
02:29:50 <dcoutts_> tibbe: so first of all we set up the set of options we're going to use
02:29:52 <tibbe> there's a Right f <- flags in accumFlags for example but I don't see where the Either comes into the picture
02:30:14 <dcoutts_> addCommonFlags :: ShowOrParseArgs
02:30:14 <dcoutts_>                -> [GetOpt.OptDescr a]
02:30:14 <dcoutts_>                -> [GetOpt.OptDescr (Either CommonFlag a)]
02:30:35 <tibbe> ok
02:30:37 <dcoutts_> tibbe: it's adding the common flags that gives us Either CommonFlag other
02:30:43 <tibbe> @paste
02:30:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:31:34 <tibbe> so you disregard the CommonFlags in one case?
02:31:37 <QplQyer> is it normal to get a Control Stack overflow when you forget the space before "show" when you do an "instance Show Type where" on the line before?  Cause I get this with hugs and ghci and it doesn't make sense to me to get that kind of error (instead of a bad syntax-error)?
02:31:45 <dcoutts_> tibbe: so we look at the getOpt result, the --list-options is favoured over all others
02:31:48 <dcoutts_> then --help
02:32:24 <dcoutts_> tibbe: then if none of those applied and there were no errors then we extract the ordinary flags
02:32:41 <tibbe> ok
02:32:43 <dcoutts_> tibbe: you mean this bit:
02:32:43 <dcoutts_> accumFlags flags = foldr (flip (.)) id [ f | Right f <- flags ]
02:33:09 <dcoutts_> so it's not so much that we're ignoring the commonflags here, but we've already looked for all the common flags already
02:33:21 <dcoutts_> and none of them were present
02:33:34 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5078
02:33:57 <tibbe> ^^
02:34:05 <tibbe> maybe it's easier if we start from the other end
02:34:32 <doserj> QplQyer: there are mutually recursive default definitions for show and showsPrec
02:34:41 <tibbe> once I have my Flag and Flags monoids, what's the absolutely simplest way of parsing argv
02:35:05 <doserj> QplQyer: so if you don't define on or the other, you get the behaviour you have seen
02:35:21 <tibbe> apologize for the cut-n-paste coding. I will fix it once I understand what needs to be done :)
02:35:45 <tibbe> dcoutts_: I think I will export another data type than flags from this module hence the module name
02:35:49 <QplQyer> ah right ok
02:35:56 <QplQyer> thanks
02:36:08 <dcoutts_> tibbe: so use GetOpt
02:36:21 <hpaste>  aaim annotated "Fast powerset" with "(no title)" at http://hpaste.org/5061#a1
02:36:25 <tibbe> dcoutts_: right, what's the type I want to use for getOpt though?
02:36:39 <tibbe> Flags a?
02:37:56 <dcoutts_> tibbe: I recommend [GetOpt.OptDescr (Flags -> Flags)]
02:38:11 <dcoutts_> tibbe: see the Simple.Setup module in Cabal
02:38:51 <tibbe> dcoutts_: OK, thanks. I'll try to figure it out using that
02:39:33 <dcoutts_> tibbe: see once you have that you can foldr them together
02:39:40 <tibbe> dcoutts_: the thing I don't understand is that if I do a Flags -> Flags what use do I have of the monoid property?
02:40:02 <tibbe> should I msum them together?
02:40:07 <tibbe> :t msum
02:40:10 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
02:40:14 <tibbe> hmm, maybe not
02:40:53 <dcoutts_> tibbe: you can do without, the reason we use monoid is to reflect the fact that some args accumulate as a list and some have a later-overrides-earlier property
02:41:06 <dcoutts_> tibbe: see the uses of mappend in the Command module
02:41:12 <tibbe> dcoutts_: OK
02:41:14 <dcoutts_> in noArg etc
02:41:21 <tibbe> dcoutts_: but it's not actually used in the parsing?
02:41:25 <tibbe> OK
02:41:35 <dcoutts_> tibbe: not in the parsing, but in how multiple options are combined
02:41:45 <tibbe> dcoutts_: OK
02:41:54 <tibbe> I'm still trying to navigate the code :)
02:42:01 <dcoutts_> tibbe: and in how different sets of flags are combined overriden, eg getting flags from a file or the command line
02:42:13 <tibbe> OK
02:42:51 <dcoutts_> tibbe: the cabal flags code goes one step further and makes it possible to get back the flags as strings
02:43:03 <dcoutts_> so it's a two way mapping
02:44:07 <dcoutts_> tibbe: you may find for your application that you don't need those features at all and can get away with a simpler style
02:44:26 <dcoutts_> tibbe: see the Setup module in the stable Cabal for example
02:44:49 <C-Keen> hm how do I build a datatype? I have data foo = foo {Field1, Field2} Now what's the name of it's constructor? I tried calling foo( 0, 0) for example
02:44:53 <dcoutts_> http://darcs.haskell.org/cabal-branches/cabal-1.2/Distribution/Simple/Setup.hs
02:44:55 <lambdabot> http://tinyurl.com/3adn6s
02:45:14 <dcoutts_> C-Keen: data types and their constructors must begin with an upper case char
02:45:37 <dcoutts_> data Foo = Foo Field1 Field2 -- assuming Field1 Field2 are names of existing types
02:45:41 <C-Keen> dcoutts_: yes, that's a typo above sorry
02:45:51 <C-Keen> and the latter is also true
02:45:57 <quicksilver> C-Keen: I think you want Foo 0 0
02:46:07 <quicksilver> C-Keen: (,) is special syntax for tuples
02:46:15 <quicksilver> data constructors don't use columns
02:47:30 <C-Keen> quicksilver: ah thanks
02:50:57 <Saul_> I'm trying out haskellDB, but I can't find the examples referred to on the website
02:51:07 <Saul_> Does anyone know where I can get them?
02:53:33 <tibbe> dcoutts_: you use functions like rewArgFlag and your own Option type so you don't have to write Flag v all the time?
02:54:05 <Cale> http://haskelldb.sourceforge.net/guide/ -- these examples?
02:54:05 <lambdabot> Title: The HaskellDB Guide to Hacking
02:55:05 <Cale> Saul_: or...
02:55:56 <Saul_> http://haskelldb.sourceforge.net/getting-started.html There is a reference here to test/dbspec.hs and some other files
02:55:56 <lambdabot> Title: HaskellDB - Getting Started
02:56:35 <quicksilver> C-Keen: I meant 'commas' of course, but I thnk you understood :)
02:56:38 <tibbe> dcoutts_: so the monoid property is used in noArg, reqArg et al :)
02:56:46 <C-Keen> quicksilver: yep, got it
02:57:10 <Cale> Saul_: hmm, there's also a comment that says that page needs to be updated for the latest version of HaskellDB
02:57:36 <Saul_> Yeah that's true
02:58:09 <gio123> Cale: could u please look rule 3 for 1 sec
02:58:15 <Saul_> But it would be nice if I at least knew what to import :)
02:58:22 <C-Keen> is there a nice way to fill a data structure from a Bytestring? I want to fill up Bools depending on whether a bit in a certain byte is set, but writing lines like foo = testBit (B.head byte) 2 over and over in the structure filling function seems to be wrong
02:58:31 <gio123> Cale: it looks exactly same as rule 2, since lambda < something is true always
02:59:01 <Cale> Saul_: there are links to presumably up-to-date documentation from http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskelldb
02:59:02 <lambdabot> http://tinyurl.com/3dwgf4
02:59:10 <Cale> (along with all the module names)
02:59:18 <gio123> Cale: module unfload third and second rule looks completly same is not?
02:59:30 <Cale> gio123: hang on...
02:59:30 <Saul_> thanks, I'll try that one
03:00:03 <Cale> gio123: no it's not.
03:00:15 <gio123> why
03:00:16 <gio123> ?
03:00:28 <gio123> look page 122
03:00:31 <Cale> gio123: lambda is less than or equal to a regular expression if and only if the empty string is matched by that expression.
03:01:31 <tibbe> dcoutts_: Simple.Command and Simple.Setup could use some comments :(
03:01:38 <quicksilver> C-Keen: Data.Binary may be relevant.
03:01:51 <gio123> Cale: then what page 122 state? lambda < s is trivialy true
03:01:57 <quicksilver> although I don't think the built in binary instance for bool is single-bit
03:02:50 <Cale> gio123: lambda <= s_1 is trivially true.
03:03:00 <Cale> gio123: What does s_1 stand for?
03:03:31 <gio123> Cale: ah sorry, I didn read s_1
03:03:38 <Cale> (hint: it stands for a set of regular expressions that all match the empty string :)
03:03:48 <gio123> s_1 means reg expresion is in the language
03:03:53 <gio123> sure
03:03:54 <gio123> yes
03:04:01 <gio123> right as state in signature
03:04:03 <gio123> thanks
03:04:04 <gio123> :)
03:07:42 <ac> Data.Binary is a little awkward when there are multiple ways to encode a data structure
03:11:47 <Cale> ac: Typeclasses are a little awkward whenever there are multiple ways to do anything, but you can help things along a it with newtypes.
03:11:52 <Cale> bit*
03:13:05 <Cale> That way, you only have to tag your data with the newtype constructor before you put, or pattern match differently for a get.
03:13:44 <ac> I don't understand that
03:13:53 <Cale> okay
03:14:11 <Cale> So you have two instances of Binary which you want to write for the same datatype, right?
03:14:27 <ac> no
03:14:30 <Cale> no?
03:14:44 <Cale> That's what I took from "multiple ways to encode"
03:14:49 <ac> I have a particular type that can be encoded in multiple ways. Specifically, it depends on the bit depth
03:15:32 <ac> so I wrote a function called encodeFoo of type "Int -> Foo -> ByteString"
03:16:13 <Cale> okay...
03:16:21 <ac> I could wrap Foo in to a new type of "Bar Int Foo"
03:16:42 <ac> that's probably what I should do. But the bit depth is already in another part, so it would be duplicating it
03:17:16 <Cale> Are you writing an instance of Binary using encodeFoo?
03:17:36 <ac> I can't because encodeFoo takes an extra argument
03:17:43 <Cale> Well, right
03:17:59 <Cale> Is there a finite list of valid values for that argument?
03:18:20 <ac> yeah actually. There are usually 2, but in some cases 5
03:18:36 <Cale> I suppose you could still just write functions that operate in the Put and Get monads.
03:19:21 <Cale> er, I suppose that doesn't really help with encodeFile and decodeFile
03:19:49 <Cale> But you do need to know that information at some point, and the Binary instance for your larger datatype would be able to use those functions.
03:20:13 <ac> there's another parameter too actually: compression level
03:20:30 <ac> I guess I should just create a record with that stuff in it, even if it's duplicated in other types
03:20:51 <ac> Then I could easily make it an instance of Binary
03:21:02 <Cale> Or just handle it for the Binary instance of the larger datastructure which does happen to contain that data.
03:21:10 <ac> yeah exactly
03:21:54 <ac> this is a very interesting project (to me :-)
03:22:03 <Cale> which project is it?
03:22:17 <ac> I'm implementing the PNG spec in pure Haskell
03:22:44 <ac> I'm hoping I'll have a validly encoded PNG image before I go to sleep :-P
03:24:35 <quicksilver> Cale: you're right, of course
03:24:40 <ac> The real can of worms for me is the definition of the input image. I want it to be as flexible as possible, but I just can't get the types right. Right now I'm writing it to take a "Array (Int,Int) (Double,Double,Double)" and I'm hoping that I'll figure out how to generalize it later
03:24:54 <quicksilver> Cale: but IMO when there is 'more than one way to do it' type classes are often just the wrong answer.
03:25:44 <Cale> quicksilver: yeah, though it would perhaps be interesting to be able to write instances inside lets ;)
03:25:49 <quicksilver> it would
03:25:54 <quicksilver> but there are problems with that
03:26:02 <quicksilver> and manual dictionary passing is not hard
03:26:06 <Cale> Separate compilation :)
03:26:06 <quicksilver> and it's not bad design either :)
03:26:29 <quicksilver> the only problem is when you want ot use a library which was designed for typeclass use
03:26:36 <quicksilver> and you want to use it in a manual dict-passing way
03:26:50 <quicksilver> although you can finess that with a custom type which stores the dictionary
03:26:59 <quicksilver> Cale: the problems go a bit deeper than that, actually
03:27:21 <quicksilver> Cale: imagine a Data.Map created using a local Ord instance and then returned from that scope
03:27:31 <quicksilver> Cale: and then 'inserted' using a different (e.g. the global) Ord instance.
03:27:49 <quicksilver> or a ByteString created using a local Binary instance and then decoded using the global one.
03:28:25 <Cale> heh
03:29:23 <ivanm> is there a haskell parser (written in Haskell, obviously!) that I can use that would let me get something like [ (Function,[Function])] (where Function is probably an alias for String)?
03:29:27 <Cale> Yeah, there are some encapsulation issues there :)
03:29:48 <Cale> ivanm: like a dependency structure?
03:29:51 <ivanm> i.e. I want to be able to parse a source file and get a list of all functions along with all other functions that they use, preferably in a way that would work over multiple files
03:29:53 <tibbe> I need a function String -> Maybe Int
03:29:54 <ivanm> Cale: yeah...
03:30:05 <tibbe> read doesn't do the job
03:30:13 <koeien> tibbe: no it is a pain :(
03:30:14 <ac> tibbe: reads
03:30:15 <Cale> ivanm: Well, you might start with Language.Haskell
03:30:18 <koeien> tibbe: look up reads
03:30:21 <ivanm> Cale: *nod*
03:30:23 <Cale> ivanm: or else the GHC API.
03:31:18 <ivanm> would this be a separate library or something that comes with ghc (6.8.2) ?
03:31:21 <koeien> tibbe: f x = case reads x of [(y, "")] -> Just y ; _ -> Nothing
03:31:23 <Cale> wow, there are so many things in Hackage now that I haven't even looked at most of it.
03:31:42 <tibbe> koeien: thanks
03:31:46 <ivanm> Cale: heh
03:32:02 <koeien> tibbe: this does not parse "37saf"
03:32:18 <int-e> > map (reads :: ReadS Int) ["123", "123a", "abc"]
03:32:19 <koeien> tibbe: if you want to parse that as Just 37, replace the "" with _
03:32:20 <lambdabot>  [[(123,"")],[(123,"a")],[]]
03:32:32 <gio123> Cale: can u look pm for a minute please
03:32:35 <C-Keen> quicksilver: Data.Binary? where can I find this? http://haskell.org/ghc/docs/latest/html/libraries/index.html has no listing of it
03:32:45 <tibbe> koeien: right, thanks
03:33:41 <ac> > (\s -> case reads s :: [(Int,String)] of (i,""):[] -> Just i; _ -> Nothing) "42"
03:33:41 <lambdabot>  Just 42
03:33:50 <int-e> @where binary
03:33:50 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
03:33:53 <ac> there's got to be a better way to specify that type
03:34:16 <Saul_> Cale: Those libraries are pretty handy to have, but I'm still not sure how to define my main function and such (in haskellDB), do you have some info on that?
03:34:26 <ac> tibbe: there's a version that returns Nothing unless it's exactly one number
03:34:41 <tibbe> ac: you mean one digit?
03:34:57 <quicksilver> :t (\s -> case reads s of [(x,"")] -> Just x; _ -> Nothing)
03:34:57 <lambdabot> forall a. (Read a) => String -> Maybe a
03:34:58 <koeien> tibbe: it is equivalent to my version
03:34:58 <ac> tibbe: no, I mean one Int. It correctly parsed "42"
03:35:04 <Saul_> koeien: Jochem?
03:35:06 <quicksilver> ^^ this is a useful function IMO
03:35:33 <koeien> quicksilver: yeah it is more useful than read itself imo
03:35:43 <tibbe> ac: oh I see, thanks
03:35:46 <quicksilver> often, yes
03:35:59 <ac> tibbe: just remove that type signature (as quicksilver did) and it's more general
03:36:41 <tibbe> ac: right
03:36:49 <ac> > (\s -> case reads s of (i,""):[] -> Just i; _ -> Nothing) "3.14159" :: Double
03:36:49 <lambdabot>  Couldn't match expected type `Double'
03:36:52 <Cale> Saul_: I suppose you're meant to use something like hdbcConnect from the haskelldb-hdbc package.
03:36:57 <quicksilver> I have equivelents for most of my parsing stuff
03:37:02 <quicksilver> e.g. if pFoo parses foo then
03:37:07 <Cale> Saul_: I've never actually used that library myself.
03:37:07 <koeien> ac: Maybe Double
03:37:13 <ac> > (\s -> case reads s of (i,""):[] -> Just i; _ -> Nothing) "3.14159" :: Maybe Double
03:37:14 <lambdabot>  Just 3.14159
03:37:23 <quicksilver> easy pFood parses foo only if there is nothing left to parse
03:38:31 <Saul_> Cale: Okay I'll try that
03:42:38 <hpaste>  aaim annotated "Fast powerset" with "with less where's" at http://hpaste.org/5061#a2
03:47:32 <ac> very nice to have BE and LE versions of putWordX functions
03:52:31 <quicksilver> ac: there are
03:52:36 <quicksilver> ac: or is that what you're saying?
03:53:01 <Saul_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HDBC-postgresql-1.0.1.0 This package doesn't compile :S
03:53:03 <lambdabot> http://tinyurl.com/2gyv7q
03:54:12 <Saul_> Wait a minute, my webserver uses mysql anyway :)
03:56:08 <dcoutts> tibbe: we added our own option type because we wanted a two way mapping [String] <-> Flags and getOpt is only designed for one direction
03:57:52 <ac> quicksilver: yeah, I was saying I appreciate them
03:58:28 <Saul_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskelldb-hsql-0.10 What the hell, this one doesn't compile either
03:58:30 <lambdabot> http://tinyurl.com/ynqhwg
03:59:04 <Saul_> I give up (for now)
03:59:57 <Cale> Saul_: what's the error?
04:00:06 <koeien> Saul_: what's the error message you get?
04:00:09 <Cale> Saul_: lots of packages are broken in a very trivial way
04:00:24 <Cale> Saul_: (just minor edits to the cabal file are needed to compile them with 6.8)
04:00:31 <Saul_> A bunch of instances are missing
04:00:41 <koeien> Saul_: do you have all the deps?
04:00:42 <Cale> example?
04:00:51 <koeien> i suggest taking the time to install cabal :)
04:01:02 <Saul_>     No instance for (SqlBind (Maybe Double))
04:01:03 <Saul_>       arising from use of `getFieldValue'
04:01:03 <Saul_>       at Database/HaskellDB/HSQL.hs:202:23-35
04:01:03 <Saul_>     Possible fix:
04:01:03 <Saul_>       add an instance declaration for (SqlBind (Maybe Double))
04:01:03 <Saul_>     In the `getDouble' field of a record
04:01:05 <Saul_>     In the expression:
04:01:07 <Saul_>         GetInstances
04:01:09 <Saul_>             {getString = getFieldValue,
04:01:11 <Saul_>              getInt = getFieldValue,
04:01:12 <Cale> okay
04:01:13 <Saul_>              getInteger = getFieldValue,
04:01:15 <Saul_>              getDouble = getFieldValue,
04:01:16 <koeien> use pastebin, pleaseeeeeeeeeeee
04:01:19 <Saul_>              getBool = getFieldValue,
04:01:21 <Saul_>              getCalendarTime = hsqlGetCalendarTime}
04:01:23 <Saul_>     In the definition of `hsqlGetInstances':
04:01:25 <Cale> koeien: you mean hpaste :)
04:01:25 <Saul_>         hsqlGetInstances = GetInstances
04:01:27 <Saul_>                                {getString = getFieldValue,
04:01:29 <Saul_>                                 getInt = getFieldValue,
04:01:29 <koeien> ehm yeah
04:01:30 <koeien> :)
04:01:31 <Saul_>                                 getInteger = getFieldValue,
04:01:33 <Saul_>                                 getDouble = getFieldValue,
04:01:35 <Saul_>                                 getBool = getFieldValue,
04:01:35 <Cale> uh...
04:01:35 <ivanm> Cale: _anything_!
04:01:37 <Saul_>                                 getCalendarTime = hsqlGetCalendarTime}
04:01:39 <Saul_> That is just one of a bunch of errors
04:01:42 <dcoutts> Saul_: stop now please :-)
04:01:50 <ibid> Saul_: NO LONG PASTES TO THE CHANNEL!
04:01:52 <Cale> Saul_: you could have just pasted the first line of that
04:02:06 <Cale> :)
04:02:17 <Saul_> Sorry :(
04:03:11 <koeien> Saul_: i have installed some bindings from the debian repositories
04:03:13 <Saul_> anyway I have all dependencies and the newest version of Cabal
04:03:25 <Saul_> So did I
04:03:33 <Saul_> Well ubuntu
04:04:11 <Cale> Saul_: so, you're on ghc 6.6?
04:04:22 <koeien> there is no libghc6-haskelldb-dev thingy in ubuntu?
04:05:00 <Saul_> I have 6.6.1-2ubuntu2
04:05:16 <Saul_> and there is, but it requires <= ghc 6.2
04:05:28 <koeien> strange
04:06:30 <koeien> so `cabal install haskelldb` causes these errors?
04:06:52 <Saul_> No, haskelldb is already installed
04:07:14 <Saul_> But I need hsql-mysql to get it to work with an actual db
04:07:28 <Saul_> and hsql doesn't compile properly
04:07:49 <ac> lol, what does "snoc" stand for in ByteString?
04:07:58 <koeien> ac: reverse cons ?
04:08:06 <dcoutts> > reverse "cons"
04:08:08 <lambdabot>  "snoc"
04:08:16 <bgeron> lol
04:08:34 <Saul_> I'm thinking it adds characters to the end of a bytestring
04:08:43 <ac> Saul_: you're correct
04:08:50 <dcoutts> Saul_: the hsql on hackage is not maintained, there are patches around to fix it
04:09:15 <Saul_> dcoutts: Ok I'll look for those then
04:09:22 <dcoutts> Saul_: eg gentoo's hsql packages work with ghc-6.8
04:09:35 <koeien> Saul_: and debian's work with ghc-6.6
04:09:48 <dcoutts> we need some mechanism in hackage for fixing unmaintained packages or marking them deprecated
04:10:31 <dcoutts> has anyone tried contacting the hsql maintainers? if so we should just fix them and upload new versions
04:11:07 <Saul_> Oh wait a minute, haskelldb-hsql-0.10 was the one that didn't work, I already have hsql from apt-get
04:11:47 <koeien> :(
04:11:48 <Saul_> So I'm not sure if hsql itself works or not
04:12:02 <Cale> http://uk.youtube.com/watch?v=kiCZiSA2W3Q -- new Catsters video!
04:12:03 <lambdabot> Title: YouTube - Double categories
04:12:14 <koeien> import Database.HSQL.MySQL or something and try
04:17:21 <Saul_> koeien: That works fine
04:17:48 <Saul_> Anyway I have other stuff to do today, I'll pick this up later
04:20:00 <ac> what's the deal with not being able to match expected type Data.ByteString.Internal.ByteString with Data.ByteString.Lazy.Char8? I'm not referring to the first type anywhere, AFAIK.
04:20:26 <dcoutts> ac: because they're really different types with different representations
04:21:01 <dcoutts> Data.ByteString[.Char8] export one ByteString type, Data.ByteString.Lazy[.Char8] export a different ByteString type
04:21:09 <ac> one's lazy and one's not. But the point is, I'm pretty sure ALL my ByteStrings are lazy.
04:21:28 <dcoutts> not if you're talking about Data.ByteString.Internal.ByteString
04:21:38 <dcoutts> since that's where the strict bytestring type is defined
04:21:46 <dcoutts> it's re-exported through Data.ByteString[.Char8]
04:22:41 <ac> something must be returning that type, I'm just not realizing what
04:22:45 <dcoutts> ac: right
04:23:14 <ac> doesn't everything in Data.Binary deal with lazy ones?
04:24:02 <dcoutts> ac: yes, except getByteString (there's also getLazyByteString)
04:26:47 <hpaste>  bgeron pasted "question" at http://hpaste.org/5079
04:26:56 <bgeron> hi, can anyone help me with this?
04:27:25 <bgeron> adding (Eq a) => .. in the type declaration of commute silences this error, but I get in trouble in the definition of >>=
04:27:44 <quicksilver> yes
04:27:46 <quicksilver> that's a bummer
04:27:53 <quicksilver> it's very hard to make monads out of things with constraints
04:28:01 <Cale> bgeron: Which GHC are you using?
04:28:04 <bgeron> ah :(
04:28:17 <Cale> You might be able to solve this one if you're using 6.8 :)
04:28:19 <bgeron> 6.4.2, no extensions
04:28:22 <Cale> oh
04:28:23 <bgeron> nice, thanks!
04:28:26 <Cale> Then no, you can't :)
04:28:35 <Cale> With 6.8.2, you could do:
04:28:44 <Cale> data Weighted a where
04:29:04 <Cale>    Weighted :: (Eq a) => [(a,Weight)] -> Weighted a
04:29:26 <Cale> and this would cause an Eq dictionary to be stored in with each Weighted value.
04:29:53 <bgeron> hmm okay
04:29:56 <bgeron> thanks for the tip
04:30:04 <quicksilver> Cale: you can do that in 6.6
04:30:08 <Cale> Thus relieving you of the need for Eq a constraints on functions using values of type Weighted a
04:30:09 <byorgey> bgeron: see http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros for some discussion of this issue
04:30:10 <lambdabot> Title: How to make Data.Set a monad, http://tinyurl.com/22rhsc
04:30:20 <Cale> quicksilver: I don't think it works correctly in 6.6 though.
04:30:32 <quicksilver> Cale: hmm. I think it does :)
04:30:39 <Cale> Okay, try it out :)
04:30:49 <quicksilver> bgeron: you could bundle the dictionary yourself
04:30:58 <Cale> bgeron: Where did you get 6.4.2 from, by the way?
04:31:06 <bgeron> gentoo
04:31:08 <quicksilver> data Weighted a = Weighted (a -> a -> Bool) [(a,Weight)]
04:31:08 <Cale> bgeron: That's pretty old at this point :)
04:31:18 <ivanm> bgeron: why 6.4.2? 6.6.1 is stable...
04:31:30 <quicksilver> of course, you risk people using incompatible dictionaries in principle
04:31:31 <bgeron> didn't upgrade in a while
04:31:44 <quicksilver> but in practice you can stop that by not exporting the constructor
04:31:45 <ivanm> heh... must have been around a year for your "while"
04:32:11 <bgeron> my binary was installed september 20th
04:32:39 <ac> ah, there's putByteString and putLazyByteString
04:32:59 <Cale> There's a Haskell overlay for gentoo, whatever that means :)
04:33:08 <ivanm> bgeron: well, we've got 6.6.1 stable and 6.8.2 unstable in the official tree
04:33:22 <ivanm> unless you're using some strange arch...
04:33:27 <bgeron> nope, x86
04:33:44 <gio123> Cale: heh it works i think
04:33:44 <ivanm> well, then run: USE=binary emerge ghc
04:33:45 <gio123> :)
04:33:58 <ivanm> Cale: an overlay is like the extra "repositories" in other distros
04:34:15 <Cale> ivanm: I figured it was something like that :)
04:34:40 <bgeron> why USE=binary, can't it compile itself?
04:34:51 <Cale> bgeron: yes, but that's a massive waste of time
04:34:52 <ivanm> bgeron: it can, but USE=binary will use a pre-built binary
04:34:53 <Beelsebob> it'll take all day
04:35:00 <ivanm> Beelsebob: takes me around an hour...
04:35:13 <ivanm> bgeron: it's a gentoo-built binary (probably built by either dcoutts or myself)
04:35:17 <Beelsebob> o.O ghc compiling still takes me several hours even on a Core2Duo
04:35:25 <ivanm> :o
04:35:42 <ivanm> I've only got a 1.6 GHz Bothan-core Pentium M
04:35:49 <Cale> Unless you're hacking on GHC, don't compile GHC.
04:35:52 <Beelsebob> (assuming building from scratch, and hence having to build it 4 times)
04:36:06 <Cale> I think that's pretty much a general rule to follow :)
04:36:11 <Beelsebob> Cale: only time I've ever tried to build it is when no one has yet released a binary for my platform
04:36:17 <ivanm> heh
04:36:23 <ivanm> why 4 times?
04:36:33 <Cale> ivanm: It builds in stages.
04:36:39 <ivanm> ahhh
04:36:42 <Beelsebob> once to get v5, once to get v6, once to get v6 optimised and once to check that it still produces the same binary
04:38:13 <bgeron> is v5 built by ghc or by something else?
04:38:35 <Beelsebob> not if you're bootstrapping
04:38:47 <Beelsebob> there's a C version (I think compiled into C from haskell IIRC)
04:39:00 <Beelsebob> there isn't a C version of v6 though, so you need to go via v5
04:40:55 <ivanm> is it possible to use say nhc to bootstrap ghc?
04:41:06 <ivanm> since nhc has C sources IIRC...
04:41:11 <quicksilver> ghc on my iBook G4 took 8 hours
04:41:11 <quicksilver> IIRC
04:41:30 <quicksilver> GHC isn't written in haskell98
04:41:37 <quicksilver> parts of it are in C--
04:41:41 <ivanm> oh, yeah
04:41:42 <quicksilver> and a few pieces in C
04:42:08 <quicksilver> in principle you could imagine the possibility of doing it with nhc, a C-- compiler and gcc
04:42:16 <ivanm> *nod*
04:42:18 <quicksilver> but I fear it relies on its own RTS in places ?
04:42:19 <ivanm> btw, where can I find the ghc API docs?
04:43:47 <Beelsebob> quicksilver: blimeh, that's odd, because it takes my MacBook roughly that long... on the other hand, my MacBook compiles Hat about 10 times faster than my old iBook did
04:43:49 <Beelsebob> weird
04:44:52 <quicksilver> Beelsebob: I was talking about ghc 6.6 using the macports bootstrap
04:44:57 <quicksilver> Beelsebob: if that removes any variables
04:45:15 <quicksilver> ivanm: I'm not sure if there are proper docs
04:45:23 <quicksilver> ivanm: there are useful bits and pieces in the GHC trac
04:45:27 <quicksilver> (the wiki part)
04:46:20 <ivanm> quicksilver: *nod*, thanks
04:51:02 <phlpp> hi all
04:51:14 <tibbe> dcoutts: interesting, why did you want a two way mapping?
04:51:44 <dcoutts> tibbe: cabal-install has to be able to construct Setup command lines
04:52:19 <tibbe> dcoutts: oh, so cabal-install communicates with cabal via the command line?
04:52:36 <dcoutts> tibbe: sometimes yes, when the package uses a custom Setup.hs script
04:52:51 <dcoutts> tibbe: and being able to combine sets of flags together implies the ability to have an empty rather than a default set of flags
04:53:05 <gio123> Cale: are u there?
04:53:12 <tibbe> dcoutts: didn't get the last part
04:53:18 <dcoutts> tibbe: so the traditional method of starting with defaults and then layering options on top does not work for us
04:53:43 <tibbe> dcoutts: why?
04:53:46 <dcoutts> tibbe: because we need to get some options from a config file, some from the command line and then combine them
04:53:54 <jedbrown> Is there a compiler for ARM9?  AIUI, GHC is being ported, but it seems awfully heavy for a system with 32 MiB of memory.  Are there better options?
04:54:12 <dcoutts> tibbe: if we could not distinguish an absent flag from a default value then we could not do that
04:54:14 <tibbe> dcoutts: so defaultFlags mappend commandLineFlags append fileFlags?
04:54:31 <dcoutts> tibbe: yes (though different order)
04:54:37 <tibbe> dcoutts: or config file first if it should be overridden by command line
04:54:41 <dcoutts> right
04:54:50 <tibbe> still don't get it, sorry :)
04:55:22 <dcoutts> defaults `mappend` configFileFlags `mappend` commandLine
04:55:24 <tibbe> that's layering flags on top of defaults, no?
04:55:47 <dcoutts> ok, so it depends where we're sending the info
04:55:50 <tibbe> dcoutts: "so the traditional method of starting with defaults and then layering options on top does not work for us"
04:55:54 <tibbe> ok
04:55:57 <dcoutts> we actually maintain it as just configFileFlags `mappend` commandLine
04:56:07 <dcoutts> and then only apply defaults when needed
04:56:27 * quicksilver doesn't see why defaults `mappend` configFileFlags `mappend` commandLine wouldn't work for dcoutts 
04:56:29 <dcoutts> so for example when calling Setup.hs we do not apply it to the defaults, we pass only the ones that are non-default
04:56:47 <quicksilver> strange
04:56:52 <quicksilver> I wonder why you do it that way?
04:57:02 <quicksilver> applying to defaults makes more sense to me intuitively
04:57:09 <dcoutts> quicksilver: we'd not be able to work with packages that need older versions of the Cabal library
04:57:27 <dcoutts> since their Setup.hs would not grok the extra flags we were passing
04:57:36 <quicksilver> oh
04:57:40 <quicksilver> that's a bit specialised
04:57:40 <dcoutts> it allows a good deal of backwards compatability this way
04:57:57 <quicksilver> I'd apply to defaults but have a "stripForV10Compat" function
04:57:58 <quicksilver> ;)
04:58:03 <tibbe> dcoutts: so a defaults would add extra flags
04:58:10 <dcoutts> quicksilver: this is more regular
04:58:10 <quicksilver> in general I find the defaults approach more elegant, anyhow
04:58:34 <dcoutts> tibbe: there are defaults for quite a few flags, though not all.
04:58:40 <tibbe> ok
04:58:52 <dcoutts> quicksilver: it's sufficient much of the time, but not for cabal/cabal-install
04:59:21 <dcoutts> quicksilver: cabal used the defaults system up until this dev cycle when I discovered it was not enough to support cabal-install sanely
05:00:50 <quicksilver> dcoutts: Ah, ok.
05:01:03 <quicksilver> dcoutts: I must admit I don't understand but I think I don't have brain space to devote to it at the moment.
05:01:16 <quicksilver> dcoutts: it suffices that I believe you when you say this is best :)
05:02:01 <eu-prleu-peupeu> hello
05:02:11 <eu-prleu-peupeu> what future do you think haskell will have in computer games ?
05:02:26 <dcoutts> quicksilver, tibbe: I think the bit about using defaults or not is orthogonal actually, the main point is that if you are getting flags/config from multiple sources then it is essential that for each flag you be able to distinguish the default value from an unset value
05:02:36 <dcoutts> tibbe: and it sounds to me like you might not need that
05:02:50 <matthew-_> eu-prleu-peupeu: it /is/ the future
05:03:09 <matthew-_> and not just for computer games either
05:03:43 <ivanm> the future is now!
05:03:48 <tibbe> dcoutts: right, I don't see the need right now at least
05:03:59 <matthew-_> medicine, politics, public transport, agriculture, space travel, domestic cleaning etc. All can benefit extensively from Haskell
05:04:29 <eu-prleu-peupeu> hehehe
05:04:37 <eu-prleu-peupeu> and football ?
05:04:44 <quicksilver> don't forget toothbrushholesmanship
05:04:49 <eu-prleu-peupeu> if haskell can have a share of football then it surely is the future
05:04:53 <roconnor> @quote politics
05:04:53 <lambdabot> No quotes match. I feel much better now.
05:05:02 <quicksilver> eu-prleu-peupeu: I find haskell to be a very convenient language for games programmer. but I'm not a professional games programmer.
05:05:07 <ibid> @quote foo
05:05:08 <lambdabot> lament says: Bullies at school used to tease little Huet: "Hey fool, your zipper's undone and the monad's sticking out!"
05:05:18 <roconnor> @remember matthew-_ medicine, politics, public transport, agriculture, space travel, domestic cleaning etc. All can benefit extensively from Haskell
05:05:19 <lambdabot> Good to know.
05:05:21 <quicksilver> There are surely some soft-realtime problems to solve before you can use it for cutting-edge stuff.
05:05:34 <ibid> @quote foobar
05:05:35 <lambdabot> No quotes match. Just try something else.
05:05:37 <ibid> h
05:05:55 <matthew-_> no no. Haskell is completely disjoint from football. Rugby it may have something to do with. But the professional acting that is Football is really anti-haskell
05:06:19 <eu-prleu-peupeu> football as in soccer :)
05:06:19 <ibid> football or football? :)
05:06:54 * ibid never understood where a game where the ball is mostly carried is called football
05:07:12 <matthew-_> oh I see. I didn't realise we were scraping the barrel that low of "sports"
05:07:21 <eu-prleu-peupeu> heheh
05:07:36 <eu-prleu-peupeu> ibid: its "american logic" applied to sports
05:07:39 <matthew-_> ibid: are you meaning "Rugby Football" or "American Poser Football"?
05:08:13 <eu-prleu-peupeu> heheh
05:08:38 <ibid> matthew-_: either :) i don't know rugby though
05:09:18 <matthew-_> ibid: well, the standard saying is "Rugby is a game for thugs played by gentlement, whereas Football is a game for gentlemen played by thugs"
05:09:33 <ibid> matthew-_: and football here is which one? :)
05:10:20 <eu-prleu-peupeu> do you guys know the rugby team called "os lobos" ?
05:10:25 <eu-prleu-peupeu> its the best team ever ! :D
05:10:26 <matthew-_> english
05:11:08 <ibid> matthew-_: i prefer downhilll anyway :)
05:11:17 <eu-prleu-peupeu> they are almost as good as haskell
05:11:22 <eu-prleu-peupeu> ...almost :)
05:11:33 <ibid> haskell is a rugby team?
05:11:40 <ibid> how many games have they won?
05:11:41 <ibid> :)
05:11:58 <eu-prleu-peupeu> i think they lost all of the games on the world championship
05:12:10 <eu-prleu-peupeu> but they were the first amateur team to go to the world championship :)
05:13:13 <ibid> the team called haskell? :)
05:13:57 <eu-prleu-peupeu> hehehe
05:13:58 <eu-prleu-peupeu> no
05:15:00 <matthew-_> ibid: it's not surprising -  the Haskell team would consist of a load of skinny PhD students trying to type-check the rules of the game
05:15:10 <ibid> heh
05:15:32 <matthew-_> ibid: they would also be cowering on the pitch as a result of being outside during day-time
05:16:01 <cu3edweb> Hello
05:16:02 <eu-prleu-peupeu> hehehe
05:16:11 <ibid> "what do you mean we made an own goal? the typechecker should have prevented that!" :)
05:17:02 <matthew-_> lol. "We quickcheck'd it any everything! We have proven subject-reductions FFS!"
05:18:07 <cu3edweb> I now very little about haskell. What is the best book I can get to learn about it?
05:18:47 <ibid> cu3edweb: what's your background?
05:18:54 <quicksilver> cu3edweb: Graham Huttons 'Programming in Haskell' is well regarded
05:19:08 <quicksilver> so is Hudak's "Haskell School of Expression"
05:19:11 <quicksilver> (did I get that right/)
05:19:48 <quicksilver> http://www.haskell.org/haskellwiki/Books
05:19:49 <cu3edweb> Most of my background is in web (HTML, PHP) stuff
05:19:49 <lambdabot> Title: Books - HaskellWiki
05:20:52 <Cale> Hutton's book should be reasonably good for beginning programmers, I think.
05:21:19 <Cale> Also, you've come to the right place. Ask lots of questions here :)
05:21:55 <cu3edweb> Great thanks
05:23:26 <duryodhan> hey can anyone enlighten me as to the difference between interpretation and compilation ? (not the part like interpreting is line by line etc.)... I mean, interpretation is just execution, but to interpret a haskelll program won't it need to convert it to assembly code too ?
05:23:41 <ibid> duryodhan: no, it doesn't
05:23:48 <duryodhan> then  ?
05:24:05 <quicksilver> duryodhan: consider this very simple interpreter:
05:24:09 <quicksilver> interp (Add n m) = n + m
05:24:23 <quicksilver> this doesn't "convert Add" into assembly language
05:24:27 <quicksilver> in any direct sense
05:24:41 <quicksilver> it just generates the code which looks for "Adds", and when it sees them, does additions
05:24:50 <duryodhan> ok
05:25:07 <duryodhan> but still to do the addition it will write the assembly code to add ...
05:25:17 <quicksilver> assembly code exists to add
05:25:27 <duryodhan> and the memory reference will still be to the variable which I want to add ...
05:25:35 <quicksilver> however that code was written when the interpreter as compiled
05:25:38 <ibid> wrt compiler (Add n m) = do n' <- compiler n ; m' <- compiler m ; putStrLn ("ADD " ++ show n' ++" " ++ show m')
05:25:42 <quicksilver> not when the "program" was compiled
05:25:52 <quicksilver> so when your haskell interpreter was compiled
05:25:53 <ibid> s/wrt/compare/
05:26:01 <quicksilver> various bits of assembly were written
05:26:08 <quicksilver> but, when you *use* the haskell interprete
05:26:14 <quicksilver> (to interpret a haskell program)
05:26:18 <quicksilver> no "new" assembly is ever written
05:26:23 <quicksilver> no code is generated at this point
05:26:36 <duryodhan> ok
05:27:12 <duryodhan> so interpreter is a program that takes your program and the input to it as the input and outputs the output ... compiler is a program that takes your program and outputs it in assembly ...
05:27:16 <ibid> (of course, some interpreters use compiler-like techniques for optimization:)
05:27:19 <duryodhan> do I make sense ?
05:27:30 <Cale> duryodhan: yes
05:27:32 <quicksilver> yes
05:27:35 <duryodhan> ibid: you mean something like the JIT ?
05:27:38 <duryodhan> ohh ok
05:27:39 <duryodhan> thanks ...
05:27:44 <quicksilver> a compiler takes a program and outputs into a nother form
05:27:46 <quicksilver> for later use
05:27:54 <quicksilver> while an interpreter takes a program and runs it NOW
05:27:57 <ibid> duryodhan: yes, also threaded interpretation (nothing to do with threads, btw:)
05:28:00 <quicksilver> giving you nothing for later use.
05:28:12 <duryodhan> quicksilver: I knew it was something like that but your example really cleared it
05:28:18 <quicksilver> most modern interpeters contain internal stages which are much like compilation.
05:28:22 <quicksilver> but, not all of them.
05:28:26 <quicksilver> simple ones don't ;)
05:28:34 <ibid> slow ones don't :)
05:28:36 <duryodhan> ok
05:28:39 <duryodhan> heheh
05:28:51 <quicksilver> the kind you'd get a compsci student to write in their 2nd year wouldn't
05:28:59 <quicksilver> then the kind you get them to write in the follow on course maybe would
05:29:14 <duryodhan> damn ... in my college comp sci undergrads asked to write compiler only in their 3rd year :(
05:29:51 <quicksilver> I have see first year students asked to write calculators
05:29:51 <duryodhan> thanks a lot all
05:29:52 <Cale> I wrote a compiler in my first year of uni, and I wasn't even in CS :)
05:29:59 <quicksilver> that is, in a sense, a very very simple interpreter
05:30:02 <Cale> (I was in pure mathematics)
05:30:05 <quicksilver> a degenarate one.
05:30:32 <duryodhan> Cale: were you in languages and wrote a program to translate german to english and slyly calling it a compiler ?
05:31:02 <Cale> There were 3 courses you could select as your first CS course, depending on what you already knew. If you picked the 3rd one, your second term you'd be writing a compiler.
05:31:04 <duryodhan> quicksilver: aah the calculator example is actually a pretty good example for showing what a interpreter is ..
05:31:23 <duryodhan> Cale: ohh :D just kidding
05:32:15 <Cale> So a large portion of all students in the mathematics faculty end up writing a compiler, even if they're not in the department/school of CS.
05:32:57 <quicksilver> the problem with compiler-writing, viewed as university exercise
05:33:07 <quicksilver> is that the boring bits obscure the interesting bits
05:33:24 <quicksilver> housekeeping with ASTs is rather verbose, it becomes hard to see the wood form the trees
05:33:32 <quicksilver> and a student who isn't keeping up becomes totally lost
05:33:42 <Cale> Yeah, if you want to do the more interesting bits, there's a 3rd year course where you write an optimising compiler.
05:34:30 <quicksilver> really understanding the difference between a naive interpreter which works straight on an AST
05:34:32 <jedbrown> In my last year of high school, I took a CS class where the project was an assembly debugger.  I guess that amounts to a sort of interpreter.
05:34:41 <quicksilver> and one which compiles to something like a stack representation
05:34:46 <Cale> Some keen student who already knew what he was doing in the first course ended up adding lots of additional features and optimisations to his compiler, and then wrote a raytracer in the simple language which we were compiling :)
05:34:46 <quicksilver> is a great thing to understand
05:34:57 <matthew-_> hmm. we did an optimising compiler in our 2nd year. and that was also the only compilers course
05:35:52 <matthew-_> On the other hand, we spent a lot of time sleeping, as our current first-year have documented: http://www.youtube.com/watch?v=IYfIiYLA5QA
05:35:53 <lambdabot> Title: YouTube - Imperial College: Sleeping Students (A Music Video)
05:35:57 <Cale> Heh, my compiler was really cheap. Not wanting to deal with register allocation for expressions, I just used two interleaved stacks. :)
05:36:45 <Cale> I think I only ended up using 2 or 3 registers.
05:37:05 <Cale> (optimisation was not a requirement :)
05:37:14 <matthew-_> we were compiling to MIPS we would have been in a lot of trouble if we'd only used 2 registers ;)
05:37:40 <Cale> oh, yeah, it must have been at least 3, now that I think of it.
05:38:20 <Cale> (probably a couple more)
05:40:25 <quicksilver> is there a good review paper on different kinds of interpretation performance?
05:40:42 <quicksilver> like, simple expression language as AST evaluator vs stack machine etc
05:41:07 <quicksilver> I have a simple expression language and at the moment performance isn't at a premium, but if it ever was I'm not sure which way I'd go.
05:41:42 <matthew-_> isn't .NET a general register interpreter?
05:41:53 <matthew-_> Perl6VM is, IIRC
05:42:30 <quicksilver> there are programmer time tradeoffs too
05:42:37 <quicksilver> I don't particularly need/want anything cutting edge...
05:42:58 <quicksilver> but I daresay there are relatively simple ways of getting quite large performance improvements.
05:43:03 <matthew-_> well, from what I can gather, the Perl6 decision was just a standard NIH decision
05:44:42 <matthew-_> and I wouldn't be at all surprised to hear that the .NET decision was the same - "Let's not copy Sun"
05:45:05 <matthew-_> personally, I think VM's should be SIMD
05:45:16 <Spark> having a massive number of registers is pretty close to a stack
05:45:32 <dcoutts> matthew-_: there are different considerations if you're aiming for JIT
05:45:40 <Spark> and you don't want a small number of virtual registers because that makes it more machine-specific
05:46:08 <matthew-_> dcoutts: were Sun actually originally aiming for a JIT? HotSpot didn't appear for a while - was it a reaction or was it always planned?
05:46:20 <Spark> hotspot wasn't the first jit
05:46:26 <matthew-_> ahh ok
05:46:29 <Spark> hotspot just does online optimisations
05:46:52 <dcoutts> matthew-_: I'm not sure, but I think stack based is not great for a jit, you have to do more transformations first
05:46:58 <zeloran> is there an easy way to transform a list of this format [["a","b"],["c","d","e"],["f"]] to ["a","b","c","d","e","f"]
05:47:18 <resiak> > concat [["a","b"],["c","d","e"],["f"]]
05:47:18 <ToRA> > concat [["a","b"],["c","d","e"],["f"]]
05:47:19 <matthew-_> > concat [["a","b"],["c","d","e"],["f"]]
05:47:19 <ibid> yes
05:47:21 <lambdabot>  ["a","b","c","d","e","f"]
05:47:21 <lambdabot>  ["a","b","c","d","e","f"]
05:47:21 <lambdabot>  ["a","b","c","d","e","f"]
05:47:24 <ToRA> heh
05:47:24 <matthew-_> lol
05:47:26 <dcoutts> hah hah :-)
05:47:28 <resiak> stereo's not good enough any more!
05:47:30 * Spark makes sheep noises
05:47:30 <doserj> only 3?
05:47:38 <matthew-_> surround sound
05:47:42 <zeloran> :)
05:47:53 <resiak> @botsnack
05:47:54 <lambdabot> :)
05:48:16 <Spark> dcoutts: you have to transform registers too, what if the vm has more registers than your machine
05:48:30 <matthew-_> Spark: register spilling is standard fare
05:48:32 <dcoutts> Spark: you want to do register allocation anyway
05:48:44 <Spark> exactly, that's my point
05:48:53 <Spark> you have to do it anyway, so why not use a stack
05:48:56 <ibid> i'd probably have lots of registers, so the translator would not need to do register allocation
05:49:01 <ibid> and leave RA for the VM
05:49:08 <dcoutts> right
05:49:40 <ibid> Spark: because the VM has to translate the stack back to a list of temporaries anyway? :)
05:49:47 <dcoutts> Spark: because you have to undo the stack stuff to get it to use lots of registers
05:49:57 <dcoutts> what ibid says
05:50:14 <Spark> why not just take the top n of the stack as the registers
05:50:19 <Spark> or something like that
05:50:58 <matthew-_> Spark: I would think that would still demand a greater interpretation overhead
05:51:04 <Spark> it just doesn't seem to be a hugely different problem to me
05:51:14 <Spark> you're still having to evict stuff from machine registers into stack/virtual registers
05:51:23 <Spark> you're still having to choose stuff to cache in machine registers
05:51:35 <Spark> it's just whether it's a line of memory, or a line of memory
05:51:42 <matthew-_> the advantage I can see with stack, is that I would suspect you'll more natually get liveness information out
05:51:46 <ibid> Spark: the translator may also have to juggle the stack to get access to older temps
05:52:01 <ibid> Spark: unless the stack is addressable, of course
05:52:04 <Spark> usually they can look as far down the stack as they want can't they
05:52:06 <Spark> i know lua can
05:52:32 <ibid> but in that case, the stack effectively is an unlimited set of registers conventionally used in a FIFO manner :)
05:52:46 <matthew-_> ibid: quite.
05:53:01 <quicksilver> well it's quite helpful for function calls
05:53:12 <matthew-_> you're almost getting on to a triple-address machine
05:53:23 <quicksilver> for simple call-return stuff a stack is a lot more convenient than registers surely
05:53:54 <Spark> i'm pretty sure that in java, you access local vars by looking a given amount down the stack
05:54:01 * ibid used register windows for that in my latest VM
05:54:02 <Spark> and that's how you do it on a machine stack too
05:54:03 <quicksilver> so a stack is not jsut "unlimited set of registers" but "unlimited set of registers with O(0) renaming"
05:54:11 <matthew-_> Spark: only in the current stack frame
05:54:12 <quicksilver> which is quite a big win
05:54:15 <quicksilver> for certain kinds of things
05:54:24 <quicksilver> ibid: what's that?
05:54:30 <Spark> quicksilver: yeah, you can guarantee that the next one along is empty
05:54:31 <quicksilver> ibid: I mean, what are register windows?
05:54:37 <ibid> Spark: yes, but the point is, if it's a stack machine, you have to bring to the top of the stack anything you want to operate on; and if you don't, it's not a stack machine :)
05:55:01 <quicksilver> Spark: but also you can rename R3 -> R5, R4 -> R6, R5 -> R7 in one atomic and almost free operation.
05:55:19 <Spark> ibid: you can compile that out easily though
05:55:47 <ibid> quicksilver: basically, the hardware registers + the stack become a large set of registers, of which a small subset is visible as ISA registers at a time (and the visible window can be manipulated by sliding it up and down)
05:55:57 <ibid> Spark: why bother?
05:56:22 <ibid> quicksilver: originally in SPARC, i believe, also in MMIX
05:56:51 <Spark> ibid: because stacks have other advantages
05:57:02 <Spark> you will always want a stack, so you can do recursion
05:57:12 <Spark> if you can use the stack for everything, surely that's simpler
05:57:27 <ibid> Spark: sure, but you can have a stack without restricting your operators to stack operators
05:57:36 <ibid> Spark: uh, it's not simpler
05:57:44 <ibid> Spark: you almost always want to have a separate heap
05:57:52 <Spark> that's not the same as using a register machine though
05:57:59 <Spark> unless you're suggesting common ground
05:58:07 <Spark> a separate heap is a given
05:58:08 <ibid> Spark: also, in jvm, the stack is local to the procedure :)
05:58:16 <Spark> i'm talking about automatic storage
05:58:23 <ibid> Spark: you just said "stack for everything". which is it?
05:58:28 <Spark> i'm talking about automatic storage
05:58:43 <tibbe> dcoutts: would the correct way of setting a flag be: \v flags -> flags `mappend` emptyFlags { someFlag = Flag v} where v is of type String for example?
05:59:44 <dcoutts> tibbe: could do but that'll be slow, use: \v flags -> flags { someFlag = someFlag flags `mappend` v }
05:59:49 <ibid> Spark: if your arithmetical operator can access arbitrary stack locations, you have a register machine with a convention to use the register bank in a stack-like manner
05:59:57 <ibid> *operators
06:00:30 <ibid> mind, there are good reasons to have a stack machine in some situations
06:00:43 <ibid> (like when you expect to need to come up with new VM implementations in a hurry:)
06:00:58 <quicksilver> ibid: what advice would you give to someone looking for a simple improvement over a naive evaluator?
06:01:10 <ibid> quicksilver: depends on the requirements
06:01:14 <Spark> i've never heard a stack machine described as a register machine just because it was possible to address the stack
06:01:15 <quicksilver> ibid: for something which mostly a numeric expression language
06:01:43 <ibid> Spark: a stack machine is characterised by the top of the stack being special :)
06:01:45 <tibbe> dcoutts: ah
06:01:56 <quicksilver> ibid: the requirements are: be able to call the same expression many times with different argumetns relatively fast.
06:01:58 <Spark> it is special - it's next to clear space
06:02:14 <ibid> quicksilver: who is writing it, for what purpose, how much effort do they want to put it, is it expected to be used for something real and if so, what, etc etc etc :)
06:02:37 <Spark> the registers don't even need to be ordered in a register machine
06:03:01 <matthew-_> ibid: you could characterise the difference as being that in a Stack machine, you don't ever need to spill registers - the Stack is unbounded
06:03:02 <Spark> you can put arrays on the heap
06:03:04 <ibid> Spark: well, my large-register machine has a special register that says that any registers over this one are inaccessible. does this make it a stack machine? :)
06:03:19 <ibid> matthew-_: nothing is unbounded in real life :)
06:03:46 <ibid> (i think i had 64k registers)
06:04:00 <Spark> nothing about a register machine says they have to be addressable
06:04:07 <Spark> so you're talking about grey areas again
06:04:08 <ibid> matthew-_: of course, if you can't address the stack, then you can't tell in advance what the bound is
06:04:46 <ibid> Spark: by address, i mean that you can say "i want this register" and get the register in constant time
06:04:52 <quicksilver> ibid: well I think I'm asking "what is the next-easiest thing after a simple evaluator, which will perform a bit faster" ?
06:04:58 <Spark> so how do you look up register i, where i was gotten from another register
06:05:00 <ibid> Spark: i don't mean that you can actually compute those addresses
06:05:15 <matthew-_> Spark: woe, you can't point to registers
06:05:26 <Spark> < ibid> Spark: well, my large-register machine has a special register that says that any registers over this one are inaccessible
06:05:26 <RayNbow> http://programming.reddit.com/info/65tie/comments/
06:05:33 <ibid> quicksilver: a stack is simple
06:05:43 <ibid> quicksilver: and may be faster, though that depends
06:05:50 <RayNbow> "The Risks and Benefits of Teaching Purely Functional Programming in First Year [PS]"
06:05:54 <Spark> matthew-_: that is my point (although you could allow it for virtual registers and i suspect that's not so uncommon)
06:05:58 <ibid> Spark: where in that do i use the word "address"?
06:06:24 <Spark> implicitly
06:06:30 <ibid> Spark: the point of that special register is to say, if the register holds 412, then using r413 is a fault
06:06:37 <Spark> looking up something by numerical value - that is addressing
06:06:43 <ibid> Spark: there was no such implication intended
06:06:48 <Spark> the question still stands
06:07:03 <ibid> Spark: please re-ask, i lost track which question :)
06:07:10 <Spark> 14:04 < Spark> so how do you look up register i, where i was gotten from another register
06:07:22 <ibid> Spark: you don't
06:07:25 <matthew-_> Spark: ibid's said you can't do that
06:07:31 <Spark> so how do you do what you suggested
06:07:36 <Spark> "if the register holds 412, then using r413 is a fault"
06:07:38 <ibid> Spark: well, you could have a huge jump table :)
06:07:47 <ibid> Spark: by hardware
06:08:11 <Spark> we were talking about virtual machines
06:08:16 <matthew-_> the code says operate on the contents of r413. How is this a tricky issue?
06:08:17 <ibid> Spark: yes
06:08:32 <ibid> Spark: in VM context, hardware refers to the code in the VM
06:08:35 <Spark> matthew-_: the code says look up the special register to get the number 413, then operate on that register
06:08:51 <ibid> Spark: no it doesn't
06:09:01 <Spark> what exactly were you suggesting then
06:09:04 <Spark> and for what purpose
06:09:08 <cu3edweb> Wow that book recommened by Graham Hutton "Programming in Haskell" is $100
06:09:13 <matthew-_> Spark: I'm starting to think you're trolling here.
06:09:14 <Spark> you were trying to implement a stack with registers, right?
06:09:18 <ibid> Spark: no
06:09:30 * ibid agrees with matthew-_ 
06:09:40 <ibid> it's time for me to hit the bus, anyway
06:09:45 <matthew-_> ibid: it's ok - he "works" in my office...
06:09:56 <Spark> matthew is skiving at the moment
06:10:07 <ibid> matthew-_: ?!
06:10:10 <ibid> "skiving"?
06:10:15 <quicksilver> cu3edweb: amazon have it for $40
06:10:24 <quicksilver> cu3edweb: not sure where you got $100 from...
06:10:24 <matthew-_> ibid: oddly enough, I prefer working from home!
06:10:31 <ibid> hah
06:10:50 <Spark> me too
06:11:20 <cu3edweb> Sorry I was looking at the hardcover not the paperback. my bad
06:11:25 <Spark> however i have to be here at least 3 days a week due to meetings and tutorials
06:11:30 <ibid> Spark: anyway, if you want to look at the VM in question, it's at http://antti-juhani.kaijanaho.fi/darcs/quadmachine/
06:11:31 <EvilTerran> @wn skive
06:11:31 <lambdabot> Title: Quadmachine 2
06:11:31 <lambdabot> *** "skive" wn "WordNet (r) 2.0"
06:11:31 <lambdabot> skive
06:11:32 <lambdabot>      v : remove the surface of; "skive leather"
06:11:32 <Spark> and susan complains if i'm not here the other 2 as well
06:11:46 <ibid> (it's of course possible that i misremember details. it's been a year:)
06:11:50 <Spark> it maens bunking off
06:12:09 <matthew-_> it means avoiding endless and unnecessary arguments ;)
06:12:44 <Spark> resolving arguments is an undecidable process
06:12:56 <Spark> usually the problem is inconsistent terminology between the two parties
06:13:16 <Spark> neither being correct of course
06:13:19 <glen_quagmire> i have a list of numbers. how can I tell if they have all same sign?  or i have a list of Bools. how can I tell if they have same value?
06:13:32 <ibid> doesn't look like i used that special register, though. it seems i misremember
06:13:48 <sizur> :t all
06:13:50 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:14:03 <koeien> glen_quagmire: f xs = all const xs || all const (map not xs)
06:14:10 <sizur> > all (>1) [3,4,5,6,7]
06:14:11 <lambdabot>  True
06:14:15 <Spark> looks like you're addressing registers by address there
06:14:16 <quicksilver> glen_quagmire: zipWith (==) xs (tail xs)
06:14:21 <sizur> > all (>1) [2,3,4,1,3]
06:14:21 <lambdabot>  False
06:14:23 <Spark> by number, rather
06:14:24 <koeien> quicksilver: that's a lot better
06:14:28 <Spark> $1 $2 etc?
06:15:18 <bbjwerner> Hello
06:15:42 <ibid> Spark: the numbers are names. you can't really address registers
06:16:52 <Spark> right ok
06:18:01 <Spark> do you use the heap for recursive function calls in this then?
06:18:08 <ac> cool. I created a PNG image. It's just doesn't look like I intended it to
06:19:18 <quicksilver> ac: yay :)
06:20:44 <ac> gimp seems to think I have encoding errors, but qiv doesn't bat an eye
06:20:51 <ac> but they both open it
06:21:13 <davidL> ac: working on the png lib?
06:21:17 <ac> davidL: yeah
06:21:37 <ac> now I just have to figure out why I have a rainbow of pixels in a funny shape, when I tried to draw a circle of one color
06:22:09 <aFlag> @getArgs
06:22:09 <lambdabot> Unknown command, try @list
06:22:31 <aFlag> @hoogle getArgs
06:22:31 <lambdabot> System.Environment.getArgs :: IO [String]
06:23:11 <quicksilver> ac: bad eyesight?
06:23:31 <ibid> Spark: ask me again in 2 hours, or /query :)
06:23:33 * ibid goes
06:23:39 <ac> cool, I created a 2x2 image correctly. Must be something wrong with my circle drawing code
06:24:11 <davidL> ac: that's with pure haskell? no bindings?
06:24:37 <ac> davidL: yeah
06:24:41 <davidL> nice :)
06:24:54 <ac> yeah, it's a fun project for me
06:25:45 <ac> it's odd that the section about deflate compression in the PNG spec doesn't match up with what I see in PNG files and what Codec.Compression.Zlib produces
06:25:48 <ac> but it works
06:26:08 <dcoutts> ac: how so?
06:26:56 <ac> the header for the compressed block doesn't match up at all. Everything else is the same though
06:28:19 <ac> I guess the byte they say should be 8 also stores flags that it doesn't specify
06:28:55 <hpaste>  pitecus pasted "types" at http://hpaste.org/5080
06:29:02 <pitecus> Hi
06:29:12 <ac> What I find especially odd is the RFC they link to for the compression spec only defines the raw compression stream, and not the container that's actually used
06:29:28 <ac> Anyway, it works, so I won't worry about it
06:29:34 <pitecus> I'm finding myself having to use silly things in what I pasted
06:29:54 <pitecus> I mean the calls like "accuracy (map,map,map)"
06:30:22 <pitecus> when i try to make the accuracy function take just a single function instead of a triple I get typing errors
06:30:37 <mauke> that indicates you need higher order types
06:30:43 <pitecus> but the three functions in the triple will alwasy be the same
06:30:55 <pitecus> mauke, how do i enable them?
06:31:19 <mauke> what's the type of accuracy?
06:31:47 <pitecus> accuracy :: (Eq a6, Eq a4, Eq a2) =>
06:31:47 <pitecus> 	    (((a1, b) -> a1) -> a -> a2, ((a3, b1) -> b1) -> a -> a4, (a5 -> a5) -> a -> a6)
06:31:47 <pitecus> 	    -> [a]
06:31:47 <pitecus> 	    -> [a]
06:31:47 <pitecus> 	    -> Accuracy
06:32:02 <integral> @type map
06:32:04 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:32:33 <mauke> something's wrong here
06:33:28 <pitecus> what?
06:33:43 <glen_quagmire> is there a way to fold on elements? usually foldr or foldl operates on 2 elements
06:34:14 <glen_quagmire> I have list of vertices [(a,b), (c,d), ...]  and I want to check if their crossProducts have same sign
06:34:45 <glen_quagmire> crossProduct (x1,y1) (x2,y2) (x3,y3) = ax * by - ay * bx where (ax, ay) = (x1 - x2, y1 - y2); (bx, by) = (x3 - x2, y3 - y2)
06:35:00 <glen_quagmire> man this book doesn't come with answers
06:36:54 <pitecus> I have OPTIONS_GHC -fglasgow-exts in that file. Shouldnt that enable the higher order types?
06:38:19 <quicksilver> glen_quagmire: I don't understand what a fold on elements would be...
06:38:23 <quicksilver> glen_quagmire: unless it's a map...
06:39:47 <quicksilver> pitecus: you have to specify higher rank types explicitly
06:39:53 <quicksilver> pitecus: they can't be inferred
06:40:32 <quicksilver> pitecus: if you gave accuracy the right type annotation you could pass map only once
06:40:55 <quicksilver> accuracy :: (forall a b . (a->b) -> [a] -> [b]) -> ....
06:40:57 <quicksilver> for example
06:41:07 <pitecus> quicksilver, let me try that
06:41:13 <quicksilver> that's the most general type map can have
06:41:20 <quicksilver> maybe you have a slight specialisation in mind.
06:41:53 <ac> cool. now I have a teal circle
06:42:00 <quicksilver> of the top of my head I don't see the correct common generalisation of map and id
06:42:51 <sizur> quicksilver: why the existential quantifier?
06:42:53 <quicksilver> ac: did you want it to be teal, though?
06:42:59 <quicksilver> sizur: that wasn't existential.
06:43:07 <quicksilver> that's universal
06:43:11 <quicksilver> that's the most general type of map
06:43:12 <quicksilver> :t map
06:43:14 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:43:20 <ac> quicksilver: yep: (0.2,0.5,0.9)
06:43:26 <sizur> quicksilver: alright. why the forall there?
06:43:34 <quicksilver> sizur: to pass it polymoprhically
06:43:36 <ac> I had several errors in my Arary -> ByteString function
06:43:47 <pitecus> quicksilver, the type that's inferred is like this: ((a1, b) -> a1) -> a -> a2
06:43:50 <quicksilver> H-M type inference always infers monomorphic parameters.
06:44:10 <pitecus> only it appears three times
06:44:31 <quicksilver> with different a1, b and a2
06:44:34 <quicksilver> only a being constant
06:44:35 <sizur> quicksilver: aha, thanks, now i understand
06:44:44 <ac> is zlib also implemented in pure Haskell?
06:44:50 <quicksilver> ac: I believe not.
06:45:05 <ac> shame, because if it was I could gaurantee no buffer overflows
06:46:19 <sizur> why does ghci give me a map :: (a->b)->[a]->[b]
06:46:52 <quicksilver> sizur: that is the haskell98 notation for the same thing.
06:47:30 <sizur> so with exstensions it means another thing?
06:47:40 <ac> now for the tedious process of implementing the rest of the spec. Damn filters, they've got to be the most annoying part
06:48:03 <ac> And I doubt anybody bothers to use them
06:49:10 <bos> the haskell zlib library is a set of safe bindings to the real zlib.
06:49:31 <ac> but it's not absolutely known that it's safe
06:49:43 <bos> at the high level, it's just a compress and decompress function.  no possibility of buffer overruns from haskell-land.
06:49:50 <ac> oh
06:50:05 <bos> also, the function types are pure: ByteString -> ByteString.
06:50:11 <ac> how can you be sure of no such possibility when C code is being called?
06:50:26 <sizur> ac: you look at the c code?
06:50:27 <aFlag> is hugs still being developed, the last release is about two years old
06:50:27 <quicksilver> sizur: no, it never means another thing ;)
06:50:40 <sizur> quicksilver: then why did you use the forall again?
06:50:50 <quicksilver> sizur: it's just that with certain extensions it is displayed more explicitly
06:50:56 <quicksilver> sizur: because it was in brackets.
06:50:58 <quicksilver> :)
06:51:00 <bos> ac: you can be sure that if something goes wrong, it's not the haskell code's fault.
06:51:06 <quicksilver> (a -> b) -> c
06:51:09 <quicksilver> is different from
06:51:16 <quicksilver> (forall a b. a -> b) -> c
06:51:19 <dcoutts> ac: we can with reasonable confidence, I wrote the zlib bindings to be fairly defencive and assert on all sorts of abnormal conditions
06:51:33 <ac> dcoutts: ok ;-)
06:51:42 <quicksilver> (a -> b) -> c is "forall a b c. (a -> b) -> c)
06:51:48 <quicksilver> which is different from
06:51:57 <quicksilver> "(forall a b. a -> b) -> c"
06:51:59 <quicksilver> erm
06:52:09 <quicksilver> "forall c . (forall a b. a -> b) -> c"
06:52:12 <quicksilver> I should say
06:52:32 <sizur> quicksilver: hmm. and what's the difference?
06:52:42 <quicksilver> types with foralls inside brackets, "nested foralls" are not expressible in haskell98
06:52:49 <quicksilver> "higher rank types" they are called.
06:53:19 <quicksilver> well the former takes a function of type (a->b), for any old a and b, and returns a value of type c
06:53:39 <quicksilver> the latter takes a *polymorphic function* of type (forall a b. a->b)
06:53:41 <sizur> old a and b?
06:53:51 <quicksilver> "any old" is just an english idiom
06:54:01 <quicksilver> it means "any ordinary"
06:54:09 <quicksilver> it's not a maths term :)
06:54:30 <jfredett> its loosely equivalent to the math term "arbitrary"
06:54:33 <sizur> english has more idioms than even american heh
06:55:38 <sizur> quicksilver: so the difference is the former can take many functions, but the latter can take only one?
06:55:39 <jfredett> hehe, sizur, we try. :)
06:56:09 <sizur> i dont understant
06:56:16 * jfredett is american
06:56:40 <sizur> no it's the opposite
06:56:42 <jfredett> most people say we've been screwing up the language
06:56:52 <pitecus> I still have no clue where to put the foralls in that type signature...
06:56:56 <sizur> but i thought that (a->b) is already polymorphic
06:57:15 <jfredett> it is, but not _as_ polymorphic,
06:57:23 <jfredett> its -- kinda tough to explain
06:57:24 <sizur> can you elaborate on that please
06:57:42 <jfredett> I can't really think of a good example.
06:57:47 <quicksilver> (a->b) is not polymorphic as a parameter
06:57:53 <quicksilver> only the whole thing is polymorphic
06:58:01 <quicksilver> foo :: (a->b)->c
06:58:07 <quicksilver> foo is polymorphic in a,b,c
06:58:22 <quicksilver> but, foo does not take a polymorphic parameter
06:58:27 <mauke> > let foo f = (f 'x', f 42) in foo id
06:58:34 <lambdabot>   add an instance declaration for (Num Char)
06:58:39 <tibbe> um, is there no way to create a FilePath from a String?
06:58:54 <quicksilver> it takes a monomorphic parameter for some particular a,b
06:58:54 <jfredett> tibbe: a filepath is a string, no?
06:58:56 <mauke> > let foo :: (forall a. a -> a) -> (Char, Int); foo f = (f 'x', f 42) in foo id
06:58:57 <lambdabot>  Parse error at "." (column 21)
06:59:00 <jfredett> @hoogle FilePath
06:59:00 <lambdabot> System.FilePath :: module
06:59:00 <lambdabot> Prelude.FilePath :: type FilePath
06:59:00 <lambdabot> System.IO.FilePath :: type FilePath
06:59:00 <pitecus> tibbe, FilePath is a type synonym for String
06:59:03 <quicksilver> tibbe: yes. This is how you do it:
06:59:13 <quicksilver> tibbe: you use the invisble operator
06:59:14 <tibbe> hmm
06:59:14 <quicksilver> ;)
06:59:17 <quicksilver> :t openFile
06:59:18 <lambdabot> Not in scope: `openFile'
06:59:21 <Lemmih> tibbe: 'id' might to the trick.
06:59:28 <tibbe> ah, I see my error
06:59:32 <sizur> so the function (a->b)->c can take only a specific function of (a->b) while a function of (forall a b. a -> b) -> c can take a function that becomes specific later?
06:59:40 <quicksilver> sizur: no
06:59:44 <tibbe> IsString sometimes leads to confusing error messages
06:59:46 <quicksilver> the latter must take a function which works for ALL a and b
06:59:55 <sizur> aha
06:59:56 <quicksilver> it must get a polymorphic function
07:00:17 <Tac-Tics> So you can't pass it, for example, an Int -> Int
07:00:18 <Tac-Tics> right?
07:00:22 <quicksilver> right
07:00:25 <sizur> i see
07:00:40 <jfredett> tibbe: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AFilePath
07:00:42 <lambdabot> http://tinyurl.com/ovjef
07:01:03 <eu-prleu-peupeu> how do i use haskell inside of C ?
07:01:21 <eu-prleu-peupeu> can haskell generate DLL's ?
07:01:29 <pitecus> cool nickname eu-prleu-peupeu
07:01:40 <quicksilver> you can link haskell code stright into C code
07:01:47 <quicksilver> (not quite the same thing as generating DLLs)
07:01:56 <quicksilver> you can statically link haskell code to your C code
07:02:00 <eu-prleu-peupeu> link straight into C, how ?
07:02:01 <quicksilver> shared library support is being worked on.
07:02:06 <quicksilver> eu-prleu-peupeu: by using a linker!
07:02:07 <quicksilver> ;)
07:02:20 <quicksilver> just like you'd link in a C library into a C program.
07:03:41 <Tac-Tics> @go fingerstring
07:03:42 <lambdabot> http://www.fingerstring.org/
07:03:42 <lambdabot> Title: fingerstring.org - e-mail reminders, birthday reminders, anniversary reminders
07:03:49 <Tac-Tics> hmm
07:03:54 <Tac-Tics> that's not what I want
07:04:12 <eu-prleu-peupeu> so haskell can generate .a files ?
07:04:19 <eu-prleu-peupeu> and .h ?
07:04:34 <mauke> :(
07:04:36 <Tac-Tics> @go ffi
07:04:37 <lambdabot> http://www.ffi.org/
07:04:37 <lambdabot> Title: Family Firm Institute (FFI)
07:04:40 <Tac-Tics> bah
07:04:42 <Tac-Tics> @where ffi
07:04:42 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
07:05:00 <eu-prleu-peupeu> ah ok
07:05:01 <eu-prleu-peupeu> ffi
07:05:22 <jfredett> thats calling C from haskell, though
07:05:24 <jfredett> isn't it?
07:05:29 <Tac-Tics> http://haskell.org/haskellwiki/GHC/Using_the_FFI
07:05:35 <Tac-Tics> It goes bothways
07:05:41 <quicksilver> jfredett: goes both ways
07:05:52 <jfredett> cool, I should probably learn that.
07:05:53 <quicksilver> eu-prleu-peupeu: you have to write the .h files yourself,
07:05:59 <quicksilver> although there might be tools that help?
07:06:05 <quicksilver> eu-prleu-peupeu: but, yes, ghc can generate .a files.
07:06:36 <Cale> Ordinarily, you'd just use GHC to compile and link your C program :)
07:08:16 <jfredett> Cale: Hmm, I wonder, could I use GHC to compile only C code, no haskell?
07:08:20 <Cale> yes
07:08:32 <eu-prleu-peupeu> ok
07:08:37 <jfredett> yay! no more gcc :)
07:08:42 <eu-prleu-peupeu> gcc is great
07:08:45 <Cale> In fact, I've had that happen simply by typoing gcc
07:08:52 <jfredett> lol
07:09:44 <Cale> Of course, you need gcc on your system for ghc to compile C :)
07:09:59 <jfredett> unless you download a binary GHC
07:10:26 <Cale> Oh, does it actually include a GCC?
07:10:49 <jfredett> no, but then I wouldn't need GCC, then again, I don't write C
07:10:53 <jfredett> as a matter of religion
07:11:17 <Cale> heh
07:12:12 <Cale> I suppose the default is now native code compilation too.
07:12:39 <jedbrown> jfredett: Do you use FFI?
07:12:44 <jfredett> nope
07:13:08 <jedbrown> jfredett: You're *pure* man.
07:13:56 <jfredett> lol
07:16:33 <jfredett> I suppose, I'm a mathematician, not a programmer, I don't typically have a need for C.
07:16:33 <jfredett> or accessing C like stuff.
07:16:39 <quicksilver> Cale: certain GHC binary packages include gcc
07:16:45 <quicksilver> Cale: in particular the windows megapackages do
07:16:51 <glen_quagmire> given a list, I want to append the head to the end.  func (x:xs) = xs ++ [x]   is this proper way to do it?
07:16:59 <quicksilver> Cale: on OSX or Linux they generally do not.
07:17:01 <glen_quagmire> given a list, I want to append the head to the end.  func (x:xs) = (x:xs) ++ [x]   is this proper way to do it?
07:17:13 <shachaf> glen_quagmire: It's generally used, yes.
07:17:17 <quicksilver> what you said first sounded better :)
07:17:25 <shachaf> (As far as I know?)
07:17:28 <quicksilver> depending if you intend to remove the head or not as well
07:17:45 <glen_quagmire> finallly, i did this exercise!
07:18:01 <Cale> glen_quagmire: There's not really a better way to do it. If you have to do that a lot, you might consider using something which isn't a list :)
07:18:57 <jfredett> like a deque, I think i have a library for them somewhere...
07:19:07 <Cale> Or a Data.Sequence
07:19:28 <jfredett> Cale: that too...
07:19:41 * jfredett runs to look at the docs for Sequence
07:20:31 <hpaste>  glen_quagmire pasted "Polygon convexity test" at http://hpaste.org/5081
07:22:08 <Cale> kinda strange indentation :)
07:22:35 <glen_quagmire> to save 4 columns
07:22:39 <glen_quagmire> @src map
07:22:40 <lambdabot> map _ []     = []
07:22:40 <lambdabot> map f (x:xs) = f x : map f xs
07:23:06 <czakey> @src concatMap
07:23:06 <lambdabot> concatMap f = foldr ((++) . f) []
07:23:39 <czakey> @src replicateM
07:23:39 <lambdabot> replicateM n x = sequence (replicate n x)
07:23:45 <czakey> @src mapM
07:23:45 <lambdabot> mapM f as = sequence (map f as)
07:24:19 <Cale> sequence is a lovely function, but don't ask @src for the source :)
07:24:30 <czakey> heheh
07:24:37 <Cale> sequence [] = return []
07:24:49 <czakey> I'm begining to understand Monads
07:24:50 <Cale> sequence (x:xs) = do v <- x; vs <- xs; return (v:vs)
07:24:52 <czakey> so
07:25:26 <shachaf> Cale: vs <- sequence xs?
07:25:31 <Cale> er, yes :)
07:25:36 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:25:46 <Cale> alternately,   sequence = foldr (liftM2 (:)) (return [])
07:25:54 <czakey> but unfortunately  I have to write in Prolog right now ;>
07:26:12 <quicksilver> glen_quagmire: map3 f vs might be the same as zipWith3 vs (tail vs) (tail (tail vs))
07:26:19 <Cale> which is nice to compare with  id = foldr (:) []
07:26:37 <glen_quagmire> :t zipWith3
07:26:39 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
07:27:01 <quicksilver> glen_quagmire: similar to the zipWith == trick
07:27:03 <quicksilver> but 3-ary.
07:27:07 <Cale> better to use drop than tail
07:27:16 <Cale> (perhaps?)
07:27:17 <quicksilver> glen_quagmire: also, all (==True) is just and
07:27:25 <quicksilver> Cale: well he already checks for length >= 3
07:27:26 <Cale> actually, maybe it would be okay :)
07:27:34 <quicksilver> Cale: but, maybe drop 2 looks nicer than tail.tail
07:27:38 <glen_quagmire> quicksilver: oh thanks. this can be a lot simpler
07:27:46 <glen_quagmire> in terms of lines of ocde
07:27:52 <quicksilver> @src all
07:27:53 <lambdabot> all p =  and . map p
07:28:04 <quicksilver> "all" uses "and" internally
07:28:11 <quicksilver> and "map (==True)" is kind of daft
07:28:14 <quicksilver> if you think carefully
07:28:25 <quicksilver> > map (==True) [False,True,True,False]
07:28:26 <lambdabot>  [False,True,True,False]
07:28:43 <glen_quagmire> haha
07:29:12 <quicksilver> (==True) is a long way to write id ;)
07:29:21 <gio123> Cale: it works in the example u gave
07:29:26 <byorgey> > map (not . (==False)) [False,True,True,False]
07:29:27 <lambdabot>  [False,True,True,False]
07:29:29 <gio123> Cale: could u give me other
07:29:36 <jfredett> > map (==False) [False, True, True, False] -- should be a synonym for map (not) xs)
07:29:36 <lambdabot>  [True,False,False,True]
07:29:38 <Cale> gio123: can't you come up with some?
07:29:44 <quicksilver> and "all id = and . map id = and . id = and"
07:29:53 <quicksilver> 3 cheers for equational reasoning!
07:30:01 <byorgey> hip hip!
07:30:04 <C-Keen> ah nice thing this xmonad
07:30:07 <jfredett> hooray!
07:30:08 <shachaf> @scheck ap (==) (==True)
07:30:09 <lambdabot>   Completed 2 test(s) without failure.
07:30:30 <jfredett> C-Keen: isn't it though? and xmobar is pretty awesome too
07:30:39 <gio123> Cale: the examples which i tasted till now it works, did u see pm?
07:30:47 <Cale> yes
07:31:13 <gio123> good
07:32:58 <quicksilver> I like the idea of tasting examples.
07:33:07 <quicksilver> Can we taste them randomly with quicktaste?
07:33:12 <quicksilver> and exhaustively with SmallTaste?
07:34:10 <glen_quagmire> how can I test correctness of my function?
07:34:38 <glen_quagmire> in imperative languages, I just print out intermediate values
07:34:54 <Cale> QuickCheck works well.
07:34:59 <glen_quagmire> a = some complicated stuff;   print a;    return a + other complicated;
07:35:12 <Cale> Or just use ghci to try the function out.
07:35:25 <ricky_clarkson> In other langs, testing often involves asserts.
07:35:56 <ricky_clarkson> Does that mean you'd replace those with a list of expressions that give Booleans in Haskell?
07:36:34 <dcoutts> heh heh, I love Java:
07:36:35 <dcoutts> "In practice, many filters end up being static final anonymous singletons."
07:36:43 <Cale> ricky_clarkson: If you're going to go that route, there's HUnit. QuickCheck will automatically generate data to pump in and test if a property holds.
07:36:43 <quicksilver> I quite often do, ricky_clarkson
07:36:47 <dcoutts> (from a blog talking about filter and iterators)
07:36:59 <quicksilver> ricky_clarkson: I quite often have tests :: [(String,Bool)]
07:37:07 <ricky_clarkson> Cale: I'd rather not go that route, but I know people who would.
07:37:18 <ricky_clarkson> The Scala list is debating it just now.
07:37:38 <quicksilver> ricky_clarkson: and run_tests = mapM (\(t,p) -> if p then putStrLn $ "PASSED : "++t else putStrLn $ "FAILED : "++t
07:37:40 <Cale> @check \xs -> (xs :: [Int]) == reverse (reverse xs)
07:37:42 <lambdabot>  OK, passed 500 tests.
07:37:46 <quicksilver> ricky_clarkson: or, something more complex along those general lines
07:37:49 <Cale> Like that
07:38:00 <byorgey> dcoutts: eh... I know Java pretty well, and that makes no sense to me =P
07:38:03 <dcoutts> Scrap your Static Final Anonymous Singletons, use the Function design pattern.
07:38:08 <quicksilver> there are times when quickcheck is ideal.
07:38:10 <byorgey> hehe
07:38:11 <dcoutts> byorgey: http://www.erik-rasmussen.com/blog/2008/01/18/the-filter-pattern-java-conditional-abstraction-with-iterables/
07:38:13 <Cale> HUnit includes useful code of the sort which quicksilver mentioned :)
07:38:13 <lambdabot> Title: Erik&#8217;s Blog  The Filter Pattern: Java Conditional Abstraction With Iterab ..., http://tinyurl.com/3b23ck
07:38:15 <quicksilver> there are time when you want to test a specific combination
07:38:18 <quicksilver> (like a regression)
07:38:32 <quicksilver> or when you want to test to a list of bullet points
07:38:56 <quicksilver> I must confess to being a bit adhoc
07:39:03 <quicksilver> different styles of tests in different modules :)
07:39:06 <byorgey> I love how things which must be described as "patterns" in other languages are just Prelude functions in Haskell =)
07:39:19 <byorgey> quicksilver: gasp!
07:39:27 <ricky_clarkson> It's true that in Java, one-time use functions are so annoying to write that people often name them.
07:39:38 <dcoutts> byorgey: oh, it gets better! the next section is about filter predicates that use another object to help them decide, like, um a closure :-)
07:39:50 <ricky_clarkson> Presumably if you split one annoying code block into two, the total is deemed to be less annoying.
07:39:55 <byorgey> dcoutts: hehe
07:39:56 <Cale> ahaha
07:40:03 <Cale> poor java programmers
07:40:30 <dcoutts> you need 10 lines to implement (<0)
07:40:58 <dcoutts> seriously, that's one example :-)
07:41:01 <Cale> Does it take an additional 10 lines to shed a tear?
07:41:02 <quicksilver> you can do that in one rather crowded line
07:41:10 <quicksilver> but it's considerably more than 4 chars :)
07:41:20 * Saizan knows this too well, sigh.. and it's only worse when you put threads in the middle, a class for each operation!
07:41:38 <quicksilver> new IntPredicate() { bool apply(x) { return (x<0); }; };
07:41:41 <quicksilver> something like that?
07:41:47 <quicksilver> my java is very rusty
07:41:55 <quicksilver> of couse you need a library of base classes like IntPredicate
07:41:59 <dcoutts> oh, now we get to higher order predicates
07:42:03 <quicksilver> but such things exist in boost-like java libs
07:42:05 <dcoutts> Filter<Integer> filter = new OrFilter( ...
07:42:08 <phobes> quicksilver:  You trying to make an anonymous class there?
07:42:12 <Cale> quicksilver: You could use generics at least.
07:42:22 <quicksilver> phobes: yes
07:42:29 <quicksilver> (and an object, too)
07:42:31 <ricky_clarkson> dcoutts: You need much more than 10 lines, because <0 is not Integer => Integer.
07:42:32 <phobes> right
07:42:39 <ricky_clarkson> :t (<0)
07:42:40 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
07:43:02 <quicksilver> if you want the full strength of haskell typeclasses then it is a bit more fiddly
07:43:10 <quicksilver> to be fair. that's not something you need as often in practice.
07:43:24 <ricky_clarkson> True, but you want that sometimes.
07:43:27 <dcoutts> aye, we can forgive them that
07:43:39 <quicksilver> so, I don't buy this 10 lines argument
07:43:43 * RayNbow once tried solving something in Java using anonymous classes...
07:43:44 <dcoutts> and you could do it in java with generics by parameterising by another interface
07:43:50 <quicksilver> (java developers as a class are two scared of putting things on one line)
07:43:53 <ricky_clarkson> It's not 10 lines, it's 5.
07:43:54 <quicksilver> too scared
07:43:54 <Cale> You see real issues with polymorphism in other languages when people try to implement monads :)
07:43:55 <RayNbow> but I ended up writing a separate class because of the lack of closures :p
07:43:59 <quicksilver> damn homotypos
07:44:14 <quicksilver> RayNbow: java has sort-of closures
07:44:21 <quicksilver> RayNbow: what kind of closure did you need?
07:44:31 <RayNbow> erm, lemme try to remember :p
07:44:32 <quicksilver> well scrap "sort-of"
07:44:35 <quicksilver> java has closures
07:44:36 <tibbe> dcoutts: it's really annoying to add a flag prefix to all record names
07:44:37 <ricky_clarkson> new FII(){ public int invoke(int i){return i<0;} } - using normal Java layout that's 5 lines.
07:44:37 <osfameron> perl developers aren't scared of putting things in one line (even when we should be)
07:44:38 <quicksilver> although they're mutable of course
07:44:43 * byorgey WAS having a nice morning, but NO, dcoutts had to go and show him that...
07:44:44 <tibbe> dcoutts: to avoid name collisions
07:44:51 <dcoutts> byorgey: heh heh :-)
07:44:54 <phobes> quicksilver:  I seem to recall "sort-of" being appropriate
07:44:57 <byorgey> =)
07:45:01 <Cale> Java has closures if you're willing to maintain your own code/environment pairs.
07:45:01 <dcoutts> tibbe: aye, one can use modules or just suffer it
07:45:02 <ricky_clarkson> Java 7 should have this: {int i => i<0} but the enterprise idiots are fighting back.
07:45:16 <tibbe> dcoutts: I guess I'll suffer it
07:45:27 <dcoutts> Cale: yes, that's exactly what this blog is doing, it's just verbose
07:45:29 <phobes> quicksilver:  Wasn't there a limitation about the context being captured?
07:45:30 <quicksilver> Cale: that's not true. It can do its own environments.
07:45:38 <Cale> I really hate when people say "closure" and mean "first class function" :)
07:45:51 <ricky_clarkson> quicksilver: If you don't mutate variables.
07:45:54 <phobes> Cale:  It has actually closures
07:46:01 <quicksilver> ricky_clarkson: yes. quite.
07:46:12 <phobes> But I seem to recall quirky rules about using them
07:46:13 <ricky_clarkson> @go rickyclarkson java already has closures
07:46:14 <lambdabot> http://rickyclarkson.blogspot.com/2007/10/java-7-example-pattern-matching.html
07:46:14 <lambdabot> Title: Ricky's technical blog: Java 7 Example - Pattern Matching
07:46:18 <ricky_clarkson> Bah.
07:46:20 <phobes> like it wouldn't just capture any local variable
07:46:33 <quicksilver> it captures by reference, not by value
07:46:36 <quicksilver> as you'd expect in java
07:46:44 <quicksilver> same caveat applies in javascript
07:46:47 <ricky_clarkson> Cale: http://rickyclarkson.blogspot.com/2007/10/why-java-needs-closures-it-already-has.html
07:46:48 <lambdabot> Title: Ricky's technical blog: Why Java Needs Closures (It Already Has Them), http://tinyurl.com/2kq2t2
07:46:49 <quicksilver> and confuses people plenty there
07:46:58 <quicksilver> but it sure does capture
07:47:24 <Cale> ricky_clarkson: Yes, you're clearly not talking about adding closures to Java. You're talking about adding closures to Java's implementation. :)
07:47:45 <Cale> Haskell doesn't have closures, GHC does :)
07:48:01 <phobes> Cale:  Now that's getting pedantic :)
07:48:11 <quicksilver> public FII makeFII(int n) { return new FII() { public int invoke(int i) {return i<n} }; }
07:48:12 <ricky_clarkson> Cale: No, the implementation isn't going to change, only the language.
07:48:23 <quicksilver> Cale, ricky_clarkson: isn't that a closure?
07:48:28 <ricky_clarkson> Scala uses closures quite happily on the JVM.
07:48:32 <ricky_clarkson> quicksilver: Yes.
07:48:34 <pjd> has http://javac.info/ been mentioned yet?
07:48:34 <quicksilver> the return predicate captures the 'n' that was passed.
07:48:35 <lambdabot> Title: Closures for the Java Programming Language
07:48:37 <jfredett> Sorry, phobes, I started Cale with Cale -pedantic -Wall today,
07:48:52 <phobes> hehe
07:48:58 <Cale> A closure is a pair consisting of some code and an environment mapping free variables in the code to values.
07:49:14 <quicksilver> Cale: yes, which that is (a java-stylte corruption of)
07:49:19 <quicksilver> Cale: the 'code' is the FII object
07:49:20 <phobes> Alot of people use "closure" to mean "first class function with bound parameters"
07:49:29 <quicksilver> the environment is the copy of "n"
07:49:34 <pjd> alternately, a closure is a function with open bindings closed by the surrounding lexical context
07:49:40 <quicksilver> which the compiler convenients packages for you somehow
07:49:45 <Cale> phobes: right, which is a usage that really annoys me :)
07:49:51 <pjd> that's how the term was introduced
07:50:01 <Cale> pjd: actually, it's not :)
07:50:20 <quicksilver> Cale: but to be clear: do you think my example is a closure, or not?
07:50:27 <quicksilver> it looks like a closure to me...
07:50:55 <RayNbow> hmm
07:50:56 <quicksilver> my code had a free variable (n) and the java compiler paired it up with my code
07:50:58 <Cale> quicksilver: no, not explicitly
07:51:01 <RayNbow> it seems it sorta works in Java...
07:51:06 <Cale> quicksilver: It might be implemented as a closure.
07:51:07 <ricky_clarkson> quicksilver: Save for the fact it doesn't compile :)
07:51:16 <quicksilver> ricky_clarkson: doesn't it? what happens?
07:51:24 <ricky_clarkson> Cale: Closures are not implementation details, but language features.
07:51:24 <Cale> A closure explicitly looks like a pair.
07:51:36 <Cale> ricky_clarkson: no
07:51:37 <ricky_clarkson> Cale: Smalltalk blocks are closures, but are implemented as objects.
07:51:58 <Cale> Closures don't actually exist at the level of language semantics.
07:52:21 <osfameron> really?
07:52:32 <phobes> Cale:  I think it's fruitful to distinguish between closures and just any first class function (C arguably has first class functions), but distinguishing between functions with bound parameters and the only reasonable implementation of that ...
07:52:33 <osfameron> you can reason over which scope is closed over etc.
07:52:34 <Cale> At that level, you should be talking about first class functions and scoping and such, but not closures. Closures are the data structures used to implement those features.
07:52:36 <ricky_clarkson> Is there a non-Cale resource that agrees with that, Cale?
07:52:51 <Cale> ricky_clarkson: yes, the paper which introduced closures.
07:52:56 <Cale> Also, say, SICP.
07:52:57 <ricky_clarkson> Which is?
07:53:05 <Cale> I could go find it...
07:53:10 <pjd> ricky_clarkson: the original Scheme report
07:53:21 <Cale> that sounds right
07:53:34 <pjd> ricky_clarkson: note that i interpret it oppositely to Cale
07:53:40 <ricky_clarkson> R1RS, or is there another term to plug into google?
07:53:45 <pjd> the matter seems to be pretty subjective
07:53:48 <quicksilver> I think the java thing is pretty close
07:53:53 <Cale> Closures were defined as a means of implementing first class functions.
07:53:58 <quicksilver> it is a chunk of code, together with a pointer to a environment
07:54:12 <quicksilver> but the environment in this case is a small java object
07:54:21 <quicksilver> then again, everything is an object in java so that's not surprising
07:54:26 <quicksilver> that's close enough to 'a pair' to me
07:54:36 <phobes> Cale:  Closures implement first class *parameterized* functions
07:54:44 <Cale> quicksilver: When I think of a closure, I think of something that looks like it has the type (AST, Map String Val)
07:54:59 <Cale> (or similar)
07:55:04 <quicksilver> Cale: except you don't really care if it's String, surely
07:55:08 <Cale> of course.
07:55:18 <quicksilver> well, the java one is very like that
07:55:27 <quicksilver> instead of String you have an index into the object table
07:55:34 <quicksilver> or however it is the JVM works
07:55:41 <quicksilver> private variables are 'numbered' IIRC?
07:55:58 <quicksilver> so you're using the property table of a small object as the Map String Var
07:55:58 <Cale> quicksilver: Well, now you're talking about the implementation of Java all of a sudden :)
07:56:03 <pjd> ricky_clarkson: http://library.readscheme.org/servlets/cite.ss?pattern=Suss-75
07:56:06 <quicksilver> right well
07:56:08 <RayNbow> quicksilver, I can't find the old code where I wrote a separate class... but apparantly Java indeed does have closures...
07:56:14 <quicksilver> you wanted to talk about implementation details :)
07:56:19 <RayNbow> http://pastebin.ca/859961 <-- it just needs the final keyword
07:56:20 <Cale> So I'd say it's something which looks like it's implemented as a closure.
07:56:21 <quicksilver> or that's how I interpreted your common
07:56:27 <Cale> But not that it's actually a closure itself.
07:56:30 <quicksilver> I'd buy that
07:56:36 <quicksilver> RayNbow: ah that's right.
07:56:39 <quicksilver> RayNbow: I remember now :)
07:56:56 <quicksilver> RayNbow: I was pretty close :)
07:57:02 <Cale> Also, note that you can perform operations on closures which you simply can't perform on first class functions.
07:57:03 <ricky_clarkson> From SICP: "A closure is an implementation technique for representing procedures with free
07:57:06 <ricky_clarkson> variables. We do not use the word ``closure'' in this second sense in this book."
07:57:20 <phobes> ah yes, you need the final keyword... maybe that's all I was remembering
07:57:26 <ricky_clarkson> What other implementation techniques exist?
07:57:38 <osfameron> so when we say "closure" we really mean "procedure with free variable" ?
07:57:49 <pjd> ricky_clarkson: FWIW, http://library.readscheme.org/servlets/cite.ss?pattern=Suss-75
07:58:05 <Cale> If I have a closure, I can rebind the free variables in the code after the fact, which is something that I'm not actually allowed to do with a first class function.
07:58:09 <phobes> I would say it's a technique for representing procedures with bound variables... not free variables
07:58:26 <Cale> phobes: The environment binds the free variables of the code.
07:58:46 <Philippa> right, they're free in the expression that defines the relevant value
07:58:48 <Cale> That is, it consists of mappings from those free variables to values.
07:58:49 <ricky_clarkson> Cale: I don't understand that about rebinding.
07:58:59 <Philippa> ricky_clarkson: imagine mutating a closure
07:59:11 <ricky_clarkson> Philippa: The code or the data it uses?
07:59:16 <Cale> ricky_clarkson: Well, if I have a closure, it's just a pair consisting of some code and a mapping. I can replace the mapping with a different one.
07:59:46 <Cale> That's not something that you can do with a function.
08:00:00 <xator> http://it.youtube.com/watch?v=fXWRL39XI2Y look this video
08:00:01 <lambdabot> Title: YouTube - ASTaRaTaTTaTTa
08:00:08 <ricky_clarkson> Cale: So you're saying a closure is Env -> t -> t2, but that languages make it look like a t -> t2?
08:00:18 <RayNbow> quicksilver: I can see now why Java wants the final keyword...
08:00:25 <Cale> yes
08:00:33 <Philippa> yep, in fact it's not unknown for compilers to do the reverse transformation en route
08:00:35 <Cale> If those are constructor types
08:00:37 <Philippa> it's called "lambda lifting"
08:00:37 <phobes> A closure is (Env, Env -> t -> t2)
08:00:45 <ricky_clarkson> RayNbow: Java wants final because that stuff is copied not referenced.
08:00:46 <Cale> yeah, that's a better representation
08:00:51 <quicksilver> RayNbow: although since java objects are by reference you can still mutate behind the closures back :)
08:01:29 <BMeph> And to be even more confusing (to me, anyway), Lua has first-class functions and closures.
08:01:29 <Cale> phobes: thanks for seeing through to what ricky_clarkson was actually suggesting, I would have missed that :)
08:02:00 <Cale> ricky_clarkson: If you're using higher-order syntax, phobes' type is good.
08:02:05 <RayNbow> it becomes fun if you create two anonymous classes and they are both referring to the same local variable... :p
08:02:12 <ricky_clarkson> Cale: Yes, I understand it.
08:02:19 <Cale> ricky_clarkson: but of course, the language makes that look like (t -> t2)
08:02:44 <ricky_clarkson> Cale: I'm having difficulty seeing this as a real difference, as it seems that (Env, Env -> t -> t2) is the only way of implementing a "language-level closure".
08:02:51 <quicksilver> BMeph: what annoys me about lua syntax is that a reference to an enclosing value is by default not an 'upvalue'
08:02:55 <Cale> It's just the most natural way.
08:02:55 <BMeph> Well, to be fair, Lua closures are not confusing at all.
08:02:56 <quicksilver> you have to ask for upvalues expicitly
08:03:06 <quicksilver> but non-upvalue is stupid :P
08:03:08 <Cale> You could, say, store environments somewhere else.
08:03:33 <Cale> Or use code rewriting.
08:03:34 <pjd> ricky_clarkson: if you want some more data points, see http://programming.reddit.com/info/1oooq/comments/c1pa23
08:03:45 <Cale> Or just do explicit graph rewriting.
08:03:48 <ricky_clarkson> I can see how code-rewriting would work.
08:04:04 <pjd> there was an extended discussion then
08:04:22 <phobes> Or you could create a new compiled version of the entire function with substituted parameters
08:04:29 <Cale> ricky_clarkson: Just copy the code and replace the variables inside it with their local values.
08:04:43 <ricky_clarkson> Cale: I said "can" :)
08:04:47 <Cale> ah
08:04:50 <Cale> hehe :)
08:05:13 <Cale> I'm a little bit out of it. I'm staying awake to get my hours turned around :)
08:05:17 <Cin> does cabal support uninstalling packages?
08:05:29 <Cale> Cin: unfortunately not.
08:05:32 <ricky_clarkson> Well, fyi Java supports what I call closures, and what you call closures.
08:05:40 <Cale> Cin: It's something I think most people would like to have though.
08:06:00 <Cin> cale: are you being sarcastic?
08:06:06 <ricky_clarkson> It doesn't support anonymous functions or code blocks though, which is the bone of contention.
08:06:11 <Cale> Cin: not at all.
08:06:20 <Cin> how depressing
08:06:23 <Cin> nevermind
08:06:28 <Cale> Cin: I'm saying, if you'd like to implement it, that would be great :)
08:06:49 <Cale> Cin: you can do  ghc-pkg unregister foo
08:06:56 <Cale> Cin: But it doesn't delete any files.
08:07:13 <Cale> It just makes GHC forget about them.
08:07:21 <phobes> Put the uninstaller in another program called canabal
08:07:32 <Cale> ricky_clarkson: right :)
08:08:24 <Cale> ricky_clarkson: I'd say that it's already using closures to implement some language features, but not first-class functions. (And this is why it's good to distinguish first-class functions from closures :)
08:08:49 <Cale> Another thing you can use closures to implement is functions with partly dynamically scoped variables.
08:09:08 <Cale> Just don't store those variables in the map, and implement a fall-through.
08:09:22 <pjd> nobody else uses the word "closure" for those things, though
08:09:46 <Cale> pjd: I think it's a bad habit.
08:10:15 <ricky_clarkson> It seems that objects replace Env in Java.
08:10:27 <Cale> and it results in needless arguments, like all those which have been had with regard to Java.
08:10:31 * ricky_clarkson retracts that.
08:10:51 <phobes> It results in needless arguments with Cale :)
08:11:07 <Cale> If people were talking about adding first-class functions with lexical scoping of variables to Java, I think there'd have been much less confusion over what people were suggesting.
08:11:26 <pjd> Cale: well, it would be good to separate what the word "closure" is generally used to mean, and what you think it should be used to mean :)
08:11:43 <pjd> language reform is not retroactive
08:11:58 <phobes> This is like the "dynamic type" argument
08:12:06 <Cale> right, and I'm suggesting the sanest way to do that is simply to stop using it in this colloquial sense to mean what it's most commonly used to implement.
08:12:21 <Cale> Note that closures are *also* used to implement objects, in, say, smalltalk.
08:12:48 <Cale> And objects are much different from first class functions, because they maintain state which is externally mutable.
08:12:49 <dcoutts> I go away for half an hour, come back and find you lot still discussing first class and closures?
08:13:00 <idnar> heh
08:13:06 <byorgey> dcoutts: well, what did you expect?
08:13:30 <noteventime> Can (.) only be used with single argument functions? O_o
08:13:30 <dcoutts> that you might have got to the bottom of the issue? :-)
08:13:43 <phobes> i'm hoping that we're nearing bottom
08:13:45 <mightybyte> > :t .
08:13:45 <lambdabot>  Parse error at end of input
08:13:48 <ricky_clarkson> noteventime: there are no other kinds
08:13:51 <mightybyte> > :t (.)
08:13:53 <lambdabot>   parse error on input `:'
08:13:58 <dcoutts> noteventime: all functions have only a single argument, so yes ;-)
08:13:59 <byorgey> :t (.)
08:14:00 <ricky_clarkson> :t (.)
08:14:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:14:01 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:14:06 <mightybyte> Ok
08:14:14 <Philippa> ricky_clarkson: a lot of people would say it's not a closure if you're not performing a lexical closure to create it. Which Java doesn't.
08:14:30 <noteventime> dcoutts + ricky_clarkson: You know very well what I mean :-P
08:14:34 <byorgey> noteventime: a function with a type like a -> b -> c is really a function of one argument (a) that returns another function (b -> c)
08:14:42 <ricky_clarkson> Philippa: I don't know what performing a lexical closure is.
08:14:45 <noteventime> Can (.) only be used with non-high level functions
08:14:48 <dcoutts> noteventime: well, the answer is still yes, sort of
08:15:02 <byorgey> noteventime: (.) can be used with any functions.
08:15:11 <dcoutts> @pl \f g x y -> f (g x y)
08:15:11 <lambdabot> (.) . (.)
08:15:15 <dcoutts> noteventime: ^^
08:15:20 <byorgey> there's no difference in Haskell between 'high-level' and 'non-high-level' functions
08:15:34 <dcoutts> noteventime: for example, but it starts to get a little silly
08:15:38 <noteventime> Err, higher-order then?
08:15:43 <noteventime> I'm not used to the terminology
08:15:47 <Saizan> > (((==0) .) . (+)) 2 3 5
08:15:47 <ricky_clarkson> noteventime: We knew what you meant, but pointing out that about functions helps you to realise that (.) cannot possibly only work with one-arg functions.
08:15:47 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `Bool'
08:15:55 <byorgey> noteventime: that's what I meant.
08:16:16 <noteventime> byorgey: I beg your pardon
08:16:18 <noteventime> ?
08:16:56 <mightybyte> ricky_clarkson Hmmm, but the signature of (.) seems to indicate that at the most basic level, it does only work with one-arg functions.
08:17:01 <phobes> noteventime:  I think the answer to your question is that it doesn't do what you want
08:17:03 <mightybyte> ...depending on your definition of "work".
08:17:24 <pjd> :t (.).(.)
08:17:25 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
08:17:25 <phobes> noteventime:  If you want to make a function that passes along multiple results to another function, you need to tuple the results
08:17:28 <pjd> :t (.).(.).()
08:17:34 <Cale> noteventime: It only works with one-parameter functions, but those include functions which take a function as a parameter, and those which return a function as a result.
08:17:34 <lambdabot>     Couldn't match expected type `a -> b -> c'
08:17:34 <lambdabot>            against inferred type `()'
08:17:34 <lambdabot>     In the second argument of `(.)', namely `()'
08:17:34 <noteventime> Let's say foo :: a -> a -> a -> b and bar :: b -> c. foo . bar doesn't give a function a -> a -> a -> c?
08:17:40 <pjd> err
08:17:41 <pjd> :t (.).(.).(.)
08:17:41 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
08:17:49 <byorgey> noteventime: when I said there's no difference between "high-level" and "non-high-level" functions, I wasn't trying to say you were using incorrect terminology, I was just saying that in Haskell, functions are functions.
08:17:52 <pjd> you can stack them like that indefinitely
08:18:20 <phobes> noteventime:  what are you trying to do?
08:18:21 <Cale> noteventime: But you can't directly use (.) to express f (g x y), you have to do some tricks, like the others are pointing out :)
08:18:34 <Cale> phobes: yes, that's the right question to ask :)
08:18:36 <dcoutts> noteventime: I find most people prefer a mixed style where you don't use silly tricks
08:18:43 <Philippa> mightybyte: Haskell only has single-parm functions
08:18:49 <Tac-Tics> @pl (.) (.)
08:18:49 <lambdabot> ((.) .)
08:18:58 <dcoutts> noteventime: like: foo f = bar f . baz
08:19:01 <Philippa> it turns out that they're enough to do everything
08:19:03 <noteventime> phobes: Combining a constructor of a vector class with the function to normalise a vector
08:19:15 <dcoutts> noteventime: rather than:
08:19:15 <dcoutts> @pl \f -> bar f . baz
08:19:15 <lambdabot> (. baz) . bar
08:19:22 <dcoutts> which is silly :-)
08:19:24 <dcoutts> though cute
08:19:49 <mightybyte> Philippa: Yes.  And currying blurs the difference.
08:19:50 <phobes> Cale:  ok, so you had it right :)
08:20:37 <noteventime> So it's not a problem. I was just wondering how it worked :-)
08:20:42 <noteventime> Thanks for the help
08:20:55 <vincenz> the only reason it's a problem in other languages, e.g. C, is because tuples are not first clcass
08:21:01 <noteventime> I can just as well do normalise $ Vector x y z
08:21:01 <Philippa> mightybyte: if you're seeing blur, you're looking at it the wrong way
08:21:04 <phobes> (normalize . mkVector) 1 2 3 isn't going to do what you want
08:21:06 <tibbe> dcoutts: does cabal sometimes separate record types into modules and some prefix them or is it always one of the two?
08:21:20 <Philippa> barring class constraints, any type variable can be instantiated with a function type
08:21:33 <dcoutts> tibbe: it goes with the prefix rather than module-qualified style generally
08:21:41 <Philippa> so a -> b can instantiate to Int -> (Int -> Bool), more commonly written Int -> Int -> Bool
08:21:44 <dcoutts> tibbe: don't feel you have to follow that though
08:22:23 <mightybyte> Philippa:  Hmmmm...I'm not saying that it's a bad thing.  It just allows us to use one-arg and multi-arg almost interchangeably.
08:22:44 <tibbe> dcoutts: right, just curious
08:23:01 <tibbe> dcoutts: I'm done with my config module now, thanks! (I'll add some more flags later)
08:23:10 <mightybyte> Philippa: Is there something else I'm still missing?
08:23:16 <dcoutts> tibbe: good good, this is for a web server you say?
08:23:37 <Philippa> mightybyte: it doesn't though - if someone's talking that way about a haskell function it means that they're looking at it via the currying isomorphism
08:23:40 <tibbe> dcoutts: yes, an application server (like python's wsgi reference implementation)
08:23:48 <Philippa> it doesn't make sense to talk about the distinction without it
08:23:53 <tibbe> dcoutts: for web apps, not for serving static content (although it could)
08:24:12 <dcoutts> tibbe: interesting
08:24:46 <tibbe> dcoutts: I guess the most important part is figuring out an interface (like WSGI) haskell web apps and web servers can standardize on
08:24:46 <dcoutts> tibbe: so do you need to store config as well as get command line params?
08:25:04 <tibbe> dcoutts: probably, it's convenient to be able to configure the server via a file too
08:25:10 <tibbe> and I want a dead simple server
08:25:28 <tibbe> basically you say: runServer <a plain old handler function>
08:25:37 <tibbe> settings are read from the command line
08:25:38 <tibbe> or file
08:25:44 <dcoutts> tibbe: that's where the mappend for Flags is really useful, for taking any saved config and overriding from the command line
08:25:46 <tibbe> or optionally you can pass a Config struct
08:25:52 <phobes> Cale:  So did you or dons ever write up that argument in favor of laziness?
08:25:59 <tibbe> dcoutts: that was the part I got from your email :)
08:26:03 <dcoutts> right
08:26:22 <Cale> phobes: I've written it up several times in reddit comments...
08:26:29 <phobes> hmm
08:26:48 <phobes> Ill see if I can find it then
08:27:20 <dcoutts> tibbe: good, I felt slightly like I was talking to myself posting that stuff about flags being monoids :-)
08:27:25 <Cale> I'll look :)
08:27:38 <Cale> they would have been a ways back
08:27:38 <tibbe> dcoutts: I'm planning to do a write up on some of the possible design decisions regarding such an interface
08:27:43 <tibbe> dcoutts: it made perfect sense to me
08:28:28 <tibbe> dcoutts: the big design decision is if the environment passed to the web app should be a dictionary of strings or a typed record
08:28:34 <dcoutts> tibbe: this is an interface for pages to talk to a host/server
08:28:46 <tibbe> well
08:28:47 <mightybyte> Philippa: So what are you saying is the right alternative to looking at haskell through the currying isomorphism?
08:29:07 <tibbe> it should make it possible for web frameworks to use different servers and different servers to host different frameworks
08:29:20 <dcoutts> tibbe: how about an HTTP headers set and a dict of post/get strings?
08:29:21 <Cale> It'll spare you my endless litany of "Not programming." comments.
08:29:21 <Philippa> to just say "function from a to b" without talking about arity at all
08:29:23 <tibbe> dcoutts: the WSGI PEP describes it really way in my opinion
08:29:33 <phobes> Cale:  hehe, I can't even find you!
08:29:38 <Cale> cgibbard
08:29:40 <phobes> Is there a way to search for users?
08:29:42 <tibbe> dcoutts: it's really worth a read, and if you read it I could have someone to discuss the design with :)
08:30:06 <mightybyte> Philippa: Ok...basically understand it from the most basic level.
08:30:16 <dcoutts> tibbe: I'm not really a web hacker, there are much more informed people to talk to
08:30:18 <phobes> ok, I was using the wrong handle... google found you
08:30:34 <Cale> http://programming.reddit.com/info/2xtua/comments/c2y67p
08:30:40 <phobes> "I thoroughly disagree that laziness is an inappropriate default.,.."
08:30:44 <phobes> Is it that one?
08:30:53 <Cale> The one I just linked to.
08:31:02 <tibbe> dcoutts: actually it touches many of the same problems as cabal like making a backwards compatible interface
08:31:02 <Cale> (which is a number of months back)
08:31:08 <tibbe> dcoutts: it's also all about composability
08:31:17 <phobes> lenient evaluation.. heh, were you arguing with sweeney?
08:31:18 <tibbe> dcoutts: very little about HTTP, sockets, etc
08:31:43 <Cale> http://programming.reddit.com/info/2xtua/comments/c2y5af -- this has some more
08:31:45 <dcoutts> tibbe: btw, we're looking for a better hackage web framework, alexj and I were considering HAppS
08:31:51 <mightybyte> Philippa: I guess the issue comes up because most people have been conditioned by the non-functional world where function arities matter.
08:32:25 <tibbe> dcoutts: mine will be much, much simpler than happs
08:32:26 <dcoutts> tibbe: the current hackagedb website is apache+cgi+compiled-.hs-progs
08:32:32 <tibbe> dcoutts: happs is not really to my tast
08:32:38 <tibbe> taste*
08:32:53 * Cale suddenly realises that he should perhaps try to preserve a few of these comments :)
08:33:09 <dcoutts> tibbe: it sounded good to me because of the way it solves the problem with state and serving multiple clients simultaneously
08:33:12 <phobes> hehe
08:34:02 <Philippa> mightybyte: right. Which is why functional people getting it right in front of everyone else matters :-)
08:35:07 <mightybyte> Philippa: Definitely
08:35:48 <tibbe> dcoutts: I'm not saying it's bad, I'm saying it doesn't fit my idea of an application server
08:35:56 <dcoutts> tibbe: sure
08:36:12 <mightybyte> tibbe: I've been looking at happs recently.  What don't you like about it?
08:36:28 <tibbe> mightybyte: it tries to done way way to much
08:36:44 <tibbe> mightybyte: and from what I've seen it's not composable like WSGI
08:36:50 <mightybyte> tibbe: Ahh, well I may or may not disagree with that.
08:36:58 <tibbe> mightybyte: :)
08:39:51 <phobes> Cale:  It looks like most of these arguments are for laziness vs. the way alot of people write Java programs, as opposed to vs. explicit streams
08:41:34 <Cale> phobes: well, specifically, the argument for laziness as default consists of the bullet points in the first comment I linked to above, together with the remark that in lazy-optional languages, the libraries are strict, which ruins compositionality.
08:42:17 <mightybyte> tibbe: Talking with some of the developers yesterday I came to the realization that they seem to be heading towards a complex state handling system when the start working on data sharding.
08:42:26 <Cale> (as if you need to apply a strict function in the middle of your computation, you either have to rewrite it to be lazy, or else strictify your computation there, which is usually not an option)
08:43:10 <mightybyte> tibbe: And it does seem like that should be separated from the web serving aspect.
08:43:12 <tibbe> mightybyte: I'd do data sharding as small separate web servers with a REST like interface
08:43:34 <tibbe> mightybyte: so my server won't serve file at all unless you write a web app that does it
08:43:47 <mightybyte> tibbe: They seem to be doing it well, but that's not necessarily apparent due to the fact that it all still falls under the HAppS moniker.
08:43:52 <Cale> phobes: There are simply more cases where laziness is better or equivalent to strict evaluation.
08:43:59 <Cale> phobes: so it makes a better default
08:44:29 <mightybyte> tibbe: How much are you concerned with scalability?
08:44:37 <Cale> and it improves compositionality of programs greatly, by allowing you to separate logic which selects things from logic which generates them
08:45:01 <Cale> (which lets you reuse those parts separately)
08:45:03 <phobes> Cale:  I think pretty much any generator should be lazy
08:45:15 <Cale> yes
08:45:33 <tibbe> mightybyte: quite concerned
08:45:35 <phobes> Cale:  Actually, 'lazy' is the wrong word
08:45:37 <Cale> well, it should produce a lazy structure
08:45:59 <phobes> Cale:  It needn't be lazy - it could even just be a function
08:46:04 <phobes> (with no memoizing at all)
08:46:15 <mightybyte> tibbe: And how do you approach back-end persistence?  The HAppS guys seem to be wanting to make relational databases unnecessary on the back-end.
08:46:50 <tibbe> mightybyte: depends on the server type, perhaps like google's bigtable
08:47:02 <tibbe> mightybyte: i.e. in memory data structure and transaction log
08:47:23 <phobes> Cale:  If you use generators instead of lazy lists, you don't have to worry about space leaks
08:47:35 <phobes> (you just have to worry about recomputation)
08:47:39 <Cale> phobes: Aren't those the same thing?
08:47:55 <phobes> Cale:  Aren't what and what the same?
08:48:10 <Cale> Generators and lazy lists.
08:48:15 <mightybyte> tibbe: That's something I'm grappling with.  Relational -vs- HAppS state -vs- something else non-relational.
08:48:27 <Cale> Well, they're lazy lists with possible side effects, okay.
08:48:41 <tibbe> dcoutts: hmm, some flag defaults would require doing IO, like a --log=$CWD/bla.log since $CWD requires IO
08:48:52 <tibbe> mightybyte: couchdb is nice in that sense
08:49:06 <phobes> Cale:  No, I just meant generator = function producing the values one at a time (not memoized)
08:49:09 <quicksilver> mightybyte: I like relational.
08:49:12 <tibbe> mightybyte: ie an alternative to relational, relational is hard to scale
08:49:12 <Cale> The only place where you'll get a space leak with lazy lists is if you hang on to the elements of the list, which you'll get if you hang on to all the results of the generator too.
08:49:25 <quicksilver> mightybyte: I think the hAppS approach is nice for its "simplicity"
08:49:28 <dcoutts> tibbe: no need to do the IO during command line parsing
08:49:40 <quicksilver> mightybyte: not simple to write, obviously, because it wasn't. But simple for the client application.
08:49:40 <phobes> Cale:  You get a space leak by holding on to the list - not by holding on to the generator
08:49:47 <dcoutts> tibbe: eg cabal handles path vars, it just parses them into a template which it expands later
08:49:54 <mightybyte> quicksilver: Yes, happs does seem to be pretty simple.
08:49:59 <tibbe> dcoutts: right, but it means I simply cannot define defaultFlags :: Flags
08:50:02 <quicksilver> mightybyte: however, I think relational is great for complex applications, which genuinely need complex queries.
08:50:17 <quicksilver> mightybyte: I use relational DBs in my real jobs, and although I despise SQL with a passion, it sure it useful.
08:50:38 <tibbe> quicksilver: I don't use relational at all :)
08:50:51 <dcoutts> tibbe: cabal does that, it uses the template thing and expands it later
08:50:53 <Cale> phobes: that's a minor interface detail. It's easy to recurse down a list in such a way that after you've processed an element, it can be reclaimed.
08:51:06 <mightybyte> quicksilver: What I'm trying to decide is how much relational really benefits in the face of high scalability requirements and unforseen data querying patterns down the road.
08:51:08 <tibbe> dcoutts: could you give me a pointer to the code
08:51:10 <Cale> (just use map, for instance)
08:51:18 <quicksilver> mightybyte: "show me running totals by week of all customer purchases made in the south or east of england, where the customer has taken advantage of at least one special offer and have made at least four purchases before"
08:51:19 <dcoutts> tibbe: ie it has a pure representation of "$CWD/bla.log"
08:51:29 <tibbe> dcoutts: I see
08:51:35 <phobes> Cale:  hmm, really?
08:51:39 <quicksilver> mightybyte: It's not precisely that that kind of stuff is hard to expression in (e.g.) pure haskell.
08:51:41 <mightybyte> quicksilver: I haven't used RDMBS's for quite awhile, so my familiarity with them is waning.
08:51:42 <quicksilver> mightybyte: it isn't.
08:51:43 <dcoutts> tibbe: see defaultInstallDirs in Distribution/Simple/InstallDirs.hs
08:51:52 <quicksilver> mightybyte: but , the obvious expression in pure haskell will run very slowl.
08:51:54 <tibbe> dcoutts: but then you need to keep track which strings might include template vars no?
08:52:08 <quicksilver> mightybyte: point being, RDBMSes know how to use indexes to copute queries efficiently.
08:52:12 <phobes> Cale:  As long as the original list is still around, you're going to get the space leak, even if you used map on it, right?
08:52:19 <dcoutts> tibbe: perhaps, or it might be generic if they're just environment vars
08:52:34 <mightybyte> quicksilver: Yeah, but if you haven't indexed the data in the way you want to query it, you're dead.
08:52:45 <Cale> phobes: not if something isn't hanging onto the head of the list as the rest gets evaluated.
08:52:48 <dcoutts> tibbe: in that code you'll notice that it actually does do IO because of the windowsProgramFilesDir thing, but in principle that could be another path var
08:52:49 <quicksilver> mightybyte: however, the RDBMS makes it easy to add a new index
08:52:55 <phobes> Cale:  But what if something is?
08:52:56 <quicksilver> mightybyte: and then your query will automatically use it
08:52:56 <tibbe> dcoutts: what do you mean? you apply the expansion to all strings?
08:53:05 <quicksilver> mightybyte: whereas, if you were "just coding" in haskell
08:53:11 <quicksilver> mightybyte: you'd have to rewrite your algorithms to use the new index.
08:53:17 <phobes> Cale:  Example, you have a function processResults :: [Int] -> (A, B, C)
08:53:20 <Cale> phobes: then it'll have to hang on to it. It's like hanging on to the results of calling your function.
08:53:22 <mightybyte> quicksilver: Ahh
08:53:36 <dcoutts> tibbe: we have a type PathTemplate and a function for expanding the templates to a plain String
08:53:43 <Cale> If you don't need them anymore, then let them go, and you won't have a space leak :)
08:53:46 <quicksilver> mightybyte: so, my argument is that the main advantage of RDBMSes is their query planners. If you think you can do better than the query planner "by hand" then you may as well not bother.
08:53:47 <phobes> Cale:  A, B, C are all generated using map-fold
08:53:54 <quicksilver> mightybyte: and for small data sets, of course, it normally doesn't matter a jot.
08:54:00 <dcoutts> tibbe: and so we parse some command line flags as a template
08:54:18 <mightybyte> quicksilver: So then the question is how well RDMBSes scale.
08:54:24 <quicksilver> mightybyte: equally, I think RDBMSes perform pretty well in the face of "unforseen querying patterns"
08:54:27 <tibbe> dcoutts: I see
08:54:30 <quicksilver> mightybyte: better than hand-written code, I imagine :)
08:54:39 <tibbe> dcoutts: is the user allowed to use the template vars as well?
08:54:47 <tibbe> dcoutts: or is the user input sanitised
08:54:55 <mightybyte> quicksilver: Well, it seems like that is what the HAppS guys are trying to make false.
08:55:00 <tibbe> dcoutts: I only need it for the defaults not for user expansion
08:55:02 <quicksilver> mightybyte: unless, effetively, you end up writing your own query engine in haskell
08:55:13 <quicksilver> mightybyte: which you can do. IN simple cases it's not particularly hard.
08:55:22 <phobes> Cale:  But in the example I just gave, assume the [Int] parameter is a long lazy list.  Won't GCH keep the result of that around between map/folds?
08:55:38 <quicksilver> mightybyte: and if there is something rather specific about your domain, which makes the normal SQL dbs suboptimal, then you may be wise in doing so.
08:55:46 <dcoutts> tibbe: I see, then it's probably simpler to just go with defaultFlags :: Whatever -> Flags
08:56:07 <dcoutts> tibbe: supplying the CWD as a parameter
08:56:11 <mightybyte> quicksilver: It seems to me that RDBMS is good at flexible querying but weak on scalability.  If they happs guys get multimaster and sharding working properly, then it seems like the state approach will be strong on scalability and weak on querying.
08:56:17 <Cale> phobes: well, certainly if you refer to the parameter multiple times in the body of the function, results of evaluation will be shared.
08:56:25 <travisbrady> mightybyte: you might check out MonetDB if you need high performance on read intensive queries
08:56:41 <Cale> phobes: but it really depends on how that function is written.
08:56:42 <phobes> Cale:  How do you write the body of that function in such a way that the results aren't kept?
08:56:44 <quicksilver> mightybyte: your database has to be HUGE for scalability to be an issue.
08:56:46 <travisbrady> mightybyte: or perhaps this new hypertable thing with kfs
08:56:50 <quicksilver> mightybyte: if it is, then, fair enough.
08:56:51 <mightybyte> travisbrady: Ok, thanks.  Although I don't really know what I need yet. :)
08:57:06 <quicksilver> mightybyte: but current-generation hardware easily supports hundreds of queries a second on multi-GB data sets.
08:57:16 <quicksilver> mightybyte: using, say, postgresql.
08:57:30 <travisbrady> mightybyte: incidentally i'm working on exactly this problem right now and i'd love to write a little haskell query engine if it could be parallelized easily enough
08:57:37 <quicksilver> mightybyte: DBs which genuinely need to scale over more than one machine are relatively few and far between.
08:57:39 <sclv_> My understanding is that there's some excellent work on scalability in RDBMS but that it is fancy high-end stuff that yr. typical MySQL or even Oracle user wouldn't come into contact with.
08:57:50 <mightybyte> quicksilver: Ok, I'm willing to go with that.  But my next question would be how hard it would be to re-tool if scalability ends up being an issue.
08:57:52 <Cale> phobes: to clarify what you mean, you want it to be possible to evaluate A, say, then drop it, and have the evaluation already done on the input list forgotten?
08:58:03 <mightybyte> ...i.e. I become the next Google ;)
08:58:35 <Cale> That sort of thing can be tricky, but it's easy if you just separate your 3-tuple returning function into 3 separate functions.
08:58:38 <phobes> Cale:  Yes, because I'm assuming generation of elements is cheap, whereas keeping the giant chunk of memory around is expensive
08:58:59 <quicksilver> mightybyte: by then you can normally afford to buy better hardware :)
08:59:05 <quicksilver> mightybyte: and/or an oracle license.
08:59:19 <phobes> Cale:  Splitting the function into 3 may or may not solve the problem - it just pushes the problem of "don't use this more than once" one level higher
08:59:28 <mightybyte> quicksilver: But I don't think that would have worked for google.
08:59:28 <Cale> hm?
08:59:31 <quicksilver> mightybyte: one of those 64-core sparcs ought to give you a little more elbow room.
08:59:35 <quicksilver> mightybyte: No, it wouldn't.
08:59:39 <quicksilver> mightybyte: not everyone is google, though.
08:59:44 <mightybyte> ...which was my concern.
08:59:49 <quicksilver> (in fact, only one organisation is google) ;)
08:59:57 <quicksilver> they are a very rare case. an interesting one, though.
09:00:16 <phobes> Cale:  Basically, as soon as you have the value for the generator, you can only do one thing with it, or you get sharing and a space problem
09:00:21 <Cale> phobes: well, it might be that it's the wrong datastructure for your particular case, but I must admit this kind of thing hasn't shown up very often in my code :)
09:00:28 <mightybyte> Yes.  I'm not so much interested in that extreme case because of the likelihood of me getting there as the inherent difficulty of the problem.
09:00:35 <quicksilver> mightybyte: ah well.
09:00:36 <phobes> Cale:  You can always thunkify the list
09:00:40 <quicksilver> mightybyte: Yes, it's an interesting problem :)
09:00:59 <Philippa> mightybyte: google build their own stuff, they've got the resources for major rewrites
09:01:03 <quicksilver> mightybyte: I'd love to write a relational qury engine which supports smooth replication.
09:01:04 <hpaste>  oxymoroon pasted "xmonad.hs -- wheel actions" at http://hpaste.org/5082
09:01:10 <phobes> Cale:
09:01:12 <mightybyte> Wouldn't we all
09:01:13 <quicksilver> mightybyte: I have some ideas about it, I don't think it's that hard in principle.
09:01:21 <tibbe> dcoutts: that sounds like a good idea, I was actually thinking of doing IO Flags but passing it makes it easier to supply a test value intead
09:01:22 <quicksilver> mightybyte: but, I don't have much time to work on it :)
09:01:38 <phobes> Cale:  But it seems like I get better control with just using generators (no hidden memoizing), so I'm trying to find the "gotcha" cases I'm forgetting
09:02:18 <Cale> Well, working with lists is a good deal more natural, typically.
09:02:30 <mightybyte> When I look at these big companies, it seems like they had to make vast changes to cope with their growth, so I guess it wouldn't be a terrible thing to underestimate on scalability at the outset.
09:02:39 <Cale> Could you be clearer about what you mean by a generator?
09:02:41 <phobes> Cale:  The interface of what I'm proposing is essentially the same ... it's just you get no sharing
09:02:57 <Cale> You mean, using normal-order rather than lazy evaluation?
09:03:45 <phobes> Cale:  hmm.  Well, I guess it would be similar to that.
09:04:21 <Cale> Well, the only difference between lazy evaluation and normal-order evaluation is sharing :)
09:04:40 <phobes> Cale:  Right, but obviously the langauge I'm talking about isn't normal order evaluation
09:05:03 <Cale> Perhaps you'd like a syntax for explicitly splitting a variable?
09:05:07 <phobes> Cale:  It's strict, but with a discipline of thunking for some datatypes (under the covers) that would be similar to normal order evaluation for those datatypes
09:05:43 <Cale> In my experience, these problem cases are extremely rare, and usually easily solved.
09:08:43 <dons> well, i'm happy, generating 10M Int64s using StdGen, 3.582s. and using mersenne-random, 0.264s :)
09:09:01 <dons> the C lib does it in 0.250s
09:09:07 <Cale> Cool :)
09:09:08 <quicksilver> dons: nice
09:09:24 <quicksilver> generating + throwing away, or generating + doing somethign with?
09:09:24 <Igloo> Is that a Mersenne Twister?
09:09:27 <dons> now, just have to make it threadsafe, and we've a non-slow Random replacement. (System.Random is *really* slow!)
09:09:31 <dons> Igloo: yeah
09:09:35 <Igloo> Cool
09:09:37 <dons> quicksilver: just summing 10M randoms
09:09:44 * quicksilver nods
09:09:48 <dons> this is a binding to the sse2 variant of the C MT.
09:09:57 <Cale> phobes: It would be interesting though, to introduce a syntax for explicit splitting as an immediate solution to any problem of that sort.
09:10:16 <Igloo> Ah, so we'd have library pain if we wanted to use it as a replacement in the standard libraries?
09:10:24 <phobes> Cale:  Ya, that would be interesting
09:10:43 <dons> well. not necessarily, Igloo. its portable, just a small amount of configure required.
09:10:53 <Cale> phobes: another solution that usually suffices is simply to pass a function which results in the lazy list, and call it 3 separate times.
09:10:54 <dons> i.e. for max speed you set -msse2 or -maltivec
09:10:56 <dons> but its ok without
09:11:08 <dons> Igloo: i'm looking to make it a viable replacement
09:11:12 <phobes> Cale:  That was my point about passing a thunkified list ()->[Int]
09:11:19 <Cale> ah, okay
09:11:27 <Cale> That's not what I'd have called that :)
09:11:34 <phobes> hehe sorry :)
09:11:38 <Cale> But I see where you're getting it :)
09:11:50 <quicksilver> isn't a thunkified list data List a = Empty | Cons a (() -> List a)
09:11:51 <quicksilver> ?
09:12:11 <phobes> quicksilver:  That's deep thunkification :)
09:12:29 <quicksilver> thanks,
09:12:41 <quicksilver> Dig that groovy thunk.
09:13:31 <Cale> It's curious how these problems are so much easier to spot in a graph reduction language which actually displays the graphs visually.
09:13:52 <dons> Igloo: if you're curious, http://code.haskell.org/~dons/code/mersenne-random
09:13:53 <lambdabot> Title: Index of /~dons/code/mersenne-random
09:13:54 <quicksilver> once again, it would be lovely to have a graph reduction visualiser for haskell.
09:14:09 <quicksilver> along the lines of the DFA NFA visualiser we were looking at the other day
09:14:18 <Cale> yeah, something like HOPS
09:14:29 <quicksilver> unreachable stuff could turn gray and slowly fade out over the next few frames.
09:14:40 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/
09:14:41 <lambdabot> Title: HOPS
09:14:57 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
09:14:57 <lambdabot> Title: HOPS - Animations
09:15:15 <quicksilver> yeah, along those lines.
09:15:27 <byorgey> @remember sclv B-but, (and here's the ironic part), launchMissile is only idempotent if the missile is atomic.
09:15:27 <lambdabot> Done.
09:15:32 <byorgey> hah!
09:15:49 <quicksilver> Cale: But I'd make the differnce between thunk and value more striking
09:16:02 <quicksilver> Cale: have thunks in circles and values in sqaure boxes, or something.
09:16:16 <quicksilver> where by "value" I include constructor
09:16:21 <quicksilver> not just complete values.
09:16:29 <Cale> quicksilver: But there's no difference between them there :)
09:16:41 <dons> Igloo: a lot of the conversions done in System.Random are very inefficient.
09:16:42 <quicksilver> there would be in haskell though
09:16:50 <Cale> Or you mean, mark the reducible expressions somehow?
09:17:04 <quicksilver> I mean, suppose you're reducing map (+1) [1,2,3]
09:17:11 <quicksilver> at one stage you'd have:
09:17:12 <dons> i.e. even though StdGen returns an Int, on next, random takes that Int, casts to an Integer, mods it by maxBound int back to an Int, and returns the result
09:17:23 <dons> and there's no special support for Double
09:17:25 <quicksilver> (2) -- (:) -- [[ map (+1) [2,3] ]]
09:17:36 <quicksilver> Cale: "2" and ":" are what I meant by values.
09:17:44 <quicksilver> Cale: the map part is still a thunk
09:19:55 <dons> Igloo: also, parts of Random are unused. maybe its not ideal anyway?
09:20:28 <dons> I'd like a RandomGen that allowed plugging custom generators for Doubles, and Words
09:21:12 <dons> does a better, statistically, random generator immprove the quality of our QuickChecks?
09:21:38 <dcoutts> dons: it's quite possible to use your own custom generator
09:21:56 <quicksilver> well it certainly seems that good quality uniformity is good for quickchek
09:22:03 <dons> dcoutts: for Arbitrary?
09:22:03 <dcoutts> the generator is not related to the types of random things you generate iirc
09:22:06 <quicksilver> I don't think it cares much about higher-order properties though
09:22:20 <dons> dcoutts: i thought Arbitrary used StdGen, hardwired
09:22:21 <dcoutts> dons: oh, perhaps QC's Arbitrary only uses StdGen
09:22:22 <Igloo> I suspect the current random is perfectly adequate for QC, but IANAstatistician
09:22:39 <quicksilver> for example, a poor randomgen has a correlation between one value and the next
09:22:46 <quicksilver> but it's not clear how much that matters for QC in general
09:22:49 <quicksilver> probably not a lot
09:22:56 <quicksilver> as long as a wide range of values is produced
09:23:16 <dons> dcoutts: yeah, at first i wanted to just plugin in MersenneGen as a System.Random RandomGen instance
09:23:19 <dcoutts> dons: it could probably be changed to accept any RandomGen
09:23:24 <dons> but all the conversions in System.Random are horrible
09:23:42 <dons> goes from 0.25s to 4s or so, due to inefficient Int handling
09:23:49 <dons> more complex random values are even worse
09:24:15 <dcoutts> dons: you mean the Int output of the next is converted into the various other type inefficiently
09:24:39 <dons> yeah, e.g. Random Int, goes via Integer :(
09:24:47 <dcoutts> heh heh :-)
09:25:05 <dons> so even if you have a good generator for say, real values, System.Random can't use it.
09:25:15 <dons> because the instances are fixed.
09:25:26 <dcoutts> dons: but do any real RNGs work natively with floating point?
09:25:46 <dons> the mersenne one has good generators for Doubles of various precision, i guess others do
09:25:54 <dcoutts> dons: so long as the projection from Int -> a is ok then you should get good random numbers
09:25:57 <dons> i've mainly looked at MT, since i needed it for the monte carlo paper
09:26:11 <dcoutts> hmm
09:26:36 <dcoutts> dons: well you could imagine a MPTC for randoms that is parameterised by both the random gen and the typ
09:27:10 <dons> yeah
09:27:14 <quicksilver> hmm
09:27:19 <quicksilver> sounds like a misuse of MPTCs to me
09:27:25 <quicksilver> why not just pass the gen in as a value?
09:27:36 <quicksilver> what business does a randomgen have being a type? :)
09:27:51 <dcoutts> quicksilver: what do you think StdGen is? :-)
09:28:06 <quicksilver> :t StdGen
09:28:08 <lambdabot> Not in scope: data constructor `StdGen'
09:28:12 <quicksilver> :k StdGen
09:28:13 <lambdabot> *
09:28:19 <dons> the other issues is 'split', it's not clear whether every RandomGen can support that
09:28:23 <dons> (purely)
09:28:30 <dcoutts> dons: no, many cannot
09:28:49 <dcoutts> it's well known that split is only ok for casual uses of random numbers
09:28:50 <quicksilver> or at least not efficiently / with good random proporties
09:29:04 <geezusfreeek> quicksilver: i have created my own RandomGen instance to use codon sequences to generate "random" functions in a genetic programming program i'm writing, for example
09:29:30 <quicksilver> geezusfreeek: yes, I guess I'm not really sure why RandomGen is a class and not jsut a type
09:29:57 <geezusfreeek> so that you can use different generators in the same functions
09:30:02 <dcoutts> right
09:30:02 <quicksilver> you could anyway
09:30:09 <quicksilver> you'd just pass the randomgen value
09:30:16 <quicksilver> instead of the randomgen type :)
09:30:25 <geezusfreeek> but it needs its own unique versions of next and split
09:30:37 <geezusfreeek> so you would have to pass those too
09:30:44 <geezusfreeek> which, as it turns out, emulates what a typeclass does anyway
09:30:49 <quicksilver> right
09:30:58 <quicksilver> except a typeclass does this funky auto-selection thing
09:31:03 <quicksilver> which I'm not clear that you want here
09:31:04 * quicksilver shrugs
09:31:10 <quicksilver> I guess it's because existentials aren't haskell98 :)
09:31:12 <dcoutts> quicksilver: you're suggesting a record and an existentially quantified internal state type?
09:31:14 <geezusfreeek> funky auto-selection thing
09:31:19 <geezusfreeek> ?
09:31:26 <quicksilver> dcoutts: yes.
09:31:39 <dcoutts> quicksilver: well that's not H98, so H98 uses a class :-)
09:31:43 <quicksilver> yeah
09:31:49 <quicksilver> that's the conclusion I had just come to.
09:31:58 <quicksilver> It's typeclasses as an approximation to existentials.
09:32:02 <quicksilver> Not typeclasses for overloading.
09:32:07 <quicksilver> (which is what they're really for, IMO.)
09:32:12 <dcoutts> quicksilver: I mean sure, there are many cases where the record and hidden state and a class solution would be mostly as good as each other
09:32:28 <quicksilver> dcoutts: and if you often want to choose different instances, the record solution is generally nicer.
09:32:39 <quicksilver> dcoutts: the class solution is nicer when one-instance-per-type is what you really want.
09:32:52 <quicksilver> dcoutts: and we were just talking about wanting to plug in other randomgens into standard methods.
09:32:56 <quicksilver> I think:)
09:32:57 <quicksilver> unless I lost track.
09:32:58 <geezusfreeek> oh i see what you mean now
09:33:33 <Saizan_> ?src RandomGet
09:33:33 <lambdabot> Source not found. stty: unknown mode: doofus
09:33:36 <Saizan_> ?src RandomGen
09:33:36 <lambdabot> class RandomGen g where
09:33:36 <lambdabot>    next     :: g -> (Int, g)
09:33:36 <lambdabot>    split    :: g -> (g, g)
09:33:36 <lambdabot>    genRange :: g -> (Int,Int)
09:34:17 <dcoutts> data RandomGen where next :: g -> (Int, g)
09:34:20 <Saizan_> but it's the type of the generator, not of the value returned, so you can still use multiple generators for the same type
09:34:45 <Saizan_> by just changing the type of the initial generator
09:35:42 <Saizan_> i don't see what an explicit record will gain here
09:39:29 <quicksilver> :t randomR
09:39:31 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
09:40:38 <geezusfreeek> randomR is probably my least favorite function in the Random typeclass because it doesn't seem to fit so many types
09:41:12 <quicksilver> you mean that a range is not helpful in many cases?
09:41:15 <quicksilver> :t random
09:41:16 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
09:41:38 <geezusfreeek> no, it's definitely helpful, i just think it should be something to implement separately on a case-by-case basis
09:41:45 <hpaste>  byorgey annotated "mouse only on floating" with "a bit cleaner: higher-order withFloat; \s -> f s === f" at http://hpaste.org/5083#a1
09:42:05 <byorgey> sorry, that was for #xmonad
09:42:37 <phobes> ?src Random
09:42:37 <lambdabot> class Random a where
09:42:37 <lambdabot>   random    :: RandomGen g => g -> (a, g)
09:42:37 <lambdabot>   randoms   :: RandomGen g => g -> [a]
09:42:37 <lambdabot>   randomR   :: RandomGen g => (a,a) -> g -> (a,g)
09:42:37 <lambdabot>   randomRs  :: RandomGen g => (a,a) -> g -> [a]
09:42:39 <lambdabot>   randomRIO :: (a,a) -> IO a
09:42:41 <lambdabot>   randomIO  :: IO a
09:43:43 <geezusfreeek> i'm not even sure why some of those other functions are in there either... is there really much of a reason to specialize randomIO for a particular type?
09:44:25 <quicksilver> geezusfreeek: randomIO is a dirty dirty hack
09:44:32 <quicksilver> geezusfreeek: where do you think it gets the "g" from?
09:44:32 <phobes> It doesn't need a generator is the point?
09:44:47 <quicksilver> ok, I see
09:44:49 <geezusfreeek> of course it just gets the global generator
09:44:52 <quicksilver> but still, it doesn't need to be a method.
09:45:00 <quicksilver> yes, that's odd.
09:45:37 <phobes> randomIO = 7
09:46:04 <geezusfreeek> randomIO = 3 -- random result of a dice roll
09:46:09 <quicksilver> Igloo: why is randomIO a method? it seems like it should always be "randomIO = g <- getStdGen; let (r,g') = random g; setStdGen g'"
09:46:15 <RayNbow> http://programming.reddit.com/info/65vew/comments/ <-- heh, this keeps popping up :p
09:46:24 <quicksilver> Igloo: can't imagine why you'd override it for a particular type a.
09:47:04 <phobes> randomIO = puts "Enter a random number:" ...
09:47:09 <byorgey> bogner: true.
09:52:52 <hpaste>  (anonymous) annotated "mouse only on floating" with "(no title)" at http://hpaste.org/5083#a2
10:08:53 <larmeh__> hi there
10:11:54 <kaol> @users
10:11:55 <lambdabot> Maximum users seen in #haskell: 454, currently: 427 (94.1%), active: 12 (2.8%)
10:12:39 <byorgey> hi larmeh
10:13:26 <paolino> I have a runtime error "overlapping instances" . I'm writing quickchecks "for a class", I had to allow  them to set the context for the Arbitrary instance ...
10:14:19 <byorgey> paolino: can you paste your code?
10:14:24 <byorgey> !paste
10:14:24 <hpaste> Haskell paste bin: http://hpaste.org/
10:17:27 <hpaste>  paolino pasted "QC for classes" at http://hpaste.org/5084
10:18:43 <bos> paolino: what were you expecting?  the error is correct.
10:19:09 <paolino> the compiler is always correct
10:19:25 <bos> paolino: it's telling you that QuickCheck already defines an Arbitrary instance for the type you're trying to use, so it can't determine which of the two possible instances it ought to be using.
10:19:51 <paolino> which is [String] right ?
10:20:01 <bos> no, it's [a] for all a.
10:20:25 <bos> so a list of any type will cause the same problem.
10:20:29 <bos> hi CosmicRay
10:20:39 <CosmicRay> hi bos
10:21:08 <byorgey> paolino: also note that instance (Eq w, Engine w) => Arbitrary w probably doesn't mean what you think it means.  instance selection happens *before* looking at the class constraints.
10:21:09 <paolino> I didn't want to write an instance for lists
10:21:35 <byorgey> paolino: so that instance will match *all* types, and then additionally generate a constraint that the type must be a member of Eq and Engine.
10:22:00 <paolino> it doesn't compile without the constraints
10:22:20 <byorgey> paolino: so it will match [String] whether or not [String] is an instance of Engine.
10:22:26 <paolino> I see
10:23:16 <paolino> is there a way to do that correct ?
10:23:24 <byorgey> paolino: one way around it would be to make a newtype wrapper
10:24:04 <paolino> with the constraints ?
10:24:14 <byorgey> newtype W a = W a ; instance (Eq w, Engine w) => Arbitrary (W w) where ...
10:24:29 <byorgey> hm, but that gets screwy with testing functions that have parameters of type w, not W w
10:24:41 <byorgey> I'm not really sure what the best solution would be.
10:24:53 <bos> you can lift them by making it a Functor.
10:25:06 <bos> but yes, it's awkward.
10:25:41 <byorgey> hm, does OverlappingInstances help?
10:25:48 <byorgey> I'm not 100% clear on how that works.
10:26:15 <bos> no, it doesn't.
10:26:29 <byorgey> ok.
10:26:31 <bos> it allows you to define overlapping instances. it doesn't help the compiler to select one.
10:27:21 <byorgey> hm... well, if you define overlapping instances, how *does* the compiler select one?
10:27:51 <bos> if you had overlapping instances of the form (a,Bool) and (Bool,a) the compiler would choose the first if you had (Char,Bool) where a cannot be a Bool.
10:28:09 <byorgey> oh, I see
10:28:27 <bos> and it would choose the second if you had (Bool,Int), but then *that* a cannot be a Bool.
10:28:46 <bos> when there's overlap, the compiler still has to be able to make an unambiguous choice.
10:28:47 <byorgey> right.  but it would still complain if you tried to use (Bool,Bool) ?
10:28:51 <bos> exactly.
10:28:53 <byorgey> got it.
10:29:44 <paolino> not me ....
10:29:48 <bos> overlapping instances are a step on the road to undecidable instances and sudden catastrophic cranial expansion.
10:30:03 <paolino> eh
10:30:18 <glguy> The road to hell is paved with undecidable instances
10:30:20 <byorgey> so, there's not a nice way to do what paolino would like to do?
10:30:45 <paolino> so what happens with the newtype ?
10:30:45 <byorgey> hehe
10:31:00 <byorgey> @remember glguy The road to hell is paved with undecidable instances
10:31:00 <lambdabot> Done.
10:31:29 * byorgey idly wonders how many quotes \bot is @remembering
10:31:43 <glguy> @quote byorgey
10:31:44 <lambdabot> byorgey says: if math, haskell :: [Knowledge], the problem with learn $ math ++ haskell (or vice-versa) is that both lists are infinite, so you'll never get to the second one.  Better to do something
10:31:44 <lambdabot> like learn $ zip math haskell.
10:33:12 <ricky_clarkson> Does math contain haskell, or haskell contain math?
10:33:20 <dons> dcoutts: does gentoo/ghc come with extralibs?
10:33:25 <byorgey> paolino: well, using the newtype, you have a way to generate random values of type (W w) where (Eq w) and (Engine w).  but the functions you'll want to test involve values of type w, not W w.
10:33:34 <dons> dcoutts: or do i need to tell isaac to install bytestring and some other packages separately?
10:33:45 <byorgey> paolino: so you have to do various acrobatics to wrap/unwrap W constructors in lots of places.
10:34:12 <ricky_clarkson> Philippa: Cale: Thanks for your explanations earlier, wrt. closures.
10:34:12 <paolino> mmhh, only pattern matching on teh tests
10:34:20 <byorgey> ricky_clarkson: I'd say the former.
10:34:21 <dcoutts> dons: all non-core libs are packages separately, some core libs can also be upgraded separately
10:34:32 <byorgey> paolino: yeah, it might not be that bad.  try it and see, I guess.
10:34:34 <Gwern-away> dons: do you know any particular reason I would be unable to darcs get http://www.cse.unsw.edu.au/~dons/code/polymer/ ?I keep getting on the first d/led patch 'darcs failed:  Failed to download URL http://www.cse.unsw.edu.au/~dons/code/polymer/_darcs/patches/20071016062715-1712c-54923acfe5e147e539f9629a1ed05519e1b595d6.gz : HTTP error (404?)'
10:34:35 <lambdabot> Title: Index of /~dons/code/polymer
10:34:39 <paolino> ok
10:34:43 <paolino> thanks both
10:34:44 <dcoutts> dons: for example bytestring is a core lib that is included in the ghc-6.8.2 ebuild, but you can also upgrade it
10:35:22 <dons> dcoutts: ok, so for the shootout, to have a workable system with some reasonable libs, (bytestring, in particular), they need do no more than install the ghc 6.8.2 package?
10:35:26 <dcoutts> dons: there are packages under the dev-haskell/ category for all the extra libs, and a lot of others as well (~60 dev-haskell/ libs)
10:35:42 <dcoutts> dons: if all they need is core libs, then yes.
10:36:07 <dons> we only use core libs in shootout examples, atm
10:36:12 <dcoutts> ok
10:36:18 <dons> though pcre-light would be one candidate , and Data.Binary
10:36:43 <dcoutts> dons: what do you like about prce-light that you didn't about regex-pcre ?
10:36:52 <kosmikus> is there a current #haskell recommendation on what to use for a terminal emulation / curses binding?
10:37:08 <dons> regex-pcre is huge, not well tested, and non-portable
10:37:28 <dons> kosmikus: curses can be done via the hscurses package (not on hackage), or ripping the small binding out of hmp3
10:37:35 <dons> there's also vty, a termio lib
10:37:36 <dcoutts> dons: non-portable? I thought it just used libpcre like your pcre-light?
10:37:59 <Gwern-away> kosmikus: you could try vty, also, although that has some known bugs
10:38:02 <dons> dcoutts: it does, along with MPTCs, FDs, ...
10:38:16 <dcoutts> dons: ah, that kind of non-portable
10:38:46 <kosmikus> related question: is there anything, regardless how simple, that also works on Windows?
10:38:52 <dons> if i can get pcre.c to build inside pcre-light, i might agitate for regex-* removal from extra libs
10:39:02 <dons> kosmikus: hmm
10:39:08 <dcoutts> dons: extralibs will not exist with ghc-6.10 I think
10:39:23 <dons> oh, regex-base/compat/posix are in core though, aren't they
10:39:30 <dcoutts> dons: no
10:39:43 <dcoutts> not in 6.8, they were in 6.6
10:39:53 <dons> hmm. so ghc doesn't use regexes at all now?
10:40:02 <dcoutts> don't think so
10:40:05 <kosmikus> dons: do you know if hscurses still works with current ghcs?
10:40:22 <dons> kosmikus: it probably doesn't. it's on my todo to cabalise the curses.hsc in hmp3 though
10:40:35 <dons> (which is a light, portable curses binding, not as featureful as hscurses)
10:40:43 <dons> probably not hard to get hscurses to build though
10:41:00 <kosmikus> is that the same as the one that's linked as curses.hsc from http://www.haskell.org/haskellwiki/Libraries_and_tools/GUI_libraries ?
10:41:03 <lambdabot> Title: Applications and libraries/GUI libraries - HaskellWiki, http://tinyurl.com/gn7tc
10:41:05 <dons> dcoutts: ah right, not in boot packages now.
10:41:05 <dons> good
10:41:14 <dcoutts> core==boot
10:41:18 <dons> kosmikus: ah . hscurses is stefan wehr's lib
10:41:51 <kosmikus> dons: yes. but I meant whether the Curses.hsc link there is essentially the same that's in hmp3?
10:41:57 <paolino> byorgey:  No instance for (Arbitrary Char), should I write it ?
10:42:18 <byorgey> there's no instance for Arbitrary Char !?
10:42:24 <paolino> mmhh
10:42:29 <paolino> thats ghci
10:42:39 <dons> kosmikus: does it link to the hmp3 one? (it should be approx the same). for the current version,see http://code.haskell.org/~dons/code/hmp3/Curses.hsc
10:42:49 <paolino> I suppose there is
10:42:53 <kosmikus> dons: thanks
10:43:08 <byorgey> paolino: huh, it seems you're right, there isn't
10:43:27 <dons> kosmikus: if you start packaging that up, i can help
10:43:51 <paolino> byorgey: how do I see that ?
10:43:57 <byorgey> very odd, there's an Arbitrary instance for String, but not Char ?
10:44:00 <kosmikus> dons: that looks good enough for my purposes
10:44:02 <dons> kosmikus: uses some things in http://code.haskell.org/~dons/code/hmp3/Style.hs
10:44:05 <dons> for colours
10:44:28 <paolino> but I asked a [String] !
10:44:31 <byorgey> paolino: well, I just opened up ghci and loaded Test.QuickCheck and Data.Char and tried doing something like test (\c -> chr (ord c) == c)
10:44:57 <dons> dcoutts: are there thoughts about what goes in extra-libs now?
10:45:09 <byorgey> oh, wait, never mind, there isn't an instance for String
10:45:11 <dons> do we ever move things *in* anymore?
10:45:25 <byorgey> @qc \c -> chr (ord c) == c
10:45:26 <lambdabot> Not enough privileges
10:45:33 <byorgey> @quickcheck \c -> chr (ord c) == c
10:45:33 <lambdabot> Unknown command, try @list
10:45:39 <byorgey> @check \c -> chr (ord c) == c
10:45:40 <dcoutts> dons: I think the plan is for ghc not to be involved in that question
10:45:41 <lambdabot>  OK, passed 500 tests.
10:45:49 <byorgey> ok, now I'm confused
10:45:56 <dons> dcoutts: ok good. i like having things like random outside of core.
10:46:01 <dons> its much more flexible now
10:46:05 <Gwern-away> @where hscurses
10:46:05 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
10:46:10 <dcoutts> dons: so if we want a "standard platform" then we need to define and distribute that separately
10:46:11 <paolino> byorgey: I'm bleeding
10:46:41 <dons> dcoutts: btw, seen the python 'batteries included' lib suite?
10:46:43 <dons> http://docs.python.org/lib/
10:46:44 <lambdabot> Title: Python Library Reference
10:46:52 <dcoutts> yep
10:46:59 <dons> some interesting things there we could look to replicate if creating a 'haskell + batteries' bundle
10:47:10 <dons> i'll probably try to knock off a few of those this year
10:47:17 <dcoutts> how do they balance the stagnation vs api quality issue I wonder
10:47:20 * byorgey goes off to do some detective work...
10:47:50 * dcoutts thinks dons should help him with automating hackage qa
10:47:57 <dons> will be doing that too :)
10:48:00 <dcoutts> :-)
10:48:40 <dcoutts> once we have the infrastrucutre we can do all sorts of automated qa, like running package testsuites, getting coverage, doing source lint checks
10:49:10 <dcoutts> using the ghc api, eg, qa checks like that libs are using package imports that are robust to additions in the namespace
10:49:24 <byorgey> paolino: if you look at http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html#t%3AArbitrary , there's no instance defined for Char.
10:49:25 <lambdabot> http://tinyurl.com/vg6r4
10:49:26 <dcoutts> or that libs are following their own versioning policy
10:49:33 <byorgey> paolino: that's the version of QC included with the latest ghc.
10:49:49 <bos> dcoutts: you are forbidden from enlisting dons in more hacking projects!  watch out, i'll come and git ya!
10:49:51 <dcoutts> dons: I wrote a package api check program once, that should be re-done using the ghci api
10:50:02 <dcoutts> bos: hah, right 'o :-)
10:50:05 <byorgey> paolino: but if you look at http://www.cs.chalmers.se/~rjmh/QuickCheck/QuickCheck.hs , there is an instance for Char.
10:50:12 <byorgey> paolino: that looks like the latest version of QC.
10:50:31 <paolino> :i Arbitrarz
10:50:43 <byorgey> paolino: conclusion: you should (1) download the newest version of QuickCheck, or (2) write your own instance for Arbitrary Char.
10:50:55 <byorgey> paolino: and if you do option (2) you can just copy the instance from that second link.
10:51:00 <dcoutts> dons: what you really need to do is persuade the folks with dosh to invest in some consultants to work on infrastructure issues ;-)
10:51:03 <paolino> :)
10:51:20 <dons> dcoutts: oh, that's interesting.
10:51:58 <dons> i'd also like to be able to replicate my waking hours
10:52:07 <dcoutts> aye :-)
10:52:14 <paolino> byorgey:  ok, it works. How do I use those tests on instances ?
10:52:27 <dons> maybe we can run an intensive summer training school for aspiring haskell open source devs
10:52:44 <bos> haskell boot camp.
10:52:50 <byorgey> paolino: what do you mean?
10:52:52 <paolino> I can do it by hand "quickCheck (prop_add :: W InsideAppend -> [String] -> Bool)"
10:52:53 <monochrom> Like implementing 100 new monad transformers a day? :)
10:52:58 <dcoutts> dons: that'd be fun, like an extended hackathon
10:53:02 <dons> yeah, get people up to speed on expected standards of purity, quality, type safety, testing
10:53:06 <bos> join up as a flabby PHP programmer, leave spitting applicative functors!
10:53:15 <dons> so that more people can write more high  quality libs
10:53:19 <monochrom> Hand-writing 1000 new FFI bindings? :)
10:53:29 <bos> that's why god gave us hsc2hs
10:53:37 <dons> its that issue of knowing when an api is 'haskellish' that's hard to convey
10:53:45 <monochrom> And 10 calculational proofs of fusion correctness. :)
10:53:49 <paolino> byorgey: but how does it do with automating them ?
10:53:56 <Nafai> A Haskell boot camp would be fun!
10:54:29 <byorgey> paolino: maybe try http://www.cs.chalmers.se/~rjmh/QuickCheck/quickcheck ?
10:54:30 <Nafai> "We like Monads, yes we do! 1! 2! 3! 4!  Ten hut!"
10:54:42 <paolino> I have to redefine all of them with an annotation each for all the instances ?
10:55:32 <paolino> this is badder than newtype
10:58:13 * Gwern-away defines the acronym WPM - -Wall Per Minute, the # you can fix
10:59:37 <paolino> I suppose there is no escape then
11:00:57 <paolino> something like wrapping all test with generics ...
11:02:00 <paolino> another road to hell :)
11:04:48 <ricky_clarkson> What does code that uses random number generators usually look like in Haskell?
11:05:11 <paolino> monadic
11:05:53 <paolino> to keep the generator state behind operation
11:06:14 <ricky_clarkson> It seems I could pass in a [Integer] so to keep the using code non-monadic.
11:06:25 <ricky_clarkson> But obviously it has to be called by somewhere that is monadic.
11:08:13 <paolino> you can make a generator with a seed you fix, not coming from IO
11:08:35 <paolino> it's ok for simulations I suppose
11:09:23 <ricky_clarkson> Ok.
11:09:53 <monochrom> Everything is called from main :: IO a.
11:10:56 <monochrom> Anyway, sometimes I take random numbers from IO, sometimes a state monad over StdGen, sometimes from randoms and randomRs.
11:18:10 <profmakx> yay! ghci is working on my machine now ;)
11:20:14 <desegnis> ricky_clarkson, the advantage of passing a generator right away instead of a list is that the generator can be splitted for sub-computations
11:21:29 <byorgey> profmakx: yay! =D
11:22:16 <ricky_clarkson> desegnis: You could pass the list to the subcomputation, and it passes a somewhat depleted version back.
11:22:26 <ricky_clarkson> And thus monadic code is emulated :)
11:23:11 <desegnis> that would force an order of evaluation, though. No luck using par e.g.
11:24:06 <ricky_clarkson> par?
11:24:19 <sioraiocht> :t par
11:24:22 <lambdabot> forall a b. a -> b -> b
11:24:29 <desegnis> @index par
11:24:30 <lambdabot> GHC.Conc, Control.Parallel, Graphics.HGL.Utils, Graphics.HGL
11:24:36 <sioraiocht> par takes two arguments, calculates them in parallel, and returns the second
11:26:17 <desegnis> anyways, to put it general, the list-passing may introduce unnecessary dependencies of one calucation on the other
11:29:09 <desegnis> calculation, even
11:39:40 <Sizur> how can one encode a nonempty list as a type?
11:40:10 <Lemmih> Sizur: (a,[a]), basically.
11:40:29 <Sizur> i guess more generally this is a problem of limited typing?
11:40:44 <sioraiocht> Sizur: you can also use GADT
11:40:49 <Sizur> like positive integers
11:40:56 <glen_quagmire> i'm editing A.hs . there is SOE/SOE.hs . how can I import it in A.hs? I tried import SOE.SOE  but it can't find it
11:41:02 <dcoutts> Sizur: yes, you can get more sophisticated type systems that can enforce much more complex properties
11:41:06 <dcoutts> see dependent types
11:41:10 <mattam> Or refinement types
11:41:11 <Sizur> sioraiocht: how would i express that as a GADT?
11:41:17 <sioraiocht> a nonempty list?
11:41:21 <Sizur> yeah
11:41:34 <sioraiocht> http://en.wikibooks.org/wiki/Haskell/GADT
11:41:34 <lambdabot> Title: Haskell/GADT - Wikibooks, collection of open-content textbooks
11:41:46 <sioraiocht> the tutorial there covers safe lists
11:41:51 <glen_quagmire> actually it's ./SOE/src/SOE.hs
11:42:10 <sioraiocht> Sizur: if you want refinement types checking out the Sage programming language, which also includes dependent types
11:42:34 <Sizur> sioraiocht: thanks for the reference. i'll take a look at Sage
11:43:14 <mattam> Or you could use Coq instead with the Program extension (http://coq.inria.fr) </shameless publicity>
11:43:15 <lambdabot> Title: The Coq proof assistant
11:47:59 <Sizur> hybrid type checking with dependent types is superb idea, i wish haskell will have it soon.
11:48:22 <ddarius> Haskell is not going to get dependent types anytime in the foreseeable future.
11:49:05 <sioraiocht> nor hybrid typechecking, I hope, heh
11:49:07 <EvilTerran> it wouldn't really be haskell any more
11:49:12 <sioraiocht> exactly
11:49:55 <Sizur> why put error calls in your functions when you can let the compiler do it?
11:50:13 <EvilTerran> so you know they're there?
11:50:28 <Sizur> you can see the type, it says positive integers
11:50:33 <EvilTerran> mmm
11:52:18 <sioraiocht> It's a cool language
11:52:35 <sioraiocht> but i agree it's Not Haskell
11:53:57 <Sizur> i cannot use it :( it's interpreted (and probably no libs)
11:54:13 <sioraiocht> sage?
11:54:19 <sioraiocht> it's highly experimental, too
11:54:21 <Sizur> yeah. haskell is industrial now
11:56:16 <glen_quagmire> {-# OPTIONS_GHC -iSOE/src -#} doesn't take effect on ghci. And there is no OPTIONS_GHCi pragma. do I have to manually :set -iSOE/src ?
11:56:55 <byorgey> glen_quagmire: can't you just start ghci with that option?
11:57:06 <Sizur> why don't they write sage on haskell? ;)
11:57:11 <ddarius> Or you can put in your .ghci if you intend to use it often.
11:57:14 <glen_quagmire> byorgey: yup just did
12:03:06 <BMeph> Sizur: Another article (good or not, you tell me) is http://www.haskell.org/haskellwiki/Non-empty_list
12:03:07 <lambdabot> Title: Non-empty list - HaskellWiki
12:03:35 <luqui> so I want to write a function Array i a -> Array i b, and use Array.ST for computation
12:03:45 <luqui> but I can't figure out what the signature (context) of that function should be
12:03:53 <luqui> because of the free state variable s
12:05:05 <Sizur> BMeph: yeah i was just thinking how to implement refinement types in haskell. just make your own type, and use a function as a constructor instead of the constructor.
12:05:30 <thoughtpolice> smart(er) constructors ftw.
12:09:41 <ddarius> @wiki Introduction/Direct translation
12:09:43 <lambdabot> http://www.haskell.org/haskellwiki/Introduction/Direct_translation
12:10:15 <ddarius> luqui: See processArray here http://www.haskell.org/haskellwiki/Introduction/Direct_Translation
12:10:16 <lambdabot> Title: Introduction/Direct Translation - HaskellWiki, http://tinyurl.com/ytokyh
12:10:52 <oerjan> ddarius: no such page
12:11:15 <oerjan> oh, capitalization
12:11:48 <luqui> ddarius, thanks
12:16:09 <byorgey> ddarius: the @wiki command is really dumb.
12:16:32 <byorgey> @wiki Making Banana Splits with Haskell
12:16:32 <lambdabot> http://www.haskell.org/haskellwiki/Making_Banana_Splits_with_Haskell
12:16:48 <ddarius> The @oldwiki command is even dumber, but more successful (or would be if HaWiki were still up)
12:17:18 <sioraiocht> what is the difference between a predicate and a function in FOL?
12:18:07 <ddarius> A function doesn't have a truth value.
12:18:33 <oerjan> @faq Can haskell make banana splits?
12:18:33 <lambdabot> The answer is: Yes! Haskell can do that.
12:18:49 <ddarius> @google "banana split theorem"
12:18:50 <lambdabot> http://www.md.chalmers.se/~patrikj/Courses/intense00/ex/
12:18:50 <lambdabot> Title: Exercises
12:19:35 <byorgey> what!?
12:19:45 <byorgey> I just made that up =)
12:20:05 <byorgey> The @faq is true!
12:20:41 <ricky_clarkson> litb: The @faq is true.
12:21:38 <litb> it can split bananas?
12:22:18 <ricky_clarkson> :t splitBy
12:22:19 <lambdabot> Not in scope: `splitBy'
12:22:27 <litb> :t splitBan
12:22:27 <lambdabot> Not in scope: `splitBan'
12:22:29 <Sizur> bananas as in catamorphisms.
12:22:33 <litb> oh i see
12:22:47 <Sizur> because they look like bananas when you write them on paper
12:23:09 <ricky_clarkson> @hoogle split
12:23:09 <lambdabot> Data.ByteString.split :: Word8 -> ByteString -> [ByteString]
12:23:09 <lambdabot> Data.Set.split :: Ord a => a -> Set a -> (Set a, Set a)
12:23:10 <lambdabot> Data.Map.split :: Ord k => k -> Map k a -> (Map k a, Map k a)
12:24:56 <ddarius> split == (&&&)
12:25:28 <ddarius> @users
12:25:29 <lambdabot> Maximum users seen in #haskell: 454, currently: 443 (97.6%), active: 16 (3.6%)
12:26:39 <grahamhutton> banana split theorem = every pair of foldrs over the same list can be rewritten as a single foldr
12:27:06 <grahamhutton> thereby avoiding two traversals over the list
12:28:36 <grahamhutton> but whether this saves time or space in practice is another question :-)
12:28:40 * ddarius wonders if that is a "trivial" continuity property of the expression of folds as limits.
12:29:06 <grahamhutton> it follows from the universal property of folds
12:29:20 <ddarius> grahamhutton: Of course it does as that's their defining property.
12:29:58 <grahamhutton> quite right --- *every* property of folds follows from this!
12:30:10 <grahamhutton> that's the point
12:30:18 <Sizur> i cannot find bananas in the unicode
12:30:35 <ddarius> I'm aiming for: "Banana Split Theorem  Proof: By continuity of right adjoints."
12:30:39 <Sizur> not like it's essential for survival ;)
12:32:52 <idnar> how efficient is "powerset = filterM (const [True, False])"?
12:33:04 <oerjan> um is that theorem anything more than foldr (\(x1,x2) (y1,y2) -> (f1 x1 y1, f2 x2 y2)) (s1, s2)
12:33:07 <oerjan> ?
12:34:11 <byorgey> grahamhutton: is it just for foldr, or for catamorphisms in general?
12:34:29 <grahamhutton> banana split holds for any cata
12:35:16 <dcoutts> idnar: do you mean complexity or constant factors?
12:36:31 <idnar> dcoutts: complexity, I guess
12:36:35 <glen_quagmire> :i filterM
12:36:57 <oerjan> :t filterM
12:36:58 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
12:37:19 <glen_quagmire> its in Control.Monad
12:37:26 <dcoutts> idnar: well, how big is a power set? if your original set had n element, how many subsets does the powerset contain? (it's a maths question)
12:37:58 <monochrom> That is the first and most obvious complexity question. There are more subtle ones.
12:38:19 <dcoutts> idnar: if you're not sure, check wikipedia
12:38:19 <byorgey> dcoutts: but given that the output list has N elements, there is also the question of whether the whole list can be generated in O(N) time, or if it's something like O(N^2).
12:38:32 <byorgey> I think it's O(N) but that is a valid question.
12:38:42 <dcoutts> byorgey: yes, now that's an interesting question, how does lazyness affect the issue
12:38:50 <idnar> there are O(n^2) subsets, no?
12:39:04 <dcoutts> no, 2^n
12:39:08 <idnar> er
12:39:15 <monochrom> Here is a subtle one: how much does "take k (powerset x)" cost?
12:39:16 <glen_quagmire> > filterM (const [True, False]) "www"
12:39:17 <idnar> yeah, I meant that
12:39:18 <lambdabot>  ["www","ww","ww","w","ww","w","w",""]
12:39:30 <idnar> anyhow, I'll be consuming the whole powerset
12:39:40 <dcoutts> monochrom: to be more precise, ask length of that
12:39:52 <oerjan> i seem to recall the filterM version is rather space leaky
12:40:19 <dcoutts> since this is all about lazyness we need to know what our eval strategy is, use whnf and extend using other evaluators like length etc
12:40:58 <monochrom> Laziness allows us to ask infinitely many complexity questions. :)
12:41:22 <grahamhutton> for anyone interested in such things, there is a general formulation/proof of the banana split theorem on p56 of Bird and de Moor's book (Algebra of Programming)
12:41:25 <oerjan> basically after outputting half the list of subsets, the list of subsets of the tail has been cached
12:41:50 <pejo> grahamhutton, how can traversing lists fewer times not save time in practice, except for the empty list?
12:42:16 <oerjan> which means you need O(2^(n-1)) memory
12:42:37 <grahamhutton> because traversing it once involves constructing/destructing pairs, which carries its own cost
12:43:04 <monochrom> In fact that very page is available on amazon.com!
12:43:06 <grahamhutton> whether fusion theorems actually buy something in practice is a fairly tricky issue
12:43:07 <ddarius> And of course, you could only use part of the output
12:44:41 <monochrom> http://www.amazon.com/gp/reader/013507245X/ref=sib_dp_pt/102-9923214-6442506#reader-link  then click "Excerpt" then you're on page 55!  there is also an arrow to get to page 56. :)
12:44:42 <lambdabot> http://tinyurl.com/23npty
12:44:50 <grahamhutton> for example, the standard "hylo" theorem, which claims to eliminate an intermediate data structure, actually just moves the structure to the control stack
12:45:49 <grahamhutton> monochrom: :-)
12:46:35 <idnar> :t product
12:46:37 <lambdabot> forall a. (Num a) => [a] -> a
12:48:15 <byorgey> wow, anyone know of a place to get "Algebra of Programming" other than Amazon?  it only has two used copies starting from $128...
12:48:53 <monochrom> My copy is likely the last new copy before extinction. :)
12:49:04 <koeien> that's about 80 euros? pretty expensive for a book
12:49:14 <oerjan> > let subsets = map reverse . foldl (liftM2 (:)) (return []) in subsets "abc"
12:49:14 <lambdabot>      Occurs check: cannot construct the infinite type: a1 = [a1]
12:49:14 <lambdabot>       Expect...
12:49:20 <oerjan> bah
12:49:35 <byorgey> @go 128 USD in EUR
12:49:35 <lambdabot> 128 U.S. dollars = 87.3302859 Euros
12:49:43 <ddarius> liftM2 (flip (:)) ?
12:49:53 <koeien> even more expensive than i thought
12:49:55 * BMeph node
12:50:19 <Igloo> byorgey: amazon.co.uk has it, but at 55.99 GBP that's about the same
12:50:27 <oerjan> oh wait
12:51:09 <byorgey> hm, I just found this LtU thread that might be useful, in case anyone else is interested: http://lambda-the-ultimate.org/node/1117
12:51:10 <lambdabot> Title: Algebra Of Programming (Bird, De Moor) | Lambda the Ultimate
12:51:28 <Igloo> Oh, no, sorry, it doesn't have it but seems to be expecting more
12:52:02 <BMeph> Just off-hand, do any of you "maths" folks remember the official name for counting the number of ways you can put items in bins, when you don't care which item or which bin it is?
12:52:29 <Tac-Tics> combinations maybe?
12:52:37 <Tac-Tics> as opposed to permutations?
12:52:53 <smack__> hmm, partitions?
12:53:02 <oerjan> > let subsets = map reverse . foldl (liftM3 flip [(:),const id] ) (return []) in subsets "abc"
12:53:02 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
12:53:03 <koeien> BMpeh: you mean like 5 nCr 2 = 10 ??
12:53:24 <BMeph> Yeah, it's going to be some kind of combination, but it's more tricky than that.
12:53:26 <koeien> smack__: hmm that makes more sense
12:53:39 <shachaf> koeien: Do you mean 5 C 2? :-)
12:53:47 <Tac-Tics> @let fact = product . enumFromTo 1
12:53:50 <lambdabot> Defined.
12:53:50 <shachaf> koeien: (Aren't the n and r placeholders?)
12:53:59 <koeien> shachaf: yeah a matter of notation, probably placeholders indeed
12:54:06 <BMeph> Let me try looking up partition formulas, that sounds faintly familiar.
12:54:07 <byorgey> BMeph: I think that would be integer partitions.
12:54:15 <Tac-Tics> @let nCr n r = fact n / (fact r * fact (n - r))
12:54:16 <lambdabot> Defined.
12:54:21 <byorgey> BMeph: i.e. 7 = 6 + 1 = 5 + 2 = 5 + 1 + 1 = 4 + 3 = ...
12:54:29 <Tac-Tics> > 2 `nCr` 5
12:54:30 <lambdabot>  1.6666666666666666e-2
12:54:39 <Tac-Tics> whoops
12:54:44 <koeien> > 5 `nCr` 2
12:54:45 <lambdabot>  10.0
12:55:14 <byorgey> BMeph: is that what you mean?  putting unlabelled items in unlabelled bins?
12:55:16 * Tac-Tics is not a stats kind of guy and doesn't know the order of that thing's operands
12:55:23 <BMeph> Yes, that should be it. Thanks. :)
12:55:32 <luqui> :t fact
12:55:32 <lambdabot> Not in scope: `fact'
12:55:39 <Tac-Tics> I just defined fact
12:55:42 <koeien> Tac-Tics: you can see it? n! > (n-k)!k!
12:55:45 <luqui> oh
12:55:55 <Tac-Tics> fact :: Num a => a -> a
12:55:55 <koeien> for n>k>1
12:56:02 <monochrom> Perhaps myth is in scope instead of fact. :)
12:56:16 <koeien> fact::Num a => a->a->a   that is
12:56:20 <koeien> ehm
12:56:21 <koeien> nCr
12:56:48 <koeien> how long are those definitions kept in lambdabot's memory?
12:56:49 <Tac-Tics> nCr :: BigNum -> SmallNum -> PrettyBigNum
12:57:01 <Tac-Tics> I would imagine until someone resets them
12:57:25 <Tac-Tics> the reset is annoying, though, because it removes *everyones* bindings
12:57:30 <oerjan> > let subsets = map reverse . foldl (liftM3 flip [(:),const id] ) (return []) . map return in subsets "abc"
12:57:31 <lambdabot>  ["abc","bc","ac","c","ab","b","a",""]
12:57:37 * monochrom toys around the idea of starting a "haskell myth vs fact page".  "Myth: FPers are smarter."  "Fact: That's right! But I must add: you can be one of them too!"
12:57:37 <Toxaris> @type product . enumFromTo 1
12:57:38 <lambdabot> forall a. (Num a, Enum a) => a -> a
12:57:51 <koeien> lol
12:58:02 <Toxaris> Tac-Tics: don't hide the Enum :)
12:58:10 <Tac-Tics> Scandalous!
12:58:22 * koeien remembers the results of the FP exams at my uni
12:58:31 <radetsky> cabal is breaking on every package for me with a type error. I'm guessing I'm missing something. Any guesses?
12:58:50 <radetsky> Setup.lhs:30:43:
12:58:50 <radetsky>     Couldn't match expected type `Distribution.Verbosity.Verbosity'
12:58:50 <radetsky>            against inferred type `Distribution.Simple.Setup.Flag
12:58:50 <radetsky>                                     Distribution.Verbosity.Verbosity'
12:59:14 <monochrom> I guess programmer error.
12:59:16 <radetsky> there's more, but I didn't want to flood
12:59:32 <koeien> cabal version?
12:59:36 <radetsky> monochrom: in cabal-install?
12:59:56 <radetsky> 0.4.2/1.3.3
12:59:57 <monochrom> Oh haha, nevermind.
13:00:12 <oerjan> idnar: i think that one should use less memory.
13:01:17 <BMeph> byorgey++
13:02:06 <BMeph> That did it, byorgey, thank you. Now to find variations where it matters which item and which partition...
13:02:15 <byorgey> BMeph: glad I could help =)
13:02:45 <byorgey> BMeph: if the items are labelled but the bins aren't, that's called set partitions.
13:02:57 <czakey> @src ask
13:02:57 <lambdabot> Source not found. That's something I cannot allow to happen.
13:03:22 <koeien> radetsky: isn't 1.3.3 very new?
13:03:32 <czakey> @src readLn
13:03:32 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
13:03:34 <byorgey> BMeph: if the bins are labelled but the items aren't... um... I don't remember =P
13:03:44 <byorgey> BMeph: what's this for?
13:03:46 <czakey> @src putStr
13:03:47 <lambdabot> putStr s  = hPutStr stdout s
13:04:10 <radetsky> koeien: yeah, but it was necessary for cabal-install
13:04:19 <radetsky> I think it may be the source of the problem though
13:04:21 <oerjan> czakey: ask is a method of MonadReader class
13:04:22 <koeien> radetsky: sure it isn't 1.2.3 ?
13:04:30 <BMeph> byorgey: Just idle curiosity. I have weird hobbies. ;)
13:04:33 <radetsky> I'm going to reinstall 1.2.3 and see if it works
13:04:43 <Tac-Tics> :t readIO
13:04:43 <czakey> oerjan: thx
13:04:43 <byorgey> the lowest price I can find for Algebra of Programming us US $109 on Amazon.co.uk. =(
13:04:43 <lambdabot> forall a. (Read a) => String -> IO a
13:04:49 <Tac-Tics> ah
13:04:50 <koeien> radetsky: hackage says cabal-install only needs 1.2 or higher
13:04:59 <koeien> radetsky: so returning to 1.2.3 might resolve your problems
13:05:08 <oerjan> @src (->) ask
13:05:08 <lambdabot> ask = id
13:05:12 <radetsky> koeien: hackage lies
13:05:41 <koeien> radetsky: i installed cabal-install with 1.2.3 though (pretty sure) but that is with ghc 6.6.1
13:05:46 <byorgey> BMeph: you may want to check out "Enumerative Combinatorics" by R. P. Stanley.
13:06:05 <radetsky> I meant it was necessary for 0.4.2
13:06:08 <radetsky> sorry, was being unlcear
13:06:10 <radetsky> unclear
13:06:13 <BMeph> byorgey: "Consider it noted." ;)
13:06:50 <koeien> radetsky: ok, i don't know any solution for problems with 0.4.2 though :(
13:08:18 <BMeph> It's times like these when I most regret not getting my Math degree in '93. :|
13:08:28 <Cheery> I'm thinking about doing some sort of type-handling for conventional data structures, and I'm looking improvisation about haskell's types
13:09:05 <idnar> @pl \a b c -> (a != b && b == c)
13:09:06 <lambdabot> (`ap` (==)) . (((.) . (&&)) .) . (!=)
13:09:06 <radetsky> ok
13:09:19 <radetsky> I'll probably just switch back to the reg version and see if that works
13:09:33 <Cheery> not thinking about implementing haskell type system thought, but a bit different, such that would protect pointers and give a nice feel for playing out with data in a virtual machine
13:09:49 <shachaf> idnar: "!="?
13:09:57 <idnar> shachaf: I meant /==
13:09:59 <idnar> uh, /=
13:10:15 <Cheery> what sort of things should I read? I'm familiar with haskell itself already
13:11:24 <Cheery> especially I'm interested about how the type system spins off from lambda calculus
13:12:11 <Cheery> and the implementation-independent stuff
13:14:42 <tibbe> Cheery: Advanced topics in types and programming languages?
13:15:13 <tibbe> Cheery: start with Topics in Programming Languages by the same author
13:15:41 <shachaf> tibbe: s/Topics in/Types and/?
13:16:14 <tibbe> shachaf:  yeah, I'm lying on my back in my couch, I can't be arsed to type properly
13:16:27 * shachaf would like to read that.
13:17:24 <tibbe> I have it but haven't read it yet
13:19:22 <litb> hm, can i make 2 type constructors that have the same arguments but just another names?
13:19:24 <Cheery> tibbe: thank you
13:19:41 <litb> like data Foo  = (Foo | Bar) Arg1 Args;
13:19:51 <litb> or is there another way to do so?
13:19:55 <shachaf> litb: Oh, you mean data constructors.
13:20:04 <tibbe> Cheery: np
13:20:11 <shachaf> litb: Not as far as I know.
13:20:15 <litb> hm
13:21:12 <oerjan> litb: data Foo = Foo Arg1 Args | Bar Arg1 Args ?
13:21:29 <oerjan> nothing simpler though
13:22:28 <litb> ok, thanks
13:22:35 <byorgey> litb: you could also say data Foo = Foo Arg1 Args, and then data Bar = Bar1 Foo | Bar2 Foo
13:22:51 <byorgey> that introduces an extra data constructor though
13:23:16 <Toxaris> litb: or you could use data Foo = Foo Bar Arg1 Args; data Bar = Foo1 | Foo2
13:23:46 <byorgey> ah, that's probably the right way to do it.
13:33:05 <litb> Toxaris: ah, i understand that now :)
13:33:16 <litb> ok, if i want to add functions to my datatype, that is done with classes?
13:33:40 <Toxaris> litb: in most cases: no.
13:34:11 <litb> oops
13:34:14 <doserj> stop your OO thinking :)
13:34:28 <litb> hm :/
13:34:28 <byorgey> just... write some functions =)
13:34:40 <byorgey> myFunction :: Foo -> Foo
13:35:19 <litb> ok. and i use class if i have common things among *multiple* datatypes?
13:35:26 <litb> or what is it good for?
13:35:27 <byorgey> myFunction (Foo Foo1 x y) = Foo Foo2 x y  -- change Foo1's to Foo2's
13:36:00 <byorgey> litb: that's right.
13:36:00 <Toxaris> litb: yes basically.
13:36:47 <litb> so, object->type class->metatype if i transform OOP->haskell :)
13:36:53 <BMeph> I think it's prescient that bundling functions and data in object-oriented programming systems has the acronym OOPS. ;)
13:37:31 <litb> or, better object->data class->functions . errm, i better don't make such comparisons. i fail doing that anyway
13:38:21 <byorgey> litb: yeah, I don't think it's very helpful at this point to try comparing OO and haskell.
13:38:26 <Toxaris> litb: OO -> Haskell is a global transformation, you have to transform whole programs (or maybe modules) at once.
13:38:39 <litb> byorgey: so i could do a liftFoo1 with that =)
13:38:39 <byorgey> litb: you will just end up thinking of Haskell in OO terms and be confused when it doesn't work. =)
13:38:55 <Toxaris> litb: e.g. an OO class hierarchy may become a data type in Haskell with multiple constructors
13:39:06 <litb> i see
13:39:09 <BMeph> Not to mention that OO is all about global variable access.
13:39:46 <Toxaris> litb: but a different OO class hierarchy may become many Haskell data types wich contain each other
13:39:58 <BMeph> Sorry, not literally "all about" it, but colloquially, as in it's looked upon as a good thing, and not a design flaw.
13:40:08 <Toxaris> litb: and a third OO class hierarchy may become a Haskell type class and a number if instantiating data types
13:41:56 <Toxaris> litb: you can compare OO's underlying concepts with Haskell's underlying concepts (like subtype polymorphism vs. universal polymorphism, existential type support, ...), but this may not help you with learning Haskell if you used OO without caring for it's underlying concepts. (wich most OO language designer seem to do)
13:43:40 <litb> Toxaris: you mean, like liskov substitution principle?
13:44:17 <idnar> :hoogle [a] -> a -> [[a]]
13:44:19 <idnar> @hoogle [a] -> a -> [[a]]
13:44:21 <lambdabot> No matches, try a more general search
13:44:29 <idnar> @hoogle a -> [a] -> [[a]]
13:44:29 <lambdabot> No matches, try a more general search
13:44:32 <idnar> hmm
13:44:35 <litb> something interesting: how can i convert a function to String?
13:44:40 <litb> i  mean, the function definition?
13:44:57 <litb> so that (\x -> x) becomes "(\x -> x)" ? is that possible?
13:45:04 <Toxaris> litb: no.
13:45:06 <idnar> I'm looking for something like: split ',' "foo,bar,baz" == ["foo","bar","baz"]
13:45:26 <idnar> @src lines
13:45:26 <lambdabot> Source not found. I am sorry.
13:45:34 <Valodim_> huh
13:45:38 <Toxaris> litb: no, that's not possible. yes, like liskov substitution principle.
13:45:43 <idnar> @src words
13:45:43 <lambdabot> words s = case dropWhile isSpace s of
13:45:43 <lambdabot>     "" -> []
13:45:43 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
13:45:51 <byorgey> idnar: such a thing does not exist, but there's currently a proposal to add that to the standard library.
13:46:11 <byorgey> idnar: for now, you can just copy the source of words and replace 'isSpace' with whatever you like.
13:46:21 <idnar> I was going to use splitAt
13:46:29 <byorgey> @type splitAt
13:46:30 <idnar> oh wait, that's not what I thought either
13:46:36 <lambdabot> forall a. Int -> [a] -> ([a], [a])
13:46:37 <Toxaris> litb: but be aware that liskov substitution doesn't work in real languages because of ad-hoc subtype polymorphism
13:46:49 <ddarius> Obviously you just abstract isSpace out.
13:47:08 <litb> hm, i don't know what that is yet
13:47:30 <idnar> hmm
13:47:42 <idnar> splitBy :: (a -> Bool) -> [a] -> [[a]]
13:47:43 <litb> anyway, can i say that a function should only accept a datatype if it was created with a given ctor (without pattern matching, but with the type of that function)
13:48:16 <koeien> litb: i don't see how you can do that without pattern matching
13:48:49 <ddarius> @let splitWhen p s = case dropWhile p s of [] -> []; (_:cs) -> w : splitWhen p s' where (w,s') = break p s
13:48:51 <lambdabot> Defined.
13:48:56 <Toxaris> litb: (well, a OO subclass may override methods however it likes, breaking semantic compatibility with it's superclasses. in Haskell, it's different. if a function has type a -> a, it *really* works with every type a the same way)
13:49:05 <ddarius> > splitWhen (==',') "foo,bar,baz"
13:49:06 <lambdabot>  ["foo","","","","","","","","","","","","","","","","","","","","","","","",...
13:49:12 <litb> data Function = Function {...} | DeriverableFunction {...}
13:49:28 <litb> i think it can be done like that?
13:50:03 <litb> (all in that those differ is that DeriverableFunction has another function representing the deriveration
13:50:15 <ddarius> @let splitWhen' p s = case dropWhile p s of [] -> []; (_:cs) -> w : splitWhen p s' where (w,s') = break p cs
13:50:17 <Toxaris> litb: you cannot say that directly, but you can use phantom types as a work around
13:50:17 <lambdabot> Defined.
13:50:20 <ddarius> > splitWhen' (==',') "foo,bar,baz"
13:50:21 <lambdabot>  ["oo","","","","","","","","","","","","","","","","","","","","","","","","...
13:50:34 <phobes> libt, Toxaris:  Or you can just have a nested datatype
13:50:45 <litb> Toxaris: ah, i understand
13:51:31 <litb> nested datatype? what do you mean by that?
13:51:44 <idnar> > let splitBy p xs = case dropWhile p xs of [] -> []; xs' -> x : splitBy p xs'' where (x, xs'') = break p xs'     in splitBy (== ',') "foo,bar,baz"
13:51:45 <lambdabot>  ["foo","bar","baz"]
13:51:45 <koeien> @let splitWhen'' p xs of [] -> [] ; _ -> x : splitWhen'' p rest where (x,rest)=break p xs
13:51:46 <lambdabot>  Parse error
13:52:00 <litb> data Function = Function { function :: Double -> Double, deriveration :: Maybe (Double -> Double) } this?
13:52:11 <koeien> idnar: isn't there a function like that in the std library?
13:52:25 <koeien> idnar: i defined a function like that in ~ 3 of my haskell programs already
13:52:29 <idnar> koeien: byorgey just mentioned that there's a proposal to add something like it
13:52:41 <koeien> in that case i agree :)
13:52:42 <phobes> litb:  no
13:52:48 <koeien> :)
13:53:14 * osfameron watches the first sussman and abelson lecture, decides that the haskell version is lovelier
13:53:17 <osfameron> root' guess x = guess : root' (avg guess $ x / guess) x
13:53:38 <phobes> I mean instead of   "data Foo = A x y z | B p q r" you do "data A = A x y z ;   data Foo = WrapA | B p q r"
13:53:42 <osfameron> + the appropriate logic for choosing the "good enough" answer
13:53:44 <Sizur> does anybody know if pretty does look-ahead a few lines to do a better fit?
13:53:55 <litb> ah
13:53:56 <phobes> err "... data Foo = WrapA A | B p q r"
13:54:28 <phobes> Then you can write a function that takes an A and do whatever
13:54:32 <phobes> You don't get subtyping though
13:54:40 <litb> i see
13:54:51 <glen_quagmire> > data Foo = A B a | B a
13:54:51 <lambdabot>  Parse error at "data" (column 1)
13:54:56 <litb> maybe i should stay with the Maybe solution
13:55:00 <idnar> "zipWith (*) [1..] . map foo xs" or "zipWith (\(n, x) -> n * foo x)) [1..] xs" ?
13:55:17 <idnar> err
13:55:24 <idnar> drop xs there
13:55:33 <ddarius> and the tupling
13:56:00 <idnar> that too
13:56:23 <phobes> litb:  I don't understand your maybe solution - how does that type guarantee anything?
13:56:26 <litb> does it take considerable time if i pattern match?
13:56:30 <idnar> "zipWith (*) [1..] . map foo" or "zipWith (\n x -> n * foo x) [1..]"?
13:56:31 <ddarius> > let foo = (1+) in zipWith (ap (*) foo) [1..] [1..]
13:56:33 <lambdabot>   add an instance declaration for (Num (b -> c))
13:56:33 <lambdabot>     In the expression: 1
13:56:51 <phobes> litb:  I wouldn't say considerable... it's a branch basically
13:56:53 <litb> phobes: if a function doesn't have a deriveration, it sets deriveration to Nothing , else it sets it to Just <putTheDerivHere>
13:57:36 <litb> phobes: ah, i see. so it's probably not worth to consider, when i don't use the state-of-the-art_integration-algorithm i guess
13:57:38 <phobes> litb:  How is that in the type system?
13:57:47 <ddarius> @pl \n x -> n * foo x
13:57:47 <lambdabot> (. foo) . (*)
13:57:56 <litb> phobes: ah. yeah, it isn't represented in the type system
13:58:08 <RayNbow> sjanssen, what is this type family thing? [ http://programming.reddit.com/info/65vew/comments/c02xl2w ] :p
13:58:21 <sjanssen> @google indexed type families
13:58:22 <lambdabot> http://www.kottke.org/plus/type/silkscreen/
13:58:22 <lambdabot> Title: Silkscreen is a small free font for your Web graphics. (kottke.org)
13:58:29 <sjanssen> @google haskell type families
13:58:31 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions
13:58:31 <lambdabot> Title: TypeFunctions - GHC - Trac
13:58:36 <Taejo> If anyone's interested, I just solved Superghost in Haskell: http://programming.reddit.com/info/65wtn/comments/
13:59:27 <sjanssen> RayNbow: see http://www.haskell.org/haskellwiki/GHC/Type_families
13:59:28 <lambdabot> Title: GHC/Type families - HaskellWiki
14:00:06 <RayNbow> sjanssen: ah thx, I'll add it to my "to read" list
14:00:41 <koeien> Taejo: your link seems not functional
14:00:53 <phobes> worked for me
14:01:00 * RayNbow is currently watching http://programming.reddit.com/info/65vup/comments/ "Verifying Elections with Cryptography, Google Tech Talk [Video] (video.google.com)"
14:01:13 <koeien> http://squing.blogspot.com/2008/01/first-player-wins-superghost.html
14:01:14 <lambdabot> Title: The Most Fuun You Can Have: First player wins Superghost, http://tinyurl.com/32lgkl
14:01:53 <koeien>  /quit
14:02:14 <litb> > data Foo = Foo Int Int | Foo Int
14:02:14 <lambdabot>  Parse error at "data" (column 1)
14:02:32 <byorgey> Taejo: what, you're not going to post your code?
14:03:17 <Taejo> byorgey: ok, I'll add it now
14:03:24 <byorgey> =)
14:03:59 <phobes> Why are some of the responses empty?
14:04:20 <byorgey> phobes: those are the winning plays for the first player
14:04:30 <phobes> ah ok
14:04:42 <phobes> Ah yes, first player wins
14:06:28 <phobes> Taejo:  You should compute a minimal winning playbook for the first player
14:06:40 <phobes> it probably wouldn't be that big (?)
14:06:46 <czakey> some progress with gtk2hs for 6.8.2?
14:06:54 <Taejo> byorgey: it has code now
14:08:21 <dcoutts> czakey: you're talking about windows I suppose?
14:09:03 <czakey> yup
14:09:14 <Taejo> phobes: I should
14:11:02 <dcoutts> czakey: not so far, I have to check what extra bug fix patches to include before I do the build
14:11:21 <dcoutts> czakey: might do it this weekend
14:12:01 <czakey> ok
14:12:12 <czakey> thanks for info & your work :)
14:12:18 <dcoutts> np
14:15:05 <eu-prleu-peupe1> hello
14:15:41 <eu-prleu-peupe1> "http://tunes.org/~nef/logs/haskell/ - we put the funk in funktion" ahahahaha brutal
14:15:43 <lambdabot> Title: Index of /~nef/logs/haskell
14:17:14 <eu-prleu-peupe1> most functional programmers in my university are always trying to pull me off C, and they invent all kinds of stupid reasonings, that only work in their theoretical world of fibonnacci and factorial functions :/
14:17:47 <eu-prleu-peupe1> ...and they are complete zealots, which definetly is not funky
14:17:55 <dons> we like to write real world code here.
14:18:16 <kmcallister> eu-prleu-peupe1, write a compiler in C, and then write it in Haskell or ML
14:18:23 * BMeph waits patiently for someone to drop "XMonad" on eu-prleu-peupe1
14:18:27 <kmcallister> and you will see the real-world value of such languages
14:18:29 <kmcallister> hehe
14:18:32 <dons> did you have a specific question, eu-prleu-peupe1 ?
14:18:53 <eu-prleu-peupe1> dons: nope, just adding noise
14:19:02 <dons> ok.
14:19:10 <dons> noise is bad for our signal/noise ratio
14:19:14 <eu-prleu-peupe1> i really must go and read something... oh well
14:19:29 <kmcallister> eu-prleu-peupe1, read http://www.haskell.org/tutorial/ :D
14:19:29 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
14:19:31 <eu-prleu-peupe1> yes i understand, its not funky... ill go to study something heheh thanks
14:19:33 * kmcallister is a non-funky zealot
14:19:54 <eu-prleu-peupe1> okey
14:20:02 <eu-prleu-peupe1> thanks
14:20:14 <Japsu> What still bothers me is that every time someone asks for real world examples of Haskell being used in writing real software, people always come up with DARCS... and nothing else
14:20:26 <idnar> hmm, I want to diagonalize two lists, but I only want the "upper half" as it were
14:20:30 <dons> its one of the more visible open source projects
14:20:44 <dons> since people don't know the commercial projects
14:20:47 <Japsu> Yeah, and it's a good one
14:21:01 <kmcallister> xmonad is also a good example
14:21:05 <phobes> Is there a way to write down fibs and compute fibs !! n in constant space?
14:21:11 <dons> yeah
14:21:16 <eu-prleu-peupe1> well none of my colleagues code in haskell, so i look at haskell as "the last hope of functional programming languages"
14:21:20 <kmcallister> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs
14:21:23 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
14:21:23 <eu-prleu-peupe1> they do a lot of lisp and a lot of ruby though :/
14:21:33 <eu-prleu-peupe1> well ill stop the noise
14:21:34 <dons> oh well, they probably can't be saved then
14:21:35 <eu-prleu-peupe1> hasta
14:21:38 <idnar> ie. I don't need both (a,b) and (b,a)
14:21:47 <RayNbow> kmcallister: you could also start with 0 and 1
14:21:57 <kmcallister> very true
14:22:10 <dcoutts> Japsu: how about WASH, eg: http://braintreehemp.com.au/
14:22:15 <phobes> kmcallister:  But that's not constant space is it?  If you compute fibs !! 100000, that's going to keep around the first 100000 members of the sequence isn't it?
14:22:47 <Valodim_> haha, I read treehump there at first glance
14:22:56 <IvdSangen> you can do it naively with accumulators
14:23:15 <Japsu> dcoutts: that's some web shop application?
14:23:18 <Japsu> interesting
14:23:28 <Japsu> in hApps?
14:23:29 <kmcallister> phobes, won't they get GC'd?
14:23:37 <kmcallister> since as you're dropping elems there's nothing left pointing at them?
14:23:44 <litb> phobes: couldn't he do head (drop 99999 fibs) ?
14:23:49 <dcoutts> Japsu: not happs, WASH is a continuation based web framework
14:23:52 <kmcallister> ?src (!!)
14:23:53 <lambdabot> xs     !! n | n < 0 = undefined
14:23:53 <lambdabot> []     !! _         = undefined
14:23:53 <lambdabot> (x:_)  !! 0         = x
14:23:53 <lambdabot> (_:xs) !! n         = xs !! (n-1)
14:23:59 <litb> or does drop saves the list in memory too?
14:24:02 <Japsu> dcoutts: ok
14:24:09 <dons> hpaste.org is in happs, hackage.haskell.org is in cgi/xhtml, iirc
14:24:11 <phobes> kmcallister:  maybeso if the compiler optimizes it
14:24:18 <dcoutts> Japsu: but happs is also a very interesting web framework
14:24:27 <dons> it'd be nice for other examples of happs sits
14:24:32 <phobes> kmcallister:  my point was that 'fibs' is still pointing at the beginning
14:24:37 <oerjan> > let diag l = [(x,y) | ys@(x:_) <- tails l, y <- ys] in diag [1..4]
14:24:39 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3,3),(3,4),(4,4)]
14:24:57 <dcoutts> dons: well we might see a hackagedb rewrite using happs
14:25:00 <idnar> > let diag l = [(x,y) | ys@(x:_) <- tails l, y <- ys] in diag [1..]
14:25:00 <kmcallister> but is the value "fibs" necessarily in memory anywhere, especially if it's local to a let binding?
14:25:01 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),...
14:25:05 <kmcallister> i'm not sure, i think this is an implementation issue
14:25:27 <idnar> hmm, I guess it's fine, my list isn't actually infinite
14:25:28 <phobes> kmcallister:  Ya, maybe not if it's a local binding
14:26:00 <kmcallister> also there are other tricky places it could live, i.e. in the stack frame for the call to drop
14:26:22 <davidL> doesn't pass.net use happs too?
14:26:43 <phobes> kmcallister:  ya
14:27:17 <dons> davidL: yep
14:34:39 <BMeph> Off to home - BBL
14:42:11 <dons> bos: are rhino's the haskell animal? rare in the wild, but indestructable? and they'll impale you on some well typed horns if you're not careful? :)
14:42:41 <Valodim_> rhino = js
14:43:37 <dons> hmm. js is way to fragile to be a rhino . and too common
14:43:39 <bos> dons: how about an ibex? rare, beautiful, and agile in dangerous settings!
14:43:40 <dons> js is more like a rat.
14:43:48 <bos> and still horned
14:43:52 <dons> bos, yeah, definitely along those lines.
14:43:59 <dons> one of this rare, tough and dangerous if provoked
14:44:49 <dons> like a cassowary
14:45:20 <dons> yeah, the ibex has unworldly horns
14:45:59 <phobes> Is there a function that takes 3,  [1,2,3,4,5 ..   to [[1,2,3], [2,3,4], [3,4,5], .. ?
14:46:42 <phobes> (ie takes an integer n and a stream to the stream of all n-tuples of that stream)
14:46:54 <jfredett> takes n ls = (take n ls) : (takes n (drop n ls)) ?
14:46:56 <jfredett> maybe?
14:47:09 <sarehu> s/drop n/tail/
14:47:17 <Jaak> > take 10 . map (take 3) $ tails [1..]
14:47:17 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11],...
14:47:23 <idnar> > let takes n ls = map (take n) (tails ls) in takes 3 [1..]
14:47:24 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11],...
14:47:27 <jfredett> > let takes n ls = (take n ls) : (takes n (tail ls)) in takes 3 [1..10]
14:47:27 <lambdabot>  Exception: Prelude.tail: empty list
14:47:40 <phobes> ya I could write one :)  But this doesn't have a common name?
14:47:44 <jfredett> idnar's is cooler
14:47:56 <jfredett> phobes' function? otherwise I don't think so
14:47:57 <jfredett> :P
14:48:02 <phobes> (I assume no, since I just got five version of it written out)
14:48:20 <idnar> there's also [[1,2,3],[4,5,6],...]
14:48:27 <phobes> ya
14:48:32 <idnar> which is a little trickier
14:48:40 <phobes> which I think isn't as interesting when dealing with streams
14:48:57 <jfredett> idnar: not really, my first version would work, just do...
14:49:12 <jfredett> > let takes n m ls = (take n ls) : (takes n (drop mls)) in takes 3 3 [1..]
14:49:12 <lambdabot>   Not in scope: `mls'
14:49:16 <jfredett> > let takes n m ls = (take n ls) : (takes n (drop m ls)) in takes 3 3 [1..]
14:49:16 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int'
14:49:18 <idnar> > let takes n ls = (take n ls) : (takes n (drop n ls)) in takes 3 [1..]
14:49:19 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,...
14:49:26 <idnar> your first one was already that ;)
14:49:28 <jfredett> or, not... :/
14:49:49 <jfredett> i was trying to make it more general, but I suppose that works.
14:50:15 <idnar> yeah, I guess you could generalise over the size of the window, and how far it slides each time
14:50:18 <idnar> (so to speak)
14:50:21 <jfredett> yah
14:50:39 <mauke> > let takes n ls = takes n <$> splitAt n ls in takes 3 [1..]
14:50:40 <lambdabot>      Occurs check: cannot construct the infinite type: b = ([a], b)
14:50:40 <lambdabot>       Exp...
14:51:01 <mauke> right, right
14:51:13 <glen_quagmire> left, left
14:51:15 <glen_quagmire> :t left
14:51:16 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
14:51:25 <glen_quagmire> :t right
14:51:26 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either d b) (Either d c)
14:51:40 <andyjgill> What is the type of <$>?
14:51:43 <mauke> > let takes n ls = uncurry (:) $ takes n <$> splitAt n ls in takes 3 [1..]
14:51:47 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,...
14:51:49 <Tac-Tics> :t <($)>
14:51:50 <lambdabot> parse error on input `<'
14:51:52 <Tac-Tics> er
14:51:54 <jfredett> :t (<$>)
14:51:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:51:55 <Tac-Tics> :t (<$>)
14:51:55 <glen_quagmire> :t (<$>)
14:51:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:51:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:52:03 <jfredett> lol
14:52:06 <Tac-Tics> heh
14:52:10 <andyjgill> Ahh. imported form somewhere else.
14:52:10 <glen_quagmire> rofl
14:52:16 <jfredett> @quote stereo
14:52:16 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
14:52:21 <jfredett> aww,
14:52:21 <glen_quagmire> @i (<$>)
14:52:22 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
14:52:40 <glen_quagmire> @hoogle (<$>)
14:52:41 <lambdabot> Did you mean: (<$>)
14:52:41 <lambdabot> Prelude.undefined :: a
14:52:41 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
14:53:10 <Tac-Tics> > (++ "... in bed!") <$> ["You will find peace in life", "You will find good fortune", "You are an interesting person"]
14:53:11 <lambdabot>  ["You will find peace in life... in bed!","You will find good fortune... in ...
14:57:47 <Lemmih> Tell that to the coma guy.
15:02:19 * dcoutts implements http://hackage.haskell.org/trac/hackage/ticket/167
15:02:21 <lambdabot> Title: #167 (cabal-install should treat package names case insenitively in the UI where ...
15:02:35 <wolverian> @hoogle <$>
15:02:36 <lambdabot> Control.Applicative.(<$>) :: Functor f => (a -> b) -> f a -> f b
15:02:44 <dcoutts> anyone want to test it?
15:02:47 <wolverian> for some reason it doesn't want is operators inside parens
15:02:55 <wolverian> s/is/its/
15:03:32 <dusty_> Does anyone have experience porting GHC?
15:03:42 <dcoutts> dusty_: a bit, it's hard :-)
15:03:48 * dcoutts pushes cabal-install patches for ticket #167
15:03:55 <dusty_> I've noticed
15:04:06 <dcoutts> someone wants to test the cabal-install changes I just know...
15:04:23 <dcoutts> Lemmih, dons: you can now cabal install haxml :-)
15:04:44 <dcoutts> SyntaxNinja: you complained about that one too, now fixed.
15:06:40 <TomMD> dusty_: What are you porting to?
15:06:49 <dusty_> armel
15:07:03 <TomMD> And would you be willing to blog or post about the experience and any gottchas?
15:07:08 <ddarius> SPJ is 50?!
15:07:17 <dusty_> sure
15:08:29 <dusty_> I know GHC has already been ported to armel, but for a different version of libc
15:10:08 <mb43> hi!
15:10:35 <mb43> a simple question: the function (abs.(-)) is binary, isnt it?
15:10:45 <kmcallister> :t (abs.(-))
15:10:47 <lambdabot> forall a. (Num (a -> a), Num a) => a -> a -> a
15:11:00 <mb43> But i cannot apply two arguments :(
15:11:12 <kmcallister> it's unlikely you'll be able to satisfy the typeclass constraints :)
15:11:24 <mb43> Ah. Why not?
15:11:27 <kmcallister> it wants a type a such that a is a type of number, and also functions from a to a are also a type of number
15:11:33 <kmcallister> Num (a -> a), Num a
15:11:35 <dusty_> The problem I'm running into right now is that when building on the target, the .hi files are missing
15:11:40 <kaol> @where DSL
15:11:41 <lambdabot> I know nothing about dsl.
15:11:46 <mb43> Hm, ok.
15:11:53 <Saizan> ?type (abs.) . (-)
15:11:54 <lambdabot> forall a. (Num a) => a -> a -> a
15:12:13 <kmcallister> > let f = (abs.) . (-) in 3 `f` 4
15:12:18 <lambdabot>  1
15:12:27 <Saizan> that's how you make \x y -> abs (x - y) point free
15:12:38 <kmcallister> ?pl \x y -> abs (x - y)
15:12:38 <lambdabot> (abs .) . (-)
15:12:58 <mb43> Ok. And what does that mean?
15:13:26 <kaol> hmm... a DSL to generate XML? would that make sense? have I even understood what DSLs are for, remotely?
15:14:27 <Saizan> mb43: in which terms?
15:15:16 <wolverian> kaol, sounds sensible to me. (see Text.Xhtml?)
15:15:22 <mb43> The problem was in g = head (filter (1 /=) (zipWith ((gcd n).(-)) xl yl))
15:15:43 <mb43> With an abs missing :)
15:16:20 <mb43> All of the symbols have Integral Type.
15:16:24 <Saizan> ?ty \n -> (gcd n).(-)
15:16:26 <lambdabot> forall a. (Integral (a -> a), Num a) => (a -> a) -> a -> a -> a
15:16:35 <kaol> I want to write some XSL templates but those just scream to be generated by something else, not to be written by hand
15:16:55 <Saizan> (gcd n) . (-) is already illtyped
15:17:22 <ddarius> kaol: Just compile (a subset of) Haskell to it.  It should be pretty straightforward.
15:17:24 <mb43> Would that further point help? Like this: (gcd n . ) . (-)?
15:17:36 <mb43> And what would that mean?
15:17:49 <ddarius> @unpl (gcd n .) . (-)
15:17:49 <lambdabot> (\ d g -> gcd n (d - g))
15:18:00 <ddarius> Why not just use lambda notation?
15:18:01 <Saizan> the lambda says it all :)
15:18:22 <mb43> Well, it works well with lamda abstraction :) But i wantet to try it without.
15:19:32 <Saizan> f . g = \x -> f (g x), so (f .) . g = \x -> (f .) (g x) = \x -> \y -> f ((g x) y) = \x y -> f (g x y)
15:20:07 <Saizan> "the right function takes 2 arguments, the left function takes the result"
15:20:47 <mb43> Another question would be, if the list will require more memory than a simple recursive solution?
15:21:01 <mb43> Does Haskell remember the whole list all the time?
15:21:17 <Saizan> no, the whole list might not even ever be there
15:21:38 <dons> often the list never exists, in any form.
15:21:40 <mb43> Ok. I thought so, when measuring memory usage.
15:21:45 <dons> its really a control structure.
15:22:21 <dons> e.g. main = mapM_ print [1..] -- no list or cons is ever created. its just a for loop sptting values out
15:22:33 <shapr> hiya dpn`
15:22:35 <mb43> ok.
15:22:42 <shapr> jfredett: Coming to dinner tonight in Porter Square?
15:22:53 <mb43> is there any rule, when lists are saved?
15:23:03 <dpn`> hey shapr
15:23:07 <shapr> hi!
15:23:20 <sjanssen> mb43: values are kept when there are still references to them left (standard garbage collection)
15:23:22 <Saizan> because of lazy evaluation the part of the list that has not already used is not computed, if you don't have a reference to the head the part consumed can be garbage collected
15:23:42 <shapr> Saizan: Oh hey, Ed thought up a really cool MACID monad today...
15:23:47 <mb43> and garbage collection is immediate?
15:23:55 <Saizan> no
15:24:19 <sjanssen> mb43: so, in dons example: "main = let xs = [1..] in do mapM_ print xs; mapM_ print xs", xs will be kept around and your memory will fill
15:24:24 <sjanssen> mb43: immediate enough
15:24:33 <droundy> Hi all!
15:24:36 <Saizan> shapr: err, Ed?
15:24:37 <shapr> hi!
15:24:42 <sjanssen> greetings
15:24:43 <shapr> Saizan: Um, edwardk
15:24:43 <mb43> So a recursive solution could be better optimized, using a loop?
15:24:56 <droundy> Anyone here who can help me with a segfault bug in darcs, related (I believe) to IORefs and concurrency?
15:25:03 <mb43> Then, there is no need for gc?
15:25:28 <sjanssen> droundy: we can try :)
15:25:51 <Saizan> shapr: ah! is it written up somewhere?
15:26:06 <shapr> Saizan: Only on my laptop...
15:26:07 <droundy> Do you know if writing to an IORef in one thread while reading from it in another could lead to a segfault?
15:26:10 <sjanssen> mb43: the garbage collector is highly tuned -- a recursive loop might be faster, but not by very much
15:26:21 <shapr> I can probably spout typesigs off the top of my head though...
15:26:29 <ddarius> mb43: dons' point is that in some cases the list using code will be turned into a loop
15:26:32 <Saizan> also ghc can do that optimization by itself
15:26:47 <mb43> AH, ok.
15:26:57 <dons> IORefs and concurrency sound like a bad mix, david
15:27:04 <shapr> Um, or not.. I'm tired.
15:27:06 <dons> at least MVars will stop you trashing writes
15:27:53 <shapr> Saizan: Anyway, I'll try to get source up soon.
15:27:53 <sjanssen> droundy: what are the contents of the IORef?  You didn't build it with unsafePerformIO, and used it polymorphically, perchance?
15:28:13 <dons> IORefs are also only threadsafe if you've got 1 of them, and use atomicModify
15:28:27 <LoganCapaldo> @type atomicModify
15:28:29 <ddarius> sjanssen: It's monomorphic.
15:28:30 <lambdabot> Not in scope: `atomicModify'
15:28:33 <droundy> sjanssen: it's a Data.Map, and not at all polymorphic
15:29:03 <Saizan> shapr: ok :), however i was just curious :)
15:29:26 <shapr> Saizan: It's pretty cool, wish I could remember more :-)
15:30:02 <LoganCapaldo> unsafePerformSurgery
15:30:18 <droundy> dons: what does "unthreadsafe" mean, I always figured it'd mean you'd get inconsistent results, but not sefaults?
15:30:37 <LoganCapaldo> unsafePerform is a good prefix
15:30:45 <sjanssen> droundy: how much code would you have to change to use an MVar?
15:31:10 <dons> droundy: race conditions. two threads take, only one updates, the other is lost
15:31:27 <droundy> sjanssen: probably not much, but I really don't want that performance hit, as it's possible this code will get into tight loops.
15:31:28 <dons> MVars are almost always a better choice for top level globals
15:31:36 <LoganCapaldo> inconsistent results can cuase segfaults. something_t **p; if * ends up with 0 in it as a result of inconsistenc ies **p is a segfault
15:31:43 <droundy> dons: that's the key, only one thread ever updates this, the other threads just read.
15:31:48 <LoganCapaldo> s/if */if *p/
15:31:51 <TomMD> Or STM... (yes, I am a fanatic)
15:31:52 <bos> droundy: if you've got a tight loop, STM might make sense.
15:32:17 <droundy> bos: but I don't need locking at all, provided I can always read the silly thing
15:32:21 <sjanssen> does darcs still run on GHC 6.2?  If so, STM is not an option
15:32:30 <LoganCapaldo> </contrived-non-haskell-example>
15:32:31 <bos> droundy: but we don't have lock-free variables.
15:33:45 <bos> droundy: what is it you're trying to do, anyway?  i wouldn't have thought darcs would need threads at all.
15:34:04 <dons> pipelining http requests, is it?
15:34:07 <droundy> I just want to output progress while darcs is doing long-running computations
15:34:13 <dons> ah
15:34:21 <dons> oh, there's purely functional progress bars.
15:34:29 <dons> there was a paper at icfp a couple of years ago.
15:34:45 <droundy> so all the "real" work is done in a single thread, which updates the progress variable, while another thread reads it and outputs stuff.
15:34:47 <bos> haskell is the only language where you can get a conference publication out of writing a progress bar.
15:34:54 <dons> droundy: how about Chans
15:35:06 <dons> link the producer and consumer via a lazy list of events
15:35:06 <droundy> dons: again, wouldn't that be higher-overhead?
15:35:10 <sjanssen> droundy: an MVar/Chan sounds perfect for that, you don't want the outputter thread to continually spin
15:35:12 <LoganCapaldo> @remember bos haskell is the only language where you can get a conference publication out of writing a progress bar.
15:35:12 <lambdabot> Nice!
15:35:14 <dons> very little, a couple of MVars
15:35:24 <droundy> Chans are as expensive as MVars, I'd rather not use that.
15:35:33 <droundy> when there's no need for synchronization
15:35:37 <dons> if its ok to miss events, MVars would be fine.
15:35:48 <dons> just update the box, the writer then blocks waiting for anything to land
15:35:50 <droundy> I *want* to miss events, that's the point.
15:36:10 <dons> ok.MVar! and you get the writer waiting for free. and MVars are super super cheap
15:36:33 <droundy> I *don't* want the writer waiting for anything, the writer needs to be lightning-fast.
15:36:43 <bos> but there is a need for synchronisation, that's the thing.  how many of these events are you reporting per second, anyway?
15:36:49 <monochrom> Something must be done to the topic line about SPJ's birthday!
15:36:57 <dons> monochrom: good idea. on it.
15:37:25 <monochrom> Hehe danke.
15:37:30 <dons> droundy: check the shootout, threads asleep on an MVar are cheaper in haskell than any other lang. they're light, and the rts will wake them up on writes
15:37:42 <monochrom> Time flies like a morphism. Couldn't believe he's already 50.
15:37:47 <droundy> I don't know how many events per second we'll be writing, but possibly very many.  I'd like to not have to agonize over which loops are too-fast to be safe to report progress on.
15:38:19 <droundy> dons: I plan on my threads spending most of their time asleep on threadDelay
15:38:44 <droundy> if the threads wake up on each progress report that'll be a real performance hit.
15:38:49 <dons> ok.
15:39:03 <dons> so have it wait a second, then grab whatever's in the MVar
15:39:11 <bos> droundy: you *could* peek and poke Ptr Int32.
15:39:14 <dons> meanwhile the generator is just spitting updates in the MVar
15:39:37 <bos> er, Ptr CInt.
15:40:00 * bos flinches at the thought of recommending such things
15:40:20 <Saizan> bos: isn't an IORef the right thing for that?
15:40:23 --- mode: ChanServ set +o dons
15:40:27 --- topic: set to '["Happy 50th Birthday Simon!","The Haskell programming language" ,"http://haskell.org " ,"http://www.jobs-in-fp.org/" ,"Paste: http://hpaste.org " ,"Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
15:40:42 <dons> i bet a beer at ICFP that MVars or Chans would be fine here.
15:40:52 <LoganCapaldo> unsafePerformTopicChange
15:40:55 <dons> hmp3, yi, all use MVars or Chans for progress bars
15:40:57 --- mode: ChanServ set -o dons
15:41:07 <bos> droundy: to be quite honest, you're really, really better off using a sensible, safe type, and then worrying about performance if you ever see it in a profile.
15:41:28 <Cale> Perhaps SampleVar is more appropriate here
15:41:32 <dons> safety should be the first priority. any instability in darcs is really dangerous.
15:41:47 <droundy> bos: but I don't see that it gains me any safety, or I don't understand why it should, anyhow.
15:41:49 <bos> given darcs's past problems with calling fromJust when you "knew" that it was safe under the circumstances, i'm surprised you're still leaping at performance over correctness.
15:41:50 <Cale> err...
15:42:26 <sjanssen> Cale: SampleVar is implemented with MVars, so I'd expect similar (or worse) performance
15:42:44 <dons> it probably ends up as the same code, modulo inlining
15:43:03 <Gwern-away> 'I'm boggled by the sheer
15:43:04 <Gwern-away> +number of libraries that are announced these days in each issue of the Haskell Weekly (sic) News.'
15:43:10 <Cale> Yeah, it's sort of missing an analogue to 'readMVar', which makes it less useful here.
15:43:13 * Gwern-away lols
15:43:15 <dons> Gwern-away: :)
15:43:31 <Cale> Gwern-away: are you quoting someone?
15:43:39 <dons> Cale: spj's 50th birthday announcement
15:43:43 <Cale> ah
15:43:46 <Gwern-away> dons: I feel a little guilty about that, actually. I'm more a writer than a coder, and I know I could be making the HWN much more weekly
15:44:15 <dons> is that a job offer?
15:44:32 <dons> if so, i'm quite interested :)
15:44:43 <sclv> being a bit contrarian here but it seems to me that atomicModifyIORef should be fine.
15:44:49 <dons> we could collaborate, and i know you're great at the writing/chasing down info stuff the HWN is all about
15:45:05 <dons> Gwern-away: write me an email outlining what you'd like to do.
15:45:06 * bos votes for anything that gives dons more book-writing cycles!
15:45:11 * dons agrees
15:45:26 * Gwern-away feels guilty because I'm not doing anything about it, and don't really have plans
15:45:35 <ray> does anyone know what the story is (was?) with ghc and freebsd 7?
15:45:45 <dons> send an email! we can share a darcs repo, and you can commit stories into it, for example
15:45:51 <dons> ray, works now, iirc
15:45:57 <LoganCapaldo> it's a sordid story of two star crossed lovers
15:46:02 <LoganCapaldo> no wait, that'
15:46:05 <LoganCapaldo> s romeo and juliet
15:46:08 <Gwern-away> dons: isn't the hwn darcs repo already public?
15:46:35 <dons> it is. i'd move it somewhere you had commit access to. you'd chase down stories, i'd review the results, we'd publish weekly.
15:46:41 <Gwern-away> LoganCapaldo: of two star-crossed lovers, STM and Programmer, and their nobles families of IO and FP which tried to keep them apart
15:46:45 <dons> you'd need to spend about an hour a week, or less
15:47:11 <Gwern-away> dons: dunno. compiling the quotes and blog posts looked like it'd take a lot of time
15:47:24 <dons> that's done automagically
15:47:33 <dons> i'd do that. you'd do the discussions and announcements
15:47:46 <Gwern-away> really? what sort of script does that?
15:47:47 <dons> the natural language processing stuff :)
15:48:03 <mb43> Thank you for explaining! I am off again!
15:48:05 <LoganCapaldo> it's don's secret weapon in the war aginst ignorance
15:48:07 <droundy> okay, it turns out that using MVars doesn't fix the segfault.  :(
15:48:08 <dons> rss aggregators/little scripts to automate things
15:48:35 <Gwern-away> hm. does anyone here run yi out of darcs? does the current darcs compile for you?
15:48:37 <dons> droundy: can you reproduce it in a small case?
15:48:48 <dons> is ti something to do with -threaded /blocking network calls/ ... ?
15:49:02 <droundy> dons: I doubt it.
15:49:08 <droundy> I'll keep debugging
15:49:31 <dons> why is unsafePerformIO used? double check any use of that.
15:49:47 <tehgeekmeister> which of the haskell xml libraries would be best for speed and memory usage?  i don't need to do anything fancy, just read a bunch of xml data and then i'll use the data elsewhere, but there's about two gigs of it that i need to work with.
15:50:08 <dons> tehgeekmeister: probably the libxml binding
15:50:28 <tehgeekmeister> dons: thanks.
15:50:29 <dons> i'm not sure the haxml or hxt ones have been optimised for large processing, though haxml is maximally lazy (iirc)
15:50:35 <Gwern-away> tehgeekmeister: depends on what sort of stuff you want to do. if it's simple, something like tagsoup might well be workable, but I don't know how great performance is
15:50:49 <dons> tehgeekmeister: its a todo to have a fast, light bytestring xml ripper
15:51:41 <Gwern-away> (1414 patches to darcs get for yi... we really need to do another release soon)
15:51:54 <Cale> > 26^3
15:51:56 <lambdabot>  17576
15:52:02 <tehgeekmeister> Gwern-away: i just need to get the data out of xml, nothing more.
15:52:08 <droundy> dons: I'm filtering out unsafePerformIO (which is used as a convenience way to annotate functions for progress output)
15:52:20 <Gwern-away> speaking of darcs getting stuff... dons, did you receive my monstrous frag patches yet? ;)
15:52:38 <dons> i did.
15:52:48 <dons> though its better if you send them to my us email addr,
15:52:58 <Gwern-away> galois.com right?
15:52:59 <dons> since then they get marked up a bit more obviously
15:53:01 <dons> yup
15:53:07 <dons> i'll look at them later
15:53:22 * Gwern-away will update the old email addresses where I see them, then
15:53:34 <Cale> droundy: I'm running a test with that many (26^3) readers, one writer, and an IORef it's a little crunchy, but it's not segfaulting.
15:54:18 <LoganCapaldo> heh
15:54:23 <LoganCapaldo> crunchy
15:54:53 <droundy> Cale: I'm starting to wonder what is causing this... the segfault stays with pretty much all the unsafePerformIO removed (just those needed to implement global IORefs)
15:55:22 <Cale> Between rounds of each reader thread printing its results, it seems to stop and think about scheduling or something.
15:55:25 <dons> oh, do you have noinline on those?
15:55:38 <dons> {-# NOINLINE myScaryGlobal #-} ?
15:56:00 <Cale> Usually I warn people away from global IORefs altogether ;)
15:56:04 <ddarius> dons: Parts of the code are on the mailing list.
15:56:25 <Cale> But I don't know.
15:56:27 <hpaste>  sjanssen pasted "ioref.hs" at http://hpaste.org/5087
15:56:29 <Cale> Maybe it's something else.
15:56:29 <ddarius> What he's describing does not sound like it should cause a segfault, so the problem is probably elsewhere.
15:56:36 <dons> yah
15:57:15 <LoganCapaldo> see if iorefs were a first class feature we wouln't have this problem. Or need to use these strange non standard {-# pragrams. We could just say global IORef a
15:57:31 <hpaste>  sjanssen annotated "ioref.hs" with "oops, previous was mvar.hs, this is ioref.hs" at http://hpaste.org/5087#a1
15:57:32 * bos gives LoganCapaldo a pony
15:57:40 <ddarius> LoganCapaldo: IORefs are as first class as anything else.
15:57:41 <kmcallister> that would involve complicating the language though
15:57:43 <dons> bos++
15:57:55 <kmcallister> would implicit parameters be a good way to do global IORefs?
15:57:59 <kmcallister> we have those
15:58:07 <dons> well, we also have Monads. :)
15:58:14 <droundy> dons: yes I do have NOINLINE on my globals
15:58:16 <LoganCapaldo> C has first class ioref, why can't the language of the future, Haskell, have them?
15:58:19 <kmcallister> yeah, but you have to pass the iorefs around
15:58:27 <Cale> sjanssen: that dies almost immediately after the threads are spawned, because your main thread has nothing to do
15:58:29 <kmcallister> LoganCapaldo, because it breaks semantics
15:58:32 <dons> LoganCapaldo: it does have first class IORefs... :)
15:58:50 <LoganCapaldo> I do not think I'll be able to use Haskell for my real time storck trading system now
15:58:50 <kmcallister> yeah, "first class" is not the term you want i think
15:59:02 * LoganCapaldo stops trolling
15:59:05 <dons> heh. sure, LoganCapaldo.
15:59:08 <kmcallister> LoganCapaldo, what about ML?
15:59:12 <Nafai> LoganCapaldo: You are trading storks?
15:59:15 * dons slaps kmcallister. don't feed him
15:59:16 <ddarius> It is hard to trade storks in real time without IORefs.
15:59:18 <LoganCapaldo> indeed
15:59:22 <kmcallister> dons: :/
15:59:32 <monochrom> C has first-class unrestricted type casts too.
15:59:42 <Cale> hmm, trading storks...
15:59:48 <sjanssen> Cale: note *take*MVar
15:59:48 <dons> you need those to cast storks to geese
15:59:50 <kmcallister> C has first class shooting your self in the foot :D
16:00:01 <kmcallister> how much can you make trading storks anyway?
16:00:05 <droundy> It seems that threading wasn't responsible at all:  Disabling my forkIO leaves the segfault behind.  I think it may be the libwww code after all (although it's annoying it just pokes up now)
16:00:26 <hpaste>  sjanssen annotated "ioref.hs" with "barely any difference" at http://hpaste.org/5087#a2
16:00:48 <dons> ffi stuff is super double plus suspicicous when segfaults are around
16:00:48 <dons> esp. when type decls for foreign imports are unchecked
16:00:49 <Cale> sjanssen: oh, duh, I'm not looking carefully enough :)
16:00:49 <Cale> sjanssen: I figured there was a forkIO in there somewhere, but no there isn't :)
16:00:49 <kmcallister> and do you trade them with or without baby attached
16:00:54 <droundy> dons: it's just that I've been using it for days without trouble... who would have expected it'd just show up now?
16:01:01 * BMeph wonders if "segmentation fault (core dumped)." was a prevalent error before the invention of C
16:01:11 <kmcallister> BMeph, almost certainly
16:01:20 <kmcallister> in the predecessor to C there were no types at all
16:01:41 <sjanssen> droundy: see my paste, I don't think MVar is going to be a bottle-neck here
16:01:56 <BMeph> kmcallister: "the" predecessor, as in B?
16:01:59 <kmcallister> BCPL
16:03:07 <droundy> sjanssen: but there's no benefit from MVar, unless IORefs are buggy.
16:03:19 <sjanssen> droundy: that's true
16:03:29 <sjanssen> just try to dispell the misconception
16:03:32 <droundy> (And I'd rather hear that from a Simon)
16:04:04 <droundy> sjanssen: do you have the code form that paste?
16:04:51 <sjanssen> droundy: http://hpaste.org/5087
16:06:04 <droundy> sjanssen: the timing I'd be interested in more would be one that only writes and never reads.  That's the situation I'm concerned with.
16:06:46 <kmcallister> BMeph, of course before MMU's were invented you'd never get a segfault, just crazy undefined behavior... reminds me of Macintosh Russian Roulette in AP CompSci class
16:07:28 <droundy> It's confirmed:  the bug was libwww bindings (or libwww itself).
16:08:01 <dons> awesome. and we've fast threadsafe progress report code too
16:09:49 <sjanssen> droundy: similar results
16:09:56 <droundy> ok
16:10:05 <sjanssen> droundy: MVar is *really* fast without -threaded
16:10:27 <droundy> I see.  With -threaded it'd be much slower?
16:10:39 <sjanssen> yeah, because GHC has to do actual locking
16:10:53 <sjanssen> IORef might take a similar performance hit, not sure about that
16:14:12 <sjanssen> mvar is about 4x slower with -threaded (but it isn't like darcs can use -threaded anyway)
16:14:34 <sjanssen> well, it can't *rely* on -threaded
16:16:48 <monochrom> My friend told me a horror story of his friend in the MSDOS days. He had a C program with a pointer error. It caused the hard disk to be formatted. Retrospective theory: the pointer error led to jumping into the BIOS code and hit upon the disk formatting section...
16:17:10 <sjanssen> oh, the good old days
16:19:23 <dons> sjanssen: hey, why don't we put the 'evolution of a haskell programmer' on the wiki
16:19:31 <dons> so we can keep it up to date with the latest tricks
16:19:43 <Philippa> monochrom: ouch, that took some doing
16:19:43 <sjanssen> dons: yeah, I was considering that earlier
16:19:44 <monochrom> Because a haskell programmer is by intelligent design.  <duck>
16:20:09 <dons> i'd like to see lennart's harpy/edsl for generating fibonaccis in raw asm done this way
16:20:12 <dons> for example.
16:20:15 <dons> and something using applicatives
16:20:41 <monochrom> neato
16:20:58 * BMeph chucks a fat (<$>).(<$>) dons' way
16:21:20 <scodil> how do you figure out what kind type variables have in signatures? I've got something that is supposed to be kind * -> * but it keeps telling me its applied to too many arguments. But I don't know where the compiler is getting the idea that it has to be kind *.
16:22:07 <Philippa> pretty much by running the kind inference algorithm yourself
16:22:10 <ddarius> scodil: If you don't give an explicit kind signature I believe Haskell assumes it's *
16:22:25 <scodil> how do you give a kind signature?
16:22:33 <Philippa> no, it does kind inference. It'll assume * if it can't figure anything else out
16:22:55 <Philippa> but every m-as-in-monad has been kind * -> * regardless of whether there was a kind signiature anywhere
16:23:28 <scodil> ok how do I tell it that the kind should be * -> *. I figured that having it appear in applied form, like (m a), it would figure out that m has kind * -> *, instead of complaining that m is applied to too many arguments
16:23:50 <Philippa> that depends whether it's unified m with another variable or not beforehand
16:24:18 <Saizan> scodil: can you paste the code?
16:24:25 <Philippa> what it expects depends on the order it looks at stuff. You're using it with kind * somewhere the typechecker gets to 'earlier'
16:24:27 <LoganCapaldo> don't do it!
16:24:27 <ddarius> Philippa: I meant in the case where it can't figure it out.
16:24:44 <scodil>   org   :: (Duals p d) => FEdge p -> m (p Int)
16:24:55 <scodil> error p is applied to too many arguments
16:25:04 <Saizan> how is Duals defined?
16:25:06 <ddarius> scodil: What's the definition of FEdge.
16:25:19 <scodil> newtype FEdge p = FEdge (p Int) deriving (Eq,Ord,Show)
16:25:22 * LoganCapaldo suspects FEdge
16:25:31 <LoganCapaldo> mmm
16:25:35 <scodil> class Duals p d | p -> d, d -> p where mkPrim :: a -> p a ...
16:25:57 * LoganCapaldo suspicion fails
16:26:00 <scodil> the type p is supposed to be a newtype
16:26:11 <Saizan> in both cases it should work
16:26:12 <scodil> like, everything is just ints, but I use newtypes to keep them separate
16:26:40 <Saizan> what do you use as p for example?
16:26:50 <ddarius> scodil: You'll have to paste more of the code (i.e. to hpaste)
16:27:21 <Philippa> it might help to pare it down to a minimal example
16:28:27 <LoganCapaldo> In org  :: (Duals p d) => FEdge p -> m (p Int) where is m comming from?
16:28:41 <scodil> I guess p doesn't have to be higher-order kind. It supposed to be like newtype Vertex a = Vertex a, where p = Vertex in that case, but concretely, I only plan to use Vertex Int, so I may as well make it newtype Vertex = Vertex Int
16:28:46 <scodil> m is a monad
16:29:04 <LoganCapaldo> and that's the correct type sig for org?
16:29:21 <scodil> looks right to mee
16:29:40 <LoganCapaldo> it's actually org :: (Monad m, Duals p d) => FEdge p -> m (p Int) ?
16:29:45 <LoganCapaldo> *it's not
16:30:10 <scodil> org is a class method and Monad m is a constraint of the class
16:30:34 <LoganCapaldo> ah ok
16:30:48 <Saizan> scodil: for which class?
16:30:58 <scodil> which class what?
16:31:11 <Saizan> which class org is a method of
16:31:58 <hpaste>  scodil pasted "full code" at http://hpaste.org/5089
16:33:03 <scodil> wtf it cut it off
16:33:16 <scodil> what's the limit?
16:33:25 <LoganCapaldo> @type shiftR
16:33:27 <lambdabot> forall a. (Bits a) => a -> Int -> a
16:33:51 <Saizan> 5k
16:33:53 <LoganCapaldo> mm
16:34:11 <ddarius> scodil: In setOrg you use p at kind *
16:34:34 <scodil> that's it
16:34:38 <scodil> you're awesome
16:34:39 <scodil> thanks
16:35:12 <Saizan> quite a distant error :)
16:35:57 <scodil> I wish there was a way to track the kind inference, like the type checker error messages
16:35:59 <Saizan> i'd expect an error on FEdge then
16:36:19 <LoganCapaldo> what left to right?
16:37:02 <scodil> ugh. well anyway, this has made me realize that I should make the newtypes be kind * instead of * -> *. Thanks for your help fellas.
16:37:05 <Saizan> scodil: type inference has the same problems, you could have enabled KindSignatures and added them as you do with typesigs
16:37:17 <scodil> oh really? cool
16:37:24 <scodil> that's what I was looking for I guess
16:37:36 <scodil> some way to annotate things to force the error out into the open
16:37:38 <Saizan> ?type return
16:37:39 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
16:37:44 <Saizan> ^^
16:37:49 <scodil> nice
16:37:55 <scodil> ok well I gotta go now. Thanks again.
16:41:37 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5090
16:46:16 <ramza3> noob question; is it accurate to say putStrLn returns type IO Monad?
16:46:39 <ddarius> No.
16:46:40 <LoganCapaldo> it reutrns a vlaue of type IO ()
16:46:59 <dons> ;t putStrLn
16:47:01 <LoganCapaldo> modulo typos
16:47:02 <dons> :t putStrLn
16:47:04 <lambdabot> String -> IO ()
16:47:13 <dons> so an "I/O unit"
16:47:22 <ramza3> just didn't know the verbiage
16:47:28 <ramza3> value of type IO ()
16:47:30 <dons> that is, "it returns unit in the IO monad"
16:48:15 <Saizan> you can say that is returns an IO action, which is what values of type IO a for some a are sometimes called
16:48:34 * ddarius loves Sublime.
16:48:49 <Saizan> Sublime?
16:50:03 <ramza3> Saizan: I was trying to describe what is happening here to someone; putStrLn $ "a"  ...where ($) :: (a -> b) -> a -> b ... and where b is represented by the return unit in the IO monad (hehe)
16:50:07 <ddarius> Saizan: The band.
16:50:09 <conal> ramza3: "monad" is not a sort of value.  it's a sort of type.
16:50:18 <RayNbow> dons, recently you posted a comment on reddit about a certain disqualified Haskell program for the language shootout that was faster than the listed C program... could you tell me which program it was?
16:50:22 <ddarius> s/type/type constructor/
16:51:22 <ramza3> conal: hmm, I was using LoganCapaldo's description
16:51:44 <bos> RayNbow: i think there have been several
16:51:49 <dons> RayNbow: it was the sum-file.hs, but it used a custom parser. note that there have been (and still are) several programs faster than in C. thread-ring for example, is currently faster, and with 6.8 we'll be ahead of gcc in binary-trees again.
16:52:09 <dons> 0.03s behind atm.
16:52:18 <dons> we beat C in binary-trees if we use a lazy tree
16:52:30 <RayNbow> ah thx
16:54:14 <dons> we're 0.01 behind on nsieve too
16:55:07 <LoganCapaldo> err, i don't see how, all I said was "value of type IO ()". Which isn't very descriptive :)
17:01:06 <ehird> is there a 'nought to yi in 5 minutes' page?
17:01:08 <ehird> it seems hell to set up
17:01:09 <ehird> :)
17:01:43 <kmcallister> i would also be interested in this
17:02:07 <ehird> (also, when do we get a cocoa/carbon UI? :))
17:02:12 <jsnx> doesn't yi have one, system wide configuration file?
17:02:15 <dons> is jyp active, amongst all this renewed interest in yi?
17:02:16 <jsnx> that's kind of annoying
17:02:28 <dons> jsnx: it should have one ~/.yi/ config file
17:02:34 <dons> unless things have changed since 2004
17:02:48 <ehird> dons: plenty of things have changed since 2004
17:02:58 <ehird> maybe not relating to yi's config file location, though.
17:07:38 <Gwern-away> ehird: there's one fellow actively working on some OS X interface
17:07:59 <Gwern-away> ehird: and it seems fairly simple to install to me - isn't it just the usual cabal triplet?
17:09:06 <ehird> Gwern-away: Nope afaik
17:09:36 <Gwern-away> ehird: for info, see http://haskell.org/haskellwiki/Yi  and esp http://snobugs.org/developer/yi/index.html
17:10:13 <Gwern-away> ehird: I always install it with 'runhaskell Setup configure --verbose=2 --user --prefix=$HOME/bin --datadir=$HOME/bin/share && runhaskell Setup build && runhaskell Setup install --user'. runs just fine
17:12:28 <dons> shootout updated to ghc 6.8!
17:12:51 <zeno> if i have say, f = x ++ x where x = whatever, will x be computed 2 times?
17:12:52 <Gwern-away> ooh ooh, how many places did we move up?
17:13:04 <kmcallister> zeno, no
17:13:22 <kmcallister> it's equivalent to a let binding
17:13:46 <kmcallister> (exception being if x has polymorphic type and is used at two different types, and you've disabled the monomorphism restriction so this is allowed)
17:14:04 <dons> binary-trees in first place!
17:14:09 <byorgey> w00t!
17:14:11 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=binarytrees
17:14:12 <lambdabot> Title: binary-trees benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/248by8
17:14:16 <dons> constructor tagging!
17:14:34 <zeno> thanks :) also i wonder how in that shootout a dynamicly typed language like lisp beats haskell
17:14:35 <dons> spectral-norm broke
17:14:47 <Gwern-away> http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=ghc&id=2 <-- Data.ByteString.Base?
17:14:49 <zeno> i thought in, say python one of the reasons it was so slow was dynamic typing
17:14:53 <lambdabot> Title: nsieve Haskell GHC #2 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comput ..., http://tinyurl.com/29z5ae
17:15:16 <Gwern-away> @hoogle unsafeIndex
17:15:16 <lambdabot> Data.ByteString.Unsafe.unsafeIndex :: ByteString -> Int -> Word8
17:15:31 <kmcallister> wow, the top 4 for binary trees are all functional languages
17:15:58 <dons> this is why we do data structure hacking in fp
17:16:04 <Gwern-away> (nsieve is easy to fix)
17:16:11 <dons> yeah, most should be easy.
17:16:16 <dons> some performance regressions to fix
17:16:21 <dons> thread-ring got slower
17:16:33 <Gwern-away> 'warning: Defaulting the following constraint(s) to type `Integer'...' <-- does this denote a performance hit?
17:17:26 <kmcallister> Gwern-away, no
17:17:47 <kmcallister> it's just telling you that it found a numeric value with polymorphic type, and defaulted it to Integer
17:18:10 <kmcallister> or do you mean as opposed to Int?
17:18:20 <Gwern-away> right, but isn't Integer slower than Int? the rest of the shootout stuff seems to avoid it religiously
17:18:50 <monochrom> If Int gives wrong answers, Int is a performance hit.
17:19:10 <kmcallister> you can override the defaulting with some obscure top level declaration right?
17:19:38 <Gwern-away> kmcallister: you would say :: Int, somewhere in this case, I think
17:19:39 <Saizan> or just put an annotation
17:19:50 <Gwern-away> it's internal to the main function, and not part of the type sig
17:20:42 <eu-prleu-peupe1> i have this great idea
17:21:10 <eu-prleu-peupe1> ill try to build a procedural content generation module in haskell
17:21:15 <eu-prleu-peupe1> its great, isn't it ? :)
17:21:44 <Gwern-away> monochrom: looking at the rules, it looks like the part defaulting to Integer will never receive a number anywhere near the upperlimit for Int
17:21:59 <sieni> eu-prleu-peupe1: indeed you can do whatever you want with haskell, it's free!
17:22:17 <monochrom> If you're more certain than "looks like", then that's good.
17:23:28 <ddarius> Just run the program and see if the output is correct.
17:24:09 <Gwern-away> monochrom: well, read http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=all#about - the Integer is from the use of ^, and ^ is being used to make 2^N, 2^n-1, @^n-2. each multiplied by 10000, where n is 2
17:24:10 <lambdabot> Title: nsieve benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language B ..., http://tinyurl.com/ncjpk
17:25:28 <Cale> I really hate the rules for that one.
17:25:40 <Gwern-away> Cale: confusing? I agree
17:26:19 <Cale> Specifically the "don't use bit flags" rule.
17:27:18 <Cale> Which seems to have been inserted simply to disqualify some of the faster programs.
17:27:34 <Cale> (Including the Haskell one)
17:28:39 <LoganCapaldo> i get this feeling liek the shootout is designed to test programs written by the dumbest programmers possible :)
17:29:26 <Cale> There should be a shootout without arbitrary restrctions on implementation. Give tasks, let the programs complete them however they want to.
17:30:06 <ehird> LoganCapaldo: i think there's some personal bias involved...
17:30:09 <Gwern-away> Cale: and if they simply print the answers to stdout? :)
17:30:24 <ehird> a version of http://golf.shinh.org/ for shootouts would be cool
17:30:24 <Cale> Gwern-away: they'll have to be able to do it for any input.
17:30:25 <lambdabot> Title: anarchy golf
17:30:32 <Saizan> i'm surprised to see printf in the shootout
17:30:41 <LoganCapaldo> ehird: on my part, or theirs? :)
17:30:43 <monochrom> "sort [1..10000] into reverse order. must use an n^2 algorithm. the 'point' of this test is to test the speed of loop constructs"
17:31:02 <ehird> LoganCapaldo: theirs
17:31:58 <Gwern-away> ehird: well, ghc *did* make them have to redo their entire setup
17:32:24 <ehird> Gwern-away: boo hoo my baby requires maintanence
17:32:58 <ehird> heh
17:33:04 <ehird> the shootout defines c++ as:
17:33:05 <ehird> 'C plus objects plus generics'
17:33:06 <Gwern-away> (and a lot of it!)
17:33:06 * Gwern-away really can't blame'em for holding a grudge. and it's not like running the shootout makes you any friends!
17:33:09 <ehird> a bit of an optimistic view...
17:33:33 <ehird> 'C plus OH HOLY SH' would be my definition
17:37:06 * BMeph is waiting for the shootout entry that "tests how well the language deals with function pointers that point to functions with different input types"...
17:37:14 <eu-prleu-peupeu> i will create macros in haskell so that it understands ansi c syntax and i can code ansi C in it
17:37:50 <LoganCapaldo> i'd much rather hve macros that lt me wrie haskell in ansi c
17:38:07 <monochrom> "output the answer 1. you must get to that answer by performing all the arithmetic operations as prescribed in the telescoping sum 1000 - 1000 + 999 - 999 ... + 2 - 2 + 1. The point of this test is speed of + and -"
17:38:13 <maslogr> ghc implemented in the C preprocessor?
17:38:27 <ehird> eu-prleu-peupeu: are you some kind of 'bad idea' robot?
17:38:33 <eu-prleu-peupeu> heheh
17:38:34 <eu-prleu-peupeu> :)
17:38:43 <ehird> also 'infeasable idea'
17:38:48 <soduko> once a master and student were walking by the river dock.. they met a swami who claimed he could walk on water
17:38:50 <LoganCapaldo> speed of + and -
17:38:51 <LoganCapaldo> wow
17:38:59 <ehird> LoganCapaldo: my + is ten times faster than yours
17:39:01 <ehird> it's parallel
17:39:02 <ehird> and quantum
17:39:05 <ehird> and tail recursive
17:39:10 <LoganCapaldo> my add instuction wins!!!!!
17:39:19 <soduko> it took him 16 years to master that..  then teh master replied, i can cross that river on a boat in 5 minutes.. why did you waste your time for 16 years:)
17:39:24 <soduko> just to cross the river
17:39:29 <monochrom> I forgot to add "no parallelism allowed". :)
17:39:47 <ehird> damnit
17:39:48 <ehird> ok
17:39:50 <ehird> my + is uh
17:39:53 <ehird> powered by goblins
17:39:54 <LoganCapaldo> what abou conncurrency? :)
17:39:55 <ehird> and faery dust
17:40:03 <ehird> AND USES HTTP AND REST!!
17:40:06 <ehird> AND CONTINUATIONS!!
17:40:07 <LoganCapaldo> actually
17:40:10 <maslogr> hm, i'm surprised then that it doesn't disallow unboxing and strictness annotations
17:40:17 <ehird> Therefore, I win. QED.
17:40:25 <LoganCapaldo> that benchmark looks lie it could be enitrely evaluated at compile time
17:40:32 <LoganCapaldo> without breaking the rules
17:41:05 <LoganCapaldo> unless one of the rules is "your compiler can't have a good optimizer"
17:41:26 <monochrom> "Output the answer 0. You must get that answer from the recursion f(n) = 0 + f(n-1), f(0) = 0. You must code up that recursion explicitly - no replacing it with tail recursion, loops, ... The point of this test is stack speed."
17:41:30 <LoganCapaldo> or alternatively they include compile time in the measurements
17:41:58 <ehird> monochrom: 'You must not use the ASM stack'
17:42:06 <Gwern-away> LoganCapaldo: code up a template haskell solver and see how quickly they change the answer :)
17:42:52 <BMeph> "This test will assign points according to how long it takes to transfer the assembly file of your program to the judges' email box. Your assembly language file must be encoded in UTF-32."
17:43:12 <LoganCapaldo> LOL
17:43:59 <ehird> "Output the answer 0. You must do this by setting a variable to 1,000,000 and using mutable state to decrement from there. You must not use monads or any other way of removing state. The purpose of this is to test mutability speed."
17:44:20 <BMeph> "Your assembly language file must not have any MMX instructions, or it will be disqualified." :p
17:45:26 <ehird> "your compiled source may not include jmp"
17:45:34 <ehird> "because GOTO is bad. Don't you know Djikstra?"
17:45:42 <ehird> *dijkstra
17:45:56 <eu-prleu-peupeu> crackpot of the day: http://www.marketwatch.com/news/story/john-dvoraks-second-opinion-sun-mysql/story.aspx?guid=%7B88606B4A-A4AF-46FC-9C80-6B186A622456%7D&dist=hplatest
17:45:57 <lambdabot> Title: The Sun-MySQL deal stinks - MarketWatch, http://tinyurl.com/2o3x8e
17:46:10 <eu-prleu-peupeu> hmm somebody already added it :)
17:46:22 <ehird> crackpot of the day: eu-prleu-peupeu's ansi C idea
17:46:45 <ehird> wow. dvorak crashed my browser
17:46:48 <ehird> that's really fitting
17:46:55 <Cale> "Output pi to as many places as you can before the benchmark judge terminates your program with Ctrl-C. Your program must not trap signals. The purpose of this is to test the benchmark judges' patience, and how much they like you."
17:47:07 <LoganCapaldo> lol
17:48:04 <Gwern-away> http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=ghc&id=4 <-- what the heck? sumfile used to be much more convoluted and much faster. where did the old one go?
17:48:05 <lambdabot> Title: sum-file Haskell GHC #4 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comp ..., http://tinyurl.com/2ebcxc
17:48:11 <eu-prleu-peupeu> ehird: heheheh :)
17:48:17 <eu-prleu-peupeu> hehehe
17:49:04 <eu-prleu-peupeu> you guys actually work out on the shootout contest haskell code ?
17:49:06 <Cale> We should include RULES pragmas in the base library which transform trivial-looking implementations of the shootout programs into highly sophisticated optimised solutions.
17:49:09 <ehird> Gwern-away: it wasn't elegant enough (and was too fast)
17:49:21 <LoganCapaldo> Cale: you win the internets
17:49:25 <Cale> That would be awesome :)
17:49:29 <ehird> Cale: {-# RULES: HASKELL #-}
17:49:45 <monochrom> "Input 1000 numbers and output a binary search tree holding them. Do not use any sorting algorithm. Do not use the system heap. Simulate your own heap with an array and do your own garbage collection. The point of this test is code obfuscation."
17:49:46 <ehird> {-# IN_YR: BENCHMARK BEATIN_UR: OTHER_LANGS #-}
17:50:04 <ehird> monochrom: "Also, write in C."
17:50:36 <LoganCapaldo> implement a 32 bit adder using bitwise operators. do not pass go, do not collect 200 dolars.
17:50:56 <sclv> Gwern-away: I think that lots of the retrogressions are where the old  fast ones now error because they're importing the wrong stuff from ByteString, so the shootout falls back on the naive versions that the changes to the ByteString API didn't break.
17:51:11 <ehird> LoganCapaldo: do not use a monopoly data board structure
17:51:40 <sclv> {-# RULES: HASKELL RULES DUDES #-}
17:53:16 <__lf> @pl f x = x >> return ()
17:53:17 <lambdabot> f = (>> return)
17:53:19 <ehird> {-# RULES: NOT_A_SNEAKY_OPTIMIZATION #-}
17:53:38 <ehird> it should transform into a hand-coded Core implementation
17:53:40 <Gwern-away> sclv: no kidding
17:53:45 <ehird> with every ghc quirk taken care of
17:53:51 <ehird> and loads of microoptimizations
17:54:14 <sarehu> whoa, pl is wrong!
17:54:38 <sclv> pl interprets unit as a set of empty parens.
17:54:43 <__lf> sarehu: thanks, i was trying to convince myself that it wasn't :)
17:54:49 <__lf> aha
17:54:59 <ehird> http://shootout.alioth.debian.org/gp4/benchmark.php?test=hello&lang=ghc&id=0 is it just me or is there some kind of bug here...
17:55:00 <lambdabot> Title: startup Haskell GHC program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer ..., http://tinyurl.com/2xhq9t
17:55:02 <__lf> is there some other syntax for ()?
17:55:10 <ehird> > (,)
17:55:12 <lambdabot>  Add a type signature
17:55:16 <sarehu> sclv: oh, I thought it was distracted by all these optimizations
17:55:21 <ehird> __lf: you could just replace it with NIL
17:55:26 <ehird> then put it backto () in the output
17:56:05 <sclv> pl also can't tell the difference between composition and qualified imports, among other issues...
17:56:32 <ddarius> sclv: There are no qualified imports.
17:56:53 <ehird> surely there needs to be some kind of haskell parser library
17:56:57 <ehird> that is a library which parses haskell
17:57:06 <ehird> and then lambdabot etc would have no problem
17:57:06 <ddarius> ehird: There are several.
17:57:09 <sclv> erm, whatever the terminology is of saying M.insert, etc. named imports i suppose.
17:57:11 <ehird> maybe just use the ghc parser
17:57:13 <ehird> :|
17:57:15 <Gwern-away> ok, I think I updated all the erroring shootout entries' haskell pages to compile
17:57:22 <ddarius> sclv: Those aren't Haskell 98.
17:57:22 <Gwern-away> now someone just needs to upload them
17:57:31 <__lf> ehird: i was hoping there was a builtin for 'discard the output for this'; naming it would defeat the purpose
17:57:44 <sclv> pl is only written to handle Haskell98?
17:58:22 <maslogr> so i'm trying to write a monad for processing infinite streams, but i'm having trouble making it lazy enough. what i have so far just runs forever before emitting anything: http://hpaste.org/5091
17:58:27 <sclv> we need a pl' !
17:58:31 <ddarius>  @pl has it's own little hacked up parser.
17:58:39 <sarehu> @pl map f x y z
17:58:40 <lambdabot> f (x y) z
17:59:25 <ddarius> I believe it treats map as fmap
17:59:29 <monochrom> One day I should collect the above parady benchmark entries and put up a real website. It should be implemented in hApps. It will be called "The Great Prog. Lang. Shootme". :)
17:59:31 <ehird> ddarius: exactly
17:59:36 <ehird> ddarius: we need a Real One
17:59:36 <ehird> :P
17:59:39 <monochrom> s/parady/parody/
17:59:49 <ddarius> ehird: As I said, there are several, @pl just doesn't use them.
18:00:06 <sarehu> :t insert
18:00:15 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
18:00:17 <ehird> "Please print out all natural numbers like this: [1,2,3,4,5... You may not use laziness features or looping."
18:00:30 <sarehu> @pl insert a b c d e
18:00:31 <lambdabot> insert a b c d e
18:00:39 <Cale> maslogr: er, any particular reason for using DList here?
18:00:53 <maslogr> for the O(1) append, of course
18:01:15 <ehird> @pl << . >>=
18:01:15 <lambdabot> (line 1, column 1):
18:01:15 <lambdabot> unexpected "<"
18:01:15 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
18:01:20 <ehird> @pl fails.
18:01:20 <lambdabot> (line 1, column 7):
18:01:20 <lambdabot> unexpected end of input
18:01:20 <lambdabot> expecting white space or simple term
18:01:20 <Cale> maslogr: But assuming that the things you tell are never very long, that doesn't matter, does it?
18:01:37 <Cale> maslogr: xs ++ ys is fast if xs is short :)
18:01:57 <Gwern-away> no wonder reverse-complement is so slow. it's not even using bytestrings
18:01:58 <sarehu> or if it's undefined
18:02:00 <maslogr> aha. duh :), thank you
18:02:07 <ddarius> xs . ys $ [] is not faster than xs ++ ys
18:03:00 <maslogr> i keep trying to drop the premature optimization habit. if there was a patch or gum...
18:03:57 <ddarius> maslogr: Keep using Haskell.  It punishes premature "optimization"
18:04:35 <MyCatVerbs> ddarius: ummm, I have a better idea.
18:04:52 <MyCatVerbs> maslogr: start using TCL. a.k.a. "cold turkey" ;)
18:05:01 <ehird> eek
18:05:02 <ehird> tcl
18:06:25 <eu-prleu-peupeu> i think raytracing might be the only way haskell has to came out of the dark cave it currently is in
18:07:29 <ehird> eu-prleu-peupeu: no no clearly optimizable, parallelable, quantum + is the way
18:07:41 <ehird> (what dark cave? it's lovely and bright from the inside)
18:08:17 <eu-prleu-peupeu> heheh
18:14:03 <ptolomy> Hmm..  I feel like I often seen (monad?) types that are of the form: "data Foo = Foo { unFoo :: Something }".. what is that all about?
18:14:32 <kpreid> ptolomy: it's a record type
18:14:41 <kpreid> it is similar to:
18:14:46 <ptolomy> well, I means specifically, "un___".
18:14:53 <sjanssen> ptolomy: it's just a convenient way to write the "unpack" function
18:15:14 <sclv> ptolomy: foax use it for wrapper types, generally, or sometimes if Something is a function, it might be runFoo instead.
18:15:17 <kpreid> ptolomy: well, the idea is that unFoo becomes the function to extract the contents, to remove the Fooness
18:15:20 <sjanssen> ptolomy: "un" as in "unwrap", "unpack"
18:15:50 <ptolomy> Ah. Okay. Thanks. :)
18:25:24 <esnip> (a1 ~ Data.Transform.Type.Type a) => Rep a b -> Data.Transform.Type.Type b -> View (Data.Transform.Type.Type a)
18:25:33 <esnip> what does the ~ stands for
18:25:59 <ddarius> A type equality constraint
18:26:02 <esnip> I don't have a clue can anyone help m please
18:26:36 <esnip> so in this case a1 is considered to be equal do data...Type a?
18:26:45 <kmcallister> ddarius, those are in Haskell?
18:26:53 <kmcallister> (i assume some GHC extension)
18:27:39 <esnip> the types are from the project library
18:29:20 <ddarius> kmcallister: They are necessary to support associated types.
18:29:40 <kmcallister> in this case a1 is not mentioned anywhere else
18:30:01 <kmcallister> is it an AT in some typeclass?
18:31:04 <esnip> ddarius: a1~b means that type b should be equal to a1?
18:31:23 <ddarius> That they should be equal to each other, yes.
18:31:45 <esnip> thanks
18:31:48 <glen_quagmire> c/exit
18:32:01 <hpaste>  davidL pasted "why won't this simple X11 program build?" at http://hpaste.org/5092
18:41:48 <levi> Would anyone mind taking a moment to help me figure out how to use the State monad (or perhaps something else) to keep track of some state in a program I'm writing?
18:42:49 <levi> (I am very new to haskell, obviously)
18:42:55 <maslogr> I might be able to
18:44:00 <Botje> levi: sure, i'm awake for a few more minutes
18:46:28 <levi> Okay, so I'm writing a lexical analyzer, and I want to keep track of the position in the String I'm lexing.
18:48:00 <levi> I have tok :: String -> (Token, String) that pattern matches on the first character or two (which sometimes causes a recursive call to munch whitespace or a helper function to match a longer lexeme)
18:49:05 <levi> The monad tutorials I've read *seem* to make sense while I'm reading them, but I've been unable to make the leap to applying them to my own code. :/
18:50:34 <Botje> levi: so you want to store the String part in the State monad, correct?
18:50:36 <levi> (I would love to just use Parsec, but this is for a compilers class and the point is to implement a lexical analyzer and a parser without too many magic libraries)
18:50:56 <ddarius> levi: Just think about what features the ideal language to implement your lexical analyzer would have?
18:51:06 <levi> Botje: Well, that would be a start.
18:51:25 <levi> I like what I have now, except it doesn't keep track of the line or column number.
18:51:42 <Botje> yeah
18:52:03 <Botje> if you want to do trickier stuff you'd have to store something like (lineno, column, restofstring)
18:53:14 <levi> That sounds reasonable.
18:54:04 <Botje> so now you have the State (Int, Int, String) monad, right?
18:54:55 <levi> I also considered making the input stream keep track of the position, so instead of taking a String, it would take [(Char, Int, Int)] and there would be another function to turn a String into that.
18:55:18 <Botje> that sounds pretty excessive
18:55:53 <levi> Well, it would keep me from having to litter the matcher with lots of 'increment x' and 'increment y' tasks.
18:55:53 <Botje> esp. since your lexer will only be moving forward
18:56:04 <Botje> that's true too.
18:56:31 <Botje> but you'd have to extract characters from that triple all the time :)
18:57:42 <ddarius> levi: You could easily have the function that gets the next character, increment a position.
18:58:56 <levi> ddarius: Well, right now there isn't a 'get next char' function, the tok function pattern-matches on the head of the string.
18:59:21 <Botje> > runState get (1,1, "foobar")
18:59:24 <lambdabot>  ((1,1,"foobar"),(1,1,"foobar"))
19:00:40 <maslogr> I would do something like... type Lex a = State (Int, Int, [Char]) a ... tok :: Lex Token ... char :: Lex Char
19:01:21 <levi> Hmm, wife is calling... be back in a while.  Thanks.
19:01:26 <sclv> assuming you don't have tokens that break over lines (a reasonable assumption) you probably want to call lines first, then you only need to keep track of col. #
19:01:35 <Botje> > let advance = do { (line,col,(char:rest)) <- get; put (line, col+1, rest); return char } in runState (advance) (1,1,"foobar")
19:01:38 <lambdabot>  ('f',(1,2,"oobar"))
19:01:43 <Botje> > let advance = do { (line,col,(char:rest)) <- get; put (line, col+1, rest); return char } in runState (advance>>advance) (1,1,"foobar")
19:01:44 <lambdabot>  ('o',(1,3,"obar"))
19:01:52 <Botje> heh, worked on the first try :)
19:03:35 <Botje> levi: I think you can try to extend the above, it's pretty straightforward: just patternmatch on char to see if it's a \n or not.
19:08:57 <Botje> :t let advance = do { (line,col,(char:rest)) <- get; put (line, col+1, rest); return char } in advance
19:08:59 <lambdabot> forall (t :: * -> *) t1 t2 t3. (Num t2, MonadState (t1, t2, [t3]) t) => t t3
19:09:19 <Botje> eep. that's scary
19:13:35 <Saizan> why?
19:13:55 <Botje> too general, mostly
19:14:16 <Botje> and I forgot the magic required to ask for a type inside another expression
19:17:12 <sclv> :t  let advance = do { (line,col,(char:rest :: [Char])) <- get; put (line::Int, col+(1::Int), rest); return char } in advance
19:17:14 <lambdabot> forall (t :: * -> *). (MonadState (Int, Int, [Char]) t) => t Char
19:17:24 <Botje> ah
19:17:30 <Botje> yeah. that helps :)
19:31:27 <maslogr> can someone explain to me how unsafeInterleaveIO is implemented? i'm having trouble making something i'm writing lazier, but when i specialize it to the IO monad and insert unsafeInterleaveIO at a certain point, it works beautifully...
19:31:52 <monochrom> "launchMissile is only idempotent it the missile is atomic" hahahaha
19:32:39 <Saizan> ?src unsafeInterleaveIO
19:32:40 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
19:33:04 <ddarius> maslogr: Roughly, unsafeInterleaveIO m = let x = unsafePerformIO m in return x
19:33:31 <monochrom> @src IO (>>=)
19:33:31 <lambdabot> m >>= k     = bindIO m k
19:33:37 <monochrom> @src bindIO
19:33:38 <lambdabot> bindIO (IO m) k = IO ( \ s ->
19:33:38 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
19:33:47 <maslogr> hm, then all I need is an unsafePerformStateT
19:34:01 <maslogr> wait, that doesn't sound right.
19:35:22 <Saizan> in state the data dependency is not a fake of the implementation, but state is also quite lazy (no unboxed tuples)
19:35:29 <monochrom> Oh! Right, "let r = ... m s ..." vs "case m s" upfront.
19:39:06 <Saizan> monochrom: ah i thought it was the _ instad of new_s, mostly
19:40:08 <monochrom> Yeah, it took me a couple of minutes to deconfuse too.
19:49:24 <maslogr> well, that solved it, but not in a very satisfactory way. Now my sort-of-generic function takes an extra parameter "interleave :: m a -> m a" depending on what monad you're running it in
19:49:37 <maslogr> in the Identity monad it's id, for IO I pass unsafeInterleaveIO
19:49:51 <Saizan> you could use a typeclass
19:50:34 <maslogr> ah, and define instances for all the well-known monads. thank you
19:53:20 <kayess> A stupid question if I may. If I'm using GHCi and have something like this "let fact 1 = 1; fact n = n * fact ( n - 1 )" - is there any way to split that up over multiple lines or does it always have to be done in a single line like that?
19:53:35 <hpaste>  maslogr pasted "success :)" at http://hpaste.org/5093
19:53:45 <bparkis> fact 0 = 1 is more correct
19:54:20 <kayess> My real function is a lot longer than that. I just want to know if I can do it on multiple lines
19:54:59 <ddarius> kayess: No, you can't
19:55:10 <kayess> That's what I thought. Thanks
19:55:38 <davidL> why isn't there a binding for XDrawText in the X11 package?
20:00:31 <Cale> kayess: I recommend keeping an editor window open alongside ghci where you put all your definitions. Reloading your file is as easy as :r
20:01:32 <kayess> It's for a talk for next week's BarCamp Bangkok. I was hoping to be able to do it all using GHCi, but I may switch to Visual Haskell instead
20:03:57 <Cale> It would be rather nice to have something like Dr. Scheme for Haskell.
20:18:02 <xpika> I need the syb to convert any data structure with end elements int to a list
20:19:17 <levi> Botje: I can't get your advance function to work in my ghci.
20:19:18 <pjd> is there a way to externally send a :r command to a ghci instance?
20:19:48 <pjd> or otherwise signal a reload
20:20:46 <ramza3> haskell vm
20:20:54 <blegh> Cale, sounds like it was a lot of fun :)
20:21:01 <Cale> Yeah, it's a fun language :)
20:21:21 <blegh> yeah, imperative programming just got very dull for me
20:21:24 <Cale> Certainly my favourite of the 15 or 20 that I know :)
20:21:49 <Cale> It's right on the cusp between research languages and practical languages
20:22:07 <blegh> :)
20:22:13 <Cale> So it has all kinds of cool features, but you can also use them to do real stuff. :)
20:22:23 <blegh> 'real stuff'?
20:22:33 <blegh> you mean, where you would in an imperative language?
20:22:46 <blegh> what you would do in an imperative language*
20:22:52 <Cale> Well, a lot of research languages have library issues because they're only used by 10 or 20 people.
20:22:59 <Cale> (if that)
20:23:17 <blegh> hehe
20:23:22 <Cale> Haskell's community has exploded in size in recent years.
20:23:31 <blegh> nice :)
20:23:33 <dnox> i so dislike indentation in haskell code, it gets so messy when a project grows big
20:23:54 <Cale> dnox: Er, how is it a function of the project size?
20:24:22 <Cale> dnox: As long as your editor is configured sensibly, it shouldn't be a problem.
20:24:23 <dnox> file size rather
20:25:05 <araujo> dnox, Haskell indentation actually becomes valuable when the project gets big
20:25:07 <Cale> One thing to make sure of is that no ASCII tab characters go into your source file (any good editor can take care of that for you)
20:25:43 <Cale> Basically the only other thing to remember is that things which are inside other things get indented farther.
20:26:10 <Cale> (and things at the same level should be lined up vertically)
20:26:14 <dnox> indentation sure is good, but.. to separe blocks not statements
20:26:27 <Cale> hm?
20:26:40 <sjanssen> dnox: do you have a sample you could hpaste?  Perhaps we can give some pointers
20:27:11 <Cale> dnox: Of course, it's also optional. If you want to put two statements in, say, a do-block, on the same line, you can just stick a semicolon between them.
20:27:33 * ddarius tends to use a mix of layout and explicit delimiters, usually layout.
20:27:40 <dnox> mm, yep i like the semicolon thing
20:27:52 <Cale> and if you include semicolons and braces, the layout is ignored, but people will hate you if you do it consistently. :)
20:28:14 <dnox> why?
20:28:33 <Cale> Because it's so much easier to read properly indented code without all the visual noise.
20:28:39 <sjanssen> dnox: because it's ugly and harder to edit
20:29:21 * cjb is currently attending a Haskell class given by someone who uses semicolons and braces *and* refuses to indent blocks after opening braces.  :(
20:29:56 <dnox> Cale: well you can mix it as in c/c++?
20:30:08 <dnox> of course some indentation is good
20:30:21 <Cale> dnox: In C and C++, you have no option.
20:30:26 <dnox> but i dont wanna get compile errors because of required indentation
20:30:30 <cjb> dnox: If you're using semicolons and braces, Haskell is being a C parser and ignoring indentation.
20:30:33 <Cale> The braces and semicolons aren't optional.
20:30:53 <cjb> dnox: Use an editor that doesn't let you write syntactically-invalid indentation, then.
20:31:45 <lament> it's really scary how many people dislike significant indentation
20:31:56 * lament -> former python zealot so lots of experience with this behavior
20:32:06 * cjb -> current python zealot :)
20:32:40 <blegh> hehe
20:32:41 <pjd> yay Python and meaningful indentation
20:32:56 <dnox> indentation can be a pain if you can like 10+ nested indentations, and it goes over the screen width
20:33:14 <cjb> dnox: I have honestly never seen Haskell code that was anything like that.
20:33:24 <ddarius> dnox: That's poor structure whether or not indentation meaningful.
20:33:25 <pjd> dnox: which goes equally for braces, of course
20:33:28 <cjb> I suggest you've spent too much time around C geeks writing nested for loops.
20:33:38 <cjb> s/for/goto/ :)
20:33:51 <lament> you don't need exra indentation for gotos :)
20:33:54 <lament> extra
20:34:21 <lament> but really... 10 indentation levels? That means your function is at least ten lines long!
20:34:48 <lament> ;)
20:34:59 <ddarius> That makes it at least nine lines too long!
20:35:05 <Nafai> Hey mattrepl
20:35:22 <mattrepl> hey Nafai
20:37:16 * ddarius considers making a declipper.
20:37:24 <gwern> ergh, given a value with the type Counts, defined as 'data Counts = Counts { cases, tried, errors, failures :: Int }
20:37:26 <Nafai> declipper?
20:37:32 <gwern> how do I pull out failures as an int?
20:37:57 <ddarius> Nafai: It's a term I just made up.  Take clipped sound data and try to get unclipped sound data.
20:38:06 <lament> ddarius: mmmm
20:38:17 <lament> sounds interesting
20:38:29 <gwern> is it 'failures value'?
20:38:52 <sjanssen> gwern: yes
20:39:02 <lament> ddarius: cool idea!
20:41:04 <ddarius> Admittedly, a cheap way to do that is just to throw a low-pass filter at it.
20:44:08 <pjd> ddarius: there's a cool program for that somewhere based on texture resynthesis
20:44:43 <ddarius> pjd: Yeah, assuming a given timbre and estimating values for it would be the most obvious approach.
20:45:03 <xpika> is t
20:45:41 <xpika> how extract all the numbers from an arbitary string ie [Char] -> [Int]
20:46:05 <ddarius> xpika: That question is ill-defined.
20:46:23 <ddarius> ill-stated rather
20:46:35 <xpika> "something1234)(*&)(*adsad23" -> [1234,23]
20:47:27 <gwern> and do you interpret it? is "10^2" 100, or 10 and 2?
20:47:40 <ddarius> > map read . words . map (\c -> if isDigit c then c else ' ') $ "something1234)(*&)(*adsad23" :: [Int]
20:47:44 <gwern> what about hex numbers?
20:48:20 <ddarius> @bot
20:48:27 <ddarius> wunderbar
20:48:37 <xpika> ddarius: that works
20:49:19 <gwern> xpika: so 11 is 1, and 1?
20:49:35 <xpika> no 11 is 11
20:49:39 <gwern> might as well define your own type, Digits, so the type would be [Char] -> [Digits]
20:51:22 <kayess> When writing a lambda, how do you refer to the lambda function itself? let fact = ( \x -> if x == 0 then 1 else x * fact (x - 1) )
20:52:02 <allbery_b> you don't, except via something like fix
20:52:07 <ddarius> kayess: You name it as you did, or equivalently you use fix, or I misunderstood your question.
20:53:07 <kayess> fix was kind of what I was expecting to use, but how do you use fix? Doing "fix fact" is apparently a very bad idea in GHCi....
20:53:41 <sjanssen> kayess: fix (\fact x -> if x == 0 then 1 else x * fact (x - 1))
20:54:09 <ddarius> compare to let fact = \x -> if x == 0 then 1 else x * fact (x - 1) in fact
20:54:27 <pjd> kayess: more generally fix $ \f -> (...stuff calling f...)
20:54:41 <kayess> Thanks. I think the type signature for fix was confusing me as the first argument was (a->a) - the a here is a function itself?
20:54:54 <ddarius> kayess: A function type, yes.
20:55:05 <kayess> That makes more sense -thanks
20:55:45 <pjd> kayess: fix f = f (fix f) = f (f (fix f)) = f (f (f (...)))
20:55:45 <ddarius> kayess: However, in fix (1:), a = [Int].  Of course, this is only possible via laziness so in strict languages usually fix :: ((a -> b) -> (a -> b)) -> a -> b
20:56:30 <pjd> kayess: in other words, fix applies the function to itself, repeatedly
20:56:53 <kayess> I don't suppose there's a way of breaking out of something in GHCi or do I need to kill the process now it's descended into an infinite loop?
20:57:42 <gwern> C-c?
20:57:54 <ddarius> let fix = foldr (.) id . repeat
20:58:21 <kayess> Ctrl-C doesn't do it. Oh well. no loss :)
21:09:02 <pjd> > let fix = ($undefined) . foldr (.) undefined . repeat in fix (1:)
21:11:29 <Cale> kayess: If you're on windows, some people have problems like that, I'm not sure why.
21:13:18 <Cale> kayess: I seem to remember fixing the situation on my friend's machine by installing emacs and using that as a terminal emulator. It's not perfect, but at least you can stop computations :)
21:14:06 <kayess> As I say, no biggie. I could still copy the text out of the session even though it was dead so no loss
21:15:25 <kayess> So, thanks everyone. I blogged about it here: http://www.kirit.com/Blog:/2008-01-19/BarCamp,%20Yoda%20and%20unfolding
21:17:23 <lkok> hi!
21:17:24 <bos> how cute. people are posting their own "happy birthday"s as comments on my "happy birthday" blog posting. the intertubes is full of the warm fuzzies!
21:18:09 * gwern checks regexpr off the hackage list
21:18:42 <gwern> Cale: in such a situation, I always try to background/kill the process with a C-z or something else
21:19:38 <bos> awesome paper title: "Theorems for low, low prices!"
21:21:06 <lkok> 4-8-12-16-23-42
21:21:09 <lkok> 108
21:21:43 <Cale> @oeis 4 8 12 16 23 42
21:21:58 <ddarius> No lambdabot
21:22:02 <Cale> oy
21:22:05 <bos> Cale: it's a reference to "Lost"
21:22:11 <Cale> bos: I know :)
21:22:14 <lkok> hey hey, wait im not a bot
21:22:26 <gwern> @hoogle openFD
21:22:35 <Valodim_> OHNOES
21:22:36 <Cale> gwern: No lambdabot
21:22:43 <gwern> gah
21:22:57 <lkok> i cant ind a channel to talk about lost
21:23:02 <lkok> find
21:23:20 <gwern> srsly?
21:23:22 <Valodim_> try #lost
21:23:25 <pjd> kayess: hmm, wouldn't x!!0, x!!1 be a bit clearer?
21:23:34 <gwern> Valodim_: nope
21:23:37 <lkok> #lost
21:23:41 <Valodim_> bad luck :P
21:23:54 <kayess> pjd: Maybe, not come across !! yet though
21:24:08 <pjd> kayess: list indexing
21:24:17 <Cale> lkok: So, are you learning to program in Haskell?
21:24:29 <kayess> Instead of head & tail? Almost certainly - thanks for the tip
21:24:52 <kayess> That's my old Miranda habits coming out :)
21:25:41 <lkok> help... i'm actually using the chat included in opera and i can't find a channel about lost
21:26:03 <pjd> lkok: this is probably not the right network
21:26:13 <lkok> sorry i don't know about it... i'm newboy
21:26:15 <Cale> lkok: This channel is for discussion of the programming language Haskell
21:26:32 <lkok> oouchh, thanks, but help me
21:26:57 <Cale> lkok: You might try looking for such a channel on efnet. This IRC server has mostly open source projects and programming languages.
21:27:42 <gwern> freenode is both free as in beer and speech :)
21:29:38 <lkok> thanks i find it
21:29:43 <lkok> you are my idol
21:30:50 <lkok> i want you to fuck me now!
21:31:14 <lkok> i actually have my pussy really wet
21:31:26 --- mode: ChanServ set +o Cale
21:31:35 * gwern wonders if lkok is cruising for a booting
21:31:35 --- kick: lkok was kicked by Cale (Cale)
21:31:47 --- mode: Cale set -b *!*@c-76-119-52-236.hsd1.ma.comcast.net
21:31:54 --- mode: Cale set +b lkok!*@*
21:32:00 <Cale> er
21:32:04 <hexpuem> lol
21:32:09 <Cale> meh
21:32:13 --- mode: Cale set -b lkok!*@*
21:32:35 --- mode: Cale set +b *!*@200.84.37.85
21:32:40 <Cale> there we go :)
21:32:52 --- mode: Cale set -o Cale
21:33:11 <Cale> First the banlist was full, then I accidentally choose the wrong bany type :)
21:33:16 <Cale> ban*
21:33:38 <davidL> Cale: was there ever a time when mbot supported plotting?
21:34:57 <Cale> davidL: Not really very good plotting, but someone made up a graphing web tool, and I wrote a small plugin to post things to it.
21:35:16 <Cale> Certainly not mathematica plotting, that's always been disabled.
21:35:48 <davidL> ah ok, I thought it may have used mathematica somehow
21:37:31 <Cale> Other bots in #math have been available from time to time to do plotting. In particular, I think there's a Maxima bot, but I'm not sure what it's called or what commands it responds to :)
21:37:51 <cjb> gosh :)
21:40:43 <dons> wow. trolls!
21:40:50 <dons> i haven't seen them in ages round here
21:41:40 <bos> for such a big channel, we're an infrequent target.  whew.
21:43:11 <aFlag> seems like that real world haskell book will finally have some of its chapters published on the web soon
21:43:46 <bos> aFlag: i'm working my arse off on revising the last chapter that we intend to post in our first batch
21:44:03 <aFlag> cool
21:44:20 <backrub> im currently reading "yet another...". do you guys suggest a book thats better?
21:44:34 <backrub> <-- obviously new to the haskell stuff
21:44:48 <aFlag> they actually wrote it down really fast, for what I understood it has almost all the chapters written, at least in draft form
21:45:44 <aFlag> backrub, you may stick around for http://www.realworldhaskell.org/ they will publish some chapters soon
21:46:07 <bos> aFlag: by my count, it's about half done.
21:46:21 <aFlag> if you have access to a library you may try "haskell: the craft of functional programming", it was the book I read, it's alright
21:46:32 <aFlag> it's introductory, though
21:47:38 <aFlag> well, you can buy it as well :P
21:48:24 <backrub> hmm.. well, i will see how my current book goes
21:48:43 <backrub> and if i enjoy this crazy haskell stuff (pretty sweet so far), then i will check it all out
21:48:55 <aFlag> yet another haskell tutorial is good also. But, at least when I started reading it, it was unfinished
21:49:09 <hexpuem> yea its still unfinished i think
21:49:12 <backrub> oh
21:49:16 <aFlag> and it spent a lot of time in continuation passing, I'm not sure it's that important, specially for a newcomer
21:49:17 <hexpuem> at least the copy i started reading 3 days ago
21:49:26 <bos> correct. it's still a decent start.
21:49:38 <backrub> well, i am not opposed to a lot of reading
21:49:44 <backrub> cs major, so i love it all
21:50:14 <aFlag> the book I told you about is not that big
21:50:47 <aFlag> I think it's specially good if you never programmed before, if you did you may find a few parts kinda boring
21:50:59 <backrub> i got the blog in my feeds. ^_^
21:51:17 <davidL> I've also seen Hutton's book recommended
21:52:07 <backrub> the new one, Programming in Haskell?
21:52:14 <davidL> yeah
21:52:21 <backrub> er... newer
21:52:31 <backrub> yeah, i was looking at it. sounded interesting
21:54:50 <aFlag> hm, I never seen that one. The thing feel I need to work on is my monads and monoid knowledge, but I'm yet to find some text that really pleases me in that area.
21:55:07 <backrub> monoid!? lol, whats that?
21:55:26 <backrub> i _sorta_ understand the monad idea. never heard monoid referenced
21:55:33 <aFlag> it's like a monad but with one less restriction, I don't know what exactly
21:55:35 <Tac-Tics2> A monoid is a group (from mathematics) not necessarily with inverses
21:55:57 <aFlag> hm, monads look a bit like a group, don't they?
21:56:00 <Tac-Tics2> A monoid just needs a "zero" and a "plus" where 0 + x = x and x + 0 = x
21:56:23 <Tac-Tics2> So integers are monoids. And so are lists ([] is 0 and ++ is +)
21:56:43 <Tac-Tics2> Monads are a bit difficult. Monoids are very straight foreward
21:56:53 <aFlag> Tac-Tics2, hm they need an operation as well, don't they?
21:56:56 <Tac-Tics2> Monads, I feel, are best learnt by just using haskell
21:57:40 <Tac-Tics2> aFlag: monoids need a 0 element and a + operator. Monads just need a return operator and a bind operator
21:57:57 <aFlag> I see
21:58:23 <backrub> its so simple!
21:58:23 <Tac-Tics2> > [1,2,3] >>= (\x -> return (x + 1))
21:58:41 <aFlag> and the + has to be associative?
21:58:44 <Tac-Tics2> (lambdabot?)
21:58:45 <Tac-Tics2> bah
21:58:59 <backrub> *eyes glaze over*
21:59:03 <Tac-Tics2> oh yes, I forgot that, but it's important. + needs to be associative
21:59:38 <aFlag> so it's called monoid instead of group just because it doesn't need a inverse?
21:59:49 <Tac-Tics2> correct
21:59:57 <Tac-Tics2> so all groups ARE monoids
22:00:22 <aFlag> I see, where do monoids theory come from?
22:00:27 <bos> never thought abstract algebra would be useful in hacking, eh?
22:01:00 <aFlag> hehe
22:01:25 <aFlag> I'm terrible on abstract algebra, though
22:01:28 <ddarius> As I have said, the free (pointed) magma is the uber data structure of CS, followed closely by the free monoid.
22:01:31 <Tac-Tics2> Do you guys know "do" notation works?
22:01:38 <aFlag> yeah
22:02:12 <aFlag> I know what a monad is and all, I just don't really know when to make my own and when it's best to use them or not
22:02:44 <bos> monoids are a class of semigroup. semigroups have been around for a while. i've no idea when monoids showed up in the theory.
22:03:19 <Tac-Tics2> Making your own original ones is hard. There's only a couple which are really fundamental, but you can create interesting ones when you start creating variations on existing monads
22:03:35 <ddarius> bos: Considering one of the most significant examples of a monoid is the monoid of endo functors and that is -extremely- important, probably a long, long time ago.
22:03:51 <ddarius> Er, endo-functions
22:04:09 <aFlag> what are those?
22:04:19 <bos> what are which?
22:04:20 <ddarius> Functions whose domain and range are the same
22:04:34 <ddarius> I.e. they have type A -> A for some A
22:05:04 <ddarius> s/range/codomain/ to be precise
22:05:34 <Tac-Tics2> One really cool thing you can do with monads, for example, are restricting their types. I could, for instance, take the IO monad, and make a more restricted version called the "NetworkIO" monad which only has access to the Network API. Or you can take the Cont and State monads and write code that can do stateful computations with continuations, as if you were programming in Scheme
22:07:12 <aFlag> hm, why would I need a NetworkIO monad? What nice properties could they have to help me working with networking?
22:07:26 <ddarius> It's really foggy.
22:07:37 <ddarius> aFlag: It's so you have more guarantees about your code.
22:07:45 <aFlag> hm
22:08:15 <ddarius> The idea is that NetworkIO computations could only do network IO and not, e.g. file or console IO.
22:08:15 <Tac-Tics2> Or if you have an application with a central data structure that needs IO access as well. The Haskell text editor Yi has an Editor monad which is an IO monad with the editor state baked right in. You can access the outside world when you're working in Editor, but you also have free access to the Editor data structure's current state (without having to carry around a pointer to that structure!)
22:08:28 <aFlag> the only times I used monads were times that they were the only way, like IO or using parsec
22:08:58 <ddarius> aFlag: IO/ST/STM are the only monads that you are "forced" to use.
22:09:02 <bos> for small problems, it's fairly easy to get away with pure, non-monadic code.
22:09:11 <aFlag> ddarius, so if I try to open a file or something I'd get an error in compile time?
22:09:21 <ddarius> aFlag: Yes.
22:09:50 <aFlag> yeah, I've used state monad as well, but I was never in a situation when I though "hm, a monad would look great here"
22:09:56 <Tac-Tics2> ddarius: With ST, I assume you mean extracting the values of STRefs? Since ST is escapable with runST?
22:10:59 <Tac-Tics2> aFlag: keep practicing, and that will come in time
22:12:34 <Tac-Tics2> Do we know where out lovely lambdabot went?
22:12:48 <dons> http://programming.reddit.com/info/65xwq/comments/ "Solving XKCD's Ghost problem in Haskell: First player wins "
22:13:04 <dons> ?bot
22:13:06 <dons> huh
22:13:20 <Tac-Tics2> aw yay! She's back!
22:13:23 <Tac-Tics2> @vixen
22:13:31 <lambdabot> Yes
22:14:35 <ddarius> Tac-Tics2: I mean if you want that effect you -must- use that monad.
22:15:22 <backrub> anybody participate in project euler?
22:15:37 <dons> also, http://programming.reddit.com/info/65xwx/comments/ "Type safety, function calls and parentheses in Haskell "
22:15:56 <Tac-Tics2> I've done a few of the puzzles. In haskell of course. Very good practice for doing Haskelly things
22:16:17 <dons> there's a full set of solutions on haskell.org, fwiw. some guy by the name of 'Lisp' is adding them
22:16:35 <dons> don't look if you want to learn on your own :)
22:16:48 <backrub> Tac-Tics2: is it? im glad to hear it. i have been doing em in python. but i may go back and do em in Haskell, for the practice
22:17:23 <Tac-Tics2> dons: someone should write an article, similar to that last one, on every possible error haskell can throw at you as a beginner and how to fix it
22:18:08 <dons> mm, that would be interesting.
22:18:17 * ddarius considers making his own HDR image.
22:18:18 <aFlag> I tried to do some problem in project euler in haskell
22:18:22 * ddarius needs a stand.
22:18:28 <aFlag> it was project 176, but I got stuck on it
22:18:34 <backrub> Tac-Tics2: well, i think i have gotten em all, if you need a list. ^_*
22:18:42 <dons> some of the top scorers are using haskell, i've noticed
22:18:51 <dons> wasn't int-e in the top 3 for a while?
22:18:55 <aFlag> I think I have to read more about pythagorean triples and stuff like that in order to do it
22:19:10 <aFlag> I'll try it again later on
22:19:15 <backrub> aFlag: i have yet to get to that one. i am sorta working in order
22:19:25 <aFlag> I did the first few
22:19:26 <dons> oh, daniel fischer's the current top haskeller, in 15th
22:19:32 <aFlag> but I thought they were too easy
22:19:36 <dons> int-e
22:19:39 <dons> s back in 48
22:19:44 <aFlag> so I went straight to the last one at the time
22:19:58 <backrub> they should have just released one tonight
22:20:01 <dons> wow, 8 people from this channel in the top 100....
22:20:04 <backrub> 19 mins ago
22:20:55 <aFlag> that kind stuff gets me bored though. I rather write programs for doing things I find more useful
22:21:07 <backrub> ahh, yeah i am like the opposite
22:21:16 <backrub> doing stuff is cool, but i like the theory/math/useless stuff
22:21:17 <backrub> ^_*
22:21:42 <backrub> no, i just enjoy the math and programming
22:21:59 <aFlag> well, I get useful is a bad term here. I should have used practical I guess
22:22:12 <aFlag> s/I get/I think/
22:22:15 * ddarius likes using the math/theory stuff to do things.
22:22:35 <aFlag> I once joined a abstract algebra class
22:22:38 <Tac-Tics2> aFlag: there's tons of practical applications for haskell as well. Very nice and easy to use IO, network, and threading libraries
22:22:39 <aFlag> it was fun for a while
22:22:46 <aFlag> but eventually I droped it
22:23:07 <aFlag> Tac-Tics2, yeah, there's even xmonad which I use everyday
22:23:29 <backrub> Haskell is used more commonly for research, correct?
22:23:48 <Tac-Tics2> speaking of Xmonad, I wanted to install taht last week, I should go pull out an old computer and try to get it running
22:23:50 <aFlag> I used to use darcs a lot as well, but lately I've been using git
22:24:08 * hgolden is away: back in 1 hour
22:24:31 <Tac-Tics2> Haskell is very much a research language. It takes a radical approach with the lazy, pure functional programming and tries to run with it as hard as it can. Lots of cool new ideas have popped up because of it
22:24:37 <dons> backrub: not so much these days
22:24:42 <dons> its gone kind of crazy open source
22:25:12 <dons> the hundreds of libraries on hackage.haskell.org are primarily not from research
22:25:32 <dons> though that was the historic origin of the language -- how to design a better, safer, more concise programming language
22:25:43 <dons> ?users
22:25:43 <lambdabot> Maximum users seen in #haskell: 454, currently: 385 (84.8%), active: 7 (1.8%)
22:25:57 <ddarius> Where does this "very much a research language" meme come from?  Relative to Java, yeah, relative to Self or Omega (languages that explicitly -are- research languages) no.
22:26:31 <dons> ddarius: stereotypes from 15 years ago have a slow death
22:26:46 * dons reboots xmonad just to check he's in the real world
22:26:51 <dons> ok. done. that was nice.
22:26:52 <ddarius> It says right on the box that it it's intended for -both- research and application.
22:26:59 <Tac-Tics2> ddarius: before I started haskell, I never ran into a situation where the only documentation for a feature was a cited postscript file....
22:27:06 <dons> ddarius: hehe
22:27:17 <dons> Tac-Tics2: yeah, that was before the great wiki/blog conflagration of 2006
22:27:21 <ddarius> Tac-Tics2: Again, relative.  Try to find Self's documentation.
22:27:34 <Tac-Tics2> Even if haskell isn't *just* a research language, that's its heritage
22:27:48 <ddarius> Tac-Tics2: That's every languages' heritage.
22:28:02 <dons> definitely. all that cutting edge research means we get to cut with sharper knives
22:28:14 <Tac-Tics2> Javascript or PHP, ddarius, would disagree with you =-P
22:28:24 <aFlag> I think there's no real need to categorize languages like that
22:28:25 <Tac-Tics2> the major source of javascript documentation is shitty tutorial sites
22:28:47 <dons> 'research' doesn't mean anything in this case, unless you mean 'there's lots of serious programming language experts contributing'
22:28:58 <aFlag> languages are just languages, they can get commercial whenever a big company uses them
22:29:05 <aFlag> doesn't really matter the background
22:29:15 <dons> that's true enough. wake up sheeple!
22:29:22 <Tac-Tics2> I'm not discriminating haskell at all. I'm not saying "just a research language", so don't take it that way, please
22:29:25 <dons> or, they can come from open source roots.
22:29:34 <dons> perl grew up without big commercial backers
22:30:08 <ddarius> Tac-Tics2: I didn't take it that way, but it's not "very much a research language" as compared to -actual- research languages.
22:30:27 <dons> the actual research languages are quite a different beast.
22:30:36 <dons> they don't come with package distribution systems :)
22:30:43 <dons> or irc channels
22:30:48 <aFlag> what makes a language a research language?
22:30:51 <Tac-Tics2> I'm not in academics, so I don't know what an "actual" research language is.
22:31:04 <aFlag> I bet there are articles written on python, is python a research language?
22:31:07 <ddarius> Tac-Tics2: I gave two examples, Self and Omega.
22:31:22 <Tac-Tics2> All I know is that Haskell forces you to dig into those PDFs all the time!
22:31:34 <ddarius> Tac-Tics2: But yeah, you (no one) is likely to even hear of most research languages.  They sometimes don't even have names.
22:31:44 <dons> a lot of the core stuff is documented in peer reviewed papers
22:31:45 <cjb> Python was very much a research language.  Guido worked in an academic CS department implementing (mostly ADA, I think?) compilers before writing it.
22:31:48 <backrub> http://www.cs.cmu.edu/~mleone/language/overviews.html
22:31:49 <lambdabot> Title: Research Language Overviews
22:32:11 <dons> hope? that looks circa early 90s :)
22:32:17 <ddarius> (Actually, comparing to Java is probably less than ideal.  I bet more research goes on using Java than using Haskell.)
22:32:25 <ddarius> hope and charity
22:33:39 <backrub> that was just what Google spat out first
22:33:45 <backrub> I was feeling lucky. ^_*
22:34:30 <dons> for "haskell is a research language?"   ?
22:34:46 <backrub> no
22:34:52 <dons> "817,000 for haskell is a research language"
22:34:56 <backrub> research languages
22:35:01 <dons> 93,500 for haskell is not a research language
22:35:08 <backrub> haha
22:35:24 <dons> 93,200 for haskell was a research language
22:35:39 <thetallguy> lord knows you wouldn't want to use anything produced by researchers
22:35:39 <dons> 312,000 for haskell is cool
22:35:48 <dons> 71,800 for haskell sucks
22:36:01 <dons> yeah, stupid researchers. always writing up their work and documenting things.
22:36:09 <dons> and innovating. damn them!
22:36:24 <backrub> well, i plan to go into academia. so whatever i have to learn i will
22:36:39 <dons> :)
22:36:48 <thetallguy> I don't trust anything peers have had their paws on, myself
22:37:19 <backrub> thetallguy: what do you mean?
22:37:26 <bparkis> in lisp, (cdr nil) = nil, and that is often convenient so why not have tail [] = []
22:38:20 <thetallguy> backrub: peer review is like in-breeding, you just end up with what your little cabal likes
22:38:31 <dons> ssh, there is no cabal
22:38:44 <thetallguy> there is only zul
22:39:01 <backrub> haha. hmm.. well, i will keep my eyes out
22:39:21 <backrub> (secretly, im just avoiding gettting a real job)
22:39:41 <aFlag> "britney is smart" -> 5,300;  "britney is not smart" -> 8
22:39:45 <aFlag> so britney is smart
22:39:50 <backrub> haha
22:39:56 <backrub> just britney?
22:40:07 <aFlag> I think google doesn't get sarcasm
22:40:10 <backrub> i mean sure the, average britney is probably smart
22:40:23 <backrub> woah.. weird.. comma dislexia
22:40:43 <aFlag> it works for "britney spears is smart" and "britney spears is not smart" as well
22:40:53 <backrub> oh well, then i concede
22:41:20 <dons> she's probably smart.
22:41:20 <aFlag> there's only one hit for "britney spears is not smart" actually
22:41:34 <sarehu> bparkis: if you want that, just use   drop 1 []
22:42:02 <ddarius> I don't think either Scheme nor CL define (cdr nil) to be nil.
22:42:23 <bparkis> cl has (cdr nil) = nil
22:42:46 <jsnx> @help
22:42:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:42:52 <jsnx> @list
22:42:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
22:43:18 <ddarius> bparkis: Apparently.  Scheme doesn't.
22:44:25 <jsnx> @seen Cale
22:44:26 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I don't know when Cale last spoke.
22:45:10 <gio123> @seen Cale
22:45:10 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I don't know when Cale last spoke.
22:45:48 <backrub> so do you guys always have a haskell interpreter open?
22:46:04 <jsnx> @tell Cale I think there is an error in PRbook.pdf -- on page 34 -- the v < w and v = w case should be interchanged
22:46:04 <lambdabot> Consider it noted.
22:46:04 <ddarius> Yes, lambdabot.  At least when she's not acting up.
22:47:27 <jsnx> i think we are all going to have to switch to coq soon
22:47:34 <jsnx> haskell is getting, well, cool
22:47:40 <jsnx> cooooooooooool
22:47:52 <jsnx> coq scares the bejeberz out of me
22:49:08 <ddarius> Why?
22:49:08 <backrub> coq? and how do you pronounce that, if i may ask
22:49:13 <sarehu> coke
22:49:19 <backrub> uh huh..
22:49:32 <sarehu> unless my french teachers all lied to me
22:49:51 <backrub> what does it mean?
22:49:56 <sarehu> chicken?
22:50:06 <dons> theorem prover :)
22:50:06 <smack__> Some French computer scientists have a tradition of naming their software as animal species: Caml, Elan, Foc or Phox are examples of this tacit convention. In French, ?coq? means rooster, and it sounds like the initials of the Calculus of Constructions CoC on which it is based.
22:50:31 <ddarius> It's referencing Thierry Coquand
22:50:44 <backrub> i see
22:52:10 <jsnx> to tell you the truth, i don't belong in this channel
22:52:10 <jsnx> i should be in #ruby
22:52:10 <jsnx> i'm riff-raff
22:52:33 <backrub> multiple servers?
22:52:42 <backrub> or in this case... channels
22:53:51 <backrub> so guys, i am mentoring a FIRST team (im the programming mentor). and we use C. which is fine and all. out of curiosity, is Haskell used in roboti cs of any sort?
22:54:22 <jsnx> i doubt it
22:54:30 <jsnx> however, i don't know for a fact
22:54:42 <ddarius> Timber was based on O'Haskell which was based (obviously) on Haskell.
22:54:59 <backrub> ddarius: And Timder is?
22:55:03 <backrub> ...Timber*
22:55:09 <ddarius> Robotics was also one of the applications for functional reactive programming (which is related to Timber)
22:55:16 <ddarius> @google Timber programming language Haskell
22:55:18 <lambdabot> http://citeseer.ist.psu.edu/593103.html
22:55:18 <lambdabot> Title: Timber: A Programming Language for Real-Time Embedded Systems - Black, Carlsson, ...
22:56:01 <backrub> hmm, interesting
22:56:34 <backrub> anybody here ever do any robotics? (any language)
22:57:16 <backrub> (doing the robot dance doesnt count)
22:57:30 <ivanm> backrub: mindstorm robotics count? :p
22:57:37 <backrub> of course
22:57:40 <backrub> them things are fun
22:57:47 <ivanm> not that I'm doing any...
22:58:06 <backrub> you guys seen those "new" rubix cubes
22:58:08 <backrub> with the lights
22:58:54 <backrub> well, i thought of building a mindstorm bot which could play some of the games. using light sensors and some motors.
22:59:26 <backrub> just to.. i dunno, duplicate in a way the guy who built a lego bot to solve rubix cubes
22:59:56 <aFlag> backrub, I did a robotics course
22:59:58 <Tac-Tics> There was a japanese robot late last year which could play the violin
23:00:03 <aFlag> I programmed on interactiveC
23:00:05 <Tac-Tics> that was sweet
23:00:16 <aFlag> it's a version of C with less stuff
23:00:21 <backrub> Tac-Tics: yeah, i think Honda made it
23:00:30 <backrub> aFlag: awesome. make anything interesting?
23:00:40 <ivanm> aFlag: did it make it better or worse than "plain" C?
23:00:54 <aFlag> it was worse because it lacked features hehe
23:00:56 <nanothief> c with less stuff... I'm kinda scared
23:01:00 <Tac-Tics> I would like to program with robots. Electronics has always interested me, but I never really figured out how to get into it
23:01:06 <aFlag> well, for threads it was better
23:01:13 <aFlag> well, it was easier
23:01:14 <aFlag> not better
23:01:48 <aFlag> backrub, I made only a robot that followed a line and another one that would follow a wall to collect little blocks in the final competition of the course
23:01:54 <backrub> Tac-Tics: Boe-Bots are fun to mess with. might be cheap, not sure.
23:02:03 <aFlag> mine was one of the simpler robots, there were ones smarter than mine
23:02:36 <backrub> the "best" thing I ever did was program a camera to recognize a green light and then autonomously move toward it, within a cetrain distance.
23:02:49 <aFlag> we used something called handyboard, which has input and output for motors, leds, sensors and such
23:03:08 <aFlag> and for programming on it you needed to use interactiveC or assembly
23:03:37 <backrub> i'd love to program a robot in a scripting language, hehe
23:04:00 <aFlag> it'd probably make the life easier
23:04:17 <aFlag> but writing the software wasn't the hardest part, at least not four our group
23:04:37 <backrub> hardware more the issue?
23:05:03 <aFlag> we were all computer science major and we didn't know even how to connect wires
23:05:09 <backrub> haha, uh oh
23:05:45 <backrub> guess i was lucky enough to be on a robotics team for 4 years. anybody here participate or follow FIRST at all?
23:05:48 <Tac-Tics> When I was a kid, I was all into those RadioShack circuit boards
23:05:56 <Tac-Tics> But I never understood how any of it worked
23:06:32 <backrub> you sound pretty smart now, bet you could figure it out
23:06:41 <backrub> or at least Google it. ^_*
23:06:53 <aFlag> Tac-Tics, those protoboards?
23:07:05 <aFlag> solding is very hard
23:07:09 <Tac-Tics> Now that I know functional programming, I don't think i could bear working with such lowlevel details as a circuit ;-)
23:07:09 <aFlag> I thought it was easier
23:07:24 <aFlag> we burned quite a few sensors
23:08:13 <backrub> Tac-Tics: figure out a way to combine FP and Robotics in some new clever way.. be famous! pay me money for inspiring you when you are rich!
23:08:33 <backrub> aFlag: i burnt my thumb soldering once
23:08:59 <Tac-Tics> If only the world were functional instead of imperative!
23:09:39 <aFlag> but the fake enthusiasm from our friends when we'd show them our robot following a black line or telling the color of a little block was priceless.
23:09:49 <BMeph> That might be a good application for Factor, actually.
23:10:33 <aFlag> it was a fun class, but I do never want to work with robotics again
23:11:21 <backrub> aww, well thats okay. however, Bill Gates and other feels the time is coming when we will all interact with robots a lot more. in the home, etc
23:11:37 <backrub> so while you may not dev, you may have to 'work' with them, by some definition, soon enough
23:12:11 <aFlag> yeah, that'll happen sooner or later
23:12:23 <ddarius> backrub: The time is coming, but not soon.  Robots haven't really moved into that role anywhere.
23:12:27 <BMeph> The company I work for supplies parts to many folks who do AUVSI.
23:13:14 <backrub> ddarius: give me 6 to 10 years, i will change things.
23:13:42 <backrub> BMeph: very cool. any demos?
23:13:59 <ddarius> backrub: In six to ten years most people still won't, but maybe there will be a significant chunk who do.
23:14:18 * hgolden is back
23:14:28 <backrub> One Robot Per Child?
23:14:39 <Tac-Tics> awesome. I'd want one
23:14:39 <BMeph> When they have events in town, one of the teams always stops by the place to show us what they've done.
23:15:01 <ddarius> One Univac Per Child!
23:15:12 <aFlag> It's likely that most people don't have a phone
23:15:18 <Tac-Tics> One Function Per Child!
23:15:31 <backrub> now -thats- pure!
23:15:37 <ivanm> lol
23:15:42 <ddarius> aFlag: Then limit my claim to just America.
23:15:43 <Tac-Tics> There's nothing more wholesome than a computable function
23:15:43 <flux> only one? sad :-(
23:16:09 <Tac-Tics> Children would probably need at least S and K
23:16:14 <ivanm> @remember Tac-Tics <Tac-Tics> One Function Per Child! <backrub> now -thats- pure!
23:16:15 <lambdabot> It is stored.
23:16:43 <ddarius> Tac-Tics: You could just give them X.
23:17:14 <Tac-Tics> How is X defined?
23:17:37 <backrub> hmm.. altho, giving a child a laptop is a form of a side-effect, right?
23:18:00 <backrub> maybe?
23:18:11 <ddarius> Tac-Tics: There are a couple definitions.  See http://citeseer.ist.psu.edu/251224.html
23:18:11 <lambdabot> Title: The systematic construction of a one-combinator basis for Lambda-terms (Research ...
23:18:13 <Tac-Tics> modify childToChildWithLaptop :: State Child ()
23:19:09 <Tac-Tics> My old computer looks to be choking on the Ubuntu install =-(
23:19:16 <Cale> jsnx: hi
23:19:16 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
23:19:43 <Cale> jsnx: with the ordinals?
23:19:54 <Cale> jsnx: yes, I agree.
23:20:29 <bench1> how do i substitute '&' to '/' in a string?
23:20:48 <backrub> well guys, i am out. need my rest, gots some more FP to learn tomorrow. ^_^ i will definitely come back here tho.
23:21:04 <Tac-Tics> @hoogle Char -> String -> String
23:21:05 <lambdabot> No matches, try a more general search
23:21:55 <ivanm> bench1: map?
23:22:11 <Tac-Tics> There's a replace in Network CGI =-P
23:22:17 <sieni> > map (\x -> if (x == '&') then '/' else x) "foo&bar"
23:22:21 <lambdabot>  "foo/bar"
23:22:24 <Tac-Tics> but it's easy enough to write
23:22:29 <ivanm> sieni: dammit, you beat me to it!
23:23:03 <bench1> ok, so there is no built-in functions i guess
23:23:36 <sieni> @pl map (\x -> if (x == '&') then '/' else x) "foo&bar"
23:23:36 <lambdabot> map (flip if' '/' =<< ('&' ==)) "foo&bar"
23:24:16 <ivanm> bench1: you could always write a generalised version...
23:24:27 <ivanm> @hoogle a -> a -> [a] -> [a]
23:24:27 <lambdabot> No matches, try a more general search
23:24:40 <ivanm> that's the kind of signature you'd want, anyway
23:24:54 <ivanm> well, subject to a being an instance of Eq anyway
23:25:21 <sieni> like
23:25:31 <sieni> > concatMap (\x -> if (x == '&') then "foo" else [x]) "foo&bar"
23:25:32 <lambdabot>  "foofoobar"
23:25:55 <ivanm> no, I meant a general replacement function:
23:26:44 <ivanm> > let replace x y = map (\ a -> if (a == x) then y else a) in replace '&' '/' "foo&bar"
23:26:45 <lambdabot>  "foo/bar"
23:28:33 <bench1> thanks ivanm
23:29:09 <BMeph> > ((map .) . flip . join . (if' .) . (/=)) '@' '&' "foo&bar"
23:29:10 <lambdabot>   Not in scope: `if''
23:29:16 <ivanm> bench1: no probs
23:29:55 <BMeph> > let if' p t f = if p then t else f in ((map .) . flip . join . (if' .) . (/=)) '@' '&' "foo&bar"
23:29:57 <lambdabot>  "foo&bar"
23:30:16 <BMeph> > let if' p t f = if p then t else f in ((map .) . flip . join . (if' .) . (/=)) '&' '@' "foo&bar"
23:30:16 <lambdabot>  "foo@bar"
23:31:04 <ivanm> BMeph: no offence, but I think mine's nicer :p
23:31:04 * BMeph has much <3 for Stupid Pointless Tricks
23:31:12 <ivanm> though maybe using if' would improve it
23:31:39 <ivanm> > let if' p t f = if p then t else f; replace x y = map (\ a -> if' (a == x) y a) in replace '&' '/' "foo&bar"
23:31:40 <lambdabot>  "foo/bar"
23:32:50 <BMeph> ivanm: Be my guest, I see it come out of @pl so often, I was annoyed that it wasn't already made.
23:33:36 <ivanm> yeah... someone added if' to lambdabot's @pl, but no-where else
