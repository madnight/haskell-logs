00:03:30 <goalieca> and you said it took 0.7 to just count
00:03:32 <goalieca> so that's preetty good
00:03:47 <dons> 0.07 to break the words
00:04:01 <dons> but there's a lot to improve in the memcmp
00:04:43 <sjanssen> dons: should there be ! on len1 and len2?
00:05:08 <dons> that's what i'm simplifying right now, actually
00:10:49 <MyCatVerbs> sarah__: Haskell is more like "the only lazy language *left* in academia" than "the only lazy language in academia" :)
00:12:41 <hpaste>  bos pasted "Data.HashTable version" at http://hpaste.org/4924
00:12:53 <solrize> speed of that?
00:13:17 <bos> 0.69 seconds on a 974KB file
00:13:40 <bos> i'm using http://www.gutenberg.org/dirs/etext97/bwulf11.txt concatenated onto itself repeatedly as the test dataset
00:14:03 <solrize> 2.6 sec for my 3MB file, a tiny bit faster than the map version
00:14:12 <solrize> but the results are in reverse order, i think
00:14:42 <bos> oh, right. use flip in front of comparing.
00:14:43 <solrize> need to flip the comparison
00:14:45 <solrize> right
00:15:07 <solrize> yeah, that looks right
00:15:09 <bos> doesn't change the execution time.
00:15:31 <solrize> yeah, it would be nice if there was a heap sort function that was lazy
00:15:36 <bos> the hashtable API sucks compared to the rich broth of Data.Map
00:16:03 <solrize> bos yeah if i ever figure out this language enough, i want to start using happs for web stuff, and it revolves around data.map
00:16:16 <xpik2> @pl (\x-> x+(x*2))
00:16:16 <lambdabot> ap (+) (2 *)
00:16:42 <solrize> Prelude> :t ap
00:16:42 <solrize> <interactive>:1:0: Not in scope: `ap'
00:17:33 <xpik2> @pl (\x-> (x/3)+(x*2))
00:17:33 <lambdabot> liftM2 (+) (/ 3) (2 *)
00:19:18 <bos> ap :: Monad m => m (a -> b) -> m a -> m b
00:19:26 <bos> it's the monadic version of $
00:19:51 <bos> also written as <*> quite often in the latest fashion.
00:20:37 <solrize> eh?  there's a monad for numeric functions?
00:20:45 <bos> no, for functions in general.
00:20:54 <xpik2> there's a monad for type (->)
00:20:56 <bos> think of (->) as a type constructor.
00:21:32 <Cale> (since it is)
00:21:59 <hpaste>  dons annotated "bytestring version" with "1sec Map + new Ord" at http://hpaste.org/4922#a4
00:22:07 <Cale> For any type e,  (->) e,  that is, the type constructor for functions from the type e, is a monad.
00:22:08 <solrize> so "return" pulls out the original parameter ?
00:22:10 <dons> so that's the fastest I've got with a Map, solrize
00:22:10 <bos> well, yes, but newbs don't think of it as such. it just looks like notation.
00:22:17 <dons> solrize: twice as fast as with String+Map
00:22:30 <xpik2> @pl   (\x y -> fst 1 == fst )
00:22:30 <lambdabot> const (const (fst 1 == fst))
00:22:36 <Cale> > do { x <- id; y <- reverse; z <- map toUpper; return (x,y,z) }
00:22:37 <bos> different ords for different fnords.
00:22:41 <Cale> > (do { x <- id; y <- reverse; z <- map toUpper; return (x,y,z) }) "hello"
00:22:51 <lambdabot>  thread killed
00:22:56 <lambdabot>  thread killed
00:23:00 <Cale> uhh...
00:23:04 <solrize> dons, 4x speedup from the earlier bytestring version is pretty good
00:23:13 <dons> you got a 4x speedup?
00:23:15 <solrize> i mean, can you fold that into the library?
00:23:25 <dons> solrize, in this case, yes.
00:23:28 <solrize> using your original timing
00:23:36 <xpik2> @pl   (\x y -> fst x == fst y )
00:23:36 <mbot> (. fst) . (==) . fst
00:23:36 <lambdabot> (. fst) . (==) . fst
00:23:39 <Cale> mbot: @run (do { x <- id; y <- reverse; z <- map toUpper; return (x,y,z) }) "hello"
00:23:42 <mbot>  ("hello","olleh","HELLO")
00:23:51 <Cale> mbot: @part #haskell
00:23:58 <bos> dons: what's different?
00:24:10 <dons> bos, an inlining was messing things up.
00:24:23 <Cale> ^^ there's an example of the (->) e monad, in this case, with e = String
00:24:25 <dons> i tried a couple of different versions of the compare, but couldn't get a faster one
00:24:32 <dons> though i'm not convinced its optimal
00:24:37 <bos> oh, you killed the inlining of cmp.
00:24:46 <Cale> and yeah, return = const
00:24:46 <dons> yeah
00:24:54 <Cale> > return 5 6
00:24:56 <lambdabot>  5
00:24:57 <bos> and compare.
00:25:08 <Cale> > (do { x <- id; y <- reverse; z <- map toUpper; return (x,y,z) }) "hello"
00:25:08 <lambdabot>  ("hello","olleh","HELLO")
00:25:16 <Cale> okay good, that's working again :)
00:26:02 <bos> so i don't think Map has any significant bearing on this, in terms of performance.
00:26:10 <solrize> bos, probably right
00:26:17 <Cale> Basically, to "run" each sub-computation, which is just a function of type e, you apply the function to the parameter which the computation as a whole has been applied to.
00:30:09 <solrize> so (ducks flames) does the PL research community still think laziness by default is a good thing?
00:30:37 <solrize> skew, i don't think clean had linear types
00:31:11 <skew> course it does!
00:31:19 <skew> maybe they say uniqueness
00:31:31 <solrize> yeah, they do, but i thought linear types meant something different
00:31:33 <dons> solrize: lazines isn't an issue here
00:31:44 <solrize> dons, not an issue for this, i mean in general
00:31:54 <dons> seems like a useful thing.
00:32:06 <sphynx> hi all
00:32:45 <sjanssen> dons: it is faster than memcmp for smallish strings, right?  Will you add it to the repository soon?
00:33:08 * sjanssen likes nagging :)
00:33:16 <sphynx> I thought that if 'newtype NT = NT Float' then NT _|_ = _|_, now I am testing this and it doesn't seem to work..
00:33:17 <dons> sjanssen: yeah. it seems like a good thing to do.
00:33:34 <xpik2> @pl   (\x y -> [x,y]  )
00:33:34 <lambdabot> (. return) . (:)
00:33:36 <skew> a program really shouldn't be doing lots of comparisions on strings with big common prefixes
00:34:23 <solrize> hmm, data.map might do a lot of exactly that, since it's chasing down a tree to find where to put something
00:34:28 <Korollary> skew: "a" program?
00:34:54 <sphynx> bot = bot
00:34:54 <sphynx> nt = NT bot
00:34:54 <sphynx> instance Show NT where show (NT x) = "NT"
00:35:05 <sjanssen> sphynx: yes, NT _|_ = _|_
00:35:11 <sphynx> and then main = print nt works
00:35:33 <sjanssen> sphynx: ah, there is the other difference -- pattern matching on NT essentially has no effect
00:35:40 <bos> sphynx: that's an irrefutable pattern.
00:35:41 <skew> Korollary: you should be using prefix trees or something if you expect it to come up
00:35:42 <sphynx> but if use data NT' = NT' !Float, all works as I want (it is strict constructor)
00:36:10 <sphynx> so the problem is in pattern matching, not in newtype strictness?
00:36:31 <sjanssen> sphynx: I would say difference rather than problem, but yes
00:36:50 <skew> hmm, well I guess if you are writting diff you do expect equality to come up...
00:36:53 <bos> sphynx: no, there's no problem. a binding in an irrefutable pattern doesn't need to be evaluated, so _|_ is never forced.
00:37:22 <sphynx> sjanssen: how should I change this? Add ~ to pattern?
00:37:28 <skew> anyway, the character where the strings first differ is useful infromation, and I don't see that returned in the current API
00:37:43 <sphynx> I need to show the difference between newtype and data somehow
00:37:43 <bos> sphynx: no, that makes the pattern lazy, which makes no difference in this case.
00:37:45 <sjanssen> sphynx: ~ on a newtype pattern changes nothing
00:38:15 <sphynx> hm, so how should I show the difference?
00:38:49 <sjanssen> NT undefined `seq` () vs. Data undefined `seq` ()
00:39:52 <dons> yeah, i get identical timings with Hash and Map now
00:40:35 <hpaste>  dons annotated "bytestring version" with "Hash on ByteString" at http://hpaste.org/4922#a5
00:41:00 <sphynx> and this is single difference between data and newtype? I mean (NT _|_ = _|_)
00:41:27 <sphynx> also there are some intenal differences maybe...
00:41:33 <sjanssen> it isn't the only one, because strict data types have the same behavior
00:41:33 <sphynx> internal *
00:41:33 <bos> that's a yucky hash :-)
00:41:41 <dons> :)
00:42:00 <sjanssen> sphynx: the Haskell report has some commentary on this issue
00:42:07 <dons> since we only need Eq, we can do a bit better yet
00:42:20 <sphynx> yeah, so what is the difference between data! and newtype?
00:42:31 <sphynx> sjanssen: ok, I will try to look into it
00:42:39 <bos> we should adapt this for bytestrings: http://www.burtleburtle.net/bob/c/lookup3.c
00:43:01 <dons> looks like Eq on bytestring should be tuned to avoid the C call too.
00:43:17 <bos> sphynx: newtype vanishes completely at runtime - there's no additional overhead.
00:43:31 <bos> sphynx: data will add an extra level of indirection usually, even with !.
00:44:03 <solrize> is type different from newtype?
00:44:09 <bos> sphynx: hence ghc's -funboxed-strict-fields flag
00:44:12 <bos> solrize: yes.
00:44:22 <bos> solrize: type == alias, newtype == distinct type.
00:45:00 <sphynx> bos: -funboxed-strict-fields makes data! works as newtype?
00:45:10 <bos> no.
00:46:08 <bos> but it means that the unboxed value will be present in the same piece of allocated heap as the rest of the value's book-keeping.
00:46:21 <sphynx> bos: BTW, I like your Mercurial book, greatly written! :)
00:46:25 <bos> thanks!
00:47:01 * solrize eagerly awaits the haskell book! :)
00:47:24 * bos goes to bed
00:47:41 <dons> there we go, 0.915s :)
00:47:59 <solrize> cool
00:48:00 <dons> so its all in tuning the inner loops of the eq and comparison functions in the end
00:48:10 <dons> which surely has been done for the python hashtable
00:48:13 <solrize> this is stuff that can go into the next version?
00:48:19 <dons> yeah.
00:48:36 <dons> basically, the current Eq and Ord are optimised for larger strings than we typically use
00:48:46 <solrize> yeah they have tuned the heck out of the python hash func.  on the other hand i deliberately wrote that python code in sort of a pessimized way using generators, to be like idiomatic haskell
00:49:12 <dons> its a surprising benchmark
00:50:04 <solrize> yes if bytestring was originally tuned for bigger strings
00:50:17 <C-Keen> @paste
00:50:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:50:40 <solrize> i mean it's a pretty reasonable application, i hope ?
00:51:04 <C-Keen> good morning, while I now know how to define monads I am feeling totally stupid that I am unable to use one...
00:51:55 <dons> solrize: yeah. having lots of small strings broken up, and stored in a Map should be well tuned.
00:52:19 <hpaste>  c-keen pasted "What am I missing here?" at http://hpaste.org/4925
00:52:56 <hpaste>  dons annotated "bytestring version" with "fastest (0.9s) Hash+ByteString Eq" at http://hpaste.org/4922#a6
00:52:58 <solrize> is there some chance that this stuff can be more completely integrated with the regular string type in future incarnations?
00:53:21 <dons> solrize: there's a very high chance the bytestring library will use these versions of Eq and Ord that don't make calls into C
00:53:28 <dons> since its faster to stay in Haskell, as we saw
00:53:39 <dons> so i'll probably commit the changes tomorrow, in fact :)
00:53:43 <skew> faster for all sizes, or just for small sizes?
00:53:54 <solrize> oh this version uses mutable hashes
00:53:57 <dons> small sizes much faster, larger ones a few percent slowdown.
00:54:02 <dons> solrize: right. the Map was 5-10% behind
00:54:13 <solrize> that seems worth it
00:54:18 <dons> (it needs Ord rather than Eq, which is a bit more complex)
00:54:24 <skew> we're planning to win eventually with dph vectorization, right?
00:54:25 <solrize> hmm true
00:54:31 <dons> you could definitely tune the hashtable data structure too
00:54:39 <dons> its very unoptimised.
00:54:59 <dons> skew, well, mostly we do. strings && hashtables == a little bit neglected
00:55:45 <dons> solrize: interestingly, the naive hashtables i've used in the shootout are many times faster than Data.HashTable, and tries are better still (for this kind of frequency counting)
00:55:45 <skew> solrize: String = [Char] is easy to write up algorithms with. It's a little harder to do pattern matching and stuff with bytestrings
00:55:48 <solrize> wow, you can importa ll those different packages as the same symbol, i didn't know that
00:56:15 <bos> views for pattern matching on bytestrings will be nice.
00:56:23 <skew> dons: I meant specifically speed of the C vs. Haskell operations on long strings
00:56:27 <solrize> skew, yeah, my fantasy would be the compiler actually treating strings more like bytestrings
00:56:54 <dons> bos, what do you reckon? given its down to 0.9s versus 0.7s for python, for the hashtable version, probably the rest is just algorithmic stuff from using a naive hashtable?
00:57:06 <dons> (our current hashtable type doesn't even inline)
00:57:11 <solrize> dons, 0.7 is the python version i pasted?
00:57:15 <bos> probably. i think that being within 20% of python for this is great.
00:57:38 <dons> well, i think we could top it -- the Data.HashTable impl is unoptimised
00:57:43 <skew> the python hashtable isn't going to inline either
00:57:57 <bos> yeah. but it will probably swing to 20% faster, not a substantial difference.
00:58:14 <dons> a fairly naive one in the shootout outperforms python fairly well,
00:58:15 <dons>    http://shootout.alioth.debian.org/gp4/benchmark.php?test=knucleotide&lang=all
00:58:16 <lambdabot> Title: k-nucleotide benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/mnnkb
00:58:30 <bos> ok, really to bed now :-)
00:58:33 <dons> (the hashtable data structure is naive algorithmically, but hand optimised)
00:59:10 <skew> that outperforms Data.Hashtable, otherwise we wouldn't bother bloating the entry with it, right?
00:59:18 <dons> skew, yeah, by 5-10x
00:59:30 <skew> so why has that not become Data.Hashtable?
00:59:38 <dons> i always meant to port it back over, but never got around to it
00:59:41 <solrize> nite bos :)
01:00:45 <dons> its also quite a naive hash type. but its simple code that optimises well.
01:01:03 <skew> ah, they are also specialized for Int
01:01:13 <dons> yeah. and the strings don't store their length
01:01:20 <dons> (its fixed at initialisation time or some such)
01:01:36 <dons> so quite specialised
01:01:44 <dons> but the basic type is pretty straightforward
01:02:06 <dons> solrize: so the lessons here, fix up ByteString's Eq and Ords to avoid ccalls, and poke around Data.HashTable some more
01:02:09 <Sizur> hsxml is beautiful. it needs to be packaged. and used!
01:02:34 <inimino> for writing an HTTP server: Erlang or Haskell?
01:02:59 <dons> inimino: well, you're in #haskell
01:03:17 <inimino> dons: yes ;-)
01:03:35 <inimino> but I am wondering about the concurrency features of erlang
01:03:47 <inimino> and the built-in networking support
01:03:49 <solrize> dons, great, that kind of hacking is way past my ability but i'm glad it's happening
01:03:50 <dons> i'd argue since you don't tend to magically distribute web servers, and haskell has better large string support/multicore support, haskell makes more sense.
01:04:02 <solrize> inimino check out www.happs.org
01:04:22 <skew> It's not exactly concurrency that erlang is good at
01:04:26 <inimino> dons: it doesn't need to be distributed
01:04:36 <skew> - except their runtime uses epoll -
01:04:53 <skew> but rather stuff like failure monitoring and restarting on top of those threads
01:04:54 <dons> inimino: right. so that doesn't play to erlang's strength. multicore concurrency is certainly haskell's
01:05:12 <solrize> does haskell have a parallel gc and all that?
01:05:20 <inimino> dons: ok, good to know
01:05:48 <skew> Haskell threads are just as cheap to make and all that
01:05:51 <inimino> I don't know much about Erlang, but I did just read the whitepaper
01:06:31 <dons> solrize: parallel gc is in the head branch of ghc, but still experimental/not on by default
01:06:36 <inimino> skew: ok, I didn't know anything about thread in Haskell, are they directly correspond to OS threads?
01:06:53 <solrize> skew, erlang seems geared towards applications with simple enough logic that if something fails you can just crash the whole process and restart it, like rebooting a windows box when an application gets an error
01:07:16 <dons> inimino: since benchmarks are fun, here's the thread-ring benchmark, http://shootout.alioth.debian.org/gp4/benchmark.php?test=threadring&lang=all
01:07:17 <lambdabot> Title: thread-ring (new) benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer ..., http://tinyurl.com/2lyngq
01:07:22 <inimino> solrize: or restarting a daemon on Unix
01:07:25 <dons> inimino: it measure the cost of starting many threads
01:07:42 * inimino looks
01:08:37 <inimino> looks very nice :-)
01:08:40 <Sizur> solrize: i wouldn't exactly call a t-online system a simple logic
01:08:53 <solrize> t-online?
01:08:58 <Sizur> eh, make that t-com
01:09:10 <inimino> also from the Erlang white-paper, the Mnesia thing sounded cool, how would you do something that with Haskell?
01:09:42 <Sizur> their whole system is on erlang
01:09:44 <solrize> sizur, phone switches seem to mostly run the same code paths over and over
01:10:11 <quicksilver> sphynx: the different between data! and newtype is more front-end than back-end
01:10:41 <xpik2> @src (==)
01:10:42 <lambdabot> x == y = not (x /= y)
01:10:54 <skew> sphynx: the difference between type and newtype, rather
01:12:14 <Sizur> wow for ruby on that benchmark
01:13:03 <Sizur> they should have a date of the benchmark on each results page
01:13:34 <skew> A for effort!
01:13:36 <quicksilver> dons: it bugs me slightly that ffi has such an overhead, actually.
01:13:52 <inimino> dons: thanks for the link, I think that resolves my concern about thread overhead
01:13:58 <quicksilver> dons: couldn't we hope GHC to have some kind of 'FFI inlining' which just generates a direct memcmp call for something as simple as this.
01:15:34 <solrize> maybe we want a typed assembler programmed completely as gadt's, so we can write inlined machine code directly and still have it type-safe
01:16:05 <skew> quicksilver: the problem is to make sure the runtime system knows what to do if it tries to suspend or GC the thread
01:16:38 <quicksilver> skew: haskell threads are not real threads in general.
01:16:39 <bruno_d> Dear Haskellers, I have a question about arrays with a functional interface.
01:16:55 <quicksilver> skew: FFI blocks a whole real thread anyway...
01:17:12 <quicksilver> so the runtime system can't "try" to suspend anything during an FFI call.
01:17:46 <solrize> yow, the ffi sets a lock on every call?  that's like 100 cycles
01:18:02 <bruno_d> For characters, there is Data.ByteString. It seems to be only implemented for the Word8 type. Would it be possible to do the same for Double and other numeric types?
01:18:40 <bruno_d> I'd like to use foldl, foldr, map, zip and the like efficiently with Double arrays, as it is possible with Strings.
01:19:00 <qweqwe> how i can ask if xs null ?
01:19:10 <qweqwe> how it should be ?
01:19:13 <solrize> null xs
01:19:16 <quicksilver> if null xs then ...
01:19:25 <quicksilver> solrize: I don't think I understand what you're saying.
01:19:27 <solrize> Prelude> null []
01:19:27 <solrize> True
01:19:46 <quicksilver> solrize: there's no lockin involved, in the simple case. haskell threads are not real threads, so there is nothing to lock. the haskell RTS just makes the FFI call ...
01:20:17 <qweqwe> ok thanks
01:20:39 <solrize> i thought you were saying the ffi blocks a real thread.  i guess that means it just stops the haskell scheduler with a per-thread flag or something, ok.
01:21:22 <skew> quicksilver: I think there are still timer signals
01:21:39 <skew> also other threads can be sending over messages
01:21:40 <quicksilver> solrize: in the simple case, there is only one real thread.
01:22:05 <quicksilver> solrize: the haskell scheduler is just a virtual, software thing.
01:22:11 <quicksilver> I know that's a bit of a clumsy way to say it :)
01:22:16 <quicksilver> because all threading is software.
01:22:37 <quicksilver> but the haskell scheduler in the non-threaded RTS doesn't use pre-emption or interrupts, AFAIK.
01:22:47 <quicksilver> it seizes control at allocation points
01:22:57 <quicksilver> (which won't happen during an FFI call like memcmp..)
01:23:02 <C-Keen> hm.. how do I declare an instance of a monad w/o changing any definitions?
01:23:19 <quicksilver> C-Keen: sorry, I meant to answer you earlier. That doesn't work because Either a isn't a monad.
01:23:38 <xpik2> is there a function (toMaybe odd) 4 => Nothing
01:23:50 <quicksilver> C-Keen: there is a Monad instance for either in Control.Monad.Error. But only in the case that "a" is a member of class "Error"
01:23:57 <bruno_d> Any comments on my Double ByteString question?
01:24:10 <quicksilver> xpik2: to lift a Bool function into Maybe? no, I believe not.
01:24:30 <quicksilver> xpik2: I'v missed some connections between Bool and Maybe before. The library lacks them for some reason.
01:24:33 <skew> bruno_d: there's nothing like the lazy bytestrings
01:24:44 <C-Keen> quicksilver: thanks. You are not a helpdesk service so I am not demanding help, just asking :)
01:24:58 <bruno_d> skew: Could I write it?
01:25:00 <quicksilver> bruno_d: foldr, foldl map and zip all work pretty efficiently on [Double], by the way.
01:25:10 <bruno_d> skew: Or are there any fundamental problems.
01:25:19 <quicksilver> bruno_d: ByteString does not improve the efficiency of these basic operations over List.
01:25:40 <bruno_d> quicksilver: Aha.
01:25:44 <quicksilver> what it improves is memory-usage / cache usage  etc
01:25:46 <C-Keen> quicksilver: ah ok, so when I like a monad like that I need to indeed write my own? From yesterday's discussion I assumed I could just use one that does things like this Left success | Right failure where failure is something else than error
01:25:49 <bruno_d> I thought so.
01:26:01 <skew> bruno_d: Data.Array.Unboxed is already something like strict bytestrings
01:26:11 <quicksilver> C-Keen: conventionally you always use "Left" for failure.
01:26:18 <quicksilver> C-Keen: mnemonic : Right = that went Right.
01:26:35 <bruno_d> skew: Yes, but it doesn't have a functional interface.
01:26:37 <quicksilver> C-Keen: I would suggest you use the built in instance for Either and switch left and right.
01:26:45 <skew> bruno_d: and then the data parallel haskell project is working on nice arrays, among other things
01:27:05 <skew> C-Keen: Left = sinister
01:27:17 <quicksilver> bytestrings for other types have been discussed and one suggestion is to use the DPH stuff.
01:27:28 <bruno_d> skew: Yes, I noticed that, but it's not complete, yet.
01:27:56 <bruno_d> Ok, thanks.
01:29:35 <xpik2> > let boolToMaybe t x = if t x then Just x else Nothing in boolToMaybe odd $ 3
01:29:44 <lambdabot>  Just 3
01:29:46 <quicksilver> xpik2: yeah, I've defined that more than once :)
01:30:45 <scook0> a.k.a. guard (t x) >> return x
01:30:46 <xpik2> quicksilver: I wonder what library it would be in.
01:30:49 <sebaseba_> newbie question here. The type of / is (Fractional a) => a -> a -> a. But if I do (0 / 0), I get a NaN. Doesn't this imply that NaN is a Fractional?
01:30:54 <quicksilver> xpik2: probably Data.Maybe
01:31:11 <quicksilver> xpik2: since in my mind Bool is "more basic", so it would make more sense there than in Data.Bool.
01:31:33 <scook0> sebaseba_: NaN is a Double (in this case)
01:31:37 <quicksilver> sebaseba_: it implies that NaN is a member of whatever specific type oyu had
01:31:42 <C-Keen> quicksilver: alright
01:31:45 <scook0> and the Double type belongs to the Fractional typeclass
01:31:46 <quicksilver> sebaseba_: Double, I imagine, because that's what defaulting gives ou
01:32:24 <C-Keen> :t Either
01:32:25 <lambdabot> Not in scope: data constructor `Either'
01:32:33 <sebaseba_> ah, I see
01:33:11 <scook0> @kind Either
01:33:12 <lambdabot> * -> * -> *
01:33:14 <scook0> @type either
01:33:15 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
01:33:24 <C-Keen> quicksilver: what do you mean by 'using the builtin instance of Either'?
01:33:29 <C-Keen> scook0: thanks
01:34:29 <quicksilver> C-Keen: the built in instance of Monad for Either, I should say
01:34:36 <quicksilver> C-Keen: which you will find in Control.Monad.Error
01:35:03 <scook0> quicksilver: to be precise, the instance for Either e
01:35:19 <quicksilver> no, to be *precise* the instance for Either [Char]
01:35:26 <quicksilver> since that's what C-Keen apparently had :)
01:35:54 <xpik2> there should be a class maybeable where [] -> Nothing and False goes to Nothing
01:35:57 <scook0> heh, I shouldn't have tried to beat you at your own game :)
01:36:19 <C-Keen> quicksilver: what do I need to tell ghc to find that class?
01:36:26 <quicksilver> C-Keen: import Control.Monad.Error
01:37:02 <scook0> xpik2: not a bad idea ... I know I've occasionally wanted a ToList class
01:37:23 <quicksilver> xpik2: well, you could write boolToMZero t x = if t x then return x else mzero
01:37:28 <quicksilver> scook0: you're in luck! there is one!
01:37:33 <quicksilver> scook0: it's called Foldable
01:38:11 <C-Keen> quicksilver: I did this:  Could not find module `Control.Monad.Error': Use -v to see a list of the files searched for.
01:38:49 <C-Keen> quicksilver: my ghc is version 6.6.1
01:39:02 <scook0> oh, in that case you could do listToMaybe . Foldable.toList
01:39:15 <xpik2> > toList Node 1 [Node 3 []]
01:39:15 <lambdabot>   Not in scope: `toList'
01:39:48 <xpik2> @m + Data.Foldable
01:39:48 <lambdabot> Maybe you meant: map messages messages? more msg . ? @ v
01:39:51 <scook0> > Data.Foldable.toList (Just 3)
01:39:52 <lambdabot>  [3]
01:41:10 <quicksilver> C-Keen: you probably haven't installed the mtl?
01:41:20 <quicksilver> apt-get install ghc6-mtl-dev, I think, on debian
01:41:29 <quicksilver> some similar incantation on less fortunate OSes
01:42:17 <C-Keen> grml not on ubuntu obviously
01:42:44 <C-Keen> quicksilver: thanks for the pointer I will deal with this
01:43:19 <quicksilver> it's something similar on ubuntu
01:43:23 <quicksilver> I may have got the name slightly wrong
01:43:45 <quicksilver> libghc6-mtl-dev
01:43:48 <quicksilver> it looks like
01:48:05 <C-Keen> quicksilver: it was the right name
01:51:26 <C-Keen> quicksilver: now I feel like I am back to square 1. Is there a Monad that let's me use an arbitrary type for Left?
01:51:39 <quicksilver> not entirely arbitrary
01:51:45 <quicksilver> it has to be an instance of "Error"
01:51:50 <quicksilver> to use the Control.Monad instance
01:52:03 <quicksilver> however, making an arbitrary type an instance of Error is easy enough
01:52:28 <C-Keen> quicksilver: what exactly is Error?
01:52:48 <doserj> @src Error
01:52:48 <lambdabot> class Error a where
01:52:48 <lambdabot>     noMsg  :: a
01:52:48 <lambdabot>     strMsg :: String -> a
01:53:27 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
01:53:29 <lambdabot> http://tinyurl.com/2cvgfn
01:53:40 <quicksilver> does not exactly explain everything but it has a couple of example at least
01:53:48 <C-Keen> so I can say Instance Error foo where strMsg :: footype -> a ?
01:54:10 <doserj> no
01:54:33 <doserj> instance Error foo where strMsg :: String -> foo; strMsg s = ...
01:55:05 <doserj> then Either foo a is a Monad
01:56:19 <Mr_Awesome> i just wrote a function like so: (^&&^) f g x = f x && g x, but i feel like im reinventing the wheel. is there a better way?
01:56:32 <C-Keen> doserj: doesn't this mean that I still have to give the Left of the monad a String to return?
01:56:46 <Sizur> :t (&&&)
01:56:48 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
01:57:00 <doserj> Mr_Awesome: liftM2 (&&) ?
01:57:07 <Sizur> sec you need a Bool
01:57:22 <doserj> C-Keen: ?
01:58:08 <Sizur> :t (\a-> uncurry (&&) . (&&&) a)
01:58:08 <lambdabot>     Couldn't match expected type `Bool' against inferred type `(c, c')'
01:58:08 <lambdabot>       Expected type: (Bool, c') -> (Bool, Bool)
01:58:08 <lambdabot>       Inferred type: (Bool, c') -> (Bool, (c, c'))
01:58:35 <quicksilver> Mr_Awesome: that is also (&&) `on` f, if you have 6.8
01:58:40 <quicksilver> Mr_Awesome: not that that is any shorter :)
01:59:06 <doserj> > liftM2 (&&) not id True
01:59:06 <lambdabot>  False
01:59:20 <doserj> quicksilver: not exactly
01:59:39 <quicksilver> doserj: oh, misread
01:59:43 <quicksilver> Mr_Awesome: sorry, ignore me :)
02:00:26 <Sizur> :t (\a b -> uncurry (&&) . (a (&&&) b))
02:00:27 <lambdabot> forall t (a :: * -> * -> *) b c c' a1. (Arrow a) => ((a b c -> a b c' -> a b (c, c')) -> t -> a1 -> (Bool, Bool)) -> t -> a1 -> Bool
02:00:28 <Mr_Awesome> so, from what i can tell, i have no real reason to change what i have :)
02:00:49 <Mr_Awesome> Sizur: yeah, i see what youre doing, but thats sort of overkill
02:00:55 <quicksilver> Mr_Awesome: no, I agree.
02:01:15 <quicksilver> Mr_Awesome: what you're doing is a pattern many of us recognise but I don't have a way to write it more concisely :)
02:01:15 <Mr_Awesome> quicksilver: you agree with what?
02:01:23 <Mr_Awesome> ah, right
02:01:37 * quicksilver . o o O ( everything, just stop hitting me )
02:01:56 <Mr_Awesome> heh
02:02:06 <Mr_Awesome> well, ill just stick with what i have now, since it works :)
02:03:09 <gio123> does somebody knows free faxing service?
02:03:25 <Botje> :t on
02:03:27 <lambdabot> Not in scope: `on'
02:03:31 <Botje> ahh
02:03:40 <Mr_Awesome> \msg lambdabot :t \f g x -> f x && g x
02:03:43 <Botje> Mr_Awesome's combinator is often defined as `on` here
02:03:46 <Mr_Awesome> whoops
02:03:59 <Mr_Awesome> wrong slash
02:04:11 <Botje> hmm
02:04:17 * Botje notices the f & g
02:04:20 <Botje> not entirely :)
02:04:47 <Sizur> @pl \f g x -> f x && g x
02:04:48 <lambdabot> liftM2 (&&)
02:05:35 <Vq^> @. type pl on (+) f x y = f x + f y
02:05:35 <lambdabot> parse error (possibly incorrect indentation)
02:06:05 <ertai> is there a function to make a regex from a string that match exactly this string?
02:06:05 <Vq^> :/
02:06:14 <Cin> i'm using Data.Map and i want to use both `map` from Data.Map and from Prelude. how can i do this?
02:06:37 <Mr_Awesome> Botje: are you saying that `on` is equivalent to my (^&&^) ?
02:06:49 <doserj> import qualified Data.Map as M
02:06:53 <Botje> no, i'm still groggy and misread a y :)
02:07:04 <Sizur> > liftM2 (&&) (==1) (>0) 2
02:07:05 <lambdabot>  False
02:07:11 <Sizur> > liftM2 (&&) (==1) (>0) 1
02:07:11 <lambdabot>  True
02:07:26 <Vq^> Cin: check out the import instructions on http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
02:07:27 <lambdabot> http://tinyurl.com/34gle9
02:07:39 <Cin> oh, thanks
02:07:55 <Mr_Awesome> ah. well, i suppose liftM2 will do for now. thanks everyone :)
02:08:02 <Vq^> Cin: it describes how Data.Map and some other packages is supposed to be imported
02:08:08 <quicksilver> if you want to be really fancy you could overload 'map'
02:08:12 <quicksilver> but it's probably not worth it :)
02:08:28 <Vq^> map=fmap ?
02:09:05 <quicksilver> Data.Map isn't really a Functor
02:09:06 <quicksilver> afaik
02:09:28 <quicksilver> hmm. maybe it is a functor on the value side.
02:09:37 <quicksilver> :t Data.Map.map
02:09:37 <C-Keen> hm Control.Monad.Error does not let me define my own type to get handed to Left.... the Error instance always expects a String, the examples on the Control.Monad.Error page show custom error strings but still strings
02:09:38 <lambdabot> forall a b k. (a -> b) -> Data.Map.Map k a -> Data.Map.Map k b
02:09:48 <quicksilver> C-Keen: that's not true :)
02:09:54 <Cin> what on earth is a functor?
02:10:03 <scook0> I don't see why it wouldn't be a functor on the value side
02:10:23 <Vq^> Cin: a type on which you can "map"
02:10:23 <C-Keen> quicksilver: hm, then I don't get it
02:10:33 <quicksilver> C-Keen: calculateLengthOrFail [] = throwError EmptyString
02:10:40 <quicksilver> C-Keen: that is an example from that page
02:10:46 <quicksilver> C-Keen: the custom error is "EmptyString"
02:10:50 <quicksilver> that's not a String.
02:10:56 <quicksilver> it's a "LengthError"
02:19:13 <C-Keen> quicksilver: this only works because LengthError has a function strMsg :: String -> LengthError. What I want is that I can return a B.ByteString on error. But the compiler expects strMsg to be of type String -> a
02:20:24 <C-Keen> quicksilver: sorry to be that annoying but obviously I missed to grasp some essential concept here...
02:21:13 <doserj> C-Keen: define a function strMsg :: String -> B.Bytestring
02:21:31 <Sizur> is strMsg used in the context of fail?
02:22:00 <quicksilver> C-Keen: OK. Well strMsg is not important.
02:22:04 <doserj> @src Either fail
02:22:04 <lambdabot> fail msg      = Left (strMsg msg)
02:22:08 <quicksilver> C-Keen: it's extremely annoying, and not important.
02:22:24 <quicksilver> C-Keen: for the most part you can entirely ignore it and just use throwError.
02:23:04 <C-Keen> what's a good value to return then? strMsg a = "idontcare" ?
02:23:19 <quicksilver> C-Keen: the only point of strMsg, as doserj alludes, is to cope with the built-in "fail"
02:23:22 <C-Keen> doserj: aaah :)
02:23:33 <quicksilver> well, that's the wrong type
02:23:34 <Sizur> problem is haskell is too popular now to change the monad interface
02:23:43 <quicksilver> strMsg a needs to return a B.ByteString
02:23:59 <quicksilver> what it should return is entirely up to you
02:24:08 <quicksilver> I don't know what format constraints your ByteString has
02:24:17 <quicksilver> if it really isn't appropriate for you, you could just do
02:24:24 <C-Keen> now I got the idea
02:24:31 <C-Keen> thanks for bearing with me
02:24:34 <quicksilver> strMsg a = error "Please don't call strMsg on this Monad, kthxbyelol"
02:25:06 <Mr_Awesome> :t liftM2 (&&)
02:25:07 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
02:25:24 <Sizur> Mr_Awesome: it must be in the (->) monad
02:25:45 <Mr_Awesome> Sizur: right, how do i write that?
02:26:23 <Sizur> :t liftM2 (&&) .(.id)
02:26:24 <lambdabot> forall a. (a -> Bool) -> (a -> Bool) -> a -> Bool
02:26:39 <Mr_Awesome> i get an error when i write the type like that
02:27:10 <Sizur> just use the liftM in the functional context
02:28:20 <Mr_Awesome> well, i wanted to write convenience operators like (^&&^) = liftM2 (&&)
02:28:47 <Sizur> dont you want it to be more general than just for (->)?
02:28:51 <Cin> (^__^)
02:29:07 <Mr_Awesome> Sizur: touch√©
02:29:21 <Sizur> plus with liftM you can use other functions too
02:29:25 <Mr_Awesome> i dont know why i wanted to restrict it, heh
02:29:57 <Mr_Awesome> what do you mean, other functions?
02:30:13 <Mr_Awesome> isnt liftM for unary functions?
02:30:17 <Sizur> liftM2 (||), etc...
02:30:30 <Mr_Awesome> oh, right yeah. thats what i planned on doing :)
02:31:03 <Mr_Awesome> Cin: haha, is that a legal operator?
02:31:04 <Sizur> it just seems backward to me. from abstraction to the more concrete
02:31:28 <Mr_Awesome> what seems backward, restricting the type, or writing these functions?
02:31:34 <Sizur> the second
02:31:45 <Sizur> and the first :P
02:31:45 <Cin> mr_awesome: no :P
02:31:57 <Cin> i've not seen it anyhoo
02:32:03 <Mr_Awesome> Cin: darn
02:32:13 <quicksilver> > let (^__^) = (+) in 3 ^__^ 3
02:32:14 <lambdabot>  Parse error at ")" (column 10)
02:32:18 <quicksilver> Yeah, I think not
02:32:24 <quicksilver> _ isn't an operator char
02:32:28 <quicksilver> it's an identifier char
02:33:11 <Mr_Awesome> Sizur: well, its for convenience and clarity. my code will have a lot of this pattern in it, and its easier to understand (f ^&&^ g) than (liftM2 (&&) f g)
02:34:05 <Sizur> > let (&&^) = (+) in 3 &&^ 3
02:34:09 <lambdabot>  6
02:34:30 <Sizur> use that, where ^ stands for 'lifted'
02:35:14 <Mr_Awesome> ...i dont know what youre talking about
02:36:17 <Sizur> > let (&&^) = liftM2 (&&) in ((==1) &&^ (<2)) 1
02:36:18 <lambdabot>  True
02:36:59 <Mr_Awesome> &&^ makes it seem like only the right side is lifted though
02:37:16 <Sizur> well, it should mean the && is lifted
02:37:50 <Mr_Awesome> what does ^&&^ mean to you then?
02:38:04 <Sizur> anime face? ;)
02:38:09 <Mr_Awesome> haha
02:38:16 <Cin> broken nose but happy anyway
02:38:44 <Mr_Awesome> ^||^ is a good one
02:39:06 <Cin> so awesome. i've got this algorithm where i'm checking a set of columns. but i only want to do each one step at a time, so i'm returning a list of all the steps. because it's lazy i can just get the heads of the list ^_^
02:39:36 <Cin> strange, i missed out a whole sentence in that message. nevermind
02:39:55 <Mr_Awesome> hooray for lazyiness!
02:40:01 <Mr_Awesome> *laziness
02:40:07 <Cin> :D
02:43:46 <xpik1> > (Just 3) * (Just 4)
02:43:49 <lambdabot>   add an instance declaration for (Num (Maybe t))
02:43:49 <lambdabot>     In the expression: (Jus...
02:44:04 <Sizur> :t (<*>)
02:44:05 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
02:45:16 <Sizur> > liftM2 (*) (Just 3) (Just 4)
02:45:17 <lambdabot>  Just 12
02:46:52 <Sizur> > (*) <$> (Just 3) <*> (Just 4)
02:47:00 <lambdabot>  Just 12
02:48:02 <Sizur> > (*) <$> [3] <*> [4,5]
02:48:03 <lambdabot>  [12,15]
02:50:16 <Sizur> > (&&) <$> (==1) <*> (<2) <*> 1
02:50:18 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Bool'
02:50:32 <Sizur> > ((&&) <$> (==1) <*> (<2)) 1
02:50:33 <lambdabot>  True
02:53:52 <phlpp> :t <>
02:53:54 <lambdabot> parse error on input `<>'
02:54:20 <phlpp> > (*) $ (Just 3) (Just 4)
02:54:21 <lambdabot>  Couldn't match expected type `t -> a'
02:54:33 <xpik1> > Just 3 >>= guard . (>4)
02:54:34 <lambdabot>  Nothing
02:54:45 <phlpp> :t <$>
02:54:46 <lambdabot> parse error on input `<$>'
02:54:53 <phlpp> :t (<$>)
02:54:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:54:58 <xpik1> > Just 3 >>= guard . (>2)
02:54:59 <lambdabot>  Just ()
02:55:05 <xpik1> why coin?
02:55:08 <phlpp> :t ap
02:55:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
02:55:19 <Sizur> :t guard
02:55:20 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
02:56:06 <Sizur> xpik1: what do you want to do?
02:57:48 <Sizur> guard will simply fail or not fail, that's why the ()
02:58:12 <Sizur> @src guard
02:58:12 <lambdabot> guard True  =  return ()
02:58:12 <lambdabot> guard False =  mzero
02:58:33 <Sizur> @src mzero
02:58:33 <lambdabot> Source not found. My brain just exploded
02:58:39 <xpik1> > Just 3 >>= \x -> guard (x>4) >> return x
02:58:39 <lambdabot>  Nothing
02:58:47 <xpik1> > Just 3 >>= \x -> guard (x>2) >> return x
02:58:48 <lambdabot>  Just 3
02:59:39 <Sizur> > liftM (>2) (Just 3)
02:59:40 <lambdabot>  Just True
03:05:43 <mux> > (>2) <$> Just 3
03:05:45 <lambdabot>  Just True
03:06:53 <Sizur> > fmap (>2) (Just 3)
03:06:53 <lambdabot>  Just True
03:10:23 <xpik1> for (1+1)  == (1+1)  will GHC calculate 1+1 twice?
03:10:36 <Taejo> xpik1: probably
03:11:11 <xpik1> let x = (1+1)  in x == x better not
03:11:20 <Taejo> that's better
03:11:26 <Corun> That last one definitely doesn't.
03:11:48 <Corun> (Graph reduction and stufF)
03:12:06 <Taejo> as far as I remember, GHC doesn't do common sub-expression elimination
03:13:32 <quicksilver> only in a limited number of cases
03:14:06 <quicksilver> I believe let x = (1+1) in x == (1+1) will CSE
03:20:28 <ndm> quicksilver: why? what reason is it using to CSE there?
03:20:59 <quicksilver> ndm: it would eliminate the (1+1), I believe
03:21:09 <quicksilver> going to let x = (1+1) in x == x
03:21:09 <Japsu> http://kde.org/announcements/4.0/ \o/
03:21:15 <lambdabot> Title: K Desktop Environment - KDE 4.0 Released
03:21:25 <ndm> quicksilver: yep, but why? because 1+1 is an Int, or other reasons?
03:21:25 <quicksilver> i.e. it will only CSE something if the thunk already exists
03:21:34 <quicksilver> it will CSE an expression to a let binding
03:21:38 <quicksilver> but not create a new let binding
03:21:39 <quicksilver> AIUI
03:21:46 <quicksilver> this is "less likely" to cause space leaks
03:21:51 <ndm> hmm, i would have thought that could still space leak
03:22:11 <ndm> let x = repeat 'x' in x `foo` repeat 'x'
03:22:25 <ndm> now all you need to do is have foo iterate down one list for 10000000 elements, then the second
03:22:47 <ndm> foo x y = x !! 100000 == y !! 1000000 -- should o
03:24:15 <quicksilver> it can, yes
03:24:19 <quicksilver> I only said "less likely"
03:24:56 <quicksilver> it is reusing an existing thunk, but it may keep it live longer than it was going to be
03:26:24 * ndm thinks thats still quite dodgy
03:26:36 <ndm> Supero performs no CSE, on the basis it can't know its safe
03:26:54 <ndm> your original example is safe though, as Int takes a bounded amount of space
03:27:07 <ndm> just wondering if your reason for saying that was CSE was the Int or something else
03:27:11 <quicksilver> yes, I agree it's a bit dodgy.
03:27:17 <quicksilver> my reason wasn't the Int.
03:27:19 <qweqwe> what is wrong here ?
03:27:19 <qweqwe> merge1::Eq a =>[a]->[a]->[a]
03:27:20 <qweqwe> merge1 x [] = x
03:27:20 <qweqwe> merge1 [] x = x
03:27:20 <qweqwe> merge1 (x:xs) (y:ys) = if (x>y) then  y:merge1((x:xs) ys)
03:27:20 <qweqwe>                                    else x:merge1(xs (y:ys))
03:27:24 <quicksilver> I may be slightly wrong, myself, of course
03:27:33 <quicksilver> the GHC FAQ explains it slightly differntly to the way I explained it.
03:27:44 <quicksilver> qweqwe: (a) you pasted something too long in the channel
03:27:51 <funktio> qweqwe: merge1 x [] = [x]
03:27:52 <qweqwe> sorry
03:27:58 <doserj> @type (>)
03:27:58 <quicksilver> qweqwe: (b) you can't use > on x and y because they aren't Ord
03:28:05 <lambdabot> forall a. (Ord a) => a -> a -> Bool
03:28:09 <quicksilver> qweqwe: (c) what funktio said :)
03:28:17 <qweqwe> thanks
03:28:52 <doserj> erm, no (c)
03:29:08 <quicksilver> ah, no
03:29:10 <funktio> hmm, yes
03:29:10 <quicksilver> quite
03:29:14 <quicksilver> funktio was wrong ;)
03:29:16 <funktio> qweqwe: merge1 [x] [] = [x]
03:29:17 <quicksilver> ignore that bit
03:29:19 <funktio> is that right?
03:29:26 <quicksilver> what qweqwe had was right.
03:29:36 <quicksilver> but he's not naming his variables very consistently
03:29:37 <funktio> ok
03:29:42 <quicksilver> which is confusing ;)
03:30:07 <funktio> ah, I see now :)
03:30:09 <qweqwe> i still have error there
03:30:10 <funktio> I'm a beginenr
03:30:13 <doserj> maybe -Wall should report it :)
03:30:14 <funktio> beginner*
03:30:34 <qweqwe> and i only changed to ord there
03:30:59 <qweqwe> *** Expression     : (x : xs) ys
03:30:59 <qweqwe> *** Term           : (:)
03:30:59 <qweqwe> *** Type           : e -> [e] -> [e]
03:30:59 <qweqwe> *** Does not match : a -> b -> c -> d
03:31:30 <doserj> fix the parantheses in the then and else clauses
03:32:25 <qweqwe> ah yes
03:36:10 <C-Keen> hm how can I convert Word8 to an Int?
03:36:58 <doserj> @type fromEnum
03:36:59 <lambdabot> forall a. (Enum a) => a -> Int
03:37:31 <C-Keen> ah
03:38:46 <quicksilver> no, I don't think so
03:38:49 <quicksilver> fromIntegral
03:38:57 <quicksilver> hmm
03:38:57 <quicksilver> well
03:39:05 <doserj> > fromEnum (5::Word8)
03:39:06 <quicksilver> ok, you could use fromEnum but that just feels wrong :)
03:39:17 <lambdabot>  5
03:39:31 <quicksilver> fromEnum == fromIntegral for all the Integral types, I suppose.
03:39:38 <Taejo> @type fromIntegral
03:39:38 <lambdabot> forall a b. (Num b, Integral a) => a -> b
03:46:42 <resiak> If I use the 'stick char *ghc_rts_opts = "-N2" into a C file and link it with the rest of the program' trick, should I be on the lookout for dragons?
03:48:12 <quicksilver> resiak: I don't believe so, no. I think that one is guaranteed dragon-free
03:48:19 <quicksilver> it might not actually be dragon-repellent, mind.
03:48:48 <resiak> Heh!
03:49:00 <resiak> Hrm, it's also not going to do anything if I omit -threaded :/
03:51:13 <scook0> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-hooks
03:51:14 <lambdabot> Title: 5.14. Running a compiled program, http://tinyurl.com/d7dj4
03:51:24 <scook0> ghc_rts_options seems to be totally sanctioned
03:53:31 <C-Keen> now when I want to use another Monad's function within my Monad I am supposed to lift it right?
03:56:18 <scook0> C-Keen: generally speaking, yes -- assuming your monad is a transformation of that other monad
03:57:04 <resiak> yeah, i didn't see any documented potential disasters
03:57:10 <scook0> in the particular case of IO, you can use liftIO
03:57:26 <C-Keen> scook0: ah ok
03:57:26 <scook0> and for MonadReader/MonadWriter/MonadState et al. you shouldn't even need to lift
03:57:41 <scook0> C-Keen: what are the two monads in question?
03:57:48 <C-Keen> IO and Error
03:58:06 * resiak is reluctant to test whether -threaded has helped avoid terrifying deadlocked unkillable processes for fear of discovering that it has not :)
03:58:40 <C-Keen> scook0: I am 'inside' the Error Monad and want to print something to IO
03:58:59 <scook0> C-Keen: that may be tricky, depending on how you've defined Error
03:59:41 <scook0> if you just want debugging messages, you can use trace
03:59:45 <C-Keen> scook0: my last statement may be wrong, I am inside an Either type
04:01:18 <Botje> :t parse
04:01:20 <lambdabot> Not in scope: `parse'
04:01:26 <Botje> :t parseFromFile
04:01:27 <lambdabot> Not in scope: `parseFromFile'
04:01:31 <Botje> arg.
04:03:14 <resiak> so, who wants to write some magic haddock -> devhelp index transformation? :)
04:03:36 <quicksilver> C-Keen: you can't do IO from instance an Either type
04:03:44 <quicksilver> C-Keen: that is the great thing, and the pain, of the type system
04:03:56 <quicksilver> C-Keen: you can only do IO from inside the IO monad. Anywhere else its pure
04:04:12 <quicksilver> C-Keen: you choices are (a) work in the IO monad (perhaps using the 'ErrorT' transformer)
04:04:20 <quicksilver> (b) save the IO until later and do it from some outer code
04:04:23 <quicksilver> which is runnin the IO monad
04:06:43 <C-Keen> quicksilver: as I understood Monad transformations are just wrappers of needed monads around the current one to make the outer monad's functions usable
04:08:24 <quicksilver> yes
04:08:39 <quicksilver> so (ErrorT foo IO) a
04:08:50 <quicksilver> is like a "micture" of 'IO a' and 'Either foo a'
04:09:00 <quicksilver> allowing you to do IO stuff and clever exceptions, both
04:09:49 <Cin> hpaste: url
04:09:49 <hpaste> Haskell paste bin: http://hpaste.org/
04:10:08 <hpaste>  Cin pasted "why does my isWin look so ugly? ;_;" at http://hpaste.org/4926
04:11:31 <Cin> hmph
04:11:39 <scook0> Cin: ugh
04:11:53 <quicksilver> Cin: try = any (\m -> expand m 0 0 0 > 3)
04:11:56 <quicksilver> Cin: I believe
04:12:04 <quicksilver> >= rather
04:12:54 <Cin> ah, good one
04:13:01 <scook0> Cin: you can hoist let (xm,ym) into the LHS of expand
04:13:22 <quicksilver> scook0: well, he does reuse 'm' in the recursive call
04:13:29 <quicksilver> scook0: he could do m@(xm,ym)
04:13:34 <quicksilver> I don't know if that's better
04:14:16 <scook0> some of those functions should probably be pulled out into a where, or to toplevel
04:14:19 <quicksilver> Cin: I would probably write mods as [ (x,y) | x <- [-1..1], y <- [-1..1]] \\ [(0,0)]
04:14:30 <quicksilver> then it fits on one line
04:14:33 <scook0> they get in the way of the isWin function's logic
04:14:38 <quicksilver> fitting on one line is important to my simple brain :)
04:14:48 <Cin> hehe, thanks for the tip
04:15:10 <Cin> scook0: such as expand?
04:15:18 <quicksilver> giving 'x+xo' and 'y+yo' names might make that code readable
04:15:19 <Cin> it has a lot of arguments, too many imo
04:15:28 <Cin> hm, i'll try that too
04:15:35 <Cin> hang on, lemmie update what we have so far
04:15:55 <scook0> Cin: perhaps it would help to define some more concrete datatypes
04:16:15 <scook0> instead of using tuples and multiple-argument functions so much
04:16:36 <quicksilver> I htink tuples for coordinates are pretty intuitive
04:16:43 <Cin> oh, you mean for Grid and whatnot?
04:16:43 <quicksilver> and since they seem to be coords on a grid, I don't mind that
04:16:55 <quicksilver> the lx, ly, ux, uy stuff is presumably a bounds check
04:17:00 <quicksilver> you could make that into a function
04:17:01 <Cin> yeah
04:17:04 <quicksilver> I bet you'll need it elsewhere
04:17:24 <Cin> okay, good thinking
04:17:42 <scook0> if you had an inBounds :: Bounds -> (Int, Int) -> Bool function, that might help
04:17:48 <Cin> aye
04:17:53 <quicksilver> inBounds :: Grid -> (Int,Int) -> Bool; inBounds ((lx,ly),(ux,uy)) (x,y) == lx <= x && x <= ux && ly <= y && y <= uy
04:17:57 <quicksilver> I was just writing it ;)
04:18:01 <Cin> hehe
04:18:05 <Cin> slow down, guys! :P
04:18:10 <quicksilver> well, you asked :)
04:18:14 <Cin> hehe
04:18:27 <scook0> (that's the sort of thing I meant by defining new datatypes -- abstract away some of the nitty-gritty value-passing & logic)
04:18:45 <Cin> right!
04:18:50 <Cin> this is beginning to look far nicer
04:19:23 <Botje> why not use Data.Ix.inRange ?
04:19:26 <Botje> :t inRange
04:19:27 <Toxaris> > inRange ((2, 2), (5, 5)) (3, 7)
04:19:28 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
04:19:29 <lambdabot>  False
04:19:32 <Toxaris> > inRange ((2, 2), (5, 5)) (3, 3)
04:19:33 <lambdabot>  True
04:19:52 <Cin> oh lord :P
04:19:57 <yaxu> ok so i have a smallish amount of data to read in as XML
04:20:36 <yaxu> is it going to be easier to learn a haskell xml library, or convert it to a simpler format in another language and read that in?
04:20:56 <yaxu> perhaps convert it to xml straight into haskell with a quick perl script
04:21:19 <fadec> yaxu: haxml is pretty easy. I'm new and I figured it out
04:21:44 <yaxu> fadec: ok thanks i'll take a look
04:22:11 <ndm> yaxu: depending on how complex it is, tagsoup might suit you
04:22:25 <ndm> tagsoup is really easy to learn, but not nearly as powerful as something like haxml
04:23:07 <yaxu> it is pretty simple
04:23:58 <yaxu> tagsoup looks good, the author's name looks familiar too :)
04:24:19 <hpaste>  fadec pasted "for yaxu" at http://hpaste.org/4927
04:24:50 <fadec> yaxu: check out the hpaste to help get started
04:25:02 <yaxu> thanks fadec
04:25:12 <longlivedeath> quit
04:25:13 <yaxu> i guess i'll invest some time looking at both libraries
04:26:31 <ndm> yaxu: tagsoup doesn't deal at all with the nesting of elements, its more like a lexer for tags, than a complete parse tree - haxml does everything
04:27:40 <quicksilver> it's not very hard to write some weak nesting combinators for tagsoup though
04:27:42 <Cin> okay. think i have all that. plus i realised i didn't have to do "x+xo" all the time when i could just start xo as being == x..
04:27:44 <quicksilver> I know because I did it :)
04:28:13 <hpaste>  Cin annotated "why does my isWin look so ugly? ;_;" with "improvment" at http://hpaste.org/4926#a1
04:28:20 <yaxu> http://hpaste.org/4928 # i just want to read in this kind of data
04:28:47 <yaxu> hand drumming data
04:30:00 <quicksilver> you could do that easily with tagsoup
04:30:03 <quicksilver> since "nesting doesn't matter"
04:30:07 <quicksilver> for that kind of file
04:30:07 <Cin> i'm quite pleased with that code now
04:30:16 <quicksilver> you just want all the matrixrows after a given frame, etc
04:30:23 <yaxu> yep
04:32:51 <ac> does anyone know of a library for mp3 encoding?
04:33:17 <Zao> ac: I'd probably interop against lame.
04:33:28 <ac> Zao: what does interop mean?
04:33:40 <hpaste>  Cin annotated "why does my isWin look so ugly? ;_;" with "is using guards in this instance a bit silly?" at http://hpaste.org/4926#a2
04:33:44 <Zao> ac: Make a foreign call into a native library.
04:33:53 <Cin> hard to tell when and when not to use guards
04:34:25 <ac> Zao: ok. I figured that's what you meant. So you mean I'll have to write haskell bindings for it.
04:34:50 <scook0> Cin: guards seem like a win there
04:34:57 <ac> I know someone must have already done decoding, as there's a Haskell mp3 player in hackage
04:35:07 <scook0> I think ifs tend to be ugly
04:35:10 <Cin> scook0: ah, cool. what about the way i indented it?
04:35:37 <scook0> looks fine to me
04:35:39 <Cin> scook0: me too, i think. they seem kind of verbose, if that makes any sense
04:35:48 <scook0> though I usually ad an extra () around the LHS of a guard
04:35:49 <ac> I doubt Don is around though
04:35:57 <scook0> since the = has such low visual weight
04:36:03 <Cin> scook0: what is LHS?
04:36:10 <ac> Cin: Left Hand Side, right?
04:36:14 <scook0> left-hand side
04:36:15 <Cin> ahh, okay
04:36:44 <quicksilver> ac: no, not left hand side right. left hand side left!
04:37:01 <ac> oh, yeah
04:37:05 <scook0> see whether putting the = on the second line looks better or worse
04:37:14 <Cin> okay
04:37:17 <ac> ifs bug me too
04:37:45 <ac> in some cases ifs can be designed away
04:37:46 <scook0> left hand side, „Å≠? ;)
04:38:25 <ac> you just make your code more general, and the ifs disappear. That may or may not be a good thing.
04:38:30 <hpaste>  Cin annotated "why does my isWin look so ugly? ;_;" with "next line. added a bit of code that  needed adding (hadn't compiled with the guard)" at http://hpaste.org/4926#a3
04:39:10 <doserj> I would definitely use x@(xm,ym) there
04:39:20 <Cin> hehe, okay
04:39:25 <scook0> why not just use fst & snd?
04:39:26 <doserj> m@(xm,ym), sorry
04:39:29 <Cin> i wasn't sure of the @ syntax was "bad practise"
04:39:41 <scook0> expand m (c+1) (xo+fst m) (yo+snd m)
04:39:54 <scook0> seems more direct to me
04:40:06 <Cin> hm
04:40:26 <Cin> aye that looks quite nice
04:40:42 <scook0> I hate let almost as much as I hate if ;)
04:40:54 <hpaste>  Cin annotated "why does my isWin look so ugly? ;_;" with "looks about complete now?" at http://hpaste.org/4926#a4
04:41:05 * scook0 is a die-hard where fan
04:41:22 <Cin> heh, i used where originally, but then i had to pass more things to the function?
04:41:38 <Cin> specifically the 'y' i obtained from the case
04:41:53 <scook0> Cin: you've messed up a little
04:42:07 <scook0> change xm/ym to m
04:42:09 <Cin> ah, yes
04:42:10 <Cin> oops
04:42:42 <ac> lets have never bothered me
04:43:23 <scook0> perhaps it's just that I'm never quite sure how to indent them
04:43:28 <doserj> lets feel so SML...
04:43:45 <Cin> indeed. lets tend to make my code branch out across the screen..
04:43:56 <scook0> Cin: another minor thing: in mods, consider changing x/y to x'/y'
04:44:13 <Cin> ah, to distinguish?
04:44:17 <scook0> to avoid shadowing the y parameter, yeah
04:44:36 <scook0> y' makes it clear that you aren't using the param
04:44:53 <Cin> aye
04:45:49 <ac> you don't have to indent lets... or is that just in do notation?
04:46:09 <scook0> I just never know where to put the let and in keywords in non-monadic let
04:46:40 <Cin> what is this x@pattern notation called?
04:46:45 <scook0> and whether to put newlines before/after them
04:46:46 <ac> what's a monadic let?
04:46:49 <scook0> Cin: as-patterns
04:46:54 <Cin> ah, thanks
04:47:04 <Cin> considering using one for b,g
04:47:17 <scook0> ac: in a do-expression, you can write a let that doesn't have an in part
04:47:29 <scook0> (the in is implicitly the rest of the do)
04:47:39 <ac> scook0: and that's the only place? Wouldn't it be possible to do the same thing in any function?
04:48:00 <scook0> ac: it's part of the desugaring of do
04:48:09 <Toxaris> Cin: I would change expand m c x0 y0 to expand c x0 y0 and any (\m -> expand m 0 x y >= 3) mods to expand 0 x y `any` mods
04:48:14 <ac> scook0: right, sugaring would be required, but it would be good sugaring
04:48:22 <scook0> outside a do, a let without an in wouldn't make sense in general
04:48:29 <Toxaris> Cin: ehm, adn add some . (>= 3) :)
04:48:39 <ac> scook0: why not? Couldn't the in just be the rest of the block?
04:49:01 <doserj> I would define mods at the top-level, and call it directions or sth
04:49:04 <scook0> ac: "block"?
04:49:15 <ac> er, function
04:49:34 <ac> scook0: by block I meant the syntactic block defined by indentation
04:49:42 <quicksilver> let isn't an indentation thing, though
04:49:47 <quicksilver> the declarations part of it is
04:49:50 <quicksilver> but not the whole thing
04:49:51 <quicksilver> IYSWIM
04:49:59 <ac> oh
04:50:02 <scook0> ac: where declarations are similar to what you describe
04:50:06 <ac> I thought that might be the case, but I never understood that
04:50:07 <Cin> toxaris: how would expand get the 'm'?
04:50:13 <scook0> though they're placed after the main part of the definition
04:50:38 <doserj> Cin: define expand to take m as the last parameter
04:50:45 <Cin> ahh
04:50:55 <Toxaris> > let add x y = x + y in map (add 3) [1, 2, 3] -- Cin
04:50:58 <lambdabot>  [4,5,6]
04:51:13 <Toxaris> Cin: like this
04:51:24 <Cin> right
04:51:31 <doserj> then \m -> expand 0 x y m >= 3 === ((>=3).expand 0 x y)
04:52:02 <ac> I guess it makes sense, because everything after the in is just one function, so it's completely unambiguous
04:52:15 <ac> er, I should say "one value"
04:52:28 <Cin> doserj: i think i follow that
04:53:32 <Toxaris> Cin: and I would define a toplevel function getLine :: Grid -> (Int, Int) -> (Int, Int) -> [Player]
04:54:00 <yaxu> ok i just did this on the ghci prompt: text <- hGetContents file
04:54:07 <Toxaris> Cin: with getLine g (x, y) (deltax, deltay) the line of cells beginning at (x, y) and progressing in direction (deltax, deltay)
04:54:17 <ac> I think I spend 3x the time talking on #haskell than I do actually writing Haskell. I should break that habit.
04:54:18 <yaxu> and it echoed the contents of the file to the screen, which was pretty big
04:54:25 <quicksilver> ac: or perhaps "one expression"
04:54:29 <quicksilver> ac: but yes, that is the point.
04:54:32 <yaxu> how can i avoid that behaviour?
04:54:44 <quicksilver> there is an option for it
04:54:49 <quicksilver> I don't remember but I'm sure it's in the docs :P
04:55:03 <Toxaris> Cin: then your isWin can use something like (>= 3) . length . filter (== p) . getLine g (x, y) $ mods
04:55:20 <LoganCapaldo> text <- hContents file ; return () :p
04:55:58 <Cin> toxaris: i don't follow the bit about deltax and deltay. can you explain that?
04:55:59 <doserj> :set -fno-print-bind-result
04:56:10 <Toxaris> Cin: you called them mx and my
04:56:30 <Toxaris> Cin, ahm, xm and ym, whatever. the (-1, 0, +1) things
04:56:46 <yaxu> ta
04:57:14 <Toxaris> Cin: correctness question: does your function handles the placing of a mark between two existing marks of the same player correctly?
04:57:28 <Toxaris> Cin: (It obviously doesnt. should it?)
04:57:51 <gio123> what is deference between tree language and word language?
04:58:07 <Cin> toxaris: yes it does...
04:58:12 <quicksilver> trees don't speak, they just rustle their branches a bit
04:58:17 <scook0> harumph!
04:58:42 <Toxaris> but ents *can* speak, just very slowly
04:58:42 <Cin> toxaris: or it would. my original one did
04:58:51 <Cin> toxaris: humph
04:58:58 <scook0> gio123: you may need to rephrase your question
04:59:03 <ac> gio123: that is an odd question. I've never heard of such a distinction
04:59:09 <doserj> you learn sth new on #haskell everyday: http://en.wikipedia.org/wiki/Deference
04:59:09 <lambdabot> Title: Deference - Wikipedia, the free encyclopedia
04:59:35 <Toxaris> wasn't tree vs. word *regular* languages discussed yesterday?
04:59:43 <gio123> what is deference between regular tree language and regular word language?
05:00:27 <ac> Toxaris: I wasn't here yesterday, and #haskell is not the kind of channel where you keep up on the back log :-P
05:00:53 <Cin> toxaris: it's supposed to carry 'count' inbetween the 'expand' construct. so that if, say, i count 2 on the left, and one on the right, it will total to 3 and thus get three in a row. likewise for veritcal and the diagonals
05:01:33 <ac> gio123: do you mean "regular" as "spoken"?
05:01:44 <gio123> nooo
05:02:02 <Toxaris> ac: just wanted to give all information I have about regular tree / word languagse
05:02:21 <Toxaris> Cin: but c is initialized to 0 all over again
05:02:46 <Cin> toxaris: indeed. it's wrong at the moment. trying to figure how to change it without making it look horrible again
05:03:03 <ac> Does anybody here think it would be interesting to create a spoken version of Haskell that could be used with an audio interface?
05:03:07 <scook0> I'm guessing the difference is that a word language generates strings, whereas a tree language generates trees
05:03:21 <quicksilver> maybe a tree language is like an AST?
05:03:29 <quicksilver> while a word language is, well, what language normally means?
05:03:33 <ac> It would possibly useful for blind people
05:03:33 <quicksilver> but the terms are not familiar to me
05:03:47 <Toxaris> it's (word regular) language, and (tree regular) language
05:04:05 <Toxaris> at least I think so
05:04:22 <Toxaris> not regular (word language) and regular (tree language)
05:04:25 <ac> the Show class could be renamed to Speak ;)
05:04:39 <ac> er, type class I mean
05:04:46 <quicksilver> http://citeseer.ist.psu.edu/255817.html
05:04:47 <lambdabot> Title: Forest-regular Languages and Tree-regular Languages - Murata (ResearchIndex)
05:05:00 <quicksilver> but I've never heard of that terminology
05:05:53 <ac> ok, so nobody thinks it would be interesting :-/
05:06:19 <gio123> <Toxaris> yes
05:06:20 <quicksilver> ac: I missed your initial comment
05:06:25 <quicksilver> ac: blind people do use haskell
05:06:36 <quicksilver> ac: they use it with a screen reader, like with any other textual application
05:06:47 <quicksilver> The layout is a bit painful though...
05:07:04 <ac> quicksilver: hmm. you mean navigating written code using a screen reader?
05:07:43 <ac> quicksilver: perhaps simply creating a better audio interface for editing than a text editor plus a screen reader would be a lot more interesting
05:08:40 <C-Keen> hm, I defined type StreamIOMonad = ErrorT ByteString IO; type Stream = StreamIOMonad (Either ByteString (Int, ByteString))
05:09:03 <fons> hi all
05:09:17 <C-Keen> now when having Stream as a parameter I need to strip off IO first right? How do I do this?
05:10:08 <quicksilver> C-Keen: I don't think what you have defined is what you meant to define.
05:10:24 <C-Keen> quicksilver: probably :)
05:10:37 <ac> quicksilver: I still think it may be interesting to try to fashion a vocabulary and syntax that would be easy to speak and to listen to. It might not be very possible
05:10:37 <scook0> hmm, I'm trying to compile a module that has some foreign bindings
05:10:50 <scook0> and I keep getting "warning: implicit declaration of function ‚Äòget_wch‚Äô"
05:10:51 <quicksilver> C-Keen: that expands to Stream = (ErrorT ByteString IO) (Either ByteString (Int, ByteString))
05:11:00 <fons> I downloaded ghc 6.8.2 for OSX/Leopard and works nicely but I'd like to get the haddock documentation of the libraries and I don't seem to find a premade package in GHC's page
05:11:00 <scook0> which goes away if I use -fasm
05:11:08 <quicksilver> C-Keen: which has two layers of 'Either' in it
05:11:17 <scook0> anybody have any better suggestions for getting rid of the warning?
05:11:22 <C-Keen> quicksilver: I see
05:11:22 <fons> did anyone have the same problem?
05:12:17 <scook0> @where documentation
05:12:17 <lambdabot> I know nothing about documentation.
05:12:21 <quicksilver> C-Keen: unfortunately, I"m not quite sure what you do want :)
05:12:54 <scook0> fons: http://www.haskell.org/ghc/documentation.html perhaps?
05:12:55 <lambdabot> Title: The Glasgow Haskell Compiler
05:13:18 <fons> damn I'm totally blind
05:13:20 <C-Keen> quicksilver: I want to wrap the IO around my error monad
05:13:31 <fons> thanks scook0 and sorry for wasting your time
05:13:40 <scook0> ah, no problem
05:13:49 <quicksilver> C-Keen: probably type Stream = ErrorT ByteString IO is what you want
05:13:51 <ac> I think the trick would be to unambigously eliminate as many parens as possible
05:14:09 <ac> by adding vocabulary words like "$" except they would have speakable names of course
05:14:42 <quicksilver> ac: yes, there is definitely clever stuff which could be done
05:14:51 <quicksilver> ac: good screenreaders can do some of these things
05:14:55 <C-Keen> quicksilver: when having functions of that type then how do I strip off the IO part so I can access the inner monad?
05:15:00 <ac> quicksilver: question is, would it be useful in any way?
05:15:03 <quicksilver> ac: (they can substitute and transform without reading)
05:15:07 <quicksilver> before reading
05:15:23 <quicksilver> C-Keen: technically IO is the inner monad and ErrorT is the outer one
05:15:31 <quicksilver> C-Keen: to access the other one, you need do nothing
05:15:39 <quicksilver> to access the inner, IO, you need to do liftIO
05:15:57 <ac> quicksilver: I guess the obvious use would be code comprehension for blind people
05:16:13 <C-Keen> quicksilver: I get an error for foo:: Stream -> Stream :  `Stream' is not applied to enough type arguments Expected kind `??', but `Stream' has kind `* -> *'
05:17:25 <quicksilver> C-Keen: yes, because Monads always have a type parameter
05:17:48 <quicksilver> C-Keen: when you use "Either ByteString blah"
05:17:52 <quicksilver> your "blah" was the parameter
05:17:58 <quicksilver> it's the 'return value'
05:18:56 <ac> quicksilver: you mean substitute and transform _while_ reading?
05:18:59 <C-Keen> So I need to either have the right type in my definition: Stream bla -> Stream bla
05:20:02 <ac> quicksilver: hm. what I'm thinking of would basically be like syntax highlighting for the blind
05:24:21 <ac> quicksilver: you type something in, and if the syntax is correct, when your screen reader reads it back to you it would substitute all the punctuation for vocabulary
05:25:43 <ac> and if it wasn't, it would just say "blah blah left paren left paren blah blah dolar sign blah right paren whack l dash greater than blah"
05:26:15 <fadec> Which db libs should I use as a newbie? Hackage has a plethora.
05:27:59 <ac> fadec: in the spirit of the blind leading the blind, I'd sugest haskelldb
05:28:21 <Cin> lots of blind talk today, heh
05:29:48 <fadec> Looks like a choice between haskelldb and hsql - but there's also a haskelldb-hsql, an hsql-sqlite3, and a haskelldb-hsql-sqlite3. . .
05:29:51 * fadec barfs
05:29:59 <ac> what is the relation between hdbc and hsql?
05:30:15 <fadec> ac: good question
05:30:51 <hpaste>  C-Keen pasted "thanks for helping the monad dummy" at http://hpaste.org/4929
05:30:57 <ac> fadec: yeah, I think you should answer that before anything else. My totally uninformed guess is that they're both the same thing, but hsql is of course geared to SQL
05:30:58 <hpaste>  Toxaris annotated "why does my isWin look so ugly? ;_;" with "how I would go about it" at http://hpaste.org/4926#a5
05:31:57 <fadec> ac: I guess I'll start with the least dependencies.
05:32:05 <ac> fadec: that looks like haskelldb-flat
05:32:39 <ac> fadec: or maybe BerkelyDB
05:32:52 <ac> fadec: depending on your definition of dependencies
05:33:01 <fadec> ac: I think hsql + hsql-sqlite3
05:33:07 <litb> hello there
05:33:50 <scook0> C-Keen: you can't use the Left constructor any more
05:34:05 <scook0> because you're no longer using Either
05:34:09 <Toxaris> Cin: the point of my code is: all uses of if and case are hidden in takeWhile and filter, all uses of recursion are hidden in takeWhile, filter, map, iterate and length. so there is no complexity left for the program, all complicated language features are delegated to the libraries
05:34:18 <scook0> you may need to use throwError instead
05:35:04 <quicksilver> C-Keen: instead of Left, use throwError
05:35:09 <quicksilver> C-Keen: and instead of Right use return
05:35:13 <quicksilver> which you are already doing
05:35:17 <quicksilver> but I mention for completeness :)
05:35:26 <Cin> toxaris: aye, i follow
05:35:52 <ac> fadec: but it still depends on sqlite3, whereas haskelldb-flat doesn't depend on any external libraries
05:36:13 <Toxaris> Cin: and with some hope, there is a vector / matrix lib providing move, scale and sclice :)
05:37:27 <C-Keen> quicksilver: that was easy
05:37:37 <C-Keen> quicksilver: thanks so much for all this
05:38:08 <Toxaris> would it make sense to define [(0, 0), (1, 2) .. ] = [(0, 0), (1, 2), (3, 4), ...]?
05:38:50 <ac> fadec: anyway, let me know what your experience is, because my second to next project that I have lined up will involve some sort of database
05:38:55 <Toxaris> > take 5 $ zip [0, 1 ..] [1, 2 ..] -- maybe no need to do so
05:38:58 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5)]
05:39:08 <Toxaris> > take 5 $ zip [0, 1 ..] [0, 2 ..]
05:39:10 <lambdabot>  [(0,0),(1,2),(2,4),(3,6),(4,8)]
05:39:27 <hpaste>  Cin annotated "why does my isWin look so ugly? ;_;" with "says "True"" at http://hpaste.org/4926#a6
05:39:53 <fadec> ac: right now hsql build fails from cabal errors. Do you use archlinux by chance?
05:39:55 <ac> my next project involves sound synthesis and mp3 encoding. If you're doing really simple stuff, is it worth using the dsp library?
05:40:03 <Cin> toxaris: i'm not sure your algorithm is completely correct
05:40:09 <ac> fadec: Ubuntu
05:40:22 <quicksilver> C-Keen: np
05:40:53 <ac> simple stuff being averaging streams together and concatenating them. I can't imagine it would be worth using dsp
05:40:58 <quicksilver> Toxaris: the reason that tuples are not Enum instances is, that that would be an enumeration
05:41:06 <quicksilver> Toxaris: however, you could argue that something is broken.
05:41:18 <quicksilver> namely, it's not clear that ".." really belongs in the enum class
05:41:31 <ac> though I do want to be adding some sort of generated noise...
05:41:39 <quicksilver> there is the 'Ix' class for another way of ordering tuples
05:43:20 <Toxaris> quicksilver: oh I see. Enum is more then just enumFromTo & friends
05:43:21 <Cin> toxaris: does it read whole lines across the grid, and validates at least >3 of 'You'? it doesn't appear to account for gaps
05:43:41 <Toxaris> Cin: oh yes you're right
05:43:48 <quicksilver> Toxaris: yeah. It's a bit of a mess.
05:44:02 <quicksilver> Toxaris: I think it's an unwritten rule that Enum should be consistent with Ord.
05:44:10 <Cin> toxaris: would you have to change your code much? mine now accounts for gaps but it doesn't look very good
05:44:14 <quicksilver> Toxaris: and I don't think your suggestion would be. Or maybe it should.
05:44:22 <Toxaris> Cin: change filter (== p) to takeWhile (== p) to stop at the first wrong mark
05:44:33 <Cin> ah, good stuff
05:45:27 <qebab> takeWhile and dropWhile are awesome
05:46:14 <gio123> what is deference between regular tree language and regular word language?
05:47:22 <MyCatVerbs> :t compare
05:47:25 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
05:47:36 <ac> @src Ordering
05:47:36 <lambdabot> data Ordering = LT | EQ | GT
05:48:51 <MyCatVerbs> :t let { fum [a,b,c,ds] = (a,b,c):(fum ds); fum [a,b] = (a,b,[]); fum [a] = (a,[],[]); fum [] = ([],[],[]); } in (sortBy (\(a,_,_)(b,_,_)-> a `compare` b)) . fum . lines
05:48:52 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
05:48:52 <lambdabot>       Expected type: t -> [(t, t, t)]
05:48:52 <lambdabot>       Inferred type: [t] -> t1
05:49:13 <ac> the infamous infinite type
05:49:19 <MyCatVerbs> :t let { fum [a,b,c,ds] = (a,b,c):(fum ds); fum [a,b] = (a,b,[]); fum [a] = (a,[],[]); fum [] = ([],[],[]); } in fum
05:49:20 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
05:49:20 <lambdabot>       Expected type: t -> [(t, t, t)]
05:49:20 <lambdabot>       Inferred type: [t] -> t1
05:49:35 <ac> that's got to be my most hated type error
05:49:51 <ac> and no, I'm not arguing they should be allowed
05:49:58 <MyCatVerbs> :t let { fum [a,b,c,ds] = (a,b,c):(fum ds); fum [a,b] = [(a,b,[])]; fum [a] = [(a,[],[])]; fum [] = [([],[],[])]; } in fum
05:50:00 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
05:50:00 <lambdabot>       Expected type: t -> [(t, t, t)]
05:50:00 <lambdabot>       Inferred type: [t] -> t1
05:50:19 <MyCatVerbs> :t let { fum [a,b,c,ds] = (a,b,c):(fum ds); fum [a,b] = [(a,b,[])]; fum [a] = [(a,[],[])]; fum [] = []; } in fum
05:50:20 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
05:50:20 <lambdabot>       Expected type: t -> [(t, t, t)]
05:50:20 <lambdabot>       Inferred type: [t] -> t1
05:51:01 <Toxaris> MyCatVerbs: fum (a:b:c:ds) = (a, b,c) : fum ds
05:51:07 <MyCatVerbs> :t let { fum (a:b:c:ds) = (a,b,c):(fum ds); fum [a,b] = [(a,b,[])]; fum [a] = [(a,[],[])]; fum [] = []; } in fum
05:51:08 <lambdabot> forall a. [[a]] -> [([a], [a], [a])]
05:51:13 <MyCatVerbs> Ahhhh.
05:51:25 <MyCatVerbs> Toxaris: danke, silly me.
05:51:45 <MyCatVerbs> :t let { fum (a:b:c:ds) = (a,b,c):(fum ds); fum [a,b] = [(a,b,[])]; fum [a] = [(a,[],[])]; fum [] = []; } in (sortBy (\(a,_,_)(b,_,_)-> a `compare` b)) . fum . lines
05:51:46 <lambdabot> String -> [([Char], [Char], [Char])]
05:51:53 <ac> would you mind explaining what that does?
05:52:40 <MyCatVerbs> ac: rips up an input string into blocks of three lines, sorts them based on the first line.
05:53:00 <Toxaris> ac: fum ["1st", "2nd", "3th", "4th"] = [("1st", "2nd", "3th"), ("4th", "", "")]
05:53:01 <ac> cool
05:53:36 <quicksilver> grouping in that sense is useful
05:53:45 <quicksilver> I'm surprised it's not in the standard libs
05:53:50 <quicksilver> it's like the "opposite to concat"
05:53:59 <MyCatVerbs> ac: except that it's somewhat incomplete.
05:54:05 <quicksilver> although you need to tell it how to group (I'm thinking equal-sized chunks)
05:54:51 <ac> I think it's come up on this channel several times than a "chunking type" function should be in the standard libs
05:55:07 <Toxaris> chunks :: Int -> [a] -> [[a]]
05:55:14 <ac> s/than/that/
05:55:25 <ac> @index chunks
05:55:26 <lambdabot> bzzt
05:55:39 <ac> darn. not in there yet
05:55:42 <Toxaris> sortBy (comparing head) . chunks 3
05:56:00 <Toxaris> so much more haskellish
05:56:04 <ac> Toxaris: yeah that's SO much more readable than MyCatVerb's ;)
05:56:20 <Cin> toxaris: hm. i think i fully understand your code now. althouh i am a little distressed that i wouldn't have realised that scale, slice and move might be in a math library.
05:56:30 <litb> it doesn'T find the chunks function here
05:56:46 <Toxaris> litb: unfortunately, there isn't any.
05:56:54 <ac> litb: it's easy enough to write. it's a one liner
05:57:04 <Toxaris> litb: write it yourself using splitAt
05:57:05 <Cin> don't really feel like coding anymore, heh
05:57:05 <litb> what is it supposed to do?
05:57:06 <ac> litb: I've defined it myself in at least two programs
05:57:08 <quicksilver> ac: often you want the tuple version, of course, and that doesn't have a general type
05:57:14 <Cin> i'll go read some terry pratchett
05:57:19 <litb> split a list into sublists of size N ?
05:57:21 <quicksilver> ac: although you can do zip3 . transpose
05:57:26 <ac> litb: yeah
05:57:51 <ac> :t transpose
05:57:53 <lambdabot> forall a. [[a]] -> [[a]]
05:57:57 <Toxaris> Cin: well, move and scale are vector addition and scalar multiplication, but slice is more special
05:58:07 <ac> quicksilver: that's not exactly what I alway want
05:58:28 <MyCatVerbs> :t let chunks n list = let (foo,bar) = splitAt n list in foo : (chunks n bar) in chunk
05:58:30 <lambdabot> Not in scope: `chunk'
05:58:33 <quicksilver> ac: yeah, and it's not quite what I meant, either
05:58:34 <MyCatVerbs> :t let chunks n list = let (foo,bar) = splitAt n list in foo : (chunks n bar) in chunks
05:58:35 <lambdabot> forall a. Int -> [a] -> [[a]]
05:58:39 <quicksilver> ac: but what I meant isn't quite typeable :)
05:58:51 <Toxaris> Cin: I don't even know how it's called in linear algebra :(
05:58:57 <quicksilver> (\[a,b,c] -> zip3 a b c) . transpose
05:58:58 <quicksilver> is closer
05:59:03 <quicksilver> :t (\[a,b,c] -> zip3 a b c) . transpose
05:59:04 <lambdabot> forall a. [[a]] -> [(a, a, a)]
05:59:05 <MyCatVerbs> :t ap
05:59:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:00:16 <Toxaris> class HomTuple t where fromList :: [a] -> (t a, [a]);
06:00:22 <MyCatVerbs> > let chunks n list = let (foo,bar) = splitAt n list in foo : (chunks n bar) in unlines . concat . (sortBy (\a b->(head a)`compare`(head b))) . (chunks 3 . lines)
06:00:24 <lambdabot>  <[Char] -> [Char]>
06:01:25 <Toxaris> class HomTuple t a | t -> a where fromList :: [a] -> Maybe (t, [a]) because of (1) different kinds for different tuples and (2) too short input lists
06:01:35 <Toxaris> chunks = unfoldr fromList
06:02:58 <MyCatVerbs> :t transpose
06:03:05 <lambdabot> forall a. [[a]] -> [[a]]
06:03:06 <ac> :t unfoldr fromList
06:03:09 <Toxaris> :t sortBy (comparing head) -- MyCatVerbs
06:03:09 <lambdabot> Not in scope: `fromList'
06:03:10 <lambdabot> forall a. (Ord a) => [[a]] -> [[a]]
06:03:22 <MyCatVerbs> Toxaris: ohhhhh, oops.
06:03:31 <Cin> toxaris: what do you reckon to the speed of that function?
06:03:40 <Cin> toxaris: i was going to write a fairly stupid AI player
06:03:46 <MyCatVerbs> :t compring
06:03:47 <lambdabot> Not in scope: `compring'
06:03:50 <C-Keen> :t liftIO
06:03:51 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
06:03:54 <MyCatVerbs> Toxaris: that saves a bit of typing, heh.
06:04:03 <MyCatVerbs> :t comparing
06:04:05 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
06:04:08 <Toxaris> Cin: It should basically do the same computation steps as yours
06:04:14 <Toxaris> Cin: it's the same algorithm :)
06:04:30 <Cin> yours has a call to length :P O(n) operation!
06:04:48 <Cin> aye it seems to be the same algoritm
06:04:50 <Toxaris> Cin: oups. you're right
06:05:08 <Toxaris> Cin: but n will never be more then 5 in a running game
06:05:23 <Cin> hehe
06:05:25 <Toxaris> Cin: better: it will never be more then 3 in a running game
06:05:33 <MyCatVerbs> @index compring
06:05:34 <lambdabot> bzzt
06:05:37 <MyCatVerbs> @index comparing
06:05:38 <lambdabot> bzzt
06:05:44 <MyCatVerbs> Ahhhh, damn you.
06:06:02 <Toxaris> Cin: but you're right to avoid ((>= n) . length) in favor of ((== n) . length . take n)
06:06:21 <Toxaris> Cin: or (not . null . drop (n - 1))
06:06:27 <Cin> toxaris: hm, indeed
06:06:56 <Cin> nice and concise, that code
06:07:12 <ac> My definition is:
06:07:14 <ac> > let chunks n = takeWhile (not.null) . map (take n) . iterate (drop n) in chunks 4 "foobarbazblahaoeu"
06:07:15 <lambdabot>  ["foob","arba","zbla","haoe","u"]
06:07:25 <Toxaris> Cin: my version may be slower due to (:) cells being created
06:07:32 <MyCatVerbs> WTF. ghc -e keeps spitting "parse error on input ]" on an expression that does not contain the ] character anywhere within its body.
06:07:53 <Cin> toxaris: i'm quite good at writing concise code in scheme, i use library functions and whatnot. i'm still learning how to do it in haskell
06:08:30 <Toxaris> Cin: in that case, ask dons for better fusion :)
06:08:40 <Cin> hm?
06:08:46 <Cin> fusion?
06:08:52 <EvilTerran> MyCatVerbs, might the shell be expanding something?
06:08:54 <ac> Cin: talking about his list fusion library
06:08:57 <EvilTerran> *, $, or something?
06:09:05 <Cin> ahh
06:09:24 <Cin> oh god i can't stop eating these pringles
06:09:31 <Toxaris> Cin: fusion is the process of transforming a program wich operators over lazy data structures into a program with explicitly tail-recursive functions
06:09:46 <Cin> interesting
06:09:46 <Toxaris> Cin: in this case: automatically transform my version into your version
06:09:51 <Cin> yeah
06:10:15 <ac> Cin: My understanding was list fusion took a series of composed functions on infinite lists and made it more efficient
06:10:31 <ac> though I guess they don't have to be infinite
06:10:39 <Toxaris> ac: finite lists too
06:10:41 <MyCatVerbs> EvilTerran: ah, thank you, that was precisely it.
06:10:55 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4930
06:10:57 <ac> Cin: I actually installed it and used it once and it did make things a little faster ;)
06:11:06 <Cin> ac: cool!:D
06:11:06 <EvilTerran> ... but what was expanding to ']'? an environment variable?
06:11:08 <ac> Something like 10 or 20 % IIRC
06:11:15 <Toxaris> a simple fusion rule is something like  map f . map g   ~~>   map (f . g)
06:11:48 <ac> Cin: using it is simply a matter of importing it, and it redefines all the standard functions that operate on lists
06:11:49 <Cin> ah. straight-forward
06:12:24 <Cin> suave
06:12:29 <Toxaris> ac, Cin: there is list fusion for the Prelude and Data.List functions too, but the new library can fuse more expressions
06:13:05 <Cin> i'll have to try that out
06:13:14 <ac> For me, this brings up the question of how easy it is to create a "library" that actually changes how ghc compiles something, rather than simply suplying a module you can import?
06:14:01 <quicksilver> Toxaris: that's a funny definition of fusion
06:14:15 <Toxaris> excellent paper about the "new" list fusion system, shortly explaining old system too: http://www.cse.unsw.edu.au/~dons/papers/stream-fusion.pdf
06:14:25 <quicksilver> I think fusion is the elimination of intermediate datastructures
06:14:42 <quicksilver> I don't really think fusion is about tail-recursion per se.
06:14:51 <quicksilver> or, for that matter, laziness.
06:14:57 <quicksilver> fusion applies just as muh to strict lists.
06:14:58 <ac> Toxaris: thanks for the link
06:15:38 <Cin> it would be cool if (length (map ... could be transformed to some operation that works out the length at the same time as mapping..
06:16:00 <ac> interesting: "                                         by transforming list func-
06:16:03 <ac> tions to expose their structure, intermediate values are eliminated
06:16:05 <ac> by general purpose compiler optimisations
06:16:06 <Cin> thanks for the link
06:16:07 <ac> oops. sorry for formatting
06:16:10 <quicksilver> Cin: it can.
06:16:15 <Cin> quicksilver: woo!
06:16:28 <quicksilver> Cin: if length was defined as a "foldr" that would happen in GHC 6.6 even
06:16:48 <Toxaris> length . map f == length
06:17:05 <pejo> quicksilver, you wrote what I was thinking.
06:17:09 <Cin> i'm sure i saw something like this as a talk about haskell
06:17:28 <Cin> maybe it was by dons, i can't remember. i only had the slides
06:17:29 <ac> I love it how my Haskell code gets more efficient with each new GHC release
06:17:46 <quicksilver> Toxaris: true, but I assumed he was thinking of stuff like 'sum' as wel
06:17:52 <quicksilver> Toxaris: and just using length as an example ;)
06:18:47 <guenni> hello, is => a reserved string?
06:18:52 <EvilTerran> yes
06:18:57 <Cin> ohh
06:19:01 <Cin> toxaris: good point
06:19:08 <guenni> thx
06:19:20 <EvilTerran> guenni, it's used to mark a class context
06:19:34 <EvilTerran> context -> "Foo a => a -> a" <- type
06:19:46 <EvilTerran>                   ^^
06:19:52 <litb> that says "a is a instance of class Foo" , right?
06:20:06 <guenni> EvilTerran: ah, right
06:20:18 <Toxaris> => is used for superclasses too: class Super => Sub where ...
06:20:24 <EvilTerran> litb, "Foo a" means "a is of a type that instantiates class Foo", yes
06:20:31 <EvilTerran> er, s/of//
06:20:32 <guenni> zat is why it didn't work zen
06:20:32 <Toxaris> => is used for superclasses too: class Super a => Sub a where ...
06:20:48 <ac> What's the difference between a super class and a type class?
06:20:49 <quicksilver> that is also a class context
06:21:00 <ac> (I've never heard of a super class)
06:21:01 <quicksilver> ac: a superclass is a type class :)
06:21:10 <quicksilver> type classes can have superclasses
06:21:21 <EvilTerran> litb, the whole thing is the type of a function that takes a value of any type that instantiates Foo, and returns a value of the same type
06:21:23 <quicksilver> just like in C++
06:21:26 <quicksilver> well not really :)
06:21:26 <ac> quicksilver: I will refrain from thinking about that for the time being.
06:21:39 <ac> but that is good to know
06:21:52 <litb> ah, i see
06:22:07 <litb> EvilTerran: but the same type, not another type of class Foo ?
06:22:15 <Toxaris> litb: yes
06:22:18 <litb> alrite
06:22:33 <Toxaris> litb: (Foo a, Foo b) => a -> b
06:23:22 <ac> just out of curiosity, could somebody give an example of a type signature that uses a super class?
06:23:35 <quicksilver> ac: no
06:23:45 <quicksilver> ac: because it's class declarations that use superclasses
06:23:50 <quicksilver> ac: not type signatures
06:23:54 <quicksilver> ;)
06:23:58 <ac> ah
06:24:08 <quicksilver> ac:  as in the definition of Num: class (Eq a) => Num a where ....
06:24:09 <Cin> is there a special notation for talking about infix operators in module import lists?
06:24:20 <quicksilver> Cin: put () around then
06:24:21 <quicksilver> them
06:24:23 <Cin> i get syntax error when saying '!' for the Map library
06:24:25 <Cin> i tried that
06:24:27 <Cin> i get another error
06:24:40 <Cin> hang on
06:24:42 <Toxaris> Cin: import M (alphanumericName, (=!$%), anotherName )
06:25:03 <quicksilver> or if it's just one
06:25:07 <Cin> hm
06:25:10 <quicksilver> import Data.Map((!))
06:25:29 <Cin> ah
06:25:46 <Cin> thanks
06:26:43 <ac> it amuses me that you actually can have an operator named "=!%%"
06:27:16 * Cin has amibition for an ^_^ operator
06:27:19 <litb> insane
06:27:23 <ac> Cin: lol
06:27:31 <ac> Cin: any speculation on what it would do?
06:27:33 <quicksilver> you can do ^.^
06:27:34 <litb> what about a <3 operator ?
06:27:48 <funktio> or function: o_O
06:28:00 <Cin> ac: something cheerful
06:28:03 <notsmack> funktio: o_O
06:28:08 <ac> Cin: obviously. But more specific than that
06:28:23 <Cin> ac: perhaps uniting two data structures, with love
06:28:38 <ac> Cin: sort of like union for Data.Map
06:29:10 <ac> ok, somebody has to write a program with all of those defined
06:29:11 <litb> how would i make a partial application of the binary op - where the second number is given?
06:29:22 <litb> (-4) doesn't work
06:29:31 <funktio> -4 is a special case
06:29:37 <funktio> because it parses as a negative number
06:29:37 <ac> litb: yes, (-) is ugly
06:29:46 <Toxaris> > map (/ 2) [1..5]
06:29:49 <lambdabot>  [0.5,1.0,1.5,2.0,2.5]
06:29:55 <litb> funktio: yeah, that is the problem
06:29:55 <ac> litb: it's probably the most inconsistent part of Haskell syntax I've discovered
06:29:56 <scook0> > map (subtract 1) [1..4]
06:29:56 <Toxaris> > map (subtract 2) [1..5]
06:29:56 <lambdabot>  [0,1,2,3]
06:29:57 <lambdabot>  [-1,0,1,2,3]
06:29:57 <notsmack> litb: subtract
06:30:03 <litb> ah
06:30:52 <daf> funktio: - is not just a number prefix, it's a unary function
06:31:14 <funktio> daf: ah, ok
06:31:23 <notsmack> daf: really?
06:31:28 <quicksilver> tup
06:31:32 <daf> > -(2 + 2)
06:31:33 <quicksilver> which makes it even worse
06:31:33 <lambdabot>  -4
06:31:38 <notsmack> gotcha.
06:31:41 <shapr> hi daf
06:31:46 <daf> shapr: hola
06:31:46 <quicksilver> I could just about live with it if it was only a number prefix
06:31:49 <shapr> daf: Will you be there tomorrow?
06:31:55 <daf> shapr: wrong continent, sorry
06:31:58 <shapr> Oh, too bad.
06:31:59 <quicksilver> but unary function, defying all the lexical rules of haskell for no good reason
06:32:02 <quicksilver> that's just horrible
06:32:06 <Toxaris> > map (+ (- 2)) [1..5] -- another option
06:32:06 <daf> shapr: wrong Cambridge, even :)
06:32:09 <lambdabot>  [-1,0,1,2,3]
06:32:12 <ac> quicksilver: I totally agree
06:32:25 <shapr> daf: Sucks.. and I bet I didn't meet you when I was in the other Cambridge.
06:32:46 <daf> shapr: hmm, my memory is really bad
06:32:47 <ac> is there anyway to have a non symbol character in an operator name other than `foo`?
06:33:02 <ac> so you can define things like "4 <3 5"?
06:33:04 <shapr> daf: Were you at AngloHaskell?
06:33:09 <daf> shapr: nope
06:33:17 <shapr> I probably didn't meet you then.
06:33:17 <daf> shapr: I didn't even hear about that
06:33:25 <daf> darn
06:33:28 <shapr> Well, it was organized in very short notice.
06:33:50 <quicksilver> ac: no.
06:34:07 <quicksilver> ac: the rule is simple. And I quite like the simplicity if not for the fact than - breaks it
06:34:11 <Toxaris> :t let (<¬≥) = undefined in 4 <¬≥ 3
06:34:13 <lambdabot> parse error on input `)'
06:34:16 <ac> too bad parens are out too. "foo :) bar" would be cool
06:34:38 <quicksilver> ac: there is a lexical class for normal (prefix) functions and one for infix operators
06:34:41 <oerjan> @version
06:34:41 <ac> Toxaris: my term does not support unicode it seams
06:34:42 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
06:34:42 <lambdabot> darcs get http://code.haskell.org/lambdabot
06:34:51 <daf> shapr: I'm actually in Cambridge MA fairly often
06:34:58 <quicksilver> ac, Toxaris: lambdabot can't read UTF8
06:35:24 <shapr> daf: Cool, let's meet up for food/drink/whatever.
06:35:42 <daf> shapr: I'll let you know when I'm in town :)
06:35:50 <shapr> I want to start a Haskell user group in Somerville.. HUGS.
06:35:52 <shapr> Spiffy!
06:35:54 <ac> When will you be able to write Haskell source in unicode, or can you already?
06:36:15 <shapr> daf: Do I also know you from the Python community possibly?
06:36:35 <ac> It would be fairly simple to implement... all you have to do is define "symbol character", and maybe a few other things I'm not thinking about
06:36:47 <ac> "upper case" is already well defined by unicode libs
06:36:53 <litb> have some of you taken part of the functional programming contest?
06:37:12 <daf> shapr: hmm, unlikely
06:37:24 <Toxaris> ac: my ghc accepts unicode
06:37:35 <ac> Toxaris: which version is that?
06:37:43 <shapr> daf: ok
06:37:44 <daf> shapr: I haven't really hung out with Python people a lot
06:37:50 <Toxaris> ac: The Glorious Glasgow Haskell Compilation System, version 6.8.1
06:37:59 <Adis> greetings
06:38:03 <daf> shapr: perhaps the most likely vector for my meeting you is Mako
06:38:04 <shapr> bok Adis
06:38:04 <ac> Toxaris: sweet. Is that new in 6.8?
06:38:13 <shapr> daf: I haven't met Mako.
06:38:14 <daf> shapr: or OLPC, if you've had anything to do with that
06:38:14 <Toxaris> ac: i have no idea
06:38:23 <daf> shapr: ok, we probably haven't met then
06:38:24 <shapr> daf: But I do know cjb, though never met.
06:38:39 <daf> shapr: ah, cjb is cool
06:39:27 <Toxaris> ac: i don't use it :) what's the point of using characters not on my keyboard?
06:39:54 <Adis> I was wondering, can anyone be kind enough to point me to a BNF grammar for Haskell?
06:40:05 <quicksilver> ac: you've been able to write haskell in unicode for yonks
06:40:15 <quicksilver> ac: it's lamdbabot that has the limitation, not ghc
06:40:37 <quicksilver> 6.6 accepted unicode source, I suspect much older versions too.
06:41:20 <Toxaris> Adis: http://www.hck.sk/users/peter/HaskellEx.htm
06:41:39 <ac> according to a blog I just stumbled accross, 6.6 is where unicode support for source was added
06:41:50 <Toxaris> Adis: http://www.haskell.org/onlinereport/
06:41:51 <lambdabot> Title: The Haskell 98 Language Report
06:42:14 <quicksilver> ah, fair enough
06:42:21 <ac> Toxaris: I just think it would be cool to write Hangul and Japanese function names
06:42:25 <Adis> Toxaris: thanks, I've tried using those, but I need something suitable for YACC or happy
06:43:12 <ac> Toxaris: I don't pay attention to the characters written on my keyboard anyway
06:43:22 <quicksilver> Adis: is there a reason that Language.Haskell isn't good enough for you?
06:44:04 <ac> Toxaris: I haven't used qwerty for well over a decade
06:44:28 <Toxaris> ac: and what do you use instead?
06:44:33 <ac> Toxaris: dvorak
06:44:38 <shapr> Me too!
06:44:46 <shapr> I've been using dvorak since 1992.
06:44:54 <ac> shapr: you have me beat I think
06:45:02 * shapr shrugs
06:45:06 <ac> shapr: I was 7 then :-P
06:45:10 <shapr> bah
06:45:12 <Cin> i got my first computer in 1997 >_>
06:45:27 <shapr> My first computer was a Spectrum Sinclair :-/
06:45:37 <Cin> old person is old
06:45:43 <ricky_clarkson> shapr: A Sinclair Spectrum.  Noob.
06:45:44 * shapr waves his cane
06:45:51 <shapr> ricky_clarkson: What was your first computer?
06:45:57 <ricky_clarkson> The same.
06:45:59 <shapr> oh
06:46:02 <shapr> noob!
06:46:13 <ricky_clarkson> I was just being silly because you got its name the wrong way around.
06:46:22 <shapr> Bah
06:46:33 * shapr throws spiky lambdas at ricky_clarkson 
06:46:49 <ricky_clarkson> GOTO 42
06:47:25 * ac speculates #haskell has the highest density of nerds in the Internet
06:47:39 <ac> s/nerds/nerdiness/
06:47:41 <Toxaris> higher order nerds
06:47:57 <Toxaris> and even some co-nerds
06:48:06 <shapr> So that's what she means when she says "Hi, HON"
06:50:04 <shapr> hej bringert
06:50:07 <myname> :pl \x -> a (b x) c
06:50:12 * ac aspires to become a co-nerd
06:50:13 <shapr> bok gour
06:50:24 <bringert> hej shapr
06:50:35 <Toxaris> @pl \x -> a (b x) c
06:50:36 <lambdabot> flip a c . b
06:51:07 <gour> shapr: bok, what's new?
06:51:22 <shapr> Code is good!
06:51:25 <gour> shapr: still in use?
06:51:26 <shapr> What's new with you?
06:51:32 <shapr> gour: Sort of...
06:51:52 <gour> shapr: i'm ill a bit, code is none, but we hope for a better
06:52:10 <gour> shapr: i meant, still in usa?
06:52:11 <shapr> Oh, I'm sorry to hear that. I hope you feel better soon.
06:52:15 <shapr> Oh yes.
06:52:17 <shapr> Permanently now.
06:52:23 <gour> some dry coughing...
06:52:29 <shapr> I moved from Alabama to Boston, MA.
06:52:37 <gour> when will you visit eu?
06:53:06 <shapr> Probably not for a long time. But Zagreb is my next EU destination :-)
06:53:15 <gour> i moved to emacs (from vim), if this can be called improvement :-)
06:53:26 <shapr> I think each choice has its benefits.
06:53:33 <gour> shapr: good, good...still single?
06:53:48 <shapr> Sadly, yes.
06:54:07 <shapr> But I'm meeting lots of new people in Boston!
06:54:10 <gour> shapr: ohh, then you should visit cro sooner ;)
06:54:12 <shapr> Mostly male programmers though.
06:54:15 <shapr> hah, yes!
06:54:26 <gour> not for she-programmers though :-)
06:55:03 <gour> shapr: you code haskell for living now?
06:56:01 <shapr> Nah, I switched jobs, I code C# for a living now.
06:56:20 <gour> is it tolerable?
06:56:31 <shapr> Yeh, lots of smart people to work with.
06:56:35 <gour> you were working on happs?
06:56:49 <Lycurgus> shapr: you weren't with Galois?
06:57:19 <Lycurgus> at a uni, no?
06:57:58 <shapr> gour: Yeah
06:58:02 <shapr> Lycurgus: No, neither.
06:58:35 <shapr> Lycurgus: Are you at uni?
06:58:51 <Lycurgus> no, I'm free. Completely.
06:58:59 <shapr> Even I can afford that!
06:59:06 <shapr> Do you have a programming job?
06:59:26 <Lycurgus> yes, but I'm self-employed.
06:59:49 <Lycurgus> I've never done anything else as an adult.
07:00:05 <ac> Lycurgus: cool, does your self employment envolve writing Haskell?
07:00:55 <Lycurgus> yes, but only for myself at this point. That's why I asked about Galois.
07:01:42 <gour> realworld haskell blog says "We‚Äôve completed the first draft of 13 of the book‚Äôs chapters". is it all, or how many chapters are supposed to be there?
07:02:21 <ac> Lycurgus: I see. I was hoping to ask if you ever felt overwhelmed writing all that Haskell code...
07:02:50 <myname> @pl \x y z -> f y (splitAt x z)
07:02:51 <lambdabot> flip ((.) . f) . splitAt
07:04:22 <Lycurgus> ac: I've been programming for more than 30 years. It's not that easy to overwhelm me at this point.
07:04:30 <ac> my next job is either going to be another very small startup, or some sort of Haskell programming ;)
07:04:32 <puusorsa> ..so, you know cobol? :)
07:04:55 <litb> > map (+$-2) [1..5] -- another option
07:04:57 <lambdabot>   Not in scope: `+$-'
07:05:07 <ac> heh
07:05:15 <litb> oops
07:06:11 <ac> (and if I'm lucky, both)
07:06:41 <oerjan> litb: (+ $ - 2) is not a legal section, because of precedence
07:07:15 <Lycurgus> puuorsa: me? Yes, I have of course used COBOL, though never was anyplace where it was the only thing. Was systems programmer in Burroughs shop and the app programmer used COBOL ...
07:07:33 <litb> @src $
07:07:34 <lambdabot> f $ x = f x
07:07:52 <ac> litb: it simply has a different precedence than " "
07:08:02 <litb> hm that looks like it would be a definition of an infix op
07:08:09 <Lycurgus> but I used Algol and only used COBOL to interface with the apps. Similar experiences other places including once parsing COBOL at Dunn and Bradstreet.
07:08:12 <litb> since the $ is in the middle of f and x
07:08:17 <oerjan> litb: correct
07:08:40 <Toxaris> > map ((+) $ (- 2)) [1..5] -- litb: has to be written like this
07:08:42 <lambdabot>  [-1,0,1,2,3]
07:08:44 <ac> :info ($)
07:08:56 <litb> i tried doing so the other day and it complained "infinite definition of f " or the like
07:08:57 <ac> @info ($)
07:08:57 <lambdabot> ($)
07:09:10 <oerjan> ac: @info -> @undo
07:09:23 <oerjan> deceptive spelling correction
07:09:32 <litb> ah, Toxaris
07:09:38 <ac> oerjan: huh? What's @undo do?
07:09:40 <Toxaris> > let f $ x = "money money money" in 27 $ 42
07:09:42 <lambdabot>  "money money money"
07:10:06 <Toxaris> litb: not problem to define infix ops. your "infinite definition" must be some other problem
07:10:06 <oerjan> @undo do { x <- test; putStr x; return (x++"hi") }
07:10:07 <lambdabot> test >>= \ x -> putStr x >> return (x ++ "hi")
07:10:17 <litb> i did it like this:
07:10:32 <ac> oerjan: cool! I was wanting that earlier today
07:10:32 <litb> let f q x = "money money money" in 27 q 42
07:10:38 <litb> > let f q x = "money money money" in 27 q 42
07:10:39 <lambdabot>   Not in scope: `q'
07:10:41 <oerjan> also:
07:10:49 <oerjan> @redo test >>= \ x -> putStr x >> return (x ++ "hi")
07:10:49 <lambdabot> do { x <- test; putStr x; return (x ++ "hi")}
07:10:51 <litb> now i get another error...
07:11:00 <myname> @pl \c (a, b) -> a ++ c (head b) : tail b
07:11:00 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (++)) . (`ap` tail) . ((:) .) . (. head)
07:11:09 <ac> oerjan: man, lambdabot has all sorts of features that should simply come packaged with ghci
07:11:14 <litb> or is a op only allowed to ne a nonalphanumeric character?
07:11:37 <ac> litb: operators must be all symbol characters
07:12:08 <oerjan> litb: not quite
07:12:24 <ac> litb: or in the form of `foo` where foo is a normal prefix function
07:12:26 <oerjan> > let f `q` x = "money money money" in 27 `q` 42
07:12:29 <lambdabot>  "money money money"
07:12:29 * litb wonders what a symbol character is
07:12:35 <fadec> ac: the darcs version of haskelldb seems to work. Looks to me like most of the other hackages are included in it e.g. it exposes Database.HaskellDB.HSQL.MySQL. Hackage is WAY out of date here.
07:12:39 <litb> oerjan: ah, nice workaround
07:13:09 <ac> fadec: good to know
07:13:12 <ac> fadec: thanks
07:13:31 <oerjan> litb: and (+) for the opposite
07:13:54 <ac> fadec: have you looked in to hsql yet?
07:14:32 <fadec> ac: I only tried to compile the hackage version of hsql. No luck.
07:14:47 <ac> fadec: ah ok, but not the darcs version yet
07:14:50 <oerjan> ac: there's ghc-on-acid although it is hard to install
07:14:57 <fadec> ac: but haskelldb exposes modules that have HSQL in the name
07:15:16 <oerjan> don't know if it works with 6.8 yet
07:15:16 <ac> oerjan: what else does ghc-on-acid come with other than an improved ghci?
07:15:23 <oerjan> ac: lambdabot
07:15:24 <fadec> ac: I think haskelldb might have eaten up the other projects from the looks of it.
07:15:45 <fadec> s/eaten up/consolidated
07:15:54 <ac> fadec: that would make sense, considering there's a haskeldb-hsql lib
07:16:30 <fadec> ac: that and the fact that while the hackage haskelldb is on ver 0.1, the darcs version claims 0.9
07:16:59 <ac> fadec: did you figure out what hdbc is?
07:17:15 <fadec> ac: guess odbc??
07:17:16 <fadec> no
07:17:43 <fadec> ac: docs say it is an  "HDBC interface for HaskellDB"
07:18:15 <ac> fadec: huh. I guess when I get to my second to next project I'll probably use haskeldb-hsql-sqlite3 then
07:18:38 <ac> fadec: but I assume the sqlite3 part will be simply configuration
07:19:01 <fadec> ac: Just get the darcs version of haskelldb. It includes all that other stuff.
07:19:17 <ac> fadec: ok. Are you using 6.6 or 6.8?
07:19:30 <fadec> ac: 6.8
07:19:41 <fadec> ac: haskelldb exposes Database.HaskellDB.HSQL.SQLite3, among others.
07:19:42 <ac> fadec: I'll probably upgrade to 6.8 while I'm at it
07:21:02 <litb> is ghc a gcc frontend?
07:21:20 <daf> no
07:21:31 <daf> it does its own code generation
07:21:44 <fadec> ac: I'm just getting into haskell. Never used 6.6. All I know is that everything on hackage is broken and the script I initially made to make an archlinux build package from a hackage package is almost useless.
07:22:31 <ac> fadec: huh. That MAY be because you're using 6.8. I've found little to be broken with 6.6
07:22:31 <litb> fadec: beware that 6.8.1 has bugs on archlinux
07:23:13 <ac> fadec: but I've largely stuck to common libraries like OpenGL and whatnot
07:23:31 <litb> are there games written in haskell?
07:23:39 <ac> litb: a few
07:24:01 <litb> more than lisp games?
07:24:12 <Philippa> no, but lisp is decades older
07:24:14 <ac> litb: I doubt it. lisp has been around longer
07:24:15 <litb> anyway, stupid question =)
07:24:31 <litb> lets seee what games there are for haskell...
07:24:44 <Philippa> I'm not aware of any "mainstream" game industry use of haskell in code the player runs
07:24:53 <fadec> litb: There was an opengl game engine which was pretty cool
07:25:00 <Philippa> (I've a feeling I've heard of it being used for tools)
07:25:15 <ac> litb: there's frag, and I saw a talk about an engine that looked interesting. not sure how complete it is
07:25:40 <litb> i'm sure it wouldn't be easy to write a game with haskell?
07:25:44 <ac> litb: there are simple games like xanqiboard
07:25:45 <pejo> Philippa, holler if you figure out what tools it is. I share that feeling with you.
07:26:31 <fadec> fadec: that's it. frag. http://www.haskell.org/haskellwiki/Frag
07:26:33 <lambdabot> Title: Frag - HaskellWiki
07:27:10 <fadec> Frag was cool but the demo was unstable for me. Froze after 3-5 minutes.
07:27:14 <ac> litb: I've written a couple simple graphics programs that use OpenGL and it was pretty painless
07:27:54 <ac> litb: but of course building a big virtual world is a whole different story. I wouldn't know what to say about the difficulty of that
07:29:13 <litb> i've heard that the future is functional programming, since it allows for far more parallelism
07:29:34 <cjb> litb: yes, that's what people said in 1960.  :)
07:30:12 <litb> oh =)
07:30:28 <ac> litb: I read a blog of a guy whining about how it's a pain to write a virtual world of interacting objects in a purely functional language [Haskell]. He may or may not have been skilled at Haskell.
07:31:09 <ac> can't remember who wrote it, and they may in fact be in this channel now
07:31:28 <ac> (if so, I mean no offence by my use of "whining")
07:33:02 <ac> His argument was that objects are a natural way to model such a thing. There is an OO library for Haskell, though I've never used it
07:33:26 <litb> oh, nice: http://video.google.co.uk/videoplay?docid=9139666903029663537&hl=en-GB
07:33:30 <lambdabot> Title: Games in Haskell, http://tinyurl.com/2bae7n
07:40:42 <Philippa> ac: something object-like is natural, yes - you'll end up with things that smell like extensible records with "behaviour" fields
07:40:58 <Philippa> but doing something akin to FRP is nice and much harder in other langs
07:41:04 <Philippa> the combination is something fairly new
07:42:27 <ac> Philippa: I was certainly not convinced that pure functionalism is discordant with simulation, and neither was the author actually. He just didn't know a good solution
07:43:29 <ac> litb: do you have a cool idea for a game in mind?
07:44:15 <litb> hm, no, ac
07:44:21 <Philippa> OO isn't necessarily that great for continuous sims anyway
07:44:54 <pejo> ac, that blog sounds like Erik Kidd (sp?). He had a presentation at CUFP or ICFP this year about what they do iirc. (Experience report thing).
07:45:04 <shapr> Eric Kidd I think.
07:45:13 <shapr> Hej pejo!
07:45:14 <fadec> ac: there's a little more to it. http://haskelldb.sourceforge.net/getting-started.html
07:45:14 <lambdabot> Title: HaskellDB - Getting Started
07:45:23 <pejo> Ah. Sorry for butchering the spelling of your name Eric. :-)
07:45:26 <pejo> Heya shapr!
07:45:32 <shapr> @seen ekidd
07:45:32 <lambdabot> I haven't seen ekidd.
07:45:34 <shapr> bah
07:46:14 <ac> shapr == Eric ?
07:46:42 <shapr> Nah, I'm Shae Erisson.
07:46:51 <shapr> I think Eric Kidd is ekidd on #haskell
07:47:19 <shapr> ac: If you use /whois shapr (or other irc nickname) the Real Name is sometimes correct.
07:47:22 <pejo> Philippa, for the record, I doubt he's advocating "Everything is an object". He's saying they would be useful to model some things.
07:48:32 <ac> shapr: suppose I should've whoised you before I asked.
07:48:50 <ac> fadec: thanks for the link
07:48:54 <shapr> ac: Just a suggestion :-)
07:49:53 * ac thinks it would be fun to write a little script that whois's everybody in an irc channel and maps out their IPs to a google map
07:50:19 <ac> well, writing the script would be a pain, but running it would be amusing
07:50:43 <shapr> ac: You could do it in Haskell. Go for it!
07:50:51 <shapr> There's a geoip library, yeah?
07:50:52 <ac> shapr: too bad I have three other programs I want to write more
07:50:57 <shapr> Heh, ok.
07:51:01 <ac> shapr: I'm sure you could find a web service
07:51:11 <shapr> Yeah, but I was thinking of how to do it as a quick hack.
07:51:36 <ac> shapr: it should be a lambabot feature (somehow)
07:51:42 <Botje> yeah
07:51:46 <Botje> you could just group people by continent
07:52:03 <Botje> I think that'd be pretty representative :)
07:52:10 <ac> huh, does lambdabot have a web interface?
07:52:19 <Botje> no(t yet)
07:52:23 <ac> Botje: you can do way better than that. Why not by city?
07:52:43 <Botje> because a list of cities wouldn't be very interesting
07:52:44 <oerjan> Botje: i think that's no(t anymore)
07:52:53 <oerjan> as in there's one which is broken
07:52:56 <Botje> oerjan: no(t yet again) ? :)
07:53:03 <ac> Botje: oh, I was imagining somehow rigging it to a google map
07:53:07 <Botje> ac: a list of countries would be doable
07:53:17 <quicksilver> I think the good geoip databases all cost money?
07:53:21 <Botje> ac: .. while we wait for some kind soul to fix the webinterface ;)
07:53:27 <quicksilver> unless you try to do something by screen-scraping google.
07:53:28 <ac> Botje: yeah, than it would be much easier to implement in lambabot now
07:53:48 <shapr> lispy wrote a web interface for lambdabot.
07:54:01 <ac> quicksilver: huh. I know of several websites that do it to you for free with ads. You could just parse the crap away
07:54:01 <Botje> quicksilver: you could do IP lookups to grab the ARIN / RIPE / whatever ID, and extract at least the country from that
07:54:24 <quicksilver> ac: "good" geoip databases :)
07:54:29 <ac> Botje: I had the whole ARIN database on my computer a while back from a contract job. I think I might still have it.
07:54:36 <quicksilver> ac: I believe the free ones are mostly poor, except probably google.
07:55:24 <ac> It's fun to dig up that database now and then and run queries against it
07:55:28 <shapr> apt-cache search geoip shows several libs that would be easy to bind from the FFI
07:56:46 <quicksilver> shapr: they're just "country" though
07:56:56 <quicksilver> shapr: that's not good enough for a pretty map ;)
07:56:59 <quicksilver> well, not a really pretty one.
07:57:02 <shapr> Yeah, true.
07:57:18 <ac> but good enough for Botje's country list
07:57:22 <quicksilver> that library really shouldn't call itself libgeoip
07:57:22 <shapr> But this is : http://www.haskell.org/haskellwiki/Haskell_user_locations
07:57:23 <lambdabot> Title: Haskell user locations - HaskellWiki
07:57:27 <quicksilver> it's libcountryip
07:58:06 <ac> quicksilver: maybe it aspires to be more than it is
07:58:41 <quicksilver> ac: everyone should!
07:59:46 <ac> quicksilver: I think they're trying to save themselves a future name change
08:00:15 <ac> shapr: looks like the coordinates on that wiki page were entered manually
08:03:06 <ac> or from frappr
08:07:40 <shapr> ac: Yeah, manually. But they're just fine for plotting a map.
08:08:47 <notsmack> @oesis 4 8 15 16 23 42
08:08:48 <lambdabot> The Lost Numbers.
08:08:48 <lambdabot> [4,8,15,16,23,42,108]
08:09:29 <quicksilver> lol
08:09:31 <oerjan> @oasis 1,3,5,7
08:09:37 <lambdabot> The odd numbers: a(n) = 2n+1.
08:09:37 <lambdabot> [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
08:10:09 <oerjan> why are they lost, i wonder.
08:10:57 <huamn> @oasis 1 7 13 19
08:10:57 <lambdabot> 6n+1.
08:10:57 <lambdabot> [1,7,13,19,25,31,37,43,49,55,61,67,73,79,85,91,97,103,109,115,121,127,133,139...
08:11:18 <quicksilver> oerjan: are you joking, or do you not know?
08:11:24 <yaxu> oerjan: i think they were a plot device in a tv series called lost
08:11:31 <oerjan> oh
08:11:44 <quicksilver> yes, it's a tv series ;)
08:11:47 <oerjan> i never watched that
08:12:04 <quicksilver> http://en.wikipedia.org/wiki/4_8_15_16_23_42
08:12:05 <lambdabot> Title: Mythology of Lost - Wikipedia, the free encyclopedia
08:12:05 <oerjan> or much tv in general
08:12:24 <notsmack> *spoiler alert*
08:13:19 <ac> my friend watched it, and so I watched a few episodes with him. Silly and a little fun
08:13:29 * yaxu doesn't have a tv any more
08:13:42 * ac has never had a TV, but DLs TV once in a while
08:14:07 <ac> (my parents were hippies)
08:14:46 <yaxu> we'll wake conal up with all this talk of TVs
08:17:14 <Nafai> ac: You're lucky to not have a TV.
08:17:27 <Nafai> ac: I went without a TV for about 2 years when I lived alone and it was great
08:17:59 <pejo> Nafai, so throw away your tv then? Exactly the advice Randy Pausch gives.
08:18:16 <Nafai> Oh it's tempting
08:18:29 <Nafai> Except my wife and I just bought a new TV after our old one went out :/
08:18:39 <Nafai> I sure read a lot more back then
08:20:23 <ac> Nafai: yeah I'd imagine it's somewhat of a bummer living with people who own a TV. I've never had to. My SO would kind of like one, but has abstained for the last two years :-P
08:22:45 <Nafai> I've found our DVR to be absolutely essential.  I'm not longer "controlled" by the TV.  I watch what I want, when I want, and I can fast forward through commercials
08:24:05 <ac> Nafai: yeah that's great. I torrent the TV I watch, or watch it on Veoh
08:24:11 * Nafai nods
08:24:21 <shapr> I just don't watch TV, that solves the problem entirely.
08:24:33 <ac> shapr: no it doesn't!
08:24:52 <shapr> It doesn't?
08:24:58 <shapr> Works for me.
08:25:04 <ac> that's _avoiding_ the problem, not solving it
08:25:09 <ac> ;)
08:25:16 <shapr> I dunno, books are faster.
08:25:34 <noteventime> In what sense?
08:25:42 <ac> noteventime: this guy reads like crazy
08:26:02 <ac> it's a heck of a lot faster to read a short story than watch a movie of equivalent content
08:26:17 <noteventime> ac: I generally enjoy the time I spend
08:26:27 <ttt--> dont take about tv behind its back
08:26:29 <ttt--> talk*
08:26:35 <noteventime> So I want it to last for as long as possible :-)
08:26:53 <ac> noteventime: yeah, I appreciate the media as well, but apparently shapr does not :-P
08:27:41 <noteventime> There's some good TV
08:27:58 <noteventime> :) Although very little compared to what's bad
08:29:55 <ac> well, I even enjoy some "bad" TV once a year or so.
08:33:00 <hexpuem> is it normal for GHC to generate 1mb+ binaries for a dynamically linked hello world?
08:34:19 <ac> hexpuem: yes
08:34:33 <ac> hexpuem: it's the haskell runtime. you can shrink that a good deal by running strip and gzexe on it
08:35:12 <hexpuem> does putstrln have a lot of dependencies or is the linker just not stripping unused stuff from the runtime?
08:35:22 <ac> hexpuem: er, I should say "GHC's runtime". It's not that GHC makes space inefficient code, there's just a 1mb lower limit
08:36:10 <ac> hexpuem: AFAIU, the same chunk of code gets attached to every executable no matter what, and it's not attempted to optimize it. I really don't know that though
08:37:04 <BMeph> @seen dcoutts
08:37:05 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 24m 31s ago.
08:37:46 <dcoutts> hia BMeph
08:38:44 <BMeph> Hi, dcoutts. I was just wondering - have there been any problems with Cabal building on Windows?
08:38:54 <hexpuem> haha you werent kidding about gzexe
08:39:07 <ac> hexpuem: go ahead and run strip too. It does not effect the program at all
08:39:23 <hexpuem> most of the binary size isnt machine code then i assume?
08:39:31 <hexpuem> for gzexe to get that good compression
08:39:53 <dcoutts> BMeph: not that I know of, but I don't test it myself on Windows very often and few windows devs follow the darcs version of Cabal so I would not necessarily know about problems.
08:40:03 <dcoutts> BMeph: are you having problems with it on Windows?
08:40:06 <ac> hexpuem: gzip is pretty decent. it could easily be compressing machine code that well
08:40:35 <conal> what does strip do?
08:40:46 <ac> conal: read the man page. It removes all symbol names from an object file
08:40:48 <hexpuem> removes symbol info
08:41:09 <dcoutts> conal: standard binaries contain extra debugging information like symbol tables etc that are not necessary for running the code
08:41:11 <hexpuem> theres utils that remove the Shdrs from elf too
08:41:18 <conal> thanks.
08:41:21 <hexpuem> OS only loads Phdrs
08:41:35 <BMeph> Yes. I probably just messed something up, so I'm about to re-install GHC, but every time I try a "cabal update", I get an error out of zlib.
08:41:45 <ac> hexpuem: I find it slightly annoying when really simple CGI scripts are that large
08:41:47 <conal> so nothing about removing unused code from packages used.  would it be difficult to do so?
08:41:56 <dcoutts> conal: but are very useful for C coders using traditional low level debuggers as it allows them to match up addresses with names of C functions. It's almost useless for Haskell code.
08:42:12 <hexpuem> yea i was trying to decide if i should try to learn haskell or Ocaml
08:42:14 <conal> dcoutts: got it,thanks.
08:42:23 <hexpuem> and was just comparing hello world size
08:42:28 <ac> hexpuem: funny metric ;)
08:42:30 <dcoutts> conal: linker do that automagically, to the best of their abilities
08:42:39 <hexpuem> yea haha
08:42:45 <hexpuem> think i might go with haskell anyway
08:42:48 <conal> hexpuem: haskell will change your thinking more.
08:42:56 <hexpuem> yea thats what i heard
08:43:07 <hexpuem> cant cheat as much with mixed programming styles
08:43:15 <ac> hexpuem: yeah, yay for Haskell. Even though it's the most recent language I've learned, it's probably taken me the longest and been the most rewarding
08:43:20 <dcoutts> conal: the ghc "split objs" feature is to help linkers identify what bits of code are really needed so they can link in the minimum necessary
08:43:24 <ac> s/learned/learning/
08:43:47 <dcoutts> conal: which is why using split-objs on large libs can make such a difference to the size of final .exes
08:44:28 <dcoutts> conal: eg, hello world with gtk2hs went from several MB to being just 30% bigger than a traditional text-only hello world when gtk2hs is built with split-objs
08:44:52 <conal> dcoutts: neat.  and how big is the text-only?
08:45:14 <ac> 1mb or so?
08:45:34 <dcoutts> conal: can't remember off the top of my head, I can look it up,  recall it being about 400k striped
08:46:38 <ac> huh. 2.8 for my version of ghc, and 1.6 stripped
08:46:50 <ac> that's more than I remember seeing last time
08:47:54 <ac> 400k after gzexe
08:48:50 <ac> (that's 6.6.1)
08:51:52 <pejo> ac, there's a mentioned bug about larger binaries with some recent ghc version. I can only find ticket 955 that mentions it though.
08:56:55 <ac> pejo: it doesn't bother me extraordinarily. My only gripe is I typically web sites such that I have a lot of little cgi programs sprinkled around, which is a lot easier than writing some sort of fastcgi thingy. If the binaries are large than syncing them to the live server is slow, and I imagine loading them on a page request is slow
08:57:10 <ac> s/typically/typically write/
09:03:47 <ac> I guess the other option is just using Haskell for my web server, but the problem with that is all the servers I use have Apache... and I like how Apache's configuration works
09:04:43 <hexpuem> you can have the runtime library as a shared object i think
09:04:51 * BMeph looks for a mod_haskell
09:04:57 <ac> hexpuem: oh yeah?
09:05:00 <ac> BMeph: I would love that
09:05:02 <quicksilver> fastcgi is the right answer
09:05:06 <quicksilver> mod_foo is a terrible answer
09:05:15 <pejo> ac, modern operating systems perform some kind of read on demand for binaries, so it should only read what is necessary for executing it. If it is the same thing being loaded over and over it will remain in the memory cache.
09:05:17 <ac> quicksilver: why not mod_haskell?
09:05:24 <hexpuem> think i saw a -dynamic option in the ghc manpage but my install diddnt have the lib built so the link failed
09:05:24 <quicksilver> the only reason to use mod_foo is if you actually want to modify the apache request sequence at all levels
09:05:32 <quicksilver> if you do want to do that, it's the right answer
09:05:39 <quicksilver> but assuming you don't, fastcgi is much cleaner
09:05:58 <dons> ?users
09:05:58 <lambdabot> Maximum users seen in #haskell: 444, currently: 421 (94.8%), active: 12 (2.9%)
09:06:08 <ac> quicksilver: ah I see. _sometimes_ I want to do that, but you're right that it's not typical
09:08:24 <pejo> ac, and predicting the actual traffic patterns to websites (to determine load) is nearly impossible unless you have previously recorded data that you can 'replay' in some kind of test environment.
09:09:22 <quicksilver> pejo: whilst your right about OS caching, there is still some kind of overhead to loading a large binary
09:09:31 <quicksilver> pejo: even if the file is cached in memory
09:09:41 <quicksilver> however, the situation is obviously much better for haskell than perl or python
09:10:09 <quicksilver> since perl/python have to load all the dependent libraries and 'sort-of-compile' them each time.
09:10:49 <jwprox> Once you learn and become proficient in Haskell... Does it actually make things easier?
09:11:26 <Taejo> jwprox: some things
09:11:27 <ac> I shouldn't be worrying about it too much because before I simply used #!/usr/bin/perl to make CGI scripts. I found mod_perl to be infuriating to develop with
09:11:31 <puusorsa> google for quicksort in haskell. compare to c version.
09:11:36 <puusorsa> jwprox
09:11:42 <Taejo> jwprox: it doesn't make herding cats easier
09:11:49 <puusorsa> i think that might answer your question
09:12:09 <jwprox> Not that I'm bashing the language, but it seems that as a general purpose language it makes simple things more difficult to accomplish
09:12:13 <Taejo> puusorsa: that's kind of cheating since the algorithms do different things (if you're referring to the list version)
09:12:23 <Taejo> jwprox: does it?
09:12:31 <ac> jwprox: it makes a lot of things more fun too, and I'd argue the Haskell style discourages a certain class of bugs
09:13:04 <sjanssen> jwprox: what sort of things seem more difficult?
09:13:21 <quicksilver> jwprox: I don't find it does. Not once you get into the swing.
09:13:38 <quicksilver> jwprox: what I do find though, is it makes you face certain difficult problems at an earlier stage.
09:13:44 <ac> jwprox: IMHO, there are many things that require a lot more knowledge than they do in other languages, but once you have that knowledge, those things are much easier
09:13:58 <ac> jwprox: quicksilver says it more elegantly
09:14:01 <dons> http://programming.reddit.com/info/657vx/comments/ "Partial application or currying?"
09:14:03 <quicksilver> so, you end up being confronted by and forced to solve something which, in a more dynamic language, you wouldn't have even discovered until you had a working prototype
09:14:11 <puusorsa> not sure about easier, but at least there's less typing which is nice as i'm lazy
09:14:25 <quicksilver> effectively, the type system makes you aware of holes in your "mental model" of the problem you were trying to solve
09:14:33 <quicksilver> this may feel like it's "harder"
09:14:50 <quicksilver> but actually I think you're doing yourself a favour by solving that problem now rather than waiting to see the problems it produces
09:15:02 <dons> i've just spent 3 months working on a commercial project, and we've had oh, maybe 5 bugs in that time. and lots of type errors that got removed before we demoed. :)
09:15:05 <jwprox> Ok that makes sense, I guess my mind is still stubbornly clinging to an imperative outlook
09:15:08 <puusorsa> often when haskell compiles, it works too. same can't be said of c
09:15:21 <dons> i really really don't think that would have happened without the type system -- which we use moderately heavily
09:15:39 <ac> puusorsa: and when it doesn't work, it's a semantic.. er higher level error rather than some stupid pointer bullshit
09:16:24 <quicksilver> of course, occasionally you a real dozie of a type error and your head explodes
09:16:26 <dons> right. you simply don't spend time tracking down low level bugs where you put the wrong data in the wrong place
09:16:27 <ac> and when I say "stupid pointer bullshit" I'm not comparing it to just C. That also applies to JavaScript, PHP, and Perl
09:16:31 <quicksilver> but that is just part of the experience
09:17:33 <quicksilver> ac: different flavours of pointer bullshit in the different languages though :)
09:17:41 <ac> quicksilver: exactly
09:17:52 <quicksilver> the perl situation feels a lot more like "error: Prelude.fromJust"
09:17:56 <ac> quicksilver: the C flavor is particularly nasty
09:17:59 <quicksilver> than it does like "segmentation fault"
09:18:13 <ac> heh
09:18:23 <dons> its eerie sometimes how much could you can write (i.e. several hours), without anything going wrong.
09:18:35 <pejo> quicksilver, what is the overhead of loading a large binary compared to  a small one if all the code that gets executed fits in one page?
09:18:40 <puusorsa> ac, right. doing the wrong thing instead of doing it wrong
09:18:44 <dons> it type checks, it runs, it does the right thing, you go and play guitar hero instead of debugging
09:18:48 <ac> dons: yeah, in all other languages prior to Haskell that SCARED me, but in Haskell it makes me happy
09:18:55 <quicksilver> pejo: my understanding is that there is a certain amount of parsing of the executable file
09:19:08 <quicksilver> pejo: mapping of data sections into areas with appropriate page permissions
09:19:20 <quicksilver> pejo: but, I'm not a kernel guy so I could be overplaying it
09:19:29 <quicksilver> dynamic linker time too?
09:20:06 <ac> quicksilver: certainly seems intuitive to me that larger executable means longer load time, but it's definitely news to me that the whole thing isn't necessarily loaded before it's executed
09:20:18 <pejo> dons, you're well beyond the average programmer, which is another reason for the lack of bugs, too.
09:20:45 <quicksilver> pejo: before dons discovered haskell, he was a lesser man!
09:20:51 <quicksilver> haskell embiggened him!
09:20:53 <quicksilver> cromulently!
09:21:19 <ac> jwprox is probably running about now
09:21:21 <dons> definitely :) i haven't had to do serious debugging in 5 years
09:21:54 <dons> i still find that most of the bugs are to do with ffi bindings.
09:22:00 <dons> we need more robust tools there.
09:22:27 <quicksilver> I worry about RULES and unsafe/inline
09:22:37 <quicksilver> and subtle bugs in librarys like ByteString and Binary
09:22:42 <quicksilver> my worries may be FUD though.
09:22:43 <dons> there was an interesting rules issue yesterday
09:22:45 <quicksilver> Or paranoia.
09:22:56 <sjanssen> dons: oh?
09:22:58 <dons> the side condition that made it correct was a subtle ghc compilation technique for ascii strings
09:23:16 <dons> sjanssen: strings with embedded \0 have a packAddress rule that calls strlen.
09:23:30 <Saul_> I just got back from an fp-day :)
09:23:33 <dons> however, ghc utf8 encodes strings with \0 in them, so the strlen is ok (and the rule never files)
09:23:37 <pejo> quicksilver, I don't disagree on the technical stuff there, I'm merely saying that it's not *that* expensive compared to the other stuff your webserver does.
09:23:38 <dons> s/fires/
09:23:42 <dons> Saul_: woot!
09:23:49 <dons> i hope there's videos/blogs?
09:24:31 <dcoutts> dons: what do you find the most common FFI bugs are? and would c2hs or an improvement on c2hs help?
09:24:34 <Saul_> It was pretty cool, although most stuff was more advanced than what I can really use
09:24:48 <Saul_> roconner did a presentation :)
09:24:58 <dons> dcoutts: i think c2hs would help -- they're type errors in ffi imports
09:25:16 <dcoutts> dons: right, that's c2hs's strong point
09:25:18 <dons> and mistakes in structure definitions for peek/poke
09:25:27 <dcoutts> that's c2hs's weak point :-)
09:25:28 <ac> pejo: stupid premature optimization on my part... I mean I was at least thinking about it
09:25:44 <quicksilver> pejo: ah yes. I was just being pedantic / making conversation I guess.
09:25:45 <quicksilver> pejo: ;)
09:25:57 <dons> dcoutts: after you do your thesis, you could come out and do an internship, and we could work on a safer ffi tools
09:26:01 <dcoutts> dons: if only I had more time I'm sure I could improve c2hs's structure support
09:26:21 <dcoutts> dons: aye, that's be a good project, c2hs needs some cleanup and extension and massive testing
09:27:13 <dons> and i've had this idea for effect inference-based unsafePerformIO checking for a while
09:27:21 <dons> that's probably an ICFP paper waiting to happen
09:27:23 <dcoutts> dons: I was very pleased with the testing I was able to do with the parser, just parse everything in a gentoo system, the same massive testing technique could be applied to check that c2hs calculates structure field sizes, offsets, alignments correctly
09:27:41 <dons> mm. that's good.
09:27:57 <quicksilver> dons: that sounds interesting.
09:27:59 <dcoutts> dons: there's been previous work on effect inference that might be applicable
09:28:07 <sjanssen> dcoutts: I've also tripped on lots of bugs dealing with C library error conventions
09:28:13 <dons> dcoutts: right. BenL's thesis was what got my interest there.
09:28:28 <dcoutts> dons: so you mean trying to work out if a particular use of unsafePerformIO is actually safe
09:28:32 <dons> quicksilver: yeah, imagine having it tell you 'yes, this use of unsafe stuff *is* referentially transparent'
09:28:34 <dcoutts> sjanssen: mmm
09:31:33 <quicksilver> dons: I'm also interested in the question of whether or not we can construct a set of referentially transparent primitives which are enough to rewrite Data.ByteString and other librarys which use unsafePerform
09:31:47 <quicksilver> dons: so we just have one set of primitives to prove safe.
09:31:53 <quicksilver> but, the answer is not obviously yes :)
09:32:15 <dcoutts> quicksilver: I think bytestring could be rewritten using ST/runST and not IO/unsafePerformIO
09:32:24 <jwprox> If there was one open source project written in Haskell that would be a good example code to browse through, which would it project would it be?
09:32:35 <sjanssen> jwprox: xmonad is pretty nice
09:32:38 <dcoutts> jwprox: try xmonad, it's small
09:32:58 <quicksilver> dcoutts: ...and still expect similar performance?
09:33:03 <dcoutts> quicksilver: yes.
09:33:05 <Tac-Tics> Does ST typically use mutable containers for its implementation?
09:33:08 <dcoutts> quicksilver: no, better.
09:33:10 <quicksilver> dcoutts: that's very interesting.
09:33:14 <jwprox> Thanks guys
09:33:17 <quicksilver> dcoutts: why isn't it, then? ;)
09:33:21 <sjanssen> dcoutts: ooh, better how?
09:33:26 <oerjan> @src STRef
09:33:26 <lambdabot> data STRef s a = STRef (MutVar# s a)
09:33:32 <dons> sjanssen: btw, looks like there might be a PSU project to do proofs in isabelle for some bits of xmonad
09:33:41 <dcoutts> sjanssen: heap allocated unpinned bytestrings
09:33:46 <Tac-Tics> The # means a primitive function, right?
09:33:50 <oerjan> @src IORef
09:33:50 <lambdabot> newtype IORef a = IORef (STRef RealWorld a)
09:33:52 <dons> dcoutts: yeah, we should look at this.
09:33:56 <dcoutts> sjanssen: heap allocation for small strings should be a big win
09:34:06 <dcoutts> dons: the only concern is loosing mmap
09:34:18 <quicksilver> Tac-Tics: the # means ghc-internal, really
09:34:21 <dons> what about other FFI calls?
09:34:24 <dcoutts> dons: but if it's just that one I wonder if we couldn't handle it specially in the rts
09:34:26 <quicksilver> Tac-Tics: I don't think everything with # is necessarily primitive.
09:34:30 <dons> we can pin them for the duratoin of the ccall ?
09:34:38 <sjanssen> dcoutts: isn't there a way to allocated pinned ByteArray#?
09:34:44 <dons> dcoutts: but it should be possible to provide Pinned / Unpinned variants
09:34:47 <dcoutts> sjanssen: yes, but it's slow
09:35:01 <ac> anybody used the gd lib?
09:35:03 <dcoutts> dons: yes, large ones are pinned, small ones are not
09:35:05 <sjanssen> dcoutts: slower even than ForeignPtr+malloc?
09:35:05 <dons> dcoutts: oh, you should look at the long thread last night tuning Ord for small bytestrings
09:35:20 <dons> i got some numbers (we're way to slow for small strings currently)
09:35:21 <dcoutts> dons: oh, yes I should
09:35:31 <dcoutts> dons: comparing or allocating?
09:35:33 <dons> this was the thread, http://hpaste.org/4922
09:35:35 <dons> comparing.
09:35:44 <quicksilver> so why does it not currently work this way? Because the ST/ ByteArray# wasn't good enough when the foreignptr rewrite happened?
09:35:48 <dons> the problem was to take a 3M text file, and find the 20 most frequent words
09:36:03 <dons> Map + ByteString or ?Hash + ByteString were find in the end, but needed non-FFI Ord
09:36:15 <dcoutts> quicksilver: yes, mostly that
09:36:20 <ac> I'm wondering if there's some way to retrieve a Ptr type from the Image type (doesn't mention it in the docs) so I can create arbitrary images and then do a gd operation on them
09:36:25 <yav> having a version of bytestrings with ST would be useful
09:36:41 <quicksilver> dons: oh, it was 20 most frequent?
09:36:45 <dcoutts> yav: useful? it should not change the external api at all
09:37:08 <quicksilver> dons: that's interesting. were you discarding things not in the top 20 constantly?
09:37:12 <quicksilver> ah, can't do that
09:37:14 <quicksilver> stupid quicksilver
09:37:20 * quicksilver fails algorithmically
09:37:26 <yav> yes, but one can trust the implementation more, because it would presumable use less unsafe stuff
09:37:26 <sjanssen> @slap quicksilver
09:37:26 * lambdabot places her fist firmely on quicksilver's jaw
09:37:26 <dons> got to calculate the whole table, then do some fun stuff.
09:37:48 <dcoutts> dons: so, the point is, there is no way at the moment to temporarily pin a bytearray# that was allocated as unpinned, however we can take advantage of the size heuristic, large ones do get pinned and small ones should be relatively cheap to copy
09:37:54 <ac> there's a spurious 'e' in that slap
09:38:24 <dons> dcoutts: i'd also say we need to move to non-ffi for small strings
09:38:30 <byorgey> ac: good spot.  submit a patch! =)
09:38:40 <ac> byorgey: don't know how
09:38:48 <dcoutts> dons: and all decent C libs provide a way to let the client manage memory, so accepting incoming data should not be a problem and for outgoing we can deal with large strings without copying and small strings with copying.
09:38:54 <quicksilver> dcoutts: one of the interesting points made was that 99% of compares complete after comparing the first char.
09:39:01 <dcoutts> quicksilver: mmm
09:39:06 <quicksilver> dcoutts: and an FFI overhead to just compare the heads is painful
09:39:12 <dcoutts> aye
09:39:19 <quicksilver> compare (head a) (head b) is a whole lot faster
09:39:21 <byorgey> ac: would you like to know how?
09:39:22 <dons> i reckon it'd be safe to only do the memcmp when size>1k or so :)
09:39:29 <quicksilver> 99% is an informal number but I imagine you can guess what I mean
09:39:32 <dons> since we can also bet on ghc getting faster
09:39:36 <ac> byorgey: is slap actually built in? I figured you could change it with an @foo command or something.
09:39:49 <sjanssen> dons: at that point, is it even worth the memcmp special case at all?
09:40:02 <dons> sjanssen: so it definitely used to be, but we need the numbers
09:40:02 <quicksilver> sjanssen: it is for 1G strings, yes :)
09:40:04 <byorgey> ac: I think it's actually built in, it randomly chooses one of a number of different possible messages
09:40:10 <dons> but people just don't Ord 1G strings very often!
09:40:16 <quicksilver> indeed not
09:40:23 <quicksilver> but they might do occasionally
09:40:29 <sjanssen> quicksilver: the size of the string doesn't matter, the common prefixes do
09:40:35 <quicksilver> very good point
09:40:39 <quicksilver> damn I stupid this afternoon
09:40:45 <quicksilver> I wonder how common a 1G common prefix is
09:40:47 <sjanssen> quicksilver: how often do you compare strings with 1GB common prefixes? :P
09:40:49 <quicksilver> rare, I would think.
09:40:51 <dons> we need to get a better Map too. there are faster AVL trees around
09:41:07 <dons> HashTable can be tuned easily, too, fwiw. and generalised tries have been toyed with
09:41:15 <quicksilver> if you have 1G common prefixes you might want to consider comparing MD5 hashes instead.
09:41:19 <dons> but even a specialised Trie ByteString a would be very useful
09:41:32 <dcoutts> dons: indeed
09:41:34 <ac> quicksilver: how could that possibly be faster?
09:41:50 <ac> quicksilver: if it's just a one time thing, a simple compare would have to be faster
09:41:54 <quicksilver> ac: if you compare the same 1G block more than once :)
09:42:01 <quicksilver> of course if you only do it once it's daft
09:42:23 <sjanssen> is that necessarily so?  What about cache effects?
09:42:36 <quicksilver> but normally if you're comparing big blocks it's for things like checking uniqueness of media files
09:42:39 <quicksilver> or some such
09:42:44 <quicksilver> and I imagine you expect to do it multiple times
09:42:54 <ac> indeed
09:42:59 <quicksilver> and I suppose media files occasionally do have huge common prefixes
09:43:01 <quicksilver> although...
09:43:08 <quicksilver> I suspec they normally have different sizes :)
09:43:17 <quicksilver> large common prefixes but the same sizes should be rare
09:43:39 <quicksilver> sjanssen: yeah, I agree with your initial comment. It's really not a very common case at all :)
09:45:11 <dcoutts> dons: yeah, looking at compareBytes we could make some improvements
09:45:30 <dcoutts> dons: eg we've got two special cases there but it's not clear they're the most likely cases
09:45:53 <dcoutts> dons: eg we incur two comparisons for the case that both strings are empty (!!?)
09:46:04 <dcoutts> seems an unlikely case to optimise for
09:46:34 <dcoutts> so we want some stats, in "ordinary" programs that use ord, what is the most common outcome
09:46:38 <dcoutts> then we optimise for that
09:47:03 <dcoutts> and as people have pointed out, it's probably that they end up not-equal after comparing one byte
09:47:45 <nelhage> Might it make sense to, for long strings, compare some number of bytes in haskell and then call out to FFI if they're still equal after some point?
09:47:50 <dcoutts> we might keep the short-cut for comparing the same string, but move it after the initial inequality test
09:48:04 <dcoutts> nelhage: probably
09:49:12 <quicksilver> sjanssen: Ah. There is of course one common case for long prefix.
09:49:17 <quicksilver> sjanssen: comparing a long string to itself.
09:49:30 <quicksilver> which certain problems or algorithms might well involve.
09:49:54 <dons> dcoutts: yep. so i've got some tests, and some different versions. so should be able to do something here
09:50:18 <ac> anybody know where the darcs repository is for the gd bindings? The hackage version is giving me some sort of C compile error when I build it
09:53:18 * gwern idly wonders how long until dons writes 'Hugs considered Harmful'
09:53:24 <dcoutts> heh heh
09:53:29 <pejo> ac, http://code.haskell.org/gd/ perhaps?
09:53:30 <lambdabot> Title: Index of /gd
09:53:43 <dcoutts> it's good to have a range of working implementations
09:54:14 <dcoutts> cabal support for the other implementations is important, as is making it easy to test packages with them
09:54:56 <dcoutts> dons: about that, the hard part I think with gathering lots of build reports is distilling useful information out of them
09:55:30 <ac> pejo: thanks. couldn't find it with Google
09:56:01 <dcoutts> dons: eg trying to find out if a package "works with ghc-6.8" is not easy since there may be several reports that say it doesn't work with 6.8, though only on windows, so in fact we might still be able to conclude that it works with ghc-6.8 but it does not work on windows
09:57:00 <dcoutts> dons: so we end up with samples in a multi-dimensional space of platform/environment/dependencies and we have to try and infer (with some level of confidence) useful information
09:57:43 <dcoutts> dons: it seems possible but I don't know the statistical methods
09:59:58 <gio123> what is deference between regular tree language and regular word language?
10:01:03 <ac> gio123: I admire your persistence
10:05:42 <Botje> dcoutts: perhaps you could simply say "this package worked on 86% of the ghc 6.8 installations it was tested on"
10:06:47 <dcoutts> Botje: but supposing it works on only 50%, but 95% of the cases where it failed were windows, then it's much more useful to say that it works on ghc-6.8 but not on windows
10:07:13 <ac> bah. darcs version is same as hackage version
10:08:06 <myname> @oasis 88 70 4 223
10:08:10 <Botje> dcoutts: hmm. bayesian networks spring to mind
10:08:21 <lambdabot> Plugin `oeis' failed with: thread killed
10:08:56 <dcoutts> Botje: I'll google for it
10:09:08 <myname> @oasis 1,1,2,3,5,8
10:09:09 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
10:09:09 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
10:09:29 <Cale> What's with all these thread killed errors lately? Is the machine on which lambdabot runs particularly busy?
10:09:35 <Botje> you might get more hits with "bayesian belief networks", but they're called bayesian networks as well
10:09:41 <ski_> http://worrydream.com/AlligatorEggs/ !
10:09:41 <lambdabot> Title: Alligator Eggs!
10:09:47 <Cale> @oeis 88 70 4 223
10:09:47 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
10:10:04 <Botje> ski_: 25% of you can be replaced by half of you!
10:10:12 <Cale> @oeis 4 8 15 16 23 42
10:10:12 <lambdabot> The Lost Numbers.
10:10:12 <lambdabot> [4,8,15,16,23,42,108]
10:10:21 <dcoutts> Botje: one of the good things is that we know how all the predicates are related, it's a simple || or
10:10:30 <C-Keen> Cale: what is this :)
10:10:37 <ski_> @help oasis
10:10:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:10:39 <Cale> C-Keen: those are from a TV show :)
10:10:39 <dcoutts> Botje: ie if a build fails for any reason then it fails
10:10:42 <ski_> @help oeis
10:10:42 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
10:11:01 <Cale> @sloane 1 1 2 3 5 8
10:11:01 <lambdabot> Unknown command, try @list
10:11:05 <ski_> Botje : ?
10:11:08 <Cale> hehe, no alias there :)
10:11:21 <C-Keen> @oeis 2 5 0 1
10:11:21 <lambdabot> Number of steps to reach an integer starting with n/3 and iterating the map x...
10:11:21 <lambdabot> [0,2,6,0,1,1,0,5,2,0,3,2,0,1,1,0,2,4,0,3,4,0,1,1,0,22,7,0,2,5,0,1,1,0,7,2,0,4...
10:11:22 <Botje> dcoutts: with bayesian networks you wouldn't have the "windows-ghc-6.8 fails so ghc6.8 fails" problem
10:11:29 <Botje> but i'm off, byebye!
10:11:29 <Cale> @oeis 6,11,23,47
10:11:30 <lambdabot> Number of trees with n unlabeled nodes.
10:11:30 <lambdabot> [1,1,1,1,2,3,6,11,23,47,106,235,551,1301,3159,7741,19320,48629,123867,317955,...
10:11:35 <ski_> @oeis
10:11:35 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
10:11:36 <dcoutts> borism: ta for the pointer
10:11:39 <dcoutts> oops
10:11:40 <ski_> bah
10:11:42 <dcoutts> Botje: ta for the pointer
10:12:00 <Cale> @oeis 2,5,0,1
10:12:01 <lambdabot> Number of steps to reach an integer starting with n/3 and iterating the map x...
10:12:01 <lambdabot> [0,2,6,0,1,1,0,5,2,0,3,2,0,1,1,0,2,4,0,3,4,0,1,1,0,22,7,0,2,5,0,1,1,0,7,2,0,4...
10:12:07 <Cale> huh
10:12:15 <Cale> I suppose it does occur there :)
10:12:48 <ndm> @seen dcoutts
10:12:48 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 1m 6s ago.
10:12:53 <dcoutts> hia ndm
10:13:00 <ski_> Cale : why can't it handle the empty list ?
10:13:01 <notsmack> Cale: i checked for the lost numbers a couple hours upwards :-)
10:13:03 <ndm> dcoutts: if i want to acknowledge someone in a .cabal file, what field should i use?
10:13:03 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
10:13:07 <ndm> @messages
10:13:07 <lambdabot> pejo said 9m 8s ago: http://ailev.livejournal.com/544965.html, some russian dude obviously keeps track of us.
10:13:13 <Cale> notsmack: hehe :)
10:13:33 <dcoutts> ndm: hmm I'm not sure there is space for that unless they are author, maintainer or copyright holder
10:13:42 <Cale> > lookupSequence [2,5,0,1]
10:13:44 <lambdabot>   Not in scope: `lookupSequence'
10:13:50 <Cale> > Math.OEIS.lookupSequence [2,5,0,1]
10:13:52 <lambdabot>   Not in scope: `Math.OEIS.lookupSequence'
10:13:53 <dcoutts> ndm: if a contribution is significant then they can become a joint copyright holder
10:13:53 <Cale> huh
10:14:01 <Cale> We used to have that module.
10:14:21 <Cale> It's more fun than the basic @oeis command :)
10:14:22 <ndm> dcoutts: i just want to say "thanks" in a .cabal file, can i use X-Thanks or something?
10:14:24 <dcoutts> ndm: similarly, if it's a significant contribution then authors
10:14:39 <dcoutts> ndm: you can, yes x-fields are ignored
10:14:56 <dcoutts> ndm: I might just use an AUTHORS file
10:15:10 <ndm> dcoutts: they didn't write anything, they just "helped"
10:15:18 <dcoutts> ndm: eg we do that for gtk2hs and distinguish regular contributers from occasional or one off helpers
10:15:46 <dcoutts> ndm: AUTHORS files are unstructured, you can say what you like
10:16:29 <jwprox> Is the HOC (Haskell Objective-C) project dead and unusable?
10:19:46 <ac> ok, now compiling gd says "Could not find module `Data.ByteString.Internal': it is a member of package bytestring-0.9.0.4, which is hidden"
10:20:19 <jedbrown> Isn't IntMap a trie?  I would expect a small modification would make it work for ByteString (and hence Binary).
10:20:45 <dcoutts> jedbrown: in a sense I guess it is, it's a trie on the binary digits of a number
10:21:15 <dcoutts> hmm, actually maybe I'm confused about that
10:21:15 <jedbrown> Oh, it's bitwise, rather than byte-wise.
10:21:27 <sjanssen> a ByteString map would need to be quite a bit different
10:21:30 <sjanssen> s/map/trie
10:21:53 <dcoutts> yes, I don't think it'd bear much obvious resemblance to an IntMap
10:22:30 <BMeph> @oeis 1 1 2 4 9
10:22:31 <lambdabot> Motzkin numbers: number of ways of drawing any number of nonintersecting chor...
10:22:31 <lambdabot> [1,1,2,4,9,21,51,127,323,835,2188,5798,15511,41835,113634,310572,853467,23567...
10:24:56 <Toxaris> can I make ghc output error messages with windows path seperators "\" instead of "/"?
10:25:09 <ndm> Toxaris: no
10:25:17 <ac> Toxaris: don't both work in Windows these days?
10:25:40 <Toxaris> ac: my editor's tool support doesn't like them :(
10:25:46 <ndm> ac: depends exactly what you are doing, in most cases, yes, in some cases, certain command line programs bork on / (i think copy springs to mine)
10:26:02 <ac> lol
10:26:41 <ndm> filepaths are a bit of an embarassing mess on windows
10:29:11 <BMeph> Does anyone know why "cabal update" would give me:
10:29:21 <BMeph> "cabal: user error (Codec.Compression.Zlib: premature end of compressed stream)"
10:30:59 <Cale> BMeph: Maybe something failed to completely download?
10:31:18 <Toxaris> changed the working directory so that I have a good chance that error messages are given without paths. works good enough for now.
10:31:42 <ndm> Tobsan: when GHC move to using System.FilePath, the paths should snap back to being \
10:32:10 <BMeph> But this is right after a re-install of GHC 6.8.2
10:32:13 <ac> So how do I unhide a module?
10:32:39 <Toxaris> ndm: Toxaris :) good to know. so no need for a "real solution" at my side.
10:32:52 <BMeph> ac: "expose" it.
10:32:54 * Toxaris hopes for EclipseFP to become usable anyway
10:33:41 <ndm> Toxaris: i don't think that might happen in the next few years though...
10:34:43 <ac> the docs say that ByteString.Internal are semi public
10:35:34 <ac> but GHC says thay're entirely hidden :-|
10:36:26 <dcoutts> ac: I think you'll find it's just that gd is missing a dependency on the bytestring package
10:36:42 <dcoutts> and since cabal builds with all other packages hidden, then ghc reports it as hidden
10:37:40 <ac> ah, that problem again
10:37:59 <ac> like usual, solving a build error does not involve editing code
10:38:37 <BMeph> ac: It depends on whether you consider build instructions to be "code" or not. ;)
10:43:51 <ac> dcoutts: well, the problem is well damn. I think I'll just upgrade to 6.8 and hope that will fix this
10:44:00 <Toxaris> types and type classes share a common namespace?
10:44:42 <dcoutts> ac: oh, if you're using 6.6, then yes the ByteString.Internal module does not exist
10:44:46 <ac> dcoutts: the package relies on the new bytestring package, but I can't install it while it's already defined in base
10:44:52 <dcoutts> ac: exactly
10:45:12 <dmhouse> Toxaris: don't think so.
10:45:23 <dcoutts> ac: many packages that use bytestring's internals use cpp to work with both, but gd seems not to be such
10:45:27 <ac> oh well, been meaning to upgrade for a month or two
10:45:57 <ac> sudo apt-get remove --purge ghc6 #!
10:46:59 <byorgey> ac: seems silly to delete 6.6 before you have 6.8 installed and working...?
10:47:16 <byorgey> but maybe it's too late =)
10:47:24 <ac> 97MB of disk space will be freed....
10:47:34 <hpaste>  Toxaris pasted "types and type classes share a common namespace" at http://hpaste.org/4934
10:47:40 <ac> byorgey: last time I tried to install both I fucked something up and disaster ensued. That's why I went back to 6.6
10:47:48 <byorgey> ah.
10:47:59 <ac> byorgey: I'm sure I did something stupid, but I'm not going to take chances
10:48:32 <ac> both versions were trying to use the same lib I installed
10:49:16 <dmhouse> Toxaris: oh, apparently so.
10:55:05 * shapr boings furiously, with much fervor
10:56:25 <kaol> yay!
10:56:58 <thetallguy> what up, shapr?
10:57:23 <thetallguy> What energy source produces such boinging?
10:57:37 <dons> the perpetual shapr
10:57:44 <thetallguy> lol
10:57:45 <dons> he's clean and green!
10:58:08 <dons> the future of our planet depends on harnessing shapr!
10:58:12 <shapr> Actually, cognitive dissonance is producing this fervor.
10:58:15 <shapr> Hah!
10:58:36 <thetallguy> dons: we'll have to get adipping bird and put his head on it.
10:58:47 <shapr> :-P
10:58:51 <thetallguy> shapr: say it ain't so!
10:58:53 * shapr throws sticky lambdas around the channel.
10:59:03 <dons> ?users
10:59:03 <thetallguy> shapr: not the dreaded cognitive dissonance.
10:59:03 <lambdabot> Maximum users seen in #haskell: 444, currently: 426 (95.9%), active: 17 (4.0%)
10:59:14 <dons> 444. i wonder if we'll get 500 by year's end
10:59:22 <thetallguy> eww
10:59:23 <dons> which seems insane :)
10:59:31 <shapr> This is the boinging of frustration. While you may be able to write FORTRAN in any language, I cannot write Haskell in any language.
10:59:36 <dons> heh
10:59:54 <thetallguy> dons: why? out of all the math classes in all the world...
11:00:09 <shapr> For one thing, you can't efficiently reverse a string char by char in a strict language.
11:00:17 <thetallguy> shapr: what's the target of frustration?
11:00:19 <shapr> C#
11:00:45 <thetallguy> shapr: can you write to the cells of the string?
11:01:09 <shapr> Oh, I'm figuring it out, it's just that my brain's current native languages are emacs + haskell.
11:01:25 <thetallguy> swap i (length -i)
11:01:33 <BMeph> Strict languages are inefficient, because they always eat up space and time on unneeded calculations... ;)
11:01:41 <thetallguy> shapr: understood
11:02:04 <thetallguy> shapr: there's a scene in RoboCop II that you would empathize with think
11:02:43 <thetallguy> shapr: one cop/robot hybrid is so distraught it just rips it's own head off.
11:03:01 <thetallguy> shapr:felt that way many times.
11:06:24 <byorgey> shapr: don't rip your head off though.
11:07:36 <ac> an interesting way to commit suicide I think... it would require a fair amount of preparation
11:07:57 <byorgey> hm, wasn't there an xkcd about this?
11:08:37 <ac> probably. I haven't read them all yet. Just the earliest and most recent ones
11:12:34 <Saul_> I have this function of type Applicable f => (t -> f (a -> b)) -> (t1 -> f a) -> t -> t1 -> f b, but I was wondering if I could write it so that I can apply it more than once
11:14:07 <Saul_> It basically combines to functions into a function that takes both inputs and applies the first to the second (and after lifting to applicative)
11:14:18 <Saul_> s/to/two
11:15:29 <Saul_> Do I make sense at all?
11:15:57 <Toxaris> :t \f g x y -> f x <*> g y -- Saul_ are you talking about this one?
11:16:00 <lambdabot> forall t t1 (f :: * -> *) a b. (Applicative f) => (t -> f (a -> b)) -> (t1 -> f a) -> t -> t1 -> f b
11:17:23 <Saul_> Toxaris: Yes
11:17:41 <Toxaris> Saul_: what do you mean by "apply it more then once"?
11:18:53 <Saul_> Well if the first input is of type t -> f (a -> b -> c), I want to be able to get a f c at the end
11:19:57 <Toxaris> so it should be \f g h x y z -> f x <*> g y <*> h z in this case?
11:20:13 <Saul_> yes
11:20:49 <Toxaris> i don't think this is easily possible in Haskell
11:21:22 <ac> I think it's rather nifty how "darcs pull" simply pulls from the last repository you pulled from
11:21:32 <Saul_> that's too bad
11:21:44 <Toxaris> Saul_: it may be possible with some type hackery, but wouldn't it be easier just to use <*> and <$> and so on?
11:21:52 <byorgey> @type \fs xs -> foldl (<*>) (pure id) (zipWith ($) fs xs)
11:21:54 <lambdabot>     Ambiguous occurrence `pure'
11:21:54 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
11:21:54 <lambdabot>                           or `pure', imported from Control.Arrow
11:22:04 <byorgey> @type \fs xs -> foldl (<*>) (Control.Applicative.pure id) (zipWith ($) fs xs)
11:22:05 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
11:22:05 <lambdabot>       Expected type: f (a -> b) -> f a -> f (a -> b)
11:22:05 <lambdabot>       Inferred type: f (a -> b) -> f a -> f b
11:22:26 <byorgey> oh, right, can't fold <*> since the intermediate types all have to be the same
11:22:58 <Saul_> Toxaris: I'm not sure how
11:23:40 <byorgey> i.e. write out f x <*> g y <*> h z explicitly instead of using a higher-order function
11:24:01 <Toxaris> Saul_: well, just use (f x <*> g y) instead of (foo f g x y) and (f x <*> g y <*> h z) instead of (foo f g h x y z).
11:24:27 <Toxaris> Saul_: I assume that at the caller of foo knows the type of f, g and h.
11:24:37 <Toxaris> Saul_: (foo is the function you hope to define)
11:28:02 <Saul_> The problem then is that I can't separate the construction of the function and using it
11:29:53 <Toxaris> I don't understand what you mean?
11:30:05 <Toxaris> construction of which function.
11:31:34 <Toxaris> let foo = f x <*> g y in ... foo <*> h z ...  should work fine
11:32:37 <Saul_> Ok I'll try that
11:33:07 <hpaste>  visof pasted "help" at http://hpaste.org/4935
11:33:36 <visof> what is the wrong for this code?
11:34:24 <Toxaris> visof: no need to use map here
11:35:41 <Toxaris> > let foo x | Char.isUpper x = Char.toLower x | otherwise = Char.toUpper x in map foo "abcABC"
11:35:45 <lambdabot>  "ABCabc"
11:35:56 <Toxaris> visof: alternative formulation using Char.isUpper and guards :)
11:36:01 <visof> oh  thanks
11:36:10 <Toxaris> visof: but your's should work too. try it!
11:36:59 <ac> can darcs do file permissions? Like for example make certain files you checkout be executable?
11:37:14 <ac> er, I should say "pull" instead of "checkout"
11:37:16 <mauke> not really
11:37:44 <ac> it would be nice if all the Setup.hs files were already executable :P
11:38:02 <mauke> --set-scripts-executable
11:38:15 <ac> ah, nice
11:38:40 <BMeph> visof: you're trying to use x as both a Char and a [Char], in your example.
11:39:50 <visof> BMeph so what should i do?
11:40:03 <dons> ?users
11:40:03 <lambdabot> Maximum users seen in #haskell: 444, currently: 430 (96.8%), active: 14 (3.3%)
11:41:12 <bringert> when do you want Hac in Gothenburg? http://www.haskell.org/haskellwiki/Hac_2008/Dates
11:41:15 <lambdabot> Title: Hac 2008/Dates - HaskellWiki
11:41:53 <gwern> wow, ContArrow is *broken*. the hackage package doesn't even have the source files in it
11:42:07 <bringert> nominolo: I don't see your name on http://www.haskell.org/haskellwiki/Hac_2008/Dates
11:42:22 <ac> why are Setup.hs scripts taking so much longer to run than I remember?
11:42:44 * BMeph waits to read the best-selling book, "Broken ContArrow"
11:45:02 <BMeph> visof: Just be consistent with how you're using your function arguments. :)
11:45:48 * gwern emails the ContArrow author
11:47:17 <opqdonut> contarrow?
11:47:21 <opqdonut> @go contarrow
11:47:23 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
11:47:46 <ac> seriously, Setup configure is taking several minutes
11:47:54 <dcoutts> that's odd
11:48:11 <dcoutts> ac: configuring what package?
11:48:47 <dcoutts> (unless it's Cabal itself in which case it's expected since it'd be interpreting all the Cabal code)
11:48:59 <ac> dcoutts: zlib
11:49:05 <dcoutts> hmm
11:49:25 <dcoutts> ac: if you run with -v where is it getting stuck?
11:50:21 <ac> dcoutts: not seeing anything
11:50:24 <BMeph> Hey, dcoutts, do you know why cabal wouldn't be able to read a package?
11:50:45 <ac> doh
11:50:53 <ac> dcoutts: there was no #! line
11:51:01 <dcoutts> BMeph: you mean like some parse error?
11:51:04 <dcoutts> ac: :-)
11:51:20 <dcoutts> ac: most don't, use runghc Setup configure, or better yet install cabal-install
11:51:25 <BMeph> Specifically, I downloaded alex, and did "cabal info" on it; where it should state the packages is blank.
11:51:41 <ac> dcoutts: working on it! ;)
11:51:58 <BMeph> "These packages would be installed:
11:51:59 <ac> hence why zlib, and next http
11:52:03 <BMeph> "
11:52:05 <dcoutts> ac: ah :-)
11:52:44 <dcoutts> BMeph: cabal info is a bit of a misnomer at the moment, it's like cabal install but just says what would be installed, and you specified no packages and it said it'd install none :-)
11:52:57 <dcoutts> BMeph: it's a UI issue really, feel free to report a bug
11:54:43 <BMeph> Okay, because if I do that in a directory without a dist subdir, it complains about that.
11:55:24 <BMeph> Oh, good, it's doing the "cabal: Data.ByteString.Lazy.index: index too large: 0" thing again. :p
11:55:52 <dcoutts> BMeph: the dist thing is a bug in an older version of Cabal, use 1.2.3
11:56:16 <dcoutts> BMeph: when do you get that bug? is it if the index fails to download or something?
11:56:18 <qweqwe> pref::[a]->Int->Int->[[a]]
11:56:18 <qweqwe> pref [] _ _ = [[]]
11:56:18 <qweqwe> pref xs i len = if(i<len) then (take i xs):(pref xs (i+1) len)
11:56:18 <qweqwe>                                 else [take i xs]
11:56:35 <qweqwe> why at the else is should be [take]
11:56:36 <qweqwe> ?
11:56:38 <BMeph> I just did "cabal info alex"
11:57:12 <qweqwe> when i do take num xs i already get [numbers]
11:57:14 <gwern> excellent. now MissingH and ConfigFile should be fixed on Hackage soon
11:57:57 <dcoutts> BMeph: can you try: ls -l $HOME/.cabal/ and see if the index file is empty?
11:58:04 <BMeph> qweqwe: pref returns a list of lists at the end.
11:58:26 <qweqwe> yes
11:58:42 <BMeph> Aha - "ls: $HOME/.cabal/: No such file or directory"
11:58:50 <qweqwe> i am confused why at one place it with[] and after that without
11:59:05 <mauke> qweqwe: look at the type of (:)
11:59:26 <dcoutts> BMeph: hmm, I would have expected that it'd tell you that the index does not exist rather than that error message
11:59:30 <Toxaris> qweqwe: you can write "else (take i xs) : []" instead of "[take i xs]", then the two cases look more similar
11:59:42 <dcoutts> BMeph: I'd recommend using the latest version of cabal-install rather than the one from hackage
11:59:43 <BMeph> qweqwe: when you use take without the [], you're cons-ing it to another list-of-lists.
11:59:57 <dcoutts> BMeph: you can cabal update to download the package index
12:00:33 <qweqwe> ahh now i got you
12:01:25 <BMeph> dcoutts: No, I get "cabal: user error (Codec.Compression.Zlib: premature end of compressed stream)" when I try it.
12:01:55 <dcoutts> BMeph: sounds like the index is not getting downloaded correctly
12:02:26 <dcoutts> BMeph: does the $HOME/.cabal dir exist with the downloaded index in it yet? (under packages/)
12:02:39 <dcoutts> BMeph: it downloads the index file then uncompresses it
12:02:41 <ac> when will cabal-install automatically pull things out of VCSs? ;)
12:02:55 <qweqwe> how i can check the type of ":" ?
12:03:02 <int-e> @type (:)
12:03:02 <ac> :t (:)
12:03:05 <dcoutts> ac: when someone designs a spec for describing VCSs in the .cabal file
12:03:05 <lambdabot> forall a. a -> [a] -> [a]
12:03:05 <lambdabot> forall a. a -> [a] -> [a]
12:03:18 <ac> dcoutts: yeah, I remember talking about that a while back
12:03:37 <ac> qweqwe: you turn operators in to prefix functions by wrapping them in parens
12:04:10 <ac> qweqwe: and the reverse (turning prefix functions in to binary operators by wrapping them in ticks, like "1 `add` 2"
12:04:35 <BMeph> dcoutts: Hm, maybe it's just a Windows thing... :(
12:04:42 <ac> qweqwe: excuse my bad example, as add is not in the std libs
12:04:59 <dcoutts> BMeph: ah, you definitely need the latest version of cabal-install if you're working on windows
12:05:13 <qweqwe> ac: how i can check the type of ":" ?
12:05:18 <dcoutts> BMeph: since yes, there were some issues with windows line endings in earlier versions
12:05:23 <notsmack> @type (:)
12:05:24 <lambdabot> forall a. a -> [a] -> [a]
12:05:25 <opqdonut> @hoogle a -> [a] -> [a]
12:05:26 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
12:05:26 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
12:05:26 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
12:05:26 <ac> qweqwe: that was answered twice a few lines above
12:05:49 <ac> qweqwe: ":t (:)" in ghci, "@type (:)" in #haskell
12:06:01 <dcoutts> BMeph: I fixed them and tested it on windows, but that's only in the development version
12:06:16 <BMeph> dcoutts: So, where is the newest cabal-install, if it isn't on Hackage yet?
12:06:28 <dcoutts> BMeph: darcs.haskell.org/cabal-install
12:06:42 <dcoutts> it depends on the development version of Cabal too
12:06:48 <BMeph> Well, the newest *working* version... ;)
12:06:52 <dcoutts> which is in darcs.haskell.org/cabal
12:07:06 <qweqwe> @type (:)
12:07:10 <lambdabot> forall a. a -> [a] -> [a]
12:07:21 <qweqwe> @type :
12:07:21 <lambdabot> parse error on input `:'
12:07:42 <dcoutts> BMeph: the reason it's not on hackage yet is because it depends on the dev version of the Cabal lib which we're not ready to release just yet
12:07:45 <ac> qweqwe: it simply takes a head and a tail and returns the tail list with the head at the beginning. @type expects a function, not an operator
12:08:17 <notsmack> > (:) 3 [4,5]
12:08:18 <lambdabot>  [3,4,5]
12:08:37 <ac> > (:[4,5]) 3
12:08:38 <lambdabot>  [3,4,5]
12:09:01 <ac> > (3:) [4,5] -- :P
12:09:01 <lambdabot>  [3,4,5]
12:09:09 <BMeph> Okay, that makes sense. I guess this is similar to the problem with getting readline to work on Windows, too, eh?
12:09:31 <ac> > flip (:3) [4,5] :-PP
12:09:32 <lambdabot>   Not in scope: data constructor `PP'
12:09:36 <ac> > flip (:3) [4,5] -- :-PP
12:09:37 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `[a]'
12:09:40 <ac> damn.
12:10:02 <ac> > flip (:3) $ [4,5]
12:10:03 <lambdabot>  Couldn't match expected type `a -> c' against inferred type `[a1]'
12:10:15 <int-e> @type (:3)
12:10:16 <lambdabot> forall a. (Num [a]) => a -> [a]
12:10:31 <ac> guess you can't flip that can you
12:10:36 <int-e> > flip (:) [4,5] 3
12:10:37 <lambdabot>  [3,4,5]
12:10:52 * ac feels silly
12:11:18 <kaol> > (++[3]) [4,5]
12:11:19 <lambdabot>  [4,5,3]
12:11:22 <int-e> ac, you can flip (:), but you can't retroactively flip the (:) inside the (:3) application (which is equivalent to (flip (:) 3) or (\x -> x:3))
12:11:34 <ac> int-e: yeah I know, I'm just tired
12:13:10 <ac> qweqwe: make sense?
12:14:15 <amaron> anything similar to python's: random.shuffle(list)
12:14:30 <wolverian> perldoc -q shuffle
12:15:00 <mauke> haha
12:15:14 <amaron> in haskell...
12:15:31 <ac> amaron: how about "sortBy randomlist list"?
12:15:41 <jsnx> amaron: you have to do the schwatzian transform yourself, i think
12:15:54 <mauke> @where oleg
12:15:54 <lambdabot> http://okmij.org/ftp/
12:16:04 <ac> I bet everyone's going to tell me why that's bad now
12:16:15 <mauke> http://okmij.org/ftp/Haskell/#perfect-shuffle
12:16:16 <lambdabot> Title: Haskell Programming: Miscellanea
12:16:22 <Toxaris> ac: there is a nice article showing why it is bad
12:16:39 <ac> not to mention it doesn't fit the type signature
12:16:42 <jsnx> knuth has a whole big thing about this
12:17:00 <jsnx> in volume 1
12:17:00 <jsnx> it is a nice algorithm, but imperative
12:17:06 <jsnx> lolz, i am lagged
12:17:31 <BMeph> jsnx: Heh-heh, lagged cat is lagged. ;)
12:18:50 <ac> map snd (sortBy fst (zipWith randlist list))
12:18:55 <ac> that's more like what I meant
12:19:07 <ac> er, s/zipWith/zip/
12:19:15 <Toxaris> ac: what is "randlist"?
12:19:22 <ac> a list of random numbers ;)
12:19:29 <Toxaris> ac: like [0, 0, 0]?
12:19:36 <IvdSange1> isn;t that in a Monad?
12:20:36 <ac> IvdSange1: randlist you mean?
12:21:07 <hpaste>  psykon pasted "ghc-pkg list" at http://hpaste.org/4937
12:21:13 <ac> Toxaris: those don't look random to me ;)
12:21:22 <Toxaris> ac: well they are as random as every other list :)
12:21:27 <Toxaris> ac: but that's not the point.
12:21:37 <Cale> IvdSange1: You just need a supply of "random" numbers which you can treat as a parameter. Alternately, you can explicitly pass around the state for a pseudorandom number generator.
12:21:56 <Cale> IvdSangen: Of course, you can construct a monad to take care of that for you.
12:22:37 <ac> Toxaris: please disregaurd my obtuseness
12:22:48 <Toxaris> ac: ?
12:22:55 <IvdSangen> ofcourse we could be in a monad without seeing it in the type of this function, as it can be composed with return
12:23:25 <IvdSangen> so forgive my stupid remark ;)
12:24:08 <Toxaris> ac: do you mean sortBy (comparing fst)?
12:25:27 <ac> Toxaris: yeah
12:26:14 <ac> Toxaris: I'm think I'm being obtuse by missing the entire point of amaron's question
12:27:05 <Toxaris> ac: what does "obtuse" mean?
12:27:46 <ac> Toxaris: "dull; stupid;" ... not pointed or acute, blunt
12:27:48 * Toxaris looked it up and feels like it for not doing that earlier
12:28:04 <notsmack> @wn obtuse
12:28:05 <lambdabot> *** "obtuse" wn "WordNet (r) 2.0"
12:28:06 <lambdabot> obtuse
12:28:08 <lambdabot>      adj 1: of an angle; between 90 and 180 degrees [ant: {acute}]
12:28:10 <lambdabot>      2: of a leaf shape; rounded at the apex
12:28:12 <lambdabot>      3: lacking in insight or discernment; "too obtuse to grasp the
12:28:14 <lambdabot> [11 @more lines]
12:29:06 <Toxaris> nice. \bot knows everything :)
12:29:41 <ac> blaaarg: $ cabal install gd ... "Could not find module `Data.ByteString.Base'"
12:30:06 <ac> What's with this ByteString nonsense?
12:30:20 <shachaf> ac: That's the old bytestring.
12:30:42 <ac> bbbut gd requires the new bytestring
12:30:56 <gwern> the hackage one apparently doesn't
12:30:56 <shachaf> ac: Hmm, `cabal install gd` seems to work for me.
12:31:10 <gwern> (ditto)
12:31:10 <ac> I'm cursed
12:31:13 <shachaf> GHC 6.9.20080101.
12:31:55 <gwern> @where Util.Digraph
12:31:55 <lambdabot> I know nothing about util.digraph.
12:32:43 <shachaf> @go util.digraph
12:32:44 <lambdabot> http://www.augustsson.net/Darcs/Djinn/Util/Digraph.hs
12:33:27 <gwern> figures
12:33:30 <reteP> Hello: I'm new to Haskell and need to implement the Robinson Unification Algorithm (puh).  Does anyone know "resources" on how to do this with Haskell?
12:34:01 <byorgey> ac: did you do a 'cabal update' first?
12:34:09 <ac> for me the darcs version dies with "Graphics/GD.hsc:340:11: Not in scope: `B.toForeignPtr'" and the hackage version dies with the error above
12:34:22 <byorgey> reteP: what's that?
12:34:51 <reteP> Do you mean my nick? Or the Robinson Unification Algorithm? ;-)
12:35:12 <ac> byorgey: no... thanks!
12:35:24 <shachaf> > reverse "Robinson Unification Algorithm"
12:35:26 <byorgey> reteP: I meant the Robinson Unification Algorithm =)
12:35:29 <lambdabot>  "mhtiroglA noitacifinU nosniboR"
12:35:32 <reteP> :-)
12:35:42 <byorgey> > sort "Robinson Unification Algorithm"
12:35:43 <lambdabot>  "  ARUabcfghiiiiilmnnnnoooorstt"
12:36:00 <byorgey> ac: dunno if that's the problem but it's worth a try =)
12:36:00 <ac> lol
12:36:05 <ac> byorgey: it worked
12:36:08 <byorgey> =D
12:36:12 <shachaf> > unify "Robinson Unification Algorithm"
12:36:13 <lambdabot>  "reteP"
12:36:14 <ac> byorgey: hence my enthusiastic thanks
12:36:17 <reteP> Well...do some Prolog with Haskell...
12:36:33 <EvilTerran> use the type system! :D
12:36:43 <jsnx> reteP: how?
12:36:53 <EvilTerran> @go "Robinson Unification Algorithm"
12:36:54 <lambdabot> http://www.cs.rpi.edu/~freems/proj3/Unification_and_Variables.htm
12:36:54 <lambdabot> Title: Unification and Variables
12:37:20 <reteP> Found tons of stuff that use monands...@lambdabot: thx, I'll check it out...
12:37:25 <reteP> monads...
12:38:00 <jsnx> EvilTerran: thank you
12:38:03 <qweqwe> i have a problem writing the type of that function
12:38:17 <qweqwe> map (\f->f.f)[(\x->x+1),(\x->x+2)]
12:38:29 <mauke> :t map (\f->f.f)[(\x->x+1),(\x->x+2)]
12:38:30 <lambdabot> forall c. (Num c) => [c -> c]
12:38:33 <ac> qweqwe: gawd put some spaces in there
12:38:50 <EvilTerran> :t map (join (.)) [(+1), (+2)]
12:38:51 <lambdabot> forall b. (Num b) => [b -> b]
12:38:52 <patperry> does anyone have any tips on debugging stack overflows?  I'm not sure what to look for in the ghc profiler output
12:38:52 <opqdonut> :D
12:39:09 <EvilTerran> qweqwe, sections are rather handy here
12:39:36 <reteP> @lambdabot: well, that's about Prolog...thx anyway
12:39:36 <lambdabot> Unknown command, try @list
12:40:01 <shachaf> > sequence (map (join (.) [(+1),(+2)]) 5
12:40:02 <lambdabot> Unbalanced parentheses
12:40:09 <qweqwe> @list
12:40:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
12:40:33 <EvilTerran> reteP, lambdabot is a bot...
12:40:34 <shachaf> > sequence (map (join (.)) [(+1),(+2)]) 5
12:40:35 <lambdabot>  [7,9]
12:40:43 <ddarius> She hides it well
12:40:46 <EvilTerran> @vixen how are you today?
12:40:47 <lambdabot> i'm good, you?
12:40:50 * shachaf is a bot.
12:40:52 <byorgey> reteP: maybe this is useful? http://web.engr.oregonstate.edu/~erwig/HaskellRules/
12:40:53 <lambdabot> Title: Haskell Rules: Embedding Rule Systems in Haskell
12:41:40 <reteP> Thx byorgey..I'll look at that
12:41:44 <Toxaris> lambdabot is a shachaf.
12:42:10 <shachaf> @babel he en ◊©◊ó◊£
12:42:10 <lambdabot> Plugin `babel' failed with: Error: Language he not supported
12:42:51 <ac> @src Ptr
12:42:52 <lambdabot> data Ptr a = Ptr Addr#
12:43:00 <ac> what the heck does "Addr#" mean?
12:43:13 <qweqwe> but (\f->f.f) doesn"t it mean envoke a function twice on the [] ?
12:43:21 <qweqwe> map (\f->f.f)[(\x->x+1),(\x->x+2)]
12:43:28 <shachaf> qweqwe: On its argument.
12:43:30 <byorgey> patperry: maybe start here? http://haskell.org/haskellwiki/Stack_overflow
12:43:36 <shachaf> > (\f -> f . f) (+1) 5
12:43:37 <lambdabot>  7
12:43:59 <byorgey> patperry: there's various info on various pages in the wiki, you might have to poke around a bit =)
12:43:59 <shachaf> > (\f x -> f (f x)) (+1) 5
12:44:00 <lambdabot>  7
12:44:42 <ac> @pl (\f x -> f (f x)) (+1) 5
12:44:42 <lambdabot> 7
12:44:49 <ac> @pl (\f x -> f (f x))
12:44:49 <lambdabot> join (.)
12:45:00 <ac> :t join
12:45:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:45:09 <qweqwe> thanks
12:45:16 <patperry> byorgey: thanks for the pointer.  I'll look around
12:45:19 <amaron> ac: your shuffle worked well, tnx
12:45:25 <ac> > join (.) (+1) 5
12:45:26 <lambdabot>  7
12:45:36 <EvilTerran> ?type join :: (a -> a -> b) -> a -> b
12:45:36 <lambdabot> forall a b. (a -> a -> b) -> a -> b
12:45:39 <shachaf> ac: join f x = f x x, in (r ->).
12:45:45 <ac> amaron: oh, I thought I was missing the point of your question ;)
12:46:00 <Toxaris> shachaf: my xchat has serious problems with hebrew text. ◊©◊ó◊£ is reversed when selected :(
12:46:34 <shachaf> Toxaris: It's reversed for me too, in irssi/urxvt. :-)
12:46:52 <visof> @src (:)
12:46:52 <lambdabot> Source not found. I've seen penguins that can type better than that.
12:46:59 <visof> @src cons
12:46:59 <lambdabot> Source not found. Where did you learn to type?
12:47:02 <ac> amaron: just make sure that precision of your random list corresponds to the number of elements you're shuffling
12:47:21 <ac> amaron: otherwise you end up with only a subset of possible shufflings
12:47:31 <Toxaris> shachaf: and what does it mean?
12:47:41 <shachaf> Toxaris: "Seagull".
12:47:43 <EvilTerran> @erc []
12:47:43 <lambdabot> Maybe you meant: rc src
12:47:57 <EvilTerran> @src []
12:47:57 <lambdabot> data [] a = [] | a : [a]
12:48:00 <EvilTerran> @help rc
12:48:00 <lambdabot> rc name. Read a file of commands (asynchonously). FIXME: better name.
12:49:31 <visof> i have function and i want to simplify it, can anyone help me?
12:49:45 <Toxaris> shachaf: nice name.
12:49:48 <EvilTerran> @paste
12:49:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:49:51 <opqdonut> paste it somewhere
12:49:52 <opqdonut> yep
12:49:58 <patperry> is that a way to get a stack trace prior to a stack overflow?
12:50:05 <opqdonut> and use @pl, @undo and others
12:50:37 <ddarius> There are two ways.
12:51:31 <hpaste>  visof pasted "simplify it" at http://hpaste.org/4938
12:52:23 <shachaf> visof: Well, (,,) tuples are a little hard to do much with @pl-ly.
12:52:24 <Cale> visof: I doubt you're going to find anything simpler than that.
12:52:30 <shachaf> visof: Is that not simple enough?
12:52:33 <patperry> typo; is *there* a way to get a stack trace prior to overflow?
12:52:34 <opqdonut> yeh that's pretty nice
12:52:48 <opqdonut> you can of course shorten and obfuscate it :P
12:53:00 <Cale> If it was a function on lists, rather than a function of three parameters returning a tuple, then there would be a nice way to generalise it.
12:53:12 <opqdonut> Cale: indeed
12:53:19 <ac> amaron: meaning, if your randlist is a list of bools, and you have more than two in your list, it's not a random shuffling
12:53:44 <Cale> foo [] = []; foo (x:xs) = map (x ++) (x:xs)
12:53:48 <visof> Cale how can we generalise it for any number of arguments
12:53:58 <visof> ok
12:54:04 <Cale> You can't. But you can write what I just wrote.
12:55:22 <Cale> > let foo [] = []; foo (x:xs) = map (x ++) (x:xs) in foo ["hello","there","world"]
12:55:25 <lambdabot>  ["hellohello","hellothere","helloworld"]
12:57:41 <nominolo> bringert: k.  seems like any date is fine for the great majority
12:58:05 <shachaf> Cale: Is there a nice way to write that without the [] special-case?
12:58:17 <sclv_> ac: even if you only have two it's a pretty awful shuffle.
12:58:46 <Cale> shachaf: Well, you could use head.
12:59:00 <Cale> > let foo xs = map (head xs ++) xs in foo []
12:59:00 <lambdabot>  []
12:59:23 <Cale> I just don't like head and tail all that much :)
13:00:44 <Toxaris> > liftM3 (,,) (++ a) (++ b) (++ c) a ("hello", "there", "world")
13:00:45 <lambdabot>   Not in scope: `a'
13:00:58 <Toxaris> > \(a, b, c) -> liftM3 (,,) (++ a) (++ b) (++ c) a $ ("hello", "there", "world")
13:00:59 <lambdabot>  Couldn't match expected type `a -> b'
13:01:00 <Cale> It's just slightly less obvious that it's safe.
13:01:16 <Toxaris> > (\(a, b, c) -> liftM3 (,,) (++ a) (++ b) (++ c) a) ("hello", "there", "world")
13:01:17 <lambdabot>  ("hellohello","hellothere","helloworld")
13:01:22 <ac> sclv_: no it's not... there are only two options... reverse it or not reverse the list. They're both equally likely
13:01:31 * Toxaris obfuscated it a bit
13:01:49 <shachaf> Toxaris: The arguments weren't in a tuple.
13:01:53 <visof> ok Cale can we do this for 3-case let me show you what is 3-case mean
13:02:04 <qweqwe> i still get error on it
13:02:15 <qweqwe> lfunc:: (Num a) => [a -> a]
13:02:15 <qweqwe> lfunc f xs = map (\f->f.f)[(\x->x+1),(\x->x+2)]
13:02:17 <shachaf> @pl \a b c -> liftM3 (,,) (++a) (++b) (++c) a
13:02:18 <lambdabot> flip =<< (flip .) . flip flip (flip (++)) . ((.) .) . (. flip (++)) . liftM3 (,,) . flip (++)
13:02:26 <visof> the arguments in the last example is    a b c right
13:02:42 <visof> then the result take the form aa  , ab , ac
13:02:44 <shachaf> @pl \a b c -> (a ++ a, a ++ b, a ++ c)
13:02:44 <lambdabot> ap (flip . ((.) .) . ap ((.) . (,,) . join (++)) (++)) (++)
13:03:12 <ac> sclv_: [0,0], [0,1], [1,0], [1,1]... nevermind you're right. It's a 3/4 it won't get reversed
13:03:15 <visof> i want the result take this form    abc , bca , ..........
13:03:37 <ac> sclv_: depending on the sorting algorithm I guess
13:03:38 <Cale> qweqwe: The type you've given appears wrong...
13:03:40 <shachaf> qweqwe: lfunc is a function that takes f and xs.
13:03:55 <visof> Cale do you understand what i mean?
13:03:55 <qweqwe> ok
13:03:59 <shachaf> @ty let lfunc :: (Num a) => (a -> a) -> [a] -> [a -> a]; lfunc f xs = map (\f->f.f)[(\x->x+1),(\x->x+2)] in lfunc
13:04:00 <lambdabot> forall a. (Num a) => (a -> a) -> [a] -> [a -> a]
13:04:10 <Cale> qweqwe: That says that lfunc is a list of functions [a -> a] where a is some numeric type.
13:04:30 <ac> sclv_: is that what you meant?
13:04:49 <Cale> visof: You want all permutations of a list?
13:04:58 <visof> ya
13:05:04 <sclv_> ac: yep
13:05:14 <qweqwe> shachaf : i still have error there
13:05:40 <Cale> visof: Okay. So probably the best way to start is to think recursively. It's easy to get the list of permutations of the empty list, it's just [[]]
13:05:55 <sclv_> you need a range large enough that collisions are statistically very improbable.
13:06:04 <Cale> visof: So if your list is (x:xs), what are the permutations of that, in terms of the permutations of xs?
13:06:28 <ac> visof: is this a homework problem?
13:06:40 <Cale> ac: no, he's learning Haskell on his own.
13:06:50 <visof> ac yep
13:06:52 <ac> ah, it sounded like a classic ;)
13:07:13 <visof> Cale what do you mean?
13:07:26 <visof> Cale simply
13:08:13 <Cale> Well, one way is to take x and insert it in each possible place in each permutation of xs.
13:08:27 <visof> ya
13:09:14 <Cale> So you might start out by writing the function which takes a value x, and a list xs, and produces the list of lists resulting from inserting x into each place.
13:09:17 <Cale> For example:
13:09:37 <visof> x ++ fst (xs) ++ fst ( snd xs).........
13:09:40 <Cale> insertions 'a' "xxx" = ["axxx","xaxx","xxax","xxxa"]
13:09:56 <visof> ya
13:09:58 <Cale> fst and snd apply to pairs, not lists
13:10:07 <visof> ok
13:10:13 <shachaf> Are you thinking of car and cdr? :-)
13:10:29 <notsmack> (and ++ applies to lists, not the individual 'x')
13:10:34 <ski_> (when i figured out how to systematically enumerate permutations (by hand), i used the selection method .. i wonder if that's more common ?)
13:10:53 <Cale> Selection is actually probably better in Haskell.
13:12:12 <Cale> visof: Another way you can break down the problem is to pick some element y from your nonempty list xs (in all possible ways), and then pick a permutation ys of the remaining elements, and the resulting permutation is y:ys
13:12:45 <Cale> (you can use a list comprehension to do that nicely)
13:13:23 <Cale> You'll need a function select, which takes a list, and returns a list of pairs consisting of an element of the list, together with the remainder of the elements:
13:14:01 <Cale> select "abcd" = [('a',"bcd"), ('b',"acd"), ('c',"abd"), ('d',"abc")]
13:14:23 <Cale> (it should be in the list library, but it is not)
13:14:37 <Cale> select [] = []
13:15:22 <Cale> select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
13:16:15 <visof> insertions way is good for me
13:16:43 <Cale> Okay, take a shot at that and let us know if you need more help.
13:17:14 <visof> Cale ok , thanks
13:20:00 <qweqwe> what is wrong here ?
13:20:01 <qweqwe> takefirsthalf::[a]->[a]
13:20:01 <qweqwe> takefirsthalf [] = []
13:20:01 <qweqwe> takefirsthalf xs = take ((length xs)/2) xs
13:20:14 <qweqwe> Instance of Fractional Int required for definition of takefirsthalf
13:20:33 <mauke> qweqwe: / doesn't work on ints
13:20:44 <seydar> div to the rescue!
13:20:53 <qweqwe> :)
13:20:57 <mauke> you don't need the first equation
13:21:18 <qweqwe> do you know any other elegant way to do it ?
13:21:30 <opqdonut> not really
13:24:42 <Cale> I can think of a semi-elegant way.
13:25:29 <qweqwe> shoot
13:25:55 <Cale> takeEveryOther [] = []; takeEveryOther [x] = []; takeEveryOther (x:y:xs) = x : takeEveryOther xs; takeFirstHalf xs = map fst (zip xs (takeEveryOther xs))
13:26:18 <Cale> At least it doesn't involve computing the length, and it operates lazily.
13:26:36 <Cale> Or if you prefer,
13:26:45 * EvilTerran tends to call that "evens", and the dual "odds"
13:26:53 <Cale> takeFirstHalf xs = zipWith const xs (takeEveryOther xs)
13:27:08 <EvilTerran> evens [] = []; evens (x:xs) = x : odds xs; odds [] = []; odds (x:xs) = evens xs
13:27:33 <EvilTerran> Cale, ooh, cunning
13:28:02 <roconnor> takeFirstHalf xs = let {helper [] _ = []; helper (_:_:ys) (z:zs) = z:(helper ys zs)} in helper xs xs
13:28:31 <roconnor> hmm, not quite right
13:28:50 <roconnor> needs helper [_] _ = [] as well
13:29:22 <EvilTerran> and it works on infinite lists, unlike take.(`div`2)=<<length
13:30:35 <qweqwe> any idea how i can take the secound half ?
13:31:14 <EvilTerran> well, that'd be _|_ for infinite lists anyway, so the `div` version would work
13:31:22 <EvilTerran> although there may be a better way of doing it
13:31:23 <roconnor> now I'd be tempted to splitAt (length l `div` 2)
13:31:31 <Toxaris> > let half xs = map fst . zip xs . takeWhile (not . null) . iterate (drop 2) $ xs in half "abcdef"
13:31:34 <lambdabot>  "abc"
13:31:52 <EvilTerran> yeah, if you always want both, that (roconnor's)'s probably better
13:31:56 <hpaste>  (anonymous) annotated "no proxy" with "(no title)" at http://hpaste.org/4939#a1
13:33:08 <EvilTerran> firstHalf xs = zipWith const xs (evens xs); secondHalf xs = foldr (const tail) xs (odds xs)
13:33:39 <EvilTerran> (using evens in one and odds in the other so the middle element doesn't end up in both)
13:33:46 <EvilTerran> (in the case of an odd-length list)
13:34:15 <EvilTerran> @let evens [] = []; evens (x:xs) = x : odds xs; odds [] = []; odds (x:xs) = evens xs
13:34:19 <lambdabot> Defined.
13:34:58 <EvilTerran> @let firstHalf xs = zipWith const xs (odds xs); secondHalf xs = foldr (const tail) xs (evens xs)
13:34:58 <lambdabot> Defined.
13:35:10 <EvilTerran> > firstHalf &&& secondHalf $ "testing"
13:35:11 <lambdabot>  ("tes","ing")
13:35:18 <EvilTerran> huh.
13:35:32 <EvilTerran> > evens &&& odds $ "testing"
13:35:32 <lambdabot>  ("tsig","etn")
13:35:35 <sarah__> &&&?
13:35:41 <kmcallister> :t &&&
13:35:42 <shachaf> sarah__: From Control.Arrow.
13:35:42 <lambdabot> parse error on input `&&&'
13:35:45 <kmcallister> :t (&&&)
13:35:46 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:35:55 <resiak> \ a:b:c:d:... -> ([a,c,...],[b,d,...]) doesn't have a standard name, does it?
13:36:05 <shachaf> (&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
13:36:08 <shachaf> In (->).
13:36:16 <EvilTerran> (&&&) :: Arrow (~>) => (a ~> b) -> (a ~> c) -> (a ~> (b,c))
13:36:29 <EvilTerran> resiak, no
13:36:46 <EvilTerran> i call it halve, myself (and phrase it much like evens/odds above)
13:36:58 <resiak> yeah, i was just writing a 'halve' funciton :)
13:37:30 <EvilTerran> @let halve [] = []; halve (x:xs) = (x:zs,ys) where (ys,zs) = halve xs
13:37:43 <lambdabot> Couldn't match expected type `[a]' against inferred type `(a1, b)'
13:37:52 <EvilTerran> @let halve [] = ([],[]); halve (x:xs) = (x:zs,ys) where (ys,zs) = halve xs
13:37:53 <lambdabot> Defined.
13:37:57 <EvilTerran> > halve "testing"
13:37:58 <lambdabot>  ("tsig","etn")
13:38:15 <EvilTerran> @check liftM2 (==) (evens &&& odds) halve
13:38:15 <lambdabot>  Add a type signature
13:38:20 <EvilTerran> @check liftM2 (==) (evens &&& odds) halve :: [Int] -> Bool
13:38:21 <lambdabot>  OK, passed 500 tests.
13:38:36 <Heffalump> (map fst *** map fst) . partition even . zip [0..]
13:38:53 <Heffalump> IM map snd, not map fst. And even might need a definition or to be (==0) . (`mod` 2)
13:38:59 <shachaf> Heffalump: Probably (cycle [0,1]) is better.
13:39:07 <shachaf> Heffalump: The numbers would get big eventually. :-)
13:39:13 <Heffalump> cycle [True, False] then
13:39:18 <Heffalump> this isn't C, you know
13:39:40 <shachaf> Heffalump: I was leaving the rest as it was. :-)
13:39:48 <seydar> what does 'inferred type `m Float' ' mean?
13:39:58 <resiak> hrm, d'oh, i actually want a list of pairs not a pair of lists
13:40:04 <Toxaris> > (foldr (.) id . zipWith ($) (cycle [first, second]) . map (:)) "abcdefghijklm" ([], [])
13:40:05 <lambdabot>  ("acegikm","bdfhjl")
13:40:06 <EvilTerran> join (***) (map snd) . partition (even.fst) . zip (cycle [True,False]) -- =]
13:40:06 <shachaf> seydar: That the type that was inferred was "m Float"?
13:40:14 <Heffalump> zip IYF...
13:40:15 <shachaf> seydar: Perhaps you can give more context.
13:40:18 <seydar> no, what is m float?
13:40:22 <resiak> true.
13:40:39 <shachaf> seydar: m is probably a Monad.
13:40:48 <EvilTerran> resiak, what do you want exactly?
13:40:57 <shachaf> seydar: So it's something like [Float], Maybe Float, IO Float.
13:41:04 <EvilTerran> [1,2,3,4,5] -> [(1,2),(3,4)]?
13:41:06 <Heffalump> how many Oxford students does it take to split a list?
13:41:08 <seydar> ooh
13:41:15 <resiak> heh
13:41:35 <resiak> EvilTerran: yeah, thinking about it.  it's obviously trivial to write, but i kind of hoped it had a name :)
13:42:05 <EvilTerran> > evens . (zip `ap` drop 1) $ "testing"
13:42:05 <lambdabot>  [('t','e'),('s','t'),('i','n')]
13:42:13 <EvilTerran> there you go :D
13:42:16 <seydar> shachaf: if i have a recursive function, and use return as a base case, will it just drop out?
13:42:30 <EvilTerran> ... that's not what return means in haskell
13:42:32 <EvilTerran> ?type return
13:42:33 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
13:42:34 <shachaf> seydar: return doesn't do what you think it does.
13:42:49 <Heffalump> seydar: no.
13:42:51 <seydar> that would explain the funky error
13:42:58 <resiak> I'm still amazed that   whileM :: [m Bool] -> m (); whileM (a:as) = x <- a; when x $ whileM as   doesn't have a name
13:42:59 <mauke> seydar: return is a virtual constructor
13:43:15 <seydar> im scared now
13:43:25 <shachaf> seydar: It "wraps" a value in a monad.
13:43:26 <EvilTerran> mauke, i'm sure a line like that'll make it much clearer ;P
13:43:27 <shachaf> seydar: Why?
13:43:31 <shachaf> > return 1 :: [Int]
13:43:32 <lambdabot>  [1]
13:43:34 <shachaf> > return 1 :: Maybe Int
13:43:34 <lambdabot>  Just 1
13:43:40 <shachaf> > return 1 :: IO Int
13:43:41 <lambdabot>  <IO Int>
13:43:43 <idnar> @pl whileM (a:as) = x <- a; when x $ whileM as
13:43:43 <lambdabot> (line 1, column 23):
13:43:43 <lambdabot> unexpected ";"
13:43:43 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
13:43:56 <EvilTerran> idnar, @pl can't do pattern-matching
13:43:59 <EvilTerran> iirc
13:44:07 <EvilTerran> er... multiple cases, i mean
13:44:13 <seydar> hold me! I dont want to die!
13:44:18 <EvilTerran> ?type foldM
13:44:18 <shachaf> @. pl undo whileM (a:as) = x <- a; when x $ whileM as
13:44:19 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:44:19 <lambdabot> Parse error at "=" (column 15)
13:44:20 <idnar> isn't that just one case?
13:44:27 <resiak> @pl f (a:as) = a >>= flip when (f as)
13:44:28 <lambdabot> f = fix ((`ap` tail) . (. head) . flip ((.) . (>>=)) . (flip when .))
13:44:30 <resiak> aii
13:44:31 <idnar> @pl f a = a
13:44:31 <lambdabot> f = id
13:44:37 <shachaf> @. pl undo whileM (a:as) = do { x <- a; when x $ whileM as }
13:44:38 <lambdabot> whileM = fix ((`ap` tail) . (. head) . flip ((.) . (>>=)) . (flip when .))
13:44:50 <EvilTerran> idnar, ah, ignore me. sorry, the missing "do" made me think the bit after the ; was another case
13:44:53 <EvilTerran> DO NOT WANT
13:44:56 <idnar> heh
13:45:01 <idnar> I didn't even know you could do that
13:45:10 <shachaf> idnar: Do what?
13:45:11 <EvilTerran> ?type let whileM (a:as) = x <- a; when x $ whileM as in whileM
13:45:15 <lambdabot> parse error on input `<-'
13:45:20 <EvilTerran> ?type let whileM (a:as) = do x <- a; when x $ whileM as in whileM
13:45:20 <lambdabot> forall (m :: * -> *). (Monad m) => [m Bool] -> m ()
13:45:34 <idnar> shachaf: well, wouldn't there normally be a do {} around that?
13:45:40 <shachaf> idnar: Yes.
13:45:44 <r3m0t> @unpl \x -> x
13:45:44 <lambdabot> \ x -> x
13:45:51 <r3m0t> @unpl \x y -> y
13:45:51 <lambdabot> \ x y -> y
13:46:05 <EvilTerran> ?src when
13:46:05 <lambdabot> when p s = if p then s else return ()
13:46:08 <shachaf> idnar: resiak also didn't include the (Monad m) =>; that was meant for humans to parse.
13:46:14 <r3m0t> @pl \x y -> y
13:46:14 <lambdabot> const id
13:46:24 <r3m0t> @pl \x y -> (==x).(!!y)
13:46:25 <lambdabot> (. flip (!!)) . (.) . (==)
13:46:26 <idnar> shachaf: oh, right, I see
13:46:31 <EvilTerran> ?type foldM when (return ())
13:46:31 <lambdabot>     Couldn't match expected type `Bool' against inferred type `()'
13:46:31 <lambdabot>       Expected type: Bool -> m () -> m Bool
13:46:31 <lambdabot>       Inferred type: Bool -> m () -> m ()
13:46:38 <EvilTerran> ?type foldM when
13:46:39 <lambdabot>     Couldn't match expected type `Bool' against inferred type `()'
13:46:39 <lambdabot>       Expected type: Bool -> m () -> m Bool
13:46:39 <lambdabot>       Inferred type: Bool -> m () -> m ()
13:46:43 <EvilTerran> ?type foldM (flip when)
13:46:43 <lambdabot>     Couldn't match expected type `m ()' against inferred type `()'
13:46:43 <lambdabot>       Expected type: m () -> Bool -> m (m ())
13:46:43 <lambdabot>       Inferred type: m () -> Bool -> m ()
13:46:47 <EvilTerran> ...
13:46:48 <idnar> @src foldM
13:46:49 <lambdabot> foldM _ a []     = return a
13:46:49 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
13:46:55 <shachaf> @ty foldM
13:46:56 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:46:57 <shachaf> @ty when
13:46:57 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
13:47:09 <idnar> @undo whileM (a:as) = do { x <- a; when x $ whileM as }
13:47:09 <lambdabot> whileM (a : as) = a >>= \ x -> when x $ whileM as
13:47:41 <r3m0t> @pl \y -> (==x).(!!y)
13:47:41 <lambdabot> ((x ==) .) . flip (!!)
13:49:06 <idnar> hmm
13:49:19 <resiak> hrm, or i can just do the termination before monadifying the list :)
13:49:28 <idnar> @type foldM
13:49:28 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:49:37 <idnar> @type when
13:49:38 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
13:51:08 * EvilTerran determines that foldM isn't suitable
13:52:10 <idnar> oh, shachaf just did those two
13:52:14 <idnar> man, I can't read tonight
13:53:05 <idnar> @type foldr
13:53:06 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:53:17 <Saizan> we lack a lot of truly monadic combinators, most of Control.Monad is applicative..
13:53:37 <idnar> @type foldr1
13:53:37 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
13:54:02 <idnar> @type foldr when (return ())
13:54:03 <lambdabot> forall (m :: * -> *). (Monad m) => [Bool] -> m ()
13:54:24 <idnar> @type liftM when
13:54:25 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 Bool -> m1 (m () -> m ())
13:55:31 <idnar> @. pl undo \mx a b -> { x <- mx; when x a b }
13:55:31 <lambdabot> Parse error at "{" (column 12)
13:55:42 <EvilTerran> do
13:55:48 <idnar> @. pl undo \mx a b -> do { x <- mx; when x a b }
13:55:49 <lambdabot> (. (flip . flip when)) . (.) . (>>=)
13:55:51 <EvilTerran> ?type foldr (\m x -> do p <- m; when p x) (return ())
13:55:53 <lambdabot> forall (t :: * -> *). (Monad t) => [t Bool] -> t ()
13:56:05 <idnar> success?
13:56:10 <hpaste>  patperry pasted "memory leak" at http://hpaste.org/4940
13:56:13 <EvilTerran> ugly success, but i think so
13:56:25 <patperry> can someone tell me why this leaks memory, and how to fix it?
13:56:28 <resiak> a-ha!
13:56:31 <idnar> @undo \mx a b -> do { x <- mx; when x a b }
13:56:31 <lambdabot> \ mx a b -> mx >>= \ x -> when x a b
13:56:53 <idnar> it seems like there should be some nicer way to do that
13:57:09 <resiak> it does
13:57:16 <EvilTerran> the difficulty is when's first parameter not being monadic
13:57:19 <resiak> it's only meant to model C's 'break' statement
13:57:20 <trofimovich> @q how to build you with GHC-6.8.2?
13:57:21 <lambdabot> Maybe you meant: quit quote . ? @ v
13:57:39 <EvilTerran> if that weren't the case, it'd just be foldr when (return ()), i think
13:57:57 <idnar> hmm
13:58:08 <EvilTerran> ?type (\m x -> do p <- m; when p x)
13:58:08 <lambdabot> forall (t :: * -> *). (Monad t) => t Bool -> t () -> t ()
13:58:16 <EvilTerran> ?type liftM2 when
13:58:17 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 Bool -> m1 (m ()) -> m1 (m ())
13:58:27 <EvilTerran> ?type join . liftM2 when
13:58:28 <lambdabot>     Occurs check: cannot construct the infinite type:
13:58:28 <lambdabot>       m = (->) (m (m1 ()))
13:58:28 <lambdabot>     Probable cause: `liftM2' is applied to too many arguments
13:58:31 <EvilTerran> hm
13:58:38 <EvilTerran> ?type (join .) . liftM2 when
13:58:38 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m (m ()) -> m ()
13:58:50 <EvilTerran> ?type (join .) . liftM when
13:58:50 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m ())
13:58:50 <lambdabot>     Probable cause: `liftM' is applied to too many arguments
13:58:50 <lambdabot>     In the second argument of `(.)', namely `liftM when'
13:59:06 <EvilTerran> ?type (join .) . liftM2 when . (. return)
13:59:07 <lambdabot> forall a (m :: * -> *). (Monad m) => (m a -> Bool) -> (a -> a -> ()) -> a -> ()
13:59:10 <EvilTerran> er
13:59:18 <EvilTerran> ?type (join .) . (. return) . liftM2 when
13:59:19 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
13:59:24 <EvilTerran> hehe
14:00:39 <seydar> how do I do do an if then statement and match an empty list?
14:00:49 <seydar> ie, if x == []
14:00:53 <trofimovich> can someone share patches for lambdabot and ghc-6.8.x? thanks!
14:01:23 <Toxaris> > null []
14:01:25 <lambdabot>  True
14:01:50 <Toxaris> > seydar: either use null, or (imho better) use case instead of if
14:01:51 <lambdabot>  Parse error at "case" (column 47)
14:01:55 <idnar> @let whileM (a:as) = do { x <- a; when x $ whileM as } in runWriter $ whileM [tell '1' >> return True, tell '2' >> return False, tell '3' >> return True]
14:01:56 <lambdabot>  Parse error
14:01:59 <idnar> > let whileM (a:as) = do { x <- a; when x $ whileM as } in runWriter $ whileM [tell '1' >> return True, tell '2' >> return False, tell '3' >> return True]
14:02:00 <lambdabot>   add an instance declaration for (Monoid Char)
14:02:05 <idnar> oops
14:02:06 <idnar> too much Python
14:02:30 <seydar> Toxaris: but how do I do it in an if-then?
14:02:39 <seydar> in ruby, I can use ===
14:03:14 <idnar> > let whileM (a:as) = do { x <- a; when x $ whileM as } in runWriter $ whileM [tell [1] >> return True, tell [2] >> return False, tell [3] >> return True]
14:03:15 <lambdabot>  ((),[1,2])
14:03:23 <Toxaris> > let x = [] in if null x then "seydar: as I said, use null" else "will not be choosen"
14:03:23 <allbery_b> if null xs then ...
14:03:23 <lambdabot>  "seydar: as I said, use null"
14:03:35 <idnar> > let whileM foldr (\m x -> do p <- m; when p x) (return ()) in runWriter $ whileM [tell [1] >> return True, tell [2] >> return False, tell [3] >> return True]
14:03:35 <lambdabot>  Parse error at "in" (column 60)
14:03:42 <idnar> > let whileM = foldr (\m x -> do p <- m; when p x) (return ()) in runWriter $ whileM [tell [1] >> return True, tell [2] >> return False, tell [3] >> return True]
14:03:43 <lambdabot>  ((),[1,2])
14:03:57 <idnar> (ok, I'm done)
14:04:04 <seydar> lambdabot: but didn't it throw an error for you?
14:04:37 * allbery_b is confused
14:04:44 <allbery_b> throw what error?
14:04:53 <seydar> Parse error at "case" (column 47)
14:04:55 <Toxaris> seydar: lambdabot is just a bot, I made her answer to you by the line starting with "> ". other people made her throw an error. unkind people they are.
14:05:05 <Saizan> trofimovich: mux linked me this patch http://mu.org/~mux/lambdabot-ghc-6.8.2.patch
14:05:09 <seydar> ok
14:05:15 <EvilTerran> > let whileM = foldr ((join.) . (.return) . liftM2 when) (return ()) in runWriter . whileM . map (tell.return &&& return) $ [(1,True),(2,True),(3,False),(4,True)]
14:05:16 <lambdabot>  Couldn't match expected type `Bool' against inferred type `m a'
14:05:21 <seydar>  so its if null xs then ....
14:05:22 <EvilTerran> oh, never mind
14:05:26 <trofimovich> Saizan: thanks !
14:05:41 <EvilTerran> > let whileM = foldr ((join.) . (.return) . liftM2 when) (return ()) in runWriter . whileM . map (uncurry(>>).(tell.return &&& return)) $ [(1,True),(2,True),(3,False),(4,True)]
14:05:42 <lambdabot>  Couldn't match expected type `Bool' against inferred type `(a, b)'
14:05:42 <Saizan> trofimovich: you also need latest darcs version of hs-plugins
14:05:49 <EvilTerran> arghblahblahblah
14:05:49 <trofimovich> i know
14:05:54 <EvilTerran> @src null
14:05:54 <lambdabot> null []     = True
14:05:54 <lambdabot> null (_:_)  = False
14:06:01 <trofimovich> i've already built them
14:06:28 <Saizan> from this? http://code.haskell.org/~dons/code/hs-plugins
14:06:29 <lambdabot> Title: Index of /~dons/code/hs-plugins
14:06:51 <seydar> Toxaris: so how do I test if a function returns a [] ?
14:06:56 <dmwit> null [] = True; null _  = False -- save 8 characters!  collect the whole set
14:07:05 <shachaf> seydar: With null?
14:07:24 <trofimovich> i'm afraid no
14:07:27 <idnar> dmwit: heehee
14:07:34 <seydar> i tested it with ' if null (function)
14:07:43 <Toxaris> seydar: if null (f 42) then ..., assuming f is a function from numbers to lists
14:08:19 <r3m0t> @src null.tail
14:08:20 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:08:22 <seydar> it is. but that throws me an error
14:08:30 <r3m0t> > (null.tail) [5]
14:08:33 <lambdabot>  True
14:08:42 * r3m0t could have used that a while ago
14:09:09 <trofimovich> Saizan: "http://www.cse.unsw.edu.au/~dons/code/hs-plugins" - used this stuff (a little patched to make it build)
14:09:10 <dmwit> r3m0t: It's dangerous, though.
14:09:10 <lambdabot> Title: Index of /~dons/code/hs-plugins
14:09:21 <seydar> "if null (findMin (filter (< f) rest)) " throws  me an error from the depths of hell
14:09:28 <dmwit> > (null.tail) []
14:09:29 <lambdabot>  Exception: Prelude.tail: empty list
14:09:39 <Toxaris> > (null . drop 1) []
14:09:41 <lambdabot>  True
14:09:56 <seydar> what does the  . do?
14:09:58 <dmwit> seydar: You need some "then" and "else" clauses, at least. ;-)
14:09:59 <r3m0t> dmwit: not in my case it wasn't
14:10:09 <dmwit> seydar: function composition
14:10:24 <seydar> dmwit: i have them, but didn't want to paste it all here
14:10:28 <dmwit> :t findMin
14:10:30 <seydar> if null (findMin (filter (< f) rest)) []
14:10:31 <seydar>                      then f
14:10:31 <seydar>                      else findMin (filter (< f) rest)
14:10:33 <lambdabot> Not in scope: `findMin'
14:10:45 <r3m0t> @src minimum
14:10:46 <lambdabot> minimum [] = undefined
14:10:46 <lambdabot> minimum xs = foldl1 min xs
14:10:54 <seydar> NOOOOOO
14:10:55 <dmwit> Oh, there's your problem, that's not well-typed!
14:10:57 <seydar> don't tell me!
14:11:15 <seydar> but where was my typing error?
14:11:36 <dmwit> findMin doesn't return a list, probably
14:11:52 <Toxaris> seydar: the parens are wrong?
14:11:59 <dmwit> Also, null doesn't take two arguments.
14:12:06 <Toxaris> seydar: if null (...) [] then :(
14:12:19 <Toxaris> seydar: you want if null (... []) then   instead
14:12:57 <dmwit> But, this function has very strange semantics.
14:13:25 <dmwit> if null rest then f else minimum rest -- simpler, and probably does the same thing
14:13:38 <Toxaris> seydar: but what you really want is    (findMin (f : rest))
14:14:17 <dmwit> yes
14:14:34 <dmwit> Toxaris: cute! =)
14:16:14 <Toxaris> > let foo atLeast = minimum . (atLeast :) in foo 5 [27, 42]
14:16:15 <lambdabot>  5
14:16:23 <Toxaris> > let foo atLeast = minimum . (atLeast :) in foo 5 [3, 1, 4, 1, 5]
14:16:24 <lambdabot>  1
14:17:32 <dmwit> > let foo = (minimum .) . (:) in foo 5 []
14:17:33 <lambdabot>  5
14:18:46 <trofimovich> @version
14:18:46 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
14:18:46 <lambdabot> darcs get http://code.haskell.org/lambdabot
14:21:48 <Toxaris> > let foo atLeast = foldl' min atLeast in (foo 5 [27, 42], foo 5 [3, 1, 4, 1]
14:21:48 <lambdabot> Unbalanced parentheses
14:21:51 <Toxaris> > let foo atLeast = foldl' min atLeast in (foo 5 [27, 42], foo 5 [3, 1, 4, 1])
14:21:52 <lambdabot>  (5,1)
14:22:44 <Toxaris> dmwit, seydar: that's how you would do it in c, just initialize the result variable for the minimum loop with the lower bound
14:22:44 <trofimovich> @karma+ Saizan
14:22:44 <lambdabot> Saizan's karma raised to 8.
14:23:09 <seydar> turns out foldl is very smart
14:23:15 <seydar> and i fixed my problem!
14:26:33 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4941
14:26:35 <dmwit> > 252. / 228
14:26:36 <lambdabot>  Parse error at "/" (column 6)
14:26:43 <dmwit> > 252.0 / 228
14:26:46 <lambdabot>  1.105263157894737
14:26:49 <Corun> Er, oops, didn't mean to paste that, sorry
14:27:55 <dmwit> > 228 / 252
14:27:55 <lambdabot>  0.9047619047619048
14:29:00 <psykon> guys, an haskell-scriptable irc client?
14:29:28 <dmwit> nope
14:29:57 <psykon> is that "nope" for me and meaning one does not exist?
14:30:27 <dmwit> The nope is for you, and it means I don't know of any such thing.
14:30:44 <psykon> ok, thanks
14:31:25 <dmwit> Although a quick search on haskell.org comes up with hircules.
14:31:38 <psykon> i want a curses one
14:31:47 <r3m0t> I want a haskell pony
14:31:58 <psykon> :)
14:32:14 <dmwit> Ponies poop.
14:32:56 <psykon> so one of you write one, pretty please :)
14:33:03 <Nafai> dmwit: But if it were a Haskell pony, that poop would have to be wrapped in a Monad...isn't poop a side effect?
14:33:10 * Nafai knows he is going to regret saying that
14:33:39 <lucca> no, it's the output.  the growing pony is the side effect
14:33:41 <dmwit> pony :: Food -> (Transportation, Poop)
14:34:08 <Nafai> Dang it.  You guys are right.  It's always a type error.
14:34:31 <resiak> type Pony = WriterT [Poop] IO ?
14:34:53 * Cin pokes psykon
14:35:06 * psykon glances around nervously
14:35:10 <Nafai> r3m0t, dmwit: Look what you started
14:35:50 <psykon> Cin: so, you know they'll kill you if they find you here?
14:35:57 <r3m0t> Nafai: apologies
14:36:04 <Cin> psykon: the SS?
14:36:14 <Cin> i better start a diary
14:36:37 <psykon> if SS means Scheme Security or something
14:36:38 <dmwit> :t lookup
14:36:40 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
14:36:47 <dmwit> :t maybe
14:36:48 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:37:17 <Cin> psykon: i thought you were an agent. they're in the walls
14:37:18 <dmwit> ?hoogle a -> Maybe a -> a
14:37:19 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
14:37:19 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
14:37:19 <lambdabot> Data.Maybe.maybe :: b -> (a -> b) -> Maybe a -> b
14:38:28 <psykon> Cin: i'll just modify the source *BAM* no more wall
14:38:54 <Cin> ghc --make kungFu -o neo
14:38:57 <dmwit> > let f x = fromMaybe x . lookup x . zip "aeiou" $ "eeoua" in map f "ping"
14:39:01 <lambdabot>  "pong"
14:39:05 <dmwit> > let f x = fromMaybe x . lookup x . zip "aeiou" $ "eeoua" in map f "poke"
14:39:06 <lambdabot>  "puke"
14:39:24 <Cin> lol
14:41:18 <dmwit> > let f x = fromMaybe x . lookup x $ zip "aiou" "ioua" in map f "poke" -- more readable
14:41:21 <lambdabot>  "puke"
14:41:28 <r3m0t> @src lookup
14:41:28 <lambdabot> lookup _key []          =  Nothing
14:41:28 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
14:41:28 <lambdabot>                         | otherwise = lookup key xys
14:41:44 * r3m0t could have used that today
14:42:01 <dmwit> You seem to say that a lot. =P
14:42:20 <dmwit> Maybe you should have a look through the Prelude.
14:42:47 <r3m0t> I did, just before the exam ;-)
14:42:51 <dmwit> heh
14:43:17 <r3m0t> but we haven't even done Maybe... it could look a bit lame
14:46:18 <EvilTerran> @index lookup
14:46:19 <lambdabot> Data.HashTable, Data.IntMap, Data.Map, Data.List, Prelude
14:46:45 <EvilTerran> r3m0t, are you sure you didn't do Maybe, at least in passing? i'm sure we did...
14:47:18 <r3m0t> EvilTerran: we most certainly did not
14:47:24 <EvilTerran> weird.
14:47:44 <EvilTerran> do you have another course of FP next term?
14:47:45 <r3m0t> woah, we did
14:47:49 <dmwit> EvilTerran: He may mean Maybe the module, not Maybe the type constructor.
14:48:02 <EvilTerran> r3m0t, changing your mind? :P
14:48:10 <r3m0t> yes, I grepped the notes
14:48:39 <dmwit> The notes... are in a greppable form?
14:48:47 <dmwit> ...you are doing a class in Haskell?
14:48:49 <EvilTerran> hehe. ISTR it was at least mentioned as an example when we did Functors in my year
14:48:49 <r3m0t> yes, postscript and .lhs
14:48:55 * dmwit is jealous
14:49:15 * dmwit is doing a class in Java D=
14:49:17 <EvilTerran> dmwit, he's a first-year at ox.ac.uk; i'm a second-year, which is why i know what the heck he's on about ;)
14:49:27 <dmwit> EvilTerran: hehe
14:49:46 <r3m0t> but as dmwit said, we didn't see any of the functions such as fromJust
14:49:48 <resiak> suddenly Heffalump's joke makes even more sense
14:49:59 <EvilTerran> don't worry, he'll have to do java next year. and between now and then, there'll be oberon, too
14:50:02 <dmwit> ?quote
14:50:03 <lambdabot> newsham says: over here in america we take people with all sorts of names (except mohammed)
14:50:10 <r3m0t> yum (!)
14:50:14 <dmwit> ?quote Heffalump
14:50:15 <lambdabot> Heffalump says: docs aren't all that useful, generally
14:50:17 <EvilTerran> being the evil bastard child of pascal
14:50:19 <dmwit> ?quote Heffalump
14:50:19 <lambdabot> Heffalump says: CPP leads to suffering
14:50:23 <dmwit> ?quote Heffalump
14:50:23 <lambdabot> Heffalump says: CPP leads to suffering
14:50:36 <dmwit> Suffer, mortals!
14:50:50 <EvilTerran> (via Modula)
14:51:20 <resiak> (namely "how many Oxford students does it take to split a list?")
14:51:38 <EvilTerran> yeah, i figured that's what you were referring to. he's a research student here, iirc.
14:51:42 <dmwit> resiak: aha =)
14:51:48 <Toxaris> > fmap fmap fmap fmap fmap fmap fmap fmap Char.toUpper [(1, "hello"), (2, "world")] -- r3m0t what about that one (in the context of association lists...)?
14:51:51 <lambdabot>  [(1,"HELLO"),(2,"WORLD")]
14:52:03 <EvilTerran> wow.
14:52:57 <r3m0t> Toxaris: oh shit...
14:53:03 <dmwit> :t fmap fmap fmap fmap fmap fmap fmap fmap
14:53:04 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
14:53:27 <resiak> EvilTerran: not any more
14:53:36 * r3m0t made another mistake in the exam, probably
14:53:37 <EvilTerran> okay
14:53:42 * dmwit tries to resist saying "fap fap fap fap fap"
14:53:52 <r3m0t> dmwit--
14:53:54 <Cale> dmwit: You fail it!
14:54:00 <r3m0t> @karma dmwit--
14:54:01 <lambdabot> dmwit-- has a karma of 0
14:54:14 <dmwit> ?karma
14:54:14 <lambdabot> You have a karma of 0
14:54:15 * EvilTerran notes that some of those fmaps are (.)s - that's one of my favourite obfuscation tricks, too
14:54:34 <r3m0t> why would anybody obfuscate haskell
14:54:43 <r3m0t> lambdabot can do it himself
14:54:45 <Toxaris> yep, these fmaps are (.), map and second
14:54:46 <EvilTerran> ?type foldr1 ($) (relicate 8 fmap)
14:54:47 <lambdabot> Not in scope: `relicate'
14:54:49 <EvilTerran> ?type foldr1 ($) (replicate 8 fmap)
14:54:50 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
14:54:50 <lambdabot>     Probable cause: `$' is applied to too many arguments
14:54:50 <lambdabot>     In the first argument of `foldr1', namely `($)'
14:54:55 <r3m0t> @src elem
14:54:55 <lambdabot> elem x    =  any (== x)
14:54:57 <dmwit> r3m0t: *herself*
14:55:02 <EvilTerran> hm. needs moar higher-order types
14:55:13 <r3m0t> @pl \x -> any (==x)
14:55:13 <lambdabot> any . (==)
14:55:20 <Toxaris> EvilTerran: lists doesn't work that way, you know, this isn't Java...
14:55:20 <EvilTerran> s/order/rank/, or whatever.
14:55:26 <r3m0t> @pl \x -> not.null.filter.(==x)
14:55:26 <lambdabot> ((not . null . filter) .) . (==)
14:55:47 <r3m0t> dmwit: herself
14:55:48 <EvilTerran> Toxaris, as i said, i think i could make it work with RankNTypes
14:56:10 <EvilTerran> although i'd have to wrap the fmaps in a constructor
14:56:52 <Toxaris> EvilTerran: I don't think so. can one occurence of fmap in an Haskell expression belong to multiple Functor instances?
14:57:54 <monochrom> f x = fmap x
14:58:09 <monochrom> That "one" occurrence of fmap belongs to multiple Functor instances. :)
14:58:27 <monochrom> (OK OK! I'm just kidding!)
14:58:30 <opqdonut> :D
14:58:31 <Toxaris> monochrom: not at once :)
14:58:43 <ddarius> Toxaris: Yes.
14:58:53 <ddarius> Depending on what you mean by "at the same time"
14:59:35 <monochrom> (Turn off monomorphism restriction in the following.)  let f = fmap in (f id (Just True), f id [True]).  Does that work?
14:59:46 <dmwit> ddarius: Can a list of fmaps refer to different Functor instances?
15:00:12 <monochrom> If that doesn't work, add a higher-rank signature to f.
15:01:38 <monochrom> Oh! List. I'll think about it.
15:01:49 <ddarius> dmwit: There might be a way (to do what you meant to say), but I'm not sure if it would work.
15:02:11 <Toxaris> monochrom: it should work, but it's not what I meant
15:03:06 <Toxaris> monochrom: but I'm not sure how to say exactly what I mean :(
15:05:35 <ddarius> Jaynes being dead is rather inconvenient.
15:08:31 <opqdonut> jaynes?
15:09:12 <ddarius> @google e.t.jaynes
15:09:13 <lambdabot> http://bayes.wustl.edu/etj/etj.html
15:09:13 <lambdabot> Title: Edwin Thompson Jaynes - July 5, 1922 - April 30, 1998
15:11:41 <grahamhutton> @users
15:11:42 <lambdabot> Maximum users seen in #haskell: 444, currently: 415 (93.5%), active: 12 (2.9%)
15:15:29 <thetallguy> @users
15:15:30 <lambdabot> Maximum users seen in #haskell: 444, currently: 416 (93.7%), active: 14 (3.4%)
15:15:47 <thetallguy> active increased by 2.
15:16:01 <thetallguy> me and the bot, I suppose
15:17:22 <EvilTerran> > 416 - 415
15:17:25 <lambdabot>  1
15:17:56 <grahamhutton> hi clifford!
15:18:04 <opqdonut> :D:D
15:18:37 <dmwit> > 14 - 12
15:18:38 <lambdabot>  2
15:19:46 <hpaste>  monochrom pasted "a list of fmaps" at http://hpaste.org/4943
15:21:03 <EvilTerran> monochrom, i thought [forall f a b. ...] wasn't allowed?
15:21:11 <thetallguy> hi graham!
15:21:24 <thetallguy> grahamhutton: how's it going?
15:21:47 <monochrom> Everything is allowed. Only trouble is can you code up non-trivial values.
15:21:58 <grahamhutton> it's getting late here, but going ok.  (we had dinner at ICFP in Freiburg)
15:22:26 <EvilTerran> monochrom, i mean, i thought you weren't allowed to use a forall.ed type as a parameter to a tycon
15:22:47 <EvilTerran> what am I thinking of?
15:23:14 <monochrom> I vaguely recall something like that. But I don't know either way. Anyway, the computer is happy with it now, and I'm happy too.
15:23:25 <EvilTerran> indeed
15:24:14 <thetallguy> grahamhutton: I remember.  I can't say I remember vividly, what with all the wine...
15:24:29 <grahamhutton> indeed; very nice hare too... :-)
15:24:47 <monochrom> ghc 6.6.1 likes it too.  would be a long time ago when it was rejected.
15:24:52 <gwern> ET Jaynes, presumably
15:24:58 <thetallguy> grahamhutton: yes, that was a good meal.  I can't remember who it was who picked the restaurant
15:25:21 <grahamhutton> peter thiemann - the local organiser
15:25:28 <visof> > foo [] = 0; let foo (x:xs) = x in foo [1,2,3]
15:25:28 <lambdabot>  Parse error at "=" (column 8)
15:25:32 <thetallguy> grahamhutton: apparently some FP/foodie came into town two weeks earlier and helped Peter identify some place
15:25:38 <Cin> > concat $ transpose ["igttepio,igttermd"," o h osn  o h eey"]
15:25:39 <lambdabot>  "i got the poison, i got the remedy"
15:25:54 <thetallguy> grahamhutton: I think Jerzy told me that.
15:25:58 <r3m0t> Cin: ...why?
15:26:17 <thetallguy> grahamhutton: I'm enjoying the worker/wrapper stuff, by the way, a little bit at a time.
15:26:25 <Cin> list practise
15:27:18 <grahamhutton> that's great to hear -- we had a lot of fun working on this paper.  the final version will be out soon, quite a bit revised from the version currently on the web.
15:27:20 <visof> > foo [] = 0 ; let foo (x:xs) = x in foo [1,2,3]
15:27:21 <lambdabot>  Parse error at "=" (column 8)
15:27:36 <visof> what's the wrong?
15:28:08 <EvilTerran> "let"
15:28:14 <dmwit> > let foo [] = 0; foo (x:xs) = x in foo [1,2,3]
15:28:14 <allbery_b> visof: misplaced let
15:28:15 <lambdabot>  1
15:28:27 <visof> oh
15:28:32 <visof> ok
15:29:25 <grahamhutton> the whole w/w business has opened up a whole vista of new ideas...
15:32:42 <gwern> by a funny coincidence, I received my copy of his Probability book yesterday
15:32:45 <monochrom> EvilTerran: It is allowed due to impredicative polymorphism.
15:32:50 <thetallguy> grahamhutton: nice to hear.  It hasn't yet for me, but I've just started thinking about it.
15:32:56 <EvilTerran> okay...
15:33:06 <grahamhutton> hopefully there will be a talk on worker/wrapper at the next "fun in the afternoon", in London in Feb.
15:33:14 <monochrom> The impredicative polymorphism example uses f :: Maybe (forall a. [a] -> [a]) -> Maybe ([Int], [Char])
15:33:40 <Toxaris> monochrom: I'm looking at your "list of fmaps" and don't see if they realy relate to EvilTerran's and my discussion
15:33:42 <grahamhutton> (given by Andy Gill, who is visiting the UK at this time)
15:34:10 <monochrom> It likely doesn't relate.
15:34:43 <Toxaris> monochrom: given that (funk [fmap, fmap] == funk [fmap] ++ funk [fmap]) holds for your code, the two fmaps in the list doesn't seem to be that different
15:34:54 <ddarius> gwern: Probability Theory: The Logic of Science?  If so, then you will shortly find one of the significant reasons his death was inconvenient.
15:35:29 <Toxaris> monochrom: (that argument may be nonsense, what do i know)
15:37:07 <monochrom> In a list I can't have two very different items. They have to be of the same type.
15:37:26 <monochrom> I can't possibly have [ fmap for Maybe, fmap for List ]
15:38:02 <monochrom> But I can have [ polymorphic fmap, polymorphic fmap ].  So now the two are the same.
15:38:35 <monochrom> However, you can still use the first polymorphic fmap just for Maybe, and the second just for List.
15:38:48 <Toxaris> monochrom: wich your code doesnt do
15:39:00 <monochrom> You can edit my code to do that.
15:39:43 <monochrom> My code does more, not less.
15:40:06 <EvilTerran> can you then have (replicate 8 fmap :: [forall f a b. Functor f => (a -> b) -> f a -> f b]), and somehow fold it down into (fmap fmap fmap fmap fmap fmap fmap fmap)?
15:40:08 <monochrom> If the first fmap can be used for both Maybe and List, then it can be used for just Maybe.
15:41:28 <monochrom> First you have to be able to type-check the "fold" there.
15:47:56 <visof> > foo [] = 0 ; let foo (x:xs) = xs in foo [1,2,3]
15:47:57 <lambdabot>  Parse error at "=" (column 8)
15:47:59 <thetallguy> grahamhutton: those are videotaped and posted, right?
15:48:09 <visof> >let  foo [] = 0 ;  foo (x:xs) = xs in foo [1,2,3]
15:48:13 <visof> > let  foo [] = 0 ;  foo (x:xs) = xs in foo [1,2,3]
15:48:14 <lambdabot>   add an instance declaration for (Num [t])
15:48:14 <lambdabot>     In the expression:
15:48:14 <lambdabot>         le...
15:48:24 <visof> oh my God
15:48:26 <grahamhutton> not so far, but this is something i want to propose for the next one
15:48:37 <visof> what is the wrong?
15:48:56 <Toxaris> visof: should foo return a list or a number?
15:49:06 <visof> list
15:49:10 <grahamhutton> we've had 4 so far - average attendance around 70, so there is lot's of interest
15:49:22 <Toxaris> visof: so foo [] = 0   is ill-typed because 0 is no list :(
15:49:35 <visof> ok
15:49:36 <ddarius> It could be.
15:49:40 <visof> thanks
15:49:50 <Toxaris> visof: this is what lambdabot returns. (actually, she returns "list is no num", what means the same thing here)
15:50:08 <visof> > let  foo [] = [] ;  foo (x:xs) = xs in foo [1,2,3]
15:50:09 <lambdabot>  [2,3]
15:50:13 <visof> hehe
15:50:26 <visof> @yow!
15:50:26 <lambdabot> A wide-eyed, innocent UNICORN, poised delicately in a MEADOW filled
15:50:26 <lambdabot> with LILACS, LOLLIPOPS & small CHILDREN at the HUSH of twilight??
15:54:03 <Cin> is there a function to split a list into a sublist of x elements? like f 2 [1,2,3,4,5,6] => [[1,2],[3,4],[6,7]]
15:54:48 <r3m0t> Cin: I believe there is not
15:55:01 <Cin> oh
15:55:26 <monochrom> There is one splitting a list into the first x items and the rest.
15:55:36 <monochrom> > splitAt 2 [1,2,3,4,5,6]
15:55:37 <lambdabot>  ([1,2],[3,4,5,6])
15:55:42 <monochrom> You can loop over it.
15:58:13 <Cin> suppose that'll have to do
15:58:19 <dons> ?usrs
15:58:19 <lambdabot> Maximum users seen in #haskell: 444, currently: 410 (92.3%), active: 12 (2.9%)
16:09:21 <JanglerNPL> Hi Mr. Hutton! I just ordered your book from Borders a few days ago...it arrives Monday! :)
16:11:02 <grahamhutton> JanglerNPL; great to hear -- hope you enjoy it!
16:20:47 <Tac-Tics> What does     Could not find module `Distribution.Simple.Setup' mean? What package contains that module?
16:21:17 <thetallguy> Cabal, probably
16:21:26 <allbery_b> it's part of newer Cabal
16:21:30 <allbery_b> you need to upgrade
16:21:45 <Tac-Tics> ok, that seems likely
16:25:03 <Tac-Tics> Hackage should have a search by modules if it doesn't already
16:27:28 <Cin> is there a function that makes a tuple?
16:27:43 <Cin> hum
16:27:45 <Tac-Tics> \x -> (x, x)
16:28:00 <thetallguy> ?type (,)
16:28:02 <lambdabot> forall a b. a -> b -> (a, b)
16:28:14 <Tac-Tics> > (,) 'a' 23
16:28:15 <lambdabot>  ('a',23)
16:28:24 <Cin> ahh. i didn't know that was a function. thanks
16:28:26 <phobes> > (,,) 1 2 3 -- does this work?
16:28:27 <lambdabot>  (1,2,3)
16:28:33 <thetallguy> Cin: everything's a function
16:28:46 <Cin> if isn't a function
16:28:50 <thetallguy> Cin: Constructors are functions
16:28:54 <Cin> right
16:29:01 <phobes> if isn't a function?
16:29:05 <thetallguy> Cin: if is sugar for a function
16:29:07 <phobes> ?type if
16:29:07 <lambdabot> parse error (possibly incorrect indentation)
16:29:23 <Cin> :t (if)
16:29:23 <lambdabot> parse error on input `)'
16:29:33 <Cin> thetallguy: which function?
16:29:39 <phobes> well, there's a special syntax... but it's still a function :)
16:29:41 <thetallguy> Type constructors are functions
16:29:55 <thetallguy> ?kind Monad
16:29:55 <lambdabot> Class `Monad' used as a type
16:30:14 <Tac-Tics> Cabal doesn't have any include-dependencies functionality to download your dependencies from the net, does it?
16:30:39 <thetallguy> ?kind []
16:30:40 <lambdabot> * -> *
16:31:03 <TomMD> ?kind Just . Left . Right . Nothing
16:31:03 <lambdabot> parse error on input `.'
16:31:14 <TomMD> ?kind (Just . Left . Right) Nothing
16:31:15 <lambdabot> parse error on input `.'
16:31:19 <thetallguy> Cin: There's no library function that does what if does, that I know of
16:31:25 <idnar> ?type (Just . Left . Right) Nothing
16:31:26 <lambdabot> forall b a a1. Maybe (Either (Either a (Maybe a1)) b)
16:31:44 <idnar> ?kind Maybe (Either (Either a (Maybe a1)) b)
16:31:44 <lambdabot> Not in scope: type variable `a'
16:31:44 <TomMD> it won't eval first? damn
16:31:45 <lambdabot> Not in scope: type variable `a1'
16:31:45 <lambdabot> Not in scope: type variable `b'
16:31:46 <thetallguy> Cin: but it would be (\b x y -> case b of True -> x ; False -> y)
16:31:49 <thetallguy> roughly
16:32:02 <idnar> TomMD: you can't take the kind of a value
16:33:20 <TomMD> I just figured it would 1) Eval 2) Figure out the type 3) Give the kind of the type.  I guess thats pretty far fetched though.
16:33:33 <idnar> TomMD: the kind is basically always going to be * there
16:33:35 <aFlag> what would be the best algorithm to implement in order to write a integer square function?
16:34:01 <phobes> algorithm?
16:34:44 <aFlag> hm, yeah
16:35:11 <aFlag> wikipedia talks about using newton's method
16:35:22 <Cin> square-root?
16:35:32 <aFlag> yeah, square-root, I'm sorry
16:35:35 <Cin> ah
16:36:04 <Cin> pretty easy. there's a lecture about it in SICP :D
16:36:32 <Cin> aflag: http://mitpress.mit.edu/sicp/full-text/sicp/book/node12.html
16:36:32 <lambdabot> Title: Example: Square Roots by Newton's Method
16:36:33 <pjd> aFlag: "best" depends
16:36:51 <qebab> aFlag: you could use a specialised version of newtons method yeah, but do the SICP examples/exercises and you'll have one that's a lot more general
16:37:12 <pjd> aFlag: what are you optimizing for?
16:37:16 <aFlag> the fastest, I want to test if a number is a perfect square or not. I first did a list like zipWith (*) [1..] [1..]
16:37:23 <aFlag> but checking against it seems slow
16:38:00 <qebab> :t ceiling
16:38:01 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
16:38:24 <Cin> aflag: consider the square root of 2
16:38:40 <Cin> aflag: your algorithm should ideally approximate to a sensible accuracy
16:39:06 <aFlag> I'm trying to solve a little problem here, I think I have a solution for it, but it's too slow. I was thinking on trying using a integer square root algorithm instead of checking on that list before asking for help on haskell-cafe :P
16:39:43 <qebab> a perfect square is what, again?
16:39:49 <qebab> I don't remember it ):
16:40:01 <aFlag> any number that can be write as x^2
16:40:08 <aFlag> written
16:40:09 <qebab> ah okay
16:40:10 <idnar> where x is an integer
16:40:23 <aFlag> yeah
16:40:33 <qebab> so you may want to test that floor x == ceiling x where x = sqrt y even though that's hacky heh
16:40:40 <qebab> and probably not secure
16:41:55 <byorgey> only problem is that doesn't work for integers that are too big, since sqrt uses Doubles, so you can lose precision
16:42:00 <aFlag> yeah, I was thinking more like y == sqrt y * sqrt y
16:42:12 <aFlag> but sqrt is kinda slow
16:42:16 <aFlag> that's the problem I think
16:42:26 <aFlag> yeah, and there's the preciso as well
16:42:40 <byorgey> aFlag: there's integer square root code somewhere on the wiki
16:42:41 <qebab> I think there's a more clever algorithm
16:43:25 <Cin> rows = unlines . reverse . map show . split (ux-lx+1) $ elems
16:43:28 <Cin> phwoar
16:43:32 <Cin> i am getting the hang of this
16:43:44 <jsnx> Cin: lolz
16:44:33 <byorgey> Cin: nice =)
16:45:07 <hpaste>  Cin annotated "why does my isWin look so ugly? ;_;" with "hum" at http://hpaste.org/4926#a7
16:46:09 <Cin> is there a way i can express the "comp ((_,y),_) ((_,y2),_) = y `compare` y2" as something else in the sortBy?
16:46:23 <Cin> i basically want to sort by the 'y' coordinate instead of the 'x'
16:46:44 <Toxaris> Cin: comparing (snd . fst)
16:47:15 <shachaf> @let on f g x y = g x `f` g y
16:47:17 <lambdabot> Defined.
16:47:38 <Cin> sortBy (compare . snd . fst) $ M.assocs g
16:47:39 <Cin> like that?
16:47:49 <byorgey> > sortBy (comparing (snd . fst)) [((3,2),5), ((6,1),3), ((7,9),18)]
16:47:52 <lambdabot>  [((6,1),3),((3,2),5),((7,9),18)]
16:47:58 <Cin> ahh
16:48:01 <shachaf> Cin: "comparing", or "compare `on`".
16:48:01 <Gebb> Can someone help me to compile HAppS on Windows? I got the sources from darcs just as happs.org says, but when I try to compile Main.hs, ghc says it's missing some modules. I suppose, some other projects must be got from their darcs repos.
16:48:03 <scook0> Cin: no, you'll need either comparing or compare `on`
16:48:17 <Cin> i couldn't figure out how to express that
16:48:33 <scook0> @type comparing
16:48:38 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
16:48:49 <Cin> :module comparing
16:49:01 <byorgey> @index comparing
16:49:01 <lambdabot> bzzt
16:49:02 <qebab> aFlag: also, you can exclude a lot of numbers based on their last digits since a perfect square has to end in 0, 1, 4, 5, 6 and 9
16:49:05 <Botje> Cin: pst and row together look like words to me.
16:49:22 <qebab> that's not really "a lot" but it is something at least
16:49:31 <byorgey> Cin: I think it's in Data.Ord ?  if it's not exported by the Prelude
16:49:47 <scook0> @hoogle comparing
16:49:47 <lambdabot> Data.Ord.comparing :: Ord a => (b -> a) -> b -> b -> Ordering
16:49:51 <scook0> bingo
16:49:53 <Cin> botje: that code is the old version. see the "vs." bit?
16:50:02 <Cin> byorgey: ahh. i'll look in that
16:50:06 <Cin> ahhh
16:50:09 <Cin> thanks scook
16:50:30 <Botje> oh. :)
16:50:38 <Botje> nevermind me
16:50:39 <Cin> hehe
16:51:18 <Toxaris> qebab: is it a good idea to work with decimal representations of big binary integers?
16:51:38 <qebab> Toxaris: not really, and I did mention that it's hacky
16:52:14 <qebab> oh wait, that heh
16:52:16 <qebab> no idea
16:52:20 <Cin> are there other "-ing"-style functions similar to `comparing`?
16:52:40 <Toxaris> Cin: there is `on`, wich is the all-in-one "ing"-style function
16:52:41 <Cin> :t on
16:52:42 <lambdabot> Not in scope: `on'
16:52:49 <Cin> ahh. i thought so
16:53:06 <Toxaris> Cin: unfortunately, it's recently added so \bot doesn't know it
16:53:12 <Toxaris> > on
16:53:13 <lambdabot>  Add a type signature
16:53:13 <Cin> oki doki
16:53:45 <Toxaris> > sortBy (compare `on` fst) [(3, "a"), (2, "b"), (4, "c")]
16:53:46 <lambdabot>  [(2,"b"),(3,"a"),(4,"c")]
16:53:54 <aFlag> qebab, yeah, I've seen that, I did something with mod but I'm not sure if it was of much help
16:54:03 <Toxaris> Cin: but you can use it, as you see, since it's added to \bot manually
16:54:09 <aFlag> maybe there's a clever way, though
16:54:11 <Cin> ahh, sweet
16:54:43 <Toxaris> Cin: it lives in Data.Function.
16:54:44 <Cin> toxaris: do you think i can express the 'split' function in that code better?
16:55:06 <Cale> @version
16:55:06 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
16:55:06 <lambdabot> darcs get http://code.haskell.org/lambdabot
16:55:11 <Cale> huh
16:55:22 <Cale> Still using 6.6
16:55:30 <Cin> toxaris: heh, i don't seem to have Data.Function
16:55:37 <Cale> Cin: which GHC?
16:55:44 <Cin> ah. i'm on 6.6
16:55:45 <Cin> heh
16:55:56 <Cin> bloody ubutunu
16:56:07 <Cin> er, ubuntu
16:57:09 <Toxaris> Cin: you can define it yourself, it's   on (*) f x y = f x * f y
16:57:24 <Cale> Yeah, I'm on ubuntu too. GHC is the one package for which I make an exception to using the package manager.
16:57:53 <Cale> It's easy enough to just alien the readline rpm they have, and install the generic binary GHC
16:58:01 <Cin> indeed. i compiled ghc 6.8 once but it took like an hour (weak laptop)
16:58:03 <Cin> ohh, good idea
16:58:22 <Cale> Yeah, you should never compile GHC unless you're hacking on it.
16:58:27 <byorgey> Cin: only an hour?  that's pretty good =)
16:58:44 <Cale> Yeah, an hour is pretty short. Usually it's more like a whole afternoon :)
16:59:03 <Cin> it was probably more. i thought saying more than an hour would sound OTT :P
16:59:04 <Cale> dons once did it in something like 9 minutes :)
16:59:36 <byorgey> in his head!
16:59:39 <Cin> lol
17:00:11 <Cale> It was on a 16 core machine, iirc.
17:00:12 <Cin> cale: where is this readline rpm? on haskell.org?
17:00:23 <Cale> yeah, the same place you get the GHC binary
17:00:33 <Toxaris> Cin: your split looks fine for me.
17:00:36 <Cin> ahh, binary packages
17:00:38 <Cale> http://haskell.org/ghc/download_ghc_682.html#x86linux
17:01:13 <Cale> oh
17:01:16 <Cin> sweet
17:01:22 <Cale> apparently there's also one built against new readline
17:01:27 <Cale> So that's cool.
17:01:31 <Cin> yeah
17:01:52 <dons> oh, its about 3 mins on the 16 core box
17:02:01 <Cin> toxaris: it seems so simple that it should already exist but i guess it mustn't be a common thing
17:02:04 <Cale> dons: :)
17:02:11 <Cale> dons: That's insane. :)
17:02:12 <Cin> 16 core
17:02:17 <Toxaris> > unfoldr (\xs -> do {guard . not . null $ xs; return . splitAt 3 $ xs}) "abcdefgh" -- Cin: there are split one-liners, but they aren't nice :(
17:02:18 <lambdabot>  ["abc","def","gh"]
17:02:22 * Cin gets up
17:02:35 <Cin> toxaris: eek, heh
17:02:41 <pjd> aFlag: http://gmplib.org/manual/Perfect-Square-Algorithm.html
17:02:43 <lambdabot> Title: Perfect Square Algorithm - GNU MP 4.2.2
17:03:58 <Cale> Someone should go about adding all the rest of GMP's provided functionality to the interface for Integer
17:04:14 <Cin> ghc uses GMP?
17:04:17 <Cale> yep
17:04:23 <Cin> interessaunt
17:04:38 <Cin> i used GMP in c. nice documentation
17:04:42 <MyCatVerbs> Cin: Integers are automatially resized as they get bigger.
17:05:06 <Botje> > product [1..40]
17:05:10 <Cale> So does Mathematica on Linux, interestingly enough.
17:05:11 <lambdabot>  815915283247897734345611269596115894272000000000
17:05:22 <MyCatVerbs> > foldr (^) [1..40]
17:05:23 <lambdabot>   add an instance declaration for (Integral [t])
17:05:35 <Cale> (at least, MathKernel is dynamically linked against libgmp.so.3)
17:05:43 <MyCatVerbs> > foldr (^) 2 [1..40]
17:05:49 <lambdabot> Terminated
17:05:57 <byorgey> Cale: really? interesting
17:06:27 <TomMD> Cale: But there is a minor goal of getting rid of GHCs use of GMP.  Do you know of any serious efforts there?
17:06:53 <Cale> TomMD: Well, there's already a library which implements Integer entirely in Haskell.
17:07:25 <Cale> (and is designed with some thought given to using good algorithms)
17:07:29 <TomMD> Yes, I saw that - but for whatever reason the related trac ticket doesn't have any mention of effort, discussion, or progress.
17:08:17 <Cale> I'm personally not sure I'd want to see it switched to using something else. GMP does a really good job.
17:09:32 <Cale> I'd want to see improvements in terms of correctness or performance before that happened, personally. I know some people don't like the license though.
17:12:20 <Cale> Heh, this message on the libraries mailing list has a funny comment:
17:12:23 <Cale> The licensing for the readline package itself is a little strange --
17:12:23 <Cale> it's licensed under the GPL (because it links with libreadline), but
17:12:23 <Cale> there's no copyright holder information; and Readline.hsc from that
17:12:23 <Cale> package lists "Copyright: (c) unknown".
17:12:59 <Cin> heh
17:13:33 <Cale> I wonder what that actually implies, legally.
17:14:12 <Cale> Are things allowed to have anonymous copyright holders?
17:14:36 <Cin> cale: don't mean to be a nusance, but is it possible to use alien on this tar.bz2 archive to install ghc? how did you do it?
17:14:50 <skew> Things can be assumed to have copyright holders, even if you don't know them
17:14:56 <Cale> Cin: oh, no, alien is for converting RPMs
17:15:10 <Cin> ah. i thought it might do extra special tricks
17:15:12 <Cale> Cin: You just unpack the .tar.gz, and do a make install
17:15:16 <Cin> ahhh
17:15:17 <Cin> okay
17:15:31 <skew> Well, I think I've got a nice way of working with a syntax ADT
17:15:52 <Cin> when install other ghc packages from apt-get, i think it will try to install ghc6.6 again
17:16:30 <Cale> (c) Anonymous Works, Pseudonymous Works, and Works Made for Hire. ‚Äî In the case of an anonymous work, a pseudonymous work, or a work made for hire, the copyright endures for a term of 95 years from the year of its first publication, or a term of 120 years from the year of its creation
17:16:49 <idnar> Cin: you can use alien on slackware style "tar.gz" packages, but that's probably not what you want
17:16:51 <Cale> (whichever expires first)
17:17:18 <Cale> Cin: It won't matter, since this GHC installs in /usr/local
17:17:26 <Cale> Cin: which should occur earlier in your path
17:17:35 <Cin> oh i see!
17:18:12 <skew> I define a separate type for each concrete constructor, with separate type parameters for each of the subexpressions I might want to further inspect or leave alone
17:18:40 <skew> then a pattern made from those things tells a view class just how much it needs to unfold
17:19:35 <kib> Hi, does someone here is interested in having a pdf file from 'Haskell for C Programmer' ? It's a very beta version.
17:19:41 <bench1> is there a haskell library for building web services?
17:20:03 <Cale> bench1: There's HAppS and Hope
17:20:21 <Cale> (probably HAppS is closest to what you want)
17:20:41 <Cale> From what I understand, it's currently a little hard to get into, but nice once you understand it. I haven't tried it yet myself.
17:21:29 <Cale> http://happs.org/
17:21:51 <bench1> Cale: HAppS seems to be  big and less documented, i haven't looked at Hope
17:22:24 <Cale> Hope is more of a CMS.
17:22:38 <idnar> HAppS seems somewhat eccentric
17:22:45 <Cale> http://hope.bringert.net/about
17:23:18 <bench1> Cale, yes, it seems hope is more of a CMS
17:23:54 <Cale> and of course, there's the CGI library :)
17:24:15 <Cin> using ghc as a cgi?
17:24:16 <bench1> idnar, yes, HappS certainly tries to do more, maybe a bit too ambitious
17:24:27 <Cale> Cin: well, a ghc compiled application, yeah
17:24:32 <Cin> hrm!
17:24:39 <Cale> It's pretty straightforward.
17:24:43 <Cin> i could use it with fastCGI ^_^
17:25:42 <Cale> There's apparently lots of other stuff on Hackage which I don't really know about :)
17:25:48 <Cin> hehe
17:25:54 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hxweb-0.1 -- like this
17:25:56 <lambdabot> http://tinyurl.com/33x9ha
17:26:22 <bench1> Cin/Cale, i was hoping to be able to create a web service with a wsdl declared, and a haskell impl, and run it and accepts requests with soap, etc
17:26:57 <skew> I think bingert had something like that
17:27:04 <skew> Bjorn Bringert
17:27:05 <Cale> Heh, I wasn't even aware of the existence of WSDL.
17:27:31 <TomMD> Is there no way to change my community.haskell.org account passwd without contacting ross@soi?
17:27:33 <Cale> (and I've never touched SOAP)
17:27:33 <skew> well, at least the soap - or was it xmlrpc?
17:27:51 <Cale> TomMD: Is that a shell account?
17:27:58 <TomMD> Yep
17:28:05 <Cale> What does passwd give you?
17:28:06 <idnar> WSDL :(
17:28:23 <TomMD> I can SSH in (PKI), but passwd asks for an old password, which doesn't exist.
17:28:52 <Cale> ah, right
17:28:54 <skew> oh, that was haxr, doing xmlrpc
17:29:04 <Cin> cale: yay. read the INSTALL file. ghc6.8 installed. ^_^
17:29:55 <Cale> Cin: cool. I can't remember, does 6.8 come with cabal-install? Try doing  cabal update  and see :)
17:29:59 <bench1> skew: what was it called?
17:30:26 <bench1> skew: xmlrpc requires that client to be haskell as well i think?
17:30:37 <Cin> cabal not found. does it come as a program or is it supposed to be run from within ghc?
17:30:45 <ndm> Cale: i think it doesn't, or if it did, was broken
17:30:47 <bench1> i want the client to be anything that understands webservice
17:30:56 <Cale> Cin: It's a program.
17:31:00 <Cin> ah
17:31:02 <sclv> i may be speaking partly out of ignorance here (what's new?) but as far as i know, a good soap or wsdl binding would be a sort of irritating task because there's so much packing of data going on -- much more natural to more dynamic languages.
17:31:02 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install-0.4.0
17:31:03 <lambdabot> http://tinyurl.com/yss6oz
17:31:06 <Cale> you can get it from there
17:31:17 <Cin> 404
17:31:21 <Cale> er...
17:31:26 <Cin> yet the tinyurl works
17:31:27 <Cin> heh
17:31:30 <Cale> huh
17:31:40 <Cin> oh, it's just my terminal cut off the URL
17:31:42 <Cin> n/m
17:32:00 <sclv> Cin: what sort of service do you want to provide that requires SOAP/WSDL as opposed to a more RESTful approach?
17:32:14 <ndm> sclv: no, in fact its probably easier in Haskell, since typeclasses will automate much of the heavy lifting
17:32:14 <Cale> Yeah, that'll download, compile, and install packages from Hackage.
17:32:38 <Cin> sclv: i don't want to provide a service? i don't know what SOAP is. are you sure you referenced the right nick? i think someone else wanted that
17:32:40 <sclv> ndm: well, yeah, but then you need to write lots of type machinery is I guess what I'm saying?
17:32:56 <sclv> sorry. s/Cin/bench1/
17:33:23 <Cale> Personally, I'm not sure why web services don't just use s-expressions to communicate :)
17:33:25 <ndm> sclv: have you used type classes much? have you seen how they get used in something like quickcheck? the type machinery is very light for the implementor of the binding, and vanishes entirely for the user - its really great :)
17:33:45 <skew> sclv: you'll write a lot of marshalling machinery one way or another, whether it's spelled isinstanceof(x,Foo) or instance SOAPSerialize Foo
17:33:59 <ndm> Cale: XML is just S-expressions with a weird syntax, some redundancy and multiple ways of representing data
17:34:08 <ndm> so in a way, they do use S-expressions
17:34:20 <sclv> ndm: for a good set of soap bindings I think you'll need some sort of generics, like with xml in general, or json, or etc. of course that's your specialty, so...
17:34:21 <Cale> and a much more complicated API, generally
17:34:26 <Cin> cale: hehe. have you played with SXSL? hope i got that acronym right. transformations and template-like operations on s-experssions for building web pages
17:34:29 <idnar> netstrings!
17:34:40 <skew> ndm: how's the homeomorphic embedding coming?
17:34:45 <bench1> sclv: it's part of the client requirements
17:35:13 <ndm> skew: turns out, even with a linear (rather than exponential) homeomorphic embedding, its only at most 3 times faster, which doesn't buy me enough to make my current supero approach scale enough :(
17:35:14 <Cin> XML is just less annoying to type real text ie with common characters like "
17:35:15 <bench1> sclv: as far as i know, REST only offers a pattern rather than a real spec
17:35:18 <skew> ndm: I just came up with something that made the syntax really nice, but I could send you my better code if you haven't already written something just as good
17:35:57 <ndm> skew: send whatever code you have over :)
17:36:18 <ndm> of course, three times faster is nice, but it means i need to look at other bits to get the order of magnitude speed-up that i want
17:36:27 <ndm> but i think i have a good idea
17:36:36 <skew> ndm: I'll send you some interesting stuff in a while then - I just figured out a nice way of doing views over locally nameless syntax
17:36:40 <sclv> bench1: ok, i'll grant that.
17:38:03 <skew> so I'm going to keep at that for a bit before trying to make any of my code work on the standard Yhc.Core expression type :)
17:38:09 <Cin> cale: http://sjamaan.ath.cx/docs/scheme/sxslt.pdf
17:38:49 <Cale> Cin: yeah, I think I've seen some things sort of like that. :)
17:38:51 <sclv> ndm: what I meant was that dynamic soap libraries tend to be easier because they just say "pretend this stuff is in this other format and if it isn't then die horribly." haskell has al the typeclass machinery to do this nicely, but it's just terribly irritating that there's the SOAPish way of representing data and the other XML ways of representing generic data and the JSON way and etc.. and it seems like to get haskell working with all of 
17:39:35 <Cale> sclv: with all of
17:39:49 <Cale> <end of line>
17:39:52 <sclv> there's no single canonical representation of "generic junk that a serialized web request passed me"
17:40:14 <ndm> sclv: true :)
17:40:39 <bench1> sclv: know of any haskell soap lib?
17:40:45 <ndm> skew: have you seen Yhc.Core.Eq ? It now exports CoreExpr1, and you have childrenCore which gives the children
17:40:51 <Cale> Well, it's a string of bytes, at least...
17:40:52 <Cale> hehe
17:41:12 <sclv> I'd really like to see HaPPs-State maybe be the basis of it, but it needs work.
17:41:20 <ndm> skew: plus http://www.cs.york.ac.uk/fp/darcs/homeomorphic/ - its my homeomorphic library, including a Shell type, to which I convert everything to first
17:41:21 <lambdabot> Title: Index of /fp/darcs/homeomorphic
17:41:33 <ndm> along with about 7 implementations of homeomorphic embedding
17:41:46 <skew> ndm: nope, a copy of "I Am Not a Number I Am a Free Variable" caught my eye and I had a go at writing my own syntax
17:41:53 <Cale> ndm: Which topology is this?
17:41:57 <skew> ndm: case/case and all those are now two lines each!
17:41:58 <Cin> ndm: you're at York? :O
17:42:19 <skew> one line to match the expression, one line to put it back together again!
17:42:52 <bench1> sclv: can HappS be stripped down so that it only does http/soap?
17:43:15 <bench1> or should i start with some fastcgi lib and do it myself?
17:43:28 <EvilTerran> @where ndm
17:43:29 <lambdabot> http://www.cs.york.ac.uk/~ndm/
17:43:35 <EvilTerran> Cin, indeed he is
17:44:02 <ndm> Cale: i know not what you talk of :)
17:44:22 <Cale> ndm: Well, a homeomorphism is a continuous map between topological spaces with a continuous inverse.
17:44:32 <sclv> bench1: HaPPs can take xml requests and run webservices with them and then return xml very nicely, as far as I know, and apparently is at a relatively stable point in its repo. I don't think it has SOAP per-se though. If your spec is simple enough (that's the depressing thing about SOAP, is that it's way overspecified for 99% of its uses) it might nit matter though.
17:44:43 <Cin> "I am have rewritten WinHugs", heh
17:44:47 <ndm> skew: oh, you mean Yhc.Core.Simplify - I looked at the free var stuff, looked very cool, but went slightly over my head - might try again
17:44:59 <ndm> Cin: oops, that would be a typo :) yes, i am at york
17:45:11 <skew> ndm: does that export alpha equality?
17:45:56 <sclv> haha I just realized that its "HAppS" -- I always get that capitalization wrong.
17:46:07 <ndm> skew: i don't think anything exports alpha equality, but the stuff in FreeVar3 allows unique renaming, and that can be used to perform normalisation so alpha equality is just equality
17:46:07 <Cin> hehe
17:47:37 <skew> ndm: glancing over your homeomorphism code, I think I may have to try my version after all
17:47:53 <bench1> sclv: thanks, have you used HAppS? how does it compare to WASH, etc?
17:48:05 <skew> ndm: it looks like you labelling nodes and using a general purpose set or map or something, right?
17:48:21 <Cin> agh. why did they stop ':' from reloading the current module?
17:48:29 <Cin> was that a bug or something?
17:48:32 <bench1> or HSP
17:48:32 <ndm> skew: yes, the current best one is "Memo", that does the cache stuff
17:48:36 <EvilTerran> Cin, i believe that's been put back in the latest ghc
17:48:43 <ndm> Cin: it was an unintentional feature, that has now been restored
17:48:51 <EvilTerran> actually, wait, it repeats the last command now
17:48:54 <Cin> ahh. haha. interesting.
17:48:58 * Cale wonders how the word "homeomorphism" came to be used in this context :)
17:49:03 <ndm> skew: although in practice SimpleParallel and Hash2 are similar speeds
17:49:20 <ndm> Cale: no idea, its not homeomorphism though, its a homeomorphic embedding
17:49:21 <skew> ndm: have you tried using one with a lazy memo structure, and do you have some handy benchmarks?
17:49:47 <Cale> ndm: Which is a homeomorphism onto a subspace, usually.
17:49:53 <Cale> er
17:49:56 <sclv> bench1: I've played with it, but done naught serious. It takes a little thought to get your head around everything it does, as I understand it. The nice part is the persistence mechanism and the native handling of XML, although you can just drop the xml libs into a typical FastCGI deployment. Again talking out of somewhat ignorance, but my understanding is that WASH has its own quirks and isn't under nearly as much active development.
17:49:56 <Cale> yeah
17:50:04 <ndm> skew: my benchmarks are deeply integrated in Supero, and I still haven't found a good benchmark - I've been using "supero x2n1 msg" then seeing how many dots appear in 30 seconds
17:50:33 * EvilTerran has no idea what all this "homeomorphism" stuff's about O.o
17:50:55 <sclv> there's also a small but responsive community who will probably help you with the problems that you will assuredly encounter in getting you up and running with it.
17:50:58 <ndm> my stats show that 2/3 of the homoemorphic tests come out of the cache, which suggests that even at 100% efficiency, it will only be 3 times faster than the simple one
17:51:14 <ndm> EvilTerran: very cool termination stuff, i will blog about it at some point
17:51:24 <EvilTerran> i look forward to it :)
17:51:28 <skew> that does include all the recursive tests?
17:51:51 <ndm> skew: yes
17:51:54 <bench1> sclv: thanks, i've looked at happs' web page, it seems complicated w/o a lot of documentation, and i don't quite care about the in-memory db stuff
17:53:35 <bench1> sclv: anything else out there that you think might be useful?
17:53:38 <sclv> there's also apparently this, but I have no idea the condition its in: http://www.dcs.shef.ac.uk/~simonf/HAIFA.html
17:53:39 <lambdabot> Title: HAIFA
17:54:26 <ndm> sclv: i seem to remember Simon moved onto a new web project after that, although may be mistaken...
17:54:58 <Cale> bench1: What kind of app is it that you're writing?
17:59:33 <gwern> 'then seeing how many dots appear in 30 seconds' <-- :)
18:00:46 <Cin> if i have showGrid :: Eq a => Grid a -> String, how can i also assert that i want a to be an instance of Show as well?
18:01:06 <sarehu> (Show a, Eq a) =>
18:01:24 <sarehu> You need parentheses if you want two or more.
18:01:26 <gwern> (Eq a, Show a) doesn't work?
18:02:00 <Cin> ah. i thought i'd tried that. must've overlooked something
18:02:09 <Cin> thanks
18:03:33 <litb> a question
18:03:44 <ndm> gwern: exactly, the benchmark is "suboptimal"...
18:03:47 <litb> what does it mean if we say "functions in haskell are high-order"
18:04:00 <Cin> a function that returns a function is higher-order
18:04:05 <ndm> litb: they may take functions as input
18:04:05 <litb> so far i know that this means that they can be passed to other functions
18:04:13 <litb> but why is it called "high-order" ?
18:04:33 <ndm> litb: a language if first order if there are no functions as values
18:04:52 <ndm> it is second order if you can have functions, but they can only operate on first-order values
18:04:54 <gwern> because they are 1st order
18:04:59 <TomMD> > map succ "litb"
18:04:59 <gwern> which is higher than 0th order
18:05:02 <lambdabot>  "mjuc"
18:05:21 <litb> lolz, i know what that did, TomMD
18:05:41 <TomMD> litb: Just having fun ;-)
18:06:36 <litb> ndm: i see
18:06:55 <litb> but people say that functions in haskell are... they don't say that haskell in itself is
18:07:03 <shachaf> Perhaps you tried Eq a => Show a => ...?
18:07:12 <shachaf> (Is there a reason that syntax doesn't work?)
18:07:20 <notsmack> litb: a function that makes use of another function argument is a higher order function, for instance
18:07:23 <sclv> ?hoogle ShowS
18:07:23 <lambdabot> Prelude.ShowS :: type ShowS
18:07:23 <lambdabot> Text.Show.ShowS :: type ShowS
18:07:23 <lambdabot> Prelude.shows :: Show a => a -> ShowS
18:07:54 <litb> oh i see
18:08:02 <litb> there is first order, second order and high order?
18:08:10 <gwern> wait, surely it goes the other way - then what's a third order function?
18:08:17 <gwern> lower numbers are less powerful
18:08:28 <ndm> litb: there is every order, and higher order is like "unlimited order"
18:08:37 <ndm> in practice, most languages are either first order or higher order
18:08:39 <notsmack> http://en.wikipedia.org/wiki/Higher-order_function
18:08:39 <gwern> something like Excel has zeroth order functions, haskell 1, and up, and so on
18:08:49 <litb> oh rhanks
18:08:51 <litb> -r
18:08:56 <litb> c++ is first order i think
18:08:57 <gwern> until you reach those crazy 7th or 6th order parsing functions
18:09:05 <sclv> gwern: a third order is usually dessert. After that maybe a nightcap, and then you're pretty stuffed.
18:09:13 <Cin> sclv: hehe
18:09:17 <TomMD> Stop increasing c's karma, it beats me already.
18:09:24 <ndm> litb: C has function pointers, but not closures - you might call it 1.1th order
18:09:28 <litb> TomMD: hehe
18:09:57 <ndm> TomMD: lambdabot knows about c++ and doesn't increase it :)
18:09:58 <litb> ;) i thought because function pointers are just values referencing function, they are not really passing functions
18:10:17 <notsmack> litb: the functionality is what matters, i'd imagine
18:10:17 <ndm> that's all functions are
18:10:24 <skew> you might inductively define all the values you need for the programming language, starting with the simple non-functional things like 0 and Bool and in each step adding functions between the previously defined values, and then values containing those functions
18:10:33 <litb> i see
18:10:34 <TomMD> ndm: When did that change?  Last summer I guess.  Well, a goo change.  There was someone in here with a -- at the end of their name - does lambdabot account for that too now?
18:10:55 <ndm> TomMD: not sure, i think C might be a special case
18:11:05 <notsmack> ttt--++
18:11:26 <notsmack> @karma ttt--
18:11:26 <lambdabot> ttt-- has a karma of 1
18:11:29 <skew> I'm not sure that approach even makes sense for things with function pointers, though
18:11:33 <skew> c++++
18:11:37 <skew> @karma C++
18:11:37 <lambdabot> C++ has a karma of -7
18:11:38 <litb> ah, so every language which supports currying also has higher order functions?
18:11:45 <litb> (since it can returns functions)
18:11:50 <ndm> litb: yes
18:12:00 <ndm> Javascript has higher-order functions, for instance
18:14:16 <LoganCapaldo> i faked closures in C++ yesterday
18:14:29 <litb> LoganCapaldo: youre welcome
18:14:39 <LoganCapaldo> hehe
18:15:03 <litb> it's trivially there says, since boost::bind hsa been made public to the broader range of novices
18:15:15 <litb> s/there/these/
18:15:29 <litb> damn, how many typos in that sentence... sorry mates
18:16:10 <LoganCapaldo> boost:;bind lets you partially apply functions, so you can do your own lambda lifting to get closures, but I wouldn't call it "trivial"
18:16:20 <LoganCapaldo> regardless I ddin't happen to use bind
18:16:36 <aFlag> pjd, are you being able to connect to gmplib.org? It's not working here
18:18:30 <Cin> works for me
18:20:21 <aFlag> hm
18:21:26 <aFlag> weird, it doesn't work at all here
18:21:47 <ndm> aFlag: fine for me
18:23:08 <aFlag> problem some issue with my system's configuration :(
18:26:49 <skew> ndm: I think case/con can decrease sharing, potentially hurt performance if an argument is really expensive
18:27:47 <skew> ndm: I doubt it's really a problem, but simplify does promise to unconditionally improve code
18:27:58 <aFlag> *probably
18:30:00 <ndm> skew: really? does case/con not introduce a let for the bound variables?
18:30:12 <skew> nope, just calls replaceFreeVars
18:30:22 <ndm> eek, i'd call that a bug!
18:30:26 <skew> also that way in the paper
18:30:49 <skew> I was just reworking my copy of the transformations to use my handy view and wondering if I should use a let
18:31:24 <ndm> use a let
18:32:34 <ndm> @karma+ skew
18:32:34 <lambdabot> skew's karma raised to 3.
18:32:51 <ndm> good catch, that could potentially really screw up optimisation, and i wouldn't have noticed
18:34:27 <skew> I'll have to get Yhc building some day and integrate the stuff I've been doing.
18:35:16 <ndm> skew: i rarely build Yhc anymore, soon i'll have multicore done, which will convert GHC Core to Yhc Core, and then you can use Yhc.Core without Yhc
18:35:23 <skew> You say McBride's paper went over your head - I have no problem with the paper, but coming to terms with a biggish project always takes me a long time
18:35:37 <ndm> i only looked quickly
18:35:37 <conal> i'm having "darcs put" trouble: after creating the repo on my server, i get "Couldn't initialize remote repository."  any ideas what's going on?
18:35:54 <ndm> conal: darcs push
18:36:04 <conal> works for me on darcs.haskell.org, but not on my server
18:36:10 <conal> ndm?
18:36:21 <conal> ndm: ?
18:36:31 <ndm> conal: i always log into the remote machine, darcs init, then do a darcs push to transfer it over
18:36:41 <ndm> have never used darcs put
18:37:01 <conal> ndm: hm.  i'll give that a try.  thanks.  the "put" path does work for me on d.h.o
18:37:53 <ndm> never realised there was a push :)
18:38:03 <ndm> i guess get and put are just equivalent to init then pull/push
18:38:14 <notsmack> conal: permissions problem maybe?
18:39:50 <conal> notsmack: on both servers, the created repo dir has rwxrwxr-x
18:40:22 <ndm> is it conceited to call my first-order reduction "mitchell's" method?
18:40:31 <ndm> cause i can't think of any other name for it!
18:40:44 <skew> which first order reduction?
18:40:57 <ndm> my first order reduction method, unpublished
18:41:06 <conal> oh ... when i do extra-verbose, i get "darcs: command not found" back from my server.  it's in my ~/bin, so i guess it's not getting found.
18:41:13 <skew> I think you are usually supposed to get your minions to name things after you :)
18:41:19 <ndm> exactly...
18:41:30 <notsmack> ndm: would 'my method' be appropriate?
18:41:32 <scook0> I believe the usual method is that you give it a really boring name, and then someone else says "that's a dumb name" and slaps your name on it instead
18:42:11 <ndm> notsmack: i need to have two flags, one which invokes reynolds style defunctionalisation, and one which invokes "the other" style defunctionalisation
18:42:43 <notsmack> ah, in that context it doesn't seem so bad
18:45:23 <skew> scook0: In more detail, I think there's usually a gradual drift of the parse from a noun phrase with your name in the possessive to one big happy proper name
18:45:43 <conal> success!  i made a symlink to darcs in /usr/local/bin, and now push & put both work.  :)
18:49:57 <shachaf> conal: You should probably not symlink /usr/local/bin/darcs to /home/conal/bin/darcs.
18:50:17 <skew> testcases feel so insufficient for program transformations...
18:50:21 <shachaf> conal: It would probably be better to add ~/bin to your $PATH.
18:51:26 <ndm> skew: at York, there is work on setting up a framework where you can test a commuting diagram on program transformations
18:51:28 <conal> shachaf: it's in my $PATH when i'm logged in.
18:51:46 <ndm> i.e forall p . semantics p == semantics (optimise p)
18:52:14 <skew> which was that?
18:52:27 <conal> shachaf: added in ~/.bash_profile
18:52:56 <shachaf> conal: Try .bashrc, possibly?
18:52:59 <ndm> Reach
18:53:00 <conal> when is .bashrc used and when .bash_profile?
18:53:26 <skew> I was especially thinking of theorem provers because the Penn group just released a paper about how easy it is to prove stuff about programs when you use a syntax representation much like the one I'm trying out now in Haskell
18:53:40 <notsmack> conal: one is for login shells, the other is all shells, i believe
18:54:02 * LoganCapaldo thinks .bashrc is for interactive shells, but could be fulla shit
18:54:15 <notsmack> When bash is invoked as an interactive login shell, or as a non-interactive shell with the --login option, it first reads and executes commands from the file /etc/profile, if that file exists.
18:54:17 <conal> notsmack: oh!  then shachaf's advice ought to fix the problem, and i can undo the symlink.
18:54:26 <conal> thanks :)
18:55:04 <notsmack>  When  an  interactive shell that is not a login shell is started, bash reads and executes commands from ~/.bashrc, if that file exists.
18:55:05 <shachaf> See `man bash`.
18:55:07 <ndm> skew: it isn't prove, but it does do a rather deep test without much effort at all
18:55:32 <shachaf> "When bash is invoked as an interactive login shell, or as a non-interactive shell with the --login option, it first reads and executes commands from the file /etc/profile, if that file exists.  After reading that file, it looks for  ~/.bash_profile,  ~/.bash_login, and ~/.profile, in that order, and reads and executes commands from the first one that exists and is readable.  The --noprofile option may be used when the shell is started to inhibit this beha
18:55:47 <skew> ndm: it's hard to search for - "Reach" at york?
18:56:08 <conal> shachaf: thanks.
18:56:15 <shachaf> conal: It works?
18:56:16 <ndm> skew: http://www-users.cs.york.ac.uk/~mfn/reach/ - not ready for prime time yet
18:56:17 <lambdabot> Title: Reach
18:57:47 <LoganCapaldo> woah
18:57:52 <conal> shachaf: chugging away ...
18:57:55 <LoganCapaldo> i thought this was -blah
18:58:06 <shachaf> LoganCapaldo: Sorry... :-)
18:58:22 <LoganCapaldo> not you're fault, I just realized is all
18:58:30 <LoganCapaldo> s/yu're/your/
18:58:36 <LoganCapaldo> err you get the idea :)
18:59:06 <notsmack> LoganCapaldo: aw, not gonna higher-order-sed it?  ;)
19:00:51 <LoganCapaldo> isn't awk higher order sed? :)
19:01:05 <conal> shachaf: PATH set in .bashrc, symlink removed, and "darcs push" worked. :)
19:05:38 <conal> with darcs, keeping my online journal up to date with the local version is now linear time instead of quadratic.
19:08:19 <notsmack> conal: was it quadratic with an earlier darcs, or some other method?
19:08:41 <thetallguy> conal: wait until you update in two different places and try to merge.  It will go exponential.
19:09:48 <conal> i mean something simpler.  until now, to update the web copy of my journal, i copied the whole file.  each time it copies more.  now i use darcs, which just copies the diffs.
19:10:01 <notsmack> anybody tried darcs2 yet?
19:10:28 <conal> and since i'm on satellite and bandwidth-limited (living in the woods), diffs help a lot.
19:15:08 <pjd> Applicative needs composition operators
19:16:04 <glguy> pjd: example?
19:18:26 <conal> @wiki TypeCompose -- for pjd
19:18:26 <lambdabot> http://www.haskell.org/haskellwiki/TypeCompose_--_for_pjd
19:18:35 <pjd> heh
19:19:06 <conal> @wiki TypeCompose
19:19:07 <lambdabot> http://www.haskell.org/haskellwiki/TypeCompose
19:19:43 <conal> pjd: TypeCompose has type composition and corresponding instances for Functor & Applicative
19:20:41 <pjd> glguy:
19:20:42 <pjd> :t let f <.> g = (f <$>) . g in sum <.> mapM (`elemIndex` ['0'..'9'])
19:20:44 <lambdabot> [Char] -> Maybe Int
19:23:13 <LoganCapaldo> :t let f <.> g = (f <$>) <$> g in sum <.> mapM (`elemIndex` ['0'..'9'])
19:23:14 <lambdabot> [Char] -> Maybe Int
19:23:24 <Saizan> :t \f g = (f <$>) . g
19:23:24 <lambdabot> parse error on input `='
19:23:28 <LoganCapaldo> tee hee
19:23:28 <shachaf> @@ (@wiki TypeCompose) -- for pjd
19:23:29 <lambdabot>  http://www.haskell.org/haskellwiki/TypeCompose -- for pjd
19:23:32 <pjd> LoganCapaldo: that too :)
19:23:32 <Saizan> :t \f g -> (f <$>) . g
19:23:32 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
19:25:17 <pjd> glguy: the idea being to allow the same intuition as with the non-Applicative transformation:
19:25:18 <pjd> digitSum x = sum $ map digitToInt x
19:25:18 <pjd> digitSum = sum . map digitToInt
19:25:50 <pjd> except with <$> and <.>
19:25:53 <glguy> pjd: I see
19:26:07 <LoganCapaldo> @type (<$>) <$> (<$>)
19:26:08 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:26:40 <LoganCapaldo> @type (<$>) . (<$>)
19:26:40 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:26:56 <pjd> :t fmap fmap fmap
19:26:56 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:27:27 * LoganCapaldo is trying to do (f <$>) <$> g pointfree and preferably only with <$>
19:27:44 * Saizan prefers fmap f . g
19:28:03 <Saizan> why use an operator if you've to section it?
19:28:37 <LoganCapaldo> I want more  money
19:28:50 <LoganCapaldo> <$><$><$><$>
19:29:14 <pjd> Saizan: to preserve the Applicative mood :)
19:29:45 <LoganCapaldo> she works hard for her <$>, so hard for it honey, she works hard for the <$> so you'd better treat her right
19:30:10 <shachaf> @ty \f g -> liftA f . g -- :-)
19:30:11 <lambdabot> forall a b (f :: * -> *) a1. (Applicative f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
19:38:28 <pjd> conal: thanks for the reference, by the way
19:38:36 <pjd> that's going to take a while to absorb
19:38:48 <conal> pjd: i'm glad to help.
19:40:03 * sclv curses "Inferred type is less polymorphic than expected" erros
19:40:14 <sclv> s/erros/errors/
19:41:18 <sclv> They mean, as I understand it, that if I want type signatures somewhere with a class constraint, I need them everywhere, no?
19:44:28 <Cale> sclv: They mean that you've explicitly given a type which is more polymorphic than the actual type of the code you've written.
19:44:51 <Cale> This could happen because you've forgotten a class constraint in a type signature, sure.
19:45:41 <skew> I don't think that error usually leads to adding a bunch of type signatures where you didn't have them at all, though
19:46:05 <sclv> I have a function, say: foo :: BarClass a => String -> a
19:46:18 <Cale> I doubt that error can happen unless you've given an explicit type signature for something, actually
19:46:24 <sclv> and its body is foo x = baz x
19:46:40 <sclv> where baz obviously has the same constraint.
19:46:55 <sclv> If I give foo a signature, ghc complains unless I give baz a signature too.
19:47:22 <skew> and what types are inferred without the signatures?
19:47:39 <sclv> well, hopefully baz can be inferred without the signature.
19:47:52 <Cale> Well, what is it inferred as? :)
19:47:53 <skew> I wouldn't expect that unless you are using funky types that can't be reconstructed, like explicit foralls or polymorphic recursion
19:47:58 <sclv> except ghc doesn't let it be.
19:48:13 <skew> you can't otherwise make a function more polymorphic just by slapping on a type signature
19:48:25 * Cale constructs sclv's example to see.
19:49:28 <Cale> I'm not seeing that problem with my code.
19:49:46 <Cale> class BarClass a
19:49:46 <Cale> foo :: BarClass a => String -> a
19:49:46 <Cale> foo x = baz x
19:49:46 <Cale> baz = undefined
19:49:51 <Cale> that works just fine
19:51:48 <Cale> class BarClass a where
19:51:48 <Cale>     bar :: String -> a
19:51:48 <Cale> foo :: BarClass a => String -> a
19:51:48 <Cale> foo x = baz x
19:51:48 <Cale> baz x = bar x
19:51:54 <Cale> this also works fine
19:51:55 <sclv> hmm... I'll try to see if I can get a small example that actually shows my problem
19:52:08 <sclv> I might accidentally be using polymorphic recursion
19:52:22 <Cale> sclv: I recommend removing all the type signatures and seeing what the inferred types are.
19:52:26 <sclv> accidentally on purpose that is.
19:53:03 <Cale> and if those don't match the types you've given, you've found the problem :)
19:53:07 <skew> then it won't work at all without signatures
19:53:36 <Cale> well, comment them out, don't really remove them :)
19:56:35 <sclv> yep.
19:56:49 <sclv> they're less polymorphic. why would that be?
19:57:19 <skew> do you have any explicit foralls?
19:57:36 <sclv> not that relate to this.
19:57:48 <skew> in the removed signatures?
19:57:55 <sclv> nope.
19:57:57 <skew> any polymorphic recursion?
19:58:01 <sclv> just a basic class constraint.
19:58:20 <sclv> I think I might have polymorphic recursion.
19:58:22 <skew> monomorphism restriction?
19:58:42 * LoganCapaldo has a crazy idea
19:58:53 <LoganCapaldo> maybe you could paste the code? <g>
19:59:06 * LoganCapaldo ducks
19:59:26 <sclv> the whole point of what I'm trying to do is essentially get action at a distance, so to speak -- make my parsers polymorphic on the return type so that I can use a single set of parse code to get different sort of results.
19:59:26 <Cale> sclv: Maybe the code that you've written makes assumptions about the values which you don't think that it does?
20:00:34 * sclv is now reading up on polymorphic recursion.
20:00:37 <Cale> Well, that's possible, so long as you're not actually encoding any of those details of what it's returning in the supposedly generic parts of the code.
20:00:47 <Cale> I doubt it's polymorphic recursion, myself.
20:01:18 <Cale> There was a good example of that the other day...
20:01:35 <sclv> Cale: why do you doubt that?
20:01:46 <Cale> Well, it's just a bit uncommon.
20:03:03 <Cale> > let foo :: (Show a) => Integer -> a -> String; foo 0 x = show x; foo n x = foo (n-1) (x,x) in foo 5 0
20:03:05 <lambdabot>  "(((((0,0),(0,0)),((0,0),(0,0))),(((0,0),(0,0)),((0,0),(0,0)))),((((0,0),(0,...
20:03:18 <Cale> There's an example of polymorphic recursion for you :)
20:03:46 <Cale> Note that the type of the second parameter is changing as the function recurses.
20:04:40 <Cale> (but it's okay, because all that's being assumed is that it's some instance of Show)
20:06:52 <Cale> > let foo 0 x = show x; foo n x = foo (n-1) (x,x) in foo 5 0
20:06:52 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, a)
20:06:52 <lambdabot>       Expec...
20:07:13 <Cale> That type signature is crucial though.
20:08:33 <Cale> > let foo 0 x = show x; foo n x = foo (n-1) (x,x) in foo 4 ()
20:08:34 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, a)
20:08:34 <lambdabot>       Expec...
20:08:39 <hpaste>  sclv pasted "polymorphic recursion irritation" at http://hpaste.org/4944
20:08:40 <Cale> > let foo :: (Show a) => Integer -> a -> String; foo 0 x = show x; foo n x = foo (n-1) (x,x) in foo 4 ()
20:08:40 <lambdabot>  "(((((),()),((),())),(((),()),((),()))),((((),()),((),())),(((),()),((),()))))"
20:09:04 <sclv> I think that's it -- the paste example shows in spirit sort of what I'm doing.
20:09:52 <Cale> What happens if you change that to baz x = toBar x ?
20:10:42 <Cale> If that works, you might want to apply the GHC flag -fno-monomorphism-restriction
20:10:46 <sclv> then it works!
20:10:49 <Cale> Right.
20:10:50 <sclv> good call.
20:11:25 <shachaf> {-# LANGUAGE NoMonomorphismRestriction #-}, possibly.
20:11:31 <Cale> The monomorphism restriction means that GHC won't infer a polymorphic type for a pattern binding like that.
20:12:10 <sclv> haha it still fails for my real code though.
20:12:47 <Cale> Let's see your real code.
20:12:56 <sclv> Ah well, type signatures aren't the worst things to have.
20:13:21 <sclv> real code is 600 lines, none of which seperates out easily for this problem. :-(
20:13:41 <Cale> Sure, but at least then I could load something into GHCi and play around with it.
20:14:20 <skew> what are the less and more polymorphic types you get?
20:14:54 <Cale> Yeah, knowing the exact error message would help some too :)
20:15:29 <sclv> Cale: going to send you an email. hang on.
20:15:55 <hpaste>  LoganCapaldo pasted "trying to do Cale's function w/o type annotations, it doesn't work :(" at http://hpaste.org/4945
20:16:11 * Cale listens to http://uk.youtube.com/watch?v=f9a4ThBNacY while hanging on.
20:16:12 <lambdabot> Title: YouTube - Victor Wooten - Norwegian Wood
20:16:43 <skew> LoganCapaldo: I'm pretty sure inferring types for that sort of function is undecidable
20:18:54 <glguy> If cartoon characters didn't have sex, then how would we get new cartoon characters?
20:19:14 <LoganCapaldo> cartoonists
20:19:40 <sclv> just sent.
20:19:43 <glguy> hmm, wrong channel (The Office quote)
20:19:50 <idnar> yeah, you get new cartoon characters from cartoonists havinrg sex, not cartoons having sex ;)
20:19:52 <hpaste>  Cale annotated "trying to do Cale's function w/o type annotations, it doesn't work :(" with "try this" at http://hpaste.org/4945#a1
20:21:25 <sclv> It's the Stringable a constraint that's killing me.
20:21:39 <sclv> on the other hand, like I said, type annotations aren't the worst things in the world.
20:21:53 <diltsman> No, LISP is.
20:22:01 <diltsman> Supid parenthesis.
20:22:02 <Cale> uh, okay, I get a bunch of Ambiguous occurrence errors.
20:22:22 <LoganCapaldo> Cale: that does work, I figured what I wrote was equivalent, I guess not
20:22:24 <sclv> hmm -- I redefined on and intercalate at the top of the Base file because I'm still in 6.6
20:22:33 <sclv> so if you comment those out it might work?
20:22:35 <Cale> Oh, okay
20:22:42 <Cale> It's actually getFirst
20:22:44 <LoganCapaldo> *Main> :t foo
20:22:45 <LoganCapaldo> foo :: (Show a, Num t) => t -> a -> String
20:22:49 <LoganCapaldo> tee hee
20:22:50 <Cale> imported from Data.Monoid
20:23:03 <sclv> right: I had to add that to the Classes file too
20:24:23 <Cale> okay, Base.hs loads for me
20:24:43 <Cale> Or... is there another module causing the problem?
20:25:02 <sclv> try commenting out the type signature for Comment or Blank
20:25:26 <runar> SOE uses a function called windowTick, but this doesn't seem to exist in any library. Do you know what I could use instead?
20:25:41 <tehgeekmeister> is it possible to import only selected functions, rather than a whole module?
20:26:07 <glguy> 40 minutes until Portal?
20:26:08 <Cale> sclv: sorry? Which file?
20:26:22 <LoganCapaldo> tehgeekmeister: yeppers
20:26:22 <glguy> I can't do this whole multi channel irc-ing
20:26:31 <LoganCapaldo> import Foo ( a, b, c )
20:26:35 <sclv> Cale: in Base
20:26:41 <tehgeekmeister> LoganCapaldo: the spaces are necessary?
20:26:46 <Cale> tehgeekmeister: It's also possible to import a whole module, hiding certain functions.
20:26:50 <LoganCapaldo> no I just like spaces
20:27:14 <tehgeekmeister> Cale: i was aware of that, just not the reverse.  thanks tho.
20:27:46 <shachaf> tehgeekmeister: Do you know about (..) syntax?
20:27:59 <Cale> sclv: commenting out the type signature for comment works.
20:28:02 <tehgeekmeister> shachaf: don't believe so?
20:28:12 <Cale> same goes for blank
20:28:17 <sclv> hmm.. for me it fails hard. must be fixed in 6.8.
20:28:42 <Cale> comment :: forall a. (Stringable a) => GenParser Char (Char, Char) (SEnv -> a) -- this is the inferred type
20:28:58 <tehgeekmeister> LoganCapaldo: any idea why import Control.Applicative (<$>) isn't working then?
20:29:11 <sclv> beautiful. it gives me (SEnv -> String) when I comment out everything.
20:29:12 <LoganCapaldo> more parens
20:29:14 <Cale> blank has the same inferred type
20:29:19 <LoganCapaldo> ( (<$>) )
20:29:23 <LoganCapaldo> i think
20:29:29 <Cale> sclv: So you just have to upgrade :)
20:29:43 <sclv> exactly!
20:30:08 <tehgeekmeister> LoganCapaldo: yep, that works, thanks.
20:30:09 <Cale> I don't know why 6.6 would infer that less polymorphic type.
20:30:27 <Cale> But *lots* of changes have been made to the type system from 6.6 to 6.8
20:30:34 <LoganCapaldo> cause it's a buggy wuggy haskell waskell compiley wiley
20:31:09 <sclv> In any case, I want this to build well across both, so no harm in leaving the type signatures in.
20:31:42 <sclv> thanks much for the help! Cale++
20:32:11 <Cale> No problem.
20:33:12 <Cale> One of the coolest new features of the type system in 6.8 is that (at least if you use the GADT syntax), data declarations with typeclass constraints finally mean what everyone's always expected them to mean :)
20:33:36 <Cale> You can write:
20:35:24 <Cale> data OrdList a where ONil :: Ord a => OrdList a; OCons :: (Ord a) => a -> OrdList a -> OrdList a
20:35:57 <Cale> and it will stash the instance of Ord in with the values, so that functions which take OrdLists as parameters don't have to have Ord constraints.
20:36:21 <Cale> (at least for the type variable which OrdList is being applied to)
20:36:44 <Cale> So you can write  sort :: OrdList a -> OrdList a
20:36:51 <sclv> very nice.
20:38:08 <Korollary> goalieca: Cowan is an idiot
20:38:35 <LoganCapaldo> Cale: does that have any benefit  besides doing what you expect? Seems like it would make sort "simpler"
20:39:07 <goalieca> :(
20:39:09 <Cale> Well, it does mean that you can write certain instances which you couldn't before.
20:39:11 <shachaf> LoganCapaldo: Simpler in what way?
20:39:34 <LoganCapaldo> in term of code generated for it
20:39:38 <LoganCapaldo> *terms of
20:40:14 <Cale> Well, instead of getting the typeclass instance record as a parameter, it extracts it from the OrdList value.
20:40:24 <Korollary> goalieca: ouchie
20:40:26 <goalieca> Korollary, :(
20:40:43 <goalieca> Korollary, i could have stopped that one
20:40:53 <Cale> It does mean that you're carrying around lots of extra pointers to that dictionary, but that makes the dictionary really accessible, so it's good :)
20:41:32 * Cale doesn't understand what Korollary and goalieca are talking about.
20:42:16 <goalieca> > print "canucks are sucking bad"
20:42:18 <lambdabot>  <IO ()>
20:42:32 <Cale> Hockey?
20:42:38 <Korollary> > "Coyotes" > "Canucks"
20:42:39 <lambdabot>  True
20:42:57 <goalieca> > "Phoenix" < "Vancouver"
20:42:58 <lambdabot>  True
20:43:17 <Korollary> This will go to overtime then
20:43:18 <ramza3> > 1 + 2
20:43:19 <lambdabot>  3
20:43:37 <goalieca> lol
20:44:14 <ramza3> > let a = 3
20:44:14 <lambdabot>  Parse error at end of input
20:45:17 <Cale> > foldr (either (\x (y,z) -> (x+y,z)) (\x (y,z) -> (y,x+z))) (0,0) [Right 1, Left 2]
20:45:18 <lambdabot>  (2,1)
20:46:28 <seabre> >map (+1) [1..10]
20:46:30 <Cale> > foldr (either (\x (y,z) -> (x+y,z)) (\x (y,z) -> (y,x+z))) (0,0) [Right 1, Left 3]
20:46:33 <lambdabot>  (3,1)
20:46:44 <ramza3> bots are cool
20:46:46 <Cale> seabre: the space after > isn't optional
20:46:46 <seabre> oh, I guess you need a space? but that's neat.
20:46:51 <LoganCapaldo> i really like the gadt syntax
20:46:57 <ramza3> > map (+1) [1..10]
20:46:58 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
20:47:00 <seabre> >map (+1) [1..10]
20:47:06 <seabre> I'm a moron
20:47:08 <seabre> ha ha
20:47:10 * LoganCapaldo comments randomly
20:47:13 <Cale> and this is my wife
20:47:20 <seabre> It's late or me anyway
20:47:21 <Cale> she's frosting a cake with a paper knife
20:47:23 <seabre> *for me
20:47:35 <LoganCapaldo> data Bool where { True :: Bool ; False :: Bool }
20:47:36 <Cale> all what we got here's American made
20:47:40 <ramza3> @type map
20:47:41 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:47:47 <Cale> a little bit cheezy but it's nicely displayed
20:47:57 <ramza3> @type (.)
20:47:57 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:48:05 * LoganCapaldo adds syntax extensio
20:48:18 <LoganCapaldo> data a@Bool where { True. False :: a }
20:48:22 <LoganCapaldo> s/./,/
20:50:37 <Cale> :t map . map . map $ map
20:50:38 <lambdabot> forall a b. [[[a -> b]]] -> [[[[a] -> [b]]]]
20:50:55 <Cale> :t fmap map map . map $ map
20:50:56 <lambdabot> forall a b. [[[a -> b]]] -> [[[[a] -> [b]]]]
20:51:14 <Cale> :t fmap (fmap map map) map $ map
20:51:14 <lambdabot> forall a b. [[[a -> b]]] -> [[[[a] -> [b]]]]
20:51:48 <Cale> :t fmap (fmap fmap fmap) fmap $ fmap
20:51:48 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => f (f1 (f2 (a -> b))) -> f (f1 (f2 (f3 a -> f3 b)))
20:52:00 <dibblego> that's some heavy lifting
20:52:38 <Lycurgus> shapr: ping.
20:52:40 <Cale> :t fmap (fmap fmap fmap) fmap `fmap` fmap
20:52:40 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
20:52:58 <ramza3> Cale: ok, that last one is unreadable
20:53:03 <Cale> It's fun how basically any combination of fmap's is valid :)
20:54:46 <ramza3> > map . map . map $ (map (+1) [1..10])
20:54:47 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
20:55:21 <LoganCapaldo> @type let buffalo = fmap in buffalo buffalo buffalo buffalo buffalo
20:55:21 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
20:55:21 <lambdabot>     Probable cause: `buffalo' is applied to too few arguments
20:55:21 <lambdabot>     In the fourth argument of `buffalo', namely `buffalo'
20:55:38 <Cale> monomorphism restriction
20:55:46 <LoganCapaldo> I had a feeling
20:55:46 <Cale> @type let buffalo f = fmap f in buffalo buffalo buffalo buffalo buffalo
20:55:47 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
20:56:02 <ramza3> I am working on a amqp client; may have to release it early because I probably cant work on it anymore (currently does publish to queue)
20:56:13 <Cale> Need a datatype with a Buffalo constructor :)
20:57:34 <sclv> @type let buffalo f = fmap f in buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo  buffalo buffalo buffalo buffalo buffalo buffalo  buffalo buffalo buffalo buffalo buffalo buffalo
20:57:35 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
20:58:08 <sclv> somebody demonstrated the fmap cycle at some point on irc i recall.
20:58:18 <Cale> @type let buffalo f = fmap f in buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo  buffalo buffalo buffalo buffalo (buffalo buffalo  buffalo buffalo) buffalo (buffalo buffalo) buffalo
20:58:19 <lambdabot> forall a (f :: * -> *) a1 a2 b. (Functor f) => (a2 -> b) -> (a1 -> a2) -> (a -> a1) -> f a -> f b
20:58:48 <sclv> and, magically, that seems sort of useful!
20:59:32 <goalieca> > score++
20:59:32 <lambdabot>   parse error on input `}'
20:59:34 <sclv> man, we need an @buffalo plugin for lambdabot to buffalo up your code.
21:03:39 <Korollary> goalieca: nice goal
21:03:42 <goalieca> tabarnac
21:18:36 <bos> @seen dons
21:18:36 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 4h 16m 43s ago.
21:21:26 <Korollary> goalieca: lol wtf did Sanford do?
21:23:57 <aFlag> god, I think I'm having that dream where everything is a buffalo again
21:24:35 <JanglerNPL> Malkovich? Malkovich Malkovich!
21:51:51 <sclv> haha I've got a new gripe now -- the list monad only works on lists and not monoids in general.
21:51:53 <sclv> :-(
21:52:24 * sclv doesn't even quite know if it would make sense the other way but figures...
21:54:24 <allbery_b> what are you trying to do?
21:54:55 <sclv> generalize something that worked on lists to something that works on monoids.
21:55:26 <dubblego> what operation?
21:58:40 <sclv> complicated.
21:58:58 <sclv> iterApp [f] vars@(LI xs:vs) = (liTrans vars >>==) . flip f
21:59:11 <sclv> is what I have now, where m >>== k = foldr (mappend . k) mempty m
21:59:44 <sclv> I'm going to replace the name of that operator with >>=:/
21:59:50 <sclv> to signal my displeasure.
22:01:52 <ricky_clarkson> heh
22:06:38 <xpika> @pl liftM2 (++) id id
22:06:38 <lambdabot> liftM2 (++) id id
22:11:07 <sclv> actually, yeah, you couldn't have a generic monoid monad, I think. it sort of defeats the purpose of monads even.
22:14:14 <clanehin> I assume it would be a generalized nondeterministic monad (like list).  Several people have tried to put together a Set monad.
22:14:38 <sclv> the problem is mconcatMap isn't a "real" bind.
22:14:40 <clanehin> you would need more operations that monoid provides, I think
22:15:49 * sclv should stop using the list monoid just for concatMap in order to quit confusing himself.
22:21:07 <Cale> >>= is concatMap anyway
22:21:40 * Cale reads more context
22:21:44 <sclv> Cale: exactly. but when I just mean concatMap I should say it instead of using >>= probably.
22:22:10 <sclv> otherwise it obfuscates what I really mean.
22:22:15 <Cale> Often do-notation or list comprehensions are also good.
22:23:09 <Tac-Tics> why is ghc so hard to compile by source?
22:23:23 <bos> it is?
22:23:32 <bos> maybe i'm just used to the pain.
22:23:55 <Cale> Sometimes list comprehensions even have advantages over plain map.
22:24:01 <Cale> select (x:xs) = (x,xs) : map (\(y,ys) -> (y,x:ys)) (select xs)
22:24:01 <Cale> select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
22:24:32 <Tac-Tics> Requiring a GHC install to compile GHC is kinda lame =-[
22:24:41 <Cale> Tac-Tics: How is that lame?
22:24:52 <clanehin> You wouldn't want a general monoid monad, anyway, what would be the monad for integers over addition?  But if you used foldable, you could probably convert any foldable monoid back to a list.
22:24:54 <Cale> Tac-Tics: It's written in Haskell, how else are you going to compile it?
22:25:08 <sclv> @pl \(y,ys) -> (y,x:ys)
22:25:08 <lambdabot> second (x :)
22:25:16 <Tac-Tics> It just adds a lot of work to getting GHC installed on an OS without a package manager
22:25:27 <Cale> Tac-Tics: Don't compile it then.
22:25:33 <sclv> probably clearer yet!
22:25:37 <Cale> Tac-Tics: There are binaries for lots of platforms.
22:25:44 <Cale> sclv: well, yes :)
22:25:58 <Svrog> you could bootstrap it from c sources couldnt you?
22:26:00 <Cale> It does involve importing Control.Arrow for second though.
22:26:14 * bos wonders what the docbook equivalent of eqnarray is.
22:26:18 <Cale> Yeah, you can bootstrap, but it's not something for the faint of heart.
22:26:22 <Svrog> hehe
22:26:35 <Cale> (basically requires a GHC developer)
22:26:52 * sclv can't work without Control.Arrow, and increasingly, without Data.Monoid
22:27:10 <Cale> If you can install GHC to the point where you can compile GHC without bootstrapping, then there's no point in compiling it.
22:27:23 <Cale> So you just shouldn't compile it unless you're also going to hack on it.
22:27:30 <Tac-Tics> Cale: does that mean at that point you have achieved transcendence or something =-)
22:28:08 <sclv> Cale: well, you can get one marginally more tuned to your system.
22:28:24 <Cale> sclv: Yeah, but you'll probably never get those CPU cycles back.
22:28:43 <Cale> Just considering how long it takes to compile.
22:29:02 <sclv> a good excuse to step away from the computer and remember to eat, or reconnect with loved ones who wonder where you've been since you started to haskell...
22:29:55 <Cale> Compiling GHC without also hacking on it is just unnecessarily contributing to the heat death of the universe, and it will not be condoned!
22:30:06 <Tac-Tics> heh
22:30:11 <Tac-Tics> yeah, I'm about 20 minutes into it
22:32:21 <Tac-Tics> What makes GHC so enormous?
22:34:11 <Cale> Haskell with all the extensions is a complicated language, there's sophisticated type checking and inference, and there's lots of optimisations in there.
22:36:27 <Cale> Oh, plus all the libraries.
22:36:42 <Cale> Also, it recompiles itself in stages.
22:37:01 <Cale> (so that new optimisations go back into the compiler)
22:37:24 <Tac-Tics> I see, crazy
22:39:21 <Cale> Compiling GCC (which is also self-hosting) takes a long time as well, if I remember.
22:39:35 <Svrog> yes
22:39:41 <Svrog> not quite as long as ghc though
22:40:44 <Svrog> at least if you're just compiling gcc (as in no g++, java, objc, etc)
22:40:49 <Cale> Right.
22:42:22 <Cale> I hope that at some point someone revives some of the dead backends in the GHC code. It looks like there's some Java backend stuff in there, as well as .NET stuff.
22:43:51 <Cale> Not that I'd personally have much use for .NET support, but I'm sure some people could find a use for it. :)
22:44:24 <Cale> It would be pretty cool to see Haskell code running in an applet in my browser window, too. :)
22:45:35 <Korollary> Would it be cool because it's unusual?
22:45:42 <sclv> the java stuff, if its based on what I think it is, is terrible slow.
22:45:55 <Cale> Korollary: In part :)
22:46:14 <Korollary> Nowadays I don't get what makes things cool.
22:46:17 <sclv> I remember spj saying the .NET stuff was a potential target however.
22:46:38 <Tac-Tics> How hard is it to get involved in hacking GHC?
22:46:41 * sclv anticipates LLVM with much excitement
22:46:55 <Korollary> sclv: Why?
22:47:09 <Tac-Tics> I've always wanted to work on a compiler of some sort
22:47:22 <Tac-Tics> holy crap it finished
22:47:27 <Cale> ISTR there were some other people working on a Haskell -> JVM compiler which they had working... I'll see if I can find the mailing list message.
22:47:43 <sclv> there was some discussion on reddit -- close enough to c-- that we could rely on them to do the low level optimizations to target multiple architectures.
22:47:59 <Korollary> Tac-Tics: You can get involved gradually. Start with cleaning up documentation, contribute to libraries, etc. until you feel like you can hack on ghc itself.
22:48:01 <goalieca> Cale, that was posted on reddit today and it was called CAL IIRC
22:48:08 <Svrog> pretty much every functional language that compiles to java ends up being slow - apparently implementing tail recursion in a jvm is fairly tricky to do efficiently
22:48:15 <Cale> goalieca: I know about CAL, it's different.
22:48:22 <Cale> CAL isn't Haskell :)
22:48:29 <goalieca> from what i heard.. not it isn't..
22:48:35 <allbery_b> yhc has a number of backends from yhc core to various targets
22:48:36 <Korollary> Cale: There was a german guy who targeted jvm (lambda something)
22:48:47 <Cale> Lambada perhaps?
22:48:51 <sclv> yhc to javascript is awesome  however!
22:48:59 <Cale> yes, that is awesome :)
22:49:05 <Cale> Haskell for everything! :)
22:49:53 <ricky_clarkson> Svrog: One JVM does tail recursion, and Java 7 is expected to support it (both the language and VM).
22:50:05 <Svrog> ah
22:50:21 <ricky_clarkson> well, tail-call elimination.  I often use the wrong term there.
22:50:48 <Svrog> yeah i know what you meant
22:51:49 <Cale> hmm, maybe I dreamt it.
22:51:55 <Korollary> Cale: Nope
22:53:05 <ricky_clarkson> Svrog: sisc (Scheme on the JVM) does tail call elimination in a good way, afaik.. well, hacky but an elegant hack.
22:53:23 <Svrog> fair enough
22:54:05 <Cale> Well, Lambdada exists, but it looks a fair bit older than what I had in mind, but perhaps it really is it.
22:55:16 <Cale> The announcement for Lambada isn't even in my GMail account.
22:55:52 <shachaf> Cale: How old is your gmail account?
22:55:59 <Korollary> Cale: This was what I remembered: http://darcs.brianweb.net/lambdavm.dontuse/doc/
22:56:00 <lambdabot> Title: Lambda VM
22:56:12 <Cale> Korollary: aha!
22:56:18 <Cale> Now that sounds like it might be it
22:56:41 * allbery_b likes that "dontuse" in the path
22:56:45 <Cale> shachaf: Fairly old. I got my account when it was invite only.
22:56:56 <Cale> (pretty early on)
22:57:11 <shachaf> Cale: It was invite-only for a long time... :-)
22:57:31 <Cale> My earliest haskell-cafe messages are from 2004
22:57:54 <Korollary> I used to have a 5-digit slashdot id
22:58:04 <Cale> Yeah, I got it in 06/2004
22:58:52 <shachaf> 2004-05-08. :-)
22:59:08 <Korollary> gmail was released in April 1 2004 says wikipedia
22:59:27 <shachaf> Korollary: I thought it was March 31?
22:59:57 * allbery_b had a 3-digit /. id, but was already souring on it by then
22:59:58 <Korollary> I can't argue with you as I don't remember it myself that vividly
23:00:04 <Cale> I have somewhere around 487000 non-spam threads.
23:00:18 <Korollary> allbery_b: lol
23:00:35 <Cale> But they're still only using up about 6% of my available space
23:01:00 <Korollary> They must have magic spam-sharing filesystems
23:01:35 <Cale> er, no, that's completely wrong, I'm misreading g-mail's interface
23:02:23 <Cale> (that's 50 times the number of threads, since I thought it was counting pages -- a little thought makes that obviously unreasonable)
23:02:37 <Cin> is there anything i can read about in relation to haskell about proving a program's correctness that doesn't really require the reader to be very good at maths?
23:03:13 <Cale> Cin: uhh...
23:03:28 <Cale> Cin: Well, there are ways to make yourself better at maths :)
23:03:47 <Cale> "Types and Programming Languages" is the classic initial text.
23:04:55 <Cale> Also, Bird and Wadler's text, iirc, had lots of stuff about equational reasoning in it, but not too heavy on the mathematical requirements.
23:05:11 <Cale> (though it's probably showing its age somewhat by now)
23:06:05 <Cin> hum
23:06:24 <Cale> After TaPL, you'll probably want to get ATTaPL (which is something I should look into getting myself)
23:06:43 <Cale> (that's Advanced Topics in Types and Programming Languages)
23:07:32 <Cale> Mostly, if you know how induction works, you should be okay, since probably about 90% of the proofs primarily use induction.
23:07:48 <Korollary> Proving program correctness is rather cutting edge.
23:08:08 <Cin> in other words: for math geeks?
23:08:41 <Korollary> Actually math geeks in general don't care about programming that much. It's for researchers or high assurance software developers, etc.
23:08:58 <Cale> Now, there's also coinduction, and I don't know of a really beginner-level reference on how that works, but the idea is actually really simple, so it shouldn't be totally impossible to explain it without involving too much.
23:09:16 <Cale> Well, I care about programming, but I'm strange :)
23:09:19 <Korollary> Most people are perfectly happy with unit testing.
23:10:01 <Cale> However, I carry along my pure-mathematician's thoroughly impractical view of the world into programming.
23:10:49 <Cale> I'm actually more content thinking about how to design and construct programs than producing actual working software.
23:11:08 <Korollary> We call that an academic view.
23:11:11 <Cin> hm, i think i probably am, too
23:11:32 <Cin> i figure out how i'd write a program and then when it comes to dumb implementation i lose interest
23:12:03 <Korollary> Well 'dumb' is a keyword there
23:12:11 <Cale> Yeah, it's sort of like how we skip all the boring steps in proofs when communicating them.
23:12:29 <sclv> if you figure it out right the implementation isn't a dumb task!
23:12:58 <Korollary> It could be tedious, largely mechanical, etc. but people pay for that stuff.
23:13:06 <Cale> sclv: It's like "Yeah, okay, that can be done. I'm happy."
23:13:37 <Cale> No need to go about actually constructing it, so long as you can convince yourself that you could do it. :)
23:13:52 <sclv> Cale, well, sure, but if the question is how many LO (readable) C will it take, then it gets interesting again.
23:13:59 <Cale> hehe
23:14:02 <sclv> or how fast can it goes.
23:14:06 <Korollary> Cale: Can you convince that you could do it in limited time and limited computing power, etc.?
23:14:22 <Cale> Korollary: If you want to go that far :)
23:14:46 <Cale> You're right, that is usually a more interesting question though :)
23:15:53 <Korollary> The only reason I am interested in haskell is that I have a feeling (and just a feeling) that it could lead to huge productivity gains. I know I can write anything in C++, Java, what have you. But they don't give me an edge.
23:19:57 <Cin> haskell interests me because laziness and value-orientation seem like they could provide performance gains and increase the ability to reason about programs. i don't have a job so i my interests are always academic
23:20:30 <Cin> although i have a php job interview soon, heh
23:20:37 * Cin chortles
23:20:50 <Korollary> A job is a job.
23:20:55 <Cin> indeed
23:22:14 <Cin> i'll probably look at Qi or Prolog next =]
23:22:22 <Cale> I'm way too excited by parallelism for someone who doesn't have an SMP machine.
23:22:33 <Cin> heh
23:22:42 <Cin> mapreduce is pretty sexy
23:23:07 <Cale> well, and the recent research being done in Haskell on parallelism and concurrency is pretty sexy too
23:23:23 <Cin> mhm!
23:23:45 <Korollary> Recent research always looks sexy.
23:23:59 <Cale> I often find the opposite is true :)
23:24:02 <Cin> i think i'll actually watch SPJ's talk about STM on blip.tv now
23:24:21 <Korollary> That's what I always think about when I read papers from the previous decade. "Somebody truly thought this was sexy. Oh well."
23:24:24 <Cale> It often takes a long time for results from recent research to be refined enough so that they actually look good.
23:24:32 <Cale> Though maybe in CS the situation is different.
23:24:37 <shachaf> Cin: I'd suggest downloading it and watching it locally.
23:24:44 <Cin> shachaf: why's that?
23:24:51 <shachaf> (If blip.tv is the one I think it is.)
23:25:04 <shachaf> Cin: I'm not sure anymore. :-)
23:25:06 <BMeph> I like Haskell, because it takes one of Alan Kay's principles - late binding - and applies it more generally and consistently than even Smalltalk.
23:25:22 <shachaf> I had some problem with it, but maybe they fixed it (or I was trying on a busy day).
23:25:23 <Cin> shachaf: flash palyer nonsense, i think
23:25:39 <Korollary> I didn't have a problem with blip.tv
23:25:44 <Cale> Korollary: and of course, nothing is truly finished until it can be taught to undergraduates
23:25:50 <shachaf> No, the player loaded, it was something else.
23:25:52 <shachaf> Never mind.
23:26:10 <Korollary> Cale: Hey, then Java is finished. Yeehaa.
23:26:24 <Cale> It was finished before it started.
23:26:34 <Cin> cale: good point (about looking good). haskell's concurrency research seems relevant and practical right now, so it looks really good
23:26:54 <Cale> yeah
23:27:15 <Cale> and not only that, but it actually looks fairly well-designed from the get-go, at least with STM.
23:27:37 <Cale> Maybe the implementation of STM will change, but those are definitely the primitives you want for effectful concurrency.
23:28:07 <Cale> (atomic blocks, retry, and orElse)
23:28:41 <Cale> It has good composability and good algebraic structure (and those are obviously related)
23:31:28 <bos> i'm trying to find a good intuitive way to explain the third monad law: m >>= (\x -> f x >>= g) == (m >>= f) >>= g
23:31:37 <bos> it's not quite an associativity law.
23:31:40 <Cale> bos: Convert it to do-notation.
23:32:01 <Cale> It is actually an associativity law, but this view of monads doesn't let you see that directly.
23:32:06 <bos> right.
23:32:34 <Cale> (If you watch the catsters videos, they have a much nicer, but also much more abstract way to picture it)
23:32:55 <Cale> If you restrict it to >> it becomes obvious that it's associativity there.
23:33:04 <BMeph> It's association by definition. I think you mean it isn't commutative, though. :)
23:33:20 <Korollary> No, I think he's talking of the lambda
23:33:37 <Cale> BMeph: Well, it's not clearly in the form of an associativity law when written that way above.
23:35:06 <BMeph> Cale: Yeah, I guess you'd have to say that it isn't purely associative, but barring the whole difference in the commutativity, it is.
23:35:42 <Cale> BMeph: operators can be associative but not commutative, but that's not what we're talking about
23:35:57 <Cale> Normally an operator * is called associative when (a * b) * c = a * (b * c)
23:36:11 <Cale> and in this form, bind doesn't quite look like that.
23:36:19 <Korollary> f >>= g and g >>= f may not be equal, but g >>= f is not even valid.
23:37:04 <Cale> In category theoretic notation, the associativity law is an equation of natural transformations T^3 -> T, where T is the functor which is your monad
23:37:19 <BMeph> Cale: Well, yes, but in this case, bind is structurally non-commutative. It isn't commutative because the types aren't the same.
23:37:22 <Cale> It says that mu . T mu = mu . mu T
23:37:23 <hpaste>  bos pasted "associativity with do notation" at http://hpaste.org/4946
23:37:41 <Cale> That is, doing mu first on the second two copies of T, and then on the remaining two
23:37:58 <Cale> is the same as doing mu on the first two copies of T, and then doing mu on the remaining two
23:38:08 <Cale> (remember, mu : T^2 -> T)
23:38:15 <bos> crap, the indentation got messed up.
23:38:34 <hpaste>  bos annotated "associativity with do notation" with "fixed indentation" at http://hpaste.org/4946#a1
23:39:17 <bos> i wonder if this looks any clearer with fmap and join.
23:39:26 <Cale> bos: The most useful way to interpret associativity from a functional programming perspective that I've managed to come up with is that it says you can chop subsections of do-blocks out, and define them as new actions, without affecting the meaning of the code.
23:39:47 <Cale> (if you know what I mean by that -- if not I can demonstrate)
23:39:49 <bos> Cale: that's exactly the verbal definition i had.
23:40:17 <luqui> with GHC, can I compile in different default RTS options?
23:40:34 <luqui> i mean for a specific program, I'd like it to by default run with, say, +RTS -V0.002
23:40:52 <bos> yes, you can set a global variable that the RTS will look in.
23:41:14 <Cale> I think you might have to do that from C though, at least, it used to be the case...
23:41:22 <luqui> ew...
23:41:35 <Cale> It's not so bad.
23:41:53 <Cale> You just create a small C source file which gets compiled in using GHC.
23:42:02 <Cale> (you can actually use GHC as a C compiler as well)
23:42:08 <luqui> well so far I am completely C-free so far.  You know, it feels dirty...
23:42:12 <Cale> hehe :)
23:43:10 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-hooks
23:43:11 <lambdabot> Title: 5.14. Running a compiled program, http://tinyurl.com/d7dj4
23:43:56 <Korollary> It's odd that GHC extensions don't provide that.
23:44:06 <Cale> yes
23:44:30 <Cale> Like, why can't Haskell programs simply define a String  ghcRtsOpts ?
23:45:04 <Korollary> or have a function setRtsOpts :: String -> IO ()
23:45:08 <Cale> yeah
23:45:10 <luqui> nice, that was easy...
23:45:22 <Cale> I was going to say, or better yet, control the options at runtime :)
23:46:34 <Cale> (maybe with an even nicer interface than setting a string)
23:48:15 <Svrog> i think runtime options would better be handled as a pragma of some sort than exposing ghc_rts_opts directly
23:48:32 <Svrog> from haskell
23:48:39 <Cale> Svrog: perhaps
23:48:51 <luqui> {-# RTS -V0.002 #-}
23:48:58 <Cale> yeah
23:49:16 <sjanssen> but RTS options only make sense in the main module -- library code shouldn't be able to set them
23:49:47 <sjanssen> I'd rather see a GHC flag to set the defaults at link time
23:49:51 <Cale> It would be interesting to have the ability to change GC options at runtime though.
23:50:20 <Cale> (why exactly you'd want to do that, I'm not entirely certain, but it would be interesting)
23:51:48 <Cale> Or be able to say "I want to start profiling right now", and then stop it at some later program-controlled point.
23:52:17 <Cale> But I don't know how much work it would be to make that happen :)
23:55:15 <Cale> Someone also pointed out that there are some other self-reflective sorts of things which would be nice to have -- like the ability to get a list of all the currently running thread ids. (Perhaps useful from GHCi)
23:57:20 <Cale> (or I should perhaps say 'runnable' rather than 'running')
