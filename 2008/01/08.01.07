00:05:11 <sclv> is there a reason why all monoids aren't functors?
00:05:33 <sclv> Ok I just realized that was a stupid question as I was asking it.
00:10:12 <sclv> First and Last should be functors though at a minimum.
00:11:08 <sclv> actually... maybe they all should be.
00:12:29 <Cale> uh, how so?
00:12:40 <Cale> oh
00:13:00 <sclv> instance Functor First where
00:13:01 <sclv>     fmap f x = First . fmap f . getFirst $ x
00:13:30 <Cale> oh, I see. It's another name for Maybe
00:13:36 <sclv> every monoid is a container with an associative operation, no?
00:13:42 <Cale> No.
00:13:47 <Cale> Most monoids aren't.
00:14:22 <Cale> Well, depends on how you mean the word "container"
00:14:34 <sclv> in a sense, I mean. All is, Any is, Sum is.
00:14:54 <sclv> the tuples might be trickier
00:15:06 <Cale> A monoid is a set of elements (in Haskell we just use a type) together with an associative operation with an identity.
00:15:35 <Cale> Those elements need not themselves be considered containers in any way.
00:15:46 <sclv> hmmm... I guess I just mean the newtypes in Data.Monoid should be functors then.
00:15:55 <Cale> How could Any be a functor?
00:16:04 <Cale> It doesn't have the right kind.
00:16:24 <Cale> Sum and Product, First and Last are, trivially.
00:16:42 <Cale> (as well as Dual)
00:16:46 <Cale> Endo isn't.
00:17:18 <sclv> hmmm... endo has the right kind at least.
00:17:42 <Cale> But there's no way to turn it into a functor.
00:18:43 <Cale> @djinn (a -> b) -> (a -> a) -> (b -> b)
00:18:43 <lambdabot> f _ _ a = a
00:19:16 <Cale> heh
00:19:33 <Cale> I suppose that would "work", in a dumb way.
00:20:05 <Cale> (make fmap f = id)
00:20:23 <Cale> er
00:20:34 <Cale> fmap f x = Endo id, rather
00:21:04 <Cale> It satisfies the functor laws, but it's obviously not very interesting.
00:21:14 <sclv> hmm... i see what you mean.
00:21:56 <Saizan> fmap id == id no? so it doesn't even satisfy them
00:23:13 <Cale> oh, right, yes
00:23:40 <Cale> So, right, there are none.
00:26:54 <sclv> the reader monoid is also trivially a functor though.
00:27:13 <sclv> but I think it automatically is anyway.
00:27:55 <Saizan> there's an instance of it, like there's an instance for monad
00:28:03 <sclv> I guess you really call it the writer monoid though...
00:29:33 <Saizan> uh? the writer monad just uses monoids
00:30:20 <sclv> getting my terms straight still..
00:30:24 <sclv> I just figured that
00:30:26 <sclv> instance Monoid b => Monoid (a -> b) where
00:30:26 <sclv> 	mempty _ = mempty
00:30:26 <sclv> 	mappend f g x = f x `mappend` g x
00:30:50 <sclv> would be more the "writer" than "reader" monoid since its parameterized on its output.
00:31:15 <sclv> (or rather, on both, but on its output being a monoid)
00:31:49 <ibid> say hello to class, everyone :)
00:32:06 <Saizan> hello :)
00:32:58 <Saizan> however, to me it seems connected to the reader monad due to the 'a' argument of those functions
00:33:35 * ibid vanishes
00:35:43 <quicksilver> it is connected to the reader monoid, yes
00:35:55 <quicksilver> you could write that as mappend = liftM2 mappend
00:36:04 <quicksilver> and the monoid would be Reader
00:36:08 <quicksilver> erm
00:36:09 <quicksilver> monad :)
00:38:07 <sclv> ah. cool.
00:38:24 <Saizan> right, there's probably a CT name for this, like lifting the monoid in the monad?
00:39:31 <quicksilver> I'm not sure it's a very natural CT concept
00:39:43 <quicksilver> it's an obscure little fact and monoids and exponentials
00:40:02 <quicksilver> "most" of CT isn't about exponentials, since "most" of CT isn't done in cartesian closed categories.
00:40:16 <quicksilver> Although perhaps this result is more general and applies to any adjunction, I'm not sure :)
00:40:31 <doserj> huh? you only need that (->) a is a functor, and that is a very natural concept in CT
00:40:48 <quicksilver> that's one way of looking at it, yes
00:41:13 <Saizan> doserj: you need more than functor for liftM2
00:41:35 <Saul_> :t liftM2
00:41:37 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:41:45 <doserj> :t liftA2
00:41:45 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
00:41:49 <idnar> :t fmap
00:41:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:44:10 <doserj> so you need a little bit more than a functor, yes :)
00:45:05 <quicksilver> doserj: you can ask the question for any functor
00:45:15 <quicksilver> but it's not the case that every functor preserves monoids
00:45:30 <quicksilver> you could talk about monoid-preserving functors, etc
00:45:37 <max__> can I write my differential geometry analysis engine in haskell?
00:45:53 <quicksilver> the "theorem" here is that the exponential functor preserves monoids.
00:46:07 <Cale> max__: why not?
00:46:09 <quicksilver> I'm not sure if that's a special case of a general theorem about adjoin functors and monoids. It probably is.
00:46:17 <lament> @faq can max__ write his differential geometry analysis engine in haskell?
00:46:17 <lambdabot> The answer is: Yes! Haskell can do that.
00:46:31 <max__> yay
00:46:33 <quicksilver> left adjoints preserve limits and all finite colimits.
00:46:36 <quicksilver> or something like that
00:46:44 <quicksilver> I forget :)
00:53:29 <jsnx> @faq can mice eat salami as well as cheese?
00:53:30 <lambdabot> The answer is: Yes! Haskell can do that.
00:54:51 <jsnx> @faq can haskell create a stone so heavy that haskell can not lift it?
00:54:51 <lambdabot> The answer is: Yes! Haskell can do that.
00:55:09 <jsnx> hmm...there is something wrong with lambdabot's solver
00:55:46 <Valodim_> @faq Can a woodchuck chuck wood if a woodchuck would chuck wood?
00:55:46 <lambdabot> The answer is: Yes! Haskell can do that.
00:55:51 <Valodim_> haha
00:55:57 <Valodim_> yep
00:59:16 <jsnx> how do i say `data Relation = Relation (of any tuple whatsoever)`
00:59:20 <jsnx> ?
00:59:53 <jsnx> or, maybe i need a typeclass
01:00:38 <mattam> what kind of tuple do you want ?
01:00:56 <jsnx> well, i want to define the type and the length of the tuple later
01:01:08 <notsmack> jsnx: then what's the use of this type?
01:01:25 <jsnx> notsmack: well, maybe it should be a type class instead
01:01:47 <max__> @faq can haskell prove it's consistency?
01:01:47 <lambdabot> The answer is: Yes! Haskell can do that.
01:01:55 <Valodim_> (its)
01:02:08 <jsnx> i could make it a `Relation a`, and then make `a` a tupel when i use it
01:02:47 <jsnx> but then i could get `Relation Int`, which I want to ban
01:02:50 <mattam> If it is going to be a variable length then yes, you can't do that using just a data declaration and some tuple.
01:03:02 <Saizan> it's hard to write code polymorphic on "flat" tuples
01:03:21 <jsnx> mattam: yes i can't? no i can't? yes i can?
01:03:25 <mattam> Why not type Relation A = A -> A -> bool ?
01:03:41 <mattam> you cannot
01:04:00 <jsnx> mattam: that's a function
01:04:07 <jsnx> mattam: no the data type i had in mind
01:04:11 <quicksilver> jsnx: the short answer is don't.
01:04:20 <quicksilver> jsnx: just make data Relation a = Relation a
01:04:21 <mattam> Yes, I'm just suggseting
01:04:30 <jsnx> 'cuz i want to make polymorphic select and join and project
01:04:35 <quicksilver> jsnx: and then impose the restriction that it has to be a tuple using type classes
01:04:43 <jsnx> quicksilver: aha, i see
01:04:49 <quicksilver> you end up with types like (Tuple t) => Relation t
01:07:38 <jsnx>  could i make a recursive `data` definition that, instead of different
01:07:38 <jsnx>          size tuples, just had more or less relations in it?
01:07:51 <quicksilver> I think so, but I don't really know what you mean :)
01:08:15 <jsnx> Relation a (Relation b (Relation c NilRelation))
01:09:08 <Saizan> another guy ready for reading the HList paper?
01:09:18 <jsnx> Saizan: oh, i see
01:09:29 <jsnx> just a sec
01:13:34 <wy> any information on constructor classes?
01:14:19 <quicksilver> well, they're just classes which have free type variables
01:14:23 <quicksilver> nothing very mysterious
01:15:05 <wy> It's very important to me
01:15:38 <max__> will learning haskell make category theory simple?
01:15:43 <quicksilver> max__: no.
01:15:50 <quicksilver> category theory is already simple.
01:15:54 <wy> I found that having a constructor and accessors is the only difference between a type and a class
01:15:55 <quicksilver> learning haskell will not change this.
01:16:15 <quicksilver> wy: I suspect you misunderstand what 'constructor class' means.
01:16:19 <quicksilver> Monad is a constructor class.
01:16:22 <max__> hm
01:16:27 <quicksilver> Because Monad is a type constructor, not a type.
01:16:38 <quicksilver> so we're talking about type constructors not data constructors.
01:16:41 <jsnx> max__: going the other way is better, i find
01:16:48 <quicksilver> Personally I prefer to speak of higher-kinded type classes.
01:16:53 <quicksilver> Monad :: * -> *
01:17:09 <quicksilver> (that's an abuse of notation, by the way! )
01:18:55 <jsnx> well, this relational-functional stuff is quite sophisticated
01:19:11 <jsnx> Saizan: thank you for pointing me to that paper
01:19:28 <wy> quicksilver: let me check my type theory ...
01:20:06 <quicksilver> wy: Even ignoring that point about what "constructor class" means, I disagree with your characterisation of the difference between types and classes.
01:20:10 <quicksilver> A type is, well, a type.
01:20:24 <quicksilver> A class is a group of types.
01:20:30 <quicksilver> If you like, a set of types, or a class of types :)
01:23:28 <wy> I just tried to reduce everything into sets... Let me check if there is something wrong
01:25:51 <gio123> who knows what is divergent program?
01:25:57 <wy> hey yminsky !
01:26:48 <wy> gio123: A program who never stops
01:30:43 <max__> hey, it seems like haskell is very mathematical in nature and would interact well with formalism and machine assisted proving
01:31:01 <Mr_Awesome> yes
01:31:08 <Valodim> that's kinda the point of it
01:31:10 <jsnx> yes, lots of people say that
01:31:20 <max__> where can I read more about tools for doing that?
01:32:00 <max__> verifying programs written in haskell and such
01:32:22 <wy> max__: checkout coq, but it's in OCaml
01:34:17 <gio123> wy: program which never stops is is nonterminating program!
01:34:42 <wy> gio123: Isn't that the same thing as divergent?
01:34:56 <gio123> wy: no idea
01:35:13 <gio123> maybe it is equvalkent to nondivergent?
01:35:23 <wy> gio123: That's the samething, because a convergent program will converge to a value
01:36:31 <quicksilver> sometimes people will include "terminates abnormally with an exception" in "divergent"
01:36:47 <quicksilver> so "divergent" might mean "runs for ever or throws an exception"
01:36:59 <quicksilver> while "convergent" means "terminates in finite time with a result"
01:38:26 <wy> I wonder why haskell can detect non-exaulstive pattern exception
01:40:23 <glguy> try that again?
01:41:14 <wy> I see...
01:41:32 <wy> It carries the variant number arround
01:42:03 <wy> It doesn't carry types, but it carries variant number.
01:43:25 <wy> That's kinda like runtime typing...
01:44:08 <wy> Yes. I believe that's partial types.
01:44:43 <wy> So haskell isn't really a "static" typed language
01:45:58 <max__> What is the term for a turing machine that stabilizes into a set of states that endlessly repeat such that for any step afterwards, each of those states will be visited in a later step?
01:46:10 <Cale> wy: But those are just values...
01:47:09 <wy> Cale: those are types, at least residual types
01:47:11 <glguy> wy: I don't think that it is clear what you are getting at
01:47:14 <glguy> can you give an example?
01:47:23 <Cale> Data constructors aren't types
01:47:27 <notsmack> max__: is that just nonterminating?
01:47:28 <Cale> They're data.
01:47:47 <max__> it would be by definition non halting, but its states wouldn't diverge
01:48:29 <notsmack> max__: it seems to me like any nonhalting machine fits your description...
01:48:41 <wy> Cale: there is no such thing as data... oh am I crazy
01:49:20 <wy> Cale: The world doesn't contain any data ;-)
01:49:51 <max__> by states I mean combined machine state and tape information, head position, etc
01:49:52 <glguy> maybe it's time to get some sleep and recover sanity?
01:50:08 <wy> glguy: right..
01:51:05 <Cale> max__: Perhaps you could call that "looping".
01:51:16 <max__> hm, that's just a nonterminating machine that never passes some position on the tape
01:52:02 <max__> or rather, simply ends up moving back and forth between two points (in an arbitrarily complex manner :D)
01:53:04 <Cale> But there are only finitely many states, and finitely many possible ways that segment of tape can be filled in, so it'll eventually repeat exactly if it only uses a bounded segment of the tape.
01:53:32 <max__> yeah, it has to
01:53:59 <max__> hmm
02:00:40 <levi13> Hi, I'm interested in playing around with the reactive library
02:00:53 <levi13> Any suggestions for reading/tutorials?
02:01:44 <Svrog> http://www.haskell.org/frp/
02:01:45 <lambdabot> Title: Functional Reactive Programming Research
02:03:23 <Svrog> http://wagerlabs.com/yampa/ is the current repository for yampa afaik - im not aware of any other more recent ones
02:03:23 <lambdabot> Title: Index of /yampa
02:03:52 <levi13> ok, I didn't know of that url, I had been following from the frp page
02:04:08 <Svrog> there appears to be a placeholder for yampa at darcs.haskell.org but there's nothing in there
02:04:27 <levi13> how does the reactive library compare to yampa?
02:04:37 <Svrog> yampa is afrp
02:05:40 <Svrog> you might also want to check http://conal-elliott.blogspot.com/
02:05:41 <lambdabot> Title: ConalBlog
02:07:22 <levi13> ok, thanks. I must admit most of what I've been reading on FRP hasn't clicked yet
02:07:32 <Svrog> join the club :)
02:08:23 <levi13> that's why I was looking at reactive rather than yampa, seems to be less code in the library ;)
02:09:11 <Svrog> oh right - when you said reactive i wasnt sure if you were talking about frp in general or not
02:10:03 <levi13> well, I'm interesed in frp in general, but reactive was looking like an easier intro
02:10:48 <Svrog> conal mentioned he's working on something similar to yampa/afrp based on Data.Reactive and some of his other libraries which should be interesting
02:12:20 <Svrog> ive only played with afrp and yampa so far, i can't quite get my head around the other libraries yet and im only now kind of getting the hang of afrp
02:12:23 <Svrog> i think
02:12:26 <Svrog> haha
02:13:12 <levi13> I think it's going take me a while :)
02:18:30 <Svrog> levi13: how does the reactive library compare to yampa? <-- just noticed that i didnt answer this - they are not quite the same thing, reactive is more general
02:19:22 <Svrog> and im still not quite sure how to use reactive to do anything really but i havent had the time to play with it much
02:20:31 <levi13> ok, thanks. I've downloaded the yampa code, so I might play around with that also
02:20:41 <Svrog> np
02:25:08 <Svrog> levi13: you might also want to check out frag and the related thesis if you havent done so already
02:27:17 <levi13> ok, I probably do need to reread the frag paper, and Yampa Arcade too
02:33:40 <levi13> I guess I should check also, is something like a HTTP server something that can be done using an FRP approach?
02:38:03 <quicksilver> no reason why not
02:38:08 <quicksilver> in fact, since HTTP is stateless
02:38:18 <quicksilver> it's often very easy to write HTTP stuff in a pure style
02:39:14 <levi13> ok, good to make sure I'm not trying something completely crazy ;)
02:45:37 <njbartlett_> http://www.londonhug.net/2008/01/07/darcs-patch-theory-and-gadts-with-ganesh-sittampalam/
02:45:39 <lambdabot> Title: Î»ondon HUG » Blog Archive » Darcs patch theory and GADTs with Ganesh Sittampala ..., http://tinyurl.com/3dk6ur
02:45:54 <osfameron> when is next londonhug meeting?
02:46:01 <njbartlett_> 23rd
02:46:06 <njbartlett_> See above link
02:46:21 <osfameron> ooo, shiny, I think I'm in London that week
02:46:51 <osfameron> do you go to the pub afterwards?
02:46:57 <njbartlett_> Of course!
02:47:03 <DRMacIver> Hm.
02:47:12 <osfameron> and is it OK to arrive after 6:30 (I finish around 5:30 near Gatwick)
02:47:28 <DRMacIver> That's the day before I fly out to the states. I might not be able to make it.
02:47:40 <njbartlett_> Well the talk will probably be under way, but it should be okay to sneak in quietly
02:47:55 <DRMacIver> Which is a shame, as it sounds interesting!
02:48:18 <osfameron> ok.  And will the pub be announced or just decided ad hoc after the talk?
02:48:21 <njbartlett_> DRMacIver: Well there's always the video later
02:48:32 <DRMacIver> Yeah
02:48:37 <njbartlett_> osfameron: The pub will likely be the Boudicea across the road
02:48:54 <DRMacIver> I'll probably come, but I definitely won't do the pub afterwards. :)
02:49:31 <njbartlett_> DRMacIver: We'll see if we can tempt you anyway...
02:50:08 <DRMacIver> Pub is less tempting than being properly prepared for a two week trip. :)
02:50:27 <njbartlett_> You could always pack before wednesday night...
02:50:46 <DRMacIver> What a silly notion. :)
02:53:56 <hpaste>  Mitar pasted "Defaulting the following constraint(s) to type `Integer'" at http://hpaste.org/4852
02:54:01 <Mitar> why?  Defaulting the following constraint(s) to type `Integer'?
02:56:18 <oerjan> Mitar: it's just a warning
02:56:30 <Mitar> yes, how can i remove it?
02:56:30 <oerjan> it has to choose a type for the exponents
02:56:33 <Mitar> i do not like warning :-)
02:57:03 <oerjan> well you must have -Wall set to get it in the first place?
02:57:34 <oerjan> last it came up, someone noted there's a flag specifically for that warning
02:58:48 <oerjan> -fwarn-type-defaults
02:59:04 <oerjan> to turn off, -fno-warn-type-defaults
03:00:28 <Mitar> thanks
03:04:42 <Mitar> great, it is normal that maximum dies on large lists with stack overflow?
03:04:57 <mux> if you don't build with -O, yes
03:05:09 <Zao> @src maximum
03:05:10 <lambdabot> maximum [] = undefined
03:05:10 <lambdabot> maximum xs = foldl1 max xs
03:05:30 <mux> same with sum
03:05:35 <mux> > sum [1..1000000]
03:05:37 <lambdabot>  500000500000
03:05:43 <mux> > sum [1..10000000]
03:05:49 <lambdabot> Terminated
03:05:53 <mux> oh well.
03:11:48 <oerjan> lambdabot does use -O
03:23:40 <luqui> what is an ivar?
03:24:11 <Svrog> in what context?
03:24:34 <Lemmih> Write once variable, I think.
03:25:22 <luqui> is it in the standard library?
03:25:28 <Lemmih> No.
03:25:34 <luqui> where can I get one? :-)
03:27:26 <Lemmih> I'm not sure. I think conal talked about their semantics on some list.
03:28:19 <luqui> (cafe, he thought that reading was referentially transparent, but it wasn't)
03:28:26 <luqui> that's the first place I heard about them
03:59:21 <TSC> Does anyone understand this type (by Lutz Donnerhacke in -cafe)
03:59:24 <TSC> unsafeShow :: (forall a . Show a => a) -> String
04:03:45 <mattam> a function which takes a polymorphic value of a type a which has an instance of Show, and probably use this instance to change a into a String ?
04:04:23 <TSC> I can't get it to compile
04:05:04 <mattam> I guess not, it seems to require second order quantification of typeclass constraints.
04:06:58 <mattam> I'm not entirely sure the show instance is availaible in unsafeShow or if you have to have it to apply the (forall a. Show a => a)
04:08:24 <oerjan> intuitively, unsafeShow x = show (x :: T) should be an implementation for any type T with a Show instance...
04:09:22 <oerjan> i.e. unsafeShow could freely select which instance to use
04:46:20 <shapr> @yow!
04:46:21 <lambdabot> I feel like I'm in a Toilet Bowl with a thumbtack in my forehead!!
04:51:39 <Lemmih> @time shapr
04:51:39 <lambdabot> Local time for shapr is Mon Jan  7 07:51:41 2008
04:59:46 <kuribas> This is valid haskell, right? "a i | i < 10 = 30 | i < 20 = 40"
05:00:40 <kosmikus> yes
05:01:29 * kuribas used to think that the |'s had to be on a different line.
05:02:15 <kosmikus> no
05:02:39 <Jomyoot> Could not find module `System.Time' it is a member of package old-time-1.0.0.0, which is hidden
05:02:41 <Jomyoot> What does that mean?
05:02:57 <Jomyoot> I am trying to install HSQL, is that the best Haskell module for interfacing mysql?
05:03:22 <doserj> you have to add old-time to the build-dependencies in the .cabal file
05:06:14 <oerjan> kuribas: layout applies only to things in do, where, let and of blocks.  everything else just has to be indented more than the surrounding statement/declaration/match in one of those
05:07:33 <Jomyoot> is Hsql what you recommend for using MYSQL?
05:08:08 <kuribas> oerjan: yes.  I also found out that toplevel variables are part of a where block, and therefore use layout.
05:08:26 <Philippa> oerjan: case, too
05:08:33 <Philippa> oh, "of". Yeah
05:08:40 <Philippa> stuff following of, but most people'd call that a case block
05:09:20 <Jomyoot> Is this an error: Database/HSQL/Types.hs:134:18: Not in scope: type variable `forall' ? Or is it a warning
05:09:40 * kuribas is writing an indentation engine for emacs.
05:09:48 <oerjan> Jomyoot: seems like you are missing the extension to enable it
05:10:07 <Jomyoot> i am installing HSQL fresh. so what extension do I need?
05:10:39 <oerjan> there are several alternatives.  perhaps just use -fglasgow-exts
05:11:05 <Jomyoot> do I add -fglasgow-exts to command line or to .cabal?
05:11:10 <dcoutts_> Jomyoot: hsql-1.7 has not been updated for ghc-6.8.x
05:11:32 <Jomyoot> dcoutts_: what should I do in that case then?
05:12:08 <dcoutts_> Jomyoot: complain loudly to the package author and since you'll get no response, apply the following patch...
05:12:40 <Jomyoot> is there an alternative MSQL package that will work with GHC 6.8?
05:12:59 <Jomyoot> what patch..?
05:13:07 <dcoutts_> Jomyoot: there's ODBC if MSQL will go via that
05:13:09 <dcoutts_> http://haskell.org/~gentoo/gentoo-haskell/dev-haskell/hsql/hsql-1.7.ebuild
05:13:10 <lambdabot> http://tinyurl.com/2d5546
05:13:18 <dcoutts_> Jomyoot: we patched it in the gentoo ebuild ^^
05:13:43 <dcoutts_> Jomyoot: you need to add old-time to build-depends, and Rank2Types, DeriveDataTypeable to extensions
05:14:23 <dcoutts_> Jomyoot: did you mean MySQL backend, rather than MSQL?
05:14:31 <Jomyoot> mysql
05:14:32 <Jomyoot> i meant
05:14:54 <dcoutts_> Jomyoot: it also needs a patch
05:14:58 <dcoutts_> http://haskell.org/~gentoo/gentoo-haskell/dev-haskell/hsql-mysql/hsql-mysql-1.7.ebuild
05:14:59 <lambdabot> http://tinyurl.com/2hs5ey
05:15:26 <dcoutts_> sadly hsql seems to be totally unmaintained
05:15:44 <Jomyoot> thanks
05:15:48 <dcoutts_> hdbc is much better maintained but lacks a MySQL backend
05:15:48 <Jomyoot> but is hsql what i should use?
05:15:58 <Jomyoot> i am very new to haskell. i will use the easiest one
05:16:02 <Jomyoot> that is available
05:17:34 <dcoutts_> Jomyoot: if you're restricted to MySQL then I think hsql is the only one, though I've heard there is some minimal mysql binding but it's not on hackage
05:17:49 <Jomyoot> is hsql good performance?
05:18:04 <dcoutts_> no idea
05:18:29 <dcoutts_> I just make sure it builds for Gentoo, I don't actually use it :-)
05:18:46 * dcoutts_ doesn't use any db libs
05:20:02 <Jomyoot> i don't know how to read .ebuild file
05:20:06 <Jomyoot> i can guess
05:20:16 <Jomyoot> i just do whatever "echo" does?
05:20:27 <Jomyoot> all changes are in .cabal?
05:25:11 <Jomyoot> Module
05:25:11 <Jomyoot>     `Distribution.Simple.Utils'
05:25:11 <Jomyoot>     does not export
05:25:12 <Jomyoot>     `rawSystemVerbose'
05:25:19 <Jomyoot> I got the above errors
05:30:26 <Jomyoot> darn none is here
05:35:28 <doserj> well, the error suggests that you don't have the right Cabal version installed.
05:36:41 <Jomyoot> I never installed Cabal. I only installed GHC
05:36:47 <Jomyoot> Do I need to install Cabal seperately?
05:36:58 <doserj> ghc-pkg list will show you the installed packages
05:38:06 <resiak> so I've been fixing up HFuse to build with recent GHCs and libfuses, and will be doing some more fixing and finishing in the near future.  as far as I can tell, there's no HFuse mailing list; where should I send my patches?  haskell-cafe?
05:39:05 <resiak> or, I suppose, I could mail galois
05:39:47 <Jomyoot> I have Cabal-1.2.3.0 installed
05:39:49 <Jomyoot> yes
05:40:00 <Jomyoot> But hsql is outdated
05:44:11 <hpaste>  mmorrow pasted "visualize fold{r,l}" at http://hpaste.org/4853
05:48:48 <Jomyoot> can someone help me with hsql on ghc 6.8?
05:52:12 <dcoutts_> Jomyoot: did you try the patches I suggested earlier?
05:53:19 <Taejo> @oeis 1 2 4 6 12 12 24
05:53:20 <lambdabot> Smallest number with at least n factors.
05:53:20 <lambdabot> [1,2,4,6,12,12,24,24,36,48,60,60,120,120,120,120,180,180,240,240,360,360,360,...
05:54:27 <oerjan> @oeis 1 2 1 2 3 4
05:54:27 <lambdabot> Highest minimal Hamming distance of any Type 4^Z self-dual code of length n o...
05:54:27 <lambdabot> [1,1,1,2,1,2,3,4,1,2,2,2,2,3,3,4,4,4,3,4,5,6,7,8]
05:54:55 <sieni> that's a nice feature
05:56:01 <Jomyoot> dcoutts_: the one for HSQL worked but for mysql, i don't know how to read ebild format
05:56:22 <Jomyoot> the one for HSQL worrked because i just modified 2 lines, but for mysql is more involving
05:56:31 <ricky_clarkson> @oeis 9 1 1
05:56:32 <lambdabot> Pascal's triangle read by rows: C(n,k) = binomial(n,k) = n!/(k!*(n-k)!), 0<=k...
05:56:32 <lambdabot> [1,1,1,1,2,1,1,3,3,1,1,4,6,4,1,1,5,10,10,5,1,1,6,15,20,15,6,1,1,7,21,35,35,21...
05:56:32 <dcoutts_> Jomyoot: it's a bash script, I'll point out the useful bits
05:57:12 <oerjan> that one was a bit fishy
05:57:15 <dcoutts_> Jomyoot: you're on linux right?
05:57:22 <Jomyoot> on Mac OS X
05:57:29 <Jomyoot> Linux enough for u?
05:57:34 <dcoutts_> Jomyoot: ok, so first we add build-depends: old-time
05:57:41 <Jomyoot> ok. done
05:57:51 <Jomyoot> we speaking of the mysql one right?
05:57:55 <dcoutts_> yep
05:58:04 <dcoutts_> Jomyoot: then we need to *replace* the complex custom Setup.hs with the default one
05:58:46 <dcoutts_> which is just echo 'import Distribution.Simple; main = defaultMain' > Setup.hs
05:58:49 <Jomyoot> how?
05:58:55 <dcoutts_> (or > Setup.lhs)
05:59:15 <dcoutts_> whichever one is there already (.hs or .lhs)
05:59:20 <Jomyoot> ok
05:59:39 <Jomyoot> in the ebuild there are other stuff though. like extra-libraries ld-options
05:59:45 <dcoutts_> Jomyoot: now we need to add some stuff back into the .cabal file since we're not using the custom Setup.hs
05:59:49 <dcoutts_> right
06:00:02 <dcoutts_> so delete the cc-options: line in the .cabal file
06:00:48 <dcoutts_> Jomyoot: the following three lines in the .ebuild add more lines to the end of the .cabal file
06:01:31 <dcoutts_> Jomyoot: you may need to customise the ld-options: line to point to where the mysqlclient library is installed on your machine, the line in the ebuild is for linux systems
06:01:44 <Jomyoot> ok
06:02:31 <Jomyoot> Setup.lhs line 2: unlit: No definitions in file (perhaps you forgot the '>'s?)
06:02:32 <Jomyoot> phase `Literate pre-processor' failed (exitcode = 1)
06:02:40 <Jomyoot> my setup just has this line import Distribution.Simple; main = defaultMain
06:02:44 <Jomyoot> is that correct?
06:03:01 <cpoucet> with a > in front?
06:04:32 <Jomyoot> with no >
06:05:33 <doserj> well, either put a "> " in front of each line, or rename the file to "Setup.hs"
06:06:41 <kib> Hi, I'm coming from Python's world and what I've seen in Haskell seems really good. Can someone point me good ressources (books, articles) to read about Haskell ? Thanks a lot.
06:07:24 <oerjan> @where yaht
06:07:24 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
06:07:35 <oerjan> @where wikibook
06:07:36 <lambdabot> http://en.wikibooks.org/wiki/Haskell
06:07:55 <oerjan> @wiki
06:07:56 <lambdabot> http://www.haskell.org/haskellwiki/
06:08:40 <oerjan> hope that's a start :)
06:10:21 <dcoutts_> Jomyoot: got the Setup.hs working?
06:10:50 <kib> ok, thanks I'll try to take a look. Any 'trap' I must be aware of before starting (knowing that I come from OO programming)?
06:11:09 <Jomyoot> getting there
06:11:12 <oerjan> just forget everything you have learned ;)
06:11:13 <Botje> haskell doesn't have the concept of objects
06:11:22 <Jomyoot> is this something i will be facing with many libs that haven't updated to 6.8?
06:11:29 <Botje> since objects involve mutable state, and mutable stuff in haskell is not necesary ;)
06:11:43 <dcoutts_> Jomyoot: most have been updated, hsql seems to be unmantained
06:12:31 <Jomyoot> i am surrprise i would expect database to be quite in demand
06:13:37 <dcoutts_> Jomyoot: if you didn't need MySQL I'd recommend HDBC instead
06:13:45 <Jomyoot> i need mysql
06:13:56 <kib> it isn't easy to forget what we've learned for several years, but the fact that there's no object will certainly help me to do so :)
06:15:54 <loupgaroublond> Jomyoot: there's also HAppS, which is as much a DB as it is an application server
06:16:25 <Jomyoot> i am reaing the haskell School Of Expression
06:16:28 <Jomyoot> that book is mind blowing
06:16:36 <oerjan> @where soe
06:16:36 <lambdabot> http://haskell.org/soe/
06:17:45 <Jomyoot> you guys think that's a good book? is there another mind blowing book to read?
06:18:05 <loupgaroublond> SICP? although that's not haskell
06:18:20 <ricky_clarkson> (+1 sicp)
06:19:03 <Botje> ITYM (1+ sicp)
06:19:13 <Botje> Jomyoot: I learned it all from YAHT
06:19:19 <Jomyoot> YAHT ?
06:19:20 <dcoutts_> Jomyoot: for an intro book "Programming in Haskell" is great
06:19:22 <loupgaroublond> although there's something to be said for reading less mind blowing books and writing more code :)
06:19:43 <Jomyoot> i need stuff to expand my mind
06:20:00 <qeb`away> SICP is awesome for that
06:20:15 <qeb`away> then there's TAOCP if you really want heavy stuff
06:20:45 <ricky_clarkson> Jomyoot: Give away your television.
06:21:32 <Botje> in all fairness: TAOCP is only interesting for the exercises
06:21:54 <Botje> at least the few volumes i've flicked through
06:23:08 <qeb`away> that said if you work yourself through the exercises you'll "expand your mind" I think
06:25:28 <kib> Sorry, but what's SICP ?
06:25:45 <kaol> @go SICP
06:25:46 <lambdabot> http://mitpress.mit.edu/sicp/
06:25:46 <lambdabot> Title: Welcome to the SICP Web Site
06:27:32 <kib> but it seems to be a Scheme course, doesn't it ?
06:28:28 <kaol> more like a programming course using Scheme
06:28:48 <kaol> it's usable even if you don't happen to use Scheme
06:29:09 <kaol> well, some understanding of it required, of course
06:29:16 <qeb`away> many of the exercises are well suited to haskell as well
06:29:28 <qeb`away> but some of the later ones, involving state and assignment aren't ideal
06:30:08 <kib> so it can help in Haskell learning in some way, that's it ?
06:30:32 <qeb`away> it could I guess, but it's more about learning programming in general
06:30:36 <loupgaroublond> if you really want to have some fun, follow the scheme interpreter in 48 hours exercises, and then use your interpreter to run the exercises in SICP :P
06:30:43 <qeb`away> it teaches some fundamentel concepts very well
06:31:17 <ricky_clarkson> I recommend SICP, and lots of people recommend TAPL for the types stuff.
06:31:42 <ricky_clarkson> ..YAHT and bits of random papers such as The Awkward Squad can do the rest.
06:32:15 * osfameron gots stuck near the beginning of the scheme in 48 hours exercises
06:32:44 <Jomyoot> is Scheme from MIT?
06:32:50 <qeb`away> sort of
06:33:03 <ricky_clarkson> SICP certainly is.
06:33:16 <Jomyoot> Well Scheme doesn't have pattern matching
06:33:21 <Jomyoot> which is the cool thing about Haskell?
06:33:33 <kuribas> scheme does have pattern matching.
06:33:36 <kib> Scheme in 48 hours : you build a lexer and parser or just a finite state machine (with some stack) ?
06:33:36 <qeb`away> it's not "the" cool thing about haskell imo
06:33:41 <ricky_clarkson> Jomyoot: There are lots of cool things about Haskell.
06:34:00 <ricky_clarkson> @faq can Haskell do things that are not covered in SICP?
06:34:04 <lambdabot> The answer is: Yes! Haskell can do that.
06:34:53 <loupgaroublond> kib, you use parsec, which is a convenient parser writing library
06:35:43 <kib> There's already a parser lib inside Haskell ? Nice...
06:36:12 <kib> I've heard it does not support Unicode, is that true ?
06:36:38 <loupgaroublond> @faq Can haskell handle any text encoding with ease?
06:36:39 <lambdabot> The answer is: Yes! Haskell can do that.
06:38:01 <allbery_b> the standard I/O routines don't do Unicode; if you use a UTF8 library to convert for I/O, Haskell will handle Unicode codepoints fine
06:38:09 <qeb`away> @faq Do haskellers like pizza?
06:38:10 <lambdabot> The answer is: Yes! Haskell can do that.
06:38:18 <allbery_b> (there's at east one UTF8 lib on hackage.haskell.org)
06:38:19 <qeb`away> hmm...
06:38:23 <qeb`away> Haskell can eat pizza?
06:38:33 * qeb`away decides to be more protective of his pizza
06:38:51 <kib> that's not what I've read in a recent article about it...but I'm sure it can make good pizzas
06:39:05 <qeb`away> if it can _make_ pizzas it has to be awesome
06:39:07 <cpoucet> kib: sure, if you don't mind lazy consumption
06:39:13 <oerjan> kib: the basic Char type is unicode
06:39:14 <qeb`away> but I'm not to keen on it eating them for me
06:39:33 <kib> ok, good point.
06:39:55 <Toxaris> nice to know: eatPizza . makePizza fuses to id with -O2
06:40:01 <oerjan> > maxBound :: Char
06:40:03 <lambdabot>  '\1114111'
06:40:10 <Toxaris> not intermediate food produced at all!
06:52:10 <Jomyoot> can I get ghci to use mysqlclient.a instead of mysqlclient.dylib?
07:04:31 <RayNbow> random question... does anyone recommend this book? http://mitpress.mit.edu/images/products/books/0262162091-f30.jpg :p
07:04:55 <dmhouse> Yeah, I've got it, it's excellent.
07:05:34 <ricky_clarkson> Many people do.
07:07:28 <RayNbow> I've only read a few pages of it once, which I used as a reference for some short paper I had to write
07:07:34 <RayNbow> but I never had the chance to read it all :p
07:09:48 <byorgey> RayNbow: I'm reading it right now, it's great =)
07:13:12 <EvilTerran> got it here, half-way through reading it
07:13:14 <EvilTerran> very useful
07:15:52 <RayNbow> ok, thx all... added to the shopping cart :p
07:21:06 <alexj> is it intended for unlines to append a \n at the end?
07:22:09 <Botje> > unlines ["foo","bar","baz"]
07:22:11 <lambdabot>  "foo\nbar\nbaz\n"
07:22:21 <Botje> makes sense
07:22:46 <alexj> > lines "foo\nbar"
07:22:47 <lambdabot>  ["foo","bar"]
07:22:58 <alexj> I would expect them to invert.
07:23:12 <Botje> > unlines . lines $ "foo\nbar"
07:23:12 <lambdabot>  "foo\nbar\n"
07:23:19 <Botje> > unlines . lines $ "foo\nbar\n"
07:23:19 <lambdabot>  "foo\nbar\n"
07:23:27 <sjanssen> > lines "foo\nbar\n" -- they do invert
07:23:28 <lambdabot>  ["foo","bar"]
07:23:40 <Saizan> lines is not injective so it can't have an inverse anyway
07:23:49 <alexj> ok.
07:31:03 <cpoucet> @src lines
07:31:03 <lambdabot> Source not found. You type like i drive.
07:31:22 <cpoucet> I think that it's a bad idea to filter those things out, if you want only non-empty lines, add a filter
07:31:33 <cpoucet> but you can't recreate that information
07:34:51 <alexj> @seen lemmih
07:34:51 <lambdabot> lemmih is in #haskell. I last heard lemmih speak 2h 43m 13s ago.
08:05:26 <hpaste>  b42 pasted "(no title)" at http://hpaste.org/4854
08:13:13 <dons> ?users
08:13:14 <lambdabot> Maximum users seen in #haskell: 439, currently: 403 (91.8%), active: 5 (1.2%)
08:13:47 <shag> doing  echo "Directory.getCurrentDirectory >>= putStr.init.tail.show " | ghc --interactive -ignore-dot-ghci -v0 >>| foo  gives very strange results, when viewing foo with less, there seems a unicode character to be appended to the path: ESC[?1034h
08:14:08 <shag> any idea where this char slips in?
08:15:53 <doserj> works fine for me
08:17:52 <shag> when i just execute that in the shell, it seems fine here, too. like the shell is eating that character ... i only see it when redirecting into a file
08:18:25 <shag> very strange ...
08:18:37 <sjanssen> shag: why init.tail.show?
08:18:48 <sjanssen> getCurrentDirectory returns a String
08:19:12 <shag> hu? it returns FilePath imho
08:19:21 <matthew-_> type FilePath = String
08:19:21 <byorgey> right, and FilePath = String =)
08:20:00 <shag> that line is just copied from the hs-plugins configure script, which (obviously) doesn't work for me. ...
08:20:22 <byorgey> hm, I don't see the strange character... odd
08:20:52 <shag> but even when i change it to >>= putStr i still get that strange character
08:21:15 <shag> inside ghci, it seems to be fine, too
08:25:07 <matthew-_> ok, I need zipWith2M
08:25:25 <byorgey> @type zipWithM
08:25:27 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
08:25:49 <matthew-_> err, 3, not 2 !
08:25:51 <matthew-_> @type sequence . zipWith3
08:25:52 <lambdabot>     Couldn't match expected type `[m a]'
08:25:53 <lambdabot>            against inferred type `[a1] -> [b] -> [c] -> [d]'
08:25:53 <lambdabot>     In the second argument of `(.)', namely `zipWith3'
08:26:32 <byorgey> @type ((sequence .) .) . zipWith3
08:26:33 <lambdabot>     Couldn't match expected type `[m a]'
08:26:34 <lambdabot>            against inferred type `[c] -> [d]'
08:26:34 <lambdabot>     In the second argument of `(.)', namely `zipWith3'
08:26:35 <matthew-_> @type z f as bs cs = sequence (zipWith3 f as bs cs)
08:26:36 <lambdabot> parse error on input `='
08:26:45 <byorgey> @type (((sequence .) .) .) . zipWith3
08:26:45 <matthew-_> @type let z f as bs cs = sequence (zipWith3 f as bs cs) in z
08:26:46 <lambdabot> forall (m :: * -> *) a a1 b c. (Monad m) => (a1 -> b -> c -> m a) -> [a1] -> [b] -> [c] -> m [a]
08:26:46 <lambdabot> forall a b c (m :: * -> *) a1. (Monad m) => (a -> b -> c -> m a1) -> [a] -> [b] -> [c] -> m [a1]
08:26:53 <matthew-_> lol
08:27:10 <byorgey> hehe, I'd use your version =)
08:27:27 <matthew-_> well I cheated and just @src zipWithM'd anyway...
08:27:53 <byorgey> @src zipWithM
08:27:53 <lambdabot> zipWithM f xs ys = sequence (zipWith f xs ys)
08:28:01 <byorgey> ah, indeed =)
08:44:42 <_andre> hello
08:44:55 <_andre> is there any way to make a regex match a \NULL character?
08:45:50 <CosmicRay> _andre: I'd bet not because the underlying C library may not be able to handle that
08:46:00 <CosmicRay> but then if there is a pure-haskell regex implementation... maybe so.
08:46:45 <osfameron> I'm sure pcre can handle null bytes
08:46:54 <osfameron> [\000] or something ?
08:47:40 <_andre> yeah, "\000"
08:48:00 <_andre> subRegex "." "\NULL" "_" does nothing
08:48:07 <dons> pcre can handle null, yes. and strings should happily match them
08:48:11 <_andre> err, (mkRegex ".")
08:50:52 <CosmicRay> but is pcre in use here?
08:50:58 <CosmicRay> ghc 6.6.x at least didn't use it, right?
08:51:27 <_andre> i'm trying this in 6.8.2, with Text.Regex
08:53:40 <quicksilver> _andre: "\NULL" is not haskell syntax, precisely
08:53:51 <quicksilver> > map ord "\NULL"
08:53:52 <Jomyoot> Loading package hsql-mysql-1.7 ... can't load .so/.DLL for: mysqlclient (dlopen(libmysqlclient.dylib, 10): image not found)
08:53:53 <lambdabot>  [0,76]
08:54:03 <Jomyoot> How do I know where it's looking for libmysqlclient.dylib?
08:54:19 <quicksilver> _andre: "\NULL" is [chr 0, chr 76], I.e. [chr 0,'L']
08:54:36 <quicksilver> _andre: all the special escape chars are 3-letter escapes I think
08:55:05 <_andre> woops, sorry it's actually "\NUL"
08:55:15 <_andre> that's what i got in ghci when i type "\000"
08:55:26 <puusorsa> no ghc for winCE?
08:55:40 * puusorsa <- sad panda
08:55:52 <quicksilver> _andre: that's better :)
08:57:20 <quicksilver> still, I agree that "." doesn't match "\NUL" with the standard Text.Regex
08:57:31 <quicksilver> presumably because it's using the C lib behind-the-scenes.
08:57:38 <quicksilver> Should work with PCRE or TDFA I would thinkg
08:58:32 <quicksilver> Also, "a$" matches "a\NULL" which proves it, IMO
08:58:38 <qeb`away> any string that has \NUL in it should confuse a C program O.o
09:00:57 <_andre> isn't libpcre written in C? :)
09:01:03 <puusorsa> and now that i'm whining, why no crosscompiling with ghc?
09:01:12 <quicksilver> puusorsa: because you haven't written it yet.
09:01:19 <quicksilver> puusorsa: we look forward to your patch!
09:01:31 <puusorsa> thanks
09:04:27 <puusorsa> i wouldn't know where to start ("of course by darcs get the-ghc-sources, stupid!").
09:06:17 <Jomyoot> is dlopen() part of haskell? or the OS?
09:06:35 <allbery_b> OS
09:08:07 <Jomyoot> how do I find out where dlopen() search for the lib?
09:08:33 <dons> in the unix package
09:09:22 <_andre> hmm the regex-base package that comes with ghc-extralibs is version 0.72 and regex-pcre wants >=0.93 :\
09:09:38 <dons> _andre: there's new regex libs released today, perhaps try those?
09:09:43 <dons> hackage.haskell.org
09:11:06 <quicksilver> puusorsa: I don't really know the serious answer, beyond 'it's fiddly to do and no one has needed it enough'
09:11:18 <quicksilver> puusorsa: it would obviously be nice to have, but presumably isn't important enough to enough people..
09:11:43 <_andre> dons: is it ok to install a new regex-base over the old one or should i uninstall it first?
09:12:22 <dons> its ok to upgrade
09:12:25 <puusorsa> quicksilver, thanks.
09:16:17 <_andre> Text/Regex/Base/RegexLike.hs:209:0: Illegal instance declaration for `Extract String' :(
09:17:02 <dons> hmm. you built the new regex-base-0.93 ?
09:17:47 <_andre> this is in regex-base-0.93
09:17:57 <_andre> when i run "runghc Setup.hs build"
09:18:27 <dons> sigh. better use regex-base-0.72.0.1 , regex-compat-0.71 and regex-posix-0.72.0.2
09:18:29 <Jomyoot> my HSQL Mysql is calling dlopen(libmysqlclient.dylib, 10) instead of using the full path
09:18:32 <dons> (they're known to work with 6.8)
09:18:33 <Jomyoot> is that correct?
09:18:52 <dons> _andre: and its worth a bug report to Chris, since presumably this are supposed to work with new ghc
09:19:02 <dons> too many extensions used in the regex libs needlessly
09:19:28 <sjanssen> the regex- libraries are in a weird state
09:19:37 <_andre> i'll send him an email then
09:19:55 <sjanssen> some versions were totally broken the last time I tried
09:20:00 <dons> thanks _andre. we should have another few regex lib options soon
09:20:08 <dons> the current one isn't satisfactory, imo.
09:20:13 <sjanssen> dons: why?
09:20:32 <dons> i've written pcre-light, an h98+ffi binding to pcre, with no extensions :)
09:20:39 <dons> almost done.
09:20:56 <dons> basically to avoid the constant breakage and confusing overloading of regex-*
09:21:25 <sjanssen> the breakage could be fixed with a more active maintainer, I think
09:21:40 <sjanssen> (or someone who would at least make sure their tarballs build)
09:21:54 <dons> the interface is too complex anyway, imo. not even close to h98
09:22:21 <resiak> hrm.  this haskell-mode stuff for vim runs ghc directly as the compiler; does anyone know the appropriate vim command fu to make it use `runhaskell Setup.lhs build`?
09:22:47 <Botje> :se makeprg=runhaskell\ Setup.lhs\ build
09:22:55 <resiak> will that still parse GHC's errors?
09:23:01 <Botje> no idea
09:23:12 <Botje> it should, if you configure the error regexp correctly
09:23:21 <resiak> let's find out!
09:25:29 <_andre> is there anything in the stdlib for reading simple key:value configuration files? i saw ConfigFile on hackage but if i didn't need external libs it'd be better
09:26:16 <dylan> hrm, is there a haskell library for SOAP?
09:26:29 <Botje> _andre: you could use break or span for that
09:26:36 <gio123> does somebody knows some translater to convert prolog code to haskell?
09:27:12 <quicksilver> dons: there is a h98 interface to regex, you know?
09:27:18 <quicksilver> the typeclass magic is totally optional
09:27:50 <puusorsa> gio123, some biological converter device running on caffeine should do it
09:28:11 <dons> quicksilver: hmm? when the build fails because of broken type class magic, i'd say its not optional :)
09:28:23 <gio123> <puusorsa>  are u jocking?
09:28:41 <Botje> gio123: haskell and prolog are entirely different beasts ..
09:28:51 <gio123> sure
09:28:55 <quicksilver> dons: well it's might not be set up as option in the build scripts, which I know nothing about
09:29:03 <quicksilver> dons: but it's optional at the module level, as I understand it
09:29:14 <quicksilver> the typeclass magic is all in some modules which are optional
09:29:16 <gio123> but maybe somebody wrote already convertor?
09:29:32 <quicksilver> _andre: map (break (==':')) . lines
09:29:38 <quicksilver> _andre: is very nearly what you want :)
09:29:44 <puusorsa> gio123, kinda. hahaha, just serious.
09:29:48 <quicksilver> _andre: you'll want to strip away the colons, too
09:30:13 <gio123> puusorsa: is it hard to implement such translator?
09:30:23 <puusorsa> biological converter device running on caffeine = average programmer
09:30:36 <quicksilver> > map ((\(a,':':b) -> (a,b)) . break (==':')) . lines $ "foo:bar\nbaz:bam"
09:30:38 <lambdabot>  [("foo","bar"),("baz","bam")]
09:30:45 <quicksilver> _andre: like that, perhaps :)
09:30:53 <Saizan> what's faster (`L.append` (L.pack x)) . L.concat, or L.concat . (++ [L.pack x])? where L = Data.ByteString.Lazy
09:31:20 <_andre> quicksilver: thanks :D
09:31:25 <gio123> puusorsa: so, I need it! somebody can advice me where can i found?
09:31:28 <quicksilver> Saizan: they do different things
09:31:34 <Botje> @pl \(a,':':b) -> (a,b)
09:31:35 <lambdabot> (line 1, column 5):
09:31:35 <lambdabot> unexpected "'"
09:31:35 <lambdabot> expecting natural, identifier, "_" or "("
09:31:46 <Botje> mm?
09:31:54 <Botje> pl has a broken parser?
09:31:59 <Saizan> yes
09:32:05 <Botje> boo :)
09:32:07 <byorgey> Botje: that would be... an understatement =)
09:32:15 <quicksilver> Saizan: one puts x into a new chunk, the other erm
09:32:27 <quicksilver> Saizan: actually maybe not that differnet :)
09:32:37 <gio123> puusorsa: so, I need it! somebody can advice me where can i found?
09:32:44 <Saizan> quicksilver: heh :)
09:32:52 <Botje> gio123: it can't be done automatically, so stop asking .
09:33:05 <quicksilver> Saizan: I would be surprised if there was a measurable difference, on refelction
09:33:10 <gio123> Botje: are u sure?
09:33:15 <Botje> very sure.
09:33:37 <gio123> Botje: haskell to common lisp
09:33:41 <gio123> is possible?
09:34:07 <Botje> probably, if you can convert GHC Core to CL
09:34:23 <gio123> CL?
09:34:24 <quicksilver> far from trivial
09:34:31 <gio123> what is that?
09:34:36 <Botje> common lisp
09:34:37 <quicksilver> compiling lazy languages to strict ones is hard
09:34:38 <gio123> GHC?
09:34:44 <Botje> the haskell compiler ..
09:34:48 <gio123> ok
09:34:53 <Botje> gio123: I suggest you start learning haskell.
09:35:00 <Botje> no way around it.
09:35:04 <gio123> I use prolog
09:35:16 <mrd> quicksilver: really? just wrap lambda around everything =)
09:35:16 <Botje> we know
09:35:21 <quicksilver> to compile a lazy language to a strict one you need to implement thunks or some similar mechanism
09:35:38 <quicksilver> mrd: I don't think taht correctly implements sharing, though
09:35:47 <mrd> quicksilver: yea yea, with a mutable ref oO
09:35:53 <Philippa> yeah, but in that sense Haskell isn't a lazy language - it's a non-strict one
09:36:20 <Philippa> you can have a perfectly valid H98 implementation with call-by-name semantics
09:36:26 <puusorsa> and not strictly lazy?
09:36:50 <quicksilver> Philippa: taht's true. But real programs often assume some kind of sharing discipline.
09:37:06 <quicksilver> Philippa: which becomes important to them having sane space usage.
09:37:07 <gio123> Botje: to read functional stile programs is hard i dont like "(" ")"
09:37:23 <Botje> gio123: good news! the $ combinator eliminates the need for most ().
09:37:43 <Botje> gio123: and i'm guessing you have to make a program in haskell for school, there's no way around it, so start learning :)
09:38:29 <mrd> @seen ndm
09:38:29 <lambdabot> I saw ndm leaving #haskell 21h 1m 32s ago, and .
09:38:30 <gio123> Botje: noo, I implemented something in prolog and now i would like how effecient it can be done in haskell
09:38:52 <Botje> gio123: if it's sufficiently small, maybe you can get people here to convert it for you
09:38:55 <gio123> @seen Cale
09:38:55 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 7h 45m 51s ago.
09:39:01 <Botje> but i'm afraid you'll have to write it yourself.
09:39:37 <gio123> Botje: if there is no convetor i will gave up ;)
09:39:56 <Botje> gio123: sorry to hear that. you're missing out though :)
09:40:56 <gio123> Botje: I would like to learn, but I think it will take 4 month hard work to learn language
09:40:57 <gio123> :)
09:41:16 <quicksilver> It should take an afternoon to get familiar with it
09:41:22 <quicksilver> of course, it takes a lifetime to master
09:41:27 <quicksilver> like any other interesting skill
09:41:31 <byorgey> gio123: even if there was such a converter, I highly doubt running a prolog program through it would yield a haskell program whose efficiency you could usefully compare.
09:41:59 <Botje> gio123: nah, haskell can be learned in two weeks. at least enough to write something comparable to your prolog program
09:42:40 <gio123> Botje: I wrote language for rule based programing, it took 8 month in prolog
09:42:57 <Botje> gio123: it might take less in haskell. try it :)
09:43:23 <gio123> Botje: heh, i will try, let see
09:43:30 <Botje> a good start would be YAHT
09:43:32 <Botje> @go YAHT
09:43:33 <lambdabot> http://en.wikibooks.org/wiki/Haskell/YAHT
09:43:39 <gio123> Botje: what is good interpreter for haskell?
09:43:43 <quicksilver> ghci
09:43:59 <gio123> can u give me a link
09:44:02 <quicksilver> of course, if your rule based programming works "natively" on the level of prolog terms and stuff
09:44:12 <quicksilver> @go glasgow haskell compiler
09:44:13 <lambdabot> http://www.haskell.org/ghc/
09:44:13 <lambdabot> Title: The Glasgow Haskell Compiler
09:44:22 <quicksilver> then it may be harder in haskell. perhaps.
09:44:30 <quicksilver> it may even amount to writing a prolog compiler :)
09:44:36 <quicksilver> interpreter, I mean.
09:44:54 <quicksilver> depends what tecniques you used in prolog
09:45:01 <gio123> quicksilver: to be honest i used prolog computation engine
09:45:04 <byorgey> gio123: ghc can probably be installed through your platform's package management system.
09:45:34 <gio123> quicksilver: but in prolog we have only 1 kind of variables
09:45:50 <gio123> quicksilver: in the language I implemented we have various kind of variables
09:46:14 <gio123> quicksilver: seq variable/ funct variable/contex variable etc
09:46:42 <gio123> quicksilver: so in haskell i will have also to implement sldnf resolution inference
09:47:18 <gio123> in prolog i used its owner engine, which makes system somehow not effcient
09:49:06 <BMeph> ?users
09:49:06 <lambdabot> Maximum users seen in #haskell: 439, currently: 411 (93.6%), active: 20 (4.9%)
09:54:09 <bos> @seen chillix
09:54:09 <lambdabot> Last time I saw chillix was when I left #darcs, #ghc and #haskell 21d 12h 7m 47s ago, and .
09:54:42 <bos> i wonder if any #haskell regulars are in san francisco for popl this week
10:08:51 <Botje> eep. pugs doesn't build on ghc 6.8 :/
10:09:11 <dons> bos: Chilli should be, i think swiert is. John Launchbury'll be there
10:09:58 <dons> bos, and lennart too, afaik
10:11:10 <radetsky> bos: afayk, is it worth it for people with relatively little experience w/haskell? I live in SF, so it's relatively trivial for me
10:11:49 <radetsky> too much "relatively"
10:12:19 <bos> dons: yeah, augustss already told me he's around.
10:12:42 <bos> radetsky: no, don't go to the actual conference if you're not a researcher. you'll get bored to tears.
10:12:53 <bos> radetsky: go to wadler's public talk on wednesday night, though.
10:12:54 <cpoucet> not to mention really expensive
10:13:58 <mrd> thurs night i'll fly over SF and wave
10:13:59 <bos> cpoucet: if you can afford to live in san francisco, the conference isn't very expensive :-p
10:15:07 <cpoucet> bos: :D
10:15:11 <wolverian> Botje, come complain on #perl6, though no-one is really maintaining it at the moment
10:15:14 * cpoucet lives in Eu unfortunately
10:15:31 <mrd> ndm: ah good timing
10:15:54 <mrd> i was about to leave.  i found that report tucked away in the library
10:15:57 <pejo> bos, a fair amount of the talks are quite understandable though. But sure, it requires some geekyness to find it interesting.
10:16:18 <bos> pejo: i speak as the sort of person who likes that kind of stuff.
10:16:19 <Saizan> ?index Int64
10:16:19 <lambdabot> Data.Int, Foreign
10:18:46 <radetsky> bos: thx
10:20:33 <ndm> @karma+ mrd
10:20:33 <lambdabot> mrd's karma raised to 5.
10:20:35 <ndm> @karma+ mrd
10:20:35 <lambdabot> mrd's karma raised to 6.
10:20:43 <ndm> mrd: very much appreciated!
10:20:44 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
10:20:59 <ndm> mrd: can i use your name to credit you on the blog post?
10:21:30 <mrd> ok
10:21:32 <ehird> useless quiz: along with the lambda, what other greek letters are associated with haskell? :-)
10:22:20 <resiak> Î±, Î², and Î·, for starters
10:22:21 <byorgey> ehird: well, there's alpha conversion, beta reduction, and eta expansion, which are associated with the lambda calculus in general
10:22:37 * mrd hopes he doesn't run afoul of any copyright woes ;)
10:22:44 <pejo> ehird, and a bunch of greek letters appear in the type theory papers.
10:22:56 <pejo> @karma+ mrd
10:22:56 <lambdabot> mrd's karma raised to 7.
10:23:09 <ehird> byorgey: true, but when i see a lambda i think 'haskell' (and 'lisp' too, simultaneously, but hey) -- when i see those, i think 'lambda calculus'
10:23:18 <bos> and of course, all of those greeks were very much into bottom, back in the day.
10:23:21 <pejo> mrd, but atleast you got some karma for the felony!
10:24:00 <ndm> i think the information in that paper will speed up Supero by an exponential factor
10:24:24 <mrd> i was worried the main result might disqualify the algorithm
10:24:31 <byorgey> ehird: so, you're asking what greek letters make *you* think of Haskell? I have no idea. =)
10:24:49 <radetsky> @karma+ radetsky
10:24:49 <lambdabot> You can't change your own karma, silly.
10:24:54 <radetsky> wtf?
10:24:59 <radetsky> I have a bug report
10:25:19 <sjanssen> it's not a bug :)
10:25:20 <ehird> byorgey: haha :-)
10:25:48 <byorgey> bos: hey now, this is a family-friendly channel ;)
10:26:36 <byorgey> ehird: phi makes me think of catamorphisms...
10:26:40 <bos> byorgey: i assure you my kids wouldn't know what i was talking about if i repeated that line in front of them :-)
10:26:50 <pjd> @vixen
10:26:50 <lambdabot> *giggles*
10:26:55 <ndm> mrd: the result that with associative and commutative you get NP? I don't need AC at all
10:27:03 <byorgey> bos: heh, I know =)
10:29:45 <mrd> anyway, i've been frustrated by the search for material like this before, so i know how you feel
10:31:04 <ndm> yeah, great algorithm, centre of a big pile of research, and I'm trasating a French thesis just to find the context it sits in - but all over now
10:31:13 <ndm> it looks an incredibly clear tech report
10:34:21 <ehird> module hierarchy question: where would i put an interpreter's modules (say the interpreter is FooBarizer and the language is FooBar)
10:35:47 <conal> ehird: what are your goals in choosing the hierarchical module names?
10:36:00 <ehird> conal: world peace?
10:36:24 <conal> ehird: Peace.World.FooBarizer
10:36:35 <ehird> conal: helpful, you are
10:36:39 <ptolomy> Am I correct in remembering that there is a slight performance bug in the 6.6 bytestrings that makes Data.Map with them a bit slow?
10:36:54 <conal> ehird: the answer depends on your goals
10:37:24 <ehird> conal: well, it's an interpreter.
10:37:25 <ehird> :p
10:37:31 <byorgey> ehird: do you want to use it just for yourself?  do you want to release it on hackage?  do you want support for it integrated in ghc?  etc.
10:37:49 <conal> ehird: are you aiming for non-collision or ontology or ...
10:38:28 <ehird> byorgey: it's mainly created for my own toying with, but i might release it on hackage if i feel like it sometime. it's just a regular interpreter for a language, so no ghc integration would make sense or be wanted :P
10:38:32 <waern> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haddock-2.0.0.0
10:38:33 <lambdabot> http://tinyurl.com/35p58l
10:38:44 <byorgey> ehird: heh, I was kidding about the ghc integration =)
10:38:46 <ndm> @seen LoganCapaldo
10:38:46 <lambdabot> LoganCapaldo is in #haskell-blah and #haskell. I last heard LoganCapaldo speak 13h 41m 33s ago.
10:39:15 <ehird> byorgey: i guessed as much :P
10:39:33 <ndm> @tell LoganCapaldo i did work on something slightly lint for haskell, but more suggestions for beginners - http://www-users.cs.york.ac.uk/~ndm/drhaskell/ - but its a bit dead at the moment
10:39:33 <lambdabot> Consider it noted.
10:40:03 <conal> waern: how are ghc libs for haddock 2 going?
10:40:14 <byorgey> ehird: honestly, I don't think it matters that much.  perhaps something like Language.FooBar.*, if you want it to fit in somehow with existing hierarchy, but you can probably name it whatever you'd like.
10:40:41 <ehird> byorgey: Peace.World.Unicorns.Pink.Fluffy.FooBarizer
10:40:54 <ehird> i think this adequately describes FooBarizer's awesomeness
10:41:24 <conal> ehird: if you're going simply for uniqueness, there are lots of choices.  if ontology, see http://www.shirky.com/writings/ontology_overrated.html
10:41:25 <lambdabot> Title: Shirky: Ontology is Overrated -- Categories, Links, and Tags
10:41:33 <waern> conal: it is possible process core+extra libs from the 6.8.2 release with haddock now
10:42:33 <waern> conal: so just download the source release, install it, then install haddock 2, then go to ghc-6.8.2-src/libraries and say "make doc"
10:43:00 <conal> waern: :)
10:43:25 <conal> waern: i guess there's still no general solution on the horizon for cross-lib doc linking.
10:44:13 <waern> conal: what's the problem?
10:44:55 <conal> waern: i think one can link from haddock to one other base location, e.g., ghc libs or hackage, but not more than one.
10:45:12 <hashendgame> @seen dons
10:45:12 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 35m 15s ago.
10:45:22 <waern> conal: ah, okay
10:45:39 <conal> waern: if everything were on hackage, it'd be okay.
10:45:44 <conal> but not everything is.
10:45:51 <waern> conal: right, and if hackage used haddock 2
10:46:18 <conal> waern: exactly.
10:46:36 <conal> waern: have you heard anything about hackage switching to haddock 2?
10:46:48 <waern> nope, sorry
10:47:35 <dons> hashendgame: ?
10:47:40 <conal> i wonder if web-based lib documentation is even important to hackage & cabal folks.
10:47:59 <dons> conal: it is!
10:48:17 <dons> for helping haskell adoption we need unified, centralised docs for the 3rd party libs
10:48:42 <conal> dons: centralized?
10:49:38 <dons> yeah. you should be able to browse all hackage docs by going to, say, hackage.haskell.org/docs or so
10:49:55 <conal> that'd be great.
10:50:26 <Botje> wolverian: re pugs: i'll try to see if i can at least get it to compile
10:50:26 <conal> is it important that the libs & docs themselves are on hackage?  i'm happy to put mine there, but i'm not sure everyone is.
10:50:34 <wolverian> Botje, patches welcome, of course
10:50:40 <dons> i think its crucial to have a single point for finding libs
10:50:41 <Botje> yes
10:50:48 <dons> i already find that if its not on hackage, i don't use it.
10:50:54 <Botje> I think it's just a matter of tweaking the cabal file
10:51:16 <dons> whereas if it is on hackage, the lib becomes an extension to the core lib set, since it can be installed reliably
10:51:46 <conal> dons: makes sense to me.
10:51:46 <dons> conal: i know there are a few still not putting there stuff on hackage (like the qtHaskell libs), and it worries me they'll languish in obscurity, since they're hard to find.
10:51:51 * ndm agrees strongly with dons
10:52:12 <conal> perhaps the benefits are not clearly understood
10:52:30 <dons> yes. perhaps it could be stated more clearly on hackage.haskell.org
10:52:51 <dons> in particular, tools for installing and distributing your lib just work (e.g. cabal-install), and new users will find your code
10:53:09 <ndm> the hackage webpage really needs a revamp though
10:53:12 <dons> haddock 2.0 out!
10:53:16 <ndm> at the moment it is a total mess
10:53:17 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haddock-2.0.0.0
10:53:19 <lambdabot> http://tinyurl.com/35p58l
10:53:25 * wolverian agrees with ndm
10:53:26 <conal> hurray for haddock 2.0 !!!
10:53:29 <waern> that's right :)
10:53:35 <waern> sorry for taking so long
10:53:56 <dons> :D
10:54:01 <dons> thanks waern
10:54:04 <wolverian> awesome :)
10:54:17 <toad3k> @hoogle decode
10:54:17 <lambdabot> Prelude.decodeFloat :: RealFloat a => a -> (Integer, Int)
10:54:30 <wolverian> now, re hackage: it doesn't show the Changes file
10:54:30 <conal> btw, is base on hackage?
10:54:35 <dons> :t Data.Binary.decode
10:54:38 <lambdabot> forall a. (Data.Binary.Binary a) => Data.ByteString.Lazy.ByteString -> a
10:54:39 <wolverian> that is really really annoying
10:54:43 <dons> wolverian: hmm?
10:54:46 <wolverian> (assuming the package has one)
10:55:11 <toad3k> I was messing with binary decode, but can anyone tell me how you catch an exception, as in it parses invalid data and the program exits?
10:55:14 <wolverian> dons, cpan lets me view the package's changes file conveniently on web, so I see what's new in a certain version.
10:55:41 <waern> http://code.haskell.org/haddock/CHANGES
10:55:45 <wolverian> thanks
10:56:01 <wolverian> http://www.haskell.org/haddock/ needs updating?
10:56:01 <lambdabot> Title: Haddock
10:56:14 <ndm> waern: does hoogle support work?
10:56:19 <waern> wolverian: yup, will be done tomorrrow
10:56:25 <waern> ndm: nope
10:57:03 <byorgey> ndm: mostly dead, or all dead? ;)
10:57:53 <ndm> byorgey: maybe an hours hacking away from being alive again, so not much at all
11:03:47 <hashendgame> dons: I've been trying to build your plugins package on ghc-6.8 and I've noticed that the trick you use to set TOP in configure.ac misbehaves. Mind if I PM?
11:05:19 <dons> hashendgame: are you using the repo from code.haskell.org ?
11:05:23 <ehird> is much haskell software licensed under the MIT license?
11:05:30 <dons> since that's been updated to 6.8
11:05:32 <hashendgame> dons: yes
11:05:52 <dons> i'm not able to do much maintainance of it, email would be better.
11:05:54 <byorgey> ehird: no, I think BSD3 is more common
11:06:03 <dons> ehird: very little. (none i can think of)
11:06:05 <ehird> oh well, stuff them. i like the MIT license. :-)
11:06:19 <ehird> not like it isn't 99% equiv. to bsd anyway
11:06:30 <ehird> (apart from: it has no 'no-endorsement' clause)
11:06:38 <dons> its BSD3 for maybe 80%, GPL for 15% and et al for the rest, approx
11:06:59 <ehird> (L)GPL :(
11:07:21 <hashendgame> dons: ok, I've worked out the problem I think. I'll send you a dpatch, but you might need to tweak it to make it fit nicely with your repo layout
11:07:47 <dons> it would be better if it required no tweaking.
11:07:53 <dons> i wonder why noone's reported an issue before?
11:09:46 <hashendgame> maybe it's something strange on my end. Basically the `echo "Directory.getCurrentDirectory >>= putStrLn.init.tail.show" | ghc --interactive ...` (configure.ac) seems to spit out extra invisible junk.
11:10:08 <hashendgame> and yet, if I stick that in a .hs, compile and run it with straight ghc, no problems
11:10:44 <ehird> wtf cabal doesn't recognize "License: MIT"
11:10:45 <ehird> :(
11:11:11 <dons> hehe BSD3 man!
11:11:33 <dons> hashendgame: oh hmm. perhaps just clean up any bogus stuff with sed?
11:12:12 <ehird> dons: YOU AND YOUR FASCIST LICENSES :( I LIKE PEOPLE USING MY NAME TO ADVERTISE SOFTWARE
11:12:57 <dons> hah
11:13:32 <BMeph> Someone else was reporting a similar "extra chars in the 'echo Dir... | ghc ...'" pipe. Maybe there's something wrong with ghc?
11:14:05 <ehird> plus it expects <organization>
11:14:16 <hashendgame> BMeph: have you got a bug ref I can look at?
11:14:24 <ehird> Neither the name of the The Great Mighty Approved Doubleplusgood Elliott Hird Organization nor the ...
11:15:24 <BMeph> hashendgame: 1) It wasn't me 2) It was reported in the channel earlier this morning, but I didn't get to record a name or check it out before my connection reset
11:15:47 <hashendgame> BMeph: :-(. Oh well.
11:15:48 <qebab> Doubleplusgood \o/
11:18:10 <bos> coolio, i just updated fedora rawhide to package haddock 2.0.0.0
11:19:16 <dons> bos, are we going to see xmonad in fedora soon? :)
11:19:26 <waern> bos: that's fast :)
11:19:38 <dons> packaging is important for haskell open source, since the toolchain issues make experimenting harder for outsiders
11:19:40 <bos> dons: that's a lot more work, unfortunately. we really need to write official packaging guidelines for that.
11:19:51 <dons> so even more important to get binary packages than for C programs
11:19:58 <bos> yeah, i know.
11:20:15 <hashendgame> dons: is there any reason not to replace this pwd trick with $ac_abs_srcdir or $ac_abs_builddir? or will that make trouble on cygwin again?
11:20:17 <bos> hi augustss, how goes the llvm hacking?
11:20:49 <bos> dons: someone new just started writing guidelines, but i haven't reviewed them yet
11:21:01 <augustss> bos: I'm trying to figure out how to trick the type check so I don't need so many instances :)
11:21:02 <dons> we see this with xmonad: it fixes lots of problems in the competition, but has an uphill battle for adoption due to people not wanting to get a haskell toolchain together
11:21:16 <bos> augustss: yeah, all the instances made me sad, too.
11:21:26 <augustss> bos: and I have many more than you
11:21:30 <bos> eek!
11:21:30 <dons> a C program with 70% of the stability and features is enough to be competitive against that , unfortunately
11:22:01 <bos> dons: maybe you should stop using arch linux and switch to a distro that has more users, where you can have more of an effect :-)
11:22:05 <kolmodin> @yarr!
11:22:05 <lambdabot> I'll crush ye barnacles!
11:22:14 <augustss> bos: but at least they are not going to change, unless the llvm gets new base types
11:22:20 <dons> bos, mm
11:22:25 <bos> augustss: right. that hasn't happened in a while.
11:22:39 <kosmikus> dons: oh, you're using arch linux these days?
11:22:43 <bos> the last new base types that got added were the funky floating point representations.
11:22:55 <kolmodin> .... gentoo haskel good haskell support...
11:23:01 <augustss> bos: yeah, and I've not even added instances for those
11:23:04 <kolmodin> +spelling
11:23:08 <dons> kosmikus: yeah. need a good kernel for multicore programming, and arch is the most openbsd like :)
11:23:11 <kosmikus> kolmodin: :)
11:23:23 <kosmikus> dons: why not bsd anymore?
11:23:32 <bos> augustss: i'm itching to see what you've been up to :)
11:23:47 <augustss> bos: also, there's a bunch of invariants that should be able to be checked by types, that I don't.  Like each basic block ending with a terminator
11:23:52 <dons> the openbsd scheduler doesn't seem up to the task of high perf smp programming -- it think its fairly untuned performance-wise
11:23:58 <bos> augustss: right.
11:24:07 <dons> while the linux kernel's had the tires kicked a little bit more thoroughly
11:24:32 <bos> augustss: in general, that stuff has so far been easy to add after the fact. at least in my bindings.
11:24:34 <augustss> bos: I'm conferencing now, but I'll have something this afternoon I think
11:24:38 <dons> so yeah, multicore hardware driving OS and language adoption :)
11:25:09 <dons> i've had people tell me they're buying dual core laptops to program in haskell, maybe we should get funding from the hardware vendors :)
11:25:24 <bos> it takes about a decade to tune an smp kernel. so openbsd might catch up by 2020, if theo doesn't drive everyone away by then.
11:25:52 <bos> dons: we need to send coffee money to JaffaCake, to work on the parallel GC!
11:26:01 <augustss> does openbsd have smp now?
11:26:18 <dons> augustss: yeah, for the last 2 years or so.
11:26:42 <hashendgame> dons: I've got something working with a heredoc (since the pipe method is apparently untrustworthy), do you want patches against configure as well as configure.ac in the dpatch?
11:26:43 <dons> but not reliable enough for my `par` fantasies
11:26:51 <dons> hashendgame: both would be good
11:26:59 <dons> (rerun autoreconf)
11:27:47 <bos> hi yminsky_
11:27:57 <int-e> hashendgame: as a workaround for those extra characters, try unsetting TERM
11:31:17 <hashendgame> int-e: bingo! now, is it worth saving/restoring TERM or just nuking it?
11:32:57 <int-e> hmm. depends on the context? in the build system it should be safe to nuke it.
11:33:04 <ehird> what's the simplest type for a mutable string?
11:33:07 <hashendgame> configure.ac, so I'll take that as a yes
11:33:18 <dons> ehird: mutable?
11:33:31 <dons> dare I ask why?
11:33:42 <ehird> dons: see above: interpreter
11:33:55 <ehird> obviously i'll have to use a monad of some sort
11:34:01 <dons> you could use the unsafe interface to ByteString
11:34:13 <dons> that's what I'd do
11:34:18 <ehird> hm, not quite 'mutable String' though :-)
11:34:23 <ehird> true i guess though.
11:34:38 <Saizan> well if your language has mutability i'd use IORefs
11:34:49 <hashendgame> dons: use the address given by the darcs repo?
11:34:49 <ehird> not my language
11:34:50 <ehird> :-)
11:34:57 <dons> hashendgame: dons <> galois.com
11:35:09 <ehird> I'll look into IORefs
11:35:19 <EvilTerran> ehird, also look at ST
11:35:44 <EvilTerran> which can be used as if it's pure
11:36:08 <ehird> this languge also happens to have imperative output, so perhaps IORefs would be better
11:36:19 <ehird> and make 'eval' etc be IO
11:36:29 <EvilTerran> how're you writing this language? an EDSL, or parsing up a string?
11:36:56 <ehird> EvilTerran: parsing a string
11:37:03 <ehird> it's Scheme, by the way ;)
11:37:14 <ehird> just writing a toy scheme interpreter to learn more about haskelle tc
11:37:25 <ehird> (i am going to support call/cc, though, which complicates things quite a bit...)
11:38:11 <Saizan> ?google implement scheme 48 hours
11:38:12 <lambdabot> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
11:38:12 <lambdabot> Title: Write Yourself a Scheme in 48 hours
11:38:24 <ehird> yeah, i know about writeyourselfascheme thanks
11:38:30 <ehird> it isn't scheme, anyway
11:38:34 <ehird> it's a language with a lot of parens
11:38:55 <Saizan> heh, just thought it could be relevant :)
11:39:01 <ehird> :)
11:39:17 <ehird> actually write yourself a scheme doesn't even parse full scheme iirc
11:39:29 <ehird> dunno if it even does basic things like character constants
11:39:53 <hashendgame> dons: sent. The configure patch is a separate record in the bundle, as I used a different autoconf version and it made a noisy patch.
11:39:59 <EvilTerran> well, that's fairly trivial to add, i imagine
11:40:10 <dons> ok, thanks hashendgame
11:40:14 <dons> got it.
11:40:18 <ehird> EvilTerran: sure, but what about lack of call/cc
11:40:27 <ehird> that's pretty damn fundamental :-)
11:40:36 <EvilTerran> well, yes. harder than char constants, anyway ;)
11:40:44 <ehird> more like total rewrite
11:40:57 <EvilTerran> are you converting the strings pretty directly into equivalent haskell, or into a parse tree, or pseudo-byte-code, or what?
11:41:07 <ehird> (i think there are three options: 1. convert program to CPS before evalutaion 2. keep a manual call stack 3. use haskell continuations, whatever they are)
11:41:17 <ehird> EvilTerran: interpreting them
11:41:20 <EvilTerran> in the first case, it wouldn't be too hard to switch from using IO to ContT IO
11:41:23 <ehird> EvilTerran: directly
11:41:40 <EvilTerran> so basically translating straight into haskell
11:41:43 <Saizan> (3 ~= 1)
11:41:54 <EvilTerran> (lambda (...) ...) becomes (\ ... -> ...), kinda thing
11:41:58 <ehird> no
11:42:11 <EvilTerran> aha
11:42:27 <ehird> (lambda (...) ...) would be Cons (Symbol "lambda") (...)
11:42:46 <EvilTerran> i call that "converting into a parse tree"
11:42:56 <ehird> which would be converted to (Lambda closure code)
11:43:02 <ehird> by eval.
11:43:12 <ehird> so, sure, parse tree.
11:43:21 <ehird> except that the objects i parse into are lisp objects themselves :-)
11:43:25 <ehird> ergo scheme (read)
11:43:51 <EvilTerran> so then evaluating it approximately according to the evaluation step semantics?
11:44:32 <Sizur> how can i instruct "runhaskell Setup.hs haddock" to run cpp first?
11:44:39 <EvilTerran> ("turn an AST that looks like <this> into another one that looks like <that>")
11:44:53 <ehird> EvilTerran: pretty much i guess
11:45:06 <hashendgame> Sizur: I'm taking a guess here, but is it -XCPP ?
11:45:15 <EvilTerran> do you know of the book Types And Programming Languages?
11:45:23 <hashendgame> I saw a command line spit that out earlier as I was tinkering with something else
11:45:36 <ehird> parse "(lambda () 2)" -> Cons (Symbol "lambda") (Cons Nil (Cons (Integer 2) Nil))
11:45:43 <ehird> change names appropriately for haskell conflicts.
11:45:45 <Sizur> i have LANGUAGE CPP header in the file itself, but it's irrelevant for Haddock
11:45:59 <EvilTerran> it does a lot of that sort of thing. it's well worth reading, too
11:46:09 <ehird> eval that -> Lambda <closure> Nil [(Integer 2)]
11:46:09 <hashendgame> runhaskell -XCPP Setup.hs haddock?
11:46:34 <ehird> my aim is simply to implement R5RS - http://schemers.org/Documents/Standards/R5RS/HTML/ - basically word for word
11:46:36 <lambdabot> Title: Revised^5 Report on the Algorithmic Language Scheme
11:46:47 <Saizan> Sizur: a solution is to use haddock 2.0
11:46:54 <EvilTerran> (defining a simple language in terms of its grammar and semantics, then building an interpreter from the grammar and semantics as directly as possible)
11:46:55 <Sizur> or better, how can i make Cabal skip generation of haddock page for a particular exposed module?
11:46:55 <ehird> of course, the hard bit is the continuations! and dynamic-wind :)
11:47:46 <EvilTerran> @go types programming languages ben pierce
11:47:47 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
11:47:47 <lambdabot> Title: Types and Programming Languages
11:47:52 <Sizur> i thought i had the latest 0.9 hmm
11:48:15 <newsham> heh, "what happens in the IO monad stays in the IO monad"
11:48:19 <Saizan> darcs get http://code.haskell.org/haddock
11:48:20 <lambdabot> Title: Index of /haddock
11:48:20 <newsham> I need a shirt saying that
11:48:41 <hashendgame> dons: do you have any plans to do another plugins release to hackage?
11:49:07 <dons> yeah,though if someone else wants to take over maintainership...
11:51:04 <Sizur> where can i read on the differences? http://www.haskell.org/haddock/doc/html/index.html talks mostly about 0.9 and even 0.2 sometimes
11:51:04 <lambdabot> Title: Haddock User Guide
11:51:53 <Saizan> Sizur: 2.0 uses ghc parser so it can handle CPP/TH and other syntactical extensions where 0.9 would die
11:52:10 <EvilTerran> ehird, anyway, I think you'd like that book, if you haven't already seen it
11:52:37 <Sizur> Saizan: thanks. so there are no differences in markup?
11:53:01 <hashendgame> I don't have the skill to maintain it, I'm afraid, but I do want to see it stay safe in gentoo
11:53:35 <Saizan> Sizur: i don't think so, at least not incompatible ones
11:54:06 <ehird> hm, is there a way to get an array/vector in haskell?
11:54:25 <waern> Sizur, the haddock pages will be updated tomorrow, here are the changes: code.haskell.org/haddock/CHANGES
11:54:27 <EvilTerran> @go site:haskell.org Data.Array
11:54:28 <lambdabot> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Array.html
11:54:52 <EvilTerran> huh. i guess that copy will do.
11:55:07 <Sizur> waern: thanks.
11:55:38 <Sizur> i installed 0.9 from my distro repo, now i installed 2.0 but haddock --version still shows 0.9 :/
11:55:46 <ehird> EvilTerran: it said immutable somewhere onthat page. :-)
11:55:49 <ehird> is that just IArray?
11:56:21 <EvilTerran> @go site:haskell.org Data.Array.MArray
11:56:23 <lambdabot> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Array-MArray.html
11:57:28 <Sizur> i see, it's installed under /usr/local/bin
11:57:33 * ehird goes looks at what ST is
11:57:58 <EvilTerran> ehird, if your arrays are fixed-length but with mutable contents, an Array ix (IORef el) may also suit
11:58:19 <ehird> EvilTerran: not sure if scheme vectors are fixed-length
11:58:21 * ehird checks
11:58:21 <EvilTerran> the ST monad is like the IORef bits of the IO monad
11:59:07 <EvilTerran> as it only does references, it's possible to have values "escape" from the ST monad, tho
11:59:26 <Sizur> now i get: haddock: unrecognized option `--package=<mypackage>'
11:59:39 <EvilTerran> because all the mutability can be wrapped up inside the monadic expression
11:59:40 <waern> --package is not supported anymore
11:59:55 <Sizur> that's from running Setup.hs haddock
11:59:56 <waern> Sizur: use --optghc=-package-name --optghc=<mypackage>
12:00:00 <ehird> 'The length of a vector is the number of elements that it contains. This number is a non-negative integer that is fixed when the vector is created.'
12:00:02 <ehird> hm.
12:00:16 <waern> Sizur: argh! that's not good :(
12:00:20 <Saizan> Sizur: newer cabal support it
12:00:31 <waern> I forgot to test with Cabal...
12:00:51 <Saizan> Sizur: if you already have a recent cabal try runhaskell Setup.hs clean first, the haddock version is cached
12:01:00 <Sizur> ok let me try that
12:01:09 <ehird> so, vector = mutable, fixed-length array
12:01:14 * ehird looks to see the most suitable thing for that
12:01:15 <EvilTerran> ehird, you can probably use an IOArray okay if you want, but apparently they only work with certain types of elements, hence my suggestion to use an array of refs
12:01:34 <waern> Sizur, Saizan: no, I think the problem is that Cabal sends --package to Haddock, Cabal has to be updated since I just removed that flag
12:01:45 * ehird takes note that all evaluation functions etc. will have to be IO anyway (for... IO, in Scheme), so using IO* will be the best
12:02:10 <Sizur> waern, Saizan: after cleaning, haddock command finishes good
12:02:21 <waern> Sizur: hm, okay then
12:02:54 <waern> that makes sense since I actually tested Haddock with Cabal, now that I remember :D
12:03:08 <Saizan> EvilTerran: IOArray is fully polymorphic in the elements, IOUArray isn't
12:03:15 <EvilTerran> ah, i see. ignore me.
12:03:31 <EvilTerran> ehird, listen to Saizan. he knows what he's talking about more than I. :P
12:15:20 <ehird> they do only have to store one type :-)
12:15:20 <ehird> presumably, SchemeVal
12:15:20 <EvilTerran> which is not a type that IOUArray can store
12:15:20 <EvilTerran> however, apparently IOArrays can
12:15:20 <byorgey> ehird: the 'U' in IOUArray is for 'unboxed', meaning it can only store certain primitive types that can be unboxed, like Int, Char, and so on
12:15:20 <ehird> byorgey: hm.
12:15:20 <byorgey> ehird: but IOArray can store anything.
12:15:20 <ehird> i love what happens whenever you take the word
12:15:20 <ehird> 'mutable' and drop it into #haskell
12:15:20 <ehird> :)
12:15:20 <EvilTerran> IOUArrays are zippy
12:15:20 <EvilTerran> but restricted
12:15:20 <byorgey> KABOOM!
12:15:20 <ehird> zam!
12:15:20 * EvilTerran looks askance at byorgey
12:15:20 <EvilTerran> ... what did you do?
12:15:21 <byorgey> it wasn't me!  it was... uh... the evil squirrels!
12:15:21 <byorgey> I was actually just making a joke re: ehird's joke about dropping the word 'mutable' into #haskell, but it was funny that a minor netsplit happened at the same time =)
12:15:21 <EvilTerran> the evil squirrels blew up zelazny, and you just happened to be in earshot at the time?
12:15:21 <EvilTerran> really now.
12:15:21 <ehird> byorgey: :-)
12:15:21 <ehird> ok, time to go back to basics:
12:15:21 <ehird> A scheme value is one of several types, the compound versions of which are mutable.
12:15:21 <ehird> Scheme code can perform imperative and IO actions at any time, with no restriction or distinction from any other type of action.
12:15:21 <ehird> Therefore: SchemeVal must utilize some kind of monad.
12:15:21 <ehird> The question: Which?
12:15:56 <EvilTerran> i think you could make the evaluator look pure from haskell's point of view
12:16:22 <EvilTerran> by having a lazily-evaluated String for each of input and output
12:17:29 <ehird> no
12:17:31 <ehird> there are many ports
12:17:43 <ehird> network ports, file ports... the input and output ports are by default set to console ports and are changable
12:17:51 <ehird> tricks like that: just not worth it here
12:17:58 <EvilTerran> ah. okay, you're not just doing stdin/stdout
12:18:09 <EvilTerran> i'd write it to use a general MonadIO
12:18:14 <byorgey> well, you'll definitely need IO for the network/file capabilities.
12:18:18 <ehird> like i said: end goal, if it's in R5RS: it works in this system :)
12:18:47 <EvilTerran> @go site:haskell.org Control.Monad.Trans
12:18:48 <lambdabot> http://cvs.haskell.org/Hugs/pages/libraries/mtl/Control-Monad-Trans.html
12:19:01 <EvilTerran> that's where MonadIO's defined
12:19:25 <EvilTerran> and using that instead of just plain IO would allow you to add stuff like a ContT later, say, to do continuations
12:19:33 <ehird> ok
12:19:36 <byorgey> ehird: do you know about monad transformers?
12:19:47 <ehird> byorgey: i may have used them without knowing what they are.
12:19:58 <EvilTerran> that's unlikely, they're quite fiddly
12:20:07 <byorgey> ehird: heh, well, I think they'll probably be your friends here.
12:20:09 <ehird> i'm still most definately an utter and completely helpless newbie :-)
12:20:21 <byorgey> ehird: there are two things you should read
12:20:25 <ehird> still, i've written quite a few toy schemes, so one in haskell? hey. :P
12:20:28 <byorgey> @go monad transformers step-by-step
12:20:29 <lambdabot> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
12:20:29 <lambdabot> Title: Monad Transformers Step by Step
12:20:37 <EvilTerran> and so you're implementing R5RS; learning by immersion ,eh?
12:20:43 <byorgey> @go site:yi.org how to use monad transformers
12:20:44 <lambdabot> No Result Found.
12:20:50 <byorgey> @go how to use monad transformers
12:20:51 <lambdabot> http://sigfpe.blogspot.com/2006/05/grok-haskell-monad-transformers.html
12:20:52 <lambdabot> Title: A Neighborhood of Infinity: Grok Haskell Monad Transformers
12:21:04 <byorgey> that's not the one I wanted
12:21:05 <ehird> EvilTerran: indeed! :D
12:21:33 <EvilTerran> ... i have too many windows open
12:22:04 <byorgey> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
12:22:05 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
12:22:10 <ehird> byorgey: i guess i should get over my hate of pdfs :(
12:22:28 <byorgey> ehird: yes, that's recommended =)
12:22:43 <ehird> byorgey: but I don't want to become an academic in a pointy hat!
12:22:51 <byorgey> ehird: the 'step-by-step' link I gave is a very readable tutorial on monad transformers, with great examples
12:22:54 <ehird> crap, i'm in #haskell. how did that happen?
12:23:09 <matthew-_> ugh, I can't remember the function. I want :: (Eq a) => a -> [a] -> [[a]] s.t. f x [a,b,c,x,d,e,x,f,x,g] = [[a,b,c],[d,e],[f],[g]]
12:23:18 <byorgey> ehird: it's not an impenetrable academic treatise, don't worry =)
12:23:37 <matthew-_> name that function!
12:23:38 <roconnor> @type group
12:23:40 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
12:23:44 <byorgey> matthew-_: there is no such function.
12:23:47 <roconnor> oh
12:23:47 <ehird> byorgey: it's a PDF in a serif font, typeset by what looks like TeX or LaTeX. I think it's too late for me. :P
12:23:56 <Toxaris> ehird: you can print those scientific-paper-looking tutorials and wrap them in the cover of the Perl-book, so nobody will know you're reading them
12:23:56 <byorgey> matthew-_: not in the standard libraries at least.
12:23:59 <matthew-_> yeah, I was thinking about groupBy or partition
12:24:03 <matthew-_> ok, I'm not going mad then
12:24:11 <matthew-_> I thought it should be called splitOn
12:24:17 <roconnor> @type splitAt
12:24:17 <lambdabot> forall a. Int -> [a] -> ([a], [a])
12:24:21 <ehird> Toxaris: but then they'll think i'm reading a perl book
12:24:34 <byorgey> ehird: ok, a graphic novel then
12:24:38 <matthew-_> right, it's going to be a foldr then
12:24:43 <roconnor> @type unintercalate
12:24:44 <lambdabot> Not in scope: `unintercalate'
12:24:51 <ketil> untercalate?
12:24:53 <ketil> :-)
12:24:59 <roconnor> :)
12:25:04 <ketil> (Of course, then we'd need Ã¼bercalate)
12:25:49 <pjd> roconnor: unintersperse, surely
12:26:16 <roconnor> @type intersperse
12:26:16 <lambdabot> forall a. a -> [a] -> [a]
12:26:38 <roconnor> @type intercalate
12:26:39 <lambdabot> Not in scope: `intercalate'
12:26:43 <roconnor> :/
12:27:11 <EvilTerran> > groupBy (const.(=='x')) "fooxbarxxbaz"
12:27:13 <lambdabot>  ["f","o","o","xbarxxbaz"]
12:27:26 <EvilTerran> er, that's not right
12:27:51 <EvilTerran> > groupBy (const (/='x')) "fooxbarxxbazx"
12:27:52 <lambdabot>  ["foo","xbar","x","xbaz","x"]
12:27:57 <Toxaris> > groupBy ((==) `on` (== 'x')) "fooxbarxxbaz"
12:27:58 <lambdabot>   Not in scope: `on'
12:28:13 * Toxaris wants on :(
12:28:20 <matthew-_> @src on
12:28:21 <lambdabot> (*) `on` f = \x y -> f x * f y
12:28:25 <EvilTerran> matthew-_, how's that for a hack of a definition? :)
12:28:26 <matthew-_> ask and ye shall receive
12:28:40 <matthew-_> drop all xs
12:28:45 <Toxaris> @let (*) `on` f = \x y -> f x * f y
12:28:47 <lambdabot> Defined.
12:28:50 <Toxaris> > groupBy ((==) `on` (== 'x')) "fooxbarxxbaz"
12:28:50 <lambdabot>  ["foo","x","bar","xx","baz"]
12:28:55 <EvilTerran> > map (dropWhile (=='x') . groupBy (const.(=='x')) $ "fooxbarxxbaz"
12:28:56 <lambdabot> Unbalanced parentheses
12:29:01 <EvilTerran> > map (dropWhile (=='x')) . groupBy (const.(=='x')) $ "fooxbarxxbaz"
12:29:02 <lambdabot>  ["f","o","o","barxxbaz"]
12:29:06 <roconnor> Toxaris: that's fucked up
12:29:10 <EvilTerran> damnit, i picked up the wrong one
12:29:20 <EvilTerran> > map (dropWhile (=='x')) . groupBy (const (/='x')) $ "fooxbarxxbaz"
12:29:21 <lambdabot>  ["foo","bar","","baz"]
12:29:41 <EvilTerran> Toxaris' is a damn slight less evil than mine, anyway.
12:30:17 * byorgey feels pity for the poor, abused groupBy function =(
12:30:21 <radetsky> I'm having difficulty fixing hmp3. It uses copyCString, which no longer exists. It had type CString -> ByteString
12:30:50 <radetsky> I defined copyCString = copy . unsafePerformIO . packCString
12:30:58 <Toxaris> I don't think my version is linear in the length of the input
12:31:03 <Toxaris> so you should not use it in real code
12:31:05 <Toxaris> but it looks nice :)
12:31:25 <EvilTerran> i think it is...
12:31:40 <EvilTerran> @src groupBy
12:31:41 <lambdabot> groupBy _  []       =  []
12:31:41 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
12:31:41 <lambdabot>     where (ys,zs) = span (eq x) xs
12:31:54 <radetsky> it doesn't work. Should it?
12:31:55 <byorgey> sure it is
12:32:08 <radetsky> am i doin it rite?
12:32:14 <matthew-_> > let f x xs = foldr (\y acc -> case y == x of True -> (case null . head $ acc of True -> acc; False -> []:acc); _ -> case acc of [] -> [[y]]; (a:rest) -> (y:a) : rest) [] xs in f 'x' "abcxdexfxxgxhi"
12:32:15 <lambdabot>  ["abc","de","f","g","hi"]
12:32:16 <byorgey> unsafePerformIO !?
12:32:22 <matthew-_> ugh, that's frikking rubbish
12:32:28 <EvilTerran> eww
12:32:58 <matthew-_> well quite. it's obviously correct though.
12:32:59 <radetsky> @src unsafePerformIO
12:32:59 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
12:33:05 <byorgey> radetsky: I don't actually know, but I'm guessing you shouldn't be using unsafePerformIO.  If you're not sure, you shouldn't be using it. =)
12:33:12 <Toxaris> hmm yes of course, it is linear. but it applies (== 'X') more often then needed
12:33:45 <radetsky> byorgey: yeah, but there isn't anything to replace copyCString
12:33:59 <byorgey> Toxaris: ah, true.  Well, you could use the 'Schwartz transform' trick...
12:34:19 <Toxaris> byorgey: @more
12:34:26 <radetsky> how do you make lambdabot return just the type of a lib f'n?
12:34:29 <byorgey> radetsky: ask dons, maybe
12:34:36 <radetsky> dons: you there?
12:34:42 <Toxaris> :t id
12:34:44 <lambdabot> forall a. a -> a
12:34:56 <radetsky> :t unsafePerformIO
12:34:57 <lambdabot> Not in scope: `unsafePerformIO'
12:35:09 <byorgey> Toxaris: first map (id &&& (=='x')) over the list, do the grouping on snd, then map (map fst)
12:35:14 <radetsky> :m System.Unsafe
12:36:23 <EvilTerran> > let f x = uncurry (:) . second (f x . dropWhile (==x)) . break (==x) in f 'x' "abcxdexfxxgxhi"
12:36:23 <radetsky> :t unsafePerformIO
12:36:24 <lambdabot>  ["abc","de","f","g","hi","","","","","","","","","","","","","","","","","",...
12:36:26 <lambdabot> Not in scope: `unsafePerformIO'
12:36:32 <EvilTerran> owzat?
12:36:40 <EvilTerran> hm. close.
12:36:46 <Toxaris> :t System.IO.Unsafe.unsafePerformIO
12:36:48 <lambdabot> forall a. IO a -> a
12:37:29 <ToRA> > let splitOn delim = filter (not . null) . unfoldr (liftM2 (>>) (guard . not . null) (Just . second (drop 1) . break (== delim))) in splitOn 'x' "therexissomexsherexxxhthe!"
12:37:30 <lambdabot>  ["there","issome","shere","hthe!"]
12:37:53 * byorgey <*> home
12:38:35 <radetsky> :t Data.ByteString.copy . System.IO.Unsafe.unsafePerformIO .  Data. ByteString.packCString
12:38:36 <lambdabot> Couldn't find qualified module.
12:38:42 <Toxaris> byorgey: oh yes that looks applicable here :)
12:39:09 <Toxaris> > unpack . split 'x' . pack $ "therexissomexsherexxxhthe!"
12:39:09 <lambdabot>   Not in scope: `pack'
12:39:14 <radetsky> @karma- lambdabot
12:39:14 <lambdabot> lambdabot's karma lowered to 52.
12:40:32 <Toxaris> > Data.List.map Data.ByteString.Char8.unpack . Data.ByteString.Char8.split 'x' . Data.ByteString.Char8.pack $ "therexissomexsherexxxhthe!" -- any bytestring at all?
12:40:32 <lambdabot>   Not in scope: `Data.ByteString.Char8.pack'
12:41:52 <radetsky> :t Data.ByteString.copy . System.IO.Unsafe.unsafePerformIO .  Data.ByteString.packCString
12:41:53 <lambdabot>     Couldn't match expected type `IO a'
12:41:53 <lambdabot>            against inferred type `Data.ByteString.Base.ByteString'
12:41:53 <lambdabot>     In the second argument of `(.)', namely
12:42:22 <radetsky> :t Data.ByteString.packCString
12:42:22 <lambdabot> Foreign.C.String.CString -> Data.ByteString.Base.ByteString
12:42:50 <radetsky> wtf
12:42:56 <radetsky> hoogle and lambdabot disagree
12:43:12 <radetsky> Data.ByteString.	packCString	:: CString -> IO ByteString
12:43:18 <radetsky> ^ hoogle
12:43:33 <radetsky> oh, wait
12:43:39 <radetsky> hoogle is wrong
12:44:24 <CosmicRay> radetsky: that is the type of it in 6.8
12:44:28 <CosmicRay> in 6.6 it was not in the IO monad
12:45:07 <radetsky> CosmicRay: lambdabot is getting :t from 6.6?
12:45:24 <CosmicRay> yes, that is what it looks like
12:45:29 <radetsky> oh, nm, I'm getting confused, lambdabot is wrong
12:45:48 * radetsky puts down crackpipe
12:45:53 <radetsky> much better
12:46:09 <CosmicRay> whew.
12:47:06 <Saizan> CosmicRay: you're the maintainer of hslogger right? a new release on hackage would be great since the current one doens't build on 6.8.* :)
12:47:14 <CosmicRay> yes, I am
12:47:15 <radetsky> if copyCString returns an IO ByteString, will unsafePerformIO extract it?
12:47:28 <CosmicRay> Saizan: check out the darcs tree.  compatibility patches pushed earlier today.
12:47:47 <CosmicRay> Saizan: new hackage upload will happen as soon as ghc 6.8.x gets sorted out in Debian unstable, which means about wednesday or so
12:48:12 <CosmicRay> Saizan: darcs get http://darcs.complete.org/hslogger
12:48:13 <lambdabot> Title: Index of /hslogger
12:48:25 <CosmicRay> add --partial after the "get" to speed things up
12:48:56 <Cale> ehird: The easiest way to stop hating PDFs is to stop using Adobe Acrobat Reader.
12:49:13 <ehird> Cale: I don't. I use Preview. :-)
12:49:16 <Saizan> CosmicRay: ok, thanks
12:50:00 <Cale> Yeah, Preview was not bad, its support for Postscript though was not so hot, if I recall correctly.
12:51:31 <radetsky> @src unsafePerformIO
12:51:31 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
12:51:48 <bos> radetsky: you want to be very careful using that
12:52:28 <Cale> Heh, wow, apparently I have ~11000 conversations in my GMail whose subject lines contain "[Haskell]"
12:52:40 <bos> chatty!
12:53:10 <radetsky> :t realWorld
12:53:12 <lambdabot> Not in scope: `realWorld'
12:53:59 <lament> u ya poydu
12:54:06 <lament> sorry wrong window
12:54:11 <nornagon> same to you
12:54:43 <radetsky> what's realWorld? does it still exist?
12:54:56 <nornagon> heh.
12:55:00 <bos> radetsky: realWorld is internal plumbing.
12:55:17 <EvilTerran> ?hoogle RealWorld
12:55:18 <lambdabot> Control.Monad.ST.RealWorld :: data RealWorld
12:55:18 <lambdabot> Control.Monad.ST.Lazy.RealWorld :: data RealWorld
12:55:51 <radetsky> EvilTerran: realWorld, the function from "@src unsafePerformIO"
12:56:03 <EvilTerran> ?src IO
12:56:03 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
12:56:08 <EvilTerran> it appears there, too
12:57:35 <radetsky> that's the type
12:57:36 <Toxaris> radetsky: RealWorld is a type wich you can't instantiate yourself, and realworld# instantiate it nevertheless.
12:57:50 <Toxaris> radetsky: at least that's my understanding :)
12:58:22 <radetsky> ok, I'm just trying to confirm that unsafePerformIO does what I think it does
12:58:31 <radetsky> I don't actually want to use its parts
12:58:51 <Sizur> if i upload a package to hackage, will the exposed modules link to haddock pages automatically?
12:59:07 <bos> radetsky: you probably still don't want to use it.  what are you trying to do?
12:59:12 <Cale> radetsky: It creates a value, which when evaluated, executes the given IO action and evaluates to the result of that action.
12:59:32 <radetsky> bos: build hmp3
12:59:46 <radetsky> it uses the old copyCString
12:59:57 <Cale> Turn that into packCString
13:00:07 <radetsky> ?hoogle packCString
13:00:08 <lambdabot> Data.ByteString.packCString :: CString -> IO ByteString
13:00:08 <lambdabot> Data.ByteString.Char8.packCString :: CString -> IO ByteString
13:00:08 <lambdabot> Data.ByteString.packCStringLen :: CStringLen -> IO ByteString
13:00:10 <hpaste>  matthew-_ pasted "err, well, here it is... after all that..." at http://hpaste.org/4855
13:00:20 <tlaboc> what does a lone hash mean in Haskell? I know they can be part of function names, but I've also seen them on their own...
13:00:30 <radetsky> need to extract the ByteString from the IO monad, right?
13:00:32 <tlaboc> as in the above signature
13:00:36 <Cale> tlaboc: It's just another infix operator.
13:00:39 <matthew-_> Toxaris, EvilTerran: ^^ (above hpaste)
13:00:40 <radetsky> or am i doin it wrong?
13:00:43 <tlaboc> ah, ok
13:00:45 <tlaboc> thanks
13:01:10 <Cale> er...
13:01:28 <Cale> yes
13:01:44 <radetsky> oh, yeah, nm, I am doin it totally wrong
13:02:00 * radetsky fails
13:02:17 <tlaboc> Does (#) have a standard definition somewhere? I can't :t it in GHCi...
13:02:21 <Cale> tlaboc: no.
13:02:41 <tlaboc> Ok, so its just a _legal_ infix operator then
13:02:44 <Toxaris> tlaboc: it's just a name you can use in your programs for infix-operator
13:02:44 <Cale> right
13:02:49 <tlaboc> ok, thanks
13:02:55 <Toxaris> > let (#) = 42 in (#)
13:02:57 <lambdabot>  42
13:03:07 <Toxaris> ok, not exactly infix...
13:03:08 <tlaboc> right on
13:03:08 <alexj> @seen lemmih
13:03:08 <lambdabot> lemmih is in #haskell. I last heard lemmih speak 8h 11m 29s ago.
13:03:09 <Cale> just as *!#$^^@ is a valid infix operator name :)
13:03:13 <alexj> @seen igloo
13:03:13 <lambdabot> igloo is in #haskell, #ghc and #darcs. I last heard igloo speak 1h 42m 7s ago.
13:03:16 <thoughtpolice> @seen dons
13:03:16 <lambdabot> dons is in #xmonad and #haskell. I don't know when dons last spoke.
13:03:32 <radetsky> is there a difference between the packCString's in ByteString and ByteString.Char8?
13:03:36 <EvilTerran> > break (const False) "testing"
13:03:37 <lambdabot>  ("testing","")
13:03:57 <radetsky> @src Data.ByteString.packCString
13:03:57 <lambdabot> Source not found. :(
13:04:04 <radetsky> @src packCString
13:04:05 <lambdabot> Source not found. Take a stress pill and think things over.
13:04:07 <tlaboc> is there seriously a channel about monads? is that what #xmonad is there?
13:04:07 <Toxaris> matthew-_: looks somewhat complicated :)
13:04:16 <bos> radetsky: it's in Data.ByteString
13:04:21 <Cale> tlaboc: No, that's about the window manager.
13:04:29 <bos> monads on tv.
13:04:35 <Cale> http://xmonad.org/
13:04:35 <lambdabot> Title: xmonad : a tiling window manager
13:04:41 <radetsky> bos: is's also in Data.ByteString.Char8
13:04:54 <bos> radetsky: that's just a re-export
13:04:58 <radetsky> oh, ok
13:05:00 <tlaboc> nevermind the noob (me)... :)
13:05:01 <radetsky> thanks
13:05:15 <Cale> tlaboc: It's cool, we don't mind :)
13:05:50 <Sizur> how can i make hackage build haddock for my package?
13:05:51 <matthew-_> Toxaris: it's quite cute actually ;)
13:06:55 <johnny87> `sup all?
13:06:58 <Toxaris> *Split> splitOn 'x' ""
13:06:58 <Toxaris> *** Exception: Prelude.tail: empty list
13:07:05 <johnny87> i`m new to programming
13:07:05 <matthew-_> oh cock
13:07:12 <matthew-_> Toxaris: ;)
13:07:18 <Cale> johnny87: hi, welcome to #haskell :)
13:07:24 <johnny87> would you recommend haskell as the first language for me?
13:07:31 <johnny87> hi to you too, cale
13:07:45 <Cale> johnny87: Sure, it's a pretty good choice :)
13:08:11 <thoughtpolice> @tell dons there was some talk on -cafe about hs-plugins, and how googling for it resulted in the old hs-plugins repo turning up first at http://www.cse.unsw.edu.au/~dons/code/hs-plugins, and gwern mentioned it might be beneficial to insert a deprecation warning in the repo, and point it to http://code.haskell.org/~dons/code/hs-plugins/ for ghc 6.8.x.
13:08:12 <lambdabot> Consider it noted.
13:08:21 <johnny87> in what fields do i benefit from it more?
13:08:24 <radetsky> johnny87: only if you : math as Ice Cube : ho's
13:08:28 <Sizur> johnny87: it's a very good choice especially as the first language. your mind is not yet polluted with object orientation.
13:08:45 <johnny87> could you recommend me a turtoisal to start with?
13:08:48 <Cale> johnny87: The online resources are not so bad, and of course we'll be happy to help with any questions you might have, but you still might want to pick up Graham Hutton's book, as it's supposed to be rather good for beginners.
13:09:00 <johnny87> ok
13:09:02 <johnny87> thanks
13:09:07 <Valodim> as a first language?
13:09:11 <johnny87> yes
13:09:11 <Valodim> whoa now that's one learning curve
13:09:13 <Cale> For online stuff, the Wikibook and Yet Another Haskell Tutorial are good.
13:09:24 <Cale> Valodim: It's not so bad. Lots of people learn it as a first language.
13:09:25 <tlaboc> Yet Another Haskell Tutorial worked for me as a first tutorial
13:09:26 <johnny87> what compiler do i have to use?
13:09:28 <thoughtpolice> the wikibook for the most part is a good introduction; I would recommend it.
13:09:34 <Cale> johnny87: Get GHC
13:09:40 <thoughtpolice> johnny87: http://haskell.org/ghc/
13:09:40 <johnny87> how much MB?
13:09:41 <hpaste>  EvilTerran annotated "err, well, here it is... after all that..." with "two versions of another algorithm" at http://hpaste.org/4855#a1
13:09:55 <johnny87> i want some turtoisal to read offline you know, like pfd
13:10:09 <EvilTerran> matthew-_, how about that?
13:10:35 <EvilTerran> er, in that first one, after should be xs' (or vice-versa)
13:10:35 <Cale> johnny87: hmm, the binary package is around 50 mb
13:10:49 <thoughtpolice> johnny87: yet another haskell tutorial is good from what I've heard. binaries for windows of ghc are around 30-60mb iirc.
13:10:56 <Cale> johnny87: Which platform are you running on?
13:11:20 <matthew-_> EvilTerran: not tail recursive I think
13:11:32 <matthew-_> oh, I'm wrong
13:11:40 <EvilTerran> i was under the impression that didn't matter in a lazy language anyway
13:12:03 <EvilTerran> or at least that the criteria for the equivalent property were somewhat different
13:12:16 <Cale> EvilTerran: Tail recursion still can be important, as the tail call optimisation is made.
13:12:18 <matthew-_> well at least you got an arrow op in ;)
13:12:33 <EvilTerran> Cale, ah, okay
13:12:59 <Cale> EvilTerran: It's just that if the tail recursive function isn't strict in those parameters, your tight loop will build up large expressions which can stack overflow when they're evaluated.
13:13:09 <matthew-_> EvilTerran: I think mine's clearer - but that's hardly surprising as I wrote it and understand it better.
13:13:20 <matthew-_> so I don't think my opinion actually counts
13:13:35 * EvilTerran prefers his first version to others
13:13:49 <matthew-_> mine would be clearer if I didn't insist on the gratuitous use of liftM2
13:13:55 <Cale> What is the function you're implementing?
13:14:10 <matthew-_> err, you have two implementations there and you're asking???
13:14:12 <matthew-_> ;)
13:14:12 <Sizur> guys, how can i make hackage build my haddocks? does it do it periodically?
13:14:21 <matthew-_> runghc Setup.hs haddock
13:14:21 <EvilTerran> three implementations!
13:14:37 <Saizan> Sizur: yes, periodically
13:14:40 <Cale> matthew-_: Yes, I could sort out what they're doing, I suppose ;)
13:14:48 <matthew-_> EvilTerran: ahh! I thought they were part of the same implementation. sorry.
13:15:07 <matthew-_> EvilTerran: aka, once again, it has been found, I don't bother to read
13:15:13 <Cale> ah, EvilTerran's first implementation is pretty clear.
13:15:27 <matthew-_> yeah agreed
13:15:29 <EvilTerran> :)
13:15:46 <EvilTerran> the explicit element-by-element recursion on yours makes my head spin
13:15:51 <Cale> This should also be an unfoldr
13:15:57 <Toxaris> @src words
13:15:57 <lambdabot> words s = case dropWhile isSpace s of
13:15:58 <lambdabot>     "" -> []
13:15:58 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
13:16:09 <matthew-_> EvilTerran: eh? there's no explicit recursion on mine
13:16:23 <EvilTerran> matthew-_, er... never mind :P
13:16:29 <dons> Saizan: yeah
13:16:30 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
13:16:31 <matthew-_> ahh, so words is pretty similar to EvilTerran's first one then
13:17:01 <matthew-_> I always like foldr id []. and lists of functions just make me happy all over
13:17:11 <idnar> :t foldr id []
13:17:13 <lambdabot> forall a. [[a] -> [a]] -> [a]
13:17:15 <Toxaris> matthew-_: and wordsBy :: (a -> Bool) -> [a] -> [[a]] is what you want, isn't it?
13:17:23 <EvilTerran> you might want to juggle the break and dropWhile to the order words does it in
13:17:35 <idnar> yrghl
13:18:18 <matthew-_> EvilTerran: neither of yours work
13:18:23 <Cale> > foldr id [] [(3:),reverse,(1:),(2:)]
13:18:24 <lambdabot>  [3,2,1]
13:18:32 <matthew-_> EvilTerran: I want splitOn 'a' "ab" => ["b"]
13:18:34 <Cale> fun :)
13:18:38 <tlaboc> Is there a modulus function defined for floating-point values anywhere?
13:18:41 <Cale> > foldr id [] [reverse,(3:),reverse,(1:),(2:)]
13:18:42 <lambdabot>  [1,2,3]
13:18:43 <matthew-_> but both of yours give ["", "b"]
13:18:51 <EvilTerran> matthew-_, as i said, juggle the break and dropWhile
13:18:58 <radetsky> what does !<type> mean in record syntax?
13:19:05 <matthew-_> radetsky: strict
13:19:11 <radetsky> thanks
13:19:33 <matthew-_> @index wordsBy
13:19:34 <lambdabot> bzzt
13:20:01 <Corun> >let f d s = filter (not . null) $ map fst $ takeWhile (not . null . snd) $ iterate ((break (d==)) . tail . snd) ([], d :  s ++ [d]) in f 'x' "abxxcdexxxfgxhxx"
13:20:07 <Cale> radetsky: When the application of the constructor to that parameter is evaluated, the parameter will be evaluated up to determining the top level constructor.
13:20:07 <nornagon> "> "
13:20:12 <Corun> > let f d s = filter (not . null) $ map fst $ takeWhile (not . null . snd) $ iterate ((break (d==)) . tail . snd) ([], d :  s ++ [d]) in f 'x' "abxxcdexxxfgxhxx"
13:20:13 <lambdabot>  ["ab","cde","fg","h"]
13:20:18 <Corun> Yay! :-)
13:20:24 <matthew-_> Toxaris: yes, that's what I want
13:20:49 <Toxaris> matthew-_: it doesn't exist, but you can adapt words :)
13:20:51 <Corun> My way is seriously fun hax, btw :-)
13:20:55 <matthew-_> > let f d s = filter (not . null) $ map fst $ takeWhile (not . null . snd) $ iterate ((break (d==)) . tail . snd) ([], d : s ++ [d]) in f 'x' "xabxxcdexxxfgxhxx"
13:20:55 <lambdabot>  ["ab","cde","fg","h"]
13:21:00 <fxr> lambdabot: why seagate wants 1000 euros to recover my 2 years old 70$ priced hard disk?
13:21:01 <matthew-_> Corun: yes, you pass
13:21:07 <Cale> > foldr id [] [reverse,('c':),reverse,map toUpper,('a':),('b':)]
13:21:07 <lambdabot>  "ABc"
13:21:42 <matthew-_> Toxaris: yes, you're right, that's a better name than splitOn
13:22:06 <Corun> That's a nice little problem, actually
13:22:12 * Corun tries to solve it nicer and shorter
13:22:28 <matthew-_> Corun: feel free to use hpaste to better lay it out
13:22:28 <Sizur> i will have a problem... hackage uses haddock 0.8. that means my haddock will fail
13:24:06 <radetsky> in hmp3, bytestring types are being made strict in records which are being made instances of Binary. Is this a good place to use binary-strict?
13:25:12 <matthew-_> if you do a let in a guard and the pattern match fails then the guard fails right?
13:26:33 <matthew-_> matthew-_: yes, that's right
13:26:34 <matthew-_> ta
13:27:08 <EvilTerran> :t unfoldr
13:27:08 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:28:12 <johnny91> lambdabot: how long did it take to you to become good in Haskell?
13:28:41 <matthew-_> yeah, a double nested unfoldr could be interesting
13:29:00 <johnny91> could you explain a little whats going on?
13:29:23 <matthew-_> johnny91: lambdabot is a robot
13:29:25 <tlaboc> johnny: http://www.haskell.org/haskellwiki/Lambdabot
13:29:25 <lambdabot> Title: Lambdabot - HaskellWiki
13:29:44 <Valodim> haha
13:29:50 <johnny91> :)
13:29:54 <johnny91> how stupid
13:29:55 <nornagon> @vixen asl?
13:29:56 <lambdabot> 19/f/California
13:29:58 <dons> radetsky: not really.
13:29:59 <tlaboc> lambdabot *is* wicked good at Haskell though
13:30:06 <matthew-_> we use him when we're too lazy to use ghci and figure out where the functions are
13:30:13 <johnny91> what was that unfoldr stuff?
13:30:27 <matthew-_> oh, that was sorta directed at Toxaris
13:30:33 <matthew-_> er, no, EvilTerran
13:30:49 <matthew-_> I'd posed a problem and Cale had said that it should be solved with an unfoldr
13:30:58 <johnny91> what`s that
13:30:59 <johnny91> ?
13:31:06 <johnny91> sorry but i`m new to programming
13:31:11 <johnny91> whats unfoldr?
13:31:18 <nornagon> :t unfoldr
13:31:18 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:31:19 <ski_> (matthew-_ : s/him/her/)
13:31:30 <matthew-_> ski_: I was going to ask ;)
13:31:32 <nornagon> johnny91: do you know what foldr is?
13:31:38 <johnny91> no
13:31:46 <nornagon> do you know about lists?
13:32:02 <johnny91> i have a general idead but supose yes
13:32:12 <Valodim> read Yet Another Haskell Tutorial, no sense in explaining it all :P
13:32:32 <tlaboc> I read it and I still have no idea what goes on in here :p
13:32:33 <nornagon> foldr is a helper function for examining an entire list and producing a single value
13:32:46 <nornagon> unfoldr is the opposite: you take a single value and produce an entire list
13:33:03 <ski_> > let {x | let {Nothing = Just ()} in True = True | otherwise = False} in x
13:33:03 <johnny91> what value for example?
13:33:04 <lambdabot>  True
13:33:25 <ski_> > let {x | let {Just y = Nothing} in y = True | otherwise = False} in x
13:33:26 <lambdabot>   Irrefutable pattern failed for pattern Data.Maybe.Just y
13:33:42 <Toxaris> johnny91: for example a number. the produced list could contain the digits of the number
13:33:48 <ski_> matthew-_ : so, no, if a let in a guard fails, then the fuard doesn't fail
13:33:49 <johnny91> aha
13:34:05 <nornagon> > unfoldr \x -> Just (x+1,x+1) $ 1
13:34:06 <lambdabot>  Parse error at "\x" (column 9)
13:34:15 <nornagon> > unfoldr (\x -> Just (x+1,x+1)) 1
13:34:16 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
13:34:22 <johnny91> so if i have in a list the number 23 unfoldr makes it 2,3
13:34:23 <johnny91> ?
13:34:25 <nornagon> no
13:34:33 <nornagon> read a tutorial :)
13:34:36 <johnny91> ok
13:34:47 <matthew-_> > let f x | let [a] = x in even a = True in f [1,2]
13:34:48 <lambdabot>   Irrefutable pattern failed for pattern [a]
13:34:51 <Toxaris> johnny91: you can use unfoldr to write a function wich realizes this 23 -> [2, 3], yes :)
13:34:58 <matthew-_> ski_: err?
13:34:59 <EvilTerran> > (\p -> unfoldr $ (>>) <$> guard.not.null <*> return.break p <$> dropWhile p) (=='x') "xfooxbarxxbazx"
13:35:00 <lambdabot>  ["foo","bar","baz"]
13:35:00 <ski_> > unfoldr (\x -> (10*x,x*2)) 1
13:35:00 <lambdabot>  Couldn't match expected type `Maybe (a, b)'
13:35:07 <EvilTerran> ta-dah!
13:35:08 <ski_> > unfoldr (\x -> Just (10*x,x*2)) 1
13:35:09 <lambdabot>  [10,20,40,80,160,320,640,1280,2560,5120,10240,20480,40960,81920,163840,32768...
13:35:19 <Toxaris> johnn91: but unfoldr doesn't do it all, you have to supply some details (like how to make 2353 into (2, 353))
13:35:25 <ski_> > let {x | let {Just y = Nothing} in y = True | otherwise = False} in x  -- matthew-_
13:35:26 <lambdabot>   Irrefutable pattern failed for pattern Data.Maybe.Just y
13:35:38 <matthew-_> oh! gotch
13:35:39 <matthew-_> a
13:35:42 <matthew-_> it's not falling through
13:35:47 <matthew-_> sorry, I'm being dumb.
13:35:51 <Toxaris> johnny91: but unfoldr knows that it has to proceed in the same way with 353 to arrive at (3, 53) and then (5, 3) so that in the end, you have 2353 -> [2, 3, 5, 3]
13:36:03 <johnny91> aha
13:36:09 <EvilTerran> matthew-_, whaddayathink of that one?
13:36:22 <nornagon> > unfoldr (\x -> if x <= 1 then Nothing else Just (x`mod`10,x/10)) 2353
13:36:22 <lambdabot>  Add a type signature
13:36:27 <nornagon> > unfoldr (\x -> if x <= 1 then Nothing else Just (x`mod`10,x/10)) 2353 :: Int
13:36:27 <lambdabot>  Couldn't match expected type `Int' against inferred type `[b]'
13:36:32 <nornagon> drat.
13:36:36 <Toxaris> johnny91: so the "idea" of unfoldr is: apply the same function over and over again, each time producing a single element of the result list and a new value
13:36:46 <johnny91> got it
13:36:50 <Cale> matthew-_: just that it could be
13:36:57 <matthew-_> EvilTerran: well, it's certainly getting shorter. ;)
13:37:06 <johnny91> when i read the tutorial i will have a clear idea
13:37:17 <EvilTerran> that's as short as it's getting while still remaining efficient, i think
13:37:28 <Toxaris> johnny91: this is (part of ) the power of Haskell: that you can express such "high level" ideas as code wich can be reused many times. plug in a different function to be multiply used, and unfoldr will do something else :)
13:37:44 <matthew-_> EvilTerran: yes, I'd actually have to read the applicative paper and probably the arrows paper aswell to have a clue what's going on there...
13:38:04 <EvilTerran> altho, each time it encounters an element that satisfies p that's not after another that satisfies p, that element does get p called on it twice
13:38:04 <johnny91> Is haskell as fast as C?
13:38:07 <Toxaris> johnny91: in the end, you arrive at very short code, using a log of "high level" functions like unfoldr as people in this channel do
13:38:11 <dons> johnny91: sometimes.
13:38:11 <Valodim> no
13:38:23 <dons> sometimes its faster, sometimes its slower.
13:38:37 <Valodim> well to be fair, in the majority of cases C is faster
13:38:40 <johnny91> without multithreading i mean
13:38:41 <dons> always it's different
13:38:47 <EvilTerran> > (\p -> unfoldr $ liftM2 (>>) (guard.not.null) (return.break p) . dropWhile p) (=='x') "xfooxbarxxbazx" -- better?
13:38:47 <lambdabot>  ["foo","bar","baz"]
13:38:49 <dons> johnny91: yeah, for some benchmarks.
13:38:55 <Valodim> however, haskell takes way less development time than C
13:39:08 <hpaste>  matthew-_ annotated "err, well, here it is... after all that..." with "just adding EvilTerran's latest" at http://hpaste.org/4855#a2
13:39:10 <Valodim> and CPU time is less costly than developer time, so...
13:39:11 <nornagon> > reverse $ (unfoldr $ (\x -> if x < 1 then Nothing else Just (x`mod`10,x`div`10))) 40012
13:39:12 <lambdabot>  [4,0,0,1,2]
13:39:15 <EvilTerran> matthew-_, i must admit, that use of Applicative was a little excessive
13:39:25 <EvilTerran> <$> and <*> where liftM2 would've sufficed
13:39:35 <qebab> I saw some index which put haskell at rougly twice the time of a fast C implementation, but then again it'll take 10 times as little time write the Haskell code and it'll be much easier to run parallell
13:39:37 <EvilTerran> and, even worse, <$> in place of (.) to save on a pair of parentheses :D
13:39:37 <dons> its rare you have to choose between haskell and C anyway
13:39:44 <dons> usually its between other high level languages,
13:39:47 <dons>  like umm.. python
13:39:48 <qebab> +to
13:40:01 <matthew-_> EvilTerran: I've only just noticed that your nick isn't EvilTerrain
13:40:21 <qebab> @hoogle unfoldr
13:40:22 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
13:40:22 <lambdabot> Data.ByteString.unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
13:40:22 <lambdabot> Data.ByteString.Char8.unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
13:40:45 <EvilTerran> hehe. rocky road!
13:40:48 <johnny91> it`s just because i`m new to programming and don`t know which language to start learning
13:41:12 <Valodim> well, what do you plan to do?
13:41:13 <qebab> Haskell gains a lot of points for being just about one of the easiest languages to run parallell, for speed, and for being very high level
13:41:14 <johnny91> i want something powerful like c and that doesnt take a lot of time
13:41:16 <nornagon> johnny91: it doesn't really make that much of a difference :)
13:41:32 <nornagon> pick one that you think looks pretty and go learn it.
13:41:32 <johnny91> i mean also the ease of learning it
13:41:37 <dons> johnny91: haskell's about 40 years more powerful than C. :)
13:41:40 <qebab> it loses for being hard to grasp if you know imparative/OOP languages but that's strictly speaking not Haskells fault ;)
13:41:41 <matthew-_> agh, can you not combine pattern guards with bools?
13:41:56 <Valodim> so in other words, you want something as powerful as C, but easier to learn and at least as fast?
13:42:00 <Valodim> sounds like a perfect language
13:42:01 <matthew-_> | [a] <- g && even a = True ?
13:42:04 <nornagon> haskell's as good a place as any
13:42:06 <Valodim> boring
13:42:10 <johnny91> yeah like utopian
13:42:14 <radetsky> can somebody point me to a good guide to instance declarations?
13:42:17 <Valodim> but if you want ease of learning, you're probably wrong :P
13:42:20 <ricky_clarkson> johnny91: Haskell isn't great for people who don't like learning stuff.
13:42:31 <qebab> johnny91: in all honesty dude, I really, really regret that I didn't try to pick up Haskell as my first language because it's been hard for me to get it in hindsight and I think it (or languages like it) is the future
13:42:36 <ricky_clarkson> johnny91: Excel is pretty nice for those people.
13:42:41 <Valodim> haha
13:42:52 <johnny91> :)
13:42:58 <nornagon> erlang actually helped me immensely when i was trying to understand the functional paradigm
13:43:01 <nornagon> not sure why
13:43:09 <qebab> johnny91: if you learn something like BASIC or C first, it will hurt quite a bit to learn a functional language
13:43:15 <nornagon> haskell had confused the crap out of the poor ruby programmer version of me
13:43:17 <pjd> @remember Valodim if you want ease of learning, you're probably wrong :P
13:43:17 <lambdabot> Done.
13:43:19 <matthew-_> ahh, you use a ,
13:43:26 <nornagon> until i read a tiny bit about erlang
13:43:37 <nornagon> i still don't know erlang, though :P
13:44:00 <qebab> johnny91: if you want a recommendation that isn't haskell though: Python, Ruby or Scheme. All three should teach you a lot of important concepts in todays programming, and be relatively easy to pick up
13:44:06 <ski_> matthew-_ : try s/&&/;/
13:44:21 <EvilTerran> > ((unfoldr .) $ (.) <$> ((>>) <$> guard.not.null <*>) . (return.) . break <*> dropWhile) (=='x') "xfooxbarxxbazx"  -- one more time, now pointsfree!
13:44:22 <lambdabot>  ["foo","bar","baz"]
13:44:23 <dons> thgouh all slower than haskell, and with worse C interfaces :)
13:44:30 <qebab> very true
13:44:35 <Botje> is there a trick to resolving "wobbly type" errors in ghc 6.8?
13:44:43 <matthew-_> ski_: | [a] <- g, even a = True ?
13:44:52 <ski_> or that, yes
13:44:58 <qebab> dons: but the syntax is less intimidating
13:44:59 <johnny91> well, to be honest my interest in programming is that it is needed in hacking
13:45:02 * ski_ can't remember the separator
13:45:11 <Valodim> ...
13:45:18 <idnar> qebab: that's a matter of perspective
13:45:23 <qebab> johnny91: "hacking" as in breaking into networks and such?
13:45:23 <Valodim> does that number at the end of your name indicate your year of birth?
13:45:26 <qebab> idnar: of course
13:45:26 <ski_> @quote hack
13:45:26 <lambdabot> dons says: the type system is *great* for coding while sleepy.. you just hack any garbage together, and let the type checker deal with it
13:45:29 <johnny91> yes
13:45:33 <johnny91> yes
13:45:35 <nornagon> johnny91: just get metasploit framework and go on your script kiddie way, then.
13:45:37 <dons> i find 'end' in blocks in ruby intimidating :)
13:45:37 <Valodim> >_<
13:45:41 <johnny91> things like that
13:45:44 <johnny91> no
13:45:46 <johnnowak> oi
13:45:49 * EvilTerran is tempted to go through and turn everything into an fmap
13:45:49 <qebab> johnny91: sorry, then I'm not helping you more
13:45:50 <idnar> qebab: I find Scheme's syntax far more intimidating than Haskell, even though I'm not very well acquainted with either
13:45:56 <Valodim> shall I laugh or cry? :)
13:45:58 <johnny91> i mean like network programming and this things
13:46:01 <Valodim> I think I'll go with eating toast
13:46:02 * Valodim afk
13:46:04 <hpaste>  Mitar pasted "How to optimize?" at http://hpaste.org/4856
13:46:21 <qebab> dons: yeah and I find curly braces and semicolons intimidating :)
13:46:33 <qebab> I still managed to pick up C somehow
13:46:35 <dons> yeah. they're scary.
13:46:36 <Mitar> this code is soo slow ... any ideas on how to optimize it?
13:46:51 <dons> why do people like to do all the work for the parser. :)
13:46:56 <qebab> indeed
13:46:59 <qebab> I don't get that
13:47:09 <johnny91> bcs i want to learn all by myself and not take some exploits made by others
13:47:09 <idnar> I find it ironic that I almost never leave out braces and semicolons, but I leave trailing colons out in Python all the time
13:47:12 <qebab> and when they see a language where they don't have to do it, they scream about not having to do it
13:47:18 <johnny91> like metasploit
13:47:19 <hpaste>  Mitar annotated "How to optimize?" with "types ..." at http://hpaste.org/4856#a1
13:47:22 <radetsky> dons: in hmp3's Tree.hs, it's erroring on "instance Binary File"
13:47:29 <Valodim> that will take many, many years, and is generally nothing you can start with
13:47:30 <dons> radetsky: what error?
13:47:49 <qebab> johnny91: why do you want to be a computer criminal?
13:47:50 <dons> radetsky: you can hang on a day, and i'll upload hmp3 1.4 tonight to hackage
13:47:54 <Valodim> also, it involves reverse engineering, so haskell is the opposite direction of what you want
13:48:02 <johnny91> yeah
13:48:07 <johnny91> i guess i got my answer
13:48:07 <nornagon> Valodim: not necessarily
13:48:22 <Valodim> huh?
13:48:28 <nornagon> Valodim: high-level languages can be valuable reverse-engineering tools.
13:48:41 <radetsky> dons: ok
13:48:44 <qebab> johnny91: if you go on and start breaking into networks and then proceed to call yourself a hacker, I will hunt you down and feed you to angry cats
13:48:48 <radetsky> so much for me being clever and fixing it
13:49:04 <Toxaris> johnny91: be aware of the lambda cats
13:49:05 <dons> well, you can if you want. you'll learn a lot
13:49:11 <radetsky> I can send you what I've done so far, but it's probably crap
13:49:33 <qebab> Toxaris: a lambda pushed me down a staircase once
13:49:35 <dons> send it over. it'll be useful
13:49:48 <Mitar> any suggestions on my code? http://hpaste.org/4856
13:49:59 <radetsky> first I have to figure out how to send darcs stuff. may take a little while
13:50:21 <notsmack> darcs send?
13:50:31 <EvilTerran> > (fmap unfoldr $ fmap fmap (fmap (fmap (>>) (guard.not.null) <*>) $ fmap (fmap return) break) <*> dropWhile) (=='x') "xfooxbarxxbazx" -- gotta live up to my name, here
13:50:31 <lambdabot>  ["foo","bar","baz"]
13:50:39 <dons> darcs send -o /tmp/foo.patch -- to make a patch file
13:50:51 <dons> or darcs send will work too, if you've mail set up
13:50:58 <dons> EvilTerran: hah
13:51:00 <radetsky> I probably don't
13:51:02 <matthew-_> EvilTerran: how much of your life are you planning on dedicating to this particular problem?
13:51:07 <dons> fmap fmap (fmap (fmap (>>)
13:51:14 <johnny91> can you explain me a little whats the duty of Lambdabot
13:51:16 <radetsky> whatever. I'm sure there's docs somewhere
13:51:16 <EvilTerran> dons, :D
13:51:17 <johnny91> ?
13:51:17 <dons> evil evil (evil (evil (!!))
13:51:25 <Corun> Are there enough fmaps, there?
13:51:34 <EvilTerran> matthew-_, oh, loads. i'm meant to be doing something *useful* here!
13:51:41 <qebab> johnny91: will you "hack" it if we tell you?
13:51:46 <Toxaris> johnny91: if you want to become a hacker in the "do cool stuff with computers, be cleverer then other people, no girlfriend in sight" sense of the word, you're right with Haskell and
13:51:57 <Toxaris> johnny91: ... and #haskell
13:52:14 <qebab> that's the only kind of hacker :/
13:52:15 <matthew-_> EvilTerran: combine with a foldr (.) ? $ repeat fmap
13:52:20 <johnny91> come on qebab
13:52:23 <qebab> the kind he wants to be is called a cracker
13:52:23 <Sizur> let him learn haskell, he'll forget about hacking business when he'll see the sexy beauty of a the category theory ;)
13:52:37 <EvilTerran> matthew-_, surely you mean foldr fmap ...
13:52:39 <johnny91> someone says the word hacker and you give him a hard time
13:52:58 <matthew-_> oh yeah
13:53:02 <Sizur> johnny91: well you used the word hacker in the context of a cracker
13:53:18 <matthew-_> Sizur: as does > 99% of the english speaking world
13:53:33 <qebab> matthew-_: that's the wrong part of the english speaking world though :)
13:53:37 <Sizur> mathrick: predominant view cannot dictate the truth
13:53:39 <Valodim> aw let's not start that discussion
13:54:02 <matthew-_> Sizur: ahh, but what is truth other than the dominant belief?
13:54:11 <matthew-_> for is truth not defined by the majority?
13:54:14 <Toxaris> johnny91: many people in here would consider themself hackers in the above-mentioned sense of the word
13:54:20 <matthew-_> also, fmap
13:54:26 <Valodim> fmap is truth?
13:54:33 <Sizur> if 2 out of 3 ppl will say 2+2=5, will it be truth?
13:55:08 <matthew-_> maths is man made anyway, so talking about truth and maths is slighty a non-sequitar
13:55:14 <Valodim> yep
13:55:22 <Sizur> two apples and two apples make five apples?
13:55:28 <matthew-_> oi. ;)
13:55:47 <psykon> Sizur, apples make nothing, they simply get eaten :)
13:55:48 <nornagon> Sizur: the concept of an apple is man-made
13:55:54 <jsnx> Sizur: usage, however, dictates the meaning of the lexicon...so don't try to speak the truth!
13:56:03 <Valodim> you're man-made .V.
13:56:13 <Toxaris> > let 2 + 2 = 5 in 2 + 2 -- Sizur: lambdabot agrees, too
13:56:14 <lambdabot>  5
13:56:19 <monochrom> apples make apple pies
13:56:23 <qebab> truth is subjective and I don't really care about people who read hollywood magazines and think that a hacker is a person who sends them spam-mail, tries to get their personal details such as cc numbers and so on
13:56:28 <qebab> :)
13:56:34 <Sizur> truth exist you want it or not. whatever it's man made or God made. it exists.
13:56:47 <matthew-_> no, I really don't agree.
13:56:54 <matthew-_> but hey, maybe this should be on -blah
13:56:55 <Sizur> you're free to
13:56:56 <notsmack> there are different types of truth...  scientific truth, or historical truth, or personal truth....
13:57:13 <Valodim> a hacker is one who doesn't consider himself as such and thus falls to the cliche
13:57:14 <Toxaris> qebab: I don't believe you (that you don't care for all of these people)
13:57:15 <matthew-_> I'm not sure I recognise a difference between a truth and a belief
13:57:24 <jsnx> matthew-_: i'm talking about it on -blah right now!
13:57:26 <oklopol> EvilTerran: this probably interests you a lot: i've accidentally opened a privmsg window with you *twice*, first time when clicking the userlist accidentally, and just now when scrolling upwards
13:57:36 <oklopol> i have not opened any other pm window by accident here
13:57:42 <qebab> Toxaris: I care *for* them but not in this context (As in I don't care what they think a hacker is, to me their definition is just wrong)
13:57:45 <oklopol> so... shall we get married or something?
13:57:51 <Sizur> then talk about belief and not truth
13:57:55 <EvilTerran> o.Ã³
13:58:29 <ski_> @yow
13:58:30 <lambdabot> hubub, hubub, HUBUB, hubub, hubub, hubub, HUBUB, hubub, hubub, hubub.
13:59:11 <monochrom> Great. After days of debating over logics, types, paradoxes, OO, ...  We finally start debating on Truth and Existence.
13:59:33 <qebab> It's like Godwins law except a lot more existential
13:59:41 <Toxaris> qebab: ok I see. sounds like a good idea. so you don't feel atacked if johnny91 uses the term hacker like you would use computer criminal youngster, because you don't care?
14:00:17 <qebab> Toxaris: I don't care what he defines it is, because we're not talking about the same thing and that's pretty clear
14:00:17 <jsnx> cracker youth are like little brown shirts
14:00:28 <qebab> defintes it as*
14:00:33 <qebab> oh my
14:00:39 <qebab> this keyboard keeps doing typoes ):
14:01:11 <jsnx> do i have to say it? cracker youth are little hitlers
14:01:22 <jsnx> good, now this discussion can end
14:01:29 <Toxaris> jsnx: :)
14:01:31 <notsmack> jsnx: sigh, no
14:01:36 <notsmack> that's covered in the rules
14:01:54 <matthew-_> um, I think we should digress to fmap
14:01:56 <jsnx> deutschland, deutschland, uber alles, uber alles in den welt
14:02:10 <Sizur> lol
14:02:14 <qebab> I want to make a reference to the rules and someone who was pretty strict in enforcing rules now
14:02:25 <tlaboc> I think this argument about truth and hackers should continue, but only as expressed in Haskell :)
14:02:39 <jsnx> or as expressed in #haskell-blah
14:02:39 <qebab> tlaboc: are side effects allowed? :D
14:02:45 <jsnx> where we are discussing it
14:03:04 <tlaboc> No, because these debates never have lasting side-effects...a.k.a. a point
14:03:06 <reqamst> what is it? huh?
14:03:14 <tlaboc> :D
14:03:43 <monochrom> is a lasting side effect static or dynamic?
14:03:50 <jsnx> qebab: who was this strict person?
14:03:54 <hpaste>  Corun pasted "THIS IS MUCH CLEANER" at http://hpaste.org/4857
14:04:16 <monochrom> person _|_ = _|_   <-- a strict person. :)
14:04:19 <Toxaris> maybe Oleg can encode unsafePerformIO at type level?
14:04:19 <tlaboc> I'm now going to politely excuse myself from the hole I've dug myself...
14:04:34 <hpaste>  EvilTerran annotated "err, well, here it is... after all that..." with "sanity and madness" at http://hpaste.org/4855#a3
14:04:38 <EvilTerran> okay, now i'm done
14:04:58 <Corun> As nice as it is to have insane amounts of higher order functions and function composition and monads to do things, sometimes its just easier to write a nice simple recursive function.
14:05:03 <qebab> jsnx: I think that if I started saying that without mentioning names that the rules apparently won't let me mention, I'll get recursive
14:05:17 <matthew-_> Corun: you're really not used to this place are you? :p
14:05:22 <EvilTerran> Corun, or use fmap!
14:05:28 <jsnx> qebab: we have rules against that stuff? where?
14:05:36 <monochrom> "easier" depends on your level of education.
14:05:41 <qebab> jsnx: I have no idea, someone mentioned rules earlier ):
14:05:45 <jsnx> oh
14:06:04 <Corun> Apparently not, Matt :-P
14:06:12 <qebab> I wonder if it would be pleasant to go all recursive
14:06:26 <jsnx> i guess i've always thought godwin's law was basically, as soon as you drop the H-bomb, the conversation is over
14:07:02 <jsnx> though it's usually phrased as "the H-bomb *will* get dropped"
14:07:02 <Toxaris> jsnx: it doesn't work if you do it deliberately
14:07:11 <jsnx> worked today ;)
14:07:11 <qebab> strictly speaking it goes something like this "As a discussion on the internet continues, the probability that someone will draw Hitler, nazism or World War 2 into it goes towards 1"
14:07:29 <Toxaris> is there a law stating that every conversation will discuss applicability of some law at some point?
14:07:38 <EvilTerran> matthew-_, how's my final (sane) version sit with you? i quite like it, actually
14:07:39 <notsmack> Toxaris: only in #haskell
14:07:41 <qebab> Toxaris: a higher-order law :)
14:07:50 <EvilTerran> inspiration drawn heavily from words, but with a little optimisation
14:07:54 <jsnx> the law of godwin's law :)
14:08:01 <Corun> I suppose the next function we need is splitWithList :: [a] -> [a] -> [[a]] :-)
14:08:14 <monochrom> It's very likely to get to fusion laws in #haskell
14:08:27 <jsnx> monochrom: what are fusion laws?
14:08:39 <matthew-_> EvilTerran: the one under "this is the formulation I'd actually use" ?
14:08:41 <qebab> fusion as in nuclear fusion? :o
14:09:13 <matthew-_> EvilTerran: yes, that's very nice.
14:10:10 <matthew-_> EvilTerran: actually, it's so nice, I'll finally replace my version with yours ;)
14:10:56 <monochrom> It's a broad term. Many equations that allow you to combine work or eliminate intermediate work are called fusion laws.  I believe an example is map g (map f xs) = map (g . f) xs
14:11:32 * Corun notes that this channel is actually so that people can write Matt's code ;-)
14:11:36 <jbauman> @. pl unpl foldr ($)
14:11:36 <lambdabot> foldr id
14:11:54 <wy> How I can tell ghci to dump core code?
14:12:06 <monochrom> -ddump-simpl IIRC
14:12:22 <monochrom> dons's favourite way anyway.
14:12:24 <EvilTerran> matthew-_, ty :)
14:12:28 <Corun> Oh, Hey, Matt, Henrik asked me something while I was advocating haskell... How do you do "plugins" in haskell?
14:12:40 <notsmack> @where hs-plugins
14:12:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
14:12:49 <dons> Corun: with one of the plugin libraries.
14:12:51 <fxr> Corun: you do well :)
14:12:57 <matthew-_> Corun: you'll find many people here who are meant to be doing PhDs and thus spend their days sitting on this channel writing other people's code
14:13:03 <dons> heh
14:13:07 <matthew-_> it's a community effort
14:13:10 <dons> matthew- continues this long tradition
14:13:15 <dons> haskell: powerered by phd
14:13:20 <matthew-_> well quite
14:13:33 * EvilTerran isn't even meant to be doing a phd
14:13:34 <matthew-_> powered by the citizens' taxes actually
14:13:43 <dons> yes, 20 years of government funding
14:13:49 * Toxaris is still in the middle of his diploma studies
14:13:50 <monochrom> ...
14:14:04 <matthew-_> I've witnessed governments spend money in worse ways
14:14:07 <jsnx> matthew-_: well, at least it hasn't killed any of our young men in foolish wars!
14:14:11 <EvilTerran> ... i'm meant to be packing to travel back to uni to continue my undergrad degree
14:14:28 <jsnx> i dropped out of school to study zen
14:14:34 <matthew-_> jsnx: um, there's probably some haskell involved somewhere.
14:14:39 <jsnx> zen led me haskell
14:14:52 <monochrom> Haskell found me.
14:14:56 <fxr> jsnx: and it will probably led you to school
14:15:06 <Corun> Haskell didn't find me. Haskell was thrust at me by uni ^_^
14:15:09 <Toxaris> i
14:15:13 <jsnx> fxr: well, i hope not -- because school costs a lot of money, and i'm already 26
14:15:18 <matthew-_> Corun: AND YOU WILL LOVE IT
14:15:25 <Corun> Eeek!
14:15:25 <jsnx> Corun: yes, you will
14:15:30 <monochrom> Haskell was stalking you at your uni!
14:15:34 <jsnx> >:3
14:15:47 <matthew-_> frankly, if you didn't want to do Haskell, you could have gone to Oxbridge
14:15:55 <wy> monochrom: Thanks. Is core code free of runtime dispatching?
14:16:03 <Corun> I didn't not want to do haskell.
14:16:15 <matthew-_> and you failed to get into oxbridge?
14:16:19 <Corun> Well, yea.h
14:16:21 <jsnx> matthew-_: i don't understand that -- isn't oxbridge where haskell happens these days?
14:16:22 <matthew-_> oh sorry, I misread
14:16:23 <Corun> :-D
14:16:33 <monochrom> Is "case ... of ..." runtime dispatching?
14:16:34 <EvilTerran> if you didn't want to do haskell, you'd better avoid oxford
14:16:44 <EvilTerran> cambridge are still using SML, last i checked
14:16:51 <jsnx> oh, interesting
14:16:53 <Corun> The tenses in that sentence waaay don't make sense, I swear
14:17:02 <jsnx> yeah, for real
14:17:04 <Corun> We were shown ML at the Cambridge open day
14:17:10 <matthew-_> Corun: aol
14:17:14 <wy> monochrom: kind of. I mean if there something like case ... of in the final object code?
14:17:24 <Corun> Er, aol?
14:17:25 <matthew-_> edinburgh has just dropped all ML hasn't it? replaced it with python iirc?
14:17:30 <matthew-_> /aol
14:17:32 <matthew-_> better?
14:17:47 <qebab> they don't teach haskell here ): they have a functional programming course, which ironically switched scheme for common lisp a couple of years ago
14:17:48 <jsnx> matthew-_: i don't get it
14:18:01 <qebab> err, switched from scheme to common lisp
14:18:06 <jsnx> qebab: "here" is edinburgh?
14:18:12 <monochrom> core is full of case-of.
14:18:15 <qebab> jsnx: "here" is Trondheim, Norway
14:18:22 <matthew-_> Corun: sorry, it's a way of saying "me too". AOL users historically have a habit of replying to long posts, quoting the whole thing and then adding "me too" at the bottom. Hence /aol
14:18:36 <Corun> Ah
14:18:37 <wy> monochrom: but is core the type checked and all runtime code?
14:18:43 <monochrom> A simple main = print (product [1..100]) is easily two or three case-of's.
14:19:15 <wy> monochrom: good. I see. thanks!
14:19:17 <matthew-_> is haskell first-year compulsory at oxford?
14:19:28 <dmhouse> For compsci, yes, I think so.
14:19:48 <matthew-_> oxford doesn't do the same tripos thing that cambridge does?
14:19:48 <wy> Is oxford good at haskell?
14:19:55 <EvilTerran> dmhouse, yeah. for maths+cs halflings, too
14:20:08 <Corun> Not as good as Imperial :-P
14:20:11 <EvilTerran> i don't know what a tripos thing is
14:20:14 <tlaboc> European university sounds far more exciting than here, I haven't done anything other than C, C++, and x86 for class :(
14:20:17 <dmhouse> matthew-_: "tripos" is a Cambridge thing.
14:20:20 <Corun> /bias
14:20:22 <matthew-_> right.
14:20:33 <wy> How about notingham, cambridge and chalmers?
14:20:48 <matthew-_> nottingham, hopefully, is epigram from day 1
14:20:50 <EvilTerran> wy, they don't really teach it in any depth; it's a means to the end of teaching functional programming technique
14:20:51 <dmhouse> Corun: *cough*. Of course, we both know Cambridge (and especially Cambridge maths) is by far superior to both of these establishments.
14:21:03 <dmhouse> Corun: although I agree that Imperial > Oxford.
14:21:13 * EvilTerran smells a tab
14:21:16 <jsnx> dmhouse: and how is their rowing?
14:21:19 <fxr> hah, I wrote fortran to plain a4 papers in university
14:21:20 <wy> EvilTerran: such as foldr, map, ... ?
14:21:20 <matthew-_> EvilTerran: if you do an undergrad in science at Cambridge then you have to spend your first year doing mixed science. so you only actually spend the 2nd and 3rd years doing what you want
14:21:31 <Corun> Cos, ya know, rowing is a good measure of worth...
14:21:40 <dmhouse> jsnx: Cambridge won the Cambridge-Oxford boat race this year. Therefore we are better. QED.
14:21:45 <dmhouse> (I'm a mathmo, I can't be wrong.)
14:21:45 <Igloo> wy: I enjoyed Oxford, FWIW. I don't know what you mean by "good"
14:21:48 <EvilTerran> matthew-_, indeed. that had a big influence on me chosing oxford.
14:22:01 <EvilTerran> wy, basically, you re-implement the prelude in first year
14:22:03 <dmhouse> matthew-_: I believe Cambridge do CL for compsci in the first year, although I might be misremembering.
14:22:07 <matthew-_> You know that the imperial rowing team regularly beats both cambridge and oxford rowing teams?
14:22:11 <jsnx> dmhouse: you're never wrong, but we're never sure if your statements actually apply:)
14:22:32 * Corun retracts previous sarcastic statement about importance of rowing
14:22:38 <Corun> Woo! Go imperial!
14:22:41 <matthew-_> Corun: you'll go far!
14:22:42 <wy> EvilTerran: good exercise :-)
14:23:02 <dons> pdxfunc meeting next Monday, btw, Portland people
14:23:08 <EvilTerran> but that's as far as it goes. monads're still considered deep magick
14:23:08 <tlaboc> Anyone in here go to university in the USA?
14:23:11 <dons> parser combinators will be the topic
14:23:21 <jsnx> well, not any more :)
14:23:34 <wy> Oh, I forgot ask about edingbour
14:23:49 <tlaboc> I was startingto think I was the only one from this side of the Atlantic...
14:23:52 <matthew-_> wy: edinburgh used to be ML, but I think, IIRC, they've just dropped it
14:24:13 <wy> matthew-_: Seems Wadler is there?
14:24:18 <EvilTerran> @seen sioraiocht
14:24:18 <lambdabot> I saw sioraiocht leaving #haskell-blah and #haskell 9h 55m 38s ago, and .
14:24:29 <fxr> dons: I hate missing those meetings, any planned video recordins?
14:24:37 <matthew-_> tlaboc: my understanding from my supervisor (which I don't really believe) is the that USA universities tend to be ML/Scheme, not Haskell
14:24:53 <Cale> If that.
14:24:57 <EvilTerran> sioraiocht's spending a year doing an MSc at oxford, but did his undergrad degree (and lives) somewhere in the US, iirc
14:25:02 <ricky_clarkson> Salford University, my employer, does no Computer Science in its Computer Science department.
14:25:07 <Corun> Why do places do ML rather than haskell?
14:25:10 <Cale> The situation is rather sad in those universities where there are coop programs.
14:25:15 <wy> matthew-_: USA universities tend to Java...
14:25:28 <monochrom> ML is just fine.
14:25:38 <MyCatVerbs> wy: USA? I think it's wider spread than that.
14:25:39 <Cale> Yes, Java, and other "practical" languages get used under pressure from coop companies.
14:25:40 <dons> fxr, not at this stage, afaik
14:25:40 <tlaboc> matthew-_: I know there's some Scheme coming for me next semester, but overall, things seem disappointingly imperative.
14:25:40 <matthew-_> wy: well, we do that here too. just it's not the only language that gets "taught"
14:25:45 <EvilTerran> Corun, because laziness is hard for people who're used to strict languages, i think
14:26:04 <monochrom> Plus, there is always this excuse "you can insert I/O operations anywhere you want, monad hurts my head, etc."
14:26:16 <Corun> Oh. So they wimped out?
14:26:18 <jsnx> when i left the university of iowa, they were switching to C# -- lots of money came from M$
14:26:18 <Corun> ^_^
14:26:33 <wy> matthew-_: We have ML too, or scheme for upper classes
14:26:39 <Cale> At Waterloo, they use ML exactly as much as they use Haskell, which is to say, not much.
14:26:56 <Cale> (they're both crammed into a "programming languages" course.
14:26:57 <Cale> )
14:27:11 <MyCatVerbs> wy: Bristol uni here in the UK teaches C, Haskell & Java in the first year, then alternates between mainly C and Java for coursework, with a few exceptions (AI unit, for example, uses Prolog).
14:27:16 <wy> matthew-_: But the atmosphere is largely Java, because most course projects are in Java, except those systems ones
14:27:17 <Cale> Fortunately though, there's a new track for undergraduates which uses scheme.
14:27:25 <Corun> An a tangential note, we had our first "Object Oriented Programming" lecture today :-D
14:27:27 <EvilTerran> i do find it interesting that cam.ac don't use haskell, actually, seeing as their new building is right next to MSR
14:27:46 <EvilTerran> you'd think SPJ could walk across the car-park and beat everyone with the report 'til they submitted
14:27:49 <tlaboc> Ah yes, the 'programming languages' course...that's where most variety is at my school too
14:27:57 <MyCatVerbs> wy: then there are projects here and there that we're allowed to use $arbitrary_language_of_choice for. Most people opt for Java when given these.
14:27:59 <wy> MyCatVerbs: Intheresting. I thought AI was in lisp
14:28:12 <Cale> We really shouldn't be aiming for industry adoption, but more for adoption by the education system, I think :)
14:28:25 <matthew-_> Corun: who's teaching that then?
14:28:25 <CosmicRay> Cale: which drives the other though?
14:28:28 <wy> MyCatVerbs: I've met people using C++ for AI class...
14:28:32 <tlaboc> One leads to the other though, I think...
14:28:40 <CosmicRay> Cale: where did the educational system get its desire to use Java, for instance?
14:28:42 <Cale> CosmicRay: Depends on where you live.
14:29:08 <wy> I guess ML is OK for the freshmen
14:29:10 <Cale> CosmicRay: Right. Anywhere that it's using Java, you can pre pretty certain that wasn't a decision made on an academic basis.
14:29:10 <Corun> Er, Sebastian Uchitel.
14:29:15 <Cale> be*
14:29:24 <matthew-_> CosmicRay: universities like to brag about their students getting jobs and getting paid lots of money.
14:29:27 <jsnx> CosmicRay: the business department presses for it
14:29:29 <wy> Cale: agree
14:29:32 <MyCatVerbs> wy: yes, I've met suicidal people too. ;)
14:29:36 <jsnx> CosmicRay: to train their MIS dudes
14:29:55 <jsnx> and if there are more MIS dudes than CS majors...
14:29:57 <Corun> He seems like a good lecturer. But, I'm not sure about the course ;-)
14:30:00 <matthew-_> CosmicRay: and eg Imperial gets quite a lot of money from banks in london because banks like snapping up imperial computing graduates
14:30:01 <MyCatVerbs> CosmicRay: it's relatively easy to use and widely used in industry.
14:30:04 <Cale> Waterloo has a big coop program, and so there's a whole lot of external pressure, which totally sucks.
14:30:05 <wy> MyCatVerbs: That's not hard, because they don't even implement A* search
14:30:11 <matthew-_> CosmicRay: so Java get's taught...
14:30:17 <Cale> gets
14:30:24 <jsnx> lolz
14:30:27 <MyCatVerbs> wy: ...what?
14:30:33 <tlaboc> When you start going for Java and that sort of thing though, universities start leaning dangerously toward being vocational institutes, not for higher learning...
14:30:36 <matthew-_> Cale: True
14:30:54 <wy> MyCatVerbs: The projects I saw is just some boolean satisfaction local search thing
14:31:24 <MyCatVerbs> tlaboc: people go for Java and that sort of thing *because* of the vocational use, though.
14:31:27 <matthew-_> tlaboc: well hang on there. Computing is hard because you can either try to teach theory or you can try to churn out good engineers. Doing both is pretty hard in a 4-year course
14:31:28 <jsnx> tlaboc: most universities are vocational
14:31:36 <wy> tlaboc: that's cornell...
14:31:46 <tlaboc> My school's CS department supposedly avoids offering anything like "software engineering" courses like the plague, so that no one gets the impression they are teaching for jobs
14:31:56 <jsnx> yeah, sure
14:32:00 <MyCatVerbs> wy: better than nothin, I guess.
14:32:10 <MyCatVerbs> *nothing, damnation.
14:32:21 <MyCatVerbs> tlaboc: where's this?
14:32:39 <tlaboc> MyCatVerbs: RPI, New York state
14:32:43 <jsnx> tlaboc: the professors aren't engineers themselves...it's an inefficient system
14:32:51 <jsnx> tlaboc: but it's the one we have got
14:32:55 <sarehu> tlaboc: I just graduated from there
14:33:07 <Cale> You can use Java as an implementation language and still mostly ignore the practicalities of programming in your courses. Of course, you'd have to question why you're doing things that way, but it can be done.
14:33:21 <matthew-_> yes, that what annoyed me most about our programming lecturing - the fact that it's highly unlikely any lecturer there has written any substantial program
14:33:27 <matthew-_> +'s
14:33:30 <tlaboc> sarehu: Huh, quite a coincidence -- usually people don't recognize the name otherwise, though
14:33:44 <wy> The only thing good about Java is it has eclipse
14:33:49 <sarehu> I do get that impression.  They do have "software design & documentation" though
14:33:52 <jsnx> most of my professors did all their programs in one big C file
14:34:14 <jsnx> in the middle of my graphics class, the prof switched to C++
14:34:23 <wy> jsnx: I've seen a one big Java file from a professor ;-)
14:34:27 <Corun> I dunno, what annoys me the most is that each lecturer slips in opinionated bits that advocate their favorite language/style/whatever as though those things are fact.
14:34:36 <Cale> wy: I was never all that impressed by eclipse -- some people seem to swear by it though.
14:34:37 <jsnx> he was quite perplexed/annoyed when i used make and one file for each class
14:34:41 <matthew-_> Corun: it's called "education"
14:34:55 <matthew-_> "the passing off of opinion as fact"
14:34:59 <opqdonut> eclipse is quite horrible
14:35:16 <jsnx> opqdonut: but aren't IDEs that way all around?
14:35:17 <wy> Cale: I really want to create an editor that really understand the langauge it's editing
14:35:17 <tlaboc> I guess my issue with the system is that many many CS majors should be taking something where they learn how to software-engineer, so that at least we end up with people good at their jobs
14:35:17 <Cale> Everything, to some extent, is opinion.
14:35:19 <opqdonut> too tight integration means i can't just swap the editor out if i don't like it
14:35:23 <opqdonut> jsnx: true
14:35:25 <matthew-_> If I'm writing Java, I vastly prefer eclipse to emacs or vim
14:35:42 <Cale> matthew-_: It seems to take a long time to load though.
14:35:48 <jsnx> tlaboc: i think they should all system administration, not 'software engineering'
14:35:57 <matthew-_> tlaboc: I have issues with the idea of "teaching" programming
14:36:00 * EvilTerran prefers to not write java :P
14:36:13 <Cale> I suppose the usage pattern is more that you'll remain in Eclipse the whole time.
14:36:19 <jsnx> once you learn how to distribute and secure a real system -- and have to read so much of other people's code -- then you really understand engineering
14:36:31 <matthew-_> programming is largely mental pattern matching. That comes from experience. It's not something that can be taught
14:36:43 <wy> opqdonut: But we can create a best editor ever so that nobody refuse it
14:36:46 <tlaboc> matthew-_: This all goes along with the general questionable nature of requiring CS degrees to get a programming job
14:36:55 <matthew-_> I think weekly labs that get more and more sophisticated and a strict line count limit is the way to go
14:37:05 <matthew-_> tlaboc: agreed
14:37:18 <Corun> What would you suggest as an alternative, Matt?
14:37:21 <jsnx> what is a suitable alternative credential, though?
14:37:35 <Corun> Oh
14:37:41 <Corun> Er, misread. Ignore me
14:37:46 <jsnx> well, personally, i would aim for physicists and mathematicicians
14:37:59 <jsnx> they can be trained
14:38:05 <jsnx> but they are so rare
14:38:19 <tlaboc> Either experience or some nonexistent better course of study
14:38:24 <kosmikus> many things that are taught at universities can only really be mastered by gaining experience
14:38:26 <wy> tlaboc: there are schools that CS is mainly theorectical. which one do you prefer? programming or complexity theories?
14:38:30 <kosmikus> that doesn't mean they shouldn't be taught
14:38:54 <sarehu> tlaboc: who did you have for prog lang?  I had Musser and we spent much of the class with Oz.
14:39:03 <matthew-_> I don't think that an expansive theoretical knowledge or training is required to be a good engineer
14:39:04 <axm_> aren't there on-the-job trainings for programmers without going to an university before in the US?
14:39:13 <tlaboc> wy: I think what I'm trying to say is that there are those two things, and that they should be distinguished between
14:39:15 <jsnx> axm_: no
14:39:26 <notsmack> axm_: you need the job first
14:39:39 <jsnx> axm_: you study on your own, and then find someone who really needs a sysadmin
14:39:55 <jsnx> (sysadmin is much more likely for a non-college grad)
14:40:10 <jsnx> because educated programmers hate system administration
14:40:14 <wy> I found that the so called theories are not actually fundamental theories. Programming is the fundamental thing in all sciences ;-)
14:40:16 <tlaboc> wy: As in, they should be separate degrees for learning theory and for learning engineering
14:40:21 <matthew-_> tlaboc: but completely separating them is going to further the divide between the "real world" and academia
14:40:30 <matthew-_> which isn't necessarily a good goal
14:40:37 <jfredett> if I have a function for which I've declared some fixity (say i declared infixl 6 foo) and I want to declare an alias with a different fixity (say infixr foo') is that possible without reimplimenting the function itself?
14:40:53 <Toxaris> jfredett: foo' = foo
14:40:54 <jsnx> tlaboc: there should be *math* degrees and *software systems* apprenticeships
14:41:10 <tlaboc> matthew-_: That's true too, but both halves of the field seem to get shortchanged the way it is now
14:41:34 <wy> jsnx: what about philosophy?
14:41:34 <jfredett> Toxaris: yes, foo' = foo, but I've tried just declaring foo' = foo and then declaring the fixity of foo' separate
14:41:37 <jsnx> basically, to go for CS you get a BA and math and take an apprenticeship
14:41:38 <jfredett> but it seems to not work
14:41:41 <notsmack> schools with separate CS and SE degrees do an ok job
14:41:55 <jsnx> wy: to be a philosopher, live in poverty for 7 years
14:41:58 <jsnx> wy: easy
14:42:12 <matthew-_> tlaboc: yes. I count myself an engineer first. Some of my supervisors and professors don't understand when I go mental at them for studying systems that they have no desire to implement or see the practical benefit of
14:42:16 <jfredett> jsnx: lol, that sounds like college + gradschool
14:42:17 * mrd graduated with a philosophy degree and took a low paying job over the last 7 years
14:42:39 <tlaboc> sarehu: I have ProgLang next semester, with I think "Goldschmidt"?
14:42:46 <wy> mrd: How does philosophy help you to understand Haskell?
14:43:04 <matthew-_> didn't monad originally come from philosophy?
14:43:04 <jsnx> wy: maybe because he took some set theory as part of it?
14:43:12 <Cale> matthew-_: Wrong monad.
14:43:13 <jsnx> matthew-_: no, category theory
14:43:13 <axm_> jsnx, that would rather narrow down the directions philosophers would be going. cannot imagine a new adam smith coming from that
14:43:19 <ricky_clarkson> He is the only one who knows what SPJ thinks when he closes his eyes during a talk.
14:43:20 <mrd> wy: well i can answer that facetiously or truthfully =)
14:43:26 <matthew-_> and then it got ruined by cat.theory. And then Haskell ruined it some more
14:43:30 <jsnx> axm_: the poverty would?
14:43:37 <axm_> wouldnt
14:43:38 <Cale> matthew-_: That word isn't really etymologically related to this sense of monad.
14:43:39 <mrd> wy: in fact, "philosophy" really means the study of logic and computation, so the overlap is plain
14:43:59 <matthew-_> Cale: ahh, ok
14:44:00 <MyCatVerbs> wy: easy. In philosophy, you keep writing new bullshit without ever scribbling over and manually deleting anything. In Haskell, you keep writing new data structures without ever manually scribbling over & deleting them. ^_^
14:44:00 <Cale> matthew-_: The monad from category theory is a portmanteau of "monoid" and "triad"
14:44:02 <jsnx> mrd: no, philosophy is the way of virtue
14:44:05 <byorgey> jfredett: it works for me
14:44:14 <jfredett> byorgey: maybe I should try it again
14:44:15 <jfredett> :/
14:44:23 <mrd> jsnx: whose philosophy?
14:44:28 <matthew-_> right, bed time. nn, gg, etc ;)
14:44:30 <Cale> matthew-_: The one from philosophy is almost directly from greek 'monas'.
14:44:38 <jsnx> mrd: yours
14:44:41 <hpaste>  byorgey pasted "different fixities for aliases" at http://hpaste.org/4858
14:44:50 <jsnx> mrd: you have to suffer to appreciate it
14:44:53 <axm_> jsnx, yes, but limiting philosophers to people who suffered from poverty as well limits the different views of these virtues
14:44:55 <dmhouse> Cale: in other words one where you have a neutral element, an associative multiplication, and vicious gang rivalries?
14:45:00 <jsnx> mrd: you can't go to school for philosophy
14:45:11 <MyCatVerbs> wy: hence philosophy helps you get over the hangup of, "how do I do useful work without ever scribbling over anything?" =)
14:45:18 * mrd ponders
14:45:19 <Cale> dmhouse: I'm not sure I get it :)
14:45:21 <jsnx> axm_: no
14:45:23 <mrd> well i have a B.S. in it
14:45:35 <monochrom> Hmm, vicious gang rivalries.
14:45:36 <MyCatVerbs> wy: (except that in philosophy you don't worry about the "useful" bit.
14:45:47 <Corun> I seem to remember that philosopher is literally, from the original greek "lover of wisdom" or something like that.
14:45:47 <jsnx> mrd: how do you get a bachelor of science in philosophy?
14:46:02 <mrd> it's lots of fun to say "B.S. in philosophy" let me tell you...
14:46:08 <jsnx> axm_: the poverty is their to refine whatever views you have coming in
14:46:14 <Cale> Not a B.Sc.?
14:46:34 <jsnx> axm_: people come from all different back grounds -- a few years of poverty will not erase that
14:46:38 <jfredett> byorgey, Toxaris: seems to work now, i must have typoed before, thanks guys
14:47:02 <mrd> jsnx: you go to a school which offers one
14:47:03 <dmhouse> "Triad societies, with a tradition of secret lore and initiation rituals dating back to the 17th century, have long dominated the underworld of Chinese communities around the globe. Based on sworn brotherhood and built on kinship, triads have been involved in a wide range of criminal activities."
14:47:10 <dmhouse> "Reputed to be among the most dangerous of organized crime organizations, triads prey upon Chinese communities, employing fear and intimidation tactics more often than physical violence. The triads stock-in-trade is smuggling, drug trafficking, and control over local bus routes, fish and produce markets, and karaoke bars."
14:47:11 <Cale> dmhouse: oh, right
14:47:22 <jsnx> mrd: my point is, it's a specious degree. you should reject it.
14:47:23 <dmhouse> Not really worth explaining.
14:47:26 <dmhouse> :)
14:47:33 <mrd> jsnx: why specious
14:47:36 <axm_> jsnx, so you are suggesting it is necessary to have ones virtues improved by poverty to have interesting views on it?
14:47:36 <monochrom> Oh! Triad! :)
14:47:37 <Cale> dmhouse: I'd completely forgotten about that sense of the word :)
14:47:47 <jsnx> axm_: to have well tested views
14:47:51 <axm_> ah
14:48:00 <Cale> I should perhaps explain that "triple" and "triad" were among the original words used to describe monads (T,eta,mu)
14:48:01 <mrd> jsnx: i'm sure if i pursued graduate studies in philosophy i'd be exposed to the ascetic lifestyle
14:48:04 <jsnx> axm_: any idiot rich person can believe "do what you love, the money will follow"
14:48:20 <Cale> Of course, they're bad names for an obvious reason.
14:48:26 <jsnx> mrd: no, because the ascetic lifestyle does not emphasize accomplishment
14:48:29 <mrd> jsnx: but i don't see the lifestyle choice being a necessity in order to study logic, math, and computer science. or maybe it is.
14:49:00 <jsnx> mrd: philosophy is not logic, math or computer science -- it is the love of *wisdom*
14:49:07 <jsnx> wisdom is born of experience
14:49:11 <Cale> and "monoid" wouldn't do, because it doesn't get across the specific kind of monoid object which a monad is, nor does it generalise in just the right way to 2-categories.
14:49:33 <Toxaris> Corun: yes, that's correct. philos = friend and sophos = wisdom. but philosopher in ancient greek meant something very broad, like "scientist" or maybe "thinker" means today.
14:49:37 <mrd> being poor and desperate doesn't tend to help you sharpen your logical thinking skills, afaict
14:49:51 <JanglerNPL> Why is "triad" a bad name?
14:50:08 <jsnx> mrd: it helps you reject your illusions -- and improves your empathy
14:50:18 <mrd> yea well that's all metaphysical zen garbage
14:50:19 <Corun> Oh, but, lover of wisdom _sounds_ cool.
14:50:25 <jsnx> mrd: lolz
14:50:27 <Cale> Well, it focuses on something kind of irrelevant about the definition -- that there are three parts to it.
14:50:35 <Toxaris> mrd: maybe being poor but not desperate does?
14:50:43 <mrd> jsnx: you're out of date. philosophers stopped caring about that stuff a century ago or so
14:50:53 <jsnx> mrd: why is that zen? why is it garbage?
14:51:14 <jsnx> mrd: philosophers stopped being philosophers and became academics
14:51:14 <ricky_clarkson> mrd: Does thought have a sell-by date?
14:51:22 <jsnx> mrd: you are out of touch
14:51:25 <mrd> no, they just realized that it's all full of shit
14:51:37 <EvilTerran> it's zen because there's a stereotype of zen buddhists giving up all their worldly posessions on their road to enlightenment
14:51:51 <monochrom> thought has a sell-by date.
14:51:52 <mrd> see The Elimination of Metaphysics Through Logical Analysis of Language, Carnap.
14:51:53 <EvilTerran> it's garbage 'cos that's what you're gonna end up digging through for food if you take that path ;)
14:51:54 <ricky_clarkson> I gave up my Java IDE on that road.
14:51:57 <jsnx> EvilTerran: yeah, but every ascetic does that
14:52:18 <EvilTerran> jsnx, so he was less polymorphic than he could've been. meh.
14:52:36 <mrd> also, History of Western Philosophy, Russell, does a pretty good job of picking apart most arguments of western philosophers
14:52:59 <jsnx> mrd: if you want a degree in mathematical logic, why not study in math?
14:53:08 <jsnx> mrd: i don't see what philosophy has to add
14:53:19 <mrd> it's a possibility.  but the program here is in the philosophy dept.
14:53:57 <jsnx> EvilTerran: as for 'picking through garbage' -- plenty of people do that without accumulating any insight, and plenty of monks do without it
14:54:00 <monochrom> Many logicians work under the philosophy department. Not necessarily any overlap with other colleagues in the same department.
14:54:02 <axm_> jsnx, I still would not say poverty is a requirement to do philosophy, but I could live with misery in general, cause without problems there is probably no reason the think about them.
14:54:14 <EvilTerran> jsnx, allow me to draw your focus to a specific part of that line
14:54:16 <jsnx> axm_: no, misery means you are failing
14:54:24 <monochrom> (Other colleagues would be working on philosophy of science, realism, existentialism, ...)
14:54:27 <EvilTerran> jsnx, "<EvilTerran> ... ;)"
14:54:27 <axm_> let me look the word up
14:54:56 <jsnx> anyways, wisdom is for hitler
14:55:01 <jsnx> i'm done with this discussion
14:55:11 <Valodim> what a way to end it
14:55:18 <Valodim> a = hitler
14:55:31 <monochrom> No, here you have to get to a pointfree style to end a discussion.
14:55:32 <jsnx> deutschland, deutschland, uber alles, uber alles in den welt
14:55:32 <axm_> it is does not equal failing for me, but lets say "struggeling", that should fit
14:55:57 <mrd> ?pl \ x y -> out y x
14:55:57 <lambdabot> flip out
14:56:10 <Valodim> in der welt
14:56:25 <EvilTerran> ?pl \x -> hands x x
14:56:26 <lambdabot> join hands
14:56:28 <jsnx> deutschland, deutschland, uber alles, uber alles in der welt
14:56:42 <jsnx> Valodim: sorry, i haven't spoken german in years...
14:56:44 <Valodim> yeah add that umlaut and you've got it
14:57:03 <jsnx> utf8 will anger some of the IRC clients on the channel
14:57:19 <mrd> it's in extended ascii
14:57:19 <monochrom> utf8 is very well accepted in this channel.
14:57:20 <Valodim> they'll manage :P
14:57:24 <Valodim> that, too
14:57:24 <jsnx> EvilTerran: lolz
14:57:37 <monochrom> some don't see it, but they don't complain.
14:58:04 <jsnx> actually, i don't remember how to do with SCIM...
14:58:34 <monochrom> Unlike some other 19th century channels. "Use ascii because I'm among that 1% of the world who can't do anything else!"
14:58:56 <EvilTerran> ?pl (\x:_ -> x) off
14:58:57 <lambdabot> head off
14:59:00 <EvilTerran> okay then
14:59:26 <monochrom> Just note, lambdabot doesn't do utf8 very well yet, that's all.
14:59:26 <Cale> If you're using X, I find it's nice to rebind caps lock to be a compose key.
14:59:36 <Valodim> he doesn't?
14:59:38 <Valodim> why not?
14:59:39 <mrd> i use it for ctrl
14:59:40 <Cale> Then Compose u " -> Ã¼
15:00:04 <EvilTerran> if you're on windows, autohotkey can be used to the same end
15:00:06 <EvilTerran> @go autohotkey
15:00:07 <lambdabot> http://www.autohotkey.com/
15:00:07 <lambdabot> Title: AutoHotkey - Free Mouse and Keyboard Macro Program with Hotkeys and AutoText
15:00:11 <monochrom> Still using putStr and getChar etc., which are still iso-8859-1.
15:00:11 <mrd> that useless windows menu key might do it though
15:00:13 <Valodim> ?pl (\Ã¼ -> Ã¼+Ã¼)
15:00:13 <lambdabot> join (+)
15:00:23 <Valodim> at least extended ascii works
15:00:45 <mux> @pl \¤ -> ¤
15:00:46 <lambdabot> (line 1, column 2):
15:00:46 <lambdabot> unexpected "\164"
15:00:46 <lambdabot> expecting pattern
15:01:10 <EvilTerran> that one's not counted as alphanumeric, i guess
15:02:08 <monochrom> > Data.Char.isAlpha 'Ã¼'
15:02:08 <lambdabot>  Improperly terminated character constant at "'Ã¼'" (column 19)
15:02:12 <mrd> monochrom: ah yea, so we determined that haskell src utf8 was ok but putStrLn did not output it right?
15:02:12 <axm_> @pl \_-> "Ã¼"
15:02:13 <lambdabot> const "\195\188"
15:02:22 <monochrom> Right.
15:02:29 <Valodim> duh
15:03:26 <jsnx> mrd: i've never been able to get putStrLn to output it right
15:03:34 <jsnx> i use utf8-string
15:03:55 <jsnx> and System.IO.UTF8.putStrLn
15:04:23 <mrd> ã
15:04:34 <jsnx> what is that?
15:04:41 <mrd> hiragana ko
15:04:43 <monochrom> Japanese
15:04:59 <jsnx> lolz japanese
15:05:02 <mrd> at least, that's what i think i typed, since this terminal won't show UTF8
15:05:21 <Saizan> that's it
15:05:24 <mrd> utf8-string, is that in hackage
15:05:35 <monochrom> Yes.
15:05:55 <mrd> nice
15:06:12 <Valodim> ã
15:06:13 <tlaboc> I saw a Japanese character
15:06:18 <Valodim> hm, yeah doesn't display for me either
15:06:20 <Valodim> not in the font
15:06:23 <tlaboc> It's definitely working all right
15:06:28 <tlaboc> for me
15:07:24 <mrd> sweet, works
15:07:35 <jsnx> f : A â B
15:08:22 <gvdm> works for me
15:08:44 <gvdm> but I've had my whole system pretty much utf from word go
15:09:19 <jsnx> f : a
15:09:32 <jsnx> f : a
15:09:35 <jsnx> oops
15:09:49 <jsnx> f : a â¦ 2a
15:10:01 <jsnx> scim is funny sometimes
15:10:44 <Cale> å²ç¢
15:10:51 <jsnx> Cale: lolz
15:10:54 <jsnx> chinese
15:12:32 <mrd-> ãã¹ã±ã« "hasukeru"
15:12:45 <ddarius> æ¥æ¬èª
15:12:46 <Cale> æ¥æ¬èª
15:12:50 <mrd-> good work
15:13:04 <ddarius> Internationalized stereo now.
15:13:13 <dons> awesome
15:13:18 <Cale> ã¸ã³ã¯ã¹ï¼
15:13:23 <wy> ä½ å¥½
15:13:35 <wy> åäº¬æ¬¢è¿æ¨
15:13:44 <dons> Ã£Â¸Ã£Â³Ã£Â¯Ã£Â¹Ã¯Â¼ ä½ å¥½Ã¥äº¬æ¬¢Ã¨Â¿Ã¦
15:13:53 <jfredett> ...
15:13:55 <dons> ascii man to the rescue!
15:13:59 * MyCatVerbs is looking at a whole load of \u30b7, \u30f3... ^_^
15:14:14 <jfredett> holy crapnitz, batman, since when was this #haskell-azn ?
15:14:24 <dons> > ['\0' .. ]
15:14:25 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
15:14:42 <jsnx> lolz lambdabot
15:14:43 <MyCatVerbs> @hoogle Int -> Char
15:14:43 <lambdabot> Data.Char.intToDigit :: Int -> Char
15:14:43 <lambdabot> Data.Char.chr :: Int -> Char
15:14:43 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
15:15:09 <mrd-> is åäº¬ beijing in chinese too?
15:15:21 <jsnx> > System.IO.UTF8.putStrLn "ä½ å¥½"
15:15:21 <lambdabot>   Not in scope: `System.IO.UTF8.putStrLn'
15:15:34 <Valodim> haha
15:15:41 <MyCatVerbs> jsnx: what library is that?
15:15:52 <Cale> ä½  shows up as horribly mangled in the font I'm using.
15:15:57 <resiak> is there a canonical faq for wrapping C libraries in Haskell?  in particular, what needs to be done to let a reference to a haskell data structure be stored in a void * in a C struct?
15:16:16 <jsnx> utf8-string
15:16:21 <ddarius> resiak: Read the FFI addendum to the Report.
15:16:36 <jsnx> Cale: but the other one is okay?
15:16:41 <jsnx> Cale: how is it mangled?
15:16:58 <Cale> yeah, it just shows up as a few dots
15:17:03 <mrd> weird. some of these characters are actually showing up in my non-UTF8 terminal
15:17:09 <ddarius> @where ffi
15:17:09 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
15:17:14 <Cale> It's okay with a larger font size. Some problem with hinting, most likely.
15:17:45 <MyCatVerbs> jsnx: thanks. Yay for hackage. ^_^
15:18:06 <resiak> ddarius: sure, got it.  thanks!
15:19:05 <Cale> hmm, I wonder...
15:19:29 <resiak> oh, this is the point of stableptrs!
15:19:32 <Cale> ä¼·ä¼¹ä¼»ä¼¾ä½ä½ä½ä½ä½ä½
15:20:02 <Cale> all of those get mangled, it seems I need a better font for some subset of the CJK characters
15:20:30 <jsnx> Cale: i can read them
15:20:36 <ricky_clarkson> They work for me in putty in Windows.
15:20:48 * dmhouse hasn't found a character for which the standard Gnome Monospace font won't handle yet.
15:20:59 <dmhouse> It's pretty, too.
15:21:16 <jsnx> i
15:21:20 <jsnx>  am using terminus
15:21:22 <Cale> dmhouse: There are lots of things which it doesn't have, but FreeType will pull in characters from other fonts on your system wherever there are gaps.
15:21:27 <ddarius> dmhouse: What's the standard gnome monospace font?
15:21:39 <dmhouse> Cale: oh, okay, that's nice of it :)
15:21:44 <dmhouse> ddarius: "Monospace".
15:21:54 <dmhouse> (No idea what it actually is.)
15:21:57 <monochrom> using "virtual font" or something like that, "monospace" is a union of many fonts.
15:22:29 <bos> it's usually bitstream vera sans mono.
15:22:34 * ddarius uses Bitstream Vera Sans Mono Bold 12 for xchat.
15:22:37 <monochrom> For example see /etc/fonts/fonts.conf
15:22:44 <dmhouse> http://imagebin.org/12846 that one
15:22:44 <lambdabot> Title: Imagebin - A place to slap up your images.
15:22:48 <Cale> I use Andale Mono, for the most part.
15:22:48 <bos> @quote stereo
15:22:48 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
15:23:00 <Cale> (via msttcorefonts)
15:23:32 <hpaste>  Corun pasted "Echo Server, one liner!" at http://hpaste.org/4861
15:24:05 <Corun> I'm sure it could be neater, though.
15:24:19 <monochrom> It's good enough.
15:24:20 <ddarius> Haskell: Where One-Liners Aren't Good Enough
15:24:48 <dmhouse> Haskell: Where Every Program Is A One-Liner (At Least Theoretically)
15:24:51 <Cale> Heh, kind of a funny one liner :)
15:25:27 <monochrom> I am not too keen on line count. I believe more in tokens.
15:25:28 <Cale> You must have a rather wide screen :)
15:25:30 <jsnx> Corun: that's at least 8 lines
15:25:39 <monochrom> You can't cheat on token count.
15:25:54 <oerjan> @quote stereo!
15:25:54 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
15:26:39 <monochrom> Actually, I believe no one intends to cheat. More likely, it's too subjective how much or how little to put on one line.
15:27:02 <jsnx> monochrom: well, couldn't we just make it so lines longer than 80 chars don't parse?
15:27:24 <Corun> (Ya see, a friend and I are having a, mostly for fun, language war
15:27:25 <jsnx> and ban tabs, while we're at it...
15:27:30 <Corun> He's doing erlang, ya see
15:28:49 <monochrom> If you need three >>='s then you need three >>='s. That is objective. Some people opine you can put them all in one line, other people opine you should never do so. That is subjective, and causes up to a 3X discrepancy in opinions. That is a very significant subjectivity.
15:29:33 <jsnx> monochrom: i agree
15:29:45 <jsnx> but the tokens to count from langauge to language is a problem
15:30:17 <jsnx> maybe we should just count chars instead
15:30:38 <Toxaris> jsnx: what's the point of comparing programming languages by length of the programs written in them?
15:31:06 <jsnx> Toxaris: the defect rate changes non-linearly with length -- that's the folk lore, anyway
15:31:44 <Toxaris> I would like to propose a new programming language with only a single token. the token is the empty program, and it's meaning is "an echo server". my language wins.
15:32:08 <TSC> No free lunch!
15:32:12 <jsnx> Toxaris: you'd lose on all the other benchmarks, though
15:32:42 <jsnx> Toxaris: did i answer your question? you at least see why people do it, even if you don't agree?
15:32:46 <Cale> My language is exactly like Haskell except that an empty program acts as the echo server.
15:32:46 <monochrom> George Russell's http://groups.google.com/group/comp.lang.functional/msg/2eb8df3cb49c789b and my reply http://groups.google.com/group/comp.lang.functional/msg/17520bdd236b3351 show how totally anti-podal opinions can be on line count.
15:32:47 <lambdabot> Title: Haskell98 - Where it used ? (example of use) - comp.lang.functional | Google Gro ..., http://tinyurl.com/2w9ncl
15:33:14 <Toxaris> jsnx: I see why people do it.
15:33:33 <monochrom> That one is an extreme case. 5X difference in opinion. Totally opposing "too hard to grasp" vs "what's so hard to grasp?"
15:33:42 <jsnx> monochrom: lolz
15:34:18 <Toxaris> jsnx: I see why programs in the same language can be compared by length.
15:34:23 <ddarius_> > let f :: Show a => Int -> a -> String; f 0 x = show x; f (n+1) x = f n (x,x) in f 3 'a'
15:34:24 <lambdabot>  Parse error in pattern at "in" (column 78)
15:34:31 <monochrom> Perhaps not so much on line count. That debate was how much you should cram into one line.
15:34:35 <Toxaris> jsnx: And I see why Haskell is a good language because it enables programmers to write concise programs
15:34:42 <jsnx> Toxaris: oh, good
15:34:47 <jsnx> go haskell!
15:35:05 <jsnx> w
15:35:14 <jsnx> eh, sorry -- thought i was in vim
15:35:46 <Toxaris> jsnx: but I don't see how this can be seen from the comparison of a finite sets of programs, written by arbitrary programmers with an arbitrary set of libraries
15:36:07 <mux> is there a parsing package based on applicative functors somewhere?
15:36:27 <ddarius> > let f :: Show a => Int -> a -> String; f 0 x = show x; f n x = f (n-1) (x,x) in f 3 'a'
15:36:27 <jsnx> Toxaris: may i just say "hitler" to that?
15:36:29 <lambdabot>  "((('a','a'),('a','a')),(('a','a'),('a','a')))"
15:37:16 <Cale> ddarius: Interesting example!
15:37:32 <Toxaris> jsnx: I would prefer: "shut up, nobody cares, and it was discussed in -cafe recently"
15:37:53 <monochrom> jsnx: Responding to another point you raised. Yes, token count isn't robust across different languages. That can't be helped. Inside the same language, token count is pretty robust, that's what I like.
15:38:23 <dons> interesting,
15:38:28 <dons>   http://hackage.haskell.org/cgi-bin/hackage-scripts/package/i18n-0.1
15:38:29 <lambdabot> http://tinyurl.com/34ea4x
15:38:32 <Cale> ddarius: It almost doesn't seem like that should be possible :)
15:38:34 <dons> The i18n package (version 0.1)
15:38:35 <dons> Internationalization for Haskell based on GNU gettext.
15:40:58 <jsnx> Cale: why shouldn't it be possible?
15:41:10 <jsnx> i do not appreciate it's subtlety
15:41:11 <Cale> Curious how "Hitler" is slowly being transformed from a name of evil into a sound which is used to end conversations.
15:41:12 <dons> http://programming.reddit.com/info/64tfx/details just because i think this kind of stuff is going to be useful
15:41:20 <jsnx> ack
15:41:24 <jsnx> i can no longer speak
15:41:28 * jsnx melting
15:42:14 <jsnx> dons: upmodded because you are on #haskell
15:42:32 <Cale> jsnx: The polymorphic recursion. Arbitrarily many types may be involved in the evaluation of f.
15:42:44 <dons> jsnx: heh
15:43:07 <conal> mux: you can use AF style in any monadic parsing package
15:43:09 <ddarius> Cale: Why not?  (That said, most languages don't support it.)
15:44:05 <Cale> ddarius: Well, of course it is possible, but usually one thinks of types as purely compile time things, and yet here the types involved in the computation of f are dependent on the value of n at runtime.
15:45:02 <Toxaris> Cale: are they?
15:45:13 <Cale> Toxaris: yes.
15:46:31 <Cale> Toxaris: The larger the value of n, the more deeply nested the pairs will become before having show applied.
15:47:05 <Cale> And so there are essentially infinitely many different types which might become involved in the computation of f.
15:47:45 <Cale> But since they're all instances of Show, it's fine.
15:49:11 <Toxaris> Cale: If I think about the Core equivalent of this code, this becomes quite clear. for the polymorphic recursive call, a new value (of a new type) is created, and a new Show dictionary is created using the instance Show a, Show b => Show (a, b) dictionary-creation-function.
15:49:25 <Cale> right
15:50:20 <glguy> ?seen shapr
15:50:20 <lambdabot> shapr is in #haskell-blah, #scannedinavian and #haskell. I last heard shapr speak 11h 3m 59s ago.
15:51:20 <dons> omg. http://programming.reddit.com/info/64th1/comments/
15:51:25 <dons> Monads, in Python, in production code! -- "you can and should use monads in your code"
15:52:45 <MyCatVerbs> ...what?
15:52:47 <Toxaris> Cale: still, I wonder in wich way these types "become involved" in the computation. f has an polymorphic type, and the type of the expressions forming f depend on the type choosen at the callsite -- as usual for polymorphic functions
15:53:19 <bos> dons: wow, that's demented
15:53:48 <Toxaris> I'm therefore at ease with this funny term, as long as I don't think about it's denotational semantics. mentally taking a fixed point of this polymorphic recursion is too much :(
15:55:18 <ddarius> Guido is rolling over in his grave!
15:55:37 <LoganCapaldo> I don't see how call/cc gives you elegant syntax for monads
15:55:37 <lambdabot> LoganCapaldo: You have 1 new message. '/msg lambdabot @messages' to read it.
15:56:11 <Cale> Guido is dead?
15:56:32 <monochrom> I can haz monads!
15:57:14 <MyCatVerbs> Cale: heart attack at reading that article, perhaps. :)
15:57:31 <MyCatVerbs> dons: I'd certainly rather use that as a library than write it myself, heh.
15:58:49 * LoganCapaldo would honestly rather see bind(x, f) than this weird (ab?)use of generators he's got going on
15:58:57 <monochrom> Every idiom can be librarised and cabalised. No? Oh, you mean Python not Haskell.
15:59:11 <bos> wow, augustss's code uses even more type hackery than mine.
16:00:31 <monochrom> Hahaha. "I'm just parsing a file!"  Yes, you should just use a moand, and you made the right choice! :)
16:02:40 <ricky_clarkson> Some people, when confronted with a problem, think "I know, I'll use monads".  Now they have no problems.
16:03:29 <ndm> when your tool of choice is a hammer, everything looks like a thumb
16:03:32 <LoganCapaldo> lies :)
16:06:03 <monochrom> when your tool of choice is taste, everyone looks tasty! :P
16:08:48 <dons> so i'm unsure whether this kind of thing is good or bad.
16:08:56 <monochrom> Yikes, now I need to learn bidirectional generators.
16:09:17 <dons> i can only think that more exposure to monad stuff helps haskell, but sometimes other feature adoption dilutes the reasons to use haskell.
16:09:28 <dons> think what happened to smalltalk
16:09:32 <dons> or lisp.
16:10:07 <monochrom> The original "yield" generator was said to be less powerful than continuation (or delimited continuation). Perhaps bidirectional generator fills the gap?
16:10:22 <dons> they're so innovative :)
16:11:31 <monochrom> Every program evolves to include an email MUA. Every language evolves to expose continuations?
16:11:45 <ddarius> dons: People don't come to Haskell for monads.
16:11:53 <dons> right. so i don't think that hurts.
16:12:03 <dons> it just lowers the barrier to entry if you find them elsewhere
16:12:09 <dons> like people to go to lisp for closures.
16:12:13 * LoganCapaldo came for the list comprehensions but stayed for the company
16:12:15 <dons> s/dont'/
16:12:40 <monochrom> A human brain is large enough to hold ten or twenty programming languages, don't worry.
16:12:54 <dons> so people really do go to erlang for distribution and fault tolerance. and haskell for well, what, correctness, and hopefully multicore in the next few years.
16:12:59 <monochrom> Haskell and Python don't need to compete. They can easily win together.
16:13:00 <BMeph> Haskell: The come for the lambdas. They stay for the monads. ;)
16:13:08 <dons> (i.e. the banks, galois, aetion, all about correctness)
16:13:25 <sarehu> personally, I came because I wanted to see what this toy interpreted language was all about
16:13:35 <dons> and no matter how many monad you add to python, its not going to be high assurance any time
16:13:40 <dons> sarehu: hah
16:14:10 <dons> ruby, you mean? :)
16:14:18 <ndm> i came for the lambdas, and stayed for them - monads really are still second class programming in Haskell
16:14:54 <Valodim> what
16:14:58 <dons> i came for the lambdas, and stayed for the type system and optimiser
16:15:33 <Valodim> I came for.. uh, nothing in particular about haskell, more about the boringnes of other languages
16:15:42 <ndm> i stayed for hindley milner, type classes, lazy evaluation and equational reasoning as well
16:16:00 * cjay came because I wanted to find out about that weird language the icfp winning teams were using :)
16:16:04 <dons> yeah, i love f . g == id tests
16:16:11 <dons> cjay: interesting
16:16:23 <ndm> if only we had functional equality :)
16:16:31 * LoganCapaldo has never actually sed equational reasoning on a haskell program (at least not consciously)
16:16:39 <LoganCapaldo> but it's nice to know I could if I wanted
16:16:49 <dons> i presume you refactor sometimes, LoganCapaldo ? :)
16:16:50 <ndm> i also hope i'll be staying for the equational reasoning theorem prover at some point...
16:16:52 <BMeph> cjay: Thirsty for Functional Beer? ;)
16:16:59 <ndm> LoganCapaldo: you do, you just don't realise with Haskell
16:17:53 <cjay> BMeph: I didn't admire functional languages at that time, was just curious
16:17:58 <ddarius> ndm: Switch to Clean?
16:18:17 <ndm> ddarius: for Sparkle?
16:18:25 <ddarius> ndm: Among other things.
16:18:31 <dons> but we have Dazzle! :)
16:18:41 <ricky_clarkson> I came for the static typing, to see how good it could get.
16:19:14 <hpaste>  oxy pasted "xmonad.hs" at http://hpaste.org/4863
16:19:14 <ndm> dons: not heard of it...
16:19:46 <dons> ndm, oh, its a graph drawing system from utrecht, written in haskell. used in some commercial project (iirc)
16:19:50 <ndm> oh, yeah, i have
16:20:01 <ndm> i've also seen blobs, which was based off it
16:20:09 <dons> yep
16:20:35 * ndm gets the feeling he may have to write the Haskell theorem prover...
16:20:55 <basti_> like "coq"?
16:20:58 <dons> well, at least a fullish haskell model in isabelle or Coq
16:21:10 <dons> would be more useful (you can build on others work then)
16:21:18 <dons> these are starting to appear
16:21:19 * ndm remembers he has actually started that project - too many projects, too little brain
16:22:44 <cytzol> this pasta > *
16:22:48 <shapr> @yow !
16:22:49 <lambdabot> We are now enjoying total mutual interaction in an imaginary hot tub ...
16:22:51 <cytzol> ...eh, wrong server, sorry.
16:24:03 <jfredett> okay- kindof a meta-haskell question, I've been working on a Directed Acyclic Graph Library, and I was wondering about two things- 1) has anyone already done this (I looked in the FGL library, it doesn't really do an implementation of DAG) and 2) would anyone possibly ever want to use it, I ask because write now, its basically a hack (though I got the Show instance to dump graphviz output, which is cool) and If someone might wa
16:24:08 <jfredett> sorry for the long message, btw
16:24:09 <jfredett> :)
16:24:37 <cjay> it was cut by the server "..someone might wa"
16:24:45 <jfredett> oh- hmm
16:25:07 <jfredett> "If someone might want to use it, I'll try to clean it up and release it, but otherwise, I'll probably just leave it in its hackish state."
16:25:11 <jfredett> sorry
16:25:52 <ndm> someone may want it
16:25:59 <dons> i think it could be wanted, yep
16:26:03 <jfredett> okay
16:26:07 <dons> graphs come up once a fortnight here
16:26:15 <jfredett> i just wanted to make sure it was worth cleaning up
16:26:34 <jfredett> because it looks like a 2$ whore after a long night of working right now...
16:26:35 <waern> is it just me or is there waaay too little haskell stuff on planet.haskell.org?
16:26:50 <dons> waern: mm. someone else mentioned that.
16:27:01 <dons> we need to kick this scala pr guys some lambdas
16:27:04 <dons> ?users #scala
16:27:05 <lambdabot> Maximum users seen in #scala: 71, currently: 66 (93.0%), active: 6 (9.1%)
16:27:59 <jfredett> i can has hasktivism?
16:28:26 * BMeph thinks SuDoKu is a Master Plan to get Haskell programmers into equational reasoning...
16:28:37 <jfredett> BMeph: lol
16:28:41 <waern> well, there's not just scala. there's also food, babies and santa claus
16:29:14 <jfredett> waern: problem is they index whole blogs, which for some people are not strictly about Haskell
16:29:28 <dons> i think the editorial guide is that you can write about anything, if you're a haskell person
16:29:30 * LoganCapaldo doesn't see the appeal of sudoku, seems so mechanical
16:29:53 <jfredett> LoganCapaldo: it is, but it makes people feel smart, cause it has numbers
16:30:13 <ddarius> waern: The purpose of Planet Haskell isn't to display Haskell stuff.
16:30:45 <waern> but who wants to read non-haskell stuff from haskell people? :)
16:31:11 <ddarius> waern: Read http://planet.haskell.org/policy.html
16:31:12 <lambdabot> Title: Membership policy - Planet Haskell
16:31:15 <BMeph> Haskell people without enough projects? ;)
16:31:28 <ddarius> waern: If you don't want to read it, don't.
16:31:56 <resiak> Currently, hfuse doesn't expose any way to keep mutable state.  libfuse itself has a void* in the contex struct that the application is meant to use to keep its state.  From reading the FFI addendum, it seems like I should be storing a StablePtr (MVar a) in it, and either make each Fuse callback have type ... -> StateT IO a b where the state ends up being read from and written to the MVar, or just have a function to let the callbacks retrieve the ...
16:32:02 <resiak> ... MVar if they want it.  Am I on the right lines?
16:32:38 <dons> it seems like a good idea to do the thread safety on the haskell side, anyway
16:33:35 <resiak> Yeah, the other thing that occured to me is to ignore the void* in the context and do the state entirely in Haskell
16:34:13 <waern> ddarius: I understand the policy, it's just that I think most people read planet.haskell.org for the haskell stuff
16:34:33 <ddarius> waern: I don't read it just for the Haskell stuff.
16:36:55 <ddarius> In fact, I would say about half or probably more of the posts I find interesting are not particularly Haskell related.
16:37:41 <dons> so who're the python guys going to go to, to help them do monads ? :)
16:37:49 <dons> anyone want a python-fp consultancy gig :)
16:38:14 * byorgey agrees with ddarius
16:38:49 <dons> i enjoy watching the pain of others in the python and scala entries
16:39:12 <ddarius> "How can we implement Haskell in ...?"
16:39:36 <byorgey> I think I'll go write a blog post on implementing monads in assembly
16:39:42 * ddarius remembers when Martin Odersky and co. first announced Scala.
16:39:58 <ddarius> byorgey: It would be easier than in some languages.
16:40:08 * Pseudonym likes Martin Odersky
16:40:08 <byorgey> ddarius: lol, so true. =)
16:40:11 <Pseudonym> He's a nice guy.
16:40:18 <waern> hm, okay then... perhaps I am in the minority
16:40:30 <Pseudonym> The Mercury group had some great conversations with him.
16:40:50 <dons> its funny watching all the researchers who grew up on haskell, go out and mess up^h^h^h add lovely features to Java, C#, Scala, et al :)
16:41:10 <Pseudonym> It's like SPJ said.
16:41:20 <Pseudonym> They're making "dirty" languages cleaner.
16:41:31 <dons> we need to get some more ex-haskell committee people into the dynamic language camp
16:41:32 <Pseudonym> Everyone is heading towards useful and clean.
16:41:37 <Pseudonym> Or useful and beautiful.
16:41:40 <dons> slowly, yeah.
16:41:45 <Pseudonym> We're heading there from the "beautiful" direction.
16:41:51 <Pseudonym> They'er heading there from the "useful" direction.
16:41:57 <dons> and there's nowhere else to go for new language features, basically
16:42:06 <mrd> if you use dirty languages like J*va do you have to wash your computer out with soap afterwards?
16:42:17 <Pseudonym> mrd: Just your brain, I suspect.
16:42:18 <ddarius> mrd: I highly recommend it.
16:42:25 * oerjan wouldn't recommend it.
16:42:35 <dons> mrd, no, you go buy wadler's book on java generics, cry a little bit, then come running over to #haskell
16:42:46 <byorgey> mrd: don't use soap, use a big magnet
16:43:04 <mrd> i didn't need a book for generics to make me cry
16:45:14 <ddarius> While Haskell wasn't intended to be -just- a research language, research was certainly one of its goals.  That the ideas now make there way to other language is success of a type that even Haskellers can get behind.
16:45:53 <dons> yeah, though its double-edged.
16:46:08 <byorgey> dons, how so?
16:46:10 <dons> i'm more of the embrace, extend, extinguish kind of guy in this respect, i must admit :)
16:46:37 <BMeph> Don Stewart: FP Commando! >;)
16:46:45 <dons> since i'd like not to have to do my monads with "self.run(lambda val"
16:46:49 <ddarius> dons: We can't embrace and extend if we are the fore-runner.
16:47:42 <MyCatVerbs> Crikey on a stick, the user list here is bloody lon.
16:48:14 <dons> ddarius: i just worry about what happened to smalltalk and lisp. though i don't see research going anywhere soon, which is something lisp and smalltalk lost long ago. so we'll stay a forerunner, even as the features developed in the 90s make their way out
16:48:19 <MyCatVerbs> *long. Also, my hands are cold, which is making me emo. (//_o)
16:48:22 <LoganCapaldo> does crikey on a stick taste good?
16:48:32 <dons> ?userss
16:48:33 <lambdabot> Maximum users seen in #haskell: 439, currently: 413 (94.1%), active: 21 (5.1%)
16:48:53 <MyCatVerbs> LoganCapaldo: probably not, though I suppose it'd be worth a try.
16:49:03 <byorgey> LoganCapaldo: doesn't sound like it.  Although I'm not sure what 'crikey' is.  maybe dons would know =)
16:49:15 <dons> streuth!
16:49:20 <dons> byorgey: you in OR yet?
16:49:31 <byorgey> dons: heh, I wish =)
16:49:33 <dons> pdxfunc is next Monday, we'll be doing beer and parser combinators
16:49:43 <byorgey> dons: not for a few weeks yet, I think
16:49:43 <mrd> is that a new drinking game
16:49:47 <dons> ok.
16:49:51 <dons> mrd, that's right!  :)
16:49:56 <dons> you get a type error, you lose
16:49:58 <byorgey> dons: sounds like fun, I'll be sad to miss it
16:50:03 <keseldude> ?seen davidL
16:50:03 <lambdabot> I saw davidL leaving #xmonad and #haskell 18h 37m 13s ago, and .
16:55:57 <ddarius> dons: Stories of either Smalltalk's or Lisp's demise are greatly exaggerated.
16:56:34 * dibblego chuckles at "greatly exaggerated" :)
16:57:22 <ddarius> I'm pretty sure Haskell has long since reached the point where it will live forever.
16:57:47 <dons> ddarius: their loss of influence + failure to make commercial inroads. :) maybe that's haskell's fate too though. unless we can get some more multicore hardware...
16:58:05 <dons> i want a 16 core laptop already! hurry up!
16:58:12 <dons> these `par`'s won't run themselves
16:59:16 <LoganCapaldo> i was under the impression that what success smalltalk had was largely commercial
16:59:31 <dons> until java
16:59:59 <shapr> dons: I may end up with an 8-core dual-quad box soon...
17:00:16 <pjd> dons: markdown in IRC?
17:00:35 <dons> oh, weird, pjd. i guess that was in my spinal memory.
17:00:41 <dons> i comment on reddit too much :)
17:00:44 <pjd> heh
17:01:21 <oerjan> @users
17:01:21 <lambdabot> Maximum users seen in #haskell: 439, currently: 412 (93.8%), active: 16 (3.9%)
17:01:43 * mrd got to use a dual-quad box last semester
17:02:31 <ddarius> dons: Haskell is not going to be the next C# ever.  If nothing else, some new language would be developed that just happened to be rather like Haskell but was new! and shiny!
17:02:51 <ddarius> dons: What is "Haskell succeeding"?
17:02:53 <pjd> #kell
17:03:03 <Korollary> and #kell-blah
17:03:15 <dons> ddarius: i'd like just a few more companies using it.
17:03:19 <mauke> I can has kell?
17:03:30 <ddarius> dons: That's definitely going to happen.
17:03:31 <dons> continued research, enough jobs to keep the phd students in work
17:03:53 <shapr> I dunno, I think Haskell could be the next C#
17:03:55 <Korollary> phd students can succ it.
17:04:15 <ddarius> If Brian Beckmann isn't a fluke, I think we may be at the very beginning of a hype bubble for FP.
17:04:16 <dons> shapr: we'd need MS or Sun or someone to kick us some monies
17:04:17 <shapr> Especially after hanging out on ##csharp for a few days...
17:04:25 <shapr> ddarius: BrianBec r0xx0rs
17:04:34 * LoganCapaldo would rather Haskell became the next C++
17:04:36 <shapr> dons: We only need advertising, we got everything else.
17:04:40 <Korollary> I was in a cave. Who's Beckmann?
17:04:48 <dibblego> shapr, what did you learn from hanging out in #csharp that would make you think that?
17:04:53 <dons> and MS got their F# for that instead. C# got Meijer, Java got Wadler, Scala got Odersky
17:04:55 <ddarius> shapr: His monad talk is ridiculous.
17:05:26 <shapr> dibblego: I learned that the community on ##csharp is ... not likely to outperform #haskell.
17:05:34 <shapr> That may be the most tactful thing I've ever said.
17:05:48 <dibblego> shapr, heh; I coulda told you that!
17:05:55 <dons> strategic positioning is tricky. my strategy at the moment is to write all the code we can, and publicise anything useful. more user groups are helping, and the continued trickle down effect of ideas into other langs.
17:05:58 <ddarius> dons: Scala didn't really "get" Odersky.  He set out to make Scala and I have to say, he's done quite a bit better than I originally thought.
17:06:22 <shapr> ddarius: Can you point me to BrianBec's monad talk?
17:06:24 <dons> ddarius: my point was that someone like that can do a viable haskell-lite
17:06:32 <bos> dons: and the book :-) all the code isn't going to help if people can't grok the language.
17:06:40 <dons> and the book is huge, actuallyy
17:06:44 <dons> just look at the effect on scala
17:06:50 <ddarius> dons: Scala isn't Haskell-lite + OO?
17:07:01 <dons> it is, isn't it? :)
17:07:24 <dibblego> Odersky would object to you saying that
17:07:29 <dibblego> but I wouldn't agree anyway
17:07:42 <dibblego> it's more like Java-plus than Haskell-lite
17:07:55 <dons> ok, so less FP, more OO
17:08:01 <dibblego> yes
17:08:04 <dons> and funny section syntax :)
17:08:12 <dons> like DRMacIver said, don't go to scala looking for FP
17:08:14 <dibblego> I seem to be the only one who uses it in a "pure sense"
17:08:36 <Korollary> That sucks. A friend of mine is hanging on to Scala as his last hope to be able to use FP at work.
17:08:38 <dibblego> and conceding where it's not worthwhile
17:08:44 <ricky_clarkson> Scala has FP, but it's not pure.
17:08:52 <dons> i'd like to see the haskell fans able to use haskell for their day jobs. that'd be success enough
17:08:55 <dibblego> Korollary, he'd be right in doing so
17:09:00 <ricky_clarkson> ..its types are somewhat lacking, but hugely better than mainstream langs.
17:09:26 <ddarius> shapr: http://channel9.msdn.com/ShowPost.aspx?PostID=358968
17:09:28 <lambdabot> Title: Brian Beckman: Don't fear the Monads
17:09:29 <sarehu> if you want FP at work, there's always XSLT :P
17:09:52 <Saizan> sarehu: C++ templates then..
17:13:35 <shapr> ddarius: Looks cool
17:15:46 <shapr> Anyone in Boston?
17:16:16 <ddarius> shapr: It starts off odd but reasonable and then goes spiraling downhill until it finally ends.  At least two people in here couldn't stand to watch the thing through, and I can empathize.
17:16:40 <shapr> I just finished an 8 hour conference call. This is not so painful :-)
17:17:49 <notsmack> shapr: 8 hours?!
17:17:56 <Korollary> ddarius: I couldn't watch the first five minutes.
17:18:07 <Korollary> and not that I am an expert on the subject.
17:18:25 <shapr> notsmack: Yeah.. 8 hours.
17:18:47 <notsmack> shapr: can you say what about?
17:18:49 <Korollary> shapr: Were you actively participating throughout?
17:18:53 <ricky_clarkson> shapr: You should charge that customer porno rates.
17:19:05 <shapr> notsmack: Company orientation
17:19:17 <notsmack> shapr: how many orientees?
17:19:19 <shapr> Korollary: Not actively, but I had to listen at all times for when I had to be active.
17:19:23 <notsmack> and what company?
17:19:24 <shapr> notsmack: um... I don't remember.
17:19:38 <notsmack> shapr: sorry, i'm just bewildered by the idea of an 8 hour conference call :)
17:19:43 <dons> wow, shapr.
17:19:59 <shapr> notsmack: My new job...
17:20:23 <shapr> Anyway, they're trying something new for the orientation, and we give feedback afterwards.
17:20:31 * shapr shrugs
17:22:08 <jaa> shapr is there a boston-fp. seems strange that the town that gave birh to Lisp wouldnt have one but NY and Bayarea do?
17:22:18 <BMeph> Hmm, anyone familiar (and willing to help with) ghc compiling issues in WIndows?
17:22:55 <Korollary> Seattle has SeaFunc, too, even though it largely sucks.
17:24:17 <shapr> jaa: I don't know, I haven't been here long enough.
17:24:20 <jaa> theres 3 ruby ones though
17:24:24 <jaa> which is just wtf. but whatever :)
17:24:38 <Korollary> Maybe Ruby needs 3.
17:24:54 <shapr> jaa: Are you in Boston?
17:24:57 <jaa> nearby
17:25:04 <shapr> jaa: If there isn't a boston-fp, I'll start one.
17:25:34 <jaa> MIT HR has 33 job posts for Java. 0 for Scheme, 0 for Lisp, 0 for HAskell
17:25:40 <shapr> suck
17:25:42 <jaa> the search box even suggests 'Java'
17:25:46 <jaa> yeah, impressive
17:25:53 <shapr> jaa: So, are you showing up on Saturday at the random geek meet?
17:26:32 * shapr wanders off to play games with friends
17:26:54 <Korollary> MIT jobs should be as mainstream as your random state college jobs. Java makes no less sense.
17:27:11 <jaa> i guess 'dogfood eating' is only important at places like Microsoft, 37signals, etc
17:27:54 <dons> Korollary: is any haskell discussed at SeaFunc?
17:28:07 <BMeph> I'm building haddock 2.0, and I keep getting a msg about bytestring 0.9.0.1, which I don't even have installed any more.
17:28:09 <dons> should it be on haskell.org's user groups page, or is it a lisp ghetto?
17:28:26 <dons> hmm, 0.9.x should work, BMeph
17:29:02 <BMeph> I agree, but it says, "ghc.exe: unknown package: bytestring-0.9.0.1 (dependency of ghc-6.8.2)"
17:29:40 <dcoutts_> BMeph: you removed bytestring-0.9.0.1 but the ghc package depended on that, so the ghc package is now borken
17:29:51 <dons> the ghc package depends on bytestring?
17:30:00 <Korollary> dons: The only haskell related subject is "I didn't understand monads" That's about it.
17:30:00 <dcoutts_> hence you cannot compile haddock-2.0 which uses the ghc package
17:30:16 <dcoutts_> dons: yep
17:30:17 <emmmi> type var reachability question: I can define a function with type "forall a b. (C a, D a b) => a -> a -> Bool", but how can I ever use it?  i.e. how to instantiate the type variable b?
17:30:19 <dons> Korollary: that's a pity. pdxfunc is the opposite
17:30:26 <dons> dcoutts_: what does ghc use bytestrings for?
17:30:35 <dcoutts_> dons: not very much really
17:30:41 <dcoutts_> a little bit in ghci iirc
17:30:51 <dons> ghci/InteractiveUI.hs:import qualified Data.ByteString.Char8 as BS
17:30:53 <dons> huh
17:30:58 <dons> codeGen/CgUtils.hs:mkByteStringCLit :: [Word8] -> FCode CmmLit
17:31:08 <dons> we better not break things :)
17:31:14 <oerjan> emmmi: you'll need a functional dependency from a to b in the D class
17:31:23 <oerjan> otherwise, you cannot
17:31:55 <BMeph> dcoutts_: That makes sense. I'll swap out the newer one for -.0.1, and see.
17:31:57 <emmmi> oerjan: really? it's surprising that I can legally define that function if I cant instantiate it, no?
17:32:30 <oerjan> emmmi: i suppose there could have been some warning, yeah
17:33:49 <emmmi> oerjan: thanks for clearing that up!
17:35:04 <oerjan> :)
17:36:00 <emmmi> oerjan: does functional dependency mean that for each instance of 'a the corresponding instance of 'b?
17:36:12 <emmmi> *the-> there will be
17:36:28 <TSC> exactly one corresponding instance of b
17:36:53 <TSC> Perhaps "instance" is the wrong word there
17:37:06 <emmmi> I see, so it would be an error to declare two instances with the same 'a?
17:37:12 <oerjan> yep
17:37:17 <emmmi> good, good
17:39:49 <monochrom> I believe there is more.
17:40:24 <monochrom> You can't have two "instance MyClass MyType". That is already true of ordinary type classes, before MPTC, before fundep.
17:41:34 <monochrom> If you now have MPTC but no fundep yet, you are allowed "instance MyClass2 T S" and "instance MyClass2 T U" to co-exist. Even "instance MyClass2 X S" too.
17:42:00 <monochrom> Now add fundep. Say "class MyClass2 a b | a -> b", just that.
17:42:04 <ddarius> The a -> b in class M a b | a -> b can be read as "a determines b" (or "a fixes b" or whatever)
17:42:26 <monochrom> Then you must choose one of "instance MyClass2 T S" and "instance MyClass2 T U". Pick one. Throw away the other.
17:42:44 <monochrom> But you're still allowed to add "instance MyClass2 X S".
17:42:57 <emmmi> that sounds right.
17:43:07 <GoMittGo> GOVERNOR ROMNEY: "And further, if I were fortunate enough to be elected your President, I'd call for a National Summit of Nations to create a new partnership â a Partnership for [Progress] and Prosperity."
17:43:07 <GoMittGo> "This Partnership would assemble the resources of all the nations of the world to work to assure that Islamic states that are threatened with violent Jihad have public schools that are not Wahhabi madrasas; that they have micro-credit and banking, the rule of law, human rights, basic health care, and competitive economic practices." (Governor Mitt Romney, Remarks At Yeshiva University, 4/26/07)
17:43:21 --- mode: ChanServ set +o Pseudonym
17:43:22 --- mode: Pseudonym set -o GoMittGo
17:43:23 --- kick: GoMittGo was kicked by Pseudonym (game over, man.  game over.)
17:43:30 --- mode: Pseudonym set -o GoMittGo
17:43:30 --- kick: GoMittGo was kicked by Pseudonym (game over, man.  game over.)
17:43:38 --- mode: Pseudonym set -o GoMittGo
17:43:38 --- kick: GoMittGo was kicked by Pseudonym (game over, man.  game over.)
17:43:41 <mauke> er
17:43:42 <Pseudonym> Bleah.
17:43:44 <Pseudonym> Full ban list.
17:43:50 --- mode: Pseudonym set -o GoMittGo
17:43:50 --- kick: GoMittGo was kicked by Pseudonym (game over, man.  game over.)
17:44:00 <Valodim> wtf?
17:44:01 --- mode: Pseudonym set -o GoMittGo
17:44:01 --- kick: GoMittGo was kicked by Pseudonym (game over, man.  game over.)
17:44:08 <mauke> so clean it?
17:44:09 <Pseudonym> Can someone clear out some ban list entries right now please?
17:44:09 <GoMittGo> GOVERNOR ROMNEY: "And further, if I were fortunate enough to be elected your President, I'd call for a National Summit of Nations to create a new partnership â a Partnership for [Progress] and Prosperity."
17:44:10 <GoMittGo> "This Partnership would assemble the resources of all the nations of the world to work to assure that Islamic states that are threatened with violent Jihad have public schools that are not Wahhabi madrasas; that they have micro-credit and banking, the rule of law, human rights, basic health care, and competitive economic practices." (Governor Mitt Romney, Remarks At Yeshiva University, 4/26/07)
17:44:13 --- mode: Pseudonym set -o GoMittGo
17:44:14 --- kick: GoMittGo was kicked by Pseudonym (game over, man.  game over.)
17:44:18 <chessguy> Cale, dons
17:44:21 --- mode: Pseudonym set -o GoMittGo
17:44:21 --- kick: GoMittGo was kicked by Pseudonym (game over, man.  game over.)
17:44:26 --- mode: Pseudonym set -o GoMittGo
17:44:26 --- kick: GoMittGo was kicked by Pseudonym (game over, man.  game over.)
17:44:31 <chessguy> glguy
17:44:35 --- kick: GoMittGo was kicked by Pseudonym (Pseudonym)
17:44:38 <monochrom> You need to free up banlist space first. :)
17:44:39 * chessguy tries to remember who else are ops
17:44:40 <mauke> Pseudonym: can you /remove him instead of /kick?
17:44:50 <Pseudonym> No.
17:44:53 * Pseudonym doesn't have that macro
17:44:56 --- kick: GoMittGo was kicked by Pseudonym (Pseudonym)
17:44:59 <jaa> /ignore #haskell JOINS PARTS KICKS
17:45:04 <mauke> it's a server command
17:45:41 <chessguy> is he goine?
17:45:42 <Botje> now may not be the best time to ask the question, but how do you solve GHC errors due to "variable is wobbly" ?
17:45:42 <Pseudonym> shapr, you wanted to know what a politbot was.
17:45:54 <Pseudonym> If you're still around, that's one.
17:46:03 <Pseudonym> Gone I think.
17:46:14 <ddarius> Botje: Don't use GADTs?
17:46:14 <allbery_b> the last time it left under its own power
17:46:24 <monochrom> wobbly variable is very advanced :)
17:46:44 <monochrom> only thing I know is "rigid" vs "wobbly".
17:46:45 <LoganCapaldo> tell to stop standing so close to the edge
17:46:54 <LoganCapaldo> *it
17:47:00 <Pseudonym> OK, it's in the autorem list, anyway.
17:47:01 <Botje> :)
17:49:49 <Pseudonym> Anyway.
17:49:51 <Pseudonym> BBS
17:49:55 --- mode: ChanServ set -o Pseudonym
17:56:53 <Romney08> GOVERNOR ROMNEY: "And further, if I were fortunate enough to be elected your President, I'd call for a National Summit of Nations to create a new partnership â a Partnership for [Progress] and Prosperity."
17:56:56 <Romney08> "This Partnership would assemble the resources of all the nations of the world to work to assure that Islamic states that are threatened with violent Jihad have public schools that are not Wahhabi madrasas; that they have micro-credit and banking, the rule of law, human rights, basic health care, and competitive economic practices." (Governor Mitt Romney, Remarks At Yeshiva University, 4/26/07)
17:57:16 <monochrom> onoes
17:57:49 <Botje> maybe it'll quiet now
17:59:13 --- mode: ChanServ set +o bos
17:59:41 --- kick: Romney08 was kicked by bos (bos)
17:59:57 --- kick: Romney08 was kicked by bos (bos)
18:00:01 <byorgey> what's the point?  who makes bots like that?
18:00:04 <Romney08> GOVERNOR ROMNEY: "And further, if I were fortunate enough to be elected your President, I'd call for a National Summit of Nations to create a new partnership â a Partnership for [Progress] and Prosperity."
18:00:05 <Romney08> "This Partnership would assemble the resources of all the nations of the world to work to assure that Islamic states that are threatened with violent Jihad have public schools that are not Wahhabi madrasas; that they have micro-credit and banking, the rule of law, human rights, basic health care, and competitive economic practices." (Governor Mitt Romney, Remarks At Yeshiva University, 4/26/07)
18:00:07 <Valodim> people
18:00:12 <lucca> -.-
18:00:18 <byorgey> *sigh*
18:00:19 <bos> sigh. the banlist is full.
18:00:19 <Valodim> it's a form of spam, and spam lost its purpose ages ago
18:00:20 <byorgey> people are dumb
18:00:59 <lucca> so set mode +i, kick, clean up the banlist, mode -i
18:01:29 <sarehu> If #haskell keeps growing it might get delegates to the Republican convention
18:01:30 <monochrom> Garbage collection :)
18:01:36 <Valodim> haha
18:01:39 <monochrom> hehehe
18:02:17 --- mode: ChanServ set +o allbery_b
18:02:37 --- kick: Romney08 was kicked by allbery_b (allbery_b)
18:02:51 <byorgey> OOC, who is allowed to have "channel operator status"?
18:03:12 --- kick: Romney08 was kicked by allbery_b (allbery_b)
18:03:27 --- kick: Romney08 was kicked by allbery_b (allbery_b)
18:03:37 --- kick: Romney08 was kicked by allbery_b (allbery_b)
18:03:41 <ricky_clarkson> Why do you not ban him?
18:03:43 --- kick: Romney08 was kicked by allbery_b (allbery_b)
18:03:49 --- kick: Romney08 was kicked by allbery_b (allbery_b)
18:03:53 <byorgey> ricky_clarkson: the ban list is full, apparently
18:03:53 <oerjan> will you for heaven's sake _stop_ kicking them without banning?  It only _adds_ to the noise!!!!
18:04:07 <felipe> fun stuff
18:04:16 --- mode: bos set -b *!*n=gavin@*.lsanca.dsl-w.verizon.net
18:04:21 <ricky_clarkson> Well remove some bans.  ChanServ can maintain a longer banlist.
18:04:34 --- mode: bos set +b *!*@*.160.144.36.cable.dyn.cableonline.com.mx
18:04:39 --- kick: Romney08 was kicked by bos (bos)
18:04:42 <felipe> allbery_b 1 - 0 Romney08
18:04:44 <bos> ok, gone for now.
18:04:53 <Valodim> haha
18:05:00 <mauke> how about *!i=ubuntu@gateway/tor/x-26e2ccc44e60a27d or *!*@p54B6E4C0.dip.t-dialin.net
18:05:31 <Botje> I keep thinking network-wide spam alterts would be nice
18:05:50 * allbery_b has not had ops here or involvement therewith for long enough to know which bans are safe to nuke
18:05:54 <Botje> just monitor some of the large channels for annoyances, ..
18:06:20 <Botje> nuke the oldest first :)
18:06:25 * oerjan doesn't know about this, but are the bans ordered by age?  Just remove the oldest ones
18:06:26 <allbery_b> (there are some obvious ones)
18:06:42 <allbery_b> I think the oldest ones are keal, who's still active
18:06:43 <bos> no, the bans are not particularly ordered. i just chose an old one at random.
18:07:05 --- mode: bos set -o bos
18:07:07 <mauke> e.g. *!*@p54B6E4C0.dip.t-dialin.net is a random dial up address
18:07:15 <allbery_b> or is that protontorpedo?  gschuett
18:07:20 <mauke> he is
18:07:34 --- mode: allbery_b set -o allbery_b
18:07:35 <pragma_> It's not hard to sort the bans.
18:07:53 <mauke> recently seen as boogooo!n=g@147.21.16.3
18:08:02 <Botje> @protontorpedo
18:08:08 <Botje> awwh :(
18:08:12 <oerjan> @bot
18:08:21 <allbery_b> also, the dates I see are mostly from some mass load in early december
18:08:42 <oerjan> You killed lambdabot!  You bastards!
18:08:49 * allbery_b wonders if his rapid-reaction kicks confused her
18:09:08 <Botje> \bot isn't dead, she's just resting :)
18:09:20 <Botje> lambdabot: are you dead?
18:09:37 <allbery_b> ex-parrbot?
18:10:05 <Botje> heheh
18:10:11 <Botje> (+1) allbery_b
18:13:04 <allbery_b> hm, right, once I release ops playing with the banlist is ineffective :)
18:13:07 --- mode: ChanServ set +o allbery_b
18:13:20 --- mode: allbery_b set -b *!*@ool-45761a5c.dyn.optonline.net
18:13:24 --- mode: allbery_b set -b *!*=chatzill@*.client.mchsi.com
18:13:27 --- mode: allbery_b set -b *!*@p54B6E4C0.dip.t-dialin.net
18:13:33 --- mode: allbery_b set -b *!*@193.216.161.248
18:13:36 --- mode: allbery_b set -b *!*@193.216.160.2
18:13:50 <allbery_b> ok, a little more space fo rbans now
18:13:56 --- mode: allbery_b set -o allbery_b
18:13:57 <int-e> the lisppaste ban can probably go, too? at least #haskell isn't listed on http://paste.lisp.org/channels anymore
18:14:08 --- mode: ChanServ set +o allbery_b
18:14:17 --- mode: allbery_b set -b *!*=lisppast@common-lisp.net
18:14:32 <allbery_b> good point, missed that one
18:14:35 --- mode: allbery_b set -o allbery_b
18:14:40 <allbery_b> 6 open slots now
18:15:21 <LoganCapaldo> 6 open graves
18:15:36 * LoganCapaldo rubs hands together evilly
18:15:47 <Valodim> why are there so many bans on this chan?
18:16:13 <LoganCapaldo> it's an exclusive club
18:16:28 <allbery_b> for some reason we seem to attract trolls and bots
18:16:47 <allbery_b> (heck, I'm in 10 channels here and for the most part only #haskell gets the politibots.  huh?)
18:17:05 <allbery_b> probably being in the top channels makes us a target
18:17:09 <mauke> #perl also gets them
18:17:20 <mauke> (+ regular visits from gschuett)
18:23:41 <dbueno> @paste
18:24:03 <int-e> http://hpaste.org/
18:24:52 <hpaste>  dbueno pasted "IArray Foldable instance" at http://hpaste.org/4864
18:25:22 <dbueno> I can't divine the problem given that error message.  Could someone shed some light?
18:25:45 <dbueno> There are some imports I didn't paste; ask if you need them.
18:26:12 <oerjan> dbueno: Foldable's need to be parametric in the result type
18:26:19 <oerjan> but IArray's are not
18:26:54 <oerjan> i.e. the e is fixed
18:26:55 <glguy> ?bot
18:27:22 <dbueno> oerjan: So there's no way to fix it?
18:27:27 <glguy> shapr: you about?
18:27:34 <dons> url module failed in contextual handler: thread killed
18:27:45 <allbery_b> ah
18:27:50 <oerjan> dbueno: hm, not that i know of
18:27:56 <allbery_b> I was worried the bot battles confused it
18:28:02 <sarehu> > 2 + 3
18:28:07 <allbery_b> @bot
18:28:12 <lambdabot>  5
18:28:14 <lambdabot> :)
18:28:26 <dons> hehe, "Wow, I guess I should actually learn what the hell monads do sometime."
18:28:37 <dons> http://programming.reddit.com/info/64th1/comments
18:28:59 <dbueno> oerjan:  Thanks for the help.
18:29:06 <TomMD> Hey!  Don't laugh at quote I could have easily made myself! ;-)
18:29:12 * oerjan started wondering what the Hell monad did
18:29:28 <oerjan> probably best not to know.
18:33:56 <nelhage> What's the recommended way to generate FFI bindings for C code these days? c2hs?
18:33:58 <chessguy_> isn't that like learning what XML "does"?
18:34:23 <TomMD> That depends on what your definition of does, does.
18:35:06 <chessguy> good point
18:35:08 <chessguy> i think
18:35:29 <TomMD> wow, a west coaster left because my lame joke - I feel bad.
18:35:31 <Lemmih> nelhage: That depends on the complexity of the foreign library.
18:35:47 <chessguy> bah, who needs west coasters anyway?
18:36:00 * chessguy ducks
18:37:27 <nelhage> Lemmih: what are the different options?
18:37:46 <Lemmih> nelhage: hsc2hs and c2hs are popular.
18:42:28 <EvilTerran> iirc, i've seen both used in the same project on occasion
18:53:38 <Jomyoot> hi
18:55:02 <byorgey> hi Jomyoot
19:13:52 <sjanssen> @quote
19:13:54 <lambdabot> MyCatVerbs says: does that make any sense, or should I go find some gin and try to explain that again?
19:17:01 <MyCatVerbs> sjanssen: damn you, now I'm thirsty.
19:22:39 <monochrom> gin would make you more thirsty
19:24:10 <MyCatVerbs> monochrom: +tonic.
19:24:37 <MyCatVerbs> monochrom: also, I might be drunk enough to stop caring, so it wouldn't even matter. Yaaaay!
19:25:00 <monochrom> gin and tonic make you thirsty and monotonic.
19:25:09 <shapr> ugh, politbot
19:25:33 <MyCatVerbs> monochrom: ...*headdesk*
19:25:59 <monochrom> Haha. I looked at "monochrom: +tonic" and thought of monotonic.
19:26:19 * monochrom is monochromic and monotonic. :)
19:26:33 <Random08> Hey, vote for Random!
19:26:42 <monochrom> ...
19:26:47 --- mode: ChanServ set +o Pseudonym
19:26:49 --- kick: Random08 was kicked by Pseudonym (game over, man.  game over.)
19:26:53 --- mode: ChanServ set -o Pseudonym
19:26:57 <Pseudonym> OK, works.
19:27:22 --- mode: ChanServ set +b Random08!n=ajb@*.alicorna.net
19:27:27 <Pseudonym> Excellent!
19:27:41 <Pseudonym> Still some noise, but it's an auto-kick.
19:27:50 <monochrom> also /ban works
19:28:15 <sjanssen> what exactly triggers the kick?
19:28:24 <Pseudonym> ChanServ kicks.
19:28:25 <mauke> anything that contains "vote for"?
19:28:37 <Pseudonym> No.
19:28:57 <Pseudonym> I'm testing out a macro that instead of +b'ing, adds an entry to the ChanServ autorem list.
19:29:02 <mauke> ah
19:29:09 <Pseudonym> Just in case the ban list fills again.
19:29:44 <Pseudonym> BRB
19:30:09 <glguy> when did the ban list fill?
19:30:10 <Pseudonym> Cool.
19:30:12 * Pseudonym is now powerful and stuff
19:30:22 <glguy> what client did you write the macro for?
19:30:26 <Pseudonym> sirc
19:32:01 <bos> that ajb fellow was always kind of shifty. we're better off without him.
19:32:55 <Pseudonym> I'm not really voting Random in '08.
19:32:58 * Pseudonym is just saying
19:34:20 * bos updates his prior and votes Bayes
19:35:11 <glguy> I need to script in some clever kick messages
19:35:22 <glguy> I never remember when I actually need to use them
19:37:26 <skew> shapr: cheer up! https://www.cs.kent.ac.uk/pubs/2006/2381/content.pdf
19:38:24 <zeeeee> @seen Cale
19:38:25 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I don't know when Cale last spoke.
19:40:31 <MyCatVerbs> Y'know what's awesome? xmonad, counterstrike, fridge door. ^_^
19:41:02 <mauke> Even electronic brain pancake crystal elderly.
19:55:38 <monochrom> I will vote Probability Measure Monad.
20:02:40 <shapr> skew: Hiya!
20:03:35 <shapr> skew: Hmm, double ended queue of delimited continuations?
20:04:02 <skew> yep
20:04:16 <skew> or, closures that print a bit more of the output
20:05:10 <skew> seems like finally a functional pretty printing algorithm with optimal complexity and laziness that's reasonably simple
20:07:01 <shapr> @users
20:07:03 <lambdabot> Maximum users seen in #haskell: 401, currently: 395 (98.5%), active: 13 (3.3%)
20:10:06 <monochrom> Scary.
20:11:20 <skew> shapr: If you haven't heard I've been writing a little structure editor thingy
20:11:30 <shapr> Oh?
20:11:36 <shapr> I haven't heard much.
20:12:06 <skew> one bit is a hacked up pretty printer that a) wraps by pixel width of the text and b) produces an index from character offsets back to subexpressions
20:12:28 <shapr> Oh neat, so you could layout variable width fonts?
20:12:32 <skew> yep
20:12:47 <shapr> Wow, that's cool.
20:12:48 <skew> works almost perfectly, except gtk seems to deliver resize events out of order or something
20:13:35 <skew> I can catch it overful, but if I strech the window vertically to trigger a resize it wraps again
20:13:45 <shapr> Do you have any screenshots?
20:14:01 <skew> no
20:14:42 <shapr> I'd like to see some.
20:14:49 <shapr> If you get time to make them.
20:15:28 <skew> I'm planning to release some code once it's a little more together
20:15:45 <shapr> Cool
20:15:47 <skew> The pretty printer is based on wadler's now, but I'm thinking of moving to Olaf's
20:16:01 <skew> among other things, his does align efficiently
20:16:08 <hpaste>  (anonymous) pasted "darcsify" at http://hpaste.org/4865
20:16:24 <skew> I'm just getting the syntax together tonight
20:16:43 <skew> following McBride and McKinna
20:16:54 <monochrom> nice nice nice
20:16:58 <skew> hugs on my XO is pretty nice for hauling around
20:17:18 <clanehin> Puzzled.  It seems like parList yields a () immediately after sparking for each element.  I want to wait until the list is fully deeply evaluated.
20:17:23 <skew> case of case seems to be working
20:17:55 <shapr> I just got a luggable, wish I had an XO.
20:18:00 <sjanssen> clanehin: par doesn't work like that -- it's asynchronous
20:18:08 <shapr> On the good side, I might get to meet one or two of the XO team this weekend :-)
20:18:11 <skew> the immediate goal is a nice GUI for manually driving supero
20:18:35 <sjanssen> now that sounds interesting
20:19:05 <sjanssen> skew: allow the user to choose sites to optimize, because doing it on an entire program is too expensive?
20:19:58 <skew> sjanssen: I think I see how to get some nice optimizations from the transformations, but the terminations conditions prevent it
20:20:29 <MyCatVerbs> \o/
20:20:39 <clanehin> sjanssen: it's entirely impossible using par and seq?
20:20:51 <ricky_clarkson> gigamonkey: Have you interviewed SPJ yet?
20:21:06 * MyCatVerbs rejoices. Much code is deleted. Many neurons and cycles saved! Also, his music player just came up with some Moby. <3
20:21:21 <sjanssen> clanehin: you can first spark parList, then seq each element of the list in turn
20:22:10 <skew> sjanssen: I'm mostly hoping to divise something automatic by playing around interactively and thought that it would be fairly awkward with a text interface and independently interesting to write the GUI and syntax manipulation stuff myself
20:25:35 <skew> sjanssen: but it will be like what you said.
20:28:14 <monochrom> Oh! I forgot to recharge my mp3 player!
20:46:53 <visof> i had some problem when i install lambdabot
20:46:58 <visof> can some help me
20:47:01 <visof> ?
20:47:22 <newsham> what problems
20:47:51 <visof> when i try to do ./Setup.hs configure "for installing lambdabot" i had::
20:49:12 <visof>  configure: /usr/bin/ghc-pkg
20:49:12 <visof>  configure: Dependency base-any: using base-2.0
20:49:12 <visof>  configure: Dependency unix-any: using unix-1.0
20:49:12 <visof>  Setup.hs: cannot satisfy dependency network-any
20:49:21 <clanehin> sjanssen: thanks, I used: waitParList s = seqList rwhnf . parMap r0 s
20:49:26 <visof> what should i do?
20:49:56 <newsham> is lambdabot up to date for the new library layout?
20:50:37 <newsham> ?about
20:50:37 <lambdabot> Unknown command, try @list
20:50:41 <newsham> ?version
20:50:41 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
20:50:41 <lambdabot> darcs get http://code.haskell.org/lambdabot
20:50:57 <newsham> visof: you're building with 6.8.x/
20:50:58 <newsham> ?
20:51:23 <visof> no ghc 6.6.3
20:51:54 <newsham> hmmm..  did you install lib extras too?
20:53:01 <visof> what should i install?
20:53:09 <visof> newsham?
20:54:42 <newsham> you have network-2.0 and it cant find network-any?
20:57:45 <visof> i don't know
20:58:06 <newsham> i dont know either
20:58:15 <visof> hahaha
20:58:22 <visof> anyone can help me
20:58:26 <visof> ?
20:58:55 <sarehu> taken out of context the last five lines are amusing
20:59:16 <monochrom> hahahaha
21:00:10 <visof> @seen dons
21:00:10 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 2h 31m 33s ago.
21:08:35 <jsnx> @tell Cale i have another math question for you. On page 7 of Eugenia's notes, it says we have `h : (A, f) â (B, g)` such that `h â f = g` -- however, I can't see how the 'signature' of h allows it to be composed with fo
21:08:35 <lambdabot> Consider it noted.
21:09:27 <Cale> jsnx: I'll look into it :)
21:09:27 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
21:10:15 <jsnx> Cale: hmmm, i couldn't tab complete your nick earlier -- thought you weren't around
21:12:05 <Cale> jsnx: Sorry, where is it saying that?
21:12:44 <jsnx> Cale: page 7 is about the "slice over X,
21:13:00 <Cale> It says that f_2 h = f_1, right?
21:13:10 <jsnx> Cale: right below that
21:13:22 <Cale> So the definition of slice under X?
21:13:27 <jsnx> yes
21:13:34 <jsnx> however, they both puzzle me
21:13:38 <Cale> And they have h f_1 = f_2
21:13:46 <jsnx> yes
21:13:48 <Cale> h f_1 is h composed with f_1
21:13:56 <Cale> That is, h following f_1
21:14:02 <jsnx> yes
21:14:14 <jsnx> but f_1 makes a Y
21:14:18 <Cale> So f_1 takes you from X to Y_1
21:14:26 <Cale> and then h goes from Y_1 to Y_2
21:14:30 <jsnx> oh
21:14:38 <Cale> So the composite goes from X to Y_2
21:14:45 <Cale> which is the same as what f_2 does
21:14:55 <jsnx> well, h : (A, f) -> (B, g) seems to suggest that h works on tuples
21:15:29 <Cale> Oh, right. There's a subtle identification going on here.
21:16:00 <jsnx> Cale: is the evaluation morphism involved?
21:16:19 <Cale> The morphisms of the slice category, going from (Y_1, f_1) to (Y_2, f_2) are the morphisms in the original category going from Y_1 to Y_2 such that the given triangle commutes.
21:16:51 <Cale> So each arrow h is simultaneously a member of the slice category as well as the original.
21:18:04 <Cale> (there are more arrows in the original category, since not every such h: Y_1 -> Y_2 will make the triangle commute)
21:18:49 <jsnx> Cale: so, the signature of h is really `h : Y_1 -> Y_2`
21:18:52 <Cale> Well, hmm... on the other hand, there are new objects in the slice category, since the objects are pairs of an object of the original category with a morphism from X
21:19:00 <Cale> jsnx: It's both.
21:19:01 <jsnx> right, that's what i thought
21:19:14 <jsnx> zomg111!!!11!
21:19:27 <jsnx> okay, so, how does that happen?
21:19:38 <Cale> jsnx: When you define a category, you're allowed to choose explicitly what the morphisms are, and it's okay for them to be morphisms stolen from another category.
21:20:04 <jsnx> but they can have a different type in the new category?
21:20:09 <Cale> yeah.
21:20:23 <jsnx> type is the wrong word though -- as is signature -- what am i supposed to call it?
21:20:25 <oerjan> jsnx: this sounds like an example where it is actually harmful to think of arrows and objects as functions and sets
21:21:09 <jsnx> oerjan: ah, i see
21:21:20 <jsnx> oerjan: is there a better one you can think of?
21:21:33 <jsnx> like forest animals or something cute like that?
21:21:40 <oerjan> heh :D
21:21:44 <skew> jsnx: the opposite category is a very simple case where morphisms are reused with a different signature
21:21:45 <Cale> Sure, my group theory prof did that.
21:21:47 <oerjan> warm fuzzy things? ;)
21:22:34 <Cale> Just remember that given any objects X and Y of C, there is a set C(X,Y) of morphisms X -> Y. This can be any set at all.
21:22:41 <jsnx> skew: is signature okay terminology? it makes me feel like we're discussing java...
21:22:42 <jfredett> hmm, is there a way to generalize to only listlike monads? that is, I want to generalize to any monad with cons and empty?
21:23:10 <oerjan> jfredett: MonadZero?
21:23:26 <jfredett> oerjan: I smell monad transformers in my near future... :/
21:23:37 <oerjan> cons x y = return x `mplus` y; empty = mzero
21:23:41 <Cale> The structure of the category actually comes from the definition of composition in the category, and not from the actual members of the morphism sets (though of course, the number of morphisms available between two objects matters, but that's all)
21:24:06 <jsnx> Cale: this is where we left off last time, actually
21:25:07 <jfredett> oerjan: those are part of the transformer world, correct?
21:25:12 <oerjan> jfredett: sheesh, i meant MonadPlus
21:25:19 <jfredett> lol, thats okay
21:25:22 <Cale> So if you wanted, you could construct a category with just two objects, say X and Y, and the set of arrows from X to Y is the set of words defined in the Oxford English Dictionary. (and only the identities X -> X, Y -> Y, and no arrows Y -> X)
21:25:28 <oerjan> jfredett: no, MonadPlus is in H98
21:25:45 <oerjan> @src MonadPlus
21:25:46 <lambdabot> Source not found. Just what do you think you're doing Dave?
21:25:50 <Cale> composition would of course not be all that interesting in this category, but it's a valid category
21:26:05 <jsnx> Cale: aha -- can we come back to that in a minute?
21:26:08 <oerjan> oh well, it's essentially just mplus and mzero
21:26:09 <Cale> Sure
21:26:09 <jfredett> @hoogle MonadPlus
21:26:10 <lambdabot> Control.Monad.MonadPlus :: class Monad m => MonadPlus m
21:26:18 <jsnx> i actually don't understand what just happened with h
21:26:22 <oerjan> :t mplus
21:26:24 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
21:26:24 <jfredett> ah, so its a class. hmm
21:26:28 <oerjan> :t mzero
21:26:28 <jfredett> okay
21:26:28 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
21:26:29 <shapr> I want to learn a new programming language, any suggestions?
21:26:38 <jsnx> shapr: datalog
21:26:39 <Cale> jsnx: Okay, so let's look at the opposite category for a moment -- have you seen that construction?
21:26:48 <jsnx> Cale: no, i have not
21:26:51 * jsnx googling
21:26:52 <jfredett> shapr: Erlang is interesting,but if you want some real fun, try Puredata
21:26:52 <jfredett> :)
21:26:52 <oerjan> :t mconcat -- optional, has default
21:26:53 <lambdabot> forall a. (Monoid a) => [a] -> a
21:26:55 <Cale> jsnx: It's a simpler example to look at than the slice category, and I think it'll help.
21:27:00 <oerjan> argh
21:27:01 <Cale> I can define it :)
21:27:05 <jsnx> okay
21:27:10 <oerjan> i'm confused
21:27:28 <Cale> Given a category C, the opposite category C^op is defined as the category whose objects are the same as those for C
21:27:39 <oerjan> just mplus and mzero, i was confusing with Monoid
21:27:45 <jfredett> oerjan: cool
21:27:46 <jfredett> thanks
21:27:47 <Cale> But the set of arrows X -> Y in C^op is exactly the set of arrows Y -> X in C.
21:28:21 <jsnx> Cale: does that make any actual difference?
21:28:24 <jfredett> I'm generalizing away from Set for my DAG library, and i realized I still needed list-like properties
21:28:31 <jsnx> oh, yes it would, i guess
21:28:45 <Cale> If f: X -> Y and g: Y -> Z, are arrows in C^op, then g . f, the composite, is defined as the arrow f . g as composed in in C
21:28:50 <Cale> er, -in
21:28:56 * shapr tries puredata
21:29:02 <Cale> See how that works?
21:29:05 <jsnx> yes
21:29:14 <monochrom> There will come a time when you want C^op instead of C.
21:29:50 <skew> shapr: do you know prolog?
21:29:53 <jsnx> so, what i do not see is how we take f from C and use it in C^op in some confusing way
21:30:01 <jsnx> like happened with h
21:30:05 <Cale> It's a common time saver when you're talking about functors, and you want to express the idea of a contravariant functor -- one which swaps the direction of the arrows as it goes.
21:30:06 <shapr> skew: Nope
21:30:23 <shapr> skew: Is gnu prolog decent?
21:30:26 <monochrom> (Yes, I have contravariant functor in mind. :) )
21:30:38 <Cale> jsnx: Well, the arrow f in C has the type X -> Y, say, then in C^op, it is instead an arrow Y -> X
21:30:40 <jsnx> shapr: check out XSB for prolog...
21:31:04 <jsnx> shapr: it has SQL hooks, XPath hooks, crazy shit...
21:31:12 <shapr> Sounds entertaining.
21:31:18 <Cale> So we're reusing the arrows of our original category in our new category.
21:31:20 <jsnx> shapr: i just installed it
21:31:30 <Cale> But with different source and target.
21:31:43 <skew> shapr: before that, do you know Coq?
21:31:47 <jsnx> Cale: however, in the example on page 7, we took h, and used it to make the commutativity triangle
21:32:02 <Cale> jsnx: right, that triangle is happening in the original category C.
21:32:06 <jsnx> oh!
21:32:12 <jsnx> i see
21:32:48 <Cale> (it could perhaps be clearer on that point, but those objects are objects of C and not of X/C
21:32:51 <Cale> )
21:33:03 <jsnx> so, say we have a morphism h, and we say, in my new category, it goes from (Y_1, f_1) to (Y_2, f_2)
21:33:17 <jsnx> how do we know what actually happened to h in this case?
21:33:26 <jsnx> would not its guts be all different in the new category?
21:33:35 <Cale> Arrows don't have guts.
21:33:50 <Cale> (that, I think, is exactly what is so confusing for you here)
21:34:14 <jsnx> Cale: i thought the guts were the part with the bar arrow  |->  or â¦
21:34:38 <Cale> Yeah, in some categories, like the category of sets, objects have elements.
21:35:07 <Cale> But this slice category isn't really one of those.
21:35:14 <jsnx> mmmm
21:35:17 <Cale> Though I suppose you could treat it as such.
21:35:28 <Cale> The guts of h would be completely unchanged.
21:35:59 <jsnx> so, what i do not get, is: in the first category, h did something...and in the slice over, it must do something else...but only the type has changed
21:36:01 <Cale> The elements of (A, f) would be the elements of A
21:36:03 <shapr> skew: No, I don't know Coq, though I've heard it's nifty.
21:36:20 <shapr> skew: How would I get started with Coq?
21:36:38 <Cale> and the arrow h: (Y_1, f_1) -> (Y_2, f_2) would make the same assignments as the arrow h: Y_1 -> Y_2 in the original category.
21:36:47 <skew> shapr: the book seems to be pretty good
21:37:04 <shapr> Which book are you reading?
21:37:09 <Cale> The arrow doesn't do something new, but its new type tells you something extra about it.
21:37:13 <skew> shapr: I also looked at Adam Chlipala's class execercises, the official tutorial, and all the Epigram papers
21:37:18 <skew> Coq'Art
21:37:23 <monochrom> I learned Coq by reading the official Coq tutorial
21:37:35 <Cale> In particular, since h: (Y_1, f_1) -> (Y_2, f_2), this means that h f_1 = f_2
21:37:36 <jsnx> Cale: if it has different arguments, how can it make the same assignments?
21:37:54 <jsnx> oh, wait
21:38:02 <Cale> jsnx: I'm saying that the underlying set of (Y_1, f_1) is the same as the underlying set of Y_1
21:38:23 <Cale> If you really want to be picky and talk about underlying sets.
21:38:35 <jsnx> well, i don't even know what that means
21:38:43 <skew> I learned some things and was confused by some other things
21:38:55 <jsnx> i am thinking it's kind of like partial evaluation
21:38:56 <Cale> There might be another way to assign underlying sets to the slice category, but I don't know what it would be.
21:39:27 <skew> the book does good things warning against possible but execssively complicated ways of doing things
21:39:35 <Cale> jsnx: Let's define a really small category, and construct a slice under an object in it.
21:39:42 <jsnx> yes, lets
21:39:50 <jsnx> s/lets/let's/
21:40:34 <skew> and also explain how to write tactics and how to do proof by reflection, both are extremely cool
21:40:45 <jsnx> write tactics?
21:40:50 * Cale attempts to work out if the example he's thinking of is too simple or not.
21:41:02 <jsnx> oh, not part of our discussion...
21:41:05 <monochrom> proof by reflection?
21:41:09 <jsnx> skew: sorry
21:41:49 <skew> tactics are neat!
21:42:06 <Cale> hmm...
21:42:49 <Cale> okay
21:43:28 <skew> monochrom: you define an AST for certain kinds of Coq expressions you want to reason about
21:43:35 <jsnx> aye?
21:43:53 <Cale> It's hard to come up with a trivial example which is also interesting :)
21:43:55 <skew> monochrom: an eval function and convertability lets you turn a goal into some goal about the AST
21:44:07 <Cale> So let's use the category of sets
21:44:11 <oerjan> Cale: some actual graph?
21:44:21 <skew> monochrom: and then you can reuse one big theorem
21:44:38 <Cale> oerjan: yeah, that's what I was thinking, but it's tricky to come up with one with only a couple of objects where the slice is interesting
21:44:47 <skew> monochrom: like, you can define an AST of list expressions - Leaf [a] | App AST AST | Cons a AST
21:45:17 <skew> eval (Leaf l) = l, eval (App l r) = eval l ++ eval r, eval (Cona a r) = a:eval r
21:46:31 <skew> then if you've got many equalities between list expressions that hold by associativity
21:46:54 <Cale> Well, let's work with the category of sets, though this really defeats the point I was trying to make, perhaps it'll still help :)
21:47:07 <Cale> and let X be any one-element set
21:47:39 <Cale> So effectively, a map f: X -> Y will pick out some element of Y
21:48:01 <oerjan> Cale: hm, what about paths between pairs of points?
21:48:07 <Cale> and now what does it mean for that triangle to commute?
21:48:25 <skew> rather than using lemmas like app_ass a bunch of times, you write one function that reassociates an AST, prove one theorem that evaling the reassociated AST gives the same list, and then use change to turn an equality of list expressions into an equality of eval of ASTs, and apply the big theorem
21:48:36 <Cale> That is, for a map h: Y_1 -> Y_2 to have the property that h f_1 = f_2?
21:48:39 <jsnx> Cale: well, hmm
21:48:45 <oerjan> (at least that isn't a concrete category)
21:48:53 <hpaste>  (anonymous) annotated "How to optimize?" with "(no title)" at http://hpaste.org/4856#a2
21:49:01 <jsnx> it means that h picks x in X
21:49:31 <Cale> Okay, let's call x the sole element of X
21:49:45 <Cale> then h(f_1(x)) = f_2(x)
21:49:50 <jsnx> Cale: that's what i meant
21:50:05 <jsnx> h inverts them both
21:50:13 <Cale> inverts?
21:50:29 <Cale> h might do anything at all to the other points in Y_1
21:50:55 <Cale> but we know that it sends the element 'marked' by f_1 to the element in Y_2 which was 'marked' by f_2
21:51:00 <jsnx> Cale: well, it has to map them to x Ïµ X
21:51:18 <jsnx> oh wait, what?
21:51:29 <jsnx> okay, just a minute
21:51:44 <jsnx> okay, i missed the point
21:51:48 <Cale> You can picture a pair (Y, f: X -> Y) as being the set Y where one of the elements has been coloured blue, so we can tell it apart from the others.
21:52:06 <jsnx> h : X â Y
21:52:09 <jsnx> sorry
21:52:34 <Cale> and a morphism h:(Y,f) -> (Z,g) as being a function from Y -> Z such that the blue point in Y is sent to the blue point in Z.
21:53:24 <hpaste>  tehgeekmeister pasted "Attempting to bring state into my flowchart program." at http://hpaste.org/4866
21:54:46 <Cale> So the intuition, at least in most cases, is that the "image" of X in Y_1 and Y_2 under the maps f_1 and f_2, is some substructure which gets preserved by the arrows (Y_1, f_1) -> (Y_2, f_2)
21:55:06 <Cale> But the arrows themselves you can think of as plain old arrows Y_1 -> Y_2
21:55:32 <Cale> Just that in order to be arrows in the slice category (Y_1, f_1) -> (Y_2, f_2), they must preserve that additional structure.
21:55:34 <jsnx> jfredett: no, the point is profit off of people's shallow fascination
21:55:37 <jsnx> oops
21:56:49 <Cale> jsnx: make sense?
21:56:51 <jsnx> Cale: so, this is different notation then a function foo : (A, B) â (C, D)
21:56:53 <jsnx> ?
21:56:57 <Cale> jsnx: (even if only vaguely)
21:57:13 <jsnx> Cale: i understand your argument
21:57:15 <Cale> um, in Haskell?
21:57:19 <jsnx> Cale: no
21:57:27 <jsnx> A and B and C and D are objects
21:57:40 <Cale> Oh, in the Cartesian product category?
21:57:58 <jsnx> Cale: yes
21:58:11 <Cale> Where an arrow (A,B) -> (C,D) is a pair of arrows, one from A -> C, and another B -> D
21:58:16 <Cale> that's different entirely.
21:58:20 <jsnx> aha
21:58:37 <Cale> But see, there we define the arrows in a new way as well.
21:58:46 <Cale> Reusing the old arrows.
21:58:57 <jsnx> when i saw `h : (A, f) â (B, g)` i thought it was an arrow on pairs
21:59:07 <Cale> You mean a pair of arrows? :)
21:59:20 <jsnx> eh?
21:59:31 <Cale> Well, those are the same thing :)
21:59:57 <Cale> (at least in the product category)
22:00:02 <jsnx> Cale: aha
22:00:26 <Cale> But f and g aren't objects, which should be the first sign that something is different.
22:00:48 <jsnx> Cale: but `h : (A, f) â (B, g)` is not a pair of arrows
22:00:54 <Cale> Also, note that the objects in C/X are the same as those for X/C, but the arrows between any pair are different.
22:01:04 <Cale> No, it's just one arrow A -> B
22:01:15 <Cale> which happens to satisfy an additional constraint
22:01:19 <jsnx> aha!
22:01:32 <jsnx> well it is so annoying they used tuples for that
22:01:41 <Cale> What else would they use?
22:02:26 <Cale> The objects of the slice under X are pairs, consisting of an object Y from C, and a morphism from X -> Y in C.
22:03:33 <Cale> The morphisms of the slice under X in C from (Y_1, f_1) to (Y_2, f_2) are the morphisms h from Y_1 to Y_2 in C such that h f_1 = f_2
22:03:53 <jsnx> Cale: i'll have to think about what other notation to use
22:04:00 <jsnx> but i understand much better now
22:04:14 <jsnx> maybe they could have used `|` for such that, or something like that
22:04:18 <Cale> If you want, you can tag the pairs somehow, write them differently or something, but there's not a whole lot of point to that.
22:05:09 <Cale> So yeah, the set of morphisms from (Y_1, f_1) to (Y_2, f_2) is the set {h: Y_1 -> Y_2 in C | h f_1 = f_2}
22:05:12 <jsnx> Cale: well, the point is, n00bs would see there was something funny happening, and not get all confused
22:06:29 <jsnx> Cale: thank you for your time, though
22:06:35 <Cale> No problem :)
22:07:16 <Cale> When you're defining a category, all you have to do is define the objects, and for any pair of objects, define the morphisms, and then say how those morphisms are supposed to compose (if it's not obvious already)
22:07:42 <Cale> and the morphisms between two objects don't have to be related to anything, they can be any set at all.
22:07:53 <Cale> as long as you can define the composition
22:08:41 <Cale> Here, it's somewhat obvious what the composition should be, since it's just stolen from the original category.
22:09:02 <jsnx> in the slice case
22:09:05 <Cale> yes
22:09:33 <Cale> btw, the opposite category is actually defined on page 6 :)
22:09:45 <Cale> (very briefly)
22:11:25 <jsnx> oh, hmmmm
22:13:21 <Cale> The idea of the opposite category is that it's just the same as the original category, with all the arrows reversed.
22:13:47 <jsnx> oh, yes, i see it no
22:14:06 <jsnx> s/no/know/
22:14:20 <jsnx> s/know/now/
22:14:26 <jsnx> lolz
22:15:22 <Cale> Later, they'll define the comma category, which is a generalisation of the slice construction.
22:15:42 <Cale> (that's on page 42)
22:15:53 <Cale> (but it could have been on page 8 or so :)
22:16:15 <hpaste>  tehgeekmeister annotated "Attempting to bring state into my flowchart program." with "Potential solution of the type problem, but how do I recurse and thread the state at the same time?" at http://hpaste.org/4866#a1
22:16:56 <Cale> tehgeekmeister: don't use runStateT yet.
22:17:49 <Cale> tehgeekmeister: or else include the extra stuff which the state is supposed to be threaded to inside the do-block inside the runStateT
22:18:11 <Cale> (which should probably be split off into its own definition, btw)
22:18:58 <Cale> When you use runState/runStateT, the final state is given as part of the resulting pair, but that means you'll have to thread it explicitly to whatever comes next in your computation.
22:19:09 <tehgeekmeister> the state should be threaded right back into another call of answerLoop
22:19:19 <glguy> case take 4 x of
22:19:23 <Cale> So make a definition:
22:19:40 <Cale> answerLoop = do answer <- askQuestion historyQuestion
22:19:50 <Cale>                 answers <- answerLoop
22:20:06 <Cale>                 return (answer:answers)
22:20:27 <tehgeekmeister> wow, that was simple.
22:20:49 <Cale> However, in this monad, you might have a problem with finishing :)
22:21:07 <tehgeekmeister> yes, it was much easier when i had no state to deal with
22:21:17 <Cale> does askQuestion indicate in any way when you're done?
22:21:32 <tehgeekmeister> askQuestion simply asks a question and returns the response
22:22:03 <tehgeekmeister> runQuestion asks a question, feeds it's result to the lambda of the question, and recurses to ask the next question
22:22:05 <Cale> ah, so is there something in that response which would let you know when you should quit?
22:22:23 <Cale> Because you'll never finish asking questions, the way I wrote that.
22:22:29 <Cale> (and never reach that return)
22:22:35 <dmwit> The lambda would have to know how to end, I guess.
22:23:01 <Cale> But if you were to check 'answer' to see if it's something like "done"
22:23:08 <Cale> then you could decide whether to loop again
22:23:19 <Cale> also, getLine >>= return = getLine
22:23:24 <tehgeekmeister> if instead of Just (Question,Maybe String) it returns Nothing, the loop ends in runQuestion
22:24:09 <Cale> but askQuestion doesn't apply f x, which it probably should
22:24:12 <Cale> er
22:24:16 <Cale> or answerLoop?
22:24:36 <Cale> Either way.
22:24:40 <tehgeekmeister> yes, that's the only way it can tell which question to go to next.
22:24:44 <Cale> right
22:24:53 <Cale> So you want something like
22:25:18 <Cale> askQuestion x = do putStrLn $ q x; fmap (f x) getLine
22:25:50 <Cale> Oh, also, this will still be a type error, if you're in a state transformed monad...
22:26:09 <Cale> But it's a valid IO computation, so you can just liftIO it when you run it.
22:26:18 <Cale> Where's the state handled?
22:26:39 <Cale> Also, it may be easier, since the machinery is already mostly there, to just handle the state yourself for now.
22:26:50 <Cale> know what I mean by that?
22:27:00 <tehgeekmeister> yes, thread the state variable manually
22:27:03 <tehgeekmeister> i could manage that
22:27:13 <Cale> That is, you'd have the state passed to f, and it would return a new state (assuming that's where you need it)
22:27:52 * bos tries to decide between a simple example for the state monad, and something more fun and meaty.
22:28:24 <bos> i haven't got a simple example in mind, but the meaty alternative that i'm itching for is affine arithmetic.
22:28:37 <tehgeekmeister> *googles affine arithmetic
22:28:42 <bos> unfortunately, it's probably too meaty.
22:28:56 <tehgeekmeister> gah!  that's beyond me.
22:29:01 <tehgeekmeister> i'm just learning linear algebra.
22:29:16 <bos> least-squares approximations to trigonometric functions! simplified zonotypes! eep!
22:29:29 <bos> er, zonotopes.
22:29:46 <ricky_clarkson> Shopping is hard. Let's do maths.
22:29:56 <MyCatVerbs> ricky_clarkson: YES.
22:31:20 <monochrom> hehehehe
22:33:42 <tehgeekmeister> Cale: so if instead i had lambdas of type String -> (State, Maybe Question), and a runQuestion that took both a state argument and a question argument, that'd be reasonable?
22:34:12 <zeeeee> Cale, hi
22:34:18 <tehgeekmeister> (where State is really just an association list or something of the sort, probably, it doesn't matter too much what.)
22:35:29 <tehgeekmeister> bos: since you seem to be around, is there any word on real world haskell?
22:35:55 <bos> tehgeekmeister: working hard on it
22:36:15 <tehgeekmeister> bos: as long as it's not dead, i can be patient.
23:18:56 <dons> ?yow
23:18:57 <lambdabot> Those aren't WINOS -- that's my JUGGLER, my AERIALIST, my SWORD
23:18:57 <lambdabot> SWALLOWER, and my LATEX NOVELTY SUPPLIER!!
23:19:09 <hpaste>  tehgeekmeister annotated "Attempting to bring state into my flowchart program." with "Basic, functional version with manual state threading." at http://hpaste.org/4866#a2
23:25:44 * tehgeekmeister wonders if he just kinda reinvented the writer monad instead of state
23:25:52 <quicksilver> I get my latex novelties from www.ctan.org
23:26:31 <quicksilver> does look a bit like the writer monad, too
23:26:33 <tehgeekmeister> ouch, i think i did.
23:26:43 <tehgeekmeister> that's not what i wanted.
23:26:45 <tehgeekmeister> i wanted state.
23:27:10 * tehgeekmeister gets back to wrok
23:27:12 <tehgeekmeister> *work
23:27:32 <sarah> in main where should you use let x = ... as opposed to x <- ...
23:28:53 <quicksilver> sarah: let x = foo if foo has the type you want. x <- foo if foo is an IO thing.
23:28:58 <quicksilver> as a general rule
23:29:02 <jsnx> sarah: well, you *can* always use x <-
23:29:14 <jsnx> for example `x <- return 7`
23:29:49 <sarah> an io thing?
23:29:52 <gurughantaal> quicksilver: what do you use to edit tex, emacs?
23:30:00 <nanothief> sarah: eg x <- getChar
23:30:05 <sarah> ah thx
23:30:06 <jsnx> :t getChar
23:30:08 <lambdabot> IO Char
23:30:26 <jsnx> :t return 7
23:30:32 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
23:30:38 <jsnx> eh?
23:30:55 <jsnx> oh, yes, that's right
23:31:10 <jsnx> :t return (7 :: Int)
23:31:10 <lambdabot> forall (m :: * -> *). (Monad m) => m Int
23:31:15 <ari> :t (return 7) :: IO Int
23:31:15 <lambdabot> IO Int
23:31:21 <sarah> also not sure what a monad is is there an easy to understand explanation?  are the different monads just different domain specific languages that let you do imperitive stuff
23:31:40 <jsnx> sarah: i am still trying to understand monads
23:31:46 <jsnx> after many months of reading
23:31:56 <sarah> heh :)
23:32:06 <nanothief> sarah: do you know unix shell scripting?
23:32:15 <sarah> a little
23:32:16 <jsnx> sarah: basically, monads server to *order* computations
23:32:37 <dons> ?users
23:32:38 <lambdabot> Maximum users seen in #haskell: 401, currently: 381 (95.0%), active: 15 (3.9%)
23:33:07 <jsnx> > do { x <- return "foo" ; putStrLn x }
23:33:08 <lambdabot>  <IO ()>
23:33:09 <hpaste>  tehgeekmeister annotated "Attempting to bring state into my flowchart program." with "Sanity check: does this look like manual state threading to everyone else too?" at http://hpaste.org/4866#a3
23:33:30 <jsnx> > do { putStrLn x ; x <- return "foo" }
23:33:30 <lambdabot>  Parse error at "}" (column 37)
23:33:48 <jsnx> > do { putStrLn x }
23:33:48 <lambdabot>   Not in scope: `x'
23:34:03 <jsnx> > do { putStrLn x ; x <- return "foo" ; }
23:34:04 <lambdabot>  Parse error at "}" (column 39)
23:34:13 <jsnx> why parse error?
23:34:30 <jsnx> > do { x <- return "foo" ; putStrLn x ; y <- return "bar" }
23:34:31 <lambdabot>  Parse error at "}" (column 57)
23:34:33 <nanothief> sarah: think of echo '3' | cat
23:34:53 <nanothief> sarah: in haskell this would be return "3" >>= print
23:35:09 <sarah> ah ok i think i get that
23:35:19 <nanothief> the do notation gets rid of a lot of the >>= symbols
23:35:35 <sarah> so >>= is sort of like a pipe?
23:35:41 <nanothief> eg do x <- return 3 \n print x
23:35:47 <jsnx> sarah: very much
23:35:58 <sarah> ah cool :)
23:36:23 <nanothief> when you get the type of an IO monad, like getChar, it will be something like IO Char
23:36:45 <nanothief> the >>= extracts the Char from inside the monad, and passes it to the next function
23:36:54 <jsnx> > do { x <- return "foo" }
23:36:54 <lambdabot>  Parse error at "}" (column 24)
23:37:03 <jsnx> trippy
23:37:16 <jsnx> > do { x <- return "foo" ; putStrLn x ; y <- return "bar" ; putStrLn y }
23:37:18 <lambdabot>  <IO ()>
23:37:31 <nanothief> jsnx: the ; occurs at the start of the statement, not the end
23:37:43 <nanothief> eg do { ; x <- return "foo" ; print x }
23:37:58 <jsnx> > do { ; x <- return "foo" }
23:37:58 <lambdabot>  Parse error at "}" (column 26)
23:38:11 <jsnx> > do {; x <- return "foo" ; putStrLn x ; y <- return "bar" ; putStrLn y }
23:38:11 <lambdabot>  <IO ()>
23:38:20 <nanothief> jsnx: also, the last expression of a do must be an expression :P
23:38:28 <jsnx> nanothief: right, right
23:38:47 <wolverian> that's return "foo" >>= \x ->
23:38:51 <wolverian> not exactly valid
23:39:08 <jsnx> it's too bad lambdabot does not actually print
23:40:30 <jsnx> > do {; y <- return "foo" ; putStrLn x ; x <- return "bar" ; putStrLn y }
23:40:31 <lambdabot>   Not in scope: `x'
23:40:37 <jsnx> > do { y <- return "foo" ; putStrLn x ; x <- return "bar" ; putStrLn y }
23:40:38 <lambdabot>   Not in scope: `x'
23:40:46 <jsnx> that does what i wanted, anyhow
23:41:29 <jsnx> > let { a = b + 2 ; b = 7 }
23:41:29 <lambdabot>  Parse error at end of input
23:41:37 <jsnx> >@let { a = b + 2 ; b = 7 }
23:41:55 <jsnx> @let { a = b + 2 ; b = 7 }
23:41:55 <lambdabot> <local>:3:0: parse error on input `{'
23:42:06 <jsnx> > let { a = b + 2 ; b = 7 } in a
23:42:07 <lambdabot>  9
23:42:17 <jsnx> bollocks
23:42:21 <sarah> in a?
23:42:32 <jsnx> sarah: yeah
23:42:41 <nanothief> let sets some variables to be used in another expression
23:42:42 <jsnx> sarah: that is a let outside of a do block
23:42:52 <jsnx> and you can define them in any order
23:43:05 <nanothief> eg let { a = 3 } in a * a
23:43:05 <jsnx> notice how i had a before b, but used b in a
23:43:15 <sarah> ah yeah knew that:) whats the "in a" do though
23:43:27 <wolverian> sarah, the syntax is 'let <bindings> in <expression>'
23:43:41 <jsnx> sarah: it tells you what the `let` applies to
23:43:46 <sarah> and the expression is returned? got it ty
23:44:08 <jsnx> sarah: well, not returned, really...
23:44:49 <jsnx> i guess i'm just being semantically picky
23:44:55 <sarah> yeah sorry
23:45:12 <sarah> im from python used to its terms
23:45:26 * glguy is knee deep in typeclasses insanity... instance (LookupLogic (Arg r FArg a) BS.ByteString t, IsArg a, Apply b c d) => Apply (t -> b) (Arg r FArg a :> c) d where
23:45:37 <wolverian> ouch
23:45:45 <glguy> this ought to collapse down once the logic is finally merged though
23:45:49 <glguy> but I'm going it piecewise
23:45:52 <tehgeekmeister> it's essentially the same.  i still think in terms of returns myself, being from python/ruby, even tho i know better.
23:45:57 <wolverian> consider using longer type variable names :)
23:46:13 <glguy> wolverian: job security
23:46:18 <glguy> :-p
23:46:31 <tehgeekmeister> glguy: you just made me feel a lot better about my n00bish monad woes, thank you.
23:46:34 <wolverian> sure it's not just the warm fuzzy feeling it gives? ;p
23:46:59 <tehgeekmeister> it's nice to know someone's suffering more, somewhere.
23:47:02 <Jomyoot_> Are haskell programms cool? like we get women?
23:47:25 <wolverian> uh..
23:49:00 <jsnx> Jomyoot_: no -- we respect women
23:49:11 <jsnx> Jomyoot_: like the ones on this channel now, ass hole
23:49:35 <Lemmih> ?faq Can Haskell get you laid?
23:49:35 <lambdabot> The answer is: Yes! Haskell can do that.
23:49:35 <TSC> Well, you scared him off
23:49:53 <jsnx> TSC: he was a troll
23:49:55 <TSC> ... temporarily
23:50:19 <jsnx> ?faq can
23:50:20 <lambdabot> The answer is: Yes! Haskell can do that.
23:51:31 <Jomyoot> I convinced my girlfriend that Lisp is awesome.
23:51:46 <jsnx> Jomyoot: lolz, then maybe that can get you laid
23:51:47 <Jomyoot> Now I am convincing her again that Haskell is cool too
23:52:24 <jsnx> Jomyoot: she's going to think you're unstable and unreliable -- next week it'll be Alice ML
23:52:39 <Jomyoot> Well she is complaining that exactly
23:52:46 <glguy> Isn't this what #haskell-blah is for almost exactly?
23:52:47 <Jomyoot> The other day I staqrted talking about Ocaml
23:53:14 <Jomyoot> she said she won't talk to me until i settle on a language
23:53:26 <jsnx> Jomyoot: lolz
23:53:37 <jsnx> glguy: yes, exactly
23:53:53 <jsnx> Jomyoot: please join #haskell-blah
23:54:56 <Jomyoot> what IDE or Editor has the best syntax highlighting and auto identing support for Haskell?
23:55:04 <jsnx> ed
23:55:11 <jsnx> ed is the standard text editor
23:55:15 <Jomyoot> I thought Emacs was really cool how it supports Lisp with auto indenting . I just hit Tab and it's all fixed
23:55:29 <Jomyoot> Is there such an editor for Haskell. where I hit tab and it fixes everything?
23:55:35 <TSC> emacs?
23:55:40 <jsnx> Jomyoot: there are emacs extensions for haskell
23:55:46 <jsnx> or the other way around, i mean
23:55:57 <Jomyoot> Does it auto indent too?
23:56:06 <jsnx> Jomyoot: don't know, i use VIM
23:56:11 <TSC> Yes
23:56:12 <Jomyoot> does VIM auto ident?
23:56:27 <jsnx> Jomyoot: i never use that part of it -- but yes, there are plugins for that
23:56:53 <Cale> Jomyoot: It does auto indenting, but it's a little strange in that regard -- sometimes you have to type the start of a line before it will be able to guess where you want to start it.
23:57:30 <Jomyoot> am i correct to say emacs has more toys than vim?
23:57:34 <jsnx> my indentation style is so beautiful and subtle, no text editor could emulate it
23:57:35 <Cale> (In particular, it seems to have this condition with let/in, if I'm remembering correctly.)
23:57:39 <tehgeekmeister> TSC: is the auto indent any good for you?  i'm an emacs noob, but it's nearly broken, for example in do blocks it's relatively useless.
23:57:50 <TSC> Works for me
23:57:54 <jsnx> Jomyoot: yes
23:58:01 <TSC> You sometimes have to press tab more than once
23:58:10 <Cale> Jomyoot: Yes, I believe so. Really, any editor which can convert tabs to spaces and can syntax colour your code should do.
23:58:49 <Cale> (you really don't want any ascii tab characters ending up in your source files)
23:59:03 * jsnx hugs Cale
23:59:24 * Cale ghci jsnx 
