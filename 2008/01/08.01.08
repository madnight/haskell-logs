00:01:30 <jsnx> actually, i meant self-important
00:01:32 <jsnx> oops
00:01:57 <tehgeekmeister> Cale: would you mind taking a look at the most recent incarnation i've hpasted to see if it looks like sane state threading? i really don't want to record another version that's not doing what i think or doing something horribly wrong.  http://hpaste.org/4866#a3
00:02:31 <jsnx> Jomyoot: helvetica
00:02:50 <jsnx> oops, wrong window again
00:02:51 <Cale> tehgeekmeister: Looks okay to me :) Does it compile?
00:03:09 <tehgeekmeister> Cale: yep, and so far it seems to do what i expect.
00:03:27 <Cale> Yeah, I'm fairly convinced that it's correct then :)
00:03:38 <tehgeekmeister> tehgeekmeister: just the first time i ended up making a mini writer monad on accident, and i don't like messing up my repository.
00:03:57 * tehgeekmeister is talking to himself.  probably a sign it's time to go to bed.
00:05:05 <tehgeekmeister> Cale: thanks for your help
00:09:21 <dons> anyone feel up to commenting on this, http://python-tips-gw.blogspot.com/2008/01/choosing-new-language.html
00:09:22 <lambdabot> Title: Python: Choosing a new language, http://tinyurl.com/2367qn
00:09:29 <dons> guy wondering whether to use lisp, python or haskell.
00:09:43 <quicksilver> Jomyoot: one side effect of semantic indentation is that editors can't autoindent perfectly. Because they can't know what you mean.
00:09:54 <quicksilver> Jomyoot: all a good editor can do is let you choose between the sensible choices.
00:10:01 <quicksilver> Jomyoot: emacs does OK, although it could be better.
00:10:06 <Korollary> dons: that's from comp.lang.functional actually iirc
00:11:14 <dons> oh, maybe. just flew by in my rss feed
00:12:50 <dons> interesting, logging on freenode, http://blog.freenode.net/?p=68
00:12:52 <lambdabot> Title: staffblog » Blog Archive » More blogging about logging&#8230;
00:13:16 * glguy needs type level let bindings...
00:13:50 <dons> anyone have a problem with yet more public logging of #haskell?
00:14:25 <jsnx> dons: like, it's a negative thing?
00:14:32 <jsnx> dons: at least they don't log #haskell-blah
00:14:48 <dons> right. but i think #haskell people expect to be publically logged?
00:14:56 <dons> it already is in a few places
00:15:07 <jsnx> dons: yeah, if find it valuable
00:15:14 <nanothief> a searchable log would be nice
00:15:21 <jsnx> dons: i search the logs for links and stuff
00:16:19 <nanothief> jsnx: how do you search it?
00:16:51 <dons> ok, so these guys will be logging #haskell, with some bot, in the future, http://www.irseek.com/
00:16:52 <lambdabot> Title: IRSeeK.com (Beta) - The most comprehensive public-chatroom search engine on the  ...
00:16:54 <jsnx> nanothief: well, i rely on dates, actually
00:17:06 <jsnx> which is not very flexible
00:18:13 <sjanssen> glguy: maybe clever use of type synonyms can help?
00:18:22 <jsnx> wow, they have a nice interface
00:18:30 <glguy> sjanssen: unfortunately not in this case
00:18:43 <glguy> the instance depends on all three arugments of the type:
00:18:46 <glguy> A x y z
00:20:23 <nanothief> jsnx: well actually searching in google with site:http://tunes.org/~nef/logs/haskell/ gives good results
00:20:24 <lambdabot> Title: Index of /~nef/logs/haskell
00:20:29 <Tac-Tics> Who here is a Category Theory jock?
00:20:30 <nanothief> just thought of that
00:20:45 <jsnx> nanothief: aren't their logs out of date?
00:22:52 <nanothief> jsnx: they seam to be up to date
00:22:54 * glguy wonders if anyone else has found occasion for:
00:23:04 <glguy> f a b `uncurry` g x y
00:23:41 <glguy> where the last two arguments just happened to match up in the end
00:24:06 <Cale> :t ?f ?a ?b `uncurry` ?g ?x ?y
00:24:11 <lambdabot> forall t t1 a b c t2 t3. (?f::t -> t1 -> a -> b -> c, ?a::t, ?b::t1, ?g::t2 -> t3 -> (a, b), ?x::t2, ?y::t3) =>
00:25:06 <Tac-Tics> anyone here want to help me out with a category problem?
00:27:06 <Tac-Tics> I'm trying to figure out whether or not I have arrow composition for the category of partial functions right or not
00:27:37 <Tac-Tics> My new book lists sets with partial funcs as a category, but doesn't give the details or solution in the back of the book
00:32:27 <Cale> There should be only one reasonable way to define it.
00:32:38 <Cale> So if what you have seems reasonable, it should be right :)
00:33:14 <Tac-Tics> Is it (f * g)(x) = f(g(x)) if g(x) is defined or undefined otherwise?
00:33:38 <Tac-Tics> like in Maybe?
00:33:48 <Cale> roughly, yes
00:34:06 <Tac-Tics> roughly? is there a smoother way to do it?
00:34:50 <Cale> If f: A -> B, and g: B -> C, then g . f is defined as the map which is defined on the subset of points x where f(x) is defined, and g(f(x)) is defined.
00:35:18 <Cale> and (g.f)(x) = g(f(x))
00:35:21 <Cale> in that case
00:35:47 <glguy> Is there any documentation on generically folding arbitrary sized tuples? (data a :> b = a :> b  data () = ()   forexample)
00:35:54 <glguy> sized/typed
00:35:54 <Tac-Tics> ah, ok, so you just would avoid the "undefined" terminology and refine the subset of the domain f . g is defined on
00:36:17 <Cale> Tac-Tics: Well, you can do it either way, but that'd be my approach.
00:36:33 <Tac-Tics> your way is the more proper way
00:36:42 <Cale> Tac-Tics: You can also define partial functions explicitly as sets of pairs, which is the really proper way :)
00:37:30 <quicksilver> it's perfectly sane to treat "undefined" as a real value
00:37:43 <Cale> Usually, when A and B are sets, a function f: A -> B is a set of pairs (a,b) with a in A, and b in B, such that for each a in A, there is exactly one b in B for which (a,b) is in f.
00:37:45 <Tac-Tics> As a C.S. major, partial functions form the basis of all existence
00:37:46 <quicksilver> that's just taking the 'pointed-set' interpretation of partial functions.
00:38:12 <Cale> With partial functions, you can change 'exactly one' to 'at most one'
00:38:26 <Cale> When (a,b) is in f, we write f(a) = b
00:38:47 <Tac-Tics> A function is an awful specific kind of object =-)
00:39:52 <Tac-Tics> Cool then, I'm glad I got that right
00:40:09 <Tac-Tics> The category theory book I got looks not too painful, and I look forward to reading it
00:40:21 <Cale> Of course, quicksilver's take is also a reasonable way to handle it. You can define a partial function f: A -> B as a function f: A -> B disjoint union {*}, where {*} just means some one element set.
00:40:59 <jsnx> http://programming.reddit.com/info/64th1/comments/c02u9mb
00:41:14 <Cale> Then it's easy to be explicit about how they compose.
00:41:32 <jsnx> that link is an "explanation of monads"
00:43:59 <Tac-Tics> why do people bother to write articles like that one above?
00:44:12 <Tac-Tics> How to furnish language X with feature from language Y
00:45:07 <Tac-Tics> Monads really have no place in python or any language with progn semantics and sideeffects =-/
00:45:32 <jsnx> because they are trapped by their conservative bosses
00:45:48 <jsnx> so they act out by reimplementing half of common lisp, as it were
00:45:53 <Tac-Tics> heh
00:46:16 * Tac-Tics has no sympathy for people who consider Python a constraining language
00:46:23 <Korollary> Heh. progn semantics.
00:46:27 <jsnx> Tac-Tics: why not?
00:46:34 <jsnx> Tac-Tics: you write PHP or something?
00:46:59 <matthew-_> morning world
00:47:20 <Korollary> good @localtime
00:47:52 <Tac-Tics> One of the Monad gods just shot down Pidgin =-(
00:48:34 <jsnx> some of their comments are great: "I had monads once, but they went away after I took some sulfa drugs."
00:48:36 <Tac-Tics> And yeah, I do PHP
00:48:56 <jsnx> Tac-Tics: i don't consider python constraining -- just unstructured
00:49:15 <jsnx> i want to be totally 1337 all the time
00:49:29 <Tac-Tics> Python, like all great languages, has its glaring flaws
00:49:33 <jsnx> i don't ever want to say the word 'superclass' again
00:49:58 <matthew-_> jsnx: err, there are super classes in haskell ;)
00:50:20 <jsnx> matthew-_: what i mean is, i never want to think in goofy OO ways again
00:51:17 <matthew-_> well, it's worth knowing anyway just so you can convert people to functional
00:52:14 <matthew-_> the last straw for me was when my final-year undergrad project (which is worth a lot of marks) started showing bugs in javac and in the sun jvm.
00:52:29 <matthew-_> "At that point I decided I'd had enough"
00:52:29 <jsnx> matthew-_: wow
00:52:30 <Tac-Tics> Convert the heathen imperativists!
00:52:33 <Korollary> That is actualy not a good reason.
00:52:47 <Korollary> GHC has bugs, too. All software has.
00:53:08 <jsnx> GHC has bugs?
00:53:12 <Tac-Tics> Your Java ways can lead you only down a path to Object Oriented Sin!
00:53:15 <jsnx> ;_;
00:53:22 <mux> I think it would probably make more sense to implement applicative functors in python than monads
00:53:26 <jsnx> not just sin -- hell
00:53:36 <matthew-_> yeah, but filing GHC bugs means you get to talk to the Great Men of Haskell. Not some faceless corporation
00:53:48 <jsnx> mux: lolz, applicative functors are not fashionable yet
00:53:54 <Tac-Tics> Do not make a false idol out of your design patterns
00:54:16 <mux> jsnx: yeah they're not so hype :)
00:54:48 <Tac-Tics> Transcend into the light of the closure and the glory of the lambda
00:54:59 <mux> lol
00:55:10 <sclv> 2008 will be the year of Control.Applicative
00:55:11 <jsnx> mux: *hip*
00:55:25 <jsnx> sclv: you heard it here first
00:55:31 <sclv> I'm so getting a <*> tatoo.
00:55:36 <mux> lol
00:55:52 <mux> I've been seduced by Control.Applicative too
00:55:57 <sclv> s/tatoo/tattoo /
00:55:57 <jsnx> i want a âˆ˜ tattoo
00:56:10 <mux> the paper of mcbride and patterson is nice
00:57:25 <quicksilver> all papers by either mcbride or patterson are nice :)
00:58:31 <matthew-_> they must have written some utter drivel at some point in their lives? Surely all of us have?
00:59:37 <jsnx> matthew-_: they wrote it for their moms ;_
01:00:21 <matthew-_> Korollary: I've come across bugs in ghc. I've not come across bugs in the runtime
01:00:29 <Jomyoot> why some language has reference implementation and some languages not
01:00:29 <matthew-_> (yet)
01:00:38 <Jomyoot> like Haskell does not have reference implementation
01:00:41 <Jomyoot> whereas Ruby does
01:01:36 <jaa> which is the reference. Rubinius? JRuby? Matz 1.8 (what JRuby and Rubinius are based on) Matz 1.9/2.0 (all his new ideas) ? Ruby has no Haskell Report
01:02:23 <sclv> Jomyoot: a standard means it was designed, a reference implementation means it was assembled.
01:02:42 <sclv> or accumulated, maybe.
01:03:14 <sclv> Lots of proposed Haskell' features essentially have GHC as their reference implementation for the time being though.
01:03:25 <Jomyoot> What is Glasglow
01:03:27 <Jomyoot> is that a university?
01:04:38 <sclv> @go google
01:04:50 <lambdabot> Plugin `search' failed with: getHostByName: does not exist (no such host entry)
01:05:32 <mux> since I learnt about applicative functors, the extension proposal about being able to write things like (<- foo) seems kinda moot
01:05:49 <mux> since it can be written <*> foo, unless I'm missing something
01:06:09 <quicksilver> matthew-_: I guess the haskell runtime is smaller than the java one. I've never been bitten by a bug in the ghc runtime, but they have certainly existed.
01:06:29 <sclv> mux: you mean the patterns proposal?
01:06:45 <Korollary> Ecmascript 4 has a reference implementation.
01:07:05 <Korollary> I think R6RS has something like it, too.
01:07:07 <mux> sclv: I don't remember how it was called
01:08:09 <sclv> Korollary: I stand corrected.
01:09:25 <Tac-Tics> What do you guys mean by reference implementation? Do you mean canonical implementation?
01:10:24 <sclv> googling for it, it looks like ecmascript's reference implementation is in part a way to make sure the language is well formed before they finalize it?
01:11:11 <jsnx> Tac-Tics: i think the reference implementation is "the implementation that everything else should be compatible with
01:11:14 <jsnx> "
01:11:21 <Tac-Tics> ah
01:11:46 <sclv> it's pretty cool actually -- they're doing it in ML so that it's well-defined enough to serve as a simultaneous well-documented spec.
01:14:46 <Philippa> Tac-Tics: it's that and a reference implementation is designed to be simple and understandable
01:15:05 <glguy> Prelude Main> let xs = Just 'a' :> Just "B" :> ()
01:15:05 <glguy> xs :: Maybe Char :> (Maybe [Char] :> ())
01:15:05 <glguy> Prelude Main> apply (\x y -> show x ++ show y) xs
01:15:05 <glguy> "Just 'a'Just \"B\""
01:15:17 <glguy> It worked... polymorphic type level list folding
01:15:31 <glguy> instance TypeFoldF TypeApply (a -> b) a b where
01:15:32 <glguy>   typefoldf TypeApply f x = f x
01:15:43 <glguy> and apply = typefold TypeApply
01:16:03 <Mitar> how can I calculate new values of an array using a window moving over old array? so fmap uses only one value to replace it, i would like to go use also neighborhood elements?
01:16:19 <Mitar> and how could i make for example a flood fill on a haskell array?
01:16:31 <sclv> Philippa: well, not always. my initial comment was in part a reference to perl being its own reference implementation.
01:17:19 <quicksilver> haskell has something even better than a reference implementation. It has a denotational semantics! Hmm. Onl it doesn't :(
01:17:34 <quicksilver> But we all know what the denotational semantics is supposed to be, right?
01:20:47 <Mitar> anyone?
01:21:10 <osfameron> is a denotational semantics just a specification?
01:21:38 <quicksilver> a denotational semantics could be one kind of specification
01:21:39 <Tac-Tics> It's a specification with funky syntax
01:21:56 <quicksilver> it wouldn't specify anything like time or space constraints though
01:22:01 <Cale> osfameron: A specification in terms of a particular kind of mathematical object.
01:22:10 <quicksilver> so it would be a weak specification by some CS standards
01:22:19 <Tac-Tics> (one with funky syntax... even by math standards)
01:22:42 <osfameron> but presumably powerful for something?
01:23:20 <quicksilver> I don't think the syntax is really part of the definition :)
01:25:30 <Tac-Tics> I swear, the conventional syntax for denot. semantics was invented to make the writers look smarter than they would if they used python, scheme, or an enriched lambda calculus
01:26:52 <roconnor> Tac-Tics: are you talking about the double struck square brackets?
01:28:11 <Tac-Tics> the brackets aren't the worst. The big thing that makes me roll my eyes is the use of the special symbols for head and tail
01:28:41 <Tac-Tics> they look like obsoleted editor's markings from some 1800's printing press
01:29:15 <Tac-Tics> head and tail are pure functions, why not just use h(c) and t(c)?
01:30:47 <mmmdonuts> Er, denotational semantics predated Scheme by about 15 years.
01:30:49 <Sizu1> anybody here has packaged a library before?
01:32:38 <Tac-Tics> mmmdonuts: fact noted, but it's still presented more confusingly than it should be
01:33:45 <jsnx> Sizu1: small one (cedict)
01:34:03 <jsnx> Sizu1: how can i be of service?
01:34:14 <mux> > getZipList $ (,) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
01:34:18 <lambdabot>  [(1,4),(2,5),(3,6)]
01:34:42 <Sizu1> jsnx: thanks. i installed my own lib using cabal, in ghci :m does autocomplete my module fine, but it wont load it. why?
01:35:35 <jsnx> do not know
01:35:39 <jsnx> what does it say?
01:36:05 <Sizu1> module main:<modulename> is not loaded
01:36:16 <jsnx> i remember vaguely that i had loading problems when i was in the project directory...
01:36:48 <Sizu1> this is it!
01:37:00 <Sizu1> jsnx: thanks.
01:37:00 <jsnx> yeah, i still have those problems :)
01:37:09 <Sizu1> but it's stupid :/
01:37:24 <jsnx> yeah, it is some kind of path precedence thing, i'm sure
01:37:25 <Sizu1> thanks for your help though, i thought i had messed up my .cabal
01:37:39 <jsnx> Sizu1: what is your library? can you tell us?
01:37:54 <Sizu1> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/i18n-0.1.2
01:37:56 <lambdabot> http://tinyurl.com/25bfjf
01:38:29 <jsnx> Sizu1: wow, cool
01:38:33 <Sizu1> i suspect haddock wont build there as hackage uses haddock-0.8
01:39:22 <mmmdonuts> Tac-Tics, it's just syntax.  You can convert back and forth between it and code automatically.  Perhaps it's still used to teach students that syntax is irrelevant. :)
01:40:27 <Tac-Tics> Isomorphism is not equivalence
01:40:51 <Tac-Tics> It's just so uglay
01:40:58 <lament> they're doing it because they think of themselves as mathematicians
01:41:05 <jsnx> lolz
01:41:20 <mmmdonuts> Scott and Strachey developed it before there were any functional programming languages!
01:41:22 <Tac-Tics> It's like a disguise
01:41:32 <Tac-Tics> they take this cool as hell theory stuff
01:41:41 <Tac-Tics> and wrap it up in rags
01:41:57 <jsnx> Tac-Tics: good wine needs no sign
01:42:05 <Tac-Tics> so no one knows how cool it really is unless they have friends in #haskell to urge them to read it
01:42:09 <jsnx> they want only the discerning to seek their way
01:42:20 <lament> Tac-Tics: h() and t() look pretty ugly to me!
01:42:42 <Tac-Tics> lament: I agree. I was going for less ugly, but still mathy
01:42:53 <jsnx> Tac-Tics: or maybe it just helps maintain the functional status quo
01:42:58 <lament> this seems to be very much a matter of taste
01:43:15 <lament> (i mean, what's prettier, not why they use those symbols)
01:44:20 <mmmdonuts> Ah well, if Haskell and Scheme ever get *too* popular, I now know what I need to do to keep the riff-raff out! ;)
01:44:34 <jsnx> mmmdonuts: yeah -- braces!
01:45:46 <mmmdonuts> No, typographical characters so obscure no-one even remembers their names, if they ever had any!
01:46:01 <Tac-Tics> Top 10 Reasons Denotational Semantics are bad 1) Not enough parenthesis. 2) no intelligent indentation. 3) no macros. 4) no for loops. 5) no OOP. 6) too many parenthesis. 7) Not enough curly braces. 8) Not Web2.0 enough. 9) No open source implementation. 10) Poor support for the OS
01:46:53 <Tac-Tics> actually, I think I am inspired to write an OSS implementation of Denot. semantics now =-)
01:46:58 <mmmdonuts> Tac-Tics, now match that list up with the top 10 reasons the earliest functional programming languages sucked.
01:47:00 <Sizu1> 0) Because.
01:47:05 <Tac-Tics> It would require Unicode source
01:47:24 <jsnx> unicode source is cool
01:47:31 <jsnx> as long as tabs are banned
01:47:49 <Tac-Tics> One time I accidently inserted a Japanese full-width space into my python source
01:48:03 <jsnx> Tac-Tics: lolz
01:48:08 <Tac-Tics> If I didn't realize what I did right away, I would have thrown the whole thing away
01:48:28 <lament> japanese is evil
01:48:31 <jsnx> there are source to source transformers for writing python in chinese
01:48:36 <Tac-Tics> _ã€€_ _
01:48:51 <Tac-Tics> lament: Japanese is awesome / evil
01:48:53 <jsnx> lament: not entirely -- there's some chinese in it
01:49:15 <Tac-Tics> Japanese makes me thinking about writting a SOV-style programming language
01:50:03 <Tac-Tics> where the method name comes last, after the invoking object and the parameters
01:51:25 <jsnx> "/" s.split
01:51:46 <jsnx> s '/' split
01:52:23 <Tac-Tics> MySql wa "localhost" "user" "pass" ni connect
01:52:40 <jsnx> why the wa and ni?
01:52:43 <jsnx> japanese stuff?
01:52:46 <Tac-Tics> yeah
01:52:47 <Sizu1> to sound japanese
01:53:05 <lament> jsnx: ah, true
01:53:11 <jsnx> yeah, when chinese programs start to show up, it'll be awesome
01:53:27 <jsnx> everything will be one or two characters
01:53:33 <Tac-Tics> What would a SOV lambda expression look like though?
01:53:43 <jsnx> one-liners will be way more powerful
01:54:04 <lament> Tac-Tics: how is lambda expression syntax related to the SVO order?
01:54:49 <jsnx> Tac-Tics: the (\ x y -> blah) part is just the object and verb
01:54:59 <jsnx> it's already OV
01:55:16 <mathrick> Tac-Tics: wrt actual Japanese grammar, you'd rather use ga instead of wa
01:55:31 <mathrick> just a nitpick :)
01:55:39 <jsnx> then you put the objects in there: 7 (\x -> 3 + x) -- 10
01:55:47 <Tac-Tics> mathrick: yeah, for programming you're probably right
01:56:08 <Tac-Tics> mathrick: but it would be cool to use wa to introduce a topic, and then omit it until another topic were declared
01:56:36 <mathrick> heh, yeah
01:56:58 <mathrick> though it'd make interpreting the source as hard as Japanese :)
01:57:05 <Tac-Tics> cursor wa "SELECT * FROM users" kara query
01:57:05 <Tac-Tics> row ni fetch_row
01:57:44 <wolverian> it's called $_ in perl
01:57:47 <mathrick> it seems even more vile than perl contexts
01:58:05 <wolverian> perl's contexts are not vile; they're just a subtle kind of type inference.
01:59:13 <wolverian> (granted, you have to squint quite a bit.)
01:59:17 <jsnx> wolverian: okay, they're not vile
01:59:21 <Mitar> nobody care about me :-(
01:59:33 <mathrick> they're vile in the same way Japanese contexts are
01:59:46 <wolverian> what way is that?
02:00:31 <Lemmih> Mitar: Compute a list and then make an array out of that list?
02:00:32 <mathrick> sure, they let you get a lot of implicit bang for your buck, but reconstructing the original intent is made hard and error-prone
02:00:33 <Mitar> how can I calculate new values of an array using a window moving over old array? so fmap uses only one value to replace it, i would like to go use also neighborhood elements?
02:00:41 <Mitar> and how could i make for example a flood fill on a haskell array?
02:01:02 <jsnx> Mitar: a flood fill is actually making it from a list
02:01:15 <jsnx> a repeating list of all the same stuff
02:01:20 <wolverian> mathrick, it's just polymorphism on return value. :)
02:01:26 <wolverian> er, s/value/type/
02:01:52 <Mitar> jsnx, i do not understand? a repeating listo of what?
02:01:57 <jsnx> Mitar: as for using a window, if you mean something like 'five point stencil', that's a good question -- i haven't thought about it
02:02:57 <mathrick> wolverian: and in Japanese it's just polymorphism on meaning, doesn't mean it's easy :)
02:03:08 <jsnx> Mitar: say you want to fill an array with zeroes
02:03:33 <mathrick> it's useful, but can (and does) lead to expressions almost devoid of meaning yet meaning almost everything
02:03:38 <jsnx> @let zero = repeat 0 in take 10 zero
02:03:38 <lambdabot>  Parse error
02:03:43 <wolverian> mathrick, easy, powerful, safe; pick one :)
02:03:57 <Mitar> no, i would like to fill for example zeros i a closed area (array is representing the picture) which have the same color
02:04:02 <Mitar> or value
02:04:04 <jsnx> @let { ; zero = repeat 0 } in take 10 zero
02:04:04 <lambdabot>  Parse error
02:04:13 <Tac-Tics> Analogs to type and type safety pop up all over the place!
02:04:20 <jsnx> @let zero = repeat 0 in zero
02:04:20 <lambdabot>  Parse error
02:04:24 <wolverian> @let zero = repeat 0
02:04:28 <lambdabot> Defined.
02:04:34 <jsnx> > let zero = repeat 0 in zero
02:04:34 <mathrick> wolverian: perl is definitely not my kinda thing, which is why I'm not very partial to its choices in this regard
02:04:35 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
02:04:40 <jsnx> aha
02:04:51 <Tac-Tics> perl is clearly the work of a madman
02:05:04 <jsnx> > let zero = repeat 0 in listArray (1, 10) zero
02:05:05 <lambdabot>  array (1,10) [(1,0),(2,0),(3,0),(4,0),(5,0),(6,0),(7,0),(8,0),(9,0),(10,0)]
02:05:13 <Tac-Tics> kinda like haskell, but a madman who isn't quite mad enough to teach himself denotational semantics
02:05:20 <wolverian> mathrick, sure. :)
02:05:24 <jsnx> Mitar: so, it flood fills the array with zeroes
02:05:40 <wolverian> mathrick, the weird thing, I guess, is that haskell and perl are both my kind of thing...
02:05:48 <mathrick> of warty but useful languages, I like Common Lisp
02:05:49 <wolverian> Tac-Tics, perl 6 fixes that.. ;)
02:06:09 <mathrick> wolverian: can you declare parameters other than by shift yet? :P
02:06:40 <wolverian> mathrick, in perl 6, yes. in core perl 5, no, but there is a quite recent module on CPAN that lets you do it; how it works is pretty scary XS magic.
02:06:59 <wolverian> http://search.cpan.org/~mschwern/Method-Signatures-0.02/lib/Method/Signatures.pm
02:07:00 <lambdabot> Title: Method::Signatures - method declarations with prototypes and without using a sou ..., http://tinyurl.com/ywt59n
02:07:14 <wolverian> mathrick, (well, of course perl 5 lets you say 'my ($foo, $bar) = @_;' which doesn't use shift)
02:09:18 <Sizu1> no source filter, interesting
02:10:05 <wolverian> yes. it requires trailing ; in the declarations, but mst is fixing Devel::Declare to fix that. it's quite insane. :)
02:10:52 <Sizu1> thanks to never-releasing-perl6, i'm a haskeller! ;) now there's no need in perl6 for me at all unfortunately.
02:11:52 <Sizu1> or fortunately
02:11:56 <wolverian> never? just wait for christmas. :)
02:12:13 <Tac-Tics> perl to haskell seems like the biggest leap one could make between languages
02:12:23 <Sizu1> and i loved it
02:12:24 <mathrick> wolverian: which christmas?
02:12:41 <mathrick> also, what's so bad about source filters that it avoids them?
02:12:59 <Sizu1> well, i knew already c/c++, java, js, and all that jazz. but perl was my fave
02:13:11 <Cale> The day on which Perl 6 is released, whatever day that eventually happens to be, will be called "christmas".
02:13:11 <wolverian> mathrick, they don't stack gracefully, and they can't parse perl 100% reliably, so they are brittle.
02:13:13 <Tac-Tics> Perl has such a "do what you feel" attitude and Haskell is all about "don't fuck with it unless you have explicit authority (read: type) from the Almighty GHC"
02:13:16 * mathrick 'd have thought they'd be somewhat like CL macros, so generally good
02:13:18 <wolverian> mathrick, the christmas it's ready.
02:13:32 <wolverian> also see what Cale said. :)
02:13:32 <mathrick> wolverian: ah, so not really like macros then
02:13:42 <mathrick> more akin to reader macros
02:13:45 <wolverian> mathrick, no. what Devel::Declare provides is more like macros.
02:13:48 <Cale> otoh, isn't pugs reasonably usable already?
02:14:06 <mathrick> wolverian: I mean source filters are not really like macros
02:14:11 <wolverian> Cale, yes, but it's languishing, unfortunately. parrot is taking big leaps, though, now that they have NQP to implement languages in.
02:14:18 <wolverian> mathrick, yes, me too.
02:14:34 <wolverian> that is, my "no" was an affirmative.
02:14:40 <mathrick> aha
02:14:40 <wolverian> (english sucks sometimes, sorry.)
02:14:53 <wolverian> s/english/my english/
02:14:53 <mathrick> s/sometimes//
02:14:57 <wolverian> heh
02:15:36 <wolverian> parrot even has a make perl6 target now, so you actually get a native perl6 compiler binary. :)
02:17:07 <wolverian> anyway, sorry, this is a bit #offtopic
02:17:30 <Sizu1> pugs is in haskell, so it's all related. perl = haskell ;P
02:17:36 <wolverian> ;)
02:18:37 <codemac> omg my brain just clicked on the monad thing.
02:18:40 <codemac> thought I'd share.
02:18:59 <wolverian> ewww, get your head off my monad
02:20:07 <Tac-Tics> x >>= f -- Monadic Bondage!
02:20:15 <Sizu1> do NOT touch my monad with YOUR monad!
02:21:35 <Cale> codemac: cool :)
02:21:41 <Cale> codemac: what did it for you?
02:21:53 <codemac> http://programming.reddit.com/info/64th1/comments/c02u9mb << what did it for everyone else today
02:21:54 <Tac-Tics> Do you implement the Show class? Or are you just happy to see me?
02:22:58 <Sizu1> ah sure 'method' is a simple subroutine ending with ';' -- talking about Method::Signatures
02:23:38 <Sizu1> why the need for xs
02:24:11 <wolverian> Sizu1, no, it's not.
02:24:19 <wolverian> Sizu1, you can not write 'foo (...) { ... };' without X.
02:24:21 <wolverian> er, XS
02:24:25 <wolverian> codemac, wow, nice post.
02:25:05 <Cale> codemac: You might want to continue with http://haskell.org/haskellwiki/Monads_as_computation (shameless plug :)
02:26:34 <Sizu1> wolverian: ok i see. can you use strict with it?
02:26:38 <wolverian> Sizu1, yes.
02:26:48 <Cale> To sleep!
02:27:26 <Tac-Tics> Monads are Math things that let you do non-Math things
02:27:39 <quicksilver> s/Monads/Computers/
02:28:07 <wolverian> s/Computers/Everything/
02:28:08 <Tac-Tics> quicksilver, your truth is greater
02:28:21 <quicksilver> wolverian's truth is ungrammatical
02:28:38 <quicksilver> Sizu1: XS gives you lisp-macro like abilities
02:28:46 <wolverian> quicksilver's truth is true.
02:28:55 <quicksilver> Sizu1: in particular, it lets you receive your arguments as syntax trees
02:28:58 <quicksilver> instead of values
02:29:08 <quicksilver> if I correctly undesrstand how Devel::Declare works.
02:29:13 <wolverian> roughly.
02:29:19 <wolverian> it sounds tidier than it is.
02:29:42 <therp> quicksilver: what's XS?
02:29:53 <wolverian> perl's C extension API
02:30:43 <therp> 50% of the terms in that expression scare me.
02:31:06 <wolverian> heh
02:51:26 <sarah> what does malformed lhs to type of class declaration mean
02:54:52 <Mitar> what I have to define to make a pair of ints an instance of Random?
02:56:46 <quicksilver> Mitar: the most natural thing is instance (Random a,Random b) => Random (a,b)
02:56:56 <quicksilver> Mitar: I'm not sure where there isn't a default instance along those lines.
02:57:09 <Lemmih> Mitar: http://www.haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html#t%3ARandom
02:57:10 <lambdabot> http://tinyurl.com/3yau3k
02:57:18 <Mitar> and deriving does not work ;-(
02:57:42 <quicksilver> indeed, you can't derive Ranomd.
02:57:50 <quicksilver> it's not hard to write the instance though.
02:58:23 <quicksilver> Oh. I know why there isn't a default definition for (a,b)
02:58:32 <quicksilver> just because it's not 100% clear what the range should mean.
02:59:22 <quicksilver> actually I think that's a bit of ugliness in the class.
03:07:47 <Mitar> juhej, to get a list of random pixels in a image: rands = randomRs (bounds image) (mkStdGen 42)
03:08:06 <Mitar> (their indexes)
03:18:43 <EvilTerran> randomR ((xlo,ylo),(xhi,yhi)) g = (randomR (xlo,xhi) g, randomR (ylo,yhi) g) -- is the only reasonable solution i can think of
03:20:54 <EvilTerran> hm... not quite right
03:20:59 <Mitar> no
03:21:08 <Mitar>   randomR ((lx,ly),(ux,uy)) g = ((x,y),g'')
03:21:08 <Mitar>     where (x,g') = randomR (lx,ux) g
03:21:09 <Mitar>           (y,g'') = randomR (ly,uy) g'
03:21:12 <Mitar> i made it like this
03:21:17 <EvilTerran> yeah, that's the one
03:21:44 <EvilTerran> but the range isn't the problem, it's threading the generator that's a bit of a pain
03:22:36 <EvilTerran> @unmtl State s a
03:22:36 <lambdabot> s -> (a, s)
03:22:40 <EvilTerran> ?type randomR
03:22:55 <lambdabot> thread killed
03:23:01 <EvilTerran> @type randomR
03:23:02 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
03:23:36 <EvilTerran> hmm
03:25:44 <EvilTerran> ?type \((xlo,ylo),(xhi,yhi)) -> runState $ liftM2 (,) (State $ randomR (xlo,xhi)) (State $ randomR (ylo,yhi))
03:25:45 <lambdabot> forall a s a1. (Random a, Random a1, RandomGen s) => ((a, a1), (a, a1)) -> s -> ((a, a1), s)
03:26:27 <EvilTerran> ?pl \((lx,ly),(ux,uy)) -> ((lx,ux),(ly,uy))
03:26:28 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (,)) . flip . (((.) . (,)) .) . (,)))
03:26:32 <EvilTerran> ...
03:26:53 <Mitar> how could i randomize a list of numbers (its order)
03:27:07 <quicksilver> EvilTerran: MonadRandom lets you thread the generator silently
03:27:27 <EvilTerran> ?type (fst *** fst) &&& (snd *** snd)
03:27:28 <lambdabot> forall a b a1 b1. ((a, b), (a1, b1)) -> ((a, a1), (b, b1))
03:27:35 <quicksilver> doesn't particularly help with randomR though, because randomR has the type it has...
03:27:47 <quicksilver> Mitar: google for 'haskell shuffle'
03:28:07 <EvilTerran> quicksilver, i imagine it works much like my State one there does
03:29:03 <quicksilver> EvilTerran: yes, it does.
03:29:32 <quicksilver> Many interesting monads can be implemented using State.
03:29:53 <quicksilver> however, ironically, the restricted interface can be more interesting than the general one.
03:36:15 * EvilTerran is reminded of "implement all these list functions using foldr"
03:36:21 <EvilTerran> "implement all these monads using State" :P
03:36:44 <osfameron> list functions with foldr was *hard*
03:37:34 <Mitar> oh
03:37:37 <Mitar> i used shuffle es = map snd $ sortBy (comparing fst) $ zip rs es
03:37:43 <Mitar> and now i get stack overflow ...
03:37:59 <Mitar> (on a million of elements)
03:39:17 <quicksilver> are you compiling with -O2 ?
03:40:23 <Mitar> yes ..
03:42:47 <Mitar> i enlarged stack size and now it works ...
03:42:59 <Mitar> -K200000000
03:43:04 <Mitar> :-)
03:43:57 * EvilTerran read that as -O200000000 the first time :P
03:44:08 <wy> Has anyone looked at dependent types?
03:44:15 * quicksilver thinks about Mitar's sort
03:44:20 <quicksilver> well sortBy is an in-memory sort
03:44:32 <quicksilver> so it's only useful on "small" lists
03:44:52 <quicksilver> I'm surprised it got stack overflow though
03:44:54 <Mitar> if i want to have a record of all elements i have to process and to be able also to remove random other elements from this record ...
03:45:00 <Mitar> i probably should not use lists?
03:45:03 <quicksilver> it should only use O(log n) stack would have thought
03:45:12 <Mitar> as I can nicelly prcess them
03:45:33 <Mitar> but searching if the elements is there and removing it if it is, is O(n)
03:45:46 <Mitar> what could I use as a structure?
03:46:04 <quicksilver> Data.Set, if the elements are unique
03:46:09 <quicksilver> Data.Seq if order is important
03:46:15 <quicksilver> are the obvious choices
03:46:26 <Mitar> which I will be able to easily traverse (can be randomly, it should be randomly - i am shuffling the list now)
03:46:45 <Mitar> and easily remove also other elements while i am traversing
03:47:52 <quicksilver> removing elements while traversing could be a job for a zipper
03:48:11 <quicksilver> might need a little more of a picture of what you're trying to do
03:49:13 <Mitar> i have an array representing the picture
03:49:19 <Mitar> i would like to make an function
03:49:23 <Mitar> whichi would take this array
03:49:41 <Mitar> and give me as a result a list of lists of pixels which have "similar" colors
03:49:57 <Mitar> so list of regions with similar colors on a image
03:50:18 <quicksilver> and you want to "condense" regions as you sort through and find they're connected?
03:50:27 <Mitar> yes
03:50:33 <Mitar> so i start randomly somwhere
03:50:47 <Mitar> check around it, if it is ok, i append, remove from the list i have yet to process
03:50:48 <quicksilver> I've written code like this once
03:50:55 * quicksilver thinks
03:51:01 <Mitar> if there is nothing i add to the resulting list
03:51:07 <quicksilver> the simplest approach is linear scan
03:51:08 <Mitar> and starts somewhere else
03:51:13 <quicksilver> go through the whole list of regions
03:51:21 <quicksilver> and check for overlap/adjacency
03:51:43 <Mitar> i do not have any list of regions at the beginning
03:51:51 <quicksilver> yes, that the empty list then :P
03:52:06 <quicksilver> more sophisticated is some kind of 2D spatial tree
03:52:16 <quicksilver> so you can "quickly" find nearby regions and check if they are the same colour
03:53:01 <Mitar> i have an array to quickly check (read) values ...
03:53:33 <Mitar> hmm, i could maybe define this as a fix point function
03:53:42 <Mitar> have first all pixels as regions
03:53:53 <Mitar> find two neighbourginh pixels with similar color
03:53:55 <Mitar> combine them
03:54:10 <quicksilver> yes
03:54:11 <Mitar> (two neigbourghing (i cannot spell this) regions)
03:54:26 <Mitar> but this will not be really efective
03:54:27 <Mitar> or?
03:54:38 <quicksilver> with laziness it might be
03:54:43 <quicksilver> you never "really" have all pixels as regions
03:54:49 <quicksilver> because that is lazily generated.
03:54:58 <Mitar> hmm
03:55:14 <quicksilver> I'd start with the simplest to understand
03:55:18 <Mitar> still is the set best to use ... do you agree?
03:55:21 <quicksilver> and then optimise when you find it too slow
03:55:45 <Mitar> hmm
03:55:45 <quicksilver> I think set could work reasonably, yes
03:55:49 <quicksilver> Set (Set Pixel)
03:55:52 <quicksilver> a set of sets of pixels
03:55:58 <Mitar> yes ...
03:56:20 <quicksilver> I like to start with a program which is "obviously" correct
03:56:24 <Mitar> why a set of sets?
03:56:28 <quicksilver> because it corresponds to a specification of the algorithm
03:56:28 <Mitar> why not a set of lists?
03:56:32 <quicksilver> you could do that, yes
03:56:40 <quicksilver> and then optimise it only if I find it is too slow
03:56:43 <Mitar> it is easier to append ...
03:57:23 <Mitar> why would this be slow?
03:57:24 <Mitar> hmm
03:58:31 <Mitar> hmm
03:58:58 <Mitar> i see the problem ... how can i find if two regions are close to each other
03:59:42 <Mitar> i think i will go from oposite direction ...
03:59:44 <quicksilver> define the 'neighbourhood set' as all pixels 1 pixel away
03:59:56 <quicksilver> then A is next to B if A intersects with (neighbourhood B)
04:00:14 <Mitar> but this will be so slow ...
04:00:31 <Mitar> it will redo work all the time ..
04:00:38 <Mitar> i will go bottom up
04:00:44 <Mitar> go over all pixels
04:00:57 <Mitar> and check if there are any neigbours i can combine it with
04:01:03 <Mitar> and i will do until i can
04:08:38 <__pao__> a newbie question... when recursive infinite list a partially evaluated... values are cached for next evaluation?
04:09:16 <Lemmih> __pao__: Yes.
04:09:23 <__pao__> > let l = 0 : map (+1) l
04:09:24 <lambdabot>  Parse error at end of input
04:09:34 <__pao__> Lemmih: thanks
04:10:03 <__pao__> > 1
04:10:05 <lambdabot>  1
04:10:06 <opqdonut> @oeis 1 1 3
04:10:07 <lambdabot> Pascal's triangle read by rows: C(n,k) = binomial(n,k) = n!/(k!*(n-k)!), 0<=k...
04:10:07 <lambdabot> [1,1,1,1,2,1,1,3,3,1,1,4,6,4,1,1,5,10,10,5,1,1,6,15,20,15,6,1,1,7,21,35,35,21...
04:10:37 <__pao__> > f x = x + 1
04:10:37 <lambdabot>  Parse error at "=" (column 5)
04:10:45 <__pao__> > let f x = x + 1
04:10:45 <lambdabot>  Parse error at end of input
04:10:57 <__pao__> give up :-)
04:11:20 <andun> > let f x = x + 1 in f 1 -- __pao__
04:11:21 <lambdabot>  2
04:12:01 <__pao__> andun: only expression... no definitions ....
04:12:08 <andun> yes
04:12:12 <opqdonut> @def f x = x + 1
04:12:12 <lambdabot> Maybe you meant: bf let
04:12:16 <opqdonut> @let f x = x + 1
04:12:18 <lambdabot> Defined.
04:12:21 <opqdonut> > f 2
04:12:21 <lambdabot>  3
04:12:22 <opqdonut> :)
04:12:24 <opqdonut> @undef f
04:12:25 <lambdabot> Undefined.
04:12:35 <__pao__> opqdonut: thanks :-)
04:12:44 <andun> > let l = 1 : map (+1) l in l
04:12:45 <__pao__> @undef
04:12:52 <lambdabot> Undefined.
04:12:53 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:13:30 <__pao__> well... haskell and functional programming are great! let me share my newbie enthusiasm :-)
04:14:14 <__pao__> > l
04:14:16 <lambdabot>   Not in scope: `l'
04:14:32 <__pao__> > let l = 1 : map (+1) l in l
04:14:34 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:14:36 <__pao__> > l
04:14:36 <lambdabot>   Not in scope: `l'
04:14:45 <nanothief> __pao__: try /query lambdabot, and you can do as much as you like without spamming the channel :)
04:15:04 <__pao__> sorry nanothief :-)
04:15:18 <__pao__> nanothief: I'll do as you suggest
04:15:21 <andun> __pao__: l is only defined in the "in" block
04:15:29 <__pao__> andun: got it
04:15:48 <__pao__> andun: is a local binding ... local to the expression
04:17:16 <andun> yes
04:24:30 <resiak> Any Cabal ninjas around?  With http://linkpot.net/healer/ as my hfuse.cabal, the two executables are built against the installed version of the library rather than with the version built by the same .cabal.  If I replace Build-Depends with Other-Modules, building the library fails with "HFuse.hsc:79:27:  error: fuse_wrappers.h: No such file or directory" (I guess it's looking in the wrong place for some reason?).  I thought that the settings in ...
04:24:31 <lambdabot> Title: darcs - hfuse
04:24:36 <resiak> ... each section were independent, but settings in the Executable section seem to affect the building of the library.  Am I doing something obvious wrong?
04:28:06 <thoughtpolice> you can build the executables and link against the library the cabal exports, yes
04:28:38 <thoughtpolice> i believe the way I did it was simply to add the directory pointing to your module heirarchy in the executable's "hs-source-dirs" field
04:29:26 <thoughtpolice> i.e. if you have your executable sources in bin and the library under lib/, in the executable stanza you'd have hs-source-dirs: bin lib
04:29:49 <resiak> along with a build-depends line, or an other-modules line?
04:29:49 <thoughtpolice> this will cause the library to be rebuilt several times, though
04:29:58 <thoughtpolice> no need for build-depends line
04:29:59 <resiak> ick.
04:30:04 <thoughtpolice> yeah
04:30:14 <thoughtpolice> it'll be rebuilt first for the actual library that'll be registered
04:30:20 <resiak> Executable HelloFS Main-Is:            HelloFS.hs HS-Source-Dirs:     .
04:30:29 <thoughtpolice> and once for every executable that does that little trick
04:30:33 <resiak> fails with Could not find module `HFuse':
04:30:47 <resiak> ("." because all the source is in the root dir)
04:31:10 <resiak> (could this be because HFuse is HFuse.hsc, not .hs ?)
04:32:21 <thoughtpolice> that's kind of what I was thinking, it might need the hsc2hs run over it first
04:32:39 <resiak> yeah; i would kind of expect cabal and/or ghc to deal with that
04:32:41 <resiak> *sigh*
04:33:03 <thoughtpolice> try running hsc2hs over it first explicitly and seeing then if the build works
04:33:11 <Taejo> @pl \(x,y) -> (y,x)
04:33:11 <lambdabot> uncurry (flip (,))
04:33:14 <thoughtpolice> or run Setup.hs build with -v3 or something
04:33:17 <thoughtpolice> to see exactly what cabal's doing
04:35:03 <hpaste>  resiak pasted "Different build failure having manually run hsc2hs" at http://hpaste.org/4867
04:35:36 <thoughtpolice> hm. :/
04:35:52 <resiak> yeah
04:36:20 <resiak> Oh, if I include Build-Depends: HFuse in the Executable section, the library itself is built with '-package HFuse-0.12', which seems wrong#
04:37:33 <thoughtpolice> support for this stuff isn't first class in cabal because i think the general attitude is if you need to do this conceptually the executable and lib should be seperate anyway. worst comes to worst you might just want to put the examples under a seperate dir and have cabal build the lib, then just provide a makefile for the examples :/
04:38:03 <resiak> heh, i just spent a day fixing up the .cabal so that I could blow away the Makefile :)
04:38:19 <resiak> yeah, an example/Makefile wouldn't be too horrible I guess, although it makes me sad.
04:38:22 <thoughtpolice> besides, having it rebuild the library several times for every executable does suck, imo.
04:38:41 <resiak> it does suck.  it shouldn't be necessary.  oh well
04:38:46 <thoughtpolice> sry :(
04:39:02 <resiak> eh, presumably it's not your fault? :)
04:39:13 <resiak> Thanks for your help!
04:39:19 <thoughtpolice> resiak: and out of curisotiy... is this fuse binding going to work on ghc 6.8? :)
04:39:22 <thoughtpolice> no prob.
04:40:53 <thoughtpolice> i've been suprised up to this point nobody's written one for more recent ghc's... last one I heard of was for 6.2 for halfs.
04:40:54 <resiak> [This isn't a new binding; it's me working on JÃ©rÃ©my Bobbio's]
04:41:32 <thoughtpolice> ah. cool beans. :) fuse is interesting stuff, bindings for haskell makes better. :)
04:41:50 <resiak> I haven't upgraded to 6.8 yet; it's not in Ubuntu Hardy and I don't want to build it all myself or use an un-packaged binary, so
04:42:52 <resiak> (Hrm, anyone here on a Mac feel like seeing if it builds against macfuse? :))
04:42:58 <thoughtpolice> ah. well when you get all that worked out give me a ring and i'd be happy to help test with 6.8
04:43:21 <resiak> That'd be great!
04:45:39 <thoughtpolice> resiak: went ahead and pulled the repo. :) i can't do much work right now since I have school pretty soon here, but when I get back i'll pull any more updates and give building and testing it a whirl.
04:45:58 <resiak> cool, thanks
04:47:19 <Mitar> why data.set.union does not work on set of sets
04:47:26 <Mitar> instead of list of sest
04:47:30 <Mitar> now i cannot use it like concatMp
04:47:33 <Mitar> concatMap
04:47:46 <Taejo> Mitar: I have just been wondering the same thing
04:52:20 <Mitar> what is difference between elems and toList?
04:54:02 <Mitar> elems :: Set a -> [a]
04:54:03 <Mitar> elems s
04:54:03 <Mitar>   = toList s
04:54:04 <Mitar> none :-)
04:56:10 <resiak> thoughtpolice: for when you get back, pushed!
04:58:26 * jedbrown thinks an `upgrade all' feature in cabal-install would be useful.
05:10:51 <opqdonut> heh
05:13:36 <Mitar> hmm
05:13:44 <Mitar> why is Data.Set.intersection O(n+m)???
05:14:00 <Mitar> why not O(m*log(n))?
05:15:22 <cpoucet> @src Data.Set.intersection
05:15:23 <lambdabot> Source not found. I am sorry.
05:15:35 <quicksilver> n+m is better than m*log(n)
05:16:00 <Mitar> for small m?
05:16:07 <Mitar> if i have m = 10 and n = 100000
05:16:07 <Mitar> ?
05:16:27 <quicksilver> depends on the constant factors, doesn't it :P
05:16:34 <quicksilver> O(m*log(n) could be
05:16:34 <Mitar> sure :-)
05:16:39 <quicksilver> 100000000000 * m * log(n)
05:16:44 <quicksilver> while n+m is n+m
05:16:46 * quicksilver shrugs
05:16:54 <cpoucet> O notation is messy
05:17:01 <quicksilver> it's "better" in the only sense that "better" could mean.
05:17:10 <cpoucet> Since computers are bounded, the limit to infinity is rather lame if you can have constnt factors this big
05:17:25 <cpoucet> s/lame/moot
05:17:57 <quicksilver> but there could be cases where the n+m algorithm is slowwer than the m*log(n) one, I agree
05:18:28 <cpoucet> quicksilver: it depends on hwo m and n go to infinity :)
05:18:35 <cpoucet> if n goes first, m*log(n) is better
05:19:19 <cpoucet> draw an arc from (0,inf) to (inf,0)
05:19:34 <cpoucet> all those points are on the infinity circle, and which direction you go defines which is better
05:19:44 <quicksilver> I had a look at the source, but I don't understand the algorithm for intersection
05:19:47 <quicksilver> ;)
05:19:55 <cpoucet> link/
05:19:55 <quicksilver> I find the notion of a m+n algorithm for intersection surprising
05:19:58 <cpoucet> @src Data.Set
05:19:59 <quicksilver> but I guess they're right.
05:19:59 <lambdabot> Source not found. My brain just exploded
05:20:03 <cpoucet> @index Data.Set
05:20:03 <lambdabot> bzzt
05:20:04 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Set.html#intersection
05:20:14 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2v3nau
05:23:33 <wy> I looked Scala just now. It seems mixins is much like type classes of haskell
05:25:07 <quicksilver> I don't think so
05:25:14 <quicksilver> mixins have a single definition
05:25:20 <quicksilver> which you apply to multiple classes
05:25:24 <quicksilver> (if I understand scala right)
05:25:32 <quicksilver> the point of typeclasses is multiple definitions
05:25:35 <quicksilver> different per type
05:25:45 <cpoucet> mixins are like template classes in c++
05:25:46 <cpoucet> e.g.
05:26:03 <cpoucet> typename <class Super> class Mixin : public Super { // mixin functionality }'
05:26:08 <cpoucet> s/'/;
05:26:21 <quicksilver> right
05:26:26 <cpoucet> you slice a horizontal layer out of the hierarchy
05:26:27 <quicksilver> so you write the code once, only
05:26:35 <cpoucet> and can then reuse that :)
05:26:39 <quicksilver> the defining feature of type classes is that you write each instance
05:26:44 <cpoucet> we use taht technique to have a full library of memory allocators
05:26:45 <quicksilver> it's the opposite of code-reuse
05:26:47 <quicksilver> it's adhoc
05:26:51 <quicksilver> it's code-rewriting :)
05:27:07 <quicksilver> [of course, you do it to enable code-reus in other places: you factor out the adhocness]
05:27:30 <quicksilver> [or, you do it to abuse the type system. If that's your sickness of choice]
05:28:01 <wy> But there is default methods in type classes
05:28:48 <matthew-_> > do { let 1 = 2; return 3 }
05:28:49 <lambdabot>  Parse error at "}" (column 26)
05:28:53 <matthew-_> err? help?
05:29:19 <matthew-_> ahh, the let's not being terminated?
05:29:32 <quicksilver> > do { let {1=2} ; return 3 }
05:29:34 <lambdabot>   add an instance declaration for (Show (t1 t))
05:29:38 <matthew-_> super, thanks
05:30:04 <cpoucet> > let 1 = 2 in 3
05:30:08 <lambdabot>  3
05:30:10 <cpoucet> > let 1 = 2 in 1
05:30:11 <lambdabot>  1
05:30:24 <quicksilver> I have no idea why that is legal :P
05:30:28 <cpoucet> yeah
05:30:30 <cpoucet> that should translate to
05:30:39 <cpoucet> let (fromInteger 1) = (fromInteger 2) in 1?
05:30:45 <matthew-_> it's never evaluated, surely
05:30:47 <cpoucet> erm in (fromInteger 1)
05:30:55 <matthew-_> > do { let {[x] = []} ; return x } :: Maybe Int
05:30:56 <cpoucet> but what does "let 1 = 2" mean
05:30:56 <lambdabot>   Irrefutable pattern failed for pattern [x]
05:30:58 <quicksilver> let x | fromInteger x == 1 = 2
05:31:01 <quicksilver> I believe
05:31:04 <matthew-_> that's annoying - it doesn't call fail
05:31:19 <quicksilver> matthew-_: [x] <- return []
05:31:47 <quicksilver> matthew-_: ugly hack but I've done it on occasion
05:32:14 <matthew-_> I think in this case, I'm just being lazy
05:32:28 <wy> I wonder if Scala has some advantage over haskell?
05:32:33 <cpoucet> wy: stop comparing languages
05:32:44 <quicksilver> wy: it's easier to type
05:32:47 <cpoucet> one language is a hammer, the other is a screwdriver
05:32:51 <quicksilver> 5 characters instead of 7
05:32:52 <cpoucet> you need more than one language
05:32:59 <wy> No. There could be a perfect one
05:33:01 <quicksilver> ...unless one of them is haskell.
05:33:04 <cpoucet> No there couldn't
05:33:39 <wy> There need be only one high leve language. Maybe it doesn't exist yet, but there should be
05:33:41 <cpoucet> Programming is a niche activity, you have web-programming, compiler-programming, gui-programming, etc..
05:33:52 <cpoucet> I am -certain- some languages lend themselves better to some domains and less to others
05:34:03 <flux> wy, would it be better than human language?
05:34:04 <cpoucet> wy: programming languages are a pareto curve
05:34:14 <cpoucet> well ok
05:34:18 <cpoucet> some fall under it, like java
05:34:19 * cpoucet coughs
05:34:47 <wy> Well, quicksilver said it's easier to type
05:34:48 <matthew-_> @index MonadPlus
05:34:49 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
05:35:02 <vincenz> wy: that's just fascetious
05:35:03 <lambdabot> vincenz: You have 1 new message. '/msg lambdabot @messages' to read it.
05:35:18 <vincenz> lambdabot: erm, I already read that one, thank oyu
05:36:50 <matthew-_> how can you pattern match on a monadplus result if you don't know the monad?
05:37:14 <vincenz> matthew-_: ?
05:37:57 <matthew-_> say I've got a computation m a, but I don't know what the m is. And then if m a fails I want to do x but if m a reveals an a then I want to do y where x,y :: IO b
05:38:03 <wy> vincenz: But may be it's also rigorous?
05:38:21 <vincenz> wy: the proof of burden lies on you
05:38:28 <matthew-_> I need, like, maybe for all m
05:38:50 <vincenz> matthew-_: sounds like you want MonadError
05:38:55 <vincenz> it has catch
05:39:10 <vincenz> @src catch
05:39:11 <lambdabot> catch m k = catchException m handler where handler (IOException err) = k err
05:39:13 <Philippa> you can't do it for all possible m a, but if you're allowed a monad transformer that's different
05:39:22 <Philippa> at least, you can't do it from outside the IO monad
05:39:27 <wy> There could be a proof, but I need to get some motivation to do it
05:39:39 <matthew-_> vincenz: right, that makes vast amounts of sense
05:40:31 <quicksilver> matthew-_: that is "mplus" for many monads
05:40:44 <matthew-_> that also makes sense
05:40:46 <quicksilver> matthew-_: in particular, the Error monads in MonadError define mplus that way.
05:41:00 <quicksilver> it's like catch but it doesn't actually catch the exception
05:41:03 <matthew-_> vincenz: did you mean catch or catchError?
05:41:09 <quicksilver> (I.e. it's "do this instead, but I don't care what went wrong")
05:41:11 <vincenz> @src catchError
05:41:12 <lambdabot> Source not found. Just try something else.
05:41:17 <vincenz> matthew-_: I think catchError
05:41:31 <vincenz> @src MonadError
05:41:33 <lambdabot> class (Monad m) => MonadError e m | m -> e where
05:41:33 <lambdabot>     throwError :: e -> m a
05:41:33 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
05:41:42 <matthew-_> surely throwError is just fail with some extra magic?
05:41:54 <quicksilver> do { foo <- m a; x foo } `mplus` { y }
05:41:57 <quicksilver> erm
05:42:01 <quicksilver> do { foo <- ma; x foo } `mplus` { y }
05:42:12 <quicksilver> where ma :: m a, x :: a -> m b and y :: m b
05:42:32 <matthew-_> ahh, I see. yes of course.
05:42:34 <quicksilver> and there is a missing superfluous 'do'
05:42:42 <matthew-_> grr, Haskell is so annoying
05:42:53 <quicksilver> and I took the liberty of assuming you wanted to do something with the returned 'a' from the 'm a' :)
05:43:00 <matthew-_> you learn one thing for one situation and then don't see how the same stuff applies in 100 other cases
05:43:31 <Toxaris> matthew-_: throwError is a typeclass method, it can be whatever the instance writer want :) but in a sensible MonadError instance, fail = throwError . strMsg, so fail is just throwError with extra magic
05:43:42 <vincenz> quicksilver: I don't see how MonadError can, since it is based on monad, not monadplus
05:44:30 <matthew-_> so is there an isMZero ? rather like isJust ?
05:44:37 <quicksilver> vincenz: the concrete instances do
05:44:44 <Toxaris> matthew-_: no there is no such thing
05:44:47 <matthew-_> ahh, but surely you could do ==
05:44:48 <quicksilver> vincenz: i.e. "Error" and "ErrorT"
05:45:00 <matthew-_> > mzero == (fail "foo")
05:45:01 <quicksilver> vincenz: erm. I.e. "Either String" and "ErrorT" perhaps I meant.
05:45:02 <lambdabot>   add an instance declaration for (Eq (m a))
05:45:02 <lambdabot>     In the expression: mzero == ...
05:45:09 <matthew-_> oh bother, that old problem...
05:45:21 <quicksilver> matthew-_: you should never use iJust
05:45:22 <quicksilver> isJust
05:45:31 <vincenz> quicksilver: I see
05:45:32 <quicksilver> by extension, you really don't want isMZero to exist
05:45:33 <quicksilver> ;)
05:45:36 <matthew-_> sir! yes sir!
05:45:41 <Toxaris> matthew-_: Monad and MonadPlus are only about constructing bigger monadic values out of smaller ones, not about deconstructing them
05:45:49 <vincenz> monads are something that need cleaning up
05:45:59 * quicksilver deconstructs Toxaris with a daring modernist argument.
05:46:06 <matthew-_> yeah. I'm quite convinced that eventually, you may want to deconstruct them...
05:46:26 <matthew-_> quicksilver: how about isNothing ;P
05:46:46 <Toxaris> matthew-_: sure you want, but you want to deconstruct them at a point where you know which concrete type they have
05:47:27 <matthew-_> that's annoying when writing a library - I don't want to push Maybe or Either String or ... on the user
05:47:55 <Toxaris> matthew-_: so use MonadError
05:48:09 <quicksilver> or MonadPlus
05:48:17 <quicksilver> with `catchError` or `mplus`
05:48:32 <quicksilver> if you do use MonadPlus you should specifiy to your users that you really mean the 'OrElse' type though
05:48:33 * Toxaris doesn't know what modernist arguments are
05:48:42 <quicksilver> cos there are two kinds of MonadPlus
05:48:51 <quicksilver> and if they use the other type they'll probably get rather odd behaviour.
05:52:48 <matthew-_> yep. thanks for all the hepl
05:56:22 <matthew-_> nah, none of this is suitable. I need to use ErrorT and runErrorT
06:00:35 <dangph> can someone tell me what this notation means please: let x=m in n = n[x:=m]
06:00:45 <dangph> what is the thing in the square brackets?
06:01:27 <earthy> dangph: is that haskell?
06:01:51 <dangph> I think so. It is from a haskell tutorial
06:01:51 <earthy> or is it formal semantics
06:01:59 <dangph> oh. I don't know
06:01:59 <earthy> in the latter case it's substitution notation
06:02:06 <frobar> dangph: prolly means "n evaluted with x taken to be m". i think they're just trying to say "let x=m in n  evaluates n with m bound to x" in an unnecessarily complicated way
06:02:12 <EvilTerran> dangph, n[x := m] means "the expression n with every free instance of the variable x replaced with the expression m"
06:02:22 <earthy> so  let x = m in n   means   n with m substituted for x
06:02:22 <frobar> *with x bound to m
06:02:55 <EvilTerran> f(x)[x := m] = f(m)
06:03:16 <EvilTerran> sometimes you'll see [x := m] written as [x \ m] or [m / x], too
06:03:49 <EvilTerran> (mnemonic: the one *over* the slash *over*writes the other one =] )
06:04:07 <dangph> oh. thanks. so it is not actual haskell syntax then?
06:04:10 <EvilTerran> nope
06:04:20 <dangph> cool. thanks
06:04:21 <EvilTerran> well, it could be
06:04:23 <frobar> nope, just people trying to explain things and failing :)
06:04:26 <EvilTerran> but it's not in this case
06:04:40 <byorgey> EvilTerran: nice mnemonic =)
06:04:40 <frobar> that notation really isn't needed there, unless you've seen it before
06:05:12 <EvilTerran> data ColonEq a b = a := b ...
06:05:33 <EvilTerran> byorgey, yeah, i like to think so. i had all kinds of trouble remembering what went where before i thought that up
06:06:10 <byorgey> EvilTerran: me too, which is why I like it!
06:06:11 <EvilTerran> especially as i had one  lecturer using [x\m] and one using [m/x] in different threads the same term
06:06:18 <byorgey> yikes
06:06:31 <EvilTerran> and one using [x |-> m], which i much prefer
06:06:34 * roconnor uses [x->m]
06:07:02 <pejo> Surely |-> must be used by a minority?
06:07:12 <byorgey> EvilTerran: indeed, that's what Pierce uses in TaPL, I much prefer it too
06:07:45 <EvilTerran> pejo, well, in other contexts, -> is used to say "maps this set to that set", while |-> is used to describe the pointwise mapping
06:07:54 <roconnor> I've thought about chaing the notaiton for \x.e  to e[x-  and notation for f t to be f>t]  then putting them together yeild e[x->t]
06:08:48 <EvilTerran> "let T : R^2 -> R^1 by (x,y) |-> 2*x + y"
06:09:45 <matthew-_> agh, sorry I may just be being dumb here but I still can't sort this. I need to transform a monad m into IO
06:09:57 <EvilTerran> byorgey, yeah, my Programming Languages lecturer (who chose TaPL as the course textbook) uses |->, too.
06:10:21 <Lemmih> matthew-_: Really?
06:10:34 <EvilTerran> my concurrency lecturer uses what the CSP spec uses, which is [x\m] IIRC
06:10:42 <Sizu1> :t runErrorT
06:10:44 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
06:11:12 <Sizu1> matthew-_: let m be IO
06:11:18 <matthew-_> Sizu1: yep.
06:11:21 <EvilTerran> and my Formal Program Design lecturer uses what Programming From Specifications (Morgan) uses, which is [m/x]
06:11:32 <EvilTerran> (that's the course book for FPD)
06:11:47 <matthew-_> I've got existing code and it's really hurting my head how to convert it to this stuff
06:12:01 <EvilTerran> matthew-_, sorry, what do you want to do?
06:12:11 <EvilTerran> convert some code that's in the IO monad to work in any MonadIO?
06:12:49 <Sizu1> matthew-_: type YourMonad = ErrorT YourError IO a
06:13:10 <Sizu1> s/YourMonad/YourMonad a/
06:13:26 <hpaste>  matthew-_ pasted "this!" at http://hpaste.org/4868
06:13:55 <matthew-_> EvilTerran, Sizu1: ^^ paste
06:14:27 <matthew-_> Sizu1: so from that I think formatter :: String -> YourMonad String ?
06:16:26 <EvilTerran> matthew-_, so you're getting something of type m String (for some unknown m) and want to get it into an IO String?
06:16:43 <matthew-_> yes
06:19:09 <Sizu1> i don't know enough about monads to say if this is possible or how to do that.
06:19:09 <Sizu1> i see only one function in the paste. how do you use it? and how do you use formatter?
06:19:31 <EvilTerran> well, you could use catchError to get the value out, if you had a MonadError context
06:19:47 <EvilTerran> you could use head.toList if you had a Foldable context
06:19:56 <hpaste>  matthew-_ annotated "this!" with "some additional details" at http://hpaste.org/4868#a1
06:20:15 <matthew-_> oh, the type there on formatter is clearly wrong ;)
06:22:03 <EvilTerran> ?instances-importing Control.Monad.Instances MonadError
06:22:06 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
06:22:57 <EvilTerran> ?instances-importing Control.Monad.Error Error
06:22:58 <lambdabot> IOError, [Char]
06:23:04 <EvilTerran> hm...
06:23:45 * EvilTerran expected there to be an instance Error () and an instance MonadError () Maybe
06:24:23 <matthew-_> right, it's liftIO with runErrorT
06:24:24 <matthew-_> I think
06:24:54 <EvilTerran> if your MonadError's an application of ErrorT, yes
06:27:12 <EvilTerran> actually, I think you need more than MonadError m => m String to get the value out
06:27:21 <matthew-_> yeah, me too
06:27:51 <EvilTerran> I'd suggest Foldable again, but it seems to lack instances somewhat
06:29:09 <EvilTerran> no "instance Foldable (Either a) where fold = either mzero id" or whatever
06:29:16 <EvilTerran> er, s/mzero/mempty/
06:29:36 <EvilTerran> ?instances-importing Data.Foldable Foldable
06:29:37 <lambdabot> Maybe, []
06:29:50 <EvilTerran> ?src Maybe fold
06:29:50 <lambdabot> Source not found. I've seen penguins that can type better than that.
06:32:33 <EvilTerran> wait, can't use fold as the minimal def; instance Foldable (Either a) where foldr f e (Left _) = e; foldr f e (Right x) = x `f` e
06:32:45 <EvilTerran> (based directly on the Maybe instance)
06:33:25 * EvilTerran stops babbling about Foldable now
06:36:06 <matthew-_> you know what? After all this, I now can't see why I wanted this generalisation in the first place
06:36:26 <hpaste>  ToRA annotated "this!" with "does this example help?" at http://hpaste.org/4868#a2
06:36:33 <matthew-_> I've gone back to the use site and just filled it in and I can't see what was going on at all...
06:36:53 <ToRA> does the example i've pased make things any clearer (assuming i've understood what you want to do...?)
06:37:10 <matthew-_> yes, ToRA, that does actually help quite a lot
06:38:03 <quicksilver> matthew-_: thinking about generalisations and abstractions is often helpful even if it turns out you don't use them
06:38:14 <quicksilver> nothing clarifies the mind like seeing why an generalisation doesn't apply.
06:39:13 <matthew-_> quicksilver: yeah, I'll let you know when that clarity hits ;)
06:41:18 <ToRA> matthew-_, note that the res <- line is the same as (in this case)
06:41:19 <ToRA>   let (res2::Either String String) = foo "yo"
06:41:42 <ToRA> since foo doesn't use IO in any way
06:41:52 <quicksilver> because the precise reason why the generalisation isn't useful turns out to be an important observation about your specific domain.
06:44:31 <matthew-_> ToRA: hang on. what about foo = return
06:44:44 <matthew-_> how do you differentiate the two cases in res ?
06:44:54 <ToRA> 1 sec, i'll updte the example
06:45:51 <matthew-_> oh I see, you get an Either back
06:45:53 <matthew-_> right
06:46:58 <hpaste>  ToRA annotated "this!" with "liftIO and let" at http://hpaste.org/4868#a3
06:47:57 <ToRA> in context of the example, you couldn't use let in the foo2 case, as Either isn't an instance of MonadIO (if that makes sense)
06:51:00 <matthew-_> ToRA: did you check those examples actually compiled?
06:51:09 <ToRA> yes, cos i ran them
06:51:53 <ToRA> why?
06:52:54 <matthew-_> I don't quite see how you've got away with such a light type sig on foo
06:53:27 <matthew-_> I'm getting things like: Couldn't match expected type `ErrorT e IO' against inferred type `m'
06:53:45 <ToRA> from my example?
06:53:49 <ToRA> or from your code?
06:54:00 <matthew-_> mine
06:54:12 <matthew-_> but I'm using just the same constraints that you've used
06:54:18 <tibbe> dcoutts_: ping
06:54:24 <ToRA> foo = your formatter yeah?
06:55:01 <ToRA> is the error coming from the <- runErrorT  in sRespInCache or from formatter?
06:55:06 <hpaste>  matthew-_ annotated "this!" with "voilla" at http://hpaste.org/4868#a4
06:56:17 <ToRA> matthew-_ your class constraint is in the wrong place
06:56:32 <ToRA> i guess
06:56:47 <tibbe> anyone know how to convince firefox to show haskell files (i.e. text/x-haskell mime type) in the browser as text?
06:57:00 <matthew-_> ToRA: that's not a compelling answer ;)
06:57:15 <ToRA> there you're saying that the caller of sRIC will tell you what the m is
06:57:29 <ToRA> but actually, sRIC wants to fix the m to ErrorT IO
06:57:31 <pejo> tibbe, atleast in netscape you had a special place in the options for different mime-types and their default-actions.
06:57:51 <ToRA> ditch the m from ProxyConfig
06:57:54 <tibbe> pejo: you can set them in FF but not to "show in browser" or something similar
06:57:58 <ToRA> and I think change the decl to
06:58:16 <ToRA>  , formatter :: (forall m . MonadError m) => String -> m String
06:58:17 <ToRA> ?
06:58:31 <matthew-_> ugh and add a dozen more language extensions...
06:58:49 <ToRA> probably
06:58:50 <ToRA> ;)
07:02:33 <matthew-_> success
07:02:40 <ToRA> \o/
07:03:18 <matthew-_> now, how to work out what language extensions I actually needed?
07:04:11 <byorgey> matthew-_: guess and check? =)
07:05:00 <matthew-_> really, wtf is the point of adding all this LANGUAGES and -X stuff if you can't actually figure out what you've used
07:06:55 <ToRA> PolymorphicComponents and FlexibleContexts
07:06:57 <ToRA> ?
07:07:07 <matthew-_> nope
07:07:11 <matthew-_> {-# LANGUAGE FlexibleContexts, Rank2Types #-}
07:07:22 <ToRA> don't use Rank2Types
07:07:32 <ToRA> use RankNTypes
07:07:43 <opqdonut> :D
07:07:46 <matthew-_> actually, this is another point. It may not be Rank2Types. It may be something that Rank2Types depends on. But again, you can't tell
07:07:52 <opqdonut> spoken like a true mathematician
07:07:53 <resiak> @pl \(x,y) -> (x, f y)
07:07:53 <lambdabot> second f
07:07:57 <resiak> :t second
07:07:57 <C-Keen> Hi! How can I assign a hex value to a Data.ByteString ?
07:08:02 <resiak> @ty second
07:08:02 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
07:08:02 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
07:08:18 <resiak> @index second
07:08:18 <lambdabot> Control.Arrow
07:11:04 <quicksilver> C-Keen: (a) parse hex into Word8s (b) pack Word8s into bytestring
07:16:13 <FunctorSalad> matthew-_: hmm just joined... what do you suggest? just use -fglasgow-exts?
07:16:58 <matthew-_> well, if I don't know what I need, I tend to just ram on glasgow-exts
07:17:12 <matthew-_> but then when I'm tidying up, I want to reduce to the minimum
07:17:33 <FunctorSalad> is there a pragma to enable everything too?
07:17:42 <byorgey> matthew-_: actually, one thing you can do is just disable all extensions and see what errors you get.
07:17:54 <dmhouse> FunctorSalad: well, {-# OPTIONS_GHC -fglasgow-exts #-}
07:17:56 <byorgey> matthew-_: often they are helpful in suggesting an option to turn off to make the error go away.
07:18:02 <FunctorSalad> thx dmhouse
07:18:17 <byorgey> matthew-_: e.g. "foo bar is not allowed.  Enable ExtensionFooBar to allow this."
07:18:36 <matthew-_> byorgey: yes, I've seldom seen errors that helpful
07:18:44 <matthew-_> and there are some errors which suggest the wrong extension too.
07:18:47 <matthew-_> super helpful
07:19:15 <Sizu1> i've seen and used error messages like this a lot
07:19:17 <FunctorSalad> why would you want to be parsimonious with extensions?
07:19:20 <byorgey> maybe I've just been lucky =)
07:19:27 <byorgey> matthew-_: what version of ghc are you using?
07:19:57 <matthew-_> byorgey: 6.8.2
07:20:02 <byorgey> mm, ok
07:20:27 <ToRA> i think if you turned on e.g. ExistentialQuantification in 6.6 you basically got -fglasgow-exts
07:20:43 <matthew-_> oh ffs. It's just too much to ask that Network.HTTP and Network.CGI both have the same data structures for HTTP headers isn't it?
07:20:56 * matthew-_ is getting rather bitter in his dotage
07:21:06 * quicksilver hands matthew-_ some slippers and a pipe
07:21:28 <Sizu1> was actually fun for me to code, and then find out that it's not supported by haskell98. learning all kinds of cool names for my swearing lexicon
07:21:51 <Sizu1> You ParametricTypeClass!
07:22:31 <byorgey> UndecidableInstance!
07:22:59 <Sizu1> You TypeSynonymInstance!
07:24:03 <C-Keen> quicksilver: I don't understand how to construct a Word8
07:24:20 <resiak> -XSpoonyBard!
07:24:39 <FunctorSalad> why does your code have to be haskell98 (sorry if this is a stupid q)
07:24:42 <FunctorSalad> ?
07:24:51 <Sizu1> Monoidal Functor!
07:25:07 <quicksilver> C-Keen: fromIntegral, perhaps. it depends what you want to construct it from.
07:25:27 <pitecus> Any idea what this is all about: ghc-6.8.1: panic! (the 'impossible' happened)
07:25:27 <pitecus>   (GHC version 6.8.1 for i386-unknown-linux):
07:25:27 <pitecus>         cat_evals
07:25:27 <pitecus>     gramlab-lib-0.2:GramLab.Data.Diff.EditTree.Split{d r1bv}
07:25:27 <pitecus>     [ix{v a289} [lid], lt{v a28a} [lid], rt{v a28b} [lid]]
07:25:28 <pitecus>     [!, !, _, _]
07:25:36 <Sizu1> FunctorSalad: it doesn't.
07:25:40 <C-Keen> quicksilver: Well I just need a constant of magic bytes I compare against
07:25:41 <quicksilver> pitecus: upgrade to 6.8.2
07:25:57 <quicksilver> C-Keen: foo = 48 :: Word 8
07:26:06 <quicksilver> C-Keen: or, foo :: Word8 ; foo = 48
07:26:08 <quicksilver> if you prefer
07:26:13 <pitecus> quicksilver, I upgraded to 6.8.1 like 1 month ago!
07:26:14 <C-Keen> quicksilver: ah! thank you very much
07:26:17 <quicksilver> without the space before the 8 ;)
07:26:25 <Sizu1> pitecus: time to do it again ;)
07:26:34 <quicksilver> pitecus: however, you upgraded to a version with bugs in.
07:26:44 <pitecus> Its a huge hassle to upgrade *sigh*
07:27:02 <quicksilver> pitecus: this leaves you with three choices : (a) don't compile the code which triggers the bugs (b) fix the bugs yourself (c) try a different version which has different bugs!
07:27:08 <quicksilver> it's entirely up to you which you choose.
07:27:33 <pitecus> ya i know, i know
07:27:37 <byorgey> pitecus: option (d): if you wiggle a magnet over your hard drive in exactly the right way, it fixes the bugs in 6.8.1 without having to upgrade
07:29:21 <pitecus> jokes aside, is it the case that this particular bug is fixed in 6.8.2, or is it just a vague possibility that it might be fixed, and after spending a few hours upgrading i still have the same problem?
07:31:17 <ToRA> pitecus: if you can replicate the bug in a small bit of code that fits on hpaste i'll try it in 6.8.2 if you want to check
07:31:47 <ToRA> (and because i'm curious to see code that breaks ghc)
07:31:53 <Sizu1> i encountered a few bugs with 6.8.1 that were fixed in 6.8.2
07:32:07 <Sizu1> that's a no guarantee that yours will be fixed, but what alternative do you have?
07:32:46 <pitecus> ToRA, thanks, but it'll probably take more time to try to reduce the code to a snippet than to upgrade, its a biggish project im compiling
07:32:46 <quicksilver> pitecus: 6.8.2 is known to fix some "the impossible happened" bugs.
07:32:54 <quicksilver> if you want to know for sure, a test case is the best way.
07:33:19 <pitecus> quicksilver, i guess i'll give it a shot...
07:34:11 <resiak> If I want to use (FilePath, OpenMode, OpenFileFlags) as the key for a Map, is there anything bad and wrong about inventing Ord instances for OpenMode and OpenFileFlags?
07:36:04 <Sizu1> i don't see any. they are just values.
07:36:26 <Corun> Heya
07:36:29 <ToRA> probably don't even need to write your own instances, just use 6.8 standalone deriving for them?
07:36:56 <Sizu1> can you derive twice?
07:37:45 <ToRA> neither derive any classes already as far as i can see?
07:37:47 <resiak> I don't have 6.8, so
07:38:30 <quicksilver> I think you could probably go as far as to file a bug that they don't have ord instances
07:38:36 <quicksilver> simple types like that should all have ord instance!
07:39:04 <quicksilver> hmm
07:39:09 <quicksilver> IOMode does have an ord instance
07:39:16 <quicksilver> what did you mean by OpenMode?
07:39:39 <resiak> file:///usr/share/doc/ghc6-doc/html/libraries/unix/System-Posix-IO.html#t%3AOpenMode
07:40:30 <quicksilver> Yup. I think that's a bug in the posix package, personally.
07:40:44 <quicksilver> resiak: but, why are you using posix? there aren't many reasons you need to.
07:43:05 <Sizu1> yeah, this sicks! my haddock failed on hackage
07:43:13 <Sizu1> sucks*
07:43:46 <resiak> quicksilver: because it's what the flags to open(2) are mapped to in the existing hfuse binding; i could map them to IOMode instead; hrm
07:45:05 <resiak> in any case, should i file the bug over on the ghc trac, or elsewhere?
07:45:20 <quicksilver> I don't actually know. GHC trac I assume.
07:45:27 <C-Keen> hm, how can I strip the value of a monad? hGet :: Handle -> Int -> ByteString -> IO() now how can I use the actual value since there are no functions defined for using that type?
07:46:37 <Tac-Tics> the actual value of what exactly C-Keen?
07:47:16 <Sizu1> C-Keen: you cannot get rid of IO, but you can use the values inside it
07:47:28 <ToRA> that isn't the type of hGet; hGet :: Handle -> Int -> IO ByteString no?
07:47:35 <tlaboc> :t hGet
07:47:37 <C-Keen> Tac-Tics: I a reading some bytes with hGet f 3, say, but when I try to append this to another ByteString the compiler complains
07:47:38 <lambdabot> Not in scope: `hGet'
07:48:03 <tlaboc> the type is Handle -> Int -> IO ByteString
07:48:09 <Sizu1> do { str <- hGet f 3; doStuff str }
07:48:28 <Tac-Tics> C-Keen, the only way to extract the value is using "bind"
07:48:38 <C-Keen> tlaboc: you are right
07:48:49 <Tac-Tics> so using do's arrow notation as Sizu1 has above, or with >>=
07:49:06 <C-Keen> Tac-Tics: I did buf <-  B.hGet (chunksize+1) let msg = sync ( B.append bytes buf ) in
07:49:07 <tlaboc> C-Keen: http://www.haskell.org/hoogle/ for the win
07:49:08 <lambdabot> Title: Hoogle
07:49:10 <C-Keen> which is wrong
07:49:32 <Tac-Tics> can you hpaste it?
07:49:34 <Tac-Tics> @paste
07:49:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:49:53 <resiak> quicksilver: i think i'll stick to using posix, for closer mapping to the underlying fuse api.  thanks for pointing out iomode
07:50:35 * quicksilver nods
07:50:46 <hpaste>  c-keen pasted "some wrong reader" at http://hpaste.org/4869
07:51:22 <quicksilver> C-Keen: you missd out the "f" from the hGet, surely.
07:51:34 <C-Keen> oh boy
07:51:58 <Tac-Tics> hehe, so close to the monads you couldn't see the trees =-)
07:52:28 <C-Keen> true
07:53:33 <quicksilver> type errors are useful but they take a while to learn to locate
07:53:40 <quicksilver> they often appear to be in the wrong place
07:54:23 <C-Keen> I hope I get the gist of this soon
07:54:28 <Tac-Tics> currying is cool but you really can't write good error messages into a language which uses it
07:54:52 * axm loves glasgow-exts and some additional types when in doubt for that
07:54:56 <Sizu1> ^ example of how not to market ;)
07:58:21 <nornagon> uh-oh
07:58:35 <nornagon> i think i just accidentally wrote a monad tutorial :(
07:58:41 <Tac-Tics> haha
07:58:43 <Tac-Tics> please link
07:59:06 <gbeshers> Can anyone else get to darcs.haskell.org?
07:59:07 <therp> nornagon: don't worry. that happens here all the time
08:00:04 <Igloo> gbeshers: I can
08:00:14 <FunctorSalad> I like the one with the monsters...
08:00:29 <nornagon> Tac-Tics: not quite finished yet
08:00:46 <nornagon> i still need to write the 'surprise, you just learned how monads work' bit
08:01:42 <pjd> less monads, more functors!
08:02:00 <nornagon> what's actually the difference?
08:02:09 <nornagon> @src Functor
08:02:09 <lambdabot> class  Functor f  where
08:02:09 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
08:02:16 <pjd> @src Applicative
08:02:16 <lambdabot> class Functor f => Applicative f where
08:02:16 <lambdabot>     pure  :: a -> f a
08:02:16 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
08:02:22 <pjd> they're simpler and more general
08:02:28 <Sizu1> can i clobber a package with the same version in hackage?
08:02:35 <nornagon> @src Monad
08:02:35 <lambdabot> class  Monad m  where
08:02:35 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
08:02:35 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
08:02:35 <lambdabot>     return      :: a -> m a
08:02:35 <lambdabot>     fail        :: String -> m a
08:02:46 <tlaboc> Functors can only lead to madness :)
08:02:50 <pjd> people should learn them before monads
08:02:52 <nornagon> pjd: but ghc doesn't have syntactic sugar
08:02:58 <nornagon> for functors, i mean.
08:03:01 <nornagon> yes?
08:03:27 <Nicko> Haskell will be a mature language when haskell programmers begin to think about solving real world problems
08:03:27 <pjd> nornagon: many people advocate learning the syntax sugar last of all
08:03:55 <gbeshers> Igloo: thanks, I can from work but not from home --- cox networking to blame I suspect.
08:04:03 <resiak> pjd: FEWER monads!
08:04:58 <nornagon> pjd: i don't think that's a useful approach, really
08:05:03 <quicksilver> Nicko: IRC will be a mature medium when commentators begin to think about what they say before saying it.
08:05:17 <nornagon> resiak++
08:05:20 <Nicko> touchÃ©
08:05:23 <Nicko> ;)
08:05:29 <quicksilver> Nicko: which is an un-necessarily sharp way of saying that some haskell programmers already do think about real problems ;)
08:05:41 <pjd> resiak: no, less (focus on) monads
08:05:53 <quicksilver> the guys over at galois, those ones at jane st capital, etc
08:06:14 <resiak> heh, you win
08:06:27 <quicksilver> Nicko: I think about real world problems all the time, although my dayjob prevents me from implementing them as much as I'd like :)
08:06:38 <pjd> resiak: :)
08:07:32 <Nicko> IÂ´m a bit frustrated with haskell because hs-plugins does not work in windows, and I need it desperately
08:07:41 * quicksilver nods
08:07:49 <quicksilver> yeah, that's annoying
08:08:00 <quicksilver> hs-plugins was a bit of a hack, although an extraordinarly clever one
08:08:12 <quicksilver> the new version is less of a hack, though, since it uses a more stable API
08:08:20 <quicksilver> and hopefull it will progress to not being a hack at all soon :)
08:08:30 <Sizu1> what do you do quicksilver?
08:08:40 <Nicko> when is supposed to be available?
08:09:08 <quicksilver> Nicko: sometime in the next week or three I think. I'm not sure who exactly is working on it.
08:09:12 <FunctorSalad> "nornagon> what's actually the difference?" <-- for one thing, monads always go from one category to the same cat, functors don't have to
08:09:16 <quicksilver> There was some discussion on the -cafe recently.
08:09:21 <resiak> Is there any reason, other than non-spherical tuits, that GHC doesn't do shared libs on *nix?
08:09:34 <Nicko> nice I canÂ´t wait for it
08:09:43 <quicksilver> resiak: yes, there was a reason but I can't remember what it was.
08:09:50 <quicksilver> resiak: they are working on a version which does, though.
08:10:03 <quicksilver> Sizu1: I'm a *blush* Perl programmer.
08:10:20 <resiak> okay.  it struck me that it might overlap with the kind of things hs-plugins needs
08:10:58 <Sizu1> just general slap-things-together hackery or more solid stuff?
08:11:27 <quicksilver> Sizu1: I like to think it's solid.
08:11:58 <Nicko> quicksilver, by the way, i found that "eval" statements have problems if the object file is loaded trough "load"
08:12:05 <Nicko> under ubuntu
08:12:35 <quicksilver> Nicko: that's odd, but out of my area of expertise. dons is the real guru...
08:12:44 <Nicko> I know
08:12:47 <quicksilver> any hs-plugins thaumaturges around?
08:17:37 <FunctorSalad> any guides on which GUI toolkit to use?
08:18:00 <quicksilver> gtk2hs is popular
08:18:10 <dcoutts> @arr!
08:18:10 <lambdabot> Drink up, me 'earties
08:18:32 <quicksilver> gtk2hs is mostly used by pirates
08:18:38 <FunctorSalad> quicksilver: yes, have heard of that. wondered if there are any other options (should be rather simple, don't think I will use fancy things)
08:18:40 <C-Keen> god if I would actually _read_ the compiler errors I would be done by now
08:18:46 <dcoutts> which reminds me, I need to release a windows installer for gtk2hs that works with ghc-6.8.2
08:18:52 <C-Keen> but you get used to it pretty quick
08:19:16 <FunctorSalad> (btw, I mean't which toolkit to *learn*)
08:20:00 <nornagon> FunctorSalad: that makes no sense, btw.
08:20:01 <Sizu1> what was it Fruits or something
08:20:07 <nornagon> oh
08:20:11 <nornagon> actually, i suppose it does
08:20:11 * mux can't wait to get back to home in order to reboot his cable modem and get a teste of his new connection speed (30Mb/s -> 100Mb/s)
08:20:15 <FunctorSalad> nornagon: what?
08:20:18 <nornagon> but i don't really understand what that's useful for
08:20:24 <nornagon> functors vs monads
08:20:32 <Nafai> mux: Nice upgrade!
08:20:36 <Sizu1> grats mux
08:20:38 <nornagon> the m -> m vs f -> f'
08:20:43 <FunctorSalad> nornagon: in math most things aren't endofunctors
08:20:51 <nornagon> ... what.
08:20:57 * mux feels like a kid waiting to open his christmas presents
08:21:01 <nornagon> you haskellers and your scary maths talk.
08:21:05 <FunctorSalad> nornagon: functors from a category to itself
08:21:48 <Sizu1> remember Bill Gates once said that nobody will ever need more than 640KB memory
08:22:28 <mux> but he didn't say that nobody will ever need 100Mb/s, did he? :-)
08:22:31 <Sizu1> or was it 1.4MB of the floppy? same diff
08:22:38 <mux> it was 640k RAM
08:23:02 <C-Keen> how can I pass Arguments in ghci to main?
08:23:36 <mux> :set args I think
08:23:41 <C-Keen> ah
08:23:55 <quicksilver> C-Keen: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-commands.html
08:23:56 <lambdabot> Title: 3.7. GHCi commands, http://tinyurl.com/ytkpuj
08:23:59 <quicksilver> you can also use :main
08:24:03 <resiak> @hoogle Float -> Int
08:24:04 <lambdabot> No matches, try a more general search
08:24:41 <quicksilver> resiak: round
08:24:46 <quicksilver> floor, ceiling
08:24:51 <resiak> aha!
08:25:03 <resiak> cheers
08:27:24 <Nicko> can anyone recommend a cheap virtual private server provider?
08:28:18 <Nicko> sorry, wrong channel
08:35:16 <Sizu1> quicksilver: man how can you continue with perl? i cannot code any other language since i learned hs
08:38:07 <quicksilver> Sizu1: the money softens the blow.
08:38:14 <Sizu1> just trying to make myself start coding perl again.
08:38:23 <pjd> nornagon: have you looked at Control.Applicative?
08:38:58 <nornagon> pjd: no?
08:39:28 <pjd> there are lots of things that form applicative functors, but not monads
08:39:43 <pjd> they lie sort of between Functor and Monad
08:40:05 <nornagon> scary.
08:40:15 <pjd> for example, zipping
08:41:13 <quicksilver> there are also times when the monad structure is not needed and it's just more convenient to use applicative style
08:41:18 <quicksilver> even though it *is* actually a monad
08:41:53 * roconnor agrees with quicksilver
08:42:06 <pjd> indeed
08:42:15 <pjd> > (+) 10 1
08:42:18 <lambdabot>  11
08:42:29 <pjd> > (+) <$> [10,20] <*> [1,2]
08:42:30 <lambdabot>  [11,12,21,22]
08:43:08 <roconnor> ``Step functions from an applicative functor (they also from a monad, but monads are so 20th century).''
08:43:13 <pejo> Sizur, Haskell isn't always the right tool for the job.
08:43:18 <osfameron> Sizu1: they are different.  I enjoy programming Perl still (as I know it better than haskell, I also find it far easier in many respects).  Which does't mean I wouldn't like some of haskell's niceties in Perl though...
08:43:25 <quicksilver> pejo: HERESY!
08:43:30 * quicksilver builds a bonfire.
08:43:55 <roconnor> quicksilver: I'll get the bananas and barbed wire
08:44:17 <osfameron> marshmallows are tastier than barbed wire
08:44:20 <znutar> write a haskell program that generates the right tool, duh
08:44:22 <quicksilver> osfameron: s/some/all/
08:44:22 <Sizu1> i heard ppl say over and over that i18n is not meant for haskell
08:44:32 <Sizu1> then i wrote it
08:44:43 <osfameron> quicksilver: well, all of its niceties I guess :-)
08:46:11 <Sizu1> i know perl better too. and i wrote some nice frameworks with it. i'm still too much fascinated with haskell to see any other lang
08:46:18 <pjd> nornagon: that example above is simplistic, but it shows how you can "lift" a function application's parameters with <$> and <*>
08:46:53 <aleator> Hi,  Are there any nice string-template libraries lying around? I tried Text.HTML.Chunks but that didn't seem to work.
08:47:14 <quicksilver> aleator: I think the answer is no.
08:47:39 <aleator> Hmm. Sad. Could really use one.
08:48:14 * quicksilver half-jokingly suggests invoking Template::Toolkit via the shell.
08:48:48 <aleator> Well. :)
08:49:08 <Sizu1> shall we write TT combinators? heh
08:49:48 <aleator> Is it just me, or does anyone else feel that haskell is bit hard to bend that way?
08:50:14 <Sizu1> what do you need string templates for in particular?
08:50:14 <quicksilver> which way?
08:50:30 <quicksilver> I don't think you could easily write text tempaltes as a convenient DSL
08:50:38 <quicksilver> the overhead of the haskell lexer is too high
08:50:52 <quicksilver> but writing parsers in haskell is a doddle
08:51:06 <aleator> quicksilver: Yeah, that was what I tried to say.
08:51:07 <quicksilver> so a simplistic template language in the general style of TT would not be hard.
08:53:20 <aleator> I'd think given some sort of extensible records you actually could do it dsl way as well..
08:53:45 <`party> :D
08:53:47 <pyx> D
08:54:32 <`party> anybody speake russia?
08:54:35 <Sizu1> da
08:54:38 <pyx> )
08:54:39 <pyx> ÿÿ
08:54:55 <pyx> åñòü êòî â õàñêåëå æàðèò? )
08:55:06 <Sizu1> well, we can even write a TT parser and simply use the .tt's
08:55:09 <quicksilver> this is, however an english-language channel.
08:55:18 <pyx> ok
08:55:21 <quicksilver> Sizu1: that would seem saner than inventing yet another syntax.
08:55:35 <Sizu1> pyx: i cannot read your text, it's not unicode
08:55:36 <quicksilver> Sizu1: unless of course there is something very objectional about TT syntax.
08:55:43 <Igloo> pyx: You might want #haskell.ru, #haskell_ru or (jabber) haskell@conference.jabber.ru
08:55:44 <osfameron> you would have to write a perl parser to implement [% perl %] tags of course...
08:55:50 <ADEpt> Sizu1: it's russian in cp1251
08:56:05 <`party> haskell_ru is empty
08:56:09 <quicksilver> osfameron: not necessarily, you could just shell them out verbatim to a perl subprocesss
08:56:13 * pyx slaps Igloo around a bit with a large trout
08:56:15 <Sizu1> i will not use anyting but unicode! :D
08:56:19 <quicksilver> osfameron: however, it would be saner not to use them :P
08:56:20 <pyx> <Igloo> thx
08:56:31 <Igloo> Sorry, wrong person
08:56:45 <ADEpt> `party: jabber conf is not
08:56:51 <osfameron> quicksilver: yeah :-)  there should be a subset of TT which is language neutral, with [% perl %] blocks considered a local implementation detail
08:56:59 <Igloo> `party: Know idea how accurate that list is, I just copied from http://www.haskell.org/haskellwiki/IRC_channel
08:57:01 <lambdabot> Title: IRC channel - HaskellWiki
08:57:38 <osfameron> that said, it TT's dot notation as useful a concept with haskell as it is with perl structs/objects ?
08:57:41 <quicksilver> osfameron: s/a local.*detail/harmful/
08:58:10 <quicksilver> osfameron: well some kind of nested-maps-of-strings approach is quite natural for a template "stash" I would say.
08:58:23 <quicksilver> but maybe you could think of something a bit better typed.
08:58:34 <osfameron> quicksilver: not necessarily. It's poor style and could be better encapsulated in a plugin or object, but it can be useful for some tasks
08:58:46 <C-Keen> hm, how can I nicely print a ByteString? I am currently unpacking it and then trying to show it but this does not match the type
08:58:49 <quicksilver> useful and harmful are not incompatible :)
08:59:03 <dcoutts> C-Keen: it's already an instance of Show
08:59:04 <quicksilver> C-Keen: how would you like to print it? :)
08:59:15 <quicksilver> C-Keen: you could just show it, it depends what kind of answer you want though.
08:59:16 <dcoutts> or just putStr it
08:59:18 <pyx> somebody plz help me to write one programm on haskel
08:59:50 <quicksilver> pyx: I'm sure we're happy to help but we can't help till you ask the question :)
08:59:59 <pyx> ok
09:00:00 <pyx> =)
09:01:08 <`party> he will forulate his question thirty minet :))
09:01:12 <`party> m
09:01:46 <ricky_clarkson> Hang on, just scanning the lecture notes in!
09:04:01 <C-Keen> dcoutts: quicksilver I forgot some parenthesis
09:06:45 <Sizu1> going home. ttyalll
09:07:07 <tibbe> dcoutts: did you ever add those monoid instances for cabal flags?
09:07:29 <dcoutts> tibbe: yes
09:07:39 <tibbe> dcoutts: where's the code?
09:07:48 <dcoutts> tibbe: in the Cabal HEAD branch
09:08:02 <dcoutts> tibbe: and I've made good use of it in cabal-install
09:08:39 <dcoutts> so that cabal-install can combine it's own defaults and overrides from config files and command line to the configure flags to pass when building a package
09:09:16 <dcoutts> we use the Monoid.mappend to combine/override sets of flags
09:09:37 <tibbe> dcoutts: cool, I'll have a look
09:10:06 <dcoutts> tibbe: you're interested in hacking on that kind of stuff? if so the next similar project is to make the config file stuff similar
09:10:18 <quicksilver> dcoutts: don't you wish Monoid.mappend had a conventional symbolic name?
09:10:20 <quicksilver> I do.
09:10:44 <dcoutts> quicksilver: I don't use it that much, only in a few key places, it doesn't need to be shorter for my purposes
09:10:57 * quicksilver nods
09:11:00 <tibbe> dcoutts: on an unrelated note: I'm having some problems structuring my code which runs in a ReaderT IO monad just like xmonad, it seems like I end up with liftIO everywhere, could you have a look and give some hints? it's a short piece of code in one file.
09:11:07 <dcoutts> quicksilver: I understand the desire to rename ++ to mappend of course
09:11:24 <cinimod> @hoogle (a -> b) -> (a,a) -> (b,b)
09:11:25 <lambdabot> No matches, try a more general search
09:11:48 <dcoutts> tibbe: aye, that's a common problem with monads layered on IO when you tend to do a lot of IO
09:11:49 <tibbe> dcoutts: is it in darcs.haskell.org/cabal ?
09:11:55 <cinimod> @hoogle (a -> b) -> (c -> d) -> (a,c) -> (b,d)
09:11:57 <lambdabot> No matches, try a more general search
09:11:57 <dcoutts> tibbe: yes
09:12:05 <tibbe> dcoutts: I'll paste the code
09:12:07 <quicksilver> cinimod: that latter one is &&&
09:12:08 <dcoutts> tibbe: and /cabal-install
09:12:09 <tibbe> @paste
09:12:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:12:15 <quicksilver> cinimod: from Control.Arrow
09:12:15 <BMeph> cinimod: That's &(&&)
09:12:28 <dcoutts> tibbe: eg in the Cairo bindings we just suffer it and use liftIO a lot
09:12:29 <BMeph> s/&(&&)/(&&&)
09:12:31 <cinimod> quicksilver: how come hoogle doesn't find it?
09:12:37 <quicksilver> cinimod: because it has a more general type
09:12:44 <quicksilver> :t (&&&)
09:12:46 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
09:12:51 <BMeph> The first one is join (&&&)
09:12:57 <dcoutts> tibbe: Cabal itself will want to move to a monad layered on IO at some point
09:13:00 <dcoutts> hia nominolo
09:13:04 <quicksilver> oh
09:13:06 <quicksilver> it's ***
09:13:08 <quicksilver> not &&&
09:13:09 <hpaste>  tibbe pasted "liftIO all over the place!" at http://hpaste.org/4870
09:13:10 <quicksilver> I misled you!
09:13:26 <nominolo> yo dcoutts!
09:13:30 <dcoutts> tibbe: and we probably need several varieties of monads in Cabal some of which share the same methods/actions
09:13:31 <BMeph> Eh, me too.
09:13:35 <dcoutts> nominolo: good holiday?
09:13:55 <tibbe> dcoutts: if you have a look at the code you see that most functions end up with the type ..... -> IO () while I want them to have .... -> Server () but I'm unsure how to refactor it
09:13:59 <cinimod> :t (***)
09:14:00 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:14:14 <nominolo> dcoutts: yahman!
09:14:24 <BMeph> > join (***) (^2) 3 4
09:14:25 <lambdabot>  Couldn't match expected type `t1 -> t'
09:14:29 <dcoutts> tibbe: so my idea was to use a number of classes which extend Monad with extra ops, then working in any monad that implements those classes can use the extra actions without liftIO
09:14:31 <waern> hi nominolo, tibbe & dcoutts
09:14:34 <harinath> @src Writer tell
09:14:35 <lambdabot> Source not found. Maybe you made a typo?
09:14:37 <byorgey> tibbe: I only see io in three places there.  Hardly seems like "all over the place"...
09:14:45 <cinimod> :i Arrow
09:15:08 <dcoutts> tibbe: but it's not very easily extensible for arbitrary IO actions, but then for Cabal that's part of what we're trying to move away from - arbitrary IO all over the place
09:15:20 <byorgey> cinimod: the type (Arrow a) => a b c represents a computation which takes an input of type b and outputs something of type c.
09:15:24 <dcoutts> hia waern, good job on getting haddock-2.0 out the door
09:15:28 <tibbe> byorgey: well, it's very coarse grained now, the environment is not even available in all functions because they run in IO () instead of Server (). I need to change that to Server () but that introduces all the liftIOs
09:15:38 <nominolo> hi waern
09:15:39 <byorgey> cinimod: one common instance of Arrow is, of course, (->)
09:15:40 <tibbe> dcoutts: makes sense
09:15:43 <tibbe> waern: hi
09:15:47 <dcoutts> nominolo: starting to get busy yet?
09:15:51 <waern> dcoutts: thanks, I'm looking at Cabal now
09:15:53 <byorgey> tibbe: oh, I see what you mean.
09:15:59 <nominolo> dcoutts: that's the plan
09:16:02 <cinimod> byorgey: that's what I wanted to know
09:16:04 <dcoutts> nominolo: you know I've always got plenty for you to look at ;-)
09:16:26 <tibbe> byorgey: I want acceptConnections to be in the Server monad for example so I can access the the environment from within to e.g. grab a file handle for logging
09:16:32 * nominolo is already trying to catch up on all the mail
09:16:36 <pyx> this is my problem http://slil.ru/25330287 plz help me solve it )
09:16:37 <byorgey> tibbe: right.
09:16:38 <lambdabot> Title: Õðàíåíèå ôàéëà, áåñïëàòíî çàêà÷àòü è ñêà÷àòü
09:17:05 <dcoutts> nominolo: tell me about it, go offline for 10 days and get 2000 emails
09:17:12 <BMeph> :t uncurry (join (***))
09:17:13 <lambdabot> forall b c. (b -> c, (b, b)) -> (c, c)
09:17:21 <quicksilver> *boggle*
09:17:29 <nominolo> dcoutts: that should make about 4000 mails for me then ...
09:17:42 <tibbe> byorgey: but if I change acceptConnections to Server () then the call to that function (from server') can't be in IO any more
09:17:42 <quicksilver> pyx's pastebin loads some adverts for me, and the word "task5.txt" in the cetner of the page
09:17:56 <byorgey> quicksilver: me too
09:17:59 <nominolo> dcoutts: i'm only reading cabal-devel and libraries, for now
09:18:00 <quicksilver> but it doesn't actually load the task
09:18:04 <quicksilver> whatever it is
09:18:27 <quicksilver> pyx: can you use a pastebin which works, like http://hpaste.org/ ?
09:18:38 <dcoutts> tibbe: did you paste the whole file or is it truncated? it doesn't look like too many io's all over the place to me
09:18:38 <pyx> 5 sec
09:18:41 <waern> dcoutts: build-tools field is parsed with parseDependency. Should we allow non-alpha-numeric characters in package names, or should we have a separate parser for build-tools?
09:18:59 <byorgey> dcoutts: I just asked tibbe the same question =)
09:19:04 <dcoutts> waern: what kinds of build-tools have such crazy names?
09:19:07 <nornagon> http://nornagon.net/exceptions.lhs <-- my monad explanation
09:19:08 <waern> dcoutts: g++
09:19:10 <pyx> <quicksilver> in a 3 minutes )
09:19:16 <dcoutts> waern: ah yes
09:19:18 <tibbe> dcoutts: I was a bit unclear, I'm trying to move all function to Server () to get the environment threaded through but that would introduce a lot of liftIOs
09:19:36 <tibbe> dcoutts: it's in an intermediate state, sorry about that
09:19:53 <quicksilver> tibbe: well, your forkIO is an extremely interesting point
09:20:01 <dcoutts> tibbe: oh I see
09:20:02 <quicksilver> tibbe: but, since it's read-only (ReaderT) it should be fine
09:20:14 <quicksilver> tibbe: if it was StateT you would have some interesting things to address.
09:20:24 <tibbe> quicksilver: ah yes :)
09:20:48 <quicksilver> tibbe: I imagein you need to replace forkIO with forkIO . runServer conf $
09:20:48 <dcoutts> waern: well fair enough, add an extra parser. While you're at it, you might like to use that to parse pkg-config package names/versions like "openssl-0.9.8g"
09:20:49 <tibbe> dcoutts: so basically every expression needs an liftIO
09:20:55 <hpaste>  pyx pasted "Expression" at http://hpaste.org/4871
09:21:01 <quicksilver> tibbe: where conf comes from an earlier ask
09:21:11 <waern> dcoutts: ok, sure
09:21:14 <tibbe> quicksilver: right
09:21:28 <byorgey> pyx: is this an assignment?
09:21:36 <dcoutts> waern: though those crazy pkg-config versions cannot fit into an ordinary Version type
09:21:48 <quicksilver> tibbe: you could read my ramblins about monadic tunnelling if you want to think about the general question of callbacks and custom monads.
09:21:50 <tibbe> quicksilver: what could be the problem if I don't (sorry, I don't see your point clearly yet)
09:21:58 <pyx> yes
09:22:00 <waern> dcoutts: wouldn't it be nice with package name components that can contain non-alpha-numeric characters?
09:22:02 <tibbe> quicksilver: sure, link it
09:22:05 <pyx> <byorgey> yes
09:22:16 <quicksilver> @go monadic tunnelling
09:22:17 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
09:22:18 <lambdabot> Title: [Haskell-cafe] Monadic tunnelling: the art of threading one monad through anothe ...
09:22:18 <waern> dcoutts: my-c++-parser-package-1.0.0
09:22:48 <quicksilver> tibbe: the basic point is that a function which accepts an action has type IO () -> IO (). If you liftIO it, that makes it IO () -> Server ().
09:22:51 <byorgey> pyx: ok, we're happy to help, but we won't do your homework for you.  Why don't you try writing some code yourself and come back if you have particular questions or problems.
09:22:56 <BMeph> :t curry (join (***))
09:22:57 <quicksilver> But really you want Server () -> Server ()
09:22:58 <dcoutts> waern: perhaps, for that we should propose it on the cabal-devel and/or libraries list since it impacts more stuff, like does ghc-pkg grok names like that?
09:22:58 <lambdabot>     No instance for (Arrow (,))
09:22:58 <lambdabot>       arising from use of `***' at <interactive>:1:12-16
09:22:58 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
09:23:11 <waern> dcoutts: right
09:23:12 <dcoutts> waern: are file names like that portable, eg win32?
09:23:19 <byorgey> pyx: if you really have no idea how to even start, you should probably talk to your professor.
09:23:22 <BMeph> :t curry (join (&&&))
09:23:23 <lambdabot>     No instance for (Arrow (,))
09:23:23 <lambdabot>       arising from use of `&&&' at <interactive>:1:12-16
09:23:23 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
09:23:33 <dcoutts> waern: there's more to it to change package names
09:23:39 <BMeph> :t curry . join (***)
09:23:39 <pyx> <byorgey>  i tryed...
09:23:40 <lambdabot> forall b c. (b -> c) -> b -> b -> (c, c)
09:23:59 <waern> dcoutts: ok, I'll just make another parser for now then
09:24:04 <byorgey> pyx: ok, can you paste your try as well?
09:24:11 <pyx> yes
09:24:12 <tibbe> quicksilver: oh, I see
09:24:16 <tibbe> quicksilver: thanks
09:24:23 <dcoutts> waern: yep
09:25:21 <hpaste>  (anonymous) annotated "Expression" with "(no title)" at http://hpaste.org/4871#a1
09:25:37 <pyx> it was me =)
09:32:16 <dons> ?users
09:32:16 <lambdabot> Maximum users seen in #haskell: 414, currently: 414 (100.0%), active: 17 (4.1%)
09:33:07 <quicksilver> ooh
09:33:12 <quicksilver> local maximum
09:33:16 <quicksilver> although two people just left
09:33:23 <quicksilver> lambdabot: obviously doesn't sample very often
09:33:31 <hpaste>  tibbe annotated "liftIO all over the place!" with "lots of IO with type errors" at http://hpaste.org/4870#a1
09:34:46 <quicksilver> tibbe: you don't need to / can't put liftIO inside bracket
09:34:58 <quicksilver> tibbe: because bracket takes IO() actions as parameters, not Serevr actions
09:35:00 <tibbe> quicksilver: right
09:35:17 <tibbe> so my problem is that I don't know what to do instead :)
09:35:29 <quicksilver> leave all that stuff as io
09:35:44 <quicksilver> and just put runServer conf in front og the bit which is really Server
09:35:48 <quicksilver> i.e. acceptConnections
09:36:06 <hpaste>  tibbe annotated "liftIO all over the place!" with "complete errors messages" at http://hpaste.org/4870#a2
09:36:27 <tibbe> ok
09:36:48 <hpaste>  quicksilver annotated "liftIO all over the place!" with "server' only" at http://hpaste.org/4870#a3
09:36:59 <quicksilver> tibbe: I have redone "server'" so you can see what I mean.
09:37:09 <tibbe> thanks
09:37:17 <pastorn> how do you pronounce "()"?
09:37:27 <glguy> unit
09:37:35 <byorgey> pyx: ok, that's a good start
09:37:38 <quicksilver> don't worry about having big chunks of IO in routines like that IMO.
09:37:52 <quicksilver> it's the application logic that benefits from the custom monad.
09:38:07 <quicksilver> pastorn: I don't very often. I sometimes say "brackets".
09:38:07 <byorgey> pyx: first, in the definition of 'varname', Var needs to be capitalized: haskell is case-sensitive.
09:38:12 <glguy> do io a ; io b ; io c   ~> io $ do a ; b ; c
09:38:23 <quicksilver> pastorn: some people say coin
09:38:33 <pastorn> quicksilver: sounds better
09:38:36 <quicksilver> pastorn: sometimes I read IO () as "IO action"
09:38:47 <byorgey> pyx: and you need the (Var p) in parentheses: otherwise it thinks you are trying to define a function with two arguments, rather than pattern-matching on the first argument
09:38:53 <glguy> () coin people must have a really rounded font ;)
09:39:15 <pyx> ok
09:39:33 <tibbe> quicksilver: I think I better understand how to do it now
09:40:23 <byorgey> pyx: for the definition "changeToConst Sequence []", I think you are missing some arguments
09:40:33 <pyx> <byorgey>  but i don't use Varname function...
09:40:34 <byorgey> pyx: if you don't care about them you can just put _
09:41:17 <byorgey> pyx: I am not sure what you mean
09:41:45 <pyx> yes, i lost [] _ _
09:42:24 <pyx> but it's not mait mistake (
09:42:27 <pyx> main
09:42:41 <byorgey> pyx: right.  Also, the (Sequence []) should be in parentheses, just like the (Var p) above
09:42:48 <C-Keen> hm what's the haskell way of checking for EOF when doing a hGet?
09:45:01 <byorgey> pyx: ok, now let's look at the last definition, for changeToConst (Sequence (x:ls)).
09:45:34 <pyx> ok
09:45:36 <byorgey> pyx: any ideas what isn't working there?
09:46:05 <pyx> i have mistake at ten line
09:46:16 <ddarius> pastorn: No one will know what you are talking about if you say "IO coin"
09:46:22 <pyx> changeToConst  op@(Assigment el (Var er) ) name number =
09:46:23 <pyx>           if ((varname er)==name)
09:46:43 <pyx> give me i 2 minutes, i'll do it )
09:46:56 <byorgey> ok =)
09:47:30 <byorgey> () = "coin"?  weird... =)
09:48:18 <pastorn> heh
09:48:23 <glguy> gio123 has quit coin
09:51:12 <tibbe> quicksilver: I have an interesting little dilemma now, either I sprinkle liftIO all over the place or runServer once per function that doesn't use the environment. if I do the latter I might as well pass the environment manually as I have to mention it in every function call anyway
09:52:00 <alexj> @seen lemmih
09:52:01 <lambdabot> lemmih is in #haskell. I last heard lemmih speak 3h 41m 40s ago.
09:55:20 <hpaste>  pyx annotated "Expression" with "(no title)" at http://hpaste.org/4871#a2
09:57:03 <byorgey> pyx: better! =)
09:58:08 <pyx> yeap.. (
09:59:53 <byorgey> pyx: ok, your definition of changeToConst is still not right.
10:00:15 <byorgey> changeToConst returns an Operator, but you are calling ++ on the result of changeToConst, and ++ only works on lists.
10:00:24 <pyx> i know. i need second helper function for [Operator]
10:01:05 <byorgey> pyx: sure, that's a good idea
10:01:11 <pyx> but Operator is Assigment Expression Expression | Sequence [Operator] , it's may be a list
10:01:27 <pyx> i trying to do it now )
10:01:48 <byorgey> pyx: ok.
10:06:10 <fadec> Anyone familiar with the Clean languge? I just skimmed a pdf intro and it looks the same as Haskell? What are the differences?
10:06:33 <ddarius> It is much the same, but there are a lot of superficial differences.
10:06:50 <dons> it uses uniquness typing, in particular. otherwise, its a sibling to haskell
10:06:55 <dons> or to haskell98, anyway
10:08:14 <hpaste>  pyx annotated "Expression" with "(no title)" at http://hpaste.org/4871#a3
10:08:37 <fadec> The IO typse look quite a bit different. I suppose that's due to the uniqueness typing. BTW, what is uniqueness typing?
10:08:54 <pyx> <byorgey> now i haven't idea... ( what's problem? (
10:09:28 <ddarius> @google clean uniqueness typing
10:09:30 <lambdabot> http://lethevert.blogspot.com/2007/06/concurrent-clean-unique-typing.html
10:09:30 <lambdabot> Title: lethevert should not be capitalized: Concurrent Clean: Unique Typing, Covariance ...
10:10:04 <ddarius> Not particularly helpful.
10:10:11 <byorgey> pyx: your types still don't match.
10:11:07 <pyx> why
10:11:35 <byorgey> pyx: well, there's still the ++ which is being called on Operators
10:13:13 <BMeph> pyx: I'm just wondering, if you try to get the varname of an Expression that isn't a Var, is your program supposed to blow up?
10:13:23 <byorgey> pyx: perhaps you want Sequence [changeToConst x name number, changeToConst' ls name number] ?
10:14:05 <pyx> <BMeph> mybe
10:14:45 <byorgey> BMeph: looks like pyx only uses 'varname' in places where the argument is provably a Var.
10:16:02 <byorgey> pyx: wait... shouldn't changeToConst' return [Operator]?
10:16:32 <pyx> no
10:16:43 <pyx> i'm not sure
10:16:53 <fadec> http://en.wikipedia.org/wiki/Pythagoreanism  -- Scroll down. The monad symbol Pythagoreans used to denote god looks like the monad in many tutorials.
10:16:53 <lambdabot> Title: Pythagoreanism - Wikipedia, the free encyclopedia
10:17:30 <pyx> no it should not
10:19:05 <BMeph> pyx: or some kind of _map_ over the Sequence list...
10:19:50 <pyx> foldl, nice idea )
10:20:25 <BMeph> pyx: At least, that's what it looks like you're trying to do in that last line.
10:21:40 <BMeph> byorgey: Duh, I just noticed the pattern at the start of the definition. ;p
10:21:51 <pyx> i try to break the list of [Operator] and create one Operator
10:21:51 <byorgey> BMeph: heh =)
10:22:26 <pyx> like Sequence [Operator]
10:24:28 <BMeph> pyx: So why not jusy say "if er == name" instead? ;)
10:25:35 <pyx> indiferently
10:40:20 <tlaboc> @users
10:40:21 <lambdabot> Maximum users seen in #haskell: 418, currently: 418 (100.0%), active: 15 (3.6%)
10:41:33 <fons> hi all
10:42:05 <fons> I testing my code, and found a bug (a call to undefined which should not have happened)
10:42:33 <fons> to guess where the call is actually made in my code I'm trying to use ghci's debugger
10:43:05 <fons> but typing ":b undefined" results in "cannot set breakpoint on undefined: module GHC.Err is not interpreted
10:43:05 <fons> "
10:43:19 <fons> any hints?
10:43:33 <dcoutts> fons: there's a bit in the user guide on exactly that
10:43:36 <Saizan> there's something like -fbreak-on-exception iirc
10:44:18 <fons> Saizan: tried that, but :back doesn't help that much (or I don't know how to use it properly)
10:45:06 <fons> dcoutts: I've been skimming through i, I'll read it more carefully, sorry
11:09:48 <Cale> In 2006, PC World rated the Zip drive as the 15th worst technology product of all time. However, in 2007, PC World rated the Zip drive as the 23rd best technology product of all time. Thus, we can conclude that PC World must think that there are only 37 technology products.
11:10:47 <moonlite> :))
11:11:02 <mrd> maybe they are using real numbers
11:11:54 <thost> or they just threw away all their Zip disks and forgot the pain that drove them to 2006's judgement ;)
11:27:17 <wy> Is [] really a list?
11:27:31 <mrd> yes
11:27:43 <mrd> it's a constructor for list
11:28:19 <wy> I mean the null list, not the constructor
11:28:42 <notsmack> wy: what's the difference?
11:28:46 * mrd is confused too
11:29:13 <wy> uhhh sorry. It's one of the constructors
11:29:23 <Valodim> why do you ask?
11:29:32 <Valodim> just try it in ghci or \bot
11:30:17 <wy> That's just a weird question ;)
11:30:58 <wy> Like "why is the sun round"...
11:31:53 <desegnis> wy, I think that's somehow because of gravity
11:32:01 <desegnis> Now, your turn.
11:33:03 <wy> because gravity operates according a law related with Euclidean distance
11:33:43 <mrd> ?!
11:33:44 <lambdabot> Maybe you meant: . ? @ v
11:34:05 <mrd> I thought the whole point of general relativity is that space is not Euclidean
11:34:47 <mrd> i even managed to confuse lambdabot
11:35:38 <dons> ?bot
11:35:38 <lambdabot> :)
11:35:40 <dons> ?uptime
11:35:40 <lambdabot> uptime: 17h 8m 2s, longest uptime: 1m 10d 23h 44m 29s
11:35:42 <dons> ?users
11:35:42 <lambdabot> Maximum users seen in #haskell: 421, currently: 415 (98.6%), active: 17 (4.1%)
11:36:37 <trez> :)
11:37:23 <wy> the roundness of the sun isn't related with general relativity
11:39:09 <wy> see? we have lots to talk about the basic questions ;)
11:39:11 <roconnor> the empty list is a list and 0 is a natural number.
11:39:18 <BMeph> wy: Is that one of your axioms of your "Theory of General Non-Relativity"> ;)
11:40:45 <Saul_> Space not being Euclidian doesn't mean that Euclidian distance is ill-defined
11:41:55 <roconnor> there is no metric in GR.
11:42:05 <roconnor> there is only that pesudometric thingy
11:43:42 <roconnor> anyhow there must be some sort of naturalality argument to be made about having empty lists
11:43:46 <Saul_> ok, but explaining why the sun is round is best explained with it
11:44:02 <roconnor> our lists are the initial algebra of some thingy
11:44:12 <roconnor> involving the functio F(X) = 1 + X
11:44:16 <roconnor> functor
11:44:35 <cinimod> @pl \(x1,y1) (x2,y2) -> ((x1,x2),(y1,y2))
11:44:36 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (,)) . flip . (((.) . (,)) .) . (,))
11:44:39 <roconnor> if we only had non-empty lists, the whole thing would be more complicated I expect.
11:47:13 <FunctorSalad> I guess you would need a unary operation to construct singletons
11:51:41 <roconnor> @type ((.) .) . (. (,))
11:51:43 <lambdabot> forall b c a a1 b1. ((b1 -> (a1, b1)) -> b -> c) -> a1 -> (a -> b) -> a -> c
11:52:09 <FunctorSalad> @type uncurry (((fst.fst)***(fst.snd))***((snd.fst)***(snd.snd)))
11:52:10 <lambdabot>     Couldn't match expected type `b -> c'
11:52:10 <lambdabot>            against inferred type `((a, a1), (b1, b2))'
11:52:10 <lambdabot>     In the first argument of `uncurry', namely
11:52:26 <FunctorSalad> @type curry (((fst.fst)***(fst.snd))***((snd.fst)***(snd.snd)))
11:52:27 <lambdabot> forall a b b1 a1 b2 a2 a3 b3 b4 a4 b5 a5. (((a, b), b1), (a2, (a1, b2))) -> (((a3, b3), b4), (a5, (a4, b5))) -> ((a, a1), (b3, b5))
11:52:35 <FunctorSalad> hmm...
11:53:17 <FunctorSalad> @type (((fst.fst)***(fst.snd))***((snd.fst)***(snd.snd)))
11:53:18 <lambdabot> forall a b b1 a1 b2 a2 a3 b3 b4 a4 b5 a5. ((((a, b), b1), (a2, (a1, b2))), (((a3, b3), b4), (a5, (a4, b5)))) -> ((a, a1), (b3, b5))
11:54:10 <FunctorSalad> aha
11:54:26 <FunctorSalad> @type uncurry (((fst.fst)&&&(fst.snd))&&&((snd.fst)&&&(snd.snd)))
11:54:28 <lambdabot>     Couldn't match expected type `b -> c'
11:54:28 <lambdabot>            against inferred type `((a, a1), (b1, b2))'
11:54:28 <lambdabot>     In the first argument of `uncurry', namely
11:54:34 <FunctorSalad> ok I give up ;)
11:54:53 <FunctorSalad> @type curry (((fst.fst)&&&(fst.snd))&&&((snd.fst)&&&(snd.snd)))
11:54:54 <lambdabot> forall a b a1 b1. (a, b) -> (a1, b1) -> ((a, a1), (b, b1))
11:54:59 <FunctorSalad> finally.
11:56:14 <gnuvince> @type (&&&)
11:56:15 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:56:55 <BMeph> FS: That one's going in my "bag-of-tricks" file. I'll likely never use it, though...
11:56:56 <FunctorSalad> (that was @ cinimod)
11:57:51 <byorgey> in this case, I think \x y -> ((fst x, fst y), (snd x, snd y)) is a wee bit more sane... =)
11:57:57 <FunctorSalad> BMeph: maybe lambda should be taught to use these tuplings rather than all the flips ;)
11:58:18 <FunctorSalad> byorgey: yeah you don't win much
11:58:27 <BMeph> FS: One of my side projects.
11:58:30 <FunctorSalad> but OTOH it's pretty readable
11:58:32 <byorgey> FunctorSalad: that would be pretty nifty.  I've no idea what state the @pl code is in, or how easy that would be to add...
12:00:59 <cytzol> is there a way to specify "any instance of a class" in data, or is doing that going about things the wrong way?
12:01:03 <dcoutts> tibbe, dons: interesting article on strings: http://weblogs.mozillazine.org/roc/archives/2008/01/string_theory.html
12:01:04 <lambdabot> Title: Well, I'm Back: String Theory, http://tinyurl.com/yqov4d
12:01:59 <dcoutts> we're fortunate that a functional approach to strings always involves iteration/recursion rather than indexing
12:02:06 <byorgey> cytzol: "any instance of class Foo" is denoted (Foo a) => (type involving a)
12:02:12 <dcoutts> and our iterators are just strings themselves, thanks to tail
12:02:16 <byorgey> cytzol: but do you mean doing that in a data declaration?
12:02:26 <cytzol> byorgey: yes, I do
12:02:33 <byorgey> cytzol: putting class constraints on a data declaration is usually not really what you want
12:03:01 <byorgey> cytzol: it's better to just put the constraint on any functions that manipulate that data structure and need the constraint
12:03:18 <dcoutts> tibbe, dons: hence I claim that making length/index efficient is wasted effort (wasted runtime, memory and programmer effort)
12:03:43 <byorgey> cytzol: for example, you might have data Tree a = blah, treeSize :: Tree a -> Int, but treeMin :: (Ord a) => Tree a -> a
12:04:08 <cytzol> byorgey: do that instead of making Tree depend on Ord somehow?
12:04:22 <dobblego> @msg dons s/correspondance/correspondence ;) http://programming.reddit.com/info/64th1/comments/c02uenu
12:04:23 <lambdabot> Not enough privileges
12:04:26 <byorgey> cytzol: right
12:04:27 <dobblego> bleh
12:04:42 <dobblego> @tell dons s/correspondance/correspondence ;) http://programming.reddit.com/info/64th1/comments/c02uenu
12:04:43 <lambdabot> Consider it noted.
12:04:55 <byorgey> cytzol: even if you put the Ord instance on the declaration of Tree itself, you'll still need the constraints on the Tree functions that need it anyway
12:06:03 <byorgey> cytzol: and there may be some functions on Trees that don't require the Ord instance -- such as treeSize above -- but if you put the Ord constraint on Tree itself you won't be able to write those.
12:07:24 <cytzol> byorgey: oh, ok.
12:11:34 <BMeph> "Make the data smart, and the functions dumb," eh byorgey? :)
12:12:34 <byorgey> BMeph: what's that from?
12:14:01 <BMeph> byorgey: I think it's an ESR quote - I got it second-hand from a blog page called "Objects have not failed". Guy Steele wrote it, I think.
12:14:47 <byorgey> BMeph: ah, I see.
12:15:12 <byorgey> BMeph: out of context I'm not sure what it's supposed to mean, but I'm not sure that I agree =)
12:17:19 <byorgey> hmm, after reading it a bit, maybe I do agree
12:17:29 <wy> :t 1+2
12:17:30 <BMeph> byorgey: Yeah - I have the page up at home, so its not at-hand for me. I'd recommend you give it a glance, it's only a couple pages' worth of text...there you go, lol. :)
12:17:33 <lambdabot> forall t. (Num t) => t
12:18:11 <wy> On my ghci it shows 1+2 :: forall t. (Num t) => t
12:18:18 <byorgey> wy: same thing.
12:18:41 <wy> why doesn't it evaluate it
12:18:46 <byorgey> wy: there is an implicit 'forall' on every free type variable.
12:19:04 <tibbe> dcoutts: interesting, I'll have a look
12:19:05 <byorgey> wy: you probably have -fglasgow-exts turned on, which (among other things) makes it print the 'foralls' explicitly
12:19:30 <wy> byorgey: I mean it gives me the type of 1+2, but not the type of the result
12:19:44 <byorgey> wy: that *is* the type of the result.
12:20:06 <byorgey> wy: you mean, you want it to print '3'?
12:20:21 <wy> yes. why doesn't it print 3?
12:20:33 <byorgey> wy: typechecking and evaluation are two separate stages.
12:20:52 <byorgey> wy: there are some expressions which can easily be typed but would diverge if you tried to evaluate them.
12:21:07 <BMeph> dcoutts_: It gave me a funny idea of possibly encoding long C strings as a function that generates the characters in order.
12:21:09 <byorgey> wy: so in general it doesn't make sense to evaluate an expression when you're just asking for the type.
12:21:25 <Saizan> wy: to get the result omit ':t'
12:21:36 <dcoutts> BMeph: which is of course a lazy [Char] style string
12:21:54 <dcoutts> BMeph: or in a lazy chunked representation like lazy ByteStrings
12:22:29 <BMeph> wy: for example, it's easy to give the type of 'repeat' used on something. Writing it out is fruitless, though. ;)
12:22:39 <byorgey> :t repeat 3
12:22:41 <lambdabot> forall t. (Num t) => [t]
12:22:43 <byorgey> > repeat 3
12:22:45 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
12:23:45 <BMeph> byorgey: Which is the best descriptive definition of "lazy" and "eager" that I could think of.
12:23:49 <resiak> is the ...-ing implemented as an alternative Show [a] instance, or by lazily show-ing the result?
12:23:53 <resiak> i guess the latter.
12:24:17 <byorgey> BMeph: it's a good example.
12:24:40 <byorgey> resiak: actually, neither =)
12:24:44 <BMeph> "Lazy" means "doing as much as you are asked for, without doing anything else.
12:24:47 <resiak> heh
12:24:47 <cinimod> FunctorSalad: I've given up with Arrow as I was ending up with things like (curry ((***) (uncurry (<+>)) (uncurry (<+>)))
12:24:53 <byorgey> resiak: it's just that lambdabot has some wrapper code which cuts off output after a certain length
12:25:09 <resiak> heh
12:25:22 <cinimod> FunctorSalad: it would be hard to understand what it did in a week's time
12:25:52 <kolmodin> can we get space usage from ghc for different data types? or is it difficult to interpret due to lazyness?
12:26:02 <byorgey> resiak: but you could easily imagine it being done with an alternative Show instance.
12:26:13 <resiak> byorgey: in fact, I did! :)
12:26:20 <byorgey> hehe =)
12:27:46 <byorgey> newtype ShowTrunc a = STrunc a ; instance (Show a) => Show (ShowTrunc a) where show (STrunc x) = take 80 (show x)  -- like that, except more fancy =)
12:38:41 <waern> dcoutts: ping
12:41:20 <roconnor> waern: rst
12:41:37 <waern> rst?
12:41:46 <roconnor> tcp reset
12:42:03 <waern> hehe ok :)
12:42:13 <roconnor> just trying to screw with your connection to dcoutts
12:45:13 <eyeris> If import Data.Map and use lookup, I get an ambiguous function error between Data.Map and Prelude. How can I disambiguate this?
12:45:46 <byorgey> eyeris: either import Prelude hiding (lookup), or (probably better), import qualified Data.Map as M, then use M.lookup and so on
12:48:31 <eyeris> hrm
12:48:40 <eyeris> Now I get this err: Not in scope: data constructor `M.Map'
12:50:00 <byorgey> eyeris: well, Data.Map doesn't export any data constructors, so you're probably using M.Map wrong.
12:50:17 <eyeris> Ok
12:50:21 <byorgey> it is a type constructor, not a data constructor
12:53:00 <__pao___> Hi all
12:53:12 <byorgey> hi __pao___
12:53:34 <__pao___> I made a question this afternoon about haskell recursive data caching...
12:53:42 <eyeris> byorgey if I use `type MyMap = Map Int String` (which compiles fine), how do I then construct a MyMap?
12:53:46 <__pao___> I made a simple example
12:53:56 <__pao___> http://pastebin.com/m71267140
12:54:24 <__pao___> the time double if you put two putStrLn statements
12:54:38 <glguy> eyeris: Data.Map.empty
12:54:39 <__pao___> it seems that the info is not cached in between two calls
12:54:43 <byorgey> eyeris: the same way you would construct a Map Int String.  using functions from Data.Map like empty, singleton, fromList, and so on
12:54:44 <roconnor> eyeris: lots of ways
12:54:54 <roconnor> what byorgey said
12:54:55 <eyeris> empty! Thank you!
12:55:16 <glguy> eyeris: type synonyms are just a convenience, they don't change how you use the value
12:56:02 <byorgey> eyeris: and of course, if you've imported Data.Map qualified as M, that should be type MyMap = M.Map Int String
12:57:18 <byorgey> __pao___: no, it isn't.  Haskell doesn't memoize the results of function calls in that way.
12:57:39 <wy> Why isn't type defined to be a set of operations in Haskell?
12:58:28 <__pao___> byorgey: __pao__ is there a way to explicitly request caching? is it reasonable need or is it a smell of an anti-pattern?
12:59:01 <byorgey> __pao___: there isn't a way to request it, but there are ways to do that sort of thing yourself if you want it.
12:59:42 <glguy> __pao___: stick with hpaste.org or other non-terrible pastebins (slow / covered in ads)
12:59:54 <byorgey> __pao___: see http://www.haskell.org/haskellwiki/Memoization
12:59:55 <BMeph> wy: Because that's what classes are for. ;)
12:59:56 <lambdabot> Title: Memoization - HaskellWiki
13:00:05 <__pao___> glguy: glguy ok, thanks for the advice
13:00:22 <desegnis> pao, main = putStrLn s >> putStrLn s where s = show (index n l)
13:00:47 <dons> dcoutts: how many packages on hackage depend on bytestring? :)
13:00:47 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
13:01:38 <__pao___> byorgey: thanks! memoization was the keyword ;-)
13:01:58 <wy> BMeph: but if types are defined to be so, we don't need classes any more
13:04:39 <resiak> What's the standard approach for representing C enums like { a = 1, b = 2, c = 4, d = 8, ... }?  An Enum instance can't be written since succ b is undefined.
13:04:55 <dons> resiak: use #enum in hsc2hs?
13:06:38 <resiak> dons: that doesn't produce data Foo = A | B | C..., though
13:07:12 <resiak> Oh, but I guess I do newtype Foo = MkFoo Int; use #enum to define the constant; then don't export MkFoo
13:09:22 <Saizan> resiak: succ  is not supposed to be total, typical enums are finite
13:09:48 <FunctorSalad> resiak: subset of {a,b,c,d,...} ;)
13:10:29 <FunctorSalad> (actually I don't know whether sets are parametrised with a base set like that)
13:10:42 <Saizan> end {#enum in c2hs declares Foo = A | B | C .. for you
13:11:17 <resiak> hmm, i must be misreading the docs!
13:11:48 <Saizan> c2hs /= hsc2hs
13:12:12 <resiak> heh, so i'm misreading the IRC channel :)
13:12:43 <thoughtpolice> resiak: hey. pulled your patches from the new hfuse repo, seems to build fine on ghc 6.8. however when running the HelloFS example (i.e. ./HelloFS /tmp/ex) and after running an ls, apparently the function for directory listings isn't implemented
13:12:56 <thoughtpolice> or is that just something you're working on?
13:14:00 <resiak> yeah, the directory stuff doesn't work.  i'm working on it, bit by bit :)
13:14:12 <resiak> thanks for trying it with 6.8 :)
13:14:13 <Botje> resiak: psst, the next one is a zero.
13:14:28 <resiak> Botje: ?
13:14:32 <Botje> "bit by bit"
13:14:42 <Botje> i'll get me coat.
13:14:47 * resiak covers Botje in bees.
13:14:53 <thoughtpolice> resiak: built completely fine, no errors or anything. i think for the most part you'll be fine in that respect, although i'll keep periodically pulling/building to test it and give you any feedback. :)
13:25:17 <bringert__> When do you want the next Hackathon? Register your preferences on http://www.haskell.org/haskellwiki/Hac_2008/Dates
13:25:21 <lambdabot> Title: Hac 2008/Dates - HaskellWiki
13:25:41 <dons> bringert__: do you have the hackathon darcs repo url?
13:25:49 <tehgeekmeister> where does ghc search when attempting to import a module?  i've defined a module and now need to use it in another file, in another directory
13:25:50 <dons> it has all the past registration and other info
13:25:59 <bringert__> dons: nope
13:26:30 <bringert> dons: could you e-mail it to me?
13:26:35 <dons> will do.
13:29:43 <waern> dcoutts: I've sent a patch to cabal-devel
13:30:09 <waern> dcoutts: I didn't do anything to pkg-config parsing, since I wasn't sure how you wanted that done
13:31:00 <thoughtpolice> tehgeekmeister: it searches in a directory heirarchy fashion, i.e. if you have something like Language.XXX.Compiler, it'll look under Language/XXX/ for the Compiler module.
13:31:12 <ndm> having just strayed into another IRC channel to ask a question, i think i've been completely spoiled by this one...
13:31:29 <Nafai> ndm: No kidding!
13:31:37 <tehgeekmeister> ndm: i know i have.
13:32:40 <ndm> has anyone spotted that Test.QuickCheck lacks any haddock comments?
13:32:47 <ndm> that seems like something someone should fix up
13:34:42 <bringert> ndm: QuickCheck 2 fixes that, afair
13:34:53 <DRMacIver> Hm
13:35:04 <ndm> bringert: should I (as a user) be on QuickCheck 1 or QuickCheck 2 ?
13:35:09 <DRMacIver> I wonder why the brainfuck interpreter in literate haskell post that has just cropped up doesn't use a zipper.
13:35:30 <bringert> ndm: QuickCheck 2 is better, but not released yet
13:35:42 <ndm> bringert: ok, so stick with 1 for the moment
13:35:48 <DRMacIver> Given that it's currently operating by indexing into a linked list.
13:35:52 <ndm> sounds like Hoogle 4 :)
13:35:54 <bringert> yeah, probably the safest bet
13:36:54 <DRMacIver> Ah, it got improved later. :)
13:40:08 <kolmodin> bringert: I added myself to the organisers, and to the date list
13:43:28 <bringert> kolmodin: great!
13:44:13 <bringert> kolmodin: s/has/have/ :-)
13:45:31 <kolmodin> ah crap :)
13:46:04 <kolmodin> I've fried my brain today. worked (C#!), and then bicycled around gbg to look at three apartments
13:46:21 * shachaf actually does sometimes pronounce "::" as "colon colon"...
13:46:50 <wolverian> all these colons on my screen, argh
13:46:50 <shachaf> But then, a lot of my pronunciations are odd.
13:46:58 <Zao> SPJ's talk about xmonad made me pronounce mkFoo as "muck Foo"
13:47:00 <kolmodin> shachaf: that has a nice touch to it :D
13:47:13 <wolverian> Zao, yeah, that was weird.
13:47:38 <bringert> kolmodin: C#? new job?
13:48:16 <kolmodin> bringert: same old job
13:49:35 <kolmodin> I could move from java, luckely
13:49:55 <kolmodin> C# 3.5 has a few FP like features
13:50:20 <kolmodin> so it's not compleeeetely crap
13:51:54 <ndm> kolmodin: bolted on in a slightly haphazard way, from what i saw - there are quite a few corner cases
13:53:18 <kolmodin> ndm: indeed there are. I hit a few already the first day and was quite disappointed
13:54:22 <kolmodin> and most new things only work in local scope (inside functions), nothing can be made into public API
13:55:24 <kolmodin> like the tupelish things they've introduced, anonymous classes
13:56:00 <bringert> kolmodin: couldn't you use F#?
13:56:31 <kolmodin> bringert: it all comes down to who is going to maintain it
13:56:53 <kolmodin> bringert: and currently we don't have anyone that's even had a serious look at FP
13:58:19 <bringert> kolmodin: "The third worry of the pointy-haired boss, the difficulty of hiring programmers, I think is a red herring. How many hackers do you need to hire, after all? Surely by now we all know that software is best developed by teams of less than ten people. And you shouldn't have trouble hiring hackers on that scale for any language anyone has ever heard of. If you can't find ten Lisp hackers, then your company is probably based in the w
13:58:21 <kolmodin> but I'm convincing them one by one :D
13:58:28 <bringert> kolmodin: from http://www.paulgraham.com/icad.html
13:58:29 <lambdabot> Title: Revenge of the Nerds
13:58:54 <gwern> is it true that it's no longer necessary to add -02 to one's .cabals because cabal turns on optimizations by default?
13:59:06 <bringert> I think that once Microsoft start marketing F# seriously, there will be a lot of hype around FP
13:59:22 <kolmodin> bringert: thanks!
13:59:37 <kolmodin> bringert: indeed, I think so too. people listen to them
13:59:53 <shachaf> gwern: Try compiling with -v to test it, I guess?
14:00:05 <bringert> and they will come up with lots of exaggerated marketing fluff to make FP sound even better than it is
14:00:43 <DRMacIver> bringert: That will be nice. :)
14:02:45 <kolmodin> haha :)
14:02:50 <kolmodin> like they do about OO?
14:02:55 <kolmodin> ;)
14:03:59 <dons> this is quite relevant to haskell. http://www.stsc.hill.af.mil/CrossTalk/2008/01/0801DewarSchonberg.html
14:04:00 <lambdabot> Title: STSC CrossTalk - Computer Science Education: Where Are the Software Engineers of ..., http://tinyurl.com/25atps
14:04:05 <dibblego> ?kind []
14:04:07 <lambdabot> * -> *
14:04:13 <dons> "It is our view that Computer Science (CS) education is neglecting basic skills, in particular in the areas of programming and formal methods."
14:04:39 <dons> "Students need to be exposed to the tools to construct large-scale reliable programs, as we discussed at the start of this article. Topics of relevance are studying formal specification methods and formal proof methodologies, as well as gaining an understanding of how high-reliability code is certified in the real world"
14:06:05 <kolmodin> right. I think far to many in my old CS class couldn't write a linked list properly
14:06:14 <dons> dibblego: reminds me of stuff you complain about
14:06:20 <dons> kolmodin: mm
14:06:24 <ndm> bringert: citing Paul Graham is never a good idea, since he's opionionated and wrong as often as he is right
14:06:32 <dibblego> dons, what do I complain about?
14:06:46 <kolmodin> ndm: so you just have to pick the pieces you like :)
14:06:54 <bringert> ndm: well, that depends on whether the person you are citing him too knows that :-)
14:06:55 <dons> dibblego: the dumbing down of undergrads caused by java :)
14:07:16 <dibblego> dons, ah right; yes, it's a sad phenomenon
14:07:35 <bringert> good night
14:07:38 <ndm> but the article suggests that if you taught Ada then you'd have less problems
14:07:49 <ndm> i know for a fact that Ada does not help undergrads learn to program
14:07:55 <dons> yeah, there are other approaches to high assurance and reliability
14:08:04 <ndm> York is going to convert from Ada -> Java next year, and it is definately a good idea
14:08:07 <dons> its also funny how they cite lisp as important for teaching referential transparency :)
14:08:23 <dons> ndm, only 10 years after everyone else, eh? :)
14:08:25 <kolmodin> that's a nice article, it's on my TOREAD list
14:08:41 <dons> unsw switched to java in 98, and ditched by 04, iirc
14:09:09 <dons> but they also used haskell for a decade to teach the newbies,so maybe its a funny place
14:09:15 <pejo> dons, Paul Graham cites lisp as important all the time. Nothing new there.
14:09:29 <kolmodin> dons: so what have they used since 04?
14:09:32 <dons> pejo: oh, this isn't PG
14:09:50 <pejo> Oh, sorry. Mixing up debates.
14:10:01 <ndm> dons: York teaches Scheme as the first language, Java will be the second - so we aren't a java school by that metric
14:10:01 <dons> kolmodin: haskell, C, java for some data structure stuff. hmm, not sure what they're doing these days. the haskell has been pushed into the grad courses
14:10:22 <vincenz> kthxbye
14:11:16 <vincenz> I think Scheme is a good intro languag, you can explore a lot of ideas without getting stuck in syntax
14:11:25 <vincenz> Haskell is a nice follow up :)
14:11:38 <vincenz> but it's easier to explore fp vs oop in scheme
14:11:41 <vincenz> with a set of macros
14:11:44 <vincenz> or a lambda and a cse
14:12:03 <vincenz> s/cse/case
14:12:41 <kolmodin> we start with (at least 5 years ago) with haskell for 8 weeks, then java 8 weeks. than you can more or less pick whatever you'd like in the courses, if it's not anything special
14:12:58 <kolmodin> and by we I mean CS at Chalmers
14:13:12 <waern> kolmodin: now they even have Haskell in the data structures course
14:13:22 <dons> awesome
14:13:41 <pejo> waern, depends on who is teaching it, I presume?
14:13:49 <dons> purely functional data's in C# now, and generics in Java, so they're going to need the foundations from somewhere
14:14:28 <waern> pejo: I don't know, I just heard that they used Haskell and Java in the data structures course this year. I suppose they look at data structures from both an imperative and functional point of view
14:14:33 <ndm> they say in that article that PRAXIS can't recruit enough graduates - which wasn't true 4 years ago, as I applied and they said they had no vacancies
14:15:02 <kolmodin> waern: that's nice!
14:15:06 <ndm> they also say people should study floating point, while i think floating point should be dumped entirely
14:15:41 <tlaboc> you mean like IEEE floating-point specifications?
14:16:07 <wy> I'm thinking about the question, is there really a need for dependent types?
14:16:18 <tlaboc> is that actually complex/important enough to need "studied"?
14:17:00 <kolmodin> good night everyone!
14:17:52 <wy> ndm: Then what do you use?
14:18:10 <dons> night kolmodin
14:18:44 <byorgey> tlaboc: well, it's certainly *complex* enough...
14:18:55 <wy> waern: It will be interesting how imperitive data structures can be interpreted by functional ones
14:18:56 <pejo> tlaboc, fp is a can of worms.
14:19:35 <wy> byorgey: because you lose precesions?
14:19:38 <tlaboc> hahaha, thats true i suppose, but ive never heard anyone speak of "studying" it, like you would study a language or something
14:20:11 <wy> tlaboc: We studied it for a semester in numerical analysis ;-) Lots about roundoff errors...
14:20:25 <wy> matrix condition numbers...
14:20:44 <tlaboc> wy: details like that are disgusting :)
14:21:04 <MyCatVerbs> @hoogle Handle -> IO [Word8]
14:21:05 <lambdabot> No matches, try a more general search
14:21:24 <wy> tlaboc: but you have to face it because we never have accurate real numbers
14:21:41 <tlaboc> wy: fixed point!
14:22:07 <tlaboc> wy: also, casual disregard for errors
14:22:48 <wy> Where can I discuss about dependent types?
14:23:24 <tlaboc> what do you mean by dependent types?
14:23:46 <wy> tlaboc: I mean by what it normally means... I don't know!
14:24:03 <tlaboc> wy: sorry, its just that i'm not familiar with the term
14:24:07 <wy> It probably means types that depend on values
14:24:21 <tlaboc> wy: im looking it up :) http://en.wikipedia.org/wiki/Dependent_types
14:24:27 <pejo> wy, there's people here who use Coq, Epigram, etc.
14:24:37 <pejo> wy, here as in #Haskell.
14:24:44 <BMeph> See y'all in an hour - time to leave work. :)
14:28:53 <wy> I tried to remove classes from the language and unify classes and types, but there is something seemingly wrong with my theory
14:30:22 <dcoutts> waern: thanks
14:31:12 <dcoutts> dons: not sure how many, we should make those kind of stats available on the hackage website
14:31:35 <dcoutts> @seen waern
14:31:35 <lambdabot> waern is in #ghc and #haskell. I last heard waern speak 17m 6s ago.
14:31:39 <dcoutts> @seen dons
14:31:39 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 13m 29s ago.
14:32:20 <dcoutts> dons: people have suggested (and I think it's a good idea) using stats like that for a "hackage rank" to get some idea of what the important/popular packages are
14:32:53 <dcoutts> a combination of download/build stats and number of packages depending directly (or indirectly) on a package
14:32:54 <dons> yeah, i'm going to write a script to compute the most popular core and non-core libraries
14:33:20 <dcoutts> dons: if you can integrate in the hackage-scripts repo that'd be even more useful
14:33:25 <waern> dcoutts: pong
14:33:40 <dons> currently i think Data.Binary is the most popular non-extra lib library (with 16 users), while the top 10 looks like,
14:33:43 <dons> array:      197
14:33:46 <dons> old-locale: 156
14:33:46 <dcoutts> waern: I've not looked at the patch yes
14:33:48 <dons> old-time:   150
14:33:51 <dons> mtl:        144
14:33:53 <dons> filepath:   134
14:33:56 <dons> directory:  134
14:33:58 <dons> unix:       121
14:34:01 <dons> containers: 120
14:34:03 <dons> random:     108
14:34:06 <dons> process:    105
14:34:08 <dons> haskell98:   91
14:34:11 <dons> bytestring:  88
14:34:13 <dons> parsec:      88
14:34:16 <dons> network:     58
14:34:18 <dons> pretty:      45
14:34:21 <dons> regex-base:  38
14:34:23 <dons> QuickCheck:  30
14:34:24 <dons> utf8-string is also pretty popular
14:34:27 <dons> and some core libs aren't used at all, e.g. html has 1 user..
14:34:31 <Igloo> dons: Where are these numbers from?
14:34:41 <dons> Igloo: the hackage required-by search field.
14:34:48 <dons> i'll script it up to extract the full list
14:35:07 <Igloo> What, you mean we have 197 packages that use array? Does that include multiple versions of each package?
14:35:19 <dons> i believe so.
14:35:26 <dons> so if one library has 20 versions, that counts for 20 hits
14:35:37 <dcoutts> dons: so the question is, what'd be the most useful way to present that kind of information...
14:35:41 <dons> i've only toyed with the results. i should be able to produce more accurate info
14:35:50 <Igloo> Ah, OK. That's more plausible then
14:35:53 <dons> we can also combinme them with the webserver logs
14:36:00 <dons> which i'm sure we can get access to
14:36:17 <dcoutts> dons: eg, looking at a single package it might be interesting to see the reverse deps and the "hackage rank" but a single page listing by rank would also be very useful
14:36:51 <dcoutts> dons: yes, we should be able to get web server logs, though it might be a little ad-hoc
14:37:09 <dcoutts> dons: there's a hackage bug open on this issue iirc
14:37:23 <dons> yeah, some things like 'xmonad' have only a couple of deps, but i bet a lot of hits on the webserver
14:37:36 <dons> then core things like mtl, lots of deps, but few hits, since they're packaged
14:37:51 <dcoutts> dons: right, we want deps and download and then some combined rank
14:38:05 <dons> yep
14:38:24 <dcoutts> dons: we want people to be able to compare DB libs or xml parsing libs for example
14:38:37 <dcoutts> to see if one is "standard" and another experimental
14:38:46 <dons> haxml is more popular than libxml, fwiw
14:38:51 <dons> but none are widely used
14:39:35 <dcoutts> http://hackage.haskell.org/trac/hackage/ticket/183
14:39:36 <lambdabot> Title: #183 (Provide &#34;library-rank&#34; in hackage) - Hackage - Trac
14:39:36 <dons> mm
14:39:37 <dons> ok, i can probably knock off that ticket
14:39:41 <dons> i've done a bit of hackage scraping recently
14:39:47 <dcoutts> great
14:39:51 <dcoutts> it needs some love
14:40:20 <dcoutts> dons: I know very little about the design or structure of the hackage-scripts code
14:40:48 <dcoutts> it's going to get more and more important as we want to add more and more features
14:41:06 <dcoutts> dons: so feel free to refactor and improve the organisation / design etc
14:41:49 <dons> yep
14:41:52 <dcoutts> dons: oh, and the other similar feature request that covers is:
14:41:53 <dcoutts> http://hackage.haskell.org/trac/hackage/ticket/162
14:41:54 <lambdabot> Title: #162 (show how often a package has been viewed or downloaded) - Hackage - Trac
14:42:01 <dons> ah ha
14:43:03 <dcoutts> dons: and once we add support for repo links in .cabal files we'll want to implement #58 or something simpler like just providing links and darcs-graph style stats
14:43:42 <doserj> the upload date would already be helpful
14:43:51 <dcoutts> yes, that too
14:44:10 <dons> right. then we can duplicate ohloh, http://www.ohloh.net/projects/6869/analyses/latest/contributors
14:44:11 <lambdabot> Title: xmonad Contributors - Ohloh
14:44:21 <dcoutts> dons: it's related to the download and dep rank since another indication people would like is project activity which we can measure by uploads and also by darcs changes
14:44:32 <dons> right.
14:45:11 <dcoutts> dons: I'd love to see a darcs-graph annotated with lines marked with release number
14:45:41 <dcoutts> dons: there's probably enough info to fill a whole page for each package
14:46:15 <dcoutts> dons: eventually we'll want to link this into hoogle to use to help order package search results
14:46:53 <dcoutts> dons: conal has a rather persuasive argument (imho) that the right interface to hackage is a google style search
14:47:04 <dons> i'd like to generate something like the ohloh stats from darcs-graph. so pie graphs of contributors, releases, etc.
14:47:17 <dcoutts> that'd be great
14:47:22 <dons> comment/code ratio. hpc coverage data ...
14:47:31 <dcoutts> there's loads of stuff yes
14:48:04 <dcoutts> probably easiest to develop it as a second page for each project, linked from the primary page
14:48:13 <dons> we didn't have hackage this time last year
14:48:29 <dons> so in the next 12 months we should be able to do a few things
14:48:46 <dcoutts> dons: you can see why I worry slightly about the design/structure of the hackage server
14:48:57 <dcoutts> it could get complex, so needs to be designed carefully
14:49:08 <dcoutts> eg consider separating aspects
14:49:37 <dcoutts> like the package repository/archive bit should be possible to deploy on it's own without needing the upload or web UI views
14:49:58 <dcoutts> lots of these stats etc would be useful to have in machine and human readable formats etc
14:50:11 <dcoutts> in otherwords it's a whole complex web app
14:50:24 <dons> yeah
14:51:09 <dcoutts> dons: I was idly wondering if HApps might be a good platform for it
14:52:02 <dcoutts> dons: we'll also want email support some day, eg to send reports to maintainers
14:52:06 <gwern> hm. so it would appear cabal does turn on -O2 by default
14:52:24 <dcoutts> gwern: no, only -O, use configure --disable-optimization
14:52:41 <dons> well, fastcgi might be ok too
14:52:50 <dons> fastcgi and a bit of javascript
14:53:06 <gwern> dcoutts: are you sure? I did a configure and build with -02 in the cabal, then edited -o2 out of the cabal, reconfigured and rebuilt - and the build didn't compile anything
14:53:25 <dcoutts> dons: there is some serialisation necessary for managing the archive and index correctly
14:53:58 <dcoutts> gwern: it does not track changes to compile flags
14:54:40 <dcoutts> gwern: by default cabal gets ghc to use -O and as I said, you can configure it to use no optimisation
14:54:46 <gwern> oh.
14:55:00 <dcoutts> you'd have to clean though if you'd already built with -O and wanted to rebuild with -O0
14:55:32 <dcoutts> dons: fastcgi would be basically the same as what we have now with cgi, it's just a performance thing
14:55:38 <dons> yep.
14:55:49 <dcoutts> dons: it's mutable state management that's the tricky bit
14:55:57 <dons> yeah.
14:56:08 <dcoutts> the package archive and any cached data, like logs, stats, etc etc
14:56:16 <Saizan> is there any easy way to query ghc or ghc-pkg about which package a module is in?
14:56:36 <dcoutts> dons: which is why HApps is potentially attractive since it has some approaches to those issues
14:56:54 <dons> that's true. it would make the state handling simpler
14:57:00 <dcoutts> Saizan: not at the moment, no. I think it might appear in a later ghc
14:57:35 <dcoutts> dons: otherwise I'm not sure how to handle concurrent uploads, or page views that come just as the index is being updated or whatever
14:58:01 <prb> dcoutts: You can disintermediate the state from the client using, e.g., a Chan.
14:58:29 <prb> dcoutts: Single-thread the updates, fork the IO, etc.
14:59:17 <dibblego> @ in defense of scala
14:59:20 <dibblego> @go in defense of scala
14:59:25 <lambdabot> http://rickyclarkson.blogspot.com/2008/01/in-defence-of-0l-in-scala.html
14:59:25 <lambdabot> Title: Ricky's technical blog: In Defence of (0/:l)(_+_) in Scala
14:59:34 <dcoutts> prb: doing that from within a cgi script is a bit hard, it's ok if you have a long running server process like HApps
15:00:11 <prb> dcoutts: Right; that's the benefit of FastCGI.  Properly configured, you can have a single server process that stays alive.
15:00:25 <dcoutts> Oh, I didn't know that
15:01:35 <dcoutts> dons: there's certainly an advantage to being able to use any old http web server for the package archive, but then the order of file actions is important to get a consistent view
15:02:19 <dcoutts> dons: probably so long as updating the index is atomic it's all ok, and that's possible using the rename trick
15:17:40 <matthew-_> any experience with getting ghc to make static executables?
15:17:56 <matthew-_> I'm using -static -optc-static -optl-static and I get link errors with pthreads
15:18:08 <matthew-_> (.text+0x124): undefined reference to `pthread_once'
15:18:13 <matthew-_> /usr/lib/gcc/x86_64-linux-gnu/4.2.3/../../../../lib/librt.a(timer_create.o): In function `timer_create':
15:18:16 <matthew-_> that kinda thing
15:18:32 <Igloo> Does -lpthread fix it?
15:19:50 <dons> that looks like a bsd-related unix pthreads failure? :)
15:20:16 <matthew-_> debian linux
15:20:21 <lambdabot> no you didn't!
15:21:04 <matthew-_> Dynamic linker error message was:
15:21:04 <matthew-_>    /usr/lib/libpthread.so: invalid ELF header
15:21:10 <matthew-_> (with -lpthread)
15:21:22 <matthew-_> but that shot out as soon as ghc hit the bit of code using TH
15:21:48 <matthew-_> Loading package base ... linking ... done.
15:21:49 <matthew-_> Loading object (dynamic) pthread ... failed.
15:21:52 <matthew-_> is how it went
15:22:03 <matthew-_> (sorry for the Îflood)
15:22:11 <matthew-_> Ãµflood, rather
15:22:15 <matthew-_> oh sod that...
15:22:35 <EvilTerran> Iflood? oflood?
15:22:52 <frobar> iFlood.. must be some apple thing
15:23:02 <matthew-_> Ï„flood
15:23:08 <Saizan> a bathtub?
15:23:08 <matthew-_> no, it was meant to be mu
15:23:14 <matthew-_> I'll be quite now...
15:23:26 <Saizan> quiet? :D
15:24:10 <jfredett> in fst $ (f *** g)  i want to make g evaluate, even though I don't want to look at it. (for instance, say I want to have gen_graph = fst $ ("Printed Graph Output" *** generate_graph) graphdata
15:24:26 <jfredett> generate_graph won't get evaluated as is, so I want to make that application strict
15:24:31 <jfredett> but I'm not sure how.
15:24:50 <EvilTerran> ...why do you want to evaluate it?
15:25:00 <jfredett> it evaluates to IO (), with side effects
15:25:13 <jfredett> it generates a graphViz image
15:25:14 <jfredett> :)
15:25:40 <jfredett> I've been experimenting with interesting show functions, :)
15:25:57 <EvilTerran> what type is f?
15:26:25 <jfredett> f is a -> String, g is a -> IO (), basicly
15:27:05 <matthew-_> no, even capturing the ld command and adding -lpthread to it directly doesn't help
15:27:19 <dcoutts> the order can be important
15:27:25 <matthew-_> I'm still left with /usr/lib/gcc/x86_64-linux-gnu/4.2.3/../../../../lib/librt.a(timer_routines.o): In function `__start_helper_thread': (.text+0xd4): undefined reference to `pthread_atfork'
15:27:40 <matthew-_> yeah, it makes no difference if I add it after the -static
15:27:53 <jfredett> EvilTerran: basicly, I'm trying to make the Show function do double duty, by printing out a text version of the graph, for immediate viewing, and a graphviz version, for use later
15:27:53 <dcoutts> matthew-_: so try putting it at the beginning and at the end of the list of ld -l flags
15:27:55 <matthew-_> and if I add it before, it reduces the number of errors, but doesn't eliminate them
15:28:02 <trontonic> Are there any good programs with gui that are written in Haskell?
15:28:07 <dcoutts> matthew-_: it's the order relative to other -l flags that's important
15:28:15 <jfredett> i think that I should just need to use strict apply, but I was wondering if there was a better way
15:28:29 <jfredett> $! or some such, as I recall
15:29:08 <matthew-_> dcoutts: woot!
15:29:42 <matthew-_> the only problem is that the resulting file doesn't exist
15:30:17 <matthew-_> file says it's dynamically linked, but running ldd on it says file not found!
15:30:23 <EvilTerran> jfredett, does "fst $ (f *** g)" have an IO type overall?
15:30:37 <idnar> :t fst $ (?f *** ?g)
15:30:39 <lambdabot>     No instance for (Arrow (,))
15:30:39 <jfredett> no, it would have a String type,
15:30:39 <lambdabot>       arising from use of `***' at <interactive>:1:7-15
15:30:39 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
15:30:51 <matthew-_> I do have this warning though, left from ld: (.text+0xe4): warning: Using 'gethostbyname' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
15:30:57 <Saizan> jfredett: so you want unsafePerformIO?
15:31:09 <EvilTerran> Saizan, that i doubt
15:31:14 <jfredett> Saizan: do I? I'm not sure.
15:31:19 <EvilTerran> jfredett, this is somewhat an abuse of Show
15:31:25 <dcoutts> matthew-_: the .so file is not on the dynamic lib search path
15:31:26 <jfredett> EvilTerran: thats the point
15:31:26 <jfredett> :)
15:31:39 <EvilTerran> you're not allowed side-effects in code with no IO type...
15:32:06 <jfredett> thats the rule, yes, but I want to see if I can get around it, :)
15:32:38 <Saizan> well, to get around it you've to give up proper sequencing of effects via unsafePerformIO
15:32:53 <jfredett> ok
15:33:15 <Saizan> but why desing your app like that?
15:33:22 <jfredett> Saizan: because I can
15:33:24 <jfredett> its just a hack
15:33:26 <jfredett> :)
15:33:38 <Saizan> heretic!
15:33:46 <jfredett> Saizan: I prefer visionary
15:33:46 <jfredett> :)
15:33:54 <Saizan> you'll get in trouble.
15:34:04 <jfredett> with whom? the haskell pope?
15:34:10 <matthew-_> dcoutts: ok, maybe I'm going about this the wrong way. All I want is to generate a binary that does not depend on libgmp as on the target machine, that's not installed.
15:34:12 <EvilTerran> jfredett, just use IO!
15:34:25 <jfredett> is SPJ going to come in his SPJ-mobile and smack me with his Haskell-pope hat?
15:34:29 <matthew-_> dcoutts: is there a way of telling ld to just statically link against certain libraries?
15:34:36 <EvilTerran> jfredett, yes
15:34:40 <jfredett> because that would be seriously cool
15:34:51 <Saizan> jfredett: no, with "oh, why it didn't print it? why it did print it NOW? etc.."
15:34:56 <dcoutts> matthew-_: there probably is, but I'm not sure how, check the ld man page and/or google
15:35:01 <EvilTerran> actually, he's going to drive up in his IO-mobile, pull you in, and give you a beating that way
15:35:19 <EvilTerran> and then you'll be stuck there forever, 'cos you can't escape IO
15:35:27 <jfredett> Saizan: it does print it, it just does other stuff first, I think I can dodge the IO bit w/ arrows
15:35:28 <ddarius> By "you'll get in trouble" Saizan meant "you'll regret it"
15:35:28 <jfredett> :)
15:35:42 <byorgey> @smack jfredett with a Haskell-pope hat
15:35:42 <lambdabot> Unknown command, try @list
15:35:48 <jfredett> ddarius: why would I regret it, if it works, its a cool hack
15:35:53 <byorgey> @slap jfredett with a Haskell-pope hat
15:35:54 * lambdabot hits jfredett with a Haskell-pope hat with an assortment of kitchen utensils
15:35:56 <jfredett> if it doesn't, it was a cool Idea
15:36:10 <byorgey> wow, nice hat! =D
15:36:12 <jfredett> lol
15:37:45 <matthew-_> agh, ps isn't reporting the whole command line...
15:38:59 <kmcallister> ps axww
15:40:28 <matthew-_> agh, who decided a 4kB limit on command line length was a good idea?!
15:41:28 <EvilTerran> ...
15:41:34 <matthew-_> hee hee hee -pgml echo
15:42:12 <matthew-_> kmcallister: no, I don't think the kernel stores more than 4kb - certainly ps axww doesn't give more than 4kB of cammand line for me
15:42:24 <kmcallister> ah
15:42:42 <vincenz> 4kb commandline ?!?
15:43:13 <kmcallister> yeah, i run into this issue when manipulating large dirs of video frames, with xargs or similar
15:43:57 <vincenz> o.O
15:44:38 * byorgey boggles
15:44:45 <koala_man> my max command line length is 128kb
15:45:07 <dcoutts> matthew-_: different kernels have different limits, some are configurable. eg most linuxes allow 128k and Windows allows 32k
15:45:09 <matthew-_> yeah, the average ghc call to ld
15:45:10 <MarcWeber> On the cabal-devel mailinglist there is a therad about a -framework flag when linking.. I've never seen it. Do you know where I can look it up ? Does it belong to ld or gcc ?
15:45:25 <dcoutts> MarcWeber: gcc (possible ld too)
15:45:30 <dcoutts> MarcWeber: but only on OS X
15:45:31 <matthew-_> it's in ld and it's for macs
15:46:01 <matthew-_> dcoutts: ahh, interesting. is it a syslimit?
15:46:15 <matthew-_> (in linux)
15:46:45 <dcoutts> matthew-_: dunno actually, I know there was recently a patch to lift the limit and (shock horror) dynamically allocate
15:47:10 <matthew-_> gosh, that can't have gone down well. Think of the performance...
15:48:15 <shachaf> xmonad passes state on the command line on restart.
15:48:31 <shachaf> That's always made me slightly nervous, though it seems to work so far.
15:49:18 <Saizan> it's not so critical :)
15:49:20 <dcoutts> I guess if it's ever a problem it can pipe it over
15:49:41 <MarcWeber> dcoutts: Ah . Thanks. Don't have OSX. That's why I haven't found it.
15:49:51 <dcoutts> MarcWeber: aye :-)
15:50:23 <dcoutts> MarcWeber: linux tends seems to have standardised on pkg-config for a similar purpose
16:12:28 <faxathisia> hello everyone
16:13:55 <ndm> hi faxathisia
16:18:16 <ptolomy> Yowza. I just implemented cooperative concurrency using callcc for ruby, and had it run the recursive algorithm for fibonacci as a long-running test.. within a few seconds, well over a 1gb of ram. I suspect that MonadCont will be a wee bit more performant.
16:19:21 <gwydion> (((.) . (.)) a b c ) is the same as ((.) ( (.) a b ) c ) ?
16:19:24 <gwydion> is that right?
16:19:28 <gwydion> can anyone tell?
16:19:33 <faxathisia> :t (\ a b c -> (((.) . (.)) a b c ))
16:19:35 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:19:41 <faxathisia> :t (\ a b c -> ((.) ( (.) a b ) c ))
16:19:42 <lambdabot> forall b c b1 a. (b -> c) -> (b1 -> b) -> (a -> b1) -> a -> c
16:19:49 <faxathisia> I think they are not the same
16:20:14 <sjanssen> ptolomy: I dunno if Haskell will do that much better -- the memory complexity is exponential if you're forking a thread for each recursive call
16:20:48 <gwydion> faxathisia: wau, that was quick
16:20:48 <gwydion> :-)
16:21:00 <faxathisia> you got :t in ghci too btw, if you use that
16:21:02 <ptolomy> sjanssen: Oh, I'm not. I'm just calling 'pass' ("yield to another coroutine if any others are running") for each call.
16:21:23 <balodja> :t \a c -> ((.) ( (.) a) c )
16:21:23 <lambdabot> forall b c a a1. (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
16:21:29 <balodja> :t (.) . (.)
16:21:29 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:21:48 <balodja> these are the same, i think
16:22:28 <ptolomy> but I suppose I have to copy the stack every time control is passed, and if it isn't copied cleverly it would cause problems.
16:24:40 <gwydion> balodja: thanks, i see the point now
16:25:48 <dbueno> @paste
16:25:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:26:27 <faxathisia> oh I asked this before, but.. Is there any haskell code which does some program transformation on an AST which is particularly clear/well written/simple.. anything like that, I might be able to learn some tricks from?
16:29:15 <faxathisia> yeah I get the impression that transforming ASTs in haskell is bound to be grimey :S
16:29:48 <faxathisia> anyone else has observed this ?
16:30:54 <Saizan> well, it seems that you usually want some form of generics
16:30:58 <kmcallister> grimey how?
16:31:05 <kmcallister> i've written a few compilers in haskell and it's always nice
16:31:19 <Saizan> like in SYB, or Uniplate, uniplate has been written by ndm to write supero
16:31:19 <faxathisia> kmcallister: are they online?
16:31:42 <faxathisia> ohh I didn't know about that
16:31:43 <ndm> Uniplate rocks for compilers
16:31:46 <Philippa> faxathisia: it's not ideal, but it beats the crap out of doing it in java
16:31:46 <hpaste>  dbueno pasted "unsafeFreeze error" at http://hpaste.org/4872
16:31:57 <kmcallister> they're not online
16:32:11 <kmcallister> i haven't used generics and it's still pretty nice
16:32:29 <dbueno> If anyone has a moment, I'd appreciate some help on dealing with MArray's and IArrays.
16:32:32 <faxathisia> why not put it up somewhere kmcallister ?
16:32:39 <thoughtpolice> is there any easy way to remove escape sequences from strings? i mean, aside from just filter and using Data.Char functions
16:33:03 <thoughtpolice> not really a problem if there isn't but i'm just wondering
16:33:04 <kmcallister> because they're not useful or production-ready
16:33:12 <kmcallister> i wrote them for various undergrad classes
16:33:15 <Saizan> dbueno: well, ask :)
16:33:23 <kmcallister> i'm not opposed to hosting though
16:33:23 <sarehu> thoughpolice: what kind of escape sequences?
16:33:24 <faxathisia> kmcallister: aw :(
16:33:31 <dbueno> Saizan: To start with, I pasted a compile error I don't understand how to remove.
16:33:50 <sarehu> thoughtpolice: and how efficiently?
16:33:54 <kmcallister> what sort of language are you manipulating the AST of?
16:34:02 <dbueno> But more generally, I have a function taking in a mutable array (Marray) that calls a function that uses an IArray, gets some info, and possibly mutates the MArray before returning.
16:34:14 <dbueno> I'll actually be using STUArrays, but this is a helper function in the ST monad.
16:34:16 <thoughtpolice> sarehu: doesn't need to be the fastest possible, it's a plugin for my irc bot that uses fortune.
16:34:45 <sjanssen> thoughtpolice: are the escape sequences Haskell style?  If so, just use read
16:34:45 <thoughtpolice> i just used unwords . lines to remove all the newlines but for example tabe characters still show
16:35:19 <sarehu> those are escape sequences?  You ean you want to remove tabs and newlines?
16:35:57 <thoughtpolice> my terminology might be screwed; basically i just want to remove \t's since lines takes care of the newlines.
16:36:10 <Saizan> dbueno: you've to instantiate the type of IArray you want there, since it won't appear in the type of f
16:36:21 <sarehu> so you have tab characters (not backslashes and t's) in your strings.
16:36:25 <dbueno> Saizan: So I need an annotation?
16:36:34 <thoughtpolice> yeah. sorry for the confusion :/
16:37:11 <dbueno> i.e. mFrozen :: UArray Int Int?
16:37:35 <Saizan> i think so
16:37:51 <dbueno> Oooh, it compiles.
16:37:55 <dbueno> Saizan, thanks for the help!
16:38:32 <Saizan> np
16:38:44 <Saizan> the error is a bit confusing
16:39:10 <Saizan> it should report ambigous type variable but the MPTC is probably deceiving it
16:39:15 <dbueno> I couldn't figure out how I'd tie the 'b' in 'IArray b Int' to anything.
16:39:27 <dbueno> MPTC?
16:39:51 <BMeph> Multi-Parameter Type Constructors (I think)
16:39:55 <kmcallister> type classes
16:40:14 <BMeph> Ooh, so close... ;P
16:40:20 <Saizan> :)
16:40:44 <Saizan> dbueno: that's the inferred type of mFrozen
16:41:51 <dbueno> Saizan: When I meant 'tie to anything' I meant by annotations -- I couldn't figure out where to stick a 'b' -- whether in the sig or on the unsafeFreeze line so that GHC didn't compain.
16:42:00 <dbueno> s/When I meant/When I said/
16:42:26 <faxathisia> huh http://www-users.cs.york.ac.uk/~ndm/supero/
16:42:29 <lambdabot> Title: Neil Mitchell - Supero
16:42:39 <faxathisia> the source code is not released?
16:43:19 <sarehu> thoughtpolice: so you want to replace "\n" with " " and "\t" with " "?
16:43:21 <Saizan> dbueno: well in the sig you can't since that type doesn't appear there, and annotating unsafeFreeze m is a bit complex due to the ST monad
16:43:23 <frobar> source code is not released?
16:43:25 <frobar> : Neil Mitchell - Supero
16:43:38 <ddarius> faxathisia: Why did (do) you think AST transformation would be "grimey" in Haskell?
16:44:01 <faxathisia> ddarius: my code is
16:44:07 <faxathisia> at least parts of it
16:44:15 <ddarius> faxathisia: How the heck did you manage that?
16:44:21 <thoughtpolice> sarehu: yeah, i got it. basically my solution is just unwords . lines $ map (\x -> if isControl x then ' ' else x)
16:44:28 <thoughtpolice> probably not the most efficient but it works
16:44:39 <faxathisia> well I had to write out val N_foo = 1, val N_bar = 2.. for like 20 things
16:44:40 <Philippa> it doesn't do a great job of relationships that smell like subtyping, that can get tedious
16:44:41 <sarehu> ah, well ok
16:44:46 <Philippa> I wouldn't call it actually grimy though
16:44:50 <Valodim> >_<
16:44:54 <sarehu> whatever, I don't care then :-)
16:45:15 <ndm> faxathisia: its not released, but it is online
16:45:39 <Feuerbach> How do I efficiently combine nub and sort?
16:45:42 <thoughtpolice> hm well in that case i guess the unwords . lines would be unnecessary but whatever. it works and i am happy. :)
16:45:46 <Philippa> faxathisia: that's not grime so much as having to embed a tedious mapping once. Though you shouldn't generally need too many of them
16:45:52 <Feuerbach> (like 'sort -u' in Unix)
16:45:59 <dons> Feuerbach: use a Set?
16:46:05 <Philippa> Feuerbach: write a specialised nub that assumes it's in order?
16:46:07 <vincenz> > group $ sort
16:46:17 <lambdabot>  Couldn't match expected type `[a]'
16:46:17 <dons> ndm's thought hard about this
16:46:25 <dons> for the case where Ord a => a holds
16:46:26 <sarehu> map head . group . sort
16:46:30 <vincenz> yp
16:46:37 <dons> :t group
16:46:38 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
16:46:41 <dons> :t nub
16:46:42 <lambdabot> forall a. (Eq a) => [a] -> [a]
16:46:59 <ndm> the answer was to use a Data.Map
16:47:22 <dons> with values of () ?
16:47:33 <dons> then pull the keys out?
16:47:34 <ndm> oh, Data.Set
16:47:51 <dons> :t Data.Set.fromList
16:47:52 <lambdabot> forall a. (Ord a) => [a] -> Data.Set.Set a
16:47:57 <dons> that's the Ord we want
16:48:03 <Feuerbach> ndm: why?? Like Philippa noted, I need just another version of nub (and wish it to be standard :p)
16:48:10 <ndm> no, use insert and lookup
16:48:31 <ddarius> Feuerbach: The "other version" of nub is just map head . group as sarehu mentioned.
16:48:46 <ndm> Feuerbach: i wanted it to be standard
16:50:14 <Feuerbach> ok, thank you :)
16:50:15 <sarehu> Feuerbach: In place of  map head . group  , you could use  foldr f . sort where { f x xs@(x':_) | x == x' = xs ; f x xs = x:xs }  -- maybe that's more efficient
16:50:33 <sarehu> but maybe not
16:50:45 <faxathisia> Oh here's one example, ddarius
16:50:53 <bench> so i've upgraded to ghc6.8.2
16:51:08 <bench> programs used to work don't anymore
16:51:16 <vincenz> dons: group groups locally
16:51:20 <bench> so how i go about finding the issue?
16:51:23 <vincenz> dons: it's O(n)
16:51:27 <faxathisia> I wanted to write a simplifier for the AST.. so I made a new AST which enforces the property... and a conversion from it to the old one
16:51:45 <faxathisia> so I basically have to define an entire set of new datatypes.. to define an invarient
16:51:52 <faxathisia> not sure if there is a way around it though
16:52:10 <faxathisia> (well I tried to do it with GADTs but it seems like a hack)
16:52:23 <Philippa> not really. Sufficiently ubiquitous generics might sugar things up a little
16:52:24 <faxathisia> (that could be my failing though)
16:52:29 <ndm> faxathisia: just document the invariant, and don't inforce it with the types
16:52:43 * ndm has written millions of AST invariants
16:52:53 <kmcallister> faxathisia, you can do that with smart constructors instead
16:53:11 <kmcallister> and you can use the module system to force use of the smart constructors
16:53:16 <faxathisia> yeah, I was thinking about it but... I could not be certain bugs don't exist in that case
16:53:18 <ndm> http://www.cs.york.ac.uk/fp/yhc/snapshot/docs/Yhc-Core-Invariant.html
16:53:19 <lambdabot> http://tinyurl.com/35tcbe
16:53:51 <ndm> faxathisia: can you ever be certain that bugs don't exist?
16:54:01 <faxathisia> ndm: Hopefully in the future!
16:54:32 <ndm> faxathisia: quickcheck gives it to you now, at some point someone will write a quickcheck prover, and we'll all be sorted :)
16:54:50 <Philippa> you can never, ever be certain. It's a question of how many nines you want to pay for
16:54:54 <ddarius> faxathisia: There are tricks.  The nicest thing would be if Haskell supported refinement types.
16:55:34 * ndm wants many nines but does not want to pay for any of them
16:55:41 <ndm> hence hindley milner is great :)
16:56:24 <faxathisia> is refinement types .. DML?
16:56:26 <faxathisia> what is that
16:57:28 <Philippa> faxathisia: imagine being able to type Cons foo (List foo) - or Cons Bar (List Foo) where Bar's a subtype of Foo, even
16:57:32 <ac_> @hoogle unit
16:57:33 <lambdabot> No matches found
16:57:45 <dons> ndm, swiert's done some Coq proofs for chunks of xmonad's StackSet
16:57:59 <ddarius> @google "Refinement types"
16:58:02 <lambdabot> http://www.cs.ucla.edu/~palsberg/tba/papers/freeman-thesis94.pdf
16:58:02 <faxathisia> oh so.. it is basically subtyping?
16:58:04 <dons> so there's an interesting spectrum from QC on xmonad, to HPC coverage, to Catch to Coq
16:58:26 <ndm> dons: soon Catch will support 100% of GHC compilable Haskell, then it should get a lot more useful
16:59:10 <kmcallister> dons: is there any way to automatically go between Coq and Haskell?
16:59:11 <faxathisia> sorry what is Catch?
16:59:19 <faxathisia> kmcallister: Coq can print out haskell code
16:59:28 <faxathisia> (as well as scheme and Ocaml)
16:59:31 <ivanm> faxathisia: it's a game using at least two people, a ball and optionally some type of glove :p
16:59:36 <kmcallister> ah, cool
16:59:39 <faxathisia> ivanm: In this context? lol
16:59:44 <ivanm> heh
16:59:48 <kmcallister> faxathisia, http://www-users.cs.york.ac.uk/~ndm/catch/
16:59:49 <lambdabot> Title: Neil Mitchell - Catch: Case Totality Checker for Haskell
16:59:59 <faxathisia> ohh ok thanks
17:00:08 <dons> kmcallister: there are some research projects that embed parts of haskell in Coq and Isabelle. Also, others that extract Haskell from Isabelle and Coq (i.e. you develop in the theorem prover first)
17:00:15 <dons> however, nothing production ready yet.
17:00:16 <ivanm> faxathisia: sorry, couldn't resist ;-)
17:00:20 <faxathisia> (how do I access that springer link thing on refinement types?)
17:00:23 <faxathisia> (I guess I can't?)
17:00:37 <ddarius> faxathisia: ?
17:00:59 <faxathisia> http://www.cs.ucla.edu/~palsberg/tba/papers/freeman-thesis94.pdf
17:01:11 <ddarius> Where do you see springer link?
17:06:33 <ac_> faxathisia: hm. So if you write something in Coq, and then emit Scheme, the Scheme code is guaranteed type safe?
17:06:55 <faxathisia> I guess.. I don't understand the internals
17:07:07 <faxathisia> You'd have to have a bug free scheme interpreter too....
17:08:33 <faxathisia> well say some function took a proof as a parameter and the extracted version didn't.. You might be able to pass in nonsense to it and cause an error
17:09:12 <faxathisia> so I think you have to make sure to call procedures with right inputs to ensure it's safe
17:10:07 <ac> Hey, does anybody have a fun little Haskell project for me to work on?
17:10:46 <faxathisia> ac, model something with Coq and generate a haskell program? :
17:10:48 <ddarius> faxathisia: That makes no sense.
17:11:14 <faxathisia> ddarius: well I've not used it yet.. just trying to answer the question
17:11:37 <dons> prove properties of the Haskell list api in Coq?
17:12:04 <ddarius> dons: Why bother?
17:12:26 <dons> i suppose a light model checker would be more useful
17:12:53 <ac> uhm... emphasis on fun
17:13:05 <dons> oh. fun! as in -Ofun?
17:13:14 <dons> hmm, emulate ion3 fully in xmonad?
17:13:14 <loupgaroublond> -funroll-loops
17:13:34 <dons> do a C-- to LLVM translator?
17:13:46 <dons> prototype a bit-level parser on top of Data.Binary?
17:13:55 <dons> write a version of polyparse for bytestrings?
17:14:09 <kmcallister> dons, speaking of emulating ion3 in xmonad, is there an xmonad layout engine that supports ion-like dynamic workspace splitting/unsplitting?
17:14:26 <sjanssen> kmcallister: not really
17:14:36 <glguy> how do you say (using associated type synonyms) class S b => C a b | a -> b
17:14:54 <sjanssen> glguy: I'm not sure that you can
17:15:11 <dons> oh, that constraint on b. hmm
17:15:14 <sjanssen> (without using a complicated encoding)
17:15:41 <dons> I think you can. I've seen:  class C a where type Ord b => b something -- or  maybe it was an example of a future extension
17:16:04 <ac> dons: what's polyparse?
17:16:09 <dons> yeah, i think it was a possible extension. glguy, check with Roman or Manuel. they've looked at this, iirc
17:16:20 <Saizan> dons: polyparsed already work on bytestring, the module is just not exposed in the .cabal
17:16:24 <alexj_> @seen lemmih
17:16:24 <lambdabot> lemmih is in #haskell. I last heard lemmih speak 11h 6m 3s ago.
17:16:27 <dons> oh, Saizan, very interesting!
17:16:53 <sjanssen> class C a where type B a; class (S (B a)) => C_Invariant a -- might work
17:19:27 <Saizan> i suppose Data.Binary.Put is much smarter than repeatedly using B.append if you want to concatenate a bunch of bytestrings?
17:20:02 <sjanssen> class C_Invariant a => C a where type B a; class (S (B a)) => C_Invariant a -- need to restrain C
17:20:41 <dons> Saizan: quite so.
17:20:44 <sjanssen> Saizan: or B.concat
17:20:51 <dons> or B.concat
17:21:15 <dons> though Data.Binary.Put builds a lazy bytestring, so it's O(k) not O(n) as for B.concat
17:21:42 <sjanssen> where k is O(n) :P
17:21:53 <dons> n/32k == 1 :)
17:22:45 <dons> constant factors matter!
17:25:30 <Saizan> what's wrong with just class S (B a) => C a where type B a?
17:26:16 <sjanssen> Saizan: good point :)
17:26:24 * sjanssen checks whether that works
17:27:02 <EvilTerran> ISTR it did when i tried it
17:27:15 <Saizan> compiles at least
17:27:32 <EvilTerran> altho the type families support is still a bit buggy
17:27:40 <EvilTerran> i've made the impossible happen a few times
17:28:24 <sjanssen> funny how often the impossible happens
17:28:38 <glguy> EvilTerran: that requires "FlexibleContexts"
17:28:44 <glguy> so I just wondered if there was some other way
17:28:52 <sjanssen> glguy: FlexibleContexts are well accepted
17:29:06 <dons> yeah, that's a fairly mild extension
17:29:15 <dons> though I bet Iavor complains anyway, glguy :)
17:29:21 <glguy> oh well, translating my fundeps into ATSs 1. causes the type checker to loop in this case
17:29:37 <glguy> 2. sucks at evaluating the ATSs away
17:29:40 <sjanssen> you can't get much done without those and flexible instances
17:29:40 <glguy> when asking for types
17:29:48 <glguy> *revert*
17:30:02 <sjanssen> sometimes you have to twist GHC's arm -- typeOf and show help
17:30:08 <glguy> typeOf?
17:30:35 <sjanssen> glguy: it would be a mistake to use type families in production code, IME
17:30:42 <glguy> agreed
17:30:44 <sjanssen> @type Data.Typeable.typeOf
17:30:46 <lambdabot> forall a. (Typeable a) => a -> TypeRep
17:30:55 <sjanssen> > typeOf (Just ())
17:30:56 <lambdabot>  Maybe ()
17:31:21 * sjanssen can't wait until GHC 6.10!
17:33:31 <glguy> ATSs, other than being buggy, seem to make the instances more "verbose" too
17:33:42 * EvilTerran agrees with that one
17:33:54 <sjanssen> oh?  I've had the opposite experience
17:34:09 <EvilTerran> i find the instance declerations using MPTCs+fundeps are much terser
17:34:12 <dcoutts_> dons: n/32k ~= 1 but not quite 1, remember all the people trying to do the icfp dna thing using lazy bytestring, the linear factor bites in the end, it was faster with a finger tree
17:34:18 <dcoutts_> dons: yes, polyparse needs investigating for performance with bytestring
17:34:24 <sjanssen> glguy: are you doing pure type programming, or do the classes have methods?
17:34:39 <glguy> sjanssen: methods
17:34:51 <EvilTerran> however, the contexts are significantly more fiddly with MPTCs
17:34:55 <sjanssen> too bad.  "type family" and "type instance" are nice
17:35:06 <glguy> sjanssen: for type level programing that is?
17:35:11 <sjanssen> glguy: yeah
17:35:12 <glguy> rather than defining method
17:35:13 <glguy> ah
17:35:45 <EvilTerran> yeah, the non-associated tysyns are significantly more succinct than having classes that serve only as relations on types
17:35:48 <sjanssen> they're especially nice with infix type names
17:36:12 <sjanssen> eg. type family m :+: n; type instance Zero :+: n = n
17:37:08 <sjanssen> type instance Succ m :+: n = Succ (m :+: n) -- the equivalent in FD is quite ugly
17:39:57 <tehgeekmeister> does anyone know if there's a haskell mode for emacs that uses ghci instead of hugs?
17:40:22 <dons> sjanssen: do you know if there's a limit to the size of files you can create on an off the shelf mac filesystem?
17:40:42 <sjanssen> dons: I've got no idea
17:40:48 <dons> ok.
17:41:26 * sjanssen has left that shiny bloat behind :)
17:41:38 <jsnx> dons: you mean UFS?
17:41:39 <shachaf> dons: http://en.wikipedia.org/wiki/HFS+ says "8 Exbibytes".
17:41:40 <lambdabot> Title: HFS Plus - Wikipedia, the free encyclopedia
17:41:50 * shachaf thought it was HFS+, anyway.
17:42:01 <yoshi> anyone know of any examples online that would help me make a function of type String to a Lambda expression?
17:42:04 <tehgeekmeister> shachaf: it is HFS+
17:42:20 <dmwit> yoshi: What?
17:42:22 <dons> shachaf: thanks
17:42:55 <dmwit> yoshi: You mean a two-argument function?
17:43:22 <tehgeekmeister> dons: i remember reading something in the past about older versions of OSX having lower limits, whether this was because of using hfs instead of hfs+ or something else i can't tell you, but i do believe there is a smaller limit for some older versions.
17:43:41 <yoshi> ex: "2x^3" -> (\x-> 2x^3)
17:44:14 <dons> tehgeekmeister: like 2G small?
17:44:24 <shachaf> tehgeekmeister: It looks like HFS+ is 2^63, HFS is 2^31 (bytes).
17:44:31 <dons> ah
17:44:32 <tehgeekmeister> dons: yes, it was 2GiB on HFS, not sure which OSX it's used in.
17:45:18 <dmwit> yoshi: Ah, you'll have to parse it yourself, or use one of the existing hot-loading frameworks that call GHC.
17:45:39 <dmwit> ?where parsec
17:45:40 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
17:45:47 <dmwit> ?where hsplugins
17:45:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
17:46:09 <dmwit> I have to go, but good luck!
17:46:23 <ddarius> sjanssen: Which shiny bloat did you replace it with then?  Were you the one who switched to a BSD?
17:47:06 <sjanssen> ddarius: I've been a Gentoo user for a long time
17:47:21 <sjanssen> (running xmonad ie. no shine, no bloat)
17:48:01 <yoshi> dmwit ah, that helps
17:48:17 <yoshi> wow parsing this is going to be a pain
17:48:20 <jsnx> sjanssen: i use gentoo, too -- i switched from fbsd
17:49:48 <EvilTerran> yoshi, even if you don't want all of haskell, there's probably still an existing parser out there somewhere that'll do, say, simple arithmetic expressions
17:50:01 <EvilTerran> if you *do* want all of haskell, hsPlugins is the way to go
17:51:13 <dons> main = do h <- openFile "big" WriteMode L.hPut h (L.cycle " haskell ")
17:51:16 <dons> is a fun program :)
17:51:25 <EvilTerran> if you just want something quick-and-dirty, you can probably implement RPN in half an hour at most
17:51:29 <dons> overloaded bytestring literals make me happy
17:51:36 <ddarius> sjanssen: xmonad isn't shiny?
17:51:44 <dons> its so shiny it burns
17:52:09 <sjanssen> ddarius: nah, intentionally not shiny
17:52:15 <dons> hah
17:52:16 <yoshi> EvilTerran RPN ?
17:52:28 <dons> its a different kind of bling
17:52:33 <sjanssen> it is "shiny" in the Firefly sense
17:52:50 <chessguy> dons, sounds like a tagline :)
17:52:52 <dons> gun metal grey, versus blingy bling diamonds :)
17:52:52 <EvilTerran> yoshi, "reverse polish notation"
17:53:07 <chessguy> "XMonad. It's a different kind of bling."
17:53:08 <EvilTerran> yoshi, like postscript, or retro calculators
17:53:51 <EvilTerran> uses a stack; constants (say, numbers) are commands that just push that constant onto the stack, functions pop their arguments from the stack and push their result
17:53:52 <ddarius> > let calc = foldr f [] . words where f "+" (x:y:xs) = x+y:xs; f "*" (x:y:xs) = x*y:xs; f n xs = read n:xs in calc "3 4 5 * +"
17:53:56 <lambdabot>  Exception: Prelude.read: no parse
17:54:02 <lucca> EvilTerran: or forth
17:54:07 <EvilTerran> okay :)
17:54:24 <sjanssen> ddarius: don't forget words
17:54:37 <sjanssen> oh, you've got it, nevermind
17:55:15 <ddarius> > let calc = foldl' (flip f) [] . words where f "+" (x:y:xs) = x+y:xs; f "*" (x:y:xs) = x*y:xs; f n xs = read n:xs in calc "3 4 5 * +"
17:55:30 <lambdabot>  thread killed
17:55:41 <EvilTerran> @vixen feeling a bit sluggish this evening?
17:55:42 <lambdabot> isn't it obvious?
17:55:51 <EvilTerran> > let calc = foldl' (flip f) [] . words where f "+" (x:y:xs) = x+y:xs; f "*" (x:y:xs) = x*y:xs; f n xs = read n:xs in calc "3 4 5 * +"
17:55:52 <lambdabot>  [23]
17:56:18 <EvilTerran> @bot
17:56:19 <lambdabot> :)
17:57:15 <EvilTerran> yoshi, there you are; RPN in about 100 characters. the complexity of parsing comes down entirely to what you want. :)
17:58:22 <lucca> errr, what is the difference between what ddarius and EvilTerran did?
17:59:06 <EvilTerran> the local weather
17:59:19 <EvilTerran> ...sometimes \bot seems to get stuck for no particular reason.
17:59:39 <lucca> hmmmm
18:00:45 <blackdog> well, i'm 8 lines into my haskell->java translation, and 120 lines of java code later...
18:00:55 <EvilTerran> @vixen or is it just that you like me better than ddarius?
18:00:55 <lambdabot> i'd say i like
18:00:58 <blackdog> either java's a terrible language or i'm a terrible java programmer :)
18:01:09 <EvilTerran> blackdog, well, the first's definitely true
18:01:22 <EvilTerran> but they're not mutexive
18:01:23 <blackdog> but it's OR, not XOR? :)
18:01:47 <blackdog> go back to flirting with my bot
18:01:48 <notsmack> blackdog: writing lots of lines of java is the hallmark of a /good/ java programmer
18:01:53 <ivanm> blackdog: isn't the second a badge of pride? :p
18:02:00 <yoshi> Haskell is the only language i know / have any interest in learning
18:02:22 <EvilTerran> even the best-written java compresses really well with, say, gzip
18:02:49 <EvilTerran> this is a bad thing; it shows there's a heck of a lot of redundancy
18:03:04 <blackdog> i'm not gonna claim that java's a terribly good language for abstraction, but it's shocking to see how much the translation bloats out
18:03:15 <EvilTerran> yoshi, that's not a perfect attitude either, mind
18:03:35 <EvilTerran> you don't want to restrict your future job prospects by refusing to learn a more mainstream language ;)
18:03:48 <blackdog> my haskell isn't doing anything wildly clever, either - couple of folds, maybe a list comprehension or two.
18:04:11 <dons> type inference helps, I guess
18:04:11 <yoshi> yeha touschet
18:04:26 <jcreigh> HOF FTW!
18:04:32 <blackdog> it's just sort of depressing - seems like the way to be a good java programmer is to type fast and be able to turn yourself into an efficient macro processor
18:04:43 <EvilTerran> or even restrict your future mind-expansion prospects; there's other languages with features you can't experiment with in haskell
18:04:47 <blackdog> dons: it isn't even that
18:04:57 <blackdog> i could translate this into ruby or lisp line for line, i think
18:05:02 <EvilTerran> blackdog, GoF = a set of macro definitions for brains ;)
18:05:04 <blackdog> it helps when you're writing it the first time
18:05:21 <hpaste>  tehgeekmeister pasted "Type error I don't understand in flowchart dealio." at http://hpaste.org/4873
18:05:32 <EvilTerran> (ha ha only serious)
18:05:53 <blackdog> EvilTerran: maybe i could try the Interpreter pattern - just embed a little language in there and call the actual program a resource file :)
18:06:36 <EvilTerran> tehgeekmeister, (case')'s second parameter is of type String, but you're returning it as the fst of the pair, which is typed as (a)
18:07:18 <tehgeekmeister> EvilTerran: yes, i realized right after i pasted it that i'd swapped the position of the arguments but didn't do the same in the type signature.  it gives a new error once i correct that, however.  annotating it now.
18:07:19 <EvilTerran> tehgeekmeister, maybe you meant case' [] s x = (x, Nothing)?
18:07:35 <EvilTerran> ah, okay
18:10:58 <tehgeekmeister> hmm.  writing the type signature makes it a lot easier to reason about what i'm doing wrong.  i think i've got myself back on track.
18:11:00 <scook0> blackdog: system("runhaskell")? ;)
18:12:11 <jsnx> s/way you would few/way you would fight/
18:12:14 <jsnx> ack!
18:12:41 <jsnx> i need to change the way irssi let's me know which window i'm typing in
18:14:25 <LoganCapaldo> type signatures rule!
18:22:41 <jsnx> yeah, i guess i could annotate all my chats :: #haskell [Char]
18:26:40 <tehgeekmeister> can you pattern match in guards?
18:26:52 <jsnx> tehgeekmeister: let's see
18:27:02 <sjanssen> with an extension called "pattern guards"
18:27:42 <jsnx> tehgeekmeister: you know, i can't figure out what that would look like...
18:27:55 <LoganCapaldo> well you can always pattern match in guards no?
18:28:18 <tehgeekmeister> i don't want to use any extensions, i can get by without it.
18:28:40 <LoganCapaldo> > let f x | (case x of { 0 -> True ; _ -> False) } = True in f 0
18:28:41 <lambdabot>  Parse error at ")" (column 46)
18:28:47 <LoganCapaldo> oops
18:28:54 <LoganCapaldo> > let f x | (case x of { 0 -> True ; _ -> False } )  = True in f 0
18:28:56 <lambdabot>  True
18:29:12 <LoganCapaldo> you just need pattern guards to do f x | (x,y) <- x = ..
18:29:19 <LoganCapaldo> type stuff
18:29:23 <LoganCapaldo> right?
18:30:07 <tehgeekmeister> to match on a maybe, but i can just use the function maybe outside of the guard.
18:30:36 <LoganCapaldo> f x | isJust maybeval
18:30:41 * LoganCapaldo shrugs
18:43:28 <MyCatVerbs> Heehee. Interesting little consequence.
18:45:02 <MyCatVerbs> I have a program that makes use of concurrent haskell to talk to network sockets and concurrently control other processes.
18:45:40 <MyCatVerbs> Since threaded operation makes using GHC's profiler impossible, I've taken to use -Sstderr to check to make sure it doesn't have, say, any crazy space leaks. (None, thankfully.)
18:46:35 <MyCatVerbs> Interesting thing is, because it uses so few CPU cycles (it's waiting on the network and the external programs pretty much 99.something% of the time)...
18:47:16 <MyCatVerbs> ...and also because of the GHC feature where the garbage collector automatically takes a sniff around if the run-time has been idle for the last 0.3 seconds...
18:47:58 <MyCatVerbs> ...it hits the garbage collector over and over again, practically every time it talks to the network (which has a human - slow - operator sat at the other end of it).
18:48:35 <MyCatVerbs> So when I kill the program (to recompile, or whatever), the run time system proudly informs me that more than 80% of the CPU cycles spent by my program were all spent in the garbage collector. :D
18:49:00 <sjanssen> hmm, can you shut that off with an RTS option?
18:50:04 <MyCatVerbs> sjanssen: yes I can, (I ran through the documentation while looking for ways to check for space leaks), but I don't really feel the need to.
18:50:57 <MyCatVerbs> sjanssen: I find it kind of cute, really. And fairly harmless, since it's at, oh, 0.09 seconds of CPU time used so far, over something like the last half hour or so, at least. =)
18:54:13 <MyCatVerbs> sjanssen: for contrast, I have a C program running as part of the same (application|fucking mess), whose sole job is to cyclically read() from one FIFO and write() into another, at a rate of ~172 kilobytes/second, with a few seconds' buffering between the two. It uses a pair of pthreads threads, one for reading and one for writing, with (prettty durn simple) synchronization provided by POSIX semaphores.
18:55:10 <MyCatVerbs> sjanssen: in the same time that my Haskell (controlling) program has eaten 0.09 (oh, call it 0.1-ish) seconds of CPU time, *that* perpetually-blocking-IO-muncher of a C program has eaten slightly over 1.2 seconds. All in all, who gives a flying turd? ^_^
18:55:19 <sjanssen> :)
18:55:29 <sjanssen> threads are no fun in C
18:56:40 <sjanssen> MyCatVerbs: have you tried re-implementing that part in Haskell?
18:56:56 <jsnx> MyCatVerbs: yeah, it would be cool if it worked well
18:57:39 <MyCatVerbs> sjanssen: Ã§a depend. If you have only awful crap like mutexes and condition variables at your disposal, multithreading in C is made of fail, pain and woe. OTOH, using better constructs like semaphores in C is actually vaguely pleasant(-ish). But still nowhere near as fun as Haskell.
18:57:49 <sjanssen> I think there is a particularly nice implementation with non-blocking IO and lazy ByteString waiting to be written
18:57:51 <MyCatVerbs> sjanssen: no, but that's my next step, since I'd rather those *weren't* seperate programs. :)
18:58:06 <sjanssen> MyCatVerbs: the program is simply 'cat'?
18:59:07 <MyCatVerbs> sjanssen: pretty much, but with a nice big buffer between the input and output. Its input is from a (not particularly smooth) decoder and the output goes straight to the luser's headphones. :)
18:59:11 <dcoutts_> MyCatVerbs: so you need an ordinary cat or a delaying cat?
18:59:34 <MyCatVerbs> dcoutts_: delaying cat, with a fixed (but large) buffer size.
18:59:34 <dcoutts_> a delaying cat, hmm.
18:59:49 <sjanssen> dcoutts_: is hGetContents in ByteString non-blocking?
18:59:59 <sjanssen> (lazy ByteString, of course)
19:00:01 <MyCatVerbs> i.e. I don't want it slurping the whole damn input file in one go, that'll break things - like my brain, for one.
19:00:04 <dcoutts_> sjanssen: in lazy bytestring it is non-blocking
19:00:16 <MyCatVerbs> sjanssen, dcoutts_: I was thinking of using IOUArrays.
19:00:42 <sjanssen> MyCatVerbs: I wouldn't bother with that, personally.  Just use ByteString
19:01:29 <dcoutts_> sjanssen: using lazy hGetContents would make it tricky since you'd not know how much input was available to be written out
19:01:40 <MyCatVerbs> Since I don't want to do *anything* with the bytes passing through. If I use anything intended for text, there's a distinct risk that someone one day might equip the input libraries I depend on with automatic UTF-8 or UTF-16 (en|de)coding, which would potentially cause all Hell to break loose. :)
19:01:51 <dcoutts_> I think you'd need to go one layer lower, to a collection of ByteString reads
19:02:03 <dcoutts_> then you know how many you've got, ie how big your buffer is
19:02:27 <dcoutts_> MyCatVerbs: ByteString IO guarantees to work in bytes not chars
19:02:32 <dcoutts_> it's binary
19:02:35 <ddarius> MyCatVerbs: As the name suggests, ByteString isn't text
19:02:54 <dcoutts_> we'll add a unicode equivalent to bytestring some day when someone has time
19:03:06 <dcoutts_> but it'll be complementary to ByteString
19:03:35 <dcoutts_> though it'll make Data.ByteString.Char8 rather less needed
19:04:44 <MyCatVerbs> ddarius: heh, I see. :)
19:05:32 <sjanssen> MyCatVerbs: is there a danger that the 'in' pipe will suddenly output very quickly?
19:05:33 <MyCatVerbs> dcoutts_: but I literally -never- touch that data, except to push it out on the other FIFO. So what would using ByteStrings gain me?
19:05:45 <sjanssen> fast enough to require that the buffer size is limited
19:06:41 <MyCatVerbs> sjanssen: oh definately. The in pipe is from an mp3 decoder (which on today's CPUs is orders of magnitude faster than real-time)... well, indirectly, but the stages in between are effectively irrelevant.
19:07:44 <dcoutts_> MyCatVerbs: because it'll make the program a good deal shorter
19:07:56 <dcoutts_> rather than manually managing a mutable buffer
19:08:04 <dcoutts_> and the performance will be similar
19:11:34 <MyCatVerbs> dcoutts_: Data.Array.IO exports hGetArray and hPutArray, which don't seem too troublesome.
19:12:17 <sjanssen> this is because you're used to C
19:12:20 <MyCatVerbs> dcoutts_: admittedly it leaves me holding the chain to allocate a set of buffers, but that's not particularly awkward.
19:12:29 <MyCatVerbs> sjanssen: yep.
19:13:36 <dcoutts_> MyCatVerbs: so the question is, is the more complex code worth the very slight performance gains
19:13:57 <dcoutts_> it's perhaps difficult to predict. One can try both and benchmark :-)
19:15:21 <MyCatVerbs> dcoutts_: the performance is irrelevant either way. The only difference I can see that I'd concievably care about is that ByteStrings will do a fair quantity of allocation, which'll piss off the garbage collector somewhat. :)
19:15:54 <dcoutts_> MyCatVerbs: actually a trivial cat (main = interact) is quite speedy and doesn't stress the GC at all
19:16:11 <dcoutts_> erm, main = B.interact id
19:16:19 <MyCatVerbs> (A garbage collection pause long enough to cause audio stuttering *would* be a performance problem, though. I can't see that happening, though, so no worries.)
19:16:33 <dcoutts_> MyCatVerbs: think about how many allocations you're doing
19:16:56 <dcoutts_> you could count them on your hands, and since GC time is proportional to the number of allocations
19:17:04 <dcoutts_> not their size
19:17:11 <dcoutts_> then it's all fine
19:19:39 <MyCatVerbs> dcoutts_: problem is that I potentially have about... two or three hundred megs (off the top of my head, estimated by looking at current memory usage and multiplying by five on the (pessimistic) assumption that the DJ has half a terrabyte of music on hand) of live data pretty much permanently resident in memory.
19:20:45 <dcoutts_> > (300 * 1024 * 1024) / (64 * 1024)
19:20:49 <MyCatVerbs> dcoutts_: also, I call map on that once every three minutes. :)
19:20:54 <lambdabot>  4800.0
19:21:09 <dcoutts_> that number of 64k chunks
19:21:14 <MyCatVerbs> dcoutts_: (that's song titles, filenames and other metadata, not songs themselves)
19:21:25 <dcoutts_> oh right
19:21:48 <MyCatVerbs> 300 megs is assuming a DJ with a biiiiig library. Heh.
19:23:51 <MyCatVerbs> So I possibly don't want to fold the buffering into the Haskell program at all, since even a very small GC pause could totally piss in my cornflakes. So to speak. Whereas with the buffering (the only really urgently (soft) real-time component that I have to deal with) in an external program, the GC could happily go off into a corner for anything up to something on the other of one and a half CPU seconds, and I wouldn't care.
19:24:11 <MyCatVerbs> ...wait, no, I'm being stupid.
19:25:35 <MyCatVerbs> I'm using less CPU time than I can conveniently easily measure anyway, and that's with (unneccessarily) over-regular GC-ing.
19:36:56 <dons> ?jion #gentoo-uy
19:36:56 <lambdabot> Maybe you meant: djinn join
19:37:00 <dons> ?join #gentoo-uy
19:37:11 <Korollary> uy = ?
19:37:12 <sjanssen> @djinn #gentoo-uy
19:37:13 <lambdabot> Cannot parse command
19:37:30 <dons> heh
19:37:35 <dons> uruguay
19:38:32 <MyCatVerbs> Why's \bot needed in #gentoo?
19:38:45 <MyCatVerbs> (And, naturally, #gentoo-*)
19:38:58 <dons> they like it?
19:39:05 <dons> it was invited
19:39:21 <Korollary> One channel at a time. Lambdabots uber alles.
19:40:23 <dons> ?seen lambdabot
19:40:23 <lambdabot> Yes, I'm here. I'm in #gentoo-uy, #friendly-coders, #fi.muni.cz, #curry, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #
19:40:23 <lambdabot> haskell-blah, #scala, #haskell, #ghc and #darcs
19:41:17 <BMeph> What, no #clean? ;p
19:42:12 <dons> 19:42 -- Irssi: #clean: Total of 1 nicks [0 ops, 0 halfops, 0 voices, 1 normal]
19:42:32 <dons> clean should have been merged into the haskell effort in 1987
19:42:35 <dons> oh well
19:47:38 <jsnx> dons: is it someone on the clean project (can not remember who) working on a haskell compiler extension?
19:47:45 <MyCatVerbs> Ah, balls.
19:47:47 <jsnx> s/is it/isn't/
19:48:21 <MyCatVerbs> dcoutts_: what would you reccommend doing to set things up such that if the read pipe is closed, the program automatically re-opens it again?
19:48:59 <MyCatVerbs> dcoutts_: I have this nicely sorted in C, but naturally that way of doing things involves ridiculous quantities of mutable state.
19:49:27 <jsnx> MyCatVerbs: can i look at your C? i've been trying to figure out how to do that in C for some time...
19:49:29 <dcoutts_> MyCatVerbs: you'll be using a recursive function in IO so you can make the Handle a parameter
19:49:47 <dcoutts_> so when you get an EOF, you can open a new Handle
19:49:59 <MyCatVerbs> jsnx: ...my C is *really* ugly. Hehehhe.
19:50:06 <jsnx> MyCatVerbs: that is okay
19:50:11 <jsnx> MyCatVerbs: it never looks that good
19:50:35 <dcoutts_> MyCatVerbs: how would you re-open a new pipe anyway? or do you mean make a new pipe?
19:50:35 <jsnx> dcoutts_: depending on what kind of pipe he has, it can be way more complicated than that
19:50:43 <dcoutts_> or is it a named pipe / socket?
19:51:05 <MyCatVerbs> jsnx: the gist of it is: for (;;) { FILE* fd = fopen(input,"r"); while (!feof(fd)) { /* read from fd */ } }
19:51:18 <jsnx> pipes send EOF after you read from them the first tiime
19:51:27 <jsnx> then you open them again
19:51:34 <MyCatVerbs> dcoutts_: it's a named pipe. FIFO! ^_^
19:51:57 <jsnx> however, if the process on the other end is dead, but waiting to be reaped, then you get SIGPIPE
19:52:09 <jsnx> i have some python that deals with this...
19:52:11 <Cale> dons: Ouch, did clean ever have much of an IRC channel though?
19:52:19 <MyCatVerbs> jsnx: just that I'm putting the bit of the program that opens the file in a for-ever loop (for (;;), heehee), and the bit that actually slurps the data inside that loop too.
19:52:48 <jsnx> MyCatVerbs: thanks, i was curious
19:52:59 <jsnx> MyCatVerbs: so, the process writing into the pipe is not a child of the reader
19:53:36 <MyCatVerbs> jsnx: no. There are a whole pile of different processes, being run from (what else?) a shell script. Of which my Haskell program is only one. :)
19:53:37 <Cale> #define ever (;;)
19:53:56 <jsnx> Cale: that is the path to madness
19:54:10 <MyCatVerbs> Cale: #define EVAR (;;) /* fixed spelling */
19:54:16 <MyCatVerbs> ;)
19:56:27 <MyCatVerbs> jsnx: oh and I also make sure not to lose track of each thread's position in the cyclic buffers when re-opening. :)
19:56:42 <MyCatVerbs> jsnx: yes, I have had the program deadlock due to a bug of that description. ^_^
19:57:23 <jsnx> MyCatVerbs: the asynchronous message passing thing for dealing with closed processes is annoying
19:57:44 <jsnx> i do not understand why can't look this stuff up in the process table
19:58:13 <jsnx> my python script feeds a UNIX interactive application from a pipe, hiding EOF from it [https://svn.j-s-n.org/public/i-can-has-root/python/pipe-fitter.py ]
19:58:28 <dons> Cale: not that i know of.
19:58:58 <jsnx> so you can run `pipe-fitter.py sh` for example, and then talk to sh through the pipes
19:59:12 <jsnx> it was not as simple or beautiful as i had hoped
20:00:01 <MyCatVerbs> jsnx: handy. Luckily my problems are less complicated than yours, as I don't really have to worry too much (yet) about inter-process interactions.
20:00:08 <jsnx> (it's called i-can-has-root because the possibilities for privilege escalation are big!)
20:00:36 <MyCatVerbs> jsnx: Unfortunately, that's about to change, as the next two features on my TODO list will require some fair quantity of voodoo with System.Process, but oh well. ^_^
20:00:47 <jsnx> MyCatVerbs: i had this weird idea -- i'd have a web server, and whenever a user logged in it would immediately start a shell with this thing using their credentials
20:01:05 <jsnx> voila -- user management courtesy of UNIX
20:01:19 <MyCatVerbs> Eeep.
20:01:26 <jsnx> whenever they wanted to change their password or whatever, it'd go through my "POSIX compatibility layer"
20:01:41 <jsnx> the plan was to virtualize the system the users interacted with
20:02:01 <jsnx> so that any mistakes would not allow them access to the servers with the actual database, LDAP directory and so on
20:02:23 <jsnx> MyCatVerbs: it would be totally stupid outside of a distributed system
20:02:30 <MyCatVerbs> Y'know first  use I could see for that? Attach dfrotz to it and play "Pick up the phone booth and die" in your browser.
20:03:34 <jsnx> MyCatVerbs: sure, there's that -- but I wanted for a CMS, with version control through mercurial and access control through POSIX groups
20:04:16 <jsnx> the idea of reimplementing users, groups and file permissions really within a database really sickened me
20:04:26 <jsnx> i'm a lazy coder ;)
20:04:43 <jsnx> s/really within/within/
20:12:04 <jsnx> MyCatVerbs: you actually wouldn't need to use sh, either -- i'd make some kind of limited shell, and use that
20:12:18 <jsnx> this would be the 'interpreter pattern' in a big way
20:13:38 <ricky_clarkson> Ugh, patterns.
20:18:23 <skew> ricky_clarkson: It's in quotes, it can't eat you
20:18:43 <ricky_clarkson> Ah.
20:18:59 <ricky_clarkson> '(0/:l)(_+_)'
20:19:03 <ricky_clarkson> phew
20:20:51 <jsnx> ricky_clarkson: that's a totally different kind of pattern
20:21:39 <skew> Wow, that looks like some kind of Picasso
20:21:45 <jsnx> ricky_clarkson: and i'm talking about giving each user on a web site a session with a limited shell, and then using POSIX groups as the basis for permission management
20:21:53 <jsnx> not some OO thing
20:22:01 <ricky_clarkson> It's Scala.
20:22:07 <jsnx> ricky_clarkson: yes, i know
20:22:24 <ricky_clarkson> I know you know.
20:22:34 <jsnx> ricky_clarkson: lolz
20:22:39 <jsnx> >:3
20:22:55 <ricky_clarkson> I wrote the in defence of it blog, and you commented on it in reddit.
20:23:07 <jsnx> ricky_clarkson: really?
20:23:07 <skew> and I thought the robot monkey operator was getting extreme
20:23:19 <jsnx> ricky_clarkson: scala is the devil
20:23:25 <jsnx> operators like that are evil
20:23:29 <jsnx> use keywords
20:23:45 <jsnx> because i do not want to learn any new operators, damn it
20:23:46 <ricky_clarkson> It's funny that you're here then, with >>=, $, etc.
20:23:51 <jsnx> lolz
20:23:58 <jsnx> there are still many key words
20:24:07 <jsnx> but they should have used | for >>=
20:24:18 <jsnx> as for $, i'm not sure what
20:24:30 <skew> The (0/:1) looks like some kind of cyclops
20:24:33 * BMeph performs an incantation to banish such arcane symbols back into J...
20:24:35 <ricky_clarkson> So operators are ok as long as it's the ones you like.
20:24:41 <jsnx> ricky_clarkson: no
20:24:46 <jsnx> ricky_clarkson: as long as they are not new
20:24:47 <ricky_clarkson> skew: It was actually an l, not a 1.
20:25:06 <jsnx> ricky_clarkson: the UNIX ones are only okay because they have been around for forty years
20:25:22 <jsnx> ricky_clarkson: if they were making that system today, there would be no excuse
20:25:26 <ricky_clarkson> jsnx: So at some point in the past they were stupid?
20:25:34 <jsnx> ricky_clarkson: no, they had requirements
20:25:47 <jsnx> and now it's part of the lexicon -- no point in fighting that
20:26:01 <jsnx> but introducing new operators is goofy and bad
20:26:04 <skew> so by induction programming languages shouldn't use punctuation!
20:26:07 <ricky_clarkson> There's no point in fighting new lexicon.
20:26:11 <jsnx> ricky_clarkson: true
20:26:25 <jsnx> ricky_clarkson: but i would encourage conservatism in introducing it
20:26:37 <jsnx> skew: no
20:26:44 <ricky_clarkson> Conservatism isn't very scientific.
20:26:45 <jsnx> skew: they should use the usual punctuation
20:26:51 <ricky_clarkson> I'd say if it's useful, use it.
20:27:03 <dons> why do people stress about operators, but don't care about learning alphabetic function or method names?
20:27:04 <jsnx> ricky_clarkson: and i say, if it's unclear, don't
20:27:14 <jsnx> dons: it's much easier to learn the longer names
20:27:30 <dons> shrug, its all just ascii after a while :)
20:27:36 <skew> ricky_clarkson: for what it's worth, I liked the original Christopher Alexander book on patterns
20:27:44 <jsnx> dons: the problem with operators is when they are equivocal -- mean half a dozen different things -- as opposed to univocal
20:27:57 <ricky_clarkson> Learning the longer names takes less time, but after you've learned them, they're less useful.
20:28:14 <dons> f `compose` g would make me cry every day :)
20:28:26 <jsnx> dons: yeah, but f
20:28:27 <ricky_clarkson> E.g., if ++ was called concatenate in Haskell, it would be far less useful.
20:28:28 <jsnx> ack
20:28:32 * ivanm passes dons a box of tissues
20:28:35 <jsnx> f
20:28:47 <dons> a `cons` b `cons` nil
20:28:53 <jsnx> f âˆ˜ g is fine though
20:29:00 <dons> yay symbols
20:29:14 <jsnx> UTF8 should help us with lot of this stuff
20:29:15 <kmcallister> f `o` g
20:29:23 <jsnx> kmcallister: no need
20:29:35 <ricky_clarkson> So as long as programmers never invent anything new, operators are ok, I see.
20:29:57 <jsnx> ricky_clarkson: look, it's not as black and white as that, i agree
20:30:01 <MyCatVerbs> jsnx: uhhh. Where the Hell am I going to find a keyboard that has that many symbols on it? :)
20:30:10 <jsnx> MyCatVerbs: dude, use SCIM
20:30:14 <MyCatVerbs> SCIM?
20:30:18 <jsnx> MyCatVerbs: i don't have that many symbols
20:30:25 <jsnx> MyCatVerbs: learn about computers
20:30:27 <ricky_clarkson> I think the opposite way.  Programmers should try using many new operators, to work out what works best for them.
20:30:31 <jsnx> MyCatVerbs: they are awesome
20:30:42 <MyCatVerbs> jsnx: :P
20:31:07 <monochrom> Why is Haskell so successful? Why are we attracting all kinds of wimps?
20:31:11 <MyCatVerbs> jsnx: X11's compose key functionality is nice, but I don't want to memorize that many keystrokes.
20:31:13 <jsnx> MyCatVerbs: SCIM == (Smart Common Input Method) for chinese, LaTeX, german, whatever
20:31:14 <dons> monochrom: heh.
20:31:38 <monochrom> "Symbols are too hard. Let's go spelling."
20:31:42 <ricky_clarkson> @bab en es morning
20:31:42 <MyCatVerbs> jsnx: sudo apt-getting now. :)
20:31:42 <lambdabot>   mañana
20:31:49 <jsnx> to type âˆ˜ i actually type \circ
20:31:58 <jsnx> like in TeX
20:31:58 <ricky_clarkson> I still can't type Ã±
20:32:20 <kmcallister> MyCatVerbs, compose key is mostly mnemonic
20:32:39 <jsnx> ricky_clarkson: i don't think there's much reason to make things short in programs, honestly
20:32:50 <jsnx> ricky_clarkson: i don't think typing slows me much -- it's thinking that does that
20:33:03 <ricky_clarkson> jsnx: Typing is less important than reading.
20:33:15 <ricky_clarkson> I got my 110wpm through programming, typing is no barrier.
20:33:17 <jsnx> ricky_clarkson: and i prefer, out of fear, i guess, that languages be verbose so i can read them
20:33:19 <MyCatVerbs> jsnx: how much you can physically fit in one screenful of text in order to read it is important.
20:33:37 <ricky_clarkson> jsnx: I think that's a fear to get over.
20:33:44 <monochrom> MULTIPLY X BY Y INTO Z
20:33:59 <MyCatVerbs> monochrom: ADD 1 TO COBOL GIVING COBOL
20:34:01 <jsnx> MyCatVerbs: then maybe we should strive for languages which make full use of UTF8, instead of ones that reuse ASCII in weird ways
20:34:16 <monochrom> APPLY M TO X BINDING RESULT TO Y.  (y <- m x)
20:34:35 <ivanm> jsnx: I think we should stick to ASCII, as it ensures widest possible usage/coverage
20:34:42 <ivanm> since not everyone uses unicode
20:34:46 <MyCatVerbs> jsnx: ...
20:34:48 <ivanm> (and not everyone can)
20:35:05 <MyCatVerbs> jsnx: well, wouldja lookit that? guile & ghc have already achieved that. :)
20:35:06 <monochrom> Stick to binary. Then you can even Morse-code it.
20:35:18 <MyCatVerbs> jsnx: and those just happen to only be the two that I can name offhand. I'm sure there are more.
20:35:24 <jsnx> I HAS A VAR
20:35:27 <ivanm> monochrom: short = 0, long = 1? :p
20:35:31 <jsnx> UP VAR!!1
20:35:34 <monochrom> ivanm: "not everyone can use unicode" is a self-fulfilling prophecy.
20:35:51 <jsnx> MyCatVerbs: ghc doesn't really, i don't think
20:35:52 <monochrom> Wonder what came before ASCII?
20:35:55 <ricky_clarkson> monochrom: Also, it's a fact.
20:36:01 <jsnx> MyCatVerbs: you can't name things in chinese
20:36:10 <ivanm> tbh, I find too many symbols in code to be too distracting from the code itself
20:36:14 <jsnx> and where the capital sigma for summation, for example?
20:36:30 <ivanm> can you imagine what would happen if people started assigning random symbols for function names?
20:36:30 <monochrom> There was a time people were like "not everyone can use ascii, some of us are still stuck with ebcdic"
20:36:31 <MyCatVerbs> jsnx: can't you? I know it now reads utf-8 string and character literals in properly... *checks*
20:36:36 <ivanm> code would look just like gibberish!
20:36:40 <jsnx> yeah, but `Î£ list` would be cool
20:36:41 <ricky_clarkson> Code should look exactly how the writer wants it to.
20:36:55 <ivanm> jsnx: true....
20:37:17 <MyCatVerbs> jsnx: uhhh... ghc totally does let you use utf-8 in function names. :)
20:37:17 <jsnx> ricky_clarkson: i have seen too many writers who don't want it to look like much...
20:37:21 <ivanm> ricky_clarkson: well, yes, but normally code should be maintainable, obfuscated comp entries aside
20:37:22 <jsnx> MyCatVerbs: no
20:37:36 <jsnx> MyCatVerbs: you can't use character sets that don't have lower and upper case
20:37:45 <ricky_clarkson> ivanm: If the writer wants it to be maintainable, yes.
20:37:59 <MyCatVerbs> > let Ã¸ = (*2) in Ã¸ 5
20:38:00 <lambdabot>  Illegal character ''\184''
20:38:00 <lambdabot>  at "¸" (column 6)
20:38:02 <jsnx> the writer must always make maintainable code
20:38:06 <jsnx> even at the shell prompt
20:38:09 <MyCatVerbs> Huh.
20:38:10 <oerjan> what i wonder is, how do you distinguish functions and constructors in chinese?
20:38:15 <MyCatVerbs> Works in 6.8.2's ghc, for me.
20:38:26 <jsnx> oerjan: case is a bad way to distinguish, i think
20:38:29 <ricky_clarkson> jsnx: Maintainability is not scientific.
20:38:40 <monochrom> unicode Î»xâ†’x+1 is gibberish?  ascii asdf #$@% is not gibberish?
20:38:48 <ivanm> MyCatVerbs: so is it IRC, lambdabot or ghc?
20:39:00 <jsnx> oerjan: should use `:constructor` or something like that
20:39:04 <oerjan> jsnx: that's my thought, but my question is, does ghc have any solution?
20:39:08 <MyCatVerbs> ivanm: I think \bot runs with an old version of ghc
20:39:10 <ricky_clarkson> Maintainable by someone who has the same background as you is different from maintainable by a random who doesn't even know the language.
20:39:16 <oerjan> @version
20:39:17 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
20:39:17 <lambdabot> darcs get http://code.haskell.org/lambdabot
20:39:22 <ivanm> MyCatVerbs: *nod* forgot about that
20:39:23 <jsnx> oerjan: they are thinking of making a 'uppercase' character to lead in with, i'm told
20:39:24 <MyCatVerbs> ivanm: and support for utf-8 in programs is new in 6.8, AFAIK.
20:39:30 <oerjan> jsnx: ah
20:39:42 <jsnx> MyCatVerbs: no, it's been around
20:39:42 <MyCatVerbs> jsnx: heh. You have one point here.
20:40:04 <jsnx> MyCatVerbs: which point?
20:40:23 <MyCatVerbs> You could never write Î£ list, since Î£ is uppercase and Haskell demands that it can hence only be a data constructor. ;)
20:41:12 <monochrom> Java already allows unicode source code. Can have Arabic variable names. That's the example in the Java books.
20:41:30 <ricky_clarkson> Arabic.  Making Java more backward.
20:41:37 <Hirvinen> =D
20:42:03 <monochrom> haha
20:42:06 <ricky_clarkson> SPJ said something along the lines of "type constructors starting with uppercase is only a convention.  An enforced convention"
20:42:09 <jsnx> yeah, but what i mean is...the language should support Î£, âˆ˜, â†’ and so on
20:42:22 <jsnx> as basic function names
20:42:31 <jsnx> so that our code could look cool like that
20:42:41 <ricky_clarkson> jsnx: I thought it did.
20:42:52 <jsnx> ricky_clarkson: what does?
20:43:00 <jsnx> ghc does not
20:43:46 <MyCatVerbs> jsnx: 6.8 does. It really really does.
20:44:00 <jsnx> MyCatVerbs: no, it does not -- you can not define a function Î£
20:44:11 <jsnx> and there is no âˆ˜ either
20:44:37 <ricky_clarkson> Can you define a type constructor Î£?
20:44:59 * ricky_clarkson only has 6.6.1.
20:46:12 <jsnx> ricky_clarkson: yes
20:46:20 <jsnx> type Î£ = int
20:46:28 <jsnx> @type Î£ = int
20:46:31 <lambdabot> parse error on input `='
20:46:35 <jsnx> > type Î£ = int
20:46:36 <lambdabot>  Parse error at "type" (column 1)
20:46:39 <jsnx> bah
20:46:48 <jsnx> on my GHCi it works
20:46:49 <monochrom> type Î£ a = [a]
20:46:50 <dons> you need the unicode flag. and your own ghci.
20:46:56 <ricky_clarkson> jsnx: so it does support UTF-8, as MyCatVerbs said, Î£ is uppercase.
20:47:04 <monochrom> ghci 6.8.1 is fine with that in a file.
20:47:07 <jsnx> ricky_clarkson: you can define a function by that name, though
20:47:17 <jsnx> ricky_clarkson: so i can't get what i am looking for
20:47:31 <ricky_clarkson> Did you mean to say "can't"?
20:47:39 <jsnx> ricky_clarkson: yes
20:47:50 <ricky_clarkson> I can't define a function called BOB.
20:47:56 <jsnx> ricky_clarkson: right
20:48:03 <jsnx> ricky_clarkson: which it too bad
20:48:38 <ricky_clarkson> I kind of agree, but it doesn't bother me.
20:48:43 <jsnx> upper/lower case frustrate use of standard mathematical notation -- as well as alienate users of Chinese, Hebrew, &c.
20:48:51 <TSC> You'd have to say Ïƒ = sum instead (:
20:49:04 <jsnx> TSC: which is totally confusing
20:49:38 <ricky_clarkson> Clearly what we need is a language where a ";)" at the end of a line makes the line into a comment.
20:49:43 <MyCatVerbs> jsnx: as a bodge, consider writing fÎ£ for "sum on Foldable instance"
20:49:45 <jsnx> because Ïƒ is used for other stuff
20:49:51 <MyCatVerbs> ?
20:50:18 <jsnx> in quantum mechanics, &c.
20:51:40 <jsnx> anyways, i hope we at least understand one another, if we don't agree
20:52:01 <jsnx> ricky_clarkson: there is a certain attraction to brevity
20:52:12 <jsnx> it's just not that attractive to me at this point
20:52:32 <jsnx> i hope scala makes headway in the webosphere
20:52:35 <ricky_clarkson> jsnx: What attracts me is saying no more than is necessary.
20:52:56 <jsnx> ricky_clarkson: i like to say no the new...and yes to the old
20:53:07 <jsnx> s/no the/no to the/
20:53:19 <sjanssen> how does the ML family disambiguate constructors and variables?
20:53:25 <ricky_clarkson> Hah, I just wrote some crap in Scala so that if I now type "hehe" at the end of the line the rest of the line isn't executed.
20:53:45 <dons> hwn up on sequence again, http://sequence.complete.org/hwn/20080105
20:53:50 <lambdabot> Title: Haskell Weekly News: January 05, 2008 | The Haskell Sequence
20:54:45 <jsnx> ricky_clarkson: lolz, your language is cool -- i hope you like it, jvm lover
20:55:09 <ivanm> dons: so when are you going to update the name of the hwn to better reflect its release schedule? :p
20:55:22 <ricky_clarkson> jsnx: I'm looking to move away from the JVM sometime.
20:55:25 <monochrom> ML doesn't disambiguate. Once you write "datatype a = whee" then whee refers to that whee everywhere.
20:55:33 <ivanm> btw, how _do_ you find all those blog posts? do you google for them, or just rely on planet.haskell?
20:55:38 <MyCatVerbs> jsnx: gah. Where on Earth did you learn to use SCIM, please? I can find plenty of information on Google on how to set it up, but bugger all on how to make use of it.
20:55:42 <jsnx> monochrom: i honestly prefer that approach
20:56:20 <ricky_clarkson> monochrom: That approach makes it less obvious which 'functions' can be pattern-matched on.
20:56:40 <sjanssen> monochrom: thanks for the info
20:56:41 <monochrom> Eh? Ha. I can still have "fun whee x = x+1" afterwards!
20:56:55 <monochrom> But afterwards, whee refers to the function. Shadowing.
20:57:07 <jsnx> monochrom: shadowing is yucky
20:57:44 <sjanssen> I suppose there are some nice examples where changes in library exports totally change the meaning of your code
21:00:30 <sjanssen> I think Haskell took the right approach
21:01:06 <jsnx> well, i think they almost did
21:01:16 <litb> hello all
21:01:35 <jsnx> if the had simply decided on an annotation, instead of upper/lower, it would be much nicer for many languages
21:01:56 <sjanssen> eh
21:02:12 <hpaste>  tehgeekmeister pasted "How do I abstract maintaing state?" at http://hpaste.org/4875
21:02:12 <litb> i've a problem
21:02:19 <litb> how can i convert from Int to Double ?
21:02:27 <monochrom> @fromIntegral
21:02:27 <lambdabot> Unknown command, try @list
21:02:33 <monochrom> @quote fromIntegral
21:02:33 <ricky_clarkson> fromIntegral
21:02:33 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
21:02:38 <sjanssen> I think if we added magic upper and lower case sigils to Haskell, we'd be set
21:02:44 <dons> ivanm: i use rss
21:02:53 <ivanm> *nod*
21:02:55 <jsnx> sjanssen: why not just a 'constructor' sigil?
21:03:05 <jsnx> sjanssen: no point in pretending it's acutally about case
21:03:28 <sjanssen> jsnx: I think most choices would add too much noise
21:03:46 <jsnx> sjanssen: what about single quote?
21:03:49 <litb>     let h  = (b - a) / fromIntegral anzahlIvl
21:03:49 <litb>     in  h
21:03:55 <litb> is that right?
21:04:07 <litb> b and a are Double, anzahlIvl is Int
21:04:15 <litb> the function returns Double
21:04:16 <monochrom> Yes
21:04:42 <litb> great, thanks
21:05:48 <jsnx> 'å­ = 'å­ 'Byte
21:06:00 <jsnx> data 'å­ = 'å­ 'Byte
21:06:03 <jsnx> that's what i meant
21:06:27 <jsnx> though you might not even need the 'data' part with the sigils
21:06:36 <sjanssen> ugly
21:06:51 <totimkopf> hi i want to learn haskell
21:06:58 <sjanssen> ' might be the best character, but I don't think it looks very nice
21:07:01 <totimkopf> i dont even know where to start, it all seems so daunting
21:07:01 <tehgeekmeister> i know i could use the state monad to abstract the manual state threading, but what's more interesting to me is making it possible to use other data structures for the state, for example a map.  I'm just using a list right now while i'm hacking it together, but in the end i really do want to use a map, and only some of the answers will need to be remembered.
21:07:04 <jsnx> sjanssen: well, that's what it'd look like in Chinese no matter what, right?
21:07:13 <ricky_clarkson> totimkopf: YAHT
21:07:17 <jsnx> sjanssen: do you have a way to fix it for Chinese speakers?
21:07:17 <sjanssen> jsnx: yep
21:07:19 <totimkopf> whats YAHT?
21:07:45 <TSC> totimkopf: Try some of the tutorials on haskell.org, like YAHT (http://en.wikibooks.org/wiki/Haskell/YAHT)
21:07:46 <lambdabot> Title: Haskell/YAHT - Wikibooks, collection of open-content textbooks
21:07:47 <tehgeekmeister> totimkopf: http://www.haskell.org/haskellwiki/Meta-tutorial has a load of good resources.
21:07:48 <lambdabot> Title: Meta-tutorial - HaskellWiki
21:07:57 <jsnx> sjanssen: please, elaborate -- assuming you can meet the requirement that they be able to reimplement everything in chinese
21:08:05 <totimkopf> cool, thank you so much :)
21:08:15 <TSC> totimkopf: Good luck!
21:08:19 <jsnx> or at least translate all the libs into chinese
21:08:33 <jsnx> and do some kind of translation back and forth
21:08:41 <jsnx> (source to source in the latter case(
21:08:49 <sjanssen> translating libs is an entirely different issue
21:08:53 <jsnx> s/\($/)/
21:09:01 <jsnx> sjanssen: your solution, then?
21:09:12 <jsnx> just do as much as you can, i guess
21:09:47 <sjanssen> okay, translation for token Just is '? where ? is the Chinese for Just
21:10:26 <monochrom> data Tå­ = Cå­ Byte.  I don't think I mind that. "C" is a way to remind me Cå­ is a constructor.
21:10:36 <jsnx> sjanssen: so chinese people have to use the sigils
21:10:47 <jsnx> sjanssen: but users of lower/upper languages do not
21:10:50 <sjanssen> jsnx: yes
21:11:14 <monochrom> Interesting.
21:11:16 <jsnx> sjanssen: of course, you can see what i don't like about that
21:11:27 <jsnx> however, there is another problem
21:11:35 <sjanssen> Haskell is *clearly* oriented towards English already, so I don't see it as a big problem
21:11:39 <jsnx> CamelCase is an abomination
21:11:49 <jsnx> and i do not want to use it
21:11:56 <sjanssen> jsnx: consider the problems with 'then''
21:11:56 <monochrom> But camelCase is optional.
21:12:12 <skew> jsnx: This is no more or less of a problem than requiring things to be identified with case already
21:12:22 <ricky_clarkson> holes_in_identifiers_are_annoying
21:12:23 * sjanssen doesn't care about the CamelCase under_score bike shed
21:12:27 <jsnx> monochrom: no, it isn't, all my type constructors have to start with uppercase letters
21:12:36 <jsnx> sjanssen: it's important in some projects
21:12:48 <sjanssen> jsnx: oh?
21:12:50 <skew> jsnx: e.g. when binding C libraries with existing case conventions
21:12:54 <monochrom> Learn Chinese. We don't need camel case. :)
21:12:58 <jsnx> sjanssen: they mandate snake_style, because it helps non-english speakers separate the identitifiers
21:13:08 <litb> hmm, if i want to do this: for each i in [1..anzahl] do value_so_far + someFunc i , with starting at 0
21:13:12 <litb> how would i do that?
21:13:14 <jsnx> skew: yes, that too
21:13:25 <ddarius> jsnx: And Snake_style fails to?
21:13:38 <jsnx> ddarius: looks like shit, does it not?
21:13:46 <skew> jsnx: you are quite welcome to use Super__Extra__Distinct__Words
21:13:54 <jsnx> ugly, though
21:14:03 <litb> i have this : foldl (+ (\i -> methode fnct (a + (fromIntegral i - 1) * h) (a + fromIntegral i * h))) 0 [1..anzahlIvl]
21:14:06 <ricky_clarkson> litb: sum $ map someFunc [1..anzahl]
21:14:07 <monochrom> litb: "do"? "value so far"?
21:14:12 <litb> but it doesn't work, since i apply too many things to (+)
21:14:20 <sjanssen> skew: you'll want to convert the names anyway, since most C libraries have prefixes that we manage with the module system instead
21:14:32 <jsnx> i guess i feel that one little sigil is worth getting rid of all those capital letters in the middle
21:14:38 <litb> (it's my try to implement a numeric integration)
21:14:43 <ricky_clarkson> > sum $ map (*2) [1..10]
21:14:46 <lambdabot>  110
21:15:04 <litb> > sum [1..5]
21:15:06 <lambdabot>  15
21:15:07 <litb> nice
21:15:13 <skew> jsnx: a little sigil -- like 'C' ?
21:15:15 <ricky_clarkson> @src sum
21:15:15 <lambdabot> sum = foldl (+) 0
21:15:22 <jsnx> and i rather hate the idea of discriminating large numbers of programmers -- chinese and indian
21:15:28 <jsnx> skew: no, '
21:15:39 <monochrom> oleg'writes'like'this
21:15:40 <litb> woo, partial application. damn that's nested in each other..
21:15:56 <sjanssen> jsnx: why care with the 'then' situation?
21:16:02 <jsnx> data 'char = 'char whatever_chars_are_made_of
21:16:10 <jsnx> sjanssen: what is the then situation
21:16:11 <jsnx> ?
21:16:12 <ricky_clarkson> litb: foldl is a function that returns a function that returns a function.
21:16:19 <sjanssen> jsnx: all keywords are English
21:16:27 <jsnx> sjanssen: that should be skinnable
21:16:31 <ricky_clarkson> litb: foldl (+) 0 is a function that takes a list.
21:16:36 <litb> i always forget that haskell supports that curring stuff natively
21:16:42 <skew> jsnx: and the word order is left to right, top to bottom, oh noes
21:16:47 <ricky_clarkson> @t foldl (+) 0
21:16:47 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:16:54 <ricky_clarkson> :t foldl (+) 0
21:16:55 <lambdabot> forall a. (Num a) => [a] -> a
21:17:00 <litb> yeah, i see. i yet have to think haskell
21:17:03 <jsnx> skew: actually, that has nothing to do with haskell
21:17:12 <jsnx> skew: the word order is one after another
21:17:34 <jsnx> i can just display it the opposite way if i'm writing hebrew or something
21:18:02 <skew> hmm, I suppose layout might still work...
21:18:08 <jsnx> skew: yes
21:18:25 <jsnx> because the spaces would show up first in the stream, even if they were to the right
21:18:28 <sjanssen> <- will point the wrong way!!
21:18:39 <jsnx> and '\n' is '\n'
21:18:55 <jsnx> sjanssen: uhm, yes
21:19:03 <jsnx> that would be weird
21:19:29 <jsnx> does not matter for chinese, though -- or japanese or urdu or whatever
21:19:44 <jsnx> so we could get more, even if we couldn't get all of them
21:19:55 <jsnx> and there are going to be lots and lots of indian and chinese programmers
21:20:09 <jsnx> (chinese can be read in any of the four directions)
21:20:33 <monochrom> Naw! No one has really done bottom-to-top yet.
21:20:33 <oerjan> litb: another alternative which might sometimes look nicer is sum [someFunc i | i <- [1..anzahl]]
21:20:59 <jsnx> there are famous poems in chinese written as blocks that can be read in any of the four directions
21:21:30 <oerjan> especially if someFunc i can be expanded right there
21:22:04 <monochrom> They are games for a few intellectuals and never been mainstream.
21:22:38 <jsnx> monochrom: yeah, but the other three directions are
21:22:43 <monochrom> Whereas top-to-bottom, left-to-right, right-to-left all had been mainstream in various periods of history.
21:22:57 <jsnx> monochrom: though most things are written l->r today
21:23:26 <jsnx> i, for one, welcome our new eastern overlords
21:23:38 <jsnx> we should make haskell pleasing to them
21:23:52 <litb> oerjan: oh, i see. that seems to be better
21:24:09 <jsnx> before we run out of crappy financial products
21:24:10 <litb> but is it also available broadly?
21:24:35 <oerjan> sure
21:30:30 <skew> jsnx: just who do you expect to object to a language requiring an arc glyph before constructor names but not a short stroke glyph?
21:31:20 <litb> hm, one question
21:31:26 <litb> what do you like more? $ or () ?
21:31:37 <ricky_clarkson> .
21:31:43 <oerjan> heh
21:31:55 <byorgey> litb: use whatever you think is more readable.
21:31:59 <litb> i mean, where should one use the one, and the other? like, () for arithmetrics, and $ for function binding or something?
21:32:25 <ricky_clarkson> > sum . map (*2) [1..10]
21:32:26 <lambdabot>  Couldn't match expected type `a -> [a1]'
21:32:48 <ricky_clarkson> > sum $ (*2) <$> [1..10]
21:32:49 <litb> yeah, my integration works :) i actually get 0.6826894921370917 for ranges froom -1 to 1 for the normal deviation
21:32:49 <lambdabot>  110
21:32:51 <byorgey> litb: IMO, you should start out using () everywhere.  Then start using $ when that gets annoying and you know what parentheses you are avoiding by using it.
21:33:39 <litb> i cee
21:33:40 <kmcallister> wait, what kind of syntax is <$>?
21:33:48 <nelhage_owl> :t <$>
21:33:49 <lambdabot> parse error on input `<$>'
21:33:51 <ricky_clarkson> litb: When you use f $ g $ stuff though, you can replace that with f . g $ stuff, afaik.
21:33:54 <byorgey> kmcallister: it's an infix operator
21:33:55 <nelhage_owl> :t (<$>)
21:33:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:33:57 <ricky_clarkson> :t (<$>)
21:33:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:33:58 <litb> is it the infix map ?
21:34:02 <byorgey> kmcallister: it's a synonym for fmap
21:34:03 <ricky_clarkson> It is.
21:34:21 <litb> thats insane :)
21:34:21 <kmcallister> ah, what module provides it?
21:34:27 <byorgey> Control.Applicative
21:34:41 <byorgey> litb: think of it as a generalization of map.
21:35:56 <oerjan> > sum $ (^2) <$> [1..10]
21:35:57 <lambdabot>  385
21:35:59 <ricky_clarkson> > map isJust $ Just 5
21:35:59 <lambdabot>  Couldn't match expected type `[Maybe a]'
21:36:04 <ricky_clarkson> > fmap isJust $ Just 5
21:36:04 <lambdabot>   add an instance declaration for (Num (Maybe a))
21:36:10 <oerjan> litb: so that gives you a third option :)
21:36:30 <byorgey> > fmap isJust $ Just Nothing
21:36:30 <hpaste>  litb pasted "nerdy stuff" at http://hpaste.org/4876
21:36:33 <lambdabot>  Just False
21:36:42 <litb> you think it's clear?
21:36:52 <ricky_clarkson> byorgey: I don't get that.
21:37:02 <byorgey> ricky_clarkson: don't get what?
21:37:07 <litb> one thing that makes it scary to me is that the type of integriere is so big
21:37:26 <byorgey> ricky_clarkson: the fmap 'lifts' isJust inside the Maybe value
21:37:39 <ricky_clarkson> byorgey: Ah.
21:37:46 <byorgey> ricky_clarkson: so fmap isJust $ Just foo  ==> Just (isJust foo)
21:37:56 <byorgey> @src Maybe fmap
21:37:57 <lambdabot> fmap _ Nothing       = Nothing
21:37:57 <lambdabot> fmap f (Just a)      = Just (f a)
21:37:58 <nelhage_owl> > liftM isJust $ Just Nothing
21:37:59 <lambdabot>  Just False
21:38:00 <ricky_clarkson> > fmap (*2) $ Just 4
21:38:01 <lambdabot>  Just 8
21:38:06 <ricky_clarkson> > fmap (*2) $ Nothing
21:38:06 <lambdabot>  Nothing
21:38:16 <byorgey> ricky_clarkson: yup, you've got it =)
21:38:23 <ricky_clarkson> Can >> or >>= do the same thing somehow?
21:38:38 <nelhage_owl> > Just Nothing >>= return . isJust
21:38:38 <litb> if i say "data MyHelperFunction = ((Double -> Double) -> Double -> Double -> Double)" is that right?
21:38:40 <lambdabot>  Just False
21:38:54 <byorgey> ricky_clarkson: sort of, yes.
21:38:54 <sjanssen> litb: no, you need a constructor name too
21:38:59 <oerjan> @src >>
21:38:59 <lambdabot> m >> k      = m >>= \_ -> k
21:39:03 <sjanssen> litb: or perhaps you mean type rather than data
21:39:13 <litb> yes, i mean a shortcut for a long type
21:39:16 <byorgey> ricky_clarkson: x >>= k = join (fmap k x), so there's an fmap involved
21:39:38 <ricky_clarkson> I see, thanks.
21:39:44 <byorgey> ricky_clarkson: so in particular, x >>= return . f is the same as fmap f x
21:40:00 <mauke> @src liftM
21:40:00 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
21:40:13 <byorgey> aka liftM =)
21:40:28 <litb> ah i see, sorry to ask that silly question dudes
21:40:34 <ricky_clarkson> Is m1 in that a monad?
21:40:39 <ricky_clarkson> :t liftM
21:40:40 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:40:49 <byorgey> litb: no such thing =)
21:41:08 <sjanssen> ricky_clarkson: it has a monadic type, yes
21:41:28 <ricky_clarkson> litb: This is a much better channel the one you're used to seeing me in.
21:41:32 <ricky_clarkson> +than
21:43:42 <litb> lolz, youre right. this seem to be very helpful :)
21:44:16 <ricky_clarkson> In x1 <- m1, if m1 was of type IO String, would x1 be the String?
21:44:47 * byorgey gives litb a golden lambda with the inscription, "welcome to #haskell"!
21:45:05 <byorgey> ricky_clarkson: yup.
21:45:23 <byorgey> ricky_clarkson: it would have type String, at least.
21:45:25 <jsnx> skew: what is an 'arc' glyph?
21:45:39 <ricky_clarkson> It seems odd that you don't write return (f (<- m1)) or something.
21:45:51 <byorgey> ricky_clarkson: it might not be "the" String since the monadic value m1 might contain no Strings, or lots of strings
21:45:51 * litb places it right beside his bed
21:46:15 <byorgey> ricky_clarkson: actually, I think that syntax has been proposed at one time or another.
21:46:34 <byorgey> it's trickier to get right than you think.
21:46:48 <jsnx> skew: my objection is to any kind of sigil in front of function names -- like i want to call a function Î£
21:47:11 <jsnx> skew: or some random chinese thing
21:49:14 <skew> jsnx: a mark is just a mark, whether it's ' or C. I don't see how something like ' is much of an improvement
21:49:27 <jsnx> skew: the C is okay
21:50:06 <jsnx> but, i rather like that you can 'pun' data and constructors
21:50:29 <jsnx> data Noses a b = Noses Int Int
21:50:34 <litb> > type Funktion Tp = Tp -> Tp
21:50:35 <lambdabot>  Parse error at "type" (column 1)
21:50:38 <litb> hmm
21:50:45 <jsnx> whereas the C seems to say 'Constructor'
21:51:01 <jsnx> and i just want a sigil to say 'not a value'
21:51:05 <byorgey> litb: that won't work in lambdabot, but that's valid Haskell
21:51:19 <mauke> litb: variables must start with a lowercase letter
21:51:28 <litb> ah, that's the solution
21:51:34 <byorgey> oh, right, what mauke said =)
21:52:19 <mauke> template<typename T> struct Funktion : Typedef<T (T)> {};
21:52:33 <byorgey> gah
21:54:05 <mauke> this assumes you already have template<typename T> struct Typedef { typedef T t; }; somewhere
21:55:32 <byorgey> mauke: I assure you that I do not.
21:55:47 <mauke> haha
21:59:47 <u_quark> hello: with Alex v.2.1.0 i don't get {-# LINE XX "lexer.x" #-} in the produced lexer.hs, in the code for the tokens... is it a bug (maybe solved in 2.2) ?
22:06:11 <litb> hm, now i want to use that integrate function , and want to integrate with at least 10^-3 , 10^-6, ... accuracy and display the result for each accuracy
22:06:58 <litb> so, i created a tuple acc=(10^(-3), 10^(-6), ....) . then i tried to loop over it, and think i should use map to do that. but i ended up with compile errors
22:07:07 <Korollary> goalieca: That was an all star goal Luongo gave up in regulation.
22:07:32 <litb> ah, wait. i have a tuple, not a list...
22:07:34 <goalieca> the trick to beating luongo... make him skate
22:07:50 <goalieca> islanders just shot every time except that once
22:25:22 <JohnDoeKyrgyz> Can anyone suggest what might be causing this error?
22:25:24 <JohnDoeKyrgyz> Cannot build superclass instance
22:25:24 <JohnDoeKyrgyz> *** Instance            : Board TicTacToe
22:25:24 <JohnDoeKyrgyz> *** Context supplied    : ()
22:25:24 <JohnDoeKyrgyz> *** Required superclass : Show TicTacToe
22:26:05 <mauke> sounds like TicTacToe isn't an instance of Show
22:26:10 <monochrom> You need to code up a Show instance for TicTacToe?
22:26:24 <monochrom> You may using "deriving" or you may hand-code it?
22:27:08 <JohnDoeKyrgyz> Here is the definition for tictactoe
22:27:10 <JohnDoeKyrgyz> newtype TicTacToe = TicTacToe (Matrix Space)
22:27:21 <JohnDoeKyrgyz> Matrix, and Space are members of show
22:28:20 <mauke> but your newtype isn't
22:28:44 <BMeph> As monochrom said, "You need to code up a Show instance for TicTacToe"
22:29:30 <JohnDoeKyrgyz> Hmn, Matrix already has a show instance. I thought that behaviour would be inherited.
22:30:18 <JohnDoeKyrgyz> instance Show a => Show (Matrix a) where
22:30:18 <JohnDoeKyrgyz>     show (Matrix x) = intersperse (map (\x -> intersperse x "|") x) hBorder
22:30:18 <JohnDoeKyrgyz>         where hBorder = "\n" ++ foldr (++) [] (replicate (length x) "--") ++ "-\n"
22:30:22 <litb> hm, when i have [ someLongFunction i | i <- [1..], someLongFunction i > 50 ] how would i do this?
22:30:26 <nelhage_owl> Part of the point of newtypes is to let you have different instance definitions for things that are structurally the same type with no performance loss, so newtypes don't inherit any instances by default
22:30:40 <litb> so that i only have to enter that function once somewhere beside that?
22:31:28 <JohnDoeKyrgyz> That makes sense, but how do I use the existing show routine for the Matrix definition for TicTacToe?
22:31:30 <monochrom> let f = blahbhah in [ f i | i <- [1..], f i > 50 ]
22:31:56 <mauke> litb: filter (> 50) . map someLongFunction $ [1 ..]
22:32:20 <mauke> [ x | i <- [1 ..], let x = f i, x > 50 ]
22:32:21 <nelhage_owl> If you're using ghc extensions, you can just add 'deriving (Show)' to the newtype declaration
22:32:23 <monochrom> oh, even better
22:32:33 <mauke> nelhage_owl: that doesn't need any extensions
22:32:37 <mauke> Show is autoderivable
22:32:39 <nelhage_owl> Oh, right
22:32:53 <nelhage_owl> If it were something other than Show (or a few others), you'd need them.
22:33:22 <skew> deriving Show for a newtype always draws it with the newtype constructor
22:33:33 <JohnDoeKyrgyz> Do I have to do something to make TicTacToe 'autoderive' show from Matrix?
22:33:52 <mauke> <monochrom> You may using "deriving" or you may hand-code it
22:35:03 <JohnDoeKyrgyz> Thanks again!
22:40:00 <litb> > 10^(-4)
22:40:09 <lambdabot>  Exception: Prelude.^: negative exponent
22:40:14 <litb> hm
22:43:04 <mauke> > 10^^(-4)
22:43:06 <lambdabot>  1.0e-4
22:43:17 <litb> ah
22:43:17 <mauke> > 10^^(-4) :: Rational
22:43:19 <lambdabot>  1%10000
22:43:30 <litb> nice
22:44:10 <pa-ching> Hmm, is it possible to alias a type constructor?
22:44:25 <pa-ching> I could just make a function, but I kinda want to keep the caps
22:44:42 <pa-ching> er, data constructor*
22:45:08 <byorgey> pa-ching: no
22:47:34 <pa-ching> Darn, I guess this change will have to leak out of the module then...
22:47:56 <pa-ching> I guess you can aoivd that by wrapping everything, but...
22:56:04 <glguy> Why must type synonyms always be fully applied?
22:56:27 <glguy> It would seem that partially applied type synonyms would solve the need for type level lambdas and parameter reordering
22:57:20 <glguy> data T a b = U a b ; type L a b = T b a     ; now   L Int can be used where a *->* is needed
22:57:45 <bos> glguy: wha?
22:58:00 <bos> something like this works fine: type Poo = State StdGen
22:58:27 <glguy> right, because the parameter was already at the end
22:58:45 <glguy> but for: SimilarToState some_monad StdGen , say
22:58:49 <glguy> there's no way
22:58:57 <bos> ah
22:58:58 <glguy> err
22:59:03 <glguy> no necessarily some_monad
22:59:08 <glguy> some_type
22:59:35 <glguy> where type P a = SimilarTo a StdGen
22:59:39 <glguy> would give the desired result
23:00:02 <glguy> hmm
23:00:05 <glguy> maybe it does then
23:00:20 <glguy> you just need a unique "type" declaration for each use
23:03:37 <skew> glguy: that would be the problem, allowing type level synonyms would give you unrestricted type lambdas
23:04:03 <skew> and make typechecking not terminate
23:11:44 <ddarius> type S f g x = f x (g x); type K a b = a
23:21:15 <dons> lovely read, 20 years on. though with only a little awkwardness in how little has changed,
23:21:19 <dons>   http://programming.reddit.com/info/64yka/details
23:21:24 <dons> "A critique of Abelson and Sussman or why calculating is better than scheming" :: PDF
23:26:48 <glguy> zomg pdf warning
23:26:51 <sclv> back to an earlier discussion, I reiterate my proposal for colorHaskell.
23:27:18 <dons> these 3 posts are just depressing,
23:27:19 <dons>  *    * C# LINQ v Python for List Processing
23:27:19 <dons>     * Python vs C# 3.0: Tuples vs. Anonymous Types
23:27:19 <dons>     * Python vs Scheme: Simple list comprehensions
23:27:28 <dons> now i know how the lisp guys feel
23:27:40 <glguy> how?
23:28:06 <glguy> old?
23:28:16 <skew> don't get all old and bitter!
23:28:17 <sclv> classes are red. type constructors are blue. infix is either green or orange depending on associativity.
23:28:33 <glguy> What is KRC?
23:28:49 <glguy> sclv: it's called syntax highlighting and it's here today!
23:29:05 <skew> Kent Recursive Calculator, apparently
23:29:07 <sarehu> what about infix type constructors?
23:29:08 <sclv> glguy: i mean instead of case conventions.
23:29:09 <dons> predecessor to haskell, influenced Orwell
23:29:11 <sclv> like colorForth.
23:29:22 <glguy> sclv: oh, that? yeah, that'd be awful
23:29:28 <dons> (wadler's pre-haskell)
23:29:33 <sarehu> And what about infix multiparameter type classes? :)
23:29:53 <glguy> sclv: when I write code out I don't want to need 4 colors of ink
23:30:06 <dons> "Some readers may object that languages like KRC or Miranda are not "credible" for teaching, because they are not used in the real world." is also kind of depressing
23:30:31 <sclv> sarehu: blend the colors!
23:30:37 <bos> meh. taking reddit seriously requires some zoloft.
23:30:56 <bos> i loved the java rant from the ada people yesterday.
23:31:04 <dons> that was awesome
23:31:05 <skew> sclv: the : convention for infix symbols also applies to typeclasses
23:31:06 <bos> "the terrorist threat requires ada!"
23:31:18 <dons> damn straight. your either with us, or ill-typed!
23:31:28 <bos> it was better than awesome. it was alsome!
23:31:37 <dons> hah
23:33:39 <litb> hm, strange thing
23:34:22 <hpaste>  litb pasted "strange" at http://hpaste.org/4877
23:34:32 <glguy> bos: link?
23:34:37 <glguy> need I just search proggramming.?
23:34:43 <bos> glguy: it's all over slashdot, programming, etc
23:34:47 <glguy> ok
23:35:04 * bos had a fun lunch with augustss today
23:35:22 <litb> it integrates for the given max blurriness fine, but when i try to integrate the sin function, it never happens that it exits the loop in intMitEpsilon
23:35:28 <bos> nice to have a few haskellers in town. i caught a glimpse of oleg and several others, too.
23:35:40 <glguy> That Defense Dept. paper dons linked to today mentioned that Ada was the language "par excellence of software engineering"
23:35:52 <litb> but when i call int directly whithout using intMitEpsilon, it just works
23:35:53 <bos> glguy: that's the one
23:36:27 <bos> ada isn't all that bad a language. it's like ML with all the functional stuff bludgeoned out and replaced with ad-hoc constructs instead.
23:36:31 <litb> so there must be something in this thing: (head (let i = (\y -> (int stdNormvtl simpsonQuadratur 0 1 y)) in [ i y | y <- [1..], abs (ref - i y) <= eps ])) that makes it never end the loo
23:36:35 <litb> p
23:36:55 <dons> ada is serious like that :)
23:37:17 <Japsu> ADA - SERIOUS BUSINESS
23:37:35 * Japsu wants Ada's numeric range subtypes in Haskell
23:38:15 <bos> Japsu: that's doable, efficiently even.
23:38:30 <sclv> same problem as with ada though: you end up with runtime checking.
23:38:42 <Japsu> bos: you mean like "type Foo is Integer range (35, 42)"?
23:38:56 <bos> Japsu: not as succinctly.
23:39:27 <bos> Japsu: but with a newtype and a rederivation of Num and Bounded, sure.
23:39:48 <sclv> someone could probably write a neat lib to encapsulate all that though.
23:40:02 <sclv> but again, what do you do when you go out of bounds?
23:40:12 <bos> you could write a bit of TH to do the code generation.
23:40:30 <Japsu> hmm, TH was what I was thinking, too
23:40:51 <bos> ada raises a constraint_error exception.
23:41:34 <sclv> right: but now that means that every numeric operation, almost, is potentially undefined
23:41:42 <sclv> which is very un-haskell.
23:42:01 <bos> the advantage with bounded subtypes being baked into the language is that the optimiser can prove that some checks don't need to be performed.
23:42:23 <sclv> ada's compiler is smart like that?
23:42:40 <bos> i'd expect so, it's a common enough thing to need to do.
23:43:13 <bos> that's the sort of thing compilers do when there's language-level enforcement of array bounds, for example.
23:44:51 <dons> i wonder if there's something in the statically-checked dimensions, or numbers, libs that get us there?   though we do have types for some of these things already (e.g. E6 E12 Fixed)
23:45:06 <dons> all done via Num instances
23:45:37 <dons> dimensional is one of the cooler haskell libs around, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dimensional-0.7.2
23:45:38 <lambdabot> http://tinyurl.com/2obfql
23:45:55 <dons> "the library is designed to, as far as is practical, enforce/encourage best practices of unit usage"
23:45:58 <dons> that's the Ada way :)
23:46:23 <dons> encourage and enforce. mm, maybe that should be haskell's slogan
23:47:03 --- mode: ChanServ set +o dons
23:47:08 --- topic: set to '["The Haskell programming language","Encourage and Enforce","http://haskell.org ","http://www.jobs-in-fp.org/","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
23:47:12 --- mode: ChanServ set -o dons
23:47:40 <bos> dons: have you looked at adam langley's Cont-based Binary hack?
23:47:47 <sclv> I came up with an idea for a statically typed data (as opposed to codata) type the other day. simple enough: just permit construction only through valid enumerations and only allow operations that produce something of the same or smaller size.
23:47:49 <bos> it's super-nice.
23:48:10 <dons> bos, yeah, looks like we might be getting something of an api together here
23:48:20 <dons> i'd like to merge it back in, esp. if he's using it for real stuff
23:48:29 <bos> dons: i'll be needing it for real stuff.
23:48:49 <bos> tcp stream reconstruction based on captured link-level packets.
23:49:01 <dons> so the main thing is strict parsing, with the ability to resume parsing?
23:49:26 <dons> i'm not sure whether this should be a separate package or not.
23:50:31 <bos> not the strictness, but the ability to resume parsing without having to restart.
23:50:52 <bos> it would be really nice to have it in the same package. it's another side of the same coin.
23:51:24 <bos> (certainly, in my case, the strictness is *nice*. i can use strict packet chunks to construct a pair of lazy tcp bytestrings..)
23:51:46 <bos> (but the lazy parser just requires a bit of extra unwrapping and rewrapping.)
23:52:17 <dons> yeah, that's a good argument - if its just going to be a different api to the underlying binary mechanism, fair enough to have both interfaces
23:53:02 <bos> right.
23:53:20 <bos> be interesting to see what effect the addition of Cont has on performance.
23:54:19 <dons> well, Cont can be inlined too (the original Binary was Cont, that got unfolded)
23:55:11 <bos> right.
23:55:33 <bos> and we've seen that judicious use of Cont can speed the use of other monads.
