00:00:26 <Philippa> you might not like thinking through C-H, but frankly that's not my problem
00:00:42 <phobes> Fair enough  :)
00:00:50 <phobes> and I definitely prefer not to think through CH
00:01:20 <darinm> phobes: why not?
00:01:35 <phobes> but I think the way typeclasses are framed contributes to some of the limitations that they don't need to have
00:01:47 <Philippa> darinm: it takes away that certainty you got from working in a pure FPL?
00:01:49 <phobes> You can't treat "evidence" like a value to be passed
00:01:55 <Philippa> yes you can, yes we do
00:02:08 <phobes> eh?
00:02:14 <darinm> huh?
00:02:29 <Philippa> and in fact the thing you accepted would be an improvement works by doing exactly that and just exposing the passing mechanism for the user to tweak with as well
00:02:29 <darinm> Philippa: I don't understand what you mean by that
00:02:49 <Philippa> darinm: about the certainty? If you think through C-H you suddenly see all the things your code doesn't actually prove about itself
00:02:58 <phobes> Philippa:  I've read something about another Haskell variant exposing something, but GHC doesn't, right?
00:03:26 <Philippa> It doesn't, no. But I just gave you an example of doing exactly that and you said it would be an improvement
00:03:29 <darinm> Philippa: oh sure, but that's not CH's problem, that's Haskell's problem.  We can all go code in Gallina (Coq) if we like :)
00:03:46 <Philippa> it's also an active area of research at the moment, exploring the intersection between module systems ala ML and type classes
00:04:09 <phobes> Philippa:  I'm not sure what we're arguing here...  Starting with something like a module system is what I have in mind
00:04:50 <phobes> You're saying I'm blaming the wrong thing and that the theory of typeclasses as relations didn't result in the current view of the compiler picking the evidence
00:04:52 <Philippa> what we're arguing about here is your insistance, over and over, that thinking about evidence is bad - despite the fact that what you have in mind is being arrived at by doing precisely that and noting that the evidence smells suspiciously like modules
00:04:58 <phobes> and I guess I doubt that
00:05:16 <Philippa> I'm telling you that the current view describes what the current compilers are doing
00:05:28 <phobes> I think that if the original view of typeclasses had been that they are choosing modules to pass, then we would have the ability to e.g. define local instances
00:05:44 <Philippa> and I'm telling you that it's been considered in the past
00:06:06 <Philippa> the original view wasn't 'modules to pass', no. But the modules're still just a form of evidence
00:06:16 <Philippa> module, dictionary, what's the difference?
00:06:30 <phobes> One viewpoint is convoluted :)
00:06:49 <darinm> too bad Mark Jones doesn't come around here...
00:06:52 <Philippa> yes. Theoretically speaking though it's the module viewpoint that's convoluted
00:07:05 <phobes> I'm sure it's not... I just think that the ubiquitous invocation of CH and category theory is often just making things more complicated than they are
00:07:11 <Philippa> and it remains that way until you start thinking about modules as evidence as well
00:07:34 <Philippa> yes. But you've said yourself you don't like thinking that way - do you think it's possible that it's your thinking about CH that's making things complicated for you?
00:07:34 <phobes> Philippa:  This all makes plenty of sense without EVER thinking of modules as evidence
00:07:41 <Philippa> phobes: no, it doesn't
00:07:55 <phobes> Philippa:  Yes, it does
00:07:57 <Philippa> the mechanism does, but why it's a sensible type system makes no sense whatsoever
00:08:18 <sarah> whats the difference between let x = y in..... and ....where x = y
00:08:25 <phobes> That CH is required for a sensible type system is another point I disagree on
00:08:40 <Philippa> go work with C++ then
00:08:44 <darinm> Things like CH and category theory often clarify important technical problems in ways that make them amenable to mathematical reasoning and proofs.  That's a pretty big deal.  That doesn't mean the result always has to be intuitive in the gut feeling sense.. heh.
00:08:59 <darinm> but I don't see really what that has to do with the argument anyway ;)
00:09:10 <phobes> Yes, because those are the only two type systems:   C++ and something from CH
00:09:24 <Philippa> no, it's worse than that: C++ is still something under CH
00:09:28 <Philippa> it's just a seriously fucked up logic
00:09:37 <darinm> heh
00:09:44 <Philippa> and that explains neatly /why/ it's such a mess
00:09:50 <phobes> It's a "logic" that looks exactly like C++
00:10:08 <Philippa> right. Which as a logic is fucked up
00:10:09 <phobes> Philippa:  I disagree with that last comment
00:10:16 <EvilTerran> sarah, nothing much
00:10:49 <phobes> Philippa:  The CH corresponence is a very elegant thing... but exactly why is it important that a type system be based on it?
00:11:03 <Philippa> you don't have a choice. You don't base it or not base it
00:11:14 <EvilTerran> sarah, in "foo ... | ...=... | ...=... | ... where {...}", the where{} bindings are visible across all the guarded branches (including in the guards themselves)
00:11:15 <Philippa> you just either think about it or not, and then realise that it tells you things about your type system
00:11:19 <phobes> and if I don't I get C++??
00:11:42 <darinm> confluence of technical results is a big deal in mathematical thinking... if you view type systems as falling within that domain, it helps to know you haven't come up with something completely ad hoc...
00:11:44 <Philippa> if you weren't thinking about it, then odds are your type system will look a mess under CH
00:11:58 <EvilTerran> darinm, what, like OOP? ;)
00:11:59 <Philippa> that /will/ correspond to it being a mess for practical purposes
00:12:11 <phobes> Philippa:  can you explain that?
00:12:19 <Philippa> which part?
00:12:26 <Philippa> messy as a logic is leaky as a type system
00:12:28 <phobes> the implication between your previous two sentences
00:12:51 <FunctorSalad> what's CH?
00:12:56 <Philippa> if it's messy as a logic it's messy as a type system, it's just that the mess shows up in different ways
00:12:57 <phobes> Who wants a water proof logic?
00:13:03 <Philippa> FunctorSalad: the Curry-Howard Isomorphism
00:13:04 <notsmack> FunctorSalad: Curry-Howard
00:13:10 <FunctorSalad> ok
00:13:11 <Philippa> phobes: an awful lot of people
00:13:17 <Cale> sarah: Basically, "let ... in ..." is part of expression syntax (and is an expression), whereas "where" is part of the declaration syntax.
00:13:18 <phobes> Writing code in coq is like pulling teeth
00:13:33 <darinm> EvilTerran: well, even OOP could have a theory, a la Cardelli :)  But the problem is that so many languages/type systems never do...
00:13:46 <Cale> (and as EvilTerran pointed out, "where" scopes over guards)
00:14:01 <Philippa> yeah. So the biggest tradeoff we make in haskell is that we fudge termination issues and allow general recursion
00:14:13 <phobes> Which is huge
00:14:16 <EvilTerran> you can also have a where{} at the end of a case/of, iirc
00:14:19 <Philippa> absolutely everything else that you can do in coq is stuff that people do in fact attempt to do in haskell
00:14:25 <phobes> and virtually requires that you have laziness
00:14:33 <Philippa> in fact, stuff that people often go to greatly painful lengths to do
00:14:38 <Cale> sarah: Each "where" clause is actually typically translated into a "let" by the compiler anyway, so they're not that different.
00:14:57 <darinm> what requires laziness?
00:14:58 <phobes> Yes, like counting in unary in the type system
00:15:03 <phobes> Which is the most god awful thing ever
00:15:20 <Philippa> this is just an "I don't like expressive type systems!" rant now
00:15:30 <phobes> On the contrary
00:15:43 <Philippa> okay, an "I don't like /current/ expressive type systems!" rant
00:15:46 <phobes> I want the type system to be just as powerful as the language I'm in
00:16:17 <darinm> so what's wrong with Coq then?
00:16:23 <Philippa> right. And really, all the sane approaches that've been found've come from this avenue of type system research
00:16:31 <phobes> Look, a core type system that forms a nice algebra like Hindley Milner is nice
00:16:52 <Philippa> have you ever tried building a type system, phobes?
00:16:55 <phobes> As soon as you start moving to dependent types, everything I've seen in "advanced type systems" is god awful and ugly
00:17:08 <Philippa> now compare it to C++
00:17:08 <phobes> As a matter of fact I'm in the middle of one :)
00:17:13 <Philippa> because that's the competition
00:17:24 <phobes> Sure, C++ sucks
00:17:58 <Philippa> and if you've got any sense, your system is going to be awful informed by CH one way or another, even if you've done it by poaching from current FPLs without paying much attention to the logic
00:18:00 <darinm> it makes sense to me that the more precise you make your types, the more difficult it will be to write programs for them
00:18:22 <darinm> if it were any other way, you'd have to question the purpose of the types
00:18:40 <phobes> Philippa:  HM is great
00:18:42 <Philippa> bitching about unary arithmetic in types is more or less irrelevant in a decent dependently-typed language
00:18:47 <phobes> Past that I wouldn't touch much of anything I've seen with a pole
00:18:56 <phobes> How so?
00:19:01 <Philippa> so what're you doing with Haskell rather than SML, huh?
00:19:08 <Philippa> because that's "past HM"
00:19:13 <Philippa> even Haskell 98 is
00:19:35 <phobes> Well, quantifiers are nice :)
00:19:52 <Philippa> because a) you want the unary for half your proofs anyway, even if it's as a view and b) it doesn't have to be implemented as unary under the hood or have unary as the only syntax
00:19:52 <phobes> ok, so I guess I mean more than HM
00:20:16 <Philippa> and if you've got a decent dependently-typed language all those things are easy to do - it's just a matter of implementation time
00:20:42 <Philippa> to put it another way, it's a library issue!
00:20:58 <phobes> Philippa:  If you have to define the Naturals twice - once as values, once as types, then it sucks
00:21:23 <Philippa> right. So you're not complaining about dependent languages, you're complaining about Haskell's present-day type system and about Omega
00:21:52 <Philippa> in fact, dependently-typed languages are precisely what that isn't a complaint about, because they're the solution to it!
00:22:54 <Philippa> you're talking precisely about when you want a type to be dependent on a value...
00:23:04 <phobes> in the last I was
00:24:12 <phobes> Dependent types that work out nicely with CH might be the best way to go
00:24:25 <Philippa> so, exactly what languages like epigram and agda are doing then
00:24:45 <Philippa> coq isn't the last word
00:24:51 <phobes> ya I know...
00:24:59 <phobes> and I haven't used epigram or agda yet
00:25:03 <phobes> though I've looked at them some
00:25:12 <darinm> well, epigram isn't exactly practical for programming anything serious
00:25:20 <darinm> as nice as an idea as it is
00:25:22 <phobes> That's the feeling I got reading about it
00:25:27 <Philippa> darinm: "are doing" on a research level at the moment, sure
00:25:54 <darinm> huh?
00:26:10 <phobes> I don't know... from my current point of view, having a fancy type system isn't that important
00:26:20 <phobes> heh, that read badly :)
00:26:24 <Philippa> epigram now is around where non-strict FPLs were about when the Haskell committee got together
00:26:44 <Philippa> that is, it's very much early days and it's one of many efforts
00:26:56 <phobes> I just mean... it's seems difficult to please these dependently typed systems
00:26:58 <darinm> Philippa: ok.  I'm not saying epigram won't improve, jus that for now it's nowhere near Coq, and probably Agda, although I haven't used the latter
00:27:07 <darinm> and Epigram2 may introduce big changes anyway
00:27:15 <darinm> if that ever sees the light of day
00:27:27 <Philippa> darinm: Epigram's more aimed at being a deep research project than Agda is, so that's no surprise
00:27:43 <Philippa> phobes: so stop telling them you're trying to be really picky?
00:27:57 <phobes> ?
00:28:00 <Philippa> granted you probably don't want to be working in a total language at the moment
00:28:21 <darinm> Philippa: sure :)  But I wouldn't recommend epigram to someone who needed to do something for which Coq would be a better choice (e.g., real programming)
00:28:21 <phobes> I definitely don't want to have to prove that my program is total
00:28:32 <Tac-Tics> Type systems are neat, but hardly a neccessity for programming
00:28:35 <Philippa> right, so don't work in a total language. Done and dusted.
00:29:07 <Philippa> darinm: not a lot of people would recommend Coq for "real programming" anyway
00:29:11 <Tac-Tics> They are really cool for things like mathematics where everything is rigidly defined and exactness is absolutely critical
00:29:31 <Philippa> Tac-Tics: we're pretty much talking under the assumption we want one already though
00:29:39 <Philippa> otherwise it's not sod off back to C++, it's sod off back to lisp
00:29:40 <phobes> Tac-Tics:  You mean dependent type systems?
00:29:40 <darinm> Philippa: fair enough ;)  Perhaps my perspective has been warped lately...
00:30:10 <Cale> > length [k | k <- [1..2008], gcd k 2008 == 1]
00:30:57 <Philippa> phobes: really, how many of your complaints about dependently-typed languages are essentially about the languages in question being total and could be solved by adding a fixpoint operator, some sugar and kissing decidable typechecking goodbye?
00:31:16 <Philippa> (note that Epigram's looking at an alternative approach for that too)
00:31:17 <phobes> Philippa:  Probably many
00:31:22 <darinm> or, just using Cayenne?
00:31:29 <Philippa> darinm: same thing
00:31:36 <darinm> Philippa: that's what I meant :)
00:31:49 <Philippa> phobes: so really, where's the grounds for complaining about CH?
00:32:40 <darinm> personally, I want my types to denote non-trivial propositions.  What would be more ideal would be to have a fragment of the language for which programs did not necessarily represent proofs, but another fragment which did
00:32:41 <phobes> Philippa:   Well, I'm saying I could probably be happy with a depedently typed language under those conditions
00:32:43 <Philippa> this sounds a lot like a combination of "but they're not doing what I want!" and complaining that people didn't have insights 20 years ago that are comparatively commonplace now
00:32:55 <darinm> perhaps using something like a provability modality or a recursion monad of some sort
00:32:56 <phobes> I have still yet to see the need to apply CH
00:33:00 <phobes> for logic
00:33:08 <Philippa> (remember that module systems weren't half as well developed then either!)
00:33:42 <Philippa> so don't. You still end up passing stuff around - CH just tells you why you have to do it
00:34:10 <darinm> phobes: without CH, Coq wouldn't make sense as a proof assistant...
00:34:25 <darinm> so it's pretty necessary there
00:34:28 <phobes> Philippa:  How would I ever figure out what to pass around without CH then?
00:34:44 <phobes> darinm:  Coq is based on CH...
00:34:45 <Philippa> don't ask me, read the original type classes paper
00:35:04 <Philippa> the question isn't "can we do stuff without?", it's "why would we want to?"
00:35:43 <darinm> phobes: yeah, you said you haven't seen the need to apply CH for logic.  Well the calculus of constructions as a basis for a theorem prover, with all of its logical goodness, doesn't make sense without CH
00:35:45 <Philippa> the logicians tend to get there first
00:36:15 <Philippa> even where they haven't directly, they tend to have a big body of useful theory
00:36:39 <Philippa> why on earth would we want to drop it? Why would we want to train ourselves to deliberately avoid thinking in a way that makes it easier to apply it?
00:37:12 <phobes> Philippa:  Is it really easier to apply?
00:37:28 <Philippa> in my experience, and that of a good many people in the field, yes
00:37:47 <Philippa> would you rather invent linear types from scratch or exploit existing work on linear logics, for example?
00:38:11 <Philippa> we already know that the core idea is "prove it's not being used any more and you can free it or overwrite it with another value"
00:38:27 <Philippa> substructural logics are exactly what you use for such proofs
00:38:58 <Philippa> well, the allocation thing's an application rather than the only reason to use 'em
00:39:10 <Philippa> they're good for things like conservation of quantities too
00:39:12 <matthew-_> has anyone adjusted Crypto to use data.binary rather than newbinary?
00:39:16 <phobes> Are substructural logics a special case of dependent type theory?
00:39:41 * roconnor thinks linear logic is for quantum computing :)
00:40:01 <Philippa> they're logics and they have corresponding type theories. As generally used they're not higher-order logics/dependent type systems because they don't need to be
00:40:18 <phobes> That's not my question
00:40:32 <phobes> I'm asking if you can model them with depednetnt type theory
00:40:49 <Philippa> no doubt, but it's more sensible to approach them directly
00:40:51 <phobes> like.. if you start with just dependent type theory, can you "embed linear logic"?
00:40:54 <phobes> ...
00:41:11 <phobes> or
00:41:16 <phobes> You start with a powerful logic to begin with
00:41:23 <darinm> so what's being argued anymore?  Is it that implementations of things coming from rich underlying theories results in weird implementations or something like that?  Or that theory is unnecessary?
00:41:24 <Philippa> "so why do I need that"?
00:41:44 <Philippa> because the next thing you know you're implementing an entirely new logic which all your programs have to be written in, so all you've done is use the more powerful logic as a metalanguage. Big whoop.
00:42:25 <Philippa> oh look, higher-order logics useful for studying logics, what a shock
00:43:18 <phobes> I think the 'leaky-ness' you're trying to avoid in finding the perfect CH based logic
00:43:31 <darinm> there is no perfect logic
00:43:35 <phobes> provides diminishing returns
00:44:09 <phobes> The thing is, once you get past the basic properties of programs like basic types
00:44:11 <Philippa> wow, pull another strawman out of your arse?
00:44:22 <Philippa> who said I'm looking for perfection?
00:44:33 <phobes> The properties that you're going to want to prove about your program will be more or less arbitrary
00:44:41 <Philippa> yep, so?
00:44:42 <darinm> eh?
00:44:53 <darinm> I disagree with that
00:45:02 <phobes> so the value of having a type system that fits together like clockwork is greatly reduced
00:45:03 <darinm> I want to prove properties of the programs I write all the time
00:45:14 <Philippa> no, it's greatly enhanced
00:45:16 <phobes> it's much better to be able to build small ad-hoc type systems in your code
00:45:30 <phobes> to check various properties
00:45:32 <Philippa> you talk about that as if it's a completely different approach
00:45:42 <Philippa> rather than just what happens as you start parameterising on more info
00:45:52 <darinm> phobes: how do you propose to verify anything with an "ad-hoc" type system?
00:45:58 <darinm> you have to clarify what verification means in that sense
00:46:02 <darinm> which is not a trivial matter
00:46:02 <Philippa> people do that with GADTs or their dependently-typed equivalents already
00:46:18 <phobes> darinm:  well, if you're in a strong system, you can always prove the ad hoc system correct
00:46:28 <darinm> what does "correct" mean?
00:46:40 <phobes> depends on the type system
00:46:45 <darinm> heh... exactly
00:46:52 <Philippa> "sound" is likely to be a good starting point
00:46:52 <phobes> the ad hoc type system
00:47:01 <Philippa> as is "consistent"
00:47:02 <darinm> so you're saying you can always build an ad hoc type system that does what you want, but it depends on the type system?
00:47:28 <Philippa> phobes: so go grab lisp already and write interpreters and compilers to your heart's content
00:47:45 <Philippa> but you already know that solution sucks, so why are you proposing it? You just want something that feels like doing this
00:47:52 <phobes> huh?
00:48:05 <phobes> How do you prove anything with lisp?
00:48:11 <Philippa> by writing a checker in it, duh
00:48:18 <phobes> How do you know the checker is right?
00:48:26 <Philippa> how do you know your better language is right?
00:48:39 <darinm> lol...
00:48:39 <phobes> 1) Start with a small and very powerful core
00:48:42 <phobes> 2) prove your way up
00:49:03 <Philippa> right. So what the hell makes you think that what you're suggesting isn't something that existing dependently-typed languages actively encourage?
00:49:11 <Philippa> it's just what happens when you write the interpreter in said language
00:49:18 <phobes> You're the one proposing that we study all of these various logics : dependent types, linear logic....
00:49:30 <Philippa> no, I'm telling you they're being studied
00:49:38 <darinm> small and powerful core... hrmm... pure type systems, calculus of constructions, etc....
00:49:43 <Philippa> you're just demanding things while claiming that they're not already possible
00:49:47 <phobes> My point is that if you can't prove the correctness of linear logic inside your dependent type system, then it's not powerful enough
00:50:10 <Philippa> Assuming that you can do so at all, of course
00:50:20 <phobes> If you can't decide "Ok, I'm going to implement a system that uses linear logic to prove it can clean things up", then you should be working in a more powerful system
00:50:28 <Philippa> thing is, we've got a pretty good idea of how to build type systems that are as powerful as the logics we have to prove things in
00:50:37 <darinm> phobes: umm, you're not distinguishing between the kind of embedding you're talking about
00:50:41 <Philippa> guess what? We jack the logics
00:50:53 <Philippa> so really what you're doing is worrying that we don't have strong enough logics
00:51:04 <Philippa> you're actually complaining that it might not be possible to write the proof *at all*
00:51:09 <darinm> most of these systems you could prove things about linear logic with a deep embedding, which is reasonable.  You can't expect a shallow embedding to always be feasible
00:51:38 <Philippa> darinm: depends how you define it. Usually the shallow embedding is just a bit of fusion away
00:51:49 <phobes> darinm:  I'm not familiar with what you mean by deep/shallow embedding
00:51:51 <Philippa> so it's a question of whether the end result's still typable
00:52:55 <roconnor> Philippa: are you suggesting that you can get from deep to shallow embedding by fusion?
00:52:55 <darinm> Philippa: yes, it depends on how you define it, but what I'm saying is that you can't expect the type system for the metalanguage to always be reflective of the object language.  There is no "perfect" metalanguage in that sense.
00:53:02 <Philippa> roconnor: I'm saying I've done it
00:53:27 <Philippa> the shallow embedding's an algebra and the deep embedding's some term algebra and an interpreter, right?
00:53:40 <roconnor> Philippa: something like that
00:53:48 <Philippa> or if you need more than just evaluation (typechecking, say), it's starting to smell a lot like a coalgebra
00:54:26 <roconnor> ok
00:54:43 <Philippa> darinm: yeah, though we've got two close shots - CIC and close relatives and something with undecidable typechecking
00:55:07 <Philippa> in the latter case, only one person actually needs to do the checking - after that you only need a proof that it was checkable, aka the typing
00:55:49 <Philippa> roconnor: that enough to work with? I've only actually done it in simple cases - implementations of a state monad, stuff like that
00:56:15 <phobes> Philippa:  Can you explain what you meant by "No, it's greatly enhanced" earlier?  I was saying that you tend to want to assert ad hoc things abour your code, so you don't necessarily need a system that fits together perfects
00:56:19 <Philippa> past a point we're starting to talking about generalising fusion to multisorted stuff
00:56:45 <roconnor> Philippa: I'm satifised for now.
00:56:45 <Philippa> phobes: if it doesn't fit together perfectly then the more stuff you try to sling together the less perfectly it fits until it doesn't actually hold together any more
00:57:04 <darinm> I don't see how you could go from a deep embedding of an object language with a linear type system to a shallow embedding of it, in a metalanguage without linear types, just by fusion.  But I don't know much about fusion :)
00:57:57 <roconnor> darinm: presumably you can use non-linear types in a linear fasion.
00:58:28 <Philippa> yeah. What you end up with is that the metalanguage doesn't "understand" linearity but it knows you've got some predicate of that name
00:58:52 <phobes> Do the dependent typed languages support subtyping?
00:59:02 <Philippa> phobes: "support"?
00:59:14 <Philippa> the usual encoding's just an embedding function from subtype to supertype
00:59:35 <Philippa> generally nobody tries to add subtyping to the core because it's a theoretical minefield - it's not worth the stress
00:59:51 <phobes> hmm
01:00:03 <Philippa> it's also not actually powerful enough
01:00:11 <Philippa> really we want to talk about more complicated relationships between our types
01:00:25 <phobes> how do you mean?
01:01:16 <Philippa> I'd quite like to be able to distinguish between terms that don't use particular subterms in them somewhere and ones that do, for example. That's "obviously" a subtyping relationship at first glance, except you can't actually encode it as one...
01:01:34 <Philippa> ...because you end up needing to restrict what parameters some of the constructors take
01:01:43 <Philippa> that's just one example
01:01:55 <phobes> can you give an example of why you'd like that?
01:02:21 <Philippa> more generally I might want to talk about "these have a similar structure but vary in properties", and "structure" might be abstracted to "support some algebra or coalgebra" for example
01:02:30 <Philippa> "is this term completely explicitly typed?"
01:02:57 <Philippa> so annotated lambdas with explicitly-typed results're okay, but the one that's a PITA to type in Haskell is function application...
01:04:19 <roconnor> Philippa: terms that don't use particular subterms seems like a very intensional predicate.  It doesn't sound like it would be preserved under beta-etc conversion.
01:05:05 <Philippa> roconnor: terms on the object level not the meta-level - on the meta-level we know more about them
01:05:25 <roconnor> oh right, lemme reread what you said
01:06:07 <roconnor> okay.
01:06:23 <Philippa> I imagine it can be done in present-day Haskell with enough encoding work
01:06:30 <Philippa> I just know it's going to be unpleasant
01:06:34 <mornfall> You got me lost. Damned.
01:07:02 <phobes> "on the object level" meaning "at type level"?
01:07:24 <Philippa> meaning that there's some datatype (family) corresponding to terms in the object language
01:07:36 <Philippa> I'm not trying to keep this info about metalanguage terms
01:08:01 <Philippa> (why yes, I do do a lot of metaprogramming - some silly LJ meme reckoned one of my new year's resolutions should be to give it up)
01:09:23 <roconnor> phobes: I understand that Philippa is talking about building some inductively defined language, and by term she ment a memer of such an inductive type, rather than a lamda term in Coq or whatever.
01:09:39 <roconnor> hopefully I got that right.
01:09:59 <Philippa> yep
01:10:20 <Philippa> more Lam "foo" (Var "foo") than \foo.foo
01:10:53 <phobes> And you're saying that the type "Contains subterm XX" is hard to define?
01:11:11 <phobes> Sounds true enough to me :)
01:11:41 <Philippa> phobes: I'm saying that "Only contains subterms of a specific form" is
01:11:50 <Philippa> suppose you've got Lam and ALam for annotated lambda...
01:12:00 <Philippa> and I want the type "all lambdas are annotated"
01:12:07 <phobes> ok
01:12:19 <Philippa> you're fine until you get to typing function application, at which point you need a type-level function isomorphic to &&
01:12:53 <Philippa> because it's only "all annotated" if both the function and the parameter are
01:13:16 <phobes> Why wouldn't this be a subtyping relation?
01:13:29 <Philippa> because it's more specific
01:13:54 <phobes> But the set of all terms built from just ALam is a subtype of the set of all terms built from either, right?
01:14:00 * roconnor doesn't even know what the rules for subtyping relations are.
01:14:01 <Philippa> it is, yes
01:14:22 <Philippa> but we don't want a separate "all annotated" version of application!
01:14:35 <roconnor> oh
01:14:40 <phobes> I see what you want
01:14:50 <Philippa> so it's subtyping under liskov substitution, but not under a simple structural subtyping rule
01:15:29 <Philippa> which means that to implement it we don't care about the logic having a notion of subtyping because we're going to end up having to supply a proof of substitutability anyway
01:16:07 <Philippa> (or more realistically, we're just going to have the constructor apply that type function)
01:16:37 <Philippa> and then in most cases we can just parameterise on that one to say we don't care if something's all annotated or not
01:17:29 <phobes> it's not just that there is some substitution, though - we want that substiution to be the natural inclusion map, right?
01:17:54 <phobes> with subtyping, you shouldn't have to specify the coercion between types
01:17:57 <Philippa> yeah, you can read a "liskov" in there again
01:18:23 <Philippa> except that if you're doing it all out explicitly you'll pretty much have to - it's just that we use overloading as a cue normally
01:19:39 <phobes> It seems to me that ideally, we'd be able to just state that the subtyping relation holds in that circumstance, and then let the theorem prover verify that it does
01:20:04 <Philippa> so you'd use something akin to type classes to fill it in
01:20:12 <Philippa> me, I just don't want to think about it as subtyping
01:20:28 <Philippa> I just want to build the damn type function and have done with it - and not get stuck messing about doing it
01:20:33 <phobes> ya, I've noticed alot of you type theory guys don't like subtyping
01:20:37 <phobes> guys/gals :)
01:21:10 <phobes> Hmm, my mind still prefers types as sets
01:21:17 <phobes> subtyping is just natural
01:21:22 <Philippa> don't you think App :: Term a -> Term b -> Term (a&&b) is easier than messing about with subtyping?
01:21:23 <phobes> as set inclusion
01:22:16 <Philippa> yeah, but by the time you've built the mechanics to do it that way it's so much easier to just have the extra functionality and then suddenly subtyping is rarely relevant
01:22:32 <Philippa> you end up doing all your subtyping via parametric polymorphism instead
01:23:04 <phobes> Ok so here's what I don't get about that view
01:23:21 <phobes> When I'm building my program
01:23:28 <phobes> I want to add constraints to types
01:23:39 <phobes> x :: Nat {(>2)}
01:23:41 <phobes> or something
01:24:08 <phobes> I don't want to have to type anything to be able to discard the {(>2)}
01:24:13 <Philippa> yeah, and it turns out that formally the syntax needs to be a little different
01:24:16 <phobes> if I need to use it as a regular Nat
01:24:26 <Philippa> yeah. So that bit's easy - you just stop passing the proof that it's >2 about
01:24:39 <phobes> ya
01:24:53 <phobes> And then when I go back, I want the compiler to pose itself a problem to solve
01:25:03 <phobes> and I still don't want to have to type anything explaining the conversion
01:25:29 <Philippa> whereas in practice you're going to have to do a bit of extra pattern matching
01:25:40 <Philippa> that's all it needs to be though - yank value from tuple
01:26:18 <phobes> well if I have f :: Nat {>2} -> Nat, and x:: Nat, and I call f x, it should infer what it needs to do, right?
01:26:24 <Philippa> you can probably, if you really have to, build some kind of typeclass that's designed to pair values and proofs about those single values and then get the value back out 'automatically' for you, but that starts to smell hacky - and what happens if the properties relate different values?
01:26:54 <Philippa> but you don't actually have Nat {>2}, you have a tuple of a Nat and the proof
01:27:10 <phobes> In your world view :)
01:27:24 <Philippa> yes. But you've yet to show that yours can be used to build a consistent language
01:27:49 <phobes> Well, I'm pretty sure it can... can you elaborate on what you think the obstruction is?
01:27:51 <Philippa> yeah, it'd be nice if all kinds of things could be sugared to hell and back
01:28:17 <Philippa> and ultimately that's what we're talking about here, no? Your language should still be translatable reasonably directly into mine?
01:28:35 <Philippa> (that is, it shouldn't feel like writing a full-blown compiler)
01:28:38 <phobes> Maybe, that's what I'm trying to figure out
01:28:56 <roconnor> phobes: in Coq we would declare f as an implicit coercion.
01:29:12 <phobes> How would that work?
01:29:33 <matthew-_> @seen dons
01:29:33 <pseudobot> dons is in #haskell. I don't know when dons last spoke.
01:29:42 <roconnor> that would be inserted automagically when you try to do things like apply a {n:nat | n > 2} to a nat.
01:29:43 <Philippa> roconnor: yeah, Coq's got a lot of features for carefully managing what's in scope in the way of coercions and notation though
01:30:32 <phobes> and that would result in a proof obligation at the call site?
01:30:44 <Philippa> no, it'd discharge one
01:30:47 <roconnor> phobes: nope
01:31:01 <Philippa> roconnor: I'll have to see how I'm getting on with it after a while, whether I reckon I've got a good enough handle on when it'll do "magic" for me and when it won't
01:31:25 <phobes> So what happens if you try to call it with n = 1?
01:31:39 <Philippa> then it sees you've got a nat and doesn't do the coercion, presumably
01:31:47 <Philippa> c'mon, you've used languages with implicit coercions before haven't you?
01:31:52 <phobes> a runtime error?
01:32:06 <roconnor> suppose we have g :: Nat -> Foo
01:32:09 <Philippa> phobes: call what, f or x?
01:32:13 <roconnor> if we do g 1, that works fine
01:32:28 <roconnor> if we do g 3, that works fine
01:32:36 <phobes> My function was f :: Nat {>2} -> Nat
01:32:38 <phobes> right?
01:32:39 <roconnor> if we do g z, that where z:Nat, that works fine
01:33:04 <Philippa> phobes: your coercion function was, yes
01:33:21 <roconnor> if do do g w, where w:{n:Nat | n > 2} then doesn't typecheck, so it tries inserting the declared coersion f, and then it is traslated to g (f w) and that works fine.
01:33:42 <roconnor> but we first need to add f to the coercion database by writing
01:33:44 <phobes> oh, that wasn't supposed to be a coercion function
01:33:45 <phobes> I see
01:33:56 <phobes> My f was supposed to be the function I wanted to call
01:33:59 <phobes> Not the coercion
01:34:01 <phobes> but I'm with you now
01:34:09 <roconnor> Coersion f :: NatGreaterThan2 >-> Nat.
01:34:14 <roconnor> or whatever
01:34:41 <phobes> Wait... you have to *write* a function to coerce Nats > 2 to Nats?
01:34:41 <phobes> o O
01:34:58 <phobes> How does this not result in mass protests?
01:35:04 <roconnor> phobes: well, in practice you would parameterize the 2.
01:35:06 <Philippa> roconnor: for my personal benefit as I start using it, how does Coq approach things if it can get somewhere with a chain of implicit coercions but not with one? Does it search to see if there's a unique chain and complain if not, not build chains or do dodgy magic?
01:35:17 <phobes> My question is the other way
01:35:37 <phobes> What do you do if you HAVE a Nat (possibly 0 or 1) and you need to call a function taking Nat > 2
01:35:56 <phobes> I'm saying the behavior I want is to infer a proof obligation at the call site
01:35:57 <Philippa> then you have to attempt to build the proof, and you can only call it if you can build that proof
01:35:58 <roconnor> Philippa: each time you add a coercion, Coq builds the transitive closure of all coercions.
01:35:58 <Pseudonym> > 1+2
01:36:08 <Pseudonym> Hrm.
01:36:15 <phobes> she's alive!
01:36:17 <phobes> or not...
01:36:22 <Pseudonym> ?botsnack
01:36:22 <pseudobot> :)
01:36:24 <roconnor> phobes: oh sorry
01:36:31 <Philippa> which in a total language will force you to handle the case where it's 0 or 1 separately
01:36:33 <Pseudonym> @type id
01:36:37 <Pseudonym> :t id
01:36:38 <pseudobot> forall a. a -> a
01:36:41 <pseudobot> forall a. a -> a
01:36:44 <Pseudonym> So it's just eval not working.
01:37:04 <phobes> Philippa:  Even if it's total... I don't want to have to write anything about it unless the compiler gets stumped
01:37:14 <Philippa> yeah, but the compiler's stumped
01:37:14 <roconnor> phobes: if you have a 0 or 1, you can not pass it to a function requiring something greater than 2 :)
01:37:19 <Philippa> it doesn't know what you want to do if it's a 0 or 1
01:37:26 <Pseudonym> pseudobot: @quot
01:37:27 <pseudobot> Igloo says: i 4m teh lambda
01:37:31 <Pseudonym> pseudobot: @quit
01:37:53 <phobes> Philippa:  As long as it introduces a proof obligation, tries to verify the subtyping, and only makes me handle semi-interesting cases before declaring that it's "stumped"
01:38:01 <Philippa> "subtyping"?
01:38:04 <Philippa> What subtyping?
01:38:36 <phobes> heh.... I'm advancing what I see as a benefit of my world view (which includes subtyping)
01:38:42 <Philippa> yeah, but it's not
01:38:50 <Philippa> what you mean is "so long as it has a good go at constructing a proof"
01:38:51 <phobes> namely, that when a function call is encountered, it can infer a proof obligation at the call site
01:39:01 <Philippa> sure, but you can do that anyway
01:39:05 <phobes> ok
01:39:19 <Philippa> you can just say "hey, type error here, you need some kind of coercion"
01:39:33 <roconnor> phobes: on the other and you can write somthing like (mkFoo 3 ()) to build something of type {n:Nat | n > 2}
01:39:37 <Philippa> and then you might use some kind of automagic tactic to go hunt for an appropriate one even
01:39:38 <phobes> And what's the mechanism for picking the natural coercion if not subtyping?
01:39:46 <roconnor> () is the proof that 3 > 2
01:39:53 <roconnor> as you can see, the proof isn't very big.
01:40:16 <roconnor> it basically hands the entire problem over to the type checker.
01:40:24 <roconnor> because the problem is decidable.
01:40:48 <Philippa> phobes: whatever the hell we like. Preferably something that's more tractable than subtyping - subtyping relationships aren't even decidable at this level
01:41:06 <phobes> Ok I think I'm missing something fundamental
01:41:20 <phobes> I have an x :: Nat, and I want to call f :: Nat > 2
01:41:27 <Philippa> which, incidentally, would be one of the big reasons "us type theory people" don't like subtyping
01:41:28 <phobes> -> something
01:41:55 <roconnor> phobes: presummable you mean call g :: Nat > 2 -> Foo
01:42:30 <phobes> Subtyping is hard, but so what?  That just means it's a hard problem... not that you get to change it
01:42:51 <Philippa> yeah. Instead we get to tell you to sod off because it's too hard, and find an alternative way of looking at the problem
01:42:52 <phobes> Subtyping is the natural relation to find when you try to call f x with x
01:42:54 <swiert> phobes: have you ever looked at Coq's Program tactic?
01:43:03 <phobes> swiert: yes
01:43:13 <phobes> I've used Coq for about 2 hours :)
01:43:16 <swiert> that sounds pretty close to what you're trying to do.
01:43:24 <Philippa> phobes: you're overloading "Subtyping" an awful lot here
01:43:40 <Philippa> what you mean is some variant of "natural injection"
01:43:44 <Philippa> this /is not the same thing/
01:44:17 <Philippa> we can't even decide if one type is a subtype of another
01:44:18 <phobes> With a set theoretic view of things, a function f : A -> B is safely callable on x :: C if C is a subset of A
01:44:22 <Philippa> let alone find the injection
01:44:35 <Philippa> yeah. Unfortunately set theoretic semantics went out of the window back at System F
01:44:38 <Philippa> they're long gone by now
01:45:07 * Pseudonym intends to play System F on his next game of Mornington Crescent
01:45:12 <phobes> Why is that?
01:45:23 <Philippa> Impredicativity, IIRC
01:45:39 <roconnor> phobes: but in your example you are giving A is the subset of C.
01:45:45 <Pseudonym> > 1+2
01:45:52 <Pseudonym> Nope.
01:45:54 <Philippa> you can do it with a sufficiently naive set theory, but then you've got paradoxes all over the place
01:46:06 <phobes> roconnor:  Yes, so you have to refine the type C that you know x to live in...
01:46:11 <Pseudonym> Hrm.
01:46:32 <phobes> Philippa:  So it was just to get rid of paradoxes?
01:46:46 <Philippa> or to put it another way, to make sure that the problem's actually decidable
01:46:51 <phobes> ZF is plenty powerful and doesn't have paradoxes that I know of
01:47:02 <phobes> Decidability is overrated
01:47:02 <Philippa> and you can't give System F semantics in ZF
01:47:06 <roconnor> phobes: what do you want to happen when we do g 0?
01:47:30 <Philippa> you're going to change your mind about that when instead of telling you it doesn't know what to do the compiler keeps crashing
01:47:33 <Philippa> and it'll do that a lot
01:47:44 <zipMe> hello, has anybody managed to build hdbc-sqlite3 with ghc 6.8.2 ? for me, it fails with : ghc-6.8.2: unrecognised flags: -F/Users/manu/Library/Frameworks
01:47:46 <phobes> um,... no
01:47:59 <phobes> Decidability = compiler crashes?
01:48:07 <phobes> undecidability*
01:48:17 <Philippa> for "sits on its arse for all eternity" values of crash, yes
01:48:33 <Philippa> or more realistically exhausts its storage and crashes that way
01:48:44 <phobes> No... the compiler will respond "cannot prove this", just like it will in your decidable system when you try to do anything useful with it
01:48:46 <Pseudonym> All computer programs stop.
01:49:02 <Philippa> phobes: no, it can't. It doesn't /know/ if it can prove it or not
01:49:10 <phobes> It has a watch
01:49:16 <Philippa> that's what "undecidability" /means/
01:49:30 <Philippa> ah. And when your typable-but-big program takes too long to compile?
01:49:52 <Philippa> the compiler shouldn't have the watch, you should
01:50:07 <phobes>  so when your compiler takes 15 days to compile but --no no, it *will* finish I can prove it, you'll be happy with that?
01:50:22 <roconnor> phobes: okay.  That is exactly what happens when we do g (mkFoo 0 ())
01:50:24 <phobes> The point is that you're going to want to give the compiler hard problems to work on
01:50:28 <phobes> and it won't solve all of them
01:50:29 <Philippa> if the compiled result was what I wanted then yeah, I might well be willing to give it 15 days
01:50:32 <phobes> This is just the way it is
01:50:44 <roconnor> phobes: Coq says that () is not of type 0 > 2.
01:50:54 <flux> philippa, really, willing to wait 15 days for one compilation?
01:51:06 <flux> philippa, even if you didn't expect for it?
01:51:13 <phobes> roconnor: sorry I've been meaning to get back to your question.   0 isn't a Nat, right - that's your point?
01:51:15 <Philippa> flux: I can picture the situation, yeah
01:51:34 <roconnor> phobes: 0 is not greater than 2.
01:51:35 <flux> "hm, I added one row, but instead of one second the compilation now appears to take hours, well I suppose it's okay"
01:51:36 <Philippa> it's unlikely that I didn't expect it, mind
01:51:40 <phobes> Philippa:  As long as it can give you a bound ahead of time, that's great... but I doubt you'd wait 15 days if it could turn into 15 years
01:51:54 <phobes> and in all actuality, 15 days will probably turn into "out of memory", not an answer
01:52:11 <flux> perhaps you could annotate the source with comments indicating that proving the following piece of code might take a lot of cpu time
01:52:14 <Philippa> you don't have a big enough HD then
01:52:15 <phobes> roconnor:  If you're trying to actually pass 0, then that's an error
01:52:32 <Philippa> run it on a 64bit system with plenty of swap and the memory's only really the same issue as time
01:53:04 <roconnor> phobes: okay.  That is exactly what happens in Coq when we do g (mkFoo 0 ())
01:53:39 <phobes> roconnor:  The issue isn't that I want to call it with a bad value... the issue is how refined do I personally have to make the types at the call site?
01:53:39 <roconnor> phobes: in practice I would make a Coq notation to shorten (mkFoo 0 ()) even further.
01:53:43 <flux> once you hit the swap in a memory-intensive problem you'll likely grind to halt, and would be happy to complete within 15 days :)
01:53:58 <Philippa> flux: depends on usage patterns
01:54:05 <flux> philippa, how about gc usage patterns?
01:54:26 <Philippa> flux: go generational GC!
01:54:38 <phobes> This is here nor there... for 99% of actual compiler usage, we're not willing to wait 15 min - forget 15 days
01:55:08 <roconnor> phobes: at the call site you have to specify the algorithm that will try to prove it for you.
01:55:15 <Philippa> phobes: hah. There's an awful lot of projects that take more than 15 minutes to complete
01:55:20 <phobes> roconnor:  I don't want to though
01:55:38 <phobes> Philippa:  Yes, I've worked on them... but incremental compilation is your friend
01:55:41 <Philippa> so you'll have to set a default instead
01:55:44 <Philippa> same difference
01:55:50 <Philippa> really, you can't escape this
01:56:09 <roconnor> phobes: we could probably make some more syntactic sugar for you.
01:56:24 <Philippa> your set theoretical approach is going to get a lot worse because you're going to be trying to sling an awful lot of infinities around
01:56:27 <phobes> The solution is obvious to me:   The compiler should deliverable runnable code ASAP, the compiler should spend idle time (while I'm editing / whatever) thinking about my code, looking for ways to prove assertions
01:56:42 <phobes> I should get feedback about what assertions / type tags have been proven
01:56:50 <phobes> The remainder should be dynamically checked
01:56:51 <Philippa> ah, you're a soft typing weenie
01:56:58 <phobes> no
01:57:01 <phobes> well sort of
01:57:10 <Philippa> an /incremental/ soft typing weenie
01:57:12 <phobes> Strong typing is great when you're at Haskell's level
01:57:31 <phobes> When you start adding annotations like "{>2}" that make the problem undecidably hard to solve
01:57:35 <phobes> Yes, then I want soft typing
01:58:03 <phobes> I definitely don't want to have to stop what I'm doing and try to play "prove it to the compiler"
01:58:19 <Philippa> but any time it can't figure it out you're going to have to anyway
01:58:22 <phobes> which will invariably just result in people commenting specific types out (or suicide)
01:58:36 <Philippa> in the meantime, work in a language that supports partial functions and don't assert things you don't mean
01:58:52 <phobes> hmmm... wasn't it you who sent me a link to your towers of hanoi solution?
01:58:56 <phobes> oh no, that was sorear
01:59:06 <phobes> suffice it to say... it was like 2-4 pages of code
01:59:37 <Philippa> this is what tactics are for, no?
01:59:40 <Pseudonym> Was it in the type system?
01:59:42 <phobes> I could look at that towers of hanoi code and prove to myself it worked (maybe not 100%), but it would be much less work than doing it in Coq
01:59:45 <phobes> He *used* tactics
02:00:05 <phobes> Proving non-trivial things in a theorem prover is a whole ton of work
02:00:14 <phobes> unless the technology improves alot
02:00:18 <Philippa> he used which tactics?
02:00:23 <phobes> Not sure
02:00:32 <phobes> His code had a bunch of them
02:00:34 <Philippa> really, I don't think after two hours you're going to know enough to assess whether it was as short as it needed to be
02:00:36 <phobes> The one that solve predicate logic
02:00:39 <phobes> some other stuff
02:00:45 <phobes> I'm surely not
02:00:53 <phobes> But sorear doesn't strike me as an idiot either
02:00:58 <FunctorSalad> you are still talking about this? :)
02:01:29 <Philippa> no, I don't think he's an idiot. I do know that the first time I have a go at something like Hanoi I'm not going to get the best possible result though because I will still be learning
02:01:50 <phobes> So the solution is to prove everything to the compiler multiple times :)
02:02:08 <Philippa> no, the solution is to stop expecting everything to work without having to learn stuff
02:02:25 <sorear> a) Philippa is right  b) I solved it *completely* - two states are connected iff they have the same number of rings
02:02:55 <sorear> a fact that even I did not know at the beginning of the excersize
02:03:12 <phobes> Philippa is right about what?
02:03:20 <Philippa> hmm. Yeah, I didn't know that either though it doesn't surprise me
02:03:39 <phobes> I don't really understand how you can think that strong typing everything is a good idea
02:04:15 <phobes> That means that you can't add an extra assertion locally - you have to propogate proof around your code saying that local assertion holds
02:04:49 <Philippa> and I don't understand how you can think that it's such a bad one that you're willing to slate anything that tries it /even though everything you're doing is based on the work in it/ - all you're doing is requesting to work in a partial language and use undecidable algorithms
02:04:50 <phobes> Since you can't possibly assert every provable property about your code
02:05:38 <Philippa> people used to say the same thing about propagating the kind of type changes we let H-M resolve for us. Suffice to say that Coq isn't where I want things to stop
02:05:58 <roconnor> phobes: what do you mean add an exrta assertion?
02:06:03 <Philippa> and that having stuff propagate automatically is exactly what happens when you start thinking about letting the computer build some of your proof for you
02:06:09 <Philippa> roconnor: suddenly requiring an extra property
02:06:18 <Philippa> presumably one that can't be proved from the ones you've got
02:06:22 <phobes> roconnor: ... like ... adding to the type of 'sort' to indicate that the result is sorted
02:06:24 <phobes> any property
02:06:35 <Philippa> but you can do that
02:06:36 <Pseudonym> Hang on here.  A program is "type correct" if my favourite type checker accepts it!  Everyone knows that!
02:06:38 <phobes> though that one would be local
02:06:51 <Philippa> the problems are properties you need proven going in
02:06:53 <Pseudonym> Philippa speaks heresy!
02:06:56 <phobes> ya
02:07:03 <phobes> Philippa: you're right
02:07:05 <roconnor> phobes: in Coq a lot of assertions are added externally.
02:07:23 <roconnor> phobes: say you have f :: Foo -> list Nat
02:07:34 <roconnor> then you prove that f produces a sorted list.
02:07:39 <roconnor> this proof is external to f.
02:07:49 <phobes> ya
02:08:02 <roconnor> and then in those places you care, you use the external proof.
02:08:07 <phobes> The problem is when the thing that uses f's result needs a sorted list
02:08:12 <phobes> and you haven't proved that f sorts it yet
02:08:27 <roconnor> the external proof has a name
02:08:39 <roconnor> fIsSorted : forall x, sorted (f x)
02:09:08 <phobes> The thing is that as you increase the level of complexity of your assertions
02:09:17 <phobes> The amount of code you spend trying to prove them increases alot
02:09:33 <phobes> And that results in more code to maintain
02:10:02 <phobes> Size will make your code brittle
02:10:24 <phobes> You don't want to have to scrap a bunch of proof work you've done when assumptions change, etc
02:10:29 <Philippa> the counter to which is to try to work abstractly when you prove things
02:10:38 <Philippa> that'd be all that category theory you were complaining about, no?
02:10:45 <phobes> no :)
02:11:08 <Philippa> don't require more than you need. If necessary, work by isomorphism or injection. Etc etc
02:11:11 <roconnor> phobes: proofs by high level tactics are surprisingly robost.
02:11:44 <phobes> roconnor:  What percentage of your code is actually runnable instructions?  in Haskell?  in Coq?
02:11:55 <Syzygy-> Abstract nonsense ftw!
02:12:01 * Syzygy- feels constructive today. ;)
02:12:07 <phobes> Abstract nonsense wtf!
02:12:09 <roconnor> phobes: a small amount.
02:12:28 <phobes> really?
02:12:33 <phobes> oh, no I agree
02:12:39 <phobes> Much smaller in Coq than Haskell, right?
02:12:45 <roconnor> sure.
02:12:46 <phobes> Haskell is > 50% runnable code almost always
02:12:55 <Philippa> phobes: before or after counting tests?
02:12:57 <phobes> Coq is like... 25%?  if you're lucky?
02:13:02 <roconnor> if I had to guess i'd say about 10% in Coq
02:13:23 <Philippa> like for like, the Coq code does more than the Haskell
02:13:25 <phobes> Philippa:  I suppose that's a good point... count the tests against the proofs
02:13:58 <phobes> Phillipa:  I think you have to be careful how you word that... you can do a heck of alot more with 1000 lines of haskell, than with 1000 lines of coq, I'd gather
02:14:02 <phobes> I'd guess*
02:14:28 <Philippa> depends on the 1000 lines. Haskell doesn't have tactics.
02:14:45 <phobes> tactics don't result in runnable code do they?
02:14:52 <Pseudonym> > 1
02:14:52 <roconnor> I'm saying 10% of what I write
02:15:00 <Pseudonym> ?botsnack
02:15:01 <pseudobot> :)
02:15:04 <Philippa> depends on the tactic and on your value of "runnable"
02:15:04 <Pseudonym> Hmm.
02:15:05 <roconnor> the lambda terms of the generated proofs are HUGE
02:15:06 <Pseudonym> Well, I dunno.
02:15:17 <phobes> Do you frequently ask Coq to find me any function of a given type so I can run it?
02:15:49 <Philippa> a specific tactic can do more than just "any", no?
02:15:57 <roconnor> phobes: I don't think I understand the question.
02:15:59 <phobes> sure
02:16:11 <phobes> So do you do that much?
02:16:17 <phobes> Implement this for me: here's a type?
02:16:33 <phobes> (I'm honestly asking... because my impression is that you write the code, and then ask Coq to verify that it works)
02:16:41 <Philippa> currently I don't use Coq much. I do an awful lot of filling out pattern-match skeletons in Haskell that're obvious from the types though
02:17:07 <Philippa> that's trivially "gimme the skeleton and I'll fill in the blanks/goals" stuff
02:17:08 <phobes> I realize that the line between what's the code and the proof is blurred under CH, but I think that it's generally true
02:17:09 <roconnor> phobes: you want it automatically generate a function Nat -> Nat?
02:17:23 <phobes> roconnor:  My point is that it wouldnt' be interesting to get it to do that
02:17:46 <roconnor> phobes: I can say `auto', and it will build such a function.
02:17:48 <phobes> There are examples of "theorems that prove themselves", but I'd think those functions would usually be small & easy to write anyway
02:17:59 <Philippa> but telling it "I'd like to eliminate this by induction" /is/ interesting - getting it for free is one of the nice things about Epigram's IDE, for example
02:18:06 <Philippa> phobes: you do realise that tactics compose, right?
02:18:12 <phobes> sure
02:18:38 <phobes> You know what I mean by the distinction between the code proper and its proof of correctness, right?
02:18:45 <Philippa> yes, I do
02:18:46 <phobes> The code proper corresponding to what actually executes
02:18:54 <roconnor> sure
02:18:57 <Philippa> those things that aren't irrelevant at runtime
02:18:58 <phobes> for some choice of "actually" and "executes"
02:19:03 <phobes> ok
02:19:17 <roconnor> code belongs to types that have more than 1 member.
02:19:23 <phobes> so I think it's fair to say that Coq will have more non-executing code than Haskell
02:19:35 <phobes> by a good margin probably, depending on what you try to prove
02:19:44 <phobes> The more you try to prove, the worse your ratio gets
02:19:55 <roconnor> and the more reliable your code gets
02:20:04 <phobes> not necessarily
02:20:16 <Philippa> then why did you waste time proving it?
02:20:29 <phobes> Because you're in a strongly typed language
02:20:32 <Philippa> and no, that's not a generic you
02:20:38 <Philippa> you mean more than "strongly typed" here
02:20:53 <Philippa> and guess what? Termination's a reliability issue
02:21:03 <roconnor> phobes: you can write code without proofs (like Haskell) in Coq for the most part
02:21:09 <phobes> No, you will end up proving things you don't want if you go down the strongly typed path with dependent types
02:21:17 <roconnor> the only big difference is that Coq doesn't have general recursion.
02:21:37 <phobes> roconnor:  But once you've asserted something in one place, you either have to prove it, or remove the assertion
02:21:42 <Philippa> phobes: wrong. You need to add "total" to that statement to even start being right, and even then it's "didn't realise I wanted"
02:21:58 <roconnor> phobes: or you can add an axiom.
02:22:05 <roconnor> and forget about it.
02:22:18 <phobes> axiom = weak type system :)
02:22:23 <swiert> roconnor: or introduce it using coinduction :)
02:22:27 <phobes> which is close to what I want, but I want it a little more autmoatic than that
02:22:40 <Philippa> yes. So go write the IDE to do it for you?
02:22:45 <phobes> Philippa:  Ya, I mean total
02:23:03 <Philippa> and do us a favour and at least rant about the right damn targets?
02:23:15 <phobes> hehe
02:23:27 <phobes> Well, I'm not sold on CH
02:23:43 <phobes> I'm not sold on dropping Sets
02:24:01 <Philippa> no, but your arguments against it are mostly a bunch of "wah, don't like!" coupled with a way of thinking that /still works under CH/ - it's just that you get told about your problems
02:24:08 <Philippa> but you're clearly not using ZF sets
02:24:20 <roconnor> phobes: well, you are certainly not alone in your opinions.
02:24:54 <Philippa> your complaint isn't really with CH, it's with being asked to drop general recursion and the like
02:25:05 <phobes> Philippa:  My problem with CH is that I think it's a distraction.  Just choose a strong logic to reason about your program and be done with it
02:25:17 <roconnor> swiert: introduce what using coinduction?
02:25:31 <Philippa> phobes: fine, go do so
02:25:42 <swiert> roconnor: general recursion.
02:25:44 <Philippa> the rest of us have better things to do than write our own compiler in the logic before doing anything
02:26:16 <swiert> roconnor: a la Bove-Capretta/Altenkirch-Capretta-Uustalu.
02:26:25 <phobes> Right... Haskell doesn't have a proof, right?
02:26:29 <phobes> GHC*
02:26:30 <roconnor> swiert: typically we induct on nat, and start if off with 10^100.
02:26:33 <Philippa> because that's what you're going to have to do - embed the semantics of your programming language in the logic
02:26:44 <phobes> Philippa: Yes, I realize
02:26:50 <Philippa> phobes: there's no formal semantics for Haskell
02:26:56 <Philippa> not even for Haskell 98
02:27:08 <phobes> Right, which is fine with em
02:27:10 <phobes> me
02:27:22 <Philippa> yeah. So what the hell kind of proof are you going to do, anyway?
02:27:36 <phobes> I'm not doing the proof at all
02:27:57 <roconnor> phobes: have you looked at minlog?
02:28:05 <roconnor> I don't think it is C-H.
02:28:21 <roconnor> but I don't recall for sure.
02:28:35 <Philippa> phobes: so stop complaining about the tools for doing proofs already?
02:28:47 <Philippa> your complaint isn't C-H. It isn't the tools. It's that you just don't want that in the first place.
02:29:01 <Philippa> so fine, don't. And stop telling the rest of us how to do them.
02:29:31 <phobes> Philippa:   What I want is the ability to do computations at the type level without engaging in superflous theorem proving or category theory
02:30:03 <Philippa> so use a partial language and STFU
02:30:15 <phobes> What partial language would you recommend?
02:30:25 <Philippa> well, we're sitting in #haskell...
02:30:28 <roconnor> Epigram?
02:30:38 <phobes> ...
02:30:39 <roconnor> Does Agda have general recursion?
02:30:48 <phobes> haskell does not have type level computation
02:30:57 <Philippa> yes it does, it just sucks
02:30:59 <phobes> * general
02:31:03 <phobes> general type level computation
02:31:09 <Philippa> yes it does, use the right flags
02:31:20 <Philippa> roconnor: I believe so, but I've not checked closely enough
02:31:24 <phobes> I want one version of Nat :)
02:31:47 <Philippa> look at Agda, anyway
02:31:57 <Philippa> in the worst case, build it yourself or pay someone else to
02:32:03 <Philippa> it's not our job to magically supply what you want
02:32:12 <roconnor> phobes: what do you mean one version of Nat?
02:32:17 <phobes> Philippa:  I didn't think I was filing a feature request
02:32:40 <Philippa> no, you were "filing" a big "wah, you all suck because I don't have this!" demand
02:33:11 <phobes> Philippa:  I apologize if you find this type of conversation tedious and annoying... You always give me alot of information so I enjoy talking about what I think I want and listen to you tell me why I really don't want that
02:33:12 <Philippa> you're making a pile of invalid attacks on the theory used to build the tools you want because the precise tool you want isn't in your hands
02:33:33 <phobes> "You all suck" was not implied
02:34:05 <Philippa> fine, excuse me for reading that into "all your work sucks!"
02:34:50 <phobes> Well, apologies then... for that was also not intended
02:35:00 <Philippa> "I don't get it" is fine, FWIW. There's plenty I don't get
02:35:02 <roconnor> phobes: as I understand it is that a dependent type theory supporting general recursion will work for you.
02:35:28 <phobes> You keep throwing "go use C++ at me" when I've clearly stated that I think Haskell is a vastly superior langauge
02:36:09 <Philippa> I did that a couple of times, yeah. Largely to point out that a good deal of the reasons for Haskell's superiority stem from exactly what you were attacking
02:36:26 <Philippa> you can reason about it, and that property is not an accident
02:36:44 <Philippa> you can keep reasoning about code that uses odd type system features, and that is also not an accident
02:36:59 <phobes> and I think that's because of the conscious people working on it
02:37:04 <phobes> not because of CH
02:37:17 <dibblego> who is CH?
02:37:21 <Syzygy-> Curry-Howard
02:37:26 <dibblego> ah those blokes
02:37:44 <Philippa> only an awful lot of those people pay attention to the Curry-Howard Isomorphism and use it to inform their work. Are you telling them that you understand what goes into their work better than they do?
02:38:47 <phobes> I'm saying that I don't see it, and thankfully have someone knowledgable to discuss it with
02:38:55 <phobes> I'm not saying you're wrong
02:39:08 <Philippa> you spent quite a lot of time saying more or less exactly that
02:39:10 <phobes> and I don't understand CH really deeply
02:39:23 <Philippa> at one point you specifically said that CH had misdirected research
02:39:36 <phobes> Yes
02:39:49 <phobes> Let me find the quote sec
02:40:00 <Philippa> I don't need to see it again, I've got logs
02:40:03 <Sizur> @users
02:40:03 <pseudobot> Maximum users seen in #haskell: 365, currently: 365 (100.0%), active: 8 (2.2%)
02:40:19 <phobes> "My problem with CH is that I think it's a distraction.  Just choose a strong logic to reason about your program and be done with it"
02:40:45 <roconnor> I belive Schwichtenberg has studied and rejected CH.
02:40:55 <phobes> heh
02:40:59 <Philippa> but that doesn't tell type theorists anything about how to design type systems
02:41:16 <Philippa> so you might not care about CH as a programmer, but so what?
02:41:26 <Philippa> you don't care about formally reasoning about your programs either
02:42:03 <phobes> I do... I just don't think it's going to be practical to reason about all aspects of them
02:42:03 <roconnor> oh right phobes isn't intrested in formal reasoning.
02:42:39 <Philippa> so don't, and stop using it as a strawman
02:42:57 <Sizur> CH?
02:43:07 <dibblego> Curry-Howard
02:43:10 <phobes> Well, I've advanced an argument that I don't really understand your reply to
02:43:13 <dibblego> them clever blokes
02:43:28 <phobes> and apparently I haven't couched everything I've said in enough "I know I don't know what I'm talking about, but..."
02:43:41 <Philippa> I don't think you've advanced much of an argument as to why CH supposedly misleads people researching type systems
02:43:55 <phobes> No I haven't
02:43:56 <Philippa> you've advanced plenty of argument about why you personally don't want to use a total language
02:44:12 <Philippa> but I don't much care if you don't
02:44:34 <Philippa> okay, but you haven't retracted the claim either
02:44:42 <phobes> which claim?
02:44:49 <phobes> About CH ?
02:44:51 <Philippa> that CH misleads type system researchers
02:45:11 <phobes> I think CH is very elegant
02:45:24 <phobes> and maybe it leads to great type systems
02:45:27 <Philippa> you also, incidentally, haven't given any reason to believe that your problem is anything other than being expected to work in a total language - which nobody is asking of you
02:45:59 <Philippa> you made a specific accusation regarding type classes, btw
02:46:26 <Sizur> why do we have skirmishes on the 2nd of new year? soften up guys
02:46:26 <phobes> which I believe you more or less agreed with once you understood it
02:46:29 <Philippa> one which ignores the fact that our understanding of module systems wasn't actually good enough at the time to take the view you propose
02:46:30 <Philippa> no, I didn't
02:46:34 <phobes> Granted, I phrased it a bit brashly at first
02:46:39 <Philippa> I agreed that type classes aren't the final word
02:46:55 <Philippa> I agreed that there's a direction to move in
02:47:09 <swiert> @seen mattam
02:47:10 <pseudobot> mattam is in #haskell. I don't know when mattam last spoke.
02:47:13 <Philippa> I fundamentally *disagreed* with your saying that CH was responsible for us not having it already
02:47:19 <phobes> "One which ignores the fact that our understanding wasn't good enough..."
02:47:23 <phobes> What is that?
02:47:34 <phobes> I'm not attacking you
02:47:50 <phobes> If you think the system isn't perfect, then why take "the system isn't perfect" as a personal attack?
02:48:03 <phobes> I didn't say anyone did a piss poor job 20 years ago
02:48:12 <Philippa> you more or less did
02:48:24 <Philippa> in that you said we didn't have it sooner because people were talking about "evidence passing"
02:48:28 <phobes> No, you interpretted it that way
02:48:34 <Philippa> you said the entire model as developed was responsible for holding things back
02:48:45 <vincenz> Which model?
02:49:00 <phobes> Yes, I do beleive that the CH view of evidence passing for type classes lead to a worse system
02:49:13 <phobes> than one would arrive at if he just followed the natural view of modules
02:49:31 <therp> excuse me, what's CH?
02:49:35 <phobes> Curry howard :)
02:49:36 <Philippa> which is an attack on those who took that route
02:49:38 <Sizur> it's a process of discovery, you'll always have branching
02:49:42 <therp> thnx :)
02:49:54 <dibblego> @let ch = "Curry-Howard"
02:50:01 <pseudobot> Plugin `eval' failed with: Data.ByteString.last: empty ByteString
02:50:06 <dibblego> pfft
02:50:15 <Taejo> @src (>>=) State
02:50:15 <pseudobot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
02:50:18 <Philippa> and it's /wrong/. The natural approach you're talking about still exhibits evidence passing, it just calls the evidence "modules" instead of "dictionaries"
02:50:19 <vincenz> donde esta lambdabot?
02:50:20 <phobes> Philippa:  Ok, I didn't intend it that way, but I understand this is your work
02:50:21 <Taejo> @src State (>>=)
02:50:22 <pseudobot> Source not found. This mission is too important for me to allow you to jeopardize it.
02:50:39 <vincenz> > 1
02:50:51 <phobes> Philippa:  It's possible to do typeclasses in a very natural way without ever considering evidence
02:51:02 <Philippa> what you're actually complaining about is that someone didn't, 20 years ago, look at a record of functions that they were calling a dictionary and go "look, modules!"
02:51:10 <Philippa> yes, you can just change the labels
02:51:10 <phobes> lol no I'm not
02:51:24 <Philippa> that's part of what an isomorphism means - you've got two names for everything
02:51:27 <FunctorSalad> goa complains "no lambdabot process" - how can I start one such that goa sees it?
02:51:36 <Pseudonym> BTW, it's likely that @src simply doesn't work.
02:51:42 <Philippa> but that's not the relevant question
02:51:55 <Pseudonym> Like @eval and @let.
02:52:12 <idnar> @undefine
02:52:13 <Philippa> the question is: would it have all been discovered and developed faster by not using the isomorphism to aid reasoning?
02:52:17 <pseudobot> Plugin `eval' failed with: Data.ByteString.last: empty ByteString
02:52:26 <idnar> doh
02:52:30 <Philippa> anything else is just complaining about how it's presented to users
02:52:47 <FunctorSalad> @botsnack cookie
02:52:47 <pseudobot> :)
02:52:49 <phobes> Ok, Philippa, clearly I need to tone down my claims / attitude... I really do apologize - I hope you'll understand I really am more excited about trying to understand how things "ought to be" than out to disparage how it's been done
02:53:04 <dolio> @src foldr
02:53:04 <pseudobot> foldr k z xs = go xs
02:53:04 <pseudobot>     where go []     = z
02:53:04 <pseudobot>           go (y:ys) = y `k` go ys
02:53:17 <Philippa> yeah. It makes you too keen to state that things "oughtn't be" how they are though
02:53:35 <Philippa> rather, you turn not understanding things into "that oughtn't be!"
02:53:54 <phobes> yes, I do do that, sometimes intentionally just to get an argument
02:54:07 <Philippa> yeah. This is called trolling, don't be surprised if it gets your arse kicked once in a while
02:54:20 <phobes> well, I don't stick to it
02:54:31 <phobes> Really just overstate my case a little and then fall back to what I believe
02:54:45 <phobes> and usually it's not on purpose
02:54:47 <Philippa> mmm. It would help if you retracted things on the way back
02:54:58 <phobes> I usually do
02:55:07 <phobes> "I've overstated that a bit", etc
02:55:36 <Philippa> yeah, sometimes you're understating the retractions
02:55:41 <phobes> hehe
02:55:57 <Philippa> btw, you can keep your set theory on one condition: you acknowledge that you're working with naive set theory with all its pitfalls
02:56:17 <phobes> I don't want naive set theory...
02:56:28 <phobes> The system needs to be consistent obviously :)
02:56:29 <Philippa> then you don't want a partial language either
02:56:36 <phobes> eh?
02:56:53 <Philippa> partial languages encode paradoxes
02:57:01 <phobes> under CH :)
02:57:08 <phobes> which is a big distraction remember :)
02:57:15 <roconnor> phobes: what type should fix id have?
02:57:18 <Philippa> yeah, but all you're trying to do is work with a logic you've assigned set-theoretic semantics to
02:57:39 <roconnor> or what set should fix id have?
02:57:47 <roconnor> @type fix id
02:57:53 <pseudobot> forall a. a
02:57:57 <phobes> Why does everything have to have a type?
02:58:05 <phobes> There are the things you can prove, and the things you can't
02:58:18 <Philippa> because otherwise the type system crashes the moment it meets that something
02:58:25 <Philippa> however, the type doesn't have to mean much
02:58:33 <Philippa> it can just be exists x.x or something
02:58:54 <JaffaCake> morning all, and happy new year
02:59:03 <roconnor> phobes: okay
02:59:08 <phobes> The thing about having a strong ambient logic is that you don't have to be perfectly tidy with your type system
02:59:11 <Philippa> likewise! I take it you survived Hangover Day?
02:59:19 <JaffaCake> aye
02:59:26 <phobes> If your types don't line up exactly right, you just push a proof obligation to the ambient logic
02:59:38 <Philippa> phobes: you're back to partiality again
02:59:50 <Philippa> as soon as you allow that, it doesn't matter
02:59:56 <phobes> eh?
03:00:00 <roconnor> phobes: wait.  do program expression have types or not?
03:00:08 <phobes> roconnor:  Yes
03:00:11 <roconnor> okay
03:00:16 <roconnor> then what type does fix id have?
03:00:24 <phobes> What type does fix have?
03:00:29 <roconnor> @type fix
03:00:34 <phobes> she's gone
03:00:35 <pseudobot> forall a. (a -> a) -> a
03:00:36 <vincenz> (a -> a) ->
03:00:39 <vincenz> a
03:01:01 <Philippa> I was actually asleep when I was supposed to be preparing the hangover, so yesterday was no problem
03:01:07 <phobes> looks like forall a. a :)
03:01:13 <phobes> Here's the problem
03:01:24 <phobes> Fix doesn't actually have type  (forall a. (a->a) ->a)
03:01:39 <Philippa> though I probably shouldn't have been so amused at one friend having his first ever hangover yesterday
03:01:40 <phobes> It has something like ... forall a.  (a -> a*) -> a*
03:01:52 <phobes> where a* is a union {_|_}
03:02:00 * Philippa thinks phobes is discovering intersection types
03:02:22 <Philippa> but you're just complaining that you could give it a more precise type
03:02:29 <Philippa> in haskell, all types already have a _|_
03:02:43 <dolio> Ahh. First hangovers.
03:02:59 <Philippa> yeah. Best experienced when you're not due on a bus at 11am
03:03:06 <dolio> Heh.
03:03:17 <dolio> I had my first hangover on parents' day at my college.
03:03:24 <dolio> And my parents were visiting.
03:03:27 <phobes> Phillipa:  Well, forall a. a is only inhabitted by _|_ in haskell, so what's the problem?
03:03:41 <phobes> I only clarified because in my language it wouldn't be inhabitted at all
03:03:54 * vincenz wonders if this has anything to do with codata
03:04:11 * vincenz skips out to lunch
03:04:16 <phobes> "there is no value that belongs to every set"
03:04:19 <roconnor> phobes: so you want to have a type langage with general recursion for your code, and then a parallel logic system for reasoning about the code.
03:04:38 <Philippa> phobes: you can't really ask "what type does foo have?" without specifying a language/type system though
03:04:38 <Taejo> @src replicateM
03:04:39 <pseudobot> replicateM n x = sequence (replicate n x)
03:04:54 <phobes> The point is that you specify the type system in the language
03:05:02 <phobes> and have a strong ambient logic to prove it correct
03:05:18 <phobes> where "correct" is specified... in the language!
03:05:28 <phobes> or in the logic
03:05:37 <Philippa> so really you don't actually have a type system
03:05:42 <Philippa> you just have the chance to build one
03:05:56 <phobes> Something like that
03:06:15 <roconnor> phobes: so you want an untyped language with a parallel logic for reasoning about it?
03:06:28 <phobes> No :)
03:06:39 <phobes> You're getting warmer though :)
03:06:41 <roconnor> phobes: I'm finding it hard to understand what you want :)
03:06:44 <Philippa> which ultimately is a lot like having a parameterised type system, no? Something akin to Pure Type Systems but with weaker theoretical properties
03:07:01 <phobes> weaker theoretical properties, but stronger proofing ability
03:07:13 <phobes> law of the excluded middle holds
03:07:15 <Philippa> "stronger proofing ability"?
03:07:42 <Philippa> rather, you'll do your proofs about it in something else where it holds
03:07:52 <phobes> huh?
03:07:56 <Philippa> nothing stopping you doing a metatheoretical study using classical logic as your metalanguage, after all
03:08:16 <Philippa> or are you saying that the law of the excluded middle will hold in the logics isomorphic to all the type systems?
03:08:29 <roconnor> ``weaker theoretical properties, but stronger proofing ability'' was that supposed to be a description of what you want?
03:08:45 <phobes> Philippa:  I'm not even going to study other logics associated to type systems
03:09:06 <Philippa> so you do indeed mean in the metalanguage you're using to do your proof of correctness
03:09:21 <phobes> Yes
03:09:47 <Philippa> the comment about theoretical properties was about the structure you're using to build the type systems
03:10:05 <phobes> oh ok
03:10:11 <Philippa> PTSes have a whole pile of common properties
03:10:22 <Philippa> sounds like you're not familiar with them?
03:10:31 <phobes> I've heard of them , but going blank
03:10:43 <Philippa> they're a bit like "build your own type system"
03:10:59 <phobes> Sounds right
03:11:01 <Philippa> if you know of the lambda cube, they're a generalisation of it
03:11:11 <phobes> Yes, I've been to this webpage about them before
03:11:17 <phobes> so I've read something
03:12:17 <Philippa> presumably you've got a fixed term language
03:12:18 <Philippa> ?
03:12:30 <phobes> for the logic?
03:12:30 <Sizur> here's a better idea: let's drink coffee
03:12:32 <Philippa> otherwise you're not just building a type system
03:12:46 <Philippa> no, for the object language - the one you write programs in
03:12:58 <roconnor> Sizur: c|_|
03:13:01 <roconnor> er
03:13:06 <roconnor> Sizur: |_P
03:13:22 <Sizur> hehe, both work with my font
03:13:24 <phobes> sure, we can assume there's some object language
03:13:38 <phobes> in theory you can axiomitize your local assembly language... but I wouldn't want to try
03:13:54 <roconnor> phobes: it's been done.
03:14:05 <phobes> probably not for a modern processor :)
03:14:18 <roconnor> didn't adam do something like that?
03:14:25 <phobes> was it multi-core?
03:14:39 <roconnor> phobes: presumably only a subset of instructions were axiomatized.
03:14:45 <phobes> ya
03:14:57 <roconnor> anyhow go on
03:15:05 <roconnor> I'm totally lost at this point anyways :P
03:15:50 <Sizur> let me recap: CH, logics, self-made types systems, coffee
03:16:10 <phobes> Anyway, so it sounds like Philippa is telling me that what will go wrong is that:  1)  The ad hoc type systems I build in the language will not be as clean as what I'd get by studying CH, and 2) ...
03:18:21 <roconnor> I don't even know what an ad hoc type system is :)
03:18:25 <hpaste>  taejo pasted "how do I use the State monad?" at http://hpaste.org/4759
03:18:46 <phobes> ad hoc meaning you just write down the rules
03:18:51 <phobes> and prove them correct
03:19:10 <Taejo> what is the first argument to runState? see paste
03:19:12 <roconnor> how can rules be correct or incorrect?
03:19:36 <phobes> If types represent sets, then subtyping must correspond to inclusion, etc.
03:20:26 <roconnor> phobes: and type membership is set membership?
03:20:48 <phobes> If you just view type checking as some arbitrary computation
03:21:00 <phobes> Then they could represent anything
03:21:10 <roconnor> okay, so type membershp isn't set membership.
03:21:29 <Philippa> so really the "proving correct" isn't relevant for much?
03:21:35 <phobes> Well, some kinds of types should probably measure something like set membership
03:21:41 <Philippa> that is, it doesn't matter if the compiler sees the proofs?
03:21:55 <roconnor> phobes: maybe I don't understand what your rules look like.
03:22:11 <phobes> Philippa, well, proving the type system correct would probably be a worthwhile endeavor
03:22:14 <Philippa> the question about terms was because I'm not clear on whether you're building type systems or entire languages
03:22:19 <Taejo> @src runState
03:22:19 <pseudobot> Source not found. The more you drive -- the dumber you get.
03:22:25 <Philippa> yeah, but technically speaking it doesn't matter if your proof is "trust me!"
03:22:28 <Taejo> @src Control.Monad.State.runState
03:22:28 <pseudobot> Source not found. Just try something else.
03:22:38 <phobes> Philippa:  No, the ambient logic is sound / strong
03:22:53 <roconnor> okay, so types are sets
03:22:55 <Philippa> sure. But all you're doing is requiring it be proven before you run the checker and compile and that's it, yeah?
03:22:59 <roconnor> and you have a bunch of rules?
03:23:02 <roconnor> what is a rule?
03:23:03 <Philippa> or if not: what else does it mean?
03:23:30 <phobes> I'm not sure what you mean
03:23:53 <Philippa> to give an example: when you spec a type system, are you also speccing type representations to some extent?
03:24:20 <Philippa> or are we just doing what may as well be running tests before compiling to, say, scheme without giving a damn what the types were?
03:24:26 <phobes> You have to encode in the ambient logic what the type represents - be it a set or whatever - is that what you mean?
03:24:46 <Philippa> yeah, so you're assigning semantics to types
03:24:51 <phobes> yes
03:24:59 <Philippa> so essentially you're writing a compiler in the ambient logic with a bit of library support
03:25:08 <phobes> yes
03:25:26 <phobes> and there's one piece you're missing that makes this a good idea :)
03:25:46 <Philippa> and it's not a fixed term language, by the sound of it
03:25:47 <phobes> The only piece i'm worried about is choosing a sufficiently strong but still consistent system
03:26:02 <roconnor> Sizur: I'm still totally lost
03:26:06 <phobes> My original system (though not just naive set theory) was inconsistent
03:26:11 <phobes> due to Curry's paradox :/
03:26:44 <phobes> I can fix it, but it leads to a bulkier stratified system
03:27:50 <Sizur> roconnor: just keep thinkg 'coffee' in a loop
03:28:11 <Sizur> maybe it'll get better (at least i hope so for me :P)
03:28:14 <Philippa> this sounds a lot like you just want to use a different logic under CH and do explicit staging
03:28:25 <roconnor> I'm glad Philippa seems to understand what's going on :)
03:28:26 <Philippa> worse: be forced to do explicit staging
03:28:58 <phobes> I'm not using CH
03:29:00 <Philippa> to have to use deep embeddings (roughly speaking, terms correspond to an algebra) rather than shallow ones
03:29:17 <Philippa> you're not thinking in terms of CH, that doesn't mean there isn't an interpretation of what you're doing using it
03:29:28 <phobes> I start with a strong logic... there is a corresponding type system, but it almost certainly represents garbage
03:30:00 <phobes> well, "almost certainly" is strong
03:30:18 <phobes> but I'm certainly not going to find a useful correspondance
03:30:21 <phobes> e*
03:30:59 <FunctorSalad> why doesn't this parse? "instance (Floating a), (Floating b) => (MyClassCon a b) a->b where"
03:31:00 <phobes> Although I skimmed a paper the other day by some guys finding a prorgamming implementation of other ZF concepts
03:31:19 <Sizur> (Floating a, Floating b) =>
03:31:34 <FunctorSalad> ah that's the one permutation I didn't try :)
03:31:35 <Sizur> and (a->b)
03:31:35 <roconnor> | a->b I think
03:31:45 <Sizur> or that
03:31:48 <FunctorSalad> roconnor: no I mean a->b
03:32:00 <FunctorSalad> a->b is an instance of (MyClassCon a b)
03:32:12 <roconnor> FunctorSalad: oh, not fundeps
03:32:42 <phobes> Philippa:  So your concern with shallow/deep is that because the type system is rather far from the ambient logic, it will require a "deep" embedding?
03:32:44 <Sizur> and you cannot have a class constructor used as a type constructor
03:33:00 <roconnor> FunctorSalad: shouldn't that be (myClassCon a b (a->b)) ?
03:33:15 <Philippa> phobes: no
03:33:21 <Philippa> do you know what I mean by "deep"?
03:33:24 <Sizur> ditto roconnor
03:33:24 <phobes> no
03:33:41 <phobes> category theory I assume :)
03:33:57 <Philippa> okay. A deep embedding is one where the terms of the object language are represented by concrete values in the metalanguage that don't directly carry the object language's semantics
03:34:13 <Philippa> for example, a deep embedding of the lambda calculus in Haskell looks like this:
03:34:21 <phobes> ya
03:34:31 <phobes> data Term = lambda ...
03:34:37 <Philippa> yep
03:34:59 <Philippa> you then add semantics by building a function (or functions)
03:35:10 <Sizur> FunctorSalad: you cannot have an extra type after your multiparam class instance. what's the definition of MyClassCon?
03:35:14 <Philippa> a shallow embedding goes straight to the semantics, there's no syntactic representation
03:35:24 <phobes> Philippa:  That's actually close to what I thought you meant
03:35:45 <phobes> Right, the easy way to write a lambda evaluator - steal meta functions
03:35:55 <Philippa> you're going to need to work with a deep embedding, if only to retain your sanity
03:36:24 <FunctorSalad> roconnor: do I need these extra parenth's for instance declarations? Sizur: hmm I have to tell it which type is an instance of the class "MyClassCon a b"
03:36:26 <phobes> data Foo = Foo Foo -> Bool    probably proves that :)
03:37:00 <phobes> (not that I have to allow such nonsense in my language :)
03:37:06 <FunctorSalad> Sizur: class MyClassCon a b where apply :: a -> b, applyInverse :: b -> a
03:37:43 <mux> bah, hs-plugins need to get updated for the base split
03:37:48 <Philippa> phobes: basically I'm saying it's an awful lot of work given how many different DSLs I use in even 1000 lines of code
03:38:27 <Philippa> especially when it sounds like I won't get any properties "for free"
03:38:29 <Sizur> FunctorSalad: and what do you want as an instance of the class?
03:38:31 <roconnor> FunctorSalad: sounds like you want ``instance (Floating a, Floating b) => (MyClassCon a b) where apply ...
03:38:35 <phobes> Philippa:  Why would each DSL need its own work?
03:38:49 <Philippa> because it comes with its own domain specific type system?
03:38:55 <roconnor> where apply = id ; apply Inverse = id
03:39:00 <Philippa> either that or you're just going to build another uberlanguage in your first uberlanguage
03:39:04 <phobes> But you'd have to do that if you tried to build a domain specific type system in Haskell, too
03:39:15 <Philippa> yes, but I can use a shallow embedding
03:39:43 <FunctorSalad> Sizur: an instance of the class should represent an invertible function from a to b
03:40:01 <FunctorSalad> roconnor: hmm, isn't the type that instantiates the class mentioned?
03:40:02 <Philippa> and I get the relevant proofs "for free", they're properties of Haskell's type system
03:40:15 <Sizur> FunctorSalad: you want to represent isomorphism?
03:40:43 <phobes> I'm not sure I wouldn't get some free theorems...
03:40:54 <roconnor> FunctorSalad: sounds like you want class MyClassCon a b t where apply :: t -> (a -> b) ; applyInverse t -> (b -> a)
03:41:16 <phobes> Well, they wouldn't be free, you'd have to state and prove them
03:41:28 <FunctorSalad> Sizur: isomorphism in Set, if you will. I'm a bit confused about what exactly I'm doing, I think in this view I would need a new type for every invertible function I need
03:41:33 <Philippa> exactly. Whereas I get "won't go wrong" for free
03:41:35 <phobes> but hopefully they're 'cheap'
03:42:13 <phobes> in the semantics you do
03:42:15 <FunctorSalad> roconnor: where t is a dummy that tells it which particular function we want?
03:42:28 <phobes> but the compiler writer still has to be very careful about representations and such
03:42:40 <roconnor> t represents invertable functions from a to b.  That's what you said isn't it?
03:42:43 <Philippa> but I'm not the compiler writer any more
03:42:49 <Philippa> which is rather the point
03:43:18 <phobes> but my point is that proving that well typed programs don't go wrong *in the logc* is the job of the compiler writer
03:43:30 <roconnor> FunctorSalad: so t isn't a dummy, it is very very important.
03:43:31 <phobes> and it was the job of your compiler-writer too, even if he didn't use a formal logic
03:43:42 <Sizur> FunctorSalad: it's not clear to me what you need. why have a class when only one polymorphic instance exists
03:43:51 <Philippa> yes. So I'm just left showing that all my DSL programs are well-typed
03:43:58 <Philippa> I don't want to have to be the compiler writer
03:44:04 <roconnor> FunctorSalad: prehaps I don't understand what you want.
03:44:23 <phobes> Yes, mostly you will end up relying on the type system
03:44:28 <phobes> But sometimes you won't
03:44:40 <FunctorSalad> roconnor: (let's call MyClassCon Bij) I thought an instance of (Bij a b) should represent an invertible function from a to b. like "instance (Bij Double Double) Exp where apply = exp, applyInv = log
03:44:49 <phobes> When you want to make a matrix class that nicely solves constraints among rows and columns of appended matrices
03:44:56 <phobes> you'll go ahead and make special types that support that
03:45:08 <FunctorSalad> where Exp would just be "data Exp" I suppose
03:45:14 <phobes> because it's an easy problem if you have access to general computation
03:45:48 <Philippa> *shrug* - so where's the advantage in your approach?
03:46:02 <Philippa> why aren't I happy with a "typical" partial dependently-typed language?
03:46:06 <phobes> I'm not sure, because I don't understand your approach well enough
03:46:39 <phobes> Philippa:  Recommend something?
03:46:46 <FunctorSalad> Sizur: hmm I think I would have no instances at all of forall a,b. Bij a b
03:46:53 <phobes> Is there a language that sounds like it would fit what I've been asking for?
03:47:09 <Philippa> cayenne, agda, implement CIC and add fix
03:47:14 <Philippa> (and sugar to taste)
03:47:22 <FunctorSalad> (which would be type constructors that make up an invertible function from any type to any other, which is impossible)
03:47:48 <roconnor> FunctorSalad: when you write (apply 0.0), what result do you expect?
03:47:48 <Philippa> build an IDE on top rather than making proof search part of the language itself and you'll have something workable for now
03:47:55 <FunctorSalad> hmm brb I will look whether that Exp example works
03:48:22 <phobes> Philippa:  For now, I'm just building the language... the fact that proof search is the "right foundation" is something I'll get to later
03:48:42 <Philippa> incidentally, I'm curious to know how you would've treated my example way back when as subtyping
03:48:50 <Philippa> that is, what the datatype declarations would look like
03:48:55 <mux> anyone has a Plugin/Dummy/DocAssocs.hs patch for lambdabot so that it builds with latest bytestring package?
03:48:56 <phobes> The Term question?
03:48:58 <Philippa> yeah
03:49:01 <phobes> ALam and Lam
03:49:02 <roconnor> FunctorSalad: the problem as I see it (apply 0.0)::Double doesn't know which isomorphism you want to use.
03:49:02 <phobes> um
03:49:11 <phobes> I'm not sure I completely understood it
03:49:16 <phobes> So with an application
03:49:30 <phobes> What do you want there?
03:49:47 <FunctorSalad> roconnor: good point.
03:50:02 <roconnor> FunctorSalad: I think you should be representing bijections as a datatype rather than a type class.
03:50:17 <roconnor> so apply exp 0.0  reduces to 1
03:50:22 <roconnor> apply id 0.0 reduces to 0
03:50:28 <Philippa> ALams yield a Term Annotated, Lams yield a Term NotAnnotated, App takes a Term a and a Term b and gives a Term Annotated iff a = b = Annotated and a Term NotAnnotated otherwise
03:50:32 <roconnor> applyInverse exp 1 returns 0
03:50:33 <roconnor> er
03:50:45 <roconnor> execpt exp and id are bad names
03:50:46 <Philippa> or any suitably comfortable encoding of the same concept
03:50:47 <FunctorSalad> anyway, it doesn't parse because it doesn't group properly: "Kind error: `Bij' is applied to too many type arguments \ In the instance declaration for `Bij Double Double Exp'"
03:50:52 <roconnor> because they are taken
03:50:56 <roconnor> I mean
03:51:08 <roconnor> apply expBij 0.0  reduces to 1
03:51:15 <roconnor> apply idBij 0.0  reduces to 0
03:51:23 <roconnor> applyInverse expBij 1.0  reduces to 0
03:51:25 <Philippa> so if you have TermNotAnnotated and TermAnnotated as subtypes of Term (with partially annotated terms becoming Term rather than Term NotAnnotated or Term a as in my case) that's okay
03:51:53 <FunctorSalad> roconnor: yes, I thought about the data approach too but wanted to practice the type system ;)
03:51:59 <phobes> It looks like the definitions you gave would encode relatively straightforwardly, and yield an easy induction proof of the subtype
03:52:14 <roconnor> If you want 1 global bijection between Double and Double, then you can use the type classes.
03:52:40 <Philippa> phobes: I want to know what the datatype definitions would look like
03:52:51 <phobes> Philippa:  If you can write down a predicate that identifies term trees as Annoated or not, then it's easy to prove subtype
03:52:54 <Philippa> it sounds like you're trying to do some variant of structural subtyping over the top
03:53:01 <phobes> Type {Predicate} is always a subtype of Type
03:53:14 <Philippa> yes, but that's got nothing to do with subtyping
03:53:23 <roconnor> FunctorSalad: unfortunatley type classes don't solve every problem :P
03:53:25 <Philippa> you're just using it as a way to drop the proof at the end
03:53:32 <Philippa> I'm asking you to /solve the problem using subtyping/
03:53:48 <FunctorSalad> roconnor: I see. but if I wanted to have one global one, how would I make "instance ((Bij Double Double) Exp) where ..." work?
03:53:50 <phobes> The problem being?
03:53:59 <Philippa> encoding that invariant
03:54:05 <roconnor> instance Bij Double Double where
03:54:06 <FunctorSalad> (it doesn't work because it thinks all three Types are arguments to Bij)
03:54:16 <roconnor> no need for Exp because there is only going to be one.
03:54:29 <Philippa> so that I can tell whether, for example, my evidence-generating type inference algorithm does in fact take a term to a fully-annotated term
03:54:34 <phobes> hmm, so this isn't just a GADT?
03:54:43 <Philippa> no, because there's a type function involved
03:55:24 <Philippa> "App takes a Term a and a Term b and gives a Term Annotated /iff a = b = Annotated/ and a Term NotAnnotated otherwise" (emphasis added)
03:55:25 <phobes> well, it could be done if you model the cases ALam and Lam separately
03:55:49 <Philippa> ALam and Lam are distinct. I refuse to have two distinct version of App
03:55:59 <Philippa> *versions
03:56:05 <phobes> ok
03:56:53 <phobes> It's looking like probably the type system I haven't in mind won't correctly propogate these types
03:57:02 <phobes> but it can certainly encode them
03:57:14 <phobes> I have in mind something like Haskell
03:57:18 <Philippa> ...if it can't propagate it properly then it hasn't encoded the types of the constructors properly
03:57:20 <FunctorSalad> roconnor: hmm, I'm confused. that wouldn't mention which type is actually an instance of Bij Double Double, would it?
03:57:54 <roconnor> if you make apply = exp and applyInv = log
03:57:55 <phobes> wait no, this isn't hard is it? ... sec
03:58:00 <Philippa> if I've got Haskell and I can put constraints on the type of constructors in GADTs then I'm sorted
03:58:09 <roconnor> then apply 0.0::Double would alwaybe be 1.
03:58:39 <roconnor> FunctorSalad: all the information about what to use are tied up with the two Doubles
03:59:03 <FunctorSalad> roconnor: yes. but I mean in the normal case, we write for example "instance Eq MyType where ..." and not just "instance Eq", right?
03:59:04 <roconnor> FunctorSalad: typeclasses in Haskell are a global phenomenom. (Haskell's dirty little secret :)
03:59:09 <jedai> I'm trying to install MissingH  on Windows and I have some problems... I have already changed the cabal config, the Setup.hs, and some files so that they don't try to Import System.Posix on Windows, but I have an error message I don't know what to do with :
03:59:12 <hpaste>  Jeda pasted "Error compiling MissingH" at http://hpaste.org/4760
03:59:26 <phobes> so it's something like this, right:
03:59:27 <phobes> data Term = Symbol Sym | ALam Term | Lam Term | App Term Term
03:59:36 <phobes> err missing Symbol on Lams
03:59:42 <Philippa> and a Type on ALam, yeah
03:59:45 <Philippa> but those can pass
03:59:49 <phobes> y
04:00:10 <Philippa> but now I want it to tell me at type level whether that invariant ("fully annotated") is known to hold for that term or not
04:00:12 <roconnor> FunctorSalad: sure.  Here Bij is playing the role of Eq, and Double is playing the role of MyType.
04:00:29 <Philippa> (if I don't know/don't care I need a way to represent that too - with the GADT I just leave the parameter as a variable)
04:01:32 <FunctorSalad> roconnor: doh. didn't realize that Eq takes a parameter too. I thought it meant "MyType is an instance of Eq"
04:01:34 <vincenz> Philippa: is that even possible in Haskell?
04:01:37 <phobes> So you have in mind this:
04:01:38 <phobes> data Term[Bool] = Symbol Sym | Term[True] ALam Symbol Term Type | Term[False] Lam Symbol Term Type | Term[A&&B] App Term[A] Term[B]
04:01:47 <roconnor> @kind Eq
04:01:50 <Philippa> phobes: sure, where's the subtyping?
04:01:53 <pseudobot> Class `Eq' used as a type
04:02:01 <FunctorSalad> @karma+ roconnor
04:02:01 <roconnor> oops
04:02:02 <pseudobot> roconnor's karma raised to 3.
04:02:15 <Philippa> vincenz: depends - can you constrain the type variables in a GADT's constructor yet? (that's constraint as in type class, type family)
04:02:41 <roconnor> FunctorSalad: it is saying that MyType is an instance of Eq
04:02:50 <vincenz> Philippa: No idea on that one
04:02:53 <phobes> Subtyping is something you would then ask your compiler to prove - it will be trivial by induction
04:03:00 <roconnor> FunctorSalad: and I'm saying that two Doubles form an instance of Bij
04:03:01 <vincenz> Philippa: and then use existential typing for the Term?
04:03:15 <FunctorSalad> roconnor: ahh now I see where your t was coming from
04:03:40 <Philippa> vincenz: full-blown GADT, that's the whole point - we want to alter the type parm in the result
04:03:46 <roconnor> FunctorSalad: right, my t thing would end up working essentially the same way as the datatype.
04:03:55 <phobes> I guess your point is "subtype of what"?
04:03:56 <roconnor> ... so you might as well just use the datatypes.
04:04:01 <Philippa> amongst other things, yes
04:04:15 <phobes> And subtyping would come in when you defined "Term = Term[True] or Term[False]"
04:04:16 <Philippa> or more bluntly, that you're just using your subtyping relationship as a source of implicit coercions
04:04:43 <phobes> Yes, implicit coercions are the kind I don't have to write
04:05:13 <Philippa> I mean really, the sane thing would be Term[dontcare]
04:05:25 <vincenz> Philippa:  so something like
04:05:34 <vincenz> (And a b c) => Term a -> Term b -> Term c
04:05:39 <Philippa> vincenz: yep
04:05:40 <vincenz> (And a b c) => App:: Term a -> Term b -> Term c
04:05:56 <Philippa> well, App:: (And a b c) => ...
04:06:01 <vincenz> right
04:06:02 <phobes> Yes, you could use exists B, Term[B] everywhere
04:06:16 <vincenz> I am totally not a type buff
04:06:20 <vincenz> Nor a logic buff
04:06:26 <Philippa> ... in most places I'll be using universal quantification, not existential
04:06:35 <vincenz> But it seems to me phobes wants non-constructive logic while most type systems use constructive logic
04:06:41 <Philippa> pretty much, yeah
04:07:32 <phobes> Another source of my problem is reading about Epigram 2
04:08:00 <phobes> God awful category theory things happening, all to get quotient types for ADTS
04:08:09 <vincenz> Non constructive types are nice since you get LEM
04:08:13 <phobes> But maybe it will be presented to the user in a nice way
04:08:14 <vincenz> and thus you can have closure on stuff
04:08:15 <roconnor> constructive logic is an extension of classical logic.  People are welcome to work in the classical fragment of constructive logic if that's what they want.
04:08:26 <Philippa> yeah, but quotient types are /nice/
04:08:31 <vincenz> like (Not a)
04:08:31 <Philippa> they're not just doing subtyping
04:08:40 <Philippa> they're "these're the same modulo some detail I don't care about"
04:08:41 <phobes> Philippa:  I can do quotient types :)
04:09:14 <phobes> That's what I like about my approach
04:09:17 <phobes> I can do *anything*
04:09:25 <Philippa> solve the halting problem?
04:09:38 <phobes> in my previous logic I could yes
04:09:40 <phobes> :P
04:09:46 <Philippa> quite
04:10:05 <vincenz> sure, because you want codata only
04:10:09 <vincenz> and thus only finite programs
04:10:11 <Philippa> believe it or not, the existing "big" constructive logics're pretty powerful even before you find a suitable way to embed nontermination
04:10:17 <vincenz> you said it youreslf, you do not allow _|_ in types
04:10:36 <phobes> I do not *automatically* want _|_ in types
04:10:45 <phobes> That doesn't mean I don't want the ability to reason about non termination
04:11:06 <vincenz> as soon as you have _|_ termination is not analyzable
04:11:09 <phobes> But I certainly want the ability to say "This is an Integer - an actual one, not _|_"
04:11:11 <hpaste>  FunctorSalad pasted "Bijections as types - messy as roconnor said it would be ;)" at http://hpaste.org/4761
04:11:35 <phobes> vincenz:  That's not true :)
04:11:41 <roconnor> FunctorSalad: right,
04:11:52 <vincenz> phobes: well for a large enough class of programs
04:11:55 <phobes> ya
04:12:02 <phobes> I know what you mean... halting problem and all
04:12:03 <swiert> phobes: what don't you like about Epigram 2?
04:12:17 <vincenz> and I know what you mean, special case analysis, flow-analysis :)
04:12:30 <vincenz> which means your type system becomes flow-dependent
04:12:32 <roconnor> FunctorSalad: but at this point you might as well write data Bij a b = mkBij {apply :: a -> b; applyInv :: b -> a}
04:12:33 <phobes> swiert:  I don't don't like it - I am very interested - I just don't undertsand the god awful category theory behind it
04:12:38 <phobes> that I've seen discussed
04:12:42 <FunctorSalad> roconnor: right
04:12:49 <roconnor> FunctorSalad: :)
04:13:17 <phobes> vincenz:  Divide the type system into two parts:  The pretty haskell like part
04:13:24 <swiert> phobes: can you be more specific than "god awful category theory"?
04:13:27 <phobes> and the ugly "Things I wish I could prove, but I'm dreaming part"
04:13:35 <phobes> swiert:  not really :)
04:14:03 <jedai> Has anyone here been building MissingH on GHC 6.8 ?
04:14:19 <phobes> vincenz:  Now, make sure the nice part is sound and gets an answer, etc
04:14:26 <phobes> But for the other part, try to prove what you can and move on
04:14:36 <Philippa> which is, uh, what Epigram's trying to do too
04:14:39 <phobes> turn what you can't into runtime checks
04:14:48 <Philippa> though not that bit
04:14:52 <phobes> If you can't even make a runtime check... oh well, it's good documentation
04:14:52 <osfameron> does reasoning about non-termination have real applications?
04:15:04 <Philippa> osfameron: yeah, like real applications that don't crash
04:15:12 <phobes> Just draw it red on my IDE so I know it wasn't checked
04:15:20 <Philippa> we all do it, it's a question of how formally
04:15:33 <phobes> Whoa, it's like 6:15 AM here
04:15:36 <phobes> so um... I gotta run
04:15:38 <Philippa> some people just waggle their hand a bit and say "should always terminate"
04:15:43 <roconnor> what does Epigram 2 have to do with category theory?
04:15:52 <phobes> google Epigram 2 :)
04:15:52 <osfameron> Philippa: ok.  I guess I see that not having programs crash is a good thing.  Just that I'm never sure how much the theory actually helps in practise :-)
04:16:06 <hpaste>  mux pasted "building LB with GHC 6.8.2" at http://hpaste.org/4762
04:16:20 <FunctorSalad> roconnor: it should prolly also carry around it's domain and codomain, since there is no "PositiveDouble" type
04:16:23 <Philippa> osfameron: usually it helps more in the shape of structuring code in such a way that you can see how to sketch a proof
04:16:24 <FunctorSalad> *its
04:16:25 <phobes> g'nite all
04:16:29 <mux> does anyone know the reason for this build error?
04:16:31 <phobes> Philippa:  thanks for the patience :)
04:16:43 <roconnor> FunctorSalad: newType PositiveDouble = PositiveDouble Double
04:17:42 <pejo> osfameron, doesn't terminator/SLAM (one of them) ensure liveness properties for windows drivers?
04:18:15 <osfameron> pejo: I have no idea.  But yeah, that would be a good answer to the question about realworld applications, yes.
04:18:51 <jedai> mux: Yes, you don't have an instance of MonadError IRCError m ;-) Do you have an idea concerning my error ? http://hpaste.org/4760
04:19:04 <pejo> osfameron, shrug, I think there are plenty of uses for proven termination - it's usually what you want when you write code.
04:19:42 <mux> jedai: existentials are beyond me
04:20:32 <osfameron> pejo:  I guess.  But usually code terminates just fine: as a non-academic working-programmer, it's just interesting to see how much research time seems to be spent on the topic.
04:21:11 <jedai> mux: I get the simple ones but I don't see what's wrong in this one (especially since it probably worked with GHC 6.6)
04:21:25 <osfameron> pejo: as in, I guess I think of it as a debugging problem rather than a proof problem.
04:21:47 <roconnor> osfameron: the type of code researched isn't proportional to how often that type of code is used.
04:22:06 <roconnor> osfameron: we spend more time researching code that is difficult to get right.
04:22:12 <pejo> osfameron, I bet there are numbers of how many blue screens in windows that come from bad 3rd party drivers compared to internal stuff. And MS gets the blame for all of them.
04:22:18 <osfameron> roconnor: fair enough
04:23:07 <flux> of course, the way I understand termination proofs is not only that the code in real world does terminate, but that it reaches the predetermined point-of-exit properly
04:23:19 <flux> so if a piece of code segfaults, it doesn't terminate - it gets terminated :)
04:23:39 <Philippa> yep, Going Wrong doesn't count
04:23:57 <roconnor> flux: not entirely.  Coq reduction can run out of memory, because memory isn't modeled by the system.
04:24:36 <Philippa> osfameron: termination's a good stepping stone to a range of more complicated properties. Memory usage is actually fairly closely related to it, for example (it's dual to run time)
04:25:01 <mux> dons: ping
04:26:37 <osfameron> Philippa: ah, cool.
04:28:08 <roconnor> Philippa: by analizing the term to bound the memory it could consume?
04:29:03 <Philippa> roconnor: right. So the equivalent of termination is just knowing that there's a finite bound
04:32:06 <mux> @seen dons
04:32:06 <pseudobot> dons is in #haskell. I don't know when dons last spoke.
04:35:15 <matthew-_> it does seem rather bizarre that ghc ships with libraries for CGI, yet without libraries to make HTTP requests
04:36:51 <therp> can someone recommend me a set of books/papers/article in sum below 1000 pages, that I can put in my knapsack, to get an idea what pure type systems, LEM, constructive vs. classical logic, CH are?
04:37:36 <therp> I just spend 10 minutes reading my backlog but could only guess what it's all really about.
04:38:25 <swiert> therp: I quite like CoqArt.
04:38:36 <Philippa> possibly with TAPL as a prelude to it
04:38:45 <Philippa> does CoqArt cover pure type systems?
04:38:54 <vincenz> therp: LEM :   a = ~~a
04:39:03 <Philippa> if not, I guess there's the bunch of references from ATTAPL's dependent typing chapter
04:39:19 <therp> I've read TAPL.. probably I should read the last 80 pages too..
04:39:22 <vincenz> not LEM : a >= ~~a   or was it <=
04:39:49 <merus> What happens if you nubBy something that isn't an equivalence relation?
04:39:57 <matthew-_> undefined
04:40:01 <merus> drat.
04:40:08 <jedai> matthew-_: Right, and FTP wouldn't hurt either, I'm trying to build ftphs but it needs MissingH and I get some type errors (which don't make sense given it's a big library which compiled and worked fine with GHC 6.6)
04:40:11 <matthew-_> it's like "groupBy" with a non-symmetric operator
04:40:14 <byorgey> merus: depends on the implementation of nubBy =)
04:40:19 <therp> hmm coqart 65 EUR..
04:40:40 <matthew-_> jedai. Yeah, I've got code that was fine under 6.6 and not fine under 6.8
04:41:22 <matthew-_> jedai: is MissingH updating for 6.8? Is it going to be? I'd be tempted to rewrite the FTP library from scratch, but I'm aware it's a bigger job than HTTP
04:41:39 <jedai> matthew-_: If at least I had a cue on what the problem is... Do you see what's wrong in this type : http://hpaste.org/4760
04:41:43 <mux> anyone has patches for building LB with GHC 6.8.2?
04:41:49 <therp> what about TTFP?
04:42:35 <therp> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
04:42:37 <pseudobot> Title: Type Theory and Functional Programming
04:42:46 <matthew-_> jedai: it could just need an extra flag
04:42:49 <jedai> matthew-_: I sure hope so, but for now it's badly broken (and it's even worse for me on Windows, there's some very strange thing there, like importation that are not properly #if-ed)
04:43:07 <matthew-_> jedai: on that file, try adding to the {-# OPTIONS_GHC #-} line
04:43:27 <matthew-_> I dunno with -fglasgow-exts still has the effect of turning everything on
04:43:44 <jedai> matthew-_: Yes, I think I'll try that but it's pretty awful, I prefer to restrict extensions
04:43:49 <matthew-_> yep.
04:44:05 <matthew-_> gosh, I haven't actually done any programming for about 4 months
04:44:21 <matthew-_> the PhD will have to stop...
04:45:26 <therp> matthew: what's your thesis about?
04:45:54 <hpaste>  mux annotated "building LB with GHC 6.8.2" with "and the code is" at http://hpaste.org/4762#a1
04:48:04 <matthew-_> therp: um, the current title is "Universally Applicable Deadlock-free Session Types"
04:51:28 <mux> grmbl, I can't figure out why this deriving statement fails
04:51:36 <mux> and it was supposedly working with GHC 6.6.x
04:51:39 <Cale> mux: which one?
04:51:45 <thoughtpolice> mux: Cale got LB to build with 6.8.2, don't know if there've been patches to the official repo yet, but from what he told me it's only a few source changes to build (since hs-plugins works with 6.8.2 as well)
04:51:52 <mux> Cale: p: um, the current title is "Universally Applicable  Deadlock-free
04:51:54 <Cale> Oh, in lambdabot?
04:51:56 <mux> woops, bad copy-paste
04:51:58 <mux> yeah
04:52:00 <mux> the MonadError thing
04:52:06 <mux> http://hpaste.org/4762
04:52:08 <Cale> Yeah, change the error type to e
04:52:17 <mux> instead of IRCError?
04:52:21 <Cale> yes
04:52:33 <mux> isn't that weird?
04:52:36 <mux> (thanks!)
04:53:04 <Cale> It is strange. I don't actually understand why 6.8.x won't accept it.
04:53:04 <mux> I hope I'm done patching LB now =) had to add tons of dependencies in the .cabal file, hacked the Plugin/Dummy/DocAssocs.hs thing, etc
04:53:26 <mux> has this been reported already?
04:55:42 <mux> the difference in GHC building speed with 6.8.2 is truly impressive
04:58:00 <vincenz> mux: faster or slower?
04:58:04 <mux> much faster
05:01:46 <dcoutts> mux: it's all down to -fasm being default now even with -O
05:06:25 <mux> ah, now LB is built but runplugs give me an error "Error in array index"
05:06:30 <mux> Cale: does that ring any bell?
05:07:06 <Cale> mux: are you sure you're running the runplugs built with the new hs-plugins?
05:07:30 <mux> quite sure, since I reinstalled all the haskell modules needed after updating to GHC 6.8.2
05:07:34 <mux> including hs-plugins 1.0rc1
05:08:10 <vincenz> dcoutts: -fasm?
05:08:48 <dcoutts> vincenz: -fasm meaning use the native code generator rather than -fvia-C which means go via C / gcc
05:08:50 <mux> Cale: where is the code for runplugs?
05:08:54 <vincenz> dcoutts: h
05:08:56 <vincenz> ah
05:08:57 * vincenz nods
05:09:06 <Cale> That error was usually caused by the hi loader not being compatible with the installed version of GHC, but that shouldn't be an issue anymore since it uses the GHC API to do that work.
05:09:34 <Cale> In scripts/
05:09:38 <mux> yeah, just found it
05:09:42 <mux> I'll clean and rebuild
05:12:20 <mux> mmm, same thing, after cleaning dist/runplugs*
05:12:44 <mux> I may have taken the wrong version of hs-plugins
05:12:54 <mux> took it from dons' webpage and not hackage iirc
05:17:34 <mux> Cale: I just took plugins-1.0 from hackage, rebuilt runplugs and I get the same :-/
05:17:43 <Cale> uh, I don't think either of those are the right place.
05:17:52 <mux> hah. where am I supposed to take it then?
05:18:03 <Cale> code.haskell.org...
05:18:06 <Cale> http://code.haskell.org/~dons/code/hs-plugins/
05:18:07 <pseudobot> Title: Index of /~dons/code/hs-plugins
05:18:11 <mux> cheers
05:19:13 <Cale> an easy way to check is to see if there's a src/Language directory
05:19:22 <Cale> If there is, you have the old version.
05:19:52 <mux> mm, I must have had the old version since this one is 1.1 and I had 1.0
05:20:12 <mux> also, I don't need to fix the STArray thing in this version :-)
05:22:09 <Cale> Oh, you managed to build hs-plugins with 6.8?
05:22:41 <mux> yes
05:22:52 <mux> and now I got a new error!
05:22:56 <mux> runplugs: /tmp/MhTKN19224.o: unknown symbol `__stginit_haskell98_Char_'
05:22:56 <mux> runplugs: user error (resolvedObjs failed.)
05:22:59 <Cale> Heh, I actually made my modifications in trying to get it to build. The code for the Hi parser wouldn't build, so I removed it and replaced it with calls into the GHC api.
05:23:10 <Cale> Oh, just remove Char from the import list.
05:23:18 <Cale> (In RunPlugs.hs)
05:23:36 <mux> thanks
05:23:40 <Cale> Data.Char is already there, and the Char module creates a dependency on the haskell98 package now.
05:24:00 <mux> what a quest for having LB built with 6.8.2
05:24:24 <oerjan> @version
05:24:25 <pseudobot> lambdabot 4p584, GHC 6.6 (Linux i686 (Mendocino))
05:24:25 <pseudobot> darcs get http://code.haskell.org/lambdabot
05:24:31 <Cale> Well, I suppose so, yes :)
05:24:52 <Cale> I never managed to fix the problems with the STArray stuff.
05:25:03 <mux> you just need to add "_ " :D
05:25:29 <mux> damn, I need to remove List too
05:25:32 <Cale> I considered pulling code from GHC, but realised that I was wasting my time, since that code was already exposed by the GHC API.
05:26:00 <Cale> Remove all the haskell98 modules except for Numeric, which is still in base.
05:26:05 <mux> oh
05:26:13 <mux> ok, I was going to remove the whole "prehier" thing
05:26:16 <mux> but I'll keep Numeric
05:29:36 <mux> runplugs: /usr/home/mux/lambdabot/L.o: unknown symbol `__stginit_haskell98_Char_'
05:29:39 <mux> any idea?
05:29:47 <mux> there seem to be more coming from elsewhere
05:31:21 <oerjan> Numeric never got a hierarchical name
05:31:45 <mux> the problem isn't about Numeric
05:32:32 <mux> ok, I think it came from State/L.hs
05:33:08 <Cale> yeah, that seems likely
05:35:07 <mux> omg
05:35:10 <mux> runplugs: /usr/home/mux/lambdabot/L.o: unknown symbol `__stginit_oeiszm0zi1_MathziOEIS_'
05:35:13 <mux> runplugs: user error (resolvedObjs failed.)
05:35:20 <mux> am I supposed to add -package flags somewhere?
05:35:52 * mux tries to add -package oeis to the ghc command line for L.hs in build
05:37:14 <mux> hmm, doesn't help
05:37:19 <mux> Cale: did you encountered that too?
05:38:47 <Cale> I just added import Math.OEIS to L.hs
05:38:56 <mux> well it's already there
05:39:07 <mux> I actually just removed it
05:39:11 <mux> and now runplugs seems to work
05:39:27 <Cale> oh, do you have the oeis package installed?
05:39:42 <mux> yes
05:39:52 <mux> as a user though
05:40:06 <mux> maybe hs-plugins doesn't take a look at user-installed packages?
05:41:37 <Cale> maybe
05:41:38 <EvilTerran> you might have to add your user package directory to a search path or sth
05:42:20 <mux> I'll live without OEIS for now, I'm already quite happy to have LB built with 6.8.2 and > working
05:43:05 <mux> and @oeis still works anyways
05:48:10 <FunctorSalad> in ghci, is there some way to list the exports of a module?
05:48:25 <profmakx> heh, i went through the same troubles gettin lb to work with 6.8.2
05:51:06 <roconnor> :b Data.List
05:51:11 <roconnor> FunctorSalad: ^^
05:52:27 <FunctorSalad> @karma+ roconnor
05:52:28 <pseudobot> roconnor's karma raised to 4.
05:52:37 <mattam> What's the rationale behind redefining a Functor instance when you have already defined a Monad instance (e.g. for State).
05:52:49 <FunctorSalad> roconnor: output of :? is too intimidating to find something ;)
05:53:10 <mattam> Better question, why not directly have instance Monad m => Functor m ?
05:53:49 <mattam> The WrappedMonad things seems like an ugly hack
05:54:07 <vincenz> mattam: not valid h98
05:54:32 <FunctorSalad> mattam: I wondered that too, someone told me it has historical reasons
05:54:36 <vincenz> Yes it is
05:54:38 <vincenz> You can't do
05:54:41 <vincenz> Foo a => Bar a
05:54:43 <oerjan> you don't want an instance, you want a superclass
05:54:44 <vincenz> you need a data-constructor
05:55:10 <mattam> oerjan: also, but that's another problem
05:55:13 <oerjan> the instance would overlap with anything that is a Functor without being a Monad
05:55:14 <roconnor> mattam: ? Not ever Functor is a Monad.
05:55:19 <roconnor> every
05:55:41 <jedai> GHC 6.8 really changed "everything", it really was a load of fun to build ftphs... :-(
05:56:02 <roconnor> mattam: oops you said instance, not class
05:56:09 <FunctorSalad> I think Monad would have to be like class Functor f => Monad f
05:56:12 <jedai> MissingH is big and there's plenty of small problems for the 6.8 in it
05:56:19 <mattam> roconnor: yep
05:56:21 <swiert> hi mattam
05:56:27 <mattam> hi
05:56:28 <FunctorSalad> (where ....)
05:56:39 <jedai> There's even a Data.String... Which is now a base module
05:56:42 * mattam 's redoing the prelude in Coq
05:57:18 <jedai> I renamed it Data.String.Utils (like the others Data.* in the distrib)
05:57:32 <FunctorSalad> I guess people don't want to have to define fmap for every Monad
05:57:38 <mattam> vincenz: so you say this instance would not be accepted because it would overlap, but with the proper flag it would be ok ?
05:57:50 <swiert> mattam: thanks for your e-mail. Where is subset_eq defined?
05:58:03 <mattam> in Coq.Program.Subset, in the trunk :)
05:58:35 <swiert> mattam: ah. ok.
05:58:56 <jedai> I guess I could send the patch to make it compile in the 6.8
06:00:20 <vincenz> mattam: yep
06:01:13 <FunctorSalad> or could Monad implement fmap retroactively? :) class Functor f a => Monad f a where return :: a->f a; >>= :: f a->(a -> f b)-> f b; fmap f x = return x >>= (return . f)
06:01:58 <FunctorSalad> overloaded f there, sorry
06:02:02 <roconnor> FunctorSalad: that also isn't valid
06:02:12 <idnar> fmap = liftM2
06:02:15 <idnar> err, liftM
06:02:35 <mattam> The Right Way (c) would be to have a Functor f => Monad f, or isnt't it possible ?
06:02:36 <roconnor> FunctorSalad: basicly the type class mechanism doesn't work like that :(
06:02:51 <FunctorSalad> roconnor: that's why I asked whether it's possible to implement fmap "retroactively"
06:02:53 <mux> this topic comes up so often
06:02:55 <swiert> mattam: I have another Program question...
06:02:59 <mattam> I mean a "class" constraint.
06:03:13 <mattam> swiert: good !
06:03:16 <mux> I have heard that type classes could be made to work this way, but that there are subtle implications
06:03:47 <roconnor> there have been proposals like class Monad f where return :: ... ; (>>=) :: ... ; instance Functor m where fmap = ...
06:03:53 <FunctorSalad> mattam: if they did this but didn't do what I suggested, then every Monad would have to implement fmap, I think
06:04:08 <roconnor> puting the functor instance in the class definition in Monad.
06:04:09 <swiert> mattam: I need to prove "(s &?) = (s &?)" where the &? is the result of a program. I'd like to use proof-irrelevance, but can't see how.
06:04:59 <mattam> subset_eq is your friend indeed. I have a tactic "pi" which applies it automatically along with f_equal.
06:06:12 <mattam> Why is "class Functor f => Monad f" not ok ?
06:06:58 <roconnor> mattam: that's okay, but it doesn't define the Functor method for you.
06:07:22 <mattam> Ok... fine.
06:07:29 <swiert> mattam: what's the type of subset_eq?
06:07:32 <roconnor> mattam: the only thing it gains is that it reminds you to define a Functor instance if your forget.
06:07:53 <roconnor> mattam: which might not be a bad idea.
06:10:02 <mattam> roconnor: i think if you have both this limitation and the fact that you cannot write "instance Monad => Functor" it could get frustrating.
06:10:31 <mattam> swiert: Lemma subset_eq : forall A (P : A -> Prop) (n m : sig P), n = m <-> (`n) = (`m).
06:11:09 <swiert> mattam: what does ` do?
06:11:09 <mattam> you can do "apply ->" to get the left-to-right implication.
06:11:18 <mattam> It's the first projection.
06:11:28 <swiert> mattam: ok. that's what I thought.
06:11:38 <roconnor> mattam: proof irrelevance?
06:11:46 <mattam> Yep.
06:11:53 <roconnor> hmm
06:12:05 <mattam> It is also defined in ProofIrrelevanceFacts
06:12:07 <roconnor> axiom?
06:12:46 <mattam> Subset_eq can be defined in terms of it.
06:13:16 <roconnor> mattam: apply -> ?
06:13:33 <mattam> Yep, and apply <- too
06:13:55 <roconnor> !!
06:14:07 <roconnor> I need to catch up on all these new tactics
06:14:24 <mattam> It's a new tactic by Evgeny Makarov I think
06:14:37 <roconnor> I wrote my own a while ago
06:14:45 <mattam> in Init/Tactics. The implementation seems rather slow though.
06:14:53 <roconnor> :(
06:15:15 <mattam> Well I'm using coqtop.byte all the time though, YMMV.
06:15:41 <roconnor> mattam: I didn't understand your ``it could get frustrating'' comment.
06:15:48 <swiert> mattam: but you can't prove subset_eq without ProofIrrelevanceFacts or stating it as an axiom, right?
06:15:57 <mattam> swiert: yes.
06:17:12 <mattam> roconnor: well, you just have to (not forget to) manually repeat your code for no.
06:17:21 <mattam> good reason.
06:17:32 <swiert> mattam: right. Thanks for your help - I now understand why I'm stuck :)
06:18:17 <mattam> swiert: have a look in the theories/Program Coq files, they're documented.
06:18:34 <swiert> mattam: ok. will do.
06:20:26 <roconnor> swiert: it epigram2 it will be provable
06:21:09 <mattam> roconnor: in coq 9.0 too
06:21:23 <roconnor> :(
06:21:50 <mattam> Well, I already have a version of Coq where it is provable.
06:22:01 <roconnor> mattam: do we lose decidable type checking too?
06:22:43 <mattam> No.
06:22:47 <roconnor> mattam: or do we lose fixpoints over Acc?
06:23:30 <mattam> Neither, they just become somehow irreducible.
06:23:57 <mattam> This is the part that changes.
06:24:05 <roconnor> so we lose church-rosser?
06:24:23 <roconnor> something has to give here :)
06:24:39 <mattam> Nope, as they're not reducible :)
06:24:54 <mattam> We lose some reductions we had previously.
06:25:25 <mattam> We give a way to recover those at the possible expense of decidability.
06:25:37 <roconnor> so some things that were convertable before are not longer convertable?
06:25:58 <mattam> Yes, in the default setting.
06:26:07 <roconnor> but you still have church-rosser?
06:26:56 <mattam> Yes, it's just that we have more normal forms (some of which you won't like).
06:27:15 <roconnor> wait, we lose canonicity?
06:28:00 <roconnor> not every term of unit in the empty context will be tt?
06:28:49 <mattam> Yes, that can happen I think.
06:29:01 <roconnor> mattam: you are right, I won't like that :)
06:29:23 <mattam> Nobody likes that actually :)
06:29:50 <roconnor> time for me to switch to mattita :)
06:29:57 <roconnor> matitta
06:30:11 <mattam> So we give a way to recover the reductions but it's user-controlled hence unsafe.
06:30:49 <roconnor> mattam: right.  I think I personally would turn that on
06:31:13 <roconnor> mattam: I rather lose strong normalization than canonicity.
06:31:43 <mattam> There could be a way to recover canonicity by analysis of the closedness of terms but that's not been followed yet. Maybe in the future.
06:31:48 <roconnor> (I suppose one could argue that a term that doesn't normalize isn't canonical either)
06:32:03 <mattam> Yeah, that's the idea.
06:32:25 <roconnor> I'd imagine that in the empty context, everything will normailze to a canonical form.
06:32:40 <roconnor> well
06:32:51 <mattam> If the proofs of accessibility are closed themselves then yes.
06:32:53 <roconnor> at least for ground types such as nat.
06:33:56 <roconnor> why the push for proof irrelevence?
06:34:11 <mattam> Because of dependently-typed programming.
06:34:27 <mattam> Proofs everywhere we shouldn't care about.
06:34:49 <roconnor> hmm
06:35:00 <Sizur> @pl (n-> Just (take (length n-3) n))
06:35:01 <pseudobot> (line 1, column 3):
06:35:01 <pseudobot> unexpected ">"
06:35:01 <pseudobot> expecting letter or digit, variable, "(", operator or ")"
06:35:03 <mattam> About half or my proof scripts just manage real proof terms to emulate proof-irrelevance.
06:35:13 <Sizur> @pl (\n-> Just (take (length n-3) n))
06:35:13 <pseudobot> Just . (take =<< subtract 3 . length)
06:36:08 <Sizur> :t (=<<)
06:36:17 <pseudobot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
06:36:43 <oerjan> @src -> (>>=)
06:36:44 <pseudobot> Source not found. My brain just exploded
06:36:52 <oerjan> @src (->) (>>=)
06:36:53 <pseudobot> f >>= k = \ r -> k (f r) r
06:37:31 <roconnor> mattam: we need to slap a tactic engine on epigram2's logic.
06:38:16 <roconnor> OTT seems like the way to go
06:38:29 <Sizur> > (subtract 2 . length >>= take) [1,2,3,4,5]
06:38:29 <roconnor> proof irrelenvce, decidablity, and canonicity.
06:39:02 <oerjan> @bot
06:39:02 <pseudobot> :)
06:39:41 <oerjan> > 2+2
06:39:52 <roconnor> 4
06:40:01 <oerjan> no > ? that's what i'd call pseudo yeah
06:40:14 <roconnor> 4
06:40:33 <roconnor> oerjan: 4
06:41:01 <oerjan> you may find this hard to believe, but i actually knew the answer.
06:41:18 <gbacon> oerjan: :-)
06:41:25 <Sizur> it depends on the type of 2
06:42:34 <mattam> roconnor: right'o, but i'll let the guys a Nottingham do it one time or another :) I have enough of one thesis.
06:43:54 <roconnor> :)
06:43:55 <Sizur> ok so how does (subtract 2 . length >>= take) [1,2,3,4,5] break down? the list is first fed to length then result to subtract 2, then the result of that together with the original list is fed to take, why?
06:44:26 <Sizur> list monad
06:44:54 <mattam> roconnor: also, I don't see how I would treat this Acc problem differently in OTT. Something has to give, it's literaly general recursion in the conversion rule after all.
06:45:13 <oerjan> -> monad, see above
06:45:17 <roconnor> mattam: epigram2 gives up inductive types in Prop
06:45:41 <roconnor> mattam: which makes sense if you want to be proof irrelevent.
06:45:58 <oerjan> the first argument to >>= is a function, so it uses the function monad
06:45:59 <Sizur> oerjan: aha, thanks
06:46:20 <mattam> How do you do well-founded induction then ?
06:46:26 <oerjan>  @pl uses it a lot
06:47:07 <roconnor> mattam: you know what, that is a really good question.
06:47:18 <Sizur> then second arg to >>= must take 2 args, third 3, etc... right?
06:47:18 <mattam> haha
06:47:35 <oerjan> um >>= has two arguments
06:47:41 <Sizur> eh, i mean second application of >>=
06:47:56 <oerjan> not sure what you mean
06:48:18 <roconnor> mattam: I suspect it can be done
06:48:45 <roconnor> mattam: I'll try to look into it sometime
06:48:46 <Sizur> :t length >>= length >>= length
06:48:53 <pseudobot>     Couldn't match expected type `Int' against inferred type `[a]'
06:48:53 <pseudobot>     Probable cause: `length' is applied to too many arguments
06:48:53 <pseudobot>     In the second argument of `(>>=)', namely `length'
06:48:57 <oerjan> no, all but the first take 2
06:49:01 <mattam> Well, I discussed that with Nicolas Oury already. It seems just as difficult :)
06:49:31 <roconnor> mattam: is he the one working on Epigram2?
06:49:32 <conal> Sizur: you want to right-associate, right?
06:49:54 <oerjan> :t length >>= flip take >>= flip take
06:50:00 <pseudobot>     Couldn't match expected type `Int' against inferred type `[a]'
06:50:01 <pseudobot>       Expected type: Int -> Int -> c
06:50:01 <pseudobot>       Inferred type: Int -> [a] -> [a]
06:50:01 <Sizur> conal: nope, just discovering a function monad
06:50:06 <oerjan> bah
06:50:10 <conal> okay
06:50:14 <mattam> roconnor: yep.
06:50:18 <oerjan> oh wait
06:50:43 <roconnor> mattam: And Nicolas didn't know how to write well-founded recursion in epigram2?
06:51:19 <oerjan> :t length >>= take >>= zip
06:51:27 <pseudobot> forall a. [a] -> [(a, a)]
06:51:48 <oerjan> :t length >>= take >>= zip >>= zip >>= zip
06:51:50 <mattam> Well you could always have Acc in type... but otherwise no.
06:51:55 <pseudobot> forall a. [a] -> [(((a, a), a), a)]
06:51:56 <Sizur> so what is being passed to zip?
06:52:04 <roconnor> mattam: shit
06:52:11 <oerjan> the result of the previous, plus the original list
06:52:17 <roconnor> mattam: my dreams are shattered
06:52:29 <Sizur> oerjan: so original is being passed though every function?
06:52:36 <Sizur> through*
06:52:44 <mattam> Don't worry, I'm sure we'll have a better story not to long from now. And I've implemented the desperate solution :)
06:52:54 <loupgaroublond> is there a library in haskell for getting system stats like CPU usage, process lists, memory usage, etc?
06:53:07 <Sizur> function monad plays really well with arrows eh
06:53:35 <roconnor> mattam: okay.  Thanks for letting me know about this problem.
06:54:11 <Sizur> thanks oerjan :) for explaining
06:54:16 <mattam> My pleasure.
06:54:21 <oerjan> Sizur: -> monad is equivalent to Reader, passing an original argument through everything
06:56:02 <oerjan> @src (->) local
06:56:03 <pseudobot> local f m = m . f
06:56:17 <oerjan> heh
06:56:25 <oerjan> @src (->) fmap
06:56:26 <pseudobot> fmap = (.)
06:56:46 <ari> :t local
06:56:53 <pseudobot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
06:56:58 <oerjan> local is flip (.)? that might be useful sometimes
06:57:49 <swiert> mattam: theories/Program doesn't exist in my distribution.
06:58:03 <swiert> mattam: any ideas where it lives?
06:58:09 <oerjan> in a twisted, evil way.
06:59:14 <Sizur> @pl (\n->intercalate "/" ["a",n])
06:59:14 <pseudobot> intercalate "/" . ("a" :) . return
06:59:46 <oerjan> return from the list monad, = (:[])
06:59:47 <Sizur> a little mind bending
07:00:03 <pejo> loupgaroublond, I'd look for some bindings to a c-library instead. The stuff you're asking for isn't exactly platform independent.
07:00:06 <oerjan> for some reason @pl uses it instead
07:00:51 <loupgaroublond> pejo: where could i find a c-library binding like that, then? or is it mainly a roll my own affair?
07:00:54 <oerjan> :t intersperse
07:01:01 <pseudobot> forall a. a -> [a] -> [a]
07:01:14 <oerjan> i think you want intersperse not intercalate
07:01:39 <Nafai> Hey byorgey!
07:01:40 <Sizur> i'm using pathSeparator and it's a char
07:01:50 <byorgey> hi Nafai! happy new year!
07:01:50 <mux> :t intercalate
07:01:50 <oerjan> intercalate is [a] -> [a] -> [a] iirc (and not yet in lambdabot)
07:01:55 <Sizur> the dirs are strings
07:01:57 <pseudobot> Not in scope: `intercalate'
07:02:01 <mux> [a] -> [[a]] -> [a]
07:02:09 <mux> try with lambdabot42 ;-)
07:02:14 <Nafai> Happy New Year to yourself as well!
07:02:32 <oerjan> oh
07:03:07 <byorgey> Nafai: what's new?
07:03:07 <oerjan> oh you're right
07:03:27 <Nafai> Not much, really.
07:03:34 <Nafai> Back to work after almost 2 weeks off :/
07:04:02 <byorgey> oh. well, I hope the time off was nice at least. =)
07:04:33 <Nafai> Yeah, it was
07:05:42 <Sizur> :t intercalate "/" . ("a" :) . return
07:05:48 <pseudobot> Not in scope: `intercalate'
07:06:01 <Sizur> :t Data.List.intercalate "/" . ("a" :) . return
07:06:08 <pseudobot> Not in scope: `Data.List.intercalate'
07:06:18 <oerjan> intercalate is new in 6.8
07:06:25 <byorgey> Data.List.intercalate "/" . ("a" :) . return :: [Char] -> [Char]
07:06:54 <Sizur> :t (&&&)
07:07:00 <pseudobot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:07:23 <oerjan> :t (&&&).(.id)
07:07:30 <pseudobot> forall c' c a. (a -> c) -> (a -> c') -> a -> (c, c')
07:07:39 <Sizur> ugh
07:07:42 <oerjan> (trick to force -> arrow)
07:07:56 <oerjan> just set a = (->)
07:08:04 <Sizur> aha
07:08:34 <byorgey> hey, neat trick oerjan =)
07:09:55 <FunctorSalad> hmm, this thing we talked about earlier works without a problem for me: "instance Monad m => Functor m where fmap f x = x >>= (return .f)"
07:10:06 <FunctorSalad> IIRC someone said it wouldn't work
07:10:26 <FunctorSalad> (for turning every Monad into a Functor)
07:11:03 <byorgey> FunctorSalad: sure, that works fine.
07:11:07 <oerjan> FunctorSalad: the problem appears the moment you try define other Functors
07:11:44 <byorgey> oh, right. that requires all Functor instances to be Monad instances as well, right?
07:11:52 <FunctorSalad> hmm, how so?
07:12:04 <oerjan> that instance will overlap with all others
07:12:05 <Sizur> because m stands for anything
07:12:18 <byorgey> the => notation is misleading.  It *looks* like it means "whenever m is a Monad, m is also a Functor"
07:12:30 <Sizur> anything that is a Monad, so it will overlap only with other monads
07:12:36 <Sizur> why?
07:12:44 <byorgey> but it *actually* means, "any m is a Functor", and generates an additional constraint for the type checker that m must also be a Monad.
07:12:54 <FunctorSalad> are you referring to the case when you have a Monad and want to make it a Functor but make its fmap work differently?
07:13:11 <byorgey> so the implication as far as the type checker is concerned goes the opposite way from what the => notation would suggest.
07:13:13 <oerjan> no, i am referring to the case of a Functor which isn't a Monad at all
07:13:34 <pejo> loupgaroublond, hackage.haskell.org might have some. I'm not familiar with any c-libraries that does it either though, would probably be easier to find what you're looking for if you know any names.
07:13:42 <oerjan> the part before => is only checked _after_ deciding which instance to use
07:13:43 <Sizur> what's the reason for this implementation?
07:13:57 <loupgaroublond> pejo: hackage is fresh out, that's why i asked :)
07:15:22 <oerjan> Sizur: something technical i'm sure
07:16:33 * oerjan bets on "confluence" being involved
07:17:27 <oerjan> i.e. that it ensures the result doesn't depend too fragilely on the order the type checker resolves things
07:18:42 <mattam> It's a design choice. First-match would be another possibility.
07:19:02 <Sizur> but he can enable overlapping, right? then the most specific instance will be selected. should this work?
07:19:38 <oerjan> Sizur: it might, but iirc there are cases when things get selected too early then
07:19:51 <mattam> byorgey: take care, are you talking about the => in class or instance decls ?
07:20:24 <oerjan> that's just my vague recall from discussions though
07:20:39 <byorgey> mattam: hm, good point. I'm talking about the => in instance declarations.  I still don't think I totally understand => in class declarations. =)
07:21:14 <FunctorSalad> oerjan: tried it out, you're right :(
07:21:18 <mattam> left of => in classes is superclasses, left of => in instances is typeclass constraint as in usual definitions.
07:21:44 <mattam> At least that's what I think the semantics are.
07:22:21 <mattam> So if you say instance Monad => Functor you're saying you can derive a Functor from any Monad instance.
07:22:53 <Sizur> which is the intended meaning
07:23:57 <byorgey> mattam: yes, but the point is that the instance is selected *without regard to* the Monad constraint.  The Monad constraint is only checked *after* the instance is selected.
07:23:57 <mattam> But the way the typechecker does instance search is not entirely compatible with this semantics it seems.
07:24:08 <byorgey> right.
07:25:15 <mattam> That's the semantics I implemented in Coq for instance search. It does backtracking and returns the first "totally" matching instance.
07:25:43 <byorgey> mattam: interesting, so the order of instance declarations matters then?
07:25:51 <mattam> I can understand why it's restricted in haskell, having backtracking in the type checker would be weird.
07:25:56 <mattam> Yes.
07:26:07 <byorgey> actually, I don't know whether the order matters in Haskell.
07:26:33 <conal> type-checking is already close to (higher-order) logic programming.  backtracking seems pretty natural to me.
07:26:36 <byorgey> maybe it does if you turn on overlapping- or -undecidable instances?
07:26:37 <mattam> You could always tweak the algorithm by declaring fixed priorities but I didn't need that yet.
07:26:48 <mattam> Probably.
07:26:54 <Sizur> ditto conal
07:26:56 <FunctorSalad> does this mean that if I implement a class A that is a subclass of a library class B, I can't express that?
07:27:11 <FunctorSalad> *implement should be "define"
07:27:16 <byorgey> FunctorSalad: sure you can.
07:27:38 <byorgey> class (Foo a) => Bar a where...
07:27:47 <byorgey> then any instances of Bar are required to also be instances of Foo.
07:28:22 <mattam> conal: i don't know precisely how typechecking works in ghc these days. Isn't it based on unification and generalization a la HM(X) ?
07:28:37 <Sizur> and why Monad constraint is so special?
07:29:11 <conal> mattam: i hear it's getting more & more constraint-oriented.  so probably easier & easier to switch to something like Lambda-Prolog.
07:29:18 <byorgey> Sizur: hm?
07:29:50 <FunctorSalad> byorgey: sorry, stated it in the wrong way. I wanted to say that some library class is a subset of my class
07:30:03 <Sizur> if i can do Foo a => Bar a, why Monad a => Functor a doesnt work
07:30:05 <mattam> Is typeclass search done at the same time as type-checking or just after ?
07:30:11 <roconnor> mattam: oh neat, the definition of Acc changed between 8.0 and 8.1
07:30:12 <byorgey> FunctorSalad: aha, no, currently you can't do that.
07:31:00 <mattam> roconnor: more parameters i guess, it's doesn't change much.
07:31:24 <roconnor> mattam: it now takes advantage of this new non-uniform parameters
07:31:27 <byorgey> FunctorSalad: there are various proposals floating around to make it possible.
07:31:40 <FunctorSalad> some ghc switch maybe?
07:31:45 <Sizur> a friend of mine implemented lambdas in prolog a few weeks ago
07:31:58 <byorgey> FunctorSalad: well, it would require changes in syntax.
07:32:10 <roconnor> mattam: I'm trying to come up with an Epigram2 definition of Acc. ... not that I'm likely to succeed.
07:32:18 <mattam> roconnor: don't you love it ?
07:32:33 <oerjan> Sizur: are you talking instance or class declaration there?
07:32:48 <roconnor> mattam: love what?
07:33:02 <oerjan> class Functor a => Monad a _could_ work.  it would just require adding more work to define a Monad instance
07:33:05 <Sizur> oerjan: instance, but i know the answer already
07:33:46 <Sizur> if anybody's interested: http://ha4.fajno.net/2007/12/14/simple-lambda-calculus-in-prolog
07:33:47 <pseudobot> Title: Ha4: Simple Lambda Calculus in Prolog
07:34:13 <mattam> roconnor: non-uniform parameters
07:34:54 <glen_quagmire> should I use http://darcs.haskell.org/alsa-midi/  or http://code.haskell.org/alsa/  ?
07:34:55 <pseudobot> Title: Index of /alsa-midi
07:35:05 <roconnor> mattam: I like to think they came out of the discussion that George and I had on the Coq mailing list a few years ago.
07:35:09 <shag> can i specify a constraint for an IO action? like foo :: Foobar b => a -> IO b
07:35:41 <roconnor> mattam: I wanted them to do variable binding using nested data types
07:35:48 <gbacon> @src CalendarTime Read
07:35:49 <pseudobot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
07:35:55 <roconnor> mattam: I'm surprised to seem them used elsewhere, like in Acc.
07:36:31 <oerjan> shag: sure, it's just a normal type
07:36:33 <roconnor> mattam: so I started with something simpler than Acc.  I tried to defined And.
07:36:37 <shag> beacuse if i do that, i get complaints from ghc in which it seems to treat b not really as type variable...
07:36:50 <matthew-_> ok, ghc 6.8 supports stand-alone derivings right?
07:36:51 <oerjan> shag: paste?
07:36:56 <oerjan> !paste
07:36:56 <hpaste> Haskell paste bin: http://hpaste.org/
07:36:56 <shag> oerjan: mompl
07:37:02 <roconnor> mattam: I've come up with And p1 p2 := forall b:bool, if b then p1 else p2
07:37:20 <roconnor> mattam: Acc is much harder.
07:37:20 <vincenz> test
07:37:31 <hpaste>  shag pasted "(no title)" at http://hpaste.org/4763
07:37:49 <shag> oerjan: ^^
07:38:05 <gbacon> argh.. doesn't the Read instance for CalendarTime support ISO 8601?
07:38:13 <oerjan> shag: er your code too
07:38:24 <mattam> roconnor: :)
07:39:32 <mattam> roconnor: non-uniform parameters are useful for datastructures too, like bintree A := leaf | node : bintree (A * A) -> bintree A.
07:39:39 <gbacon> > read "2008-01-02T01:02:03.456Z" :: CalendarTime
07:39:42 <pseudobot>   Not in scope: type constructor or class `CalendarTime'
07:39:43 <oerjan> shag: seems like the inferred type of your action is more restrictive than your declared type
07:39:54 <gbacon> > read "2008-01-02T01:02:03.456Z" :: System.Time.CalendarTime
07:39:56 <pseudobot>      Not in scope: type constructor or class `System.Time.CalendarTime'
07:40:06 <shag> oerjan: http://hpaste.org/4764
07:40:47 <oerjan> shag: ah.  haskell types don't work that way
07:41:09 <roconnor> mattam: that's a strange way of doing binary trees
07:41:10 <shag> oerjan: this "loadFromFile" is a method required by the class
07:41:25 <gbacon> > read "2008-01-02T01:02:03Z" :: System.Time.CalendarTime
07:41:27 <oerjan> loadIndex :: HolIndex i => Flag -> IO i
07:41:28 <pseudobot>      Not in scope: type constructor or class `System.Time.CalendarTime'
07:41:36 <roconnor> mattam: wait, are those binary tree alway full?
07:41:38 <mattam> complete binary trees actually
07:41:41 <oerjan> means loadIndex must work for _all_ i
07:41:56 <roconnor> mattam: shit! someone was asking about that a week ago
07:42:16 <roconnor> mattam: I was trying to find a haskell 98 way of doing it with non-uniform parameters
07:42:23 <roconnor> but i couldn't come up with one.
07:42:24 <shag> oerjan: doesnt that mean "i is some type which is instance of HolIndex"?
07:42:43 <mattam> That's the beauty of it. You can impose lots of regularity with such indexes without the pain of real arguments.
07:42:46 <oerjan> shag: no it means for _all_ types which are instances of HolIndex
07:43:01 <oerjan> including instances not defined yet...
07:43:08 <shag> hm..
07:43:20 <mattam> roconnor: and you asked for it ! :)
07:43:22 <oerjan> shag: you probably must make loadIndex a method too
07:43:39 <oerjan> or wait...
07:44:28 <shag> oerjan: then i could just use the loadFromFile method. i just need some place where i can explicitly use one of the HolIndex instances
07:44:57 <roconnor> data CompleteBinTree A = Leaf A | Node (CompleteBinTree (A,A))
07:45:28 <oerjan> gah, my brain isn't working
07:46:06 <shag> oerjan: if i omit the explicit type specifications (:: InvIndex) then GHC doesn't know which loadFromFile to use (because it is a method, too)
07:46:33 <oerjan> shag: the problem is that the choice of which i to use is _runtime_
07:46:41 <glen_quagmire> is there a way to detect OS during compilation time and compile different files as same module?  linux/Midi.hs   windows/Midi.hs    as  Sound.Midi module
07:46:44 <shag> yes, exactly :)
07:47:09 <roconnor> @seen r3m0t
07:47:10 <pseudobot> I haven't seen r3m0t.
07:47:15 <roconnor> of course not
07:47:21 <oerjan> shag: so you have a function whose type depends on a value, which is not allowed
07:47:40 <oerjan> you may want existential types perhaps
07:48:04 <Saizan> glen_quagmire: the most common way is to use cpp
07:48:42 <shag> hmmh. i just realized the dimension of this problem now ...
07:48:44 <oerjan> actually, it all depends on how you intend to be able to _use_ the returned InvIndex or HybIndex i think
07:49:21 <shag> well, i have a bunch of functions which all take something like (HolIndex i => i)
07:50:00 <oerjan> um, for a specific i each?
07:50:20 <shag> no. theyre all generalized to work with the methods from the class
07:50:51 <glen_quagmire> Saizan: so cpp is assumed to be installed?
07:51:07 <oerjan> well loadIndex alone does not seem to fit
07:51:25 <glen_quagmire> in, Sound/Midi.hs   #ifdef WIN32 ...  is that what you meant Saizan?
07:51:33 <roconnor> mattam: how about we add Acc as a primative to epigram2 :)
07:51:45 <Saizan> glen_quagmire: yes, something like that
07:51:59 <mattam> lol
07:52:09 * glen_quagmire searches for example
07:52:49 <oerjan> but if you define an existential data AnyHolIndex = forall i. HolIndex i => AnyHolIndex i
07:53:06 <oerjan> then you could make loadIndex return IO AnyHolIndex instead
07:53:54 <oerjan> whether that fits into the rest of your program i don't know
07:53:59 <shag> sure.
07:54:40 <shag> well, this is during startup of the program. the program basically gets a filename from which it should load the index. and the type is determined by some command line option
07:55:26 <shag> so the program needs to decide depending on the commandline opt which type of index to load through the loadFromFile function.
07:56:02 <shag> hmhm. perhaps it would be the best to remove loadFromFile from the class
08:00:55 <Saizan> deciding the type of something at runtime requires a bit of type hackery
08:08:01 <matthew-_> with multiple threads in ghc's runtime, if the "main" thread finishes before the others, is the process killed first, or does any non-dead thread prevent the process finishing?
08:08:52 <conal> matthew-_: hm.  there's an answer on the Control.Concurrent haddock page.
08:09:03 * conal looks
08:09:17 <conal> i think: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#9
08:09:19 <pseudobot> http://tinyurl.com/y2q5k2
08:09:51 <conal> "In a standalone GHC program, only the main thread is required to terminate in order for the process to terminate. Thus all other forked threads will simply terminate at the same time as the main thread (the terminology for this kind of behaviour is "daemonic threads")."
08:10:06 <matthew-_> gotcha. Thanks
08:10:13 <conal> plus example of how to implement waiting for child threads
08:10:26 * conal happened to read that page recently
08:10:31 <matthew-_> yep.
08:12:02 <conal> mmmdonuts: nice nick!
08:12:45 <mmmdonuts> conal: thanks!
08:19:29 <matthew-_> you know you're in trouble when you're writing "liftM (liftM (flip (,) mv)) $ ..."
08:20:19 <conal> matthew-_: you certainly are when "(fmap.fmap.flip (,) mv) ... "  would do!
08:20:28 <conal> ;)
08:20:52 * vincenz wonders what monad the internal one is
08:20:56 <matthew-_> yeah... I can never remember, is fmap or liftM the current style de jour?
08:21:03 <vincenz> ap!
08:21:08 <conal> no!
08:21:10 <conal> <*>
08:21:15 <vincenz> <$>
08:21:16 <matthew-_> oh yes, applicative
08:21:18 <conal> matthew-_: fmap & <$>
08:21:33 <byorgey> matthew-_: fmap is more general, hence preferred
08:21:38 * mux is fond of `fmap` because it's in Prelude
08:21:46 <vincenz> Of course
08:21:51 <vincenz> If you want to be as generic as possible
08:21:57 <vincenz> You use the -everything- operator:    .
08:22:20 <byorgey> flip (,) mv <$$> ... perhaps?  with <$$> = fmap.fmap
08:22:32 <byorgey> that's not standard but I use it now and then
08:23:03 <conal> i prefer (fmap.fmap) because it's clear how it extends.
08:23:13 <conal> but really i prefer "result.result"
08:23:15 * vincenz keeps reading that as something else
08:23:21 <conal> and mixing with first & second
08:26:23 <ricky_clarkson> > "anybotyet?"
08:26:28 <matthew-_> No instance for (Error ConnError)
08:26:32 <matthew-_> you've got to be kidding me
08:35:58 <shachaf> @bot pseudobot?
08:35:59 <pseudobot> :)
08:36:09 <shachaf> @ty 1
08:36:15 <pseudobot> forall t. (Num t) => t
08:36:24 * shachaf assumes this is a problem with @run specifically.
08:36:38 <byorgey> @run 1 + 1
08:36:40 <shachaf> I had the same thing when compiling lambdabot before.
08:36:41 <pseudobot> Plugin `eval' failed with: Data.ByteString.last: empty ByteString
08:36:54 <byorgey> @run > 1 + 1
08:36:55 <pseudobot>   parse error on input `>'
08:37:03 <mux> > 1 + 1
08:37:04 <shachaf> @run 1
08:37:06 <lambdabot42>  2
08:37:07 <lambdabot42>  1
08:37:08 <pseudobot> Plugin `eval' failed with: Data.ByteString.last: empty ByteString
08:37:16 <byorgey> @bot
08:37:16 <pseudobot> :)
08:37:16 <lambdabot42> :)
08:37:18 <mux> you can use my lambdabot temporarily I guess
08:37:22 <shachaf> lambdabot42: @version
08:37:22 <lambdabot42> lambdabot 4p584, GHC 6.8.2 (FreeBSD i386)
08:37:22 <lambdabot42> darcs get http://code.haskell.org/lambdabot
08:37:24 <pseudobot> Title: Index of /lambdabot
08:37:25 <mux> at least it works :-)
08:37:32 <shachaf> 6.8.2? How did you get that to work?
08:37:38 <mux> with lots of sweat
08:37:47 <mux> and a bit of help from caust1c`
08:37:50 <mux> oops, I meant Cale
08:37:53 <Japsu> erm how many lambdabots are there now
08:37:56 <Japsu> @botsmack
08:37:56 <lambdabot42> :)
08:37:57 <pseudobot> :)
08:37:57 <shachaf> mux: Did you keep the information somewhere?
08:38:07 <mux> shachaf: it's hot in my head if you want to ask :-)
08:38:27 * shachaf had kappabot, but couldn't get everything working enough to @join.
08:38:43 <mux> > (intercalate " " . map return) "happy new year!!"
08:38:46 <lambdabot42>  "h a p p y   n e w   y e a r ! !"
08:38:46 <pseudobot>   Not in scope: `intercalate'
08:38:53 <byorgey> mux: I get the feeling that many people would love you if you wrote it up quick on the wiki =)
08:38:57 <shachaf> mux: Not at the right computer right now -- any chance of writing it down somewhere?
08:39:17 <mux> byorgey: I'm not short of things to do if I want people to love me, I'm short on free time ;-)
08:39:21 * shachaf would figure it out otherwise -- he didn't have that much time to work on it.
08:39:27 <mux> shachaf: nope, sorry
08:39:29 <allbery_b> lopbot works but doesn't hav the runplugs stuff
08:39:30 <byorgey> mux: heh, I understand that =)
08:39:33 <mux> at least not anytime soon
08:39:44 <shachaf> mux: Did you have to apply any strage patches?
08:39:53 <mux> I had to hack some code quite a bit
08:39:58 <allbery_b> (actually it has runplugs support, but none of the haskell-support plugins are enabled)
08:40:05 <mux> especially Plugin/Dummy/DocAssocs.hs
08:40:12 <mux> and State/Pristine.h
08:40:22 <mux> and others I have forgotten about
08:40:34 <mux> whose bot is pseudobot?
08:40:38 * shachaf got hs-plugins working with 6.9.20071213.
08:40:45 <shachaf> mux: Pseudonym? :-)
08:40:51 <byorgey> someone should make a nice, cutting-edge version of lambdabot for a SoC project next summer.
08:40:57 <rotondo> why
08:41:12 <byorgey> how
08:41:15 <mux> I only wish LB would reconnect when it gets timed out of an IRC server
08:41:30 <rotondo> mux: you're wrong
08:41:49 <mux> I can't say I'm not
08:41:49 <shachaf> rotondo: Llama?
08:41:50 <olsner> how do you make lambdabot's edge more cutting than it already is?
08:42:04 <mux> when it's stated so out of the blue
08:42:18 <rotondo> shachaf: what have lamas got to do with it?
08:42:29 <mux> rotondo: what is this all about?
08:43:14 <shachaf> rotondo: With what?
08:43:36 <rotondo> you asked "Llama"
08:43:58 <shachaf> rotondo: And you asked "why" (I assume you asked, anyway).
08:43:58 <byorgey> olsner: I mean, so it compiles with the latest GHC and so on.
08:45:02 <rotondo> and why did you ask llama
08:45:10 <mux> and why am I wrong?
08:45:14 <shachaf> Why did you ask "why"?
08:45:21 <mux> I did not.
08:45:30 * mux adds some more confusion just for fun
08:45:31 <mmmdonuts> who?
08:45:49 <shachaf> @babel en he why
08:45:49 <lambdabot42> Plugin `babel' failed with: Error: Language he not supported
08:45:49 <pseudobot> Plugin `babel' failed with: Error: Language he not supported
08:46:23 <mux> I'd really like to leave lambdabot42 here since pseudobot isn't working properly, but if the owner isn't here, it's just causing massive annoyance
08:46:34 <rotondo> bechause you are always wrong, mux
08:46:51 <rotondo> why did you ask llama, shachaf?
08:47:03 <idnar> what the heck are you people talking about?
08:47:12 <shachaf> rotondo: You asked "why" first -- why?
08:47:17 <mux> nothing, this guy just joined the channel and is talking nonsense
08:47:30 <rotondo> why is always a good question
08:47:34 <mux> smells like a big filthy troll
08:47:37 <rotondo> mux sucks
08:47:43 <mux> with way too much free time on his hands
08:47:44 <idnar> oh, I see
08:47:45 <byorgey> rotondo: if you are here to learn or talk about Haskell, then welcome.  If you are here to make ad hominem attacks just for "fun" and talk nonsense, then I suspect you will get kicked.
08:48:02 <rotondo> byorgey sucks
08:48:09 <mux> idnar: see? :)
08:48:12 <byorgey> =D
08:48:15 --- mode: ChanServ set +o allbery_b
08:48:20 <rotondo> byorgey sucks
08:48:25 <rotondo> byorgey sucks
08:48:29 <rotondo> byorgey sucks
08:48:29 <mux> rotondo is leaving
08:48:31 <byorgey> have a nice day, rotondo
08:48:33 <mux> bye!
08:48:36 <rotondo> byorgey sucks
08:48:41 <rotondo> byorgey sucks
08:48:41 --- kick: rotondo was kicked by allbery_b (allbery_b)
08:48:52 <shachaf> ????
08:49:12 --- mode: ChanServ set +o vincenz
08:49:21 --- mode: vincenz set -o vincenz
08:49:22 <allbery_b> ban list is full
08:49:33 --- mode: allbery_b set -o allbery_b
08:49:48 <matthew-_> um, do I take it that you can never have read :: String -> [String] ?
08:50:03 <Saizan> matthew-_: why not?
08:50:05 <byorgey> matthew-_: why not?
08:50:09 <mux> > read "[1,2,3]" :: [Int]
08:50:11 <shachaf> > read "[\"a\",\"b\"]" :: [String]
08:50:12 <lambdabot42>  [1,2,3]
08:50:12 <thoughtpolice> conal: wow, just looking at phooey and it's really neat stuff. :) just wondering on the wiki page though, you say phooey is built on DataDriven, but it requires reactive as a dependency in the cabal file. does reactive fully contain datadriven's ability and more? if so i think it's a err on the wiki page
08:50:14 <lambdabot42>  ["a","b"]
08:50:23 <matthew-_> ahh, the Show instance is wrong. ta
08:50:35 <byorgey> > show ["a","b"]
08:50:37 <lambdabot42>  "[\"a\",\"b\"]"
08:50:42 <byorgey> it is?
08:50:51 <matthew-_> byorgey: it is in what I'm doing ;)
08:51:00 <byorgey> matthew-_: oh. =)
08:51:02 <idnar> > show ["\"", "\\\""]
08:51:03 <vincenz> > 1
08:51:06 <lambdabot42>  "[\"\\\"\",\"\\\\\\\"\"]"
08:51:06 <lambdabot42>  1
08:52:00 <idnar> @bot
08:52:01 <lambdabot42> :)
08:52:01 <pseudobot> :)
08:52:12 <shachaf> > fix (show . (:[]))
08:52:14 <vincenz> One bot please
08:52:15 <lambdabot42>  "[\"[\\\"[\\\\\\\"[\\\\\\\\\\\\\\\"[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"[\\\\\\\...
08:52:25 <yrlnry> Cool!
08:52:26 <vincenz> Can pseudobot be removed, please?
08:52:51 <shachaf> @seen Pseudonym
08:52:52 <lambdabot42> I haven't seen Pseudonym.
08:52:52 <pseudobot> I saw Pseudonym leaving #haskell-blah and #haskell 4h 20m 24s ago, and .
08:53:02 <vincenz> pseudobot: @leave #haskell
08:53:09 <byorgey> oh, haha =)
08:53:14 <mux> heh, fine
08:53:15 * vincenz has ops in lambdabot
08:53:31 <mux> if lambdabot42 becomes an issue because the "real one" comes back, please just kick it out guys
08:53:37 <mux> I'm leaving
08:53:43 <vincenz> thx mux
08:53:50 <mux> my pleasure
08:54:20 <byorgey> lambdabot withdrawal is not a pretty thing.
08:55:08 <desegnis> lambdabot42: You don't respond to /msg or /query :(
08:55:18 <vincenz> desegnis: obvious
08:55:23 <vincenz> lambdabot42 is probably not identified
08:55:43 <desegnis> ah
08:56:07 <shachaf> /msg nickserv set unfiltered on -- I'd guess.
08:56:14 <shachaf> To make lambdabot42 work.
08:56:18 <vincenz> nod
09:05:52 <wolverian> @where hlist
09:05:52 <lambdabot42> http://homepages.cwi.nl/~ralf/HList
09:06:11 <wolverian> @where+ hlist http://darcs.haskell.org/HList/
09:06:11 <lambdabot42> Okay.
09:13:56 <matthew-_> :set +s measures CPU time only doesn't it?
09:22:55 <roconnor> ``the GNU C library qsort function is actually mergesort if the C library thinks the computer has enough free memory
09:57:56 <wolverian> okay, I'm about to give up on hlist. I just don't understand it, without any docs.
10:05:26 <glguy> ?seen dons
10:05:27 <lambdabot42> dons is in #haskell. I don't know when dons last spoke.
10:08:12 <ricky_clarkson> Can #scala have it too?
10:08:29 <ricky_clarkson> (lambdabot is normally there)
10:11:25 <EvilTerran> wolverian, i found the paper quite helpful, if a bit dense
10:33:13 <laz0r> hi, everybody, i have a somehow haskell unrelated question: is the sauerbraten server, that has www.haskell.org in its description line somehow related to you guys?
10:34:12 <roconnor> sauerbraten?
10:34:22 <laz0r> aka cube2
10:34:30 <laz0r> its an oss fps like game
10:35:18 <laz0r> the great thing about is that you can create maps cooperativly, in mutliplayer
10:35:50 <laz0r> thats really fun, but is problematic because of the... 'lame' users out there
10:36:28 <DuClare> the way you build maps is rather slick. one of the easiest map editors I've seen.
10:36:36 <DuClare> and yea, fun too.
10:36:43 <laz0r> and there is a server, in coopedit mode, that has the description 'www.haskell.org'
10:37:02 <laz0r> ah, so that server is run by some guys from here?
10:37:17 <shachaf> laz0r: Perhaps they like Haskell?
10:38:16 <allbery_b> you might do better by asking them
10:38:39 <shachaf> (Liking Haskell is entirely understandable, though.)
10:38:46 <laz0r> their server is set to private, and i had hoped i could maybe gain entrance by contacting them here....
10:43:59 <gbacon> I have addSeconds :: Rational -> String
10:44:23 <gbacon> but I'm getting an exception trying addSeconds (read "0.00")
10:44:59 <gbacon> I'm trying to use Data.Time.addUTCTime
10:45:25 <byorgey> > read "0.00" :: Rational
10:45:26 <gbacon> and generating NominalDiffTime values is giving me trouble
10:45:27 <lambdabot42>  Exception: Prelude.read: no parse
10:45:27 <allbery_b> I think you need to use 0%0 format
10:45:40 <allbery_b> or coerce the result to Rational
10:45:41 <byorgey> 0%1, you mean =)
10:45:44 <allbery_b> yeh
10:46:48 <gbacon> without fromRational, the typechecker complains that there's no Read NominalDiffTime
10:48:17 <gbacon> my input has 0.00
10:48:31 <gbacon> I want to add a real number of seconds to some base time
10:50:38 <gbacon> grrrr
10:54:14 <allbery_b> I see NominalDiffTime is Enum, so you should be able to coerce values with toEnum/fromEnum
10:56:25 <gbacon> but fromEnum is a -> Int
10:56:38 <gbacon> my deltas have real values
10:57:20 <gbacon> it's an instance of Num, Real, RealFrac, et al.
10:59:13 <gbacon> but if I try addSecods :: Num a ... for example, the typechecker barfs
11:00:13 <roconnor> > toRational (read "0.00")
11:00:15 <lambdabot42>  Exception: Prelude.read: no parse
11:02:25 <gbacon> this is perverse
11:04:02 <roconnor> > toRational (read "0.00"::Double)
11:04:05 <lambdabot42>  0%1
11:04:10 <roconnor> > toRational (read "0.00001"::Double)
11:04:12 <lambdabot42>  5902958103587057%590295810358705651712
11:04:18 <roconnor> > toRational (read "0.000000000000000001"::Double)
11:04:20 <lambdabot42>  1298074214633707%1298074214633706907132624082305024
11:04:29 <roconnor> > toRational (read "1.00000000000000000001"::Double)
11:04:31 <lambdabot42>  1%1
11:04:34 <roconnor> :/
11:04:41 <gbacon> ok, so it typechecks as addSeconds :: Double -> String
11:04:45 <roconnor> there must be something better in Numeric
11:04:53 <gbacon> but I have to fromRational . toRational
11:05:11 <roconnor> > (readFloat "1.00000000000000000001")::Rational
11:05:12 <lambdabot42>  Couldn't match expected type `Rational'
11:05:33 <gbacon> but why in ghci can I say 3.14 :: NominalDiffTime, and everything's happy?
11:05:43 <roconnor> > (readFloat "1.00000000000000000001")::(Rational,String)
11:05:45 <lambdabot42>  Couldn't match expected type `(Rational, String)'
11:05:48 <roconnor> > (readFloat "1.00000000000000000001")::[(Rational,String)]
11:05:51 <lambdabot42>  [(100000000000000000001%100000000000000000000,"")]
11:05:57 <roconnor> :)
11:06:24 <roconnor> > (fst . head . readFloat) "1.00000000000000000001"::Rational
11:06:26 <lambdabot42>  100000000000000000001%100000000000000000000
11:06:38 <roconnor> gbacon: there you go
11:06:54 <gbacon> roconnor: thanks
11:07:06 <gbacon> but why is all the chicanery necessary?!
11:07:13 <roconnor> gbacon: sucks that it isn't easier.
11:07:37 <monochrom> :t readFloat
11:07:39 <lambdabot42> forall a. (RealFrac a) => String -> [(a, String)]
11:08:11 <gbacon> ooh
11:09:07 <roconnor> is nominalDiffTime part of the new time package?
11:09:49 <roconnor> > (fst . head . readFloat) "1.00000000000000000001"::NominalDiffTime
11:09:50 <gbacon> it's in Data.Time.Clock.UTC
11:09:51 <lambdabot42>      Not in scope: type constructor or class `NominalDiffTime'
11:10:13 <roconnor> anyhow, you shouldn't even need the fromRational
11:10:15 <monochrom> Clearly, ghci has a better parser than read.
11:10:28 <roconnor> NominalDiffTime is an instance of RealFrac
11:10:51 <roconnor> @type 1.01
11:10:52 <lambdabot42> forall t. (Fractional t) => t
11:11:00 <allbery_b> > (fst . head . readFloat) "1.00000000000000000001"::Data.Time.Clock.UTC.NominalDiffTime
11:11:01 <lambdabot42>      Not in scope:
11:11:01 <lambdabot42>       type constructor or class `Data.Time.Clock.UTC.Nomin...
11:11:04 <allbery_b> bah
11:11:58 <gbacon> no, if I drop fromRational, it doesn't typecheck
11:12:21 <roconnor> gbacon: I think it ought to.
11:12:25 <roconnor> paste the code?
11:13:38 <hpaste>  gbacon pasted "addSeconds" at http://hpaste.org/4765
11:14:34 <hpaste>  gbacon annotated "addSeconds" with "added dummy value" at http://hpaste.org/4765#a1
11:15:09 <roconnor> gbacon: where is your (fst . head . readFloat) ?
11:15:39 <gbacon> I'm calling addSeconds (read ...)
11:16:22 <roconnor> gbacon: I thought addSeconds was going to take a Rational
11:16:28 <monochrom> realToFrac = fromRational . toRational ?
11:17:14 <roconnor> damn it, mozilla always crashes
11:17:21 <roconnor> gbacon: one sec
11:20:14 <hpaste>  roconnor annotated "addSeconds" with "version using readFloat" at http://hpaste.org/4765#a2
11:22:46 <roconnor> gbacon: ^^
11:22:55 <gbacon> roconnor: thanks
11:23:06 <gbacon> roconnor: but why is all the hoop-jumping necessary?
11:23:59 <roconnor> gbacon: one sec
11:24:20 <roconnor> okay
11:24:44 <roconnor> anyhow usually the read instance only parse the output of show
11:25:05 <roconnor> A case could be made that we ought to extend the behavour of Read
11:25:27 <gbacon> then what's ghci doing?
11:26:16 <gbacon> I can say 3.14 :: NominalTimeDiff, and ghci replies with 3.14s
11:26:25 <gbacon> so it's running through NTD's show
11:26:32 <roconnor> in haskell floating point literals like 3.14 are always interpreted as (fromRational (314%100))
11:26:49 <gbacon> ah
11:27:05 <yrlnry> @type 3
11:27:07 <lambdabot42> forall t. (Num t) => t
11:27:11 <yrlnry> @type (%)
11:27:13 <lambdabot42> forall a. (Integral a) => a -> a -> Ratio a
11:27:16 <gbacon> @ty 3.14
11:27:17 <roconnor> @type 3.14
11:27:18 <lambdabot42> forall t. (Fractional t) => t
11:27:20 <lambdabot42> forall t. (Fractional t) => t
11:27:41 <roconnor> @type fromRational
11:27:42 <lambdabot42> forall a. (Fractional a) => Rational -> a
11:27:50 <roconnor> @type (fromRational (314%100))
11:27:52 <lambdabot42> forall a. (Fractional a) => a
11:28:16 <a2dk> Any good examples of using the list monad for backtracking? I'm trying to learn monads and keep reading that the list monad can be used for backtracking.
11:30:29 <byorgey> > [1..100] >>= \x -> [x..100] >>= \y -> [y..100] >>= guard (x^2 + y^2 == z^2) >> return (x,y,z)
11:30:30 <lambdabot42>   Not in scope: `z'
11:30:39 <byorgey> > [1..100] >>= \x -> [x..100] >>= \y -> [y..100] >>= \z -> guard (x^2 + y^2 == z^2) >> return (x,y,z)
11:30:41 <lambdabot42>  [(3,4,5),(5,12,13),(6,8,10),(7,24,25),(8,15,17),(9,12,15),(9,40,41),(10,24,2...
11:30:47 <byorgey> a2dk: how about that?
11:30:59 <pjd> a2dk: the list monad doesn't do backtracking, so much as trying all possibilities in parallel
11:31:49 <pjd> (modulo laziness)
11:32:15 <sarehu_> a2dk: of course there is a cuter way to write that
11:32:20 <sarehu_> with do notation
11:32:28 <a2dk> Yep. I'll leave as an excercise for myself :)
11:32:46 <byorgey> it can also be written as a list comprehension.
11:33:16 <hpaste>  roconnor annotated "addSeconds" with "a ``safer'' version of readFloat" at http://hpaste.org/4765#a3
11:33:51 <gbacon> roconnor: thanks for your help
11:34:45 <roconnor> gbacon: that version crashes more often on bad input.
11:35:04 <roconnor> gbacon: whether that is safer or not is a matter of opinion
11:35:28 <roconnor> gbacon: you may want to consider a String -> Maybe a version
11:35:37 <roconnor> depending on your application
11:36:08 <gbacon> roconnor: I'd really like to wrap the whole thing in ErrorT
11:36:18 <roconnor> gbacon: you may want to consider a String -> m a version
11:36:26 * gbacon nods
11:36:50 <gbacon> yeah, right now there's all kinds of case ... of boilerplate that I'd like to see disappear
11:37:35 <roconnor> do {let [(x,"")] = Numeric.readFloat; return x}
11:37:40 <roconnor> I wonder if that works
11:37:59 <gbacon> but someone (I thought it was you?) said ErrorT was overkill
11:38:21 <gbacon> dons's cpuperf is really beautiful code
11:38:25 <roconnor> let rf z = do {let [(x,"")] = readFloat z; return x} in rf "3.14" :: Maybe Rational
11:38:28 <gbacon> I'd like to mimic that style
11:38:30 <roconnor> > let rf z = do {let [(x,"")] = readFloat z; return x} in rf "3.14" :: Maybe Rational
11:38:30 <lambdabot42>  Parse error at "}" (column 52)
11:38:39 <gbacon> meeting &
11:38:49 <gbacon> roconnor: thanks again
11:38:54 <byorgey> roconnor: I think that still throws an error on pattern-match failure?
11:39:07 <roconnor> byorgey: really? that sucks.
11:39:14 <roconnor> byorgey: but also makes sense
11:39:21 <roconnor> since the let is lazy
11:40:10 <roconnor> > let rf z = do {[(x,"")] <- return (readFloat z); return x} in rf "3.14" :: Maybe Rational
11:40:13 <lambdabot42>  Just (157%50)
11:40:23 <roconnor> > let rf z = do {[(x,"")] <- return (readFloat z); return x} in rf "3.14blabla" :: Maybe Rational
11:40:25 <lambdabot42>  Nothing
11:40:28 <roconnor> :)
11:41:21 <hpaste>  roconnor annotated "addSeconds" with "monadic version of readFloat" at http://hpaste.org/4765#a4
11:42:10 <roconnor> > let rf z = do {[(x,"")] <- return (readFloat z); return x} in rf "3.14blabla" :: Either String Rational
11:42:12 <lambdabot42>  Left "Pattern match failure in do expression at <irc>:1:15-22"
11:42:45 <roconnor> I suppose one might want a better error message
11:47:13 <ulrivo> Hi. I am learning Haskell. I have a function f::a->a and want: until (init==) f (f init). If f interates often, I get a stack overflow in Hugs. Any hint?
11:48:12 <roconnor> @type until
11:48:14 <lambdabot42> forall a. (a -> Bool) -> (a -> a) -> a -> a
11:48:36 <dozer> ulrivo: what are you feeding the result of f into?
11:49:11 <ulrivo> init is of type a (f::a->a)
11:49:50 <roconnor> perhaps dozer means what are you feading the until expression into?
11:50:16 <dozer> yeah roconnor, that's more like it - not woken up after xmas hybernation
11:50:33 <ulrivo> a is something like: data Clock = Clock { m, f, h, q :: [Int] }
11:53:13 <roconnor> ulrivo: what is the implemenation of Eq?
11:53:49 <roconnor> ulrivo: something fishy is going on.  we wouldn't expect a stack overflow from what you have told us so far. :)
11:54:25 <ulrivo> Eq is just derived for Clock: ....deriving (Show, Eq)
11:55:24 <roconnor> ulrivo: the problem probably lies in what happens after the until.
11:55:54 <roconnor> or possible what is happening inside f.
11:57:12 <ulrivo> roconner: I tried different things, for instance: run 0 c = c; run n c = run (n-1) $! f c
11:57:32 <roconnor> oooh $!
11:57:34 <ulrivo> roconner: this will overflow for n = 10500
11:57:59 <ulrivo> roconner: I tried it without the $!, too
11:58:11 <roconnor> right
11:59:29 <roconnor> ulrivo: what is f?
11:59:32 <roconnor> @paste
11:59:32 <lambdabot42> Haskell pastebin: http://hpaste.org/new
11:59:40 <roconnor> maybe you should paste your code
12:01:44 <Sizur> @instances []
12:01:46 <lambdabot42> Plugin `instances' failed with: regex failed: (ReturnCode 7,"brackets ([ ]) not balanced")
12:02:18 <hpaste>  ulrivo pasted "stack overflow" at http://hpaste.org/4766
12:03:13 <ulrivo> roconnor: f is "proceed" in the code
12:04:05 <roconnor> it's the ball-clock problem :)
12:07:41 <roconnor> ulrivo: I'm mostly concerned about the k+1 in loop
12:08:07 <roconnor> try loop (k,c) = k `seq` (k+1, proceed c)
12:08:20 <roconnor> see if that helps
12:09:46 <ulrivo> roconnor: hugs will succeed now for n=30, but gets a overflow for n=45
12:09:47 <roconnor> ulrivo: if that helps, I will advise you on how I would rewrite that segment
12:10:09 <roconnor> hmm
12:10:26 <markluffel> byorgey: what's the easiest way of converting your integer-sided-triangles code above: (guard (x^2 + y^2 == z^2), etc) from searching depth-first into the z variable, to breadth-first search over x,y,z?
12:10:47 <roconnor> ulrivo: it's a start :)
12:11:43 <byorgey> markluffel: well, you could just switch around the order of the search ranges, so instead of using [1..100], [x..100], [y..100], use [1..100], [1..x], [1..y]
12:11:55 <roconnor> ulrivo: let's try one more thing
12:12:11 <roconnor> replace all your count clock + 1 with incrementCount
12:12:19 <markluffel> byorgey: is there a way to avoid the "100" there?
12:12:23 <roconnor> and define incrementCount x = x `seq` (x+1)
12:12:27 <byorgey> markluffel: and of course, for this particular example, there are much better ways to calculate pythagoren triples =)
12:12:28 <markluffel> x <- [1..]
12:12:49 <byorgey> markluffel: yup, that should work, as long as you use something like [1..x] and [1..y] for y and z
12:13:07 <byorgey> > [ (x,y,z) | x <- [1..], y <- [1..x], z <- [1..y] ]
12:13:09 <lambdabot42>  [(1,1,1),(2,1,1),(2,2,1),(2,2,2),(3,1,1),(3,2,1),(3,2,2),(3,3,1),(3,3,2),(3,...
12:13:25 <markluffel> byorgey: oh yeah, exactly
12:13:30 <roconnor> ulrivo: (I get the feeling you added this count for testing purposes)
12:15:04 <ulrivo> roconnor: you are right, because I had a bad feeling with the k+1 in loop (but can not explain) ;-)
12:15:40 <roconnor> ulrivo: the +1 idiom is often dangerous in haskell implemenations.
12:15:53 <roconnor> ulrivo: there are often ways of removing them.
12:16:09 <roconnor> ulrivo: if we succeed here we will try to remove your uses of +1.
12:17:07 <ulrivo> roconnor: I am surprised. I replaced all "count clock + 1" by "incrementCount clock", and defined incrementCount
12:17:57 <ulrivo> roconnor: this time hugs succeeds for n=30 and doesnt get a stack overflow, but the gc fails to reclaim space for n=45
12:18:29 <roconnor> interesting
12:19:01 <roconnor> ulrivo: shall we try to get rid of the +1's and then move on to the heap overflow?
12:19:05 <wolverian> EvilTerran, yeah, my problem is that I don't really understand which of the record implementations I should use, and how they map onto my use case (a few common labels on each type).
12:19:44 <ulrivo> roconnor: yes please :-) but I dont understand why +1 is dangerous
12:19:54 <roconnor> ulrivo: okay, let me explain that first
12:20:16 <roconnor> ulrivo: haskell is lazy, so what the implementaions doing are delaying the +1 until later
12:20:40 <roconnor> ulrivo: so it is keeping this huge chain of what we call thunk saying add 1 later
12:21:02 <roconnor> ulrivo: then eventually it becomes time to add 1 some number of thousands of times
12:21:31 <roconnor> ulrivo: and then that evaluation does thousands of calls and the stack grows by thousands
12:21:36 <roconnor> and then the stack overflows
12:22:02 <roconnor> the seq forces the impelemention to evaluate count, thus getting rid of the thunks.
12:22:35 <ulrivo> ulrivo: got that. thank you.
12:23:12 <EvilTerran> wolverian, i was thinking of a type-indexed list with uniqueness of element type enforced
12:23:33 <EvilTerran> with newtypes for field names, you basically get extensible records, subtyping an' all
12:23:49 <roconnor> ulrivo: step one is to get rid of (or comment out) the count
12:23:56 <roconnor> ulrivo: you are not using it for anything, right?
12:24:03 <wolverian> EvilTerran, I started to build that, then saw the extensible records in the paper and got confused about which I want.
12:24:19 <ulrivo> roconnor: you are right...it is redundant to the counting in loop
12:24:41 <roconnor> okay, so that is step 1.
12:24:49 <roconnor> now to get rid of the count in loop
12:25:02 <EvilTerran> aRecord :: (HAppearsOnce Foo r, HAppearsOnce Bar r) => r or however it works
12:25:25 <wolverian> EvilTerran, ("nextLabel" and such in the paper, I don't understand how they relate to the type-indexing)
12:25:26 <roconnor> ulrivo: we are going to change (fst $ until (\r -> queue init == (queue $ snd r)) loop (1,proceed init))
12:25:32 <EvilTerran> wolverian, yeah, you have a point; the whole thing's pretty confusing
12:25:39 <roconnor> ulrivo: we are going to replace it with ...
12:26:16 <EvilTerran> I think the nextLabel thing is something to do with run-time first-class field names. i may be mistaken, tho
12:26:31 <ulrivo> roconnor: I just deleted all stuff with count. And hugs succeeds now for n=45, too .... wow
12:26:46 <wolverian> String names instead of types as names. but the type-indexing is Typeable, too, so....
12:27:09 <wolverian> anyway, if I went with the approach I have now (type indexing), how do I query the list?
12:27:20 <roconnor> ulrivo: (length (takeWhile (\r -> queue init == queue r) (iterate proceed (proceed init))))
12:27:22 <ulrivo> roconnor: I let hugs print the garbage collection messages....they keep constant
12:28:00 <roconnor> ulrivo: I think that is right, but I may have the order of some arguments wrong.
12:28:15 <roconnor> ulrivo: length is smart enough to count without stack overflows.
12:28:38 <monochrom> the length code is highly optimized
12:29:49 <EvilTerran> well, if you have the field label newtype Foo = Foo { foo :: Int }, say, then you've got a fn foo :: Foo -> Int
12:29:55 <ulrivo> @iterate
12:29:55 <lambdabot42> Unknown command, try @list
12:30:11 <EvilTerran> the HAppearsOnce or (whatever its called) typeclass should have a method to get that one appearance out of the hlist
12:30:32 <roconnor> @type iterate
12:30:34 <lambdabot42> forall a. (a -> a) -> a -> [a]
12:30:42 <roconnor> > iterate (+1) 0
12:30:44 <lambdabot42>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
12:30:57 <EvilTerran> hGet or whatever. then foo.hGet :: HAppearsOnce Foo a => a -> Int
12:31:12 <roconnor> ulrivo: I also may have an off by 1 error in my count.
12:32:50 <ulrivo> roconnor: it works...I am impressed. you are right...by 1 and it "takeWhile (\r -> queue init /= queue r)...." instead of ==
12:33:15 <roconnor> ah oops
12:33:41 <ulrivo> roconnor: thank you very much for your help. I spend the whole afternoon and didnt understand the problem :-(
12:33:46 <roconnor> well, you can add or subtract 1 to fix it :)
12:33:59 <roconnor> ulrivo: sadly it is a common error.
12:34:13 <wolverian> EvilTerran, ah, hmm. I don't think I saw records used in the paper like that. thanks.
12:34:22 <ulrivo> roconnor: this was my first visit to #haskell. thanx again
12:34:26 <roconnor> ulrivo: it doesn't occur to much with haskell veterns because we use things like length.
12:34:29 <EvilTerran> :)
12:34:48 <EvilTerran> i think it happens in the middle of one of the impenetrable code blocks
12:34:48 <roconnor> ulrivo: but it catches novices fairly often. :(
12:35:28 <roconnor> ulrivo: notice how iterate produces an infinite list
12:35:35 <roconnor> ulrivo: this is a very common way to work in Haskell.
12:35:44 <roconnor> ulrivo: but very uncommon in other languages.
12:36:08 <ulrivo> roconnor: I had the prob with "run n c = run (n-1) $ proceed c", too. here it is the iterative (n-1), right?
12:36:23 <roconnor> hmm
12:36:46 <roconnor> ulrivo: you mean runnie in the pasted code?
12:36:53 <ulrivo> right
12:37:08 <roconnor> ulrivo: that n-1 shouldn't be a problem here
12:37:24 <roconnor> ulrivo: because the case check for 0 forces the evaluation each iteration
12:37:44 <ulrivo> roconnor: oops. but "runnie 11000 init" will overflow, too
12:37:50 <roconnor> ulrivo: then +1 is a problem when you don't use the data until later (as happens with accumlators)
12:38:27 <roconnor> ulrivo: does it still overflow now that you've removed count?
12:39:09 <ulrivo> roconnor: yep. I just tried it.
12:39:23 <roconnor> with and without the $! ?
12:39:36 <roconnor> oh right, it will won't it.
12:39:45 <ulrivo> roconnor: with $! later than with $
12:40:00 <roconnor> because it is building a huge thunk of proceeds, and not evaluating them until later
12:40:57 <roconnor> ulrivo: out of curiousity, what happens if you do  last (take 11000 (iterate proceed init)) ?
12:41:09 <roconnor> or
12:41:09 <ulrivo> roconnor: of course. First I wrote runnie....suggested the huge thunk and wrote the until loop
12:41:31 <roconnor> what happens if you do (iterate proceed init)!!11000
12:41:39 <roconnor> I think it will still overflow
12:41:44 <roconnor> but I'm not sure
12:42:28 <ulrivo> roconnor: it overflows
12:42:34 <roconnor> right
12:43:21 <roconnor> I suggest trying  runnie n clock = (length (queue clock)) `seq` (runnie (n-1) proceed clock)
12:43:34 <roconnor> it's a bit of a sad hack :(
12:45:25 <ulrivo> roconnor: it works! but you are right...a sad hack ;-)
12:45:42 <roconnor> I'm surpised it overflows in the regular case
12:46:15 * roconnor tries it myself
12:46:16 <ulrivo> roconnor: I love your "length iterate...." solution, this is very nice.
12:46:29 <roconnor> ulrivo: it comes with experience
12:47:24 <roconnor> ulrivo: what initclock did you use with runnie n?
12:47:38 <ulrivo> roconnor: I am a bit surprised (disappointed) to run in such problems with this easy ball clock puzzle and the '+1'
12:47:51 <ulrivo> roconnor: Clock [][][][1..30]
12:48:56 <roconnor> ulrivo: yeah.  I would try to argue that you were using haskell `improperly' but I kinda feel like it is a cop-out answer.
12:49:34 <roconnor> ulrivo:  runnie 110000 (initClock 30) works for me in GHCI
12:49:45 <ulrivo> roconnor: okay. then it is not so easy to use haskell 'properly'
12:50:08 <ulrivo> roconnor: ghci overflows very much later than hugs
12:50:10 <roconnor> ulrivo: that's because you have bagage from other languages :)
12:50:19 * roconnor forgot to remove count
12:50:54 <monochrom> Most C programmers never manage to use C properly for life, too.
12:51:39 <roconnor> there we go, runnie 1100000 (initClock 30) overflows
12:51:46 <hpaste>  ulrivo pasted "new version of clock.hs" at http://hpaste.org/4767
12:52:18 <roconnor> ulrivo: btw, you can annotate your original paste.  That is the prefered method :)
12:52:25 <monochrom> Many of my classmates spent months unlearning: char *p; strcpy(p, "hello").  Yes, strcpy to p right after declaring p, no malloc in-between.
12:52:29 <ulrivo> roconnor: I learned tonite that I must look out for +1 :-)
12:52:57 <roconnor> ulrivo: when you are using +1 in an accumulator you are often doing something wrong :)
12:53:10 <roconnor> ulrivo: and you should be using length on some list instead :)
12:53:21 <roconnor> ulrivo: (there are some exceptions)
12:54:01 <ulrivo> roconnor: although the ball clock problem is easy, I learned a lot from it...thanx for you help
12:54:34 * roconnor ponders the stack overflow in runnie
12:55:48 <roconnor> btw, shouldn't gcd somehow solve this problem faster :)
12:56:39 <monochrom> queue clock ++ minutes clock  is the next candidate.
12:57:14 <monochrom> Generally length (...(xs ++ [x0]) ++ [x1]) ++ [x2] ++ ... )  is very bad news.
12:57:23 <roconnor> monochrom: is that a potentional stack overflow?
12:57:32 <Sizur> quick question:, did anybody hear anything about if a haskell interface to Qt4 is in the plans?
12:57:37 <ulrivo> roconnor: 'solve' is solving it in a different way. solve3 is brute force
12:58:04 <monochrom> Of course, even head (...(xs ++ [x0]) ++ [x1]) ++ [x2] ++ ... )  is intractible.
12:58:33 <roconnor> monochrom: oh, the associativity?
12:58:42 <Apocalisp> I can has lambdabot?
12:58:52 <monochrom> You have to go through n ++'s before seeing the first cons cell.
12:59:39 <roconnor> monochrom: but the queue is constantly being tailed.
13:00:19 <monochrom> Is the tail being constantly seq'ed?
13:01:01 <monochrom> I suppose (length (queue clock)) `seq` suffices
13:01:34 <arjanoosting> and eat your kittens
13:01:59 <roconnor> monochrom: the tail should be foreced by the all the head queues
13:04:44 <EvilTerran> @bot
13:04:45 <lambdabot42> :)
13:07:41 <roconnor> ulrivo: I'm not sure I understand why runnie overflows :(
13:08:24 <monochrom> I can't get an overflow in ghci of 6.8.1
13:08:44 <monochrom> runnie 1100000 (initClock 30) gives Clock {minutes = [], fives = [20,15,22,19], hours = [29,24,11,18,8,6,26,2,5], queue = [1,9,16,21,7,14,4,27,17,23,3,28,10,30,13,25,12]} successfully
13:09:27 <roconnor> monochrom: oh good, they must have fixed a bug in ghc :)
13:09:50 <monochrom> Is using 211MB of heap normal? :)
13:10:01 <ulrivo> monochrom: I am using ghci of 6.8.1 , too ...and it wont crash with this version of Clock.hs anymore.
13:10:02 <roconnor> ulrivo: what version of ghci do you have?
13:10:41 * roconnor runs ghc 6.6 :(
13:11:24 <ulrivo> roconnor: do you use the version without the count?
13:12:24 <Apocalisp> Oh, there he is! He just has a new name.
13:12:33 <monochrom> 6.6.1 doesn't overflow either. I have deleted 6.6.
13:13:16 <roconnor> ulrivo: I removed count myself
13:13:27 <monochrom> ghci-6.6.1 uses half as much heap as ghci-6.8.1 :)
13:13:33 <roconnor> *L*
13:14:18 <roconnor> ulrivo: I'm running without the (length (queue clock)) `seq`
13:14:39 <roconnor> ulrivo: because I don't like that hack :)
13:14:55 <ulrivo> roconnor: :-)
13:15:05 <monochrom> OK, without (length (queue clock)) seq'ed constantly, the long chain of ++ I described kicks in and kills everything.
13:15:09 <roconnor> ulrivo: are you stack overflowing without that seq?
13:15:16 <roconnor> monochrom: right.
13:15:32 <roconnor> monochrom: I still don't think that long chain should be there.
13:15:57 <roconnor> I would have expected the tails to force the ++'s and the heads to force the tails.
13:16:03 <monochrom> All your head (queue clock) and tail (queue clock) will not help if they in turn aren't seq'ed.
13:16:09 <roconnor> but I must admit, I find it pretty hard to imagine what is going on :)
13:16:22 <monochrom> "tail whatever" is a thunk too.
13:16:33 <roconnor> sure
13:16:39 <thetallguy> am I imagining things or is there no implmentation of factorial in the standard libraries?
13:16:51 <roconnor> > product [1..5]
13:16:54 <lambdabot42>  120
13:17:08 <thetallguy> I know a zilllon ways to do it.
13:17:17 <monochrom> Banging all or most fields of Clock helps.
13:17:34 <thetallguy> Half the Haskell literature discusses it.
13:17:54 <thetallguy> But after all that, not to have it predefined?
13:17:55 <roconnor> monochrom: oh wait, of course we are building a huge list of proceed thunks
13:17:56 <ulrivo> roconnor: it overflows with the 'count', and it overflows without the count and without that seq.
13:18:04 <thetallguy> Weird.
13:18:08 * roconnor smacks my head
13:18:10 <roconnor> duh
13:18:25 <roconnor> I realized that before and then promplty forgot
13:18:25 <monochrom> Since there are a zillion ways, it is unclear which way should go into the standard.
13:18:56 <sarehu> Having factorial in the standard lib would be weirder than lacking it.
13:20:27 <ulrivo> roconnor: why are we building a huge list of thunks?
13:21:07 <SyntaxNinja> @seen dons
13:21:08 <lambdabot42> dons is in #haskell. I don't know when dons last spoke.
13:22:02 <thetallguy> sarehu: why?
13:22:07 <roconnor> ulrivo: oh wait, nevermind, that doesn't seem to be the problem.
13:22:18 <sarehu> thetallguy: what standard libraries actually have factorial in them?
13:22:21 <thetallguy> sarehu: I don't mean in the prelude
13:22:39 <thetallguy> sarehu: I mean a library of math functions
13:22:50 <thetallguy> Numeric, for example.
13:23:04 <tlaboc> I have a rather general question, I don't really know the right place to find an answer, and was wondering if someone here might have an idea...
13:23:22 <sarehu> Numeric has math functions?
13:23:22 <thetallguy> I suspec the teachers want it left out.
13:23:39 <tlaboc> sorry to interrupt
13:24:20 <thetallguy> no, I've got the wrong lib
13:24:33 <dibblego> ?hoogle Maybe a -> a -> a
13:24:33 <Cale> tlaboc: Just ask away :)
13:24:34 <lambdabot42> Data.Maybe.fromMaybe :: a -> Maybe a -> a
13:24:34 <lambdabot42> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
13:24:34 <lambdabot42> Data.Maybe.maybe :: b -> (a -> b) -> Maybe a -> b
13:24:54 <Toxaris> tlaboc: you should ask your question if you hope for answers :)
13:24:57 <tlaboc> I was wondering if there is any "right" way to call C from Haskell
13:25:06 <mauke> tlaboc: yes!
13:25:09 <tlaboc> there seem to be about a thousand ways
13:25:14 <mauke> @where ffi
13:25:14 <lambdabot42> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
13:25:21 <Cale> sarehu: It has mostly not-so-mathematical functions which are associated with numbers.
13:25:24 <tlaboc> i was wondeing what the right one was
13:25:33 <Cale> (mostly stuff to deal with reading and showing them)
13:25:35 <mauke> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
13:25:42 <sarehu> Cale I know :P thanks
13:25:50 <tlaboc> ah, ok -- thanks
13:26:06 <Cale> sarehu: oh, heh, I missed the context, sorry
13:26:33 <hpaste>  monochrom annotated "new version of clock.hs" with "(no title)" at http://hpaste.org/4767#a1
13:27:09 <Cale> tlaboc: Yeah, Haskell's FFI is rather good. There are various tools which you can use to help construct bindings faster with c2hs probably being the most popular of those, but even just raw FFI is not so bad (and it's important to learn it even if you'll be using another tool).
13:28:00 <tlaboc> i had been looking at something called "greencard", but it was a bit convoluted and hadn't been upadated since '03, i believe
13:28:18 <mauke> yeah
13:28:23 <Cale> greencard was another tool somewhat like c2hs, iirc.
13:29:22 <tlaboc> ill take a look at c2hs and the FFI stuff then
13:29:43 <Cale> All this talk about the FFI is reminding me that I should work more on my Imlib binding :)
13:29:49 <mauke> I've never used c2hs
13:29:56 <mauke> I can tell you how hsc2hs works, though :-)
13:30:02 <roconnor> ulrivo: see monocrome's http://hpaste.org/4767#a1
13:30:02 <tlaboc> the reason i was curious is that ive been reading "The Haskell School of Expression"
13:30:19 <roconnor> monochrom: what does ![Int] do?
13:30:33 <roconnor> how much is strict?
13:30:36 <tlaboc> which has a bunch of graphics examples, which means either libraries or calling SDL or something
13:30:38 <Cale> Yeah, if you're just calling a few C procedures, you don't really need a preprocessor, it's more convenient if there are hundreds of calls that need wrapping.
13:30:50 <Cale> Oh, there are bindings to SDL already.
13:30:50 <monochrom> WHNF. This is a list, so just the first cons cell.
13:31:07 <Cale> And SOE has a library which it's meant to be used with explicitly.
13:31:12 <tlaboc> all right then, i was scared off FFI initially, because it sounded frighteningly complex
13:31:19 <monochrom> Fortunately, just getting to the first cons cell is enough to combat the piled-higher-and-deeper ++'s. :)
13:31:39 <tlaboc> right, i saw the bit about the SOE library, the FFI thing was more out of curiosity
13:31:50 <monochrom> We need our own Haskell gallery of Piled Higher and Deeper!
13:31:57 <ulrivo> monochrom: what does WHNF mean? and what does the ! in front of [Int] ?
13:31:58 <roconnor> monochrom: interesting
13:32:04 <monochrom> A gallery of thunk-building, stack-overflowing code. :)
13:32:21 <mauke> heh, if you've seen the Perl and OCaml FFI, Haskell is completely trivial and simple
13:32:27 <monochrom> WHNF is a technical jargon. I don't have motivation to explain it all today.
13:32:38 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HGL-3.2.0.0 -- I believe this is the latest continuation of the graphics library which SOE uses.
13:32:46 <dylan> WHNF = Wanna Have New Friends?
13:32:47 <monochrom> But I can define it for several common types.
13:33:01 <roconnor> ulrivo: WHNF means weak head normal form
13:33:09 <monochrom> For most number types, it means evaluate the number for real.
13:33:18 <dmhouse> ulrivo: http://en.wikibooks.org/wiki/Haskell/Laziness#Thunks_and_Weak_head_normal_form
13:33:19 <roconnor> ulrivo: ! is like always doing $!
13:33:23 <Cale> If you install Gtk2Hs, there's a GTK version of the SOE library which, iirc, uses Cairo for drawing, it's here: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/soegtk-0.9.12.2
13:33:40 <monochrom> For lists, it means evaluate until the first cons cell is seen. (But not what's in the head, and not the tail)
13:34:02 <monochrom> For Maybe's, it means evaluate until you know it's Nothing or Just. (But not what's inside the Just.)
13:34:03 <ulrivo> wow..lots of stuff to understand and read ...thanx dmhouse, too
13:34:46 <ulrivo> monochrom: so ![Int] just forces the head to be evaluated
13:34:53 <Cale> ulrivo: The basic idea of WHNF is that you evaluate until you know the top-level constructor. If that constructor is strict, you might of course need to evaluate a bit more though.
13:35:00 <roconnor> Haskell's problem with +1 I can forgive, but this hack makes me a little sad :'(
13:35:23 <Cale> roconnor: what hack?
13:35:33 <dibblego> ulrivo, not even the head I believe
13:35:42 <roconnor> Cale: http://hpaste.org/4767#a1
13:35:43 <monochrom> Just the first :
13:36:15 <roconnor> Cale: monochrom says it isn't hacky, but I think it is just less hacky than before.
13:36:34 <ulrivo> monochrom: okay. I shall read more about WHNF later ;-)
13:36:48 <monochrom> If you have a list-type thunk, WHNF of that thunk is going to look like: <potential thunk> : <another potential thunk>
13:36:59 <Cale> It means that when constructing a value of type Clock, when you apply the Clock constructor to its last argument, that argument will be evaluated into WHNF before the value of type Clock is given.
13:37:04 <roconnor> ulrivo: WHNF is a bit beyond beginner level stuff.  It's too bad you are encountering it now.
13:37:09 <Cale> (so, up to determining if it's an empty list or not)
13:37:55 <ulrivo> roconnor: so, I started to tonite to move from beginner to experienced beginner :-)
13:38:06 <roconnor> ulrivo: \o/
13:38:14 <monochrom> It is not hacky because the two !'s (the ! in the record, and the $! in the recursion) are no more specific than what I want: change the evaluation order.
13:38:48 <monochrom> seq (length ...) is hacky because it is more specific than what I want. I just want evaluation order. I code up length.
13:39:16 <ulrivo> monochrom: but you admit, that this solution is for intermediate haskeller
13:39:42 <monochrom> I have doubt on that.
13:39:48 <Cale> Yeah, beginners pretty much remain unaware of the actual evaluation order.
13:39:54 <roconnor> monochrom: ! is always hacky :)
13:40:03 <Cale> Lazy evaluation is outermost-first (with sharing)
13:40:12 <monochrom> I retract my doubt on that. But for a reason different from what you think.
13:40:37 <roconnor> although not quite as hacky as ! is in Prolog.
13:40:41 <monochrom> Your reason is you have to know the operational semantics, therefore it is not beginner stuff.
13:41:02 <Cale> But in fact, the Haskell standard doesn't say that one must use lazy evaluation to evaluate Haskell code -- any evaluation order which gives the same results is okay (but most non-toy-implementations today use lazy evaluation)
13:41:32 <monochrom> My reason is you are translating an imperative, mutable-state algorithm into Haskell, not using Haskell for what it is intended for, therefore it is not beginner stuff.
13:41:59 <monochrom> For example, only beginners ever do list ++ [item].
13:42:02 <Cale> But there are things in Haskell which allow you to exercise some control over the order in which things get evaluated anyway, and make them stricter.
13:42:03 <ulrivo> monochrom: and consider the algorithm we are talking about...it is ridiculous easy. I am still surprised about the problems which I got
13:42:15 <mauke> monochrom: ISTR seeing that in xmonad
13:42:51 <monochrom> What I mean is, an intermediate Haskeller uses a completely different algorithm, and that algorithm will not need any ! or seq.
13:44:14 <monochrom> Is the algorithm ridiculously easy? How do you know?
13:44:34 <monochrom> It is ridiculously intended for C, that is obvious.
13:45:44 <yaxu> what do non-beginners do instead of list ++ [item] ?
13:45:59 * roconnor was wondering the same.
13:46:00 <Cale> yaxu: Avoid having to do that at all costs? ;)
13:46:02 <monochrom> Depends on what problem is to be solved.
13:46:11 <roconnor> okay
13:46:18 <ulrivo> monochrom: so, what would you suggest to forget all my baggage of old languages for a beginner in Haskell?
13:46:19 <monochrom> Most cases involve an infinite list.
13:46:20 <ricky_clarkson> item:list
13:46:37 <Cale> It's not so much a problem if you only do it once or twice. If you build up a list like that though, the costs become prohibitive.
13:46:58 <Axioplase> ulrivo: trial and error is a good way. And reading books/blogs of neat and smart people.
13:47:00 <Cale> xs ++ ys takes length xs + 1 reductions to fully evaluate.
13:47:05 <ricky_clarkson> > head ([1..] ++ 4)
13:47:06 <lambdabot42>   add an instance declaration for (Num [t])
13:47:10 <monochrom> I don't know what to suggest. I have the talent of suppressing my old knowledge when I learn new things. I can't download that to you. I don't know how I can do that.
13:47:13 <ricky_clarkson> > head ([1..] ++ [4])
13:47:15 <lambdabot42>  1
13:47:24 <ulrivo> Axioplase: I do my very best. :-)
13:47:25 <roconnor> ulrivo: that would be ideal :D, but more seriously, your baggage will mean that you will have to stick with Haskell a bit longer before dismissing it because you have so much to unlearn ;)
13:47:31 <Cale> So building up a list like that will end up being quadratic in the length of the list.
13:48:11 <monochrom> Perhaps one thing I do is I am not ambitious in trying coding projects. I spent a long time reading tutorials and writing 3-line code before I ever wrote 20-line code.
13:48:31 <Cale> A rather common trick is to work with list to list functions which prepend elements to their input rather than working with lists directly.
13:48:43 <monochrom> For example I definitely didn't do any of those Euler Projects, Scheme in 48 Minutes, ...
13:48:45 <Cale> Concatenation is then represented with function composition.
13:49:08 <roconnor> ulrivo: the secret truth is that it is actually easier to program (better to say ``solve problems'') in Haskell than imperitive languages ;)
13:49:09 <ulrivo> monochrom: would you say that my Clock-program is just a (Haskell) mess?
13:49:32 <Cale> You can then apply the resulting function to the empty list once all the concatenation is complete in order to get a conventional sort of list.
13:49:40 <monochrom> It is not a mess. It is well organized. Just unoptimized for Haskell.
13:49:49 <roconnor> ulrivo: it isn't too bad, but it definitely has a C like feeling to it :)
13:49:59 <monochrom> You can easily write unoptimized C code too.
13:50:24 <roconnor> ulrivo: in languages like C, one writes out how to solve the problem, like you do here.
13:50:36 <roconnor> ulrivo: in haskell we tend to write out what the solution is.
13:50:42 <pgavin> is there a "preferred" Haskell XML package? there are a few, and I'd like to pick the one most used by other programmers
13:50:59 <Cale> pgavin: I personally like HXT.
13:51:14 <pgavin> Cale: that's the one I'm currently leaning towards
13:51:34 <Cale> The interface is perhaps a little overcomplicated, but then, so is XML.
13:51:51 <ulrivo> roconnor: it would be great to see a better solution, at least an idea of it.
13:51:52 <pgavin> but if HaXmL or HXML are used by more packages, I'll use one of them
13:52:23 <oerjan> Cale: what i don't understand is: why is ((f1 . f2) . f3) . f4 better than ((s1 ++ s2) ++ s3) ++ s4 ?
13:52:41 <Cale> oerjan: because function composition occurs in constant time.
13:52:54 <oerjan> does it, really, when you have left recursion?
13:52:58 <Cale> yep
13:53:14 <Cale> If you want, I can write a program to demonstrate the difference :)
13:53:18 <monochrom> Someone asked what you would do instead of list++[item]. Here is my favourite task to be done in two ways: map f xs.
13:53:18 <ricky_clarkson> How could it not occur in constant time?
13:53:59 <ricky_clarkson> (+ 2) . (* 10) there are no variables to make it not constant.
13:54:03 <monochrom> In a mutable language, you create an empty list, then keep appending (f x) for each x in xs. You do this because appending is O(1) there.
13:54:30 <monochrom> In Haskell, don't do that. Instead, map f (x:xs) = f x : map f xs
13:55:06 <roconnor> monochrom: would using Data.Sequence solve this problem?
13:55:33 <monochrom> You prepend f x to the answer for the rest of the list. You do this because prepending is O(1), and forming the thunk for the rest is O(1) too.
13:56:07 <roconnor> @docs Data.Sequence
13:56:08 <lambdabot42> Data.Sequence not available
13:56:09 <monochrom> If you really want to append, Data.Sequence is a good approach.
13:56:29 <roconnor> monochrom: I think ulrivo really wants a queue
13:56:36 <roconnor> so I'm thinking Data.Sequence.
13:56:44 <oerjan> hm i guess the point is that the overhead of (f1 .) is only applied _once_, regardless of how many other functions it is nested with...
13:57:27 <oerjan> while if you do (s1 ++ ...) ++ ... then the s1 ++ part is rerecursed on each further ++ ?
13:57:33 <Cale> !paste
13:57:33 <hpaste> Haskell paste bin: http://hpaste.org/
13:57:43 <Saizan> ?src (++)
13:57:43 <lambdabot42> (++) []     ys = ys
13:57:43 <lambdabot42> (++) (x:xs) ys = x : xs ++ ys
13:57:47 <hpaste>  Cale pasted "++ demo" at http://hpaste.org/4768
13:58:00 <roconnor> ulrivo: I my first improvement would be to replace your lists (or at the very least your queue) with Data.Sequence.Seq
13:58:07 <Cale> watch the difference in speed between printing those two lists :)
13:58:13 <roconnor> ulrivo: BTW, this Seq has nothing to do with `seq`
13:58:18 <Cale> (I mercifully put the fast one first :)
13:58:49 <ulrivo> roconnor: I started reading at Data.Sequence and thought so :-)
13:59:01 <monochrom> Data.Sequence makes a good queue.
13:59:21 <monochrom> I also know of Okassaki's queues which are purported to be even better.
13:59:28 <roconnor> ulrivo: haskell's list structure makes for a fairly bad queue structure.
13:59:40 <monochrom> But Data.Sequence is more versatile.
13:59:45 <Cale> But it makes an excellent stack :)
14:00:13 <ulrivo> monochrom: you are right. not the algorithm is easy (far away from optimized)...but the problem is easy, isnt it? And I need Data.Sequence for it? hmmm
14:00:26 <Cale> oerjan: try that program?
14:00:46 <oerjan> it scrolled by too fast
14:01:00 <Cale> oerjan: The first one is supposed to scroll fast.
14:01:18 <Cale> (it's 100000 elements long, and is fast to compute)
14:01:26 <oerjan> ah, it finished that
14:01:28 <Cale> the next list should be noticeably slower
14:01:36 <oerjan> and then immediately got a stack overflow in hugs
14:01:44 <Cale> ah, hugs
14:01:49 <sclv_> http://programming.reddit.com/info/64di2/comments/
14:01:53 <Cale> Try it in GHCi, it actually works :)
14:02:11 <roconnor> I'm off to bed all
14:02:31 <ulrivo> roconnor: thank you very much for your help. I learned a lot.
14:02:34 <roconnor> yay recursive do
14:02:46 <roconnor> time travel \o/
14:02:59 <Cale> Wow, it does stack overflow in hugs, I suppose that's another reason to avoid (++) :)
14:04:14 <Cale> Compiled with O2 under GHC, the (++) version appears stricter than when interpreted. It's taking a long time to print even the first element of the list.
14:04:47 <Cale> (or maybe it has something to do with I/O buffering, I'm not sure yet)
14:04:48 <oerjan> Cale: never mind, changing to 10000 in hugs also demonstrated it clearly
14:04:53 <Cale> ah, okay :)
14:08:21 <oerjan> hm so is the ++ version O(n^2) essentially?
14:08:28 <Cale> You can feel the quadratic nature of the computation as the list proceeds to get faster toward the end, as the stack of (++)'s gets shallower.
14:08:32 <Cale> Yeah.
14:09:30 <oerjan> is this something that stream fusion could fix?
14:09:41 <Cale> hmm, possibly
14:09:57 <Cale> yeah, I'm pretty sure that it would fix this quite nicely
14:10:38 <oerjan> because (++) = flip (foldr (:)) isn't it
14:10:58 <Cale> yeah.
14:11:30 <Cale> It's easier to see the complexity with the version that does explicit recursion :)
14:11:37 <Cale> [] ++ ys = ys
14:11:45 <Cale> (x:xs) ++ ys = x : (xs ++ ys)
14:12:18 <Cale> That's obviously going to be length xs + 1 steps to completely evaluate out the (++)
14:12:36 <Cale> (the +1 for the nil case at the end)
14:13:39 <Cale> Of course, if you only ever end up wanting the head, it runs in constant time -- effectively it places an additional constant cost on each of the first length xs + 1 elements of the list.
15:04:50 <hpaste>  jameysharp pasted "monadic (filter . map): can it be simplified?" at http://hpaste.org/4769
15:06:09 <dmhouse> ?hoogle filterM
15:06:10 <lambdabot42> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
15:06:59 <dmhouse> filterMapM f p = filterM (fmap p . f), maybe?
15:07:06 <dmhouse> That's not quite right.
15:08:01 <dmhouse> ?hoogle mapM
15:08:02 <lambdabot42> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
15:08:02 <lambdabot42> Control.Monad.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
15:08:02 <lambdabot42> Data.Traversable.mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:08:38 <jameysharp> I want the particular sequence that my filterMapM executes in, by the way, because that way it doesn't hold a reference to things that the predicate rejected.
15:08:48 <dolio> @hoogle foldrM
15:08:49 <lambdabot42> Data.Foldable.foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
15:09:03 <dmhouse> filterMapM f p xs = fmap (filter p) . mapM f xs -- how's that?
15:09:15 <jameysharp> ooh, I didn't know there was a monadic foldr lying around. I'd only found foldM.
15:09:52 <dmhouse> Sorry, typo, replace that . with a $ (or beta-reduce the xs).
15:09:58 <jameysharp> dmhouse: did you mean ... right, thanks. :-)
15:10:40 <dmhouse> bs >>= return . (b :) -- write this as fmap (b :) bs.
15:10:48 <dmhouse> Any time you have ">>= return", think fmap.
15:11:04 <jameysharp> dmhouse: that only works if the monad is also a functor though...?
15:11:27 <dmhouse> jameysharp: all monads are functors, theoretically at least. Every Monad should also be declared a Functor.
15:12:06 <jameysharp> dmhouse: ok; and I'm only using this with IO, which is declared a Functor, so that's fine.
15:12:30 <dmhouse> ?hoogle (a -> b) -> m a -> m b
15:12:31 <lambdabot42> Prelude.($) :: (a -> b) -> a -> b
15:12:31 <lambdabot42> Prelude.($!) :: (a -> b) -> a -> b
15:12:31 <lambdabot42> Data.Function.($) :: (a -> b) -> a -> b
15:12:36 <dmhouse> No, silly hoogle.
15:13:01 <oerjan> jameysharp: liftM = fmap, but with only Monad type
15:13:22 <jameysharp> ok, that version of filterMapM doesn't evaluate in the same order as mine.
15:13:38 <dmhouse> Yeah, liftM was the function I was trying to remember. You can use that if your Monad isn't a Functor.
15:13:42 <jameysharp> oerjan: ah, thanks! I'd played with liftM but didn't see that connection.
15:13:59 <dmhouse> I prefer fmap, though, because (1) its name is shorter and (2) you don't have to import it.
15:14:19 <jameysharp> I'm already importing Monad in this source file anyway...
15:14:29 <monochrom> I recently enjoyed the no-need-to-import too. :)
15:15:32 <dmhouse> ?src mapM
15:15:32 <lambdabot42> mapM f as = sequence (map f as)
15:15:39 <dmhouse> ?src sequence
15:15:39 <lambdabot42> sequence ms = foldr k (return []) ms
15:15:40 <lambdabot42>     where
15:15:40 <lambdabot42>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
15:16:04 <dmhouse> Hmm, sequence is a right fold, I'd expect it to be the same.
15:16:25 <jameysharp> anyway, the fact that 'bs' doesn't get sequenced if the predicate is false seems to be the key feature of my version.
15:16:48 <dolio> @type \f p l -> mapM f l >>= filterM (return . p)
15:16:50 <lambdabot42> forall a b (m :: * -> *). (Monad m) => (a -> m b) -> (b -> Bool) -> [a] -> m [b]
15:17:32 <dmhouse> dolio: that's the same as my fmap (filter p) . mapM f, I think.
15:17:56 <dolio> Ah, indeed.
15:18:14 <oerjan> hm wait... p is pure?
15:18:30 <jameysharp> oerjan: yes, p is not monadic.
15:19:58 <dolio> @pl \f p l -> mapM f l >>= filterM (return . p)
15:19:58 <lambdabot42> (. (filterM . (return .))) . flip . ((>>=) .) . mapM
15:19:59 <conal> @tell thoughtpolice thanks for the tip on http://haskell.org/haskellwiki/Phooey.  changed "DataDriven" to "Reactive" and fixed calculator example.
15:19:59 <lambdabot42> Consider it noted.
15:20:13 <oerjan> this does mean it's only memory behavior that distinguishes it from the other suggestions i think
15:20:50 <jameysharp> oerjan: since I'm using it with the IO monad, it also makes a difference on whether file descriptors are held open.
15:21:24 <oerjan> actually i think map f xs is an obvious start
15:21:39 <jameysharp> but yeah, as far as I can see it's only "memory" that matters.
15:22:15 <dmhouse> How about filterMapM = sequence . fmap (filter p) . map f, then? Move the seqence outside.
15:22:36 <dmhouse> Err, not quite right.
15:22:42 <Saizan> ?ty \f p -> sequence . fmap (filter p) . map f
15:22:44 <lambdabot42> forall a a1. (a1 -> [a]) -> (a -> Bool) -> [a1] -> [[a]]
15:22:44 <oerjan> filterM p . map f ?
15:23:13 <dmhouse> filterM (fmap p), I think.
15:23:22 <jameysharp> ?ty \p f -> filterM p . map f
15:23:23 <lambdabot42> forall (m :: * -> *) a b. (Monad m) => (b -> m Bool) -> (a -> b) -> [a] -> m [b]
15:23:40 <dmhouse> ?type \p f -> sequence . filterM (fmap p) . map f
15:23:43 <lambdabot42> forall a a1. (a -> Bool) -> (a1 -> [a]) -> [a1] -> [[[a]]]
15:23:46 <oerjan> right, filterM (fmap p) . map f
15:24:19 <Saizan> ?type \f p -> filterM (fmap p) . map f -- here f is pure
15:24:21 <dmhouse> ?type filterM
15:24:21 <lambdabot42> forall a (f :: * -> *) a1. (Monad f, Functor f) => (a1 -> f a) -> (a -> Bool) -> [a1] -> f [f a]
15:24:24 <lambdabot42> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
15:24:43 <dmhouse> oerjan: still not quite there.
15:24:43 <oerjan> not at all
15:24:47 <oerjan> huh?
15:24:58 <dmhouse> oerjan: look at the derived type.
15:25:13 <oerjan> oh hmm
15:25:18 <dmhouse> Oh, hang on, you already dropped the sequence. Yeah, that's right, I think.
15:25:23 <dmhouse> ?type \p f -> filterM (fmap p) . map f
15:25:25 <lambdabot42> forall a (f :: * -> *) a1. (Monad f, Functor f) => (a -> Bool) -> (a1 -> f a) -> [a1] -> f [f a]
15:25:35 <oerjan> :t \p f -> filterM (return . p) . map f
15:25:37 <lambdabot42> forall (m :: * -> *) a b. (Monad m) => (b -> Bool) -> (a -> b) -> [a] -> m [b]
15:25:52 <oerjan> that's it
15:26:28 <dmhouse> Hmm, how does that work? That must surely mean that p takes a monadic input.
15:26:41 <oerjan> yes, which f provides
15:26:45 <Saizan> ?type \p f -> return $ filter p . map f -- no monadic at all
15:26:46 <lambdabot42> forall (m :: * -> *) a b. (Monad m) => (b -> Bool) -> (a -> b) -> m ([a] -> [b])
15:26:54 <oerjan> or wait
15:26:56 <dmhouse> map f xs gives you [m b].
15:26:59 <oerjan> darn
15:27:02 <Saizan> ?type \p f -> return . filter p . map f -- no monadic at all
15:27:03 <lambdabot42> forall (m :: * -> *) a b. (Monad m) => (b -> Bool) -> (a -> b) -> [a] -> m [b]
15:27:13 <dmhouse> oerjan: however yours seems to have the right type.
15:27:28 <dmhouse> Oh, no it doesn't, it requires f to be pure.
15:27:29 <oerjan> no wait i messed up
15:27:38 <jameysharp> oerjan's has (a -> b) ... not quite right.
15:28:12 <oerjan> ok i don't think filterM can do it
15:28:24 <jameysharp> I've spent most of the morning staring at this. ;-)
15:28:41 <jameysharp> hmmm, most of the day, by now.
15:30:55 <dolio> @type \f p -> join . liftM sequence . filterM (liftM p) . map f
15:30:57 <lambdabot42> forall a1 (m :: * -> *) a. (Monad m) => (a -> m a1) -> (a1 -> Bool) -> [a] -> m [a1]
15:31:37 <oerjan> :t \p f -> filter p . mapM f
15:31:39 <lambdabot42> forall a b. ([b] -> Bool) -> (a -> [b]) -> [a] -> [[b]]
15:31:44 <dmhouse> Yeah, I see, that's it.
15:31:46 <oerjan> oops
15:32:27 <oerjan> :t \p f -> liftM (filter p) . mapM f
15:32:29 <jameysharp> dolio: still isn't sequenced in the same order, though it has the right type.
15:32:29 <lambdabot42> forall a (m :: * -> *) b. (Monad m) => (b -> Bool) -> (a -> m b) -> [a] -> m [b]
15:32:42 <dmhouse> jameysharp: are you sure the order differs?
15:32:50 <jameysharp> dmhouse: strace says so...
15:33:38 <dmhouse> *Main> filterMapM (\x -> putStr (show x) >> return x) (> 1) [1..2]
15:33:39 <dmhouse> 12[2]
15:33:39 <dmhouse> *Main> filterMapM' (\x -> putStr (show x) >> return x) (> 1) [1..2]
15:33:42 <dmhouse> 12[2]
15:34:09 <dmhouse> filterMapM is yours, filterMapM' was the one I put up a while back that didn't have the advantage of not sequencing false elements.
15:34:12 <dolio> @type \f p -> join . liftM (liftM reverse . sequence . reverse). filterM (liftM p) . map f -- :)
15:34:13 <lambdabot42> forall a1 (m :: * -> *) a. (Monad m) => (a -> m a1) -> (a1 -> Bool) -> [a] -> m [a1]
15:34:54 <jameysharp> dmhouse: ok, that's interesting. the guard in an if/then/else is strict, right? am I seeing a strict vs. lazy thing?
15:35:07 <nolrai> > unwords ["It's", "back"]
15:35:10 <lambdabot42>  "It's back"
15:35:43 <dmhouse> Hmm, oerjan, your version still isn't right.
15:35:57 <dmhouse> We sequence twice so true items get executed twice.
15:36:27 <dmhouse> *Main> let filterMapM' f p = join . liftM sequence . filterM (liftM p) . map f in filterMapM' (\x -> putStr (show x) >> return x) (> 1) [1..2]
15:36:27 <dmhouse> 122[2]
15:37:37 <dolio> Oh those tricky monads.
15:38:49 <Saizan> these combinators would be more natural to write with data MList m a = Nil | Cons a (m (MList m a)), probably
15:39:23 <oerjan> huh? what's wrong with liftM (filter p) . mapM f version (apart from memory)
15:39:35 <Saizan> memory :)
15:40:52 <dmhouse> Yeah, I don't see a way of doing it without writing a filterM with slightly different semantics
15:41:44 <jameysharp> dmhouse: can you explain what's different here? best I've managed to do is fiddle with it until I got the sequence of system calls I wanted.
15:42:02 <dmhouse> jameysharp: different where?
15:42:14 <nolrai> is there any way in haskell to define f n a b -- is a if it takes less then n arbitrary units of time to compute otherwise b? a and b dont need to be raw haskell but i want them to be closish, (i.e. if they were computations in a state languege this would be reltively easy, but i want functional).
15:42:15 <jameysharp> I don't understand which aspect of Haskell--monads? laziness?--is making this hard.
15:42:26 <dolio> Side effects are hard.
15:42:33 <dolio> :)
15:42:46 <LoganCapaldo> Saizan: not Cons (m a) (m (MList m a)) ?
15:42:46 <Saizan> jameysharp: it's not "hard", but there's no combinator suited for this
15:42:56 <oerjan> jameysharp: are you using readFile or hGetContents?  in that case only the opening of the file is sequenced reliably
15:43:19 <oerjan> the actual reading of characters is lazy
15:43:19 <pierre-> hello all, and happy new year
15:43:42 <Saizan> LoganCapaldo: the need for "lazier" actions is usually in the recursive part
15:43:57 <augustss> nolrai: you could only define something like that in the IO monad.  what you want is not a mathematical function
15:44:58 <oerjan> nolrai: check out the System.Timeout module
15:45:08 <oerjan> it's IO though
15:45:37 <nolrai> well the units of "time" need only corespond very roughly with real time, im realy looking for a way to messure computational dificulty.
15:45:55 <nolrai> oerjan: that might work.
15:45:58 <LoganCapaldo> what about singleton lists tho? I don't think I quite grok what MList is for
15:46:54 <nolrai> oerjan: thats perfect!
15:47:03 <dolio> LoganCapaldo: MLists delay the execution of monadic actions until they're needed to produce the rest of the list.
15:47:24 <LoganCapaldo> Oh ho
15:47:32 <LoganCapaldo> that makes sense now
15:47:43 <LoganCapaldo> methinks I get it
15:47:48 <LoganCapaldo> thanks dolio
15:47:51 <dolio> Instead of, say, m [a], where you have to force the actions to get the entire list just to see the head.
15:49:11 <LoganCapaldo> yah
16:02:39 <jameysharp> oerjan: I'm using readFile, yes, and I understand that it's lazy about the read(2) calls, but I want it to read far enough to evaluate the filter predicate before it goes on to open the next file.
16:03:11 <oerjan> oh i see
16:03:28 <oerjan> so the pure evaluation of the filter matters in the sequencing.
16:03:32 <jameysharp> yeah.
16:05:19 <oerjan> hm...
16:06:43 <nolrai> Is there a single data type that i can use as a map with type of key and a multi-map with another key?
16:09:24 <nolrai> would a map of maps maby work? ie just use msum on lookup on the inner map for the map, and lookup then tolist for the multy map?
16:11:42 <xpika> is there an easy way to get all the rotations of a list say [1,2,3] => [1,2,3] [2,3,1] [3,1,2] ?
16:12:16 <cjb> xpika: those are called "permutations"; Google will find you code.
16:12:23 <TSC> No they're not
16:13:05 <cjb> TSC: I think they are.
16:13:19 <oerjan> > liftM2 (zipWith (++)) tails inits [1,2,3]
16:13:21 <nolrai> permutations would include [2,1,3]
16:13:22 <lambdabot42>  [[1,2,3],[2,3,1],[3,1,2],[1,2,3]]
16:13:26 <notsmack> > let rots xs = zipWith (++) (tails xs) (inits xs) in [1..4]
16:13:28 <lambdabot42>  [1,2,3,4]
16:13:46 <notsmack> > let rots xs = zipWith (++) (tails xs) (inits xs) in rots [1..4] -- oops
16:13:48 <lambdabot42>  [[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1,2,3],[1,2,3,4]]
16:13:54 <oerjan> > init $ liftM2 (zipWith (++)) tails inits [1,2,3]
16:13:56 <lambdabot42>  [[1,2,3],[2,3,1],[3,1,2]]
16:13:59 <cjb> ah, I'm sorry.
16:14:15 <xpika> nice
16:16:02 <oerjan> :t \p f -> liftM catMaybes . mapM (\a -> do b <- f a; if p b then Just b else Nothing)
16:16:04 <lambdabot42> forall a a1. (Maybe a -> Bool) -> (a1 -> Maybe (Maybe a)) -> [a1] -> Maybe [a]
16:16:20 <oerjan> oh wait
16:16:37 <oerjan> :t \p f -> liftM catMaybes . mapM (\a -> do b <- f a; if p b then return $ Just b else return Nothing)
16:16:39 <lambdabot42> forall a a1 (m :: * -> *). (Monad m) => (a -> Bool) -> (a1 -> m a) -> [a1] -> m [a]
16:16:56 <jameysharp> oerjan: cute!
16:18:09 <jameysharp> oerjan: that works. :-)
16:18:24 <jameysharp> I'm not sure it's "simpler" than what I wrote though. :-)
16:18:27 <nolrai> @ty Data.Map.lookup
16:18:29 <lambdabot42> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
16:18:40 <oerjan> it lacks a certain pointfreeness
16:19:11 <oerjan> oh right...
16:19:44 <oerjan> :t \p f -> liftM catMaybes . mapM (\a -> do b <- f a; return $! guard (p b) >> Just b)
16:19:45 <lambdabot42> forall a a1 (m :: * -> *). (Monad m) => (a -> Bool) -> (a1 -> m a) -> [a1] -> m [a]
16:20:29 <jameysharp> oerjan: why `$!`?
16:20:37 <oerjan> to force the evaluation
16:21:10 <oerjan> otherwise return is lazy in the returned value
16:21:31 <jameysharp> oerjan: oh, of *course*. nice!
16:21:54 <oerjan> :t \p f -> liftM catMaybes . mapM (>>= \b -> return $! guard (p b) >> Just b) . map f
16:21:55 <lambdabot42> forall a (m :: * -> *) a1. (Monad m) => (a -> Bool) -> (a1 -> m a) -> [a1] -> m [a]
16:22:18 <jameysharp> I was just pondering a rewrite like that.
16:23:05 <jameysharp> hmm, does mapMaybe help?
16:23:09 <oerjan> @pl \b -> return $! guard (p b) >> Just b
16:23:09 <lambdabot42> (return $!) . ap ((>>) . guard . p) Just
16:23:23 <oerjan> :t mapMaybe
16:23:25 <lambdabot42> forall a b. (a -> Maybe b) -> [a] -> [b]
16:24:26 <oerjan> ooh wait
16:25:08 <oerjan> :t \p f -> liftM concat . mapM (>>= \b -> return $! [b | p b]) . map f
16:25:10 <lambdabot42> forall a (m :: * -> *) a1. (Monad m) => (a -> Bool) -> (a1 -> m a) -> [a1] -> m [a]
16:25:39 <jameysharp> heh, better and better! :-)
16:26:19 <byorgey> [b | p b] ?
16:26:28 <byorgey> humbug ;-)
16:26:30 <oerjan> interesting, a list comprehension that assigns _no_ variables :)
16:26:34 <jameysharp> :t \f-> liftM concat . mapM f
16:26:36 <lambdabot42> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
16:26:50 <jameysharp> :t \f-> liftM (concatMap f)
16:26:52 <lambdabot42> forall a b (m :: * -> *). (Monad m) => (a -> [b]) -> m [a] -> m [b]
16:27:33 <byorgey> :t \b p -> [b | p b]
16:27:35 <lambdabot42> forall t. t -> (t -> Bool) -> [t]
16:28:03 <dibblego> ?type map . not
16:28:05 <lambdabot42>     Couldn't match expected type `a -> b' against inferred type `Bool'
16:28:05 <lambdabot42>     Probable cause: `not' is applied to too many arguments
16:28:05 <lambdabot42>     In the second argument of `(.)', namely `not'
16:28:11 <dibblego> ?type map not
16:28:13 <lambdabot42> [Bool] -> [Bool]
16:29:54 <oerjan> ooh lambdabot42 has 6.8...
16:30:10 <oerjan> :t \p f -> liftM concat . mapM (f >=> \b -> return $! [b | p b])
16:30:12 <lambdabot42> forall a b (m :: * -> *). (Monad m) => (b -> Bool) -> (a -> m b) -> [a] -> m [b]
16:31:42 <byorgey> :t \b p -> guard p >> return b
16:31:44 <lambdabot42> forall (m :: * -> *) b. (MonadPlus m) => b -> Bool -> m b
16:32:01 <byorgey> :t \b p -> guard (p b) >> return b
16:32:02 <lambdabot42> forall (m :: * -> *) b. (MonadPlus m) => b -> (b -> Bool) -> m b
16:32:28 <oerjan> with monad comprehensions [b | p b] would have been equivalent
16:32:38 <byorgey> oerjan: indeed.
16:32:51 * byorgey wishes for a ghc switch to turn on monad comprehensions
16:32:55 <jameysharp> oerjan: are monad comprehensions coming?
16:33:06 <byorgey> jameysharp: more like going =(
16:33:22 <jameysharp> they were implemented and are being ripped out? awww.
16:33:26 <oerjan> jameysharp: they will (in ghc) if someone reimplements them
16:33:33 <byorgey>  they were ripped out a long time ago.
16:33:42 <oerjan> no they were ripped out a long time ago
16:33:58 <jameysharp> seems like a pretty natural extension to me.
16:34:21 <oerjan> it was in haskell 1.4
16:34:44 <oerjan> or was that 4.0?
16:35:08 <lakupuu> a
16:35:10 <byorgey> oerjan, that's Java you're thinking of ;-)
16:35:23 <lakupuu> does this thing work
16:35:32 <byorgey> lakupuu: seems to!
16:35:41 <BMeph> Haskell SDK 4.0... ;p
16:35:48 <oerjan> jameysharp: did you see my >=> improvement?
16:36:04 <cjb> has anyone made ghc6.8 packages for Ubuntu?
16:36:09 <jameysharp> oerjan: I did. I like it. but I don't have 6.8 handy and don't feel like compiling it...
16:36:18 <sioraiocht> anyone know of a good place to find info on record concatenation?
16:36:32 <EvilTerran> on whatnow?
16:36:53 <conal> http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html
16:36:56 <byorgey> hm, >=> is only in 6.8?
16:37:05 <oerjan> byorgey: yep
16:37:08 <byorgey> ah
16:37:38 <nolrai> if i want a database that can be serched on two difrent keys, would it be beter to implement as a map of maps or a pair of maps?
16:37:48 <conal> thetallguy says that there's now a ghc6.8.2 package.  see url above
16:37:58 <jameysharp> oerjan: for 6.6, this seems good enough: liftM concat . mapM (\a-> do b <- f a; return $! [b | p b])
16:38:04 <oerjan> nolrai: pair of maps i think
16:38:25 <byorgey> nolrai: at least, pair of maps seems much more elegant.
16:38:32 <cjb> is haskell-unsafe usable on ubuntu (gutsy)?
16:38:49 <byorgey> nolrai: wait, how would searching the other way even work in a map of maps?
16:39:25 <sarehu> Given key types key1 and key2, a (Map Key1 (Map Key2 Value), Map Key2 Value) would cover everything
16:40:18 <nolrai> byorgey: msum the lookups?
16:40:30 <sarehu> wait - do you want multiple values per key?  Or not?  That is a question to ask..
16:40:42 <nolrai> only for one of the keys
16:40:48 <byorgey> nolrai: sure, but it's not very efficient.
16:41:50 <EvilTerran> Map Key1 (Map Key2 Value) is (pretty much) equivalent to Map (Key1,Key2) Value, i think
16:42:04 <EvilTerran> and the latter likely outperforms the former
16:42:18 <oerjan> EvilTerran: not if you want to get everything for a Key1 at once
16:42:27 <EvilTerran> mmm, true
16:42:44 <nolrai> whitch is exactly what i want.
16:42:55 <sarehu> Oh, well in that case, a pair (Map Key1 [Value], Map Key2 Value) is sufficient, since you'll never need a two-way lookup.
16:43:22 <sarehu> assuming Key2 is the one with exactly one value per key
16:43:38 <nolrai> ok that makes sense.
16:43:51 <cjb> oh, that's odd.  haskell-unsafe seems to provide ghc6.6, not ghc6.8.
16:44:10 <oerjan> possibly Set Value instead of [Value]
16:46:13 <nolrai> how eficent are Sets?
16:46:37 <oerjan> depends on size, probably
16:46:43 <sarehu> yeah, whatever comes in handy... I didn't think Set can have multiple equal values - depends if that's possible
16:46:58 <oerjan> Map Value Int for multisets :)
16:47:58 <sarehu> Map Key2 Value, Map Value [Key2]... . or whatever
16:48:20 <jameysharp> well, thanks for all the suggestions! see ya.
16:59:43 <aFlag> hello, is there some function for formating a string like C's printf or python's % operator?
16:59:51 <Leimy> printf
16:59:59 <aFlag> oh
17:00:14 <Leimy> Under Text.Printf
17:00:16 <Leimy> IIRC
17:00:27 <Leimy> lambdabot should know :-)  It's got a Hoogle interface I believe
17:00:41 <Leimy> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html#v%3Aprintf
17:00:55 <LoganCapaldo> > printf "Works: %s" (show True)
17:00:56 <lambdabot42>  Add a type signature
17:01:04 <LoganCapaldo> > printf "Works: %s" (show True) :: String
17:01:06 <lambdabot42>  "Works: True"
17:01:19 <Leimy> LoganCapaldo: sweet :-)  Love that lambdabot
17:01:31 <LoganCapaldo> printf in Haskell is printf _and_ sprintf
17:01:42 * LoganCapaldo never gets tired of that
17:02:08 <aFlag> hehe cool
17:02:26 <Leimy> > :hoogle printf
17:02:26 <lambdabot42>   parse error on input `:'
17:02:31 <Leimy> hmmmm
17:02:34 <Leimy> > hoogle printf
17:02:35 <lambdabot42>   Not in scope: `hoogle'
17:02:37 <Leimy> dang
17:02:40 <LoganCapaldo> @hoogle printf
17:02:40 <lambdabot42> Text.Printf.printf :: PrintfType r => String -> r
17:02:40 <lambdabot42> Text.Printf :: module
17:02:40 <lambdabot42> Text.Printf.PrintfType :: class PrintfType t
17:02:44 <Leimy> Oh thanks!
17:02:58 <LoganCapaldo> > is short  for @run
17:02:58 <lambdabot42>  Parse error in expression at end of input
17:03:04 <TSC> > "is only for interpreting code"
17:03:06 <lambdabot42>  "is only for interpreting code"
17:03:13 <LoganCapaldo> @run 2 + 2
17:03:15 <lambdabot42>  4
17:03:26 <LoganCapaldo> (and you can use either @ or ?)
17:03:31 <oerjan> > Parse error in expression at end of input
17:03:32 <lambdabot42>  Parse error at "in" (column 13)
17:03:47 <LoganCapaldo> ?hoogle [a] -> a
17:03:48 <lambdabot42> Prelude.head :: [a] -> a
17:03:49 <lambdabot42> Prelude.last :: [a] -> a
17:03:49 <lambdabot42> Data.List.head :: [a] -> a
17:03:52 <oerjan> bah
17:04:20 <LoganCapaldo> oerjan: that looks like a tough cookie
17:04:37 <LoganCapaldo> error quines :)
17:04:48 <oerjan> that won't quine ... it's syntactically correct :(
17:05:08 <oerjan> i had one the other day
17:05:13 <aFlag> this looks weird
17:05:15 <aFlag> Prelude Text.Printf> (printf "asd\n") :: IO ()
17:05:15 <aFlag> asd
17:05:15 <aFlag> Prelude Text.Printf> printf "asd\n"
17:05:15 <aFlag> asd
17:05:15 <aFlag> *** Exception: Prelude.undefined
17:05:34 <aFlag> why does it print that exception and asd?
17:05:41 <aFlag> shouldn't it print only the exception?
17:06:02 <oerjan> weird
17:06:16 <LoganCapaldo> that is weird
17:06:22 <ricky_clarkson> Are you using a nondeterministic evaluator? ;)
17:06:32 <aFlag> not as far as I know
17:06:34 <oerjan> aFlag: no exception here
17:06:47 <aFlag> I'm using ghc 6.6
17:06:54 <oerjan> oh wait
17:07:09 <oerjan> you mean without the type?
17:07:14 <aFlag> yeah
17:07:25 <oerjan> then i get unresolved overloading
17:07:39 <TSC> It works here in ghci 6.8 (it must do some defaulting)
17:07:51 <oerjan> lessee
17:07:59 <oerjan> > (printf "asd\n")
17:08:00 <lambdabot42>  Add a type signature
17:08:06 <oerjan> :t (printf "asd\n")
17:08:08 <lambdabot42> forall r. (PrintfType r) => r
17:08:37 <oerjan> @instances-importing Text.Printf PrintfType
17:08:38 <lambdabot42> (a -> r), IO a, [c]
17:09:07 <oerjan> none of those are in the default list are they?
17:09:34 <BMeph> Look for PrintfArg
17:09:54 <BMeph> >	@instances-importing Text.Printf PrintfArg
17:10:05 <oerjan> BMeph: but there were no args
17:10:08 <LoganCapaldo> s/>//
17:10:11 <BMeph> @instances-importing Text.Printf PrintfArg
17:10:12 <lambdabot42> Char, Double, Float, Int, Integer, [c]
17:10:16 <oerjan> apart from the format string
17:10:31 <BMeph> oerjan: "PrintfArg" is the name of the class
17:10:51 <oerjan> BMeph: yes, but i don't see why it should matter for this error
17:11:22 <aFlag> it's weird how you can pass variable number of arguments to printf
17:11:41 <oerjan> hm, possibly it _does_ get defaulted to IO because ghci expects IO actions
17:11:53 <oerjan> and then it could get IO () by further defaulting
17:11:56 <ricky_clarkson> :t printf
17:11:58 <lambdabot42> forall r. (PrintfType r) => String -> r
17:12:32 <aFlag> can you write functions with variable number of arguments using only haskell?
17:12:32 <ricky_clarkson> You can pass multiple args to it because it returns a PrintfType.
17:12:42 <ricky_clarkson> aFlag: No, but perhaps printf is the closest.
17:12:54 <LoganCapaldo> aFlag: thru the magic of type class hackery
17:12:59 <oerjan> but that doesn't explain why it gives an error after printing the usual IO () result
17:13:04 <TSC> aFlag: All functions have one argument (:
17:13:25 <oerjan> aFlag: printf is written in pure haskell
17:13:32 <aFlag> hm
17:13:40 <ricky_clarkson> @faq
17:13:40 <lambdabot42> The answer is: Yes! Haskell can do that.
17:13:51 <LoganCapaldo> the source is instructive but it's done pretty much how'd you expect
17:13:52 <aFlag> that's wild, I have no idea how it could be done :P
17:14:09 <oerjan> @instances-importing Text.Printf PrintfType
17:14:11 <lambdabot42> (a -> r), IO a, [c]
17:14:20 <ricky_clarkson> @src PrintfType
17:14:21 <lambdabot42> Source not found. Maybe if you used more than just two fingers...
17:14:21 <oerjan> aFlag: not those typeclass instances
17:14:24 <oerjan> *note
17:14:40 <oerjan> the a -> r is the "magical" one for getting varargs
17:14:49 <nolrai> > printf 1 2
17:14:51 <lambdabot42>   add an instance declaration for (Num String)
17:14:55 <BMeph> oerjan: Maybe overloaded strings?
17:15:07 <nolrai> > printf "abcd %d" 1
17:15:08 <lambdabot42>  Add a type signature
17:15:17 <nolrai> > printf "abcd %d" 1 :: String
17:15:19 <lambdabot42>  "abcd 1"
17:15:26 <nolrai> cool
17:15:33 <oerjan> the bad thing about that trick is you keep having to give explicit type signatures to printf
17:15:39 <oerjan> BMeph: huh?
17:15:48 <aFlag> hm, the way I would expect would be for it to look the string and to return the function of the type you need for passing the other parameters
17:16:05 <oerjan> aFlag: it cannot do that
17:16:15 <aFlag> yeah, because of the typing system
17:16:16 <TSC> oerjan: That's usually only in ghci; in a program the context is usually enough for it to figure out the right type
17:16:34 <oerjan> because haskell has no dependent types - it cannot depend on a value
17:17:07 <aFlag> yeah, but they somehow simulate that, right?
17:17:10 <oerjan> instead it looks at the _other_ argument types to determine how to interpret the format
17:17:20 <LoganCapaldo> > printf "%d" 3 ++ " feet"
17:17:22 <lambdabot42>  "3 feet"
17:17:38 <LoganCapaldo> (an example of not needing to supply a signature)
17:19:30 <aFlag> that (a -> r) looks promissing because you can unify that with a1 -> a2 -> ... -> an -> IO b
17:19:38 <oerjan> indeed
17:19:57 <oerjan> printf fmt = spr fmt []
17:20:04 <aFlag> I guess for understanding how it's done I have to look the code :)
17:20:09 <oerjan> is the definition of printf. spr is the class method.
17:20:18 <LoganCapaldo> > do { printf "Likewise no signature" }
17:20:19 <lambdabot42>   add an instance declaration for (Show (t t1))
17:20:26 <LoganCapaldo> drat
17:20:29 <LoganCapaldo> I fail
17:20:38 <LoganCapaldo> > do { printf "Likewise no signature" ; putStr "" }
17:20:39 <oerjan> instance (PrintfArg a, PrintfType r) => PrintfType (a -> r) where spr fmt args = \ a -> spr fmt (toUPrintf a : args)
17:20:40 <lambdabot42>  <IO ()>
17:20:49 <oerjan> that's the -> instance
17:20:59 <brushbox> Hi there: can anyone help me with a simple issue? I'm on Mac OS and the following gives me a segfault: let ang = (90*pi)/(360) -- if I try and take the negative of ang (-ang)???
17:21:21 <oerjan> it takes one more argument and adds it to the accumulated arglist
17:21:43 <nolrai> @Hoogle (a -> a1, b -> b1, c -> c1) -> (a, b, c) -> (a1, b1, c1)
17:21:44 <lambdabot42> Maybe you meant: google hoogle
17:21:51 <nolrai> @hoogle (a -> a1, b -> b1, c -> c1) -> (a, b, c) -> (a1, b1, c1)
17:21:52 <lambdabot42> Did you mean: (a -> A1, b -> B1, c -> C1) -> (a, b, c) -> (A1, B1, C1)
17:22:06 <nolrai> ??
17:22:25 <oerjan> nolrai: there are few tuple functions for length > 2
17:23:03 <oerjan> for length 2 there is:
17:23:28 <oerjan> :t (($) *** ($))
17:23:29 <lambdabot42> forall a b a1 b1. (a -> b, a1 -> b1) -> (a -> b, a1 -> b1)
17:23:35 <oerjan> oh wait
17:23:55 <oerjan> :t uncurry (***)
17:23:57 <lambdabot42> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
17:24:11 <oerjan> that's the one
17:24:32 <oerjan> :t uncurry (***).($)
17:24:33 <lambdabot42>     Couldn't match expected type `(a b c, a b' c')'
17:24:34 <lambdabot42>            against inferred type `a1 -> b1'
17:24:34 <lambdabot42>     Probable cause: `$' is applied to too few arguments
17:24:40 <oerjan> bah
17:25:04 <oerjan> :t ($).uncurry (***)
17:25:05 <lambdabot42> forall b c b' c'. (b -> c, b' -> c') -> (b, b') -> (c, c')
17:25:49 <brushbox> This segfaults on macos:   putStrLn $ "-lit: " ++ show(-0.7853981608749999)
17:26:10 <Copy_Left_> 6.8.2?
17:26:15 <brushbox> 6.6.1
17:26:37 <oerjan> > -0.7853981608749999
17:26:39 <lambdabot42>  -0.7853981608749999
17:28:27 <Copy_Left_> so, busted and been busted. A word to the wise is sufficient.
17:29:48 <brushbox> I'm attempting a port upgrade on ghc...I'll see what happens if it succeeds.
17:29:48 <cin> how can i catch an exception when using `read'? is this possible?
17:30:03 <EvilTerran> cin, use reads instead
17:30:12 <cin> evil: i'll check the docs for that
17:30:20 <sjanssen> who is running lambdabot42?  mind if we have her join some more channels?
17:30:24 <EvilTerran> > map reads ["12", "13ffff", "bleem fleem", ""] :: [Int]
17:30:25 <lambdabot42>  Couldn't match expected type `Int'
17:30:27 <EvilTerran> er
17:30:33 <EvilTerran> > map reads ["12", "13ffff", "bleem fleem", ""] :: [(Int,String)]
17:30:34 <lambdabot42>  Couldn't match expected type `(Int, String)'
17:30:48 <EvilTerran> ?type map reads ["12", "13ffff", "bleem fleem", ""]
17:30:50 <lambdabot42> forall a. (Read a) => [[(a, String)]]
17:30:54 <EvilTerran> > map reads ["12", "13ffff", "bleem fleem", ""] :: [[(Int,String)]]
17:30:57 <lambdabot42>  [[(12,"")],[(13,"ffff")],[],[]]
17:30:59 <EvilTerran> there we go
17:31:28 <oerjan> sjanssen: mux iirc
17:32:03 <cin> evil: what's happening there?
17:32:04 <EvilTerran> cin, (reads str) tries to parse a prefix of the parameter, returning a list of (result,suffix) pairs
17:32:14 <EvilTerran> if there's no parse, it returns []
17:32:18 <cin> ah
17:32:35 <EvilTerran> if there's one (the usual case), it'll return [(whatever, "and the bit of the string that wasn't consumed")]
17:32:58 <EvilTerran> if the parse is ambiguous, it can return multiple results. this is unusual, but can happen.
17:33:10 <EvilTerran> it's designed to be used with the list monad
17:34:02 <oerjan> StateT String []  works nicely too
17:34:42 <cin> > reads "1t" :: (Int,String)
17:34:43 <lambdabot42>  Couldn't match expected type `(Int, String)'
17:34:54 <cin> > reads "1t" :: [(Int,String)]
17:34:56 <lambdabot42>  [(1,"t")]
17:34:56 <EvilTerran> well, yes. should've said "the list monadS", i guess, if i wanted to include transformed versions
17:35:06 <EvilTerran> > reads "-1t" :: [(Int,String)]
17:35:08 <lambdabot42>  [(-1,"t")]
17:35:17 <EvilTerran> > Numeric.readDec "-1t" :: [(Int,String)]
17:35:19 <dibblego> is there a good paper/article describing the benefits of hiding data type constructors? i.e. Abstract Data Types?
17:35:19 <lambdabot42>  []
17:35:21 <EvilTerran> > Numeric.readDec "1t" :: [(Int,String)]
17:35:24 <lambdabot42>  [(1,"t")]
17:35:27 <cin> > reads "<garbage data>" :: [(Int,String)]
17:35:29 <lambdabot42>  []
17:36:17 <oerjan> > evalStateT (replicateM 3 $ StateT reads) "1 2 3 4 5" :: [([Int],String)]
17:36:18 <lambdabot42>  Couldn't match expected type `([Int], String)'
17:36:24 <oerjan> oh wait
17:36:26 <cin> so, if i want to read in an integer, i should use
17:36:30 <EvilTerran> readDec has better performance and provides more semantic meaning than the generic "reads" function (as it's not polymorphic), so i prefer it
17:36:32 <oerjan> > evalStateT (replicateM 3 $ StateT reads) "1 2 3 4 5" :: [[Int]]
17:36:34 <lambdabot42>  [[1,2,3]]
17:36:46 <EvilTerran> but it can't do signed numbers
17:36:49 <cin> > reads "1" :: [(Int,String)]
17:36:50 <lambdabot42>  [(1,"")]
17:37:07 <EvilTerran> ?type readSigned
17:37:09 <lambdabot42> forall a. (Real a) => ReadS a -> String -> [(a, String)]
17:37:36 <EvilTerran> > readSigned readDec "-23a"
17:37:38 <lambdabot42>  [(-23,"a")]
17:38:53 <cin> > reads "(1,2)" :: [(Int,Int)]
17:38:54 <lambdabot42>  Couldn't match expected type `Int' against inferred type `String'
17:39:01 <EvilTerran> @check liftM2 (==) reads (readSigned readDec) . show :: Int -> Bool
17:39:03 <lambdabot42>  quickcheck: /tmp/MzfDU28996.o: unknown symbol `__stginit_haskell98_Char_' qu...
17:39:04 <cin> > reads "(1,2)" :: (Int,Int)
17:39:05 <lambdabot42>  Couldn't match expected type `(Int, Int)'
17:39:08 <EvilTerran> crikey
17:39:17 <cin> lolwut
17:39:31 <oerjan> :t readDec
17:39:33 <lambdabot42> forall a. (Num a) => String -> [(a, String)]
17:39:40 <oerjan> is too polymorphic
17:39:58 <EvilTerran> it's less polymorphic than reads is :P
17:40:17 <cin> > readDec "12rubbish"
17:40:19 <lambdabot42>  [(12,"rubbish")]
17:40:25 <cin> > readDec "rubbish"
17:40:27 <lambdabot42>  []
17:40:31 <cin> excellent
17:41:59 <EvilTerran> > readSigned readDec "+12foo"
17:42:01 <lambdabot42>  []
17:42:50 <cin> :m readDec
17:43:00 <EvilTerran> m?
17:43:10 <cin> ah. it's in Numeric
17:43:11 <cin> n/m
17:43:17 <EvilTerran> ?hoogle readDec
17:43:17 <lambdabot42> Numeric.readDec :: Num a => ReadS a
17:43:18 <lambdabot42> Text.Read.Lex.readDecP :: Num a => ReadP a
17:43:21 <oerjan> @index readDec
17:43:21 <lambdabot42> Numeric
17:43:29 <EvilTerran> ?bot
17:43:30 <lambdabot42> :)
17:53:34 <EvilTerran> ?yow
17:53:34 <lambdabot42> I'm wearing PAMPERS!!
17:53:58 <loupgaroublond> the prefix changed?
17:54:04 <notsmack> @yow
17:54:04 <lambdabot42> But they went to MARS around 1953!!
18:00:20 <Cale> @. elite yow
18:00:20 <lambdabot42> DO u |ixE "73NDeR vi77lEz"?
18:00:30 <loupgaroublond> @.chef yow
18:00:30 <lambdabot42> Unknown command, try @list
18:00:37 <loupgaroublond> @.bork yow
18:00:38 <lambdabot42> Unknown command, try @list
18:01:03 <loupgaroublond> @list
18:01:03 <lambdabot42> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:01:21 <oerjan> @. chef yow
18:01:22 <lambdabot42> Plugin `compose' failed with: Unknown command: "chef"
18:01:48 <oerjan> @list yow
18:01:48 <lambdabot42> quote provides: quote remember forget ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
18:02:05 <oerjan> @list elite
18:02:06 <lambdabot42> elite provides: elite
18:02:22 <loupgaroublond> @yhjulwwiefzojcbxybbruweejw
18:02:23 <lambdabot42> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
18:02:28 <loupgaroublond> @protontorpedo
18:02:28 <lambdabot42> on the haskell site they compare haskell to a spreadsheet
18:02:33 <loupgaroublond> :)
18:02:43 <Cale> @protontorpedo
18:02:43 <lambdabot42> and haskell is general purpose?
18:02:45 <Cale> @protontorpedo
18:02:45 <lambdabot42> scheme, lisp, php, python, perl, tcl, al banned
18:02:47 <Cale> @protontorpedo
18:02:47 <lambdabot42> wil haskell make mroe more money?
18:03:11 <Cale> @keal
18:03:12 <lambdabot42> i only trust opensource tools. where can i download haskell for windows?
18:03:13 <loupgaroublond> @v
18:03:14 <lambdabot42> "\"\\\"\\\\\\\"\\\\\\"
18:03:18 <LoganCapaldo> @phaser
18:03:18 <lambdabot42> Unknown command, try @list
18:03:21 <loupgaroublond> @.brain
18:03:21 <Saizan> @girl19
18:03:21 <lambdabot42> Well, I think so, Brain, but do I really need two tongues?
18:03:21 <lambdabot42> LOL
18:03:27 <Cale> I think I like keal more than protontorpedo
18:03:37 <Cale> @keal
18:03:37 <lambdabot42> Keal was so happy with T, coded in basic so run on anything, and does lot
18:03:57 <LoganCapaldo> I fear keal.
18:04:05 <oerjan> @fear
18:04:06 <lambdabot42> Maybe you meant: faq keal learn read
18:05:33 <byorgey> @help learn
18:05:34 <lambdabot42> learn. The learning page url
18:06:09 <oerjan> @learn
18:06:09 <lambdabot42> http://www.haskell.org/learning.html
18:06:23 <oerjan> @list learn
18:06:23 <lambdabot42> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack thanks thx thank you wiki oldwiki docs source fptools hackage
18:07:27 <EvilTerran> @help keal
18:07:28 <lambdabot42> keal. Talk like Keal
18:08:05 <notsmack> @keal
18:08:05 <lambdabot42> somone would expect that trees 500gb hdds of expressions as if they were floppy dicks
18:08:43 <oerjan> >_<
18:14:05 <ramza3> is there a printf function that returns a string?  as opposed to this one: "printf :: PrintfType r => String -> r"
18:14:30 <LoganCapaldo> yes, printf :)
18:14:44 <LoganCapaldo> > printf "%d" 3 :: String
18:14:46 <lambdabot42>  "3"
18:15:30 <ramza3> dope
18:15:55 <oerjan> PrintfType instances are of the form a1 -> a2 -> ... -> b where b is String or IO ()
18:19:06 <ricky_clarkson> Is printf "%d%d" 3 3 basically ((printf "%d%d") 3) 3 ?
18:19:47 <oerjan> sure
18:19:49 <notsmack> ricky_clarkson: yeah
18:19:51 <LoganCapaldo> yes, just like every function in fact
18:19:56 <notsmack> ricky_clarkson: function application binds tightly
18:20:11 <LoganCapaldo> f a b c == (((f a) b) c)
18:22:06 <ramza3> interesting; lisp s-expressions in haskell are just haskell code
18:22:15 <ramza3> is just
18:22:40 <ricky_clarkson> Haskell is somewhat like a lisp-1.
18:23:00 <fadec> are just codes
18:23:48 <ramza3> ricky_clarkson, (((printf "Magic: %X %X\n") (magicNumberA db)) (magicNumberB db))  this worked, interesting
18:24:53 <mmmdonuts> except lisp/scheme don't support currying so you'd usually have to write something like (f a b c) or ((f a b) c) depending on the arity of the functions being applied.
18:25:54 <ricky_clarkson> ramza3: You did a video about Haskell, I think someone said.. where is it?
18:26:53 <bos> @seen Pseudonym
18:26:54 <lambdabot42> Pseudonym is in #haskell. I don't know when Pseudonym last spoke.
18:27:17 <bos> where are all the type hackers? sigh.
18:28:35 <EvilTerran> hm?
18:28:37 <bos> @seen ddarius
18:28:37 <lambdabot42> I haven't seen ddarius.
18:28:50 <bos> EvilTerran: i've gotten myself hopelessly confused.
18:29:08 <LoganCapaldo> .
18:29:24 <EvilTerran> i like to think i can hack types fairly well... do tell?
18:29:29 <bos> ooh, ok.
18:29:33 <bos> let me paste some bits.
18:29:43 <ramza3> ricky_clarkson, I did a video on factor and it was only a screencast; not that high quality
18:31:40 <ricky_clarkson> Ah, sorry, cross-channel blip.
18:33:29 <ramza3> ricky_clarkson, but since you asked: http://www.youtube.com/watch?v=koRFLwHGS7o&eurl=http://factorlang-fornovices.blogspot.com/2007/10/cross-post-factor-screencast-basic.html
18:33:31 <ramza3> oops
18:33:35 <ramza3> http://www.youtube.com/watch?v=koRFLwHGS7o&feature=related
18:34:36 <blackdog> do you need to do anything special to activate parallel evaluation? My copy of ghc-6.8.1 seems not to like +RTS -N2 as shown on don's page...
18:35:01 <Leimy> blackdog: that worked ok here
18:35:14 <monochrom> ghc -threaded ... to compile.
18:35:46 <hpaste>  bos pasted "type hackery" at http://hpaste.org/4771
18:35:56 <bos> EvilTerran: see above for first part
18:35:58 <blackdog> ah, that did it. thanks monochrom
18:36:03 <thoughtpolice> you shouldn't need anything to do parallelism, but you need -threaded if you don't want lightweight threads to block all others on safe calls or you want to use multiple cores
18:36:04 <lambdabot42> thoughtpolice: You have 1 new message. '/msg lambdabot42 @messages' to read it.
18:36:07 <dibblego> ?type munit . return
18:36:09 <lambdabot42> Not in scope: `munit'
18:36:12 <dibblego> er
18:36:18 <dibblego> ?type mplus . return
18:36:20 <lambdabot42> forall (m :: * -> *) a. (MonadPlus m) => a -> m a -> m a
18:36:48 <dibblego> ?type flip . mplus . return
18:36:49 <lambdabot42> forall b a. (MonadPlus ((->) b)) => a -> b -> (b -> a) -> a
18:36:52 <thoughtpolice> @messages
18:36:52 <lambdabot42> You don't have any new messages.
18:36:55 <thoughtpolice> :/
18:36:56 <blackdog> thoughtpolice: oh, ok. i was calling par and pseq and it was evaluating it sequentially without the
18:37:00 <blackdog> -N2 flag
18:37:11 <blackdog> seems good to go now, though. thanks.
18:37:16 <dibblego> ?type flip $ mplus . return
18:37:17 <lambdabot42> forall (m :: * -> *) a. (MonadPlus m) => m a -> a -> m a
18:38:58 <ricky_clarkson> ramza3: Don't sleep tonight until you've done that screencast again, with sound and without saying sorry. ;)
18:39:28 <EvilTerran> bos, yeah?
18:39:43 <bos> EvilTerran: still pasting ...
18:39:49 <ramza3> ricky_clarkson, talk to ubuntu and linux software; half the screencast software doesnt work.  Plus, my video production studio is down
18:39:57 <hpaste>  bos annotated "type hackery" with "(no title)" at http://hpaste.org/4771#a1
18:40:11 <bos> EvilTerran: ok, so the second paste starts to show some details.
18:40:16 <ricky_clarkson> I've used Wink in Windows before, seemed quite capable.
18:40:22 <ricky_clarkson> Certainly more so than I was.
18:40:26 <bos> the first paste is the type system i'm dealing with. the second is the value system.
18:40:52 <EvilTerran> okay...
18:42:00 <bos> EvilTerran: so my problem is that i need to take a type of the form (a :-> b :-> c), and an [AnyValue] list, and wrap each AnyValue in an Argument constructor, so i get a result of type Argument a :-> Argument b :-> Argument c
18:43:02 <bos> EvilTerran: and that's where my powers of type hackery are currently failing.  i tried a similar lists-in-the-type-system trick as with the Param typeclass, but it's not working.
18:43:56 <EvilTerran> do you mean specifically the three-items case, or in general?
18:44:00 <bos> in general.
18:45:09 <Saizan> a problem is that you don't have a terminator for your type-level list
18:45:25 <wolverian> eh, is everyone reimplementing hlist today?
18:45:34 <Saizan> so you need an additional trick to avoid overlapping problems with fundeps
18:45:37 <bos> Saizan: that's not a problem with the type-level lists on types.
18:45:51 <bos> Saizan: i already have some fundeps in place.
18:46:13 <Saizan> it's a problem because your base case unifies with the recursive one, at least in the class i'm imagining :)
18:46:41 <hpaste>  bos annotated "type hackery" with "fundeps" at http://hpaste.org/4771#a2
18:47:46 <EvilTerran> where does the FFI module come from, here?
18:48:01 <bos> it's a module i wrote with a bunch of bindings.
18:48:25 <EvilTerran> hm. T likewise, apparently. here i was hoping to prod the thing in ghci.
18:48:26 <bos> so e.g. FFI.int1Type :: Ptr Blah
18:48:55 <blackdog> is there such a thing as a parallel map in Control.Parallel, or do you just hack it up yourself?
18:49:12 <bos> EvilTerran: oh, T is just a mistake, you can edit it out.
18:49:15 <EvilTerran> Saizan appears to have a head start on comprehension of it all, anyway
18:49:24 <Saizan> class FromList tl atl | tl -> atl where fromList :: tl -> [AnyValue] -> atl; instance FromList b argb => FromList (a :-> b) (Argument a :-> argb) where fromList a (x:xs) = Argument x :-> fromList (cdr a) xs and missing base case
18:49:27 <bos> EvilTerran: that code is in separate modules as things stand.
18:49:31 <blackdog> oh, parMap. nevermined.
18:50:42 <EvilTerran> i'm afraid i'm going to hand over to him. i just noticed that it's rather later than i intended to go to bed :P
18:50:49 <EvilTerran> good luck, eh
18:50:52 <bos> :)
18:51:36 <Saizan> but, the base case will be of the form class FromList c (Argument c)  where fromList _ [x] = Argument x, you need OverlappingInstances and you'll probably get an error on the fundep
18:51:38 <bos> Saizan: ah, of course!
18:51:53 <Saizan> err, instance in my last line
18:52:38 <Saizan> :)
18:53:13 <bos> ok, let me try that in a bit. must run myself for a few minutes.
18:57:49 <Saizan> bos: if you do get the problem i mentioned you can work around it with a slight modification of this: http://okmij.org/ftp/Haskell/typecast.html#is-function-type
19:00:25 <ramza3> with left arrow, is it only that it can be used with IO operations; is that the difference from binding a variable with just let
19:00:45 <sclv> @src (a->b) mconcat
19:00:46 <lambdabot42> Source not found. The more you drive -- the dumber you get.
19:02:08 <dolio> @src (->) mconcat
19:02:09 <lambdabot42> Source not found. This mission is too important for me to allow you to jeopardize it.
19:02:29 <LoganCapaldo> ramza3: depends on how accurate you want to be.
19:02:54 <Saizan> ramza3: the <- arrow "extracts" the value from an IO computation, while using let you'd just define another name for the computation as a whole
19:04:23 <Saizan> so in let x = getChar, x :: IO Char, but in do x <- getChar; ...  x :: Char
19:04:36 <oerjan> @src (->) mappend
19:04:37 <lambdabot42> Source not found. That's something I cannot allow to happen.
19:04:40 <ramza3> Saizan, I am going to quote you in my blog
19:05:24 <Saizan> as you wish :)
19:05:31 <Saizan> but, is it clear?
19:05:44 <EvilTerran> mappend f g x = f x `mappend` g x
19:05:46 <EvilTerran> (i think)
19:05:52 <ramza3> Saizan, got it
19:06:05 <dolio> Yeah, that's the one.
19:06:05 <EvilTerran> unless you're thinking of Endo, in which case mappend = (.)
19:07:08 <dolio> mconcat is probably the default for both.
19:07:18 <BMeph> @quote behavior
19:07:18 <lambdabot42> No quotes match.
19:07:28 <dolio> foldr mappend mempty, or whatever.
19:07:49 <sclv> yep -- I was defining a custom monad and it was forcing me to define mconcat manually to prevent overlapping instances
19:07:51 <EvilTerran> ?src mconcat
19:07:52 <lambdabot42> Source not found. Sorry.
19:08:02 <dolio> @src Monoid
19:08:02 <lambdabot42> class Monoid a where
19:08:02 <lambdabot42>     mempty  :: a
19:08:02 <lambdabot42>     mappend :: a -> a -> a
19:08:02 <lambdabot42>     mconcat :: [a] -> a
19:08:18 <dolio> Or maybe there is no default...
19:08:37 <Saizan> i rather wonder why mconcat is a class method
19:08:39 <sclv> I almost get the monoid I want for free but a monoid on a -> (Maybe b) requires a monoid instance for b.
19:08:40 <EvilTerran> "Fold a list using the monoid. For most types, the default definition for mconcat will be used, but the function is included in the class definition so that an optimized version can be provided for specific types."
19:08:54 <BMeph> EvilTerran: mappend (f.g) x?
19:09:12 <EvilTerran> BMeph, what?
19:09:36 <oerjan> @src mconcat
19:09:36 <lambdabot42> Source not found. Do you think like you type?
19:09:40 <sclv> all the newtype declarations in Monoid make it a pain to use.
19:09:42 <BMeph> EvilTerran: mappend (f.g) x = f x `mappend` g x
19:09:44 <dolio> sclv: What about First and Last?
19:10:01 <sclv> dolio: exactly. I need to use a newtype though, right?
19:10:28 <EvilTerran> BMeph, i'm referring to the (a->) Monoid instance in particular when i say "mappend f g x = f x `mappend` g x"
19:10:58 <EvilTerran> sorry, the Monoid b => Monoid (a -> b) instance
19:10:58 <dolio> sclv: Well, a -> First b is probably a monoid automatically...
19:11:05 <BMeph> EvilTerran: Ah, got it.
19:11:18 <dolio> If that's the monoid you want.
19:11:54 <sclv> hmm.. I'll try that at first.
19:13:35 <sclv> is First new?
19:13:40 <sclv> I'm not getting it in scome
19:13:43 <sclv> er scpe
19:15:07 <oerjan> :t First
19:15:08 <lambdabot42> forall a. Maybe a -> First a
19:15:24 <dolio> I'm not sure when it was added.
19:15:27 <Saizan> ?index First
19:15:27 <lambdabot42> bzzt
19:16:03 <sclv> not in 6.6 -- just browsed.
19:16:47 <BMeph> oerjan, sclv: It's in Data.Monoid
19:17:00 <sclv> BMeph: yep. but not in my version.
19:18:13 <oerjan> BMeph: i thought so, given the conversation
19:19:20 <BMeph> sclv: Where'd you pick up your Monoid module? Er, when, rather? :)
19:19:57 <sclv> base-2.1.1
19:20:22 <sclv> I'm copying over the new source though for first, since its obviously the Right Thing for my problem.
19:22:32 <sclv> and indeed I drop it in and..poof! I'm spending a lot of thought on how to use monoids more in my code.
19:24:52 <bos> Saizan: i get a coverage condition failure on a fundep in my instance declaration
19:26:32 <sclv> It's really handy -- to just declare a newtype of a -> First b and get all my mconcat goodness for free.
19:26:57 <bos> @seen Saizan
19:26:57 <lambdabot42> Saizan is in #haskell. I last heard Saizan speak 10m 53s ago.
19:26:58 <aFlag> I don't really understand too well how to use monad and monoid
19:27:07 <bos> hmm, ah.
19:27:10 <Saizan> bos: tried UndecidableInstances?
19:27:11 <aFlag> the only monads I've use were the state monad and IO monad
19:27:21 <bos> Saizan: yeah, i'm going to.
19:27:53 <sclv> aFlag: here's how I got sold on monoids.
19:28:05 <Saizan> bos: but i really think you need to apply that bit of oleg hackery i've linked before
19:28:07 <loupgaroublond> for a moment, i read that as 'sold on steroids'
19:28:14 <sclv> I had a list like such [(Env -> String)]
19:28:19 <bos> Saizan: didn't see it, sorry.
19:28:40 <Saizan>  http://okmij.org/ftp/Haskell/typecast.html#is-function-type
19:28:54 <sclv> and had an ugly if compact function to apply an environment to each and concatenate the results
19:29:19 <sclv> which became, even more neatly, (concat .) . sequence
19:29:31 <sclv> (apply each to an environment, rather)
19:29:44 <sclv> and then I realized that it was just a special case of mconcat!
19:29:49 <sclv> ?ty mconcat
19:29:51 <lambdabot42> forall a. (Monoid a) => [a] -> a
19:29:58 <aFlag> hm
19:30:16 <aFlag> I'd probably implement that with a fold
19:30:37 <sclv> because the a in that Monoid a is actually an instance of (Monoid b) => a -> m b
19:30:52 <bos> Saizan: ok, thanks.
19:30:59 <sclv> aFlag: but mconcat takes care of all of it for me, and is actually more expressive of what I want.
19:31:16 <aFlag> yeah, I'm not saying fold would be better
19:31:37 <sclv> so now I'm looking for the monoid pattern everywhere I can.
19:32:26 <sclv> (oh, and I get mempty for free in this case too, which is handy!)
19:32:50 <Saizan> bos: in your case you need to check on (:->) rather than (->)
19:32:58 <aFlag> how does your code looks like using mconcat?
19:33:03 <bos> Saizan: right.
19:33:12 <sclv> aFlag: it looks like "mconcat"
19:33:34 <sclv> seriously -- it gives me exactly what I want.
19:33:38 <aFlag> hm, how does it know what Env to apply and how to concat the strings?
19:33:52 <BMeph> sclv: Do you know of a good paper explaining what the deal is with monoids, and "mconcat" and such? I'm just now hitting the "Applicative programming" paper, and I'm impressed with how well zipWith resembles fmap, but with more containers
19:34:34 <sclv> well the type of mconcat in my specific usage is [(Env->[Char])]->Env->Char
19:34:41 <sclv> or, Env->[Char] rather
19:35:13 <sclv> the list of chars is only one type of monoid -- the "free monoid" I think it's called. by default its mappend is (++).
19:35:22 <sclv> the Env is a record type that I'm using
19:36:05 <aFlag> because with fold it would be something like "foldr1 f where f g rest = g env ++ rest", right? How does it know how to implement that f function?
19:36:47 <sclv> instance Monoid b => Monoid (a -> b) where
19:36:47 <sclv> 	mempty _ = mempty
19:36:48 <sclv> 	mappend f g x = f x `mappend` g x
19:37:00 <sclv> 	mconcat = foldr mappend mempty
19:38:23 <aFlag> hm, I see.
19:38:58 <aFlag> please don't think I'm being difficult, but why is that better?
19:39:08 <bos> Saizan: wow, it seems to be working.
19:39:24 <aFlag> or you didn't implement that instance?
19:39:45 <sclv> aFlag: I didn't have to implement anything! I imported Data.Monoid and it all came for free!
19:39:53 <aFlag> oh, now I see
19:39:54 <sclv> haha I sound like a car salesman.
19:40:23 <aFlag> neat
19:41:02 <oerjan> > mconcat [replicate 3, enumFromTo 1] 4
19:41:05 <lambdabot42>  [4,4,4,1,2,3,4]
19:41:22 <BMeph> sclv: Not yet like a salesman - you haven't offered any Turtle Wax to anyone. ;p
19:41:23 <dibblego> ?type fmap
19:41:24 <lambdabot42> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:41:47 <Saizan> bos: you'll need type annotations when the last argument is not instantiated enough to distinguish it from (a :-> b), but for the rest it works quite well
19:42:39 <oerjan> > msum [replicate 3, enumFromTo 1] 4
19:42:41 <lambdabot42>   add an instance declaration for (MonadPlus ((->) a))
19:42:41 <lambdabot42>     In the expression:...
19:42:48 <oerjan> hmph
19:43:47 <EvilTerran> one of those ones that'd be possible for only some parameter types of the monad
19:44:29 <EvilTerran> (like Monad Set)
19:45:01 <EvilTerran> mzero = return mempty; mplus = liftM2 mappend; kinda thing
19:45:24 <oerjan> hm right
19:46:40 <sclv> > let foo a = if (even a) then First (Just a) else mempty; bar a = if (odd a) then First (Just (a*12)) else mempty in (mconcat [foo, foo, foo, foo]) 1
19:46:42 <lambdabot42>  First {getFirst = Nothing}
19:46:51 <sclv> > let foo a = if (even a) then First (Just a) else mempty; bar a = if (odd a) then First (Just (a*12)) else mempty in (mconcat [foo, foo, bar, foo]) 1
19:46:54 <lambdabot42>  First {getFirst = Just 12}
19:47:34 <Saizan> it's just easier to define instances for Monoid then MonadPlus since it's not a constructor class
19:48:44 <EvilTerran> isn't MonadPlus kinda redundant, given Monad and Monoid?
19:50:20 <Saizan> you'd have even more instances for Monoid!
19:51:20 <EvilTerran> most MonadPlus m instances have equivalent Monoid (m a) instances already, don't they?
19:51:39 <Saizan> currently there's Monoid a => Monoid (Maybe a), not Monoid (Maybe a) iirc
19:51:56 <EvilTerran> ah, yes. different semantics
19:52:06 <oerjan> First is closer to the mplus of Maybe
19:55:19 <dibblego> ?type flip $ mplus . return
19:55:21 <lambdabot42> forall (m :: * -> *) a. (MonadPlus m) => m a -> a -> m a
19:57:38 <EvilTerran> @check \x y -> (getFirst $ First x `mappend` First y) == x `mplus` (y :: Maybe Int)
19:57:40 <lambdabot42>  quickcheck: /tmp/MKcRG29699.o: unknown symbol `__stginit_haskell98_Char_' qu...
19:57:44 <EvilTerran> grah
19:57:45 <oerjan> dibblego: does that do what you want?
19:58:05 <dibblego> you mean EvilTerran's function?
19:58:16 <oerjan> no, what you ?type'd
19:58:43 <dibblego> oerjan, I'm just playing
19:58:53 <oerjan> :t (. return) . mplus
19:58:55 <lambdabot42> forall (m :: * -> *) a. (MonadPlus m) => m a -> a -> m a
20:00:56 <EvilTerran> ?type on
20:00:57 <lambdabot42> Not in scope: `on'
20:01:08 <oerjan> :t Data.Function.on
20:01:10 <lambdabot42> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
20:01:15 <EvilTerran> :t ?type ?f . ?g `on` ?h
20:01:17 <lambdabot42>     precedence parsing error
20:01:17 <lambdabot42>         cannot mix `(.)' [infixr 9] and `on' [infixl 9] in the same infix expression
20:01:17 <lambdabot42> Not in scope: `on'
20:01:35 <EvilTerran> i find it odd that it knows the fixity of a value that isn't in scope
20:01:42 <oerjan> it doesn't
20:01:48 <aFlag> :t id
20:01:48 <oerjan> infixl 9 is the default
20:01:49 <lambdabot42> forall a. a -> a
20:01:50 <aFlag> ?type id
20:01:51 <lambdabot42> forall a. a -> a
20:01:54 <EvilTerran> ah. okay.
20:01:56 <aFlag> what's the difference?
20:02:02 <aFlag> between ?type and :t?
20:02:06 <aFlag> are they the same thing?
20:02:14 <oerjan>  :t is just an abbreviation
20:02:24 <aFlag> oh
20:02:53 <oerjan> afaik there are three abbreviations: :t for @type, :k for @kind and > for @run
20:03:21 <oerjan> everything else starts with @ or ? (free choice)
20:03:46 * oerjan would be happy to be corrected on that
20:04:04 <monochrom> ?quote fugue
20:04:04 <lambdabot42> No quotes match.
20:04:39 <EvilTerran> ?quote fudge
20:04:39 <lambdabot42> No quotes match. And you call yourself a Rocket Scientist!
20:04:41 <EvilTerran> aww
20:05:22 <oerjan> ?quote fu..e
20:05:23 <lambdabot42> shapr says: Programming is the Magic Executable Fridge Poetry, it is machines made of thought, fueled by ideas.
20:07:00 <ramza3> There is no magic in this module that supports Unicode?  I am assuming no.  http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Lazy-Char8.html
20:07:17 <Saizan> no
20:08:05 <Saizan> e.g. pack throws away the higher bits
20:08:09 <ramza3> ok
20:08:23 <ramza3> I looked complicated, so I thought maybe I was looking at it wrong
20:08:52 <bos> Saizan: it's very satisfying to have this stuff working.  thanks!  and i didn't seem to need the oleg level of hackery.
20:10:09 <Saizan> bos: no TypeCast needed? damn, i didn't grok it yet then :)
20:10:40 <bos> oleg lives only about 70 miles from me.  i've been hoping that the thought rays would reach here, but they don't seem to. i'm still just of normal intelligence.
20:11:56 <Saizan> heh, reading his posts it feels like the typechecker is scared of him :)
20:13:38 <bos> Saizan: are you actually in italy?
20:13:49 <Saizan> yes
20:14:16 <Saizan> i shouldn't be awake at this hour..
20:14:49 <dmwit> ?localtime Saizan
20:14:50 <lambdabot42> Local time for Saizan is Thu Jan  3 05:18:05 2008
20:14:54 <dmwit> mmm
20:15:25 * EvilTerran notes that he's only one timezone better off than that
20:15:51 <aFlag> ?localtime aFlag
20:15:53 <lambdabot42> Local time for aFlag is Thu Jan  3 02:15:53
20:16:31 <aFlag> hehe I always try stuff I see people doing on lambdabot :P
20:17:01 <EvilTerran> ?localtime
20:17:02 <lambdabot42> Local time for EvilTerran is Thu Jan 03 04:17:00
20:17:24 <EvilTerran> that's so much easier than typing it myself :P
20:22:24 <Plareplane> ?localtime
20:43:59 <ramza3> with haskell emacs mode,  doc mode, does anyone know how I can copy paste the type definition when it is printed to the echo area?
20:56:43 <bos> ramza3: C-u C-c C-t
20:57:25 <bos> Saizan: i need a few more type annotations than i'd like, which i guess is a hazard of fundeps
20:59:25 <BMeph> bos: Just remember, fundeps are no more "fun" than is a funeral. The first three letters tell nothing of the whole. ;)
20:59:45 <bos> BMeph: yes, i've noticed this many times.
20:59:49 <monochrom> funeral...
21:00:11 <BMeph> Although, getting them to do what you want is fun... at the end of it all. :)
21:00:25 <mauke> ... putting the fun in funerals and laughter in manslaughter
21:00:54 <BMeph> mauke: Yeah, you can't have slaughter without laughter... ;p
21:01:51 * monochrom reports #haskell to the authority. Potential serial killer or rage killer.
21:06:34 <oerjan> > map toUpper $ fix ("kill "++)
21:06:37 <lambdabot42>  "KILL KILL KILL KILL KILL KILL KILL KILL KILL KILL KILL KILL KILL KILL KILL ...
21:08:30 <BMeph> @remember DRMacIver Suppose I told you there were two major areas of your code that were deeply intertwined. Each is intimately connected to the other and it was almost impossible to tell where one started and the other began, yet the two were really very different. Suppose I now told you those two areas were "behaviour" and "data".
21:08:30 <lambdabot42> It is forever etched in my memory.
21:09:01 <mauke> > map (chr . (+ 16) . ord) . tail . show $ ((( 9/11 )))
21:09:04 <lambdabot42>  ">HAHAHAHAHAHAHAHB"
21:11:35 <bos> augh, yet more type hackery ahead of me.
21:14:19 <BMeph> @check \x y -> (getFirst $ First x `mappend` First y) == (x :: Maybe Int) `mplus` (y :: Maybe Int)
21:14:21 <lambdabot42>  quickcheck: /tmp/MJFxQ29900.o: unknown symbol `__stginit_haskell98_Char_' qu...
21:14:34 <BMeph> :(
21:14:35 <mauke> @check True
21:14:37 <lambdabot42>  quickcheck: /tmp/MscVv29904.o: unknown symbol `__stginit_haskell98_Char_' qu...
21:15:22 <justinhj> hi
21:15:45 <shachaf> justinhj: Hello.
21:17:05 <justinhj> I'm working through a book, the haskell school of expression. What can I use with ghc that is like SOEGraphics
21:17:12 <Pseudonym> Oh, we have a lambdabot42?
21:17:28 <mauke> @where soe
21:17:29 <lambdabot42> http://haskell.org/soe/
21:17:55 <mauke> http://haskell.org/soe/software1.htm
21:18:18 <justinhj> groovy thanks
21:21:29 <allbery_b> also soegtk which is part of gtk2hs
21:32:33 <runar> I'm trying to wrap my head around strictness.
21:32:49 <runar> (&&) is strict in its first argument only, right?
21:32:57 <ricky_clarkson> Right.
21:33:05 <Cale> @src (&&)
21:33:06 <lambdabot42> True  && x = x
21:33:06 <lambdabot42> False && _ = False
21:33:13 <runar> (True &&) is strict, yes?
21:33:17 <ricky_clarkson> > fix (True &&)
21:33:19 <lambdabot42>  Exception: <<loop>>
21:33:28 <ricky_clarkson> > fix (False &&)
21:33:29 <Cale> It has to pattern match its first argument to determine the result.
21:33:30 <lambdabot42>  False
21:33:53 <runar> (True &&) does not have to pattern match at all, does it?
21:34:25 <allbery_b> hm?  the True is a pattern match
21:34:35 <Cale> Well, it returns its result unevaluated, but then that must be evaluated, or else the (&&) never would have been.
21:34:46 <Cale> er, returns its argument
21:35:31 <Cale> So  True && x reduces to x, but then whatever pattern match caused the && to evaluate is going to need to evaluate x
21:35:41 <runar> GITH says that a function f is strict if f _|_ = _|_
21:35:52 <Cale> Right, that's the typical definition.
21:36:14 <runar> Ok, so (True &&) is definitely strict by that definition.
21:36:14 <Cale> > True && undefined = undefined, and so (True &&) is strict.
21:36:14 <lambdabot42>  Parse error at "=" (column 19)
21:36:31 <runar> pun not intended
21:36:52 <Cale> But False && undefined = False, so (False &&) isn't strict.
21:37:00 <runar> yay!
21:37:16 <Cale> > True && undefined
21:37:17 <lambdabot42>  Undefined
21:37:22 <ricky_clarkson> > let notstrict x=5
21:37:23 <lambdabot42>  Parse error at end of input
21:37:23 <runar> @bot
21:37:24 <lambdabot42> :)
21:37:31 <ricky_clarkson> > let notstrict x=5 in notstrict undefined
21:37:33 <lambdabot42>  5
21:37:48 <Cale> More subtle are functions like (1:)
21:37:55 <ricky_clarkson> If notstrict was strict in x, the above would have caused a problem.
21:38:10 <Cale> > head (1 : undefined)
21:38:12 <lambdabot42>  1
21:38:23 <Cale> > 1 : undefined
21:38:25 <lambdabot42>  Undefined
21:38:30 <ricky_clarkson> hehe
21:38:41 <yoshi> is there anything similar to the fromEnum function that has :: a -> Double
21:38:43 <Cale> (you get that error, because the undefined value gets evaluated while trying to show the string)
21:39:08 <Cale> yoshi: Well, you could compose fromEnum with fromIntegral
21:39:17 <Cale> :t fromIntegral . fromEnum
21:39:19 <lambdabot42> forall b a. (Enum a, Num b) => a -> b
21:39:33 <yoshi> ah thanks
21:40:07 <runar> > if True then 1 else undefined
21:40:08 <lambdabot42>  1
21:40:09 <ricky_clarkson> > show (1 : undefined)
21:40:11 <lambdabot42>  Undefined
21:40:22 <ricky_clarkson> > show (1 : [])
21:40:24 <lambdabot42>  "[1]"
21:40:40 <ricky_clarkson> > show (1 : undefined) ! 1
21:40:41 <lambdabot42>  Couldn't match expected type `Array i e'
21:40:48 <Cale> > show (1 : undefined) !! 0
21:40:50 <lambdabot42>  '['
21:40:52 <ricky_clarkson> > show (1 : undefined) !! 1
21:40:54 <lambdabot42>  '1'
21:41:03 <ricky_clarkson> Nicely lazy.
21:41:09 <Cale> > show (1 : undefined) !! 2
21:41:11 <lambdabot42>  Undefined
21:41:15 <runar> haha
21:41:23 <ricky_clarkson> There's holes in your string, sir.
21:41:58 <ricky_clarkson> > last [undefined,undefined,undefined,2]
21:41:58 <skew> runar: you could use :print in a newer ghci
21:42:00 <lambdabot42>  2
21:42:19 <skew> runar: except undefined is a bit special and rasises an exception anyway
21:42:26 <runar> I didn't know about print.
21:42:29 <skew> Prelude> let z = z; x = 1:z
21:42:41 <skew> Prelude> :sprint x
21:42:45 <skew> x = 1 : _
21:42:48 <runar> I just use "let bot = bot" and try for the stack overflow.
21:43:08 <ricky_clarkson> > let ones=1:ones in ones -- I like this
21:43:10 <lambdabot42>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:43:18 <Pseudonym> > fix (1:)
21:43:20 <lambdabot42>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:43:45 <Cale> skew: Happen to know why undefined is special in that way?
21:44:11 <Cale> skew: That behaviour (somehow managing to force the tail when it's undefined) seems wrong.
21:44:23 <skew> oh, and 1:bot is actually a cons of two unevaluated thunks, because the litearal is fromIntegral 1
21:44:38 <Cale> Using (error "Undefined") in place of undefined itself works fine.
21:44:47 <skew> Cale: probably because undefined is actually an evaluated value whose entry procedure rasises an exception
21:45:11 <Cale> hmm
21:47:28 <Cale> Interestingly enough, even if I force the tail of x, when that tail is (error "undefined") and the exception occurs, :print just goes on assigning that tail a fresh variable.
21:48:00 <runar> >let ifFun a b c = if a then b else c
21:48:12 <runar> > let ifFun a b c = if a then b else c
21:48:12 <lambdabot42>  Parse error at end of input
21:48:23 <ricky_clarkson> runar: "in ifFun some args here"
21:48:24 <skew> Cale: error will never mark its thunk resolved
21:48:32 <runar> oh, duh
21:48:40 <Cale> skew: But undefined will?
21:48:53 <runar> I want to say that ifFun is strict in its first argument only.
21:49:02 <skew> Cale: I'm guessing undefined is already an evaluated thunk
21:49:16 <ricky_clarkson> runar: ifFun only has one argument.
21:49:18 <skew> Cale: but it's entry procedure raises the exception
21:49:56 <Cale> hmm, all right
21:50:03 <ricky_clarkson> :t \a b c -> if a then b else c
21:50:06 <lambdabot42> forall t. Bool -> t -> t -> t
21:50:21 <runar> ricky_clarkson: don't all functions have one argument, technically?
21:50:42 <Cale> runar: depending on what that first argument is, the result will be strict in either its first or second argument (which is to say, the second or third argument of ifFun)
21:50:44 <ricky_clarkson> Yes.
21:51:25 <ricky_clarkson> Cale said what I meant to.
21:51:27 <Cale> The second parameter of a function is the first parameter of its result.
21:51:37 <runar> right-o, so ifFun is a function from Bool to a function, and is strict in its only argument. That's clever.
21:52:19 <runar> now... how about map?
21:52:19 <ricky_clarkson> Is it right to say it's strict, rather than "it evaluates"?
21:52:42 <Cale> runar: Yeah, multiparameter functions can have arbitrarily complicated strictness when you analyse more than one parameter at a time.
21:52:46 <runar> I don't know, but the books say "f is strict if f bot = bot"
21:52:59 <ricky_clarkson> map is mighty lazy.
21:53:24 <runar> I want to say that map is strict in its second argument.
21:53:27 <Cale> map f is strict
21:53:42 <skew> ricky_clarkson: other way around actually, it's always right to say strict rather than "it evaluates", but not necessarily the other way
21:53:51 <runar> I suppose that means precisely that map f is strict.
21:54:04 <skew> ricky_clarkson: id is strict in the argument, but doesn't evaluate it
21:54:19 <ricky_clarkson> skew: I think I understand.
21:54:48 <skew> I think that's the only way a function can be strict without evaluating an argument
21:55:41 <runar> like (True &&)
21:55:58 <Philippa> actually, under lazy semantics forcing id will force the argument simply because the demand propagates
21:56:34 <Cale> Well, forcing id x will force x, but that's what you meant :)
21:56:42 <skew> yeah, but after evaluation of id proper finishes, at least in some reasonable models
21:57:04 <Cale> right
21:57:23 <Philippa> yeah, the beta reduction'll happen first
21:57:40 * runar makes hand waving gesture over his head and a whooshing sound.
21:58:10 <Cale> runar: We're talking about distinctions so fine that they're actually kind of hard to formalise. It's not terribly important :)
21:58:18 <Philippa> but you haven't finished evaluating (id x) until you've hit WHNF
21:58:27 <runar> I figured it was a bit of hair splitting.
21:58:58 <Philippa> so what you're actually arguing about is "what do you mean by 'a function does something'?"
21:58:58 <skew> I mean x is only evaluated after you have finished with id
21:59:02 <Cale> The question is about when the evaluation of id in the expression id x finishes.
21:59:15 <skew> say, if you color all the expressions introduced in a particular function application and see when they are all gone
21:59:18 <Philippa> I don't think it is
21:59:29 <Cale> A more interesting example is provided by (++)
21:59:34 * runar notes that hairSplit is probably strict.
22:00:13 <Philippa> I don't think there's a meaningful notion of a function "doing something" before the function itself's been evaluated to WHNF (so id's been replaced with \x.x) for example
22:00:19 <Cale> (x:xs) ++ ys = x : (xs ++ ys)
22:00:36 <Cale> When does the (++) really finish?
22:00:39 <Philippa> so in one sense you're "done with id" by then
22:01:16 <Philippa> when there's no demand remaining?
22:01:59 <Cale> It depends on where you put the finish line :)
22:02:30 <Cale> It certainly pattern matches its argument, but it returns a cons, and you could say that at that point, (++) has finished its work.
22:02:42 <Philippa> yes. I don't like "when it hits the first available WHNF" as an answer
22:03:01 <Philippa> but even that one would say that "id x" evaluates x to WHNF
22:03:05 <conal> what are some causes of "<<loop>>" from a ghc-compiled program?
22:03:08 <Cale> There might be something before WHNF for expressions like id x
22:03:37 <Philippa> sure. But you'd be introducing the notion artificially
22:03:41 <Cale> You'd have to somehow treat functions as all the stuff around the copies of the parameters in their body.
22:04:00 <Cale> When that stuff has gone, then the function has "finished"
22:04:22 <Cale> I agree that it's somewhat artificial, but I think it's what skew was getting at.
22:04:44 <Philippa> WHNF isn't artificial in the same way though, it's a necessary point in defining the semantics
22:04:48 <skew> evaluating (id x) evaluates x, that's why it's strict
22:04:50 <Cale> conal: An attempt to force x within the evaluation of x
22:05:00 <Cale> > fix id
22:05:02 <lambdabot42>  Exception: <<loop>>
22:05:19 <skew> but to say "id evalutes x" sounds to me like some code in the body of id is actually demanding x
22:05:20 <conal> Cale: thanks.
22:05:24 <skew> pattern matching on it or something
22:05:29 <Philippa> skew: it is. "x" is
22:05:33 <skew> as opposed to just sticking x in a tail position
22:05:40 <Cale> I've also had <<loop>> exceptions happen from strange bugs in the multithreaded runtime.
22:05:47 <thoughtpolice> gah, why won't lambdabot let me view my messages? :(
22:05:49 <Cale> But that was pre 6.8
22:06:18 <Philippa> but putting x in tail is precisely how you propagate demand. And we already know that id does nothing until demanded, so when demanded it promptly demands x
22:06:33 <mauke> thoughtpolice: you may be filtering messages from unregistered users
22:07:09 <conal> thoughtpolice: i left you a message.  you weren't able to read it?
22:07:09 <skew> well, the original question was the distinction between "foo is strict in arg" and "foo evaluates arg"
22:07:50 <conal> thoughtpolice: thanks much for the tip on http://haskell.org/haskellwiki/Phooey.  i've changed "DataDriven" to "Reactive" and fixed calculator example.
22:08:10 <conal> phooey used to use DataDriven.  now Reactive.
22:08:16 <Philippa> and the distinction is at best that "is strict in" means "/always/ evaluates arg"
22:08:55 <Philippa> that, and that "is strict in" is valid across a wider range of semantic models
22:09:42 <Philippa> "x evaluates y" is an operational concept, "x is strict in y" is a denotational one
22:12:17 <runar> I like the definition given in GITH. A function f is said to be strict if, when applied to a nonterminating expression, it yields a nonterminating expression.
22:14:52 <runar> It allows what exactly is evaluated, and how, to be completely opaque.
22:14:54 <skew> yeah, that's a good one, and standard
22:15:42 <bos> @hoogle fracToReal
22:15:43 <lambdabot42> No matches found
22:15:58 <skew> Philippa: I think you can define the operational concept so it's reasonable to say id is strict in the argument without evaluating it
22:16:57 <bos> @hoogle CDouble -> Double
22:16:58 <lambdabot42> No matches, try a more general search
22:17:03 <bos> crap.
22:18:36 <Philippa> skew: I think you can define /an/ operational concept that way, yes. It won't be lazy evaluation though
22:18:59 <Philippa> runar: yep, that's /the/ definition of strictness - anything else is exploring consequences
22:20:07 <skew> Philippa: I think you get an operational concept like that if you look for example at the way GHC uses the stack
22:20:14 <Philippa> skew: it won't even be how most compilers do it - they'll generate code that amounts to "id x = force x"
22:21:05 <mauke> bos: realToFrac
22:22:06 <bos> mauke: yeah, found it.
22:22:59 <Philippa> you're essentially trying to argue that tail calls aren't something the calling function "does"
22:23:34 <Philippa> which is odd, not least because I'm pretty sure that if the tail was a constructor you'd say the function constructs the appropriate value
22:23:56 <skew> not tail calls exactly, but just returning an argument
22:24:09 <skew> it seems natural to me to say that the function returns the value
22:24:19 <BMeph> Here's an fun one: (const undefined) is a function that is strict, although it does not evaluate its argument.
22:24:31 <Philippa> right. *Value*. That requires ensuring that it's been evaluated
22:24:57 <skew> returns the argument, like the function has finished and returns something, before evaluation actually moves into the argument
22:24:57 <Philippa> so what it actually does is force the argument and return the result
22:25:04 <scook0> BMeph: not to mention the function (undefined)
22:25:35 <shachaf> lambdabot++
22:25:43 <shachaf> @bot
22:25:43 <lambdabot> :)
22:25:44 <lambdabot42> :)
22:25:53 <Philippa> the entire concept of 'return' changes when you're dropping something else onto a continuation stack though
22:26:15 <Philippa> you're doing exactly the same thing as claiming a tail call isn't a return
22:26:23 <ricky_clarkson> @bab es en quien es la mas rpido?
22:26:24 <lambdabot42>   who is but r I request?
22:26:26 <skew> It don't mean making a tail call to another function and passing the argument
22:26:31 <shachaf> dons: mux said someone should /kick lambdabot42 when there's a suitable replacement.
22:26:34 <lambdabot> Plugin `babel' failed with: getHostByName: does not exist (no such host entry)
22:26:51 <skew> I mean actually putting an argument in a tail position
22:26:51 <shachaf> (However, it looks like lambdabot still needs some fixing?)
22:26:58 <ricky_clarkson> There's clearly no suitable replacement while babel doesn't work.
22:27:09 <Philippa> yes, which on account of the requirement to /evaluate/ that argument is nearasdammit the same thing
22:27:34 <Philippa> we're talking about a cbv encoding of cbn semantics, arguments become something you call
22:27:51 <shachaf> http://haskell.org/
22:27:52 <lambdabot> Title: Haskell Community Server
22:28:11 <shachaf> Hmm.
22:28:13 <mauke> @check True
22:28:13 <lambdabot>  OK, passed 500 tests.
22:28:15 <lambdabot42>  quickcheck: /tmp/MtXMH30126.o: unknown symbol `__stginit_haskell98_Char_' qu...
22:29:28 --- mode: ChanServ set +o allbery_b
22:29:44 --- kick: lambdabot42 was kicked by allbery_b (allbery_b)
22:30:02 --- mode: allbery_b set -o allbery_b
22:30:02 <shachaf> @babel en es magnesium
22:30:03 <lambdabot>   magnesio
22:30:19 <allbery_b> bah, xchat doesn't support * shorthand
22:30:19 <shachaf> @bab es en quien es la mas rpido?
22:30:20 <lambdabot>   who is but r I request?
22:30:28 <shachaf> ricky_clarkson: Seems to work.
22:30:54 <ricky_clarkson> Not the translation I wanted, mind.
22:31:05 <ricky_clarkson> @bab en es who is the fastest?
22:31:32 <shachaf> ricky_clarkson: Did you expect to get the translation you wanted?
22:31:53 <allbery_b> btw, dons: lots of political bots running loose on freenode of late.  (and the ban list is full)
22:31:58 <ricky_clarkson> Sometimes I do.
22:32:03 <skew> ricky_clarkson: so, did any of that answer your question?
22:32:42 <ricky_clarkson> skew: Yes, the first thing you said answered it.
22:41:25 <nickchange> why is getArgs in IO? does it actually need to perform a syscall to get the arguments? (i naively thought the arguments to a program was put on the stack when control passed to its _start..
22:42:05 <mauke> well, there's a withArgs
22:42:38 <mauke> but in my opinion main :: [String] -> IO () would have been nicer
22:42:46 * runar hopes to some day fire a programmer with the words: "You're terminated, you lazy thunk!"
22:43:17 <nickchange> yeah, i guess that's also my question.. why isn't main [String] -> ..
22:44:11 <runar> hmm
22:44:15 <runar> why [String] ?
22:44:54 <nickchange> what'd you rather have?
22:45:08 <runar> Well, [Image] might be nice, for some programs.
22:45:46 <runar> [Maybe String] might be nice too
22:45:50 <nickchange> you don't ./prog <image>... you give it a string which might be the name of an image file..
22:46:15 <mauke> runar: huh?
22:46:19 <nickchange> and getArgs gives [String]
22:46:24 <Korollary> nickchange: iirc it had something to do with some programs' being able to modify the args after startup.
22:46:32 <runar> You're importing the operating system semantics into the language, in that case. None for me, thanks.
22:46:45 <mauke> runar: er, you do that anyway
22:47:03 <mauke> @bot
22:47:03 <lambdabot> :)
22:47:50 <mauke> anything that runs C will (pretend to) pass an array of strings to programs
22:47:56 <Philippa> mauke: not in the same way though, you can presently shift to another OS's semantics just by replacing the operations /other than >>= and return/ in the IO monad
22:47:59 <runar> I don't think I do, but OK.
22:48:33 <Philippa> for that matter, you can shift to no OS but the RTS that way
22:49:17 <runar> Haskell-OS!
22:49:28 <mauke> I must be missing something
22:49:58 <mauke> you could always add getOSSpecificStuff :: whatever, no matter what main looks like
22:50:17 <runar> mauke: Imagine running a haskell program in an environment that has no file system, and no pipes.
22:50:27 <mauke> ok
22:51:00 <mauke> now what?
22:51:19 <runar> Now run the program passing it an image.
22:51:34 <mauke> what does that mean?
22:51:57 <Philippa> mauke: yes, but if main includes some OS-specific stuff you can't get rid of it
22:52:10 <nickchange> you're gonna have to get the "Image" type from somewhere? .. ie. the OS.. so the OS is imported into the language then?
22:52:16 <sclv> @hoogle atomicModifyIORef
22:52:16 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
22:52:19 <mauke> Philippa: you could always pass [] to indicate "no command line available"
22:52:21 <runar> It means that "image" is an OS primitive. Maybe it's a highly specialized image processing engine and your haskell program is embedded in a DSP or something.
22:52:25 <sclv> the signature confuses me :-(
22:52:32 <mauke> or call Freestanding.main instead of Main.main
22:52:32 <Philippa> mauke: this is called a waste
22:53:01 <Philippa> IOW, you'd have to commit a further gross hack
22:53:27 <sclv> the a of (a,b) goes into the IORef and the b gets returned?
22:53:41 <mauke> it's what C does :-)
22:54:06 <Philippa> yes. Since when is C something for us to aspire to?
22:54:23 <mauke> since 100% of my Haskell programs run on systems with a command line, I see no reason not to optimize for this common case
22:55:09 <runar> You can write a simple module to reuse for that case, no?
22:55:28 <runar> In fact, don't legions exist already?
22:55:35 <Philippa> mauke: so define a single-char func to wrap the main you want to write that calls getArgs and passes the result in
22:55:59 <runar> What Philippa said.
22:56:05 <mauke> hmm, right
22:57:46 <hpaste>  sclv pasted "Oh ugly ugly code." at http://hpaste.org/4772
22:57:58 <runar> Programming languages like Haskell will outlive the command line interface.
22:58:48 <sclv> I don't know if the unsafePerformIO semantics will work right for this either even...
22:59:51 <mauke> somehow I feel uneasy about seeing getClockTime inside unsafePerformIO
23:00:10 <sclv> the whole thing is messy, but I want a referentially transparent cache.
23:00:30 <sclv> which is, I'll grant, a contradiction in terms.
23:00:32 <Philippa> I think you're missing some of the necessary NOINLINE etc?
23:00:38 <Philippa> a cache with an RT interface
23:00:50 <sclv> Philippa: yeah. I know I need to add some of that stuff later.
23:01:49 <Philippa> I think the big question is: will it ever allow you to break x = x by accident?
23:02:01 <Philippa> rather, x == x for stuff with Eq?
23:02:23 <sclv> the stuff its caching doesn't implement Eq so we should be alright on that count.
23:02:35 <Philippa> that's not really the issue
23:02:43 <ricky_clarkson> runar: Programming languages like Haskell extend the life of the CLI.
23:02:56 <runar> or replace it
23:03:07 <Philippa> it's more: will you ever get a different value back out?
23:03:41 <sclv> That's sort of the point of it actually -- I know I'm playing fast and loose with concepts like RT here, so its only intended to be an alternate interface.
23:04:01 <Philippa> ricky_clarkson: not really. The current toolchain does a little, but it's easy to imagine a haskell IDE for windows that doesn't give a damn
23:04:01 <runar> (the awful) PowerShell by Microsoft is an example of a CLI where arguments you pass are not strings at all.
23:04:01 <ricky_clarkson> Philippa: Yes.
23:04:01 <Philippa> an alternate interface to what?
23:04:04 <sclv> But conceptually template files should be "sort of static" quantities.
23:04:20 <sclv> Philippa: my templating library. Its almost done.
23:04:21 <Philippa> okay, so it's static so long as the templates aren't updated I guess
23:04:41 <Philippa> if you're picky you can copy the files as cached at the time to a temp dir, too
23:04:51 <sclv> right: the notion is that the templates get updated either in development or when yr. pushing a fix live, but that those are exceptional circumstances.
23:05:03 <glguy> what sort of templates are you using?
23:05:08 <Philippa> and if you push a fix you intend to break RT anyway
23:05:23 <sclv> ideally you'd swap out the short term caching for some sort of permanent stuff (or even compile-time!) when you launch.
23:05:36 <sclv> glguy: its got pretty much all the StringTemplate grammar in place.
23:05:44 <sclv> no group files or interfaces yet, tho.
23:05:47 <glguy> heh, I just did a StringTemplate implementation today
23:05:50 <Philippa> I guess you could have the cache check for known fixes, too
23:06:06 <sclv> I guess its an idea whose time has come.
23:07:44 <sclv> anyway, suggestions as to how to make the ugly code somewhat more elegant, if not less unsafe, are very welcome.
23:08:17 <glguy> You are trying to cache template loads from file?
23:08:25 <sclv> glguy: yep.
23:08:26 <glguy> transparently
23:08:44 <sclv> that's the notion.
23:08:49 <glguy> I didn't implement file loading yet
23:08:54 <glguy> I've been loading them from strings so far
23:09:41 <sclv> the loading from files is just:
23:09:42 <sclv> stringTemplateFileGroup path = stfg
23:09:43 <sclv>   where stfg =  First . Just . STMP (SEnv M.empty [] stfg) . parseSTMP ('$','$') . unsafePerformIO . readFile . (path ++)
23:09:55 <sclv> (yay circular programming!)
23:10:15 <glguy> do you know what the expected behavior of: $[1,2],3:{ a b | $a$ $b$ }$ is?
23:12:27 <sclv> " 1 3  2  "
23:12:32 <sclv> is what my implementation gives, at least.
23:13:08 <sclv> I don't think its officially allowed in the StringTemplate grammar
23:14:51 <sclv> and actually, my implementation doesn't allow raw numerals as literals, only strings.
23:17:19 <glguy> ditto
23:17:28 <glguy> but I didn't feel like cluttering the example :)\
23:18:13 <sclv> are you planning to release yrs. as a public library?
23:19:15 <glguy> eventually, I was doing it at work today
23:19:35 <dons> yo glguy
23:19:36 <sclv> hmm... we should combine forces maybe?
23:19:58 <sclv> I've got mine almost ready for a 0.1 release once I get the file work done.
23:20:12 <glguy> dons: how was Mexico?
23:20:31 <dons> warm :) just got off the plane -- without bags unfortunately :(
23:20:45 <glguy> sclv: yeah, I'd being willing to chip in
23:21:00 <sclv> cool.
23:21:04 <glguy> what license?
23:21:42 <sclv> I'll see what I can do about getting a hosted darcs repo running tomorrow. I think its mainly API style work that needs to be done now -- plus the interfaces and groups, but those seem less central for an initial release.
23:21:57 <sclv> glguy: I figured BSD, since that's what StringTemplate is under.
23:22:02 <glguy> cool
23:22:15 <runar> dons: Did the airline lose your bags?
23:22:17 <glguy> just making sure you weren't doing anything more restrictive
23:22:30 <glguy> if I'm going to be working on it I'd like to be able to use it :)
23:23:09 <sclv> yeah this has been my big hobby project to teach myself parsing and interpreters and also haskell is sort of at that stage where it seems really handy and useful all round.
23:23:46 <dons> runar: yeah, but just got a call saying they've been found. yay!
23:23:47 <yoshi> how do I turn a string into a list of characters
23:23:55 <mauke> yoshi: id
23:23:56 <Zao> yoshi: It is.
23:23:58 <runar> wo0t!
23:23:59 <runar> o/
23:24:04 <dons> that was scary
23:24:10 <mauke> @src String
23:24:10 <lambdabot> type String = [Char]
23:24:56 <runar> I have a theory that the airlines put a special tag on my bags that says "lose this one".
23:25:03 <yoshi> > filter (/=" ") "123 456"
23:25:04 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
23:25:11 <mauke> yoshi: " " is a string
23:25:20 <runar> But, that's neither here nor there. Now, lambdabot.
23:25:39 <yoshi> > filter (/=(" "::char)) "123 456"
23:25:39 <lambdabot>   " "
23:25:44 <BMeph> > filter (/=' ') "123 456"
23:25:45 <Korollary> try ' '
23:25:45 <lambdabot>  "123456"
23:25:51 <mauke> what the
23:26:03 <yoshi> ah thanks
23:26:12 <runar> I would like to compile lambdabot under 6.8.2, but I cannot, as hs-plugins is required, and I haven't had any luck compiling it with 6.8.
23:26:18 <Korollary> > filter (/=(" "::char)) "123 456"
23:26:19 <lambdabot>   " "
23:26:22 <Korollary> eh?
23:26:59 <mauke> :t filter (/=(" "::char)) "123 456"
23:27:00 <lambdabot>     Couldn't match expected type `char' (a rigid variable)
23:27:00 <lambdabot>            against inferred type `[Char]'
23:27:00 <lambdabot>       `char' is bound by the polymorphic type `forall char. char'
23:27:26 <thoughtpolice> runar: if you darcs get from http://code.haskell.org/~dons/code/hs-plugins, it should build on 6.8.2 just fine (I'm on 6.8.2 and using it in a project right now)
23:27:26 <lambdabot> Title: Index of /~dons/code/hs-plugins
23:28:16 <runar> thoughtpolice: What version of Cabal?
23:28:45 <thoughtpolice> runar: >= 1.2.3, so you should be fine since it comes stock
23:31:03 <runar> src/System/Plugins/PackageAPI.hs:64:20:
23:31:03 <runar>     Not in scope: data constructor `InstalledPackageInfo'
23:32:35 <runar> Now, that's part of Cabal, and it's there. What do you mean it's not in scope?
23:33:25 <thoughtpolice> hm. i don't know on that note, judging from darcs changes it doesn't seem like there have been any real changes to the code base since I used it.
23:33:33 <thoughtpolice> well, installed.
23:34:09 <runar> I cry.
23:34:36 <thoughtpolice> indeed. :(
23:38:46 <thoughtpolice> hm, very weird. i tried building the repo again and now it's telling me that my gcc is broken. :(
23:40:43 <thoughtpolice> hm just had to su.
23:40:52 <thoughtpolice> runar: very weird, it's building fine on this box. :/
23:41:06 <runar> "works on my machine"
23:41:16 <thoughtpolice> quite a problem, isn't it.
23:41:30 <runar> I might have Cabal incorrectly installed
23:42:09 <runar> hmm... nope
23:42:14 <runar> I don't think so.
23:42:36 <runar> other libraries do just fine with it
23:43:40 <Thunde1> @where lambada
23:43:40 <lambdabot> I know nothing about lambada.
23:44:10 <ulrivo> @list
23:44:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
23:49:44 <SilentBob> Hi, I've just downloade hugs and I've created a file called test.hs in the hugs dir. I'm trying to :load test.hs, but im getting the error message ERROR file:test.hs - Module "Main" already loaded. What am i doing wrong?
23:50:10 <skew> how are you running hugs?
23:50:58 <skew> Should Haskell include left slices of :: ?
23:51:25 <skew> I'm looking at some code that defines an identity function with a restricted type, just to stick an annotation in a pipeline
23:52:07 <skew> interact (show . (1+) . (::Double) . read) ?
23:52:15 <glguy> asTypeOf
23:52:18 <glguy> or
23:52:21 <glguy> id :: Double
23:52:58 <skew> that's (`asTypeOf` undefined :: Double)
23:53:49 <skew> In Morrow type annotations were just defined by translating them into applications of coercion functions
23:54:00 <SilentBob> im running hugs by running winhugs.exe
23:54:39 <skew> SilentBob: what does the prompt look like, and does test.hs have a module line?
23:54:57 <SilentBob> Main> :load test.hs
23:54:57 <SilentBob> ERROR file:test.hs - Module "Main" already loaded
23:54:57 <SilentBob> Main>
23:55:08 <skew> oh, then you already have loaded a main module
23:55:10 <SilentBob> module Main where
23:55:12 <SilentBob> import System.Enviroment
23:55:12 <SilentBob> main = do
23:55:12 <SilentBob> 	args <- getArgs
23:55:12 <SilentBob> 	putStrLn (unwords args)
23:55:17 <SilentBob> thats test.hs
23:55:28 <skew> maybe you want :reload?
23:55:28 <SilentBob> (i yoinked the code from a website)
23:56:16 <SilentBob> can i unload whatever main file ive loaded (i have no idea what ive got loaded)
23:56:26 <SilentBob> and then :l test.hs ?
23:56:27 <skew> plain :load should do that
23:56:34 <skew> unload things
23:56:59 <skew> but hugs here (sept 2006 release on linux) is happy to reload a file with :load
23:59:27 <skew> SilentBob: maybe you are not in the right directory? try :load System.Directory then getCurrentDirectory >>= putStrLn
