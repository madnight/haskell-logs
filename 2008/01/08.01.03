00:01:35 <SilentBob> nope, its the right dir
00:02:21 <SilentBob> i think im missing something really simple, but the book ive got does teach you how to use hugs
00:02:30 <dibblego> which book?
00:02:53 <SilentBob> 'Programming in Haskell', Graham Hutton
00:02:55 <skew> try removing the module line, it ought to match the filename anyway
00:04:05 <SilentBob> is there a way i can get back to the command line just being >
00:04:09 <SilentBob> and not Main>
00:04:18 <skew> :load
00:04:47 <SilentBob> Main> :load
00:04:48 <SilentBob> Main>
00:05:08 <skew> works on linux. Try :browse Main, see what's there
00:06:06 <SilentBob> Main> :load
00:06:11 <SilentBob> Main>
00:06:11 <SilentBob> whoops
00:06:17 <SilentBob> Main> :browse Main
00:06:18 <SilentBob> module Main where
00:08:14 <skew> here hugs starts in a module called "Hugs" defined by "module Hugs where"
00:08:34 <skew> seems like your hugs uses a fake module called main
00:08:53 <skew> and :load tries to add in an additional module, but your new module is also called main
00:09:25 <skew> so, delete the module Main line from test.hs
00:09:48 <skew> or change it to Frumple
00:09:53 <SilentBob> yeap, that line is gone
00:10:08 <skew> default name may still be Main
00:10:46 <skew> I get your error if I say a file is "module Hugs"
00:10:59 <skew> and a file with no module declaration comes up as Main
00:11:26 <skew> weird that your windows version comes up in Main - you have the latest?
00:11:45 <SilentBob> yeah, just downloaded it
00:12:46 <SilentBob> ok, in module manager, ive got packages\hugsbase\Hugs\Prelude.hs, packages\base\Prelude.hs and pakcages\hugsbase\Hugs.hs
00:12:48 <SilentBob> is that normal?
00:13:20 <skew> I don't know, I'm not running the windows version
00:13:35 <skew> I mostly use ghci, except on my little laptop
00:13:51 <SilentBob> haha ok :P
00:14:18 <glguy> sclv: still about?
00:14:19 <SilentBob> im just trying to find a place where i can start to learn from, but i cant get hugs working :s
00:14:33 <sclv> glguy: yep, but need to turn in soon.
00:14:50 <glguy> sclv: do you know if you can have: $a,b:c()$ ?
00:15:12 <glguy> normally you might use an anonymous template with multiple iterator arguments
00:15:30 <Korollary> SilentBob: You can try ghc on windows, too.
00:15:47 <SilentBob> ive just ssh'd to my university linux box
00:15:56 <SilentBob> typed 'hugs' and im in something :P
00:16:02 <SilentBob> ill see if i can get this working
00:16:22 <sclv> glguy: regular templates only take one argument. so it doesn't make much sense. i accept it and fail semi-silently on my implementation but the correct behavior is probably to take an error?
00:16:42 <glguy> I'm wondering if that shouldn't be a parse error
00:17:56 <sclv> st's semantics on arity mismatch are pretty ill-defined so I'm just taking as much as possible and, e.g., in that instance, just handling the head.
00:18:56 <sclv> it makes it so much easier to treat regular and anonymous templates the same.
00:19:01 <SilentBob> ok Korollary, skew, the linux one seems to be acting how i thought it should
00:19:04 <SilentBob> cheers for the help :)
00:19:41 <sclv> plus you get bonuses like $a,b:{a | blahblah}, b(blah=a), {a | foobar}$
00:20:05 <glguy> yup
00:20:11 <glguy> I don't treat them differently in my AST
00:20:17 <glguy> but I obviously parse them differently
00:22:33 <glguy> allowing: $(expr)()$ adds a whole layer of run-time errors
00:25:29 <sclv> runtime errors are no fun -- I just trap for null templates and then return some sort of default string.
00:25:50 <glguy> do you support $ var ; null = "n/a" $
00:26:25 <sclv> yep -- got everything except the autoindentation, which looks sort of broken anyway.
00:26:37 <glguy> good deal
00:26:43 <sclv> it seems like it makes more sense to add that later as a mostly separate layer.
00:26:43 <glguy> let me know when you publish the repo
00:27:05 <glguy> autoindent is tightly bound to the parse step
00:30:17 <sclv> glguy: yeah, except you don't really know how far you've indented till runtime.
00:30:43 <sclv> because you can have multiple things on the same line.
00:30:44 <glguy> Agreed. I just mean that you can't do it after the fact
00:31:04 <glguy> You have to count the indent at parse-time and add them up at run-time
00:32:15 <sclv> I was thinking escaping the strings you return to leave room for control codes, then putting control codes in the results of your execution, then putting the whole shebang through a final prettyprinter
00:32:46 <sclv> its really weird to mix up essentially a funny form of lambda-calculus with something entirely different.
00:33:33 <glguy> do you have value types other than string list map null ?
00:34:24 <sclv> yep -- i did some typeclass work so pretty much anything can be passed in, with the right instances in place. that's how I'm going to implement format strings.
00:34:59 <sclv> eventually I'd like to hook it up to HAppS-Data or somesuch, as well as common xml representations.
00:35:09 <glguy> I'm not sure I like the builtin-function syntax
00:35:14 <glguy> I'd rather:  [1,2,3].rest
00:35:21 <glguy> over: rest([1,2,3])
00:35:48 <glguy> seems out of place as it is
00:35:50 <sclv> eh. it makes the parsing sort of a pain -- as does having the pipe only after the variables in the anonymous template.
00:36:10 <sclv> its all pretty cobbled together, but still much nicer than most else.
01:27:45 <skew> Philippa: I see your LtU comment about some kind of refactoring tools, interested in some rough GUI bits?
01:28:58 <Philippa> skew: sure
01:29:30 <Philippa> though I can't promise I'll get anything done too quickly - I've got one good project on the run already and I'm not exactly well-known for productivity
01:29:50 <Philippa> but any help makes it more likely I'll at least kludge up a proof of concept
01:30:08 <skew> I'll try to bundle it up and mail it to you
01:30:42 <Philippa> cool, thanks. Do you have an address for me?
01:30:50 <skew> from your home page
01:31:03 <Philippa> that should work fine :-)
01:31:26 <skew> the main thing is a function that takes an expression and callbacks that want a zipper, and makes a window pretty printing the document
01:33:04 <skew> can you build Yhc?
01:34:49 <dibblego> ?where zipper
01:34:49 <lambdabot> I know nothing about zipper.
01:34:51 <dibblego> ?where zippers
01:34:51 <lambdabot> I know nothing about zippers.
01:35:03 <skew> shame!
01:35:13 <dibblego> ?where+ zippers http://en.wikibooks.org/wiki/Haskell/Zippers
01:35:13 <lambdabot> It is forever etched in my memory.
01:38:02 <Philippa> I haven't tried building Yhc yet - I work under windows though, which is pretty much the main factor
01:38:13 <Philippa> the main thing sounds pretty useful though!
01:38:25 <skew> Philippa: I grabbed Yhc core for my expression type
01:38:34 <skew> It needs uniplate at least
01:38:58 <Philippa> 'k - I'll see how I get on with it
01:39:14 <Philippa> does your view window also allow selecting subexpressions?
01:39:21 <skew> yes
01:39:35 <Philippa> cool, I can build the rest around it then
01:39:36 <skew> it's built around a hacked up wadler pretty printer
01:39:52 <skew> which remembers where the subexpressions are in the output
01:41:34 <Philippa> cool. The idea from there's to maintain a stack of transformations - or rather, a history of such stacks as the user edits stuff
01:42:16 <Philippa> then the "fun" bit is finding a suitably stable way to name subexpressions that's robust against edits to the 'source' and knows when an edit's broken the chain
01:42:47 <Philippa> so that you can not only transform at will but do your transformation work in parallel with further work on the code base
01:43:13 <Philippa> hmm. I should probably have a chat with some of the darcs guys at some point, it's going to end up retreading some of their stuff
01:44:50 <skew> ok, I sent you my working code
01:45:14 <skew> It happens to use Yhc core as the expression type now, as I was hacking it up as a frontend to Neil's supero
01:45:34 <skew> but not quite to the point where derivied functions remembered the history they were derived through
01:46:03 <skew> It does demonstrate transforming the selected subexpression
01:46:32 <skew> and more simply, also widening the text selection to the whole of the smallest subexpression containing the current selection
01:47:08 <Philippa> cool. I'll see what I can do with it - probably not today though
01:47:41 <skew> I'd like you to see if it at least builds
01:48:09 <Philippa> *nod*
01:48:35 <Philippa> I'll set something running after it shows up in my mailbox. I'm due out for the afternoon though and I'm probably falling asleep as soon as I get back - I'm kinda wrapping round from having been nocturnal
01:48:39 <skew> I should be able to replace Yhc core with something with fewer dependencies pretty easily, needs gtk2hs too
01:49:00 <skew> I'm still on the nocturnal
01:54:25 <quicksilver> skew: screenshot?
01:56:12 <matthew-_> Philippa: is that a deliberate 25 or 26 hour day pattern?
01:56:24 <skew> it's not much to look at
01:56:31 <skew> a text box with buttons underneath
01:56:57 <matthew-_> @seen dons
01:56:58 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 2h 20m 51s ago.
01:57:02 <skew> the most interesting bit is that I seriously mangled wadler's code to pretty-print in pxiel width of the text
01:57:17 <Philippa> matthew-_: no, it's an involuntary and rather unpleasant one. The week where you wake up somewhere between 6pm and 4 am is pretty damn isolating
01:57:22 <skew> most interesting graphical thing anyway
01:57:46 <glguy> sclv: any chance you actually didn't go to bed?
01:57:50 <Philippa> I've been stuck with it the last couple of months, I'm hoping it'll clear up as the days get longer again
01:58:45 <Philippa> skew: sounds "fun" - take it much further and you'll end up reinventing TeX :-)
01:59:45 <matthew-_> well which of us hasn't tried reinventing TeX?
02:00:19 <skew> That's a later project for an actual editing thing
02:00:33 <skew> this was just because wrapping by characters is really wrong with a proportional font
02:00:46 <skew> guess I could have just requested mono
02:01:07 <shag> if i want to compress a large IntMap containing IntSets using the bzlib library, i have to convert that thing into a ByteString beforehand. someone know how to do that?
02:03:43 <Philippa> matthew-_: some of us got a short way, realised that was what we were about to do and decided against it :-)
02:04:56 <skew> I am actually planning to try some editor ideas that want manual text layout, but not this project.
02:06:11 <matthew-_> shag: Data.Binary may help
02:06:54 <shag> matthew-_: aaah! thanks!
02:06:56 <skew> Philippa: do you have the code yet?
02:09:55 <Philippa> nope, 'fraid not
02:10:37 <Philippa> looks like my host's got some maintenance issues, it's likely that their mail server'll be running slow today
02:12:35 <oklopol> > 7
02:12:37 <lambdabot>  7
02:16:56 <skew> Hey, Olaf Chitil has a nicer pretty printer
02:17:22 <oklopol> > (\a*2 -> a-1) 8
02:17:22 <lambdabot>  Parse error at "*2" (column 4)
02:17:28 <oklopol> > (\a+2 -> a-1) 8
02:17:28 <lambdabot>  Parse error at "+2" (column 4)
02:17:38 <oklopol> > (\(a+2) -> a-1) 8
02:17:38 <lambdabot>  Parse error in pattern at "->" (column 9)
02:17:49 <skew> darn, "extended abstract"
02:17:59 <oklopol> doesn't haskell have that?
02:18:09 <b_jonas> I think +n patterns are disabled in lambdabot
02:18:13 <oklopol> oh
02:18:15 <oklopol> why?
02:18:24 <bos> @seen dons
02:18:24 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 2h 42m 18s ago.
02:18:46 <oklopol> also, does haskell have just that, or can you do that for any reversible function?
02:19:09 <earthy> just that
02:19:16 <oklopol> thought so
02:19:19 <earthy> n+k patterns are considered a bad feature by some
02:19:24 <earthy> however, there is talk of 'views'
02:19:35 <earthy> which would provide much similar functionality
02:19:38 <oklopol> first class pattern matches or something?
02:19:44 <earthy> something like that yeah
02:19:58 <earthy> however, that's very much in the experimental stage
02:20:23 <skew> ah, finally published as "Pretty printing with delimited continuations"
02:21:06 <earthy> hm. neat.
02:21:30 <b_jonas> earthy: would that be like setf in common lisp or foo= methods in other languages?
02:21:33 <skew> earthy: I like the use of non-standard induction principles in Epigram
02:21:52 <earthy> b_jones: unsure.
02:22:07 <b_jonas> earthy: the other possibility I can think of is like Mathematica's patterns
02:22:15 <earthy> as I don't know lisp well enough and don't understand the foo= remark
02:22:22 <earthy> ah, yeah, somewhat like mathematica's patterns
02:22:24 <oklopol> +=
02:22:25 <oklopol> -?
02:22:28 <oklopol> *-=
02:22:31 <b_jonas> oklopol: yes,
02:22:34 <b_jonas> but you can define new ones
02:22:42 <b_jonas> you can define a foo= method for a class
02:22:51 <oklopol> in lisp?
02:22:52 <b_jonas> then you say anobject.foo= 4
02:22:55 <b_jonas> no
02:23:00 <oklopol> in what then
02:23:03 <b_jonas> in lisp it's called setf (I think)
02:23:08 <b_jonas> but that's the same feature
02:23:08 <oklopol> i think so too
02:23:12 <skew> b_jonas: that's different from view
02:23:12 <b_jonas> in ruby or c++ or D
02:23:28 <oklopol> didn't know c++ has that
02:23:31 <earthy> ah, but that's not quite the same as n+k patterns
02:23:33 <skew> a view is like writing pattern-matching in a different basis
02:23:33 <oklopol> must be a new add.
02:23:36 <b_jonas> the point is, you can define what assigning to something that _looks like_ a method call does
02:23:47 <b_jonas> that's what both setf and the foo= methods do
02:23:54 <b_jonas> otoh Mathematica is completely different
02:23:55 <skew> updating subterms is a different problem
02:24:00 <earthy> or views
02:24:03 <earthy> yeah
02:24:14 <earthy> it has nothing to do with assignment
02:24:25 <earthy> ofcourse, in mathematica the matter is somewhat muddled
02:24:38 <b_jonas> it has (in addittion to the usual patters for atoms and data constructors) patterns that match only iff a given expression is true
02:24:40 <earthy> but that's mathematica for you. ;)
02:24:57 <b_jonas> it evaluates the expression when matching the pattern, and it can use the value of whatever it's matched to
02:25:03 <skew> views might let you match a queue as x :< rest or EmptyQ, even if it's really some effient data structure
02:26:06 <b_jonas> skew: I think that's like foo= methods
02:26:16 <skew> defining how setf handles a function is kind of related
02:26:22 <b_jonas> yep
02:26:44 <skew> but views generally just refer to getting the accessor side working in the first place
02:27:53 <skew> but extending them to update could be nice, if you get views in the first place
02:29:41 <skew> If the view patterns can use functions like insert as if they were constructors that would be closer
02:29:45 <b_jonas> um, I wasn't thinking of update really
02:30:02 <skew> I think the stuff about forced arguments in Agda might do it
02:30:17 <b_jonas> what's that?
02:30:36 <skew> I think you can make caseQueue <expr> (\.(insert x rest) -> ...) (\.(empty) -> ...) valid
02:30:47 <skew> where insert :: a -> Queue a -> Queue a, empty :: Queue a
02:31:07 <skew> it's dependently typed, so the shape of some arguments can be forced
02:31:32 <b_jonas> hmm
02:31:33 <b_jonas> I see
02:31:47 <skew> like data Preimage f a where Preimage x :: Preimage (f x)
02:32:13 <b_jonas> I think though that this kind of thing ruins the simple syntax,
02:32:19 <b_jonas> because it makes shadowing such names harder
02:32:21 <skew> rather, Preimate x :: Preimate f (f x)
02:32:40 <b_jonas> like, what if you want to define a function named insert, and the parser thinks you want to pattern match a tree isntead?
02:32:44 <skew> if some part of a pattern match is forced by other arguments can write it anyway
02:32:53 <b_jonas> it's the same as the +n patterns and redefining + but in larger scale
02:32:57 <skew> but in .()
02:33:09 <skew> and also arguments can be implicit
02:33:39 <srid> what do you recommend next to YAHT?
02:33:46 <b_jonas> well, I trust they woudln't break haskell98 syntax with whatever they invent, so they'll find out something
02:33:46 <skew> Actually, scope is easier because it's just normal expressions
02:34:27 <ArtfclIntllgnc_> is that trust well founded?
02:34:44 <skew> It's just that you know from fancy types that some subexpression has to equal the result of evaluating e.g (expensiveFunction x y)
02:34:46 <b_jonas> ArtfclIntllgnc_: well, if it's haskell then I think yes
02:34:50 <b_jonas> not in all languages
02:35:01 <b_jonas> like, I wouldn't be sure in lisps or ruby
02:35:05 <skew> where that's whatever function was actually in scope when the fancy type was defined
02:35:21 <ArtfclIntllgnc_> I meant the head of ghc vs. haskell98.
02:35:28 <skew> so in another scope the pattern might be .(Queues.insert x rest)
02:35:43 <b_jonas> ArtfclIntllgnc_: I think those are mostly compatible
02:36:00 <ArtfclIntllgnc_> mostly, got it.
02:37:30 <sstipic> hi
02:37:45 <skew> welcome
02:38:12 <sstipic> can somebody explain me what is the difference between monadic and unary functiona, and dyadic and binary function? tnx
02:38:36 <b_jonas> sstipic: it's a terminology thing, the names depend on which programming language you talk about
02:38:53 <sstipic> i am currently learning 'j programming language' but it has some simmilarity with haskell
02:39:37 <b_jonas> sstipic: yes, and J (like APL) uses "monadic" and "diadic"
02:39:47 <b_jonas> while haskell doesn't use those names because it uses "monad" for something else
02:39:47 <skew> I think monadic and dyadic are just their words for unary and binary
02:40:01 <b_jonas> skew: except that j functions are curried in a different way
02:40:29 <b_jonas> that is, diadic verbs doesn't just mean it wants two arguments, but also a "calling convention" of how it wants them
02:40:33 <sstipic> i think that j doesn't do currying (at least not as haskell)
02:41:17 <sstipic> tnx for the explanation
02:42:41 <b_jonas> sstipic: it does in some way
02:42:50 <b_jonas> or, um
02:42:59 <sstipic> b_jonas: can you give me one example, please
02:43:14 <b_jonas> only, it does it less than haskell (even less than sml)
02:44:14 <b_jonas> for example, array amend is really a 3-argument operation, but as there's no such language feature as a 3-argument function, it's implemented as an adverb } returning a diadic verb
03:08:50 <shag> hm. converting an IntMap of IntSet to ByteString and compressing it through BZip makes it larger ... *sigh*
03:09:18 <srid> what do you recommend one to read after having read YAHT?
03:10:35 <skew> does anyone know a nice way to get a gtk text box to vertically align stuff with a proportional font?
03:12:07 <skew> srid: random papers?
03:15:04 <doserj> srid: don't read, write!
03:15:18 <srid> perhaps.
03:15:48 <bos> @seen dcoutts
03:15:48 <lambdabot> Last time I saw dcoutts was when I left #darcs, #ghc and #haskell 17d 5h 29m 24s ago, and .
03:29:50 <mattam> @instances Functor
03:29:52 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
03:30:08 <mattam> @instance Functor ((,) a)
03:30:08 <lambdabot> Maybe you meant: instances instances-importing
03:30:17 <mattam> @src Functor ((,) a)
03:30:17 <lambdabot> Source not found. :(
03:30:32 <quicksilver> fmap f (a,b) = (a, f b)
03:30:43 <mattam> Yeah I know :)
03:30:49 <quicksilver> can't be anything else :)
03:31:01 <mattam> I wondered if lambdabot could show instances
03:31:08 <quicksilver> @djinn (b -> c) -> (a,b) -> (a,c)
03:31:08 <lambdabot> f a (b, c) = (b, a c)
03:31:17 <mattam> of course
03:31:19 <quicksilver> it can show methods, sometimes
03:31:33 <quicksilver> @src IO fmap
03:31:33 <lambdabot> fmap f x = x >>= (return . f)
03:31:33 <mattam> How ?
03:31:49 <mattam> @src ((,) a) fmap
03:31:49 <lambdabot> Source not found. :(
03:31:51 <b_jonas> @src Monad []
03:31:52 <lambdabot> Source not found. Wrong!  You cheating scum!
03:31:59 <b_jonas> @src [] Monad
03:31:59 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
03:32:01 <faxathisia> It would be cool if djinn could do recursive data structures :)
03:32:07 <mattam> ((,) a) is too complicated...
03:32:39 <faxathisia> ?djinn [a] -> (a -> b) -> [b]
03:32:39 <lambdabot> -- f cannot be realized.
03:33:21 <quicksilver> faxathisia: there's nothing stopping djinn doing recursive structures, per se. It just needs proof rules for them.
03:33:37 <mattam> @src askP
03:33:37 <lambdabot> Source not found. Are you on drugs?
03:35:50 <faxathisia> oh I got a question
03:36:29 <faxathisia> If I was gonna parse some language (using Parsec) right, I would define a datatype for Tokens.. So parsing would be two stages
03:36:37 <faxathisia> Is that bad? Someone said it's 70s styke
03:36:44 <b_jonas> quicksilver: really? I thought it's not doing them because it wouldn't be able to terminate
03:37:15 <faxathisia> b_jonas: Can you give an example which wouldn't terminate?
03:37:27 <b_jonas> faxathisia: no, because I've no idea at all how djinn works
03:37:32 <quicksilver> faxathisia: I often parse in two stages
03:37:33 <faxathisia> uh ok..
03:37:39 <faxathisia> quicksilver: cool :D
03:37:41 <quicksilver> faxathisia: traditionally the first is called lexing
03:37:42 <b_jonas> I just thought it's like that, because they say it's a proof engine
03:37:43 <faxathisia> so it's not bad?
03:37:50 <quicksilver> I don't think it's bad
03:38:05 <faxathisia> The only thing I didn' like is
03:38:09 <faxathisia> | If'   { tokenPosition :: SourcePos } | Then' { tokenPosition :: SourcePos }
03:38:13 <quicksilver> as far as I know, all haskell implementations are two-phase
03:38:18 <faxathisia> all these tokenPosition.. but other than that it's ok
03:38:34 <faxathisia> yeah, I thought so cause of that function..
03:38:46 <faxathisia> :t lex
03:38:47 <lambdabot> String -> [(String, String)]
03:44:06 <bos> @where+ llvm http://darcs.serpentine.com/llvm
03:44:06 <lambdabot> Done.
03:44:06 <faxathisia> also
03:44:23 <faxathisia> Does anyone know a mixfix parser for a haskell-like language other htan Agda2?
03:45:43 <CivilService_> aren't people supposed to use parsec or happy?
03:45:47 <byorgey> @pl \x h l -> x : (h l)
03:45:47 <lambdabot> (.) . (:)
03:48:59 <quicksilver> CivilService_: not if they don't want to :)
03:50:46 <quicksilver> I've always found a hand-coded lexer more convenient and flexible than somethiing like alex
03:51:00 <skew> faxathisia: What are you trying to parse? bnfc is really nice if your grammar is not too strange
03:51:30 <faxathisia> skew: I already wrote my parser and someone said bad, it's 70s style :p
03:51:40 <faxathisia> but I think it's fine
03:52:08 <skew> what are you parsing?
03:56:20 <faxathisia> I was parsing Janus..
03:56:27 <faxathisia> It's really simple a bit like While
03:57:58 <skew> you could almost copy their bnf into Janus.cf for bnfc
04:12:26 <JohnMeacham> Is it ironic I had to look up and read a tutorial on the haskell regular expression syntax I invented?
04:12:34 <ivanm> heh
04:12:50 <ivanm> even worse if you're the one who wrote the tutorial... :p
04:13:11 <JohnMeacham> I should put a note on the JRegEx page pointing out it has been integrated into the standard libraries...
04:13:13 <koala_man> did you get lots of liquid presents for christmas?
04:20:27 <quicksilver> @remember JohnMeacham  Is it ironic I had to look up and read a tutorial on the haskell regular expression syntax I invented?
04:20:27 <lambdabot> I will never forget.
04:20:54 <ivanm> unless you crash again, lambdabot :p
04:22:02 <FunctorSalad> can't a bot have some fun once in a while :(
04:22:17 <quicksilver> @botsmack
04:22:18 <lambdabot> :)
04:22:22 <quicksilver> there's her fun
04:22:25 <quicksilver> now she has to pay attention
04:23:07 <JohnMeacham> hey, this must have been written a hundred times, but I want something that takes a text file and turns it into a haskell file that exports the file contents as a string, perhaps with some variables substituted. a template thingy.
04:23:42 <JohnMeacham> so foo $bar baz turns into f bar = "foo " ++ bar ++ " baz"
04:23:55 <ivanm> quicksilver: so, lambdabot is a masochist?
04:24:27 <FunctorSalad> @smack quicksilver
04:24:27 <lambdabot> Unknown command, try @list
04:24:40 <ivanm> I think you want @slap
04:24:48 <FunctorSalad> huh, locally that works
04:25:42 <visof> hello
04:26:31 <visof> how can i put lambdabot in my own channel?
04:26:42 <shachaf> visof: Compile your own? :-)
04:27:22 <ivanm> or if you ask dons very nicely, he might let you borrow his
04:27:22 <visof>  i don't understand
04:27:26 <quicksilver> visof: you can ask the LB owners to put her in your channel, but she has a limit
04:27:29 <ivanm> @where lambdabot
04:27:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
04:27:33 <byorgey> visof: you can also say /msg lambdabot foo  if you just want to talk to LB privately.
04:27:38 <quicksilver> or you can compile your own lambdabot and put her in all the channels you want
04:27:39 <ivanm> ^^ source code
04:27:59 <shachaf> @version
04:27:59 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
04:27:59 <lambdabot> darcs get http://code.haskell.org/lambdabot
04:28:18 <ivanm> does lambdabot compile on 6.8 yet?
04:28:34 <shachaf> ivanm: Yes, but not trivially.
04:28:39 <ivanm> *nod*
04:28:46 <shachaf> ivanm: I understand you have to change a few files yourself.
04:28:47 <ivanm> so, even less trivially then with 6.6? :p
04:28:48 <byorgey> JohnMeacham: that should be possible with Template Haskell, I'd think.
04:28:55 <shachaf> ivanm: Ask Cale and/or mux, I think.
04:29:09 <shachaf> (And a recent 6.9 is even more trouble.)
04:29:13 <ivanm> heh
04:29:17 <quicksilver> JohnMeacham: I don't think that has been done
04:29:31 <ivanm> I used to have a local lambdabot running, but it stopped working properly a while back... and GOA didn't work too well either :s
04:29:33 <quicksilver> JohnMeacham: I'd have thunk you'd probably generate a function which takes a (Map String String) personally
04:30:07 * shachaf wishes http://lambdabot.codersbase.com/ worked.
04:30:13 <lambdabot> Title: Lambdabot Web Interface
04:30:14 <visof> i use ghc-6.8.1  can i compile it by this?
04:30:34 <ivanm> visof: if you noticed what I asked and shachaf replied above, not easily
04:30:42 <shachaf> @seen Cale
04:30:42 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I don't know when Cale last spoke.
04:32:41 <visof> what should i do?
04:33:01 <ivanm> @seen dons
04:33:01 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 4h 56m 55s ago.
04:33:01 <shachaf> visof: Try it and see? :-)
04:33:24 <shachaf> @version -- lambdabot is still using 6.6.
04:33:24 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
04:33:24 <lambdabot> darcs get http://code.haskell.org/lambdabot
04:33:35 <benny99> @seen shachaf
04:33:35 <lambdabot> shachaf is in #jtiger, #scala, #perl6, #haskell-blah, #xmonad and #haskell. I last heard shachaf speak 11s ago.
04:34:27 <visof> i installed ghc 6.8 and ghc 6.6 how can i use ghc 6.6 to compile it?
04:35:04 <shachaf> visof: Use the 6.6 binary?
04:37:31 <visof> shachaf what is the command?
04:37:56 <shachaf> visof: I have no idea.
04:38:11 <visof> ok
04:38:14 <visof> thanks
04:38:15 <shachaf> visof: It calls `ghc` directly, so you might need to ln -s `which ghc-6.6.1` ~/bin.
04:38:39 <shachaf> visof: (~/bin/ghc, I mean. Something like that.)
04:38:48 <visof> ok
04:38:55 <visof> i'll try
04:40:51 <quicksilver> well, or arrange for the thing which is calling ghc to have that first in its path
04:41:09 <shachaf> quicksilver: To have what first?
04:41:19 <quicksilver> the right version of ghc
04:41:42 <shachaf> quicksilver: That's still /usr/bin or /usr/local/bin, no?
04:42:37 <quicksilver> dunno
04:42:43 <quicksilver> depends how you installed it
04:42:58 <quicksilver> I could imagine ou might end up with /usr/lib/ghc-6.6.1/bin/ghc
04:43:03 <quicksilver> but I'm not sure :)
04:52:23 <visof> i have the following dependencies are missing:
04:52:43 <visof> plugins >=1.0  , fps >=0.7
04:52:49 <visof> what is that?
04:55:59 <skew> visof: plugins you can get from hackage
05:09:13 <faxathisia> what ways do you generally express invariants on an AST?
05:10:01 <swiert> what kind of invariants do you want?
05:11:01 <earthy> those that change over time? :P
05:11:32 <swiert> well, the point is GADTs can get you part of the way...
05:11:58 <swiert> but they may lead you down a path of type-level programming in Haskell.
05:12:43 <quicksilver> faxathisia: I suppose the general approach is (1) make some of them directly encoded by the structure (2) make the rest enforced by smart constructors
05:12:54 <quicksilver> (3) prove that any manipulation functions preserve them
05:14:11 <faxathisia> cool
05:14:18 <faxathisia> I'm gonna try both ways on a simple example then
05:14:29 <faxathisia> since I will probably break my actual code if I just go for it
05:15:50 <FunctorSalad> invariants = relations in this context?
05:16:16 <faxathisia> I guess I used the wrong word actually
05:16:25 <quicksilver> FunctorSalad: an invariant of an AST is a property which it must satisfy
05:16:29 <faxathisia> I don't really want an invarient, but some propery which is true after a program transformation
05:16:35 <quicksilver> like all variables being bound
05:16:52 <faxathisia> invariant*
05:16:55 <shag> does someone know if and when hs-plugins will be avaliable for ghc 6.8?
05:17:01 <FunctorSalad> hmm, thought you were talking about GADTs in general
05:17:36 <oerjan> shag: it has been ported but last i heard they wanted to make it work on windows before release
05:18:00 <shag> oerjan: ok, sounds good. thanks
05:18:50 <oerjan> shag: yesterday we had a 6.8 lambdabot in here
05:18:54 <oerjan> @version
05:18:54 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
05:18:54 <lambdabot> darcs get http://code.haskell.org/lambdabot
05:18:59 <FunctorSalad> faxathisia: I suppose it depends on how you want to transform the AST
05:19:07 <oerjan> but the original still hasn't been converted
05:20:41 <shachaf> mbot is 6.8.
05:20:49 <oerjan> @where hs-plugins
05:20:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
05:24:52 <thoughtpolice> shag: http://code.haskell.org/~dons/code/hs-plugins should build on 6.8.2 just fine
05:24:52 <lambdabot> Title: Index of /~dons/code/hs-plugins
05:27:16 <shag> thoughtpolice: hm. ok, i'll give it a try.
05:31:16 <roconnor> @seen swiert
05:31:16 <lambdabot> swiert is in #haskell. I last heard swiert speak 19m 18s ago.
05:31:29 <swiert> hi roconnor
05:31:43 <roconnor> swiert: in epigram2, if P:Prop, and p q:P, then are p and q convertable?
05:31:54 <roconnor> ... not that you are likely to know the answer.
05:32:13 <swiert> roconnor: hmm, I let me look something up.
05:35:20 <swiert> roconnor: nope. don't know.
05:35:25 <roconnor> Hmm
05:35:37 <roconnor> I'd guess yes, but I'm not sure.
05:36:09 <roconnor> swiert: but you agree that p and q are equal?
05:36:35 <swiert> roconnor: yes - that's proof irrelevance right?
05:36:40 <roconnor> right
05:36:44 <swiert> equal props have equal proofs.
05:37:02 <roconnor> except I'm not realizing that there is a stronger notion of PI that means that the objects are convertable.
05:37:04 <roconnor> er
05:37:09 <roconnor> I'm now realizing ...
05:37:49 <roconnor> swiert: have you epigram2 people ever discussed well-founded induction?
05:38:42 <swiert> roconnor: I'm pretty sure Conor and Thorsten will have, possibly even in my presence, but I haven' a clue really.
05:38:47 <roconnor> I had assumed that epigram2 will have everything I want, but now rumour has it that it won't support well-founded induction.
05:39:19 <roconnor> swiert: okay.
05:39:47 <roconnor> conor needs to spend more time on IRC to answer all my questions :)
05:40:17 <swiert> hehe.
05:41:12 <roconnor> swiert: I'm conjecturing that strong-normalization, proof-irrelevence, and well-founded induction cannot coexist.
05:41:28 <roconnor> if true it means I cannot have everything I want. :(
05:41:47 <faxathisia> can I just ask well-founded induction on N is like, instead of P(0) and P(n+1) assuming P(n)... P(0) and P(n+1) assuming P(x) for any x < n?
05:41:56 <faxathisia> <=* sorry
05:43:00 <roconnor> faxathisia: mathematically speaking well founded induction is induction over any relationship that is well-founded
05:43:30 <roconnor> a releationship over A is well-founced if every element of A is accessable.
05:43:50 <swiert> roconnor: how does proof-irrelevance cause problems?
05:43:54 <roconnor> an element a is accessable if all of it's predecessors (under the releation) are accessable.
05:44:09 <faxathisia> ah I get it
05:44:31 <roconnor> faxathisia: but now I realize when I was saying well-founded induction and meant well-founded recursion.
05:44:42 <roconnor> (of course induction and recursion are kinda the same thing).
05:45:16 <roconnor> swiert: if you are doing recursion over a well founded relation in an inconsistent context...
05:45:31 <roconnor> swiert: then all guards on the recursion are equal.
05:45:44 <roconnor> swiert: if furthermore all guards on the recursion are convertable
05:46:00 <roconnor> swiert: then one can keep reducing the fixpoint indefinitely
05:46:08 <roconnor> swiert: leaning to no normal form.
05:48:43 <swiert> roconnor: I think I can see what you're worried about.
05:49:26 <roconnor> OTOH well-founded recursion is nice
05:49:48 <roconnor> because the structure that you are recursing on can be removed during program extraction.
05:51:51 <swiert> roconnor: sure.
05:52:59 <swiert> roconnor: but this is only a problem in an inconsistent context right?
05:53:07 <roconnor> right
05:53:24 <roconnor> but that is important when type-checking, I think.
05:57:03 <swiert> roconnor: right.
05:58:16 <roconnor> It's sad to that we have to worry about type checking in the inconsitent context.
05:58:34 <roconnor> I wish we could say, to hell with it, we are never going to be in this context anways.
05:58:51 <roconnor> but it is undecidable if a context is consistent or not.
05:59:54 <swiert> but if all the interesting questions were decidable, they wouldn't be interesting :)
06:00:04 <roconnor> :)
06:05:15 <faxathisia> @hoogle reverse . tail . reverse
06:05:15 <lambdabot> Hoogle Error: Parse Error: Unexpected character '. tail . r'
06:05:32 <roconnor> last
06:05:34 <roconnor> er
06:05:41 <roconnor> what's the thing that isn't last
06:05:43 <faxathisia> @@ @hoogle :t reverse . tail . reverse
06:05:43 <lambdabot>  Hoogle Error: Parse Error: Unexpected character ':t reverse'
06:05:47 <faxathisia> :S
06:06:06 <faxathisia> @@ @hoogle @type reverse . tail . reverse
06:06:08 <lambdabot>  Did you mean: Forall A. [a] -> [a]
06:06:08 <lambdabot> Prelude.repeat :: a -> [a]
06:06:08 <lambdabot> Data.List.repeat :: a -> [a]
06:06:20 <faxathisia> I guesss that butLast doesn't exist?
06:06:21 <doserj> > init [1..10]
06:06:22 <lambdabot>  [1,2,3,4,5,6,7,8,9]
06:06:25 <roconnor> init!
06:06:26 <faxathisia> ahah.. okthanks
06:06:52 <roconnor> > tail []
06:06:52 <lambdabot>  Exception: Prelude.tail: empty list
06:06:56 <roconnor> > init []
06:06:56 <lambdabot>  Exception: Prelude.init: empty list
06:07:06 <faxathisia> :t tail
06:07:07 <lambdabot> forall a. [a] -> [a]
06:11:14 <fons> Hi all
06:11:23 <faxathisia> Hello
06:11:48 <hpaste>  faxathisia pasted "Exp simplify" at http://hpaste.org/4773
06:11:59 <hpaste>  faxathisia annotated "Exp simplify" with "one way" at http://hpaste.org/4773#a1
06:12:27 <faxathisia> So I made an example of simplifying an expression
06:12:40 <faxathisia> but how could you do this sort of thing with GADTs?
06:15:04 <FunctorSalad> faxathisia: "Num" is confusing :)
06:15:27 <faxathisia> should have called it Int I guess :P
06:15:38 <FunctorSalad> (to a newbie like me that isn't used to classes and value constructors having different namespaces yet)
06:18:19 <gbacon> > let l = [1,2,3] in [(a,b) | a <- ps l, b <- l \\ a]
06:18:19 <lambdabot>   Not in scope: `ps'
06:18:47 <swiert> faxathisia: the usual trick is to talk about expressions with n free variables.
06:19:13 <roconnor> faxathisia: your ExpS doesn't disallow (NumS 2) `PlusS` (NumS 2).
06:19:22 <gbacon> > let ps = filterM $ const [True,False]; l = [1,2,3] in [(a,b) | a <- ps l, b <- l \\ a]
06:19:22 <lambdabot>  [([1,2],3),([1,3],2),([1],2),([1],3),([2,3],1),([2],1),([2],3),([3],1),([3],...
06:19:25 <faxathisia> (NumS 2) `PlusS` (NumS 2) is ok
06:19:34 <gbacon> why isn't that a list of pairs of lists?
06:19:42 <gbacon> :t (\\)
06:19:43 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
06:19:54 <faxathisia> gbacon b is one of the lists l \\ a
06:20:01 <roconnor> faxathisia: ah sorry, the ``or numbers'' in your comment was off the edge of my screen :)
06:20:15 <faxathisia> swiert: What do the free variables represent?
06:20:29 <swiert> faxathisia: the "Set" operations.
06:20:48 <oerjan> gbacon: you want let b = , not b <-
06:20:58 <gbacon> ohhhhhhhhhhhh
06:21:59 <oerjan> hm...
06:22:52 <gbacon> > let ps = filterM $ const [True,False]; l = [1,2,3] in [(a,b) | a <- ps l, let b = l \\ a]
06:22:52 <lambdabot>  [([1,2,3],[]),([1,2],[3]),([1,3],[2]),([1],[2,3]),([2,3],[1]),([2],[1,3]),([...
06:23:14 <faxathisia> > let ps = filterM $ const [True,False]; l = [1,2,3] in [(a,l \\ a) | a <- ps l]
06:23:15 <lambdabot>  [([1,2,3],[]),([1,2],[3]),([1,3],[2]),([1],[2,3]),([2,3],[1]),([2],[1,3]),([...
06:26:29 <oerjan> > foldr (ap [first,second] . return . (:)) [([],[])] [1,2,3]
06:26:29 <lambdabot>  Couldn't match expected type `b -> b'
06:27:06 <oerjan> > foldr (ap . ap [first,second] . return . (:)) [([],[])] [1,2,3]
06:27:07 <lambdabot>  [([1,2,3],[]),([1,2],[3]),([1,3],[2]),([1],[2,3]),([2,3],[1]),([2],[1,3]),([...
06:27:13 <myname> @pl \x y -> x y
06:27:13 <lambdabot> id
06:27:26 <gbacon> @oerjansnack
06:27:27 <lambdabot> Unknown command, try @list
06:27:32 <oerjan> :D
06:27:44 <rindolf> Hi all.
06:27:48 <myname> @pl \x -> x
06:27:48 <lambdabot> id
06:27:51 <faxathisia> Hi rindolf
06:28:10 <rindolf> What does boxing/unboxing (for Integers, etc.) mean in Haskell? I'm trying to understand http://lambda-the-ultimate.org/node/2589
06:28:10 <lambdabot> Title: The worker/wrapper transformation | Lambda the Ultimate
06:28:16 <rindolf> Hi faxathisia
06:28:33 <gbacon> oerjan: so what's the best way to prevent it from yielding each partition twice?
06:28:54 <myname> @pl \a b -> (a b, a b)
06:28:54 <lambdabot> ap =<< ((,) .)
06:29:13 <hpaste>  faxathisia annotated "Exp simplify" with "GADT sytle" at http://hpaste.org/4773#a2
06:29:22 <myname> @type ap
06:29:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:29:33 <faxathisia> swiert, Something like this?   http://hpaste.org/4773#a2
06:29:54 <faxathisia> (oops I wrote Exp2 Simple once, that should be Exp Simple)
06:30:50 <swiert> faxathisia: are you only interested in making sure that Plus works on vars and nums?
06:30:53 <swiert> (just checking)
06:30:59 <oerjan> gbacon: huh? when does it do that?
06:31:13 <faxathisia> Yes
06:31:33 <faxathisia> I'm wondering about ways I have simple properties like that typecheked
06:31:34 <gbacon> oerjan: it yields both ([],[1,2,3]) and ([1,2,3],[]), for example
06:32:05 <swiert> faxathisia: that looks ok then...
06:32:14 <FunctorSalad> faxathisia: do you want to do the simplification such that the type system gets it?
06:32:25 <oerjan> gbacon: oh.
06:32:28 <faxathisia> FunctorSalad not sure what you mean
06:32:34 <swiert> but you can write funny things like Plus (Set "x" ...) (Set "y" ...)
06:32:47 <oerjan> gbacon: just pick an element to be in a fixed place
06:33:14 <FunctorSalad> faxathisia: such that your simplification function returns an ExpS
06:33:16 <faxathisia> well there is one problem
06:33:41 <faxathisia> FunctorSalad: I really want to have Exp -> [Exp] but a proof somewhere that the returned value obeys some property
06:34:00 <faxathisia> so going Exp -> [ExpS] -> [Exp] I think works
06:34:07 <oerjan> say the first element always goes in the first list
06:34:12 <FunctorSalad> I think I would do it like swiert said, but swiert, shouldn't we just let the type know the depth of the term rather than num of free vars?
06:34:38 <faxathisia> If I used that type of GADT style, though.. Is there anyway I could have Exp Unrestricted and Exp Restricted?
06:34:50 <faxathisia> (then one function .e.g eval could work on both)
06:34:51 <FunctorSalad> since as far as I can see, fax essentially wants to reduce terms to depth 1
06:34:56 <swiert> ignore my remark about free vars - I thought you were interested in well-scoped expressions.
06:35:33 <faxathisia> swiert: Ah.. I understand what you meant about free vars now though :)
06:36:02 <FunctorSalad> what's well-scoped? :)
06:37:36 <swiert> FunctorSalad: I was being a bit imprecise: I meant that expressions should only refer to defined variables.
06:38:31 <FunctorSalad> IOW, no free variable?
06:38:34 <FunctorSalad> *variables
06:39:21 <faxathisia> I suppose that it's impossible to emulate any kind of subtyping with GADTs?
06:39:49 <swiert> FunctorSalad: basically, yes.
06:40:13 <gbacon> > let ps = filterM $ const [True,False]; l = [1,2,3] in [(a,b) | a <- ps l, (not . null) a, head a == head l, let b = l \\ a]
06:40:14 <lambdabot>  [([1,2,3],[]),([1,2],[3]),([1,3],[2]),([1],[2,3])]
06:41:34 <faxathisia> how do you define a type level id?
06:41:37 <myname> unpl (ap =<< ((,) .))
06:41:40 <FunctorSalad> I suppose subtyping should have something to do with these funny "subobject classifiers" we did in CT
06:41:42 <myname> @unpl (ap =<< ((,) .))
06:41:43 <lambdabot> ((\ a m -> ((,)) (a m)) >>= \ e f -> e >>= \ c -> f >>= \ b -> return (c b))
06:42:48 <FunctorSalad> (they let you turn a characteristic function (= predicate) into an subobjet)
06:42:59 <FunctorSalad> *object
06:44:55 <FunctorSalad> maybe that could be done at the typelevel but I better shut up before I make a fool of myself
06:51:16 <gbacon> > let ps = filterM $ const [True,False]; l = [1,2,3] in [(a,b) | a <- ps l, (not . null) a && head a == head l, let b = l \\ a]
06:51:16 <lambdabot>  [([1,2,3],[]),([1,2],[3]),([1,3],[2]),([1],[2,3])]
06:52:15 <hpaste>  faxathisia annotated "Exp simplify" with "guessing here.." at http://hpaste.org/4773#a3
06:52:43 <faxathisia> Does this sound reasonable, If I wanted to have a type (like Exp) with some constraint which you can switch on or off...
06:52:55 <faxathisia> Then I might be able to construct some type 'b' which let's me do that?
06:53:00 <faxathisia> Or is this impossible?
06:54:26 <Saizan> why do you want to turn it off?
06:54:43 <rindolf> What does boxing/unboxing (for Integers, etc.) mean in Haskell? I'm trying to understand http://lambda-the-ultimate.org/node/2589
06:54:44 <lambdabot> Title: The worker/wrapper transformation | Lambda the Ultimate
06:55:29 <Saizan> unboxed values are raw machine values without the machinery to make laziness work
06:55:56 <rindolf> Saizan: hmmm...
06:56:44 <rindolf> Saizan: what is the implication of this?
06:58:24 <Saizan> rindolf: you get better performance in tight loops
06:59:08 <Saizan> rindolf: it's an optimization some compilers do when they can deduce that the laziness isn't used
07:00:09 <myname> @pl \(a, b) -> (b, a)
07:00:10 <lambdabot> uncurry (flip (,))
07:00:37 <FalconNL> Can anyone tell me if you can use something similar to pattern binding in expressions or do I have to use let in or where? For example: test = a@2 + b where b = a + 1, which would return 5
07:01:39 <faxathisia> FalconNL: You could just write test = 2 + b where b = 2 + 1
07:02:04 <FalconNL> Yeah, I know, the example might be too simple to illustrate the point
07:02:22 <faxathisia> FalconNL: If it's more complex I would use let or where then yeah
07:03:11 <FalconNL> The situation where I needed this was the following memoized function: routes gridx gridy = memolist where memolist = [routes' x y | x <- [0..gridx]] | y <- [0..gridy]]   routes
07:03:21 <FalconNL> ' = etc
07:03:33 <faxathisia> Saizan: It would be good to be able to have something like simplify :: Exp Unconstrainted -> Exp Constrainted, as well as eval :: Exp _ -> Int
07:03:52 <FalconNL> It would be more elegant to not have to repeat the memolist word twice
07:04:08 <faxathisia> so I could know that simplify does simplify just frmo the type, and I don't have to write eval twice
07:04:35 <faxathisia> FalconNL: Can you paste the entire code?
07:04:45 <faxathisia> I just want to see how it looks
07:04:48 <Saizan> faxathisia: you can write eval :: Exp a -> Int, just as it wasn't a gadt
07:04:53 <FalconNL> routes gridx gridy = memolist
07:04:57 <FalconNL> where memolist = [[routes' x y | x <- [0..gridx]] | y <- [0..gridy]]
07:05:01 <FalconNL> routes' x 0 = 1
07:05:05 <FalconNL> routes' 0 y = 1
07:05:11 <FalconNL> routes' x y = ((memolist !! (y-1)) !! x) + ((memolist !! y) !! (x-1))
07:05:39 <FalconNL> it's a naive solution to project euler 15, but i like it better than the combinatory solution
07:06:01 <rindolf> Hmmm... http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html
07:06:02 <lambdabot> Title: 8.2. Unboxed types and primitive operations, http://tinyurl.com/y59rbr
07:10:52 <JohnMeacham> so, what is the quickest path from a 6.8.1 ghc install to an SQL database?
07:11:14 <JohnMeacham> on a fedora core system. is there a yum repo that has pre-compiled ghc libraries?
07:15:16 <myname> @pl (\f -> map ((:f) . snd) (filter ((== (head f)) . fst) linktable))
07:15:16 <lambdabot> ap (map . (. snd) . flip (:)) (flip filter linktable . (. fst) . (==) . head)
07:15:47 <visof> did anyone read haskell road to logic , math and programming book??
07:17:53 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4775
07:18:16 <hpaste>  rindolf pasted "I# and unboxed variables problem" at http://hpaste.org/4776
07:19:49 <rindolf> Can anyone help with http://hpaste.org/4776 ?
07:21:03 <roconnor> rindolf: have you imported the right modules?
07:21:38 <rindolf> roconnor: which ones?
07:21:41 <quicksilver> rindolf: it's an internal GHC constructor for unboxed ints
07:21:50 <roconnor> GHC.internalsomething
07:21:56 <quicksilver> rindolf: it's not very helpful to ask 'why does this not compile' without posting the complete error
07:21:57 <rindolf> roconnor: oh.
07:22:19 <rindolf> roconnor: it doesn't appear in the code excerpt from the paper.
07:22:41 <roconnor> rindolf: you could try GHC.Exts
07:22:54 <roconnor> I'm not sure what you need to import.
07:23:05 <hpaste>  (anonymous) annotated "I# and unboxed variables problem" with "(no title)" at http://hpaste.org/4776#a1
07:23:25 <rindolf> roconnor: ok.
07:23:57 <quicksilver> parse error on input "->" is probably because you don't have MagicHash on
07:24:02 <quicksilver> or whatever the option is called
07:24:18 <rindolf> roconnor: after I do "import GHC.Exts" I'm still getting the same error.
07:24:21 <quicksilver> although some of your indenttion looks doubtful
07:24:24 <quicksilver> and it could be that
07:24:39 <oerjan> gbacon: your head a == head l check is a bit expensive, since it comes after the work of selecting a has already been performed.  i think it is better to handle the first element separately:
07:26:20 <oerjan> > let ps = filterM $ const [True,False]; parts (x:l) = [(x:a,b) | a <- ps l, let b = l \\ a] in parts [1,2,3]
07:26:21 <lambdabot>  [([1,2,3],[]),([1,2],[3]),([1,3],[2]),([1],[2,3])]
07:27:24 <gbacon> snazzy
07:27:31 <roconnor> rindolf: you also need -fglasgow-exts
07:27:36 <roconnor> on the command line or in a pragma
07:27:44 <rindolf> roconnor: OK.
07:28:03 <oerjan> > let parts (x:xs) = first (x:) . foldr (ap [first,second] . return . (:)) [([],[])] [1,2,3] xs in parts [1,2,3]
07:28:04 <lambdabot>  Couldn't match expected type `b -> b'
07:28:21 <oerjan> > let parts (x:xs) = first (x:) . foldr (ap . ap [first,second] . return . (:)) [([],[])] [1,2,3] xs in parts [1,2,3]
07:28:21 <lambdabot>  Couldn't match expected type `[t] -> a -> ([t], d)'
07:28:25 <rindolf> roconnor: thanks, now it works.
07:28:37 <oerjan> > let parts (x:xs) = first (x:) . foldr (ap . ap [first,second] . return . (:)) [([],[])] [1,2,3] $ xs in parts [1,2,3]
07:28:37 <lambdabot>  Couldn't match expected type `a -> ([t], d)'
07:28:45 <oerjan> what the?
07:28:49 <oerjan> oh
07:29:03 <oerjan> > let parts (x:xs) = first (x:) . foldr (ap . ap [first,second] . return . (:)) [([],[])] $ xs in parts [1,2,3]
07:29:03 <lambdabot>  Couldn't match expected type `([t], d)'
07:29:10 <hpaste>  faxathisia annotated "Exp simplify" with "hopefully better explanation" at http://hpaste.org/4773#a4
07:29:19 <faxathisia> Alright I think that explains what I meant better..
07:29:32 <oerjan> sheesh
07:29:32 <faxathisia> I still don't know how to write Exp though.. is it possible to do it in this way?
07:30:01 <oerjan> > let parts (x:xs) = map (first (x:)) . foldr (ap . ap [first,second] . return . (:)) [([],[])] $ xs in parts [1,2,3]
07:30:01 <lambdabot>  [([1,2,3],[]),([1,2],[3]),([1,3],[2]),([1],[2,3])]
07:31:53 <faxathisia> oh I think I got it actually
07:33:46 <faxathisia> alright
07:33:59 <hpaste>  faxathisia annotated "Exp simplify" with "working" at http://hpaste.org/4773#a5
07:34:27 <faxathisia> (that works.. forgot to remove the misleading comment)
07:34:30 <CosmicRay> Does anybody know if Hugs ought to be supplying HsBase.h?
07:35:11 <CosmicRay> I am working on Debian bug #458644 and can't figure out what has changed recently that it doesn't build for hugs anymore because it can't find HsBase.h
07:35:41 <gbacon> oerjan: http://programming.reddit.com/info/64dn2/comments/c02svbm
07:36:54 <gbacon> @bot
07:36:54 <lambdabot> :)
07:37:03 <sieni> @bothug
07:37:03 <lambdabot> Unknown command, try @list
07:37:06 <sieni> :-('
07:38:25 <myname> @pl \a b -> f a [[b]]
07:38:25 <lambdabot> (. (return . return)) . f
07:40:09 <fadec> How can I build haddock docs for ghc 6.8? I downloaded the source but haddock throws parse errors from the preprocessor statements.
07:40:51 <FunctorSalad> faxathisia, hang on, what I'm trying atm might work ;)
07:42:00 <gbacon> @pl \l -> [(a,b) | (a,b) <- partitions l, sum a == sum b]
07:42:00 <lambdabot> (: [sum a == sum b]) . (((a, b) | (a, b)) <-) . partitions
07:42:30 <gbacon> funny, a (: operator!
07:43:18 <shachaf> gbacon: I prefer (:[]).
07:43:51 <shachaf> @quote eat.a
07:43:51 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
07:46:03 <Igloo> fadec: Do you mean for ghc's code? That's never been done AFAIK
07:48:02 <roconnor> gbacon: I'm sure we can easily merge partion and powerset
07:49:08 <roconnor> >  ap [Left, Right] [1,2,3]
07:49:09 <lambdabot>  [Left 1,Left 2,Left 3,Right 1,Right 2,Right 3]
07:49:14 <roconnor> hmm
07:51:28 <roconnor> @type partition
07:51:29 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
07:51:41 <roconnor> I guess we need paritionM
07:51:45 <roconnor> @src filterM
07:51:45 <lambdabot> Source not found. Do you think like you type?
07:52:27 <gbacon> @ty filterM
07:52:27 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
07:53:35 <myname> @pl \x -> x == (a, b) || x == (b, a)
07:53:35 <lambdabot> liftM2 (||) ((a, b) ==) ((b, a) ==)
07:53:43 <gbacon> > filterM $ const [True,False] $ [1..3]
07:53:43 <lambdabot>  Couldn't match expected type `a -> m Bool'
07:53:58 <gbacon> > (filterM $ const [True,False]) [1..3]
07:53:58 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
07:54:25 <gbacon> we need an arrow!
07:54:29 <myname> @pl \x -> x == (5, 7) || x == (7, 5)
07:54:29 <lambdabot> liftM2 (||) ((5, 7) ==) ((7, 5) ==)
07:55:27 <myname> @pl \(a, b) -> a == a && b == b || b == a && a == b
07:55:27 <lambdabot> uncurry (ap (ap . ((||) .) . (. join (==)) . (&&) . join (==)) (ap (ap . ((&&) .) . (==)) (==)))
07:55:32 <roconnor> let paritionM p = foldM (\(x0,x1) y -> if (p y) then (y:x0,x1) else (x0,y:x1)) ([],[]) in  (paritionM $ const [True,False]) [1..3]
07:55:34 <roconnor> > let paritionM p = foldM (\(x0,x1) y -> if (p y) then (y:x0,x1) else (x0,y:x1)) ([],[]) in  (paritionM $ const [True,False]) [1..3]
07:55:35 <lambdabot>      Occurs check: cannot construct the infinite type: t = ([b], t)
07:55:35 <lambdabot>       Exp...
07:56:13 <roconnor> > let paritionM p = foldM (\(x0,x1) y -> do {b <- (p y); return (if b then (y:x0,x1) else (x0,y:x1))) ([],[]) in  (paritionM $ const [True,False]) [1..3]
07:56:13 <lambdabot>  Parse error at ")" (column 99)
07:56:21 <roconnor> > let paritionM p = foldM (\(x0,x1) y -> do {b <- (p y); return (if b then (y:x0,x1) else (x0,y:x1))}) ([],[]) in  (paritionM $ const [True,False]) [1..3]
07:56:22 <lambdabot>  [([3,2,1],[]),([2,1],[3]),([3,1],[2]),([1],[3,2]),([3,2],[1]),([2],[3,1]),([...
07:56:40 <roconnor> someone add partionM to Contorl.Monad
07:56:43 <fadec> Igloo: like this in the libraries dir ... haddock `find -name '*.hs'` -o doc -h  ... It's like I need a cleaned up version of the source without the preprocessor directives. I guess I'll use the online prebuilt docs.
07:57:14 <myname> @unpl ((f .) .)
07:57:15 <lambdabot> (\ b e i -> f (b e i))
07:57:43 <myname> @unpl (f . .)
07:57:44 <lambdabot>  Parse error at ".)" (column 6)
07:58:15 <roconnor> @type \p -> foldM (\(x0,x1) y -> do {b <- (p y); return (if b then (y:x0,x1) else (x0,y:x1))}) ([],[])
07:58:15 <lambdabot> forall b (m :: * -> *). (Monad m) => (b -> m Bool) -> [b] -> m ([b], [b])
07:59:34 <roconnor> http://paste.lisp.org/display/24633
07:59:42 <roconnor> @seen tibbie
07:59:42 <lambdabot> I haven't seen tibbie.
07:59:46 <roconnor> @seen tibbe
07:59:46 <lambdabot> I haven't seen tibbe.
08:00:03 <roconnor> http://hpaste.org/1747
08:00:13 <roconnor> @seen Cale
08:00:13 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I don't know when Cale last spoke.
08:00:35 <roconnor> http://hpaste.org/1746
08:01:05 <roconnor> http://www.cse.unsw.edu.au/~sseefried/darcs/icfp07/MonadUtil.hs
08:01:27 <gbacon> roconnor: snazzy
08:01:36 <roconnor> okay, there are about a million copies of paritionM floating around the internet
08:02:34 <roconnor> partitionM
08:03:30 <faxathisia> messing with GADTs is pretty fun
08:05:58 <byorgey> roconnor: perhaps it should be added to the next version of Control.Monad?
08:06:07 <byorgey> oh, you just said that above =)
08:06:54 <roconnor> http://hackage.haskell.org/trac/ghc/newticket?type=proposal&component=libraries/base&milestone=Not+GHC
08:06:56 <lambdabot> http://tinyurl.com/ytn4fl
08:07:10 <roconnor> we cannot make new library proposals :(
08:07:17 <roconnor> TICKET_CREATE privileges are required to perform this operation
08:07:42 <roconnor> although prehaps I should login
08:07:43 <roconnor> :P
08:07:48 <gbacon> The Haskell Establishment is holding us back!
08:07:49 <Saizan> heh
08:12:07 <roconnor> bah too much work
08:12:14 * roconnor drops the ball
08:14:05 <gbacon> roconnor: they're all doing too much work
08:15:09 <roconnor> too much work to login
08:15:20 <roconnor> I cannot create an roconnor accout
08:15:29 <roconnor> and I cannot retreive my password
08:15:33 <roconnor> so I give up
08:16:10 <gbacon> > let paritionM p = foldM (\(x0,x1) y -> do {b <- (p y); return (if b then (y:x0,x1) else (x0,y:x1))}) ([],[]) in  (paritionM $ const [True,False]) [1,2]
08:16:10 <lambdabot>  [([2,1],[]),([1],[2]),([2],[1]),([],[2,1])]
08:16:36 <visof> can someone put lambdabot in #curry ?
08:16:46 <gbacon> it repeats each result
08:17:18 <visof> thanks
08:18:04 <roconnor> gbacon: what do you mean?
08:18:54 <gbacon> e.g., ([1],[2]) and ([2],[1])
08:19:28 <roconnor> gbacon: doesn't your code on reddit do that too?
08:19:41 <gbacon> nope
08:20:27 <roconnor> > let { powerset = filterM $ const [True, False]; partitions (x:l) = [(x:a,b) | a <- powerset l, let b = l \\ a] } in partitions [1,2]
08:20:27 <lambdabot>  [([1,2],[]),([1],[2])]
08:20:39 <roconnor> > let { powerset = filterM $ const [True, False]; partitions (x:l) = [(x:a,b) | a <- powerset l, let b = l \\ a] } in partitions [2,2]
08:20:40 <lambdabot>  [([2,2],[]),([2],[2])]
08:21:11 <roconnor> gbacon: oh
08:21:34 <roconnor> gbacon: paritions is a bit more sophisticated than I thought.
08:22:21 <roconnor> > let { powerset = filterM $ const [True, False]; partitions (x:l) = [(x:a,b) | a <- powerset l, let b = l \\ a] } in partitions [2,2,2]
08:22:22 <lambdabot>  [([2,2,2],[]),([2,2],[2]),([2,2],[2]),([2],[2,2])]
08:22:42 <roconnor> :)
08:23:32 <gbacon> hm
08:27:20 <gbacon> > let { powerset = filterM $ const [True, False]; partitions (x:l) = [(x:a,b) | a <- powerset l, let b = l \\ a] } in partitions [1..3]
08:27:21 <lambdabot>  [([1,2,3],[]),([1,2],[3]),([1,3],[2]),([1],[2,3])]
08:31:26 <gbacon> when I use any of the partitionM implementations, ex has two pairs rather than one
08:32:26 <roconnor> right, that is what partitionM will do
08:32:42 <roconnor> so you are better off with your code.
08:33:18 <roconnor> partitionM (const [True,False]) will create a list of all partitions
08:33:27 <roconnor> even the symetrical ones
08:33:39 <roconnor> because maybe you want to do something different with the left than with the right.
08:33:45 <gbacon> right
08:33:56 <faxathisia> What's the type level equivalent of undefined?
08:34:11 <gbacon> whether to focus on the positions in the input or the positions in the output
08:34:23 <Saizan> faxathisia: data Void ?
08:34:27 <gbacon> @ty undefined
08:34:27 <lambdabot> forall a. a
08:35:28 <roconnor> paritionM is like filterM, but it shows you the rejected part too.
08:35:33 <gbacon> roconnor: but your earlier poin still stands
08:36:26 <gbacon> the code is still doing too much work: it creates partitions, throws part away, and then computes them again
08:41:28 <faxathisia> There's no way to do exists in haskell?
08:41:39 <faxathisia> like data Foo = exists x. Bar x x
08:42:12 <roconnor> faxathisia: you can with extensions
08:42:48 <faxathisia> how could you do it?
08:43:09 <roconnor>  data ShowBox = forall s. Show s => SB s
08:43:09 <roconnor>  
08:43:09 <roconnor>  heteroList :: [ShowBox]
08:43:09 <roconnor>  heteroList = [SB (), SB 5, SB True]
08:43:12 <dons> faxathisia: data E = forall t . P t => Existential t
08:43:16 <roconnor> http://en.wikibooks.org/wiki/Haskell/Fun_with_Types
08:43:47 <dons> the type class dictionary carries the only valid operations on type 't'
08:44:01 <dons> (besides polymorphic stuff)
08:50:14 <faxathisia> I can't work out how to apply that
08:51:10 <faxathisia> It's possible to define a type like, type ExpConstrained  = Exp TT FF ??, where then ?? is inferred? (It's going to be TT or FF, but I don't know which yet)
08:52:28 <Saizan> faxathisia: do you need to know which is it later?
08:52:40 <faxathisia> no
08:53:04 <hpaste>  gbacon pasted "partitionM1" at http://hpaste.org/4777
08:53:05 <Saizan> data ExpContrained = forall t. ExpC (Exp TT FF t)
08:54:11 <faxathisia> What is ExpC?
08:54:28 <Saizan> a new data constructor
08:54:45 <Saizan> (so the name is not important)
08:56:00 <faxathisia> I'm so confused...
08:58:46 <gbacon> roconnor: so I guess there's no escaping a final nubBy
08:59:15 <Saizan> 1you can think of a function :: Foo -> ExpConstrained as an equivalent CPS-style :: Foo -> (forall t. Exp TT FF t -> r) -> r, if rank-2 polymorphism is more clear :)
09:07:08 <jimstutt> dons: trying to build haskell supercollider but depends on fps-0.8 (found yr 3006 note re broken). Any suggestions? TIA
09:07:34 <jimstutt> dons: s/3006/2006/
09:12:53 <Saizan> jimstutt: i think the only solution for recent ghc is to port it to bytestring
09:15:16 <jimstutt> dons: ta, I'll find out who's owning hsc3 and try and get stuck in. I have people who want this. tnx
09:16:48 <byte-> hello.
09:17:33 <Saizan> hi!
09:18:07 <byte-> whoah, scared me there.
09:18:13 <byte-> wasn't expecting so much enthusiasm.
09:18:31 <byte-> is this channel usually this empty?
09:18:57 <sieni> @users
09:18:57 <lambdabot> Maximum users seen in #haskell: 403, currently: 403 (100.0%), active: 13 (3.2%)
09:18:57 <byte-> or is it just that everybody else is at work?
09:19:18 <sieni> well, I'm at "work"
09:19:23 <byte-> yay, I helped contribute to that.
09:19:33 <byte-> well, I meant at work doing something ;)
09:19:52 <sieni> i.e. tomorrow is the last day at this place and on monday I'll start at a new job
09:20:25 <Lycurgus> are you trying to imply that close monitoring of the banter in IRC channels is not "work"?
09:20:27 <byte-> nice.
09:20:42 <byte-> depends.
09:20:46 <byte-> do you have your eyes open or closed?
09:21:17 <sieni> xkiawsm id xiyeaw
09:21:31 <Lycurgus> abrir los oyos
09:22:00 <byte-> "to open eyes"?
09:22:11 <byte-> don't you want "eyes are open"?
09:22:37 <byte-> I can't remember how to turn verbs into adjectives in spanish.
09:22:39 <byte-> oh well.
09:23:06 <byte-> anyway, I just had an amazing idea.
09:23:07 <loupgaroublond> abriende?
09:23:14 <byte-> so I came in here so I could get the air kicked out of it.
09:23:28 <byorgey> byte-: let's hear it!
09:23:48 <Lycurgus> I'm not sure. Ask me later. bbiab.
09:23:53 <byte-> the idea is to add on to function notation
09:24:22 <byte-> to get rid of the crufty sequence operators like .
09:24:51 <Cale> Composition is crufty?
09:24:53 <byte-> and instead use explicit sequencing with basically a graph structure.
09:24:54 <byorgey> . is crufty?
09:25:10 <byte-> Cale, define a x y = f x y > 1 using function composition, please.
09:25:30 <Saizan> ((>1) .) . f
09:25:31 <byorgey> a = ((>1) .) . f
09:25:32 <faxathisia> @pl a x y = f x y > 1
09:25:32 <lambdabot> a = flip flip 1 . ((>) .) . f
09:25:33 <byte-> nope.
09:25:39 <Cale> That's somewhat of an unnatural thing to do.
09:25:45 <byte-> exactlly.
09:25:50 <Cale> So don't do it :)
09:25:52 <byte-> which is why it's crufty.
09:25:55 <Cale> Use a lambda
09:25:56 <faxathisia> lol
09:26:10 <Cale> (\x y -> f x y > 1)
09:26:28 <byte-> which is longer than it needs to be.
09:26:37 <byorgey> byte-: how do you propose to change the syntax, then?
09:26:52 <byte-> oh, forgot to put in the disclaimer.
09:26:56 <byte-> this has nothing to do with haskell.
09:26:58 <mux> the only way I can think of to make that shorter would be to have lambdas with de brujin indices
09:27:00 <Cale> It's no less clear than it needs to be though.
09:27:02 <sclv_> (1 <) `dot` f
09:27:06 <sclv_> whee!
09:27:18 <mux> I'd say that's unnecessary
09:27:21 <byte-> Cale, well, perhaps.
09:27:29 <byorgey> mux: heh, awesome.  but what would you do with the '1' then?
09:27:30 <sclv_> I think that's plenty readable.
09:27:56 <mux> byorgey: that would need to have a special syntax, so it'd be super crufty :-)
09:28:03 <byorgey> \ \ f 1 0 > S Z ?
09:28:04 <faxathisia> byte-: Have you not written it in haskell?
09:28:10 <mux> ?0 ?1 etc maybe, reminding of implicit parameters
09:28:10 <lambdabot> Maybe you meant: . ? @ v
09:28:14 <byte-> faxathisia, hmm?
09:28:38 <byorgey> mux: oh, I was going to suggest special syntax for integers =)
09:28:41 <byte-> sorry, got interrupted by myself.
09:28:46 <mux> :t ?f ?x ?y > 1
09:28:47 <sclv_> seriously -- just flip the greater than sign and its perfectly elegant pointfree. what am I missing?
09:28:47 <lambdabot> (?f::t_a2pI -> t_a2pJ -> Integer, ?x::t_a2pI, ?y::t_a2pJ) => Bool
09:28:58 <faxathisia> byte-: You seem to be suggesting you had some kind of idea, Didn't you prototype it in haskell yet?
09:29:03 <mux> (?f ?x ?y > 1) (+) 0 2
09:29:10 <mux> > (?f ?x ?y > 1) (+) 0 2
09:29:10 <lambdabot>   Not in scope: `y'
09:29:14 <byte-> faxathisia, it's not for haskell.
09:29:21 <byte-> faxathisia, it's purely vaporware.
09:29:28 <mux> I don't know how implicit parameters are supposed to work, but it's ugly anyways.
09:29:32 <Cale> mux: That's not how you pass implicit parameters.
09:29:34 <byte-> I just enjoy thinking about these sorts of thing.
09:29:40 <mux> Cale: I figured as much =)
09:30:46 <byte-> see, this is exactly why I like asking questions like this.
09:30:53 <mux> byorgey: proposed syntax for that insane feature :-) \# -> ?0 ?1 ?2 > 1
09:31:04 <byte-> other people always expose the rough edges of my theories.
09:31:44 <byorgey> mux: heh =)
09:31:49 <byte-> I'll continue describing my idea once I mull something over in my head.
09:31:57 <matthew-_> dons: ping?
09:32:14 <byorgey> mux: so it's assumed that \# always begins a closed term, and expands into as many \?n -> 's as necessary?
09:32:34 <byte-> ok, I think I'm done.
09:32:44 <mux> byorgey: I guess it would
09:33:12 <byte-> oops, false alarm.
09:33:16 <faxathisia> you don't need the ->
09:33:26 <mux> indeed
09:33:40 <mux> ...we can make that even more confusing
09:33:44 <byorgey> sweet!
09:33:53 <Cale> mux: hehe, and it gets better when you start to nest them :)
09:34:13 <mux> heheh
09:34:38 * byorgey finds it amusing to be having this conversation, having just learned about de Bruijn indices yesterday =)
09:36:33 <hpaste>  FunctorSalad pasted "Type-level term reducer for faxathisia" at http://hpaste.org/4778
09:36:38 <Nafai> byorgey: What are those?
09:36:45 * tlaboc finds this conversation bewildering, never having heard of de Brujin indices
09:37:23 <byorgey> Nafai: it's a way of numbering parameters to lambda expressions, so you don't have to worry about names clashing when reducing them.
09:37:42 <FunctorSalad> faxathisia: this only works on type-level yet but implementing the value stuff would be easy
09:37:45 <byorgey> The de Bruijn index k refers to the argument of the kth enclosing lambda.
09:37:45 <byte-> I hope "de Brujin indices" isn't just a fancy name for using numbers to represent arguments?
09:37:53 <byte-> oh god, it is.
09:38:01 <byte-> If I had a trout right now I'd slap you with it.
09:38:15 <byorgey> so \x . x is the same as \.0
09:38:18 <faxathisia> byte-: It's not a fancy name, it's a defined term
09:38:28 <byte-> you're a defined term!
09:38:31 <byorgey> \x.\y. y x is \ . \ . 0 1
09:38:33 <faxathisia> byte-: we could both use numbers to represent args in different ways
09:38:34 <byorgey> and so on.
09:38:57 <faxathisia> FunctorSalad: This is completly insane
09:39:12 <byte-> I think I know of one other high level PL that uses "de Bruijn indices"...
09:39:14 <FunctorSalad> uhm is that good or bad
09:39:15 <byte-> it's called bash!
09:39:19 <faxathisia> I don't know
09:39:28 <byorgey> byte-: that's not really the same thing...
09:39:49 <byte-> it most certainly is.
09:40:24 <byte-> at least in this context.
09:41:25 <faxathisia> oh wow
09:41:30 <faxathisia> I just figured out what it does
09:41:49 <byte-> faxathisia, the indices?
09:42:16 <byorgey> byte-: maybe you're right.  But it still "feels" different... I suppose because the purposes are different.
09:42:26 <byte-> of course.
09:42:35 <faxathisia> byte-: No De Bruijn Indices are totally different to bash args
09:42:48 <byte-> meh, this conversation doesn't even matter.
09:44:09 <byorgey> byte-: so what's your idea?  still thinking?
09:44:23 <byte-> byorgey, ironically, I was just writing something about that.
09:44:30 <byte-> I had to backspace over it to respond to you :P
09:44:36 <byorgey> byte-: aww =(
09:44:48 <byte-> ok, how about this
09:45:05 <byte-> get rid of the intermediate variable in this using composition:
09:45:20 <byorgey> byte-: I usually use cut+paste as a one-element irc-message stack =)
09:45:32 <byte-> f x = let y = {- some long expression -} in g y y
09:45:43 <xerox> You should use an emacs irc client for a full fledget stack :)
09:45:55 <faxathisia> f x = g {- some long expression -} {- some long expression -}
09:45:59 <byorgey> xerox: really? neat
09:46:08 <byte-> xerox, if I want to torture myself I'll send myself to GitMo.
09:46:23 <FunctorSalad> byte-: f = g . (h &&& h), where h is your thing in the let
09:46:24 <byte-> oops
09:46:28 <byte-> {- some long expresion -} contains x
09:46:46 <byte-> also, your solution can't be crufty :P
09:47:09 <FunctorSalad> ? :(
09:47:11 <byte-> it has to be obvious what the code is doing, basically.
09:47:21 <byte-> FunctorSalad, what's &&& do?
09:47:26 <byorgey> f x = join g ({- long expression -})
09:47:27 <FunctorSalad> target tupling
09:47:40 <FunctorSalad> (f &&& g) x = (fx,gx)
09:48:12 <FunctorSalad> I wouldn't exactly call that crufty
09:48:30 <byte-> perhaps not.
09:48:42 <byte-> but on the other hand, you have to write a new helper function each time  you want to do something like that, but slightly different.
09:48:50 <byte-> same with ., .2, .3, etc...
09:49:03 <byte-> where .n = f (g ($0 ... $n))
09:49:20 <byte-> in those cases you can get by with named parameters.
09:50:14 <byte-> anyway, my solution is to remove the need for named lets in those cases
09:50:30 <byte-> by allowing return values to be "split" and sent to different places.
09:50:39 <faxathisia> Why would you want to remove lets?
09:50:48 <byte-> not entirely
09:50:57 <byte-> but in the cases like above where they just obsfucate things.
09:50:58 <faxathisia> Why though
09:51:10 <byte-> "obsfucate things"
09:51:17 <sclv_> byte: <*> in the reader instance of applicative is your friend!
09:51:22 <byte-> anyway, let me finish explaining.
09:51:27 <FunctorSalad> byte-: well &&&: Hask x Hask -> Hask is left adjoint to the diagonal functor delta: Hask -> Hask x Hask, A |-> AxA if that is general enough -.-
09:52:10 <byte-> FunctorSalad, unless whatever you just said means you don't have to keep rewriting similiar functions, I think we're done with you :P
09:52:25 <byte-> anyway, let me finish.
09:52:44 <byte-> "splitting" return values becomes easy if you represent input and output explicitly.
09:52:55 <byte-> I suppose it's easier to explain in pictures.
09:53:05 <sfogarty> I am trying to get ghc on an IA64 system. Which requires a binary. IA64 is supported by ghc, but I seem to have a blind spot for finding the binary.
09:53:07 <byte-> instead of h . g . f, you'd have f -> g -> h
09:53:16 <FunctorSalad> byte-: you said &&& was not general enough, I offered a possible generalization.
09:53:16 <byte-> where an arrow shows a value being routed somewhere else.
09:53:56 <faxathisia> uh
09:53:59 <faxathisia> -> is already used
09:53:59 <byte-> FunctorSalad, I'm too lazy to look up annoyingly opaque terms.
09:54:03 <byte-> 'splain.
09:54:07 <faxathisia> byte-: You might be better to learn more haskell
09:54:11 <byte-> faxathisia, it's not haskell.
09:54:16 <faxathisia> byte-: Then you could find ways to solve the problem which already exist
09:54:42 <byte-> perhaps.
09:54:55 <byorgey> byte-: so how would you notate \f g x y -> f (g x y) ?
09:54:57 <sfogarty> Anyone that can perhaps point me to IA64 binaries?
09:54:58 <byte-> while I'm at it, I could also work to improve myself in life
09:55:01 <byte-> ....bwahaha.
09:55:37 <byte-> byorgey, nice catch.
09:55:45 <byte-> like I said, it's an extension of the usual method.
09:55:57 <byte-> you could just do
09:56:18 <byte->  \f g x y =
09:56:25 <byte->    | | |
09:56:28 <FunctorSalad> byte-: I just offered that in case you were familiar with it. "annoyingly opaque" is your subjective opinion
09:56:34 <byte->   f v v v
09:56:44 <byte-> bah, laying things out in 2d in IRC sucks.
09:56:47 <byorgey> heh
09:56:48 <faxathisia> byte-: I suggest you implement this
09:56:52 <FunctorSalad> easier that way than asking "are you familiar with ...." before saying something.
09:56:53 <faxathisia> byte-: before elaborating further
09:56:59 <byte-> lol
09:57:11 <byte-> FunctorSalad, that's fine.
09:57:29 <byte-> FunctorSalad, I'm just saying, I'm not the kind of person that has enough willpower to read boring material.
09:57:47 <Cale> What's opaque?
09:57:48 <byte-> anyway, have to run.
09:57:59 <byte-> thanks for the nice conversation.
09:58:03 <mux> it's not about haing the will to read boring things, it's about actually findings those things not boring but interesting
09:58:04 <byte-> Cale, the term's meaning.
09:58:07 <byte-> bye :)
09:58:08 <Cale> Which term?
09:58:19 <FunctorSalad> Cale: what I said above about &&&
09:58:20 <byorgey> bye byte-
09:58:25 <byte-> mux, I do enjoy this stuff, but it's hard to be interested if there's no obvious application.
09:58:26 <Cale> Left adjoint?
09:58:48 <FunctorSalad> yes. he said &&& was too specific so I said what it was an example of
09:59:01 <mux> he's a kid, a slightly trolling one imho
09:59:09 <mux> he annoyed the hell of us in ##freebsd yesterday
09:59:12 <mux> in exactly the same way
09:59:19 <Saizan> so he was proposing some ASCII-art to avoid using let?
09:59:38 <byorgey> mux: what do you mean by 'in exactly the same way'?
10:00:06 <mux> byorgey: making nearly 0 sense, being very vague, and stating sometimes totally wrong facts with some authority
10:00:15 <noteventime> Does Haskell (GHC) contain some standard library for representing geometrical shapes (spheres, cubes, points, rays), or is there some common one?
10:00:29 <mux> but maybe that's just me and you all found him very clear and all heh.
10:00:35 <FunctorSalad> I'm not sure whether adjoints have a place in haskell but in math they pop up everywhere
10:00:39 <faxathisia> mux, I'm glad I wasn't the only one annoyed by that guy...
10:01:57 <byorgey> I didn't think it was THAT bad, although I wasn't in ##freebsd so can't comment on that.
10:02:21 <byorgey> annoying in some ways perhaps, but worth giving him the benefit of the doubt IMO.
10:02:25 <mux> I also found him to be slightly arrogant
10:02:31 <mux> byorgey: that's what I did yesterday hahah :-)
10:02:36 <mux> honest.
10:02:40 <byorgey> mux: heh, I see. =)
10:02:52 <mux> I think if he comes back and gets annoying in that other channel I'll just kick him now.
10:03:01 <FunctorSalad> I can understand why people are annoyed if I bring theory into play but I was acting in good faith
10:03:20 * mux pats FunctorSalad in the back
10:03:39 <FunctorSalad> :)
10:03:52 <byorgey> I agree about the slightly arrogant part.  I just think that if slightly arrogant people are treated with respect, sometimes they learn stuff and become less arrogant.
10:03:58 <mux> I didn't understand what you said _at all_ but I'm sure it was relevant :-)
10:04:06 <faxathisia> btw bash functions arguments are numbered
10:04:16 <byorgey> hehe
10:04:19 <mux> not just bash, it's /bin/sh
10:04:20 <faxathisia> de bruijn indices just 'point' to a lambda (and the lambda all have one argument)
10:04:38 <FunctorSalad> essentially, he asked about a general way for writing things pointlessly -- IMHO category theory is the tool of choice for that, so I mentioned one of its concepts
10:06:28 <faxathisia> do people use catagory theory as axioms.. kind of like ZFC or various type theories
10:07:03 <FunctorSalad> hmm more as a language to formulate things I'd say... but I'm no expert either
10:07:59 <faxathisia> in that case, what are the basics of catagory theory often defined in terms of?
10:08:52 <byorgey> set theory, I think?  a category is a set of objects together with a set of morphisms (ordered pairs of objects) that satisfy certain laws.
10:09:13 <Cale> There are some crazy people who like the idea of using category theory as a foundation for mathematics. I'm not exactly sure how one defines a category without reference to sets.
10:09:23 <FunctorSalad> hmm if you want to use things like the "category of sets" without paradoxes, you need somewhat advanced set theory, but it's not really necessary as long as you don't pretend that Set is a set itself
10:09:27 <monochrom> Not necessarily a set. Usually a class. (Some classes cannot be sets. E.g., the class of all sets.)
10:09:56 <byorgey> isn't that the distinction between 'small' and 'large' categories?
10:09:58 <faxathisia> Set of all Sets is basically the same paradaox as Type : Type isn't it?
10:09:59 <xerox> Or even the empty set if you don't axiomatize it.
10:10:01 <FunctorSalad> byorgey: yes
10:10:20 <monochrom> Large categories are interesting, cannot be neglected.
10:10:23 <Cale> monochrom: Well, a class is just a proposition with a free variable ranging over sets.
10:10:48 <Cale> (effectively)
10:11:05 <FunctorSalad> I think what you do is take all sets you are currently interested in, close under set operations, and regard the result as your new universe
10:11:32 <FunctorSalad> which now is just as good as the class of all sets for your purposes
10:11:39 <monochrom> One could argue that "class" is just another "set theory". Anyway, you need some type system, and then you can have a foundation. The type system is better off stratified, like that of Coq.
10:11:50 <mux> quite OT: do you have recommendations for a nice frontend to crafty/gnuchess? this stupid gnome-chess thing just has 3 difficulty levels
10:11:55 <faxathisia> stratified? :S
10:11:59 <monochrom> Stratification solves all those paradoxes and clarifies your thought too.
10:13:04 <monochrom> FunctorSalad is probably going towards stratification.
10:13:17 <Cale> There's a way in which you can treat classes, as I mentioned, as simply propositions with a free variable ranging over sets, together with a mechanical transation which removes any mention of classes from any theorem, as well as a bunch of the usual set-theoretic operations on classes.
10:14:20 <Cale> Basically, you can replace membership of an element in a class with the application of the proposition to the element.
10:15:27 <FunctorSalad> IMHO if you are using CT for something else than practicing set theory, the method of choice is to ignore the issue ;)
10:15:42 <FunctorSalad> (and don't do anything self-referential)
10:16:28 <Cale> Occasionally you can end up writing nonsense, but I agree it's somewhat rare to really get yourself into a trap.
10:16:33 <FunctorSalad> but monochrom has a point that typing could help to clarify things
10:18:36 <Cale> I like how typing 'zfc' into the URL bar in firefox brings me directly to the wikipedia article.
10:19:57 <Cale> The major restriction with the view of classes that I present there is that classes can't contain other classes as elements, only sets. (Which is usually not so much of a problem.)
10:20:42 <Mitar> i know that i found some time ago a visual recognition library being written in haskell
10:20:55 <Mitar> but i cannot find it now ... does anybody know about it?
10:21:07 <FunctorSalad> Cale: hmm you do want the Cat of Cats
10:21:38 <FunctorSalad> (stratification would probably be appropriate here)
10:21:43 <Cale> FunctorSalad: Most people usually only work with the category of small categories.
10:22:01 <Cale> But yeah, if you really want that, then you'll need some kind of stratification.
10:22:59 <FunctorSalad> Cale: yes, I think that's the use of the universe-of-sets approach. you have a small subcategory of sets that does contain your favourite sets and is closed under power set, unions etc.
10:23:13 <FunctorSalad> *a small subcategory of Set
10:24:27 <FunctorSalad> afk
10:26:43 <Saizan> in Set, with the functor F X = 1 + (A x X), the greatest fixed point of F should be the set of infinite or finite "lists of A" right? how do you "calculate" that?
10:27:44 <brx> ok
10:30:21 <byte-> hello, I'm back.
10:33:20 <glen_quagmire> hello, I'm back too.
10:39:54 <byte-> ok, here ya go: http://home.comcast.net/~cwarren89/goal.txt
10:40:08 <byte-> basically sums up the idea.
10:40:22 <byte-> disclaimers: this is not meant as an addition for haskell
10:40:38 <byte-> disclaimers: ignore the parsing issues.
10:40:52 <byte-> disclaimers: ignore the editing issues.
10:40:59 * jfredett waves hand, "They are not the issues you are looking for"
10:41:48 <byte-> jfredett, what?
10:42:03 <byorgey> hehe
10:42:29 <byorgey> byte-: you haven't seen Star Wars? =)
10:42:43 <jfredett> byte-: ...
10:42:46 <byte-> I think I've only seen 2 of them.
10:42:50 <byte-> episode 1
10:42:53 <byte-> and possibly one of the first 3.
10:42:55 <byte-> I don't remember.
10:42:58 <byte-> I'm not a big fan.
10:43:02 <jfredett> your lack of star wars knowledge disturbs me
10:43:09 <faXx> jfredett: XD
10:43:21 <byte-> glad to know I've had an impact on this world.
10:43:32 <byte-> now, on to my ebay feedbacks page...
10:43:36 <jfredett> do not underestimate the _power_ of the star wars geek
10:43:59 <byte-> your lack of xkcd knowledge disturbs me.
10:44:09 <jfredett> pfft, I know plenty about xkcd
10:44:14 <jhjones> could someone give me a clue on this newbie question... i'm writing a function that generates a list of things, and i want to create each thing by passing in some arguments
10:44:15 <byorgey> and now, you will witness the power of this fully operational semantics!!
10:44:23 <jfredett> "Got tiger, would not buy again"
10:44:28 <byte-> and yet you didn't chuckle at that brilliant (if I do say so myself...) reference?
10:44:34 <byte-> ;P
10:44:53 <byte-> byorgey, another star wars reference?
10:45:00 <byorgey> byte-: of course =)
10:45:06 <byorgey> jhjones: ok...
10:45:21 <jfredett> i wasn't here for the whole convo- so I wasn't sure if you had _actually_ been talking about your ebay page
10:45:21 <jhjones> so i made a function that looks like this
10:45:23 <byte-> I'm guessing nobody could figure out what the hell that text file was, then?
10:45:46 <jhjones> getPolypoint 2 4 10.0
10:45:51 <byte-> or noobyd bothered downloading it?
10:46:04 <byte-> yes, that's right.
10:46:06 <jhjones> which returns the point of a regular poly, with index 2, radius 10, and four sides
10:46:13 <byte-> you might think that was a spelling error, but you would be mistaken.
10:46:18 <jhjones> but i can't figure out how to call it n times and create the list of points
10:46:24 <byte-> I was actually calling all of you 'noobs' in the most covert fashion.
10:46:50 <byorgey> jhjones: you just want to repeat the output of 'getPolypoint 2 4 10.0' n times?
10:46:59 <byorgey> jhjones: or you want to call it n times with different parameters?
10:47:12 <byte-> I think he's having trouble writing 'getPolypoint', correct?
10:47:14 <jhjones> the first parameter is the one that will change, it is the vertex index i want
10:47:22 <jhjones> no i've written that and it's working
10:47:25 <byte-> damn.
10:47:34 <byte-> well fine, then!
10:47:39 <byte-> enjoy figuring it out on your own ;)
10:47:43 <byorgey> jhjones: ok, so I think you want something like map (\i -> getPolypoint i 4 10) [1..4]
10:48:04 <jhjones> yes i think so, thanks
10:48:18 <byte-> or better yet, reorder the parameters to 'getPolypoint' so you can do
10:48:23 <byte-> map getPolypoint 4 10 [1..4]
10:48:27 <byte-> oops
10:48:32 <byte-> map $ getPolypoint 4 10 $ [1..4]
10:48:41 <byorgey> or map (getPolypoint 4 10) [1..4]
10:48:49 <byte-> I don't like parenthesis.
10:48:57 <byorgey> actually, byte-, your version with $ doesn't work
10:49:05 <byte-> it doesn't?
10:49:08 <byorgey> since $ is right-associative
10:49:40 <byorgey> x $ y $ z ==> x (y z)
10:49:54 <byte-> whoops
10:49:55 <byte-> I see now.
10:50:31 <byte-> I've been using composition so much lately that's all I remember how to do :/
10:50:57 <alexj> what is the correct way to convert between string and bytestring?
10:51:25 <bos> alexj: pack and unpack
10:51:25 <byte-> well, I think I've milked this channel for all it's worth.
10:51:30 <byte-> *its
10:51:33 <byte-> toodles.
10:51:38 <alexj> bos: pack and unpack convert to Word8
10:51:41 <bos> alexj: but they're only 7-bit clean
10:51:59 <bos> alexj: you're using the wrong module then. Data.ByteString{,.Lazy}.Char8
10:52:08 <alexj> bos: (unpack bs) ++  "abc"
10:52:12 <alexj> does not compile
10:52:23 <bos> see above.
10:52:34 <alexj> ah ok.
10:52:50 <sjanssen> bos: why aren't they 8-bit clean?
10:53:53 <bos> sjanssen: they preserve the 8th bit, but they don't interpret it via an encoding. so what they do is almost always useless.
10:55:15 <jhjones> so this is working regularPolygon n s = Polygon (map (\i -> getPolypoint i n s) [0..n])
10:55:27 <jhjones> byte: how do i do what you suggested with the params
10:58:17 <Mitar> is there any computer vision library?
10:58:43 <byorgey> jhjones: what he was suggesting is to change the order of the parameters to getPolypoint, so the index is last
10:59:05 <byorgey> jhjones: that way instead of writing \i -> getPolypoint i n s, you can just write getPolypoint n s
10:59:22 <jhjones> gotcha
10:59:52 <byorgey> i.e. partially apply it to n and s, resulting in a function that takes the index and returns the poly point
11:04:11 <Brian`> hi, when i try to compile some packages, it says "Warning: The field "hs-source-dir" is deprecated, please use "hs-source-dirs""
11:04:18 <visof> > fst fst ((2,'d') , "hi")
11:04:19 <lambdabot>  Couldn't match expected type `(a, b)'
11:04:20 <Brian`> how do I use hs-source-dirs?
11:04:29 <visof> > fst  ((2,'d') , "hi")
11:04:30 <lambdabot>  (2,'d')
11:04:46 <bos> Brian`: the same way
11:04:52 <jfredett> > fst (fst ((2,'d'),"hi"))
11:04:52 <visof> the first is error why?
11:04:53 <lambdabot>  2
11:04:59 <visof> oh
11:05:03 <visof> thanks
11:05:06 <byorgey> Brian`: edit the .cabal file
11:05:06 <jfredett> also
11:05:12 <jfredett> > fst $ fst ((2,'d'),"hi")
11:05:12 <lambdabot>  2
11:05:27 <visof> what $ mean?
11:05:27 <jfredett> when in doubt, do as the lispers do
11:05:31 <jfredett> parenthesize
11:05:44 <jfredett> $ wraps the term to the right in parens
11:05:48 <jfredett> essentially
11:05:50 <byorgey> visof: it just means function application, but it has low precedence so it lets you avoid parens sometimes
11:05:54 <byorgey> f $ x = f x
11:06:19 <visof> apply f to the argument x
11:06:23 <visof> right?
11:06:24 <jfredett> yep
11:06:24 <byorgey> right
11:06:29 <visof> ok
11:06:32 <visof> thanks
11:06:42 <jfredett> its nice for making code less lisp-like
11:06:50 <visof> hahaha
11:07:00 <jfredett> you'll get some situations where you have a chain of 6 or 7 functions
11:07:07 <jfredett> and $ is invaluable for readability
11:07:37 <byorgey> or better yet, .
11:07:58 <jfredett> yes- but sometimes (.) doesn't do what you want
11:08:16 <bos> . usually does what you want. just put the $ at the end of the chain.
11:08:23 <jfredett> yes
11:08:29 <jfredett> i dunno
11:08:33 <byorgey> jfredett: (.) always does what *I* want. ;-)
11:08:34 <jfredett> they're both equally useful
11:08:36 <jfredett> :P
11:08:40 <jfredett> . doesn't like me
11:08:41 <jfredett> :)
11:08:49 <bos> no, there are places where $ doesn't do what you want, and . does.
11:09:14 <jfredett> bos, sure, but I'd bet the converse is true
11:09:48 <jfredett> all combinators are useful somewhere, or else they wouldn't have survived the successive revisions of prelude
11:09:49 <bos> no, it isn't.  it's to do with the type inference not working out on higher-ranked types when you use $.
11:09:56 <oklopol> > ((+) . (*)) 5 6
11:09:56 <lambdabot>   add an instance declaration for (Num (a -> a))
11:10:06 <oklopol> :)
11:10:16 <oklopol> (.) not always does what i want!
11:10:35 <jfredett> actually, it likely would, but I think what your trying to do
11:10:40 <jfredett> and what your telling it to do
11:10:43 <jfredett> are different
11:11:11 <jfredett> i'm not saying only use $ or .
11:11:15 <byorgey> jfredett: well, you could say that about any situation where Thing X doesn't do what you 'want it to do'. =)
11:11:17 <jfredett> i'm saying they're both useful for something
11:11:18 <jfredett> :P
11:11:30 <byorgey> they are indeed.
11:11:34 <jfredett> lol
11:11:59 <Brian`> one more question about installing a package..
11:12:09 <FunctorSalad> faxathisia: so how did the term thing work out? was my program what you were looking for?
11:12:11 <malsyned> is there a combinator that does what oklopol meant with ((+) . (*)) 5 6 ?
11:12:13 <Brian`> when I try to install HaXml with ghc-6.8.2,
11:12:25 <Brian`> I got "<interactive>: /usr/local/lib/ghc-6.8.2/lib/Cabal-1.2.3.0/HSCabal-1.2.3.0.o: unknown symbol `prettyzm1zi0zi0zi0_TextziPrettyPrintziHughesPJ_lvl18_closure'
11:12:25 <Brian`> ghc-6.8.2: unable to load package `Cabal-1.2.3.0'"
11:12:28 <Brian`> this error message..
11:12:37 <Brian`> has anyone encountered the same error?
11:12:41 <jfredett> do you have the latest cabal installed?
11:12:45 <Brian`> 1.2.3.0
11:12:49 <faxathisia> FunctorSalad: It wasn't exactly what I was looking for but pretty amazing
11:12:58 <jfredett> you get that when doing a ghc-pkg --list
11:13:12 <Brian`> jfredett, yeah I have 1.2.3.0.. is it not the latest one?
11:13:19 <jfredett> well, its the one its looking for
11:13:19 <malsyned> actually, nevermind, I'm not sure what he might have meant.
11:13:29 <FunctorSalad> faxathisia: heh thanks. I'm a haskell newb so I was afraid hot to interpret "insane" =)
11:13:30 <jfredett> so I think it should be all set
11:13:31 <jfredett> hmm
11:13:34 <byorgey> malsyned: I was just about to say something to that effect =)
11:14:31 <hpaste>  ra9ftm pasted "fsck" at http://hpaste.org/4779
11:14:40 <Brian`> hm... would it be because I installed pretty package..?
11:14:46 <Brian`> how do I remove the package?
11:14:58 <malsyned> Are there any papers anyone could recommend about implementing interpreters or compilers for normal-order languages?
11:15:23 <byorgey> Brian`: that shouldn't make a difference.  is Cabal installed locally or systemwide?  i.e. which list does it show up under when you run 'ghc-pkg list'?
11:15:51 <Brian`> byorgey, "/usr/local/lib/ghc-6.8.2/package.conf:"
11:15:51 <Brian`>  
11:16:12 <Brian`> does that mean it's installed locally?
11:16:17 <hpaste>  ra9ftm pasted "fdisk" at http://hpaste.org/4780
11:16:39 <byorgey> Brian`: no, that's system-wide
11:16:50 <byorgey> Brian`: locally would be somewhere in your home directory
11:18:47 <oklopol> malsyned: after giving it a bit of thought, i have no idea myself.
11:18:56 <oklopol> haskell is cleverer than me
11:19:03 <jfredett> oklopol: story of my life
11:19:17 <oklopol> which one :)
11:19:37 <Brian`> byorgey, ok. hm... is there any known package problems (i.e. two packages conflict each other)
11:20:14 <byorgey> Brian`: not that I know of
11:25:06 <Brian`> byorgey, how do I remove a package?
11:25:15 <yrlnry_> n #Haskell
11:25:18 <Brian`> byorgey, I think ever since I installed pretty package, it gives me that problem..
11:25:18 <jfredett> ghc-pkg -unregister i think?
11:25:27 <yrlnry_> @pf \(x:_) (y:_) -> x + y
11:25:27 <lambdabot> Maybe you meant: bf pl
11:25:28 <jfredett> then the name of the package
11:25:33 <yrlnry_> @pl \(x:_) (y:_) -> x + y
11:25:33 <lambdabot> (`ap` tail) . (. head) . (const .) . (+) . head
11:25:34 <Brian`> jfredett, k
11:25:38 <Brian`> jfredett, thanks
11:25:45 <yrlnry_> @pl \x y  -> (head x) + (head y)
11:25:46 <lambdabot> (. head) . (+) . head
11:25:46 <jfredett> if you do a ghc-pkg --help
11:25:50 <jfredett> it should tell you
11:25:51 <yrlnry_> Is the former output a bug?
11:26:04 <yrlnry_> "tail" should not appear anywhere in the output, I think.
11:26:09 <faxathisia> :t (`ap` tail) . (. head) . (const .) . (+) . head
11:26:11 <lambdabot> forall a. (Num a) => [a] -> [a] -> a
11:26:40 <yrlnry_> > ((`ap` tail) . (. head) . (const .) . (+) . head) [3] [7]
11:26:41 <lambdabot>  10
11:27:33 <yrlnry_> What is "tail" doing in there?
11:30:04 <FunctorSalad> Brian`: ghc-pkg can "hide" packages without removing them, too
11:30:19 <FunctorSalad> ... which is undone with "expose"
11:30:43 <KirinDave> Hey, does anyone have a detailed description of how to install ghc on an intel darwin box? I'd like to learn more about haskell but they don't provide intel mac binaries and their preferred install method has been broken for nearly a year.
11:33:00 <Brian`> hey, how come my ghc-pkg list shows "/usr/local/lib/ghc-6.8.2/package.conf:
11:33:00 <Brian`>     Cabal-1.2.3.0, HTTP-3001.0.4, HUnit-1.2.0.0, X11-1.4.1,
11:33:00 <Brian`>     array-0.1.0.0, base-3.0.1.0, bytestring-0.9.0.1,
11:33:00 <Brian`>     containers-0.1.0.1, directory-1.0.0.0, filepath-1.1.0.0,
11:33:04 <Brian`>     (ghc-6.8.2), haskell98-1.0.1.0, hpc-0.5.0.0, hxt-7.4, mtl-1.1.0.0,
11:33:07 <Brian`>     network-2.1.0.0, old-locale-1.0.0.0, old-time-1.0.0.0,
11:33:18 <Brian`>     packedstring-0.1.0.0, parsec-2.1.0.0, polyparse-1.1,
11:33:18 <Brian`>     pretty-1.0.0.0, process-1.0.0.0, random-1.0.0.0, readline-1.0.1.0,
11:33:18 <Brian`>     rts-1.0, template-haskell-2.2.0.0, unix-2.3.0.0, xmonad-0.5,
11:33:20 <Brian`>     xmonad-contrib-0.5"? why is ghc-6.8.2 in parentheses?
11:33:22 <Brian`> does that mean ghc-6.8.2 package is hidden?
11:33:25 <markluffel> KirinDave: do you have darwinports installed?
11:34:07 <malsyned> Wow, really?  Nobody in #haskell has a pet favorite paper on implementing a lazy interpreter or compiler?
11:34:33 <jfredett> no malsyned, some of us have lives. :)
11:34:44 <KirinDave> markluffel: Darwinports _does not work._
11:35:01 <KirinDave> markluffel: It never works. I dunno why i even tried. Darwinports is about as effective as the rythm method.
11:35:02 <jstanley> KirinDave: It worked for me a couple of weeks ago. What problem in particular are you having with it?
11:35:14 <KirinDave> jstanley: configure: error: GHC is required unless bootstrapping from .hc files.
11:35:15 <markluffel> KirinDave: i used it to install 6.6, but i compiled 6.8 from the tarball
11:35:27 <Leimy> I got an old GHC releaes
11:35:32 <Leimy> and built it from source on an Intel mac
11:35:42 <KirinDave> Do I need to have a ghc before darwinports can install ghc?
11:35:43 * Leimy worked on darwinports...
11:35:48 * Leimy doesn't like darwinports :-)
11:36:07 <markluffel> KirinDave: nope, needs a c compiler only (i believe)
11:36:08 <Leimy> I think the darwinport will download a GHC binary then compile it with it.
11:36:08 <jstanley> KirinDave: I didn't need one :-/
11:36:10 <malsyned> jfredett: sure, but for some people who hang out here, those lives include maintaining Haskell implementations and writing papers about it.
11:36:18 <KirinDave> Well, it certainly implies that I need one.
11:36:22 <Leimy> GHC is written in haskell, but can be bootstrapped from C source.
11:36:26 <KirinDave> "GHC is required unless bootstrapping from .hc files."
11:36:28 <jfredett> malsyned: I was making a joke, :P
11:36:38 <Leimy> I do NOT recommend trying to bootstrap from C files, from experience.
11:36:45 <markluffel> jfredett: perhaps not the kindest kind of joke
11:36:54 <jfredett> markluffel: thats the _best_ kind
11:37:04 <jfredett> my middle name is "Spreader of turmoil and misery"
11:37:16 <jfredett> me and  Korollary are working towards armageddon
11:37:16 <jfredett> :)
11:37:18 <malsyned> jfredett: and anyway, just because some of you have lives, doesn't mean all of you do.  I might still have some luck.
11:37:20 <Leimy> oy
11:37:37 <Leimy> the joys of IRC...
11:37:52 * jfredett shakes his hea
11:37:53 <jfredett> d
11:37:57 <jfredett> never mind...
11:39:30 <byorgey> Brian`: yes, it means the ghc-6.8.2 package is hidden, but I believe that's the package that provides a ghc API, which you shouldn't need.
11:39:40 <byorgey> i.e. it's not "ghc itself".
11:40:51 <KirinDave> So basically I can't install ghc on an intel mac any other way?
11:40:55 <markluffel> KirinDave: I guess you've downloaded from http://haskell.org/ghc/download_ghc_682.html#macosxintel ? what errors are you getting?
11:40:57 <Brian`> byorgey, hm.. weird ; where can I ask this problem to other than irc channel?
11:41:18 <KirinDave> markluffel: Let me run that again. I don't have it in my scrollback.
11:41:32 <Brian`> byorgey, I mean "<interactive>: /usr/local/lib/ghc-6.8.2/lib/Cabal-1.2.3.0/HSCabal-1.2.3.0.o: unknown symbol `prettyzm1zi0zi0zi0_TextziPrettyPrintziHughesPJ_lvl18_closure'ghc-6.8.2: unable to load package `Cabal-1.2.3.0'" this problem
11:41:44 <byorgey> Brian`: you could try the haskell-cafe mailing list
11:41:45 <faxathisia> KirinDave: Cant' you use a ppc GHC?
11:41:53 <faxathisia> KirinDave: Then compile an intel one using it?
11:41:57 <Leimy> hmmm
11:42:05 <Leimy> Won't PPC GHC only make PPC binaries?
11:42:19 <faxathisia> Leimy: I don't see why it would
11:42:22 <markluffel> Leimy: you could (presumably) cross-compile
11:42:40 <Leimy> does GHC target non native platforms with it's native code?
11:43:02 <Leimy> I've never tried it at that level
11:43:26 <markluffel> what do you mean by non-native?
11:43:52 <Leimy> if GHC is a PPC binary, does it have the ability to generate non PPC code? :-)
11:44:39 <Leimy> anyway, I got an old Intel targetted Mac 6.6.(1?) release, installed it, and then build 6.8.2 with it.
11:44:42 <KirinDave> faxathisia: I don't even kno what's really wrong.. so.
11:44:43 <Leimy> so far so good I think.
11:46:57 <visof> > "hello" ++ "\n" ++ "world"
11:46:59 <lambdabot>  "hello\nworld"
11:47:26 <visof> isn't "\n" for newlin?
11:47:35 <visof> new line*
11:48:45 <faxathisia> visof: Why do you ask?
11:49:01 <Valodim> lambdabot just doesn't display it, I guess
11:49:16 <faxathisia> "hello\nworld" is a picture of a string with a newline in it
11:49:22 <visof> i did it by ghci but i had the same result
11:49:36 <faxathisia> visof: try print "hello\nworld"
11:49:43 <Saizan> not print
11:49:47 <Saizan> putStr
11:50:11 <noteventime> Is there some standard Haskell library for vectors (and vector multiplication e.t.c.)?
11:50:36 <Leimy> noteventime: see the hackage DB
11:50:42 <Leimy> look for the linear algebra package.
11:50:45 <Leimy> I think there's one
11:50:46 <dons> noteventime: yeah, hmatrix, iirc or one of the others
11:51:15 <noteventime> dons and Leimy: Is there some kind of consensus on which one is the more complete/robust?
11:51:17 <Leimy> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Math
11:51:18 <lambdabot> http://tinyurl.com/yqov7f
11:51:30 <Leimy> noteventime: I've never tried any of em :-)
11:51:42 <visof> it's work by putStr
11:51:59 <noteventime> Leimy: Ok, thanks :-)
11:52:23 <dons> noteventime: you'll be one of the first 3rd party users :)
11:53:15 <noteventime> dons: I'll try hmatrix then, thanks :-)
11:53:59 <malsyned> dons!  surely you'll be able to name a few papers that deal with implementing lazy interpreters or compilers.  I'm playing with a toy language and I want to make sure I don't make old mistakes instead of new ones.
11:54:44 <Cale> malsyned: Well, there's the famous paper about the STG machine.
11:55:02 <dons> there's SPJ's "thesis", "The implementation of functional programming languages", (or something like that)
11:55:08 <malsyned> Cale: pretend I'm new to this ;) which paper?
11:55:28 <Cale> I'll find it
11:55:33 <Cale> http://citeseer.ist.psu.edu/peytonjones92implementing.html
11:55:34 <lambdabot> Title: Implementing lazy functional languages on stock hardware: the Spineless Tagless  ...
11:55:41 <dons> that's the ghc bible
11:55:57 <dons> but its more about the compilation and runtime strategy
11:55:57 <Cale> 210 citations :)
11:56:15 <Cale> http://research.microsoft.com/%7Esimonpj/papers/slpj-book-1987/index.htm
11:56:15 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/jd2f6
11:56:18 <dons> spj's book includes compilers and intrerpreters
11:56:23 <dons> so probably a better place to start
11:56:31 <dons> there's also bob harper's book
11:56:32 <dons> ?plbook
11:56:33 <lambdabot> Unknown command, try @list
11:56:36 <dons> ?where plbook
11:56:36 <lambdabot> http://www-2.cs.cmu.edu/~rwh/plbook/
11:56:40 <dons> which has similar material
11:56:45 <dons> also very good
11:56:55 <malsyned> wow.  awesome.  thanks guys!
11:58:24 <Cale> Yeah, I suppose the STG machine paper would be a pretty natural continuation of SPJ's book, seeing as it works with the plain G-machine throughout part III.
12:00:55 <Saizan> is there anything like that for typechecking h98 + MPTC + fundeps?
12:02:05 <Cale> I'm not entirely certain that MPTC's + fundeps are actually formally understood/specified yet. There was some work in that direction on the mailing list.
12:03:45 <Saizan> which?
12:03:47 <malsyned> Man SPJ is prolific.
12:04:18 <Saizan> however since they use it in ghc i hope they have a specification for them..
12:05:18 <hpaste>  (anonymous) pasted "simple program" at http://hpaste.org/4781
12:06:33 <malsyned> well, there's a bug in that paste.  who posted it?
12:08:10 <visof> i 'm
12:09:16 <byorgey> visof: module names must start with a capital letter.
12:09:32 <visof> ok
12:09:37 <visof> thanks
12:09:40 <byorgey> sure
12:10:07 <visof> i learn haskell from yaht
12:25:55 <thetallguy> Can someone point me to a detailed discussion of WHNF?
12:32:36 <jz87> is anyone familiar with the http library?
12:32:50 <jz87> I'm a bit puzzled at the behavior of the stream socket readline function
12:33:28 <jz87> it seems that I can't call it unless all the input bits are already buffered
12:33:40 <jz87> or else I get a recvLen error
12:34:03 <jz87> what is the proper usage of receiveHTTP in the HTTP package?
12:39:43 <swiert> thetallguy: http://research.microsoft.com/~simonpj/papers/slpj-book-1987/PAGES/198.HTM
12:39:43 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/233gfm
12:39:59 <swiert> might be a good place to start.
12:43:54 <jz87> so anyone know about the HTTP library?
12:46:45 <thetallguy> swiert: thanks
12:53:49 <tlaboc> thetallguy: if you are still looking for WHNF info here's a link that someone mentioned yesterday that seems to explain it nicely: http://en.wikibooks.org/wiki/Haskell/Laziness
12:53:55 <roconnor> > let {(*) = (,); (+) = (:)} in "apples" * 7 + "bananas" * 6 + []
12:53:56 <lambdabot>  Couldn't match expected type `([Char], t)'
12:54:18 <roconnor> > let {(*) = (,); (+) = (:)} in "apples" * 7 + ("bananas" * 6 + [])
12:54:19 <lambdabot>  [("apples",7),("bananas",6)]
12:54:29 <roconnor> damn associativity
12:55:39 <byorgey> > let {(*) = (,); (+) = flip (:)} in [] + "apples" * 7 + "bananas" * 6
12:55:39 <lambdabot>  Couldn't match expected type `[a]'
12:55:39 <tlaboc> how's that?
12:57:33 <EvilTerran> the precedence is attached to the specific binding, not the name
12:58:20 <byorgey> ah
12:58:22 <EvilTerran> > let {infixl 7 *; (*) = (,); infixl 6 +; (+) = flip (:)} in [] + "apples" * 7 + "bananas" * 6
12:58:23 <lambdabot>  [("bananas",6),("apples",7)]
12:58:29 <byorgey> that would do it =)
12:59:04 <byorgey> > let {infixl 7 *; (*) = (,); infixr 6 +; (+) = (:)} in "apples" * 7 + "bananas" * 6 + []
12:59:05 <lambdabot>  [("apples",7),("bananas",6)]
13:00:24 <tlaboc> i've seen code like this before...what's the reason for using + and * instead of the usual symbols?
13:00:56 <byorgey> tlaboc: no reason, really... maybe they look nicer?
13:01:17 <byorgey> or maybe they help you think more directly about the problem you are trying to solve
13:01:23 <tlaboc> abuse of operator reassignment just for fun? :p
13:01:52 <byorgey> tlaboc: sure, why not? =)
13:02:03 <tlaboc> i won't dispute that its neat
13:02:18 <byorgey> you must promise to only use this power for Good
13:02:21 <tlaboc> im just trying to figure out an application of it
13:02:47 <tlaboc> are there any obfuscated Haskell contests?
13:03:00 <byorgey> tlaboc: there used to be
13:03:10 <tlaboc> a terrifying thought
13:03:11 <byorgey> @go obfuscated haskell
13:03:14 <lambdabot> http://www.haskell.org/haskellwiki/Programming_contests
13:03:14 <lambdabot> Title: Programming contests - HaskellWiki
13:03:32 <byorgey> I think there have been two, the Zeroth and the Succ Zeroth =)
13:04:00 <tlaboc> ...because counting with human numbers is boring?
13:04:34 <byorgey> no, because it's not obfuscated, of course =)
13:04:57 <byorgey> oh, sorry, there were three, I forgot about the Bottomth
13:04:59 <tlaboc> this can only lead to madness...
13:05:36 <tlaboc> there's already way too much theoretical math in Haskell, people don't need to be 'suspending layout' and replacing keywords with symbols too
13:08:20 <tlaboc> dont get me wrong, haskell's awesome stuff, but it obfuscated haskell? :O
13:08:52 <oerjan> obfuscation is fun
13:10:41 <tlaboc> well sure, but byorgey was just making me promise only to use a certain technique only for 'Good'... :)
13:10:56 <FunctorSalad> it's nice that with ghc you can derive arbitrary classes for a newtype
13:11:05 <FunctorSalad> (apparently)
13:11:49 <dozer> is there a fairly generic collection class?
13:11:49 <oerjan> single-parameter classes, that is
13:11:56 <byorgey> tlaboc: obfuscating things for a fun contest counts as Good.  obfuscating things to confuse noobs so they are in awe of your god-like haskellishness is not. =)
13:12:15 <dozer> I want to write code that collects a load of things from a data-structure, but don't want to specify the container for the collected things
13:12:19 <dozer> e.g. list vs set
13:12:25 <Saizan> oerjan: even multi
13:12:53 <Saizan> dozer: Data.Traversable?
13:13:03 <Saizan> or Foldable
13:13:06 <oerjan> Saizan: oh!
13:13:59 <oerjan> alas Foldable only is generic when you extract _from_ a collection
13:14:30 <tlaboc> byorgey: fair enough :)
13:14:37 <oerjan> wasn't there an alternative collections library were things were more generic?
13:14:41 <dozer> both foldable and traversable are suitable for decomposition/visitng, not for building it up
13:14:57 <Saizan> uh, i read the question backwards
13:15:20 <hpaste>  (anonymous) annotated "Type error" with "(no title)" at http://hpaste.org/4782#a1
13:15:50 <dozer> I want a class with operations like Nill::(Collection c) => c e; Add::(Collection c) => e -> c e -> c e
13:16:38 <dufflebunk> Array?
13:16:41 <Saizan> i'd just use a list and let the compiler fuse if you're converting to another struct
13:16:55 <EvilTerran> ApplicativePlus? :D
13:17:19 <dozer> ET:??
13:17:42 <dozer> Saizan: that's what I've ended up doing, but it's not very elegant
13:17:43 <bos> @seen dcoutts
13:17:43 <lambdabot> dcoutts is in #ghc, #gentoo-haskell and #haskell. I last heard dcoutts speak 6h 45m 49s ago.
13:18:30 <oerjan> EvilTerran: that's Alternative
13:18:39 <EvilTerran> oh right
13:19:56 <sclv_> dozer: you could also pass in an empty instance and a collection item both to yr. function, right?
13:20:22 <dozer> sclv_: sure - but the function would have to be able to deal with the type of the empty instance
13:21:13 <sclv_> you could also maybe return a monoid?
13:21:38 <sclv_> and just take an injection function. not awful efficient tho.
13:22:08 <dozer> again, yes I could, but it isn't making the code document the intent
13:24:29 <sclv_> monoids are a good model for collections though?
13:25:24 <roconnor> <EvilTerran> the precedence is attached to the specific binding, not the name
13:25:27 <roconnor> what does that mean?
13:26:31 <yrlnry_> @source (>>>)
13:26:32 <lambdabot> (>>>) not available
13:26:36 <yrlnry_> @source >>>
13:26:37 <lambdabot> >>> not available
13:27:28 <oerjan> @source Arrow
13:27:28 <lambdabot> Arrow not available
13:27:37 <oerjan> argh
13:27:43 <oerjan> @src Arrow
13:27:43 <lambdabot> class Arrow a where
13:27:43 <lambdabot>     arr, pure   :: (b -> c) -> a b c
13:27:43 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
13:27:43 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
13:27:44 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
13:27:46 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
13:27:48 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
13:29:14 <oerjan> roconnor: it means if you redefine a name in an inner scope, the precedence is reset too
13:30:33 <roconnor> oh
13:31:09 <oerjan> > let a + b = a Prelude.+ b; infixr 8 + in 1 + 2 * 3 Prelude.+ 4
13:31:11 <lambdabot>  13
13:33:04 <oerjan> also, the same name from different modules, although then of course you need to qualify at least one of them
13:58:12 <FunctorSalad> why don't I have the Data.Function package?
13:58:34 <hpaste>  mmorrow pasted "FastCGI App Monad Transformer" at http://hpaste.org/4783
13:58:50 <Saizan> FunctorSalad: old ghc?
13:59:23 <FunctorSalad> Saizan: 6.6.1
13:59:40 <FunctorSalad> ok I'll just write "on" myself ;)
14:03:46 <Sizu1> @users
14:03:46 <dcoutts> bos: pong
14:03:46 <lambdabot> Maximum users seen in #haskell: 425, currently: 414 (97.4%), active: 13 (3.1%)
14:06:43 <dcoutts> bos: ah, the prefix mangling...
14:07:18 <oerjan> mangle mangle, twist and tangle...
14:08:35 <dozer> those of you in the UK may want to drop a friendly note to your MP re: http://yro.slashdot.org/article.pl?sid=08/01/03/2056223&from=rss
14:08:37 <lambdabot> Title: Slashdot | UK Moves to Outlaw 'Hacker Tools'
14:09:21 <dozer> before they accidentally outloaw distributing turing complete languages with tcp/ip stacks
14:13:18 <FunctorSalad> why do I need allow-undecidable for this? "instance (SLOrd a1 a2 a) => Ord a where ..."
14:13:41 <FunctorSalad> with SLOrd being  "class (Ord a1, Ord a2) => SLOrd a1 a2 a | a -> a1 a2 where ..."
14:14:21 <oerjan> the context is vastly larger than the result instance
14:15:03 <FunctorSalad> hmm doesn't the fundep solve that?
14:15:18 <oerjan> hm
14:15:57 <oerjan> ok maybe it should, perhaps ghc is just not that clever
14:16:35 <FunctorSalad> would the problem without the fundep be that a could be equipped with a < from multiple a1/a2's ?
14:16:58 <oerjan> oh wait
14:17:15 <sclv_> SLOrd has an implicit (forall a.), no?
14:17:15 <oerjan> the actual problem may be that a1 and a2 themselves may be larger than a
14:18:18 <oerjan> sclv_: i think not
14:19:01 <FunctorSalad> sclv_: hmm a can in principle be anything if you mean that
14:19:20 <sclv_> so what if a is an it?
14:19:25 <sclv_> erm, Int?
14:19:39 <sclv_> then which Ord instance applies?
14:20:02 <alexj> is there a standard lib for hextoint?
14:20:03 <FunctorSalad> hmm then you couldn't have instances of SLOrd Foo Bar Int
14:20:49 <FunctorSalad> but can't I make instances of SLOrd Foo Bar Whatsit, with Whatsit not ordered?
14:20:51 <oerjan> > readHex "beef"
14:20:53 <lambdabot>  [(48879,"")]
14:21:33 <oerjan> > read "0xbeef" :: Integer
14:21:34 <lambdabot>  48879
14:22:19 <sclv_> FunctorSalad: with allow undecidable and allow overlapping
14:22:35 <hpaste>  mmorrow annotated "FastCGI App Monad Transformer" with "example" at http://hpaste.org/4783#a1
14:22:37 <oerjan> overlapping is a given
14:22:42 <sclv_> then you can even have instances of Foo Bar Int -- the Int ord will take priority because its more specific
14:22:54 <FunctorSalad> that sounds dangerous
14:22:57 <FunctorSalad> :)
14:23:53 <sclv_> Anyway, I think that's why you need -fallow-undecidable.
14:25:58 <FunctorSalad> FWIW, "SLOrd a1 a2 a" should mean "c has a lexical order induced by f1::a->a1, f2: a->a2 and has some additional features"
14:26:25 <FunctorSalad> if I had to, I could fix a1 and a2 to Int, but it seems nicer this way
14:26:42 <FunctorSalad> sorry, "a has a lexical ordering..."
14:27:14 <FunctorSalad> but maybe this is a job for "data" again...
14:28:58 <FunctorSalad> "data D a1 a2 a = { f1 :: a->a1; f2 :: a->a2; additionalFunction :: ... }"
14:29:12 <FunctorSalad> I seem to be obsessed with the type system :)
14:30:14 <oerjan> hm...
14:30:28 <oerjan> maybe this could be done with those newfangled type families?
14:30:59 <sclv_> hmmm: I guess overlapping doesn't require/imply undecidable.
14:31:05 <sclv_> reading the ghc docs now...
14:31:16 <oerjan> class SLOrd a where type a1 = ...
14:31:43 <oerjan> except i don't know anything about it, really
14:32:32 <FunctorSalad> oerjan: I think data is actually perfect for this :) as I said, type obsession
14:32:59 <sclv_> The docs do note that GHC doesn't take fundeps into account for the patterson and coverage conditions.
14:33:05 <FunctorSalad> same thing as with the bijective function thing I asked the other day
14:33:51 <sclv_> FunctorSalad: I feel the same way sometimes, like looking to typeclasses is, about half the time, just an OO hangover.
14:34:02 <mdmkolbe|work> Is there a standard equivalent of (concat . intersperse x)?  (Like Perl's "join" operator)
14:34:19 <Saizan> intercalate?
14:34:24 <Saizan> ?type intercalate
14:34:25 <lambdabot> Not in scope: `intercalate'
14:34:29 <sclv_> Whenever I use an existential I feel very silly for this reason.
14:34:40 <FunctorSalad> sclv_: that too. I forget I can stick pass first-class into a data
14:34:43 <oerjan> mdmkolbe|work: intercalate is it, new in 6.8
14:34:53 <sclv_> ?hoogle intercalate
14:34:53 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
14:34:53 <lambdabot> Data.ByteString.intercalate :: ByteString -> [ByteString] -> ByteString
14:34:53 <lambdabot> Data.ByteString.Char8.intercalate :: ByteString -> [ByteString] -> ByteString
14:34:55 <FunctorSalad> errr
14:35:06 <FunctorSalad> "I forget I can stick first-class functions into a data"
14:35:09 <mdmkolbe|work> thx
14:35:46 <FunctorSalad> (note to self: don't carelessly edit the middle parts of your sentences)
14:36:23 <sclv_> FunctorSalad: and the neat part of that is that laziness can make otherwise very silly patterns pretty efficient.
14:37:12 <sclv_> I.e. instead of a typeclass with three operations of type (a->Something) just make a data type with all three applied.
14:37:27 <sclv_> and only evaluate the ones you need!
14:41:02 <glguy> sclv, I got you mail
14:41:02 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
14:42:33 <sclv_> glguy -- yeah .. just getting ready to take off from work in a few minutes.
14:43:37 <FunctorSalad> why isn't every Enum an Ord?
14:44:10 <TSC> It wouldn't make sense for every Enum
14:44:16 <FunctorSalad> ok, Enum's needn't be Eq's
14:44:37 <TSC> I mean some Enums don't have a "natural" order
14:44:46 <pi3> @src lcm
14:44:46 <lambdabot> lcm _ 0     =  0
14:44:46 <lambdabot> lcm 0 _     =  0
14:44:46 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
14:45:53 <FunctorSalad> TSC: you could just compare two values's position... of course this gets into non-termination waters
14:46:22 <TSC> Yeah, you can give any Enum some arbitrary ordering
14:46:47 <FunctorSalad> it's not arbitrary, it's just ordering after fromEnum
14:47:10 <TSC> I'd say that might be arbitrary too (:
14:47:54 <TSC> But it might not make any sense to say that one value is less than another, so you don't provide the Ord instance
14:48:23 <FunctorSalad> ? a < b = fromEnum a < fromEnum b
14:48:33 <FunctorSalad> what's arbitrary about that?
14:48:50 <TSC> The fromEnum might be arbitrary
14:49:07 <oerjan> > fromEnum 1.0
14:49:09 <FunctorSalad> I realize fromEnum might be extremely slow for some problems
14:49:09 <lambdabot>  1
14:49:14 <oerjan> > fromEnum 1.5
14:49:15 <lambdabot>  1
14:49:35 <FunctorSalad> shouldn't that be injective?
14:49:49 <FunctorSalad> > succ 1.0
14:49:49 <lambdabot>  2.0
14:49:54 <TSC> For example: data Colour = Red | White | Blue | Green | Yellow | Purple
14:49:59 <oerjan> > succ 1.5
14:50:00 <lambdabot>  2.5
14:50:11 <FunctorSalad> that doesn't enumerate all Doubles, does it :)
14:50:13 <TSC> I wouldn't bother giving that an Ord instance, because it's meaningless
14:50:28 <oerjan> but an Enum instance is pretty meaningless too
14:50:38 <matthew-_> @seen dons
14:50:39 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 8m 7s ago.
14:50:48 <TSC> Mmm
14:50:52 <oerjan> > [1.5 ..]
14:50:52 <lambdabot>  [1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5,14.5,15.5,16.5,17.5...
14:51:26 <FunctorSalad> maybe I was thinking too much into Enum. I thought an Enum is essentially a surjective map from the naturals to the type
14:51:40 <FunctorSalad> (or rather, a type that has such a map)
14:51:42 <oerjan> for most Enums it is
14:51:53 <oerjan> but Float and Double are somewhat dubious Enums
14:51:59 <FunctorSalad> agreed
14:52:20 <Cale> Basically, it's something for which list sequence syntax works.
14:52:42 <oerjan> @instances Enum
14:52:43 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
14:52:48 <oerjan> @instances Ord
14:52:48 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
14:53:13 <Jangler> > > (>) > (<)
14:53:14 <lambdabot>   parse error on input `>'
14:53:15 <oerjan> Enum is contained in Ord
14:53:21 <Jangler> rats
14:53:27 <oerjan> in practice
14:53:29 <FunctorSalad> heh
14:54:21 <Jangler> > (>) < (<)
14:54:21 <lambdabot>        add an instance declaration for (Ord (a -> a -> Bool))
14:54:21 <lambdabot>     In the expr...
14:54:30 <Jangler> > GT < EQ
14:54:31 <lambdabot>  False
14:54:31 <FunctorSalad> I'd still say that if the enumeration is surjective, then ordering by number would be a "natural" ordering :)
14:55:03 <oerjan> hm...
14:55:19 <FunctorSalad> hmm maybe not if it fails to be injective
14:55:20 <oerjan> > [(1.0 :+ 0.0) ..]
14:55:20 <lambdabot>   add an instance declaration for (Enum (Complex t))
14:55:21 <lambdabot>     In the expression: [...
14:55:25 <oerjan> bah
15:01:55 <pi3> I just created this function that builds the series between a and b with step s, is it "nice"? I'm just starting to learn Haskell and even though this works it may not be the best way to do it: serie a b s = if a > b then [] else [a] ++ serie (a+s) b s
15:02:33 <mauke> @src enumFromThenTo
15:02:33 <lambdabot> Source not found. I am sorry.
15:02:50 <mauke> pi3: looks ok
15:02:56 <mauke> [a] ++ can be written as a :
15:03:22 <pi3> mauke: is : faster or better in any way?
15:03:30 <mauke> it's more primitive
15:03:36 <mauke> @src (++)
15:03:37 <lambdabot> (++) []     ys = ys
15:03:37 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
15:03:44 <dmwit> Its more idiomatic, too.
15:03:46 <mdmkolbe|work> Is there a funtion for (\f x y -> x <= f && f <= y)?
15:03:49 <pi3> mauke, right
15:04:06 <mauke> @pl (\f x y -> x <= f && f <= y)
15:04:06 <lambdabot> ap (flip . (((.) . (&&)) .) . flip (<=)) (<=)
15:04:20 <mdmkolbe|work> order of arguments doesn't matter to me
15:04:28 <oerjan> mdmkolbe|work: for Ix instances there's inRange
15:04:41 <mdmkolbe|work> @hoogle inRange
15:04:42 <lambdabot> Data.Ix.inRange :: Ix a => (a, a) -> a -> Bool
15:04:42 <lambdabot> Distribution.Version.withinRange :: Version -> VersionRange -> Bool
15:04:45 <dmwit> :t \a b s -> [a, a+s .. b]
15:04:46 <lambdabot> forall t. (Num t, Enum t) => t -> t -> t -> [t]
15:04:51 <Shurique> is it possible to do something like data Foo = Integral a => Bar a String?
15:05:08 <oerjan> it's not quite the same though
15:05:13 <oerjan> hm...
15:05:19 <Shurique> apart from using a function as a constructor
15:05:43 <dmwit> Right, it's different for floating point numbers.
15:06:22 <dmwit> Shurique: Prefer to put constraints on functions rather than data types if at all possible.
15:06:39 <mauke> Shurique: yes
15:06:44 <mauke> that's an existential type
15:06:58 <mauke> dmwit: the constraint is on the constructor, not the type
15:07:17 <dmwit> oh, right
15:07:30 <Shurique> I'll have to read up on that
15:07:32 <Shurique> thanks!
15:09:08 <oerjan> > and . sequence [(>= 1),(<= 10)] $ 5
15:09:11 <lambdabot>  True
15:10:34 <dmwit> > liftM2 (&&) *
15:10:34 <lambdabot>   parse error on input `}'
15:11:04 <dmwit> > liftM2 (&&) (>= 1) (<= 10) 5
15:11:05 <lambdabot>  True
15:12:34 <dmwit> I guess I haven't quite gotten the hang of this keyboard yet. =P
15:13:13 <byte-> hello again.
15:13:28 <dmwit> Hiya, byte-!
15:13:51 <oerjan> > (==[LT,GT]) . mapM compare [1,10] $ 5
15:13:54 <lambdabot>  True
15:14:33 <dmwit> weird
15:14:41 <dmwit> :t mapM
15:14:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:15:04 <byte-> what was the command for point-free conversion?
15:15:05 <byte-> pf?
15:15:11 <dmwit> pl
15:15:11 <oerjan>  @pl
15:15:20 <byte-> what's the l stand for?
15:15:22 <byte-> pointless?
15:15:24 <dmwit> less
15:15:26 <byte-> lol
15:15:30 <EvilTerran> @help pl
15:15:30 <lambdabot> pointless <expr>. Play with pointfree code.
15:15:31 <dmwit> yep =)
15:15:35 <profmakx> pointlol?
15:15:36 <byte-> double entendres ftw.
15:15:40 <EvilTerran> @help unpl
15:15:40 <lambdabot> pointful <expr>. Make code pointier.
15:15:45 <EvilTerran> hehe
15:16:05 <byte-> :pl gcd x y > 1
15:16:11 <byte-> do I need to give it a lambda?
15:16:30 <dmwit> ?pl \x y -> 1
15:16:30 <lambdabot> const (const 1)
15:16:36 <EvilTerran> yes. also need to use @ or ?, not :
15:16:36 <dmwit> yes =)
15:16:42 <byte-> ?pl 1
15:16:42 <lambdabot> 1
15:16:47 <byte-> ?pl x
15:16:47 <lambdabot> x
15:16:50 <byte-> ok.
15:16:58 <EvilTerran> @unpl ((>1).) . gcd
15:16:58 <lambdabot> (\ e h -> (gcd e h) > 1)
15:17:02 <byte-> @pl \x y -> gcd x y > 1
15:17:02 <lambdabot> flip flip 1 . ((>) .) . gcd
15:17:09 <oerjan> well mostly.  it does a few simplifications even without a lambda
15:17:14 <dmwit> Non-functions are already point-free.
15:17:20 <oerjan> @pl map f . map g
15:17:20 <lambdabot> map (f . g)
15:17:27 <EvilTerran> I suspect you want mine
15:17:49 <byte-> probably.
15:17:55 <byte-> I was just curious.
15:18:00 <byte-> I wouldn't use that in actual code, anyway.
15:18:02 <oerjan> > nubBy (((>1).).gcd) [2..]
15:18:03 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
15:18:58 <byte-> > nubBy (\x y -> gcd x y /= 1) [1..]
15:18:58 <lambdabot>  [1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,10...
15:19:16 <byte-> cool, it is a list of primes.
15:19:31 <EvilTerran> > nubBy (((==0).).flip mod) [2..] -- performs better
15:19:31 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
15:20:10 <dmwit> Its performance still sucks, though. ;-)
15:20:10 <EvilTerran> > nubBy (\x y -> y `mod` x == 0) [2..] -- equivalent
15:20:11 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
15:20:29 <EvilTerran> dmwit, well, as naive haskell versions go, it does remarkably well
15:20:37 <dmwit> yeah
15:20:54 <EvilTerran> @src nubBy
15:20:55 <lambdabot> nubBy eq []             =  []
15:20:55 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
15:23:00 <byte-> @unpl \x -> (not . eq x)
15:23:00 <lambdabot> \ x c -> not (eq x c)
15:23:13 <EvilTerran> @pl \x -> (not . eq x)
15:23:14 <lambdabot> (not .) . eq
15:23:18 <byte-> @unpl (not . eq x)
15:23:18 <lambdabot> (\ c -> not (eq x c))
15:23:59 <EvilTerran> incidentally, it's fairly common to have (f .: g) x y = f (g x y)
15:24:13 <EvilTerran> to make writing pointsfree easier
15:24:23 <byte-> you shouldn't really have to.
15:24:38 <byte-> the fact that you do shows the shortcomings of this notation.
15:25:14 <byte-> also, I just found out that Control.Arrow's >>> is the same as F#'s |>
15:25:21 <byte-> |> = flip (.)
15:25:26 <oerjan> @unpl (.f) . g
15:25:27 <lambdabot> (\ d i -> g d (f i))
15:25:28 <byte-> oops, that doesn't seem right.
15:25:44 <dibblego> I use |> in Scala as an alias for map
15:25:49 <glguy> but that's only for one instance of Array
15:25:52 <glguy> arrow..
15:25:54 <byte-> x |> f = f x
15:26:06 <byte-> what would that be in pl...
15:26:17 <oerjan> flip id
15:26:17 <byte-> oh wait, lol
15:26:23 <byte-> @pl \x f = f x
15:26:23 <lambdabot> (line 1, column 6):
15:26:24 <lambdabot> unexpected "="
15:26:24 <lambdabot> expecting pattern or "->"
15:26:28 <byte-> @pl \x f -> f x
15:26:29 <lambdabot> flip id
15:26:42 <byte-> can lambdabot evaluate expressions?
15:26:44 <byte-> @help
15:26:44 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:26:53 <dons> byte-: yeah
15:26:58 <byte-> I don't feel comfortable exploring this interface in public...
15:27:00 <dons> > map (^2) [1..]
15:27:01 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
15:27:04 <mux> > fix ((1:) . scanl (+) 1)
15:27:04 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
15:27:07 <byte-> every time something goes wrong I look like a noob :/
15:27:09 <dons> byte-:  you can query it in a privmsg
15:27:10 <byte-> oh yeah.
15:27:12 <byte-> I already used it :/
15:27:19 <FunctorSalad> byte-: you can query her
15:27:21 <byte-> @src id
15:27:21 <lambdabot> id x = x
15:27:27 <byte-> @src flip
15:27:28 <lambdabot> flip f x y = f y x
15:27:36 <byte-> ah, I see.
15:29:19 <byte-> hmm... if women took over the geek profession instead of guys 50 years ago
15:29:26 <byte-> do you think they'd be naming all their bots "guys"?
15:29:55 * Japsu just uses "it"
15:30:12 <byte-> @src ($)
15:30:12 <lambdabot> f $ x = f x
15:30:35 <LoganCapaldo> geek is a profession now? where do i sign up?
15:30:38 <Pseudonym> Ah, good to see the real lambdabot back.
15:30:52 <Pseudonym> I think "the geek professions" is more accurate.
15:31:00 <Pseudonym> But even then, women have taken over some of them.
15:31:07 <Pseudonym> I see more female librarians, for example./
15:31:08 <byte-> it's sort of a moot point...
15:34:41 <FunctorSalad> @vixen are you a woman or a man?
15:34:41 <lambdabot> of course i'm female
15:34:49 <FunctorSalad> you see, Japsu ;)
15:34:50 <oerjan> > on
15:34:50 <lambdabot>   Not in scope: `on'
15:35:06 <oerjan> @let on (+) f x y = f x + f y
15:35:07 <Japsu> FunctorSalad: lol
15:35:08 <lambdabot> Defined.
15:38:47 <oerjan> > ((/=) `on` compare 5) 1 10
15:38:47 <lambdabot>  True
15:40:17 <oerjan> mdmkolbe|work: ^^
15:40:37 <byte-> :type on
15:40:47 <byte-> oh.
15:40:50 <oerjan> i just defined on
15:40:53 <byte-> heh, just got back.
15:40:55 <byte-> I notice that now.
15:41:03 <oerjan> it's only in 6.8 which lambdabot doesn't have yet
15:41:21 <hpaste>  yoshi pasted "Evaluating Derivatives" at http://hpaste.org/4784
15:41:47 <byte-> why did you hardcode that function in there?
15:42:33 <byte-> that definition only accepts the + function as its first argument, doesn't it?
15:42:37 <oerjan> nope
15:42:39 <byte-> I don't understand how that's working...
15:42:48 <Pseudonym> I want my Debian-packaged GHC 6.8, dammit!
15:42:52 <oerjan> in haskell even operators can be redefined
15:43:04 <oerjan> and used as arguments
15:43:10 <byte-> duh.
15:43:13 <byte-> that's not what I asked :P
15:43:29 <byte-> you're defining 'on' to accept 4 parameters
15:43:29 <hpaste>  ArcSin_ pasted "Evaluating Derivatives" at http://hpaste.org/4785
15:43:34 <byte-> with the first one matching (+)
15:43:37 <EvilTerran> on op f x y = f x `op` f y
15:43:39 <oerjan> i mean the + in the definition has nothing to do with the usual +
15:43:43 <EvilTerran> (+) is lower-case
15:43:51 <dons> Pseudonym: didn't you get the memo?
15:43:54 <EvilTerran> (:+), say, would be upper-case
15:43:55 <dons> it's done!
15:44:00 <byte-> lowercase?
15:44:01 * mux teases Pseudonym by using Data.Function
15:44:07 <Pseudonym> Oooh!
15:44:11 <mauke> byte-: meaning it's a variable, not a constant
15:44:17 <Pseudonym> mux: I'm not 6.8-less.  I do have... Windows.
15:44:17 <byte-> I got that part..
15:44:21 <Pseudonym> No, I didn't get the memo.
15:44:22 <dons> an email an hour or so, Magnus Therning
15:44:23 * Pseudonym looks
15:44:25 <mux> Pseudonym: heh.
15:44:25 <Pseudonym> Aha!
15:44:29 <Pseudonym> Haven't checked the mail yet.
15:44:29 <byte-> I wasn't aware there was a lowercase + in ascii.
15:44:31 <EvilTerran> symbol identifiers starting with a : are allowed in the same contexts alphanumeric ones are starting with a capital latter
15:44:32 <hpaste>  (anonymous) annotated "Evaluating Derivatives" with "(no title)" at http://hpaste.org/4784#a1
15:44:35 <thetallguy> Pseudonym: http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html
15:44:36 <lambdabot> Title: Haskell Unsafe
15:44:39 <Pseudonym> Thanks!
15:44:44 * Pseudonym gets to it
15:45:02 <EvilTerran> those without are allowed in the same contexts an alphanumeric one starting with a lower-case letter are
15:45:19 <EvilTerran> hence, in haskell, : is uppercase, and all other punctuation is lowercase. :)
15:45:58 <byte-> wow...that's rather counterintuitive.
15:46:05 <byte-> interesting, though.
15:46:08 <EvilTerran> as mauke says, this means that, say, constructors and class names can by symbolic, but only if they start with a :
15:46:28 <EvilTerran> but symbolic names that don't start with a : are variables (or type variables)
15:46:31 <FunctorSalad> @type on
15:46:32 <lambdabot> Not in scope: `on'
15:46:37 <FunctorSalad> where's it gone?
15:46:38 <mauke> type variables are variables
15:46:49 <oerjan> FunctorSalad: @type doesn't know about @let
15:46:56 <FunctorSalad> oh :)
15:46:57 <EvilTerran> mauke, i know that, i was just drawing attention to it as a reminder.
15:47:16 <EvilTerran> ?type (***)
15:47:17 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:47:37 <FunctorSalad> > ((==) `on` fst ) (1,2) (1,3)
15:47:38 <lambdabot>  True
15:47:55 <byte-> anyway.
15:47:56 <FunctorSalad> so it did generalize to other first arguments :)
15:47:58 <EvilTerran> (Arrow (~>)) => (b ~> c) -> (b' ~> c') -> ((b,b') ~> (c,c'))
15:48:10 <byte-> the point is, you deserve to be slain by dracula if you use + as a variable name...
15:48:22 <EvilTerran> i disagree
15:48:25 <mauke> byte-: the Prelude also does that
15:48:31 <oerjan> byte-: but i'm using it to represent an operator
15:48:36 <alexj> is ByteString.Lazy.lines supposed to be strict?
15:48:41 <EvilTerran> you have to be aware of it, but once you are, it's pretty easy to work with
15:48:46 <byte-> oerjan, `op`
15:48:50 <FunctorSalad> do ***, &&& and ||| slow things down because of the Arrow stuff?
15:49:04 <FunctorSalad> or is this compile-time
15:49:24 <dons> alexj: hmm.
15:49:25 <EvilTerran> altho i tend to say such things as "on (??) f x y = f x ?? f y" rather than re-use an established operator, there's no harm in it
15:49:41 <byte-> EvilTerran, that's better.
15:49:44 <dons> alexj: how strict?
15:49:47 <EvilTerran> it's no worse than shadowing an alphanumeric name that's already in scope
15:49:47 <byte-> I could probably figure that out.
15:49:47 <FunctorSalad> in other words, is (+2) &&& (+3) just as fast as \x -> (x+2, x+3)
15:50:06 <oerjan> byte-: ok i probably wouldn't have used + if it had been more than a quick throwaway definition
15:50:24 <dons> alexj: oh, it does look a little strict...
15:50:25 <oerjan> but i couldn't be bothered to think of a better name
15:50:30 <byte-> @t >>>
15:50:31 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
15:50:37 <byte-> @t (>>>)
15:50:38 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
15:50:39 <conal> FunctorSalad: the former probably gets rewritten to the latter by ghc -O.  you could ask on #ghc to make sure.
15:50:40 <alexj> dons:  head $ L.lines $ L.append (L.pack "a\nb\n") (error  "abc")
15:50:41 <byte-> ...
15:50:44 <byte-> :t (>>>)
15:50:44 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
15:50:54 <FunctorSalad> conal: thanks
15:50:54 <dons> byte-: try querying the bot in privmsg perhaps?
15:51:18 <FunctorSalad>  /me likes likes the tupling operators :)
15:51:22 <dons> alexj: yeah, there's no strictness proprety testing unfortunately. we have a framework for it, but not for bytestrings, so looks like that slipped through
15:51:30 <conal> FunctorSalad: in fact, "+" is overloaded also, so a similar question holds about "x+2" and "x+3".
15:51:34 <FunctorSalad> too bad you often have to uncurry and re-curry things first
15:51:50 <ArcSin_> I have a question about Evaluating Derivatives http://www.hpaste.org/4785, can anyone out there help a fellow Haskeller
15:51:53 <alexj> dons: can you give me a lazy version I can use now?
15:52:05 <EvilTerran> i might use (+) or (*) to indicate that the function is meant to be associative and commutative
15:52:18 <alexj> dons: can you give me a lazy version I can use now?  I've just spent a couple of hours "discovering" this bug.
15:52:26 <dons> alexj: i'd have to write it from scratch
15:52:43 <alexj> is it a quickie?
15:52:43 <FunctorSalad> conal: I suppose annotating things with Int would be the safe way
15:52:45 <dons> but you could do it by just porting Data.List.lines to lazy bytestrings
15:52:47 <dons> that should be lazy enough
15:52:51 * dons tries...
15:52:52 <EvilTerran> > (\(+) 0 x y -> x + 0 + y) (++) [] [1,2] [3,4]
15:52:53 <lambdabot>   add an instance declaration for (Num [a])
15:53:03 <EvilTerran> hm
15:53:10 <mauke> 0 is not a variable
15:53:13 <EvilTerran> bah.
15:53:38 <conal> ArcSin_: is your question how to parse more context expressions than "3" or "2x"?
15:53:53 <dons> alexj: should have one ready in 15 mins or so
15:53:54 <ArcSin_> conal: correct
15:54:05 <conal> ArcSin_: use Parsec
15:54:13 <alexj> dons: ok standing by.
15:54:38 <conal> ArcSin_: or another parser tool.  Parsec is a pretty popular one.
15:55:26 <ArcSin_> Conal:  there is nothing in the Parsec library for something of :: String -> Expr
15:55:41 <ArcSin_> Expr has been created
15:58:57 <oerjan> ArcSin_: in Parsec you define yourself what types to return, and how to combine subexpressions.  take a look at the example with buildExpressionParser
16:00:23 <oerjan> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#Expressions
16:00:27 <lambdabot> http://tinyurl.com/2p5p89
16:01:21 <hpaste>  dons pasted "lazy bytestring liens" at http://hpaste.org/4786
16:01:29 <dons> alexj: your dinner is served ^
16:03:11 <mauke> is it really true there are elephants and liens too in piccadilly circus?
16:03:59 <oerjan> mauke: no.
16:04:13 <oerjan> if there were, google would have given a hit on it.
16:04:19 <dmwit> liens are hueg like xbox
16:04:31 <ArcSin_> oerjan: Thanks!! doing this without examples was impossible
16:04:38 <mauke> Jethro Tull - Mother Goose
16:07:55 <alexj> dons: thanks.
16:08:06 <dons> alexj: let me know if that's suitable
16:08:18 <alexj> testing now (building a proxy server for happs)
16:08:26 <dons> alexj: i was 7 minutes early :)
16:08:32 <Pseudonym> Ian Anderson got an honour this year.
16:08:33 <alexj> dons: heh
16:08:50 <Pseudonym> So that's Jethro Tull OBE to you, thankyou very much.
16:08:57 <dons> if only i always got code written 50% faster than i planned
16:09:18 * Pseudonym assumes it was the same Ian Anderson, anyway
16:09:18 <alexj> dons: yay it works!
16:09:22 <dmwit> You would soon plan on that boost. =)
16:09:27 <alexj> happs now has prxy server code!
16:09:35 <dons> awesome.
16:09:38 <Pseudonym> happs++
16:09:43 <alexj> happs now has a bytestring http client.
16:09:53 <dons> oh, that's sweet
16:09:54 <alexj> not in the repo yet, but coded.
16:10:06 <dons> i might know some people who'd like to steal that code
16:10:34 <alexj> if they'll maintain it, they can have it!
16:10:48 <alexj> will be in the repo in the next 24 hours or so.
16:11:48 <dons> ok. great
16:12:26 <davidL> Will there be an official happs release any time soon?
16:12:43 <alexj> davidL yes concurrent witha new happs homepage.
16:12:52 <alexj> all in the next couple of days.
16:13:01 <alexj> homepage preview is at http://happs.org/index2.html
16:13:11 <davidL> nice!
16:14:21 <keseldude> wow that looks great!
16:15:21 <dons> alexj: maybe an 'About'? saying who's working on what?
16:17:47 <Cin> if i have 'Data A = X Int | Y Int', is it possible to match, in one pattern, either X or Y to extract the Int?
16:17:53 <Cin> er, 'data'
16:18:19 <mauke> no
16:18:38 <dons> only by match both constructors
16:18:50 <Cin> ah well
16:18:57 <dons> you could change the type to: data A = A Tag Int
16:19:02 <dons> data Tag = X | Y
16:19:10 <dons> to share the common field
16:19:17 <Igloo> Or data A = X { i :: Int } | Y { i :: Int }
16:19:38 <dons> oh, now that's curious..
16:19:44 <dons> does that really work?
16:19:55 <chadz> looks proper
16:20:04 <mauke> looks like a redefinition of i
16:20:17 <Igloo> It does work
16:20:17 <chadz> oh, that's true.
16:20:24 <dons> *M> :t i
16:20:24 <Leimy> hmmm, yi is seriously neat :-)
16:20:25 <dons> i :: A -> Int
16:20:47 <dons> *M> map i [Y 2, X 1]
16:20:47 <dons> [2,1]
16:20:55 <chadz> will it resolve as A -> Int, or choke on the X/Y?
16:21:00 <dons> Igloo: that's the record system hack of the year...
16:21:14 <byte-> dons, meh, not really.
16:21:15 <Igloo> That's not a hack, that's just how it works!
16:21:20 <byte-> you could accomplish the same thing without records.
16:21:31 <byte-> i (A x) = x
16:21:34 * LoganCapaldo dies of shock
16:21:38 <byte-> oops
16:21:41 <byte-> i (X a) = a
16:21:43 <LoganCapaldo> dons didn't knw that worked and I did?
16:21:44 <byte-> i (Y a) = a
16:22:05 * LoganCapaldo checks the temparature of hell ;)
16:22:44 <byte-> the problem is that, either way, you can't pattern match on it anymore.
16:23:14 <byte-> does haskell at least let you double up patterns in case statements?
16:23:23 <Igloo> You can still pattern match it, but if you just wanted to extract the Int then you wouldn't want to
16:23:29 <oerjan> because there's no way to match on a field without also matching the data constructor :(
16:23:44 <Pseudonym> dons only writes good code, not hacks.
16:23:55 <Pseudonym> He shields his pure eyes from such awfulness.
16:23:56 <mauke> byte-: no
16:24:07 <LoganCapaldo> lol
16:24:07 <EvilTerran> byte-, no; you can achieve the same effect with an extra function, tho
16:24:08 <byte-> hmm... odd.
16:24:11 <byte-> OCaml lets you do that.
16:24:21 <byte-> I suppose.
16:24:31 <byte-> but then you have to repeat code.
16:24:37 <EvilTerran> case ... of {X a -> xy a; Y a -> xy a; ...} where xy = ...
16:24:56 <EvilTerran> not particularly repetetive
16:25:57 <byte-> you don't need the 'xy' in that case.
16:26:03 <mauke> it gets worse with more variables and more code around it
16:26:11 <byte-> since 'a' is the value you're looking for.
16:26:53 <EvilTerran> what
16:26:53 <byte-> I've actually used that a few times in F#.
16:26:58 <byte-> can't believe haskell doesn't implement that.
16:27:07 <EvilTerran> I have no idea what you're talking about
16:27:30 <byte-> You've already extracted the value you want when you pattern match.
16:27:38 <byte-> thus you don't need 'xy'
16:27:40 <EvilTerran> the point is, instead of writing the body of the block that uses a twice, you make it a function in the where{} clause
16:27:56 <byte-> ohh.
16:28:03 <byte-> lol, I completely missed that.
16:28:07 <EvilTerran> so i see
16:28:14 <chadz> noob
16:28:16 <dmwit> Or you write 'i' from above, then use xy . i
16:28:23 <LoganCapaldo> no one suspects the butterfly
16:28:34 <EvilTerran> indeed
16:28:44 <oerjan> dmwit: that won't work if there are more cases
16:28:46 <EvilTerran> or you break out Data.Generics and do something horrible
16:29:16 <Pseudonym> BTW, Haskell programmers also use views in this situation.
16:29:22 <LoganCapaldo> s/horrible/awesome/
16:29:38 <byte-> explain this "view."
16:29:40 <oerjan> LoganCapaldo: those are not contradictory :D
16:29:47 * LoganCapaldo has never actaully used Data.Generics
16:29:53 <Pseudonym> @wiki Concrete_view
16:29:53 <lambdabot> http://www.haskell.org/haskellwiki/Concrete_view
16:30:21 <Pseudonym> That's especially useful if you're likely to reuse the pattern match.
16:30:34 <dons> Igloo:  yeah, but that's a moderately obscure corner of the record system :)
16:31:14 <hpaste>  dons pasted "backspace" at http://hpaste.org/4787
16:31:59 <EvilTerran> mapFirstConstrParam :: GenericT -> GenericT, or something
16:33:09 <EvilTerran> (ie :: (forall a . Data a => a -> a) -> (forall a . Data a => a -> a))
16:33:40 <araujo> hello!
16:33:58 <dons> ?users
16:33:58 <lambdabot> Maximum users seen in #haskell: 425, currently: 412 (96.9%), active: 18 (4.4%)
16:34:11 <araujo> happy new year
16:36:05 <_andre> does anyone know if there's any library for event-based programming in haskell (libevent style)?
16:36:14 <dcoutts> @seen bos
16:36:14 <lambdabot> I saw bos leaving #ghc and #haskell 1m 13s ago, and .
16:37:12 <dons> _andre: there's a binding to libevent , iirc
16:37:24 <dons> or perhaps you can just use haskell threads and threadWait stuff
16:37:31 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/codec-libevent-0.1 ?
16:37:32 <lambdabot> http://tinyurl.com/3ck9yg
16:37:55 <byte-> http://test.com/
16:37:55 <lambdabot> Title: Test.com Web Based Testing Software
16:38:04 <byte-> eh?
16:38:06 <dons> dcoutts: note all of Adam Langley's stuff depending on binary and binary-strict
16:38:11 <byte-> it didn't give me a tinyurl?
16:38:20 <dcoutts> dons: like what?
16:38:32 <dons> like the above libevent stuff
16:38:34 <byte-> ohhhh...
16:38:40 <oerjan> byte-: it was already tiny enough :)
16:38:45 <dons> for some low level things, Get on a single strict buffer is easier
16:38:46 <byte-> wow, that's really cool... it looks at the length of the URL.
16:38:47 <dcoutts> dons: and the strict is just a different representation for lists right?
16:39:00 <dons> it is just Get on a strict buffer
16:39:09 <_andre> dons: i saw that one but it's not a binding to the libevent api
16:39:12 <dcoutts> dons: what does he want that for?
16:39:12 <dons> http://hackage.haskell.org/packages/archive/binary-strict/0.1/doc/html/Data-Binary-Strict-Get.html
16:39:13 <lambdabot> http://tinyurl.com/2qr7s3
16:39:29 <dons> dcoutts: i guess he has scenarios where he needs to parse data not in a lazy bytestring
16:39:35 <dons> low level buffers, i guess
16:39:49 <dcoutts> dons: but a strict bytestring is a lazy one with one chunk, I thought it was more than that
16:40:05 <dons> looks like that's all it is (?)
16:40:14 <dons> _andre: what requirements do you have?
16:40:56 <_andre> something that would run a callback function when some event occurs in a file descriptor
16:41:06 <dcoutts> dons: well if that's all it is it's silly, I'd need to re-read the emails he sent us but I'm convinced there's more to it
16:41:08 <dons> ah ok. so threadWaitFd would work for that
16:41:24 <dons> dcoutts: ok. maybe there is . binary-strict doesn't seem to have more to it though, afaik
16:41:26 <_andre> i'll have a look, thanks :)
16:41:40 <dons> _andre: so fork a haskell lightweight thread with a callback function, and have it wait on the fd
16:41:57 <dons>         threadWaitRead,         -- :: Int -> IO ()
16:41:59 <dons>         threadWaitWrite,        -- :: Int -> IO ()
16:42:06 <dons> in Control.Concurrent
16:42:40 <_andre> thanks!
16:43:47 <dcoutts> dons: we should check what it's really for, since if all he wants is to go to and from a strict bytestring then that's trivial
16:44:12 <dcoutts> just make a single chunk lazy bytestring, and for the put side, just concat all the chunks together
16:44:38 <dcoutts> it's a one liner for each of get/put and with no effeciency loss
16:44:45 <dons> yeah
16:45:07 <dons> btw, did you see above alexj's bug report about Lazy.lines being fully strict
16:45:22 <dons> or too strict, at least.
16:46:36 <alexj> dons: you said something about else wanting to take over all the HAppS http code..
16:47:07 <alexj> we are about to do a repo refactor but if the HTTP code moves to some other project ... then we will organize that way.
16:47:09 <dons> well, there's a project here for a bytestring http layer
16:47:29 <alexj> not sure what that means?
16:47:34 <dons> it seems sensible for the http layer to be a standalone library
16:47:39 <dons> for bytestring http
16:49:15 <alexj> yeah, we are about to rename happs.server to happs.http because it now encompasses both sides.
16:50:01 <dcoutts> dons, alexj: lines too strict? how?
16:50:18 <dcoutts> is this about lines that span chunk boundaries?
16:50:35 <alexj> I didn't read the code.
16:50:38 <dons> no, i don't think so. its just chunkwise-strict, isn't it?
16:50:51 <dcoutts> I don't know what that means
16:50:57 <alexj> dcoutts: head $ L.lines $ L.append (L.pack "a\nb\n") (error "abc")
16:51:11 <alexj> should not produce an error
16:51:25 <dons> its stricter than list there, anyway
16:51:49 <dcoutts> alexj: is that just because L.append is too strict? what version of bytestring are you using?
16:51:58 <Pseudonym> I'm editing the wiki, and I want to check this before it goes on.
16:52:06 <Pseudonym> Concrete views are codata, right?
16:52:10 <dons> hmm. if you rewrite lines to use break and tail, it works
16:52:12 <dons> ?src lines
16:52:13 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:52:25 <dons> http://hpaste.org/4786 like that
16:52:37 <dcoutts> it's a lot slower though
16:52:39 <dons> the go loops in the Lazy.Char8 lines look too eager
16:52:42 <dons> yeah
16:52:45 <Nafai> lambdabot: Sheesh, his name is don, not dave!
16:52:46 <Nafai> :)
16:53:17 <lambdabot> This is highly irregular.
16:59:13 <dcoutts> dons: I'm testing a hunch
16:59:39 <dons> we do need some strict check in there before 1.0
17:04:00 <justinhj> evening
17:04:38 <justinhj> I've just installed GLFW-01 on ghc 6.8.2 and i'm getting an error when loading
17:04:40 <justinhj> Loading package GLFW-0.1 ... : panic! (the 'impossible' happened)
17:04:40 <justinhj>   (GHC version 6.8.2 for i386-unknown-mingw32):
17:04:40 <justinhj> 	loadObj: failed
17:04:42 <justinhj>  
17:05:01 <mauke> yay, compiler bug
17:05:16 <Leimy> The impossible rules!
17:05:26 <justinhj> heh
17:05:39 <Leimy> me fail english, that's unpossible
17:05:52 <dcoutts> dons: fixed it
17:06:13 <dcoutts> dons: delete the STRICT2/3 macros in lines, they're forcing the tail
17:06:16 <justinhj> this is through ghci, i'll try just ghc
17:06:35 <dcoutts> dons: at most, only the current chunk and accumulation list should be strict
17:06:39 <Leimy> dons: you have 2 months of C/C++ coding experience on your ohloh profile?
17:06:49 <Leimy> because xmonad is primarilly C/C++ ???
17:06:56 <Leimy> that's *super* :-)
17:07:04 <mauke> xmonad is 100% Haskell
17:07:08 <Leimy> I know
17:07:13 <Leimy> I'm reading the ohloh.net website
17:07:21 <Leimy> http://www.ohloh.net/projects/6869?p=xmonad
17:07:22 <lambdabot> Title: xmonad - Ohloh
17:07:24 <Pseudonym> Leimy: Anyone who uses the phrase "C/C++" doesn't know C++.
17:07:30 <Leimy> Indeed
17:07:37 <mauke> (or C)
17:07:42 <Leimy> or /
17:07:51 <Pseudonym> Certainly not the latest C.
17:08:00 <mauke> on the other hand, I've written a C/C++ interpreter in Haskell :-)
17:08:08 <Pseudonym> Yeah.  Never hire such a person to program in PL/I or A/PL.
17:08:08 <Leimy> heh
17:08:21 <Leimy> COBOL FTW!
17:08:34 <Pseudonym> COBOL is okay.  No slashes.
17:08:42 <Leimy> heh
17:08:45 <Pseudonym> CO SLASH BOL
17:08:59 <mauke> C/C++ needs a better website
17:09:30 <Pseudonym> You try getting a domain name with a slash in the middle.
17:10:08 <cjb> easy.
17:10:18 <dons> Leimy: heh ohloh actually thinks xmonad's .cabal file is C/C++
17:10:28 <mauke> what the
17:10:30 <dons> so it tracks my 2 month's experience committing to .cabal files :)
17:10:38 <dons> and it ignores all the .hs
17:10:42 <loupgaroublond> last year i saw an ad on craigs list for an APL programmer in NYC, for a start up no less
17:10:50 <dons> dcoutts: do we need any strictness there?
17:10:52 <mauke> someone checking for isInfixOf ".c"?
17:11:02 <dons> something like that. pretty stupid
17:11:06 <dcoutts> dons: probably not
17:11:08 <dons> i put in a request for haskell parsing
17:11:30 <Leimy> dons they even have "haskell" as an oholoh language
17:11:45 <dons> oh??
17:11:53 <dons> they didn't 2 weeks ago
17:11:58 <Leimy> or I swear they did before
17:12:01 <Leimy> wow
17:12:12 <Leimy> ok that must be the hops clogging my neural pathways again.
17:12:17 <dons> i don't see it on the languages page
17:12:20 <dcoutts> dons: sending a patch...
17:12:21 <dons> http://www.ohloh.net/languages
17:12:22 <lambdabot> Title: Programming Languages - Ohloh
17:12:38 <Leimy> yeah, no haskell, but they have DOS Batch Scripts
17:12:41 <Leimy> because... yeah
17:12:47 <dons> yeah.
17:12:59 <dons> they're web dev people :)
17:13:21 <Leimy> apparently
17:13:34 <dons> also, they only accept svn and git
17:13:40 <dons> so you have to convert darcs repos to get stats
17:13:43 <Leimy> I saw that... how weak.
17:13:51 <dons> but then, of course, it won't analyse commits to files with .hs in the name
17:14:00 <dons> it might change --they're going to open source their parser
17:14:08 <Leimy> oh that'd be nice
17:14:16 <Leimy> They should write their parser in haskell
17:14:21 <Leimy> and then still not support haskell
17:14:24 <Leimy> that'd be awesome
17:14:36 <dolio> Heh, HTML.
17:15:04 <Leimy> oh well... time to drink beer and throw a heavy ball down a greasy lane at some white rednecks
17:16:05 <dcoutts> dons: sent, I cannot apply since I'm not on my normal box and am without my darcs.h.o ssh keys
17:16:19 <dons> oh ok. sent to me?
17:16:23 <dcoutts> dons: yes
17:16:29 <dons> cheers
17:17:04 <dons> i like the new fine grained package breakup.
17:17:07 * EvilTerran idly wonders if Leimy has a rug that really ties the room together
17:17:08 <dons> point releases are cheaper
17:17:46 <justinhj> hmmm. so at the command line everything is fine. ghc compiles and runs my program. but with ghci i get the error i posted above
17:18:34 <dcoutts> dons: I've not modified the notes you added about it being too strict, I'll let you test it and you can remove the comments
17:18:41 <cjb> EvilTerran: I always wondered -- why didn't he just get the rug dry-cleaned?
17:18:43 <dons> will do.
17:18:50 <cjb> it would've saved, like, a lot of effort.
17:19:02 <dcoutts> dons: you're quite right, we need to test strictness and see if all those STRICT annotations are all necessary
17:19:17 <dons> yep. ghc's smarter than it used to be.
17:19:22 <EvilTerran> eh. the plot isn't particularly relevant to that particular film as a whole
17:19:24 <dcoutts> dons: we were too liberal with them, since we did not have convenient ! patterns
17:19:30 <dons> yeah.
17:19:44 <dcoutts> dons: and I made the representation stricter so it's more important now
17:20:03 <dcoutts> dons: I bet that error did not happen with the [Strict.ByteString] rep
17:20:26 <EvilTerran> maybe he didn't like the concept of continuing to use that rug, even tho he knew intellectually it could be cleaned
17:20:29 <dons> dcoutts: ah
17:20:42 <dcoutts> dons: since forcing the tail used to do nothing since the list is lazy in it's elements, but now forcing the list forces the first chunk
17:20:51 <EvilTerran> the thought could still make him squeamish
17:21:05 <dons> strictness properties are a hair ball
17:21:31 <EvilTerran> cjb, or maybe he spent far too much of his life rotting his brain on drink and weed, and didn't think of it. who knows, eh. :)
17:21:37 <dons> we need a better story for specifying them, and encouraging people to think about them (particularly lib authors of mixed lazy/strict structures :)
17:22:12 <dcoutts> dons: I think StrictCheck was great, it found loads of bugs in the list re-impl
17:22:33 <dcoutts> we need to publish it and/or integrate it with SmallCheck
17:22:55 <dons> yes.
17:27:18 <oerjan> > 'N' :( 'o' :) " worries"
17:27:19 <lambdabot>  "No worries"
17:38:49 <LoganCapaldo> @remember oerjan 'N' :( 'o' :) " worries"
17:38:49 <lambdabot> It is stored.
17:40:28 <byte-> :t (:()
17:40:30 <lambdabot> parse error (possibly incorrect indentation)
17:40:37 <byte-> ah
17:40:54 <byte-> heh, nice, oerjan.
17:41:00 <byte-> took me a second to figure out how you managed that.
17:44:14 <wolverian> huh. building ghc-6.8.2 myself on ubuntu 7.10 gave me no docs in $PREFIX/share/doc/ghc/libraries
17:44:21 <wolverian> all the directories are there, but they only have LICENSE files
17:44:34 <wolverian> make install-docs explicitly didn't help
17:46:28 <drtomc> Hi all! A quick Qn: I have 4 Maps which I wish to union. The function unions works, but is not so efficient as I'd like - I know that all the keys in the first map are less than all the keys in the second map, etc. Is there are more efficient way?
17:48:11 <wolverian> I'll try a new haddock from darcs
17:49:47 <Saizan> drtomc: you could try with fromDistinctAscList $ map toAscList maps
17:49:53 <scook0> drtomc: fromAscList . concatMap toAscList perhaps?
17:50:17 <scook0> should be O(n)
17:50:32 <Saizan> if you use fromDistinctAscList yeah
17:50:53 <drtomc> Right - though the constant factors will be bad. I have code somewhere for AVL trees which have a join operation which is O(log n).
17:51:13 <drtomc> I was wondering if there was something similar for map.
17:51:32 <wolverian> when installing haddock, it can't find alex, but it is installed in /usr/bin/alex. any hints?
17:52:49 <wolverian> I'm using ghc under ~, while alex is in /usr/bin. could this have an effect?
17:53:26 <wolverian> dammit, I'll just download the html docs manually
17:54:33 <hpaste>  (anonymous) annotated "backspace" with "(no title)" at http://hpaste.org/4787#a1
17:55:02 <EvilTerran> wait what
18:01:04 <ramza3> What unicode library should I use; seems like there a couple to choose from.  Right now I am reading Java class files, but ideally would only want to use Unicode UTF-8.  And I am using the Data.Binary library to read the integer values of the file
18:02:42 <jsnx> ramza3: well, there's utf8-simple
18:03:49 <ramza3> jsnx, this one? http://code.haskell.org/utf8-string/
18:03:50 <lambdabot> Title: Index of /utf8-string
18:05:09 <ramza3> jsnx, google search comes up with 48 results; sounds good to me
18:13:04 <BMeph> Heh, heh, Mozilla Firefox: "written in JavaScript"... ;)
18:34:41 <pi3> what do you think about using a different background color for the odd rows in hpaste?
18:35:17 <tlaboc> seems like it would be easier to read
18:36:23 <pi3> ping glguy
18:36:28 <twanvl> yuck, I think it would just be distracting
18:37:08 <tlaboc> maybe it could be toggle-able, like lines #s
18:41:01 <hpaste>  ramza3 pasted "Should be the same type?" at http://hpaste.org/4788
18:41:28 <ramza3> I am trying to read this ByteString from Data.Lazy.ByteString but apparently is conflicting with the same type?
18:42:23 <oerjan> ramza3: lazy and strict ByteStrings are different
18:42:34 <ramza3> dang it
18:42:34 <oerjan> but have the same name
18:42:44 <ramza3> is there a way to convert them
18:44:54 <oerjan> ramza3: there's unpack in Lazy too
18:45:57 <oerjan> just move the import
18:46:09 <oerjan> (i hope)
18:48:11 <drtomc> ramza3: You could qualify the import (e.g import Data.ByteString.Lazy as Lazy).
18:50:59 <ramza3> drtomc: thanks, I did the following: import Data.ByteString.Lazy as Lazy (ByteString, unpack)
18:52:25 <wolverian> I'm trying to build my own cabalised app. the build fails because ghc can't find Data.Array, because array-0.1.0.0 is hidden. however, it is _not_ hidden according to ~/bin/ghc-pkg. any hints?
18:53:19 <wolverian> (this is with ghc 6.8.2)
18:53:48 <wolverian> oh, wait, perhaps I should mention that dependency in the .cabal file ;)
18:54:42 <conal> wolverian: yes.  because cabal auto-hides all packages.
18:55:15 <conal> wolverian: and then explicitly unhides the listed ones
18:56:53 <wolverian> thanks, works now. however, mentioning package names (e.g. 'array') instead of the actual library (e.g. 'Data.Array') seems ugly to me. what if they change packages? can't I specify the _actual_ dependencies?
18:57:40 <wolverian> (for once, cpan does this right)
19:02:46 <Saizan> wolverian: it's harder to find where Data.Array comes from, also two packages may in theory provide different modules with the same name
19:03:16 <wolverian> yeah. the right way would be to specify authorship as well.
19:03:52 <wolverian> perl6 is designing this into the module system. it's quite enlightening how hard it is.
19:04:29 <Lemmih> wolverian: You'd be fond of searchpath, I believe.
19:04:29 <wolverian> (http://perlcabal.org/syn/S11.html#Versioning)
19:04:30 <lambdabot> Title: S11
19:04:56 <wolverian> Lemmih, hm, maybe, though I'd really rather make cabal support this.
19:05:46 <wolverian> I'm used to central repositories... mavenish things scare me
19:07:36 <wolverian> the amount of automagic in searchpath is impressive, certainly
19:10:21 <mauke> @where zipper
19:10:22 <lambdabot> I know nothing about zipper.
19:11:27 <chessguy> @go huet zipper
19:11:28 <lambdabot> Plugin `search' failed with: getHostByName: does not exist (no such host entry)
19:12:04 <chessguy> @where+ zipper http://www.haskell.org/haskellwiki/Zipper
19:12:05 <lambdabot> I will remember.
19:12:35 <chessguy> thanks, lambdabot
19:15:44 <nanothief> whats a good haskell gui toolkit? I've found a few (wxHaskell, HToolkit, Gtk2Hs, HOC, etc), but don't know which ones are good
19:16:20 * araujo likes gtk2hs
19:16:25 <dmwit> Gtk2Hs and wxHaskell are quite nice.
19:17:04 <nanothief> ok i'll give those 2 a go
19:17:17 <nanothief> which one would be easier to use?
19:17:24 <dmwit> Gtk2Hs
19:17:32 <dmwit> Well...
19:17:41 <araujo> nanothief, I recommend gtk2hs , it has many advantages
19:17:57 <dmwit> The toolkit you know better will be easier to use. =P
19:18:12 <nanothief> lol so true
19:18:16 <drtomc> :t insertWith
19:18:18 <lambdabot> Not in scope: `insertWith'
19:18:18 <araujo> nanothief, for example , it will help you to know gtk+ which is a toolkit widely used through different languages and platform
19:18:28 <drtomc> :t Data.Map.insertWith
19:18:29 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> Data.Map.Map k a -> Data.Map.Map k a
19:18:37 <araujo> Plus it has a good documentation
19:19:14 <nanothief> araujo: cool I'll go with gtk2hs then (documentation ftw)
19:19:33 <araujo> :-)
19:28:22 <conal> nanothief: wxHaskell is higher level (more elegant), while gtk2hs is better maintained.  either of these properties may improve.  hard to know.
19:30:05 <smitti12> did someone sucessful compiled zlib 0.4.0.1 with ghc-6.8.2 on OS X?
19:32:03 <smitti12> I get compile error because of an invalid ghc flag -F/Library/Frameworks. Any idea what's wrong?
19:34:08 <dons> hmm, looks like a mac thing
19:35:14 <smitti12> I'm newbie to haskell and cabal, can I somehow change the options in the cabal configuration?
19:36:50 <dons> the Frameworks flag is likely stored in the .buildinfo file (I think)
19:37:56 <smitti12> hmmm... where do I finde the file? it's not in the package directory.
19:41:47 <smitti12> It looks like I can compile the one file when I remove the -F/... option.
19:59:49 <dibblego> the Harrop-talking-shit-about-Haskell-on-Scala-list thread has had new contributions, for anyone interested
20:01:26 <Korollary> More shit was added?
20:01:43 <dibblego> yes, he responded after all this time
20:02:01 <dibblego> cleverly omitting the inconvenient parts
20:02:02 <Nafai> mattrepl__: Hey, I saw a posting from you on the austinfp list!
20:02:07 <Korollary> He also got himself a haskell-news blog at blogspot
20:02:30 <Nafai> I read a post the other day talking about how this person didn't like O'Caml
20:02:46 <mattrepl__> Nafai, hey there.  are you going to the meetup on Sunday?
20:02:54 <dibblego> I'm angry at just how fraudulent he is; I didn't realise it was that bad
20:02:58 <Nafai> I looked at the post an hour or so after it was posted, and sure enough, there was a post from Harrop
20:03:01 <thoughtpolice> dibblego: link?
20:03:13 <dibblego> lemme find
20:03:14 <Nafai> mattrepl__: Unfortunately not, Sundays are bad for me :/
20:03:38 <dibblego> thoughtpolice, http://www.nabble.com/Re%3A-Another-rant-p14098434.html
20:03:41 <lambdabot> Title: Nabble - Re: Another rant
20:03:49 <dibblego> thoughtpolice, actually, that's not the start
20:04:00 <wolverian> I need to save an image from my app. are there bindings to any image libraries, e.g. libpng or libtiff? if not, any recommendations for a simple image format?
20:04:03 <Nafai> mattrepl__: But I'm excited for a FP group getting going in Austin, I've wanted to talk to people face-to-face about Haskell and such
20:04:08 <mattrepl__> it's surprising how many FP-interested folks are in the area
20:04:36 <Nafai> Nah, there are a lot of smart people here.
20:04:51 <Nafai> I hear from my coworkers that Haskell is used at UT, but most didn't like it :)
20:05:02 <mattrepl__> suppose so
20:05:03 <ricky_clarkson> I'd love to meet just a single smart programmer.  It's been about 6 years since I knowingly did so.
20:05:03 <mattrepl__> heh
20:05:32 <Korollary> They're all married?
20:05:36 <Nafai> ricky_clarkson: I knew a few in college, haven't met many in person since :/
20:06:01 <chessguy> wow, does that mean i'll get really smart when i get married in 2 months?
20:06:19 <Korollary> chessguy: congratulations
20:06:20 <wolverian> ah, imlib looks like a suitably simple one
20:06:27 * chessguy calls his fiancee to badger her about moving the wedding up
20:06:35 <mattrepl__> hey ricky_clarkson liked the last Scala post
20:07:44 * chessguy plans the six months after his wedding for reading all the papers on haskell and category theory that have gone over his head in the past
20:09:04 <chessguy> "so honey, uh...what's in the huge suitcase?" "oh, TAPL, and a bunch of other type theory and category theory books. now that i can finally understand them, i don't want to waste any time!" "but...this is our honeymoon...
20:09:49 <Pseudonym> Marriage is like that!
20:09:50 <thoughtpolice> Nafai: gah, I would join you but i'm several hours away. :(
20:09:55 <Pseudonym> I started understand all sorts of maths!
20:10:23 <Nafai> thoughtpolice: :(
20:10:26 <chessguy> wow, who'd've thunk it
20:10:29 <Nafai> Anyway, I must be off to bed
20:10:37 <thoughtpolice> Nafai: perhaps during the summer though I could stop by up there, austin's about an hour away from where my sister lives
20:10:57 <chessguy> must be a hormonal thing
20:13:16 * bos31337 contemplates encoding the length of a vector in its type using peano numerals. hmm.
20:14:22 <bos31337> this is one of the infelicities in my LLVM bindings at the moment.  LLVM's vectors are typed with their lengths, but mine aren't.
20:14:59 <Pseudonym> Sounds like it should be a library, then.
20:15:20 <chessguy> hmph. it's way too late to be seing words like "infelicities"
20:15:43 <lokik> @paste
20:15:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:16:36 <Korollary> bos31337: Does LLVM binding mean something like FFI for LLVM code?
20:18:28 <bos31337> Korollary: yes, you can generate LLVM code and execute it via a JIT
20:18:33 <BMeph> ?src (<$>)
20:18:34 <lambdabot> f <$> a = fmap f a
20:19:20 <Korollary> bos: Generate llvm code? Why would I do this?
20:20:11 <bos> Korollary: because you want to?
20:20:29 <BMeph> ?index (<$>)
20:20:29 <lambdabot> bzzt
20:20:56 <BMeph> ?src (<*>)
20:20:56 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:21:04 <BMeph> ?index (<*>)
20:21:05 <lambdabot> bzzt
20:21:12 <mauke> Control.Applicative
20:21:25 <dibblego> ?type (<*>)
20:21:25 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
20:21:31 <dibblego> ?type ap
20:21:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:21:38 <Korollary> bos: Umm, that's not what I understand from LLVM binding. I thought it was going to let me execute other people's LLVM programs.
20:21:55 <BMeph> Yeah, <*> in in Applicative, but where's <$>?
20:22:01 <bos> Korollary: you ought to be able to do that, too.
20:22:14 <Korollary> bos: oh ok
20:22:26 <oerjan> BMeph: it's also in that module
20:22:52 <oerjan> @index <$>
20:22:52 <lambdabot> bzzt
20:22:55 <oerjan> hmph
20:25:01 <BMeph> oerjan: Thanks, I kept looking for it, but not seeing it. It was making me nuts.
20:42:47 <hpaste>  bretthall pasted "Bug in ghc?" at http://hpaste.org/4789
20:44:45 <hpaste>  bretthall annotated "Bug in ghc?" with "(no title)" at http://hpaste.org/4789#a1
20:45:54 <sorear> @seen SyntaxNinja
20:45:55 <lambdabot> I saw SyntaxNinja leaving #haskell and #haskell-blah 3h 9m 19s ago, and .
20:46:21 <oerjan> bretthall: why do you want an explicit forall in the type of createArray?
20:46:22 <sorear> @tell SyntaxNinja It's much easier if you do it the other way.  show 1 == "1"
20:46:22 <lambdabot> Consider it noted.
20:46:47 <jz87> is anyone here familiar with the http library?
20:46:49 <bretthall> Using runST requires it, doesn't it?
20:46:54 <oerjan> that should not be necessary, and perhaps it's the cause of your problem
20:47:19 <jz87> I'm wondering how you're supposed to use receiveHTTP
20:47:34 <jz87> the behavior of Stream readLine is really fickle
20:47:56 <oerjan> if it triggers limitations in old ghc implementations of rank 2 types
20:48:54 <bretthall> I don't see how to leave it off and still get a value in the ST monad
20:49:07 <mauke> use plain s
20:50:17 <oerjan> haskell puts foralls on automatically, but outermost
20:50:52 <bretthall> Oh, this is first time that I've used forall for anything
20:51:14 <bretthall> I guess the compiler is inferring the type of s from where createArray is being called?
20:51:29 <pete213> oh my god......
20:51:32 <oerjan> essentially
20:51:32 <pete213> what was i thinking
20:51:46 <wolverian> heh
20:52:17 <Lemmih> Isn't a sorted list the pathological input for Data.Set?
20:52:41 <oerjan> Lemmih: Data.Set has a pathological input?
20:53:45 <Lemmih> A sorted list should trigger more rebalancing than a randomized list, no?
20:54:55 <Korollary> Lemmih: I presume so
21:03:23 <Lemmih> Weird, I'm seeing a significant decrease in performance when testing with randomized input.
21:09:21 <Korollary> Lemmih: What is the contained type?
21:16:09 <drtomc> Here's another Map question: I'm using splitLookup to find the largest key <= a given value. Is there a more efficient way?
21:16:37 <drtomc> (context: using Map Key Subtree for the internal nodes of a BTree)
21:30:48 <pgavin> @pl \g -> f (g x) (g y)
21:30:48 <lambdabot> liftM2 f ($ x) ($ y)
21:31:03 <oerjan> f `on` g
21:31:10 <pgavin> :t on
21:31:12 <lambdabot> Not in scope: `on'
21:31:14 <pgavin> @t on
21:31:14 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:31:21 <oerjan> it's new in 6.8
21:31:27 <pgavin> ah
21:31:41 <pgavin> which module?
21:31:46 <oerjan> Data.Function
21:31:54 <pgavin> cool, thx
21:32:29 <lekro> maybe this is the right channel to ask: I recall dimly an algorithm by someone like "rasswrow & witreiler". But I probably totally messed up the spelling, so I'm unable to find the algorithm. It has something to do with graphs and cuts, I think. Any ideas for the correct spelling of the names?
21:38:53 <pgavin> is there an easy way to derive Monoid?
21:41:23 <dons> depends on the type. but in general, no.
21:41:25 <oerjan> if that has anything with the \g -> f (g x) (g y) you made, then i think the -> instance already works that way
21:41:41 <oerjan> oh wait n
21:41:43 <oerjan> *no
21:42:05 <pgavin> actually, no.. I have a big data whose fields are all monoids
21:42:16 <pgavin> it'd be nice to just do deriving (Monoid)
21:42:21 <oerjan> oh
21:42:29 <oerjan> @instances Monoid
21:42:30 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
21:42:48 <pgavin> isn't maybe a monoid?
21:43:16 <mauke> Maybe is two monoids
21:43:22 <oerjan> there were some new instances in 6.8 iirc
21:43:51 <dons> yep. there are 2 monoids for Maybe though, so there's some confusion about which should have been used
21:44:05 <oerjan> First, Last, and one for Maybe which assumes the range is monoid
21:44:07 <lekro> hm, maybe I also mixed that up with the Stoer-Wagner algorithm. I am confused. so "rasswrow & witreiler" doesn't ring a bell to anyone (being tolerant with the spelling)?
21:44:10 <dons> -- | Lift a semigroup into 'Maybe' forming a 'Monoid' according to
21:44:10 <dons> -- <http://en.wikipedia.org/wiki/Monoid>: \"Any semigroup @S@ may be
21:44:10 <dons> -- turned into a monoid simply by adjoining an element @e@ not in @S@
21:44:10 <dons> -- and defining @e*e = e@ and @e*s = s = s*e@ for all @s â~H~H S@.\" Since
21:44:10 <dons> -- there is no \"Semigroup\" typeclass providing just 'mappend', we
21:44:12 <dons> -- use 'Monoid' instead.
21:44:14 <dons> instance Monoid a => Monoid (Maybe a) where mempty = Nothing Nothing `mappend` m = m m `mappend` Nothing = m Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)
21:45:26 <pgavin> ahh
21:45:39 <pgavin> so mappend is deep
21:45:46 <pgavin> i guess I want to use First
21:46:12 <oerjan> First is the same as the mplus variant i guess
21:46:36 <pgavin> hmm, I guess mplus is what I should use then :)
21:47:41 <pgavin> @src MonadPlus [a]
21:47:41 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:47:57 <oerjan> @src [] mplus
21:47:58 <lambdabot> mplus = (++)
21:48:09 <pgavin> cool, that's what I wanted :)
21:50:58 <jz87> I have a question about haskell threading
21:51:20 <jz87> if I write forkIO $ (fun :: IO ())
21:51:22 <jz87> in a loop
21:51:31 <jz87> where fun runs a small finite time action
21:51:34 <mauke> (or just forkIO fun)
21:51:37 <jz87> like write to a file
21:51:42 <jz87> yes, I'm just labeling the type
21:51:44 <jz87> for clairty
21:51:47 <jz87> does the thread die
21:51:52 <jz87> after the action completes?
21:51:55 <thoughtpolice> yes
21:52:00 <mauke> the return key
21:52:00 <jz87> ok cool
21:52:01 <mauke> is not
21:52:05 <mauke> punctuation
21:52:06 <thoughtpolice> after the action is done the runtime will kill the thread.
21:52:25 <jz87> I'm wondering why threadids aren't being reused
21:52:35 <jz87> because I'm just printing out the threadid of the threads being spawns
21:52:39 <mauke> they aren't?
21:52:40 <jz87> and they're incrementing
21:52:44 <mauke> interesting
21:52:49 <jz87> so I was a bit alarmed
21:55:34 <Korollary> It could be intentional. What would you gain by reusing an id? This way it's always unique among other thread ids ever issued, alive or dead.
21:56:35 <jz87> well, I was just wondering
21:56:57 <jz87> because I can't tell if the threads are being kept alive but dormant by the runtime or what
21:57:07 <jz87> if I'm going to spawn a lot of threads I need to know if I need to clean up after myself
21:57:37 <mauke> eh, I just ran a program with 120000 simultaneous threads
21:57:56 <mauke> you're unlikely to run into any limits
21:58:41 <thoughtpolice> and that limit increases with the more cores you have if you use the threaded runtime. so you probably won't hit a limit very easily
21:59:25 <sarehu> if threadids were reused, throwTo and killThread would behave incorrectly
22:00:20 <jz87> I see
22:00:24 <jz87> I have a question
22:00:30 <jz87> what's the proper way to escape from interat
22:00:34 <jz87> interact runs in a loop
22:00:39 <jz87> but on certain values like :q
22:00:44 <jz87> I would like to exit the loop
22:01:07 <jz87> do I throw an exception in the String -> String and then catch it?
22:01:11 <mauke> you can't. interact only stops at the end of the input
22:01:22 <mauke> hmm, or maybe you should just stop generating more output :-)
22:01:40 <jz87> but the function that interact takes is just String -> String
22:01:48 <mauke> yeah, so?
22:01:52 <jz87> basically I'm using this to write a server console
22:01:59 <jz87> so the interact gets forkIOed
22:02:08 <jz87> and it sends commands to the server via a TCHan
22:02:10 <jz87> TChan
22:02:36 <jz87> does every thread die if the main thread dies?
22:02:43 <mauke> interact (whatever . takeWhile (/= ":q") . lines)
22:02:50 <pgavin> is there any difference (at top level) between a x = b and a = \x -> b ?
22:03:04 <mauke> pgavin: yes, the monomorphism restriction
22:03:14 <jz87> :t  (whatever . takeWhile (/= ":q") . lines)
22:03:14 <lambdabot> Not in scope: `whatever'
22:03:17 <pgavin> ah, right
22:03:34 <mauke> :t (?whatever . takeWhile (/= ":q") . lines)
22:03:34 <lambdabot> forall c. (?whatever::[[Char]] -> c) => String -> c
22:03:46 <sarehu> jz87: yes, killing the main thread kills them all (in GHC) (if the docs are right).
22:04:48 <jz87> hmm
22:05:17 <jz87> I guess I should probably just write my own interact
22:05:23 <jz87> I need to perform STM operations in there
22:05:25 <dons> so you can just have the main thread wait on the children
22:05:35 <dons> demonic threads yo yo
22:05:39 <mauke> jz87: yeah, I'd use a manual loop
22:05:52 <jz87> basically the main thread spawns worker threads
22:05:55 <jz87> and 1 console thread
22:06:03 <jz87> that interprets commands from the console
22:06:17 <jz87> and I need to be able to kill the whole program
22:06:22 <jz87> from a console command
22:06:25 <dons> yeah, spawn a thread to read commands, and pass them back over a pipe.
22:06:32 <jz87> pipe?
22:06:35 <dons> a Chan
22:06:38 <jz87> ok
22:06:49 <jz87> what is the difference between Chan and TChan?
22:06:52 <jz87> I've been using TChans
22:06:55 <dons> not much. the locking mechanism
22:06:57 <dons> that's fine.
22:07:15 * luqui has fallen in love with STM...
22:07:34 * sarehu writes fan fiction about STM...
22:07:50 <luqui> haha
22:09:31 <hpaste>  dons pasted "io in child thread" at http://hpaste.org/4790
22:09:33 <jz87> is there a way of embedding bytestring literals?
22:09:46 <dons> jz87: ^ see above for a control structure to pass commands back to the main program
22:09:50 <dons> yeah, pack "foo"
22:09:58 <dons> will turn into an inline bytestring literal at compile time
22:10:10 <dons> sarehu: heh
22:10:13 <jz87> wait, which line are you referring to?
22:10:16 <jz87> wow, that's cool
22:10:20 <dons> http://hpaste.org/4790
22:10:38 <jz87> thanks
22:10:41 <dons> so the child thread does the io, and returns items lazily to the main thread to evaluate
22:10:46 <jz87> I'm writing a small rpc server
22:10:59 <jz87> to work with a web application I'm writing, and HAppS is perpetually broken
22:11:15 <dons> cool.
22:11:16 <jz87> this this great, thanks
22:11:19 <dons> using fastcgi or something?
22:11:22 <jz87> no
22:11:30 <jz87> just getting http
22:11:32 <dons> ok
22:11:34 <jz87> accepting socket
22:11:38 <jz87> and writing response back
22:11:43 <jz87> I'm using the Network.HTTP lib
22:11:49 <jz87> but I'm a bit concerned with their IO code
22:11:55 <jz87> it seems to be using really slow functions
22:12:12 <jz87> they would probably benefit a lot from using ByteStrings
22:12:13 <alexj> jz87: happs is getting a lot less broken really fast.
22:12:14 <dons> you could use network-bytestring, or bytestring-http
22:12:22 <jz87> bytestring-http?
22:12:23 <dons> happs also has a bytestring http in it, these days
22:12:32 <jz87> I didn't know about this lib
22:12:48 <dons> http://nominolo.blogspot.com/2007/05/networkhttp-bytestrings.html
22:12:48 <alexj> happs has been a bytestring server for a while.  as of today it can do bytestring client side as well.
22:12:49 <lambdabot> Title: nominolo's Blog: Network.HTTP + ByteStrings
22:13:04 <dons> we need one standard bytestring-based http lib for hackage
22:13:33 <alexj> dons happs does client and server these days.
22:13:42 <dons> alexj: cool
22:14:12 <jz87> this isn't distributed with the standard http libs?
22:15:11 <jz87> the standard http lib needs to be converted to bytestrings
22:16:00 <alexj> jz87: happs should release in the next couple of days.
22:16:30 <alexj> HAppS.Server is being renamed HAppS.Network.HTTP
22:16:39 <sclv> how do I determine operator precedence again?
22:16:46 <jz87> wait
22:16:51 <faxathisia> :i +
22:16:52 <Lemmih> There's a standard http lib?
22:16:52 <jz87> I can't build the lazy bytestring http
22:16:59 <faxathisia> shows you the infixr 6 +
22:17:00 <jz87> it says that Data.ByteString.Lazy is hidden
22:17:01 <sclv> thx
22:17:03 <faxathisia> (in ghci..)
22:17:04 <jz87> by the bytestring package
22:18:05 <sclv> using lots of applicative I notice that I really need a low precedence (.)
22:19:41 <jz87> how would I enabled the Lazy bytestrings
22:19:44 <jz87> instead of the strict ones
22:19:49 <jz87> when building bytestring-http
22:20:11 <Cale> import Data.ByteString.Lazy instead of Data.ByteString
22:20:20 <jz87> no
22:20:25 <jz87> I meant the GHC command line params
22:20:40 <jz87> I'm trying to compile the lazy version of bytestring-http
22:20:54 <jz87> and it says that Data.ByteString.Lazy is hidden
22:21:20 <alexj> dons: how does code migrate into the standard libs?
22:21:21 <Cale> Make sure that the cabal file lists the bytestring package as a dependency.
22:21:35 <sarehu> I'm getting ^B and ^? on Ctrl-B and Backspace in GHCi and GHC-built programs.  What is the source of this?  Some readline thing?  What is the fix?
22:21:42 <Cale> alexj: Recently, most code has been migrating out.
22:22:03 <alexj> Cale: ok.  I guess that works too.
22:22:06 <sarehu> This is on Debian lenny
22:22:06 <dons> alexj: i'm not sure any code has migrated in recently. to do that you make a proposal on the libraries@ list
22:22:13 <dons> mostly just for instances and missing core functions
22:22:21 <alexj> I'll push a bunch of happs packages to cabal.
22:22:30 <alexj> hackage.
22:22:32 <dons> yep, that'd be best. get them on hackage with the others.
22:22:45 <mauke> sarehu: that means someone messed with your terminal settings
22:22:47 <mauke> raw mode, etc
22:22:48 <dons> i hope to get a bunch of galois web libs out soon too
22:22:49 <alexj> fyi, searchpath is getting a lot of work put into it.
22:22:52 <dons> so we can save some duplicated effort
22:23:08 <dons> is searchpath a competitor to cabal-install ?
22:23:17 <alexj> dons: I think so.
22:23:22 <alexj> it already does import chasing.
22:23:26 <sarehu> mauke: but no other program does that
22:23:40 <alexj> and the module maps now take build commands.
22:23:45 <dons> that's a pity. we should really only have one such system
22:23:53 * dons worries about duplicated effort
22:24:09 <dons> and cabal-install is pretty widely used now
22:24:50 <jz87> hey dons
22:24:53 <alexj> dons: cabal-install does not module chase.
22:25:02 <dons> right, only cabal dependencies
22:25:03 <alexj> the spec is also self-conflicting.
22:25:05 <jz87> the bytestring package by default hides lazy bytestring right?
22:25:15 <alexj> and cabal dependencies are also self-conflicting.
22:25:19 <jz87> I'm trying to compile bytestring-http
22:25:19 <dons> jz87: well, kind of.
22:25:25 <Cale> jz87: no
22:25:27 <jz87> and I'm getting a compiler error
22:25:36 <dons> alexj: you should contribute patches to cabal then :)
22:25:37 <jz87> saying that the package is hiding data.bytestring.lazy
22:25:52 <dons> jz87: oh, are you using ghc 6.6?
22:25:56 <alexj> dons: the cabal code base is confusing and I am moving searchpath forward faster in my spare time.
22:25:56 <dons> it has bytestring in the base library
22:25:57 <jz87> 6.8.2
22:26:03 <jz87> yes it comes with the system
22:26:09 <Cale> The bytestring library exposes Data.ByteString.Lazy by default.
22:26:13 <dons> alexj: ok. but i worry it will be wasted effort
22:26:15 <jz87> hmm
22:26:29 <alexj> dons: I do too. but right now, the oob experience with cabal is pretty painful.
22:26:32 <dons> maybe that's ok for happs, but pretty much everything is using cabal as is, and it has broad consensus
22:26:45 <jz87> but why then is it saying Could not find module Data.ByteString.Lazy, it's a memberof package bytestring-0.9.0.3 which is hidden
22:26:53 <dons> have you passed on these issues to dcoutts? he's quite responsive
22:27:04 <dons> jz87: hmm. ah, you need --user
22:27:08 <Cale> jz87: Look inside the .cabal file, and see what it says under Build-Depends
22:27:09 <dons> or maybe you didn't install it as user
22:27:22 <sclv> also a high precedence (>>) would be helpful
22:27:29 <alexj> I don't know.  the .cabal file format itself is confusing.
22:27:37 <sclv> anyone tend to define (.) and (>>)with different precedences?
22:27:44 <jz87> base, network, parsec, mtl
22:27:45 <dons> oh, its fine. what's confusing, alexj ?
22:27:51 <jz87> it doesn't actually mention bytestring
22:27:59 <Cale> jz87: Then add bytestring to the list.
22:28:21 <faxathisia> sclv: I think that would be a little confusing
22:28:24 <Cale> (the package must be out of date with respect to the base split)
22:28:27 <alexj> can you put AT&T in a synopsis?
22:28:39 <dons> the string "AT&T" ?
22:28:42 <alexj> yes.
22:28:45 <jz87> I need to really read up on cabal one of these days
22:28:50 <dons> it's just a chunk of haddock markup, so i guess so. possibly escaped
22:29:01 <alexj> FYI, I've been working on this part as well http://searchpath.org/package-info.rnc
22:29:13 <alexj> possibly escaped is where the trouble comes in.
22:29:24 <sclv> faxathisia: not to redefine the defaults, I mean, but to define say, |. as . but with a low precedence. etc
22:29:34 <dons> seems easy enough to fix, i'm not sure anyone's even suggested this as a bug issue for cabal
22:29:41 <alexj> RSS became Atom because among other things there was no definitive way to do AT&T in the title.
22:29:56 <dons> it would be *so* much more efficient to just pass on improvments to cabal, than to reimplement that huge wheel
22:29:56 <alexj> dons: the bigger bug is that modules have program scope.
22:30:16 <jz87> oh crap
22:30:17 <dons> since you lose all the tools already written to support cabal files
22:30:31 <alexj> dons: like what?
22:30:33 <jz87> I now have 2 HTTP packages in my ghc-pkg list
22:30:40 <jz87> HTTP and HTTP1
22:30:48 <dons> cabal-install, mkcabal, cabal-update, hackage, cabal-upload, ...
22:30:57 <dons> all the management and distribution tools
22:31:09 <sarehu> mauke: thanks, you're right
22:31:12 <dons> we're too small a community to have fragmented efforts like this :(
22:31:19 <jz87> yeah
22:31:25 <dons> or, you have to get community consensus before embarking
22:31:28 <jz87> reminds of the lisp community
22:31:31 <jz87> roll your own
22:31:42 <jz87> and everything is incompatible
22:31:45 <dons> its ok to have libs duplicated, breeding better solutions
22:31:48 * faxathisia thinks there is a lot of good free lisp code which you can use.....
22:31:59 <dons> but we've benefited a lot from having a single dvcs and build system in common
22:32:00 * faxathisia (doesn't expect someone to write code for them though)
22:32:21 <dons> there are notable large projects that aren't cabalised -- their value outweights any non-standard build system
22:32:24 <jz87> well having a ton of fragmented systems make learning it really hard
22:32:25 <dons> gtk2hs and happs are like that
22:32:41 <alexj> dons, there is not straightforward way to module chase using cabal.
22:32:56 <dons> you're supposed to package chase from hackage
22:33:06 <dons> which works. if it doesn't, that's a bug report.
22:33:32 <glguy> dons: happs isn't cabalized?
22:33:51 <dons> glguy: just this searchpath stuff instead of using hackage/cabal-install, seems like wasted effort to my eyes
22:33:53 <alexj> glguy: happs is also cabalized, but maintaining cabal files turns out to be a apin.
22:34:01 <alexj> pain.
22:34:14 <alexj> the cabal files are always out of sync with the package.
22:34:29 <alexj> there end up being too many touch points to manage the same information.
22:35:03 <dons> you could generate the .cabals to avoid that.
22:35:11 <Cale> hmm
22:35:16 <alexj> ok then cabal files are a machine format not a human format.
22:35:19 <dons> it depends on how important it is to fit in with what 95% of the other haskell libs are doing.
22:35:21 <alexj> I want a human editable file format.
22:35:35 <Cale> alexj: Where is there repeated information in a .cabal file?
22:35:53 <dons> Cale: i think he's referring to export lists in .hs files being duplicated into .cabal files
22:36:00 <alexj> If I create a module in the directory then it is part of the package.
22:36:04 <dons> if you add a module, you need to add it to the .cabal file
22:36:09 <alexj> dons: yes.
22:36:20 <dons> which is pretty easy -- modules don't get created often.
22:36:28 <dons> maybe in big/odd projects, that's more burdensome
22:36:34 <Cale> Isn't that how you control which modules are accessible from outside the package?
22:36:42 <dons> but an incompatible alternative build systems seems overkill
22:36:50 <sclv> a tool to generate .cabal files more automagically would be pretty handy all round tho.
22:37:00 <dons> sclv: i use mkcabal, which does most of what i need
22:37:03 <dons> it could be a little smarter
22:37:14 <dons> Cale: that's right
22:37:18 <Cale> It would be cool to have mkcabal integrated with the main cabal executable.
22:37:21 <dons> you hide/expose packages that way
22:37:24 <alexj> dons: I want to parse cabal files from javascript.
22:37:28 <dons> yeah, dcoutts has asked to do that.
22:37:38 <dons> alexj: ok, now that's seriously interesting. (and unusual)
22:37:56 <alexj> the new happs homepage actually pulls package-info.xml files from each of the repos.
22:38:10 <alexj> check out http://happs.org/index2.html
22:38:11 <Cale> Heh, perhaps you can use yhc's javascript compiler.
22:38:21 <dons> cabal2xml might be easier :)
22:38:39 <alexj> where is cabal2xml?
22:38:47 <dons> it doesn't exist.
22:38:49 <alexj> there is too much magic.
22:38:50 <alexj> yes.
22:38:59 <Cale> That would be easy enough to write, wouldn't it?
22:39:09 <alexj> cale: it would if cabal had a meaningful spec.
22:39:23 <dons> but you're not proposing searchpath as a replacement to cabal for build and distribution of haskell libs?
22:39:45 <alexj> dons: HAppS will support both.
22:39:54 <alexj> searchpath is on the verge of working for non-haskell libs too.
22:40:09 <Cale> Well, you have Distribution.PackageDescription which defines a data structure representation of cabal files.
22:40:10 <glguy> Cabal needs to be smarter about version numbers to be useful with non-release versions
22:40:25 <glguy> I'd like to figure out a way to allow cabal to query the vcs
22:40:30 <Cale> It can't be that hard to convert that to and from XML using, say, HXT.
22:40:31 <glguy> to find out what version the source was
22:40:42 <dons> are there any build systems that support that kind of thing automagically, glguy ?
22:40:44 <glguy> only to be cemented when preparing a release
22:40:52 <dons> i'm not sure we've done a survey of what has been done wrt that kind of thing
22:40:55 <glguy> dons: build systems? I don't know
22:41:02 <glguy> dons: but that is how git works
22:41:05 <alexj> searchpath can pull from any repo.
22:41:09 <glguy> the source for the tool itself
22:41:21 <Cale> Barring unforeseen problems, I could probably whip that up in a few minutes :)
22:41:23 <alexj> the map format allows you specify syntax for pulling a tag.
22:41:24 <glguy> its makefile isn't a generalized build system
22:42:00 <glguy> This wouldn't work as well for darcs since it doesn't really name arbitrary combinations of patches
22:42:06 <glguy> unless you explicitly tag
22:42:32 <alexj> glguy: HAppS.Util    "darcs get --partial --tag=0.9.1.2 http://happs.org/repos/HAppS-Util util; echo hello world" util/src
22:42:33 <glguy> but would for almost every other vcs
22:42:57 <alexj> you can replace the darcs command with the equivalent for the other vcs
22:43:06 <alexj> works now.
22:43:13 <glguy> alexj: no, I meant auto-version naming
22:43:15 <glguy> not searchpath
22:43:21 <glguy> (not working well with darcs)
22:43:29 <alexj> glguy: what is auto-verson naming?
22:43:43 <glguy> when you build the tool, it computes its name from your source control system
22:43:43 <dons> but what do you see as the future for this, alexj? the community's not likely to ditch cabal at this point -- it works well enough, and there's too much on hackage.
22:43:47 <glguy> its version rather
22:44:17 <glguy> so when you install a development version of something you know what version you have
22:44:30 <glguy> since most people don't (all people don't?) change their cabal version every build
22:44:33 <dons> the case against cabal isn't compelling enough, i think. (only complex or rapidly changing projects run into the edge cases)
22:45:07 <sclv> searchpath is nice for a development setting, i think, but not a good general model.
22:45:07 <dons> and it took a lot of negotiating/discussion to get an agreed upon build system for haskell in the first place
22:45:21 <sclv> maven's dependency chasing drives people nuts for example.
22:45:22 <sclv> http://fishbowl.pastiche.org/2007/12/20/maven_broken_by_design
22:45:23 <lambdabot> Title: The Fishbowl: Maven: Broken By Design
22:45:55 <dons> yeah, there's something to be said for the single, centralised, standardised hackage setup.
22:46:25 <glguy> doesn't maven have automatic dependency download / install?
22:46:32 <dons> improvements to hackage/cabal/mkcabal benefit everyone, too
22:46:37 <glguy> the problem is just that it is spread out into lots of deps
22:47:01 <qweqwe> what is wrong here ?
22:47:07 <qweqwe> rev::[Int]->[Int]
22:47:07 <qweqwe> rev [] = []
22:47:07 <qweqwe> rev (x:xs) = rev (xs) ++ x
22:47:16 <dons> x has the wrong type
22:47:16 <glguy> ++ [x]
22:47:24 <dons> rev (x:xs) = rev xs ++ [x]
22:47:28 <dons> ?src reverse
22:47:28 <lambdabot> reverse = foldl (flip (:)) []
22:47:32 <dons> oh, heh.
22:47:41 <qweqwe> thenks
22:47:44 <dons> more efficient, but a bit obscure with that @pl going on.
22:47:56 <dons> foldl eh?
22:48:17 <dons> ah, that's the h98 defn
22:48:19 <dons> in practice,
22:48:20 <dons> reverse l =  rev l []
22:48:20 <dons>   where
22:48:22 <alexj> dons: searchpath does 1. module chasing 2. package building 3. it does auto-recompile/restart on changes in code which is really useful for server apps.
22:48:22 <dons>     rev []     a = a
22:48:25 <dons>     rev (x:xs) a = rev xs (x:a)
22:48:32 <dons> yeah, i can see that use case
22:48:41 <luqui> @unpl foldl (flip (:)) []
22:48:41 <lambdabot> foldl (\ b c -> (:) c b) []
22:48:50 <dons> as a foundation for non-stop stuff running in happs
22:48:55 <alexj> and I am game to keep using hackage as the database.  the question is the toolset fo.
22:49:12 <alexj> dons yes.
22:49:51 <alexj> searchpath also can run source pulled directly from the internet.
22:50:08 <dons> so what's the use case for that?
22:50:14 <alexj> sp runhaskell Some.Module.Main
22:50:17 <dons> rapid distributed development?
22:50:25 <dons> when stuff you need hasn't made it to hackage yet?
22:50:34 <alexj> pulling scripts directly from the internet and running them without bothering to install.
22:50:35 <dons> but you're already distributing the src to others
22:50:50 <alexj> the point is that the whole installation process should be invisible.
22:51:56 <alexj> if you have searchpath installed, the process for building the happs.org website is:   darcs get http://happs.org/happs.org MyProject; cd MyProject; sp ghc -isrc src/Main.hs --make --run --http-port=5000
22:52:07 <alexj> now you have a server running on port 5000.
22:52:14 <alexj> notice the absence of any installation process for anything.
22:52:32 <alexj> and if you go ahead and modify the source, searchpath will automatically recompile and restart.
22:52:44 <dons> yeah, nhc98 uses a similar script to pull a bunch of libraries from darcs repos for installation.
22:53:18 <dons> so a useful tool to have
22:53:18 <alexj> at some point I will scrape hackage to generate the default mapfile.  right now it is a manual process.
22:55:26 <skew> alexj: are you claiming cabal can't or shouldn't have similar features?
22:55:47 <alexj> skew: I'm claiming that i rewrote searchpath and added a lot of this funcitonality over the past week or so.
22:56:00 <alexj> cabal is moving pretty slow.
22:56:16 <skew> so more that it's hard to understand or change cabal?
22:56:18 <alexj> philosophically, I think the system should be centered on modules and not packages.
22:56:34 <alexj> modules are program global.
22:56:46 <alexj> a build system that ignores that is a recipe for trouble.
22:57:01 <jz87> is there a hGetLine
22:57:05 <jz87> with ByteString?
22:57:15 <thoughtpolice> yes
22:57:26 <jz87> really? it's not in the docs
22:57:35 <thoughtpolice> Data.ByteString.hGetLine
22:57:39 <glguy> alexj: if you look at things at a module granularity, where to implementation detail modules fit in
22:57:40 <sclv> sp doesn't put stuff in the global package system, right?
22:57:45 <jz87> does the lazy version have one?
22:57:56 <glguy> things that are depended upon by a module but that the use doesn't know to know about ot use a library?
22:58:06 <glguy> user*
22:58:17 <thoughtpolice> jz87: looks like it
22:58:31 <sclv> So if I install the same thing with sp in two different directories it hits the repos twice?
22:58:32 <alexj> glguy: can you give an example?
22:58:47 <thoughtpolice> jz87: http://haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Lazy.html#28
22:58:47 <lambdabot> http://tinyurl.com/yspt37
22:59:04 <alexj> sclv: searchpath caches in ~/.SearchPath
22:59:55 <sclv> ok. but then if i use sp to pull a bunch of stuff, then I want to use some dependency it pulls elsewhere, it's not in my installed packages?
22:59:57 <alexj> jz87: are you trying to do HTTP code?
23:00:01 <jz87> yes
23:00:02 <jz87> why?
23:00:05 <sclv> unless I uses sp there too?
23:00:05 <alexj> pull HAppS-Server
23:00:08 <glguy> alexj: lots of libraries (including GHC) have .Internal modules
23:00:39 <alexj> sclv: I don't understand the question?
23:01:02 <qweqwe> what is wrong here ?
23:01:04 <glguy> that package level "packaging" allows you to hide away
23:01:04 <alexj> glguy: GHC is the only haskell compiler that allows any modules to be non-global
23:01:05 <skew> alexj: can searchpath actually install a package so other Haskell program can use it?
23:01:06 <qweqwe> last ::[Int]->Int
23:01:06 <qweqwe> last [] = []
23:01:06 <qweqwe> last xs = head (reverse xs)
23:01:19 <sclv> alexj -- say I pull HAppS-Server and it requires the Network.Magic.Stuff module and so sp chases that down?
23:01:44 <alexj> skew: if they are also compiled using searchpath then yes.
23:01:49 <sclv> now I'm developing another app. is Network.Magic.Stuff automatically available to me, or is it only available if I use sp?
23:01:59 <glguy> alexj: I'm not concerned whether the user can or can not see the module if they wanted to,just that they shouldn't need ot know about it
23:02:11 <jz87> why does happs have a unix dependency?
23:02:17 <jz87> is that really necessary?
23:02:22 <jz87> I'm trying to build this on windows
23:02:33 <Zao> jz87: It will fail.
23:02:56 <sclv> right: this is the issue. in your answer to skew. SP locks you in. It's great for development, and maybe even certain types of deployment, but I think it would be slightly more awesome if it played nice with cabal.
23:02:57 <alexj> sclv: sp ghci MyModule.hs -- will use the cache.
23:02:58 <jz87> lol
23:02:58 <jz87> ok
23:03:17 <qweqwe> any idea ?
23:03:40 <alexj> sclv, the only thing that searchpath does is pull some files from the internet and generate a ghc command line which it then executes.
23:04:37 <alexj> searchpath basically is just a way of making the -i cmmand line option a lot more powerful because no you can pass it mapfiles in addition to directories and it downloads the needed modules locally and then converts the -i into a directory for ghc.
23:04:42 <sclv> alexj: what I mean is it should be able to run ./setup.lhs configure, build, and install.
23:04:57 <skew> alexj: do you consider it a feature that it just pulls source?
23:05:24 <alexj> skew: ghc will then compile .hi and .o versions in your cache.
23:05:36 <sclv> alexj: assuming such versions area available, that is.
23:05:43 <sclv> s/versions/files/
23:05:57 <skew> alexj: Automatically grabbing the dependencies to make the code run is cool
23:06:14 <alexj> sclv: cabal also has some place where it puts stuff it "installs"
23:06:20 <glguy> when doing development which is spread across multiple packages
23:06:41 <glguy> the cabal way of having to reinstall all of your packages and rebuild things that were based on changed versions is a huge hassle
23:06:43 <skew> I don't see why you couldn't also grab prebuild code, rpms of C libraries etc
23:07:00 <alexj> glguy: exactly.
23:07:29 <alexj> skew: searchpath is heading in that direction.
23:07:49 <sclv> its great for development, but again, when the repos break, because, y'know, yr. in development, then everything goes kaput.
23:07:55 <davidL> qweqwe: last [] returns a list whereas list xs returns an Int, last [] should probably be undefined
23:08:02 <alexj> you can basically do that now, but it is not elegant.
23:08:02 <skew> not having to think about instailling stuff to get code running is great
23:08:09 <sclv> it seems the opposite of a stable trustworthy system for deployment.
23:08:26 <sclv> not worrying about what you've got installed is awesome until you want to lock everything down.
23:08:27 <alexj> sclv: you can control the mapfiles you use.
23:08:28 <skew> but I don't see what that has to do with what goes on behind the scenes
23:08:37 <alexj> you can use multiple mapfiles.
23:08:55 <alexj> the mapfiles can point either to tagged releases, tgz files, or moving target directory hierarchies.
23:09:30 <alexj> skew: the point is not to have to think about anything other than the content of your haskell modules.
23:10:05 <alexj> sclv you also have control over whether you want to use the cache so you can tar up a hierarchy you created dedicated to your app.
23:10:09 <jz87> alexj, I have a question about your code
23:10:22 <jz87> in the Listen.hs file, it references a request function
23:10:33 <jz87> tags isn't finding the right one for me
23:10:53 <alexj> sclv: sp ghc --sp-cache mydir -imyMapFile MyMain.hs --make -o Executable
23:10:59 <jz87> are you reading the request from the socket or the handle?
23:11:33 <alexj> jz87: HAppS.Server.HTTP.Listen?
23:11:38 <sclv> alexj: and then a security-related fix is released for library zed out of alpha-zed with three other libraries depending on it. and i want to update that library and make everything work with it and ignore everything else.
23:12:03 <sclv> I'm not saying I've seen a totally sane way of dealing with these issues in any system...
23:12:05 <alexj> ok so you edit one line of your mapfile and rebuild.
23:12:45 <alexj> sclv: check out the mapfile format http://searchpath.org/default.map
23:13:13 <alexj> see that happs-util isretrieved from tag 0.9.1.2
23:13:28 <alexj> if you modify that to 0.9.1.3 and recompile then it will use the new lib.
23:13:47 <sclv> so we end up with one big hierarchy per app.... hmmm... I guess with disk space and compilation times being less at issue this tradeoff is reasonable for some purposes.
23:13:47 <jz87> nvm, ok I see how you're doing it
23:13:51 <jz87> you're reading from the handle as well
23:14:40 <alexj> sclv: sp does a reasonable job of uniquely identifying libs so if you use the shared cache you are usually just fine.
23:14:41 <jz87> I have a queston though
23:14:50 <jz87> alexj, how come you didn't use the http library?
23:14:57 <jz87> and decided to do your own header parsing
23:15:37 <alexj> jz87: at the time Network.HTTP was very client focused and we were writing a server.
23:15:47 <alexj> I added the client side code today.
23:15:56 <jz87> ah
23:16:06 <jz87> ok, because HTTP has server oriented code now
23:16:16 <alexj> also Network.HTTP was really incompatible with ByteString and LazyByteString
23:16:52 <alexj> it may have been fixed but it had issues for a long time.
23:17:14 <skew> alexj: Would anything be wrong with using a module map to turn includes to packages and then using something like cabal-install behind the scenes to get the code?
23:17:49 <alexj> skew: you can do any shell thing you want in the module maps.
23:18:19 <alexj> notice the "echo hello world" in the default.map
23:19:38 <alexj> searchpath is really just a mapping from module bases to things you need to do to get those modules available to be passed to ghc via a -i command line option.
23:22:21 <jz87> :t liftIO
23:22:23 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
23:22:26 <jz87> :i liftIO
23:23:12 <alexj> goodnight.
23:23:20 <sclv> cheers
23:25:27 <skew> So, has anyone else noticed Olaf Chitil's FPretty?
23:25:44 <jz87> hmm
23:26:49 <jz87> ByteString.Lazy doesn't have gGetLine
23:27:08 <davidL> alexj: you are leaving?
23:27:36 <skew> jz87: check one of the Char8 modules
23:27:39 <alexj> davidL: its 226AM here.  time for me to sleep (if I can).
23:27:59 <alexj> davidL: anything I can do for you in the last moments?
23:28:07 <jz87> nope
23:28:09 <jz87> not in there
23:28:17 <skew> jz87: oh, that's just in strict - with lazy you mght as well use lines
23:28:20 <davidL> quick question do I have to restart happs when I edit the source?
23:28:28 <davidL> or will it do that automagically?
23:28:42 <alexj> davidL searchpath is what automatically restarts.
23:28:50 <jz87> ok, here's the problem
23:28:58 <davidL> ah nice, thanks, sp is working great
23:29:06 <jz87> I'm writing an implementation of the Lazy version of Stream for HTTP
23:29:10 <davidL> good night :)
23:29:16 <jz87> and Stream defines a function readLine
23:29:37 <skew> jz87: if you need to be careful about reading too much you should use strict bytestrings
23:29:39 <jz87> I can't just read a block and then parse it into lines
23:29:42 <jz87> I see
23:30:04 <jz87> what's the difference in performance between strict and lazy bytestrings?
23:30:23 <skew> jz87: or more exactly, read line carefully till you are through the header, then throw them into a lazy bytestring with pack if you want, and switch over
23:30:55 <jz87> ah
23:30:59 <jz87> yes, headers are small
23:31:04 <jz87> so there shouldn't be much of a performance hit
23:31:09 <skew> strict does a whole read at once
23:31:17 <jz87> good idea
23:31:20 <skew> lazy reads nicely (cache?) sized buffers
23:32:02 <jz87> can I convert from strict to lazy bytestrings?
23:32:04 <skew> actually, you should be able to just use hGetContents from Lazy and then split with lines
23:32:14 <jz87> no, that doesn't work
23:32:18 <jz87> because if I read the whole block
23:32:25 <jz87> then the next call to readLine will be messed up
23:32:33 <jz87> I'm writing a function readLine
23:32:38 <jz87> which will be called by the http library
23:32:48 <jz87> and each call should only return 1 line of input
23:33:00 <jz87> if I read more the next call will not return the correct output
23:33:16 <skew> and you want to use a raw Handle for your connection type?
23:33:24 <skew> rather than something that can stash the rest?
23:33:29 <jz87> well
23:33:32 <jz87> what else can I use?
23:34:01 <skew> data Connection = Connection Handle ByteString, if you want
23:34:16 <skew> Handle and strict reading sounds best
23:34:36 <jz87> which package is that in?
23:34:56 <skew> Data.ByteString.Char8 has hGetLine
23:35:12 <skew> Data.ByteString.Lazy.{pack,unpack} convert between lazy and strict
23:35:17 <jz87> ah
23:35:25 <skew> lazy bytestrings are just lazy lists of strict bytestrings
23:36:16 <jz87> well for reading headers, since they're small
23:36:23 <jz87> there should be no problem using strict
23:36:43 <jz87> I imagine the difference comes into play when reading large files
