00:00:37 <lispy> yoshi: look at isDigit
00:01:03 <yoshi> @hoogle isDigit
00:01:04 <lambdabot> Data.Char.isDigit :: Char -> Bool
00:01:59 <lispy> > isDigit 'a'
00:02:03 <lispy> > isDigit '0'
00:02:14 <lambdabot>  True
00:02:14 <lambdabot>  False
00:02:40 <lispy> > isDigit '0'
00:02:40 <lambdabot>  True
00:02:51 <lispy> oh weird, those results came back to my screen in the wrong order
00:03:11 <lispy> > any isDigit "1a2b3c"
00:03:12 <lambdabot>  True
00:03:13 <sjanssen> same here
00:03:47 <lispy> > any (not . isDigit) "1a2b3c"
00:03:48 <lambdabot>  True
00:04:13 <yoshi> =]
00:04:46 <lispy> yoshi: I'm not sure, n >= (fromEnum '.'), does what you expect
00:05:44 <yoshi> yes I'm just noticing that. it will fail in that case
00:06:09 <hpaste>  mmorrow pasted "randTree via (modified) QuickCheck" at http://hpaste.org/5234
00:06:28 <yoshi> > any (not. isDigit) "1.23"
00:06:28 <lambdabot>  True
00:06:45 <lispy> > all isDigit "1a2b3c"
00:06:46 <lambdabot>  False
00:06:50 <lispy> > all isDigit "123"
00:06:52 <lambdabot>  True
00:07:16 <lispy> yoshi: so my guess is that you want all isDigit, when you're checking for numbers
00:07:29 <yoshi> yeha
00:08:27 <sclv> the rjson library is so inspirational. it makes syb look fun.
00:09:26 <lispy> :t splitAt
00:09:27 <lambdabot> forall a. Int -> [a] -> ([a], [a])
00:09:33 <lispy> :t breakAt
00:09:34 <lambdabot> Not in scope: `breakAt'
00:10:02 <lispy> @hoogle [a] -> a -> ([a],[a])
00:10:03 <lambdabot> Data.List.genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
00:15:10 <ibid> BMeph: thanks
00:15:24 <ibid> it seems to have struck some nerves
00:17:11 <lispy> yoshi: > map (\x -> (takeWhile (/= '.') x, drop 1 (dropWhile (/= '.') x)) ) ["", "123", "1", ".1", "1.", "1.2", "12.", ".12"]
00:17:15 <lispy> > map (\x -> (takeWhile (/= '.') x, drop 1 (dropWhile (/= '.') x)) ) ["", "123", "1", ".1", "1.", "1.2", "12.", ".12"]
00:17:16 <lambdabot>  [("",""),("123",""),("1",""),("","1"),("1",""),("1","2"),("12",""),("","12")]
00:17:57 <lispy> yoshi: so, then you could just run your 'all isDigit' test on each part of the tuples
00:18:24 <lispy> > map (\x -> (all isDigit (takeWhile (/= '.') x), all isDigit (drop 1 (dropWhile (/= '.') x))) ) ["", "123", "1", ".1", "1.", "1.2", "12.", ".12"]
00:18:25 <yoshi> haha good idea =]
00:18:25 <lambdabot>  [(True,True),(True,True),(True,True),(True,True),(True,True),(True,True),(Tr...
00:19:07 <lispy> (of course, your 'all isDigit' test is more like, (if all (isDigit x) then x else "")
00:41:17 <dogsson> is jerky head/hand behavior crazy behavior or threatening behavior therefore mental illness? :D thank you
00:52:48 <Twey> Say, how's Haskell's Unicode support?
00:55:02 <dmwit> Haskell was built around Unicode.
00:56:38 <Twey> let „ÅÇ = "foo" in show(„ÅÇ) in GHCi (UTF-8) is an error, is that just GHCi's fault?
00:56:55 <Twey> Oops
00:57:04 <sjanssen> Twey: try putting in a .hs file and see if that works
00:57:15 <sjanssen> (UTF-8 is the only encoding supported, so use that :) )
00:57:15 <Twey> OK, let „ÅÇ = "foo" in show „ÅÇ is too
00:58:18 <Twey> sjanssen, lexical error
00:58:49 <Twey> main = let „ÅÇ = 3 in putStrLn „ÅÇ
00:59:06 <Twey> Er, that's a type error isn't it.  But nevertheless.
00:59:20 <Twey> 's a lexical error first and foremost.  :-)
01:00:46 <Twey> Is there some option I have to pass to GHC to get it to like UTF-8?
01:07:42 <Svrog> nope, no option - it should just work
01:07:52 <dogsson> i stared at a homeless short fat girl like a paki and perverts when i do not "deserve" it. and almost hurt her or raped or or beat her up. i am ugly by the way and colored + dirty and have no balls
01:08:13 <Svrog> but the file may need the byte order mark, not sure
01:13:45 <Twey> Svrog: Nope, even with a BOM it's a lexical error
01:13:52 <Svrog> hmm
01:29:59 <sjanssen> Twey: would you classify that character as a lower case character?
01:30:24 <Twey> sjanssen: It's neither
01:30:58 <sjanssen> so that is one issue -- identifiers must begin with a lower case character
01:31:06 * Twey tries the katakana equivalent, just in case, and finds that doesn't work either.
01:31:24 <Twey> sjanssen: So can't be represented in orthographies without lower-case characters?
01:31:46 <Twey> Nope, even when I prepend "a" to it it doesn't work.
01:31:57 <sjanssen> Twey: hmm, probably something else going on too
01:32:02 <sjanssen> what version of GHC are you using?
01:32:51 <Twey> sjanssen: 6.4.2
01:33:37 <sjanssen> there's the problem -- UTF-8 was added in 6.6
01:33:42 <Twey> Aha
01:33:45 * Twey upgrades.
01:33:51 <sjanssen> maybe 6.8
01:34:01 <sjanssen> yeah, why were you using such an ancient version? :)
01:34:31 <Twey> Installed it ages ago and been having dependency difficulties :-P
01:34:35 <Twey> (Gentoo :-))
01:35:48 <sjanssen> you should upgrade to 6.8 if possible, the compiler is faster and produces faster code
01:36:28 <Twey> sjanssen, got 6.8.2 here, that should do right?
01:37:07 <sjanssen> that's the newest release
01:37:29 <Twey> Good good
01:37:40 * Twey is still waiting for KDE4 in Portage :-\
01:46:22 <dmwit> Wow, I do not envy the Unicode committee.
01:46:28 <dmwit> > maxBound :: Char
01:46:30 <lambdabot>  '\1114111'
01:47:09 <dmwit> ...they have to classify *all* those codepoints as to upper/lower case, space-ness, alphanumeric-ness...
01:47:31 <dmwit> I mean, I'm sure it isn't hard.  But how boring!
01:48:16 <Twey> I don't get it
01:48:24 <jql> prone to errors, too. there have been typos
01:48:36 <Twey> Some characters aren't either upper- or lower-case, for example
01:49:08 <dmwit> That's no problem.
01:49:13 <dmwit> > isUpper '.'
01:49:19 <dmwit> > isLower '.'
01:49:23 <lambdabot>  False
01:49:23 <lambdabot>  False
01:49:27 <Twey> In fact, probably the majority aren't
01:49:39 <Twey> > isUpper '„ÅÇ'
01:49:40 <lambdabot>  Improperly terminated character constant at "'„ÅÇ'" (column 9)
01:49:40 <jql> and the thing with typos... how would you even know you'd made one until sometime down the road someone does a case-insensitive collation and notices that McDonald comes before Mccallister?
01:49:48 <Twey> Egh, fail
01:49:50 <jql> but in gujarti
01:49:57 <Twey> Hah, aye
01:50:04 <Twey> Do you think they have proof-readers?
01:50:17 <dmwit> Actually, it's probably easier to just specify these things as sets.
01:50:33 <Twey> Ah, good point
01:50:35 <dmwit> i.e. the set of upper case characters is "ABCDE..."
01:51:00 <dmwit> Now that I've said it, I'm absolutely certain that is what they do. =P
01:51:03 <Twey> This is interesting
01:51:04 <jql> there are three cases. >:)
01:51:15 <Twey> Hugs.Base> let „ÅÇ = 3 in „ÅÇ
01:51:20 <Twey> ERROR - Undefined data constructor "„ÅÇ"
01:51:22 <vegai> @type "„ÅÇ"
01:51:22 <lambdabot> lexical error in string/character literal at character '\129'
01:51:34 <Twey> Does that mean it's considered upper-case?
01:51:44 <dmwit> jql: mmm, yeah, that could be bad =P
01:51:46 <vegai> in ghci:
01:51:46 <vegai> Prelude> :type "„ÅÇ"
01:51:46 <vegai> "B" :: [Char]
01:51:56 <Twey> If I use katakana „Ç¢, I get ERROR - Syntax error in expression (unexpected symbol "„Ç¢") instead
01:52:51 <Twey> jql, I'm sure there must be orthographies out there that have more
01:53:07 <Twey> Upper/lower case is a Greek thing, I think
01:53:34 <jql> unicode only recognizes three
01:53:38 <jql> upper, lower, title
01:54:28 <Twey> Hm, maybe there aren't then
01:54:42 <Twey> What's title for?
01:55:15 <jql> it's only for strings rather than letters, IIRC
01:55:33 <jql> for, literally, titles. "The Daily Show, with Jon Stewart"
01:58:13 <Twey> Strings rather than letters?
01:58:24 <cjay> this is very weird
01:58:26 <Twey> But Unicode only deals with glyphs
01:58:52 <jql> it specifies collation rules and normal forms and combining characters
01:58:59 <jql> so, not just glyphs
01:59:31 <cjay> how is title-case encoded?
02:00:00 <jql> I think it's just a function, not a different encoding
02:01:56 <jql> heh, google pointed at an old unicode spec that kinda explains the implementation of title http://unicode.org/reports/tr21/tr21-5.html#Case_Conversion_of_Strings
02:01:58 <lambdabot> Title: UTR#21: Case Mappings, http://tinyurl.com/ypo6k7
02:57:08 <Cale> http://upload.wikimedia.org/math/2/9/2/2922879252c9d6d8402dcb267a02cb2e.png -- heh, that is some beautiful typesetting :)
02:57:09 <lambdabot> http://tinyurl.com/35coqd
03:02:44 <Twey> How do I flush output to the console after using putStr?
03:03:24 <Twey> Cale: Cripes xD  What page was that from?
03:03:39 <Cale> From the page defining Graham's number
03:03:54 <Twey> Ah
03:04:13 <Cale> That's the first of a stack of 64 ever larger numbers used to define it.
03:05:40 <Cale> It's already an understatement to say that g_1 is larger than the number of particles in the observable universe. Something along the lines of saying that MacDonalds has sold more than one hamburger.
03:06:18 <Twey> Hahaha
03:06:30 <Cale> You can use hFlush, but it's probably better just to hSetBuffering stdout NoBuffering
03:10:19 <Twey> Where is hFlush defined?
03:10:51 <Cale> System.IO
03:10:51 <Twey> Oh, IO
03:11:07 <Twey> Hmm
03:11:39 <Twey> Now, do I ask what the heck it's supposed to be taking as an argument, or do I assume that the necessity to ask this many questions means I'm not ready to tackle it yet?
03:11:53 <Cale> :)
03:12:02 <Cale> :t hFlush
03:12:04 <lambdabot> Not in scope: `hFlush'
03:12:08 <Cale> Well...
03:12:09 <Vq^> @hoogle hFlush
03:12:09 <lambdabot> System.IO.hFlush :: Handle -> IO ()
03:12:13 <Twey> "Handle"
03:12:14 <cnwdup> What is the best way to solve conflicts between Prelude and System.IO.UTF8? Is there a way to tell ghc: Prefer UTF8 over Prelude and don't complain about multiple function declaration (as Prelude and UTF8 both declare getLine for instance)?
03:12:16 <Twey> Whatever that may be
03:12:22 <Cale> It takes a Handle. You can provide stdout
03:12:38 <Twey> Hmm, OK
03:13:02 <Twey> Um
03:13:04 <Cale> Twey: But the better solution is to just hSetBuffering stdout NoBuffering  at the start of your program, if it's just an interactive console app.
03:13:25 <Cale> Then you never have to flush the buffer.
03:13:29 <Twey> Cale: I'm still learning, and I don't understand that yet, so I'm trying to avoid it :-P
03:14:07 <cnwdup> Ah, hiding is what I am looking for. (-:
03:14:26 <Twey> cnwdup, you can hide things from the Prelude?
03:14:26 <Cale> Twey: Well, this isn't a Haskell-specific thing. Input and output are stored in a buffer which fills up until a larger amount of I/O can be done all at once.
03:14:32 <Cale> Yep
03:14:43 <Cale> import Prelude hiding (foo)
03:14:51 <Twey> Hm, int'restin'
03:14:54 <cnwdup> (=
03:15:06 <Twey> Ohh
03:15:12 <Cale> There are 3 buffering modes you can choose from:
03:15:12 <Twey> hSetBuffering is an action
03:15:14 <Cale> yes
03:15:17 <Twey> OK
03:15:21 <Twey> I understand it now :-P
03:15:23 <Cale> Well, it's a function that produces an action :)
03:15:29 <Twey> I thought it was some magic statement.
03:16:41 <Twey> Heh.  Silly me.  It all works now.
03:16:43 <Twey> Thanks!
03:17:32 <Vq^> interesting that it works with stdin as well, doesn't that require some terminal-specific magic?
03:19:13 <Cale> Well, if your terminal buffers input too, it won't have so much effect.
03:19:40 <Cale> But normally it's the program's responsibility to take care of that, at least as I understand it.
03:20:02 <Cale> (and terminals which buffer input are thus kind of lame)
03:20:54 <Vq^> are you sure? i thought most of them did
03:21:53 <Cale> Well, if they buffered input by default, then "press any key to continue" wouldn't work.
03:23:08 <Vq^> Cale: no it wouldn't, but does it?
03:23:16 <Cale> I think so :)
03:24:14 <Cale> Also, for instance, vim wouldn't work, because pressing individual keys wouldn't do anything until perhaps you pressed enter or something.
03:25:28 <Vq^> Cale: vim uses terminal magic to enter that mode
03:26:17 <Vq^> it's usually some ansi escape-code to stdout to tell the terminal to change behaviour
03:26:38 <Cale> That seems odd.
03:27:08 <Vq^> not that odd
03:27:30 <desegnis> I'd be pretty sure that ancient Unix terminals did their own buffering... and they did have vi, so...
03:27:36 <Vq^> i guess the old terminals couldn't afford to send everything directly
03:28:20 <Cale> I, at least, would consider as broken any terminal which buffered my keystrokes instead of sending them directly to the program I was running.
03:28:29 <lightstep> i think people used ed on stupid terminals and vi on start ones
03:28:42 <lightstep> *smart
03:28:49 <Vq^> it lives on thought, i just tested a very simple read(1,_,1) program and the terminal itself buffers lines
03:28:59 <Vq^> gnome-terminal and rxvt-unicode
03:29:52 <Vq^> lightstep: i think most terminals (even dumb) supports nonbuffering
03:29:57 <Vq^> it just isn't the default
03:30:28 <lightstep> on some linux machines, if the type your username in uppercase when logging in, the terminal would switch to uppercase mode
03:30:54 <idnar> I believe the actual criteria is "if the first character you send is in uppercase"
03:31:10 <idnar> or something crazy like that
03:31:25 <idnar> might be the first line
03:31:45 <idnar> (which would then be essentially equivalent to what you said, of course :P)
03:32:08 <lightstep> those old stupid terminals were very old and very stupid, perhaps. maybe from the 60's
03:32:57 <Vq^> yep, ghci reads the terminfo files
03:33:25 <smtms> man termios if you want to know more about terminal buffering
03:33:33 <Vq^> and at hSetBuffering it sends "\33[?1034h"
03:34:29 <desegnis> Speaking of terminal behaviour... Is it ok that I often experience GHC-compiled programs to react somewhat reluctantly to ^C ?
03:36:15 <desegnis> (I get used to  ^Z kill %1  now because it's more reliable, but that's eight keystrokes more!)
03:37:43 <mux> right, I sometimes have to do the same
03:37:50 <mux> though I use kill %% ;-)
03:38:22 <czakey> its good to kill via %%
03:38:34 <czakey> i mean: not to be killed by %%
03:38:36 <czakey> :P
03:39:03 <idnar> desegnis: does ^\ help?
03:39:23 <Vq^> i think i have experienced the same fenomenon when dealing with threading
03:40:12 <desegnis> idnar, doesn't seem so
03:40:27 <desegnis> mux, thanks, that's easier on the hands :)
03:43:31 <Cale> ah, I see. hSetBuffering also calls setCooked in System.Posix.Internals to ensure that any buffering your terminal is doing doesn't interfere with the mode you set.
04:12:01 <mxc> random question, are any linux distros particularly better or owrse for haskell development?
04:13:20 <Vq^> if i had to guess i would say that gentoo has most and latest haskell packages
04:14:00 <desegnis> mxc, they usually suggest source-driven distributions like Gentoo, because, if you compile everything yourself anyway, it's easy for the distributors to provide you with the latest versions of packages
04:15:15 <Vq^> it's also easy to make own installation-scripts for packages in gentoo
04:19:29 <therp> easy yes, but boring
04:19:33 <Vq^> but as long as the packages you require exists i fail to see how much difference the distribution would make
04:19:55 <Vq^> therp: more enjoyable than many others :P
04:20:04 <therp> hmm true :)
04:20:11 <therp> I guess packaging in general is boring.
04:24:19 <fnord`> hi all
04:25:00 <fnord`> I'm writing a GA that needs random values throughout, any thoughts on the best way to supply them? I'm thinking either a Reader or a State monad
04:25:58 <fnord`> The state monad seems a little more general than maybe I need but the with the Reader monad I think I'd have to introduce a new local binding each time I got a new random value, right?
04:26:33 <audreyt> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
04:26:34 <Vq^> whats wrong with a random monad? :)
04:26:36 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
04:26:43 <audreyt> http://www.haskell.org/haskellwiki/New_monads/MonadRandomSplittable
04:26:44 <lambdabot> Title: New monads/MonadRandomSplittable - HaskellWiki, http://tinyurl.com/yqmpwn
04:26:49 <fnord`> There's a random monad? That would apear to be what I need then
04:26:52 <fnord`> thanks
04:27:29 <audreyt> np :)
04:34:16 <fnord`> Is there a standard version of the random monad anywhere? Or should I just copy and paste from the wiki?
04:35:34 <fnord`> never mind, just found it in hackage
04:46:39 <Feuerbach> dons: what is original source of those fun error messages lambdabot produces? Is it sudo?
04:47:16 <Vq^> i thought it was 2001
04:48:17 <Feuerbach> Vq^: what do you mean?
04:48:52 <Vq^> Feuerbach: http://en.wikipedia.org/wiki/2001:_A_Space_Odyssey_%28film%29
04:48:52 <lambdabot> Title: 2001: A Space Odyssey (film) - Wikipedia, the free encyclopedia
04:51:53 <Feuerbach> Vq^: thanks, several quotes are indeed from there. But not all I think
04:52:22 <Feuerbach> e.g. "And you call yourself a Rocket Scientist!" or "I've seen penguins that can type better than that."
04:54:08 <litb> hello all
04:54:20 <Cale> hello
04:54:21 <litb> i have to understand one thing yet very important:
04:54:28 <litb> :t liftM2
04:54:31 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:54:38 <litb> that's this. but:
04:54:45 <litb> :t liftM2 id
04:54:46 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
04:54:54 <Cale> liftM2 f x y = do v <- x; w <- y; return (f v w)
04:54:57 <litb> how does the id transform the type into the latter one?
04:55:16 <Cale> so...
04:55:23 <Yosusin> http://bitxarraco.myminicity.es/
04:55:24 <Yosusin> http://bitxarraco.myminicity.es/
04:55:25 <Yosusin> http://bitxarraco.myminicity.es/
04:55:25 <Yosusin> http://bitxarraco.myminicity.es/
04:55:25 <Yosusin> http://bitxarraco.myminicity.es/
04:55:26 <Yosusin> http://bitxarraco.myminicity.es/
04:55:28 <Yosusin> http://bitxarraco.myminicity.es/
04:55:30 <Yosusin> http://bitxarraco.myminicity.es/
04:55:31 --- mode: ChanServ set +o Cale
04:55:32 <Yosusin> http://bitxarraco.myminicity.es/
04:55:34 <Yosusin> http://bitxarraco.myminicity.es/
04:55:36 <Yosusin> http://bitxarraco.myminicity.es/
04:55:38 <Yosusin> http://bitxarraco.myminicity.es/
04:55:40 <Yosusin> http://bitxarraco.myminicity.es/
04:55:42 <Yosusin> http://bitxarraco.myminicity.es/
04:55:42 --- kick: Yosusin was kicked by Cale (Cale)
04:55:59 --- mode: Cale set -b Random08!n=ajb@*.alicorna.net
04:56:10 <litb> the steps are that id v returns v, and in effect it valls "v w" ?
04:56:10 <olsner> why so many trolls in #haskell these days?
04:56:20 --- mode: Cale set +b *!*@191.Red-88-16-120.dynamicIP.rima-tde.net
04:56:24 <ivanm> olsner: because it's a big channel with a lot of activity?
04:56:31 <Cale> Also, keeping the banlist full is annoying.
04:57:02 <ivanm> is that the fault of the IRC protocol or freenode?
04:57:10 <litb> Cale: ah i see
04:57:11 --- mode: Cale set -b *!*n=KEAL@unaffiliated/Keal
04:57:22 --- mode: Cale set -b *!i=ubuntu@gateway/tor/x-26e2ccc44e60a27d
04:57:31 --- mode: Cale set -b *!*@CPE00012e15cab1-CM00194757ed42.cpe.net.cable.rogers.com
04:57:46 --- mode: Cale set -o Cale
04:57:48 <litb> Cale: i would have thought because the type of the first parameter is "(a1 -> a2 -> r)" it woudl not accept id at all?
04:57:54 <czShadoW> Oh, ban list here is really big :)
04:58:14 <quicksilver> litb: that is the important thing to notice.
04:58:15 <Cale> litb: the type of id unifies with a1 -> a2 -> r
04:58:28 <Cale> with a1 = a2 -> r
04:58:33 <quicksilver> litb: "r" could be anything
04:58:41 <quicksilver> litb: so try a1 -> a2 -> (a1 -> a2)
04:58:57 <quicksilver> a.k.a  a1 -> a2 -> a1 -> a2
04:59:02 <litb> oh i see
04:59:18 <litb> r could itself be an ordinary  function
04:59:32 <Cale> quicksilver: err...
04:59:36 <quicksilver> erm
04:59:40 <quicksilver> ehem
04:59:47 <quicksilver> I got my brackets wrong :)
04:59:50 <litb> (a1 -> a2) -> a1 -> a2
04:59:52 <quicksilver> try a1 = a2 -> r
04:59:55 <quicksilver> like cale said ;)
04:59:55 <litb> that way dude
05:00:11 <litb> or even yet another way?
05:00:55 <quicksilver> well, if you're trygin to keep the variable names
05:01:01 <quicksilver> it's (a2 -> r) -> a2 -> r
05:01:03 <Cale> (a1 -> a2 -> r) & a1 = a2 -> r   ~~>  (a2 -> r) -> a2 -> r
05:01:07 <quicksilver> but yes, it's that shape.
05:17:39 <Twey> Is there a "list contains" function?
05:18:04 <Japsu> Twey: yes:
05:18:09 <Twey> Ah, any
05:18:10 <Japsu> > 1 `elem` [1,2,3]
05:18:13 <lambdabot>  True
05:18:16 <Twey> Oh?
05:18:21 <Twey> What's the difference?
05:18:37 <Japsu> > 'x' `elem`  "asxz"
05:18:37 <kpreid> @type elem
05:18:38 <Twey> Oh, any takes a function
05:18:38 <lambdabot>  True
05:18:38 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
05:18:39 <kpreid> @type any
05:18:40 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
05:18:42 <Twey> Thanks
05:19:04 <kpreid> elem x = any (x ==)
05:19:07 <Japsu> any (== 'x') "asxz"
05:19:12 <Japsu> > any (== 'x') "asxz"
05:19:13 <lambdabot>  True
05:19:29 <Japsu> @type all
05:19:30 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
05:21:08 <quicksilver> :t find
05:21:08 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
05:21:30 <quicksilver> Twey: find is similar to any but actually returns the one it found
05:22:19 <filcab42> hi
05:22:47 <filcab42> I'm having a little problem with this simple function and can't understand how
05:23:03 <hpaste>  filcab pasted "fix" at http://hpaste.org/5235
05:23:20 <filcab42> it tells me it: Couldn't match expected type `[Char]' against inferred type `Char'
05:23:37 <filcab42> in the first argument of (++) namely `"&quot;"'
05:23:57 <filcab42> but if I try to tell the types of the bindings, I come up with the correct types :s
05:24:08 <resiak> you mean "fixKey' (x:xs)" not [x:xs] in the case
05:24:14 <resiak> erm, before the case
05:24:16 <filcab42> oh
05:24:18 <filcab42> :s
05:24:22 <filcab42> thanks
05:24:25 <resiak> [x:xs] is a one-element list containing the list (x:xs)
05:24:26 <filcab42> damn
05:24:30 <filcab42> sorry 'bout that
05:24:34 <resiak> np.
05:24:46 <roconnor> it's an understandable error
05:24:53 <filcab42> thanks you very much ;)
05:25:17 <Cale> after all, prolog uses syntax like [H|T]
05:25:30 <filcab42> quite
05:25:44 <filcab42> and matlab also does some weird things with the []
05:26:25 <Saizan> i always found prolog list notation confusing
05:26:31 <Twey> Erlang does [H|T] too
05:27:10 <resiak> I still find the need to parenthesise x:xs in "f (x:xs) y = ..." surprising, even though it's consistent and i know why
05:27:35 <quicksilver> I get tripped up by the need to parenthesise constructors pretty often.
05:28:33 <olsner> I didn't find prolog list notation confusing until I learnt haskell
05:28:59 <Saizan> i just can't tell if i'm nesting lists or not
05:32:31 <Twey> resiak: What's it consistent with, and what's the reason behind it?
05:32:35 <Cale> (x:xs):xss <-- nesting lists,  x:(y:xs) <-- not nesting lists. (:) is right associative, so by default, you're not nesting them.
05:33:27 <Twey> Also, what is it about n+k patterns?
05:33:32 <Saizan> Cale: i was talking about prolog :)
05:33:37 <Cale> oh
05:33:45 <EvilTerran> Twey, it's consistent with expressions
05:33:57 <EvilTerran> f x:xs y = (f x):(xs y) in expressions
05:34:06 <litb> it's confusing that some ops are left and some are right associative
05:34:11 <Twey> Oh, I see
05:34:15 <EvilTerran> so it's consistent to make it like that in patterns, too. same for n+k
05:34:22 <EvilTerran> litb, oh, but it's so handy!
05:34:29 <Cale> The idea behind n+k patterns is that it lets you imagine that Integer is actually a recursively-defined natural type.
05:34:56 <EvilTerran> litb, that's only something that's confusing 'til you get used to it
05:35:07 <Cale> It's one of the more controversial features. Some people would like to see it removed.
05:35:08 <Twey> Integer = 0 | 1 | Integer + 1 | Integer - 1 ?
05:35:10 <Vq^> litb: theres always lisp :o)
05:35:22 <litb> o.O
05:35:24 <Twey> (probably pseudo-code, sorry 'bout that)
05:35:28 <Twey> Lisp <3
05:35:35 <Twey> :-)
05:35:37 <litb> i' finished with lisp and its ((()))()())) (ifq)()
05:35:38 <EvilTerran> well, until you end up using two different modules which define the same operator with different precedence/fixity :P
05:35:53 <Twey> litb, but it's very explicit :-)
05:36:01 <Twey> And not at all confusing :-)
05:36:14 <EvilTerran> litb, well, then, don't complain when a language tries to be helpful and gives you precedence and fixity
05:36:25 <litb> i'm not sure whether it has monads arrows and all these nifty stuffs
05:36:34 <EvilTerran> without those, you'd get ((()()((())))) anyway
05:36:38 <Twey> Could probably implement them.
05:36:46 <Twey> It's impure though.
05:36:52 <filcab42> litb you can implement monads and stuff in any (?) functional language
05:36:58 <EvilTerran> Twey, you could, but there's not much point in an impure language, yeah
05:37:01 <filcab42> and lisp is (arguably) functional ;)
05:37:04 <filcab42> though not pure
05:37:05 <vegai> EvilTerran: except with a concatenative language :)
05:37:06 <Twey> Yeah
05:37:16 <EvilTerran> vegai, what
05:37:16 <Twey> filcab42, multi-paradigm
05:37:17 <filcab42> at least I don't know any purely functional lisp
05:37:23 <vegai> like forth...
05:37:27 <Philippa_> EvilTerran: people've found uses for monads in impure langs
05:37:29 <Twey> filcab42, it's possible to write it
05:37:29 * Vq^ regrets that he mentioned lisp
05:37:31 * Cale wonders where this PDF of ATTaPL came from.
05:37:32 <filcab42> yes and, by being multi-paradigm, it's also functional ;)
05:37:42 <EvilTerran> vegai, why are you telling my whis?
05:37:52 <Philippa_> Cale: all of it, or just the ML/HM(X) chapter?
05:37:53 <EvilTerran> vegai, what does your "except" refer to?
05:38:02 <vegai> EvilTerran: < EvilTerran> without those, you'd get ((()()((())))) anyway
05:38:07 <Twey> Yeah, it's nice that it takes a functional approach to multi-paradigm-ism rather than an imperative one like Python or ECMAScript
05:38:08 <Cale> The whole thing.
05:38:13 <Cale> And it's not page scans.
05:38:16 <EvilTerran> vegai, er, I was talking about haskell
05:38:28 <vegai> er, ok.
05:38:45 <EvilTerran> i take it forth is postfix?
05:39:27 * EvilTerran notes RPN wouldn't work with currying
05:39:45 * EvilTerran hesitates to call lisp functional, TBH
05:40:01 <EvilTerran> what is it that makes it functional that isn't covered by perl5's sub{}s?
05:40:27 <Cale> EvilTerran: an obsession with lists? :)
05:40:37 <Cale> But I agree.
05:41:00 <EvilTerran> in fact, i'd say perl manages to do functional more tersely than lisp
05:41:01 <EvilTerran> :P
05:41:49 <EvilTerran> (seriously, the verbosity of lisp puts me right off. "lambda"? "define"? haskell's "\" and "=" are much nicer)
05:42:31 <mxc> haskell needs more practical tutorials
05:42:33 <Saizan> no primitive loops?
05:42:45 <Cale> I'd hesitate to call any language functional which doesn't have function composition in its basic library, and where it's unidiomatic to make frequent use of it.
05:43:01 <mxc> that deal with monads, but from a more practical perspective
05:43:17 <mxc> but not in the cookbook style way that the 'practical' ones do
05:43:17 <Vq^> mxc: in the style of scheme-in-48h?
05:43:17 <mxc> sorry
05:43:35 <EvilTerran> mxc, no pleasing some people, is there? ;)
05:43:37 <mxc> vq^ thats the one tutorial i really liked
05:43:38 <mxc> hehe
05:43:51 <mxc> but still kind of cookbookish
05:43:56 <Vq^> yeah, thats a good one :)
05:44:03 <mxc> my problem might be trying to learn completely independently
05:44:11 <mxc> having someone to teach might have made a huge difference
05:44:12 <matthew-_> in haskell, you can't write a function f :: a -> b can you?
05:44:18 <Vq^> the main problem really is how to design programs in Haskell
05:44:20 <filcab42> Cale: Common Lisp has functional composition in the standard
05:44:27 <filcab42> Scheme may have also, but I don't know
05:44:35 <EvilTerran> mxc, i think most people get a feeling like that at some point in their haskell ccareer. that's why there's so many monad tutorials already.
05:44:36 <dcoutts_> @type let f x = f x in f
05:44:38 <lambdabot> forall t t1. t -> t1
05:44:40 <filcab42> you just don't have currying and have some problems with that
05:44:45 <EvilTerran> matthew-_, only _|_
05:45:00 <mxc> vq^ exactly.  i feel like i have no idea how to structure a program.  try to do all the IO in main and make the rest purely functional
05:45:01 <Cale> filcab42: what's it called?
05:45:04 <mxc> but that seems very un-ideal
05:45:06 <filcab42> compose, I think
05:45:13 <Cale> filcab42: (it's not compose)
05:45:16 <dcoutts_> EvilTerran: you can do better than _|_, you can do const _|_ :-)
05:45:20 <Cale> http://www.lisp.org/HyperSpec/FrontMatter/Alphabetical-C.html
05:45:20 <lambdabot> Title: CLHS: Alphabetical Symbol Index (C)
05:45:22 <filcab42> no, it's not
05:45:22 <kpreid> filcab42: you are misinformed. there is no standard composition
05:45:24 <matthew-_> heh, fix doesn't count ;)
05:45:28 <Philippa_> not necessarily in man
05:45:29 <dcoutts_> > let f x = f x in f `seq` 3
05:45:30 <lambdabot>  3
05:45:31 <Philippa_> main, even
05:45:37 <Vq^> mxc: well, main has to do all IO in one way or another :)
05:45:39 <EvilTerran> filcab42, ah, that goes well with lambda and defun and do-simple-thing-with-as-many-characters-as-possible
05:45:40 <matthew-_> silly haskell and its lack of dependent types...
05:45:42 <Philippa_> just in a thin 'shell' that starts from main
05:45:50 <EvilTerran> dcoutts_, :)
05:46:01 <filcab42> yes, the names are very long, many times
05:46:06 <Vq^> mxc: and as much code as possible should be pure, so it sounds like youre right on track :)
05:46:12 <Cale> http://www.lisp.org/HyperSpec/Issues/iss172-writeup.html -- the very end of this document suggests that the proposal to add COMPOSE was rejected.
05:46:12 <lambdabot> Title: CLHS: Issue FUNCTION-COMPOSITION Writeup
05:46:37 <mxc> vq^ true.  heres one issue i have.  one way i do a lot of debugging is basically with print statements.  but to add thoes to pure functions, would require IO, but output alone shouldnt break referential transparency (exlcuding exceptions)
05:46:38 <Philippa_> matthew-_: you can have dependent types and fix
05:46:53 <mxc> vq^ i have a sizeable amount of ocaml background
05:47:02 <Cale> Also, if it was called COMPOSE, that's pretty unmanageably long.
05:47:15 <Vq^> mxc: it's possible to use trace or unsafePerformIO
05:47:31 <Cale> (at least compared to Haskell's decision to use the . for it)
05:47:32 <Philippa_> mxc: it does break it, just not how you're used to thinking of breaking it. And debug.trace or the GHCi debugger.
05:47:33 <kpreid> Cale: I think CL's lisp-2ness is by itself very discouraging to passing/manipulating functions *casually*
05:47:42 <Cale> kpreid: right
05:47:49 <matthew-_> Philippa_: what I want is f :: Int -> a where a depends on the value of the int. Which I think is, by definition, not possible in Haskell
05:47:49 <suq> Anatomy of Lisp uses . as compose operator
05:48:06 <Cale> suq: That would be nice :)
05:48:16 <mxc> unsafePerformIO doesnt seem safe
05:48:26 <mxc> hehe
05:48:27 <Vq^> mxc: it is safe enough :)
05:48:30 <Cale> mxc: It's not, and you shouldn't use it.
05:48:33 <EvilTerran> matthew-_, indeed not
05:48:35 <mxc> cale - agree
05:48:44 <Philippa_> matthew-_: right, but the literal translation of that type isn't either. It's doable if you use an existential rather than a universal
05:48:47 <Vq^> Cale: never?
05:48:53 <Saizan> matthew-_: f :: Int -> (forall a. a -> r) at max
05:49:14 <Saizan> -> r
05:49:17 <matthew-_> Saizan: yeah, exactly, the CPS solution is what I'm entertaining
05:49:24 <Twey> :t return
05:49:25 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
05:49:30 <Cale> Vq^: Well, you shouldn't use it unless you're absolutely sure that you know how it's going to be compiled. Think of it as a way of extending the evaluation mechanisms in the language without having to recompile GHC.
05:49:47 <filcab42> I know why I thought compose was in the standard
05:49:50 <filcab42> scheme stuff ;)
05:49:56 <Cale> filcab42: :)
05:50:00 <filcab42> don't know if it's in the standard, though
05:50:09 <filcab42> at least MzScheme has it, I'll look it up
05:50:22 <matthew-_> hey, you know how you can stick parens in the type sig and then add in foralls, well is that were you also put further class context? Presumeably, with scoping, it'd have to be there
05:50:44 <Vq^> Cale: we were talking debugging, should i avoid it for that purpose too?
05:50:47 <matthew-_> eg f :: :: Int -> (forall a. (Foo a) => a -> r)
05:51:02 <matthew-_> s/: ://
05:51:03 <Saizan> matthew-_: yes
05:51:12 <filcab42> it's not in the standard. but it's definition is ;)
05:51:23 <matthew-_> Saizan: are these Rank2 or RankN ?
05:51:33 <matthew-_> or neither?
05:51:35 <Cale> mxc: There is Debug.Trace (which uses unsafePerformIO), which *can* be very handy in very specific circumstances in debugging, and at least certain precautions were taken in defining it (it's marked such that it won't be inlined)
05:51:41 <Saizan> Rank2,afaiu
05:51:51 <Cale> But that's not really how you debug Haskell programs for the most part.
05:51:56 <Vq^> Cale: i thought it was "safe" to use as long as the IO didn't have effects which touches the other IO actions
05:53:23 <Cale> Basically, if you really don't care whether the effects are never run, or run arbitrarily many times, or anything about what order they happen in, go ahead. :)
05:53:59 <mxc> @hoogle trace
05:53:59 <lambdabot> Debug.Trace.trace :: String -> a -> a
05:53:59 <lambdabot> Debug.Trace :: module
05:53:59 <lambdabot> Debug.Trace.traceShow :: Show a => a -> b -> b
05:54:21 <Vq^> Cale: of course :)
05:54:23 <Cale> Practically speaking, if you're careful and use NOINLINE pragmas, you can make things reasonably safe at present in GHC.
05:54:49 <Saizan> matthew-_: you may also look at existential types if you don't like the CPS style
05:54:50 <Cale> But you can still break the type system completely and segfault your program with unsafePerformIO
05:55:09 <Vq^> i think i have used it once or twice for reading files which is static during the execution of the program
05:55:38 <Cale> Usually people want to use it for things which just lead to bad program designs.
05:56:19 <Cale> There are legitimate uses in designing fundamental data structures which have a pure interface, but do mutation behind the scenes.
05:56:40 <mxc> alright
05:56:42 <Cale> (like ByteString and Arrays)
05:56:45 <matthew-_> Saizan: I really don't have an issue with CPS - it'll ultimately be generated code
05:56:48 <mxc> i:m going to try my luck setting up a dualboot
05:56:53 <Cale> mxc: :)
05:56:58 <Vq^> good thing it has such an awful name then
05:57:06 <Cale> mxc: Ubuntu is nice if you're starting out with linux.
05:57:15 <litb> i like archlinux
05:57:31 <mxc> not starting out
05:57:33 <mxc> used fc8 for a wihle
05:57:39 <mxc> but, first time tha ti will have to dual boot
05:57:46 <matthew-_> Saizan: though getting better acquainted with existentials too will be a good idea. I've banged my head against the "a escapes from context" issue and the abuse of case and stuff to try and make it work...
05:57:49 <litb> then i think archlinux might be just the right thing for you
05:57:56 <Cale> litb: hm?
05:58:10 <Cale> Most distributions make dual-booting trivial.
05:58:20 <mxc> hm
05:58:25 <mxc> maybe i should stick with fc8 hten
05:58:46 <Cale> I had no additional work to do when installing Ubuntu on my dad's machine to get a dual boot going.
05:58:50 <sizur> i sincerely recommend opensuse
05:58:53 <mxc> allthough, earlier poeple were sugesting gentoo
05:59:24 <Cale> basically, just installed windows (obviously not using up the entire disk), and then installed ubuntu afterward, and it detected the windows install and set things up correctly
05:59:25 <litb> mxc: yeah, what you need is basicially just the right menu.lst , grub and a boot partition for it (well, you don't need this, but it is safer to do so)
05:59:34 <Vq^> mxc: if the packages you use exists for fc8 then it doesn't make much difference
05:59:40 <Cale> Gentoo is for people who don't mind wasting lots of time.
05:59:40 <mxc> yeah
05:59:50 <litb> mxc: but really the linux distro does all this automatically normally
05:59:52 <mxc> m machine blows, dont want to be compiling every package
05:59:56 <Vq^> Cale: lots of computer time that is
06:00:00 <mxc> wihch is why i:m leaning towards fc8
06:00:01 <Saizan> matthew-_: well if you think them as a sort of sugar for the CPS version it makes more sense, the function that pattern match on the existential is like the continuation, it can't restrict the 'a' in any way other than what the class context provides
06:00:01 <Cale> Vq^: right.
06:00:13 <Cale> Vq^: not to mention electricity
06:00:14 <Vq^> Cale: and once a gentoo box is running it's not that bad, is it?
06:00:19 <mxc> do you know if the FC8 installer can defrag the drive before partitioning?
06:00:23 <pjd> does gentoo not have any packages?
06:00:36 <mxc> the windows defragger keeps leaving one peice in the middle of my open space
06:00:42 <Cale> pjd: It has packages, they consist of source code which is compiled.
06:00:45 <Vq^> pjd: it doesn't have any binary packages
06:00:47 <matthew-_> Saizan: yeah sure. I wonder if there's a proof of sound and completeness for existentials <=> CPS
06:00:48 <sizur> i used (k)ubuntu, gentoo, fc8, some italian version of gentoo, freespire, and opensuse
06:00:56 <Cale> And it actually has some binary packages.
06:01:00 <Vq^> pjd: it has ebuild-files scripts which installs packages from source
06:01:04 <mxc> ok
06:01:06 <mxc> gotta run
06:01:07 <Cale> But not as many as you'd want.
06:01:13 <Vq^> Cale: yeah, but they aren't worth talking of
06:01:40 <litb> sizur: oh hehe. what was the best one?
06:01:42 <Vq^> Cale: if you don't mean the -bin pkgs...
06:01:48 <sizur> litb, i say opensuse
06:02:03 <Cale> I really prefer having the developers of the applications I run do the compiling. They wrote the software, let them decide which compiler flags should be set.
06:02:03 <litb> oh i see
06:02:13 <litb> openSuse seem to be much liked by haskell programmers
06:02:23 <Cale> litb: I don't know :)
06:02:46 <sizur> litb, it's not because of haskell
06:02:50 <Vq^> litb: where did you get that from? :P
06:03:14 <litb> it's because two people that i know of being quite good at haskell just love openSuse
06:03:17 <Cale> Ubuntu does have the problem that its release cycle is almost pessimised relative to the GHC release cycle, but it doesn't matter so much because the  generic binary package for GHC is easy to install.
06:04:05 <litb> maybe it is because of the chameleon :)
06:04:27 <sizur> opensuse has community repos, it does help. it takes just a few days before new ghc is up there
06:04:34 <Cale> I like Ubuntu because the default configuration is very close to how I'd configure things ideally anyway.
06:04:42 <Vq^> gentoo has something similar called overlays
06:05:01 <sizur> i use gnome at work, i'm kde guy.
06:05:02 <mux> Cale: a framework building software from source doesn't need to muck with the compiler flags set by the authors, and nor do binary packages guarantee that the builder won't have changed them
06:05:31 <Cale> mux: Sure.
06:05:42 <litb> archlinux has AUR :)
06:05:58 <Cale> mux: But there is still the issue that it's a complete waste of time.
06:06:02 <Vq^> the gentoo-haskell overlay even uses darcs :)
06:06:43 <mux> Cale: I would say this is completely dependent upon point of view; I like to build most of my software, it doesn't take me that much time, and for huge beasts such as OOo, I use packages
06:07:03 <Cale> mux: But why?
06:07:08 <sizur> mux, unless you upgrade your c compiler
06:07:26 <Cale> mux: If you're not going to be making modifications to the source, I really don't see the point in it.
06:07:31 <cdr> dealing with symbol-lookop errors due to distro using diff g++ version than you is a lot more annoying than compiling everyting from source
06:07:35 <mux> Cale: because it allows me to have access upon all sources *very easily*
06:07:40 <mux> I do very often for various reasons
06:07:42 <litb> maybe he likes looking at the compiler output
06:07:44 <mux> sizur: no problems here :)
06:07:52 <Vq^> it also gives control over what gets compiled
06:07:57 <sizur> mux, takes days
06:07:58 <Vq^> support for other libraries for example
06:08:01 <Cale> I have access to all the sources for my packages too :)
06:08:02 <cdr> if your stuff takes longer than 2 seconds to compile (hi dwm) it proably sucks too much anywyas
06:08:09 <mux> and it allows me to custom build stuff, so that it's more lightweight
06:08:33 <sizur> mux, because more than half of your packages must be recompiled
06:08:33 <mux> Cale: when you use a framework that needs the source to begin with, access to those is generally much more convenient
06:08:47 <Cale> If I want to get the source for any debian/ubuntu package, modify, and recompile it, I can do that quite easily.
06:08:57 <mux> sizur: er, no they don't need to
06:09:01 <Cale> It's one command to get the source for any package.
06:09:25 <mux> Cale: I find it much more convenient to insert mods in the FreeBSD ports tree
06:09:34 <mux> I have used debian packages heavily previously, for work
06:09:46 <sizur> well, i like gentoo a lot, i just cannot sit and wait for compilation process anytime i install something
06:09:59 <mux> I'm actually not talking about gentoo :-P
06:10:16 <litb> it's very easy with archlinux. just "find /var/abs -iname <package-name>; cd <the-path>; makepkg --nobuild" and that's it
06:11:35 <Vq^> seems longer than "emerge -b <package-name>" :o)
06:12:17 <filcab42> -b gets the source and unpacks it?
06:12:17 <litb> that is to be multiplied by the fact that archlinux provides binary packages by default
06:12:46 <Vq^> oh, i misinterpretted
06:12:52 <Vq^> filcab42: no, it doesn't
06:12:58 <filcab42> but what does -b do, btw?
06:13:19 <filcab42> normally, if you only want the source you would just emerge -f <package>
06:13:21 <Vq^> filcab42: builds a binary package
06:13:27 <filcab42> the patches are already in the portage tree
06:13:29 <filcab42> oh, right
06:13:30 <litb> oh hehe
06:13:33 <filcab42> never used it :P
06:13:39 <litb> then that is "pacman -S <package>"
06:13:55 <Vq^> no, usually one wants to install it :)
06:14:27 <Jiten> I've got a string that's 1000 characters long. I'd rather split it up on several lines rather than one long line but I can't figure out (or find) the syntax. This is possible, right?
06:14:51 <litb> @type lines
06:14:55 <lambdabot> String -> [String]
06:15:01 <byorgey> Jiten: of course.
06:15:15 <byorgey> > unlines ["a few", "lines", "here"]
06:15:16 <lambdabot>  "a few\nlines\nhere\n"
06:15:24 <kpreid> Jiten: Do you mean in source?
06:15:28 <Jiten> yes, in source
06:15:32 <Vq^> > words "a couple of words"
06:15:33 <lambdabot>  ["a","couple","of","words"]
06:15:42 <kpreid> "abc def \
06:15:42 <kpreid> \ghi jkl'
06:15:48 <kpreid> er, with a double quote at the end...
06:15:52 <litb> > lines "foo\nbar\nbaz"
06:15:52 <lambdabot>  ["foo","bar","baz"]
06:15:57 <kpreid> anyway, like that. surround your line break with \
06:16:06 <kpreid> and you can indent the continuation if you like, too
06:16:08 <quicksilver> I think the \ syntax looks nasty
06:16:17 <quicksilver> I would rather use unlines or concat :)
06:16:25 <quicksilver> matter of taste though
06:16:31 <Vq^> i would probably do the same
06:16:42 <Vq^> it's more similar to the C version too
06:16:44 <Jiten> that unlines is close but line feeds are not good.
06:16:50 <quicksilver> then use concat
06:16:58 <quicksilver> which is like unlines but without linefeeds :)
06:17:12 <quicksilver> > concat ["probably longer","than this","in your real code"]
06:17:16 <Jiten> thank you :)
06:17:17 <lambdabot>  "probably longerthan thisin your real code"
06:18:34 <litb> i wonder how guards look used with lambda abstractions
06:19:37 <litb> that, for example, errors out: (\x | x==1 = 1; | otherwise = 6) 1
06:19:58 <Cale> litb: If you want guards inside a lambda, you'll need to use case
06:20:03 <dcoutts_> @seen nominolo
06:20:03 <lambdabot> nominolo is in #haskell-soc, #ghc and #haskell. I last heard nominolo speak 14h 54m 32s ago.
06:20:27 <byorgey> hiya dcoutts_
06:20:40 <Cale> > (\x -> case x of x | x == 1 = 1 | otherwise = 6) 1
06:20:40 <lambdabot>  Parse error at "=" (column 29)
06:20:48 <Cale> > (\x -> case x of x | x == 1 -> 1 | otherwise -> 6) 1
06:20:48 <lambdabot>  1
06:20:57 <litb> ah i see
06:21:49 <Cale> > (\x -> if x == 1 then 1 else 6) 1
06:21:51 <lambdabot>  1
06:22:48 <dcoutts_> hia byorgey
06:22:55 <dcoutts_> byorgey: how's it going? :-)
06:23:48 <byorgey> dcoutts_: pretty good, thanks =)
06:23:50 <dcoutts_> byorgey: btw, nominolo is also someone to ask about the configurations stuff (since he wrote it)
06:24:00 <byorgey> dcoutts_: right
06:24:10 <byorgey> dcoutts_: your overview of the sources helped a lot yesterday, thanks =)
06:24:22 <dcoutts_> byorgey: great, I'll try and fill in a bit more now
06:24:24 <dcoutts_> byorgey: so what approach are you taking to finding the undefined config flags?
06:24:34 <byorgey> dcoutts_: I've read/skimmed through most of the "non-active" stuff yesterday
06:24:46 <dcoutts_> right
06:25:03 <byorgey> dcoutts_: well, right now I am just trying to figure out where in Distribution.Simple.Configure that stuff actually gets called =)
06:25:18 <dcoutts_> byorgey: right :-) grep helps
06:25:25 <byorgey> dcoutts_: indeed =)
06:25:29 <dcoutts_> grep foobar Distribution/ -R
06:25:54 <byorgey> yep, definitely doing some of that =)
06:26:30 <byorgey> dcoutts_: in theory it seems pretty simple: at some point once the tree of conditions has been built, but before it gets simplified, check to make sure all the vars are defined
06:26:32 <dcoutts_> byorgey: I had a breif look at it a while ago, and yes the tricky part would seem to be finding the right point to insert a check
06:26:34 <byorgey> and if not issue an error
06:26:38 <byorgey> right
06:26:40 <dcoutts_> byorgey: exactly
06:28:11 <byorgey> dcoutts_: well, I plan to work on it more this afternoon (which would be evening for you I suppose)
06:28:24 <dcoutts_> @localtime dcoutts_
06:28:25 <lambdabot> Local time for dcoutts_ is Sat Jan 26 14:28:24
06:28:41 <byorgey> @localtime byorgey
06:28:44 <lambdabot> Local time for byorgey is Sat Jan 26 09:28:41 2008
06:28:47 <byorgey> yep =)
06:29:05 <dcoutts_> byorgey: seems to me that it should be done before the caller gets ahold of a GenericPackageDescription
06:30:01 <litb> hm, maybe i thought wrong of fix.  thought that fix terminates if f x = x
06:30:18 <byorgey> dcoutts_: hm, so you mean while the GenericPackageDescription is being built?
06:30:22 <dcoutts_> byorgey: so that'd imply calling the check from inside parsePackageDescription
06:30:37 <byorgey> dcoutts_: right, ok
06:30:58 <quicksilver> litb: no. It's not that kind of fixed point, exactly.
06:30:59 <dcoutts_> byorgey: in fact it looks like there are some checks there already
06:31:03 <litb> now i have x y = -y , and fix x . i would have expected to get 0
06:31:05 <quicksilver> litb: it doesn't "check for equality"
06:31:15 <byorgey> dcoutts_: oh, so as soon as a flag is encountered, check whether it has been defined
06:31:20 <quicksilver> litb: because you can't "check for equality" on haskell types.
06:31:40 <dcoutts_> byorgey: not necessarily, it might be simpler to do a traversal over the structure at the end
06:31:54 <byorgey> dcoutts_: ok, right, that's what I was thinking originally
06:32:13 <dcoutts_> byorgey: eg, see the maybeWarnCabalVersion check that happens just before returning the final GenericPackageDescription
06:32:23 <byorgey> dcoutts_: ok
06:32:30 <dcoutts_> byorgey: inside parsePackageDescription, that seems like an appropriate place
06:32:32 <byorgey> makes sense
06:32:49 <dcoutts_> byorgey: and that is inside a parse monad so it has good error reporting facilities already
06:33:03 <byorgey> ok, excellent
06:33:09 <dcoutts_> @yarr!
06:33:09 <lambdabot> Shiver me timbers!
06:36:00 <desegnis> litb: ‚Äúfix negate‚Äù is just - ( - ( - ( - ( - ... )))), and that won't terminate (or rather, gives you a stack overflow)
06:37:10 <litb> ah, fix just calls a function infinitely often
06:37:33 <litb> and if it yields the same thing twice in a row, it terminates
06:37:50 <litb> hm, no that is wrong too i suspect
06:38:35 <kpreid> litb: fix f calls f with fix f
06:38:39 <kpreid> there is no termination condition
06:38:41 <desegnis> yeah. you're right about ¬ªinfinitely often¬´, but there is no check for the same thing
06:38:49 <kpreid> > fix (\xs -> 1 : xs)
06:38:51 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
06:39:29 <desegnis> it's up to the laziness of f, or the laziness of the data structure, to give useful results
06:39:41 <kpreid> litb: another way to look at it is that the base case is "f undefined", and (provided that that succeeds) it is applied again infinitely often
06:40:11 <litb> ah i think i'm getting it
06:40:33 <Cale> Just remembering that functions are applied *outermost first* is enough to work out how it works.
06:41:12 <desegnis> The beautiful thing about fix (1:) is that [1,1..] is really a fixpoint, because the infinite list of ones does not change if you prepend 1
06:41:13 <jethr0> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 5
06:41:14 <lambdabot>  120
06:42:07 <Cale> Nor does the Fibonacci sequence change if you take the sums of the initial segments, add one to each, and prepend 0 :)
06:43:06 <jethr0> i never figured out why why the above terminates. or how anything using fix can terminate for that matter
06:43:29 <Cale> jethr0: try evaluating it with, say, 2, as the parameter
06:43:43 <quicksilver> jethr0: because of the if n == 0 case
06:43:44 <Cale> jethr0: Just remember to do all evaluations outermost first, or it won't terminate.
06:43:58 <quicksilver> jethr0: it terminates because it doesn't *always* call the parameter 'fac' again.
06:44:10 <quicksilver> jethr0: there is a case when it doesn't, and that makes it terminate
06:44:14 <Cale> !hpaste
06:44:18 <Cale> !paste
06:44:18 <hpaste> Haskell paste bin: http://hpaste.org/
06:44:37 <jethr0> quicksilver: i see that, but the definition of fix is recursive, so i don't get how it can stop. but i might just as well evaluate it on paper to try it out ;)
06:45:01 <quicksilver> jethr0: fix f = f (fix f)
06:45:09 <quicksilver> jethr0: it's not truely recursive
06:45:19 <quicksilver> jethr0: the recursiveness is 'passed to' f as its first parameter
06:45:29 <EvilTerran> fix (const 1) = const 1 (fix (const 1)) = 1 :)
06:45:30 <quicksilver> jethr0: i.e. \fac, in this example
06:45:30 <jethr0> ah, because the part in parens doesn't have to be evaluated... i'm beginning to see
06:45:45 <quicksilver> jethr0: if the definition of "f" doesn't (always) use its first parameter
06:45:50 <quicksilver> then it may terminate
06:45:56 <jethr0> yup, thanks, that helped a lot
06:46:06 <hpaste>  Cale pasted "one step down the factorial" at http://hpaste.org/5236
06:46:08 <litb> ah i see
06:46:27 <litb> that let x = f x in x doesn't "loop" forever but only pass the f x to f
06:49:04 <byorgey> litb: right, lazy evaluation is key =)
06:49:20 <quicksilver> normal order evaluation is the key.
06:49:25 * desegnis suggests to replace the lambda term by a variable like t when writing it down :)
06:50:38 <jethr0> i'm still a little confused though. in my example "f" is a function of two arguments. why does the first argument become a recursive function?
06:51:01 <jethr0> this kind of thing makes my head hurt. plus it makes me think i'm not all that bright ^_^
06:52:06 <roconnor> typically we write let f = F f to produce a recursive function f.
06:52:19 <roconnor> then F is the ``body'' of the function
06:52:20 <litb> > fix (\x y = if y == 0 then 42 else x (y-1)) 10
06:52:20 <lambdabot>  Parse error at "=" (column 11)
06:52:25 <pejo> jethr0, (side note) you need a different definition of fix for a strict language.
06:52:26 <litb> > fix (\x y -> if y == 0 then 42 else x (y-1)) 10
06:52:28 <lambdabot>  42
06:52:35 <litb> i think i fully got it now :)
06:52:43 <roconnor> F = \f -> (some expression where the recursive calls are marked with f)
06:53:00 <roconnor> > fix (\f y -> if y == 0 then 42 else f (y-1)) 10
06:53:01 <lambdabot>  42
06:54:14 <hpaste>  Cale annotated "one step down the factorial" with "complete evaluation" at http://hpaste.org/5236#a1
06:55:22 <litb> @src fix
06:55:22 <lambdabot> fix f = let x = f x in x
06:56:28 <Cale> (note that the reason that the multiplications aren't evaluated until the very end is that I'm actually leaving out some brackets there, and they're associated to the right -- (*) is strict, so they're always waiting for their right branch to evaluate until the very end)
06:58:13 * RayNbow finally found a page about rotations and 4D space... (man, 4D is just headache inducing :p)
06:58:42 <Cale> 4D is fine. It's infinite dimensional spaces which are troublesome.
06:58:52 <byorgey> o.O
06:59:04 <Botje> just picture an n-dimensional space and set n to 4.
06:59:10 <Cale> exactly :)
06:59:35 <roconnor> aren't all rotations easy
06:59:52 <roconnor> pick a plane, and rotate in it.
07:00:04 <czakey> Ultimate Question: Life the Universe and Everything
07:00:06 <Cale> Even dimensional spaces work a little differently from odd-dimensional ones with regard to rotations though.
07:00:13 <czakey> (in haskell)
07:00:13 <czakey> > fix (\f y -> if y == 0 then 42 else f (y-1)) 10
07:00:14 <lambdabot>  42
07:00:15 <jethr0> roconnor: after grappling for a long time with quaternions, transformation matrices and converting between the two i would say: no
07:00:16 <czakey> :P
07:00:21 <litb> hm, one thing
07:00:47 <roconnor> jethr0: use versors instead.
07:01:49 <jethr0> is that a combination of vectors and tensors?
07:01:50 <litb> it says fix is let x = f x in x , so the first call would be fac' (fac' x) 5 but why is it not?
07:01:58 <dv>  /\^k(V)
07:02:17 <roconnor> jethr0: I'm not sure how the word came about.
07:02:35 <litb> ah i see. it would be fac' fac' fac' but which is itself just fix fac'
07:02:36 <jethr0> i never heard of versors. looking it up on wikipedia.
07:02:44 <Cale> litb: I'm using  fix f = f (fix f)
07:02:59 <phobes> I've never heard of versors either
07:03:08 <phobes> What's a versor?
07:03:47 <jethr0> roconnor: i'm not sure versors are such a good solution.
07:03:52 <Cale> phobes: I just looked it up, apparently that's what some people call unit quaternions.
07:03:59 <jethr0> versors are the x,y and z axis in 3d space
07:04:14 <Cale> What?
07:04:31 <phobes> ah
07:04:42 <jethr0> Cale: sry, might have misread that
07:04:50 <phobes> ah to Cale :)
07:04:54 <roconnor> A gemometric product of vectors is a versor.
07:05:05 <jethr0> geometric product?
07:05:13 <phobes> I hope so :)
07:05:18 <roconnor> the product in geometric algebra.
07:05:27 <roconnor> it is the sum of the inner product and outer product.
07:05:53 <Cale> (the formal sum)
07:06:04 <roconnor> yeah, formal sum.
07:06:37 <jethr0> i know dot product and cross product of two vectors, but geometric product is neither then?
07:06:48 <roconnor> right.
07:06:49 <litb> same here hehe
07:06:53 <roconnor> the dot product is the inner product.
07:06:55 <Cale> I think "unit quaternion" is probably the simplest way to express that :)
07:06:56 <phobes> dot product.. ya
07:07:15 <roconnor> and the cross product is vaguely related to the outer product.
07:07:26 <skorpan> hey guys and gals. i'm having problems compiling cabal-install 0.4.0 and i get a bunch of "not in scope" errors when compiling Hackage.Config
07:07:41 <Cale> actually, that wouldn't necessarily be a unit quaternion
07:07:55 <Cale> It would be an arbitrary quaternion :)
07:08:20 <Cale> skorpan: what's your GHC version?
07:08:24 <roconnor> Cale: for 3-D space I think that is correct.
07:08:28 <skorpan> Cale: 6.8.2
07:08:40 <roconnor> Cale: but if you want 4D space ...
07:08:41 <Cale> !paste
07:08:42 <hpaste> Haskell paste bin: http://hpaste.org/
07:09:04 <phobes> Rotation in 3D space can be identified with the action of unit quaternions, right?
07:09:12 <Cale> phobes: yeah
07:09:38 <roconnor> http://www.science.uva.nl/ga/files/cga-1.pdf
07:09:53 <Cale> (x,y,z) |-> xi + yj + zk defines a correspondence between vectors in R^3 and quaternions with zero real part.
07:10:18 <Cale> Conjugation by unit quaternions then results in rotations. (and it leaves that subspace fixed)
07:10:34 <phobes> ya
07:10:34 <roconnor> the action of a versor v on x is v*x*v^-1.
07:10:54 <phobes> that's how quaternions are applied as well
07:10:57 <roconnor> so the magnitude of the versor is cancled.
07:11:05 <phobes> iirc
07:11:35 <roconnor> so the versor, (or quaternions) don't need to be unit.
07:11:55 <phobes> But normalizing to unit gives you an isomorphism
07:12:06 <roconnor> probably
07:12:06 <Cale> Not quite.
07:12:12 <roconnor> or right, the double cover
07:12:17 <Cale> yes
07:12:22 <roconnor> the action of v and -v are the same
07:12:27 <roconnor> they differ only by a scalar.
07:13:23 <phobes> Makes sense, since RP2 isn't orientable
07:13:38 <roconnor> jethr0: anyhow, versor are a good solution because they are basically the generalization of quaternions to higher dimension spaces.
07:14:05 <jethr0> k, thx
07:15:05 <Cale> I think a more common name for this is the exterior algebra, or Grassmann algebra.
07:15:12 <roconnor> well, I guess versors are more general
07:15:17 <roconnor> they can do reflections as well.
07:15:33 <roconnor> Cale: Clifford Algebra.
07:16:13 <roconnor> Geometric Algebra is in some sense a restriction of Clifford Algebra.
07:16:41 <dejones_> what is the equivalent to C printf("test = %d", test) in Haskell?
07:16:50 <Cale> The exterior algebra is what you get when you take Cl(V,0)
07:16:51 <phobes> Exterior algebra is just about wedge products and such
07:17:10 <roconnor> because the components of elements in Geometric Algebra for the middle grades are always blades.
07:17:11 <Cale> So what does the Q /= 0 do for you?
07:17:19 <davidL> :t printf
07:17:20 <lambdabot> forall r. (PrintfType r) => String -> r
07:17:40 <Cale> davidL: printf is frighteningly polymorphic :)
07:17:43 <dejones_> davidL: oh, I didn't see a printf
07:17:48 <phobes> Cale:  Cl?
07:17:49 <dejones_> * Haskell printf
07:17:56 <Cale> phobes: Clifford algebra
07:17:59 <litb> @undo do { x <- (\q -> 2*q); y -> (\q -> 3*q); return x * y }
07:17:59 <lambdabot>  Parse error at "->" (column 26)
07:18:04 <roconnor> I'm not sure we should be teaching people printf.
07:18:08 <litb> @undo do { x <- (\q -> 2*q); y <- (\q -> 3*q); return x * y }
07:18:08 <lambdabot> (\ q -> 2 * q) >>= \ x -> (\ q -> 3 * q) >>= \ y -> return x * y
07:18:35 <roconnor> print ("test ="++show test) is a more resonable Haskell version of that C statement.
07:18:51 <dejones_> roconnor: thanks :)
07:19:12 <roconnor> dejones_: I forgot a space after the =
07:19:13 <RayNbow> roconnor: doesn't print add quotes around strings?
07:19:26 <dejones_> roconnor: that's fine, thanks again
07:19:26 <roconnor> RayNbow: oops, you are right
07:19:28 <phobes> Cale:  ah ok
07:19:29 <phobes> thx
07:19:37 <roconnor> putStr ("test = "++show test) is a more resonable Haskell version of that C statement.
07:19:55 <dejones_> roconnor: it worked, thanks.  :)
07:20:21 <Cale> Ah, okay, so the exterior algebra and geometric algebras are sort of the two natural subcases of Clifford algebras.
07:20:23 <dejones_> roconnor: I did 'print("test = " ++show test)'
07:20:34 <RayNbow> > print "test"
07:20:35 <lambdabot>  <IO ()>
07:20:37 <Cale> The exterior algebra is what you get when the associated quadratic form is 0
07:20:38 <RayNbow> oh wait
07:20:40 <dejones_> thank you roconnor and davidL
07:20:51 <roconnor> dejones_: print will put "'s around the output.
07:21:06 <roconnor> (when what you are printing is a string)
07:21:51 <dejones_> roconnor: ahh, yah, thanks again.
07:21:52 <dejones_> :)
07:21:52 <Cale> and geometric algebras result from nondegenerate quadratic form (one with trivial kernel)
07:21:53 <RayNbow`afk> hmm
07:22:54 <roconnor> Cale: the structure under consideration is more or less the same for all these things, it is the operations under consideration that differ.
07:22:55 <RayNbow`afk> linking nicknames is a bit different on Freenode :p
07:23:19 <dejones_> is there any way to confirm your answer is correct for Project Euler problems?
07:23:37 <Axioplase> dejones_: run it and compare results?
07:23:53 <Cale> roconnor: Well, it's the Clifford algebra construction :)
07:24:01 <dejones_> Axioplase: hmm, maybe I should have registered first to see if there is more info provided.
07:24:03 <Cale> (with different special cases taken)
07:24:39 <davidL> dejones_: once you have created an account you can submit answers for checking
07:25:00 <dejones_> davidL: yah, just figured that one out.  ;)
07:25:06 <Cale> With the geometric algebra case, you get a proper inner product on the algebra.
07:25:35 <Cale> Whereas with the exterior algebra case, the Clifford scalar product reduces to 0.
07:26:39 <roconnor> Cale: oh wait, I don't know what an exterior algebra is.
07:26:58 <roconnor> I was thinking Geometric, Clifford and Grassman algebras.
07:30:27 <phobes> I think Grassman algebra = Exterior algebra?
07:30:46 <phobes> Grassmann*
07:33:06 <roconnor> I need a diagram explaining all these algebras.
07:39:11 <sieni> http://forums.spacebattles.com/archive/index.php/t-51628.html
07:39:13 <lambdabot> Title: funny letter [Archive] - SpaceBattles.com
07:39:17 <sieni> oops
07:39:22 <sieni> wrong channel :-)
07:41:27 <jorgedbucaran> hi
07:42:25 <Cale> hello
07:43:01 <Cale> sieni: yeah, I've seen that before, it's great :)
07:43:14 <jorgedbucaran> is this Cale?
07:43:18 <Cale> yep
07:43:28 <jorgedbucaran> as in Cale Gibbard?
07:43:30 <Cale> yeah
07:43:31 <sieni> "why can't I own canadians?" :-D
07:43:36 <jorgedbucaran> omg
07:43:48 <Cale> Am I famous?
07:43:53 <jorgedbucaran> dude
07:44:02 <jorgedbucaran> hahaha
07:44:19 <Cale> Did I post something on your blog recommending that you come here?
07:44:22 <jorgedbucaran> I will just say it: Can you help me get started the wrong way with Haskell?
07:44:38 <Cale> The *wrong* way?
07:44:42 <jorgedbucaran> I've read posts of you on forums as well as seeing your Monads tutorials...
07:44:47 <Cale> ah, okay
07:45:20 <Cale> There are much more famous Haskellers who hang around here at times as well :)
07:45:24 <jorgedbucaran> yes the wrong way, because I am starting on Haskell you see, I even started a blog XD because I am actually enjoying the journey, jorgebucaran.wordpress.com
07:45:38 <Cale> ah, cool :)
07:46:11 <Cale> So I take it you've seen my Monads as Computation and Monads as Containers articles?
07:47:02 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO
07:47:04 <Cale> http://haskell.org/haskellwiki/Monads_as_computation
07:47:04 <jorgedbucaran> sorry, back.
07:47:05 <Cale> http://haskell.org/haskellwiki/Monads_as_containers
07:47:18 <jorgedbucaran> the thing is, I am doing some tutorials but the reason I started is because another friend who has to decipher some code
07:47:28 <jorgedbucaran> (yes Cale those ones)
07:47:47 <Cale> ah, is it for that Mod-X thing?
07:48:10 <jorgedbucaran> so I am following a *right* way, at my own pace. but at the same time I am trying to help him with this hardcore thing.
07:48:34 <jorgedbucaran> Mod-X ?
07:48:36 <jorgedbucaran> no idea what you are talking about.
07:49:11 <Cale> It's a site with a bunch of security puzzles. One of the puzzles involves deciphering some broken Haskell code.
07:49:26 <jorgedbucaran> oh well that's far beyong my reach
07:49:35 <jorgedbucaran> I'm stuck with the basics
07:49:47 <jorgedbucaran> you see I thought I was greast 'cause I knew a lot of imperative code...
07:50:08 <Cale> Oh, I was just thinking that might have been what you were referring to your friend deciphering :)
07:50:19 <jorgedbucaran> but I only realize now that I am a baby, I know so little on functional programming...
07:50:37 <jorgedbucaran> hehe, what irc client you use by the way?
07:50:42 <Cale> X-Chat
07:50:52 <jorgedbucaran> have you seen chatzilla?
07:50:55 <Cale> yep
07:51:01 <jorgedbucaran> cool eh?
07:51:35 <jorgedbucaran> anyway would you mind if I fire some questions?
07:51:44 <Cale> Sure, go right ahead :)
07:52:32 <jorgedbucaran> mapReduce
07:52:38 <jorgedbucaran> do you about it?
07:52:40 <Cale> yeah
07:52:54 <Cale> At least I know the general idea.
07:53:36 <jorgedbucaran> well my friend is to understand some code about it! I know that is way beyond my reach now but I said I'll help him, plus could be a good reason to get started on Haskell. (the wrong way, but after that I am sure will continue with other tutorials)
07:54:20 <jorgedbucaran> so first we have this:
07:54:20 <jorgedbucaran> module MapReduce.Basic ( mapReduce ) where
07:54:20 <jorgedbucaran> import Data.Map (Map,empty,insertWith,mapWithKey,filterWithKey,toList)
07:54:20 <jorgedbucaran> what is that?
07:54:36 <Cale> Well, that says we're working on a module called MapReduce.Basic, which has a single export called mapReduce
07:54:53 <jorgedbucaran> is this module compiled or a source file?
07:54:54 <Cale> It imports functions from a library Data.Map (which is a finite map implementation)
07:55:08 <Cale> This is a source file. If it were compiled, it would be gibberish.
07:55:33 <Cale> (but it will eventually be compiled by the Haskell compiler of course :)
07:55:34 <jorgedbucaran> I mean, this importing is from another source file, so that file is available.
07:55:44 <Cale> Ah, Data.Map is a standard library.
07:55:58 <jorgedbucaran> part of Haskell standard implementation?
07:56:13 <Cale> It comes with GHC in an already compiled form, but you can read the source online, or in the GHC source.
07:56:27 <jorgedbucaran> I see, why is Map instead of map?
07:56:40 <Cale> It's kind of semi-standard. It's not in the Haskell-98 standard, but all the Haskell implementations support it.
07:56:45 <jorgedbucaran> I know the map function but since there reads Map I am confused if it has anything to do with it.
07:56:51 <Cale> This is different.
07:57:11 <Cale> Data.Map is a module defining a data structure for representing functions on a finite domain.
07:57:22 <Cale> (using balanced binary trees internally)
07:57:32 <Cale> Like a dictionary or hash.
07:57:34 <jorgedbucaran> alright
07:57:39 <jorgedbucaran> yeap
07:57:47 <filcab42> hi, I'm having a problem, compiling with ghc
07:57:49 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
07:57:51 <jorgedbucaran> so module ... where import...
07:57:51 <lambdabot> http://tinyurl.com/34gle9
07:57:54 <filcab42>     module `main:Main' is defined in multiple files: x.hs x.hs
07:58:01 <filcab42> how is he getting the two file?
07:58:08 <Botje> filcab42: how are you invoking ghc?
07:58:20 <filcab42> ghc -I... -L... -main-is --make -o x x.hs
07:58:49 <jorgedbucaran> cale: so this syntax? module specifies what module to import and *import* actually selects wich function to get from it?
07:59:02 <filcab42> jorgedbucaran: yes
07:59:16 <Cale> jorgedbucaran: No, module declares the current module name
07:59:25 <Cale> and import declares a module to import things from
07:59:33 <jorgedbucaran> ohhhh
07:59:34 <filcab42> Cale: but you can give an export list to module, right?
07:59:40 <Botje> filcab42: why the "-main-is" ?
07:59:41 <Cale> yes
07:59:42 <Cin> what do you guys think of literate programming?
07:59:54 <filcab42> Botje: it was in the tut for FFI I was following
07:59:54 <filcab42> wait
07:59:56 <Cale> the export list follows the module name in parens
07:59:57 <jorgedbucaran> so what is the mapReduce between parenthesis and the where keyword?
07:59:59 <filcab42> http://haskell.org/haskellwiki/FFI_Introduction
08:00:09 <filcab42> section 5
08:00:46 <Cale> jorgedbucaran: What (optionally) follows the module name is a parenthesised list of all the functions and values that it exports.
08:01:08 <Botje> filcab42: note how there's a module name after the -main-is
08:01:15 <Cale> The 'where' is just syntax -- the idea behind it is that everything that follows in the file is inside the module.
08:01:19 <filcab42> :s
08:01:21 <Botje> filcab42: and I don't think the -main-is is needed if you already have a module named Main
08:01:22 <filcab42> sorry
08:01:26 <Botje> try removing the -main-is
08:02:11 <jorgedbucaran> oh my
08:02:14 <Cale> (You can't currently put more than one module in a single file, but if you could, then it would make more sense)
08:02:19 <jorgedbucaran> so what is this?
08:02:21 <jorgedbucaran> mapReduce .: forall k1 k2 v1 v2 v3.
08:02:21 <filcab42> nice
08:02:23 <jorgedbucaran> Ord k2
08:02:24 <jorgedbucaran> => (k1 -> v1 -> [(k2,v2)])
08:02:25 <filcab42> it worked, thanks ;)
08:02:26 <jorgedbucaran> -> (k2 -> [v2]) -> Maybe v3)
08:02:27 <jorgedbucaran> -> Map k1 v1
08:02:30 <jorgedbucaran> -> Map k2 v3
08:02:31 <jorgedbucaran> mapReduce mAP rEDUCE =
08:02:32 <jorgedbucaran> reducePerKey
08:02:33 <mauke> spam
08:02:34 <jorgedbucaran> . groupByKey
08:02:36 <jorgedbucaran> . mapPerKey
08:02:38 <jorgedbucaran> filcab42: can you stay around?
08:02:40 <Cale> jorgedbucaran: please...
08:02:41 <Botje> jorgedbucaran: ARGH. please use hpaste.org
08:02:43 <filcab42> yes
08:02:47 <Cale> !paste
08:02:47 <hpaste> Haskell paste bin: http://hpaste.org/
08:02:49 <mauke> jorgedbucaran: or put it all on a single line
08:03:01 <jorgedbucaran> auch I am sorry
08:03:07 <jorgedbucaran> what happened? I have no idea
08:03:21 <Cale> http://hpaste.org/new
08:03:31 <Lemmih> jorgedbucaran: You pasted ten lines of code.
08:03:44 <filcab42> how do I unmarshall a CString?
08:04:02 <jorgedbucaran> is that wrong?
08:04:06 <mauke> filcab42: http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-String.html
08:04:07 <lambdabot> http://tinyurl.com/3454mw
08:04:07 <Lemmih> filcab42: See Foreign.C.String
08:04:15 <filcab42> thanks
08:04:27 <Cale> filcab42: Specifically, peekCString
08:04:35 <jorgedbucaran> I am clueless, I need help with understanding that code. It's longer but I only picked a little of it.
08:04:50 <Cale> jorgedbucaran: Where is the code from?
08:05:04 <jorgedbucaran> http://www.cs.vu.nl/~ralf/MapReduce/paper.pdf
08:05:05 <jorgedbucaran> page 17
08:05:23 <Lemmih> jorgedbucaran: Learning Haskell might help.
08:05:29 <Cale> Heh, I wonder if Ralf is here :)
08:06:24 <jorgedbucaran> Lemmih: Sure, this is the wrong way, but can you help me understand that?
08:06:59 <Cale> jorgedbucaran: What about it in particular would you like to know?
08:07:07 <jorgedbucaran> it's not like I won't return here, I am actually considering learning Haskell for real, but I need to get this finished.
08:07:12 <Cale> jorgedbucaran: First of all you had a type declaration...
08:07:40 <jorgedbucaran> well, first the type of the mapReduce function, I don't know what it is, is just too long
08:07:42 <jorgedbucaran> mapReduce :: ????
08:08:23 <Cale> which appears misparenthesised...
08:08:27 <litb> guys, i think i understand do { x<-(2*); y<-(3*); return (x*y); } $ 10 now, it's really amazing how everything fits together
08:08:32 <Cale> litb: :)
08:08:49 <Cale> jorgedbucaran: Well, first of all, let's try understanding some much simpler types.
08:09:23 <Cale> jorgedbucaran: It'll be basically impossible to start with that one :)
08:09:24 <jorgedbucaran> ok I hear you
08:09:32 <litb> :)
08:09:51 <Cale> So, length is a good example:
08:09:56 <Cale> length :: [a] -> Integer
08:10:01 <Cale> length [] = 0
08:10:07 <Cale> length (x:xs) = 1 + length xs
08:10:13 <jorgedbucaran> got that one
08:10:19 <jorgedbucaran> actually I have a question there
08:10:30 <Cale> Now, really, that means   length :: forall a. [a] -> Integer
08:10:37 <jorgedbucaran> what is xs? is that a standard?? way to represent all types?
08:10:42 <litb> don't be confused about (xy:x) it is not a tuple
08:10:49 <litb> jorgedbucaran: it means lots of x
08:10:52 <litb> x'ses :)
08:10:53 <jorgedbucaran> what is x?
08:10:56 <jorgedbucaran> any type?
08:11:03 <Cale> x is any value
08:11:19 <Cale> xs is any list of values each of which have the same type as x
08:11:24 <litb> jorgedbucaran: xs is a list of the type of x i think
08:11:38 <jorgedbucaran> so that is like generic?
08:11:47 <jorgedbucaran> a way to generalize the input of the function
08:11:53 <Cale> (note that we usually add an s to the end of names of list variables, because they're plural)
08:12:01 <jorgedbucaran> whatever I send there will be handle okay
08:12:15 <jorgedbucaran> (yeah I read that, just didn't get the x any-type thing)
08:12:28 <litb> it's like template<typename T> void swap( T a, T b[10]); in cpp :)
08:13:00 <Cale> Every list in Haskell is either the empty list, [], or it's a nonempty list with first element x, and with tail xs which we write (x:xs)
08:13:04 <jorgedbucaran> you ROCK!!
08:13:28 <jorgedbucaran> length :: forall a. [a] -> Integer
08:13:30 <jorgedbucaran> so it takes a single a or a list of a and returns an int_
08:13:40 <Cale> It specifically takes a list of a
08:13:41 <Axioplase> no
08:13:48 <litb> it takes a list of a indeed
08:13:57 <jorgedbucaran> what is . for?
08:13:59 <Cale> (that list may have zero or more elements)
08:14:12 <idnar> jorgedbucaran: that's part of the forall
08:14:12 <Cale> The . just separates the forall from the rest of the type signature
08:14:15 <Axioplase> "forall a . foo ""whatever a is, then foo"
08:14:34 <litb> jorgedbucaran: (x:xs) means that list has at least 1 argument : x could be some argument, and xs could be the empty list [] . but it cannot have fewer argument. for that case, there is the length [] = above it
08:14:46 <Cale> For any type a, length takes a list of values of type a, and produces an Integer.
08:15:00 <litb> s/argument/element/
08:15:09 <Cale> litb: I was about to suggest that :)
08:15:24 <litb> o.O
08:15:38 <Cale> litb: (I mean the s/argument/element/ thing)
08:15:54 <Cale> So, let's see how length works on a small list before we check out some other simple examples
08:15:54 <jorgedbucaran> but why a . [a] ?
08:16:17 <jorgedbucaran> how can I understand that? from a imperative point of view?
08:16:23 <litb> jorgedbucaran: read it: "(forall a.) [a] -> Integer"
08:16:27 <Cale> If t is any type, then [t] is the type of lists of values with type t
08:16:41 <jorgedbucaran> mmmm
08:16:42 <litb> jorgedbucaran: it simply says that every type is allowed
08:16:50 <jorgedbucaran> so it's like [a] -> Integer
08:16:50 <Cale> For example, [Char] is a list of characters
08:16:58 <Cale> [Integer] is a list of integers
08:17:04 <jorgedbucaran> but also saying that a can be of any type.
08:17:07 <Cale> jorgedbucaran: exactly the same thing, in fact
08:17:11 <Axioplase> jorgedbucaran: never had a logic course at school ?
08:17:17 <litb> lolz
08:17:17 <Cale> jorgedbucaran: If you leave out the forall, it's implied.
08:17:30 <jorgedbucaran> so without the forall it would be?
08:17:30 <litb> anyway i don'T understand that "forall x" thing yet. i never have used it :)
08:17:59 <jorgedbucaran> length :: [a] -> Integer
08:18:01 <litb> jorgedbucaran: it's just "length :: [a] -> Integer" then
08:18:11 <Cale> jorgedbucaran: Without the forall, the compiler would just put the forall in for you. It's not necessary, but sometimes nice to write explicitly.
08:18:14 <litb> you get to the arrow
08:18:33 <jorgedbucaran> I see, and what is that point again for?
08:18:44 <jorgedbucaran> I read it was like combining functions
08:18:45 <Axioplase> ponctuation
08:18:46 <litb> i don't understand why it isn't forall a => [a] -> Integer tho
08:19:05 <Cale> litb: because quantifiers don't normally work like that :)
08:19:08 <mauke> litb: because => is for type classes
08:19:14 <Axioplase> jorgedbucaran: it helps your brain and the compiler parse the sentence...
08:19:33 <litb> i know, but then we could say "for all type classes" and that would be without restrictions then
08:19:40 <jorgedbucaran> litb: hehe, okay
08:19:42 <litb> or is there some restriction i don't know yet?
08:19:47 <Cale> jorgedbucaran: Remember this is a type signature. Haskell is actually two languages: a value language, and a type language
08:19:58 <Cale> jorgedbucaran: (.) in values is function composition
08:20:07 <Botje> we hope to eventually turn it into an awesome language.
08:20:21 <litb> hehe
08:20:31 <tumdum> like it isn't already ;)
08:20:48 <Botje> Haskell is going to be the Chuck Norris of programming languages.
08:20:50 <jorgedbucaran> it's different and awesome, that's for sure
08:21:00 <jorgedbucaran> and who will be Bruce Lee?
08:21:10 <pejo> Botje, a fist under the beard?
08:21:13 <jorgedbucaran> Cale: anyway, you were saying?
08:21:37 <Cale> jorgedbucaran: well, the . in the type here is just separating punctuation :)
08:21:43 <litb> darn, there must be something for Bruce too. maybe it is nextGenHaskell then
08:21:52 <Cale> It's completely unrelated to the function composition .
08:22:17 <jorgedbucaran> mmm so in this time . just acts to let me put both things on the same line?
08:22:23 <litb> how would it look like if you were to place restrictions?
08:22:32 <litb> foronly ... or something?
08:22:38 <Cale> jorgedbucaran: Well, it helps the parser parse things, yeah. You can't leave it out.
08:22:53 <Cale> jorgedbucaran: (but you can incidentally leave the entire  "forall a." out
08:22:55 <Cale> )
08:22:55 <jorgedbucaran> alright.
08:23:03 <jorgedbucaran> :D thanks god
08:23:23 <mauke> litb: you can't place restrictions unless they're typeclasses in which case the syntax is =>
08:23:25 <pejo> litb, use a typeclass
08:23:27 <Cale> foralls really only become important when they occur *elsewhere* in a type
08:23:38 <Cale> But let's not deal with that right now :)
08:23:42 <filcab42> is it possible to ave a CString without getting involved in the IO Monad?
08:23:43 <jorgedbucaran> ok ok
08:23:50 <Cale> filcab42: no
08:23:51 <litb> i see. so forall a. is only used ot underline that there are no typeclass restrictions on the type?
08:23:59 <litb> reverse [o,t]
08:24:01 <Cale> jorgedbucaran: So, how about the map function :)
08:24:02 <filcab42> hmm
08:24:05 <mauke> litb: no
08:24:09 <Cale> map :: (a -> b) -> [a] -> [b]
08:24:17 <mauke> litb: forall is used to introduce type variables
08:24:35 <Cale> (or equivalently,  map :: forall a b. (a -> b) -> [a] -> [b])
08:24:35 <litb> ah, i understand
08:24:45 <mauke> show :: forall a. (Show a) => a -> String
08:25:03 <jorgedbucaran> oh my. enlight me
08:25:08 <litb> hehe
08:25:09 <mauke> :t runST
08:25:12 <lambdabot> Not in scope: `runST'
08:25:13 <Cale> Okay, so map takes two parameters
08:25:17 <litb> @src map
08:25:17 <lambdabot> map _ []     = []
08:25:17 <lambdabot> map f (x:xs) = f x : map f xs
08:25:36 <Cale> The first parameter is a function of type a -> b
08:25:40 <litb> @yaht
08:25:41 <lambdabot> Maybe you meant: fact part yarr
08:25:44 <Cale> the second parameter is a list of values of type a
08:25:51 <Cale> and it produces a list of values of type b
08:26:25 <mauke> > map (* 2) [1,4,6,9]
08:26:27 <lambdabot>  [2,8,12,18]
08:26:48 <litb> > map Char.toUpper "i am upset"
08:26:49 <lambdabot>  "I AM UPSET"
08:26:50 <jorgedbucaran> so (* 2) is interpreted as a function?
08:27:01 <Cale> Yes, that's the function which multiplies things by 2
08:27:04 <jorgedbucaran> yeah I got that is like a callback
08:27:05 <skorpan> > takeWhile (not . null) [1..]
08:27:05 <lambdabot>   add an instance declaration for (Num [a])
08:27:05 <lambdabot>     In the expression: 1
08:27:06 <Cale> > (* 2) 5
08:27:07 <lambdabot>  10
08:27:14 <litb> (notice that "foo" is of type [Char] :))
08:27:15 <jorgedbucaran> like a foreach
08:27:28 <dino-> :t (* 2)
08:27:28 <lambdabot> forall a. (Num a) => a -> a
08:27:30 <jorgedbucaran> correct?
08:27:36 <Cale> jorgedbucaran: sort of, yes :)
08:27:50 <litb> jorgedbucaran: (*) takes 2 params but you gave it only one. so it still requires one when you do (2*) :)
08:27:55 <jorgedbucaran> what is =>?
08:27:56 <jorgedbucaran> (hehe don't laugh at my silly analogies)
08:28:12 <jorgedbucaran> oooh so the operator is like the function?
08:28:17 <jorgedbucaran> so I am passing the function *
08:28:19 <mauke> operators are functions
08:28:31 <jorgedbucaran> which is * a b = a * b
08:28:33 <jorgedbucaran> ?
08:28:37 <jorgedbucaran> kinda?
08:28:38 <litb> sure, you pass a partially applied function
08:28:39 <Cale> (*) a b = a * b
08:28:51 <mauke> (*) a b is the same as a * b
08:28:58 <jorgedbucaran> in posfix
08:29:01 <mauke> conversely, f x y is the same as x `f` y
08:29:03 <jorgedbucaran> wow this is sweet
08:29:07 <Cale> (You can wrap any infix operator in parens to make it prefix)
08:29:14 <Cale> > (*) 3 5
08:29:14 <lambdabot>  15
08:29:15 <litb> (infix) a b = a `postfix` b
08:29:21 <mauke> litb: wtf?
08:29:24 <litb> errm, prefix
08:29:26 <mauke> ITYM prefix/infix
08:29:39 <Cale> f a b = a `f` b
08:29:47 <jorgedbucaran> alright, so I got map
08:29:47 <mauke> > 10 `mod` 3
08:29:48 <lambdabot>  1
08:29:48 <Cale> for example:
08:29:55 <dino-> jorgedbucaran: In this case the => reads like "for all". That says basically "For all things of type class Num, known here as 'a', this is a function from a to a"
08:29:55 <Cale> > (*2) `map` [1,2,3,4]
08:29:55 <lambdabot>  [2,4,6,8]
08:30:11 <litb> and see this beauty:
08:30:30 <Cale> dino-: uhh...
08:30:32 <dino-> Cale: oh no!
08:30:39 <litb> > let a = map (2*); a [1, 2, 3]
08:30:39 <lambdabot>  Parse error at end of input
08:30:47 <dino-> What did I get wrong?
08:30:48 <litb> > a = map (2*); a [1, 2, 3]
08:30:48 <lambdabot>  Parse error at "=" (column 3)
08:30:49 <desegnis> jorgedbucaran, the => is quite similar to logical implication: If a is a type in class Num, then there is a function of type a -> a
08:30:50 <litb> darn
08:30:56 <litb> someone enlight me =)
08:30:56 <mauke> > let butter = map (2 *) in butter [1, 2, 3]
08:30:57 <lambdabot>  [2,4,6]
08:30:59 <Cale> dino-: There's actually an implicit "for all" for any type variables. => reads more like "implies"
08:31:06 <Cale> Or "if-then"
08:31:15 <jorgedbucaran> haha
08:31:44 <jorgedbucaran> cale: so, where were we?
08:31:51 <Cale> okay, let's look at sort :)
08:32:05 <Cale> Now, we'd want sort to work on lots of different types of lists
08:32:19 <Cale> So the first thing you might think is that we'd have:
08:32:23 <Cale> sort :: [a] -> [a]
08:32:25 <litb> lolz, this is going to reinvent the "haskell in 11 minutes" wheel
08:32:28 <Cale> But there's a problem with that
08:32:43 <Cale> In particular, we don't know how to compare values of just any types
08:32:55 <Cale> For example, what do we do if someone hands us a list of functions?
08:33:03 <Cale> There'd be no way to sort those
08:33:04 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5237
08:33:19 <filcab42> how can he expect a type a1->a in the first argument of >>=?
08:33:21 <Cale> So we need a way to say that values of type a can be compared for ordering
08:33:22 <litb> the answer would be class Ord i suppose
08:33:29 <Cale> Yes
08:33:37 <desegnis> litb: Cale is an All-you-need-to-know-about-Haskell tutorial with a keyboard in front of him.
08:33:38 <Cale> sort :: (Ord a) => [a] -> [a]
08:33:58 <litb> desegnis: lolz, indeed
08:34:23 <mauke> filcab42: possibly because of the return $ take 9 $ drop 3
08:34:23 <Cale> Which you can read as "if a is any ordered type, then sort takes a list of values of type a, and produces a list of values of type a"
08:34:43 <Cale> An ordered type is one for which <, <=, >, >=, etc. are defined for.
08:34:47 <mauke> filcab42: what's the type of crypt?
08:34:53 <jorgedbucaran> so that will restrict me to pass what to the function?
08:34:59 <Cale> yes
08:34:59 <filcab42> foreign import ccall unsafe "unistd.h crypt"
08:35:00 <filcab42>                crypt :: CString -> CString -> CString
08:35:00 <jorgedbucaran> list of functions for example?
08:35:06 <litb> jorgedbucaran: now, to go on in our c++ analogy, this would be like "concepts" in c++0x
08:35:11 <dino-> ok, sorry about that. I guess what I said maybe isn't strictly wrong. But poor choice of terms.
08:35:24 <Cale> You won't be allowed to pass a list of functions because they're not in the typeclass Ord
08:35:27 <doserj> filcab42: replace the $ in the last line with .
08:35:40 <mauke> filcab42: that's wrong
08:35:45 <Cale> However, you *can* pass in a list of characters, because characters are ordered
08:35:51 <Cale> Or a list of integers
08:35:51 <litb> jorgedbucaran: you want to make your type an instance of Ord to make it comparable
08:35:57 <Cale> Or a list of lists of integers :)
08:35:59 <Cale> etc.
08:35:59 <jorgedbucaran> in any order however? right?
08:36:07 <mauke> filcab42: crypt :: CString -> CString -> IO CString
08:36:12 <filcab42> hmm
08:36:14 <filcab42> why?
08:36:27 <mauke> because crypt has side effects
08:36:32 <filcab42> it has?
08:36:33 <mauke> it's not a pure function
08:36:42 <Cale> yeah, the idea is that our function is going to sort the list
08:36:42 <Cale> (with regard to that ordering)
08:36:42 <Cale> > sort [5,1,2,6,2]
08:36:43 <lambdabot>  [1,2,2,5,6]
08:36:48 <jorgedbucaran> alright
08:36:54 <Cale> :t sort
08:36:54 <lambdabot> forall a. (Ord a) => [a] -> [a]
08:37:13 <litb> @src Char Ord
08:37:14 <lambdabot> Source not found. I feel much better now.
08:37:14 <jorgedbucaran> sort :: (Ord a) => [a] -> [a]
08:37:15 <jorgedbucaran> takes a list of any type a and returns a list of type a
08:37:19 <jorgedbucaran> but type a must be ordinal
08:37:19 <litb> @src Ord
08:37:20 <lambdabot> class  (Eq a) => Ord a  where
08:37:20 <lambdabot>     compare      :: a -> a -> Ordering
08:37:20 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
08:37:20 <lambdabot>     max, min         :: a -> a -> a
08:37:25 <Codex_> cale: how do you make it sort backwards? :)
08:37:28 <Cale> "for all types a, if the type a is an instance of the class Ord, then take a list of values of type a, and produce a list of the same type"
08:37:40 <mauke> Codex_: sortBy (flip compare)
08:37:42 <Cale> > sortBy (flip compare) [5,2,6,2,1]
08:37:45 <lambdabot>  [6,5,2,2,1]
08:37:49 <mauke> reverse . sort
08:38:58 <litb> ohyeah, i would do that with reverse, but doing that with flip remains the same time complexity
08:38:59 <jorgedbucaran> what is =>
08:39:02 <Cale> jorgedbucaran: It separates typeclass constraints from the rest of the type
08:39:04 <litb> jorgedbucaran: it says that Ord is "derived from" Eq
08:39:05 <Cale> :t sort
08:39:05 <lambdabot> forall a. (Ord a) => [a] -> [a]
08:39:06 <Cale> oh
08:39:07 <Cale> In the definition of Ord?
08:39:10 <litb> read it loke "if a is an instance of Eq, then it follows that it is an instance of Ord where the following is true:"
08:39:11 <litb> s/loke/like
08:39:37 <Cale> "if the following is true" :)
08:39:51 <litb> heh
08:39:54 <jorgedbucaran> another use of => ?
08:39:57 <Cale> @src Eq
08:39:57 <lambdabot> class  Eq a  where
08:39:57 <lambdabot>     (==), (/=)   :: a -> a -> Bool
08:40:02 <shachaf> jorgedbucaran: They're both type-class constraints.
08:40:03 <idnar> mauke: what are the side-effects of crypt()?
08:40:03 <Cale> jorgedbucaran: yeah, related, but not quite the same
08:40:13 <mauke> idnar: it changes the contents of a static buffer
08:40:30 <Cale> Eq is another typeclass -- it specifies the operations for equality testing
08:40:31 <jorgedbucaran> alright
08:40:33 <idnar> mauke: what buffer?
08:40:39 <Cale> :t nub
08:40:39 <lambdabot> forall a. (Eq a) => [a] -> [a]
08:40:41 <idnar> mauke: an internal one?
08:40:42 <mauke> idnar: the one it stores the result string in
08:40:46 <Cale> > nub "mississippi"
08:40:46 <lambdabot>  "misp"
08:40:47 <jorgedbucaran> so far I understand => as a way to express constraints with class types
08:40:50 <mauke> I mean, it has to store it somewhere
08:40:51 <idnar> mauke: oh, right
08:41:07 <idnar> mauke: lightbulb is on now :P
08:41:21 <Cale> jorgedbucaran: yeah, basically, it restricts the types over which type variables range, so they satisfy all the typeclasses on the left of it
08:41:36 <litb> > nub "lississippi"
08:41:37 <lambdabot>  "lisp"
08:41:39 <litb> :)
08:41:39 <jorgedbucaran> okay
08:42:15 <jorgedbucaran> I'l eat that
08:42:19 <Codex_> jorgedbucaran: => is needed because "a" is lowercase, and thus means any type. (as opposed to some specific type)
08:42:43 <mauke> > let a = "lississippi"; ur = flip id in  ur a nub
08:42:47 <lambdabot>  "lisp"
08:43:01 <Cale> Another thing you might wonder about is why functions with multiple parameters use a bunch of arrows in a chain to separate them.
08:43:18 <litb> lol
08:43:39 <Cale> For example,  add :: Integer -> Integer -> Integer
08:43:39 <nolrai> what does "Quantified type variable `o' escapes" mean?
08:43:39 <wy> hey
08:43:42 <wy> Would functional analysis be related to FP?
08:43:54 <Cale> wy: very very weakly
08:44:06 <ibid> wy: about as much as apples and oranges are related
08:44:10 <mauke> nolrai: "you're doing something wrong"
08:44:14 <ibid> (they're both fruits)
08:44:19 <wy> oh...
08:44:27 <nolrai> mauke: :P
08:44:28 <Cale> wy: Functional analysis is one of the least constructive branches of mathematics. It's almost entirely founded on applications of the axiom of choice.
08:44:34 <litb> and are both somewhat red colored
08:44:51 <wy> I see. So I'll put that one later
08:44:58 <ibid> in this case, FA uses higher-order functions, and so does FP
08:45:03 <wy> what about abstract algebra?
08:45:10 <ibid> closer
08:45:30 <ibid> universal algebra even more
08:45:32 <jorgedbucaran> I gtg, hopefuly if any has time can check this thread: whatever explanation you may give would be fine
08:45:34 <jorgedbucaran> http://www.dynamicdrive.com/forums/showthread.php?t=28822
08:45:38 <jorgedbucaran> I'll back later
08:45:41 <Cale> Functional analysis is combination of linear algebra (on infinite dimensional spaces, primarily), and topology (and the theory of metric spaces)
08:46:08 <Cin> is this annoying to read or cool to read?
08:46:09 <Cin> http://rtfs.ath.cx/haskell/IRCServer/SocketFiddling.lhs.html
08:46:59 <litb> oh, what tool was used to transform the lhs into the html?
08:47:02 <litb> it looks pretty good
08:47:26 <Cin> hsColour
08:47:49 <Cale> Wow, hsColour is getting pretty sophisticated :)
08:47:53 <wy> Cale: What about representation theory?
08:47:58 <litb> wow nice
08:48:11 <litb> does the Latex output support formulas?
08:48:16 <Cin> cale: it's not, i've written the html code in my actual source file. but i'm considering modifying it to do that. depends how annoying it is to read
08:48:32 <Cale> wy: That's about taking groups and representing them with other structures, primarily matrices with complex coefficients.
08:49:01 <Cale> Cin: It looks nice.
08:49:07 <Cin> litb: i'm not sure i'm using er "bird" notation
08:49:22 <litb> Cin: well i do it with emacs:
08:49:36 <litb> http://www.johannes-schaub.de/wnm.hs.html but that doesn't work well with bird
08:49:37 <lambdabot> Title: wnm.hs
08:50:05 <Cale> I'd recommend a slightly brighter blue
08:50:21 <Cale> (for the comments)
08:50:32 <Cin> litb: that is pretty nice. pity i can't read german :P
08:51:09 <litb> :) yeah emacs does a nice job with that
08:51:16 <mauke> man, why do programmers think writing code in their native language is a good idea?
08:51:37 <wy> Thanks. I'll go to the library to chech these out :)
08:51:37 <Cale> mauke: why wouldn't it be?
08:51:39 <litb> hehe, usually i write english comments..
08:51:43 <Zao> mauke: Less conflict with reserved keywords and platform names? :)
08:52:15 <mauke> Cale: because usually the keywords and standard library of a programming language are in English
08:52:27 <mauke> and it just looks weird if you mix it with your own stuff
08:53:03 <mauke> litb: I'd rather have English code and German comments :-)
08:54:31 <litb> ok , there is <*> , liftM2 and fmap in my head and i always mix them together :)
08:54:32 <Cale> wy: Group theory is important because for essentially every kind of mathematical structure we study, we look at various kinds of structure preserving maps between them.
08:54:32 <litb> and ap too
08:54:32 <Cin> Maybe Funktion :P
08:54:32 <Lemmih> mauke: I'm with Cale on this one. I personally write all my comments in a mixture of Klingon and Esperanto.
08:54:35 <Cale> ...
08:54:35 <Cale> okay
08:54:37 <litb> mauke: ah i see what you meant
08:55:08 <mauke>  istAbleitbar (Funktion _ Nothing) = False
08:55:57 <Cale> mauke: hehe, perhaps we should produce translations of each programming language into each native language :)
08:56:04 <litb> lolz, then that would be funny for editors writers considerung the hilighting
08:56:06 <Cin> could probably include links to google translator
08:56:07 <litb> /ung/ing/
08:56:12 <mauke> Cale: that would be even worse (excel does that IIRC)
08:56:17 <Cin> Faux :P
08:56:20 <Cin> (throw in some francais)
08:56:27 <Botje> mauke: you mien Nichts en Falsch, surely? :)
08:56:28 <Botje> *mean
08:56:35 <Zao> mauke: Please don't remind me of that.
08:56:38 <litb> maybe i should have used istAbleitbar (Funktion _ x) = not . isNothing x
08:56:47 <Zao> I have had the pleasure of developing against a localized Excel.
08:58:28 <Cale> I wonder if there are any purely Japanese or Chinese programming languages.
08:59:00 <Cin> cale: could probably write your own in scheme with macros >_>
08:59:11 <litb> or having "type Vielleicht = Maybe" o.O
08:59:16 <Cin> or just re-define the reader
08:59:28 <mauke> I know a language whose keywords were taken from English, German, Latin, IRC and complete nonsense
08:59:29 <hpaste>  nolrai pasted "what does "Quantified type variable `o' escapes" mean?" at http://hpaste.org/5238
08:59:58 <nolrai> mauke: whats its name?
09:00:10 <mauke> nolrai: ploki
09:00:16 <mauke> I stopped working on it, though
09:01:25 <pejo> mauke, as for the german comments - it's a pain imho. I think that source code was mostly german too though.
09:02:33 <litb> pejo: yes
09:03:08 <litb> pejo: I will (Maybe Change) that code
09:03:35 <dogsson> simon and your mother and a stranger and your room mate says turn the volume down
09:06:26 <Twey> @src return
09:06:26 <lambdabot> Source not found. You speak an infinite deal of nothing
09:06:32 <Twey> :-\
09:06:39 <mauke> Twey: it has no source
09:06:53 <Twey> mauke: But what *is* it?
09:07:03 <mauke> Twey: a method in Monad
09:07:22 <Twey> It seems very... magic
09:07:29 <mauke> nah, it's just a virtual constructor
09:07:30 <shachaf> Twey: It is different in every Monad.
09:07:35 <mauke> > return 42 :: [Int]
09:07:37 <shachaf> > return 1 :: [Int]
09:07:37 <lambdabot>  [42]
09:07:38 <lambdabot>  [1]
09:07:40 <mauke> > return 42 :: Maybe Int
09:07:41 <shachaf> > return 1 :: Maybe Int
09:07:41 <lambdabot>  Just 42
09:07:41 <lambdabot>  Just 1
09:07:45 <shachaf> > return 1 :: IO Int
09:07:46 <mauke> :|
09:07:46 <lambdabot>  <IO Int>
09:08:00 <shachaf> @src Maybe return
09:08:01 <lambdabot> return              = Just
09:08:01 <Twey> Hmm
09:08:03 <shachaf> @src [] return
09:08:03 <lambdabot> return x    = [x]
09:08:06 <mauke> > return 42 :: Double -> Int
09:08:07 <lambdabot>  <Double -> Int>
09:08:53 <shachaf> > return 1 :: Either String Int
09:08:54 <lambdabot>  Right 1
09:09:01 <Twey> Ahh
09:09:04 <idnar> > (return 42 :: Double -> Int) 0.5
09:09:05 <lambdabot>  42
09:09:05 <Twey> I see it now.
09:09:16 <idnar> heh
09:09:20 <mauke> > return 42 0.5
09:09:21 <lambdabot>  42
09:09:38 <shachaf> Twey: Also look at Monad's other method, (>>=).
09:09:41 <shachaf> @ty (>>=)
09:09:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:09:49 <nornagon> @instances Monad
09:09:50 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:09:58 <mauke> or maybe look at liftM and join first
09:10:11 <nornagon> that ((->) r) one always trips me up.
09:10:12 <Twey> shachaf, what's this "forall" notation?
09:10:12 * shachaf was about to suggest that.
09:10:18 <shachaf> Except call liftM "fmap". :-)
09:10:27 <mauke> Twey: ignore everything between 'forall' and '.'
09:10:28 <shachaf> Twey: It means "for all". :-)
09:10:37 <shachaf> Twey: It's usually implied.
09:10:42 <Twey> Hm, OK
09:10:51 <shachaf> @ty id
09:10:52 <lambdabot> forall a. a -> a
09:11:23 <shachaf> "For all types a, id gets an a and returns an a."
09:11:57 <tibbe> @seen dons
09:11:58 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 13h 37m 46s ago.
09:12:07 <shachaf> ("For any" might make more sense -- for any specific type you pick, id will work.)
09:12:09 <tibbe> dons: ping
09:17:04 <mauke> nolrai: I think the problem is Displayer m2 -> m2
09:17:24 <tibbe> @seen dcoutts
09:17:25 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 1d 21h 5m 9s ago.
09:17:27 <mauke> m2 :: m (o, r) for some unknown o
09:17:31 <tibbe> dcoutts: ping
09:17:49 <mauke> you need to get rid of the o somehow before returning from the case
09:20:03 <nolrai> mauke: yeah, this modle worked for Inquirer, but it dosn't seem to like haveing the exitential in the return value.
09:20:58 <nolrai>  /modle/model/
09:22:06 <nolrai> it doesn't seem posible to perserve the o type from one constucter to the next.
09:26:15 <roconnor> what are the functions of type (m a, b) -> m (a, b)  and (a, m b) -> m (a, b) called?
09:27:05 <idnar> @pl (x, y) -> x >>= (\x -> (x, y))
09:27:05 <lambdabot> (line 1, column 8):
09:27:05 <lambdabot> unexpected ">" or "-"
09:27:05 <lambdabot> expecting variable, "(", operator or end of input
09:27:14 <idnar> @pl \(x, y) -> x >>= (\x -> (x, y))
09:27:14 <lambdabot> uncurry ((. flip (,)) . (>>=))
09:27:17 <mauke> @pl \ma b -> liftM (\a -> (a, b)) ma
09:27:17 <lambdabot> flip (fmap . flip (,))
09:29:00 <shachaf> mauke: Not the same function.
09:29:24 <shachaf> mauke: idnar's didn't have a return.
09:29:49 <hpaste>  gwern pasted "another sdist problem" at http://hpaste.org/5239
09:29:52 <idnar> :t \(x, y) -> x >>= (\x -> (x, y))
09:29:53 <lambdabot> forall t a. (Monad ((,) a)) => ((a, a), t) -> (a, t)
09:30:02 <idnar> oops
09:30:02 <gwern> my cabal problem is with a .hsc file
09:30:09 <idnar> :t \(x, y) -> x >>= (\x -> return (x, y))
09:30:10 <lambdabot> forall t (m :: * -> *) a. (Monad m) => (m a, t) -> m (a, t)
09:30:12 <nolrai> mauke: could a newtype help me? do you think.
09:30:15 <idnar> @pl \(x, y) -> x >>= (\x -> return (x, y))
09:30:15 <lambdabot> uncurry (flip (fmap . flip (,)))
09:30:18 <gwern> anyone know of any example repos which have hsc files I could cruib from?
09:30:25 <mauke> nolrai: no idea
09:30:37 <idnar> @pl \(x, y) -> y >>= (\y -> return (x, y))
09:30:38 <lambdabot> uncurry (fmap . (,))
09:30:43 <mauke> gwern: X11 has hsc files
09:31:16 <jedbrown> gwern: pcre-light is simpler and uses hsc.
09:31:31 <shachaf> idnar: Using the same name there is still confusing.
09:31:59 <gwern> ok. are they pure libraries or do they use executables as well?
09:32:44 <gwern> hm. am I supposed to list it in C-sources:?
09:34:00 <Saizan> i think it's the other-modules: HsLock
09:34:14 <jedbrown> gwern: They are just libs.  You list in extra-libraries.  You don't need to mention the header file.
09:35:17 <jedbrown> gwern: I found cabal to be magic when building FFI libs with hsc2hs or c2hs.
09:35:18 <gwern> Saizan: but the file itself just has a Main module header, iirc
09:35:32 <gwern> yeah, 'module Main where'
09:35:57 <Saizan> gwern: so there's no Hslock module?
09:36:14 <ac> Anybody read this paper: http://www.ccs.neu.edu/scheme/pubs/popl08-thf.pdf ?
09:36:15 <dcoutts_> @seen tibbe
09:36:15 <lambdabot> I saw tibbe leaving #ghc, #darcs, #xmonad and #haskell 4m 58s ago, and .
09:36:36 <ac> (It's the one about Typed Scheme from LTU)
09:36:48 <gwern> Saizan: no. this repo is just a bunch of executables all with a module Main where header
09:36:59 <gwern> one of which is not a .hs file but a .hsc file...
09:37:21 <Saizan> gwern: so, try removing the other-modules line? does it still compiles?
09:38:17 <gwern> Saizan: it compiles, but the sdist error is the same - Building source dist for xmonad-utils-0.1.20080126...
09:38:20 <gwern>  Setup: Hslock.hs doesn't exist
09:38:53 <ac> They introduce this notion of "occurence typing", which AFAIU, allows for implicit union types
09:40:06 <ac> They eliminate the need for a pattern matching
09:40:26 <ac> expression
09:40:48 <jedbrown> @check ((\f a -> f a == f a) :: (Double -> Int) -> Double -> Bool)
09:40:49 <lambdabot>  Exception: Prelude.(!!): negative index
09:41:07 <jedbrown> @check ((\f a -> f a == f a) :: (Int -> Double) -> Int -> Bool)
09:41:09 <lambdabot>  OK, passed 500 tests.
09:41:18 <jedbrown> @check ((\f a -> f a == f a) :: (Double -> Int) -> Double -> Bool)
09:41:19 <lambdabot>  Exception: Prelude.(!!): negative index
09:42:36 <jedbrown> So quickCheck generates bad arbitrary (Double -> Int).  (I actually get _|_ lots more than the negative index in my testing.)
09:42:43 <jedbrown> Is this expected?
09:43:59 <kpreid> @check ((\f a -> f a == f a) :: (Double -> [Bool]) -> Double -> Bool)
09:44:02 <lambdabot> Terminated
09:44:14 <kpreid> @check ((\f a -> f a == f a) :: (Double -> Either Bool ()) -> Double -> Bool)
09:44:15 <lambdabot>  Exception: Prelude.(!!): negative index
09:44:36 <gwern> (so it won't build without the line 'main-is:            Hslock.hs', but if I add it and it builds, then sdist won't build a tarball because Hslock.hs doesn't exist! sometimes cabal can be very frustrating)
09:44:47 <kpreid> jedbrown: if I were to take a wild guess, I'd look for bugs in handling Double ->
09:45:35 <jedbrown> kpreid: Yeah, it seems to be that (Double -> a) is a problem.  Same for (Float -> a).
09:46:34 <kpreid> perhaps because of their screwy Enum instances?
09:47:33 <jedbrown> kpreid: well, I suspect it is from  coarbitrary = coarbitrary . decodeFloat
09:47:44 <kpreid> @type decodeFloat
09:47:45 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
09:48:08 <kpreid> that sounds innocent enough
09:48:13 <Saizan> gwern: i think it's just a bug, assuming that the main would be an .hs somewhere, use the bugtracker!
09:48:38 <jedbrown> @src decodeFloat
09:48:38 <lambdabot> Source not found. stty: unknown mode: doofus
09:48:50 <dcoutts_> gwern: what's the problem?
09:49:02 <olsner> @djinn Maybe (a,b) -> (Maybe (a,b) -> Maybe (a, Maybe c)) -> Maybe (a,c)
09:49:02 <lambdabot> f a b =
09:49:02 <lambdabot>     case a of
09:49:02 <lambdabot>     Nothing -> Nothing
09:49:02 <lambdabot>     Just (c, d) -> case b Nothing of
09:49:02 <lambdabot>                    Nothing -> Nothing
09:49:04 <lambdabot>                    Just (e, f) -> case f of
09:49:06 <lambdabot>                                   Nothing -> Nothing
09:49:08 <lambdabot>                                   Just g -> case b (Just (e, d)) of
09:49:09 <gwern> dcoutts_: http://hpaste.org/5239
09:49:10 <lambdabot>                                             Nothing -> Nothing
09:49:12 <lambdabot>                                             Just (h, i) -> case i of
09:49:14 <lambdabot>                                                            Nothing -> Just (h, g)
09:49:16 <lambdabot>                                                            Just j -> Just (c, j)
09:49:36 <olsner> oh, only that?
09:49:45 <roconnor> lambdabot: hpaste plz
09:50:18 <Saizan> or do-notation
09:50:25 <dcoutts_> gwern: looks like a cabal bug to me, please report it
09:50:35 <fasta> What's a good alternatative to fInST f_of_type_ST_something = runST (do stuff; bar <- f_of_type_ST_something; doStuff bar) ?
09:50:42 <olsner> I was looking for a short simple function to beat my Maybe's into shape, I guess I'll have to write it myself with do :(
09:51:13 <fasta> I get the obnoxious message that it is less polymorphic than expected. The compiler is just being as ass.
09:51:17 * gwern bows to the inevitable. I shall report a cabal bug
09:51:44 <Saizan> fasta: from it, or from the use of it?
09:52:10 <fasta> Saizan: from it, AFAIK.
09:52:43 <fasta> Saizan: you just cannot pass computations into a runST block.
09:52:49 <Saizan> ?type let finst f = runST (do undefined; bar <- f; undefined bar) in finst
09:52:51 <lambdabot> Not in scope: `runST'
09:52:53 <jedbrown> kpreid: So decodeFloat just uses decodeDouble# hence the negative indexing must happen in quickCheck.
09:53:02 <gwern> dcoutts_: could it be a duplicate of http://hackage.haskell.org/trac/hackage/ticket/161 ?
09:53:04 <lambdabot> Title: #161 ('sdist' cannot find some modules that 'build' finds ok) - Hackage - Trac
09:53:24 <Saizan> fasta: aah, wait, finst needs a Rank2 signature.
09:53:47 <fasta> Saizan: imho, the compiler needs to be smarter.
09:54:03 <Saizan> fasta: finst :: (forall s. ST s A) -> B
09:54:09 <dcoutts_> gwern: it's similar but I think this is different, I think it's not pre-processing the main module on sdist
09:54:26 <gwern> ok
09:54:29 <fasta> Saizan: thanks for your advice, but I still believe it's the compiler that should be fixed.
09:54:59 <Saizan> fasta: i think higher-rank type inference is still an open research topic or has given negative results
09:55:33 <fasta> Saizan: I would be highly surprised if this case cannot be handled.
09:55:35 <Twey> Hmm
09:55:44 <Twey> How do I make show work with my types?
09:56:04 <shachaf> Twey: instance Show MyType where ...
09:56:09 <fasta> instance Show TweyType where show tweyValue = ....
09:56:17 <shachaf> Twey: Or data MyType = ... deriving Show
09:56:17 <mxc> are there any problems with ghc 6.8.x on ubuntu 7.10?  it seems like it is only in the ubuntu 8.x repo
09:56:20 <Twey> Ah, thanks
09:56:25 <jedbrown> @check ((\f a -> f a == f a) :: ((Integer,Int) -> Bool) -> (Integer,Int) -> Bool)
09:56:25 <lambdabot>  OK, passed 500 tests.
09:56:45 <shachaf> mxc: 7.10 won't get any big updates like that.
09:58:03 <jedbrown> So that works okay, but it's generating small Integers.  decodeFloat generates some really big ones.  If that overflows, then coarbitrary can take a negative variant.
09:58:14 <dcoutts_> gwern: hmm, where is Hslock.hsc exactly? is it in ./Hslock.hsc or ./src/Hslock.hsc ?
09:58:29 <dcoutts_> gwern: cabal is only looking for the file in the hs-source-dirs
09:59:17 <gwern> dcoutts_: src/
09:59:18 <fasta> Saizan: in this case the type would be about 200 chars long, I guess. Not user-friendly.
10:00:03 <dcoutts_> gwern: so what is the error?
10:00:03 <gwern> dcoutts_: but hs-source-dirs does declare it to be in src/
10:00:08 <gwern> they all do
10:00:20 <jedbrown> Since Integer uses (fromInteger :: Integer -> Int) to choose the variant.
10:00:23 <dcoutts_> gwern: right, so I'm confused, what's the message exactly?
10:01:10 <mxc> can anyone point me to a changelog for ghc (specifically, 6.8 additions)
10:01:22 <jedbrown> Cool, I know how to fix this now, but I'm surprised this bug exists.  Wouldn't somebody have tried arbitrary (Double -> a)?
10:01:27 <dcoutts_> mxc: the release notes are in the user guide
10:01:31 <gwern> dcoutts_: http://hackage.haskell.org/trac/hackage/ticket/217
10:01:33 <lambdabot> Title: #217 (.hsc files do not get processed for cabal sdist?) - Hackage - Trac
10:03:32 <olsner> does djinn do type classes?
10:04:48 <mxc> ty
10:05:30 <fasta> Saizan: how would the Rank-2 type work when 's' is part of the first 2 arguments?
10:05:51 <fasta> Saizan: i.e. the forall should quantify over both, but they need to be separate parameters.
10:08:17 <fasta> Or maybe I should just use two foralls, since I guess it doesn't matter which one cannot be touched.
10:09:16 <olsner> @type fromMaybe
10:09:17 <lambdabot> forall a. a -> Maybe a -> a
10:09:27 <olsner> @type fromMaybeM
10:09:28 <lambdabot> Not in scope: `fromMaybeM'
10:16:49 <dons> ?users
10:16:49 <lambdabot> Maximum users seen in #haskell: 447, currently: 435 (97.3%), active: 14 (3.2%)
10:17:58 <dcoutts_> gwern: I cannot reproduce your result
10:18:23 <dcoutts_> gwern: if I specify main-is: Test.hsc then sdist works but build does not
10:18:37 <dcoutts_> which is opposite to what you get
10:19:06 <dcoutts_> gwern: can you cabal clean first and try again, I think you might just have a stale pre-processed .hs version hanging around
10:19:40 <dcoutts_> tibbe: you were after me earlier I think
10:20:12 <tibbe> dcoutts_: ah yes, it had something to do with doing lazy BS IO and making sure handle/socket gets closed in time (and not too early)
10:20:25 <tibbe> dcoutts_: but I'm making food now so we have to talk about it another time
10:20:33 <dcoutts_> tibbe: with latest bytestring package it should "just work"tm
10:20:44 <tibbe> dcoutts_: even if the whole input is not consumed?
10:20:57 <gwern> dcoutts_: you mean 'runhaskell Setup clean'?
10:20:58 <dcoutts_> tibbe: no, it behaves just like ordinary hGetContents
10:21:05 <tibbe> dcoutts_:  I also want it closed before GC if I know the whole content won't get read
10:21:16 <tibbe> dcoutts_: i.e. it's used in a web server
10:21:19 <dcoutts_> gwern: yeah, I use cabal-install
10:21:36 <gwern> dcoutts_: my haskell build script starts with a clean
10:21:40 <dcoutts_> tibbe: then you can hClose, just as with ordinary IO
10:22:18 <tibbe> dcoutts_: OK, thanks
10:22:53 <litb> hm, is it better to do "return (+) `ap` (Just 4) `ap` (Just 5)" or "liftM2 (+) (Just 4) (Just 5)" ?
10:22:58 <litb> what would you recommend?
10:23:15 <kpreid> litb: the second is better, absent other reasons
10:23:15 <tibbe> dcoutts_: then I just need to make sure that my computation that uses the lazy bs gets run before I do hClose (i.e. so it's not in a thunk). I find lazy IO a bit difficult
10:23:25 <litb> but first, does they do the same thing?
10:23:29 <kpreid> yes.
10:24:00 <dcoutts_> tibbe: lazy IO is most commonly used when you intend to read to the end of the input stream
10:24:30 <dcoutts_> gwern: is the darcs repo available, I cannot reproduce your results with a simple test example
10:24:34 <litb> i' still having problems with understanding ap , how it uses LiftM2 by passing it id
10:24:54 <gwern> dcoutts_: http://gorgias.mine.nu/repos/xmonad-utils
10:24:56 <lambdabot> Title: Index of /repos/xmonad-utils
10:25:14 <kpreid> @src ap
10:25:14 <lambdabot> ap = liftM2 id
10:25:29 <tibbe> dcoutts_: well, sometimes I might and sometimes I might not, I also don't know how many bytes I need (I'm sending the lazy bs to a HTTP parser)
10:25:31 <kpreid> litb: that definition is equivalent to ap = liftM2 ($)
10:25:46 <kpreid> is that clearer?
10:25:51 <kpreid> ($) f x = f x
10:25:54 <kpreid> id f x = f x
10:25:59 <tibbe> dcoutts_: but I'll try to do a write up in an email to haskell cafe
10:26:12 <litb> moment, i will go out a bit buying some stuff and then come back
10:26:25 <kpreid> ap = \mf mx -> do f <- mf; x <- mx; return f x
10:26:48 <tibbe> dcoutts_: but now I need to cook before the guests show up! :)
10:27:00 <doserj> return $ f x
10:27:04 <fasta> Indeed, a type signature of 251 chars, typed by hand. In assembly that could be a complete program!
10:27:29 <fasta> Productivity down the drain, I guess.
10:28:04 <Zao> See it from the bright side. It could have been Java code.
10:28:27 <fasta> Yes, or C++, all with those terrible type annotations.
10:29:11 <fasta> It's a miracle Eclipse came out of that mess.
10:29:14 <dcoutts_> gwern: ah, that explains things, you *are* specifying "main-is: Hslock.hs", not "main-is: Hslock.hsc" as you said in the hpaste and the bug report.
10:29:39 <dcoutts_> gwern: so I get similar results then
10:31:28 <gwern> dcoutts_: right. I tried Hslock.hsc, but that definitely didn't work...
10:31:41 <dcoutts_> gwern: it works for sdist but not build :-)
10:31:57 <gwern> lol
10:32:13 <dcoutts_> gwern: so yes, the bug is that specifying the .hs doesn't make sdist look for the .hsc
10:32:15 * gwern notes that when you try build with 'main-is: Hslock.hsc', you get: Linking dist/build/hxput/hxput ...
10:32:19 <gwern> ghc-6.8.2: no input files
10:32:21 <gwern>  Usage: For basic information, try the `--help' option.
10:32:39 <dcoutts_> gwern: right, because it passes the file as if it were a .hs file and ghc does not recognise it
10:32:53 <dcoutts_> we should check that main-is is always given as a .hs or .lhs file
10:32:55 * gwern notes that ross@soi.city.ac.uk has closed the bug report
10:34:46 <fasta> Does GHC cache types between two invocations?
10:35:31 <dons> in .hi files
10:36:09 <fasta> When one changes one letter in a file, is that file still used?
10:36:29 * gwern briefly wonders if .hi files could solve Harrop's desperate need for type inference while programs are broken
10:37:01 <fasta> Harrop's deserate need? Is that a new movie? :)
10:37:04 <pejo> gwern, you have to admit that it would be handy to have a "do what I mean" feature when you are fixing things though.
10:37:07 <fasta> desperate*
10:37:50 <monochrom> I have long abandoned "do what I mean", since even I don't know what I mean.
10:38:16 <gwern> pejo: bleh. it'd also be convenient to not have the IO monad
10:39:12 <fasta> Computers are too slow to do that. I know how it should work, though.
10:39:49 <gwern> fasta: 'Saving Private Harrop'
10:40:09 <fasta> Give me 10 billion times the CPU and memory bandwidth available, 20 years, lots of money and you will get what you want.
10:40:34 <dcoutts_> gwern: bug report updated and re-opened
10:40:37 <monochrom> I want computers to write programs for us. Can you do that?
10:40:42 <fasta> monochrom: of course
10:40:50 <monochrom> Nice. I believe you.
10:41:35 <doserj> instance Arbitrary HsModule where ...
10:42:39 <monochrom> It is rumoured that NSA has that much resource. Likely it is already using computers to write programs. Hell, it can even use computers to run all its activities!
10:43:12 <gwern> monochrom: but computers do write programs for us! I have some modules around here that has my computer write like 5 sets of programs for me. it goes through TH, Core, C, asm, and then the internal CPU languages
10:43:33 <monochrom> (E.g., whenever the NSA head goes talk to the president, he/she is really just reading aloud a report written by computers!)
10:45:08 <fasta> monochrom: is that a joke? I can actually imagine that they can do that, though -- with those budgets.
10:45:17 <monochrom> (And if the president asks a question, the NSA head is really using a microphone to receive the question and relay to the computers real-time, and the computers whisper back the answer to the NSA head.)
10:45:31 <fasta> monochrom: now you pushed it.
10:46:03 <monochrom> ("human computer interface" has gained a new meaning. It's: a human acting as a computer interface. XD)
10:46:11 <fasta> :)
10:46:39 <fasta> You need to hit their toes to input, I heard.
10:47:09 <RayNbow`afk> heh... http://reddit.com/r/programming/info/66opa/comments/ , "Only at MIT does one get handed an assignment that you have absolutely no idea how to even START."
10:47:30 <monochrom> No, there is the other extreme.
10:47:42 <fasta> Maybe that person didn't belong at MIT ;)
10:48:11 <monochrom> A school with extremely underqualified students also get handed assignments that they don't know how to start.
10:48:28 <RayNbow> :p
10:48:31 <monochrom> Of course in the latter case it is a problem with the students.
10:49:23 <RayNbow> anyone familiar with this? :) http://www.ecs.umass.edu/mie/faculty/smith/cube.jpg
10:49:47 <RayNbow> except for the fact that it's a picture of a cube :p
10:50:43 <monochrom> And thus I disbelieve in "any researcher must be able to explain his/her research in a page of writing to anyone".
10:51:08 <monochrom> To "anyone"?! Even to an emphatically uneducated public?
10:51:40 <cjb> I prefer the ending "to a particularly interested ten year-old".
10:51:44 <cjb> :)
10:52:25 <pejo> monochrom, if research doesn't get communicated there wasn't much point in doing it in the first place. The unedcuated public (as you put it) are funding a lot of research, they have a right to know what people do with their tax money.
10:52:46 <monochrom> I'm really objecting to the "a page" limit.
10:53:06 <RayNbow> you could tell the uneducated public anything you like... :p
10:53:36 <monochrom> If you listen to me for 1 week straight, I can teach you Haskell.
10:53:47 <monochrom> I can't teach most people Haskell in a page.
10:54:26 <andyjgill> But you could communicate what you like about Haskell in one page.
10:54:29 <monochrom> If you don't already know calculus, I can't explain differential geometry to you in a page.
10:55:06 <mxc> andyjgill - i would posit that to a non technical person, that would be impossible
10:55:15 <monochrom> But if you listen to me for two semesters, I can first spend one semester to teach you calculus first. Then I can start talking about differential geometry.
10:57:18 <andyjgill> I like talking about bridges. Why do engineers like suspension bridges? Because they are functional (pun) and aesthetically pleasing. Like Haskell.
10:58:20 <pejo> mono, as uneducated public, I'd go with andy.
10:58:53 <monochrom> That is just sweet-talking.
10:59:06 <dons> haskell http://dubaistructures.com/millau1.jpg :)
10:59:47 <dons> C++ http://jca.umbc.edu/~george/html/courses/phys224/images/tacoma-narrows-bridge.JPG
10:59:48 <lambdabot> http://tinyurl.com/2ep62t
10:59:49 <TomMD> andyjgill: Any news on the academic front?  I'd hate to see you "leave" industry, but am curious what research you will produce.
11:00:22 <andyjgill> You might not be able to teach someone Haskell in a page, but you could capture why you like Haskell.
11:00:25 <opqdonut> dons: :)
11:00:33 <SamB> andyjgill: isn't that the same reason why everyone else likes them?
11:01:02 <andyjgill> TomMD: No news yet.
11:01:24 <monochrom> "why you like haskell" has little to do with "explain your research".
11:01:33 <andyjgill> But big research plans. Some of them are on my web page.
11:01:45 <monochrom> My original statement was: And thus I disbelieve in "any researcher must be able to explain his/her research in a page of writing to anyone".
11:01:46 <jwp> dons: nice.. ;)
11:01:48 <TomMD> @where andyjgill
11:01:48 <lambdabot> I know nothing about andyjgill.
11:02:19 <andyjgill> I am being ignored by a bot :-)
11:02:31 <monochrom> Note it is not "say what you like about your research".
11:02:35 <andyjgill> monochrom: explain for the sake of?
11:02:54 <monochrom> I don't know. It is not my requirement. It is some dumb government requirement.
11:02:57 <SamB> monochrom: to anyone?
11:03:11 <SamB> some people are just to dumb to know
11:03:16 <SamB> *too
11:03:46 <monochrom> What do you think what government wants?
11:04:06 <monochrom> I think governments want to get a feeling that they know everything.
11:04:20 <andyjgill> If you mean explain as in give relevance to, then the elevator pitch is what you need.
11:04:56 <monochrom> elevator pitch still depends on the education level or life experience of the audience.
11:05:53 <sizur> monochrom, if it's for the government, why not assume they will understand?
11:06:30 <litb> ah i think i got that now, kpreid
11:06:40 <litb> given that ap is ap = \mf mx -> do f <- mf; x <- mx; return f x
11:07:10 <litb> hm, when do you usually need ap`
11:07:12 <litb> ?
11:07:45 <sizur> > succ `ap` Just 5
11:07:45 <lambdabot>  Couldn't match expected type `(->) (a -> b)'
11:08:04 <sizur> > succ `ap` (Just 5)
11:08:04 <lambdabot>  Couldn't match expected type `(->) (a -> b)'
11:08:10 <sizur> ah
11:08:24 <litb> > return succ `ap` Just 5
11:08:25 <lambdabot>  Just 6
11:09:06 <litb> hm, but we could aswell chosen liftM directly. so i do not see the point of ap :)
11:09:16 <sizur> > [succ,pred] `ap` [1,2,3]
11:09:16 <lambdabot>  [2,3,4,0,1,2]
11:09:25 <dons> did peope see the news that PLT Scheme is getting immutable lists by default
11:09:30 <Saizan> litb: e.g. since you can't write a generic liftMn, you can simulate it with: return f `ap` m1 `ap` m2 `ap` ... `ap` mn
11:09:31 <dons>   http://blog.plt-scheme.org/2007/11/getting-rid-of-set-car-and-set-cdr.html
11:09:32 <fasta> dons: yes
11:09:33 <lambdabot> Title: PLT Scheme Blog: Getting rid of set-car! and set-cdr!, http://tinyurl.com/23ah7z
11:09:40 <SamB> dons: lovely!
11:09:43 <fasta> dons: isn't that old news?
11:09:46 <dons> welcome to the 1980s for Scheme :)
11:09:49 <idnar> :t ap
11:09:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:09:51 <dcoutts_> litb: ap is much cooler than liftM, see the Applicative class
11:09:52 <idnar> :t liftM
11:09:52 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
11:09:55 <dons> apparently, it is, fasta
11:10:14 <SamB> why is that the 1980s?
11:10:18 <phobes> C++:  http://www.uglybloke.co.uk/garden/bridge1.jpg     Haskell:  http://www.woodentoystore.co.uk/images/33351%20viaduct%20bridge.jpg
11:10:31 <litb> @src Applicative
11:10:31 <lambdabot> class Functor f => Applicative f where
11:10:31 <lambdabot>     pure  :: a -> f a
11:10:31 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
11:10:32 <phobes> j/k :)
11:10:33 <fasta> SamB: Haskell got rid that in 1987?
11:10:38 <fasta> +of
11:10:42 * dons slaps phobes 
11:10:43 <TomMD> ?karma monochrom
11:10:43 <lambdabot> monochrom has a karma of 18
11:10:58 <SamB> Haskell was early
11:11:03 <dcoutts_> dons: I like how they say map is a thing of beauty and then show us a 4 line monster :-)
11:11:08 <dons> scary
11:11:20 <litb> > (pure succ) `ap` Just 5
11:11:21 <lambdabot> Terminated
11:11:25 <litb> o.O
11:11:37 <dons>   (define (map f l)
11:11:37 <dons>    (cond
11:11:37 <dons>      [(null? l) '()]
11:11:37 <dons>      [else (cons (f (car l)) (map f (cdr l)))]))
11:11:40 <Saizan> litb: retry
11:11:46 <dons> ?src map
11:11:46 <lambdabot> map _ []     = []
11:11:46 <lambdabot> map f (x:xs) = f x : map f xs
11:11:49 <litb> > (pure succ) <*> Just 5
11:11:49 <lambdabot> Terminated
11:11:58 <dcoutts_> now, that is a thing of beauty :-)
11:12:01 <litb> lolz it doesn't seem to work
11:12:03 <fasta> [] in Scheme is horrible.
11:12:13 <kaol> mmm... Functors. Now I want to define Oz-like ports with them.
11:12:16 <ddarius> dcoutts_: Note that that definition of map is inappropriate for a strict language.
11:12:18 <dons> dcoutts_: and 'f' can be impure
11:12:39 <dcoutts_> ddarius: why is that?
11:13:03 <ddarius> It requires O(length l) stack.
11:13:18 <litb> > [succ,pred] `ap` [1,2,3] -- but that makes sense!
11:13:19 <lambdabot>  [2,3,4,0,1,2]
11:13:38 <sizur> > Nothing `ap` Just 5
11:13:38 <lambdabot>  Nothing
11:13:51 <sizur> > Just (^2) `ap` Just 2
11:13:52 <lambdabot>  Just 4
11:13:55 <dcoutts_> ddarius: so does the scheme one it looks like, I don't see any accumulating parameter
11:14:19 <litb> > pure (^2) <*> Just 2
11:14:19 <lambdabot> Terminated
11:14:29 <litb> hm, lets look up Applicative source
11:14:31 <ddarius> dcoutts_: I was referring to the Scheme one.
11:14:39 <sizur> litb, use <*> isntead of ap
11:14:43 <ddarius> (And it is identical to the Haskell one.)
11:14:43 <dcoutts_> ddarius: ah, right.
11:15:03 <ddarius> However, Haskell is a lazy language and that is the appropriate definition for a lazy language.
11:15:10 <sizur> > (^2) <$> Just 5
11:15:10 <lambdabot>  Just 25
11:15:53 <sizur> > (*) <$> [1,2,3] <*> [5]
11:15:54 <lambdabot>  [5,10,15]
11:16:31 <dons> "Programming in C is like eating red meat and drinking strong rum"
11:16:46 <dons> huh, and after we just had our conversation about haskell being the vegetarianism of languages
11:16:58 <Saizan> ddarius: mmh with immutable lists you'd have to pass the (\x -> cons (f (car l)) x) to the recursive call to make it TC, right?
11:17:00 <sizur> oh no! not vegies!
11:17:09 <SamB> I think Haskell is way better than vegetarianism
11:17:17 <kaol> not breatharianism?
11:17:35 <dons> maybe vegetarianism is better than you think, SamB :)
11:17:57 <SamB> I suppose it's possible
11:18:06 <sizur> Haskell is the Heavy Metal of the New Age.
11:18:23 <ddarius> Saizan: That would just turn stack space into heap space.
11:18:35 <SamB> sizur: maybe if you run out of millolegs...
11:18:46 <sizur> lol
11:19:19 <shachaf> SamB: For whom? :-)
11:19:55 <SamB> well, see, Haskell doesn't seem to cause headaches...
11:20:00 <sizur> Haskell is the tangent of math and the world
11:20:49 <monochrom> Haskell is a purely functional non-strict statically typed programming language.
11:20:59 <sizur> that is useful actually!
11:21:23 <monochrom> I mean: why all the false metaphors.
11:21:41 <sizur> btw, any function in C is pure ;) with implied world state parameter
11:22:02 <byorgey> Haskell is people!!
11:22:12 <sizur> people, it's Haskell!
11:22:18 <dcoutts_> g'evening byorgey
11:22:23 <byorgey> hey dcoutts_
11:22:50 <litb> hm, why is this?
11:23:02 <litb> (<*>) f g x = f x (g x) -- definition of <*> for (->)r
11:23:17 <litb> but in the class Aplicative it says: (<*>) :: f (a -> b) -> f a -> f b
11:23:18 <fasta> #haskell talks too much :)
11:23:22 <Cale> GHC is actually a bunch of slave labourers translating your program into machine code?
11:23:32 <monochrom> Or is that the whole point of "elevator pitch"? To give sweet talks by way of false metaphors, even false information, to make the audience feel good without learning anything, and to avoid calling a shovel a shovel?
11:23:46 <Cale> litb: yes
11:23:46 <byorgey> litb: that's right.  replace each 'f' with r -> and wee what you get.
11:23:47 <sizur> litb, because that's the function functor
11:23:48 <litb> so, <*> in Applicative requires 2 arguments, but the instance decl for (->)r uses 3 arguments?
11:23:54 <byorgey> uh, *see
11:23:54 <fasta> monochrom: you found their little secret.
11:24:16 <byorgey> litb: 'number of arguments' is a red herring.
11:24:19 <Cale> Functions from r have an additional argument of type r, of course
11:24:20 <monochrom> Then this world is really sick and bent and pervert.
11:24:36 <sizur> monochrom, no false ones! just white sales
11:24:37 <Cale> litb: Of course, all functions in Haskell really have only one argument.
11:24:42 <fasta> monochrom: there is no law of nature against that.
11:24:58 <monochrom> When has people stopped wanting to learn something for rea?
11:24:59 <Cale> litb: It's just that some functions result in other functions when applied.
11:25:27 <Cale> I has a cheezburger.
11:25:34 <sizur> monochrom, problem is you cannot learn everything, however you can lean anything ;) question is what will you choose to lean
11:25:37 <TomMD> monochrom: Could it be that you are bitter about having to explain your research?
11:26:12 <sizur> monochrom, we still have the 120 years limit you know ;)
11:26:26 <monochrom> I am not bitter as long as I am allowed reasonable length for the description.
11:26:41 <TomMD> Excellent - I have all day ;-)
11:26:47 <fasta> monochrom: how do you think about presentations about non-trivial topics?
11:27:01 <monochrom> They have to be non-trivial presentations.
11:27:04 <BMeph> litb: f(a-b) for lists is [a->b]. For (r->), it becomes: (r->a->b)
11:27:15 <dcoutts_> dons: that set-car! is interesting, one reason they don't know how much code would break is they cannot just change the type and find out like we can if we switch between immutable and mutable types.
11:27:19 <BMeph> s/f(a-b)/f(a->b)
11:27:45 <litb> ah, that makes it clearer BMeph
11:28:04 <BMeph> monochrom: Congratulations, you have just found the essence of US politics! ;p
11:28:16 <Cale> I think we need to care just a little bit less about mainstream acceptance. The community's growing at a reasonable pace, and acceptance of things like referential transparency and good type systems are essentially inevitable anyway.
11:28:34 <BMeph> litb: Whew, thanks! I was hoping that it wouldn't confuse you more, heh-heh. :)
11:29:25 <sizur> Cale, i agree, but without sales, electricity would got wide use later, and you might still be sitting on Commodore 64 ;)
11:30:02 <Cale> Just worry about making the language awesome, not so much about how many people are using it.
11:30:29 <sizur> language is awesome already, what we need is libraries and frameworks
11:30:32 <BMeph> litb: for example, look at join :: m (m a) -> m a
11:30:43 <Cale> sizur: There are basic things which are pretty broken.
11:30:48 <sizur> and for that we need more ppl
11:30:54 <litb> ok, well then: (<*>) :: f (a -> b) -> f a -> f  for f=(r->) will become: "(<*>) :: (r -> a -> b) -> r -> a -> a -> b"
11:31:08 <Cale> There are enough libraries for me :)
11:31:11 <Cale> hehe
11:31:17 * litb hopes that it did it right
11:31:23 <litb> s/it/he/
11:31:24 <sizur> not for me :( i want to actually use haskell at work
11:31:33 <Cale> I couldn't possibly use all the libraries on Hackage already!
11:31:37 <dcoutts_> sizur: and we need decent packaging & distribution infrastructure
11:31:49 <BMeph> sizur: Nice argument, but specifically false. The Commodore Amiga shows that Commodore's problem was a severe lack of marketing skill, just as Microsoft's success comes from excellent marketers.
11:31:53 <fasta> Cale: you wouldn't want to, neither.
11:31:55 <Cale> (I've barely had a chance to look at them all!)
11:31:56 <sizur> dcoutts_, agreed. although Cabal is pretty good if you ask me
11:31:57 <dcoutts_> hackage still needs more work, join in the hacking! :-)
11:32:04 <litb> i forgot parens: "(<*>) :: (r -> a -> b) -> (r -> a) -> a -> b"
11:32:17 <fasta> Hackage lacks a quality selector.
11:32:21 <byorgey> litb: not quite, should be (<*>) :: (r -> a -> b) -> (r -> a) -> r -> b
11:32:35 <sizur> BMeph, what was false? i said electricity would got used widely much later without sales
11:32:47 <litb> oh right, we don't know what b is yet
11:32:53 <sizur> BMeph, and as a consequence, computers would got developed later
11:33:08 <BMeph> sizur: ...and you might still be sitting on Commodore 64 ;)
11:33:21 <litb> ah, yeah, it even says "f b" ok. i think i got that part
11:33:25 <fasta> sizur: if Tesla's ideas would be known to everyone, we would have free energy :)
11:33:29 <sizur> BMeph, exactly ;) because it would come out only at 2005 ;)
11:33:37 <dcoutts_> fasta: yes, that's top priority for hackage development, effective automatic ways to gauge package quality
11:33:49 <sizur> fasta, agreed
11:33:53 <SamB> BMeph: a, how nice that would be ;-)
11:33:55 <byorgey> litb: this is known as the 'S combinator' =)
11:34:02 <sizur> fasta, however, again he was lacking sales for that
11:34:05 <BMeph> sizur: But with the way Commodore works, they'd've sunk before developing it. ;p
11:34:06 <litb> frankly, i don't find it difficult to understand monads. much more difficult is to get that type substitution right
11:34:11 <Cale> sizur: What's the rush?
11:34:21 <byorgey> litb: well, that comes with practice
11:34:22 <monochrom> Let haskellers mod up or down packages on hackage. :)
11:34:28 <fasta> Cale: sizur just explained we only live < 120 years .
11:34:34 <fasta> Cale: :)
11:34:37 <Cale> fasta: yeah, so?
11:34:45 <monochrom> "reddit.hackage.haskell.org" :)
11:34:52 <fasta> Cale: so, if you want to change that bound, you need to rush, I guess.
11:34:59 <monochrom> Let them write comments, mod up, mod down. :)
11:35:00 <Cale> meh
11:35:09 <TomMD> monochrom: Wouldn't a 'popularity' rating do about as well?
11:35:09 * SamB still hasn't figured out how tesla was planning to pay for the power plants
11:35:20 <SamB> TomMD: no
11:35:38 <fasta> I don't like popularity mechanisms.
11:35:40 <monochrom> Well, popularity = let people mod up, mod down, as far as I can tell.
11:35:57 <SamB> not if by popularity you mean download counts or anything like that
11:36:13 <fasta> I want to select people I think know what they are talking about with some social network mechanism.
11:36:16 <TomMD> No, I mean "Measure the number of systems using said package or perhaps the number of other packages depending on said package"
11:36:18 <monochrom> I see. Do both then.
11:36:27 <fasta> That's at least robust.
11:36:33 <SamB> even that isn't so useful for libraries...
11:36:40 <SamB> though at least it is information
11:36:44 <monochrom> Somehow the Haskell community is sane and tame enough for naked democracy to work.
11:36:59 <monochrom> (Unlike the sick, bent, pervert outside world.)
11:37:01 <TomMD> monochrom: avoid success...
11:37:02 <fasta> No, democracy will never work :)
11:37:17 <Cale> Yes, *avoid* success people.
11:37:20 <FunctorSalad> TomMD: leading to package spam? ;) j/k, monochrom has a point
11:37:55 <FunctorSalad> eigenvector centrality (or how it is called) is vulnerable to sheer numbers, isn't it?
11:37:56 <TomMD> FunctorSalad: I'm not saying my suggestions is perfect (or novel), but I don't like user ratings typically.
11:38:19 <fasta> OMG! KEWL! 5 STARS!!!
11:38:47 <fasta> We don't want HaskellTube, do we?
11:38:47 <litb> i will live 121 i suppose
11:38:49 <SamB> but, I mean, "has installed" is the transitive closure of "depends on" over "wants installed"
11:39:05 <sizur> hmm this guy got only 1 star, but his package is the only one that does what i need, hmmm... so where was that Perl again
11:39:07 <monochrom> Two factors in favour of us. We are tired of sales pitch, sales pitch don't work on us. We don't whine, we try to contribute.
11:39:20 <SamB> or regular closure
11:39:23 * SamB is rusty
11:39:38 <fasta> SamB: what's a regular closure?
11:39:42 <pingus> hi, I'm trying to implement neural networks in haskell --- have to justify the use of haskell in my report, what should I say? ;-)
11:40:07 <sizur> sales
11:40:10 <fasta> pingus: bad idea
11:40:16 <glguy> You should probably include the reasons you picked Haskell in there
11:40:21 <glguy> and how it has helped
11:40:25 <glguy> if you want a good grade
11:40:30 <BMeph> fasta: No, democracy ALWAYS works. It just doesn't work for everything. :)
11:40:33 <sizur> pingus, it's fast, it's easy to understand, it's correct, it grows in popularity, it's portable
11:40:53 <monochrom> "I heard of Haskell on reddit."
11:40:54 <fasta> pingus: GHC numerics is slow.
11:41:09 <fasta> All the cool kids use Haskell.
11:41:22 <pingus> fasta: it's OK if it's not fast
11:41:41 <fasta> pingus: So, it's a toy, in that case, it doesn't matter.
11:41:42 <BMeph> "[Haskell] is made of win and awesome"
11:41:46 <dcoutts_> monochrom, fasta, SamB: we were thinking of using a combination of downloads, build reports and dependencies to gauge package popularity.
11:41:47 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/183
11:41:48 <lambdabot> Title: #183 (Provide &#34;library-rank&#34; in hackage) - Hackage - Trac
11:41:50 <sizur> fasta, what do you mean it's slow? you always use Doubles for NN
11:41:53 <TomMD> pingus: Common debate with plenty of good reasons on the other side.  I would think that before going down the path you would have your reasons.
11:42:05 <fasta> sizur: google will tell you all about it.
11:42:13 <sjanssen> fasta: please no trolling
11:42:14 <monochrom> I am not too sure how strongly you must justify the choice of prog lang, the choice of this, the choice of that, ...
11:42:27 <sizur> fasta, i thought here is the news source ;)
11:42:34 <SamB> dcoutts_: just so long as you aren't using it to gauge how well people like a package...
11:42:36 <monochrom> Like, do you also need to justify the choice of your OS?
11:42:41 <TomMD> pingus: but if you want reasons I (and perhaps others here) use it, then I'd be happy to share.
11:42:45 <yoshi> > filter (/= 'a' && /= 'b') "abc"
11:42:45 <lambdabot>  Parse error at "/=" (column 19)
11:42:47 <SamB> monochrom: probably not.
11:43:07 <sizur> monochrom, in a company setting you always have to justify choices. unfortunately
11:43:12 <fasta> sizur: well, it's old news. GHC numerics is one of the weak points of GHC. I don't know this from personal experience, though.
11:43:19 <SamB> programming language is harder to change than OS anyway
11:43:24 <litb> is there a good book on S combination and such stuff?
11:43:25 <monochrom> IMO you only have to say why Haskell is good enough, no need to say why Haskell is the best.
11:43:36 <litb> teaching how to eat the lambdas?
11:43:47 <monochrom> OK, I'm not talking about company.
11:44:16 <byorgey> > filter (\c -> c /= 'a' && c /= 'b') "abc"  -- yoshi
11:44:18 <lambdabot>  "c"
11:44:20 <Cale> "I decided to use Haskell because that's what I decided to use. If you don't like it, I really don't care."
11:44:22 <BMeph> > filter ((/= 'a') && (/= 'b')) "abc"
11:44:22 <lambdabot>      The section `(/= 'a')' takes one argument,
11:44:22 <lambdabot>     but its type `Bool' has none
11:44:38 <shachaf> You want liftM2 (&&), I think.
11:44:38 <hpaste>  (anonymous) pasted "udev luks" at http://hpaste.org/5241
11:44:39 <sizur> fasta, Integer, Rato, i can agree, but processor primitives...
11:44:51 <byorgey> > filter (`notElem` "ab") "abc" -- yoshi, even better
11:44:51 <lambdabot>  "c"
11:44:52 <BMeph> Must have more dots! ;)
11:44:55 <sizur> Cale, you are fired
11:44:56 <shachaf> > filter (\c -> all (/=c) "ab") "abc"
11:44:56 <lambdabot>  "c"
11:45:25 <monochrom> Not everything is corporate. And not every corporation cares.
11:45:25 <sizur> Cale, take that in quotes :P
11:45:26 <fasta> sizur: Haskell is not programming with processor primitives unless you use Harp.
11:45:28 <byorgey> > filter (liftM2 (&&) (/='a') (/='b')) "abc" -- getting fancy
11:45:29 <lambdabot>  "c"
11:45:38 <Cale> Heh
11:45:55 <jedbrown> > filter (not . (`elem` "ab")) "abc"
11:45:56 <lambdabot>  "c"
11:46:20 <SamB> some corporations may actually trust their technical people to make technical decisions!
11:46:22 <BMeph> fasta: Or a Reduceron. ;)
11:46:47 <fasta> BMeph: right
11:46:48 <sizur> loosing traction there with reality a little
11:47:05 <shachaf> > filter (and . sequence (map (/=) "ab")) "abc"
11:47:06 <lambdabot>  "c"
11:47:20 <litb> or should i simply grab a haskell book for this?
11:47:36 <shachaf> litb: S combination?
11:47:37 <fasta> litb: those combinators are often completely worthless.
11:47:39 <litb> yeah
11:47:50 <fasta> litb: just use what you think helps you
11:48:10 <davidL> should I use strict or lazy bytestrings to keep state?
11:48:21 <litb> oh , it is not crucial to know them?
11:48:31 <czakey> > last "abc"
11:48:31 <lambdabot>  'c'
11:48:32 <shachaf> litb: Crucial for what?
11:48:41 <litb> to code haskell without problems
11:48:49 <litb> e.g write irc clients or such
11:48:49 <hpaste>  (anonymous) pasted "udev luks" at http://hpaste.org/5242
11:48:54 <shachaf> litb: Crucial to know what?
11:48:59 <litb> or don't having problems with Applicative :)
11:49:26 <fasta> litb: I never write against Applicative.
11:49:33 <litb> shachaf: to know what exactly S combination and alpha whatever is
11:49:56 <shachaf> litb: Alpha conversion?
11:50:19 <shachaf> litb: See http://en.wikipedia.org/wiki/Lambda_calculus , for example.
11:50:19 <lambdabot> Title: Lambda calculus - Wikipedia, the free encyclopedia
11:51:13 <shachaf> litb: What do you mean by "S combination"?
11:51:17 <shachaf> litb: Using the S combinator?
11:52:07 <byorgey> litb: no, it's not necessary, just some interesting theoretical aside =)
11:52:21 <byorgey> @go SKI calculus
11:52:22 <lambdabot> http://en.wikipedia.org/wiki/SKI_combinator_calculus
11:52:28 <byorgey> litb: see that if you're interested ^^^
11:52:59 <olsner> (*three* combinators? bloated!)
11:54:58 <glguy> only S and K are primitive
11:55:08 <byorgey> @slap olsner
11:55:08 * lambdabot is overcome by a sudden desire to hurt olsner
11:55:17 <sizur> SamB, i'd like to see a corporation like that. if you can find one it's great. there are many problems, even if the leadership wants to give you choice freedom: legacy platform, cost of change, retraining of all the ppl who relate somehow to your code, etc.
11:55:25 <monochrom> It is still nice to get the word "ski". People like to ski.
11:55:53 <glguy> sizur: I'd like to introduce you to galois ;)
11:56:06 <magnus_> I'm having weird problems. I've installed mtl yet I get "Could not find module `Control.Monad.Writer'"
11:56:15 <sizur> glguy, nice
11:56:27 <monochrom> My "technical merit" would include those concerns.
11:56:43 <radix> anyone know the status of vectorisation support in GHC/Data Parallel Haskell?
11:56:55 <TomMD> sizur: Don't be lured in - they eat up all the good Haskellers and no one ever leaves!  (ignore Gill).
11:56:59 <radix> is there a mailing list or blog or something about GHC/DPH?
11:57:05 <allbery_b> magnus_: does the next line or so say something about "is hidden"?  if so you need to edit the *.cabal file to include a dependency on mtl
11:57:26 <allbery_b> (otherwise, well, we need to see more of the message, and possibly other details as to what you're doing)
11:57:27 <magnus_> allbery_b: it does not
11:57:35 <monochrom> "let the technical people decide" - the technical people are themselves the very ones affected by those concerns. they will give them a fair treatment.
11:57:52 <sizur> code cowboys just dont cut it, no matter how good they are. if you decide to move to Hawaii, the company dies?
11:58:19 <magnus_> allbery_b: I'll make a paste. hold on...
11:58:32 <Eiler> Cale: "In applications where performance is required at any cost, or when the goal is detailed tuning of a low-level algorithm, an imperative language like C would probably be a better choice than Haskell, exactly because it provides more intimate control over the exact way in which the computation is carried out." what do you say about that?
11:58:43 <yoshi> if (`notElem` ".-") :: Char -> Bool, why does: all isDigit (`notElem` ".-") "-1.3" fail
11:58:51 <yoshi> > all isDigit (`notElem` ".-") "-1.3"
11:58:51 <dbueno> If I'm reading the StdGen docs correctly (GHC 6.8.2), the following should not happen, right? read "doofusnoParse" :: StdGen --> *** Exception: Prelude.read: no parse
11:58:55 <lambdabot>      The section `(`notElem` ".-")' takes one argument,
11:58:55 <lambdabot>     but its type `[Ch...
11:59:20 <dbueno> Is that a bug, or my ignorance? I couldn't find anything on trac....
11:59:51 <magnus_> allbery_b: actually, it seems that the debian package doesn't get mtl registered with ghc-pkg. I'll keep investing
11:59:59 <magnus_> allbery_b: investigating
12:00:32 <Cale> Eiler: Depends. If performance *really* matters, you actually probably don't want to leave it entirely up to a human anyway. Writing a special purpose code generator which does a combinatorial search over a good portion of the solution space might be a better option. Of course, you could write that in a high level language if you want :)
12:00:45 <monochrom> Anyway I wouldn't trust the manager to be able to balance all concerns alone either. The concerns are frontline concerns. The manager is one step detached from the frontline. What does the manager really know anyway?
12:01:33 <sizur> monochrom, i agree, it's CTO's decision, not managers
12:01:34 <jedbrown> radix: If you have HEAD, you can use the ndp package.  I don't know the details, but there is at least partial vectorization.
12:01:41 <Cale> Eiler: another thing is just that high level languages give the computer more information about the problem, and hence more ability to potentially search for a good solution
12:02:01 <hpaste>  (anonymous) annotated "what does "Quantified type variable `o' escapes" mean?" with "answer" at http://hpaste.org/5238#a2
12:02:31 <Cale> Eiler: Another issue is that if high performance is really required, you're probably looking at parallelisation, which is hard to do in a language like C.
12:02:46 <radix> jedbrown: ok, cool. the web site seems to say that they haven't even started with vectorisation, but maybe it's just being conservative about the state of support.
12:03:02 <Eiler> Cale: well it aint totally up to the human, the compiler still comes into action... an example is the quicksort(hoare in C), which obviously is faster and uses less memory
12:03:36 <sizur> manager's sole purpose it to crack the whip and give cookies.
12:03:52 <Eiler> Cale: directly from the haskellwiki introduction
12:03:57 <radix> jedbrown: I'm dreaming of writing a ray tracer that's automatically parallelized :)
12:04:21 <Cale> Eiler: So while C certainly does give you lots of control to hand tune things, it also doesn't help you all that much. Similarly, you get much greater control over the implementation by moving to assembly code, but even implementing some things, let alone performance tuning them can be quite hard.
12:04:50 <Cale> Eiler: Well, you can write the C code in Haskell too -- it looks different from the provided Haskell code though.
12:04:52 <Eiler> Cale: yes of course
12:05:09 <Eiler> thats usualy the result of lower vs higher level languages
12:05:19 <jedbrown> Eiler, Cale: See the paper on optimal FFT here: <http://okmij.org/ftp/NumMath.html#FFT-generation>  They show a code generator that matches instruction count with FFTW, but through reductions, rather than searching for tuning parameters.
12:05:36 * SamB thinks manager should merely threaten not to give cookies from next batch
12:05:53 <kaol> pfft, who needs a CPU. for best performance, put the logic on an ASIC board.
12:06:04 <Eiler> Im not talking about c++ code called from haskell now or assembly called from c++ or whatever
12:06:20 * FunctorSalad was almost driven crazy yesterday by trying to write "regexec" pointlessly.
12:06:24 <Cale> Eiler: FFTW is a good example actually.
12:06:25 <SamB> kaol: CPUs are great for things that don't need to be fast
12:06:27 <FunctorSalad> @type regexec
12:06:29 <lambdabot> Not in scope: `regexec'
12:06:38 <olsner> regexec?
12:07:01 <kaol> SamB: just taking the "C is better. No, asm is!" thing to the logical conclusion ;-)
12:07:15 <Cale> If you're unfamiliar with it, FFTW consists of an O'Caml program which generates fast Fourier transform code.
12:07:52 <FunctorSalad> olsner: compile :: CompOption -> ExecOption -> String -> IO (Either WrapError Regex)     and     regexec :: Regex -> String -> IO (Either WrapError (Maybe (String, String, String, [String])))
12:08:16 <pejo> Eiler, I think Cale was talking about writing "low level Haskell", not calling a foreign language from within Haskell. (See the language shootout for great examples).
12:08:16 <kaol> and doesn't Haskell already have some fame in circuit design?
12:09:13 <sizur> hey galois is in oregon! nice
12:09:18 <Cale> Another problem with programming in assembly directly now is that understanding some of these processors' pipelines can get rather hairy.
12:09:30 <RayNbow> http://reddit.com/r/programming/info/66p62/comments/ <-- ugh... crappy tattoo is crappy
12:10:21 <BMeph> yoshi: isDigit :: Char -> Bool. (`notElem` ".-") :: Char -> Bool "-1.3" :: [Char] Try a "filter in there, like:
12:10:23 <SamB> kaol: the trouble with ASICs is that they aren't software...
12:10:25 <Eiler> pejo: well ye, but the wikihaskell introduction says C provides more intimate control over the exact way in which the computation is carried out
12:10:40 <SamB> kaol: perhaps you should have said something about an FPGA
12:10:44 <BMeph> > all isDigit $ filter (`notElem` ".-") "-1.3"
12:10:45 <lambdabot>  True
12:10:48 <FunctorSalad> my nasty solution: "main = re >>= (ignoreLeft >>> regexec >>> ($"foobar") >=> ignoreLeft >>> ignoreMaybe >>> fourth >>> wr)", where re is a IO (Either WrapError Regex) and ignoreLeft, ignoreMaybe do the obvious thing =)
12:11:05 <FunctorSalad> and wr does something with the match
12:11:21 <Cale> Eiler: It does. That doesn't necessarily mean that you'll always be able to write a better C program than the Haskell compiler. :)
12:11:40 <Eiler> Cale: why are we talking assemly? its often not so hard to implement algorithms in C and understand pretty much how it works under the hood
12:11:48 <jedbrown> C overspecifies the method.  Ideally, the high-level description does not, therefore sufficient code-manipulation would be able to generate optimal assembly.
12:11:55 <Cale> Eiler: Because it's the same issue at another level.
12:11:57 <yoshi> Bmeph: thanks,gosh these type errors are driving me up the wall
12:12:24 <Cale> Eiler: The choice you make between C and assembly is in some sense the same choice as the one you make between Haskell and C.
12:12:36 <Eiler> Cale: thats correct, but it still gives the possibily to optimize and speficy more exactly in some cases exactly what you want to do
12:12:39 <jedbrown> In contrast, the C compiler must deduce that it was actually overspecified and find ways to remove it.
12:12:45 <BMeph> yoshi: Types are your friends. ;)
12:12:59 <yoshi> haha =]
12:13:01 <BMeph> Be good to the types, and the types will be good to you.
12:13:14 <shachaf> yoshi: Type errors driving you up the wall are better than runtime errors driving you up the wall. :-)
12:13:22 <nelhage> The types are your friends, but they can be somewhat prickly friends until you get to know them :)
12:13:45 <Eiler> Cale: in sense of level abstraction i agree. But its still okay to write huge programs both in c++ and haskell. The same cant be said about assemly .. today, even if it is technically possible
12:13:46 <BMeph> Eiler, Cale: If I were really looking for high-performance, I'd code in FORTH, heh-heh. ;)
12:13:55 <fasta> Types are your enemies, type inference is your friend.
12:14:04 <Cale> Eiler: I'm not really sure if I agree :)
12:14:18 <olsner> a "Segmentation fault" is more readable than a half-page type error, though
12:14:42 <mux> a "segmentation fault" barely contains any useful information though
12:14:54 <Cale> olsner: More *readable*, but *far* less useful.
12:14:56 <lispy> Cale: you can do some very nice high level programming in C++ as long as you're very competent in the language.  Also, you still won't be 100% typesafe
12:15:21 <cjb> mux: a core file showing you precisely the line of code that failed, along with the current stack and call trace, is entirely useful.
12:15:24 <Eiler> Cale: I know you aint but thats okay :), as an objective look... even if haskell aint as popular. Many huge programs are written in c++ today, in assembly.. not so much, only small parts.. if any is.
12:15:28 <lispy> Cale: so i'd be happy to conceed taht you can write large apps in C++ these days.
12:15:45 <Cale> lispy: I know. However, I have a hard time trusting many of the abstractions people have set up simply because of their ridiculous and complicated implementations.
12:15:47 <mux> cjb: sure, but that's not the point here, olsner was referring to the readability of a "segmentation fault" message
12:15:47 <nelhage> Honestly, a segfault + gdb gives me about the same leve of information at first look as a page-long type error: It gives me a location that is probably vaguely related to what went wrong.
12:16:16 <Cale> Eiler: that's a matter of popularity
12:16:29 <cjb> mux: I don't think that's what he actually meant.
12:16:39 <lispy> well, that popularity can't be completely unfounded, right?
12:16:41 <Eiler> Cale: well not the comparision between c++ and assemly and the usage of those for big programs
12:16:43 <Cale> Eiler: If you're trying to say that C++ is more popular than assembly or Haskell, well, yes, of course it is :)
12:16:46 <FunctorSalad> for me a problem with the type errors is that I don't understand what exactly it means by "inferred" and "expected" :)
12:16:57 <olsner> for me, type errors tell me less than a crash+stack trace/gdb, but that might just be lack of haskell experience
12:17:00 <FunctorSalad> I mean, inferred could kind of refer to both
12:17:18 <lispy> FunctorSalad: expected is what the type signatures gave it, inferred is what it actually had according to type inference.
12:17:23 <Cale> If you're trying to say that it's more appropriate for writing large programs than Haskell, well, that I'm not so sure about.
12:17:29 <monochrom> I'm thinking you have no access to intstruction re-ordering and branch predication and speculative execution etc. in C.  Sometimes you may think you have access to instruction ordering by writing your statments in your order, but the compiler will yet find out it's sub-optimial and foil you. Therefore, on an absolute scale, I disbelieve that C gets you access to under the hood. (Relatively? Sure, you get just a bit more than
12:17:29 <monochrom> Ruby...)
12:17:31 <mux> a stack trace is more like low-level information about a bug
12:17:45 <mux> it shows you precisely the symptom of the bug, and the surrounding context
12:17:47 <Cale> monochrom: right.
12:17:48 <nelhage> To me the advantage of a type error over a core file+gdb is not information content, but that the type error happens earlier.
12:18:06 <Cale> monochrom: At the same time, C shields you from having to deal with that information to some extent.
12:18:11 <mux> a type mismatch error is high-level information about a likely problem
12:18:29 <Cale> Just like Haskell shields you from having to deal with irrelevant details like the order of evalution of expressions.
12:18:32 <Eiler> Cale: thats not really what im saying. I just reserved your point that not many big programs may not be written in haskell because the language still aint so popular. But thats not the case between why so many big programs are written in C++ vs assemly. C++ provides a object approach(among others) and is pretty well suited for writing big programs, assemly aint.. its usually way to hard and time consuming
12:18:38 <nelhage> When ghc throws half a page of type error at me, I often end up just looking at the location and going back and rethinking the code without trying to parse the actual error.
12:18:53 <mux> clearly, good error messages are hard
12:19:26 <Cale> Eiler: It's not *that* hard. You can still set up good abstractions in assembly. You just have more to keep track of by hand.
12:19:31 <FunctorSalad> lispy: hmm I meant things like 'let a = "baz" in a+2', then you can both 'infer' that a is a String and that it is a Num depending on where you start :)
12:19:36 <lispy> Eiler: people who do write applications in asm tend to create a language of macros and effectively write in some other language that supports inline asm :)
12:19:46 <Eiler> Cale: its insanely much harder
12:19:53 <Cale> Eiler: well, okay.
12:19:58 <jedbrown> mux: Of course the type error will happen every time, but the seg fault may happen very rarely so that you miss the bug.
12:20:13 <Cale> Eiler: It's also insanely much harder to write correct C++ programs than it is to write correct Haskell programs.
12:20:21 <fasta> At least there is a fast interpreter for asm....
12:20:24 <SamB> Cale: you can't get so much code compression out of abstractions in assembly...
12:20:32 <mux> jedbrown: yeah; I think this just goes to show how different things they are
12:20:38 <SamB> or use them for optimization...
12:20:56 <sizur> Cale, it's insanely harder to prove them correct, not write :)
12:21:07 <Eiler> Cale: not insanely, you might have your type safety and stuff. And it might even be easier but the gap aint even close as between c++ and assembly
12:21:11 <lispy> the fundamental drawback of detecting bugs an run-time is that you have to have the right input to hit the buggy line and you have to have the right input to trigger it.  All pathes and possibilties are considered when type checking.  It's just that, not all type errors would cause invalid programs and not all bugs can be detected.
12:21:21 <Cale> Eiler: I beg to differ.
12:21:43 <Eiler> Cale: the big companies dont, they have made their choices.. as of today at least
12:21:48 <Cale> Eiler: Even C++ (though I thought we were talking about C?) makes you think about way too many irrelevant things
12:22:31 <fasta> Every currently existing programming language makes you think about irrelevant things. See my comments about slow computers.
12:22:33 <Cale> Eiler: Yes, but that has more to do with programmer availability and the cost of hiring.
12:22:42 <pejo> Eiler, do you honestly think that companies base their decisions on what language to use from a technical point of view+
12:23:03 <BMeph> Am I wrong to prefer writing code in either C or Java than C++? Either way, I'd definitely much rather write code in Haskell, though. ;)
12:23:08 <Eiler> Cale: well we were talking about C but i mean C++ also, since c++ is often use and C is almost a subset up C++... its built on it but there is some small things that dont make it a subset strictly speaking
12:23:16 <jedbrown> Eiler: Note that companies and agencies that care a lot about correctness don't write C++.
12:23:17 <Cale> BMeph: I kind of agree with you there.
12:23:43 <BMeph> Cale: Thanks! :)
12:23:44 <Cale> Eiler: C++ is a much different language.
12:23:50 <Eiler> pejo: what do you think? they say... do we wanna spend 10 years writing a game using assemly or write a game in 1 year using c++ and profit?
12:24:23 <lispy> Eiler: and they also say, "where will we get programmers for language X?"
12:24:27 <sizur> Eiler, you are right there, but what about C++ vs Haskell?
12:24:31 <nelhage> BMeph: I certainly know what you mean.
12:24:33 <pejo> Eiler, Cale pointed out that programmer availability and cost of hiring was relevant, just as I had typed that.
12:24:39 <lispy> Eiler: and, "How will we integrate with middleware X"
12:25:02 <SamB> or ... DirectX
12:25:06 <Cale> Eiler: anyway, just wait a few years :)
12:25:06 <sizur> ditto lispy
12:25:11 <Eiler> Cale: it is, but in the sake of the conversation im relating to both even if i didnt explicit started with it. C++ is hugely commonly used and similar performance to C, and a little faster developement time.. especially for big projects
12:25:24 <Cale> Eiler: In a few years, when 80 core machines are the norm, we'll have this discussion again :)
12:25:58 <SamB> C++ and C will probably still be related in the same way, though
12:26:01 <lispy> I would say high-level C++ is actually very slow compared to C
12:26:18 <lispy> vectors, for example, aren't all that efficient.
12:26:20 <Cale> Things like C and C++'s obsession with irrelevant details like execution order will suddenly take on a new meaning. :)
12:26:45 <piojo> lispy: compiling with optimizations made a world of difference for me, last time I used high level C++ with lots of STL use
12:26:52 <piojo> 10x speedup
12:27:14 <piojo> intolerably slow -> fast enough
12:27:26 <Eiler> Cale: no need cause its not really important to this discussion.. when we have 80 cores we dont really know what it will look like or if totally new languages will be out or if the machines gets so fast that itself gives a more preferably option to use higher level languages. But of today.. C++ is commonly used based on popularity and performance/developement speed(difficulty)
12:27:37 <lispy> also, something a lot of people don't know about C/C++ is that malloc/free, new/delete are terribly inefficient unless you use them for big chunks infrequentely
12:28:22 <sclv> oh, ffs, what's the sanest -X to bring forall into scope again?
12:28:36 <mxc> sorry for getting in the middle, but does ghc generate code htat takes advantage of multiple procs/cores?  it seems that referential transparency should make auto-parallelization much easier
12:28:37 <scodil> lispy: gnu's libstdc++ uses a pooled allocator for stl containers. It's pretty fast.
12:28:39 <shachaf> sclv: It depends on what you're using it for.
12:28:49 <Cale> Eiler: Look at it this way: basing your entire language around the concept of "do this, then do this", that is, sequential composition of stateful, side-effect causing operations, makes for a damn hard time parallelising.
12:29:06 <thoughtpolice> scodil: -XExistentialQuantification
12:29:08 <thoughtpolice> erl
12:29:13 <thoughtpolice> sclv i mean :x
12:29:21 <scodil> is that a haskeller retort? :)
12:29:25 <lispy> scodil: actually, my complaint was that where I work we had to change a bunch of code I wrote using new/auto_ptr to use stack based variables because of efficiency.
12:29:41 <BMeph> Eiler: I say, if you're gonna write big programs, use the language of choice that's been time-tested, and still overwhelmingly popular: COBOL! ;)
12:29:45 <sclv> right, thanks!
12:29:57 <Eiler> Cale: yep it certainly can be in some aspects, you are correct there, but we only have 4 cores today on x86, and to implement it on 2 or 4 cores is totally doable
12:30:01 <Cale> If you want to run on 80 cores, or on 800 cores, (and 2 is already hard enough in imperative languages), at some point you're going to need to give up your obsession with specifying the order in which things are computed.
12:30:20 <lispy> scodil: and then i read this book for intermediate/advanced level C++ programmers and there is an entired chapter on writing your own allocators for quick allocation because the language builtins apparantly suck :)
12:30:27 <jedbrown> mxc: You need to annotate your code for parallelism.  (Or use explicit threading.)  Then compile with -threaded and run with +RTS -N4 (for 4 threads).
12:30:35 <Cale> Intel is already talking about building 80 core machines.
12:30:36 <pejo> mxc, http://cgi.cse.unsw.edu.au/~dons/blog
12:30:37 <lambdabot> Title: Haskell hacking
12:30:46 <scodil> lispy: yes, and the gcc people have done that, with std::alloc.
12:30:59 <thoughtpolice> mxc: you can take advantage of multiple cores using the threaded runtime. the whole 'referential transparency = automatic parallelization' thing assumes a SufficientlySmartCompiler, of which I don't think GHC qualifies in that area.
12:31:04 <lispy> scodil: gcc++
12:31:12 <lispy> scodil: (as in, that's great!!)
12:31:16 <mux> Cale: I so fully agree with you.  C inserts sequence points about everywhere, notably at each function call
12:31:29 <Eiler> Cale: yeah talking... look on their existing roadmap for the coming years, its not saying anything about 80 cores coming
12:31:34 <thoughtpolice> the main problem I think is the granularity of the parallelization when it's so automatic.
12:31:45 <kaol> @go intel "80 cores"
12:31:46 <lambdabot> http://www.news.com/2100-1006_3-6119618.html
12:31:46 <lambdabot> Title: Intel pledges 80 cores in five years | CNET News.com
12:31:53 <meryrus> End of game.
12:31:55 <Cale> Eiler: http://www.news.com/2100-1006_3-6119618.html
12:31:55 <lambdabot> Title: Intel pledges 80 cores in five years | CNET News.com
12:32:37 <monochrom> This is an interesting time to live in!
12:32:41 <kaol> I want one of those
12:32:49 <jedbrown> Cale: I don't think we'll see 800 cores in common usage until imperative languages are out of the main stream.  The cache coherency issues kill that model.
12:32:55 <thoughtpolice> i would be very happy with 2 cores. :(
12:32:57 <Eiler> Cale: that is still talking abviously it will come in the future... but it aint here and it aint here next year or in next next year.. Im not gonna go to sleep and wake up then to develope a program
12:33:10 <scodil> lispy: I was curious once and I tried putting a million or so ints into gcc's std::map and into ghc's Data.Map. Gcc's won by a large margin. I'm sure there explanation for that is complicated, because std::map can is mutable and what not, but the generalization that C++ allocation = slow doesn't always hold
12:33:56 <astrolabe> How long does it take for the number of cores to double?
12:33:57 <monochrom> You have five years to shift your programming paradigm for multi-core. Do you think it is enough time?
12:34:00 <lispy> scodil: cool.  I have to do all my C++ in VS, so, for me it is slow :)
12:34:10 <meryrus> monochrom, the other option is to retire.
12:34:17 <Eiler> Cale: in 5+ years c++ can have totally changed, haskell can have changed and there might be new languages out there
12:34:42 <lispy> standardized languages cannot change in 5 years to be totally different
12:34:43 <monochrom> It took even Java almost ten years to gain momentum.
12:34:43 <shachaf> scodil: If you were using ints, perhaps you should've used IntMap?
12:34:55 <jedbrown> astrolabe: Last year, the answer would have been 50 years.  This year, it's 1 year.
12:34:56 <Cale> Eiler: Basically, if languages don't look *something* like Haskell does now, they won't be able to function.
12:35:25 <scodil> shachaf: intmap is only a little bit faster than map. the main advantage, as i understand it, is that it does unions/intersections way faster, but i have not witnessed that first hand
12:35:53 <BMeph> thoughtpolice: A couple of my Comp Engineering buddies put together an eight-core machine...about 20 years ago. ;)
12:35:53 <Cale> That is, referential transparency will be *crucial*
12:35:53 <SamB> totally
12:35:53 <SamB> at least, to the extent that it is in Haskell ;-)
12:35:54 <monochrom> C++ five years to just add templates.
12:35:55 <Eiler> Cale: maybe, but even if it would be so that dont rule out to use them that are better today
12:35:57 <astrolabe> jedbrown: 1 year would be incredibly fast.  I can't believe that will be sustained.
12:36:08 * SamB points in Lava's general direction
12:36:23 <monochrom> The alternative is to argue that there is no need to shift paradigm, that most languages have threading libraries, just use them. We will see how well that plays out.
12:36:30 <TomMD> SamB: Wasn't Lava abandoned?
12:36:31 <jedbrown> scodil: IntMap is a trie while Map is a tree.  That causes a significant difference in the complexity.
12:36:31 <thoughtpolice> BMeph: sounds like awesome stuff, honestly. :) i'm still on a p4 which isn't bad, but I would like my haskell to use 2 cores. :)
12:36:40 <SamB> TomMD: eh?
12:36:55 <SamB> TomMD: you only say that because there has been no activity on the website...
12:37:02 <monochrom> IMO "just use the threading libraries" is do-able but will lead to much hair loss at least. :)
12:37:05 <TomMD> SamB: Xilinx nixed it and there is a new functional HDL out now in the academic world, right?
12:37:09 <Cale> Eiler: You do whatever you want. I'm just saying that it might be a cold awakening in a few years :)
12:37:41 <TomMD> SamB: I only say that because I see this new "wired" or whatever and I heard Xilinx dropped it.
12:37:52 <SamB> TomMD: Xilinx-lava has not seen the light of day for a while, sure, but what about chalmers-lava?
12:37:59 <jedbrown> astrolabe: Yes.  The Cell (1 + 8 cores) has been around for a while now, it's just really hard to program for currently.
12:38:03 <Eiler> Cale: im not standing still, i keep moving in time
12:38:28 <monochrom> Do heed that "debugging" is out of the question when parallelism becomes heavy.
12:38:29 <jedbrown> astrolabe: But if it was easier, I think we'd see rapid progress in that direction for a few years.
12:38:29 <TomMD> SamB: That is why I am (saying?  asking?  I'm not sure).  Didn't Chalmers start on a 'new' evolution to Lava?
12:38:39 <SamB> TomMD: hmm?
12:38:49 <SamB> don't they usually call those Lava?
12:39:05 <scodil> jedbrown: Yeah I know the complexity is different, I was talking about actual timings. For basic inserts, deletes and lookups of single elements, IntMap does not go a whole lot faster than Map. Map nodes are actually smaller, and the IntMap trie is twice as big as a Data.Map tree, because it has to put everything in leaves, so maybe that explains the difference.
12:39:17 <BMeph> thoughtpolice: Yeah, I play online games, but since I'm also a SW Engr. student, I'm shelling out my big bucks to the textbooks, heh-heh. I do have a Core 2 Duo board, though, and it makes a lot of difference, even though the cores are slower than my earlier single processor.
12:39:41 <scodil> er, not the difference, but maybe that's what IntMap's do not beat Data.Maps by as much as one would expect
12:39:46 <TomMD> SamB: http://www.cs.chalmers.se/~emax/wired/  this is where I've seen the recent work.  Guess it doesn't mean Lava is dead though.
12:39:46 <lambdabot> Title: W i r e d :&nbsp Expressing and Estimating Non-Functional Properties of Digital  ...
12:40:20 <BMeph> TomMD, SamB: Aren't the York guys using Lava in the Reduceron project?
12:40:21 <SamB> eww, frames
12:40:21 <thoughtpolice> BMeph: I will hopefully be headed to college soon so I'll have to beg for a nice development computer with a core 2 duo. :)
12:40:58 <monochrom> Now I actually fear that the parallelism will cause a new Dark Age, or rejuvenate a past Dark Age. The past Dark Age of "the program has hung/crashed again? nevermind, software is always like that. just re-start it." The Dark Age of pervertedly enjoying software to be fragile.
12:41:01 <TomMD> York Guys:  Are you using Lava?
12:41:19 <jedbrown> scodil: What size were you working with?
12:41:22 <scodil> Hey does anyone know if you can mix GHC threads with, say, pthreads? Like, can I put a pthread mutex in a C function, and expect it work work nicely with forkIO ?
12:41:26 <TomMD> BMeph: ;-)  If thats so, news to me but certainly good news.
12:41:42 <SamB> why didn't they add a link to the wired site from the lava site...?
12:41:43 <scodil> jedbrown: I forget, something like 100,000 - 1mil
12:41:51 <BMeph> thoughtpolice: Yes, yu should - good luck! I've been "in college" for over twenty years. I hope to actually earn a degree from it, soon... ;)
12:42:04 <BMeph> TomMD: http://www-users.cs.york.ac.uk/~mfn/reduceron2/
12:42:05 <lambdabot> Title: The Reduceron II
12:42:16 <thoughtpolice> BMeph: thanks for the confidence! it's scary stuff, definately
12:42:23 <BMeph> That's what the blurb says.
12:42:43 <thoughtpolice> scodil: ghc threads are lightweight so if you use a mutex or some thread-blocking-function, you'll stop all the lightweight threads on that particular OS thread
12:42:47 <thoughtpolice> you can avoid that using the OS runtime
12:42:51 <thoughtpolice> er
12:43:02 <thoughtpolice> the threaded ghc runtime
12:43:19 <scodil> yeah I'm talking about SMP, not lightweight threads
12:43:33 <scodil> +RTS -N8 and whatnot
12:43:33 <jedbrown> scodil: Hmm, my algorithms were much better in that range with IntMap, but there was a lot of taking apart and reconstruction, rather than individual element inserts.
12:43:56 <Eiler> Cale: you think imperative languages will die out because of many cores and only functional ones will exist?
12:44:11 <monochrom> Here is how this Dark Age will re-appear. Parallelism is impossible to debug. If you can't prove your program correct, it is definitely erroneous, just waiting for the right timing to get into a race condition. They will happen and they will be irreproducible. You have two choice: shift paradigm to eliminate them, or accept them as fact of life. History shows that human prefers the latter.
12:44:17 <scodil> jedbrown: yeah I think IntMaps really shine when you do more complicated things, because it doesn't have the overhead of rebalancing, like if you take sub-ranges
12:44:27 <cjb> Eiler: It's not an entirely unreasonable argument.
12:44:37 <scodil> i have a hunch that rebalancing puts a lot of pressure on the GC
12:44:47 <cjb> People *hate* writing threaded imperative code.  Most software uses one core, people are occasionally brave enough to use two.
12:44:59 <SamB> monochrom: well, when they happen always then you tend to want to try something else...
12:45:03 <cjb> yeah, GHC needs a concurrent GC
12:45:20 <monochrom> Just these few years we have finally got Windows to crash less and (more importantly) people to expect it to crash less. It is depressing to predict that in five years people will allow dismal quality once again.
12:45:39 <Eiler> maybe i should have written that question in another way. Is it impossible for imperative language to parallellize in a similar way to functional ones
12:45:58 <Eiler> or make them work on so many cores
12:45:58 <thoughtpolice> if you look at most imperative languages, it seems reasonable to assume they were 'prematurely optimized' for single-core execution.
12:46:07 <SamB> Eiler: well, they must first transcend imperativism
12:46:10 <TomMD> cjb: This is why I love task parallelism, its easy and (given the right problem) can scale really well using one of many sync methods.
12:46:13 <scodil> so has anybody mixed a C threading library with GHC's threaded runtime? To say, guard access to global variables in C land? Is this possible?
12:46:17 <thoughtpolice> so utilizing more than that gets harder.
12:46:30 <jedbrown> monochrom: And when the hardware manufacturers realize that people are willing to shift paradigm, we'll get a hardware STG Machine.
12:46:57 <SamB> which is not spineless, not tagless, not much like the G-machine, and not terribly fast anyway
12:47:22 <monochrom> SamB: There is a minority, like us, who say "Windows too flaky, I switch to linux or bsd or ...", who say "c++ is too messy, I switch to haskell".  But remember we are the minority. What does the majority still stick to? Windows and C++.
12:47:38 <SamB> Linux is too flaky also
12:47:50 <jedbrown> SamB: heh.  I didn't really mean that literally.
12:48:14 <SamB> GHC's STG is already not spineless, not tagless, and not terribly like the G-machine
12:48:26 <monochrom> Yes, even I haven't ditched linux. You see the power of momentum and inertia. Don't underestimate it.
12:48:33 <litb> hm, what type does pi have?
12:48:37 <shachaf> @ty pi
12:48:38 <lambdabot> forall a. (Floating a) => a
12:48:44 <shachaf> @src Floating
12:48:44 <lambdabot> class  (Fractional a) => Floating a  where
12:48:46 <lambdabot>     pi                                                      :: a
12:48:48 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
12:48:50 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
12:48:52 <lambdabot>     (**), logBase                                           :: a -> a -> a
12:48:53 <SamB> in my defence, this machine is only my second Linux-based machine
12:49:03 <monochrom> The two most powerful things in human society that keep getting underestimated: inertia and exponential growth.
12:49:06 <litb> is it a very long Rational?
12:49:10 <SamB> well. If you don't count upgrading the entire system except the hard drive...
12:49:38 <litb> ah, nvm
12:49:44 <litb> i was being tricked by sin
12:49:55 <gwern> could always move to GRIN
12:50:05 <scodil> sin is tricky. that's how the devil gets you
12:50:18 <litb> lolz
12:50:41 <monochrom> Those who haven't learned from history are bound to repeat it. Those who have learned from history are bound to helplessly watch it repeat. :)
12:51:01 <Trinithis> has haskell learned from history?
12:51:09 <monochrom> Yes. :)
12:51:25 <monochrom> We will helplessly watch other people not adopting Haskell or FP etc. :)
12:51:26 <Trinithis> i meant the logician, not the language
12:51:36 <monochrom> Ah, I wouldn't know.
12:51:40 <Trinithis> :D
12:51:48 <Trinithis> the languge is infallable
12:53:16 <BMeph> Trinithis: Since Haskell, the logician is dead, he's done all of the learning from history that we're ever going to be able to use... ;)
12:53:30 <Trinithis> lol
12:56:55 * SamB wonders why people are always trying to steal other people's theses
12:57:07 <radix> SamB: because originality is hard
12:57:28 <BMeph> Originality is hard. Let's go Thesis-shopping! ;p
12:57:37 <radix> :)
12:57:48 <FunctorSalad> =)
12:58:08 <radix> I finished SLPJ's introduction to haskell at OSCON video today. that was really excellent.
12:58:43 <Nafai> radix: Yay to see you here!  #haskell is one of the most useful and friendly IRC channels I've ever joined
12:58:59 <radix> hi nafai. :-)
12:59:15 <litb> i have an idea:
12:59:38 <radix> it's kind of creepy that I'm starting to be more like you weird IRC channel junkies. I'm seeing idnar, samb, and nafai everywhere I go :P
12:59:46 <Nafai> Heh
13:00:02 <SamB> where have you been seeing me?
13:00:02 <Nafai> Looks like I have a few more channels to join
13:00:03 <idnar> radix: heehee
13:00:06 <Eiler> OSCON video?
13:00:22 <Nafai> radix: So did shapr talk you into looking at Haskell?
13:00:47 <litb> i change my Funktion datatype from "data Funktion = Funktion { funktion :: Double -> Double, ableitung :: Maybe Funktion }" to this: " data Funktion a = Funktion { funktion :: a, ableitung :: Maybe (Funktion a) }
13:00:51 <litb> "
13:01:07 <radix> Nafai: probably the reason I joined #haskell recently is that shapr moved to boston and we started going out to dinner.
13:01:12 <litb> then, i could make this Funktion a Monad and use it with ap
13:01:23 <Nafai> Cool
13:01:48 <Eiler> shapr got a haskell job there?
13:01:58 <radix> Eiler: http://research.microsoft.com/~simonpj/papers/haskell-tutorial/index.htm
13:01:58 <lambdabot> Title: A taste of Haskell (tutorial), http://tinyurl.com/ypuvug
13:01:59 <glguy> C#
13:02:01 <radix> Eiler: no, a C# job :-)
13:02:38 <Eiler> oh he upgraded :)
13:02:52 <BMeph> I wonder if shapr can convince them to let him program in F# instead...
13:03:05 <litb> and i want to be able to do this: (take 10 (iterate (fromJust . ableitung) someFunktion)) `ap` pi
13:03:08 <Eiler> what company?
13:03:20 <litb> that would get the first 10 deviations, and apply pi to each of them
13:03:50 * BMeph hopes the company isn't SAIC...
13:04:05 <litb> but now i think the problem is that that would be [Funktion] `ap` pi which doesn't work.
13:04:22 <Cale> Eiler: Well, imperative programming as a general style will essentially be forced out, except for limited situations. The better part of most programs I'm fairly sure will have to be more declarative in nature (not necessarily functional, but imperative won't work.)
13:04:24 <litb> so is there any function that work on [m a] but which in principle is like ap ?
13:04:47 <scodil> anyone know any good union-find algorithms that are haskell friendly? I'm just using "Map a a" now and its not that great.
13:04:59 <Eiler> Cale: because of the parallellizm part?
13:05:05 <conal> litb: do you know about Applicative?
13:05:42 <litb> conal: yes
13:06:08 <conal> litb: maybe Applicative + type composition is what you're looking for.
13:06:19 <litb> the problem is that [Funktion] is the list monad and my Funktion is not r->e but it is r e
13:06:21 <conal> litb: [] `O` m
13:07:06 <litb> oups?
13:07:09 <conal> litb: what do you want [Funktion] `ap` pi to mean?
13:07:59 <litb> it should apply pi to every Funktion in the list
13:08:05 <litb> oh, darn that would not be possible
13:08:15 <litb> since Funktion is not an ordinary function
13:08:30 <conal> litb: and what's pi here?
13:08:40 <glen_quagmire> data List = List  -- this is not recursive type isn't it?
13:08:42 <litb> it is a Double
13:08:57 <Saizan> if you have an apply for function you can just write foo fs v = map (\f -> apply f v) fs
13:09:00 <conal> litb: do you mean you want to apply each function to pi and gather the result?
13:09:03 <conal> into a list?
13:09:05 <litb> glen_quagmire: isn't that just a constructor for List?
13:09:12 <jedbrown> litb: something like ($pi) <$> [Funktion] for suitable defined (<$>)?
13:09:33 <Saizan> glen_quagmire: no, because the second list is a data constructor, not the type
13:09:50 <glen_quagmire> data List a = List a -- this is recursive now
13:10:10 <litb> jedbrown: at the moment i have made a Funktion $$ pi
13:10:35 <araujo> glen_quagmire, you need a base constructor to avoid it to be infinitely recursive
13:10:37 <glen_quagmire> nope it isn't still recursve
13:10:52 <glen_quagmire> data List a = Cons a (List a)  --now recursive
13:11:51 <litb> conal: yeah
13:11:52 <BMeph> litb: you'd need something like [Funktion] `ap` (repeat pi)
13:12:06 <litb> conal: i want to apply each function to pi, and have the results in a list of the same size
13:12:09 <Saizan> glen_quagmire: yeaf
13:12:20 <Saizan> s/f/h/
13:12:35 <litb> BMeph: oh i see. but Funktion is not r->e
13:12:44 <litb> it is data Funktion ... = ...
13:12:57 <conal> litb: i agree with Saizan's suggestion.  do you have something like "apply" that maps a Funktion to a function?
13:13:34 <litb> conal: yes, it is called (someFunktion $$) here
13:13:41 <gwern> hm.... offhand, does anyone know to how include a data file (ie, 'data-files:') conditionally as a part of a flag in a cabal file?
13:13:45 <litb> and returns Double -> Double , conal
13:14:26 <jedbrown> litb: zipWith ($$) [Function] (repeat pi)    or   map ($$ pi) [Funktion]  -- I think this is the operation you want.  Now what properties does it satisfy?
13:14:32 <BMeph> instance Applicative Funktion where...
13:14:40 <Cale> Eiler: yeah.
13:14:46 <litb> jedbrown: oh nice
13:14:57 <litb> haven't thought about zipWith
13:15:09 <Saizan> map ($$) [Funktion] `sequence` pi
13:15:10 <sjanssen> gwern: if flag\n data-files: foo
13:15:12 <adu> I'm reading "Generalizing Monads to Arrows" (arrows.pdf), and I'm confused
13:15:12 <litb> i think making Funktion a monad or a Applicative isnot the right idea is it?
13:15:38 <gwern> sjanssen: I know, I am trying that
13:15:46 <gwern> (it doesn't seem to work?)
13:15:47 <sjanssen> gwern: what goes wrong?
13:15:51 <adu> page 12 says "arr :: (b -> c) -> a b c" and
13:15:52 <adu> page 13 says "arr :: (a -> b) -> a b c"
13:15:53 <Cale> Eiler: Imperative programming just won't scale all that well, and even to the extent it will, it'll require more functional ideas like immutability, or restrictions on side effects.
13:16:00 <adu> which is the correct type?
13:16:12 <conal> adu: the first one is right.
13:16:13 <BMeph> litb: Always think about zipWith. Jeden Tag! ;)
13:16:19 <adu> conal: thanks
13:16:21 <Saizan> litb: it looks like you can't, a monad or an applicative is supposed to be able to contain any possible type
13:16:27 <Cale> adu: The second is a kind error, so it must be the first.
13:16:27 <litb> lolz BMeph
13:16:31 <gwern> sjanssen: Warning: Unknown fields: data-files (line 101) Fields allowed in this section: executable, main-is, buildable, build-tools, cpp-options, cc-options, ld-options, pkgconfig-depends, frameworks, c-sources, extensions, extra-libraries, extra-lib-dirs, includes, install-includes, include-dirs, hs-source-dirs, other-modules, ghc-prof-options, ghc-shared-options, ghc-options, hugs-options, nhc98-options, jhc-options
13:16:59 <litb> Saizan: i could make my funktion a data Funktion a = Funktion { funktion :: a, ableitung :: Maybe (Funktion a) }
13:17:06 <Cale> adu: (note that 'a' must be a type constructor taking two type parameters here)
13:17:18 <Cale> (in either line)
13:17:19 <adu> Cale: right, that makes sense
13:19:16 <conal> adu: these days we might write: class Arrow (~>) where arr :: (a -> b) -> (a ~> b) ...
13:19:21 <adu> So far, I like how Arrows seem to have a more "symmetric"? type system, i.e. require functions (a -> b) instead of (a -> m a)
13:19:47 <gwern> sjanssen: so I'm thinking that it just currently can't be done and I need to make a feature request
13:19:56 <gwern> (at least, done in any non-hacky way)
13:20:39 <conal> adu: arrows (and applicative functors) are also statically analyzable, unlike monads.
13:20:49 <Saizan> litb: won't it be more like data Funktion a b = Funktion { funktion :: a -> b, ableitung :: Maybe (Funktion a b) } ? you have funktion :: Double -> Double not, right?
13:21:21 <jedbrown> Cale: Imperative programming scales okay if you keep a distributed memory model.  But not all algorithms are well-suited to this, and the complexity is still huge.  Complexity aside, it scales terribly for shared memory due to cache coherency with mutable state.  While it is relatively untested, functional programming should scale with shared memory, but that hardware will be rare until functional programming become mainstream.
13:21:44 <adu> conal: I'm also kind of confused between "static" properties and "dynamic" properties, are these referring to "static" and "dynamic" kinds of semantics?
13:21:45 <litb> Saizan: yeah, but then can i still use it with Applicative?
13:22:19 <litb> since "(<*>) :: f (a -> b) -> f a -> f b" i get only one type parameter (a -> b) but my type requires 2 (a and b)
13:23:13 <sjanssen> gwern: so it seems
13:23:31 <conal> adu: would examples help?
13:23:40 <adu> but I think the most explainatory example that made the most sense was: "second f = arr swap >>> first f >>> arr swap" it just makes it so clear :)
13:24:44 <byorgey> litb: you could make your Funktion type a Functor (i.e. instance Functor (Funktion a) where ...) but it wouldn't lead to an Applicative instance that does what you want.
13:24:48 <Saizan> litb: yes, the instance would look like the (->) r one, but i'm not sure if it will keep the right semantic wrt the derivative (ableitung == derivative, right?)
13:25:00 <Cale> jedbrown: Well, designing your whole means of programming around a sequence of instructions occurring and causing effects in some order, and then relying on some automatic analysis to decide that the order really isn't so important and that things really can be run in parallel certainly won't work.
13:25:09 <adu> conal: maybe more examples would help, yes
13:25:22 <byorgey> litb: I've thought about this before, the other day when you were looking for a nice way to 'apply' a value of your Funktion type
13:25:46 <byorgey> litb: I really don't think Functor/Applicative/Monad will gain you very much.
13:25:46 <litb> i think i will not touch Monad and Applicative by now. i'm still too unsure about all this
13:26:35 <conal> adu: for parsing: token look-ahead sets is static, while the parsing of a particular string is dynamic.  for GUIs, the structure and widgets of a GUI is static, while a particular output value is dynamic.
13:26:37 <byorgey> litb: if you want to learn about those classes, I would start by studying existing instances in the standard libraries.
13:26:43 <Cale> Or at the very least, it's an insane way to approach the problem -- you're effectively starting out with the assumption that everything must be run in sequence, and then hoping that maybe it won't.
13:26:46 <Saizan> yeah, it's better to define some ad-hoc combinators, rather than forcibly adapting your type to applicative
13:26:51 <jedbrown> Cale: I don't know of any serious attempt at automatic distributed memory parallelism.  The programmer has to handle that explicitly, but sometimes it is manageable (for scientific computing, for instance).
13:27:26 <conal> adu: that's why functional GUIs lend themselves to Applicative but less well to Monad.
13:27:27 <Cale> I think that any approach to that will have to be quite declarative in nature.
13:28:00 <adu> conal: so you mean the representation of the finite state machine for reading the next token is "static", but the next token itself is "dynamic"?
13:28:05 <conal> adu: and why applicative/arrow-based combinator parsers can be more efficient than monadic parsers
13:28:18 <jedbrown> Cale: That is my biggest frustration with most languages: they overspecify the solution.  The the clever compiler is expected to remove the unnecessary specification so it can optimize it.  The declarative is much better.
13:28:19 <conal> adu: yes -- that puts it well.
13:28:19 <Cale> It might even be that ordinary functional programming won't work out so well for that sort of thing. But the real pressing issue for the moment is making things work on shared memory systems.
13:28:26 <Cale> jedbrown: right.
13:28:47 <glen_quagmire> can I use ($) with constructors?
13:29:09 <Cale> So I think that multiprocessors will kill imperative programming in the next 5 to 10 years.
13:29:20 <jedbrown> Cale: And things like OpenMP are so backwards that you overspecify the algorithm, then add pragmas that partially despecify it, then leave it up to the compiler.
13:29:21 <vincenz> Cale: let's hope so :)
13:29:45 <byorgey> glen_quagmire: of course, constructors are just functions
13:29:49 <Saizan> glen_quagmire: yes, in expressions contructors are functions
13:29:50 <adu> Cale: YA! death to imperative!
13:29:53 <Cale> Especially if Moore's law continues to hold.
13:30:02 <kaol> it can't happen too soon
13:30:05 <vincenz> Cale: it won't
13:30:18 <vincenz> Cale: read my blog entry from April
13:30:30 <litb> nah, let's stay dreaming
13:30:31 <jedbrown> Cale: If functional programming was mainstream, we'd have 16 cores on over desktop today.
13:30:36 <Cale> vincenz: link?
13:30:40 <Vq^> vincenz: wheres your blog?
13:30:44 <jedbrown> *every desktop
13:30:57 <vincenz> http://notvincenz.blogspot.com/2007/04/observations-from-date-2007.html
13:30:58 <lambdabot> Title: lambda.oasis: Observations from DATE 2007, http://tinyurl.com/yw4e7z
13:31:11 <dcoutts_> jedbrown: they have a 16 core desktop at UNSW :-) it was quite loud
13:31:14 <conal> we need a Hari Seldin for functional programming.  someone to hasten the fall of the Imperative Empire.
13:31:42 <gwern> conal: what, and cause a 1000 year interregnum of feuding warlords^Wbusinessmen?
13:31:45 <adu> I like how Oz does it, Oz allows you to define threads for explicit parallel computations, but the threads aren't run until the values they depend on are finished computing, so everything could be a thread and only execute if it doesn't depend on any uncomputed values
13:31:54 <hpaste>  glen_quagmire pasted "try to write this without parenthesis" at http://hpaste.org/5244
13:31:58 <vincenz> conal: You mean a Luke Skywalker?  "Luke use the Lambda"
13:32:02 <Cale> Well, I don't really care too much about hastening it or whatever, since I can already program in functional languages.
13:32:09 <jedbrown> dcoutts_: Heh.  They'd be clocked slower, but more of them.  And lower power than existing desktop chips.
13:32:12 <Cale> (Perhaps that's being a little selfish :)
13:32:13 <dcoutts_> jedbrown: we should get one of those sun sparc boxes that has a single 64-thread cpu (8-core, 8 threads per core)
13:32:19 <litb> guys, some private things: what colours do you like to edit with? i mean, do you have black backround with bright text, or bright background with black text, or something other?
13:32:24 <litb> s/other/else/
13:32:56 <pejo> dcoutts, T2000?
13:32:58 <dcoutts_> jedbrown: that seems to be just what you're talking about, a sparc T1 or T2, low power, highly threaded
13:33:05 <dcoutts_> pejo: right
13:33:11 <Cale> vincenz: Where do you say that Moore's law won't hold there?
13:33:17 <adu> I think instead of starting "Intro. to programming" with QB/VB, they should require everyone learn Haskell.
13:33:22 <jedbrown> dcoutts_: Yeah, those are cool.  Also, IBM could have written a GHC backend for the Cell.
13:33:23 <Cale> vincenz: You're talking about 1T transistor chips :)
13:33:29 <adu> that way, newbies have less to unlearn
13:33:46 <Cale> vincenz: Moore's law is about transistor count, not clock speed :)
13:33:59 <dcoutts_> jedbrown: we should get sun to pay for us to update ghc's sparc ncg :-)
13:34:09 <vincenz> Cale: http://notvincenz.blogspot.com/2007/04/memory-bottlenecks.html
13:34:09 <lambdabot> Title: lambda.oasis: Memory bottlenecks
13:34:10 <dcoutts_> and to give us a T2 box to test it on
13:34:17 <Cale> I'm taking for granted the fact that clock speed won't increase.
13:34:17 <vincenz> Cale: Yeah, I was off by a factor of 10
13:34:21 <vincenz> 100G transistors
13:34:33 <vincenz> Cale: but, the problem is that 1) clock-speed -will- go down if you make smaler transitors
13:34:39 <vincenz> 2) reliability will go down
13:34:41 <litb> nah it is so obvois
13:35:02 <jedbrown> dcoutts_: Yes.  But they like Fortress.
13:35:17 <litb> speed doesn't increase, so get more parallelism. it's so natual
13:35:25 <vincenz> not really
13:35:36 <vincenz> one of the problems is that current architectures don't scale to multicore
13:35:43 <vincenz> I mean yo have 100 chips accessing 1 bus to main memory
13:35:51 <vincenz> shared memory doesn't scale to manycore systems
13:35:56 <litb> then we need 5 busses :)
13:36:04 <phobes> Need separate memories
13:36:20 <jedbrown> vincenz: NUMA scales when there is no mutable state.
13:36:51 <vincenz> jedbrown: paper?
13:37:37 <dcoutts_> jedbrown: yeah, perhaps so, but it'd be cheap for them to donate one and get a student to get it working
13:38:05 <jedbrown> dcoutts_: Yeah, that's small money for them with potentially huge returns.
13:38:21 <phobes> What's NUMA?
13:38:44 <vincenz> non-uniform memory-architecture
13:38:48 <dcoutts_> phobes: Non-Uniform Memory Access
13:38:56 <vincenz> jedbrown: funnily, we don't refer to that terminology so much
13:39:05 <jedbrown> vincenz: Perhaps my statement was too strong, but there is no reason it can't.
13:39:13 <pejo> dcoutts, I looked at the ncg for sparc in 6.4ish. It was beyond painful to compile stuff on a 750 Mhz Ultra3 CPU with a fair amount of memory.
13:39:14 <dcoutts_> phobes: it's a way of arranging cpus and memory that scales well, but causes other headaches
13:39:18 <vincenz> jedbrown: right, but as is, it doesn't scale
13:39:24 <vincenz> jedbrown: as is, most NUMA's are still based on a single bus and some caches
13:39:30 <glen_quagmire> > error "a"
13:39:32 <lambdabot>  Exception: a
13:39:36 <vincenz> or possibly scratchpad's
13:39:38 <glen_quagmire> :t error
13:39:39 <lambdabot> forall a. [Char] -> a
13:40:02 <dcoutts_> pejo: really? why was that? I use ghc-6.8 with the C backend on a 500Mhz sparc
13:40:13 <dcoutts_> pejo: what that specific to the sparc ncg or just generally?
13:40:40 <glen_quagmire> > [1 .. ] + (error "a")
13:40:41 <lambdabot>   add an instance declaration for (Num [t])
13:40:41 <lambdabot>     In the expression: ([1 .. ]) ...
13:40:54 <vincenz> jedbrown: read pm :)
13:41:16 <dcoutts_> vincenz: sgi and cray sell numa machines with a rather sophisticated global memory routing system
13:41:34 <pejo> dcoutts, oh, general observation. GHC is a beast. Don't you take a break for coffee when you compile stuff on that 500 Mhz machine?
13:41:35 <jedbrown> vincenz: The SGI is not very successful, I think that is mostly due to the imperative code.  The recent GpH-GRID work shows reasonable scaling to 40 or 60 cpus, emulating shared memory on a cluster.
13:41:45 <dcoutts_> pejo: yeah :-)
13:41:50 <vincenz> Interestng
13:42:03 <vincenz> My knowledge comes from a different domaini, embedded, where numa's been very active too
13:42:19 <pejo> dcoutts, and coercing that many breaks on you doesn't make you feel stressed out? :-)
13:42:35 <dcoutts_> pejo: I get good at task switching :-)
13:42:52 <nominolo> i know of an SGI shared memory system with 1024 cpus
13:43:27 <dcoutts_> pejo: it would be a lot quicker with the sparc ncg, it'd make ghc quicker since the unregisterised C backend is slow, and it'd mean ghc was doing less work since it'd not be calling gcc
13:43:42 <pejo> dcoutts, I think the NCG compiles on sparc if you feel you have some spare cycles over. Lots of tests still failing though.
13:43:47 <dcoutts_> pejo: I expect getting the ncg working again would make ghc compiles about 4x faster
13:43:59 <pejo> dcoutts, I kind of gave up on it since I'm not using sparc as my primary platform any longer.
13:44:20 <dcoutts_> pejo: I thought it was bit rotted since about 6.0 or so
13:45:01 <pejo> dcoutts, no, it worked in 6.2, but 6.4 broke it to the degree it didn't even compile, and hence disabled it in the configure script.
13:45:28 <nominolo> but generating sparc code should be relatively comfortable, shouldn't it?
13:45:40 <dcoutts_> pejo: ah, yes and 6.4 was the last version that worked with the registerised backend, perhaps I should go back to using 6.2 :-)
13:45:43 <pejo> dcoutts, I made it compile and fixed some of the tests, but got sidetracked and sent the patch to JaffaCake.
13:45:55 <dcoutts_> nominolo: yes, if anyone has the time and knowledge to do it
13:46:03 <olsner> so, since 6.4 no-one's been working on sparc ncq at all?
13:46:18 <olsner> why do I confuse G and Q?
13:46:25 <nominolo> dcoutts_: i'd say i have the latter
13:46:27 <dcoutts_> olsner: not so far as I know, though the new register allocator has some support for it
13:46:31 <dcoutts_> pejo: oh, interesting
13:46:35 <nominolo> dcoutts_: but not the former ;)
13:46:46 <dcoutts_> nominolo: heh heh
13:46:59 <piojo> hi. could anybody give me a hint as to what I'm doing wrong with type classes? A short paste is at http://hpaste.org/5246 . thanks.
13:47:08 <dcoutts_> nominolo: perhaps we can get you a SoC project to do it and get Sun to donate us a T1 box :-)
13:47:26 <pejo> nominolo, it's mainly bitrotted, it worked in 6.2 as mentioned. It doesn't resemble the PPC backend though (which is new) and alpha is equally bitrotted. But the asm is a lot nicer than ia32.
13:47:32 <nominolo> does anyone know someone at sun?
13:47:48 <mauke> piojo: Under has the type Preposition, not (Word w) => w
13:48:04 <dcoutts_> nominolo: my department has some contacts, Sun often send us stuff trying to get students to do projects with them
13:48:06 <piojo> but isn't Preposition a Word?
13:48:24 <mauke> yes ...?
13:48:29 <nominolo> dcoutts_: hm, that would be nice
13:48:30 <glguy> piojo: you've started defining a new type-class method with getWordLength
13:48:35 <mauke> that doesn't mean every Word is a Preposition
13:48:55 <piojo> mauke: the instance declaration doesn't do that?
13:48:55 <glguy> (new overloaded function)
13:49:06 <mauke> piojo: huh?
13:49:13 <piojo> sorry, s/do/imply
13:49:16 <monochrom> Why do you need getWordLength? You already have wordlength.
13:49:28 <glguy> piojo: you'll need to define getWordLength the same way as you did wordlength
13:49:34 <glguy> piojo: as part of a type-class
13:49:38 <mauke> glguy: no
13:49:45 <mauke> getWordLength w = wordlength w
13:49:59 <glguy> mauke: at this point, sure
13:50:13 <glguy> mauke: but it's not obvious that that's what he's trying to understand
13:50:25 <pejo> dcoutts, so if anyone is up to hacking, they just need to tweak configure to enable ncg and fix the failing tests. ;)
13:50:45 <dcoutts_> pejo: so it actually compiles and bootstraps but a few tests fail?
13:50:54 <olsner> is there a dedicated lexical analysis combinator library around, or are alex and parsec(/any parser combinator lib) the alternatives I should look at?
13:51:49 <glguy> glen_quagmire: using a where or let clause
13:51:57 <piojo> glguy and mauke: thanks... i can't really test those suggestions (the real function is a less trivial than these examples), but i will try to parse what you suggested into changes to my code...
13:52:01 <pejo> dcoutts, at the time (2 years ago?) it compiled and a quite a few tests were failing. I don't recall how I was running the testsuite, perhaps with ghc-inplace?
13:52:16 <dcoutts_> pejo: what version was that?
13:52:28 <dcoutts_> pejo: and did the patches get applied at the time?
13:52:29 <glguy> piojo: the key is that if you want to overload a function, you need to use a type-class
13:53:10 <piojo> glguy: i am though, right?
13:53:36 <piojo> that's just "data X = Y | Z..."
13:53:36 <glguy> piojo: you used a type-class for wordlength
13:53:36 <glguy> but then you tried to overload getWordLength
13:53:36 <glguy> without one
13:53:36 <piojo> oh
13:53:50 <glguy> if you want getWordLength to have a different implementation based on the type, you need typeclasses
13:53:52 <glguy> that's overloading
13:53:56 <piojo> oh. i see
13:54:02 <glguy> (beyond just using overloaded functions)
13:54:09 <piojo> so i can't pattern match on data type?
13:54:13 <glguy> you can
13:54:21 <glguy> but you can't pattern match on multiple data types
13:54:21 <mauke> sure you can, but only if it's a single type
13:54:23 <glguy> without a typeclass
13:54:26 <piojo> okay
13:54:52 <piojo> thanks. i think i'll be able to make it work...
13:55:22 <pejo> dcoutts, hm. It must have been post 6.4, otherwise I wouldn't have realised it was broken. 6.4.1 is the most recent ghc installed here, so I'm guessing the patch went into HEAD at the time (6.6)
13:55:55 <dcoutts_> pejo: ok, thanks. I might give it a spin and see how far it gets.
13:56:16 <dcoutts_> I'm up to fixing compile errors I expect, and I know a bit of sparc assembly...
13:56:17 <pejo> dcoutts, isn't there a fairly large rewrite of the NCG in the pipe already though?
13:56:26 <glen_quagmire> glguy: ?? for my hpaste?
13:56:35 <glguy> glen_quagmire: yeah
13:56:40 <dcoutts_> pejo: parts of it, yes. though mostly above the machine specific layer I think.
13:56:45 <glen_quagmire> glguy: thanks
13:58:07 <glguy> glen_quagmire: something like this could work
13:58:15 <glguy> if you would allow one set of parens
13:58:32 <glguy> :t ($ ?x) ?f ?y
13:58:34 <lambdabot> forall a t t1. (?x::a, ?f::a -> t -> t1, ?y::t) => t1
13:58:55 <glen_quagmire> :t (?)
13:58:55 <lambdabot> Not in scope: `?'
13:58:57 <glguy> :t ($ Just $ ?x) ?f $ Just $ ?y
13:58:57 <lambdabot> forall a b a1. (?x::a, ?f::Maybe a -> Maybe a1 -> b, ?y::a1) => b
13:59:04 <pejo> dcoutts, ah. The ncg didn't compile at all before my patch, so it's easy to figure out if it was applied.
13:59:17 <dcoutts_> pejo: right
13:59:25 <glen_quagmire> glguy: what is ?x
13:59:39 <glen_quagmire> do I look at pattern matching?
13:59:42 <glguy> an implicit parameter to make it easier to do the type checking
13:59:46 <glguy> in lambdabot
13:59:52 <glen_quagmire> oh i see
13:59:56 <glguy> I'll do it on the page
13:59:58 <glguy> paste
13:59:59 <olsner> I would love to have had a sun machine to do NCG hacking on ;-)
14:00:26 <pejo> dcoutts, just holler when you're closer to start working on it if you want me to dig up the mails; I'm kind of swamped right now.
14:00:41 <dcoutts_> pejo: ok
14:00:54 <glguy> simpleTree = ($ Just $ Node "left" Nothing Nothing) $ Node "root" $ Just $ Node "right" Nothing Nothing
14:01:14 <pejo> olsner, would remote access be of interest to you?
14:01:29 <glen_quagmire> glguy: ok using where or let sounds like the most readible
14:01:40 <glguy> glen_quagmire: using parenthesis does too
14:01:46 <olsner> unfortunately, I also lack knowledge and time
14:02:07 <pejo> olsner, heh. Bummer.
14:02:11 <glguy> simpleTree = Node "root"  (Just $ Node "left" Nothing Nothing) (Just $ Node "right" Nothing Nothing)
14:02:26 <killfire> question about development environment (specifically, minimum disk space requirements) - is this the right place to ask?
14:02:32 <glen_quagmire> glguy: nice!
14:02:51 <Saizan> simpleTree = ($ Just $ Node "left" Nothing Nothing) $ Node "root" $ Just $ Node "right" Nothing Nothing <-- here the branches are swapped, right?
14:03:48 <glguy> yeah
14:03:51 <glguy> they are
14:03:54 <Saizan> killfire: if it's about haskell just ask :)
14:05:02 <glen_quagmire> for  haskell, you need an OS with readline. otherwise ghci won't do tab completion
14:06:10 <killfire> Saizan: okay - basically, I am trying to squeeze ghc into 400mb total. the problem is I dont even have gcc. is it possible to fit this?
14:06:35 <glguy> might help to not instlal extralibs
14:06:49 <Saizan> and profiling libraries
14:06:51 <pejo> killfire, what architecture?
14:06:57 <glen_quagmire> isn't binary distribution of ghc already under 400mb decompresed?
14:06:58 <killfire> hmm... I'm looking at http://www.haskell.org/ghc/download_ghc_682.html#x86_64linux
14:06:59 <lambdabot> Title: GHC: Download version 6.8.2
14:07:25 <glen_quagmire> when i compiled ghc on x86_64, it's like 2GB
14:07:29 <killfire> glen_quagmire: no, it is over (for 64)
14:07:38 <Saizan> but i think ghc needs gcc for things like CPP
14:07:48 <killfire> Saizan: that is the problem
14:07:52 <glen_quagmire> i used to carry windows version of ghc on usb thumb
14:08:10 <pejo> killfire, how can you have a 64-bit linux system without a compiler, and no space?
14:08:21 <killfire> pejo: remote server on the cheap
14:08:32 <olsner> my i386 ghc 6.8.2 takes 325 megs in total
14:08:33 <Saizan> killfire: but there are flags to override that i think
14:08:44 <killfire> and my local is not 64bit, so it would be easier if I could do all development there
14:09:09 <glguy> installed ghc on 64-bit linux is ~325meg
14:09:19 <glguy> with extralibs
14:09:24 <olsner> if you select extra libraries carefully, you should be able to squeeze it down a bit from there
14:09:31 <olsner> OpenGL is about 50 megs for me
14:09:41 <killfire> olsner: hmm... but fitting gcc probably wont work...
14:09:56 <killfire> I guess cross compiling and sending later might be a better option..
14:10:05 <Saizan> doesn't 100mb slackware comes with gcc?
14:10:18 <Saizan> ghc can't crosscompile..
14:10:26 <glen_quagmire> i bet windows version with gcc is uder 400mb
14:10:38 <killfire> Saizan: that is unfortunate.
14:10:55 <glen_quagmire> to compile ghc, you need ghc
14:11:09 <glen_quagmire> so you have 400mb without ghc and trying to compile ghc there
14:11:13 <killfire> glen_quagmire: doesnt intermediate c kind of eliminate that problem?
14:11:37 <glen_quagmire> i'm not sure. i just built standard way once
14:11:43 <killfire> glen_quagmire: yes, I have 400mb, and want to get a working ghc there.
14:12:49 <killfire> I thought the binary tarball would just be complete, able to be extracted - is that not the case?
14:12:58 <Saizan> yes it is
14:13:01 <killfire> (greping through tar -t makes me thinkg not, but...)
14:13:27 <killfire> Saizan: okay, so the INSTALL file says do a ./configure && make install
14:13:29 <jedbrown> killfire: Perhaps take the binary install, unpack it, strip and gzexe, then repack.
14:13:36 <killfire> Saizan: but configure dies because I dont have gcc...
14:14:16 * byorgey hacks happily on Cabal
14:14:20 <Saizan> heh, i don't know a way out of having gcc
14:14:46 <killfire> jedbrown: well, I just excluded things when extracting, so I have extracted everything I need (no opengl, etc), but the 'binary' distribution doesnt seem to have the actual binaries...
14:15:27 <Saizan> doesn't it have a ghc-6.8.2 somewhere?
14:15:38 <Saizan> it should.
14:15:57 <killfire> oo, I was looking for the symlink (just ghc)... hold on
14:16:28 <Saizan> as for gcc you may try on #ghc if there's an hack to avoid it
14:16:35 <glen_quagmire> but with ghc binary,don't you still need gcc?
14:16:53 <Saizan> +to ask
14:17:01 <killfire> glen_quagmire: well, the documentation seems ambiguous - it says on some architecutres you can go straight to native code
14:18:04 <Saizan> yes, it's the default now
14:18:55 <killfire> Saizan: straight to native, or by way of C?
14:19:00 <pejo> killfire, you can hack the configure script to not fail on the test for gcc, but it's not clear that you'll have a working ghc after that (it uses cpp for example).
14:21:30 <Yosusin> http://bitxarraco.myminicity.es/
14:21:30 <Yosusin> http://bitxarraco.myminicity.es/
14:21:31 <Yosusin> http://bitxarraco.myminicity.es/
14:21:32 <Yosusin> http://bitxarraco.myminicity.es/
14:21:32 <Yosusin> http://bitxarraco.myminicity.es/
14:21:33 <Yosusin> http://bitxarraco.myminicity.es/
14:21:34 <Yosusin> http://bitxarraco.myminicity.es/
14:21:36 <Yosusin> http://bitxarraco.myminicity.es/
14:21:48 <byorgey> argh
14:21:56 <glen_quagmire> nice
14:22:09 <Saizan> killfire: straight to native, it goes via c-- internally
14:23:09 <adu> adu
14:23:13 <adu> oops
14:23:15 <adu> sorry
14:26:39 <killfire> this seems dumb - what is the -B<dir> option (cant find it on google, in the man page, or on the user docs page for ghc) - ghc wont do anything but spit out -V without it...
14:28:26 --- mode: ChanServ set +o Cale
14:28:46 <phobes> BABABOUI BABABOUI BABABOUI !!!
14:28:47 --- mode: Cale set +b *!n=ircap*@*
14:28:59 --- mode: Cale set -o Cale
14:29:14 <killfire> oh hmm, probably because it cant find libraries - nevermind.
14:29:36 <Cale> (hope that mask doesn't match anyone's current address)
14:30:01 <jethr0> is there a canonical wrapper for a c library anywhere. i'm thinking about writing a wrapper for imagemagick in my very limited spare time. any pointers? (for projecting c/c++ onto haskell, exception handling, ...)
14:31:21 <pejo> @google hsc2hs
14:31:24 <Cale> jethr0: You mean, the FFI?
14:31:27 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
14:31:27 <lambdabot> Title: 11.3. Writing Haskell interfaces to C code: hsc2hs
14:31:33 <mauke> @where ffi
14:31:34 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
14:32:05 <jethr0> Cale: i'm aware of the ffi. my question was more geared to an easily readable already existing wrapper that was deemed OK in style and error handling, ...
14:33:07 <jedbrown> jethr0: For a simple C example, pcre-light is good.
14:33:46 <jedbrown> jethr0: Also, read the wiki.  gtk2hs is a very complex example that uses both hsc2hs and c2hs in different parts.
14:34:03 <jethr0> and for c++?
14:34:04 <mauke> here's a very bad example: http://mauke.ath.cx/stuff/haskell/hell.hs
14:34:22 <Cale> jethr0: Tim Chevalier (catamorphism@gmail.com) said he was working on an imagemagick binding a while back.
14:34:30 <monochrom> hell.hs ?! :)
14:34:34 <jethr0> hehe
14:34:40 <mauke> monochrom: compiles to hell.o
14:35:01 <monochrom> Does "mkFun" allure to "make fun"? :)
14:36:54 <monochrom> Is mkFun a routine written in C?
14:37:10 <phobes> Bah.  Why would anyone make a file browser interface that lists files in column major order, and then have multi-select select rectangles
14:38:25 <mauke> monochrom: no, that's the whole definition of mkFun
14:40:03 <Eiler> foldl is usually faster than foldr?
14:40:09 <mauke> Eiler: no
14:40:18 <jethr0> phobes: on that matter, why would anyone (microsoft) make a file browser interface whose alphanumeric sorting algorithm is completely unpredictable?
14:40:42 <Eiler> so when is foldl faster than foldr?
14:41:15 <byorgey> Eiler: they serve different purposes, so can't really be compared for speed.  that said, you pretty much never want to use foldl -- use foldl' (from Data.List) or foldr.
14:42:01 <byorgey> Eiler: see http://haskell.org/haskellwiki/Stack_overflow
14:42:01 <Eiler> The yaht says foldl can be faster
14:43:25 <phobes> yaht:  says it's faster than foldl' or than foldr?
14:43:32 <phobes> heh Eiler:*
14:43:47 <mrd> > take 10 $ foldr (++) [] $ map return [1..]
14:43:47 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
14:43:49 <mrd> > take 10 $ foldl (++) [] $ map return [1..]
14:43:51 <lambdabot> Terminated
14:43:58 <mrd> foldr looks like its infinitely faster!
14:44:16 <sizur> > take 10 $ foldl' (++) [] $ map return [1..]
14:44:19 <lambdabot> Terminated
14:44:34 <Saizan> Eiler: well foldl is tail recursive, so it uses less stack but can't deal with infinite lists, and in general needs to traverse all the list before you can look at the result
14:44:35 <Eiler> mrd: no cause foldl dont work on infinite lists
14:44:54 <sizur> > [..1] too bad we cannot define enum like that ;)
14:44:55 <lambdabot> Unbalanced parentheses
14:45:11 <ddarius> Eiler: As byorgey said and as it suggests on the Stack Overflow page, foldl' and foldr are used in different situations.  You almost always want one or the other, so to compare them, one of them has to be being used in a case where it is inappropriate.
14:45:21 <jethr0> sizur: we can (reverse [1..]), it just takes long to evaluate ;)
14:45:23 <mrd> it's tail recursive but it can build up a large unevaluated thunk
14:45:42 <sizur> jethr0, no, that would start from positive number
14:46:03 <sizur> jethr0, some time in the infinity. and i want to start from negative number sometime in the infinity :P
14:46:44 <jethr0> k, (map (*(-1)) $ reverse [1..]) ++ [0,1]
14:46:59 <mauke> jethr0: negate
14:47:03 <jethr0> right
14:47:14 <mauke> reverse [1, 0 ..]
14:47:22 <mrd> > take 1 . reverse $ [1..] ++ [1]
14:47:24 <lambdabot> Terminated
14:50:00 <sizur> it just hit me, why does [1..] has the same type as [1]? when it's a completely different type
14:50:30 <byorgey> :t [1..]
14:50:31 <lambdabot> forall t. (Num t, Enum t) => [t]
14:50:32 <shachaf> sizur: Why?
14:50:33 <monochrom> mauke: I see now. I haven't learned "dynamic", but now I do, mkFun needs only be declared and the computer will write it. Deep magic. :)
14:50:34 <byorgey> :t [1]
14:50:34 <lambdabot> forall t. (Num t) => [t]
14:50:38 <jethr0> why would it be a different type?
14:50:42 <Nafai> sizur: Why is that a completely different type?  I didn't know arrays were typed based on the number of items in it
14:50:47 <shachaf> sizur: Other than the Enum, that is.
14:50:50 <sizur> because it's infinite
14:50:56 <shachaf> sizur: So?
14:50:58 <shachaf> @src []
14:50:58 <lambdabot> data [] a = [] | a : [a]
14:51:06 <jethr0> Nafai: lists, not arrays
14:51:19 <sizur> you cannot do the same operations on infinite lists as on finite, that's the whole point of typesafety
14:51:37 <Nafai> jethr0: Yeah, sorry.  I knew I was using the wrong term :)
14:51:41 <jethr0> sizur: any list is potentially infinite. you have to evaluate it to the end to find out, and that's by far not always done in a non-strict language
14:51:56 <jethr0> > take 1 [1]
14:51:56 <lambdabot>  [1]
14:52:03 <jethr0> > take 1 [1..]
14:52:04 <sizur> but the point of types is to know what operations you can do on them
14:52:06 <lambdabot>  [1]
14:52:25 <sizur> infinite sets is a different category from finite ones
14:52:57 <monochrom> The point of types is to make some distinctions and not others. OK I'm trolling.
14:52:59 <jethr0> partially true. maybe dependant types could help with this
14:53:27 <shachaf> sizur: Does (map (*2)) work on finite or infinite lists?
14:53:40 <sizur> shachaf, both, but reverse does not
14:54:05 <shachaf> sizur: You should also distinguish empty and non-empty lists.
14:54:05 <monochrom> You can make a type system distinguish finite lists from infinite lists. Some haskellers want it for haskell. But as of now it doesn't make the distinction yet.
14:54:06 <phobes> sizur: it works, it just never finishes
14:54:13 <oerjan> sizur: haskell allows general recursion without restriction on types.  that makes it impossible to truly define a type of finite but unknown length lists
14:54:15 <shachaf> sizur: And, for that matter, lists with 1 and 2 elements.
14:54:25 <sizur> phobes, i say it does not work by definition.
14:54:28 <shachaf> (tail . tail) -- what lists will that work on?
14:54:33 <oerjan> it would need to distinguish data and codata types to get around that
14:54:35 <sizur> shachaf, you are right about empty lists
14:54:38 <phobes> sizur:  Does head work on the empty list?
14:55:17 <phobes> sizur:  or head.head on length 1 ... you need depedent types to stop all bad behavior
14:55:28 <monochrom> Some haskellers now ask for a moderate position: introduce keyword "codata" for those who want to document that they intend infinite data structures. At first "codata" and "data" are interchangeable. They hope in the far future the type system distinguishes them too.
14:55:29 <sizur> my point is that distinction between a finite list and infinite list is even stronger than Int and IO a
14:55:48 <sclv> you can define a very restricted type of finite list in haskell though.
14:55:57 <phobes> sizur: I basically agree with you btw :)
14:56:14 <monochrom> Anyway this whole conversation has been repeated on haskell-cafe many times many years ago.
14:56:20 <sclv> create a type whose only constructor is enumFromTo for well bounded types.
14:56:31 <sclv> and allow destructive operations but no appends.
14:56:56 <phobes> monochrom:  heh, step 1) introduce codata, step 2) ridicule those who use data for infinite lists :)
14:57:05 <sclv> this effectively limits you to operations on this type that use structural recursion.
14:57:33 <jethr0> > (tail . tail) [[1]]
14:57:36 <lambdabot>  Exception: Prelude.tail: empty list
14:58:31 <shachaf> It is a nice thing, in some cases, that when given a list you don't have to care how long it is.
14:58:52 <monochrom> There is a tension because some operations like "map" "take 10" work fine on both data and codata. If you divorce them, who gets the child custody rights? And then some proponents mumble "type class" etc. I don't know how to do it nicely.
15:00:33 <oerjan> well map already has a type class :)
15:01:11 <phobes> monochrom:  I say most of the problem is that haskell typeclasses are too heavyweight
15:01:45 <monochrom> As long as you want type checking to be decidable, or to stay within a fixed complexity class, there will be distinctions you as a programmer make but the type system doesn't make.
15:02:03 <monochrom> Some people accept this as "c'est la vie".
15:02:16 <monochrom> Some people take refuge under "dynamic typing".
15:02:29 <mauke> just use unsafeCoerce
15:02:30 <phobes> monochrom:  As long as you want type checking to be easy *and you don't want to specify gobs of proof* ...
15:02:56 <monochrom> Yes. I forgot that.
15:02:57 <phobes> type checking is easy as long as you make the programmer supply all of the proofs
15:03:48 <sizur> well, then you dont need static typing at all if you force programmer to write proofs
15:04:01 <Philippa> ...what do you think proof-checking is?
15:04:19 <monochrom> Proof checking is type checking in Heaven.
15:04:47 <monochrom> I believe in Heaven and I believe in programmer obligation to prove things. :)
15:05:12 <sizur> i like that. so lisp then? lol
15:05:18 <oerjan> what, Heaven without proof inference?  you must be joking.
15:05:36 <monochrom> hahahahaha
15:08:06 <monochrom> Hmm, how is haskell typeclass too heavyweight?
15:11:56 <sclv> @remember monochrom Proof checking is type checking in Heaven.
15:11:57 <lambdabot> I will remember.
15:12:06 <monochrom> heh
15:12:08 <sclv> @quote type.checking
15:12:08 <lambdabot> SyntaxNinja says: * SyntaxNinja does the type-checking dance ;)
15:12:14 <sclv> @quote type.checking
15:12:14 <lambdabot> SyntaxNinja says: * SyntaxNinja does the type-checking dance ;)
15:12:17 <sclv> @quote type.checking
15:12:18 <lambdabot> monochrom says: Proof checking is type checking in Heaven.
15:12:24 <sclv> whee.
15:13:21 <SyntaxNinja> hmm
15:13:41 <Axioplase> Is it possible, with type informations, to have a function that only accepts lists of even length ?
15:13:41 <Eiler> @paste
15:13:41 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:13:41 <sizur> @vixen echo (memory consumption)
15:13:42 <lambdabot> am I the only person you're talking to?
15:14:12 <ddarius> Axioplase: type EvenList a = [(a,a)]
15:14:24 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5247
15:14:49 <Axioplase> ddarius: well, I wasn't thinking about that.. Rather phantom types, or something like that...
15:14:51 <Eiler> http://hpaste.org/5247 is there any performance difference in those three functions?
15:15:07 <sizur> ddarius, that's a nice one. i like it
15:15:28 <ddarius> Axioplase: You could do it with phantom types though you'd have a tiny "trusted core"
15:15:50 <Axioplase> ddarius: can you be more precise please?
15:16:23 <Axioplase> overloading the cons/car/cdr operators ?
15:17:02 <bos> Eiler: yes
15:17:28 <bos> Eiler: a haskell compiler will not often perform common subexpression elimination for you, so it helps to do so by hand.
15:17:53 <glguy> Eiler: you can check this by looking at the output from -ddump-simpl (if you are up for reading core)
15:18:44 <ddarius> newtype List o a = List [a]; data Even; data Odd; nil :: List Even a; nil = List []; econs :: a -> List Even a -> List Odd a; econs x (List xs) = List (x:xs); ocons :: a -> List Odd a -> List Even a; ocons x (List xs) = List (x:xs)
15:19:29 <Eiler> okay, so is the 3rd version the fastest?
15:19:37 <bos> Eiler: yes
15:19:39 <Axioplase> Thanks. let me read this.
15:19:40 <ddarius> Except that it strongly suggests adding subtyping to the language, I think refinement types would be an addition to Haskell that is in the spirit of other extensions.
15:20:05 <bos> Axioplase: you can also do this using GADTs
15:20:14 <phobes> I like refinement typing as a way to get subtyping
15:20:15 <Eiler> ok
15:20:47 <sizur> can refinement typing be complete while static?
15:20:54 <Axioplase> ddarius: That's reoughly what I had, though I wondered how to have one single cons, instead of two.
15:21:18 <ddarius> Axioplase: You could stick them in a type class if you wanted to.
15:21:38 <Axioplase> bos: If you got sample code too ^^
15:22:10 <Axioplase> ddarius: It's been months since I last coded in Haskell. I must have some type class code I wrote at that time. Thanks, I'll look at that.
15:22:15 <ddarius> Using type functions, you could probably use the same cons too.
15:22:21 <bos> Axioplase: see the haskell wiki
15:22:42 <bos> http://en.wikibooks.org/wiki/Haskell/GADT
15:22:55 <ddarius> You could easily use two normal mutually recursive types instead of GADTs, or phantom types, or refinement types.
15:23:00 <bos> it's not a well written page, but it gets the idea across.
15:23:16 <ddarius> (It would be rather related to refinement types though.)
15:23:25 <Axioplase> Alright. Thanks
15:24:06 <ddarius> data EList a = Nil | ECons a (OList a); data OList a = OCons a (EList a)
15:25:29 <sizur> i like phantom solution until we have refinements
15:25:50 <sizur> with a class
15:25:59 <MateT> Hello - Haskell noob here. I have a random question that I wonder if you smart people can assist with: Suppose I want to create a trivial dll that exports two functions, say "getAlpha" and "setAlpha". The idea is, if a user of the dll (possibly writing in C or VB6) calls setAlpha 10 and then getAlpha, the value 10 should be returned. What's the easiest way of doing that in Haskell (ignoring the mechanics of compiling
15:25:59 <MateT>  the dll etc - I've been able to sort that stuff out).
15:27:21 <dcoutts_> MateT: take a look at the FFI, it allows you to export haskell functions as if they were C functions
15:28:36 <lispy> MateT: so the deal is you want the user to be able to set/get state in the dll?
15:28:47 <lispy> MateT: how would you do it in C?
15:29:37 <MateT> Lispy - that's right.  Well in C of course I could have a global variable called alpha. Really I just need to 'the equivalent thing' in Haskell. I've been playing around with IORefs but haven't yet found the answer.
15:29:49 <sizur> do you want to use this as means of interprocess communication?
15:30:31 <ramza3> is there a glob function in haskell;  I was looking for System.Path ...but couldnt find the library or is it used that often
15:31:58 <sizur> System.Directory.getDirectoryContents?
15:32:02 <MateT> dcoutts - while I'm sure I'll need to read up on the FFI in due course, I'm not sure the interface is the issue here. As lispy said, it's about having state in the dll.
15:33:24 <lispy> MateT: well, if you don't need IPC, then yeah, a top level IORef is probably what you want
15:33:45 <lispy> MateT: There is a good chance you'll need unsafePerformIO
15:34:11 <oerjan> and NOINLINE, sure?
15:34:17 <lispy> MateT: iirc, the wiki had or has a page about simulating global state variables in Haskell
15:34:50 <oerjan> @go global variable site:haskell.org/haskellwiki
15:34:55 <lambdabot> http://www.haskell.org/haskellwiki/Top_level_mutable_state
15:34:55 <lambdabot> Title: Top level mutable state - HaskellWiki
15:36:07 <dcoutts_> MateT: right, Haskell functions are pure, you can pass some context via a StablePtr
15:36:22 <lispy> MateT: I won't pretend to understand the problem your trying to solve, or to know how to write it best, but maybe, just maybe, you should be sending in the state parameters as a struct instead of setting them?
15:36:31 <MateT> sizur - it's not about interprocess communication. Ah thanks oerjan - looks like exactly what I need.
15:36:40 <olsner> what was that haskell tool which included a mostly-complete C parser?
15:37:49 <MateT> Lispy. Hehe - yes that may very well be the best way. I'm thinking it depends whether global state is more or less of a hassle than understanding how to marshal complicated data.
15:38:21 <lispy> MateT: I can't speak for VB6, but I know in VB.NET and C# that data marshalling is about as sane/easy as it gets.
15:39:16 <lispy> MateT: another option, (sounds like you're on windows) is to use hdirect/com.
15:39:35 <lispy> But, if you don't need COM, I would stay away from it.
15:41:25 <elias`> I need to use an ioctl command in a small daemon to periodically wake up a device unless user has been idle for long enough. Haskell would be convenient for this especially if I later extend it to work with other Haskell-based things I'm doing. Is there some nice way to get just ioctl callable from haskell?
15:41:37 <MateT> Yeah, I think that's good advice. Thanks for the help lispy and the rest of you.
15:42:02 <ddarius> c3hs probably
15:42:04 <ddarius> er c2hs
15:42:22 <MateT> I looked into hdirect btw, but I don't think it works with the latest GHC.
15:43:08 <ddarius> elias`: Just make a binding to it via the FFI if there doesn't already exist one.  It should be trivial or close to it.
15:43:53 <kib> Hi, is this code easily transposable to Haskell ? http://mitpress.mit.edu/sicp/full-text/sicp/book/node39.html
15:43:53 <lambdabot> Title: Example: Symbolic Differentiation
15:44:20 <ddarius> Sure.
15:44:41 <ddarius> It will actually be a lot nicer looking in Haskell.
15:45:57 <kib> I've started something, but it looks horrible I think.
15:46:55 <kib> http://dpaste.com/32678/
15:47:26 <sjanssen> kib: that looks great
15:47:39 <kib> that's not at all...
15:48:08 <sjanssen> looks slightly better than the scheme, I think
15:48:13 <sjanssen> kib: what don't you like about it?
15:48:43 <kib> the results it gives me, like "7*x*5*y"
15:48:44 <ddarius> How does it look worse than the Scheme code?  Note that you have to implement all those 'variable?' and 'make-sum' functions in the Scheme code, but you get them for free with the data declaration.
15:48:48 <conal> kib: if you give a Num instance for Expr, you can make the RHSs very pretty, and you can make (*) and (+) be smart about *1, +0, *0
15:49:10 <ddarius> kib: You can either output the results using s-expr notation, or you need to handle precedence.
15:49:52 <ddarius> (or you can fully parenthesize the infix expressions, but that looks ugly)
15:50:12 <kuribas> ddarius: you can have data declaration in scheme.
15:50:23 <kib> good ideas, but how can I have the left and right parts of a sum/product ?
15:50:32 <conal> kib: if you use a Num instance, you'll get to use existing precedence, e.g., derive (Mul a b) x = a * derive b x + b * derive a x
15:50:35 <ddarius> kuribas: Not in standard R5RS Scheme though you could easily write one.
15:51:04 <ddarius> I need to see what all R6RS has added.
15:51:15 <kib> Thanks conal
15:51:21 <conal> :)
15:51:29 <kuribas> ddarius: Nobody writes in standard R5RS scheme :)  But there is srfi, which is pretty standard.
15:51:37 <oerjan> kib: you also have the option of making infix constructors, such as :+: and :*:
15:51:41 <ddarius> conal: That won't help for output.
15:51:48 <oerjan> they can even be defined with precedence
15:52:03 <kib> ddarius : I'm not at all a Scheme or Lisp programmer, I'm just stating with Haskell and found some good subject to work with : symbolic calculation (but maybe too hard for a start).
15:52:49 <ddarius> kib: It depends on how far you want to go.  You aren't going to reimplement a CAS anytime soon (in any language), but this code that you've written is fine.
15:53:39 <kib> In fact I just want a  very simple CAS
15:54:26 <kib> sum, product, differentiate, integrate (? I don't know the term in English ) of expressions.
15:54:43 <sjanssen> kib: integration
15:55:24 <sjanssen> kib: and integrate, depending on your sentence :)
15:55:32 <kib> oh yes, I know it for sure : thanks for remembering me :)
15:55:44 <ddarius> sjanssen: integrate is what he wanted there.
15:55:57 <ddarius> Er, nevermind
15:56:35 <ddarius> (I'd say dropping 'of' is probably the best way to "fix" that sentence.)
15:57:25 <kib> oerjan : How can I make those infix constructors ? It will be very usefull.
15:58:52 <sjanssen> data Expr = Expr :*: Expr | Expr :+: Expr ...
15:58:59 <sizur> @seen alex
15:58:59 <lambdabot> I haven't seen alex.
15:59:15 <sjanssen> kib: you'll also need to give GHC some flags to turn on that extension
15:59:19 <oerjan> kib: they have to start with : though
15:59:25 <oerjan> sjanssen: er no
15:59:35 <oerjan> not for data constructors, that's H98
15:59:41 <sjanssen> oerjan: no, it isn't
15:59:49 <oerjan> yes it is
15:59:52 <sjanssen> ':' is special according to the report
16:00:08 <kib> Thanks sjanssen, could you be more precise with those options to give to ghc ?
16:00:26 <oerjan> sjanssen: it's a keyword, other constructors can start with that character though
16:00:38 <sjanssen> actually, maybe I'm wrong.
16:01:13 <dcoutts_> byorgey: got the patch, looking at it now...
16:01:23 <byorgey> dcoutts_: cool
16:01:35 <sjanssen> oerjan: yeah, you're right
16:01:48 <sjanssen> kib: it's not an extension -- listen to oerjan :)
16:02:28 <oerjan> kib: then you can have infixl 7 :*: and infixl 6 :+: declarations to give them the same precedences as the ordinary * and +
16:03:32 <kib> ok, but now I've got a problem with my formatExpr function. "formatExpr (:*: a b) = ..." does not compile.
16:03:52 <sjanssen> kib: you pattern match infix too -- (a :*: b)
16:04:45 <oerjan> (a :*: b)
16:07:13 <kib> ok, Haskell is just terrible :)
16:07:30 <Cale> what?
16:07:55 <Cale> kib: Why is that terrible?
16:08:05 <Cale> kib: You wanted them to be infix :)
16:08:23 <Cale> I suppose you could probably pattern match like ((:*:) a b) if you wanted
16:08:32 <Juliet_45> EXOTICS ADULT FORUM ::: http://exotics.heavenforum.com --- Free membership ! Come and share your adult materials ! We are here for you !!! AND WE ARE NEW !!!
16:08:32 <lambdabot> Title: EXOTICS FORUM
16:08:33 <kib> Yes, I find Haskell so short for such things !
16:08:33 <Juliet_45> EXOTICS ADULT FORUM ::: http://exotics.heavenforum.com --- Free membership ! Come and share your adult materials ! We are here for you !!! AND WE ARE NEW !!!
16:08:33 <lambdabot> Title: EXOTICS FORUM
16:08:39 --- mode: ChanServ set +o Cale
16:08:43 <Cale> ugh
16:08:51 <Cale> We need to do something about this.
16:09:05 <kib> For sure, annoying
16:09:09 <Botje> freenode needs a network of early-warning bots
16:09:24 <lispy> my adult materials?  Like adult building materials?
16:09:48 <lispy> I hate immature building supplies.
16:10:03 <Cin> is there a printf-like thing, but not to print to a handle, just to return a string?
16:10:10 <Cale> Chances are that spammer didn't just post the message in one channel. If you did some analysis of the messages which someone was sending to all channels you could notice repeating pretty quickly.
16:10:11 <lispy> Cin: yes
16:10:12 <ddarius> Cin: There's printf
16:10:15 <lispy> ?hoogle printf
16:10:16 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
16:10:16 <lambdabot> Text.Printf :: module
16:10:16 <lambdabot> Text.Printf.PrintfType :: class PrintfType t
16:10:27 <Cin> ahh... sorry
16:10:33 <Cale> > printf "hello %i" 5 :: String
16:10:33 <lambdabot>  Exception: Printf.printf: bad formatting char i
16:10:34 <kib> Cale : Yes, I find Haskell so short for such things
16:10:54 <Cale> > printf "hello %d" 5 :: String
16:10:55 <lambdabot>  "hello 5"
16:11:14 <Cale> kib: Short is terrible?
16:11:16 <ddarius> > printf "Hello %d" 5 :: IO ()
16:11:17 <Cin> > printf "%d%d" 5 5 :: Int
16:11:17 <lambdabot>   add an instance declaration for (PrintfType Int)
16:11:17 <lambdabot>     In the expression: pri...
16:11:17 <lambdabot>  <IO ()>
16:11:27 <Cale> > printf "%d%d" 5 5 :: String
16:11:27 <lambdabot>  "55"
16:11:33 <davidL> What is a good data structure to implement a tagging system where each Entry has a set of tags (Strings) associated with it such that Entries can be filtered by tag (like del.icio.us)? Currently I have data Entry = Entry { ... tags :: [ByteString] } and !(Seq [Entry]) for keeping state, is there a better way?
16:11:39 <Cin> just wondering why you need the signature
16:11:45 <kib> Maybe not the good term : in French, terrible means 'great'
16:11:49 <byorgey> dcoutts_: I'm going to dinner now and won't be on IRC again til tomorrow, if you have any comments etc., just send them to the mailing list.  thanks!
16:11:54 <ddarius> davidL: Why not use a Set?
16:11:55 <dcoutts_> byorgey: looks good, seems to work too, I'll apply it :-)
16:12:11 <byorgey> dcoutts_: great! =)
16:12:25 <ddarius> kib: Sometimes it's used that way in English, e.g. "Haskell is terribly useful"
16:13:13 <kib> that's what I thought in fact. It has two meanings, in French too.
16:13:14 <lispy> kib: but in english if we meant to use that expression, we could say, "Haskell is bad."  But, then...it really depends on the audience/context if they would understand that 'bad' means good
16:13:16 <dcoutts_> davidL: a trie, mapping tags to Entry
16:13:47 <sjanssen> davidL: I'd probably use (Map Tag (Set Entry), Map Entry (Set Tag))
16:13:56 <ddarius> dcoutts_: That seems overkill.  Even a Set seems overkill except that it will automatically get rid of duplicates and will scale if there were an insane number of tags.
16:14:19 <kib> lispy : yes, we can go to the C++/Java channel to see it in action :)
16:14:29 <oerjan> kib: i think in english "terrific" is more like it
16:14:29 <dcoutts_> ddarius: a trie will be faster, but you could just go with an ordinary Map like sjanssen says
16:15:14 <sjanssen> where Map k v = fast collection type mapping k to v, not necessarily Data.Map :P
16:15:35 <davidL> is there a trie implementation in core?
16:16:01 <sjanssen> davidL: you'll likely do two types of query very frequently: what tags does an entry have, and which entries have a certain tag
16:16:09 <lispy> davidL: well, as sjanssen points out, worry about the interface for now.  Pin down the implemenation later after you can experiment.
16:16:14 <kib> I've started a sort of Haskell Quickref, is there anything like this existing ?
16:16:34 <davidL> sjanssen: exactly
16:16:36 <sjanssen> you'll also frequently want intersection/union of sets of tagged entries
16:16:40 <ddarius> sjanssen: I would think that when you ask what tags an entry has, you already have the entry so you can just include the set of tags in the data type as per his original setup.
16:17:02 <Cale> kib: There's a tour of the syntax
16:17:07 <jorgedbucaran> hey
16:17:09 <ddarius> @google zvon haskell reference
16:17:09 <jorgedbucaran> anyone?
16:17:10 <lambdabot> http://www.zvon.org/other/haskell/Outputglobal/index.html
16:17:10 <lambdabot> Title: Haskell
16:17:12 <kib> Cale : http://kib2.free.fr/Haskell/HaskellQR.pdf
16:17:45 <Cale> kib: ah, that kind of quickref :)
16:17:52 <Cale> jorgedbucaran: yeah?
16:17:54 <kib> yes, like Emacs one
16:18:40 <oerjan> Cin: printf is extremely overloaded, so when using it directly from an interpreter prompt it needs disambiguation
16:18:55 <jorgedbucaran> Cale would you be up to for a small talk on what we left previously or that just too much of abuse?
16:19:05 <lispy> kib: hrm...your quickref is not loading...is it a large file?
16:19:07 <Cale> jorgedbucaran: it's fine.
16:19:22 <ddarius> lispy: 288kb
16:19:23 <jorgedbucaran> I'll take that as a Yes, roll it
16:19:28 <Cin> oerjan: ahh, i see
16:19:30 <kib> lispy : not at all, 2 pages only
16:19:30 <Cale> jorgedbucaran: So what would you like to know about?
16:19:31 <Cin> oerjan: thanks
16:19:32 <davidL> thanks all
16:19:40 <Cale> anything in particular?
16:19:54 <Cale> Maybe what function composition is all about?
16:19:59 <jorgedbucaran> translate the mapReduce type first
16:20:06 <Cale> um, okay
16:20:23 <lispy> kib: that is very nice!
16:20:31 <kib> What's wrong with my new code ? http://dpaste.com/32682/ ?
16:20:43 <Cale> Can you point me at where you pastebinned it?
16:20:56 <Cale> (jorgedbucaran)
16:21:00 <sjanssen> kib: can we also see the error message?
16:21:22 <lispy> kib: are you having a specific problem?
16:21:25 <Cale> main is currently a string
16:21:34 <Cale> That would be one problem
16:21:36 <lispy> kib: or do you just want advice on making it better?
16:21:56 <Cale> (maybe you'd like to putStrLn that string?)
16:22:10 <kib> http://dpaste.com/32683/
16:22:29 <jorgedbucaran> http://dpaste.com/32684/
16:22:38 <jorgedbucaran> that's the mapReduce thing Cale
16:22:57 <jorgedbucaran> I know groupByKey and mapPerKey are not defined haha, of course  just need to walk trough that first
16:23:06 <adu> Why are there so many Float-like numeric classes?
16:23:21 <Botje> jorgedbucaran: you might want to use hpaste.org instead of dpaste.com
16:23:27 <sjanssen> kib: which line is 37?>
16:23:39 <Botje> it has haskell syntax highlighting en it announces on the channel
16:23:52 <kib> exp1 = ...
16:23:54 <Cale> kib: exp1 = Var "x" :+: Num 2
16:23:58 <jorgedbucaran> mmm ok... haha
16:24:08 <kib> Cale : Yes, what's wrong ?
16:24:15 <Cale> kib: you have exp1 = (Var "x") :+: 2
16:24:28 <Cale> kib: the 2 is missing a data constructor
16:24:33 <lispy> kib: you might want to instead use a GADT for Expr
16:24:39 <hpaste>  jorgedbucaran@g pasted "mapReduce" at http://hpaste.org/5248
16:24:41 <hpaste>  jorgedbucaran@g pasted "mapReduce" at http://hpaste.org/5249
16:24:42 <kib> Yes, but I thought "+"2" was right.
16:24:51 <jorgedbucaran> mmmmm
16:24:53 <jorgedbucaran> I see why
16:24:54 <lispy> kib: it would be (Num 2)
16:25:01 <Cale> jorgedbucaran: hm?
16:25:06 <sjanssen> kib: "Num 2" and "2" are two different things
16:25:08 <jorgedbucaran> the hpaste thing
16:25:11 <jorgedbucaran> first time I ever used that.
16:25:14 <jorgedbucaran> it's cool.
16:25:17 <Botje> Cale: get off you @Hovercraft! :)
16:25:18 <jorgedbucaran> I mean, it is handy.
16:25:23 <Botje> *your
16:25:28 <sjanssen> kib: "2 :: Int" (basically), but "Num 2 :: Expr"
16:25:34 <Cale> Botje: My hovercraft is full of eels?
16:25:38 --- mode: Cale set -o Cale
16:25:52 <kib> sjanssen : I understand that, but can I override this ?
16:25:53 <jorgedbucaran> question
16:25:54 <litb> one thing:
16:25:56 <litb> type QuadraturFormel = (Double -> Double) -> (Double, Double) -> Double
16:26:01 <Botje> Cale: P-lease fondle my but-tocks.
16:26:03 <sjanssen> kib: you can, by writing a Num instance for your type
16:26:04 <jorgedbucaran> does a function always return just one parameter in Haskell?
16:26:05 <litb> i don't understand one thing yet
16:26:17 <Cale> jorgedbucaran: in some sense, yes
16:26:29 <Cale> jorgedbucaran: and always takes one parameter, in some sense
16:26:30 <litb> what is different if i were to wrote this: type QuadraturFormel = Double -> Double -> Double, Double -> Double
16:26:32 <jorgedbucaran> of course it can return a list with a set of answers
16:26:34 <jorgedbucaran> I dunno
16:26:37 <Cale> jorgedbucaran: yeah
16:26:46 <kib> sjanssen : ok, should I derive Show inside ?
16:26:46 <Cale> jorgedbucaran: It can also return a function which takes another parameter.
16:26:50 <litb> i mean, i could pass a Double and get type QuadraturFormel = Double -> (Double, Double) -> Double , or?
16:26:53 <davidL> kib: have you seen http://cdsmith.wordpress.com/2007/11/29/some-playing-with-derivatives/ ?
16:26:54 <jorgedbucaran> of course
16:26:54 <lambdabot> Title: Some Playing with Derivatives ´ Sententia cdsmithus, http://tinyurl.com/2srhre
16:27:01 <litb> so the parens don't seem to make sense to me
16:27:06 <sjanssen> kib: yep, you'll need Show and Eq before you can write a Num instance
16:27:09 <jorgedbucaran> so the type of mapReduce
16:27:12 <lispy> kib: you might find this an interesting read: http://www.haskell.org/haskellwiki/Phantom_type
16:27:13 <lambdabot> Title: Phantom type - HaskellWiki
16:27:14 <jorgedbucaran> in written human form.
16:27:19 <Cin> who wants to pass judgment on my ircd code so far? http://rtfs.ath.cx/haskell/IRCServer/Server.hs.html
16:27:20 <lambdabot> Title: Haskell Code by HsColour
16:27:25 <Cale> jorgedbucaran: Because we use a really light syntax for function application, this makes functions of multiple parameters and functions of one parameter that return other functions into the same thing.
16:27:38 <litb> or isn't it possible to provide one Double only for the first form?
16:27:40 <jorgedbucaran> mmmm
16:28:09 <Cale> > let add x y = x + y; addFive = add 5 in addFive 7
16:28:11 <jorgedbucaran> I am still naive about Haskell power in functions. I believe it, I just haven't understood it quite yet.
16:28:12 <lambdabot>  12
16:28:23 <Cale> Check out that example.
16:28:34 <kib> davidL : no, thanks but it's just computation of derivatives values.
16:28:34 <Cale> > let add x y = x + y; addFive = add 5 in map addFive [1,2,3]
16:28:35 <lambdabot>  [6,7,8]
16:29:05 <Cale> addFive is defined simply by applying the two parameter function 'add' to one of its parameters
16:29:14 <jorgedbucaran> don't get the in
16:29:16 <jorgedbucaran> "in"
16:29:22 <Cale> let ... in ...
16:29:26 <jorgedbucaran> in addFive = add 5 in addFive 7
16:29:33 <jorgedbucaran> I mean add takes 2 parameters
16:29:34 <jorgedbucaran> which are?
16:29:41 <jorgedbucaran> 5 and ??
16:29:41 <kib> lispy : thanks for the link.
16:29:49 <Cale> Really, add takes one parameter
16:30:02 <Cale> and returns another function which takes the the other.
16:30:10 <Cale> -the
16:30:15 <EvilTerran> jorgedbucaran, the first is 5, the second is the parameter to addFive
16:30:21 <jorgedbucaran> wait
16:30:24 <jorgedbucaran> add takes one parameters?
16:30:25 <litb> > [1, 2, 3] + 1
16:30:25 <lambdabot>   add an instance declaration for (Num [t])
16:30:25 <lambdabot>     In the expression: [1, 2, 3] ...
16:30:29 <Cale> yep
16:30:30 <jorgedbucaran> add x y = ...
16:30:31 <EvilTerran> addFive x = add 5 x
16:30:31 <litb> ugg, how did that work Cale ?
16:30:33 <jorgedbucaran> that means it takes 2 parameters
16:30:55 <EvilTerran> add x = f
16:30:59 <EvilTerran>     where f y = x + y
16:31:03 <Cale> jorgedbucaran: yes, but taking two parameters is the same thing as taking one parameter and returning a function.
16:31:04 <RayNbow> litb: what do you want to do?
16:31:10 <lispy> kib: same concept, different example: http://augustss.blogspot.com/2007/06/representing-dsl-expressions-in-haskell.html
16:31:12 <lambdabot> Title: Things that amuse me, http://tinyurl.com/35u5ec
16:31:13 <EvilTerran> is equivalent to that definition of 5
16:31:16 <EvilTerran> er, add
16:31:32 <Cale> Let's look at this on the type level
16:31:32 <Cale> add :: Integer -> Integer -> Integer
16:31:41 <Cale> -> associates to the right
16:31:45 <Cale> So that's really:
16:31:47 <lispy> kib: the second link discusses the use of GADTs to make it even better
16:31:53 <Cale> add :: Integer -> (Integer -> Integer)
16:32:01 <jorgedbucaran> mmm
16:32:01 <Cale> function application associates to the left
16:32:04 <Cale> So when you write
16:32:06 <jorgedbucaran> takes int and returns 2 ints?
16:32:07 <Cale> add 5 7
16:32:10 <Cale> it really means
16:32:14 <jorgedbucaran> but hey then all I know is wrong?
16:32:14 <Cale> (add 5) 7
16:32:25 <jorgedbucaran> or it's just a formalism?
16:32:31 <Cale> jorgedbucaran: It's fine -- you can look at it both ways
16:32:35 <jorgedbucaran> so add 5 is actually what?
16:32:37 <adu> is this the right way to declare a class: http://hpaste.org/5250
16:32:40 <jorgedbucaran> (add 5)
16:32:43 <jorgedbucaran> is what?
16:32:45 <Cale> add 5 :: Integer -> Integer
16:32:49 <Cale> It's a function
16:32:58 <litb> ah, is it because of the list monad that list + int worked above?
16:32:59 <jorgedbucaran> wow
16:32:59 <kib> lispy : Phantom seems really useful, I've got some litterature for tonight.
16:33:02 <Cale> Specifically, it's the function which adds 5 to its parameter.
16:33:09 <lispy> kib: also, if you go with GADTs and want to add a type checker, look at this: http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html
16:33:11 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2saxu3
16:33:17 <jorgedbucaran> that must be easy to work out at the compiler level
16:33:20 <ddarius> litb: Cale wrote _map_ addFive [1,2,3]
16:33:21 <EvilTerran> adu, that looks fine
16:33:25 <jorgedbucaran> I mean it's all about recursivity
16:33:34 <jorgedbucaran> recursion**
16:33:40 <litb> oh hehe lolz, i haven't noticed that
16:33:45 <litb> i thought he is on his magic trip
16:33:51 <jorgedbucaran> anyway
16:34:19 <EvilTerran> adu, but will the body of those functions actually need to change depending on the types?
16:34:39 <jorgedbucaran> let add x y = x + y; addFive = add 5 in addFive 7        --addFive equals result of add 5 with what?? in map addFive?
16:34:49 <adu> EvilTerran: I dunno, I haven't only implemented them so far for Rational a
16:34:56 <EvilTerran> jorgedbucaran, it means the result of "add 5". nothing more.
16:34:57 <jorgedbucaran> what is "in"?
16:35:01 <Cale> addFive becomes the function add 5
16:35:02 <EvilTerran> > let x = 1 in x
16:35:03 <lambdabot>  1
16:35:06 <litb> jorgedbucaran: that will be "5 + 7
16:35:12 <EvilTerran> > let x = "something"; y = "else" in x ++ y
16:35:13 <Cale> > let x = 5 in x + x
16:35:13 <lambdabot>  "somethingelse"
16:35:13 <lambdabot>  10
16:35:14 <litb> > let add x y = x + y; addFive = add 5 in addFive 7
16:35:15 <lambdabot>  12
16:35:26 <lispy> jorgedbucaran: it's like reading it in english, let <definitions> in <use of definitions>
16:35:30 <jorgedbucaran> is that that "in" enforced?
16:35:34 <Cale> yes
16:35:44 <kib> I have to go. Thank you all, you've got a nice channel here : keep it like this !
16:35:49 <Cale> It's part of the syntax of a  'let ... in ...' expression
16:35:55 <litb> jorgedbucaran: without in , let would be pretty useless
16:35:57 <jorgedbucaran> mmmmmm
16:36:00 <lispy> kib: good luck
16:36:01 <jorgedbucaran> got it
16:36:12 <kib> thanks, bye !
16:36:15 <jorgedbucaran> oh wait
16:36:17 <adu> EvilTerran: what difference would it make if I were to need different implementaitons?
16:36:22 <jorgedbucaran> didn't
16:36:33 <litb> it would be like "in the following, f is "foo": ."
16:36:35 <EvilTerran> adu, if you don't need different implementations, you could dispense with the class entirely
16:36:50 <adu> EvilTerran: how else would I declare "Matrix" then?
16:37:14 <jorgedbucaran> for example I get this: let add x y = x + y; addFive = add 5
16:37:38 <lispy> man, if lennart ever comes back i want more of his type checking blog entries
16:37:46 <EvilTerran> adu, wait, in the instance you've written so far, what's m?
16:37:46 <jorgedbucaran> addFive = add 5 in addFive 7?
16:37:50 <jorgedbucaran> what is that addFive 7?
16:37:54 <Cale> jorgedbucaran: The 'in' part says which value we'd like to evaluate with the definitions given in the 'let' part.
16:37:58 <oerjan> jorgedbucaran: add 5 7
16:38:06 <litb> jorgedbucaran: it is the code that is returned by the whole let clause
16:38:10 <adu> EvilTerran: I dunno, I wanted to distinguish between "a" and a matrix of "a"
16:38:26 <Cale> > let echo x = x ++ x in echo "hello"
16:38:27 <lambdabot>  "hellohello"
16:38:34 <EvilTerran> jorgedbucaran, "addFive = add 5". so "addFive 7" = "(add 5) 7"
16:38:44 <Cin> http://sovietrussia.org/code/src/11983479293370831.jpg :)
16:39:02 <Cale> Cin: :)
16:39:05 <EvilTerran> jorgedbucaran, , "addFive" and "add 5" are equal, it says so in the source - so you can swap one for the other with impunity! :)
16:39:05 <Cale> hehe
16:39:15 <jorgedbucaran> so? let add x y = x + y; addFive = add 5 . addFive 7
16:39:17 <litb> > let echo t = "echo has taste!" in echo "perfect wave"
16:39:17 <jorgedbucaran> works too?
16:39:18 <lambdabot>  "echo has taste!"
16:39:35 <Cale> jorgedbucaran: no, it's a type error, and a syntax error.
16:39:47 <jorgedbucaran> haha I figured
16:39:49 <EvilTerran> adu, see, the thing is, every parameter to a class has got to be some relevant type
16:39:55 <hpaste>  adu pasted "Matrix implementation" at http://hpaste.org/5251
16:40:08 <jorgedbucaran> what I don't understand is that addFive = add 5 in addFive 7
16:40:15 <EvilTerran> adu, and do you mean distinguish between "array of a" and "matrix of a"?
16:40:15 <jorgedbucaran> that is so hardcode
16:40:20 <jorgedbucaran> hardcore** to me
16:40:28 <adu> EvilTerran: I guess so
16:40:40 <Cale> jorgedbucaran: the 'in' separates the end of the definitions from the expression we want to evaluate
16:40:44 <adu> EvilTerran: this is the implementation I have so far: http://hpaste.org/5251
16:40:55 <Cale> jorgedbucaran: look at this example
16:40:57 <EvilTerran> adu, you see the "annotate" link on hpaste posts? you can use that to put several pastes on the one page, which is quite handy for keeping 'em together
16:41:01 <Cale> > let x = 5 in x + x
16:41:01 <litb> jorgedbucaran: see: don'T read it as "addFice = (add 5 in addFive 7)" but read it as "... addFive = add 5) in addFive 7"
16:41:02 <lambdabot>  10
16:41:02 <jorgedbucaran> another example of in?
16:41:11 <Cale> yes
16:41:12 <olsner> there! I have a partial C/C++ lexer written in polyparse
16:41:14 <Cale> I gave one there
16:41:35 <litb> jorgedbucaran: the in marks the end of the definitions and the begin of actually using them
16:41:37 <Cale> > let str = "hello" in reverse str
16:41:37 <lambdabot>  "olleh"
16:41:42 <adu> EvilTerran: o ok
16:41:49 <Cale> > let f x y = x^2 + y^2 in f 3 4
16:41:50 <lambdabot>  25
16:41:54 <jorgedbucaran> let x = 5 in x + x
16:42:05 <jorgedbucaran> what is IN??
16:42:06 <Cale> It might help if I add some braces.
16:42:09 <jorgedbucaran> omg
16:42:09 <litb> lolz
16:42:10 <lispy> > let x = 5 in x + x
16:42:11 <lambdabot>  10
16:42:13 <Cale> It's syntax.
16:42:14 <EvilTerran> jorgedbucaran, we've told you repeatedly
16:42:15 <oerjan> > let { add x y = x + y; addFive = add 5 } in addFive 7 -- with explicit braces
16:42:16 <lambdabot>  12
16:42:18 <jorgedbucaran> haha
16:42:25 <lispy> jorgedbucaran: it's just a keyword that seperates the two parts of the let
16:42:33 <jorgedbucaran> ohhh right
16:42:35 <jorgedbucaran> let
16:42:38 <jorgedbucaran> what is that for?
16:42:40 <jorgedbucaran> why not
16:42:44 <jorgedbucaran> x = ...
16:42:44 <lispy> jorgedbucaran: it could be pizza instead of 'in' for all we care
16:42:50 <Cale> It's for making definitions inside an expression.
16:42:56 <jorgedbucaran> mmmmm
16:43:08 <jorgedbucaran> so without let
16:43:12 <Cale> lambdabot only evaluates expressions
16:43:13 <litb> jorgedbucaran: you could aswell ask "why the if? it could just be l != k !"
16:43:14 <lispy> let x = 4 pizza x + x, would have worked just as well if the language desiners didn't like the word 'in'
16:43:15 <jorgedbucaran> how would you do the same?
16:43:30 <Cale> You would create a source file, put the definitions in that, and load it.
16:43:35 <adu> EvilTerran: What I'm trying to do is generalize my code from "Array x Rational" to "Array x Real"
16:43:37 <Cale> But we can't do this with the bot.
16:43:53 <litb> i think the bot is in a big do loop
16:44:17 <jorgedbucaran> let x = 1
16:44:21 <jorgedbucaran> that makes x = 1
16:44:24 <EvilTerran> adu, i see
16:44:27 <adu> EvilTerran: well actualy not quite that either, "Array x BigFloat" is actually what I'm looking for
16:44:29 <jorgedbucaran> so is that like a variable
16:44:34 <litb> jorgedbucaran: you would do just "x = 1"
16:44:35 <jorgedbucaran> ?
16:44:39 <lispy> litb: well, it parses it, writes it to a file, type checks it, (if it has an acceptable type) it executes the result
16:44:44 <jorgedbucaran> great
16:44:51 <jorgedbucaran> so when does let comes in handy?
16:44:56 <jorgedbucaran> to do what thing I can't do without it?
16:45:05 <EvilTerran> adu, i can't tell, do you actually do anything in those functions in the "implementation" bit that depend on the values being Rationals?
16:45:14 <lispy> jorgedbucaran: it's not required, it just there to make it easier to write code
16:45:27 <jorgedbucaran> Cale said it was to make definitions
16:45:30 <Cale> jorgedbucaran: Sometimes you want to define a function or a value which is local to the definition of another function.
16:45:39 <Cale> jorgedbucaran: That's what let is for.
16:45:40 <jorgedbucaran> I mean what "thing" I can't do without let?
16:45:43 <jorgedbucaran> in this context.
16:45:44 <ddarius> 'x = 1' is a top-level function declaration, 'let x = 1 in E' is an expression and can be used anywhere an expression can be used.
16:45:53 <jorgedbucaran> ok what is that?
16:45:55 <jorgedbucaran> let x = 1 in E?
16:45:55 <litb> jorgedbucaran: see this: (\x y -> let sum = x+y in sum * (y - x))
16:45:59 <jorgedbucaran> what does that means?
16:46:15 <EvilTerran> jorgedbucaran, we've explained this repeatedly. go read a tutorial, you don't seem to be picking things up here.
16:46:17 <jorgedbucaran> what translates let x = 1 in E?
16:46:19 <litb> jorgedbucaran: without let, you would have to repeat that x+y all over again if you would have used it more than one time
16:46:38 <adu> EvilTerran: well, I use division...
16:46:46 <Cale> > let s = 1 + 2 + 3 in s * s
16:46:47 <lambdabot>  36
16:46:59 <EvilTerran> http://haskell.org/haskellwiki/Learning_Haskell#Online_tutorials
16:47:05 <litb> i think he is quite confused now
16:47:09 <RayNbow> jorgedbucaran, the E in "let x = 1 in E" stands for an arbitrary expression... it's a meta-variable (that is, not a variable in the Haskell language)
16:47:11 <LoganCapaldo> jorgedbucaran: Do you know another language (like C for instance?)
16:47:19 <EvilTerran> adu, okay, so you need to be able to divide; that's not peculiar to rationals, let's see...
16:47:21 <EvilTerran> @type (/)
16:47:22 <lambdabot> forall a. (Fractional a) => a -> a -> a
16:47:32 <EvilTerran> adu, okay, so the type needs to be Fractional
16:47:34 <jorgedbucaran> yeah
16:47:35 <jorgedbucaran> C
16:47:54 <LoganCapaldo> so let x = 1 in E is like { int x = 1; E; } in C
16:47:54 <adu> EvilTerran: oh, cool, thats so simple!
16:47:56 <jorgedbucaran> let s = 1 + 2 + 3 in s * s
16:47:56 <oerjan> @go haskell for C programmers
16:47:57 <litb> i can't think of a let in c
16:48:00 <lambdabot> http://www.haskell.org/~pairwise/intro/intro.html
16:48:00 <lambdabot> Title: Haskell for C Programmers
16:48:11 <EvilTerran> adu, let's parameterise SlogMatrix, so you can change what type its elements are: a = Array SlogIndex a
16:48:13 <Cale> There's unfortunately no equivalent of let in C
16:48:20 <LoganCapaldo> Sure there is
16:48:24 <litb> LoganCapaldo: not really dude :D
16:48:24 <EvilTerran> adu, no, wait, it's not that easy, there's typeclasses to make things harder yet
16:48:27 <LoganCapaldo> a naked block
16:48:31 <ddarius> Not a complete equivalent.
16:48:33 <Cale> So if you need to define a function or value inside an expression, you can't.
16:48:35 <jorgedbucaran> geez
16:48:36 <LoganCapaldo> serves the same purpose
16:48:39 <adu> the numeric types have always confused me, I can't tell the difference between Fractional, Floating, RealFrac, RealFloat or Real... :)
16:48:45 <jorgedbucaran> let x = 1 in E
16:48:49 <jorgedbucaran> what does that does?
16:48:50 <EvilTerran> adu, or are you cool with typeclasses already?
16:48:53 <Cale> LoganCapaldo: Is a naked block allowed as part of an expression?
16:48:54 <litb> LoganCapaldo: not at all
16:48:56 <jorgedbucaran> I don't even know what happens there.
16:49:02 <litb> { } cannot return any value
16:49:15 <EvilTerran> jorgedbucaran, people keep explaining that.
16:49:19 <Cale> jorgedbucaran: It evaluates to whatever the expression E is, but where x = 1
16:49:20 <jorgedbucaran> nop
16:49:26 <litb> jorgedbucaran: it's like "int foobar; foobar = expr; "
16:49:27 <adu> EvilTerran: do I just replace "Rational" with "a" and prepend "Rational a" in the type declaration?
16:49:29 <LoganCapaldo> Cale: no but I'm not trying to claim that it its "exactly" the same
16:49:48 <EvilTerran> adu, yeah, that sounds about right. "type SlogMatrix a = Array SlogIndex a"
16:50:04 <adu> "Fractional a" i mean
16:50:05 <litb> and you ask "what does foobar mean??" and we say " it's a meta variable" and you ask "but what does it mean?" lolz
16:50:06 <LoganCapaldo> the "interesting" part of let x = 1 in E is tha x is only visible in E, the fact that E is an expression is just par for the course in Haskell
16:50:39 <LoganCapaldo> and that visibility is why you would choose to use let .. in ... over a top level binding
16:50:55 <LoganCapaldo> So I think the analogy is entirely appropiate for jorgedbucaran's question
16:51:16 <jorgedbucaran> I don't get it.
16:51:23 <EvilTerran> adu, well, you can't add that type constraint to "type" definitions
16:51:27 <jorgedbucaran> what is the output
16:51:30 <EvilTerran> adu, or do you mean adding it to annotations?
16:51:30 <ddarius> LoganCapaldo: There are uses of let beyond just visibility.
16:51:31 <oerjan> jorgedbucaran: well might be best to replace E by something else
16:51:39 <jorgedbucaran> let x = 1 in E
16:51:44 <oerjan> > let x = 1 in 2*x+1
16:51:45 <lambdabot>  3
16:52:03 <adu> EvilTerran: Like "type Fractional a =>  SlogMatrix = Array SlogIndex a"
16:52:13 <EvilTerran> adu, i'm afraid you can't do that
16:52:21 <adu> ok
16:52:24 <EvilTerran> adu, altho a problem would arise if you did that anyway
16:52:25 <jorgedbucaran> so... 1 + 2 * x (which is one?)
16:52:26 <adu> what can I do?
16:52:37 <litb> > (let x = 1 in x) + 1
16:52:37 <lambdabot>  2
16:52:39 <LoganCapaldo> ddarius: For the purposes of why use let over a top level binding?
16:52:47 <ddarius> LoganCapaldo: Yes.
16:52:52 <LoganCapaldo> Like?
16:52:56 <oerjan> jorgedbucaran: it was sort of "let x = 1 in ...any expression..." except ...any expression... was abbreviated to E
16:53:07 <jorgedbucaran> mmm
16:53:12 <EvilTerran> adu, if you tried to multiply two SlogMatrixes together, you wouldn't be able to tell what type "a" was in each case
16:53:14 <ddarius> LoganCapaldo: f x = g in let g y = x + y
16:53:15 <adu> EvilTerran: can I use data/newtype?
16:53:26 <jorgedbucaran> let x = 1 in x
16:53:27 <EvilTerran> adu, so you couldn't tell if they were the same, so couldn't multiply 'em
16:53:29 <jorgedbucaran> what is that?
16:53:34 <jorgedbucaran> what the heck is that???
16:53:36 <jorgedbucaran> XD
16:53:38 <litb> jorgedbucaran: it means you use x lolz
16:53:51 <EvilTerran> adu, instead, you can make "a" a parameter of SlogMatrix
16:53:54 <litb> and x is 1 . i don't see what is difficult with that
16:54:15 <adu> EvilTerran: thats what I was trying to do with the "Matrix" class......
16:54:17 <EvilTerran> adu, because then it'd be clear that you can multiply a  SlogMatrix Rational with a SlogMatrix Rational, but not with a SlogMatrix Float
16:54:34 <EvilTerran> adu, the syntax for this is "type SlogMatrix a = Array SlogIndex a"
16:54:39 <litb> it is like if(int x = 1) return x;
16:54:42 <jorgedbucaran> roots a b c = ((-b + sqrt(b*b - 4*a*c)) / (2*a), (-b - sqrt(b*b - 4*a*c)) / (2*a))
16:54:46 <litb> in c++
16:54:46 <adu> EvilTerran: oh, so I don't need a class?
16:54:50 <jorgedbucaran> what is the , for?
16:54:52 <jorgedbucaran> ","
16:54:54 <Cale> jorgedbucaran: Functional programming is all about defining values. Expressions evaluate to values.
16:54:59 <oerjan> > let x = "jorgedbucaran" in "Hello " ++ x
16:54:59 <lambdabot>  "Hello jorgedbucaran"
16:55:02 <EvilTerran> adu, i think it's overkill to use a class, at least :)
16:55:09 <adu> oh ok
16:55:22 <litb> jorgedbucaran: in fact, you cannot have an if without an else
16:55:26 <Cale> jorgedbucaran: Declarations (in part) give names to values.
16:56:02 <EvilTerran> adu, once you've added this parameter, you'll have to go through and add it wherever "SlogMatrix" appears left of a ::
16:56:05 <EvilTerran> er, right of
16:56:09 <jorgedbucaran> oh my
16:56:10 <LoganCapaldo> ddarius: I don't follow that example
16:56:11 <adu> EvilTerran: right
16:56:12 <jorgedbucaran> dude
16:56:15 <jorgedbucaran> let x = 1
16:56:19 <jorgedbucaran> is making x into 1
16:56:40 <oerjan> yep
16:56:48 <litb> you get it
16:56:51 <Cale> jorgedbucaran: "let ... in ..." is an expression form, that is, it evaluates to a value. The part after the 'let' consists of a sequence of declarations, which are either function bindings, or pattern bindings. In any case, you're defining names for functions and values.
16:56:57 <adu> EvilTerran: thanks
16:57:00 <Cale> The part after the 'in' is an expression.
16:57:20 <EvilTerran> adu, bear in mind that, when you do this, you'll get a mass of scary type errors
16:57:25 <Cale> This expression is evaluated and the declarations of values are used in carrying out that evaluation.
16:57:36 <adu> EvilTerran: lol, why?
16:57:41 <litb> jorgedbucaran: it is like in K&R C , variable definitions could only take place at beginning of a function. after them, there was code that returned them and that did the return E;
16:58:02 <EvilTerran> because the type annotation "slogDet :: SlogMatrix a -> Rational" means slogDet's first parameter can be a SlogMatrix with any type parameter
16:58:18 <jorgedbucaran> let add x y = x + y; addFive = add 5 in addFive 7
16:58:20 <jorgedbucaran> so here
16:58:32 <EvilTerran> it could be a SlogMatrix String, or a SlogMatrix (Either Bool Char), for all the compiler knows
16:58:36 <jorgedbucaran> why isn't the let after the ;
16:58:39 <ddarius> LoganCapaldo: You could define a local value/function to close over something from an outer scope.
16:58:48 <litb> lolz
16:58:52 <jorgedbucaran> add x y = x+y; let addFive = add 5 in addFive?
16:59:10 <litb> jorgedbucaran: functions are high order in haskell
16:59:11 <jorgedbucaran> then addFive would be add 5 and addFive 7 would be add 5 7
16:59:15 <jorgedbucaran> which 13
16:59:17 <EvilTerran> adu, but you're doing arithmetic with the elements of the array
16:59:22 <litb> jorgedbucaran: there is nothing that makes functions any different from "variables"
16:59:29 <EvilTerran> adu, and you can't do arithmetic on values of any type
16:59:32 <jorgedbucaran> am I correct?
16:59:36 <jorgedbucaran> add x y = x+y; let addFive = add 5 in addFive 7
16:59:47 <fnord`> > add x y = x+y; let addFive = add 5 in addFive?
16:59:47 <lambdabot>  Parse error at "=" (column 9)
17:00:00 <jorgedbucaran> huh?
17:00:08 <adu> EvilTerran: that sucks
17:00:09 <litb> jorgedbucaran: that would work in haskell
17:00:21 <jorgedbucaran> it would?
17:00:24 <jorgedbucaran> my code
17:00:24 <litb> jorgedbucaran: if that let would be in a function, then that is legal haskell
17:00:26 <EvilTerran> adu, you can fix this, tho; bear with me
17:00:26 <jorgedbucaran> add x y = x+y; let addFive = add 5 in addFive 7
17:00:35 <EvilTerran> class constraints to the rescue!
17:00:36 <adu> EvilTerran: so can I implement this in a class?
17:00:46 <Cale> > let add x y = x+y in (let addFive = add 5 in addFive 7)
17:00:46 <lambdabot>  12
17:00:46 <EvilTerran> no, you don't need a new class
17:00:55 <Cale> is the same as
17:01:01 <EvilTerran> you just need to tell the compiler which classes slogDet (say) is using
17:01:04 <jorgedbucaran> 12 of course
17:01:05 <Cale> > let add x y = x+y; addFive = add 5 in addFive 7
17:01:05 <lambdabot>  12
17:01:09 <jorgedbucaran> my math sucks apparently
17:01:16 <jorgedbucaran> let add x y = x+y; addFive = add 5 in addFive 7
17:01:17 <jorgedbucaran> why not
17:01:23 <jorgedbucaran> add x y = x+y; let addFive = add 5 in addFive 7
17:01:29 <EvilTerran> adu, so, let's see... you're calling product on a list of elements from our SlogMatrix a
17:01:33 <EvilTerran> ?type product
17:01:34 <lambdabot> forall a. (Num a) => [a] -> a
17:01:37 <Cale> Because that looks like a declaration followed by an expression
17:01:40 <oerjan> jorgedbucaran: because that let defines both add and addFive
17:01:48 <jorgedbucaran> mmmmmmm
17:01:51 <Cale> lambdabot wants an expression to evaluate
17:01:52 <litb> jorgedbucaran: because you are in a do block. you can only do "add x y = .." at global level
17:01:54 <EvilTerran> adu, so we're calling product on a [a], and that means the constraint "Num a" must apply
17:02:03 <jorgedbucaran> what about a simple example?
17:02:07 <EvilTerran> adu, also, note that means we're returning an a, not a Rational
17:02:09 <Cale> > let x = 5 in x
17:02:10 <lambdabot>  5
17:02:12 <Cale> > let x = 5 in x^2
17:02:13 <lambdabot>  25
17:02:15 <Cale> > let x = 5 in x+x
17:02:15 <lambdabot>  10
17:02:19 <litb> lolz
17:02:34 <jorgedbucaran> > let x = 5 in x
17:02:34 <lambdabot>  5
17:02:39 <litb> > let x = 2^x in x
17:02:40 <lambdabot>  Exception: <<loop>>
17:02:40 <fnord`> > let func x = x + 1 in func 10
17:02:41 <lambdabot>  11
17:02:48 <jorgedbucaran> oh my lambdabot is a machine!!! :O
17:03:03 <jorgedbucaran> am I from the past?
17:03:05 <jorgedbucaran> haha
17:03:08 <Cale> You didn't realise that?
17:03:11 <jorgedbucaran> nop
17:03:13 <litb> lolz
17:03:21 <EvilTerran> adu, i'm not sufficiently sure what your functions are doing to be able to tell you what exactly to change
17:03:32 <litb> you thought we had a lambda guru answering the silly snippets?
17:03:33 <jorgedbucaran> I thought it was a cool guy that followed you up all the time XD XD no kidding
17:03:41 <EvilTerran> adu, but changing the type sig there to "slogDet :: Num a => SlogMatrix a -> a" would be a start, i think
17:03:43 <jorgedbucaran> hahaha
17:04:11 <ddarius> jorgedbucaran: How do you know it isn't now?
17:04:15 <davidL> jorgedbucaran: what gave it away?
17:04:27 <Cale> probably the results in quick succession :)
17:04:27 <EvilTerran> adu, that means "for any (a) the caller of slogDet likes, provided (a) is a Numeric type, it'll happily take a (SlogMatrix a) and give back an (a)"
17:04:29 <jorgedbucaran> mmm
17:04:32 <oerjan> @vixen Are you a machine, lambdabot?
17:04:33 <lambdabot> no, how dare you ask if i'm a bot!
17:04:40 <Cale> > product [1..100]
17:04:40 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
17:04:47 <litb> woo
17:04:51 <litb> that was fast
17:04:54 <jorgedbucaran> hahaha
17:04:58 <LoganCapaldo> ddarius: right. But that's visibility too, admittedly the visibility of something else. (And it's also similar to f(int x) { int z; { int dbl = 2 * x; z = dbl + 1; }; return z; }). I'm also assuming to get your example originally was because you meant to say f x = g where g y = x + y or let g y = x + y in f x = g
17:05:01 <EvilTerran> adu, without the "Num a =>" constraint, the " provided (a) is a Numeric type" part of that would be missing
17:05:11 <jorgedbucaran> > 2 +1
17:05:14 <lambdabot>  3
17:05:16 <jorgedbucaran> > 2 + 1
17:05:17 <lambdabot>  3
17:05:18 <jorgedbucaran> > 2 + 1
17:05:19 <lambdabot>  3
17:05:22 <jorgedbucaran> it's a bot
17:05:22 <litb> lolz
17:05:25 <Cale> :)
17:05:27 <RayNbow> > product [1..] * 0   -- too bad (*) is strict... :p
17:05:31 <glguy> jorgedbucaran: if you want to flood the bot, you can do it in a /msg too
17:05:34 <lambdabot> Terminated
17:05:39 <jorgedbucaran> > 1 / 0
17:05:40 <lambdabot>  Infinity
17:05:42 <jorgedbucaran> hahaha
17:05:47 <jorgedbucaran> > hello
17:05:47 <lambdabot>   Not in scope: `hello'
17:05:52 <jorgedbucaran> there you go
17:05:52 <sizur> @vixen jorgedbucaran just called you a bot!
17:05:52 <lambdabot> a bot? what is that?
17:05:57 <EvilTerran> adu, are you following?
17:05:58 <Cale> > let hello = "hello" in hello
17:05:58 <lambdabot>  "hello"
17:05:59 <adu> EvilTerran: ok
17:06:05 <jorgedbucaran> @vixen hello pal!
17:06:05 <lambdabot> how're you?
17:06:11 <jorgedbucaran> @ cool, and you?
17:06:16 <EvilTerran> adu, okay, but just changing the type signature probably won't be enough to get it working
17:06:21 <jorgedbucaran> @vixen cool, and you?
17:06:21 <lambdabot> cool you say?
17:06:29 <jorgedbucaran> @vixen are you stupid?
17:06:29 <lambdabot> i truely am
17:06:33 <ddarius> LoganCapaldo: Oh wow, I totally jacked that up.  You see how often I use let v. where.
17:06:33 <jorgedbucaran> XD
17:06:38 <RayNbow> > let lazyMult x y = if (x == 0 || y == 0) then 0 else x*y   in    product [1..] `lazyMult` 0
17:06:38 <Cale> @vixen a/s/l
17:06:39 <lambdabot> 19/f/California
17:06:43 <jorgedbucaran> hahaha
17:06:43 <RayNbow> hmm
17:06:45 <lambdabot> Terminated
17:06:45 <jorgedbucaran> XD
17:06:55 <litb> @vixen hm, tell me how old i am
17:06:55 <lambdabot> 19, you?
17:07:03 <Cale> heh
17:07:05 <RayNbow> oh crap
17:07:09 <litb> lolz, i tricked it
17:07:14 <RayNbow> == forced evaluation
17:07:15 <jorgedbucaran> let x = x in x +1
17:07:18 <jorgedbucaran> > let x = x in x +1
17:07:19 <lambdabot>  Exception: <<loop>>
17:07:21 <EvilTerran> adu, er, what's "prod"?
17:07:22 <Cale> @vixen What do you think of functional programmers?
17:07:22 <lambdabot> you're fun too
17:07:28 <sizur> litb, no, she's asking you to guess her age now
17:07:28 <LoganCapaldo> ddarius: it took me a while to try and decide whether this was some corner of Haskell I had no idea about or what, heh
17:07:36 <Cale> > let x = x+1 in x
17:07:36 <lambdabot>  Exception: <<loop>>
17:07:40 <LoganCapaldo> So I decided to paly it safe and ask
17:07:42 <jorgedbucaran> > let x = x in x*x
17:07:43 <lambdabot>  Exception: <<loop>>
17:07:58 <Cale> > let x = 1 : x in x
17:07:59 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:08:00 <litb> sizur: yeah, i believe you
17:08:11 <ddarius> Curses!
17:08:11 <jorgedbucaran> > let x = 5 in x^2
17:08:12 <lambdabot>  25
17:08:16 <RayNbow> > let lazyMult x y = if (x == 0) then 0 else x*y   in   0 `lazyMult` product [1..]   -- dumdiedum...
17:08:17 <lambdabot>  0
17:08:23 <jorgedbucaran> > let x = x in x +1
17:08:23 <lambdabot>  Exception: <<loop>>
17:08:27 <jorgedbucaran> mmm
17:08:32 <Cale> > let x = x in x
17:08:33 <lambdabot>  Exception: <<loop>>
17:08:37 <jorgedbucaran> I like that
17:08:40 <jorgedbucaran> it's logic
17:08:51 <Cale> It detects some infinite loops, but not all of them.
17:08:54 <jorgedbucaran> > let x = x in x
17:08:54 <lambdabot>  Exception: <<loop>>
17:08:58 <EvilTerran> > last [1..]
17:09:00 <litb> does it resemble UML stereotypes?
17:09:01 <lambdabot> Terminated
17:09:01 <jorgedbucaran> > let x = x in print(x)
17:09:03 <lambdabot>  <IO ()>
17:09:05 <davidL> > let x = x in x*0
17:09:06 <lambdabot>  Exception: <<loop>>
17:09:11 <jorgedbucaran> > let x = x in 0
17:09:12 <lambdabot>  0
17:09:25 <EvilTerran> :D
17:09:38 <ddarius> @faq  Can Haskell solve the Halting Problem?
17:09:38 <lambdabot> The answer is: Yes! Haskell can do that.
17:09:45 <Cale> haha
17:10:03 <adu> EvilTerran: you know you can define the determinant of a matrix [a_ij] by: Sum_{perm in perms} Signature(perm) Product_{i in perm} a_(i)(perm i)
17:10:07 <RayNbow> @faq Can Haskell make us happy?
17:10:08 <lambdabot> The answer is: Yes! Haskell can do that.
17:10:10 <adu> prod == Product_{i in perm} a_(i)(perm i)
17:10:16 <jorgedbucaran> let div x y = x/y
17:10:19 <jorgedbucaran> > let div x y = x/y
17:10:19 <lambdabot>  Parse error at end of input
17:10:23 <jorgedbucaran> > let div x y = x/y;
17:10:23 <lambdabot>  Parse error at end of input
17:10:31 <RayNbow> jorgedbucaran: you need
17:10:35 <EvilTerran> adu, oh, i see, it's defined in the line above (doh)
17:10:38 <RayNbow> crap, damn enter...
17:10:48 <RayNbow> *jorgedbucaran: you need an in ... part
17:10:49 <EvilTerran> @quote pcrs
17:10:49 <jorgedbucaran> what do I need raynbow?
17:10:50 <lambdabot> No quotes match. Wrong!  You cheating scum!
17:10:53 <EvilTerran> hm
17:10:54 <jorgedbucaran> oh right
17:10:59 <EvilTerran> @remember pcrs Premature carriage ret
17:11:00 <sizur> @faq is pepsi orange to the taste?
17:11:00 <lambdabot> The answer is: Yes! Haskell can do that.
17:11:00 <lambdabot> Done.
17:11:28 <ddarius> sizur: Part of the flavor of (carbonated) Pepsi comes from carbonic acid.
17:12:05 <sizur> ddarius, that's ok, i eat stones
17:12:07 <litb> acid is atomicy consistency isolation durability
17:12:20 <hpaste>  EvilTerran annotated "Matrix implementation" with "trimming it down so it's easier to work with" at http://hpaste.org/5251#a1
17:12:26 <jorgedbucaran> > r a b c = 1,2,3
17:12:26 <lambdabot>  Parse error at "=" (column 9)
17:12:31 <EvilTerran> adu, okay, i've annotated your paste there
17:12:38 <jorgedbucaran> what is the comma for?
17:12:41 <EvilTerran> adu, complete with the changes i've made so far
17:12:44 <litb> > let a (,) in a 1 2
17:12:44 <lambdabot>  Parse error at "in" (column 11)
17:12:50 <Cale> jorgedbucaran: It's used in a couple of places
17:12:51 <litb> > let a = (,) in a 1 2
17:12:52 <lambdabot>  (1,2)
17:12:54 <litb> o.O
17:12:57 <adu> EvilTerran ok
17:13:01 <Cale> jorgedbucaran: In separating the elements of lists, and tuples
17:13:29 <EvilTerran> adu, a stylistic point: "prod = (\x -> ..." can just be written "prod x = ..."
17:13:35 <Cale> jorgedbucaran: and in other places in the syntax which demand a list of things, but which aren't actually values (like export lists)
17:13:42 <jorgedbucaran> foo a = a + 5
17:13:47 <jorgedbucaran> <foo a = a + 5
17:13:51 <jorgedbucaran> > foo a = a + 5
17:13:51 <lambdabot>  Parse error at "=" (column 7)
17:14:00 <jorgedbucaran> > foo a = a + 5;
17:14:00 <lambdabot>  Parse error at "=" (column 7)
17:14:03 <Cale> jorgedbucaran: That's a valid declaration
17:14:06 <sizur> @faq Can Haskell travel back in time and kill his own grandfather?
17:14:06 <litb> lolz
17:14:06 <lambdabot> The answer is: Yes! Haskell can do that.
17:14:07 <oerjan> jorgedbucaran: > doesn't do top level declarations
17:14:10 <Cale> jorgedbucaran: but it's not a valid expression
17:14:28 <oerjan> @let foo a = a + 5
17:14:29 <lambdabot> <local>:10:0:     Multiple declarations of `L.foo'     Declared at: <local>:9...
17:14:32 <jorgedbucaran> > foo a = a + 5; foo 10
17:14:32 <lambdabot>  Parse error at "=" (column 7)
17:14:35 <jorgedbucaran> > foo a = a + 5; foo 10;
17:14:35 <lambdabot>  Parse error at "=" (column 7)
17:14:36 <Cale> You can use @let to store a declaration in the bot temporarily :)
17:14:46 <Cale> @undefine
17:14:48 <lambdabot> Undefined.
17:14:49 <byorgey> > let foo a = a + 5 in foo 10
17:14:49 <lambdabot>  15
17:14:53 <Cale> @let foo a = a + 5
17:14:54 <lambdabot> Defined.
17:14:59 <adu> EvilTerran: I still get errors, for some reason it thinks "SlogMatrix a -> a" is infered as "SlogMatrix Int -> Int"
17:15:00 <Cale> > foo 10
17:15:00 <lambdabot>  15
17:15:01 <sizur> i think @let feature needs to be turned off
17:15:07 <litb> > foo 20
17:15:08 <lambdabot>  25
17:15:11 <ddarius> sizur: Why?
17:15:12 <litb> how long does it last?
17:15:15 <jorgedbucaran> > foo a = a +5;
17:15:15 <lambdabot>  Parse error at "=" (column 7)
17:15:15 <sizur> it's a vulnerability
17:15:21 <byorgey> litb: until someone @undefines it
17:15:23 <ddarius> sizur: In what way?
17:15:24 <Cale> It lasts until the next @undefine
17:15:28 <jorgedbucaran> @let foo a = a +5;
17:15:28 <lambdabot> <local>:1:0:     Warning: Pattern match(es) are overlapped              In th...
17:15:31 <hpaste>  EvilTerran annotated "Matrix implementation" with "A little light reformatting (adu)" at http://hpaste.org/5251#a2
17:15:37 <Cale> @undefine
17:15:38 <lambdabot> Undefined.
17:15:40 <jorgedbucaran> @let jorge_foo a = a +5;
17:15:41 <lambdabot> Defined.
17:15:41 <Cale> jorgedbucaran: try again
17:15:45 <Cale> there we go :)
17:15:49 <EvilTerran> adu, now, you may prefer it your way, but that version's how i'd lay it out
17:15:49 <jorgedbucaran> jorge_foo 5
17:15:52 <jorgedbucaran> > jorge_foo 5
17:15:52 <lambdabot>  10
17:15:56 <EvilTerran> adu, yes, you'll still be getting errors at this point
17:15:57 <davidL> it would be nice if you could @undefine a specific function :)
17:16:00 <sizur> you can chewup all mem all the time with random definitions
17:16:07 <byorgey> davidL: that would be nice, wouldn't it?
17:16:10 <adu> EvilTerran: oh ok
17:16:13 <Cale> sizur: they're stored on disk
17:16:19 <sizur> have another bot @let her all the time
17:16:21 <Trinithis> [1,2] >>= (\x -> x^2)
17:16:23 <Cale> sizur: Expressions are compiled as separate programs.
17:16:25 <sizur> Cale, even worse
17:16:38 <Trinithis> @[1,2] >>= (\x -> x^2)
17:16:38 <lambdabot> Unknown command, try @list
17:16:42 <Cale> sizur: and so unused expressions are eliminated as dead code
17:16:55 <EvilTerran> adu, what do you think of my reformatting? i don't mind working with newbies, but i do tend to force my stylings on them ;)
17:16:59 <litb> Trinithis: sure that will work?
17:17:01 <sizur> Cale, when?
17:17:07 <byorgey> > [1,2] >>= (\x -> [x^2]) -- Trinithis
17:17:08 <Cale> sizur: during compilation
17:17:08 <lambdabot>  [1,4]
17:17:09 <litb> ah sure
17:17:19 <adu> EvilTerran: I don't see any difference
17:17:20 <Trinithis> i thx
17:17:25 <Cale> sizur: Each expression is compiled and executed as a separate program.
17:17:27 <litb> oh wait doesn't it concatMap using that function?
17:17:36 <litb> > [1,2] >>= (\x -> x^2)
17:17:36 <byorgey> litb: yes.  notice I added [ ] around the x^2.
17:17:36 <lambdabot>   add an instance declaration for (Num [b])
17:17:36 <lambdabot>     In the expression: x ^ 2
17:17:36 <lambdabot>     ...
17:17:40 <litb> i'm upset
17:17:44 <litb> oh i see
17:17:48 <sizur> Cale, so @let works only till the first evaluation?
17:18:01 <litb> because of the type of >>=
17:18:01 <EvilTerran> adu, that last paste didn't change the behaviour at all, just reformatted it how i like it
17:18:04 <jorgedbucaran> @let tup a b = a,b
17:18:05 <lambdabot>  Parse error
17:18:07 <EvilTerran> adu, you might have to reload to see it
17:18:13 <jorgedbucaran> @let tup a b = a,b;
17:18:13 <lambdabot>  Parse error
17:18:17 <Cale> sizur: @let stores the definitions in L.hs which is imported into the program which it creates for each expression
17:18:25 <adu> oh hehehe
17:18:30 <litb> > [1,2] >>= (\x -> return (x^2))
17:18:31 <lambdabot>  [1,4]
17:18:37 <jethr0> > liftM (^2) [1,2]
17:18:38 <lambdabot>  [1,4]
17:18:42 <sizur> Cale, so what if i will @let a million times?
17:18:54 <sizur> Cale, taking 1k per defintion
17:18:55 <jorgedbucaran> @let tup a b = a,b;
17:18:55 <lambdabot>  Parse error
17:18:57 <adu> EvilTerran: that is much more clear
17:19:02 <EvilTerran> --- sizur has left IRC (Excess flood)
17:19:03 <litb> couldn't we call some evil function from a let?
17:19:03 <EvilTerran> :P
17:19:05 <jorgedbucaran> why?
17:19:06 <Cale> sizur: You'll maybe use a few megs on Don's disk.
17:19:11 <litb> and that is imported and executed then?
17:19:17 <EvilTerran> adu, i thought so :)
17:19:18 <sizur> Cale, that's 1 gig there
17:19:19 <Cale> sizur: You couldn't take 1k per definition
17:19:28 <ddarius> sizur: There's no problem setting a file quota.
17:19:31 <Cale> sizur: IRC has a much smaller cutoff than that.
17:19:35 <davidL> irc supports only 512 bytes per message
17:19:38 <EvilTerran> adu, okay, now the problem is this: you're returning an "a", whatever that is
17:19:49 <EvilTerran> but, your return value is the return value of a call to sum...
17:19:50 <Cale> (and a bit less since your message includes other stuff)
17:19:51 <EvilTerran> ?type sum
17:19:52 <lambdabot> forall a. (Num a) => [a] -> a
17:19:54 <byorgey> jorgedbucaran: I think you want (a,b)
17:20:01 <jorgedbucaran> @let tup a b = (a,b);
17:20:03 <lambdabot> Defined.
17:20:06 <byorgey> jorgedbucaran: also, ; does not terminate expressions in haskell
17:20:13 <sizur> still, there is a possibility of filling up that quota every day
17:20:14 <jorgedbucaran> > tup 1 2
17:20:15 <lambdabot>  (1,2)
17:20:17 <byorgey> jorgedbucaran: you can just leave off the ;
17:20:20 <litb> sum is foldl (+)
17:20:22 <jorgedbucaran> thanks
17:20:31 <jorgedbucaran> @vixen you are helping me fellow
17:20:31 <Cale> sizur: There's also a possibility that you can be banned from using the bot.
17:20:31 <lambdabot> I like to pick everything up and smell it... Its a fetish of mine... And i mean everything! Is that cool with you?
17:20:33 <EvilTerran> adu, and the parameter to sum is a list of results from toRational
17:20:36 <EvilTerran> ?type toRational
17:20:36 <lambdabot> forall a. (Real a) => a -> Rational
17:20:38 <sizur> especially easy with a distributed attack
17:20:47 <jorgedbucaran> @vixen I guess, stop being so creepy.
17:20:48 <lambdabot> sorry, i'll stop
17:20:56 <litb> errm, foldl (+) 0 i mean
17:20:59 <jorgedbucaran> @vixen hooray!
17:20:59 <lambdabot> yeah, why not?
17:21:05 <adu> EvilTerran: so should that be "fromRational" instead?
17:21:10 <EvilTerran> adu, surprisingly, these're rationals. sum returns something of the same types as the elements of its parameter
17:21:15 <jorgedbucaran> @undefined
17:21:16 <RayNbow> @src sum
17:21:16 <lambdabot> Undefined.
17:21:16 <lambdabot> sum = foldl (+) 0
17:21:21 <EvilTerran> so it's trying to return a Rational, which is breaking
17:21:22 <Cale> sizur: It hasn't been a problem really.
17:21:35 <Cale> sizur: and it's easy to fix if it ever becomes one.
17:21:45 <sizur> Cale, that's good, and i hope it will never be a problem
17:21:52 <RayNbow> hmm, why isn't sum using the strict version of foldl?
17:21:58 <jorgedbucaran> > value = sqrt(5)
17:21:59 <lambdabot>  Parse error at "=" (column 7)
17:22:03 <litb> i read foldl is faster than foldr
17:22:08 <EvilTerran> adu, is the function in that position recieving Rationals as a parameter? i can't tell offhand
17:22:10 <jorgedbucaran> > value = sqrt 5
17:22:10 <lambdabot>  Parse error at "=" (column 7)
17:22:11 <ddarius> Most of the "vulnerabilities" were not fixed because they were actually abused.
17:22:19 <Cale> jorgedbucaran: that's a declaration
17:22:19 <litb> > sqrt 5
17:22:20 <lambdabot>  2.23606797749979
17:22:25 <Trinithis> how can i convert "5" to 5::Int?
17:22:26 <jorgedbucaran> > sqrt 5
17:22:26 <lambdabot>  2.23606797749979
17:22:29 <jorgedbucaran> ofc
17:22:30 <Cale> > let value = sqrt 5 in value
17:22:31 <lambdabot>  2.23606797749979
17:22:34 <RayNbow> Trinithis: use read
17:22:35 <jorgedbucaran> yea yea thanks
17:22:37 <Trinithis> kk
17:22:43 <RayNbow> > read "5" :: Int
17:22:44 <lambdabot>  5
17:22:44 <Cale> > let value = sqrt 5 in value^2
17:22:45 <lambdabot>  5.000000000000001
17:22:48 <litb> > show $ sqrt 5
17:22:48 <lambdabot>  "2.23606797749979"
17:23:13 <wagle> > sqrt (5 :: Int)
17:23:13 <lambdabot>   add an instance declaration for (Floating Int)
17:23:13 <lambdabot>     In the expression: sqrt ...
17:23:14 <Trinithis> > read "5" -- error?
17:23:15 <lambdabot>  5
17:23:21 <EvilTerran> adu, it seems to me that "permSig x" will be an Int, and "prod x" will be an "a"
17:23:24 <litb> > let value = sqrt 5 in value**2
17:23:25 <lambdabot>  5.000000000000001
17:23:26 <wagle> :t 5
17:23:26 <lambdabot> forall t. (Num t) => t
17:23:37 <Cale> Trinithis: it would be, but there's a system of defaulting for numbers
17:23:43 <jorgedbucaran> @let values a b = ( sqrt (a+b) , -sqrt(a+b) )
17:23:45 <Trinithis> okay
17:23:46 <lambdabot> Defined.
17:23:49 <adu> EvilTerran: that would be nice
17:23:51 <davidL> @version
17:23:51 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
17:23:51 <lambdabot> darcs get http://code.haskell.org/lambdabot
17:24:03 <Trinithis> Cale: what's the default? The most simple of the type?
17:24:06 <jorgedbucaran> > values 5, 2
17:24:07 <RayNbow> <litb> i read foldl is faster than foldr <-- that's not what I asked though :)
17:24:07 <Cale> Trinithis: You'll get an Integer or a Double, whichever is the first to apply.
17:24:08 <lambdabot>   parse error on input `,'
17:24:10 <davidL> Cale: how did you get mbot to build on 6.8.2?
17:24:12 <jorgedbucaran> > values 5 2
17:24:13 <lambdabot>  (2.6457513110645907,-2.6457513110645907)
17:24:18 <litb> does lambdabot run in ptrace?
17:24:36 <litb> otherwise, couldn't an evil user make it coredump by crashing the compiler?
17:24:38 <EvilTerran> adu, so, seeing as we want our function to return an "a" overall, it'd be easier to make "permSig x" an "a" before we multiply and then just work wit the multiplication results
17:24:39 <Cale> davidL: Quite easily. Changed some things in the cabal file to update for split base, I believe there was one other easy thing.
17:24:52 <litb> RayNbow: oh sorry, what did you ask?
17:24:57 <EvilTerran> adu, as (*) returns the same type as its parameters
17:25:07 <adu> EvilTerran: ok
17:25:09 <davidL> Cale: ah good, you should push those changes :)
17:25:16 <Cale> davidL: Something GHC didn't like in a deriving clause. I replaced an instance of the type IRCError with the variable e, and it worked.
17:25:19 <RayNbow> litb: why it uses foldl and not foldl'
17:25:19 <EvilTerran> adu, so we want a function that converts from Int to Num a => a
17:25:29 <litb> i don't know foldl'
17:25:31 <litb> what is it?
17:25:33 <adu> EvilTerran: fromInteger?
17:25:39 <RayNbow> strict version of foldl
17:25:45 <litb> what is that?
17:25:46 <jorgedbucaran> @let values a b = let x = sqrt(a+b) in ( x , -x )
17:25:46 <lambdabot> <local>:1:0:     Warning: Pattern match(es) are overlapped              In th...
17:25:50 <EvilTerran> adu, well, that goes from Integers to whatever
17:25:51 <EvilTerran> not Ints :P
17:25:53 <litb> sorry, i don't know what "strict version" means
17:25:58 <Trinithis> is gui difficuly in haskell?
17:26:03 <jorgedbucaran> @undefined
17:26:04 <lambdabot> Undefined.
17:26:04 <EvilTerran> ?type fromIntegral -- adu, this, OTOH...
17:26:05 <lambdabot> forall a b. (Num b, Integral a) => a -> b
17:26:07 <jorgedbucaran> @let values a b = let x = sqrt(a+b) in ( x , -x )
17:26:08 <lambdabot> Defined.
17:26:15 <jorgedbucaran> values 5 5
17:26:17 <Cale> Trinithis: not really any more difficult than in most other languages.
17:26:19 <jorgedbucaran> > values 5 5
17:26:20 <lambdabot>  (3.1622776601683795,-3.1622776601683795)
17:26:29 <jorgedbucaran> mmm
17:26:34 <Trinithis> Cale: got any tutorials for it?
17:26:36 <adu> oh ok
17:26:42 <Cale> Trinithis: There are bindings to GTK2 and wx
17:26:45 <litb> > (id&&&negate) pi
17:26:45 <lambdabot>  (3.141592653589793,-3.141592653589793)
17:26:57 <Cale> http://j-van-thiel.speedlinq.nl/gtk2hs/index.html
17:26:59 <adu> > toRational pi
17:26:59 <jorgedbucaran> > let add x y = x+y; addFive = add 5 in addFive 7
17:27:00 <lambdabot>  884279719003555%281474976710656
17:27:00 <lambdabot>  12
17:27:01 <lambdabot> Title: Gtk2Hs Tutorial
17:27:01 <EvilTerran> adu, check the paste again, i've updated it
17:27:08 <Cale> There's a tutorial for Gtk2Hs
17:27:24 <Cale> I don't think it uses Glade though. Glade is a much cooler way to use Gtk2Hs.
17:27:36 <dcoutts_> there is also a gtk2hs + glade tutorial
17:27:39 <litb> any1 could enlight me about "strict" ?
17:27:44 <Cale> http://www.haskell.org/gtk2hs/docs/tutorial/glade/
17:27:45 <lambdabot> Title: Gtk2Hs ª Documentation ª Glade Tutorial
17:27:45 <sizur> Grapefruit!
17:27:48 <Cale> there :)
17:27:57 <Trinithis> not sure what the difference between gtk2hs and glade are though, but as long as there is something, im fine :d
17:28:06 <RayNbow> litb: foldl (+) 0 [1,2,3,4,5] would evaluate to something like (0+1+2+3+4+5) before finally being evaluated to 15
17:28:14 <Cale> Trinithis: Glade is a UI designer which works with Gtk2Hs.
17:28:19 <sizur> @vixen, do you like Grapefruit?
17:28:19 <lambdabot> sure, i definitely don't hate
17:28:21 <litb> > second negate pi
17:28:22 <lambdabot>   add an instance declaration for (Floating (d, a))
17:28:36 <Cale> Trinithis: It saves you the trouble of typing in descriptions of all the controls you want by hand.
17:28:47 <Trinithis> Cale: mmm
17:28:49 <dcoutts_> Trinithis: gtk2hs is the haskell gui library, glade is a program for graphically designing UI layouts (that can then be loaded by gtk2hs code)
17:28:50 <davidL> :t second
17:28:51 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
17:29:05 <jorgedbucaran> > let add x y = x+y; addFive = add 5 2 in addFive 7
17:29:06 <lambdabot>   add an instance declaration for (Num (t -> a))
17:29:06 <lambdabot>     In the expression: add 5...
17:29:09 <sizur> g'night all
17:29:18 <Trinithis> nite
17:29:22 <Cale> It's also rather cool in that you don't have to recompile your program if you're just making cosmetic changes to the UI :)
17:29:30 <ramza3> :t let content = foldl (\x y -> (readFile x) ++ y) "" paths
17:29:31 <lambdabot> <command line>:
17:29:31 <lambdabot>     Could not find module `L':
17:29:31 <lambdabot>       Use -v to see a list of the files searched for.
17:29:37 <Trinithis> ha, that is neat
17:29:37 <litb> RayNbow: oh i see
17:29:38 <jorgedbucaran> > let add x y = x+y; add 5
17:29:38 <lambdabot>  Parse error at end of input
17:29:42 <litb> RayNbow: haven't known that
17:29:42 <RayNbow> litb: the strict version of foldl' forces evaluation after each recursive step
17:29:43 <jorgedbucaran> > let add x y = x+y; add 5;
17:29:43 <lambdabot>  Parse error at ";" (column 25)
17:29:52 <litb> RayNbow: how can that be done?
17:29:56 <jorgedbucaran> >@let add x y = x+y;
17:29:58 <RayNbow> @src foldl'
17:29:58 <lambdabot> foldl' f a []     = a
17:29:58 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:30:05 <litb> and is the strict version faster?
17:30:07 <jorgedbucaran> @undefined
17:30:09 <EvilTerran> adu, incidentally, does what i've pasted there seem to work?
17:30:15 <jorgedbucaran> @let add x y = x+y;
17:30:16 <lambdabot> Undefined.
17:30:16 <lambdabot> Defined.
17:30:18 <litb> > (second negate) pi
17:30:19 <lambdabot>   add an instance declaration for (Floating (d, a))
17:30:21 <litb> hm
17:30:24 <jorgedbucaran> >add 1 2
17:30:25 <Trinithis> > join Just Just x
17:30:25 <lambdabot>   Not in scope: `x'
17:30:26 <Botje> litb: not faster, O(1) memory instead of O(n).
17:30:28 <Cale> > let add x y = x + y in add 5
17:30:29 <Trinithis> > join Just Just 8
17:30:29 <lambdabot>  <Integer -> Integer>
17:30:29 <lambdabot>  Couldn't match expected type `a -> t1 -> t'
17:30:40 <Botje> (probably faster though)
17:30:43 <adu> EvilTerran: no
17:30:43 <jorgedbucaran> >add 1 2
17:30:50 <Cale> > let add x y = x + y in add 1 2
17:30:51 <lambdabot>  3
17:30:52 <jorgedbucaran> @undefined
17:30:52 <lambdabot> Undefined.
17:30:53 <RayNbow> Botje: do you know by any chance why @src sum shows foldl instead of foldl'?
17:31:01 <litb> Botje: ah
17:31:07 <jorgedbucaran> @let sum a b = a+b
17:31:11 <ddarius> RayNbow: Because that's how it's defined.
17:31:11 <lambdabot> Defined.
17:31:15 <litb> is there a strict version of sum too?
17:31:17 <litb> @src sum
17:31:17 <lambdabot> sum = foldl (+) 0
17:31:19 <Cale> oy, that'll be annoying :)
17:31:26 <litb> oh hehe, that was what you were asking i see
17:31:34 <ramza3>  let content = foldl (\x y -> (readFile x) ++ y) "" paths   ... I am trying to append the content of files read; but readFile returns IO String ...can I still use foldl this way
17:31:37 <litb> @src sum'
17:31:37 <lambdabot> Source not found. You untyped fool!
17:31:39 <Trinithis> > (join Just (Just 5)) >>= (\x -> x^2)
17:31:40 <lambdabot>  Couldn't match expected type `a1 -> m a'
17:31:43 <Cale> jorgedbucaran: You just defined something which is already defined in another module, making it ambiguous :)
17:31:44 <jorgedbucaran> > sum 1 1
17:31:44 <lambdabot> Terminated
17:31:47 <Cale> hehe
17:31:49 <RayNbow> ddarius: the Hugs version of the Prelude uses foldl' though
17:31:50 <Trinithis> > (join Just (Just 5)) >>= (\x -> return (x^2))
17:31:51 <lambdabot>  Couldn't match expected type `a1 -> m a'
17:31:55 <jorgedbucaran> @undefined
17:31:55 <lambdabot> Undefined.
17:31:59 <EvilTerran> adu, okay, i've tested it locally (commenting out everything else that causes an error 'til it worked ;)
17:32:02 <jorgedbucaran> @let my_sum a b = a+b
17:32:02 <lambdabot> Defined.
17:32:04 <RayNbow> @src foldl
17:32:04 <lambdabot> foldl f z xs = lgo z xs
17:32:04 <lambdabot>     where lgo z []     =  z
17:32:04 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
17:32:05 <ddarius> RayNbow: Hugs is wrong.
17:32:09 <jorgedbucaran> > my_sum 1 1
17:32:10 <lambdabot>  2
17:32:35 <Japsu> > solveTheDHProblem
17:32:36 <lambdabot>   Not in scope: `solveTheDHProblem'
17:32:45 <ddarius> RayNbow: Actually I think Hugs has an option like "use Report Prelude".
17:32:54 <Cale> RayNbow: that implementation of foldl makes me cry
17:32:57 <jorgedbucaran> > my_sum 1
17:32:58 <lambdabot>  <Integer -> Integer>
17:33:02 <Cale> foldl f z [] = z
17:33:04 <adu> EvilTerran: what did you comment out?
17:33:11 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
17:33:24 <jorgedbucaran> @let add a b = a + b
17:33:25 <lambdabot> Defined.
17:33:26 <ddarius> Actually, I'm thinking of a CPP define in the hierarchical libraries.
17:33:41 <RayNbow> Cale: it only makes you cry? In my case it's making my eyes bleed :p
17:33:44 <ddarius> So Hugs is just wrong (though admittedly that definition is almost certainly better)
17:33:46 <jorgedbucaran> @let addFive = add 5
17:33:47 <lambdabot> Defined.
17:33:49 <hpaste>  EvilTerran annotated "Matrix implementation" with "attack of the mass commenting-out -- adu" at http://hpaste.org/5251#a4
17:33:58 <litb> hm, so foldl' (+) 0 is better for sum ?
17:34:02 <jorgedbucaran> > addFive 7
17:34:02 <lambdabot>   Not in scope: `addFive'
17:34:19 <ddarius> litb: In most cases, yes.
17:34:34 <adu> lol
17:34:41 <Trinithis> what's wrong with: (join Just (Just 5)) >>= (\x -> return (x^2)) -- Just 25
17:34:44 <litb> hm, then maybe i should use that instead of sum in my itegration program, since the elements to be summed up are many
17:34:59 <litb> :t join
17:35:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:35:15 <byorgey> Trinithis: well, for one thing, the right argument to >>= must have type (a -> m b)
17:35:16 <RayNbow> litb: you shouldn't worry about performance though until you find out you're having a performance problem :p
17:35:20 <jorgedbucaran> > addFive 7 43
17:35:20 <lambdabot>   Not in scope: `addFive'
17:35:24 <byorgey> Trinithis: wait, ignore me =)
17:35:27 <ddarius> litb: If you are summing over Ints or Doubles GHC's strictness analyzer will produce foldl' effectively anyways with -O(2)
17:35:28 <EvilTerran> adu, i find it helps to concentrate on only one broken thing at a time :)
17:35:29 <jorgedbucaran> @undefined
17:35:30 <lambdabot> Undefined.
17:35:36 <adu> EvilTerran: good idea
17:35:39 <jorgedbucaran> @let add a b = a + b
17:35:40 <lambdabot> Defined.
17:35:46 <byorgey> Trinithis: you need parens around (Just (Just 5))
17:35:56 <oerjan> RayNbow: sum was defined in the haskell 98 report, which doesn't contain foldl' at all
17:35:59 <byorgey> Trinithis: as it is, it parses as (join Just) (Just 5)
17:36:01 <jorgedbucaran> @let addFive x = add 5 x
17:36:01 <lambdabot> Defined.
17:36:05 <RayNbow> oerjan: ah
17:36:06 <Trinithis> ahah thanks
17:36:15 <jorgedbucaran> >addFive 5
17:36:16 <byorgey> Trinithis: you could also add a $, like  join $ Just (Just 5)
17:36:21 <jorgedbucaran> > addFive 5
17:36:22 <lambdabot>  10
17:36:34 <Trinithis> byorgy : even better :D
17:36:44 <litb> > join (Just (Just 8))
17:36:44 <lambdabot>  Just 8
17:36:47 <byorgey> jorgedbucaran: you can also define that as :  addFive = add 5  =)
17:37:06 <ddarius> I don't think the Report Prelude uses seq anywhere other than in the definition of ($!)
17:37:10 <litb> > join [[1, 2, 3], [3, 4, 5]]
17:37:10 <lambdabot>  [1,2,3,3,4,5]
17:37:12 <litb> i see
17:37:19 <litb> @src join
17:37:19 <lambdabot> join x =  x >>= id
17:37:31 <litb> smart rly
17:37:35 <byorgey> > join (\x y -> x^2 + y) 6
17:37:36 <lambdabot>  42
17:37:53 <Trinithis> > (\x y -> x^2 + y) 6
17:37:54 <lambdabot>  <Integer -> Integer>
17:37:58 <BMeph> @let dup x = (x, x)
17:37:58 <lambdabot> Defined.
17:38:00 <hpaste>  EvilTerran annotated "Matrix implementation" with "moving on to slogMatrix " at http://hpaste.org/5251#a5
17:38:18 <BMeph> > second negate (dup pi)
17:38:18 <lambdabot>  (3.141592653589793,-3.141592653589793)
17:38:23 <oerjan> ddarius: yep, just checked.  and same with $!
17:38:30 <litb> dup x == id&&&id
17:38:47 <byorgey> Trinithis: that was mean, sorry =)
17:38:48 <litb> BMeph: ah, thxx
17:39:05 <Trinithis> byorgey: can you explain join (\x y -> x^2 + y) 6
17:39:24 <BMeph> litb: No problem, I have a Util.hs just full of little things like that.
17:39:28 <litb> @type join
17:39:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:39:33 <byorgey> Trinithis: it's join for the ((->) r) monad
17:39:37 <davidL> @pl \x -> x * x
17:39:37 <RayNbow> > let list = tails [1..10] in concat list == join list
17:39:37 <lambdabot> join (*)
17:39:38 <ddarius> dup = join (&&&)
17:39:41 <lambdabot>  True
17:39:42 <ddarius> dup = join (&&&) id
17:39:48 <byorgey> so in this case join :: (r -> r -> a) -> (r -> a)
17:40:06 <byorgey> Trinithis: it turns a function of two arguments into a function of one argument by duplicating its input
17:40:14 <Trinithis> ok
17:40:21 <byorgey> i.e. join f x == f x x
17:40:31 <oerjan> :t join.($)
17:40:32 <lambdabot> forall a a1. (a1 -> a1 -> a) -> a1 -> a
17:40:40 <adu> EvilTerran: I'll work on it at home later, thanks for you help
17:40:45 <litb> so second makes an arrow get the second one as input and output, and pass through the first one
17:40:50 <ddarius> @. djinn type join . ($)
17:40:50 <lambdabot> f a b = a b b
17:40:56 <byorgey> oerjan: that's slick.  I have to remember that little trick. =)
17:41:08 <oerjan> :)
17:41:12 <byorgey> litb: right.
17:41:18 <oerjan> byorgey: i've been advertising it ;)
17:41:31 <EvilTerran> adu: it's worth noting on that one th-
17:41:34 <EvilTerran> ...
17:41:39 <byorgey> hehe
17:41:40 <EvilTerran> didn't even get my ++ :(
17:41:52 <byorgey> EvilTerran++
17:41:53 <ddarius> EvilTerran++
17:41:57 <EvilTerran> woo! :D
17:42:02 <ddarius> EvilTerran--
17:42:02 <byorgey> see, now you got two! even better!
17:42:08 <byorgey> ... oh.
17:42:27 <EvilTerran> =/
17:42:28 <litb> @src join
17:42:28 <lambdabot> join x =  x >>= id
17:42:30 <EvilTerran> i guess that's fair
17:42:42 <byorgey> what are newbies coming to these days, they don't give ++'s like they used to
17:42:56 <EvilTerran> (don't worry, i'm not that much of a karma whore really. i just play one on weekends.)
17:43:09 <byorgey> @karma EvilTerran
17:43:09 <lambdabot> EvilTerran has a karma of 7
17:43:17 <RayNbow> @karma lambdabot
17:43:17 <lambdabot> lambdabot has a karma of 55
17:43:23 <Nafai> @karma byorgey
17:43:23 <lambdabot> byorgey has a karma of 9
17:43:23 <RayNbow> lambdabot++
17:43:28 <RayNbow> @karma lambdabot
17:43:28 <lambdabot> lambdabot has a karma of 56
17:43:38 <Cale> > (join Just (Just 5)) >>= (\x -> return (x^2))
17:43:38 <lambdabot>  Couldn't match expected type `a1 -> m a'
17:43:50 <davidL> @karma C
17:43:50 <lambdabot> C has a karma of 15
17:43:50 <Cale> > (join (Just (Just 5))) >>= (\x -> return (x^2))
17:43:51 <lambdabot>  Just 25
17:43:59 <litb> @karme C++
17:44:00 <lambdabot> C++ has a karma of -8
17:44:00 <Cale> davidL: heh
17:44:02 <litb> lolz
17:44:15 <oerjan> @karma Java
17:44:15 <lambdabot> Java has a karma of -23
17:44:21 <RayNbow> @karma Haskell
17:44:21 <lambdabot> Haskell has a karma of 23
17:44:28 <Cale> Haskell = -Java
17:44:33 <litb> lolz nice
17:44:39 <davidL> haha
17:44:40 <RayNbow> Haskell + Java = 0
17:44:43 <oerjan> litb: i believe it is actually impossible to increase the karma for Java
17:44:58 <byorgey> it is, I tried once =P
17:45:02 <Cale> RayNbow: a true algebraist!
17:45:09 <hpaste>  jorgedbucaran@g pasted "(no title)" at http://hpaste.org/5252
17:45:11 <araujo> java--
17:45:18 <Cale> Haskell++
17:45:23 <RayNbow> Cale: I just found a new meaning to the symbol 0 ;)
17:45:26 <araujo> haskell++
17:45:29 <litb> how can i @src (->e) >>= again?
17:45:33 <oerjan> @karma Java
17:45:34 <lambdabot> Java has a karma of -24
17:45:38 <byorgey> @src (->) (>>=)
17:45:38 <lambdabot> f >>= k = \ r -> k (f r) r
17:45:47 <oerjan> @karma Haskell
17:45:48 <lambdabot> Haskell has a karma of 25
17:45:52 <davidL> java++
17:45:55 <araujo> java--
17:45:56 <davidL> @karma java
17:45:56 <lambdabot> java has a karma of -25
17:45:58 <oerjan> hm that algebra was coincidental
17:46:02 <EvilTerran> haha
17:46:02 <araujo> java--
17:46:04 <hpaste>  jorgedbucaran@g pasted "(no title)" at http://hpaste.org/5253
17:46:04 <araujo> haskell++
17:46:09 <EvilTerran> @karma java
17:46:10 <lambdabot> java has a karma of -26
17:46:13 <jorgedbucaran> so what is the type of mapReduce?
17:46:15 <EvilTerran> @karma+ java
17:46:15 <lambdabot> EvilTerran's karma lowered to 6.
17:46:16 <RayNbow> some people are trying to unbalance the equation :p
17:46:21 <jorgedbucaran> http://hpaste.org/5253
17:46:22 <EvilTerran> !!!
17:46:32 <EvilTerran> @karma- java
17:46:32 <lambdabot> java's karma lowered to -27.
17:46:37 <EvilTerran> :(
17:46:37 <Cale> jorgedbucaran: well... that is :)
17:47:05 <jorgedbucaran> why are there 8 things
17:47:07 <Trinithis> @karma+ assembly
17:47:07 <lambdabot> assembly's karma raised to 1.
17:47:15 <jorgedbucaran> when the function only appear to take 6?
17:47:30 <RayNbow> @karma ChanServ
17:47:30 <lambdabot> ChanServ has a karma of 0
17:47:34 <litb> @karma Haskell
17:47:34 <lambdabot> Haskell has a karma of 26
17:47:37 <davidL> @karma+ "ChanServ"
17:47:37 <lambdabot> "ChanServ"'s karma raised to 1.
17:47:40 <RayNbow> @karma NickServ
17:47:40 <lambdabot> NickServ has a karma of 0
17:47:44 <davidL> @karma ChanServ
17:47:44 <lambdabot> ChanServ has a karma of 0
17:47:49 <jorgedbucaran> mapReduce :: forAll k1 k2 v1 v2 v3
17:47:55 <jorgedbucaran> those are 5
17:48:01 <Trinithis> :t forAll
17:48:01 <lambdabot> Not in scope: `forAll'
17:48:20 <twanvl> EvilTerran: The LB source says "| map toLower (Msg.nName nick) == "java" && km == 1 = changeKarma msg (-km) (Msg.lambdabotName msg) sender"
17:48:47 <jorgedbucaran> and what is Maybe??
17:48:58 <jorgedbucaran> so Cale, what is the type?
17:48:59 <EvilTerran> twanvl, eeeewilll...
17:49:14 <hpaste>  Cale annotated "(no title)" with "type interpretation" at http://hpaste.org/5253#a1
17:49:16 <davidL> @. karma+ run map chr [108,97,109,98,100,97,98,111,116]
17:49:17 <lambdabot> "lambdabot"'s karma raised to 1.
17:49:26 <olsner> nothing wrong with tipping the stats a wee bit haskell's way, is there? :P
17:49:29 <Cale> :t Just 5
17:49:29 <lambdabot> forall t. (Num t) => Maybe t
17:49:34 <Cale> :t Nothing
17:49:35 <lambdabot> forall a. Maybe a
17:49:49 <Cale> data Maybe a = Nothing | Just a
17:49:53 <byorgey> davidL: haha
17:50:23 <oerjan> @karma "lambdabot"
17:50:24 <lambdabot> "lambdabot" has a karma of 1
17:50:24 <ramza3> > 1 + 2
17:50:26 <lambdabot>  3
17:50:29 <Cale> For any type t, the type Maybe t is the type of values such that Nothing :: Maybe t, and if x :: t, then Just x :: Maybe t
17:50:56 <ramza3> > readFile "/var/log/dmesg"
17:50:57 <lambdabot>  <IO [Char]>
17:50:58 <Cale> jorgedbucaran: If you want, you could think of it as a list with at most one element ;)
17:51:06 <opqdonut> :)
17:51:12 <opqdonut> listToMaybe
17:51:20 <jorgedbucaran> > Maybe 45
17:51:21 <lambdabot>   Not in scope: data constructor `Maybe'
17:51:25 <jorgedbucaran> what is Maybe?
17:51:28 <Cale> jorgedbucaran: As a C programmer, you might be familiar with the practice of using NULL pointers to effectively say "this computation didn't work out"
17:51:29 <Trinithis> > Just 45
17:51:30 <lambdabot>  Just 45
17:51:35 <RayNbow> :t Just 45
17:51:38 <lambdabot> forall t. (Num t) => Maybe t
17:51:41 <Cale> jorgedbucaran: right?
17:51:44 <ramza3> > let z = 2 + 3
17:51:45 <jorgedbucaran> yes
17:51:45 <lambdabot>  Parse error at end of input
17:51:58 <Cale> jorgedbucaran: Okay, but what if the thing you're returning isn't a pointer?
17:52:07 <jorgedbucaran> then it does not work
17:52:11 <oerjan> > let z = 2 + 3 in z
17:52:12 <lambdabot>  5
17:52:15 <EvilTerran> jorgedbucaran, Cale just explained. pay attention, and stop repeating questions! especially ones that're already being answered!
17:52:18 <Cale> jorgedbucaran: If it's an int, and -1 doesn't mean anything, you might return -1 to mean failure.
17:52:18 <jorgedbucaran> no way around
17:52:40 <jorgedbucaran> aha
17:52:46 <Cale> jorgedbucaran: But generally, it's pretty difficult and annoying, right?
17:52:53 <jorgedbucaran> indeed
17:52:53 <litb> throw
17:52:59 <byorgey> catch
17:52:59 <Cale> The Maybe type is a solution to that problem.
17:53:18 <oerjan> catchJust isAnnoying
17:53:20 <litb> boost::optional<T>
17:53:25 <jorgedbucaran> what does it does?
17:53:41 <EvilTerran> <Cale> For any type t, the type Maybe t is the type of values such that Nothing :: Maybe t, and if x :: t, then Just x :: Maybe t
17:53:44 <EvilTerran> <Cale> jorgedbucaran: If you want, you could think of it as a list with at most one element ;)
17:53:48 <Cale> jorgedbucaran: Let's write a function that gives the first element of a list.
17:53:53 <EvilTerran> jorgedbucaran, READ what people are SAYING TO YOU
17:54:08 <litb> lolz
17:54:09 <Cale> jorgedbucaran: Of course, if the list is empty, we'll be stuck!
17:54:17 <litb> the Evil:xs is talking
17:54:20 <Cale> jorgedbucaran: So instead of just erroring out
17:54:28 <Cale> jorgedbucaran: We'll use the Maybe type
17:54:42 <EvilTerran> litb, Evil:xs? i am not a list element, i am a free man!
17:54:51 <Cale> When the function succeeds, we'll return the value  (Just x), where x is the head of the list
17:54:53 * oerjan empties a bucket of cold water over EvilTerran 
17:55:00 <davidL> EvilTerran: terran as in terran vs. zerg vs. protoss?
17:55:01 <Cale> when it fails, we'll return the value  Nothing
17:55:08 <jorgedbucaran> foo [] = 0; foo [type] = top([type])
17:55:08 <lispy> EvilTerran: is that anything like a free theorem?
17:55:10 <litb> EvilTerran: free as in free beer or in free speech?
17:55:19 <Cale> foo [] = Nothing
17:55:22 <EvilTerran> davidL, amoung about a gazillion other scifi mythoses, but yeah :)
17:55:23 <Cale> foo (x:xs) = Just x
17:55:34 <ddarius> davidL: Terran as in Irrelevant
17:55:43 <Cale> :t let foo [] = Nothing; foo (x:xs) = Just x in foo
17:55:44 <lambdabot> forall a. [a] -> Maybe a
17:55:55 <Cale> See? The type documents that it might fail.
17:55:57 <EvilTerran> lispy, i'm not sure... i guess if you could extract roff pages from binaries somehow, you could have a free `man`
17:56:05 <davidL> just curious :)
17:56:10 <Cale> It takes a list of a's and gives Maybe a
17:56:19 <EvilTerran> litb, i think speech, in the original context
17:56:26 <Cale> jorgedbucaran: does that make sense?
17:56:28 <EvilTerran> > sort "evilterran" == sort "irrelevant"
17:56:29 <lambdabot>  True
17:56:35 <jorgedbucaran> *processing*
17:56:37 <davidL> oh, haha
17:56:39 <lispy> EvilTerran: haha nice
17:56:46 <ddarius> > sort "evilterran" == sort "evilranter"
17:56:46 <lambdabot>  True
17:56:59 <EvilTerran> > sort "evilterran" == sort "vileranter"
17:57:00 <lambdabot>  True
17:57:07 <davidL> that is clever
17:57:16 <litb> > (\q -> do { (x:xs) <- q; return x; }) [1, 2, 3]
17:57:17 <lambdabot>   add an instance declaration for (Num [t])
17:57:17 <lambdabot>     In the expression: 3
17:57:38 <Botje> @pl \w -> (sort w) == (sort a)
17:57:38 <lambdabot> (sort a ==) . sort
17:57:58 <Botje> huh?
17:58:02 <Botje> that sounds oddly broken.
17:58:10 <Botje> @unpl (sort a ==) . sort
17:58:11 <lambdabot> (\ e -> (sort a) == (sort e))
17:58:13 <byorgey> > sort "evilterran" == sort "ieravltren"
17:58:13 <lambdabot>  True
17:58:17 <byorgey> amazing
17:58:20 <oerjan> litb: 3 becomes the whole x:xs
17:58:20 * Cale is tempted to change his name to GoodZerg
17:58:21 <EvilTerran> byorgey, :P
17:58:21 <ddarius> It's assuming (==) is commutative
17:58:41 <litb> oerjan: hmm
17:58:54 <litb> oerjan: why isn't x 1 and xs [2, 3] ?
17:58:55 <EvilTerran> Botje, (==) `on` sort may also be relevant to your interests
17:59:20 <Botje> I already know one of the parts
17:59:21 <EvilTerran> litb, because (_ :: a) <- (... :: m a) for some monad m
17:59:27 <Botje> bah, i'll just write a lambda
17:59:28 <davidL> > and $ map (`elem` "evilterran") "irrelevant"
17:59:28 <lambdabot>  True
17:59:36 <Botje> my pointless-fu isn't good enough yet :)
17:59:39 <Trinithis> :t elem
17:59:40 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
17:59:41 <chessguy> hiya  haskellers
17:59:45 <Cale> > (do { (x:xs) <- q; return x; }) [1, 2, 3]
17:59:46 <lambdabot>   Not in scope: `q'
17:59:50 <Cale> > (do { (x:xs) <- id; return x; }) [1, 2, 3]
17:59:51 <lambdabot>  1
18:00:03 <Cale> There you go :)
18:00:03 <lispy> > [1..3] >>= return . id
18:00:06 <lambdabot>  [1,2,3]
18:00:33 <EvilTerran> litb, so you're trying to bind each element in the list individually to the pattern (x:xs)
18:00:33 <lispy> i don't really need taht (. id) do i?
18:00:33 <litb> oh darn i forgot that
18:00:38 <lispy> > [1..3] >>= return
18:00:39 <lambdabot>  [1,2,3]
18:00:45 <byorgey> hey chessguy!
18:00:46 <ddarius> @undo do { (x:xs) <- id; return x; }
18:00:46 <lambdabot> id >>= \ a -> case a of { (x : xs) -> return x; _ -> fail ""}
18:00:46 <litb> of course
18:00:47 <Trinithis> 4 `elem`  [1,5]
18:01:00 <litb> > (\q -> do { (x:xs) <- [q]; return x; }) [1, 2, 3]
18:01:01 <lambdabot>  [1]
18:01:04 <litb> :)
18:01:26 <EvilTerran> > do (x:xs) <- tails [1,2,3]; return x
18:01:27 <lambdabot>  [1,2,3]
18:01:30 <litb> oh i see Cale already solved it a better way
18:01:38 <jorgedbucaran> why x:xs?
18:01:44 <EvilTerran> Cale, er, O.o
18:01:51 <jorgedbucaran> I thought : was to add items to lists
18:01:52 <lispy> jorgedbucaran: what would you put?
18:01:53 <Cale> jorgedbucaran: (x:xs) means the list whose first element is x and whose tail is xs
18:02:06 <jorgedbucaran> ohhhh
18:02:07 <EvilTerran> Cale, you're mean! ;)
18:02:12 <lispy> jorgedbucaran: in this case, it's called a pattern match
18:02:20 <jorgedbucaran> omg
18:02:22 <jorgedbucaran> you were kidding
18:02:27 <lispy> the list [1,2,3] matches the pattern (x:xs)
18:02:31 <jorgedbucaran> in this case is something else
18:02:38 <Cale> EvilTerran: huh?
18:02:57 <EvilTerran> "Cale> > (do { (x:xs) <- id; return x; }) [1, 2, 3]"
18:03:01 <Cale> ah
18:03:05 <Cale> heh
18:03:10 <geezusfreeek> yeah i thought that was pretty evil myself
18:03:14 <twanvl> jorgedbucaran: it is not really something else, just the same thing (adding something to a list) in the other direction (taking something from a list)
18:03:18 <litb> > (do { (x:xs) <- id; return x; }) []
18:03:18 <lambdabot>  Exception: Pattern match failure in do expression at <irc>:1:6-11
18:03:19 <chessguy> that's the ((->) r) monad, yes?
18:03:20 <Cale> jorgedbucaran: You're not expected to understand that code... yet :)
18:03:21 <litb> well you fail :D
18:03:28 <lispy> :t do { (x:xs) <- id; return x; }
18:03:29 <lambdabot> forall t. [t] -> t
18:03:30 <litb> > (\q -> do { (x:xs) <- [q]; return x; }) []
18:03:31 <jorgedbucaran> you are right
18:03:31 <lambdabot>  []
18:03:31 <Cale> It was for litb :)
18:03:33 <jorgedbucaran> you guys are great
18:03:38 <jorgedbucaran> even when you are mean
18:03:42 <litb> mine doesn't error out
18:03:43 <jorgedbucaran> I guess that's the point
18:03:49 <jorgedbucaran> urging me to defeat you
18:03:51 <Cale> litb: right :)
18:03:54 <jorgedbucaran> by being mean
18:03:56 <Cale> jorgedbucaran: hehe
18:04:00 <jorgedbucaran> Ill go read yaht
18:04:01 <litb> but then, mine doesn't return the first element hehe
18:04:05 <jorgedbucaran> parts of it
18:04:07 <jorgedbucaran> and come back
18:04:12 <Cale> jorgedbucaran: hehe, all right :)
18:04:27 <jorgedbucaran> dude and you stay around every day?
18:04:29 <lispy> I know how/why the list monads works the way it does, but sometimes the concrete examples still throw me for a loop
18:04:33 <jorgedbucaran> I mean *generally*
18:04:35 <Cale> jorgedbucaran: For the most part.
18:04:39 <jorgedbucaran> wow
18:04:45 <jorgedbucaran> so everyone here is like friends
18:04:47 <jorgedbucaran> hahaha
18:04:51 <jorgedbucaran> this is so cool.
18:04:53 <Cale> jorgedbucaran: If I have nothing better to do, I'll mostly hang around here.
18:04:54 <Trinithis> jorgedbucaran... when you get to monads, I found this useful: http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
18:04:55 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
18:05:05 <jorgedbucaran> thanks
18:05:15 <Cale> Obviously, I recommend my own tutorials for monads as well :)
18:05:18 <jorgedbucaran> you gave me some inspiration to get started
18:05:19 <lispy> monads-shmonads.
18:05:22 <jorgedbucaran> haha sure you do
18:05:25 <jorgedbucaran> roger
18:05:31 <geezusfreeek> monads are fun
18:05:36 <geezusfreeek> they're funtastic
18:05:36 * ddarius recommends Wadler's original papers.
18:06:03 <litb> > (\q -> do { (x:xs) <- Just q; return x; }) [1, 2, 4]
18:06:04 <lambdabot>  Just 1
18:06:08 <litb> > (\q -> do { (x:xs) <- Just q; return x; }) []
18:06:09 <lambdabot>  Nothing
18:06:17 <litb> yeah :)
18:06:20 <lispy> monads are cool, but monad transformers + automatic deriving is where it's at
18:06:48 <lispy> ie, you get custom monads almost for free
18:07:04 <Trinithis> ?
18:07:24 <oerjan> @. pl undo do (x:xs) <- return q; return x
18:07:25 <lambdabot> (line 1, column 31):
18:07:25 <lambdabot> unexpected "{"
18:07:25 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<" or end of input
18:07:39 <oerjan> @undo do (x:xs) <- return q; return x
18:07:39 <lambdabot> return q >>= \ a -> case a of { (x : xs) -> return x; _ -> fail ""}
18:07:57 <EvilTerran> lispy, hooray for language extensions!
18:08:09 <litb> fail of Maybe returns Nothing
18:08:19 <lispy> EvilTerran: yes, i rarely program in Haskell without them.  For me, it's GHC or nothing.
18:08:28 <lispy> > fail "" :: Maybe Int
18:08:29 <lambdabot>  Nothing
18:08:41 <ddarius> @src Maybe fail
18:08:41 <lambdabot> fail _      = Nothing
18:08:52 <oerjan> litb: i thought for a moment you were doing something that could be simplified
18:09:01 <chessguy> > fail "" :: Maybe (Int, Int, Int, Int, Int)
18:09:02 <lambdabot>  Nothing
18:09:05 <litb> =)
18:09:09 <lispy> :t maybe
18:09:10 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:09:10 <ddarius> listToMaybe
18:09:16 <chessguy> much tupling about Nothing :)
18:09:21 <ddarius> > (listToMaybe [1,2,3],listToMaybe [])
18:09:21 <lambdabot>  (Just 1,Nothing)
18:09:33 <EvilTerran> lessee... monad transformers is MPTCs, FunDeps, OverlappingInstances...
18:09:34 <Trinithis> :t listToMaybe
18:09:34 <lambdabot> forall a. [a] -> Maybe a
18:09:39 <EvilTerran> UndecidableInstances too? i'm not sure
18:09:50 <litb> oerjan: well by that i think the recursive one of first is way simplier, but not as elegant imho
18:09:56 <ddarius> Only the MonadReader and co. type classes require any of that.
18:10:03 <Trinithis> @src listToMaybe
18:10:03 <lambdabot> listToMaybe []        =  Nothing
18:10:03 <lambdabot> listToMaybe (a:_)     =  Just a
18:10:14 <ddarius> It shouldn't need either Overlapping or Undecidable Instances.
18:10:30 <lispy> listToMaybe is a weird thing to find in the standard libraries, what was the motivation for including it?
18:10:33 <EvilTerran> ddarius, okay, not monad transformers themselves, but the automatic lifting does need all that
18:10:38 <EvilTerran> (not undecidable, but the others)
18:10:46 <EvilTerran> lispy, because head is partial
18:10:55 <ddarius> lispy: It's pretty convenient.
18:11:10 <litb> not to mention that it's a even more weird name
18:11:12 <lispy> also, I would say that it has a poorly choosen name
18:11:15 <ddarius> It's also a fairly natural monad morphism from [] to Maybe.
18:11:25 <EvilTerran> altho i'd've called it headM :: Monad/MonadPlus m => [a] -> m a
18:11:30 <EvilTerran> and had tailM likewise
18:11:38 <lispy> > tail []
18:11:39 <lambdabot>  Exception: Prelude.tail: empty list
18:11:44 <Trinithis> alirght, thx for the help. I gtg
18:12:40 <oerjan> > runReaderT (do (x:xs) <- ask; lift (Just x)) [1,2,3]
18:12:41 <lambdabot>  Just 1
18:13:00 * oerjan cackles evilly
18:13:03 <EvilTerran> hehe
18:15:18 <lispy> :t (do (x:xs) <- ask; lift (Just x))
18:15:19 <lambdabot> forall t (t1 :: (* -> *) -> * -> *). (MonadTrans t1, MonadReader [t] (t1 Maybe)) => t1 Maybe t
18:15:33 <nornagon> > runReaderT (do x:xs <- ask; lift (Just xs)) [1,2,3]
18:15:34 <lambdabot>  Just [2,3]
18:15:42 <oerjan> lift (Just x) = return x btw, it's just to fix the type
18:16:36 <davidL> > Data.Set.fromList [1,1,1,1,1,2]
18:16:37 <lambdabot>  fromList [1,2]
18:16:38 <ddarius> #haskell: Where You See How Not To Write Haskell
18:16:42 <litb> @type liftM
18:16:43 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:16:43 * EvilTerran would quite like eitherToMaybe and maybeToEither, too
18:16:54 <EvilTerran> @go site:hpaste.org "i'm an imperative programmer"
18:16:58 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
18:17:02 <litb> ugg, how does (Just x) fit a1 -> r ?
18:17:05 <ddarius> What would maybeToEither do?
18:17:19 <EvilTerran> http://hpaste.org/2654
18:17:24 <litb> ah
18:17:26 <litb> @type lift
18:17:27 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
18:17:37 <litb> don't know lift yet
18:17:37 <EvilTerran> ddarius, :: a -> Maybe b -> Either a b, i guess?
18:17:50 <EvilTerran> that one's less useful, tbh
18:19:23 <ddarius> > foldr (const . Just) Nothing [1,2,3]
18:19:24 <lambdabot>  Just 1
18:19:38 <geezusfreeek> @djinn a -> Maybe b -> Either a b
18:19:38 <lambdabot> f a b =
18:19:38 <lambdabot>     case b of
18:19:38 <lambdabot>     Nothing -> Left a
18:19:38 <lambdabot>     Just c -> Right c
18:22:45 <oerjan> :t (.Right).maybe.Left
18:22:46 <lambdabot>     Couldn't match expected type `Either a1 a'
18:22:46 <lambdabot>            against inferred type `a2 -> Either a3 b'
18:22:46 <lambdabot>     Probable cause: `.' is applied to too few arguments
18:22:59 <oerjan> er
18:23:51 <oerjan> :t maybe.Left
18:23:52 <lambdabot> forall a a1 b. a1 -> (a -> Either a1 b) -> Maybe a -> Either a1 b
18:23:59 <ddarius> :t fromMaybe
18:24:00 <lambdabot> forall a. a -> Maybe a -> a
18:24:21 <byorgey> @remember ddarius #haskell: Where You See How Not To Write Haskell
18:24:21 <lambdabot> It is stored.
18:24:24 <oerjan> hmmm
18:24:42 <oerjan> :t ($Right).maybe.Left
18:24:43 <lambdabot> forall a b. a -> Maybe b -> Either a b
18:24:57 <oerjan> :t (.Right).fromMaybe.Left
18:24:58 <lambdabot>     Couldn't match expected type `Either a1 a'
18:24:58 <lambdabot>            against inferred type `Maybe (Either a2 b)'
18:24:58 <lambdabot>       Expected type: a2 -> Either a1 a -> c
18:25:32 <oerjan> :t (.fmap Right).fromMaybe.Left
18:25:33 <lambdabot> forall a b. a -> Maybe b -> Either a b
18:25:34 <geezusfreeek> @unpl ($Right).maybe.Left
18:25:34 <lambdabot> (\ d -> maybe ((Left) d) (Right))
18:25:50 <geezusfreeek> wow that certainly helped a lot
18:25:51 <ddarius> If only Cont wasn't a newtype wrapper.
18:26:53 <oerjan> :t either (const Nothing) Just
18:26:54 <lambdabot> forall a b. Either a b -> Maybe b
18:26:58 <EvilTerran> ddarius, what'd that allow?
18:27:22 <ddarius> ($ Right) to be (return return)
18:27:43 <EvilTerran> it would?
18:27:46 <Botje> @pl \x -> snd $ fromJust $ lookup x l
18:27:46 <lambdabot> snd . fromJust . flip lookup l
18:27:51 <ddarius> @src Cont return
18:27:51 <lambdabot> return a = Cont ($ a)
18:27:58 <EvilTerran> oh, i se
18:28:02 <oerjan> @src (->) local
18:28:02 <lambdabot> local f m = m . f
18:28:05 <EvilTerran> as compared to a type alias
18:28:15 <EvilTerran> i thought you meant as compared to a data decleration
18:28:17 <EvilTerran> :P
18:28:22 <EvilTerran> @src Cont
18:28:23 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
18:30:49 <EvilTerran> ?hoogle writeIOref
18:30:50 <lambdabot> Data.IORef.writeIORef :: IORef a -> a -> IO ()
18:32:26 <EvilTerran> @let while p x = p >>= when >> x >> while p x
18:32:29 <lambdabot> Defined.
18:33:23 <oerjan> > [while, ()]
18:33:24 <lambdabot>  Couldn't match expected type `(m () -> Bool)
18:33:42 <EvilTerran> wait, i've done that wrong
18:33:45 <EvilTerran> @undef
18:33:46 <lambdabot> Undefined.
18:34:14 <EvilTerran> @let while p x = p >>= flip when (x >> while p x)
18:34:15 <lambdabot> Defined.
18:35:11 <oerjan> @pl while p x = p >>= flip when (x >> while p x)
18:35:12 <lambdabot> while = fix (liftM2 (.) (>>=) . (((flip when .) . ap (>>)) .))
18:35:29 <oerjan> @pl z = p >>= flip when (x >> z)
18:35:30 <lambdabot> z = fix ((p >>=) . flip when . (x >>))
18:35:51 <EvilTerran> > runState (while (not.null.fst<$>get) (modify $ \((x:l),r) -> (l,x:r))) ([1,2,3,4],[])
18:35:54 <lambdabot>  ((),([],[4,3,2,1]))
18:36:22 <EvilTerran> ?type when =<< ?p
18:36:23 <lambdabot> forall (m :: * -> *). (Monad m, ?p::m () -> Bool) => m () -> m ()
18:36:57 <EvilTerran> ?type fix \while p x -> (when =<< p) (x >> while p x)
18:36:58 <lambdabot> parse error on input `\'
18:37:01 <EvilTerran> ?type fix $\while p x -> (when =<< p) (x >> while p x)
18:37:02 <lambdabot> Parse error in pattern
18:37:07 <EvilTerran> ?type fix $ \while p x -> (when =<< p) (x >> while p x)
18:37:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => (m () -> Bool) -> m a -> m ()
18:38:34 <litb> @src while
18:38:34 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
18:38:43 <EvilTerran> ?type fix$ \while -> ($) <$> (when =<<) <*> ((>>) =<<) . while
18:38:44 <lambdabot>     Couldn't match expected type `()' against inferred type `m b'
18:38:44 <lambdabot>       Expected type: ((m b -> ()) -> Bool) -> m b -> ()
18:38:44 <lambdabot>       Inferred type: ((m b -> ()) -> Bool) -> m b -> m b
18:38:54 <EvilTerran> whups
18:39:26 <EvilTerran> ?type fix$ \while p -> (when =<< p) . ((>>) =<< while p)
18:39:27 <lambdabot> forall (m :: * -> *). (Monad m) => (m () -> Bool) -> m () -> m ()
18:41:16 <oerjan> :t fix $ \while -> liftM2 (.) (when =<<) (((>>)=<<).while)
18:41:17 <lambdabot> forall (m :: * -> *). (Monad m) => (m () -> Bool) -> m () -> m ()
18:41:24 <EvilTerran> curses, beaten to the punch
18:41:37 <oerjan> same answer? :)
18:41:52 <EvilTerran> ?type fix $ \while -> (.) <$> (when =<<) <*> ((>>)=<<).while
18:41:53 <lambdabot> forall (m :: * -> *). (Monad m) => (m () -> Bool) -> m () -> m ()
18:41:59 <EvilTerran> much the same, yeah :)
18:42:39 <EvilTerran> ?type fix $ ((.) <$> (when =<<) <*>) . (((>>)=<<).)
18:42:40 <lambdabot> forall (m :: * -> *). (Monad m) => (m () -> Bool) -> m () -> m ()
18:42:45 <EvilTerran> hah!
18:42:59 * EvilTerran is more pointless than thou
18:43:58 <oerjan> :t fix $ liftM2 (.) (when =<<) . (((>>)=<<).)
18:43:59 <lambdabot> forall (m :: * -> *). (Monad m) => (m () -> Bool) -> m () -> m ()
18:44:17 * oerjan is shorter than thou
18:45:10 <Japsu> your pointlessness is overflowing
18:45:11 <EvilTerran> ?type not.null `liftM` get
18:45:12 <lambdabot>     precedence parsing error
18:45:13 <lambdabot>         cannot mix `(.)' [infixr 9] and `liftM' [infixl 9] in the same infix expression
18:45:16 <EvilTerran> -.-
18:45:36 <ddarius> Yeah, EvilTerran, what were you thinking?
18:46:04 <EvilTerran> ?type not.null <$> get
18:46:04 <lambdabot> forall a (f :: * -> *). (MonadState [a] f, Functor f) => f Bool
18:48:15 <oerjan> :t ((>>)=<<)
18:48:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m b -> m a) -> m b -> m b
18:48:29 <ehird> doo be
18:48:45 <ehird> what are the minimum primitives neccessary for turing-complete point-freeity?
18:48:58 <ddarius> ehird: There isn't a unique set.
18:49:02 <oerjan> ap, const, fix
18:49:11 <ddarius> X
18:49:12 <ehird> ddarius: well, yeah
18:49:15 <ehird> i meant one permutation :-)
18:49:29 <ehird> oerjan: aww, fix is SO cheating! :-)
18:49:30 <ddarius> @google one combinator basis fokker
18:49:30 <oerjan> ddarius: typeable ones?
18:49:31 <lambdabot> http://citeseer.ist.psu.edu/538202.html
18:49:31 <lambdabot> Title: The Systematic Construction of a One-Combinator Basis (ResearchIndex)
18:49:40 <ehird> ddarius: the iota combinator too
18:49:43 <ehird> \x. xSK
18:49:45 <ehird> but that's not the point
18:49:47 <oerjan> ehird: you need fix if you want typeability
18:49:55 <ehird> oerjan: bah, to hell with types
18:50:13 <oerjan> otherwise, ap and const are S and K
18:50:41 <oerjan> @unpl ((>>)=<<)
18:50:41 <lambdabot> (\ a -> a >>= (>>))
18:53:12 <litb> @src when
18:53:12 <lambdabot> when p s = if p then s else return ()
18:54:44 <ehird> @src until
18:54:44 <lambdabot> until p f x | p x       = x
18:54:44 <lambdabot>             | otherwise = until p f (f x)
18:54:54 <ehird> it's random @src day
18:55:02 <oerjan> :t \a x -> a x >> x
18:55:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m b -> m a) -> m b -> m b
18:55:12 <ehird> actually personally i think that definition of until is kind of weird
18:55:19 <ehird> but eh
18:55:27 <ddarius> ehird: Why?
18:55:27 <ehird> it'd be nicer monadic
18:55:58 * oerjan guesses until is an ancient function from before monads
18:56:10 <ehird> until x y = if x then return () else y >> until x y
18:56:13 <ehird> hmm
18:56:21 <ehird> you'd need to do something to keep the laziness
18:56:23 <ehird> if i read that right
18:56:37 <ddarius> That would never terminate or it would immediately terminate.
18:56:50 <ddarius> (excepting mzero where that makes sense)
18:56:53 <Cale> It's a good thing that you need to add fix specifically when you add types. If not, then combinator calculi wouldn't quite serve their other purposes for logic.
18:57:05 <hpaste>  blbrown pasted "associate file content with filename" at http://hpaste.org/5254
18:57:08 <ehird> ddarius: well, yeah, exactly
18:57:09 <ehird> wait
18:57:11 <ehird> should be
18:57:23 <Cale> It also opens up the possibility of including more restrictive forms of recursion without the full thing.
18:57:39 <ehird> until x y = do res <- x; if x then return () else do y; until x y
18:57:44 <ddarius> Cale: That would probably be why they were what Curry discovered...
18:57:47 <ehird> which doesn't work properly either
18:57:53 <ehird> you'd need to do some weird lazy magic
18:57:54 <ehird> but still
18:58:16 <ddarius> ehird: That function wouldn't be very handy.
18:58:25 <ehird> ddarius: eh, it might be
18:58:28 <ehird> ah
18:58:31 <ehird> this might be more useful:
18:58:32 <ddarius> Only in a monad supporting state would it be useful.
18:58:37 <EvilTerran> ddarius, well, it's kinda like that "while" i had above
18:59:02 <blbrown> http://hpaste.org/5254  how would I get that to work, I think I need to rebuild the list as a tuple of data somehow
18:59:05 <ehird> until x y = do res <- x; if res then return () else do foo <- y res; until x y
18:59:07 <ehird> but you're right
18:59:12 <ehird> it needs a bit of rethinking
18:59:31 <EvilTerran> while p x = p >>= flip when (x >> while p x)
18:59:36 <litb> > until (==0) (+(-1)) 10
18:59:40 <lambdabot>  0
19:00:03 <ehird> um
19:00:08 <ehird> (+(-1)) -> (1-)
19:00:11 <litb> until is std haskell ?
19:00:18 <EvilTerran> while p x = do p' <- p; if p then (do x; while p x) else return ()
19:00:18 <ddarius> @hoogle until
19:00:18 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
19:00:22 <EvilTerran> ehird, no it isn't...
19:00:26 <ehird> EvilTerran: oh
19:00:26 <ehird> duh
19:00:29 <EvilTerran> > (1-) 2
19:00:30 <lambdabot>  -1
19:00:35 <EvilTerran> > (+(-1)) 2
19:00:36 <lambdabot>  1
19:00:40 <ehird> EvilTerran: right
19:00:41 <hpaste>  oerjan annotated "associate file content with filename" with "thus" at http://hpaste.org/5254#a1
19:00:46 <EvilTerran> > (-1+) 2
19:00:47 <lambdabot>  1
19:00:50 <ehird> until p x = while (not p) x
19:00:55 <oerjan> blbrown: see my annotation
19:01:03 <ddarius> EvilTerran: And your while is only useful (in a direct way) for a monad supporting something like state.
19:01:13 <EvilTerran> ddarius, i know that full well
19:01:29 <litb> @hoogle while
19:01:29 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
19:01:29 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
19:01:29 <lambdabot> Data.List.takeWhile :: (a -> Bool) -> [a] -> [a]
19:01:41 <EvilTerran> ddarius, it only came to me as something to try to implement when looking at that "no, i'm an imperative programmer" paste
19:01:48 <EvilTerran> so i'm not surprised it's not that useful :P
19:02:57 <EvilTerran> while p i x = p x >>= flip when (f x >>= while p i) -- might be more useful
19:03:02 <EvilTerran> @undef
19:03:03 <lambdabot> Undefined.
19:03:06 <EvilTerran> @let while p i x = p x >>= flip when (f x >>= while p i)
19:03:07 <lambdabot> <local>:1:33: Not in scope: `f'
19:03:14 <EvilTerran> @let while p f x = p x >>= flip when (f x >>= while p i)
19:03:14 <lambdabot> <local>:1:49: Not in scope: `i'
19:03:17 <EvilTerran> @let while p f x = p x >>= flip when (f x >>= while p f)
19:03:18 <lambdabot> Defined.
19:03:21 <EvilTerran> @type while
19:03:23 <lambdabot> Not in scope: `while'
19:03:39 <EvilTerran> @type fix $ \while p f x -> p x >>= flip when (f x >>= while p f)
19:03:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m Bool) -> (a -> m a) -> a -> m ()
19:06:16 <EvilTerran> altho it'd be better to call that whileM
19:06:24 <EvilTerran> or maybe re-arrange it into untilM
19:08:06 <ehird> so where's the Good haskell mode?
19:08:08 <ehird> I have the Crappy one
19:08:19 <Valodim> ?
19:08:35 <ehird> Valodim: beats me, but i've used emacs on loads of machines and carbon emacs does.. not have haskell-mode
19:08:39 <ehird> it has something claiming to be it
19:08:42 <ehird> but it sucks, and isn't it
19:09:01 <Valodim> ah, in emacs
19:09:11 <Valodim> didn't see that context :)
19:12:18 <ddarius> http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs perhaps?
19:12:18 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki
19:13:44 <chessguy> that's the one i use. it's not bad
19:13:59 <chessguy> not that i'm writing much haskell code these days :(
19:14:28 * ddarius just uses the Haskell syntax highlighting files that came with vim.
19:15:12 <chessguy> ewww, vim
19:16:24 <ddarius> chessguy: The outdated version of xmonad I use (xmonad version 3 or so) is too featureful for my tastes.
19:16:43 <chessguy> um...ok
19:17:03 <ehird> chessguy: what's wrong with vim? :/
19:17:41 <chessguy> nothing, but as an emacs user i have to trash vim at any free chance i get :)
19:19:23 <chessguy> it's an unwritten law
19:19:24 <ehird> bah :)
19:19:26 <ehird> i use both!
19:19:33 <ehird> i also use multiple OSs
19:19:34 <chessguy> oh really? that's unusual
19:19:38 <ehird> i am immune to holy wars
19:19:56 <meryrus> No one is immune to holy wars.
19:19:57 <ehird> unless they're the literal kind of holy wars i guess
19:20:03 <ddarius> Unless it affects me, I just don't care what other people use.
19:20:14 <ehird> kind of hard to be an atheist *and* religious
19:20:15 <ehird> :D
19:20:20 * ddarius kills ehird in the name of Jeebus.
19:20:23 <chessguy> ehird, do you choose between the two based on the task at hand, or just your mood?
19:20:34 <chessguy> (vim and emacs, that is)
19:20:39 <sclv> i always screw up keybindings when switching between editors and oses
19:20:56 <ddarius> "I'm in the mood to edit text today and not play around with configuration files..."
19:21:02 * sclv hates ctrl-S = XOFF
19:21:13 * chessguy rarely plays with his .emacs file
19:23:09 * Tac-Tics would like emacs, but the way it handles tabs is completely retarded
19:23:30 <Tac-Tics> *but I use it anyway, because I like everything else about t
19:23:46 <ehird> damn, haskell-mode is much better than fake-imitation-haskell-mode
19:23:46 <ehird> :D
19:23:54 <jcreigh> huh?
19:24:03 <ehird> chessguy: well, i wouldn't write a whole haskell app in vim :)
19:24:07 <Tac-Tics> where does one acquire real haskell mode?
19:24:08 <oerjan> hm, http://en.wikipedia.org/wiki/Haskell_class_attack_transport
19:24:09 <lambdabot> Title: Haskell class attack transport - Wikipedia, the free encyclopedia
19:24:11 <ehird> but mainly it just depends whether i'm in the terminal or not
19:24:12 <ehird> :|
19:24:16 <oerjan> (currently on main page)
19:24:24 <gwern> what is the difference between the OPTIONS and GHC_OPTIONS pragmas?
19:24:35 <chessguy> nice oerjan
19:25:06 <ehird> of course the only REAL editor is acme! or maybe sam
19:25:09 <monochrom> Why is emacs retarded about tabs? From what I know you can make it do whatever you want about tabs. Unless "whatever you want" is the retarded part.
19:25:11 <gwern> oerjan: "Can Haskell transport 1500 of my troops to obliterate mine enemies?"
19:25:29 <chessguy> i wonder if it transports troops lazily
19:25:33 <jcreigh> ?faq
19:25:33 <lambdabot> The answer is: Yes! Haskell can do that.
19:25:53 <ehird> hahahah
19:26:01 <gwern> (thank you jcreigh. I was hoping someone would catch my drift)
19:26:07 <ehird> monochrom: because it's retarded about tabs by default
19:26:18 <monochrom> Default doesn't count, IMO.
19:26:21 <chessguy> hm, tabs work really well for me
19:26:32 <chessguy> oh, but not so good in haskell-mode
19:26:33 <ehird> i just indent using spaces
19:26:34 <ehird> :|
19:26:35 <chessguy> if that's what you mean
19:26:37 <ehird> however
19:26:41 <ehird> theoretically tabs are infinitely better
19:27:03 <oerjan> no, at most 8 times better :D
19:27:08 <ehird> because they don't embed esthetic garbage into the source code and instead keep it semantic. But editors decided that "tab = space * x" and the whole world fscked them up!
19:27:10 <ddarius> gwern: OPTIONS_GHC you mean?  There isn't for GHC, but OPTIONS might be interpreted by a different implementation at which point it will probably fail.
19:27:14 <ehird> so now nobody can sanely use tabs
19:27:19 <ehird> so we're all stuck with spaces
19:27:21 <ehird> thank you humanity
19:27:31 <EvilTerran> in theory, theory and practice are the same. in practice, not so much
19:27:41 <Tac-Tics> the problem is spaces and tabs look the same in every editor
19:27:53 <Tac-Tics> and emacs likes to mix them together, thinking they're the same
19:27:57 <gwern> ddarius: ah
19:28:01 <Saizan> i hate the completion for paths.. i'd like it to cycle through existing files (like irssi with nicks) rather then blocking on common prefixes
19:28:01 <mauke> :set list
19:28:19 <Tac-Tics> but when you are scrolling over them with C-b and C-f, you suddenly skip by 4 and 8 lines at a time every once in a while
19:29:01 <monochrom> Alright I see, you mean the tab character U+0009, not the tab key.
19:29:22 <sclv> @quote editor
19:29:23 <lambdabot> bakert says: [On text editors] The best plan is to install them all and switch between them typing one line at a time in each until you know which is best for you.  Usually it can be decided within
19:29:23 <lambdabot> a few months.
19:29:37 <ehird> question: how does lambdabot define `instance Show (a -> b)`?
19:29:40 <oerjan> ooh, good plan
19:29:53 <oerjan> ehird: using Typeable probably
19:29:58 <ddarius> ehird: It doesn't.
19:29:58 <Tac-Tics> > id :: Int -> Int
19:29:58 <ehird> oerjan: hm
19:30:00 <lambdabot>  <Int -> Int>
19:30:01 <EvilTerran> instance Typeable a, Typeable b => Show (a -> b), ISTR
19:30:10 <ddarius> It defines what EvilTerran said.
19:30:19 <ehird> yes, but i mean the actual body
19:30:20 <ehird> :)
19:30:27 <ddarius> @src Typeable
19:30:28 <lambdabot> Source not found. I feel much better now.
19:30:34 <ddarius> @version
19:30:34 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
19:30:35 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:30:39 <ddarius> Have at it.
19:30:43 <ehird> yep
19:30:44 <ehird> trying to find it
19:30:45 <ehird> hehehe
19:30:48 <EvilTerran> show f = show (typeOf f), possibly
19:30:58 <ddarius> I believe it's in a module by itself.
19:31:24 <oerjan> > printf "<%s -> %s>" (typeOf 1) (typeOf 1.0) :: String
19:31:25 <lambdabot>   add an instance declaration for (PrintfArg TypeRep)
19:31:25 <lambdabot>     In the expression: ...
19:31:40 <oerjan> > printf "<%s -> %s>" (show (typeOf 1)) (show (typeOf 1.0)) :: String
19:32:00 <oerjan> ?
19:32:02 <oerjan> @bot
19:32:11 <oerjan> oh dear
19:32:45 <ehird> EvilTerran: that is SO cheating
19:32:45 <ehird> :)
19:32:45 <ehird> i expected black magic
19:32:45 <monochrom> No one is cheating.
19:32:46 <lambdabot> :)
19:32:47 <lambdabot>  "<Integer -> Double>"
19:33:06 <ehird> lambdabot is amused at your worry
19:33:16 <EvilTerran> > typeOf
19:33:16 <lambdabot>  Add a type signature
19:33:32 <EvilTerran> > show . typeOf (undefined :: Int -> Bool)
19:33:33 <lambdabot>  Couldn't match expected type `a -> b'
19:33:41 <EvilTerran> ?type typeOf
19:33:42 <lambdabot> forall a. (Typeable a) => a -> TypeRep
19:33:46 <EvilTerran> > show $ typeOf (undefined :: Int -> Bool)
19:33:47 <lambdabot>  "Int -> Bool"
19:34:14 <EvilTerran> ("<"++).(++">").show.typeOf it is :D
19:34:37 <ehird> hm, is there any way to define a data/type/whatever in ghci :|
19:34:41 <ehird> that's been bugging me for forever
19:34:47 <monochrom> No.
19:34:50 <ehird> !
19:35:06 <EvilTerran> well, ('<':).(`shows`">").typeOf would be better
19:35:09 <monochrom> Perhaps ghc 60.80.20 will have it.
19:35:25 <ehird> ghc 564564564.4358712.2
19:35:41 <EvilTerran> is GHC not tending towards a limit, then?
19:35:47 <EvilTerran> *finite limit
19:36:01 <monochrom> The sky is the limit.
19:36:10 <gwern> I say have it tend to a limit of Omega
19:36:13 <jcreigh> what, exactly, is the value of the sky?
19:36:23 <monochrom> Omega. :)
19:36:27 <ehird> ghc tends to some busy beaver value
19:36:31 <ehird> > coerce (Bar 97 :: Foo) :: Boo
19:36:31 <ehird> Quux 'a'
19:36:31 <lambdabot>   Not in scope: type constructor or class `Boo'
19:36:32 <oerjan> EvilTerran: will reach infinite cardinality some time next autumn
19:36:33 <ehird> :D
19:36:43 <EvilTerran> actually, i guess it can safely tend to infinity, as the version number's only forced further by evaluating more features
19:36:44 <gwern> jcreigh: go ask a Fper. they know the value of everything, and the cost of nothing, after all...
19:36:48 <EvilTerran> laziness ftw :D
19:36:56 <monochrom> Hahahaha
19:37:04 <ehird> ghcVersion = 1 : ghcVersion
19:37:16 <davidL> the upper limit is graham's number
19:37:47 <ehird> fibonacci numbers versioning!
19:38:04 <ehird> start off 0.1, 0.1 though you might have some troubles there.
19:38:21 <ehird> 'so, exactly *which* 0.1 are you referring to?'
19:38:32 <ehird> 'the first or the second?'
19:39:04 <monochrom> Even LOTR had two 1st editions. One in UK, one in US. And they did differ.
19:39:23 <ehird> incidentally, you never get to say 'YAY 1.0'
19:39:25 <ehird> :D
19:39:34 <ehird> also, you tend to skip a lot of version numbers..
19:39:52 <ehird> "258.4 will be followed by 418.1 in December."
19:40:10 <ehird> the version numbers get a bit confusing 7502.5 onwards
19:40:23 <monochrom> Certain modern printings of LOTR has a brief history of the text revisions. I read it and I was like "OMG what a version control mess". :)
19:40:31 <gwern> worse than emacs even
19:40:50 <ehird> monochrom: darcs ci -am 'update hobbits'
19:41:44 <ehird> pi versioning system! every pi versions, you add another digit of pi
19:41:45 <EvilTerran> hehe
19:42:00 <davidL> that's what TeX uses
19:42:03 <EvilTerran> ehird, i hope you're working in base pi
19:42:08 <ehird> davidL: not every pi versions!
19:42:19 <gwern> ehird: imagine. it's like an unary numbering system with a bunch of meaningless symbols
19:42:35 <ehird> busy beaver versioning system. you release 'when it's ready', which is code for 'when the next value of the sequence is worked out'
19:42:39 <gwern> 'version 3? ok, so that'd be revision 3.14...'
19:42:50 <monochrom> Tolkien would once in a while send patches to the UK publisher, but not the US publisher. Next he would send an independent patch to the US publisher, but not the UK publisher. Then he would lose his own patches. It caused many branchings until eventually someone computerized it all and merged them.
19:43:28 <ehird> monochrom: tolkien the theory of patches
19:43:30 <ehird> err
19:43:33 <ehird> monochrom: tolkien broke the theory of patches
19:43:41 <monochrom> Lord of The Revisions. :)
19:43:52 <ehird> tolkien probably used rcs. :P
19:43:56 <gwern> ehird: no, tolkien's theory of patches was 'Meh. Let Chris sort it all out.'
19:44:00 <jcreigh> but the theory-that-was-broken can be reforged!
19:44:16 <EvilTerran> the One Ring was actually a circular dependency
19:44:20 <monochrom> "One Revision to confound them all"? :)
19:44:27 <ehird> gwern: eventually chris changed himself into 'alias chris "darcs merge"'
19:44:42 <ehird> turns out darcs isn't quite advanced enough
19:44:53 * ddarius has a desire to write self-modifying shell scripts now.
19:47:19 <Nafai> ddarius: Scary!
19:49:45 <sjanssen> darcs obliterate --matches=ONE_RING
19:50:26 <Saizan> sjanssen: hah! it was that simple!
19:50:59 <monochrom> "One Repo for the Darcs Lord"...
19:51:05 <sjanssen> lol
19:51:37 <sjanssen> In _darcs where the patches lie
19:51:54 <monochrom> hahahaha this is great
19:53:04 <ehird> One repository to rule them all, One repository to find them, One repository to bring them all and in the darkness merge them.
19:53:13 <ehird> **in the shell
19:55:56 <ehird> Either that was so awesome that you all died or that was incredibly crappy
19:56:27 <monochrom> I'm thinking a more complete, more mutated version.
19:57:35 <ehird> mm
19:59:57 <monochrom> Something like: One repo to release them all, One repo to hold them, One repo to commute them all and in the darcness merge them.
20:00:43 <ehird> darcness is kinda lame
20:00:53 <monochrom> Yeah that one is optional.
20:01:00 <sjanssen> I'd go with darcsness
20:01:06 <ehird> shell!
20:01:10 <ehird> or emacs
20:01:14 <ehird> and in the emacs merge them
20:01:34 * ddarius doesn't use emacs.
20:01:56 <ehird> well, you're lame.
20:01:56 <ehird> so.
20:02:02 <ehird> :P
20:03:01 <gwern> I would suggest 'in the yi merge them', but that doesn't scan
20:03:43 <lament> down with emacs!!!
20:04:01 <phobes> These are all references to "Legally Blonde 2", right?
20:04:53 <gwern> lament: emacs is the worst editor around, except for all the others that get tried from time to time
20:05:14 <phobes> gwern: You're half right :)
20:06:23 <gwern> crud. now I need to read up on the ReaderT monad.
20:06:30 * gwern is not very familiar with monads besides IO
20:06:57 <Tac-Tics> heh
20:07:08 <Tac-Tics> The first time I saw Yi's code, I thought the same thing
20:07:44 <Tac-Tics> EditorM for the editor, YiM for useractions, BufferM for buffer actions
20:07:48 <gwern> do you still think't?
20:07:55 <Tac-Tics> and weird parser crap for the input
20:08:01 <monochrom> ReaderT is nice. You will be delighted.
20:08:16 <Tac-Tics> ReaderT is just the "config file" monad, isn't it?
20:08:38 <gwern> monochrom: sure, but that's all the rest i have to deal with: type SelectionDataM a = ReaderT (Ptr ()) IO a
20:08:46 <gwern> *what's
20:09:44 <lament> gwern: i'm trying to start a yi vs emacs flamewar :)
20:10:29 <gwern> lament: don't. the former would just lose on every ground currently
20:10:39 <monochrom> Yi is the best editor.
20:10:43 <lament> it has a cooler name!
20:10:52 <sclv> Ed is the standard editor!
20:10:53 <monochrom> Emacs is the best editor I've used.
20:10:53 <gwern> memory usage, ease of use, stability, features... I think the only metric yi wins on is having a smaller code-base...
20:10:54 <Cin> how do you pronnounce ``yi''?
20:11:02 * monochrom plays Risk with himself.
20:11:04 <gwern> Cin: yee, of course
20:11:08 <Tac-Tics> yih?
20:11:09 <Tac-Tics> heh
20:11:11 <gwern> Y-I is just silly
20:11:13 <lament> rise all yi faithful
20:11:17 * sclv feels ashamed at meme propagation.
20:11:22 <gwern> although if it's derived from vi... hum
20:11:32 <oerjan> monochrom: the Y in your name doesn't happen to stand for Yi does it? :D
20:11:36 * Cin eyes sclv suspiciously
20:11:37 <monochrom> yi-macs mode? :)
20:11:47 <gwern> sclv: ed will not corrupt your precious memes!
20:11:50 <lament> doesn't 'vi' stand for 'visual'? Why would it be pronounced vee eye?
20:11:52 <monochrom> No, it stands for Yu.
20:12:01 <Tac-Tics> the YiM monad also confused the hell out of me when I first saw the Yi source code, because I kept thinking "Yim" like "Vim"
20:12:19 <monochrom> Hahaha the ViM monad...
20:12:44 <monochrom> Would you also like the YuM monad? :)
20:12:52 <ddarius> Yi is based on an (archaic) Japanese word if I recall correctly.
20:13:04 <gwern> don't laugh, the vim keybinding is getting complex enough it might need to define a custom monad
20:13:45 <ddarius> At any rate, it should be pronounced "yee" though perhaps not held as long as that suggests.
20:14:02 <lament> it should be pronounced as written.
20:14:16 <Tac-Tics> "Yi" isn't even a recognized syllable in modern japanese, so it'd have to be really old
20:14:25 <ddarius> That is what "archaic" means.
20:14:25 <scook0> is there anyone familiar with community.haskell.org about? I'm having trouble getting an account
20:14:34 <ddarius> Tac-Tics: "yen"
20:14:35 <scook0> lament: you mean as a series of pen-scratching sounds?
20:14:49 <gwern> sclv: I have an account there, but I never figured out how to use the place personally
20:14:59 <phobes> We are the knights who say ...
20:15:06 <gwern> yi!
20:15:08 <Tac-Tics> yi!
20:15:10 <Tac-Tics> yi yi yi!
20:15:13 <scook0> I can't log in, but I'm not sure if that's because my account hasn't been created :/
20:15:16 <Eiler> "new parallelism annotations" is parallelism something new for haskell?
20:15:28 <gwern> sclv: you'd've gotten an email, iirc
20:15:29 <ddarius> scook0: Have you gotten an email to say that your account has been created?
20:15:35 <monadhrom> old idea, new implementation
20:15:38 <ddarius> Eiler: No.
20:15:39 <scook0> ddarius: nope
20:15:51 <ddarius> scook0: Then it almost certainly hasn't been created.
20:15:57 <Eiler> what has been renewed then?
20:15:58 <scook0> that's what I thought
20:16:03 <scook0> but I wasn't sure
20:16:04 <Eiler> whats the difference that is
20:16:19 <Tac-Tics> stupid algorithms and their tendencies to produce lists reversed of how I want them
20:16:27 <monadhrom> was implemented over PVS and cluster. now SMP.
20:16:32 <ddarius> Eiler: What are you referring to?  Haskell has a whole menagerie of parallelism stuff.
20:16:42 <oerjan> @remember lament it should be pronounced as written. <scook0> you mean as a series of pen-scratching sounds?
20:16:42 <lambdabot> Good to know.
20:16:49 <monadhrom> Err, s/PVS/PVM/
20:17:12 <Eiler> ddarius: dunno, since i dont know what the old stuff was, reading dons blogg
20:17:34 <alexis> So.. i was watching channel9.msdn.com and i saw some foreign guy talking about haskell -- i just wanted to let you know that I've reviewed his claims and found haskell to be complete bullshit.  Thank you.
20:17:55 <lament> alexis: finally!
20:17:56 <alexis> And the guy from Leave it to Beaver was never any cool anyway.
20:18:19 <gwern> oh no! someone finally saw through our elaborate charade!
20:18:42 <gwern> I guessthe gig is up fellas. we'd better 23-skiddoo, and skeddaddle before the coppers show
20:18:57 <lament> man
20:19:03 <alexis> And the way you formatted the topic isn't clever, either.
20:19:03 <lament> all that terminology didn't stop them
20:19:16 <alexis> it's pathetic.
20:19:29 <ddarius> Eiler: Those aren't really new.
20:19:34 <monadhrom> kickban?
20:19:46 <alexis> monadhrom:  That's not a well-formed question.
20:19:49 <gwern> monadhrom: if we ban alexis, who will teach us the error of our ways?
20:19:50 <jaredj> ...?
20:20:04 <monadhrom> palomer teaches better
20:20:04 <alexis> Why would anyone want to ban me?  I am the truth.
20:20:10 <alexis> If you'll excuse me, i need to scavange for some batteries for my dildo.
20:20:10 <monadhrom> and palomer is banned.
20:20:13 <lament> gwern: look at christianity. They crucified the dude, and only then realized he was actually cool.
20:20:20 <jaredj> ...!
20:20:27 <lament> Perhaps we should crucify this dude too.
20:20:36 <gwern> lament: that's because he was a filthy jew
20:20:56 --- mode: ChanServ set +o sjanssen
20:21:01 <jaredj> ...*
20:21:10 <lament> and on the internet, nobody knows you're a jew?
20:21:12 <sjanssen> aww, too slow
20:21:32 <phobes> sjanssen:  Do you have to catch them in channel?
20:21:46 <phobes> or is it just easier that way?
20:21:51 <sjanssen> phobes: I didn't think a ban was warranted
20:21:56 <gwern> lament: no, their notorious miserly nature comes out in every treacherous word. Judenrehein out!
20:22:01 <sjanssen> unless this isn't the first time?
20:22:06 <phobes> sjanssen:  oh ok, you just wanted a boot
20:22:08 <lament> i was pretty sure he was just being sarcastic
20:22:18 <lament> but no, now he's doing the same routine in #kde
20:22:22 <flippo> lament, well, a few hundred years later anyway.  Based on some oral tradition.   With some confusion over the details.
20:22:31 <ddarius> lament: About KDE or Haskell?
20:22:37 <lament> about kde.
20:22:48 <lament> 20:22 <alexis> KDE.  It's a really crappy program.
20:22:49 <lament> 20:22 <alexis> It's almost as crappy as that linux operating system.
20:22:50 <phobes> I wouldnt' ban anyone like that if it seemed that they were aware of what Haskell was
20:22:58 --- mode: ChanServ set -o sjanssen
20:23:12 <Cale> Eiler: There's some not-quite-released nested data parallelism stuff which is rather cool.
20:23:15 <ddarius> phobes: I doubt he knows what Haskell is.
20:23:50 <gwern> ddarius: he did at least know of the SPJ videos
20:23:53 <monadhrom> "I am the truth" is proof enough.
20:24:06 <phobes> ddarius:  You mean you think he just completely made up the "foreign guy"?
20:24:11 <phobes> ddarius:  seems implausible
20:24:23 <gwern> SPJ does talk foreigny
20:24:29 <ddarius> phobes: You could watch those and have no idea what Haskell is.
20:24:33 <phobes> oh , foreign guy was SPJ?
20:24:43 <gwern> phobes: I can't think who else
20:24:45 <Cale> Eiler: It adds a new datatype called the parallel array together with some fancy code transformations such that operations on parallel arrays are automatically split across processors in a fair way.
20:24:56 <Eiler> oh
20:25:32 <monadhrom> Trolling does not preclude knowing the subject.
20:25:41 <ddarius> monadhrom: I know.
20:25:47 <Cale> Also, you can do things like nest parallel arrays, and nest computations which internally use parallel arrays and this very clever "flattening transformation" can handle it.
20:25:56 <Tac-Tics> If I had a nickle for every time $'s low precedence cause me a syntax error, I'd have.... $0.05 times the number of lines of haskell code I've ever written
20:25:59 <phobes> I've been trolling for months now, and am starting to know quite a few things about haskell
20:26:01 <monadhrom> I mean I want to point that out to phobes.
20:26:13 <Eiler> Cale: http://cgi.cse.unsw.edu.au/~dons/blog im reading the top blog post. I dont really get it, first he gets 39s without parallelism and 1 core, then he gets 76s with 4 cores and parallelism?
20:26:14 <lambdabot> Title: Haskell hacking
20:26:34 <ddarius> Tac-Tics: ?  The low precedence of ($) is part of the point.  If you don't want that, don't use ($).
20:26:40 <Cale> oh, he's actually using rather old parallelism primitives there
20:26:46 <Tac-Tics> ddarius: it was a joke
20:26:50 <Eiler> or aha nvm, im looking at the user time, not total
20:26:51 <Cale> but no, that doesn't sound quite right...
20:26:53 <Tac-Tics> $ is what separates us from the Lispers
20:26:55 <Cale> ah, okay
20:26:58 <monadhrom> Alright, there is still malicious trolling vs harmless, even benevolent trolling. :)
20:27:26 <lament> Tac-Tics: i thought it was being able to pronounce the sound "s"
20:27:38 <Eiler> he uses a slow C implementation to compare with though, that kind of sucks
20:27:50 <Tac-Tics> lament: yes, that too
20:28:11 <Cale> Eiler: the idea is to maintain the naive fibonacci implementation
20:28:14 <ddarius> Eiler: He's using a naive version in both cases.
20:28:28 <Cale> That is, it's the same algorithm
20:28:52 <Cale> It's just that divide and conquer makes for a better parallelism story than linear iteration.
20:28:53 <Eiler> Cale: there is nothing naive with long long instead of int
20:29:04 <Cale> You won't get the right result with int.
20:29:19 <ddarius> Eiler: He switches to Int -> Integer for the final Haskell version.
20:29:24 <Cale> Also, the haskell version is using arbitrary precision integers.
20:29:34 <Eiler> you probably would get the right result since its usually 2^32
20:29:55 <Eiler> and you would definetly get the correct result with a normal long
20:30:08 <Tac-Tics> heh, my friend from college who works with me, and who mostly did C++ throughout school got bored at work and did some Project Euler. The look on his face was just too much when he found out that "unsigned long long" wasn't big enough to calculate some of the answers
20:30:58 <sjanssen> Eiler: sparking a parallel computation has a small overhead -- the first implementation sparks far too many
20:31:06 <Tac-Tics> He kept going on "why isn't it big enough? It's a unsigned LONG long!??" and I just kept telling him "use python or download yourself a bignum class"
20:31:08 <Cale> Eiler: hmm...
20:31:10 <Eiler> fib(44) 1134903170 that can fit into 32bit
20:31:41 <monadhrom> Don't you love simple-mindedness.
20:31:58 <oerjan> @let fib = 1:1:zipWith(+)fib(tail fib)
20:32:01 <lambdabot> Defined.
20:32:06 <Cale> Eiler: okay, that's interesting, he could have used Int in Haskell as well.
20:32:07 <oerjan> > fib!!44
20:32:08 <lambdabot>  1134903170
20:32:13 <Cale> (but he didn't)
20:32:29 <Cale> Eiler: Anyway, comparing GMP integers with long longs is pretty fair.
20:32:37 <oerjan> > fib!!44 :: Int
20:32:38 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
20:32:43 <oerjan> oops
20:32:49 <geezusfreeek> overcompensating, even
20:32:53 <oerjan> > fromIntegral $ fib!!44 :: Int
20:32:54 <lambdabot>  1134903170
20:34:10 <Trinithis> > fib !! 0
20:34:11 <lambdabot>  1
20:34:12 <Eiler> not if you are comparing speed of languages, you might at least put in a small efford to put in good types and not to much overhead code
20:34:18 <Trinithis> your fib is wrong
20:34:52 <Cale> Eiler: I think he pretty much got the point across though.
20:35:49 <oerjan> Trinithis: well !!44 is the answer Eiler mentioned
20:35:55 <Eiler> Yep, the point of comparing parallelism vs non parallelism sure, but not really by comparing language speeds... if they not remain the same for at least a little optimized examples
20:36:07 <Trinithis> oerjan: fib !! 0 should be 0
20:36:33 <ddarius> Trinithis: I don't think the starting value for fib is standardized, and in my experience, 1 is more common.
20:36:45 <oerjan> Trinithis: i know
20:36:52 <Cale> Eiler: the overall idea is that exploiting parallelism can end up more than compensating for the overhead of having an immature code generator.
20:37:10 <oerjan> especially with negative values, it makes things more symmetric
20:37:18 <sclv> @oeis fibonacci
20:37:18 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
20:37:18 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
20:37:38 <Trinithis> ddarius: fyi, the first fib value is indeed defined to be zero
20:37:43 <mxc> what is oeis?
20:37:49 <ddarius> Trinithis: Defined by who?
20:37:52 <sclv> ?go oeis
20:37:53 <lambdabot> http://www.research.att.com/~njas/sequences/
20:37:53 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
20:38:21 * Cale hugs OEIS.
20:38:38 <monadhrom> omniscient engine for internet search
20:38:50 <Cale> It's so bloody useful for formulating conjectures when counting things :)
20:38:53 <Trinithis> ddarius: perhaps you're right, but I've never seen it start at 1
20:39:07 <LoganCapaldo> if you have  an omniscient engine, what do you need search for?
20:39:11 <oerjan> i'm sure Fibonacci started it at 1 :D
20:39:13 <Cale> The 0th Fibonacci number is 0
20:39:29 <phobes> @oeis 0, 6, 15, 16, 31, ...
20:39:29 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
20:39:34 <phobes> @oeis [0, 6, 15, 16, 31, ...
20:39:34 <lambdabot> Sequence not found. stty: unknown mode: doofus
20:39:36 <phobes> @oeis [0, 6, 15, 16, 31, ...]
20:39:36 <lambdabot> Sequence not found. I feel much better now.
20:39:36 <Cale> @oeis 0, 6, 15, 16, 31
20:39:37 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
20:39:55 <Cale> @oeis 0  6  15  16  31
20:39:55 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
20:40:06 <phobes> Is that it telling me that I failed at syntax or it failed at search?
20:40:12 <oerjan> @oeis 1,1,2,3,5
20:40:13 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
20:40:13 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
20:40:14 <ddarius> Search
20:40:21 <phobes> ok
20:40:21 <ddarius> @oeis 1 1 2 3 5
20:40:22 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
20:40:22 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
20:40:27 <monadhrom> You need the search part as a human-computer interface. You can't just expect the engine to download everything it knows to you. Your brain would explode.
20:40:34 <Cale> @oeis 6, 15, 16, 31
20:40:35 <lambdabot> Permutation of natural numbers: maps the canonical list of fractions (A020652...
20:40:35 <lambdabot> [1,2,3,4,7,8,5,6,15,16,31,32,9,11,12,14,63,64,10,13,127,128,17,23,24,30,255,2...
20:40:49 <oerjan> @oeis 1is1this2:::3also5legal?
20:40:49 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
20:41:01 <oerjan> ok not quite that liberal
20:41:21 <geezusfreeek> lol
20:41:22 <phobes> @oeis one two three four
20:41:22 <lambdabot> Reverse one number (0), then two numbers (2,1), then three (5,4,3), then four...
20:41:22 <lambdabot> [0,2,1,5,4,3,9,8,7,6,14,13,12,11,10,20,19,18,17,16,15,27,26,25,24,23,22,21,35...
20:41:25 <LoganCapaldo> @oeis 2 4 8 16 32
20:41:25 <lambdabot> Powers of 2: a(n) = 2^n.
20:41:25 <lambdabot> [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
20:41:30 <Cale> Leaving spaces and putting commas means a different thing
20:42:06 <Cale> With spaces, it'll search for sequences which contain those elements but with possibly other elements in between.
20:42:16 <Cale> (but in the same order)
20:42:21 <oerjan> @oeis 1:1%2?3!5
20:42:22 <lambdabot> Sequence not found. :(
20:42:32 <Trinithis> what does oeis mean
20:42:33 <Cale> With commas, it won't allow other things in between.
20:42:37 <Cale> @go oeis
20:42:38 <lambdabot> http://www.research.att.com/~njas/sequences/
20:42:38 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
20:42:43 <oerjan> ah
20:43:13 <Cale> and if you search for anything else, it'll just do a full text search
20:43:31 <geezusfreeek> @oeis  1, 4, 5, 7
20:43:31 <lambdabot> a(n) is the number of k such that k and n*k, taken together, are pandigital.
20:43:31 <lambdabot> [0,48,6,8,12,0,1,16,3,0,0,1,1,6,3,1,19,6,4,12,0,3,3,4,3,9,2,1,8,2,0,16,1,3,14...
20:43:36 <phobes> Anyone know elliptic function theory?  (I need to construct a function out of Weierstrass p)
20:43:37 <davidL> @oeis repunit
20:43:38 <lambdabot> Repunits: (10^n - 1)/9. Often denoted by R_n.
20:43:38 <lambdabot> [0,1,11,111,1111,11111,111111,1111111,11111111,111111111,1111111111,111111111...
20:43:43 <Cale> actually, I'm mistaken, spaces also just does a full text search
20:44:08 <Cale> @oeis lost
20:44:08 <lambdabot> Taylor series from Ramanujan's Lost Notebook.
20:44:08 <lambdabot> [0,1,2,3,5,8,11,16,23,31,43,58,76,101,132,170,219,280,354,447,562,699,869,107...
20:44:12 <geezusfreeek> @oeis  4,2,1,4
20:44:12 <lambdabot> Number of prime divisors of n (counted with multiplicity).
20:44:13 <lambdabot> [0,1,1,2,1,2,1,3,2,2,1,3,1,2,2,4,1,3,1,3,2,2,1,4,2,2,3,3,1,3,1,5,2,2,2,4,1,2,...
20:44:13 <Cale> @oeis lost numbers
20:44:13 <lambdabot> The Lost Numbers.
20:44:13 <lambdabot> [4,8,15,16,23,42,108]
20:44:33 <LoganCapaldo> 4, do you need directions?
20:44:38 <Cale> @oeis 1, 6, 21, 107
20:44:39 <lambdabot> Busy Beaver problem: maximal number of steps that an n-state Turing machine c...
20:44:39 <lambdabot> [1,6,21,107]
20:44:40 <davidL> > map (\n -> (10^fromIntegral(n) - 1)/9) [0..]
20:44:41 <lambdabot>  [0.0,1.0,11.0,111.0,1111.0,11111.0,111111.0,1111111.0,1.1111111e7,1.11111111...
20:44:44 <monadhrom> Heh?! Indiana Jones and The Lost Numbers?!
20:45:39 <ddarius> monadhrom: Not that magical, unfortunately.
20:45:40 <phobes> @oeis 8, 6, 7, 5, 3, 0, 9
20:45:40 <lambdabot> From the words to the song "Jenny's Letterbox" by Tommy Tutone.
20:45:41 <lambdabot> [8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,...
20:46:11 <phobes> @oeis 8, 6, 7, 5, 3
20:46:11 <lambdabot> Decimal expansion of 6th root of 2.
20:46:11 <lambdabot> [1,1,2,2,4,6,2,0,4,8,3,0,9,3,7,2,9,8,1,4,3,3,5,3,3,0,4,9,6,7,9,1,7,9,5,1,6,2,...
20:46:15 <phobes> @oeis 8, 6, 7, 5, 3, 0
20:46:15 <lambdabot> From the words to the song "Jenny's Letterbox" by Tommy Tutone.
20:46:16 <lambdabot> [8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,...
20:46:50 <Tac-Tics> @oeis 0,0,0,0,0
20:46:50 <lambdabot> The characteristic function of 0: a(n) = 0^n.
20:46:50 <lambdabot> [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
20:46:56 <Tac-Tics> heh
20:47:19 <Tac-Tics> If only there were a way in lambdabot to pipe list-valued expressions to it
20:47:35 <davidL> oh there is
20:47:43 <LoganCapaldo> > map ((/9) . (subtract 1 . (10 ^))) [0..]
20:47:43 <Tac-Tics> gimme gimme gimme!
20:47:44 <lambdabot>  [0.0,1.0,11.0,111.0,1111.0,11111.0,111111.0,1111111.0,1.1111111e7,1.11111111...
20:49:00 <phobes> So how does it decide that "Decimal expansion of 6th root of 2" is more relevant than "From the words to Jenny's Letterbox"...
20:49:32 <phobes> Does hpaste have ban?
20:49:37 <Cale> > describeSequence
20:49:38 <lambdabot>   Not in scope: `describeSequence'
20:49:44 <Cale> booo... :(
20:49:50 <LoganCapaldo> hissss
20:49:56 <oerjan> > OEIS.describeSequence
20:49:57 <lambdabot>   Not in scope: `OEIS.describeSequence'
20:50:06 <Cale> > Math.OEIS.describeSequence
20:50:06 <lambdabot>   Not in scope: `Math.OEIS.describeSequence'
20:50:23 <oerjan> :t Math.OEIS.describeSequence
20:50:28 <lambdabot> Not in scope: `Math.OEIS.describeSequence'
20:50:30 <LoganCapaldo> Two star-crossed modules, destined never to meet
20:51:00 <davidL> @. oeis run unwords . take 10 $ map show (fix((1:).scanl (+) 1))
20:51:01 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
20:51:01 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
20:51:56 <oerjan> @@ @run reverse $ take 10 $ reverse $ @oeis 1,1,2,3,5
20:51:56 <lambdabot>  Parse error at "=" (column 55)
20:52:08 <oerjan> @@ @run reverse $ take 10 $ reverse $ @show @oeis 1,1,2,3,5
20:52:09 <lambdabot>  "10946,1..."
20:52:16 <davidL> @. oeis run unwords . take 10 . map show $ nubBy(((>1).).gcd)[2..]
20:52:18 <lambdabot> The prime numbers.
20:52:18 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,1...
20:52:30 <Tac-Tics> neat!
20:52:57 <davidL> @help @
20:52:57 <lambdabot>  @ [args].
20:52:57 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
20:52:57 <lambdabot>  The commands are right associative.
20:52:57 <lambdabot>  For example:    @ @pl @undo code
20:52:57 <lambdabot>  is the same as: @ (@pl (@undo code))
20:53:12 <Cale> I like how it takes more characters to get the sequence into the right form for oeis than to actually define the prime numbers.
20:53:41 <Cale> > nubBy(((>1).).gcd)[2..]
20:53:41 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
20:53:50 <gwern> hm. is there any option to make ghci exit with an error if .ghci doesn't work perfectly?
20:54:08 <oerjan> @@ @run (read :: String->[Integer]) . (!!1) . lines $ @show @oeis 1,1,2,3,5
20:54:11 <lambdabot>  Exception: Prelude.(!!): index too large
20:54:28 <Twey> Hm
20:54:29 <oerjan> @show @oeis 1,1,2,3,5
20:54:29 <lambdabot> "@oeis 1,1,2,3,5"
20:54:36 <oerjan> @@ @show @oeis 1,1,2,3,5
20:54:36 <lambdabot>  "Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ... [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1..."
20:54:50 <davidL> neat
20:54:50 <Twey> I hear GHC supports UTF-8 now, but main = let „ÅÇ = 3 in putStrLn (show „ÅÇ) is still a lexical error?
20:55:34 <oerjan> @@ @run lines $ @show @oeis 1,1,2,3,5
20:55:35 <lambdabot>  ["Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ....
20:55:44 <oerjan> @@ @run tail . lines $ @show @oeis 1,1,2,3,5
20:55:45 <lambdabot>  []
20:55:46 <gwern> > let „ÅÇ = 3 in show „ÅÇ
20:55:46 <lambdabot>  Illegal character ''\129''
20:55:46 <lambdabot>  at "ÅÇ" (column 6)
20:56:01 <Tac-Tics> it support utf8 for identifiers?
20:56:02 <Eiler> Cale: if you gonna compare at least write the algoritm in a descent way: http://rafb.net/p/eEMu3y43.html 79 seconds vs 0.008 seconds
20:56:02 <lambdabot> Title: Nopaste - No description
20:56:04 <Twey> lambdabot doesn't do UTF-8.
20:56:11 <Trinithis> oh dear!
20:56:18 <Twey> Hey Trinithis
20:56:26 <Trinithis> ;)
20:56:28 <Twey> Heh
20:56:34 <Twey> Discovered IRC?  :-P
20:56:40 <Trinithis> a while ago
20:56:45 <Trinithis> just havent been on much
20:56:48 <Twey> Ah, OK
20:56:51 <Trinithis> gonna watch some babylon 5 soon
20:56:58 <Twey> Tac-Tics, so, I guessed it should
20:57:04 <oerjan> @@ @run (read :: String -> Integer) . last . words $ @show @oeis 1,1,2,3,5
20:57:05 <lambdabot>  Exception: Prelude.read: no parse
20:57:26 <oerjan> @@ @run last . words $ @show @oeis 1,1,2,3,5
20:57:27 <lambdabot>  "[0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:57:44 <Twey> Tac-Tics: If it doesn't, what *does* it support in UTF-8?
20:58:06 <Tac-Tics> I don't know anything about it, but unicode identifiers scare me =-)
20:58:22 <Trinithis> the big question is... will it accept real lambdas?
20:58:40 <sjanssen> Trinithis: yes, as part of an identifier
20:58:59 <sjanssen> it wouldn't be fair to steal a letter from Greek speakers
20:59:00 <poodlesucks> omg some guy threw stuff at me while i was walking!! hat should i have done to him? :D thank you
20:59:02 <Twey> Tac-Tics, heh
20:59:10 <Trinithis> so soon everyone will code with identifiers like \\\\
20:59:13 <sjanssen> Twey: how did you test it?
20:59:25 <Twey> sjanssen: ghc -o utf8 utf8.hs
20:59:33 <Tac-Tics> Does anyone have any cool Haskell one-liners off the top of their head?
20:59:49 <Twey> Tac-Tics, almost all Haskell is cool one-liners
20:59:58 <Trinithis> jokes?
21:00:00 <Trinithis> or code?
21:00:02 <Tac-Tics> I know, but I want to build a collection of them
21:00:02 <Twey> A program is just a collection of them chained together.
21:00:07 <Twey> Haha, code :-P
21:00:12 <oerjan> poodlesucks did slow spamming yesterday too
21:00:18 <Tac-Tics> Trinithis, preferably code, but jokes work too =-)
21:00:32 <Trinithis> as my brother says... "haskell's triange"
21:00:37 <Trinithis> triangle*
21:01:08 <Twey> oerjan, I think he's dogsson?
21:01:11 <Trinithis> in any case, gtg. probbaly be on later
21:01:12 <Eiler> Cale: wrote out with printf now, 0.002 sec then
21:01:25 <davidL> Eiler: that wasn't really the point "fix((1:).scanl(+)1)!!44" will run in the same time...
21:01:26 <oerjan> @go site:haskell.org/haskellwiki blow your mind
21:01:27 <lambdabot> http://www.haskell.org/haskellwiki/Blow_your_mind
21:01:27 <lambdabot> Title: Blow your mind - HaskellWiki
21:01:34 <oerjan> Tac-Tics: try there
21:01:56 <Tac-Tics> thanks!
21:02:09 <oerjan> Twey: who is dogsson?
21:02:21 <Eiler> Can lambdabot write out time of an evaluation?
21:02:53 <Twey> oerjan, someone who was spamming crazy stuff yesterday.
21:04:44 <poodlesucks> somebody threw snow ball at me with their words. what should i do to her? she is my ugly sister
21:04:49 <davidL> Eiler: what value N are you using?
21:05:02 <Eiler> 44
21:05:28 <Eiler> and all printing time was included
21:05:43 <Eiler> for n = 1 to 44
21:05:48 --- mode: ChanServ set +o sjanssen
21:06:06 <sjanssen> poodlesucks: are you here to discuss Haskell?
21:06:30 <gwern> sjanssen: admit it, you just want to kick someone tonight, amiright? :)
21:06:58 <davidL> Eiler: how long does it take for that to get the 444444'th Fibonacci number?
21:07:28 <sjanssen> gwern: I have the bloodlust
21:07:48 <ddarius> I love this community.
21:08:02 --- kick: poodlesucks was kicked by sjanssen (sjanssen)
21:08:03 <gwern> sjanssen: the blood is the life
21:08:04 <Tac-Tics> is there a Functor instance for Data.Set's Set?
21:08:11 <ddarius> No.
21:08:15 <ddarius> There can't be.
21:08:20 <Eiler> davidL: wasnt 44 enough? what time did you get
21:08:27 <Tac-Tics> whynot?
21:08:44 <ddarius> It would need an Ord context and thus it's "fmap" would have the wrong type.
21:08:46 <LoganCapaldo> @type Data.Set.fromList
21:08:47 <lambdabot> forall a. (Ord a) => [a] -> Data.Set.Set a
21:08:47 <Tac-Tics> because of the internal representation or something?
21:08:56 <LoganCapaldo> @type fmap
21:08:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:09:48 <Eiler> > fix((1:).scanl(+)1)!!44
21:09:49 <lambdabot>  1134903170
21:10:16 <davidL> real 0m49.551s for "fix((1:).scanl(+)1)!!444444" on 3.2 GHz :P
21:10:51 <ddarius> Does that include printing the result?
21:11:01 <davidL> yeah
21:11:20 <Eiler> and how long for 44 including printing results?
21:11:46 <davidL> real	0m0.001s
21:11:53 <LoganCapaldo> compiled or interpeted? did you use -O2? :)
21:12:04 <davidL> ghc -O2
21:14:25 <davidL> (57.94 secs, 9597059292 bytes) in ghci
21:15:14 <ddarius> Yeah.  For heavy Integer work, most of the time is spent in GMP and so GHCi usually does relatively well w.r.t GHC.
21:15:51 <LoganCapaldo> wheres the compile time evaluation at? That should take nly as long as it does to print it <g>
21:16:17 <ddarius> $( fibs!!444444 )
21:16:19 <Eiler> to bad they hardly showing the screen in the OSCON video
21:16:31 <geezusfreeek> you'd rather the compilation take a minute?
21:17:03 <Eiler> you can evaluate the n'th term in fibonacci sequence directly if you want
21:17:09 <ddarius> Cripes! Musaks!
21:17:11 <LoganCapaldo> Sure. I (hopefully)_ compile way less often than I run it
21:17:33 <geezusfreeek> what if the function didn't happen to be total?
21:17:51 <geezusfreeek> would require solving the halting problem to know whether it was worth trying to evaluate for so long
21:18:15 <monadhrom> sjanssen: poodlesucks has a track record of deserving kickban. Last time it was: "IMPORTANT." then some incoherence seemingly about "should I watch TV or movies".
21:18:18 <LoganCapaldo> it doesn't have to be general
21:19:01 <monadhrom> Needless to say, I'm most particularly put off by "IMPORTANT." That is always a telltale sign.
21:19:38 <geezusfreeek> i play the side i disagree with sometimes so that the need to formulate arguments forces me to better understand the problem
21:19:42 <davidL> are these spammers all over freenode? I'm only on a few channels here
21:19:53 <geezusfreeek> i agree that compile-time evaluation should work more often than it does
21:21:17 <geezusfreeek> however, if this problem was solved at compile time then it would only be fair to include compilation time in any benchmarks
21:22:05 <taruti> Is there something equivalent to XTestFakeKeyEvent in the Haskell x11 bindings?
21:23:15 <Twey> Tac-Tics, sjanssen: In fact even main = putStrLn "„ÅÇ" fails (outputs "B" instead)
21:23:22 <Tac-Tics> Is there a built in choice function in haskell?
21:23:35 <monadhrom> No.
21:23:41 <Tac-Tics> Twey: really? weird lemme try
21:24:12 <Twey> Looks like two of the bytes are being truncated...
21:24:14 <monadhrom> putStrLn etc. truncates MSBs before outputting.
21:24:31 <oerjan> Twey: putStrLn is not UTF-8 clean, it's only the actual haskell parser...
21:24:37 <Tac-Tics> you're right
21:24:59 <LoganCapaldo> Sure if your goal is to play "the lowest number of seconds game". OTOH if you want to get a practical, useful speedup, then up to a point you can consider compilation to be "free". (But definitely only up to a point. Plenty of code bases out there that take a loooooong time to build)
21:25:00 <Twey> So effectively, there's no UTF-8 support?
21:25:08 <oerjan> try print instead
21:25:26 <oerjan> Twey: the String itself should be right
21:25:37 <Twey> Outputs "\12354"
21:25:43 <Twey> oerjan: Yes, the string is right
21:25:53 <Twey> But... I can't do anything with it
21:25:56 <Tac-Tics> print will call "show" on it, thus, the weirdness
21:26:00 <Twey> So it might as well not be
21:26:11 <Tac-Tics> there's probably some UTF8 enabled library
21:26:16 <monadhrom> Look for the "utf8-string" package and the "encode" package.
21:26:17 <Twey> :-\
21:26:29 <Twey> "Haskell was built around Unicode," they said
21:26:36 <monadhrom> s/and/or/
21:27:10 <oerjan> Twey: just not very well :/
21:27:21 <monadhrom> In theory, theory equals practice. In practice, there are bug reports and todo lists.
21:27:33 <Twey> :-(
21:27:52 <monadhrom> Be assured that GHC 20.4.8 will have UTF-8 putStrLn. :)
21:28:06 <allbery_b> haskell was built around unicode.  haskell implementations, not so much.
21:28:07 <Twey> That's highly useful.  :-(
21:28:20 <oerjan> monadhrom: but but that will break backwards compatibility!
21:28:53 <nominolo> @seen conal
21:28:53 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 5h 37m 33s ago.
21:29:01 <Twey> Hmm, utf8-string and encode aren't in Portage
21:30:48 <ddarius> @where hackage
21:30:48 <lambdabot> http://hackage.haskell.org/
21:31:10 <monadhrom> By the time of 20.4.8, most likely most people will have moved on to UTF-16 or something, and consider UTF-8 a legacy thing. So that will be good backwards compatibility! :)
21:32:00 <sjanssen> if you want to talk about legacy, UTF-16 is a big stinking example of it
21:32:19 <monadhrom> Heh, OK, UTF-16TNG.
21:32:26 --- mode: ChanServ set -o sjanssen
21:33:01 <sjanssen> anybody heard of UCS-2?
21:33:21 <monadhrom> I think I did and I keep forgetting its details.
21:33:38 <xpika> is there a more robust haskell algorithm simplifier?
21:33:39 <Twey> sjanssen, UTF-16?  How so?
21:33:46 <xpika> than @pl
21:34:02 <ddarius> xpika: You think @pl is a Haskell algorithm simplifier?
21:34:04 <sjanssen> UCS-2 is the progenitor of UTF-16, it was a fixed width 2 byte encoding
21:34:04 <monadhrom> Yes, it's called #haskell.
21:34:06 <BMeph> Twey: How Not so? ;p
21:34:18 <sjanssen> there were several early adopters, Windows, Java, some others
21:34:19 <xpika> @pl (\x->x)
21:34:20 <lambdabot> id
21:34:46 <xpika> ddarius: looks like it
21:35:02 <Twey> BMeph: UTF-16 can encode CJK characters in two bytes, as opposed to UTF-8's three
21:35:06 <ddarius> xpika: A better example is \x -> map f (map g x)
21:35:12 <sjanssen> turns out 16 bits didn't allow enough characters, so they hacked up UTF-16 to support the higher characters
21:35:18 <monadhrom> I might actually have UCS-2 in mind. I keep confusing the two.
21:35:46 <davidL> @pl \x -> map f (map g x)
21:35:46 <lambdabot> map (f . g)
21:35:56 <xpika> ddarius: ?
21:35:57 <Twey> BMeph: This makes it a good choice for encoding text largely written using CJK characters.
21:35:59 <sjanssen> so there are environments that have these stupid half characters (usually called surrogate pairs)
21:36:21 <sjanssen> we're going to be stuck with this legacy for quite a long time
21:36:22 <ddarius> 64k characters is enough for -anybody-
21:36:26 <BMeph> The whole point to having UTF-16, AKA "Unicode", was to have a 16-bit encoding for every readable glyph on the planet. Then they looked up from their toes and realized that there were a lot more symbols for things than could be encoded with 16 bits.
21:36:42 <sjanssen> BMeph: it was called UCS-2 at that time
21:37:07 <BMeph> sjanssen: I believe UCS-2 was MS's entry into the ring.
21:37:30 <BMeph> I'm wrong a lot, so don't mind me, that's just what I've heard. ;)
21:38:06 <Twey> Well, yes, but it's still useful.
21:38:14 <xpika> wikipedia says one dictionary gives 85,568 characters
21:38:39 <Twey> xpika, that's just Chinese hanzi
21:38:47 <sjanssen> BMeph: I don't think it originated with MS
21:39:03 <BMeph> From Wikipedia: "UCS-2 (2-byte Universal Character Set) is an obsolete character encoding which is a predecessor to UTF-16."
21:39:32 <Twey> You've also got all the different possible combinations of Korean hangeul (which are encoded seperately), and the Japanese kana
21:39:33 <sjanssen> BMeph: and UTF-16 has always referred to the variable width encoding that covers the entire current Unicode range
21:39:39 <Twey> Korean fonts are *huge*
21:40:03 <Cale> Eiler: Dude, that totally misses the point.
21:40:18 <Cale> Eiler: Of course the linear version of fib is much faster.
21:40:38 <sjanssen> but anyway, most platforms that advertise UTF-16 support actually have a bastardized version of UCS-2 with surrogate pairs bolted on
21:40:40 <Cale> Eiler: There exist problems with similar recursion patterns as the recursive fib with no linear solution.
21:40:40 <Twey> Oh, and some of the Japanese and Korean kanji/hanja differ from those found in Chinese, and have to be encoded as well.
21:41:10 <prb> Twey: I've had the fun of Japanese encodings.  Shift-JIS, UTF-*, etc.
21:41:11 <sjanssen> eg. in Java, when you index a String, you might only receive a half character
21:41:17 <Twey> (although in some cases the Unicode committee didn't do that, to the great howling and gnashing of teeth of the Japanese masses)
21:41:26 <blbrown> :t asks
21:41:31 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
21:41:46 <Twey> prb: Fun, isn't it?  :-P
21:42:35 <prb> Twey: My particular hit of "fun" was figuring out why a file was getting garbled across several hosts in a transfer.  One of the hosts was using ISO-8859-1 for bonus difficulty (byte-to-ord).
21:43:17 <prb> Twey: It is surprising that Haskell doesn't have a getContents that accepts an encoding as an argument.
21:43:22 <blbrown> :t asks
21:43:23 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
21:43:25 <prb> Twey: It clearly should.
21:43:32 <Tac-Tics> @src asks
21:43:33 <lambdabot> asks f = do
21:43:33 <lambdabot>     r <- ask
21:43:33 <lambdabot>     return (f r)
21:44:00 <blbrown> Tac-Tics, I was trying to find what module it was in; got it now
21:44:17 <oerjan> @@ @pl @undo @src asks
21:44:18 <lambdabot>  ()
21:44:25 <oerjan> bah
21:44:26 <blbrown> @src (+)
21:44:27 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:44:36 <oerjan> @src Num
21:44:37 <lambdabot> class  (Eq a, Show a) => Num a  where
21:44:37 <lambdabot>     (+), (-), (*)           :: a -> a -> a
21:44:37 <lambdabot>     negate, abs, signum     :: a -> a
21:44:37 <lambdabot>     fromInteger             :: Integer -> a
21:44:49 <LoganCapaldo> @index asks
21:44:50 <lambdabot> Control.Monad.Reader, Control.Monad.RWS
21:44:51 <oerjan> blbrown: it's a class method ^
21:45:10 <blbrown> oerjan, it seems like all haskell code in the base code is an average of 10 lines long
21:45:21 <blbrown> function implementations I mean
21:45:54 <oerjan> surely many are smaller...
21:46:04 <Cale> Eiler: besides, if we're allowed to change the algorithm, I can do it in Haskell with the same algorithm in the same amount of time.
21:46:04 <blbrown> hehe
21:46:15 <monadhrom> It is said that a programmer writes 10 lines a day on average.
21:46:30 <Tac-Tics> 10 working lines?
21:46:47 <blbrown> that study seems flawed
21:46:54 <monadhrom> Yes. Do you want to know the variance?
21:47:48 <monadhrom> Some days you participate in specification, requirement, design, meetings.
21:48:08 <LoganCapaldo> +/- 1 bad lisp implemenation ?
21:48:12 <monadhrom> Some days you code 26 hours a day and produce thousands of lines of code.
21:48:32 <monadhrom> Some days you don't write new code, you test 26 hours a day and modify bits of code.
21:48:34 <ddarius> Sometimes I produce negative lines of code per day
21:48:37 <LoganCapaldo> or mail reader
21:48:44 <monadhrom> Now take average and it should come out right.
21:48:45 <Tac-Tics> ddarius: those are good days
21:48:46 <blbrown> ddarius, refactoring, you are the true developer
21:49:06 <sandbox> has anyone worked with hdbus at all?
21:49:32 <Cale> Eiler: and of course, once you've done that, it becomes rather hard to compare C with Haskell at all, since without extra libraries or a lot of work, you can't even implement a non-broken fib to compare with Haskell on a reasonable size problem.
21:50:37 <Twey> utf8.o: In function `siy_info': (.text+0xea): undefined reference to `utf8zmstringzm0zi2_SystemziIOziUTF8_putStrLn_closure'
21:50:40 <Twey> *sigh*
21:51:09 <ddarius> --make?
21:51:12 <allbery_b> ghc --make
21:51:15 <Twey> Aha
21:51:18 <allbery_b> or -package utf8-string
21:51:19 * Tac-Tics wishes he knew more about how building C applications worked
21:51:31 <Twey> Yay!
21:51:33 <Twey> It works!
21:51:36 <Twey> <3
21:51:43 <Twey> Tac-Tics, it's messy.
21:51:50 <Tac-Tics> it seems as such
21:52:09 <ddarius> Better than C++
21:52:22 <Twey> ddarius, debatable (but I'd agree)
21:52:48 * BMeph wonders how much one can get done in C w/o any libraries...
21:53:24 <ddarius> BMeph: Are you allowed to write code with "undefined" behaviour according to the standard?
21:53:30 <allbery_b> plenty, assuming you're willing to reinvent the world
21:53:58 <LoganCapaldo> under what circumstances will your code be run?
21:55:02 <Tac-Tics> BMeph, how much work can you get done in any language without them?
21:55:11 <conal> nominolo: looking for me?
21:55:16 <nominolo> conal:
21:55:20 <nominolo> oops
21:55:21 <nominolo> yep
21:55:33 <BMeph> ddarius: The C Standard?
21:55:43 <Cale> Eiler: I have some Haskell code here which computes and prints fib of 1000000 in 0.531s or so.
21:55:47 <conal> nominolo: what's up?
21:55:49 <nominolo> i wanted to try your reactive library, but i'm missing examples
21:56:16 <conal> nominolo: did you look in src/Examples.hs?
21:56:19 <ddarius> BMeph: Yes.
21:56:26 <nominolo> conal: oh
21:56:33 <BMeph> Tac-Tics: Oh, don't get me wrong, you can still cause a core dump in C without even accessing I/O, just some idle "wondering"... ;)
21:56:36 <nominolo> conal: no, i was using the online docs only
21:56:43 <Tac-Tics> BMeph: ha
21:56:52 <Cale> Eiler: give that a shot and let me know how it goes :)
21:57:55 <nominolo> conal: hm, let's see if i can try that out without having to get wx worknig
21:57:56 <conal> nominolo: there are a few examples, all GUI-related, in reactive/src/Examples.  more in Phooey, under src/Examples/{Monad,Applicative}.hs .
21:58:07 <BMeph> ddarius: According to the standard, there are many times where you are REQUIRED to write code with "undefined" behavior. I haven't taken a good look at C since "C99", though, so YMMV.
21:59:00 <ddarius> BMeph: Well then, you can write any program without libraries.
21:59:02 <conal> nominolo: yes, for now wx is a req for those examples, which is too bad.  it ought to be very easy to re-do reactive's mini-phooey (in src/Examples.hs) for gtk2hs.  or something non-gui related.
21:59:24 <conal> nominolo: do you have some kind of examples/application in mind?  maybe we could cook up some examples together.
22:00:08 <BMeph> ddarius: Well, in that respect, sure. It'd be nice to get something Useful, but if all you're after is writing code, no problem.
22:00:10 <nominolo> conal: i want to try and see if it can be used in to describe how an editor renders content
22:00:23 <nominolo> conal: ie, still gui-based, but at a finer level
22:00:40 <ddarius> BMeph: "any program" obviously includes "useful programs"
22:00:51 <nominolo> conal: and then see how slow it gets and what optimizations are possible
22:01:04 <conal> nominolo: oh yeah --- you mentioned that to me quite a while ago.
22:01:16 <nominolo> conal: yep.  getting back to it :)
22:01:48 <conal> nominolo: sounds like a very nice application.  and if it's slow, then it'd be very interesting making it fast, while keeping a purely functional (no IO) interface.
22:01:50 <nominolo> conal: so, what i really need to understand is: how do i feed events into the system? and how do i run it?
22:02:08 <LoganCapaldo> /usr/bin/true and /usr/bin/false can be written w/o any libs (and without even any cheating) and are arguably "useful" ;)
22:02:27 <ddarius> No "arguably"
22:03:10 <conal> nominolo: see mkEvent and runE.  also runE's relatives forkE, subscribe, and forkR.
22:03:37 <conal> @localtime nominolo
22:03:38 <lambdabot> Local time for nominolo is Sun Jan 27 07:02:08
22:04:37 <nominolo> :)
22:04:40 <nominolo> conal: ok
22:05:01 <conal> nominolo: i'm just about to go to bed.  maybe i can catch you in the (my) morning.  and/or you can drop me some email with questions & ideas.
22:05:16 <nominolo> conal: sure, np
22:05:24 <conal> nominolo: we can start simple and get fancier.
22:05:30 <conal> g'night all.
22:05:32 <nominolo> conal: my plan, too
22:05:47 * ddarius suggests starting simple and getting simpler.
22:06:42 <nominolo> @instances WhenStartedSimpleCanBeMadeSimpler
22:06:45 <lambdabot> Couldn't find class `WhenStartedSimpleCanBeMadeSimpler'. Try @instances-importing
22:07:02 * nominolo had hoped for a different error message ...
22:07:07 * BMeph wonders if adjoint functors are "simple" or "simpler" to ddarius
22:07:39 <ddarius> Well since they can only be "simpler" in comparison to something, "simple" is the only possibility.
22:08:04 <nominolo> @localtime conal
22:08:37 <ddarius> He's gone.
22:08:51 <nominolo> oh, right
22:11:04 <ddarius> nominolo: He's in Pacific Standard Time, so it's about 10ish there.
22:11:25 <nominolo> my guess, too.  seems kinda early, though ;)
22:14:53 <ddarius> I believe he is a "morning person"
22:16:01 <BMeph> I like his quotes page, very "hmm"-worthy. :)
22:16:11 <nominolo> link?
22:16:26 <BMeph> Not quotes BY him, mind you, but of others he's collected.
22:16:36 <BMeph> At: http://conal.net/quotes.htm
22:16:37 <lambdabot> Title: Some of my favorite quotes
22:16:37 <nominolo> i understand
22:17:44 <nominolo> BMeph: not if you have met him in person ;)
22:18:15 <zarvok> Is there a haskell-mode command which copies the current region into the ghci buffer?
22:18:28 <BMeph> nominolo: Okay, ... s/BY/ORIGINALLY BY/ ;p
22:19:50 <nominolo> BMeph: i like the quotes
22:21:24 <BMeph> nominolo: Same - it's interesting to meet someone now-a-days that isn't afraid to quote Nietzsche (and Schweitzer). :)
22:21:56 <nominolo> what's wrong with Nietsche?
22:22:31 <nominolo> or Schweitzer?
22:23:38 <BMeph> Nothing in general, but they aren't usually regarded as both worthy of quoting.
22:24:41 <nominolo> zarvok: i don't think so
22:25:58 <zarvok> nominolo: alas I think you're right.  Of course, it doesn't make as much sense as it does for sml-mode, but it would still be nice to be able to write little script files and copy regions in for testing during development
22:26:08 <zarvok> thanks anyway
22:26:52 <nominolo> zarvok: i usually use:  t1 = my expr  C-c C-r  t1 RET
22:27:16 <nominolo> i usually want to keep my test cases anyways, so it's not too bad
22:27:29 <zarvok> nominolo: yeah, I figure that's what I'll do, basically
22:27:55 <zarvok> still, would be nice to easily put them in their own file
22:28:12 <zarvok> I can just manually copy regions though, it's only an extra couple keystrokes
22:28:19 <Trinithis> @vim users: do you know how to set up the make command for a haskell file?
22:28:20 <lambdabot> Maybe you meant: id time v
22:28:43 <nominolo> how does the sml mode find out where the expression ends?
22:29:28 <zarvok> well, in sml-mode, if you ask it to send a region it just sends that whole region
22:29:31 <zarvok> you have to select it yourself
22:29:49 <nominolo> zarvok: ok, that should be simple to duplicate
22:29:54 <zarvok> the mechanism is to actually copy the region in a temp file and then run an sml/nj command which effectivly copies that file in
22:30:19 <zarvok> nominolo: yeah, it could be done (though not the same way) but I'm lazy :)
22:30:23 <zarvok> I may later
22:30:48 <nominolo> make sure to publish it somewhere
22:31:02 <nominolo> probably the haskell wiki would be best
22:31:11 <zarvok> yeah
22:34:18 <scook0> @hoogle unsafePerformIO
22:34:20 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
22:34:20 <lambdabot> System.IO.Unsafe.unsafePerformIO :: IO a -> a
22:40:25 <yoshi> How would I go about making an implicit substitution of text/css into something Haskell can understand; that is, when quotation marks and the character '/' are required (ex: style ! [thetype "text/css"] << toHtml " #navlist li:before { content: " >> ";... /*Win IE browsers...")  the use of quotes are understood as breaking up a string and I get n lexical error in string/character literal at character '/'
22:43:15 <glguy> I know 0x and 0o for hex and octal, but do we have a format for literal binary numbers?
22:43:15 <oerjan> yoshi: put a \ before each " or \
22:43:37 <ddarius> glguy: Nope.
22:43:48 <oklopol> does haskell do floating point hex?
22:44:02 <ddarius> I don't think so, but I'd have to check to be sure.
22:44:48 <oklopol> it's unfair so many programming languages don't support that
22:45:31 <ddarius> What exactly is the usage scenario for them?
22:46:16 <oklopol> the same as for decimal floating point.
22:47:07 <ddarius> To support all those people raised on hexadecimal?  The only reason octal and hexadecimal are supported is that they give a compact way to write binary patterns.
22:47:30 <oerjan> > floatToDigits pi 16
22:47:32 <lambdabot>   add an instance declaration for (Floating Integer)
22:47:39 <oerjan> > floatToDigits 16 pi
22:47:40 <lambdabot>  ([3,2,4,3,15,6,10,8,8,8,5,10,3],1)
22:47:51 <sjanssen> oklopol: which languages do support them?
22:48:05 <oklopol> i'm not sure any commercial language does.
22:48:12 <oklopol> except most scheme interps do
22:48:15 <oklopol> *many
22:48:16 <oerjan> > floatToDigits 10 pi
22:48:17 <lambdabot>  ([3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3],1)
22:48:19 <oklopol> i haven't tried most
22:48:37 <oklopol> oerjan: but haskell doens't support changing syntax
22:48:43 <oklopol> so still discrimination
22:48:49 <oerjan> oklopol: you can use that for printing them
22:48:50 <oklopol> *doesn't
22:48:59 <oklopol> sure, that's not the point
22:49:34 <sjanssen> > 0xf :: Double
22:49:35 <lambdabot>  15.0
22:49:48 <sjanssen> fractional parts aren't supported
22:49:49 <ddarius> > 0xf.f :: Double
22:49:50 <lambdabot>   Not in scope: `f'
22:50:53 <scook0> people have written TH functions that allow (somewhat clumsy) binary literals
22:50:56 <oklopol> i rarely have a need for numbers in source anyway, except for 1..5
22:51:12 <oklopol> so i don't really even see a definite need for floating point numbers.
22:51:30 <sjanssen> it would be quite easy to extend Haskell with fractional hex literals
22:52:06 <sjanssen> though it slightly complicates the language for (what seems to be) very little benefit
22:52:28 * ddarius would say "no benefit"
22:52:53 <yoshi> oerjan: it only seems to be work for quotations, do you know of a relevant wiki page?
22:53:49 <oerjan> yoshi: i was just describing how to escape haskell strings, are you doing something different?
22:54:20 <sjanssen> > fromRational (0xf % 0x10) -- one can always write like this
22:54:22 <lambdabot>  0.9375
22:55:07 <oerjan> yoshi: although i don't understand what / has to do with it, it's perfectly legal in strings
22:55:47 <yoshi> perhaps I have made an error
22:56:08 <oklopol> sjanssen: a bit complicated
22:58:31 <oklopol> i find binary floating point much more intuitive than decimal even though i've grown up with decimal, btw
22:59:10 <oklopol> but if haskell doesn't even have binary, i guess i should whine about that first :P
22:59:21 <oklopol> (i promise i won't)
22:59:27 <ddarius> too late
22:59:42 <oklopol> i guess that was somewhat of a whine already
23:01:00 <blbrown> :t lift
23:01:03 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
23:01:06 <yoshi> oerjan: It looks like \ must be placed in front of the character '*' as well, Thanks
23:01:13 <yoshi> =]
23:01:30 <oerjan> heh, weird
23:02:38 <Cale> How is the next version of Parsec coming along?
23:03:50 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5256
23:04:17 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5257
23:04:41 <brian`> hi, I just pasted those two 5256, 5257 ...
23:05:03 <brian`> could anyone help me figuring out what the problem is?
23:05:18 <ddarius> Cale: I made a project request to put the darcs repo online about a week ago.
23:05:54 <Cale> brian`: Does it compile and not work, or is there an error message?
23:06:04 <ddarius> Cale: I want to have some more usage before I throw it on hackage, but I don't see anything significant (or much at all) needing changes (at least, that would stop a first release).
23:06:12 <Cale> brian`: You're writing another l-system generator? :)
23:06:27 <brian`> Cale, yeah that's what i'm trying to do
23:06:31 <brian`> *** Exception: user error (widgetGetDrawWindow: no DrawWindow available (the widget is probably not realized))
23:06:35 <brian`> it compiles
23:06:42 <brian`> but giving me the above msg when i run it
23:08:10 <Cale> hmm
23:08:29 <Cale> Perhaps that drawWindowBeginPaintRect should be in the onExpose?
23:09:05 <brian`> what is onExpose?
23:09:13 <Cale> brian`: It's complaining that your window isn't constructed and on the screen yet, but you're trying to draw on it.
23:09:26 <brian`> hm...
23:09:30 <Cale> That's an event which happens when a window needs to repaint.
23:09:54 <Cale> (because either it's just been put back on the screen, or some other window has uncovered part of it)
23:10:03 <BMeph> Heh-heh, I like this comment: "It feels like half of what we do when programming is manage side effects like overwriting a variable you are using elsewhere, and the more you can restrict those side effects, the easier programming becomes."
23:10:20 <Cale> BMeph: nice, where is that?
23:11:16 <brian`> Cale, even with exposure event option checked, it gives me the same error message...
23:11:21 <BMeph> It's from Reg Braithwaite. Saw it referenced on a PH post.
23:11:39 <BMeph> Reg's blog entry: http://weblog.raganwald.com/2008/01/objectandand-objectme-in-ruby.html
23:11:39 <lambdabot> Title: Object#andand & Object#me in Ruby, http://tinyurl.com/22gnpf
23:11:55 <Cale> brian`: I mean, you need to put that drawWindowBeginPaintRect inside an event handler...
23:12:19 <BMeph> Haskell: Where side-effects are invoked only when and where YOU want them! ;)
23:12:40 <poodlesucks> someone is calling the police on me for no good reason. please help me :D thank you
23:12:43 <brian`> Cale, oh.. I'll try that
23:12:47 <Cale> drawWindow `onExpose` \(Expose {eventRegion = r}) -> do
23:12:48 <Cale>  ...
23:13:10 <Cale> At least if the API hasn't significantly changed on me :)
23:13:15 <BMeph> me thinks he hears sirens...
23:13:23 * BMeph thinks he hears sirens...
23:14:24 <gwern> hm. any idea what extension 'cannot construct infinite type' might need?
23:14:29 <kscaldef> that's an interesting post because he basically recreates Maybe in it
23:14:58 <oerjan> gwern: a newtype to break the cycle
23:15:15 <gwern> oerjan: no, I mean it compiles with -fglasgow-exts I think, but not without
23:15:32 <kscaldef> I haven't quite figured out if the second half of it (Object#me) maps nicely onto something like the State monad
23:15:33 <gwern> trying to add a LANGUAGE pragma
23:15:45 <oerjan> oh. paste?
23:16:20 <hpaste>  gwern pasted "LANGUAGE and -fglasgow-exts" at http://hpaste.org/5258
23:17:49 <oerjan> hm weird.  perhaps try RankNTypes?
23:18:36 <gwern> that seems to work. good guess!
23:19:26 <Trinithis> how would someone implement sqrt for Integral?
23:19:43 <BMeph> I wonder how many blogs of (you can do this in Haskell, but it's not so easy in Ruby - here's how to hack something like it) it'll take before people start just coming straight over...
23:20:24 <oerjan> Trinithis: awkwardly, if my vague memory of previous discussions is right
23:20:44 <Trinithis> oerjan: I came up with ... sqrt' x = head [y | y <- reverse $ enumFromTo 0 x, y^2 <= x]
23:20:49 <lament> BMeph: didn't help lisp
23:20:59 <Trinithis> oerjan: but i bet its bad
23:21:11 <oerjan> Trinithis: ok not _that_ awkwardly.  i think someone used newton's method as a base
23:21:12 <nominolo> BMeph: i don't think adopting things from other language in <your-favourite-language> is a bad idea
23:21:27 <BMeph> lament: People jumping from lisp to haskell, or ruby to lisp?
23:21:28 <nominolo> BMeph: every language has its tradeoffs
23:21:37 <lament> BMeph: any language to lisp
23:21:42 <brian`> Cale, yeah when I put it in an event handler, it works! thanks :) btw do you know where I can find in-depth tutorial about using gtk2hs?
23:22:01 <gwern> oh no. I hit the infinite extension loop bug again
23:22:04 * Cale wonders why there are so many pages on the internet with "integer" square root "algorithms" that do lots of bitwise magic and don't generalise worth a damn.
23:22:24 * gwern tries to remember which extension it was that I needed to add the last time I encountered this problem
23:22:37 <Cale> brian`: Well, there's http://j-van-thiel.speedlinq.nl/gtk2hs/index.html
23:22:37 <lambdabot> Title: Gtk2Hs Tutorial
23:23:05 <ddarius> Cale: Because that is the more common use case?
23:23:12 <gwern> ah, yes, it was Rank2Types where if you didn't have it specified GHC would loop
23:23:27 <oerjan> > let x = 1024 in iterate (\n -> (n + x `div` n) `div` 2) (x `div` 2)
23:23:28 <lambdabot>  [512,257,130,68,41,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,...
23:23:31 <brian`> Cale, fantastic! :)
23:23:41 <Cale> Maybe I have strange expectations of what people want to do with computers.
23:23:55 <oerjan> > let x = 1025 in iterate (\n -> (n + x `div` n) `div` 2) (x `div` 2)
23:23:56 <lambdabot>  [512,257,130,68,41,33,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,...
23:24:11 <oerjan> > let x = 1023 in iterate (\n -> (n + x `div` n) `div` 2) (x `div` 2)
23:24:12 <lambdabot>  [511,256,129,68,41,32,31,32,31,32,31,32,31,32,31,32,31,32,31,32,31,32,31,32,...
23:24:21 <Trinithis> :t iterate
23:24:22 <lambdabot> forall a. (a -> a) -> a -> [a]
23:24:26 <oerjan> ah, not quite stable
23:24:41 <Cale> If I ever wanted to compute an integer square root, I'm pretty sure I'd be horribly unsatisfied with anything that only worked on 32 bit integers.
23:25:01 <nominolo> could be faster, though
23:25:33 <Tac-Tics> sqrt 17 :: Int -- PWNED
23:26:59 <poodlesucks> hi help me people are calling the police on me after using Linux :D thank you
23:28:11 <oerjan> Trinithis: that is faster than testing every integer up to it, at least
23:28:16 <ddarius> Cale can you please kick poodlesucks?
23:28:48 --- mode: ChanServ set +o Cale
23:28:49 <Trinithis> oerjan: :D. Not sure how the logic works, but okay
23:28:55 --- mode: Cale set +b *!*@CPEe8dd5640e290-CM00194757ed42.cpe.net.cable.rogers.com
23:29:14 <yoshi> :t  :t "IE\*/"
23:29:14 <lambdabot> parse error on input `:'
23:29:16 --- mode: Cale set -o Cale
23:29:27 <oerjan> Trinithis: it gradually improves the approximation to the real sqrt
23:29:47 <Tac-Tics> what is the point of -o'ing afterwards? (/me knows little of the ways of IRC)
23:30:04 <ddarius> Tac-Tics: People in #haskell don't keep op
23:30:08 <Tac-Tics> is it to express your humbleness afterwards?
23:30:29 <Tac-Tics> that you step up, take action, and then step down gracefully?
23:31:01 <yoshi> where is there an operator in "IE\*/" ? is that not just a string?
23:31:07 <ddarius> Not really.  It's probably more for personal convenience than "humbleness".  Also it's just conventional by now.
23:32:44 <Cale> It's considered a little rude to wear your +o all the time.
23:35:02 <oerjan> Tac-Tics: reminds me of the ancient roman dictators...
23:35:22 <oerjan> :t "IE\*/"
23:35:24 <lambdabot> lexical error in string/character literal at character '/'
23:35:29 <oerjan> oh
23:35:33 <Tac-Tics> oerjan: Did they +o to kick out spammers from Rome?
23:35:41 <oerjan> yoshi: you cannot have \ before *, actually
23:35:53 <qebab> Tac-Tics: they +praetorian'd instead, back then
23:36:09 <yoshi> yes I'm just realizing that
23:36:15 <oerjan> Tac-Tics: no, but the dictators did the stepping down gracefully bit, at least some of them
23:36:22 <yoshi> > '"':[]
23:36:23 <lambdabot>  "\""
23:36:26 <yoshi> ??
23:37:15 <Tac-Tics> :t "IE\*/"
23:37:16 <lambdabot> lexical error in string/character literal at character '/'
23:37:29 <ddarius> :t "IE\\*/"
23:37:30 <lambdabot> [Char]
23:37:31 <Tac-Tics> :t "IE\\*/"
23:37:31 <lambdabot> [Char]
23:38:22 <oerjan> yoshi: in case i wasn't clear, don't put \ before the initial and final " of a String
23:38:50 <BMeph> @go roman dictator
23:38:52 <lambdabot> http://en.wikipedia.org/wiki/Roman_dictator
23:38:53 <lambdabot> Title: Roman dictator - Wikipedia, the free encyclopedia
23:39:07 <oerjan> yoshi: perhaps paste part of your program which has a syntax error
23:40:35 <gwern> Tac-Tics: remember Cincinnatus, who became proverbial
23:40:55 <Tac-Tics> I never took any classes about Roman history in all my schooling
23:40:58 <yoshi> toHtml "#navlist li:before { content:  "   >> "; }"
23:41:26 <yoshi> toHtml "hide from Mac IE\*/ * html"
23:42:26 <gwern> (how low high culture has fallen. there was a time where knowledge of such as Cincinnatus could be taken for granted)
23:43:05 <Tac-Tics> during Cincinnatus's time, no doubt
23:43:05 <kilimanjaro> yea then he died
23:43:08 <Tac-Tics> heh
23:43:11 <oerjan> @show #navlist li:before { content:  "   >> "; }
23:43:11 <lambdabot> "#navlist li:before { content:  \"   >> \"; }"
23:43:53 <oerjan> yoshi: like that, escape only the inner "'s as well as inner \'s if you have any
23:44:20 <oerjan> @show hide from Mac IE\*/ * html
23:44:20 <lambdabot> "hide from Mac IE\\*/ * html"
23:44:47 <blbrown> @src foldl
23:44:48 <lambdabot> foldl f z xs = lgo z xs
23:44:48 <lambdabot>     where lgo z []     =  z
23:44:48 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
23:45:01 <Cale> ugh
23:45:05 <Cale> foldl f z [] = z
23:45:10 <Tac-Tics> heh, you did it again
23:45:16 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
23:45:24 <blbrown> Cale: dont like it, hehe
23:45:52 <Cale> I hate the responces from @src with regard to foldl, foldr and sequence,
23:46:04 <Cale> They're needlessly ugly.
23:46:06 <oerjan> @src foldr
23:46:06 <lambdabot> foldr k z xs = go xs
23:46:06 <lambdabot>     where go []     = z
23:46:06 <lambdabot>           go (y:ys) = y `k` go ys
23:46:14 <Cale> foldr f z [] = z
23:46:18 <Tac-Tics> @remember Cale  Cale: ugh, Cale: foldl f z [] = z
23:46:18 <lambdabot> I will remember.
23:46:30 <blbrown> @src foldl
23:46:30 <lambdabot> foldl f z xs = lgo z xs
23:46:30 <lambdabot>     where lgo z []     =  z
23:46:30 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
23:46:31 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
23:46:41 <blbrown> I guess you can't redefine them
23:47:06 <Cale> blbrown: I should. I have source access to lambdabot.
23:47:28 <Cale> I'm not exactly sure how they're stored though.
23:47:41 <Cale> (but that's no excuse, I could figure it out)
23:48:42 <oerjan> oh, the report versions are what Cale said, not @src's versions
23:49:15 <Cale> The @src versions are hacks to get GHC to compile slightly better code, because it lacks a certain optimisation.
23:49:29 <Cale> The next version of GHC won't need the hacks.
23:50:46 <Cale> Unfortunately, they serve almost no pedagogical purpose.
23:51:31 <Tac-Tics> Which is what Lambdabot is best for
23:51:53 <Tac-Tics> Without lambdabot, I'm sure half of the people in this channel wouldn't be here right now
23:52:08 <Tac-Tics> It turns learning haskell into something painful into something almost goofy and fun
23:52:30 <ddarius> Lambdabot didn't exist when I started Haskell.
23:53:00 <BMeph> ddarius: You had to program in the snow, going uphill both ways? ;)
23:53:01 <Tac-Tics> ddarius: you get to be in the half I'm not talking about then
23:53:02 <Cale> I'm not sure if it existed when I started Haskell. At the very least it was something new.
23:53:39 <Cale> hs-plugins didn't exist when I started Haskell, so no run plugin and no @pl
23:54:13 <ddarius> lambdabot was one of the earliest things I hacked on.
23:54:39 <ddarius> Dynamic loading of code didn't come for a while, but it was pioneered primarily on lambdabot.
23:55:17 <Cale> Actually, I think I might have been one of the people to suggest it as an idea for something to work on.
23:55:40 <ddarius> It was brought up several times before something actually got started.
23:56:01 <Cale> I vaguely recall dons asking around if anyone had ideas for Haskell projects :)
23:56:02 <Tac-Tics> Does Lambdabot still follow the method used in the paper? I know Yi's dynamic loading has been overhauled
23:57:43 <Trinithis> "The next version of GHC won't need the hacks." - Cale
23:57:46 <Trinithis> why
23:57:46 <ddarius> lambdabot has used every method of dynamic code loading that has been announced.
23:58:00 <Tac-Tics> what does that mean?
23:58:44 <ddarius> I'm not sure if the mainline one has switched to a GHC API based approach yet, but I'm pretty sure someone has done the work already.
23:58:46 <Cale> Trinithis: because it includes an optimisation which does that code transformation
