01:58:22 <fnord124> whois dons
02:00:23 <Lemmih> He's a Haskell hacker.
02:00:40 <fnord124> I forgot the /
02:02:41 <halassocracy> heh
02:07:34 <ivanm> I thought he was _the_ haskell hacker... :o
02:25:31 <Lycurgus> well close, he's damn near The Haskell hacker
02:29:32 <Lycurgus> sorry ivanm didn't see you'd already done the suck up service for the channel :)
02:32:33 <ivanm> heh
02:39:55 <Lemmih> The Oleg, the Dons and the Holy Simons, we call on you to keep us pure and save us from temptation. May ye forever typecheck.
03:06:18 <olsner> hmm, how about writing a haskell extension that takes every operator with >'s or <'s and autogenerates the flipped version (=<<) = flip (>>=), (<<) = flip (>>) etc
03:07:02 <qweqwe> what is wrong here ?
03:07:07 <qweqwe> f2::(Num a)=>a->a->Bool
03:07:08 <qweqwe> f2 x y = y `mod` x /=0
03:08:19 <qweqwe> Inferred type is not general enough
03:09:09 <scook0> @type mod
03:09:10 <lambdabot> forall a. (Integral a) => a -> a -> a
03:09:54 <scook0> qweqwe: you may need to change your signature from Num to Integral
03:10:11 <qweqwe> why num is not good ?
03:10:35 <qweqwe> by the way it solved the problem
03:10:36 <scook0> because instances of Num are not necessarily required to support mod
03:10:52 <scook0> mod requires Integral, which is more specific than Num
03:11:41 <olsner> argh, worthless error messages: "An unexpected error has occured"
03:13:57 <roconnor> olsner: how about ``The impossible just happend''
03:14:37 <olsner> nah, that error message is witty enough to make up for its own uselessness
03:37:58 <scook0> heck, "the impossible just happened" is at least somewhat informative
03:38:09 <scook0> it tells you that a sanity check failed
03:39:20 <olsner> does it also say which sanity check failed?
03:43:59 <hpaste>  larmeh pasted "parse error on input `='" at http://hpaste.org/4801
03:44:51 <larmeh_> any ideas why there is a parse error at line 5?
03:44:51 <shachaf> larmeh_: You have extra indentation.
03:45:13 <shachaf> larmeh_: The definition should be as indented as the type signature.
03:45:36 <shachaf> larmeh_: (Also, you should use spaces. :-) )
03:46:07 <larmeh_> ahh ok. use spaces? where?
03:46:18 <shachaf> Also, you want to call Any.any, or import Prelude hiding any.
03:48:51 <olsner> or import qualified Prelude and any = Prelude.any :P
03:49:28 <desegnis> Does anyone else experience vim literate haskell highlighting (lhaskell.vim 1.01, Aug 31, 2004) to get utterly confused whenever the lhs file includes one of the strings  \begin{document}, \section{bla}, \subsection{bla}, as well as some other strings?
03:50:25 <shachaf> olsner: Or just import Prelude (any).
03:50:34 <desegnis> Namely, it well then highlight everything as TeX, nothing as Haskell.
03:50:49 <shachaf> desegnis: I remember there being some problem with that.
03:51:30 <olsner> shachaf: but that wouldn't re-export the 'any' function in the Any module, would it?
03:51:42 <desegnis> shachaf, maybe you even remember someone with a fix for that problem?
03:52:09 <shachaf> desegnis: No, sorry.
03:52:16 <shachaf> desegnis: Tell me if you solve it, though. :-)
03:52:22 <desegnis> sure :)
03:53:53 <shachaf> desegnis: Perhaps someone in #vim will know.
03:54:06 <desegnis> ah, good idea
03:56:08 <hpaste>  larmeh_ pasted "proper code?" at http://hpaste.org/4802
03:57:01 <larmeh_> it works now, thanks to you shachaf but is it also properly formatted?
03:57:21 <shachaf> larmeh_: I guess so.
03:57:36 <shachaf> larmeh_: Usually the :: isn't indented like the =, I think.
03:57:55 <shachaf> larmeh_: But it certainly could be. :-)
03:57:59 <olsner> you don't have to line things up like that, that's just something some people like to do because they like the look
03:58:44 <larmeh_> well, i like the look too, i guess... thanks so far :)
03:59:56 <qweqwe> how i check that a virable is not null
04:00:03 <qweqwe> i mean not []
04:00:52 <shachaf> > null []
04:00:54 <lambdabot>  True
04:01:11 <shachaf> qweqwe: Or you could pattern match.
04:01:52 <qweqwe>  > null []
04:02:01 <qweqwe> > null []
04:02:02 <lambdabot>  True
04:02:05 <qweqwe> cool
04:02:11 <qweqwe> > null a
04:02:12 <lambdabot>   Not in scope: `a'
04:02:34 <shachaf> qweqwe: Can you give some more context?
04:02:41 <shachaf> > null [1]
04:02:42 <lambdabot>  False
04:03:14 <byorgey> > let f [] = 6 ; f (x:xs) = x  in (f [], f [1,2,3])
04:03:15 <lambdabot>  (6,1)
04:13:37 <qweqwe> what is wrong here ?
04:13:38 <qweqwe> matches::[Char]->[Char]->Int->Int->[Int]
04:13:38 <qweqwe> matches [] _ _ _ = []
04:13:38 <qweqwe> matches (x:xs) ys index misses = if(match (x:xs) ys misses) then index:(matches xs ys (index+1))
04:13:38 <qweqwe>                                                else (matches xs ys (index+1) misses)
04:14:10 <qweqwe> *** Type           : Int -> [Int]
04:14:11 <qweqwe> *** Does not match : [a]
04:14:43 <shachaf> qweqwe: Well, for one, you're not giving matches enough arguments in the then case.
04:15:49 <qweqwe> yep thanks
04:18:09 <hpaste>  desegnis pasted "Vim lhs highlighting hack" at http://hpaste.org/4803
04:18:41 <desegnis> shachaf: I hacked together something looking like a solution to my problem
04:20:00 <shachaf> desegnis: You might want to put it on the wiki.
04:20:11 <shachaf> desegnis: I'm sure other people have had the same problem. :-)
04:21:06 <desegnis> right. But before that, I'll have to investigate how to make vim always parse the whole file. Because it will chuckle on lhs files with large code sections, too
04:23:43 <desegnis> Argh. After half an hour's hacking, I find an archived haskell-cafe post with the solution...
04:38:55 <s710b> where can i find more information about using lambda expressions in haskell?
04:39:49 <shachaf> s710b: What type of information are you looking for?
04:40:21 <shachaf> @wiki Lambda abstraction
04:40:22 <lambdabot> http://www.haskell.org/haskellwiki/Lambda_abstraction
04:40:26 <s710b> i shall implement the boolean data type with lambda expressions. im looking for a general understanding first
04:41:12 <pejo> s710b, I think you want some kind of lambda calculus tutorial.
04:42:01 <s710b> i know the lambda calculus in theory, but im not sure how to do it in haskell...
04:42:24 <shachaf> true = \x y -> x; false = \x y -> y?
04:42:32 <dcoutts> dons: what kind of bytestring parse lib do you use?
04:42:55 <dcoutts> dons: I was thinking of looking at polyparse
04:44:14 <roconnor> s710b: be aware that untyped lambda calculus terms often do not translate to typed lambda terms.
04:44:38 <s710b> shachaf: so boolean would be sthg like: data Boolean = true | false and then define true and false like you did?
04:45:16 <notsmack> s710b: no, that's not how type definitions work
04:45:29 <shachaf> Oh, that would be «data Bool = False | True».
04:45:49 <notsmack> (which then don't need any lambda definition)
04:48:15 <s710b> shachaf, notsmack : i know how to do it without lambda but how do i do the equivalent with lambda?
04:48:39 <shachaf> s710b: Do what?
04:48:46 <notsmack> s710b: the lambda calculus doesn't have named data types, i don't think there's much of a translation...
04:49:10 <s710b> thats what i was thinking
04:50:06 <pejo> s710b, how would you do what you're trying to do in lambda calculus?
04:52:09 <desegnis> shachaf: Anyways, my updated lhaskell.vim is on the wiki now
04:52:17 <s710b> pejo: that was my question :) maybe sthg like data MyBool = MyTrue | MyFalse; MyTrue = \x y -> x; MyFalse= \x y -> y
04:52:41 <desegnis> s710b: »data« isn't lambda calculus
04:52:49 <desegnis> It's Haskell, rather
04:53:00 <shachaf> desegnis: Thanks! What's the page called?
04:53:18 <desegnis> shachaf, http://haskell.org/haskellwiki/Literate_programming/Vim
04:53:20 <shachaf> s710b: You'de define myTrue = \x y -> x; myFalse = \x y -> y as regular functions.
04:53:40 <shachaf> Hmm, the search doesn't find it.
04:54:13 <desegnis> shachaf: Did you search for vim? That may not be indexed properly due to it being a three-letter word.
04:54:35 <shachaf> Oh, right.
04:54:47 <shachaf> Searching for "lhaskell" works.
04:55:11 <desegnis> It's hyperlinked from the Literate programming page anyways.
04:55:26 <s710b> shachaf, desegnis : i will try a little more, thanks for the tips
04:55:54 <resiak> hrm.  trying to build the hfuse docs gives me "parse error in doc string: [haddock: Internal Happy error"
05:02:19 <Betovsky> @src sequence
05:02:20 <lambdabot> sequence ms = foldr k (return []) ms
05:02:20 <lambdabot>     where
05:02:20 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
05:03:32 <shachaf> k = liftM2 (:)
05:04:01 <shachaf> @seen dons
05:04:01 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 6h 17m 2s ago.
05:04:32 <shachaf> Oh, never mind.
05:06:48 <bogner> @src sequence_
05:06:48 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
05:07:07 <Betovsky> hi ppl
05:07:10 <Betovsky> need a hint
05:07:18 <Betovsky> dont understand why this doesn't work
05:07:25 <guenni> hi guys
05:07:46 <shachaf> guenni: Hello.
05:07:55 <guenni> btw does anybody have the solutions to the exercises in Birds book?
05:08:03 <Betovsky> (sequence $ take 1 (fix (randomRIO (1,10):))) >>= print
05:08:18 <dmhouse> ?type randomRIO
05:08:20 <lambdabot> forall a. (Random a) => (a, a) -> IO a
05:08:35 <dmhouse> ?type fix (randomRIO (1,10) :)
05:08:36 <lambdabot> forall t. (Num t, Random t) => [IO t]
05:08:50 <Betovsky> when I put the sequence it gives always stack overflow
05:08:52 <dmhouse> Betovsky: what is it meant to do?
05:08:55 <Betovsky> even if i make take 1
05:09:28 <Betovsky> fix (randomRIO (1,10):) <- make an infinite list of random numbers between 1 and 10
05:09:41 <Betovsky> type is [IO Integer]
05:09:43 <dmhouse> Oh, you want to continuously print a list of random numbers, I guess, and your take 1 is there to try to avoid the stack overflow.
05:09:50 <dmhouse> ?type forever
05:09:51 <lambdabot> Not in scope: `forever'
05:10:06 <dmhouse> I thought that went in.
05:10:07 <Betovsky> something like that
05:10:19 <mux> dmhouse: it did, but this lambdabot still has GHC 6.6.2
05:10:25 <dmhouse> forever :: Monad m => m a -> m () -- in GHC 6.8
05:10:27 <mux> Prelude Control.Monad> :t forever
05:10:27 <mux> forever :: (Monad m) => m a -> m ()
05:10:29 <Betovsky> the idea is to have a function to make an infinite list because before hand i dont know how many numbers i want
05:10:40 <dmhouse> So try forever (randomRIO (1,10) >>= print)
05:10:42 <guenni> is there a "haskell beginners" channel?
05:10:50 <shachaf> guenni: #haskell. :-)
05:11:03 <guenni> shachaf: thx
05:11:12 <shachaf> guenni: Feel free to ask questions here.
05:11:21 <guenni> I just did :)
05:11:26 <byorgey> isn't there a function like randomRIOs that does that for you already?
05:11:33 <Betovsky> dmhouse the print is there only to debug
05:11:43 <dmhouse> Betovsky: ah, okay.
05:11:46 <Betovsky> i want is a [Integer]
05:11:58 <dmhouse> Well, IO [Integer], obviously, but okay.
05:12:00 <guenni> I could do with the solutions to the exercises in birds book, does anybody here have them?
05:12:04 <Betovsky> or IO [Integer] since it is in the IO
05:12:36 <byorgey> Betovsky: that won't really work in IO, you'd need unsafeInterleaveIO
05:12:55 <dmhouse> Betovsky: have you tried using randomRs?
05:13:02 <byorgey> Betovsky: I think what you want to do is use getStdGen and then randomRs
05:13:41 <Betovsky> oky
05:13:45 <Betovsky> going to check that
05:13:46 <Betovsky> thx
05:14:10 <Betovsky> but i still dont understand why it gives stack overflow
05:16:29 <byorgey> Betovsky: it's because you can't perform just part of an IO action.
05:16:40 <guenni> is there anybody here who recently went through Birds book?
05:16:56 <shachaf> guenni: Do you have a specific question about it?
05:17:07 <byorgey> Betovsky: so if you have something of type IO [Integer], you can't use the returned list lazily
05:17:12 <dmhouse> guenni: is there a specific exercise you want an answer to?
05:17:36 <notsmack> byorgey: huh...
05:17:36 <byorgey> Betovsky: well, I think it's more subtle than that... I wouldn't say that I understand it 100% but it's something along those lines =)
05:17:59 <guenni> shachaf: indeed, I got myself a couple of books for haskell now, and I just restarted reading birds book again ...
05:18:01 <notsmack> byorgey: you can do, say getContents and read that lazily...
05:18:13 <Betovsky> its happening the samething with randomRs
05:18:15 <guenni> ... so I'm back on the exercises
05:18:15 <byorgey> notsmack: well, getContents is special =)
05:18:19 <Betovsky> Prelude Random> let f = getStdGen >>= return . take 20 . randomRs (1,10)
05:18:19 <Betovsky> Prelude Random> f >>= print
05:18:19 <Betovsky> [*** Exception: stack overflow
05:18:23 <dmhouse> Prelude System.Random> sequence [randomRIO (1,10)]
05:18:23 <dmhouse> [5]
05:18:27 <Betovsky> is it a bug of GHCi ?
05:18:29 <guenni> especially the first ones
05:18:50 <guenni> chapter one that is, and I wonder if the solutions are available online
05:19:02 <dmhouse> Prelude System.Random> sequence (take 1 . repeat $randomRIO (1,10))
05:19:02 <dmhouse> [8]
05:19:22 <resiak> Out of interest, does anyone use haskell-unsafe on Ubuntu?
05:19:38 <byorgey> Betovsky: that's strange, it works fine for me
05:19:46 <Betovsky> Prelude Random> sequence (take 1 . repeat $randomRIO (1,10))
05:19:46 <Betovsky> [*** Exception: stack overflow
05:19:48 <Betovsky> lol
05:19:55 <guenni> I mean it just occured to me what these particular exercises are, they're entirely abstract
05:20:26 <dmhouse> Prelude System.Random Control.Monad.Fix> sequence . take 1 $ fix (randomRIO (1,10) :)
05:20:26 <dmhouse> [2]
05:20:27 <shachaf> guenni: Do you have a problem with your solutions, or do you just want to compare?
05:20:48 <byorgey> Betovsky: what version of ghc do you have?
05:20:53 <Betovsky> 6.8.1
05:21:06 <Betovsky> hmm
05:21:08 <Betovsky> weird
05:21:15 <Betovsky> it closed ghci
05:21:21 <Betovsky> and opened again and it works fine now
05:21:28 <guenni> shachaf: I'd like to test my understanding of the exercises, would the exercise 1.2.3 be considered about "symbolic computation"?
05:21:37 <byorgey> Betovsky: that's... bizarre!
05:21:57 <shachaf> @tell dons You should probably add a link to haskell-08 on http://www.cse.unsw.edu/~dons/irc/.
05:21:57 <lambdabot> Consider it noted.
05:22:01 <Betovsky> yeah
05:22:18 <Betovsky> probably it gave the first stack overflow in a first testing
05:22:34 <Betovsky> and then on the nexts ones it gave always
05:22:36 <guenni> the last time I went through the exercise I didn't, I just passed it, because I didn't understand what the exercise is about
05:22:37 <Betovsky> i dont know
05:22:40 <Betovsky> but thx
05:23:20 <guenni> now I believe to understand what the exercise is about, but of course do not have the solution yet ...
05:24:26 <guenni> shachaf: is that somewhat understandable?
05:24:27 <shachaf> guenni: I don't know, I haven't read the book. :-)
05:24:35 <shachaf> guenni: What is the exercise about?
05:25:27 <guenni> that'd be really difficult to describe shachaf, if you don't have the book
05:25:42 <geocalc> lol
05:25:59 <guenni> shachaf: what do you read to learn haskell?
05:27:26 <geocalc> guenni=<< can't you past the exercice ?
05:28:05 <guenni> ooh, not really I just have the print version
05:28:53 <geocalc> how many lines ?
05:29:29 <notsmack> geocalc: heh, let him be if he doesn't want to type it
05:29:47 <geocalc> hehe
05:29:53 <guenni> lemme see if I can find a pdf of the book
05:30:48 <geocalc> wow be nice to share it then guenni !
05:31:12 <guenni> I'll try geocalc
05:31:21 <shachaf> notsmack: Well, it's a little harder to help it without knowing what the exercise is about. :-)
05:36:12 <dcoutts> bos: any opinions to share with kolmodin about how hinotify should be designed? we were reading your post on pynotify
05:36:45 <dcoutts> bos: hinotify does not yet use a bunching threshold as you suggest
05:37:05 <dcoutts> ie waiting n millisec for more events to accumulate to process them in batches more effeciently
05:39:50 <olsner> what's hinotify?
05:42:19 <guenni> shachaf sry I just tried to scan it, no luck
05:42:48 <pejo> olsner, inotify reports changes in filesystems to applications.
05:43:27 <olsner> ah, h-inotify, I read it hi-notify, and thought it was somehow related to .hi-files
05:43:49 <shachaf> guenni: Is it that long? :-)
05:43:53 <kolmodin> bos: I'd like to get the details on the test you performed with pyinotify, so we can repeat it with hinotify
05:44:25 <kolmodin> to see if it blows up or not :D
05:44:37 <guenni> shachaf: quite, and to read it properly one need the indentation as well
05:45:24 <guenni> I think it's a very good book, but I lack the requiered background to grasp it
05:45:55 <guenni> the first exercises are entirely symbolic it seems
05:46:23 <guenni> it's just about reducing expressions
05:46:46 <guenni> and I had a hard time figuring even that out
05:50:13 <pejo> guenni, what book are you talking about?
05:51:29 <shachaf> pejo: 08:16 < guenni> is there anybody here who recently went through Birds book?
05:52:56 <halassocracy> maybe intro to functional programming or algebra of programming
05:53:23 <shachaf> Oh, he wrote more than one?
05:53:40 <halassocracy> i think so
06:07:50 <guenni> the book is "introduction to functional programming using haskell"
06:10:49 <desegnis> Hmm, is that book still up to date? For the 1998 edition, the publisher informs that it »now uses Haskell 3.1«...
06:11:15 <Saizan> has anyone explored a second-order typeclass system?
06:20:16 <bogner> Saizan: aren't the type related compiler errors complicated enough for you? :p
06:20:52 <Saizan> bogner: nah, i understand most of them at this point :)
06:21:30 <bogner> you're doin' better than me
06:23:14 <Saizan> heh, probably a matter of time
06:31:07 <waern> question: does DrIFT search the hierarchical namespace for modules?
06:31:51 <dancor> how do i go from IO GHC.Conc.ThreadId to IO ()?  i just want my main to wait on this thread forever
06:32:22 <visof> please anyone send lambdabot to #eglug
06:33:17 <shachaf> Are there plans to make the arrows package work with a recent (darcs) GHC?
06:33:25 <shachaf> That is, with Control.Category?
06:34:23 <visof> ok don't send lambdabot to #eglug
06:35:04 <shachaf> visof: Compile your own. :-)
06:35:11 <visof> ok
06:35:14 <dancor> i guess if i just have my main thread sleep forever the thread will just run?  how do you sleep forever without spinning cpu
06:36:45 <bartw> mutex/event for c like applications
06:40:36 <roconnor> shachaf: that;
06:40:47 <roconnor> shachaf: that's mean asking someone to compile lambdabot themselves.
06:41:10 <shachaf> roconnor: I'm just going through the same process. :-)
06:41:14 <Saizan> dancor: waiting for a thread is usually implemented with a MVar ()
06:41:21 <roconnor> shachaf: *L* good luck
06:41:21 <shachaf> roconnor: Using GHC 6.9.200810101, too.
06:41:43 <Saizan> dancor: that the working thread will fill when it terminates
06:42:04 <olsner> was that 6.9.2008-10-10-1?
06:42:39 <shachaf> Oops.
06:42:45 <shachaf> 6.9.20080101, sorry.
06:43:01 <olsner> ah, I thought so ;-)
06:43:29 * shachaf considers using 6.8.2 instead.
06:46:44 <matthew-_> if you have some function definitions that do pattern matching directly on their args, and an arg is presented that doesn't match anything and the final type is a monad, does in call fail ?
06:47:01 <matthew-_> > let f 1 = return 1 in f 2
06:47:02 <lambdabot>   add an instance declaration for (Show (m t))
06:47:34 <matthew-_> > let f 1 = Just 1 in f 2
06:47:36 <lambdabot>   Non-exhaustive patterns in function f
06:47:51 <matthew-_> hmm. that doesn't look like it's come out of fail...
06:48:11 <shachaf> matthew-_: That doesn't even get to anything monadic.
06:48:21 <shachaf> matthew-_: It's just plain pattern-matching that fails.
06:48:24 <matthew-_> > let f a = do { 1 <- a; Just 1 } in f (Just 2)
06:48:24 <lambdabot>  Nothing
06:48:28 <shachaf> matthew-_: Maybe you're thinking of do-notation?
06:48:37 <matthew-_> yes - is it specific to do-notation then?
06:48:38 <shachaf> Yes, that does call fail.
06:48:46 <shachaf> @where report
06:48:46 <lambdabot> http://www.haskell.org/onlinereport/
06:51:02 <shachaf> matthew-_: http://www.haskell.org/onlinereport/exps.html
06:51:03 <lambdabot> Title: The Haskell 98 Report: Expressions
06:51:55 <shachaf> matthew-_: do {p <- e; stmts} === let { ok p = do {stmts}; ok _ = fail "..." } in e >>= ok
06:52:35 <matthew-_> shachaf: yeah, I've looked at that page...
06:52:41 <shachaf> matthew-_: This also happens in list comprehensions (or should).
06:52:49 <shachaf> @src catMaybes
06:52:49 <lambdabot> catMaybes ls = [x | Just x <- ls]
06:52:58 <shachaf> But not in general pattern matching.
06:53:35 <matthew-_> I see. that makes much sense.
06:57:35 <nornagon> @undo do { Just x <- ls ; return x }
06:57:36 <lambdabot> ls >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
06:58:02 <nornagon> @pl \ls -> ls >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
06:58:02 <lambdabot> (line 1, column 32):
06:58:02 <lambdabot> unexpected "{"
06:58:02 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<" or end of input
06:58:20 <faxathisia> @pl \x -> length x ++ x ++ length x
06:58:20 <lambdabot> liftM2 (++) length (ap (++) length)
06:58:45 <matthew-_> nornagon: ahh, super
06:58:58 <faxathisia> @pl \x y -> y ++ x ++ y
06:58:58 <lambdabot> ap (++) . (++)
06:59:01 <nornagon> matthew-_: eh?
06:59:19 <shachaf> @undo do { x <- ls; return x } -- @undo is clever
06:59:19 <lambdabot> ls >>= \ x -> return x
07:00:43 <JanglerNPL> @pl (\x y -> f x == f y)
07:00:43 <lambdabot> (. f) . (==) . f
07:01:04 <nornagon> @unpl (.).(.)
07:01:05 <lambdabot> (\ i b c f -> i (b c f))
07:01:55 <faxathisia> @src on
07:01:56 <lambdabot> (*) `on` f = \x y -> f x * f y
07:02:18 <sjw`> dons: why doesn't Haskell have something like Rails or Django?  Get to work! :)
07:02:30 <faxathisia> JanglerNPL: == `on` f  :D
07:02:37 <shachaf> sjw`: There's HAppS.
07:02:39 <faxathisia> sorry (==) `on` f
07:02:42 <shachaf> sjw`: And WASH.
07:02:48 <shachaf> sjw`: And a few others, I think.
07:03:14 <sjw`> don't know HApps
07:03:28 <matthew-_> it would be generally nice for ghci to say "try loading this extension" rather than "parse error"
07:03:40 <shachaf> matthew-_: It does, sometimes.
07:03:46 <shachaf> matthew-_: Which extension are you thinking of?
07:03:58 <matthew-_> I think, existentalquantification
07:04:15 <matthew-_> if you add a forall m . ... then it just goes "parse error"
07:04:29 <sjw`> shachaf: My point was that those other apps seem to mesh the DB/Web/... stuff together with minimal pain
07:04:46 <shachaf> matthew-_: let id :: forall a. a -> a; id x = x
07:04:57 <shachaf> Oh, wait.
07:04:59 <matthew-_> yeah, that sorta thing
07:05:03 <shachaf> It's recommending the wrong extension. :-)
07:05:03 * sjw` googles HAppS
07:05:21 <shachaf>     Illegal operator `.' in type `forall a . (a -> a)'
07:05:21 <shachaf>       (Use -XTypeOperators to allow operators in types)
07:05:22 <matthew-_> mmm. ghci 6.8.2 is just refusing to load the module here
07:06:01 <faxathisia> :t liftM2 (++) length (ap (++) length)
07:06:03 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Int'
07:06:03 <lambdabot>       Expected type: [a1] -> [a]
07:06:03 <lambdabot>       Inferred type: [a1] -> Int
07:06:12 <desegnis> also, »forall a. (Num a) => a« will give a plain parse error
07:06:13 <shachaf> sjw`: HAppS does that, to some degree, I understand.
07:06:16 <faxathisia> @pl True + 1
07:06:16 <lambdabot> True + 1
07:06:38 <matthew-_> desegnis: yes, that's what I've got
07:07:25 <shachaf> faxathisia: @pl doesn't know about types.
07:07:36 <shachaf> @pl \x -> x x
07:07:36 <lambdabot> join id
07:08:11 <shachaf> Wait.
07:08:22 <faxathisia> :t join id
07:08:22 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
07:08:22 <lambdabot>     Probable cause: `id' is applied to too many arguments
07:08:22 <lambdabot>     In the first argument of `join', namely `id'
07:08:22 * shachaf was using 6.8.2 for this, actually.
07:09:11 <matthew-_> I do like how the ghc user guide just says "use -fglasgow-exts"
07:09:14 <matthew-_> yeah, swell...
07:09:25 <JanglerNPL> @where on
07:09:26 <lambdabot> I know nothing about on.
07:09:34 <JanglerNPL> @index on
07:09:34 <lambdabot> bzzt
07:09:56 <faxathisia> @src on
07:09:56 <lambdabot> (*) `on` f = \x y -> f x * f y
07:10:11 <shachaf> Data.Function.
07:13:35 <sjw`> shachaf: cheers, HAppS looks better than what I thought was out there.  I was also just dons-baiting :)
07:14:11 <shachaf> sjw`: HPaste is written with HAppS, for example.
07:15:54 <hpaste>  matthew-_ pasted "Comments on my confusion?" at http://hpaste.org/4804
07:16:34 <bogner> what's the easiest way to do integer division, rounding up?
07:16:37 <matthew-_> ^^ has behaviour changed between 6.6 and 6.8 on this or am I just totally confused and wrong?
07:16:43 <drkm> what is haskell??
07:17:02 <DuClare> who are you?
07:17:08 <drkm> I am me, who are you
07:17:16 <DuClare> what a coincidence, I am me too
07:17:28 <drkm> nice.. now what's haskell?
07:17:34 <faxathisia> drkm: Programming Language
07:17:39 <drkm> for programming waht
07:17:40 <drkm> what*
07:17:44 <matthew-_> @where yaht
07:17:44 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
07:17:58 <matthew-_> drkm: the above are useful tutorials you might like to look at
07:18:03 <DuClare> matthew-_, is yaht better than the other book on haskell @ wikibooks?
07:18:13 <shachaf> matthew-_: I think those should be the same.
07:18:16 <faxathisia> drkm: It's general purpose and capable of computing pretty much anyway..
07:18:17 <matthew-_> yaht seems to get the most recommendations
07:18:27 <DuClare> shachaf, the other is a pdf version of it
07:18:31 <DuClare> same thing
07:18:37 <DuClare> I believe?
07:18:42 <matthew-_> shachaf: are you talking about my hpaste?
07:18:54 <doserj> matthew-_: LANGUAGE ScopedTypeVariables ?
07:18:55 <shachaf> matthew-_: Yes.
07:19:17 <DuClare> o, actually wikibooks links to darcs
07:19:18 <shachaf> (By the way, join . fmap f == (>>= f).)
07:19:33 <matthew-_> hang on, you can now do ExistentialQuantification without ScopedTypeVariables ?
07:20:09 <doserj> I think so
07:20:10 <shachaf> matthew-_: How are you compiling it?
07:20:13 <matthew-_> ghci
07:20:30 <shachaf> matthew-_: -XExistentialQuantification?
07:20:33 <matthew-_> no
07:20:35 <matthew-_> no extensions
07:20:46 <shachaf> matthew-_: Why would the forall work, then?
07:20:47 <matthew-_> unless ghci has got its pants in a twist...
07:21:05 <matthew-_> well, with the forall version, yes I added {-# LANGUAGE ExistentialQuantification #-}
07:21:18 <matthew-_> what surprises me is that the first version works at all
07:21:19 <shachaf> matthew-_: There are several extensions that can enable forall.
07:21:39 <matthew-_> I have no extensions on in this module
07:21:50 <shachaf> matthew-_: You're saying "assuming that m is a Functor, and m is a Monad, ...".
07:22:15 <doserj> matthew-_: why does it surprise you?
07:22:35 <shachaf> @ty show . succ
07:22:35 <lambdabot> forall a. (Show a, Enum a) => a -> String
07:22:36 <matthew-_> join requires that the two m's are the same monad. but there's no evidence that they are
07:22:57 <shachaf> Oh, wait.
07:22:59 * shachaf misunderstood.
07:23:02 <doserj> so they get unified
07:23:20 <shachaf> fun works for any Monad.
07:23:38 <shachaf> Including the specific m that mjStrToStr is returning.
07:24:34 <matthew-_> ahh yes, of course. Ok, I must be thinking of another situation then
07:24:37 * matthew-_ goes to think
07:25:12 <shachaf> matthew-_: Oh.
07:25:24 <shachaf> matthew-_: In the second case, fun is :: J.value -> m String.
07:25:32 <shachaf> matthew-_: Why did you drop the (Monad m) =>?
07:26:30 <matthew-_> because I'd assumed that the context of m is carried with the m with Existentals turned on
07:26:47 <matthew-_> I didn't realise that Existentals and LexicallyScoped... are separate now
07:27:08 <matthew-_> and I really can't spell..
07:29:44 <matthew-_> and now I'm getting really annoyed - http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html contains ScopedTypeVariables but when I try to use it, I get "cannot parse LANGUAGE pragma"
07:29:45 <lambdabot> http://tinyurl.com/2xjyqs
07:30:23 <shachaf> matthew-_: Works for me.
07:30:29 <shachaf> matthew-_: (With -X, anyway.)
07:32:07 <matthew-_> yeah, works with -X on an {-# OPTIONS ... #-}
07:32:09 <matthew-_> grrr.
07:32:17 <shachaf> matthew-_: That's odd.
07:33:11 <matthew-_> yeah, and with Scoped... on, the second verison with the forall and no second context on fun works fine
07:33:17 <shachaf> matthew-_: Works for me, with LANGUAGE.
07:34:34 <matthew-_> oh sodding hell, it now works for me too. I can't work out if I'm just being incompetant or whether ghci is getting upset
07:34:46 <matthew-_> I have noticed some odd things with ghci 6.8.2
07:35:15 <matthew-_> eg start it with a module that doesn't compile, then fix the module, then :r and it doesn't fully load the new module
07:37:24 <matthew-_> yeah, I can repeat that too. (echo -e "module Foo where\n\n1\n" > Foo.hs && ghci Foo.hs) then (echo -e "module Foo where\n\nf = 1\n" > Foo.hs); in ghci :r and it says Compiling Foo, but the prompt doesn't change from Prelude to Foo
07:37:30 <EvilTerran> i've had problems like that; i had them occasionally in 6.6, too, tho
07:37:42 <matthew-_> and f isn't in scope either after the :r
07:37:43 <EvilTerran> sometimes i'd try to reload and get an obscure error, but trying again would work
07:42:50 <sylvan> Anyone know where I can find that "powered by lambda" logo?
07:44:43 <shachaf> sylvan: What does it look like? :-)
07:44:47 <shachaf> sylvan: Where did you see it?
07:45:17 <sylvan> it
07:45:27 <sylvan> it's like a small button and it has a lambda on it
07:45:35 <sylvan> I've seen it but I don't know where
07:46:29 <shachaf> sylvan: Does it have any text?
07:46:52 <bruno_d> Dear Haskell programmers. I'm a newbie and I apologize if my question is trivial:
07:46:53 <sylvan> Yeah, I think it said "powered by haskell" or just "powered by" and then the lambda...
07:47:27 <bruno_d> Why do the following to functions get a different type from the type inference of ghci?
07:48:00 <bruno_d> double2 x = x*2     vs     double3 = \x -> x*2
07:48:09 <shachaf> @go monomorphism restriction
07:48:11 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
07:48:11 <lambdabot> Title: Monomorphism restriction - HaskellWiki
07:48:22 <shachaf> bruno_d: Because of that.
07:48:26 <bruno_d> The first gets    double2 :: forall a. (Num a) => a -> a
07:48:43 <bruno_d> ah, I see. Thanks.
07:48:48 <bruno_d> I'm going to read it.
07:49:00 <sylvan> it's annoying
07:50:49 <EvilTerran> it can be disabled by passing -XNoMonomorphismRestriction to ghc(i), or by adding {-# LANGUAGE NoMonomorphismRestriction #-} to your source file
07:51:16 <bruno_d> Thanks, EvilTerran.
07:51:19 <EvilTerran> ...but that's cheating slightly; the official way of doing it is to give double3 an explicit type
07:51:46 <EvilTerran> adding "double3 :: Num a => a -> a" will see that it gets the right type
07:51:59 <bruno_d> Ok. Are there cases where I'd have to give an explicit type to lambda functions somewhere else in my programs?
07:52:17 <bruno_d> I mean somewhere inside expressions?
07:52:29 <EvilTerran> it's only where you declare something without parameters
07:52:38 <bruno_d> Ok
07:52:49 <EvilTerran> "foo = ..." - foo is forced to be monomorphic unless you give it an explicit type
07:52:58 <EvilTerran> "foo x = ..." isn't, tho
07:53:44 <bogner> is there an integer square root in the standard libraries?
07:53:59 <EvilTerran> no
07:54:01 <Botje> yes, but it's disguised as floor . sqrt . fromIntegral
07:54:08 <bruno_d> Is it advisable to leave out explicit types in my programs anyway?
07:54:10 <sjw`> hmmm ... that's kinda nasty
07:54:11 <EvilTerran> not a proper one :P
07:54:11 <faxathisia> :t floor . sqrt . fromIntegral
07:54:12 <lambdabot> forall b a. (Integral b, Integral a) => a -> b
07:54:17 <faxathisia> Nice
07:54:22 <faxathisia> @let isqrt = floor . sqrt . fromIntegral
07:54:22 <int-e> > floor . sqrt . fromIntegral $ 10^100
07:54:23 <lambdabot>  100000000000000007629769841091887003294964970946560
07:54:24 <lambdabot> Defined.
07:54:39 <EvilTerran> bruno_d, it's pretty common to explicitly type most things anyway
07:54:40 <bogner> seems nicer to just write my own
07:54:43 <EvilTerran> it's a form of documentation
07:54:52 <faxathisia> bruno_d: I leave out types unless they help explain what the code does
07:55:02 <EvilTerran> @undef
07:55:02 <lambdabot> Undefined.
07:55:07 <bruno_d> EvilTerran: Ok, so I'll do so, too. It's better for type synonyms anyway.
07:55:19 <faxathisia> Why ??
07:55:49 <EvilTerran> @let isqrt x = last $ takeWhile ((<=x).(^2)) [0..]
07:55:50 <lambdabot> Defined.
07:55:59 <EvilTerran> > isqrt (10^100)
07:56:07 <lambdabot> Terminated
07:56:10 <EvilTerran> hm
07:56:13 <EvilTerran> > isqrt (10^10)
07:56:13 <lambdabot>  100000
07:56:21 <int-e> > let isqrt x | x <  0 = undefined | x == 0 = 0 | otherwise = steps 1 where step n = (((x-1) `div` n) + n + 1) `div` 2; steps n = let n' = step n in if n == n' then n' else steps n' in map isqrt ([0..25]++[10^100])
07:56:22 <lambdabot>  [0,1,1,2,2,2,2,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,10000000000000000000000...
07:56:28 <faxathisia> your way is slower!
07:56:29 <faxathisia> :P
07:56:57 <bruno_d> Thanks, have a good weekend, all of you!
07:57:08 <EvilTerran> my way is fast enough for many purposes. :P
07:57:40 <EvilTerran> altho i'd hope any standard lib function would use an optimal algorithm (int-e's, say)
07:58:01 <mux> http://mu.org/~mux/lambdabot-ghc-6.8.2.patch
07:58:14 <mux> for those who want to build LB with ghc 6.8.2, here's a (dirty) patch
07:59:33 <int-e> EvilTerran: it's not optimal, because it uses a bad starting value for the (variation of a) Newton iteration.
08:00:57 <faxathisia> > tail $ reverse $ foldr (\a b -> (a+b!!0):b) [0] $ reverse [2,3,5,8,6,-5,1,0,0,5]
08:00:57 <lambdabot>  [2,5,10,18,24,19,20,20,20,25]
08:01:12 <faxathisia> That is a bad way to do a running total isn't it?
08:01:37 <JanglerNPL> scanl or scanr would work, I think. I forget which
08:01:39 <shachaf> > scanl (+) 0 [2,3,5,8,6,-5,1,0,0,5]
08:01:40 <lambdabot>  [0,2,5,10,18,24,19,20,20,20,25]
08:01:41 <Botje> > scanl1 +  [2,5,10,18,24,19,20,20,20,25]
08:01:42 <lambdabot>  Couldn't match expected type `(a -> a -> a) -> [a] -> [a]'
08:01:42 <int-e> > scanl1 (+) [2,3,5,8,6,-5,1,0,0,5]
08:01:42 <kpreid> > scanr (+) loses
08:01:42 <lambdabot>  [2,5,10,18,24,19,20,20,20,25]
08:01:43 <lambdabot>   Not in scope: `loses'
08:01:51 <JanglerNPL> hehe
08:02:02 <faxathisia> Woah :D
08:02:19 <int-e> @index scanl1'
08:02:20 <lambdabot> bzzt
08:02:21 <kpreid> @src scanl
08:02:21 <lambdabot> scanl f q ls = q : case ls of
08:02:22 <lambdabot>     []   -> []
08:02:22 <lambdabot>     x:xs -> scanl f (f q x) xs
08:02:54 <Botje> @src scanl1
08:02:54 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
08:02:54 <lambdabot> scanl1 _ []     =  []
08:03:03 <Octal> hi, what could it be: i have X11-current 1.4.1 build and installed (by Setup.hs) to ~, `ghc-pkg latest` reports 1.4.1, but when i try to build XMonad setup reports missing dependency
08:03:12 <shachaf> http://cale.yi.org/index.php/Fold_Diagrams has some nice diagrams for scanl & friends.
08:03:12 <lambdabot> Title: Fold Diagrams - CaleWiki
08:03:21 <shachaf> Octal: Try #xmonad, in general, for xmonad questions.
08:03:35 <Octal> even when i use --with-pkg-config=~/.ghc... it says that At least the following dependencies are missing: X11 >=1.4.1
08:03:42 <shachaf> Octal: Maybe you're configuring xmonad with --usr?
08:03:46 <shachaf> (--user, I mean.)
08:03:47 <wolverian> http://uncyclopedia.org/wiki/Slim_Shady_Algorithm -- the haskell version is nice
08:04:24 <mux> (patch updated to a darcs patch)
08:05:01 <Octal> shachaf: that worked! thanks!!
08:05:14 <monochrom> I had a nightmare. haskell-cafe let through spams. My bayesian spam filter let them through too.
08:05:39 <kpreid> Okay, those diagrams for mapAccum* are scary.
08:05:47 <Valodim> oO
08:06:09 <chessguy_> @remember monochrom I had a nightmare. haskell-cafe let through spams. My bayesian spam filter let them through too.
08:06:09 <lambdabot> Good to know.
08:06:10 <kpreid> @type mapAccumL
08:06:10 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
08:06:37 <kpreid> now *that* I understood
08:08:00 <chessguy> > mapAccumL (\x y -> (x+y,y)) 0 [1..5]
08:08:01 <lambdabot>  (15,[1,2,3,4,5])
08:08:21 <chessguy> @pl \x y -> (x+y,y)
08:08:21 <lambdabot> join . ((,) .) . (+)
08:09:01 <kpreid> > mapAccumL (\a (x:xs) -> (x:a, xs)) [] (words "abc def ghi")
08:09:01 <lambdabot>  ("gda",["bc","ef","hi"])
08:10:29 <kpreid> @pl (\a (x:xs) -> (x:a, xs))
08:10:30 <lambdabot> (`ap` tail) . (. head) . ((,) .) . flip (:)
08:10:39 <kpreid> some things just ought to be pointful
08:10:44 <shachaf> > (ap (flip (,)) . (+)) 5 3
08:10:44 <lambdabot>  (8,3)
08:11:45 <shachaf> Arguably simpler?
08:12:08 <monochrom> @pl \(x,y) -> (x+y,y)
08:12:08 <lambdabot> uncurry (join . ((,) .) . (+))
08:12:11 <guenni> hi guys, I just googled for functional programming in German and up come a book, also in German, for standard ML, and it seems that Haskell and ML are quite close, is that correct?
08:12:28 <shachaf> guenni: In some ways, yes.
08:12:43 <kpreid> guenni: ML and Haskell are related but not especially interchangeable
08:12:47 <faxathisia> ?djinn ([a],[b]) -> [(a,b)]
08:12:47 <lambdabot> -- f cannot be realized.
08:12:59 <shachaf> faxathisia: @djinn doesn't know [].
08:13:11 <guenni> shachaf, kpreid thx
08:13:12 <kpreid> faxathisia: it cannot handle recursive types
08:13:23 <faxathisia> Why not add support for list
08:13:30 <shachaf> You can use Maybe, it's equivalent.
08:13:32 <kpreid> because recursion is nontrivial
08:13:32 <shachaf> @djinn (Maybe a,Maybe b) -> Maybe (a,b)
08:13:33 <lambdabot> f (a, b) =
08:13:33 <lambdabot>     case a of
08:13:33 <lambdabot>     Nothing -> Nothing
08:13:33 <lambdabot>     Just c -> case b of
08:13:34 <lambdabot>               Nothing -> Nothing
08:13:36 <lambdabot>               Just d -> Just (c, d)
08:14:34 <guenni> well I'll consider the book because some subjects seem to be a bit more thuroughly explained than in the 5 haskell books I have
08:14:47 <shachaf> guenni: Which 5?
08:15:00 <shachaf> guenni: And which subjects? :-)
08:15:07 <faxathisia> shachaf; Cool
08:15:26 <monochrom> which ML book?
08:15:33 <hpaste>  faxathisia pasted "Just -> []" at http://hpaste.org/4805
08:15:50 <shachaf> @babel en de functional programming
08:15:50 <lambdabot>   funktionale Programmierung
08:15:50 <faxathisia> This is likely possible automatically?
08:16:01 <guenni> school of expression, introduction to funct ..., programming in haskell, road to logic math
08:16:14 <guenni> the fun of programming
08:16:22 <guenni> the ml book is in German
08:17:15 <monochrom> Then perhaps the real phenomenon is that the German world explains FP better than the English world.
08:18:10 <guenni> doubt it, but I'm still struggling with some basics, so the German book might indeed be easier for me
08:18:24 <monochrom> And this is because... German is a concatentative language? :)
08:18:50 <faxathisia> If you have data .. = A | B | C | D | X Int
08:19:06 <guenni> it's because German is my first language ...
08:19:10 <faxathisia> is it possible to get an Enum like A -> 0, B -> 1, C -> 2, D -> 3, X i -> i ?
08:19:11 <shachaf> guenni: Which Haskell book are you trying right now?
08:19:21 <faxathisia> without writing it :(
08:19:37 <monochrom> A -> 0, X 0 -> 0 ?
08:19:45 <faxathisia> monochrom, Yeah
08:19:56 <shachaf> faxathisia: That seems like a somewhat arbitrary behavior.
08:19:59 <monochrom> That deviates from the spirit of Enum.
08:20:02 <faxathisia> it is, yes
08:20:04 <guenni> ooh, I keep switching between Birds book, shame there's no solutions to the exercises, soe, which confuses me
08:20:10 <faxathisia> alright I will rewrite everything to use Either then
08:20:15 <faxathisia> hm....
08:20:16 <guenni> and I'm done with Hudaks
08:20:28 <guenni> sry Huttons book
08:20:29 <shachaf> guenni: Have you looked at Programming in Haskell yet?
08:20:31 <monochrom> If you deviate from the spirit, you have to write your own code.
08:20:32 <faxathisia> I'm not sure if I should use Either or write my own value function...
08:20:36 <shachaf> OK.
08:20:44 <shachaf> guenni: That one seems nice.
08:20:50 <guenni> shachaf: yep, I'm through with it
08:25:38 <kpreid> faxathisia: deriving Enum doesn't do that?
08:25:48 <resiak> so is there a less explosive way to install cabal 1.2 on Ubuntu other than (a) rolling my own package from the upstream tarball; (b) building ghc 6.8.2 (which allegedly includes it?) from haskell-unsafe?
08:26:00 <kpreid> oh, hm, wouldn't work in general without Bounded
08:26:06 <faxathisia> It doesn't allow Enum since there is a non-nullary constructor
08:31:58 <shachaf> resiak: I'd suggest using 6.8 in one way or another, if you can
08:32:31 <bogner> resiak: you can build and install the cabal-1.2.3.0 tarball from haskell.org with no problems on ubuntu gutsy
08:32:44 <resiak> bogner: did you package it up, or just install it in /usr/local?
08:32:53 * resiak is curently building a package…
08:33:03 <shachaf> resiak: /usr/local is easier. :-)
08:33:06 <resiak> shachaf: i'd really like to avoid compiling ghc and all its libraries on my laptop :)
08:33:10 <bogner> resiak: i installed it in my home directory
08:33:15 <shachaf> resiak: You can use a GHC binary.
08:33:31 <resiak> i'd really like to avoid having an un-package-managed ghc :)
08:34:04 <shachaf> resiak: Well, you could use checkinstall, or something like that.
08:34:09 <resiak> that's a good point!
08:34:13 <resiak> thanks for the suggestions :)
08:34:20 * shachaf gave up on that idea a long time ago. :-)
08:34:41 * shachaf has 12 versions of GHC installed.
08:34:44 <resiak> !
08:35:09 <shachaf> I just never get rid of them.
08:36:13 <byorgey> cool, I didn't know about checkinstall.
08:37:20 * byorgey only has 3 versions of GHC... some catching up to do =)
08:37:38 <resiak> I keep forgetting about checkinstall
08:37:45 <shachaf> byorgey: I don't do anything with the old versions anyway...
08:37:51 <shachaf> I should uninstall them someday.
08:38:24 <byorgey> shachaf: I find them useful for testing things for compatibility with older ghc's
08:38:49 <byorgey> not that I do that all that often, but often enough that I'm not planning to delete old versions anytime soon
08:38:55 * shachaf doubts he's ever going to test for compatibility with 6.7.20070830.
08:40:30 <byorgey> shachaf: good point. =)
08:53:13 <shachaf> @seen dons
08:53:13 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 10h 6m 15s ago.
08:59:31 <larmeh_> hey there, does anyone know how to replace a "where"-statement using lamda abstractions?
09:00:14 <resiak> something like   foo where x = bar  -->   (\x -> foo) bar  ?
09:00:18 <faxathisia> f x where x = y   can be written as   (\x -> f x) y
09:00:32 <pejo> larmeh, think about lets instead, and see how you can replace them using lambda abstractions.
09:00:56 <larmeh_> alright, thanks
09:02:37 <oerjan> larmeh_: note that the replacement doesn't preserve the typing rules though - arguments in lambda expressions are not polymorphic
09:04:21 <faxathisia> oerjan ahh.. very subtle (and important) point.. I wish I remembered :)
09:04:33 <LoganCapaldo> i dislike that
09:05:05 <oerjan> it's an essential part of type inference
09:05:47 <larmeh_> hm, i think as a beginner i'm not exactly supposed to understand this, right?
09:05:56 <oerjan> larmeh_: possibly :)
09:06:00 <faxathisia> > let id x = x in (id 3, id "x")
09:06:01 <lambdabot>  (3,"x")
09:06:06 <faxathisia> > (\id -> (id 3, id "x")) (\x -> x)
09:06:06 <lambdabot>   add an instance declaration for (Num [Char])
09:06:41 <oerjan> larmeh_: the arguments in a lambda can only be used with a single type inside it
09:07:04 <LoganCapaldo> I don't see how it's "essential", you can run thru a program and replace every occurrence of a lambda expression w/ a named function and get polymorphic arguments can't you?
09:07:37 <oerjan> LoganCapaldo: um it's not the lambda expression itself but its _arguments_ that are restricted
09:07:38 <faxathisia> > (\id1 id2 -> (id1 3, id2 "x")) (\x -> x) (\x -> x)
09:07:38 <lambdabot>  (3,"x")
09:08:29 <LoganCapaldo> oerjan: but isn't f x = ... teh x as eligible for polymorphicsnessity as let x = ...
09:08:53 <oerjan> LoganCapaldo: um no. let me demonstrate:
09:09:01 <shachaf> > let f x = (x 1, x 'a') in f id
09:09:01 <lambdabot>   add an instance declaration for (Num Char)
09:09:09 <oerjan> > let f id = (id '3', id "3") in f id
09:09:10 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
09:09:29 <LoganCapaldo> ok
09:09:37 * LoganCapaldo goes back to disliking that
09:09:49 <LoganCapaldo> :P
09:10:05 <oerjan> it's uses at different types _inside_ the lambda.  the lambda itself might technically end up generalized.
09:10:23 <resiak> if you give
09:10:42 <EvilTerran> > let f :: (forall a. a -> a) -> (Char,Bool); f g = (g '3', g True) in f id
09:10:42 <lambdabot>  Parse error at "." (column 19)
09:10:43 <oerjan> i assume you can get around it with explicit type declaration and higher rank types extension
09:10:51 <resiak> … what they said
09:11:10 <EvilTerran> ?type let f :: (forall a. a -> a) -> (Char,Bool); f g = (g '3', g True) in f id
09:11:11 <lambdabot> (Char, Bool)
09:11:11 <oerjan> EvilTerran: > has almost no extensions enabled
09:11:17 <EvilTerran> there we go
09:11:26 <EvilTerran> ?type let f g = (g '3', g True) in f id
09:11:26 <lambdabot>     Couldn't match expected type `Bool' against inferred type `Char'
09:11:26 <lambdabot>       Expected type: Bool -> t
09:11:26 <lambdabot>       Inferred type: Char -> t1
09:12:04 <oerjan> ?type \(g :: (forall a. a -> a)) -> (g 'a', g "a")
09:12:04 <lambdabot> (forall a. a -> a) -> (Char, [Char])
09:12:19 <EvilTerran> ... why is there a Rank2Types extension, distinct from the RankNTypes one?
09:12:34 <monochrom> some compilers want to just support rank-2.
09:12:40 <EvilTerran> i see
09:13:31 <Nathan> @help
09:13:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:13:56 <Nathan> @help list
09:13:56 <lambdabot> list [module|command]
09:13:56 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
09:14:02 <oerjan> EvilTerran: rank-2 was implemented much earlier, and i assume it's easier
09:14:16 <Nathan> @help list command
09:14:16 <lambdabot> list [module|command]
09:14:17 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
09:14:21 <brian`> hello folks,
09:14:29 <brian`> which haskell sql library do you recommend for mysql?
09:15:01 <oerjan> @list
09:15:02 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
09:15:26 <oerjan> @list vixen
09:15:26 <lambdabot> vixen provides: vixen
09:15:47 <EvilTerran> @list yhjulwwiefzojcbxybbruweejw
09:15:48 <lambdabot> quote provides: quote remember forget ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
09:15:56 <Nathan> @pl \x y -> g x . h y
09:15:56 <lambdabot> (. h) . (.) . g
09:17:15 <oerjan> :t uncurry (.) . (?g &&& ?h)
09:17:16 <lambdabot> forall b c a a1. (?g::a1 -> b -> c, ?h::a1 -> a -> b) => a1 -> a -> c
09:17:45 <EvilTerran> ?type (&&&)
09:17:46 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
09:17:57 <RyanT5001> is there a way to access haskell variables from C?
09:18:06 <oerjan> @where ffi
09:18:06 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
09:18:11 <RyanT5001> i'd like to climb around inside closures and stuff
09:18:17 <EvilTerran> :t curry $ uncurry (.) . (?g *** ?h)
09:18:18 <lambdabot> forall b c a b1 b'. (?g::b1 -> b -> c, ?h::b' -> a -> b) => b1 -> b' -> a -> c
09:18:24 <RyanT5001> i don't mean just link with C code
09:18:36 <EvilTerran> ?type \x y -> ?g x . ?h y
09:18:36 <lambdabot> forall t b c t1 a. (?g::t -> b -> c, ?h::t1 -> a -> b) => t -> t1 -> a -> c
09:19:26 <faxathisia> this is so oddd....
09:19:36 <faxathisia> this parser I have does not like '/'
09:19:38 <hpaste>  Gebb pasted "word freqs (slow)" at http://hpaste.org/4806
09:20:11 <LoganCapaldo> RyanT5001: "climbing around" probably isn't gonna be viable w/ ghc.
09:20:17 <LoganCapaldo> maybe hugs?
09:20:43 <RyanT5001> LoganCapaldo: why not? i don't actually need to *understand* it
09:20:55 <RyanT5001> LoganCapaldo: i'm trying to write a serializer that can handle arbitrary closures
09:21:05 <oerjan> RyanT5001: because ghc rewrites everything completely
09:21:15 <oerjan> there might no longer _be_ any closures
09:21:22 <RyanT5001> oerjan: then there's nothing to serialize :P
09:21:28 <RyanT5001> oerjan: which is fine with me
09:21:41 <oerjan> ah
09:21:59 <RyanT5001> oerjan: i basically just want to be able to take *any* haskell datastructure and send it over the network
09:21:59 <oerjan> well good luck, it's something many people want i think
09:22:08 <RyanT5001> oerjan: i'm tired of having to restrict myself to nonfunctions
09:22:32 <RyanT5001> is there anything that describes the GHC runtime memory model?
09:22:32 <pitecus> anyone know an algorithm to find edit distances between each pair of substrings of two strings?
09:23:05 <shachaf> RyanT5001: The GHC source code? :-)
09:23:33 <EvilTerran> Gebb, how does that compare with, say, (main = print . map (head &&& length) . group . sort . words =<< readFile "words.txt")?
09:23:36 <faxathisia> pitecus: There is a fantastic paper on this but it's in Prolog not Haskell
09:23:39 <EvilTerran> in terms of performance?
09:23:56 <pitecus> faxathisia, i can probably translate it
09:24:05 <pitecus> faxathisia, have a link?
09:24:15 <faxathisia> http://www.iis.sinica.edu.tw/~scm/pub/lpse00.ps.gz
09:24:18 <RyanT5001> shachaf: i was kinda hoping it would be anything *but* that
09:24:23 <Gebb> EvilTerran: OMG, I hardly understand your code.
09:24:37 <EvilTerran> Gebb, they should both be O(n.log n), but i don't know what the constants would be
09:24:51 <EvilTerran> Gebb, do you know what (.) means? what about (=<<)?
09:25:09 <pitecus> faxathisia, thanks
09:25:18 <EvilTerran> print x = putStrLn (show x) -- that one's easy
09:25:26 <Gebb> EvilTerran: I'm not familiar with &&&
09:25:31 <LoganCapaldo> RyanT5001: you are aware ghc is a compiler right? lots f the sort of information you are interested in is gonna be gone by the time you get at it thru C.
09:25:39 <EvilTerran> (f &&& g) x = (f x, g x)
09:25:40 <shachaf> f &&& g = \x -> (f x, g x)
09:25:48 <shachaf> For this purpose.
09:25:49 <RyanT5001> LoganCapaldo: yeah, i'm aware of that
09:26:06 <RyanT5001> LoganCapaldo: all i need to know, though, is how big the closure is and what in it is a pointer
09:26:35 <LoganCapaldo> I don't think there's necessarily such a thing though is what I'm saying
09:26:48 <Gebb> EvilTerran: I'll compare.
09:26:49 <pejo> RyanT5001, that information has to be available to the GC as well, reasonably speaking.
09:27:00 <EvilTerran> Gebb, do you see how mine works?
09:27:05 <RyanT5001> LoganCapaldo: right, as pejo just said, it's the same info the GC needs
09:27:25 <LoganCapaldo> but it won't necessarily be in a form you can use
09:27:27 <EvilTerran> > group . sort . words "foo bar baz foo baz foo eek ack eek"
09:27:28 <lambdabot>  Couldn't match expected type `a -> [a1]'
09:27:30 <EvilTerran> > group . sort . words $ "foo bar baz foo baz foo eek ack eek"
09:27:31 <lambdabot>  [["ack"],["bar"],["baz","baz"],["eek","eek"],["foo","foo","foo"]]
09:27:39 <pejo> RyanT5001, there's a paper by .. Marlow and others on the GC from 2004 (?). Or check the GHC commentary.
09:28:10 <LoganCapaldo> it could be indistisguishable from a tuple or a cons by the time the gc is concerned with it
09:28:32 <LoganCapaldo> of course I don't really know
09:28:58 <Gebb> EvilTerran: Yes, I see. A nice piece of code.
09:28:58 <RyanT5001> LoganCapaldo: well the thing is i don't actually care at all; as long as i can get 1) the pointers 2) the data and 3) the linkage to globals
09:29:00 <RyanT5001> i'm set
09:29:21 <RyanT5001> lambdas get lifted to toplevel anyway
09:30:08 <EvilTerran> :)
09:30:14 <oerjan> RyanT5001: what about the actual code?
09:30:27 <EvilTerran> counting duplicates in a list is a fairly common requirement, actually.
09:30:31 <EvilTerran> @go haskell cookbook
09:30:32 <lambdabot> http://pleac.sourceforge.net/pleac_haskell/index.html
09:31:15 <RyanT5001> oerjan: at first, i'm going to require that the loading program be linked identically to the storing program
09:31:22 <RyanT5001> oerjan: so i can just store pointers into global-space
09:31:25 <oerjan> ic
09:31:38 <RyanT5001> oerjan: but clearly that's unacceptable long-term
09:31:41 <oerjan> sounds more reasonable then :D
09:31:50 <oerjan> oh :(
09:32:01 <RyanT5001> oerjan: so i'll let you provide a way of providing custom linkages
09:32:26 <RyanT5001> oerjan: as long as you know which global symbols in the storer correspond to which in the loader, you're fine
09:33:06 <faxathisia> >:|
09:33:08 <RyanT5001> oerjan: e.g.: if (+) gets linked at 0x12345678 on the storer, and at 0x87654321 on the loader, that's fine
09:33:10 <faxathisia> What's so special about the '/' character
09:33:36 <oerjan> faxathisia: paste?
09:33:42 <RyanT5001> as long as you store them in some mutually-recognizable way
09:34:14 <faxathisia> :S
09:34:20 * faxathisia is not sure what to paste
09:34:26 <faxathisia> I just find this bizarre
09:34:41 <monochrom> If other people can't reproduce your problem, there is no problem.
09:34:51 <oerjan> faxathisia: if it had been \, i could have had a guess at least :D
09:34:59 <monochrom> (Scientific metric.)
09:35:03 <faxathisia> hehe
09:35:08 <LoganCapaldo> monochrom: oh man, I wish I could get away that :)
09:35:14 <LoganCapaldo> *with
09:35:20 <byorgey> faxathisia: is this a parser you wrote yourself, or are you using parsec, or something else?
09:35:24 <faxathisia> Parsec
09:35:28 <faxathisia> check this out for example
09:35:29 <faxathisia> Prelude Parser> parse tokens [] "1 + 1" ===> Right [Num' {tokenPosition = (line 1, column 3), getNum = 1},Op' {tokenPosition = (line 1, column 5), getOp = Add},Num' {tokenPosition = (line 1, column 6), getNum = 1}]
09:35:36 <monochrom> Yes LoganCapaldo, most people lack scientific thinking.
09:35:42 <faxathisia> Prelude Parser> parse tokens [] "1 / 1" ==> Left (line 1, column 1): unexpected "1" .. more error messages
09:36:07 <EvilTerran> faxathisia, are you basing your parser off one of the language doodads?
09:36:11 <oerjan> faxathisia: where in your program is / mentioned?  you could paste those parts
09:36:23 <faxathisia> no it's not based on anything
09:36:31 <hpaste>  faxathisia pasted "op table" at http://hpaste.org/4807
09:36:42 <faxathisia> thing is, every operator works except /
09:37:03 <EvilTerran> what're you passing this to to make a parser?
09:37:06 <Nathan> @unpl .(.).
09:37:06 <lambdabot>  Parse error at end of input
09:37:26 <EvilTerran> faxathisia, (Mul, "*/", ...)?
09:37:28 <hpaste>  faxathisia annotated "op table" with "operatorToken parser" at http://hpaste.org/4807#a1
09:37:35 <faxathisia> Yeah */ is working
09:37:38 <Nathan> @unpl (.h).(.).g
09:37:39 <lambdabot> (\ i o d -> g i (h o d))
09:37:40 <byorgey> EvilTerran: Parsec has a "make expression parser" function that does that
09:37:59 <EvilTerran> byorgey, don't tell me, tell fax
09:38:02 <faxathisia> I'm not using make expression parser
09:38:08 <faxathisia> (intentionally)
09:38:34 <byorgey> oh, I see
09:40:07 <faxathisia> this is so odd though I am wondering if it's Parsec's fault
09:40:13 <RyanT5001> what's a .cmm file?
09:40:17 <brian`> has anyone succeeded compiling HDBC with ghc-6.8.2?
09:40:22 <monochrom> It is. File a bug report.
09:40:44 <byorgey> faxathisia: does it work if you comment out all the other operators?
09:41:09 <RyanT5001> oh, c minus minus
09:41:15 * byorgey is not sure whether monochrom knows something, or is being snarky...
09:41:41 * byorgey guesses snarky
09:42:00 <faxathisia> nah I got the same error with all other ops commented out
09:42:15 <byorgey> faxathisia: but if you change the / to, say, + it works ok?
09:42:18 <oerjan> faxathisia: is the character / mentioned anywhere else in your program?
09:42:19 <faxathisia> Yes
09:42:42 <faxathisia> lol.... god
09:42:52 <faxathisia> thanks yeah, I just realized that was a silly mistake
09:43:00 * faxathisia has a // comment parser
09:43:09 <byorgey> doh!
09:43:11 <oerjan> :)
09:43:16 <faxathisia> can't beleive that!
09:43:32 <EvilTerran> this is why we lex first :)
09:43:50 * faxathisia is lexing wrong!
09:44:13 <EvilTerran> "lex first, ask precedence later" :D
09:44:20 <faxathisia> hehehe
09:44:31 <Gebb> EvilTerran: hmm... your code seems faster.
09:45:16 <EvilTerran> Gebb, I suspected that would happen. GHC puts a lot of work into optimising list-based stuff; less so with maps
09:45:49 <Nathan> @unpl (.h).(g x)
09:45:50 <lambdabot> (\ d i -> g x d (h i))
09:46:01 <Nathan> @unpl (.h).(.)(g x)
09:46:02 <lambdabot> (\ i l -> g x (i (h l)))
09:46:06 <doserj> Gebb: you could try your code using foldl and a strict insert
09:46:16 <EvilTerran> and more complicated datastructures do tend to have larger constant factors as a cost of better asymptotic complexity
09:46:30 <EvilTerran> although, as I said, i think both algorithms are O(n.log n) here
09:48:22 <EvilTerran> you might be able to do something cunning involving recursively halving the input to get yours down to O(log n.log n)
09:49:55 <oerjan> unionWith...
09:51:06 <oerjan> hm but you could do that with the list version too, just replace mergesort with a different binary fold
09:53:12 <hpaste>  EvilTerran annotated "word freqs (slow)" with "halving -- is this faster? i dunno..." at http://hpaste.org/4806#a1
09:55:18 <EvilTerran> > M.fromListWith (+) . map (\x -> (x,1)) . words $ "foo bar baz foo baz foo eek ack eek" -- here's another formulation involving Maps
09:55:19 <lambdabot>  fromList [("ack",1),("bar",1),("baz",2),("eek",2),("foo",3)]
09:55:36 <Gebb> doserj: that worked! Now it's much faster.
09:56:08 <doserj> good :)
09:56:09 <EvilTerran> the fromListWith there is pretty much handing over the folding you're doing to the Map module
09:57:13 <doserj> Gebb: just curious, can you tell some numbers, how the different versions compare?
09:59:46 <Gebb> doserj: well, my very first version runs ~20s, EvilTerran's &&& version ~6s, the foldl version ~3s.
10:00:41 <faxathisia> :t (\x -> x)
10:00:43 <lambdabot> forall t. t -> t
10:00:47 <faxathisia> :t 54
10:00:48 <lambdabot> forall t. (Num t) => t
10:01:14 <Gebb> EvilTerran: gotta try fromListWith.
10:02:29 <faxathisia> Hey how many bugs do you fix per 1000 lines of code you write?
10:02:49 <Cin> are there other ways to inspect the values of a function during the course of its evaluation without having to change your code to use the IO monad and printing them out manually?
10:02:58 <EvilTerran> @where hat
10:02:58 <lambdabot> http://www.haskell.org/hat/
10:03:12 <EvilTerran> > fix (take 1000 bugs)
10:03:12 <lambdabot>   Not in scope: `bugs'
10:03:12 <Cin> ah. grand-spanking-tastic
10:08:19 <hpaste>  Gebb annotated "word freqs (slow)" with "And the winner is..." at http://hpaste.org/4806#a2
10:10:58 <Cin> faxathisia: how might you measure that? manually writing down each bug you think you've fixed could be cumbersome, unless, i guess, you told darcs about it somehow and then just built a histogram from the patches
10:13:34 <ramza3> what are some approaches with cabal for configuring/building and then just running an application without installing; even I tried to do this (which is silly): ghc --make -o Test | `find . -name "*.o"`
10:13:39 <ramza3> in the dist directory
10:14:08 <faxathisia> ./Test # not work?
10:14:37 <ramza3> faxathisia, does cabala build an executable or just the object files?
10:14:56 <ramza3> oops, does build the executable
10:14:58 * faxathisia has no idea, but if you did ghc --make -o Test, surely there is an executable named "Test" you can run
10:15:42 <ramza3> faxathisia, I am using cabal though; runhaskell Setup.hs configure / runhaskell Setup.hs build ... I just need to define "executable: Test"
10:24:31 <pjd> Cin: Debug.Trace?
10:26:09 <Cin> pjd: i'll try that, too
10:27:28 <pjd> > 2 * (trace "foo" 5)
10:27:29 <lambdabot>   Not in scope: `trace'
10:27:38 <pjd> oh well
10:33:35 <hpaste>  resiak pasted "Why might HFuse fail to build with -O but succeed without it?" at http://hpaste.org/4808
10:36:01 <resiak> Strangely, throwing -O0 into ghc-options (which winds up putting it after the existing -O) doesn't help
10:36:20 <resiak> aaaaaaand it's the implicit -fvia-c.  Hrm.
10:37:54 <resiak> throwing -fasm into ghc-options works around it, apparently, but feels ugly.
10:38:14 <dons> http://programming.reddit.com/info/64mwr/comments
10:38:20 <dons> "Xiangqiboard: a new game for unix written in Haskell "
10:39:46 <Igloo> resiak: Is the code actually correct?
10:40:52 <resiak> Igloo: it's entirely possible that it's not
10:41:34 <monochrom> Chinese Chess? :)
10:41:47 <resiak> Igloo: That said, the Hello World filesystem compiles and runs against it :-/
10:42:22 <Igloo> It's not implausible that it could happen to work anyway
10:42:51 <monochrom> Chinese Chess! :)
10:44:06 <monochrom> This is a new way to waste time, and it's written in Haskell! :)
10:44:06 <Igloo> resiak: What's the FFI import decl for fuse_main_real?
10:44:21 <resiak>     fuse_main_real :: Int -> Ptr CString -> Ptr CFuseOperations -> CSize -> IO ()
10:44:43 <resiak> oh...
10:44:48 <resiak> there's a missing user_data argument!
10:45:12 <byorgey> @src mapM
10:45:12 <lambdabot> mapM f as = sequence (map f as)
10:45:58 <resiak> apparently the fuse api has changed.  that's most helpful
10:46:27 <byorgey> @type zipWithM
10:46:28 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
10:46:58 <resiak> Igloo: thanks for the hint — i'd not considered that it might be just working anyway
10:47:33 <Igloo> Welcome to C  :-)
10:48:16 <resiak> step two: figure out what the type representing void* is
10:48:46 <byorgey> @type foldM
10:48:47 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
10:50:19 <byorgey> @index foldM
10:50:19 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:51:34 <Saizan> now i want japanese mah jong too!
10:52:54 <monochrom> haha
11:13:31 <dons> http://programming.reddit.com/info/64mzk/comments/ pretty code
11:13:53 <Heffalump> jdh30 seems to have gone quiet for a bit
11:14:12 <dons> oh, he was pretty active a copule of days ago
11:14:32 <dons> he invited me to prove haskell's value by reimplementing fftw and unison, iirc
11:15:05 <Heffalump> that sounds pointless
11:15:14 <Heffalump> and yes, I know, I was arguing with him about popcon
11:15:28 <dons> ah yes.
11:15:42 <Heffalump> which I am now thoroughly bored of
11:15:49 <dons> he doesn't contribute code to the ocaml community, does he?
11:15:59 <Heffalump> nafaik
11:16:08 <dons> btw, arch linux has a popcon. xmonad's winning there (over similar competitors) :)
11:16:15 <flux> actually he has contributed something. atleast lablgl has his name in the tessellator code.
11:16:24 <dons> oh, good.
11:16:33 <dons> since otherwise he's just leaching off them.
11:16:42 <LoganCapaldo> dons, what no guards? blast
11:16:47 <dons> heh
11:25:16 <dons> Heffalump: are you able to say what you (or lennart) are using overloaded string literals for ?
11:25:30 <dons> i've started playing with them, and wondering where we could take them.
11:25:32 <Heffalump> just to make our DSEL easier to use
11:25:44 <dons> so the strings represent strings in the DSEL?
11:25:49 <dons> without needing constructors?
11:25:52 <Heffalump> when users of the DSEL write a string literal, we want it to be our type, not a String.
11:25:55 <dons> yep.
11:26:04 <dons> ok, so not say, embedding ASTs in strings (say, for regexes)
11:26:14 <mauke> (DSL)
11:26:28 <Cale> Heh, I was thinking of more perverse uses for overloaded string literals the other day. Especially where the overloading produces a function type :)
11:26:35 <dons> oh my.
11:26:47 <dons> i'm happy enough to have bytestring literals :)
11:26:49 <Heffalump> No, though that's a cool idea.
11:26:53 <dons> and regex literals would almost work
11:27:04 <dons> though compile :: String -> Maybe Regex isn't quite fromString
11:27:12 <Heffalump> One annoyance is that I discovered they make defaulting rather messy.
11:27:21 <dons> hmm
11:27:23 <mauke> oh, I have a regex syntax that's error-free
11:27:36 <LoganCapaldo> mauke: do tell
11:27:39 <dons> or do what perl does, and throw a runtime error, mauke :)
11:27:42 <ndm> anyone used the GHC API?
11:27:52 <mauke> dons: perl throws a compiler error
11:27:59 <dons> oh, cool.
11:28:04 <ndm> in particular, if i do import Var, I can't match against a TyVar, as I get an out of scope error
11:28:06 <chessguy> ndm, to state the obvious, dons has :)
11:28:13 <mauke> LoganCapaldo: basically, it ignores errors
11:28:20 <dons> well, not much, chessguy. Cale and Lemmih are more familiar
11:28:21 <chessguy> @bot
11:28:21 <lambdabot> :)
11:28:33 <ndm> however, as far as I can tell, it seems like it should be exported by Var (doing :i on TyVar doesn't work, but doing :i on Var lists TyVar as a constructor)
11:28:35 <chessguy> dons, doesn't LB use it?
11:28:42 <Cale> Heh, just barely. :)
11:29:16 <Cale> I pretty much relied entirely on the type system to figure out what I was doing with the GHC API, and luckily that worked :)
11:29:17 <dons> ndm: btw, this couchdb stuff is interesting.
11:29:27 <LoganCapaldo> hooray types!
11:29:37 <mauke> LoganCapaldo: have a look at http://home.cs.tum.edu/~mai/ploki/ploki-0.6.4/re.c
11:29:37 <dons> ndm, i'm pushing to get the galois web libs released, which will solve the issues with broken json, and other related web dev issues
11:29:37 <chessguy> @faq
11:29:38 <lambdabot> The answer is: Yes! Haskell can do that.
11:29:40 <waern> ndm,Cale: I relied pretty much on GHC sources
11:29:59 <mauke> note how it parses the string backwards (assuming you can find the parser)
11:30:01 <ndm> dons: i have not the slightest idea about couchdb - the commits only come in on my email
11:30:02 <Cale> waern: yes, that's helpful too
11:30:07 <dons> ndm ah ok :)
11:30:25 <ndm> i think i've figured it out now - GHC exports type TyVar = Var, and exports TyVar, not the constructor TyVar in the same module
11:31:44 <ndm> dons: more libs out of Galois would be nice :)
11:32:30 <dons> ndm, expect a dozen or so this month :)
11:32:32 <ndm> i am however hacking at the moment to get GHC to spit out Yhc Core, which would mean all the good tools such as Reduceron, Catch, Reach, Ycr2js would all work with any GHC Program
11:32:41 <Heffalump> how come so many all of a sudden?
11:32:46 <LoganCapaldo> mauke: the "backwards" [] is kind of neat
11:33:17 <dons> Heffalump: a lot have been accumulated over the last 3 months or so, for web dev
11:33:27 <mauke> http://home.cs.tum.edu/~mai/ploki/ploki-0.6.4/doc/ploki-expr.txt also describes the syntax
11:34:17 <dons> we've got quite an army of coders who are paid , effectively, to do infrastructure work on the side, so hopefully we'll see a steady stream of releases
11:34:40 <dons> Heffalump: now I challenge CS to release their improved xml libs :)
11:35:13 <dons> i bet you guys have lots of foundational infrastructure-ish code
11:36:23 <swiert> hiya dons
11:36:38 <dons> hey swiert . happy 2008
11:37:05 <swiert> dons: thanks. you too. did you have a look at the Coq code I sent you?
11:37:18 <Heffalump> lennart fixed some strictness bugs in the pretty printer, but that was in HaXml 1.13, so I'm not sure what use sending that upstream would be
11:37:31 <dons> swiert: oh, had a quick look, but haven't had time to dig into it yet.
11:37:31 <Heffalump> apart from that we don't have any improved xml libs
11:37:53 <swiert> dons: fair enough. I'd be interested to hear your thoughts.
11:37:53 <dons> oh well.
11:38:02 <dons> swiert: yep, i should get some time to look at it
11:38:17 <Heffalump> almost all of our code is CS-specific, really.
11:38:57 <swiert> dons: no rush.
11:40:40 <swiert> dons: are you going to POPL etc btw?
11:40:56 <dons> ah no, unfortunately. though i've got a paper at PADL.
11:41:07 <dons> i probably should have asked earlier.
11:41:10 <LoganCapaldo> heheh, paddle
11:42:03 <swiert> dons: I saw your reddit post about the Coq-tutorial, so I was just curious.
11:42:48 <moonlite> dons and dcoutts: read about the new bytestring release. Cool stuff! How is that (the not needing B.pack part) implemented?
11:43:07 <dons> it uses a new ghc extension, moonlite, for overloaded string literals
11:43:11 <dons> like overloaded numbers in h98
11:43:24 <dcoutts> "foo" :: IsString s => s
11:43:30 <moonlite> oh
11:43:34 <dcoutts> like, 3 :: Num n => n
11:43:40 <Heffalump> length "foo" :: <ambiguous type>
11:43:48 <moonlite> yep, get it. Really neat
11:44:01 <dcoutts> Heffalump: yeah, less nice, it needs defaulting like there is for Num
11:44:09 <Heffalump> dcoutts: that's the thing, it's hard.
11:44:10 <moonlite> are pattern matching a future possibility too?
11:44:15 <LoganCapaldo> err I thought length was [a] -> [a]
11:44:16 * Heffalump goes to find the bug he reported
11:44:17 <moonlite> is
11:44:26 <dcoutts> Heffalump: yeah, I saw it
11:44:45 <dcoutts> moonlite: pattern matching is a good deal harder
11:44:47 <dons> though there's not any functions polymorphic in string and bytestring
11:44:52 <Heffalump> moonlite: pattern-matching works too, by doing equality tests
11:45:23 <dcoutts> well, you don't get the nice pattern syntax
11:45:48 <moonlite> dcoutts: ok, i'll be excited about this for the time being then. :)
11:45:58 <Heffalump> nice pattern syntax?
11:46:05 <dons> x : ys, i guess.
11:46:15 <dons> you don't get list-like views for free :)
11:46:27 <notsmack> 'c' : "foo" ::?
11:46:35 <Heffalump> ah, right
11:46:39 <Heffalump> well, yes :-)
11:46:45 <Heffalump> but view patterns would give you that, yes?
11:47:48 * EvilTerran thinks IsString should be called Stringy
11:47:57 <sjanssen> case s of (uncons -> x:xs) -> ...
11:50:13 <hpaste>  ndm pasted "Debug.Trace in Core" at http://hpaste.org/4809
11:50:15 * Igloo thinks defaulting should be removed anyway
11:50:29 <ndm> i'm having issues with the Core in that hpaste
11:50:38 <ndm> i have given the Core, and my Haskell'ish translation
11:51:11 <ndm> i don't quite understand why there are two $dMonad bindings, and why one is $dMonad = $dMonad, which is an obvious blackhole
11:53:17 <EvilTerran> does 6.8 have those views?
11:54:06 <Igloo> No, it's darcs-only currently
11:55:24 <EvilTerran> ok... does it have the View class (or whatever it's called)?
11:55:37 <ndm> does anyone have a reference on dictionaries in Core, and why code like the stuff I've pasted works? or what the semantics of letrec's are?
11:55:44 <EvilTerran> (for case s of (-> x:xs) -> ... or whatever)
12:06:34 <Feuerbach> can I import some module from ghci?
12:06:45 <mauke_> :m +Some.Module
12:07:56 <hpaste>  sphynx pasted "simple parsec error" at http://hpaste.org/4810
12:08:27 <Feuerbach> mauke_: thanks
12:10:27 <mauke_> sphynx: bold = do char '*'; e <- expression ... looks wrong
12:10:59 <mauke_> because with that, when it sees another '*', it tries to start another "bold" match
12:11:32 <sphynx> mauke_: hm..
12:11:50 <sphynx> but it can be nested
12:12:00 <mauke_> not directly
12:12:18 <sphynx> when I use single  (not many single) it parses **2** like Bol (Bold 2))
12:12:27 <mauke_> *1*2*3* should be (bold 1) (raw 2) (bold 3), not (bold 1 (bold 2) 3)
12:13:03 <mauke_> your current code parses it as (bold 1 (bold 2 (bold 3 (bold ERROR
12:13:45 <mauke_> you need to change e <- so it only accepts raw or italic
12:14:20 <sphynx> yeah, thanks!
12:14:26 <sphynx> it sounds reasonable
12:14:47 <sphynx> nobody do need embedded bolds )
12:15:27 <duaneb> hey guys
12:15:37 <duaneb> I just compiled yi and installed it succesfully
12:15:48 <dons> hah, "m in your shoes. I had pretty much given up on haskell as an impossible academic language until I saw Xmonad."
12:15:58 <dons> write more apps, peoples!
12:16:14 <mauke_> dons: where's that from?
12:16:24 <duaneb> nm
12:16:29 <dons> http://www.goesping.org/archives/2007/12/18/haskell-is-kind-of-cool/
12:16:32 <lambdabot> Title: The Blog That Goes Ping  Blog Archive  Haskell is kind of cool., http://tinyurl.com/345l2a
12:17:04 <sphynx> mauke: thanks, it works like a charm now! :)
12:17:28 <sphynx> when I use e <- italic <|> raw in bold
12:31:44 <duaneb> hey guys
12:31:50 <duaneb> I'm trying to use yi
12:32:00 <duaneb> it compiled/installed succesfully, but can't find a frontend
12:32:03 <duaneb> succesfully
12:32:07 <duaneb> whatever
12:32:40 <Cale> A frontend?
12:33:57 <duaneb> yea
12:34:01 <duaneb> i.e. gtk, vty
12:34:35 <duaneb> "Panic: frontend not found"
12:35:27 <yigal> is there an rss feed reader written in haskell?
12:35:58 <dons> yigal: several libraries for reading rss/atom
12:36:21 <dons> all pretty straightforward too
12:36:36 <yigal> dons: so making my own would be too difficult
12:36:45 <yigal> s/would/wouldn't
12:36:49 <dons> your own client?
12:36:58 <dons> i would say its a fairly easy project, yep.
12:37:02 <yigal> dons: yes, I would like a cli client
12:37:15 <dons> you don't like snownews?
12:37:27 <dons> (that's the cli rss client i use, but it needs some work)
12:37:30 <dons> could do with parallel downloads
12:37:50 <yigal> dons: I will check it out
12:37:56 <dons> i'll be releasing some atom/rss libraries next week, so it will get even easier to write one
12:38:10 <yigal> dons: thank you
12:39:02 <resiak> In a C library binding using hsc2hs, is it possible to use macros?
12:39:55 <resiak> that is, C macros from the library
12:40:08 <dons> hmm, you can use #defines, and there's some keyword for macros
12:40:15 <dons> you can even define your own macros in the .hsc file
12:40:24 <resiak> hrm, so I see
12:40:55 <resiak> but you can't use a macro in a foreign import, right?
12:41:04 <dons> nope
12:41:07 <mauke> hsc2hs converts your .hsc file to a C program, runs it through the C compiler, then collects its output in a .hs file
12:41:37 <mauke> foreign imports don't necessarily touch any part of the C system
12:43:25 <resiak> okay
12:44:42 <hpaste>  ramza3 pasted "Compile with Cabal, module dependencies" at http://hpaste.org/4812
12:45:27 <resiak> so if i wanted to use a #define-d macro in place of a function currently foreign import-ed, i'd have to do some trickery to get hsc2hs to figure out which function is actually being called by the macro and then substitute that into the foreign import
12:45:34 <ramza3> I have an executable; A.Main depends B... B depends on C Module;  in that code, I tried to setup that up but the app won't recognize the C module?
12:47:00 <yrlnry_> At http://programming.reddit.com/info/64hni/comments/c02tdv0 , what does the notation "<*>" mean?
12:47:25 <glguy> ap
12:47:32 <glguy> ?type ap
12:47:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:47:39 <glguy> ?type <*>
12:47:39 <lambdabot> parse error on input `<*>'
12:47:42 <glguy> ?type (<*>)
12:47:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:47:49 <yrlnry_> Oh, duh.
12:47:57 <yrlnry_> I forgot to put the (...) when I asked ghci about it.
12:48:07 <yrlnry_> Thanks.
12:52:43 <sjanssen> resiak: probably the best thing to do is just write a C stub that calls the macro
12:53:11 <resiak> ah, that's a good idea
12:53:45 <resiak> the problem is that Fuse keeps source (but not binary) compatability between minor versions with mad macros…  *sigh*
12:53:59 <resiak> sjanssen: that solves a lot of problems.  thanks!
12:55:46 <dibblego> is there a foldl-like function with an early break?
12:55:57 <abz> is 'with' a reserved word in Haskell? (for implicit parameters)
12:56:42 <Saizan> dibblego: foldM in Either e
12:57:12 <Saizan> dibblego: you'd have to provide a dummy Error instance for your e if it's not a String
12:57:19 <dibblego> Saizan, ah, won't foldM on Maybe do just as well?
12:57:56 <dibblego> ?type foldM
12:57:56 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:58:12 <Saizan> dibblego: oh, yeah, i thought you had some value to return early
12:58:44 <dibblego> yeah I do; but I'm using Scala where the Either Monad is a pain :)
12:58:55 <dibblego> (because Scala has no partial type arguments)
12:59:09 <Saizan> ah ok
12:59:23 <Saizan> does scala have continuations?
13:00:32 <dibblego> not sure
13:00:45 <sphynx> hm, it seems that haskell lexer does not consume multiline strings.. am I right?
13:00:55 <sphynx> test = "1
13:00:56 <mauke> yes, you need explicit gaps
13:00:57 <sphynx> 2"
13:01:04 <mauke> test = "1\    \2"
13:01:32 <ramza3> http://hpaste.org/4812  ... anyone see why I am getting this error
13:01:40 <sphynx> test = "1\
13:01:41 <sphynx> 2"
13:01:43 <sphynx> ?
13:01:50 <dibblego> is there a (Monad m, Foldable f) => (a -> b -> m a) -> a -> f b -> m a
13:01:55 <mauke> sphynx: you need another \ before 2
13:03:26 <sphynx> yeah, but I want to have in test many tests, then I can split them using lines and test one by one
13:03:53 <mauke> it would be easier to make it a list of strings in the first place
13:03:57 <sphynx> but length $ lines "1\    \2" = 1
13:04:30 <sphynx> yeah, I just want to copypaste it from another source )
13:04:47 <sphynx> without need to surround it with [ and ]
13:04:59 <sphynx> but ok, it's not a big problem
13:06:00 <Saizan> ?type \f z l -> foldl (\a b -> a >>= \a' -> f a' b) (return z) l
13:06:01 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:06:12 <gwern> hm. I wonder whether Linspire is still using haskell? http://lambda-the-ultimate.org/node/2491 sez their lead haskell dev left
13:06:13 <lambdabot> Title: Examples of large-scale functional language projects | Lambda the Ultimate
13:06:21 <Saizan> ?type \f z l -> Data.Foldable.foldl (\a b -> a >>= \a' -> f a' b) (return z) l -- dibblego
13:06:22 <lambdabot> forall b (m :: * -> *) a (t :: * -> *). (Monad m, Data.Foldable.Foldable t) => (a -> b -> m a) -> a -> t b -> m a
13:06:51 <int-e> ramza3: does adding ../../lib/haskell/src to the Hs-Source-Dirs for the executable help?
13:07:02 <BMeph> ramza3: Just curious, but, I see "runhaskell Setup.hs configure" and "...build". I don't see an "install", though.
13:07:09 <dibblego> Saizan, cheers; is it possible to obtain the second element of a list without list appearing in the type signature?
13:08:18 <Saizan> ?type (!! 2) . Data.Foldable.toList
13:08:19 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t a -> a
13:08:35 <int-e> ramza3: I think cabal doesn't really support building a library and executables using it from a single cabal file. Try giving the AMPQ library a cabal file, install it, and add it to the build-depends: line.
13:08:44 <Saizan> there's probably a less hacky way, but considering laziness it seems fine
13:08:45 <dibblego> ?src Data.Foldable.toList
13:08:46 <lambdabot> Source not found. Take a stress pill and think things over.
13:08:56 <mauke> int-e: huh?
13:09:00 <mauke> I do that in miniplex
13:09:14 <gwern> (it was more or less nice, except for the two days in florida where we were soaked and then froze)
13:09:18 <int-e> mauke: but it compiles the modules again for the executable, doesn't it?
13:09:22 <gwern> (mischan)
13:09:28 <mauke> ah, right
13:10:30 <int-e> as opposed to installing the library portion and then compiling the executables using the installed library.
13:10:59 <mauke> or simply compiling the executables using the previously compiled object files
13:11:06 <int-e> (which doesn't fit into the "cabal build; cabal install" workflow)
13:12:10 <resiak> is there magic .cabal-ese for "oh, and compile and link this C file"?
13:12:23 <dons> yep.
13:12:33 <dons>   c-sources:         cbits/fpstring.c
13:12:34 <dons>   include-dirs:      include
13:12:34 <dons>   includes:          fpstring.h
13:12:34 <dons>   install-includes:  fpstring.h
13:12:43 <dons> for example, to compile cbits/fpstring.c and include the .h file with it
13:12:55 <resiak> oh, very nice!
13:14:57 <zeeeee> i have "data E = E deriving (Typeable,Show)". when i "throwDyn E `catchDyn` print", why do i get "*** Exception: unknown" rather than "E"?
13:16:08 <dons> which ghc version?
13:16:31 <zeeeee> dons, 6.8
13:16:35 <zeeeee> .1
13:16:43 <zeeeee> er, 6.8.2
13:17:13 <dons> Ambiguous type variable `exception' in the constraints:..
13:17:51 <hpaste>  dons pasted "give a type" at http://hpaste.org/4813
13:17:59 <magnusth> good evening good haskellers!
13:18:37 <dons> good day, magnusth !
13:19:00 <zeeeee> dons, how did you manage to get that error?
13:19:06 <magnusth> all's well down under, dons? (just guessing your location BTW)
13:19:15 <dons> magnusth: i live in the USA now :)
13:19:29 <dons> zeeeee: i just started trying to reproduce your code
13:19:38 <dons> the 'print' is ambiguous, since DynExceptions don't require show
13:19:44 <dons> so somewhere you'd have to state the type
13:20:06 <zeeeee> dons, that's weird. i never got that error from ghci
13:20:16 <magnusth> dons, ah, ok
13:20:41 <dons> zeeeee: oh, ghci is defaulting  things, probably
13:20:45 <magnusth> trying to do something, possibly unwise...
13:21:39 <magnusth> want to wrap a ContT around a StateT, around some other MonadTrans, around IO a, but I'am having problems getting ghc to see the light
13:21:56 <int-e> dons: right, it defaults to () it seems.
13:22:21 <hpaste>  magnusth pasted "My first attempt" at http://hpaste.org/4814
13:22:54 <magnusth> I am obviously doing something wrong, but what?
13:23:00 <zeeeee> dons, otoh, this works, furthering my confusion: handle print (throwDyn E)
13:23:19 <zeeeee> no types needed, and it prints "exception :: Main.E"
13:23:49 <dons> :t handle
13:23:50 <lambdabot> Not in scope: `handle'
13:23:56 <dons> :hoog handle
13:23:58 <zeeeee> Control.Exception.handle
13:24:03 <dons> :hoogle handle
13:24:07 <dons> ?hoogle handle
13:24:08 <lambdabot> Control.Exception.handle :: (Exception -> IO a) -> IO a -> IO a
13:24:08 <lambdabot> System.IO.Handle :: data Handle
13:24:08 <lambdabot> Control.Exception.handleJust :: (Exception -> Maybe b) -> (b -> IO a) -> IO a -> IO a
13:24:09 <int-e> zeeeee: however, that prints the type name, not the constructor name
13:24:40 <zeeeee> int-e, oh, right - that's what drove me to experiment with this in the first place, since all i was seeing from my app was the exception type and not the constructor
13:24:47 <zeeeee> argh
13:25:24 <hpaste>  Saizan annotated "My first attempt" with "like this?" at http://hpaste.org/4814#a1
13:27:15 <Saizan> magnusth: ^^^ it's usually a bad idea to have type variables on the RHS that don't appear on the LHS of a type declaration
13:27:56 <doserj> magnusth: you can't use typeclass contexts in type synonym declaration
13:28:10 <int-e> is there a higher order version of catchDyn? (of type  IO a -> (forall e . Typeable e => e -> IO a) -> IO a ?
13:28:46 <Saizan> ?type catchDyn
13:28:47 <lambdabot> Not in scope: `catchDyn'
13:28:57 <Saizan> ?type Control.Exception.catchDyn
13:28:58 <lambdabot> forall a exception. (Typeable exception) => IO a -> (exception -> IO a) -> IO a
13:29:01 <zeeeee> so if i'd like to log errors, and see which constructor, i need to nest a catchDyn per dynamic exception type, all in a Control.Exeption.handle/catch?
13:29:18 <Heffalump> int-e: no, but you could write one
13:29:25 <magnusth> Saizan, yes, of course, thanks!
13:30:56 <magnusth> doserj, oh, hmm, is there any way of doing what I want to do then?
13:31:19 <Saizan> magnusth: what you want to do, precisely?
13:32:01 <magnusth> want to wrap a ContT around a StateT, around some other MonadTrans, around IO a
13:33:16 <doserj> magnusth: just leave out the typeclass in the type-synonym?
13:33:30 <Saizan> well if you define type K mt a = (ContT r (StateT MyState (mt IO)) a), then you can have functions like foo :: MonadTrans mt => Foo -> K mt Bar, etc..
13:34:20 <magnusth> Saizan, ah, yes, that would work, I think
13:35:08 <zeeeee> i now get "Ignoring (deprecated) result type signature DownloaderException"
13:35:24 <Saizan> btw, you don't _need_ to, it's just to give shorter type signatures
13:35:32 <int-e> Heffalump: Actually looking at Data.Dynamic, that would be hard, because Data.Dynamic only stores the TypeRep, and not the Typeable dictionary, so you'd have to construct a new dictionary.
13:36:26 <int-e> Heffalump: OTOH, Data.Dynamic really does everything that's needed.
13:36:45 <Heffalump> Typeable isn't a superclass of Dynamic?
13:36:57 <int-e> Dynamic is a type.
13:37:08 <zeeeee> where DownloaderException is from: data DownloaderException = ...
13:37:11 <magnusth> Saizan, yes, but the type sigs are long when wrapping a few MonadTrans so I though an alias would be nice
13:37:20 <int-e> data Dynamic = Dynamic TypeRep Obj
13:37:34 <zeeeee> the error comes from a ... `catchDyn` \e :: DownloaderException -> ...
13:38:41 <Heffalump> hmm, I see, yeah
13:39:47 <Heffalump> I wonder why the representation doesn't just wrap up the dictionary.
13:39:57 <zeeeee> furthermore, from dons' example, throwDyn E >> error "a" `catchDyn` (\(e :: E) -> print e) no longer prints the ctor type (adding error "a" does that)
13:40:13 <zeeeee> this is complicated
13:41:00 <Saizan> well you can write a throwDyn that does that
13:41:03 <int-e> Heffalump: Well this way the code doesn't need any higher order types. I'd guess that's the reason.
13:41:25 <Heffalump> how is fromDynamic implemented, though?
13:42:03 <int-e> using unsafeCoerce and with a comparison of the TypeReps
13:42:19 <Heffalump> oh, right, as opposed to using cast.
13:43:46 <Saizan> cast is actually the same but recomputing the TypeRep, right?
13:43:57 <Heffalump> recomputing the TypeRep?
13:44:09 <Heffalump> it gets it from the Typeable instance
13:44:17 <int-e> it calls typeOf again, yes.
13:44:40 <sutats> What's the difference between "f . g x" and "f $ g x"?
13:44:41 <Heffalump> a Typeable dictionary is completely equivalent to having a TypeRep, information-wise, but I'm not quite sure how you could get from a TypeRep to a Typeable dictionary sensibly.
13:44:59 <int-e> (But any Typeable instance where typeOf is not a constant function will break horribly.)
13:44:59 <Heffalump> sutats: f . g x = f . (g x) = \y -> f (g x y)
13:45:09 <Heffalump> sutats: whereas f $ g x = f (g x)
13:45:16 <LoganCapaldo> sutats: f . g x == f . (g x) f $ g x == f (g x)
13:45:33 <LoganCapaldo> f $ g x == (f . g) x
13:45:52 * LoganCapaldo is too slow
13:46:10 <sutats> Ah, okay, that makes sense.
13:46:41 <BMeph> LoganCapaldo: Actually, I like that last line. :)
13:46:56 <idnar> haha
13:47:26 <LoganCapaldo> thanks, I think :)
13:48:31 <LoganCapaldo> the key to remember is that $ doesn't do anything <g>
13:48:54 <hpaste>  dons annotated "give a type" with "package typeable dictionary" at http://hpaste.org/4813#a1
13:49:21 <BMeph> LoganCapaldo: Yes, I meant the "f $ g x == (f . g) x" line, not about you being too slow. ;)
13:49:23 <zeeeee> how do i get this to print the ctor rather than the type? throwDyn E >> return () `catchDyn` (\(e :: E) -> print e)
13:49:26 <dons> zeeeee: ^ something like that maybe? (wrap up the typeable bits to require the ability to Show them)
13:49:57 <dons> zeeeee: see http://hpaste.org/4813#a1 (works)
13:50:02 <dons> note the precedence issues with >>
13:50:31 <sutats> LoganCapaldo: I guess my real question is, then, what's the difference between "(f . g) x" and "f . g x"?
13:50:33 <Heffalump> Throw deriving Typeable looks highly dodgy to me
13:50:48 <sclv> dons -- I'm trying to build mkcabal on 6.6.1 on a mac and getting a linker error: _readline not defined.
13:50:49 <Heffalump> sutats: precedence. f . g x = f . (g x)
13:50:57 <zeeeee> dons, what is that annotation for?
13:51:03 <dons> Heffalump: just so it gets thrown. then unwrap, pull out the Show dictionary, and off we go.
13:51:12 <zeeeee> dons, thanks for the tip about the precedence
13:51:16 <dons> sclv: mac issue with readline
13:51:25 <BMeph> sutats: function application has higher precedence than any other operation.
13:51:26 <dons> zeeeee: the existential quantification?
13:51:27 <Heffalump> dons: sure, I just didn't know that there was a TypeRep for existentials
13:51:29 <zeeeee> dons, yeah
13:51:32 <zeeeee> dons, what is Throw for
13:51:37 <dons> Heffalump: oh, there isn't. its the outer constructor
13:51:41 <sutats> Ah, okay.
13:51:46 <dons> "Throw" basically
13:51:50 <sclv> i figured. any quick advice on how I could define something close enough to it to get the package to run?
13:51:58 <Heffalump> but you have to represent the contained thing, surely.
13:52:04 <dons> nope. that's entirely hidden
13:52:07 <Heffalump> oh, I guess not. ok.
13:52:20 <dons> no unification or so one
13:52:31 <zeeeee> dons, i mean, why did you add it? is it for getting rid of the type annotations?
13:52:42 <zeeeee> (in the handler)
13:53:00 <LoganCapaldo> sutats f . g x is (.)  f (g x) and (f . g) x is ((.) f g) x so f . g = \x -> f (g x) and f . g x = \y -> f ((g x) y) as Heffelump saids
13:53:21 <LoganCapaldo> saids
13:53:31 <dons> zeeeee: oh, that's how you write an existential type in Haskell. i used an existential to ensure that the thrown thing always implements Show
13:53:35 <LoganCapaldo> my new mutation of the english language rules
13:53:50 <LoganCapaldo> I also failed to use nick completeion
13:55:01 <sutats> So, it's basically a matter of which one is applied first.
13:55:38 <hpaste>  magnusth annotated "My first attempt" with "The end result" at http://hpaste.org/4814#a2
13:56:20 <magnusth> Saizan, sorry to bother you again, is there some way to avoid repeating (MonadTrans mt, Monad (mt IO)) for each function?
13:57:19 <Heffalump> magnusth: you could make a custom class
13:57:19 <magnusth> glguy, where can I report errors on hpaste? ;)
13:57:38 <LoganCapaldo> also for (f .g ) x and f . gx, f and g have different "aritties" if I can abuse that word in such a manner. Since you see f . g x you know g takes at least 2 arguments (or that g x results in a function). With f . g you know that g is a function, but g x may or may not be one
13:58:08 <LoganCapaldo> (assuming the code passes the type checker anyway)
13:59:12 <magnusth> Heffalump, hmm, not sure I see how that would help me
14:00:03 * LoganCapaldo want on a explanation rampage
14:00:09 <LoganCapaldo> s/want/went/
14:00:20 <sutats> LoganCapaldo: Why does the g in "f . g x" need to take 2 arguments? It seems like it only takes 1 there, namely x.
14:00:24 <magnusth> Heffalump, or rather I don't really see how that class would look
14:00:36 <sclv> my quick and dirty readline replacement:
14:00:37 <sclv> readline x = do
14:00:37 <sclv>   putStr x;
14:00:38 <sclv>   return . Just =<< getLine
14:00:53 <LoganCapaldo> sutats because otherwise you couldn't use it as a parameter to .
14:01:05 <LoganCapaldo> :t (.)
14:01:07 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:01:28 <sclv> don't know how it handles EOF or if I should worry about such
14:01:29 <LoganCapaldo> > (\x -> x + 3) . id $ 3
14:01:30 <lambdabot>  6
14:01:57 <LoganCapaldo> > (\x -> x + 3) . (id 3) $ 4
14:01:57 <lambdabot>   add an instance declaration for (Num (a -> b))
14:02:12 <LoganCapaldo> @src const
14:02:12 <lambdabot> const x _ = x
14:02:27 <LoganCapaldo> > (\x -> x + 3) . (const 3) $ 4
14:02:27 <sutats> > (\x -> x + 3) $ 3
14:02:27 <lambdabot>  6
14:02:28 <lambdabot>  6
14:02:48 <sutats> Okay, I think I get the difference, thanks.
14:02:48 <LoganCapaldo> follow?
14:02:50 <sutats> Yeah.
14:05:37 <magnusth> Heffalump, ah, got it after some experimentation
14:06:25 <dons> someone likes zipWith, http://programming.reddit.com/info/64ncz/details :)
14:07:34 <magnusth> thanks everyone, my little daughter is waking up so I'm needed elsewhere :)
14:07:38 <BMeph> dons: I haven't vored (yet), but I like zipWith.
14:07:46 * magnusth bids everyone good night
14:08:04 <BMeph> I like it so much, that I now think of _map_ as _zipWith1_. ;)
14:08:40 <faxathisia> oo
14:08:47 <faxathisia> I like that
14:11:01 <LoganCapaldo> @type let map f xs = zipWith (f . (. const)) xs (replicate undefined) in map
14:11:01 <lambdabot>     Couldn't match expected type `[b]' against inferred type `a -> [a]'
14:11:01 <lambdabot>     In the third argument of `zipWith', namely `(replicate undefined)'
14:11:01 <lambdabot>     In the expression:
14:11:38 <LoganCapaldo> I think I got my parens misarranged
14:12:01 <BMeph> ?type let map f xs = zipWith (repeat f) xs in map
14:12:02 <lambdabot>     Couldn't match expected type `a -> b -> c'
14:12:02 <lambdabot>            against inferred type `[a1]'
14:12:02 <lambdabot>     In the first argument of `zipWith', namely `(repeat f)'
14:12:20 <LoganCapaldo> ($)
14:12:45 <BMeph> ?type let map f xs = zipWith ($) (repeat f) xs in map
14:12:45 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:12:53 <BMeph> LoganCapaldo++
14:12:58 <BMeph> LoganCapaldo+
14:13:11 <LoganCapaldo> bwahaha karma
14:13:13 <BMeph> Well, anyway, good eye, and thanks! :)
14:13:17 <LoganCapaldo> precious precious karma
14:13:27 * LoganCapaldo hoards it
14:14:35 <LoganCapaldo> I like how "primal" many of the prelude functions are
14:14:57 <BMeph> @karma+ LoganCapaldo
14:14:57 <lambdabot> LoganCapaldo's karma raised to 4.
14:15:03 <BMeph> ?bo
14:15:03 <lambdabot> :)
14:15:52 <BMeph> ?type zipWith ($)
14:15:52 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
14:16:03 <BMeph> ?type ap
14:16:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:16:06 <r3m0t> @pl \f x -> f x
14:16:07 <lambdabot> id
14:16:23 <r3m0t> @pl \x -> [y | y <- [1..x]]
14:16:23 <lambdabot> return . ((y | y) <-) . enumFromTo 1
14:16:30 <r3m0t> @pl \x -> [y | y <- [1..x], x `mod` y == 0]
14:16:31 <lambdabot> ap ((:) . ((y | y) <-) . enumFromTo 1) (return . (0 ==) . (`mod` y))
14:16:45 <LoganCapaldo> methinks pl doens't quite speak list comprehension
14:16:54 <r3m0t> oh
14:17:05 <r3m0t> @pl \x -> [1..x]
14:17:05 <lambdabot> enumFromTo 1
14:18:03 <r3m0t> @pl \x -> filter ((==0).(mod x)) [1..x]
14:18:03 <lambdabot> ap (filter . ((0 ==) .) . mod) (enumFromTo 1)
14:18:10 <LoganCapaldo> @pl \x -> [1..x] >>= \y -> guard (x `mod` y) == 0 >> return y
14:18:11 <lambdabot> ap ((>>=) . enumFromTo 1) ((`ap` return) . ((>>) .) . flip flip 0 . (((==) . guard) .) . mod)
14:18:20 <r3m0t> @info ap
14:18:20 <lambdabot> ap
14:18:26 <LoganCapaldo> oops
14:18:28 <r3m0t> what is ap?
14:18:39 <LoganCapaldo> should be guard (x `mod` y == 0)
14:18:40 <mauke> @src ap
14:18:40 <lambdabot> ap = liftM2 id
14:18:49 <mauke> @src liftM2
14:18:50 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:18:52 <r3m0t> oh good god
14:18:56 <LoganCapaldo> ap is what you use when you run out of liftMs
14:19:08 <BMeph> > ((filter (0 ==) .) . liftM2 (.) mod (enumFromTo 1)) 5
14:19:08 <lambdabot>  Couldn't match expected type `a -> [t]'
14:19:38 <BMeph> meh
14:19:46 <LoganCapaldo> liftM3 f a b c = liftM2 f a b `ap` c
14:20:08 <LoganCapaldo> liftM f a = return f `ap` a
14:20:16 <BMeph> > (ap ((.) . filter . ((0 ==) .) . mod) (enumFromTo 1)) 5
14:20:16 <lambdabot>  Couldn't match expected type `a -> [a1]'
14:20:22 <LoganCapaldo> however
14:20:41 <LoganCapaldo> when pl uses it, it's usually the (-> r) instance
14:20:50 <LoganCapaldo> so it's the S combinator
14:21:14 <LoganCapaldo> s f g x y = f x (g y) -- I think
14:21:37 <BMeph> S x y z = x z (y z)
14:21:46 <LoganCapaldo> yeah
14:21:51 <LoganCapaldo> BMeph++
14:21:56 <BMeph> ?bo
14:21:56 <lambdabot> :)
14:23:17 <sclv> @. redo unpl ap ((>>=) . enumFromTo 1) ((`ap` return) . ((>>) .) . flip flip 0 . (((==) . guard) .) . mod)
14:23:17 <lambdabot> (do { k <- (\ r -> (>>=) (enumFromTo 1 r)); j <- (\ u -> do { ao <- (\ aj -> (>>) ((guard (mod u aj)) == 0)); an <- return; return (ao an)}); return (k j)})
14:23:50 <LoganCapaldo> mmmmmmpressive
14:27:02 <BMeph> Okay, last try:
14:27:08 <BMeph> > (ap (filter . ((0 ==) .) . mod) (enumFromTo 1)) 5
14:27:08 <lambdabot>  [1,5]
14:27:16 <BMeph> > (ap (filter . ((0 ==) .) . mod) (enumFromTo 1)) 12
14:27:17 <lambdabot>  [1,2,3,4,6,12]
14:27:47 <BMeph> Whew, I'm nutty, but not hopeless - yet. ;)
14:30:09 <sclv> @pl (do { k <- (\ r -> (>>=) (enumFromTo 1 r)); j <- (\ u -> do { ao <- (\ aj -> (>>) ((guard (mod u aj)) == 0)); an <- return; return (ao an)}); return (k j)})
14:30:09 <lambdabot> (line 1, column 5):
14:30:10 <lambdabot> unexpected "{"
14:30:10 <lambdabot> expecting variable, "(", operator or ")"
14:30:18 <BMeph> ?help src
14:30:18 <lambdabot> src <id>. Display the implementation of a standard function
14:30:24 <sclv> gah
14:30:45 <BMeph> ?src (>>=) []
14:30:45 <lambdabot> Source not found. I feel much better now.
14:30:58 <BMeph> ?src [] (>>=)
14:30:58 <lambdabot> m >>= k     = foldr ((++) . k) [] m
14:31:13 <BMeph> ?src [] (return)
14:31:13 <lambdabot> Source not found. Sorry.
14:31:22 <BMeph> ?src [] return
14:31:22 <lambdabot> return x    = [x]
14:32:54 <hpaste>  int-e pasted "a throwDyn' implementation" at http://hpaste.org/4815
14:33:34 <int-e> Heffalump: there's a throwDyn' implementation for your amusement.
14:37:13 <paczesiowa> what's the easiest way to transform [Word8] -> [Word64] ? (I need to "pack" 4 words into one)
14:38:02 <dons> use Data.Bits to do the shifting,
14:38:06 <paczesiowa> I mean 8 words
14:38:08 <dons> and a recursive loop to match 4 elems at a time
14:38:12 <dons> or 8 :)
14:38:22 <dons> there's similar code in Data.Binary
14:39:53 <LoganCapaldo> gtk2hs uses gadts
14:39:56 <LoganCapaldo> fascinating
14:40:56 <BMeph> Probably because there's no other (good) way to specify the number of members in a list - or a sequence, for that matter.
14:41:01 <int-e> :t let chunks (a:b:c:d:xs) = [a,b,c,d]:chunks xs; chunks _ = [] in map (foldl (\x y -> x*256 + fromIntegral y) 0) . chunks
14:41:02 <lambdabot> forall a b. (Integral b, Num a) => [b] -> [a]
14:42:00 <int-e> (I guess that's about the most unflexible way to write it)
14:43:08 <int-e> oh and you didn't specify the endianness
14:44:14 <dons> might be easier to use Data.Binary here.
14:44:45 <paczesiowa> I don't know endianness:D, I would like to parse 8 bytes of file the same way as reading smth to a buffer and casting that to unsinged long long in C
14:46:00 <hpaste>  dons pasted "le-pack64, stolen from data.binary" at http://hpaste.org/4816
14:46:25 <hpaste>  sjanssen pasted "packing" at http://hpaste.org/4817
14:46:58 <dons> i love this from binary too,
14:46:59 <dons> unroll :: Integer -> [Word8]
14:46:59 <dons> unroll = unfoldr step
14:46:59 <dons>   where
14:46:59 <dons>     step 0 = Nothing
14:47:02 <dons>     step i = Just (fromIntegral i, i `shiftR` 8)
14:47:04 <dons> roll :: [Word8] -> Integer
14:47:07 <dons> roll   = foldr unstep 0
14:47:09 <dons>   where
14:47:12 <dons>     unstep b a = a `shiftL` 8 .|. fromIntegral b
14:47:32 <dons> sjanssen's code reminded me of it
14:47:33 <sjanssen> ha, that's practically exactly what I wrote
14:47:54 <dons> :)
14:49:13 <paczesiowa> casting 8bytes to unsinged long long in C depends on endianness of machine right?
14:49:22 <int-e> yes
14:49:22 <sjanssen> yes
14:49:54 <mauke> (and alignment)
14:50:36 <paczesiowa> then I'm translating piece of unportable code so I don't have to do it nice:D
14:50:52 * BMeph imagines casting Chaotic Evil bytes with a whip and a chair...
14:51:20 * int-e ponders using unsafeCoerce on an UArray. ... *shiver*
14:52:30 <sjanssen> there are problems with indices, of course
14:52:49 <sjanssen> it would probably be better to unpack it and make a new UArray from the ByteArray# inside
14:52:50 <oerjan> paczesiowa: iirc Data.Binary(.Get/.Put) has local-endian functions too
14:53:01 <dons> i wonder how much map c2w costs us in Data.ByteString.Char8.pack
14:53:12 <dons> i bet there's a way to coerce that, without requiring the traversal
14:53:28 <dons> fuse the array creation and c2w. mm.
14:55:41 <dons> oh, we do fuse it.
14:55:52 <int-e> sjanssen: oh I'd use unsafeAt of course *g*
15:06:50 <int-e> so using Data.Binary we get  runGet getWord64host . runPut . mapM_ putWord8 $ [1,2,3,4,5,6,7,8]  for a conversion of 8 bytes to a Word64
15:07:24 <dons> very cute.
15:07:36 <dons> the nice thing is that the efficiency issues are taken care of by the library
15:07:55 <jsnx> > mapM_ putWord8 $ [1,2,3,4,5,6,7,8]
15:07:55 <lambdabot>   Not in scope: `putWord8'
15:09:45 <paczesiowa> int-e: thx
15:12:41 <jz87_> who is the maintainer for gtk2hs?
15:13:02 <BMeph> > mapM_ Data.Binary.putWord8 $ [1,2,3,4,5,6,7,8]
15:13:03 <lambdabot>   Not in scope: `Data.Binary.putWord8'
15:16:56 <Lemmih> jz87_: dcoutts, I think.
15:17:02 <jz87_> ah
15:17:41 <jz87_> what would I have to do to get him to update the windows installer for 6.8.2
15:18:00 <jz87_> the source doens't build on my cygwin
15:21:00 <ehird`> what's the correct way to export various constructors of a 'data'
15:21:23 <dons> module M ( D(..) ) where
15:21:32 <dons> exports all of them, otherwise, name them explicitly
15:21:36 <dons> module M ( D(A,B,C) ) where
15:28:30 <oerjan> *ahem*
15:28:44 <oerjan> wrong channel
15:30:35 <dons> http://programming.reddit.com/info/64ngm/details "The worker/wrapper transformation: "Dijkstra's soul breathes out of every equation" "
15:33:49 <dons> http://programming.reddit.com/info/64nj1/comments/
15:33:55 <dons> "Like Xiangqiboard? New Haskell GUI tutorial: Teach Yourself Gtk2Hs in 21 Hours "
15:34:20 <scook0> :t sequence
15:34:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:36:04 <int-e> jz87_: oh you could try to catch dcoutts on IRC or send a friendly request to the gtk-users mailing list.
15:39:11 <LoganCapaldo> @type catch
15:39:12 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
15:39:44 * LoganCapaldo wonders if dcoutts really has type IOError
15:40:42 <EvilTerran> nah, he's the first parameter
15:41:17 <EvilTerran> dcoutts :: IO [Coffee] -> IO Haskell
15:41:47 <EvilTerran> er, IO ([Coffee] -> Haskell), even :P
15:43:41 <ndm> anyone any idea how to get a thesis for free: http://portal.acm.org/citation.cfm?id=916599
15:43:42 <lambdabot> Title: Computational problems in equational theorem proving
15:44:14 <ndm> it looks incredibly useful, but $46 of usefullness is a lot...
15:44:14 <faxathisia> @free thesis
15:44:15 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `thesis'\n\n"
15:45:29 <EvilTerran> ndm, if you access it from an IP allocated to a uni (by SSH or VPN or whatever), they might have a subscription
15:47:29 <ndm> EvilTerran: already tried that, no luck
15:49:24 <Igloo> ndm: Have you tried looking for papers he published? A lot of the material might be in those
15:57:29 <sclv> is there a standard 0, 1, many combinator foax use?
15:58:00 <BMeph> Igloo: ndm's reference says that it's a Ph. D. Thesis, so it's not likely to have anything more developed than what's in that paper.
15:58:28 <sclv> fromMany : a -> (b->a) -> ([b] -a>) -> [b] -> a
15:58:49 <Igloo> BMeph: No, but it's quite likely that the same material will have been published at conferences
16:00:04 <BMeph> Igloo: Hmm, interesting...
16:00:23 <EvilTerran> sclv, that looks kinda like foldr, only not really
16:00:54 <EvilTerran> it reminds me of my (list :: b -> (a -> [a] -> b) -> [a] -> b)
16:00:54 <ndm> Igloo: can't find any relevant papers
16:01:14 <ndm> BMeph: i don't want the detail, i just want the big result - if he published a paper, it would have it in
16:01:19 <EvilTerran> list e f [] = e; list e f (x:xs) = f x xs
16:01:32 <EvilTerran> only with another parameter for the single-element case
16:01:39 <ndm> thesis tends to be papers + waffle (where waffle ties up loose ends and is great to do, but not that useful to read)
16:02:00 <sclv> trying to decide if its the right abstraction.
16:03:42 <LoganCapaldo> gui stuff is too much work.
16:04:09 <ndm> LoganCapaldo: you mean we haven't get found the right abstraction for GUI's
16:04:36 <BMeph> ndm: Eh, I'm an academic at heart - I like the "waffle" part more than the big result. ;)
16:04:56 * ndm is currently writing the waffle part
16:05:29 * BMeph is looking for the syrup and a fork to enjoy more waffles
16:05:45 <LoganCapaldo> i actually had waffles for breakfast today
16:05:57 <jcreigh> mmm, waffles.
16:07:04 <TomMD> ndm: Is supero ever going to get negative information?
16:08:58 <ndm> TomMD: unlikely
16:09:07 <LoganCapaldo> you people use words strange to my ears
16:09:15 <TomMD> s/information/knowledge
16:09:25 <ndm> TomMD: or rather, not in the current incantation before it gets released
16:09:32 <LoganCapaldo> heheh
16:09:37 <LoganCapaldo> current incantation
16:10:17 <LoganCapaldo> itym incarnation
16:10:19 <TomMD> LoganCapaldo: It would be a cool project to make a "laymaniffier" for #haskell (perhaps a lambdabot plugin?)  I know I would find it helpful.
16:10:20 <BMeph> LoganCapaldo: ...like, Chaotic Evil word alignment? ;)
16:10:24 <pejo> TomMD, have a specific use case for it, or just a cool thing
16:10:25 <pejo> ?
16:10:57 <LoganCapaldo> TomMD I think a laymaniffer for #haskell is probably strong AI, <g>
16:11:10 <TomMD> pejo: Cool thing.  WRT Haskell, my next task will either be: A) Make MD5.rolled as fast as MD5.unrolled using GHC or B) Find a GHC/YHC project that I can break into the compiler world on.
16:11:29 <sclv> I don't think I really need the single element case after all
16:11:33 <Sizu1> @gjinn a -> a
16:11:34 <lambdabot> f a = a
16:11:38 <sclv> better to abstract it to somewhere else
16:12:04 <JanglerNPL> gjinn?
16:12:23 <LoganCapaldo> @gun 1 + 2
16:12:25 <lambdabot>  3
16:12:31 <oerjan> JanglerNPL: @djinn
16:12:34 <faxathisia> @mixen \x -> x
16:12:34 <lambdabot> go on
16:12:40 <JanglerNPL> wow
16:12:54 <oerjan> @find Maybe
16:12:54 <lambdabot> * -> *
16:13:20 <scook0> @botsmack
16:13:20 <lambdabot> :)
16:13:23 <Sizu1> @gjinn m1 (a, m2 b) -> m2 (m1 (a,b))
16:13:23 <lambdabot> -- f cannot be realized.
16:13:29 <pejo> TomMD, oh, compilers could definitely use some hacking. There's probably more worthwhile stuff if you want performance though.
16:14:01 <Sizu1> @djinn Maybe (a, IO b) -> IO (Maybe (a,b))
16:14:01 <lambdabot> -- f cannot be realized.
16:14:05 <Sizu1> why not?
16:14:05 <oerjan> Sizu1: i doubt it has type constructor variables
16:14:16 <oerjan> Sizu1: doesn't know about IO
16:14:40 <TomMD> pejo: The attraction to fixing up the MD5 is 1) It should be applicable to many codes. 2) It will probably lead very directly to the GHC inliner 3) I made the "pureMD5" package both those are located in.
16:14:51 <oerjan> @djinn-env
16:14:51 <lambdabot> data () = ()
16:14:51 <lambdabot> data Either a b = Left a | Right b
16:14:51 <lambdabot> data Maybe a = Nothing | Just a
16:14:51 <lambdabot> data Bool = False | True
16:14:51 <lambdabot> data Void
16:14:53 <lambdabot> type Not x = x -> Void
16:14:55 <lambdabot> class Eq a where (==) :: a -> a -> Bool
16:15:01 <pejo> TomMD, oh, I was referring to the negative information for supero.
16:15:07 <oerjan> Sizu1: those are all the types it knows
16:15:12 <jsnx> in haskell, is there a way to make a datatype that acts like a list (e.g. can be destructured with (x:xs)) ?
16:15:21 <faxathisia> jsnx: Yes
16:15:24 <LoganCapaldo> @type \x -> x >>= \(a,b) -> b >>= \c -> return (return (a,c))
16:15:25 <lambdabot> forall (m :: * -> *) t a (m1 :: * -> *). (Monad m1, Monad m) => m (t, m a) -> m (m1 (t, a))
16:15:26 <jsnx> faxathisia: what?
16:15:31 <jsnx> faxathisia: type classes?
16:15:35 <faxathisia> lists..
16:15:43 <dcoutts> @seen jz87
16:15:43 <lambdabot> I saw jz87 leaving #haskell 4h 2m 36s ago, and .
16:15:48 <faxathisia> you could also use infix constructors e.g.  :::
16:15:57 <TomMD> Pejo: Ohh, oops.    Yeah, I don't pretend to know enough to work on supero et al myself - but I am always interested in something that will allow me to write "ideal haskell" and get the performance of "hacked up haskell"
16:16:01 <dcoutts> LoganCapaldo: gtk2hs does not use GADTs
16:16:14 <LoganCapaldo> dcoutts: info lied to me then
16:16:17 <jsnx> faxathisia: so, there is no way to make a *new* datatype Foo that can be destructured with (x:xs) ?
16:16:31 <LoganCapaldo> or chose to use confusing syntax
16:16:40 <oerjan> LoganCapaldo: you have two m's before the ->
16:16:51 <faxathisia> jsnx: list has already been implemented
16:16:56 <faxathisia> jsnx: You can just use it directly
16:17:04 <paczesiowa> jsnx: (:) is infix constructor for lists, you can define you own infix constructors
16:17:08 <Sizu1> how can i widen the scope of IO? i have [a,IO b] and i need IO [a.b]. surely one can do that
16:17:12 <jsnx> aha, i see
16:17:15 <oerjan> i think one of them needs to be Traversable, not Monad
16:17:32 <faxathisia> like I mentioned, :::  is a common one
16:17:37 <jsnx> haha
16:17:42 <jsnx> well, that's too bad
16:18:01 <oerjan> :t \[a,m] -> m >>= \b -> return [a,b]
16:18:02 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
16:18:02 <lambdabot>       Expected type: m a
16:18:02 <lambdabot>       Inferred type: a
16:18:08 <oerjan> what?
16:18:10 <dcoutts> LoganCapaldo: oh, ghci's :info command? what example data type was that?
16:18:29 <sylvan> oerjan, you probably don't want square brackets there
16:18:32 <jsnx> faxathisia: your answer was less than helpful
16:18:41 <sylvan> tuples use ()
16:18:41 <oerjan> sylvan: Sizu1 had them
16:18:42 <paczesiowa> jsnx: data List a = Nil | a ::: List a
16:18:44 <oerjan> oh right
16:18:53 <paczesiowa> jsnx: list = 1 ::: (2 ::: Nil)
16:18:56 <sylvan> oerjan, well he used them incorrectly :-)
16:18:57 <faxathisia> jsnx: sorry
16:19:00 <hpaste>  LoganCapaldo pasted "dcoutts, thusly" at http://hpaste.org/4819
16:19:00 <oerjan> :t \(a,m) -> m >>= \b -> return (a,b)
16:19:01 <lambdabot> forall t (m :: * -> *) a. (Monad m) => (t, m a) -> m (t, a)
16:19:04 <oerjan> Sizu1: ^^
16:19:16 <faxathisia> jsnx: If I say something confusing just ask me to clarify
16:19:17 <Sizu1> sylvan: why do you say that
16:19:25 <Sizu1> i do have a list
16:19:36 <oerjan> Sizu1: a list must have all elements of the same type
16:19:39 <sylvan> Sizy1, No you don't, in lists all elements have the same type
16:19:54 <sylvan> so if you have a and IO a it must be a tuple if anything...
16:20:00 <faxathisia> jsnx: not sure what problem you are trying to solve?..
16:20:12 <Sizu1> oh yeah [(a,IO b)] -> IO [(a,b)]
16:20:32 <sylvan> right, so use oerjans function together with "mapM"
16:20:40 <sylvan> :t mapM
16:20:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:21:02 <jsnx> faxathisia: have you written any python or c++? i'm looking for a pattern...
16:21:13 <faxathisia> yeah I have..
16:21:14 <LoganCapaldo> dcoutts: so am I nuts, or what?
16:21:21 <oerjan> :t mapM $ \(a,m) -> m >>= \b -> return (a,b)
16:21:22 <lambdabot> forall (m :: * -> *) a t. (Monad m) => [(t, m a)] -> m [(t, a)]
16:21:54 <jsnx> so, say you have a an object with several properties -- a username and password, and then a list of ssh connections it has made
16:21:55 <Sizu1> oerjan: thank you
16:22:10 <paczesiowa> Sizu1:
16:22:10 <paczesiowa> f :: (a,IO b) -> IO (a,b)
16:22:10 <paczesiowa> f (a, b) = do
16:22:10 <paczesiowa> 	tmp <- b
16:22:10 <paczesiowa> 	return (a,tmp)
16:22:34 <dons> hwn for 2008, http://www.haskell.org/pipermail/haskell-cafe/2008-January/037503.html
16:22:35 <lambdabot> Title: [Haskell-cafe] Haskell Weekly News: Issue 68 - January 05, 2008, http://tinyurl.com/2xs6cj
16:22:36 <jsnx> faxathisia: in python, if you implement a certain method, you can substitute this item in all list operations
16:22:39 <dons> "This HWN features new releases of the GHC and nhc98 Haskell compilers, a pre-release of darcs 2.0, several new user groups formed, and of course, more than 100 updated and new libraries
16:22:43 <dons> "
16:22:47 <jsnx> faxathisia: which has some positives
16:23:10 <jsnx> faxathisia: in some cases, haskell allows the same thing -- for example, Show and Read
16:23:20 <oerjan> jsnx: haskell has actually developed a bit backwards in that respect
16:23:27 <jsnx> oerjan: ?
16:23:34 <oerjan> it used to allow list comprehensions to be any monad
16:23:42 <jsnx> oerjan: but no longer?
16:23:58 <oerjan> otoh strings recently got overloadable in ghc
16:24:14 <oerjan> it was remove from haskell 1.4 to haskell 98
16:24:20 <oerjan> *removed
16:25:32 <jsnx> say my object is a Foo and when it's iterated over, it returns a new Foo with only one SSH connetion in it, and the same username and password
16:25:46 <jsnx> then Foo :: [Foo] !
16:25:59 <faxathisia> huh..
16:26:05 <jsnx> that would be weird
16:26:09 <EvilTerran> ... SSH connection?
16:26:19 <faxathisia> @src Traversable
16:26:19 <lambdabot> class (Functor t, Foldable t) => Traversable t where
16:26:20 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
16:26:20 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
16:26:20 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
16:26:20 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
16:26:21 <jsnx> EvilTerran: just an example, it's not import
16:26:24 <oerjan> jsnx: even those things that _can_ be overloaded don't have types themselves doing that
16:26:36 <oerjan> there is always a typeclass involved
16:27:12 <jsnx> so, while I can't get a type that's destructured with (x:xs), i can get a Traversible
16:27:40 <jsnx> good to know, since most of the time when you're using this kind of object in python and C++, you're using for
16:27:45 <oerjan> or Foldable
16:27:54 <jsnx> hmm, Foldable
16:28:01 <oerjan> or even Monad
16:28:03 <jsnx> @src Foldable
16:28:03 <lambdabot> Source not found. stty: unknown mode: doofus
16:28:17 <jsnx> :t Foldable
16:28:18 <lambdabot> Not in scope: data constructor `Foldable'
16:28:24 <jsnx> :t Traversable
16:28:25 <lambdabot> Not in scope: data constructor `Traversable'
16:28:27 <jsnx> :t Foldable a
16:28:27 <lambdabot> Not in scope: data constructor `Foldable'
16:28:28 <lambdabot> Not in scope: `a'
16:28:36 <faxathisia> jsnx; In general though.. I find that applying idoms from other languages in other languages is often not a good idea
16:28:36 <oerjan> they can all be considered as slightly different ways of descending into a structure
16:28:47 <faxathisia> jsnx; So there may be a more natural way to do what you're talking about
16:29:04 <oerjan> jsnx: those are type classes, not types
16:29:10 <jsnx> oerjan: that is okay
16:29:19 <jsnx> that i what i meant
16:29:39 <jsnx> oerjan: oh, wait -- you are talking about using :t
16:29:58 <jsnx> i have no idea how to look up type classes in GHCi and lambdabot
16:29:59 <oerjan> don't know why @src Foldable is left out (as always @src is troublesome)
16:30:11 <oerjan> jsnx: @src often works
16:30:31 <oerjan> in ghci, :info
16:30:33 <Cin> whaaddayou guys think of liskell? has anyone used it to solve some problem that required metaprogramming?
16:30:53 <glguy> Do you have any examples of required metaprogramming in mind?
16:31:16 <EvilTerran> we have typeclasses; metaprogramming is redundant :P
16:31:19 <Cin> no. i've just started reading the liskell report. thought i'd mention it in here
16:31:38 <jsnx> Cin: to answer your question, i haven't used it
16:32:52 <EvilTerran> and, for the circumstances it isn't, we've got SYB, Uniplate, TH, etc
16:33:14 <EvilTerran> (the first two aren't strictly metaprogramming, but they've got a certain amount in common)
16:35:27 <kpreid> jsnx: btw, in Haskell lists are used for a lot of things where elsewhere you might use a generic iteration interface
16:35:49 <kpreid> jsnx: this is because they can be lazily constructed, fused, etc.
16:36:16 <ndm> i would have thought any domain-specific language is meta-programming
16:36:33 <ndm> in a pure+lazy language meta-programming is just called "programming"
16:36:57 <jsnx> ndm: well, type classes sure help, too
16:37:25 <ndm> jsnx: yes, they do indeed - and monads
16:37:58 <jsnx> kpreid: yeah, it's not something i've ever thought about having when writing haskell -- but i'm doing some python this weekend, and i've had to do it several times -- so i was wondering about how to do it in haskell
16:38:33 <jsnx> kpreid: though i suppose it's just as interesting to figure out how *not* to do it
16:38:36 <LoganCapaldo> I'd think SYB and TH and ilk would be the Haskell "metaprogramming"
16:38:50 <JFT> what's considered meta-programming in one language often ends up as "regular programming" in other language. A lot of what's called meta-programming in C++ for exemple you can do directly in Haskell...
16:41:31 <jsnx> JFT: true -- like type classes
16:41:43 <JFT> jsnx: between other things
16:42:30 <jsnx> the full power of template specialization is available on GHC with -XOverlappingInstances
16:42:54 <jsnx> but it's not as flexible by default
16:43:48 <JFT> jsnx: i dont feel the need for template programming in Haskell compared to C++
16:44:15 <hpaste>  ramza3 pasted "What am I missing with cabal including file" at http://hpaste.org/4821
16:44:23 <JFT> jsxn: maybe because in Haskell the control code doesn't pollute the processing code as much hence it is easier to reuse and recombine
16:44:36 <jsnx> JFT: sometimes i want to make a weird show function
16:44:54 <ramza3> hpaste: anybody see why I am getting that error at the end of the post,
16:45:10 <jsnx> like, i have a Foo (which is in Show) and i want to write a special show for (Foo, Foo)
16:46:35 <_phobes> Meta-programming would be nice in places where you'd want to generalize what "Deriving" declarations currently do
16:47:04 <ndm> _phobes: we have generics for that, and the Data.Derive framework
16:47:06 <jsnx> JFT: that's comparable to a "template specialization" in C++
16:47:22 <ndm> _phobes: but in general, there is a lack of a good "write your own deriving" thing
16:47:23 <JFT> jsnx: newtype ?
16:47:25 <jsnx> though in haskell, it's an overlapping instance
16:47:42 <JFT> jsnx: unless I'm missing what you mean....
16:47:45 <jsnx> JFT: not if you enable overlapping instances
16:48:09 <jsnx> you just say `class Show (Foo, Foo) where...` and then go from there
16:48:19 <desp> Have you guys seen http://subtextual.org/subtext2.html ?
16:48:19 <lambdabot> Title: Created with Camtasia Studio 5
16:48:29 <_phobes> desp: Ya, I looked at that
16:48:39 <jsnx> even though `class Show (Show a, Show a) where...` has already been defined
16:49:29 <desp> Pretty damn amazing.
16:49:50 <_phobes> Does he have anything you can download?
16:50:09 <_phobes> (an executable to play with)
16:50:10 <puusorsa> pr0n?
16:50:15 <desp> "No. Subtext is a research prototype that is still far from being a usable language."
16:50:29 <_phobes> ya
16:50:32 <desp> http://subtextual.org/FAQ.html
16:50:32 <lambdabot> Title: Subtext FAQ
16:50:41 <jsnx> oh wait -- in my examples, replace 'class' with 'instance'
16:50:55 <_phobes> I remember now that the slides were all just created in a paint program
16:51:06 <desp> _phobes: Huh?
16:51:08 <_phobes> or somethign
16:51:08 <desp> :o
16:51:13 <_phobes> I think he said that in the paper
16:51:20 <desp> Aw, man.
16:51:29 <_phobes> That this was a visualization aide of how it would look
16:51:45 <desp> Are you thinking about the first or the second video?
16:51:57 <_phobes> I didn't watch the videos - they wouldn't play for me
16:51:57 <desp> The second video clearly shows Windows Vista window borders;
16:51:59 <_phobes> I just read the paper
16:52:02 <desp> Ah.
16:52:10 <_phobes> The paper might also have been earlier than the videos
16:52:14 <_phobes> he may have some kind of prototype onw
16:52:16 <_phobes> now*
16:52:27 <JFT> jsnx: Never used overloapping instances I'll check them up :) Thx
16:52:37 * Botje has resolved to keep up with haskell-cafe
16:52:55 <Botje> .. but i'm already failing quite horribly with 977 unread mails :p
16:53:06 <sclv> ok so i have the following function:
16:53:19 <sclv> seqTmpls [f]    y = f y;   seqTmpls (f:fs) y = seqTmpls fs =<< return . f y;
16:53:31 <sclv> Is this already some sort of foldM or such?
16:53:38 <jsnx> Botje: maybe you can hire some one at Amazon Mechanical Turk to keep up for you
16:53:43 <Botje> :)
16:53:54 <Botje> :t foldM
16:53:56 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
16:54:12 <Botje> @src foldM
16:54:12 <lambdabot> foldM _ a []     = return a
16:54:12 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
16:54:18 <oerjan> > until odd (`div` 2) 48
16:54:19 <lambdabot>  3
16:54:45 <jsnx> :t until
16:54:46 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
16:55:15 <jsnx> @src until
16:55:16 <lambdabot> until p f x | p x       = x
16:55:16 <lambdabot>             | otherwise = until p f (f x)
16:56:37 <ramza3> hpaste: anybody see why I am getting that error at the end of the post,
16:56:43 <ramza3> http://hpaste.org/4812
16:56:43 <jsnx> ramza3: no
16:57:50 <sclv> :t sequenceM
16:57:50 <lambdabot> Not in scope: `sequenceM'
16:57:56 <sclv> :t sequence
16:57:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:58:00 <gwern> I see the 'weekly' haskell news has come out :) interesting reading
16:58:36 <ramza3> jsnx: thanks
16:59:10 <oerjan> @hoogle Eq a => (a -> a) -> a -> a
16:59:11 <lambdabot> Control.Monad.Error.Class.catchError :: MonadError e m => m a -> (e -> m a) -> m a
16:59:11 <lambdabot> Control.Monad.Writer.Class.censor :: MonadWriter w m => (w -> w) -> m a -> m a
16:59:11 <lambdabot> Control.Monad.Reader.Class.local :: MonadReader r m => (r -> r) -> m a -> m a
16:59:19 <oerjan> bah
17:03:47 <hpaste>  glguy pasted "generalized liftM, needs tweaks" at http://hpaste.org/4822
17:03:56 <glguy> so this works when I make it less polymorphic
17:04:04 <glguy> but how can I get it to work in the general case?
17:06:08 <dcoutts> LoganCapaldo: ah yes, so AttrOp uses existential components but it does not need GADTs
17:06:20 <dcoutts> LoganCapaldo: but yes, ghci is presenting it in that style
17:07:23 <LoganCapaldo> dcoutts: good to know
17:10:24 <glguy> solved :)
17:10:54 <hpaste>  glguy annotated "generalized liftM, needs tweaks" with "generalized applicative programming :)" at http://hpaste.org/4822#a1
17:11:48 <glguy> *Main> iI (++) getLine getLine Ii
17:11:48 <glguy> one
17:11:48 <glguy> two
17:11:48 <glguy> "onetwo"
17:13:26 <ramza3> jsnx: I think I needed to define the module 3 levels deep as opposed to 2 (Data.ABC.Module.hs as opposed ABC.Module.hs)  strange
17:14:00 <jsnx> ramza3: that worked? interesting...
17:14:04 <laminatka> Hi, could you add lambdabot to #fi.muni.cz ?
17:15:09 <ramza3> jsnx: yep
17:16:13 <jsnx> ramza3: all the modules i've defined in the past have fit under one of the "standard" ones -- Data.Char.CEDICT, for example -- so i've never encountered that problem
17:16:53 <ramza3> jsnx, I wonder if you tried just Char.CEDICT , if you would get any issues
17:19:49 <jsnx> ramza3: well, i am unable to do so right now, because i have rather a lot of work to do...but it's something to look into, for sure
17:20:04 <dons> laminatka: is that on freenode?
17:20:13 <laminatka> dons: yes
17:20:17 <dons> ?join #fi.muni.cz
17:20:20 <dons> done :)
17:20:29 <jsnx> ramza3: once i had phrase search to CEDICT, it won't really go in Data.Char anymore
17:20:29 <laminatka> thank you:)
17:20:38 <dons> ?users #fi.muni.cz
17:20:38 <lambdabot> Maximum users seen in #fi.muni.cz: 20, currently: 20 (100.0%), active: 3 (15.0%)
17:25:45 <sclv> glguy: nice! you should update the haskellwiki: http://www.haskell.org/haskellwiki/Idiom_brackets
17:25:46 <lambdabot> Title: Idiom brackets - HaskellWiki
17:26:19 <glguy> oh :(
17:26:24 <glguy> I didn't know if was on the wiki already
17:27:32 <jsnx> damn, i missed that part
17:27:51 <jsnx> so, the 'idiom brackets' in the wiki example are 'iI' and 'Ii' ?
17:28:11 <glguy> yeah, as defined by the paper
17:28:19 <glguy> which is why I had the same choice
17:28:37 <sclv> what's the paper?
17:28:59 <glguy> I don't know the title, but I think it was about the first one on applicative style programming
17:29:06 <glguy> haskell based at least
17:31:08 <sclv> applicative programming with effects?
17:31:13 <glguy> that sounds like it
17:31:22 <sclv> its the only paper on the topic I know. be curious to see what others there are.
17:31:37 <glguy> The paper leaves implementation of iI .... Ii
17:31:42 <glguy> as an exercise for the reader
17:42:09 <sclv> ooh.. another paper! http://lambda-the-ultimate.org/node/1410
17:42:09 <lambdabot> Title: The Essence of the Iterator Pattern | Lambda the Ultimate
17:45:47 <monochrom> Hehehehe, Haskell Quarterly News is out!
17:46:14 <dons> well, its been 6 weeks
17:46:30 <glguy> should hwn go into the topic?
17:46:40 <dons> not until sequence.complete.org starts working again
17:46:44 <glguy> oh
17:46:44 <glguy> ok
17:46:51 <monochrom> yikes
17:47:13 <dons> i've informed john
17:47:21 <dons> yay php
17:51:07 <LoganCapaldo> ah man, I got all excited about the :=> constructor for setting properties, but it only does the action once
17:57:31 <monochrom> Two entries for uulib :)
18:02:04 <dons> a script aggregates the rss feed for hackage
18:02:11 <dons> (hackage2hwn, its itself on hackage)
18:02:17 <dons> so you could hack that to filter dups
18:02:46 <dons> oh, it uses the galois xml lib. hmm
18:04:03 <dons> kinda cool how naive page scraping and ppr is so concise, in haskell now,  http://code.haskell.org/~dons/code/hackage2hwn/Main.hs
18:04:38 <dons> (that script turns the hackage site rss into the hwn entries you get in your inbox)
18:07:25 <dons> now we just need bytestring tagsoup, network, xml, http :)
18:09:16 <desp> What do you call using a lotto ticket as a bookmark for a probability theory textbook? :)
18:09:31 <oerjan> irony
18:10:06 <dons> so that's not irony though :)
18:10:50 <desp> That's what my friend does, and I just about collapsed laughing.
18:11:24 <dons> its perversly appropriate though :)
18:11:26 <r3m0t> I would have to buy a ticket first
18:11:31 <r3m0t> seems awfully bothersame
18:12:00 <desp> dons: Have you seen the Subtext language video?
18:12:09 <dons> nope
18:12:23 <desp> http://subtextual.org/subtext2.html
18:12:23 <lambdabot> Title: Created with Camtasia Studio 5
18:12:43 <desp> I bumped into it in a progreddit comment; really interesting...
18:12:54 <dons> maybe it is ironic though, the probability text describe why gambling is stupid, yet it is marked with a lotto ticket. i guess that's situational irony in fact.
18:13:11 <dons> there's your incongruity in the situation. good enough for me.
18:13:33 <Cin> desp: it warms my mind
18:13:45 <Cin> and by 'warms', you know i meant 'warps'
18:13:57 <desp> Cin: which thing does?
18:14:02 <Cin> subtext
18:14:20 <desp> I like how it extracts structure.
18:15:10 <Cin> i like how changing some logic just requires moving one graphical thing on the table elsewhere
18:15:20 <Cin> as opposed to editing a string
18:15:25 <desp> I'm not aware of any other sensible 2D programming languages.
18:15:35 <desp> Befunge and the ICFP 2D don't count. :)
18:15:46 <xpika> its a shame this doesn't work
18:15:48 <xpika> ( sequence $ repeat $ randomRIO (0,51) ) >>= return . take 7 . nub
18:16:34 <kpreid> I'd like to watch the Subtext 2 video, but it tells me I need JavaScript and the latest Flash Player (paraphrasing). This requirement is sufficiently silly.
18:16:48 <faxathisia> desp Epigram?
18:16:55 <glguy> the subtext video seems to use vista... how embarrassing
18:17:09 <xpika> I can't think of an as easy way to generate 7 unique random numbers from 0 to 51
18:17:12 <sclv> ohman we need colorHaskell
18:17:16 <desp> faxathisia: looking up
18:17:42 <oerjan> :t newStdGen >>= return . take 7 . nub . randomRs (0,51)
18:17:46 <lambdabot> forall a. (Num a, Random a) => IO [a]
18:17:46 <desp> faxathisia: oh, well. That's not quite as comprehensively 2D as Subtext. ;)
18:17:50 <oerjan> ^^ xpika
18:18:01 <sclv> distinguish between operators, types, classes, and constructors with color!
18:18:20 <xpika> [*** Exception: stack overflow
18:18:34 <xpika> ^^ oerjan
18:19:13 <oerjan> xpika: works here
18:19:39 <desp> kpreid: I think it's worth the hassle of getting a Flash player. Even though it uses Vista, the presentation is crystal clear, and the ideas are interesting.
18:19:49 <dons> Prelude System.Random Data.List> newStdGen >>= return . take 7 . nub . randomRs (0,51)
18:19:53 <dons> [26,32,30,36,41,7,15]
18:20:26 <BMeph> I also like the ideas presented in the first one.
18:20:50 <kpreid> I *have* Flash. Specifically, the one Apple ships OS X with. I don't care to expose my computer to Macrom^WAdobe's installer without a decent reason to.
18:21:17 <desp> Odd.
18:21:19 <xpika> ok, it started working
18:21:45 <desp> I have the 10.5 standard Flash, I think. ;)
18:22:14 <xpika> inface the overflow of the first caused the overflow of the second
18:22:19 <xpika> must be a bug in ghc
18:22:44 <desp> Oh, that reminds me. Has anyone gotten GHC 6.8.2 to compile on OS X 10.5 PowerPC?
18:24:41 <hpaste>  clanehin pasted "What's up with this?" at http://hpaste.org/4823
18:25:20 <clanehin> Google didn't tell me much about monotypes, I guess it has to do with how arrow notation is implemented.
18:26:19 <oerjan> clanehin: you are passing in an Integer
18:26:35 <oerjan> you cannot get out a Num without using fromIntegral somehow...
18:27:16 <oerjan> :t proc n -> returnA -< (+ fromIntegral n)
18:27:17 <lambdabot> Parse error in pattern
18:27:22 <oerjan> hmph
18:27:23 <clanehin> ok, I see
18:27:40 <clanehin> let me look at how I got that, because I may still have a question
18:28:20 <clanehin> I still get it when I add fromInteger
18:28:32 <puusorsa> "it"
18:28:40 <puusorsa> we has them all over
18:28:40 <oerjan> oh
18:28:43 <puusorsa> evil shit
18:28:59 <puusorsa> good thing the booze thingy makes them go awat
18:29:00 <puusorsa> y
18:29:14 <oerjan> maybe there really is a monomorphism restriction there
18:29:33 <clanehin> it's my original problem, with weird types/typeclasses replaced with Integer/Num
18:29:59 <oerjan> what about using functions rather than arrow notation? does that work?
18:30:28 <oerjan> :t arr ((+).fromInteger)
18:30:29 <puusorsa> even if it does, it's just a temporary fix
18:30:29 <lambdabot> forall b (a :: * -> * -> *). (Num b, Arrow a) => a Integer (b -> b)
18:30:40 <puusorsa> how do you plan to escape heat death?
18:32:01 <kpreid> desp: ah, perhaps I can use the Leopard machine here then
18:32:33 <clanehin> oerjan: that seems to work, but I think it won't work for what I need to do
18:32:56 <sfultong> hey, does anyone know of a good javascript library?  I think I remember hearing about one that had a terse, functional style to it
18:35:43 <hpaste>  clanehin annotated "What's up with this?" with "What's up with this?  Corrected." at http://hpaste.org/4823#a1
18:36:25 <jsnx> what is the usual way to make programs which are connected to standard input just bail if they do not actually have any input?
18:36:36 <Lemmih> sfultong: Flapjax?
18:37:01 <jsnx> i have a program that i can feed like this `echo "chinese" | zi4pu3`
18:37:09 <oerjan> :t isEof
18:37:09 <lambdabot> Not in scope: `isEof'
18:37:17 <oerjan> :t isEOF
18:37:18 <lambdabot> Not in scope: `isEOF'
18:37:19 <jsnx> oerjan: oh, hmmm
18:37:28 <oerjan> :t System.IO.isEof
18:37:28 <lambdabot> Not in scope: `System.IO.isEof'
18:37:32 <oerjan> :t System.IO.isEOF
18:37:33 <lambdabot> IO Bool
18:37:34 <jsnx> oerjan: will give that a shot
18:37:54 <jsnx> weird
18:38:26 <desp> puusorsa: There's still time to think of something that will think of something.
18:38:54 <puusorsa> why bother
18:39:16 <puusorsa> i think burroughs wasn't too stupid
18:39:17 <sphynx> hi again!
18:39:22 <puusorsa> exterminate all rational thought!
18:39:37 <sclv> http://osteele.com/sources/javascript/functional/
18:39:37 <lambdabot> Title: Functional Javascript
18:39:42 <puusorsa> or die trying
18:39:48 <sclv> sfultong: ^^
18:40:20 <sfultong> thanks Lemmih, sclv
18:40:32 <toad3k> :i Data.Binary.decode
18:40:37 <hpaste>  glguy pasted "subtextual video's damage function" at http://hpaste.org/4824
18:40:38 <toad3k> :t Data.Binary.decode
18:40:39 <lambdabot> forall a. (Data.Binary.Binary a) => Data.ByteString.Lazy.ByteString -> a
18:43:00 <clanehin> oerjan: thanks
18:48:26 <monochrom> Haha nice, http://blog.plover.com/prog/haskell/pointfree.html (item 165 in HWN) cites my writing :)
18:48:26 <lambdabot> Title: The Universe of Discourse : Note on point-free programming style
18:49:53 <monochrom> Oh gosh, item 175 also cites the same writing of mine.
18:50:19 <monochrom> Maybe I should add this fact to my CV. "Many blogs cite my writing!"
18:50:24 <glguy> where is the hwn available?
18:50:37 <monochrom> Not on the web yet. In the haskell mailing list.
18:50:55 <loupgaroublond> monochrom: do you normally put where you've been cited on a british CV?
18:51:04 <dons> http://article.gmane.org/gmane.comp.lang.haskell.cafe/34514
18:51:05 <lambdabot> Title: Gmane -- Mail To News And Back Again
18:51:05 <monochrom> No.
18:51:09 <dons> glguy: ^
18:51:13 <glguy> thanks
18:51:55 <monochrom> However, if I have something to brag, may as well brag on my CV, conventional or unconventional. XD
18:52:17 <glguy> Did you read the latest thread about darcs 2 being 10 - 100x slower in common operations?
18:52:24 <abz> so why does hpaste have type  (a -> b) -> f a -> f b ?
18:52:25 <glguy> it wasn't clear if that was a bug or a fact of the new algorithms
18:52:50 <abz> is there any reason, or was it just for looks?
18:53:05 <monochrom> Now I wonder why on January 3 suddenly two bloggers got interested in my little pointfree note.
18:53:26 <dons> monochrom: one wrote something, the second responded
18:54:07 <monochrom> This is encouraging. I should write more. :)
18:54:41 <loupgaroublond> i learn alot from blog tidbits, much easier to read than some of the papers you gents churn out on a regular rate
18:57:01 <glguy> abz, dons picked it, but I think that it is for looks
18:57:32 <monochrom> Yes, academic writing takes a bit of training to read. Mostly training to recognize what to skip, what to expect in each section, what to read first. :)
18:58:43 <loupgaroublond> not to mention, not everyone can afford the 40k USD (or equiv) a year for that training
18:59:35 <monochrom> Actually, no one trained me. I trained myself.
19:00:07 <abz> glguy: Cool, thanks.
19:00:51 <fadec> another on the topic of unix pipes - submitted by dons on reddit http://blog.closuretohome.com/2008/01/sharper-function-operators.html
19:00:52 <lambdabot> Title: Closure to Home: Sharper function operators, http://tinyurl.com/2yy5rv
19:01:01 <monochrom> Err, I guess that's a lie. I certainly got trained by others when writing papers with others. They told me what must be written in what sections. From that I deduced how to read such a thing.
19:02:27 <loupgaroublond> the truth comes out :)
19:02:32 <monochrom> Here is an example. The "introduction" section is written for those who already know the research area. It is written to justify the new work reported in the paper, or even arguing that it is new work.
19:03:11 <loupgaroublond> well, it's not that us plebians can't read them, it just takes much longer
19:03:22 <monochrom> Therefore, a non-academic reader is probably well-advised to skip it.  1. You have already decided you want to know, you don't need the sales pitch.  2. It is written for those who already know a lot. It makes no sense to a beginner.
19:04:30 <monochrom> Only about 1% of the papers have excellent introductions. "excellent" means serving both the above academic purpose and also makes sense to beginners.
19:04:41 <monochrom> E.g., Wadler's are mostly OK.
19:04:46 <EvilTerran> i use the intro as a guide for what dependencies i need to chase before i can start on the paper proper
19:05:18 <EvilTerran> there should be some nice computer-readable standard for thatr
19:05:32 <EvilTerran> "in order to understand this paper, you'll first need to understand these: ..."
19:05:41 <EvilTerran> then you could have a little script to chase them all down for you
19:05:56 <EvilTerran> does BibTeX have something for that?
19:05:57 <monochrom> Section 2 is usually the dependency.
19:06:11 <loupgaroublond> make it mandatory for all haskell papers to submit a metapackage to hackage that defines their dependencies, so a depency tracker could figure it all out?
19:06:17 <loupgaroublond> :P
19:07:05 <monochrom> E.g., Suppose a paper is on the State monad.  Then Section 2 is a crash course on the basics of monads. Or maybe not so basic but whatever is used in the rest of the paper.  Then usually section 3 and onwards is the promised State monad.
19:07:50 <EvilTerran> need to distinguish between references that're vital groundwork for this paper, and references that're just "further reading"
19:07:52 <monochrom> If the crash course is inadequate for you, usually it also has pointers to further reading.
19:08:06 <magnus> @pl \x -> x * x
19:08:06 <lambdabot> join (*)
19:09:05 <sphynx> @pl \x -> x * x * x
19:09:05 <lambdabot> (*) =<< join (*)
19:09:44 <xpika> hi
19:09:56 <xpika> is there a haskell library for permutations
19:10:56 <sphynx> hm... \x -> x * x == join (*)  how this thing works?
19:11:09 <sphynx> is it that join :: m (m a) -> m a ?
19:11:22 <oerjan> sphynx: that and using the (r ->) monad
19:11:42 <sphynx> hm, what a strange monad (r ->)
19:11:44 <oerjan> so join :: (r -> r -> a) -> (r -> a)
19:11:48 <dancor> how could a library i just installed have a linking error
19:11:52 <sphynx> where can I read smth about it?
19:12:01 <oerjan> sphynx: it's Reader
19:12:16 <oerjan> without the usual type wrapping
19:12:44 <BMeph> So, is there a name for the reverse-bind?
19:13:39 <sphynx> oerjan: so how can I use this join (*) to calculate 2 * 2 for example? Something with runReader?
19:13:46 <dancor> more specifically, in what case would something compile without errors and then immediately contain undefined references to other parts within the same library
19:13:51 <oerjan> > join (*) 2
19:13:52 <lambdabot>  4
19:14:06 <sphynx> but it doesn't work in my ghci
19:14:09 <oerjan> sphynx: runReader is only for removing the Reader type wrapping
19:14:17 <oerjan> sphynx: oh, import Control.Monad.Reader
19:14:25 <oerjan> the monad instance is there
19:14:50 <sphynx> ahh, ok, I've imported Control.Monad only before that
19:14:55 <sphynx> it works now
19:15:14 <sphynx> Anyway, is there anywhere more detailed explanation of these tricks with Reader?
19:15:40 <sphynx> I know about Reader only one thing - that it is used for reading from some common environment
19:15:45 <bos> @seen augustss
19:15:45 <lambdabot> I saw augustss leaving #haskell 1d 19h 45m 23s ago, and .
19:15:48 <oerjan> sphynx: i don't know, just picked it up here on the channel
19:16:10 <oerjan> if you mean the tricks for making things point-free
19:16:23 <oerjan> but you can experiment with lambdabot's @pl
19:16:46 <sphynx> yeah, making point-free with help of Reader, and maybe arrows
19:17:07 <oerjan>  @pl is not that good with arrows though
19:17:20 <oerjan> it often uses lots of . and stuff instead
19:17:40 <oerjan> @pl x -> (f x, g x)
19:17:41 <lambdabot> (line 1, column 3):
19:17:41 <lambdabot> unexpected ">" or "-"
19:17:41 <lambdabot> expecting variable, "(", operator or end of input
19:17:42 <sphynx> yeah, smth like (.) . (.) and other fun stuff :)
19:17:49 <oerjan> @pl \x -> (f x, g x)
19:17:49 <lambdabot> liftM2 (,) f g
19:18:11 <oerjan> that's f &&& g
19:18:30 <sphynx> something called 'pair' in Bird's book
19:18:36 <sphynx> IIRC
19:18:42 <oerjan> so @pl used the -> monad instead
19:19:03 <sphynx> maybe I sould take a look at source of Reader monad
19:19:19 <sphynx> to make things clearer
19:19:32 <BMeph> sphinx: Control.Monad.Instances is also a good place. It's a big pain to me, that there's a separate module containing which types qualify as monads.
19:21:10 <sphynx> @src Control.Monad.Reader
19:21:11 <lambdabot> Source not found.
19:21:18 <sphynx> @src Reader
19:21:18 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:22:57 <sphynx> BMeph: thanks, I will take a look
19:27:19 <oerjan> @source Control.Monad.Reader
19:27:19 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
19:28:13 <oerjan> that link may or may not be up-to-date...
19:29:11 <oerjan> but it's nicer to go via the documentation pages now, they've got much nicer interface with 6.8
19:37:45 <mcnster> hi.  rts q:  is it true in 6.8.2 that the __stginit_Main and equivalents in other modules are never invoked?
19:41:24 <mcnster> doesn't anyone hack on saturday night anymore? ;-)
19:43:09 <oerjan> mcnster: you're about half an hour late
19:43:31 <oerjan> um make that 20 minutes
19:44:21 <mcnster> oerjan, oh.  i'll have to learn to read faster then
19:44:42 <oerjan> oh i didn't mean the question had been asked
19:44:53 <oerjan> i just meant that's when there was activity here :)
19:45:36 <mcnster> oerjan, i understand.  the haskell gods are probably scarfing down take out chinese food, but not at their consoles?  how odd... ;-)
19:45:57 <xpika> @pl  concat $ map (\x -> map (+x*(13)) [0..3]) [0..3]
19:45:57 <lambdabot> flip map [0..3] . (+) . (13 *) =<< [0..3]
19:46:04 <loupgaroublond> it must be tasty chinese
19:46:48 <oerjan> @pl concatMap (\x -> map (+x*(13)) [0..3]) [0..3]
19:46:49 <lambdabot> flip map [0..3] . (+) . (13 *) =<< [0..3]
19:46:55 <oerjan> oh right
19:56:56 <oerjan> :t concat $ map (\x -> map (+x*(13)) [0..3]) [0..3]
19:56:58 <lambdabot> forall a. (Num a, Enum a) => [a]
19:57:04 <oerjan> right...
19:57:40 <oerjan> > [13*x+y | x <- [0..3], y <- [0..3]]
19:57:42 <lambdabot>  [0,1,2,3,13,14,15,16,26,27,28,29,39,40,41,42]
20:00:24 <oerjan> > (join . liftM2 $ (+).(13*)) [0..3]
20:00:24 <lambdabot>  [0,1,2,3,13,14,15,16,26,27,28,29,39,40,41,42]
20:07:14 <EvilTerran> @oeis 0 1 2 3 13 14 15
20:07:14 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
20:07:29 <jive> http://news.bbc.co.uk/2/hi/americas/7173527.stm
20:07:29 <lambdabot> Title: BBC NEWS | Americas | Bogota opens 'museum of laziness'
20:07:53 <xpika> @pl \n -> length [1..n]
20:07:53 <lambdabot> length . enumFromTo 1
20:08:47 <ricky_clarkson> Can someone keep SPJ locked up until he's done A Taste of Haskell again with a decent cameraman?
20:08:48 <oerjan> > maxBound :: Int
20:08:50 <lambdabot>  2147483647
20:09:05 <oerjan> > length [1..2147483648]
20:09:08 <lambdabot> Terminated
20:09:13 <oerjan> bah :D
20:10:22 <loupgaroublond> >length [1..]
20:10:28 <loupgaroublond> > length [1..]
20:10:31 <lambdabot> Terminated
20:10:50 <ricky_clarkson> @src Bool
20:10:51 <lambdabot> data Bool = False | True deriving (Eq, Ord)
20:11:09 <ricky_clarkson> How does show True work?
20:11:58 <oerjan> it's the derived one, except ghc implements it separately for some reason
20:12:46 <ricky_clarkson> Does that derivation need syntax for other datatypes then?
20:13:10 <oerjan> the haskell report simply says data  Bool  =  False | True     deriving (Eq, Ord, Enum, Read, Show, Bounded)
20:13:38 <ricky_clarkson> Ok, thanks.
20:18:41 <mcnster> ricky_clarkson, see instance declaration at libraries/base/GHC/Show.lhs:174
20:20:40 <EvilTerran> > length [1..2147483648::Int]
20:20:41 <lambdabot>  0
20:21:01 <EvilTerran> > 2147483648::Int
20:21:01 <lambdabot>  -2147483648
20:21:48 <idnar> > length [1..2147483647]
20:21:51 <lambdabot> Terminated
20:21:54 <idnar> :t [1..2147483647]
20:21:55 <lambdabot> forall t. (Num t, Enum t) => [t]
20:21:59 <ricky_clarkson> > 2147483647*2
20:22:00 <lambdabot>  4294967294
20:22:22 <ricky_clarkson> > 4294967295 :: Int
20:22:22 <lambdabot>  -1
20:23:21 <paczesiowa> sjanssen: that code you gave me earlier wasne little endian:-(
20:26:36 <ricky_clarkson> "You can write forall a., but writing an upside down A looks more impressive" -- now I know why papers are littered with dyslexic symbols.
20:27:12 <monochrom> Who would say that?
20:27:20 <loupgaroublond> you can always hack emacs to put an upside down A instead of forall
20:27:33 <monochrom> I use ∀ because it saves space. Shorter than forall.
20:27:43 <ricky_clarkson> SPJ said that.
20:28:03 <monochrom> If someone wants me to write Ax. x->x I don't mind doing that too.
20:28:36 <monochrom> I think he was joking.
20:34:50 <hpaste>  Paczesiowa pasted "only ghci loves me" at http://hpaste.org/4825
20:35:15 <paczesiowa> anyone can help me or at least point my error and tell me to go to sleep?
20:35:16 <ricky_clarkson> monochrom: You're of course right.  I was also joking.
20:36:03 <monochrom> OK! :)
20:36:40 <oerjan> paczesiowa: when you do x <- computeHash file does it print the result?
20:36:57 <oerjan> that could be enough to force more strictness
20:37:41 <monochrom> Precisely.
20:38:41 <monochrom> To obtain 0 in ghci, :set -fno-print-bind-result
20:38:59 <monochrom> IMO print-bind-result is evil.
20:39:13 <paczesiowa> so that's on of those evil lazy IO things, right?
20:39:13 <monochrom> And this example is not my only reason.
20:39:43 <oerjan> paczesiowa: if you change return $ sum beginning to return $! sum beginning, it should force the actual calculation
20:40:43 <monochrom> hGetContents is lazy IO, yes.
20:41:25 <paczesiowa> then I need some hardworking version of hGetContents
20:42:13 <monochrom> Since you already use ByteString, you may like to look for one there.
20:44:19 <paczesiowa> there's hGet
20:44:48 <monochrom> It is odd that a "hash" depends only on the first 8192 units of the file.
20:45:20 <paczesiowa> it's lazy hash:P
20:45:43 <paczesiowa> http://trac.opensubtitles.org/projects/opensubtitles/wiki/HashSourceCodes
20:45:44 <lambdabot> Title: HashSourceCodes - OpenSubtitles.org - Trac, http://tinyurl.com/3yzapa
20:51:51 <monochrom> Perhaps hGet, hSeek, hGet is the right approach.
20:52:33 <paczesiowa> yes it is
21:02:07 <sutats> What's the difference between C-- and something like LLVM?
21:06:12 <ricky_clarkson> "Actually the universe does not disappear into your laptop when you run a Haskell program" -- SPJ
21:06:54 <bos> sutats: C-- is a language. llvm is a toolkit.
21:08:38 <wolverian> cabal-install++ # it works
21:09:35 <sutats> bos: Are they trying to accomplish the same thing though?
21:11:12 <bos> sutats: C-- is similar to LLVM's IR, but how else does one compare a language specification with a bunch of software? they're different categories of thing.
21:12:37 <sutats> bos: Okay, that makes sense, thanks.
21:14:11 <bos> ooh, augustss has started hacking on the llvm bindings.  this is good, because i need to return to hacking on the book.
21:19:37 <paczesiowa> just want to make sure, is addition associative with positive numbers (but results can overflow)?
21:20:35 <oerjan> for most fixed with Int- and Word-like types, i think so
21:20:43 <oerjan> they use modulo arithmetic
21:20:47 <oerjan> *width
21:23:00 <paczesiowa> oerjan: thx
21:25:14 <wolverian> hm. how can I configure the default prefix in cabal-install?
21:26:31 <wolverian> is the ~/.cabal/config file documented anywhere?
21:29:27 <wolverian> user-prefix: ... I think
21:29:59 <wolverian> hm, no.
21:32:36 <wolverian> actually, I think that's supposed to work
21:32:53 <wolverian> however, I get: "Warning: Error parsing config file /home/wolverian/.cabal/config: On line 5: Parse of field 'prefix' failed:"
21:45:22 <dibblego> why is there msum when there is join?
21:45:42 <oerjan> @src msum
21:45:42 <lambdabot> msum =  foldr mplus mzero
21:45:51 <dibblego> oh of course
21:46:14 <oerjan> they're along different axes, almost like addition vs. multiplication
21:50:19 <notsmack> @src join
21:50:19 <lambdabot> join x =  x >>= id
21:52:56 <notsmack> @type join
21:52:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:53:36 <BMeph> wolverian: If you're having that much trouble, maybe you should go to the source: http://www.haskell.org/ghc/docs/latest/Cabal.pdf
21:54:27 <dibblego> I didn't see the MonadPlus on msum
21:54:35 <dibblego> s/see/take notice of
21:54:59 <BMeph> Never mind - cabal-install, I see. :p
22:00:30 <wolverian> BMeph, yeah. I submitted a ticket.
22:00:42 <wolverian> (http://hackage.haskell.org/trac/hackage/ticket/204)
22:00:43 <lambdabot> Title: #204 (should setting user-prefix in ~/.cabal/config work?) - Hackage - Trac
22:14:00 <blackdog> is there a clever way to automatically intern strings in haskell?
22:14:23 <blackdog> i can do it explicitly with a dictionary, but it muddies the intent of the code a little
22:14:34 <sjanssen> intern?
22:15:04 <oerjan> a trie perhaps?
22:15:46 <blackdog> have strings automatically committed to a lookup table, so that if i read in a file which has 40 repetitions of the word "tragic", i only store it once.
22:16:15 <blackdog> (i have an algorithm that's working fine, but taking three orders of magnitude too much space :)
22:16:35 <sjanssen> is the behavior referentially transparent?  If so, unsafePerformIO is probably okay here
22:17:03 <blackdog> yeah, it is.
22:17:07 <Cale> http://programming.reddit.com/info/64o48/comments/ -- Reddit HWN link
22:18:40 <sjanssen> or if you don't want to sell out, a nice little state monad would be fine
22:21:54 * MyCatVerbs wants to sell out.
22:22:08 <MyCatVerbs> Fuck talent, where do I sign up for moeny and power?
22:22:56 <MyCatVerbs> Oh and free garlic. I can get that too, right?
22:23:39 * MyCatVerbs <3 garlic. Garlic makes everything better. Kudos to the French, they know a good thing when they see it. Taste it.
22:26:30 <dons> Cale: thanks :)
22:30:08 <Cale> No problem :)
22:30:55 <dons> apparently sequence.complete.org has moved to pdx, and this is some db failure associated with the migration
22:31:02 <dons> the website will get fixed up at some point
22:35:33 <dons> pity the downmods. its a good news week, http://programming.reddit.com/info/64o48/details
22:41:05 <dons> so does anyone go through all the entries in the hwn?
22:41:12 <dons> it almost needs to come out weekly to keep up with things :)
22:42:31 <fsh2> i'm trying to parse haskell-ish expressions with parsec, but i'm a bit stumped when it comes to using buildExpressionParser in conjunction with the "apply" pattern of 'f x'.. do i maybe "try" the expr parser first, and if it fails try to parse a function application?
22:45:04 <ddarius> fsh2: Application is effectively just a higher precedence "operator"
22:46:31 <fsh2> yeah, but i can't specify binary "" as an operator in the op table?
22:47:32 <fsh2> hmm, guess if i want to support sections like (+) and (2 +) i can't use buildExpressionParser then anyway..
22:47:53 <runar> How can I get quickCheck to test the equivalence of two functions?
22:48:30 <oerjan> fsh2: i think you want applications to be your base terms
22:49:24 <sjanssen> runar: saturate them with arguments
22:49:40 <runar> I think I saw somebody here do something like "check f1 == f2"
22:49:50 <oerjan> runar: === i think
22:50:12 <runar> something to that effect
22:50:19 <oerjan> except it must be in a newer version because it always fails when people try it on lambdabot
22:50:42 <runar> Oh, perhaps they tried and failed then.
22:51:13 <oerjan> @check (id :: Int -> Int) === ($)
22:51:14 <lambdabot>   Not in scope: `==='
22:51:41 <sjanssen> @check (\xs ys -> (xs ++ ys :: [Int]) == foldr (:) ys xs)
22:51:41 <lambdabot>  OK, passed 500 tests.
22:51:51 <sjanssen> you can do something like that
22:52:23 <runar> that's it!
22:52:49 <sjanssen> '@check' is approximately equivalent to the quickCheck function
22:53:06 <runar> right on. Thanks a lot.
23:00:31 <sjanssen> @quote types.are.strong
23:00:31 <lambdabot> No quotes match. You speak an infinite deal of nothing
23:00:40 <sjanssen> @quote markedtrees
23:00:40 <lambdabot> No quotes match. :(
23:02:25 <sjanssen> @remember markedtrees Ah yes, Haskell. Where the types are strong, all the men carry arrows, and all the children are above average.
23:02:25 <lambdabot> Done.
23:02:36 <sjanssen> gotta love the Lake Wobegon humor :)
23:03:08 <dons> :)
23:03:40 <sjanssen> dons: are you familiar?  I doubt the show makes it all the way to .au
23:05:09 <dons> sjanssen: i'm familiar with it, since i've been in the US
23:05:34 <bos> the internet falls asleep while transmitting garrison keillor's voice to australia. the data never actually gets through.
23:05:45 <dons> tv and radio. Garrison Keillor has a very distinct voice
23:05:54 <dons> heh
23:09:12 <bos> augustss is working on some nice monadic wrappers for the llvm bindings.
23:11:03 <jsnx> is unicode syntax deprecated?
23:11:29 <bos> i think only ghc supports it.
23:11:57 <dons> its definitely not deprecated.
23:12:05 <jsnx> well, even ghc does not document it
23:13:24 <sjanssen> are you sure about that?
23:15:23 <dons> its in section 5.6.1. of the user's guide
23:15:27 <jsnx> sjanssen: well, i am reading the docs for ghc 6.8.2 -- and there's no link from "-XUnicodeSyntax" to documentation
23:15:30 <jsnx> oh
23:15:35 <dons> "GHC assumes that source files are ASCII or UTF-8 only, other encodings are not recognised. However,
23:15:38 <dons> invalid UTF-8 sequences will be ignored in comments, so it is possible to use other encodings such
23:15:41 <dons> as Latin-1, as long as the non-comment source code is ASCII only.
23:15:43 <dons> "
23:15:58 <dons> and then, yes, -XUnicodeSyntax             |Enable unicode syntax.       |dynamic|-XNoUnicodeSyntax
23:16:49 <jsnx> well, i was looking for docs that would say: "you can use
23:17:02 <sjanssen> "invalid UTF-8 sequences will be ignored in comments" sounds like a decision that they will regret
23:17:07 <jsnx> λ → ...
23:17:13 <jsnx> &c."
23:17:16 <dons> yeah, looks like a bug report (or some docs) are needed
23:17:21 <dons> esp. for the unicode keywords
23:17:48 <jsnx> same thing for magic hash
23:17:51 <flux> sjanssen, what kind of implications do you think there could be?
23:18:36 <sjanssen> flux: it means they've got to interpret the characters in the lexer rather than call out to an external library
23:20:17 <jsnx> dons: i've got ghc sources, and would be happy to contribute some documentation
23:20:19 <sjanssen> jsnx: the report has some things to say about Unicode characters in source
23:20:31 <jsnx> sjanssen: oh, the haskell report has it...
23:21:32 <flux> sjanssen, you mean they need to decode utf8 in the lexer.. well, it's not likely utf8 format is going to change, and given its simplicity, it's doubtful there are bugs in the decoder.
23:22:05 <sjanssen> the description is somewhat vague, "uniSymbol" is not explicitly defined
23:23:05 <sjanssen> flux: yes, I meant they need to interpret the "bytes", not the "characters".  Which is the problem, really -- IMO it's nicer to define the lexer as an operation on characters rather than bytes
23:23:12 <hpaste>  mmorrow pasted "okasaki structural decomp" at http://hpaste.org/4826
23:23:44 <dons> jsnx: but you know about these unicode keywords right? like forall and -> and so on? i wonder why they're not documented.
23:24:03 <jsnx> dons: i have no idea what they are, just →
23:24:10 <jsnx> dons: haven't seen any others
23:24:32 <jsnx> googling `haskell "unicode syntax"` gets you porn sites on the first page of results!
23:24:47 <dons> #if __GLASGOW_HASKELL__ >= 605
23:24:47 <dons>        ,("â~H·",   ITdcolon, unicodeSyntaxEnabled)
23:24:47 <dons>        ,("â~G~R",   ITdarrow, unicodeSyntaxEnabled)
23:24:47 <dons>        ,("â~H~@",   ITforall, \i -> unicodeSyntaxEnabled i &&
23:24:47 <dons>                                 explicitForallEnabled i)
23:24:49 <dons>        ,("â~F~R",   ITrarrow, unicodeSyntaxEnabled)
23:24:52 <dons>        ,("â~F~P",   ITlarrow, unicodeSyntaxEnabled)
23:24:54 <dons>        ,("â~K¯",   ITdotdot, unicodeSyntaxEnabled)
23:24:57 <dons>         -- ToDo: ideally, â~F~R and â~H· should be "specials", so that they cannot
23:25:00 <dons>         -- form part of a large operator.  This would let us have a better
23:25:02 <dons>         -- syntax for kinds: É~Qâ~H·*â~F~R* would be a legal kind signature. (maybe).
23:25:05 <dons> so they're turned on by the flag
23:25:11 <runar> Pretty much every google query gets you porn sites on the first page.
23:25:13 <dons> no lambda though, due to the case.
23:25:25 <runar> make that "image query"
23:25:28 <flux> sjanssen, can't they just switch to 'swallow anything' lexer when they discover a comment character, until eol? and otherwise the input still needs to be read and still needs to be utf8-decoded etc.
23:25:31 <hpaste>  mmorrow annotated "okasaki structural decomp" with "(no title)" at http://hpaste.org/4826#a1
23:25:45 <flux> (well, add block comment support too)
23:26:12 <flux> s/comment character/comment sequence/
23:26:13 <dons> jsnx: check Lexer.x
23:26:38 <hpaste>  mmorrow annotated "okasaki structural decomp" with "(no title)" at http://hpaste.org/4826#a2
23:26:41 <dons> sjanssen: we need that debian 0.5 package, http://people.debian.org/~igloo/popcon-graphs/index.php?packages=xmonad%2Cstumpwm%2Cawesome&show_installed=on&want_legend=on&want_ticks=on&from_date=2007-10-01&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
23:26:42 <lambdabot> Title: popcon graph, http://tinyurl.com/3bcv55
23:26:55 <jsnx> dons: did my unicode look all messed up to you?
23:27:11 <sjanssen> flux: why should the lexer care about UTF-8 at all?
23:27:42 <dons> jsnx: i've not got utf8 enabled, so yep.
23:27:45 <sjanssen> flux: isn't "lex . decodeUTF8" better?
23:27:56 <flux> sjanssen, you mean it should get a decoded stream in? I think that should still be possible, but the composition isn't quite as neat as you put it
23:28:12 <sjanssen> flux: why isn't it?
23:28:29 <jsnx> dons: well, yours looked all silly to me, so :)
23:29:27 <flux> yes, due to blocks of code being interpreted in different character set, that cannot be done, which is what you've been saying. but it doesn't need to be a big problem, all it needs is a mechanism that allows changing the decoding format of the input stream.
23:30:26 <sjanssen> well, GHC already pretends that other character sets don't exist.  Besides, source files with multiple encodings are dubious at best
23:31:26 <runar> What's the difference between div and quot?
23:31:38 <flux> I guess the use case is exactly as mentioned: you might want to have the actual source in a ascii, and comments in latin1
23:31:55 <flux> so effectively the whole source code would be latin1, and ghc would still accept it
23:32:05 <sjanssen> flux: in fact, "lex . decode" is actually easier to adapt to multiple encodings in a robust fashion
23:32:31 <flux> sjanssen, I'm not denyint that wouldn't be simpler
23:32:33 <flux> denying, even
23:32:46 <mauke> > [div 5 (-4), quot 5 (-4)]
23:32:47 <lambdabot>  [-2,-1]
23:33:11 <flux> many (?) programming languages sort of behave that way already, by accepting any data in but the actual accepted identifiers etc are limited to a subset of ascii
23:46:51 <xpika> how do I make a data type data Foo = Bar (Integral a)
23:46:54 <xpika> ?
23:47:11 <oerjan> data Foo = forall a. Integral a => Bar a
23:47:29 <xpika> oerjan: thanks
23:47:45 <xpika> Not a constructor: `forall'
23:47:53 <oerjan> requires existential types extension
23:47:53 <mauke> -fglasgow-exts
23:47:55 <xpika> is this GHC only
23:48:49 <oerjan> no, hugs has it too, don't know about the others
23:59:55 <dibblego> can filterM be written as a foldr?
