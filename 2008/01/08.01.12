00:19:13 <Cin> oh, ace
00:19:36 <Cin> i didn't realise that one could export a data type but not its constructors
00:19:41 <Cin> good means of encapsulation
00:24:51 <Cin> SPJ makes me excited about haskell, heh
00:55:09 <czakey> uh damn...
00:56:02 <czakey> ive crashed my computer...
00:56:27 <czakey> im novice in haskell -> so experimenting
00:56:35 <czakey> ive done:
00:56:55 <czakey> let bigone = [1..]
00:57:05 <czakey> length bigone
00:57:09 <czakey> :D
00:57:29 <czakey> helloo everybody btw ;)
00:59:51 <therp> good morning
01:00:36 <czakey> good morning...
01:00:54 <Vq^> only problem with that is that it doesn't terminate :)
01:01:01 <czakey> yep
01:01:35 <czakey> it takes 100% of resouces
01:01:53 <czakey> and frucking windows hangs ;d
01:02:02 <Vq^> :/
01:02:58 <czakey> unfortunately I don't have any u*ix here
01:03:11 <kaol> doing the same thing with any programming language would have crashed windows if it was about to crash due to that. Only in haskell, it was almost trivial to do that.
01:03:31 <czakey> mhm
01:03:38 <czakey> but Prolog
01:04:29 <kaol> unless there was some way to detect an infinite list beforehand... but that couldn't be a generic check, due to halting problem and all.
01:07:55 <Cale> um, that really shouldn't crash windows.
01:08:38 <Cale> In particular, you should be able to stop the computation with some appropriate key combination, perhaps Ctrl-C
01:08:48 <czakey> that didn't crash it for real. that hang it :P
01:09:01 <Cale> well, still
01:09:20 <czakey> ctrl-c didn't work
01:09:21 <Cale> It should just keep running until you decide to stop it.
01:09:27 <Cale> hmm
01:09:35 <Cale> Perhaps the key is different on windows.
01:09:51 <Svrog> in the worst case you can just kill it from the task manager
01:09:57 <czakey> same i think
01:09:59 <Svrog> pretty sure ctrl-c works from ghci on windows
01:10:17 <czakey> task manager loads about 5 minutes ;d
01:10:19 <Cale> But I'm not inclined to believe they wouldn't leave a way to kill a nonterminating computation in ghci.
01:10:43 <Cale> czakey: are you running just about out of memory or something? Is it swapping?
01:10:55 <czakey> task maneger shoud work
01:11:00 <czakey> but it didnt
01:11:22 <czakey> yep swap was in use I think
01:12:14 <czakey> because disk started to produce some noises :D
01:12:39 <czakey> whatever
01:14:54 <Cale> Perhaps it somehow ran your machine out of memory. That'd do it.
01:15:44 <Cale> evaluating [1..] should run in memory which is proportional to the log of the time you let it run though.
01:16:07 <dubblego> can groupBy be written as a foldr within a foldr?
01:16:12 <Cale> However, if your terminal has a large backbuffer, it would fill that up pretty quickly :)
01:19:49 <Cale> dubblego: Well, I can write group as a single foldr, and groupBy shouldn't be any harder.
01:20:24 <Cale> I'm not exactly sure how nesting them will help any...
01:20:40 <Cale> > foldr (\x xs -> case xs of [] -> [[x]]; ((y:ys):yss) -> if x == y then (x:y:ys):yss else [x]:(y:ys):yss) [] "mississippi"
01:20:40 <lambdabot>  ["m","i","ss","i","ss","i","pp","i"]
01:24:05 <Cale> (anyone think of a way to clean that up any?)
01:24:43 <Cale> maybe just using 'head' would look nicer
01:24:55 <sjanssen> Cale: you can't write groupBy with that method
01:25:09 <Cale> > foldr (\x xs -> case xs of [] -> [[x]]; (ys:yss) -> if x == head ys then (x:ys):yss else [x]:ys:yss) [] "mississippi"
01:25:10 <lambdabot>  ["m","i","ss","i","ss","i","pp","i"]
01:25:30 <sjanssen> I think this version is slightly more strict, also
01:25:39 <Cale> hmm
01:25:52 <sjanssen> @src groupBy
01:25:53 <lambdabot> groupBy _  []       =  []
01:25:53 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
01:25:53 <lambdabot>     where (ys,zs) = span (eq x) xs
01:26:46 <glguy> > foldr (\x xs -> case xs of [] -> [[x]]; (ys:yss) -> if x == head ys then (x:ys):yss else [x]:ys:yss) [] [1,1..]
01:26:47 <lambdabot>  Exception: stack overflow
01:26:54 <glguy> > groupBy (==) [1,1..]
01:26:54 <lambdabot>  [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
01:26:59 <sjanssen> yep
01:27:25 <Cale> hmm, yeah
01:28:10 <sjanssen> I think you have to do some fancy CPS
01:28:32 <Cale> Surely it ought to be doable then :)
01:29:36 <Cale> hey, didn't this come up on the mailing lists a while back, or maybe in a paper?
01:34:05 <dubblego> Cale, that's as far as I had got; I was trying to remove the case matches as well, but I'm feeling a bit fried
01:42:16 <mountain_> Hello all. I am a newbie in this channel. Just want to know how many guys from China?
01:42:50 <Cale> Hi mountain_ I'm not sure how many.
01:43:03 <Cale> (I'm from Canada, myself)
01:43:36 <xpika> if I have data Mytype = Foo Int | Bar Int is thereway to generalise (mytype n) = mytype (n+1)?
01:44:13 <Cale> uh
01:44:34 <Cale> Mytype is a type with no parameters, I'm not sure I understand...
01:45:11 <xpika> as apposed to addone (Foo n) = Foo (n +1) and addone (Bar n) = Bar (n +1)
01:45:42 <mrd> late nighters huh
01:45:56 <Cale> xpika: ah
01:45:59 <sjanssen> xpika: seems like Mytype wants to be a functor
01:46:06 <sjanssen> data Mytype a = Foo a | Bar a
01:46:29 <Cale> xpika: yeah, maybe you could do what sjanssen is suggesting
01:46:44 <Cale> Or just write a function with type  (Int -> Int) -> Mytype -> Mytype
01:47:37 <xpika> there's always SYB but that seems like overkill
01:48:03 <czakey> hmm
01:48:21 <czakey> anyone knows some good introduction to gui?
01:48:48 <Cale> czakey: There's a new intro to Gtk2Hs, I think.
01:49:14 <czakey> so gtk2hs for start?
01:49:25 <czakey> wxwindows ist good?
01:49:37 <Cale> It's also decent.
01:49:38 <xpika> czakey: what OS are you running?
01:49:40 <czakey> *isn't*
01:49:52 <czakey> XP right now
01:50:10 <czakey> but I want it to be os-independent
01:50:12 <Cale> Of course, which library you use will probably determine what set of tutorials you'll want to try :)
01:50:27 <xpika> czakey: both wxwidgets and gtk2hs is
01:50:39 <Cale> wxHaskell too :)
01:50:48 <profmakx> s wxHaskell maintained?
01:50:53 <Cale> yes
01:51:01 <profmakx> i tend to like wxwindows better than gtk
01:51:05 <Cale> In fact, it has new developers.
01:51:10 <xpika> czakey: but I can't remember where to get the wxwindows binaries
01:51:14 <profmakx> oh, didnt notice that
01:51:16 <Cale> Make sure you get the darcs version if you're going to try it.
01:51:28 <Cale> The old version is probably broken.
01:51:31 <czakey> i like darcs much
01:51:38 <profmakx> i will try that out right after i wrote up my thesis ... which will be in 1 month or so ;)
01:51:44 <czakey> ive used it before i even know what haskell is
01:51:45 <czakey> :D
01:51:57 <xpika> czakey:compiling wxwidgets on windows isn't the easiest thing to compile (lots of dependancies with version requirements)
01:52:06 <czakey> hmm
01:52:08 <Cale> http://www.haskell.org/gtk2hs/docs/tutorial/glade/ -- this looks like a nice intro to using Gtk2Hs with Glade.
01:52:09 <lambdabot> Title: Gtk2Hs » Documentation » Glade Tutorial
01:52:16 <czakey> thanks
01:52:20 <xpika> you can get gtk2hs binaries
01:52:45 <Svrog> with cygwin or mingw its not that difficult
01:53:06 <Cale> http://darcs.haskell.org/gtk2hs/docs/tutorial/Tutorial_Port/ -- this is a larger tutorial, which is a port of one originally written for C, I think.
01:53:19 <xpika> http://haskell.org/gtk2hs/download/
01:53:28 <xpika> has binaries
01:54:12 <Cale> It gets right into the details of packing and describing user interfaces with code.
01:54:25 <Cale> Personally, I like using Glade with Gtk2Hs much better.
01:55:33 <Cale> You're designing a graphical user interface, the tools for describing it should be graphical :)
01:56:04 <czakey> hehe
01:56:57 <Cale> Heh, Ubuntu's little orange star icon owns me. I see it in a screenshot and I immediately think "software updates!"
01:57:42 <profmakx> quite a good point, Cale
01:58:13 <profmakx> well every gui-lib suits me. i'm not too much into fancy interfaces, but sometimes its quite nice to have some kind of gui
01:58:40 <Cale> I've been wanting something along the lines of what Conal's been working on for quite a while.
01:59:25 <Cale> GUI programs have the problem that it's not really easy to plug them together into something new.
01:59:43 <Cale> (like with unix pipeline programs)
02:00:17 <qweqwe> how i can write it ?
02:00:23 <qweqwe> (filter (x>0) xs)
02:00:31 <Cale> filter (>0) xs ?
02:00:40 <Cale> Or  filter (\x -> x > 0) xs ?
02:00:47 <qweqwe> thanks
02:01:03 <Cale> Or even,   [x | x <- xs, x > 0]
02:01:20 <qweqwe> i am playing with filter
02:01:40 <xpika> > filter (x>5) [1..10]
02:01:42 <lambdabot>   Not in scope: `x'
02:01:42 <Cale> Good thing to learn early :)
02:01:51 <Cale> > filter (>5) [1..10]
02:01:53 <xpika> > filter (\x-> >5) [1..10]
02:01:53 <lambdabot>  [6,7,8,9,10]
02:01:53 <lambdabot>  Parse error at ">5)" (column 14)
02:02:12 <Cale> > filter (\x -> x > 5) [1..10]
02:02:13 <lambdabot>  [6,7,8,9,10]
02:02:52 <Cale> The first parameter to filter is always a function which takes an element of your list and decides whether it should be kept (giving a Bool response)
02:02:59 <profmakx> monadic guis!
02:03:08 <qweqwe> i ahve errror there
02:03:13 <Cale> profmakx: Or applicative ones!
02:03:27 <qweqwe> ERROR file:{Hugs}\packages\hugsbase\Hugs.hs:2 - Cannot justify constraints in explicitly typed binding
02:03:27 <qweqwe> *** Expression    : squarePos
02:03:27 <qweqwe> *** Type          : Num a => [a] -> [a]
02:03:27 <qweqwe> *** Given context : Num a
02:03:27 <qweqwe> *** Constraints   : Ord a
02:03:46 <qweqwe> squarePos::Num a =>[a]->[a]
02:03:46 <qweqwe> squarePos xs =map (\x->x*x) (filter (\x->(x>0)) xs)
02:04:07 <Cale> qweqwe: It's not possible to know that > is meaningful for all kinds of numbers.
02:04:29 <qweqwe> ah yes
02:04:32 <qweqwe> thanks
02:04:32 <Cale> qweqwe: So your type signature should be:  squarePos :: (Num a, Ord a) => [a] -> [a]
02:06:46 <czakey> heh
02:07:01 <czakey> that -> http://haskell.org/gtk2hs/download/
02:07:05 <czakey> says:
02:07:36 <czakey> this ver. of gtk2hs req. GHC v. 6.6.1 or 6.8.1
02:07:51 <czakey> you have 6.8.2
02:07:55 <czakey> sorry winnetou ;)
02:08:04 <czakey> damn ;d
02:08:16 <Cale> oy, that's annoying
02:08:21 <czakey> yep
02:08:32 <czakey> shoud I downgrade?
02:08:39 <czakey> or better do it another way?
02:08:40 <Cale> dcoutts: are you still the primary maintainer for Gtk2Hs?
02:10:03 <Cale> http://haskell.org/gtk2hs/archives/2005/06/24/building-from-source-on-windows/ -- there's always building from source, but it involves mingw
02:10:04 <lambdabot> http://tinyurl.com/yhuln8
02:10:26 <czakey> i have mingw
02:10:51 <czakey> but I dont know if I have haskell libs in it... hmm thats no problem
02:10:54 <czakey> lets try
02:12:39 <Cale> If all else fails, complain on the Haskell-cafe mailing list, and someone will do something about it, hopefully. :)
02:12:53 <Cale> 6.8.2 came out a bit unusually fast after 6.8.1
02:15:26 <czakey> yep
02:15:31 <czakey> fracking windows
02:15:43 <czakey> doesnt understand ./configure
02:16:09 <czakey> coz "configure" isnt some .exe or w/e win-exec
02:16:27 <czakey> I glad to have some unix...
02:16:38 <czakey> but still i have to do it on win
02:16:39 <czakey> blach
02:16:42 <Cale> I wonder how long it's been since I last ran windows on my machine...
02:17:18 <Cale> 7 years or so now.
02:20:09 <profmakx> hm i have a notebook with windows xp... last time i booted was last year when i wanted to play some win-only game
02:22:53 <czakey> my laptop is
02:22:54 <czakey> hmm
02:23:08 <czakey> i dont know how to say it in english
02:23:11 <czakey> buisness?
02:23:15 <czakey> staff?
02:23:18 <Cale> ah
02:23:28 <Cale> Owned by the company you work for?
02:23:34 <czakey> yes
02:23:49 <qweqwe> i have error and no idea how solve it
02:23:54 <qweqwe> for map (\f -> f.f) [(\x -> x+1),(\x -> x+2)] 5
02:23:54 <Cale> profmakx: Yeah, I've been playing windows-only games in wine. Wine is getting really impressive these days.
02:24:08 <qweqwe> i get ERROR - Type error in application
02:24:08 <qweqwe> *** Expression     : map (\f -> f . f) [\x -> x + 1,\x -> x + 2] 5
02:24:08 <qweqwe> *** Term           : map
02:24:08 <qweqwe> *** Type           : (e -> f) -> [e] -> [f]
02:24:08 <qweqwe> *** Does not match : a -> b -> c -> d
02:24:14 <Cale> qweqwe: well, remove that 5
02:24:17 <czakey> I'm IT chef
02:24:18 <czakey> but
02:24:39 <czakey> there are some problems with Windows workstations in my company
02:24:46 <Cale> qweqwe: map (\f -> f . f) [\x -> x + 1,\x -> x + 2] is a list of functions
02:24:51 <czakey> so I must have some computer to test
02:24:52 <profmakx> qweqwe should read up on type signatures and syntax of haskell
02:25:03 <czakey> and - it unfortunaly cant be dual-boot
02:25:14 <czakey> because of hard-drive encryption
02:25:15 <Cale> qweqwe: If you want to apply each of the functions to 5, you can write:  map ($ 5) (...)
02:25:48 <Cale> czakey: that's unfortunate, yeah
02:26:30 <czakey> You know, I'm happy
02:26:44 <czakey> that my company (financial)
02:27:04 <czakey> if very open to open-source
02:27:22 <qweqwe> and what about type of it ?
02:27:30 <czakey> so - we must have Windows workstations
02:27:32 <qweqwe> mapit::Num a=>a->[a]
02:27:33 <qweqwe> mapit x =map (\f -> f.f) [(\x -> x+1),(\x -> x+2)]
02:27:52 <czakey> but all servers is on linux
02:27:52 <qweqwe> i get error on that type
02:27:54 <Cale> qweqwe: um, what's the extra x parameter for?
02:28:05 <profmakx> i forgot a you there. i didnt want to be insulting.
02:28:09 <Cale> It should be:
02:28:22 <Cale> mapit :: Num a => [a -> a]
02:28:25 <czakey> on windows we have pretty-much opensource software
02:28:27 <czakey> and now
02:28:30 <Cale> mapit = map (\f -> f.f) [(\x -> x+1),(\x -> x+2)]
02:28:49 <czakey> I want do do some programs for company in Haskell :p
02:28:59 <Cale> Cool :)
02:29:29 <qweqwe> Cale: why [a->a] i get one argument and return [a]
02:29:45 <profmakx> i did all scripting for my thesis in haskell. its totally refreshing ;)
02:29:58 <Cale> qweqwe: Well,  (\f -> f . f) :: (a -> a) -> (a -> a), right?
02:30:05 <czakey> ok
02:30:17 <czakey> any ideas how to run configure on windows?
02:30:18 <czakey> :D
02:30:19 <qweqwe> yes
02:30:26 <profmakx> although i would really like to implement the whole toolset myself in haskell... i will have to look up some KnuthBendix stuff for that. but now i first have to get the thesis out of the door
02:30:45 <Cale> czakey: from the MSYS shell?
02:31:05 <Cale> qweqwe: So map applied to that function will have what type?
02:31:08 <czakey> ahh
02:31:19 <Cale> remember that  map :: (a -> b) -> ([a] -> [b])
02:31:21 <czakey> yep
02:31:37 <czakey> ive tried to fire it from standard cmd
02:31:52 <qweqwe> as i know map is (a->a)->[a]->[a]
02:31:55 <czakey> and im thinking "why its not working"
02:31:59 <czakey> stupid me ;)
02:33:09 <Cale> qweqwe: well, here given that you've passed map a function of type (c -> c) -> (c -> c), we have that a = (c -> c), and b = (c -> c) in the type of map
02:33:10 <dubblego> is this the same qweqwe from reddit learning Haskell?
02:33:52 <Cale> There's a qweqwe on reddit?
02:33:56 <qweqwe> what is it reddit ?
02:34:11 <dubblego> oh wait, I'm thinking qwe1234 I think
02:34:38 <Cale> qweqwe: It's a link/news aggregation site.
02:36:18 <Cale> qweqwe: There's a troll who posts there using the username qwe1234. Based on his comments, it would be quite surprising if you were him. :)
02:36:36 <dubblego> indeed :)
02:37:12 <qweqwe> but what news ppl post there ?
02:37:27 <dubblego> it used to be programming related, but it's not very good anymore
02:37:38 <Cale> Well, on programming reddit, mostly news about programming. At least, that's the idea.
02:38:26 <qweqwe> you have any idea where i can find good advansed articles on c++
02:38:32 <Cale> Unfortunately, there are now enough people on reddit who don't actually know what "programming" is meant to refer to, and post all kinds of junk.
02:39:10 <desegnis> The current face of reddit.com looks indeed like a spammed mail box :)
02:40:15 <desegnis> which doesn't concern me too much since I never got the hang of those social Â»but the content is elsewhere on the webÂ« sites
02:41:53 <desegnis> On the other hand, associating URLs with fora discussions isn't too bad an idea; it frees webmasters from providing commenting facilities
02:47:07 <dons> ?users
02:47:07 <lambdabot> Maximum users seen in #haskell: 444, currently: 416 (93.7%), active: 9 (2.2%)
02:51:03 <czakey> c2hsLocal.exe: glib-object.h: File does not exist
02:51:03 <czakey> make[2]: *** [glib/glib.precomp] Error 1
02:51:03 <czakey> make[2]: Leaving directory `/home/czakey/gtk2hs-0.9.12.1'
02:51:03 <czakey> make[1]: *** [glib/System/Glib/Types.hs] Error 2
02:51:05 <czakey> make[1]: Leaving directory `/home/czakey/gtk2hs-0.9.12.1'
02:51:09 <czakey> damn
02:51:16 <czakey> today
02:51:27 <czakey> computers doesn't like me ;]
03:01:32 <bgold> hey, i'm writing an interactive lisp evaluator which needs to hold state across user input, and was using a StateT to do that, but realized it was lame since the evaluator core shouldnt really know or care about IO. can anyone help me with ST? or are there any better ideas?
03:04:11 <Cale> bgold: So the lisp evaluator is evaluating just pure lisp expressions?
03:04:28 <qweqwe> i still little bit confuzed with the map (\f -> f.f) [(\x -> x+1),(\x -> x+2)] map is the type of (c->b)->[c]->[b] (.) here is of type (a->a)->(a->a) so why the final type is not [a->a]->[a->a]
03:04:49 <bgold> cale: right, the evaluator should just be evaluating lisp expressions in terms of an environment
03:04:51 <qweqwe> and it only of type [a->a]
03:05:03 <Cale> qweqwe: well, that's the type of map (\f -> f . f)
03:05:11 <Cale> qweqwe: then you apply it to the list of functions
03:05:17 <bgold> cale: main has a repl loop which parses then evaluates
03:05:45 <bgold> cale: but if a user types something like (define x 5), and then the repl loop outputs it, the next input passed to the evaluator should have x:5 in the env
03:05:59 <Cale> well, that's fine of course :)
03:06:12 <mauke> bgold: what if someone types (print 4)?
03:06:17 <qweqwe> ah so you mean i have [a->a]-
03:06:18 <Cale> What I would recommend to start off with is just manually managing that state.
03:06:20 <bgold> cale: i originally solved this buy making the monad in the evaluator be a StateT with IO, but really thats kind of hackish because the evaluator shouldnt care about IO
03:06:29 <bgold> mauke: the print command is not implemented
03:06:38 <mauke> or (loop (print (eval (read))))
03:06:38 <Cale> bgold: So why not just the plain State monad?
03:06:40 <bgold> the result of all the statements is returned in a list and printed
03:07:04 <qweqwe> ah so you mean i have [a->a]->[a->a]  than i apply it on [(\x -> x+1),(\x -> x+2)] and get [a->a]
03:07:09 <Cale> qweqwe: right
03:07:19 <qweqwe> ok finnaly i got it
03:07:22 <Cale> :)
03:08:30 <Cale> bgold: You could also just handle the environments in a pure way.
03:08:36 <bgold> cale: i guess i'm just not sure how the environment can span across IO input without using StateT to encapsulate IO
03:08:51 <bgold> cale: what do you mean in a pure way?
03:08:55 <Cale> bgold: make the evaluator take an environment as a parameter, and return a (possibly modified) environment along with its result
03:09:24 <Cale> Then from IO, your recursive loop will maintain that environment in a parameter
03:09:35 <Cale> But the evaluator will just be a pure function.
03:10:13 <bgold> cale: but then wouldnt the evaluator need to pass the environment between all of the functions that use it?
03:10:16 <bgold> cale: wont that get messy?
03:10:31 <mauke> yes
03:10:40 <mauke> State can hide that
03:10:59 <Cale> loop env = do input <- getLine; let {(env', result) = eval env input}; print result; loop env'
03:11:34 <Cale> But yeah, that evaluator might be written using the plain State monad, which is just a simple way to wrap up passing that parameter around as it changes.
03:11:52 <bgold> ahh, makes sense
03:11:56 <bgold> dunno why i didnt think about that before
03:11:57 <bgold> thanks :)
03:11:58 <Cale> But I think it's worthwhile just to write it without fancy monads first, so you get an idea of what they abstract away.
03:12:24 <Cale> (not that the State monad is all that fancy, but still :)
03:12:41 <bgold> well, that's kind o what happened
03:12:49 <bgold> originally i was threading env around between all of the functions, but that was lame
03:12:56 <bgold> then i started using StateT, but that was also lame
03:12:59 <czakey> meh
03:13:01 <czakey> still
03:13:02 <czakey> c2hsLocal.exe: glib-object.h: File does not exist
03:13:14 <bgold> but yeah, State sounds like a good idea, thanks
03:13:31 <czakey> after
03:13:37 <czakey> make[2]: Entering directory `/home/czakey/gtk2hs-0.9.12.1'
03:13:37 <czakey> ./tools/c2hs/c2hsLocal.exe +RTS -M120m -RTS --cppopts='-include "gtk2hs-config.h"' --precomp=glib/glib.precomp glib-object.h
03:13:40 <Cale> czakey: Did I reply to you before, or just think it? :)
03:13:49 <czakey> just think
03:14:01 <czakey> or I'm kinda blind
03:14:27 <Cale> czakey: You should check your Gtk+ install. The notes at (http://www.haskell.org/gtk2hs/archives/2005/06/24/building-from-source-on-windows/) say that it must be in a directory which has no spaces in it.
03:14:30 <lambdabot> Title: Gtk2Hs » Blog Archive » Building from source on Windows, http://tinyurl.com/2z825w
03:14:41 <czakey> Cale: yep
03:14:50 <czakey> but I'm sure that gtk
03:14:57 <czakey> is under c:\gtk
03:15:14 <Cale> okay, and you just installed it using the package from gladewin32.sourceforge.net ?
03:15:22 <czakey> ive reinstalled it just for sure
03:15:26 <Cale> okay
03:15:26 <czakey> yes
03:15:40 <Cale> You might have a look around your system for where the header files are.
03:15:48 <czakey> maby I have to check variables
03:16:07 <Cale> Oh, when you install it it asks whether you want to install Devel headers/libraries
03:16:25 <Cale> (and you also want the environment vars option)
03:16:33 <czakey> PKG_CONFIG_PATH=/C/GTK/2.0/lib/pkgconfig
03:16:38 <czakey> looks good
03:16:43 <czakey> am I right?
03:16:58 <Cale> I'm afraid I can't really follow along, since I don't have a windows machine handy.
03:17:08 <czakey> PATH='/C/GTK/2.0/bin: [...]
03:17:10 <Cale> But yeah, that doesn't look bad :)
03:17:58 <Cale> Is there a directory somewhere under /C/GTK which has a whole bunch of header files in it?
03:18:33 <Cale> (probably called include)
03:19:01 <Cale> The install is complaining about one of those being missing.
03:19:05 <roconnor> yesterday Doaitse Swierstra show us how to write a on-line breath-first parser.
03:19:23 <roconnor> it was quite cool
03:19:28 <czakey> yep
03:19:37 <czakey> C:\GTK\2.0\include
03:19:41 <czakey> has plenty of it
03:19:42 * Cale always takes a deep breath before parsing ;)
03:20:17 <Cale> czakey: Out of interest, glib-object.h really isn't there?
03:20:22 <Saizan> roconnor: on-line?
03:20:28 <Cale> czakey: I really don't know, to be honest.
03:20:38 <roconnor> the technique seems like it would work for many breath first searching problems
03:20:52 <czakey> ha
03:21:01 <czakey> it's in C:\GTK\2.0\include\glib-2.0
03:21:03 <roconnor> Saizan: that you can lazilly get some partal parsing results before parsing is complete.
03:21:09 <Cale> czakey: hmmm...
03:21:14 <czakey> not include/ itself
03:21:24 <czakey> maby thats the problem
03:21:25 <Cale> czakey: perhaps the chs file can be updated
03:21:44 <czakey> e
03:21:50 <roconnor> Saizan: this required restricting the parsing problem to those things that have one unique parse.
03:22:03 <czakey> i simply copied glib-object.h to ../
03:22:03 <czakey> ;p
03:22:19 <Cale> czakey: well, that might work too :)
03:22:35 <czakey> ...but that doesn't help
03:22:44 <roconnor> Saizan: that is that the big tree of parsing only one leaf is labeled sucess
03:22:47 <Cale> does the error change at least?
03:22:49 <czakey> I wonder where it looks for it
03:23:12 <roconnor> Saizan: although you can set it up so that the right most sucesses is the one returned.
03:23:14 <czakey> nothing changed
03:23:24 <roconnor> but you won't get a list of sucesses.
03:23:30 <czakey> make[2]: Entering directory `/home/czakey/gtk2hs-0.9.12.1'
03:23:30 <czakey> ./tools/c2hs/c2hsLocal.exe +RTS -M120m -RTS --cppopts='-include "gtk2hs-config.h"' --precomp=glib/glib.precomp glib-object.h
03:23:30 <czakey> c2hsLocal.exe: glib-object.h: File does not exist
03:23:33 <czakey> hmm
03:23:48 <czakey> maby its looking for it in /home/czakey/gtk2hs-0.9.12.1
03:23:51 <Cale> hmm indeed
03:24:08 <czakey> but that would be kinda strange
03:24:10 <Cale> which would be really stupid, but seems like it might be the case
03:24:31 <czakey> wow
03:24:36 <czakey> now it works
03:24:42 <czakey> but of course
03:25:05 <czakey> I have now hungred other errors about .h files
03:25:08 <czakey> :d
03:25:30 <Cale> --includedir=DIR
03:25:44 <czakey> mhm
03:25:44 <Cale> is an option to configure, at least the linux version
03:25:54 <Cale> Maybe setting that will help?
03:25:56 <czakey> thats the same version
03:26:02 <czakey> I'll try
03:26:09 <Cale> oh, right :)
03:26:47 <Cale> I wish dcoutts were here :)
03:26:51 <Saizan> roconnor: ah, interesting, do you know if there are any online descriptions/papers on this?
03:27:05 <Cale> Or one of the other Gtk2Hs developers :)
03:27:27 <roconnor> Saizan: It was unclear to me if this on-line part was presented at ICFP or was very recent.
03:27:28 <Cale> I should probably go to bed
03:27:55 <roconnor> Saizan: but I got the impression that at least the breath first stuff was presented at ICFP
03:27:59 <roconnor> but I haven't checked.
03:29:10 <roconnor> is there a list of ICFP papers?
03:30:24 <roconnor> hmm, maybe I should just go to the author's page
03:31:17 <czakey> Cale: so goodnight (?)
03:31:32 <czakey> for me is 1 pm ;)
03:31:56 <czakey> that --includedir doesn't help ;/
03:32:29 <czakey> exacly same errors about missing header files
03:32:47 <czakey> as they say: shit happens
03:32:48 <czakey> ;]
03:33:53 <roconnor> Saizan: I can't find anything.  How frusterating.
03:36:52 <Saizan> roconnor: yeah, his page doesn't list any paper for 2007
03:40:33 <roconnor> :/
03:40:53 <roconnor> I more or less remember how the breath first thing worked
03:41:00 <roconnor> but the on-line was more complicated
04:05:38 <dcoutts_> czakey: any luck building from source in then end?
04:05:52 <czakey> nope
04:06:04 <dcoutts_> czakey: I'm planning to do a build for ghc-6.8.2 soon
04:06:21 <czakey> got stuck on looking for other header files
04:06:37 <czakey> even copying them to locations won't work
04:06:39 <czakey> ;>
04:06:52 <czakey> thats good news :)
04:06:53 <dcoutts_> I use these gtk+ sdks: http://haskell.org/gtk2hs/win32/
04:07:06 <dcoutts_> rather than the ones from gladewin32.sf.net
04:07:34 <dcoutts_> and the scripts from http://darcs.haskell.org/gtk2hs/tools/win32/
04:07:35 <lambdabot> Title: Index of /gtk2hs/tools/win32
04:07:51 <czakey> hm
04:08:02 <czakey> I can wait
04:08:06 <czakey> I'm lazy :P
04:08:17 <czakey> for real
04:08:46 <czakey> I'm trying to learn Haskell itself
04:09:06 <czakey> (now trying to write list permutation)
04:09:35 <czakey> but converting from imperative to functional programing isn't easy
04:09:37 <czakey> ;>
04:10:31 <czakey> I want gtk2hs because I like effects from the begining :P
04:11:14 <dcoutts_> czakey: well, learn more of the basics and by that time there'll be a new gtk2hs installer for windows
04:11:48 <czakey> that what I'll do :)
04:12:00 <czakey> thanks for your work
05:00:47 <shag> is it possible to have a polymorphic type inside a data declaration, like in this example? http://hpaste.org/4947
05:01:18 <mauke> not in Haskell98
05:01:52 <mauke> data Foo = forall f. (FooClass f) => Foo { barfoo :: f } should work with ghc extensions
05:02:06 <litb> ok, but why is it called "order" ?
05:02:26 <litb> if we say "it's a high order function"
05:02:44 <shag> mauke: thanks
05:04:19 <EvilTerran> shag, mauke: isn't "data Foo = Foo { barfoo :: forall f. (FooClass f) => f }" more useful here?
05:04:39 <shag> hm, looks like
05:04:47 <mauke> I don't know
05:04:53 <shag> i don't know much about this foralll thing, yet.
05:07:21 <litb> what does that forall thing mean anyway?
05:07:48 <litb> it's only showed here in #haskell if i do @type . but in ghc if i do :t i don't see it
05:07:56 <mauke> it introduces type variables
05:08:09 <mauke> it's usually implicit
05:09:47 <EvilTerran> it's not Haskell'98
05:12:06 <EvilTerran> as mauke says, it introduces type variables; it means that something can be polymorphic in a way that isn't visible from the outside
05:12:07 <EvilTerran> as it were
05:12:33 <EvilTerran> and other such funny stuff
05:15:09 <EvilTerran> ?type let f g = (g 'A', g True) in f fromEnum
05:15:10 <lambdabot>     Couldn't match expected type `Bool' against inferred type `Char'
05:15:10 <lambdabot>       Expected type: Bool -> t
05:15:10 <lambdabot>       Inferred type: Char -> t1
05:15:15 <EvilTerran> ?type let f :: (forall a. Enum a => a -> Int) -> (Int,Int); f g = (g 'A', g True) in f fromEnum
05:15:16 <lambdabot> (Int, Int)
05:16:51 <roconnor> > parition odd [0..]
05:16:52 <lambdabot>   Not in scope: `parition'
05:16:57 <roconnor> > partition odd [0..]
05:16:58 <lambdabot>  ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
05:17:02 <roconnor> > partition odd [0..10]
05:17:02 <lambdabot>  ([1,3,5,7,9],[0,2,4,6,8,10])
05:17:15 <EvilTerran> ?type fromEnum
05:17:16 <lambdabot> forall a. (Enum a) => a -> Int
05:17:47 <EvilTerran> in the first case, there, f :: forall a. Enum a => ((a -> Int) -> (Int, Int))
05:18:00 <EvilTerran> rather than f :: (forall a. Enum a => (a -> Int)) -> (Int, Int)
05:18:49 <EvilTerran> this means that, in the first case, f has to work for any a that's Enum
05:19:02 <EvilTerran> but once an a has been chosen, its first parameter only has to work for that one a
05:19:21 <EvilTerran> OTOH, in the other one, the first paramater has to work for all such a
05:21:19 <mauke> stacks are hard :/
05:25:52 <Saizan> ?src IO mfix
05:25:52 <lambdabot> mfix = fixIO
05:25:59 <Saizan> ?src fixIO
05:25:59 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
05:26:04 <Saizan> ?index fixIO
05:26:05 <lambdabot> System.IO
05:32:32 <fbuilesv> Hello, as part of a learning exercise I'm trying to build a Markdown to HTML converter tool. Would you suggest to try and using Parsec/UUlib or should I just go straight for regular expression parsing?
05:34:10 <Saizan> regexps are usually considered evil here :)
05:34:53 <EvilTerran> if you're parsing in haskell, you almost certainly want to use either Parsec or Happy
05:34:57 <yondalf> you might want to take a look at pandoc
05:35:36 <Saizan> ?report
05:35:36 <lambdabot> ()
05:35:39 <Saizan> ?where report
05:35:40 <lambdabot> http://www.haskell.org/onlinereport/
05:36:52 <EvilTerran> ?list report
05:36:52 <lambdabot> No module "report" loaded
05:36:57 <EvilTerran> hmm
05:37:18 <fbuilesv> yondalf: Checking the source right now, that's what motivated me to write my own as a learning experience :-)
05:38:30 <yondalf> fbuilesv: okay :-) my experiences with haskell is limited to customising xmonad, though, so don't take me seriously
05:39:27 <Jomyoot> does HSQL support UTF8?
05:39:41 <Jomyoot> I am getting return of ???? for UTF8 characters
05:40:25 <Saizan> Jomyoot: you probably need to encode/decode the String yourself
05:41:50 <Jomyoot> Saizan: can you give me ppointers please?
05:43:43 <Saizan> Jomyoot: you can find the codec functions in utf8-string on hackage
06:07:53 <Saizan> is it safe in a cabal file to assume !os(windows) => unix?
06:08:34 <ndm> Saizan: mac == unix ?
06:08:56 <ndm> probably is safe, if mac is sufficiently unix for your needs
06:09:07 <Saizan> ndm: is the unix package compiled on unix?
06:09:13 <dcoutts_> Saizan: for most purposes, yes
06:09:25 <dcoutts_> Saizan: unix package is available on macos
06:11:28 <Saizan> ok, thanks
06:15:57 <Saizan> hah, funny how earlier cabals just ignore 'Cabal-Version: >= 1.2' (but it's an hint for the user i suppose)
06:16:37 <twanvl> why not just test if the unix package is available?
06:19:30 <Saizan> twanvl: since unix is in the boot libraries that's probably safe, but if you're on UNIX without that package i'd like an error rather than compiling as on windows
06:42:29 <byorgey> hi keseldude
06:42:43 <byorgey> oops, wrong channel =)
06:44:07 <Jomyoot> The utf8-string converts UTF8 to Word8 and not Char
06:45:06 <EvilTerran> Jomyoot, there'll be one for [Char] -> [Word8] and one for [Word8] -> [Char], i suspect
06:45:24 <EvilTerran> the first is encoding characters as bytes of UTF-8 codes, the second vice-versa
06:46:08 <EvilTerran> i believe there's functions for reading/writing [Word8]s somewhere
06:46:17 <EvilTerran> but, if not,
06:46:27 <EvilTerran> > toEnum.fromEnum :: Word8 -> Char
06:46:30 <lambdabot>  <Word8 -> Char>
06:50:05 <ndm> @seen dcoutts_
06:50:05 <lambdabot> dcoutts_ is in #gentoo-haskell, #ghc and #haskell. I last heard dcoutts_ speak 40m 39s ago.
06:50:26 <ndm> dcoutts_: its hard to see why Gtk2hs for Windows is not released within a few hours of GHC 6.8.2, and all stable GHC releases...
06:58:50 <Jomyoot> How to I convert result of getFieldValue :: SqlBind a => Statement -> String -> IO a into a String?
07:00:16 <ndm> Jomyoot: do you know how to get the a out of IO?
07:00:37 <Jomyoot> Nope
07:00:39 <ndm> its really two steps, getting the a out of the IO, and getting the String out of the SqlBind
07:00:51 <ndm> Jomyoot: read a tutorial on the IO monad, but the easiest answer is
07:01:05 <ndm> do x <- getFieldValue a b
07:01:08 <ndm>     print x
07:01:24 <ndm> i.e. use the do notation and the <- arrow to convert an IO to an "a"
07:01:32 <EvilTerran> "convert"
07:02:14 <ndm> EvilTerran: me suspects that words like "monadically bind" would not be appreciated right now :)
07:02:15 <litb> ok, just to be sure. return converts a "normal" type to a monad type .
07:02:18 * EvilTerran really quite likes http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html for a rough-and-ready monad intro
07:02:20 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care, http://tinyurl.com/yplmwx
07:02:20 <litb> or is it the other way around?
07:02:28 <EvilTerran> ?type return
07:02:30 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
07:02:37 <EvilTerran> had it right the first time :)
07:02:48 <ndm> litb: you are correct, although i'd say wraps a normal type in a monad type
07:03:00 <ndm> convert is a bad choice of word for going into and out of monads, as EvilTerran rightly points out :)
07:03:09 <litb> hm, that m a is not function application
07:03:18 <ndm> i love hte monads as containers article
07:03:21 <EvilTerran> litb, indeed not
07:03:24 <ndm> litb: its type application
07:03:34 <litb> hmm
07:03:59 <EvilTerran> litb, monads are parameterised types; given a monad m and a type a, the application of m to a, ie "m a" is a type
07:04:13 <litb> oh i see
07:04:16 <EvilTerran> so, say, "Maybe" is a monad, but "Maybe Int" is a type
07:04:28 <EvilTerran> [] is a monad; [] a (ie [a]) is a type
07:05:00 <litb> so, IO Int wraps an Int into a IO . and a <- return 10; would first wrap the 10, then unwrap it again into a
07:05:18 <EvilTerran> yeah
07:05:57 <EvilTerran> although I tend to think of "x <- foo" as getting inside the bundle that foo is wrapped in
07:06:18 <EvilTerran> rather than taking foo out of the bundle. but that's just me. :D
07:06:26 <litb> so that x "visits" the bundles content?
07:07:06 <Jomyoot> I am lost
07:07:17 <litb> ah i understand a key principle of monads now i think
07:07:25 <Jomyoot> i hoipe this is worth it
07:07:32 <Jomyoot> in terms of practical programming usage
07:08:02 <litb> ?type (>>)
07:08:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
07:08:04 <roconnor> @src interact
07:08:05 <lambdabot> interact f = do s <- getContents; putStr (f s)
07:08:23 <roconnor> ah, lazy getContents
07:08:25 <roconnor> :/
07:09:04 <ndm> Jomyoot: it takes a while to get to grips with, but once you do, its incredibly powerful
07:09:24 <litb> one silly question left
07:09:45 <litb> what does that "forall (m :: * -> *) a b." mean? in particular the * -> * part
07:09:58 <opqdonut> m has to be of kind * -> *
07:10:06 <ndm> litb: its not Haskell, its a GHC extension, to indicate the m is a higher kinded type
07:10:07 <opqdonut> which basically means it takes a type and gives a type
07:10:16 <opqdonut> that is, is a one-argument type constructor
07:10:18 <ndm> in Haskell, you can drop the bit between forall and .
07:10:19 <opqdonut> :k Maybe
07:10:20 <lambdabot> * -> *
07:10:21 <opqdonut> :k Maybe Int
07:10:21 <lambdabot> *
07:10:24 <opqdonut> :k Either
07:10:25 <lambdabot> * -> * -> *
07:10:26 <opqdonut> :k Either String
07:10:27 <lambdabot> * -> *
07:10:31 <opqdonut> :k ST
07:10:31 <lambdabot> Not in scope: type constructor or class `ST'
07:10:45 <opqdonut> :k StateT
07:10:45 <lambdabot> * -> (* -> *) -> * -> *
07:10:47 <EvilTerran> :k State
07:10:47 <lambdabot> * -> * -> *
07:10:49 <opqdonut> :)
07:10:58 <litb> :k map
07:10:59 <EvilTerran> :k StateT Int Maybe
07:10:59 <lambdabot> Not in scope: type variable `map'
07:10:59 <lambdabot> * -> *
07:11:11 <litb> ah i understand
07:11:15 <EvilTerran> litb, kinds are like types for types
07:11:20 <litb> :k Ordering
07:11:20 <lambdabot> *
07:11:38 <EvilTerran> values can only have types of kind *
07:11:44 <opqdonut> :k []
07:11:45 <lambdabot> * -> *
07:11:49 <EvilTerran> those're "types proper"
07:12:18 <EvilTerran> sadly the word "type" is a bit abused, here
07:12:19 <byorgey> keseldude: you can use shift-mod-j/k to reorder windows
07:12:34 <byorgey> gah, wrong channel again =P
07:12:42 <EvilTerran> ...
07:12:45 <byorgey> still getting used to this irssi thing...
07:12:57 <EvilTerran> icy
07:13:28 <mauke> byorgey: do you have multiple channels per tab?
07:14:04 <byorgey> mauke: no
07:14:37 <mauke> then how can you reply in the wrong channel? :-)
07:15:24 <byorgey> mauke: I have multiple channels in split windows, all within one terminal, so there's only one input line for all of them, as opposed to having a separate window for each channel...
07:15:34 <mauke> ah
07:15:42 <byorgey> so I have to pay attention to which channel is highlighted
07:16:23 <byorgey> I dunno, I was using xchat before, but I kept hearing people disparage such things and say how great irssi was, so I figured I have to at least try it for a week and see if I like it.
07:16:33 <litb> i'm using irssi
07:16:41 <mauke> me too, but I don't use split windows
07:16:49 <litb> i don't use them too
07:16:53 <litb> but i use the nicklist
07:16:53 <ndm> i'm using Opera, the one thing that sucks is that you can't get notifications when someone says your name :(
07:17:19 <byorgey> mauke: what do you do?  just flip around between channels using alt-#?
07:17:21 <Jomyoot> what is a reverse of return
07:17:28 <mauke> byorgey: alt-a mostly
07:17:32 <litb> Jomyoot: i think (<-)
07:18:01 <litb> ?type (<-)
07:18:01 <lambdabot> parse error on input `<-'
07:18:02 <byorgey> Jomyoot: it's different for each monad.  some don't even have such a function.
07:18:04 <litb> hmm
07:18:10 <byorgey> Jomyoot: return has type a -> m a
07:18:10 <mauke> litb: <- is not an operator
07:18:12 <ndm> there is no reverse of return
07:18:15 <litb> darn
07:18:24 <byorgey> Jomyoot: so its reverse would have type m a -> a
07:18:25 <mauke> it's syntactic sugar for >>=
07:18:34 <mauke> :t (>>=)
07:18:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:18:39 * shachaf has too many channels for alt-a unless somebody sends him a message.
07:18:48 <merus> Isn't coreturn the reverse of return?
07:18:50 <byorgey> Jomyoot: that exists for certain monads, such as State, but not others, such as IO
07:18:51 <mauke> so >>= lets you get at the 'a' but only if you return an m b
07:18:58 <shachaf> You can only "temporarily" do the reverse -- you have to re-wrap afterwards.
07:19:39 <shachaf> Or, you can only do the reverse if you have more than one layer of monad.
07:19:39 <Jomyoot> even after decodeString the UTF8 still prints as ?????
07:19:55 <litb> ?src (>>=)
07:19:56 <lambdabot> Source not found. :(
07:20:04 <litb> silly :)
07:20:05 <shachaf> litb: Different for each monad.
07:20:08 <mauke> litb: it's a method
07:20:09 <shachaf> @src [] (>>=)
07:20:09 <lambdabot> m >>= k     = foldr ((++) . k) [] m
07:20:12 <litb> oh right
07:20:16 <shachaf> @src Maybe (>>=)
07:20:16 <EvilTerran> Jomyoot, does your output system support unicode?
07:20:17 <lambdabot> (Just x) >>= k      = k x
07:20:18 <lambdabot> Nothing  >>= _      = Nothing
07:20:38 <ndm> why is src [] (>>=) not concatMap?
07:20:49 <litb> i wondered about that too o.O
07:20:49 <EvilTerran> wouldn't it be flip concatMap?
07:20:58 <shachaf> ndm: flip concatMap, if anything.
07:20:59 <mauke> because lambdabot hates you
07:21:01 <ndm> yes
07:21:02 <EvilTerran> there's probably a performance reason, anyway
07:21:04 <EvilTerran> much like
07:21:06 <EvilTerran> @src foldr
07:21:08 <ndm> EvilTerran: no, there isn't
07:21:10 <lambdabot> foldr k z xs = go xs
07:21:10 <lambdabot>     where go []     = z
07:21:10 <lambdabot>           go (y:ys) = y `k` go ys
07:21:12 <mauke> @src concatMap
07:21:12 <lambdabot> concatMap f = foldr ((++) . f) []
07:21:19 <mauke> see? exactly the same thing
07:21:20 <EvilTerran> it might be an out-of-date performance reason
07:21:31 <ndm> EvilTerran: any GHC worth its salt would end up with the same result
07:21:32 <shachaf> lambdabot's @src is just weird.
07:21:34 <ndm> quite possibly
07:21:37 <EvilTerran> the @src database is a bit arbitrary, anyway
07:21:42 <Jomyoot> anyone knows how to use HSQL with UTF8?
07:21:46 <shachaf> @src foldr
07:21:47 <lambdabot> foldr k z xs = go xs
07:21:47 <lambdabot>     where go []     = z
07:21:47 <lambdabot>           go (y:ys) = y `k` go ys
07:22:16 <ndm> i know the reasons foldr is written like that - so its not recursive
07:22:49 <IvdSangen> go is till recursive
07:22:52 <ndm> that is a performance hack, but one that GHC _really_ needs
07:22:52 <IvdSangen> *still
07:23:04 <shachaf> ndm: No reason to have it in @src, though.
07:23:07 <ndm> IvdSangen: yes, but it means GHC can inline the foldr, which means head can be written in terms of foldr
07:23:11 <ndm> shachaf: true
07:23:14 <shachaf> In other places they have Prelude implementations.
07:23:23 <EvilTerran> -@src should use the report implementations, i'd think
07:23:32 <EvilTerran> seeing as those're chosen for clarity rather than performance
07:24:05 <IvdSangen> ndm: can you explain this inlining of foldr?
07:24:44 <ndm> IvdSangen: GHC can inline any function which is not recursive, and foldr as defined above is not recursive
07:25:05 <ndm> after the initial inlining, at some point, it will get lambda lifted, and you'll end up with a directly recursive function
07:25:22 <litb> hm, but go is
07:25:36 <ndm> litb: yes, but i can inline foldr, but not go - so it does one step of inlining
07:25:37 <EvilTerran> it's not that there isn't still recursion there, it's just that that recursion doesn't involve passing around k and z
07:25:51 <litb> ah
07:25:55 <EvilTerran> (i think)
07:26:28 <IvdSangen> that is an optimization that can be done automatically, right?
07:26:37 <litb> i usually don't think of speed when i'm coding functional aps
07:26:39 <litb> *apps
07:27:00 <litb> i mean apps in a functional language
07:27:01 <ndm> IvdSangen: no, not in this case
07:27:13 <TomMD> I code then hope ndm brings the speed I want.
07:27:15 <ndm> litb: you shouldn't, unless you find something is too slow
07:28:43 <pejo> TomMD, we're all hoping for that!
07:40:37 <installation> hi, I have a problem with installing hugs98. is this the right place for me to seek help?
07:41:22 <mauke> maybe
07:41:41 <mauke> what's the problem? :-)
07:41:53 <installation> the only thing I found by googleing was a log file from this chat :)
07:41:57 <ricky_clarkson> heh
07:42:18 <installation> well, Im using vista and I cant install hugs
07:43:23 <installation> a sec after the installation starts, there comes the following error message: Could not extract the file ...\hugs98.chm
07:43:40 <installation> ...\ = the directory :)
07:44:12 <mauke> hmm, upgrade to XP?
07:44:26 <installation> :D
07:48:10 <installation> so no known problem, huh?
07:48:39 <installation> wooops
07:48:41 <installation> lol
07:48:46 <shachaf> installation: No known solution, rather. :-)
07:48:56 <installation> now Im ashamed
07:49:09 <installation> didnt try to instal it as admin :D
07:49:22 <installation> works now
07:49:24 <installation> ha
07:49:28 <installation> thx anyway
07:49:36 <shachaf> installation: Is there a particular reason you're using Hugs, by the way?
07:49:36 <mauke> yay, now the logs contain a solution
07:49:57 <installation> shachaf: yes
07:50:16 <installation> shachaf: my universety wants me to use it :)
07:51:02 <mauke> what if you secretly use ghc instead?
07:51:25 <shachaf> SOLUTION: If you get an error extracting HUGS98.CHM under VISTA, make sure you install as an ADMINISTRATOR. Thanks to <installation> for this solution.
07:52:28 <EvilTerran> @yow
07:52:29 <lambdabot> Are you mentally here at Pizza Hut??
07:52:43 * shachaf wasn't thinking of @yow.
07:53:04 <installation> mauke: what would be the advance of using it? Im a haskell noob, and probably wont use it a lot, besides for the uni.
07:53:20 <mauke> I like ghci's error messages better
07:53:36 <mauke> and ghc is a full blown compiler, should you feel the need to produce exe's
07:53:47 <installation> I c
07:53:58 <shachaf> installation: And the REPL is nicer, I understand.
07:54:24 <mauke> oh yeah, ghci lets you use "let" interactively
07:55:09 <installation> well, Ill keep it in mind. but Ill start with hugs first, because I got an ebook about haskell which is also using hugs
07:55:58 <installation> after I mastered the language, I maybe try ghc ;)
07:56:32 <shachaf> installation: You'll probably want GHC well before mastering the language. :-)
08:00:51 <installation> maybe :)
08:00:57 <installation> time will tell
08:01:08 <installation> ok. thx for your help.
08:01:13 <installation> bye
08:10:15 <hpaste>  ramza3 pasted "With Put Monad, combine two operations" at http://hpaste.org/4948
08:10:56 <ramza3> In that code, how can I call one operation and then another (also with match the right pattern in the first case);
08:11:57 <ramza3> hmm, I wonder if I need a new operator (q>>=) :: Put a ->  (a -> Put b) -> Put b
08:13:09 <twanvl> Put is a monad, so you can do: putOneThing >> putAnotherThing
08:13:33 <twanvl> Or with do notation, do{ putOneThing; putAnotherThing }
08:14:30 <mauke> ramza3: your pattern match doesn't make sense
08:16:33 <ramza3> mauke: how so, data amqpstring = astr | bstr ...if astr then do this, if bstr, do that? return Put monad in both cases?
08:17:06 <mauke> what is AMQPString?
08:17:37 <ramza3> data AMQPString = [Word8] | [Word16]
08:17:51 <ramza3> oops, nevermind
08:18:18 <mauke> that's a syntax error
08:19:36 <roconnor> @go 1/2 lb in grams
08:19:36 <lambdabot> (1/2) pound = 226.796185 grams
08:24:02 <gwern> (bah. the programming language shootout is still at 6.6. fie!)
08:26:47 <Sizur> greetings to everybody
08:28:02 <gwern> Sizur: grettings fellow human
08:28:12 <Sizur> @users
08:28:13 <lambdabot> Maximum users seen in #haskell: 444, currently: 421 (94.8%), active: 8 (1.9%)
08:53:33 <nolrai> hey is there a function that gives the ajacent(sp?) elems in a list i.e. f [1,2,3,4] = [(1,2),(2,3),(3,4)]?
08:53:46 <Botje> yes!
08:54:14 <shachaf> > (\l -> zip l (tail l)) [1,2,3,4]
08:54:14 <lambdabot>  [(1,2),(2,3),(3,4)]
08:54:16 <Botje> unfortunately, its name is rather long
08:54:16 <Botje> its called pairs x = zip x $ tail x
08:54:39 <integral> @pl zip x $ tail x
08:54:39 <lambdabot> zip x (tail x)
08:54:50 <EvilTerran> zip `ap` tail
08:54:53 <integral> @pl \x -> zip x $ tail x
08:54:53 <lambdabot> ap zip tail
08:55:03 <phlpp> :>
08:55:07 <nolrai> thanks!
08:55:10 <shachaf> EvilTerran: Use (<*>) if it's already infix. :-)
08:55:10 <integral> oh, it's obvious when you think about it, isn't it? :-P
08:55:19 <EvilTerran> okok
08:55:19 * Botje still has trouble wrapping his head around ap :(
08:55:29 <EvilTerran> @src ap
08:55:29 <lambdabot> ap = liftM2 id
08:55:32 <EvilTerran> hm
08:55:34 <integral> it's just lifted $
08:55:59 <EvilTerran> ap mf mx = do f <- mf; x <- mx; return (f x)
08:56:01 <mauke> Botje: it's just the S combinator!
08:56:03 <shachaf> Botje: ap is S in (r ->).
08:56:19 <mauke> S f g x = f x (g x)
08:56:21 <shachaf> (Where S = \x y z -> x z (y z))
08:56:21 <integral> why is ap defined in terms of id nor $?
08:56:32 <shachaf> integral: Why not?
08:56:35 <shachaf> ($) = id
08:56:43 <Botje> *shrug* I'll have to look at the (r-> ) monad for a bit then
08:56:48 <EvilTerran> zip <*> tail = do zip_xs <- zip; tail_xs <- tail; return (zip_xs tail_xs)
08:56:48 <Botje> but first, paper writing time
08:56:52 <integral> I wouldn't say that ($) = id
08:57:00 <shachaf> Botje: It's just like Reader.
08:57:12 <integral> (because just saying ($) = id gives ($) the wrong type signature
08:57:34 <EvilTerran> well, it gives it a more general type signature
08:57:40 <integral> which is bad, yes.
08:57:40 <shachaf> Not really.
08:57:44 <shachaf> @ty liftM2 id
08:57:44 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
08:57:46 <shachaf> @ty liftM2 ($)
08:57:47 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m a -> m b
08:58:01 <shachaf> Oh, you mean ($).
08:58:02 <shachaf> Sorry.
08:58:03 <integral> shachaf: no, I mean saying ($) = id to Haskell gives ($) the wrong type signature
08:58:30 <shachaf> integral: Is that type signature "wrong"?
08:58:38 <shachaf> You can always specify the type yourself, anyway.
08:58:46 <shachaf> The implementation is (can be) id.
08:59:09 <EvilTerran> i'd tend to use ($) rather than id as ($) provides more detailed semantics
09:00:25 <shachaf> EvilTerran: Except in the case where using id can make a function more general.
09:00:31 <shachaf> (And more "useful".)
09:00:36 <EvilTerran> shachaf, well, yes
09:00:48 <shachaf> Which this isn't.
09:00:59 <EvilTerran> but it doesn't here, as the requirement that the parameter of id be a function is enforced by passing it to liftM2 anyway
09:01:08 <EvilTerran> it's like adding an explicit type signature for clarity
09:01:09 <shachaf> I agree that liftM2 ($) may be clearer, because it shows that you're lifting function application.
09:01:14 <EvilTerran> except nowhere near so much work
09:01:28 <integral> @type liftm id
09:01:29 <lambdabot> Not in scope: `liftm'
09:01:31 <integral> @type liftM id
09:01:32 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m a1
09:01:48 <shachaf> fmap id = id
09:01:53 <integral> @type id :: (Monad m) => m a -> ma
09:01:53 <lambdabot>     Couldn't match expected type `ma' (a rigid variable)
09:01:53 <lambdabot>            against inferred type `m a'
09:01:53 <lambdabot>       `ma' is bound by the polymorphic type
09:01:54 <integral> @type id :: (Monad m) => m a -> m a
09:01:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
09:03:34 <Sizur> :t ($)
09:03:34 <lambdabot> forall a b. (a -> b) -> a -> b
09:04:26 <nolrai> whats the haskell notation for base 2 log?
09:04:32 <EvilTerran> ?hoogle logBase
09:04:33 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
09:04:37 <mauke> @hoogle log
09:04:38 <lambdabot> Prelude.log :: Floating a => a -> a
09:04:38 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
09:04:38 <lambdabot> GHC.Conc.Logoff :: ConsoleEvent
09:04:42 <EvilTerran> > logBase 2 4
09:04:44 <lambdabot>  2.0
09:05:16 <Sizur> @src logBase
09:05:17 <lambdabot> Source not found. Do you think like you type?
09:05:35 <EvilTerran> i think it's a method
09:05:42 <Sizur> is it defined in terms of log?
09:05:57 <EvilTerran> logBase x b = log x / log b --iirc?
09:05:58 <Sizur> not that's important
09:06:00 <Sizur> yeah
09:06:40 <EvilTerran> @index log
09:06:41 <lambdabot> Prelude
09:10:10 <nolrai> how would i tell if an Integer is of the form (2 ^ (2 ^ n) n is an integer)?
09:10:42 <nolrai> would somthing like isWholeNum (logBase 2 $ logBase 2 x) work?
09:10:47 <EvilTerran> > map ((2^).(2^)) [0..]
09:10:52 <lambdabot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
09:11:06 <EvilTerran> see if it's an element of that?
09:11:22 <nolrai> yeah if it gets that big that fast
09:11:30 <nolrai> which it does
09:12:12 <Sizur> > ((2^).(2^)) <$> [0..]
09:12:12 <lambdabot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
09:12:31 <EvilTerran> incidentally, best do that by \x -> x == head (dropWhile (<x) $ map ((2^).(2^)) [0..])
09:12:35 <EvilTerran> rather then `elem`
09:12:53 <EvilTerran> takes advantage of the list being ordered, so it actually works ;)
09:13:51 <EvilTerran> > map (length.($"").showInt.(2^).(2^)) [0..]
09:13:57 <lambdabot> Terminated
09:14:01 <EvilTerran> bah
09:14:05 <Sizur> does it make sense to completely eliminate map from ones usage?
09:14:08 <EvilTerran> > take 10 $ map (length.($"").showInt.(2^).(2^)) [0..]
09:14:09 <lambdabot>  [1,1,2,3,5,10,20,39,78,155]
09:14:19 <EvilTerran> > take 30 $ map (length.($"").showInt.(2^).(2^)) [0..]
09:14:25 <lambdabot> Terminated
09:14:26 <EvilTerran> > take 20 $ map (length.($"").showInt.(2^).(2^)) [0..]
09:14:33 <lambdabot> Terminated
09:14:35 <EvilTerran> bah
09:14:38 <EvilTerran> Sizur, i wouldn't
09:15:15 <EvilTerran> Sizur, as I said above, if using a more general function wouldn't make the thing more general overall, i prefer to use a more specific function
09:15:30 <EvilTerran> cf using an explicit type annotation
09:15:41 <EvilTerran> makes things clearer, imo
09:15:46 <Sizur> but then you're less consistent
09:15:57 <EvilTerran> i don't want to have to keep thinking "which functor does that fmap work on?"
09:16:05 <EvilTerran> if it can only ever work on one
09:16:23 <EvilTerran> clarity > consistency :)
09:17:35 <Sizur> that's true. i'm just thinking that practice of answering to "what does this fmap realize to?" will make you think naturally in abstractions faster
09:17:41 <EvilTerran> using map instead of fmap provides the same information to the programmer that adding a list type annotation would provide, and much more tersely
09:20:58 <llf> @pl n f x = return (f x)
09:20:58 <lambdabot> n = (return .)
09:21:22 <llf> is there a good name for that thing?
09:21:41 <ricky_clarkson> :t return .
09:21:42 <lambdabot> parse error (possibly incorrect indentation)
09:21:51 <ricky_clarkson> :t (return .)
09:21:51 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
09:21:56 <mux> :t pure
09:21:57 <lambdabot>     Ambiguous occurrence `pure'
09:21:57 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
09:21:57 <lambdabot>                           or `pure', imported from Control.Arrow
09:22:04 <ricky_clarkson> :hoogle (Monad m) => (a -> b) -> a -> m b
09:22:15 <mux> Control.Applicative.pure is nearly but not quite the same, it's slightly more generic
09:22:24 <ricky_clarkson> @hoogle (Monad m) => (a -> b) -> a -> m b
09:22:24 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
09:22:24 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
09:22:24 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
09:22:35 <mux> @version
09:22:35 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
09:22:35 <lambdabot> darcs get http://code.haskell.org/lambdabot
09:22:38 <llf> thanks
09:22:39 <idnar> t Control.Applicative.pure
09:22:45 <idnar> :t Control.Arrow.pure
09:22:45 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
09:22:47 <idnar> :t Control.Applicative.pure
09:22:47 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
09:22:54 * idnar kicks his keyboard
09:24:12 <Sizur> :t Control.Applicative.pure . id
09:24:12 <lambdabot> forall (f :: * -> *) a. (Applicative f) => a -> f a
09:28:09 <Sizur> EvilTerran: i'd say that consistency leads to clarity in the long run
09:29:18 <hashendgame> I'm looking at building a plugin-based program, and I want to have plugins able to add their own data to structures. My first thought was to have something like data Server = Server { ... , extra :: Data.Map String Data.Dynamic , ... }. This looks ok, but will it work across plugins?
09:29:26 <Sizur> where you could for example replace a structure easely, if you're not using list syntax inline.
09:29:55 <EvilTerran> eh. when it's possible to make a function more general, i'd do so
09:30:20 <EvilTerran> but if it's tied to lists because of another function i'm using, i'll use the list-specific functions
09:30:58 <ricky_clarkson> Then you'll never see if your function might be more general than lists.
09:31:16 <EvilTerran> maybe you wouldn't
09:31:30 <EvilTerran> I find i have a fairly good intuition for it
09:31:52 <EvilTerran> as in, if i'm using something like zipWith, i'll use the list-specific functions
09:32:00 <EvilTerran> if i'm not, i'll use the generic ones
09:33:47 <roconnor> Zippable?
09:34:25 <Sizur> applicable
09:36:18 <cosimo2> hi all
09:36:38 <EvilTerran> well, yes, but i'm not gonna start importing extra classes that i have no intention of actually leveraging
09:36:50 <EvilTerran> just to make a function more general
09:36:51 <byorgey> hi cosimo2
09:36:54 <Sizur> hi cosimo2
09:39:57 <Sizur> :t zipWith
09:40:12 <lambdabot> thread killed
09:40:22 <idnar> poor thread
09:40:26 <idnar> it was so young!
09:40:26 <Sizur> :t zipWIth2
09:40:27 <lambdabot> Not in scope: `zipWIth2'
09:42:00 <Sizur> > (,) <$> [0..] <*> repeat True
09:42:02 <lambdabot>  [(0,True),(0,True),(0,True),(0,True),(0,True),(0,True),(0,True),(0,True),(0,...
09:42:25 <Sizur> lol yeah
09:42:44 <byorgey> :t zipWith2
09:42:44 <lambdabot> Not in scope: `zipWith2'
09:42:55 <Sizur> zipWith = zipWith2
09:42:59 <byorgey> wait, yeah =)
09:44:04 <byorgey> > (,) <$> ZipList [0..] <*> pure True
09:44:05 <lambdabot> Terminated
09:44:09 <byorgey> > (,) <$> ZipList [0..] <*> pure True
09:44:09 <lambdabot> Terminated
09:44:13 <byorgey> ?
09:44:45 <mux> that should definitely work
09:44:46 <byorgey> > (,) <$> ZipList [0..] <*> pure True
09:44:47 <lambdabot> Terminated
09:44:59 * byorgey slaps lambdabot with a trout
09:45:14 <byorgey> > 3
09:45:15 <lambdabot>  3
09:45:17 <Sizur> @hoogle ZipList
09:45:17 <lambdabot> Control.Applicative.ZipList :: newtype ZipList a
09:45:17 <lambdabot> Control.Applicative.ZipList :: [a] -> ZipList a
09:45:17 <lambdabot> Control.Applicative.getZipList :: ZipList a -> [a]
09:45:26 <byorgey> > sum $ [1..10]
09:45:26 <lambdabot>  55
09:45:30 <byorgey> > (,) <$> ZipList [0..] <*> pure True
09:45:30 <lambdabot> Terminated
09:45:33 <byorgey> gah!
09:45:38 <mux> > getZipList $ (,) <$> ZipList [0..] <*> pure True
09:45:39 <lambdabot> Terminated
09:45:46 * mux shrugs
09:46:11 <Jomyoot> Can GCHI print actual characters instead of \224\184\149\224
09:46:20 <dcoutts> Jomyoot: putStr
09:46:52 <dcoutts> but note that putStr doesn't do unicode
09:47:08 <Sizur> System.IO.UTF8.putStr
09:47:42 <Sizur> from utf8-string package
09:48:26 <Jomyoot> ok
09:48:28 <Jomyoot> thanks guys
09:49:08 <Sizur> i wonder why haskell was not designed right from start with Char being unicode
09:49:28 <Sizur> C legacy
09:49:31 <mauke> Char is unicode
09:49:35 <Zao> Sizur: Char is an unicode codepoint.
09:49:38 <roconnor> Sizur: did unicode exist in the late 80's?
09:49:43 <Zao> Standard IO truncates on input/output.
09:50:02 <idnar> hmm, droundy said something on the darcs mailing list the other day that made it sound like Char wasn't unicode
09:50:38 <idnar> "However, the similar bug in the output of whatsnew, etc, has not yet been fixed.  Many of these issues date from my very naive assumption (long ago!) that because Char is a 32 bit value, it is therefore a unicode value. :("
09:50:56 <dcoutts> Sizur: the Haskell98 report states that Char is Unicode and that source modules are to be treated as Unicode
09:51:33 <roconnor> dcoutts, do function names have to be ascii?
09:51:39 <dcoutts> roconnor: no
09:51:47 <Sizur> ok, i believe Char is unicode. the curse of babel
09:51:54 <dcoutts> and you can use unicode operators as operators
09:51:59 <roconnor> dcoutts, hmm, how does it know what is a captial letter and what isn't?
09:52:07 <dcoutts> roconnor: using unicode property tables
09:52:29 * Botje wonders if redefining Char to be unicode would be much work
09:52:30 <Sizur> roconnor: unicode specifies which alpha char is capital
09:52:35 <roconnor> oh
09:52:43 <dcoutts> Botje: none at all since it is already :-)
09:52:51 <roconnor> even langauges like japanesse?
09:53:03 <Botje> it is?
09:53:09 <Botje> cool
09:53:24 <Botje> Prelude> length "Ã©"
09:53:25 <Botje> 2
09:53:27 <Botje> this saddens me :(
09:53:40 <Sizur> roconnor: i guess if a langauge has no capitals, then there wont be in unicode
09:53:46 <dcoutts> Botje: that's ghci's fault
09:54:03 <Botje> ah
09:54:05 <dcoutts> Botje: try doing that in a module rather than entering it on the command line
09:54:26 <mauke>  % perl -wle 'print length "Ã©"'
09:54:26 <mauke> 2
09:54:26 <dcoutts> Botje: since ghc-6.6 it treats .hs files as utf8
09:54:35 <roconnor> Sizur: what do you mean?
09:54:42 <dcoutts> > fromEnum (maxBound :: Char)
09:54:45 <mauke> (fixable with 'use utf8;')
09:54:49 <lambdabot>  1114111
09:55:01 <idnar> Prelude> length "\xe9"
09:55:01 <idnar> 1
09:55:23 <Sizur> roconnor: i dont know if there is a language without capitals, but if there is one, then there will be no capitals in the unicode representation of that langauge
09:55:42 <Botje> dcoutts: would it take a lot of work to make ghci look at the current locale / encoding and .. ?
09:56:01 <roconnor> Sizur: I assume most eastern languages such as japanesse, korean, chinesse, thai, etc. don't have a notion of captial letters.
09:56:04 <dcoutts> Botje: I think it's done in ghc 6.9, though not locale, just always utf-8
09:56:22 <Botje> yeah
09:56:30 <Botje> it's probably a bit too early to start using 6.9, i guess :)
09:56:37 <dcoutts> aye
09:59:41 <Sizur> roconnor: i'll ask my chinese friend if there is a way to emphasize a chinese clear-text
09:59:53 <Sizur> i'd take that as capitals
10:00:34 <roconnor> :/
10:01:35 <Sizur> one can argue that hieroglyphics are not characters, but then we'd create more problems than solve
10:03:23 <roconnor> they are certainly Chars
10:03:50 <Sizur> plus input devices produce hieroglyphics by inputing a sequence of chars
10:05:03 <Sizur> korean and japanese including, even though they have much less characters than chinese
10:07:18 <roconnor> @src Numeric.readOct
10:07:19 <lambdabot> Source not found. Wrong!  You cheating scum!
10:07:52 <Sizur> that wasnt funny actually
10:08:36 <idnar> heh
10:09:08 <roconnor> Sizur: huh?
10:09:19 <Sizur> roconnor: that was aimed at lambdabot
10:09:35 <pi3> Why is a^b for b < 0 incorrect in Haskell?
10:09:35 <roconnor> I want to see the source of Numeric.readOct
10:09:47 <lightstep> ?hoogle Double -> Int
10:09:48 <mux> :t (^)
10:09:48 <lambdabot> No matches, try a more general search
10:09:49 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
10:09:52 <roconnor> pi3: you probably want a^^b
10:09:58 <pi3> 2^(-2)
10:10:17 <mux> > 2^^(-2)
10:10:17 <mux> > 2^(-2)
10:10:18 <lambdabot>  Exception: Prelude.^: negative exponent
10:10:18 <lambdabot>  0.25
10:10:18 <roconnor> > 2^(-2)
10:10:19 <lambdabot>  Exception: Prelude.^: negative exponent
10:10:20 <roconnor> > 2^^(-2)
10:10:21 <lambdabot>  0.25
10:10:33 <roconnor> @type (^^)
10:10:34 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
10:10:41 <roconnor> different types
10:10:46 <pi3> roconnor: ok, thanks
10:10:55 <mux> I suppose that's for enabling more efficient implementations
10:11:10 <Sizur> > 2**(-2)
10:11:11 <lambdabot>  0.25
10:11:41 <Sizur> @type (**)
10:11:42 <lambdabot> forall a. (Floating a) => a -> a -> a
10:11:51 <mux> and there you wish we had some limited form of dependent typing to express positive integral types
10:12:07 <mux> other than Oleg-isms I mean :)
10:12:38 <Sizur> yeah, and possibility to override methods in subclasses
10:13:10 <Sizur> then you wouldnt need 3 operators for power
10:16:35 <shachaf> Well, (^) has the advantage of working for Integrals.
10:17:08 <shachaf> > (2 ^^ (-5)) :: Integer -- Doesn't make that much sense.
10:17:08 <lambdabot>   add an instance declaration for (Fractional Integer)
10:17:08 <lambdabot>     In the expression:...
10:17:15 <Jomyoot> is utf8.print correctly implemented?
10:17:23 <Jomyoot> it does not work analogous to utf8.putStr
10:18:37 <Sizur> doesn't it use show?
10:19:00 <monochrom> Prelude.print is different from Prelude.putStr too.
10:19:20 <Jomyoot> well it doesn't convert the UTF8 thing
10:19:28 <Jomyoot> whereas the putStr works with UTF8
10:19:49 <shachaf> Jomyoot: Are you talking about utf8-string's System.IO.UTF8?
10:19:57 <Jomyoot> yes
10:20:06 <Jomyoot> the putStr works on UTF8
10:20:15 <Jomyoot> where as the print doessn't and does no different from the Prelude's one
10:20:19 <shachaf> print x = putStrLn (show x)
10:20:39 <shachaf> (From the source; it's just like the regular print, except UTF8.)
10:21:15 <monochrom> > show "\x2221"
10:21:16 <lambdabot>  "\"\\8737\""
10:21:33 <monochrom> That is what show and print should do.
10:22:19 <mauke> Jomyoot: do you have a custom Show instance that produces unicode?
10:22:31 <Jomyoot> nope
10:22:40 <Jomyoot> where do I get the custom show instance?
10:22:47 <mauke> then how are you testing this?
10:22:47 <Sizur> just use putStrLn
10:22:59 <Jomyoot> Will putStr print list?
10:23:09 <monochrom> mapM_
10:24:06 <monochrom> IMO it is false expectation to expect print to do "a similar thing" as putStr.
10:24:08 <Sizur> > putStrLn <$> ["a","b"]
10:24:09 <lambdabot>  [<IO ()>,<IO ()>]
10:24:21 <Jomyoot> i meant tuple
10:24:34 <Jomyoot> i need to print a tuple where its elements are UTF8
10:24:52 <Sizur> that's resonable
10:25:38 <monochrom> show for String escapes all non-ascii non-printable characters.
10:25:50 <monochrom> The UTF8 module can't help it.
10:26:13 <Sizur> how can one do it then
10:26:25 <monochrom> You have to write your own show for String, and somehow suppress the omnipresent one.
10:26:40 <Jomyoot> Why deesn't the UTF8 include customized show?
10:26:47 <monochrom> Or don't use show and print at all.  Write your own pretty printer.
10:26:58 <monochrom> Why should it? I see no reason.
10:27:04 <mauke> Jomyoot: because it would be useless
10:27:07 <EvilTerran> Jomyoot, 'cos you can't override the default instance Show String
10:27:18 <mauke> all existing types are instances of Show, not UTF8Show
10:28:08 <EvilTerran> you could make another class YourShow, instance Show a => YourShow a, instance YourShow String
10:28:12 <EvilTerran> with -XOverlappingInstances
10:28:20 <EvilTerran> i think
10:28:37 <monochrom> But print doesn't use YourShow.
10:28:49 <monochrom> Err write one's own yourprint? :)
10:28:54 <EvilTerran> then import Prelude hiding (show, print, etc), and write your own show, print, etc using YourShow
10:29:06 <lightstep> a solution for this is "newtype PrintMyWay = PMW (String, String)", for which you define a show instnce
10:29:17 <EvilTerran> ?type Prelude.etc --:D
10:29:18 <lambdabot> Not in scope: `Prelude.etc'
10:29:19 <lightstep> then you saw "print (PrintMyWay tuple)"
10:30:02 <shachaf> EvilTerran: Don't you need UndecidableInstances for that?
10:31:44 <monochrom> "do what I mean" mentality is very damaging.
10:32:31 <lightstep> yeah, symbolics did it, and they lost
10:36:18 <Sizur> is there any efficiency gain using mapM_ over mapM in a lazy context?
10:36:37 <monochrom> Yes absolutely. Their codes are very different.
10:36:38 <ddarius> Yes.
10:37:08 <Sizur> @src mapM
10:37:08 <lambdabot> mapM f as = sequence (map f as)
10:37:17 <Sizur> @src mapM_
10:37:17 <lambdabot> mapM_ f as = sequence_ (map f as)
10:37:27 <monochrom> Hehe
10:37:30 <Sizur> @src sequence_
10:37:30 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
10:37:39 <Sizur> @src sequence
10:37:40 <lambdabot> sequence ms = foldr k (return []) ms
10:37:40 <lambdabot>     where
10:37:40 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
10:37:48 <ddarius> k = liftM2 (:)
10:39:10 <idnar> :t sequence
10:39:13 <idnar> :t sequence_
10:39:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:39:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
10:39:22 <monochrom> sequence infinite_list uses infinite memory, sequence_ infinite_list doesn't. I assume the IO monad and most common monads.
10:39:41 <Sizur> why would liftM2 (:) be slower than (>>) when i don't use the list?
10:40:38 <idnar> how do you get anything out of sequence_ on an infinite list?
10:40:46 <monochrom> It still builds a thunk.
10:41:15 <Sizur> idnar: a game loop?
10:41:25 <monochrom> And if m >>= f really "executes" m before looking at f, the whole list is still built.
10:41:37 <fadec> in the category Hask, how would (+) be drawn since it takes two arguments before returning to Num? A morphism has only two ends.
10:42:06 <idnar> hmm, I suppose all the machinery is in the monad type, not the contained type
10:42:23 <monochrom> Yes, it's up to >>=
10:42:30 <LoganCapaldo> fadec: I don't know but consider (->) Int ((->) Int Int)
10:43:06 <byorgey> fadec: functions in Haskell all take one argument
10:43:06 <monochrom> You can use exponentiation for the (->) Int Int part.
10:43:18 <byorgey> fadec: the (+) function takes an Int, and returns a new function
10:43:21 <monochrom> (+) :: Int -> Int^Int
10:43:36 <fadec> byorgey: so functions are not only morphisms but objects?
10:43:53 <byorgey> fadec: no, types are objects and functions are morphisms
10:44:03 <byorgey> fadec: oh, I see what you mean
10:44:13 <byorgey> fadec: types are objects, which includes function types
10:45:00 <sclv> ok question about polymorphism and typeclasses. (this is in ghc 6.6.1 mind you)
10:45:06 <fadec> byorgey: I was just trying to figure out how to draw it. I can draw an arrow for say (+1), because it has a type similar to id.
10:45:12 <sclv> if I have a function parseSTMP :: (Stringable a) => (Char, Char) -> String -> SEnv -> a
10:45:23 <fadec> (+1) is from Num to Num
10:45:34 <sclv> then why can't I have:
10:45:36 <sclv> foo :: String -> (forall a. (Stringable a) => SEnv -> a)
10:45:36 <sclv> foo = parseSTMP ('$','$')
10:45:52 <byorgey> fadec: right, and (+) is from Int to (Int->Int)
10:46:38 <fadec> byorgey: and (Int -> Int) is an object because it is a type. I'm starting to see it more clearly
10:46:45 <sclv> i.e. I want to return a function that's polymorphic over a class constraint. if I move the forall to the front of foo, I get "foo" polymorphic, but its return type is monomorphic.
10:47:02 <byorgey> fadec: that's right.
10:47:16 <byorgey> fadec: if A and B are types, then so is (A->B)
10:48:06 <fadec> and if f :: A -> B and g :: A -> B, then f and g are homomorphic?
10:48:08 <sclv> as it is, I get: "    Inferred type is less polymorphic than expected;  Quantified type variable `a' escapes" and fno-monomorphism-restriction doesn't help. Is there a clean way to do what I want?
10:48:09 <desegnis> so for any morphism in Hask, there is a corresponding object...
10:49:06 <byorgey> fadec: I don't think that's the right term, I'd just say they're parallel arrows
10:49:13 <byorgey> desegnis: I guess that's true, isn't it?
10:49:27 <fadec> hmm
10:49:29 * fadec thanks #haskell and returns to reading
10:49:52 <desegnis> byorgey: Well I was thinking aloud, and I hope so
10:52:29 <gwern> so I want to take a string and find the index of the first ' '; I could use "Data.List.findIndex (== ' '0) foo", but is there anything which specializes findIndex?
10:52:42 <gwern> (for strings, to look for first Char)
10:52:43 <mauke> :t findElem
10:52:45 <lambdabot> Not in scope: `findElem'
10:52:59 <trofimovich> ?search setResourceLimit
10:52:59 <lambdabot> Unknown command, try @list
10:53:19 <byorgey> gwern: I don't think there is
10:53:21 <gwern> @hoogle findElem
10:53:22 <lambdabot> No matches found
10:53:33 <mauke> oh, duh
10:53:34 <LoganCapaldo> sclv: guessing (completely) but wouldn't a need to be fixed for parseSTMP since presumably it's "used" there (in the sense that it uses methods from Stringable)?
10:53:37 <mauke> :t elemIndex
10:53:38 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
10:53:41 <desegnis> sclv: I cannot see why it does not work either, but what is the benefit of having the forall right there where you have it? If you put forall at the beginning of the type signature, the function that you return will still be polymorphic
10:53:43 <LoganCapaldo> @type elemIndex
10:53:44 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
10:53:45 <byorgey> oh, there is! =)
10:54:10 * gwern hoogled for Char -> String -> Maybe Int but I didn't see anything
10:54:20 <monochrom> sclv: foo s = parseSTMP ('$','$') s  works. I wouldn't worry about foo = parseSTMP ('$','$')
10:54:20 <gwern> @src elemIndex
10:54:21 <lambdabot> elemIndex x     = findIndex (x==)
10:54:41 <sclv> monochrom: hmm. I'll try that.
10:54:41 <LoganCapaldo> String = [Char] there isn't a lot of good reasons to have string specifc functions
10:54:56 <gwern> good
10:55:38 <gwern> yeah, but something that worked on a -> [a] -> Int should work for Char -> [String] -> Int
10:55:42 <gwern> so why ddn't hoogle find it?
10:55:51 <gwern> er, [Char]
10:56:10 <LoganCapaldo> @hoogle Char -> [Char] -> Maybe Int
10:56:10 <lambdabot> No matches, try a more general search
10:56:15 <sclv> desegnis: without the forall the function I return isn't polymorphic, it's got to be fixed to a particular instance of Stringable.
10:56:19 <LoganCapaldo> hoogles not perfect? :)
10:56:43 <idnar> well, it tells you to try a more general search :)
10:56:54 <LoganCapaldo> that it does
10:57:02 <gwern> LoganCapaldo: WHAT. who do I talk to about that??? :)
10:57:28 <LoganCapaldo> I dunno :)
10:57:36 <desegnis> :type const show
10:57:42 <LoganCapaldo> it might be neat if it tried to "generalize" for you I suppose
10:57:44 <gwern> lambdabot maybe, but what about http://haskell.org/hoogle/?q=Char+->+String+->+Maybe+Int ?
10:57:48 <desegnis> @type const show
10:57:49 <lambdabot> forall a b. (Show a) => b -> a -> String
10:57:51 <desegnis> @type const show ()
10:57:51 <lambdabot> forall a. (Show a) => a -> String
10:57:55 <gwern> I see no suggestion to be more general there
10:57:58 <sclv> monochrom: your solution gives a half-fix. it accepts the signature, but then rewrites it. :-( i.e. foo :: String -> (forall a. (Stringable a) => SEnv -> a) passes, but when I get the type in ghci it still gives foo :: (Stringable a) => String -> SEnv -> a
10:58:44 <monochrom> "forall hoisting"
10:58:54 <trofimovich> it seems serResourceLimit is broken on ghc-6.8.2 (i386), isn't it? (RunPlugs and simple test fail to limit CPU time)
10:59:46 <gwern> > [1..]
10:59:47 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
11:00:33 <sclv> is that proper behavior?
11:00:52 <monochrom> Yes. I have also tested that it does not reduce polymorphism.
11:02:34 <monochrom> If you observe non-polymorphism, you need a forall signature nearer the site of use.
11:03:32 <Corun> > let mm = 1 : 1 : [ mm !! i + mm !! (i + 1) | i <- [0..]] in mm
11:03:34 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
11:03:52 <trofimovich> http://hpaste.org/4949#a1 - can someone help me get it to work? thanks
11:04:04 <byorgey> Corun: using indexing like that isn't very efficient with lists
11:04:23 <Corun> What better way would you suggest of doing fibonacci?
11:04:31 <byorgey> > let mm = 1 : 1 : zipWith (+) mm (tail mm) in mm
11:04:31 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
11:05:28 <gwern> oh no not another #haskell discussion on how to do fibonacci
11:05:34 <byorgey> hehe
11:05:49 <gwern> don't we keep a master list of ways to do fibinoacca on the haskell wiki to avoid just this?
11:05:55 <sclv> monochrom: thanks much. going through and seeing what I can do.
11:05:58 <Corun> Hehe, sorry. My fault.
11:06:04 <byorgey> Corun: http://haskell.org/haskellwiki/The_Fibonacci_sequence
11:06:12 <byorgey> Corun: no problem =)
11:06:21 <Corun> I just felt like writing a recursively defined infinite list.
11:07:22 <byorgey> Corun: sure, it's a pretty natural thing to do in Haskell.
11:08:34 <czakey> hello again
11:08:45 <byorgey> > fix ((1:) . (scanl (+) 1))
11:08:46 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
11:08:52 <byorgey> hi czakey
11:08:59 <FunctorSalad> np Corun. we have this a lot but you couldn't have known :)
11:10:20 <czakey> someone can tell me please
11:10:33 <czakey> why I'm so stupid
11:10:44 <czakey> and why that isn't working:
11:10:46 <czakey> let rev (x:xs) = if length x == 2 then (xs:x) else rev xs
11:10:49 <mauke> because you are EDUCATED STUPID
11:10:49 <czakey> ;>
11:10:55 <czakey> yes
11:11:00 <Sizur> @pl \a b -> fix ((a:) . (scanl (+) b))
11:11:00 <lambdabot> (fix .) . (. scanl (+)) . (.) . (:)
11:11:02 <shachaf> czakey: (:) only works one way.
11:11:02 <mauke> an evil ANDROID,
11:11:03 <mauke> your opposite brain destroyed by Evil ONE.
11:11:03 <czakey> you right
11:11:03 <hpaste>  monochrom pasted "high polymorphism example" at http://hpaste.org/4950
11:11:10 <shachaf> czakey: You can't cons onto the end of a list.
11:11:11 <czakey> Im imperative
11:11:17 <monochrom> sclv: see http://hpaste.org/4950 for examples
11:11:28 <FunctorSalad> hey let's do fibonacci with a GADT (with the algebra generated by the iteration matrix) =)
11:11:29 <czakey> so much imperative thats discousting ;>
11:11:30 <gwern> mauke: the man didn't want him to know time is a cube!
11:11:34 <shachaf> czakey: Also, you shouldn't use length here, probably.
11:11:34 <FunctorSalad> I'm on it.
11:11:47 <byorgey> FunctorSalad: =D
11:12:31 <Sizur> > let ns = (fix .) . (. scanl (+)) . (.) . (:) (-234) (1234) in (ns!!201)/(ns!!200)
11:12:31 <lambdabot>  Couldn't match expected type `a -> b -> c'
11:12:35 <EvilTerran> czakey, why're you taking the length of x? x is a list item, not a list element
11:12:42 <czakey> I'm trying to write "reverse"
11:12:43 <EvilTerran> er, s/element//
11:12:43 <monochrom> The best functional programming is inspired by imperative programming. The best imperative programming is inspired by functional programming.
11:12:52 <czakey> to reverse the list
11:13:02 <EvilTerran> czakey, yes, but x isn't a list
11:13:09 <czakey> oh
11:13:10 <czakey> yes
11:13:10 <EvilTerran> x is the first item of a list
11:13:15 <czakey> you right
11:13:16 <EvilTerran> so it doesn't have a length
11:13:24 <EvilTerran> and even if it did, there'd be no good reason for it to be 2
11:13:34 <EvilTerran> okay, so
11:13:38 <EvilTerran> reverse [] = ???
11:13:38 <Sizur> > (fix .) . (. scanl (+)) . (.) . (:) 1 1
11:13:38 <lambdabot>  Couldn't match expected type `a -> b -> c'
11:13:39 <gwern> @quote monochrom
11:13:39 <lambdabot> monochrom says: people â© haskellers = â
11:13:48 <shachaf> > foldl (flip (:)) [1,2,3]
11:13:49 <lambdabot>  <[Integer] -> [Integer]>
11:13:50 <czakey> reerse [] = []
11:13:54 <Saizan> > let ns = ((fix .) . (. scanl (+)) . (.) . (:)) (-234) (1234) in (ns!!201)/(ns!!200)
11:13:55 <lambdabot>  1.618033988749895
11:13:56 <shachaf> > foldl (flip (:)) [] [1,2,3]
11:13:56 <lambdabot>  [3,2,1]
11:13:57 <Sizur> :t (fix .) . (. scanl (+)) . (.) . (:)
11:13:57 <lambdabot> forall a. (Num a) => a -> a -> [a]
11:13:57 <czakey> thats ok
11:13:58 <czakey> ;)
11:14:30 <Sizur> > (fix .) . (. scanl (+)) . (.) . (:) (1::Integer) 1
11:14:31 <lambdabot>  Couldn't match expected type `a -> b -> c'
11:14:34 <EvilTerran> okay then. reverse (x:xs) = ???
11:14:52 <gwern> > 7 `mod` 7
11:14:53 <lambdabot>  0
11:15:02 <gwern> > 2 `mod` 7
11:15:02 <lambdabot>  2
11:15:05 <czakey> thats what I'm thinking about :>
11:15:19 <gwern> > 2 `rem` 7
11:15:19 <lambdabot>  2
11:15:21 <EvilTerran> what'd it be in words?
11:15:24 <czakey> it shoud be revesed xs and then x
11:15:25 <czakey> :>
11:15:47 <czakey> so if I have [1,2,3,4,5] it will give [5,4,3,2,1]
11:15:53 <EvilTerran> okay, so you want to append x onto the end of (reverse xs)?
11:15:59 <Sizur> > let f = ((fix .) . (. scanl (+)) . (.) . (:)) (-234) (23456) in f!!201/f!!200
11:15:59 <lambdabot>  1.618033988749895
11:16:01 <monochrom> gwern: mod and rem differ when some operands are negative.
11:16:05 <EvilTerran> > [1,2,3,4,5] ++ [6]
11:16:06 <lambdabot>  [1,2,3,4,5,6]
11:16:06 <czakey> yep
11:16:19 <czakey> concatenation
11:16:20 <czakey> hmm
11:16:37 <EvilTerran> however, this is very inefficient; it'll be O(n^2)
11:16:43 <EvilTerran> it does work, tho
11:16:58 <sclv> hmm... it was a monomorphismish issue i think. some ugly lambdas in a few places did the trick!
11:17:15 <EvilTerran> @check let rev [] = []; rev (x:xs) = rev xs ++ [x] in \xs -> rev xs == reverse (xs :: [Int])
11:17:16 <lambdabot>  OK, passed 500 tests.
11:17:16 <monochrom> See Andy Gill and Graham Hutton's latest paper for how to *transform* it to efficient code. :)
11:17:26 <gwern> monochrom: I noticed
11:17:52 <EvilTerran> czakey, the problem with that code is that (xs ++ ys) takes O(length xs) operations
11:18:15 <EvilTerran> and (++) is happening (length xs) times
11:18:23 <czakey> so n^2 in result
11:18:26 <EvilTerran> indeed
11:18:31 * monochrom knows how to combat monomorphisms!
11:18:44 <EvilTerran> @remember monochrom knows how to combat monomorphisms!
11:18:44 <lambdabot> Nice!
11:19:04 <czakey> so I probably need to place recursion at end
11:19:08 * monochrom is also a mono, has insider information :)
11:19:09 <czakey> but first
11:19:10 <gwern> this is hard... so I have forwardWord :: (Int,String) -> (Int,String), but how do I define backwardWord in terms of forwardWord? it can't simply be backwardWord (a,b) = forwardWord (a,reverse b), because then the index you are at is not transformed appropriately. hum...
11:19:15 <czakey> do it better way :>
11:19:19 <sclv> this is really awesome now: I have a parser that produces polymorphic output! so I can get pretty-printer combinator expressions or ShowS expressions or bytestrings with the same code!
11:19:20 <Sizur> @src reverse
11:19:20 <lambdabot> reverse = foldl (flip (:)) []
11:19:46 <EvilTerran> czakey, here's an idea: create a new function, revCat xs ys
11:19:58 <EvilTerran> so revCat xs ys = reverse xs ++ ys
11:20:09 <EvilTerran> revCat [] ys = ???
11:20:26 <czakey> hmm
11:20:59 <EvilTerran> (I pronounce (++) as "cat", that's why i called revCat that)
11:21:11 <monochrom> Sounds like sclv has a code parser than generates code.
11:21:14 <czakey> thats ok
11:21:32 <czakey> but I dont know why another function
11:21:37 <EvilTerran> trust me on this one :)
11:21:37 <czakey> to concatenate
11:21:39 <monochrom> Hrm! I would think id is also a code parser that generates code! :)
11:21:49 <czakey> ok
11:21:51 <czakey> ;)
11:21:59 <EvilTerran> what'd the value of (revCat [] ys) be?
11:22:06 <sclv> monochrom: its pretty much an interpreter, yeah. due to the way I wrote it though, it still can't output its own parse tree :-(
11:22:19 <czakey> ys
11:22:22 <EvilTerran> indeed
11:22:34 <EvilTerran> and... revCat (x:xs) ys = ???
11:23:04 <czakey> xs:x
11:23:08 <czakey> ?
11:23:17 <EvilTerran> you can't : onto the end of a list
11:23:21 <EvilTerran> and what happened to ys?
11:23:33 <EvilTerran> i'll give you some equational reasoning...
11:23:34 <czakey> aah
11:23:38 <EvilTerran> revCat (x:xs) ys
11:23:43 <EvilTerran> = reverse (x:xs) ++ ys
11:23:52 <EvilTerran> = (reverse xs ++ [x]) ++ ys
11:23:57 <EvilTerran> = reverse xs ++ ([x] ++ ys)
11:24:04 <EvilTerran> = reverse xs ++ (x:ys)
11:24:05 <IvdSangen> ?type (:)
11:24:06 <lambdabot> forall a. a -> [a] -> [a]
11:24:10 <EvilTerran> = revCat xs (x:ys)
11:24:30 * byorgey cheers for equational reasoning
11:24:36 <IvdSangen> the type are asymmetric
11:24:39 <EvilTerran> czakey, do you understand every step of that?
11:25:03 <czakey> just moment
11:25:11 <idnar> monochrom: which paper is this?
11:25:12 <czakey> in first step
11:25:16 <czakey> ys = []
11:25:17 <czakey> ?
11:25:26 <EvilTerran> we don't care what ys is
11:25:36 <EvilTerran> remember, earlier i said we're defining revCat such that revCat xs ys = reverse xs ++ ys
11:25:42 <EvilTerran> i just used that
11:26:00 <czakey> ah, ok
11:26:20 <EvilTerran> in the second step, i used our naive definition of reverse (reverse (x:xs) = reverse xs ++ [x])
11:26:29 <monochrom> idnar: see for example http://groups.google.com/group/fa.haskell/browse_thread/thread/aa3a6465d88744c0/824000d08ad40771?lnk=raot
11:26:30 <lambdabot> Title: The Worker/Wrapper Transformation - fa.haskell | Google Groups, http://tinyurl.com/2xlv49
11:26:31 <czakey> mhm
11:26:41 <EvilTerran> then i took advantage of (++) being associative, and then that ([x] ++ xs) = (x:xs)
11:26:56 <czakey> ok, I get it
11:27:00 <idnar> monochrom: cool
11:27:00 <EvilTerran> and then i noticed that reverse xs ++ (x:ys) fits the right-hand side of our definition of revCat
11:27:05 <czakey> got
11:27:20 <EvilTerran> so now we have revCat [] ys = ys; revCat (x:xs) ys = revCat xs (y:ys)
11:27:30 <EvilTerran> this works in O(length xs) time
11:27:55 <EvilTerran> but now, revCat xs [] = reverse xs ++ [] = reverse xs
11:27:59 <idnar> EvilTerran: (x:ys), you mean?
11:28:03 <EvilTerran> er, yes
11:28:16 <byorgey> > let revCat [] ys = ys; revCat (x:xs) ys = revCat xs (x:ys) in revCat [1..100000]
11:28:18 <lambdabot>  <[Integer] -> [Integer]>
11:28:21 <EvilTerran> czakey, so we can redefine reverse xs = revCat xs []
11:28:24 <czakey> yep I tought soemthing is wrong ;>
11:28:27 <byorgey> > let revCat [] ys = ys; revCat (x:xs) ys = revCat xs (x:ys) in revCat [1..100000] []
11:28:27 <lambdabot>  [100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99...
11:28:43 <EvilTerran> and this new definition of (reverse xs) works in O(length xs) time :D
11:29:04 <byorgey> > let rev [] = []; rev (x:xs) = rev xs ++ [x] in rev [1..100000]
11:29:11 <lambdabot> Terminated
11:29:23 <idnar> > let revCat [] ys = ys; revCat (x:xs) ys = revCat xs (x:ys) in revCat [1..10] [42]
11:29:23 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,42]
11:29:39 <EvilTerran> czakey, and that derivation technique i gave doubles as a proof of correctness :)
11:29:55 <czakey> hehe
11:30:17 <czakey> thanks
11:30:22 <EvilTerran> no probs
11:30:31 <EvilTerran> for more in that style, consult the Bird book
11:30:45 <monochrom> Both Bird books. :)
11:30:46 <EvilTerran> http://www.amazon.com/dp/0134843460
11:31:05 <czakey> thats the problem
11:31:06 <EvilTerran> (I have to plug him, he taught me that as my lecturer :D)
11:31:25 <czakey> ive searched something about 8 bookshops
11:31:42 <czakey> theres nothing about Haskell ;d
11:31:47 <EvilTerran> for haskell books, you do tend to end up buying off the internet
11:32:07 <ddarius> For most technical books that's the case.
11:32:29 <EvilTerran> amazon's suitable, also try abebooks.com (and maybe ebay)
11:32:49 <czakey> there is something
11:33:12 <czakey> but I will get it after some time
11:33:13 <desegnis> Oh, there are people who order books in their bookshop, too :-)
11:33:13 <monochrom> and http://www.amazon.com/dp/013507245X/
11:33:46 <czakey> but I'm experimenting right now ;)
11:34:03 <EvilTerran> monochrom, ooh, i hadn't seen that one before
11:34:13 <EvilTerran> and it's by my two favourite lecturers! :D
11:34:32 <czakey> ok
11:34:44 <czakey> so last question
11:34:46 <monochrom> @botsnack
11:34:46 <lambdabot> :)
11:35:03 <czakey> how to create permutations of list?
11:35:16 <czakey> so if I have
11:35:26 <czakey> [1,2,3]
11:35:37 <czakey> it returns with
11:35:42 <czakey> [3,2,1]
11:35:48 <czakey> [2,3,1]
11:35:58 <czakey> [1,3,2]
11:36:00 <EvilTerran> try writing a naive algorithm. if it's too slow, paste it, and we'll try to show you how to optimise it
11:36:01 <sarehu> you mean, [[3,2,1],[2,3,1],...]?
11:36:10 <EvilTerran> and don't forget you can't (:) onto the end of a list ;)
11:36:11 <czakey> ok
11:36:31 <EvilTerran> @paste
11:36:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:37:00 <monochrom> I have an elliptic curve factorer. It is too slow.
11:37:17 * Botje is tempted to paste the filterM algorithm, since this is very clearly homework :)
11:37:42 <EvilTerran> isn't filterM for all sublists?
11:37:56 <ddarius> Indeed
11:38:29 * EvilTerran wanders off
11:39:47 <llf> @pl f a b c x y = c (a x) (b y)
11:39:47 <lambdabot> f = flip . ((flip . ((.) .)) .) . flip (.)
11:43:01 <idnar> @djinn a -> ([a] -> [a]) -> [a] -> [a]
11:43:01 <lambdabot> f _ a b = a b
11:43:17 <idnar> @. pl djinn a -> ([a] -> [a]) -> [a] -> [a]
11:43:17 <lambdabot> f = const id
11:43:22 <idnar> heh
11:47:06 <basvdijk> Hello, quick question: Why gives GHC a type error on the following function foo' on hpaste?
11:47:08 <hpaste>  basvdijk pasted "ScopedTypeVariables" at http://hpaste.org/4951
11:47:55 <Igloo> basvdijk: You need a "forall a ."
11:48:25 <basvdijk> Igloo: thanks that works!
11:50:04 <hpaste>  basvdijk annotated "ScopedTypeVariables" with "fixed by Igloo" at http://hpaste.org/4951#a1
11:51:54 <snotbrake> hello, may someone help me
11:52:31 <allbery_b> ask your question, if someone can elp they'll answer
11:52:36 <allbery_b> help, even
11:52:42 <snotbrake> i tried to import Graphics.HGL with the command "import Graphics.HGL" and it work by an friend, but not by me. Error is "unexpected symbol "Graphics.HGL""
11:52:50 <snotbrake> what shall i do
11:53:22 <basvdijk> Do you have the package hgl installed?
11:53:29 <snotbrake> but it's on my computer in a subdirectory
11:53:56 <snotbrake> i installed just hugs and i can find the graphics.hgl files on my computer
11:54:09 <Botje> snotbrake: can you paste the exact import line you used?
11:54:40 <snotbrake> i did: "import Graphics.HGL"
11:55:34 <snotbrake> where do i have to place the Graphics/HGL folder relative to my prog?
11:56:33 <basvdijk> Have you actually installed hgl?
11:56:43 <basvdijk> If not read: http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
11:56:43 <lambdabot> http://tinyurl.com/39kra4
11:56:48 <snotbrake> not sure
11:56:58 <basvdijk> and get HGL from http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HGL-3.2.0.0
11:57:00 <lambdabot> http://tinyurl.com/382n8n
11:57:18 <snotbrake> ok, i'll try
11:57:20 <basvdijk> (or use your package manager if you're on linux)
11:58:19 <basvdijk> If you're using GHC you can check which packages are installed by ghc-pkg -L... with hugs I don't know
12:02:11 <basvdijk> snotbrake: getting anywhere?
12:02:27 <clanehin> > Just (-0/1)
12:02:30 <lambdabot>  Just -0.0
12:02:36 <czakey> hahah
12:02:52 <czakey> when I'm trying to do that permutations
12:03:05 <czakey> I wrote reverse
12:03:11 <czakey> different way
12:03:18 <snotbrake> install doesn't work: Setup.hs: HGL.cabal:21: Invalid syntax (no colon after field name)
12:03:39 <czakey> perm [] = []
12:03:39 <czakey> perm (x:xs) = zs ++ [x] where zs = perm xs
12:03:48 <czakey> thet shoud be rex ;>
12:04:11 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4952
12:04:17 <czakey> http://hpaste.org/4952
12:04:28 <czakey> oh
12:04:45 <czakey> it announces here!
12:04:47 <czakey> cool ;>
12:05:14 <roconnor> @seen brzozan
12:05:15 <lambdabot> I haven't seen brzozan.
12:05:28 <byorgey> czakey: isn't that 'perm' really just 'reverse'? ;)
12:05:32 <czakey> what about that version EvilTerran?
12:05:35 <basvdijk> snotbrake: I think you are using a to old Cabal version... what is yiur cabal version
12:05:54 <czakey> byorgey: [20:59:10] < czakey> when I'm trying to do that permutations ++ [20:59:23] < czakey> I wrote reverse
12:05:55 <czakey> ;>
12:05:55 <roconnor> @seen glum
12:05:56 <lambdabot> I haven't seen glum.
12:06:05 <byorgey> czakey: ah, you already said that =)
12:06:32 <czakey> but
12:06:40 <czakey> is it optimised?
12:06:40 <byorgey> czakey: instead of zs ++ [x], see if you can write a function which will insert x into every possible place in zs
12:06:44 <czakey> i mean
12:06:47 <snotbrake> what is cabal?
12:06:55 <byorgey> czakey: no, it's the same as the first version of reverse you wrote before
12:07:02 <czakey> did compiler optimise it?
12:07:03 <allbery_b> packaging and build system
12:07:07 <byorgey> czakey: notice you can just substitute for zs
12:07:31 <basvdijk> snotbrake: See: http://haskell.org/cabal/
12:07:41 <litb> hm, so do ...; os another form of a >>= b >>= c; ?
12:07:51 <basvdijk> snotbrake: It is possible that your version of Hugs is to old.
12:07:54 <litb> s/os/is/
12:08:08 <byorgey> hehe, ok
12:08:30 <allbery_b> litb: more or less.  try @undo and @redo with lambdabot
12:08:41 <Tac-Tics> Could not find module `Data.ByteString.Base' <-- Where can I find this module?
12:09:10 <allbery_b> older versions of bytestring
12:09:13 <ddarius> Tac-Tics: You want a different module.
12:09:21 <Tac-Tics> ok
12:09:24 <basvdijk> snotbrake: Do you mind using ghci instead of Hugs? With GHC it's much easier to install a modern cabal package. See: http://haskell.org/ghc
12:09:25 <Tac-Tics> I'm trying to install zlib
12:10:04 <snotbrake> i think, i couldn't compile ghc on mac... i tried it
12:10:43 <snotbrake> ok thx... i try to install ghc
12:11:00 <basvdijk> snotbrake: I've no experience on Mac but according to http://haskell.org/ghc/download_ghc_682.html there are binaries for it...
12:11:30 <Tac-Tics> None of the older versions seem to list data.bytestring.base in Hackae.
12:11:36 <basvdijk> snotbrake: good luck and keep us informed of your progress!
12:11:38 <litb> @undo
12:11:38 <lambdabot> ()
12:11:51 <snotbrake> yeah, i found but need some time, thx, ok, i'll keep you informed
12:12:06 <allbery_b> @undo do { a <- x; b <- y; return (x:y) }
12:12:06 <lambdabot> x >>= \ a -> y >>= \ b -> return (x : y)
12:12:31 <litb> ah i see
12:12:43 <idnar> @. pl undo do { a <- x; b <- y; return (x:y) }
12:12:43 <lambdabot> x >> (y >> return (x : y))
12:12:55 <litb> from where does x and y come?
12:13:07 * allbery_b got that backwartds
12:13:11 <allbery_b> @undo do { a <- x; b <- y; return (a:b) }
12:13:11 <lambdabot> x >>= \ a -> y >>= \ b -> return (a : b)
12:13:26 <idnar> @. pl do { a <- x; b <- y; return (a:b) }
12:13:26 <lambdabot> Plugin `compose' failed with: Unknown command: "do"
12:13:31 <idnar> @. pl undo do { a <- x; b <- y; return (a:b) }
12:13:31 <lambdabot> (`fmap` y) . (:) =<< x
12:13:32 <litb> @src x
12:13:32 <lambdabot> Source not found. Where did you learn to type?
12:13:35 <litb> hmm
12:13:42 <idnar> hmm, @pl doesn't know liftM2 I guess?
12:13:46 <allbery_b> litb: they're assumed to come from somewhere else, possibly arguments
12:13:51 <byorgey> of course!
12:14:05 * byorgey slaps irssi
12:14:06 <idnar> oh wait
12:14:09 <idnar> @. pl undo \x y -> do { a <- x; b <- y; return (a:b) }
12:14:09 <lambdabot> liftM2 (:)
12:14:14 <idnar> success!
12:18:10 <roconnor> @seen ndm
12:18:10 <lambdabot> I saw ndm leaving #haskell 4h 41m 28s ago, and .
12:18:32 <snotbrake> basvdijk: ghc is installed and now?
12:19:01 <litb> now enjoy
12:20:17 <litb> how can i display the source of return again?
12:20:53 <Alberto> It seems that hs-plugins 1.1 existe. Could anyone give me the link?
12:21:10 <litb> oh darn. i see. it's different for each type. forgot that
12:21:21 <allbery_b> @src [] return
12:21:21 <lambdabot> return x    = [x]
12:21:41 <allbery_b> @src Maybe return
12:21:41 <lambdabot> return              = Just
12:29:16 <Alberto> It seems that hs-plugins 1.1 exist. Could anyone give me the link?
12:29:38 <Alberto> please...
12:30:55 <byorgey> Alberto: you can try the latest darcs version
12:30:58 <byorgey> darcs get --set-scripts-executable http://www.cse.unsw.edu.au/~dons/code/hs-plugins
12:31:00 <lambdabot> Title: Index of /~dons/code/hs-plugins
12:31:32 <byorgey> actually, I don't know if it's on code.haskell.org now
12:31:36 <byorgey> @seen dons
12:31:36 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 9h 44m 28s ago.
12:32:04 <Alberto> thanka byorgey
12:32:45 <czakey> x <- someting
12:32:47 <czakey> means
12:32:49 <ac> is there a function like read that returns a Maybe type rather than an error on failure?
12:33:00 <czakey> substitution?
12:33:06 <czakey> im little confused
12:33:24 <shachaf> czakey: do { x <- m; ... } = m >>= (\x -> do { ... })
12:33:31 <shachaf> czakey: Approximately.
12:33:48 <ac> @undo do { x <- getLine; putStrLn x }
12:33:49 <lambdabot> getLine >>= \ x -> putStrLn x
12:33:49 <roconnor> ac: reads
12:33:54 <roconnor> @type reads
12:33:55 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:33:56 <ac> roconnor: ah I knew that
12:33:56 <byorgey> czakey: it doesn't really "mean" anything, in the sense that you can't just describe it with a word
12:34:26 <czakey> huh
12:34:31 <ac> undo could be smarter. Shouldn't that be
12:34:36 <ac> getLine >>= putStrLn
12:34:40 <byorgey> czakey: informally, you could say that 'x <- m' means 'bind the result of running monadic computation m to the name x'
12:34:51 <roconnor> @. pl undo do { x <- getLine; putStrLn x }
12:34:51 <lambdabot> putStrLn =<< getLine
12:35:08 <byorgey> czakey: but I think it's best to understand it via its desugaring, as ac and roconnor are showing.
12:35:32 <ac> czakey: or just not worry about it until other things make sense
12:35:41 <ac> czakey: just pretend it's like "=" in C
12:35:42 <shachaf> czakey: I'd suggest looking at monads in terms of (>>=) and return before looking at do-notation.
12:36:04 <shachaf> ac: But it's not.
12:36:13 <shachaf> ac: Even in IO.
12:36:25 <czakey> I tought that was something like substitution
12:36:37 <shachaf> czakey: In what context? It could be a lot of things.
12:36:43 <czakey> but I know that in HS variables are inmutable
12:36:48 <litb> so, simply said, the >>= and >> op are there to execute a monad?
12:36:49 <czakey> yes
12:37:00 <czakey> Im trying to do that premutations ;)
12:37:12 <shachaf> litb: Are where?
12:37:13 <byorgey> litb: they are for combining two monadic values into one.
12:37:15 <czakey> it looks like this riht now
12:37:19 <ac> czakey: it also appears in list comprehension, like so...
12:37:25 <czakey> let perm (x:xs) = [x:v | x <- xs, v <- perm (xs)]
12:37:35 <ac> > [ (x,y) | x <- [0..4], y <- [0..3] ]
12:37:37 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
12:37:40 <litb> so that if i make a Monad, the code that i want to be executed when the Monad is run is put in >>= and >> ?
12:37:52 <shachaf> litb: Is "run"?
12:37:54 <byorgey> czakey: oh! you mean <- in list comprehensions =)
12:38:05 <shachaf> litb: The code will be run when you use (>>=).
12:38:16 <shachaf> litb: Which you can do through do-notation, if you prefer.
12:38:22 <litb> yeah. i mean that
12:38:24 <byorgey> czakey: well, it's actually the same <- under the hood, but in list comprehensions it might be a little easier to understand at first
12:38:29 <czakey> I feel like blind man :D
12:38:34 <litb> so if i do my own Monad , i shoudl execute the code in my >>=
12:38:43 <shachaf> litb: Execute what code?
12:38:52 <litb> the code that belongs to a Monad
12:38:54 <byorgey> litb, shachaf: no, >>= does not "run" anything.
12:39:02 <shachaf> byorgey: I didn't say it did.
12:39:10 <litb> so, if i write a monad that should write into some file somthing, i would write the code for that in the >>=
12:39:11 <shachaf> Oh, hmm.
12:39:14 <litb> oh
12:39:16 <byorgey> shachaf> litb: The code will be run when you use (>>=).
12:39:17 * shachaf mis-phrased that.
12:39:24 <byorgey> ok =)
12:39:33 <litb> yeah, but where should i put that code, shachaf ?
12:39:44 <shachaf> litb: What code? :-)
12:39:54 <litb> the code which will be run
12:40:06 <shachaf> litb: Will be run when?
12:40:08 <byorgey> czakey: in list comprehensions, "x <- l" basically means "successivly choose every possible value x from the list l"
12:40:15 <litb> when i use >>=
12:40:22 <byorgey> czakey: (which is really just <- in the list monad =)
12:40:45 <shachaf> litb: The code that will be run when you use (>>=) will be run when you use (>>=). :-)
12:40:56 <litb> hm, confusing
12:40:56 <shachaf> Regardless of what you mean by "run".
12:41:02 <shachaf> litb: I
12:41:03 <czakey> humhum
12:41:08 <czakey> so that
12:41:10 <czakey> let perm (x:xs) = [x:v | x <- xs, v <- perm (xs)]
12:41:13 <shachaf> 'd suggest looking at some specific monads.
12:41:16 <czakey> possibly could work?
12:41:17 <shachaf> @src Maybe (>>=)
12:41:17 <lambdabot> (Just x) >>= k      = k x
12:41:17 <lambdabot> Nothing  >>= _      = Nothing
12:41:20 <shachaf> @src Maybe return
12:41:20 <lambdabot> return              = Just
12:41:50 <byorgey> czakey: well, it does something, but I don't think it computes permutations =)
12:42:34 <byorgey> czakey: one thing to note is that the x in (x:xs) and the x inside the list comprehension have nothing to do with each other
12:42:35 <czakey> yes I havent finished it yet
12:42:52 <byorgey> the x inside the list comprehension hides the one in the argument
12:43:06 <czakey> hm
12:43:31 <czakey> ...first day with Haskell
12:43:35 <czakey> can be little scary
12:43:37 <czakey> :D
12:43:48 <byorgey> czakey: oh! you're doing very well then =)
12:44:08 <litb> so, i write a Logger instance of Monad, which log stuff to some file. and in a do i do this: { x<- getLine; y<- (logger x); } which is supposed to log the value of x
12:44:17 <shachaf> czakey: Don't worry, you'll get used to it (being scary). :-)
12:44:19 <litb> and the code with which the logger appends that line to a file
12:44:29 <litb> where should i write that? that is what i don't know :/
12:44:30 <czakey> thanks, but I'm afraid not so well
12:44:51 <czakey> I'll be happy if I finally write that perm ;d
12:44:51 <shachaf> litb: You could look at Writer.
12:45:07 <byorgey> litb: that doesn't really make sense.  I echo shachaf's suggestion to start from the beginning and look at some simple monads to see how they work.
12:45:44 <byorgey> czakey: I think you should try writing a function allInsertions which works like this:
12:46:00 <ac> > [ (x,y) | x <- [0..4], y <- [0..3] ]
12:46:03 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
12:46:05 <ac> oops
12:46:09 <gwern> @go NewBinary
12:46:10 <lambdabot> http://www.newbinary.com/
12:46:10 <lambdabot> Title: NewBinary Design
12:46:12 <byorgey> allInsertions 4 [1,2,3] ----> [[4,1,2,3], [1,4,2,3], [1,2,4,3], [1,2,3,4]]
12:46:13 <ac> roconnor: this is what I wanted: mRead s = case reads s of { (a, _):_ -> Just a; [] -> Nothing }
12:46:14 <shachaf> litb: I'd suggest reimplementing some simple monads like Reader/Writer/State.
12:46:29 <litb> ok, i will go with that one
12:46:30 <shachaf> litb: That really helped me with understanding how things worked.
12:46:47 * gwern doesn't think that's where NewBinary is :)
12:46:48 <shachaf> litb: (But still look at Maybe/[]/Id first, probably; they're simpler.)
12:46:58 <gwern> anyone know if there's a NewBinary repo and if there is where?
12:47:09 <byorgey> litb: also, stare at the types of return and (>>=) until you're sure they make sense to you, then stare some more =)
12:47:35 <Botje> once it leaks out that monads are easy, the underground monad tutorial scene is doomed!
12:47:37 <byorgey> czakey: once you get allInsertions working I think you'll be able to use it to help you write perms.
12:47:49 <gwern> http://www.n-heptane.com/nhlab/repos/NewBinary/ <-- yes! hurray for Google's understanding of code
12:47:50 <lambdabot> Title: Index of /nhlab/repos/NewBinary
12:47:52 <czakey> hm
12:48:02 <czakey> yes
12:48:14 <gwern> (and thanks to searchpath.org, whoever you are)
12:48:38 <shachaf> And also join/fmap/return.
12:48:42 <ac> Botje: I do not think some monads are easy (at least not for me). Any function that uses the list monad confuses me
12:49:28 <shachaf> Which is arguably a simpler way to implement some monads.
12:49:39 <byorgey> yes.  join/fmap/return are underappreciated as a way to understanding monads, IMO.
12:50:15 <Botje> ac: the monads i've used so far have been pretty accessible
12:50:29 <Botje> but then i haven't done much exotic monad code yet :)
12:50:31 <shachaf> @instances Monad
12:50:32 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:51:22 <byorgey> monads are easier to understand than they seem at first, but harder to understand than people who already understand them try to make them out to be. =)
12:51:36 <Botje> yeah
12:51:37 <kaol> hmm... if I am to package a haskell library for GHC and Debian and include a -prof package, it's going to need -prof packages of all its dependencies too, right?
12:51:46 <Botje> once the switch flips you're like "what was that all about?"
12:51:48 <LoganCapaldo> I find the list monad somewhat confusing when you are looking at it written in monadic style (eg w/ do-notation or >>=).  find it helps if I concentrate on >>= being (flip) concatMap
12:52:15 <LoganCapaldo> *I find
12:52:29 <Saizan> kaol: yes
12:53:38 <ac> @hoogle a -> b -> m a
12:53:39 <lambdabot> Prelude.const :: a -> b -> a
12:53:39 <lambdabot> Prelude.seq :: a -> b -> b
12:53:39 <lambdabot> GHC.Conc.par :: a -> b -> b
12:53:40 <kaol> arjanoosting: I'll file a wishlist bug on haxml then (hope you won't mind)
12:54:00 <ac> @hoogle (Monad m) => a -> b -> m a
12:54:01 <lambdabot> Prelude.const :: a -> b -> a
12:54:01 <lambdabot> Prelude.seq :: a -> b -> b
12:54:01 <lambdabot> GHC.Conc.par :: a -> b -> b
12:54:16 <Saizan> list monad with do-notation is simple, it's less obvious what the monadic combinators do without looking at their code
12:54:28 <shachaf> @@ (@google newbinary _darcs) -- How I'd search for it, possibly.
12:54:34 <lambdabot>  http://www.n-heptane.com/nhlab/repos/NewBinary/_darcs/
12:54:34 <lambdabot>  Title: Index of /nhlab/repos/NewBinary/_darcs
12:54:34 <lambdabot>  -- How I'd search for it, possibly.
12:55:02 <shachaf> LoganCapaldo: That's the join/fmap/return way of looking at things.
12:56:57 <LoganCapaldo> shachaf: I don't think that's the issue, just that it's easy to loose track of what's going on when there's that extra layer of genericness
12:57:13 <byorgey> yup, for lists, join = concat, fmap = map, return = (:[])
12:57:17 <byorgey> nice and simple! =)
12:57:26 <shachaf> LoganCapaldo: concat/map/(:[])? :-)
12:58:35 <LoganCapaldo> I mean whether you think in terms of fmpa/join/return or >>=/return the "problem" IME is it's one more layer to think about
12:58:44 <shachaf> class (Applicative m) => Monad m where (>>=) :: m a -> (a -> m b) -> m b; m >>= f = join (fmap f m); join :: m (m a) -> m a; join m = m >>= id
12:59:19 <shachaf> LoganCapaldo: Where's the layer?
12:59:24 <shachaf> fmap should be called map.
13:00:09 <LoganCapaldo> the layer is that join :: (Monad m) => m (m a) -> m a and concat :: [[a]] -> [a]
13:00:37 <Tac-Tics> Why are there so many regex libraries for haskell?
13:00:44 <shachaf> LoganCapaldo: join :: [[a]] -> [a].
13:00:58 <LoganCapaldo> yes
13:01:11 <shachaf> LoganCapaldo: Just forget about monads for a bit. :-)
13:01:13 <ac> > join ["foo","bar","baz"]
13:01:15 <lambdabot>  "foobarbaz"
13:01:18 <LoganCapaldo> but you see join, you go "Hey this is monadic code, ok which monad is this? Oh it's the list ok..."
13:01:20 <ac> what's the point of concat?
13:01:30 <Saizan> shachaf: but if you think of the code in terms of Monad, rather than List you lose track of what's happening quite easily since every value you use is multiple values instead
13:01:32 <shachaf> ac: People like LoganCapaldo. :-)
13:01:35 <LoganCapaldo> you see concat you go "Oh I'm concating lists"
13:01:38 <byorgey> LoganCapaldo: I understand what you mean. =)
13:01:52 <ac> and what's the point of map when there's fmap?
13:02:17 <Saizan> ac: the same :)
13:02:25 <shachaf> And what's the point of (.) when there's fmap?
13:02:38 * shachaf thinks (.) = fmap may be a little overdone.
13:02:38 <Saizan> well . is nicer to type
13:02:51 <ac> That doesn't answer my question. I really don't see why there's a concat or a map
13:02:51 <shachaf> But I have no problem with join instead of concat.
13:03:07 <ac> Is it for more concise type errors when you get things wrong?
13:03:23 <byorgey> at some level I still think it's useful to have specialized versions of more general things around
13:03:32 <Saizan> yes, for beginners who don't understand typeclasses yet
13:03:39 <TSC> It lets you teach people basic haskell without introducing monads immediately
13:03:40 <byorgey> otherwise when people learn the language and they want to use lists, you'd have to explain monads to them first... and so on
13:03:48 <LoganCapaldo> the more ways to declare my intent the better
13:03:55 <byorgey> that's another reason.
13:03:58 <idnar> :t fmap
13:03:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:04:01 <idnar> :t (.)
13:04:02 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:04:20 <byorgey> ac: nothing prevents you from using 'join' every time you want to concatenate lists. =)
13:04:35 <Saizan> i like (.) to be only for functions, it'd be a bit bad if every . i read could be of an arbitrary functor..
13:04:45 <ac> byorgey: I think I will... it's shorter to type and it's a better name in my opinion
13:04:54 <shachaf> Saizan: Yes, it could be slightly confusing (sadly).
13:05:08 <shachaf> Though it does at least stay associative.
13:05:24 <byorgey> Saizan: not just Functors!  arbitrary Categories =)
13:05:53 <shachaf> Yes, Control.Category defines (.) now, doesn't it?
13:06:01 <Saizan> byorgey: ah, that's generalizing in the other way :)
13:07:07 <Saizan> ?type (>>>)
13:07:08 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
13:07:30 <idnar> @type Control.Category.(.)
13:07:31 <lambdabot> Couldn't find qualified module.
13:07:41 <shachaf> lambdabot is still using 6.6... :-(
13:07:44 <byorgey> shachaf: yes, although it's not in the libraries yet, and may not be for a while
13:07:56 <byorgey> shachaf: it's not even on hackage yet, actually =(
13:07:59 <shachaf> byorgey: It isn't?
13:08:07 <ac> why does 'join (Just (Just (Just 3)))' produce 'Just (Just 3)' but 'join ["foo","bar","baz"]' produce "foobarbaz"?
13:08:10 <idnar> my 6.8.2 doesn't hae it either
13:08:14 <shachaf> Oh, right.
13:08:25 * shachaf has been running darcs for too long now.
13:08:31 <shachaf> @ty Just (Just (Just 3))
13:08:32 <lambdabot> forall t. (Num t) => Maybe (Maybe (Maybe t))
13:08:42 <shachaf> @ty ["foo","var","baz"]
13:08:42 <lambdabot> [[Char]]
13:08:50 <byorgey> shachaf: is it in darcs?
13:08:51 <shachaf> Remember type String = [Char]
13:08:57 <shachaf> byorgey: It's in my GHC.
13:09:23 <shachaf> byorgey: And has been for some time.
13:09:34 <byorgey> interesting
13:09:34 <idnar> @join [[["foo"]], [["bar"]], [["baz"]]]
13:09:34 <lambdabot> Not enough privileges
13:09:36 <idnar> > join [[["foo"]], [["bar"]], [["baz"]]]
13:09:37 <lambdabot>  [["foo"],["bar"],["baz"]]
13:09:37 <shachaf> (Which breaks the arrows package... :-( )
13:09:46 <byorgey> indeed =(
13:10:02 <byorgey> maybe there are multiple versions of Control.Category floating around...
13:10:21 <shachaf> byorgey: Yes, this isn't exactly the same as another one I've seen.
13:10:29 <byorgey> I was using a category package that includes Data.FRef with TH deriving for records
13:10:39 <shachaf> (The one which had FRefs.)
13:10:40 <shachaf> Yes.
13:10:42 <byorgey> right.
13:11:30 <byorgey> rey_: what should mod-shift-tab do? cycle backwards?
13:11:37 <byorgey> argh! sorry, mischan =(
13:14:53 <litb> (\x -> Char.isSpace x == False)
13:14:56 <basvdijk> Hello, I've another question about ScopedTypeVariables but now a more serious one: The followinf code on hpaste gives a GHC panic! Anyone know why:
13:14:59 <hpaste>  basvdijk pasted "(the 'impossible' happened" at http://hpaste.org/4953
13:15:00 <litb> is there a better way to negate that?
13:15:27 <ac> > ["foo","bar","baz"] >>= id
13:15:28 <ddarius> @src not
13:15:28 <lambdabot> not True   =  False
13:15:28 <lambdabot> not False  =  True
13:15:45 <lambdabot>  "foobarbaz"
13:15:45 <basvdijk> If I comment the type of 'unify' it compiles just fine
13:15:48 <byorgey> litb: not . Char.isSpace
13:16:04 <litb> ah, sure. that magic dot. thxx
13:16:12 <ricky_clarkson> @check not . Char.isSpace == (== False) . Char.isSpace
13:16:13 <lambdabot>   add an instance declaration for (Eq (Char -> Bool))     In the expression: ...
13:16:14 <ddarius> @src (.)
13:16:14 <lambdabot> (.) f g x = f (g x)
13:16:19 <ac> ok, the type signatures make sense I suppose, I just don't see how that works
13:16:30 <ricky_clarkson> @check (not . Char.isSpace) == ((== False) . Char.isSpace)
13:16:30 <lambdabot>   add an instance declaration for (Eq (Char -> Bool))     In the expression: ...
13:17:04 <byorgey> ricky_clarkson: you need to compare values, not functions
13:17:09 <ricky_clarkson> @check \x -> (not . Char.isSpace) x == ((== False) . Char.isSpace) x
13:17:09 <lambdabot>  OK, passed 500 tests.
13:17:16 <byorgey> like that =)
13:17:23 <ac> I mean the type signature makes sense if [a] is a monadic type, but where is the iteration coming from in "(>>=id)"?
13:17:25 <litb> o.O
13:17:33 <ricky_clarkson> Does QuickCheck have a pointfree way to do stuff like that?
13:17:40 <shachaf> ac: Iteration?
13:17:45 <ricky_clarkson> Hmm, that's Haskell, not QC.
13:17:55 <byorgey> ac: it's the list monad's version of >>= .
13:17:56 <ricky_clarkson> @pl \x -> (not . Char.isSpace) x == ((== False) . Char.isSpace) x
13:17:57 <lambdabot> ap ((==) . not . Char . isSpace) ((False ==) . Char . isSpace)
13:17:59 <ricky_clarkson> pah
13:18:04 <byorgey> @src [] (>>=)
13:18:04 <lambdabot> m >>= k     = foldr ((++) . k) [] m
13:18:07 <shachaf> l >>= id = concatMap id xs = concat (map id xs) = concat xs
13:18:32 <ac> byorgey: ah, different definitions for different monads
13:18:39 <byorgey> ac: yup
13:18:47 <ac> that's a lot simpler than I thought it was
13:19:02 <byorgey> =D
13:19:15 <ac> that's why this doesn't work:
13:19:18 <ac> @src (>>=)
13:19:18 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
13:19:24 <byorgey> ac: exactly.
13:19:25 <shachaf> @check liftM2 (==) (not . Char.isSpace) ((==False) . Char.isSpace)
13:19:25 <lambdabot>  OK, passed 500 tests.
13:19:51 <byorgey> ac: Monad is a type class; for a particular type to be an instance of Monad it must provide definitions for >>= and return
13:19:51 <shachaf> ac: m >>= f = join (fmap f m)
13:20:03 <shachaf> ac: In this case, it's concat (map f m).
13:21:15 <ac> Time for me to read the monad laws
13:23:21 <ddarius> fmap id = id, fmap (f . g) = fmap f . fmap g, fmap join . join = join . join, fmap return . join = return . join = id
13:23:27 <ac> @redo (m >>= f) >>= g = m >>= (\x -> f x >>= g)
13:23:28 <lambdabot>  Parse error at "=" (column 17)
13:23:38 <daf> 1. Thou shalt not harm referential transparency, or through inaction...
13:24:07 <ac> @redo m >>= (\x -> f x >>= g)
13:24:07 <lambdabot> do { a <- m; (\ x -> do { a <- f x; g a}) a}
13:24:31 <ac> @redo (m >>= f) >>= g
13:24:32 <lambdabot> do { a <- (do { a <- m; f a}); g a}
13:24:50 <byorgey> well, @redo isn't the greatest =/
13:25:50 <monochrom> @remember daf 1. Thou shalt not harm referential transparency, or through inaction...
13:25:50 <lambdabot> Okay.
13:29:08 <czakey> ok
13:29:12 <czakey> about allInsertions
13:29:34 <czakey> I know how to add something to any place in list
13:29:50 <czakey> but dunno how to do all insertions
13:30:18 <czakey> lack of knowlege how to do recursion
13:31:58 <byorgey> czakey: think of it this way.  you have something to insert, call it z, and a list (x:xs) with first element x and remainder xs.
13:32:26 <byorgey> czakey: if you can (recursively) insert z at every place into xs, how can you use that to build a solution to allInsertions z (x:xs) ?
13:34:01 <czakey> [x] + allInsertons (xs)
13:34:10 <czakey> and
13:34:26 <czakey> [z] ++ xs
13:35:03 <byorgey> czakey: yup, that's the right idea.
13:35:07 <byorgey> czakey: now, two things:
13:35:23 <byorgey> czakey: first, I think you meant allInsertions z xs there in that first line, right?
13:35:44 <czakey> yeah
13:36:07 <byorgey> now, allInsertions z xs actually returns a list of lists.
13:36:09 <czakey> [x] ++ allInsertons z (xs)
13:36:16 <byorgey> so you want to prepend x to the beginning of each one.
13:36:26 <czakey> yep
13:36:58 <czakey> exacly that what I'm trying to do ;]
13:37:09 <byorgey> [x] ++ allInsertions z xs doesn't do that, it's like saying [1] ++ [[2,3,4], [5,6,7], [8,9]]
13:37:31 <czakey> yes
13:37:32 <byorgey> which just gives you [[1], [2,3,4], ...]
13:37:32 <czakey> ains v (x:xs) = [x] ++ ains v (xs)
13:37:37 <czakey> isnt right ;>
13:37:48 <byorgey> when what you want is [[1,2,3,4], [1,5,6,7], and so on
13:37:59 <byorgey> czakey: do you know about the 'map' function?
13:38:16 <czakey> by now
13:38:19 <dons> ?users
13:38:19 <lambdabot> Maximum users seen in #haskell: 444, currently: 434 (97.7%), active: 23 (5.3%)
13:38:30 <czakey> only that that I probably need it ;>
13:38:54 <czakey> ok -> manual
13:40:15 <byorgey> czakey: "ok -> manual" meaning... you're going to go read documentation now ??
13:40:24 <czakey> yes :)
13:40:27 <byorgey> ok =)
13:46:33 <litb> i'm just looking at the Computation class of yaht, and i'm slowly getting used to it :)
13:50:08 <czakey> so
13:50:25 <czakey> on every element (read: list) of that list of lists
13:50:41 <czakey> i must use concatenation with [x]
13:52:24 <shachaf> czakey: [x] ++ l = x : l, by the way.
13:53:13 <czakey> slowy
13:53:22 <czakey> I have the idea
13:53:41 <czakey> now I'm trying to compile it :P
13:57:48 <TomMD> @ask ndm Catch on hackage isn't updated to work with the package split and on darcs isn't cabalized.  If I were to write a patch 1) which code base should be the base? 2) Would you accept it?
13:57:48 <lambdabot> Consider it noted.
13:58:36 <czakey> so
13:58:45 <czakey> map produces output type
13:58:53 <czakey> like element of list
13:59:06 <czakey> so if I have list of lists
13:59:20 <czakey> it shoud return list, right?
13:59:33 <monochrom> :t map id
13:59:33 <lambdabot> forall a. [a] -> [a]
13:59:40 <TomMD> > map (map (+1)) [ [1,2,3], [55,33,563] ]
13:59:41 <lambdabot>  [[2,3,4],[56,34,564]]
14:00:07 <TomMD> > map (head) [ [1,2,3], [55,33,563] ]
14:00:08 <czakey> > map length [[1],[1,2],[1,2,3]]
14:00:08 <lambdabot>  [1,55]
14:00:08 <lambdabot>  [1,2,3]
14:00:30 <monochrom> I don't understand "map produces output type. like element of list".  It's probably wrong.
14:00:46 <shachaf> czakey: map f [a,b,c,...] = [f a, f b, f c, ...]
14:00:53 <czakey> ok
14:01:06 <czakey> so whats wrong in this:
14:01:06 <shachaf> @ty map
14:01:07 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:01:10 <czakey> ains v (x:xs) = map length (ains v xs)
14:01:36 <shachaf> czakey: What is it supposed to do?
14:01:43 <shachaf> czakey: (Do you have a [] case too?)
14:01:46 <monochrom> It can't be type-checked.
14:01:59 <idnar> :t ains v (x:xs) = map length (ains v xs)
14:01:59 <lambdabot> parse error on input `='
14:02:00 <czakey> no, I dont
14:02:02 <monochrom> Maybe it can be.
14:02:11 <idnar> :t let ains v (x:xs) = map length (ains v xs) in ains
14:02:12 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Int'
14:02:12 <lambdabot>       Expected type: [[a]]
14:02:12 <lambdabot>       Inferred type: [Int]
14:02:28 <czakey> it suppose to count length of lists produced by ains v xs
14:02:35 <czakey> (I think)
14:02:37 <monochrom> "What is it supposed to do?" is the right question. For all programming.
14:02:43 <idnar> map length (...) is going to be of type [Int]
14:02:58 <idnar> so (ains v xs) should be of type [Int] too, then
14:03:15 <idnar> but then you're trying to map length over [Int], and you can't take length of an Int
14:03:20 <czakey> I want concagenation there
14:03:20 <shachaf> czakey: Can you write the type of ains?
14:03:32 <shachaf> czakey: (The type you want for it?)
14:03:32 <czakey> as byorgey says
14:03:51 <czakey> something like
14:04:02 <czakey> ains v (x:xs) = map (x ++) (ains v xs)
14:04:16 <czakey> I know thats totally wrong
14:04:21 <shachaf> czakey: I'm not sure what you're trying to do.
14:04:26 <shachaf> czakey: But you still need a [] case.
14:04:27 <byorgey> czakey: almost!  I think you want (x:) instead of (x ++)
14:04:29 <czakey> (sorry, first day... ;))
14:04:42 <byorgey> czakey: : is for adding a single element onto the front of a list
14:04:46 <Cale> czakey: What should ains v [1,2,3] result in?
14:04:50 <byorgey> czakey: ++ is for concatenating two lists
14:04:50 <shachaf> Yes, the ([x] ++) you had before would also have worked.
14:04:51 <czakey> ha
14:05:23 <byorgey> Cale: czakey is trying to write an 'allInsertions' function that inserts an element at every possible location in another list
14:05:32 <byorgey> Cale: ultimately in order to write a permutations function
14:05:42 <Cale> ah, okay
14:05:46 <shachaf> We had this one yesterday. :-)
14:06:08 <monochrom> So the "length" there is a red herring?
14:06:23 <czakey> something like that
14:06:23 <FunctorSalad> that one's best done with arrays I think...
14:06:32 <FunctorSalad> (random permutation)
14:06:33 <czakey> I was trying to find out
14:06:39 <shachaf> FunctorSalad: Random?
14:06:39 <monochrom> No, not random today.
14:06:46 <idnar> > intersperse 50 [1..5]
14:06:47 <shachaf> FunctorSalad: czakey wants all permutations.
14:06:49 <lambdabot>  [1,50,2,50,3,50,4,50,5]
14:06:49 <ac> czakey: sorry, I can't help but (don't look at this if you don't want to) say...
14:06:52 <ac> allIns i ls = map (\(l,r) -> l ++ [i] ++ r) $ zip (inits ls) (tails ls)
14:06:55 <czakey> why map "doesn't work"
14:06:55 <czakey> :D
14:06:59 <FunctorSalad> shachaf: oh, apparently you want all perms
14:07:06 <shachaf> FunctorSalad: Me?
14:07:17 <shachaf> I don't want any of them. :-)
14:07:19 <FunctorSalad> no, czakey. nevermind :)
14:07:22 <idnar> @src intersperse
14:07:23 <lambdabot> intersperse _   []     = []
14:07:23 <lambdabot> intersperse _   [x]    = [x]
14:07:23 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
14:07:23 * shachaf has all the permutations he needs.
14:07:56 <czakey> but I want ALL the perms :d
14:08:02 <czakey> ok
14:08:07 <ac> idnar: that's not what mine does
14:08:11 <czakey> ains v (x:xs) = map (x:) (ains v xs)
14:08:16 <czakey> < ains v (x:xs) = map (x:) (ains v xs)
14:08:19 <czakey> blach
14:08:23 <czakey> > ains v (x:xs) = map (x:) (ains v xs)
14:08:24 <lambdabot>  Parse error at "=" (column 15)
14:08:34 <idnar> > let allIns i ls = map (\(l,r) -> l ++ [i] ++ r) $ zip (inits ls) (tails ls) in allIns 10 [1..5]
14:08:35 <lambdabot>  [[10,1,2,3,4,5],[1,10,2,3,4,5],[1,2,10,3,4,5],[1,2,3,10,4,5],[1,2,3,4,10,5],...
14:08:40 <idnar> *oh*
14:08:40 <czakey> > let ains v (x:xs) = map (x:) (ains v xs)
14:08:40 <lambdabot>  Parse error at end of input
14:08:47 <ac> czakey: the ">" is only for expressions, not definitions
14:09:13 <ac> idnar: I _think_ that's what czakey is trying to write
14:09:16 <byorgey> czakey: ok, but when we talked about it before you told me there was one other list which should be produced
14:09:41 <czakey> yep
14:10:00 <byorgey> czakey: ok, so combine that with what you have
14:10:14 <byorgey> czakey: you will also need a base case -- what happens if you do ains on an empty list?
14:10:18 <czakey> yes, sir!
14:10:19 <czakey> :)
14:10:22 <byorgey> =)
14:10:44 <ac> but I think the point he's trying to accomplish is writing it in a recursive fashion
14:11:07 * shachaf hates these disconnections.
14:11:45 <litb> lol
14:12:00 <ac> > let allIns i ls = zipWith (\x y -> x ++ [i] ++ y) (inits ls) (tails ls) in 10 [1..5]
14:12:01 <lambdabot>   add an instance declaration for (Num ([t] -> a))
14:12:01 <lambdabot>     In the expression:
14:12:01 <lambdabot>    ...
14:12:48 <litb> i'm sorry i forgot how to repeat something N times
14:12:57 <ac> litb: replicate
14:12:57 <litb> repeatN or so
14:13:05 <monochrom> replicate 10 True
14:13:06 <byorgey> using inits/tails and ++ like that isn't the most efficient way to do it
14:13:11 <ac> > replicate 5 'a'
14:13:12 <lambdabot>  "aaaaa"
14:13:19 <litb> ah, thank you
14:13:31 <ac> byorgey: I didn't think so, but it's nice and concise
14:13:44 <ac> can't see why my second definition doesn't work
14:14:28 <byorgey> ac: your definition was fine, but there might be a slight problem with '10 [1..5]' ;)
14:14:41 <ac> > let allIns i ls = zipWith (\x y -> x ++ [i] ++ y) (inits ls) (tails ls) in allIns 10 [1..5]
14:14:47 <lambdabot>  [[10,1,2,3,4,5],[1,10,2,3,4,5],[1,2,10,3,4,5],[1,2,3,10,4,5],[1,2,3,4,10,5],...
14:15:42 <basvdijk> I just reported a GHC bug regarding lexically-scoped type variables. Anyone seen this before? http://hackage.haskell.org/trac/ghc/ticket/2037
14:15:43 <lambdabot> Title: #2037 (Inner type declaration causes GHC panic) - GHC - Trac
14:17:14 <ac> czakey: I'd like to see your more efficient version
14:17:30 <czakey> hey
14:17:46 <czakey> this is my first day with Haskell
14:17:53 <dons> welcome, czakey !
14:18:12 <ac> czakey: cool. Why should that stop you?
14:18:14 <czakey> no combat and complexity fights
14:18:16 <czakey> :P
14:18:25 * Botje attaches some brightly colored balloons to czakey 
14:18:36 <Botje> you can take them off when you write your first monad tutorial :)
14:18:42 <dons> gwern++ http://www.daniweb.com/forums/thread104257.html
14:18:44 <litb> hello czakey
14:19:07 <byorgey> czakey: don't worry, with the route you are going you will end up with a more efficient version anyway =)
14:19:17 <ac> czakey: yeah, that's what I meant
14:19:37 <czakey> better stick a green leaf somewhere on my laptop :>
14:20:00 <czakey> or "Haskell noob" sticker ;]
14:20:09 <shachaf> czakey: Why?
14:20:30 <czakey> just for fun
14:20:33 <czakey> I mean...
14:20:33 <shachaf> czakey: There'll never be a sudden transition when you should take it off.
14:20:48 <Cale> gwern: Tell him to come visit us on irc (give the server address and channel) :)
14:21:06 <monochrom> I still keep my noob sticker.
14:21:24 <czakey> noob stickers are good
14:21:41 <czakey> when you are doing stupid things
14:21:49 <czakey> noone shout at you
14:22:11 <ac> ok, I want to generate arbitrary images and then produce a PNG file with the gd library. With HOpenGL and gtk2hs I just write a function of type "(Int -> Int -> Color) -> Texture", but I can't see how to do this with gd
14:22:35 <shachaf> czakey: Has anyone shouted at you in here?
14:22:37 <czakey> but only shakes head with "what-a-noob" face
14:22:38 <czakey> ;>
14:22:42 <czakey> no, no
14:23:24 <czakey> you guys (some girls?) are very friendly :)
14:23:40 <monochrom> I don't think of noob to mean I know little. I think of noob to mean I have infinitely many things to learn.
14:24:29 <ac> actually, the type is more like "Pixbuf -> (Int -> Int -> Colour) -> IO ()"
14:24:33 <czakey> you learn al your life...
14:24:34 <czakey> ok
14:24:39 <Cale> gwern: uh, n/m, I'll do it :)
14:24:43 <czakey> I have to write it
14:24:54 <czakey> before tommorow comes
14:25:07 <czakey> (only 40 minutes left ;f)
14:26:06 <shachaf> Cale: gwern did.
14:26:11 <shachaf> "Secondly, I don't know much about Daniweb, but I think I can guarantee that the #haskell IRC channel on FreeNode and the haskell-cafe mailing list (http://www.haskell.org/mailman/listinfo/haskell-cafe) are the best places online to ask for haskell help, bar none."
14:26:12 <lambdabot> Title: Haskell-Cafe Info Page
14:26:21 <Cale> ah, okay :)
14:26:26 <kmcallister> ac, this isn't an answer to your question but i often find the easiest way to output images is to print a PPM and then convert it externally
14:26:33 <Cale> (somehow I missed that :)
14:27:09 * shachaf has made no further progress in his gwern-tracking project.
14:27:31 <ac> kmcallister: the problem is I want to use the gd library to do a couple operations
14:27:32 <shachaf> gwern: You would write "list2 == []"?
14:27:33 <Cale> gwern: xs == [] is worse than null xs, due to the type constraints
14:27:40 <shachaf> gwern: That gives an Eq constraint.
14:27:45 <shachaf> What Cale said. :-)
14:28:03 <shachaf> (Of course, pattern matching is even better in this case.)
14:28:08 <ac> kmcallister: I'm pretty sure I can deconstruct the Image type in to a Ptr and ForignPtr, but there's no specification for the binary data
14:28:21 <ac> basically what I want is a pure Haskell image library
14:28:35 <ac> or better bindings
14:29:12 <dubblego> is it true that people in academia submit papers for topics that have already advanced beyond the given paper and that it often appears like the author of that paper is unaware of these advancements?
14:31:01 <ac> anybody have any guess on how hard it would be to write a PNG library?
14:31:05 <monochrom> Submit, yes.
14:31:10 <JanglerNPL> :t flatten
14:31:11 <lambdabot> forall a. Tree a -> [a]
14:31:21 <znutar> Papua New Guinea libraries?
14:31:32 <dubblego> monochrom, and have them published?
14:31:34 <ac> znutar: Portable Network Graphics (image format)
14:31:58 <monochrom> If the reviewers of the journal are good, they will catch it.
14:32:53 * ac goes to read the PNG spec
14:33:45 <davidL> ac: I was going to until I realized there is the gd packages in hackage
14:34:04 <davidL> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gd-3000.4.0
14:34:05 <lambdabot> http://tinyurl.com/2d3x5c
14:34:27 <czakey> I have now
14:34:29 <czakey> ains s [] = []
14:34:36 <czakey> ains v (x:xs) = map (x:) (ains v xs))
14:34:41 <byorgey> czakey: I don't think that base case is right
14:35:02 <czakey> and knowlege of that I must have v:xs
14:35:18 <ac> davidL: right, but I don't see how to compose a pixel array in to a gd image and vice versa. I need to do both
14:35:21 <czakey> hm
14:35:31 <byorgey> czakey: and I think you want v:x:xs actually
14:36:02 <czakey> a yes
14:36:12 <tom`> hi all
14:36:17 <gwern> shachaf, cale: bah! I find xs == [] to be incredibly clear; null xs looks like an imperative operation to me
14:36:22 <ac> PNG spec is only about 60 to 70 pages it looks like :-P
14:36:22 <czakey> but base isn't right you say?
14:36:27 <czakey> hmm
14:36:32 <dons> gwern: hehe. but null doesn't have an Eq constraint
14:36:40 <dons> gwern: so its more generic for library code
14:36:42 <czakey> allInsert to []
14:36:57 <czakey> allInsert v []
14:37:02 <davidL> ac: can't you just write bindings for libpng?
14:37:05 <czakey> shall return [v]
14:37:10 <czakey> ?
14:37:14 <byorgey> czakey: yup
14:37:15 <dons> more graphics lib bindings would be awesome
14:37:24 <dons> uniform strict bytestring access to libpng et al..
14:37:25 <ac> davidL: well I've never written bindings :-P. I think it would be cool for it to be pure Haskell too
14:37:32 <tom`> got a question, very basic but anyway... I've got a data type defined like this: "data Side = Black | White" and I want to export the names Side, Black and White from my module so other modules can see that there is a data type of type "Side" and can also distinguish between it's values
14:37:36 <idnar> :t null
14:37:38 <lambdabot> forall a. [a] -> Bool
14:37:58 <dons> tom`: ok. module M (Side(..)) where ...
14:38:00 <czakey> ok
14:38:02 <byorgey> czakey: well, actually, [[v]].  remember, ains must return a list of lists
14:38:03 <idnar> :t \xs -> xs == []
14:38:03 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
14:38:05 <dons> tom`: will export the type, and its constructors
14:38:05 <tom`> but when i try to export them like this "module CheckesBoard(Side, Black, White) where" it says that Black And WHite arne't allow
14:38:08 <idnar> ah, of course
14:38:09 <czakey> so last problem
14:38:17 <tom`> dons: thanks! that's it
14:38:17 <ac> dons: are you saying it would be awesome to have bindings to C's libpng, or to have a pure Haskell libpng?
14:38:22 <davidL> ac: I think it would be easier to learn FFI than it would be to recreate libpng :)
14:38:31 <czakey> how to merge
14:38:33 <gwern> dons: how often do you get two lists which are in Num but not Eq?
14:38:36 <tom`> dons: knew it was something simple like that :p
14:38:38 <dons> ac, i think bindings to C would be the most efficient in terms of developer effort
14:38:41 <ac> davidL: you're no doubt correct
14:38:43 <czakey> "merge"
14:38:43 <czakey> ains v (x:xs) = map (x:) (ains v xs))
14:38:46 <desegnis> tom`: also, module M (Side (Black, White)) if you want to be explicit
14:38:49 <dons> ac, unless we have some .png experts here who can do significantly better
14:38:53 <czakey> with v:x:xs
14:39:08 <ac> dons: are there any known problems with libpng?
14:39:15 <pejo> dons, isn't libpng written by someone involved in the standardization?
14:39:22 <dons> i'm not familiar with it enough to know.
14:39:30 <dons> pejo: if so, that would be a good plus in favour of binding to it
14:39:46 <ac> yeah, then as the standard evolves, it wouldn't be as much work
14:39:47 <ac> to maintain it
14:39:56 <dons> we *don't* have to duplicate complex, C libraries unless there's a compelling reason (e.g. better safety, parallelism or some such)
14:40:03 <byorgey> czakey: there's no 'merge' that has to happen, you just want to add the list (v:x:xs) to your list of lists produced by the map
14:40:09 <dons> a lot of the time its going to make more sense to let someone else maintain the C lib, and do the ffi binding
14:40:26 <dons> pcre is another example -- a high perf regex clone in pure haskell makes no sense -- we gain nothing
14:40:34 <TomMD> It just has a larger chance of harming portability.
14:40:38 <czakey> thats what I meant
14:41:10 <ac> huh. OK, time to jump in to c2hs and whatnot I guess
14:41:10 <davidL> ac: I can't seem to find the code where I started creating png bindings :(
14:41:30 <czakey> right now it looks like that
14:41:43 <hpaste>  czakey pasted "(no title)" at http://hpaste.org/4955
14:41:44 <ac> davidL: if you could I'd definitely like to have it
14:42:04 <czakey> and produces only one list in list
14:42:22 * araujo thought like this when he applied to SoC ... but the Haskell community thought the other way
14:42:24 <czakey> wonder why ;]
14:43:02 <ac> where's a good introduction/tutorial for writing C bindings?
14:43:38 <byorgey> czakey: you still have to add the v:x:xs
14:43:44 <dons> ac,there's some here, http://haskell.org/haskellwiki/Blog_articles/FFI
14:43:54 <dons> ac, and i can direct you to examplles.
14:44:02 <byorgey> czakey: since it's recursive, small things like that can have a big effect on the result =)
14:44:15 <shachaf> gwern: Does (null? xs)?
14:44:20 <dons> also, consider basing it on a strict bytestring type  in haskell (so we can ensure no performance loss marshalling data)
14:44:43 <gwern> shachaf: ?
14:44:45 <ac> dons: ok, thanks
14:44:47 <gwern> :t null?
14:44:48 <lambdabot> parse error (possibly incorrect indentation)
14:45:05 <shachaf> gwern: Scheme.
14:45:10 <czakey> hm
14:45:13 <czakey> like that:
14:45:14 <shachaf> gwern: Does that look like an imperative action to you?
14:45:15 <hpaste>  czakey pasted "ains" at http://hpaste.org/4956
14:45:21 <araujo> Let's see if we can get good bindings for popular libs this year
14:45:24 <czakey> ?
14:45:36 <gwern> shachaf: dunno. not very familiar with scheme
14:45:51 <shachaf> gwern: Anyway, it has a procedure called NULL?.
14:45:56 <ac> ARHG, sometimes I hate dpkg. I uninstalled ghc6, but libghc6-cabal-dev refuses to die, and it depends on ghc6, so dpkg is broken until ghc6 is reinstalled
14:46:00 <byorgey> czakey: does it work?
14:46:08 <czakey> huh
14:46:16 <shachaf> gwern: Does the question mark make it look less imperative?
14:46:20 <czakey> yes :D
14:46:29 <byorgey> czakey: =D
14:46:43 <czakey> 23:42
14:46:52 <czakey> so Ive made it :D
14:46:56 <czakey> thanks a lot
14:47:00 <byorgey> czakey: note that if you're just adding one thing to a list, it's more efficient to put it at the beginning using :
14:47:04 <monochrom> Hrm, if libghc6-cabal-dev depends on ghc6, how could you uninstall ghc6?
14:47:17 <czakey> now rest of perm :p
14:47:18 <byorgey> i.e. (v:x:xs) : map ...  instead of map ... ++ [v:x:xs]
14:47:20 <ac> monochrom: it's broken
14:47:27 <gwern> shachaf: makes it look odd, since I keep wondering what operator ? is
14:47:31 <resiak> araujo: what libs are you after?
14:47:32 <ac> monochrom: through an apt operation that uninstalled both
14:47:39 <shapr> Hey, anyone in Boston want to show up at the Asgard tonight at 6:30pm to meet me and some other folks?
14:47:44 <shachaf> gwern: Not if you were using Scheme... No infix. :-)
14:47:45 * gwern thinks that you shouldn't be allowed to write 1+1 but 1 + 1 in Haskell
14:48:06 <czakey> hmm
14:48:12 <araujo> resiak, pcre is one of them
14:48:12 <czakey> but (v:x:xs)
14:48:18 <czakey> is a list
14:48:23 <byorgey> czakey: yup
14:48:34 <shachaf> czakey: Also look at @-patterns at one point, possibly.
14:48:35 <czakey> so I can concatenate lists with :
14:48:36 <czakey> ?
14:48:40 <byorgey> czakey: no.
14:48:49 <byorgey> czakey: remember, ains is producing a list of lists
14:48:52 <shachaf> czakey: You can add an element to a list.
14:48:59 <LoganCapaldo> shapr: I'd so woulda gone with more advance warning. I'm not in boston, but what's a few states between people who vaguely know each other irc? :)
14:49:04 <shachaf> > 1 : [1,2,3]
14:49:05 <shapr> haha
14:49:07 <lambdabot>  [1,1,2,3]
14:49:09 <LoganCapaldo> *on irc
14:49:11 <byorgey> czakey: so (v:x:xs) : map ... means, add the list v:x:xs as the first element of a list of lists
14:49:13 <shapr> LoganCapaldo: Fortunately, there will be more opportunities.
14:49:16 <czakey> ah right
14:49:23 <ac> czakey: cool
14:49:26 <czakey> list
14:49:32 <byorgey> > [1,2,3] : [[4,5],[6,7],[8,9]]
14:49:32 <lambdabot>  [[1,2,3],[4,5],[6,7],[8,9]]
14:49:36 <czakey> but element of other list
14:49:48 <ac> czakey: you can put it on one line like so, and it's about the same length as my less efficient version: ains v l = case l of x:xs -> map (x:) (ains v xs) ++ [v:x:xs]; [] -> [[v]]
14:49:48 <czakey> so can be concatenated by :
14:50:00 <czakey> oukey
14:50:19 <byorgey> personally, I don't think writing it as a case makes it any easier to read
14:50:34 <ac> byorgey: neither do I of course. That wasn't my point
14:50:42 * shachaf would be glad to meet fellow #haskellers. :-)
14:50:59 <byorgey> ac: oh, I see. =)
14:51:02 <shachaf> But there are none in the immediate area.
14:52:02 <czakey> yes, everyone enjoys when program has one line ;]
14:52:31 <czakey> but sometimes you have to read and understand it
14:52:47 <arjanoosting> koal: no problem :-)
14:53:01 <czakey> now
14:53:02 <ac> czakey: It's good to know case, as sometimes it actually does make something more clear
14:53:20 <ac> I think you can alway use let in place of case though
14:53:28 <czakey> hm case like case in C?
14:53:40 <monochrom> case better than case in C
14:53:58 <dons> its the basic pattern matching syntax
14:54:00 <czakey> I could guess it :d
14:54:14 <dons> case e of Pat -> alt1 ; ... Pat_n -> altn
14:54:18 <ac> czakey: just look at my one line version of ains. It's just another way of writing a pattern match
14:54:37 <gwern> I rarely see Maybe stuff without a case expression nearby
14:55:23 <czakey> ok
14:55:25 <czakey> and now
14:55:34 <czakey> how to use that ains
14:55:44 <czakey> to do perm?
14:55:51 <czakey> because ains
14:55:58 <czakey> extends list by one
14:56:08 <czakey> ha
14:56:18 <czakey> mayby now the delete is usefull?
14:56:30 <ac> anybody know how to wrestle dpkg in to blowing away a package manually? I just want to remove it from the package database, and I'll delete the files myself
14:56:34 <czakey> @src delete
14:56:34 <lambdabot> delete = deleteBy (==)
14:56:42 <czakey> @src deleteBy
14:56:43 <lambdabot> Source not found. You speak an infinite deal of nothing
14:57:16 <byorgey> czakey: I don't think you need to use delete
14:57:34 <TomMD> @src Data.Map.lookup
14:57:35 <lambdabot> Source not found. Where did you learn to type?
14:57:35 <byorgey> czakey: do it by cases.  perms [] = ?  perms (x:xs) = ?
14:57:58 <czakey> ac: dpkg --purge?
14:58:05 <shachaf> ac: Will you delete the ghc-pkg entry too?
14:58:10 <czakey> I dont know what exacly you mean
14:58:11 <czakey> ?
14:58:13 <Cale> purge deletes everything, including the config files
14:58:23 <ac> shachaf: the ghc it corresponds to is gone
14:58:43 <czakey> ah
14:58:45 <ac> czakey: that just deletes ALL the files
14:59:00 <czakey> so you want only to delete package from base?
14:59:07 <ac> czakey: that's what I _don't_ want dpkg to do, because it errors when I try
14:59:12 <Cale> Well, you could just hand-edit the database.
14:59:20 <idnar> ac: what sort of error?
14:59:25 <czakey> yes
14:59:25 <idnar> ac: there's always --force-all ;)
14:59:33 <ac> idnar: already tried that. That fails too
14:59:35 <czakey> editing database is an idea
14:59:39 <idnar> ac: wow
14:59:43 <Cale> But it's probably better to ask in #debian or #ubuntu
14:59:43 <czakey> but not quite good ;>
15:00:08 <czakey> ac: what error?
15:00:13 <ac> well, it is a GHC package that's failing
15:00:18 <ac> the error is: /usr/share/doc/libghc6-cabal-dev/unregister.sh: 3: /usr/bin/ghc-pkg: not found
15:00:25 <czakey> hee
15:00:29 <ac> and I tried to fix it by reinstalling ghc6, but no luck
15:00:34 <czakey> edit line 3
15:00:46 <czakey> of .postrm
15:00:53 <czakey> comment it out
15:01:01 <czakey> and then remove ;)
15:01:03 <ac> czakey: where's the file?
15:01:18 <czakey> whats the package name?
15:01:25 <ac> libghc6-cabal-dev
15:02:23 <ac> the problem it seems is it removes ghc6 first
15:02:27 <czakey> and mabt
15:02:29 <czakey>  /var/lib/dpkg/info/libghc6-cabal-dev.postrm
15:02:33 <czakey> and mabt
15:02:37 <czakey> maby
15:02:45 <idnar> --force-all ought to ignore a failing postrm
15:02:47 <czakey>  /var/lib/dpkg/info/libghc6-cabal-dev.prerm
15:03:14 <czakey> idnar: not it wont afaik
15:03:31 <czakey> no*
15:03:43 <idnar> czakey: hmm.
15:03:44 <shachaf> You could make a fake ghc-pkg binary.
15:04:33 <idnar> I thought it did, guess I was wrong
15:04:49 <ac> czakey: huh, can't find the line there. shachaf: good idea
15:05:16 <czakey> ac: the line contains "unregister.sh"
15:05:45 <czakey> I told you wrong that whas line 3...
15:06:02 <czakey> line 3 in /usr/share/doc/libghc6-cabal-dev/unregister.sh
15:06:05 <czakey> is failing
15:06:21 <czakey> but postrm or prerm is invoking that
15:06:50 <ac> czakey: ah right. shachaf suggestion worked beautifully though ;)
15:06:51 <czakey> [23:53:53] < byorgey> czakey: do it by cases.  perms [] = ?  perms (x:xs) = ?
15:07:01 <czakey> perms [] = []
15:07:08 <czakey> quite easy
15:07:19 <sarehu> no
15:07:23 <sarehu> perms [] = [[]]
15:07:26 <czakey> ac: congrats ;)
15:07:37 <FunctorSalad> if you don't care about performance, just take the cartesian product and filter by (x == nub x) ;)
15:07:53 <czakey> lol
15:08:07 <czakey> hah
15:08:18 <czakey> I can generate ALL lists
15:08:45 <czakey> and filter it by all numbers from orginal
15:08:46 <czakey> :P
15:08:55 <sarehu> > (\xs -> filter (\x -> x == nub x) (replicateM (length xs) xs)) [1,2,3]
15:08:56 <lambdabot>  [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
15:09:00 <sarehu> neato
15:09:13 <czakey> wow
15:09:49 <czakey> but I dont understand \ and all lambda-stuff yet
15:10:06 <czakey> and probably
15:10:06 <shachaf> czakey: \x -> y -- A function which gets an argument called x and returns y.
15:10:17 <shachaf> > (\x -> x + 1) 5
15:10:17 <lambdabot>  6
15:10:17 <czakey> that thing is quite slow
15:10:37 <shachaf> czakey: When you say Â«f x = x + 1Â», you really mean Â«f = \x -> x + 1Â».
15:10:50 <FunctorSalad> actually it's not *that* much worse, by stirling n! ~~ sqrt(2Ïn) n^n e^-n
15:10:57 <czakey> ah so
15:11:04 <FunctorSalad> which is just as astronomical as n^n ;)
15:11:31 <czakey> \f x -> y
15:11:34 <czakey> means
15:11:44 <czakey> f(x)=y
15:11:45 <czakey> ?
15:11:46 <FunctorSalad> sorry, the sqrt should be in the denominator
15:11:50 <czakey> thats all?
15:11:52 <Cale> czakey: not quite
15:12:18 <Cale> czakey: \x -> x + 1 is the function which adds 1 to its parameter
15:12:28 <Cale> > (\x -> x + 1) 5
15:12:28 <lambdabot>  6
15:12:49 <shachaf> "f x = x + 1" really means "f = \x -> x + 1"
15:12:53 <Cale> f = \x -> y means something like "the function f such that for all x, f(x) = y"
15:12:55 <sarehu> > let f = (\x -> x + 1)   in    f 5
15:12:56 <lambdabot>  6
15:12:57 <FunctorSalad> > replicateM 3 [0,1] -- I wonder how that worked
15:12:59 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
15:13:21 <Cale> FunctorSalad: do you not see it?
15:13:45 <FunctorSalad> Cale: I seem to remember this function is polymorphic for any monad
15:13:49 <FunctorSalad> @type replicateM
15:13:49 <Cale> yes
15:13:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
15:13:57 <shachaf> @src replicateM
15:13:57 <lambdabot> replicateM n x = sequence (replicate n x)
15:14:02 <Cale> replicateM n = sequence . replicate n
15:14:19 <FunctorSalad> @src replicate
15:14:19 <lambdabot> replicate n x = take n (repeat x)
15:14:31 <Cale> > replicate 3 [0,1]
15:14:32 <lambdabot>  [[0,1],[0,1],[0,1]]
15:14:36 <shachaf> > sequence [[1,2],[3,4]]
15:14:37 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
15:14:46 <Cale> Now, sequence will pick an element from each of those lists in all possible ways
15:14:59 <FunctorSalad> oh, didn't know sequence. mixed it up with seq
15:15:17 <shachaf> FunctorSalad: sequence does this in the [].
15:15:24 <shachaf> @src sequence
15:15:25 <lambdabot> sequence ms = foldr k (return []) ms
15:15:25 <lambdabot>     where
15:15:25 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
15:15:27 <FunctorSalad> so I wondered how replicateM could figure out that we want a product ;)
15:15:33 <Cale> The sequence function takes a list of actions and produces an action which runs each in turn, producing a list of the results.
15:15:35 <newsham> .
15:15:39 <shachaf> sequence = foldr (liftM2 (:)) (return [])
15:15:59 <Cale> In the list monad, running an action (which is just a list) is just picking an element from the list in each possible way.
15:16:03 <sarehu> > replicateM 8 ['0','1'] !! (ord 'A')
15:16:04 <shachaf> newsham: â
15:16:06 <lambdabot>  "01000001"
15:16:26 <Cale> sarehu: cute :)
15:17:07 <czakey> @src replicateM
15:17:07 <lambdabot> replicateM n x = sequence (replicate n x)
15:17:26 <Cale> oh, that source for sequence above is unnecessarily confusing
15:17:31 <Cale> sequence [] = return []
15:17:44 <czakey> @src return
15:17:45 <lambdabot> Source not found. My brain just exploded
15:17:46 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:18:02 <ac> @src [] return
15:18:03 <lambdabot> return x    = [x]
15:18:29 <ac> czakey: as mentioned above, return is a member of the Monad type class and has a different definition for each monad
15:18:31 <Cale> return takes a value and produces the action which "does nothing" and returns that value.
15:18:55 <czakey> got it
15:18:58 <FunctorSalad> Cale: but that is specialised for the list monad now?
15:19:12 <Cale> FunctorSalad: in which case? My code for sequence is generic.
15:19:16 <byorgey> czakey: if it makes sense, cool, but not something you really need to worry about on your first day of Haskell =)
15:19:31 <Cale> Another way to write sequence is:
15:19:42 <FunctorSalad> > sequence 3 [Just 1, Just 2, Just 3]
15:19:43 <lambdabot>        add an instance declaration for (Num [[Maybe t] -> a])
15:19:43 <Cale> sequence = foldr (liftM2 (:)) (return [])
15:19:47 <czakey> byorgey: I'm aware od that ;)
15:20:08 <czakey> its late for me
15:20:21 <byorgey> > sequence [Just 1, Just 2, Just 3]
15:20:21 <Cale> If you view foldr f z as replacing each cons in a list with f and the nil at the end with z
15:20:22 <lambdabot>  Just [1,2,3]
15:20:26 <czakey> so I need to learn case now ;d
15:20:34 <Cale> then sequence can be seen as replacing list structure with program structure
15:20:35 <byorgey> > sequence [Just 1, Nothing, Just 3]
15:20:35 <lambdabot>  Nothing
15:21:23 <czakey> @src case
15:21:24 <lambdabot> Source not found. Do you think like you type?
15:21:36 <czakey> heheh
15:21:39 <Cale> Instead of just consing together the computations into the list, you build a computation which will cons their results into a list.
15:22:13 <Cale> That is, that's the difference between id = foldr (:) [], and sequence = foldr (liftM2 (:)) (return [])
15:22:16 <byorgey> czakey: case isn't a function, it's built-in syntax
15:22:29 <LoganCapaldo> Cale: you're sucha  cons artist
15:22:35 <Cale> heh
15:22:59 <byorgey> Cale: you always have such good ways to think about things =)
15:23:10 <FunctorSalad> Cale: ok, think I'm beginning to get it. thanks.
15:23:34 <byorgey> I'm quite comforatble with sequence but had never thought of it in quite that way before.
15:23:59 <FunctorSalad> sequence list conses the elements together with the cons that is obtained by applying the morphism part of the monad to plain cons?
15:24:03 <dons> initial hpc code coverage results for my pcre-light binding, http://galois.com/~dons/tmp/hpc_index.html
15:24:08 <dons> code coverage rocks!
15:24:12 <FunctorSalad> sorry, "list" was supposed to be a variable there ;)
15:24:26 <dons> see e.g. http://galois.com/~dons/tmp/Text.Regex.PCRE.Light.hs.html (branches that are never taken)
15:24:46 <Cale> FunctorSalad: well, liftM2 isn't exactly the same as liftM, but roughly, yeah
15:25:25 <FunctorSalad> liftM2 = curry $ liftM $ uncurry?
15:25:42 <czakey> byorgey: perm l = case l of x:xs <something>; [] -> [[]]
15:25:49 <czakey> sth like that?
15:25:56 <Cale> FunctorSalad: You can view liftM2 as sort of a generalisation of T on morphisms to 2-parameter things, as you can view return as a generalisation of T on morphisms to 0-parameter things
15:26:31 <FunctorSalad> @type liftM2 (:)
15:26:36 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1] -> m [a1]
15:26:38 <czakey> so now to use ains to generate permutations
15:26:40 <czakey> ;)
15:26:41 <Cale> We perhaps should have liftM0 = return :)
15:26:54 <byorgey> czakey: oh, you don't need case; just say perm [] = [[]]  and perm (x:xs) = ...
15:27:07 <FunctorSalad> @type curry $ liftM $ uncurry (:)
15:27:12 <byorgey> czakey: but yes, you could use case like that
15:27:18 <czakey> ah
15:27:21 <czakey> you mean
15:27:23 <lambdabot> forall a a1. (Monad ((,) a)) => a -> (a1, [a1]) -> (a, [a1])
15:27:35 <czakey> to use case inside of perm
15:27:45 <czakey> to invoke ains
15:27:49 <czakey> hmm
15:28:10 <LoganCapaldo> @type ap
15:28:24 <byorgey> czakey: I don't think you need to use a case at all.  did someone say that?
15:28:39 <czakey> erm... you?
15:28:57 <czakey> [23:53:33] < byorgey> czakey: I don't think you need to use delete
15:29:00 <czakey> [23:53:53] < byorgey> czakey: do it by cases.  perms [] = ?  perms (x:xs) = ?
15:29:07 <FunctorSalad> @type (liftM curry) $ liftM $ uncurry (:)
15:29:15 <byorgey> czakey: oh, heh, sorry.  I just meant that perms should have two cases: perms [] = ...  and perms (x:xs) = ...
15:29:16 <czakey> or this is misunderstanding
15:29:21 <czakey> ah :D
15:29:26 <byorgey> not that you need a case expression
15:29:38 <byorgey> anyway, I'm off to celebrate my birthday with my family =D
15:29:40 <czakey> its to late for me right now ;>
15:29:43 <byorgey> czakey: good luck finishing perms!
15:29:45 <LoganCapaldo> > 1 -- you ok buddy?
15:29:47 <Nafai> byorgey: Happy Birthday!
15:29:56 <byorgey> Nafai: thanks!  it was Thursday
15:30:03 <Nafai> It's my wife's birthday today
15:30:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:30:11 <lambdabot> forall a b a1. ((a, b) -> (a1, [a1])) -> a -> b -> [a1]
15:30:14 <lambdabot>  1
15:30:22 <czakey> Happy Birthdat byorgey!
15:30:37 <Cale> FunctorSalad: You can't write liftM2 with an arbitrary functor.
15:30:39 <czakey> and thanks for your help
15:31:12 <Cale> (that is, just liftM won't do it)
15:31:22 <LoganCapaldo> @type let liftM2 f a b = liftM f a `ap` b in liftM2
15:31:22 <lambdabot> forall a1 a b (m :: * -> *). (Monad m) => (a1 -> a -> b) -> m a1 -> m a -> m b
15:31:24 <FunctorSalad> Cale: seems like it needs to preserve products
15:32:51 <Cale> That seems reasonable. An applicative functor will certainly do, but it implies a whole lot more as well.
15:33:00 <Cale> :t (<*>)
15:33:00 <LoganCapaldo> @type let ap f a = f >>= \f' -> a >>= \a' -> return (f' a') in ap
15:33:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:33:01 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:33:08 <Cale> haha
15:34:22 <Cale> :t let liftA2 f x y = pure f <*> x <*> y in liftA2
15:34:23 <lambdabot>     Ambiguous occurrence `pure'
15:34:23 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
15:34:23 <lambdabot>                           or `pure', imported from Control.Arrow
15:34:29 <Cale> D'oh!
15:34:38 <Cale> :t let liftA2 f x y = Control.Applicative.pure f <*> x <*> y in liftA2
15:34:39 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
15:35:44 * FunctorSalad ponders how to get the morphism from (m a),(m b) to m (a,b)
15:36:08 <Cale> In terms of which primitives?
15:36:42 <Cale> liftM2' (x,y) = do v <- x; w <- y; return (v,w)
15:36:45 <kmcallister> :t uncurry $ liftM2 (,)
15:36:46 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
15:37:43 <Cale> :t \(x,y) -> pure (,) <*> x <*> y
15:37:44 <lambdabot>     Ambiguous occurrence `pure'
15:37:44 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
15:37:44 <lambdabot>                           or `pure', imported from Control.Arrow
15:37:52 <Cale> :t \(x,y) -> Control.Applicative.pure (,) <*> x <*> y
15:37:53 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => (f a, f a1) -> f (a, a1)
15:38:05 <FunctorSalad> Cale: given a monad m
15:38:16 <FunctorSalad> not familiar with Applicatives yet
15:38:21 <LoganCapaldo> Control.Arrow should drop pure, it already has arr after all :)
15:38:36 <Cale> yeah, at least it should be hidden by lambdabot
15:39:56 <FunctorSalad> @type \x -> (>>= \y -> return (x,y)) -- almost there ;)
15:39:57 <lambdabot> forall (m :: * -> *) a t. (Monad m) => t -> m a -> m (t, a)
15:40:24 <FunctorSalad> but the final bind doesn't do what I think it should
15:40:34 <FunctorSalad> (turning the t into m t)
15:40:40 <Cale> FunctorSalad: An applicative functor is a functor F together with a natural transformation 1 -> F, and a map which does: F(B^A) -> (FB)^(FA) that's natural in B and A.
15:40:48 <FunctorSalad> @type (>>= \x -> (>>= \y -> return (x,y)))
15:40:48 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (m a1 -> a) -> m a1 -> m (a, a1)
15:41:14 <LoganCapaldo> @type \(x,y) -> x >>= \x' -> y >>= \y' -> return (x', y')
15:41:15 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (m a, m a1) -> m (a, a1)
15:41:36 <Cale> Er, satisfying some obvious axioms :)
15:42:21 <Cale> Probably easier just to look at the Haskell definition, as I haven't seen it come up in category theory.
15:42:30 <Cale> class Functor f => Applicative f where
15:42:35 <Cale>    pure :: a -> f a
15:42:44 <Cale>    (<*>) :: f (a -> b) -> f a -> f b
15:43:01 <dons> yay, found a bug (and with HUnit!)
15:43:32 <Cale> with laws:
15:43:36 <Cale> pure id <*> v = v
15:43:38 <Cale> pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
15:43:49 <Cale> pure f <*> pure x = pure (f x)
15:44:16 <Cale> u <*> pure x = pure ($ y) <*> u
15:44:33 <Cale> also, fmap f x = pure f <*> x
15:45:26 <Cale> Basically, the idea is that you have a meaningfully overloaded notion of function application.
15:45:39 <Cale> Which is represented by (<*>)
15:45:56 <FunctorSalad> @karma+ Cale
15:45:56 <lambdabot> Cale's karma raised to 58.
15:45:58 <Sizur> shouldn't data default to newtype implementaiton if the declaration can be translated into newtype?
15:46:08 <LoganCapaldo> instance Monad f => Applicative f where pure = return ;  (<*>) = ap -- btw, I think
15:47:09 <Sizur> dons: did you have a chance to break i18n a little?
15:47:14 <FunctorSalad> @src ap
15:47:15 <lambdabot> ap = liftM2 id
15:48:12 <ddarius> :t uncurry (liftM2 (,))
15:48:13 <dons> Sizur: not yet.
15:48:13 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
15:48:40 <FunctorSalad> Cale: hard to understand all the laws just now but at least I've seen it now, thanks :)
15:49:00 <resiak> Cale: what do you do when you're not providing lucid explanations of Haskell types and idioms? :)
15:49:58 <resiak> (or rather, do you have time to do anything else?)
15:49:59 <ddarius> @google "strong functor"
15:50:00 <lambdabot> http://home.imf.au.dk/kock/MSMCC.pdf
15:50:45 <FunctorSalad> @type ((,) <*>)
15:50:46 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
15:52:28 <FunctorSalad> ddarius: I was trying to write liftM2 in terms of a function (m a1, m a2) -> m (a1, a2) so that's now allowed ;)
15:53:45 <ddarius> FunctorSalad: Yes, but then you just look at the definition of liftM2.
15:53:53 <Sizur> :t \a b-> (,) <$> a <*> b
15:53:55 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a -> f a1 -> f (a, a1)
15:54:29 <FunctorSalad> @type <$>
15:54:31 <lambdabot> parse error on input `<$>'
15:54:35 <FunctorSalad> @type (<$>)
15:54:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:54:45 <ddarius> (incidentally, preservation of products means more than F(AxB) ~ FAxFB)
15:55:29 <FunctorSalad> it means that F(AxB) is the ("a") product of FA and FB
15:55:35 <FunctorSalad> or not?
15:55:39 <Sizur> @pl \(a,b) -> (,) <$> a <*> b
15:55:39 <lambdabot> uncurry ((<*>) . ((,) <$>))
15:55:59 <Sizur> :t uncurry ((<*>) . ((,) <$>))
15:55:59 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
15:58:57 <Sizur> one shouldn't need to use metaprogramming when the only change for accepting any tuple by a function is the number of commas in the tuple constructor
15:59:37 <sarehu_> what?
15:59:43 <gwern> how do you load into ghci a file using cpp?
15:59:47 <Sizur> it's a recurring theme, like zipWith functions
16:00:18 <sarehu_> what does zipWith have to do with metaprogramming?
16:00:39 <Sizur> it would if you'd want to have only one function
16:00:43 <centrinia> sarehu, there is zipWith, zipWith3, zipWith4, zipWith5, and zipWith6
16:00:43 <gwern> sarehu_: writing zipWithN is apparently fairly hard
16:00:54 <litb> could some1 have a look at this?
16:00:56 <litb> http://rafb.net/p/46Z9jv68.html
16:00:56 <lambdabot> Title: Nopaste - No description
16:01:08 <litb> oh sorry, i will repaste it to hpaste
16:01:32 <hpaste>  litb pasted "without do" at http://hpaste.org/4957
16:01:47 <litb> i tried todo that without using do, but i fail
16:02:18 <nburlett> hey all, anyone know how to get darcs-sent patches out of Mail.app on Leopard?
16:02:20 <Sizur> gwern: you need to have a LANGUAGE CPP pragma
16:02:31 <Sizur> in the file
16:03:01 <shachaf> TH makes it easier, doesn't it?
16:03:03 <gwern> Sizur: like '{-# LANGUAGE CPP #-}'?
16:03:03 <FunctorSalad> @type (<*>) . ((Control.Applicative.pure (,)) <*>)
16:03:04 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
16:03:10 <Sizur> gwern: yeah
16:03:15 <FunctorSalad> \o/
16:03:36 <gwern> Sizur: doesn't work in ghci
16:03:47 <gwern> lexical error at the first #include...
16:03:49 <Cale> resiak: Not a whole lot -- I read mathematics books and work on problems and write small programs and play games. At some point in the not-too-distant future I'll go to graduate school. :)
16:04:24 <LoganCapaldo> nburlett: unless the format has changed (again) each mail should be in an .emlx file so you can probbaly get somewhere with that (find the right mime section or what have you)
16:04:25 <gwern> @where IOExts
16:04:25 <lambdabot> I know nothing about ioexts.
16:04:29 <Sizur> FunctorSalad: pure f <*> == f <$>
16:04:33 <gwern> go IOExts
16:04:37 <gwern> @go IOExts
16:04:39 <lambdabot> http://www.informatik.uni-kiel.de/~pakcs/lib/CDOC/IOExts.html
16:04:39 <lambdabot> Title: Module IOExts
16:04:56 <shachaf> @ty (<*>) . fmap (,)
16:04:56 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
16:05:13 <Sizur> gwern: try then with a flag in OPTIONS pragma
16:05:17 <shachaf> nburlett: Out of?
16:05:23 <shachaf> nburlett: Aren't they just attachments?
16:05:30 <gwern> that page defines IOExts.curry, not IOExts... hm
16:05:34 <gwern> what *is* IOExts?
16:05:56 <nburlett> shachaf: they don't show up as attachments, they show up inline
16:06:19 <shachaf> nburlett: Hmm. Just copy them, then?
16:06:24 <shachaf> nburlett: That doesn't work?
16:06:33 <nburlett> shachaf: I can't quite figure out what to copy
16:06:45 <gwern> Sizur: {-# OPTIONS -cpp #-} ? nope
16:07:18 <Sizur> gwern: alright, then pass -cpp when you invoke ghci?
16:07:20 <shachaf> Hmm, it's not separated?
16:07:48 <nburlett> shachaf: no, it just shows up. Do you know what the first line of an attachment is supposed to be?
16:07:53 * Sizur is not an not expert
16:07:58 <Sizur> lol
16:08:14 <resiak> Cale: heh!
16:08:21 <shachaf> nburlett: Looking at a .dpatch, it has "\nNew patches:\n[" ++ ... ++ "something that looks like a sha1sum".
16:08:22 <gwern> ok, if I set -cpp in .ghci, and start a new ghci, then it works.
16:08:23 <gwern> annoying
16:08:55 <shachaf> nburlett: But maybe you can try #darcs.
16:09:04 <litb> oh, it was because i missed parens
16:09:34 <nburlett> shachaf: yeah, I'm also there :->
16:10:33 <nburlett> shachaf: thanks for trying... gotta run
16:10:41 <shachaf> nburlett: Doesn't that format work?
16:10:59 <shachaf> nburlett: (Newline, "New patches:", newline, "[", and ends with a sha1sum?)
16:13:24 <BMeph> ?src ap ((,)a)
16:13:24 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
16:13:37 <BMeph> ?src ap []
16:13:37 <lambdabot> Source not found. My pet ferret can type better than you!
16:13:47 <BMeph> ?src [] ap
16:13:48 <lambdabot> Source not found. You untyped fool!
16:14:08 <centrinia> ?src src
16:14:09 <lambdabot> Source not found. Wrong!  You cheating scum!
16:14:22 <litb> hm, u know how i can use command line parameters?
16:14:27 <BMeph> ?help ?src
16:14:28 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:14:37 <BMeph> ?help src
16:14:37 <lambdabot> src <id>. Display the implementation of a standard function
16:14:49 <psi> :t getArgv
16:14:53 <BMeph> ?src ap
16:14:53 <lambdabot> ap = liftM2 id
16:14:55 <lambdabot> Not in scope: `getArgv'
16:14:58 <centrinia> So (src) is not standard.
16:15:35 <psi> :t getArgs
16:15:36 <lambdabot> Not in scope: `getArgs'
16:15:41 * psi gives up
16:15:44 <BMeph> centrinia: Nope, src is an LB plugin
16:16:13 <BMeph> :t System.Environment.getArgs
16:16:14 <lambdabot> IO [String]
16:16:32 <BMeph> psi: ^^  :)
16:17:01 <psi> thanks. litb: that's how you can get at them.
16:17:11 <Sizur> litb: use parenthesis between (>>=)
16:17:13 <litb> ah, thanks again :)
16:17:34 <Sizur> litb: btw, >>= \_ is the same as >>
16:17:49 <litb> in yaht i read that the IO monad doesn't support >>
16:17:59 <psi> uhm
16:18:00 <kmcallister> ?src putStrLn
16:18:01 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
16:18:03 <Sizur> it doesn't?
16:18:04 <kmcallister> ?src putStr
16:18:04 <lambdabot> putStr s  = hPutStr stdout s
16:18:12 <kmcallister> ?src hPutStr
16:18:12 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:18:18 <gwern> hm. suppose I run 'ghci -e "main" foo.hs
16:18:21 <Cale> litb: >> works in any monad at all
16:18:24 <idnar> @src (>>)
16:18:25 <lambdabot> m >> k      = m >>= \_ -> k
16:18:32 <idnar> it's defined purely in terms of >>=
16:18:37 <litb> oh
16:18:38 <Cale> litb: You might be interested in reading my articles about monads :)
16:18:46 <litb> it must have been the language barrier then
16:19:00 <gwern> hm. suppose I run 'ghci -e "main" foo.hs', and 'main' calls getArgs; how do I supply the args to getArgs?
16:19:04 <litb> Cale: the otherones in here already told me about you
16:19:11 <idnar> for some monads it might not make any sense, but the IO monad is one of the monads for which it does make sense
16:19:14 <litb> Cale: where can i find them?
16:19:16 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO -- here's a quick blurb just about the IO monad
16:19:18 <Sizur> litb: it's a must for any monad
16:19:33 <gwern> I can't go 'ghci foo.hs -e 'main' 100' because it thinks 100 is the name of a haskell file
16:19:35 <Cale> http://haskell.org/haskellwiki/Monads_as_computation -- this is for all monads, from a computation perspective
16:19:57 <Cale> http://haskell.org/haskellwiki/Monads_as_containers -- this is again about all monads, but from a different perspective
16:20:18 <ddarius> FunctorSalad: For a functor to preserve products, it must also preserve the limiting cone.
16:20:30 <Sizur> gwern: :set args bla ble blu
16:21:06 <Cale> litb: And of course, let me know if you have any questions or comments regarding them.
16:21:19 <gwern> you can do :set on the command line?
16:21:23 <LoganCapaldo> gwern: I don't think you can use -e in conjunction with --interactive.
16:21:28 <litb> yeah, thanks in advance :)
16:21:43 <Sizur> gwern: if you are using ghci, why would you?
16:21:53 <gwern> for a script
16:21:59 <gwern> to run on darcs record
16:22:11 <gwern> the maintainer doesn't have a really sensible test suite, admittedly
16:22:13 <LoganCapaldo> I think you might be looking for runhaskell / runghc
16:22:38 <FunctorSalad> ddarius: oh, you're right
16:22:48 <ramza3> there is 'take' to get items from a list; how can I take part of a list based on index elements (2  through 3) for example
16:22:49 <Sizur> gwern: i think i'm missing something
16:23:13 <Cale> ramza3: Well, you can combine drop and take
16:24:14 <gwern> ah, this works: 'runghc -XPatternSignatures SpeedTestBytes.hs 1000'
16:24:21 <gwern> runghc was what I was looking for after all I guess
16:25:14 <LoganCapaldo> gwern: you can put -XPatternSignatures in the file itself with {-# PatternSignatures #-}
16:25:22 <centrinia> between i j = (drop i) . (take (j-i))
16:25:47 <LoganCapaldo> err
16:25:50 <centrinia> Err.
16:25:54 <centrinia> I should reverse them. :p
16:25:55 <LoganCapaldo> LANGUAGE PatternSignatures
16:25:59 <BMeph> let slice a b list = (drop (b-a) . take a) list
16:26:05 <gwern> LoganCapaldo: there you go :)
16:26:08 <gwern> and yes, i know
16:26:20 <Cale> BMeph: still backwards
16:27:31 <centrinia> : let slice i j = (take (j-i)) . (drop i) in slice 2 3 [1..6]
16:27:31 <Cale> You could do something like  drop a . take b
16:27:32 <BMeph> let slice a b list = (take (b-a) . drop a) list
16:28:12 <Cale> then there's no arithmetic to perform
16:29:08 <centrinia> I think you should still do the drop first.
16:29:41 <centrinia> Or maybe not. Hmm.
16:29:42 <BMeph> slice = (. take) . (return) . drop -- conal would be proud ;)
16:30:06 <Sizur> @pl slice i j = (take (j-i)) . (drop i)
16:30:07 <lambdabot> slice = ap (flip . (((.) . take) .) . subtract) drop
16:30:47 <BMeph> >let slice = (. take) . (.) . drop in slice 2 4 [1..7]
16:30:50 <Sizur> :t (.take).return.drop
16:30:52 <lambdabot> forall a. Int -> Int -> [a] -> [a]
16:30:54 <BMeph> > let slice = (. take) . (.) . drop in slice 2 4 [1..7]
16:30:56 <lambdabot>  [3,4]
16:31:15 <centrinia> Woah.
16:32:38 <Sizur> let slice = ap (flip . (((.) . take) .) . subtract) drop in slice 2 4 [1..7]
16:32:45 <Sizur> > let slice = ap (flip . (((.) . take) .) . subtract) drop in slice 2 4 [1..7]
16:32:46 <lambdabot>  [3,4]
16:33:36 <centrinia> > let fib = 0:1:zipWith fib (tail fib) in ((. take) . (.) . drop) 7 14 fib
16:33:37 <lambdabot>  Couldn't match expected type `[a]'
16:33:40 <BMeph> Cale's right - you shouldn't do extra arithmetic if you don't have to.
16:33:42 <Botje> @unpl (.take).return.drop
16:33:42 <lambdabot> (\ d j -> return (drop d) (take j))
16:33:47 <centrinia> > let fib = 0:1:zipWith fib (tail fib) in ((. take) . (.) . drop) 7 14 (fib :: Int)
16:33:48 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int'
16:33:59 <BMeph> Wait a minute, that's a tautology. :p
16:34:21 <centrinia> > let fib = 0:1:zipWith fib (tail fib) in ((. take) . (.) . drop) 7 14 (fib :: [Int])
16:34:21 <lambdabot>  Couldn't match expected type `[a]'
16:34:23 <BMeph> > let fib = 0:1:zipWith fib (tail fib) in ((. take) . (.) . drop) 7 14 (fib :: [Int])
16:34:24 <lambdabot>  Couldn't match expected type `[a]'
16:34:40 <centrinia> > let fib = 0:1:zipWith fib (tail fib) in ((. take) . (.) . drop :: Int -> Int -> [Int]) 7 14 (fib :: [Int])
16:34:40 <lambdabot>  Couldn't match expected type `[Int]'
16:34:53 <centrinia> > let fib = 0:1:zipWith fib (tail fib) in ((. take) . (.) . drop :: Int -> Int -> [Int] -> [Int]) 7 14 (fib :: [Int])
16:34:53 <lambdabot>  Couldn't match expected type `[a]'
16:34:55 <BMeph> > let fib = 0:1:zipWith fib (tail fib) in ((. take) . (.) . drop) 7 14 fib
16:34:56 <lambdabot>  Couldn't match expected type `[a]'
16:34:57 <centrinia> What? :(
16:35:11 <BMeph> > let fib = 0:1:zipWith (+) fib (tail fib) in ((. take) . (.) . drop) 7 14 fib
16:35:14 <lambdabot>  [13,21,34,55,89,144,233]
16:35:28 <centrinia> Oh. My bad. :">
16:35:47 <BMeph> centrinia: We forgot to tell zipWith the "With", i.e., what function to use on the lists, lol. ;)
16:36:18 <Sizur> @pl (\a b-> take b . drop a)
16:36:18 <lambdabot> flip ((.) . take) . drop
16:37:15 <dons> the first 100% tested FFI library interface? http://galois.com/~dons/tmp/hpc_index.html :)
16:37:27 * dons does happy 100% covered dance
16:38:02 <BMeph> Go dons! go dons! Go dons - go! go! :)
16:38:47 <dons> code's here, btw, http://code.haskell.org/~dons/code/pcre-light/tests/
16:38:48 <lambdabot> Title: Index of /~dons/code/pcre-light/tests
16:38:56 <dons> checking it builds on interresting machines would be useful
16:39:56 <dons> if you've never used hpc before, its worth looking at.
16:40:02 <dons> great for checking the quality of your tests
16:42:21 * Sizur is trying to grasp HSXML
16:42:31 <ac> what does c2hs do, and should I use it to make libpng bindings?
16:43:17 <dons> ac, so to do bindings to foreign libraries , there are 3 approaches:
16:43:23 <dons> manually write the foreign import statements
16:43:25 <dons> use hsc2hs
16:43:27 <dons> or use c2hs
16:43:37 <dons> they increaes in complexity, and what they do automatically
16:43:57 <ac> ok. I was wondering what hsc2hs did. Does c2hs use hsc2hs?
16:43:58 <dons> i tend to use hsc2hs for small things (like libpcre), and c2hs for much larger things (well, gtk2hs)
16:44:08 <dons> no. they're two different tools for generating bindings
16:44:35 <dons> this is a .hsc file, http://code.haskell.org/~dons/code/pcre-light/Text/Regex/PCRE/Light/Base.hsc
16:44:36 <lambdabot> http://tinyurl.com/2aqnsa
16:44:57 <dons> see , e.g. , the use of #{enum PCREConfig, to bind to #define'd constants in C
16:45:46 <ac> I assume c2hs will turn a c header file in to a .chs file
16:46:14 <gio123> if I have two regularexpresions R and Q I am interested to find such S1 and S2 that  R =< S1 and L(S1;S2) = L(Q). is such  S1 and S2  unique
16:46:30 <dons> ac, right, it parsers headers, and typechecks the ffi bindings
16:47:25 <ac> why not use c2hs as apposed to hsc2hs?
16:48:29 <dons> its more complex. much bigger tool. so for small jobs hsc2hs is a bit more agile (?)
16:48:35 <dons> it may be that c2hs has caught up, though
16:48:45 <dons> dcoutts is the c2hs expert. he could distinguish the two a bit more
16:49:26 <dubblego> ?type let breaks xs f = Data.Foldable.foldr (\a as -> case as of [] -> [[a]]; (b:bs) -> if f a == any f b then (a:b):bs else [a] : as) [] xs in breaks
16:49:27 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t a -> (a -> Bool) -> [[a]]
16:50:26 <ac> well I cabal installed c2hs, but cabal fails to install hsc2hs. So far my attempts to use c2hs have only produced "c2hs: does not exist"
16:50:30 <Cale> dons: watch out, those green bars are supposedly evil :)
16:51:46 <dons> Cale: oh?
16:52:20 <dubblego> how could I remove the [[a]] from that type signature? (MonadPlus m1, MonadPlus m2) => m1 (m2 a) perhaps?
16:53:09 <Cale> dons: I can't remember where I read that -- there was an article on reddit back a while ago which was complaining about this design of code coverage tools.
16:53:29 <dons> oh, interesting.
16:54:22 <ddarius> Cale: It depends on the depth of the coverage and how much stock the person using it puts in it.
16:54:43 <Cale> right :)
16:55:01 <ddarius> Cale: I think I remember that article, and it was complaining about, e.g. code coverage tools that just check that each function was called and such.
16:56:04 <dons> yeah, that's pretty pointless.
16:56:24 <dons> expression/branch level seems to be most useful. things that always false are very suspciious
16:56:43 <dons> i want to start displaying hpc stats on hackage this year some time
16:56:53 <dons> as another metric for the code quality
16:57:20 <dons> e.g. regex-pcre, the current lib, has no tests with it.
16:57:33 <dons> which is not good for an extra-lib :(
16:57:54 <ddarius> If I prove my code correct, do I need tests?
16:58:24 <dons> that would also suffice.
16:58:59 <dons> 100% coverage of the mapping from src to proof text would be required though :)
16:59:11 <dons> so i can check you didn't forget to prove a chunk of your src
16:59:30 <dons> so e.g. implement in Isabelle, and extract the library code. that would be ok.
17:01:34 <ac> what is a .hsc file?
17:02:26 <allbery_b> input to hsc2hs
17:02:38 <ac> ah ok. and a .chs file is input to c2hs
17:05:47 <ac> I was thinking a .chs file was input to GHC
17:08:15 <litb> hm, i don't like the underscores after mapM_ and sequence_ and so
17:08:19 <litb> they look ugly :)
17:08:50 <ddarius> litb: What would you suggest instead?
17:08:57 <r3m0t> apostrophes
17:09:27 <allbery_b> don't they represent the (virtual) \_ -> ...?
17:09:38 <ddarius> r3m0t: That doesn't convey the same sense to me and it conflicts with another convention.
17:09:47 <gwern> (only 80 Hackage packages left on my list. that's good)
17:09:53 <allbery_b> you could always use sequence and mapM and throw away the result; might be slower
17:09:55 <gwern> (progress is being made!)
17:10:00 <r3m0t> gwern: list?
17:10:22 <gwern> r3m0t: I made a list of Hackage packages I couldn't install through cabal install
17:10:36 <gwern> the list used to have like 110 entries; I've been busy
17:10:48 * gwern appreciates darcs send even more now
17:12:14 <ac> r3m0t: apostrophies are used to indicate a dependence on another variable, as in "let x' = x + 1". "mapM'" would just look weird
17:12:48 <r3m0t> ac: ok... not how I use them I guess :-)
17:13:28 <ac> r3m0t: It's a convention I like when I have no clue what to name a value that in other languages I would reassign over an existing variable
17:14:18 <r3m0t> I use it for a subsidiary function that could only be useful in the context of the main function
17:14:26 <ddarius> ac: Locally it's common to append a ' for a related variable, but at the top-level usually ' means a stricter version of another function.
17:15:15 <r3m0t> e.g. foldr f e = foldr' where foldr' [] = e, foldr' (x:xs) = f x $ foldr' xs
17:15:30 <r3m0t> or something very similar to that
17:15:33 <ac> ah I see
17:16:19 <r3m0t> which looks silly for the list which has only two constructors, but if I was folding over something with four constructors...
17:16:42 <litb> mapMNullary maybe
17:16:58 <litb> who knows
17:17:01 <ddarius> litb: That doesn't make sense.  It's not nullary
17:17:11 <litb> i mean, the return is
17:17:23 <litb> but it's confusing ^^
17:18:47 <litb> mapMV is a nice name V meaning Void . i will recommend that to the standardization group
17:19:13 <ddarius> Void has nothing to do with it.
17:19:13 <Cale> litb: Yeah, it's kind of ugly, but you really don't want to make the name much longer, or there's no point, and there's not much in the way of meaningful other characters you could use.
17:19:27 <Cale> U for unit? :)
17:19:45 <ddarius> _ is better than U.
17:20:18 <Cale> I don't really mind the _ anymore.
17:21:13 <ddarius> I think it is the optimal choice.  It does no good to complain about something unless you can offer an alternative and convince others that it is better
17:21:13 * smack_ laughs at Pupeno
17:21:22 <ac> never bothered me because the name makes intuitive sense
17:21:29 * smack_ wonders since when he's smack_, also
17:21:37 <Pupeno> smack_: why?
17:21:55 <smack_> Pupeno: was your nick change related to the discussion of trailing underscores being ugly?
17:22:31 <Pupeno> smack_: no, not at all. I wasn't even aware of that discussion, I've just uniconofied my irc client.
17:22:41 <allbery_b> probably just noticed it.  irc clients append _ when the primary /nick is taken (dropped connection, usually)
17:23:46 <ac> happens to me frequently when I join a channel I'm already in on another computer
17:24:12 <BMeph> I like it because it's suggestive of what the function does, and how it differs from the regular version.
17:24:34 <ac> though now that doesn't happen to me anymore because I started irssi in a screen session on a server I can log in to from anywhere ;)
17:24:38 <LoganCapaldo> I'm down with the trailing underscore
17:24:43 <BMeph> I think it's ugly, too, but I think that the ugliness of it also reflects what it does.
17:25:25 <monochrom> The ugly duckling will grow up as a beautiful swan.
17:25:50 <Cale> Yeah, throwing away information is always ugly :)
17:25:59 <BMeph> basically, (function)_ = (\_ -> return ()) . (function)
17:26:10 <litb> they should call it mapMU not because of unit but because of ugly
17:26:23 <BMeph> Where (function) stands for mapM, sequence, of whatever.
17:26:50 <monochrom> Betty_ is beautiful.
17:27:12 <BMeph> monochron: No, only if what you thought was an ugly duckling was actually a swan to start.
17:27:20 <litb> Betty_ is nothing (())
17:27:29 <BMeph> Usually, ugly ducklings grow up to be ugly ducks. ;)
17:27:41 <litb> wth do you talk about?
17:27:50 <LoganCapaldo> ugly ducklings are beautiful
17:27:55 <ac> c2hs should be able to generate a default .chs file that imports everything
17:28:04 <BMeph> Ugly ducks are delicious. ;)
17:28:33 * LoganCapaldo hopes BMeph has _stopped_ speaking in metaphor
17:28:47 <monochrom> Ugly ducks will become beautiful after roasting.
17:29:05 <BMeph> monochron: Mmm, duck glaze! :)
17:29:40 * BMeph wasn't aware that anyone else was speaking in metaphor
17:30:33 <LoganCapaldo> maybe we shoulda used an allegory instead :)
17:31:04 <ac> or maybe someone could write another tool called c2chs
17:32:45 <LoganCapaldo> r2d2
17:33:07 <monochrom> Scheme R2D2
17:34:29 <LoganCapaldo> c3pohs
17:43:13 <ac> blarg. I don't see how to import a #define as a simple top level value as opposed to an enum
17:43:59 <LoganCapaldo> one element enum! :)
17:44:19 <ac> grrr
17:45:10 <BMeph> Hmm, good point. I'll have to see if H' is going to fix the whole awful mess they made of numbers.
17:45:10 <ac> oh well it's not necessary. I was just trying to include the version number
17:46:40 <LoganCapaldo> data Version = Version ; instance Enum Version where fromEnum Version = 23 ; toEnum 23 = Version :)
17:48:32 <BMeph> Seriously, who thought declaring "Enum Float" was a good idea? :p
17:48:44 <LoganCapaldo> but but
17:48:48 <LoganCapaldo> you need it
17:49:00 <LoganCapaldo> > [1.1..2.2]
17:49:02 <lambdabot>  [1.1,2.1]
17:49:19 <LoganCapaldo> so you can do that!
17:49:37 <scook0> > [0.0, 0.1 .. 1.0]
17:49:37 <lambdabot>  [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.899999...
17:49:40 <scook0> \o/
17:50:05 <BMeph> ...and so you get things like that. :)
17:50:16 <LoganCapaldo> ezactly
17:50:49 <LoganCapaldo> take away our Enum Floats and you take away one Haskell's essential weapons in the war against newbs ;)
17:50:54 <Cale> It's handy for, say, producing ranges of points for plotting functions.
17:50:56 <LoganCapaldo> one of
17:51:01 <scook0> sometimes I'd like to have proper succ/pred for floats
17:51:10 <scook0> i.e. next representable quantity
17:51:22 <Cale> scook0: I agree that would be a nice thing to have.
17:51:31 <Cale> In fact, you could have both.
17:51:43 <scook0> well, it doesn't even need to be Enum's succ/pred
17:51:48 <Cale> Where [0.0 .. 1.0] would be the list of all representable floats from 0 to 1
17:52:12 <Cale> and [0.0, 0.1 .. 1.0] would be just incrementing by (approximate) tenths
17:52:13 <monochrom> For plotting, you're really better off with 0.1 * map fromIntegral [0..100]
17:52:26 <ddarius> I don't think it is common for someone to want to interate over all representable floats in a range.
17:52:31 <ac> uhg, it's been a while since I've seen C code. The '*' character is overloaded far too much in C syntax
17:52:51 <ddarius> It has two meanings... ?
17:52:58 <monochrom> It has three meanings.
17:53:13 <Cale> ddarius: It's handy when you're really being picky in testing some numerical algorithm.
17:53:16 <ac> ddarius: multiplication, comments, pointer declaration, pointer dereference
17:53:16 <monochrom> int *x = *y * 5
17:53:20 <mauke> but two of them are the same
17:53:22 <Cale> But yeah, such things tend to take a long time to run :)
17:53:25 <scook0> I remember reading about somebody listing all the different meanings of * in Perl
17:53:33 <mauke> int *x; means *x is an int
17:53:34 <scook0> it was quite a list :)
17:53:37 <ddarius> Cale: "common"
17:53:39 <ac> isn't it used for union types too?
17:53:44 <r3m0t> but [0.0 .. 0.1] could be reasonable or unreasonable size depending on the architecture
17:54:04 <Cale> But it is a lazy list at least :)
17:54:09 <scook0> mauke: unless x is null, in which case it's erroneous
17:54:21 <mauke> scook0: that statement creates x
17:54:23 <ddarius> ac: Saying * is overloaded for constants and further in a confusing way is, in my opinion, quite unreasonable.
17:54:48 <idnar> s/constants/comments/ ?
17:54:55 <ddarius> Yes.
17:54:55 <scook0> heh, I suppose _|_ is an int after all, though
17:54:56 <mauke> scook0: typeglob sigil, multiplication, regex quantifier. what else?
17:54:56 <ac> ddarius: I just think it's ugly
17:55:12 <ac> ddarius: none of it's confusing
17:55:18 <ddarius> scook0: No, it is not.
17:55:25 <ddarius> (Not in C.)
17:55:51 <idnar> ac: what about Haskell using . for function composition, ranges, and floating point numbers? ;)
17:55:52 <Cale> A function returning an int in C can result in _|_
17:56:17 <Cale> (simply loop forever without returning anything)
17:56:18 <scook0> mauke: sorry, can't remember the details
17:56:33 <ddarius> Cale: Yes, but that doesn't make the int type contain bottom.
17:56:50 <ddarius> Rather the "function type constructor" includes a lifting.
17:56:56 <mauke> int bottom(void) { int x; return x; }
17:57:12 <idnar> mauke: that's a random value, not bottom
17:57:19 <mauke> idnar: no, it's not a value
17:57:26 <idnar> mauke: why not?
17:57:45 <monochrom> "That's just semantics." :)
17:57:46 <mauke> because looking at uninitialized values causes undefined behavior
17:57:52 <dons> what do people think about (optional) IsString instances for PCRE regexes?
17:57:57 <LoganCapaldo> int bottom(void) { int x; return x; } is arguably not C
17:58:06 <ddarius> dons: The beginning of the end.
17:58:27 <dons> so that, match "a.*b" "foo" []  would translate to, match (compile "a.*b) (pack "foo") []
17:58:46 <monochrom> What are the IsString methods?
17:58:51 <dons> the only caveat is that the compile may fail, and would throw.
17:58:54 <ac> could someone who actually knows C explain "typedef png_time FAR * png_timep;"?
17:59:01 <dons> monochrom: none. just string literals
17:59:06 <mauke> ac: FAR is something funky
17:59:17 <monochrom> Hmm runtime error.
17:59:18 <dons> i've found it really useful for bytestring literals -- don't know how i lived without it
17:59:21 <mauke> the rest means type PngTimep = Ptr PngTime
17:59:41 <dons> monochrom: right. so it would be purely optional -- you'd have to enable -XOverloadedStrings
17:59:43 <ddarius> mauke: It's most likely #defined to nothing on most architectures.
18:00:06 <LoganCapaldo> NEAR FAR wherever you are are
18:00:09 <ac> mauke: hah that's a funny way of writing that
18:00:26 <dons> though with the type inference, you could accidentally, say, mix up the regex and subject string arguments to 'match', and it wouldn't be a type error
18:00:39 <mauke> png_time *x; means *x is a png_time, with * meaning "dereference"
18:00:45 <mauke> therefore x is a pointer to png_time
18:00:45 <monochrom> Then again, pathological example:  Someone defines a Num instance consisting of just the even numbers.  Then fromInteger 3 is a runtime error. :)
18:00:47 <dons> while rquiring an explicit 'compile' is more likely to make the user think.
18:00:47 <ac> If I'm creating bindings, I should ignore the png_timep type then
18:00:53 <ddarius> dons: Indeed, in some C# code I'm frustrated by the implicit calls to ToString().
18:00:55 <mauke> adding typedef to a declaration turns it into a type alias
18:01:11 <dons> compile :: S.ByteString -> [PCREOption] -> Either String Regex
18:01:32 <ac> and just pay attention to png_time
18:01:37 <dons> fromString r = case compile r [] of Left s -> error s ; Right rptr -> rptr
18:01:58 <dons> so my assumption is that regexes are mostly correct, and defined at compile time.
18:02:11 <dons> so the call to 'compile' is a little tedious (but maybe not too tedious)
18:02:16 <ac> or should I use a standard time data type from a standard library?
18:03:25 <LoganCapaldo> ac: do it interatively. Make some minimal bindings start trying to do something, ee what you need, bind more, rather, rinse, repeat.
18:03:32 <monochrom> I don't think I'm afraid of runtime error in this case. But I think I'm afraid of mixing up match x y with match y x.
18:03:40 <ac> LoganCapaldo: naturally ;)
18:04:11 <idnar> dons: what is the type of match?
18:04:16 <idnar> (currently, I mean)
18:04:35 <dons> match :: Regex -> S.ByteString -> [PCREExecOption] -> Maybe [S.ByteString]
18:04:54 <dons> and, already using -XOverloadedStrings, you can write,   match r "foo" []
18:05:16 <dons> which "foo" --> (pack  "foo") due to bytestring IsString instance
18:05:38 <dons> monochrom: right. that seems plausible
18:05:49 <dons> you'd not want either the regex or bytestring instance to wander in by mistake
18:06:13 <mauke> the solution is to use =~ instead of match
18:06:32 <dons> how?
18:06:43 <dons> "foo" =~ "a.*b"  -- and leave off the flags?
18:06:54 <ddarius> mauke: It is no more immediately clear to me which argument is which with (=~)
18:07:10 <dons> i actually got them wrong today, when testing perl :)
18:07:10 <mauke> every perl programmer knows that the pattern is on the RHS
18:07:13 <dons> and it didn't warn me :)
18:07:35 <ddarius> mauke: I'm a Haskell programmer, not a Perl programmer.
18:08:30 <mauke> time to learn Perl, then!
18:08:42 <ddarius> mauke: I've learned Perl at least twice.
18:09:20 <allbery_b> it's lifted from awk ($1 ~ /foo/)
18:11:27 <byorgey> when I learned Perl, I thought it was the most amazing thing since sliced bread
18:11:33 <byorgey> now it annoys me =)
18:11:47 * ddarius never had that problem.
18:12:30 <litb> i do not know Perl, and i don't want to know it
18:12:41 <dons> so that was "no consensus" ?
18:13:09 <ddarius> dons: Let's not put that in the "standard" libraries.
18:13:18 <ddarius> It's easy enough for someone to add if they like it.
18:13:31 <litb> [[ foo =~ "a.*b" ]] && echo yeah
18:13:34 <dons> that's true. i you expect to work with a lot of regexes, then an IsString instance is 2 lines away
18:13:39 <litb> bash is better
18:13:40 <ddarius> Maybe a Text.Regex.Instances
18:16:08 <idnar> I thought it was ~= in perl
18:16:18 <shachaf> idnar: No, =~.
18:16:21 <LoganCapaldo> it's =~
18:16:27 <dons> i've put a comment in,
18:16:29 <shachaf> (There's a !~, for example.)
18:16:29 <dons> -- Possible improvements: an 'IsString' instance could be defined
18:16:29 <dons> -- for 'Regex', which would allow the compiler to insert calls to
18:16:29 <dons> -- 'compile' based on the type:
18:16:29 <dons> --
18:16:31 <dons> -- The following would be valid:
18:16:34 <dons> --
18:16:36 <dons> -- > match "a.*b" "abcdef" []
18:16:39 <dons> --
18:16:41 <dons> -- and equivalent to:
18:16:44 <dons> --
18:16:44 <litb> lol
18:16:46 <dons> -- > match (either error id (compile "a.*b")) "abcdef" []
18:17:09 <shachaf> dons: @paste with pastes that long, possibly? :-(
18:17:21 <Cale> It's cool.
18:17:36 <litb> @src match
18:17:36 <lambdabot> Source not found. That's something I cannot allow to happen.
18:17:36 <dons> it was easier to than typing the conclusion of the discussion
18:17:36 <Cale> It's not like we're going to refer back to it again :)
18:17:58 <dons> it would be interesting to have IsString parse "/a.*b/i" and find the flags too.
18:18:14 * shachaf missed the rest of the discussion... Sorry.
18:18:14 <ddarius> As I said dons, the beginning of the end.
18:18:16 <dons> then we can extend IsString to allow defining your own string literal delimiters
18:18:22 <dons> and then it would be the end :)
18:18:28 <idnar> bwahaha
18:18:56 * idnar goes back to implementing the IRC protocol
18:19:55 <litb> are there threads for haskell?
18:20:07 <ac> idnar: you writing an irc client?
18:20:10 <litb> i mean real thread of executions?
18:20:16 <Cale> litb: yes
18:20:21 <mauke> :t forkIO
18:20:24 <lambdabot> Not in scope: `forkIO'
18:20:28 <Cale> litb: In fact, Haskell's threading system is extremely nice.
18:20:43 <Cale> litb: In my opinion, it competes quite nicely with Erlang's.
18:20:44 <dons> :t Control.Concurrent.forkIO
18:20:45 <lambdabot> IO () -> IO GHC.Conc.ThreadId
18:20:48 <ddarius> Not in the standard.  Though you could easily implement cooperative concurrency in pure Haskell.
18:20:59 <ac> aren't there other ways to achieve concurrency and parallelism?
18:21:06 <clanehin> grrr that we don't have any kind fo thread priority, though, except in haskell'
18:21:07 <Cale> Well, this is GHC, we're probably talking about :)
18:22:45 <Cale> litb: There are two major systems of thread communication for concurrent programming, the old one, which involves MVars, which are memory cells that are either empty, or can contain a value. Threads which read an empty MVar will block until it is filled, and threads which write to a full MVar will block until it is empty.
18:22:59 <Cale> (and reading a full MVar normally empties it)
18:23:01 <dons> ac, there's `par`, and other mechanisms. but they all boil down to forkIO in the end
18:23:24 <Cale> Then there's STM, which is a system for Software Transactional Memory.
18:23:38 <litb> ah i see.
18:23:42 <Cale> It lets you write blocks of code which are guaranteed to behave as if they ran atomically.
18:23:44 <litb> i will read about them tomorrow
18:24:00 <litb> good nite all
18:24:41 <LoganCapaldo> transactions are fun
18:24:47 <LoganCapaldo> hooray transactions
18:24:50 * MyCatVerbs oO's at the universe.
18:25:45 <MyCatVerbs> Why the HELL would my main function *ever* have an inherited time or alloc cost below 100%? That's just FUBAR, by which I mean apparently the universe doesn't work how I think the universe is supposed to work. :/
18:25:53 <ac> dons: isn't there a version of GHC that implements some sort of message passing system too?
18:26:12 <LoganCapaldo> @hoogle Chan
18:26:12 <lambdabot> Control.Concurrent.Chan :: module
18:26:12 <lambdabot> Control.Concurrent.Chan.Chan :: data Chan a
18:26:12 <lambdabot> Control.Concurrent.STM.TChan :: module
18:26:14 <dons> well, we usually use Chan or TChan or something like that for passing messages around
18:26:57 <ac> what's the point of Glasgow Parallel Haskell then?
18:27:35 <LoganCapaldo> parallel != concurrent
18:27:37 <Cale> That's pure parallelism, something different from concurrency.
18:27:37 <ac> I'm guessing GPH parallelizes things automatically
18:27:45 <Cale> No, it doesn't
18:28:23 <ac> parallel means physically executing things in parallel, where concurrency means interlacing execution through time, right?
18:28:46 <ac> interlacing the execution of two or more threads through time, I mean
18:29:00 <Cale> yeah
18:29:23 <Cale> Concurrency is where you introduce nondeterministic results due to threading.
18:30:15 <MyCatVerbs> Concurrency alone gains you a) headaches (always) and b) interactive response times (but only if you do it right ;)
18:30:16 <Cale> Parallelism is about physically running things in parallel, but might not introduce any nondeterminism, if, say, the things you're parallelising are pure computations.
18:30:39 <ac> does Control.Concurrent.forkIO execute things in parallel if the hardware is capabable? I guess I'm asking if it uses OS level threads
18:30:49 <MyCatVerbs> Parallelism gains you a) headaches (always) and b) throughput (only if you do it right)
18:30:56 <MyCatVerbs> ac: yes.
18:31:06 <Cale> What I'd like to know is to what extent GpH has been integrated into GHC.
18:31:06 <MyCatVerbs> ac: if and only if you use +RTS -N2 or more
18:31:15 <Cale> Certainly par exists in GHC now.
18:31:31 <ac> MyCatVerbs: those ghc compile flags?
18:31:34 <Cale> MyCatVerbs: Why should parallelism always give you headaches?
18:31:36 <MyCatVerbs> ac: it uses green threads (that is, super-duper lightweight threads implemented in user space) rather than OS threads.
18:32:02 <MyCatVerbs> Cale: it takes some serious investigation to work out just *where* to put the par annotations, except in toy problems.
18:32:08 <dons> i don't understand 'slava's comment here,
18:32:09 <dons>   http://programming.reddit.com/info/65bpf/comments/c02vt8u
18:32:10 <Cale> Well, okay.
18:32:17 <MyCatVerbs> Cale: but you have a point, `par` massively reduced the headache overhead.
18:32:34 <Cale> I'm not sure whether I completely agree with that -- there are lots of problems which are trivial in that regard.
18:32:36 <dons> what accumulator (or is he forgetting about laziness?)
18:32:49 <MyCatVerbs> ac: mmm, you want to compile your programs with -threaded, and +RTS -N[number] is an option that you give at runtime.
18:32:51 <Cale> (anywhere that you have, say, a map, for example)
18:33:42 <ac> MyCatVerbs: ah, so those arguments are automatically parsed by the runtime?
18:33:49 <LoganCapaldo> what would tail recursion buy you with unfoldr?
18:34:02 <MyCatVerbs> ac: yes, the runtime steals and interprets anything between +RTS and -RTS
18:34:10 <dons> isn't that tail recursion "modulo cons" , which gives us constant space for free in a lazy language?
18:34:33 * Botje fpa that as "modulo dons
18:34:34 <MyCatVerbs> ac: (I think you can override that, but I can't remember how. It's damn useful, anyway.)
18:34:44 <Botje> good sign I should go to bed.
18:34:44 <MyCatVerbs> Botje: fpa?
18:34:51 <Botje> "first parsed that as"
18:35:08 <ac> MyCatVerbs: yeah, that's good to know. I bet there's a few other things you can pass to the RTS
18:35:11 <MyCatVerbs> Ahhh.
18:35:20 <MyCatVerbs> ac: lots of things to do with profiling.
18:35:36 <ac> cool
18:36:03 <LoganCapaldo> wouldn't a tail recursive foldr with an accumlator (a list I presume) be _worse_ because you have to append to the end?
18:36:13 * LoganCapaldo hopes he isn't going insane
18:36:14 <MyCatVerbs> ac: lots of little constants for tuning the garbage collector (though I presume you don't usually want to actually use them yourself, since the nice people who wrote GHC will have tuned the shit out of them beforehand).
18:36:32 <LoganCapaldo> s/foldr/unfoldr/
18:36:46 <MyCatVerbs> :t unfoldr
18:36:48 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
18:36:52 <MyCatVerbs> @src unfoldr
18:36:52 <lambdabot> unfoldr f b  = case f b of
18:36:52 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
18:36:52 <lambdabot>    Nothing        -> []
18:37:34 <ac> so Control.Parallel has par and seq in it. Isn't that all GPH has?
18:37:37 <MyCatVerbs> LoganCapaldo: trying to make things that produce lists tail-recursive usually does involve your choice of a) appending to the end of the list or b) reversing the list at the end.
18:38:12 <MyCatVerbs> ac: GPH has many other things, too, like parallel data types and such. par and seq are the coolest bits, though. ;)
18:38:12 <ac> I'm asking if there's any reason to use GPH over the standard GHC, or if GPH has been basically merged entirely
18:38:21 <LoganCapaldo> and if you reverse it you can't have your infinite unfold
18:38:28 <MyCatVerbs> LoganCapaldo: precisely.
18:38:54 <MyCatVerbs> LoganCapaldo: to be honest, I've falled into the trap of doing b) a few times, as a result of not being used to lazy programming.
18:39:22 <clanehin> I remember reading the GHC itself had been parallelized some time ago, but I don't see current documentation about it.
18:39:59 <MyCatVerbs> LoganCapaldo: I think you can't do append sanely either, since it would involve traversing the whole list to get to the end of it to stick the new element on.
18:40:47 <LoganCapaldo> MyCatVerbs: it would be suckier but you should still be able to take from it etc. I think
18:41:25 <MyCatVerbs> clanehin: well, Concurrent Haskell has been included, which makes multithreading an absolute joy. Also, there's the Control.Parallel module, which exports par and seq and also masses and masses of stuff for clever evaluation strategies, all of which is just *way* over my head.
18:41:57 <MyCatVerbs> LoganCapaldo: I have a vague feeling it'd be O(n^2)-ish on finite output and wouldn't terminate on infinite output, though.
18:43:14 <clanehin> MyCatVerbs: no, this.  If you scroll down it talks about parallelizing the compiler, unless I'm very confused: http://research.microsoft.com/~tharris/papers/2005-haskell.pdf
18:46:36 <MyCatVerbs> clanehin: eh? That's not about parallelising the compiler's own work, that's about making the compiler produce programs that can take advantage of parallel processing.
18:46:55 <KevBurnsJr> Hi all, I just found hpaste through swik.  Wanted to come on and give a big tyvm!
18:47:14 <KevBurnsJr> Cleanest open pastie i've found to date :)
18:47:36 <MyCatVerbs> clanehin: oh well, whoopsy me, they show GHC itself being parallelised using exactly the tools they're producing, as a good non-trivial example. I feel stupid, now. =D
18:48:11 <clanehin> MyCatVerbs: yeah.  Want.   :)
18:48:21 <MyCatVerbs> KevBurnsJr: check the "announce" box and a bot yells in here about what you just pasted, so we can all make fun of^W^W^Whelp you with it. ;)
18:48:56 <hpaste>  LoganCapaldo pasted "MyCatVerbs: you appear to be correct sir" at http://hpaste.org/4960
18:48:57 <ac> dons: the problem with writing bindings for libpng rather than writing a new png library (not that I'm seriously proposing this) is that what should be a few simple functions are actually a big mess of functions that all have IO types
18:50:39 <MyCatVerbs> clanehin: ...I have a vague feeling that the contents of that paper might well be already implemented in GHC. >_>
18:51:45 * MyCatVerbs hugs LoganCapaldo.
18:52:06 <MyCatVerbs> Thank you very much for being more curious than lazy, and actually doing that experiment - unlike me. ;)
18:52:25 <ddarius> What the?  Doesn't python have generators?  Why wouldn't you just implement unfold on those?
18:52:47 <clanehin> MyCatVerbs: it would seem to have to be, but ghc doesn't seem to respond to +RTS -N2, nor does it take the -j flag described in the paper.  Furthermore, when I tested parallel GNU make with ghc, I got no net performance benefit, but they did.
18:53:35 * MyCatVerbs wonders where he could get an almightily huge body of crap Haskell...
18:53:47 <allbery_b> hpaste? :)
18:54:18 <Botje> MyCatVerbs: students?
18:54:56 <dons> ac, well, good C libraries tend to provide referentially transparent ops
18:55:00 <dons> which you can then encapsulate
18:55:03 <MyCatVerbs> Botje: heh. I am one, but I'm too lazy to write it. =D
18:55:06 <dons> (e..g pcre-compile and match)
18:55:24 <dons> MyCatVerbs: hpaste or hackage.haskell.org :)
18:55:41 <Botje> well, sleepytime
18:55:54 <Botje> i'll have to lay off irc for a day and become _REALLY_ productive
18:56:34 <MyCatVerbs> Botje: sleep well.
18:56:35 <ddarius> :t unfoldr
18:56:36 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
18:56:55 <MyCatVerbs> dons: hee. Will try hackage. :)
18:57:19 * MyCatVerbs just wants a single .hs lump that will take ghc more than, say, 30 seconds of CPU time to compile on a fast CPU.
18:58:35 <ddarius> I had some code that took GHC quite a while to compile.
18:59:10 <dons> oh, typically parser or lexer generated files with huge datastructures and lots of patterns, will yield results like that
18:59:58 <monochrom> Many modules in GHC itself does that.
19:00:17 <monochrom> Maybe not 30 seconds. Maybe most are 10 seconds.
19:02:31 <dons> the module i'm working on now takes 5s currently
19:02:40 <dons> it'll probably take a lot more by the time i'm done
19:04:24 <allbery_b> dunno, most of them take >30s on my machine :)
19:08:20 <dibblego> can two lists be compared to equality-ignoring-order in less than O(n^2) without ordering over the element type?
19:10:50 <ddarius> I doubt it.
19:10:51 <LoganCapaldo> not generally I don't think
19:11:45 <LoganCapaldo> if you have a small number of constructors you can count and do it in O(n + m)
19:14:56 <ac> dons: libpng doesn't seem to
19:15:53 <MyCatVerbs> ac: libpng is, at least, nicely threadsafe, though. Thank $DEITY for small mercies. ;)
19:19:34 <ac> arhg. I think it would actually be kind of fun to just read the png spec
19:22:34 <ac> and implement it purely
19:41:32 * MyCatVerbs hugs Mori hugging hatter.
19:41:51 * MyCatVerbs stabs whoever decided to put the N key next to the M key.
19:42:25 <dons> pcre-light released, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pcre-light-0.1
19:42:26 <lambdabot> http://tinyurl.com/3aro3x
19:42:28 <dons> enjoy :)
19:42:29 <MyCatVerbs> (I guess that was also my own fault for using ^M instead of enter in an IRC client in which ^N switches to the next window, blah.)
19:49:25 <sarehu> Who was it who asked about comparing lists ignoring order?
19:49:38 <dibblego> me
19:49:40 <sarehu> with only Eq, in better than O(n^2)?  Was that question answered?
19:49:42 <sarehu> ok
19:49:47 <dibblego> yes
19:49:48 <sarehu> I think I have an O(n log n)
19:49:54 <dibblego> great!
19:50:55 <sarehu> the trick is: make an operation notUnion :: Eq a => [a] -> [a] -> ([a],[a]) which returns the elements of the two lists not shared in common..
19:50:57 <sarehu> let me paste
19:51:04 <sarehu> let me test first...
19:51:29 <shapr> Yay, that was fun!
19:53:04 <Cale> Don't you have to do n^2 comparisons just to tell that one list is a permutation of the other?
19:53:35 <sarehu> (a) you do? (b) isn't that the problem?
19:55:14 <Cale> Well, any one of the elements of the first list could fail to be in the second, so you have to try them all. Once you've picked one to test, you basically have to go through the elements of the second list (which haven't been matched yet) in order to tell if it's there or not.
19:56:12 <kmcallister> Cale, you can make an intermediate datastructure to do fast list membership testing
19:56:14 <kmcallister> like a Data.Set
19:56:20 <sarehu> not without Ord
19:56:22 <Cale> kmcallister: But that involves an ordering
19:56:38 <kmcallister> oh, hooray for reading more than the past 2 lines of convo :)
19:56:42 <Cale> The assumption here is that all we can do with elements is compare them for equality.
20:00:16 <davidL> Is there somehow someone can search hpaste?
20:00:16 <FreshCat> anyone using GHC on FreeBSD 7.0 RC1?
20:00:28 <Cale> I'm fairly sure one could prove that any algorithm which correctly tests if the lists have the same elements without regard to order will make at least n (n+1)/2 comparisons in the worst case.
20:02:16 <twanvl> davidL: google, site:hpaste.org
20:02:45 <Cale> FreshCat: Well, there's an x86_84 binary package for GHC 6.8.2 on FreeBSD, so it seems that *someone* is :)
20:02:50 <Cale> oh
20:03:48 <davidL> twanvl: that completely slipped my mind, thanks
20:06:02 <Cale> Who asks a question and then just leaves IRC immediately? *sigh*
20:06:36 <shachaf> Cale: FreshCat. :-)
20:07:23 <dons> anyone got cabal-install installed?
20:07:33 * shachaf does.
20:08:09 <dons> could you try a, $ cabal update && cabal install pcre-light
20:08:11 <dons> for me? :)
20:08:16 <dons> distributed build testing. :)
20:08:30 <dons> assuming you have libpcre (the C lib) available
20:08:44 <Cale> dons: sure
20:09:54 <kaol> I don't quite like the haskell library packaging support provided by either haskell-utils or haskell-devscripts... At this rate, Debian will get a third semi-automated way for packaging them.
20:09:55 <allbery_b> some people have no patience
20:10:04 <shachaf> dons: Seems to work.
20:10:13 <shachaf> (After installing libpcre3-dev.)
20:10:15 <Cale> dons: yep, working
20:10:31 <shachaf> Perhaps it could fail more nicely, though?
20:11:04 <Cale> kaol: what are those things?
20:11:23 <Cale> kaol: The official way to package Haskell libraries is Cabal :)
20:12:05 <allbery_b> linux distributions tend to "prefer"/insist on their own packaging
20:12:22 <shachaf> Cale: Those are things to turn cabal packages into Debian packages (I think).
20:13:08 <dons> awesome, thanks guys.
20:13:22 <dons> you could also run the testsuite,
20:13:23 <dons> $ cd .cabal/packages/hackage.haskell.org/pcre-light/0.1/
20:13:23 <dons> $ tar xzf pcre-light-0.1.tar.gz
20:13:28 <dons> $ runhaskell pcre-light-0.1/tests/Unit.hs
20:13:28 <dons> Cases: 145  Tried: 145  Errors: 0  Failures: 0
20:13:44 <dons> should be the result (assuming you have, hmm, HUnit, and ghc 6.8.2 and a new bytestring)
20:13:51 <Cale> pcre-light-0.1/tests/Unit.hs:48:16:
20:13:51 <Cale>     No instance for (Data.String.IsString S.ByteString)
20:14:01 <dons> right, you need the latest bytestring.
20:14:06 <Cale> yeah
20:14:18 <dons> cabal install bytestring-0.9.0.4
20:14:22 <Cale> So maybe pcre should depend on a newer one?
20:14:31 <dons> well, its not required to use the lib, just the testsuite
20:14:52 <shachaf> Text/Regex/PCRE/Light.hs:314:0:
20:14:52 <shachaf>     Illegal foreign declaration: requires via-C or native code generation (-fvia-C)
20:14:55 <shachaf>     When checking declaration:
20:14:57 <shachaf>         foreign import ccall unsafe "static  &free" c_free
20:15:00 <shachaf>           :: FinalizerPtr a
20:15:04 <Cale> There should be a way to tell cabal-install that you just want the latest everything.
20:15:06 <dons> shachaf: ah yes. it assumes you've built and installed the library
20:15:23 <dons> Cale: i think there's a new option for that, actually. cabal upgrade
20:15:26 <dons> but not released (?)
20:15:31 <shachaf> Didn't I?
20:15:40 <dons> shachaf: oh, maybe you're in the pcre-light dir?
20:15:44 <shachaf> Right.
20:15:47 <dons> in which case it will try to interpret the src
20:15:47 * shachaf just realized that.
20:16:02 <dons> which doesn't work for "&free"-style ffi imports
20:16:22 <shachaf> dons: Works now.
20:16:28 <dons> great.
20:16:57 <dons> cabal-install is great for distributing code cheaply :) 5 mins and your code is built, installed, tested and running on other people's machines.
20:17:48 <davidL> @seen ac
20:17:48 <lambdabot> ac is in #haskell. I last heard ac speak 55m 14s ago.
20:18:05 <shachaf> There should be an easy test option to cabal-install.
20:18:14 <shachaf> (And "cabal help" should work, without --.)
20:18:22 <dons> yeah, cabal test would be good, wouldn't it, for this scenario
20:18:26 <Cale> Okay, if pcre-light is built against the new bytestring too, it works fine :)
20:18:32 <dons> great, thanks Cale.
20:18:41 <dons> i'll release it then
20:19:47 <dons> i hope this will be a more stable, simpler replacement for the regex-* stack
20:19:47 <jfredett> Data.Set.union is faster than Data.List.union, right? (the former is (O(n+m), the latter O(nm)?)
20:19:51 <Cale> There ought to be some way to merge all the documentation for all installed cabal packages and show it in one big tree.
20:20:05 <Cale> jfredett: yeah
20:20:25 <jfredett> cool
20:21:34 <Cale> Better yet, get Haddock to generate a bookmarks.html tree of bookmarks for all the documentation, which you can import into Firefox/etc.
20:29:55 <dons> interesting, "I am a better programmer in every language I use
20:29:55 <dons> because of Haskell. I use Haskell most of the time now though. It?s really not that bad. I get a lot
20:29:58 <dons> done. I feel better about the code I write. I could even write a large application in Haskell
20:30:02 <dons> without feeling like I am limited in some way. Haskell is, without a doubt, practical for every day
20:30:05 <dons> use, far more so than any of the imperative language I have come across."
20:30:06 <dons> http://geekrant.wordpress.com/2008/01/12/on-the-utility-of-functional-programming/
20:30:07 <lambdabot> Title: On the Utility of Functional Programming « Geek Rant, http://tinyurl.com/yrjovt
20:30:10 <dons> which is otherwise a bit scary
20:33:35 <cjb> dons: I see you're quoting the positive part :)
20:34:33 <dons> yep. just to warn people :)
20:34:49 <dons> i think the view's a little outdated though -- hackage didn't exist a year ago, after all
20:34:56 <dons> so there's clearly a lot of outward-focused development.
20:35:10 <dons> the commercial user's conference was the largest ever in 2007, so signs are postiting
20:38:33 <sarehu> agh, I miscounted.
20:39:59 <kaol> this would've been easier if there was a way to tell cabal to use something besides dist/ as the build dir. for example, us distributions like to build regular and profiling versions of the libraries on the same run. or did I miss some switch after all?
20:40:14 <dons> hmm, so in the end, the call in that article is for more projects (open source / commercial ones), and less research experiments?
20:40:24 <sarehu> And it seems that the number of comparisons used on random input is about 0.33*n^2
20:40:47 * shachaf wonders: Is anyone here planning to be at LFNW (http://linuxfestnorthwest.org/)?
20:40:56 <shachaf> Maybe present something Haskell-related? :-)
20:41:45 <dons> hmm
20:42:17 <dons> there's a pretty serious haskell regiment down in OR, so we probably could get someone up there
20:47:54 * BMeph wonders if there's a Fort Lewis detatchment trying to get assigned as security to the Haskell regiment
20:52:29 <MyCatVerbs> shachaf: damn y'all for being on the other end of the Atlantic, and damn humanity for not inventing the personal freakin' teleporter already. :)
20:52:47 <MyCatVerbs> Oh and to HELL with physics for making it actually really difficult. =D
20:53:01 <shachaf> MyCatVerbs: Huh? YOU'RE the ones on the other end.
20:53:05 * shachaf is right here.
20:53:16 <ac> davidL: what?
20:53:34 <allbery_b> reallyUnsafePerformIOWithModifiableRealWorld# ...
20:54:14 <davidL> ac: are you working on libpng bindings?
20:54:31 <MyCatVerbs> shachaf: bwhahahaha. I like the turnaround. :)
20:54:40 <jfredett> i love it when algorithm time scales linearly with problem size
20:54:42 <jfredett> :)
20:55:31 <MyCatVerbs> shachaf: reminds me of a conversation involving my parents a while back, discussing a family who'd emigrated to Australia and then moved back a scant six-ish months later: "Maybe they got tired of having to stand on their heads all the time?"
20:56:18 <shachaf> dons: How does it feel not to stand on your head anymore?
20:57:11 * allbery_b rolls his eyes
20:57:45 * shachaf apologizes.
20:58:17 * ricky_clarkson stands on shachaf's head.
20:59:25 <Kirakishou> Â¿FIESTA?
21:00:56 <MyCatVerbs> shachaf: don't be silly, we're only roughly ninety degrees apart.
21:01:11 <MyCatVerbs> shachaf: more like standing on one's ear than one's head. :)
21:04:32 <allbery_b> Â¿sÄ±É¥Ê ÇÊÄ±Ê uÇÊÊÄ±É¹Ê ÇÊÉÉ¥ suop Ê,upÊnoÊ
21:06:10 <MyCatVerbs> allbery_b: <3 utf-8
21:07:20 <MyCatVerbs> allbery_b: plus, no. Well, yes, *he*'d have to, but his computer would've sent it upside down, too, so that it'd come out the right way up on my screen. ;)
21:09:13 <shapr> Yay Boston!
21:09:25 <jfredett> :) isn't it a great town, shapr?
21:09:26 <jfredett> :)
21:09:31 <shapr> Yeah, it's fun.
21:09:40 <shapr> Hey, did I forget to ask you to show up and meet Python & Haskell guys today?
21:09:42 <MyCatVerbs> What, in particular, makes Boston great?
21:09:49 <jfredett> lol, yah
21:09:51 * MyCatVerbs is curious.
21:09:52 <jfredett> MyCatVerbs: Everything
21:09:58 <shapr> MyCatVerbs: The fact that I live here, and so do lots of other smart programmery people.
21:10:02 <jfredett> forall x. Boston >> x
21:10:08 <shapr> MIT Contra Dancing also makes Boston nifty.
21:10:35 <shapr> MyCatVerbs: Will you be visiting soon?
21:12:04 <jfredett> shapr: is the Boston HUG/PUG going to be on saturdays?
21:12:44 <shapr> Seems likely.
21:12:47 <shapr> Since I work during the week.
21:12:59 <shapr> Will you show up at http://stuff.mit.edu/iap/#hackhaskell ?
21:12:59 <lambdabot> Title: SIPB IAP 2008 Activities
21:13:07 <jfredett> hmm
21:13:41 <jfredett> depends, *stares at blank schedule*
21:14:04 <shapr> Is that a yes?
21:14:07 <dons> HUG/PUG?! sounds great!
21:14:29 <shapr> Haskell Users Group of Somerville = HUGS ?
21:14:40 <shapr> Or should it be BHUG?
21:14:48 <jfredett> i dunno, its a little late in the evening for me, I don't like taking the T at night, :/
21:14:54 <shapr> Aww
21:14:56 <jfredett> esp the Worc/Boston T
21:15:09 <shapr> Where are you? I have a car.
21:15:22 <jfredett> i'll check it out, maybe I can get my Dad to come too
21:15:37 <jfredett> he's a C guy, and rails at me for my functional obsession, :)
21:15:40 <shapr> heh
21:15:46 <shapr> ruby on rails?
21:16:46 <jfredett> lol
21:16:49 <jfredett> not quite
21:17:25 <jfredett> he's one of the few people i know who never changed languages from C
21:17:42 <ricky_clarkson> shapr: I thought you were setting of a Chicago HUG.
21:17:47 <ricky_clarkson> s/of/up/
21:17:48 <jfredett> he still programs in C, he only programs in C, he doesn't even touch Java.
21:17:52 <shapr> ricky_clarkson: Nah, Boston
21:18:06 <MyCatVerbs> shapr: where, Boston? Heck no, plane tickets are expensive and I don't have a compelling reason to right now.
21:18:30 <MyCatVerbs> jfredett: I'm usually after a greater degree of precision than that, but I'd still call that a pretty glowing reccommendation. :)
21:18:43 <jfredett> lol
21:21:01 <dons> how can we get more open source haskell projects? what impediments to doing your next script/tool/project/coorporate takover with haskell, do people face?
21:21:08 <dons> any ideas?
21:22:15 <MyCatVerbs> dons: laziness.
21:22:29 <dons> make the creation of web apps easier? ensure the ghc tool chain is on every distro?
21:22:39 <dons> (the latter is one of the key barriers for xmonad)
21:22:41 <MyCatVerbs> dons: specifically, I'm too lazy to do my next script/tool/project/corporate takeover *at all*, let alone in Haskell. ;)
21:22:49 <dons> ok, so lazy people can stay lazy.
21:22:55 <MyCatVerbs> Heheheh.
21:23:03 <dons> i want to get the people who write stuff, not to do it in python/C / shell whatever
21:23:35 <dons> we've got a good core of researchers, then a wrapper around them of open source devs, writing haskell libraries, mostly, and then some corporate guys using all this in a few places
21:23:57 <dons> really, i guess success here would be more corporate projects
21:23:57 <Cale> HAppS seems to need more thorough documentation.
21:24:17 <faxlore> Hi
21:24:20 <dons> yep. good docs take time, but are critical.
21:24:22 <Cale> Which is sad, since it looks like it has a lot of useful code in it.
21:24:42 <dons> maybe we need a revised "best practices for new projects" article
21:24:46 <cjb> dons: I wrote a perl script today that would probably be a good Haskell script.  But it was for my graphics card driver, and it would be totally insane to expect the xorg folks to ship a companion script written in Haskell.  :/
21:24:58 <dons> hmm. so that's a toolchain issue
21:25:08 <dons> you'd not write it in ruby either, i guess
21:25:12 <cjb> right.
21:25:13 <dons> or erlang, or F# , or ocaml
21:25:17 <cjb> in fact my daily language is Python
21:25:27 <conal> faxlore: hi
21:25:27 <dons> why's that, do you think?
21:25:41 <cjb> and I chose Perl over Python here because there was already another companion script in the xorg driver written in Perl.
21:25:52 <cjb> why's my daily language Python?  well, I work for OLPC, and we wrote an OS in it :)
21:26:04 <dons> ok. so legacy codebase :)
21:26:08 <cjb> haha
21:26:11 <cjb> something like that, yeah.
21:26:19 <dons> i guess you wrote a package management system/support tools, not the kernel, right? :)
21:26:33 <dons> like linspire's haskell tools for their distro?
21:26:52 <cjb> for which, the OLPC python code, or the perl script I wrote today?
21:26:54 <dons> a ubiquitous install of ghc would make things a *lot* easier
21:27:11 <dons> cjb: "we wrote an OS in it" -- i guess you don't mean a python *kernel* running on bare metal?
21:27:18 <cjb> ah.  no, everything above X.
21:27:32 <cjb> and some things that would normally be below X, such as an object datastore (filesystem replacement)
21:27:46 <dons> so perhaps a better route in is via support scripts/testing/web stuff -- tools that don't need haskell deployed on the target
21:28:00 <dons> or, make binary packages of haskell tools easier (that's important for xmonad, for example)
21:28:17 <cjb> yup.  I was very happy that my desktop's xmonad binary ran on the XO just by scping it (and nothing else) over.
21:28:25 <dons> yeah.
21:29:20 <Cale> xmonad has the funny condition of having configuration require a Haskell compiler
21:29:20 <dons> its much easier to create new haskell libraries and tools for the haskell community, than to fight distros to get tools in to large open source projects
21:29:49 <dons> yep. like having a python or ruby interpreter installed
21:30:08 <Cale> (Which makes the binary situation more complicated)
21:30:59 <dons> so haskell can do a bit better for the *new ideas* projects -- get new, experimental stuff done faster (say, like darcs or pugs or xmonad). better than reimplementing some existing tool
21:31:21 <dons> since its such an agile platform for extreme haxoring
21:31:57 <dons> so, hmm, new slightly-not-quite research open source developers, would be a good target market
21:32:36 <dons> emphasis / improve the ease of deployment
21:33:15 <dons> and i'd like to some how "convert" more latent projects in the minds of people in here, into code :)
21:34:33 <dons> cale, release more code :) ddarius, more code, man! shapr, i want fermat's last margin, now!
21:35:13 <shapr> heh
21:35:20 <shapr> I'll work on it!
21:35:25 <Cale> Let's make some major compatibility-breaking changes to the language!
21:35:32 <dons> no!
21:35:59 <dons> Cale, your a domain expert for the math/haskell faction, we could get more math stuff from you :)
21:36:02 <ricky_clarkson> @seen cdsmith
21:36:02 <lambdabot> I haven't seen cdsmith.
21:36:03 <Cale> Oh, come on, it will be so good!
21:36:10 <dons> shapr, web apps, you've had a lot of experience. more web stuff!
21:36:15 <Cale> The Prelude needs work :)
21:36:31 * faxlore wants to ask something please..,
21:36:34 <faxlore> How does haskell figure out the type of y  in  y f = f (y f) ?
21:36:37 * dons slaps Cale with a copy of the h98 report, and yells, "It's done, already! Let it go!"
21:36:40 <jfredett> Cale I agree
21:36:42 <ddarius> Okay dons.  I need to write some parser to test out parsec3.  What's something that needs parsing that isn't -too- involved?
21:37:03 <jfredett> @type (\y f -> f (y f)
21:37:06 <lambdabot> parse error (possibly incorrect indentation)
21:37:09 <jfredett> @type (\y f -> f (y f))
21:37:09 <faxlore> :t let y f = f (y f) in y
21:37:09 <lambdabot> forall t t1. ((t -> t1) -> t) -> (t -> t1) -> t1
21:37:10 <lambdabot> forall t. (t -> t) -> t
21:37:14 <ddarius> faxlore: The same way it figures out the type in any expression.
21:37:16 <conal> faxlore: by combining constraints implied by the definition.
21:37:17 <dons> mm. ok. i'd say JSON, but i'm about to release a galois json library, so it would be duplicated work
21:37:20 <Cale> faxlore: Well, it's clearly a function, because it has a parameter f, and returns some value
21:37:36 <ricky_clarkson> faxlore: It doesn't make the types concrete until you use the function.
21:37:40 <Cale> faxlore: So to determine the type of y, we just have to determine a type for that parameter f, and the result
21:37:41 <faxlore> I run thought it myself in a text editor.. starting like you said Cale
21:38:08 <dons> ddarius: maybe browse the rfc list, or say, the ruby/python new libs site -- they'll be a list of new protocols that we could do with parsers for
21:38:15 <Cale> In the body of y, the value f is applied to (y f), so it must itself be a function.
21:39:25 <Cale> and the parameter type of the function f must be the same as the result type for y, as well as the result type of f being the same as the result type for y
21:39:26 <dons> ddarius: json would be a good candidate though -- you can do a very robust impl in maybe 100 lines.
21:39:34 <dons> bytestring-based, would be very useful
21:40:24 <Cale> So we must have that  y :: (t -> t) -> t
21:40:45 <Cale> The compiler does what is essentially a formalisation of this
21:40:59 <Cale> It assigns different type variables to all the expressions
21:41:07 <Cale> and then determines a bunch of equations between them
21:41:16 <Cale> and solves that system of equations
21:41:21 <faxlore> ok
21:41:24 <faxlore> I see
21:41:29 <jfredett> Cale, once again, bringing light to the dark places of Type theory. He likes to explore places in type theory where the sun, proverbially, does not shine.
21:41:49 <faxlore> 1 thing I don't see
21:41:57 <faxlore> y :: (t -> t) -> t
21:41:59 <faxlore> as opposed to
21:42:01 <faxlore> y :: (t -> u) -> t
21:42:10 <hpaste>  faxlore pasted "typing y" at http://hpaste.org/4962
21:42:17 <Cale> oh, the result type of f must be the same as the result type of y
21:42:23 <faxlore> this is sort of how I would imagine the type checker might work..
21:42:25 <Cale> because y f = f (y f)
21:42:37 <Cale> The two sides of the equation must have the same type
21:43:02 <faxlore> Why?
21:43:19 <jfredett> because they're equal
21:43:23 <Cale> Because if two things are equal, they have the same type.
21:43:38 <jfredett> if x == y, then the type of x is equal to the type of y
21:44:05 <ddarius> jfredett: This is basic Hindley-Milner type inference.
21:44:16 <ddarius> You can code it in like five lines of Prolog.
21:44:24 <jfredett> ddarius: i'm aware of that
21:44:25 <faxlore> does my reasoning in that paste match what haskell does?
21:44:38 <faxlore> although I have the wrong answer...
21:44:40 <Cale> faxlore: yes, but it's not quite finished
21:45:23 <Cale> faxlore: You get another constraint from the fact that the result of y f is equal to the result of applying f
21:45:36 <ddarius> faxlore: The last step is the return value of f needs to be the same type as the return value of y f.
21:46:05 <faxlore> I don't see that working
21:46:14 <faxlore> if I have, {f :: ?2 -> ?3, y :: (?2 -> ?3) -> ?2}
21:46:17 <Cale> Okay, suppose we write:
21:46:22 <Cale> x = (5 :: Integer)
21:46:31 <faxlore> then the result of y is ?2, and that equals the parameter of f's type
21:46:33 <Cale> What type must x have?
21:46:39 <faxlore> Integer
21:46:48 <Cale> okay
21:46:57 <Cale> Suppose that square :: Integer -> Integer
21:47:01 <MyCatVerbs> dons: oh, that reminds me. How about a retard-friendly tutorial on setting things up to work nicely with Cabal? I could really do with one. :)
21:47:02 <Cale> y = square 5
21:47:08 <Cale> what type does y have? :)
21:47:38 <ddarius> dons: What the hey, it's something and shouldn't take too long.
21:47:52 <Cale> (I'm going somewhere with this, I promise :)
21:47:58 <faxlore> (Integer -> Integer) $ (Integer) = Integer, so y has type integer
21:48:05 <faxlore> I don't have .. good notation for this
21:48:06 <Cale> right
21:48:24 <Cale> Now, y x = square x
21:48:32 <Cale> What's the type of y?
21:48:52 <faxlore> y x = square x -> y = square, y as type Integer -> Integer since square does
21:49:03 <faxlore> has*
21:49:08 <Cale> How about without eta reducing? :)
21:49:18 <Cale> (Of course, you get the same result)
21:49:34 <Cale> It must be a function, since it takes a parameter
21:49:37 <MyCatVerbs> :t let y f = f (y f) in y (+2)
21:49:46 <lambdabot> forall a. (Num a) => a
21:50:08 <Cale> x :: Integer, since square is being applied to it
21:50:08 <jfredett> though, couldn't you eta reduce the y f = f (y f)? i'm no type theorist, but I think y = f y is the same thing, as y = f (y f), no?
21:50:15 <MyCatVerbs> Oh hey, that acts like fit.
21:50:16 <Cale> and square x :: Integer
21:50:22 <Cale> So y :: Integer -> Integer
21:50:30 <ddarius> jfredett: No.
21:50:34 <faxlore> not sure Cale
21:50:38 <MyCatVerbs> Cale: Num a => a, since it works for any numerical type? ;)
21:50:39 <jfredett> ddarius: okay
21:50:41 <faxlore> I mean.. It's obvious
21:50:52 <faxlore> but I don't know how to step through it explicitly
21:51:02 <Cale> MyCatVerbs: and will pretty consistently give you bottom, though not for sufficiently lazy numeric types :)
21:51:09 <Cale> okay
21:51:15 <Cale> Let's rewrite that as:
21:51:19 <MyCatVerbs> *that acts like fix
21:51:24 <Cale> y = \x -> square x
21:51:25 <BMeph> More like y = f . y
21:51:27 <faxlore> ohh
21:51:41 <ddarius> MyCatVerbs: y is fix
21:51:41 <MyCatVerbs> Cale: yeah, that didn't take long to hit me. More useful would be...
21:51:50 <MyCatVerbs> > let y f = f (y f) in y (1:)
21:51:53 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:51:57 <ddarius> BMeph: And where is the f coming from?
21:52:04 <MyCatVerbs> ddarius: heh. So *that* is why the type seemed so similar to fix. :)
21:52:15 <BMeph> ddarius: Exactly! ;)
21:52:22 <Cale> > let y f = f (y f) in y (\f n -> if n == 0 then 1 else n * f (n-1)) 10
21:52:23 <lambdabot>  3628800
21:52:47 <MyCatVerbs> ddarius: so wouldn't that make it possible to confuse the *crap* out of people by using \recurse->foo functions with fix instead of an identical function actually *called* y? =)
21:53:00 <faxlore> y = \x -> (square :: Int -> Int)$x   ...   y = \x -> (Int -> Int)$(x :: Int)   ...   y = \(x :: Int) -> (Int -> Int) (Int)   ...   y = \Int -> Int,     y :: Int -> Int
21:53:05 <faxlore> er sorry a bit long
21:53:07 <Cale> > fix ((0:) . scanl (+) 1)
21:53:08 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:53:12 <faxlore> that sort of works out though
21:53:29 <MyCatVerbs> ddarius: ...actually, when you put it like that, it makes fix easier to understand in terms of y, rather than y easier to understand in terms of fix. fix used to vaguely break my brain. :)
21:53:38 <Cale> faxlore: You have strange notation, but it works :)
21:53:42 <MyCatVerbs> @index fix
21:53:42 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
21:53:43 <ddarius> @src fix
21:53:43 <lambdabot> fix f = let x = f x in x
21:53:53 <faxlore> I would adapt to any clearer notation :D
21:54:09 <Cale> faxlore: the usual approach is, as you did in your paste, give type variables to all the subterms right off, then write down the equations
21:54:15 <ddarius> fix f = x where x = f x, substituting, fix f = f (fix f)
21:54:33 <MyCatVerbs> @src mfix
21:54:34 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
21:54:45 <LoganCapaldo> @type mfix
21:54:46 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
21:54:54 <Cale> (y :: ?0) = (\(x :: ?1) -> (square :: Integer -> Integer) (x :: ?1)) :: ?0
21:55:02 <ddarius> It's easy to see what fix is doing.  Unfold the definition: fix f = f (fix f) = f (f (fix f)) = ...
21:55:04 <Cale> er, I should start out with:
21:55:14 <dons> MyCatVerbs: so there's a very thorough tutorial on development with cabal, http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
21:55:20 <Cale> (y :: ?0) = (\(x :: ?1) -> (square :: Integer -> Integer) (x :: ?1)) :: ?2
21:55:24 <dons> i should up date that with more info
21:55:43 <Cale> and the first thing you do is to say ?0 = ?2
21:55:50 <faxlore> Yes
21:56:16 <MyCatVerbs> dons: k, I've read that and I had one or two problems with it - pieces that seemed to be "black holes", where I could see that stuff had been done but had no idea what the author was doing.
21:56:32 <Cale> The typing rule for applications is that if  (f :: a -> b) and (x :: a) then f x :: b
21:56:32 <dons> MyCatVerbs: ok. so a simpler guide
21:56:44 <dons> MyCatVerbs: might also be worth just looking at stuff on hackage
21:56:45 <Cale> er, and I forgot a subexpression:
21:56:50 <faxlore> ohh
21:56:56 <Cale> (y :: ?0) = (\(x :: ?1) -> (square :: Integer -> Integer) (x :: ?1) :: ?3) :: ?2
21:57:01 <MyCatVerbs> dons: ...belay that. My complaints appear to have already been addressed.
21:57:03 <faxlore> I see where all the rules for this come from then
21:57:20 <Cale> So we have ?1 = Integer, and ?3 = Integer
21:57:20 <Cin> oh, cool tutorial. thanks dons
21:57:32 <LoganCapaldo> @type let mfix f = (mfix f) >>= f -- why is there a MonadFix class?
21:57:33 <lambdabot> <command line>:
21:57:33 <lambdabot>     Could not find module `L':
21:57:33 <lambdabot>       Use -v to see a list of the files searched for.
21:57:42 <LoganCapaldo> @type let mfix f = (mfix f) >>= f in mfix-- why is there a MonadFix class?
21:57:43 <lambdabot> forall b (m :: * -> *). (Monad m) => (b -> m b) -> m b
21:58:05 <Saizan> LoganCapaldo: that's not the same
21:58:06 <Cale> and then the typing rule for lambda is that if x has type a and y has type b, then (\x -> y) :: a -> b
21:58:17 <Cale> So then the lambda has type Integer -> Integer
21:58:28 <Saizan> LoganCapaldo: with the real mfix the sideeffects of f are performed only once
21:58:28 <LoganCapaldo> not the same as what?
21:58:45 <LoganCapaldo> i see
21:58:49 <Cale> faxlore: So coming back to y f = f (y f)
21:59:16 <faxlore> there are typing for = , applications, abstractions
21:59:20 <faxlore> is that everything?
21:59:26 <faxlore> typing rules*
21:59:34 <MyCatVerbs> faxlore: typing rules?
21:59:45 <MyCatVerbs> faxlore: you mean interfaces like Eq, Ord and so on?
21:59:57 <Saizan> MyCatVerbs: type inference rules
22:00:02 <Cale> There's a separate rule for let
22:00:04 <MyCatVerbs> Saizan: ah.
22:00:12 <Cale> and there are typing rules for case
22:00:26 <Cale> It depends on the language.
22:00:57 <Cale> In Haskell, things are already pretty complicated, especially with all the typeclass stuff, and in GHC, even moreso.
22:01:07 <Cale> But the basics are pretty simple.
22:01:36 <faxlore> oh
22:01:45 <faxlore> then, when you define a recursive function
22:01:45 <Saizan> Cale: let doesn't have more rules than toplevel '=', right?
22:02:03 <Cale> Saizan: a module as a whole acts as one big let
22:02:32 <EvilTerran> can you have datas and instances and stuff in a let?
22:02:33 <Saizan> yeah :)
22:02:48 <Cale> EvilTerran: It would be nice, but no.
22:03:02 <EvilTerran> not quite like one big let, then. ah well. =/
22:03:05 <Saizan> well data and instances don't have a type though :)
22:03:21 <EvilTerran> sorry i've not read the scrollback
22:03:22 <ddarius> Saizan: Just move all that stuff outside the let and all the top-level bindings inside.
22:03:37 <ddarius> er EvilTerran
22:03:38 <Cale> There's also all that crap about the monomorphism restriction and pattern bindings. :)
22:04:05 <faxlore> :t test (Just x) = x ; test Nothing = (test (Just 3), test (Just "foo"))
22:04:07 <lambdabot> parse error on input `='
22:04:13 <faxlore> :t let test (Just x) = x ; test Nothing = (test (Just 3), test (Just "foo")) in test
22:04:14 <lambdabot>     Occurs check: cannot construct the infinite type: t = (t, t1)
22:04:14 <lambdabot>       Expected type: Maybe (t, t1) -> t
22:04:14 <lambdabot>       Inferred type: Maybe (t, t1) -> (t, t1)
22:04:26 <faxlore> this means that, recursive definitions are not usiung let are they?
22:04:32 <faxlore> It's more simple, just like equality
22:04:51 <Cale> let is where polymorphism comes in
22:05:14 <faxlore> (similar to (\x -> (x 3, x "foo")) id, vs let x = id in (x 3, x "foo")
22:05:25 <Cale> right
22:05:35 <Cale> The latter is fine, the former is not.
22:06:12 <ddarius> polymorphic recursion
22:06:20 <Cale> Because generalisation happens in the typing rule for let -- the free type variables get forall'd.
22:06:26 <faxlore> so is it that, which lets me say, since y f = f (y f) the return type of y = the return type of f?
22:06:37 <Cale> No, that's much simpler
22:06:51 <Cale> The expressions on either side of the = sign have to have the same type.
22:07:46 <Cale> Just like when we wrote x = (5 :: Integer)
22:07:56 <Cale> We knew that x must also have type Integer
22:08:00 <MyCatVerbs> dons: the biggest problem I have with Haskell is that, dammit, I feel embarrassed hanging around so many people so many orders of magnitude smarter than I am. Still, humility for the win. ^_^
22:08:33 <Cale> MyCatVerbs: Haskell makes you smarter, you just have to wait :)
22:08:43 <cjb> MyCatVerbs: likewise :)
22:09:08 <Cale> But if people are interested in this stuff, TaPL is the book to get.
22:09:10 <MyCatVerbs> dons: 'side from that, the problems I have seem to be distressingly temporary, as people keep nailing them with these concise and wonderful solutions that just spring up out of nowhere in the space of six damn months or less. :)
22:10:11 <Cale> MyCatVerbs: Problems of what sort?
22:10:30 <faxlore> cool
22:10:32 <faxlore> that makes perfect sense
22:11:00 <MyCatVerbs> Cale: oddly, I've never read anything dead-tree on Haskell. Well, I've been reading Chris Okasaki's book on functional data structures, but that's it.
22:11:23 <ddarius> MyCatVerbs: I've never read anything "dead-tree" on Haskell.
22:11:24 <MyCatVerbs> Cale: things like the build system being a pain, which just totally melted.
22:11:33 <hpaste>  faxlore annotated "typing y" with "finishing it" at http://hpaste.org/4962#a1
22:11:33 <hpaste>  faxlore annotated "typing y" with "finishing it" at http://hpaste.org/4962#a2
22:11:34 <MyCatVerbs> ddarius: three cheers for LaTeX.
22:11:38 <faxlore> oops sorry
22:11:41 <ddarius> In fact the only paper things I've read on programming were a Java book and a C# book.
22:12:06 <faxlore> thanks Cale!
22:12:30 <Cale> MyCatVerbs: TaPL unfortunately uses ML as an implementation language rather than Haskell. It's not long before they abuse exceptions ;)
22:12:41 <MyCatVerbs> I used to devour dead-tree books from my local library. Which, when I did finally read *one* dead tree book that was actually any good, was what made me realise that >95% of the literature on programming is total dogshit.
22:12:54 <MyCatVerbs> Cale: TaPL?
22:13:00 <shapr>  Has anyone ported it to Haskell?
22:13:01 <ddarius> @where tapl
22:13:02 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
22:13:04 <Cale> But mostly the implementation language doesn't matter, since TaPL is mostly theory.
22:13:14 <shapr> Too bad it's not like Okasaki's book, with both implementations included.
22:13:18 <MyCatVerbs> ddarius: thanks.
22:13:45 <MyCatVerbs> Cale: from what I can tell, most of the time, the exceptions can be factored out anyway.
22:13:46 <shapr> Oh, edwardk loaned me a great book today that includes the ARIES paper. Much spiffiness!
22:14:05 <ddarius> ARIES paper?
22:14:09 <Cale> MyCatVerbs: yes, it's just mildly upsetting.
22:14:48 <shapr> ddarius: I think it's http://carlstrom.com/stanford/quals/mirror/swig.stanford.edu/pub/summaries/database/aries.html
22:14:49 <lambdabot> Title: Aries, http://tinyurl.com/2826vz
22:15:30 <MyCatVerbs> Cale: for example, where Okasaki suggests using exceptions to allow insertion into a treeset already containing an element to return the original tree, rather than a dumb path-copy of the tree, you'd just instead use a little function in a where or a let clause to keep the original tree in scope (without having to manually pass it all the way down the recursion)
22:17:06 * ddarius now simply needs to solve âg(r) = Î´(r) where r = x 
22:17:39 * ddarius now simply needs to solve âg(r) = Î´(r) where r = x - x' and â is with respect to x and is the vector derivative in Minkowski space.
22:20:13 <MyCatVerbs> ddarius: funnily enough, that clarification didn't actually clarify anything for me. This is what I mean about hanging around with people so obviously smarter than I am. ;)
22:20:36 <ddarius> What clarification?  I just accidentally hit enter too soon.
22:21:32 * faxlore also has no idea what those equations are ...
22:24:58 <Cale> I don't know what Î´ is.
22:25:06 <ddarius> The Dirac delta function.
22:25:34 <Cale> hmm
22:27:44 <soduko> has a value of 1 at 0 and 0 elsewhere
22:28:35 <ddarius> soduko: It doesn't have the value 1 at 0, rather it is infinite there.
22:29:01 <soduko> i stand corrected, i jumped the gun its infinity
22:29:33 <sebaseba> 1 at 0 would be the Kronecker delta
22:29:44 <soduko> yups:)
22:30:07 <ddarius> sebaseba: Yes, which can be viewed as a discrete version of the Dirac delta
22:30:11 <soduko> of late i have been running into these functions too:) jitter analysis
22:30:41 <TomMD> @messages
22:30:41 <lambdabot> You don't have any new messages.
22:31:41 <cjb> Dirac delta function:   "What's zero times infinity? Well, one answer to that question is kind of '1'."
22:31:58 <LoganCapaldo> @tell TomMD you don't have any messages
22:31:58 <lambdabot> Consider it noted.
22:33:29 <faxlore> It's kind of strange
22:33:40 <faxlore> using -> for type arrow and also in a lambda abstraction
22:34:07 <ddarius> Often mathematicians use a notation x â¦ f(x)
22:34:20 <LoganCapaldo> i dunno about strange, value -> value, type -> type
22:34:50 <ddarius> That said, the lambda calculus usually uses the notation Î»x.x instead of \x -> x
22:35:39 <Cin> Î»(x,_)[].x would look weird :P
22:35:46 <LoganCapaldo> Same thing happens with tuples, and to a lesser extent, lists
22:35:50 <Cin> albeit cool
22:41:51 <MyCatVerbs> Cin: well, it'd certainly motivate me for one to switch to using mlterm  :)
22:43:15 <LoganCapaldo> i prefer hsterm
22:46:40 <MyCatVerbs> LoganCapaldo: ehhh?
22:46:53 <LoganCapaldo> small joke :)
22:47:05 <Cale> It would be nice to use â¦ for lambda calculus, but then we'd have nothing to name the calculus after.
22:47:18 <ddarius> I prefer lambda notation.
22:47:32 <MyCatVerbs> LoganCapaldo: the "ehhhh?" was because that didn't show up on Hackage. :P
22:47:59 <Cale> In fact, the lambda notation started out as a typographical hack: he originally wanted to put a hat over the bound variable, but those weren't available.
22:48:15 <ddarius> I know the story.  It was a fortuitous occurence.
22:50:00 <Cale> (f â¦ (x â¦ f (x x)) (x â¦ f (x x)))
22:50:36 <LoganCapaldo> Y would you do sucha thing
22:52:23 <Cale> I actually think that looks nicer, myself :)
22:53:32 <soduko> right anchor calculus instead of lambda calculus :)
22:53:45 <Cale> heh, \mapsto calculus
22:54:10 <Cale> But right anchor is cooler :)
22:54:39 <ddarius> Lambda, to me, allows a more compact notation without looking wrong, e.g. Î»xy.x xyâ¦x looks wrong, I'd expand it to x y â¦ x which looks more ambiguous to my eye than the lambda version.
22:55:40 <Cin> a function that takes x and y or x applied to a function that takes y?
22:56:01 <Cale> Heh, a function which takes an application of x to y and produces x ;)
22:56:18 <Cale> That won't do
22:56:19 <Cin> heh
22:56:28 <Cale> But I think you'd get used to it.
22:57:02 <Cin> cale: people get used to Perl code :)
22:57:03 <Cale> Just like Î»xy.x probably looked strange the first time someone wrote it.
22:57:57 <ddarius> I'd get used to it, but I'd still never write xyâ¦x.  I'd be more inclined to write (x,y) â¦ x
22:58:18 <soduko> how do i generate a random realnumber with a fixed width? basically im trying to generate the zero crossings for a signal
22:58:39 <atp> i have a question about mutable arrays in the ST monad.  I'm looking at this type: runSTArray :: Ix i => (forall s . ST s (STArray s i e)) -> Array i e ... to me this looks as if runSTArray passes e through untouched
22:58:46 <atp> in particular, if e itself is a mutable array
22:58:51 <atp> what happens?
22:59:39 <atp> what if my type looks like ST s (STArray s i (STArray s i e)) ?
22:59:44 <atp> (ie, an array of arrays?)
23:00:04 <ddarius> atp: The s will need to be in scope and it won't be in Array i e = Array i (STArray s i e)
23:00:30 <ddarius> You'll get an error like "type variable s escapes"
23:00:38 <atp> ah...
23:00:47 <atp> so the type system catches it, huh :)
23:00:49 <atp> smart
23:01:01 <ddarius> That's the whole magic of the type of runST(Array)
23:01:44 <atp> pretty cool :)
23:03:00 <czakey> yaaawn
23:03:05 <czakey> hi there
23:22:11 <ramza3> should I use Data.Time.Clock.POSIX to get the epoch time in seconds; or can I just take the first integer from ClockTime?
23:23:57 <dons> utcTimeToPOSIXSeconds ?
23:24:45 <dons> that's in import Data.Time.Clock.POSIX
23:25:37 <ramza3> yea
23:31:49 <ramza3> external library...ok
23:34:33 <dons> everything's an external library :)
23:34:54 <dons> except for the Prelude, and a bit of System.IO , pretty much
23:35:10 <faxlore> can you make a terniary infix constructor? :S
23:35:18 <faxlore> ternary* sorry
23:35:52 <dons> well, ...
23:36:32 <dons> you can't define a single mix-fix operator, but certainly, something like (f :*: g) x = ... is ok
23:39:00 <ddarius> You can define multiple binary operators that work in concert to give the impression of a ternary operator.
23:39:35 <dons> yeah, ? : sometimes get done like this for infix if-then-else
23:39:53 <dons> there's also Okasaki's paper on postfix operators, if you swing that way
23:40:48 <MyCatVerbs> Maybe it'd be helpful for newcomers to mention that (if foo then bar else baz) in Haskell works just like (foo?bar:baz) did back in C class. :)
23:41:10 <faxlore> postfix? :o
23:41:29 <faxlore> http://portal.acm.org/citation.cfm?doid=581690.581699
23:41:29 <MyCatVerbs> It might at least clear up the immediate frustration over, "why does *every* if statement *have* to have an else clause, dammit?"
23:41:31 <lambdabot> Title: Techniques for embedding postfix languages in Haskell
23:41:36 <ddarius> @google typed quote/antiquote
23:41:37 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/publications/Quote.pdf
23:42:35 <MyCatVerbs> dons: which reminds me to ask, I have vague memories of you saying that Data.Graph is somewhat evil. Why? Or have I got the wrong end of the stick?
23:42:52 * MyCatVerbs has been curious about this for some time now. :)
23:44:06 <dons> oh, its a research project. so untested in serious scenarios
23:44:18 <dons> ok for little jobs, but pre-haddock, so under documented
23:44:27 <dons> oh, and that's just Data.Graph.FGL
23:44:34 <dons> i don't think anyone uses Data.Graph itself
23:45:14 * MyCatVerbs blinks.
23:45:19 <MyCatVerbs> Is that all? It's underdocumented?
23:45:49 <MyCatVerbs> Untested, true, but presumably it's unlikely to give incorrect results?
23:46:04 <dons> that's fgl I was talking about. untested, seriously underdocumented. Data.Graph, is well documented, but rarely used
23:46:23 <dons> right. i'd just expect performance issues for large graphs (say, > 1000 nodes)
23:46:35 <dons> for fgl, that is. i've not used Data.Graph
23:47:28 <MyCatVerbs> dons: Ahhhh, I see.
23:50:09 <ivanm> why doesn't anyone use Data.Graph itself? not developed enough?
23:50:21 <ivanm> is fgl good enough for common graph-theory uses?
23:50:33 * ivanm was thinking of using it as part of his honours project
23:51:02 <dons> quite probably, for light workloads.
23:51:34 <ivanm> *nod*
23:51:35 <dons> i'm not sure what the current state of purely functional graphs is, maybe there's better data types waiting to be implemented
23:51:47 <ivanm> @google purely functional graphs
23:51:48 <lambdabot> http://en.wikipedia.org/wiki/Purely_functional
23:51:48 <lambdabot> Title: Purely functional - Wikipedia, the free encyclopedia
23:52:39 <ivanm> well, that was useless... :s
23:53:58 <Cin> anyone know where i can get a t-shirt with Î» on it?
23:54:23 <ddarius> There are quite a few on cafe-press related to various projects.  Or you can just make your own.
23:54:50 <Cin> ddarius: for how much?
23:55:50 <faxlore> What is better out of [(Var,Val)] and Context? (which is a type synonym)
23:55:52 <ddarius> Here's an example: http://www.cafepress.com/skicalc  the price should be representative
23:56:20 <ddarius> faxlore: Depends, probably the latter since that allows you to change implementation slightly easier and conveys intent.
23:56:24 <faxlore> aww... the good bit is on the wrong side
23:56:27 <Cin> ddarius: niiice :D
23:56:35 <Cin> ddarius: i want just a big one in the middle, heh
23:56:41 <faxlore> ok, thanks ddarius
23:57:39 <Cin> ddarius: this is a cool site. thanks for the link
23:58:34 <ddarius> Here's an xmonad shirt: http://87154.spreadshirt.com/us/US/Shop/Article/Index/article/2125373
23:58:36 <lambdabot> Title: xmonad inverse ~ Men's Heavyweight Cotton T-Shirt ~ David Lazar's Shop, http://tinyurl.com/2684pm
23:58:54 <ivanm> dons: do you know if anyone else has implemented a graph library?
23:59:04 <Cin> ddarius: that actually looks pretty sweet
