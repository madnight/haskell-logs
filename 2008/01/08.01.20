00:00:45 <ramza3> pheaver2, let me ask this; if I have  class AAA a where  testA :: a -> b ... is it impossible to set a type for b when I define the "instance" definition... wont I always get a compile error
00:01:27 <pheaver2> short answer: try it and see, heh
00:01:39 <glguy> If the class defines a function polymorphic in the return type
00:01:42 <ddarius> ramza3: You have class AAA a where testA :: forall b. a -> b
00:01:52 <glguy> individual instances won't be able to set that type
00:03:23 <sjanssen> ramza3: there is (essentially) only one valid defn. of that method -- const undefined
00:03:31 <ramza3> interesting
00:04:01 <glguy> if each 'a' is associated with a single 'b', you'd want: class AAA a b | a -> b where testA :: a -> b
00:04:05 <pheaver2> ramza3: yeah, the 'b' in testA must always be that universal 'b', and cannot be any more specific
00:04:16 <sjanssen> the only occupant of (forall b. b) is bottom
00:06:11 <ddarius> Or class AAA a where type F a; testA :: a -> F a or however it goes.
00:06:37 <glguy> That becomes feasible no earlier than 6.10 :)
00:10:37 <pheaver2> so... I'm still having this problem building Yi, so I'll post the problem one more time :0
00:10:41 <pheaver2> When I try to cabal build Yi (the latest version from darcs) on ghc-6.8.2, I get a "package can't be built on this system"... I get this message on both archlinux 32-bit and FreeBSD 64-bit.  Any thoughts?
00:11:23 <pheaver2> what i'd really like to know is how to interpret that error message
00:11:34 <pheaver2> it'
00:11:38 <pheaver2> it's kinda vague :p
00:12:01 <glguy> any hints in the .cabal file?
00:12:40 <pheaver2> i dunno, what am I looking for?  build-depends?
00:12:48 <pheaver2> i don't know what causes cabal to give that error message
00:14:36 <pheaver2> in the source for Cabal, the message is generated by this 'build' function in Distribution.Simple.Build: http://code.softwarefreedom.org/projects/backports/browser/external/with-debian/ghc6/current/libraries/Cabal/Distribution/Simple/Build.hs?rev=110
00:14:38 <lambdabot> Title: /external/with-debian/ghc6/current/libraries/Cabal/Distribution/Simple/Build.hs  ..., http://tinyurl.com/378bnv
00:14:53 <pheaver2> heh, thanks lambdabot...
00:15:12 <glguy> pheaver2: also, did you notice any custom main function in Setup.hs?
00:15:20 <pheaver2> oh yeah, there's one :)
00:19:08 <pheaver2> there's a build hook, which may be what's failing... don't know how to make it give me more information without modifying the Setup.hs file
00:19:55 <sjanssen> pheaver2: does --verbose give you any more info?
00:20:21 <pheaver2> nope
00:21:31 <pheaver2> sjanssen: I should clarify... I can get lots of info with runhaskell -v3 Setup.hs build, but nothing looks unusual
00:22:42 <pheaver2> and 'runhaskell Setup.hs build --verbose' gives almost no information, certainly nothing useful
00:24:10 <pheaver2> it's just frustrating that the error message is so vague and useless, ya know?
00:28:48 <ddarius> How did Lorentz get his name on exponential decay?
00:29:07 <glguy> ?yow
00:29:07 <lambdabot> I wish I was a sex-starved manicurist found dead in the Bronx!!
00:32:03 <dons> wow, ghc, stack overflow: use +RTS -K<size> to increase it
00:32:08 <dons> *ghc*
00:32:36 <ddarius> dons: A darcs build or a released version?
00:32:54 <dons> a released version, investigating.
00:33:13 <ddarius> I could easily see an infinite loop hiding in the type system.
00:33:38 <ddarius> Anything unusual about the code you are compiling?
00:33:43 <dons> or the rules engine
00:33:52 <dons> (this is the  stream fusion lib, lots of rules)
00:34:18 <ddarius> Ah.  That seems reasonable.  It doesn't get the breadth of testing that most of the rest of the compiler gets.
00:34:35 <dons> yeah
00:35:11 <dons> doesn't look like a bad leak, more just lots of stack.
00:35:25 <dons> 751M onproc/1 -         1:12 96.78% ghc-6.8.2
00:35:37 <ddarius> dons: What happens if you make a loop with RULES pragmas?
00:35:49 <dons> it just sits and spins
00:36:05 <dons> i might have made a complex loop without realising it though.
00:36:43 <ddarius> What if you have a RULE like f x -> f (f x) ?
00:38:57 <dons> well, didn't get far with that, ghc-6.8.2: out of memory (requested 1048576 bytes)
00:39:54 <dons> must have been an .hi file bug
00:39:57 <dons> goes through fine now.
00:51:27 <zx]treads> is there a way to delete a symbol from ghci? (like python's del )
00:52:56 <dons> you can just rebind it
00:53:18 <dons> x = undefined , for example. but it won't affect things bound to the old value
00:53:27 <dons> since we like referential transparency too much :)
00:55:57 <Taejo> that's one thing I don't like about GHCi; Abelson and Sussman specifically made top-level variables in the Scheme interpreter dynamic instead of lexical
00:57:48 <dons> i think that's the first time i've seen someone ask about that, here.
00:58:30 <Taejo> the idea is that you can say to yourself, I wonder if replacing foo with foo' will fix that bug
00:59:16 <faxathisia> Just make the change and :load
00:59:58 <ddarius> Taejo: The top-level variables aren't dynamic, they are lexical, but they are mutable.
01:00:20 <ddarius> (in Scheme that is)
01:01:29 <Taejo> ddarius: I'm not a Scheme programmer, so I'm sure you right, but I seem to remember the dynamic/lexical distinction from a \tU paper
01:01:54 <ddarius> In CL global variables are always dynamic.
01:01:57 * bos curses darcs yet again
01:06:35 <Cale> Taejo: Basically, don't rely too much on making bindings directly from the GHCi prompt. Put all your definitions in a file, and load it, keeping your editor window open alongside. :r from GHCi will reload everything, that way you can be sure changes are made consistently.
01:07:25 <Taejo> Cale: well, GHCi pretty much enforces that style
01:07:37 <Taejo> but Lisp interpreters don't
01:08:02 <faxathisia> Haskell and lisp are a lot different...
01:09:07 <Taejo> indeed they are
01:12:13 <ddarius> Taejo: There are problems and benefits of both approaches.
02:29:06 <levi13> @hoogle f a -> (a -> m b) -> m f b
02:29:06 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
02:29:07 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
02:29:07 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
02:41:54 <quicksilver> @tell kuribas pong
02:41:54 <lambdabot> Consider it noted.
02:42:37 <quicksilver> levi13: that looks rather like Control.Applicative.sequence
02:42:45 <quicksilver> levi13: Assuming you mean m (f b)
02:42:52 <quicksilver> :t Control.Applicative.sequence
02:42:54 <lambdabot> Not in scope: `Control.Applicative.sequence'
02:43:13 <quicksilver> :t Data.Traversable.sequence
02:43:13 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
02:43:19 <quicksilver> that's what I mean ;)
02:43:25 <quicksilver> :t Data.Traversable.traverse
02:43:25 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
02:43:33 <quicksilver> that one, even better
02:44:49 <levi13> thanks, I'll look at that one
02:46:18 <levi13> but, I'll need f to be an instance of traversable?
02:47:35 <kib> I'm trying to make the first Hutton's exercices : http://hpaste.org/5107
02:49:38 <desegnis> kib: You don't have to pattern-match on (:) if you just reconstruct the value on the right-hand side
02:49:54 <quicksilver> levi13: Yes. This is the exact purpose of traversable
02:50:06 <quicksilver> levi13: to abstract what it meants to be able to 'run' a monad over.
02:50:20 <quicksilver> levi13: (and reconstruct the original 'shape' with the answers)
02:50:30 <desegnis> kib: e.g. myRemove' is partial anyway, because of the use of tail
02:50:51 <levi13> ok, thanks. I was hoping to get it for free ;)
02:50:53 <kib> desegnis : sorry, I don't understand what you mean.
02:51:16 <levi13> but, i think if I need that function, implementing traversable will be a good thing
02:51:17 <desegnis> kib, just write  xs  instead of  (x:xs)
02:51:31 <kib> ok, thanks.
02:51:51 <kib> but do I really need all those parenthesis in myRemove' ?
02:52:34 <desegnis> kib, as for those parentheses, Haskell programmers are fond of the (.) operator, which is function composition
02:52:45 <desegnis> @src (.)
02:52:45 <lambdabot> (.) f g x = f (g x)
02:53:52 <kib> thanks, why not using 'Â°' ? It seems to me more 'natural'
02:54:42 <desegnis> Alas, Â° is not ASCII. And to be perfectly correct, the circle would have to be in the middle of the line, not above :)
02:55:21 <kib> yes, you're right but I can't use 'o' so I have to find another char :)
02:55:35 <quicksilver> there is a centered circle in unicode
02:55:40 <quicksilver> and you could use that if you wish
02:56:10 <kib> quicksilver : really ? cool...
02:56:40 <desegnis> Ah, that's the new GHC unicode stuff, right?
02:57:01 <kib> does anyone here use Yi ?
03:02:51 <mux> âˆ˜
03:25:21 <desegnis> > (id âˆ· Î± â†’ Î±) 5  -- But I fear lambdabot is not up-to-date on this?
03:25:21 <lambdabot>  Illegal character ''\136''
03:25:21 <lambdabot>  at "ˆ·" (column 6)
03:25:27 <desegnis> right.
03:26:00 <desegnis> But especially the âˆ· is fun :)
03:42:48 <quicksilver> desegnis: not very new.
03:42:56 <quicksilver> desegnis: ghc has supported unicode since 6.6 or even 6.4
03:43:09 <quicksilver> desegnis: lambdabot doesn't have UTF8 reading support though :)
03:44:56 <aFlag> it's cool to use real lambdas for lambda functions, althought in my keyboard \ is much faster to type :P
03:46:43 * RayNbow has no idea how to type a real lambda :p
03:47:10 <RayNbow> oh wait
03:47:27 * RayNbow starts JP IME
03:47:36 <RayNbow> Î»
03:48:11 <RayNbow> Windows' IME for the Japanese language knows that "ramuda" can also mean the symbol :p
03:53:25 <quicksilver> there are (at least?) two lambdas in unicode
03:53:41 <quicksilver> the one which is actually the greek letter 'l' and the maths symbol
03:53:47 <quicksilver> that's one of the odd things about unicode.
03:59:00 <ivanm> quicksilver: I would guess the reason is for fonts/progs that only implement/look at a specific portion of the specification...
04:01:41 <quicksilver> yes, it makes perfect sense, it's just odd
04:01:55 <quicksilver> typographically 'greek letters' are different from 'maths symbols'
04:02:00 <quicksilver> different spacing and so on
04:02:23 <desegnis> quicksilver, oh, since 6.4? That's definitely not so new :)
04:03:32 <desegnis> quicksilver, if we're unlucky, Unicode will soon have a Â»lambda calculus lambdaÂ« ;)
04:05:55 <desegnis> But there are definitely odd things in unicode. Â»FullwidthÂ« letters and symbols, for instance
04:07:59 <desegnis> As for lambdas, there's a small capital lambda that looks like a conjunction, namely á´§
04:14:36 <roconnor> @unmtl ContT r (StateT DNA (MaybeT (Writer [RNA])))
04:14:36 <lambdabot> err: Unknown MTL(1)
04:14:45 <roconnor> @unmtl ContT r (StateT DNA (ErrorT (Writer [RNA])))
04:14:45 <lambdabot> err: Unknown MTL(1)
04:14:57 <roconnor> @unmtl ContT r (StateT DNA (ErrorT (Writer [RNA])))a
04:14:57 <lambdabot> err: Unknown MTL(1)
04:16:05 <roconnor> @unmtl ContT r (StateT DNA (ErrorT () (Writer [RNA]))) a
04:16:05 <lambdabot> (a -> DNA -> (Either () (r, DNA), [RNA])) -> DNA -> (Either () (r, DNA), [RNA])
04:21:53 <dcoutts_> @seen dons
04:21:54 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 3h 24m 5s ago.
04:22:23 <roconnor> if I have c :: forall r, (a -> r) -> r, then does f (c id) === c f?
04:22:25 <dcoutts_> dons: so, those versions of the regex-* packages are in the haskell overlay, we could probably push them into portage proper
04:31:35 <Saizan> roconnor: c ~= \k -> k (x :: a), f ((\k -> k a) id) = f a = (\k -> k a) f = c f  ?
04:42:44 <RayNbow> <desegnis> As for lambdas, there's a small capital lambda that looks like a conjunction, namely á´§ <-- hmm, I can't see this character..
04:42:49 <RayNbow> which font are you using, desegnis?
04:43:44 <desegnis> RayNbow, Bitstream Vera I think
04:44:14 <RayNbow> I've tried copying that character to some editor and tried to view it in Arial Unicode, but it remained a square block
04:44:18 <desegnis> but I'm not sure whether pango falls back to another font
04:45:10 <mux> I was using bitstream vera fonts until recently, I believe those are the gnome default font, however the "dejavu" fonts are nearly the same but support a much wider range of unicode scripts
04:45:24 <mux> @google dejavu fonts
04:45:25 <lambdabot> http://dejavu.sourceforge.net/
04:45:26 <lambdabot> Title: sourceforge.netwiki Coming Soon!
04:50:21 <RayNbow> ah, Dejavu shows the symbol
05:04:52 <roconnor> Saizan: it is the first bit c ~= \k -> k (x :: a) that I am unsure of
05:06:57 <BSP_> does anyone know why i might get an error about not being able to find the FastTypes interface when I build GHC HEAD on Mac OS X Leopard?
05:08:51 <opqdonut> has the idea of a haskell-like language with every piece of data inside a functor and all actions inside a monad been discussed?
05:09:07 <opqdonut> of course with implicit identity functors and monads
05:09:29 <opqdonut> so one could do f `fmap` g `fmap` data regardless of whether data is [1,2,3] or 1
05:09:57 <opqdonut> additionally, concatenation could mean `fmap` which would be additionally nice
05:24:05 <larmeh> is there a comprehensive explaination of parsing in haskell?
05:24:47 <EvilTerran> opqdonut, so it's as if there's a type Id a = a; instance Functor Id where fmap = id --?
05:24:56 <EvilTerran> (if that were alloweD)
05:25:48 <desegnis> larmeh, what qualifies as a comprehensive explanation of parsing?
05:27:40 <Philippa> larmeh: truly comprehensive is tricky in any turing complete language, no?
05:27:44 <EvilTerran> opqdonut, if that's what you mean, it'd need a pretty big rethink of the type system, as that'd be seriously ambiguous as it is
05:28:17 <opqdonut> yes, of course
05:28:23 <Philippa> I don't know of anything that examines the most common libraries though. A lot of people just work through the non-haddock docs for Parsec (linked from the haddock) and use that
05:28:26 <opqdonut> i'm not saying it would fit into haskell
05:29:00 <EvilTerran> fmap (const 1) [[2,3],[4,5]]) = 1 or [1,1] or [[1,1],[1,1]]
05:29:22 <opqdonut> [1,1] right?
05:29:45 * roconnor votes for [[1,1],[1,1]]
05:30:00 <opqdonut> hmm
05:30:13 <Philippa> it'll be [1,1] by default
05:30:24 <opqdonut> well anyway i think it could be defined consistently
05:30:27 <Philippa> roconnor: that's kinda "deep fmap", no? You're mapping through two functors
05:30:35 <EvilTerran> > fmap (const 1) [[2,3],[4,5]]) -- opqdonut's right in haskell, but it'd be ambiguous
05:30:35 <lambdabot> Unbalanced parentheses
05:30:43 <EvilTerran> > fmap (const 1) [[2,3],[4,5]] -- ahem
05:30:44 <opqdonut> the implementation could just tag every value with the functor ("mapping strategy") that applies
05:30:46 <lambdabot>  [1,1]
05:31:05 <opqdonut> and the tags could be inferred like in haskell
05:31:42 <opqdonut> of course this would limit the type system to kinds *->* and *
05:31:42 <EvilTerran> you might be interested in a class i made called FunctorOf
05:31:45 <opqdonut> i guess
05:32:12 <EvilTerran> class FunctorOf a fa b fb | {- lots of fundeps -} where fomap :: (a -> b) -> fa -> fb
05:32:20 <opqdonut> hmmm
05:32:24 <EvilTerran> instance FunctorOf a a b b where fomap = id
05:32:34 <opqdonut> yep
05:32:42 <opqdonut> that would do it
05:33:00 <EvilTerran> instance (FunctorOf a fa b fb, Functor g) => FunctorOf a (g fa) b (g fb) where fomap = fmap . fomap
05:33:08 <EvilTerran> iirc
05:33:35 <EvilTerran> ISTR it requires UndecidableInstances
05:34:02 <EvilTerran> (and MPTCs, obviously)
05:35:27 <tibbe> how do I get cabal to link my haddock to Hackage instead of trying to find the local GHC docs?
05:39:51 <BSP_> fwiw i've fixed that problem with ghc on OSX i mentioned: i just had to compile fasttypes manually first, that seemed to be sufficient to let make work out the rest of the compilation order..
06:05:44 <kib> |/back|
06:12:23 <araujo> morning
06:40:18 <shag> @pl (\c -> prefixCase c (index s) q)
06:40:18 <lambdabot> flip (flip prefixCase (index s)) q
06:41:54 <olsner> hmm, reduceron 2 out-performs an *interpreter* on a PC, but are there comparisons with native-compiled code on PC?
06:48:49 <shag> @ (\c -> fromList c $ prefixCase c (index s) q)
06:48:53 <shag> @pl (\c -> fromList c $ prefixCase c (index s) q)
06:48:53 <lambdabot> ap fromList (flip (flip prefixCase (index s)) q)
06:52:28 <vincenz> tibbe: ping
07:01:39 <hpaste>  dcoutts pasted "hackage build reporting" at http://hpaste.org/5108
07:01:49 <dcoutts_> der_eq: ^^
07:02:27 <dcoutts_> and anyone else interested in helping with hackage build reporting and/or hackage QA
07:03:09 <dcoutts_> this is the issue of how do we gather and present useful info on the hackage site about the state of each package
07:03:39 <dcoutts_> so you know if the package is likely to work for you and to make sensible comparisons between packages
07:04:14 <olsner> heh, how about an hackage auto-builder?
07:04:49 <dcoutts_> olsner: yes, that's the idea. We want to make it possible for everyone to be a hackage auto-builder
07:05:12 <dcoutts_> using cabal-install to collect and send build reports to hackage
07:05:26 <dcoutts_> and hackage would present the info in a useful way
07:05:52 <dcoutts_> olsner: if you're interested in helping that'd be great
07:07:47 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/184
07:07:49 <lambdabot> Title: #184 (cabal-install should report build results to hackage server) - Hackage - T ...
07:09:13 <olsner> not sure I can actually be of meaningful help although I certainly like the idea
07:17:07 <olsner> are the {build, docs, test, install} things done separately or should it rather be something like buildOutcome :: Outcome; data Outcome = OK | Failed Stage String; data Stage = ...?
07:17:47 <dcoutts_> olsner: some are dependent on each other, others are independent
07:18:06 <dcoutts_> olsner: for example if a dependent package fails to build then we're stuffed
07:18:12 <dcoutts_> similarly if configure fails
07:18:35 <dcoutts_> but docs are only dependent on configure and test on build
07:19:13 <dcoutts_> so we might well get that build worked, but docs and tests failed
07:19:30 <dcoutts_> so it's not a simple linear phase thing
07:20:02 <olsner> buildOutcomeConfigure and buildUnresolvedDeps?
07:20:28 <TomMD> Does anyone know about Control.Concurrent.STM.old?  I asked on the ML but have no responses.  It seems to not exist at current.
07:20:49 <dcoutts_> olsner: right, those are missing
07:21:15 <dcoutts_> olsner: what I pasted is not the final say on the issue of what and how to represent the info :-)
07:22:10 <dcoutts_> olsner: perhaps the report should be structured according to the dependencies of the phases
07:22:32 <dcoutts_> olsner: eg if configure worked we get what deps were used, otherwise we get some info on why configure failed
07:23:20 <dcoutts_> olsner: ie nest the info we get from each stage
07:23:36 <dcoutts_> olsner: feel free to annotate that paste with your ideas
07:24:28 <larmeh> what does this mean ">.>"?
07:24:53 <EvilTerran> in what context?
07:24:56 <olsner> looking right (your right, i.e. the smiley's left)
07:25:25 <EvilTerran> if it's a smiley, it usually means "looking shifty", i find. often when in conjunction with the mirror image.
07:26:07 * EvilTerran looks around furtively to make sure he hasn't been spotted <.< >.>
07:26:39 <EvilTerran> if it's a haskell operator, i wouldn't be surprised if it's flip (.)
07:27:23 <waern> dcoutts: nesting the info makes sense
07:29:01 <larmeh> EvilTerran: no, it's not a smiley... it's a haskell function defined in the code i'm reading, so nevermind :)
07:29:21 <dcoutts_> waern: aye, want to update the design?
07:29:36 <EvilTerran> ok then. i'd wager the "." indicates it's some kind of composition
07:32:05 <waern> dcoutts_: I guess we'd need more records, e.g ConfigureOutput,
07:32:16 <waern> sorry
07:32:18 <waern> ConfigureOutcome
07:33:25 <HelgeS> Would Haskell be a suitable language for a real time audio program? (similar to a guitar tuner)
07:35:20 <waern> dcoutts: I'll annotate
07:35:21 <shapr> HelgeS: I think you could do it.
07:35:25 <Sizur> is there any way to mix two polyvatiadic functions without having to write out the type of one of the function expression? (i hope that made sense)
07:36:01 <HelgeS> shapr: Do you know of any such program?
07:36:24 <shapr> I know of signal processing libraries in Haskell.
07:36:48 <shapr> I don't know if FVision counts as a realtime application.
07:37:03 <HelgeS> shapr: But the real-time part? taking in audio and presenting results on a GUI?
07:37:05 <shapr> FVision was a computer vision lib/app.
07:37:29 <shapr> HelgeS: Yeah, you could do it if you used the Yampa approach to stay away from space leaks.
07:37:54 <shapr> But for the most part you won't need to apply that many IQ points to get a guitar tuner in Haskell.
07:38:02 <hpaste>  (anonymous) annotated "hackage build reporting" with "(no title)" at http://hpaste.org/5108#a1
07:38:55 <HelgeS> OK, I'll look up FVision and Yampa. So far, I don't know Haskell. I have Python and C++ as alternatives. Or perhaps LabView or Matlab.
07:39:43 <esnip> why when i unwrap an IO variable it assumes a new type?
07:40:28 <esnip> i mean if i have a function Maybe (View a) and i have a functio that returns IO(View a)
07:40:44 <esnip> it assumes is View a1
07:40:53 <esnip> why?
07:44:08 <EvilTerran> @paste -- esnip, can you show us what code's causing the trouble? i don't quite follo
07:44:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:45:11 <esnip> just a second
07:50:39 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5109
07:51:06 <esnip> EvilTerran: hpaste is the above
07:52:26 <EvilTerran> what's the definition of View?
07:53:17 <esnip> View :: Rep a b -> Type b -> View (Type a)
07:55:47 <vincenz> esnip: ths related to conal's stuff?
07:56:09 <esnip> ?
07:56:16 <EvilTerran> esnip, is that a GADT?
07:56:20 <esnip> yes
07:56:23 <vincenz> EvilTerran: seems lke it
07:56:49 <EvilTerran> i think the problem might be to do with the b there not appearing in the type of the constructed value
07:56:56 <esnip> Type is a GADT
07:57:07 <EvilTerran> ?index on
07:57:07 <lambdabot> bzzt
07:57:22 <esnip> but it doesn't need
07:57:27 <vincenz> on f g x y = f (g x) (g y)
07:57:29 <esnip> when i do from . to i return a -> a
07:57:54 <czakey> @src listenOn
07:57:55 <lambdabot> Source not found. There are some things that I just don't know.
07:58:08 <czakey> @src accept
07:58:09 <lambdabot> Source not found. :(
07:58:21 <EvilTerran> vincenz, i know, i was just trying to remember where it was in 6.8; Data.Function, apparently.
08:07:34 <vincenz> tibbe: ping
08:17:18 <esnip> EvilTerran: but what do u suggest I do?
08:17:38 <EvilTerran> esnip, i don't know, sorry
08:17:48 <esnip> :\ tks
08:24:49 <Saizan> esnip: are you using type families?
08:26:46 <esnip> i use a GADT Type which defines several types
08:26:49 <czakey> is there some ways to conert large c++ code into haskell code...?
08:27:01 <esnip> so i can comparae function
08:27:01 <esnip> s
08:27:16 <czakey> c2hs maybe
08:27:31 <esnip> to proof that from . to == id
08:27:31 <esnip> in this casa
08:27:31 <esnip> *case
08:30:10 <Heffalump> czakey: c2hs is for making Haskell wrappers for C functions, not for converting them
08:31:31 <czakey> you're right
08:33:45 <Saizan> esnip: yeah but you've Rule ~ (etc..) in the context
08:34:30 <esnip> yes that was trying to make explicit that rule also had Type a
08:34:44 <esnip> that's the definition of Rule
08:36:03 <EvilTerran> I was thinking that ~ looked a bit odd
08:36:14 <esnip> yes
08:36:19 <esnip> i'v tried everything :\
08:37:52 <Saizan> so Rule is not defined elsewhere?
08:38:51 <EvilTerran> Saizan, if that were the case, i'm pretty sure it'd have to start with a lowercase
08:38:58 <EvilTerran> as it'd be a type variable
08:40:05 <esnip> it's defined elsewhere
08:40:46 <esnip> type Rule = (Type a -> Maybe (View (Type a)))
08:40:57 <Saizan> ahAH!
08:41:13 <Saizan> EvilTerran: yeah
08:41:41 <EvilTerran> esnip, i'm confident there's no need for that ~ thing in the context
08:41:45 <Saizan> esnip: try using type Rule a = Type a -> Maybe (View (Type a))
08:42:12 <Saizan> and instead of the context, just (Rule a) as the first argument
08:42:39 <EvilTerran> you might still need a context of (Eq a,Show a,Typeable a)
08:43:12 <Saizan> type synonyms are not pure syntax macros, e.g. the 'a' in rule gets foralled
08:45:02 <esnip> i can't change the definition of Rule
08:45:12 <Saizan> why?
08:45:20 <esnip> is not only used here
08:45:48 <esnip> and it's a common library
08:45:49 <Saizan> are you sure that definition is what you want?
08:45:55 <EvilTerran> esnip, do you want the a in the defn of Rule to be forall.ed?
08:46:11 <esnip> yes
08:46:23 <EvilTerran> because, as it stands, it means type Rule = forall a. Type a -> Maybe (View (Type a))
08:46:28 <Saizan> well then you can't unify it with another 'a'
08:46:30 <EvilTerran> i'm not sure what you can do with that
08:47:45 <esnip> I'm sure that the definition is what i want to use, because what i have to prove is that
08:47:51 <esnip> a representation inside the Rule
08:48:11 <esnip> Rep a b {to: a->b, from:b-a}
08:48:24 <esnip> from . to == ID
08:48:48 <kuribas> quicksilver: ping
08:48:48 <lambdabot> kuribas: You have 1 new message. '/msg lambdabot @messages' to read it.
08:48:50 <Saizan> that doesn't mean you can't let a to be free?
08:49:05 <esnip> yes,
08:49:29 <esnip> but i'm just building a generic HUnit test function
08:49:42 <esnip> i can't change the library
08:49:42 <esnip> :\
08:50:22 <Saizan> i think you might need to get more familiarity with existentials to work with them then
08:52:02 <sclv> is there any test harness code floating around in a package that uses both hunit and quickcheck?
08:53:25 <sclv> on the other hand, introducing hunit code means another dependency, so i'm tempted not to use it...
09:07:22 <vincenz> > EOF
09:10:22 <dcoutts_> @botsnack?
09:10:45 <dcoutts_> lambdabot: gone awol?
09:12:08 <dcoutts_> waern: the ConfigureOutcome would need an alternative for failure
09:12:32 <waern> dcoutts: right
09:12:32 <dcoutts_> similarly for BuildOutcome
09:13:06 <waern> dcoutts: so is this to be reported from users running cabal-install's install command?
09:13:48 <esnip> can i use exists in context?
09:14:02 <EvilTerran> "exists"?
09:14:05 <dcoutts_> waern: right
09:14:07 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/184#comment:1
09:14:16 <dcoutts_> waern: I added a bit more info ^^
09:16:14 <dcoutts_> waern: oh, and we should record versions of important build tools in each report, eg happy/alex/haddock/c2hs etc
09:21:20 <waern> dcoutts_: right
09:36:06 <sclv> finally took the plunge and upgraded to 6.8.2 on OS X 10.4. I was worried after hearing all the issues, but this was utterly seamless! cmaeder++
09:44:28 <jwprox> Does anyone here have experience with writing distributed applications in haskell?
09:46:04 <sclv> jwprox: always better to ask your question first. someone usually chimes in.
09:48:01 <jwprox> What is the most mature distributed haskell implementation?
09:48:11 <jwprox> sclv: Thats basically what I'm shooting for ;)
09:48:44 <oerjan> and if no one does, you get one of those rare chances to say, "what a useless channel!  it's even worse than #c#", and leave in a huff
09:48:47 <sclv> by implementation do you mean library?
09:49:13 * oerjan saw that happen once
09:49:25 <oerjan> well, maybe not literally
09:49:55 <sclv> this might be a dumb obvious answer, but if you're doing anything production quality rather than for research, pretty much GHC is the only way to go.
09:51:07 <jwprox> Ok, so GHC has everything required for developing distributed apps built in by default?
09:51:09 <sjanssen> jwprox: there isn't a distributed version of Haskell that's freely distributed
09:51:15 <sjanssen> AFAIK
09:51:41 <pejo> jwprox, have you considered Erlang for your project?
09:51:47 <oerjan> a paradox, that...
09:52:00 <sjanssen> jwprox: there is GdH, which is based on an ancient version of GHC, and I'm not so sure that the code is generally available
09:52:03 <sclv> again, depends what you mean by distributed apps. if you want to serialize functions across a network, then, yeah, no easy way to do that.
09:52:26 <sclv> if you can reduce your problem to a subset of that, its very easy to do in typical ghc.
09:52:43 <jwprox> sjanssen: I was looking at GdH and looked pretty outdated, figured it was an old research project
09:53:24 <jwprox> By distributed I mean distributing the processing across multiple machines, yes
09:53:25 <sjanssen> jwprox: exactly
09:53:37 <pejo> jwprox, they have publications in 2007 about some version of GdH atleast, so the project isn't totally dead.
09:54:33 <jwprox> pejo: Cool, I have to look into Erlang, it has been open sourced right?
09:56:27 <pejo> jwprox, I think so, but you should probably try #Erlang for those kind of questions.
09:56:29 <olsner> sclv: you used the binary release (of 6.8.2) then?
09:56:54 <sclv> olsner: yep. now running cabal install on some typical packages, and it also works mostly like a charm.
09:57:16 <jwprox> pejo: Point taken
09:57:55 <phlpp> > let fold f v (x:xs) = x `f` (fold f v xs) where fold f v [] = v in fold (+) 0 [1,2,3]
09:58:08 <pejo> jwprox, wasn't trying to scare you off, just pointing out that we might not necesarily know the answers to your questions. :-)
09:58:36 <phlpp> eh
09:58:37 <jwprox> pejo: Yeah :) Thats the point I took heh
09:58:39 <phlpp> lambdabot down
09:58:56 <sclv> you should really ask if you need to serialize functions across a network though, or if you couldn't do the same thing in a simpler way.
09:59:33 <oerjan> phlpp: that probably should be ; rather than where
09:59:58 <phlpp> oh
10:00:01 <phlpp> :>
10:00:11 <oerjan> otherwise you are actually defining too different functions in different scopes
10:00:13 <allbery_b> [12:12] <-- lambdabot has quit (No route to host)
10:00:14 <phlpp> sorry
10:00:15 <oerjan> *two
10:00:30 <sclv> with Data.Binary as I understand it, almost anything else can be serialized easily. so as long as you don't want to pass, e.g., closures, you're all set.
10:00:33 <phlpp> oerjan: but, you have to admit, it _sounds_ very natural ;)
10:04:32 <duaneb> > let least x:xs = foldl (\a b -> if b < a then b else a) x xs in least [2..30]
10:04:54 <duaneb> hrm
10:05:00 <duaneb> anyone see anything wrong with that?
10:05:46 <twanvl> (\a b -> if b < a then b else a) == min
10:05:50 <byorgey> duaneb: you need parens around the (x:xs)
10:05:56 <duaneb> rather, let least x:xs = foldl (<) x xs in least [2..30]
10:05:57 <duaneb> thanks
10:06:09 <duaneb> > let least (x:xs) = foldl (<) x xs in least [2..30]
10:06:19 <oerjan> least = foldl1 min
10:06:23 <byorgey> duaneb: lambdabot isn't here though.
10:06:29 <duaneb> heh
10:07:26 <byorgey> foldl (<) won't work, though, since it's of type (Ord a) => a -> a -> Bool.
10:07:34 <byorgey> (<) is of that type I mean.
10:07:35 <duaneb> oh :(
10:07:55 <byorgey> as oerjan and twanval said, I think you want foldl min.
10:08:00 <duaneb> ok
10:08:02 <oerjan> or minimum
10:08:07 <oerjan> it's predefined :)
10:08:23 <duaneb> ok, works fine
10:08:32 <duaneb> yea, but I think in least, not minimum
10:08:40 <duaneb> plus, this gives me more haskell experience
10:08:43 <oerjan> foldl (<) is legal on Bool lists though...
10:10:11 <duaneb> oerjan: what'd be the use of that?
10:10:28 <oerjan> not quite sure yet...
10:10:52 <oerjan> x < True == not x
10:11:06 <oerjan> x < False == False
10:12:46 <oerjan> it calculates whether the list ends with an odd number of True's or not, i think
10:13:14 <vincenz> > foldl (<) [True]
10:13:25 <vincenz> oh right, lb is down
10:13:31 <oerjan> you want foldl1
10:13:33 <vincenz> and that should be foldl1
10:13:43 * vincenz was editing it when he realized lb was down and stopped
10:14:09 <byorgey> oerjan: sounds right.
10:14:25 <vincenz> oerjan: it's true for odd length
10:14:45 <oerjan> foldl1 (<) == odd . length . takeWhile id . reverse
10:14:50 <oerjan> i think
10:15:37 <vincenz> seems so
10:15:44 <oerjan> er except for the empty list.  make that foldl (<) False for all lists
10:16:01 <byorgey> Prelude Test.QuickCheck> test (\l -> (not . null $ l) ==> (foldl1 (<) l == (odd . length . takeWhile id . reverse $ l)))
10:16:04 <byorgey> OK, passed 100 tests.
10:17:05 <vincenz> byorgey: what about foldr1 and no reverse?
10:17:39 <oerjan> foldr1 (>) False probably
10:17:44 <byorgey> Prelude Test.QuickCheck> test (\l -> (not . null $ l) ==> (foldr1 (<) l == (odd . length . takeWhile id $ l)))
10:17:48 <byorgey> Falsifiable, after 3 tests:
10:17:50 <byorgey> [False,True]
10:18:06 <vincenz> and >
10:18:18 <byorgey> ah, right
10:18:27 <byorgey> yup, that works
10:19:11 <oerjan> hm True < undefined is undefined
10:19:18 <byorgey> well. such a useful function, I'll have to remember that one. ;)
10:26:13 <oerjan> x > False == x, x > True == False, so foldl1 (>) (x:xs) == x && not (or xs)
10:28:22 <vincenz> oerjan: sounds like a version of demorgan
10:30:16 <oerjan> i don't quite see how that's relevant...
10:31:07 <oerjan> perhaps if you put a not on the x.
10:31:54 <oerjan> foldl1 (>) (not x : xs) == not (or (x:xs))
10:32:39 <quicksilver> kuribas: pong
10:40:53 <nominolo> @seen bringert
10:41:11 <nominolo> > "hello?"
10:41:40 <Valodim_> :(
10:42:04 * oerjan wonders if Randroid is a lambdabot
10:42:06 <oerjan> @bot
10:42:15 <Randroid> Nope.
10:42:28 <oerjan> would have been very nice timing...
10:42:37 <Valodim_> so that leaves chanserv and hpaste
10:42:40 * Randroid is a real person sitting at a Panera and writing Objective C instead of Haskell at the moment.
10:42:55 <LoganCapaldo> blasphemy!
10:42:59 <Randroid> lol
10:43:26 <dylan> heh, another haskeller from .tpa.
10:43:28 <oerjan> Valodim_: clog and cmeme too, although they don't say much
10:43:45 <Randroid> .tpa?
10:43:50 <Valodim_> it doesn't matter, the world is sad and empty without \bot
10:44:08 <dylan> well, that looks an aweful lot like a connection to a T1-ish connection in Tampa, FL.
10:44:29 <Randroid> Oh, yeah. I'd have understood what you meant if you said TPA, but I've never seen ".tpa".
10:44:42 <dylan> fpa.fdn.com, that is.
10:44:47 <dylan> err, tpa.
10:45:02 <Randroid> There are other Haskellers in Tampa? I though this place was a wasteland of business developers. I don't even know any other Mac developers from Tampa.
10:45:27 <olsner> how small is Tampa?
10:45:30 <Randroid> I make my living by day writing C#, sadly, and every other programmer I personally know does so too.
10:45:40 <Randroid> Tampa's metropolitan area is about 2.5 million.
10:45:43 <dylan> Randroid: I win my bread by working with perl. :)
10:46:04 <dylan> But I'm not in Tampa, I'm in St. Pete.
10:46:26 <kaol> I escaped my PHP job. But I'm lacking on winning any bread.
10:46:34 <Randroid> dylan: Cool.
10:47:10 <Randroid> St. Pete isn't my style, but lots of people prefer it. I'm a thoroughly urban person. I feel at home in New York City and plan to move back there within the next couple years. :)
10:47:36 <dylan> Randroid: St. Pete would make a better New york than Tampa ever will.
10:47:49 <Randroid> Eh, maybe. :)
10:47:58 <dylan> Tampa civil planning is sort of like "ooh! money! sure you can build that there!"
10:48:12 <jadenbane> Hello, can anyone help me fix this function: my_map a b = a( head b ) : my_map  a (tail b)
10:48:32 <Randroid> I don't pay much attention. I spend my days at home or in Ybor at the Castle/Czar/etc.
10:48:37 <Randroid> Or at work.
10:49:40 <dylan> Randroid: anyway, the major conentration of geeks seems to be the Suncoast LUG meetings. Even then, there's only about 10 competent people that come to the meetings.
10:49:51 <Toxaris> jadenbane: what happens if b is []?
10:50:21 <jadenbane> head b = []    tail b = [] ?
10:50:34 <LoganCapaldo> incorrect! but nice try :)
10:50:42 <Toxaris> > head [] -- let's look what happens, jadenbane
10:50:44 <LoganCapaldo> @tpe head
10:50:51 <LoganCapaldo> @type head
10:50:52 <Deewiant> lambdabot's gone
10:50:54 <Valodim_> head [] or tail [] = beep
10:50:55 <LoganCapaldo> doh
10:51:07 <jadenbane> Haha.
10:51:08 <Valodim_> better use patterns, easier and cleaner
10:51:15 <jadenbane> Okay.
10:51:22 <jadenbane> *** Exception: Prelude.head: empty list
10:51:32 <LoganCapaldo> head :: [a] -> a, so head xs can only ever be [] when your list's type can be unified with [[a]]
10:52:20 <jadenbane> So I need something like      20 my_map a [] = [] ?
10:52:47 <vincenz> jadenbane: yes
10:52:48 <LoganCapaldo> IOW head [] = [] is not a result that would type check, ieven if that's how someone wanted to handle the empty lsit case for head
10:53:05 <jadenbane> *Test> my_map Char.toUpper "Hello"
10:53:05 <jadenbane> "HELLO"
10:53:07 <jadenbane> Yay.
10:53:18 <Deewiant> however tail [] = [] would work, but doesn't anyway :-P
10:53:34 <Deewiant> s/would/could/
10:53:37 <Valodim_> jadenbane: yes, although you can use _ for a there since you're not gonna use it in the expression
10:54:07 <jadenbane> Valodim_: Sorry - I don't follow what you mean
10:54:15 <Valodim_> my_map _ [] = []
10:55:04 <jadenbane> .Oh!
10:55:06 <jadenbane> I see.
10:55:08 <Valodim_> if you're not going to use a pattern variable in an expression, you can use _ to show it, that way it's obvious to the reader and a hint for the optimizer
10:55:25 <jadenbane> Sorry - I have been haskelling for ~45 minutes now :P
10:55:31 <Valodim_> :)
10:55:37 <jadenbane> So I need everything spoon fed to me.
10:55:42 <LoganCapaldo> Is _ really a hint for the imptimizer? i find that difficult to credit.
10:56:02 <Valodim> well I don't know if it makes any use but it would be a hint :P
10:56:11 <Valodim> (any use "of it")
10:56:14 <LoganCapaldo> s/imptimizer/optimizer/
10:56:24 <oerjan> the compiler could find out if a variable wasn't used anyhow
10:56:33 <Deewiant> since haskell doesn't have side effects I doubt the optimizer needs such a hint
10:56:43 <LoganCapaldo> oerjan: exactly
10:57:01 <Valodim> then just do it for readability, geez :P
10:57:05 <oerjan> but with _, the compiler may know whether or not to warn you if a variable is unused
10:57:07 <dcoutts_> yes, the desugarer just makes up a unique name for _'s
10:57:17 <dcoutts_> and ghc discovers unused vars automatically
10:57:17 <Deewiant> I find [x] often more readable than [_]
10:58:27 <sjanssen> Deewiant: the problem is scanning the RHS to make sure that x isn't used
10:58:47 <sjanssen> I'd prefer [_] for that reason
10:59:02 <Deewiant> true, if it's something longer it is better
10:59:24 <Deewiant> but in general that's for cases like "length [x] = 1" or whatever
10:59:59 <Deewiant> but you're right, if you don't want to think about it just always use [_] and you can't be wrong :-)
11:00:01 <jadenbane> Any Project Euler fans here?
11:00:23 <Deewiant> \o
11:00:47 <ddarius> jadenbane: Why are your parameters name a and b?
11:00:55 <Deewiant> although I've succumbed to laziness and used mathematica for most of my solutions...
11:01:09 <jadenbane> ddarius: Why not?
11:01:17 <LoganCapaldo> first two letters of the aplhabet?
11:01:18 <Valodim> \o
11:01:25 <ddarius> jadenbane: Because those names convey no information.
11:02:06 <Valodim> [20:00] Deewiant: although I've succumbed to laziness and used mathematica for most of my solutions...
11:02:06 <Valodim> that is strangely contradictive... ;p
11:02:16 <oerjan> haskell naming style needs to be learned like everything else...
11:02:18 <jadenbane> ddarius: my_map thefunctiotobeappliedtothefollowinglisthereaftercalledlist list would be too wordy
11:02:21 <Deewiant> Valodim: well, mathematica has builtins for a lot of handy stuff
11:02:48 <Valodim> true
11:03:13 <dons> dcoutts_: the regex-base and regex-posix packages are needed on the shootout machine. in particular, the new versions, regex-base-0.93.1, regex-posix-0.93.1. what's the best way to install those on gentoo?
11:03:15 <LoganCapaldo> Haskell programmers have a disturbing bent towards a form of hungarian notation (f, g, or h if it's a function, appending an s onto lists, etc.) ;)
11:03:19 <oerjan> jadenbane: arbitrary functions: f, g, h or something like that.  list names often end with s like xs
11:03:35 <dcoutts_> dons: I refer you to my eariler reply :-)
11:03:36 <jadenbane> oerjan: Fair enough.
11:03:40 <ddarius> jadenbane: The typical definition is: map f [] = []; map f (x:xs) = f x : map f xs
11:04:05 <dcoutts_> dons: the answer is either to use the overlay which has those versions or ask us to push the newer versions into portage
11:04:18 <ddarius> Without pattern matching: map f [] = []; map f xs = f (head xs) : map f (tail xs)
11:04:20 * dons checks the logs
11:04:21 <allbery_b> "hungarian notation"?  that stuff was invented by fortran, not microsoft
11:04:30 <dcoutts_> dons: s'ok, it's the same answer
11:04:43 <mux> map f = foldr ((:) . f) []
11:04:44 <ray> that's not any notation, that's common sense
11:04:45 <dons> dcoutts_: so what command would igouy need to use to get them from the overlay?
11:04:57 <jadenbane> mux: Sweeet.
11:04:59 <dons> if i can make it as straight forward as possible, he's more likely to say yes :)
11:05:04 <Deewiant> hungarian was originally implemented by a dude who later worked at microsoft
11:05:43 <Deewiant> and then microsoft developed their own hungarian notation which perverted the point of the original
11:05:59 <LoganCapaldo> Maybe smiley face isn't strong enough for in where. I need to start leading stuff off with [What follows is a joke and or kidding, please do not take it too seriously. Sincerly, the commitee for the prevention of misunderstanding of Logan Capaldo. (c) 2008]
11:06:05 <ddarius> allbery_b: Where did anyone say anythnig about Microsoft?
11:06:12 <dcoutts_> dons: it's probably more sensible for us to just put those updates into portage
11:06:20 <allbery_b> ddarius: see deewiant's commenrts
11:06:42 <LoganCapaldo> s/in where/in here/
11:06:46 <Deewiant> allbery_b: where did the "not microsoft" come from though :-P
11:06:49 <dcoutts_> dons: once you use the overlay you get the unstable versions of every haskell package, that might not be what he really wants
11:06:53 <allbery_b> ("Hungarian notation" is commonly understood to have been inveted by programmers at Microsoft, although strictly speaking Deewiant is correct)
11:07:04 <allbery_b> I ws shorthanding
11:07:08 <sjanssen> dons: will the 0.7x versions work?  IIRC, they're in portage alread
11:07:10 <sjanssen> y
11:07:10 <dons> ok, yes, that sounds right. we can just wait for them to be in portage.
11:07:26 <dons> sjanssen: oh, possibly, certainly useful.
11:07:43 <ddarius> allbery_b: Those comments came a minute or two after your original comment.  I'll just blame IRC.
11:07:45 <allbery_b> "Microsoft" vs. "a Hungarian professor best known for inspiring Mcrosoft to adopt a form of his notation"
11:08:15 <sjanssen> dcoutts_: is that right?  The versions that were released with GHC are stable in portage?
11:08:16 <dcoutts_> dons: as sjanssen says, we've already got the regex-* versions that were included in the ghc-6.8.x extralibs collection
11:08:26 <mux> yet another way with list comprehensions: map f xs = [ f x | x <- xs ]
11:08:37 <dcoutts_> sjanssen, dons: they're not stable, but ~arch, like ghc-6.8.x is.
11:08:59 <oerjan> mux: although that could end up being desugared to map again
11:09:05 <dons> ok. so hmm. the current entry uses the Regex ByteString instance, which is new, but we could work around it.
11:09:07 * mux nods
11:09:08 <Deewiant> as a beginner (well, more beginner than now) I used list comprehensions a lot, nowadays I don't use them at all
11:09:16 <dons> might be nice to get pcre-light in :)
11:09:29 <mux> yeah, list comprehensions don't blend well with point-free code often
11:09:31 <allbery_b> My point still remains:  that convention cmes from FORTRAN's implicit typing of variables by initial letter
11:09:35 <dcoutts_> dons: that's in the overlay too. If you need either in portage just say so.
11:09:52 <oerjan> technically concatMap (x -> [f x]) xs
11:10:06 <oerjan> er, concatMap (\x -> [f x]) xs
11:10:10 <allbery_b> (if not from mathematical convention that predates all of it)
11:10:13 <Deewiant> concatMap (return . f) xs
11:11:58 <desegnis> xs >>= return . f
11:12:07 <ddarius> liftM f xs
11:12:10 <oerjan> fmap f xs, full circle
11:12:12 <Deewiant> :-)
11:12:34 <mux> someone needs to mention <$>
11:12:45 <_frederik_> hello, how do i convert from the old Network.CGI to the new Network.CGI?
11:13:44 <_frederik_> there is no more 'wrapper', and cgi-compat depends on a package called 'fps' which I can't find anymore
11:13:56 <oerjan> fps -> bytestring
11:13:58 <allbery_b> fps is known as bytestring thee days
11:14:02 <cjb> _frederik_: 'lo.
11:14:07 <_frederik_> so basically cgi-compat is bit-rotted
11:14:10 <_frederik_> hello cjb
11:15:24 <_frederik_> i'm not sure what to do, it seems now there is a monadic interface but i don't see my old code using it, so does that mean i basically have to either change everything or upgrade cgi-compat myself?
11:26:18 <Cheery> whatfor binomial trees and heaps exist?
11:26:29 <dons> vegai: is anyone chasing up the broken arch linux xmonad package?
11:26:42 <dons> vegai: a couple of reports that the new ghc package has broken things
11:39:24 <phlpp> dons: broken?
11:39:55 <phlpp> ok, mine is about 3 days old, maybe it's _now_ broken
11:40:14 <phlpp> (my ghc package is 6.8.1-1)
11:40:23 <dons> apparently it updated to 6.8.2
11:41:29 <phlpp> oh
11:42:15 <phlpp> seems like a pacman -Syu is awaiting me
11:45:25 <litb> hello all
11:45:37 <HairyDude> hmm, no lambdabot
11:46:04 <litb> strange
11:46:43 <dons> ?bot
12:00:35 <dons> hehe, comment about haskell doing well on the shootout, "love Haskell. But i think these benchmarks make it look like there isn't a problem to be solved."
12:01:19 <mauke> bah. locks and threads don't mix :(
12:01:34 <Corun> Threads and memory don't mix :-)
12:01:41 <LoganCapaldo> it's true
12:02:01 <LoganCapaldo> locks and threads? I mean come on, they are't even from the same metaphor vocabulary set!
12:02:10 <mauke> I need something like lock files without the locks
12:02:21 <Deewiant> threads and needles?
12:02:25 <LoganCapaldo> If we were honest and called locks, knots, well things would be much better
12:02:38 <mauke> lock files don't work because waiting for a lock pauses all threads
12:02:57 <Nafai> dons: Where was that comment?
12:03:05 <smack__> isn't that the point of a lock?
12:03:23 <mauke> no
12:03:38 <mauke> it should only block the thread that is trying to get the lock
12:03:41 <LoganCapaldo> mauke: can you do the file lock in another process? (obvious suggestion i know)
12:03:55 <mauke> I'd rather not
12:04:11 <dons> Nafai: on a reddit thread about the shootout.
12:04:14 <mauke> forking in haskell isn't something known to work
12:04:22 <LoganCapaldo> mmmm
12:04:27 <LoganCapaldo> I was unawae of that
12:04:31 <LoganCapaldo> *unaware
12:04:32 <dons> some guy ranting that the haskell being fast there was making it look like haskell was fast, or something
12:04:54 <Saizan> mauke: even with -threaded?
12:05:02 <mauke> especially with -threaded
12:06:29 <mauke> http://article.gmane.org/gmane.comp.lang.haskell.cafe/30242
12:06:32 <gwern> hm. does it make sense to define a fold on a list where the function is a->b->c->d instead of a->b->c?
12:07:29 <oerjan> gwern: sure
12:07:31 <Saizan> gwern: a bit vague as a question.. what will c be?
12:08:12 <gwern> Saizan: I was wondering if partial application might serve - it would combine the two arugments and return a function which might eat the third argument
12:08:29 <LoganCapaldo>  f :: (a -> b -> c) . g :: (c -> d) :: (a -> b -> d) makes perect sense
12:09:05 <LoganCapaldo> err wait
12:09:07 <LoganCapaldo> me silly
12:09:16 <LoganCapaldo> that's not the same type <g>
12:09:59 <LoganCapaldo> t's not even the same question
12:10:37 <oskarM> > (+) . (1+)
12:10:45 <LoganCapaldo> I'm barely in teh right room
12:10:49 <oskarM> :t (+) . (1+)
12:11:24 <LoganCapaldo> I also used an imaginary definiteion of .
12:11:37 <LoganCapaldo> oskarM: lambdabot is not currently with us
12:12:25 <oskarM> oh, that's terrible :(
12:12:42 * gwern watches LoganCapaldo's successive series of relevations with amusement
12:13:21 <LoganCapaldo> it's sunday, I'm clearly not in programmer mode <g>
12:15:14 <dons> ?users
12:15:20 <dons> oh hmm.
12:16:18 <dons> hmm. can't connect
12:17:41 <LoganCapaldo> lambdabot is down! send assitance!
12:18:00 * LoganCapaldo makes siren noises
12:20:22 <allbery_b> the disconnect message said "no route to host" fwiw
12:22:44 <olsner> dons: aren't you on the same internet connection as lambdabot?
12:24:26 <dons> nope
12:25:46 <oerjan> "72.249.126.23 does not exist, try again"
12:25:59 <oerjan> that's where lambdabot last connected from?
12:28:47 * HairyDude ponders doing @seen lambdabot, but realises it wouldn't work. :)
12:29:57 <Jaak> 72.249.126.23 does not exist? it pings fine
12:30:42 <oerjan> hm...
12:31:00 <HairyDude> who's the admin for lambdabot?
12:32:32 <oerjan> hmph, no reverse lookup
12:33:18 <HairyDude> it's in a colo in Dallas, apparently
12:34:03 <byorgey> HairyDude: dons is.
12:34:32 <HairyDude> I see
12:34:57 <oerjan> colo is a technical term?
12:35:13 <HairyDude> short for colocation, a type of hosting
12:35:41 <oerjan> that explains the last readable traceroute line...
12:36:27 <olsner> ghc 6.8.2 now seems to build through the patched macport, at least it's gotten farther than I think it got yesterday.. although it's still only using stage1/ghc-inplace, so I guess I'm at best half-way through
12:37:09 <kuribas> quicksilver: My indentation engine is working!
12:38:30 <pejo> olsner, On 10.5?
12:38:55 <olsner> pejo: nope, 10.4
12:44:39 <Big_Red> does anyone use textpad?
12:45:41 <jsnx> Big_Red: no
12:45:53 <Big_Red> sigh
12:46:01 <jsnx> Big_Red: u r on windows?
12:46:05 <Big_Red> yeah
12:46:19 <byorgey> kuribas: congrats!
12:46:34 <jsnx> Big_Red: there are many editors availanble...you are looking for syntax highlighting/coloring?
12:47:33 * Stinger_ whispers "emacs"
12:47:40 <Valodim> subtle.
12:47:40 <Big_Red> i've got this one - was just trying to link it to hugs
12:48:01 <Big_Red> and i've learned not to ask advice on which editor to use on #haskell :P
12:48:19 <jsnx> you shouldn't do that editor/compiler thing -- where the errors are highlighted and all that stuff -- it raises productivity too much
12:48:34 <Valodim> vyimacs
12:48:48 <byorgey> hehe
12:48:52 <Big_Red> productivity is bad...
12:49:01 <mauke> http://www.vimacs.com/
12:49:07 <Stinger_> actually I should sit down and try yi again oneday
12:49:10 <Valodim> lacks yi
12:49:12 <ddarius> jsnx: It only affects productivity if you make errors.
12:49:50 <EvilTerran> @users
12:49:55 <Big_Red> so one last shot - anyone know about linking textpad and hugs
12:49:56 <Big_Red> ?
12:49:56 <EvilTerran> @bot
12:50:06 <jsnx> ddarius: but, on average, people make errors
12:50:10 <HairyDude> mauke: ENOTANEDITOR
12:50:11 <Vq^> @karma+ ddarius
12:50:30 <jsnx> ddarius: and it's the average productivity i'm worried about
12:50:31 <HairyDude> Vq^: no lambdabot atm
12:50:34 <Vq^> aw :(
12:50:35 <ddarius> jsnx: That's a silly thing for them to do.
12:50:53 <jsnx> because, if programmers improve in the main, then many of us will be out of a job
12:51:07 <jsnx> we should really have a union, to limit productivity
12:51:13 <jsnx> and work hours, &c.
12:51:34 <HairyDude> programmers don't usually need to improve in the main, they only need to improve in the subroutines.
12:51:36 <glguy> there will always be more programs to write
12:51:39 <Vq^> jsnx: there is such a union
12:51:46 <jsnx> Vq^: what?
12:51:47 <HairyDude> budum tssh
12:51:51 <Vq^> jsnx: i believe it's called java :o)
12:51:57 <jsnx> Vq^: lolz, no
12:52:43 <dons> glguy: hacking on some open source libs for haskell today? :)
12:53:22 <dcoutts_> dons: any chance you'll make it to the hackathon?
12:53:27 <glguy> no big plans yet, but who knows
12:53:29 <jsnx> Vq^: it limits productivity, but not work hours ;)
12:53:34 <dons> dcoutts_: yeah, i plan to.
12:53:35 <Vq^> glguy: nah, one day a Haskell compiler will get self aware, and then all program will appear instantanously
12:53:54 <jsnx> all programs are already in the digits of pi
12:54:09 <dons> dcoutts_: even if i have to take time off. oh, we should look at tshirts too.
12:54:09 <jsnx> we should just implement a lazy search over pi
12:54:10 <dcoutts_> dons: great :-)
12:54:14 <dcoutts_> dons: yes
12:54:15 <Vq^> jsnx: forgot about those damn hours :/
12:54:18 <dons> get all of jobs-in-fp.org sponsoring :)
12:54:34 <dcoutts_> dons: and perhaps try and get more people working on more similar things than last time
12:54:35 <jsnx> let's have an FP union, too
12:54:54 <jsnx> we'll need to push F# in to the sea before it takes over
12:55:00 <dons> dcoutts_: yep. we can start a list now of key things
12:55:11 <Big_Red> #haskell IS the FP union
12:55:21 <jsnx> Big_Red: we need dues
12:55:32 <dcoutts_> dons: let me add community packaging infrastructure at the top of that list :-)
12:55:34 <jsnx> Big_Red: we don't organize sit-ins or work stoppages
12:55:36 <Big_Red> jsnx: you want to PAY them?
12:55:53 <Big_Red> jsnx: and where would you sit in?
12:56:05 <dons> dcoutts_: yes.
12:56:08 <jsnx> Big_Red: for F#, we'd sit in redmond
12:56:15 <dcoutts_> dons: there is room for at least 10 people to work on about 4 aspects of that in parallel
12:56:26 <jsnx> oh, wait -- we'd have to sit in cambridge
12:56:44 <jsnx> "stop the ML forkage!"
12:56:44 <Big_Red> cambridge is nice
12:57:09 <Big_Red> REALLY pretty :)
12:58:11 <jsnx> also, once we have a real union, we can build connections with organized crime...
12:58:31 <Big_Red> ... organised crime and haskell - an UNSTOPPABLE union
12:58:34 <jsnx> ...to manipulate the results of financial markets, for example, by changing composition laws
13:00:01 <Japsu> pure crime without side-effects
13:00:23 <oerjan> the transparency may prove to be a mistake, though
13:00:31 <byorgey> dcoutts_: where/when is the hackathon?
13:01:37 <dcoutts_> byorgey: http://haskell.org/haskellwiki/Hac_2008/Dates
13:01:51 <kuribas> If someone wants to try out an early version of my indentation engine for emacs, you can find it here: http://kuribas.hcoop.net/haskell-indent.el
13:01:56 <olsner> hmm, stage1 is the ghc built by my bootstrap compiler from 6.8.2 sources, right? so the stage2 compiler I'm compiling now will be optimized by ghc 6.8.2? meaning I can expect the next stage to go faster by some percentage?
13:01:56 <oerjan> time to write Control.World...
13:02:10 <byorgey> oh, Sweden.
13:02:21 <byorgey> probably a little to far away for me =(
13:02:42 <jsnx> dcoutts_: you are in the EU?
13:02:47 <jsnx> dons: you are in the EU?
13:02:49 <dcoutts_> jsnx: UK
13:02:54 <jsnx> byorgey: you are in the states?
13:03:22 <Taejo> is there going to be an ICFP contest this year?
13:03:30 <ddarius> jsnx: dons just recently moved to Oregon
13:03:30 <olsner> ah, gothenburg! I hope some of those days are during the easter holiday
13:03:43 <jsnx> ddarius: oic
13:03:49 <ddarius> Taejo: There's an ICFP contest every year.
13:04:10 <Taejo> ddarius: do you know who's doing this year's?
13:04:11 <jsnx> i suppose we could have an north american co-hackathon
13:04:19 <Igloo> olsner: There's no benefit in doing more than 2 stages
13:04:22 <byorgey> jsnx: yep, in washington dc
13:04:27 <jsnx> byorgey: oic
13:04:43 <jsnx> have we polled to see whether that makes more sense than the west coast?
13:04:45 <gwern> kuribas: work on yi, not emacs. emacs is the *old* hotness
13:04:49 <ddarius> byorgey: If I still lived in the DC area that would be handy.
13:05:00 <ddarius> Taejo: No.
13:05:02 <jsnx> byorgey: or even new york, &c. ?
13:05:18 <jsnx> byorgey: there's a lot of crime in DC
13:05:29 <gwern> new york is good. don't we have a lot of financial types using haskell?
13:05:30 <jsnx> lobbying, election stealing, &c.
13:05:33 <kuribas> gwern: is yi already usable?
13:05:36 <byorgey> jsnx: hehe, true =)
13:05:50 <olsner> Igloo: the idea is that the original compiler may have miscompiled the stage1 compiler (such that the stage2 compiler will be incorrect), so some people (eg gcc) build another stage to double-check
13:05:50 <jsnx> gwern: you are in the states? what state?
13:06:10 <jsnx> gwern: i suspect that many of the people on this channel are on the west coast...
13:06:17 <jsnx> ...but i don't know
13:06:20 <gwern> kuribas: if you're good enough to write a good indentation engine, then you're probably good enough to improve yi, no?
13:06:20 <olsner> ghc doesn't seem to do that though
13:06:29 <gwern> jsnx: mm. could just poll them maybe?
13:06:42 <jsnx> gwern: yes
13:06:46 <gwern> isn't there a chart somewhere for #haskell baased on reverse-lookups of IPs?
13:06:47 <glguy>  ghc's build files support "stage3'
13:06:54 <jsnx> gwern: lolz
13:07:03 <Igloo> olsner: Well, some of the nightly builders do do 3 stages, but as a user there's little point. Also, the testsuite does a pretty good job of spotting compiler brokenness
13:07:04 <jsnx> i could do it now, probably
13:07:14 <byorgey> re: something in the US, see http://haskell.org/haskellwiki/AmeroHaskell
13:07:19 <jsnx> gwern: but dude, my IP is in texas sometimes
13:07:25 <byorgey> I don't know if anything is still happening with that
13:07:27 <ddarius> gwern: There's a map made by people giving their locations.
13:07:28 <jsnx> gwern: but i live in california
13:07:38 <jsnx> gwern: it's just a quirk of my ISP
13:07:39 <gwern> ddarius: maybe that's what I was thinking of
13:07:39 <ddarius> byorgey: I need to do something with it.
13:07:51 <gwern> jsnx: errors are the price we pay for eternal liberty?
13:07:59 <byorgey> ddarius: that would be awesome.
13:07:59 <gwern> (or, er, something)
13:08:29 <jsnx> gwern: lolz, no -- i think it's a $1.05 american
13:08:39 <jsnx> or eternal vigilance, i mean
13:08:40 <ddarius> byorgey: If I continue in the vein I was originally, it'll probably be West Coast.
13:08:49 <ddarius> (Neither coast really helps me.)
13:08:55 <byorgey> ddarius: where are you?
13:09:01 <ddarius> byorgey: Texas
13:09:09 <byorgey> ah
13:09:22 <jsnx> byorgey: you are in DC?
13:09:24 <byorgey> ddarius: west coast would be OK with me, I might still come anyway.
13:09:27 <byorgey> jsnx: yes
13:09:39 <jsnx> we should meet in iowa
13:09:46 <jsnx> that would be hilarious
13:09:47 <byorgey> hehe, in a corn field
13:09:54 <gwern> kansas is even more hilarious
13:09:57 <gwern> iowa is too cold right now
13:10:07 <jsnx> "whadda you boys doin' out here?"
13:10:20 <byorgey> CosmicRay actually lives in Kansas, IIRC
13:10:37 <jsnx> "gosh -- programmin' 'puters! i ain't ever seen a com-puter before!"
13:10:51 * jsnx is from iowa
13:10:51 <gwern> 'we're looking at gay porno!'
13:10:59 <gwern> 'no, seriously, we're programming'
13:11:11 <dons> oh no, jdh is benchmarking parsec
13:11:18 <gwern> jsnx: ok, that's going a little far - I have a lot of relatives in Iowa
13:11:23 <jsnx> "gay what? son, i'll have to shoot you dead, lord almighty!"
13:11:28 <dons> he's a relentless FP infighting machine
13:11:45 <jsnx> dons: he's an ML terrorist
13:11:56 <gwern> ..infighting?
13:11:59 <gwern> who is jdh?
13:12:00 <jsnx> they should throw him out, take away his syntax coloring
13:12:02 <sjanssen> dons: link?
13:12:09 <jsnx> gwern: jon d harrop
13:12:10 <dons> on -cafe@
13:12:40 <jsnx> it's okay if haskell is a little slower than o
13:12:42 <jsnx> caml
13:12:53 <dons> well, parsec is probably slower than a parser generator
13:12:56 <jsnx> i mean, c kicks them both in the nuts/labia
13:12:56 <dons> i'm sure he'll find.
13:13:04 <dons> jsnx: check the shootout page :)
13:13:08 <dons> its not so simple.
13:13:11 <jsnx> dons: i mean, in general
13:13:16 <gwern> oh... harrop. yes, I remember him now
13:13:26 <jsnx> dons: though in many cases, haskell and o'caml to really well
13:13:45 <dons> we're out ranking ocaml on raw speed since updating to 6.8.2 yesterday
13:14:07 <olsner> oh, the lisp guy? (or was it anti-lisp guy?)
13:14:19 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=ocaml
13:14:38 <vincenz> "Note that this functionality continues to be widely used in other functional
13:14:38 <vincenz> languages, e.g. SML, OCaml, F#. I can't think why Haskell would be any
13:14:38 <ddarius> dons: We spoil the boat by releasing a new parsec shortly.
13:14:39 <dons> which shows that 6.8.2 and the ocaml compiler are pretty much identical now
13:14:39 <vincenz> different."
13:14:47 <dons> ddarius: yep. good. bytstring parsec.
13:14:53 <jsnx> however, the point is, haskell has a rich type system, clear syntax, well-controlled side effects (unlike o'caml) -- and is way faster than python/perl/ruby or anything else similarly high level
13:15:11 <dons> vincenz: that's a typical troll. we should not respon to/encourage this behaviour
13:15:24 <jsnx> ddarius: you don't spoil a boat
13:15:29 <jsnx> ddarius: you *rock* a boat
13:15:54 <dons> jsnx: i'd strongly argue that ghc 6.8.2 (writh pointer tagging) is pretty much identical to ocaml.
13:16:01 <dons> the ocaml copmiler's just not moving as fast as ghc.
13:16:13 <ddarius> jsnx: -You- don't spoil a boat
13:16:14 <gwern> vincenz: I don't even know what's he's talking about. didn't he just post that no ide's offered it?
13:16:17 <jsnx> dons: well, even if it is, there are probably some highly optimized libs for o'caml, still
13:16:33 <gwern> ddarius: you add spoilers to your boats? :)
13:16:37 <dons> sure. apparently ghc has some too, looking at that sum-file benchmark
13:16:45 <jsnx> ddarius: -you- don't speak english as your first language
13:16:53 <cdsmithus> I'm having trouble getting gtk2hs working.  I get a bunch of stuff like: undefined reference to `gtkzm0zi9zi12zi2_GraphicsziUIziGtkziWindowsziWindow_windowNew_closure' when linking.  Works fine in GHCi, though.
13:16:53 <dons> ah, thread-ring, actually
13:17:06 <dons> missing --make cdsmithus ?
13:17:07 <ddarius> jsnx: I speak my own idiolect.
13:17:13 <cdsmithus> Nope, got --make.
13:17:38 <jsnx> ddarius: you are not standards compliant
13:17:51 <ddarius> jsnx: Damn straight!
13:18:17 <jsnx> ddarius: well, at the next meeting for ISO English, this boat thing needs to get sorted
13:18:25 * vincenz shrugs
13:18:27 <vincenz> He's a really odd fellow
13:18:35 <jsnx> English 09 is going to be a great standard
13:18:48 <dons> sjanssen: this parsec thing is driving him crazy! http://programming.reddit.com/user/jdh30
13:18:50 <jsnx> ...if it's ever implemented :(
13:19:04 <gwern> jsnx: bushwah! it's way too complex
13:19:18 <gwern> I tell you, this 'homonym' thing will lead to trouble and miscomprehension!
13:19:28 <dcoutts_> cdsmithus: it's not just a make clean issues is it? it always does this when you build your prog from scratch?
13:19:29 <gwern> leave that sort of overloading to perl
13:19:43 <jsnx> gwern: lolz, yes
13:20:17 <ddarius> Parsec is a ridiculously successful library.
13:20:30 <cdsmithus> Yes, I'm building from scratch.  I deleted everything except the .hs.  And nothing odd about the program.  It just does initGUI, windowNew, windowSetTitle, widgetShowAll, and mainGUI
13:20:50 <cdsmithus> dcoutts: ^ (forgot to address you)
13:22:22 <sjanssen> dons: wow, that thread is still going!
13:22:26 <dcoutts_> cdsmithus: can you @hpaste the whole linker error
13:22:30 <dcoutts_> @hpaste
13:22:34 <sjanssen> good to see hsenag fighting the good fight
13:22:42 <EvilTerran> !paste
13:22:43 <hpaste> Haskell paste bin: http://hpaste.org/
13:22:44 <dons> yeah.
13:22:54 <dcoutts_> what's happened to lambdabot?
13:23:01 <EvilTerran> @seen lambdabot
13:23:04 <EvilTerran> er
13:23:25 <jsnx> what is hsenag doing? on reddit?
13:23:27 <hpaste>  cdsmithus pasted "Link errors from gtk2hs" at http://hpaste.org/5111
13:23:38 <sjanssen> dons: his "throwback of inferred types" thread suddenly makes sense in this thread's context
13:23:54 <dons> he's a very single minded individual :)
13:24:04 <dcoutts_> cdsmithus: ok, so it seems to be missing everything :-)
13:24:13 <dons> dcoutts_: can't seem to connect from code.haskell.org
13:24:20 <cdsmithus> dcoutts_: Pretty much, yeah
13:24:29 <dcoutts_> dons: huh? from or to?
13:24:50 <dons> the freenode machine doesn't resolve or something
13:25:16 <dcoutts_> cdsmithus: check what ghc-pkg thinks about the gtk package, in the gtk2hs package's lib dir find the libHSgtk.a
13:26:11 <quicksilver> kuribas: woo! put a copy up somewhere I can play with
13:26:21 <dcoutts_> cdsmithus: we should use nm on it to see if those symbols really exist or not
13:26:36 <dcoutts_> cdsmithus: eg I do:
13:26:37 <dcoutts_> nm /usr/local/lib/gtk2hs/libHSgtk.a | grep GraphicsziUIziGtkziAbstractziWidget_widgetShowAll_closure
13:26:37 <kuribas> quicksilver: Just a minute, I am fixing a bug (a bad indentation)...
13:26:37 <dcoutts_> 00000000000005a0 D gtkzm0zi9zi12zi1_GraphicsziUIziGtkziAbstractziWidget_widgetShowAll_closure
13:26:44 <cdsmithus> dcoutts_: what exactly do you want me to check?  I don't know anything about ghc-pkg.
13:27:05 <dcoutts_> cdsmithus: ghc-pkg describe gtk, tells you all ghc knows about the package, like where it find the libs etc
13:27:08 <kuribas> quicksilver: It's still very much alpha software.
13:27:28 <kuribas> But so is the other indentation engine...
13:27:34 <dcoutts_> dons: so lambdabot runs off code.h.o and it cannot resolve freenode
13:28:11 <dons> http://programming.reddit.com/info/6623h/details , `Language shootout: GHC 6.8.2 with pointer tagging made of "win and awesome" '
13:28:20 <cdsmithus> dcoutts_: Okay yeah, so the symbols are not there.  nm prints (a bunch of) stuff, but the grep turns up nothing.  Should I paste nm output?
13:29:06 <dcoutts_> cdsmithus: no, the nm output should be many many kb, is it rather short?
13:29:22 <dcoutts_> dons: when I ssh to code.h.o I can resolve irc.freenode.net and chat.freenode.net using the host command
13:29:34 <cdsmithus> 15K.  And scrolling through it, it seems (very) incomplete
13:29:59 <dcoutts_> cdsmithus: so something went wrong building or linking gtk2hs it looks like
13:30:18 <dons> dcoutts_: ok. i'll try again.
13:30:46 <cdsmithus> dcoutts_: Yeah, the only object file with symbols of that general form is CustomStore_stub.o
13:30:51 <MarcWeber> dcoutts: Whihc is the way to install a package (nix store path / nonstandard)  registering the user package-database using cabal? copy to cp the lib and register --gen-strict then sed the path to register ? There is also install --dest-dir which is depreceated
13:31:15 <dcoutts_> cdsmithus: hmm
13:31:37 <cdsmithus> dcoutts_: I'll rebuild and capture the build output, and look for anything suspicious
13:31:42 <dcoutts_> cdsmithus: ok
13:32:06 <dcoutts_> MarcWeber: runghc Setup.hs configure --user
13:32:47 <dcoutts_> MarcWeber: that uses the per-user package db to satisfy package deps and it'll register into that package db upon runghc Setup.hs install (or register)
13:33:08 <dcoutts_> MarcWeber: or perhaps I mis-understood your question
13:33:17 <MarcWeber> dcoutts_: And the user package db is the first passed in GHC_PACKAGE_PATH ?
13:33:37 <dcoutts_> MarcWeber: I really don't know how GHC_PACKAGE_PATH works
13:33:42 <MarcWeber> And what path will be used ? /usr/lib/ghc...mypackage ?
13:33:51 <dcoutts_> MarcWeber: it's the default ghc-pkg per-user db
13:34:06 <dcoutts_> MarcWeber: the install prefix is set with configure --prefix=
13:34:11 <MarcWeber> Oh. Thanks then. Then I'll patch the register script as I've done before.
13:34:28 <dcoutts_> MarcWeber: you can also install into a temp dir without registering
13:34:46 <MarcWeber> Give me a sec
13:34:53 <dcoutts_> MarcWeber: eg configure for the final location, but create an install image in a temp dir.
13:35:06 <dcoutts_> MarcWeber: perhaps you can say what it is you're really trying to do
13:36:53 <MarcWeber> dcoutts_: Install the package and pkg db (only containing one this lib) into $out
13:37:27 <MarcWeber> http://rafb.net/p/sYMCdW90.html That's what I got. Really nice message. GHC devs have done a great job..
13:37:49 <Sizur> gah! Text.XHtml.Internals is hidden!
13:38:07 <Sizur> is it not possible to use it?
13:38:14 <dcoutts_> MarcWeber: where are the dependent packages registered?
13:38:20 <dcoutts_> MarcWeber: which package db
13:38:51 <MarcWeber> dcoutts_: In different database files. nix will take care of them and add tehm to GHC_PACKAGE_PATH
13:39:36 <dcoutts_> MarcWeber: you can register into any db you like by doing: runghc Setup.hs register--gen-pkg-config=foo.pkg; ghc-pkg register foo.pkg --package-conf=whatever-you-like
13:39:55 <Sizur> does Bjorn Bringert hang out here?
13:40:04 <ddarius> Sizur: Yes.
13:40:07 <dcoutts_> Sizur: normally, he's away atm
13:40:09 <dcoutts_> MarcWeber: so cabal does not directly support or understand GHC_PACKAGE_PATH
13:40:21 <Sizur> ddarius: thanks.
13:40:38 <Sizur> if a module is hidden in a package, there is no way to import it?
13:41:00 <MarcWeber> dcoutts_: Not yet. I need neither --user nor --global but --custom=$mydb. So I'll patch the configure script and patch cabal when I have time to . It's only about two sed line so no trouble..
13:41:03 <dcoutts_> MarcWeber: runghc Setup.hs configure defaults to *only* looking in the global package db. With --user it looks in all dbs that ghc-pkg reports by default. However that's only somewhat by accident.
13:41:43 <dcoutts_> MarcWeber: I sent someone else a patch the other day to play with that extends cabal to know about specific package dbs, in addition to the global and per-user ones. You might like to look at that.
13:45:07 <MarcWeber> dcoutts_: I know. That's the only part of the source I've read till now. Don't care about me using this feature made by accident. I'll notice when things change.
13:45:31 * RayNbow upmods the GHC 6.8.2 reddit link
13:50:22 <dons> hehe, yay
13:50:23 <dons> "Actually, it looks like it's not doing that badly compared to C.
13:50:23 <dons> That is fucking unbelievable if you take a second to remember how brutally low-level C is."
13:50:36 <dons> even our critics agree, ghc *is* made of win and awesome
13:51:40 <Sizur> looks like i will have to copy paste source code again :(
13:52:01 <gwern> dammit. how is sumfile *still* slower than clean's? what the heck is the clean compiler doing that ghc isn't?
13:52:17 <dons> gwern: so its very close now, readInt is almost exactly freadi
13:52:23 <dons> it may be using a faster int parser
13:52:36 <dons> gwern: e.g. like the one used in the illegal haskell entry
13:52:56 <gwern> dons: very close? haskell's is like twice as slow
13:53:12 <EvilTerran> illegal? O.o
13:53:15 <dons> right, but that's only 1 or 2 instructions in the main loop :)
13:53:19 <dons> EvilTerran: yeah, it doesn't follow the spec
13:53:29 <dcoutts_> dons, sjanssen, gwern: Jon Harrop is perhaps a bit inflammatory, but I think he's right. It is in principle possible to type check (and indeed run) a module that does not compile and it would be useful.
13:53:57 <dons> sure. expect to see an article on his web page mentioning how haskell fails at this.
13:53:59 <dcoutts_> replace expressions that do not unify with error "the type error message"
13:54:08 <kuribas> quicksilver: http://kuribas.hcoop.net/haskell-indent.el
13:54:10 <dcoutts_> I've not actually seen this in other languages though
13:54:25 <dcoutts_> does F# really do partial type checking?
13:54:31 <dcoutts_> if so, that's pretty cool.
13:55:16 <gwern> dcoutts_: sure, I agree. I do that all the time with undefined. but I don't get his asking why it isn't done when he already said that nobody does it
13:55:21 <IvdSangen> dcoutts_: does that mean that everything that can not be inferred is treated as dynamic types?
13:55:55 <dcoutts_> IvdSangen: no, as a new type var and a _|_ value
13:56:11 <gwern> but I still think using undefined would mean getting erroneous/overlybroad types inferred
13:56:33 <dcoutts_> gwern: it'd be an interesting research project :-)
13:57:53 <gwern> dcoutts_: doubt it. maybe a blog post - the hardest part would be coming up with a good example to demonstrate how using undefined could lead to bad inferred types
13:59:36 <idnar> wow, ocaml does badly in thread-ring
13:59:43 <Sizur> i find that encapsulation nullifies the strongest point of functional programming -- modularity.
14:00:12 <Sizur> it's second time i cannot extend something thanks to module hiding something
14:00:21 <IvdSangen> Sizur: doesn't it actually enable modularity?
14:00:25 <dcoutts_> gwern: perhaps one could be conservative and not report errors that depend on bits you've already identified as dodgy
14:00:44 <Sizur> IvdSangen: i endup copy-pasting the original code to extend it
14:01:07 <IvdSangen> yes, than the interface is too high-level
14:01:24 <idnar> and Free Pascal seems to do insanely well on memory usage
14:01:33 <IvdSangen> making submodules can be useful then
14:01:48 <gwern> dcoutts_: but then what if the error only shows up many modules or function definitions away during the propagation of type constraints meets a conflicting explicit type or inferred type?
14:02:17 <moonlite> idnar: about the same as haskell :)
14:02:30 <Sizur> IvdSangen: Text.XHtml.Internals is hidden, and i need it's type constructors to serialize html to dhtml
14:02:37 <sjanssen> gwern: it probably doesn't make sense with multiple modules (at least with GHC's module-at-a-time compilation)
14:02:49 <dons> gwern: btw, 'fasta' is one benchmark that i bet can be improved
14:02:57 <idnar> moonlite: eh, it seems to do a lot better than GHC in some benchamrks
14:02:59 <idnar> *benchmarks
14:03:15 <idnar> moonlite: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=fpascal&lang2=ghc
14:03:32 <moonlite> idnar: oh ok. I thought you meant in that specific benchmark (thread-ring)
14:03:44 <idnar> moonlite: oh, sorry, I meant in general
14:03:51 <idnar> but I guess that was a bit of a non-sequitur
14:04:56 <gwern> dons: how so?
14:04:58 <Big_Red> hrm how do you type functions that take functions as arguments?
14:05:19 <glguy> exactly like that
14:05:21 <glguy> :t map
14:05:30 <Sizur> just two simple (..) are missing...
14:05:34 <glguy> map :: (a -> b) -> [a] -> [b]
14:05:40 * Sizur is crying like a baby
14:06:07 <Big_Red> so just (a -> b) as the first argument then
14:06:25 <Sizur> yes
14:06:42 <DRMacIver> Hm. I wish the Haskell entries for the language shootout were a bit more honest.
14:06:57 <DRMacIver> There's a lot of really grotty low level code in there.
14:07:15 <IvdSangen> DRMacIver: that;s a general problem of the shootout
14:07:22 <DRMacIver> True
14:07:50 <DRMacIver> I'm annoyed about some of the Java code too. :) It uses GMP for anything requiring big ints.
14:07:55 <IvdSangen> but I agree with you
14:07:56 <dons> DRMacIver: what is honest in microbenchmarks?
14:08:27 <dons> seriously. these are *microbenchmarks* -- so you have to go low level to win. since there's an optimal strategy for each benchmark, and you have to nail that or loose.
14:08:32 <ddarius> dons: Where are these quotes coming from?
14:08:39 <DRMacIver> dons: "winning" isn't very interesting. I'd be more interested in how idiomatic Haskell fared.
14:08:48 <dons> what, just lazy lists of 32 bit Chars?
14:09:05 <DRMacIver> I don't consider ByteStrings to be unidiomatic. :)
14:09:47 <DRMacIver> inline IO, unboxed values, foreign arrays... etc. are a different matter.
14:09:52 <dons> there's always a tension between naive code and speed
14:10:08 <ddarius> Does F# copy O'Caml's totally screwed up type inference?
14:10:09 <dons> the code's a lot cleaner than it used to be, and will continue to improve
14:10:37 <dons> but really, if the C guys go and use raw simd instructions, we have to follow them down that whole
14:10:37 <DRMacIver> ddarius: In what way is O'Caml's type inference screwed up?
14:10:52 <cdsmithus> dcoutts_: still there?
14:11:16 <sjanssen> I think explicitly unboxed code should be banned on the shootout
14:11:18 <dcoutts_> cdsmithus: yep
14:11:43 <cdsmithus> dcoutts_: I've got a rebuild, even repulled from darcs, and no changes.  Any ideas where to look for the problem?
14:12:04 <Sizur> wow, that lisp there is pretty good.
14:12:14 * EvilTerran notes that \row -> [i | (i,1) <- zip [0..] row] is really quite cool
14:12:15 <dcoutts_> dons: they should be required to use cpu-portable code, ie simd is ok if it's portable intrinsics that are translated by the compiler to whatever cpu we're using
14:12:42 <yitz> DRMaclver: While it's also nice to know how high-level idiomatic Haskell performs, the shootout serves different purposes:
14:12:44 <dons> i think the main use for unboxed code on the shootout atm is unchecked shifts
14:12:52 <dcoutts_> cdsmithus: try configuring gtk2hs with --disable-split-objs
14:13:00 <dcoutts_> cdsmithus: what ghc and gcc are you using?
14:13:01 <EvilTerran> much nicer than (map fst . filter ((==1).snd) . zip [0..])
14:13:03 <DRMacIver> dons: Getting into a low level code competition with C sounds like a lost cause to me. The performance of high level constructs is more interesting than the ability to drop down into grotty low level code.
14:13:26 <dons> yep. there's a long term trend of the haskell code getting more and more higher level. so i expect that to continue
14:13:32 <yitz> it gives us the confidence to know that if we need to optimize, there's a huge amount of horsepower under the hood. And it gives us a nice feeling, and good press.
14:13:34 <cdsmithus> dcoutts_: gcc 4.2.3, ghc from darcs
14:13:38 <dons> e.g. pattern matching in inner loops is dead cheap now, and we've better libraries
14:13:46 <dons> so you'll see more pure code, and more cleaner code.
14:13:53 * EvilTerran wonders if [i | i <- zip [0..] | 1 <- row] is sufficiently nicer to be worth the extension
14:13:55 <DRMacIver> That's good. :)
14:13:59 <EvilTerran> er, s/zip//
14:14:34 <Valodim> > zip [0..]
14:14:43 <Valodim> is lambdabot still not here
14:14:48 <Valodim> what's up with that?
14:14:57 <dons> and, eg. if ST arrays aren't idiomatic haskell, what the hell are they? http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsievebits&lang=ghc&id=0
14:14:59 <dcoutts_> cdsmithus: yes, I recommend trying configure --disable-split-objs and also --with-hcflags=-O0 for a much faster build
14:15:23 <sjanssen> Valodim: no Show instance for (b -> (Integer, b))
14:15:28 <dcoutts_> cdsmithus: some combos of ghc/gcc do not like split-objs at all and we can end up loosing half the symbols from object files
14:15:46 <cdsmithus> dcoutts_: Okay, I'm trying now.  What does split-objs do?
14:15:48 <yitz> sjanseen: @botsnack
14:15:50 <Valodim> ...what?
14:15:56 <DRMacIver> dons: ST arrays are fine. Foreign.Marshal.Array is somewhat suspect. :)
14:15:57 <dcoutts_> cdsmithus: eg ghc-6.6.1 and gcc-4.2 were abad combo
14:16:28 <Valodim> ah
14:16:33 <dons> DRMacIver: that's true. a lot of those could be turned back to nice ST arrays
14:16:42 <dcoutts_> cdsmithus: it munges the object files to try and help the linker only include the bits that are really needed when linking a final binary
14:16:46 <dons> if anyone wants to step up and do that, we'd all appreciate it.
14:17:02 <glguy> ``no Show instance for ([b]....
14:17:15 <cdsmithus> dcoutts_: So no harm as long as I'm okay with bigger binaries?
14:17:19 <dcoutts_> cdsmithus: otherwise the linker tends to include the entire static lib into each binary which leads to 1.5Mb hello world :-)
14:17:27 <glguy> oh, I missed a [] too
14:17:27 <dcoutts_> cdsmithus: right.
14:17:33 <sjanssen> glguy: damn, my GHC emulation is getting weak :)
14:17:41 <cdsmithus> dcoutts_: Okay, great.  I don't care about binary size.
14:17:55 <glguy> sjanssen: good thing we have computers
14:18:06 <cdsmithus> dcoutts_: That sounds very similar to what I'm seeing.  I'm hopeful.
14:18:09 <dcoutts_> cdsmithus: it's not 100% certain to be that problem, but it seems a likely candidate with you using such a new gcc
14:18:40 <dcoutts_> cdsmithus: since object splitting is a rather low level affair that tends to break with new gcc versions
14:21:53 <nornagon> hm, emacs can display haskell code with unicode arrows... can vim?
14:22:47 <cdsmithus> dcoutts_: Thanks for the help.  I gotta run, but I'll come back later and see how this worked.
14:23:13 <matthew-_> nornagon: yes, I believe so
14:23:35 <nornagon> matthew-_: i've tried to google for it, but i can't seem to unearth anything...
14:23:42 <dcoutts_> cdsmithus: ok, good luck
14:23:58 <matthew-_> nornagon: I'm not a vim expert. ToRA would probably be able to tell you how to do it.
14:24:29 <nornagon> @time ToRA
14:24:42 <matthew-_> my time
14:24:45 <nornagon> where's lambdabot gone now? ;(
14:25:57 <oerjan> nornagon: dons etc. mumbled something about gtk2hs problems and not being able to lookup freenode
14:26:08 <andyjgill> afternoon room!
14:26:16 <DRMacIver> lambdabot uses gtk2hs?
14:27:09 <oerjan> i may have been greatly confused about something...
14:29:34 <oerjan> ah yes dcoutts_ was talking to dons and cdsmithus at the same time
14:30:12 <EvilTerran> ... is there a snazzier way of expressing [[(x,y) | y <- [0..]] | x <- [0..]] ?
14:30:56 <oerjan> liftM2 (,)
14:31:12 <idnar> EvilTerran: zip (repeat 0) [0..] *duck*
14:31:13 <mauke> > map (join (,)) [0 ..]
14:31:37 <ddarius> DRMacIver: (re O'Caml) I don't remember what it was exactly and maybe I meant type checking.  It's something to do with O'Caml using unification instead of instantiation or something like that somewhere or something like that.
14:31:42 <oerjan> oh wait
14:31:59 <EvilTerran> idnar, that's a somewhat different value -.-
14:32:13 <ddarius> EvilTerran: It depends on the type.
14:32:32 <EvilTerran> what does?
14:32:51 <yitz> > flip zip [0..] [0..]
14:32:55 <DRMacIver> ddarius: I'm sorry, I have no idea what that means. :)
14:33:09 <ddarius> If 0 :: Integer in the above, then that expression is what idnar said it was.
14:33:28 <EvilTerran> no it's not; you can drop the first element of the outermost list
14:33:41 <ddarius> DRMacIver: I think there was an email on the O'Caml mailinglist about it a long time ago.
14:33:43 <dons> lambdabot's just not connecting. hmm
14:33:53 <olsner> EvilTerran: isn't it liftM2 (,)?
14:33:55 <EvilTerran> NB my expression is *not* [(x,y) | x <- [0..], y <- [0..]]
14:34:18 <oerjan> indeed
14:34:21 <yitz> ah, more brackets. ok, like idnar said.
14:34:28 <oerjan> thus my oh wait
14:34:37 <EvilTerran> which is what the liftM2 would give, i think
14:34:56 <olsner> where is our bot!? I am without cognition
14:34:57 <EvilTerran> and would be extensionally equivalent to idnar's
14:34:58 <ramza3> Don't know why I wish this was valid code let f = length("a") / length("sbs") :: Double
14:35:16 <Botje> ramza3: s/length/GenericLength
14:35:18 <EvilTerran> ramza3, use genericLength
14:35:21 <idnar> EvilTerran: I didn't say zip [0..] [0..]
14:35:24 <EvilTerran> ramza3, also, you don't need any of those brackets
14:35:38 <EvilTerran> idnar, i know you didn't.
14:36:05 <EvilTerran> but your expression is Num a => [(a,a)]
14:36:12 <EvilTerran> and mine is Num a => [[(a,a)]]
14:36:33 <oerjan> map (flip map [0..] . (,)) [0..], maybe
14:36:35 <idnar> oh whoops
14:36:50 <DRMacIver> ddarius: I don't read the OCaml mailing lists, so without some more information that's not much help. :) Could you give me an example?
14:36:52 <idnar> I meant [zip (repeat 0) [0..]]
14:37:04 <EvilTerran> it's still not the same, tho
14:37:04 <DRMacIver> (I can think of some problems with the ocaml type system, but not really anything I'd call totally screwed up)
14:37:08 <idnar> anyway, I was just being silly
14:37:15 <EvilTerran> sure, you can't tell it apart with show, but it remains different
14:37:22 <oerjan> EvilTerran: mine is not?
14:37:35 <idnar> EvilTerran: yeah
14:37:36 <EvilTerran> oerjan, i dunno, i haven't scrutinised your last one yet
14:37:53 <oerjan> there should be a for like there's forM ...
14:38:07 <EvilTerran> it's called `map` :P
14:38:09 <oerjan> then it would be for [0..] (for [0..] . (,))
14:38:21 <oerjan> EvilTerran: to avoid the ugly flip
14:38:36 <EvilTerran> (`map` [0..]) ((`map` [0..]) . (,))
14:38:43 <oerjan> ah yes
14:38:45 <ddarius> DRMacIver: I don't read the O'Caml mailinglist either.  Someone just mentioned it here once.
14:38:51 <DRMacIver> ok
14:38:58 <EvilTerran> but, yes, for would be handy
14:39:06 <yitz> > map (flip zip [0..] . repeat) [0..]
14:39:13 <EvilTerran> yitz, the bot remains not here
14:39:29 <yitz> I was talking to sjanssen
14:39:47 <yitz> :)
14:39:48 <idnar> *giggle*
14:41:05 <EvilTerran> oerjan's seems to work nicely
14:41:14 <ddarius> DRMacIver: It's hard for me to find especially because I'm not sure if it's even there.
14:41:34 <oerjan> whether it's better than the comprehension is another matter
14:41:47 <EvilTerran> map (flip zip [0..] . repeat) [0..], alternatively
14:42:03 <EvilTerran> eh, nested comprehensions make me antsy
14:43:14 <DRMacIver> ddarius: For what it's worth, as far as I know F#'s type system is pretty similar to that of OCaml's. So the answer is probably yes, even without knowing the underlying problem. :)
14:43:24 <ddarius> DRMacIver: Ah, it has to do with type annotations.
14:45:01 <ddarius> DRMacIver: If I remember correctly and the information was accurate, O'Caml just makes sure the inferred type unifies with a given type annotation rather than is a generalization of it.
14:45:38 <ddarius> If I felt like installing O'Caml I could check.
14:45:48 <tibbe> what's the point of MonadFix?
14:45:58 <tibbe> i.e. why would it be useful to make your monad an instance of it?
14:46:31 <dons> it's a good question :)
14:46:42 <ddarius> mdo syntax uses it.
14:46:47 <dons> tibbe: i hear vincenz is heading off to zurich to work with you guys? :)
14:46:55 <dons> and what's mdo good for, ddarius ?
14:47:01 <tibbe> dons: yup :)
14:47:09 <dons> quite a cabal you'll have :)
14:47:18 <tibbe> who, me?
14:47:20 <DRMacIver> ddarius: Hm. I don't entirely understand that, but thanks. I'll think about it.
14:47:24 <EvilTerran> cabal install vincenz?
14:47:57 <tibbe> dons, I've improved my bytestring parsec to the point where I soon want a code review, would you have time once it's done?
14:48:12 <ddarius> dons: One use is making cyclic mutable data structures.
14:48:18 <tibbe> dons, there are three or so primitive parsers that work directly on bytestrings that need optimizing
14:48:20 <yitz> dons: Recently, I thought of something that mdo might be good for.
14:48:33 <olsner> where does cabal install put its build directories? configure fails on plugins-1.0
14:48:39 <ddarius> DRMacIver: I'll test it and see if I'm right/remember correctly.
14:49:00 <yitz> ddarius: I have no trouble making cyclic mutable data structures w/o mdo.
14:49:03 <DRMacIver> A nice example I've thought about using mdo for is when you're doing some code generation of an imperative language (in my case, java bytecode). You want to goto a label, and mdo allows you to goto labels which you declare later.
14:49:10 <DRMacIver> I think harpy does something like this.
14:49:23 <dons> tibbe: definitely.
14:49:25 <DRMacIver> I could be completely wrong though. I've yet to try to put the idea into practice. :)
14:49:27 <mauke> DRMacIver: heh, I do exactly that in my interpreter
14:49:40 <dons> olsner: oh, plugins should be used only from darcs
14:50:00 <DRMacIver> ddarius: Thanks
14:50:06 <DRMacIver> mauke: Glad to know I'm not barking up the wrong tree. :)
14:50:19 <olsner> oh, grmbl
14:50:27 <ddarius> yitz: It allows you to do it with a binding group rather than having to update a cell later.
14:50:44 <ddarius> At any rate there is a whole section of the Research Papers page on recursive do-notation.
14:51:13 <DRMacIver> I think whomever it was doing the monadic web objects stuff used it similarly? You can do forward references for navigation links or something
14:51:16 * ddarius needs to figure out how to write O'Caml in its top-level now.
14:51:24 <mightybyte> @hoogle lookMb
14:51:39 <mauke> a function using mdo: http://rafb.net/p/ewlAnK76.html
14:51:50 <yitz> Let's say you wrote something using mutual recursion of several infinite lists. And let's say that one of lists happens to be a randomRs thing. Now you want to mend your ways, and do the randoms in a monad instead, say a ListT-done-right. Without mdo, you have to rewrite your program from scratch.
14:51:57 <ddarius> http://www.haskell.org/haskellwiki/Research_papers/Monads_and_arrows#Recursion
14:52:21 <olsner> but it used to work on ghc-6.6, is it ghc-6.8 that isn't compatible with plugins-1.0?
14:52:26 <yitz> ddarius. ok, but that's usually not much of an advantage imho.
14:53:09 <cdsmithus> dcoutts_: Just so you know, that was the problem.  All is well.  Thanks again.
14:53:42 <dcoutts_> cdsmithus: ok, so you might want to report a ghc bug, to say that the splitter is broken with that version of gcc.
14:54:01 <dcoutts_> cdsmithus: the ghc core libs are also built using split-objs so this will affect ghc at some point.
14:54:03 <ddarius> yitz: It can make a significant difference in clarity.
14:54:15 <ddarius> But the papers have examples and motivation.
14:54:21 <dcoutts_> cdsmithus: I assume you must be using a ghc that was built with an older gcc, but is now running using this newer one.
14:54:44 <cdsmithus> dcoutts_: No, I built GHC myself this morning.  No problems yet, but that sounds scary.
14:54:53 <yitz> ddarius: mdo is very, very unclear if it requires a week full time to understand those mfix axioms.
14:55:18 <cdsmithus> dcoutts_: And I've been using my own GHCs for six months now.  At least two months with this gcc
14:55:20 <dcoutts_> cdsmithus: hmm. Perhaps you built without split-objs then.
14:55:31 <ddarius> yitz: mdo is just what a recursive let is in an imperative language.
14:55:38 <olsner> @where plugins
14:55:48 <olsner> wait, no bot
14:56:34 <yitz> That's a nice slogan. But that doesn't tell me *exactly* what my program will do. So I'm going to put my money on the line with it until I understand it.
14:56:46 <dcoutts_> cdsmithus: you can easily tell, try something like:
14:56:46 <dcoutts_> ar t /usr/lib/ghc-6.8.2/lib/base-3.0.1.0/libHSbase-3.0.1.0.a | wc -l
14:57:17 <dcoutts_> cdsmithus: I get 10593. ie a lot! if it's an order of magnitude smaller then it's without split-objs
14:57:18 <dons> this is why we do the shootout, "My thoughts exactly. I'm literally shocked at how fast Haskell is."
14:57:38 <yitz> Not only that, but the next person, five years from now, with little math background, who needs to fix a bug in my program or refactor it to fit an API change, needs to understand my code completely without spending a month studying mdo. So I don't think mdo makes it clearer at all.
14:58:28 <cdsmithus> dcoutts_: Yeah, I get 136.  GHC must detect gcc version and decide not to use the splitter.
14:59:06 <dcoutts_> cdsmithus: perhaps
14:59:16 <olsner> dons: I tried the darcs version from ~dons/code/hs-plugins/ (if that is the correct one) but that gives the same error message (configure: error: C compiler cannot create executables)
14:59:43 <dons> olsner: ok, something's wrong with your setup.
15:00:14 <glguy> mdo's axioms only need to be studied if you are implementing a new instance
15:00:29 <dons> glguy: have you ever used mdo?
15:00:31 <glguy> if you are just using one you know that the side-effects will occur once, just like in do
15:00:35 <dons> i wonder why i've not had the need. hmm.
15:00:36 <glguy> dons: sure
15:00:43 <dons> oh, that would be interesting to hear about.
15:00:52 <glguy> the only distinction is that results are in scope before they are computed
15:00:56 <glguy> just like in a let, for example
15:00:57 * dons puts that on the 'glguy code haxor represent forum' topics list
15:01:03 <dons> yep.
15:01:35 <glguy> Levent is a good person to talk about, he wrote some of the original work on the subject :)
15:01:53 <dons> ah yes, wasn't it JL and Levent?
15:02:13 <dons> -- For a detailed discussion, see Levent Erkok's thesis,
15:02:13 <dons> -- /Value Recursion in Monadic Computations/, Oregon Graduate Institute, 2002.
15:02:14 <dons> :)
15:02:15 <glguy> we used it on the tearline project to inject side effects into a translator
15:02:18 <olsner> hmm, the ghc invokation to get the current directory produces something with line noise at the end of it
15:02:28 <dons> -- Module      :  Control.Monad.Fix
15:02:29 <dons> -- Copyright   :  (c) Andy Gill 2001,
15:02:29 <dons> --        (c) Oregon Graduate Institute of Science and Technology, 2002
15:02:33 <dons> huh
15:03:39 <ddarius> dons: [15:56] <dons> this is why we do the shootout, "My thoughts exactly. I'm literally shocked at how fast Haskell is."   Where is this from?
15:03:45 <idnar> http://programming.reddit.com/info/6623h/comments/
15:04:11 <ddarius> idnar: thanks
15:04:49 <cpst> I wonder how the memory usage compares
15:05:30 <ddarius> How do you give a function definition a type signature in O'Caml?
15:05:56 <cpst> ddarius: generally in the .mli file that you should always make
15:06:13 <dons> cpst: check it out. its surprising :)
15:06:19 <ddarius> cpst: What about in the top-level?
15:06:20 <mauke> ddarius: let f : your type here = fun a b c -> body
15:06:29 <mauke> ;;
15:07:03 <glguy> "I'm literally shocked at how fast Haskell is." Do you think he put his fingers in the power socket?
15:07:13 <DRMacIver> How much I hate the syntax for doing things like this is one of the biggest reasons I never got into OCaml. :)
15:08:36 <ddarius> DRMacIver: Well, at least if you write, let square : 'a = fun x -> x * x;; it passes which is the issue I was talking about.  I don't know if that extends to types in .mli files.
15:09:35 <DRMacIver> ddarius: Ah, I see.
15:10:28 <cpst> dons: what is wrong with k-nucleotide?
15:14:07 <dons> cpst: it needs a hashtable.
15:14:14 <dons> i hacked up a quick one, that works ok.
15:14:21 <dons> but needs a careful eye to do this properly
15:14:36 <dons> unfortunately, using a Trie, while much more idiomatic, and way faster, isn't allowed.
15:15:05 <olsner> what, it's specified to be a specific kind of hash table?
15:15:49 <dons> "define a procedure/function to update a hashtable of k-nucleotide keys and count values, for a particular reading-fram e even though we'll combine k-nucleotide counts for all reading-frames (grow the hashtable from a small default size)"
15:16:04 <dons> DRMacIver: ^ that kind of spec punishes idiomatic haskell
15:16:09 <DRMacIver> dons: Yeah. :-/
15:16:44 <dons> anyway, we can do fast hashtables
15:16:47 <dons> just takes a bit of effort
15:16:59 <dons> Clean's 2x C here, Haskell's 4x. we can improve that i think
15:17:14 <DRMacIver> I've idly wondered if you could build a tolerable hashtable from an IntMap [(k, v)]
15:17:34 <DRMacIver> But it probably loses all the advantages of both approaches. :)
15:17:46 <dons> yeah, better to use a trie. but oh well.
15:17:54 <glguy> if you are going through the trouble to hash the value
15:18:01 <glguy> better if you can do an array lookup
15:18:04 <glguy> than a binary search
15:18:59 <dons> 'zactly.
15:19:04 <DRMacIver> Yeah
15:19:10 <dons> and its not that hard to do a good bytestring-specialised hashtable
15:19:28 * dcoutts_ would prefer a trie
15:19:30 <glguy> have any of the entries made use of overloaded strings?
15:19:34 <glguy> + bytestring
15:19:40 <dons> glguy: nope :) that's a bit too sneaky.
15:19:53 <dons> it'd help gzip size a little
15:20:18 <dons> if someone wants to look at improving the hashtable implementation here,
15:20:19 <dons>   http://shootout.alioth.debian.org/gp4/benchmark.php?test=knucleotide&lang=ghc&id=2
15:20:22 <dons> that'd be cool
15:20:53 <dons> dcoutts_: ^ note, that hashtable impl also shows the "Eq instance not calling memcmp " performance win
15:20:58 <glguy> seems like in the case where you are using "acgt" that data Base = A | C | G | T
15:21:06 <glguy> would be better able to make use of GHCs abilities
15:21:57 <dons> its also a good idea to look at the current best performing C entry,
15:21:57 <dons>   http://shootout.alioth.debian.org/gp4/benchmark.php?test=knucleotide&lang=all
15:22:00 <dcoutts_> dons: mm
15:22:05 <dons> see what algorithmic tricks they use
15:22:19 <dons> different hash magic numbers, etc.
15:23:15 <dcoutts_> dons, glguy: for data Base = A | C | G | T you'd want ghc to implement the optimisation where it uses data Base = Enum Int#
15:23:38 <glguy> with pointer tagging wouldn't you get something like that?
15:24:38 <dons> i bet pointer tagging makes tries yet more attractive.
15:24:50 <dons> anything that traverses an ADT, pattern matching on where to go, gets a lot cheaper.
15:25:27 <LoganCapaldo> pointer tag! you're it!
15:26:29 <asdf> hi there
15:26:35 <Cale> asdf: hello
15:27:15 <asdf> :) im just about to learn haskell but i really dont get into it, its so... different
15:27:28 <olsner> we should take the shootout with only naive implementations in haskell, and turn it into a haskell compiler shootout, and eventually turn up with a compiler that runs 10-line implementations of the shootout blazingly fast
15:27:39 <Cale> asdf: You've come to the right place. Feel free to ask lots of questions.
15:27:43 <Cale> :)
15:27:44 <dons> welcome, asdf !
15:28:02 <dons> > map (^2) [1..] -- we can demo stuff in here, if you get confused
15:28:15 <Cale> asdf: It can be rather like learning to program all over again :)
15:28:15 <dons> oh, when the bot's here, we can.
15:28:28 <mux> LB died again?
15:29:08 <vincenz> since a bit
15:29:09 <dons> no, it can't connect.
15:29:11 <dons> some network issue
15:29:14 <Botje> asdf: welcome to haskell, here's your complimentary roll of duct tape and beginner monad
15:29:14 <vincenz> > 1
15:29:18 <mbot>  1
15:29:21 <Cale> > map (^2) [1..]
15:29:24 <mbot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
15:29:27 <olsner> > liftM2 (,) [1..5] [1..3]
15:29:29 <mbot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(5,...
15:29:32 <dons> i find it really difficult to understand data structures in languages without ADTs
15:29:33 <Cale> hehe :)
15:29:41 <Cale> dons: yeah, it's brutal.
15:29:45 <asdf> sounds good ;) so lets say i want simply to write a programm that multiplicates two numbers without using * operator. with my little knowledge i thought about something like this:
15:29:47 <asdf> times :: Int -> Int -> Int
15:29:47 <asdf> times 0 y = y
15:29:47 <asdf> times x y = x-1 y+y
15:29:56 <dons> encoding things in arrays and pointers -- that's perverse!
15:29:58 <Cale> asdf: That's missing some parens.
15:30:06 <Cale> asdf: around (x-1) and (y+y)
15:30:22 <olsner> hmm, lambdabot still doesn't compile on 6.8.2 does it?
15:30:28 <Cale> also, I don't think it's quite correct :)
15:30:33 <mauke> times 0 y is not y
15:30:33 <asdf> mmh but still doesnt work ;)
15:30:50 <asdf> what i thought was pattern matching
15:30:54 <dobblego> @pl \n -> fmap lines (readFile n)
15:30:55 <mbot> fmap lines . readFile
15:30:58 <mux> > let mul x y = sum (replicate x y) in 3 `mul` 4
15:31:00 <mbot>  12
15:31:08 <asdf> add y as long as the first parameter isn zero
15:31:22 <mux> I guess this one is a bit too contrived an example
15:31:26 <oerjan> @version
15:31:26 <mbot> lambdabot 4p575, GHC 6.8.2 (Linux i686 2.40GHz)
15:31:27 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
15:31:34 <mauke> asdf: did you mean times x y = times (x-1) (y+y)?
15:31:37 <Cale> asdf: But you'd be adding y to itself on each step, doubling it. That is, if the recursive call weren't missing :)
15:31:46 <dons> olsner: it does, you need plugins and lambdabot from code.haskell.org
15:32:04 <asdf> mauke, think so yea
15:32:15 <Cale> asdf: Perhaps you want  times x y = y + times (x-1) y
15:32:21 <olsner> Pulling from "http://code.haskell.org/lambdabot"... No remote changes to pull in!
15:32:27 <asdf> oh
15:34:02 <olsner> I'm getting errors from Plugin/Dummy/DocAssocs.hs using Data.ByteString.Base
15:34:10 <olsner> *one error
15:34:12 <Toxaris> :t (sum .) . replicate
15:34:14 <mbot> forall a. (Num a) => Int -> a -> a
15:34:19 <asdf> okay Cale that works :)
15:34:31 <asdf> but why doesnt mauke line do this job?
15:34:55 <mauke> <Cale> asdf: But you'd be adding y to itself on each step, doubling it.
15:35:22 <Toxaris> asdf: times 3 2 = times 2 (2 * 2) = times 1 ((2 * 2) * (2 * 2)) = ...
15:35:53 <oerjan> Toxaris: + not *
15:36:00 <Cale> asdf: Effectively, you were computing times x y = 2^x * y
15:36:06 <asdf> mmh moment i have to get a pen and paper to visualize it for me :D
15:36:10 <wagle> yeah, i was going "huh?"
15:36:13 <Toxaris> oerjan: yes :)
15:36:24 <pastorn> what function is this? \f x -> f x x
15:36:25 <mauke> asdf: write (y+y) as (2*y) if it helps
15:36:31 <oerjan> pastorn: join
15:36:31 <Cale> asdf: times x y = times (x-1) (y+y) = times (x-2) ((y+y)+(y+y)) = ...
15:36:32 <mauke> @pl \f x -> f x x
15:36:32 <mbot> join
15:36:34 <BlubberBla> http://www.laura-du-schlampe.com/?c=9f6ab8c18a
15:36:44 <pastorn> oerjan: thanks
15:37:01 <ddarius> DRMacIver: It does complain when they are different between an .mli and a .ml
15:37:05 <oerjan> pastorn: but you need the monad instance for ->, in Control.Monad.Reader or .Instances
15:38:10 <pastorn> oerjan: in Monad.Reader, what is meant by "Reader"?
15:38:25 <oerjan> @src MonadReader
15:38:25 <mbot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:38:55 <oerjan> pastorn: a Reader monad is one that threads a read-only state into the actions
15:39:01 * ddarius completely removes ocaml
15:39:10 <Cale> pastorn: Are you talking about the newsletter, or the actual Reader monad? :)
15:39:19 <pastorn> Cale: latter
15:39:21 <oerjan> @instances-importing Control.Monad.Reader MonadReader
15:39:23 <mbot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
15:39:26 <pastorn> so IO-stuff?
15:39:30 <oerjan> yuck
15:39:47 <Cale> pastorn: No, all the reader monad lets you do is read from a fixed environment.
15:40:02 <Cale> pastorn: (well, and locally alter the environment)
15:40:16 <pastorn> some sort of state-thingamobob?
15:40:20 <Cale> It's isomorphic to functions from a fixed type.
15:40:28 * ddarius decides to start watching a movie like he planned to an hour ago.
15:40:28 <Cale> (which happens to also be a monad)
15:40:30 <oerjan> pastorn: ignore the *T monads in that list, except ReaderT.
15:40:36 <mauke> pastorn: it just passes a hidden argument to all functions
15:40:47 <Cale> > (do x <- id; y <- reverse; z <- map toUpper) "hello"
15:40:47 <mbot>  Parse error at ")" (column 44)
15:40:57 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
15:40:59 <mbot>  ("hello","olleh","HELLO")
15:41:13 <Cale> Kinda like that, but usually with some more wrapping around it.
15:41:14 <ddarius> > sequence [id,reverse,map toUpper] "hello"
15:41:16 <mbot>  ["hello","olleh","HELLO"]
15:41:35 <pastorn> that's monadReader-stuff?
15:41:35 <vincenz> > map toUpper "wear"
15:41:37 <mbot>  "WEAR"
15:41:52 <Cale> See how the result of each "action", which is just a function, is the result of applying that function to the fixed value "hello"?
15:42:28 <Cale> Well, it's not actually (Reader e), but it's an unwrapped version of that.
15:42:40 <asdf> mh what happens exactly at this line: times 0 y = y
15:42:42 <Cale> (The actual reader monad involves using a little extra syntax)
15:42:43 <oerjan> pastorn: well MonadReader has the methods ask and local, which those Monads implement
15:42:54 <oerjan> :t ask
15:42:55 <pastorn> ok
15:42:55 <asdf> y isnt the output of the programm since y keeps being e.g. 5 wenn the call is times 3 5
15:42:57 <mbot> forall (m :: * -> *) r. (MonadReader r m) => m r
15:43:04 <Cale> asdf: If times is passed 0 as its first parameter, then it returns its second unaffected.
15:43:28 <asdf> mmh but the second parameter is 5
15:43:33 <asdf> but he returns the right value 20
15:43:53 <Cale> asdf: no it's not, not by the time it's recursed a bit :)
15:43:55 <ddarius> asdf: It's a declaration not a command.  It states something that is rather than something to do.  It states that time 0 y = y where that = is essentially the same one from math.
15:43:56 <Toxaris> asdf: 3 * 5 = 15
15:44:19 <Cale> asdf: of course, you actually want  times 0 y = 0
15:44:23 <Cale> (since 0 * y = 0)
15:44:25 <mauke> asdf: what programming languages do you know?
15:44:31 <idnar> asdf: in "times 3 5", the first parameter is not 0, so the line you listed isn't what's used
15:44:40 <oerjan> @src (->) local
15:44:41 <mbot> local f m = m . f
15:44:51 <ddarius> @src (->) ask
15:44:52 <mbot> ask = id
15:44:58 <ddarius> @src (->) asks
15:44:58 <mbot> Source not found. My brain just exploded
15:45:07 <mauke> @src asks
15:45:08 <mbot> asks f = do
15:45:08 <mbot>     r <- ask
15:45:08 <mbot>     return (f r)
15:45:24 <Cale> asdf: Basically, the Haskell interpreter/compiler tries each line of the definition in turn. The first one to match the parameters passed in wins, and the result is the RHS of the = sign.
15:45:34 <asdf> eh i dont fully understand... :D  c @ mauke
15:45:37 <ddarius> The irony is that asks is also id.
15:45:47 <Cale> asdf: Let me demonstrate in a paste :)
15:45:49 <Cale> !paste
15:45:49 <hpaste> Haskell paste bin: http://hpaste.org/
15:45:55 <mauke> asdf: think of it as a switch statement
15:46:17 <asdf> Cale, okay got that one but when the line times 0 y = y matches, the passed parameter y is still 5
15:46:24 <mauke> no, it isn't
15:46:25 <oerjan> > asks succ 1
15:46:27 <mbot>  2
15:46:36 <mauke> int times(int x, int y) { switch (x) { case 0: return y; default: return y + times(x - 1, y); } }
15:46:45 <mauke> er, wait. yes, it is
15:47:16 <mauke> but that's only the result of the innermost call to times
15:47:42 <asdf> good old c :D yea that makes sense to me
15:47:57 <Toxaris> asdf: times 3 5 = 5 + (times 2 5) = 5 + (5 + times 1 5) = ...
15:48:22 <Toxaris> asdf: so in the end, you added enough 5's to yield 20.
15:48:24 <wagle> you lost me when you say times 0 x == x (and not 0)
15:48:27 <mauke> times(3, 5) == 5 + times(2, 5) == 5 + (5 + times(1, 5)) == 5 + (5 + (5 + times(0, 5))) == 5 + (5 + (5 + (5))) == 20
15:48:31 <hpaste>  Cale pasted "evaluation steps" at http://hpaste.org/5112
15:48:47 <Toxaris> wagle: it's a bug, not a feature :)
15:48:57 <Cale> asdf: have a look at my paste there
15:49:04 <asdf> Toxaris, yea exactly, but when the line times 0 y matches, it says = y, and i understand it in a way "y is passed as 5 and all the old stuff 5+(5+(5+...) is forgotten
15:49:17 <ddarius> Hey!  This movie has Rose Byrne in it.
15:49:22 <asdf> k
15:49:49 <Botje> ddarius: oh sorry sir, we'll bring you another one.
15:50:13 <Cale> asdf: It's exactly like elementary mathematics. Function definitions are applied by replacing the parameters in their bodies with the arguments. You just keep replacing things according to the definitions until you can't do it anymore.
15:51:29 <asdf> okay that looks good
15:52:36 <asdf> mmh sounds confusing have to think about it a minute <;
15:52:57 <Cale> Like in mathematics, suppose I tell you that f(x,y) = x^2 + y
15:53:09 <Cale> and then ask you to evaluate f(3,5)
15:53:13 <Cale> what do you do?
15:53:42 <Cale> (of course, I mean that f(x,y) = x^2 + y, for any numbers x and y)
15:53:51 <mauke> .oO( I ask C and get 6 )
15:54:10 <Cale> mauke: haha
15:54:16 <mauke> I get 4, actually
15:54:17 <asdf> as a haskell function? somethin like f x y = (x*x) + y? :D
15:54:45 <Cale> asdf: no, pretend this is grade 6 mathematics class or something
15:55:14 <Cale> > let f x y = x^2 + y in f 3 5
15:55:15 <mbot>  14
15:55:21 <Cale> Of course, Haskell can do it :)
15:55:24 <asdf> 3*3 + 5 = 14 or what ya mean
15:55:28 <Cale> yeah
15:55:51 <Cale> You'd replace x and y on the RHS of the equation f(x,y) = x^2 + y with the specific x and y
15:56:30 <asdf> makes sense yea. btw, how does haskell know the names of parameters?
15:56:43 <ivanm> how does any language know the names of parameters?
15:56:49 <Cale> Because you name them on the LHS of the equations you give.
15:56:53 <asdf> always in the first line in the body like times x y, then x and y are first and 2nd arguments?
15:57:00 <Cale> yeah
15:57:12 <asdf> and in later lines i can always refer as x and y to it?
15:57:23 <Cale> err...
15:57:24 <mauke> yes
15:57:30 <Cale> You'll be pattern matching again, most likely.
15:57:37 <Cale> If you mean what I think you mean by "lines"
15:57:39 <mauke> assuming you're still in the same function body
15:57:58 <Cale> But yeah, throughout the RHS, x and y will be bound to the first and second parameters after that.
15:58:10 <asdf> yay sure. the "=" operater is something totally different to what it is in e.g. c isnt it
15:58:11 <Toxaris> asdf: you can refer to them on the right hand side of the equals sign. if you start a new line like "times a b = ...", you need to use a and b instead of x and y
15:58:18 <Cale> asdf: right
15:58:20 <mauke> asdf: "=" is not even an operator :-)
15:58:34 <Cale> asdf: It means essentially "define these two things as being equal"
15:58:43 <Cale> And once they're equal, that's it.
15:58:43 <mauke> = defines things. it doesn't assign a new value to a variable
15:58:58 <Cale> If you write  x = x + 1  in Haskell, you've written an infinite loop.
15:59:18 <asdf> but times a b would be again the passed arguments? okay thats all very new to me
15:59:21 <Cale> Trying to evaluate x will give you x + 1, which will then reduce to (x + 1) + 1, and so on.
15:59:21 <oerjan> > let x = x + 1 in x
15:59:24 <mbot>  Exception: <<loop>>
15:59:52 <asdf> mauke, yay that was difficult - or actually IS difficult - to understand for me...
16:00:06 <mauke> it just takes time getting used to
16:00:43 <LoganCapaldo> x = x + 1 mewans where you see x, replae it with x + 1, so x = x + 1, x = (x + 1) + 1, x = ((x + 1) + 1) + 1 ...
16:00:58 <asdf> Cale, really? but when i write
16:00:58 <asdf> f :: x -> x
16:00:58 <asdf> f x = x+1
16:00:58 <ivanm> those x's are different again (in the :: line)
16:01:20 <mauke> asdf: that's not the same as x = x + 1
16:01:22 <pastorn> i haven't coded for very long... anyone know of any cool labs or something i could put my teeth in?
16:01:37 <oerjan> those x are types, not values
16:01:39 <mauke> asdf: only the first "word" is the thing being defined
16:01:45 <mauke> the rest is arguments
16:01:51 <mauke> (i.e. local variables)
16:02:06 <LoganCapaldo> f x = x + 1 means when you see f x replace it with x + 1, so f 2 = 2 + 1 , f a = a + 1...
16:02:13 <yitz> pastorn: project euler
16:02:23 <mauke> spoj.pl
16:02:25 <asdf> ah i see
16:02:29 <pastorn> yitz: yeah, forgot about that...
16:02:57 <mux> @users
16:02:57 <mbot> Unknown command, try @list
16:03:06 <mauke> @list
16:03:07 <mbot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:03:31 <asdf> but
16:03:32 <asdf> times :: Int -> Int -> Int
16:03:32 <asdf> times 0 y = y
16:03:32 <asdf> times x y = y + times (x-1) y
16:03:38 <asdf> isnt correct though
16:03:42 <oerjan> mbot doesn't have exactly the same commands as lambdabot
16:03:58 <mauke> correct in what sense? because it gives wrong answers?
16:04:00 <asdf> times 3 10 is 40
16:04:05 <idnar> asdf: "times 0 y = y" isn't right; 0 times y should be 0, not y
16:04:48 <asdf> mmh but i thought he match the pattern at this line
16:04:53 <asdf> as x is passed zero at one point
16:05:04 <LoganCapaldo> alternative times 1 y = y could work assuming you never type something like times 0 4
16:05:05 <idnar> asdf: it matches, but it gives the wrong answer
16:05:15 <asdf> ah you mean times 0 y = 0
16:05:20 <oerjan> mux: /list #haskell says 414 users
16:05:20 <idnar> asdf: yeah
16:05:45 <asdf> yea you are right, he is adding an additional y at the end when i make it like that :)
16:05:51 <mux> oerjan: heh, I've figured it out :-P
16:14:14 <asdf> mmh hugs says to this line summe a:b = a + summe [b] "ERROR "a2c.hs":2 - Syntax error in declaration (unexpected symbol ":")"
16:14:32 <asdf> but i thought when you write a list as a:b a is the first element and b is the rest of the list
16:14:51 <twanvl> you need parentheses, summe (a:b) = ...
16:14:59 <Toxaris> asdf: your idea is correct, but your syntax not quite
16:15:32 <Toxaris> asdf: you need "summe (a:b) = ..." because "summe a : b = ..." is parsed as "(summe a) : b = ..."
16:15:52 <Toxaris> asdf: and you don't need those brackets. just "... = a + summe b" should work
16:17:37 <asdf> ah okay, but its still broken
16:17:44 <asdf> summe :: [Int] -> Int
16:17:44 <asdf> summe (a:b) = a + summe b
16:17:44 <asdf> summe [] = 0
16:18:40 <asdf> is what i got so far, tryin to add all elements of a given list
16:18:54 <Botje> and this somehow doesn't work for you?
16:18:54 <Toxaris> > let {summe :: [Int] -> Int; summe (a:b) = a + summe b; summe [] = 0} in summe [1..3]
16:18:57 <mbot>  6
16:19:02 <Toxaris> asdf: seems to work fine
16:19:02 <idnar> asdf: that works just great for me
16:20:04 <asdf> oh okay, i called summe with (..) instead of [..]
16:20:46 <Toxaris> asdf: the brackets are not for calling, but for writing a literal list
16:21:12 <Toxaris> asdf: like braces for arrays in c: int foo[4] = {1, 2, 3, 4}
16:22:08 <Toxaris> > let {summe :: [Int] -> Int; summe (a:b) = a + summe b; summe [] = 0} in summe (1 : 2 : 3 : [])
16:22:10 <mbot>  6
16:22:27 <Toxaris> asdf: you can specifiy the argument to summe however you want
16:22:44 <sciolizer> "import qualified Array as A; foo = A.(!)" makes ghc say "Not in scope: data constructor `A'". Any ideas/workarounds?
16:22:53 <Toxaris> sciolizer: (A.!)
16:22:58 <sciolizer> Toxaris: thank you
16:23:25 <Toxaris> sciolizer: especially funny is import qualified Prelude as P; ... (P..) ...
16:24:00 <oerjan> > succ Prelude.. pred $ 1
16:24:03 <mbot>  1
16:24:27 * LoganCapaldo names a module .
16:24:29 <sciolizer> heh
16:24:33 <idnar> bwahaha
16:24:44 <mauke> module names must start with an uppercase letter
16:24:48 <mauke> ITYM :
16:25:02 <idnar> .:.
16:25:03 * BMeph tries import qualified Prelude as .
16:25:03 <LoganCapaldo> Can you really start module names with colon?
16:25:15 <mauke> INFIX MODULES
16:25:25 <LoganCapaldo> bwhahaha
16:25:31 <mauke> import as `Prelude` P
16:33:53 <asdf> well i will keep on askin i think but up to this point thanx for ya nice help (:
16:34:29 <LoganCapaldo> Control.Monad.Instances = Control `Instances` Monad ? ;)
16:34:42 <DRMacIver> Hm. Inspired by question in programming.reddit: Is there any particular reason Haskell couldn't be made really good for numerical calculations?
16:34:53 <vincenz> LoganCapaldo: no
16:34:58 <vincenz> Monad `Control` Instances
16:35:06 <vincenz> or with proper grammar
16:35:08 <vincenz> Monads `Control` Instances
16:35:14 <DRMacIver> It seems like the purity, etc. should give you a lot of the optimisation benefits that high performance fortran does.
16:35:16 <LoganCapaldo> No they don't!
16:35:30 <DRMacIver> (evne if you're starting from somewhere a bit slower)
16:35:36 <augustss> DRMacIver: laziness can be a drawback
16:35:48 * LoganCapaldo imagines uber strictness analyzer 
16:36:06 <augustss> LoganCapaldo: keep dreaming :)
16:36:09 * LoganCapaldo and then realizes he can't imagine that, because he cant even imagine an non uber strictness analyzer
16:36:17 <DRMacIver> augustss: How about given a useful set of strict datastructures and operators to start from?
16:36:26 <DRMacIver> operations
16:36:34 <augustss> DRMacIver: yes, i think that would work
16:36:43 <augustss> and then a lot of compiler work
16:36:47 <goalieca> dons, nice post on reddit ;)
16:37:03 <augustss> the Fortran guys have a 30 year head start on Haskell
16:37:15 <dons> head starts are massively important.
16:37:16 <DRMacIver> Yeah. Clearly GHC, etc. aren't there yet. I was just wondering if there were some actual obstacle.
16:37:20 <cpst> augustss: but they did publish all of their techniques ;-)
16:37:31 <DRMacIver> -fvia-fortran? ;)
16:37:50 <LoganCapaldo> numeric monad + harpy + simd instructions = zoom?
16:37:59 <cpst> Optimizing Compilers for Modern Architectures is a nice book on compiling Fortran
16:38:03 <dons> goalieca: got to represent the FP crew :)
16:38:25 <augustss> LoganCapaldo: harpy is old news, LLVM rulez now :)
16:38:30 <Philippa_> augustss: getting within sight of Fortran while still having Haskell's benefits is enough to be viable though
16:38:38 <DRMacIver> A comment intended only partially in jest.
16:38:41 <Philippa_> I know people who use C for it
16:38:42 <dons> also, it was super cool how many benchmarks got faster by updating to 6.8.2
16:38:50 <LoganCapaldo> augustss: there a harby workalike for llvm?
16:38:58 <LoganCapaldo> *harpy
16:39:11 <dons> we've 'pretty much' caught ocaml, even without a new codegen, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=ocaml
16:39:18 <augustss> LoganCapaldo: I'm working on an improvement to bos's llvm bindings
16:39:20 * dcoutts_ and kolmodin crack down on hackage QA
16:39:25 <dons> 9 wins to ghc 6.8.2., 6 to ocaml.
16:39:26 <LoganCapaldo> cool
16:39:31 <asdf> when i want to merge to lists together, why does
16:39:32 <asdf> union :: [Int] -> [Int] -> [Int]
16:39:32 <asdf> union xs ys = (xs:ys)
16:39:34 <asdf> not work?
16:39:38 <cpst> OCaml isn't really that efficient
16:39:50 <LoganCapaldo> @type (:)
16:39:51 <DRMacIver> dons: Do you know if that changes on 64-bit?
16:39:52 <mbot> forall a. a -> [a] -> [a]
16:39:56 <dons> sure it is. its got a great codegen. python isn't really inefficient.
16:40:04 <sciolizer> asdf: perhaps you want (++), not (:)
16:40:09 <dons> DRMacIver: unknown.
16:40:12 <LoganCapaldo> asdf: compare your type to the type of (:)
16:40:16 <DRMacIver> dons: Whenever you mention the shootout OCaml guys complain about how much better the numbers are on 64-bit machines.
16:40:18 <cpst> dons: it's got an okay codegen, but a lot of the rest of the compiler sucks
16:40:19 <dons> DRMacIver: didn't jdh get better results for ghc on 64bit?
16:40:37 <cpst> dons: like inlining of higher-order functions and anything involving functors
16:40:46 <dcoutts_> DRMacIver, dons: I think ghc's numbers would be worse on 64bit
16:40:48 <dons> there's no functors in the shootout, anyway
16:40:50 <asdf> okay ty
16:41:10 <DRMacIver> dons: I thought it was the other way round? (And he got really huffy with augustss testing them on 32-bit or something)
16:41:15 <dons> ah maybe.
16:41:23 <dons> jdh's a bit huffy generally though
16:41:28 <DRMacIver> dcoutts_: GHC's numbers would actually be worse or just worse in comparison to OCaml?
16:41:31 <DRMacIver> Yeah, he is.
16:41:40 <dcoutts_> DRMacIver: worse absolutely
16:41:48 <augustss> I think OCaml does double better on 64 bit machine because they don't need boxing there
16:41:55 * mux wants to see GHC burn Clean some day
16:42:24 <vincenz> how come clean is so fast?
16:42:30 <dcoutts_> DRMacIver: the size of everything doubles, so much more memory bandwidth needed
16:42:42 <dons> but more bits for pointer tagging :)
16:42:43 <dcoutts_> vincenz: excellent low level code gen apparently
16:42:50 <DRMacIver> dcoutts_: Ah, right.
16:42:50 <dcoutts_> same for ocaml
16:43:00 <sclv> also very natural unboxed arrays.
16:43:04 <LoganCapaldo> all the dirt other pls have slow them done <g>
16:43:05 <dcoutts_> ghc has a notoriously bad low level code gen
16:43:14 <cpst> augustss: OCaml's slowness on 32-bit is due to the small number of registers (their compiler likes more registers) and the bad codegen for the x87 stack
16:43:22 <vincenz> dcoutts_: what's the reason for that?
16:43:23 <dcoutts_> problem is it's hard to get research funding for writing code generators
16:43:34 <dons> cpst: but that's the same problem with ghc.
16:43:53 <LoganCapaldo> can we start a code gen research fund?
16:43:56 <DRMacIver> It would be nice to get some company to support code generator GHC development.
16:44:07 <dons> MSR?
16:44:12 <cpst> dons: maybe, but OCaml's is a lot better on 64-bit, likely because it was written in the era of lots of different RISC machines
16:44:19 <oliv3_> erm
16:44:31 <oliv3_> "oh my god" as they say
16:44:31 <dcoutts_> dons: may well be the same problem for ocaml and ghc on 32bit x86, but it's also possible that ocaml takes advantage of x86-64 better than ghc does.
16:44:47 <dons> its possible
16:45:02 <oliv3_> did anyone match on this one: http://hpaste.org/5103 ??
16:45:10 <cpst> LoganCapaldo: the problem isn't researching it, the problem is actually writing one
16:45:24 <vincenz> yeah, backends aren't novel
16:45:25 <dons> oliv3_: what's your question about that?
16:45:28 <asdf> mmh i never understand the errors hugs give me....
16:45:32 <LoganCapaldo> so start a fund for that
16:45:39 <goalieca> would be nice seeing llvm.. but it appears people say its technically inadequate
16:45:44 <LoganCapaldo> wha=tever gets it done :)
16:46:26 <oliv3_> dons: well, in C, ints are limited to 32788, if not unsigned... of course this benchmark will run faster, since it does _not_ do 1000000 iterations ...
16:46:28 <cpst> there are some interesting new techniques for backends, like exploiting properties chordal graphs for register allocation, but for the most part it's all textbook stuff
16:46:47 * LoganCapaldo wishes he was arbtrarily rich so he could start companies to make his favorite projects better
16:46:49 <oliv3_> the mistake is obvious
16:46:50 <dons> > maxBound :: Int
16:46:52 <mbot>  2147483647
16:46:58 <oliv3_> not in C..
16:47:02 <augustss> oliv3_: 16 bit ints are really rare in C these days
16:47:14 <dons> > maxBound :: Foreign.C.Types.CInt
16:47:15 <mbot>      Not in scope: type constructor or class `Foreign.C.Types.CInt'
16:47:16 <goalieca> oliv3_, you mean "short"
16:47:25 <dons> > maxBound :: CInt
16:47:26 <mbot>   Not in scope: type constructor or class `CInt'
16:47:28 <dons> bah
16:47:30 <oliv3_> i mean the default "int"
16:47:34 <dons> yeah.
16:47:36 <oliv3_> is 16bits
16:47:40 <mauke> oliv3_: wrong
16:47:41 <dons> nope. :)
16:47:52 <augustss> oliv3_: the default int on any modern machine is 32 bits
16:48:00 <augustss> oliv3_: try it
16:48:13 <oliv3_> augustss: sure, just doing it
16:48:29 <asdf> http://hpaste.org/5113 what is going wrong there?
16:48:52 <dons> oliv3_: here you go,
16:48:53 <dons> #include <stdio.h>
16:48:53 <dons> int main(void) { printf("%d\n", sizeof(int));
16:48:53 <dons> }
16:48:58 <dons> $ gcc t.c
16:48:58 <dons> $ ./a.out
16:48:58 <vincenz> 4
16:49:02 <augustss> asdf: missing parens/$
16:49:08 <dons> vincenz: :)
16:49:35 <mauke> technically, printf("%lu\n", (unsigned long)(CHAR_BIT * sizeof (int)))
16:49:38 <asdf> parens/$?
16:49:40 <Toxaris> asdf: "... else insert x ys union xs ys" doesn't make sense
16:49:54 <glguy> asdf: x == True   ->  x
16:50:01 <Toxaris> asdf: the linebreak has no meaning at this position
16:50:02 <mauke> == True doesn't make sense either
16:50:11 <augustss> asdf: also, never write '== True'.  It's a sure sign of not understanding the booleans
16:50:24 <asdf> Toxaris, why not? i want him to call both functions in a row
16:50:29 <vincenz> dons: whoops :)
16:50:38 <Toxaris> asdf: and what would that mean?
16:50:40 <asdf> augustss, ? contains returns True or False...
16:50:45 <mux> dons: hopefully! posix mandates 32-bits ints, thogh C alone accepts 16-bits ints
16:50:45 <LoganCapaldo> asdf: insert is not going to change ys
16:51:01 <augustss> asdf: and what does == return?  True or False
16:51:01 <oliv3_> ok all, slaping myself.
16:51:05 <LoganCapaldo> it's going to yield a new list that's the result of inserting x in ys
16:51:22 <augustss> asdf: so why not compare the result of == True with True again?
16:51:31 <glguy> just to be safe?
16:51:35 <glguy> (x == True) == True ?
16:51:39 <mauke> if ((contains ys x == True) /= False) == True
16:51:48 <mauke> == False) /= True
16:51:57 <vincenz> oliv3_: int is the size of your datapath
16:51:58 <Toxaris> asdf: (insert x ys) will return something, (union xs ys) will return something else, wich of these results should union return? since only one can be returned, it doesn't make sense to call both
16:52:07 <vincenz> oliv3_: on modern machines, that's 32bits, on 16bit machines, that's 16bit
16:52:15 <vincenz> on 64 bit machines it's ... 64bit
16:52:17 <augustss> mmmm PDP11
16:52:29 <vincenz> what is that 11bits?
16:52:33 <augustss> 16
16:52:35 <vincenz> oh
16:52:40 <augustss> C was made for PDP11
16:52:42 <mux> int is not the size of the datapath
16:52:45 <vincenz> mux: yes it is
16:52:53 <mux> int stays 32-bits on most 64-bits architecture
16:52:56 <DRMacIver> vincenz: I was under the impression that ints were usually still 32-bit on 64-bit machines
16:52:56 <mux> no, it isn't :-)
16:53:03 <vincenz> bleh, they broke tradition then
16:53:08 <mux> most 64bits architectures are LP64
16:53:17 <augustss> int has not specified size in the standard, but it is often the word size
16:53:21 <mux> this tradition is broken since years already
16:53:27 <asdf> Toxaris,  else union xs (insert x ys) would make more sense?
16:53:32 <mux> there are very few ILP64 systems
16:53:38 <Toxaris> asfd: yes
16:53:39 <mux> this is mostly a waste of memory
16:53:39 <goalieca> c would be nice if it standardized on int8, int24, int16, etc.
16:53:55 <mauke> goalieca: :(
16:54:10 <asdf> okay, now hugs loads it, but for union [2,3] [2,8] he returned []... mmmh so still not correct
16:54:13 <mux> goalieca: it did in C99
16:54:18 <augustss> while (*p++ = *q++); compiles to 2 instructions on the PDP11 :)
16:54:26 <mux> C99 has int32_t, int64_t, uint32_t, etc.
16:54:31 <goalieca> ya. i've used those
16:54:34 <mauke> mux: all of which are optional
16:54:36 <goalieca> but not every compiler handles it
16:54:36 <EvilTerran> <stdint.h>
16:54:54 <mux> mauke: right, but usually provided when C99 is there
16:55:04 <mux> and it's already quite a relief
16:55:15 <Toxaris> asdf: is "union [] _ = []" correct?
16:55:21 <vincenz> augustss: 2?
16:55:26 <vincenz> o.O
16:55:30 <mauke> you could just use long, long long, or unsigned long instead
16:55:35 <vincenz> that's assignment and 2 increments
16:55:53 <augustss> vincenz: exactly
16:56:00 <vincenz> erm, that's three if I count right
16:56:05 <augustss> that's why you have a postincrement addressing mode
16:56:08 <vincenz> they have indirect-index with update?
16:56:14 <vincenz> erm indirect-address
16:56:16 <vincenz> nat
16:56:17 <vincenz> neat even
16:56:20 * vincenz can't type today
16:56:35 <augustss> L: MOVB (R1)++,(R2)++; JNE L
16:56:45 <asdf> Toxaris, mh when [] the first argument of union is, then he is ready with what he is doing
16:57:07 <asdf> and i thought applying a empty list is always okay
16:57:09 <mauke> asdf: then why are you throwing the accumulated result away?
16:57:14 <augustss> postincrement, and predecrement.  ideal for a stack
16:57:18 <Toxaris> asdf: you *return* an empty list
16:57:44 <asdf> why that? i thought the term is replaced with [] but everything which was before is still there
16:57:49 <vincenz> augustss: oh, including the while? damn
16:58:04 <Toxaris> asdf: yes that is true. but here is nothing before
16:58:09 <augustss> As I said, C was made for the PDP11
16:58:11 <vincenz> augustss: I bet that's hard to compile for, tho, since it's only useful in specific cases
16:58:28 <asdf> oh. should replace [] with ys eh
16:58:37 <augustss> not that hard when the source language has the same constructs as the assembly code
16:58:37 <Toxaris> asdf: yes :)
16:59:26 <asdf> :) is workin yay
16:59:38 <vincenz> augustss: well if you write code that way... f you had the increments in the loop-body..
16:59:46 <augustss> vincenz: and PC was in an ordinary register, which makes indirect autoincrement on PC a very useful addressing mode
16:59:56 <vincenz> yeah :)
17:00:20 <augustss> vincenz: why do you think old C code looks like it does? :)
17:00:57 <vincenz> :)
17:01:09 * vincenz hates cornercases
17:03:16 * LoganCapaldo is a little scared now about how much he knows may have been influenced by the quirks of a pdp11
17:04:00 <augustss> LoganCapaldo: just an incentive to learn more about the PDP11.  It's a beautiful machine
17:04:14 <RayNbow> asdf: when writing base cases for functions (like union [] ys = ...), it's best to ask yourself what should be a meaningful definition
17:04:38 <RayNbow> so in this case... ask yourself "what's the union of an empty list and a list ys?"
17:05:52 <LoganCapaldo> one day in the distant future I'll sit my grankids on my knee and exlain to them why C has a postincrement operator, as it was relayed to me many  years ago in an ancient for of communication known as "IRC" ;)
17:06:37 <vincenz> "Years ago, they had this thing called monads..."
17:06:38 <RayNbow> LoganCapaldo: are you implying that IRC will be dead when you're a grandfather? :p
17:06:52 <LoganCapaldo> RayNbow: _anything_ is possible :)
17:07:01 <LoganCapaldo> but I _know_ C won't be <g>
17:07:49 <asdf> RayNbow, that is what i asked myself and thought "union of [] and ys is ys" so i made the misstake applying [] at the end
17:08:11 <RayNbow> ah
17:08:38 <Toxaris> asdf: so you should have written "union of [] and ys is ys", in Haskell-speech: union [] ys = ys. :)
17:08:57 <augustss> vincenz: another cool thing.  you can fill the PDP11's memory withe same bit pattern in every word using a single instruction.  I have told you enough about the PDP11 for you to figure out how. ;)
17:09:26 <augustss> it's not an arbitrary bit pattern, it's very special
17:09:26 <vincenz> MOVB (Rx)++, bitpattern
17:09:31 <asdf> yay think that takes some time, haskell-speech is to new on the first day ;)
17:09:32 <vincenz> MOVB (Rx)++, R0
17:09:38 <augustss> vincenz: that doesn't loop
17:09:45 <vincenz> oh right
17:10:02 <vincenz> MOVB (Rx)++, (PC)--
17:10:09 <augustss> oh, you need to know that there's also MOVW
17:11:16 <augustss> vincenz: yes, something like that.  my favourite is MOVW --(PC),--(PC)
17:11:17 <LoganCapaldo> MOVW (PC), (PC)++ ?
17:11:50 <vincenz> LoganCapaldo: that won't work
17:12:01 <vincenz> you'll skip ahead twice, no?
17:12:03 <LoganCapaldo> well ya know
17:12:14 <LoganCapaldo> i suck at pdp11 programming
17:12:27 <LoganCapaldo> never my strong suite :)
17:12:38 <augustss> it should be taught before C/C++ ;)
17:12:55 <LoganCapaldo> also *pc = *pc++ was the sort of thing I was taught, "don't do that!" :)
17:13:36 <Cale> http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html :)
17:13:40 <augustss> yes, i think it's actually undefined what happens
17:14:08 <augustss> it depends on the model what happens when you have autoic/dec on the same reg twice in an instruction
17:18:16 <EvilTerran> augustss, so what was the instruction you were thinking of?
17:18:27 <EvilTerran> oh, never mind, i see where you said
17:18:35 <augustss> EvilTerran: :)
17:18:45 <EvilTerran> clever
17:22:30 <asdf> is it possible to make 2 operations after "then"?
17:22:41 <mauke> depends on your definition of "operation"
17:22:52 <asdf> if ... then call-function1 call-function2
17:22:59 <mauke> technically, no; you have to combine them into one operation
17:23:24 <asdf> uhm....
17:23:26 <mauke> asdf: if you don't use the return value of call-function1, it will be as if it had never been called
17:23:34 <mauke> so you can just remove it
17:24:06 <asdf> ah you gave me a idea
17:25:37 <asdf> ahh perfect thx :D
17:25:38 <Cale> asdf: There's a major difference between Haskell functions and "functions" in most other programming languages. A Haskell function's behaviour is completely determined by its inputs and outputs.
17:26:12 <Cale> If passed the same parameters, it will always give the same result, and the only effect of applying it will be to produce this result.
17:26:53 <Cale> So as mauke says, if you don't use the result, there's no point in using that function in the first place.
17:28:31 <asdf> yea that was the point where i said myself "wait u actually need output from function1 as parameter for function2..." so it was easy to call direct function2 with function1 as argument
17:28:46 <Cale> yep
17:29:20 <Cale> Otherwise, you can use a "let ... in ..." expression, or a where clause to define the intermediate value you're using.
17:29:47 <Cale> > let x = 3; y = 4 in x + y
17:29:49 <mbot>  7
17:30:44 <asdf> mmh think i will watch out for stuff like "let in" or "where" another time, im goin to sleep now <:
17:31:24 <asdf> ceeya and thx
17:32:13 <hpaste>  Chad annotated "Calling a Haskell library from C" with "linking step used by ghc" at http://hpaste.org/5104#a1
17:32:56 <Cha1> still struggling with this. It won't link unless I have all the -u switches, but that seems like a burden for the library user
17:34:03 <Cale> Cha1: Shouldn't you compile with ghc?
17:34:29 <Cha1> Yes, but I'd like to have a haskell library to hand to a C person, who may not have ghc installed
17:35:49 <Cha1> trying to make it so the fact that I'm using haskell is as transparent as possible
17:36:26 <Cale> Hmm, what happens if you link the library separately, using GHC, and then try linking it into another C program in a plain fashion with GCC?
17:36:35 <vincenz> heh
17:36:42 <vincenz> you can put C and haskell code in one file :)
17:36:45 <vincenz> use .lhs
17:36:52 <vincenz> and put /* */ around the lhs code
17:37:20 <Cale> heh, that's true :)
17:37:22 <dobblego> hmm, you could do that with HTML as well right?
17:37:26 <Cale> Yes
17:37:31 <Cha1> Cale: So write a C wrapper that just re-exports the functions?
17:37:39 <Cale> dobblego: I've seen that done a number of times in fact
17:37:44 <Cale> Cha1: yeah
17:38:15 <Cha1> Hmm, ok I can try that.
17:38:45 <Cha1> vincenz: The idea here is that primes.c would be written by someone else - most likely a non-haskell person
17:39:11 <Cale> Cha1: Well, you could put your C-wrapper in the same file as the Haskell source :)
17:39:26 <Cha1> Ahh, ok I didn't see the connection there
17:39:32 <Cale> (I'm not entirely sure that would be advisable :)
17:39:43 <vincenz> btw
17:39:45 <LoganCapaldo> but it would be cool
17:39:47 <vincenz> what's with all the -u stuff?
17:40:04 <LoganCapaldo> and cool > advisable everytime :)
17:40:04 <Cha1> Well, this is just my proof-of-concept - the real thing is much bigger, and may as well have separate C stuff
17:40:18 <Cha1> haha LoganCapaldo
17:40:39 <hpaste>  vincenz annotated "Calling a Haskell library from C" with "mixed lhs and c file" at http://hpaste.org/5104#a2
17:41:11 <Cha1> from the gcc man page:
17:41:11 <Cha1>  -u symbol
17:41:11 <Cha1>            Pretend the symbol symbol is undefined, to force linking of library
17:41:11 <Cha1>            modules to define it.  You can use -u multiple times with different
17:41:11 <Cha1>            symbols to force loading of additional library modules.
17:41:16 <vincenz> LoganCapaldo: then people compile your code "I don't get the answer you got!?!"  I told you use gHc not gCc!
17:41:29 <LoganCapaldo> :)
17:42:09 <Cha1> vincenz: Ahh, ok that is pretty slick
17:43:25 <Cha1> Well, wait a minute, if I just write a wrapper, they're still going to need to link the whole thing, right? WOuldn't they still need all the -u crap?
17:44:15 <mauke> http://projecteuler.net/index.php?section=problems&id=35
17:44:27 <mauke> what am I doing wrong if the answer I get is 43?
17:45:20 <glguy> mauke: forgetting to count some
17:45:26 <mauke> :(
17:45:30 <vincenz> counting too many?
17:45:35 <glguy> nope
17:45:46 <vincenz> mauke: circular, not reflective?
17:45:46 <glguy> or just counting the wrong ones altogether :)
17:46:15 <vincenz> Cale: http://notvincenz.blogspot.com/2008/01/literate-haskell-and-c.html
17:46:16 <vincenz> :)
17:46:20 <mauke> ok, reality check. how many primes are there below one million?
17:46:25 <vincenz> mauke: many :)
17:46:38 <vincenz> @hoogle isPrime
17:46:39 <mbot> http://www.isprime.com/
17:46:39 <mbot> Title: ISPrime Managed Services - The Ultimate Hosting Company
17:46:42 <vincenz> o.O
17:46:48 <vincenz> hoogle, not google!
17:47:07 <mauke> argh!
17:47:22 <vincenz> mauke: ?
17:47:28 <glguy> mauke: 78498
17:47:31 <mauke> I found a bug
17:47:31 <glguy> primes < 1 million
17:47:36 <vincenz> glguy: what code did you use?
17:47:45 <glguy> primes 1 1000000 | wc -l
17:47:48 <glguy> instant :)
17:47:49 <vincenz> oh, lol
17:47:52 <mauke> glguy: that's definitely > 11734
17:48:10 <vincenz> mauke: quite :)
17:48:36 <vincenz> mauke: pls show code, kthx
17:48:52 <glguy> when I did the PE problems, I'd read in my primes list from stdin a lot of times
17:49:05 <glguy> primes is a highly optimized implementation
17:49:12 <lispy> PE?
17:49:18 <glguy> project euler
17:49:24 <vincenz> glguy: is that allowed?
17:49:56 <glguy> the point isn't to write your own prime sieve every time
17:49:57 <lispy> somepeople just google the answers
17:50:08 <glguy> the algorithms are more complicated than that generally
17:50:32 <vincenz> mauke: how do you input solutions?
17:50:35 <BMeph> I use oerjan's generator for my primes, 'cause it's easy to type. :)
17:50:36 <mauke> glguy: thanks, solved
17:50:46 <vincenz> BMeph: ?
17:50:54 <mauke> vincenz: my code is http://rafb.net/p/2kYjBf50.html
17:50:55 <BMeph> vincenz: oerjanPrime = nubBy (((>1).).gcd) [2..]
17:51:14 <vincenz> > nubBy (((>1).).gcd) [2..]
17:51:16 <mbot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
17:51:24 <BMeph> That's how I have it in my "utility-belt" file. ;)
17:51:29 <vincenz> holy moley
17:51:39 <vincenz> > drop 1000 $ nubBy (((>1).).gcd) [2..]
17:51:43 <mbot>  [7927,7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,8081,...
17:51:48 <vincenz> > drop 100000 $ nubBy (((>1).).gcd) [2..]
17:51:52 <mbot> Terminated
17:52:40 <lispy> > drop 100000 $ nubBy (((>1).).gcd) (2:[3,5..])
17:52:45 <mbot> Terminated
17:53:04 <mauke> > nubBy (((>1).).gcd) (2:[3,5..])
17:53:05 <glguy> â””â”€(%)â”€â”€ time primes 1 10000000 | wc -l
17:53:06 <mbot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
17:53:06 <pastorn> :t  (((>1).).gcd)
17:53:07 <glguy> 664579
17:53:08 <mbot> forall a. (Integral a) => a -> a -> Bool
17:53:09 <glguy> primes 1 10000000  0.18s user 0.02s system 94% cpu 0.215 total
17:53:11 <glguy> wc -l  0.01s user 0.01s system 9% cpu 0.214 total
17:53:22 <pastorn> :t gcd
17:53:24 <mbot> forall a. (Integral a) => a -> a -> a
17:54:03 <Pseudonym> OK, one thing I don't like about GHC 6.8.  Large data structures still take a long time to compile.
17:54:24 <lispy> Pseudonym: how large are we talking+
17:54:53 <Pseudonym> 1.4Mb of Haskell.
17:55:07 <Pseudonym> All one list.
17:55:20 <lispy> so in that nubBy example, what algo does nub use? an O(n^2) comparison?
17:55:28 <mauke> yes
17:55:31 <Pseudonym> Standard hack for just such an occasion:
17:55:33 <Pseudonym> theData :: [(Double,Double,Double,Double,Double)]
17:55:33 <Pseudonym> theData = read . unsafePerformIO . readFile $ "theData"
17:55:40 <ddarius> THat nubBy definition of primes was, I believe, originally due to sorear.
17:56:43 <lispy> Pseudonym: so you're saying, it's faster to read it in than to let GHC parse it?
17:56:54 <Pseudonym> I don't think it takes long for GHC to parse.
17:57:11 <lispy> s/parse/grok/
17:57:19 <ddarius> Pseudonym: Write a program that directly generates .o files from the data.
17:57:22 <Pseudonym> I think it's that the CORE representation is particularly evil.
17:57:27 <pastorn> how do i upgrade ghc to 6.8 in ubuntu?
17:57:45 * Pseudonym will stick with unsafePerformIO for now
17:57:54 <Pseudonym> But really, static data is important.
17:57:59 <Pseudonym> It's not a showstopper, but it's important.
17:58:06 <Tac-Tics> pastorn: I just installed it by source
17:58:20 <Tac-Tics> It's annoying that it's not available by aptitude yet
17:58:29 <lispy> Pseudonym: what about using template haskell to read it in at compile time as static data...is that slow too?
17:58:37 <Pseudonym> I have no idea.
17:58:45 <Pseudonym> Thus far, I've avoided template haskell.
17:58:49 <mauke> > tails "foo"
17:58:53 <mbot>  ["foo","oo","o",""]
17:59:21 <lispy> > tails "Sonic"
17:59:25 <mbot>  ["Sonic","onic","nic","ic","c",""]
17:59:30 <Valodim> haha
18:00:35 <Tac-Tics> > tails "lambdabot"
18:00:39 <mbot>  ["lambdabot","ambdabot","mbdabot","bdabot","dabot","abot","bot","ot","t",""]
18:01:06 <Tac-Tics> mbot? You aren't the lambdabot I know!
18:01:14 <pastorn> lispy: HA HA! very funny!!
18:01:55 <lispy> > inits "lambdabot"
18:01:59 <mbot>  ["","l","la","lam","lamb","lambd","lambda","lambdab","lambdabo","lambdabot"]
18:02:18 <lispy> > inits "lambdabot" `intersect` tails lambabot
18:02:19 <mbot>   Not in scope: `lambabot'
18:02:24 <lispy> > inits "lambdabot" `intersect` tails "lambabot"
18:02:25 <Tac-Tics> > inits "lambdabot" \\ tails "lambdabot"
18:02:30 <mbot>  [""]
18:02:30 <mbot>  ["l","la","lam","lamb","lambd","lambda","lambdab","lambdabo"]
18:02:44 <lakupuu> > inits tails "lollero"
18:02:46 <mbot>  Couldn't match expected type `[a]'
18:03:02 <pastorn> @src inits
18:03:02 <mbot> inits []     =  [[]]
18:03:02 <mbot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
18:03:04 <jfredett> @type (&&&)
18:03:07 <lispy> > (sort . inits "lambdabot") `intersect` (sort . tails "lambabot")
18:03:07 <mbot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:03:09 <mbot>  Couldn't match expected type `a -> [a1]'
18:03:13 <lakupuu> > inits.tails "lollero"
18:03:15 <mbot>  Couldn't match expected type `a -> [a1]'
18:03:19 <Valodim> inits tails ["lam", "bda", "bot"]
18:03:23 <jfredett> @type (inits &&& tails) "hello"
18:03:26 <mbot> ([[Char]], [[Char]])
18:03:28 <jfredett> > (inits &&& tails) "hello"
18:03:32 <mbot>  (["","h","he","hel","hell","hello"],["hello","ello","llo","lo","o",""])
18:03:37 <lispy> > ((sort . inits) "lambdabot") `intersect` ((sort . tails) "lambabot")
18:03:42 <mbot>  [""]
18:03:50 <lispy> > ((sort . inits) "lambdabot") `intersect` ((sort . tails) "lambdabot")
18:03:55 <pastorn> > map head $ tails "lollero"
18:03:56 <jfredett> > uncurry (intersect) $ (inits &&& tails) "hello"
18:03:57 <mbot>  ["","lambdabot"]
18:04:03 <mbot>  Exception: Prelude.head: empty list
18:04:04 <mbot>  ["","hello"]
18:04:48 <Tac-Tics> > make some curry for me please (,) "lambdabot"
18:04:49 <mbot>   Not in scope: `please'
18:04:55 <lispy> > \x -> delete "" (delete x ((sort . inits) x) `intersect` ((sort . tails) x)) "racecar"
18:04:56 <mbot>  Couldn't match expected type `[Char] -> t'
18:05:04 <jfredett> > uncurry (intersect) $ (inits &&& tails) "i can haz arrows?"
18:05:08 <mbot>  ["","i can haz arrows?"]
18:06:01 <pastorn> jfredett: not what you intended?
18:06:14 <jfredett> no, thats precisely what I intended
18:06:24 <jfredett> &&& is the greatest thing ever
18:06:25 <jfredett> :)
18:06:39 <jfredett> well, that and the rest of the arrow family
18:06:40 <jfredett> :)
18:07:49 <BMeph> Hmm, thanks for the perspective, jfedett. :)
18:07:57 <jfredett> BMeph: ?
18:08:02 <jfredett> whatdya mean
18:08:52 <lispy> oh hrm....I was trying to make that a palindrome detector
18:09:05 <lispy> but, it it's more of a proper substring palindrome detector
18:09:26 <BMeph> I've been pestering folks to but swap in as a top-level definition. Since it's used in Arrow, it'd be a quick and easy fix to just pass the def on out of the module.
18:09:32 <jfredett> > let isPalin s = uncurry (==) $ (id &&& reverse) s in isPalin "bob"
18:09:34 <mbot>  True
18:09:38 <jfredett> > let isPalin s = uncurry (==) $ (id &&& reverse) s in isPalin "boa"
18:09:42 <mbot>  False
18:10:03 <jfredett> lispy, I think that does it
18:10:03 <jfredett> :)
18:10:27 <jfredett> though, its more usually written as:
18:10:28 <lispy> jfredett: yeah, but that reverses the string, so it takes the fun out of it
18:10:39 <LoganCapaldo> @type ap (==) reverse
18:10:41 <jfredett> lispy, I'm not sure you're going to find a better way
18:10:42 <jfredett> :P
18:10:42 <mbot> forall a. (Eq a) => [a] -> Bool
18:10:56 <jfredett> LoganCapaldo: I think you win.
18:10:59 <lispy> jfredett: well, so i wondered if you could do in terms of inits and tails
18:11:02 <jfredett> if that works, anyway
18:11:02 <BMeph> Ooh... o.O
18:11:06 <jfredett> lispy: hmm
18:11:19 <LoganCapaldo> > ap (==) reverse $ "bob"
18:11:23 <mbot>  True
18:11:26 <lispy> but, racecar gives ["", "r", "racecar"]
18:11:26 <jfredett> > let isPalin s = ap (==) reverse $ s in "boa"
18:11:27 <LoganCapaldo> > ap (==) reverse $ "boa"
18:11:31 <mbot>  "boa"
18:11:32 <vincenz> True
18:11:32 <jfredett> oops. lol
18:11:33 <mbot>  False
18:11:52 <vincenz> jfredett: make your functions pointless
18:12:02 <vincenz> isPalin = (==) `ap` reverse
18:12:18 <vincenz> heh, ap = half on
18:12:18 <jfredett> vincenz: yeh, sometimes it helps me to leave them pointy,
18:12:41 <jfredett> i usually sand them down after I've figured out how everything should work
18:12:45 <LoganCapaldo> @remember vincenz heh, ap = half on
18:12:46 <mbot> It is forever etched in my memory.
18:12:48 <lispy> i think (==) `ap` reverse is harder to read than \s -> ap (==) reverse $ s
18:12:49 <Pseudonym> There's a Monty Python joke in here somewhere.
18:13:01 <Pseudonym> isPalin Cleese == False
18:13:24 <jfredett> LoganCapaldo wins the palindrome detection bit, but i came in a cool second
18:13:29 <jfredett> @src (ap)
18:13:29 <mbot> Source not found. stty: unknown mode: doofus
18:13:33 <jfredett> @src ap
18:13:33 <mbot> ap = liftM2 id
18:13:37 <jfredett> hmm
18:13:43 <jfredett> @type liftM2 is
18:13:45 <mbot> Not in scope: `is'
18:13:45 <jfredett> @type liftM2 id
18:13:47 <mbot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
18:13:49 <pastorn> @src liftM2
18:13:49 <mbot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:14:03 <jfredett> hmm
18:14:20 <sciolizer> Why is it "liftM2 id" instead of "liftM2 ($)"?
18:14:34 <jfredett> @type liftM2 ($)
18:14:35 <sciolizer> @type liftM2 ($)
18:14:36 <mbot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m a -> m b
18:14:37 <mbot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m a -> m b
18:14:38 <jfredett> @type liftM2 (id)
18:14:39 <mbot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
18:14:47 <BMeph> sciolizer: Fewer characters? ;)
18:14:50 <vincenz> lolzor
18:14:51 <sciolizer> heh
18:14:56 <jfredett> types are the same, up to renaming
18:15:01 <vincenz> can i has ($)
18:15:02 <jfredett> sciolizer: i suppose it doesn't matter
18:15:05 <Pseudonym> > uncurry (==) (id &&& reverse) "hello"
18:15:06 <mbot>  Couldn't match expected type `(a, c)'
18:15:14 <LoganCapaldo> alternative defn of ap is ap mf ma = do { f <- mf ; a <- ma ; return (f a) }
18:15:15 <jfredett> you need the $, i think
18:15:22 <vincenz> ($) is the identity function for functions
18:15:22 <Pseudonym> > uncurry (==) . (id &&& reverse) $ "otto"
18:15:24 <mbot>  True
18:15:30 <jfredett> is ap from applicative functor world?
18:15:31 <vincenz> @type ($)
18:15:33 <mbot> forall a b. (a -> b) -> a -> b
18:15:34 <jfredett> or elsewhere?
18:15:42 <LoganCapaldo> it's from monad world :)
18:15:46 <sciolizer> Yeah. I just find "liftM2 ($)" more intuitive.
18:15:46 <jfredett> really?
18:15:58 <vincenz> the new ap is from applicative functor world
18:16:16 <vincenz> @src ap
18:16:17 <mbot> ap = liftM2 id
18:16:24 <vincenz> @hoogle ap
18:16:25 <mbot> http://www.ap.org/
18:16:25 <mbot> Title: The Associated Press | The essential global news network
18:16:29 * vincenz palmslaps
18:16:35 <BMeph> jfredett: It's from Monad, but is the name source for Applicative
18:16:38 <lispy> so then the question is, what monad is used in that def. of isPalin?
18:16:45 <vincenz> actually, never mind, ap in applicative functor = <$>
18:16:53 <Pseudonym> I really, really should not have called this module "PFunctor".
18:17:01 <Pseudonym> Get off your ass and jam!
18:17:04 <jfredett> hmm, interesting
18:17:10 <LoganCapaldo> > ((==) <*> reverse) "bob"
18:17:12 <mbot>  True
18:17:12 <BMeph> vincenz: <*>, actually. <$> is fmap.
18:17:15 <LoganCapaldo> > ((==) <*> reverse) "boa"
18:17:17 <mbot>  False
18:17:18 <vincenz> oh right :)
18:17:21 <vincenz> always confuse the two :)
18:17:33 <vincenz> LoganCapaldo: looks like a spaceship
18:17:34 <pastorn> what is a functor? a collection?
18:17:49 <vincenz> pastorn: functor != applicative functor
18:17:54 <lispy> it supports fmap and something else
18:17:59 <lispy> or maybe just fmap, I forget
18:18:01 <vincenz> functor supports fmap
18:18:04 <sciolizer> pastorn: anything that can be folded, where the fold operation is called "fmap"
18:18:09 <pastorn> vincenz: that's all very tardy, if i know what a functor is to begin with
18:18:10 <vincenz> applicative functor supports <$> and <*>
18:18:11 <sciolizer> pastorn: kind of
18:18:19 <jfredett> sciolizer: actually
18:18:29 <jfredett> Foldable is anything that can be folded
18:18:37 <dobblego> the category theory definition is the most concise, or just think of it as map across "anything" (not just lists)
18:18:38 <Pseudonym> Alternatively, pastorn, a functor is anything which has a trivial way to construct homomorphisms, via "fmap".
18:18:53 <BMeph> sciolizer: Ah, jfreddett beat me to it. :)
18:18:56 <jfredett> :)
18:19:08 <pastorn> folded as in foldl?
18:19:12 <vincenz> jfredett: does it contain shirts?
18:19:13 <Pseudonym> But the way that I think of a Functor, it's anything that doesn't "inspect" its type argument.
18:19:23 <dobblego> pastorn, and foldr (of which map is a specialisation of)
18:19:24 <jfredett> vincenz: hmm, whats the instance defn for shirts?
18:19:24 <vincenz> pastorn: yes, but more genericaclly, foldl is specific to lists
18:19:26 <sciolizer> jfredett: hm. I'll have to look at that.
18:19:30 <Toxaris> vincenz: Applicative functors also support pure.
18:19:35 <lispy> Pseudonym: that's a cool way to look at it
18:19:39 <vincenz> Toxaris: good point
18:19:56 <pastorn> dobblego: i always saw them as very separate functions, part for the higher order commonality
18:20:03 <Pseudonym> lispy: There's one catch, of course, and that's that the type variable can't be in a "negative" position.
18:20:18 <vincenz> mauke: btw, cool idea, use the 'let primes = ...' in ghci, force it to some really high drop-value and then from then on you can use it for free :)
18:20:21 <BMeph> No, map is a specialization of zipWith! ;)
18:20:23 <lispy> Pseudonym: what is a negative position?
18:20:23 <dobblego> pastorn, try writing map in terms of foldr (a very good exercise)
18:20:32 <pastorn> dobblego: thanks :)
18:20:36 <Pseudonym> data F a = F (a -> ())
18:20:44 <Pseudonym> instance Functor F where {- ? 0}
18:20:46 <dobblego> pastorn, also, filter, ++ and concatMap :)
18:21:04 <Pseudonym> instance Functor F where {- ? -}
18:21:16 <Pseudonym> The left-hand-side of a (->) is "negative".
18:21:28 <Pseudonym> ?free f :: (a -> ()) -> a
18:21:29 <mbot> Unknown command, try @list
18:21:39 * Pseudonym cries, no free theorems
18:22:04 <jfredett> nothing in life is free, Pseudonym
18:22:09 <Pseudonym> Theorems are!
18:22:13 <lispy> Pseudonym: that definition looks vaguely like rank-2 blah
18:22:18 <jfredett> no such thing as a free theorem? :P
18:22:29 * Cale hands jfredett a vector space.
18:22:46 <BMeph> The best things in life are free. Theorems are free. Therefore... :)
18:22:56 <jfredett> Cale: Yay! I've always wanted my very own VS!
18:23:07 <Toxaris> Pseudonym: ... where fmap _ _ = F (\_ -> ())
18:23:10 <lispy> the best things in life are not free...i had to buy her dinner...(oh wait, I'm getting OT)
18:23:11 <jfredett> is it one of those fancy Inner Product spaces too?
18:23:23 <Cale> It's free too!
18:23:24 <jfredett> lispy: take that to blah, :P
18:23:35 <Cale> (http://en.wikipedia.org/wiki/Free_object)
18:23:35 <Pseudonym> Now give me money.  That's what I want.
18:23:43 <BMeph> lispy: If you HAD to buy her dinner, maybe she wasn't the best. ;)
18:23:46 <vincenz> dons: ?
18:24:07 <BMeph> Although, the dinner was free for her... :)
18:24:07 <vincenz> dons: why isn't 'make' in that new benchmark strict on it's input?
18:24:11 <pastorn> dobblego: i'll do them soon, just need some fuuuuud
18:24:16 <Pseudonym> Anyway, the "doesn't inspect" idea of Functors is a good way to connect Functors with their free theorems.
18:24:38 <pastorn> map eat (repeat food)
18:24:44 <dobblego> pastorn, I run a Scala course regularly; we do it on the first or second day, it's always very effective for learning ;)
18:24:52 <lispy> Pseudonym: I didn't know free theorems were useful
18:25:03 <Korollary> lispy: You get what you paid for.
18:25:03 <pastorn> dobblego: scala's the new java, right?
18:25:04 <Cale> (In that it is guaranteed to have a basis which it is freely generated by)
18:25:09 <jfredett> Scala, I should learn that sometime.
18:25:11 <dobblego> pastorn, let's hope so
18:25:12 <Pseudonym> lispy: Obviously you don't read my blog.
18:25:15 <pastorn> or the java/haskell bastard
18:25:18 <lispy> Pseudonym: correct.
18:25:23 <LoganCapaldo> free theorums -> how we get list fusion -> optimizations, no?
18:25:26 <dobblego> yeah, Java/Haskell/ML
18:25:28 <jbapple> @djinn (a -> a)
18:25:28 <mbot> Unknown command, try @list
18:25:32 <jbapple> @list
18:25:33 <mbot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:25:39 <dons> vincenz: strictness analysis?
18:25:43 <Pseudonym> Turns out that two of the Arrow axioms aren't axioms at all.  They're corollaries of free theorems.
18:25:53 <Cale> jbapple: mbot doesn't have all the commands listed there
18:25:58 <dons> vincenz: $wmake_r1gV :: GHC.Prim.Int# -> GHC.Prim.Int# -> Main.Tree
18:25:59 <jfredett> Pseudonym: *twitch*
18:26:07 * jfredett runs to wikipedia
18:26:09 <Cale> jbapple: But lambdabot is down, so I put mbot in here.
18:26:12 <lispy> scala has some nasty semantics in some places though...I forget the examples, but one term I found several things that were either implemenation bugs are just plain flawed semantics.
18:26:20 <jfredett> something cooler than arrows? free theorems, nifty!
18:26:26 <jbapple> ah, that explains why mbot won't talk to me in a private channel
18:26:49 <DRMacIver> jbapple: There are definitely some instances of Scala semantics being stupid.
18:26:58 <Cale> jbapple: Just register, and it will.
18:27:06 <jbapple> Cale: thanks
18:27:08 <DRMacIver> jbapple: I can't remember any particular instaces of it being really flawed.
18:27:24 <pastorn> http://rosettacode.org/rosettacode/w/index.php?title=Category:Scala <-- here the good stuff it
18:27:25 <DRMacIver> (But bugs are highly possible)
18:27:34 <jbapple> DRMaclver: you mean lispy
18:27:43 <jbapple> DRMaclver: I have no opinions on Scala
18:28:05 <DRMacIver> Oops. Yes.
18:28:10 <DRMacIver> Dont' know why I read that s you. Sorry.
18:28:11 <Pseudonym> jfredett: http://andrew.bromage.org/blog/archive/2007/09/post.html
18:28:29 <jfredett> damn my inadequate abstract algebra knowledge!
18:28:53 <jfredett> *stares at the wiki entry for free objects* maybe you're blog will be more lucid
18:29:37 <Pseudonym> jfredett: Unlikely.  Free objects actually aren't difficult.
18:29:41 <Pseudonym> Want a quick rundown?
18:29:48 <jfredett> Pseudonym: go for it,
18:29:53 <Pseudonym> OK.
18:29:56 <Pseudonym> You know what a monoid is?
18:30:06 <jfredett> a kind of generalized group
18:30:09 <jfredett> as i recall
18:30:13 <Pseudonym> Right.
18:30:19 <Pseudonym> Think of it as two operations:
18:30:24 <Pseudonym> zero, and <+>
18:30:27 <Pseudonym> With the laws:
18:30:40 <Pseudonym> (x <+> y) <+> z = x <+> (y <+> z)
18:30:42 <Pseudonym> and:
18:30:48 <Pseudonym> zero <+> x = x <+> zero = x
18:30:50 <jfredett> associative, identity, and closure, right?
18:30:54 <BMeph> DRMacIver: Does Scala use that property with function signatures that you found in the JVM?
18:30:55 <Pseudonym> Right.
18:31:00 <jfredett> okay,
18:31:00 <Pseudonym> Now that describes a lot of things.
18:31:10 <Pseudonym> From lists with concatenation, to numbers with addition...
18:31:14 <vincenz> dons: ah
18:31:15 <jfredett> right
18:31:15 <Pseudonym> All groups, of course.
18:31:16 <vincenz> dons: neat :)
18:31:17 <DRMacIver> Pseudonym: What's >< supposed to be in that post?
18:31:18 <Pseudonym> Lots of things.
18:31:28 <Pseudonym> DRMacIver: read on
18:31:32 <DRMacIver> BMeph: Yeah. It's used for its primitive optimisations among other things.
18:31:44 <DRMacIver> Pseudonym: Oh, sorry.
18:31:50 <Pseudonym> >< is essentially ***, only for functions.
18:31:58 <DRMacIver> Ah, right
18:32:03 <BMeph> DRMacIver: Interesting. Was that how you found out about it, I'm guessing? :)
18:32:09 <Pseudonym> Believe it or not, it's in the GHC library, but it's tucked away in Data.Graph.Lazy.Somewhere.Bizarre.
18:32:24 <DRMacIver> BMeph: Yep
18:32:29 <Pseudonym> If hoogle was working, I'd find it for you. :_)
18:32:32 <Cale> jfredett: Do you happen to know what a category is?
18:32:36 <Pseudonym> Anyway, jfredett.
18:32:40 <jfredett> vaguely, Cale
18:32:44 <Pseudonym> A monoid is defined over some set.
18:32:56 <DRMacIver> BMeph: I was looking at the bytecode to check if some optimisations were being performed.
18:32:58 <Pseudonym> Where x <+> y makes sense for any two elements of the set.
18:33:02 <Pseudonym> Right?
18:33:02 <BMeph> Cale: Categories are hard. Let's go shopping! ;)
18:33:04 <jfredett> Cale: objects, arrows, identity, all that
18:33:07 <jfredett> Pseudonym: sure
18:33:07 <Cale> yeah
18:33:10 <Pseudonym> OK.
18:33:23 <Pseudonym> The "free monoid" is the monoid where that's _everything_.
18:33:51 <Pseudonym> An example is finite-length lists.
18:33:54 <jfredett> you mean where x  <+> y is "everything"?
18:33:58 <Pseudonym> In a sense, it's the most general monoid.
18:34:11 <Pseudonym> Right?
18:34:20 <Pseudonym> [1] ++ [2] == [1,2]
18:34:26 <jfredett> oh!
18:34:40 <Pseudonym> The list contains all of the information, given that monoids are associative and have left and right identity.
18:34:47 <lispy> oh, here was a problem I found in Scala, if a parent trait defined some state, then the children traits used that same state and it was shared across the trait heirarchy
18:35:11 <Pseudonym> The representation preserves that, since (xs ++ ys) ++ zs == xs ++ (ys ++ zs)
18:35:15 <dobblego> lispy, what behaviour would you expect?
18:35:17 <Pseudonym> and ditto for the identity.
18:35:22 <jfredett> right
18:35:36 <Pseudonym> It's also the most general monoid in a deep categorical sense.
18:35:46 <jfredett> okay
18:36:06 <Pseudonym> Take any other monoid over Int, say.
18:36:10 <lispy> dobblego: I would expect traits to work like other type heirarchies in scala
18:36:14 <Pseudonym> Let's say, Ints with addition.
18:36:17 <jfredett> okay
18:36:17 <Cale> jfredett: Well, a concrete category is one where we can think of the objects as sets (but maybe not all sets), and the arrows as functions between them (but maybe not all the functions). Most of the categories in mathematics are of this type. An object Q of a concrete category is said to be freely generated by the set X, if there is some map h: X -> Q such that for every other object R, and every function f: X -> R, t
18:36:17 <Cale> here is a *unique* morphism g: Q -> R such that g . h = f
18:36:25 <lispy> dobblego: if the parent declares some state, then the children get their own copy
18:36:35 <Pseudonym> As Cale just said, there's a _unique_ homomorphism from [Int] to Ints-with-addition.
18:36:35 <dobblego> lispy, I don't know why you'd expect that
18:36:55 <Pseudonym> Ditto for any monad over Ints that you can think of.
18:37:03 <Pseudonym> There's a _unique_ morphism from [Int] to that monoid.
18:37:06 <Pseudonym> s/monad/monoid/
18:37:09 <lispy> dobblego: because it's never mentioned to do otherwise, and the other language features work that way
18:37:19 <dobblego> lispy, what other language features are you thinking of?
18:37:26 <lispy> dobblego: classes
18:37:27 <jfredett> oh-
18:37:28 <Cale> That is to say we can sort of think of X as a subset of Q so that if you define where the elements of X go, you can say where every element of Q is going.
18:37:28 <mauke> :t scanl
18:37:30 <mbot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
18:37:32 <dobblego> no, they don't do that
18:37:41 <Pseudonym> So "free" in this sense really means "most general".
18:37:54 <Cale> jfredett: If you've had a course on linear algebra, this is the case with bases and linear transformations.
18:38:02 <dobblego> lispy, that's not true; and in any case, a trait *is* a class
18:38:08 <jfredett> so the free monoid is like a monoid to which every other monoid can be mapped to?
18:38:12 <lispy> dobblego: what is not true?
18:38:14 <Cale> If you know where a linear transformation sends each basis element, you know where it sends everything.
18:38:19 <dobblego> lispy, that classes behave that way
18:38:21 <jfredett> Cale: OH!
18:38:22 <Pseudonym> jfredett: Yes, and the mapping is unique.
18:38:22 <jfredett> yah
18:38:25 <lispy> dobblego: er...??
18:38:26 <jfredett> I get it now
18:38:33 <lispy> dobblego: i think you misunderstood me
18:38:37 <jfredett> i see
18:38:43 <Cale> So yeah, free objects are the generalisation of that.
18:38:45 <dobblego> lispy, perhaps
18:38:49 <Pseudonym> Right.
18:38:56 <Pseudonym> Lots of things are "free" in that sense.
18:39:02 <Pseudonym> Like initial objects.
18:39:06 <jfredett> like theorems, apparently
18:39:16 <lispy> dobblego: my experience when I used scala, was that state defined in a parent trait, was SHARED in all child instances of that trait
18:39:17 <Cale> Well, I'm not sure if those are really related here :)
18:39:24 <lispy> dobblego: but, normal classes don't do that
18:39:27 <Pseudonym> Not really, no.
18:39:28 <Cale> It would be quite interesting if that was true :)
18:39:34 <jfredett> oh.
18:39:41 <Pseudonym> I mean, they're related, but the sense in which free theorems are "free" is that you don't have to prove them.
18:39:41 <Cale> (in some strange sense, certainly, if at all)
18:39:44 <dobblego> lispy, that's untrue; all types do that, as I would expect and so would anyone familiar with Java/C++
18:39:50 <jfredett> i see.
18:39:50 <lispy> dobblego: i think i neven submitted a bug report
18:40:02 <Pseudonym> Free theroems have cool structure, though.
18:40:05 <jfredett> so a free object is just an object to which there exists a mapping to any other objects?
18:40:11 <jfredett> object*
18:40:14 <Pseudonym> If F and G are Functors, for example, this function:
18:40:17 <Pseudonym> f :: F a -> G a
18:40:19 <lispy> dobblego: no, this behavior was not the normal kind
18:40:29 <Pseudonym> has a free theorem which essentially says "f is a natural transformation".
18:40:31 <Cale> jfredett: nearly so.
18:40:44 <Cale> jfredett: To everything except possibly empty objects.
18:40:52 <Tac-Tics> What's so natural about natural transformations?
18:40:55 <jfredett> ahh.
18:41:06 <lispy> dobblego: i've programming in languages like Java/C++ for about a decade and the behavior was quite socking (took quite a bit of testing/debugging to convince myself)
18:41:09 <jfredett> well those are pretty damn nifty...
18:41:24 <dobblego> lispy, I'd love to see a case for it
18:41:40 <Cale> Tac-Tics: That's a deep question. The intuition is that they act in "the same way" regardless of the object which the functor they act on is being applied to.
18:42:11 <lispy> dobblego: the code that did it, is in this repo, and there is also a project write up that mentions it: http://codersbase.com/index.php/DarcsSim
18:42:19 <Pseudonym> A Haskell way of thinking about it is:
18:42:22 <Cale> Tac-Tics: Sort of like how  concat :: [[a]] -> [a] doesn't behave differently when it's acting on a list of lists of integers.
18:42:25 <Pseudonym> f :: forall a. F a -> G a
18:42:31 <Pseudonym> That really means "for all a".
18:42:41 <Pseudonym> i.e. f can't assume _anything_ about the type of a
18:42:44 <Cale> (even though potentially, it could, say, add up the elements in each of the contained lists, and get the right type)
18:42:45 <jfredett> right
18:42:48 <lispy> dobblego: I had a UsageCollector trait
18:42:48 <Pseudonym> And it can't assume that it supports any particular operations.
18:42:53 <Pseudonym> Which means it really does not inspect a.
18:42:58 <lispy> dobblego: and then I would subclass it for the different types of 'usage'
18:43:06 <Tac-Tics> Speaking of mathy stuff, is there any practical use for higher rank typing?
18:43:12 <lispy> dobblego: My statics were all weird
18:43:24 <Cale> Tac-Tics: Well, there's tricks like the one used by ST.
18:43:33 <lispy> dobblego: so in the Project write up, look at the second paragraph in the section 3.5 Traits
18:43:50 <Pseudonym> They're used in Church-encoding of structures.
18:44:03 <Pseudonym> Or hand-implementing typeclass dictionaries.
18:44:23 <Tac-Tics> Where it hides the implementation of a type? That one I could see as being useful. I guess I don't fully understand them, but I was thinking about objects with a type like (forall a. a -> [b]) -> b
18:44:42 <dobblego> lispy, "no constructor arguments to traits" is solved by using an abstract class, which is exactly what a trait is (which is why I am sceptical of your claims)
18:44:44 <Tac-Tics> where the quantifier is local in the type
18:45:30 <dobblego> traits do not have static members
18:45:40 <Cale> Tac-Tics: You can use them to get a certain level of security in that your function takes a function which must not be allowed to inspect certain parts of the data it's given.
18:46:23 <Tac-Tics> Are there any simple examples to illustrate that? I have a vague idea of what you mean
18:46:37 <Cale> Tac-Tics: Basically, all that higher-rank types are is a way of insisting that certain things really be polymorphic.
18:47:10 <Cale> Well, okay, perhaps I can concoct something... :)
18:47:27 <Saizan> yeah, like keeping the possibility to apply an argument polymorphically
18:47:28 <airport> I need some help with runInteractiveCommand please
18:47:29 <airport> http://pastie.caboo.se/141356
18:47:47 <airport> why does the code hang after line 6
18:47:47 <Cale> Saizan: well, there's that too.
18:48:15 <airport> but if i comment out lines 9-11, then it goes through?
18:48:49 <Saizan> > let f :: (forall a. Show a => a -> String) -> (String,String); f g = (g 'a', g 1) in f show -- old little example
18:48:50 <mbot>  Parse error at "." (column 19)
18:48:58 <lispy> dobblego: yeah, looking at the code in the repo, i was forced to use an Abstract class for UsageCollector
18:49:12 <Saizan> well, with -fglasgow-exts :)
18:49:21 <DRMacIver> lispy: I'm not really sure what you're talking about either. Traits certainly don't share members between different instances.
18:49:29 <Cale> airport: I might be able to figure that out, but there's a nicer library for interacting with other programs out there I could also point you to.
18:49:42 <lispy> well, I had a very, very concrete example where that was definitely happening.
18:49:48 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HSH-1.2.5
18:49:51 <airport> any solution is good for me
18:49:53 <Cale> http://software.complete.org/hsh
18:50:12 <Cale> (the latter link has some examples of usage)
18:50:27 <DRMacIver> lispy: I have a very very concrete example where it's definitely not, unless I'm totally misunderstanding you.
18:51:08 <Cale> (I really hope that it's been maintained :)
18:51:19 <airport> i'll check in out
18:51:26 <DRMacIver> lispy: Where am I supposed to be looking in your darcs repo?
18:51:26 <lispy> where is the scala bug database, maybe I submitted the example I made...
18:51:33 <airport> the interface does seem simpler
18:51:47 <DRMacIver> lispy: http://lampsvn.epfl.ch/trac/scala
18:51:49 <lispy> DRMacIver: StatCollector.scala has the final version of the code, unfortunately it doesn't have the broken version in the history
18:52:03 <Cale> If you have cabal-install installed, it should be just   sudo cabal --global install HSH  to install it.
18:52:32 <lispy> this is not the bug tracker i used, iirc
18:52:45 <Cale> oh, d'oh, it needs some changes made to its .cabal file
18:52:46 <Cale> hmm
18:52:55 <DRMacIver> lispy: Is http://pastebin.com/m5228b4f8 not a counterexample to what you're claiming?
18:52:55 <Cale> I wonder if I'm allowed to upload a new version :)
18:53:47 <DRMacIver> lispy: Presumably http://scala-webapps.epfl.ch/bugtracking/bugs/displayBugs.do then
18:54:14 <lispy> DRMacIver: the behavior in your paste is what I would want, but not what I was getting.
18:54:30 <DRMacIver> When was this?
18:55:06 <DRMacIver> If it was many many versions ago I suppose the semantics of traits could have changed since then, but traits have always worked this way since I've started using Scala at least.
18:55:49 <DRMacIver> And it seems like the behaviour you're suggesting is obviously stupid and contrary to how traits are intended to work, so I can't imagine it ever being in. But clearl you observed *something* screwy happening...
18:56:20 <lispy> I wrote darcssim in dec. 2007
18:56:29 <DRMacIver> Huh
18:56:35 <lispy> and i used whatever version was current on the mac
18:56:40 <DRMacIver> I really can't imagine what you saw then.
18:56:47 <DRMacIver> Because traits just don't work like that.
18:56:49 <dobblego> neither
18:57:34 <Hanto> Could Haskell help me with a network program I'm making?
18:57:42 <smack__> @faq
18:57:43 <mbot> The answer is: Yes! Haskell can do that.
18:58:27 <Hanto> OH...
18:58:28 <Hanto> Hmmm
18:58:39 <Hanto> And it's native to which operating system please?
18:58:48 <Hanto> sorry for using you as a faw
18:58:50 <Hanto> faq*
18:58:56 <Hanto> I kind of stumbled in here
18:58:57 <Philippa_> "native"?
18:59:01 <Hanto> very very randomly
18:59:06 <kmcallister> Hanto, there are haskell implementations for every major OS
18:59:12 <Hanto> Ok...
18:59:14 <Hanto> interesting
18:59:15 <kmcallister> (as with most languages)
18:59:16 <Hanto> Hmmm
18:59:18 <jfredett> and some of the minor ones, I'm sure
18:59:21 <Hanto> true
18:59:31 <Philippa_> it's slightly more at home on *nix than windows, but only slightly
19:00:05 <Hanto> Good
19:00:11 <Hanto> Nix is my middle name
19:00:43 <dobblego> Hantonix
19:00:56 <Tac-Tics> Haskellix
19:01:01 <Hanto> Yeah...
19:01:05 <Hanto> Hantonix
19:01:09 <Hanto> sounds like a drink
19:01:42 <Pseudonym> Sounds like one of the gauls from Asterix.
19:01:57 <Hanto> Can't argue that
19:04:33 <Hanto> Oh wait....
19:04:40 <Hanto> Nix isn't my middle name!
19:04:42 <Hanto> What's nix?
19:06:22 <lispy> dobblego, DRMacIver: I'm not seeing my bug (maybe I didn't get around to reporting it) but I do see a lot of bugs related to traits.  Perhaps I was hitting one of them.
19:07:28 <DRMacIver> lispy: Could be. But I simply can't imagine how a bug like what you describe could occur.
19:07:42 <Cale> oh, ha! It's been recently updated.
19:07:55 <Cale> So HSH should be installable. :)
19:09:26 <Cha1> Hanto: *nix means "unix-like"
19:09:50 <airport> Cale: I installed cabal, does that include cabal-install?
19:10:05 <Cale> airport: Not yet, I don't think.
19:10:17 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install-0.4.0
19:10:21 <Cale> you can get it from here
19:10:47 <airport> thanks
19:10:51 <Cale> It can download and install the packages on hackage for you. (at least, when they're not broken due to the base split problem :)
19:11:46 <airport> maybe it's just me, but a lot of haskell libraries seem to have problems building on cygwin
19:11:56 <airport> which is what I use
19:12:10 <Cale> I think the GHC people on windows use mingw.
19:12:28 <Cale> But I don't really know anything about it.
19:12:31 <soduko> any happs users here?
19:13:37 <airport> ok, might have better luck on mingw then
19:13:49 <Cale> Maybe in #happs? (Though those people are probably all in here too :)
19:14:31 * ddarius missed a CT and a higher-ranked types conversation.
19:15:18 <soduko> but except for you joining and leaing there doesnt seem to be any activity there:)
19:16:29 <Cale> soduko: I was just checking if it was populated :)
19:17:20 <soduko> Cale: do you use happs?
19:18:01 <ddarius> Cale writes programs that count things.
19:18:02 <Cale> I haven't.
19:18:08 <Cale> Yeah, mostly :)
19:18:10 <Cale> heh
19:19:17 <Cale> I recently wrote a small library for comparing regular expressions for equality and containment. I should probably Cabalise it. :)
19:19:28 <ddarius> dons would say to.
19:19:34 <airport> hey speaking of regex
19:19:35 <ddarius> And then put it on hackage.
19:19:49 <soduko> unfortunatley there doesnt seem to be good docs on happs.  so im able to only follow the isntructions and serve static pages.. i want to understand what else can be done with it
19:20:10 <vincenz> maximumBy overflows :|
19:20:15 <airport> i just wrote a regex replace function that lets you use the captures in the replacement string
19:20:16 <vincenz> @src maximumBy
19:20:16 <mbot> Source not found. Maybe you made a typo?
19:20:47 <Cale> airport: Is it based on regex-base?
19:20:57 <Saizan> mbot is so polite!
19:21:03 <airport> was that a dumb thing to do? is there a better way to do that?
19:21:18 <airport> used Text.Regex.Posix
19:21:46 <Cale> airport: ah, okay :)
19:22:55 <Cale> airport: As far as I know, there's sort of a gap in our regex support in that regard. You're expected to just take the bits which the match operator hands you and combine them however you like, which is safe, but less convenient than it could be.
19:23:49 <airport> i see
19:24:01 <airport> can you use regex in pattern matching?
19:24:36 <Cale> On Haskell datastructures? Not really, no. There was something called HaRP, iirc, which let you do that.
19:24:47 <Cale> (It was a preprocessor for Haskell sources.)
19:25:45 <Cale> You can, however, use things like pattern guards along with matching.
19:26:23 <Cale> (and there's something possibly coming up soon called view-patterns which would also help with that)
19:27:42 <airport> hmm
19:28:20 <Cale> Regular expressions aren't really in the spirit of Haskell though. It's usually much nicer to use something like Parsec.
19:28:57 <smack__> @hoogle shuffle
19:28:57 <mbot> http://www.apple.com/ipodshuffle/
19:28:57 <mbot> Title: Apple - iPod shuffle
19:29:07 <Valodim> hahaha
19:29:08 <smack__> heh
19:29:09 <vincenz> :t foldl1'
19:29:10 <Cale> (which as an added benefit will let you parse any context-free and many context sensitive grammars as well)
19:29:10 <mbot> forall a. (a -> a -> a) -> [a] -> a
19:29:32 <Cale> Spell-correcting :)
19:29:40 <Cale> (I don't have the hoogle plugin installed)
19:29:44 <smack__> yep.  mbot doesn't have hoogle?  yep.
19:30:35 <airport> Parsec is sort of a parser generator?
19:30:48 <kmcallister> airport, it's a parser library
19:30:55 <Cale> airport: Sort of. It's a library for representing and manipulating parsers as first-class values.
19:30:59 <ddarius> Parser generators aren't really in the spirit of Haskell.
19:31:03 <kmcallister> unlike lex/yacc/happy/etc. you don't use a special language or syntax
19:31:31 <vincenz> :t foldr1
19:31:32 <vincenz> @src foldr
19:31:32 <mbot> forall a. (a -> a -> a) -> [a] -> a
19:31:32 <mbot> foldr k z xs = go xs
19:31:32 <mbot>     where go []     = z
19:31:32 <mbot>           go (y:ys) = y `k` go ys
19:31:39 <vincenz> @src foldl
19:31:39 <mbot> foldl f z xs = lgo z xs
19:31:39 <mbot>     where lgo z []     =  z
19:31:39 <mbot>           lgo z (x:xs) = lgo (f z x) xs
19:31:44 <Cale> vincenz: noooo... bad @src :)
19:31:46 <vincenz> @src foldl'
19:31:46 <mbot> foldl' f a []     = a
19:31:47 <mbot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
19:31:56 <vincenz> Cale: eh?
19:32:00 <Cale> foldl' is the only well-written one
19:32:09 * ddarius would write foldl' differently.
19:32:11 <vincenz> maximumBy was bloating my stack
19:32:22 <vincenz> and sortBy was not possible :|
19:32:43 <Cale> foldr f z [] = z; foldr f z (x:xs) = f x (foldr f z xs)
19:32:57 <Cale> foldl f z [] = z; foldl f z (x:xs) = foldl f (f z x) xs
19:32:59 <ddarius> foldr c n ...
19:33:05 <Cale> Or sure, c n :)
19:33:09 <faxathisia> Hi
19:33:16 <Cale> hi
19:33:51 <faxathisia> I want to ask how people would solve this..
19:34:03 <Cale> faxathisia: Has gio123 been bothering you too? I noticed he asked for you in #prolog (or was that you?)
19:34:07 <dobblego> > join (Left(Right 7))
19:34:08 <mbot>   add an instance declaration for (Error (Either a t))
19:34:08 <mbot>     In the expression:...
19:34:34 <kmcallister> :t join
19:34:36 <mbot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:35:28 <dons> Cale: he's been bothering me.
19:35:34 <Cale> heh
19:35:54 <faxathisia> If you had made e.g.  data Ex = Var String | Num Integer | Add Ex Ex  | Sub Ex Ex | Mul Ex Ex  | Div Ex Ex
19:35:55 <Cale> Sorry about that. I helped him for a while, but he's just gotten too annoying.
19:35:56 <LoganCapaldo> > join (Right (Right 7)) :: Either String Int
19:35:58 <dons> ok
19:35:58 <mbot>  Right 7
19:36:35 <dobblego> > join (Left (Right 7)) :: Either String Int
19:36:36 <mbot>  Couldn't match expected type `String'
19:36:52 <dobblego> > join (Left (Right 7)) :: Either Int Int
19:36:53 <mbot>  Couldn't match expected type `Int'
19:37:01 <LoganCapaldo> (it's instance Monad (Either String a) or some such)
19:37:08 <dobblego> ah
19:37:14 <faxathisia> What I'm wondering is how to write a show function which drops as many parens as possible
19:37:14 <Cale> I read three papers for him, and explained some things, but he seems to be attempting to write code for an algorithm which he doesn't understand, and he wants me to help him debug his prolog code.
19:37:15 <bos> dons: "made of win and awesome"? :-)
19:37:23 <Saizan> Error e => Either e
19:37:28 <ddarius> faxathisia: Use showsPrec, that's what it is for.
19:37:47 <dons> bos :) kids these days.
19:37:52 <ddarius> Cale: This isn't #prolog
19:38:30 <Cale> ddarius: I know. He seems to think it's okay to try to get my attention when I'm not around by talking at me in channels that I'm in.
19:40:05 <faxathisia> ddarius, great thanks! That's amazingly simple compared to what I was doing
19:47:38 <aFlag> I hate prolog
19:47:57 <faxathisia> I like it
19:48:24 <aFlag> I feel it makes matters worst
19:49:18 <faxathisia> hm..
19:49:35 <aFlag> worse
19:49:43 <faxathisia> I don't think I can drop every paren I want with shosPrec
19:49:57 <faxathisia> (Var "x" `Add` Var "y") `Add` (Var "z" `Add` Var "w")   prints as   (x + y) + (z + w)
19:51:00 <faxathisia> showsPrec*
19:51:11 <ddarius> ?  That should be quite doable.
19:51:31 <faxathisia> To make it print as x + y + z + w?
19:51:36 <ddarius> Yes.
19:51:37 <lispy> :t showsPrec
19:51:39 <mbot> forall a. (Show a) => Int -> a -> String -> String
19:51:50 <ddarius> I'm wondering what you are doing to make it not.
19:53:41 <ddarius> The code should look like: showsPrec prec (Add x y) | prec > addPrec = showParens ( ... ) | otherwise = ...
19:54:14 <ddarius> You just recursively call with addPrec in that case.
19:54:48 <ddarius> :t showParens
19:54:50 <mbot> Not in scope: `showParens'
19:54:54 <ddarius> :t showParen
19:54:55 <mbot> Bool -> ShowS -> String -> String
19:55:26 <lispy> what is addPrec
19:55:27 <lispy> ?
19:55:34 <ddarius> It actually should look like, showsPrec prec (Add x y) = showParen (prec > addPrec) (showsPrec addPrec x) . ('+':) . showsPrec addPrec y)
19:55:53 <airport> i am having a bit of trouble with cabal install
19:55:54 <faxathisia> I think that I got to now
19:56:01 <ddarius> lispy: addPrec is the name for the addition precedence level, i.e. addPrec = 1; mulPrec = 2
19:56:26 <airport> it asked me to update, i did, and then now it's giving me an error when I try to install
19:56:26 <lispy> ddarius: ah, hrm, look ingat Text.Show now and I didn't see that...did faxathisia define it?
19:56:36 <ddarius> lispy: I'm assuming it.
19:56:48 <airport> cabal.exe: Data.ByteString.Lazy.index: index too large: 0
19:57:39 <lispy> 0 is pretty small as for as natural numbers go...
19:58:16 <ddarius> > []!!0
19:58:21 <mbot>  Exception: Prelude.(!!): index too large
19:58:41 <lispy> > length [] > 0
19:58:44 <mbot>  False
19:59:11 <ddarius> > [1,3,4]!!length [1,3,4]
19:59:14 <mbot>  Exception: Prelude.(!!): index too large
20:00:33 <vincenz> :i Monoid
20:01:30 <Cale> airport: Oh! Which version of Cabal do you have?
20:01:46 <Cale> airport: The one which comes with GHC 6.8.2 should be fine.
20:01:59 <lispy> it's cabal.exe, quick blame windows! ;)
20:02:17 <ddarius> lispy: I blame global warming.
20:02:26 <airport> =)
20:02:45 <lispy> ddarius: i blame unicorns then, since we're blaming made up things! ;)
20:02:48 <ddarius> Cale: You should learn to knit and crochet if you haven't already.
20:03:12 <ddarius> lispy: There are unicorns all over the place where I'm from.
20:03:20 <airport> i guess it's cabal-install-0.4.0
20:03:25 <airport> that i just installed
20:04:27 <Cale> Global warming: a process by which global variables are heated to a high temperature, melted, and later cast into ingots. See: ingot variables.
20:05:56 <hpaste>  ramza3 pasted "Bad design?" at http://hpaste.org/5115
20:06:23 <faxathisia> hehe
20:06:40 <Cale> ramza3: You could, say, use the reader monad.
20:06:40 <ramza3> in that code, I think I am not using good design; should I use a class/IORef or none of the above
20:06:50 <Cale> ramza3: But that's not a terrible design.
20:06:58 <ddarius> ramza3: Classes don't keep state.
20:07:08 <Cale> ramza3: The functions actually depend on that parameter, and so it's nice that they explicitly mention it.
20:07:10 <ddarius> And IORefs are rarely adviseable.
20:08:51 <kmcallister> ramza3, you're not updating the list, so i would use the Reader monad
20:09:14 <Cale> http://www.loganrawmaterials.com/meltable_program_description.htm
20:09:49 <Cale> Google allows for the surreal.
20:09:59 <ddarius> Meltable Program Manual?  Cool!
20:10:13 <kmcallister> haskell should allow the creation of meltable programs
20:10:39 <dons> i reckon with the FFI, that's possible, yep.
20:10:57 <ddarius> If we get all of dons' cores topped out at the same time.
20:11:41 <Cale> (that page is apparently the only match for "ingot variables")
20:11:58 <Cale> (aside from a PDF version of the same)
20:24:47 <mxc> newbie question, whats the difference between the . operator and the $ operator?  is it just an issue of fixity?
20:25:15 <faxathisia> mxc, (a . b) x = a (b x)
20:25:24 <ddarius> :t ($)
20:25:26 <mbot> forall a b. (a -> b) -> a -> b
20:25:27 <ddarius> :t (.)
20:25:29 <mbot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:25:32 <faxathisia> mxc, $ just applies a function
20:25:40 <faxathisia> mxc, f x = f $ x
20:25:46 <mxc> got it
20:26:19 <mxc> has lambdabot been renamed?
20:26:34 <faxathisia> so also,  f . g . h $ x = f (g (h x))
20:26:38 <ddarius> No.
20:26:59 <ddarius> mbot is one of the various instances of lambdabot running on freenode (and elsewhere).  The actual lambdabot is having network issues.
20:27:05 <mxc> ah
20:32:03 * BMeph wishes the real lambdabot would please stand up
20:48:56 <nolrai> :t Monad.forM
20:48:57 <mbot> Not in scope: `Monad.forM'
20:49:06 <nolrai> :t Control.Monad.forM
20:49:08 <mbot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
21:14:09 <wy> hello
21:14:43 <faxathisia> Hi
21:15:00 <chessguy> @hoogle (a -> Bool) -> a -> Maybe a
21:15:01 <mbot> http://www.haskell.org/haskell-report/Maybe.html
21:15:01 <mbot> Title: The Haskell 1.3 Library Report: Maybe Utilities
21:15:15 <Cale> heh, that's at least possibly useful :)
21:15:23 <faxathisia> Is that a new hoogle?+
21:15:26 <Cale> (lambdabot is gone and mbot doesn't have hoogle)
21:15:33 <Cale> (so you got google's result)
21:15:40 <faxathisia> aha
21:15:51 <wy> I'm trying to get a suitable set of classes for this semester. I hope to get some ideas here for a helpful math course for FP design
21:16:47 <Cale> Enumerative/algebraic combinatorics would be good, if your uni has something good along those lines.
21:17:22 <Cale> I don't really know. A lot of mathematics doesn't apply directly but does actually help to shape your mind.
21:17:44 <wy> There is one here: http://www.math.cornell.edu/Courses/GradCourses/sp08/739.html
21:18:05 <wy> I don't know if model theory would be helpful
21:18:22 <Cale> hmm...
21:18:48 <wy> I'm also considering metaphysics ;-)
21:18:57 <Cale> That course looks interesting, but I don't know how relevant most of that stuff would be to FP.
21:19:22 <Cale> I suppose the posets and lattices stuff would be quite good preparation for Scott domains.
21:19:54 <Cale> and depending on what "permutations and partitions" actually means, there might be some useful stuff in there.
21:19:55 <wy> Is there some courses would be directly have Scott domains?
21:20:24 <Cale> Possibly? I would be kind of surprised to see them directly in a mathematics curriculum.
21:21:16 <wy> unfortunately enumberative combinatorics is not held this semester
21:21:55 <Cale> Also, the course does sound a bit harsh if you haven't had much in the way of other combinatorics courses, despite the claims to the contrary. :)
21:22:27 <Cale> Well, it is a grad course.
21:23:40 <wy> I've learned some combinatorics before. I could even count number of ways to form a soccer ball with matches.  But I guess I forgot most of it.
21:24:13 <Cale> Anything with generating series?
21:24:29 <wy> forgot ;-)
21:24:33 <faxathisia> "I could even count number of ways to form a soccer ball with matches" is the answer 1?
21:24:36 <Cale> The theory of generating series seems so nicely applicable to thinking about data structures.
21:24:45 <kmcallister> Cale, how so?
21:25:26 <Cale> kmcallister: You're decomposing structure in similar ways, and the corresponding operations on combinatorial structures and generating series have started to pop up in CS lately.
21:26:00 <Cale> Combinatorialists have been differentiating structures for quite some time, and Huet came along and realised that this operation is quite handy with data structures as well.
21:26:18 <wy> How about model theory?
21:26:20 <kmcallister> hmm, could you give an example of the correspondence, or point me at one?
21:26:22 <Cale> (In particular, it's used to construct zippers)
21:26:59 <Cale> wy: Model theory is quite interesting, and would be more than ample preparation for ideas you'd see when studying type theory.
21:27:44 <Cale> (Functional programming is sort of applied logic.)
21:28:20 <kmcallister> in particular, typing is logic
21:28:30 <Cale> kmcallister: Well, are you already familiar with generating series?
21:28:44 <kmcallister> Cale, somewhat
21:28:47 <Cale> (I'm not quite sure which correspondence you're asking about)
21:28:59 <kmcallister> any between generating series and data structures
21:29:31 <kmcallister> actually, now i'm remembering a combinatorics problem where we proved that mergesort is O(n log n) using three pages of dense algebra on generating series, but i can't say i got any general enligtenment about datastructures from that problem ;)
21:29:46 <wy> Cale: So I guess model theory might be appropriet. How does type theory fit into math?
21:30:02 <Cale> Differentiation of combinatorial structures is generally defined in such a way that it deletes some substructure in a canonical way (reducing the weight by 1, and giving n new structures for each object with n such substructures)
21:30:30 <Cale> wy: It's part of computer science, I'd say.
21:31:15 <faxathisia> type theory is relating theorems to lambda terms, So you have a new way to treat logics, Isn't it?
21:31:16 <ddarius> Type theory is related to higher order logic.
21:31:20 <Cale> wy: I suppose it might be considered part of logic as well. Mathematicians tend to just use set theory as a super-expressive form of type theory, whereas CS people are interested in comparatively weak ones which are actually decidable.
21:31:52 <ddarius> Via topos theory, type theory is related to many things.
21:31:55 <kmcallister> wy, http://en.wikipedia.org/wiki/Curry-Howard_Isomorphism
21:32:10 <wy> Cale: Is set theory able to express type theory?
21:32:33 <phlpp> #xmonad
21:32:42 <phlpp> oh, sorry :D
21:32:45 <Cale> kmcallister: For a small example, the derivative with respect to x of x^3 = x*x*x is 3 x^2, because there are three ways to delete an x, and each way gives x^2.
21:33:27 <wy> Cale: I guess combinatorics is only useful when analysing algorithms?
21:33:48 <Cale> wy: Um, I was thinking of it as being more useful just for the kinds of thought pattern inherent in it.
21:34:14 <Cale> You're usually taking some discrete structure (CS is full of discrete structures), and breaking it down into more easily analysable parts.
21:34:16 <ddarius> wy: What are you interested iN?
21:34:29 <ddarius> All of CS's structures are discrete.
21:34:39 <jfredett> in the definition "assoc ~(~(a,b),c) = (a,(b,c))", what is the role of ~?
21:34:52 <sjanssen> jfredett: lazy pattern match
21:34:52 <ddarius> jfredett: It's an irrefutable pattern.
21:34:56 <wy> ddarius: I'm interested in designing a super elegant programming language that could express all we need...
21:35:18 <jfredett> what does that mean? are there docs around for it?
21:35:24 <jfredett> *googles*
21:35:26 <Cale> jfredett: It causes assoc not to force the evaluation of the components of the pairs until those components are actually genuinely requested.
21:35:33 <sjanssen> > case undefined of (_, _) -> "works?"
21:35:34 <mbot>  Undefined
21:35:37 <sjanssen> > case undefined of ~(_, _) -> "works?"
21:35:39 <mbot>  "works?"
21:35:46 <faxathisia> wy, Check out The Calculus Of Constructions
21:35:52 <jfredett> interesting
21:37:21 <ddarius> wy: What kind of math do you like?
21:37:47 <Cale> > let f (x,y) = (0:y, 1:x) in case fix f of (x,y) -> (take 10 x, take 10 y)
21:37:49 <mbot>  Exception: <<loop>>
21:37:53 <Cale> > let f ~(x,y) = (0:y, 1:x) in case fix f of (x,y) -> (take 10 x, take 10 y)
21:37:54 <mbot>  ([0,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0])
21:37:56 <wy> ddarius: Those related with the expressiveness of programming languages. I'm not considering algorithms at this time
21:38:46 <Cale> kmcallister: With that in mind, look up Huet's paper on the Zipper.
21:38:50 <Cale> @where zipper
21:38:50 <mbot> I know nothing about zipper.
21:38:54 <Cale> @where huet
21:38:54 <mbot> I know nothing about huet.
21:39:12 <wy> faxathisia: It looks like dependent types
21:39:22 <dmwit> ?where wolf
21:39:23 <mbot> I know nothing about wolf.
21:39:29 <dmwit> aw, man
21:39:49 <ddarius> wy: Domain theory comes out of topology.  You'd never discover domain theory if you sat there trying to study math "related to the expressiveness of programming languages."
21:41:06 <Cale> oh, or rather Conor's paper
21:41:11 <Cale> http://www.cs.nott.ac.uk/~ctm/diff.pdf
21:41:35 <Cale> Which talks about Huet's construction in terms of differentiation.
21:41:52 <Cale> "The Derivative of a Regular Type is its Type of One-Hole Contexts"
21:42:30 <Cale> That is, the type of structures obtained by removing a piece of data in all possible ways from values of the original type.
21:42:59 * kmcallister reads
21:45:00 <phlpp> :t (~)
21:45:03 <mbot> parse error on input `)'
21:45:03 <phlpp> :>
21:45:12 <phlpp> who the hell is mbot
21:45:29 <Cale> My instantiation of lambdabot.
21:45:42 <Pseudonym> Actually, I'm reading the follow-up paper now.
21:45:53 <Pseudonym> The one on bifunctors.
21:46:02 <phlpp> Cale: I think lambdabot created an other error messagae for :t (~)
21:46:15 <phlpp> I'm pretty sure actually
21:46:17 <ddarius> Clowns and Jokers?
21:46:21 <Pseudonym> Yeah.
21:46:33 <phlpp> :t +
21:46:35 <mbot> parse error on input `+'
21:46:38 <phlpp> :t (+)
21:46:38 <Pseudonym> While typing up the code, I called the polynomial functor stuff "PFunctor.hs".
21:46:39 <mbot>     Ambiguous occurrence `+'
21:46:39 <mbot>     It could refer to either `L.+', defined at <local>:3:0
21:46:39 <mbot>                           or `Prelude.+', imported from Prelude at L.hs:3:0-55
21:46:44 <Cale> heh
21:46:45 <Pseudonym> And I had a funky disco moment.
21:46:52 <Cale> @undefine
21:46:53 <mbot> Undefined.
21:46:59 <Cale> :t (+)
21:47:00 <mbot> forall a. (Num a) => a -> a -> a
21:47:06 <phlpp> \o/
21:47:30 <Pseudonym> One nation under a groove!
21:48:08 <phlpp> > let m f = foldr (\x xs -> f x : xs) [] in m (*2) [1,2,3,4,5]
21:48:11 <mbot>  [2,4,6,8,10]
21:48:30 <jfredett> hmm, Pseudonym, I just finished going over your post on Free Theorems, it's very interesting, I had a kindof silly question though
21:48:31 <Pseudonym> Well, I guess P-Funk was proto-disco.
21:48:36 <Pseudonym> jredett: Sure.
21:49:11 <jfredett> It looks like each of the free theorems are just showing that certain pairs of functions commute
21:49:17 <Pseudonym> Yup.
21:49:31 <jfredett> f . g = g . (h f) seems to be the form
21:49:56 <wy> ddarius: maybe the mathematicians have other thinkings, or they don't get the truth?
21:49:58 <Pseudonym> Not always.
21:50:18 <Pseudonym> Let's hear your question first, then I'll explain. :-)
21:50:27 <jfredett> so heres my question
21:50:54 <ddarius> wy: "the expressiveness of programming languages" is not a mathematical field.
21:51:20 <wy> ddarius: but maybe it's a philosophy field ? hehe
21:51:28 <jfredett> lets say I'm a compiler, and I know how to generate free theorems, could I potentially have some optimization which uses those free theorems to mess around with the order of function application
21:51:38 <wy> ddarius: I'm even looking at I Ching for those matters
21:51:47 <Pseudonym> OK
21:52:03 <jfredett> I ask because, combined with some kind of "inverse" annotation, you could potentially shuffle around functions and cancel them out automagically
21:52:17 <jfredett> with the programmer only notating that f and f' are inverses
21:52:44 <jfredett> (I'm fairly sure that the compiler cant determine whether f and f' are inverse on it's own)
21:53:08 * Pseudonym nods
21:53:18 <chessguy> check this out: http://osteele.com/sources/javascript/functional/
21:53:22 <chessguy> interesting stuff
21:53:24 <Pseudonym> It may not surprise you to learn that free theorems tend not to be useful for optimisation.
21:53:36 <jfredett> really?
21:53:57 <jfredett> that actually does surprise me- a little, though maybe thats because most useful programs are not that general
21:54:16 <jfredett> the free theorems business probably wouldn't come up too often, hmm
21:54:32 <ddarius> jfredett: It comes up in every polymorphic type.
21:54:56 <Pseudonym> Although it's more complicated if you have typeclass constraints.
21:55:09 <Pseudonym> Actual, pure polymorphism isn't as common in Haskell as one might hope.
21:55:18 <jfredett> ddarius: sure, but do useful programs have purely polymorphic types?
21:55:18 <ddarius> Sometimes they are useful, a lot of times they aren't.  E.g. the free theorem for reverse is: map f . reverse = reverse . map f
21:55:24 <jfredett> Pseudonym: thats what I thought
21:55:35 <Pseudonym> They mostly reside in libraries, yeag.
21:55:36 <faxathisia> wy, What were you actually meaning? I guess dependant types is not the sort of thing you meant?
21:55:38 <Pseudonym> yeah
21:56:01 <ddarius> jfredett: It comes up for -each- polymorphic type variable.  Most Haskell functions have at least one and often several of those.
21:56:11 <Pseudonym> I guess in theory, the compiler could convert reverse . map f . reverse to just map f if it knew that the list was finite.
21:56:43 <jfredett> Pseudonym: and that reverse . reverse == id
21:56:58 <wy> faxathisia: I looked at  Calculus Of Constructions on wikipedia and it seems to me dependent types
21:57:13 <ddarius> wy: It's the far corner of the lambda cube
21:57:32 <jadenbane> Hey there, ghci is choking on "factors n = [ i | i <- [1..n]; n `mod` i = 0 ]"
21:57:36 <jadenbane> Any idea why?
21:57:51 <jfredett> wy: its dependant types, polymorphism, and type functions, IIRC
21:57:57 <sjanssen> jadenbane: you should use ',' rather than ';'
21:58:02 <jfredett> all sorts of fun stuff in CoC
21:58:02 <dmwit> Pseudonym: I guess I wouldn't be too upset with that transformation even if the list was infinite.
21:58:21 <faxathisia> You should use == as well
21:58:22 <dmwit> Non-terminating -> terminating is a nice direction to go
21:58:25 <sjanssen> jadenbane: oh, and ==
21:58:25 <jadenbane> sjanssen: <interactive>:1:10: parse error on input `='
21:58:59 <jfredett> right, dmwit, because then reverse . map (+1) . reverse [1..] would output the right list
21:59:02 <jfredett> rather than hanging
21:59:05 <jadenbane> factors n = [ i | i <- [1..n], n `mod` i == 0 ]
21:59:11 <vegai> jadenbane: try let factors n ...
21:59:23 <Pseudonym> Maybe.  I think I'd be upset if my code started failing in jhc.
21:59:28 <dmwit> jfredett: right
21:59:31 <faxathisia> factors n = [ i | i <- [2..n], n `mod` i == 0 ]
21:59:37 <jadenbane> That does it!
21:59:40 <wy> jfredett: I still have problem defining types. Whare are types? I know there is some definition, but I haven't got the reason for that
21:59:41 <Pseudonym> Code that was working in GHC.
21:59:49 <jfredett> though, I suppose situations like that wouldn't come up dynamically
21:59:55 * sjanssen agrees with Pseudonym
21:59:56 <dmwit> That's an interesting point.
22:00:26 <nolrai> this very issue came up a few weeks ago
22:00:42 <Pseudonym> Gaining or losing sharing is one thing, but it doesn't change the meaning of a program.
22:00:43 <nolrai> reverse . reverse ==(/=) id
22:00:43 <jfredett> wy: types are sets of things with certain properties. in my estimation
22:00:56 <faxathisia> A type is a proposition?
22:01:05 <faxathisia> is that a good definition?
22:01:07 <jfredett> a proposition is a type,
22:01:29 <kmcallister> wy, they're usually defined axiomatically
22:01:45 <jfredett> If you can describe something as "x is a Lilliputian" then Lilliputian is a type
22:01:46 <kmcallister> a type is () or a sum of types, product of types, etc.
22:02:27 <nolrai> sum is Either and product is (a,b) right?
22:02:32 <jfredett> yep
22:02:33 <kmcallister> yes
22:02:48 <kmcallister> usually you also have fixed points for recursive types
22:02:55 <faxathisia> Isn't False a type, though it has no inhabitants
22:02:55 <sjanssen> jfredett: "2 is a prime number"? :P
22:03:05 <kmcallister> yeah, that's usually given too
22:03:11 <jfredett> well, number is a type
22:03:22 <jfredett> so prime just specifies some elements of the type
22:03:31 <kmcallister> recursive types, i.e., Tree a is the least t such that t = 1 + (t * t), where 1 is the unit type
22:03:37 <wy> kmcallister: Maybe there could be other definitions?
22:03:37 <jfredett> it's just a metaphor, sjanssen :P
22:03:59 <kmcallister> there are type systems where you can express the type of prime numbers
22:04:10 <kmcallister> of course typechecking in such systems tends to be undecidable
22:04:23 <kmcallister> but e.g. this is how you would do it in Coq
22:04:29 <kmcallister> if you wanted to talk about primes
22:04:36 <faxathisia> typechecking doesn't have te be undecideable?
22:04:45 <jfredett> faxathisia: nope
22:04:49 <faxathisia> Good.
22:04:59 <jfredett> consider a system with only one type,
22:05:03 <kmcallister> faxathisia, typechecking Haskell 98 is decidable
22:05:05 <jfredett> with only one function
22:05:06 <kmcallister> even with inference
22:05:27 <faxathisia> I meant systems which you can describe primes in
22:05:29 <jfredett> id on a single type "A" is certainly decidable, not particularly useful
22:05:29 <kmcallister> (inference makes typechecking a theorem-proving rather than proof-verifying task, as i understand)
22:05:29 <jfredett> :P
22:05:46 <wy> kmcallister: I guess prime numbers are too much for a type to use in programming languages
22:05:47 <jfredett> faxathisia: those types are typically not decidable
22:06:19 <kmcallister> i can come up with a trivial system with decidable typing and the ability to express the type of primes
22:06:21 <kmcallister> but it won't be very useful
22:06:25 <ddarius> kmcallister: You can use them in a programming language.
22:06:32 <faxathisia> If you have a term and a type in CoC it should be decideable to check ?
22:06:33 <kmcallister> it would be something like data Prime = Five
22:06:40 <jfredett> kmcallister: right, I was talking about useful systems there. :P
22:07:00 <faxathisia> If you have just a term or just a type, That is certainly undecideable
22:07:40 <jfredett> faxathisia: AFAIK, with a term and associated type, it's decidable to check
22:07:52 <faxathisia> cool
22:08:11 <jfredett> but don't take my word for it, i'm just a lowly math student. :)
22:08:17 <nolrai> > let f n = ((n - 1) / n) ** n ([0..10..100])
22:08:17 <mbot>  Parse error at "..100..." (column 37)
22:08:27 <faxathisia> [0,10..100]
22:08:42 <wy> I guess dependent types are not quite right for programming languages, because we just need types to be convenient for us to write programs, but now they made types programs themselves
22:08:42 <nolrai> > let f n = ((n - 1) / n) ** n in map f [0,10..100]
22:08:47 <mbot>  [1.0,0.3486784401000001,0.3584859224085419,0.3616615134616106,0.363232439887...
22:09:12 <kmcallister> my understanding was that e.g. in Coq, your proof script is a typing derivation showing that some term has some type
22:09:24 <jfredett> wy, dependent types are pretty useful, actually, with them you can define indexed vector types
22:09:26 <kmcallister> and while there are some automated proof steps, you have to supply this yourself
22:09:27 <nolrai> > 1 / exp(1)
22:09:27 <jfredett> among other things
22:09:31 <mbot>  0.36787944117144233
22:09:50 <faxathisia> kmcallister, I thought that a proof script is proving that a type in inhabited
22:09:55 <wy> jfredett: You mean with bound checking?
22:09:55 <ddarius> > exp(-1)
22:09:57 <mbot>  0.36787944117144233
22:10:18 <faxathisia> e.g. you can prove   nat   by exacting 5
22:10:50 <nolrai> > let f n = ((n - 1) / n) ** n in map f 10000
22:10:52 <mbot>   add an instance declaration for (Num [a])
22:10:56 <nolrai> > let f n = ((n - 1) / n) ** n in f 10000
22:10:59 <jfredett> wy: i mean a vector as in an arraylist from Java, but typesafe
22:11:00 <mbot>  0.36786104643297046
22:11:30 <wy> jfredett: How is it unsafe in Java?
22:11:39 <jfredett> look at the epigram tutorial, they derive the vector type as one of its first exercises
22:11:52 <kmcallister> faxathisia, hmm, i think you're right
22:11:56 <faxathisia> append : forall n m, vec n -> vec m -> vec (n+m)
22:12:01 <jfredett> wy: well, not so much unsafe, the problem there is the type system isn't as strict as haskell/epigram
22:12:08 <faxathisia> Stuff like this is good
22:12:43 <wy> I'm thinking about the question what are arrays...
22:12:55 <jfredett> in java, the type system serves more like a deterrent to dumb bugs (passing a argument with a bad type to a function)
22:13:20 <jfredett> in haskell/epigram, the types are really more important than the code, they serve as real structure for your code
22:13:41 <wy> jfredett: I think types should be something for conveniency, and not all for correctness.
22:14:02 <kmcallister> jfredett, i agree, a lot of the work in any haskell program is figuring out what the types should be
22:14:07 <sjanssen> wy: types are all about correctness
22:14:11 <kmcallister> after that each function can be written almost mechanically
22:14:31 <jfredett> wy: i dont know, correctness is too important to be left to humans.
22:14:46 <kmcallister> wy, being correct is convenient ;)
22:14:52 <Cale> jfredett: At the end of the day, we're the ones responsible for it.
22:14:53 <jfredett> wy: imagine what would happen if your heart monitors software was incorrect
22:15:10 <Cale> Typeclasses take types a little farther than just for correctness.
22:15:11 <kmcallister> types are about the convenience of having (some) correctness properties proven for you at compile time, such that you can catch bugs earlier and more reliably
22:15:11 <sjanssen> the goal of a type system is to reject as many incorrect programs as possible while simulataneously accepting as many correct programs as possible
22:15:13 <wy> jfredett: When we have pattern matching on types, it's more convenient than Lisp without CLOS
22:15:30 <wy> So I think types are partly for convenience
22:15:42 <jfredett> wy: well certainly types are for convinence
22:15:42 <kmcallister> it seems more like pattern matching is the feature of note there
22:15:50 <kmcallister> because e.g. you can have pattern matching in a dynamically typed language
22:16:01 <kmcallister> and you can have static typing without patterns
22:16:14 <jfredett> noone would deny that, but at the least, we need types for correctness
22:17:04 <jfredett> i mean, there are some places where types are not as important, if I'm writing a one-off script, I don't necessarily want to deal with strict type systems
22:17:28 <jfredett> I still use bash or perl for that, but if I'm writing something big, i'm definitely going to use some kind of typed language
22:17:39 <jfredett> be it Java, C, Haskell, or Epigram.
22:17:49 <faxathisia> C
22:17:51 <wy> jfredett: Do you use Epigram?
22:17:53 <kmcallister> C is not safely typed
22:18:01 <kmcallister> and the type system is quite lacking in expressiveness
22:18:02 <jfredett> types make it easier for a lone programmer like myself to stay sane
22:18:16 <jfredett> wy: hither and thither, I pretty much uniformly suck at it
22:18:17 <jsnx> kmcallister: but it's better than nothing ;)
22:18:24 * gwern reads the linspire slides. 'Correctness first. (pillage, *then* burn!!!)'
22:18:25 <kmcallister> jsnx, not always
22:18:34 <jfredett> kmcallister: no, pretty much always
22:18:35 <kmcallister> i find that C++'s type system is often worse than nothing
22:18:39 <kmcallister> not so much with C
22:18:49 <faxathisia> I want to try Epigram and Omega but they are both irritating to try and install
22:18:56 <jsnx> kmcallister: i agree
22:18:57 <jfredett> the problems with C stem from its freeness with its pointers
22:19:03 <jfredett> pointers are evil.
22:19:21 <kmcallister> nah, they're just something that should be abstracted away for most programming
22:19:22 <faxathisia> (Omega doesn't have dependant types though)
22:19:26 <jsnx> jfredett: they are not evil...just of limite use
22:19:33 <kmcallister> i can't believe people write applications in C in this day and age
22:19:34 <wy> jfredett: that's tied to the architecture
22:19:36 <jfredett> jsnx: no, pointers are evil, :)
22:19:45 <kmcallister> or C++ for that matter... you still have to use pointers everywhere, and manage memory manually
22:19:51 <gwern> (...linspire's guys have a good philosophy, but why do they use gnu arch and not darcs?)
22:20:00 <jsnx> i think the problem with C is that kernigan and ritchie were like, hey, you can implement anything on top of pointers!
22:20:26 <jfredett> jsnx: yah- pointers are a neat idea, but too much of a good thing...
22:20:27 <jsnx> so let's expose the pointers and make arrays with them!
22:20:33 <wy> Is there a good reason to construct processors like what we are currently using?
22:20:36 <kmcallister> C is a excellent *systems* programming language
22:20:46 <int-e> jsnx: and it works, too. it's just not safe.
22:20:50 <jfredett> wy: hmm? I don't know
22:20:54 <jsnx> kmcallister: well, it's an excellent driver programming language
22:20:59 <ddarius> wy: It's cheap and it works and we already have the hardware.
22:21:01 <jsnx> int-e: yes, it does
22:21:01 <gwern> 'APL, the programming language of the future for the programmers of the past; a mistake carried through to perfection'
22:21:17 <fnord123> I'm interested to know how memoization works in Haskell. If I read in a smallish file, I'm interested to know if it will be buffered in memory if i opened it as read-only so that multiple handles to the file will only load this once.
22:21:32 <kmcallister> jsnx, good point, i would like to see more things like schedulers and network protocols implemented in high level languages
22:21:33 <jfredett> wy: I'm always interested in innovative technology, and I wouldn't shun someone who wants to build a new kind of processor
22:21:41 <ddarius> fnord123: Haskell doesn't do any memoization.
22:21:43 <wy> I guess I've got enough pointers for my classes tomorrow. Have a good night :-)
22:21:44 <faxathisia> gwern, it creates a new generation of coding bums.
22:21:49 <jsnx> int-e: i'm just saying, they basically took pointers as a primitive and exposed them in lists, for example
22:21:52 <jfredett> but I don't think we're doing anything particularly wrong with our processors
22:21:52 <gwern> fnord123: how do you read it in? some functions are strict, and others use unsafeInterleaveIO to get lazy IO
22:22:03 <gwern> faxathisia: ah, you are familiar with perlis too?
22:22:13 <olsner> wy: http://www.cs.york.ac.uk/~mfn/reduceron2/ for an interesting alternative architecture
22:22:16 <kmcallister> ?src getContents
22:22:17 <mbot> getContents = hGetContents stdin
22:22:17 <faxathisia> I thought it was EWD
22:22:21 <kmcallister> ?src hGetContents
22:22:21 <mbot> Source not found. Just what do you think you're doing Dave?
22:22:24 <jsnx> kmcallister: filesystems, too
22:22:37 <kmcallister> jsnx, yes
22:23:04 <jfredett> I dunno, I've always thought that new kinds of processors were less interesting than new kinds of kernels
22:23:11 <ddarius> The power and size benefits of stack computers may make them more of a player in the future.
22:23:22 <jsnx> so, if we were going to take the linux kernel and divide it in two -- one part in c--, one part in haskell -- where would we draw the line?
22:23:25 <jfredett> kernels, of course, being something I'll likely never fully understand
22:23:44 <dons> hey guys, i'm about done with the new random lib. a bit of feedback would be good . http://code.haskell.org/~dons/code/mersenne-random/   i got defeated in the end by the impurity of the C lib -- it was too tricky to try to make it pure, in the end. however, what we've got is randoms in IO, 20x faster than 'random' in System.Random
22:23:45 <ddarius> jfredett: Why do you think they are hard to understand?
22:23:45 <jfredett> like the synthesis kernel
22:23:50 * BMeph is waiting for the first CPU-bypassing Reduceron card to come into production
22:23:52 <visof> is the tail function identified ad  tail (x:xs) = xs
22:23:53 <visof> ??
22:23:55 <jsnx> ddarius: what are the power benefits?
22:23:56 <jfredett> ddarius: it's just out of my range of thinking
22:24:03 <wy> I feel as if arrays have something to do with compilation, because they are instantly accessible
22:24:04 <jsnx> ddarius: like power usage?
22:24:05 <Cale> visof: yep
22:24:06 <jfredett> my heads to far up in the clouds for kernels
22:24:19 <gwern> jfredett: kernels can be really awesome. just sel4 in haskell is interesting, nm stuff like JITing kernels like synthesis or exokernels
22:24:20 <kmcallister> ?src tail
22:24:21 <mbot> tail (_:xs) = xs
22:24:21 <mbot> tail []     = undefined
22:24:22 <nolrai> what is epigram?
22:24:34 <ddarius> jsnx: Yes.  They tend to require much less power (which also has temperature benefits and is related to them requiring less transistor space)
22:24:57 <faxathisia> nolrai, Some programming language with dependant types, coded in haskell
22:25:06 <jfredett> gwern: I'm sure they can be, i've just never been able to wrap my head around then
22:25:08 <jfredett> them*
22:25:14 <Cale> dons: I wonder how it would compare to implementing the Mersenne twister directly in Haskell.
22:25:28 <ddarius> jsnx: When we start having processors in the fabric of our clothing and mixed into concrete, each small and expendable, such factors will be more significant.
22:25:39 <wy> and writing programs with arrays is like writing programs in a compiled form, that is machine language
22:25:44 <dons> Cale, since it uses sse2 directly, i guess "no competition".
22:25:54 <dons> i'll probably have one more go at extracting out the effects to make it pure
22:25:57 <jsnx> http://www.ece.cmu.edu/~koopman/stack_computers/sec3_1.html
22:26:12 <dons> i if can do that, it becomes super awesome. otherwise its only fairly awesome
22:26:23 <visof> Cale i had an error
22:26:26 <visof> foo.hs:3:26: parse error on input `='
22:26:29 <olsner> dons: if you can't, you'll have to hack in the proper optimizations in ghc :P
22:26:44 <Cale> visof: could you paste that part of your source file on hpaste?
22:26:48 <Cale> @hpaste
22:26:48 <mbot> Haskell pastebin: http://hpaste.org/new
22:27:08 <jsnx> dons: how can random ever be pure?
22:27:17 <dons> jsnx: thread the generator around
22:27:21 <dons> pseudo-random is still pure
22:27:25 <glguy> random can be pure as a lazy list
22:27:28 <bparkis> larry wall says "Though if you think about it hard enough, you realize lexical scopes are also a funny kind of dynamic scope, or recursion wouldn't work right."  at http://www.perl.com/lpt/a/997
22:27:37 <bparkis> what does he mean
22:27:53 <dons> jsnx: a pseudo-random generator is a function from :: g -> (a, g), basically
22:27:56 <Cale> bparkis: I have no idea.
22:28:03 <jsnx> dons: oic
22:28:10 <ddarius> bparkis: Larry Wall is not the best person to listen to on such matters.
22:28:16 <jfredett> he's a perler, bparkis, you have to be really high to comprehend what perlers say
22:28:17 <jsnx> dons: so it is monadic -- just not necessarily in IO
22:28:21 <faxathisia> bparkis, It's a joke
22:28:25 <dons> just State, yep
22:28:32 <sjanssen> dons: how big is the state?
22:28:37 <jsnx> bparkis: he is saying, everything is a mess -- so perl is clean!
22:28:42 <dons> sjanssen: oh, hmm 4k or so. tiny.
22:28:47 <dons> its just deeply buried :)
22:28:48 <hpaste>  visof pasted "(no title)" at http://hpaste.org/5116
22:28:56 <dons> i did get something compiling that should be pure, but the results were wrong
22:29:03 <dons> so some of my custom C hacks must have been wrong :)
22:29:06 <faxathisia> bparkis, Some things are done neatly with it (check out Norvigs PAIP)
22:29:11 <sjanssen> dons: seems too large to copy repeatedly, anyway
22:29:17 <Cale> visof: I don't understand why you'd get the error that you did, but that has a type error in it.
22:29:18 <dons> sjanssen: oh, yeah, Ptr State
22:29:32 <dons> malloc on the C side. pass the token back and forwrad.
22:29:38 <dons> the generator just permutes the bits in the state array
22:29:41 <gwern> 'this bug crashes your computer and corrupts your hard drive. good thing you keep backups and can simply restore it'
22:29:48 <gwern> (mischan)
22:30:05 <Cale> visof: specifically, 0 and xs can't have the same type, because xs is a list, and lists are not an instance of Num
22:30:24 <bparkis> done neatly with what faxathisia
22:30:43 <Cale> visof: That shouldn't be a syntax error though. How are you loading the file?
22:30:45 <visof> Cale so foo [] = []
22:30:48 <faxathisia> bparkis, dynamic scope and recursion
22:30:53 <Cale> visof: you might try that, yeah
22:31:00 <visof> Cale ok
22:31:06 <Cale> visof: That would amount to the same thing as  drop 1  then.
22:31:20 <Cale> > drop 1 []
22:31:22 <mbot>  []
22:31:27 <Cale> > drop 1 "hello"
22:31:29 <mbot>  "ello"
22:32:07 <jsnx> ddarius: so, there is no linux for stack machines, i'm sure
22:32:15 <Cale> > describeSequence [1,1,2,3,5,8]
22:32:15 <mbot>   Not in scope: `describeSequence'
22:32:23 <bparkis> ah well I understand dynamic scope I simply don't understand the connection he is drawing to static scope
22:32:23 <Cale> hmm, I should load that one up :)
22:32:39 <ddarius> jsnx: Stack machines haven't really entered the PC market.  I'm not sure how they are faring in the embedded market.
22:32:47 <jsnx> ddarius: oic
22:32:53 <visof> Cale it's work   , thanks
22:33:05 <jsnx> ddarius: if they come out, though, we could still write haskell on them, i assume...
22:33:08 <ddarius> jsnx: The benefits of stack machines don't really matter for a desktop.  Most people don't care about power consumption or chip space as compared to speed.
22:33:18 <jsnx> ddarius: oic
22:33:22 <ddarius> jsnx: Sure.
22:33:31 <fnord123> gwern, i was just thinking about how in games you would have a texture manager that reads in textures so they only exist in memory once. One way to make sure it's in memory once is a singleton (with all it's drawbacks). I'm not sure if this is a good idea in haskell since we want to maintain referential transparency and singletons don't fit in that scheme.
22:33:58 <jsnx> fnord123: referential transparency doesn't fit with graphics, period
22:34:02 <int-e> bparkis: Well, I think following his line of reasoning, even global variables are sort of dynamically scoped because the memory location that they refer is different for each process running the program.
22:34:15 <gwern> fnord123: you know, that really reminds me of uniqueness (or was it linear?) types
22:34:28 <fnord123> gwern, as in Clean?
22:34:38 <jsnx> fnord123: basically, you the "GrapicsCard" monad deal with it
22:34:47 <jsnx> though presumably, that's in IO
22:34:48 <gwern> fnord123: ayuh
22:35:25 <ddarius> jsnx: Why doesn't referential transparency fit with graphics?
22:35:29 <Cha1> dons: I used cabal to install MT and got a segfault in ghci. Should it work from there?
22:35:32 <ddarius> Conal would be quite surprised then.
22:35:40 <jsnx> ddarius: because explicit memory management is very important in graphics
22:36:13 <jsnx> ddarius: basically, you want to avoid talking about the buffers directly
22:36:32 <jsnx> ddarius: and build your program around making actions that stuff shit in the buffers, &c.
22:36:37 <nolrai> > let f n = ((99) / n) ** 100 in map f [100,200..10000]
22:36:39 <mbot>  [0.3660323412732292,2.887486040769659e-31,7.102217821866597e-49,2.2778248519...
22:36:44 <jsnx> ddarius: seem reasonable to you?
22:37:16 <ddarius> jsnx: How does that inherently not fit with referential transparency.
22:37:19 <ddarius> ?
22:37:22 <jsnx> ddarius: i think there's large parts of any graphic simulation that do fit pure functional programming well...just not the part where you are actually loading textures.
22:37:35 <jsnx> ddarius: referential transparency is relational
22:37:45 <jsnx> ddarius: you establish a relation that is true for all time
22:38:07 <jsnx> ddarius: that doesn't make sense for the "what's in the buffers" relation
22:38:23 <jsnx> ddarius: in haskell, we have limited relational powers -- just ==
22:38:32 <jsnx> ddarius: but the principle is the same
22:38:45 <ddarius> jsnx: You specify the whole "worldline"
22:38:50 <jsnx> ddarius: oic
22:39:16 <hpaste>  Chad pasted "Mersenne segfault in ghci" at http://hpaste.org/5117
22:39:18 <ddarius> That's, highly simplified, the idea behind functional reactive programming.
22:39:28 <jsnx> ddarius: yes, sure
22:39:51 <jsnx> ddarius: mmmmm
22:39:57 <dons> Cha1: oh, very interesting! it should work.
22:40:05 <jsnx> is there IO monad in it?
22:40:09 <dons> but its untested on 32 bit machines... so there could be issues :)
22:40:23 <jsnx> ddarius: maybe it's just locally functional -- but globally imperative?
22:40:35 <Cha1> Well, it's tested now! ;)
22:40:36 <dons> Cha1: ok. that's great. what OS/platform?
22:41:16 <nolrai> > let f n = ((99) / n) ** 100 in f 100
22:41:21 <mbot>  0.3660323412732292
22:41:24 <hpaste>  Chad annotated "Mersenne segfault in ghci" with "cpuinfo details" at http://hpaste.org/5117#a1
22:41:30 <nolrai> > let f n = ((99) / n) ** 100 in f 1000
22:41:31 <Cha1> Ubuntu Gutsy
22:41:34 <mbot>  3.660323412732312e-101
22:41:41 <dons> 32 bit linux/x86?
22:41:49 <Cha1> Yeah
22:42:01 <jsnx> ddarius: at a high level, you can say, my simulation is referentially transparent
22:42:03 <dons> ok. cool. i'll investigate.
22:42:28 <jsnx> ...you take the input, all the way to ^C, and that of course completely determines the output
22:42:30 <BMeph> I wonder if/how the Reduceron relates to a stack machine.
22:43:02 <fnord123> Obviously if you are pulling data from a file, it's not referentially transparent since someone can toy with the file. However, I'm curious if there's a Haskell idiom for keeping single references to external resources.
22:43:24 <nolrai> > let f n = ((n - 99) / n) ** 100 in f 100
22:43:29 <mbot>  1.000000000000002e-200
22:43:29 <jsnx> fnord123: well, no
22:43:36 <jsnx> fnord123: it depends
22:43:55 <jsnx> fnord123: if you the *filename* as input, you are right
22:44:10 <jsnx> fnord123: if you take the contents, though -- then it's a horse of a different color
22:44:32 <nolrai> > let f n = ((n - 99) / n) ** 100 in f 1000
22:44:37 <mbot>  2.9681038886005824e-5
22:44:54 <nolrai> > let f n = ((n - 99) / n) ** 100 in f 10000
22:44:58 <mbot>  0.3697481852804817
22:45:23 <fnord123> im talking about the data
22:45:29 <fnord123> because i want to blit it
22:45:56 <qebab> > let x = 100.0 in (1.0 - 1.0 / x) ** x
22:46:01 <mbot>  0.3660323412732292
22:46:05 <jsnx> fnord123: well, the result of the blitter is completely determined by the data
22:46:07 <qebab> > let x = 100.0 in (1.0 + 1.0 / x) ** x
22:46:12 <mbot>  2.7048138294215285
22:46:16 <jsnx> fnord123: so, that's referential transparency
22:46:16 <qebab> right
22:46:26 * qebab had forgotten the lim for e
22:47:53 <Cale> > exp 1
22:47:55 <mbot>  2.718281828459045
22:48:10 <hpaste>  ramza3 pasted "Simple idiom, save prev value" at http://hpaste.org/5118
22:49:06 <hpaste>  visof pasted "(no title)" at http://hpaste.org/5119
22:49:18 <visof> please anyone help
22:49:28 <visof> i have error
22:49:44 <ramza3> (5118) I know that is simple; but I was having trouble on how to keep the value of 'sum' without using recursion
22:49:55 <Cale> visof: x probably isn't a list on its own
22:50:03 <hpaste>  mmorrow pasted "sortPerm" at http://hpaste.org/5120
22:50:25 <dons> Cha1: what kind of processor do you have?
22:50:26 <Cale> visof: you probably want steal 1 (x:xs) = [x]
22:50:39 <Cale> visof: and steal n (x:xs) = x : steal (n-1) xs
22:51:03 <Cale> visof: It's also possible to do the 0 case instead of the 1 case, which is maybe easier.
22:51:21 <Cha1> dons: Pentium 4. I put details at http://hpaste.org/5117
22:51:46 <Cale> > scanl (*) 4 [1..10]
22:51:47 <fnord123> ramza3, foldl (\(x,y) z -> (x*z, y+z)) (1,0) [1..10]
22:51:48 <mbot>  [4,4,8,24,96,480,2880,20160,161280,1451520,14515200]
22:51:54 <Cale> > sum (scanl (*) 4 [1..10])
22:51:56 <mbot>  16151656
22:51:57 <dons> could you, cd tests ; and run your test from there?
22:52:04 <visof> Cale it's work
22:52:04 <hpaste>  (anonymous) annotated "Simple idiom, save prev value" with "(no title)" at http://hpaste.org/5118#a1
22:52:07 <dons> i wonder if its an issue with ghci doing something with the src files
22:52:18 <Cale> ramza3: That's how I'd write it, at least.
22:52:27 <dons> Cha1: ah, reproduced it! :)
22:52:28 <dons> Prelude System.Random.Mersenne> :t g
22:52:28 <dons> g :: MTGen
22:52:28 <dons> Prelude System.Random.Mersenne> random g :: IO Int
22:52:28 <dons> zsh: segmentation fault  ghci
22:52:34 <ramza3> Cale: that makes sense, I wasn't thinking lambda expression
22:52:36 <dons> 64 bits good, 32 bits bad.
22:52:40 <dons> Cha1++ thanks :)
22:52:45 <Cale> ramza3: lambda?
22:52:47 <Cale> > sum (scanl (*) 4 [1..10])
22:52:49 <mbot>  16151656
22:53:04 <Cha1> no prob, thank you! Looking forward to seeing this!
22:53:27 <ramza3> Cale: oh, I was looking at the hpaste , thought it was you
22:53:36 <Cale> oh, yeah, that wasn't me
22:53:49 <Cale> That does give another way to do it though.
22:54:09 <Cale> (which is perhaps closer in style to the imperative version)
22:54:27 <Cale> Mine builds up a successive list of the values of term, and then sums them separately.
22:55:01 <int-e> dons: 32 bits without sse2 works fine here. (can't test sse2, athlon XP doesn't support that)
22:55:18 <ramza3> Cale; I wish I would have learned haskell first, too much imperative development (like 15 years)
22:55:36 <dons> int-e: but does it compile at all with sse2 on ?
22:55:50 <int-e> dons: yes
22:56:09 <int-e> dons: I got a SIGILL on the first try. :P
22:56:09 <dons> and with it on, does it crash or work?
22:56:11 <dons> ah!
22:56:17 <dons> i just assumed gcc would refuse :)
22:56:33 <dons> i should never assume things when C is involved
22:57:04 <Cale> @remember dons I should never assume things when C is involved.
22:57:04 <mbot> It is forever etched in my memory.
22:57:45 <dons> yeah, that's it.
22:59:16 <dons> oh, its supposed to work on P4 though. curious.
23:15:56 <hpaste>  BMeph pasted "No joy in Core 2 Duo-ville" at http://hpaste.org/5121
23:16:27 <dons> BMeph: cd in to the tests dir, and try again
23:16:30 <dons> that's just ghci getting confused
23:16:33 <BMeph> I may have missed a step in compilation - let me check it out. :)
23:18:43 <BMeph> No output - it makes the files, but they're empty.
23:19:00 <BMeph> No segfault, so that's a good sign... ;)
23:26:45 <BMeph> dons: number-fast 11 50 gave me: Segmentation fault/access violation in generated code
23:30:14 <dons> ok. can you pull from the repo again, runhaskell Setup.lhs clean, recompile, and try again?
23:31:29 <int-e> dons: in fact I even tracked down the SIGILL using gdb, maybe this is interesting for you: http://hpaste.org/5122
23:32:34 <dons> huh. gcc is a bit evil eh?
23:32:46 <dons> nice work.
23:33:00 <dons> good thing it didnn't melt your box
23:33:19 <Cale> hcf
23:34:20 <Cale> On some architecture, they actually really did have an hsc instruction "Halt and Spontaneously Combust"
23:38:14 <nolrai> is there a f such that "f a test defualt = if test a then a else defualt"?
23:40:45 <Cale> @pl f a p d = if p a then a else d
23:40:45 <mbot> f = flip =<< (if' .) . flip id
23:40:52 <Cale> Basically, no :)
23:41:20 <int-e> @pl \a p d -> fromMaybe d (guard (p a) >> return a)
23:41:21 <mbot> (flip fromMaybe .) . ap (flip . (((>>) . guard) .) . flip id) return
23:41:22 <Cale> (If you mean that in the sense where it isn't obviously true.)
23:42:44 <int-e> @pl \a p d -> fromMaybe d (liftM2 (>>) (guard . p) return a)
23:42:44 <mbot> (flip fromMaybe .) . flip (flip (liftM2 (>>) . (guard .)) return)
23:42:45 <BMeph> nolrai: Most folks (from my experience, which is VERY limited) just define the "if'" command:
23:43:27 <nolrai> it does seem to come up a time or two.
23:44:55 <nolrai> :t if'
23:44:57 <mbot> Not in scope: `if''
23:45:51 <nolrai> @pl f p a d = if p a then a else d
23:45:52 <mbot> f = (if' =<<)
23:45:59 <BMeph> I think the most useful one is a variant: iIf pred t f x = if (pred x) then (t x) else (f x)
23:47:05 <BMeph> Well, I need to go to work in six hours, so I'll chat at you guys at work. ;)
23:51:49 <dons> System.Random, 10000000 Doubles
23:51:49 <dons> 0.9999995277030392
23:51:49 <dons> Computation time: 13.150 sec
23:51:49 <dons> System.Random.Mersenne, 10000000 Doubles
23:51:49 <dons> 0.9999998570276724
23:51:51 <dons> Computation time: 0.620 sec
23:51:54 <dons> :)
23:52:41 <int-e> nice.
23:53:49 <dons> using the vector instructions, the last line becomes,
23:53:50 <dons> Computation time: 0.200 sec
23:54:14 <Cale> dons: How is that number just shy of 1 produced?
23:55:16 <dons> that's a random Double in [0,1)
23:55:23 <Cale> ah
23:55:27 <dons> and then i just recorded the maximum i saw in 10M runs
23:55:35 <Cale> oh, okay :)
23:55:41 <Cale> That makes more sense :)
23:58:59 <nolrai> does any one have any idea where i would talk to too, if i whanted fix gedit's haskell highlighting?
