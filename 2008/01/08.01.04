00:02:13 <luqui> I heard that there was research indicating STM has better performance than locking as the number of cores becomes high
00:02:19 <luqui> does anyone know where I can find that?
00:04:21 <Spark> google
00:04:25 <Spark> stm vs lock performance is still an open question
00:04:45 <Spark> and of course there's a massive difference between hardware and software transactional memory
00:05:17 <Spark> in general, lock inference is conservative and thus will always have a worse granularity than transactions
00:05:33 <Spark> this is evident for example if you have a queue with one thread pushing and one thread popping
00:06:08 <Spark> but stm obviously has to backtrack whereas locks don't
00:06:14 <Spark> so then it becomes a question of contention
00:06:31 <Spark> so the winner really depends on the application at hand
00:07:31 <Cale> Explicit locking doesn't compose well though. The compositional problems with it will eventually limit application size (or at least cost a prohibitive amount more development time)
00:07:33 <luqui> yeah that makes sense
00:11:22 <luqui> hmm, does it make sense to seq variables before entering atomically when writing to TVars to keep transactions small?
00:11:38 <luqui> (this is more of an observation than a question, but I'd like to know if it's wrong :-)
00:12:53 <skew> It won't make the transaction log shorter, and you can store thunks in a TVar just as well a value
00:13:17 <sjanssen> luqui: it makes sense if a transaction will need to force the value at some point
00:13:21 <skew> but getting as much computation done outside the block as you can is probably always a good idea
00:16:14 <skew> Looks like the FPretty code just piles up indentation levels
00:16:49 <skew> I guess it could use a correct derivation
01:16:14 <luqui> is there any nontrivial difference whatsoever between data X = X A B C and newtype X = X (A,B,C) ?
01:16:28 <luqui> strictness, etc.  assuming the obvious transliteration of usage?
01:18:36 <faxathisia> I guess it matters when you pattern match with it
01:19:05 <faxathisia> oh that's a newtype actually, then I really don't know
01:19:06 <sorear> luqui: No.
01:19:24 <luqui> ok good.
01:19:48 <thoughtpolice> the newtype will be optimized away at compile time, for the most part. if you have single-constructor data types, you can probably move them to newtypes without hassle
01:20:11 <sorear> the transliteration of usage is slightly non-obvious in that the pattern ~(X a b c) must become (X ~(a, b, c))
01:20:34 <luqui> right, but in this case the tuple constructor will take the place of the data constructor
01:20:41 <luqui> sorear, good to know
01:21:00 <sorear> thoughtpolice: newtypes are always optimized away (it's somewhat hard to implement the h98 semantics without doing so), GHC will try to optimize single-constructor data
01:21:25 <thoughtpolice> ah, okay then. :)
01:25:44 <pipedream> I installed ghc6 6.6-3 on ubuntu feisty. For "import Char" I get <interactive>:1:0: parse error on input `import'. Should I install another library?
01:26:06 <glguy> in GHCi you'll use:
01:26:09 <glguy> :m Char
01:26:41 <glguy> ghci doesn't allow you to do things like declare data types, import modules (using source file syntax)
01:29:35 <sutats> Has anyone used a shell written in Haskell?
01:29:51 <sutats> Are there any that are actually useful and stable enough for day-to-day usage?
01:30:30 <pipedream> thanks
01:30:50 <faxathisia> sutats: That would be pretty cool
01:32:15 <sutats> faxathisia: It would. I've found HSH, but haven't actually tried it.
01:36:38 <ricky_clarkson> I noticed a video on my computer and watched it; A Taste of Haskell, Part I.
01:36:52 <ricky_clarkson> I have no idea where I downloaded it from, but I cannot find a download link for Part II.
01:37:23 <faxathisia> http://blip.tv/file/325646
01:37:24 <lambdabot> Title: OSCON 2007 - Simon Peyton-Jones - A Taste of Haskell Part II
01:37:43 <faxathisia> (found it using www.google.com)
01:42:37 <ricky_clarkson> How do I download that instead of streaming it?
01:42:50 <ricky_clarkson> (I found that using google too)
01:44:48 <sutats> ricky_clarkson: There's a link on the side for just downloading.
01:45:03 <dibblego> ricky_clarkson, that video is a *must watch*
01:45:13 <dibblego> goes for 3 hours though
01:45:36 <dibblego> ricky_clarkson, I have links to the video on my blog
01:45:42 <ricky_clarkson> The second part is 3 hours?
01:45:58 <dibblego> together they are 3 hours
01:46:07 <dibblego> http://blog.tmorris.net/algebraic-data-types-again/
01:46:08 <lambdabot> Title: Î» Tony&#8217;s blog Î» » Blog Archive » Algebraic Data Types again
01:46:16 <dibblego> links to both videos and the slides
01:46:45 <ricky_clarkson> I read the source for the page and grabbed the link from that.
02:00:52 <micmicmic> Hi
02:09:13 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4791
02:15:56 <shag> where does cabal store it's configure information? since the new version, it doesn't create .setup-config anymore, is that correct?
02:28:06 <sjanssen> shag: dist/setup-config
02:28:17 <shag> sjanssen: ah thanks.
02:37:01 <faxathisia> @undo do (g:gs) <- get ; put gs ; return g
02:37:01 <lambdabot> get >>= \ a -> case a of { (g : gs) -> put gs >> return g; _ -> fail ""}
02:37:44 <jz87> hey have anyone tried building gtk2hs with ghc 6.8.2?
02:38:00 <vincenz> faxathisia: there's an easier way
02:38:01 <lambdabot> vincenz: You have 1 new message. '/msg lambdabot @messages' to read it.
02:38:16 <faxathisia> I'm thinking get >>= \(g:gs) -> put gs >> return g is not very nice
02:38:16 <vincenz> oh you want g
02:40:18 <vincenz> @messages
02:40:18 <lambdabot> conal said 3d 13h 41m 3s ago: i'd like a chat about lossy events.
02:40:30 <vincenz> faxathisia: well if you didn't want g, you could modify
02:40:53 <vincenz> what we need is a generic modify and get
02:40:56 <vincenz> something lie
02:41:18 <vincenz> modifyGet f g = do a <- get; let r = f a; put (g a); return r
02:41:21 <vincenz> then you could do
02:41:24 <vincenz> modifyGet head drop 1
02:41:26 <vincenz> modifyGet head (drop 1)
02:41:39 <faxathisia> ohh yeah
02:42:17 <faxathisia> @hoogle (MonadState s t) => (s -> t1) -> (s -> s) -> t t1
02:42:17 <lambdabot> Did you mean: MonadState s t => (s -> T1) -> (s -> s) -> t T1
02:42:18 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
02:42:18 <lambdabot> Data.Function.(.) :: (b -> c) -> (a -> b) -> a -> c
02:42:51 <faxathisia> huh..
02:42:53 <vincenz> that or
02:42:56 <vincenz> have modify return the old state
02:43:06 <vincenz> modify :: (s -> s) -> m s
02:43:09 <vincenz> but it doesn't do taht
02:43:12 <sjanssen> there is a combinator like this in Applicative, IIRC
02:43:25 <vincenz> you could then do: liftM head (modify (drop 1))
02:43:34 * faxathisia :browse Control.Applicative
02:43:46 <faxathisia> :t liftM head (modify (drop 1))
02:43:47 <lambdabot>     Couldn't match expected type `[a]' against inferred type `()'
02:43:48 <lambdabot>       Expected type: m [a]
02:43:48 <lambdabot>       Inferred type: m ()
02:44:06 <vincenz> faxathisia: modify doesn't return old state
02:44:07 <sjanssen> gets head <* modify tail
02:44:13 <faxathisia> ohh I see what you mean
02:44:28 <sjanssen> @type gets head <* modify tail
02:44:29 <lambdabot> forall a (f :: * -> *). (Applicative f, MonadState [a] f) => f a
02:44:47 <vincenz> sjanssen: interesting
02:45:16 <faxathisia> but, No instance for (Applicative (State [String]))
02:45:20 <vincenz> yeah I guess since you're head'ing
02:45:31 <vincenz> yu might as well tail too
02:45:39 <sjanssen> faxathisia: yes, you'll have to write one (it's trivial)
02:45:50 <faxathisia> @src Applicative
02:45:50 <lambdabot> class Functor f => Applicative f where
02:45:50 <lambdabot>     pure  :: a -> f a
02:45:50 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
02:45:52 <sjanssen> <*> = ap; pure = return
02:46:26 <vincenz> instance Applicative (State s) where
02:46:55 <vincenz> instance ApplicativeT (State s m) where
02:47:01 <vincenz> whoops, T should go after State
02:48:03 <faxathisia> instance Applicative (State [x]) where pure = return ; (<*>) = ap -- works, if I use -XFlexibleInstances
02:48:14 <vincenz> remove []
02:48:17 <vincenz> State x
02:48:23 <vincenz> that instance is valid for -any- monad
02:50:52 <faxathisia> What does this mean?
02:50:53 <faxathisia> Could not deduce (Functor m) from the context (Monad m)
02:50:59 <faxathisia> I thought that Monads were Functors
02:51:12 <quicksilver> indeed they are, but haskell does not know this
02:51:37 <luqui> a bug in the design imho..
02:51:38 <sjanssen> is it just me, or does this come up daily?
02:51:53 <luqui> weekly or so for me
02:52:19 <mattam> daily
02:52:26 <vincenz> faxathisia: did you write what I said?
02:52:32 <vincenz> instance Applicative (State s) where ...
02:52:36 <faxathisia> vincenz yes
02:52:45 <sjanssen> in the channel, I mean.  I don't personally run into it very often
02:52:51 <faxathisia> then I tried Monad m => Applicative m
02:52:57 <vincenz> faxathisia: that's going to break
02:52:57 <faxathisia> but I can't do that without Functor too
02:53:09 <vincenz> faxathisia: You can't do that without -XOverlappingInstances
02:53:12 <luqui> I wonder how possible it is to support superclassing: instance (Monad m) => Applicative m, in the form meaning "every monad is an applicative", not the constraint form it currently means... or is that necessarily undecidable?
02:53:12 <vincenz> or some such
02:53:30 <faxathisia> It wanted -XFlexibleInstances and -fallow-undecidable-instances
02:53:35 <vincenz> right
02:53:42 <vincenz> cause you have an instance with no type-constructor head
02:53:50 <vincenz> imagine
02:53:57 <vincenz> instance Foo a => Bar a where
02:54:00 <vincenz> instance Bar a => Foo a where
02:54:51 <luqui> but because the instances are nonincreasing, I claim that is decidable (just erroneous)
02:55:36 <luqui> hmm, maybe I'll prototype something...
02:56:01 <vincenz> Foo a => Bar a, Foo a => Boo a, Boo a => Bar a
02:56:04 <vincenz> now you have an issue
02:56:25 <luqui> no, same issue.
02:56:30 <luqui> decidable, erroneous
02:56:52 <luqui> it's multiple instances for same type error
02:56:57 <vincenz> point
02:57:07 <luqui> a nice way to resolve that is unclear though...
02:57:10 <vincenz> a circular one is not decideable tho
02:57:16 <vincenz> it's like saying "this statement is true"
02:57:17 <mattam> You can find the loop in this case but not always
02:57:21 <vincenz> it could be both true or false
02:57:26 <vincenz> it's the opposite of a paradox
02:57:55 <luqui> but, and again this is a conjecture, if the instances are nonincreasing in term size, then you *can* always find the loop
02:58:17 <faxathisia> When is this not just a graph?
02:58:20 <vincenz> not with separate compilation
02:58:23 <faxathisia> I mean it's decideable if a graph has loops
02:58:32 <luqui> faxathisia, it might be an infinite graph
02:58:36 <mattam> If you have a finite number of instances I think
02:59:02 <faxathisia> instance x => S x where.. something like this is possible?
02:59:07 <luqui> vincenz, hmm, you've got a point.  though you can't find multiple instances with separate compilation either...
02:59:25 <luqui> faxathisia, that doesn't make sence
02:59:35 <luqui> faxathisia, the thing before => should be a class constraint
03:00:06 <faxathisia> instance Nat x => Nat (S x)
03:00:23 <luqui> faxathisia, that is fine haskell 98
03:00:40 <faxathisia> cool I think I can see where undecideability is coming frmo
03:00:53 <sjanssen> instance Nat (S x) => Nat x -- is where we run into trouble
03:00:53 <luqui> instance Nat (S x) => Nat x -- undecidableish...
03:01:02 <luqui> haha
03:02:52 <mattam> you two should write: http://haskell.org/haskellwiki/Undecidable_instances_or_Why_every_Monad_is_not_an_instance_of_Functor
03:02:53 <lambdabot> http://tinyurl.com/2buz9n
03:03:55 <luqui> except we disagree :-).  I claim that there is no good reason for it :-)
03:04:15 <sjanssen> I refuse to conflate undecidable instances and Functor => Monad
03:04:50 <mattam> well the trouble with Functor => Monad could have another solution indeed
03:04:56 <luqui> there is _especially_ no good reason for Monad not being declared:  class (Functor m) => Monad m
03:05:05 <vincenz> yes
03:05:07 <luqui> but I'm talking about no good reason for instance Monad m => Functor m
03:05:08 <vincenz> functor => Monad
03:05:10 <vincenz> is -class-
03:05:13 <vincenz> not -instance-
03:05:23 <vincenz> so that's got nothing to do with undecideable
03:05:30 <mattam> We're ok with that. It just needs to be written somewhere too
03:08:25 * vincenz writes it on a piece of paper and tosses it
03:09:06 <mattam> :)
03:09:16 * luqui doubts vincenz actually did that
03:10:13 <vincenz> luqui: I fear that's undecidable for you
03:11:12 <bringert> luqui: class (Functor m) => Monad m would certainly be possible, but it would make it more cumbersom to write monad instances, since it would force you to write a Functor instance as well
03:11:21 <bringert> that's the only reason I can see
03:11:27 <luqui> bringert, barely more cumbersome
03:11:31 <vincenz> bringert: people that can't write functor instances shouldn't be writing monads
03:11:36 <luqui> instance Functor Foo where fmap = liftM
03:11:45 <bringert> it's not about not being able to write them
03:12:17 <vincenz> tbh, this sounds like work a compiler could do
03:12:27 <bringert> I agree that it's really a minor problem to add the two lines needed, but that's the only reason I can think of for why the libs don't have class (Functor m) => Monad m
03:12:36 <luqui> I think that was the reason
03:13:10 <luqui> It's a valid but barely important reason, and I disagree with it... no biggie either way.
03:13:14 <vincenz> maybe the language should be extended with TC-rules?
03:13:21 <vincenz> if (class A a => B a)
03:13:27 <vincenz> aand instantiate B a, auto generate Aa
03:14:19 <vincenz> Might not work for everything (here I think of the Num-family), but definitely for some things
03:14:56 <luqui> auto generate if not already specified?
03:14:59 <sjanssen> seems ad-hoc
03:15:00 <luqui> because that has problems...
03:15:08 <vincenz> luqui: separate compilation
03:15:16 <luqui> right.
03:15:17 <vincenz> sjanssen: so is polymorphism in haskell
03:15:18 * vincenz coughs
03:15:26 <luqui> :-)
03:15:53 <sjanssen> @google wadler making ad-hoc polymorphism less ad-hoc
03:15:55 <lambdabot> http://citeseer.ist.psu.edu/85097.html
03:15:55 <lambdabot> Title: How to Make Ad-Hoc Polymorphism Less Ad Hoc - Wadler, Blott (ResearchIndex)
03:16:02 <quicksilver> it's an utterly invalid reason
03:16:04 <quicksilver> it's one line!
03:16:06 <sjanssen> Wadler ftw
03:16:11 <quicksilver> it's so easy to write the Functor instance
03:16:13 <quicksilver> just daft, IMO
03:16:29 <quicksilver> and it's not like defining new Monads is something new haskell programmers do every day.
03:16:40 <sjanssen> agreed
03:16:43 <vincenz> quicksilver: no, that's the first nirvana stage
03:16:49 <vincenz> "I wrote a monad!"
03:16:53 <gaal> Hi there. I just built and installed ghc HEAD, and I'm not seeing the arrows package in ghc-pkg. Is that intentional? I thought arrows was included when I did ./darcs-all --extra get
03:16:55 <quicksilver> however, the general problem
03:17:03 <quicksilver> (writing loads of instances for complex class hierarchies)
03:17:05 <quicksilver> is real
03:17:06 <quicksilver> I agree there
03:17:11 <sjanssen> 99% of monad instances are MTL or newtype-derived, I reckon
03:17:15 * vincenz still votes for class-aliases
03:17:18 <quicksilver> but Functor -> Monad is not a complex class hierarchy :)
03:17:42 <vincenz> class aliases would solve this
03:17:50 <luqui> vincenz, class aliases?
03:17:59 <vincenz> it wasa a proposed extension
03:18:04 <vincenz> It's rather syntactic but quite powerful
03:18:09 <vincenz> http://repetae.net/recent/out/classalias.html
03:18:10 <lambdabot> Title: Class Alias Proposal for Haskell
03:19:43 <vincenz> class alias Monad m = (Functor m, BareMonad m) where
03:19:49 <vincenz>   fmap = liftM
03:19:53 <sjanssen> the whole class defaults system could use some sorting (note the recent discussion on cyclic definitions on the mailing lists)
03:21:03 <luqui> vincenz, is that decidable?
03:21:20 <vincenz> it's like a default implementation
03:22:22 <vincenz> afaict
03:22:37 <luqui> i'm not totally convinced.  presumably you'd have an instance of Monad whenever there are instances of Functor and BareMonad, without having to declare an instance of Monad
03:22:59 <luqui> if that's true, decidability is not trivial...
03:23:08 <luqui> (but still concievable)
03:23:53 <luqui> the extension, even without that feature, is pretty cool though
03:24:08 * vincenz nods
03:24:19 <vincenz> It's a shame it never got adopted
03:24:19 <luqui> I'd go for it, at the current moment writing a somewhat complex hierarchy which would benefit :-)
03:24:27 <vincenz> The only problem with it is that it requires a bit of coding
03:24:33 <luqui> i wish I were a haskell guru so I could hack it into ghc
03:24:34 <vincenz> Since yo need to edit ghc down to the .hi file
03:24:36 <vincenz> you need to export aliases
03:24:44 <luqui> oh, that's trickier
03:24:47 <vincenz> So it's not a big change, but it's a change all the way down
03:25:02 <vincenz> Which is what requires a ghc expert
03:26:57 <quicksilver> luqui: where do you think undecidability would creep in?
03:27:56 <luqui> quicksilver, the fact that you can't transliterate it to haskell 98
03:28:12 <luqui> (ignoring .hi stuff)
03:28:13 <quicksilver> that's not a proof of undecidability :P
03:28:35 <luqui> I'm not proving it, it's just that a decidability proof is not trivially derived from H98's
03:28:50 * quicksilver nods
03:39:42 <luqui> okay I was misunderstanding, if the defaults only came into effect when declaring an instance of the alias then it's fine, of course
03:39:50 <luqui> the problem is when you want the defaults to declare some of the instances in the alias, which i suspect wasn't intended
03:42:37 <zeloran> hi
03:42:54 <zeloran> does somebody know a list/url for all character escape sequence in haskell?
03:44:21 <faxathisia> @where report
03:44:22 <lambdabot> http://www.haskell.org/onlinereport/
03:44:31 <luqui> specifically http://haskell.cs.yale.edu/haskell-report/syntax-iso.html#escape
03:44:31 <lambdabot> Title: Haskell 1.3 Syntax
03:44:45 <faxathisia> uh
03:44:48 <faxathisia> yeah luqui got there first
03:45:53 <luqui> I didn't know about \NUL etc.
03:45:55 <luqui> that's cool
03:47:30 <zeloran> thx very mush :)
03:47:40 <zeloran> much
03:51:22 <quicksilver> > map toEnum [0..] :: [Char]
03:51:25 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
03:51:30 <quicksilver> There you go. A list
03:51:31 <quicksilver> ;)
03:53:40 <Cale> heh, from the 1.3 report, no less :)
04:11:57 <jz87> what's a .hsc file?
04:14:17 <Lemmih> jz87: A file for hsc2hs.
04:14:38 <jz87> what does that do?
04:14:45 <jz87> I'm trying to compile fastcgi bindings
04:14:51 <jz87> and apparently it's missing c header files
04:15:16 <Lemmih> It helps you write foreign language bindings.
04:15:21 <jz87> ah
04:15:34 <Lemmih> You probably haven't installed the fastcgi library.
04:16:28 <jz87> I see
04:17:10 <jz87> I need to learn more about these corners of haskell
04:17:22 <jz87> there are like 10 books on functional programming in haskell
04:17:35 <jz87> and none of them explains stuff like FFI
04:17:56 <faxathisia> jz87: if you haven't read http://research.microsoft.com/~simonpj/papers/marktoberdorf/mark.pdf you might like it
04:17:57 <lambdabot> http://tinyurl.com/yq63p6
04:19:33 <DRMacIver> jz87: I imagine Real World Haskell will help a lot with that.
04:20:22 <jz87> I hve read sections of them
04:20:28 <jz87> I'm pretty familiar with IO by this point
04:21:08 <DRMacIver> I mean the book "Real World Haskell" :)
04:21:53 <jz87> where would I get this book?
04:21:57 <jz87> is this a joke?
04:21:59 <DRMacIver> It's not out yet.
04:22:11 <DRMacIver> http://www.realworldhaskell.org/
04:22:12 <lambdabot> Title: Real World Haskell
04:23:01 <jz87> that sucks
04:23:04 <jz87> not yet published
04:23:07 <jz87> but I want it now
04:25:42 <Cale> http://uk.youtube.com/watch?v=k-RehY4tLdI -- new catsters video :)
04:25:42 <lambdabot> Title: YouTube - 2-categories 1
04:27:02 <roconnor> Cale: can we add partitionM to Control.Monad ?
04:27:15 <Cale> roconnor: I don't see why not?
04:27:23 <roconnor> :D
04:27:40 <roconnor> wait, let me rephrase
04:27:45 <roconnor> Cale: can you add partitionM to Control.Monad ?
04:27:51 <Cale> roconnor: If I were in charge of these things, there would be a lot of other things in Control.Monad as well.
04:28:34 <roconnor> Cale: do you have a darcs repo for Cale.Monad ?
04:28:36 <Cale> Or are you asking me to invent such a function, and write up the appropriate patch, then submit it to the libraries list?
04:28:46 <Cale> hehe :)
04:28:55 <roconnor> Cale: I think that is what I'm asking :)
04:29:08 <mux> I often find the haskell base libraries a bit terse
04:29:20 <Cale> I should make some kind of effort to collect together the various snippets of code which I have lying around.
04:29:56 <mux> I've submitted a few functions already, but I often get somehow counter-attacked by Bulat
04:29:58 <roconnor> Cale: --> http://www.cse.unsw.edu.au/~sseefried/darcs/icfp07/MonadUtil.hs
04:30:04 <Cale> I have several directories now of hundreds of purely miscellaneous Haskell source files, constructed usually while talking to someone here or playing around with some idea.
04:30:25 <jz87> oh yeah
04:30:28 <faxathisia> You should make it browseable online1
04:30:32 <jz87> a lot of the library code is unreadable
04:30:43 <jz87> people use really undescriptive names for functions and name bindings
04:30:58 <jz87> I try to write in literal haskell so I know what I wrote 6 months down the road
04:31:16 <jz87> and I try to expand monads into do notation unless it's a really short 1 liner
04:31:30 <roconnor> jz87: one tends to learn the terminology after a while.
04:31:35 <Cale> The undescriptive names are usually for those things too polymorphic to give names to.
04:31:51 <jz87> yeah, that's part of the problem
04:32:02 <jz87> in that case I think it should be accompanied by a comment
04:32:04 <faxathisia> any exmples?
04:32:08 <Cale> It's okay, you do get used to it.
04:32:10 * faxathisia can't think of any such functions
04:32:15 <jz87> I think the right mixure of comment to code ratio in haskell is probably like 2 to 1
04:32:21 <Cale> faxathisia: hm?
04:32:37 <Cale> faxathisia: Examples of names in code which can't really be meaningfully improved?
04:32:39 <faxathisia> something with an undescriptive name
04:32:41 <roconnor> faxathisia: some people on reddit were complaining about fst and snd
04:32:46 <Cale> Let's say:
04:32:49 <jz87> people use names like h
04:32:50 <Cale> map f [] = []
04:32:51 <roconnor> faxathisia: I suggested car and cdr instead
04:32:51 <jz87> or hn
04:32:57 <Cale> map f (x:xs) = f x : map f xs
04:33:02 <jz87> instead of handle and hostname
04:33:04 <Cale> f and x there
04:33:28 <roconnor> jz87: oh, you mean names of variables?
04:33:36 <jz87> I think there needs to be some sort of source processor
04:33:38 <faxathisia> oh right, yeah I detest 'hn' instead of 'hostname', but 'f' for a general function seems perfectly fine
04:33:42 <phlpp> hi there
04:33:45 <jz87> like, long to short name convertion
04:33:48 <Cale> Sure, you could write something like functionToApply instead of f, but it doesn't really buy any readability, in fact, it takes away.
04:34:00 <faxathisia> roconnor: But then you have to have cadr cddr etc
04:34:05 <jz87> why not just function
04:34:13 <roconnor> faxathisia: :)
04:34:20 <jz87> map function list
04:34:34 <Cale> jz87: 'function' doesn't really buy anything over 'f'
04:34:47 <jz87> or you can just define over = $
04:34:54 <jz87> and write map function over list
04:34:57 <jz87> that's very readable
04:35:02 <faxathisia> âˆ‚function(x)*other_function(x)/âˆ‚x =
04:35:05 <faxathisia> yuck!
04:35:20 <idnar> jz87: it's readable, but deceptively so
04:35:23 <jz87> haskell has the potential to read very close to natural english
04:35:37 <jz87> there are 2 ways to read programs
04:35:39 <Cale> jz87: uh, over will be a parameter to map there
04:35:45 <jz87> one is to think about operational semantics
04:35:50 <jz87> that's not how I like to read programs
04:35:54 <jz87> that's how you read imperative programs
04:35:58 <idnar> jz87: you're making the source code say what it does, but in a way that means that the reason why it does what it says it does, has nothing to do with why it says that
04:35:59 <jz87> you trace the executation in your head
04:36:18 <Cale> The point is that many functional programs do purely structural things with data, and you don't really need meaningful names for that.
04:36:18 <idnar> (also, as Cale points out, that won't work)
04:36:28 <jz87> yes
04:36:50 <idnar> I don't see the point in calling it 'f' instead of 'function', when 'f' is a well-known conventional name for an arbitrary function
04:37:12 <Cale> Plus, if all else fails, look at the type :)
04:37:13 <jz87> but using short 1, 2 character names make the code unreadable to anyone but the most experienced haskell programmers
04:37:21 <idnar> jz87: that really depends on the code
04:37:24 <jz87> well, I'm talking about heavily nested functions
04:37:29 <Cale> jz87: Not true. It's something you get used to fairly quickly.
04:37:30 <jz87> which don't have type annotations
04:37:31 <faxathisia> jz87: not true, you can just the type signature
04:37:35 <jz87> yes
04:37:39 <jz87> but if you're looking at a function
04:37:41 <Cale> At least, I got used to it rather quickly. :)
04:37:48 <idnar> jz87: using a long and meaningless name isn't an improvement over a short and meaningless name
04:38:04 <faxathisia> just load it into ghci or whatever and check it's type
04:38:07 <Cale> (but perhaps I'm abnormal, given my background is in mathematics where we basically use one-character variables all the time)
04:38:08 <jz87> f h hn x = io h hn x where io _ _ n = f
04:38:12 <jz87> something like that
04:38:19 <jz87> except instead of just one inner function
04:38:23 <jz87> you have a whole list like 4-5
04:38:28 <jz87> and none of them have type annotations
04:38:41 <jz87> put this in a function that's doing some complicated monadic magic
04:38:48 <idnar> well, I suspect you should be shot for writing that code ;)
04:38:48 <faxathisia> if type annotations are clearer than the code, then I think someone is going to include them
04:39:03 <jz87> haha
04:39:13 <roconnor> now I really want a language that divorces the source code as string from the asbstract syntax tree.
04:39:19 <jz87> well in the code that I've been reading
04:39:23 <roconnor> that would solve jz87's problem
04:39:25 <idnar> but yeah, type annotations usually help a lot more with "generic" variables than trying to mush the type info into the name somehow
04:39:25 <jz87> there is very little comments and very little type annotations
04:39:30 <roconnor> and a bunch of other problems too
04:39:32 <jz87> in fact most of the functions aren't even type annotated
04:39:33 <faxathisia> What does that mean roconnor?
04:39:36 <jz87> even top level ones
04:39:59 <jz87> well type annotatinos aren't a panacea either
04:40:04 <jz87> some type annotations are confusing
04:40:05 <roconnor> faxathisia: I imagine a system where your code is saved as an AST.
04:40:27 <faxathisia> ah.. I can imagine that being very nice for editors
04:40:31 <jz87> especially type annotations of the form (Error a, Stm b, M1 b, M2 a) => a -> b
04:40:35 <roconnor> faxathisia: then you load the AST + style, into your editor
04:40:36 * faxathisia wants more things like paredit
04:40:51 <roconnor> roconnor: different people can use different styles
04:40:52 <roconnor> er
04:40:56 <roconnor> different people can use different styles
04:40:57 <jz87> where you have a huge long list of distracting restrictions before the real type
04:41:01 <roconnor> and edit the same code
04:41:05 <roconnor> and use the same code
04:41:22 * faxathisia likes the idea
04:41:26 <roconnor> and not complain about wheter it should be called unzipEithers or partitionEithers, or splitEithers.
04:41:33 <Cale> jz87: Those aren't distracting, they're important!
04:41:36 <jz87> yeah, I agree that picking suitable names is hard
04:41:38 <faxathisia> although it would be important to have an editor everyone can use
04:41:40 <jz87> which is why I like haskell
04:41:44 <jz87> where types really help you
04:41:53 <jz87> some of the other languages, like erlang
04:41:56 <jz87> is almost unreadable
04:42:03 <jz87> unless the code is very clearly commented
04:42:16 <Cale> jz87: If you just see a -> b, then the type is not meaningful. It's those restrictions there which tell you what a and b are meant to mean.
04:42:27 <roconnor> faxathisia: yep.  And honestly, I'm not sure such a system would be practical.  But I think it is worth a try.
04:42:42 <jz87> Cale, I know those are important, but when they take up more space than the basic type
04:42:45 <jz87> it's distracting
04:42:48 <faxathisia> roconnor: Doesn't epigram do this to an extent..
04:42:59 <roconnor> faxathisia: that is a good question.
04:43:02 <Cale> It might be worth considering alternate syntaxes for typeclass constraints. We could have gone with something using where
04:43:12 <byorgey> jz87: what code are you reading?
04:43:17 <jz87> I know a -> b doens't tell you everything, but I think the C#/Java way of restricting types makes more sense
04:43:19 <jz87> in terms of syntax
04:43:27 <Cale> f :: a -> b where Error a; Stm b; M1 b; M2 a
04:43:32 <jz87> you put the ytpe restrictions after the type instead of before
04:43:36 <jz87> like a footnote
04:43:49 <jz87> HAppS
04:43:53 <byorgey> Cale: yeah, that's not a bad idea
04:43:54 <byorgey> ah
04:43:58 <jz87> try reading the code for HAppS
04:44:13 <jz87> I tried installing it and it didn't work
04:44:15 <jz87> so I tried to fix thing
04:44:21 <Cale> However, the current syntax does serve as a rather nice reminder of the actual implementation of typeclasses in practice.
04:44:23 <jz87> but reading the source code is nearly impossible
04:45:00 <faxathisia> reading code seems to be.. often harder than writing it
04:45:01 <jz87> now if Haskell source editors can fold those type restrictions like Eclipse does with function definitions
04:45:05 <faxathisia> (regardless of language)
04:45:10 <jz87> it would make those complex monads a lot less intimidating
04:45:41 <jz87> here's the problem with haskell
04:45:47 <jz87> because the type checker is so powerful
04:45:55 <jz87> the actual source files are woefully under annotated
04:46:05 <jz87> if people don't put in types or comments
04:46:09 <jz87> the code becomes unreadable
04:46:12 <faxathisia> jz87: You can put annotations if they make the code better
04:46:17 <jz87> yes I do
04:46:21 <jz87> I code in literal haskell
04:46:24 * faxathisia does too
04:46:28 <faxathisia> except not lhs
04:46:33 <jz87> I basically write as if I'm writing a blog post
04:46:41 <jz87> and then insert some code in between the paragraphs
04:47:01 <jz87> but it's not me who's writing all that unreadable code out there
04:47:02 <faxathisia> hmm.. I mostly don't write comments
04:47:05 <Cale> jz87: literal, or literate?
04:47:10 <jz87> literate
04:47:13 <faxathisia> although sometimes paste stuff in from references
04:47:26 <jz87> I think it's worth the time to write explanations
04:47:33 <jz87> unless it's VERY obvious what  the code is doing
04:47:57 <jz87> you really want your code to be modifiable by other people
04:48:06 <jz87> that is the whole point behind open source
04:48:06 <faxathisia> you have basically 3 languages.. Haskell, Haskell Type System, Stuff in comments... So easy for comments to go out of sync
04:48:15 <jz87> yes, that's true
04:48:37 <jz87> but at least document the intentions of the function
04:48:41 <jz87> if not how it works
04:48:53 * faxathisia would really like more expressive types but I guess that's not haskell
04:48:57 <jz87> I might be able to figure out how it works from reading what it's supposed to do
04:49:15 <jz87> the reason why pasting into ghci doesn't always work
04:49:31 <jz87> is that sometimes you are referencing inner functions
04:49:36 <jz87> which aren't defined in the global scope
04:49:48 <jz87> I would need a ghci execution context that is inside of your function
04:49:53 <faxathisia> :t reverse.rev
04:49:55 <lambdabot> Not in scope: `rev'
04:49:55 <jz87> in order to type a particular expression
04:49:58 <faxathisia> (would be nice :p)
04:49:59 <dcoutts> jz87: yes, the gtk2hs-0.9.12.1 release works with ghc-6.8.x
04:50:10 <jz87> yes, but I can't install it
04:50:11 <jz87> with windows
04:50:15 <faxathisia> hey, I'm sure that's possible to code
04:50:25 <faxathisia> How does anyone edit GHC?
04:50:41 <matthew_-> faxathisia: emacs
04:50:45 <faxathisia> I mean it takes a couple hours to compile, so.. do you just make sure to get it right in the first place?
04:51:07 <Lemmih> faxathisia: It's only the libraries that take a long time.
04:51:08 <matthew_-> you can do stage1 builds quite quickly
04:51:24 <matthew_-> and if you turn off optimisations, you can build it in 5 mins
04:51:28 <jz87> haha
04:51:40 <Lemmih> faxathisia: Compiling say stage2 only takes a few minutes. Usually seconds if you haven't touched that many files.
04:52:08 <jz87> well, if you can run ghci's executation contexts inside of functions
04:52:13 <jz87> that would be awesome
04:52:31 <jz87> because some expressions can't be typed in the global context
04:55:00 <quicksilver> jz87: that would indeed be nice
04:55:09 <quicksilver> jz87: although in general there might be a lot you have to supply
04:57:29 <faxathisia> jz87: Oh I just realized I do use comments sometimes, for things I don't know how to put in the type system.. like this is a list of unique elements
04:58:24 <faxathisia> other than that.. I'm not sure it helps, If I'm reading code I generally look at the code
04:58:24 <jz87> Also
04:58:41 <jz87> sometimes I purposefully don't annotate types
04:58:50 <jz87> because annotating types can make things painful
04:59:00 <jz87> for example. if I'm writing a library that uses String
04:59:10 <jz87> but I want to be able to switch to bytestring down the road
04:59:18 <jz87> if I annotated String everywhere
04:59:23 <jz87> it would be a pain in the pass to change
04:59:40 <jz87> byteString and String should seriously be grouped into the same class
04:59:53 <jz87> so that programs can be written to be portable between the two
05:01:57 <Cale> That's easier said than done, though there's been talk about doing something about it.
05:02:15 <Taejo> @src map
05:02:16 <lambdabot> map _ []     = []
05:02:16 <lambdabot> map f (x:xs) = f x : map f xs
05:02:36 <Cale> jz87: Note that it's also convenient in that the compiler will inform you where changes need to be made, pretty much automatically.
05:06:39 <dcoutts> jz87: ah yes, I need to update the windows installer for ghc-6.8.2
05:07:14 <jz87> yes, well sometimes those changes are sprawled all over the place
05:07:27 <jz87> it would be even nicer if those changes can be made automatically if they're the same changes
05:07:33 <jz87> just applied over a ton of source files
05:08:08 <jz87> I was trying to build haxr with my copy of Network.http
05:08:15 <jz87> which uses Lazy bytestrings instead of String
05:08:32 <jz87> so haxr doesn't compile because it expects the standard Network.HTTP which uses strings
05:08:47 <jz87> and in order to fix haxr, I also have to fix haxml which also expects String
05:09:05 <faxathisia> search and replace?
05:09:11 <roconnor> for my ICFP contest I used the module system to make an abstract interface that worked for ByteStrings, LazyByteString, and Seq.
05:09:17 <jz87> it's not that trivial
05:09:23 <roconnor> I'm sure I could add String if I wanted :)
05:09:36 <jz87> that would help a lot
05:09:39 <faxathisia> if ghc tells you everwhere there is a mistake.. it shoudl be possible to use that to search and replace automatically I think
05:10:01 <jz87> if libraries can be written to an abstract interface instead of String specifically
05:10:16 <jz87> because if you have a library, but you need to optimize it for speed, then you need to use bytestring
05:10:33 <jz87> using String with large inputs is not feasible
05:11:18 <roconnor> jz87: This worked well for me, but it isn't as nice as a class for String/Bytestring would be.
05:11:28 <roconnor> (ie it worked well for a single project0
05:12:45 <jz87> well the problem is when you get into interdependent libraries
05:12:48 <earthy> faxathisia: hare allows you to do something like that
05:12:59 <jz87> I don't want to hand convert a bunch of 3rd party libraries I didn't write
05:13:04 <jz87> to another string representation
05:13:27 <jz87> bytestring really should be the default
05:13:29 <jz87> for a lot of things
05:13:30 <roconnor> exactly
05:13:44 <zeloran> does somebody remember the operator that is used to select an element by its index from a list?
05:13:55 <faxathisia> zeloran: (!!)
05:14:02 <jz87> ask lambda bot
05:14:16 <jz87> Int -> [a] -> a
05:14:19 <zeloran> thx
05:14:23 <faxathisia> yeah, if you know it's type ([a] -> Int -> a)you can hoogle it
05:14:34 <jz87> what's the syntax to lambda bot
05:14:35 <faxathisia> @hoogle [a] -> Int -> a
05:14:36 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
05:14:36 <lambdabot> Data.List.(!!) :: [a] -> Int -> a
05:14:40 <jz87> doesn't lambda bot have hoogle functionality?
05:14:42 <jz87> ah there it is
05:14:52 <roconnor> @hoogle Int -> [a] -> a
05:14:53 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
05:14:53 <lambdabot> Data.List.(!!) :: [a] -> Int -> a
05:15:00 <roconnor> hoogle is so smart :D
05:15:03 <jz87> yeah
05:15:08 <jz87> but it's not complete
05:15:12 <jz87> a lot of libraries aren't in there
05:15:13 <faxathisia> @hoogle [a] -> (a -> b) -> [b]
05:15:14 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
05:15:14 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
05:15:14 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
05:15:14 <jz87> like HTTP
05:15:22 <jz87> @hoogle receiveHTTP
05:15:22 <lambdabot> No matches found
05:15:36 <roconnor> jz87: in principle you can install hoogle yourself and index whatever you want.
05:15:40 * faxathisia wishes djinn could do lists..
05:15:43 <jz87> true
05:16:04 <jz87> but then I'd be maintaining an index to 3rd party libraries
05:16:41 <jz87> hoogle should just automically download and index all the source files uploaded to hackage
05:17:36 <earthy> yes, I'd also like a pony. :)
05:17:59 <Taejo> jz87: if you code it, I'll use it
05:19:06 <Taejo> @src foldM
05:19:06 <lambdabot> foldM _ a []     = return a
05:19:06 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
05:19:51 <roconnor> jz87: basically hoogle should be a package that we download and indexes all of our own libraries.
05:20:01 <roconnor> call it hoogle toolbar
05:20:12 <roconnor> or hoogle desktop
05:20:18 <roconnor> or whatever
05:20:44 <faxathisia> can ghciu get plugins?
05:20:51 <faxathisia> so like you have hoogle and djinn in ghci? :D
05:21:52 <roconnor> yep
05:26:34 <Taejo> @pl cartProd xs ys = concatMap ((flip map ys) . (,)) xs
05:26:34 <lambdabot> cartProd = (. ((. (,)) . flip map)) . (>>=)
05:27:18 <Taejo> @type (. ((. (,)) . flip map)) . (>>=)
05:27:20 <lambdabot> forall a a1. [a1] -> [a] -> [(a1, a)]
05:27:30 <Taejo> @type (. ((. (,)) . flip fmap)) . (>>=)
05:27:31 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => m a1 -> m a -> m (a1, a)
05:27:42 <faxathisia> > ((. ((. (,)) . flip map)) . (>>=)) [1,2,3,4] [5,6,8,7]
05:27:43 <lambdabot>  [(1,5),(1,6),(1,8),(1,7),(2,5),(2,6),(2,8),(2,7),(3,5),(3,6),(3,8),(3,7),(4,...
05:28:43 <vincenz> > return (,) `ap` [1..4] `ap` [5..7]
05:28:43 <lambdabot>  [(1,5),(1,6),(1,7),(2,5),(2,6),(2,7),(3,5),(3,6),(3,7),(4,5),(4,6),(4,7)]
05:28:53 <faxathisia> nice :D
05:29:23 <Taejo> vincenz: of course :) why didn't I think of that
05:29:34 <vincenz> or you could even use applicatives
05:29:46 <vincenz> > (,) <$> [1..4] <*> [5..8]
05:29:47 <lambdabot>  [(1,5),(1,6),(1,7),(1,8),(2,5),(2,6),(2,7),(2,8),(3,5),(3,6),(3,7),(3,8),(4,...
05:29:55 <Taejo> vincenz: but can you give me a nice version of this:
05:30:01 <Taejo> @let {cartProd' (x:xs) (y:ys) xs' ys' = (zip xs' $ reverse ys') ++ (cartProd' xs ys (x:xs') (y:ys')); cartProd' _ _ _ _ = []}
05:30:02 <lambdabot> <local>:3:0: parse error on input `{'
05:30:29 <Taejo> cartProd xs ys = cartProd' xs ys [] []
05:31:01 <Taejo> that's cartesian product for infinite lists
05:31:06 <vincenz> why reverse?
05:31:40 <faxathisia> @let diagon (0, x) = (1+x, 0) ; diagon (y, x) = (y-1, x+1)
05:31:42 <lambdabot> Defined.
05:32:15 <Taejo> vincenz: the reverse is unecessary... just to make it fit with my diagram
05:32:28 <vincenz> what's wrong with <$> <*>
05:32:57 <Taejo> > (,) <$> [1..] <*> [1..]
05:32:57 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),...
05:33:13 <Taejo> >(2, 3) `elem` ((,) <$> [1..] <*> [1..])
05:33:20 <vincenz> oh you wnat a diagonal walk?
05:33:48 <Taejo> unless you know another way to get infinite cartesion products
05:34:24 <vincenz> basically you want to reach all finite elemnts withing finite time?
05:34:35 <Taejo> vincenz: yes
05:34:47 <vincenz> hmm
05:35:08 <vincenz> not off the top of my head
05:35:39 <faxathisia> > map (\(x,y) -> ([1..]!!x, cycle "foo"!!y)) (iterate diagon (0,0))
05:35:39 <lambdabot>  [(1,'f'),(2,'f'),(1,'o'),(3,'f'),(2,'o'),(1,'o'),(4,'f'),(3,'o'),(2,'o'),(1,...
05:35:49 <vincenz> faxathisia: you're nuts
05:36:29 <faxathisia> > iterate diagon (0,0)
05:36:30 <lambdabot>  [(0,0),(1,0),(0,1),(2,0),(1,1),(0,2),(3,0),(2,1),(1,2),(0,3),(4,0),(3,1),(2,...
05:36:35 <faxathisia> I think that's a nice way to do it
05:36:45 <araujo> morning
05:36:53 <faxathisia> good morning
05:36:53 <vincenz> faxathisia: dunno
05:36:56 <vincenz> !! is pisslow
05:37:03 <faxathisia> oh yeah.. that's true
05:37:20 <faxathisia> I don't know how to eliminate that
05:38:00 <zeloran> how to convert from Int to String?
05:38:10 <faxathisia> zeloran: Int -> String
05:38:12 <faxathisia> Hoogle it :D
05:38:17 <faxathisia> @hoogle Int -> String
05:38:17 <lambdabot> No matches, try a more general search
05:38:26 <roconnor> :(
05:38:26 <faxathisia> oh well show..
05:38:34 <roconnor> > show 5
05:38:34 <zeloran> Int -> String
05:38:34 <lambdabot>  "5"
05:38:48 <biribau> is there any study in the efficiency gained writing code style haskell, I mean w/o parenthesis against typical code...?
05:39:21 <vincenz> got it
05:39:22 <vincenz> Taejo: found one
05:39:27 <Taejo> biribau: you mean using $ instead of ()?
05:39:36 <Taejo> vincenz: yes?
05:39:39 <biribau> no
05:39:49 * vincenz nods
05:39:53 <biribau> f x why instead of f(x,y)
05:40:07 <biribau> f x y
05:40:08 <Taejo> ah
05:40:36 <vincenz> > let inits' = drop 1 . inits in concat $ zipWith zip (inits' [1..4]) (map reverse $ inits' [5..8])
05:40:36 <lambdabot>  [(1,5),(1,6),(2,5),(1,7),(2,6),(3,5),(1,8),(2,7),(3,6),(4,5)]
05:40:51 <biribau> sorry it's the auto gramatical correction of pidgin, transforms all my y's in why's
05:40:59 <vincenz> > let diagonalize xs ys = let inits' = drop 1 . inits in concat $ zipWith zip (inits' xs) (map reverse $ inits' ys) in diagonalize [1..] [1..]
05:41:00 <lambdabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),(3,...
05:41:28 <vincenz> > let diagonalize xs ys = let inits' = drop 1 . inits in concat $ zipWith zip (inits' xs) (map reverse $ inits' ys) in diagonalize [1..] [1..3]
05:41:28 <lambdabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1)]
05:41:32 <vincenz> hmm
05:41:42 <Taejo> vincenz: where is inits defined?
05:41:43 <vincenz> only works for squares
05:41:48 <vincenz> yes
05:41:51 <vincenz> that brings up a valid question
05:41:56 <vincenz> what do you do about non-squares?
05:42:04 <biribau> > 1
05:42:04 <faxathisia> cycle
05:42:05 <lambdabot>  1
05:42:14 <vincenz> faxathisia: only if you want an infinitely repeated thing
05:42:28 <vincenz> > let diagonalize xs ys = let inits' = drop 1 . inits . cycle in concat $ zipWith zip (inits' xs) (map reverse $ inits' ys) in diagonalize [1..] [1..3]
05:42:29 <faxathisia> diagonalize x y = diagonalize (cycle x) (cycle y)
05:42:29 <lambdabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,1),(2,3),(3,2),(4,1),(1,2),(2,1),(3,...
05:43:01 <Taejo> vincenz: my code doesn't seem to work on finite lists at all
05:43:07 <vincenz> nope
05:43:13 <vincenz> doesn't work on non-square matrices
05:43:19 <biribau> > [(x,y)| x<-[1..3]| y<-[1..3] ]
05:43:19 <lambdabot>  Parse error at "|" (column 18)
05:43:28 <jedbrown> There was a related discussion on -cafe a while back with regard to merging a possibly infinite list of infinite lists.
05:43:30 <vincenz> biribau: we already covered that
05:43:39 <vincenz> > (,) <$> [1..3] <$> [4..6]
05:43:39 <lambdabot>  Couldn't match expected type `a -> a1' against inferred type `[a2]'
05:43:43 <vincenz> > (,) <$> [1..3] <*> [4..6]
05:43:44 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
05:43:48 <jedbrown> I believe byorgey had a nice solution.
05:44:26 <vincenz> if we just had a check (isInfinite)
05:44:30 <vincenz> ;
05:44:31 <vincenz> :D
05:45:09 <vincenz> faxathisia: btw, I think cycle is dangerous
05:45:19 <faxathisia> Why?
05:45:20 * vincenz thinks cycle would lead to a spaceleak if used on an infinite list
05:45:27 <vincenz> you can't apply fusion
05:45:30 <vincenz> since you still need the list
05:45:48 <vincenz> granted, in this case that is kind of a moot point
05:46:30 <vincenz> @pl \x y -> zip (inits x) (map reverse $ inits y)
05:46:30 <lambdabot> (. (map reverse . inits)) . zip . inits
05:46:40 <Taejo> @where inits
05:46:40 <lambdabot> I know nothing about inits.
05:46:45 <vincenz> @src inits
05:46:45 <lambdabot> inits []     =  [[]]
05:46:45 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
05:46:50 <vincenz> it's std functionality
05:46:54 <faxathisia> ?djinn False
05:46:54 <lambdabot> -- f cannot be realized.
05:46:56 <vincenz> @hooge inits
05:46:57 <lambdabot> Data.List.inits :: [a] -> [[a]]
05:46:57 <lambdabot> Data.ByteString.inits :: ByteString -> [ByteString]
05:46:57 <lambdabot> Data.ByteString.Char8.inits :: ByteString -> [ByteString]
05:47:36 <Taejo> vincenz: in GHC 6.6.1, I get "Not in scope: `inits'"
05:47:49 <vincenz> Taejo: import Data.List
05:47:54 <Taejo> ok
05:50:39 <fadec> I have a toy browser I'm working on to learn haskell and I need a little guidance. To parse invalid html I was thinking I should lex it into at least start and end tags, then apply a correction algoritm. Is Read.Lex suitable?
05:51:18 <roconnor> fadec: web browser?
05:51:49 <fadec> roconnor: yes - nothing specail
05:52:05 <roconnor> fadec: there exist html parsers, or do you want to write your own HTML parser?
05:52:24 <fadec> I started with Parsec
05:52:40 <roconnor> Parsec is good.
05:52:44 <fadec> but I can only parse valid html and a subset at that
05:53:30 <roconnor> so do you on purpose want to write your own HTML parser as an exercise, or should we point you to one of the existing HTML parsers?
05:53:44 <fadec> I'll take a pointer to an existing parse
05:53:49 <fadec> parser
05:55:25 <roconnor> fadec: HaXml comes with an HTML parser that I've used a little bit
05:55:37 <roconnor> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HaXml-1.19.1
05:55:38 <lambdabot> http://tinyurl.com/3cnr3v
05:55:56 <fadec> I'll look more into that
05:56:00 <fadec> thanks
05:56:19 <roconnor> there may be other HTML parsers out there
05:56:20 <fadec> roconnor: did you have any issues with invalid markup?
05:56:30 <malcolmw> the HaXml parser for HTML does a certain amount of non-well-formedness detection and correction
05:56:30 <roconnor> I was only parsing valid HTML.
05:56:48 <fadec> cool
05:56:49 <roconnor> fadec: I used TagSoup to ``parse'' invalid HTML
05:57:11 <roconnor> but I use parse losely.  TagSoup is really designed for ``grepping'' HTML
05:57:27 <roconnor> or scrapping
05:57:31 <roconnor> or whatever you want to call it.
05:59:23 <roconnor> fadec: be warned, HaXml isn't the easiest thing in the world to learn.
05:59:29 <fadec> I see there is Text.XML.HaXml.Html.Pretty
05:59:36 <fadec> roconnor: I got that impression
05:59:47 <fadec> this tag soup? http://www-users.cs.york.ac.uk/~ndm/tagsoup/
05:59:47 <lambdabot> Title: Neil Mitchell - Tag Soup
05:59:52 <roconnor> and Text.XML.HaXml.Html.Parse
06:00:01 <roconnor> fadec: that is tagsoup
06:05:25 <jedbrown> > let next n l = map head a ++ next (n+1) (map tail a ++ b) where (a,b) = splitAt n l in next 1 $ map (iterate succ) [0,10..]
06:05:28 <lambdabot>  [0,1,10,2,11,20,3,12,21,30,4,13,22,31,40,5,14,23,32,41,50,6,15,24,33,42,51,6...
06:43:32 <eu-prleu-peupeu> hey!
06:43:37 <eu-prleu-peupeu> does haskell support continuations ?
06:43:53 <sieni> yes
06:44:14 <sieni> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Cont.html
06:44:15 <lambdabot> http://tinyurl.com/vp4ok
06:49:29 <quicksilver> that's a funny answer to it, in a way
06:49:56 <quicksilver> there is a sense in which haskell doesn't support full first-class continuations, I believe
06:50:07 <quicksilver> but, since haskell has strong support for functions
06:50:17 <quicksilver> it supports continuations encoded as functions
06:50:38 <eu-prleu-peupeu> does haskell support reflection ?
06:50:42 <quicksilver> what the library sieni pointed to is, is a way of implementing continuations as a monad.
06:50:55 <quicksilver> eu-prleu-peupeu: not in a full native fashion, no.
06:51:05 <quicksilver> it's a full compiled language with no type information at runtime.
06:51:15 <eu-prleu-peupeu> ok
06:51:24 <quicksilver> however, typeclasses turn out to give you most of the benefits of reflection without the overhead.
06:51:30 <eu-prleu-peupeu> and are there any rtti modules ?
06:51:44 <quicksilver> Data.Typeable is RTTI in a sense.
06:51:54 <eu-prleu-peupeu> hmm
06:52:03 <quicksilver> but the question is less germane than you image
06:52:10 <eu-prleu-peupeu> why are haskell coders so hard to find ?
06:52:12 <quicksilver> the point of RTTI is for cases when you have a value of unknown type.
06:52:26 <quicksilver> since haskell is strongly typed with types checked at compile time
06:52:32 <quicksilver> there is no such thing as an unknown type
06:52:37 <eu-prleu-peupeu> hmm
06:52:39 <quicksilver> all types are known, and furthermore, known at compile time.
06:52:40 <eu-prleu-peupeu> i see
06:52:49 <quicksilver> As for why haskell programmers are rare, I don't know.
06:52:57 <quicksilver> I'm tempted to say "because good programmers are rare"
06:52:57 <eu-prleu-peupeu> hmm
06:53:01 <quicksilver> but I'd be half-joking.
06:53:31 <eu-prleu-peupeu> why is the documentation on most haskell modules extremely incomplete ?
06:54:21 <matthew-_> Haskell code is self documenting?
06:54:23 <quicksilver> because people are lazy :)
06:54:34 <quicksilver> but also, the type is sufficient documentation surprisingly often
06:54:38 <quicksilver> and the source is often easy to read
06:54:38 <matthew-_> given the function name and its type sig, it's surely obvious what it does?
06:54:52 <eu-prleu-peupeu> ok
07:07:18 <eu-prleu-peupeu> can i manipulate the AST's askell generates ?
07:07:38 <Japsu> eu-prleu-peupeu: yes, that's what Template Haskell (TH) is for
07:09:23 <eu-prleu-peupeu> nice
07:10:05 <eu-prleu-peupeu> can i link haskell with C, and have it parse my input ? (like the python C-API does)
07:10:42 <luqui> eu-prleu-peupeu, in a manner of speaking, using the ghc api
07:13:08 <eu-prleu-peupeu> hmm
07:13:52 <luqui> actually maybe not
07:14:10 <eu-prleu-peupeu> i have some bash scripts that i want to port for a higher level language, these bash scripts are the core of my business, and i was wondering, does haskell have any module that replaces "curl" ?
07:14:22 <luqui> well, actually yes, but it's kind of convoluted (shouldn't be too hard though)
07:15:22 <eu-prleu-peupeu> hmm
07:15:26 <eu-prleu-peupeu> how is it called ?
07:16:30 <luqui> eu-prleu-peupeu, the ghc api is only available from within haskell, since ghc is written in haskell.  but you can use FFI bindings to export a C routine which calls back into haskell's ghc api
07:16:55 <luqui> so haskell calls c, which does its thing and calls haskell back, which compiles/executes code and returns..
07:17:37 <luqui> check out http://haskell.org/haskellwiki/GHC/As_a_library for the beginning of the trail
07:17:41 <hpaste>  wy pasted "An attempt to define a heterogeneous list" at http://hpaste.org/4792
07:18:33 <wy> Hey, look at this post. I somehow figured out how to define a heterogeneous list, but I'm having trouble defining map on it
07:18:40 <Saizan> eu-prleu-peupeu: we have abinding to libcurl
07:18:40 <luqui> wy, that's a compile-time list...
07:18:42 <eu-prleu-peupeu> right now im between moving to haskell or sticking with python
07:19:00 <eu-prleu-peupeu> ok, thats nice
07:19:10 <luqui> wy, isomorphic to a tuple...
07:19:10 <eu-prleu-peupeu> i will look into that for the bash scripts
07:19:38 <luqui> wy, mapping over it will be about as meaningful as mapping over a tuple...
07:19:38 <wy> luqui, Can you define map on it?
07:19:59 <wy> oh.. Let me see why this can't be done...
07:20:25 <oerjan> wy: i vaguely recall oleg did it, actually :D
07:20:40 <luqui> oleg doesn't count :-)
07:20:42 <Saizan> it's not an easy thing to encode
07:20:55 <oerjan> luqui: thus the smiley
07:21:03 <wy> oerjan, The same way?
07:21:16 <|Lupin|> hello everybody.
07:21:30 <glen_quagmire> hello |Lupin| , welcome to #haskell. I'm your bot.
07:21:43 <luqui> wy, do you mean for your list's length to be fixed at compile time?
07:21:57 <Saizan> since to use the elements you need some kind of class context on them, and you can't specify that in a generic map
07:22:10 <|Lupin|> Could anyhbody please suggest a (programming language independent) introduction to delimited continuations, control operators and so on, please ?
07:22:25 <wy> luqui: No. You can have different length I think
07:22:46 <Saizan> wy: the type of the list also encodes the length
07:23:01 <oerjan> wy: don't know.  doubtlessly he used some heavy type hackery with type classes, although somehow only Haskell 98.  at least that's how it usually goes ;)
07:23:34 <faxathisia> |Lupin|: One good article is this http://community.schemewiki.org/?composable-continuations-tutorial
07:23:36 <lambdabot> http://tinyurl.com/yy2eux
07:24:32 <|Lupin|> faxathisia: thanks!
07:24:34 <mrd> |Lupin|: oleg has a lot of writings on this: http://okmij.org/ftp/Computation/Continuations.html
07:24:34 <lambdabot> Title: Continuations and delimited control
07:24:36 <wy> oerjan: I'm not actually trying to create heterogeneous lists. I'm experiment an idea. If I can make heterogeneous lists this way, I can prove that we don't need variants in data types
07:25:27 <|Lupin|> mrd: also good, thanks!
07:25:37 <fadec> eu-prleu-peupeu: python to haskell? An increase in expressiveness and performance, like the BASIC to C transion of your youth, but in 2008.
07:26:00 <Saizan> ?where hlist
07:26:00 <lambdabot> http://homepages.cwi.nl/~ralf/HList
07:26:08 <Saizan> wy: for inspiration ^^^
07:26:42 <Saizan> i suggest you to read the paper first
07:27:13 <eu-prleu-peupeu> fadec: i still find it hard why there are so few haskell programmers ?
07:27:28 <glen_quagmire> have you ever collaborated with other people using haskell?
07:27:35 <eu-prleu-peupeu> and python has lots of modules already built
07:28:00 <Cale> eu-prleu-peupeu: Mostly because Haskell is a rather different language from the ones people most commonly learn first.
07:28:01 <glen_quagmire> if you did, did you use UML?
07:28:03 <eu-prleu-peupeu> glen_quagmire: in my university there is only one guy writing haskell, and like me, he is a student...
07:28:29 <eu-prleu-peupeu> glen_quagmire: i did use UML quite some times
07:28:31 <Cale> eu-prleu-peupeu: In some places in Europe and Australia, it's a pretty common teaching language.
07:28:51 <glen_quagmire> in OOP, don't pepole use UML to communicate and separate task?
07:29:04 <wy> Saizan: Indeed they are similar. Maybe I can find how to define map there
07:29:05 <phobes> Some people
07:29:05 <glen_quagmire> i'm not sure how collaboration applies to functional programming
07:29:30 <JFT> glen_quagmire: You can use UML to do Analysis AND Design
07:29:40 <eu-prleu-peupeu> well here the functional world is mostly dominated by scheme, lisp
07:30:13 <luqui> haskell is reasonably different from those, too...
07:30:20 <Saizan> wy: yeah, they define an hMap, but the way to call it is a bit cumbersome
07:30:32 <JFT> glen_quagmire: You can very well analyse a problem in an OO manner then design a solution using either OO or something else
07:30:55 <eu-prleu-peupeu> hmm well one thing i dislike in haskell when compared to ocaml is the console... the haskell console is not that good for continuous development
07:30:57 <JFT> glen_quagmire: Analysis => Detailed Specification through better understanding of the problem
07:31:01 <wy> Saizan: sure. this way of defining lists is not convenient
07:31:03 <eu-prleu-peupeu> it probably wasn't designed for that
07:31:36 <glen_quagmire> i see
07:31:41 <JFT> eu-prleu-peupeu: True, :r is your friend ;)
07:32:34 <JFT> glen_quagmire: UML can be useful when designing/thinking about Type Class in Haskell
07:32:46 <JFT> glen_quagmire: But I think good old DFD are more useful
07:32:54 <eu-prleu-peupeu> now i find myself with three problems: 1. migrate some bash scripts, and 2. parse huge files of ansi C code, and rewrite them in some functions, 3. write a GUI for some tools to ease development in certain areas...
07:32:56 <JFT> glen_quagmire: For FP in general
07:33:04 <luqui> DFD?
07:33:07 <eu-prleu-peupeu> and i want to use ONE high level language for all of them
07:33:13 <JFT> luqui: Data Flow Diagram
07:33:26 <phobes> wy:  What does this get you?  I don't see how, if you managed to build a heterogenous list in Haskell, you could do something useful with it (unless you start adding operations to those type classes, but then how is this different from just using an existential type?)  What am I missing?
07:33:33 <eu-prleu-peupeu> and i was undecided between python and haskell
07:34:34 <eu-prleu-peupeu> JFT: what is :r ?
07:34:38 <roconnor> eu-prleu-peupeu: haskell currently sucks for making GUIs
07:34:41 <JFT> eu-prleu-peupeu: I love Haskell but for "script oriented tasks" I'd stick with Python/Ruby
07:34:52 <luqui> phobes, wy, there may be some misconception about the ability to downcast in haskell (or lack thereof)
07:34:52 <JFT> eu-prleu-peupeu: it reloads the last file you loaded in ghci or hugs
07:35:12 <eu-prleu-peupeu> ah
07:35:13 <roconnor> eu-prleu-peupeu: but then again maybe everything sucks for making GUIs :P
07:35:14 <eu-prleu-peupeu> nice
07:35:16 <wy> luqui: What does downcast mean?
07:35:23 <phobes> luqui:  You're saying you can downcast?
07:35:45 <luqui> wy, well, in haskell's context, take determine whether an object is of a given type
07:35:46 <eu-prleu-peupeu> roconnor: ocaml sucks, lisp sucks even more :( the last and final option is to writen the gui in C
07:35:49 <roconnor> eu-prleu-peupeu: perhaps Gtk2hs makes writing gui's in haskell as easy as in other languages.
07:36:02 <oal`> meh
07:36:06 <oal`> tcl/tk
07:36:06 <luqui> wy, which is sortof maybe possible using Dynamic..., but not natural
07:36:11 <JFT> eu-prleu-peupeu: why not use qt or tcl/tk?
07:36:11 <phobes> luqui:  You need to build the ability to downcast somewhere in the type though
07:36:12 <roconnor> eu-prleu-peupeu: which is still too hard in my (uneducated) opinion.
07:36:24 <Saizan> phobes: a simple example is tables from a database, each record is an heterogenous collection, and the presence of select/join/etc.. means that you can't use a fixed product type for it
07:36:34 <wy> luqui: You mean as in (Show a) => ... ?
07:36:36 <roconnor> Tk!!
07:36:38 <|Lupin|> Oleg's writing are doubtlessly very nice, but they don't look very introductory to me... even after the reading of the first article :/
07:36:44 <luqui> phobes, right.  Basically, a variadic list in haskell gets you a lot less than in, say, C#...
07:37:08 <faxathisia> |Lupin|: This is good too http://jaortega.wordpress.com/2006/02/12/continuation-kata/
07:37:09 <eu-prleu-peupeu> JFT: QT is c++ oriented, im more into GTK or in the worst case scenario, doing it in opengl :/
07:37:12 <lambdabot> Title: Continuation kata « programming musings
07:37:16 <phobes> Saizan:  But you can still use normal lists... you just make a type class of what your elements need to support, and then make an existential type that takes something of the right class
07:37:17 <faxathisia> simpler and not about delimited
07:37:26 <faxathisia> dunno if that's useful to you
07:37:33 <Saizan> phobes: that way you lose type information
07:37:39 * earthy laughs out loud at Ian Sommerville... 'Given that recursion is an inherently error-prone construct,...'
07:37:52 <roconnor> earthy: link?
07:38:08 <eu-prleu-peupeu> for the bash scripts i have to decide until next friday, but for the gui i have until april to make my mind, so still have some time to ponder well
07:38:18 <earthy> roconnor: Ian Sommerville, "Software Engineering", 6th ed., p. 415, exercise 18.2
07:38:20 <phobes> Saizan:  So what I'm saying is I don't see how you're going to get more type information than that back... maybe you can I'm just asking for how you do it
07:38:27 <roconnor> earthy: :/
07:38:38 <JFT> eu-prleu-peupeu: how "advance" is the GUI you required?
07:38:41 <Saizan> phobes: then read the paper :)
07:38:43 <earthy> ISBN 0-201-39815-X
07:38:46 <phobes> ah, I missed the link
07:38:50 <phobes> will do
07:38:51 <phobes>  :)
07:38:56 <JFT> eu-prleu-peupeu: just a front-ent to the scripts?
07:39:04 <roconnor> earthy: URN:ISBN:0-201-39815-X
07:39:08 <|Lupin|> faxathisia: will give it a try, thanks a lot !
07:39:23 <earthy> roconnor: yah, but that's not close enough. :)
07:39:34 <earthy> the book is like 700 pages thick
07:39:37 <roconnor> :)
07:39:44 <earthy> (and I'm doing a manual diff between 6th and 8th editions...)
07:40:31 <eu-prleu-peupeu> JFT no
07:41:02 <faxathisia> :S
07:41:12 <pejo> earthy, teaching from that book, or curious in general about the differences between those editions?
07:41:31 <faxathisia> Does anyone know some haskell code that does interesting program transformation, and isn't a complete mess?
07:41:39 <earthy> actually, I'm updating the material to go with the Open University course that is based on the book
07:41:44 <eu-prleu-peupeu> the gui has to support a openGL context, to draw some meshes, and generate a dll or a .so for several math functions on those meshes
07:41:54 <earthy> and this material is intended to make the book palatable for self-study
07:42:14 <earthy> fortunately, Sommerville has seen the light. a bit.
07:42:19 <pejo> faxathisia, yhc? supero?
07:42:40 <earthy> the question has been dropped in 7th and 8th editions. :)
07:42:43 <JFT> eu-prleu-peupeu: I wouldn't use Haskell to do such a GUI...
07:42:45 <hpaste>  luqui pasted "Layout-free haskell error" at http://hpaste.org/4793
07:42:46 <faxathisia> cool cheers
07:43:09 <faxathisia> luqui: let .. in
07:43:12 <eu-prleu-peupeu> JFT: what do you advice ?
07:43:16 <faxathisia> without a ;
07:43:24 <eu-prleu-peupeu> JFT: python ?
07:43:26 <luqui> faxathisia, that's necessary when not using layout?
07:43:35 <luqui> strip the {}s and ;s and it compiles
07:43:57 <JFT> eu-prleu-peupeu: On Linux I'm not sure, I tend to do GUI with Cocoa then backend in anything I see fit
07:44:25 <oerjan> luqui: the let is not closed by the next line
07:44:27 <JFT> eu-prleu-peupeu: Probably Python/Ruby for Linux
07:44:38 <oerjan> because the outside block has layout disabled
07:44:38 <eu-prleu-peupeu> hmm, i see
07:44:39 <JFT> eu-prleu-peupeu: but again depending on the GUI toolkit you choose
07:44:53 <oerjan> so you need to disable layout for the let too
07:44:57 <eu-prleu-peupeu> GTK with openGL context
07:45:23 <eu-prleu-peupeu> thats the toolkit ill use, its ugly, but it works cross-platform, and the code is not that bad (compared to wxwidgets)
07:45:32 <oerjan> oh wait that is weird.
07:45:43 <pejo> faxathisia, you have the commentary for ghc somewhere as well - and it's fairly well written so you should be able to find some transformation inside ghc if you want to.
07:45:56 <hpaste>  luqui annotated "Layout-free haskell error" with "there we go.  how annoying.  I guess I'll just use "in" :-/" at http://hpaste.org/4793#a1
07:47:49 <JFT> luqui: dumb question but why do you want to use Layout-free?
07:49:19 <oerjan> oh no it's correct anyhow.  because the ; does not close the let; the next line _does_ close the inner block but then misses the explicit semicolon
07:49:46 <oerjan> luqui: i think you actually can just move the final semicolon
07:50:06 <oerjan> make it indented less than the x
07:51:45 <phobes> saizan:  Ah, I see ... like the HOccursMany example using overlapping instances
07:51:49 <phobes> yuck! :)
07:51:53 <hpaste>  oerjan annotated "Layout-free haskell error" with "this might work?" at http://hpaste.org/4793#a2
07:54:17 <phobes> saizan:  But it was an interesting paper - thanks for the link
07:54:27 <Saizan> phobes: yes, for example :) and you can implement a typed and fairly advanced object system with the polymorphic extensible records. like in the OOHaskell paper
07:55:42 <phobes> Using typeclasses with overlapping instances to do essentially branching on types in computations seems really clunky to me
07:56:08 <|Lupin|> faxathisia: the continuation kata page is great, thanks !
07:56:52 <phobes> It feels dirty like C++ template programming
07:57:13 <luqui> oerjan, that worked
07:57:23 <luqui> oerjan, man, that really encourages the prefix-punctuation style
07:57:41 <oerjan> heh
07:59:40 <faxathisia> It would be nice if haskell just ignored any "..." at the very start of a line
08:00:19 <oerjan> faxathisia: strings you mean?
08:00:51 * faxathisia wants to put ellipses down
08:01:31 <Saizan> phobes: i don't see a way in which typeclasees don't branch on types, they are still ad-hoc polymorphism
08:02:26 <matthew-_> DRMacIver: how's the fire burning then? ;-)
08:02:35 <DRMacIver> Hm?
08:02:40 <matthew-_> your scala thread
08:02:46 <DRMacIver> The post seems to have gone down fairly well actually.
08:02:59 <DRMacIver> At least with people whose opinions actually interest me (i.e. not random idiots on reddit :) )
08:03:01 <matthew-_> yeah, certainly having martin interested is a good thing
08:03:19 <matthew-_> (I'm on the scala mailing list too)
08:03:20 <phobes> Saizan:  They do - my point is that to do something like   (in ad-hoc notation) filter (\x -> type x == Int) list ... you end up writing a page and half of code :)
08:03:37 <DRMacIver> matthew-_: Any particular reason you're not in #scala ? :)
08:03:51 <matthew-_> well, um, I prefer #haskell
08:03:59 <guenni> :)
08:04:13 <matthew-_> and I prefer not to mix my functional and OO nicks
08:04:17 <DRMacIver> Revolutionary concept: Multiple IRC channels!
08:04:19 <DRMacIver> Heh
08:04:21 <DRMacIver> Ok. :)
08:04:40 <phobes> The OO guys get to see the last name
08:04:49 <Saizan> phobes: yeah the encoding can be verbose :)
08:05:13 <matthew-_> DRMacIver: whilst my Haskell knowledge may be rudimentary, my scala knowledge is non-existant
08:05:22 <DRMacIver> Heh. Fair enough.
08:05:28 <DRMacIver> I'm about equally bad at both. :)
08:06:02 <DRMacIver> (Maybe a little better at Scala purely due to relative amounts I've written recently)
08:07:47 <hpaste>  dikini pasted "any ideas on keeping this readable, but reducing the traversals" at http://hpaste.org/4795
08:10:13 <dikini> I'm thinking of rewriting it using arrows or applicative functors, but would welcome any pointers
08:10:49 <matthew-_> right, can someone please replace xorg with something written in Haskell?
08:10:52 <Saizan> i don't see a way if p has that type
08:11:00 <matthew-_> I'm fed up of this memory-leaking piece of c***
08:11:42 <mrd> standalone xmonad
08:11:52 <matthew-_> no, I don't like xmonad
08:12:04 <matthew-_> sorry, but I'm a die-hard ratpoison user
08:12:09 <mrd> heh
08:12:15 <mrd> they have similar goals
08:12:18 <Saizan> standalone xmonad?
08:12:19 * mrd has ratpoison on his work machine
08:12:31 <Leimy> ratpoison used to be pretty fun
08:12:33 <byorgey> dikini: why does p have to be a predicate on the transformer f as well as the state?
08:12:39 <matthew-_> as far as I'm concerned, I should be in charge of what windows are visible and where they are. Not some algorithm
08:12:42 * faxathisia is irritated to be writing code without knowing for sure if it works
08:12:51 <cjb> matthew-_: xmonad is not for you :)
08:13:01 <byorgey> dikini: there's probably a good reason, it just seems rather roundabout to me at first glance.
08:13:04 <matthew-_> cjb: this is my conclusion too ;)
08:13:14 <faxathisia> "Not some algorithm" hehe
08:13:15 <dikini> byorgey: the 'default' predicate is (f x) == x
08:13:20 <mrd> well you're even more hardcore than me, because I let ratpoison take care of windows too
08:13:48 <dikini> byorgey: but I'm want to allow for composing predicates
08:13:51 <matthew-_> mrd: but surely you have frames set up and then a set of windows that you put into those frames?
08:14:12 <mrd> no i'm usually happy just splitting the screen up into a few xterms
08:14:27 <matthew-_> ok, so you have every application always visible?
08:14:42 <dikini> It probably is sufficient to have f x passed as a prameter
08:14:45 <mrd> generally
08:14:48 <byorgey> dikini: anyway, it actually looks pretty readable to me.
08:15:03 <Saizan> dikini: you could just make it a -> a -> Bool then, so you can share the fmap f s with the recursive branck
08:15:09 <matthew-_> fair enough then. I'm tempted to take the xmonad bindings to xorg/xlib and rewrite ratpoison in haskell...
08:15:14 <faxathisia> My function definition starts out at 80 columns :(
08:15:42 <faxathisia> I keep findin that I use lots of horizontal space
08:15:54 <mrd> there's lots of contribs.  might make a good learning project if you're looking for that.
08:16:51 <mrd> by that i mean adding the desired behavior to xmonad
08:16:53 <dikini> byorgey: I'm writing a small toolkit to compare different 'evolutionary' optimisation techniques - ga, pso, differential evolution, etc...
08:17:08 <byorgey> dikini: cool
08:17:43 <blarz> holy moly... building ghc sure takes a while
08:18:01 <byorgey> matthew-_: the xorg/xlib bindings are not specific to xmonad, it's just a standalone X11 package
08:18:08 <byorgey> blarz: =)
08:18:10 <dikini> byorgey: and this is essentially 'the main loop', that's why i'm trying for it to be as flexible as possible
08:22:37 <faxathisia> @hoogle (Monad m) => (a -> m [b]) -> [a] -> m [b]
08:22:38 <lambdabot> No matches, try a more general search
08:22:45 <faxathisia> no concatMapM :(
08:23:10 <oerjan> er @hoogle doesn't do higher-kind types
08:24:27 <|Lupin|> bye all
08:24:30 <|Lupin|> thanks for helping
08:26:19 <oerjan> :t \f -> liftM concat . map (>>= f)
08:26:21 <lambdabot> forall a a1. (a1 -> [[a]]) -> [[a1]] -> [[a]]
08:26:29 <oerjan> eek
08:26:41 <oerjan> oh no
08:26:47 <phobes> :t \f -> liftM flatten . map (>>= f)
08:26:47 <lambdabot>     No instance for (Monad Tree)
08:26:47 <lambdabot>       arising from use of `>>=' at <interactive>:1:26-32
08:26:47 <lambdabot>     Possible fix: add an instance declaration for (Monad Tree)
08:26:57 <|Jedai|> :t sequence . concatMap
08:26:57 <oerjan> :t \f -> liftM concat . map f
08:26:57 <lambdabot>     Couldn't match expected type `[m a]'
08:26:58 <lambdabot>            against inferred type `[a1] -> [b]'
08:26:58 <lambdabot>     In the second argument of `(.)', namely `concatMap'
08:26:58 <lambdabot> forall a a1. (a1 -> [[a]]) -> [a1] -> [[a]]
08:27:32 <oerjan> :t \f -> liftM concat . mapM f
08:27:33 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
08:27:38 <oerjan> ah
08:28:41 <byorgey> :t \f -> concat <$> mapM f
08:28:42 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
08:28:47 <phobes> :t concatM
08:28:48 <lambdabot> Not in scope: `concatM'
08:29:07 <phobes> :t concat
08:29:07 <lambdabot> forall a. [[a]] -> [a]
08:29:10 * luqui wonders what concatM would do...
08:29:12 <phobes> :t flatten
08:29:13 <lambdabot> forall a. Tree a -> [a]
08:29:17 <byorgey> :t concat
08:29:17 <lambdabot> forall a. [[a]] -> [a]
08:29:42 <byorgey> concatM would just be [[a]] -> m [a].  not very useful =)
08:30:20 <phobes> :t mapM
08:30:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:30:26 <phobes> :t liftM . map
08:30:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m [a] -> m [b]
08:30:35 <phobes> :t liftM map
08:30:35 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m ([a] -> [b])
08:31:31 <oerjan> :t (concat <$>). mapM
08:31:31 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
08:31:44 <byorgey> for homework, write a detailed 3-5 page explanation of the differences between those three expressions, with examples of use for each =)
08:32:16 <byorgey> :t ((concat <$>).) . mapM
08:32:16 <lambdabot> forall a a1 (m :: * -> *). (Functor m, Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
08:32:55 <byorgey> not really an improvement... =)
08:37:48 <phobes> Why did I think 'flatten' was the standard term for what Haskell calls 'concat'?
08:38:09 <phobes> Do other languages do it that way?  or am I just having a brain-short?
08:38:26 <faxathisia> I don't know any language which has a flatten function built in
08:39:48 <idnar> I think it is a fairly common term in usage
08:40:01 <idnar> er, pretend my last sentence was proper English
08:40:06 <mattam> phobes: OCaml's List.flatten
08:40:31 <mattam> Maybe other ML's too
08:40:47 <phobes> Ya, scala too I see
08:41:01 <phobes> I think alot of the literature on Monads refers to 'flatten' for the list monad as well
08:45:16 <shachaf> Ruby has flattn (which is not quite concat).
08:45:26 <shachaf> s/n/en/
08:46:34 <b_jonas> I always missed concat from ruby
08:46:43 <b_jonas> it's not quite trivial to write it
08:47:07 <b_jonas> though it's not difficult either
08:47:17 <byorgey> phobes: perhaps part of the difference is that in languages with dynamic typing, you can have expressions like [1,2,[3,[4]],5]
08:47:30 <byorgey> and "flatten" usually refers to turning that into [1,2,3,4,5]
08:47:53 <byorgey> whereas in Haskell that can only be well-typed if you put it in some sort of tree structure
08:47:57 <b_jonas> it's a pity how most progamming langs have some important function missing from their list libraries
08:48:00 <phobes> byorgey:  I don't think that's what it means in scala
08:48:00 <byorgey> which is why there is a "flatten" function in Data.Tree.
08:48:03 <oerjan> so flatten = toList :)
08:48:05 <shachaf> b_jonas: .inject([]) {|s,n| s + n }?
08:48:16 <shachaf> b_jonas: (Which isn't the most efficient way of doing it, of course.)
08:48:17 <b_jonas> though haskell and standard ml seem to have the complete set
08:48:17 <phobes> it makes sense to me though
08:48:19 <byorgey> phobes: perhaps, I don't know Scala.
08:48:22 <b_jonas> shachaf: no, that's the wrong one
08:48:40 <b_jonas> it has O(n^2) performance in the worst case, for it has to copy the whole array
08:49:11 <b_jonas> most likely you want to use the Array#concat method which destructively appends a list to another list
08:49:31 <b_jonas> (as ruby arrays are resizable)
08:52:03 <Saizan> hey, who wants to implement erlang as an haskell library?
08:52:28 <mrd> an haskell?
08:53:13 <Saizan> yes?
08:53:35 <dons> what part of erlang?
08:53:36 <mrd> do you mean the distributed part?
08:53:43 <mrd> heh, dons is a step ahead of me
08:53:47 <dons> or the bad syntax? :)
08:53:48 <matthew-_> Saizan: that's kinda my PhD
08:53:54 <mrd> or the lack of typing?
08:54:05 <matthew-_> Saizan: just wait a bit...
08:54:26 <matthew-_> ahh, dons is awake! Did you receive my patch to nano-md5 ?
08:54:39 <Saizan> the "processes exchanging messages potentially over the network" part, preferrably more typed
08:54:55 <matthew-_> Saizan: the more typed bit is certainly the interesting part
08:55:02 <mrd> you could use Chans/TChans for the message part locally.  over the network is more interesting
08:55:28 <matthew-_> mrd: that would restrict the values exchanged too much
08:55:30 <dons> matthew-_: i did, i'll be applying it.
08:55:38 <dons> if you want to fill out more of the openssl binding, go for it :)
08:55:56 <matthew-_> dons: fab. Although it rather means that calling it nano-md5 is a little bit confusing
08:56:00 <mrd> matthew-_: Chans?
08:56:21 <dons> matthew-_: ah well.
08:56:21 <phobes> How do you serialize arbitrary values in Haskell?
08:56:30 <dons> phobes: using Show/Read or Data.Binary
08:56:35 <mrd> write a Binary instance
08:56:43 <shachaf> dons: When is lambdabot going to run under GHC 6.8?
08:56:44 <dikini> Saizan: http://nowonder.foldr.org:8080/roller/page/vs?entry=erlang_style_distributed_haskell
08:56:46 <lambdabot> http://tinyurl.com/2d7pos
08:56:49 <matthew-_> mrd: a Chan can only carry values of one type
08:56:52 <dikini> is along those lines
08:57:04 <dons> shachaf: it does mostly, just not on openbsd, so i've not been able to finish the update
08:57:04 <mrd> matthew-_: they're polymorphic
08:57:11 <matthew-_> mrd: indeed.
08:57:12 <mrd> matthew-_: (parametric)
08:57:40 <matthew-_> mrd: but that still doesn't help enough.
08:57:44 <Saizan> matthew-_: i envisaged something like an Chan of hlist or and hlist of chans..
08:57:59 <matthew-_> yeah, you really want session types
08:58:00 <mrd> matthew-_: I don't see what the difference is between that and homogenous lists
08:58:18 <matthew-_> and then you have a plan as to what types of values are going to appear when in the chan
08:58:25 <larmeh> hi there
08:58:30 <matthew-_> which means you can do nice pattern matching at the receiving end and so forth
08:58:31 <phobes> How are functions encoded by show and by Data.Binary?
08:58:37 <mrd> matthew-_: create a sum type if you have more than one thing. then you can pattern match.
08:58:42 <matthew-_> phobes: with difficulty!
08:58:46 <byorgey> hi larmeh
08:59:05 <matthew-_> mrd: yeah, just account for the possibility of receiving EVERYTHING all the time
08:59:15 <mrd> matthew-_: but ... that defeats the point of typing
08:59:17 <phobes> matthew-_ :  Does the encoding assume another running version of the program with the same base source?
08:59:24 <dikini> matthew-_: is there such a big need for dynamically typed channels?
08:59:24 <matthew-_> exactly
08:59:29 <larmeh> can anyone explain to me what this line of code does? "any p (h:t) = p h || any p t"
08:59:32 <mrd> in erlang it's the case because of no typing.  i'd hope to improve on that.
08:59:46 <matthew-_> no no, I'm not talking about dynamic typing of the channels
08:59:48 <mrd> I guess there's always Chan Dynamic =)
08:59:55 <matthew-_> I'm saying that we can do MUCH better than sum types
09:00:03 <mrd> oh sure
09:00:19 <matthew-_> phobes: hang on, what are you talking about?!
09:01:05 <byorgey> larmeh: that is defining a function called 'any', which takes two parameters.
09:01:08 <phobes> matthew-_ :  Basically are functions passed by sending an encoding of the entire function or is there a protocol for referencing some base set of functions?
09:01:17 <dikini> the biggest problem is improving the security, compared to erlang, the rest is not hard
09:01:20 <byorgey> larmeh: the second parameter must be a list with head 'h' and tail 't'.
09:01:29 <matthew-_> phobes: when I said "with difficulty", I meant, it can't be done.
09:01:40 <phobes> matthew_- :  Heh
09:01:52 <mrd> it can be done -- if you have access to an oracle
09:01:57 <phobes> I did originally ask for how to serialize "an arbitrary value"
09:02:07 <byorgey> larmeh: the result of applying 'any' to some p and a list (h:t) is the boolean OR of applying p to h, and recursively calling any p on the tail of the list.
09:02:14 <phobes> It can be done if you pick a protocol that allows transfering source
09:02:17 <oerjan> @remember matthew-_ when I said "with difficulty", I meant, it can't be done.
09:02:18 <lambdabot> I will remember.
09:02:29 <phobes> Or you can agree that both programs know about the source and send only the closures
09:02:33 <byorgey> larmeh: in other words, it computes whether the predicate p is true for any of the list elements.
09:02:54 <byorgey> larmeh: does that make sense?  anything you are still confused about?
09:03:15 <larmeh> byorgey: i think this really helped, thanks alot.
09:03:21 <byorgey> larmeh: sure
09:03:22 <Philippa> phobes: that's arguably not totally arbitrary
09:03:23 <olsner> "it can't be done"!? someone hasn't read the @faq ;-)
09:03:49 <Philippa> I remember talking to beelsebob about it in the context of YHC's bytecode a couple of years back though
09:03:50 <mrd> @faq can haskell decide extensional equality?
09:03:50 <lambdabot> The answer is: Yes! Haskell can do that.
09:04:08 <matthew-_> @faq can haskell solve global warming?
09:04:08 <lambdabot> The answer is: Yes! Haskell can do that.
09:04:13 <matthew-_> rightyho.
09:04:36 <matthew-_> @faq can C solve global warming?
09:04:36 <lambdabot> The answer is: Yes! Haskell can do that.
09:04:37 <phobes> Philippa:  Not arbitrary because you want to assume that code can be dynamically compiled at runtime?
09:04:41 <mrd> @faq can haskell destroy all life as we know it?
09:04:41 <lambdabot> The answer is: Yes! Haskell can do that.
09:04:49 <mrd> hmm, haskell is a WMD
09:04:52 <phobes> which, dons' library lets you do that, right?
09:04:59 <Saizan> matthew-_: anything you'd suggest to read on session types?
09:05:08 <byorgey> grr, why isn't parsec's ParseError an instance of Error? =(
09:05:27 <matthew-_> Saizan: wouldn't it by nice to reel off a list of papers I'd had published by now at this point? ;)
09:05:57 <Philippa> phobes: amongst other things, yeah
09:06:18 <Philippa> or otherwise obtained from outside sources - taking it from the IO monad is good enough
09:06:31 <phobes> Philippa:  In which case there's still a way to do it - you just have to now have a protocol for transfering the new code too
09:06:56 <matthew-_> Saizan: There's a paper by Thiemann on Session types in Haskell which is sorta worth reading.
09:07:12 <phobes> matthew-_:  So you're trying to type protocols basically?
09:07:21 <matthew-_> Saizan: don't read any of the OO papers on Session Types. Read the ones by Simon Gay and others from Glasgow
09:07:36 <matthew-_> phobes: yes, and in particular, deadlock analysis
09:07:47 <matthew-_> which gets quite hairy.
09:07:50 <phobes> matthew-_:  oh, interesting... ya I'd imagine
09:08:00 <matthew-_> and as with all static analysis, is conservative
09:08:11 <fadec> Getting familiar with HaXml. Am I doing things the stupid way? I have stuff like this (rootElement d = e in Document _ _ e _). I couldn't find any selectors like this in the lib. Is this the "haskell way"?
09:08:15 <Philippa> phobes: that may just involve translating between two completely different platforms. Are you going to do this for IO computations too?
09:08:54 <matthew-_> quite. Please serialise and send over the network these openGL calls...
09:09:04 <phobes> Philippa:  You could - in practice I suppose it could involve agreeing upon a VM up front
09:09:09 <Philippa> I was thinking of code for the PS2's vector units myself
09:09:25 <Philippa> which isn't working on multiple platforms, it's declaring a new one
09:10:01 <Philippa> (including the stuff that has VU1 send data out to the GS)
09:10:28 <phobes> If every implementation has to support the VM then it is cross platform, right?
09:10:50 <Philippa> not so cross platform that I can run it on my watch though
09:10:57 <matthew-_> Saizan: in general, avoid papers by Nobuku Yoshida - they're pretty much incomprehensible.
09:11:08 <phobes> Or on your toaster, but I think you're setting the bar a little high here...
09:11:45 <Philippa> it's just a platform that can be implemented on top of other platforms. It's not cross-platform the way C can be
09:11:47 <phobes> My point is just that there is a solution that works for reasonable meanings of "every value is serializable"
09:12:04 <Philippa> but not for meanings equivalent to, say, Haskell's current meaning of 'value'
09:12:05 <phobes> And C isn't cross-platform the way it can be
09:12:08 <matthew-_> dons: that md5 (1) command that you were using in the quickcheck stuff - is that part of the openssl utils?
09:12:22 <matthew-_> dons: I couldn't find it anywhere, hence the switch to md5sum
09:13:02 <phobes> Philippa:  I'd imagine it would work for Haskell's current definition of value ... if Haskell has such a definition
09:13:11 <hpaste>  stefanha pasted "Why does this produce "ambiguous type variable"?" at http://hpaste.org/4796
09:13:26 <phobes> I'll need a reference if you want me to believe Haskell's definition references your watch :)
09:13:26 <Philippa> you can write platform-specific code in the IO monad and those computations are values
09:13:28 <Philippa> so no, it wouldn't
09:14:20 <Philippa> all you need is the IO monad and the FFI
09:14:37 <phobes> The FFI would be a bigger problem to standardize :)
09:15:17 <Philippa> even file IO has assumptions baked into it
09:16:00 <Saizan> matthew-_: ok, thanks :) http://citeseer.ist.psu.edu/658381.html <-- is this the one by Thiemann you were referring to?
09:16:00 <lambdabot> Title: An Implementation of Session Types - Neubauer, Thiemann (ResearchIndex)
09:16:10 <matthew-_> yeah that's the one
09:16:23 <phobes> Philippa:  ok well, sending over an open file handle is probably going overboard
09:16:43 <matthew-_> Saizan: there are some issues with their work and I ultimately want something vastly more flexible...
09:16:59 <byorgey> is it possible to hide a particular type class instance when importing a module?
09:17:10 <phobes> But note that an open file handle isn't actually a Haskell value iether
09:17:13 <matthew-_> ok, how about reading from /dev/random - serialize that and send it across.
09:17:16 <mrd> byorgey: no
09:17:34 <byorgey> mrd: well, that sucks =P
09:17:39 <Philippa> perhaps, but there are certainly haskell values that're handles for the handles
09:17:55 <mrd> byorgey: in fact you can do import Module () to get just the instances
09:18:06 <phobes> I don't know - I have to leave :)
09:18:06 <mrd> byorgey: yes, type classes and instances are all kinds of broken :/
09:18:17 <byorgey> mrd: ah, right
09:19:00 <phobes> Maybe saying "every value" is pushing it too far, but you can certainly go a long way... (though I'm actually not even sure it's a good idea, so I'll stop arguing :)
09:19:04 <byorgey> ParseError isn't an instance of Error, so I can't use the result of Parsec.parse (Either ParseError a) as a monad.
09:19:15 <malcolmw> fadec: that seems reasonable - you are right, there are no selectors defined for the HaXml datatypes, but then it is old code (getting on for 9 years old)
09:19:19 <phobes> Philippa:  Good arguing with you again :)
09:19:24 <phobes> later
09:19:34 <byorgey> So I have to either define my own instance of Error for Either that ignores fail (which would require hiding the instance from the Prelude)
09:19:49 <byorgey> OR make ParseError an instance of Error, which is difficult since the constructor isn't exported. =P
09:20:40 <byorgey> but it seems like I'll just have to forgo parse x >>= foo and do some manual pattern-matching.  bleh.
09:20:57 <mrd> yea i had some ugly few lines for pulling out the errors, somewhere
09:21:51 <dons> matthew-_: i think md5sum is called md5 on openbsd
09:22:16 <matthew-_> dons: oh right. ok, that should probably be abstracted then so that it searches for either...
09:23:06 <hpaste>  mrd pasted "ugly few lines of code" at http://hpaste.org/4797
09:31:34 <byorgey> mrd: yeah, that works.  I've decided that I don't really care about parse errors for now, so I'm first doing eitherToMaybe and then using the Maybe monad.
10:03:36 <oerjan> byorgey: strMsg s = newErrorMessage (Message s) someDummyPosition
10:04:16 <byorgey> oerjan: aha, I didn't know about the newErrorMessage function
10:04:34 <byorgey> @karma+ oerjan
10:04:34 <lambdabot> oerjan's karma raised to 17.
10:05:20 <byorgey> well, I'm done working on my untyped lambda calculus interpreter for today, but I'll use that tomorrow =)
10:05:34 <oerjan> and newErrorUnknown seems appropriate for noMsg
10:06:21 <byorgey> indeed
10:07:03 <therp> OT: what's the difference between an uncountable cardinal and a presumably countable one?
10:07:31 <oerjan> a countable cardinal is one that is less than or equal to that of the set of natural numbers
10:08:24 <therp> and an uncountable? "bigger" than that?
10:08:38 <oerjan> which is the same as saying you can count the elements with natural numbers
10:08:42 <oerjan> yep
10:09:10 <therp> hm thanks
10:12:04 <therp> so the set of sets I construct with an uncountable cardinal is bigger than the set of sets I can construct with only countable cardinals. Is there something more general than that? sets with a cardinality that isn't uncountable?
10:12:44 <faxathisia> therp: You must read Cantors stuff, it is the best
10:13:14 <therp> I'm just wondering because, this term rewriting book uses the "uncountable" term only once and never mentions it again... so it might not be that important
10:13:19 <oerjan> uncountable is everything larger than countable, but there is an infinite hierarchy of them...
10:13:32 <oerjan> even uncountably infinite :)
10:13:50 <therp> faxathisia: I was afraid of an answer like that :), but yes for sure interesting
10:14:34 <pejo> therp, you get pretty far in this field with only countable infinites.
10:14:49 <faxathisia> therp: Or don't....
10:14:51 <oerjan> everything computable is countable, for sure
10:16:18 * oerjan waits for someone to bring up the inevitable subtle counterexample
10:16:19 <therp> this proposition uses the uncountable cardinal to describe the generating set of a free algebra in a variety of equations.
10:16:56 <faxathisia> oerjan: I can't think of a counterexample
10:17:09 <faxathisia> (since there's countable programs..?)
10:17:11 <oerjan> neither can i, but on this channel it's inevitable someone will :)
10:17:16 <faxathisia> Oh right hehe
10:17:23 * therp smiles :)
10:23:08 <byorgey> well, adjoint co-co-monoidical elliptic transforms are computable but uncountable.
10:24:03 <EvilRanter> ... i think you just made that up
10:25:34 <byorgey> EvilRanter: who, me?!? never!!
10:27:09 <oerjan> the double co- betrayed you.
10:27:19 <byorgey> hehe =)
10:27:41 <byorgey> oerjan: right, and I am to understand that you would have believed me otherwise?
10:27:50 <chadz> dons: how's the real world haskell book coming?
10:28:14 <oerjan> i uld have...
10:28:39 <oerjan> co-co-uld, that is
10:29:20 <dons> chadz: going well!
10:30:44 <chadz> the blog hasn't been updated in a while. is there anywehre else I could check status?
10:30:52 <chadz> maybe like a darcs repo of the text? :)
10:31:50 * EvilRanter found "-ical" a bit of a giveaway, too
10:33:16 * byorgey makes a mental note to use "strong adjoint comonoidal elliptic second-order transforms" next time
10:33:52 <phobes> Actually I think it's third-order and higher that are uncountable
10:34:52 <Saizan> the second can be reduced to the first with a polynomial factor
10:39:02 <byorgey> hm, good point
10:39:25 <faxathisia> ugh so disappointing.. my code does not work correctly
10:40:12 <chadz> faxathisia: you gotta use more force
10:40:30 <conal> or use the Force more
10:40:33 <chadz> or hpaste.
10:40:44 <faxathisia> wont fit on hpaste :)
10:41:01 * faxathisia goes into stare at code until bugs crawl out mode
10:45:56 <olsner> @ty sortBy
10:45:58 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
10:46:27 <chadz> data Ordering = EQ | LT | GT, or something silly like that
10:46:51 <roconnor> @src Ordering
10:46:51 <lambdabot> data Ordering = LT | EQ | GT
10:47:09 <dmhouse> Has to be in that order to derive the correct Ord instance.
10:47:14 <chadz> mines in alphabetical ordering :)
10:47:20 <roconnor> > [minBound .. maxBound] :: [Ordering]
10:47:21 <lambdabot>  [LT,EQ,GT]
10:47:39 <dmhouse> And Enum instance.
10:47:50 <chadz> > EQ > LT
10:47:50 <lambdabot>  True
10:47:57 <roconnor> > fromEnum EQ
10:47:58 <olsner> @ty sortOn
10:47:58 <lambdabot>  1
10:47:58 <lambdabot> Not in scope: `sortOn'
10:48:01 <roconnor> :(
10:48:04 <mauke> > compare EQ LT
10:48:05 <lambdabot>  GT
10:48:06 <roconnor> fromEnum EQ ought to be 0
10:48:20 <roconnor> ... maybe
10:49:08 <mauke> roconnor: just use mappend
10:49:20 <roconnor> @tpe mappend
10:49:20 <lambdabot> forall a. (Monoid a) => a -> a -> a
10:49:37 <roconnor> EQ `mappend` LT
10:49:41 <roconnor> > EQ `mappend` LT
10:49:41 <lambdabot>  LT
10:49:45 <chadz> @src mappend
10:49:45 <lambdabot> Source not found.
10:49:54 <roconnor> > EQ `mappend` EQ
10:49:55 <lambdabot>  EQ
10:49:58 <roconnor> > EQ `mappend` GT
10:49:58 <lambdabot>  GT
10:50:05 <roconnor> > LT `mappend` LT
10:50:05 <lambdabot>  LT
10:50:08 <roconnor> hmm
10:50:21 <mauke> it's useful for chaining comparisons
10:50:32 <roconnor> mauke: sounds good.
10:50:44 <mauke> like compare (field1 x) (field1 y) `mappend` compare (field2 x) (field2 y)
10:51:03 <EvilRanter> assuming what you wanted for sortOn is what i think you want, i think sortOn f = sortBy (comparing `on` f)
10:51:05 <roconnor> > LT `mappend` GT
10:51:06 <lambdabot>  LT
10:51:11 <roconnor> > GT `mappend` LT
10:51:12 <lambdabot>  GT
10:51:17 <roconnor> ok
10:51:29 <EvilRanter> er, compare, not comparing
10:51:32 <roconnor> @src sortOn
10:51:32 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
10:51:58 <EvilRanter> > sortBy (compare `on` reverse) ["foo bar baz eek ack ook"]
10:51:59 <lambdabot>  ["foo bar baz eek ack ook"]
10:52:06 <EvilRanter> ups
10:52:11 <EvilRanter> > sortBy (compare `on` reverse) $ words "foo bar baz eek ack ook"
10:52:11 <lambdabot>  ["ack","eek","ook","foo","bar","baz"]
10:57:26 <baobab> OT: how do you answer to posts in hpaste.org?
10:57:50 <glguy> annotate
10:57:55 <baobab> thx
10:58:01 <glguy> like the one at the top for a fresh textbox
10:58:10 <glguy> or the one next to a post to use it as a starting point
10:59:28 <hpaste>  baobab annotated "Layout-free haskell error" with "The line feed should be interpreted as {}, check 9.3 in http://www.haskell.org/onlinereport/syntax-i" at http://hpaste.org/4793#a3
11:00:05 <baobab> heh i'm embarassed, everyone can see my errors :D
11:03:38 <ricky_clarkson> How do I get sqrt 500 as an Integer?
11:03:57 <byorgey> > floor . sqrt . fromIntegral $ 500
11:03:58 <lambdabot>  22
11:03:59 <mauke> > floor (sqrt 500)
11:03:59 <lambdabot>  22
11:04:06 <ricky_clarkson> :t floor
11:04:06 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:04:09 <ricky_clarkson> Thanks.
11:04:25 <chadz> maybe he wants ceiling? :)
11:04:37 <ricky_clarkson> I want floor.
11:04:40 <ricky_clarkson> > filter (\x -> 0==length (filter (\y -> mod (x :: Integer) y==0) [2..floor . sqrt x])) [1..]
11:04:40 <lambdabot>  Couldn't match expected type `a -> b'
11:05:47 <byorgey> cototient function?
11:06:26 <byorgey> oh, primes, I see
11:07:30 <chadz>  [2.. (floor  (sqrt (fromIntegral x)))]))
11:07:53 <faxathisia> 2 : [3, 5, ... floor ?] better maybe
11:08:00 <chadz> ?pl \x -> (floor (sqrt (fromIntegral x)))
11:08:00 <lambdabot> floor . sqrt . fromIntegral
11:08:14 <chadz> ?pl \x -> [2 .. (floor (sqrt (fromIntegral x)))]
11:08:14 <lambdabot> enumFromTo 2 . floor . sqrt . fromIntegral
11:08:21 <Apocalisp> I want to turn [3,5] into (\x -)
11:08:22 <faxathisia> :t sqrt
11:08:23 <lambdabot> forall a. (Floating a) => a -> a
11:08:24 <Apocalisp> bah
11:09:26 <Apocalisp> I want to turn [3,5] into (\x -> x `mod` 3 == 0 || x `mod` 5 == 0)
11:09:31 <chadz> > take 10 $ filter (\x -> 0==length (filter (\y -> mod (x :: Integer) y==0) [2.. (floor  (sqrt x))])) [1..]l x)))])) [1..]
11:09:31 <lambdabot> Unbalanced parentheses
11:09:36 <Apocalisp> can I use fold?
11:09:37 <chadz> copy and paste sux
11:09:54 <byorgey> Apocalisp: sure
11:10:13 <faxathisia> any $ map (\y x -> mod x y)) [3,5]
11:10:21 <faxathisia> something like this..
11:10:25 <Apocalisp> any!
11:10:30 <Apocalisp> @src any
11:10:31 <lambdabot> any p =  or . map p
11:10:37 <phobes> baobab:  What's causing the parse error in your pasted example"
11:10:38 <phobes> ?
11:11:01 <chadz> Apocalisp: isn't that fizzbang or whatever?
11:11:20 <Apocalisp> chadz: What do you mean?
11:11:34 <faxathisia> lol
11:11:36 <mauke> fizzbuzz
11:11:36 <chadz> teh ruby example, numbers 3 are fizz, numbers 5 (divisible) are bang
11:11:42 <chadz> ah, that's it
11:11:47 <byorgey> :t any (==0) $ map (flip mod) [3,5]
11:11:48 <lambdabot>     No instance for (Num (a -> a))
11:11:48 <lambdabot>       arising from the literal `0' at <interactive>:1:7
11:11:48 <lambdabot>     Possible fix: add an instance declaration for (Num (a -> a))
11:12:57 <byorgey> :t \x -> any ($x) $ map ((0==) . flip mod) [3,5]
11:12:58 <lambdabot>     Couldn't match expected type `a -> Bool'
11:12:58 <lambdabot>            against inferred type `Bool'
11:12:58 <lambdabot>       Expected type: [a -> Bool]
11:13:22 <byorgey> :t map ((0==) . flip mod) [3,5]
11:13:22 <lambdabot>     No instance for (Num (a -> a))
11:13:22 <lambdabot>       arising from the literal `0' at <interactive>:1:6
11:13:22 <lambdabot>     Possible fix: add an instance declaration for (Num (a -> a))
11:13:46 <faxathisia> :t mod
11:13:48 <lambdabot> forall a. (Integral a) => a -> a -> a
11:14:18 <byorgey> :t \x -> any ($x) $ map (((0==).) . flip mod) [3,5]
11:14:22 <ricky_clarkson> > map (\x -> let buzz=if (x%5==0) then "buzz" else "" in if (x%3==0) then "fizz"++buzz else if (x%5==0) then buzz else x) [1..]
11:14:24 <lambdabot> forall a. (Integral a) => a -> Bool
11:14:24 <lambdabot>   add an instance declaration for (Integral [Char])
11:14:33 <ricky_clarkson> > map (\x -> let buzz=if (x%5==0) then "buzz" else "" in if (x%3==0) then "fizz"++buzz else if (x%5==0) then buzz else show x) [1..]
11:14:37 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17"...
11:14:41 <ricky_clarkson> Fail.
11:14:58 <faxathisia> > (any (==0) $ (flip mod :: Int -> Int -> Int) [3,5]) [1..]
11:14:59 <lambdabot>  Couldn't match expected type `[a]'
11:15:26 <phobes> > map (%3) [1..]
11:15:29 <lambdabot>  [1%3,2%3,1%1,4%3,5%3,2%1,7%3,8%3,3%1,10%3,11%3,4%1,13%3,14%3,5%1,16%3,17%3,6...
11:15:38 <phobes> That's constructing fractions :)
11:16:01 <ricky_clarkson> > map (\x -> let buzz=if (mod x 5==0) then "buzz" else "" in if (mod x 3==0) then "fizz"++buzz else if (mod x 5==0) then buzz else show x) [1..]
11:16:07 <lambdabot>  ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","14...
11:16:17 <ricky_clarkson> It didn't show 15.
11:16:24 <ricky_clarkson> > map (\x -> let buzz=if (mod x 5==0) then "buzz" else "" in if (mod x 3==0) then "fizz"++buzz else if (mod x 5==0) then buzz else show x) [10..]
11:16:27 <lambdabot>  ["buzz","11","fizz","13","14","fizzbuzz","16","17","fizz","19","buzz","fizz"...
11:16:59 <mauke> too long!
11:17:03 <mauke> print"F"x!($_%3).b x!($_%5)||$_ for 1..32
11:17:15 <dons> my eyes are burning
11:17:16 <byorgey> :t \l x -> any (==0) $ map (mod x) l
11:17:21 <lambdabot> forall a. (Integral a) => [a] -> a -> Bool
11:17:26 <byorgey> that's better =)
11:19:22 <faxathisia> What's .b ?
11:20:00 <mauke> . is string concatenation
11:20:01 <phobes> .b is a built-in function that prints "buzz"
11:20:34 <faxathisia> ow... I'm confused
11:20:39 <roconnor> > b
11:20:41 <lambdabot>   Not in scope: `b'
11:20:41 <faxathisia> how does that b become the character b
11:20:50 <dmhouse> > 'b'
11:20:52 <lambdabot>  'b'
11:21:08 <chadz> ?hoogle (a->a->b) -> (a,a) -> (b,b)
11:21:08 <mauke> faxathisia: well, the perl parser has no other interpretation for it, so it assumes it's supposed to be a string
11:21:10 <lambdabot> No matches, try a more general search
11:21:14 <faxathisia> wow :D
11:21:18 <faxathisia> I had never known that
11:21:19 <phobes> lol
11:21:22 <mauke> faxathisia: (you can disable this behavior with 'use strict;')
11:22:57 <chadz> isnt this an arrow function?  (a->a->b) -> (a,a) -> (b,b)
11:23:29 <dmhouse> chadz: how would it work? \f (x, y) -> (f x, f y)?
11:23:31 <desegnis> chadz: Why two bs, are they the same?
11:23:35 <chadz> dmhouse: ya
11:23:51 <dmhouse> chadz: wait, it'd have to be (f x y, f y x) or something.
11:24:01 <dmhouse> chadz: unless you mean (a -> b) -> (a, a) -> (b, b).
11:24:04 <mauke> :t \f (x, y) -> (f x, f y)
11:24:05 <lambdabot> forall t t1. (t -> t1) -> (t, t) -> (t1, t1)
11:24:10 <faxathisia> ?djinn (a->a->b) -> (a,a) -> (b,b)
11:24:10 <lambdabot> f a (b, c) = (a b c, a b c)
11:24:15 <roconnor> @. pl djinn (a->a->b) -> (a,a) -> (b,b)
11:24:15 <lambdabot> f = (`ap` snd) . (. fst) . (ap =<< (liftM2 (,) .))
11:24:29 <dmhouse> ?hoogle (&&&)
11:24:29 <lambdabot> Did you mean: (&&&)
11:24:29 <lambdabot> Prelude.undefined :: a
11:24:29 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
11:24:36 <roconnor> @type (&&&)
11:24:37 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:24:37 <chadz> yes, and djinn just made some arrow function, iirc
11:24:43 <dmhouse> :| Yes, I did mean (&&&). That's what I typed it.
11:24:49 <faxathisia> lol
11:24:51 <mauke> @. pl . djinn type \f (x, y) -> (f x, f y)
11:24:52 <lambdabot> f = (`ap` snd) . (. fst) . (const .) . (ap =<< ((,) .))
11:25:17 <faxathisia> @. type pl . djinn (a -> b) -> (b -> a)
11:25:17 <lambdabot> parse error (possibly incorrect indentation)
11:25:20 <faxathisia> >:[
11:27:10 <Apocalisp> lol @ ricky_clarkson
11:30:35 <Leimy> > :t print
11:30:36 <lambdabot>   parse error on input `:'
11:30:41 <Leimy> doh!
11:30:50 <mrd> :t print
11:30:51 <lambdabot> forall a. (Show a) => a -> IO ()
11:30:54 <Leimy> thanks :-)
11:31:03 <mrd> ?src print
11:31:03 <lambdabot> print x = putStrLn (show x)
11:32:49 <Leimy> :t printf
11:32:49 <lambdabot> forall r. (PrintfType r) => String -> r
11:32:52 <ToRA> @pl const ()
11:32:53 <lambdabot> const
11:33:49 <mauke> @pl a () b
11:33:49 <lambdabot> a b
11:33:51 <mrd> > printf "%d" 1
11:33:52 <lambdabot>  Add a type signature
11:33:55 <mrd> > printf "%d" 1 :: String
11:33:56 <lambdabot>  "1"
11:34:04 <mrd> > printf "%d" 1 :: IO ()
11:34:05 <lambdabot>  <IO ()>
11:34:11 <mauke> @pl () () () ()
11:34:11 <lambdabot> ()
11:34:12 <Leimy> neat
11:34:13 <faxathisia> > (+1) () 2
11:34:13 <lambdabot>  Couldn't match expected type `t -> t1' against inferred type `()'
11:34:17 <faxathisia> wtf :/
11:35:31 <byorgey> what the heck is @pl a () b doing?
11:35:47 <EvilRanter> looks like a glitch in the handling of ()
11:35:56 <faxathisia> > lex "()"
11:35:57 <lambdabot>  [("(",")")]
11:36:00 <byorgey> apparently so
11:36:06 <faxathisia> :t (                )
11:36:07 <mauke> () is clearly nothing with parens around it
11:36:07 <lambdabot> ()
11:36:13 <mrd> :t lex
11:36:14 <lambdabot> String -> [(String, String)]
11:36:17 <mauke> and (foo) simplifies to foo
11:36:23 <byorgey> hehe
11:36:24 <mrd> > lex "1+1+2"
11:36:25 <lambdabot>  [("1","+1+2")]
11:36:36 <sjanssen> pl's parser is pretty silly
11:37:17 <mrd> ?pl \ x -> you x off
11:37:17 <lambdabot> flip you off
11:37:22 <faxathisia> lol
11:37:44 <Leimy> nice
11:38:20 <mrd> ?pl \ x y -> y`mod`x==0
11:38:20 <lambdabot> flip flip 0 . ((==) .) . flip mod
11:38:32 <mrd> > nubBy (flip flip 0 . ((==) .) . flip mod) [2..]
11:38:33 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
11:38:54 <dmwit> EvilRanter: Oh, hey, did you get a facelift?
11:39:06 <EvilRanter> ...
11:39:20 <dmwit> ?pl \x y -> 0==y`mod`x
11:39:20 <lambdabot> ((0 ==) .) . flip mod
11:39:29 <dmwit> shorter
11:39:42 <hpaste>  Apocalisp pasted "Project Euler problem 1, exceedingly verbose" at http://hpaste.org/4798
11:40:06 <byorgey> :t flip flip 0
11:40:08 <lambdabot> forall a b c. (Num b) => (a -> b -> c) -> a -> c
11:40:13 <dmwit> putStrLn . show === print
11:40:15 <faxathisia> Apocalisp: You don't have to make a Main and IO and compile the thing into a binary... just write a function that produces a value and run it in ghci
11:40:21 <jorik808> it is indeed a shame that Haskell's design didn't result in an unambiguous indentation system
11:40:49 <Apocalisp> faxathisia: ghc makes faster code than ghci
11:40:57 <twanvl> there shoud be a standard operator for composition with two arguments:  let f .: g x y = f (g x y)
11:41:11 <Apocalisp> faxathisia: ...and I wanted to see how fast this was.
11:41:27 <dmwit> ?src sum
11:41:27 <lambdabot> sum = foldl (+) 0
11:41:32 <dmwit> mmm
11:41:36 <Philippa> jorik808: yep. The interaction with fixity declarations is subtle and nasty
11:41:56 <Philippa> oh, and damn you for reminding me that I'd like to purchase nepheton (and drumazon) sometime just when I have some income...
11:42:10 <Philippa> (but nothing personal)
11:42:41 <jorik808> :D
11:44:56 <Apocalisp> I'm rather proud of myself for weaseling =<< in there.
11:46:03 <dmwit> Apocalisp: heh
11:46:21 <zeloran> is there an elegant way to get an element in a tupel?
11:46:42 <zeloran> for example if i have ("abc","123") and i want "abc"
11:46:42 <byorgey> zeloran: if it's a two-tuple, you can use fst and snd
11:46:50 <byorgey> > fst ("abc", "123")
11:46:52 <lambdabot>  "abc"
11:46:56 <zeloran> :) thx
11:47:04 <zeloran> i thought this only works for lists
11:47:43 <andun> > fst [1,2,3]
11:47:44 <lambdabot>  Couldn't match expected type `(a, b)' against inferred type `[a1]'
11:47:47 <byorgey> zeloran: fst and snd do not work for lists.
11:47:49 <andun> > head [1,2,3]
11:47:50 <lambdabot>  1
11:48:00 <byorgey> maybe you're thinking of head and tail?
11:48:09 <Apocalisp> > (1,(2,3))
11:48:10 <lambdabot>  (1,(2,3))
11:48:28 <Apocalisp> is (,) associative?
11:48:42 <roconnor> nope
11:48:42 <Apocalisp> ?src (,)
11:48:43 <lambdabot> Source not found. My mind is going. I can feel it.
11:48:48 <roconnor> Apocalisp: it isn't even an operation
11:48:52 <byorgey> Apocalisp: it's a special syntactic form.
11:48:53 <roconnor> @type (,)
11:48:54 <lambdabot> forall a b. a -> b -> (a, b)
11:49:05 <roconnor> @type (+)
11:49:06 <lambdabot> forall a. (Num a) => a -> a -> a
11:49:08 <Apocalisp> oh bovver
11:49:28 <roconnor> for something to be associative it needs to be of the form a -> a -> a ... I think.
11:49:32 <byorgey> so (1,2,3) is not the same thing as (for example) (,) 1 ((,) 2 3)
11:49:33 <mrd> bos: cool bindings
11:49:49 <bos> mrd: thanks
11:49:55 <byorgey> actually, roconnor has a good point =)
11:50:43 <Apocalisp> How can I express a function that takes an n-tuple and yields an n+1-tuple?
11:50:59 <phobes> roconnor:  by definition you mean?
11:51:16 <mauke> Apocalisp: you don't
11:51:27 <Apocalisp> That makes me sad. Why not?
11:51:50 <Apocalisp> You make Apocalisp cry. Apocalisp mad!
11:51:59 <roconnor> @type \op x y z -> (op x (op y z))==(op (op x y) z)
11:52:00 <lambdabot> forall a. (Eq a) => (a -> a -> a) -> a -> a -> a -> Bool
11:52:12 <mauke> because (1,2) and (1,2,3) have different types
11:52:15 <byorgey> Apocalisp: the problem is that you can't give such a function a type.
11:52:16 <mauke> you can't make a function that works with both
11:52:31 <faxathisia> You can make lists whoes length is partof the type can't you?
11:52:51 <mauke> yeah
11:52:56 <roconnor> Apocalisp: typically we use nested pairs for that sort of problem.
11:53:46 <byorgey> Apocalisp: what would you want such a function for?
11:54:03 <Apocalisp> join, project
11:55:06 <kilimanjaro> But that's not an explanation of *why* you want such a function...
11:55:56 <Apocalisp> I could be convinced that I don't need it.
11:56:09 <roconnor> :)
11:56:18 <roconnor> we will convince you!
11:56:20 <sjanssen> you don't need it (usually :)
11:56:32 <kilimanjaro> )
11:57:08 <sjanssen> wrong.  I meant an operator section
11:57:47 <roconnor> @type \usually -> map (usually :) (inits [0..]))
11:57:48 <kilimanjaro> Apocalisp, I think what you are asking about would be an example of dependent types
11:57:49 <lambdabot> parse error on input `)'
11:57:55 <roconnor> @type \usually -> map (usually :) (inits [0..])
11:57:56 <lambdabot> forall a. (Num a, Enum a) => a -> [[a]]
11:58:54 <Apocalisp> dependent on what?
11:59:06 <phobes> on values
11:59:21 <phobes> like Vector 3
11:59:28 <kilimanjaro> Apocalisp, but it's not feasible nor, in my opinion, desireable to express all the properties of some function via its type signature.
11:59:54 <roconnor> just use nested pairs.
12:00:13 <roconnor> > (1,(2,(3,4)))
12:00:14 <lambdabot>  (1,(2,(3,4)))
12:00:19 <phobes> kilimanjaro:  You're saying you think dependent types are not a good idea?
12:00:44 <faxathisia> It is certainly desireable
12:01:08 <phobes> (note: I don't think he ever said anything about expressing *all* properties in a type signature)
12:01:21 <Apocalisp> For my type, I want (1,(2,(3,4))) == (((1,2),3),4)
12:01:38 <phobes> oh, you want quotient types
12:01:58 <sjanssen> (1, (2, (3, ()))) -- use this instead, fewer corner cases
12:02:17 <phobes> You might be able to do something using typeclass madness that automatically sorts them for you
12:02:43 <roconnor> listen to sjanssen
12:02:46 <kilimanjaro> faxathisia, you pick what properties are important and ignore the ones that are unimportant
12:03:09 <roconnor> Apocalisp: your expression doesn't even typecheck.
12:03:17 <jz87> I have a question about the fastcgi bindings
12:03:35 <roconnor> Apocalisp: just make sure everything is always fully associated one way and you will probably be fine.
12:03:43 <faxathisia> kilimanjaro: what
12:03:43 <jz87> when I try to install it, it says I need cgiapp.h
12:03:46 <roconnor> (although you haven't said what you are trying to do yet ;)
12:03:52 <jz87> but I do have the fcgi library installed
12:03:58 <jz87> where is it looking for the header file?
12:04:12 <phobes> There's no way to define new enclosing operators, right?   (: 1, 2 :), or something
12:04:19 <kilimanjaro> faxathisia, what are the properties of (+) : Integer -> Integer ? To express all the properties of this would be essentially defining addition at the type level, and that's not very helpful
12:05:02 <faxathisia> (+) :: Int -> Int -> Int
12:05:03 <bringert> jz87: where your system thinks include files live
12:05:03 <phobes> kilimanjaro:  it is useful if you're writing functions like cross :: Vec 3 -> Vec 3 -> Vec 3, etc
12:05:15 <jz87> this is windows
12:05:22 <bringert> jz87: try setting CPATH
12:05:25 <bringert> jz87: oh
12:05:55 <jz87> yeah, everything is harder with windows
12:05:58 <kilimanjaro> phobes, I'm not talking specifically about what Apocalisp was asking, I just said that it's not desireable to express all properties
12:06:23 <faxathisia> kilimanjaro: It's quite confusing to just make some random unrelated statement like that :p
12:06:29 <phobes> kilimanjaro:  In general it's not desirable, I agree
12:06:38 <bringert> jz87: you can always edit the .cabal file ad set Include-dirs:
12:06:55 <phobes> kilimanjaro:  Though some types (forall a. a -> a), do a good job of pinning down their implementation :)
12:07:03 <kilimanjaro> faxathisia, he had not provided any concrete example of what he wanted
12:07:11 <jz87> where would I add explicit dir references?
12:07:35 <faxathisia> ((a, b) -> c) -> (a -> b -> c) is another nice one
12:07:46 * faxathisia thinks that is a lot clearer than an implementation
12:07:47 <bringert> jz87: Include-dirs in the .cabal file
12:08:39 <bringert> jz87: you will probably need to add something for it to find the lib when linking as well
12:08:47 <Apocalisp> What I want is a types which is expressed by an unordered set of n pairs (a, T), such that any two pairs (a1, T) and (a2, T) satisfy a1 != a2. Roughly.
12:08:48 <phobes> curry f (x,y) = f x y -- pretty straighforward
12:09:04 <bringert> jz87: e.g. by setting Extra-lib-dirs
12:09:18 <phobes> or I did that backwards :)
12:09:23 <faxathisia> phobes: Maybe it's just me then but I find that lots more confusing than the type sig
12:09:39 <jz87> ok
12:09:39 <bringert> jz87: you could also try setting the CPATH  environment variable to find the header files
12:09:41 <phobes> apparently not just you :)
12:09:53 <phobes> curry f x y = f (x,y)
12:10:27 <bringert> remember, currying makes things better
12:10:28 <jz87> uh
12:10:30 <roconnor> Apocalisp: are a1 and a2 types or values?
12:10:38 <jz87> it says section expected
12:10:38 <Leimy> mmmm delicious curry
12:10:40 <jz87> is the syntax just
12:10:43 <jsnx> bringert: yeah, even old rotten meat
12:10:51 <jz87> extra-lib-dirs: "c:\\documents and settings..."
12:10:52 <jz87> ?
12:10:53 <idnar> @djinn ((a, b) -> c) -> (a -> b -> c)
12:10:54 <lambdabot> f a b c = a (b, c)
12:11:08 <faxathisia> @djinn (a -> b -> c) -> ((a, b) -> c)
12:11:08 <lambdabot> f a (b, c) = a b c
12:11:12 <Apocalisp> roconnor: I'm not sure. In Lisp, it would just be a symbol.
12:11:21 <bringert> jz87: you need to add it in the library section, indented
12:11:39 <bringert> jz87: add it at the end of the file, indented as much as extra-libraries
12:11:53 <bringert> there ought to be a cabal command-line flag for this
12:12:12 <roconnor> Apocalisp: hmm, still not fully understanding you.
12:12:15 <phobes> Apocalisp:  Can you write down the typeclass that captures the ADT you want?
12:13:11 <jz87> nope
12:13:15 <jz87> still not working
12:14:06 <roconnor> Apocalisp: sounds kinda like you want to use Data.Map
12:14:25 <phobes> ya
12:14:29 <jz87> do I just include the dir
12:14:37 <jz87> like ..path/include/
12:14:40 <Apocalisp> roconnor: If I were writing a typechecker for this specific algebra, then x::(a1, T) == y::(a2, T) would not be well typed, or so I would hope.
12:14:52 <jz87> where fcgiapp.h is in include/fciapp.h
12:15:30 <jz87> btw
12:15:40 <jz87> is there a xml manipulation library that uses bytestrings?
12:15:53 <roconnor> Apocalisp: okay, can you give some example values for x, a1 and T?
12:16:05 <phobes> Apocalisp:  That comment loses me :)
12:16:11 <Apocalisp> sorry!
12:16:26 <roconnor> Apocalisp: we will figure this out yet :)
12:16:32 <Apocalisp> heh
12:16:38 <faxathisia> :D
12:17:26 <kilimanjaro> I'm putting words in his mouth, but I think he means x would, be for example a 3-vector, so x::(3, Vector), x == (x1,x2,x3)
12:17:31 <kilimanjaro> with pseudo-syntax
12:18:28 <phobes> ah, where a1, a2 are values in the type system (so dependent types)
12:18:59 <roconnor> kilimanjaro: if that is true then we can tell him about our tricks to do poor-man's dependent types.
12:19:04 <faxathisia> Agda2 has dependant types and is very haskell-like
12:19:07 <faxathisia> also implemented in haskell
12:19:08 <kilimanjaro> Just send him to okmij.org
12:19:18 <kilimanjaro> tell him to come back when the blood pours from his eyes
12:19:21 <Apocalisp> Example value for x: (foo "foo", bar 3, baz True). Its type is something like: (foo String, bar Int, baz Boolean). String, Int, and Boolean are examples of what I called T. foo, bar, and baz are examples of what I called a1.
12:19:44 <kilimanjaro> ohh I was way off
12:20:58 <roconnor> Apocalisp: hmm
12:21:01 <kilimanjaro> So are you asking for the haskell equivalent of an association list?
12:21:18 <Apocalisp> kilimanjaro: I don't know what an association list is.
12:21:24 <kilimanjaro> I thought you were a lisper
12:21:51 <Apocalisp> Oh, sorry. Thinking in different context. Not exactly, no.
12:22:01 <Apocalisp> I want to write a tuple algebra.
12:23:04 <roconnor> Apocalisp: I think I'm slowly starting to understand whatt you want
12:23:19 <roconnor> Apocalisp: foo, bar, baz can basically be any string right?
12:23:55 <Apocalisp> Any symbol. I don't think I want spaces or punctuation.
12:24:01 <phobes> Are these just records?
12:24:04 <kilimanjaro> Apocalisp, what definition of tuple are you interested in?
12:24:40 <phobes> data X = mkX { foo :: String, bar :: Int, baz :: Boolean }
12:24:48 <phobes> is that what you want?
12:24:51 <Apocalisp> Tuple : Let tr be a tuple and Hr a heading; The tuple tr is a set of ordered triplets <a,T,v>
12:24:51 <Apocalisp> where each attribute ai of Hr is associated with a triplet <ai,Ti,v> .
12:25:47 <Apocalisp> A heading Hr is a set of ordered pairs <a, T> for each attribute a of tr. So, two pairs <a1,T1> and <a2,T2> of tr are such as a1? a2 (i.e.: the names of attributes are different).
12:26:00 <roconnor> Apocalisp: this is going to be quite difficult to do in haskell.
12:26:34 <Apocalisp> That's unfortunate. What kind of language would make this easy?
12:26:50 <Apocalisp> Say Prolog and I will... so help me.
12:26:58 <Apocalisp> :-)
12:27:00 <roconnor> because you basicallly cannot do any static type checking
12:27:15 <phobes> python :)
12:27:57 <phobes> I still don't know what you're talking about though, so don't take that seriously
12:28:31 <mrd> if you write utf-8 encoded text in quotes, how will ghc handle that?
12:28:36 <Apocalisp> I guess I don't see why the types can't be statically checked.
12:28:40 <roconnor> Apocalisp: Map Symbol Dynamic comes pretty close to what you want
12:29:06 <roconnor> hmm
12:29:21 <roconnor> but the type system won't fully capture the type you want
12:29:29 <roconnor> sooo
12:29:38 <Apocalisp> I'm beginning to see that. What kind of type system would?
12:29:41 <phobes> roconnor:  So you understand what he wants?
12:29:42 <roconnor> we would need to do some type class hackery
12:30:00 <monochrom> mrd: let me do a test.
12:30:02 <roconnor> phobes: he wants to make a tuple algebra :)
12:30:14 <phobes> The first sentence loses me... "The tuple tr is a set of ordered triplets..."
12:30:37 <roconnor> Apocalisp: this can certainly be done in a system with dependent types.
12:30:38 <phobes> roconnor:  Meaning a record algebra?
12:30:43 <roconnor> phobes: right
12:30:52 <mrd> i tried somethin, but i can't tell if its ghc or my terminal screwing it up
12:31:09 <phobes> There's a paper somewhere about doing records in Haskell using typeclasses, I think - right?
12:31:15 <roconnor> Apocalisp: I bet we can convince Haskell to do this somehow
12:31:25 <roconnor> phobes: such a paper may be good.
12:31:36 <Apocalisp> http://www.di.uminho.pt/~joostvisser/publications/StrongTypesForRDBs.pdf
12:31:38 <lambdabot> http://tinyurl.com/yr69ow
12:32:08 <phobes> Apocalisp:  Haskell's built in for records is pretty weak, but you should make sure it's not enough for what you need
12:32:25 <phobes> It's getting some extra sugar in an upcoming (recent?) release
12:32:42 <phobes> If you want subtyping or more dynamic features though, you'll probably have to build something
12:32:45 <Apocalisp> phobes: I looked at records, and you are right, it's pretty weak.
12:32:58 <roconnor> Apocalisp: ugh, that paper looks about right.
12:33:39 <monochrom> mrd: It is tricky to test, since putStr etc. is lossy.  Try to test with "print (map Data.Char.ord mystring)" instead, to check that internally it gets the characters right.
12:33:42 <phobes> well I have to go - good luck
12:33:54 <Apocalisp> That paper outlines an incredibly baroque way of coercing Haskell into typechecking a subset of the relational algebra.
12:34:20 <Apocalisp> good lord
12:34:37 <roconnor> yep
12:34:53 <Apocalisp> Maybe this can be made more terse in Scala?
12:35:09 <Apocalisp> I shall ask the Scala folks
12:35:15 <sclv_> Apocalisp: browsing HList papers seems to be the best way to pick up yr. own sorts of techniques.
12:35:59 <Apocalisp> yea, I will hold that thought
12:36:00 <monochrom> I did: print (map ord "Ã—âˆ€")
12:36:03 <Apocalisp> thanks for the pointers
12:36:16 <monochrom> It correctly gives [215,8704]
12:36:18 <mrd> looks like it does
12:37:08 <monochrom> putStr would mangle up at least âˆ€. putStr is known to deliberately drop higher bits.
12:37:48 <monochrom> Also putStr deliberately does not output utf-8. Therefore if your terminal expects utf-8, it thinks it receives something weird.
12:40:27 <faxathisia> Any more suggestions of well written haskell programs which do program transformation?
12:40:57 <desegnis> > sum $ (\n -> map (n*) [1..]) =<< [3,5]  -- Apocalisp: As it seems you're still around
12:41:08 <lambdabot> Terminated
12:41:50 <desegnis> lambdabot: Of course that program will terminate.
12:42:30 <desegnis> Oh, I realize I dropped the takeWhile. Never mind
12:42:43 <desegnis> > sum $ (\n -> takeWhile (<1000) $ map (n*) [1..]) =<< [3,5]
12:42:45 <lambdabot>  266333
12:46:29 <Apocalisp> desegnis: Eh? What's that?
12:46:33 <faxathisia> actually.. Has anyone tried using pretty printing libraries for program transformation?
12:46:57 <faxathisia> afaict it's difficult to represent certain manipulations, because I lack langauge for it
12:47:05 <faxathisia> (not sure if pretty printing is the way..)
12:47:33 <Apocalisp> desegnis: Hah! That's a much nicer solution.
12:47:47 <Apocalisp> But still keeps the =<<. I like that.
12:47:54 <desegnis> Apocalisp, of course, if you do want the right result, then:
12:48:22 <desegnis> > sum . map head . group . sort $ (\n -> takeWhile (<1000) $ map (n*) [1..]) =<< [3,5]
12:48:23 <lambdabot>  233168
12:48:32 <desegnis> (removing duplicates there)
12:48:37 <Apocalisp> sort??
12:48:55 <desegnis> think of it like, unique = map head . group . sort
12:49:10 <desegnis> (sry, off for movie now)
12:49:14 <Apocalisp> Nice one.
12:49:38 <Apocalisp> But I'd rather not have duplicates in the first place.
12:56:41 <faxathisia> Any comments on my code http://rafb.net/p/G2YE9g19.txt :)
12:57:04 * faxathisia thinks it's possibly not the best way to have written this..
12:57:06 <Apocalisp> > let ms = [3,5] in let xs = [1..1000] in let p = product xs in (sum . takeWhile (< n) $ map (+ p * n) (filter (any (0 ==) . flip map xs . mod) [0..p]) =<< [0..]) ms xs
12:57:08 <lambdabot>   Not in scope: `n'
12:57:11 <Apocalisp> grr
12:57:36 * faxathisia thinks it's possibly not the best way to have written this..
12:58:06 <Apocalisp> > let n = 1000 in let ms = [3,5] in let xs = [1..n] in let p = product xs in (sum . takeWhile (< n) $ map (+ p * n) (filter (any (0 ==) . flip map xs . mod) [0..p]) =<< [0..]) ms xs
12:58:06 <lambdabot>  Couldn't match expected type `a -> m b'
12:59:42 <dibblego> is there not a flip (>>) somewhere? (I was expecting <<)
13:00:56 <phobes> People don't use the long one-liners they write to this channel in real code I hope :)
13:01:24 <dibblego> no, they do it to keep the channel alive, deliberately being verbose :)
13:01:33 <phobes> hehe
13:01:59 <faxathisia> oops I repeated myself
13:02:06 <TSC> dibblego: It seems there's a flip (>>=), but no flip (>>)
13:02:15 <dibblego> TSC, ok, just confirming, thanks
13:02:28 <TSC> That's just what @pl reckons
13:03:04 <Toxaris> :t (<*)
13:03:05 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
13:03:29 <Toxaris> :t (>>)
13:03:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
13:03:37 <dibblego> nice thanks
13:10:18 <faxathisia> :S
13:10:26 <faxathisia> Does anyone else have this trouble?
13:10:38 <faxathisia> (Program transfomation code is close to illegible)
13:10:41 <faxathisia> (in haskell)
13:14:37 <thetallguy> ?seen igloo
13:14:38 <lambdabot> igloo is in #haskell, #ghc and #darcs. I last heard igloo speak 1h 58m 33s ago.
13:29:39 <Cin> hi. so the `if' can only be used with values of type Bool, right?
13:30:11 <heatsink> Cin: you can only test Bool values.
13:30:26 <heatsink> Cin: if you want to do case analysis on other types, use case.
13:32:00 <Cin> right. in other languages you might have that all objects that are tested, evaluate to true, unless they are False or 0 or #f
13:32:19 <Cin> (depdending on the language)
13:32:22 <chadz> thanfully Haskell is super strong.
13:32:26 <chadz> thank
13:32:49 <Cin> right. i'm pondering the implications of both of these
13:32:51 <tuukkah> or None or [] or "" or ...
13:33:23 <Cin> :t None
13:33:24 <lambdabot> Not in scope: data constructor `None'
13:33:42 <Cin> is that a keyword?
13:33:44 <tuukkah> not haskell but the other language :-)
13:33:48 <Cin> ah
13:35:56 <kalmar> "the other language"
13:36:01 <heatsink> Cin: if you want to get a true/false result from some other data, you have to do the conversion yourself.  Usually it's just a function call, so I've never found it cumbersome.
13:36:08 <oerjan> @users
13:36:08 <lambdabot> Maximum users seen in #haskell: 433, currently: 433 (100.0%), active: 18 (4.2%)
13:36:19 <chadz> one more!
13:36:19 <heatsink> wow.
13:36:46 <tuukkah> kalmar, the other white-space-sensitive language even ;-)
13:36:51 <heatsink> heh
13:37:40 <kalmar> tuukkah: indeed
13:37:47 <Cin> yay!
13:37:50 <Cin> @users
13:37:50 <lambdabot> Maximum users seen in #haskell: 434, currently: 434 (100.0%), active: 18 (4.1%)
13:37:52 <kalmar> ?users
13:37:52 <lambdabot> Maximum users seen in #haskell: 434, currently: 434 (100.0%), active: 18 (4.1%)
13:37:54 <defcon8> :|
13:37:59 <chadz> omg, one more!
13:38:13 <heatsink> the #haskell drinking game.
13:38:18 <defcon8> woo
13:38:24 <defcon8> haha
13:38:26 <defcon8> @users
13:38:26 <lambdabot> Maximum users seen in #haskell: 435, currently: 434 (99.8%), active: 19 (4.4%)
13:40:22 <dons> cool
13:40:54 <chadz> we should have a reddit event
13:41:02 <dons> hmm?
13:41:06 <chadz> or have the xkcd guy write something about #haskell
13:41:08 <faxathisia> Hi dons :)
13:41:23 <chadz> "on friday the 11th, we must all join #haskell to celebrate its greatness"
13:41:28 <dons> the xkcd guy's been lost to python, hasn't he?
13:41:39 <heatsink> It's a step up from perl, at least.
13:41:42 <dons> true.
13:41:49 <chadz> dunno. he's gone from lisp, perl, to python
13:41:56 <chadz> he's all over.
13:42:04 <dons> does he write code though?
13:42:09 <Leimy> hmmm
13:42:16 <chadz> probably little things.
13:42:22 <chadz> he probably lives off t-shirts now.
13:42:37 <Leimy> Hmm python is capable of neat stuff.
13:42:49 * Leimy has a weird y combinator like thingy with it.
13:43:06 * heatsink hates writing monads in python
13:43:17 <faxathisia> Leimy: Hows it compare to let y f = f (y f) ?
13:43:39 <chadz> thankfully you don't need monads in python...
13:43:44 <Leimy> Y = lambda g: (lambda f: g(lambda arg: f(f)(arg))) (lambda f: g(lambda arg: f(f)(arg)))
13:43:44 <Leimy>  
13:43:50 <thorat> I thought Python didn't even have closures.
13:44:15 <faxathisia> ((lambda (m) ((lambda (x) (x x m)) (lambda (y m) (m (lambda (n) ((y y m) n))))))
13:44:23 <faxathisia> Scheme is shorter & cleaner :p
13:44:25 <Leimy> memo_trace_fib = Y(_memoizer(_trace(_fibstep)))
13:44:26 <oerjan> @unpl fix f
13:44:26 <lambdabot> fix f
13:44:33 <Saizan> thorat: it has quite a nice support for first-class functions
13:44:35 <chadz> someone should point me to the difference between closures and first-class functions. it's at the compiler level and somewhat entangled with static typing, isit not?
13:44:37 <Leimy> memoized traced fibonacci using the Python Y combinator :-)
13:44:59 <Leimy> hpaste: url?
13:44:59 <hpaste> Haskell paste bin: http://hpaste.org/
13:45:19 <heatsink> thorat: If you define a function inside another function and return it, the inner function has read-only access to the outer function's local variables.  So it has closures.
13:45:20 <monochrom> No one "needs" anything.
13:45:37 <thorat> ok
13:45:45 <hpaste>  leimy pasted "Python Y combinator stuff..." at http://hpaste.org/4799
13:46:15 <monochrom> Haskell doesn't "need" monads either.
13:46:18 <Leimy> I got started on that reading a blog that's linked in there...
13:46:32 <Leimy> all you need is Forth!
13:46:34 <chadz> heatsink: i've always considered that the case with all first-class functions. i could see how it could not tho
13:47:43 <monochrom> This is more important: If you want to use monads, does Haskell make it easier? If you want to use monads, does Python make it easier?
13:48:26 <chadz> that's an important question, but i think it's not accurate
13:49:08 <Philippa> chadz: closures mean something different in a language with mutability
13:49:24 <Philippa> in that it may be possible to mutate an existing closure
13:49:28 <chadz> Philippa: true.
13:49:48 <phobes> closures in a language with mutability means trouble
13:50:01 <faxathisia> phobes: Why?
13:50:16 <Philippa> are you sure the first two words of that sentance weren't redundant?
13:50:24 <heatsink> heh
13:50:35 <monochrom> Hahahaha
13:50:42 <phobes> Philippa talking to faxathisia?
13:50:46 <phobes> :)
13:50:51 <faxathisia> lol
13:51:07 <faxathisia> I though mutable closures works ok... never saw any problems
13:51:33 <monochrom> Mutability doesn't mean trouble to me.
13:51:43 <monochrom> But hear my punchline:
13:51:51 <phobes> Ya, it's fine - the only confusing thing is if you have closures modifying aliased state
13:52:17 <monochrom> That's only because I reason about imperative programs by translating them back to functional programs first.
13:52:31 <monochrom> "x:=x+1" is a state function.
13:52:38 <phobes> monochrom:  That's in general pretty hard
13:52:42 <Leimy> ++x
13:52:45 <Leimy> x++
13:52:50 <Leimy> not the same :-)
13:52:51 <Leimy> phear!
13:52:54 <Cin> a closure that is capable of mutating variables in its environment?
13:53:05 <monochrom> Why is it in general pretty hard?
13:53:07 <phobes> unless you're willing to translate to x :: BigBallOfYarn -> BigBallOfYarn, Int
13:53:37 <Cin> when you say "mutable closure" it sounds like you can modify parts of the closure itself. is that what you're talking about?
13:53:39 <phobes> Try to automate the translation
13:53:55 <oerjan> just use Control.Monad.Yarn
13:54:02 <phobes> x = x + 1 is easy to translate to x1 = x + 1
13:54:32 <phobes> but when you start having the possibility of aliasing, you quikly build the BigBallOfYarn
13:55:16 <monochrom> I am still pretty informal when I deal with aliasing.
13:56:17 <monochrom> When there is no aliasing, the translation is straightforward. I haven't automated it, but that's only because it's too easy to do by hand.
13:56:43 <phobes> I agree that when imperative code is easy to understand it's usually because it translates relatively easily to functional code
13:57:00 <phobes> but when imperative code gets confusing, translating it to functional code might not help
13:57:08 <phobes> if it's written in a screwball way
13:57:36 <phobes> might not help / might be difficult
13:58:30 <phobes> The theory behind higher order functions is all wrong
13:58:38 <chadz> i don't know why you'd want to translate stateful imperative code to functional monadic io.
13:58:55 <monochrom> Some aliasing can be eliminated. For example have array A, index variables i, j.  i==j may be true or false, possible aliasing.  There is a well-known way to deal with that.  Instead of thinking "a[i] := e", use "a := new array which is like a except at index i it takes e".  That functionalizes array-using programs perfectly.
13:58:57 <phobes> (That was for Philippa :P)
14:00:03 <monochrom> But when it comes to heap allocation and pointers, I don't use formal reasoning. I stay informal. I haven't practiced the formal ways I know for this.
14:00:33 <monochrom> chadz: I am just talking about state, no io.
14:00:49 <heatsink> chadz: I think the benefit is in translating it to non-stateful functional code when possible, so that you no longer have to reason about the code as a sequence of many small steps of computation.
14:00:58 <monochrom> It also helps that I just don't consider screwball programs. :)
14:01:21 <phobes> monochrom:  Right, but if you have a[i] := e1;  f ();    a[j] := e2;   Then you have to know that f() doesn't screw with a to conclude something about a at the end
14:01:41 <monochrom> That is right. I must know the external specification of f.
14:02:14 <monochrom> But any reasoning of any program in any language requires external specifications.
14:02:30 <chadz> heatsink: yes, but in that case the code wasn't written elegantly. stateful languages don't need to modify state.
14:02:48 <monochrom> Only choice is you choose to write formally or you choose to say "you know what I mean".
14:03:49 <phobes> If external specifications means "explaination of all side effects of this function" it can be sometimes hard to describe
14:04:04 <phobes> In a langauge where you have a big tangled object structure
14:04:06 <monochrom> And of course, in that example, you can also informally assure "f doesn't modify a", and you can still reason formally about the rest.
14:04:58 <monochrom> Yes, if there are heap objects and pointers, I still reason informally.
14:05:19 <monochrom> I know of formal ways. I just haven't practiced them enough to use them effectively.
14:05:59 <phobes> I just think that in general a formal translation will end up passing the Heap around
14:06:57 <monochrom> I have seen two. They pass a fragment of the heap around. Not the whole heap.
14:08:04 <phobes> I can imagine... you do your best to identify regions of the Heap that be passed separately
14:08:29 <phobes> but I'm saying that in general (for "randomly generated" programs or something), I think it will devolve into passing the heap around
14:08:52 <monochrom> You also don't have to state and prove all relations among heap objects. Just a few non-interference statements go a long way usually.
14:08:56 <phobes> I'd speculate that the better written the imperative program, the more easily it would be possible to untangle and functionally update only a fraction of the heap
14:09:50 <mdmkolbe|work> Ok, why does "foo = fromInteger 12" when typed into a file infer  the type "Integer" when "fromInteger 12" typed at the prompt has type "(Num a) => a"?
14:09:54 <phobes> I don't think we disagree that much :)
14:10:08 <oerjan> mdmkolbe|work: monomorphism restrictino
14:10:12 <oerjan> *ion
14:10:21 <monochrom> A good reasoning method for programs should be: easy for well-designed programs, hard for pathological programs.  That gives you some incentive to design programs well.
14:11:01 <oerjan> + defaulting
14:11:08 <mdmkolbe|work> oerjan: you know... someday I'm going to learn what that actually means (other than just being anoying)
14:12:10 <oerjan> http://www.haskell.org/onlinereport/decls.html#sect:monomorphism-restriction
14:12:10 <mdmkolbe|work> what are the conditions of the MR?  (I already know it has to do with no declared type and no explicit parameters, but I don't know what else.)
14:12:11 <lambdabot> Title: The Haskell 98 Report: Declarations, http://tinyurl.com/yy9y4w
14:12:30 <monochrom> I think that's all?
14:12:36 <phobes> mdmkolbe|work:  The idea is just that when you write "fromInteger 12" that should be a constant - not a function that's reevaluated every time you use it
14:12:52 <oerjan> also type class restrictions must be involved
14:14:05 <oerjan> because if a type has no class restrictions, you don't need to specialize it to an instance so the internal representation can be uniform
14:15:01 <Apocalisp> @type (=<<)
14:15:01 <heatsink> > case undefined of x -> 0
14:15:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
14:15:04 <lambdabot>  0
14:15:14 <Apocalisp> @type (=<<) (+)
14:15:15 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
14:15:32 <Apocalisp> > (=<<) (+) 1 2
14:15:33 <lambdabot>   add an instance declaration for (Num (a -> a))
14:15:48 <heatsink> Is a type inferred for x in [| case undefined of x -> 0 |]?
14:15:48 <Apocalisp> > (=<<) (+) (+1) 2
14:15:49 <lambdabot>  5
14:15:59 <oerjan> heatsink: probably not
14:16:00 <nornagon> > case undefined of !x -> 0
14:16:00 <lambdabot>  Parse error at "!x" (column 19)
14:16:39 <oerjan> nornagon: no bang patterns in >
14:17:12 <oerjan> @src (->) (>>=)
14:17:12 <lambdabot> f >>= k = \ r -> k (f r) r
14:17:20 <oerjan> ^^ Apocalisp
14:17:46 <phobes> oerjan:  Can you give an example of what you meant by "because if a type has no class restrictions...
14:17:46 <Apocalisp> oh, there it is
14:17:54 <mdmkolbe|work> thx, oerjan, phobes, that explains things (annoying things, but at least they are explained)
14:18:03 <mdmkolbe|work> @hoogle Integer -> Char
14:18:04 <lambdabot> No matches, try a more general search
14:18:05 <nornagon> oerjan: evidently :)
14:18:12 <oerjan> phobes: well consider a = map
14:18:15 <oerjan> :t map
14:18:15 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:18:23 <mdmkolbe|work> @hoogle (Num a) => a -> Char
14:18:23 <lambdabot> No matches, try a more general search
14:18:36 <mdmkolbe|work> @type chr . fromInteger
14:18:37 <lambdabot> Integer -> Char
14:18:49 <oerjan> its type has no class restrictions, so there is nothing about its internal representation that varies according to the type
14:19:03 <oerjan> *type=type variables
14:19:21 <mdmkolbe|work> oerjan: by class restrictions you mean e.g. (Num a)?
14:19:25 <phobes> The MR wouldn't apply to mapM either though, would it?
14:19:44 <phobes> I thought it only applied to non-functions with class constraints?
14:19:46 <oerjan> and therefore it doesn't need to be reevaluated
14:19:48 <oerjan> :t mapM
14:19:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
14:20:25 <oerjan> > let a = mapM in (a id [1,2,3], a id (Just 1))
14:20:25 <lambdabot>  Couldn't match expected type `[m b]'
14:20:34 <oerjan> er wait
14:20:37 <Apocalisp> @src (->) (=<<)
14:20:38 <lambdabot> Source not found. :(
14:20:52 <Apocalisp> oh, that's just a flip
14:20:57 <oerjan> > let a = mapM in (a (:[]) [1,2,3], a Just [1,2,3])
14:20:58 <lambdabot>  Couldn't match expected type `[]' against inferred type `Maybe'
14:21:09 <oerjan> there we are, so a is monomorphic in the monad
14:21:29 * mdmkolbe|work just realized that "monomorphism restriction" is actually a restriction on polymoprism to make it monomorphic in some cases and not a "restriction on monomorphism"
14:21:36 <oerjan> > let a = mapM in (a Just [1,2,3], a Just "abc")
14:21:36 <lambdabot>  (Just [1,2,3],Just "abc")
14:21:50 <phobes> mdmkolbe|work:  heh, ya
14:21:59 <oerjan> but it is not monomorphic in the element types, which have no class restrictions
14:22:41 <phobes> oerjan:  processing ...
14:23:41 <phobes> > mapM (:[]) [1,2,3]
14:23:42 <lambdabot>  [[1,2,3]]
14:23:58 <phobes> > mapM Just [1,2,3]
14:23:59 <lambdabot>  Just [1,2,3]
14:24:17 <phobes> > let a = mapM in (a Just [1,2,3])
14:24:18 <lambdabot>  Just [1,2,3]
14:25:51 <oerjan> phobes: the thing is, the exception for functions to MR is not about their type, but about their syntactic definition, i.e. f x1 x2 = ... where there are parameters given to the left of =
14:26:07 <phobes> ya I'm getting it now
14:26:15 <phobes> I misunderstood before :)
14:26:49 <monochrom> If you write f = \x y -> ...  you also trigger MR.
14:28:04 <oerjan> i guess they made the distinction syntactic because anything else would just make MR even more complicated...
14:28:53 <Heffalump> it's syntactic because people expect values to be only evaluated once
14:30:21 <Toxaris> oerjan: isn't the point of the MR: "if it looks like a top-level constant, it should not take any hidden type parameters"?
14:30:40 <phobes> Toxaris:  That was basically my understanding prevoiusly
14:30:49 <Toxaris> so it's about how definitions look like (syntactic), not what they mean (semantic)
14:30:50 <monochrom> Yes, that's the spirit.
14:30:55 <phobes> but not just top-level, inside let declarations too
14:31:22 <Toxaris> oh ok, so it's "if it looks like a constant ..."
14:31:47 <phobes> oerjan:  oh I see, I was just being dumb
14:31:57 <phobes> I think my previous understanding was right... I just muddled it :)
14:32:06 <phobes> of course it doesn't look at the type of the thing being define
14:32:09 <phobes> defined*
14:33:23 <matthew-_> Left "Data.Map.lookup: Key not found"
14:33:31 <matthew-_> wonderful error message there...
14:33:49 <dons> what's a better one? :)
14:33:52 <Toxaris> matthew-_: what do you expect?
14:34:03 <oerjan> matthew-_: i guess it can hardly do better since there is no Show restriction on the keys
14:34:06 <dmhouse> Keeping in mind that the key doesn't have to instantiate Show.
14:34:24 <dmhouse> Although I believe GHCi now supports a generic object outputter for debugging.
14:34:45 <matthew-_> well, do a dynamic check to see if it supports Show and then behave suitably
14:35:08 <oerjan> matthew-_: but that is impossible
14:35:17 <Toxaris> matthew-_: what is a "dynamic check"? there are no dynamic types in Haskell
14:36:04 <matthew-_> I thought you could do it with Data.Dynamic (though I've never looked at that)
14:36:20 <oerjan> sure, but Data.Map has no Dynamic restriction either :D
14:36:38 <matthew-_> ahh I see. So now I have more clue about Data.Dynamic ;)
14:36:56 <oerjan> well actually i don't think you can check if it implements Show
14:37:07 <oerjan> but you can check if it is any specific type
14:40:26 <phobes> So would it be appropriate to have a debugShow in Key ?
14:41:21 <phobes> I guess there's not a way to have an instance declaration for Show t  =>  some defaults for Key t
14:42:55 <Toxaris> class Key a where showKey :: a -> String; instance Show a => Key a where showKey = show; instance Key a where show = const "key"
14:43:32 <Toxaris> given a lot of evil language extensions this may work, but what do i know
14:43:44 <matthew-_> no, I don't think that would ever work
14:43:46 <phobes> ya and then Key a => Map ...
14:43:55 <matthew-_> decisions are never made based on context IIRC
14:44:09 <matthew-_> unless there are some new extensions I'm unaware of
14:44:10 <phobes> hmm
14:44:22 <Toxaris> matthew-_: as i said: what do i know :)
14:44:25 <matthew-_> you can only make decisions based on the RHS of the instance
14:44:31 <phobes> You mean overlapping instances are never resolved by considering "Class a => a" more specific than just "a"?
14:44:33 <matthew-_> Toxaris: probably more than me ;)
14:44:47 <matthew-_> phobes: I believe that's correct
14:45:29 <matthew-_> phobes: you simply are looking at what information you have about the instances, not their context. But the GHC user guide explains it, as opposed to the waffle I'm spouting
14:45:57 <phobes> That seems like it would be a pretty common use case...
14:47:02 <matthew-_> yeah, depends more on whether it's decideable and sound, not on use cases ;)
14:47:37 <phobes> Don't get me ranting about typeclasses again - Philippa might still be around
14:50:39 <monochrom> I like rants. :)
14:50:48 <chadz> i hate zergling rushers.
14:51:03 <chadz> 6poolers could all die, imo.
14:51:20 <njbartlett_> @seen dons
14:51:20 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 17m 30s ago.
14:53:05 <Toxaris> :t let niceLookup k = left (const $ shows k " not found") . lookup k in niceLookup -- hey, I don't care about this ignored type :(
14:53:06 <lambdabot>     Couldn't match expected type `Either b d'
14:53:06 <lambdabot>            against inferred type `Maybe b1'
14:53:06 <lambdabot>     In the second argument of `(.)', namely `lookup k'
14:53:15 <dons> njbartlett_: ?
14:53:17 <Toxaris> :t let niceLookup k = left (const $ shows k " not found") . Data.Map.lookup k in niceLookup -- hey, I don't care about this ignored type :(
14:53:18 <lambdabot>     Ambiguous type variable `b' in the constraint:
14:53:18 <lambdabot>       `Error b'
14:53:18 <lambdabot>         arising from use of `Data.Map.lookup' at <interactive>:1:57-73
14:53:43 <oerjan> :t left
14:53:44 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
14:53:47 <njbartlett_> Hi dons. Just saw your post to reddit regarding qtHaskell...
14:54:01 <dons> yep?
14:54:12 <njbartlett_> I'd been meaning to tell you, qtHaskell works like a dream on Mac OS. A huge improvement over Gtk2Hs and wxHaskell...
14:54:33 <Cale> I'm somewhat curious about how the qtHaskell binding was generated.
14:54:42 <chadz> who did it?
14:54:47 <dons> wow. cool. perhaps you should start a wiki page on  haskell.org to collect examples and programs
14:54:53 <Cale> The haskell sources all say that they're machine generated, but they don't mention how.
14:55:02 <dons> njbartlett_: and encoruage the author to submit the package to hackage.haskell.org
14:55:08 <dons> since he seems skeptical about hackage
14:55:11 <monochrom> They came from the Chinese room.
14:55:24 <Cale> Searle's? :)
14:55:35 <oerjan> oh...
14:55:42 <njbartlett_> dons: Yeah. There are lots of examples included. I notices that the code you have to write it is very low level and verbose, it would be nice to write some abstractions on top of it
14:55:50 <njbartlett_> Gah can't type today
14:56:00 <oerjan> :t let niceLookup k = left (asTypeOf $ shows k " not found") . Data.Map.lookup k in niceLookup
14:56:01 <lambdabot> forall a a1. (Show a, Ord a) => a -> Data.Map.Map a a1 -> Either String a1
14:56:05 <oerjan> yay
14:56:07 <faxathisia> how about making a GUI that prints out haskell code?
14:56:12 <faxathisia> (which makes a GUI)
14:56:25 <chadz> crack.
14:56:36 <njbartlett_> faxathisia: Like a graphical quine? ;-)
14:57:11 <Toxaris> oerjan: nice
15:00:02 <oerjan> Toxaris: i though, hm, you need a constraint on the input to const, maybe use asTypeOf, hey wait, asTypeOf _is_ a constrained const
15:00:40 <oerjan> :t asTypeOf . fail
15:00:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a -> m a
15:07:35 <Toxaris> :t \k m -> Data.Map.lookup k m `catchError` (const $ fail $ shows k "not found")
15:07:36 <lambdabot> forall k b (m :: * -> *) a. (Ord k, Show k, MonadError b m) => k -> Data.Map.Map k a -> m a
15:07:52 <Toxaris> oerjan: how to fix the b?
15:08:14 <oerjan> wouldn't the same asTypeOf work there?
15:08:19 <shachaf> Is the arrows package supposed to compile under GHC 6.8?
15:08:29 <Toxaris> oerjan: const :: e -> m a   here
15:08:35 <oerjan> :t \k m -> Data.Map.lookup k m `catchError` (asTypeOf $ fail $ shows k "not found")
15:08:36 <lambdabot> forall k (m :: * -> *) a. (Ord k, Show k, MonadError (m a) m) => k -> Data.Map.Map k a -> m a
15:08:46 <oerjan> oops
15:09:04 <Toxaris> oerjan: ehm, const :: e -> m a -> m a   of course
15:09:39 <monochrom> MonadError b m comes with the fundep m -> b.  So if you can fix m, you don't have to worry about inferring b.
15:10:52 <oerjan> :t \k m -> Data.Map.lookup k m `catchError` (const $ Left $ shows k "not found")
15:10:53 <lambdabot> forall k b. (Show k, Ord k) => k -> Data.Map.Map k b -> Either String b
15:11:55 <matthew-_> ok, I must be being slow and dumb
15:12:02 <matthew-_> @type maybe [] fromJust
15:12:02 <lambdabot> forall a. Maybe (Maybe [a]) -> [a]
15:12:17 <matthew-_> But I think it should be Maybe [a] -> [a]
15:12:22 <oerjan> :t maybe
15:12:22 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:12:27 <noa> anyone tried compiling the monad example the gentle introduction to haskell tutorial?
15:12:36 <matthew-_> oh, I see
15:12:44 <matthew-_> it should be id, not fromJust
15:12:54 <matthew-_> maybe removes the just for me.
15:12:58 * matthew-_ blushes
15:13:04 <sjanssen> matthew-_: you probably should use fromMaybe instead
15:13:04 <oerjan> :t maybe [] id
15:13:04 <lambdabot> forall a. Maybe [a] -> [a]
15:13:11 <sjanssen> @type fromMaybe []
15:13:11 <lambdabot> forall a. Maybe [a] -> [a]
15:13:24 <oerjan> :t maybeToList
15:13:24 <lambdabot> forall a. Maybe a -> [a]
15:13:31 <oerjan> um no
15:13:39 <noa> i'm getting: could not deduce (Eq (R a), Show (R a)) from the context
15:13:41 <matthew-_> @src fromMaybe
15:13:41 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
15:13:50 <matthew-_> cool ok. that's simpler
15:14:02 <monochrom> noa: which example?
15:14:16 <monochrom> I'm looking at http://www.haskell.org/tutorial/monads.html right now.
15:14:17 <lambdabot> Title: A Gentle Introduction to Haskell: About Monads
15:14:20 <Toxaris> oerjan, monochrom: so there's no need to fix the b, the caller will decide upon m (and b) as he pleases.
15:14:24 <noa> the state monad example
15:14:43 <monochrom> under "9.3 Using Monads"?
15:14:48 <noa> yes
15:15:53 <noa> specifically, the instance declaration: "instance Num a => Num (R a)"
15:16:25 <oerjan> > Data.Foldable.fold (Just "hi")
15:16:26 <lambdabot>  "hi"
15:16:34 <oerjan> > Data.Foldable.fold (Nothing)
15:16:34 <lambdabot>  Add a type signature
15:16:47 <oerjan> > Data.Foldable.fold (Nothing) :: [Int]
15:16:48 <lambdabot>  []
15:16:55 <oerjan> matthew-_: ^^
15:17:02 <chadz> haha
15:17:23 <chadz> > Data.Foldable.fold (Nothing) :: Int
15:17:23 <lambdabot>   add an instance declaration for (Monoid Int)
15:17:23 <lambdabot>     In the expression: Data.Fo...
15:17:40 <chadz> truetrue
15:18:24 <shachaf> a
15:18:34 <shachaf> Oops, sorry.
15:20:00 <oerjan> > fold (Just "hi")
15:20:01 <lambdabot>   Not in scope: `fold'
15:20:11 <oerjan> oh it was necessary
15:20:23 <matthew-_> oerjan: yikes, that scares me a little...
15:20:30 <matthew-_> @type Data.Foldable.fold
15:20:30 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
15:20:48 <oerjan> @src Maybe fold
15:20:48 <lambdabot> Source not found.
15:20:50 <oerjan> @src Maybe foldMap
15:20:50 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:20:58 <oerjan> @src Maybe foldr
15:20:59 <lambdabot> Source not found.
15:21:02 <Toxaris> noa: the problem is that Eq and Show are superclasses of Num, so you have to provide Eq and Show instances for (R a) too.
15:21:05 <oerjan> hmph
15:21:45 <noa> cheers, i will try that
15:22:23 <Toxaris> noa: (you cannot define sensible instances, but if you don't use show and (==) on (R a), nonsense instances will do)
15:23:08 <Toxaris> noa: wich shows that instantiating Num to reuse the operator symbols for EDSLs is somewhat hackish
15:23:20 <noa> Toxaris: what's a nonsense instance?
15:23:46 <Toxaris> noa: instance Eq a => Eq (R a) where (==) = undefined
15:23:55 <noa> Toxaris: i see
15:24:11 <oerjan> Toxaris: i think everything after where, perhaps the where itself can be omitted
15:24:21 <LoganCapaldo> good evening haskellians
15:24:42 <Toxaris> oerjan: Yes i think so too. but an explicit undefined seems to be better then an implicit nonterminating loop
15:24:58 <oerjan> and Eq a => isn't really necessary either
15:25:23 <Toxaris> oerjan: is instance Eq (R a) H98?
15:25:23 <oerjan> ah yes Eq has those looping defaults doesn't it.
15:25:36 <oerjan> i think so
15:25:41 <monochrom> Seems the tutorial is a bit dated.  Look at (==*) for example.  It just needs Eq but it says Ord.
15:26:03 <Toxaris> oerjan: hmm yes of course it is... consider instance Monoid [a]
15:26:27 <monochrom> If you fix (==*) to assume Eq, you can now use it for instance Eq a => Eq (R a) where (==) = (==*)
15:28:54 <Toxaris> monochrom: ==* return R Bool, but == returns Bool
15:29:08 <monochrom> Oops!
15:32:06 <sjanssen> oerjan: missing method definitions are allowed in Haskell '98
15:32:22 <chadz> doesn't it require a -fallow?
15:32:29 <sjanssen> no
15:32:50 <oerjan> sjanssen: that's what i was saying
15:33:08 <sjanssen> oh, sorry I mean Toxaris
15:33:20 <monochrom> Nice!
15:34:13 <oerjan> @free f :: (T0 -> r) -> r
15:34:13 <lambdabot> g . f = f . (.) g
15:34:16 <Toxaris> sjanssen: yes I know. I wondered about unrestricted type variables for some reason, but they are obviously fine, too.
15:34:42 * Toxaris has always trouble to remember the various restrictions on instances in different Haskell versions
15:38:22 <Toxaris> what about instance Eq a => Eq (R a) where x == y = x 1 == y 1
15:38:31 <Liskni_si> hm, what does @free do?
15:38:49 <Toxaris> this should recursively allow more ressources to be used until a value is produced
15:39:05 <faxathisia> Liski_si: Change an expression into point free style
15:39:14 <faxathisia> oh wwait not
15:39:17 <faxathisia> free is free theorems
15:39:31 <faxathisia> using the polymorpic types.. it generates theorems somehow..
15:39:53 <allbery_b> @go "theorems for free"
15:39:54 <lambdabot> http://citeseer.ist.psu.edu/250500.html
15:39:54 <lambdabot> Title: Theorems for Free! - Wadler (ResearchIndex)
15:40:30 <Liskni_si> ok, i'll read it, thx :)
15:45:21 <monochrom> I also need to read it.
15:46:03 <monochrom> Ha, let me put away reading Hughes's pretty-printing derivation, and read the free paper first!
16:00:18 <sutats> Is there a way to pull up the type signature of a function while hacking a Haskell file in Vim?
16:02:37 <LoganCapaldo> this guy's stuff can do that apparently http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
16:02:37 <lambdabot> Title: Haskell mode for Vim
16:03:25 <sutats> LoganCapaldo: Thanks, I'll check that out.
16:06:29 <Cale> sutats: Usually the most convenient thing though is to simply keep ghci running in a separate window
16:07:54 <Saizan> or use emacs
16:08:11 * faxathisia uses ghci in a seperate window & emacs :S
16:13:36 <Cale> faxathisia: I've done that too.
16:13:48 <Cale> faxathisia: I never liked emacs' terminal "emulation"
16:17:44 <chadz> why is there no untilM?
16:18:36 <Cale> chadz: Probably not any good reason.
16:19:04 <dons> while-like loops are usually done with recursion for some reason
16:19:20 <dons> go x = when (x > 0) $ do ...
16:19:26 <dons> go x = until (x == 0) $ do ...
16:19:37 <dons> where the body calls go
16:19:41 <Cale> you mean unless?
16:19:48 <dons> whatever it is :)
16:20:12 <oerjan> hm...
16:21:29 <Saizan> everytime i had a loop without a list to consume i was using forever
16:22:28 <ClaudiusMaximus> is HaXml expected to work with namespaces in the naive way I am expecting (namely: ... /> tag "myns:mytag" /> ...) or am i using it wrong?
16:24:01 <oerjan> :t unfoldr
16:24:02 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:25:13 <Saizan> ClaudiusMaximus: have you checked the rendered document?
16:25:15 <jsnx> why don't we have multiline strings in haskell?
16:25:27 <jsnx> would it complicate the parser in some evil way?
16:26:16 <oerjan> jsnx: it fits badly with layout, is all i can think of
16:26:17 <allbery_b> we do, sort of.  whtespace (including newlines) between pairs of \ \
16:26:18 <ClaudiusMaximus> Saizan: i'm getting "" where i expect "something", but i don't know whether that's because of the namespace stuff or if i'm using showattr incorrectly
16:26:32 <jsnx> oerjan: oh, you mean with the identation?
16:26:37 <oerjan> yeah
16:26:42 <jsnx> ah, i see
16:26:47 <monochrom> It's more general than multi-line string.
16:26:52 <jsnx> monochrom: ?
16:27:13 <monochrom> "hello  \  {- this is a comment -} \ world" is possible IIRC.
16:27:28 <oerjan> > "hello  \  {- this is a comment -} \ world"
16:27:29 <lambdabot>  Illegal character in string gap at ""hell..." (column 1)
16:27:41 <oerjan> alas
16:27:49 <monochrom> Now I need to look it for for real.
16:27:57 <jsnx> monochrom: what was that supposed to do?
16:28:33 <monochrom> Damn, comment not allowed.
16:28:55 <oerjan> the grammar says whitechar rather than whitespace :(
16:29:56 <jsnx> oerjan: whitechar is just one?
16:30:03 <oerjan> yep
16:30:22 <oerjan> while whitespace includes comments
16:30:29 <jsnx> aha
16:30:51 <oerjan> http://www.haskell.org/onlinereport/lexemes.html
16:30:52 <lambdabot> Title: Haskell 98 Lexical Structure
16:31:34 <jsnx> so, there is basically one problem with "here documents" in haskell -- they don't fit well with the indentation rules
16:31:56 <jsnx> monochrom: or was there another one?
16:32:14 <monochrom> The Standard Hath Spoken.
16:32:15 <oerjan> hugs has here documents btw
16:33:43 <allbery_b> someone did an implementation of here documents using TH
16:34:56 <jsnx> allbery_b: oh, interesting
16:35:04 <jsnx> so, i actually have another idea
16:35:20 <jsnx> if we *can* have here documents, then why not make all comments strings?
16:35:28 <jsnx> is there any philosophy on this?
16:35:38 <jsnx> some strings just aren't assigned to anything...
16:36:49 <oerjan> you would need some way to distinguish them
16:36:53 <jsnx> why is that?
16:37:07 <jsnx> for haddock?
16:37:31 <oerjan> because haskell does _not_ treat a comment and a string as equivalent
16:37:33 * allbery_b vaguely recalls some language which did that.  lt was mildly freaky
16:37:38 <oerjan> a string is an expression
16:37:45 <jsnx> allbery_b: python does it
16:37:53 <jsnx> oerjan: yes, but, so what?
16:38:02 <allbery_b> also, it means you can't have embedded comments --- at least not where a string would be valid syntactically
16:38:32 <jsnx> allbery_b: yeah, true
16:38:36 <jsnx> allbery_b: but i never use those
16:38:41 <Saizan> we could just have ghci lookup haddock comments in a database, no need for additional syntax
16:39:00 <jsnx> Saizan: like to have doc strings?
16:40:16 <jsnx> Saizan: i'm not sure what you are saying...
16:40:30 <jsnx> Saizan: ...you mean we could put here docs in comments?
16:40:34 <oerjan> one good thing about strings being single-line is that you cannot get too far away by forgetting a quote character
16:40:37 <Saizan> jsnx: to have the equivalent of help() in the python interpreter
16:42:26 <jsnx> Saizan: yes, i see
16:42:34 <xpika> @pl (\f x y -> compare (f x) (f y))
16:42:34 <lambdabot> flip =<< (((.) . compare) .)
16:42:35 <jsnx> Saizan: that is one way
16:42:42 <xpika> lambdabot: nice!
16:42:47 <oerjan> xpika: comparing
16:43:09 <oerjan> also compare `on`
16:43:24 <xpika> oerjan: on?
16:43:25 <jsnx> Saizan: actually, probably better than having multiline strings and jettisoning comments -- because then you can tell them apart
16:43:33 <oerjan> a new function in 6.8
16:43:45 <faxathisia> @src on
16:43:45 <lambdabot> (*) `on` f = \x y -> f x * f y
16:43:56 <xpika> which import is on?
16:44:01 <oerjan> Data.Function
16:44:25 <jsnx> :t comparing
16:44:26 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
16:44:37 <jsnx> :t compare `on`
16:44:38 <lambdabot> parse error (possibly incorrect indentation)
16:44:51 <oerjan> :t (compare `on`)
16:44:51 <lambdabot> Not in scope: `on'
16:44:56 <jsnx> :t on compare
16:44:57 <lambdabot> Not in scope: `on'
16:45:04 <oerjan> @version
16:45:04 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
16:45:04 <lambdabot> darcs get http://code.haskell.org/lambdabot
16:45:17 <xpika> @info comparing
16:45:18 <lambdabot> comparing
16:45:29 <oerjan>  @info is not what you think it is
16:45:51 <oerjan> @indo do { x <- get; put (x+1); return x }
16:45:51 <lambdabot> get >>= \ x -> put (x + 1) >> return x
16:46:01 <blackdog> hey, is there a canonical way of memoising function calls in haskell? i keep threading dictionaries around and it's a bit clunky - is lifting it all into a state monad the way to go?
16:46:11 <oerjan> er, @info -> @undo
16:46:34 <oerjan> @go tying-the-knot
16:46:35 <lambdabot> http://www.1049films.com/
16:46:36 <lambdabot> Title: Tying the Knot - The Movie
16:46:39 <Botje> blackdog: unsafeperformio *ducks*
16:46:39 <oerjan> er not that
16:46:41 <faxathisia> lol
16:46:54 <blackdog> Botje: filthy beast :)
16:47:14 <Botje> memoising stuff is inherently stateful anyway
16:47:25 <blackdog> that's true
16:47:31 <oerjan> http://haskell.org/haskellwiki/Memoization
16:47:45 <oerjan> Botje: not in haskell :)
16:48:11 <Botje>  ooh
16:48:16 <Botje> the page got updated
16:48:28 <Botje> it lists more than just the !! trick now
17:04:16 <Saizan> ?type packAddress
17:04:18 <lambdabot> Not in scope: `packAddress'
17:04:29 <Saizan> ?type Data.ByteString.Base.packAddress
17:04:29 <lambdabot> GHC.Prim.Addr# -> Data.ByteString.Base.ByteString
17:05:57 <dons> you should know what you're doing if you use that :)
17:06:06 <dons> its unsafe* in recent bytestrings, in fact
17:10:07 <xpika> @pl \x-> (x,x)
17:10:07 <lambdabot> join (,)
17:10:33 <oerjan> also id &&& id
17:13:31 <dozer> evening
17:15:35 <ClaudiusMaximus> should this ever happen?  *** Exception: Text/XML/HaXml/Combinators.hs:(135,0)-(137,36): Non-exhaustive patterns in function find
17:16:11 <dons> that should be reported as a bug to the haxml authors
17:16:24 <dons> non-exhautive patterns in libraries are bad style, and make client code more fragile
17:16:33 <dons> (they mustn't have compiled with -Wall)
17:17:15 <oerjan> cannot be the usual Data.List.find for sure...
17:17:23 <ClaudiusMaximus> think i'll try the latest version, if possible
17:17:32 <ClaudiusMaximus> then see if the bug is still there..
17:18:15 <LoganCapaldo> Data.Maybe has a bug! fromJust ;)
17:18:43 <dmwit> Prelude has a bug! head ;)
17:19:31 <dcoutts> anyone else want to add more detail on a RubyGems vs Cabal comparison?
17:19:32 <dcoutts> http://hackage.haskell.org/trac/hackage/wiki/RubyGems
17:19:33 <lambdabot> Title: RubyGems - Hackage - Trac
17:20:00 <dcoutts> to see what lessons we can learn from gems and if there are any obvious features or good ideas we're missing
17:20:40 <dcoutts> if anyone's actually used ruby and gems their contributions would be especially appreciated
17:21:01 * dcoutts has only read the RubyGems web pages a little
17:21:05 <dons> dcoutts: ask on the -cafe@, there are definitely users there
17:21:17 <LoganCapaldo> I've used rubygems
17:21:22 <dcoutts> dons: aye, good idea
17:21:27 <LoganCapaldo> as a consumer anyway
17:22:00 <dcoutts> LoganCapaldo: feel free to add a section on that wiki page about what you thought of the system and/or how it compares to cabal
17:22:33 <LoganCapaldo> is cabal safe against poisoning?
17:22:44 <dcoutts> LoganCapaldo: to edit, login username "guest", passwd "haskell'" -- note the ' prime in password
17:23:01 <LoganCapaldo> I remmebr someone accidentally put up a gem w/ the same name as an existing gem and wreaked all sorts of havoc
17:23:20 <LoganCapaldo> (that's been fixed)
17:23:36 <dcoutts> LoganCapaldo: yes that'd currently add a new version, or overwrite an existing version
17:23:47 <dcoutts> LoganCapaldo: anyone can upload any package
17:24:29 <Saizan> is there any significant gain in using unsafePackAddress for a bunch of static strings?
17:24:32 <dcoutts> LoganCapaldo: what is enforced for gems now?
17:24:46 <LoganCapaldo> I don't recall exactly the fix
17:25:01 <dcoutts> LoganCapaldo: was it just a fix on RubyForge? since anyone can run a gems server
17:25:01 <LoganCapaldo> I wasn't personally bitten by it, but there was much hue and cry on the ML
17:25:13 <LoganCapaldo> it may have been a fix specifc to rubyforge
17:26:23 <LoganCapaldo> the prompting to install deps has changed, I believe the default now is to install dependencies unless you ask it not  to
17:27:00 <dcoutts> ah
17:27:12 <dcoutts> LoganCapaldo: feel free to make corrections or additions to that wiki page
17:29:09 <LoganCapaldo> Is cabal part of ghc?
17:29:17 <dcoutts> LoganCapaldo: no, separate project
17:29:28 <LoganCapaldo> I ask because as of 1.9 gems is now part of ruby
17:29:29 <dcoutts> but it's distributed with ghc and other haskell implementations
17:29:53 <LoganCapaldo> well distributed with it may be a better way of putting it
17:29:56 <LoganCapaldo> no
17:30:00 <LoganCapaldo> it's part of of it
17:30:11 <LoganCapaldo> definitely part of it
17:30:16 <dcoutts> LoganCapaldo: presumably that means it's part of the standard set of ruby libraries and tools
17:30:36 <dcoutts> LoganCapaldo: if so, it's the same as Cabal's relationship with the haskell implementations
17:30:47 <dcoutts> Cabal is a "core" lib for ghc.
17:31:05 <LoganCapaldo> well they've added new command line options to the ruby executable
17:31:11 <LoganCapaldo> eg ruby --disablegems
17:31:35 <LoganCapaldo> since it's now loaded by default
17:31:45 <LoganCapaldo> oh that's probably a huge difference
17:32:02 <dcoutts> what other stuff does such integration give?
17:32:15 <LoganCapaldo> unlike cabal (i think) rubygems changes ruby's lib location resolution mechanism
17:32:35 <LoganCapaldo> (it always did that)
17:32:35 <dcoutts> right, cabal just works with ghc's notion of a registered package
17:32:40 <Saizan> newtype Foo m a = Foo (m a) deriving (Monad,MonadError String) <-- this should compile, right? i get a No instance for MonadError String m error
17:33:18 <LoganCapaldo> and gems notion of what gem is "active" is per process
17:33:31 <LoganCapaldo> (for when you have multiple versions)
17:34:03 <LoganCapaldo> sorry I should jsut be editing the wiki
17:34:05 <LoganCapaldo> heh
17:34:07 <oerjan> Saizan: paste?
17:34:23 <dcoutts> LoganCapaldo: ghc allows packages to be selected as command line parameters, eg -package Foo-1.0 or -package Foo-1.1
17:34:31 <oerjan> or do you mean just that line fails?
17:34:36 <LoganCapaldo> dcoutts: mm
17:34:51 <dons> mmm.  http://blog.whoop.as/?p=1665
17:34:53 <lambdabot> Title: Emacs love w/ Haskell » Ignorance is Underrated
17:34:58 <dons> unicode emacs haskell
17:35:24 <hpaste>  Saizan pasted "deriving error" at http://hpaste.org/4800
17:35:35 <dons> someone should work out what eh's doing there, and publicise it
17:35:43 <Saizan> oerjan: just that line however
17:35:56 <dcoutts> LoganCapaldo: ghc already had a farily sophisticated notion of a registered package before cabal came along
17:35:57 <wolverian> I want that for vim
17:36:08 <LoganCapaldo> yeah
17:36:31 <LoganCapaldo> is there a CPAN analog site on the wiki too?
17:36:43 <wolverian> hackagedb
17:36:49 <oerjan> weird
17:37:09 <dons> LoganCapaldo: hackage.haskell.org
17:37:10 <LoganCapaldo> wolverian: analog to the rubygems page on the wiki ;)
17:37:22 <wolverian> oh, where's that?
17:37:23 <LoganCapaldo> hackage vs. cpan
17:37:31 <LoganCapaldo> is what I was asking
17:37:43 <wolverian> yeah, haven't seen that, but then again I hadn't seen hackage vs gems either
17:37:54 <wolverian> ah, found it
17:38:03 <dcoutts> LoganCapaldo: no, no similar comparison, but if someone wants to start one then feel free
17:38:07 <Saizan> oerjan: do you have an older ghc to test it? like 6.6.*
17:38:41 <oerjan> er, no
17:38:43 <LoganCapaldo> dcoutts: I wouldn't even now where to start on that one but it seems like that would be the first comparision to come to mind. I guess gems "feels" a little bit more like cabal
17:39:03 <oerjan> full disclosure: i _still_ haven't installed ghc
17:39:21 <dcoutts> LoganCapaldo: right, that's why I started writing the comparison
17:40:00 <magnus> I have a type system problem: http://magnus.hcoop.net/bla.hs.txt
17:40:07 <magnus> it is reduced from a more complicated problem I have
17:41:14 <magnus> the problem is that the inner definition of g has a too strict type
17:41:38 <magnus> it doesn't preserve h::a->a when h is passed as parameter k
17:41:51 <wolverian> I would gladly contribute to a CPAN page on the wiki
17:42:09 * LoganCapaldo is trying to delegate to the gems maintainer
17:42:13 <LoganCapaldo> ;)
17:42:34 <wolverian> :)
17:42:44 <wolverian> cpan is perhaps interesting in the sense that it is goddamn huge
17:42:47 <oerjan> Saizan: oh wait.  i think the problem is you have no actual data constructor in the field?  i.e. (m a)
17:43:05 <oerjan> or is that allowed, hm
17:43:32 <wolverian> has a large network of mirrors, is made up of components (pause, search.cpan, various other frontends), has a liberal upload policy
17:44:15 <wolverian> also perl6's versioning policy is relevant here, mainly because perl5 doesn't have such a thing, so there are all kinds of versioning schemes in use on cpan, and the special cases that's led to in clients are.. interesting
17:44:44 <magnus> Is there any type system extension feature that can make the following well typed? let g k = (k 2,k "hi") in g id
17:45:59 <oerjan> magnus: higher rank types
17:46:26 <Saizan> oerjan: it's the same if e.g. you have ReaderT String m a
17:46:33 <magnus> aha, finally I have run into what higher rank types are good for :)
17:47:20 <LoganCapaldo> I added a bit about the .gem format
17:47:44 * Saizan supposes he's the first to build lambdabot with 6.8.2
17:47:54 <LoganCapaldo> He says "For a 10,000ft overview it's great"
17:48:13 <wolverian> is the wiki open to edit?
17:48:34 <LoganCapaldo> there's a guest acct. guest / haskell'
17:49:18 <oerjan> mbot has 6.8
17:50:17 <oerjan> Saizan: does the example from the ghc users guide work:
17:50:20 <oerjan> newtype Parser tok m a = Parser (State [tok] (Failure m) a) deriving (Monad, StateMonad [tok])
17:55:03 <Saizan> oerjan: using
17:55:10 <Saizan> MonadState it works
17:55:31 <Cin> does ghc ever memoize pure functions?
17:55:37 <oerjan> oh a typo
17:56:43 <Cin> i suppose a pure function of a certain set of arguments is just a thunk waiting to be evaluated and once you evaluate it the value sticks
17:56:52 <Cin> kind of memoziation in effect
17:57:30 <Cin> interrupt me if i'm wrong, please
17:58:12 <dcoutts> Cin: so yes, that gives limited memoisation
17:58:19 <Saizan> well, it doesn't memoize between function calls, but if you still have a reference to the same value it won't be recomputed
17:59:32 <Cin> saizan: why doesn't it? insane memory usage?
18:00:58 <Saizan> Cin: i think it's hard to deduce when it would be a win
18:02:55 <Cin> saizan: i guess so. hard to say how often a function really gets called with the same arguments, even if you accept the memory usage
18:04:42 <ToxicFrog> If you have overlapping subproblems (say, recursive fibonnachi as a trivial case) it can be a big win, or if you have a function that won't be called with the same arguments a -lot-, but is hugely expensive.
18:04:55 <ToxicFrog> But yeah, it's not something you can apply globally in a useful manner.
18:06:07 <Cin> makes sense
18:10:13 <Kirakishou> Did ever a dude come in here
18:10:22 <Kirakishou> and ask about how to write a ray-tracer?
18:11:38 <lament> that seems likely
18:22:09 <Kirakishou> I meant specifically
18:22:15 <Kirakishou> lately
18:22:28 * pragma_ searches and replaces in his IRC client.
18:22:38 * pragma_ has the drop on 1984.
18:22:59 <pragma_> ERC ftw!
18:23:54 * BMeph wonders if Oleg's looked into using the type system to implement a ray tracer engine...
18:25:36 <oerjan> @quote ray-trac
18:25:36 <lambdabot> No quotes match.
18:25:55 <oerjan> @quote in-the-type-system
18:25:55 <lambdabot> No quotes match. Where did you learn to type?
18:26:02 <oerjan> oh wait
18:26:07 <oerjan> @quote ray.trac
18:26:07 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
18:26:16 <oerjan> @quote type.system
18:26:16 <lambdabot> augustss says: Given that strength of the Haskell type system it wouldn't be that hard to write a compiler from some language into a Haskell type.
18:26:22 <oerjan> @quote type.system
18:26:22 <lambdabot> dons says: the type system is *great* for coding while sleepy.. you just hack any garbage together, and let the type checker deal with it
18:26:39 <oerjan> @quote ray
18:26:39 <lambdabot> ray says: ask your doctor if haskell is right for you. side effects may include: NOTHING
18:26:42 <oerjan> @quote ray
18:26:43 <lambdabot> ray says: ask your doctor if haskell is right for you. side effects may include: NOTHING
18:26:46 <oerjan> bah
18:27:04 <oerjan> i was nearly sure i'd seen such a quote
18:27:28 <oerjan> @quote leg.*system
18:27:28 <lambdabot> simonpj says: Maybe if I had an Oleg implant I could express all this in the type system
18:27:33 <oerjan> @quote leg.*system
18:27:33 <lambdabot> shapr says: The legal system is the ultimate denial of service attack.
18:27:40 <oerjan> @quote leg.*system
18:27:40 <lambdabot> shapr says: The legal system is the ultimate denial of service attack.
18:27:47 <oerjan> @quote [Oo]leg.*system
18:27:47 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
18:27:53 <oerjan> @quote [Oo]leg.*system
18:27:54 <lambdabot> simonpj says: Maybe if I had an Oleg implant I could express all this in the type system
18:27:57 <ray> i remember something about a ray tracer in the type system too, if that makes you feel better
18:28:37 <ray> i think it was in the topic
18:31:13 <Kirakishou> hmm
18:31:39 <ray> i remember lots of things people say about ray tracers on irc, actually ;)
18:32:14 <LoganCapaldo> There's gotta be a raymond  tracer out  there somewhere
18:32:19 <oerjan> cannot imagine why.  you got it on highlighting or something? ;)
18:32:39 <ray> probably a bug in my client
18:33:41 <Korollary> @go Raymond Tracer
18:33:42 <lambdabot> http://www.geocities.com/jamisbuck/raytracing.html
18:33:43 <lambdabot> Title: The Recursive Ray Tracing Algorithm
18:34:21 <LoganCapaldo> Korollary: I found some stuff
18:34:34 <LoganCapaldo> @go "raymond tracer"
18:34:35 <lambdabot> http://www.classmates.com/directory/school/Thomas%20Jefferson%20High%20School_9.jsp?org=4924
18:34:35 <lambdabot> Title: Thomas Jefferson High School, Auburn, Washington (WA)
19:03:09 <hpaste>  mmorrow annotated "backspace" with "time +/- -threaded" at http://hpaste.org/4787#a2
19:03:57 <Kirakishou> Now, about these ray tracers
19:04:16 <Kirakishou> more specifically, about 3D file formats,
19:04:38 <Kirakishou> there are libraries to parse those, right?
19:07:03 <LoganCapaldo> povray is fun
19:10:40 <sclv> from aways back: haskell extended unicode (there's a basic haskell unicode mode too that does arrows, double arrows, lambdas and function composition only)
19:10:43 <sclv> http://www.emacswiki.org/cgi-bin/wiki/PrettyLambda>
19:20:41 <bos> wah! haddock doesn't understand funky type constructors@!
19:21:50 * oerjan vaguely recalls there being a haddock-ghc which understands more
19:23:02 <bos> yeah.
19:23:13 <bos> it will become the default in ... a long time, i think.
19:48:45 <glguy> ?seen alexj
19:48:46 <lambdabot> alexj is in #ghc, #darcs and #haskell. I don't know when alexj last spoke.
19:50:20 <glguy> ?seen shapr
19:50:20 <lambdabot> Last time I saw shapr was when I left #darcs, #ghc and #haskell 18d 22h 3m 59s ago, and .
19:51:13 <glguy> ?uptime
19:51:13 <lambdabot> uptime: 1d 21h 27m 54s, longest uptime: 1m 10d 23h 44m 29s
19:52:08 <Korollary> shapr hasn't been gone for 18 days
19:52:42 <allbery_b> no, but LB lost its mind a couple days ago
20:30:15 <scook0> @type foldl'
20:30:17 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:48:30 <bos> god, the polymorphism of types in Text.Regex.* makes it a nightmare to work with.
20:53:04 <dons> i've got a replacement, Text.Regex.PCRE.Light that is more like old school Text.Regex
20:53:24 <dons> hopefully one that doesn't break on each ghc release
20:53:53 <bos> whew.
20:54:50 <bos> john meacham wrote an amusing comment on my blog tutorial about regexes: "Is it ironic I had to read this tutorial to remember how to use the regex syntax I invented in the first place? hmmâ€¦."
20:55:01 <dons> heh.
20:55:18 <bos> dons: is your replacement out yet?
20:55:20 <dons> too much overloading is bad in any language
20:55:41 <dons> not yet, almost done. probably done by monday
20:55:46 <dons> a couple of hours work left on it
20:59:07 <bos> ok, cool.
21:00:15 <dons> just pushing the IsString instance for ByteStrings!
21:00:18 <dons> (finally!)
21:07:53 <dons> mm,bytestring literals rock,
21:07:54 <dons>   Prelude Text.Regex.PCRE.Light Data.ByteString.Char8> pcre_compile "a(.*)b" Nothing
21:08:16 <dons> pcre_compile :: ByteString -> Maybe PCREOption -> Either String Regex
21:22:56 <pastorn> dons: pcre being short for?
21:23:08 <Cale> Perl Compatible Regular Expression
21:24:10 <wolverian> dons, nice
21:26:04 <dons> bytestring 0.9.0.4, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-0.9.0.4
21:26:06 <lambdabot> http://tinyurl.com/2j9qya
21:26:09 <dons> with support for bytestring literals.
21:26:20 <dons> (use -XOverloadedStrings)
21:30:51 <jz87> hey dons
21:30:56 <dons> yo
21:31:03 <jz87> we should really group bytestring and String into some type class
21:31:15 <wolverian> hm, why doesn't cabal-install see it?
21:31:24 <jz87> this way libraries can be written against it and compiled against either one without breaking
21:31:25 <dons> cabal update first, wolverian
21:31:29 <wolverian> I did
21:31:31 <dons> jz87: it'd be a big type class
21:31:46 <jz87> I was trying to use haxr with my recompiled network library
21:31:48 <jz87> using bytestrings
21:32:08 <jz87> I ended up converting back to the standard Network library
21:32:28 <dons> $ cabal install bytestring-0.9.0.4
21:32:28 <dons> Downloading 'bytestring-0.9.0.4'...
21:32:29 <dons> ...
21:32:37 <jz87> because to use the bytestring Network library I would have to convert haxr and haxml and whatever else it depends on
21:32:38 <wolverian> why the explicit version?
21:32:39 <dons> jz87: which network library supports bytestring?
21:32:50 <jz87> well there is a version floating around out there
21:32:51 <dons> that's right. they use explicit pattern matching and so on.
21:32:53 <jz87> that uses bytestring
21:32:57 <dons> so its non-trivial to convert
21:33:01 <dons> ah,network-bytestring
21:33:04 <wolverian> install doesn't update by default? weird
21:33:10 <dons> right.
21:33:21 <wolverian> so how do I update things without specifying versions?
21:33:40 <wolverian> (I should say 'upgrade')
21:33:41 <jz87> yeah, I was thinking that bytestrings can be Haskell's version of Erlang's bit syntax expressions
21:34:11 <jz87> which makes protocol programming really convenient
21:34:21 <davidL> there is a bitsyntax module in hackage
21:34:28 <jz87> aha
21:34:33 <dons> and Data.Binary also makes that a lot easier
21:34:36 <davidL> I've never used it, I stick to Data.Binary
21:34:39 <wolverian> I suppose I shouldn't complain about a beta :)
21:34:43 <dons> given that its all for parsing binary stuff out of bytestrings :)
21:37:23 <jz87> the program is how do we deal with the fact that a ton of libraries are written to use Strings
21:37:35 <jz87> but they would benefit performance wise from using bytestrings?
21:38:08 <dons> yes, lots would. there's a growing shift towards a full bytestring stack for network and parsing stuff
21:38:31 <dons> we've bytestring-network/binary/http now, along with regexes and readp parsers
21:38:33 <jz87> yeah, I really would like to use bytestring more
21:38:51 <jz87> but the libaries aren't there yet
21:39:14 <dons> well, the xml parser would be the big one.
21:39:19 <jz87> yes
21:39:21 <dons> that simply doesn't exist. but a lot of the others are in place.
21:39:29 <jz87> having the xml parser bytestringed
21:39:32 <jz87> would go a long way
21:39:36 <dons> i've got a back project to port the galois xml-light library to bytestrings in the next few months
21:39:38 <jz87> toward making bytestring generally usable
21:39:41 <dons> so expect it before the end of the year
21:40:09 <dons> and there's a readp for bytestrings now, so i'd also expect bytestring-json, and other bytestring format parsers to follow
21:40:23 <jz87> I was looking at readp
21:40:29 <jz87> there isn't a lot of documentation on it
21:40:34 <jz87> I'm used to parsec
21:40:48 <jz87> I know readp uses parallel parsing
21:41:05 <Cale> jz87: If you know parsec, ReadP is easy.
21:41:17 <jz87> well, mostly I just need to know what's different
21:41:33 <jz87> there isn't a lot of documentation on the differences
21:41:38 <Cale> The main difference is that you'll be using +++ instead of <|>
21:42:05 <jz87> well readP does parsing in parallel right?
21:42:07 <Cale> and typically to run a parser, you use readP_to_S
21:42:09 <jz87> in terms of performance
21:42:24 <jz87> well I'm interested in the performance characteristics of this feature
21:42:37 <jz87> in terms of defining grammars I know it'll make my life easier
21:42:38 <dons> a lot of people could help here, by chipping in bytestring parsers for their favourite formats
21:42:42 <Cale> It processes branches "in parallel", but that doesn't mean that it's written to take advantage of multiprocessors.
21:42:51 <dons> to get lots of them though, we need a reliable parser that's been highly tuned
21:42:55 <jz87> I was just thinking of writing a AMF3 adapter
21:42:58 <Cale> It just means that it won't hang on to the beginning of the input string.
21:43:02 <jz87> since adobe has jsut released the format
21:43:10 <jz87> I write a lot of flash front ends
21:43:10 <dons> i guess duncan and i'll have to work on that (using knowledge of how bytestrings are optimised)
21:44:33 <jz87> I guess my confusing with parallel parsing is
21:44:48 <jz87> does it try all the combinations?
21:45:05 <jz87> in Parsec
21:45:21 <jz87> if I write string "Pat" <|> "Pop"
21:45:29 <jz87> this would not parse "Pop"
21:45:36 <glguy> string "Pop"
21:45:39 <jz87> because the parser by default doesn't backtrack
21:45:44 <jz87> yes, sorry
21:45:58 <glguy> nvm, unneeded correction :)
21:46:19 <jz87> does parallel mean that readP parses both?
21:46:20 <Cale> Yeah, it'll try them all
21:46:25 <Cale> +++ is commutative
21:46:29 <jz87> isn't that really inefficient though?
21:46:39 <Cale> p +++ q is the same as q +++ p for all parsers p and q
21:46:54 <glguy> ReadP++
21:46:56 <Cale> Well, ordinarily, but it uses a trick to make it more efficient.
21:47:01 <jz87> oh?
21:47:03 <jz87> what does it do?
21:47:18 <jz87> because the tree of potential parses can grow pretty quickly
21:47:21 <jz87> which I'm worried about
21:47:31 <jz87> if I'm going to implement non-trivial parsers in readP
21:48:43 <sclv> related: if there are two possible valid parses, how does it know which to pick?
21:49:29 <glguy> picks both
21:49:30 <Cale> Well, it's possible to write parsers which are themselves inefficient.
21:49:49 <Cale> (or design languages for which any parser will be inefficient)
21:49:55 <jz87> readS returns a list of possible parses
21:50:11 <Cale> But ReadP takes pains not to hang on to the beginning of the input any longer than it has to.
21:50:31 <jz87> well I guess my question then is
21:50:40 <glguy> <++ is the left-biased exclusive combinator
21:50:41 <jz87> what sort of things would I do in parsec
21:50:46 <jz87> that I don't have toworry about
21:50:48 <Cale> That is, each of the branches tries to advance down the string in parallel, so that the beginning of the input can be GC'd
21:50:51 <glguy> so  a <++ b   will only use b if a consumes no input
21:50:52 <jz87> that I should worry about in readP
21:51:01 <Cale> Well, there's no more 'try'.
21:51:33 <sclv> glguy: so then if you get a list of parallel parses, are there guarantees about the order of the list?
21:51:39 <jz87> so basically readP is like parsec with try by default?
21:51:45 <Cale> I suppose a weakness of the library relative to Parsec is the error reporting isn't so nice.
21:52:03 <Cale> jz87: Yes, though parsec is much more inefficient than ReadP if you use it like that.
21:52:05 <glguy> sclv, parses that consume more of the string will be listed later
21:53:43 <jz87> so basically readS produces all possible parses
21:54:29 <jz87> and I just have to be careful about branches
22:21:08 <Kirakishou> http://www.haskell.org/haskellwiki/Image:Lambdabot.png
22:21:09 <lambdabot> Title: Image:Lambdabot.png - HaskellWiki
22:21:15 <Kirakishou> ...wtf?
22:22:03 <jsnx> lambdabot is hawt
22:22:23 <jsnx> she looks like a south park character
22:24:49 <allbery_b> @topic-tell #haskell-blah
22:24:49 <lambdabot> Anything BUT Haskell (especially SEX!) -|- add yourself to the collection -> http://www.elis.ugent.be/~kehoste/haskell-blahSouthPark.html -|- lambdabot's first words: "Ooh, functional programmers
22:24:49 <lambdabot> are so hot" -|- current topic: Who needs #haskell when there's #haskell-blah ! (oh yeah, and Happy Xmas and Merry New Year and all that)
22:24:59 <allbery_b> note second element :)
22:25:01 <ari> jsnx: That's because it was (probably) generated with http://sp-studio.de/
22:25:02 <lambdabot> Title: Planearium.de presents: SP-Studio.de
22:46:59 <dons> ?users
22:46:59 <lambdabot> Maximum users seen in #haskell: 435, currently: 376 (86.4%), active: 9 (2.4%)
22:47:14 <jql> now it's 10
22:51:59 <jfredett> 10.5, I'm half watching chat, :)
22:52:29 <allbery_b> if LB still tracks activity the way my slightly older version does, you two already counted
22:52:58 <jfredett> ah,
22:53:03 <jfredett> lets pretend it doesn't
22:53:06 <jfredett> :)
22:53:25 <allbery_b> (it doesn't actually distinguish between channels when determining activty, so you're both "active" here even though youw ere in #haskell-blah and #perl6)
22:54:40 <xpika> @type safehead
22:54:43 <lambdabot> Not in scope: `safehead'
22:55:25 <xpika> @type genericHead
22:55:26 <allbery_b> the Safe library isn't standard.  but isn't it [a] -> Maybe a ?
22:55:26 <lambdabot> Not in scope: `genericHead'
22:55:52 <xpika> allbery_b: maybe.
22:59:42 <xpika> > listToMaybe [1..5]
22:59:44 <lambdabot>  Just 1
23:00:01 <xpika> @hoogle listToMaybe
23:00:02 <lambdabot> Data.Maybe.listToMaybe :: [a] -> Maybe a
23:23:00 <yoshi> what function would I use to go from "123" -> ["1","2",3"] ?
23:23:21 <jsnx> yoshi: unfoldr is one
23:23:29 <yoshi> ah thanks
23:23:35 <Lemmih> > map (:[]) "123"
23:23:35 <lambdabot>  ["1","2","3"]
23:23:47 <jsnx> oh, i guess there's that, too :)
23:25:22 <Lemmih> There's no such thing as too many smileys in your code.
23:31:58 <glguy> *Main> :t liftMn ?f $ getLine :> readFile "" :> ()
23:31:58 <glguy> liftMn ?f $ getLine :> readFile "" :> () :: (?f::String -> String -> a) => IO a
23:34:30 <xpik2> why is it when I define my function it goes from being Integral a => [a] -> Maybe [a] to [Integer] -> Maybe [Integer]
23:38:34 <TSC> Defaulting, perhaps
