00:04:57 <sizur> @users
00:04:58 <lambdabot> Maximum users seen in #haskell: 436, currently: 388 (89.0%), active: 2 (0.5%)
00:17:45 <hpaste>  stick_figure pasted "GHC Error" at http://hpaste.org/5212
00:17:59 <stick_figure> I was just happily hacking Haskell, and when I go to compile a binary, ghc tells me: http://hpaste.org/5212
00:18:48 <stick_figure> Does anyone have any idea what that means?  Should I reinstall GHC?  I could compile binaries consistently minutes ago, then it broke.  It may have to do with adding a module declaration.
00:19:24 <stick_figure> It does, wtf, if I add a module declaration GHC rejects my code.  Any ideas as to why?
00:20:15 <sjanssen> stick_figure: is there a 'main' function?
00:20:23 <sjanssen> stick_figure: is the module called 'Main'?
00:20:24 <stick_figure> yes
00:20:27 <stick_figure> no
00:20:50 <sjanssen> the main module must be called Main (unless you use the -main-is flag)
00:21:08 <stick_figure> Oh.  Whoops.
00:21:16 <stick_figure> Thanks!
00:30:48 <Cale> stick_figure: btw, the only other source of link errors is when you use modules from other packages and don't provide the --make flag (or package flags for each package).
00:46:00 <Altair^> how can I read data from file until the next whitespace?
00:48:32 <faxathisia> Altair^, Maybe you could read tho entire file, lazily.. then takeWhile (/=' ')
00:49:18 <faxathisia> actually, You'd need a takeWhile that gives the tail as well.. so break (==' ')
00:49:40 <Cale> Alternately, use hGetChar in a loop with a test.
00:50:20 <Cale> (Too bad there's no untilM/whileM in the libraries.)
00:52:23 <Cale> !paste
00:52:24 <hpaste> Haskell paste bin: http://hpaste.org/
00:52:44 <hpaste>  Cale pasted "hGetWord via untilM" at http://hpaste.org/5213
00:53:14 <Cale> Note that it also eats the space at the end of the word without returning it.
00:53:58 <Cale> Altair^: still here? :)
00:56:22 <sizur> :t until
00:56:25 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
00:56:44 <sizur> :t liftM3 until
00:56:45 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> m (a -> a) -> m a -> m a
00:59:44 <sizur> > (^2) <$> listToMaybe []
00:59:46 <lambdabot>  Nothing
01:01:05 <sizur> > [1,2] `mappend` [3,4]
01:01:07 <lambdabot>  [1,2,3,4]
01:01:29 <sizur> > mempty :: [Int]
01:01:29 <lambdabot>  []
01:03:08 <sizur> hmm, i wonder if it's possible to extend laziness to type determination
01:03:43 <sizur> where a value stays polymorphic until one actually needs to use it
01:04:32 <roconnor> ?
01:04:37 <sizur> mm, s/type/value
01:04:38 <roconnor> types are static
01:05:02 <sizur> yeah, that prevents something like this
01:05:23 <sizur> where i wouldn't need to annotate mempty (for example)
01:05:41 <sizur> in the above evaluation
01:06:38 <sizur> will i gues sis does not make sense
01:06:50 <sizur> * i guess it *
01:07:16 <sizur> :t mempty
01:07:16 <lambdabot> forall a. (Monoid a) => a
01:08:05 <sizur> > map id mempty
01:08:05 <lambdabot>  []
01:08:50 <sizur> :t map Just mempty
01:08:51 <lambdabot> forall a. [Maybe a]
01:11:36 <sizur> > [1,2] >> [3,4]
01:11:37 <lambdabot>  [3,4,3,4]
01:13:47 <sizur> > :t (>>=)
01:13:49 <lambdabot>   parse error on input `:'
01:13:54 <sizur> :t (>>=)
01:13:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
01:14:54 <sizur> > [1,2] >>= (\n->[n])
01:14:55 <lambdabot>  [1,2]
01:15:26 <sizur> > [1,2] >>= \n->[n,n]
01:15:26 <lambdabot>  [1,1,2,2]
01:16:23 <faxathisia> > [1,3,..] >>= \n->[n,n+1]
01:16:24 <lambdabot>  Parse error at "..]" (column 6)
01:16:27 <faxathisia> > [1,3..] >>= \n->[n,n+1]
01:16:27 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
01:17:23 <sizur> > do { n <- [1,2,3]; return $ if n<2 then [] else n }
01:17:24 <lambdabot>   add an instance declaration for (Num [a])
01:17:52 <sizur> > do { n <- [1,2,3]; if n<2 then [] else [n] }
01:17:53 <lambdabot>  [2,3]
01:18:12 <faxathisia> > filter (<2) [1,2,3]
01:18:13 <lambdabot>  [1]
01:18:31 <sizur> i'm just trying to find uses for the list monad
01:19:03 <faxathisia> I have one
01:19:12 <faxathisia> select [] = [] ; select (x:xs) = (x,xs) : map (second (x:)) (select xs)
01:19:35 <Cale> > do x <- [1..20]; y <- [x..20]; z <- [y..20]; guard (x^2 + y^2 == z^2); return (x,y,z)
01:19:36 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
01:19:47 <faxathisia> (foo :=: bar, rest) <- select list
01:19:59 <faxathisia> (baz :=: quux, rest') <- select rest
01:20:08 <kmcallister> :t (:=:)
01:20:09 <lambdabot> Not in scope: data constructor `:=:'
01:20:12 <faxathisia> guard $ something here
01:20:20 <faxathisia> return $ something
01:20:43 <Cale> The list monad implements a basic kind of backtracking nondeterminism.
01:21:05 <sizur> Cale, that's nice one, but what about chaninig (>>)
01:21:06 <Cale> Which actually turns out to be just what you need in quite a lot of cases.
01:21:16 <Cale> sizur: >> isn't all that useful in the list monad
01:21:38 <Cale> It just causes duplication of elements.
01:21:44 <Cale> > [1,2,3] >> [4,5]
01:21:45 <lambdabot>  [4,5,4,5,4,5]
01:21:45 <sizur> then why is it implemented liek that if it's not useful?
01:21:52 <Cale> Because >>= is useful
01:22:05 <Cale> >> is just defined in terms of >>= always in the same way
01:22:14 <sizur> well that's good, but you can implement >> another way and still keep the monad laws
01:22:15 <Cale> (or at least, in an equivalent way)
01:22:25 <sizur> or no?
01:22:54 <Cale> You can implement it with a different algorithm, but whatever that algorithm gives had better be identical
01:23:19 <Cale> That is  x >> y = x >>= const y is a law which must be satisfied.
01:23:39 <Cale> Even if you choose to not implement it like that.
01:23:54 <sizur> ok i see
01:24:07 <sizur> Cale, thanks
01:24:11 <Cale> No problem
01:24:45 <Cale> Well, and >> is kind of useful still.
01:24:54 <Cale> It does the right thing with regard to guarding.
01:25:49 <Cale> > [1..100] >>= \x -> guard (x `mod` 3 == 0) >> guard (x `mod` 5 == 0) >> return x
01:25:50 <lambdabot>  [15,30,45,60,75,90]
01:25:51 <sizur> i suspect you can use >> well with [Maybe a] and at the end colapse all Nothings
01:26:05 <Cale> (and at the end with return)
01:26:21 <Cale> But on its own as a separate operation, it's not really very useful.
01:26:30 <sizur> no what i said is moot because [] is the same thing
01:26:44 <Cale> @src guard
01:26:44 <lambdabot> guard True  =  return ()
01:26:44 <lambdabot> guard False =  mzero
01:26:45 <sizur> :t guard
01:26:46 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
01:27:15 <Cale> mzero is [] for the list type, and of course, return () = [()]
01:27:27 <sizur> if i have a three step decision process, i can implement it with chaining >> in the list monad
01:27:32 <Cale> yes
01:28:08 <Cale> >> usually occurs after guards
01:28:14 <Cale> (in general)
01:29:27 <sizur> no, i'd need to use >>= still
01:29:46 <sizur> it's cool anyway
01:30:14 <Cale> Well, yeah, you still need >>= to bind the things which you're guarding.
01:34:10 <sizur> yeah, using guards is neat
01:35:16 <sizur> :t cycle
01:35:16 <lambdabot> forall a. [a] -> [a]
01:39:34 <sizur> > do { a <- cycle [1,2,3]; b <- [1,2,3]; guard (not (even (a*b))); return (a,b) }
01:39:37 <lambdabot>  [(1,1),(1,3),(3,1),(3,3),(1,1),(1,3),(3,1),(3,3),(1,1),(1,3),(3,1),(3,3),(1,...
01:40:28 <sizur> i have have only one infinite list and it must be bound first
01:40:46 <Cale> Of course, the plain list monad is identical to list comprehensions.
01:41:02 <sizur> yeah
01:41:07 <Cale> But one advantage it has over list comprehensions is that it can be transformed by monad transformers.
01:41:11 <Cale> Especially State
01:41:19 <sizur> aha
01:42:15 <Cale> State transformed list monads are a very handy way to explore game spaces or do (brute force) constraint optimisation.
01:42:21 <sizur> > [ (a,b) | a <- repeat 1; b <- repeat 2 ]
01:42:21 <lambdabot>  Parse error at ";" (column 24)
01:42:46 <sizur> > [ (a,b) | a <- repeat 1, b <- repeat 2 ]
01:42:48 <Cale> This is because the state "backtracks along with you".
01:42:48 <lambdabot>  [(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,...
01:43:24 <Cale> If you have more than one infinite choice to make, the list monad doesn't work so well.
01:43:25 <sizur> > [ (a,b) | a <- [1.., b <- repeat 2 ]
01:43:25 <lambdabot>  Parse error at "," (column 20)
01:43:42 <sizur> > [ (a,b) | a <- [1..], b <- [1..] ]
01:43:43 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),...
01:43:54 <Cale> > do { x <- [1..]; y <- [1..]; return (x,y) }
01:43:54 <sizur> nor list comprehensions
01:43:54 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),...
01:44:18 <faxathisia> @let pairs = concatMap pairsSummingTo [0..]  where pairsSummingTo n = map (\i -> (i, n-i)) [0..n]
01:44:20 <lambdabot> Defined.
01:44:23 <faxathisia> > pairs
01:44:23 <Cale> However there are more sophisticated monads which will work.
01:44:23 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
01:44:42 <Cale> I've actually been reading the paper on LogicT for the last couple hours. :)
01:44:58 <Cale> http://okmij.org/ftp/Computation/monads.html#LogicT
01:44:59 <lambdabot> Title: Monads
01:45:00 <sizur> interesting
01:45:49 <balodja> Hmm. Are ``do { x <- xs; y <- ys; e }'' and ``[ e | x <- xs, y <- ys ]'' the same?
01:46:16 <balodja> In terms of list monad.
01:46:20 <Cale> It turns out that apart from mzero and mplus, you only need one more operation to get lots of useful fair combination and backtracking control operations.
01:46:39 <Cale> balodja: stick a return e in there, and yes
01:46:49 <Cale> do { x <- xs; y <- ys; return e }
01:46:57 <faxathisia> msplit
01:47:03 <faxathisia> ?
01:47:04 <Cale> also, you can use the guard function to do the same thing as guards
01:47:07 <Cale> faxathisia: yes
01:47:20 <faxathisia> It's crazy what they've done :D
01:47:25 <Cale> msplit :: m a -> m (Maybe (a, m a))
01:47:49 <Cale> Basically, it's the same thing as splitting the head off a list (or giving Nothing when there's no element)
01:47:57 <quicksilver> Cale: that's the key to LogicT?
01:48:00 <Cale> yep
01:48:03 <quicksilver> interesting
01:48:09 <quicksilver> I've often wondered about that operation
01:48:17 <Cale> In terms of that operation, you can implement interleave, >>-, ifte and once
01:48:21 <quicksilver> It's a certain sort of dual to Monoid.
01:48:36 <Cale> yeah
01:48:53 <quicksilver> it's defineable in all free Monoids, at least.
01:48:56 <Cale> Or to MonadPlus
01:49:07 * quicksilver tries to think a bit harder
01:49:13 <quicksilver> it's probably only interesting in free monoids.
01:49:34 <shag> does someone know whether the parsec-manual can be found on a mirror or something? the original parsec website seems to be down...
01:49:44 <quicksilver> shag: there is always the wayback archive
01:50:01 <Cale> quicksilver: Well, in non-free monoids, it might be *more* interesting even :)
01:50:08 <Cale> Just harder to implement :)
01:51:02 <quicksilver> I'm not sure.
01:51:08 <osfameron> "free as in monoids" ?
01:51:13 <quicksilver> In non-free monoids you'd have infinite loops
01:51:21 <quicksilver> I'm not sure that's something you want from msplit.
01:51:39 <quicksilver> you'd be able to split the identity.
01:51:58 <Cale> Depends on the laws you subject it to.
01:52:29 <Cale> msplit mzero = return Nothing
01:52:48 <Cale> msplit (return a `mplus` m) = return (Just (a,m))
01:53:48 <quicksilver> right
01:54:00 <quicksilver> but in a non-free monoid, you couldn't guarantee that second lawy
01:54:01 <quicksilver> law
01:54:19 <quicksilver> because there would be more than one way to factorise return a `mplus` m
01:54:20 <Cale> Most likely.
01:54:32 <quicksilver> not most likely. definitely :)
01:54:58 <Cale> How are you sure that there's more than one way to factorise elements constructed in just that manner?
01:55:00 <quicksilver> if you have at least one non-trivial equation, you can find two different factorisations of at least one elemtn.
01:55:38 <quicksilver> I'm assuming here that the only generators are "return a" for all possible a.
01:55:47 <quicksilver> after all, that's the only elements we can care about, I think.
01:55:47 <Cale> Not every element of a non-free monoid would necessarily be return a `mplus` m for some (a,m)
01:56:02 <Cale> What are generators in a non-free monoid?
01:56:19 <Cale> er
01:56:22 <quicksilver> non-free monoids can be expressed by generators and relations.
01:56:40 <Cale> ah, okay
01:56:52 <Cale> So you're thinking of them as quotients of free monoids.
01:57:14 <Cale> However, we have monad structure here too.
01:57:21 * quicksilver nods
01:57:28 <quicksilver> I'm trying to ignore that bit
01:57:34 <Cale> Like, in the case of a Logic transformed IO monad
01:57:38 <quicksilver> that's true
01:58:18 <sizur> > fail "balba" :: [Int]
01:58:19 <lambdabot>  []
01:58:32 <Cale> sizur: fail is evil
01:58:44 <Cale> (just so you know)
01:59:06 <sizur> > fail "blabla" `mplus` [3]
01:59:06 <lambdabot>  [3]
01:59:08 <Cale> It's not really supposed to be part of the Monad class. It got stuck in there by mistake by the H'98 committee.
01:59:19 <sizur> yeah
01:59:39 <Cale> (for a not-so-clear reason)
02:00:04 <sizur> C-h f not-so-clear
02:00:17 <Cale> hm?
02:00:33 <aleator> I've got this weirdest problem with ghc. It hangs every time when I try to compile something. (No error or anything. Just doesn't)
02:00:49 <sizur> nothing, i'm a noob emacseka
02:00:50 <Cale> aleator: does this something involve zany types?
02:01:36 <aleator> Cale: No. 'module Main where main = print "Hello World"'
02:02:02 <Cale> aleator: Uh, okay, your copy of GHC must be broken.
02:02:18 <sizur> Cale, what's a better way to express a monadic failure if no fail?
02:02:33 <Cale> sizur: mzero, or a failure in a separate class.
02:02:39 <sizur> :t mzero
02:02:40 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
02:02:57 <ertai> @pl \x y z -> x + y * z
02:02:57 <lambdabot> (. (*)) . (.) . (+)
02:03:04 <aleator> Cale: Yep. I Did pull it from haskell.org though.
02:03:18 <Cale> aleator: which platform?
02:03:28 <Cale> aleator: You did get a binary release, right?
02:03:53 <ertai> @pl \x y z -> z + y * x
02:03:53 <lambdabot> ((+) .) . (*)
02:04:40 <Cale> aleator: If you're on Linux x86, the appropriate package is most likely http://haskell.org/ghc/dist/6.8.2/maeder/ghc-6.8.2-i386-unknown-linux.tar.bz2
02:04:41 <lambdabot> http://tinyurl.com/3cqaam
02:04:54 <aleator> Cale: Binary release, and platform being 2.6.17-1.2142_FC4smp. (Yes, that one was the package)
02:05:12 <aleator> Can multiple ghcs co-exist on same system?
02:05:26 <sizur> > mzero `mplus` [2] `mplus` mzero
02:05:26 <Cale> They should be able to.
02:05:27 <lambdabot>  [2]
02:05:39 <Cale> I have 6.6.1 and 6.8.2
02:06:06 <aleator> Hmm. How about if other is local install and by root?
02:06:56 <Cale> All the important stuff should go into separate paths under /usr/local/lib
02:08:13 <Cale> Moreover, there should be version-numbered scripts in /usr/local/bin which specify the appropriate paths.
02:09:13 <aleator> Humm. Yes. there are..
02:10:25 <aleator> Hmm. Gee. Now the original 6.4.1 is hanging just like the new one I installed at ~..
02:11:26 <Cale> Weird.
02:14:33 <aleator> ghci works fine..
02:23:49 <sizur> :t msum
02:23:50 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
02:25:05 <sizur> > Just 1 `mplus` Just 2
02:25:06 <lambdabot>  Just 1
02:26:08 <sizur> from name one can think there can be mmultiply, mdivide, mlog heh
02:26:21 <faxathisia> > [1,2,3] `mplus` [4,5,6]
02:26:22 <lambdabot>  [1,2,3,4,5,6]
02:26:42 <koeien> sizur: actually, no
02:26:56 <koeien> sizur: you only have a zero and a plus
02:27:05 <faxathisia> @src [] mplus
02:27:06 <lambdabot> mplus = (++)
02:27:08 <sizur> koeien, yes
02:27:22 <koeien> sizur: i wouldn't even want to think what mdivide would be :)
02:27:47 <sizur> or mlog
02:27:53 <koeien> yeah
02:28:09 <sizur> there is msum ;)
02:28:19 <sizur> that means we can have mmean lol
02:28:34 <sizur> maverage
02:31:54 <Cale> hmm, ring-structured monads
02:32:41 <Cale> (still, it wouldn't quite be, since mplus generally is not commutative)
02:33:29 <Cale> But the important property that an mtimes would have would be that  (a `mtimes` b) `mplus` (a `mtimes` c) = a `mtimes` (b `mplus` c)
02:33:45 <vali> in this haskell-book i'm reading, the author uses a symbol which looks like a circle with a +-symbol in it... is that xor? it's used for making "sections" i think
02:34:05 <Cale> Of course, such an operation already exists, specifically (f =<<) for any f.
02:34:41 <Cale> vali: It just represents an arbitrary operator symbol, most likely.
02:34:59 <Cale> > (*5) 5
02:35:00 <lambdabot>  25
02:35:06 <Cale> > (5+) 10
02:35:06 <lambdabot>  15
02:35:44 <Cale> > map (*5) [1..10]
02:35:45 <lambdabot>  [5,10,15,20,25,30,35,40,45,50]
02:36:06 <Cale> > map (`div` 2) [1..10]
02:36:07 <lambdabot>  [0,1,1,2,2,3,3,4,4,5]
02:36:21 <Cale> > map (/ 2) [1..10]
02:36:22 <lambdabot>  [0.5,1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0]
02:36:33 <Cale> > map (1/) [1..10]
02:36:34 <lambdabot>  [1.0,0.5,0.3333333333333333,0.25,0.2,0.16666666666666666,0.14285714285714285...
02:36:38 <mux> > map (`mod` 2) [1..10]
02:36:38 <lambdabot>  [1,0,1,0,1,0,1,0,1,0]
02:37:01 <Cale> vali: do those examples mesh with the usage in the book?
02:38:19 <vali> Cale: what do you mean mesh?
02:38:32 <Cale> Er, does it seem to agree?
02:38:45 <Cale> Or is the book using it in a different sense?
02:38:56 <vali> Cale: you are right, it makes sense if it's an arbitrary operator
02:39:00 <vali> thank you
02:39:06 <Cale> okay :)
02:39:14 <vali> i always think of xor when i see that symbol, so it was confusing me
02:39:17 <Cale> ah
02:40:28 <Cale> I always think of the direct sum of vector spaces :)
02:40:46 <Cale> V ⊕ W :)
02:41:22 <vali> oh, i know nothing about that
02:41:40 <_frederik_> hey can we use unicode symbols in ghc yet?
02:42:02 <quicksilver> you have been able to for many years, _frederik_
02:42:04 <quicksilver> 6.4, I think.
02:42:12 <_frederik_> oh, huh
02:42:21 <quicksilver> not ghci, though.
02:42:28 <quicksilver> ghci doesn't have working unicode input afaik.
02:42:32 <_frederik_> ok
02:42:38 <quicksilver> but ghc has read utf8-.hs files for a long time.
02:42:49 <_frederik_> even in non-comments?
02:42:50 <quicksilver> ghci 6.8.2 is supposed to have unicode input though :)
02:42:52 <quicksilver> yup
02:43:02 <_frederik_> cool
02:43:03 <quicksilver> it even uses the unicode class to decide if something is operator or identifier
02:43:23 <sizur> or a capital
02:43:25 <_frederik_> so what is the policy wrt unicode in standard libraries
02:43:47 <quicksilver> it's not used, I don't think.
02:43:48 <sizur> poeple avoid using it
02:43:51 <quicksilver> don't know if that's policy :)
02:44:27 <sizur> i'd love to convert a bunch of 3 character operators into one each
02:45:10 <sizur> but i guess if you use emacs, it's even easier to input 3 chars and have it display one unicode instead
02:46:35 <_frederik_> by the way, can i get ghci to record my commands in a persistent history file?
02:48:48 <quicksilver> not that I know of
02:48:51 <quicksilver> run it inside emacs? :)
02:49:12 <_frederik_> well i run it inside rlwrap currently, but that means that ghci's completion isn't functional
02:49:47 <_frederik_> it's worth it because i spend more time re-running old commands from a previous session, than completing new identifiers, but it would still be nice to have both
02:50:06 <quicksilver> I didn't even know ghci had completion :P
02:50:12 <quicksilver> since I always run it inside emacs.
02:50:25 <quicksilver> which gives me identifier completion, sort-of, anyway.
02:50:33 <_frederik_> yeah but not as good as ghci
02:50:41 <quicksilver> it's not very smart but on the other hand it can read my other buffers.
02:50:52 <_frederik_> oh i see
02:50:58 <_frederik_> that would help
02:51:06 <pejo> _frederik_, if you're using readline I think you can configure how readline behaves independently of application.
02:51:57 <quicksilver> I think that's true, yes.
02:52:02 <quicksilver> .inputrc or something.
02:52:25 <_frederik_> i know about .inputrc, but are you saying i can make readline persistent by putting something in .inputrc?
02:53:24 <quicksilver> I'm just speculating you might be able to.
02:53:29 <quicksilver> I don't know much about readline :)
02:53:32 <pejo> _frederik_, I'm not sure but I figured it might be worth pointing out. Perhaps it's just bash who does it on top of readline.
02:54:01 <sizur> @vixen how much memory do you consume right now?
02:54:01 <lambdabot> oh, good. i'm glad you think i'm right
02:54:04 <_frederik_> pejo: yeah i think so
02:57:42 <Cale> http://www.marriedtothesea.com/011808/same-city-different-universe.gif
02:57:42 <lambdabot> http://tinyurl.com/3dhn7k
03:00:03 <ari> Cale: ... what?
03:00:37 <Cale> ari: heh, that was a response to antirobotrobot's nick :)
03:00:53 * ari sees
03:04:40 <_frederik_> that's so what i'm going to be like when i'm old
03:10:09 <Cale> Using ' in the middle of a haskell identifier is evil :)
03:15:49 <quicksilver> Cale: it's useful for hawaiian variable names like ni'ihau and hawai'i
03:15:56 <_frederik_> and irish names
03:15:57 <Cale> :)
03:16:11 <_frederik_> and possessives
03:16:40 <what-> hello
03:16:49 <Cale> cale's :: Integer -> Bool
03:17:02 <Taejo> _frederik_: _frederik_'s_function
03:17:04 <Cale> It tells you which integers are my intellectual property
03:17:12 <_frederik_> hello, what-
03:17:28 <Cale> Hi what- -- have a question?
03:17:57 <what-> I am trying to get some practical use of haskell recently
03:18:10 <_frederik_> what- *is* a question
03:18:27 <Cale> Cool, what are you working on?
03:18:27 <Taejo> taejo's :: a -> Bool; taejo's _ = True
03:18:31 <Taejo> I own everything
03:18:35 <what-> and wondering what are the possibilities for building GUI-s with haskell in Windows
03:18:42 <koeien> what-: you can use GTK+
03:18:51 <hpaste>  vegai pasted "Hypothetical web module defining three services" at http://hpaste.org/5214
03:18:52 <koeien> what-: with Haskell bindings in the form of Gtk2Hs
03:18:55 <Cale> Well, there's Gtk2Hs and wxHaskell
03:19:12 <what-> i have the GHC and it comes with opengl only
03:19:15 <Cale> (if you go with wxHaskell, make sure to get the darcs version)
03:19:22 <what-> the wx is not in the default
03:19:28 <Cale> Yeah, these gui libraries are distributed separately.
03:19:30 <vegai> I was wondering about web development. Do you think it could be possible with some magic to make that work?
03:19:36 <koeien> what-: neither toolkit is distributed with GHC
03:20:11 <what-> is there wx for windows?
03:20:25 <Cale> what-: yep, both wxHaskell and Gtk2Hs work on windows.
03:20:27 <koeien> vegai: yes, this must be possible; i have no idea how though
03:20:36 <koeien> what-: yes, wx for windows exists
03:20:37 <Cale> Gtk2Hs is cool, since you can use it with glade.
03:20:46 <Cale> (which is a user interface designer)
03:21:07 <vegai> preferably without having to use runtime eval...
03:21:25 <vegai> or I don't know. Would that be a problem?
03:21:32 <Cale> vegai: Um, what do you mean by "web development" exactly?
03:21:32 <lightstep> vegai, the toolkit would have to know the function names somehow
03:21:48 <what-> Cale - what do you mean by getting the darcs version? - build from sources on win?
03:22:19 <Cale> what-: oh, that's a good point, I don't know how difficult the windows build is.
03:22:29 <koeien> yes, you would need some mapping from strings to functions
03:22:42 <Cale> what-: It's just that there's been a bunch of recent development in bringing wxHaskell up to date, but no release yet.
03:22:53 <Taejo> @hoogle Int -> Double
03:22:54 <lambdabot> No matches, try a more general search
03:23:04 <Taejo> @hoogle (Floating a) => Int -> a
03:23:04 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
03:23:04 <lambdabot> Data.List.(!!) :: [a] -> Int -> a
03:23:04 <lambdabot> Data.Sequence.index :: Seq a -> Int -> a
03:23:05 <koeien> not doing so is probably a security risk as well (people could call arbitrary functions)
03:23:18 <koeien> @type fromIntegral
03:23:21 <lambdabot> forall a b. (Num b, Integral a) => a -> b
03:23:23 <Cale> koeien: people can call arbitrary functions in lambdabot :)
03:23:32 <what-> yes I see a lot of activity around haskell recently ;-) If only there were a better eclipse support ...
03:23:36 <koeien> Cale: no, unsafePerformIO and such are blocked?
03:23:54 <Cale> koeien: well, you can't load modules other than the ones which are preconfigured.
03:24:01 <vegai> lightstep: hmm, could TH be used for this, perhaps?
03:24:08 <koeien> Cale: yes there are some precautions
03:24:29 <quicksilver> unsafePerformIO isn't a function.
03:24:32 <quicksilver> ;P
03:24:37 <vegai> lightstep: I mean, the information *is* there in the source file.
03:24:37 <Cale> (also the source is preparsed to check that it's actually an expression)
03:24:44 <vegai> or perhaps just some form of preprocessing
03:24:59 <lightstep> yes, but perhaps using a reflection library will be easier
03:25:06 <Cale> vegai: Somehow I completely fail to understand what you're asking about :)
03:25:22 <lightstep> oh, these functions have different types, so maybe macros are the solution
03:25:26 <Cale> It's possible to write web applications with Haskell, if that's what you mean.
03:25:33 <koeien> Cale: vegai wants some functions like http://host/sum/2/3
03:25:36 <lambdabot> Title: host
03:25:45 <Cale> *blink*
03:25:46 <lightstep> you'd need to add "$(this'is'a'web'app)" in the end of the file
03:25:46 <koeien> Cale: to evaluate "sum 2 3"
03:25:53 <Cale> huh
03:26:15 <quicksilver> Well you need to build the mapping of strings to functions somewhere.
03:26:20 <quicksilver> but that's relatively trivial.
03:26:32 <Cale> koeien: how is it supposed to give the result? Build an HTML document with the response in it?
03:26:33 <quicksilver> for a real web framework you normally want to be able to tweak that mapping anyway.
03:26:38 <koeien> Cale: for example
03:26:53 <koeien> Cale: that isn't clear to me as well, but that would be logical
03:27:13 <Cale> Do you want to be able to evaluate (almost) arbitrary expressions?
03:27:20 <Cale> You can do that with hs-plugins.
03:27:37 <what-> Info: #haskell is the #7 on FreeNode by number of users, wow
03:27:43 <koeien> what-: wow
03:27:45 <Cale> But parsing a URI into a haskell expression could be somewhat challenging at times.
03:28:01 <koeien> Cale: yeah that is possible; isn't there a framework available that does this all for us?
03:28:51 <Cale> Runs as a webserver and runs arbitrary Haskell expressions encoded as URIs?... not that I know of.
03:29:33 <koeien> something like that could be useful
03:29:39 <Cale> That seems like a kind of insane thing to want to do, at least to me... but maybe it's useful.
03:29:46 <koeien> (preferrably only functions in some predefined module)
03:29:55 <lightstep> the functions are all of the types String -> ... -> [IO] String
03:30:06 <what-> koeien - arbitrary expressions from URI-s are dangerous
03:30:17 <lightstep> you can have a type class for these that will translate them to a common structure
03:30:30 <koeien> lightstep: yes, like the 'varargs' typing example
03:30:32 <Cale> what-: you'd think so, but not all that dangerous if they can't do IO
03:30:54 <koeien> what-: it depends what functions you want to expose
03:31:00 <Cale> and, say, they're running in a time and memory limited context
03:31:15 <koeien> what-: for example http://host/unsafePerformIO/callOS/deleteEverything is dangerous
03:31:16 <lambdabot> Title: host
03:31:38 <what-> Cale - DOS attacks like out of memory or extreme swapping are pretty bad
03:31:44 <Cale> koeien: Obviously, you wouldn't load the System.IO.Unsafe module.
03:31:47 <koeien> what-: but if you only allow a certain set of functions, and "real" functions i.e. not unsafe ones, that would be ok
03:32:01 <quicksilver> koeien: unsafePerformIO isn't a function or an expression.
03:32:03 <quicksilver> ;)
03:32:07 <Cale> what-: Which is why you bound the memory usage.
03:32:13 <koeien> quicksilver: i've never used it. i don't do blasphemy
03:32:30 <what-> well if the interface is limited than it should be ok
03:32:31 <Cale> koeien: quicksilver is pulling your leg :)
03:32:35 <koeien> quicksilver: i don't even want to think about "unsafePerformIO floating out of things" :)
03:32:51 <koeien> quicksilver: i can't get my head around that :) so i just don't use it
03:32:52 <Cale> what-: after all, lambdabot will compile and run arbitrary Haskell code
03:32:57 <what-> but then it is not "arbitrary" anymore :)
03:33:14 <Cale> what-: It just doesn't execute any resulting IO actions.
03:33:25 <Taejo> and you put time and memory limits in place
03:33:28 <Cale> > readFile "/etc/passwd"
03:33:31 <lambdabot>  <IO [Char]>
03:33:40 <Taejo> oops, I was a bit behind
03:33:45 <lightstep> ?hoogle Q [String]
03:33:46 <lambdabot> No matches, try a more general search
03:33:47 <Cale> > sum [1..]
03:33:51 <koeien> > fix id
03:33:52 <lambdabot> Terminated
03:33:53 <lambdabot>  Exception: <<loop>>
03:34:32 <vegai> Cale, lightstep et al: of course it wouldn't have to run arbitrary urls, just the ones I define
03:34:57 <lightstep> i wonder how you get the list of exported names using TH
03:35:03 <vegai> so the only problem is just to transform the url to a function call
03:35:11 <koeien> vegai: if you're ok with definining a mapping from strings to functions that is pretty easy
03:35:26 <Cale> I'm still amazed that people managed to figure out what you meant from 'web development'
03:35:27 <Cale> :)
03:35:34 <what-> what is the lamdabot url?
03:35:37 <vegai> Cale: look it up or something :-)
03:35:42 <Cale> @where lambdabot
03:35:42 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
03:35:43 <sizur> vegai, if you define what function to allow, why not then map them?
03:35:49 <koeien> vegai: e.g. mapping = [("sum", sum), ("index", index)]
03:35:59 <vegai> and what about the functions that have side-effects?
03:36:02 <lightstep> <hpaste>  vegai pasted "Hypothetical web module defining three services" at http://hpaste.org/5214
03:36:04 <vegai> 'functionss'
03:36:07 <koeien> Cale: if you looked at the hpaste of vegai it would have been clearer :)
03:36:16 <what-> > sum [1..10]
03:36:16 <lambdabot>  55
03:36:16 <Cale> vegai: Web development is a broad term for any activities related to developing a web site for the World Wide Web or an intranet. This can include e-commerce business development, web design, web content development, client-side/server-side coding, and web server configuration. However, among web professionals, "web development" usually refers only to the non-design aspects of building web sites, e.g. writing markup a
03:36:16 <Cale> nd coding.
03:36:21 <what-> hehe
03:36:21 <koeien> vegai: you can evaluate them, but it would be useful
03:36:31 <koeien> vegai: like lambdabot does
03:36:38 <Cale> (that's wikipedia's definition)
03:36:46 <what-> > sum [1..1000]
03:36:47 <lambdabot>  500500
03:36:53 <what-> > sum [1..10000000]
03:36:58 <lambdabot>  50000005000000
03:37:01 <what-> > sum [1..100000000000]
03:37:08 <lambdabot> Terminated
03:37:11 <Cale> ah, okay, with the hpaste context, heh :)
03:37:13 <vegai> I wonder why no-one has done this yet
03:37:14 <lightstep> > (\n->(n+1)*n/2) 1000000000
03:37:15 <lambdabot>  5.000000005e17
03:37:28 <sizur> vegai, HAppS?
03:37:30 <koeien> > let sum' n = n*(n+1) `div` 2  in sum' 100000000000000000
03:37:31 <lambdabot>  5000000000000000050000000000000000
03:37:31 <quicksilver> vegai: people have
03:37:37 <vegai> sizur: no
03:37:42 <sizur> vegai, just map url duspatch to your functions
03:37:53 <ibid> vegai: good afternoon. how is life? :)
03:38:03 <vegai> ibid: slow friday :)
03:38:17 <sizur> vegai, you'd need to map them anyway like you did with comments
03:38:18 <ibid> :)
03:38:30 <ibid> vegai: fp course is in its third week now
03:39:00 <vegai> ibid: oh, great. How's it going? Are 70% of the students still following along? :)
03:39:23 <ibid> vegai: had 50 % dropout rate before first class :)
03:39:35 <vegai> heh
03:39:43 <ibid> vegai: but i think we still have about 2/3 of those who took the first lecture
03:39:47 <Cale> Better if the 50% dropout rate is *during* first class.
03:39:54 <Cale> :)
03:40:14 <ibid> yeah, i had >40 people enrolled, and never have seen more than 25 in lectures
03:40:43 <vegai> sizur: yeah, now that I gave it a minute of thought, perhaps that would be the best way to do this
03:41:26 <vegai> sizur: I just wonder if it will be possible to actually have *functions* for web services that don't have side-effects
03:41:39 <vegai> i.e. that in my example, sum would be Int -> Int -> String
03:41:45 <Cale> Hehe, that happened in a combinatorics class I was taking. It was a little too hardcore for many of the people who signed up, apparently. :) The prof counted the people as they left.
03:41:52 <sizur> i think that's what web services in theory should do
03:41:57 <sizur> just be functions
03:42:07 <pjd> well, what do you know: http://reddit.com/r/haskell/
03:42:08 <vegai> yeah, but I'm worried about implementation now...
03:42:24 <resiak> Cale: left *during* the lecture?!
03:42:29 <koeien> sizur: they often have some database as back-end which they should be able to call
03:42:32 <Cale> resiak: yeah.
03:42:53 <sizur> koeien, implementation detail ;)
03:42:57 <resiak> The categories course last term downsized from 25 in the first lecture to 10 in the second when all the math-hating compscis realised what it was
03:43:00 <ibid> though i note that there were 25 people who did exercises first week and 23 who did exercises second week, three of those who did in first week did not do exercises second week
03:43:03 <Cale> resiak: well, some stayed to the end and didn't show up for the next one
03:43:09 <resiak> but i've never seen an in-lecture exodus!
03:43:21 <ibid> so  the dropout rate there is rather small i see
03:43:49 <koeien> "math-hating compscis", do they exist? :)
03:43:53 <ibid> resiak: i can never tell if the people leaving the lecture early are leaving the course or if they just need to be elseweher then
03:43:59 <resiak> ibid: ah
03:44:03 <what-> does anyone know what has triggered the activity spike in haskell-cafe around august 2007 (http://gmane.org/plot-rate.php?group=gmane.comp.lang.haskell.cafe)
03:44:42 <vegai> I've been thinking of presenting Haskell questions in job interviews... to see what people do when they're faced with something they don't immediately understand
03:44:44 <ibid> resiak: since the lectures are not compulsory
03:44:52 <resiak> koeien: among undergrads, yes; every undergrad who remained was either a maths+compsci or a mathematician
03:44:52 <vegai> ibid: perhaps you can say this to your students to motivate them :P
03:44:56 <sizur> what-, it was a controlled reaction test on how the world will react on Haskell hostile takeover
03:45:00 <ibid> vegai: heh :)
03:45:07 <koeien> resiak: yeah i started with maths+compsci as well :)
03:45:17 <what-> sizur: :-)
03:45:32 <ibid> vegai: they seeem fairly motivated aleady. but what do you do to those interviewees who you recognise from past courses? :
03:45:35 <ibid> )
03:45:43 <vegai> duh, I hire them
03:45:47 <koeien> ibid: you hire them
03:45:50 <ibid> happened before?
03:45:51 <koeien> :)
03:45:58 <ibid> koeien: i don't. i don't hire :)
03:46:25 <vegai> not that I have that power either... some influence perhaps...
03:48:28 <pejo> Cale, heh, there was a (well hidden) class in semantics here, one year they had 30 people enrolling, and after first class it was down to 15 people, and it kept halving. In the end 4 people wrote the exam and 1 passed. ;)
03:49:22 <koeien> the FP exams at my university are also infamous for their supposed difficulty
03:49:31 <koeien> while actually they are fairly trivial
03:50:39 <what-> only after confronting haskell I learned the true meaning of "My mind hirts", it's a funny feeling
03:51:01 <resiak> koeien: i still am one, so.
03:51:07 <vegai> what-: tried mathematics?
03:51:16 <koeien> what-: tried category theory?
03:51:28 <koeien> :)
03:51:33 <Cale> pejo: haha
03:51:37 <vegai> seems to be na echo here
03:51:55 <pejo> Cale, the hillarious part was that it was an exchange student who passed. :-)
03:52:13 <Cale> pejo: That combinatorics course had insane exams. I got 32/80 on the midterm and it got scaled to a 96%
03:52:20 <what-> mathematics is OK, maybe knowing alot of other languages is the problem, FP and especially haskell is unique
03:52:40 <ibid> what is hirting, besides (possibly) a typo? :)
03:52:45 <koeien> what-: no, that is not the problem i think; the problem is attitude imo
03:52:52 <what-> its a typo
03:53:06 <koeien> what-: "i can already do programming, why can't i write a moderately complex program in this?"
03:53:11 <koeien> what-: "how can it ever be useful"
03:53:13 <ibid> it sounds so funny it ought to be something else too :)
03:53:24 <koeien> what-: "i don't have to do all this mathematics to program, now do i?"
03:53:44 <hpaste>  vegai annotated "Hypothetical web module defining three services" with "(no title)" at http://hpaste.org/5214#a1
03:53:49 <koeien> what-: which is rather unfortunate, ime you can easily program haskell without knowing a lot of maths
03:54:27 <what-> it just functions totally different, I feel what is the use. In other languages the people invent the FP because it is usefule, I have done it also ;-)
03:55:44 <what-> imo the jump OOP -> FP is bigger than procedural programming -> OOP
03:55:54 <quicksilver> that's because it has nothing to do with OOP
03:56:01 <idnar> OOP and FP are orthogonal
03:56:02 <quicksilver> the correct jump to be making is procedural -> FP
03:56:08 <Cale> what-: rapid cranial expansion can be painful, but you end up with a much larger brain :)
03:56:19 <quicksilver> OOP should only be learnt after 5 years of FP study.
03:56:25 <sizur> well, one can think of OOP as a superset of FP
03:56:26 <quicksilver> then it can be discussed as a breif curiosity
03:56:27 <Cale> quicksilver: hehe
03:56:41 <what-> I hope my skull is still elastic after these years
03:56:43 <quicksilver> "some other people tried this other paradigm, which is extremely bad for the following 99 reasons"
03:57:00 <sizur> heh
03:57:01 <quicksilver> "if you find someone using OOP, you should laugh at them and not hire them"
03:57:09 <pejo> quicksilver, knowledge is a light burden to carry.
03:57:16 <quicksilver> true
03:57:23 <quicksilver> but you need maturity to deal with knowledge correctly
03:57:35 <quicksilver> otherwise you might be tempted to misuse it
03:57:35 <what-> quicksilver: OOP and FP and different tools for different tasks, do not judje too early
03:57:45 <quicksilver> what-: trust me, I am not judging early.
03:57:52 <Cale> OOP is actually pretty interesting in certain respects. I tend to think of it as programming with existential types.
03:58:05 <quicksilver> what-: I have a large number of years programming experience in a substantial number of languages.
03:58:20 <quicksilver> what-: certainly I'm exagerrating, and perhaps even gently trolling
03:58:25 <quicksilver> because that's fun :)
03:58:32 <sizur> what-, actually anything you can do with OOP you can do better with FP. (i like that song)
03:58:40 <Cale> The real problem with OO is the rampant mutable state aspect of it.
03:58:42 <pejo> quicksilver, people tend to conflate OOP and C++/Java though.
03:58:56 <quicksilver> pejo: yes, true. I make that mistake sometimes.
03:58:58 <Cale> The other ideas are pretty good.
03:59:15 <quicksilver> Cale: overuse of inheritance isn't a great idea.
03:59:27 <Cale> quicksilver: okay, that one's not so good also
03:59:28 <quicksilver> Cale: correct use of inheritance is quite neat, though :)
03:59:34 <Cale> yeah
03:59:40 <sizur> but i do still have a question mark floating concerning static vs dynamic typing
03:59:50 <pejo> quicksilver, when you say inheritance you mean implementation inheritance, right?
03:59:58 <quicksilver> pejo: yes, in this context I do.
04:00:11 <what-> imo if the tools exist and do the job fine, then they are good tools
04:00:16 <quicksilver> pejo: I'm thinking of the observaton "A button and a text input field have some things in common, they're being GUI widgets"
04:00:34 <quicksilver> pejo: that observation is certainly correct.
04:00:45 <quicksilver> although C++-style inheritance isn't the only way to model it, of course.
04:00:50 <sizur> what-, they either break, or grow in complexity such that you cannot do anything anymore with it.
04:00:51 <pejo> quicksilver, that sounds like a case for subtyping, not implmeentation inheritance.
04:01:02 <Taejo> > let y = toInt 1 in let x = ((x `shift` 13) `xor` x) in x::Int
04:01:02 <lambdabot>   Not in scope: `toInt'
04:01:14 <quicksilver> implementation inheritance because I don't want to rewrite generic behaviour like event passing and layout packing
04:01:16 <Cale> pejo: right.
04:01:17 <quicksilver> say
04:01:20 <Taejo> > let y = toIntegral 1 in let x = ((x `shift` 13) `xor` x) in x::Int
04:01:20 <lambdabot>   Not in scope: `toIntegral'
04:01:23 <what-> the ugliest example: VisualBasic, from programmers perspective a horror, from users perpective nice tool to do some simple tasks
04:01:39 <quicksilver> but in other designs you might have the event passing and layout packing external to the widgets
04:01:45 <quicksilver> in which case there isn't really any implementation to inherit
04:01:50 <quicksilver> so it's not a constant.
04:01:55 <what-> note: this is a tool for people that can not afford to invest time im learning programming and want to create simple things
04:02:01 <quicksilver> but I don't deny it's a piece of modelling which makes sense.
04:02:25 <mauke> Taejo: ?
04:02:39 <sizur> what-, that's too bad though, because you can write in a nice functional style
04:02:40 <Cale> what-: I must say that some of the ideas from VB (in particular the UI designer) are rather good, and the newer VB.net languages are actually getting much better.
04:02:40 <sizur> what-, in VB
04:02:46 <Taejo> mauke: I forgot that I defined toInt myself
04:02:52 <Cale> what-: VB.net now has Haskell programmers working on it :)
04:02:56 <mauke> Taejo: even so, that code doesn't make sense
04:03:04 <Cale> what-: So it's improving :)
04:03:07 <Taejo> mauke: it doesn't?
04:03:09 <what-> I mean the old VB :-)
04:03:15 <pejo> quicksilver, I have to run for a meeting, OO can be useful, but like any hammer you might hurt your thumb while using it.
04:03:25 <mauke> Taejo: it's equivalent to undefined :: Int
04:03:27 <what-> the new Microsoft deducation to haskell is a nice thing
04:03:35 <what-> or FP to be correct
04:03:48 <Cale> It's inevitable in some sense.
04:03:56 <Taejo> mauke: ah, thank you
04:04:04 <idnar> overuse of inheritance is just abuse of OO :P
04:04:19 <Cale> The machines we'll be using in a few years will have way too many cores.
04:04:35 <Taejo> mauke: some of those x's should be y's... I translated it from imperative pseudocode, which reassigns x all over the place
04:04:38 <Cale> Imperative programming fundamentally makes parallelism hard.
04:04:52 <what-> inheritance makes simple extensions simple and complex extensions unmanageable (too complex)
04:05:10 <sizur> and with quantum computer imperative code is simply nonsense
04:05:16 <Cale> So there has to be some effort to get people into using purer, more declarative languages.
04:05:20 <what-> composition makes simple extension complex and complex extensions possible, imo
04:05:26 <Cale> and that's a big transition, so they're planning ahead :)
04:05:59 <idnar> I wouldn't really get too worried about quantum computers at the moment
04:06:09 <Cale> idnar: I'm not talking about quantum computers.
04:06:22 <idnar> that was in response to sizur's comment
04:06:29 <Cale> ah :)
04:06:35 <koeien> a programming language for quantum computers would be very cool :) but i don't see how it can be done easily
04:06:36 <Cale> I'm talking about the 80 core processors that Intel is talking about.
04:06:52 <idnar> the problem with quantum computers isn't programming languages
04:06:57 <Cale> koeien: Some people at my university are working on that.
04:07:00 <mauke> so that's what 80x86 means
04:07:02 <sizur> i just read a paper where a functional model for quantum computations was proposed
04:07:07 <what-> FP would fit nice with multi-core CPU-s
04:07:15 <idnar> the problem is building one that has more than a handful of particles, and doesn't require a building full of shielding and monitoring equipment
04:07:17 <Akrillo> hi all, im a student in germany and i have a little type definition error with an multiple treee application... someboday can help me ?
04:07:24 <Cale> Akrillo: sure :)
04:07:26 <Cale> !paste
04:07:26 <hpaste> Haskell paste bin: http://hpaste.org/
04:07:35 <koeien> idnar: yes i know that, but i'm not particularly interested in the physics part of it :)
04:07:51 <Cale> If you paste the relevant code and error message there, we can take a look.
04:08:01 <vegai> hmm, but anyway...
04:08:20 <quicksilver> idnar: that might be the problem, but it's not the interesting part :)
04:08:26 <vegai> quicksilver: you said that somebody has implemented the plumbing that makes the code I pasted possible... where might that be?
04:08:26 <koeien> Cale: did they publish something yet?
04:08:28 <quicksilver> idnar: the interesting part is the proramming.
04:08:41 <quicksilver> vegai: the various haskell web frameworks do stuff like that to some extent.
04:08:47 <Cale> koeien: That's a good question. I just heard about it from my friend who was working on the project.
04:08:51 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5215
04:08:57 <koeien> Cale: in that case, i would like a reference :)
04:09:19 <Cale> Akrillo: countLeafs :: GTree a -> Int
04:09:32 <koeien> Akrillo: what is the type of countLeafs?
04:09:37 <Cale> Akrillo: Also, you named the recursive cases incorrectly (maybe changed the name)?
04:09:37 <mauke> flatten x + flatten xs looks wrong
04:09:39 <koeien> :: GTree a -> Int
04:09:57 <koeien> Akrillo: but see what you apply it to, both to x and to xs
04:10:19 <koeien> Akrillo: now think about the types of both x and xs, and you'll see what's wrong
04:10:36 <Akrillo> http://hpaste.org/5215 , here u can find my code... because of i need trees with more than 2 Leafs i got type problems... some can give ma tip what i have to do to solve my problem ?
04:10:42 <Cale> Akrillo: also think about the case that you have a GNode []
04:11:05 <Akrillo> yee
04:11:08 <Cale> Akrillo: there's a nice way to handle both that case and the case GNode (x:xs) with the same code.
04:11:25 <Cale> Akrillo: (think about your basic list functions)
04:11:27 <koeien> Cale: :) indeed
04:12:27 <mauke> foldl' ((. cL) . (+)) 0
04:12:50 <Akrillo> the type definition is fixed...
04:14:15 <Akrillo> the input variable is [GTree b]
04:14:30 <Cale> mauke: putting the cL inside the fold here is sort of evil :)
04:14:40 <Cale> Akrillo: right
04:14:44 <Cale> Akrillo: er...
04:14:46 <Akrillo> and GTree a ...
04:14:52 <koeien> Akrillo: what do you mean?
04:14:53 <mauke> Cale: I didn't want to make it too easy :-)
04:15:00 <Cale> mauke: hehe :)
04:15:19 <koeien> Akrillo: you have a    data GTree a = Leaf a | GNode [GTree a]
04:15:24 <vegai> quicksilver: but not exactly... I was wondering if it's even possible
04:15:24 <Akrillo> 2 different types in 1 function ... [GTree b] -> Int and GTree a-> Int
04:15:26 <Cale> Akrillo: you certainly want  countLeafs :: GTree a -> Int
04:15:34 <Cale> Akrillo: right, that's your problem :)
04:15:42 <quicksilver> vegai: I don't know which bit you mean.
04:15:49 <Cale> Akrillo: so can you think of what you need to do with that list of trees?
04:15:50 <Akrillo> ye^^ , what can i do to solve the problem ? :O
04:15:50 <quicksilver> vegai: if you want to automatically map "foo" -> foo
04:15:55 <ricky_clarkson> Cale: The anchor picture on marriedtothesea was somewhat disturbing.
04:15:56 <quicksilver> vegai: then no, that's totally impossible
04:16:04 <Cale> ricky_clarkson: heh
04:16:11 <quicksilver> vegai: because that breaks alpha-renaming which is one of the most important properties of a programming lanague.
04:16:21 <ricky_clarkson> Still, thanks for mentioning the site, it's no xkcd but the artwork's great.
04:16:21 <Cale> ricky_clarkson: They made another one about how disturbing it was later, I think
04:16:22 <quicksilver> vegai: however, it's trivial to do in TH, I imagine.
04:16:35 <Akrillo> Cale: don't know .... recursiv programming is hard for me *G*
04:16:37 <koeien> Akrillo: so your countLeafs functions is of type GTree a -> Int
04:16:37 <quicksilver> vegai: and probably possible with various other metaprogramming things.
04:16:44 <Cale> Akrillo: not recursive :)
04:16:48 <koeien> Akrillo: the base case (i.e. a Leaf) you handled correctly
04:16:54 <vegai> quicksilver: aye, that's what I hope. I'll try to find the time to look into TH
04:17:04 <koeien> Akrillo: but what is the number of leafs in the recursive case?
04:17:05 <Cale> Akrillo: the recursions are already handled for you by functions that you probably should know...
04:17:14 <Cale> Akrillo: do you know about map filter and fold?
04:17:22 <Akrillo> Cale: yes
04:17:26 <koeien> Akrillo: have you used foldr before?
04:17:35 <Akrillo> koeien: yes
04:17:44 <therp> I'm sorry for the youtube noise, but for anyone who ever attended a research talk this is quite funny :) http://youtube.com/watch?v=yL_-1d9OSdk
04:17:45 <lambdabot> Title: YouTube - Chicken chicken chicken
04:17:53 <Cale> Akrillo: okay, also, there's a function called sum for adding up a list of numbers in the Prelude, if you don't want to write it as a fold.
04:18:03 <koeien> Akrillo: so, you could write it out but you could use sum as well
04:18:13 <koeien> @src sum
04:18:14 <lambdabot> sum = foldl (+) 0
04:18:41 <Akrillo> i only need the sum of the leafs
04:18:54 <Akrillo> i think foldr give me the sum of the leafs and the nodes
04:18:57 <mauke> the sum of the counts of the trees
04:18:57 <koeien> yes, true ! but what is the number of leafs in a GNode xs ?
04:19:13 <koeien> it's the sum of the number of leaves in each tree in xs !
04:19:20 <koeien> right?
04:19:39 <Twey> @pl (\ x -> x ^ 2)
04:19:39 <lambdabot> (^ 2)
04:19:43 <Akrillo> ye...
04:20:04 <koeien> Akrillo: so, think about how to get a list of number of leaves of xs there, and how to sum them :)
04:20:20 <koeien> Akrillo: the basic list functions map, filter and foldr may help :)
04:20:45 <Cale> (they're the usual things to think about first if you're working with lists)
04:21:33 <Akrillo> ok i will think about it ... mb i will come back lateR =D
04:21:41 <koeien> Akrillo: good luck! :)
04:21:48 <Akrillo> thx 4 your help :P
04:22:30 <mauke> int countLeaves(GTree<T> x) { switch (x) { case Leaf(T _): return 1; case GNode(List<GTree<T>> p): { int s = 0; for (; p; p = p->cdr) { s += countLeaves(p->car); } return s; } }
04:23:06 <koeien> mauke: lol
04:23:30 <Cale> therp: hahaha
04:23:46 <Cale> therp: that's awesome. I especially liked the response to the question.
04:26:47 <mauke> truly a content-free talk
04:27:22 <Twey> Hmm
04:27:51 <Twey> :t (^) is (Integral b, Num a) => a -> b -> a
04:27:53 <lambdabot> parse error on input `=>'
04:28:10 <koeien> :t (**)
04:28:12 <lambdabot> forall a. (Floating a) => a -> a -> a
04:28:16 <koeien> :t (^)
04:28:16 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
04:28:33 <koeien> > 2^64
04:28:35 <lambdabot>  18446744073709551616
04:28:37 <Twey> So why is `let square = (^2) in square 5` an error?
04:28:38 <koeien> > 2**64
04:28:39 <lambdabot>  1.8446744073709552e19
04:28:49 <mauke> > let square = (^2) in square 5
04:28:50 <lambdabot>  25
04:28:54 <koeien> Twey: huh
04:28:55 <Twey> Huh
04:28:58 <mauke> Twey: "no."
04:29:03 <ivanm> therp: that's not you giving that talk, is it? :p
04:29:11 <Twey> Er, sorry, 0.5
04:29:15 <Twey> > let square = (^2) in square 0.5
04:29:16 <lambdabot>  0.25
04:29:18 <Twey> ...
04:29:20 <mauke> Twey: 0.5 is not an Integral
04:29:23 <mauke> er
04:29:25 <Twey> It threw an error, honest :-(
04:29:28 <mauke> assuming you meant (^0.5)
04:29:32 <Twey> Integral is for the 2
04:29:33 <Twey> No
04:29:39 <Twey> I did let square = (^2)
04:29:44 <koeien> let square = (^0) in square 0
04:29:45 <Twey> Then square 0.5
04:29:47 <koeien> > let square = (^0) in square 0
04:29:48 <lambdabot>  1
04:29:52 <Twey> And it failed
04:29:57 <mauke> Twey: monomorphism restriction?
04:30:30 <Twey> It defines it square :: Integer -> Integer
04:30:33 <Twey> For some reason
04:30:39 <Twey> mauke: Bless you?
04:30:50 * Twey is a newbie, sorry :-(
04:30:54 <koeien> mauke: the most probable reason
04:31:06 <Twey> What is that?
04:31:15 <koeien> Twey: there is a haskellwiki page explaining it
04:31:21 <mauke> Twey: yeah, that happens for top-level definitions without arguments
04:31:28 * Twey searches.
04:31:28 <Botje> Twey: haskell has to decide a type, so it picks the most general one possible.
04:31:39 <Botje> :t (^)
04:31:39 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
04:31:49 <Botje> :info Integral
04:31:52 <Twey> Botje, that would be a
04:31:52 <Botje> bah
04:31:59 <mauke> Twey: http://haskell.org/haskellwiki/Monomorphism_restriction
04:32:07 <Botje> Twey: no, because the type a is restricted by Num
04:32:20 <mauke> Botje: ?
04:32:42 <Botje> that's how I understand it at least
04:32:49 <Botje> am I wrong?
04:32:55 <Twey> Botje: So is Integer
04:33:12 <mauke> Botje: the most general type of square would be (Num a) => a -> a
04:33:13 <Twey> mauke, reading
04:33:37 <mauke> but it was defined without a type signature or arguments, so the compiler decided to make it monomorphic
04:33:44 <Botje> yeah
04:33:57 <Botje> i'll grab some caffeine before answering questions
04:34:42 <LoganCapaldo> :t (^)
04:34:43 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
04:34:56 <LoganCapaldo> :t (^^)
04:34:57 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
04:35:08 <LoganCapaldo> :t (**)
04:35:09 <lambdabot> forall a. (Floating a) => a -> a -> a
04:35:53 <mauke> :t id (^)
04:35:54 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
04:36:54 * LoganCapaldo was trying to figure out how the  most gneral type could be (Num a) => a -> a. I guess if you define it as square x = x * x
04:37:16 <mauke> :t let square = (^2) in square
04:37:17 <lambdabot> forall a. (Num a) => a -> a
04:37:20 <koeien> :t (^2)
04:37:21 <lambdabot> forall a. (Num a) => a -> a
04:37:57 <Twey> @pl (\x -> x * x)
04:37:57 <lambdabot> join (*)
04:38:03 <Twey> @src join
04:38:03 <lambdabot> join x =  x >>= id
04:38:17 <mauke> monowned
04:38:25 <Twey> Heh
04:38:32 * Twey hugs lambdabot.
04:38:37 <Twey> This bot is excellent.
04:39:01 <koeien> lambdabot++
04:39:35 <quicksilver> Twey: you think that's clever, you should see djinn :P
04:39:38 <ivanm> @vixen Twey thinks you're excellent!
04:39:38 <lambdabot> where on a map is Panama?
04:39:40 <Cale> I can tell it's morning because of the orange sunrise of IOWait in my cpu meter.
04:39:43 <LoganCapaldo> :t (^ (2 :: (Integral a) => a))
04:39:44 <lambdabot> forall a. (Num a) => a -> a
04:39:47 <koeien> @djinn a->b->(b,a)
04:39:48 <lambdabot> f a b = (b, a)
04:40:03 <quicksilver> @djinn (a -> b -> c) -> (a -> b) -> (a -> c)
04:40:03 <lambdabot> f a b c = a c (b c)
04:40:19 <Twey> quicksilver: I'm not sure I get that one (still a newbie :-P)
04:40:23 <ivanm> ummm... so djinn produces identity-like functions?
04:40:23 <koeien> @djinn a->b
04:40:23 <lambdabot> -- f cannot be realized.
04:40:29 <quicksilver> Twey: it generates functions of a given type
04:40:35 * LoganCapaldo is drunk or sth
04:40:36 <quicksilver> it can even regenerate some builtins
04:40:38 <koeien> ivanm: djinn finds functions of a type
04:40:38 <quicksilver> @src either
04:40:38 <lambdabot> either f _ (Left x)     =  f x
04:40:38 <lambdabot> either _ g (Right y)    =  g y
04:40:42 <quicksilver> @type either
04:40:42 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
04:40:43 <Twey> The simplest possible?
04:40:48 <quicksilver> @. djinn type either
04:40:49 <lambdabot> f a b c =
04:40:49 <lambdabot>     case c of
04:40:49 <lambdabot>     Left d -> a d
04:40:49 <lambdabot>     Right e -> b e
04:40:54 <quicksilver> Twey: yes, essentially.
04:40:57 <LoganCapaldo> @djinn Bool -> a -> a -> a
04:40:58 <lambdabot> f a b c =
04:40:58 <lambdabot>     case a of
04:40:58 <lambdabot>     False -> c
04:40:58 <lambdabot>     True -> b
04:41:00 <koeien> Twey: in a way
04:41:01 <Twey> Interesting
04:41:24 <quicksilver> ivanm: if 'identity-like' means 'obvious' then yes :)
04:42:08 <ivanm> yes, that's what I meant
04:42:32 <Twey> @djinn Bool -> (Int, String) -> (Int -> String)
04:42:32 <lambdabot> f _ (_, a) _ = a
04:42:51 <Twey> _ is cheating :-P
04:43:01 <koeien> @djinn a->b->a
04:43:01 <lambdabot> f a _ = a
04:43:06 <koeien> which other function has that type?
04:43:10 <ivanm> @djinn (Show a) => a -> String
04:43:14 <ivanm> let's see...
04:43:26 <Twey> Heh
04:43:26 <ivanm> @hoogle a -> b -> a
04:43:27 <lambdabot> Prelude.const :: a -> b -> a
04:43:27 <lambdabot> Prelude.seq :: a -> b -> b
04:43:27 <lambdabot> GHC.Conc.par :: a -> b -> b
04:43:36 <quicksilver> ivanm: it doesn't have proof rules for any classes.
04:43:37 <ivanm> djinn seems to have died...
04:43:40 <ivanm> quicksilver: ahhh
04:43:41 <koeien> well yeah, par and seq don't count
04:43:44 <koeien> and i wrote const
04:44:24 <ivanm> koeien: did you? I thought const was defined in the prelude... :s
04:44:41 <ivanm> ;-)
04:44:59 <koeien> ivanm: :)
04:45:18 <kuribas> @hoogle Maybe a -> a -> a
04:45:19 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
04:45:19 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
04:45:19 <lambdabot> Data.Maybe.maybe :: b -> (a -> b) -> Maybe a -> b
04:45:29 <quicksilver> par is const, isn't it? with arguments flipped.
04:45:35 <quicksilver> seq is nearly const, but not quite.
04:45:42 <koeien> seq undefined 37
04:46:04 <Cale> quicksilver: yes
04:46:17 <koeien> > seq undefined 37
04:46:18 <lambdabot>  Undefined
04:46:22 <koeien> > const 37 undefined
04:46:23 <lambdabot>  37
04:46:27 <ivanm> quicksilver: seq is const where the first operator is "forced" to evaluate, isn't it?
04:46:33 <koeien> that's the only difference is it?
04:46:35 <Cale> ivanm: yeah.
04:46:36 <quicksilver> ivanm: well I was speaking denotational.
04:46:40 <ivanm> *nod*
04:46:47 <quicksilver> ivanm: denotatioanlly, seq is const unless the first param diverges
04:46:53 <quicksilver> whilst par actually *is* const
04:46:55 <ivanm> *nod*
04:47:01 <quicksilver> (except args are reversed)
04:47:08 <Cale> The interesting thing is that  seq a b is not required to evaluate a before b.
04:47:11 <ivanm> par == flip const ?
04:47:24 <ivanm> Cale: it isn't? isn't that the whole point?
04:47:30 <Cale> It's just required to evaluate a before the result of b is produced from the expression.
04:47:33 <koeien> ivanm: indenotational  semantics, yes
04:47:34 <quicksilver> the denotation does not require it to.
04:47:36 <Cin> dons: the text on your web site goes off my screen to the right :(
04:47:53 <quicksilver> you could evaluate b first if you wanted to
04:48:02 <quicksilver> although arguably it would be daft/perverse.
04:48:05 <ivanm> just not return it?
04:48:08 <quicksilver> right
04:48:19 <quicksilver> you could certainly evaluate them in parallel and that might not even be daft.
04:48:24 <Cale> The only requirement is that  seq _|_ b = _|_ and seq a b = b otherwise.
04:48:27 <quicksilver> However, it would be a different operational semantics.
04:48:44 <Cale> (at least according to the standard)
04:48:58 <dcoutts_> quick guessing game: how big do you think the hackage archive is (tar gziped -9) to the nearest Mb? (winner gets @karma+)
04:49:11 <dcoutts_> step up, guesses please...
04:49:17 <Botje> 751
04:49:23 <mauke> 1337
04:49:27 <dcoutts_> hah
04:49:28 <koeien> 666
04:49:36 <Cale> 665
04:49:36 <mauke> 42
04:49:41 <koeien> 37
04:49:56 <Botje> ONE
04:49:59 <mauke> [1 ..]
04:50:03 <ivanm> dcoutts_: 137 ;-)
04:50:05 <sieni> please stick only to valid siteswaps
04:50:24 <dcoutts_> ok, that's enough. mauke wins with 42 (it's actually 56M)
04:50:28 <dcoutts_> @karma+ mauke
04:50:28 <lambdabot> mauke's karma raised to 11.
04:50:29 <mauke> yay!
04:50:31 <sieni> 1337 and 665 are not valid siteswaps
04:50:35 <sieni> nor is 751
04:50:42 <ivanm> "siteswaps"?
04:51:13 * dcoutts_ downloads the entire hackage archive to nefarious^H^H^H^H^H testing purposes
04:51:22 <sieni> 753 would be
04:51:25 <ivanm> dcoutts_: s/to/for ?
04:51:34 <dcoutts_> ivanm: erm, yeah, for
04:51:47 <sieni> ivanm: you obviously aren't very familiar with juggling :-)
04:51:54 <ivanm> nope ;-)
04:51:59 <ivanm> and proud of it!
04:52:12 <sieni> ivanm: well you shouldn't be :-)
04:52:36 <ivanm> why not? I don't juggle and I have poor hand-eye co-ordination
04:52:56 <sarah87> if i have class (Integer i) MyInt i, can i make + have a differnt type?
04:53:10 <koeien> sarah87: no
04:53:24 <koeien> sarah87: but i don't get what you mean exactly
04:53:43 <koeien> sarah87: but (+) :: (Num a) => a->a->a
04:54:00 <koeien> (unless you hide the Prelude version, but i don't think you want that)
04:54:01 <Cale> sarah87: You can import the Prelude hiding (+) and the other arithmetic operations
04:54:10 <ski_> you can make `(+)' have a different type if you don't import the usual one (or import it qualified)
04:54:16 <frwmanners> > map (+1) [1..10]
04:54:16 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
04:54:17 <sieni> ivanm: well, hand-eye-coordination is a trainable skill
04:55:29 <sarah87> sieni: probably some tallent involved tho
04:55:43 <sieni> sarah87: I don't think so
04:56:07 <Cale> I lack depth perception thanks to my brain being wired strangely.
04:56:18 <sieni> sarah87: I started juggling at the age of 29 and I'm pretty fluent with 5 balls now
04:56:27 <ski_> > let (+) :: Integer -> [Integer]; (+) x = [x*y | y <- [0..x]] in (10 +)  -- or shadowing
04:56:27 <lambdabot>  [0,10,20,30,40,50,60,70,80,90,100]
04:56:47 <mauke> I bet I can do that with the Prelude +
04:56:51 <ivanm> Cale: lucky you ;-)
04:56:52 <sieni> 6 balls and 5 clubs still present some challenge, but those should be achievable, though
04:57:06 <mauke> hmm, no :(
04:57:31 <mauke> *Main> 10 * [0 .. 10]
04:57:31 <mauke> [0,10,20,30,40,50,60,70,80,90,100]
04:58:12 <sieni> learning to juggle 5 balls only requires determination, not any kind of talent
04:58:27 <quicksilver> determination is a talent!
04:58:29 * quicksilver grins
04:58:30 <sieni> I don't know about 7 balls, since I can't do that
04:58:37 <sieni> yet
04:59:43 <RayNbow> hmm
04:59:45 <RayNbow> > pi
04:59:45 <lambdabot>  3.141592653589793
04:59:55 <RayNbow> > 1 / sqrt 3 - tan (pi/6)
04:59:55 <lambdabot>  7.654467337747661e-17
05:00:29 <opqdonut> heh
05:00:50 <RayNbow> slightly better than what ghci outputs on my screen :p
05:01:04 <RayNbow> 1.1102230246251565e-16 <-- this is the output I get :p
05:01:51 <quicksilver> RayNbow: lambdabot is compiled with excess-precision, I think
05:02:03 <quicksilver> so it used 80bit fpu regs to approximate 64bit math.
05:02:11 <quicksilver> which sometimes gives "better" answers
05:02:16 <quicksilver> depending how you define "better"
05:02:28 <RayNbow> :p
05:02:58 <sieni> quicksilver: what do you mean by approximating?
05:03:06 <opqdonut> excess-precision hmm, i think we need overkill-precision
05:03:11 <quicksilver> sieni: it returns different answers.
05:03:14 <quicksilver> sieni: which are, therefore, wrong.
05:03:22 <quicksilver> sieni: and hence are only an approximation to 64bit math.
05:03:37 <sieni> naturally, but clearly the 64-bit floats are a subset of 80-bit floats
05:03:44 <quicksilver> It's a better approximation of exact math, of course. But it's a worse approximation of 64bit math.
05:03:56 <quicksilver> if your objective is to implement a reproducible algorithm on 64bit math
05:04:03 <quicksilver> then -fexcess-precision screws it up
05:04:09 <quicksilver> by occasionally doing "better" than you expect.
05:04:11 <quicksilver> i.e. wrong.
05:04:14 <opqdonut> heh
05:04:44 <RayNbow> the whole concept of floating points is just plain wrong... :p
05:04:53 <sieni> quicksilver: I can understand that it can happen, but could you give a concrete example
05:05:03 <sieni> RayNbow: no, it's not!
05:05:10 <quicksilver> RayNbow: FSOV "wrong", yeah.
05:05:18 <quicksilver> "Wrong" == overused and often used when it shouldn't be.
05:05:23 <mauke> f x == 0
05:05:29 <Cale> It would be nice to have a proper multiprecision floating point library for Haskell.
05:05:32 <quicksilver> it's good for applications which by design work at multiple different scales.
05:05:33 <RayNbow> quicksilver, fsov?
05:05:41 <quicksilver> so its' actually quite sensible for openGL
05:05:49 <quicksilver> which is intended to be 'scale-independent'
05:05:55 <Cale> (which kept track of the error)
05:05:56 <quicksilver> within certain limits, of course.
05:06:08 <quicksilver> but floating point is quite a good match for that case.
05:06:11 <opqdonut> RayNbow: "for some value of"
05:06:17 <RayNbow> ah
05:06:33 <quicksilver> however for your typicaly 'messing with non-whole numbers' some fixed-point type would be better in many programs.
05:06:42 <opqdonut> yep
05:06:43 <sieni> RayNbow: floating point numbers are perfectly good for numerical simulations, which is what they were intended for
05:06:53 <RayNbow> sieni: I know
05:07:05 <quicksilver> sieni: there are large classes of simulation for which fixed point is better, though...
05:07:17 <quicksilver> the main reason they are used, IMO, is that hardware support them
05:07:22 <quicksilver> and so do programming languages
05:07:25 <quicksilver> bit of a vicious circle
05:07:30 <opqdonut> mhmm
05:07:36 <opqdonut> and they're usually quite fast
05:07:43 <quicksilver> which is because hardware supports them :)
05:07:50 <quicksilver> in principle fixed point should "obviously" be faster.
05:07:52 <sieni> well...
05:07:55 <opqdonut> yeah
05:07:57 <quicksilver> but in practice, floating point is actually faster.
05:08:01 <quicksilver> because machines have FPUs.
05:08:32 * RayNbow has a book somewhere that covers fixed point math... but that's because the book was written in the DOS age...
05:08:41 <Cale> hmm...
05:08:56 <sieni> quicksilver: why should fixed point arithmetic be faster?
05:09:32 <quicksilver> sieni: there is less to do.
05:09:40 <quicksilver> sieni: FP addition is just simple addition.
05:09:45 <quicksilver> erm
05:09:53 <quicksilver> ambiguous use of 'FP' ;)
05:09:57 <sieni> heh
05:09:59 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Fixed.html
05:10:00 <lambdabot> http://tinyurl.com/3bzw9h
05:10:04 <quicksilver> fixed point addition / substraction is 'just' addition/subtraction.
05:10:13 <quicksilver> fixed point multiplication/division adds one extra step.
05:10:22 <quicksilver> which can be implemented efficiently in hardware as a bit shift
05:10:29 <quicksilver> (assuming we use base 2 fixed point of some kind)
05:10:50 <sieni> quicksilver: well, floating point addition/division isn't that much harder
05:11:03 <quicksilver> quite a lot more basic ops though
05:11:11 <quicksilver> compare exponents, shift
05:11:13 <sieni> but floating point numbers have certain advantages
05:11:18 <quicksilver> add/minus exponents.
05:11:20 <Cale> > 45.329473 :: Pico
05:11:21 <lambdabot>  45.329473000000
05:11:25 <Cale> :)
05:11:26 <quicksilver> Cale: yeah, its' really nice.
05:11:31 <sieni> well, if you implement those in hardware, then it's not a problem
05:11:35 <quicksilver> Cale: but probably slower than Double.
05:11:37 <quicksilver> sieni: Right.
05:11:46 <quicksilver> sieni: if you implement anything in hardware its' not a problem.
05:12:06 <quicksilver> if hardware implemented thunking and blackholing, GHC-compiled programs woudl be faster than C programs :P
05:12:28 * RayNbow once had to write software for a slow CPU that couldn't even do multiplication for a lab course...
05:12:32 <quicksilver> Cale: woudl be interesting to check if it really is, though.
05:12:43 <Cale> I think a combined rational / arbitrary precision floating point might work well in Haskell, represented using functions of an eventual desired precision.
05:12:51 <sieni> well, you can't take an np-complete problem and tell people to solve it in hardware
05:13:21 <quicksilver> sieni: sure you can.
05:13:33 <Cale> (various basic algorithms would have to know how much additional precision to request)
05:13:36 <quicksilver> sieni: they'll implement something broken, and attach a post-it note saying 'you can fix this is software'
05:13:39 <sieni> well, you can of course
05:13:46 <quicksilver> grin
05:13:58 <quicksilver> actually there are some np problems you can solve with analogue electronics
05:14:04 <quicksilver> variations on the path-finding stuff
05:14:10 <sieni> but unless you are stupid, you can't expect to get any reasonable results from it
05:14:11 <quicksilver> quite funky
05:14:18 <quicksilver> but obviously not generalisable
05:14:25 <quicksilver> (and also, the solutions are approximate)
05:14:42 <kuribas> Is floating point good for typesetting?
05:14:50 <quicksilver> I woudln't have thought so.
05:14:54 <Cale> Minimal surface finding with bubbles is an interesting but ultimately broken means of encoding computation.
05:14:58 <quicksilver> I'd have thought you'd choose a fixed target resolution
05:15:02 <quicksilver> like 1000dpi
05:15:04 <quicksilver> and stick to it.
05:15:05 * RayNbow knows a 2 step algorithm for finding the longest path in a tree...
05:15:29 <quicksilver> Cale: you might, in some cases, use it to "solve" a non-linear equation by getting an approximate solution
05:15:55 <quicksilver> Cale: if that approximation solution is close enough to the true solution that the problem is linear on that region
05:16:06 <quicksilver> Cale: then you can finish off with standard methods like N-R.
05:16:21 <quicksilver> Cale: however, this is not a practical basis for general computaiton :)
05:16:29 <RayNbow> (although that algorithm requires you to represent the tree using ropes and beads :p)
05:16:36 <quicksilver> Cale: just a cute way of solving very particular kinds of DEs.
05:20:15 <nolrai> how do I get "
05:20:15 <nolrai> class MonadPrompt m d i | m -> d, m -> i where
05:20:15 <nolrai>     prompt :: d -> m i
05:20:45 <nolrai> " to work and what does the | stuff do?
05:21:01 <quicksilver> the stuff is functional dependencies
05:21:09 <quicksilver> you need -fglasgow-exts, or some langauge flags
05:21:18 <quicksilver> proabbly MultiParamTypeClasses and FunctionalDependencies
05:21:24 <quicksilver> but I woudln't swear on it
05:23:44 <nolrai> thanks
05:25:44 <Cale> Yay! They're putting animated PNG support in Firefox 3! My colour cycling list bullets and spinning 3D-rendered @-sign email links (so cool) will finally have alpha-blended edges!
05:26:03 <quicksilver> Cale: do you also have marquue and blink tags? :P
05:26:24 <stefanha> I have said import System.IO, but GHC 6.6.1 still stays Not in scope: `withBinaryFile'.
05:26:34 <Cale> Is it 1998? You bet I do!
05:27:08 <stefanha> Is withBinaryFile > GHC 6.6.1 or am I doing something else wrong?
05:27:10 <ricky_clarkson> <hr>
05:27:58 <quicksilver> stefanha: I think you're right. Its > 6.6.1
05:28:25 <nolrai> where is a good discription of forall syntax and semantics?
05:28:30 <RayNbow> Cale: 1998 is a very cool year :p
05:28:51 <stefanha> quicksilver: thanks.  Is there a way to check?
05:28:51 <Cale> stefanha: http://www.haskell.org/ghc/docs/6.6.1/html/libraries/doc-index-W.html seems not to mention that function.
05:28:51 <lambdabot> http://tinyurl.com/2rwqgc
05:28:59 <stefanha> aha, thanks guys
05:29:07 * RayNbow remembers he once created the frames for an ani-GIF in Paint :X
05:32:08 <Cin> the `accept' function from Network.Socket returns (Socket,SockAddr), except i can't find any functions that let one inspect a SockAddr value so that i can get the hostname of the client (a la Network's `accept'). does anyone know how to do this?
05:32:34 <quicksilver> stefanha: yeah, it's worth bookmarking the old version of hte library docs.
05:32:42 <quicksilver> stefanha: I did a google search and found the ticket.
05:32:47 <quicksilver> stefanha: and looked at the date :)
05:36:11 <Cale> Oh, neat, there's an entire function f: C -> C such that the set {f^(n) : n = 0,1,2,...} of all derivatives of f have the property that for any compact set K, every e > 0, and every entire function g, there is some derivative f^(k) of f such that |f^(k)(z) - g(z)| < e for all z in K.
05:36:38 <mauke> Cin: SockAddr is a public type; you can simply inspect it
05:38:12 <Cale> (The space of all entire functions doesn't seem so large :)
05:38:14 <Cin> mauke: oh, thanks
05:39:56 <RayNbow> Cale: you lost me :p
05:40:13 <RayNbow> but that's probably because I would have to look up what a compact set is :p
05:40:21 <Cale> RayNbow: closed and bounded
05:40:33 <Cale> (do you know what each of those means?)
05:40:53 <RayNbow> Cale, so a compact set is just a set that has a finite size?
05:41:12 <mauke> no: [0,1)
05:41:14 <Cale> basically, yeah, and contains its boundary
05:41:55 <quicksilver> and doesn't have any weird things happening inside it
05:41:59 <quicksilver> for some sense of the word 'weird'
05:42:01 <Cale> for example, { z in C : |z| < 1 } isn't closed (but it's bounded), but { z in C : |z| <= 1 } is compact.
05:42:14 <Saizan> well, fsvo of size too
05:42:22 <RayNbow> ah ok
05:42:25 <RayNbow> got it :)
05:42:26 <mauke> wasn't there something with finite subsets of open covers?
05:43:58 <Cale> Strictly speaking, A closed set K is defined as one which for any point x not in K, there is some e > 0, so that the disc of radius e around x lies totally outside K.
05:43:58 <quicksilver> yes, but Cale is restricting to C
05:43:58 <quicksilver> to make it easier to explain, I imagine ;)
05:43:59 <quicksilver> the raw topological definition is fairly unpalatable
05:43:59 <quicksilver> until you spend a few months thinking about it.
05:43:59 <quicksilver> in R and C it corresponds to simpler ideas.
05:44:00 <Cale> And a bounded set K is just one for which there is some M such that for any x in K, |x| < M
05:45:20 <Cale> An entire function is one which is differentiable everywhere, in the complex-variable sense of the term.
05:45:39 <Cale> (defined the same as with real derivatives, but using complex numbers in the limit instead)
05:46:14 <_frederik_> what is stg_ap_pp_fast?
05:46:16 <Cin> :t Control.Concurrent.Chan.chan
05:46:18 <lambdabot> Not in scope: `Control.Concurrent.Chan.chan'
05:46:22 <Cin> bleh
05:46:29 <Cin> :t Control.Concurrent.Chan.Chan
05:46:30 <lambdabot>     Not in scope: data constructor `Control.Concurrent.Chan.Chan'
05:46:40 <Zao> Isn't that TChan?
05:46:55 <Cale> Chan doesn't export the data constructors, only the type
05:47:07 <taruti> :i Control.Concurrent.Chan.Chan
05:47:11 <Cale> Zao: that'd be under Control.Concurrent.STM
05:47:24 <taruti> hmm. lambdabot has no :i :(
05:47:54 <quicksilver> yeah, annoying that
05:47:59 <quicksilver> although, :i is quite verbose sometimes
05:48:01 <quicksilver> htat might be why
05:49:08 <Cin> if i have a datatype that contains a Chan, how do i write that?
05:49:24 <quicksilver> data Foo = Foo (Chan Int)
05:49:25 <quicksilver> ?
05:49:51 <quicksilver> data SomeKindOfChan = ThisOnesNumbers (Chan Int) | ThisOnesStrings (Chan String)
05:50:09 <quicksilver> Cale: another great example of why it's nice to be allowed apostrophes in identifiers :)
05:50:33 <Cin> oh. i'm sorry. i was getting kind errors but i must've missed the parentheses
05:51:11 <Cale> quicksilver: hehe
05:51:13 <quicksilver> Cin: almost certaily missing parens, yes.
05:51:27 <quicksilver> Cin: you can't put an 'unapplied type constructor' into a fiel.
05:51:31 <quicksilver> like 'Chan'
05:51:46 <quicksilver> you can use unapplied type constructors in synonyms though.
05:51:54 <quicksilver> "fiel" should be "field" sorry
05:52:05 <quicksilver> type MyChan = Chan -- I belive this works
05:52:09 <Cin> i originally wrote (Chan a), then wrote Chan String, etc. i keep making stupid mistakes today -_-
05:52:13 <quicksilver> ;)
05:53:47 <Cale> The proof of that fact is only a page long, but in my present state, it's a little tricky to follow.
05:58:19 <Saizan> so, the set of derivatives of f approximates the set of entire functions?
06:00:00 <Cale> Saizan: on compact sets, yes
06:01:02 <Cale> There's also an entire function which does a similar thing, but with translates instead of derivatives.
06:01:44 <quicksilver> Cale: is the proof remotely constructive?
06:02:02 <Cale> Remotely, but I think it's actually using the axiom of choice here.
06:03:04 <Cale> Let P_1, P_2, P_3,... be an enumeration of all the polynomials with rational coefficients.
06:03:17 <quicksilver> ah, that doesn't sound very satisfying
06:03:22 <Cale> Let I be the integral operator I(h)(z) = integral from 0 to z of h(w) dw
06:03:37 <Cale> Represent repeated applications of I by I^n
06:03:42 <quicksilver> it's just saying that polynomials are dense in the function space?
06:03:56 <Cale> Our function f will have the form  sum of I^(K_n) (P_n)
06:03:59 <quicksilver> and that you can get all polynomials up to blah by differentiating
06:04:17 <Cale> where the K_n are large positive integers chosen to satisfy a bunch of conditions
06:04:23 <Cale> yeah.
06:05:19 <quicksilver> well it's still a surprising result
06:05:20 <Cale> It exploits the fact that every entire function is the uniform limit on compact sets of a sequence of polynomials, and every polynomial is the uniform limit of polynomials with rational coefficients.
06:05:28 <quicksilver> but ultimately an unsatisfying proof
06:05:29 <quicksilver> :)
06:05:43 <Cale> The conditions are actually pretty interesting.
06:05:57 <koeien> quicksilver: suprising result, uninteresting proof (well not after the proof idea)
06:06:47 <Cale> First, we need K_n > K_j + deg P_j for j = 1,...,n-1, and if H_n = I^(K_n)(P_n), then we need |H_n^(j)(z)| <= 1/(2^n) for j = 0,1,...,K_(n-1), |z| <= n.
06:07:23 <Cale> If that can be done, the series defining f converges uniformly on compact sets and can be differentiated term-by-term.
06:07:59 <Cale> Also, f^(K_n)(z) = P_n(z) + E_n(z), where |E_n(z)| <= 2^(-(n-1)) for |z| <= n
06:08:50 <nolrai> is there a way to ask ghci what kind a type constructor is?
06:09:03 <mauke> :k
06:09:05 <Cale> :kind
06:09:06 <koeien> :kind
06:09:20 <nolrai> in fugue.
06:09:30 <mauke> @kind StateT
06:09:31 <lambdabot> * -> (* -> *) -> * -> *
06:09:39 <ski_> @kind Chan
06:09:39 <lambdabot> Not in scope: type constructor or class `Chan'
06:10:12 <ski_> @kind Control.Concurrent.Chan
06:10:13 <lambdabot> * -> *
06:11:08 <Cale> So then all you have to do is show that it's possible to make the choice so that |H_n^(j)| <= 1/2^n for j = 0,...,K_(n-1) and |z| <= n.
06:12:40 <Cale> |I^k(z^r)| = |z^(r+k)/((r+1) ... (r+k))| <= |z^r| |z^k|/k!, and on any fixed disk, {z : |z| <= R}, you have that |z^r| <= R^r, and |z^k|/k! converges uniformly to zero on the disk as k -> infinity.
06:13:28 <Cale> So since P_n is a finite linear combination of such z^r, you can just take K_n sufficiently large.
06:15:58 <Cale> It's a good question whether this really needs the axiom of choice.
06:16:06 <Cale> I actually think perhaps it doesn't.
06:16:44 <_frederik_> what is "Edge Exception" and "Node Exception" in fgl?
06:17:17 <Cale> _frederik_: where are you seeing those?
06:17:35 <jedbrown> Cale: I think the critical bit is just enumerating a countable set.  I think it shouldn't need AC.
06:17:45 <Cale> jedbrown: right
06:18:00 <Cale> jedbrown: well, the really critical thing is choosing these K_n
06:18:03 <_frederik_> Cale: i'm creating random graphs to test something
06:18:16 <quicksilver> edge exception is when you fall off the edge of the world
06:18:21 <Cale> jedbrown: but it seems like one could actually make a canonical choice for each if one were careful
06:18:27 <quicksilver> and node exception is if you bang your nose if you land.
06:18:42 <_frederik_> quicksilver: perhaps you can update the docs? :)
06:19:00 <quicksilver> _frederik_: I would guess you'd managed to generate an invalid graph.
06:19:03 <jedbrown> Cale: exactly.  Like perhaps 2^n grows fast enough.
06:19:56 <_frederik_> quicksilver: that is my guess too
06:20:04 <_frederik_> quicksilver: it would be nice if we didn't have to guess, though
06:20:30 <Cale> _frederik_: what function is generating the message? Do you know?
06:21:11 <Cale> _frederik_: the source code is linked from the docs
06:21:31 <_frederik_> Cale: i think it may be when there are duplicate vertices, or an edge with no vertex
06:21:35 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/fgl/src/Data-Graph-Inductive-Tree.html -- could be these
06:21:41 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2txljc
06:21:45 <_frederik_> yeah i found it in the source
06:21:50 <_frederik_> it is nice to have the source linked
06:22:01 <Cale> yes, that would do it.
06:22:53 <Cale> You're writing an instance of Arbitrary?
06:23:46 <Cin> quicksilver: heh. someone pasted what you said about object oriented programming on /prog/
06:23:55 * Cin suspiciously peers round at people in the channel
06:24:06 <_frederik_> thanks btw
06:24:14 <Cale> no problem :)
06:24:19 <quicksilver> Cin: what's /prog/ ?
06:24:42 <Cin> quicksilver: some programming board on 4chan.
06:24:50 <quicksilver> link?
06:24:54 <mauke> http://dis.4chan.org/prog/
06:24:54 <Cin> quicksilver: http://dis.4chan.org/read/prog/1201262475/1-40
06:24:54 <lambdabot> Title: 4chan BBS - Programming
06:24:55 <lambdabot> Title: 4chan BBS - Functional programming
06:25:32 <quicksilver> heh
06:25:39 <quicksilver> I though 4chan was about anime porn
06:25:44 <quicksilver> evidently it's not just that :P
06:26:00 <quicksilver> still, I guess that makes it my most succesful troll to date.
06:26:06 <quicksilver> maybe I should apply for a job at /.
06:26:21 <mauke> can I post that? :-)
06:26:24 * Cin chortles
06:26:59 <quicksilver> anything I (or indeed anyone else) says in this channel is implicitly public.
06:27:04 * Cin eyes mauke suspiciously
06:27:07 <quicksilver> The channel is logged and indeed google searchable.
06:30:04 <Cin> quicksilver: does haskell fullfill enough criteria to be called an object oriented language (if you say a value is just an immutable object)? has encapsulation, inheritence, polymorphism, er some other words...
06:30:28 <earthy> http://www.cwi.nl/~ralf/OOHaskell/
06:30:29 <lambdabot> Title: Haskell's overlooked object system
06:30:40 * earthy whisltes
06:30:48 <quicksilver> Cin: it certainly provides enough abstraction tools to enable you to write in that style.
06:30:57 <earthy> if you so choose
06:30:57 <quicksilver> Cin: its more about programming style than language, after all
06:31:07 <earthy> heck, X11 is OO in C
06:31:11 <quicksilver> glib and gtk were object oriented programs (well, libraries) written in C.
06:31:37 <quicksilver> Cin: there are some key language support things that haskell doesn't have, though.
06:31:49 <quicksilver> Cin: it doesn't have any automatic support for implementation inheritance, for example.
06:31:54 <quicksilver> although certainly you can build it.
06:33:05 <Cin> oh, i see
06:33:56 <BMeph> Hello, everybody!
06:34:03 <quicksilver> Cin: it only becomes really hard when your language is very very weak on abstraction.
06:34:16 <quicksilver> Cin: it's quite hard to implement OOP in BASIC.
06:34:32 <quicksilver> Cin: but in perl, python, haskell, ruby, lua, javascript
06:34:40 <quicksilver> the tools are mostl there to choose your paradigm.
06:34:52 <Cin> quicksilver: true
06:36:11 <araujo> morning
06:36:14 <quicksilver> of course, you can't really "stitch on" static typing to a dynamic language
06:36:25 <quicksilver> unless the language gives you an unusual level of compiler hooks.
06:36:33 <quicksilver> Perl does, and thus you can inprinciple do it there.
06:36:40 <pejo> quicksilver, just bless things and they are objects!
06:36:40 <Cin> i'm particularly agnostic about object orientation. i'm just interested in defining things, in this context
06:36:43 <quicksilver> but the others in that list don't as far as I know.
06:37:29 <Cin> quicksilver: i think Qi might be such an example. it's Common Lisp, but with the reader replaced that adds a layer of static typing
06:37:51 <Cin> quicksilver: (among other things like pattern matching etc)
06:37:52 <sarah87> > [0..2..10]
06:37:53 <lambdabot>  Parse error at "..10]" (column 6)
06:38:23 <jedbrown> Does anyone have some UArray/STUArray/IOUArray using code that I can add to my test suite?
06:38:24 <Zao> > [0,2..10]
06:38:25 <lambdabot>  [0,2,4,6,8,10]
06:38:29 <sarah87> ah thx
06:38:50 * jedbrown is trying to improve code coverage for the new CArray library.
06:39:24 <quicksilver> Cin: yes, you're probably right.
06:42:44 * dcoutts_ compiles all 751 Setup.(l)hs files from hackage with stable and development versions of Cabal lib
06:43:08 <_frederik_> Could not find module `Vector.Template':
06:43:08 <_frederik_>   it was found in multiple packages: vectro-0.2 vectro-0.2
06:43:12 <Cin> my irc server is up to 200 lines so far. *gulp*
06:43:35 <czakey> irc server?
06:43:40 <czakey> in hs?
06:43:44 <czakey> meow
06:43:50 <dcoutts_> _frederik_: that's interesting, what does ghc-pkg list vectro say?
06:44:03 <_frederik_> /usr/lib/ghc-6.8.2/package.conf:
06:44:05 <_frederik_> /home/frederik/.ghc/x86_64-linux-6.8.2/package.conf:
06:44:05 <_frederik_>     vectro-0.2
06:44:23 <czakey> Cin: will be there public version?
06:44:29 <Cin> czakey: yeah
06:44:40 <czakey> great
06:44:46 <dcoutts_> _frederik_: very odd indeed
06:44:51 <Cin> czakey: probably with this license or similar: http://www.haskell.org/haskellwiki/HaskellWiki:Copyrights
06:44:52 <lambdabot> Title: HaskellWiki:Copyrights - HaskellWiki
06:44:57 <_frederik_> dcoutts_: should i report it then
06:45:00 <Cin> i like haskellwiki's license
06:45:07 <czakey> great
06:45:22 <czakey> I want to write some irc server with IRCX protocol
06:45:31 <quicksilver> Cin: i was in favour of a shorter version, which read 'ALL UR BASE R BELONG TO US'
06:45:32 <czakey> but not from scratch
06:45:33 <dcoutts_> _frederik_: make sure it's reproducible, and supply the output of ghc-pkg describe vectro
06:45:36 <quicksilver> Cin: but that was rejected.
06:45:39 <_frederik_> dcoutts_: i don't really have time to find a minimal test case
06:45:47 <czakey> so if its possible using some other project
06:45:59 <czakey> maybe that one :]
06:46:10 <dcoutts_> _frederik_: what ghc version is this? and does ghc-pkg describe vectro look sane? eg no duplication of exposed-modules ?
06:46:10 <_frederik_> dcoutts_: ah, maybe this is the problem
06:46:12 <_frederik_> exposed-modules: Vector.Misc.FloatMisc Vector.Misc.Util Vector
06:46:12 <_frederik_>                  Vector.Base Vector.Template Vector.General Vector.Array Vector.Fast
06:46:15 <_frederik_>                  Vector.FileIO Vector.Template Vector.TemplateUtil Vector.Sparse
06:46:16 <Cin> czakey: cool :)
06:46:26 <_frederik_> dcoutts_: (Vector.Template appears twice)
06:46:56 <czakey> Cin: do you write it to be modular?
06:47:00 <Cin> quicksilver: 'ALL UR BASE R BELONG TO US, PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED ...' :P
06:47:05 <czakey> I think thats good idea
06:47:05 <dcoutts_> _frederik_: ok, good. :-) ok so it's just a sanity checking bug in ghc-pkg. It should have rejected that package.
06:47:21 <dcoutts_> _frederik_: did you build with Cabal? if so we need to make that give an error too
06:47:33 <Cin> czakey: i'm hoping to setup some way to extend it with modules, if that is what you mean
06:47:46 <czakey> cool
06:47:49 <_frederik_> dcoutts_: no, mostly the build avoids cabal
06:47:55 <czakey> because, you know
06:48:12 <czakey> IRCX needs some other stuff than usual irc server
06:48:21 <_frederik_> however, now that i have removed the duplicate, it says "Could not find module `Vector.Template'"
06:48:28 <_frederik_> strange
06:48:30 <czakey> ie. other modes, and so on
06:48:30 <dcoutts_> _frederik_: so report it as a ghc bug, that ghc-pkg did not reject your package in the first place
06:48:52 <_frederik_> dcoutts_: ok
06:49:14 * czakey is looking forward hearing about that one
06:50:26 <Cin> czakey: when i get it up and running, i'd be happy to help you extend it to support IRCX, if you want to.
06:51:11 <czakey> kewl :)
06:51:13 <czakey> thx
06:54:17 <jedbrown> How does one write coarbitrary?
06:54:33 <BMeph> Has anyone seen this blog lately: http://www.wagerlabs.com/blog/2008/01/introducing-fac.html
06:54:33 <lambdabot> Title: Tenerife Skunkworks: Introducing Factor
06:54:34 <quicksilver> there is an example in the quickcheck docs
06:55:50 <BMeph> Not trying to cross-link languages, but he asks in the end about solving his problem in other languages besides Factor - and names Haskell specifically.
06:57:10 <jaa> he posts about why he doesnt use haskell further back
06:57:27 <jedbrown> quicksilver: So there are no magical properties that should hold?  It doesn't go into much detail.
06:59:42 <jaa> BMeph: http://www.wagerlabs.com/blog/2007/05/who-let-the-dog.html
06:59:43 <lambdabot> Title: Tenerife Skunkworks: Who let the dogs out?
07:05:25 <Cale> http://reddit.com/r/programming/info/607jo/comments/c02fotd -- oh, this is such a mean comment, but it's funny
07:06:16 <quicksilver> ++
07:08:09 <BMeph> jaa: It looks like this guy is more comfortable programming in an imperative style, and went out of his way to justify using OCaml over Haskell. Interesting reading, though.
07:16:49 <neko> This maybe in some faq somewhere, but does anybody have any success in getting Tclhaskell to run with ghc under Mac OS X?
07:21:34 <hpaste>  Mike pasted "Tclhaskell" at http://hpaste.org/5217
07:27:08 <Tac-Work> > cycle "goodmorning#haskell"
07:27:11 <lambdabot>  "goodmorning#haskellgoodmorning#haskellgoodmorning#haskellgoodmorning#haskel...
07:28:05 <Lemmih> neko: That paste isn't exactly all that helpful (:
07:29:47 <what-> > [1..]
07:29:48 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:30:48 <dozer> mm - that darcs pull I started yesterday still hasn't terminated
07:31:11 <Cin> > concat "go go gadget voice enhancement syste" ++ cycle "sys"
07:31:12 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
07:31:31 * Cin facepalms himself
07:31:50 <Tac-Work> >  "go go gadget voice enhancement syste" ++ cycle "sys"
07:31:50 <lambdabot>  "go go gadget voice enhancement systesyssyssyssyssyssyssyssyssyssyssyssyssys...
07:32:01 <Tac-Work> syste, eh =-D
07:32:43 <Cin> that crazy inspector gadget. his equipment always fails. ho, ho :)
07:33:21 <Tac-Work> If only kid's cartoons today were as awesome as they were when I was a child
07:34:33 <ricky_clarkson> If only you'd kept some for your kids!
07:34:35 <Cin> it may have taken me ages to come up with a model for this irc server and implement it, but it feels pretty damn stable
07:38:26 <Tac-Work> Cin: Are you using a homebrew irc client?
07:38:38 <Tac-Work> (this was talked about yesterday in #haskell, but I wasn't paying attention I guess =-)
07:39:39 <Cin> tac: i'm writing a homebrew irc server. i'll probably use irssi or xchat to test it.. =)
07:39:51 <Tac-Work> ah
07:39:52 <Tac-Work> cool
07:39:56 <Tac-Work> (In haskell of course?)
07:40:00 <Cin> yep
07:40:08 <Tac-Work> neato
07:40:16 <Tac-Work> What libraries are you using?
07:40:25 <Tac-Work> Or are you writing the protocol code yourself?
07:40:46 <Cin> i'll write that myself. i think it's pretty simple
07:41:15 <Cin> there's a library for parsing irc messages as a client, but it's not really appliccable for a server
07:41:25 <Cin> i'm considering just using regexes to parse messages
07:42:15 <Vq^> Cin: will you be using stm?
07:42:41 <Cin> vq: no, i am using just channels at the moment
07:42:44 <Tac-Work> I need to find some program to try out STM sometime. STM is the shit
07:43:19 <Cin> vq: ie i have one thread which holds all the state in a recursive function's arguments, and that recursive function reads from a channel and manipulates the state. if you follow me.
07:43:37 <Vq^> i follow
07:44:21 <Vq^> i have done a small school assignment (threaded "bank"-server) with stm
07:44:22 <shapr`> Good morning #haskell!
07:44:29 <Cin> i'll probably try a few different ways to implement it. this is my first project with haskell threads
07:44:36 <Vq^> im thinking about releasing the src, might be a good example
07:44:38 <_frederik_> good morning shapr`
07:44:40 <Cin> vq: cool. do you have code available?
07:44:45 <Tac-Work> > cycle "GoodMorning"
07:44:45 <lambdabot>  "GoodMorningGoodMorningGoodMorningGoodMorningGoodMorningGoodMorningGoodMorni...
07:44:46 <Cin> vq: yeah, that would be cool
07:44:51 <Vq^> shapr`: evening formarn
07:44:53 <shapr`> hiya _frederik_ ! You wouldn't happen to be in Boston would you?
07:44:58 <_frederik_> is shapr` an improvement over shapr
07:44:59 <_frederik_> no
07:45:03 <_frederik_> i'm in cambridge, uk
07:45:04 <shapr`> hej Vq^!
07:45:09 <shapr`> _frederik_: Ah, too bad
07:45:17 <_frederik_> cjb is in boston
07:45:17 <shapr`> I thought it'd be fun to hang out with you if you're in Boston.
07:45:19 <Cale> Oy, the Binary instance for Float is not what I expected it'd be.
07:45:24 <shapr`> Yeah, but I haven't met cjb yet.
07:45:33 <Cale> (and hence I am getting a stack overflow :)
07:46:12 <_frederik_> shapr`: i thought he went to some haskell club at MIT?
07:46:30 <cjb> _frederik_: shapr has a day job.
07:46:32 <cjb> well, I have a day job too
07:46:38 <_frederik_> oh hi
07:46:41 <cjb> but he has one where can't leave to go to Haskell talks :)
07:46:41 <shapr`> Your day job is cooler than mine.
07:46:42 <cjb> 'lo.
07:46:51 <shapr`> cjb: true that, only after hours.
07:47:05 <_frederik_> what is shapr`'s job
07:47:14 <shapr`> hacking C# for the defense industry
07:47:14 <Vq^> Cin: arda.no-ip.org/BankServer.tar.bz2
07:47:29 <shapr`> Used to be professional Haskeller, and I'll probably come back to that at some point.
07:48:22 <Cin> vq: thanks :)
07:48:25 <ski_> hiya shapr
07:48:55 * Tac-Work believes no one's job could be lamer than his
07:49:07 <quicksilver> leg surgery?
07:49:24 <mightybyte> <groan>
07:49:52 * Vq^ 's last job was for the defense itself (försvarsmakten)
07:51:08 <shapr`> hej ski!
07:51:26 <shapr`> _frederik_: What's your job these days?
07:51:44 <shapr`> tmoertel: hiya! I was talking about you yesterday, I mentioned your cheating hangman in relation to another game I've been playing.
07:52:03 <shapr`> tmoertel: Written any cool Haskell code lately?
07:52:28 <litb> hello all
07:52:45 <litb> i have troubles making my own fib function that lists all fibonacci nums between 0 and x
07:52:52 <shapr`> greetings litb, how's the lambda consumption going?
07:53:09 <litb> shapr`: there are x lambdas left
07:53:10 <tmoertel> shapr`: not a ton recently owing to new-job business.
07:53:50 <litb> what i have is map fib [1..x] but that is hell slow
07:53:56 <shapr`> litb: what about "fib n = product [1..n]" ?
07:54:07 <Vq^> shapr`: thats not fib
07:54:09 <litb> and i want a function that just calcs it like fib n+1 = fib n-1 + fib n
07:54:14 <shapr`> oh right, duh
07:54:14 <ski_> thats a fact function
07:54:20 * shapr` had four hours sleep last night
07:54:45 <Vq^> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 20 fibs
07:54:47 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
07:55:03 <basti_> litb: ever thought about "unfold"?
07:55:13 <litb> basti_: yes, i thought about unfoldr
07:55:24 <litb> but the function gets only one number
07:55:30 <mrd> my dentist told me i had some calculus built up on my teeth.  i nearly asked him: lambda-calculus?
07:55:35 <shapr`> haha
07:55:38 <cjb> shapr`: the defense industry uses C#?  I thought they were all about Ada.  :)
07:55:48 <ski_> litb : thread a pair
07:55:50 <litb> and has to return it and its neighbour. i couldn't make it work with unfold that way
07:56:13 <shapr`> cjb: I heard some other parts of this business do use Ada, RPG, COBOL, Java.. all sorts of variety here, most of it old.
07:56:39 <basti_> litb: well, "it and its neighbor" could be a pair no?
07:57:06 <basti_> litb: and of course, your function would supply the first argument for unfoldr so that a number remains to be given
07:57:09 <litb> fibs n = unfold (\(x,y) = Just (x+y, ...)) (1, 1)
07:57:18 <litb> i don't know what to put in the second one
07:57:21 <shapr`> ##csharp isn't nearly as cool as #haskell
07:57:40 <basti_> uhm
07:57:41 <basti_> kk
07:57:43 <cnwdup> Can I pass arguments to main using ghci that can be read with haskells getArgs function?
07:57:57 <litb> however Vq^ solution looks interesting
07:58:06 * Vq^ prefers the zip-...-(tail...) trick
07:58:18 <ski_> litb : replace `...' with the next state
07:58:40 <jedbrown> cnwdup: use :set args blah
07:58:46 <cnwdup> jedbrown: Thank you. (=
07:59:02 <shapr`> So, what's exciting in the world of Haskell lately?
07:59:07 <litb> fibs n = unfold (\(x,y) = Just (x+y, (x+y) + y)) (1, 1)
07:59:09 <litb> ahh :)
07:59:23 <dcoutts_> shapr: planning a Cabal-1.4 release, that's exciting :-)
07:59:52 * dcoutts_ encourages everyone to help out with bug fixing for Cabal-1.4
07:59:53 <dcoutts_> http://hackage.haskell.org/trac/hackage/roadmap
07:59:54 <lambdabot> Title: Roadmap - Hackage - Trac
08:00:14 <_frederik_> shapr`: sorry for the delay, i am a phd student
08:00:47 <litb> @type unfoldr
08:00:50 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
08:01:39 <basti_> > unfoldr (\((l,ll),c) -> if (c>0) then Just (l+ll,((ll+l,l),c-1)) else Nothing) ((0,1),10)
08:01:41 <Syzygy-> @index unfoldr
08:01:41 <lambdabot> Data.List
08:01:43 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
08:02:00 <RayNbow`> hmm, interesting... http://swtch.com/~rsc/regexp/regexp1.html
08:02:01 <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast
08:02:01 <jedbrown> > unfoldr (\(a,b) -> Just (a+b, (a+b,a))) (0,1)
08:02:03 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
08:02:12 <litb> oh
08:02:18 <Corun> Yay fib.
08:02:45 <ski_> > unfoldr (\(a,b) -> Just (b,(b,a+b))) (1,0)
08:02:45 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
08:02:53 <litb> @src unfoldr
08:02:53 <lambdabot> unfoldr f b  = case f b of
08:02:53 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
08:02:53 <lambdabot>    Nothing        -> []
08:03:01 <ski_> (no need to do more additions that needed)
08:05:38 <Syzygy-> Actually, this fib is pretty neatly an implementation of Lukas numbers, and used for that special case.
08:05:57 <Syzygy-> If you just drop the (0,1) at the end, you get a Lukas number lister.
08:06:04 <Syzygy-> That takes the initial seed, of course.
08:06:22 <byorgey> > let lukas (x,y) = unfoldr (\(a,b) -> Just (b,(b,a+b))) in lukas (1,0)
08:06:23 <lambdabot>  <(Integer,Integer) -> [Integer]>
08:06:32 <byorgey> oh, duh
08:06:38 <byorgey> > let lukas = unfoldr (\(a,b) -> Just (b,(b,a+b))) in lukas (1,0)
08:06:39 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
08:07:21 <shapr`> dcoutts: that is exciting!
08:07:37 <shapr`> _frederik_: Work must keep you busy.. is your PhD proposal online somewhere?
08:09:04 <quicksilver> does anyone stick to their phd proposals?
08:09:11 <quicksilver> my phd had no resemblance at all to mine...
08:09:17 <vincenz> quicksilver: no
08:09:19 <quicksilver> (except for the word 'logic', IIRC)
08:10:58 <Cin> hm. Network.Socket doesn't export SockAddrInet, so I can't get the HostAddress from a SockAddr value :\
08:11:18 <Cin> data SockAddr = SockAddrInet PortNumber HostAddress | SockAddrUnix String
08:12:00 <Cin> i have no idea how am i supposed to get the address
08:12:16 <byorgey> Cin: is there a function to extract it?
08:12:34 <Cin> byorgey: i can't find one
08:12:51 <Cin> there is this: inet_addr :: String -> IO HostAddress
08:12:57 <Cin> but i don't know what the string is supposd to be
08:13:15 <byorgey> maybe it does a dns lookup?
08:13:29 <byorgey> i.e. inet_addr "haskell.org"
08:13:39 * byorgey has no idea
08:13:42 <mrd> hmm?
08:14:19 <Cin> i want to get the remote host's name, or ip. but i can't see how to do either
08:14:28 <shapr`> good morning byorgey!
08:14:35 <byorgey> morning shapr` !
08:14:43 <shapr`> How's code treating you today?
08:15:04 <dcoutts_> shapr`: yes :-) so if you see people who want to contribute to the community but are not sure where they're needed, direct them towards cabal hacking :-)
08:15:08 <byorgey> shapr`: pretty good, thanks.  reading through the Yi source and contemplating hacking it some =)
08:15:14 <Cale> Man, I shouldn't have to use unsafeCoerce# just to read floating point numbers in standard binary format.
08:15:15 <shapr`> dcoutts: will do
08:15:20 <dcoutts_> @yarr!
08:15:20 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
08:15:20 <mrd>     bindSocket sock $ SockAddrInet (toEnum 25001) addr
08:15:23 <shapr`> byorgey: ooh, have screenshots?
08:15:32 <mrd> i got addr from inet_addr
08:15:38 <byorgey> I'm also contemplating hacking cabal, dcoutts_, but it's a little intimidating =)
08:15:55 <Cale> (fortunately, unsafeCoerce# works beautifully)
08:16:05 <byorgey> shapr`: I mean... I could, but it kind of just looks like emacs =)
08:16:08 <shapr`> dcoutts: hey, maybe we can get someone to write a lambdabot plugin that shows Hackage stats? That might encourage cabal hacking?
08:16:08 <mrd> Cin: you want it from something like getPeerName?
08:16:17 <Cin> mrd: does that compile? i get this: Module `Network.Socket' does not export `SockAddrInet'
08:16:21 <quicksilver> Cale: yes, that comes up about once a week on the cafe.
08:16:24 <shapr`> byorgey: Any idea if hs-plugins works in windows?
08:16:27 <dcoutts_> byorgey: yes, it is a bit, but we've got lists of easy bugs
08:16:38 <quicksilver> Cale: but the haskell standard doesn't know about this "standard binary format" of which ou speak.
08:16:44 <mrd> Cin: yea it compiles
08:16:48 <Cin> mrd: i've got a SockAddr. the problem is inspecting its values
08:16:53 <dcoutts_> byorgey: http://hackage.haskell.org/trac/hackage/report/13
08:16:54 <Cale> quicksilver: It's easy to fix too. We could change the instance of Binary for Float and Double to convert in that way.
08:16:54 <Cin> mrd: well what the hell?
08:16:55 <lambdabot> Title: {13} Easy tickets - Hackage - Trac
08:16:55 <mrd> at least on my old install
08:16:55 <byorgey> shapr`: no idea.
08:16:57 <quicksilver> Cale: it has been commented more than once that 'getIEEE64' would be a good addition to Binary.
08:16:59 <Cin> hm
08:17:09 <Cale> It's easily written.
08:17:18 <mrd> Cin: you'd need to use Network.BSD or somesuch to do a reverse lookup.  Sockaddr contains only the IP in a word
08:17:19 <Cale> (in an unsafe way, at least)
08:17:38 <quicksilver> Cale: I don't think its guaranteed that Double is the same number of bits on all haskell implementations?
08:17:41 <quicksilver> Cale: I'm not sure...
08:17:43 <byorgey> dcoutts_: yeah, I know.  ok, if you're going to be around in irc in case I have questions...?
08:17:46 <mrd> brb
08:17:57 <Hiato> Hello all, I'm new to functional programming as a whole and I am interested specifically in Haskell. Which would be the generally accepted best introduction tutorial for someone a-fresh in the functional language group, wishing to learn Haskell?
08:17:58 <dcoutts_> byorgey: I'm around a lot :-)
08:18:11 <byorgey> dcoutts_: ok!
08:18:18 <Cale> quicksilver: Float and Double are supposed to be single and double precision IEEE754 floating point numbers.
08:18:21 * byorgey rolls up his sleeves and goes off to hack cabal
08:18:24 <shapr`> Hiato: You may want to start with YAHT, or with the wikibooks. Any way you start, asking questions here on #haskell will help most!
08:18:33 <dcoutts_> byorgey: more specifically, here's the list of easy ones targeted at the next milestone:
08:18:34 <dcoutts_> http://hackage.haskell.org/trac/hackage/query?status=new&status=assigned&status=reopened&group=component&difficulty=easy+%28%3C4+hours%29&milestone=Cabal-1.4&order=priority
08:18:37 <lambdabot> Title: Custom Query - Hackage - Trac, http://tinyurl.com/yrkj88
08:18:39 <Cale> @where yaht
08:18:39 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
08:18:45 <Cale> @where wikibook
08:18:45 <lambdabot> http://en.wikibooks.org/wiki/Haskell
08:18:54 <Hiato> thanks shapr` and dcoutts_ and Cale
08:19:19 <Cale> Hiato: no problem, let us know if you run into any trouble
08:19:22 <Hiato> this is the friendliest specific language group, by far :D
08:19:51 <Hiato> oh, and lambdabot
08:20:00 <Cale> :)
08:20:06 <byorgey> @botsnack
08:20:07 <lambdabot> :)
08:20:12 <Cin> mrd: ah. i was looking at Hugs's documentation for Network.Socket which has quite a few differences to GHC's
08:21:08 <Cin> mrd: getNameInfo should do the trick
08:21:14 <mrd> sure
08:21:32 * Cin high fives mred
08:21:44 <Cin> -e
08:21:52 <Cale> getFloat = fmap unsafeCoerce# (get :: Get Int)
08:22:10 <Cale> there's something funny about using unsafeCoerce# together with fmap :)
08:22:34 <litb> whoo now i 've understood that unfoldr fib thing. took me a long time :)
08:22:41 <dcoutts_> byorgey: you know, we should have some cabal page on the cabal dev wiki that gives an intro guide to the source code
08:22:50 <oerjan> Cale: i am pretty sure H98 doesn't mandate IEEE
08:23:00 <quicksilver> Cale: I don't believe that is the case, no.
08:23:05 <byorgey> dcoutts_: yup, that's an excellent idea.
08:23:11 <byorgey> dcoutts_: I've actually begin writing such a thing for xmonad.
08:23:27 <quicksilver> Cale: if it was, then "isIEEE" would be "const True" and a bit of a silly method.
08:23:31 <dcoutts_> byorgey: perhaps you could keep some notes on what you learn so we can use that as a starting point for such a guide
08:23:40 <Cale> ah, right, however...
08:23:46 <Cale> > isIEEE undefined
08:23:49 <lambdabot>  True
08:23:49 <byorgey> dcoutts_: I'll try.
08:24:04 <quicksilver> "Float is implementation-defined; it is desirable that this type be at least equal in range and precision to the IEEE single-precision type. Similarly, Double should cover IEEE double-precision"
08:24:06 <dcoutts_> byorgey: ta muchly :-)
08:24:10 <Cale> yeah
08:24:14 * byorgey begins by grepping the Cabal source for FIXes and TODOs and XXXs (oh my!)
08:24:29 <quicksilver> so the best Binary instance for Double is not obvious.
08:24:47 <quicksilver> I imagine the intention is that Double can use hardware FP, even if that is better than IEEE.
08:24:53 <Cale> Does Binary work on non-GHC implementations of Haskell?
08:25:04 <quicksilver> As it is on x86 hardware, at least
08:25:12 <quicksilver> although GHC opts to make double's 64 bit, even in that case.
08:27:40 <byorgey> dcoutts_: could you give me a ten-second 50,000-foot overview to start?  i.e. if I want to start reading some of the Cabal source to get an idea of how it's organized and how things work, where should I start?
08:27:58 <oerjan> Cale: hm, isn't fmap unsafeCoerce# = unsafeCoerce# in most cases?
08:28:04 <dcoutts_> byorgey: I'm just writing that on the wiki, I'll ping you in a sec...
08:28:21 <Cale> oerjan: probably
08:28:29 <quicksilver> oerjan: not for Either.
08:28:43 <byorgey> dcoutts_: awesome, thanks =)
08:28:46 <quicksilver> actually, yes it is.
08:28:48 <quicksilver> sorry :)
08:28:55 <quicksilver> interesting.
08:29:02 <quicksilver> I wonder if that's a law.
08:29:57 <oerjan> if you do type erasure, then that turns into fmap id = id, but perhaps some instances might not carry over
08:30:10 <oerjan> (fmap id = id is a law, of course)
08:31:18 <quicksilver> the only case would be if the functor had concealed structure
08:31:21 <quicksilver> (like Data.Set)
08:31:39 <quicksilver> and that concealed structure violated an invariant under the new typeing assumption
08:32:06 <quicksilver> for example, if you were unsafeCoerce#'ing between two types in a way which didn't preserve the Ord instance
08:32:13 <quicksilver> and the functor used the ord instance
08:32:19 <quicksilver> again like Data.Set, although that isn't a functor.
08:32:44 <oerjan> i think perhaps that is impossible because a Functor must be fully parametric in its last argument
08:32:45 <cnwdup> I am querying a value with asks display. But display is of type Maybe Display and I want to get just Display. No combination is working for me: dpy <- fromJust $ asks display, is the piece of code I expect to work.
08:33:00 <quicksilver> oerjan: that sounds like good reasoning.
08:33:11 <Cale> cnwdup: fmap fromJust $ asks display
08:33:16 <ski_> dpy <- fromJust `liftM` asks display
08:33:18 <Lemmih> cnwdup: Just dpy <- asks display
08:33:19 <quicksilver> cnwdup: Just dpy <- asks display
08:33:25 <quicksilver> @quadrophonic
08:33:25 <lambdabot> Unknown command, try @list
08:33:32 <quicksilver> @surround-sound
08:33:32 <lambdabot> Unknown command, try @list
08:33:36 <cnwdup> Uh, I think I like the last suggestion best. Thank you, guys! (:
08:34:02 <Lemmih> cnwdup: It'll give you the best error messages as well.
08:34:11 * byorgey likes the last suggestion best too, although he would have suggested fmap before =)
08:34:22 <ski_> dpy <- asks (fromJust . display)  -- fwiw
08:34:36 <quicksilver> different failure behaviour
08:34:38 <quicksilver> Just foo <-
08:34:45 <quicksilver> defers to the monad instances 'fail' method
08:34:54 <quicksilver> which may or may not be very handy.
08:34:58 <Cale> quicksilver: yeah...
08:35:10 <quicksilver> it often is quite handy
08:35:10 <conal> cnwdup: are you sure you won't get a Nothing?  you could use fromMaybe to provide a default.
08:35:11 <dcoutts_> byorgey: http://hackage.haskell.org/trac/hackage/wiki/SourceGuide
08:35:13 <lambdabot> Title: SourceGuide - Hackage - Trac
08:35:19 <dcoutts_> byorgey: more content to come...
08:35:24 <quicksilver> but you often wish you could customise the error message
08:35:44 <cnwdup> conal: Yeah, I am pretty sure. But I just want to upload a piece of code as I am not sure if I *have* to use the Maybe monad at all. Mom.
08:35:45 <byorgey> dcoutts_: thanks!
08:35:47 <byorgey> dcoutts_++
08:36:24 <conal> cnwdup: ok.  "Mom"?
08:36:53 <Zao> "Moment"?
08:37:01 <conal> oh
08:37:07 <cnwdup> http://pastebin.archlinux.org/24860 I just use Maybe Display as I have to specify a default value for display in defaultZen and I don't know about an Display value that says uninitialized. It's concerning Xlib.
08:37:25 <cnwdup> Oh, sorry. The english equivalent should have been sec, doesn't it? But yes, Zao is right. :D
08:38:26 <quicksilver> moment, bitte
08:38:56 <oerjan> your Mom should have been sec.  er...
08:39:22 <Cin> oerjan: your mom goes to college
08:39:25 <byorgey> cnwdup: in English you could say "just a second (sec)" or "just a moment" but "sec" or "moment" usually aren't used by themselves as an abbreviation, like "Moment" is in German
08:39:44 <quicksilver> fortunately there is now a response to all "your mom" jokes.
08:39:49 <quicksilver> It goes like this: http://xkcd.com/366/
08:39:49 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
08:39:50 <cnwdup> byorgey: Oh, okay. I thought at least sec was common.
08:40:06 <byorgey> cnwdup: well, maybe in IRC, I don't know =)
08:40:29 <quicksilver> I think 'sec' is pretty common in lazy message media
08:40:34 <quicksilver> like MSN, IRC and jabber
08:40:46 <quicksilver> sec brb lol thx
08:41:01 <Cale> byorgey: I use 'sec' in real life.
08:41:16 <Cin> cale: what's that?
08:41:17 <byorgey> Cale: but you're from Canada. ;)
08:41:36 <Cale> Cin: An abbreviated form of "just a second"
08:41:47 <Cin> cale: real life? :P
08:41:52 <cnwdup> hehe
08:42:03 <Tac-Work> Sec is an acceptable abbreviation here in America Town
08:42:20 <Tac-Work> Mostly, because when you slip up and use "secs" it's funny in a juvinile but satisfying way
08:44:21 <litb> hm, is there a infinite large Fractional for haskell?
08:44:34 <Cale> Data.Ratio
08:44:36 <Cale> Rational
08:45:54 <Tac-Work> > 3 % 4
08:45:57 <lambdabot>  3%4
08:46:09 <Tac-Work> > 3 % 4 + 3 % 4
08:46:10 <lambdabot>  3%2
08:46:14 <litb> can i make it to output it as anuber?
08:46:16 <ski_> > 1 % 0
08:46:16 <lambdabot>  Exception: Ratio.%: zero denominator
08:46:22 <litb> i.e y.x1x2x3...
08:46:30 <litb> *number
08:46:58 <Cale> anyone know if there's a way to get cabal-install to pass on configure flags to the Setup.lhs when building a package? Specifically, I'd like to coerce it into installing profiling libraries for a package.
08:46:59 <Tac-Work> ski_: stop trying to destroy the universe by bottom valued division :-)
08:46:59 <ski_> > fromRational (3%4)
08:47:00 <lambdabot>  0.75
08:47:07 <litb> ah, nice
08:47:29 <ski_> Tac-Work : well, s/he asked for infinite fractionals ..
08:48:24 <Tac-Work> It would be neat to have an extended rational class with values for +/- infinity
08:48:56 <Cale> It would be nice to have a data constructor for affinely and projectively extending other kinds of numbers.
08:49:11 * byorgey is intrigued
08:49:12 <Cale> er, type constructor
08:49:15 <quicksilver> Tac-Work: it's neat in concept but not that neat in practice.
08:49:34 <quicksilver> Tac-Work: it's not all that often that you actually find an algorithm for which such a simple extension makes the algorithm simpler to write.
08:49:38 <Tac-Work> quicksilver: but you could totally brag about it on Reddit and people would be like "Haskell can do that??? whaooo!"
08:49:47 <Tac-Work> quicksilver: I know =-)
08:50:17 <Cale> Tac-Work: What is this class you speak of?
08:50:27 <Cale> :)
08:50:37 <litb> ski_: it would be even better if it would not cut the output
08:51:17 <quicksilver> litb: what ski is doing is converting it to Double.
08:51:23 <byorgey> litb: you mean you want to get the infinite list (repeat 3) from the rational 1%3 ?
08:51:28 <quicksilver> litb: you should also be able to convert it directly to a string.
08:51:34 <byorgey> litb: I think there are libraries to do that sort of thing
08:51:38 <quicksilver> although I'm not entirely sure how
08:52:07 <byorgey> quicksilver: not too hard, just construct the repeating part and then apply 'cycle'
08:52:11 <dcoutts_> byorgey: some updates...
08:52:27 * byorgey hits 'refresh'
08:52:31 <Tac-Work> > show id
08:52:31 <lambdabot>  Add a type signature
08:52:42 <Tac-Work> > show (id :: Int -> Int)
08:52:42 <lambdabot>  "<Int -> Int>"
08:52:44 <quicksilver> byorgey: that sounds daft.
08:52:51 <quicksilver> byorgey: why not just do the long division? :)
08:53:04 <byorgey> quicksilver: well, that's what I mean.
08:53:06 <Cale> dcoutts_: Perhaps you'd know if cabal-install already has a feature to install profiling versions of things?
08:53:40 <byorgey> quicksilver: by 'contstruct the repeating part' I mean 'use long division to construct the repeating part'
08:53:51 <dcoutts_> Cale: sure, the install command takes all the configure options, so you can use --enable-library-profiling
08:53:58 <Cale> ah, okay
08:55:04 <byorgey> quicksilver: is there something I'm missing?
08:56:32 <RayNbow> man, having Maple installed makes you lazy...
08:56:52 <quicksilver> byorgey: I wouldn't bother trying to detect the repeat though
08:56:58 <quicksilver> byorgey: seems like wasted work.
08:57:10 <quicksilver> byorgey: I would just keep doing the long division and spitting out the characters
08:57:13 <oerjan> @let digs r = unfoldr (\r -> if r == 0 then Nothing else Just $ second (10*) $ properFraction r) r
08:57:15 <lambdabot> Defined.
08:57:18 <Cale> RayNbow: how so?
08:57:28 <oerjan> > digs (1%3)
08:57:29 <lambdabot>  [0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
08:57:42 <oerjan> > digs (1%8)
08:57:43 <lambdabot>  [0,1,2,5]
08:57:51 <byorgey> quicksilver: well, I agree that's simpler.
08:58:04 <Cale> > digs 22103%328
08:58:05 <lambdabot>   add an instance declaration for (Integral [d])
08:58:09 <Cale> > digs (22103%328)
08:58:09 <lambdabot>  [67,3,8,7,1,9,5,1,2,1,9,5,1,2,1,9,5,1,2,1,9,5,1,2,1,9,5,1,2,1,9,5,1,2,1,9,5,...
08:58:20 <RayNbow> Cale: well, diff and simplify... :p
08:58:28 <quicksilver> if you want to analytically find the repetition, you scale it up so the denominator is of the form (10^n-1)
08:58:53 <quicksilver> it is a non-obvious fact, to me at least, that the 10^n-1 form a basis for N.
08:58:54 <byorgey> quicksilver: ah, right
08:58:55 <quicksilver> but they do.
08:59:22 * byorgey understood the proof of that once but forgets now.
09:00:17 <Cale> RayNbow: differentiate f(x) = sin(x/(x - sin(x/(x - sin x)))) ... by hand
09:00:24 <byorgey> actually, I think I had to prove that on my number theory midterm  =)
09:01:40 <byorgey> Cale: is that supposed to nest infinitely?
09:01:46 <oerjan> @check \n -> n > 1 ==> (10^n-1) `mod` n == 0
09:01:47 <lambdabot>  Add a type signature
09:01:48 <Cale> byorgey: no
09:01:52 <byorgey> oh, ok
09:01:54 <oerjan> @check \n -> n > 1 ==> (10^n-1) `mod` (n::Integer) == 0
09:01:55 <lambdabot>  Falsifiable, after 0 tests: 2
09:02:07 <byorgey> Cale: I wasn't sure what the ... was for
09:02:16 <Cale> byorgey: it was a dramatic pause
09:02:18 <oerjan> hmph it was not that simple
09:02:23 <quicksilver> oerjan: yes, it's not a basis in that sense.
09:02:28 <byorgey> Cale: oh, I get it =)
09:02:36 <oerjan> oh wait
09:02:40 <quicksilver> oerjan: obviously it's always an odd number, and it never divdes by 5 either :)
09:02:46 <oerjan> @check \n -> gcd n 10 == 1 ==> (10^n-1) `mod` (n::Integer) == 0
09:02:47 <lambdabot>  Exception: Prelude.^: negative exponent
09:02:56 <quicksilver> oerjan: however, I can't quite remember in what sense it is true :)
09:02:59 <oerjan> @check \n -> n > 1 && gcd n 10 == 1 ==> (10^n-1) `mod` (n::Integer) == 0
09:03:00 <lambdabot>  Falsifiable, after 11 tests: 7
09:03:04 <Cale> byorgey: That's actually an exercise in Spivak :)
09:03:06 <oerjan> ok not that either
09:03:08 <RayNbow> <Cale> RayNbow: differentiate f(x) = sin(x/(x - sin(x/(x - sin x)))) ... by hand <-- I'm too lazy to do that :p
09:03:25 <oerjan> oh wait
09:03:38 <byorgey> quicksilver, oerjan: for all integers k such that gcd(k,10) = 1, there exists an n such that k divides 10^n - 1
09:03:38 * Cin has spivak
09:03:42 <oerjan> @check \n -> n > 1 && gcd n 10 == 1 ==> (10^(n+1)-1) `mod` (n::Integer) == 0
09:03:43 <lambdabot>  Falsifiable, after 12 tests: 7
09:04:11 <oerjan> byorgey: yep, but i thought there might be a simple formula for such an n
09:04:24 * oerjan doesn't quite recall
09:04:32 <byorgey> oerjan: well, it's easy to compute, but there's not a "formula" that I know of
09:04:50 <quicksilver> byorgey: yes, that's the one :) thanks.
09:04:51 <byorgey> it involves modular exponentiation
09:06:42 <oerjan> hm wait
09:07:20 <oerjan> the simplest way to prove it is _from_ the long division of 1/k :D
09:07:30 <byorgey> oerjan: yep =)
09:07:56 <oerjan> because the moduli have to repeat
09:08:52 <litb> byorgey: yeah, i wanted repeat 3 :)
09:08:52 <byorgey> you can actually extract a nice proof from the ideas behind long division, without mentioning long division itself
09:09:05 <litb> > print (1%3)
09:09:07 <lambdabot>  <IO ()>
09:09:12 <litb> lolz
09:09:33 <byorgey> litb: well, see oerjan's code for the 'digs' function above
09:09:41 <litb> oh
09:10:33 <litb> wow, nice oerjan
09:11:29 <byorgey> oh, right: saying k divides (10^n - 1) is equivalent to saying 10^n === 1 (mod k)
09:11:47 <litb> what do i need for second tho?
09:11:55 <byorgey> which has a solution when gcd(k,10) == 1 by some elementary number theory result I forget the name of
09:12:05 <byorgey> existence of modular inverses and all that
09:12:06 <oerjan> litb: Control.Arrow
09:12:29 <byorgey> there's really nothing special about 10 =)
09:12:56 <dozer> if darcs is taking insanely long to apply a patch, is it likely that I can apply it manually and get darcs to be happy about that?
09:17:26 <Cale> Heh, apparently Rolle (of Rolle's theorem) never accepted the new notions of Calculus.
09:18:09 <byorgey> Cale: funny. so how/why did he prove that theorem?  or is it just named for him?
09:18:10 <Cale> (which was reasonable, since at the time, nobody could actually tell you what limits were)
09:18:43 <quicksilver> the real line is a funny old thing.
09:18:56 <oerjan> @let showRat r | r < 0 == '-':showRat (-r) | otherwise = sr (digs r) where sr [] = "0"; sr [x] = show x; sr (x:r) = show x ++ '.' : concatMap show r
09:18:57 <lambdabot>  Parse error
09:19:03 <Cale> It's named for him, most likely because of another result he proved about roots of polynomials.
09:19:19 <oerjan> @let showRat r | r < 0 = '-':showRat (-r) | otherwise = sr (digs r) where sr [] = "0"; sr [x] = show x; sr (x:r) = show x ++ '.' : concatMap show r
09:19:21 <lambdabot> Defined.
09:19:21 <Cale> (that wasn't stated in terms of the derivative, but can be interpreted in terms of it)
09:19:34 <oerjan> > showRat (1%3)
09:19:35 <lambdabot>  "0.3333333333333333333333333333333333333333333333333333333333333333333333333...
09:19:41 <quicksilver> oerjan: heh.
09:20:08 <oerjan> > showRat (355%113)
09:20:09 <lambdabot>  "3.1415929203539823008849557522123893805309734513274336283185840707964601769...
09:20:28 <oerjan> litb: ^^
09:20:58 <quicksilver> OMG, pi is rational.
09:21:04 <quicksilver> oerjan has turned the world upside down.
09:21:10 * byorgey stares at it to try to see the period length
09:21:20 <quicksilver> clearly if pi is rational then all this rubbish about cmplex numbers is flawed.
09:21:41 <EvilTerran> oerjan, i'd suggest use of intToDigit rather than show, btw
09:21:47 <EvilTerran> ?hoogle intToDigit
09:21:47 <lambdabot> Data.Char.intToDigit :: Int -> Char
09:21:57 <ddarius> 3.141592_6_
09:22:05 <oerjan> EvilTerran: i didn't want to trigger Ints rather than Integers
09:22:05 <Cale> 355/113 is a particularly good approximation to pi, being one of the convergents of its continued fraction expansion.
09:22:08 <Tac-Work> > 22 % 7
09:22:08 <lambdabot>  22%7
09:22:13 <oerjan> might have used a fromIntegral
09:22:14 <EvilTerran> i see
09:22:25 <byorgey> > head . filter ((==1) . (`mod` 113)) $ iterate (*10) 1
09:22:26 <lambdabot>  1
09:22:27 <EvilTerran> but then it all gets a bit tedious
09:22:29 <Tac-Work> > fromRational (22 % 7)
09:22:29 <lambdabot>  3.142857142857143
09:22:31 <byorgey> > head . filter ((==1) . (`mod` 113)) $ iterate (*10) 10
09:22:32 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
09:22:38 <byorgey> > length . head . filter ((==1) . (`mod` 113)) $ iterate (*10) 10
09:22:39 <lambdabot>   add an instance declaration for (Integral [a])
09:22:45 <byorgey> > length . show . head . filter ((==1) . (`mod` 113)) $ iterate (*10) 10
09:22:45 <lambdabot>  113
09:22:50 <byorgey> ah, no wonder =)
09:22:52 <Cale> (and one which incorporates an unusually large term of that CF-expansion)
09:23:15 <byorgey> Cale: that's the 292, right? =)
09:23:34 <Cale> er, actually it incorporates the terms up to, but not including that term
09:23:37 <Cale> yeah
09:23:42 <byorgey> right
09:24:56 <oerjan> > fromRat pi -- don't think it actually depends on Rational
09:24:57 <lambdabot>   add an instance declaration for (Floating Rational)
09:25:03 <oerjan> oh it does
09:25:08 <oerjan> er wait
09:25:13 <oerjan> > showRat pi -- don't think it actually depends on Rational
09:25:14 <lambdabot>  "3.141592653589793115997963468544185161590576171875"
09:25:35 <oerjan> it's worse, pi is terminating :D
09:25:38 <Cale> So you have this unusually good rational approximation. You get 6 digits with a denominator that only has 3.
09:25:48 <byorgey> dcoutts_: are you still adding stuff to that wiki page, or can I add some stuff?
09:26:04 <dcoutts_> byorgey: let me commit, then you go
09:26:18 <byorgey> ok
09:26:34 <byorgey> well, you probably already added the stuff I was going to add then =)
09:26:42 <Cale> what-: dude
09:26:47 <dcoutts_> byorgey: refresh and check
09:26:49 <oerjan> > showRat (10^50 + 1%2) -- checking big integer part
09:26:50 <lambdabot>  "100000000000000000000000000000000000000000000000000.5"
09:27:04 <what-> Cale: just playing around
09:28:40 <Cale> Heh, that's funny. Searching for "zip" in the mathematica documentation produces the article for "Thread" as a result, and what do you know, Thread is a kind of generalisation of zip :)
09:29:04 <Tac-Work> it is?
09:29:16 <Cale> But the word zip doesn't occur in that article.
09:29:17 <monochrom> Which thread and which zip?
09:29:32 <Cale> monochrom: I'm thinking of the zip from Haskell
09:30:18 <litb> oerjan: lol, thxx
09:30:21 <litb> you rule^^
09:30:23 <Cale> Thread[f[{a,b,c},{x,y,z}]] = {f[a,x], f[b,y], f[c,z]}
09:30:27 <Cale> for any f
09:30:55 <Tac-Work> ahk, mine eyes!
09:31:09 <Tac-Work> not a paren in sight! how does it work?
09:31:09 <monochrom> What's wrong with your eyes?
09:31:47 <byorgey> Cale: so Thread does some kind of structure analysis on its argument?
09:31:50 * Tac-Work advises everyone to ignore him while he's bored at work
09:32:04 <ddarius> Tac-Work: Does x(y+z) mean x*(y+z) or x applied to y+z?
09:32:04 <Cale> byorgey: yeah.
09:32:23 <quicksilver> > showRat (10^30 + 1%(10^30))
09:32:24 <lambdabot>  "1000000000000000000000000000000.000000000000000000000000000001"
09:33:16 <quicksilver> > length $ showRat (10^300 + 1%(10^300))
09:33:17 <lambdabot>  602
09:33:21 <litb> @src second
09:33:22 <lambdabot> Source not found. My mind is going. I can feel it.
09:33:30 <oerjan> @src Arrow
09:33:31 <lambdabot> class Arrow a where
09:33:31 <lambdabot>     arr, pure   :: (b -> c) -> a b c
09:33:31 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
09:33:31 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
09:33:31 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
09:33:32 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
09:33:33 <quicksilver> oerjan: looks good to me :)
09:33:34 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
09:33:54 <litb> oh nooo! i'm lost o.O
09:34:00 <byorgey> litb: for the (->) instance of Arrow, second f = \(a,b) -> (a, f b)
09:34:32 <quicksilver> litb: second is like fmap, for the "right" half of a tuple
09:34:39 <quicksilver> litb: and first is for the left half
09:34:48 <byorgey> litb: in general, second a  takes an Arrow a, and produces a new Arrow which takes pairs, and leaves the first element unchanged while applying a to the second element
09:35:21 <Cale> > fmap (*2) (1,1)
09:35:22 <lambdabot>  (1,2)
09:35:39 <byorgey> litb: Arrow a => a b c  represents a computation with input type b and output type c.
09:35:53 <oerjan> litb: Arrow is a generalization of functions, but functions themselves are an instance, and many of the Arrow methods are useful for it
09:35:58 <Cale> (Just thought I'd throw that in there, you're free to ignore it :)
09:36:53 <quicksilver> funnily enough, Arrows are not the functional generalisation I normally want.
09:37:01 <quicksilver> normally they're almost the opposite direction.
09:37:07 <jfredett> cale, what the...
09:37:11 <jfredett> how does that
09:37:12 <oerjan> litb: basically whereever you see a something1 something2 above, think of it as something1 -> something2
09:37:22 <Cale> fmap f (x,y) = (x, f y)
09:37:31 <jfredett> *thinks about the fmap (*2) (x,y) bit*
09:37:32 <litb> ah, rite. thanks for enlighting me :) i will dig into that
09:37:41 <byorgey> jfredett: there's a Functor instance for (,) a
09:37:45 <jfredett> thats cool as hell...
09:37:46 <quicksilver> they had to arbitrarily choose one side to make functorial, in a sense
09:37:51 <quicksilver> although they both are, of course
09:37:59 <quicksilver> although the way haskell Functor is written, it was the only choice
09:38:11 <Cale> Which, incidentally, is why State and Writer have their pairs backwards.
09:38:14 <jfredett> yeh, I wish I could have multiple instances of a class somehow
09:38:17 <quicksilver> since it can only be a * -> * in one direction.
09:38:23 <Cale> (and ought to be corrected)
09:38:51 <byorgey> Cale: corrected how?
09:39:01 <monochrom> What is correct?
09:39:03 <quicksilver> Cale: doesn't matter a lot though, because they should be thought of mostly as abstract.
09:39:12 <Cale> byorgey: runState :: State s a -> s -> (s,a)
09:39:18 * byorgey has vague thoughts about type-level lambda expressions
09:39:24 <Cale> :t runState
09:39:25 <lambdabot> forall s a. State s a -> s -> (a, s)
09:39:31 <quicksilver> mostly :)
09:39:49 <byorgey> Cale: oh, ok, I thought you meant something more than that
09:40:26 <Cale> I found another very subtle design problem in the list library too :)
09:40:31 <byorgey> Cale: since you said they are flipped that way due to a language restriction, I thought you were proposing some sort of language extension =)
09:40:39 <oerjan> Cale: the pairs are irrelevant, and the (a, s) order is used nearly everywhere that resembles state, such as in unfoldr
09:41:02 <Cale> oerjan: I'm saying that's actually backwards, and we ought to use (s,a)
09:41:16 <Cale> Because the functor instance is for (,) s
09:41:23 <oerjan> hm...
09:41:28 <jfredett> well, maybe it'd be easier to change t he functor instance?
09:41:40 <oerjan> jfredett: unfortunately no
09:41:44 <jfredett> how many people have state code that'd get depreciated
09:41:48 <Cale> another really subtle flippage is that mapAccumR would be nicer if it were mapAccumR . flip
09:42:01 <jfredett> vs number of people using functor version? :/
09:42:01 <byorgey> Cale: I'm confused now.  what did you mean by  <Cale> Which, incidentally, is why State and Writer have their pairs backwards.  ?
09:42:02 <oerjan> a functor instance must be on the last parameter.
09:42:08 <Cale> jfredett: It's impossible to change the functor instance.
09:42:13 <jfredett> really?
09:42:17 <Cale> jfredett: yes
09:42:19 <jfredett> that seems... odd
09:42:26 <Cale> jfredett: We don't have type lambdas.
09:43:01 <byorgey> jfredett: a Functor instance has to be a partially applied type, i.e. something of kind * -> *
09:43:02 <Cale> byorgey: They have their pairs the wrong way around.
09:43:03 <monochrom> I see how to parse that sentence now. Perverted.
09:43:11 <jfredett> thats really a weird thing, it seems so easy, but then in run the type lambdas
09:43:19 <jfredett> @src Functor
09:43:19 <lambdabot> class  Functor f  where
09:43:19 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
09:43:31 <Cale> instance Functor ((,) s) where
09:43:42 <Cale>    fmap f (x,y) = (x, f y)
09:43:44 <litb> this channel seem to have a lot of informations on its website. it's very good. thumbs up
09:43:58 <litb> s/seem/seems/
09:44:07 <jfredett> litb: we try, :)
09:44:20 <dcoutts_> byorgey: did you make the wiki changes you wanted to?
09:44:32 <byorgey> dcoutts_: you already made them =)
09:44:33 <Cale> Also, information is a mass noun, so you don't need to pluralise it.
09:44:42 <dcoutts_> byorgey: ok :-)
09:45:01 <monochrom> Godawful singular-plural-countable-uncountable mess.
09:45:17 <monochrom> Information is a mass noun. English is a mess language.
09:45:30 <Cale> http://cale.yi.org/index.php/Fold_Diagrams -- you can see the problem with mapAccumR visually at the bottom of this page.
09:45:34 <lambdabot> Title: Fold Diagrams - CaleWiki
09:45:47 <mrd> you obtains your informations on the internets
09:46:33 <monochrom> you haz informationez :)
09:46:47 <Cale> The parameters to the input function are backward, and so the graph structure ends up looking funny.
09:48:16 <Cin> i may have to use IORefs soon. storing the users in the function's arguments was working fine but when i add channels and other things it's going to get messy
09:48:37 <Cale> Cin: You can make a datatype which holds all the state.
09:48:50 <Cin> ah, good point
09:49:20 * mrd disagrees with lolcats.  first of all, if cats could spell, they would do so impeccably
09:50:02 <Cin> what's that feature called where you can refer to only parts of a datatype?
09:50:15 <mrd> pattern matching?
09:50:16 <Cin> i read about it in YAHT but haven't used it since..
09:50:20 * Cin opens yaht
09:50:33 <Tac-Work> mrd: they are smart, yes, but smart enough to know that speaking pidgin melts the hearts of their human owners / internet voyers
09:50:39 <Cale> mrd: Like Twisp of Twisp and Catsby :)
09:50:46 <Cin> fields?
09:50:46 <mrd> right
09:50:57 <mrd> records have fields
09:51:16 <Cin> data Foo = bar :: mu -- something like that?
09:51:19 <mrd> twisp isn't the other guy?
09:51:22 <monochrom> w00t, new picture on lambdacats!
09:51:40 <oerjan> data Foo = Foo { bar :: mu }
09:52:01 <Cale> Catsby is the imp :)
09:53:20 <Cin> so let's say you have data State = State { users :: UserMap, chans :: ChannelMap }
09:53:31 <Cin> what kind of stuff can i do with that when pattern matching?
09:53:43 <Cin> i remember there being something nifty that you can do with it
09:54:07 <Cale> Cin: you can match it with a single variable and later apply  users  or chans as a function to extract that part, first of all
09:54:14 <oerjan> case st of State { users = u } for example
09:54:18 <Cale> Or, you can pattern match only one of the fields
09:54:25 <Cale> like oerjan just demonstrated
09:54:26 <cnwdup> Is there a documentation for haskell-xft? I can't find anything.
09:54:41 <Cin> ahhh. i found it
09:54:48 <Cin> absPoint (Pt {pointx = x, pointy = y}) = sqrt (x*x + y*y)
09:54:49 <what-> cale: your wiki rocks, got some nice monad-readings for the weekend
09:54:56 <Cin> being able to extract single bits from it
09:55:00 <Cale> cnwdup: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11-xft-0.2 -- the docs linked from here, perhaps
09:55:00 <lambdabot> http://tinyurl.com/3b9x6m
09:55:01 <Cale> ?
09:55:09 <oerjan> and you can modify:  st { users = newUser "fnord" : users st }
09:55:27 <cnwdup> Cale: I don't see any. O:
09:55:41 <Cale> The module names are links
09:55:43 <Cin> oerjan: what is 'st'? in this context? the value?
09:55:45 <Cale> click them :)
09:56:02 <oerjan> Cin: st is the State value you start with
09:56:09 <cnwdup> Cale: Fanzy. Thank you. :D
09:56:31 <Cin> oerjan: ahh. that will be much better than having to write out the whole structure each time i want to modify one of its parts
09:56:40 <cnwdup> s/z/c/
09:56:49 * Cin modifies various areas of his code..
09:56:52 <largos> can someone explain the difference between Int and Integer?  (eg: :t length("str") and :t it, after performing an addition (+) of two natural numbers in ghci?
09:56:59 <igel> someone familiar with compiling ndp (nested data parallel) haskell?
09:57:06 <Cale> I just wish they'd use the newer haddock with the syntax-coloured source links hanging off the documentation.
09:57:07 <monochrom> > 2^40 :: Int
09:57:09 <lambdabot>  0
09:57:16 <monochrom> > 2^40 :: Integer
09:57:16 <lambdabot>  1099511627776
09:57:21 <monochrom> That's the difference.
09:57:36 <largos> monochrom: ah..
09:57:42 <Cale> Inexplicably, half the Prelude uses Int.
09:58:06 <monochrom> I'm fine with Int.
09:58:30 <Cale> I'm not. Those functions ought to be generic.
09:58:46 <monochrom> They're quite available from Data.List.
09:58:53 <Cale> (with SPECIALISE pragmas of course)
09:58:59 <largos> > it
09:59:00 <lambdabot>   Not in scope: `it'
09:59:03 <monochrom> That's just engineering.
09:59:04 <Cale> typing genericLength is dumb
09:59:14 <oerjan> Cale: if they were generic then they would tend to default to Integer
09:59:22 <Cale> oerjan: right, as they should
09:59:34 * monochrom hugs his Int
09:59:47 <Cale> Int is an optimisation, one which is often premature.
10:00:06 <ketil> monochrom, 2^40 ?!  Why not 2^32?
10:00:25 <byorgey> largos: to be explicit, Int corresponds to a machine-sized integer, whereas Integer is unbounded.
10:00:26 <largos> ketil: avoids off-by-one confusion?
10:00:33 <byorgey> > 30 ^ 65 :: Integer
10:00:34 <lambdabot>  1030105146087753745397354726784300000000000000000000000000000000000000000000...
10:00:38 <monochrom> Why optimise?
10:00:45 <cjb> ketil: It fails for 2^32 too.
10:00:51 <largos> byorgey: cool
10:00:55 <ketil> > 2^32 :: Int
10:00:56 <lambdabot>  0
10:01:00 <ketil> > 2^33 :: Int
10:01:01 <lambdabot>  0
10:01:04 <ketil> > 2^34 :: Int
10:01:05 <lambdabot>  0
10:01:06 <oerjan> > 2^31 :: Int
10:01:07 <lambdabot>  -2147483648
10:01:14 <ketil> Wrchz?!
10:01:21 <ketil> I though it should wrap??!
10:01:22 <cjb> But will an Integer be stored in an int if appropriate?
10:01:29 <oerjan> ketil: 2's complement
10:01:30 <Cale> cjb: yes
10:01:39 <monochrom> @src Integer
10:01:39 <lambdabot> data Integer = S# Int#
10:01:39 <lambdabot>              | J# Int# ByteArray#
10:01:51 <cjb> Oh.  So there really isn't a very good reason to have prelude use Int.
10:02:04 <Saizan> ketil: 0 + 0 = 0
10:02:06 <Cale> Right. Just the speed.
10:02:12 <cjb> Unless Integer wastes extra memory with a tag or something.
10:02:20 <Cale> and the speed hit isn't even all that large
10:02:47 <byorgey> cjb: well, it does, and it's slower, BUT these shouldn't be considerations in the prelude, IMO.
10:02:53 <monochrom> I actually think it is large.
10:02:53 <cjb> byorgey: That makes sense.
10:02:56 <Cale> Plus, if you defined the operations generically, people could still explicitly specify Int if they wanted it.
10:03:27 <Cale> Int should be relegated to a non-prelude library.
10:03:35 <Cale> I suggest Data.Int
10:03:50 <Feuerbach> If I do {h <- fileOpen ...; x <- hGetContents h; hClose h} and then use x, it is empty. Isn't hGetContents strict in IO monad?
10:04:04 <oerjan> Feuerbach: absolutely not
10:04:07 <monochrom> It is emphatically lazy.
10:04:28 <monochrom> Don't close h. Don't pass Go. Don't collect $200.
10:04:46 * ketil slaps himself.  Of course!
10:04:59 <monochrom> @slap ketil
10:04:59 * lambdabot pushes ketil from his chair
10:05:03 <Cale> Feuerbach: it'll close h for you when you're done with the string
10:05:06 * monochrom giggles
10:05:27 <Cale> You shouldn't use any handle after applying a getContents-like operation to it.
10:05:43 <monochrom> "done with the string" is ambiguous.
10:05:53 <Cale> (unfortunately, it's awkward to statically enforce that)
10:05:59 <mrd> linear types!
10:06:05 <Feuerbach> thank you all
10:06:12 <ketil> > 2^30
10:06:13 <lambdabot>  1073741824
10:06:34 <ketil> > map (2^30*) [1,2,3,4]
10:06:34 <lambdabot>  [1073741824,2147483648,3221225472,4294967296]
10:06:46 * ketil sighs.  ::Int
10:06:51 <ketil> > map (2^30*) [1,2,3,4::Int]
10:06:51 <lambdabot>  [1073741824,-2147483648,-1073741824,0]
10:07:02 <gbacon> in a cabal file, how can I make dependencies conditional on the version of ghc?
10:07:35 <gbacon> for ghc-6.8+, I need old-locale, but not with 6.6
10:07:50 <Cale> gbacon: perhaps use the version number of base
10:09:19 <gbacon> so in "build-depends: base >= 3, containers, directory, process", are the subsequent packages dependent on the satisfying the base version constraint?
10:09:26 <Cale> base (<3) or base (>=3.0), old-locale
10:10:01 <Cale> gbacon: comma means 'and'
10:10:37 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-0.4.1  has a good complex example
10:10:38 <lambdabot> http://tinyurl.com/28wqy4
10:10:52 <Saizan> http://hackage.haskell.org/packages/archive/xmonad/0.5/xmonad.cabal <-- se small_base here
10:10:55 <lambdabot> http://tinyurl.com/2a2bec
10:11:09 <Cale> ah, in the .cabal file, the syntax is || for or
10:11:11 <conal> anyone know about planet.haskell.org maintenance?  i asked antti-juhani a few days ago to add my new blog and haven't heard back.
10:11:34 <kaol> ibid: ping ^
10:12:04 <dons> conal: it takes a few days usually
10:13:27 <conal> dons: i just looked, and it's been nine days.  is that normal?
10:14:00 <dons> it depends on what ibid is doing. that's getting to the bounds of almost abnormal
10:14:30 <conal> oh -- i see his latest blog post: http://antti-juhani.kaijanaho.fi/newblog/archives/285
10:14:32 <lambdabot> Title: Antti-Juhani Kaijanaho  Blog Archive  A visit at the emergency room
10:15:13 <byorgey> conal: it took him about three or four weeks to add mine =)
10:15:37 <conal> byorgey: yurk.  maybe we'd better get the process opened up.
10:15:53 <conal> at least have one or two back-up folks.
10:16:05 <byorgey> conal: yeah, that'd probably be good.
10:16:15 * byorgey wouldn't mind volunteering
10:17:07 <vegai> dons: I talked with him today here, actually
10:17:11 <Cale> From the compendium of poorly thought out marketing schemes: "Look inside specially marked eggs! You could be a winner!"
10:17:17 <dons> heh
10:17:30 <byorgey> wha...?
10:17:55 <gbacon> where's the definition for bytestring-in-base?
10:18:13 <gbacon> cf. binary.cabal
10:26:08 <gbacon> spooky
10:26:22 <dons> gbacon: ?
10:26:32 <gbacon> with flags, cabal files are prolog programs? :-)
10:26:40 <dons> yep
10:26:44 <dons> its a constrain solver
10:26:54 <dons> don't ask me how this happened
10:27:00 <conal> i just emailed Antti-Juhani, proposing sharing the haskell planet maintenance.
10:27:12 <dons> cool,conal . thanks for stepping up!
10:27:13 <gbacon> yikes.. cargo-culting encouraged :-)
10:27:19 <conal> :)
10:27:52 <nominolo> dons: no no. it's the simplest, stupidest implementation i could think of
10:28:04 <dons> nominolo: :) its fine -- it works and hackage is booming
10:28:13 <nominolo> dons: i really did not want to put a constraint solver in cabal ;)
10:28:22 <dons> nominolo: do you know of other constraint solving package managers?
10:28:27 <dons> is it a unique feature ?
10:28:29 <Cale> nominolo: So... what is in cabal then?
10:28:38 <Cale> ;)
10:28:39 <oerjan> haskell, the language where even the build tools are turing complete
10:29:39 <kaol> make was around well before Haskell
10:30:15 <nominolo> Cale: basically the list monad
10:30:16 <dons> kaol: its not doing the kind of constraint solving for rules cabal does. that's more just pattern matching :)
10:30:22 <oerjan> somehow that didn't come out quite right
10:30:27 <byorgey> how about "haskell, the language where the build tools are unintentionally turing complete"? =)
10:30:36 <nominolo> Cale: but i did some tricks to get reasonably short error messages
10:30:44 <oerjan> byorgey: sold!
10:30:57 <gbacon> nominolo++
10:31:27 <kaol> @where ndp
10:31:27 <lambdabot> http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/ http://www.cse.unsw.edu.au/~chak/project/dph http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
10:31:56 <Nafai> byorgey: Unintentionally Turing complete, the way C++ templates are? :)
10:32:13 <kaol> ouch, that was a low blow
10:32:34 <oerjan> darn we were beaten...
10:32:47 <nominolo> Haskell's type system (with MPTC and FPs) is turing complete, too
10:32:58 <byorgey> Nafai: well, when you put it that way, maybe it's not such a great slogan after all... =)
10:33:06 <Nafai> Heh
10:33:23 <Nafai> Sorry, that's just the first thing I thought of when you said "unintentionally Turing complete"
10:33:35 <invlim> anyone get type signatures for non-prelude functions working in emacs haskell-mode?  I can't seem to get it to happen, tried debian package, self-installing the latest, etc
10:33:54 <nominolo> invlim: what do you mean?
10:34:36 <invlim> when the cursor is just after the function name, it displays the type signature in the bar
10:35:02 <nominolo> you mean   (turn-on-haskell-doc-mode)
10:35:04 <nominolo> ?
10:35:11 <litb> do you know the "tasteofHaskell" ?
10:35:43 <litb> he is working at microsoft and using xmonad. lol
10:35:56 <invlim> yeah, I have turned it on, manually and .emacs, but it still doesn't pick up locally defined functions -- just the prelude functions.
10:36:01 <litb> it's great: http://research.microsoft.com/~simonpj/papers/haskell-tutorial/index.htm
10:36:02 <lambdabot> Title: A taste of Haskell (tutorial), http://tinyurl.com/ypuvug
10:36:17 <nominolo> invlim: yes, that doesn't work
10:36:21 <litb> invlim: i have the same problem
10:36:31 <nominolo> invlim: shim can do that under some circumstances
10:37:17 <invlim> ok so it is a common problem, doesn't work for anyone?
10:37:27 <nominolo> invlim: right
10:37:39 <litb> invlim: ah, you have to "haskell-doc-show-global-types"
10:38:27 <litb> and haskell-doc-show-user-defined maybe too
10:38:48 <litb> anyway, it works after i enabled those too. great :)
10:39:21 <oerjan> litb: spj is probably the most famous guy in the haskell community
10:39:32 <invlim> hmm,  still no love for me...  but it works fro you, that is encouraging.
10:39:32 <oerjan> famous in the community, at any rate
10:39:59 <litb> oerjan: oh, i see
10:40:10 <litb> that's why his slides are so cute
10:41:18 <BMeph> It's part of the irony of Microsoft Research being so supportive of Haskell.
10:42:08 <nominolo> and he's got a very idiosyncratic taste in pullovers ;)
10:43:00 <litb> maybe they do that because they want to adopt parts of haskell (ideas) to c#
10:47:09 <nominolo> microsoft research seems to be rather different from MS Redmond
10:48:09 <monochrom> It shows that stereotypes break.
11:00:52 <shapr`> Is there anyway to get sloppy focus in windows?
11:01:33 <Zao> shapr`: Windows [TM]?
11:01:48 <Zao> shapr`: Install the Powertoys, and there's a whole Xmouse section.
11:06:43 * ibid processes planet requests in batches
11:08:07 <ibid> the oldest request i have on file dates from jan 11
11:09:19 <Cale> Except that iirc, that powertoy never worked quite the way I wanted it to. It was a long long time ago that I used it, though.
11:09:41 <ptolomy> http://www.wagerlabs.com/blog/2008/01/introducing-fac.html <- a public call for haskell benchmarks, and nobody yet has responded.
11:09:42 <lambdabot> Title: Tenerife Skunkworks: Introducing Factor
11:10:04 <vincenz> ptolomy: most people are a bit tired of his flipping about
11:10:14 <ptolomy> vincenz: And understandably so.
11:10:30 <ptolomy> It actually amuses me, because he's jumping into My Industry.
11:10:36 <Cale> I seem to recall there was some horrible flaw in the way that it handled point-to-focus, like maybe it was that if you pointed away from a window, it got defocused, even if you weren't pointing at another window.
11:10:49 <vincenz> ptolomy: which industry is that?
11:10:57 <ptolomy> I have done a good bit of work for the CME (Chicago Mercantile Exchange).
11:11:02 <Cale> ptolomy: I wrote one. It took just under a second.
11:11:03 <ptolomy> And built numerous custom trading platforms.
11:11:16 <kaol> you're a quant?
11:11:17 <Cale> I haven't responded yet though.
11:11:20 <ibid> (batches because it takes less time and energy to do multiple at the same time, and i get about one every week or so)
11:11:32 <vincenz> ptolomy: "My Industry" ?
11:11:45 <Cale> Mainly because the Haskell solution to that precise problem is currently messy.
11:11:54 <ptolomy> kaol: Nope. :) I know very little about finance. What I do is closer to distributed systems and realtime something something.. it's boring, really.
11:12:02 <gwern> @pl insert  = do c ← satisfy (const True); write (insertE c)
11:12:02 <lambdabot> (line 1, column 17):
11:12:02 <lambdabot> unexpected "\134"
11:12:02 <lambdabot> expecting variable, "(", operator or end of input
11:12:28 <gwern> hm. isn't there a funtion on lambdabot to go from do to bind notation?
11:12:28 <jedbrown> (===) :: (Model i a, Model i a', Model b c, Model b' c, Eq c)
11:12:28 <jedbrown>          => (a -> b) -> (a' -> b') -> i -> Bool
11:12:28 <jedbrown> (f === g) x = model (f (model x)) == model (g (model x))
11:12:28 <jedbrown>  
11:12:33 <gwern> @undo insert  = do c ← satisfy (const True); write (insertE c)
11:12:33 <lambdabot>  Parse error at "=" (column 9)
11:12:35 * ibid would not in fact be totally against passing the maintenance along. i'd just have to check that any candidate has the right mindset and - of course - has an account on the relevant machine
11:12:43 <gwern> @undo do c ← satisfy (const True); write (insertE c)
11:12:43 <lambdabot>  Illegal character ''\134''
11:12:43 <lambdabot>  at "" (column 7)
11:12:44 <shachaf> @. pl undo insert = do c <- satisfy (const True); write (insertE c)
11:12:44 <lambdabot> insert = write . insertE =<< satisfy (const True)
11:12:58 <jedbrown> How can I fix this ^^^  ??
11:13:14 <gwern> shachaf: ah, so it's '@.'?
11:13:22 <shachaf> gwern: @. is for composition.
11:13:53 * byorgey also wonders about the " ←" character in gwern's input to @undo
11:13:55 <shachaf> @@ @pl (@undo f = do x <- y; return z) -- @@ also works.
11:13:55 <lambdabot>  f = y >> return z
11:14:04 <shachaf> gwern: Yes, that is a bit odd.
11:14:12 <jedbrown> GHC says it can't deduce (Model b b1) from the context, but there is no b1 in the context.
11:14:20 <gwern> byorgey: unicode symbols. I keep forgetting how my emacs uses PrettyLambda
11:14:34 <byorgey> gwern: heh
11:16:12 <ibid> kaol, Cale, dons: see above
11:16:13 <shapr`> Zao: ooh, good idea!
11:16:20 <vincenz> jedbrown: that code is undecideable
11:16:30 <vincenz> jedbrown: use something like
11:16:40 <vincenz> (model (f (model x)) :: c) == ..
11:16:41 <ibid> bah. kaol, conal, dons: see above
11:16:49 <vincenz> jedbrown: nothing's forcing thta model to a c
11:16:56 <dons> "Im bumping into this brick wall of batteries included, the notion that the python library comes with a lot of stuff that should be good enough for whatever you need to do. Only problem is that it doesngt. XML parsing stinks in Python; http IO stinks (need lots of third party stuff to make that usable); no UTF-8 by default"
11:16:57 <vincenz> jedbrown: but even then, that code is undecideable
11:17:25 <jedbrown> vincenz: Ah, yes.  I can't do it all with that function.
11:17:43 <vincenz> jedbrown: unless
11:17:48 <vincenz> class Model b c | b -> c
11:18:02 <jedbrown> vincenz: Oh, good idea.
11:20:39 <monochrom> What? Python libraries unusable and lacking? That's news to me. :)
11:20:53 <monochrom> Seems like user expectation has raised. :)
11:21:42 <monochrom> Next year they will complain that CPAN is useless. That will be the day when Haskell reigns. :)
11:21:46 <conal> ibid: what would you like to know about mindset?  and maybe you have any other ideas about what would help you with faster turnaround on haskell planet requests.
11:23:09 <gwern> cpan has a very ugly website and interface. we can do better
11:23:33 <conal> ibid: i guessed you were overloaded and might like some help.
11:23:59 <jedbrown> vincenz: Thanks, that's working great.
11:24:06 <vincenz> \o/
11:24:07 <kaol> monochrom: Haskell will still have to overcome millions of PHP script kiddies
11:24:16 <ibid> conal: not overloaded in the sense that i could not have done that earlier.  i just like to get a neat pile to work on as a batch.  sometimes people nag me and i get to it sooner (like now) :)
11:24:29 * kaol won't dignify calling them "PHP programmers"
11:24:35 <ibid> (planet is updating)
11:24:42 <conal> ibid: i see.  thanks.
11:24:44 <ibid> conal: but yeah, i'm pretty busy overall
11:24:48 <gwern> ('We shall overcome'; 'It takes an Internet of Millions to Hold Us Back')
11:26:08 <ibid> conal: on the mindset. a question for anyone who wants to help: what do you think of the current eligibility requirements, please elaborate (probably in email, don't flood the channel)
11:26:38 <ibid> conal: i was going to send that to you by email, but i think this'll work as well :)
11:27:03 <conal> ibid.  yep
11:27:35 <ehird> odd question: is there a way to simulate writing code monadically without using monads? in this case, it'd look nicer i think
11:27:41 <ibid> (for the record, there were three requests outstanding)
11:27:57 <dons> thanks ibid !
11:28:10 <ehird> well, I guess:
11:28:19 <ehird> (>>>) a b = b a
11:28:41 <ehird> wait no
11:28:59 <Cale> a >>> b = b . a
11:29:31 <ibid> conal: also note that the question might have a trick in it, depending on if you have looked at it from the right angle :)
11:29:38 * gwern groans. so many outdated keymaps in yi!
11:29:42 <conal> btw, here's a visitor i had this week: http://hollyc.com/hollosphere/?p=51
11:29:43 <lambdabot> Title: The Hollosphere  Blog Archive  Audrey Snacks
11:29:47 <Cale> ehird: That's not using a monad though, it's using an Arrow
11:29:53 <shapr`> Yeah,but I forgot the name.
11:30:02 <shapr`> argh, was scrolled back
11:30:03 <ehird> Cale: Well, yes. :P
11:30:08 <ehird> I should just use NothingMonad
11:30:14 <ehird> It's a Monad without any state, IO, anything!
11:30:17 <ehird> :D
11:30:21 <Cale> Identity
11:30:25 <ehird> ... Okay, you win.
11:30:45 <ehird> What package is that in?
11:30:48 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Identity.html
11:30:50 <lambdabot> http://tinyurl.com/yosw2p
11:31:33 <ehird> Aww, cute identity monad.
11:31:53 <ehird> By the way. I think the haskell-mode I have isn't the regular haskell mode.
11:32:00 <dylan> ehird: why are you not in sine? :)
11:32:10 <ehird> It seems incredibly crappy. Where can I download the super-awesome haskell-mode that I hear so much about? :P
11:32:19 <ehird> dylan: hmm, switched irc clients, forgot to readd
11:32:26 <cjb> how well does/can Haskell parallelize (pure functions) across CPUs?
11:32:30 <dylan> well, fix that. :)
11:32:39 <cjb> s/Haskell/GHC/, I suppose
11:32:59 <ehird> dylan: I did so :P
11:33:03 <Cale> cjb: It can do it very well, but not automatically. You need to add annotations which mark things that could potentially evaluate in parallel.
11:33:21 <phobes> cjb:  across CPUs meaning across cores?
11:33:43 <Cale> The expression x `par` y when evaluated will "spark" x, and result in y.
11:34:11 <Cale> Sparking an expression means putting it in a queue of work to possibly be done an free processors.
11:34:12 <slarba_> is the parallel gc there yet?
11:34:14 <Cale> on*
11:34:29 <slarba_> :)
11:35:00 <cjb> Cale: Out of curiosity, why can't we parallelize pure functions without annotation?
11:35:03 <mrd> i think the current development on parallel gc isn't in parallel with the mutator, but rather a parallel gc algorithm
11:35:27 <cjb> phobes: Yes, across cores is fine.
11:35:34 <phobes> cjb:  I'd guess the problem is figuring out where parallelization is a win
11:35:44 <Cale> cjb: Because sparking computations is expensive enough that doing it with every expression is wasteful, but figuring out which expressions are worth sparking is difficult.
11:35:50 <dons> cjb: we can. but its still a research problem
11:35:56 <cjb> I see.  Okay!
11:35:57 <dons> it needs runtime profiling and a cost model
11:36:07 <cjb> One can imagine running your program once and.. right.
11:36:13 <dons> since its very difficult to statically assign costs to thunks
11:36:27 <dons> but at least we can parallel code with light annotations :)
11:36:32 <dons> doesn't require full restructing.
11:36:40 <dons> so already about 10 years ahead of everyone else
11:36:43 <Cale> It's also possible to build richer abstractions out of par.
11:36:53 <dons> we need to take advantage of this *seriously*.
11:36:57 <slarba_> for some reason, I haven't had very good results with par & seq... I think the gc might be a serious bottleneck if the sparked threads produce loads of garbage
11:36:58 <Cale> Like the Control.Parallel.Strategies library.
11:37:20 <cjb> I guess I have a dream of watching my code magically float to take up 16 cores without me writing anything, but I think the conclusion is that it could do that but it wouldn't achieve what I actually want.
11:37:22 <dons> slarba_: that's one thing. i think  SimonM is keen for any performance benchmarks, if you have them
11:37:25 <cjb> Which is for my programs to run faster.
11:37:34 <dons> slarba_:  he really wants programs that will need parallel GC
11:37:46 <dons> slarba_: also, you have to be careful not to spark too much
11:37:54 <dons> which means using Strategies
11:38:05 <phobes> cjb:  The thing is that if you don't design your program well, the automatic parellizer that works by running once and seeing what to profile might not turn much up
11:38:05 <cjb> Cale: Thanks, I'll read up.  Is it possible to define a strategy that says "parallelize everything pure without computing cost"?  That would be neat to see.
11:38:12 <litb> who is the most experienced FP guru in the world?
11:38:14 <hpaste>  BSP pasted "Type class dilemma" at http://hpaste.org/5218
11:38:16 <slarba_> dons: yeah...
11:38:16 <fasta> dons: why would it take 10 years to port "par" to e.g. Scheme?
11:38:17 <phobes> cjb: or running many times
11:38:19 <dons> sure. but that's a bad strategy, cjb :)
11:38:22 <cjb> phobes: Yeah, of course.  Much like normal profiling.
11:38:37 <Cale> I have a message from Simon Marlow from 2006 saying that parallel GC would likely be in 6.8
11:38:38 <BSP_> does anyone know how i might fix the code at http://hpaste.org/5218
11:38:41 <dons> fasta: it wouldn't, if they wanted to.
11:38:48 <radix> this simon peyton-jones talk is awesome.
11:38:54 <fasta> dons: so, where do you get your 10 years from?
11:38:56 <dons> but they'll need to modify the runtime, do some effect inference...
11:38:57 <cjb> radix: the dotnet one?
11:38:58 <Cale> cjb: You can do things like evaluate all the elements of a list in parallel.
11:39:01 <phobes> cjb:  My point is that restructuring to expose parellism might be needed
11:39:06 <radix> cjb: the haskell introduction at OSCON
11:39:09 <phobes> cjb:  More than just adding 'par' annotations
11:39:14 <cjb> radix: oh, is there audio/video?
11:39:22 <dons> fasta: like the 10 years it took monads to make it widespread
11:39:22 <cjb> phobes: Oh, that makes sense.
11:39:27 <radix> cjb: yes, http://research.microsoft.com/~simonpj/papers/haskell-tutorial/index.htm
11:39:28 <lambdabot> Title: A taste of Haskell (tutorial), http://tinyurl.com/ypuvug
11:39:58 <cjb> wow, this looks great!
11:40:02 <fasta> dons: as all that has already been done, I don't see why that would take ten years, unless the articles describing the algorithms are incorrect/incomplete (which is very common).
11:40:10 <dons> but its just a number. we're a long way ahead. no one's really close on implicit parallelism in the mainstream. and without purity, and a decent abstraction over evaluation orde,r, you're kinda screwed.
11:40:14 <BSP_> i think the problem is that the signature :: [Field a] does not refer to the same a as the enclosing type signature..
11:40:39 <litb> make it a @taste =)
11:41:04 <BSP_> dons: do you know if anyone has done a "limits of instruction level parallelism" style study on typical haskell programs?
11:41:05 <dons> still, let's see if anyone actually bothers hacking a parallel scheme in the next decade
11:41:16 <cnwdup> I just chose the Reader monad for one of my first projects and at least understand it according to my needs. But I have to use the State monad now and can't find a equivalently good tutorial for it. I learned a lot from 'Roll your own IRC bot'. Does anyone know a good short example where I can read something about the State monad?
11:41:19 <phobes> I think you're about to see alot of competitors that have purity
11:41:20 <dons> BSP_: there's been limits on `par` implicit parallelism
11:41:24 <slarba_> I just held a haskell & fp introduction today at work to my mates :)
11:41:30 <roconnor> rumour has it that firefox is single threaded. :/
11:41:30 <dons> slarba_: yay!
11:41:31 <cnwdup> I read some other tutorials, but I don't really get it.
11:41:51 <mrd> @go all about monads
11:41:52 <lambdabot> http://www.haskell.org/all_about_monads/html/
11:41:52 <lambdabot> Title: All About Monads
11:41:59 <mrd> but really its easy if you know Reader
11:42:07 <dons> phobes: i'd be surprised -- if you've got an impure language full of impure libraries, there's a lot of work to do to get a useful parallelisable code base
11:42:14 <mrd> now instead of "ask" you have "get", and you can now "put" state back and have it changed
11:42:19 <mrd> that's about it
11:42:19 <Cale> cnwdup: Well, you know how the Reader monad lets you read from a shared environment which later gets passed in?
11:42:45 <slarba_> dons: trying to spread the word ;)
11:43:03 <Cale> cnwdup: The State monad is similar, but lets you modify the thing which you computation-globally have access to.
11:43:09 <cnwdup> Yes, I know it's pretty similar. But somehow I can't get it working. Well, I think I have to try harder. Is StateT the equivalent of ReaderT?
11:43:19 <Cale> cnwdup: yeah
11:43:27 <cnwdup> Ah, that's good to know.
11:43:27 <dons> slarba_: how was it received?
11:43:33 <slarba_> the example program was a small compression utility using huffman coding
11:43:34 <Cale> cnwdup: and instead of runReaderT, you apply runStateT
11:43:56 <slarba_> dons: quite well actually... those guys weren't familiar with fp
11:44:07 <Cale> cnwdup: and things are similar except instead of ask, you have get, and you have a new operation called put
11:44:58 <slarba_> dons: but they showed interest, which is nice.
11:44:58 <cnwdup> That was what I was trying to do the first time. I'll try it again. (-: Thanks.
11:45:34 <slarba_> usually people dismiss FP here completely (my town is the "embedded city" of the country)
11:45:37 <Cale> Such that do put x; get is the same as return x, if you get what I'm saying :)
11:45:42 <Cale> er
11:45:47 <Cale> It's not quite the same :)
11:45:51 <kaol> are all MonadT such that MonadT with Identity as the inner monad == Monad?
11:46:06 <Cale> do put x; get is the same as do put x; return x
11:46:21 <Cale> kaol: that's the idea
11:46:54 <Cale> (of course it's not required, but you'll probably confuse people if you break that convention)
11:47:23 <kaol> could we drop Monads altogether and just have MonadTs and Identity?
11:47:31 <phobes> Yes
11:47:58 <Cale> Not all monads are easily converted to transformers.
11:48:27 <kaol> but for those which are...
11:48:28 <roconnor> @src IdentityT
11:48:29 <lambdabot> Source not found. stty: unknown mode: doofus
11:48:31 <Cale> (also, note that ListT is completely broken and you basically just shouldn't use it.)
11:48:43 <glguy> but mtl's choicet works
11:48:45 <glguy> err
11:48:47 <glguy> monadlib
11:48:57 <Cale> Also, LogicT :)
11:49:14 <mrd> didn't they propose a fixed ListT
11:49:17 <glguy> All projects I'm on at work have converted from mtl to monadlib
11:49:18 <kaol> but I guess I'm just playing the devil's advocate
11:49:23 <phobes> Cale:  I also claim there is a uniform way to convert a general Monad into a transformer :)
11:49:27 <dons> glguy: seriously?
11:49:34 <phobes> Cale:  In a certain sense
11:49:36 <Cale> phobes: I claim that you're wrong :)
11:49:46 <glguy> dons: I'm not on that many projects, but yeah, I think so
11:49:59 <dons> hmm.
11:50:12 <dons> we should have a mini monadLib hackathon
11:50:31 <kaol> @where monadlib
11:50:32 <lambdabot> http://www.cse.ogi.edu/~diatchki/monadLib/
11:50:34 <dons> grab yav, you, me. sit down and get the thing into a mainstream sort of state.
11:50:35 <phobes> Cale:  My claim is that every Monad can be translated into a MonadT such that there exists a runMonad function that produces the same effect as the original Monad
11:50:35 * sjanssen thinks monadLib could use some marketing
11:50:40 <dons> sjanssen: yeah!
11:50:43 <dons> glguy: see ^^
11:50:55 <glguy> dons: yeah, we need someone to do that ...
11:50:57 <sjanssen> glguy, dons: how is it better?
11:50:58 <dons> sjanssen: it needs docs, and some restructing to be more normalised
11:51:07 <fasta> glguy: where do you work?
11:51:12 <kaol> that page's dead :-(
11:51:18 <dons> kaol: its on darcs.haskell.org
11:51:21 <glguy> sjanssen: more attention to strictness/laziness, more fine-grained type classes
11:51:35 <phobes> Cale:  This is along the same lines as my previous claims, so I won't belabour it :)
11:51:36 <fasta> Everyone uses mtl, because it's 'sanctioned' by GHC.
11:51:45 <Cheery> what is the optimal type signature for a compiler?
11:51:47 <Cale> phobes: I don't see how that's the case.
11:52:00 <Cale> phobes: Please do this with the following monad:
11:52:09 <Cheery> [Char] -> [Char] ?
11:52:19 <Cale> data Tree a = Leaf a | Branch (Tree a) (Tree a)
11:52:24 <Cale> instance Monad Tree where
11:52:27 <Cale>   return = Leaf
11:52:34 <Cale>   (Leaf x) >>= f = f x
11:52:35 <mrd> Program -> Program
11:52:57 <Cale>   (Branch l r) >>= f = Branch (l >>= f) (r >>= f)
11:53:01 <cnwdup> Cale: Thanks. It's working. And it really is the same (almost)! (=
11:53:50 <sjanssen> this Iso stuff seems cool
11:53:50 <Cale> phobes: Oh, and be sure that your transformer is really a transformer. I should be able to apply it to any monad and get a monad.
11:53:59 <monochrom> A compiler is unlikely to be a pure function.
11:54:02 <Cale> (which satisfies all the laws)
11:54:14 <roconnor> monochrom: !?
11:54:26 <monochrom> Because of "#include", "import", etc.
11:54:26 <phobes> Cale:  Ok, I suppose this will be a good validation exercise :)
11:54:34 <roconnor> :/
11:54:45 <glguy> fasta: I work at Galois in Portland
11:54:55 <glguy> (to answer your previously ignored question)
11:55:14 <slarba_> portland... a rather nice city
11:55:42 <roconnor> monochrom: maybe the function returns a continuation :D
11:55:43 <slarba_> I lived in Seattle -2004, took a ride there one weekend
11:55:48 <fasta> glguy: doesn't dons work there too?
11:55:56 <glguy> sure does
11:56:14 <fasta> glguy: oh, I assumed that such a change would be known to all developers then.
11:56:22 <glguy> such a change?
11:56:29 <fasta> glguy: mtl -> monadlib
11:56:40 <glguy> fasta: we are so big that we don't all work on the same projects
11:56:50 <bos> glguy: is monadlib advantageous in some way?
11:56:51 <fasta> glguy: how big is Galois then?
11:57:00 <glguy> 30-40 peole I think
11:57:11 <fasta> glguy: oh, that's 5 times larger than I thought.
11:57:14 * glguy runs to catch up with the lunch crowed!
11:57:19 <monochrom> Apparently a continuation is itself a compiler waiting for someone to feed it the extra files before it emits target code.
11:57:20 <fasta> glguy: thanks
11:57:22 <glguy> bos: I'll pop your question on my stack
11:57:34 <glguy> push*
11:57:36 <bos> heh
11:57:46 <monochrom> Then, a compiler maps input streams to more compilers?
11:58:23 <monochrom> Sounds like fertility to me.
11:58:27 <cjb> dons: Ah, just read your fib parallelism bloggy.  Thanks!
11:58:39 <monochrom> Someone is going to say "a compiler is like a rabbit".
11:58:59 <cjb> dons: I hadn't realized thread creation would be so costly.  Ah well.
11:59:20 <gwern> monochrom: you mean, scheme compilers are like RABBIT :)
11:59:31 <Saizan> monochrom: the first one was written by fibonacci, didn't you know?
11:59:31 * mrd was going to say that
11:59:53 <monochrom> This revisionist history is too revisionist for my taste!
12:00:05 <gwern> monochrom: revise your tase
12:00:07 <gwern> *taste
12:00:08 <mrd> so, compiler authors create more rabbits?
12:00:19 * gwern has a mistaken flavor
12:00:24 <sjanssen> cjb: it isn't actually thread creation
12:01:04 <sjanssen> cjb: par uses a work pool of thunks that need to be evaluated -- the threads that evaluate the thunks are already started
12:01:32 <cjb> Gosh.  Where does the time go, then?
12:01:49 <sjanssen> cjb: well, there is still a cost of inserting an item into that pool
12:02:09 <jedbrown> cjb: The thing is that evaluating sequential fib for very small n is really cheap.
12:02:23 <monochrom> Somone buy me a multi-core computer, so I can test out my factoring program written in Haskell and par it for multi-core. Should be a great showcase.
12:02:23 <cjb> jedbrown: Right, I read the blog post.
12:02:49 <cjb> jedbrown: Just surprised at the extent.  I guess there are many small-n computations involved, since no memoization.
12:02:50 <jedbrown> cjb: But the algorithm does it a *lot*.  Hence, even if it's just a few extra instructions, you'll see a big performance hit.
12:02:52 <gwern> monochrom: go buy it yourself! a good 4-core processor is like in the 100-200 dollar range
12:03:03 <monochrom> I don't even have 100 dollars.
12:03:05 <cjb> jedbrown: I see.  That makes sense.
12:03:15 <monochrom> I can only afford 10 dollars. I'm serious.
12:03:19 <shapr`> Wait, who was playing with correct layout for non-monospaced fonts using delimited continuations? That was skew, wasn't it?
12:03:31 <shapr`> That would be great for Yi!
12:03:38 <gwern> monochrom: so whore yourself out to 10 hot chicks for 10 dollars each (or maybe one really fat chick for 100 dollars)
12:04:16 <monochrom> Let's say I'm castrated, just to push the envelope.
12:04:32 <jedbrown> monochrom: One ugly guy then.
12:04:50 <monochrom> You people are sick.
12:04:57 * gwern coughs. there are many forms of sexual expression people are willing to pay for
12:05:24 <monochrom> I would rather whore in terms of PHP programming than whore in terms of sex.
12:05:25 <gwern> monochrom: heck, people will even pay for insults and abuse. you might be a natural at that one
12:05:46 <BSP_> so, can noone offer any insight into my problem with type variable scoping at http://hpaste.org/5218 ? :-)
12:06:21 <sjanssen> BSP_: this should work in GHC if you turn on scoped type variables
12:06:27 <mrd> you need an extension
12:06:44 <sjanssen> BSP_: oh, and you have to use 'forall'
12:07:06 <BSP_> ahh, i have to enable something: cheers
12:07:10 <BSP_> -XTypeOperators?
12:07:48 <monochrom> -XWings
12:07:59 <mrd> -XRated
12:08:47 <Saizan> BSP_: -XScopedTypeVariables
12:09:15 <BSP_> saizan: just found it, thanks!
12:10:45 <Cin> where (User { rec=rec, send=sender, h=h } ) = clients Map.! id
12:11:05 <Cin> i'm getting an error that 'send' is ambigious because of the 'send' exported from Network.Socket
12:11:15 <Cin> but i would have thought it would only care about the fields inside User?
12:11:45 <byorgey> Cin: yeah, you'd think so.
12:11:57 <Cin> byorgey: i see
12:12:02 <Saizan> no, because it's just syntactic sugar for functions of type :: User -> ..
12:12:36 <byorgey> Cin: ISTR reading various proposals to make that work.  obviously from context it's clear which send you're referring to, but some special code to deal with that case would have to be added to the compiler.
12:13:15 <Cin> byorgey: ah. i see
12:13:52 <Cin> guess i'll, er
12:14:11 <Cin> prepend something to my field names?
12:14:23 <Saizan> use them qualified?
12:14:30 <sjanssen> Cin: you can use the usual module qualification
12:15:11 <Cin> sjanssen: on Network.Socket??
12:15:14 <Cin> -?
12:15:41 <sjanssen> Cin: or on your field names
12:15:50 <Cin> really? hmm
12:15:52 <byorgey> Cin: you could either import Network.Socket qualified, or you could write MyModule.send instead of send
12:16:15 <RayNbow> hmm, just wondering if I'm getting this right... the purpose of the Functor class is to allow one to modify the value that's contained in a container type?
12:16:31 <Saizan> you can even reimport your module with an as clause to use a shorter name
12:16:31 <Cin> i'd rather use Network.Socket as qualified
12:17:20 <Saizan> RayNbow: with a sufficient broad concept of contained
12:17:22 <byorgey> RayNbow: or value(s)
12:18:06 <glen_quagmire> do I have to do something after installing ghc , before i can use cabal?
12:18:25 <Saizan> glen_quagmire: no, why?
12:18:35 <byorgey> glen_quagmire: does the output of ghc-pkg list show the Cabal library?
12:19:15 <glen_quagmire> byorgey: yes. i think missing a dependancy
12:19:29 <glen_quagmire> Setup.hs: At least the following dependencies are missing:  OpenGL >=2.1
12:19:55 <RayNbow> Saizan, byorgey, ah ok... and the Functor class can be useful when you don't want to export the constructors, right?
12:19:57 <Saizan> then you're yet using cabal, but you miss that package
12:20:18 <glen_quagmire> Saizan: yup. i thought opengl came with ghc
12:20:31 <Saizan> glen_quagmire: it's in the extralibs iirc
12:21:07 <glen_quagmire> i think my distro's ghc is broken
12:21:29 <Saizan> RayNbow: or just write functions reusable with mani functors
12:22:29 <RayNbow> Saizan: yup
12:22:32 <Cin> byorgey: how do you give your module another name?
12:22:42 <RayNbow> it's just that I had a problem with the name Functor :p
12:23:00 <Cin> byorgey: i.e like 'Me' or something (what's a good, short name for the current module?)
12:23:07 <Saizan> RayNbow: ah, it's not the "function as an object" that comes from oop :)
12:23:34 <Saizan> Cin: import MyModule as Me
12:23:48 <RayNbow> Saizan: yeah, that's exactly what caused confusion :)
12:24:14 <Cin> saizan: "Module imports form a cycle for modules" o_o
12:24:30 <Saizan> RayNbow: it would be silly to have a class for that, we have real first-class functions :)
12:24:34 <Cin> saizan: does it need to be in any specific order before or after other imports?
12:24:44 <cjb> dons: for massive bonus points, you and sjanssen should write a version of RealPar.hs that determines the value of cutoff on the fly :)
12:24:46 <Saizan> it shouldn't
12:25:05 <Cin> i've got "import Main as Me"
12:25:49 <Saizan> mmh, maybe you can't really do that..
12:26:03 <phobes> Cale:  ok, so it took some effort
12:26:03 <byorgey> Cin: at the top, put 'module MyModuleName where'
12:26:25 <phobes> Cale:  But I've got an implementation of the following signature:
12:26:38 <Cin> byorgey: instead of `module Main where'? i don't follow
12:26:42 <byorgey> Cin: whatever name you use will be the same name other modules refer to it by, so 'Me' isn't a particularly good name =)
12:26:47 <byorgey> Cin: yes, exactly
12:27:10 <glen_quagmire> is darcs the only place to download haskell opengl ?
12:27:20 <Cin> byorgey: d'oh. i thought you said that i could give my module an additional name
12:27:41 <byorgey> Cin: oh! no.  but can't you say 'Main.send' then?
12:28:08 <Cin> byorgey: i suppose. it just makes my code bigger again (ie why use fields?)
12:28:14 <Cale> phobes: The important things are: 1) Applying it to the identity monad gives a monad M such that you can write a pair of functions: f :: Tree a -> M a, and g :: M a -> Tree a, which are inverses, and that 2) When applied to any monad m, it produces another monad which satisfies the laws.
12:28:17 <byorgey> Cin: Main isn't a particularly good name for a module anyway.  usual practice is to have a module called 'Main' which just imports other modules and has a short 'main' function
12:28:35 <Cin> byorgey: well, i'll change that.
12:28:55 <byorgey> Cin: personally, I would either change the field names, or import the Network module qualified.
12:29:03 <phobes> Cale: Let me hpaste this
12:29:04 <phobes> sec
12:29:16 <RayNbow> hmm Saizan, do you think that the Functor hawiki entry should be extended with more information?
12:29:33 <Cin> byorgey: i'll do that then
12:29:53 <phobes> Cale:  Heh, sorry first hpaste... do all hpastes automatically go to #haskell?
12:30:24 <fasta> phobes: there is a check box
12:30:31 <shapr`> Is HaskellScript updated to work with the latest ghc and the latest VisualStudio? I have this urge to go all emacs on devstudio.
12:30:32 <phobes> ah yes
12:30:47 <Saizan> RayNbow: probably so, seeing as it's almost empty, however the name comes from category theory
12:30:58 <hpaste>  phobes pasted "MonadBranch" at http://hpaste.org/5219
12:31:16 <Cin> byorgey: what is 'ISTR', by the way?
12:31:21 <shapr`> I seem to remember
12:31:33 <byorgey> Cin: I Seem To Recall
12:31:37 <byorgey> or Remember
12:31:38 <Cin> byorgey: ah, okay
12:32:28 <Saizan> phobes: why did you cut off all the interesting parts?
12:32:36 <phobes> Saizan: heh
12:32:45 <phobes> I want to make sure I've solved the right problem first :)
12:33:20 <RayNbow> Saizan: I'm not familiar with category theory, but maybe if I have some time... I'll try extending the Functor entry
12:33:37 <Saizan> instance Monad m => MonadTrans BranchT where <-- the context is not there, right?
12:33:48 <phobes> Cale:  Do you agree that if I can fill in those bodies and satisfy the Monad laws, I win?
12:34:03 <phobes> Siazan: The instance body you mean?
12:34:20 <Saizan> 'Monad m =>'
12:34:44 <Cale> phobes: not quite. You also need to show there's an inverse mapping so that BranchT Identity is really isomorphic to Tree
12:35:10 <shapr`> So, where's the Haskell for Windows irc channel? :-)
12:35:14 <roconnor> @src iterate
12:35:15 <lambdabot> iterate f x =  x : iterate f (f x)
12:35:47 <byorgey> shapr`: hehe
12:35:54 <phobes> Saizan:  oh you're right ... my Trans instance is foobar
12:36:05 <Cale> phobes: Oh, and once you've done this one, I'd like to see the monad transformer for vertex labelled graphs where the join operation takes a graph of graphs and produces the graph whose vertices are the disjoint union of the vertices of all the contained graphs, and whose edges are the edges of those graphs, plus an edge between each pair of vertices originating in graphs which were connected by an edge in the outer g
12:36:06 <Cale> raph.
12:36:29 <Cale> :)
12:36:37 <Saizan> evil.
12:36:37 <shapr`> @seen ndm
12:36:37 <lambdabot> I haven't seen ndm.
12:36:40 <shapr`> bah
12:36:41 <phobes> Cale:  Well, if I show you how to do this one, I don't think you'll be arguing wtih me anymore :)
12:36:50 <shapr`> Only Haskell on Windows expert I know of is ndm.
12:36:56 <Cale> phobes: I actually kind of suspect this one is doable.
12:36:58 <shapr`> Daan doesn't show up here... who else could I ask?
12:37:02 <Cale> phobes: (but it's nontrivial)
12:37:13 <phobes> Cale:  But I mean once you see the pattern
12:37:24 <phobes> Cale:  It's clear that it's doable with any monad
12:38:06 <Cale> Why not just prove that the pattern works then? ;) It's not so obvious.
12:38:23 <phobes> Cale:  I could do that
12:38:25 <Saizan> Cale: have you used that graph monad in some applications?
12:38:40 <phobes> Cale:  Good point - I'll write down a proof
12:38:41 <Cale> Saizan: nope.
12:39:04 <phobes> Cale: And maybe I'll run this code by ghc to see if it's happy with it :)
12:39:47 <litb> do {p <- e; es} → let ok p = do {es} ; ok = fail "..." in e >>= ok
12:39:56 <litb> i've a problem understanding one part of this:
12:40:16 <litb> how does haskell know which fail it has to call?
12:40:26 <litb> i mean, there doesn't seem any context information passed into
12:40:27 <byorgey> litb: fail is a member of the Monad class.
12:40:31 <monochrom> The fail of the same monad.
12:40:40 <shapr`> Bah, what's ndm's email address?
12:40:45 <monochrom> If you know which >>= to call, you also know which fail to call.
12:41:03 <shapr`> @tell ndm shapr needs help with Haskell on win32, any tips?
12:41:03 <lambdabot> Consider it noted.
12:41:06 <litb> ah it is a compiler trick?
12:41:13 <byorgey> litb: the type of ok is constrained by the type of >>=, which is constrained by the type of the do block.
12:41:20 <monochrom> Is >>= a compiler trick?
12:41:22 <byorgey> litb: no tricks, just type checking =)
12:41:29 <monochrom> I guess everything is a compiler trick.
12:41:38 <Saizan> litb: it's just how typeclasses works
12:41:40 <litb> byorgey: yeah, but where does type checking involve there?
12:41:47 <phobes> Cale:  I want to understand your requirement on the "inverse mapping" - you just mean that running a tree computation in BranchT Identity and then extracting the result vs. running the computaton in your tree Monad produce the same result, right?
12:41:49 <litb> with >>= the left hand side is the Monad itself
12:42:00 <monochrom> @type fail
12:42:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
12:42:06 <litb> but with fail, there is only a String passed. how can the compielr deduce the Monad from that?
12:42:33 <Saizan> litb: from the required type of the result
12:42:33 <monochrom> Then it is the same question as how "show" works.
12:42:44 <monochrom> Err how "read" works.
12:43:01 <monochrom> > read "5" == 0 || read "False"
12:43:03 <lambdabot>  False
12:43:09 <monochrom> @type read
12:43:09 <lambdabot> forall a. (Read a) => String -> a
12:43:25 <shapr`> Bah, I may become the win32 czar for Haskell.
12:43:34 <byorgey> litb: if you want to think of it from a "method dispatch" point of view, in Haskell dispatching can be done on the type of the return value just as well as the type of an input.
12:43:37 <mrd> a brutal bloody dictator?
12:43:43 <hpaste>  nolrai pasted "bad attempt at Prompt" at http://hpaste.org/5220
12:43:54 <shapr`> mrd: I'm already that for #haskell, why not extend my influence?
12:43:56 <monochrom> Yes, please become the win32 czar for Haskell and answer all win32 questions and get all win32 problems fixed! :)
12:44:27 <shapr`> monochrom: I'll need people to help of course... want to do stuff to make this happen?
12:44:39 <monochrom> No, I don't want to program on win32.
12:44:50 <shapr`> Not even Haskell?
12:45:00 <monochrom> No.
12:45:29 <shapr`> bah
12:45:35 <radix> hey shapr
12:46:18 <shapr`> radix!!
12:46:25 <shapr`> Wassup mon?
12:46:31 <radix> I might be unsick enough by this weekend to actually leave my house.
12:46:40 <shapr`> Oh, you got that too?
12:46:46 <nolrai> Hey, any can any one tell me where my ideas are wrong on my hpaste?
12:46:46 <radix> I think you got me sick. At least I got sick last Friday.
12:46:51 <shapr`> Got it from glyph, I assume?
12:47:27 <shapr`> radix: Hey, are you coming to Hacking in Haskell at MIT? It's free and in the evening: http://stuff.mit.edu/iap/#hackhaskell
12:47:27 <lambdabot> Title: SIPB IAP 2008 Activities
12:47:36 <shapr`> jfredett: Are you coming to that also?
12:47:57 * shapr` tries to build a Haskell Users Group of Somerville (HUGS?)
12:48:03 <cjb> Oh, you guys are in Boston too?
12:48:13 <cjb> I haven't been keeping track.  :)
12:48:14 <shapr`> #twisted core team is in Boston
12:48:17 <radix> shapr: I dunno. I'm leaving for a while in a week, so I have a bunch of crap to get sorted out.
12:48:24 <shapr`> cjb: When is Mako returning?
12:48:31 <shapr`> radix: bah, maybe next time?
12:48:33 <radix> Like finishing up my classwork.
12:48:41 <cjb> shapr`: he's in the office next to mine.  Just got back recently.
12:48:56 <shapr`> Ah, spiffy. Is he coming to the Hacking in Haskell also?
12:49:01 <cjb> Yes, I think so.
12:49:10 <shapr`> yay cool
12:49:11 <radix> shapr: when's the first SHUG meeting?
12:49:17 <shapr`> radix: I dunno, we need a venue.
12:49:31 <shapr`> My apartment is large, but my parking is small.
12:49:35 <cjb> OLPC might be available.
12:49:44 <shapr`> Ooh, that sounds good.
12:49:50 <Tac-Work> :t unfoldr
12:49:50 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
12:49:52 <Saizan> nolrai: inquirer should be the producing or consuming monad?
12:49:53 <radix> Is there already a CHUG?
12:50:06 <shapr`> cjb: Do you have a projector and wifi?
12:50:12 <cjb> there's very little Haskell in MA, in my experience.
12:50:13 <shapr`> Not that we really require either.
12:50:16 <cjb> shapr`: Yes, 'course.
12:50:21 <shapr`> cjb: That is about to change!
12:50:43 <Cale> phobes: I mean that the types are isomorphic. There's a pair of polymorphic functions which map back and forth between them.
12:50:59 <Cale> (whose compositions are equal to id either way)
12:50:59 <shapr`> I wonder who else I can recruit?
12:51:18 <cjb> Perhaps there's a haskell instance on Zephyr.
12:51:18 <phobes> Cale:  What types?
12:51:31 <Cale> phobes: BranchT Identity and Tree
12:51:40 <phobes> Cale:  I'm making no claims about BranchT - it's a black box
12:52:03 <phobes> Cale:  All I'm saying is that the runBranchT computes the right result
12:52:06 <Cale> That's fine as long as you can actually write the isomorphisms.
12:52:28 <shapr`> Oh, Dave Herman is in Boston, I'll email him.
12:52:29 <phobes> Cale:  No, I have no way of doing that
12:52:57 <phobes> Cale:  Well, actually I do in this case, but don't in general
12:53:07 <cjb> shapr`: We could plan on co-opting the Haskell talk to ask people if they're interested in a regular meetup.
12:53:09 <phobes> Cale:  Nm, I do in general
12:53:10 <phobes>  :P
12:53:16 <Cale> phobes: There just has to be a way to take a (Tree a) and turn it into the equivalent (BranchT Identity a), and vice versa.
12:53:20 <shapr`> cjb: Yeah, good idea!
12:53:43 <phobes> Cale:  In this case, you just call branch :)
12:53:47 <Cale> Such that f . g = id and g . f  = id
12:54:04 <Cale> You don't lose or gain structure when mapping back and forth.
12:54:15 <Cale> (that really should be the easy part)
12:54:28 <litb> oh i see. it's the return type that matters
12:54:42 <phobes> Cale: To go from Tree a -> BranchT a, you can use the 'branch' function.  To go the other way, you have to use the runBranchT
12:54:58 <phobes> Cale:  The two are inverses
12:55:02 <Cale> okay
12:57:35 <phobes> Cale:  Hmm.... thinking about this, I think I can write this all generically.  I think I can define this pattern in haskell - take an arbitrary Monad and make it a MonadT
12:58:47 <phobes> Cale: Ya, it's pretty obvious actually how to generalize this to do that
13:09:08 <nolrai> does "data InquireE (m :: * -> *) a where Inquire :: (forall m' . Inquireable m' a) => InquireE m a" even make any sence at all? i dont really understand GADTs.
13:10:30 <nolrai> Saizan: what do you mean?
13:13:53 <glen_quagmire> building ghc again to include OpenGL and GLUT
13:14:10 <glen_quagmire> maybe i should've just built those separately oh darn
13:15:55 <byorgey> glen_quagmire: oh well.  but now you get all the other extralibs too =)
13:15:59 <glguy> ?seen bos
13:15:59 <lambdabot> bos is in #ghc and #haskell. I last heard bos speak 1h 18m 23s ago.
13:16:13 <bos> que?
13:16:23 <Saizan> nolrai: is that even allowed? you don't use m'.
13:16:33 <glen_quagmire> yay. it's nice because ghc requires ghc to build. i can use binary ghc to build bhc
13:17:10 <jedbrown> I'm having an interesting QuickCheck problem.  It seems to be generating functions (Int -> Double -> Int) which are _|_ and/or have a huge memory leak.  When I only use (Int -> Int -> Int) for instance, then things are fine.
13:17:16 <glguy> So I like the monadLib type-classes (finer-grain) attention to strictness/laziness throughout, the "Iso" types for things that don't otherwise support generalized newtype deriving
13:17:27 <bos> fair enough.
13:17:34 <glguy> the Exception transformer is better
13:17:40 <glguy> doesn't require string based errors
13:17:53 <glguy> has a working ListT
13:18:04 <glguy> (called ChoiceT)
13:18:29 <glguy> the only advantage of mtl over it is that mtl is in extralibs
13:19:01 <dons> its in all package systems too
13:19:22 <glguy> I don't use package systems for any of my libs, so that's never affected me
13:19:49 <glguy> if you mean apt or yum or pacman..
13:20:30 <dons> yeah, as in open source haskell projects need to depend on packaged components
13:20:42 <dons> so xmonad couldn't switch to monadLib without killing off users
13:21:43 <nolrai> Saizan: it compiles (modulo a  misplaced paren)
13:22:07 <glguy> dons: xmonad wasn't a package until someone packaged it
13:22:15 <glguy> someone packaged it because they wanted it
13:22:25 <glguy> if someone had packaged xmonad while it used monadLib
13:22:29 <glguy> then monadLib would ahve been pakcaged
13:22:30 <nolrai> (I dont think its usible though.)
13:22:36 <glguy> they wouldn't have thrown their hands up and moved on
13:26:36 <dons> i'd like to see some smaller projects using mtl switch first.
13:26:39 <dons> i've a few like that.
13:34:40 <bos> where's the IsString class defined?  is it a magic builtin?
13:35:03 <glen_quagmire> @index IsString
13:35:03 <lambdabot> bzzt
13:35:14 <glen_quagmire> @hoogle IsString
13:35:15 <lambdabot> Data.String.IsString :: class IsString a
13:35:15 <lambdabot> GHC.Exts.IsString :: class IsString a
13:35:22 <bos> ooh
13:35:30 <bos> i didn't expect hoogle to be up to date!
13:35:57 <bos> dons: bytestring string overloading isn't in ghc 6.8.2, right?
13:42:59 <Cale> It seems a bit strange that there's no composition defined for arrays.
13:43:49 <monochrom> @pl \x -> a ! (b ! x)
13:43:49 <lambdabot> (a !) . (b !)
13:43:55 <byorgey> dcoutts: ping
13:43:56 <monochrom> Like that?
13:44:09 <Cale> Like that, but resulting in an array
13:44:34 <monochrom> @pl \a b -> (a !) . (b !)
13:44:34 <lambdabot> (. (!)) . (.) . (!)
13:44:59 <Cale> That is,  compose :: (IArray a j, IArray a k, Ix i, Ix j) => a j k -> a i j -> a i k
13:45:05 <phobes> Cale:  You want one array to contain indices into another, right?
13:45:12 <Cale> exactly
13:45:27 <jedbrown> bos: Works for me with 6.8.2 and -XOverloadedStrings
13:45:28 <monochrom> You must want the result to be an array?
13:45:43 <bos> jedbrown: ok, cool
13:45:47 <phobes> Arrays have map, right?
13:45:47 <Cale> yes
13:46:11 <Cale> They do, you can implement the operation, but it would be a nice addition to Data.Array.IArray
13:47:08 <jedbrown> Cale: Sounds like multiplication with a permutation matrix.
13:47:34 <Cale> Well, perhaps, but it's just function composition.
13:47:42 <jedbrown> Cale: Well, more general actually.
13:48:14 <Cale> Arrays are just functions on a finite domain whose results get stored as they're computed.
13:48:29 <phobes> Cale:  I don't know - it seems like that might be cleanest in a library as two pieces
13:49:01 <Cale> as such, the fundamental operation of function composition ought to be defined :)
13:50:01 <Cale> Also  identityArray :: (IArray a i, Ix i) => (i,i) -> a i i
13:50:34 <phobes> Cale:  It seems like you want a way to treat an array as a finite function + a way to compose an array with a finite function
13:51:02 <Cale> There's no interpretive layer here. That's just what arrays are.
13:51:10 <nolrai> (I dont think its usible though.)
13:51:17 <Cale> Well, I suppose there's the interpretive layer of using !
13:51:20 <nolrai> sorry
13:51:29 <nolrai> just bad typing
13:51:32 <jedbrown> We need a well thought out array library.  As a general representation of multi-linear functionals in finite dimensions, with all the usual tensor operations.
13:51:54 <Cale> That's not an array library, it's a tensor library.
13:52:07 <phobes> Cale: I mean you should be able to compose an array with a function (map), and then be able to treat another array as that function (!)
13:52:10 <jedbrown> Well, implemented as arrays.
13:52:11 <monochrom> I want to be a tenor.
13:52:16 <phobes> Cale:  It seems like that's a pretty good interface
13:52:17 <dbueno> @hpaste
13:52:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:52:31 <Cale> phobes: You already can.
13:52:36 <phobes> Cale: That's my point :)
13:53:00 <phobes> Cale:  The implementation of this would just be something like "map (!)", right?
13:53:02 <Cale> phobes: So? That doesn't excuse the fact that fundamental operations defined in terms of map and (!) are missing from the library.
13:53:24 <phobes> Cale:  I'm arguing that I don't see it as fundamental
13:53:37 <Cale> Composition is absolutely fundamental to functions.
13:53:46 <phobes> Cale:  But arrays aren't functions :)
13:53:52 <Cale> Yes they are.
13:53:57 <hpaste>  dbueno pasted "HList error with hFoldr" at http://hpaste.org/5223
13:53:58 <jedbrown> Cale wants: (.) = amap (!)
13:54:12 <Cale> not quite that.
13:54:33 <dbueno> All, does anyone see any immediate problems from the code pasted?  I can't figure out why GHC complains.
13:55:02 <nolrai> what does "GADT pattern match in non-rigid context for `Inquire'/n Tell GHC HQ if you'd like this to unify the context" mean?
13:55:15 <phobes> Cale:  My point is that 'map' is the appropriate version of compose for arrays
13:55:29 <Cale> compose g f = amap (g !) f
13:55:33 <phobes> because in general you can compose an array with a general function - not just an array- and get back an array
13:55:53 <jedbrown> phobes: Cale wants (.) = fmap in general.
13:56:20 <Cale> Actually, I do want that, but it wouldn't really help in this case.
13:56:34 <Cale> Well, it'd help a little.
13:56:51 <Cale> er, no
13:57:12 <jedbrown> Cale: I thought I've seen you argue for that on this channel?  Perhaps it was tongue-in-cheek.
13:57:24 <Cale> jedbrown: Oh, the (.) = fmap thing is great.
13:57:37 <Cale> We should totally do that. It's just it doesn't help with IArray.
13:58:06 <Cale> (note that fmap can't quite be defined -- you have amap instead)
13:58:21 <sjanssen> why can't fmap be defined?
13:58:28 <Cale> Class constraints.
13:58:33 <sjanssen> oh, because of Ix restraints
13:58:39 <Cale> yep
13:58:57 <sjanssen> well, it can be defined if you have knowledge of Array's innards
13:59:26 <Cale> right.
13:59:27 <sjanssen> @src Array
13:59:27 <lambdabot> Source not found. My pet ferret can type better than you!
14:02:16 <Cale> jedbrown: The thing which totally convinced me that (.) = fmap is a good idea is that the (nontrivial) law which fmap needs to satisfy turns into associativity of (.)
14:02:20 <sjanssen> we ought to have that instance
14:02:49 <Cale> fmap (f . g) = fmap f . fmap g
14:02:52 <Cale> So,
14:03:03 <Cale> fmap (f . g) x = fmap f (fmap g x)
14:03:11 <Cale> So using (.) = fmap
14:03:21 <Cale> (f . g) . x = f . (g . x)
14:03:27 <jedbrown> Cale: I agree.  The only good point against it would be error messages.
14:04:25 <jedbrown> Cale: And I suppose it makes higher order code potentially a little harder to reason about, considering how powerful (.) can become.
14:05:35 <Cale> Well, possibly, but that associativity makes things a lot easier than they could be.
14:05:41 <monochrom> fmap = (.)  comes from the idea of Hom-functor. I fear it.
14:06:54 <Cale> Also, it takes what are arguably the two most important operations in functional programming and unifies them :)
14:07:08 <Cale> (and gives them the most lightweight operator symbol available!)
14:07:44 <byorgey> I'm confused.  is it (.) = fmap or fmap = (.) ?
14:07:50 <Cale> both
14:08:10 <monochrom> Using the mathematical = (rather than the Haskell =).
14:08:10 <sjanssen> byorgey: we already have "fmap = (.)" in the instance for functions
14:08:26 <Cale> (.) :: (Functor f) => (b -> c) -> f b -> f c
14:08:45 <byorgey> Cale: oh, I see.  so I could write . everywhere instead of fmap.
14:08:49 <Cale> right
14:09:01 <Cale> and because of the instance for functions, it would still mean composition.
14:09:02 <jedbrown> (.) = map = fmap = <$> = <*>   -- This would free up some symbols.  Hooray!
14:09:14 <byorgey> Cale: cool =)
14:09:16 <sjanssen> jedbrown: no, <*> is different
14:09:18 <Cale> and because of the functor laws, it would still be guaranteed associative
14:09:31 <jedbrown> sjanssen: oops ;)
14:09:32 <sjanssen> @type (Control.Applicative.<*>)
14:09:34 <sjanssen> @type fmap
14:09:34 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:09:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:09:58 <shachaf> Cale: What about the (.) in Control.Category?
14:10:02 <Cale> But you could basically lose liftM and liftA (though you'd keep them for ease of defining instances)
14:10:08 <Cale> shachaf: >>>
14:10:23 <shachaf> Cale: They can't be made to work together?
14:10:38 <Cale> shachaf: I tried that, and it's really hard to get them to play nice together.
14:10:48 <Cale> But you can give it a shot if you want.
14:10:58 <hpaste>  nolrai pasted "GHC doesnt like unimo example" at http://hpaste.org/5224
14:11:04 <Cale> You tend to end up with lots of ambiguous types everywhere once you do that.
14:11:18 <sjanssen> Cale: (.) = fmap and liftM/liftA are orthogonal
14:11:29 * shachaf supposed (.) = fmap is general enough. :-)
14:11:42 <Cale> sjanssen: Well, sure, but they're all instances of the same general operation.
14:11:45 <sjanssen> Cale: the issue there is actually that Functor isn't a superclass of those classes
14:11:46 <Cale> (functor application)
14:11:51 <Cale> Right.
14:12:30 <Cale> Even if it were, we'd probably keep liftM/liftA (maybe renamed to something less convenient) for ease in defining instances.
14:12:44 <shachaf> And what was the reason for that again? That people would have to define instance Function when defining a Monad?
14:12:48 <shachaf> Or something more than that?
14:12:56 <Cale> Functor
14:13:08 <shachaf> s/ion/tor/
14:13:10 <Cale> However, this is *barely* an excuse.
14:13:21 <Cale> instance Functor MyFunctor where
14:13:24 <Cale>    fmap = liftM
14:13:29 <shachaf> s/ion/or/, I mean. :-)
14:13:40 <phobes> Cale:  Why can't that just be a general instance?
14:13:42 <Cale> That's valid, so long as there's a full instance of Monad around.
14:13:44 <shachaf> Cale: And that's the only reason?
14:13:54 <Cale> shachaf: yep, basically.
14:14:04 <sjanssen> shachaf: I think it's just an oversight
14:14:15 <Cale> phobes: Because instance heads have to contain a type constructor.
14:14:22 <monochrom> Should Control.Category really be under Control.*? :)
14:14:29 <Cale> yes
14:14:39 <nolrai> any idea whats up whith the unimo code?
14:14:40 <phobes> Cale:  Ah, this is a technical limitation?
14:14:43 <Cale> Because it's not really representing a category.
14:14:48 * monochrom is now thinking intead: Category, Category.Applicative, Category.Monad, etc.
14:14:54 <shachaf> Monads should also be definable in terms of join/fmap/return.
14:15:02 <Cale> phobes: Well, unless you turn on lots of experimental options, yeah.
14:15:10 <Cale> monochrom: hehe :)
14:15:13 <jedbrown> We could build up the numbers this way too: Group => Ring => Field
14:15:22 <shachaf> jedbrown: Just numbers?
14:15:29 <monochrom> Monad => Group => Ring => Field
14:15:39 <Cale> Rings and Fields aren't really the right abstractions for numbers on computers, unfortunately.
14:15:39 <monochrom> err typo!
14:15:43 <monochrom> Monoid => Group => Ring => Field
14:15:53 <jedbrown> Which would be much prettier than an instance Num with (/) = undefined
14:15:55 <Cale> because there aren't so many fields you can actually implement
14:16:05 <Cale> jedbrown: (/) isn't a member of Num
14:16:22 <shachaf> @src Num
14:16:22 <lambdabot> class  (Eq a, Show a) => Num a  where
14:16:22 <lambdabot>     (+), (-), (*)           :: a -> a -> a
14:16:22 <lambdabot>     negate, abs, signum     :: a -> a
14:16:22 <lambdabot>     fromInteger             :: Integer -> a
14:16:29 <Cale> @src Fractional
14:16:29 <lambdabot> class  (Num a) => Fractional a  where
14:16:29 <lambdabot>     (/)             :: a -> a -> a
14:16:29 <lambdabot>     recip           :: a -> a
14:16:29 <lambdabot>     fromRational    :: Rational -> a
14:16:41 <jedbrown> Cale: Oops.  yes (*) = undefined in this case.
14:16:43 <Cale> The real shame is the abs and signum functions in there
14:16:53 <Cale> and the Eq and Show being superclasses
14:16:58 <jedbrown> Cale: and those.
14:17:24 <Cale> I'd probably prefer the names Additive, Multiplicative and Num
14:17:43 <monochrom> I like that.
14:17:55 <shachaf> Clean has classes +, *, etc., right?
14:17:56 <phobes> I'm almost of the opinion that floating point numbers shouldnt' use the same operations as numbers in a field
14:18:00 <Cale> Because you have things like Floating point arithmetic. And it's basically nothing.
14:18:30 <Cale> Using the names from mathematics sets up the expectations from mathematics, and they're impractical sometimes on computers.
14:18:59 <taruti> find /foobar -type f -print0 | perl -e '%h={};while(<>){chomp;if($h{$_}){print"$_ is duplicate of $h{$_}"};$h{qx/"md5sum $_"/}=$_;}'
14:19:06 <taruti> :P
14:19:17 <taruti> wrong channel too.
14:19:53 <monochrom> You are sentenced to three months of monad blogging for that crime. :)
14:21:46 * monochrom comes up with this idea of "community service" penalty for #haskell felonies and haskell-cafe@ felonies. E.g., if you mock a newbie, you're sentenced to cabalize a stagnated but much wanted library such as monadlib. :)
14:22:48 <phobes> I haven't seen a language with a really nice story for floating point operations yet
14:23:03 <byorgey> phobes: that's because there isn't a really nice story for floating point operations.
14:23:35 <phobes> byorgey:  I'm not so sure you can't do much better than what we're doing now
14:24:23 <smack_> a good symbolic manipulation library would probably help
14:25:28 <hpaste>  nolrai annotated "GHC doesnt like unimo example" with "now this happens" at http://hpaste.org/5224#a1
14:27:21 <hpaste>  nolrai annotated "GHC doesnt like unimo example" with "fixed it" at http://hpaste.org/5224#a2
14:27:38 <gwern> does compiling with -Onot really go faster than -O or no optimization option at all?
14:27:53 <monochrom> Yes.
14:28:10 <monochrom> Unnoticeable on small inputs.
14:28:19 <litb> i have to say, that method to build the fibs using that zip really looks cute
14:28:31 <gwern> hm. I figured Yi was not small input...
14:29:02 <bos> huh. where on earth is the IsString instance for ByteString?
14:29:06 <sjanssen> gwern: -Onot is equivalent to no optimization at all
14:29:21 <sjanssen> bos: IIRC, it's only in very new versions of ByteString
14:29:30 <bos> sjanssen: that's what i thought.  whew.
14:29:33 <monochrom> Yeah, should be noticeable on real programs like Yi and GHC itself. How long does it take to build Yi with -O? Is it too long for you?
14:29:40 <jedbrown> bos: Data.ByteString.Char8
14:30:04 <bos> jedbrown: are you sure you don't have a custom bytestring package installed?
14:30:13 <gwern> monochrom: it takes about 55seconds both ways
14:30:27 <jedbrown> bos: I've got 0.9.0.4
14:30:45 <bos> jedbrown: yeah, that's newer than 6.8.2's version
14:30:55 <monochrom> That is actually surprising.
14:31:01 <sjanssen> gwern: how are you building it?  Are there OPTIONS_GHC pragmas in the files?  Is there ghc-options in the .cabal file?
14:31:15 <sjanssen> gwern: are you using ./Setup configure --disable-optimization?
14:31:25 <monochrom> Oh well, all the better, -O produces faster executables. :)
14:31:37 * monochrom has always used -Onot or -O2.
14:32:06 <monochrom> err, not always. since 6.6.x
14:32:12 <gwern> sjanssen: cabal, all the pragmas are LANGUAGE afaik, and I'm not passing --disable-optimization, the ghc-options are -Wall
14:32:17 <jedbrown> bos: Oh, true.  It's not in 0.9.0.1 (I just checked)
14:32:27 <sjanssen> gwern: Cabal automatically passes -O
14:32:42 <bos> you can never believe teh interwebs!
14:32:43 <monochrom> O!
14:34:36 <quicksilver> anyone know about freebsd?
14:35:30 <jedbrown> @seen mux
14:35:30 <lambdabot> mux is in #haskell-overflow and #haskell. I last heard mux speak 11h 58m 52s ago.
14:36:01 <jedbrown> quicksilver: I beleive he knows.
14:36:20 * quicksilver nods
14:36:27 <bos> is cabal uploading borked?
14:36:38 <quicksilver> not me that needs to know, but there is a user in #ghc struggling to get a freebsd copy of ghc
14:36:56 <Cale> Wow, apparently they can do graph minor testing in O(n log n) time now.
14:37:14 <bos> pardon?
14:37:16 <gwern> shoot. I have a cabal question: 'main-is: Main.hs', but in one of directories listed in the hs-source-dirs: (Yi/), there's also a Main.hs (Yi.Main). how do I unconfuse Cabal?
14:37:23 <Cale> I'm going to have to get that paper.
14:37:38 <gwern> (the main-is: Main.hs is intended for the one in ., obviously)
14:37:39 <monochrom> Cale: announce it on math.reddit! :)
14:37:54 <ehird> Is it possible to write 'instance Monad a'? :-)
14:38:09 <Leimy> anyone know if/when i386 FreeBSD users can have GHC?  :-)
14:38:10 <Cale> monochrom: I found out about it on science reddit.
14:38:21 <Cale> monochrom: (near the end of another article)
14:38:43 <sjanssen> gwern: I don't think you can
14:38:47 <AdGupta> hi, i'm just starting to learn the language - in ghci, how can I see the functions that are available for a specific module?
14:38:57 <Cale> ehird: Not every type constructor is a monad
14:39:01 <gwern> AdGupta: :browse, iirc
14:39:13 <gwern> sjanssen: you don't think so? :(
14:39:24 <monochrom> Redundancy is good. There are people like me who follow one but not the other.
14:39:24 <sjanssen> gwern: should Yi/ really be an hs-source-dir, or are all the modules under Yi/ qualified with Yi.* ?
14:39:26 <AdGupta> thanks
14:39:38 <gwern> sjanssen: I believe the latter
14:41:09 <sjanssen> gwern: then don't include Yi/ in hs-source-dirs :)
14:41:42 <phobes> Cale:  General minor testing?
14:41:44 <litb> @pl let q = 2 : zipWith (*) q (repeat 2) in q
14:41:45 <lambdabot> fix ((2 :) . flip (zipWith (*)) (repeat 2))
14:41:45 <sjanssen> ehird: Haskell '98 doesn't allow it
14:41:47 <gwern> hm. well, that puts me right back where I started with sdist then
14:41:50 <phobes> Cale:  Isn't that NP complete?
14:41:59 * gwern was hoping hs-source-dirs would get sdist to just work dammit
14:42:02 <sjanssen> ehird: and you won't be able to write a reasonable defn. for the functions
14:42:16 <oerjan> > let q = 2 : zipWith (*) q (repeat 2) in q
14:42:24 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
14:42:30 <litb> from what module does fix come from?
14:42:32 <monochrom> I gather graph minor /= subgraph isomorphism
14:42:34 <Cale> phobes: Testing whether a specific graph is a minor of another graph.
14:42:35 <oerjan> > scanl (*2) 2
14:42:35 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
14:42:35 <lambdabot>     Probabl...
14:42:41 <sjanssen> gwern: you have to mention all extra files in extra-source-files
14:42:41 <olsner> > map (2^) [1..]
14:42:42 <mauke> > iterate (*2) 2
14:42:42 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
14:42:43 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
14:42:46 <oerjan> bah
14:42:51 <oerjan> what mauke said
14:43:07 <litb> oerjan: yeah, i know. just playing around
14:43:08 <sjanssen> gwern: can you use 'darcs dist'?
14:43:12 <olsner> @ty scanl (*2)
14:43:12 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
14:43:12 <lambdabot>     Probable cause: `*' is applied to too many arguments
14:43:12 <lambdabot>     In the first argument of `scanl', namely `(* 2)'
14:43:16 <olsner> @ty scanl
14:43:17 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
14:43:37 <Cale> phobes: That is, the input consists of a single graph which you want to test whether it has just one specific graph as a minor.
14:43:46 <gwern> sjanssen: darcs dist seems to work
14:43:58 <Cale> (not two graphs where you want to check that one is a minor of the other)
14:44:06 <oerjan> @ty scanl (*) 2
14:44:07 <lambdabot> forall a. (Num a) => [a] -> [a]
14:44:08 <gwern> sjanssen: do I have to mention them even if their module names are alreayd listed as part of other-modules: ?
14:44:19 <sjanssen> gwern: no, you shouldn't need to
14:44:41 <gwern> (for cabal sdist, I mean, not darcs dist)
14:44:45 <phobes> Cale:  oh, I get it
14:45:12 <phobes> Cale:  So since the general problem is NP, you can expect an exponential constant factor that depends on the specific graph in question, right?
14:45:16 <oerjan> > scanl (*) 2 $ repeat 2
14:45:17 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
14:45:34 <Cale> phobes: yeah, that had better be the case
14:45:38 <mauke> > ap (scanl (*)) repeat 2
14:45:39 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
14:45:45 <Cale> phobes: er
14:45:48 <phobes> Cale:  But this would be useful looking for small graphs in a big graph
14:46:08 <Cale> phobes: actually, it might just be that the algorithm takes exponential time to build
14:46:48 <litb> @pl (\y -> Just (y, y*2))
14:46:48 <lambdabot> Just . ap (,) (2 *)
14:46:54 <phobes> Cale:  Right, for a given graph, it takes an exponential time to produce the O(nlogn) instance that looks for that graph
14:47:01 <Cale> right
14:47:08 <litb> ah, you even can apply a type
14:47:15 <mauke> :t id &&& (* 2)
14:47:16 <lambdabot> forall a. (Num a) => a -> (a, a)
14:47:32 <fasta> phobes: that result seems completely trivial.
14:47:35 <mauke> :t Just . id &&& (* 2)
14:47:36 <lambdabot> forall a. (Num a) => a -> (Maybe a, a)
14:47:48 <phobes> fasta: which?
14:47:50 <oerjan> litb: (,) = \a b -> (a,b) as an expression
14:48:00 <fasta> phobes: as you just formulated it.
14:48:13 <phobes> fasta:  I think the O(nlogn) part is the interesting part
14:48:21 <phobes> fasta: why do you think it's trivial?
14:48:44 <oerjan> :t Just . (id &&& (*2))
14:48:45 <lambdabot> forall a. (Num a) => a -> Maybe (a, a)
14:49:00 <litb> mauke: ah, haven't notices that does exactly that
14:49:00 <ehird> Hmm, is it possible to write unsafePerformIO in Haskell?
14:49:14 <mauke> yes, but no
14:49:18 <oerjan> ehird: not without access to something even more primitive
14:49:25 <oerjan> @src unsafePerformIO
14:49:26 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
14:50:23 <ehird> oerjan: mm, I guess
14:50:43 <olsner> @src lazy
14:50:43 <lambdabot> Source not found. I've seen penguins that can type better than that.
14:51:05 <jedbrown> as compared to: inlinePerformIO (IO m) = case m realWorld# of (# _, r #) -> r
14:51:19 <ehird> > getLine
14:51:19 <lambdabot>  <IO [Char]>
14:51:27 <ehird> you're no fun, lambdabot.
14:51:32 <ehird> > unsafePerformIO getLine
14:51:33 <lambdabot>   Not in scope: `unsafePerformIO'
14:51:39 <ddarius> olsner: lazy is just an identity function
14:51:44 <ehird> hm, can you :m in lambdabot?
14:52:10 <litb> > unfoldr (Just . (id &&& (*2))) 2
14:52:11 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
14:52:15 <litb> lol that is so hot :)
14:52:22 <oerjan> olsner: i believe lazy is a trick to prevent ghc from optimizing by evaluating inside it
14:52:44 <olsner> yeah, figured it'd be something like that
14:53:00 <ehird> but can you.
14:53:00 <ehird> :P
14:53:05 <oerjan> it marks the expression as lazy to the strictness analyzer, even if it is actually strict
14:53:11 <phobes> Cale:  I'd be interested to know if you figure out whether it's an exponential factor or just a one time cost
14:53:26 <larmeh__> how could this possibly create a "parse error"? `data Dictionary a = [Trie a]'
14:53:32 <ehird> > System.IO.Unsafe.unsafePerformIO getLine
14:53:32 <lambdabot>   Not in scope: `System.IO.Unsafe.unsafePerformIO'
14:53:36 <ehird> larmeh__: Array in a data
14:53:38 <ehird> you want a type
14:53:40 <oerjan> ehird: lambdabot carefully censors which modules are available in >
14:53:41 <ehird> type Dictionary a = [Trie a]
14:53:44 <bos> @where+ bytestringparser http://darcs.serpentine.com/bytestringparser
14:53:44 <lambdabot> Done.
14:53:47 <ehird> oerjan: goddamn :(
14:53:48 <mauke> larmeh__: missing data constructor name
14:53:52 <mauke> ehird: Array?!
14:54:02 <ehird> mauke: errr sorry
14:54:05 <oerjan> ehird: unsafePerformIO is the main reason for that :D
14:54:08 <fasta> phobes: that was some intuition. Never mind.
14:54:08 <ehird> :( feel free to kill me for blasphemy
14:54:13 <ehird> oerjan: what's wrong with unsafePerformIO :(
14:54:17 <larmeh__> ehird: hehe
14:54:48 <ehird> @let unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
14:54:49 <lambdabot>  Parse error
14:54:52 <oerjan> ehird: lambdabot's sandboxing policy depends on the fact that evaluating pure code cannot have side effects.  unsafePerformIO violates that
14:54:53 <ehird> eat flaming death, lambdab- oh.
14:55:07 <ehird> @let unsafePerformIO (IO m) = lazy (case m realWorld# of (_, r) -> r)
14:55:07 <lambdabot>  Parse error
14:55:16 <olsner> ehird: for shooting oneself in the foot, unsafePerformIO is the perfect level of safety
14:55:20 <ehird> @let unsafePerformIO \(IO m) -> lazy (case m realWorld# of (# _, r #) -> r)
14:55:21 <lambdabot>  Parse error
14:55:25 <ehird> grr
14:55:28 <ehird> i suck at typing :|
14:55:31 <sjanssen> ehird: it is not going to work.
14:55:38 <ehird> sjanssen: :( why does it syntax error
14:55:43 <mauke> ehird: #
14:55:47 <oerjan> ehird: although i think it also does chroot etc. for added value :)
14:55:50 <sjanssen> ehird: the #'s are part of a GHC extension that is disabled
14:55:57 <ehird> d'awww
14:56:00 <ehird> :(
14:56:03 <sjanssen> ehird: also, the IO data constructor isn't in scope
14:56:16 <sjanssen> same with lazy and realWorld#
14:56:22 * juhp wonders if there are any yi users around
14:56:32 <ehird> why do you all hate me and my efforts to bring cuddly functions to lambdabot :(
14:56:54 <fasta> Cale: what's 'n'?
14:57:01 <fasta> Cale: number of edges?
14:57:03 <mauke> ehird: there's buubot for that
14:57:07 <mauke> it evals perl
14:57:12 <litb> hm, how can i get the code for (->)e (&&&) ?
14:57:16 <ehird> mauke: but that's perl.
14:57:37 <mauke> ehird: so?
14:57:47 <jsnx> how do i fix it when haddock bails on a 'magic number mismatch'?
14:57:56 <ehird> mauke: it's not haskell
14:58:06 <mauke> ehird: unsafePerformIO isn't haskell either :-)
14:58:11 <jedbrown> @src (&&&)
14:58:11 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
14:58:31 <ehird> mauke: OK IT ISN'T GHC AND TONS OF OTHER COMPILERS are we satisfied now :P
14:58:35 <ehird> oh wait interpreters too, hugs
14:59:01 <litb> oh
14:59:02 <jedbrown> litb: But really, just read Arrow.hs.  It's actually not intimidating.
14:59:10 <AdGupta> I have a small question - in the following snippet - foldr max 0 [5,10,2,8,1] - which returns 10, the max of the list, how exactly is the function max applied? as I understand foldr, max would be inserted between the list elements, which doesn't work...
14:59:29 <litb> i don't know yet how i can display its source, jedbrown
14:59:33 <dibblego> AdGupta, why do you think it doesn't work?
14:59:43 <mauke> > max 5 (max 10 (max 2 (max 8 (max 1 0))))
14:59:44 <lambdabot>  10
14:59:45 <litb> maybe i should download the ghc sourcecode
14:59:48 <gwern> AdGupta: think of it as (0 `max` (10 `max`...
14:59:54 <dibblego> > 5 `max` 10 `max` 0
14:59:58 <lambdabot>  10
15:00:06 <AdGupta> well, as I understand the expansion of foldr, it would go 5 max 10 max ...
15:00:16 <jedbrown> litb: <http://haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Arrow.html>
15:00:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Arrow.html>
15:00:18 <ddarius> Actually unsafePerformIO is Haskell 98+FFI Addendum.
15:00:19 <AdGupta> but max isn't infix
15:00:26 <ehird> AdGupta: thats a metaphor.
15:00:26 <mauke> AdGupta: my code is the expansion of that
15:00:40 <ehird> AdGupta: imagine the list like this
15:00:45 <ehird> (:) 5 ((:) 10 ...
15:00:52 <ehird> and you see why you can replace (:) with max
15:01:32 <AdGupta> oh wait - i see that you use `max` - that seems to work - can you use non-infix operators like that?
15:01:40 <gwern> AdGupta: yep!
15:02:09 <monochrom> `max` is infix. note the ` `. :)
15:02:29 <AdGupta> does that work for all non-infix operators?
15:02:37 <mauke> yes
15:02:38 <litb> ah, thanks jedbrown
15:02:45 <oerjan> litb: also you can reach the source code of many modules from the documentation page:
15:02:48 <oerjan> @docs
15:02:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
15:03:21 <AdGupta> thanks - haskell syntax is pretty new
15:03:32 <ben{}> hello
15:03:45 <oerjan> they even added the ability to select individual functions, although it doesn't always end up in the exact spot
15:03:53 <hpaste>  gwern pasted "why does sdist not include all the source code?" at http://hpaste.org/5225
15:04:32 <gwern> sjanssen: that's the cabal file in the current state I've wrangled it to, but runhaskell Setup sdist still doesn't work well
15:05:04 <ben{}> i'm trying haskell for the first time, was used with CaML, bit cant declare a function in hugs:
15:05:16 <ben{}> square x = x * x
15:05:23 <ben{}> ERROR - Syntax error in input (unexpected `=')
15:05:26 <ben{}> any hint ?
15:05:36 <ehird> ^Alet
15:05:37 <oerjan> ben{}: hugs doesn't allow declarations in the interpreter, only expressions
15:05:43 <ehird> oh
15:05:45 <ehird> hugs, hah
15:05:45 <monochrom> hugs can't take declarations at the prompt. Put it in a file, tell hugs to load file.
15:05:53 <ehird> monochrom: alternatively, switch to ghc
15:05:58 <ben{}> thanks monochrom !
15:06:08 <oerjan> > let square x = x * x in square 2 -- this works in both ghci and hugs
15:06:09 <lambdabot>  4
15:06:15 <ehird> oerjan: hugs doesn't allow that
15:06:16 <ehird> iirc.
15:06:20 <monochrom> ghci can take declarations but is still different from what you would put into file.
15:06:32 <monochrom> also ghci can't take all declarations.
15:06:36 <oerjan> ehird: sure it does, remark the "in"
15:06:41 <ehird> ah
15:06:46 <ben{}> thanks
15:07:03 <monochrom> To date there is still no haskell interpreter that provides a first-class REPL.
15:07:04 <oerjan> hugs incidentally also allows square 2 where square x = x * x, unlike ghci
15:07:05 <ehird> oerjan: why doesn't it work in hugs? does it not use a 'do'?
15:07:11 <oerjan> ehird: indeed
15:07:14 <ehird> monochrom: we need HaskellWithLispStyleInteraction
15:07:16 <ehird> (TM)
15:07:33 <ehird> ...mmm...SHIME....
15:07:38 <ehird> (Superior Haskell Interaction Mode for Emacs!)
15:07:52 <gwern> my problem is this, I'm looking at the docs which say 'The files placed in this distribution are the package description file, the setup script, the sources of the modules named in the package description file, and files named in the license-file, main-is, c-sources, data-files and extra-source-files fields.' and I *have* everyting there - the modules are listed, but they are are not showing up in the sdist tarball
15:08:08 <oerjan> ehird: you didn't see the discussion about a possible notebook-like interface yesterday?
15:08:14 <Nafai> ehird: I'd love that too
15:08:16 <oerjan> that would be cool
15:08:21 <nominolo> ehird: see code.haskell.org/shim
15:08:21 <ben{}> sorry to bother again:
15:08:27 <gwern> I am perplexed. is it because the modules are listed inside an 'executable yi {' delcaration?
15:08:47 <ben{}> Hugs> let fact n = if n == 0 then 1 else n * fact(n-1) yields to an error
15:08:56 <centrinia> Would it make sense for a function-like entity to return multiple values?
15:09:03 <monochrom> Right, you can't do that either.
15:09:16 <nominolo> ben{}: it's  let ... in ...
15:09:17 <gwern> where's the 'in' clause?
15:09:40 <ben{}> thanks nominolo
15:09:44 <nominolo> centrinia: sure
15:09:50 <RayNbow> ben{}: the "let ... = ..." construct doesn't work in Hugs
15:09:53 <centrinia> So, for a function of type f: a -> b -> c -> d, f c d :: a -> b
15:09:54 <ben{}> that works
15:10:19 <tkl> can anyone point me to some docs that could explain why is that code not working: http://hpaste.org/5226 ?
15:10:23 <RayNbow> in ghci you can have a let without an in part
15:10:30 <AdGupta> is the let...in... specific to hugs?
15:10:38 <nominolo> AdGupta: no
15:10:42 <mauke> AdGupta: let .. in .. is normal haskell
15:10:42 <AdGupta> cause in ghci it works without "in"
15:10:43 <RayNbow> no, let...in... is just normal Haskell
15:10:44 <nominolo> standard haskell
15:10:59 <centrinia> But you get to do funky stuff such as : g :: e -> a -> b; g (f c d) :: e
15:11:07 <nominolo> AdGupta: let without "in" can be used inside monads
15:11:33 <nominolo> centrinia: if you need more than one result, use a tuple
15:11:43 <nominolo> :t bounds
15:11:44 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
15:12:08 <nominolo> this returns the minimum and maximum index of a tuple
15:12:32 <monochrom> tkl: Have you enabled GADT? You have to enable it explicitly.
15:12:47 <tkl> i used -fglasgow-exts
15:12:58 <monochrom> Alright, then I don't know.
15:13:09 <oerjan> tkl: what's the error message?
15:13:16 <centrinia> I was thinking that a function sp :: (a -> b -> c) -> (a -> b) -> a -> c; sp u v a = (u a) (v a); would be easier to implement with a function that returns multiple values.
15:13:42 <tkl> Couldn't match expected type `k' against inferred type `m' ...
15:14:00 <oerjan> :t ap.($)
15:14:00 <lambdabot> forall a b a1. (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
15:14:07 <Cale> heh
15:14:13 <oerjan> centrinia: ap of the -> monad
15:14:14 <RayNbow> hmm, just wondering... why doesn't ghci support the where construct?
15:14:36 <Cale> Nice trick composing it with id :)
15:14:50 <AdGupta> nominolo:thanks - though I am not far enough to understand your answer :-) (no monads yet)
15:14:50 <Cale> RayNbow: because it's not part of the syntax of expressions
15:14:53 <oerjan> RayNbow: it's not legal haskell in any context
15:14:55 <nominolo> RayNbow: not on the command line
15:15:01 <Cale> RayNbow: It's part of declaration syntax
15:15:06 <Cale> oerjan: what?
15:15:08 <RayNbow> Cale: ah
15:15:18 <centrinia> Wow, that's very useful.
15:15:28 <Cale> :t ap
15:15:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:15:29 <oerjan> Cale: expression where ..., i mean
15:15:30 <nominolo> AdGupta: it's actually just syntactic sugar, and ghci supports it on the repl
15:15:46 <Cale> > ap (,) (^2) 5
15:15:47 <lambdabot>  (5,25)
15:15:55 <Cale> > map (ap (,) (^2)) [1..10]
15:15:55 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
15:16:00 <centrinia> I didn't know that -> was a monad though.
15:16:01 * gwern curses alex again, and for neither the first nor the last time
15:16:52 <ddarius> monochrom: hbc did/does
15:17:08 <ddarius> (re "first-class REPL")
15:17:08 <monochrom> oops
15:18:15 <oerjan> tkl: oh right, append Nil ys = ys causes ys to be interpreted both as List m a and List k a
15:18:43 <nominolo> gwern: what are you trying to package up?
15:18:45 <centrinia> > map (ap (->) id) [1..3]
15:18:45 <lambdabot>  Parse error at "->)" (column 10)
15:20:21 <monochrom> ddarius: I have come up with this idea of "community service" penalties for #haskell felonies. Like OT or misinformation => write a monad blog (and thus spread more OT and misinformation? XD); mock a newbie => cabalize a bitrotten but much wanted library.
15:20:59 <ehird> monochrom: :(
15:21:05 <oerjan> tkl: i think you need to make append a method of Plus
15:21:22 <tkl> oerjan: thx, will try
15:21:59 <poodlesucks> noob
15:22:10 <monochrom> I can't think of very very severe felonies (they exist, I just can't think of an example now), but I have thought out the ultimate penalty for that: be a personal assistant of dons for three months, doing his house chore so he has more time to do haskell stuff. :)
15:22:29 <nominolo> tkl: did you try adding fundeps?
15:22:46 <tkl> like n m -> k ?
15:22:51 <nominolo> yeah
15:22:58 <d0rt> i have a setup question about debian unstable haskell packages:  is there a meta package that i can install that'll pull in the relevant sub-packages that i need to have gtk2hs functionality?  or do i just install as many individual packages as it takes until it works?
15:23:08 <nominolo> well, probably not
15:23:45 <nominolo> d0rt: try libghc6-gtk2hs
15:23:58 <d0rt> ty
15:24:26 <nominolo> er,  libghc6-gtk-dev
15:24:47 <nominolo> but, debian has a pretty old ghc, doesn't it?
15:24:55 <d0rt> yeah, that's the one that i'm waiting for the install to finish while i asked :-]
15:25:05 <d0rt> i don't care, i'm new to haskell :-]
15:25:21 <oerjan> centrinia: (->) cannot be used there - the (,) Cale used was an expression (equivalent to \x y -> (x,y))
15:25:31 <nominolo> the nice thing, it pulls all the C-stuff
15:25:48 <centrinia> Weird.
15:26:27 <oerjan> centrinia: the monad used is just inferred with usual type inference
15:26:49 <centrinia> Oh, now I understand.
15:26:57 <oerjan> (although my .($) trick above is a way to fix it to ->)
15:27:01 <centrinia> I thought ap . ($) was pretty cool though.
15:27:34 <tkl> nominolo: adding n m -> k doesn't help
15:27:55 <centrinia> Would this make any semantic sense?
15:28:02 <centrinia> > ap (--)
15:28:03 <lambdabot> Unbalanced parentheses
15:28:20 <ehird> Evidently not
15:28:47 <oerjan> centrinia: yeah, there are so many monadic and arrow functions that are useful with -> but the fully general type is a bit hard on newbies so a suitable ($) can make it simpler
15:28:54 <oerjan> centrinia: -- starts a comment
15:29:04 <centrinia> I know. :)
15:31:51 <sjanssen> > ap (--!)
15:31:51 <lambdabot> Unbalanced parentheses
15:32:00 <sjanssen> oops, found a bug in the parser
15:32:05 <sjanssen> @type ap (--!)
15:32:06 <lambdabot> parse error (possibly incorrect indentation)
15:32:20 <sjanssen> no, I'm just confused
15:32:29 <sjanssen> > (!--)
15:32:29 <lambdabot> Unbalanced parentheses
15:32:37 <sjanssen> @type (!--)
15:32:38 <lambdabot> parse error (possibly incorrect indentation)
15:32:55 <oerjan> that's weird
15:33:14 <oerjan> a parser bug
15:33:39 <centrinia> @type (!{- -})
15:33:39 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
15:33:59 <oerjan> --! is a perfectly legal operator name
15:33:59 <sjanssen> oerjan: yeah, there's something odd here
15:34:13 <centrinia> @type ({-! -})
15:34:14 <lambdabot> ()
15:34:15 <oerjan> > (!--!)
15:34:16 <lambdabot> Unbalanced parentheses
15:34:21 <sjanssen> ghci accepts all of these
15:34:23 <oerjan> > (---)
15:34:23 <lambdabot> Unbalanced parentheses
15:34:26 <oerjan> > (--+)
15:34:27 <lambdabot> Unbalanced parentheses
15:34:33 <oerjan> > (-+-)
15:34:33 <lambdabot>   Not in scope: `-+-'
15:34:36 <centrinia> > ( -- -} )
15:34:36 <lambdabot> Unbalanced parentheses
15:36:04 <centrinia> Does anything terminate a line comment besides a newline?
15:36:24 <sjanssen> centrinia: no
15:36:33 <mauke> and you can't nest them
15:37:11 <sjanssen> > id {- {- -} -} ()
15:37:11 <lambdabot>  ()
15:37:31 <ehird> > )(
15:37:31 <lambdabot> Unbalanced parentheses
15:37:50 <sjanssen> yes folks, Haskell is non-regular
15:37:51 <oerjan> hm wait
15:37:55 <ehird> probably does manual parenchecking before sending it off to the paresr
15:38:00 <ehird> sjanssen: turing complete parsing!
15:38:02 <oerjan> > let a --- b = 2 in 2 --- 3
15:38:03 <lambdabot>  Parse error at end of input
15:38:11 <oerjan> bah
15:38:27 <oerjan> ok it is not just the parenthesis checking
15:38:33 <ehird> > ibetlambdabot--stripsoutcommentsbeforeparsing
15:38:33 <lambdabot>   Not in scope: `ibetlambdabot'
15:38:44 <ehird> > fornoapparent--reason
15:38:44 <lambdabot>   Not in scope: `fornoapparent'
15:39:04 <oerjan> > "what about -- strings?"
15:39:05 <lambdabot>  "what about -- strings?"
15:39:12 <centrinia> :t 1---Hello World!
15:39:12 <lambdabot> forall t. (Num t) => t
15:39:19 <centrinia> I thought so.
15:39:44 <sjanssen> ehird: no, it doesn't
15:40:07 <sjanssen> ehird: we do parse the input with Language.Haskell before sending it to ghc
15:40:17 <oerjan> ehird: it used to do manual paren checking, even more broken than this, but it was fixed
15:40:27 <centrinia> That means it is a problem with Language.Haskell?
15:40:45 <sjanssen> centrinia: so it seems
15:41:21 <oerjan> Language.SlightlySimilarToHaskell
15:41:49 <centrinia> :t parseModule
15:41:50 <lambdabot> Not in scope: `parseModule'
15:42:08 <ehird> Language.LotsOfWeirdSymbols
15:42:16 <ehird> AndMathematicalNotation
15:42:18 <centrinia> :t Language.Haskell.Parser.parseModule
15:42:18 <lambdabot> String -> Language.Haskell.ParseMonad.ParseResult Language.Haskell.Syntax.HsModule
15:45:02 <centrinia> Okay, I think I see the problem.
15:45:32 <centrinia> > Language.Haskell.Parser.parseModule "module Main where\nx y = 1---Hello World!\n"
15:45:33 <lambdabot>   Not in scope: `Language.Haskell.Parser.parseModule'
15:46:40 <ehird> lol lambdabot is horribly broken dance
15:46:46 <ehird> ,o/ \o, \o/
15:47:57 <centrinia> That was informative about Language.Haskell.
15:48:36 <centrinia> I would assume that GHC doesn't use Language.Haskell.
15:48:54 <sjanssen> ehird: no, lambdabot is not broken in that respect
15:49:05 <sjanssen> ehird: you have to import the modules you use
15:49:16 <ehird> sjanssen: didn't mean that
15:49:24 <sjanssen> we don't allow imports for pretty obvious reasons
15:50:32 <sjanssen> centrinia: GHC uses its own parser
15:50:33 <ivanm> @import Nuclear.Missile.Launcher ? :p
15:50:33 <lambdabot> Unknown command, try @list
15:51:05 <sjanssen> ivanm: exactly
15:51:07 <ehird> I want unsafeperformio :<
15:51:18 <Cale> Prelude> let a --- b = a - b in 5 --- 3
15:51:18 <Cale> <interactive>:1:30: parse error (possibly incorrect indentation)
15:51:35 <sjanssen> or, more practically, GHC.Exts
15:51:54 <oerjan> Cale: ooh, that's bad
15:51:55 <sjanssen> time to look at the report, everybody
15:51:56 <Cale> oh right, you need a distinct symbol character
15:52:03 <Cale> Prelude> let a --> b = a - b in 5 --> 3
15:52:03 <Cale> 2
15:52:33 <oerjan> Cale: huh?
15:52:36 <oerjan> hm
15:53:35 * oerjan hadn't noticed that
15:54:08 <sjanssen> --- has special treatment in the report
15:54:20 <oerjan> > let a --> b = a-b in 5 --+ 3
15:54:22 <lambdabot>   Not in scope: `--+'
15:54:28 <oerjan> urk
15:54:31 <oerjan> > let a --> b = a-b in 5 --> 3
15:54:32 <lambdabot>  2
15:54:34 <Cale> varsym -> ( symbol {symbol | :})<reservedop | dashes>
15:54:48 <Cale> dashes -> -- {-}
15:55:14 <Cale> So 2 or more dashes are specially removed from being varsyms.
15:55:16 <oerjan> however:
15:55:21 <oerjan> > (-->)
15:55:21 <lambdabot> Unbalanced parentheses
15:55:26 <oerjan> that _is_ a bug
15:55:29 <Cale> yes
15:55:40 <Cale> but not in GHC
15:55:56 <ivanm> in what? Language.Haskell (or whatever the haskell-src lib is called)? language spec?
15:56:04 <Cale> Language.Haskell
15:56:53 <oerjan> > (2 -->)
15:56:54 <lambdabot> Unbalanced parentheses
15:56:54 <centrinia> Well, this gives the  expected parse:  Language.Haskell.Parser.parseModule "module Main where\n main = print $ let \n  (-->) a b = a-b \n  in 2 --> 3\n"
15:57:14 <centrinia> I'm the man in the middle!
15:57:31 <oerjan> hm, maybe it is the paren check still then
15:57:55 <sjanssen> oerjan: there is no paren check now
15:58:03 <oerjan> > let (-->) a b = a-b in 2 --> 3
15:58:04 <lambdabot> Unbalanced parentheses
15:58:40 <oerjan> so where does that error come from if centrinia is right...
15:58:46 <Cale> Sure you're using the same version of Language.Haskell?
15:58:49 <Cale> @version
15:58:49 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
15:58:49 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:58:57 <Cale> lambdabot is kind of getting old
15:59:01 <centrinia> I'm using ghc-6.8.2 \m/
15:59:31 <Cale> Which is odd, since I specifically updated hs-plugins so that lambdabot would compile under 6.8.2
15:59:34 <oerjan> > (2 --> 3)
15:59:34 <lambdabot> Unbalanced parentheses
15:59:52 <sjanssen> Cale: IIRC, there are several other problems in lambdabot
16:00:04 <sjanssen> some old ByteString dependencies, for one
16:01:22 <EvilTerran> > ("(")
16:01:22 <lambdabot>  "("
16:01:22 <EvilTerran> > (')')
16:01:22 <lambdabot>  ')'
16:01:23 <centrinia> > 2 --> 3
16:01:23 <Cale> sjanssen: Only trivial ones.
16:01:23 <centrinia> Where's lambdabot?
16:01:23 <lambdabot>   Not in scope: `-->'
16:01:46 <oerjan> EvilTerran: oh they already fixed that (by taking away the specific paren check)
16:01:49 <Cale> mbot: @version
16:01:50 <mbot> lambdabot 4p575, GHC 6.8.2 (Linux i686 2.40GHz)
16:01:50 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:01:52 <lambdabot> Title: Index of /~dons/lambdabot
16:02:01 <Cale> mbot: @part #haskell
16:02:30 <sjanssen> Cale: applied upstream?
16:03:23 <Cale> > (-->)
16:03:23 <lambdabot> Unbalanced parentheses
16:03:23 <mbot> Unbalanced parentheses
16:03:32 <sjanssen> Cale: I have commit privileges if you need them (or I'm sure dons would add you to lambdabot-p if asked)
16:03:32 <Cale> hmm, still broken, interesting :)
16:03:36 <Cale> mbot: @part #haskell
16:04:13 <Cale> I have commit privileges. I can't remember if I applied my changes upstream or what...
16:07:50 <sjanssen> Cale: doesn't look like it
16:11:00 <sjanssen> > pi :: CReal
16:11:00 <lambdabot>   Not in scope: type constructor or class `CReal'
16:11:14 <sjanssen> bah, old lambdabot
16:13:36 <ehird> > pi
16:13:37 <lambdabot>  3.141592653589793
16:13:49 <ehird> > pi :: Int
16:13:49 <lambdabot>   add an instance declaration for (Floating Int)
16:13:49 <lambdabot>     In the expression: pi
16:13:49 <lambdabot>   ...
16:13:52 <ehird> aww :)
16:14:00 <mauke> > pi :: Complex Double
16:14:01 <lambdabot>  3.141592653589793 :+ 0.0
16:14:07 <oerjan> > pi :: Float
16:14:08 <lambdabot>  3.1415927
16:14:34 <EvilTerran> > pi :: Rational
16:14:35 <lambdabot>   add an instance declaration for (Floating Rational)
16:14:35 <lambdabot>     In the expression: ...
16:14:41 <EvilTerran> buu
16:14:44 <EvilTerran> > pi :: Ratio Float
16:14:45 <lambdabot>        add an instance declaration for (Floating (Ratio Float))
16:14:45 <lambdabot>     In the ex...
16:14:47 <oerjan> > toRational pi
16:14:48 <lambdabot>  884279719003555%281474976710656
16:15:00 <ehird> > coerce (pi :: Double) :: Integer
16:15:00 <ehird> 1413754136
16:15:00 <lambdabot>   Not in scope: `coerce'
16:15:09 <ehird> Silly pi!
16:15:42 <sjanssen> what is coerce?
16:15:53 <ehird> coerce :: a -> b
16:15:53 <ehird> coerce a = let xyzzy = unsafePerformIO (newIORef undefined)
16:15:53 <ehird>            in unsafePerformIO (writeIORef xyzzy a >> readIORef xyzzy)
16:15:55 <sjanssen> oh, "Not in scope:" :)
16:16:08 <ehird> so, answer: evil
16:16:12 * sjanssen prefers unsafeCoerce#
16:16:29 <ehird> Mine is cooler! >:(
16:16:46 * mauke uses unsafeCoerce in his xmonad.hs
16:16:53 <ehird> Because it shows how unsafePerformIO can transform Haskell into a weakly typed, evil language!
16:16:58 <ehird> mauke: Yikes. Why?
16:17:00 <sjanssen> mauke: oh dear god why?
16:17:03 <mauke> haha
16:17:22 <LoganCapaldo> mauke++
16:17:36 <mauke> because I want to use a specialized version of mirroring for HintedTile
16:17:57 <ehird> uhm
16:18:00 <ehird> ghc just said this to me
16:18:02 <ehird> 'compilation IS NOT required'
16:18:03 <ehird> why
16:18:10 <centrinia> > pi = 3
16:18:10 <lambdabot>  Parse error at "=" (column 4)
16:18:16 <centrinia> Blah.
16:18:19 <mauke> this is all in the context of MultiToggle, which requires instance declarations for all layout transformers you want to use
16:18:20 <oal> ehird, everything is already compiled
16:18:22 <cjb> ehird: because you re-ran ghc without changing the source file.
16:18:27 <ehird> oh
16:18:32 <ehird> stupid clever ghc
16:18:33 <ehird> >:(
16:18:35 <cjb> so it can use the already compiled binary instead of making a new one.
16:18:56 <mauke> however, the type of this class means it has to work with any layout even though I know it's only applied to HintedTile
16:20:04 <mauke> it is theoretically possible to tell the compiler about this (by making the base layout type a class parameter), but that requires very ugly changes to both MultiToggle and all user code
16:20:14 <monochrom> <3 ghc
16:20:35 <mauke> so I just unsafeCoerce the layout to HintedTile in this case, and it works
16:21:02 <ehird> theWorldsAnInt = coerce (coerce :: a -> b) :: a -> Int
16:21:22 <ehird> Interestingly, "theWorldsAnInt 3" segfaults.
16:21:24 <dcoutts_> byorgey: pong
16:21:38 <sjanssen> ehird: 3 defaults to Integer
16:21:59 <ehird> sjanssen: aha
16:22:45 <Maddas> mauke: do you use Xmonad as your main WM?
16:22:55 <mauke> yes
16:23:03 <dcoutts_> @seen byorgey
16:23:03 <lambdabot> byorgey is in #xmonad, #haskell-blah and #haskell. I last heard byorgey speak 2h ago.
16:23:14 <Maddas> Are you satisfied with it (compared to, say, ion3 or wmii)?
16:23:30 <mauke> I haven't used ion3 but I don't miss wmii
16:24:35 <mauke> wmii just felt like a very immature project
16:24:40 <cjb> I'm using xmonad, but I don't like it enough yet.
16:24:41 <Maddas> Yeah.
16:24:52 <cjb> Because I want to be able to resize windows relative to each other inside the same frame.
16:25:03 <sjanssen> cjb: see resizabletile
16:25:09 <cjb> ie. my master frame contains a 50-line and an 8-line xterm.
16:25:12 <cjb> cool, will do
16:25:47 <cjb> looks good :)
16:25:47 <Maddas> mauke: I would have asked you whether you would share your Xmonad.hs, but it seems that it's already available online :)
16:26:27 <mauke> it is?
16:26:44 <mauke> where?
16:27:06 <Axioplase> cjb: what about ion3 as a WM? (it does not handle automatic positioning, but is very nice to use). I can also tell you to check "awesome"
16:27:10 <Maddas> oh, http://mauke.ath.cx/stuff/xmonad/status/ isn't you? (Or is that not what I'm looking for?)
16:27:11 <lambdabot> Title: Index of /stuff/xmonad/status
16:27:42 <mauke> Maddas: that's a status bar program. and probably an older version
16:27:49 <Maddas> Oops. Mind sharing your xmonad.hs?
16:28:11 <mauke> http://mauke.ath.cx/stuff/xmonad/xmonad.hs
16:28:33 <Maddas> Neat, thanks!
16:32:36 <idnar> I need to see how hard it would be to persuade xmonad to behave like my current ion3 setup
16:33:04 <sjanssen> idnar: what is your setup?
16:33:48 <idnar> sjanssen: nothing terribly fancy, basically every window fills the whole screen, and I have them strewn across a couple of desktops
16:33:57 <idnar> the main thing is key bindings and such
16:34:01 <cjb> Axioplase: I used ion3 before xmonad.  It is fine.  It has the window resizing that I didn't realize xmonad did until now.
16:34:11 <sjanssen> idnar: shouldn't be hard, I think
16:34:13 <cjb> idnar: that sounds fairly easy.
16:34:31 <Axioplase> cjb: maybe I should try xmonad again then
16:34:35 <cjb> idnar: there is also "tritium", which is a reimplementation of ion3 in python.
16:34:38 <sjanssen> cjb: already tried resizabletile?
16:34:40 <cjb> but it is very rough/crude.
16:34:48 <cjb> sjanssen: Not just yet, but will.  Watching an SPJ talk :)
16:35:05 <sjanssen> cjb: no problem, I was just curious if you had some feedback
16:50:12 <dons> bos: bytestring overloading is in 6.8.2 -- if you install bytestring from hackage
16:50:18 <dons> the bytestring in extralibs doesn't have it
16:56:38 <lispy> overloading?  so you get them implicitly?
17:00:16 <dons> conal: new blog looks great!
17:04:20 <dons> bos: where does the bytestringparser repo live?
17:04:39 <bos> darcs.serpentine.com/bytestringparser
17:04:54 <dons> wanna stick it on code.haskell.org ?
17:05:01 <bos> yeah, don't have an account there though.
17:05:17 <dons> go to community.haskell.org and give them your login and public ssh key
17:05:28 <dons> then malcolmw'll set you up
17:05:48 <dons> so is this going to be the one true bytestring parsec-like?
17:06:21 <dons> bos, oh, nice FastSet.hs
17:06:24 <bos> i've asked johan tibbell to collaborate with me. his code is very similar.
17:06:34 <dons> i always wondered if there would be a use for the fast sort on strict bytestrings :)
17:06:38 <dons> oh great.
17:06:38 <bos> now you know!
17:07:07 <dons> we should get ketil to try to parse one of his 25G bioinf files
17:07:08 <bos> ok, malcolmw should have my application now.
17:07:43 <bos> dons: the thing that i want to go back and do is write quickcheck tests for bytestringparser.
17:07:46 <dons> yeah, this looks good.
17:07:55 <dons> right. we need some testing/coverage
17:08:06 <bos> and maybe try out strictcheck on it too.
17:08:08 <dons> how does one test a parser combinator suite.
17:08:15 <dons> hmm. yes. make some laziness statements
17:08:17 <bos> good question!
17:08:39 <lispy> if you have a specific grammar, people make 'grammar' testers
17:08:46 <lispy> they create random sentences
17:08:52 <dons> well, each combinator can be tested in isolation
17:08:55 <lispy> so...you just have to take it up a level :)
17:09:02 <bos> yeah, i'd like the parser to be nicely lazy if possible, because i don't want it e.g. causing an entire 25GB file to get pulled into memory to see if the first character is "#".
17:09:20 <dons> yeah, it can be quite subtle to get the off-by-one laziness bugs out
17:09:33 <dons> bytestring had one, that meant it forced one too many butes
17:09:37 <bos> it took me about 15 minutes to refactor the code to use the same chunking trick as binary.
17:09:48 <bos> haskell is the win for refactoring.
17:09:56 <dons> oh, nice.
17:10:07 <dons> yeah , it helps we added a bit more type structure to lazy bytestrings
17:10:38 <bos> what did you use to check the laziness properties of bytestring?
17:10:55 <bos> manual tests, or something automated?
17:11:11 <dons> automated properties using a custom strictcheck/chasing bottoms set up
17:11:19 <dons> let me point you at em
17:11:37 <dons> should write that up for HW dcoutts_ :)
17:11:48 <bos> yeah, really.
17:12:08 <dons> so it has custom Arbitraries that insert bottoms
17:12:19 <dons> and then you specify what laziness to expect
17:13:05 <lispy> dons: i really have no idea what your tool is like, but could it also help a person gain introspection into what the type checker is doing?
17:13:43 <lispy> dons: i ask, because i insert a lot of bottoms trying to figure out how to get the types to match up sometimes in this darcs code
17:15:20 <dons> http://www.cse.unsw.edu.au/~dons/code/streams/list/tests/Strictness/
17:15:21 <lambdabot> Title: Index of /~dons/code/streams/list/tests/Strictness, http://tinyurl.com/2hsm7g
17:15:53 <dons> but it needs to get packaged
17:16:00 <ehird> what was that functional gui builder again? and is it still under development?
17:16:12 <lispy> ehird: fruit?
17:16:28 <dons> phooey?
17:16:31 <dons> tv?
17:16:43 <ehird> not sure
17:16:59 <ehird> but hey i'm open to any of them... though only ones that iwll actually work for real apps :-) (oops, there they all go)
17:17:08 <dons> gtk2hs?
17:17:22 <dons> someone has to dive in and use one of the high level ones, before anyone else will
17:17:34 <dons> gtk2hs is guaranteed to work
17:17:55 <dons> but if you have a bit more flexibility, and can liase with conal, one of the higher level ones could well be worth it
17:17:57 <lispy> wxhaskell could be nice, but i'm never really sure if it's maintained
17:18:08 <ehird> eek, gtk2hs is 1. gtk 2. gtk 3. gtk 4. ?
17:18:09 <ehird> :)
17:18:10 <dons> yeah, it seems better to build on top of gtk2hs
17:18:16 <dons> all of them
17:18:17 <ehird> (main reason: i use os x)
17:19:12 <cjb> ehird: gtk2.
17:19:32 <ehird> cjb: just as bad
17:19:34 <ehird> :|
17:19:53 <ehird> no quartz support: and the (highly experimental) quartz support is 100% non-native
17:19:55 <cjb> oh.  but the interface is presumably going to be updated to gtk for n>2, but those don't exist yet.
17:19:56 <ehird> not even carbon
17:20:00 <conal> ehird: looking for a functional gui library?
17:20:12 <ehird> conal: yes... i see this leading up to something
17:21:56 <dons> conal: do all the nice functional gui libs live on top of wx?
17:22:01 <dons> any on top of gtk2hs?
17:22:13 <ehird> wx sounds good! gtk2hs not as much so
17:22:26 <dons> it seems like a good idea to build over the well maintained gtk2hs, rather than the unmaintained wx.
17:22:28 <lispy> ehird: why is that, exactly?
17:22:52 <conal> currently wxhaskell is more elegant & gtk2hs better maintained.
17:22:52 <lispy> but, is wx actually unmaintained? there was a big deal several months ago that it would have new maintainers
17:23:24 <ehird> lispy: OS X
17:23:25 <hexpuem> is there another way to multiplex IO other than using forkio?
17:23:29 <conal> grapefruit is on gtk2hs.  phooey & tv are on wxhaskell
17:23:29 <ehird> mainly.
17:23:47 <dons> has anyone written hackage packages that depend on these guys?
17:23:52 <ehird> even the highly crashable quartz port is just that. no carbon. looks entirely non-native.
17:23:57 <ehird> themes can't really do anything to help.
17:24:14 <lispy> ehird: so look and feel and robustness?
17:25:04 <ehird> lispy: mainly, yes...
17:25:05 <conal> ehird: check out Grapefruit, TV, and Phooey on the wiki.  see what you like, and dive in.  if you play with TV and/or phooey, i'll be glad to help.
17:25:15 <ehird> lispy: to phrase it another way, 'it looks like dung on OS X, and I won't accept that'
17:25:35 <ehird> 'also, its C backend is crazy as all hell, and I have a moral objection to crazy as all hell OOP in C ;)'
17:25:35 <conal> btw, Reactive has a mini-phooey in it, for the examples.  it's very simple.
17:25:52 <hpaste>  travisbrady pasted "Error while trying to build lambdabot" at http://hpaste.org/5227
17:26:23 <travisbrady> does anyone have any tips for building lambdabot on os x?
17:26:53 <conal> i'd be happy to help port my functional gui stuff to gtk2hs or some other platform.
17:31:53 <akr> Anyone out there know why I can't build the colllections-0.3 package from Hackage?
17:32:13 <akr> At the "runghc Setup.hs build" step...
17:33:08 <monochrom> I think no one knows.
17:33:17 <akr> ....I get the error message, "Could not find module `Data.ByteString.Lazy'
17:33:31 <akr> "it is a member of package bytestring-0.9.0.1, which is hidden"
17:34:01 <Saizan> akr: add bytestring to build-depends
17:34:03 <akr> And yet when I run "ghc-pkg list", bytestring-0.9.0.1 very much appears not to be hidden.
17:34:09 <Saizan> akr: in the .cabal file
17:34:43 <Saizan> akr: while building cabal hides packages not liste in build-depends
17:35:21 <akr> Thanks! Let me try that.
17:36:41 <lispy> > {- _ -}
17:36:43 <lambdabot>   parse error on input `}'
17:37:02 <lispy> Interesting, so lambdabot cannot handle those types of commens?
17:37:03 <oerjan> > {- _ -} 1
17:37:05 <lambdabot>  1
17:37:15 <lispy> ah, empty input is the real problem
17:37:18 <kmcallister> >
17:37:22 <kmcallister> >
17:37:50 <kmcallister> > -- foo
17:37:50 <lambdabot>   parse error on input `}'
17:38:00 <oerjan> > 1+
17:38:00 <lambdabot>   parse error on input `}'
17:38:17 <oerjan> it's actually the } that lambdabot wraps that expression inside
17:38:19 <lispy> Oh, I know why
17:38:21 <lispy> yeah
17:38:24 <kmcallister> > {}
17:38:24 <lambdabot>  Parse error at "{}" (column 1)
17:38:26 <lispy> exactly, I just realized that too :)
17:39:13 <oerjan> > }
17:39:14 <lambdabot>  Parse error at "}" (column 1)
17:39:39 <idnar> > {
17:39:40 <lambdabot>  Parse error at "{" (column 1)
17:39:45 <lispy> > 1+1 -
17:39:49 <lambdabot>   parse error on input `}'
17:39:51 <idnar> > }{
17:39:51 <lambdabot>  Parse error at "}{" (column 1)
17:39:59 <oerjan> strange that it gives no column number in that case
17:40:17 <idnar> hmm, it's "parse" and not "Parse"
17:40:23 <idnar> so I guess a different piece of code is emitting the error
17:40:32 <oerjan> ah right
17:40:38 <lispy> well, doesn't ghc generate different types of parse errors depending on if it can make a suggestion?
17:40:56 <oerjan> iirc "Parse" is from Language.Haskell while "parse" would be from ghc proper
17:42:10 <LoganCapaldo> So it's possibly to sneak past L.H but not have GHC like it? i'm surprised, I thought it would be the other way around
17:42:26 * monochrom imagines "statically type-checked use of upper and lower cases"...
17:42:55 <Tac-Tics> Hey everyone. I'm trying to figure out the name for a particular kind of system where one uses primitive operations on strings: insert a letter, delete a letter, or change a letter. I remember using it a few years ago in a spellchecker I did for school, but I can't remember the name used for such a system
17:43:06 <Tac-Tics> (I figured this channel would be the place to ask ;-)
17:43:06 <kmcallister> Tac-Tics, that sounds like the string edit distance problem
17:43:10 <monochrom> Hamming distance? Edit distance?
17:43:21 <oerjan> Tac-Tics: that's what lambdabot uses for its spelling correction
17:43:22 <kmcallister> it takes various forms depending on what the ops are, but they can usually be solved by dynamic programming
17:43:39 <oerjan> levens(h)tein pops into my mind
17:43:41 <Tac-Tics> cool, levenshtein distance was the name I remember
17:43:42 <Tac-Tics> yeah
17:43:51 <kmcallister> iirc hamming distance is the number of positions where the symbols differ
17:43:57 <Tac-Tics> and it's possible to get the minimum distance efficiently?
17:44:06 <kmcallister> Tac-Tics, yeah, using dynamic programming
17:44:12 <kmcallister> familiar with the technique?
17:44:29 <kmcallister> the WP article on levenshtein distance explains it
17:44:37 <Tac-Tics> no, but my good friend Dr. Wikipedia is
17:45:01 <kmcallister> (i would actually be interested to see a good (small, elegant) haskell solution to this problem)
17:45:22 <jfredett> i have one, kmcallister
17:45:27 <jfredett> hang on, i'll paste it
17:46:13 <Tac-Tics> I wonder if there's an easy to understand operation to make the problem intractable
17:46:29 <Tac-Tics> maybe something like reordering the letters
17:46:48 <hpaste>  jfredett pasted "distances" at http://hpaste.org/5228
17:46:53 <travisbrady> anyone have any hints w/ this? http://hpaste.org/5227
17:46:55 <kmcallister> jfredett, cool
17:46:58 <jfredett> i wrote that a little while ago
17:47:01 <Tac-Tics> I think *all* the wikipedia algorithms need to be presented in haskell....
17:47:03 <travisbrady> dons: have you tried building on os x?
17:47:07 <Tac-Tics> (or at least in a pattern-matched functional way)
17:47:12 <jfredett> thatsthe relavent bits, plus some extra stuff
17:47:21 <Tac-Tics> none of this python and C-like-math pseudocode bs
17:47:24 <jfredett> theres more, but they dont work quite right yet
17:49:17 <Tac-Tics> jfredett: do you just keep those in a file in case some random person in chat asks for them?
17:49:21 <jfredett> kmcallister: I was actually suprised at how much i could derive from that one "generalDist" formula.
17:49:37 <jfredett> Tac-Tics: no, i was fiddling with something that required them
17:49:43 <jfredett> so I wrote myself a little library
17:49:56 <Tac-Tics> good enough. It'll be really helpful for something of mine
17:50:07 <jfredett> have at it,
17:50:27 <jfredett> i should  clean it up sometime... I bet I could  turn the whole thing into a typeclass... hmm
17:50:33 <kmcallister> food, bbl
17:50:49 <Tac-Tics> I have a friend who is fond of word games, and levenstein measure would make for a really good point system to a game. Like strokes in golf
17:50:59 <jfredett> yah
17:51:07 <cjb> it's a really good point system for a typing tutor, too :)
17:51:11 <jfredett> i was building a "language fingerprinting" kind of thing
17:51:22 <Tac-Tics> sorta like perl golf, only for people who are merely nerd at heart (and not in mind)
17:51:49 <jfredett> i needed the distance stuff, for determining relative similarity between two languages
17:51:56 <cjb> The thing Levenshtein is missing, if I recall, is probabilities for error vs. addition vs. deletion.
17:52:05 <cjb> We should really use Bayes theorem and provide priors.
17:52:32 <litb> hm, infixr seem to be interesting
17:52:44 <jfredett> infixl is cool too, :)
17:52:46 <litb> does that regulate the binding?
17:53:26 <litb> ime if something has a high infixr, it binds better to the right side or something?
17:53:52 <lispy> litb: i forget if higher is tighter, but that's idea
17:53:53 <litb> errm, doesn't make sense for infix . hmm
17:54:37 <litb> i'm not yet convinced of that idea. how does the left side differ from the right side with an infix op?
17:54:42 <monochrom> I keep forgetting "infix 7" "infix 8" which one is "higher" too.  I always have to ask ":info * +" to see. :)
17:54:53 <litb> i would be very confused by an op where infixr op != infixl op
17:55:56 <oerjan> litb: an op is always _either_ infix, infixl or infixr
17:56:23 <twanvl> monochrom: just remember that function application is infixl 10
17:56:34 <jfredett> infixl 9
17:56:39 <jfredett> there is no 10, iirc
17:56:44 <oerjan> the difference only applies between operators with the same number
17:57:16 <oerjan> i.e. something with number 8 always binds tighter than something with number 7
17:57:19 <litb> oerjan: oh, and that says from which side its arguments are bound?
17:57:40 <oerjan> but if ops are equal level, l/r/ comes into play
17:58:04 <twanvl> jfredett: there is also no real function application operator, application is tighter than anything else, so infixl 10
17:59:01 <oerjan> first, all ops of a level used in a row must have the same l/r/, and then it decides which way they are combined (infix means they cannot be combined at all)
17:59:28 <oerjan> > (0$0 +) -- trick
17:59:30 <lambdabot>      The operator `+' [infixl 6] of a section
17:59:30 <lambdabot>         must have lower precede...
17:59:30 <Tac-Tics> jfredett: what transformations does your levenstein function take into account?
17:59:31 <lispy> twanvl: but, but then, data constructors are not infixl 10 are they?  And yet, data constructors are just functions...
17:59:44 <jfredett> Tac-Tics: whatdya mean?
18:00:01 <jfredett> it just calculates letter distance  (based on (ord))
18:00:04 <Tac-Tics> levensteinDist "Saturday" "Sunday" => 7 with your system
18:00:05 <Tac-Tics> ah
18:00:09 <jfredett> and Pads with nulls
18:00:28 <Tac-Tics> so distance between the ASCII's of the letters is taken into account?
18:00:33 <litb> here, Sunday => sleep-time
18:00:47 <jfredett> hamming returns nothing if the strings are not the same length
18:00:57 <jfredett> just (levenstein s t) otherwise
18:01:03 <jfredett> Tac-Tics: yah, basically
18:01:24 <oerjan> lispy: data constructors can also have declared fixity i think
18:01:36 <jfredett> oerjan: they can
18:02:06 <oerjan> the default is infixl 9 for all operators (even `such` ones) unless declared
18:02:49 <lispy> oerjan: right, they can
18:03:02 <Tac-Tics> jfredett: ok. I was just confused because it's not the same one on the Levenstein Algorithm wikipedia page
18:03:36 <lispy> oerjan: it's just weird to me sometimes that data constructors are functions but, no not really...oh wait, yes they are but sometimes
18:03:41 <jfredett> Tac-Tics: I didn't really follow it to closely, It was just a little hack
18:04:06 <jfredett> I think I'm gonna fix it up.
18:04:11 * Tac-Tics is annoyed all the wikipedia pages use base-1 indexes!
18:04:19 <Tac-Tics> err
18:04:23 <Tac-Tics> 1-based*
18:04:48 <asdf25> hey so i have a question about modules if anyone cares to answer... when i'm writing a program and i have a big central module, and i'll have a group of related code in the central module that i'd like to move to a seperate module to hide the implementation details and avoid cluttering the namespace of the central module... but this isn't possible in haskell because modules can't be mutually dependent? is there something wrong
18:04:48 <asdf25>  with that idea?
18:05:14 <monochrom> base-1 indexes would be awesome!
18:05:19 <oerjan> asdf25: circular imports are legal in haskell
18:05:24 <jfredett> monochrom: Peano numbers ftw?
18:05:45 <jfredett> in ghc, anyway, IIRC, some other compiilers dont work
18:05:49 <lispy> asdf25: well, you don't have to export everything in the module.  Otherwise just be careful about the module dependencies.
18:05:54 <Tac-Tics> The haskell report says modules should be allowed to be recursive, but there are flags for it, I think, in GHC
18:06:13 <lispy> jfredett: ghc requires a hack to work with mutualy dependent modules...it's kinda painful for the programmer.
18:06:25 <monochrom> Not flags. You need to write some ".hi-boot" files. More work than flags.
18:06:26 <oerjan> asdf25: but in ghc you need to add a special file to list types etc.
18:06:27 <jfredett> lispy: ah, cool
18:07:12 <Saizan> http://hpaste.org/100 <-- mine, an year ago!
18:07:31 <oerjan> asdf25: but a limited export list is much simpler when it works
18:07:31 <Tac-Tics> thanks
18:07:32 <asdf25> oh great, i'll look into that... anyone have a link or google search term for more info?
18:08:18 <oerjan> http://haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
18:08:18 <lispy> Module Foo ( function1, function2, ... ) where ...
18:08:19 <lambdabot> http://tinyurl.com/2y3hr6
18:09:05 <sclv> asdf25: also, its possible that you can often segregate your classes and types out into a different module, and then have various modules that each only depend on those.
18:09:40 <oerjan> http://haskell.org/onlinereport/modules.html#sect5.2 (export lists)
18:10:54 <litb> frankly, i like arrows more than monads apparently
18:11:25 <jfredett> arrows are awesome
18:11:32 <asdf25> sclv: yeah, was thinking something like that might be good too, or necessary if language doesn't support mutual dependency
18:11:40 * sclv still hearts monoids.
18:11:52 <jfredett> monoids are cool, functors too
18:12:03 <jfredett> really, an algebraic structure is awesome in my book
18:13:08 <sclv> not all monads are monoids, but i was wondering if every monoidal functor is by definition a monad.
18:13:34 <oerjan> what is a monoidal functor?
18:13:50 <jfredett> a monoid that is also a functor?
18:13:51 <jfredett> :)
18:14:16 <jfredett> @src monoid
18:14:16 <lambdabot> Source not found. I feel much better now.
18:14:20 <jfredett> :/
18:14:21 <sclv> although actually, i suppose if you let >> be mappend, every monad actually is a monoid.
18:14:28 <sclv> ?src Data.Monoid.Monoid
18:14:29 <lambdabot> Source not found. I am sorry.
18:14:31 <oerjan> @src Monoid
18:14:32 <lambdabot> class Monoid a where
18:14:32 <lambdabot>     mempty  :: a
18:14:32 <lambdabot>     mappend :: a -> a -> a
18:14:32 <lambdabot>     mconcat :: [a] -> a
18:14:37 <sclv> ?src Monoid
18:14:37 <lambdabot> class Monoid a where
18:14:37 <lambdabot>     mempty  :: a
18:14:37 <lambdabot>     mappend :: a -> a -> a
18:14:38 <lambdabot>     mconcat :: [a] -> a
18:14:41 <jfredett> bah, case sensitivity
18:15:04 <oerjan> sclv: no, >> has no right unit
18:15:29 <idnar> @src Functor
18:15:29 <lambdabot> class  Functor f  where
18:15:29 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
18:16:01 <idnar> using arrows still makes my head explode
18:16:45 <jfredett> idnar: thats the best part
18:16:50 * sclv outside of parsers and futzing with tuples (and, ok, fine, frp) has yet to see any special uses for arrows.
18:16:58 <lispy> there is one special case where i like arrows, and that's the Monad special case :)
18:17:45 <sclv> What I'd really like to see would be somebody demonstrating a use for a CoApplicative
18:18:26 <lispy> sclv: you need Cale
18:18:40 <lispy> I'm sure he has canned examples of that.
18:19:17 * oerjan isn't sure what a CoApplicative is but assumes every CoMonad is one
18:19:19 <sclv> coAp would be f a -> f b -> f (a -> b), no?
18:19:47 <sclv> or actually (f a -> f b) -> f (a->b) to be useful.
18:20:45 <lispy> sclv: what is f, a fuctor?
18:20:57 <lispy> functor*
18:21:06 <sclv> a coFunctor, I'd imagine.
18:21:13 <sclv> or a coApplicative actually.
18:21:18 <lispy> "fuctor" sounds like something they say in the south to ask if you slep with someone
18:22:14 <twanvl> Another interpretation is that ap is equivalent to (f a, f b) -> f (a,b), then its dual is f (a+b) -> f a + f b
18:22:55 <Saizan> ?
18:23:01 <Saizan> ?type ap
18:23:02 <oerjan> taking zip as basic instead of zipWith, right?
18:23:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:23:38 <twanvl> oerjan: yes, the applicative paper sugests this makes more sense from a category theory perspective
18:23:53 <lispy> > ap (liftM (+1)) (return 2) :: Maybe Int
18:23:54 <lambdabot>  Couldn't match expected type `Maybe (a -> Int)'
18:23:59 <Saizan> i can see  (m (a -> b), m a) -> m b, but not (f a, f b) -> f (a,b)
18:24:15 <oerjan> more categories have products than have exponentials...
18:24:31 <lispy> :t liftM (+1)
18:24:33 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1
18:24:49 <lispy> > ap (+1) (return 2) :: Maybe Int
18:24:49 <lambdabot>      The section `(+ 1)' takes one argument,
18:24:49 <lambdabot>     but its type `Maybe (a -> In...
18:24:56 <lispy> huh
18:25:02 <lispy> I'm doing something wrong :)
18:25:18 <sclv> lispy the function there would i think be fmap
18:25:59 <lispy> > ap (return (+1)) (return 2) :: Maybe Int
18:26:00 <lambdabot>  Just 3
18:26:25 <oerjan> Saizan: ap f x = fmap ($) (liftM2 (,) f x)
18:26:26 <lispy> > (return (+1)) `ap` (return 2) :: Maybe Int
18:26:26 <lambdabot>  Just 3
18:26:42 <oerjan> er, uncurry ($)
18:26:54 <oerjan> so you could take liftM2 (,) as base
18:27:05 <chessguy> @pl \f x -> fmap ($) (liftM2 (,) f x)
18:27:05 <lambdabot> liftM2 (,)
18:27:47 <oerjan> @pl \f x -> fmap (uncurry ($)) (liftM2 (,) f x)
18:27:47 <lambdabot> (fmap (uncurry id) .) . liftM2 (,)
18:28:11 <sclv> :t liftM2 (,)
18:28:11 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
18:28:56 <sclv> twanvl: silly question, but what does the + mean in what you wrote above?
18:29:04 <twanvl> sclv: Either
18:29:45 <Tac-Tics> jfredett: weird! I just reimplemented it according to wiki (to the best of my abilities..) and I got the same answer as you
18:29:52 <sclv> ah. ok i've seen that notation before.
18:29:54 <jfredett> oh, hmm
18:30:15 <wy> Does the Show class completely solve the string concatenation problem?
18:30:17 <oerjan> :t ap
18:30:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:30:18 <jfredett> not sure why, but there you have it
18:30:19 <jfredett> :)
18:30:24 <oerjan> :t \f x -> fmap (uncurry ($)) (liftM2 (,) f x)
18:30:25 <lambdabot> forall b a2 (f :: * -> *). (Monad f, Functor f) => f (a2 -> b) -> f a2 -> f b
18:30:56 <Tac-Tics> but I translated it to python and it worked as expected
18:31:08 <jfredett> what was the answer supposed to be?
18:31:21 <jfredett> for Saturday to Sunday
18:31:22 <Tac-Tics> dist "Saturday" "Sunday" is 3
18:31:32 <Tac-Tics> delete a, delete t, insert n
18:31:37 <litb> ap is just liftM but for monadic functions ?
18:31:45 <jfredett> right
18:31:48 <glen_quagmire> how can I test if two expressions have same type?
18:31:52 <oerjan> litb: no
18:32:03 <oerjan> ap is <*>
18:32:05 <jfredett> so mine is really just a oddball version of levenstein
18:32:10 <jfredett> hamming*
18:32:18 <oerjan> liftM = fmap
18:32:18 <jfredett> not levenstein
18:32:22 <glen_quagmire> isSameType 1 2.0
18:32:42 <wy> glen_quagmire: You don't need to test them
18:32:42 <oerjan> :t 1
18:32:44 <lambdabot> forall t. (Num t) => t
18:32:46 <oerjan> :t 2.0
18:32:46 <glen_quagmire> @hoogle a -> b -> Bool
18:32:47 <lambdabot> No matches, try a more general search
18:32:47 <lambdabot> forall t. (Fractional t) => t
18:33:39 <litb> @src (<*>)
18:33:40 <lambdabot> Source not found. stty: unknown mode: doofus
18:33:53 <Saizan> glen_quagmire: there's nothing like that at runtime, the best you can get is isSameType a b = typeOf a == typeOf b
18:33:54 <glen_quagmire> can I get length of a tuple?
18:33:58 <sclv> ?src ap
18:33:58 <lambdabot> ap = liftM2 id
18:34:16 <glen_quagmire> :i typeOf
18:34:18 <sclv> :t ap
18:34:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:34:50 <sclv> ap takes a function "in" a monad, applies it to a value "in" a monad and returns the result "in" the same monad.
18:34:59 <oerjan> @src Applicative
18:35:00 <lambdabot> class Functor f => Applicative f where
18:35:00 <lambdabot>     pure  :: a -> f a
18:35:00 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
18:35:07 <pgavin> giggity giggity goo
18:35:09 <oerjan> litb: ^
18:35:12 <wy> glen_quagmire: tuple is not recursive, so you need to keep track of the length your self
18:35:22 <glen_quagmire> i see
18:35:38 <twanvl> glen_quagmire: what are you trying to do?
18:35:51 <glen_quagmire> twanvl: i'm just wondering why list and tuple are different
18:35:59 <idnar> :t (<$>)
18:36:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:36:05 <glen_quagmire> list makes sense because it makes possible functions like `map`
18:36:21 <twanvl> glen_quagmire: A list is homogenious, all elements have the same type
18:36:40 <glen_quagmire> so, why not make tuple almost same as list ? with all list interfaces, constructors..etc
18:36:49 <jfredett> glen_quagmire: also, tuples are finite, whereas lists can be lazyily infinite
18:37:08 <jfredett> glen_quagmire: cause tuples are heterogenous
18:37:16 <litb> @src Functor
18:37:16 <lambdabot> class  Functor f  where
18:37:16 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
18:37:17 <wy> glen_quagmire: If so, you don't need tuples...
18:37:18 <jfredett> and thats not particularly straightforward to implement
18:37:40 <glen_quagmire> jfredett: so, the differentiation comes from implementation, not from math?
18:37:59 <glen_quagmire> i mean difference between tuple and list
18:38:01 <Cin> http://rtfs.ath.cx/haskell/IRCServer/Server.hs.html
18:38:02 <lambdabot> Title: Haskell Code by HsColour
18:38:09 <Cin> feel free to grab hscolour.css =]
18:38:14 <wy> But I think lists shouldn't necessarily be homogeneous
18:38:22 <jfredett> glen_quagmire: well, sortof. wy is right, if we had all that, we wouldn't need tuples, we'd just use lists
18:38:26 <glen_quagmire> probably people added tuple so that they can group heterogeneous values together?
18:38:31 <litb> hm, but it looks like that the only difference is that with <*> the function in wrapped inside the monad, while it is not wrapped inside a monad with fmap
18:38:32 <nolrai> also tuples of diferent are typed diffrently from each other, the tupleness happens at compile time
18:38:47 <jfredett> glen_quagmire: so they can group heterogenous values together easily, yes
18:38:55 <wy> glen_quagmire: They added tuples for some weird mathematical reasons
18:38:58 <oerjan> litb: <*> is Applicative
18:38:59 <jfredett> its hard, not imposible to hack together a heterogenous list.
18:39:22 <twanvl> but you will end up with something more like tuples if you do.
18:39:30 <wy> jfredett: I saw as if O'Haskell can do it
18:39:33 <glen_quagmire> wy: oh
18:39:43 <jfredett> wy: normal haskell can too
18:39:51 <glen_quagmire> python has heterogenous list. but it's dynamically typed
18:39:51 <nolrai> why is (a,b,c) not synatic sugar for ((a,b),c)
18:39:56 <wy> jfredett: But that wouldn't be consistent
18:40:12 <nolrai> wy: ??
18:40:20 <jfredett> O'Haskell might have an easier time, but it can be done, type safely iirc, in haskell
18:40:39 <jfredett> the trick is to use some kind of data type to wrap them, and other fancy things
18:40:47 <glen_quagmire> let's make all types derived from Object and be done with it
18:40:52 <twanvl> nolrai: because the semantics are slightly different, more things can be _|_
18:40:57 <wy> jfredett: That's not convenient
18:41:07 <jfredett> wy which is why we have tuples
18:41:08 <jfredett> :)
18:41:08 <wy> jfredett: And in a sense wrong in my idea
18:41:09 <nolrai> like [Either Int Float]
18:41:17 <nolrai> twanvl: how?
18:41:25 <oerjan> glen_quagmire: subtyping is fundamentally incompatible with decidable type inference
18:41:48 <nolrai> oh you mean more on the ((a,b),c) side?
18:41:54 <wy> jfredett: Everytime you need that, you wrap the things up. Then they will get thick... hehe
18:42:05 <idnar> glen_quagmire: note that you don't normally use lists in a heterogenous fashion in python
18:42:12 <twanvl> if (a,b,c) = (a,(b,(c,())) then a value of type (a,b,c) can be _|_, (_|_,_|_), (_|_,(_|_,_|_)), etc.
18:42:30 <jfredett> the real deal here, wy, is that anywhere you need a heterogenous list, you can probably get away with a tuple
18:42:37 <twanvl> The solution would be to declare: data Tuple a b = Tuple a !b
18:42:42 <jfredett> or several distinct lists
18:43:02 <nolrai> or use foralls
18:43:17 <twanvl> And desugar (a,b,c) as Tuple a (Tuple b (Tuple c ()))
18:43:20 <wy> jfredett: not necessarily. Many times we need that
18:43:22 <idnar> glen_quagmire: if you just have a bunch of random objects in a list, it's pretty hard to do anything with it, except maybe treat it as a "record" of sorts, like a tuple
18:43:27 <nolrai> (but those are wierd)
18:43:36 <glen_quagmire> idnar: ah makes sense
18:43:49 <jfredett> wy: right, and in that situation, it could probably be better written, or at the least changed into separate lists
18:43:54 <idnar> glen_quagmire: so generally you're expecting all of the objects in a list to share a common interface, even if that's not explicitly defined, and you only use operations from that common interface
18:43:57 <glen_quagmire> with tuples, you can only pattern match to access elements right?
18:43:59 <wy> jfredett: Say you have some apples and oranges. You want to put them into one bowl and eat them... You can't have a bowl like that
18:44:14 <jfredett> why not? they're both instances of the type class "food"
18:44:20 <idnar> glen_quagmire: in Haskell, you'd group those into a typeclass, and use that to type the list
18:44:20 <jfredett> food a => [a] is the type
18:44:20 <glen_quagmire> well fst, snd
18:44:20 <jfredett> :)
18:44:34 <twanvl> we need first class existential types, [exists a. Food a => a]
18:44:44 <idnar> (SomeStuff a) => [a] or whatever
18:45:02 <nelhage> That's still a homogenous list, idnar
18:45:06 <jfredett> wy, if you _really_ need heterogenous lists that badly, you can always hack them up
18:45:09 <idnar> nelhage: yes, that's my point
18:45:21 <jfredett> create a typeclass for the types you need with no implementation details
18:45:25 <jfredett> instance the types you need
18:45:26 <wy> jfredett: No way. I tried
18:45:44 <wy> jfredett: At least no nice way
18:45:50 <nolrai> why not?
18:45:55 <jfredett> ooh, i don't think so, give me ten minutes
18:46:39 <wy> Because the type system of Haskell and ML think we know what a thing is, but actually we don't know
18:46:59 <nolrai> but you can tell it that
18:48:34 <wy> so we are cheating ourselves
18:48:46 <nolrai> there has to be some conditions on what it is or it doesn't make any sense.  you cant do anthing if you truly dont know what it is. (whether its in a list or not)
18:49:06 <Saizan> wy: use an existential if you want that, or read the HList paper if you want to keep the type information
18:49:26 <jfredett> the typeclass way doesn't work like i thought it would, but you can do it w/ datatype just as easily, (though, you do need to have constructors)
18:49:33 <wy> Saizan: Do I need a new type for the heterogeneous list?
18:49:54 <hpaste>  jfredett pasted "heterolist hack" at http://hpaste.org/5230
18:50:20 <Saizan> wy: with existentials you need a wrapper like data Foo = forall a. Foo a => Foo a, and then have [Foo]
18:50:43 <poodlesucks> is there any good windows to linux games that teaches me about life(no half life 2)?
18:50:44 <jfredett> add a deriving show, so you can see it
18:50:55 <Saizan> and you can put there any type that instances the class Foo, if you wrap it in the Foo constructor
18:51:00 <jfredett> poodlesucks: does not compute, retry.
18:51:39 <wy> I often find there are two ways to do the same thing. type classes or sum types. So I think they are duplicated in functionality
18:51:55 <poodlesucks> jfredett> game that is good for your mind lik eworkign but fun
18:51:58 <Saizan> sumtypes are harder to extend
18:52:05 <wy> Saizan: that simple?
18:52:20 <wy> Saizan: Do I need a new kind of list?
18:52:24 <sclv> data Showable = Shows a => Showable a
18:52:42 <sclv> now you can have a list of showables.
18:52:44 <Saizan> wy: no. but you won't be able to "downcast" them
18:52:56 <sclv> and it works like an "OO" interface.
18:53:51 <sclv> showme (Showable a) = show a
18:54:21 <wy>     Not in scope: type variable `a'
18:54:24 <oerjan> instance Show a => Show (Showable a) where show (Showable a) = show a
18:54:40 <oerjan> er wait
18:54:57 <Saizan> wy: did you add the forall a.? and you need -fglasgow-exts
18:55:05 <oerjan> just instance Show Showable where show (Showable a) = show a
18:55:13 <Saizan> or -XExistentialTypes, iirc
18:55:31 <Tac-Tics> what's the correct brace notation for lets?
18:55:47 <oerjan> let { x = 3; y = 2 } in ...
18:55:58 <Tac-Tics> ah, I'm messing up the in part
18:55:59 <Tac-Tics> thanks
18:56:05 <davidL> Do HDBC and HSQL achieve the same goals? Is there any reason to choose one over the other?
18:56:19 <wy> data Showable = forall a. (Show a) => Showable a
18:56:25 <oerjan> Tac-Tics: the brackets are never necessary i think
18:56:39 <oerjan> (for let ... in)
18:56:51 <Tac-Tics> I know, but I was getting errors, and it took me a second to think of why
18:56:58 <Tac-Tics> it was because I had a multiline expression
18:57:10 <wy> [10, "hello"] still doesn't work
18:57:19 <Tac-Tics> it's just as well, I'm just trying to get something to work, then I'll go back and clean it up
18:57:27 <twanvl> [Showable 10, Showable "hello"]
18:58:06 <wy> twanvl: If I do that, I don't need existentials
18:58:25 <Saizan> twanvl: that's how existentials work.. and you need them.
18:58:32 <Saizan> err, wy
18:58:41 <Saizan> how could you write that without?
18:58:59 <wy> Saizan: But the wrapper will get thick
18:59:26 <twanvl> if the language supported first class existentials, you wouldn't need them. See for example Morrow.
18:59:42 <Saizan> it's not like you want to use them everywhere.. and you need to store dictionaries somewhere anyway
19:00:32 <monochrom> Consider "Showable" as an upcast operator.
19:00:34 <wy> I just guess maybe object-oriented way has something nice in it. That's just another kind of philosophy
19:01:08 <Saizan> wy: it's not like objects are not that thick :)
19:01:27 <Saizan> however yes, subtyping has its merits
19:03:19 <poodlesucks> IMPORTANT. why are television shows designed to mass me up where movies to not mass me up ? so what are some games that are movie like but not television shows alike?:D thank you
19:03:28 <monochrom> kickban
19:03:45 <wy> I guess the thing is that, functional languages think we know what a thing is, but object-oriented languages think we only know what we can do with them.
19:04:43 <wy> The latter seems to be mostly right in a philosophical sense
19:05:05 <wy> The former might be a useful simplification
19:05:11 <Saizan> well, then you'd like a language with structural subtyping rather than nominal
19:05:16 <Botje> > take 10 $ sortBy (flip $ comparing awesomeness) allMovies
19:05:18 <lambdabot>   Not in scope: `allMovies'
19:05:31 <oerjan> monochrom: getting predictable - i suspected it hours ago
19:05:33 <Botje> boo.
19:06:49 <wy> Saizan: I don't know if I can still get other nice features of haskell, but it sounds like possible
19:08:44 <wy> Saizan: but maybe bidirectional programming wouldn't be possible anymore
19:08:45 <Saizan> wy: well not haskell, which doesn't have subtyping at all, but the mainstream oop typed languages bases "what you can do with an objects" on names of the types, rather than the collections of available methods
19:09:30 <Tac-Tics> dear god, I need to learn how to use the haskell debugger
19:09:44 <Saizan> bidirectional programming?
19:10:06 <Tac-Tics> I accidentally put "sameAt i j = s !! (i-1) == t !! (i-1)" instead of "sameAt i j = s !! (i-1) == t !! (j-1)"
19:10:09 <Tac-Tics> took me an hour to find it
19:10:10 <wy> Saizan: Like prolog. I guess the nominal typing has something to do with that
19:11:07 <wy> I guess the algebraic data types are inherited some logic language, maybe databases
19:11:14 <monochrom> Is "bidirectional programming" a well-known term? How many authors have used it?
19:11:26 <twanvl> Tac-Tics: enable warnings, you would have got "sameAt doesn't use binding 'j'"
19:11:35 <wy> monochrom: maybe not. I just heard it recently
19:12:23 <Tac-Tics> twanvl: What would the K combinator think of that advice =-D
19:12:27 <Saizan> i guess adt and terms in prolog both discend by the concept of grammar
19:12:50 <twanvl> Tac-Tics: that is what _ is for, you only get warnings about actual names
19:13:00 <Tac-Tics> now the only problem is using strings is _O____slooowoo____f____e
19:13:08 <Tac-Tics> oh really? Cool
19:13:31 <wy> and then logic itself ... from aristotle...
19:13:36 <Tac-Tics> Do you know the flag twanvl?
19:13:38 <oerjan> Tac-Tics: i think you can even do _f and such if you do want to give an unused var a name
19:13:48 <monochrom> -Wall
19:13:54 <Tac-Tics> blah
19:13:58 <Tac-Tics> I'll do that from now on
19:14:13 <Tac-Tics> Now it's time, I think, to learn about bytestrings
19:14:15 <Tac-Tics> or arrays
19:14:26 <Tac-Tics> I need something with O(1) access
19:14:52 <monochrom> -fwarn-unused-binds
19:15:23 <Tac-Tics> In Haskell, what's considered best practice for when you want to take strings, but you need them to be O(1) access? Should you pass String and internally convert them to Bytestring and back?
19:15:35 <Tac-Tics> or pass in Bytestrings and burden the caller with wrapping the input?
19:15:54 <monochrom> Add -Werror for real fun.
19:16:58 <wy> Tac-Tics: You might want to find better ways to deal with strings
19:17:05 <monochrom> I would decide on a case-by-case basis.
19:17:20 <twanvl> Tac-Tics: first make a function that takes a ByteString, then for convenience make a wrapper function that converts the input/output
19:17:21 <Tac-Tics> There should be an -Wabsolutelyall which prevents your program from compiling at all, and instead simply prints out the error message "This program almost surely has a bug in it, you're better off doing things on pen and paper.
19:17:49 <monochrom> I know how to implement -Wabsolutelyall
19:18:50 <poodlesucks> IMPORTANT. why are television shows designed to mass me up where movies to not mass me up ? so what are some games that are movie like but not television shows alike?:D thank you
19:18:58 <monochrom> There is a more moderate ground, "if you also submit a machine-checkable proof of correctness, it's OK". It is called Coq. :)
19:19:32 <nelhage> But who shall check the checker?!
19:20:41 <Tac-Tics> are Data.ByteString's length and Data.ByteString.Char8's length distinct functions?
19:20:53 <twanvl> no
19:21:12 <Tac-Tics> what about the 'pack's of both?
19:21:22 <twanvl> .Char8 is just a thin wrapper that converts between Word8 and Char
19:21:27 <monochrom> No one checks the checker. The point is making your life hard, not correctness. :)
19:21:42 <dons> Tac-Tics: they're just a different interface to the underlying data
19:22:03 <Tac-Tics> so it would be a namespace nightmare if you tried to intermix them?
19:22:17 <Tac-Tics> not that I'm trying to do that here
19:22:21 <dons> Tac-Tics: not really. you'd be force to import one qualified
19:22:35 <Tac-Tics> ok
19:23:17 <davidL> What is the preferred way to keep state for a happs web-app, using a database or serializing it with Data.Binary?
19:24:04 <monochrom> Not sure about preferred ways, but I have a great idea: use both. :)
19:24:27 <monochrom> Serialize with Data.Binary, submit the bit string to the database.
19:25:00 <davidL> you mean use a database instead of Control.Monad.State?
19:25:03 <dons> davidL: the happs framework will store state for you
19:25:14 <monochrom> Database is great for organizing and looking up things, e.g., map from cookie to state.
19:25:23 <dons> so usually you store in memory, and let the macid thingy keep it synced to disk
19:25:33 <monochrom> OK, nevermind me.
19:25:35 <dons> but you can hook in databases too, if you want
19:25:55 <dons> monochrom: what's all this about me getting personal slaves?
19:26:22 <davidL> has macid been added recently?
19:26:31 <dons> its been in since the beginning
19:26:34 <monochrom> I see that my original statement gets distorted by transmission :)
19:26:39 <dons> hpaste.org for example, stores things in an IntMap (iirc)
19:26:49 <dons> but gets synced to disk by the framework
19:27:14 <davidL> dons: really? I'm looking at the source for that right now
19:27:38 <Tac-Tics> damn, even with BS, it's still slower than the python version!
19:27:46 <dons> Tac-Tics: sounds suspicious. what are you doing?
19:27:51 <Tac-Tics> I'll paste it
19:27:54 <dons> and did you compile with -O2
19:28:18 <hpaste>  Tac-Tics pasted "(no title)" at http://hpaste.org/5231
19:28:24 <Tac-Tics> oh, no I didn't
19:28:25 <Tac-Tics> actually
19:28:29 <Tac-Tics> I ran it in ghci
19:28:31 <Tac-Tics> so that might be it
19:28:33 <Tac-Tics> lemme compile
19:28:43 <davidL> I don't see IntMap anywhere
19:29:06 <Saizan> hpaste uses Data.Sequence.Seq
19:29:41 <dons> Tac-Tics: yeah, ghci is 30-500x slower than compiled with -O2
19:29:42 <monochrom> hpaste keeps all pastes in memory? all five thousand of them?
19:29:51 <dons> gzipped.
19:30:41 <Tac-Tics> how much does O2 versus no O compilation?
19:30:41 <dons> lots
19:30:42 <dons> esp. with bytestrings
19:30:42 <Tac-Tics> what does it do exactly? just run more of the optimizations?
19:30:42 <dons> if you care about speed, always -O2
19:30:42 <dons> yep. enables the rewrite rules, and constructor specialisation, and inlinging, and 20 years of research
19:30:42 <Tac-Tics> Oh cool, it from from taking nonzero time to zero time!
19:30:45 <davidL> doesn't that make backing up hpaste more difficult?
19:30:46 <Tac-Tics> hah, I like that
19:30:47 <Saizan> Tac-Tics: won't that recursion kill you?
19:30:52 <monochrom> zero time!
19:31:03 <Tac-Tics> I really want to learn more about GHCi and functional language compilers
19:31:14 <Tac-Tics> saizan: would it?
19:32:40 <Saizan> Tac-Tics: well it's like calculating fibonacci the recursive way, you get exponential complexity rather than polynomial, but it's more a gut feeling since it's too late for me to follow the code :)
19:33:03 <davidL> Saizan: Data.Sequence is what I needed, thanks
19:33:05 <Saizan> davidL: you just have to save the last checkpoint of the state
19:33:09 <Tac-Tics> Well, I just copied the wiki page to the best of my ability
19:33:21 <Tac-Tics> And their algorithm runs in O(nm) of the two strings
19:34:01 <Tac-Tics> I'm pretty sure with laziness, Haskell gets the same performance
19:34:02 <dons> Tac-Tics: you can make that somewhat faster by not packing
19:34:10 <Tac-Tics> no packing?
19:34:11 <dons> and using unsafeIndex, since you already have the bounds checked
19:34:16 <Tac-Tics> oh cool
19:34:43 <Tac-Tics> If I can dare ask... what if you overshoot the bounds with unsafe?
19:34:56 <Tac-Tics> Death by Segfault?
19:35:10 <Saizan> Tac-Tics: with the difference that d in wikipedia is a matrix, not a function, haskell doesn't memoize functions per se
19:36:41 <Tac-Tics> Saizan: I only kinda paid attention in the class where we went over Big-Oh, so I dunno ;-)
19:37:03 <Tac-Tics> But for my purposes, this works for now
19:38:00 <Saizan> it won't get bad for small strings.. it's not O(nm) becuse you end up recalculating a lot of small subproblems rather than sharing results
19:38:00 <monochrom> You probably haven't tried large inputs, such as 50-byte strings.
19:38:47 <Tac-Tics> Well, for the scope of what I'm working on, the biggest string I'll need on either input will about about 15 at the very extremely biggest
19:39:18 <Tac-Tics> Is there a nice way to force a function to memorize? I like the clarity of it how it's written now
19:39:59 <Tac-Tics> I could just use an array, but then again, I could just write it in C ;-)
19:39:59 <monochrom> http://www.haskell.org/haskellwiki/Memoization
19:40:01 <lambdabot> Title: Memoization - HaskellWiki
19:40:08 <hpaste>  nolrai annotated "bad attempt at Prompt" with "this works but i dont understand how it dosn't break the type system" at http://hpaste.org/5220#a1
19:40:37 <monochrom> Might be more elaborate than necessary.
19:42:09 <Saizan> it doesn't list the easier solution.. allocate a lazy array filled with the results and use it recursive calls
19:42:22 * gwern goes into hour 4 of hacking yi's cabal setup &etc. I now understand why dons stopped maintaining it
19:42:43 <Tac-Tics> What's the difficulty with it?
19:43:09 <gwern> Tac-Tics: was that aimed at me?
19:43:19 <Tac-Tics> sorry, yes
19:44:16 <gwern> Tac-Tics: its intricate setup of ~70 files, infelicities in cabal, yi pushing the capabilities of ghc and cabal both, grotty ancient unmtaintined code, a switch from -fglasgow-exts to enumerating extensions in the files and .cabal, etc.
19:44:45 <monochrom> http://www.haskell.org/haskellwiki/Dynamic_programming_example  may inspire you.
19:44:46 <lambdabot> Title: Dynamic programming example - HaskellWiki
19:44:53 <gwern> the old keymaps were especially unpleasant. bernardy depcreated and removed and renamed a ton of functions, but didn't bother to fix the code that used them
19:45:18 <gwern> and the keymaps weren't well commented, so I had to go spelunking through old revisions and editor man pages...
19:45:42 <Tac-Tics> is that why there are so many functions ending with E in weird places? I figured msgE and friends were all EditorM values, but I found a few counterexamples
19:46:12 <Tac-Tics> monochrom: thanks for the link
19:46:22 <gwern> Tac-Tics: he seems to have generally renamed stuff from fooE to fooB
19:46:28 <gwern> msgE just got missed maybe?
19:46:42 <Tac-Tics> I dunno
19:46:49 <Tac-Tics> I wonder if maybe I picked too hard of a project to work on
19:46:53 <Tac-Tics> =-P
19:47:00 <gwern> his darcs commits were notably laconic and unhelpful...
19:47:32 <gwern> Tac-Tics: well, I have yi compiling again with a massively revamped cabal file, and I *think* sdist now includes all the sourc-files. but there are still a few niggling issues where the sdist tarball won't compile
19:48:47 <Tac-Tics> gwern: and you goal is to make yi accessible to the part of the world who doesn't want to spend at least 2 hours getting it to compile =-)
19:49:38 <gwern> Tac-Tics: oonce the sdist tarball compiles and runs, I intend to borrow the ghc CLI options from xmonad and use them for xmonad. should make compiles quicker
19:50:00 <gwern> (Tac-Tics: and yes, I would devoutly love a new Hackage release, which is why I've been spending all day on this)
19:50:20 <Tac-Tics> will it affect the load time at all? The current wait time for it to open is ridiculous
19:50:28 <jfredett> gwern a new release for yi, thats easier to install, kick. ass.
19:50:37 <jfredett> gwern++ for even trying.
19:50:45 <BMeph> Yay, Team gwern! gwern++
19:50:53 <gwern> jfredett: 'for even trying'? that's hardly encouraging
19:50:59 <Tac-Tics> heh
19:51:06 <jfredett> lol, the last time i tried to compile yi
19:51:10 <jfredett> i spent a week in an asylum
19:51:19 <jfredett> assylum?, w/e
19:51:29 * gwern thrusts a dagger through the map of Hackage in the Ys section; Yar! thar be dragons
19:51:35 <jfredett> lol
19:51:40 <oerjan> @remember jfredett  the last time i tried to compile yi i spent a week in an asylum
19:51:41 <lambdabot> Good to know.
19:52:03 <jfredett> :)
19:52:04 <gwern> @quote jfredett
19:52:04 <lambdabot> jfredett says:  the last time i tried to compile yi i spent a week in an asylum
19:52:09 <BMeph> ibid: Nice ST write-up. (No, not the monad)
19:52:11 <gwern> @quote jfredett
19:52:11 <lambdabot> jfredett says:  the last time i tried to compile yi i spent a week in an asylum
19:52:18 <jfredett> thats all i have, apparently
19:52:20 <gwern> jfredett: make more funnies
19:52:23 <jfredett> lol
19:52:36 <Tac-Tics> It's really not as funny as it is tragic
19:52:41 <jfredett> Monad Transformers, Endofunctors in disguise?
19:53:09 <oerjan> er monads are endofunctors all by themselves
19:53:16 <gwern> Tac-Tics: as the saying goes - laugh or cry, laugh or cry...
19:53:17 <jfredett> there once was a man from nantucket?
19:53:26 <BMeph> ...Automorphisms who destroy the Evil Forces of unsafePerformIO! ;p
19:53:39 <jfredett> :)
19:54:14 * gwern wonders when someone will come up with Deceptimonads - combating the Automorphisms in mechanical transformations/combat
19:55:11 <Tac-Tics> Automorphisms wage their battle to destroy the evil forces of the Deceptimonads~ The Transformers~ more than >>='s the eye! The Transformers
19:55:26 <gwern> Tac-Tics: that's the spirit!
19:56:06 <nolrai> :t liftM2
19:56:09 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:56:24 <jfredett> lol
19:56:27 <Tac-Tics> I think the Haskell community needs more artists to take ideas that come about in this channel, such as that one, draw a picture of it, and then watch the rating on Reddit soar
19:57:58 <nolrai> @pl \f a -> f a a
19:57:59 <lambdabot> join
19:58:15 * BMeph ponders giving the name "meet" to the reversed-bind...
19:58:23 <nelhage> :t join
19:58:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:58:58 <nolrai> > join (+) 2
19:59:00 <lambdabot>  4
19:59:16 <Tac-Tics> :t join (+) 2
19:59:18 <lambdabot> forall a. (Num a) => a
19:59:26 * gwern gasps! did... did it really just compile and install from the tarball?
19:59:32 <jfredett> !!!!!!!!!!!!!1
19:59:32 <Tac-Tics> lols
19:59:41 <jfredett> gwern did it for the lulz.
19:59:54 <nolrai> is "join (liftM2 (:)) inquire" or "liftM2 (:) inquire inquire" better?
20:00:06 <jfredett> i like the latter
20:00:16 <gwern> no, surely it was just someone tapping, tapping at my front door as I ponderied upon this midnight dreary over many a quaint and curious volume of forgotten code...
20:00:32 <monochrom> One Monad to return them all. One Monad to fmap them. One Monad to join them all and in the pureness bind them.
20:00:52 <Tac-Tics> you're all a bunch of weirdos and I love this channel
20:00:58 <gwern> (but - *is* there surcease in IO, surcease for my lost referntial transparency?)
20:01:08 <monochrom> (In some copies "bind" is replaced by ">>=".)
20:01:11 <gwern> (quoth the unsafeRaven - Never more!)
20:01:35 <jfredett> ...
20:01:42 <jfredett> you people are freaking nuts
20:01:43 <jfredett> i love it
20:02:28 <oerjan> nolrai: the former won't work because inquire is used at two different types
20:02:48 <gwern> still, recording all my changes is going to be painful. I must have like 20 patches worth of changes
20:02:50 <hpaste>  Saizan annotated "(no title)" with "memoized, but can be made prettier" at http://hpaste.org/5231#a1
20:03:13 <nolrai> oerjan: thanks!
20:03:40 <Tac-Tics> thanks Saizan
20:06:38 <nelhage> Hey #haskell. What'd be a interesting and hopefully useful project for someone looking to get some more experience writing nontrivial haskell?
20:06:58 <BMeph> gwern: "Embrace Change" ;)
20:07:19 <Riastradh> Write a Scheme compiler in Haskell, or vice versa!
20:07:38 <nelhage> Oh, hi, Riastradh :)
20:07:45 <Saizan> nelhage: hacking on cabal! start with simple tasks from the bugtracker
20:07:46 <Riastradh> Hi.
20:08:03 <nelhage> @where cabal
20:08:03 <lambdabot> http://www.haskell.org/cabal
20:08:55 <cjb> nelhage: Evenin'.
20:09:14 <nelhage> Have you jumped on the haskell bandwagon as well? :)
20:09:32 <Riastradh> Who, me or cjb?
20:09:34 <cjb> yeah :) the IAP SIPB talks pushed me over the edge.
20:09:49 <gwern> nelhage: write a rogue-like game in haskell
20:09:55 <nelhage> cjb. I assume you're still a scheme diehard, Riastradh
20:10:02 <Riastradh> I ride no bandwagons.
20:10:10 <gwern> BMeph: sure, sure, but it's bear-hugging me! I can't breath!
20:10:30 <gwern> 'Real Programmers don't comment their code. If it was hard to write, it should be hard to understand.'
20:10:34 <nolrai> :t Untill
20:10:34 <lambdabot> Not in scope: data constructor `Untill'
20:10:38 <nolrai> :t untill
20:10:39 <lambdabot> Not in scope: `untill'
20:10:46 <Maddas> gwern: That reminds me of the X11 mentality, 'If it was hard to write, it should be hard to use.'
20:10:47 <cjb> nolrai: one l
20:11:21 <cjb> :t until
20:11:22 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
20:11:57 <gwern> Maddas: no no, X11 isn't hard to use, it's very flexible! 'mechanism, not policy' dudes
20:12:11 <Maddas> gwern: :-)
20:12:12 <monochrom> If a program is hard to come up with, I give a derivation in the comments.
20:13:07 <oerjan> > until odd (`div` 2) 248
20:13:09 <lambdabot>  31
20:16:10 <nolrai> I want type (a -> Bool) -> m a -> m a.
20:16:50 <shapr> yarr!
20:16:55 <istarex> filterM?
20:17:01 <Maddas> @yarr
20:17:02 <lambdabot> Swab the deck!
20:17:15 <jfredett> avast, y'knaves
20:17:39 <nolrai> istarex: but like until.
20:17:48 <jfredett> i guess it wasn't a dud, Guest_920...
20:19:19 <BMeph> :t filterM
20:19:20 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
20:19:42 <oerjan> filterM is probably not right
20:19:43 <nolrai> i.e. "u p m = do {a <- m; if p a then return a else u p m}"  is that called any thing?
20:20:12 <oerjan> nah
20:20:33 <BMeph> :t mfilter --would this be the right name for it?
20:20:34 <nelhage> Why do you want that, nolrai?
20:20:37 <lambdabot> Not in scope: `mfilter'
20:20:49 <oerjan> BMeph: it does not exist
20:21:03 <oerjan> there is a lack of imperative loop functions
20:21:03 <istarex> :t dropM :-)
20:21:03 <lambdabot> parse error on input `)'
20:21:08 <istarex> :t dropM
20:21:09 <lambdabot> Not in scope: `dropM'
20:21:09 <EvilTerran> it'd be more like mIterateUntil
20:21:14 <BMeph> oerjan: Well, yeah, but maybe it should... :)
20:21:27 <EvilTerran> er, muntil?
20:21:33 <EvilTerran> ?type until
20:21:34 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
20:21:50 <EvilTerran> ?type let u p m = do {a <- m; if p a then return a else u p m} in u
20:21:51 <lambdabot> forall t (t1 :: * -> *). (Monad t1) => (t -> Bool) -> t1 t -> t1 t
20:21:54 <nelhage> @hoogle while
20:21:56 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
20:21:56 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
20:21:56 <lambdabot> Data.List.takeWhile :: (a -> Bool) -> [a] -> [a]
20:22:03 <EvilTerran> actually, it'd be untilM, wouldn't it?
20:22:32 <nelhage> I thought there was a whileM somewhere, but I may be mistaken
20:22:45 <EvilTerran> well, kinda. not passing the new result in to the recursive call is a bit odd.
20:23:05 <Saizan> untilM :: Monad m => (a -> m Bool) -> (a -> m a) -> a -> m a?
20:23:10 <EvilTerran> ?src until
20:23:10 <lambdabot> until p f x | p x       = x
20:23:10 <lambdabot>             | otherwise = until p f (f x)
20:23:57 <nolrai> yeah passing it in would be more consistant.
20:24:23 <EvilTerran> untilM p f x = do px <- p x; if px then return x else untilM p f =<< f x
20:25:01 <cjb> whileM c b = do { x <- c; when x (b >> whileM c b) } # http://haskell.org/pipermail/haskell-cafe/2007-February/022003.html
20:25:02 <lambdabot> http://tinyurl.com/2j8gjj
20:25:20 <nelhage> #, cjb? :)
20:25:35 <nolrai> EvilTerran: exactly! Although how often would the passed in value be used?
20:26:45 <cjb> nelhage: habit :)
20:29:55 <gwern> hm. is there anyway to parallelize ghc/cabal compilations? (besides simply running multiple processes obviously)
20:31:21 <gwern> -_- yi now segfaults on startup. the hell?
20:31:28 <Tac-Tics> =-[
20:31:40 <cjb> I checked out HEAD yesterday and it worked.  But I guess you've made lots of changes today.  :)
20:31:55 <gwern> cjb: yes. yes, that would be a safe guess
20:37:24 * Tac-Tics feels that if if-then-else in haskell is going to be so quirky, it should at least support an arbitrary number of elseif clauses
20:38:16 <gwern> Tac-Tics: that's what guards are for silly
20:38:22 <jfredett> Tac-Tics: as far as I'm concerned, if-then-else stuff is for one-off if statements, if you need something more substantial, you use the fn x | blah | blah | blah |otherwise business
20:38:27 <jfredett> guards or w/e
20:38:33 <gwern> guards desugar to nested ifs anyway, iirc
20:38:35 <oerjan> > if False then 1 else if False then 2 else if False then 3 else 4 -- it doesn't?
20:38:38 <lambdabot>  4
20:38:40 <gwern> or you could maybe use case expressions?
20:38:41 <nolrai> @pl \x -> (x == 'Y') || ( x == 'N')
20:38:42 <lambdabot> liftM2 (||) ('Y' ==) ('N' ==)
20:38:48 <Tac-Tics> case () of _ | .. | .. | .. looks silly
20:39:34 <Tac-Tics> guards are very lovely and nice, but they don't fit as naturally in my case, I don't think
20:39:47 <oerjan> > (`elem` "YN") 'Y'
20:39:48 <lambdabot>  True
20:39:58 <Tac-Tics> so clearly, since I'm working in Haskell, I need to change my case =-)
20:40:08 <nolrai> thanks
20:43:43 <Tac-Tics> bah, there are so many little things in Haskell syntax I wish would be a bit cleaner /consistent
20:43:59 * Tac-Tics fights the syntax and loses
20:44:05 <Twey> Which?
20:44:26 <Tac-Tics> case uses -> instead of = after guards
20:44:31 <Twey> Ah
20:44:32 * gwern rejoices. the segfault had an easy fix!
20:44:41 <Tac-Tics> more generally, it always uses ->, but it should be one way or another
20:44:49 <Twey> gwern: Segfaults?  In Haskell?  :-(
20:44:51 <gwern> thank god my guess was right - that segfault came with *no* indication what the heck was causing it
20:45:07 <Twey> What was causing it?
20:45:21 <Twey> Tac-Tics, mmmm
20:45:28 <Tac-Tics> also, it took me a long long time to get used to "case ___ of" instead of Ocaml's "match ____ with"..... I don't know much at all about Ocaml, but even though they're french, it's better english
20:45:31 <gwern> Twey: I know, bizarre right?
20:45:34 <Twey> Tac-Tics: I think it would be semantically wrong to use =
20:45:44 <Twey> gwern, aye
20:45:56 <gwern> Twey: it came from a use of the GHC API, and not passing needed library, afail
20:45:57 <Tac-Tics> twey: It bugs me to see things like this:
20:45:57 <Tac-Tics> @let foo = let bar = foo in bar
20:45:57 <gwern> *afaik
20:45:59 <lambdabot> Defined.
20:46:06 <Twey> Tac-Tics: case..of is traditional
20:46:08 <Tac-Tics> so many ='s
20:46:16 <Twey> gwern: Hm, mmk
20:46:31 <Tac-Tics> From what? Lisp? Or miranda?
20:46:37 <Twey> Tac-Tics: I guess we could use -> instead of =, but then it would look like Prolog :-P
20:46:42 <Twey> Err
20:46:59 <Tac-Tics> I'm going to write my own Lazy Pure Functional Language
20:47:00 * Twey isn't entirely sure where it originated, but it's used in a few other languages.
20:47:03 * Twey googles.
20:47:04 <Tac-Tics> With stripers and blackjack
20:47:10 <Tac-Tics> In fact, forget the TCO!
20:47:10 <Twey> Hahaha
20:48:13 <Tac-Tics> the arrow makes more sense. Sure, both sides are truly equal in haskell (barring whatever the hell gwern is doing right now), but the evaluation is definitely a directed action
20:48:14 <gwern> Tac-Tics: actually... the NixOS linux distribution did just that
20:48:26 <Cin> did somebody just say weeaboo? because i think i just heard somebody say weeaboo
20:48:27 <gwern> (apparently the guy who wrote it wanted a maximally lazy language or something)
20:48:44 <Tac-Tics> maximally lazy?
20:48:45 <Twey> Blah
20:48:56 <Tac-Tics> maximally lazy would be just doing your project in Java
20:49:00 <Twey> I can't find who originally implemented case..of
20:49:07 <Twey> Tac-Tics, don't be ridiculous
20:49:11 <Twey> That's much more work
20:49:16 <Tac-Tics> heh
20:49:20 <Tac-Tics> umm, ok python
20:49:26 <Twey> Maximally lazy would be just doing your project in Python.
20:49:27 <Twey> Heh.
20:49:31 <gwern> Tac-Tics: that was joke, yes?
20:49:39 <oerjan> Twey: it was in pascal, at least
20:49:47 <Twey> oerjan, aye
20:49:57 <oerjan> perhaps algol?
20:50:06 <Tac-Tics> My two favorite languages are Haskell and Python, and in terms of difficulty, they ARE the end points of the spectrum
20:50:20 <Tac-Tics> gwern: yes, that was a joke
20:50:29 <dash> Tac-Tics: i dunno, the stuff I find difficult to do in python would also be difficult in haskell :)
20:50:32 <cjb> Tac-Tics: Python isn't.  We're giving it to kids on the OLPC.
20:50:36 * BMeph orders some NixOS with some Nick sauce...
20:50:52 <Tac-Tics> cjb: You're also giving it to me on the OLCP.... if it ever arrives in my mailbox
20:51:03 <cjb> Tac-Tics: oh :)
20:51:09 <cjb> Tac-Tics: when did you order?
20:51:11 <gwern> yay! I can install and run from a tarball generated by sdist! and with no warnings or problems, and in a brief editing session it seems to work!
20:51:14 <Tac-Tics> I'm so excited for it
20:51:17 <dash> hey, functional programming geniuses, i've got a data structures question
20:51:21 <Tac-Tics> On the second to last day in December
20:51:26 <gwern> huzzah! soon wewill be able to cabal install yi!
20:51:34 <gwern> oh frabjous day
20:51:34 <jfredett> hooray!
20:52:13 <Twey> oerjan, nah, Algol used "case..in"
20:52:17 <cjb> Tac-Tics: ah, I ordered one then too.. I'm afraid it looks like it will take a while.
20:52:29 <Twey> Well, same basic grammar I suppose
20:52:37 <davidL> is there a zlib implementation for strict bytestrings?
20:52:49 <Tac-Tics> It was the biggest impulse buy I've ever made
20:53:12 <cjb> Tac-Tics: We got pounded with orders, which I guess is good and bad.  :)  It'll take a while to have enough laptops built for the orders at the end.
20:53:20 <Tac-Tics> I was like 2 days left? effectively 200$..... so cute! Do some research.... video of a guy playing DOOM on it? Python??? I'm sold!
20:53:27 <Twey> Hahaha
20:53:35 <oerjan> Twey: i didn't think you meant the exact syntax
20:53:42 <cjb> heh.  well, I think it lives up to the hype :)
20:53:50 <cjb> we got the view source key working recently
20:53:58 <gwern> cjb: you are involved with olpc?
20:53:59 <Tac-Tics> no GCC, though, so it's probably a pain to install stuff
20:54:06 <Twey> oerjan, Tac-Tics was complaining than "case X of Y" was bad (English) grammar
20:54:11 <Tac-Tics> cjb: what is the view source key about?
20:54:12 <Twey> that**
20:54:35 <cjb> so for most of the inbuilt "activities", you can hit view source; you see the python source in a gtksourceview, and you can build activities with your modified code straight away
20:54:44 <Tac-Tics> that's so cool
20:54:50 <cjb> we're even working on looking at reloading python classes in the middle of execution
20:54:53 <Tac-Tics> It reminds me of stories I've heard about lisp machines
20:54:54 <cjb> Guido's interested in that
20:54:55 <gwern> sounds tricky as hell to get right
20:55:04 <cjb> yes!  we're trying to build a python machine in the style of lisp machines.
20:55:09 <gwern> Tac-Tics: no kidding! I think that's where the idea comes from, that or Squeak
20:55:11 <cjb> gwern: yes, been working at OLPC for a year and a half.
20:55:24 <dash> cjb: Twisted has code for that.
20:55:26 <Tac-Tics> Someone needs to do the same for Haskell
20:55:26 <Twey> gwern, yes, because they do initialisation...
20:55:32 <oerjan> Twey: oh
20:55:33 <Twey> Heh
20:55:33 <gwern> cjb: cool. I take it Haskell will be well supported? :)
20:55:34 <cjb> Tac-Tics: "yum install gcc" works out of the box, so it's not too difficult.
20:55:34 <Tac-Tics> A fully lazy machine would be neat
20:55:36 <Twey> A Haskell machine?
20:55:39 <cjb> I guess Yi has similar code?
20:55:41 <Tac-Tics> really? cool
20:55:47 <dash> cjb: Python's semantics make it difficult to do well, unfortunately.
20:55:54 <cjb> yup.  we're binary compatible with Fedora 7 packages.
20:55:55 <gwern> cjb: mm. I'm not really sure.
20:56:01 * Twey nods.
20:56:03 <cjb> so you can just grab them out of the Fedora repo
20:56:08 <Twey> Nice
20:56:09 <cjb> dash: Ah, I don't know enough about it.
20:56:11 <Tac-Tics> cjb: yeah, a machine who's OS and all its major software is mostly haskell
20:56:14 <gwern> yi's pretty compelx! I've been hacking on it for weeks, and I'm still not sure what it can and cannot do
20:56:28 <cjb> dash: Are you in Boston, by any chance?
20:56:30 <gwern> Tac-Tics: have you read the House and sel4 papers on writing OSs in Haskell?
20:56:43 <dash> cjb: No. I know some people who are, though. :)
20:57:01 <cjb> dash: I'd love to hold a meetup to chat about some of these use cases in Python
20:57:03 <dash> (who work on twisted, and who have been round this channel in the past...)
20:57:12 <Tac-Tics> I've heard of them, and I was planning on reading them, but I didn't take the time (mostly because there's not a lot of people shouting loudly about them, like they do about xmonad, darcs, and cabal)
20:57:53 <gwern> Tac-Tics: simple age. they are the old hotnesses, if you follow, while xmonad darcs cabal are happening *now*
20:57:58 <gwern> still worth reading
20:58:11 <Tac-Tics> Maybe I will
20:58:20 <dash> so, datastructure. I need to implement an immutable map/dictionary type whose iteration order is insertion order. it's OK if it does internal mutation, I just need a functional contract. Anybody got advice for me?
20:58:31 <Tac-Tics> plus, a haskell OS, while cool as hell, is pretty impractical in anything but the longest of long terms
20:58:37 <dash> My first idea was just a hashtable with a list for ordering. But that seems so tame :)
20:58:52 <Tac-Tics> and even by the time functional kernels are the standard, Haskell will be legacy, most likely
20:59:23 <Twey> Hahaha: "The main short term goal is to maximize Yi's Fun Factor.  This includes: - improve hackability (and therefore architecture)  - add cool features"
20:59:23 <cjb> I think Haskell might be flexible enough to not die anytime soon
20:59:31 <cjb> ie. in the next five years
20:59:52 <cjb> it certainly only seems to be getting more popular at the moment
20:59:56 <Tac-Tics> cjb: that's my point... it'll be *that* long before we cleanse our souls of C
20:59:56 <dash> Tac-Tics: when more linux distributions ship with hardware virtualization, the barrier to entry for research OSes will be lower, I bet
21:00:05 <gwern> depends on the standardization process, imo. what killed common lisp was really the lack of followup
21:00:10 <cjb> Tac-Tics: people will have to stop paying me to hack C code, for one thing :)
21:00:17 <Tac-Tics> dash: that's an interesting thought
21:00:30 <dash> gwern: also, there was no open source community then.
21:00:37 <gwern> if haskell' goes through, that will definitely help, and then haskell'' can continue to follow the latest stuff
21:00:56 <Tac-Tics> cjb: stop hurting the cause!
21:00:56 <Tac-Tics> hehe
21:01:01 <gwern> dash: sure there was. nethack, GNU, various academic stuff, etc. it's just that it wasn't very large
21:01:22 <dash> gwern: hmm, yes
21:01:51 <clanehin> dash: have you read the book "Hackers"?
21:01:51 <dash> gwern: the main counterpoint there is that the FSF has never succeeded in publishing any original software that anyone has wanted to use
21:01:54 <Tac-Tics> haskell's syntax lends itself to weird line layouts. I try to keep to 80 cols, but it really resists it!
21:01:54 <dash> clanehin: yes.
21:02:06 <shapr> mmm Haskell
21:02:09 <dash> hi shapr
21:02:14 <shapr> hi dash
21:02:20 <shapr> How come I never got to meet you when I lived in Birmingham?
21:02:24 <wy> I found it's not obvious how to write a NFA simulator in Haskell  like that of the page http://swtch.com/~rsc/regexp/regexp1.html.
21:02:25 <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast
21:02:29 <dash> shapr: dunno, what happened? :)
21:02:40 <gwern> dash: I suspect of their hundreds of packages, there's plenty of innovation. but innovative stuff was never FSF's goal
21:02:52 <shapr> dash: Not sure.. I got to meet radix and exarkun recently though.
21:03:05 <dash> gwern: all the good ones are copies of previous designs
21:03:16 <dash> gwern: which is important, and I'm not denying that
21:03:29 <wy> It uses lists of dangling C pointers in a list, and patch them later.
21:04:00 <wy> I haven't figured out how to achieve the same efficiency in Haskell. Maybe we need to use monads?
21:05:01 <dash> shapr: so I'm looking for functional datastructure advice. #functionaldatastructures was empty so I came here.
21:05:33 <shapr> dash: Read Okasaki and Rabhi&Lapalme already?
21:05:45 <dash> shapr: Okasaki yes, didn't know about the other one.
21:06:12 <shapr> There are also several functional pearls and other papers that detail specific FP datastructures.
21:06:22 <Svrog> barrier to entry for research os-s has always been quite low
21:06:38 <dash> Svrog: having to reboot is a barrier ;)
21:06:43 <gwern> the pearls series is very nice. I always wonder if there's any formal process for quality assurance for them
21:06:46 <Svrog> who said anything about rebooting?
21:06:49 <dash> and having to run in emulation makes use painful
21:07:09 <dash> shapr: in particular i'm looking for an ordered map implementation of some variety.
21:07:11 <Svrog> there are plenty of open source emulators for all kinds of architectures
21:07:24 <Svrog> and while they're quite slow for actual apps, for os development they're alright
21:07:47 <dash> Svrog: yes but the goal of software development is software use :)
21:08:10 <Svrog> yeah but you did mention research os-s :P
21:08:28 <Svrog> a bigger problem for os-s that people would actually use is device drivers
21:08:34 <cjb> I was pretty shocked to see that Hurd is reasonably usable lately
21:08:36 <wy> I guess the NFA data structure I pointed to just now is the kind of structure that's most nonobvious how to implement functionally
21:08:43 <cjb> which is to say you can run X, emacs22, and so on.
21:08:43 <shapr> dash: I'm too short on sleep and too long on adventure to help out right now, sorry.
21:09:11 <shapr> cjb: Downtown Boston is up near terrifying.
21:09:18 <dash> shapr: okay! i'm not even sure how i'd implement this non-functionally :)
21:09:39 <wy> dash: What's the data structure?
21:10:20 <gwern> cjb: sure, but Hurd is massively piggybacking on a dead-end, Minix. wait to see that functionality on the l4 port, and then be impressed
21:10:26 <Svrog> i think the best option for anyone trying to write a new os currently is to write it on top of an existing one - conceptually a bit like various smalltalk implementations
21:11:16 <dash> wy: a map, where iteration order is the same as insertion order
21:11:24 <cdsmithus> Yikes!  Data.Graph implements '==' incorrectly, it appears.
21:11:25 <wy> Svrog: paravirtualized kernel?
21:11:28 <dash> and probably where element access is as close to O(1) as possible :)
21:11:43 <cjb> gwern: yeah.
21:11:47 <cjb> shapr: how's that?
21:11:55 <Svrog> im not sure what that means, paravirtualized
21:12:11 <wy> dash: I don't quite understand
21:12:26 <dash> wy: i'm implementing a language in the python/javascript/etc vein
21:12:30 <Svrog> but basically just a standalone app that runs under say linux or windows or os x or some other os but has it's own apis, it's own graphical interface, etc
21:12:55 <wy> dash: You mean you want something like an array?
21:13:01 <dash> wy: something like a hashtable
21:13:27 <dash> wy: except, when you iterate over it, the pairs in it are in the ordered they were added.
21:13:29 <wy> dash: So what's iteration order?
21:13:39 <wy> I see
21:14:31 <cdsmithus> dash: So you'd basically need to keep a doubly linked list besides a hashtable, and coordinate insertions and deletions.
21:14:32 <oerjan> dash: do you need to delete elements?
21:15:03 <wy> dash: right. It's not even obvious how to do it in an imperitive language
21:15:04 <dash> cdsmithus: Yeah, that's what I figured...
21:15:35 <wy> dash: The first thing is to think about something else for substitution
21:15:45 <dash> I wish my spec said "in sorted order"... i'd just use a tree... :)
21:15:51 <bos> @hoogle poke
21:15:52 <lambdabot> Foreign.Storable.poke :: Storable a => Ptr a -> a -> IO ()
21:15:52 <lambdabot> Foreign.Storable.pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()
21:15:52 <lambdabot> Foreign.Storable.pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
21:16:11 <oerjan> dash: then Data.Map would have had all you need
21:16:15 <dash> yep
21:16:38 <wy> dash: a tree and a list?
21:17:23 <dash> yeah, either a tree or a hashtable
21:17:26 <oerjan> dash: possibly a Map + a Seq?
21:17:28 <wy> dash: or a hashtable and a list. but I heard hashtables have a bad name in FP
21:17:32 <cdsmithus> So the problem is finding a functional equivalent to modifying or deleting the node in the middle of a linked list?
21:17:44 <oerjan> a Seq would be easier to delete a specific position
21:17:49 <oerjan> (than a list)
21:18:00 <dash> wy: well, this'd all be monadic anyway, I just need a functional interface to it... :)
21:18:03 <dash> anyhow
21:18:22 <dash> thanks, I just wanted to make sure I didn't miss something obvious. sounds like I didn't :)
21:20:51 <wy> Hey, any ideas on my data structure question? http://swtch.com/~rsc/regexp/regexp1.html. Basically I'm constructing an NFA by parsing a regular expression, but the part about fixing the transition pointers is not as nice as the C implementation.
21:20:52 <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast
21:22:52 <cdsmithus> I'm quite shocked by this.  Apparently (\g -> buildG (1,n) (edges g)) is NOT True for n-vertex graphs.  That seems broken to me.  Is this an unreasonable expectation?
21:30:59 * Twey has wistful thoughts of being a better mathematician.
22:00:38 <gwern> ok! my 22 yi patches have been sent!
22:00:48 <gwern> all you yi hangerons can download and try it out
22:02:10 <cjb> gwern: congrats :)
22:03:42 <hpaste>  bos pasted "fast character set membership testing" at http://hpaste.org/5232
22:09:56 <hexpuem> are the writes to Control.Concurrent.Chan channels atomic?
22:22:58 <dmwit> hexpuem: I think the point of concurrent channels is that they're atomic.
22:23:18 <Tac-Tics> @src (a -> a) -> (a, b) -> (a, b)
22:23:18 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
22:23:20 <Tac-Tics> err
22:23:29 <Tac-Tics> @hoogle (a -> a) -> (a, b) -> (a, b)
22:23:30 <lambdabot> No matches, try a more general search
22:23:38 <dmwit> :t first
22:23:40 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
22:23:44 <Tac-Tics> :t second
22:23:45 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
22:25:14 <hexpuem> yea was just making sure before i rewrote all this stuff to use it haha
22:30:38 <dmwit> Quiet night, not much to distract me from my Java programming. =/
22:34:09 <Tac-Tics> > cycle "make NOISE!!!!!!one1"
22:34:10 <lambdabot>  "make NOISE!!!!!!one1make NOISE!!!!!!one1make NOISE!!!!!!one1make NOISE!!!!!...
22:34:21 <andyjgill> Nothing wrong with Java.
22:34:34 <gwern> andyjgill: perks you up at night
22:34:38 <dmwit> There are a lot of things wrong with Java.
22:34:41 * gwern likes tea better tho, but that's just me
22:35:02 <dmwit> I've only been using it for two weeks, and I already know enough to dislike it.
22:35:07 <gwern> dmwit: the natives of Java would be irked to hear you say that
22:35:17 <dmwit> heh
22:42:26 <lispy> > cycle "Java..."
22:42:27 <lambdabot>  "Java...Java...Java...Java...Java...Java...Java...Java...Java...Java...Java....
22:43:08 <lispy> I heard that when they changed the name from Oak to Java the other name they were heavily considering was Verbose
22:43:19 <ivanm> heh
22:44:00 <dmwit> Verbosity... yes.  Luckily, I have a good editor. =)
22:44:13 <dmwit> :abbr++
22:44:26 <mauke> also, tab completion
22:44:32 <oerjan> @karma :abbr
22:44:32 <lambdabot> :abbr has a karma of 1
22:45:33 <lispy> one of the things that bothers me about Java is that it's typesafe but requires all this reflection and casts to/from object.  Seems like it's not that safe after all.
22:45:48 <lispy> generics have helped, but it seems they aren't fully featured.
22:46:12 <dmwit> No, the Generics actually throw away type information at runtime.
22:46:23 <Twey> Ych
22:46:38 <dmwit> There are actually cases where you simply *cannot* use Generics to guarantee type-safety. =(
23:03:28 <sjanssen> @yow
23:03:29 <lambdabot> Toes, knees, NIPPLES.  Toes, knees, nipples, KNUCKLES ...
23:03:29 <lambdabot> Nipples, dimples, knuckles, NICKLES, wrinkles, pimples!!
23:14:52 <Twey> o.@
23:14:54 <Twey> @.o
23:14:54 <lambdabot> Not enough arguments to @.
23:14:57 <Twey> O.O
23:17:11 <lispy> http://augustss.blogspot.com/2007/06/representing-dsl-expressions-in-haskell.html at one point the author says, GADTs is really the way to go, but it has the disadvantage of not being standard Haskell. It can also get somewhat cumbersome when we have variables; the evaluator now needs a typed environment."  What does 'typed environment' mean?
23:17:12 <lambdabot> Title: Things that amuse me, http://tinyurl.com/35u5ec
23:18:13 <lispy> Is the author referring to adding variables to the evaluators language constructs and then saying that you need to have types for the variables?
23:18:45 <ac> would it make sense to have a function like "getLength :: Get a -> Int"?
23:19:09 <lispy> what is Get a?
23:19:33 <ac> er, I meant "Put a"
23:19:37 <ac> from the binary package
23:19:51 <lispy> sorry, i'm unfamiliar with binary
23:21:43 <ac> without it I have to runPut, then length, then putLazyByteString
23:45:18 <hpaste>  Yoshi pasted "Test Function - foo" at http://hpaste.org/5233
23:56:55 <hpaste>  (anonymous) annotated "Test Function - foo" with "(no title)" at http://hpaste.org/5233#a1
23:57:07 <lispy> yoshi: that should fix it
23:57:50 <lispy> there are also much simpler ways to write foo
23:59:42 <yoshi> lispy: thanks so much.
23:59:52 <yoshi> lispy: how so?
