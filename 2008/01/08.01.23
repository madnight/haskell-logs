00:02:53 <dmwit> geezusfreeek: Really?  I would imagine newtype IO a = IO (State RealWorld# a).
00:05:04 <olsner> dmwit: so, translated, it'd become something like this? newtype IO a = IO (StateWizardry RealWorld) -> WizardTuple (StateWizardry RealWorld) a
00:05:09 <sjanssen> well, the defn. has just inlined the State newtype
00:19:19 <ac> Wow, interesting conversation while I was gone.
00:20:10 <ac> someone mentioned it would be possible to annotate a program such that each element of a list would be evaluated in parallel. How could you do this when you need one processor to traverse through the cons cells?
00:20:21 <glguy> > let !_ = undefined in ()
00:20:22 <lambdabot>  Parse error at "!_" (column 5)
00:20:28 <glguy> silly Haskell98 parser
00:20:55 <ivanm> ac: there's a difference between evaluating the list and evaluating the elements in the list
00:21:06 <ivanm> I presume they meant evaluating the cells in parallel
00:21:21 <ivanm> after the actual list stucture has already been evaluated
00:21:45 <ac> I figured so
00:22:37 <sjanssen> glguy: undefined, if you're curious
00:23:14 <glguy> sjanssen: I know, its just a use I hadn't considered before
00:23:16 <glguy> "!_"
00:24:51 <nominolo> @seen bringert
00:24:51 <lambdabot> bringert is in #ghc and #haskell. I don't know when bringert last spoke.
00:24:53 <sjanssen> I've seen some bizarre uses
00:25:07 <sjanssen> eg. let !_ = trace "foo" ()
00:30:17 <kaol> what's up with those HList's examples? They use all sorts of modules that are hidden or even not installed.
00:32:22 <kaol> eh... I suppose I'll just leave those uninstalled for the Debian package.
00:33:20 <nominolo> kaol: probably outdated .cabal file
00:33:33 <kaol> or outdated examples
00:34:01 <kaol> and trying to run haddock on HList just gives out a parse error
00:35:16 <glguy> anyone heard of "fronz"?
00:35:25 <glguy> err
00:35:26 <glguy> frons
00:35:51 <glguy> a non-deterministic choice version of cons
00:37:35 <nominolo> kaol: i usually copy the files i need
00:37:39 <shag> what is the size of a single Char?
00:37:51 <nominolo> shag: 32 or 64 bits
00:38:11 <shag> i'm on amd64 so i suppose its 64bit for me?
00:38:47 <nominolo> shag: yep.  but i don't think values outside unicode make much sense
00:38:51 <opqdonut> it's a bit less, to leave space for tagging
00:38:56 <opqdonut> iirc
00:39:00 <shag> ok, thansk
00:39:06 <opqdonut> 62 bits or so
00:39:23 <nominolo> opqdonut: i think only pointers are tagged
00:39:42 <opqdonut> ah, i thought it was used for unboxed ints too
00:39:43 <kaol> nominolo: that won't do me much good, if I'm packaging HList for Debian and want to include some examples of using the HList module... The examples that come with HList don't use the HList module, that much I can tell.
00:41:11 <nominolo> kaol: hm.  also, HList doesn't have its own namespace
00:41:28 <nominolo> kaol: it should be Data.HList, i'd say
00:42:05 <nominolo> opqdonut: it's used for constructors, but i don't think it's done for ints.
00:42:38 <opqdonut> ok ok
00:42:38 <nominolo> opqdonut: you don't need tagging of values in Haskell because it's statically typed
00:43:03 <opqdonut> well, one there could be some sort of adaptive unboxing or so
00:43:07 <opqdonut> but yeah i see your point
00:43:24 <kaol> perhaps I should ask to have HList removed from Debian for now... I only packaged it in the first place since it seemed to become a dependency for HAppS at one point.
00:43:39 <nominolo> opqdonut: right.  i think O'Caml does just that
00:43:52 <opqdonut> :)
00:44:41 <nominolo> kaol: you could ask the authors if they'd accept patches.  but I think proper packaging will require some effort
00:45:30 <ac> @let (;) = flip (.)
00:45:30 <lambdabot>  Parse error
00:45:54 <nominolo> @src (>>>)
00:45:54 <lambdabot> Source not found. Sorry.
00:46:05 <nominolo> @src Control.Applicative.(>>>)
00:46:06 <lambdabot> Source not found. You speak an infinite deal of nothing
00:46:56 <nominolo> ac: ; is a special character.  >>> does what you want
00:46:59 <opqdonut> @src (>>>) (->)
00:47:00 <lambdabot> Source not found. You untyped fool!
00:47:14 <ac> nominolo: that's a monstrous operator
00:47:22 <nominolo> ac: true
00:47:44 <nominolo> ac: in emacs you can assign certain character sequences a unicode character
00:47:55 <ac> nominolo: that would be rather nifty actually
00:48:01 <ac> nominolo: can you do it in vim?
00:48:23 <nominolo> ac: probably, but i don't use vim a lot
00:48:27 * ac would be pleased with himself if his Haskell code looked like a Tex document
00:48:49 <nominolo> ac: that's actually my goal for Yi (one day)
00:49:01 <ac> nice. I've always wanted an AST level code editor
00:49:15 <ac> I'm not sure how practical it would be, but I've always thought it would be cool
00:49:22 <nominolo> ac: me too.  i so miss it from lisp
00:49:44 <ac> yeah, didn't somebody write something like that for drscheme rather recently?
00:50:00 <nominolo> yes, with vim-style interface
00:50:17 <ac> I wanted to try that out, but I never got around to it. I started with Haskell instead
00:50:30 <ac> Are you really aiming for that with yi? I thought dons was the yi guy
00:50:45 <nominolo> ac: i'm not the yi-maintainer
00:51:07 <nominolo> but i'm contributing a little once in a while
00:51:26 <nominolo> ac: dons no longer works on yi
00:51:28 <ac> some day when I can actually call myself a Haskell programmer I'll try to contribute a little to yi
00:52:05 <nominolo> ac: how long will that be? ;)
00:52:18 <ac> hmmm... probably a couple more months
00:52:25 <nominolo> ac: in my experience the best way to learn is to do something serious with it
00:52:36 <ac> nominolo: right now I'm working on an implementation of the PNG spec
00:52:46 <ac> nominolo: pretty simple binary parsing thing
00:52:48 <nominolo> ac: i wrote a compiler in haskell without understanding monads
00:53:09 <ac> nominolo: I'm using the binary package, which of course uses Get and Put monads liberally
00:53:19 <nominolo> ac: yeah, that's a good start
00:53:36 <ac> nominolo: my last project was a boggle (if you've played the game) solver
00:53:41 <opqdonut> :)
00:53:43 <opqdonut> nice
00:54:07 <ac> It parses a normal sized dictionary and solves a board in about ... a second
00:54:37 <nominolo> ac: are you using a trie?
00:54:56 <ac> nominolo: of course. A tree of "Map Char Tree"
00:54:57 <opqdonut> does it build some sort of "index" of the board or are you just going through it combinatorically
00:55:12 <ac> opqdonut: the latter
00:55:32 <ac> opqdonut: the majority of the time I believe is taken by building the word tree, but I haven't bothered to test that. It works good enough for me ;)
00:55:47 <opqdonut> yeah sure it works, but does it scale?-)
00:55:53 <ac> lol
00:55:53 <opqdonut> to say 1000x1000
00:55:58 <nominolo> ac: good chance to try out ghc's profiler ;)
00:56:00 <ac> that is an interesting question
00:56:03 <opqdonut> yep
00:56:16 <ac> I hpasted the code a while back...
00:56:38 <opqdonut> i'd say building a trie and then going through it, saving intermediate results might speed it up a bit
00:57:03 <hpaste>  ac pasted "unboggle.hs" at http://hpaste.org/5179
00:57:15 <opqdonut> so for example finding the words "lol" "loll" "lollll" "lolllllllll" wouldn't duplicate effort
00:57:18 <ac> what's a "trie"? I've heard that word a lot recently
00:57:29 <opqdonut> one perhaps could do the same with a prefix and suffix tree
00:57:39 <ac> opqdonut: yeah true. It finds ALL possible ways for each word, and then uniques them afterwords
00:58:07 <ac> the most annoying part was the damn "Qu" tile
00:58:15 <ac> I hacked that in at the end
00:58:20 <opqdonut> :P
00:58:21 <nominolo> ac: trie = prefix tree ---> http://en.wikipedia.org/wiki/Trie
00:58:21 <ac> which explains that uggly lambda expression
00:58:22 <lambdabot> Title: Trie - Wikipedia, the free encyclopedia
00:58:35 <opqdonut> ac: couldn't you just handle it when building the tree?
00:58:41 <opqdonut> say replace qu with Q
00:58:42 <ac> nominolo: ah ok.
00:58:43 <opqdonut> or _
00:58:53 <ac> opqdonut: yeah, I think so
00:59:10 <ac> opqdonut: I guess I could just remove all 'u's after 'q's
00:59:29 <ac> that would have been a lot simpler :-P
01:00:06 <ac> opqdonut: oh, I remember why I didn't do that. Because then I'd have to reinsert them afterwords
01:00:13 <ac> opqdonut: but still, it may be simpler
01:00:26 <dmwit> What do you do for Iraq?
01:00:43 <ac> yeah I'm already doing that
01:01:04 <ac> who said "Iraq"?
01:01:41 <dmwit> Okay, Iraq is a bad example, because it's a proper noun.
01:02:13 <osfameron> Qabbalah?
01:02:28 <dmwit> qabab
01:02:38 <ac> you can't use such words in Boggle, AFAIK
01:02:41 <dmwit> sheqel
01:02:55 <ac> can you really just ignore the 'u' in the "Qu" tile?
01:04:37 * roconnor prefers kabab
01:05:08 * ac is tempted to dig out his rules
01:05:30 <dmwit> Really?  Was it more than just a programming exercise?
01:06:03 <pastorn> @src sequence
01:06:03 <lambdabot> sequence ms = foldr k (return []) ms
01:06:03 <lambdabot>     where
01:06:03 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
01:06:59 <ac> dmwit: of course. I love dragging out my laptop when I can't beat someone
01:07:20 <dmwit> heh
01:10:58 <ac> actually, I've only done that once when people were hounding me to play and I didn't feel like it, but it would be cool if it found words that most people didn't even realize were legal
01:13:22 <opqdonut> ac: well, a nice excercise anyway :)
01:13:59 <ac> oh well, there aren't any words in my dictionary that match "q[^u]"
01:14:11 <opqdonut> + your code is pretty nice
01:14:18 <opqdonut> i especially like nextTo
01:14:22 <ac> thanks ;)
01:15:38 <dmwit> whoa, that code is dense
01:15:57 <ac> (I come from perl)
01:16:01 <opqdonut> :D
01:16:35 <opqdonut> ac: findWords might need some clarification :P
01:17:12 <opqdonut> typesigs for the help functions might be nice also
01:17:51 <ac> yeah, I probably shouldn't have removed all the type signatures. I was making it small :-P
01:18:03 <opqdonut> :P
01:18:06 <dmwit> ac: Ah, you already know what a trie is, you're using one. =)
01:18:22 <ac> dmwit: didn't know it :-/
01:18:43 <dmwit> Meh, names are just for communicating between people.
01:18:53 <dmwit> i.e. totally unimportant ;-)
01:19:37 <ac> I was really pleased how easy it was to fold the dictionary in to the tree
01:20:09 <opqdonut> catamorphisms rule :)
01:20:42 <opqdonut> my favourite example is folding a string through a statemachine into a Bool (accept or not)
01:21:52 <dmwit> gah, combinator overload
01:23:40 <ac> catamorphism?
01:23:52 <dmwit> foldl' > foldl -- pretty much always
01:26:05 <ac> opqdonut: that's pretty cool too. I imagine that's how you'd implement a regex
01:36:11 <Taejo> @pl \l -> (takeWhile p l, dropWhile p l)
01:36:11 <lambdabot> ap ((,) . takeWhile p) (dropWhile p)
01:39:38 <Taejo> @unpl liftM abs f
01:39:39 <lambdabot> liftM abs f
01:45:07 <sizur> @users
01:45:07 <lambdabot> Maximum users seen in #haskell: 454, currently: 394 (86.8%), active: 7 (1.8%)
01:58:13 <Taejo> is there a function I can use to read and write bytes instead of chars?
01:58:31 <dmwit> Look at Data.Word8
01:58:51 <opqdonut> ac: actually that's how i did it :)
01:59:35 <Taejo> dmwit: thanks... now, how do I get them into a file?
02:00:22 <dmwit> Dunno, haven't used it much.
02:00:25 <dmwit> ?hoogle pack
02:00:27 <lambdabot> Data.ByteString.pack :: [Word8] -> ByteString
02:00:27 <lambdabot> Data.ByteString.Char8.pack :: String -> ByteString
02:00:27 <lambdabot> Data.ByteString.Lazy.pack :: [Word8] -> ByteString
02:00:42 <Taejo> thanks
02:02:27 <quicksilver> Taejo: you either bite your tongue and use putStr even though it has the wrong type.
02:02:43 <quicksilver> Taejo: or you use ByteString which has nicer feeling types.
02:02:55 <Taejo> ok
02:09:50 <ac> Taejo: depending on what you're doing you might want to use the binary package from hackage
02:10:04 <ac> Taejo: (specifically if you're reading and writing data structures)
02:10:11 <Taejo> ac: no
02:10:24 <Taejo> I'm generating audio wave files
02:10:46 <dmwit> Hey, neat!
02:10:59 <dmwit> Whatcha making?  (or is it private?)
02:11:00 <ac> Taejo: cool. Yeah, if it's just a big unstructured stream than binary won't be so useful
02:11:12 <ac> Taejo: but for writing the headers of the .wav file, binary would be perfect
02:11:26 <Taejo> ac: sox does that just fine
02:12:12 <Taejo> dmwit: my friend wants to start a hacker's band
02:12:19 <Taejo> and I want him to learn haskell
02:12:34 <Taejo> so I thought I'd hack up a composition library
02:12:47 <dmwit> Most excellent.
02:14:33 <Taejo> also, I just read http://samdanielson.com/2008/1/23/haskell-music and thought I would do it a little differently
02:14:39 <lambdabot> Title: Haskell Music by Sam
02:17:02 <Cale> Haskore is rather cool, but I don't think anyone's touched it in ages.
02:20:43 <Taejo> @pl (\t -> (s1 t) + (s2 t))
02:20:43 <lambdabot> liftM2 (+) s1 s2
02:21:39 <Taejo> is there a tutorial/description of the (->) monad somewhere?
02:21:51 <dmwit> ?src (->) return
02:21:52 <lambdabot> return = const
02:22:08 <dmwit> ?src (->) (>>=)
02:22:09 <lambdabot> f >>= k = \ r -> k (f r) r
02:22:16 <dmwit> ?go meet the monads
02:22:18 <lambdabot> http://www.haskell.org/all_about_monads/html/meet.html
02:22:18 <lambdabot> Title: Meet the Monads
02:22:54 <dmwit> Taejo: In particular, here: http://www.haskell.org/all_about_monads/html/readermonad.html
02:22:55 <lambdabot> Title: The Reader monad
02:23:04 <Taejo> thanks
02:29:58 <ac> Taejo: what's sox?
02:30:21 <mux> a command line audio files manipulation tool
02:31:26 * ac sudo apt-get install sox
02:40:28 <ac> Taejo: if you're dealing with long streams of wav data, you may want to use the lazy ByteString
02:41:04 <ac> Taejo: the lazy and non-lazy ByteStrings use the exact same interface, it's just a matter of choosing which one to import
02:48:49 <ac> meh. I've always wished this would work: $ sort foo > foo # but instead somehow foo is clobbered
02:49:44 <Cale> ac: Because the shell uses lazy IO too :)
02:50:07 <quicksilver> I'm not really sure that's why.
02:50:15 <quicksilver> it's because the shell opens the file, not sort.
02:50:22 <quicksilver> so the files are opened up-front.
02:50:33 <quicksilver> and it opens with O_TRUNC
02:50:38 <quicksilver> in that particular case
02:51:11 <dmwit> zsh has an option like magicredirect or something that is false by default.
02:51:24 <dmwit> I'm sure there's similar things in other shells.
02:52:59 <resiak> there's a tool called "sponge" in the "moreutils" collection, so that `sort foo | sponge foo` does what you'd like `sort foo > foo` to do
02:53:52 <ac> resiak: ah cool. Didn't know about those
02:54:26 <resiak> ac: combine and vipe are also pretty handy
02:54:31 <Baughn> resiak: Does it do it with a temporary file?
02:55:27 <resiak> no, it holds it in memory
02:55:57 <resiak> i'm sure a replacement which doesn't eat your branes on enormous input would be about five lines of ByteStringy functions :)
02:56:57 <quicksilver> mmmm branes
02:57:15 <ivanm> not to mention brains?
02:59:00 <dmwit> ...or one line of shell script
02:59:03 <ac> where can I find mirrors for hardy heron?
02:59:38 <dmwit> TEMP=`mktemp` sort foo > $TEMP; mv $TEMP foo
03:00:09 <ac> oh the joys of shell script. I wrote a web forum in bash once
03:00:42 <ac> in had a CLI back end that supported auto completion on topics and threads
03:00:58 <ac> and it posted a specific thread to the MOTD
03:04:45 <scook0> @type maybe
03:05:04 <quicksilver> @bot
03:05:10 <quicksilver> byebye
03:06:02 <ac> did she crash?
03:06:21 <quicksilver> no, the route vanished.
03:06:32 <quicksilver> [Read error: 113 (No route to host)]
03:08:00 <ac> dmwit: that's a great solution unless the current directory just happens to be a different file system than your destination argument :-P
03:08:28 <quicksilver> ac: s/current directory/mktemp directory/
03:08:31 <dmwit> ac: Sure, sprinkle a bit of basename in there if you really want.
03:08:35 <quicksilver> but yes, that's a potential issue on large file.
03:08:36 <quicksilver> s
03:13:21 <dmwit> Oh, moreutils has a bunch of things I've wanted in the past.
03:13:36 <dmwit> resiak++
03:14:59 <quicksilver> dmwit: I couldn't find a contents page for it. I found a 'todo' list and a 'wontdo' list but not a 'havedone' list...
03:15:22 <Saizan> i've foo :: [A] -> [B] and bar :: B -> IO [A], where bar would be non-strict if not for IO, i need to feed the result of bar to foo, and the head of the result of foo to bar, i can't find a way that doesn't involve unsafeInterleaveIO in bar..
03:15:24 <dmwit> quicksilver: Yeah, you have to install it before you get that. =(
03:16:00 <dmwit> quicksilver: From my installation: isutf8, sponge, ts, vidir, vipe, combine, ifdata, pee, zrun, mispipe
03:16:47 <quicksilver> Saizan: sonds like you need to think a bit about when you do actaully want those IO effects to occur.
03:19:42 <hpaste>  dmwit pasted "man pages for moreutils" at http://hpaste.org/5181
03:20:05 <dmwit> Ooop, that got cut off fairly early.
03:20:09 <Saizan> quicksilver: well, on demand by foo mostly so i can process foo result without accumulating too much input in memory, that would suggest to use unsafeInterleaveIO and be happy with it i guess..
03:20:19 <quicksilver> dmwit: well, it's interesting as far as it goes... thanks :)
03:21:20 <quicksilver> cool stuff
03:21:28 <ac> I propose they name the next Ubuntu release Cathartic Cthulhu
03:21:46 <dmwit> That doesn't start with a 'G' at all!
03:21:59 <ac> are they actually going in the order of the alphabet?
03:22:13 <ac> darn
03:22:22 <dmwit> edgy, feisty, gutsy
03:22:34 <dmwit> I can't tell for sure, but it seems that way.
03:22:44 <dmwit> I'll be interested to see what 'h' will be. =P
03:22:48 <ac> Hardy Heron
03:23:04 <ac> it's sort of released (I think). Can't find any mirrors though
03:23:15 * dmwit (obviously) doesn't keep up with it too much
03:23:58 <tirpen> It's not released, there is an alpha (or maybe beta?) out though.
03:26:27 <dmwit> http://buckwheat.stanford.edu/onoesitshidden/man
03:26:39 <dmwit> I never cease working for you guys. =P
03:33:20 <ac> vidir: crazy
03:33:31 <ac> and vipe!
03:33:57 <ac> just when I thought I knew the unix CLI
03:34:10 <dmwit> Yeah, vipe looks really nice.
03:34:39 <dmwit> I've never wanted it in the past (like some of the others), but it *seems* like I would want it now that I know it exists.
03:34:44 <ac> and pee. I've wanted that a lot
03:34:56 <dmwit> mispipe is the killer app for me
03:38:51 <ac> a lot of times I find rectangular edit to be more convenient than sed/awk/perl
03:39:10 <dmwit> true
03:39:14 <ac> vipe will make that process a lot cleaner
03:39:56 <osfameron> rectangular edit?
03:40:02 <osfameron> what's vipe?
03:40:07 <ac> osfameron: ctrl+v in vim, don't know about emacs
03:40:17 <osfameron> ah, ok, I know ctrl+v
03:40:18 <dmwit> ?go moreutils
03:40:24 <osfameron> well, "know" ish.  never use it :-)
03:40:25 <shapr> @yow !
03:40:28 <shapr> Time for work!
03:40:30 <dmwit> osfameron: moreutils has vipe
03:40:38 <mux> ^V works in most shells too
03:40:48 <mux> useful for sed -e 's/
03:40:50 <mux> oups
03:40:51 <ac> osfameron: it's a program that lets you put an edit session in a series of pipes
03:40:52 <dmwit> osfameron: See my link above for all the moreutils' man pages.
03:40:54 <osfameron> I used to use Word's rectangular edit feature for generating strange text for fantasy languages :-)
03:40:57 <mux> useful for sed -e 's/^V^M//' foo
03:41:11 <RayNbow> roygbiv <-- just wondering, but is this a well-known mnemonic for English speakers?
03:41:18 * RayNbow had to look it up
03:41:19 <dmwit> yes
03:41:28 <ac> RayNbow: roygbiv? Never heard of it
03:41:33 <byorgey> morning shapr!
03:41:42 <shapr> hej!
03:41:51 <RayNbow> ac: it's used in chapter 3 [ http://book.realworldhaskell.org/beta/deftypes.html ]
03:42:15 <byorgey> RayNbow: I think it's pretty common
03:42:19 <RayNbow> it's apparently a mnemonic for the spectral colors Red, Orange, Yellow, Green, Blue, Indigo, Violet
03:42:19 <osfameron> oh, cute.  I haven't had a particular usecase for vipe, but I can imagine it becoming useful at some point
03:42:22 <osfameron> where is moreutils ?
03:42:41 <dmwit> google knows
03:42:51 <ac> osfameron: it's a debian and ubuntu package
03:43:01 <osfameron> ah, ta
03:43:02 <dmwit> That, too.
03:47:29 <Cale> RayNbow: Yes, that's common.
03:47:43 <quicksilver> how is that a mnemonic?
03:47:45 <Cale> (Roy G. Biv)
03:47:45 <quicksilver> it isn't a word.
03:47:50 <quicksilver> Ah.
03:47:53 <quicksilver> That's dire :P
03:48:02 <tirpen> "Read Out Your Good Book In Verse" is a better one.
03:48:21 <dmwit> That's hardly more memorable than the actual colors.
03:48:24 <quicksilver> I can't say i've ever found the rainbow particularly hard to remember :P
03:48:38 <Cale> What if your good book is made up of Prose?
03:48:58 <tirpen> Then your rainbows will sadly end in pink.
03:49:00 <quicksilver> you have to convert it to iambic pentameter as you read.
03:49:05 <Cale> Purple!
03:49:13 <quicksilver> translating to ancient greek at the same time is optional.
03:49:21 <quicksilver> but improves the quality of the rainbow.
03:50:09 <tirpen> A rainbow would be a very useful tool if you just had some rainarrows. Then you could use it to hunt reigndeers...
03:50:26 <dmwit> Actually, a number of things such as raindrop size and density, wind speed, and the position of the sun affect the quality of the rainbow.
03:50:40 <Cale> Rainarrows will be the next big Haskell abstraction.
03:51:14 <dmwit> heh, for the royal intellectual
03:51:25 <mux> applicative rainbows?
03:52:40 <tirpen> Quick, someone go and make up some mathematical theory about Applicative Rainbows! :)
03:54:19 <tirpen> Meh. I hate how all the haskell packages in Ubuntu are totally ancient and don't work with any of the code on Hackage. :(
03:55:21 <dmwit> I've learned to love darcs and cabal.
03:55:41 <Saizan> and cabal-install!
03:55:50 <Saizan> (from darcs)
03:56:05 <njbartlett> Reminder: Ganesh will be giving a talk about Darcs Patch Theory and GADTs tonight at the London Haskell User Group. http://tinyurl.com/3dk6ur
03:56:06 <dmwit> That I have not yet learned to love.  I'm sure I will, though!
03:56:11 <tirpen> Yes, It's just that I'd rather not have to recompile GHC and all the libraries.
03:56:40 <dmwit> You should be able to upgrade cabal independently of GHC, or isn't that what you meant?
03:56:43 <C-Keen> grml I am trying to install hmp3 but it cannot find -lpcre despite giving it the right location (-L/usr/local/lib) any ideas?
03:57:22 <RayNbow> dmwit: I have yet to learn darcs and cabal... :p
03:57:52 <RayNbow> well, I used darcs to get the source of wxHaskell... but that was just copy/pasting a command to cmd.exe :p
03:58:24 <tirpen> It's just that lots of stuff on Hackage requires GHC 6.8 or higher it seems. (Or maybe I'm just incompetent again)
03:59:43 <RayNbow> http://www.londonhug.net/2008/01/07/darcs-patch-theory-and-gadts-with-ganesh-sittampalam/ <-- hopefully this will be recorded :p
04:00:15 <njbartlett> RayNbow: Yes it will
04:00:17 <tirpen> That sounds interesting.
04:00:33 <ac> C-Keen: someone not too long ago was suffering from the same problem
04:00:46 <ac> C-Keen: someone else had a solution, but I can't remember it. You'll have to dig through the logs
04:01:10 <ac> I could be wrong though. It may have been another package :-P
04:01:34 <C-Keen> ac: since it is a cabal problem i think the solution would be similar i think
04:01:36 <ac> There should be a #haskell log search (if there isn't already)
04:02:33 <ac> googling "haskell foo site:tunes.org" sort of works
04:06:17 <C-Keen> there is but it seems to require some login
04:07:58 <dmwit> grepping for hmp3 or pcre doesn't turn up anything useful here
04:08:15 <dmwit> (Though I don't have quite as complete of logs as tunes.org.)
04:12:25 <RayNbow> njbartlett: ah, good... because I don't live in the UK :p
04:12:43 <njbartlett> RayNbow: What a pathetic excuse ;-)
04:12:55 <RayNbow> njbartlett: ok ok...
04:12:59 <dmwit> There are many other user groups... are you near a populated area?
04:13:02 <RayNbow> I don't feel like swimming across the North Sea ;)
04:13:20 <njbartlett> RayNbow: Last I heard, the Netherlands had airports :-p
04:13:23 <dmwit> I just discovered that there's one just half an hour from me, for example! =D
04:13:49 <njbartlett> dmwit: You just discovered there's a populated area half an hour from you? Cool :-)
04:13:59 <dmwit> heh
04:14:06 <RayNbow> http://home.shinnonoir.nl/Waddinxveen.jpg <-- my location :p
04:15:08 <njbartlett> So, somewhere between Amsterdam and Den Haag?
04:15:36 <dmwit> http://buckwheat.stanford.edu/onoesitshidden/coolest.jpg <-- my location
04:15:51 <RayNbow> njbartlett, do you have Google Earth? :)
04:15:55 <dmwit> Somewhere between sanity and sci-fi. =)
04:16:01 <njbartlett> RayNbow: Nope
04:16:03 <RayNbow> http://home.shinnonoir.nl/Train%20station%20Waddinxveen%20Noord.kmz <-- Google Earth link
04:17:16 <RayNbow> njbartlett: Waddinxveen is like... surrounded by cities like Gouda, Leiden, Rotterdam, Den Haag
04:17:24 <RayNbow> (sorta)
04:17:40 <nominolo> tirpen: i think lots of stuff needs cabal >= 1.2,  not necessarily ghc 6.8
04:18:18 <nominolo> tirpen: you have to install cabal 1.2 separately for other versions, though
04:18:59 <RayNbow> njbartlett, Google Maps to the rescue: http://maps.google.com/maps?f=q&hl=nl&geocode=&time=&date=&ttype=&q=Waddinxveen,+Zuid-Holland,+Netherlands&ie=UTF8&ll=52.173932,4.717255&spn=0.60975,1.277161&z=10&om=0
04:19:11 <njbartlett> RayNbow: Then start the Netherlands Haskell User Group :-)
04:19:45 * osfameron wonders if he can be arsed to trek into london tomorrow for the hug
04:19:55 <RayNbow> njbartlett: I'm already trying to infect people with the Haskell disease in #devschuur @ irc.tweakers.net (devschuur = Dutch abbrev for development shed)
04:20:05 <Beelsebob> I want a hug
04:20:41 <RayNbow> but that IRC channel also contains Ruby and Python fundamentalists
04:20:48 <njbartlett> osfameron: Please don't trek to London tomorrow for the HUG. Nobody will be there. It's tonight.
04:20:54 <RayNbow> so I have a hard time converting people ;)
04:21:01 <osfameron> njbartlett: thanks :-)
04:21:40 <osfameron> njbartlett: good luck with it by the way!  If I get my lazy arse in gear I might be there for pub, but doubt it if work doesn't let up a bit...
04:22:18 <njbartlett> osfameron: Hope you can make it
04:22:42 <njbartlett> And if not, there will be the video later
04:24:09 <osfameron> njbartlett: and if I drink a beer at flat while watching the vid, I can replicate the whole experience including pub...
04:24:47 <njbartlett> osfameron: Yeah. Who needs all those other people to talk to when you've got beer ;-)
04:41:11 <ac> dmwit: man you've got some funny pictures uploaded
04:46:57 <jedbrown> Helpful error message:     hpc: Prelude.foldr1: empty list
04:47:37 <ac> http://buckwheat.stanford.edu/onoesitshidden/cuddling.jpg
04:47:38 <ac> liftM (map sleep) $ replicateM 4 lcat
04:47:57 <ac> (ok, ok, not very funny)
04:48:58 * mux discovers D has some limited lazy evaluation features
04:48:58 <resiak> is \cats still active?
04:49:09 <jedbrown> I can't beleive other people haven't encountered this:  hpc markup tests --include some-package
04:49:09 <ac> do you think that's worth submitting?
04:49:31 <resiak> the kittens' arms look kind of like the edges in a fold diagram
04:49:49 <resiak> i'm sure there's a joke in that somewhere
04:49:52 <ac> yeah, fold would probably be better than replicateM
04:50:25 <quicksilver> foldl sleep (replicate4 lolkitten)
04:50:25 <resiak> foldl1 paw cats ?
04:50:25 <quicksilver> ?
04:50:45 <ac> quicksilver: nice
04:50:53 <ac> quicksilver: I like that
04:51:24 <byorgey> and definitely foldl, not foldr =)
04:51:49 <ac> indeed, those cats are definitely left associative
04:51:53 <tirpen> @src lolkitten
04:53:58 <jedbrown> Can someone else duplicate this behavior?  (My hpc version = 0.6)
05:04:28 <Cff> Hi, quick question. I have a big list (360000 elements) where each element is reasonably complex to compute. I use the entire contents of this list at a couple of different points in my program so I'd rather it wasn't lazily evaluated each time. How do I go about computing the contents of the list just once?
05:05:32 <jedbrown> Cff: Presumably you share the list between the different parts of your program, so each element will only be computed once.
05:05:36 <Saizan> Cff: bound it to some variable and pass it to both the points where is consumed
05:06:18 <jedbrown> Cff: If you really want to evaluate it completely, you could use 'rnf' from Control.Parallel.Strategies.
05:06:54 <Saizan> evaluating it completely won't gain anything wrt sharing, though
05:07:31 <Cff> at the start of my prog i just have: mylist = blah..., then call mylist at various points
05:07:34 <quicksilver> Cff: "lazily evaluated each time" is a contradiction, in a way.
05:07:38 <ac> Cff: if the list is something like [Int] or [Word32] you can use Array.Unboxed
05:07:45 <quicksilver> Cff: that 'lazy' means is that it is only evaluated once
05:07:55 <quicksilver> Cff: (that's the difference between lazy and non-strict, roughly)
05:08:06 <quicksilver> Cff: sounds like your code is already fine.
05:08:13 <quicksilver> mylist = will only be evaluated once.
05:08:14 <jedbrown> Cff: The only reason I can think of to do this is you are trying to guarantee a response time for a lookup, although the GC would get in the way there as well.
05:08:23 <ac> it may even be executed at compile time in GHC, right?
05:08:28 <quicksilver> nope.
05:09:32 <MyCatVerbs> :t arb
05:09:57 <Cff> say i have: mylist = blah; ...; take x mylist; ....; drop x mylist (or whatever)....... doesn't mylist get evaluated twice?
05:10:01 <MyCatVerbs> Oh hey, no lambdabot.
05:10:21 <MyCatVerbs> Cff: nope. Common subexpression elimination for the win, amongst other things.
05:11:02 <jedbrown> Cff: In that case, the elements of the list still aren't evaluated.
05:11:23 <quicksilver> eh?
05:11:29 <quicksilver> thais has nothing to do with CSE
05:11:40 <quicksilver> furthermore, GHC doesn't do CSE very often.
05:12:05 <quicksilver> Cff: Definitely not. One of the key features of lazy evaluation is that if you give something a name, it's evaluated (at most) once.
05:12:29 <jedbrown> Cff: for instance:   length (take 4 (repeat undefined)) = 4
05:13:18 <jedbrown> quicksilver: Though occasionally, it may be evaluated more than once on SMP.
05:13:41 <quicksilver> jedbrown: only if it's unboxed, afaik.
05:13:47 <opqdonut> jedbrown: is that length example really relevant?
05:13:47 <ac> quicksilver: what does CSE stand for?
05:13:48 <quicksilver> jedbrown: boxed values are never re-evaluated.
05:13:54 <Cff> so if i have x = length (take 4(repeat undefined)). to start with that will not be evaluated unless i call x somewhere. but once i call x a 2nd time it's already got the 4 and doesn't need to be evaluated again?
05:13:58 <opqdonut> CSE=Common subexpression elimination
05:14:10 <opqdonut> Cff: exactly
05:14:22 <jedbrown> quicksilver: There is still a race condition after the closure is entered, but before the indirection.  It is very rare though.
05:14:30 <opqdonut> but if you have "length (take 4(repeat undefined))" in two different places, the work will most definitely be done twice
05:14:30 <quicksilver> jedbrown: ah.
05:14:34 <kmcallister> Cff, are you familiar with graph reduction?
05:14:55 <Cff> vaguely
05:15:17 <Cff> we covered it in my ug fp course
05:15:35 <jedbrown> opqdonut: Cff was concerned that the elements of his list would be evaluated in his take n list, then drop n list.  I was just pointing out that the elements may not be evaluated anyway.
05:16:11 <Cff> that was just an example, they most definately are being evaluated in my actual list :)
05:16:27 <ac> Cff: no, GHC just intuits the values
05:16:33 <kmcallister> so you can think of evaluation of lambda terms as a process operating on trees, since each lambda expression is a tree
05:16:47 <opqdonut> jedbrown: oh, okay
05:16:55 <kmcallister> and you can define such tree reductions for either strict or non-strict eval order, but in the latter case you end up duplicating bits of the tree many times
05:17:46 <jedbrown> Cff: You don't need to worry about re-evaluation there.  The elements of the list are boxed, so the values will be shared and only computed at most once.
05:17:46 <kmcallister> so in actual implementations of non-strict languages, we use lazy eval, and instead of duplicating the subtrees substituted into arguments, we just point multiple edges at the same node (thus making it an acyclic graph rather than necessarily a tree)
05:18:00 <kmcallister> (i guess it's not acyclic either, if you have recursion)
05:21:19 <Baughn> Things like the famous fibonnacci one-liner, you mean?
05:21:33 <kmcallister> yeah
05:21:40 <opqdonut> which one?-)
05:21:52 <kmcallister> fibs = 1 : 1 : zipWith (+) fibs $ tail fibs
05:21:56 <kmcallister> was the one i was thinking of
05:22:05 <Baughn> They all use cycles, so it doesn't matter
05:22:08 <opqdonut> yeah, that's the classic one i guess
05:22:12 <Baughn> kmcallister: Also, that should be 0 : 1. ;)
05:22:18 <kmcallister> heh
05:22:33 <opqdonut> not sure how explicitly cyclic the fix and scanl version is
05:22:43 <opqdonut> oh well, it turns cyclical once we evaluate one step
05:24:38 <Cff> cheers for that guys, time for some lunch :)
05:26:58 <Baughn> @pl f fibs = zipWith (tail fibs) fibs
05:27:08 <Baughn> @pl f fibs = zipWith (+) (tail fibs) fibs
05:27:24 <Baughn> @pl f fibs = zipWith (+) (tail fibs) fibs
05:27:24 <Cheiron> f = zipWith (+) =<< tail
05:27:41 <Baughn> > fix (0 : 1 : zipWith (+) =<< tail)
05:27:43 <Cheiron>  Couldn't match expected type `[t]'
05:28:09 <Jaak> > fix((1:).scanl(+)1)
05:28:11 <Cheiron>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
05:28:27 <kmcallister> :t scanl
05:28:29 <Cheiron> forall a b. (a -> b -> a) -> a -> [b] -> [a]
05:28:30 <Baughn> @type zipWith (+) =<< tail
05:28:32 <Cheiron> forall a. (Num a) => [a] -> [a]
05:28:33 <mauke> :t join (zipWith (+) . tail)
05:28:35 <Cheiron> forall a. (Num a) => [a] -> [a]
05:29:18 <Baughn> @pl f fibs = 0 : 1 : zipWith (+) (tail fibs) fibs
05:29:18 <Cheiron> f = (0 :) . (1 :) . (zipWith (+) =<< tail)
05:29:25 <Baughn> ..figures.
05:35:52 * jedbrown awaits war stories on -cafe
05:37:39 <nominolo> @seen dcoutts
05:37:39 <Cheiron> dcoutts is in #haskell. I don't know when dcoutts last spoke.
05:37:43 <nominolo> @seen dcoutts_
05:37:43 <Cheiron> dcoutts_ is in #haskell. I don't know when dcoutts_ last spoke.
05:42:40 <matthew_-> @tell Heffalump  that I'm sorry but I can't make it to the london hug meet tonight
05:42:40 <Cheiron> Consider it noted.
05:45:25 <dcoutts_> hia nominolo
05:46:00 <nominolo> dcoutts_: hi.  i've just seen that you up'd the prio of dep-chasing
05:46:13 <dcoutts_> nominolo: yeah, so much depends on it
05:46:19 <nominolo> dcoutts_: so, i'd be open to some hacking over the weekend
05:46:24 <dcoutts_> cool
05:46:48 <dcoutts_> perhaps we can rope in waern and kolmodin
05:47:59 <dcoutts_> nominolo: I'm also looking at hackage QA and build reporting, that's a nearer term goal, and proper dep stuff is the next big thing for cabal generally, more medium term
05:49:01 <dcoutts_> nominolo: and...  and I'd also like to get a stable Cabal-1.4 release out so we can get more people to try cabal-install
05:49:38 <nominolo> dcoutts_: to me, the most important thing is to try and get the requirements formalised
05:49:58 <nominolo> *formalized
05:50:25 <dcoutts_> nominolo: the requirements for the dep framework?
05:50:41 <nominolo> yes
05:51:00 <nominolo> i always forget what features we need
05:51:58 <dcoutts_> aye, we need quite a bit :-0
05:52:25 <dcoutts_> though of course we have to layer things sensibly so it does not get too complex
05:53:01 <dcoutts_> nominolo: so I've had an idea formulating in my head for a while...
05:53:10 <dcoutts_> so we know that make rules look a bit like:
05:53:16 <dcoutts_> targets : deps
05:53:20 <dcoutts_>        action
05:53:44 <nominolo> yo
05:53:46 <dcoutts_> or: data Make a = Make [Target] [Target] (Action a)
05:54:05 <dcoutts_> this should be an instance of Functor, Applicative and Monad
05:54:16 <dcoutts_> or something like it
05:54:30 <dcoutts_> and the interesting bit is that <*> corresponds to static deps
05:54:34 <shag> is there something like IntMap that works with Word32 or Word16?
05:54:35 <dcoutts_> and >>= to dynamic deps
05:54:56 <dcoutts_> shag: make a wrapper that converts -> Int
05:55:17 <quicksilver> Word32 -> Int may not be possible?
05:55:24 <dcoutts_> nominolo: so if you look at a (f <*> x) you can see all the deps of each
05:55:25 <shag> well, i need the intmap to be space efficient
05:55:30 <quicksilver> > (maxBound :: Int)
05:55:31 <Cheiron>  9223372036854775807
05:55:37 <quicksilver> bah
05:55:41 <quicksilver> stupid 64bit compilation
05:56:05 <sizur> > maxBound::Integer
05:56:06 <Cheiron>   add an instance declaration for (Bounded Integer)
05:56:06 <Cheiron>     In the expression: ma...
05:56:12 <nominolo> shag: use a radix-tree or sth
05:56:19 <quicksilver> hmm. Looks like GHC does use the full range, so you could do a word32->int conversion.
05:56:25 <quicksilver> nominolo: isn't that what IntMap is?
05:56:36 <nominolo> quicksilver: no idea :)  could be
05:56:45 <totimkopf> hello
05:56:49 <sizur> totimkopf: hi
05:56:54 <dcoutts_> nominolo: but if you look at (f =<< x) then initially you only know the deps of x, to get the deps of the overall action you need the current value of the x action to be able to call f and get back another action
05:56:56 <nominolo> hello deadinthehead
05:57:25 <totimkopf> i'm using hugs98, i'm trying to follow a tutorial, but as i try to define my variable hugs tells me its not defined
05:57:35 <totimkopf> i type: area::Int
05:57:44 <totimkopf> is this wrong? is there something else i must be doing?
05:57:52 <dcoutts_> nominolo: and that corresponds to dynamic deps on .hi files for example where the deps of one action depends on reading the content of some file (another action)
05:57:56 <mauke> totimkopf: area = 42
05:57:57 <nominolo> totimkopf: use let
05:58:04 <mauke> assuming you're in a file
05:58:07 <nominolo> totimkopf: let area = 42
05:58:15 <mauke> nominolo: missing 'in'
05:58:29 <totimkopf> so there is no need for giving it a type?
05:58:39 <sizur> totimkopf: it's inferred
05:58:42 <dcoutts_> nominolo: so if one uses applicative as much as possible you get to inspect a big graph of static deps, where you have to use >>= you get data dependencies in the construction/viewing of the graph
05:58:51 <totimkopf> thanks guys :)
05:59:45 <nominolo> dcoutts: can we parallelize this?
05:59:46 <totimkopf> i'm now getting Syntax error in expression (unexpected end of input)
05:59:51 <totimkopf> :S
05:59:59 <mauke> totimkopf: let area = 42 in area
05:59:59 <nominolo> dcoutts: (>>=) is not commutative
06:00:15 <totimkopf> i did that
06:00:16 <totimkopf> oh
06:00:23 <mauke> it's a local variable
06:00:24 <pejo> dcoutts, what happens in gtk2hs if you have a window which you hide, and then drop the reference to it in Haskell?
06:00:24 <totimkopf> yay
06:00:29 <mauke> its scope is limited to the expression after 'in'
06:00:36 <dcoutts_> nominolo: indeed, >>= prevents some parallelism where <*> allows it. But that is inherent in the structure of the dependencies.
06:00:37 <totimkopf> ah
06:00:43 <sizur> you cannot bind in hugs interactive?
06:00:49 <mauke> sizur: nope, only ghci
06:01:00 <dcoutts_> nominolo: which is why we should use <*> where possible and >>= where necessary.
06:01:13 <vincenz> @src div Integer
06:01:13 <Cheiron> Source not found. You type like i drive.
06:01:15 <vincenz> @src div Int
06:01:16 <Cheiron> Source not found. You type like i drive.
06:01:24 <vincenz> @src Integer div
06:01:25 <Cheiron> Source not found. stty: unknown mode: doofus
06:01:35 <dcoutts_> pejo: it stays alive for ever. toplevel windows must be closed explicitly.
06:01:39 <nominolo> dcoutts_: yep.  that seems very elegant
06:02:10 <dcoutts_> nominolo: I think it needs existential types, but ghc, hugs and nhc support that.
06:02:37 <totimkopf> mauke, so after every statement i will have to type 'in'?
06:02:37 <nominolo> dcoutts_: or an additional type parameter
06:02:51 <sizur> totimkopf: why don't you try ghc?
06:02:52 <dcoutts_> nominolo: no, it's worse than that
06:02:57 <pejo> dcoutts, hm. So you need an explicit resource deallocation in your Haskell to free the resources?
06:03:00 <totimkopf> i think i will
06:03:04 <dcoutts_> @type (<*>)
06:03:06 <Cheiron> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
06:03:31 <mauke> totimkopf: no
06:03:38 <dcoutts_> pejo: yes, you have to explicitly close the window (or the user can close it)
06:04:01 <mauke> but if you want to write expressions with local variables in them, you need let ... in
06:04:47 <nominolo> dcoutts_: lets see.  existentials seem to be the number one feature missing from haskell98
06:05:09 * totimkopf is now downloading GHC for windows :D
06:05:24 <pejo> dcoutts, thanks a bunch. Have you pondered ways around that, or do you think it's impossible?
06:05:27 <dcoutts_> nominolo: I think one needs a data constructor like: data Make b where App (Make (a -> b) -> Make a -> Make b)
06:05:50 <nominolo> dcoutts_: yes, those are deep-embedding artifacts
06:06:13 <nominolo> dcoutts_: you can fix that using shallow embeddings (ie. functions / CPS)
06:06:25 <nominolo> dcoutts_: but it's often harder to understand
06:06:33 <dcoutts_> pejo: I think it makes some sense actually. It should be possible to spawn off a window with some attached event handlers and not have it be GC'ed essentially a top level window serves as a GC root
06:06:38 <hpaste>  Odissey_ pasted "Parser`s" at http://hpaste.org/5182
06:07:03 <dcoutts_> nominolo: yes, I've looked a bit at doing that. I think I'll prototype it with existentials and then see if it's possible to H98-ify it.
06:07:32 <dcoutts_> nominolo: I tried H98 initially and found it too hard to understand :-)
06:07:36 <nominolo> dcoutts_: yes. i wouldn't mind relying on existentials
06:09:00 <dcoutts_> pejo: it's a deliberate design in gtk+ memory management, that there is a table in which all top level windows are registered precisely to keep them alive, rather than having to maintain a reference to them to keep them alive.
06:09:13 <dcoutts_> pejo: think of a top level window like a haskell thread.
06:09:23 <nominolo> gtk+ is GCed?
06:09:33 <dcoutts_> nominolo: refcounted
06:09:39 <nominolo> i see
06:09:45 <totimkopf> hmmm
06:09:52 <nominolo> poor-mans GC ...
06:09:52 <dcoutts_> and designed to work with languages that use GC
06:10:37 <dcoutts_> nominolo: yes it means they have to be careful about cycles, but it works fairly well. And it is C afterall. :-)
06:10:43 <pejo> dcoutts, that design decision comes from gtk, and not the Haskell bindings?
06:10:51 <totimkopf> i'm using GHCi now
06:10:58 <dcoutts_> pejo: yes and we do not try to override it.
06:11:13 <totimkopf> so how do i make it so that i dont have to explicitly type the namespace i'm in?
06:11:26 <shag> sorry (phone), thanks for the IntMap tipps.
06:11:52 <mauke> totimkopf: ghci lets you say 'let foo = 42' and it will stay in scope for the rest of your session
06:11:55 <dcoutts_> pejo: is this causing you problems?
06:12:02 <totimkopf> ah
06:12:04 <totimkopf> i see :)
06:12:05 <nominolo> dcoutts_: seems like a good trade-off to me.  just heard today that GNUStep is actually supporting the Cocoa API.  AFAIK, ObjC is now GCed on OSX10.5
06:12:40 <nominolo> totimkopf: use a module and a file
06:12:43 <totimkopf> mauke, how do i define my first function? i've tried foo 1,2->Int->Int->Int but i got an error
06:12:50 <nominolo> then use :l file.hs  or  :r
06:12:52 <dcoutts_> nominolo: seems tricky given what C lets you do with pointers.
06:13:03 <mauke> totimkopf: let foo x y = x * x + y * y
06:13:10 <dcoutts_> nominolo: but then gcc uses GC internally too.
06:13:24 <totimkopf> niiice
06:13:53 <nominolo> dcoutts_: oh.  well, writing a compiler without GC sucks big time
06:13:55 <pejo> dcoutts, well, hm. Pondering what I would do if I were to create gtk bindings, figured it was easier to ask someone who had already done it. :-)
06:14:24 <totimkopf> so now, how do i pass foo arguements at whim?
06:14:31 <dcoutts_> pejo: you're creating gtk+ bindings? for what language?
06:14:54 <sizur> totimkopf: foo 1 2
06:15:01 <totimkopf> wow
06:15:29 <totimkopf> i'm sorry guys, if i'm annoying you with my newbie questions, i'm just a little intimidated by the tutorials, i wanted to get my feet wet with you guys first
06:15:41 <mauke> totimkopf: no problem :-)
06:15:57 <totimkopf> thanks :)
06:16:02 <pejo> dcoutts, not personally I hope. Timber.
06:16:19 <dcoutts_> hia bringert!
06:16:35 <bringert> hi dcoutts_
06:17:17 <totimkopf> mauke, how would i do advance string operations? like say if i wanted to reverse the order of a string?
06:17:25 <dcoutts_> pejo: I see. So, yes I'd recommend to just go with the flow. It's not an unreasonable decision on the part of the Gtk+ devs, don't bother trying to override it (which would be very hard to do anyway).
06:17:38 <sizur> > reverse "abcd"
06:17:39 <Cheiron>  "dcba"
06:17:40 <mauke> totimkopf: you'd use library functions like 'reverse' :-)
06:17:47 <totimkopf> niiiiiiiiiiice
06:17:53 <johnnowak> hehe
06:17:54 <mauke> @src reverse
06:17:54 <Cheiron> reverse = foldl (flip (:)) []
06:18:00 <sizur> :t reverse
06:18:02 <Cheiron> forall a. [a] -> [a]
06:18:43 <sizur> totimkopf: strings are just lists of chars, so all list functions work on strings
06:18:55 <totimkopf> oh i see
06:19:29 <mauke> > ['a', 'b', 'c']
06:19:30 <Cheiron>  "abc"
06:19:38 <johnnowak> totimkopf: String is just a synonym for [Char]
06:20:06 <totimkopf> ahhh
06:20:42 <nominolo> > (+) (-) 3 4 5
06:20:43 <Cheiron>   add an instance declaration for (Num (a -> a -> a))
06:20:43 <Cheiron>     In the expression: ...
06:21:24 <mauke> > (+) ((-) 3 4) 5
06:21:26 <Cheiron>  4
06:22:08 <totimkopf> i dont understand what (+) ((-) 3 4) 5 does
06:22:15 <totimkopf> are those functions in disguise?
06:22:20 <mauke> (+) and (-) are functions
06:22:25 <totimkopf> ah
06:22:25 <mauke> > (-) 3 4
06:22:27 <Cheiron>  -1
06:22:36 <johnnowak> totimkopf: wrapping an operator in parens lets you use it as a 'normal' function instead of infix
06:22:47 <johnnowak> 1 + 2 == (+) 1 2
06:22:52 <mauke> > (==) 1 2
06:22:53 <Cheiron>  False
06:22:59 <michael_campbell> is "+" an actual operator?  Or is it always a function, just used AS an operator?  (sorry, newbie here too)
06:23:11 <mornfall> michael_campbell: Everything is a function.
06:23:23 <johnnowak> michael_campbell: it's only an "operator" because of its name
06:23:32 <michael_campbell> Gotcha, thanks.
06:23:36 <mux> michael_campbell: operators are just like functions, except that you use them in infix notation
06:23:44 * michael_campbell is working through YAHT, slowly.
06:23:49 <mux> but there are ways to use functions in infix notation, and operators in prefix notation
06:24:09 <michael_campbell> I've seen use of that; once I saw it I thought, "Why don't all languages do that?!?"
06:24:11 <mux> > 'o' `elem` "foo"
06:24:12 <Cheiron>  True
06:24:17 <sizur> > 5 `sum` 5 5
06:24:18 <Cheiron>   add an instance declaration for (Num (t -> t1))
06:24:31 <sizur> lol i used it as polyvariadic
06:24:49 <mux> > 10 `div` 3
06:24:50 <Cheiron>  3
06:25:37 <sizur> > (+1) 2
06:25:38 <Cheiron>  3
06:25:53 <totimkopf> why would one use operators as functions?
06:26:05 <sizur> totimkopf: to pass them as parameters to other functions
06:26:20 <pejo> dcoutts, mmm, that makes sense. Thanks a lot.
06:26:21 <sizur> > map (+2) [1,2,3,4]
06:26:22 <ski_> > zipWith (*) [1,2,3] [40,50,60]
06:26:23 <Cheiron>  [3,4,5,6]
06:26:23 <Cheiron>  [40,100,180]
06:29:11 <sizur> > let a ^.^ b = replicate a b in 3 ^.^ 'a'
06:29:12 <Cheiron>  "aaa"
06:29:56 <totimkopf> so i could express every algebraic expession in haskell, right? and everything would remain mathematically correct etc?
06:30:25 <nominolo> modulo non-termination
06:30:39 <sizur> totimkopf: beware of Floats. usual gotcha
06:30:47 <totimkopf> sizur, why?
06:30:52 <nominolo> [0,0.1,..1.0]
06:31:02 <nominolo> > [0,0.1..1.0]
06:31:03 <Cheiron>  [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.899999...
06:31:19 <nominolo> > [0,0.25..1.0]
06:31:20 <Cheiron>  [0.0,0.25,0.5,0.75,1.0]
06:32:01 <nominolo> totimkopf: http://docs.sun.com/source/806-3568/ncg_goldberg.html
06:32:06 <sizur> totimkopf: because floats use the floating point unit of the processor
06:32:12 <masklinn> let (^.^) = replicate in 3 ^.^ 'a'
06:32:20 <shepheb> what happened to lambdabot this time?
06:32:28 <masklinn> > let (^.^) = replicate in 3 ^.^ 'a'
06:32:29 <Cheiron>  "aaa"
06:33:17 <nominolo> > let x = replicate in 3 `x` 'O'
06:33:19 <Cheiron>  "OOO"
06:33:49 <nominolo> > (+1) `fmap` [2..6]
06:33:50 <Cheiron>  [3,4,5,6,7]
06:33:55 <totimkopf> okay guys, this is what i want to do, i want to make a regular verb conjugator in haskell
06:34:02 <totimkopf> any suggestions?
06:34:25 <sizur> totimkopf: start with finishing the tutorial maybe? ;)
06:34:29 <totimkopf> sizur, hehehe
06:34:51 <totimkopf> ok
06:35:53 <michael_campbell> Any opinions here on the "Real World Haskell" book (to be released)?  I'm going through YAHT with some success, so am going to stick with that for now.
06:36:09 <sizur> michael_campbell: i like it
06:36:25 <nominolo> michael_campbell: very incomplete, but quite good already
06:36:49 <michael_campbell> Good, thanks; as long as what's there is good and correct, I can always mix and match.
06:36:55 <mux> I found it nice too
06:38:11 <mightybyte> What package utilities do I need to run a "bleeding-edge" set of haskell packages on Ubuntu?  I've tried getting cabal-install to help with dependancies, but I have even had trouble getting that installed.
06:39:06 <nominolo> michael_campbell: if you're a newbie your comments could be particularly helpful in the sections published so far
06:39:18 <sizur> mightybyte: i had to install Cabal from darcs to install cabal-install, all went smooth
06:39:36 <michael_campbell> I've commented some; mostly what I've found others have found before I have.
06:40:00 <mightybyte> sizur: Does cabal come with ghc?  Seems like I saw something that gave me that idea.
06:40:02 <nominolo> mightybyte: cabal-install needs zlib and one other non-standard library
06:40:20 <sizur> mightybyte: yes, but cabal-install needs a newer version
06:40:24 <nominolo> mightybyte: the plan is that cabal-install and all it's deps will be released as one piece
06:40:25 <mightybyte> nominolo: Is zlib a haskell library?
06:40:29 <mightybyte> sizur: Ahh
06:40:42 <nominolo> mightybyte: there are haskell bindings to the c-lib
06:41:01 <mightybyte> nominolo: Ok
06:41:22 <BMeph> > let endings=[["e","st","t"],["en","t","en"]]; regConj verb = map (verb++) endings in regConj "brenn"
06:41:23 <Cheiron>  Couldn't match expected type `[Char]' against inferred type `Char'
06:41:30 <nominolo> mightybyte: cabal-install currently depends on the development version of cabal.  look out for the cabal-1.4 release.
06:41:40 <mightybyte> What's the standard way to install from darcs?  Get the sources into /usr/local/src and then build from there?
06:41:55 <mightybyte> nominolo: Ok, thanks.
06:42:21 <sizur> mightybyte: yeah that's good if you're installing systemwide
06:42:45 * nominolo uses cd ~/devel ; darcs get ... ; runhaskell Setup configure --prefix=$HOME/usr; ...
06:43:24 <sizur> runhaskell Setup.hs configure --user
06:44:06 <nominolo> sizur: there was a bug that --user didn't change the prefix to some user-writable location
06:44:24 <sizur> nominolo: worked for me
06:44:26 <nominolo> sizur: it's fixed now, but i don't know the default user location
06:44:27 <totimkopf> how do i concatenate strings?
06:44:38 <nominolo> > "like " ++ "this"
06:44:39 <Cheiron>  "like this"
06:44:44 <totimkopf> nice
06:44:53 <sizur> :t (++)
06:44:55 <Cheiron> forall a. [a] -> [a] -> [a]
06:44:57 <mightybyte> Ok, hopefully this will get me going better.  Thanks for the help.
06:45:09 <totimkopf> so let foo x = x ++ "poop"  would work
06:45:23 <nominolo> yep
06:45:49 <nominolo> @pl foo x = x ++ y
06:45:49 <Cheiron> foo = (++ y)
06:46:03 <sizur> :t (++"poop")
06:46:05 <Cheiron> [Char] -> [Char]
06:48:52 <totimkopf> what do conditions look like in haskell?
06:49:38 <sizur> > if 5>6 then "poop" else "goodness"
06:49:39 <Cheiron>  "goodness"
06:50:13 <totimkopf> hhehe
06:50:28 <sizur> totimkopf: care as both expressions of then and else have to match types
06:50:28 <totimkopf> i'm not intimidated by haskell so much anymore
06:50:34 <totimkopf> oh
06:50:45 <sizur> because the whole expression has only one types
06:50:47 <sizur> type*
06:51:09 <mauke> > if 5>6 then [1,2,3] else 'x'
06:51:10 <Cheiron>  Couldn't match expected type `[t]' against inferred type `Char'
06:51:36 <totimkopf> lists seem cool
06:52:20 <totimkopf> can i mix types in lists?
06:52:24 <sizur> no
06:52:27 <totimkopf> oh
06:52:35 <totimkopf> i guess that wouldnt be very useful anyway
06:52:47 <sizur> you use tuples when you need to mix types
06:52:58 <EvilTerran> (but they're fixed-length)
06:53:05 <sizur> and have order
06:53:09 <totimkopf> :/
06:53:26 <EvilTerran> totimkopf, you can mix, say, two types in a list with Either
06:53:44 <EvilTerran> ?type [Left True, Right "bleem", Left False, Right "fleem"]
06:53:46 <Cheiron> [Either Bool [Char]]
06:54:10 <sizur> totimkopf: it is very rare that you really need a heterogenious list. but
06:54:31 <sizur> when something is not possible but you really really want it, then it is possible
06:54:55 <Japsu> and by chaining eithers you can put an arbitrary number of types in a list ;)
06:54:56 <EvilTerran> totimkopf, the thing is, if you could mix types ad hoc in a list, that'd break the types
06:54:58 <totimkopf> what do multiple statements within the body of a function look like, how are they seperated?
06:55:04 <totimkopf> (sorry for interrupting)
06:55:15 <EvilTerran> totimkopf, haskell doesn't have statements, only expression
06:55:15 <EvilTerran> s
06:55:17 <sizur> totimkopf: there are no statements in haskell
06:55:19 <totimkopf> oh
06:55:21 <totimkopf> expressions then
06:55:26 <sizur> just mix them ;)
06:55:38 <EvilTerran> each binding is only one expression
06:55:39 <Japsu> the body of a function is one expression
06:55:44 <totimkopf> oh
06:55:45 <Japsu> @quote stereo!
06:55:45 <Cheiron> No quotes yet.
06:55:48 <EvilTerran> these are functions, in the maths sense
06:55:48 <Japsu> what
06:55:49 <Japsu> NO
06:55:56 <EvilTerran> @quote fugue
06:55:56 <Japsu> no
06:55:56 <Cheiron> No quotes yet.
06:55:56 <Japsu> wait
06:56:00 <Japsu> what's that
06:56:03 <Japsu> @bot
06:56:03 <EvilTerran> ?version
06:56:03 <Cheiron> :)
06:56:03 <Cheiron> lambdabot 4p15, GHC 6.6.1 (Linux x86_64 3500+)
06:56:03 <Cheiron> darcs get /home/svein/dev/milfbot/orig
06:56:11 <opqdonut> milfbot :D
06:56:16 <totimkopf> hmm
06:56:20 <Japsu> liek wut
06:56:24 <Japsu> Mui. opqdonut
06:56:38 <opqdonut> Mui. Japsu
06:56:44 <totimkopf> so i'll have to write a bunch of seperate functions then
06:56:47 <EvilTerran> totimkopf, when starting out, i personally found it easier to think of haskell as maths formulae
06:56:51 <totimkopf> i guess thats why they call it functional programming ;)
06:56:55 <Japsu> yep ;)
06:56:56 <EvilTerran> rather than programming in the usual sense
06:57:21 <totimkopf> i kinda like that idea
06:57:24 <pjd> totimkopf: you will learn about monads
06:57:29 <totimkopf> it'll make me feel like a maths genius
06:57:52 <Japsu> totimkopf: and instead of loop constructs such as "while" and "for", you use recursion either directly or indirectly through common functions that work on lists
06:58:13 <totimkopf> 'mom: totimkopf, are you playing with your computer again? me: no i'm writing functions in lambda calculus'
06:58:23 <pjd> totimkopf: the IO monad basically fills the role of statements in Haskell
06:58:31 <Japsu> @remember totimkopf 'mom: totimkopf, are you playing with your computer again? me: no i'm writing functions in lambda calculus'
06:58:31 <Cheiron> Not enough privileges
06:58:34 <Japsu> Cheiron: STUPID BOT
06:58:36 * Japsu bashes Cheiron 
06:58:47 <Japsu> @botsmack
06:58:48 <Cheiron> :)
06:58:50 <Japsu> >_>
06:58:56 <sizur> lol
06:59:03 <opqdonut> :D
06:59:06 <totimkopf> recursion makes sense
06:59:13 <EvilTerran> totimkopf, if you're going to want to do IO, have a look at http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
06:59:23 <totimkopf> thanks EvilTerran
06:59:45 <sizur> i think it's a little early for monads
06:59:56 <EvilTerran> totimkopf, but it's important to keep use of that sort of thing to a bare minimum; otherwise you lose many of the advantages of haskell
07:01:18 <pjd> totimkopf: to give you a taste, try this at your ghci: do x <- readLn; print (x*2)
07:01:48 <Japsu> @pl fmap id
07:01:48 <Cheiron> id
07:01:50 <pjd> (you can also put the "print (x*2)" underneath the "x <- readLn")
07:01:57 <opqdonut> Japsu: ?
07:02:09 <Japsu> opqdonut: nvm, just reading http://sigfpe.blogspot.com/2007/04/trivial-monad.html
07:02:38 <Japsu> "Exercise 4: We can't completely unwrap things using the monad API. But we can unwrap one layer from things that are wrapped twice. So here's a nice puzzle: define a function join :: W (W a) -> W a using the Monad API and no explicit unwrapping." <-- I take it "no explicit unwrapping" means no pattern matching on W x
07:02:54 <mauke> right
07:02:59 <fasta> When I run a profiled version of my program in GHC, I see a partial stack trace, but the machine is still using 99% CPU (and has no intention of stopping). When I run it in ghci I don't see that. Where does this come from?
07:03:15 <opqdonut> Japsu: yep
07:03:32 <opqdonut> and this can be implemented by not exposing the constructor W
07:03:47 <totimkopf> i just learned what a command is
07:03:59 <totimkopf> and i thought everything would be a function :O
07:04:00 <opqdonut> module Trivial (W (), bind, ...) --  that's the syntax i think
07:04:17 <osfameron> Japsu: that sounds like a really badly worded, annoying monad tutorial exercise...
07:04:19 <EvilTerran> totimkopf, commands are functions
07:04:23 <Japsu> osfameron: ;P
07:04:35 <mauke> totimkopf: there are no commands
07:04:36 <sizur> totimkopf: keep reasing
07:04:38 <sizur> reading
07:05:01 <osfameron> in fact I think I've read that exercise (and possibly attempted it.  where's it from?)
07:05:02 <mauke> break glass in case of insufficient confusion
07:05:04 <fasta> mauke: some tutorials did use the word "command" for "action".
07:05:21 <Japsu> I was thinking something like join = fmap id, but fmap id (W (W x)) = W (id (W x)) = W (W x) still
07:05:28 <mightybyte> Hmmm, zlib doesn't want to build for me.  "error: zlib.h: No such file or directory"
07:05:40 <mauke> Japsu: since when is fmap part of the monad api?
07:06:02 <Japsu> mauke: the article uses it, so I'm assuming it's allowed in the excercise ;)
07:06:07 <sizur> fasta: at the end of this one he says that he lied a few. it's just a tool to create conceptual parallel
07:06:10 <pjd> totimkopf: the best thing to do is not worry about monads yet
07:06:11 <pjd> http://squing.blogspot.com/2008/01/unmonad-tutorial-io-in-haskell-for-non.html
07:06:25 <opqdonut> Japsu: hint: fmap is not enough
07:06:28 <opqdonut> you need bind
07:06:37 <pjd> when you've used Haskell a while, and understand the type system and type classes better, monads will naturally make sense
07:06:53 <mauke>  Plato, Aristotle, Socrates? Morons!
07:07:05 <doserj> mightybyte: installed the development package for the C zlib library?
07:07:21 <sizur> mauke: it's just you think that i think that you think
07:07:50 <fasta> sizur: most people blogging about monads have little to no clue. Cale's tutorial on monad transformers is nice, though.
07:07:57 <sizur> or was it, I know that you know that i know
07:08:15 <mightybyte> doserj: I thought so, but I'm not sure which ubuntu package it is.
07:08:32 <mightybyte> doserj: I installed zlibc and zlib-bin.
07:08:32 <Japsu> ah
07:08:34 <Japsu> (>>= id)
07:08:38 <opqdonut> :)
07:08:39 <fasta> If Haskell would have anonymous classes, we wouldn't even need the concept of a monad.
07:08:41 <pjd> == liftM
07:08:44 <mauke> @src join
07:08:44 <Cheiron> join x =  x >>= id
07:08:56 <pjd> err, nevermind me
07:09:12 <Japsu> @pl (>>= return)
07:09:13 <Cheiron> id
07:09:23 <doserj> mightybyte: sth like zlib-dev?
07:09:30 <Japsu> @src liftM
07:09:31 <Cheiron> liftM f m1 = do { x1 <- m1; return (f x1) }
07:09:36 <pjd> Japsu: fmap id == id being one of the Functor laws
07:09:41 <Japsu> yeah
07:10:37 <mightybyte> doserj: There's lib32z1-dev
07:11:44 <mightybyte> doserj: Ahh, that did it.
07:12:02 <mightybyte> doserj: Definitely not very obvious.
07:12:24 <totimkopf> is database programming possible with ghc?
07:12:56 <pjd> it's a general-purpose language, so anything is possible :)
07:13:04 <kaol> @faq
07:13:04 <Cheiron> The answer is: Yes! Haskell can do that.
07:13:08 <pjd> but yes, there are several database interfaces available
07:13:42 <pjd> http://haskell.org/haskellwiki/Applications_and_libraries/Database_interfaces
07:13:44 <Cerox> hi, i'm a german student and we learn haskell as an example for declarative programming languages, i've to write a dictionary in Haskell, the type dictionary = String -> String is given, but i've never seen the -> syntax in type definitions before, how i can work with it. haskell is a new language for me and i didn't find that situation in my books
07:14:07 <pjd> also http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Database
07:14:09 <EvilTerran> Cerox, i think you need a tutorial
07:14:27 <Cerox> so fundamental? :)
07:14:32 <quicksilver> Cerox: the notation means "functions which take as an argument one String and return one String as a result"
07:14:38 <pjd> that's probably dictionary :: String -> String
07:14:39 <EvilTerran> Cerox, very much so
07:14:41 <quicksilver> I concur with EvilTerran too.
07:14:41 <mauke> Cerox: you haven't seen functions before?!
07:14:52 <EvilTerran> @where tutorial
07:14:52 <Cheiron> I know nothing about tutorial.
07:14:53 <quicksilver> there are some excellent haskell tutorials around.
07:14:54 <EvilTerran> ...
07:15:07 <mauke> @go haskell tutorial
07:15:09 <Cheiron> http://www.haskell.org/tutorial/
07:15:09 <Cheiron> Title: A Gentle Introduction to Haskell, Version 98
07:15:15 <mauke> haha
07:15:21 <pjd> @go haskell wikibook
07:15:22 <Cheiron> http://en.wikibooks.org/wiki/Programming:Haskell
07:15:22 <Cheiron> Title: Programming:Haskell - Wikibooks, collection of open-content textbooks
07:15:27 <EvilTerran> http://haskell.org/haskellwiki/Tutorials
07:15:56 <sizur> haskell wikibook was my stepping stone
07:16:02 <sizur> then a few real books
07:16:04 <pjd> Cerox: have a look at those
07:18:13 <Cerox> okay okay.. i know the syntax dictionary :: String -> String...i'm new, but no idiot ;-) but it's given as a type, not as a function.. that was confusing me
07:18:54 <matthew_-> has anyone got a haskell compiler that outputs to dvalik or whatever the google android vm/non-vm thing is?
07:20:17 <sizur> it's a type of that function
07:20:57 <Cerox> oh.. okay ^^
07:21:09 <njbartlett> matthew_-: Dalvik uses transformed Java bytecodes. You could use something like CAL or LambdaVM with it I guess
07:21:32 <Cerox> i just know imperative programming languages... haskell is totally confusing me :)
07:21:36 <Cerox> but thanks ;)
07:22:10 <matthew_-> njbartlett: ahh, so it's a managed environment with GC there already?
07:23:15 <quicksilver> haskell maps poorly to JVM, doesn't it/
07:23:16 <quicksilver> ?
07:23:32 <quicksilver> you have to represent thunks as objects, if you want the JVM to do your GC.
07:23:40 <quicksilver> and that's not a very good way to go?
07:23:41 <matthew_-> in general yes, but it's quite possible that tail-calls finally will be going into the jvm
07:23:43 <osfameron> how does scala manage it?
07:23:51 <Lemmih> Cerox: Don't expect to know Haskell just because you know some imperative languages.
07:24:05 <C-Keen> the opposite is the case
07:24:26 <C-Keen> you don't know haskell _because_ you know imperative languages
07:24:38 <osfameron> that is a little excessive
07:24:41 <matthew_-> well, odds are that android is going to be quite a "big thing". Being able to write haskell to it would be good
07:27:25 <Cerox> Lemmih: i never expected that... i just said it's confusing me, because it's "no" imperative language ;)
07:28:01 <Cerox> and i'm familiar with these
07:31:54 <dejones_> ?[].head
07:32:14 <resiak> @src head
07:32:14 <Cheiron> head (x:_) = x
07:32:14 <Cheiron> head []    = undefined
07:32:23 <dejones_> thanks
07:33:57 <dcoutts_> @seen nominolo
07:33:58 <Cheiron> nominolo is in #haskell. I last heard nominolo speak 48m 8s ago.
07:34:26 <nominolo> dcoutts_: thou has calleth?
07:34:26 <pjd> :t listToMaybe
07:34:28 <Cheiron> forall a. [a] -> Maybe a
07:34:31 <pjd> use that
07:34:39 <pjd> instead of head
07:34:40 <sizur> i think by the time we will have good programmable mobile platform, all apps will be on the serverside anyway
07:34:40 <hpaste>  dcoutts pasted "more Make ideas" at http://hpaste.org/5183
07:34:44 <dcoutts_> nominolo: ^^^
07:35:17 <quicksilver> I don't agree.
07:35:24 <nominolo> dcoutts_: GADTs? :)
07:35:26 <quicksilver> Mobile platforms are often used out of service.
07:35:42 <dejones_> pjd: Maybe a?  huh?
07:35:43 <sizur> there will be more coverage, cheaper
07:35:51 <dcoutts_> nominolo: it's not actually the G part of GADTs, note the result type is always the same
07:36:17 <dcoutts_> nominolo: but it's nicer to present that way, obviously we'd use ordinary data and existentials
07:36:24 <dejones_> pjd: not sure how to use listToMaybe...
07:36:50 <nominolo> dcoutts_: yeah.  i'm trying to figure out where the dependencies/targets parts come into the game
07:36:56 <dcoutts_> nominolo: what is missing there is any real use of the targets (and it should be parameterised by Target)
07:37:17 <nominolo> dcoutts_: ah, "gather"
07:37:32 <pjd> @src Maybe
07:37:32 <Cheiron> data Maybe a = Nothing | Just a
07:37:35 <mightybyte> Is there any way to uninstall things with cabal-install?
07:37:47 <matthew_-> dcoutts, nominolo: this isn't finally, a nice haskell replacement for Make is it?
07:37:50 <dcoutts_> mightybyte: not yet, would you like to implement it?
07:38:00 <pjd> dejones_: in general, Maybe is used for results that can fail, or be missing
07:38:05 <dcoutts_> matthew-_: it's some ideas along those lines, yes.
07:38:10 <nominolo> dcoutts_: good answer! ;)
07:38:10 <sizur> mightybyte: ghc-pkg unregister
07:38:15 <mightybyte> dcoutts_: I would, if I was there yet.
07:38:19 <quicksilver> I believe that 'nice' and 'replacement to make' are contradictory goals.
07:38:24 <quicksilver> The problemspace is inherently non-nice.
07:38:30 <dejones_> pjd: what does it return if it fails...?
07:38:33 <matthew_-> quicksilver: well, it's just a graph really, right?
07:38:37 <quicksilver> A more realistic goal is "slightly less horrific"
07:38:38 <pjd> dejones_: listToMaybe is like head, but if the list is empty, instead of raising an exception, it returns Nothing
07:38:39 <mightybyte> sizur: Ahh, my problem is that cabal-install did a user instead of global and I'm trying to switch it.
07:38:46 <pjd> > head ""
07:38:47 <Cheiron>  Exception: Prelude.head: empty list
07:38:48 <dejones_> pjd: thanks
07:38:54 <pjd> > listToMaybe ""
07:38:56 <Cheiron>  Nothing
07:39:00 <pjd> > listToMaybe "hello"
07:39:02 <Cheiron>  Just 'h'
07:39:04 <dejones_> > listToMaybe []
07:39:06 <Cheiron>  Nothing
07:39:08 <dejones_> :)
07:39:12 <dejones_> thanks pjd
07:39:24 <dcoutts_> mightybyte: http://hackage.haskell.org/trac/hackage/ticket/106
07:39:30 <nominolo> being better than make is actually not that easy
07:39:38 <pjd> dejones_: there's a bit more to it;  a successful result is wrapped in a Just
07:39:50 <dcoutts_> mightybyte: it's easier to go with the flow and do user installs. Is there any need to do global ones?
07:39:50 <idnar> pjd: that's a pretty weird function name
07:39:52 <dejones_> pjd: can I use Nothing in a return?
07:39:54 <dejones_> :t Nothing
07:39:56 <Cheiron> forall a. Maybe a
07:39:57 <jedbrown> instance (RealFloat a, Storable a) => Storable (Complex a) where
07:39:57 <jedbrown>          sizeOf _ = 2 * sizeOf (undefined :: a) -- How do I do this?
07:40:16 <pjd> idnar: don't blame me, i didn't do it
07:40:33 <dcoutts_> quicksilver: actually I think the central idea of make is pretty good.
07:40:40 <pjd> dejones_: well, Just and Nothing are the constructors for Maybe
07:40:46 <pjd> so you can pattern match on them
07:40:51 <quicksilver> dcoutts_: so do I. And dificult to reinvent.
07:40:51 <sizur> user isntalls are generally better idea, unless you really Need a global one
07:40:58 <dejones_> pjd: thanks
07:41:03 <pjd> but you'll probably use higher-level functions to work with them
07:41:14 <dcoutts_> quicksilver: yes, it's an incremental parallel evaluator. Not trivial.
07:41:15 <swiert> aoesahou
07:41:16 <pjd> dejones_: are you familiar with monads?
07:41:22 <pjd> or functors?
07:41:49 <dcoutts_> nominolo: so what is missing there is reduce...
07:41:52 <nominolo> quicksilver: it's also hard to find all the requirements
07:41:58 <pjd> > fmap (+5) . listToMaybe [1..]
07:41:59 <Cheiron>  Couldn't match expected type `a -> f a1'
07:42:11 <pjd> > fmap (+5) . listToMaybe $ [1..]
07:42:13 <Cheiron>  Just 6
07:42:14 <dcoutts_> nominolo: eval is all every well, but it looses the structure of the graph after evaluation
07:42:20 <pjd> > fmap (+5) . listToMaybe $ []
07:42:21 <mightybyte> dcoutts_: Well, the user didn't seem to work.  I was trying to install HAppS-Util and it didn't seem to see mtl and hslogger when they were installed as user.
07:42:22 <Cheiron>  Nothing
07:42:22 <dejones_> pjd: nope  :/  I'm very new to Haskell...
07:42:31 <quicksilver> dcoutts_: This is roughly want I meant. It's a complex problem space with unpleasant corner cases.
07:42:44 <quicksilver> dcoutts_: therefore it's hard to reinvent, and harder still to reinvent something better.
07:42:53 <dcoutts_> nominolo: what we really want is to be able to take the graph, and bring one node up to date, keeping the graph and all the bits necessary to re-eval later.
07:42:56 <sizur> mightybyte: do runhaskell Setup.hs configure --user
07:43:00 <pjd> > do x <- listToMaybe [5]; return (x+1)
07:43:02 <Cheiron>  Just 6
07:43:02 <quicksilver> just look at ant, and aegis, and that other one
07:43:03 <dejones_> pjd: for example if x : xs = [], then x would fail, right?
07:43:05 <pjd> > do x <- listToMaybe []; return (x+1)
07:43:06 <sizur> mightybyte: when you install Happs
07:43:06 <Cheiron>  Nothing
07:43:16 <dcoutts_> nominolo: we need to keep the unevaluated and partially evaluated graphs tied together
07:43:21 <pjd> those are a few ways to work with Maybes
07:43:27 <matthew_-> quicksilver: ant never tried to do anything even remotely intelligent
07:43:31 <dcoutts_> nominolo: or another way of looking at that is to say we need to cache value in the graph
07:43:33 <mightybyte> sizur: Ok, will that also get the global packages?
07:43:46 <sizur> yes
07:43:54 <matthew_-> apparently the whole thing (ant) was designed and written on a plane flight between two places not very far apart
07:43:57 <jedbrown> Pattern matching with `sizeOf (r :+ _) = ...' breaks the semantics since :+ is strict, but I can't think of another way.
07:44:02 <nominolo> dcoutts_: why do we need fmap?
07:44:04 <njbartlett> osfameron: Scala works better than Haskell on the JVM because it's not lazy
07:44:22 <dcoutts_> nominolo: everyone needs fmap :-) I'm not sure it's essential actually.
07:44:22 <sizur> but scala look sugly to me
07:44:24 <nominolo> dcoutts_: mapping from action type a to b doesn't seem very useful (well-defined) to me
07:44:25 <sizur> looks*
07:44:28 <therp> btw anyone ever considered writing a GHC backend for LLVM?
07:44:28 <mightybyte> sizur: Ok, that's great.  I think I'm starting to understand how these tools work. :)
07:44:41 <njbartlett> osfameron: However, another problem with all functional languages on JVM is the lack of tail-call optimization
07:44:50 <nominolo> therp: sort of
07:44:57 <pjd> dejones_: i have to run off now, but please feel free to ask questions;  i'm sure someone will help
07:44:57 <matthew_-> njbartlett: that may go away soon(ish)
07:44:57 <osfameron> njbartlett: ah.  so that makes GC faster than a lazy language?
07:45:05 <njbartlett> sizur: sure, compared to Haskell, Scala is horribly ugly. But compared to Java, it's sheer beauty
07:45:16 <dejones_>  if x : xs = [], then x would fail, right?
07:45:21 <mightybyte> sizur: Will that --user cause HAppS to be installed as user also?  Or just see user-installed packages?
07:45:30 <nominolo> dcoutts_: what does the a actually stand for?  just the embedded actions?  and if so, is that what we want?
07:45:31 <therp> nominolo: I haven't really looked at this intermediate representation. also I haven't looked at the Cmm data types in GHC closely.. I wonder if they are that far apart
07:45:32 <dcoutts_> quicksilver: we have three ideas for re-inventing it better. One is to allow dynamic deps rather than just static ones as make does. Then to parameterise over the underlying monad (not just IO and file targets) and also to guarantee by construction that deps are specified correctly. Make allows you to make mistakes by missing off deps.
07:45:39 <sizur> njbartlett: i dont know, all i see is {}{}{}{{}}{{}}} in scala ;) lisp is beauty compared to that
07:45:53 <nominolo> therp: i don't think it's harder than compiling to C
07:45:58 <dcoutts_> nominolo: the 'a' in Make m a ? yes, that's the value of the top level of the graph.
07:46:10 <nominolo> therp: but there is no real standard other than the implementation files
07:46:32 <therp> nominolo: "no real standard" of what? the LLVM interface?
07:46:33 <njbartlett> osfameron: It's not that it makes GC faster as such. Just that with a lazy language, you have lots of small, long lived thunk objects. Also ideally you would replace a thunk with its actual value once calculated, which can't be done in JVM.
07:46:40 <nominolo> therp: yep
07:46:59 <nominolo> therp: i had to infer the grammar from the .y file
07:47:00 <therp> nominolo: hmm yes. that's a difference in comparison with the java VM..
07:47:20 <nominolo> therp: it's also evolving
07:47:21 <sizur> mightybyte: that will isntall Happs as user
07:47:25 <osfameron> njbartlett: ah, ok.  Are there VMs extant which support haskell semantics better?
07:47:26 <njbartlett> matthew_-: To answer your earlier question though, yeah Dalvik is a managed environment with GC, just like JVM. The main difference from JVM is it's optimized for smaller memory consumption
07:47:29 <dcoutts_> quicksilver: since make only had shell as the action language, it made you specify the targets and depends separately from the action that generates the targets from the dependencies. That separation allows untracked depends.
07:47:47 <therp> nominolo: isn't the intended use case that you build up your AST with calls to the LLVM, and never hit a textual description?
07:48:01 <dcoutts_> nominolo: ok, I've gotta go teach some OOP :-(.  later.
07:48:02 <therp> nominolo: that's at least what a friend told me when chatting about llvm
07:48:05 <nominolo> therp: that's even less specified
07:48:16 <nominolo> therp: the binary rep, i mean
07:48:37 <njbartlett> osfameron: Not that I know of, but I haven't looked much either.
07:48:39 <nominolo> therp: the intended use is via their C++-classes
07:48:43 <therp> nominolo: that wouldn't hurt, when using the API
07:49:01 <therp> nominolo: I heard there are haskell bindings.. so that would ease the job certainly
07:49:07 <nominolo> therp: i'd start with emitting text, and then later try the binary format
07:49:22 <nominolo> therp: i started some, but bos released his first :)
07:50:11 <therp> nominolo: I would rather go via the haskell bindings, generate an AST in memory, and that dump into a file by some API call..
07:50:27 <nominolo> therp: that was my plan
07:50:37 <nominolo> it's not too hard, actually
07:50:40 <therp> nominolo: great :) (to see two people working on the same binding, in other languages you have to beg someone to do it, if you don't have time)
07:51:08 <nominolo> well, so far we didn't work on the same code ;)
07:51:35 <therp> details details :)
07:52:07 <nominolo> i was considering to use it the other way, though.  that is, i wanted to use gcc-llvm and generate code for a custom platform
07:52:29 <nominolo> but the existing Mips -> custom code part still seems simpler
07:52:48 <nominolo> but, once you have the parser, writing a pretty printer is trivial
07:53:17 <olsner> so, we have work on a LLVM backend in ghc? or a haskell API for writing llvm code? or are we talking about a haskell API for *reading* llvm code?
07:53:20 <therp> what's gcc-llvm?
07:53:45 <therp> olsner: the first (backend) using the second (haskell bindings of llvm)
07:53:49 <nominolo> GCC patched to generate LLVM code, instead of binaries
07:54:04 <therp> nominolo: ah nice
07:54:27 <olsner> ah, okay, I'll be wanting to use the second when I actually get going again on my C++ compiler
07:54:31 <nominolo> therp: they are working on a better C-compiler, too.  "clang"
07:55:10 <nominolo> therp: where "better" mostly "faster"
07:55:40 <sizur> Hackell
07:55:55 <nominolo> ?
07:56:02 <quicksilver> dcoutts_: I agree those are improvementrs.
07:56:07 <quicksilver> dcoutts_: they also sound like challenges :)
07:56:09 <quicksilver> dcoutts_: good luck!
07:56:27 <quicksilver> olsner: there are reasons why LLVM may not be a good target for GHC.
07:56:39 <quicksilver> olsner: having said that, I believe people have worked on it.
07:57:18 <nominolo> quicksilver: llvm is not much useful than assembler for GHCs purposes
07:57:24 <therp> I should have a look at the intermediate representation that LLVM uses..
07:57:43 <nominolo> quicksilver: LLVM's optimizations are not very suitable for Haskell, i'd say
07:58:14 <quicksilver> nominolo: I think there are respects in which LLVM is actually quite a bit worse than assembler.
07:58:25 <nominolo> quicksilver: but you could get portable binaries for free
07:58:26 <quicksilver> nominolo: because it abstracts away stuff which GHC doesn't want to be abstracted.
07:58:34 <quicksilver> well that's true.
07:58:36 <nominolo> quicksilver: that, too
07:58:57 <therp> quicksilver: what would be 'that stuff'? I'm sure there is plenty of it.
07:59:25 <nominolo> my use would be as a compiler backend, possibly for runtime-codegen in DSLs
07:59:55 <quicksilver> therp: http://www.haskell.org/pipermail/glasgow-haskell-users/2006-December/011794.html
08:00:00 <nominolo> therp: like using %esi for special purposees
08:00:01 <therp> I would make a Lisp styled repl :)
08:00:05 <quicksilver> I don't really know personally, I'm just relayign stuff I've heard.
08:00:16 <therp> oh there is a thread nice, thanks quicksilver
08:00:41 <quicksilver> also spj's response (next in thread afte that)
08:01:02 <Cin> hpaste: url
08:01:03 <hpaste> Haskell paste bin: http://hpaste.org/
08:01:28 <nominolo> quicksilver: interesting
08:01:31 <therp> but shouldn't LLVM be faster (because of at least some optimization) than GHCi bytecode?
08:01:54 <nominolo> therp: a bit
08:02:45 <nominolo> therp: but haskell allows very different kinds of optimizations compared to, say, C
08:03:07 <quicksilver> ghci bytecode operates on data in the ame basic format as ghc compiled code
08:03:09 <quicksilver> IIUC
08:03:19 <quicksilver> and that's quite efficient
08:04:02 <nominolo> quicksilver: it usually just leaves out the inlining/rewriting/... stuff, right?
08:04:27 <quicksilver> I'm not sure what the code looks like, in detail.
08:04:38 <therp> nominolo: these optimizations are run before any intermediate Cmm code is generated, afaik.. so we won't lose that part of GHC
08:04:40 <quicksilver> but the data rep is very important for good performance.
08:05:09 <nominolo> therp: yes, but you can't run many if you want incremental changes
08:05:40 <therp> nominolo: incremental changes as in reloading parts of the code?
08:05:44 <nominolo> therp: yep
08:06:02 <nominolo> therp: that's what you'll want for a "real" REPL, right?
08:06:14 <nominolo> otherwise REPL = ghci ;)
08:06:15 <shag> @pl (\s n -> n + size s)
08:06:15 <Cheiron> (+) . size
08:06:54 <nominolo> bbl
08:07:43 <therp> nominolo: yes true, but I'd say we should keep a "base-line" unoptimized version around, let the optimizer work on the code that generates methods that can be used under some assumptions like arg1,arg2 in registers x,y.. if the precondition can't be met just use the baseline version, or recompile to generate another copy of foo that can be used with different assumptions
08:10:15 <sarah_> dang lambdabots dead :(
08:10:32 <quicksilver> Cheiron is around though
08:10:35 <quicksilver> > 1 + 2 + 3
08:10:37 <Cheiron>  6
08:10:44 <sarah_> ah cool
08:11:19 <glen_quagmire> > --1
08:11:19 <Cheiron>   parse error on input `}'
08:11:46 <glen_quagmire> > -(-1)
08:11:48 <Cheiron>  1
08:12:06 <mauke> > join (.) negate 1
08:12:07 <Cheiron>  1
08:12:52 <glen_quagmire> :i join
08:13:44 <sarah87> erg i registerd but its still not responding to me :(
08:14:44 <glen_quagmire> > join (.) negate 1
08:14:46 <Cheiron>  1
08:14:54 <salparot> @bot
08:14:54 <Cheiron> :)
08:14:54 <sizur> @type join
08:14:56 <Cheiron> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:14:58 <glen_quagmire> that doesn't work on 6.1
08:15:01 <byorgey> sarah87: you mean with nickserv?
08:15:18 <mauke> glen_quagmire: 6.6.1?
08:15:28 <glen_quagmire> no. it's wierd. i have 6.8.1
08:15:38 <mauke> :m +Control.Monad.Reader
08:15:40 <glen_quagmire> i did :m Control.Monad
08:15:57 <byorgey> glen_quagmire: you might also need Control.Monad.Instances
08:15:59 <quicksilver> sizur: probably means Cheiron isn't registered...
08:16:26 <glen_quagmire> oh, :m Control.Monad.Reader works
08:16:28 <quicksilver> glen_quagmire: Control.Monad doesn't contain the reader instance
08:16:33 <quicksilver> ou need Reader or Instances
08:17:23 <sarah87> byorgey: ya
08:18:03 <byorgey> sarah87: what's not responding to you? Cheiron?  or nickserv?
08:18:07 <sizur> i think join polutes namespace. joinM would be a better choice
08:18:11 <sarah87> cheiron
08:18:17 <byorgey> sarah87: ah
08:18:21 <glen_quagmire> oneday i'll write tutorial on monads too after i understand them
08:18:25 <mauke> sizur: eww
08:18:31 <sizur> :P
08:19:09 <quicksilver> sizur: yuck :P
08:19:18 <glen_quagmire> > Control . Monad . join (.) negate 1
08:19:19 <Cheiron>   Not in scope: data constructor `Monad'
08:19:20 <byorgey> sarah87: strange, when I do a /whois on you it says you are identified
08:19:25 <fasta> I wrote a brute-force combinatorial algorithm, but it only does a few thousand iterations/second. All the data structures I use are optimal and there are zero useless indirections, the data representation is also minimal. Are computers just so slow or is this a Haskell thing (cache misses etc (can I check for cache-misses easily))?
08:20:00 <salparot> there should be a tinyurl-like site with a name and generated urls such that you can enter the generated urls on a cell phone without double-tapping any key
08:20:17 <sizur> fasta: if it's compiled by ghc, i'd question the 'all's
08:20:19 <byorgey> fasta: probably the elves in your processor are tired.  try sprinkling some magic pixie dust around.
08:21:06 <salparot> could be you're doing too much work and should be more lazy
08:21:13 <quicksilver> fasta: a few thousand interations a second is typical for some kinds of algorithm a few million per second is typical of others
08:21:24 <quicksilver> how much work is each iteration? :)
08:21:29 <dons> ?users
08:21:29 <Cheiron> Maximum users seen in #haskell: 428, currently: 423 (98.8%), active: 16 (3.8%)
08:21:35 <dons> interesting..
08:21:51 <quicksilver> dons: where's your bot? :)
08:22:01 <olsner> @seen lambdabot
08:22:01 <Cheiron> I haven't seen lambdabot.
08:22:13 <dons> looks like code rebooted or something
08:22:17 <byorgey> \o/
08:22:20 <olsner> lambdabot: welcome back!
08:22:21 <dons> Cheiron: @part #haskell
08:22:21 <Cheiron> Not enough privileges
08:22:24 --- mode: ChanServ set +o dons
08:22:27 --- kick: Cheiron was kicked by dons (dons)
08:22:33 <byorgey> hehe
08:22:38 --- kick: Cheiron was kicked by dons ( i hope you understand)
08:22:43 <dons> oh man!
08:22:44 --- mode: ChanServ set -o dons
08:22:48 <sizur> first kick of the year!
08:22:58 <idnar> dons: try /remove
08:22:59 <byorgey> whose bot is Cheiron?
08:23:05 --- mode: ChanServ set +o dons
08:23:10 <ehird> persistant
08:23:26 <ehird> [dramatic pause]
08:23:27 <byorgey> @bot
08:23:27 <Cheiron> :)
08:23:27 <lambdabot> :)
08:23:27 <olsner> sizur: you missed last week's troll
08:23:28 --- mode: dons set -b *!i=JavaUser@*
08:23:29 <glen_quagmire> Cheiron: who's your daddy?
08:23:29 <sarah87> fasta: the optimal algorithm in haskell may be different than the same one in c++ or whatever
08:23:36 <sizur> olsner: yep
08:23:37 --- mode: dons set +b *!*i=svein@*.customer.alfanett.no
08:23:37 --- kick: Cheiron was kicked by dons (thanks!)
08:23:45 <ehird> cheiron is in ##c
08:23:49 <ehird> there's something wrong with that
08:23:51 --- mode: ChanServ set -o dons
08:23:52 <dons> heh
08:23:53 <idnar> heh
08:23:58 <dons> lambdabot taking over
08:24:04 <mauke> byorgey: Baughn's
08:24:04 <glen_quagmire> we could have started a botwar
08:24:28 <byorgey> ah
08:24:42 <fasta> dons: the users command should take into account bots.
08:24:57 <FunctorSalad> really stupid question here :( why does this not terminate rather than throwing an exception "main = getLine >>= readFile >>= putStr" when called with an non-existent filename?
08:25:03 <glen_quagmire> -- > putStr "> putStr \"> putStr ...
08:25:07 <ehird> the onnly fun thing to do with multiple bots is an iterating quine.
08:25:18 <sarah87> @type IO
08:25:19 <totimkopf> thanks for all your help guys, i will be joining you all soon again! time for farscape ;)
08:25:20 <lambdabot> Not in scope: data constructor `IO'
08:25:39 <ehird> specifically, a program "!trigger-for-bot1 ..." that produces a program "!trigger-for-bot2 ...", which when listened to by bot2, produces the original command
08:25:46 <ehird> got one of them going a while ago.
08:26:00 <ehird> double points for every bot you add to the chain
08:26:20 <olsner> I'd like to see a C bot ,-)    > *(int*)0 | [quit] C-Bot (SIGSEGV)
08:26:46 * dejones_ just checked out the "Haskell School of Expression" from my University Engineering Library.  :)
08:27:11 <olsner> ehird: was that the sarahbot quote I've seen from lambdabot?
08:27:24 <olsner> @quote sarahbot
08:27:24 <lambdabot> sarahbot says: sarahbot: later tell lambdabot @quote sarahbot
08:27:26 <byorgey> FunctorSalad: it throws an exception for me.
08:27:29 <ehird> olsner: no
08:27:33 <ehird> olsner: it was in #esoteric
08:27:42 <olsner> ooh, there's an #esoteric?
08:27:46 <ehird> yes
08:27:58 <ehird> olsner: you're on the wiki right?
08:28:07 <byorgey> dejones_: =D
08:28:07 <ehird> i seem to remember your name from there.
08:28:12 <olsner> ehird: esolangs.org, yeah
08:28:28 <ehird> olsner: yep, that's #esoteric
08:28:59 <dejones_> byorgey: yah, the tutorials just weren't enough for me...
08:28:59 <DRMacIver> olsner: I think #c++ actually has a C++bot.
08:29:12 <ehird> DRMacIver: #c has a bot written in C but it doesn't evaluate C.
08:29:18 <dejones_> byorgey: I keep struggling on the syntax, so I need full programs and more details.
08:29:25 <byorgey> dejones_: fair enough.
08:29:28 <olsner> DRMacIver: that evaluates C++ code?
08:29:33 <ehird> actually once you have a parse tree a c interpreter, sans libs, is pretty trivial
08:29:35 <DRMacIver> ehird: No, I've definitely read about a bot which evaluates C or C++. It's written in Haskell. :)
08:29:36 <ehird> it's... not a big language
08:29:48 <byorgey> dejones_: feel free to ask lots of questions in here, of course. =)
08:29:56 <FunctorSalad> byorgey: thanks. odd...
08:30:09 <DRMacIver> olsner: I think so. It uses system tracing to prevent it from doing Bad Things
08:30:14 <byorgey> FunctorSalad: indeed.  what version of ghc/platform/-O level/etc.?
08:30:22 <FunctorSalad> byorgey: oh, I'm stupid. it reads from stdin, not from command line arguments ;)
08:30:30 <FunctorSalad> doh
08:30:32 <byorgey> FunctorSalad: um... yes. =)
08:31:35 <byorgey> "help! I wrote this program 'main = getLine >>= putStr' and when I run it it doesn't do anything, it just sits there!' ;)
08:31:38 <dejones_> byorgey: yeah, the channel has been immensely helpful.
08:31:53 <DRMacIver> Ah, here we go: http://www.xs4all.nl/~weegen/eelis/geordi/
08:32:16 <dejones_> byorgey: The sad thing is that I am a master's student in computer science engineering, so it annoys me that I'm struggling with Haskell.  I'm quite good at C!  :)
08:32:17 <byorgey> dejones_: glad to hear it!
08:33:18 <byorgey> dejones_: don't let it bother you.  Haskell is so different from C and its ilk that even the smartest Haskell hacker had to struggle with it initially.
08:33:33 <mux> amen to that
08:33:49 <quicksilver> C is so different from Haskell than even the smartest haskell programmer finds it extremely hard to learn C.
08:33:51 <byorgey> dejones_: just view it as a fun challenge rather than an affront to your intelligence =)
08:33:55 <dejones_> quicksilver: lol
08:34:05 <dejones_> byorgey: yep, I love a challenge.
08:34:08 <mux> Haskell is the only language I ever learnt that made me feel unacceptably srtupid
08:34:11 <quicksilver> C is just such a strange, illogical and foolish language.
08:34:23 <dejones_> mux: exactly
08:34:40 <mux> but this is also one of the best motivation
08:34:53 <dejones_> I read the intro for the "Haskell Tutorial for C programmers.."  The guy was very funny that this was going to be very painful.
08:34:53 <dejones_> lol
08:35:02 <dejones_> quicksilver: I love C  :)
08:35:17 <dejones_> I can't help but enjoying being close to the machine.
08:35:27 <ehird> dejones_: you want ASM
08:35:29 <ehird> :D
08:35:34 <quicksilver> I was joking to some extent.
08:35:35 <mux> dejones_: I found this passes with time :-)
08:35:41 <quicksilver> Certainly I learnt C before haskell myself.
08:35:46 <dejones_> ehird: ha, well, maybe not that tedious of a language.
08:35:48 <dons> kinda cute, http://reddit.com/r/programming/info/66d1p/comments/
08:35:50 <quicksilver> but there is a nugget of seriousness there.
08:36:08 <mux> when I was a kid, I was fond of asm; then I was fonder of C, then I discovered haskell
08:36:09 <ricky_clarkson> The machine is on my lap, I don't want to get any closer to it.
08:36:09 --- mode: ChanServ set +o dons
08:36:14 --- mode: dons set -b *!*i=svein@*.customer.alfanett.no
08:36:15 <mux> and then I thought "shit! there are actually people who _design_ languages?"
08:36:16 --- mode: ChanServ set -o dons
08:36:57 <dejones_> :)
08:37:01 <dons> also nice, http://reddit.com/r/programming/info/66d1y/comments/ state monads
08:37:09 * BMeph thinks that if Haskell made mux feel stupid, then he should try Hebrew... ;)
08:37:29 <mux> BMeph: I like to feel stupid when I know I can reach a point where I won't be anymore :-)
08:37:35 <mux> hebrew is probably a lost cause for me
08:37:43 <dejones_> well, I am very interested in the ability of a language, Haskell, to make concurrent / parallel execution safe... I think that with multiple core processors this will become more and more important.
08:37:55 <mux> yeah
08:37:57 <ehird> hm
08:38:02 <ehird> i ought to write a c evaluator
08:38:04 <mux> anyone who's done some amount of C with pthreads knows how sucky it is
08:38:06 <ehird> is there a C parser in haskell? :-)
08:38:09 <mux> how incredibly unsafe, touchy, and so on
08:38:19 <BMeph> mux: Since I'm going through the Abstract Algebra Wikibook currently, I guess I'm the same way... ;)
08:38:36 <dejones_> mux: definitely...  threading overall is a serious pain.
08:39:32 <dejones_> but anyway, I'm going to read this Haskell book
08:39:32 <mux> threading in C *so* hurts maintainability
08:39:39 <dejones_> later.
08:39:48 <byorgey> dons: how do you find this stuff?  do you have some sort of search engine looking for haskell-related keywords mailing you new hits?
08:39:54 <mux> you want to add a field to some struct, and you realise you're going to need to completely overhaul the locking protocol
08:39:59 <mux> hate that.
08:40:02 <dons> rss feeds, byorgey
08:40:08 <dons> via google. so yes.
08:40:20 <Saizan> ehird: there are some partial parsers inside tools like c2hs, but no standalone library afaik
08:40:21 <byorgey> dons: ok, right.
08:40:26 <dons> "rotonyms in haskell",  http://reddit.com/r/programming/info/66d2n/comments/
08:40:39 <mux> you realize you're going to lock two of your objects at once, and that's it, you need to completely revamp locking
08:41:00 <ehird> Saizan: aww
08:41:09 <ehird> Saizan: if i had a nice parse tree i could do it trivially
08:41:24 <BMeph> I guess I'm lucky in learning a lot of differently-organized comp. languages early. First BASIC and Pascal, then COBOL and FORTRAN.
08:41:35 <fasta> mux: sounds like it could use a declarative language. Probabably someone else thought of that already. Is it impossible?
08:41:40 <BMeph> After those, Forth and C seemed refreshing. ;)
08:41:54 <dejones_> is GHC written mostly in C?  ;)
08:42:05 <fasta> dejones_: most of the RTS is.
08:42:09 <dejones_> RTS?
08:42:17 <Saizan> the runtime system
08:42:20 <mux> fasta: sorry, I don't follow you here?
08:42:30 <dejones_> Saizan: ahh.
08:42:52 <dejones_> Does the compiled Haskell code generate C?
08:42:54 <Saizan> but the rest of the compiler (which is the most part) is in haskell
08:42:58 <dejones_> * in GHC
08:43:08 <quicksilver> dejones_: that used to be the main path
08:43:11 <fasta> mux: the whole idea of locking is to make sure that only one thread (or set of threads) can access some value at the same time, right?
08:43:16 <quicksilver> dejones_: but now the main path is to directly generate machine code
08:43:23 <dejones_> quicksilver: wow.
08:43:24 <quicksilver> dejones_: teh code which generates C still exists though.
08:43:33 <mux> fasta: yes, the whole idea of locking is synchronization
08:43:46 <ehird> GHC is written in Haskell+GHCexts and compiles to something, depending on your platform
08:43:50 <mux> quicksilver: I thought GHC was going to generate C-- ?
08:44:13 <dejones_> cool, thanks guys
08:44:17 <dejones_> later (again)  ;)
08:44:30 <fasta> mux: so, if you can say to the machine: I want that only at most one thread can touch this value at the same time and the compiler then implements the locking for you, you would have one problem less.
08:44:31 <quicksilver> mux: well, yes it does
08:44:44 <sizur> "(This doesn~t exactly match conceptually because Haskell doesn~t have nominal overloading.)" -- what does this quote mean??
08:44:46 <quicksilver> mux: but the code which converts C-- to native code is, also, part of GHC.
08:44:54 <mux> fasta: well yeah, but my point was that Haskell relieves me from most of these problems
08:44:54 <quicksilver> mux: so it depends a bit where you draw the line around "ghc" :)
08:45:04 <mux> oh, indeed :)
08:45:06 <sizur> what's what classes are for
08:45:21 <quicksilver> ehird: I think GHC is pretty much written in haskell98, isn't it?
08:45:32 <mux> fasta: when I can use haskell of course :-)
08:45:35 <ehird> quicksilver: you can't run it with hugs
08:45:35 <quicksilver> ehird: isn't it technically possible (although not easy) to bootstrap ghc with nhc?
08:45:42 <ehird> quicksilver: beats me
08:45:43 <mux> I could not convince fellow freebsd committers to switch to writing the kernel in haskell yet :-)
08:45:55 <mux> surprisingly
08:45:56 <quicksilver> ehird: well hugs can't run the C or C-- bits...
08:45:57 <dejones_> mux: why?  :P
08:46:04 <ehird> we need a c interpreter like hugs but ghc-compatible
08:46:09 <ehird> for the sole purpose of bootstrapping ghc
08:46:41 <mux> dejones_: the fact that we already have a several millions C lines of code kernel maybe has something to do with it :-P
08:46:54 <fasta> mux: to me it seems that a source to source transformation of the code with extra annotations like described with a smart locking compiler should to the trick too, but I haven't given such a compiler much thought.
08:47:07 <mux> fasta: that's about what OpenMP does
08:47:37 <fasta> mux: well, good for them. Any limitations?
08:47:42 <mux> people are actually trying to make threading in C/C++ more usable; OpenMP is one of these projects, Intel's TBB is another
08:47:52 <mux> I don't know them well enough to comment
08:47:54 <dejones_> mux: lol, yea yea, like that matters ;)
08:48:10 <fasta> mux: ok, thanks. I knew about those projects, though.
08:48:26 <mux> fasta: OpenMP basically works with #pragma's sprinkled here and there, telling the compiler "this is going to be shared", etc
08:49:02 * ehird wonders what he'd need for a c parse tree
08:49:06 <ehird> i can write the parser later :P
08:49:08 <fasta> The "this is going to be shared" can also be automated.
08:49:23 <quicksilver> ehird: I find writing a parser the easiest way to define the AST.
08:49:30 <ehird> quicksilver: but... for C!
08:49:35 <quicksilver> ehird: the AST writes itself as you go along. Hmm. what do I need for this part?
08:49:41 <ehird> but C!!!
08:50:06 <fasta> Hmm, well, partly, since you would have the Halting problem....
08:50:31 <mux> fasta: I don't quite see how this would be possible, but I guess it would at least be quite tricky
08:50:55 <fasta> If you want to parse C, use an existing parser and read the AST back in to Haskell or some other language.
08:51:10 <quicksilver> ehird: I've written most of a C++ parser in perl, of all languages.
08:51:12 <ehird> fasta: i imagine e.g. gcc's parsetree is fugly
08:51:18 <quicksilver> It really isn't particularly hard.
08:51:20 <fasta> ehird: the world is bigger than gcc.
08:51:25 <vincenz> quicksilver: erm?
08:51:27 <vincenz> quicksilver: eh?
08:51:28 <ehird> fasta: see 'e.g.'
08:51:35 <ehird> quicksilver: isn't C++ parsing turing complete?
08:51:36 <ehird> you can
08:51:42 <vincenz> c++ parsing is ambiguous
08:51:43 <fasta> ehird: no
08:51:44 <ehird> 't tell whether it's valid code without fumbling with stuff
08:51:49 <vincenz> until you have your full parse tree and do a name-lookup
08:51:56 <czakey> > replicateM 5 [1,2,3]
08:51:57 <quicksilver> well you parse something slightly weaker than C++
08:51:57 <lambdabot>  [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,1,3],[1,1,1,2,1],[1,1,1,2,2],[1,1,1,2,3],[1,...
08:52:12 <quicksilver> you parse the kind of ambiguous superset of C+++
08:52:19 <quicksilver> then later you check if it makes sense
08:52:21 * vincenz nods
08:52:24 <vincenz> that's how elsa/elkhound does it
08:52:26 <quicksilver> (which I didn't bother with)
08:52:27 <vincenz> quicksilver: it doesn't look simple tho
08:52:43 <quicksilver> I was mainly trying to parse large constant 'struct's
08:52:46 <vincenz> ah
08:52:47 <RayNbow> http://yosefk.com/c++fqa/web-vs-c++.html#misfeature-2 <-- C++? :p
08:52:48 <lambdabot> Title: C++ FQA Lite: C++ criticism by other people
08:52:49 <quicksilver> to get some static data out of some code
08:52:49 <czakey> > map (++) replicateM 5 [1,2,3]
08:52:50 <lambdabot>  Couldn't match expected type `[[a]]'
08:52:59 <quicksilver> I just ignored anythign which didn't look like a struct :)
08:53:08 <czakey> > map (++) replicateM 5 [1,2]
08:53:08 <quicksilver> but I did parse the type definition as well as the value.
08:53:08 <lambdabot>  Couldn't match expected type `[[a]]'
08:53:25 <byorgey> czakey: maybe you want 'concat'?
08:53:32 <czakey> yup
08:53:34 <byorgey> > concat $ replicateM 5 [1,2]
08:53:34 <lambdabot>  [1,1,1,1,1,1,1,1,1,2,1,1,1,2,1,1,1,1,2,2,1,1,2,1,1,1,1,2,1,2,1,1,2,2,1,1,1,2...
08:53:34 <czakey> :]
08:53:48 <czakey> thx
08:54:15 <idnar> > foldr1 (++) $ replicateM 5 [1,2]
08:54:15 <lambdabot>  [1,1,1,1,1,1,1,1,1,2,1,1,1,2,1,1,1,1,2,2,1,1,2,1,1,1,1,2,1,2,1,1,2,2,1,1,1,2...
08:55:03 <vincenz> > replicateM 2 [1,2]
08:55:04 <lambdabot>  [[1,1],[1,2],[2,1],[2,2]]
08:55:07 <vincenz> > replicateM 3 [1,2]
08:55:08 <lambdabot>  [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
08:55:20 <vincenz> ah, permutations :)
08:55:23 <jedbrown> Can one request better than default alignment with mallocForeignPtrArray?
08:55:44 <dons> hmm
08:55:46 <byorgey> vincenz: I don't think permutations is the right word...
08:55:47 <Taejo> where is the (-> a) monad instance declared?
08:55:51 <dons> don't think so jedbrown
08:55:55 <byorgey> Taejo: Control.Monad.Reader
08:56:01 <vincenz> byorgey: point
08:56:04 <byorgey> Taejo: or Control.Monad.Instances
08:56:25 <jedbrown> dons: The hack I've thought of is a newtype with the needed alignment followed by a cast.
08:56:32 <Taejo> byorgey: thanks
08:56:38 <byorgey> vincenz: actually, I'm not quite sure if there is a word for that... 'combinations with replacement'?
08:56:54 <jedbrown> dons: SIMD instructions only work with very good alignment.
08:57:22 <shepheb> replicateM n [0..b] is all n-digit numbers in base (b+1) broken into digits, in ascending order, to look at it another way
08:58:07 <bringert> dcoutts_: did you want to talk to me? I left for the office right after you said hi
08:58:57 <byorgey> shepheb: ah, indeed, that's a good way to look at it
08:59:40 <Tac-Tics> :t replicateM
08:59:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
09:00:27 <stefanha> jedbrown: you are working on Haskell SIMD stuff?  I'm working on library-level support for SIMD (hopefully AltiVec and SSE2).
09:00:46 <byorgey> replicateM n m = sequence (replicate n m)
09:01:08 <jedbrown> stefanha: Actually no, but I'm binding to FFTW which would like to be able to do SIMD.
09:01:26 <stefanha> jedbrown: aha :).  I just allocate + 15 bytes and then aligned the pointer.
09:02:23 <jedbrown> stefanha: That would work too, although I like the newtype approach better.
09:02:35 <stefanha> jedbrown: yeah, it's a hack :)
09:14:48 <paczesiowa> why haskell doesn't have modules and functors like ocaml?
09:16:13 <puusorsa> because it's not ocaml?
09:16:33 <anX> paczesiowa: TRAITOR!
09:16:43 <ricky_clarkson> puusorsa: That's not going to go down well with Jon Harrop.
09:16:57 <bos> paczesiowa: http://www.haskell.org/pipermail/haskell/2004-August/014463.html
09:16:58 <lambdabot> Title: [Haskell] Applicative translucent functors in Haskell
09:17:12 <Saizan> translucent?
09:18:32 <bos> Saizan: opaque in some places, transparent in others
09:18:50 <FunctorSalad> seems like Text.Regex ignores instructions to be non-greedy
09:19:21 <bos> FunctorSalad: Text.Regex is deprecated
09:19:45 <FunctorSalad> oh
09:20:08 <shag> what is the easiest way  to figure out the size of a particular data structure in a running program?
09:20:11 <paczesiowa> bos: before I read&understand (or die tryin) that, can you tell me if it's equally powerful like ocaml's modules? using parsec's language module with haskell is ugly (lots of stupid rebinding code) and it's much nicer with ocaml (apparently it's the only nicer thing in ocaml)
09:20:46 <bos> paczesiowa: no, it's not as elegant, merely a demonstration that haskell's type system can give you the same capabilities without *too* much ugliness.
09:20:59 <bos> for it to be pretty, we'd need syntactic support.
09:21:16 <FunctorSalad> bos: what is the recommended replacement then?
09:21:59 <bos> FunctorSalad: the hierachy beneath Text.Regex - Text.Regex.Base, Text.Regex.Posix, etc
09:22:17 <bos> FunctorSalad: dons also wrote a replacement library that binds to pcre, which is a bit easier to use
09:22:25 <dejones_> umm, can something like "let x = x + 1; x" run forever?
09:22:38 <Valodim> sure why not
09:22:54 <dejones_> I guess it won't eventually run out of some resource?
09:23:02 <bos> dejones_: let x = x + 1 in x is detected by ghc and blackholed
09:23:16 <vincenz> what language option do you need for bangpatterns
09:23:18 <bos> i.e. it will block forever, but it won't do anything
09:23:26 <twanvl> it will eventually run out of time :)
09:23:33 <bos> vincenz: -XBangPatterns
09:23:40 <dejones_> bos: ahh...  what if you gave "x = x + 1; x" to the lamdabot?  ;)
09:23:46 <bos> dejones_: try it
09:23:51 <vincenz> bos: thx
09:23:54 <dejones_> > let x = x + 1; x
09:23:54 <lambdabot>  Parse error at end of input
09:24:03 <dejones_> I guess I did that wrong?
09:24:04 <RayNbow> > let x = x + 1 in x
09:24:05 <lambdabot>  Exception: <<loop>>
09:24:06 <bos> dejones_: you might want to fix the syntax
09:24:18 * dejones_ is a Haskell noob.
09:24:31 <bos> that's why we're here!
09:24:33 <dejones_> :)
09:24:38 <dejones_> lambdabot is smart.
09:24:39 <dejones_> hehe
09:24:49 <RayNbow> hmm, ghci 6.8.2 hangs at "let x = x + 1 in x"... until I hit Ctrl+C
09:25:03 <byorgey> dejones_: it is quite possible to create an expression which will never terminate, though.
09:25:09 <vincenz> RayNbow: that's an infinite loop
09:25:17 <byorgey> > let f n = f (n + 1) in f 0
09:25:24 <lambdabot> Terminated
09:25:29 <dejones_> lol
09:25:43 <dejones_> what is "in" doing?
09:25:43 <idnar> > fix (+1)
09:25:44 <lambdabot>  Exception: <<loop>>
09:25:47 <byorgey> dejones_: lambdabot kills things after a certain number of seconds, but if you ran it in ghci you'd have to Ctrl-C it.
09:25:47 <RayNbow> vincenz: I wish ghc was lazy enough to say it was just an infinite loop... but alas, HALT is not decidable :p
09:25:51 <idnar> dejones_: it's part of the let syntax
09:25:52 <bos> RayNbow: that's the blackholing i mentioned
09:26:03 <bos> RayNbow: if you check, you'll notice it's not consuming any CPU
09:26:03 <byorgey> dejones_: let <bindings> in <expression>
09:26:07 <paczesiowa> bos: but is there any important reason not to have fancy module system?
09:26:12 <dejones_> byorgey: thanks
09:26:24 <FunctorSalad> @botsnack
09:26:25 <lambdabot> :)
09:26:29 <bos> paczesiowa: no, it would make sense. the type system supports it. it just hasn't been done.
09:26:31 <RayNbow> bos: hmm, true...
09:26:54 <dejones_> thanks again :)
09:26:56 <dejones_> back to reading
09:28:28 <Saizan> paczesiowa: the problem is that those overlaps with typeclasses and with a good record system, and there's not consensus on a design afaiu
09:29:48 <paczesiowa> Saizan: :-(
09:30:58 <RayNbow> oh btw bos, what's the ETA of the RW Haskell book? :)
09:31:27 <bos> RayNbow: just like an open source project: when it's done!
09:32:02 <RayNbow> bos: ah, so no real concrete plans... that's ok :)
09:32:54 <pejo> bos, how difficult was it to convince the publisher?
09:33:04 <bos> pejo: trivial
09:37:12 <dejones_> > let b = ['z', 42] :: [Char, Integer]
09:37:12 <lambdabot>  Parse error at "," (column 27)
09:37:18 <dejones_> why is that a parse error?
09:37:53 <shag> because you cant have different type in one list
09:37:57 <ToRA> let b = ['z', 42] in b
09:38:06 <ToRA> parse error because you don't have the "in ..." bit
09:38:34 <ToRA> it's also a type error because you don't have an instance for Num Char available...
09:38:40 <ToRA> >  let b = ['z', 42] in b
09:38:41 <lambdabot>   add an instance declaration for (Num Char)
09:38:41 <lambdabot>     In the expression: 42
09:38:41 <lambdabot>     In...
09:39:18 <dejones_> alright, so Haskell list elements must have the same type, otherwise I have to define a class for it?
09:39:56 <ToRA> erm, all list elements must have the same type
09:40:18 <gnomnain> you can use a tuple instead : ('z',42) :: (Char,Integer)
09:40:45 <dejones_> > let b = [('z', 42), ('a', 1)] :: [(Char, Integer)]
09:40:46 <lambdabot>  Parse error at end of input
09:40:48 <hpaste>  vali pasted "?" at http://hpaste.org/5184
09:40:57 <ToRA> in ....
09:40:59 <dejones_> > let b = [('z', 42), ('a', 1)] :: [(Char, Integer)] in b
09:40:59 <lambdabot>  [('z',42),('a',1)]
09:41:02 <dejones_> :)
09:41:07 <dejones_> thanks ToRA
09:41:23 <Lemmih> vali: '1'.
09:42:10 <byorgey> vali: 1 is a numeric value; isDigit can only be called on Char values such as '1', 'a', and so on.
09:42:22 <vali> oh, i have to do that when it's expecting a character... thank you!
09:42:42 <vali> i got my haskell book in the mail today, so i'm trying to run some of the example code
09:42:58 <matthew_-> > let .... = "...." in ....
09:42:58 <lambdabot>  Parse error at "...." (column 5)
09:43:08 <dejones_> vali: what book did you get?
09:43:37 <vali> dejones_: it's called "Programming in Haskell" by Graham Hutton... i hope it's good. seems really good so far
09:43:41 <matthew_-> > let (....) = "...." in (....)
09:43:42 <lambdabot>  "...."
09:44:24 <byorgey> vali: I've heard only good things about it.
09:44:50 <quicksilver> if you're lucky you can even find the author on IRC and give him criticism directly :)
09:44:54 <quicksilver> although, not that often.
09:45:00 <quicksilver> @seen grahamhutton
09:45:00 <lambdabot> I saw grahamhutton leaving #haskell 3d 19h 53m 31s ago, and .
09:45:10 <dejones_> vali: cool, thanks.  :)  I'm reading "Haskell School of Expression" at this moment -- it was the only Haskell book in my Univ.'s Engineering library ;)
09:45:11 <JanglerNPL> I just got it as well, it's really good :)
09:45:20 <dejones_> I'm just glad they had a Haskell book.  :)
09:45:37 <hpaste>  jedbrown pasted "Problems with Storable instance for Complex" at http://hpaste.org/5185
09:45:50 <vali> though the book has mentioned "Integer" and "Integral".. is Integer a type and Integral a class? when i heard "Integral" i think about mathematical integration
09:45:56 <vali> dejones_: ah, great. is it any good?
09:45:59 <byorgey> vali: exactly.
09:46:00 <quicksilver> vali: yes.
09:46:11 <vali> quicksilver: i will tell him!
09:46:17 <dejones_> vali: seems good so far, but I just started reading it about 30min ago, so I'm not really far.
09:46:23 <byorgey> vali: Integral is a class, of which both Integer and Int (and a few other things) are instances.
09:46:26 <quicksilver> vali: Integral is a class containing Integer, Int, Word8, and more like that
09:46:56 <vali> aah, i see. thanks for the help! i'll go back to reading now
09:47:44 * byorgey wonders idly about the etymology of 'integral' as it is used in calculus
09:48:40 <jedbrown> Does anyone have suggestions regarding my paste, other than to write the instances explicitly for Float and Double?
09:48:54 <doserj> jedbrown: ScopedTypeVariables?
09:50:24 <Saizan> jedbrown: define foo :: Complex a -> a; foo = undefined, then sizeOf x = 2 * sizeOf (foo x)
09:50:26 <Cale> jedbrown: rather than using _, you could actually name the variable
09:51:31 <jedbrown> doserj: I think that worked.  Thanks.
09:52:00 <dons> jedbrown: there's stuff in Foreign.* to control alignment
09:52:03 <dons> via Storable
09:52:21 <ehird> if there's a monolithic haskell program, just in the Main module, should it be called "prog.hs" or "Prog.hs"?
09:52:23 <ehird> i think the former..
09:53:00 <jedbrown> dons: As in through the alignment function?
09:53:40 <dons> i think so.
09:53:43 <jedbrown> dons: alignment (undefined :: Double) = 4 on my machine, but it needs to be 16 for SIMD to work.
09:53:58 <dons> newtype Double Double128 ?
09:54:17 <dons> so you want to allocate pinned memory on the haskell heap to pass to C?
09:54:19 <vali> hmm, i like to use 2 spaces for indentation. some haskell code aligns the next line with whatever comes after = and such, giving many different levels of indentation... is it a bad idea to use 2 spaces for everything? i think it looks prettier that way
09:54:25 <jedbrown> dons: So I figured I would make a newtype with a Storable instance that is 16-byte aligned and allocate the array based on that, then cast it to Double.
09:54:33 <jedbrown> dons: Exactly
09:54:37 <dons> yep
09:55:16 <Cale> vali: you might have trouble lining certain things up.
09:55:48 <Cale> vali: But it's possible to do, just pretty constraining as to where you break lines.
09:56:42 <vali> Cale: i do it like this http://hpaste.org/5184#a1
10:00:14 <Cale> vali: How about a let statement with multiple declaration lines in the middle of one of those do-blocks? (That is, without the in part, otherwise it'd be a let-expression.)
10:00:54 <byorgey> Cale: what would be the problem with that?
10:01:12 <Cale> You might end up writing let on its own on a line :)
10:01:33 <Cale> Just to have to avoid indenting the successive lines of the body a little more.
10:02:41 <byorgey> Cale: ah, that's true.
10:03:46 <byorgey> vali: it's not how I would indent things, but it looks fine.  you'll find there isn't as much of a standardized indentation style in Haskell as there is in other languages.
10:06:00 <vali> i see. i'll keep using it as long as it doesn't give me any problems. it feels weird to have random indentation levels... 2 bytes, 5 bytes (odd number?), 4 bytes etc
10:09:06 <shepheb> @src groupBy
10:09:07 <lambdabot> groupBy _  []       =  []
10:09:07 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
10:09:07 <lambdabot>     where (ys,zs) = span (eq x) xs
10:11:01 <bos> @where parsec2
10:11:01 <lambdabot> I know nothing about parsec2.
10:11:04 <bos> @where parsec
10:11:04 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
10:11:07 <bos> hmph
10:11:12 <bos> @seen ddarius
10:11:13 <lambdabot> I saw ddarius leaving #haskell, #haskell-blah and #haskell-overflow 3d 8h 36m 20s ago, and .
10:11:23 <bos> ah, forgetful lambdabot
10:14:28 <ehird> "and ..."
10:14:31 <ehird> "uh ..."
10:15:34 <dejones_> EvilTerran: did you read Haskell School of Expression?  :)  It seems the way you were teaching me the other day is very similar to this book.
10:25:38 <vali> o
10:29:11 <BMeph> bos: Have you actually experimented with compiling Haskell using LLVM?
10:29:44 <dcoutts> BMeph: that's a seriously large task
10:30:22 <dcoutts> not something you can casually experiment with, though making a edsl in haskell to generate code via llvm would be much more straightforward
10:30:34 <dcoutts> similar to the existing harpy lib for code generation
10:30:58 <bos> BMeph: no, not at all.
10:33:30 <BMeph> dcoutts: Who said anything about being casual about it? :)
10:36:28 <BMeph> bos: Were you planning on doing anything more with it besides the binding? Say, making an LLVM-based harpy replacement?
10:36:46 <bos> BMeph: i haven't looked closely at harpy.
10:37:12 <shag> what is the most space-efficient way to store short string, ranging from 1-20 characters?
10:37:26 <shag> strings, even (a lot)
10:37:49 <BMeph> bos: But I have seen that you're very involved with LLVM. :)
10:38:02 <bos> BMeph: i have my fingers in many pies!
10:38:24 <BMeph> bos: You said it!
10:38:24 <bos> too many, in fact.  if you're interested in doing harpy-like stuff, send me patches.
10:39:22 <BMeph> I'm only mildly interested, I have more than enough side projects on my own as it is. :)
10:47:03 <vincenz> anyone tht can explain how to make coarbitrary instances?
10:47:32 <vincenz> andyjgill: you're the author of hpc?
10:47:59 <vincenz> andyjgill: dons suggested I contact you about a cute idea: overlay profiling information over the hpc-information, so that it can be seen as one colored webpag
10:49:41 <mauke> Foreign.C.Error, I am very disappointed by your mangling of errno values
10:50:55 <shepheb> @src foldr
10:50:56 <lambdabot> foldr k z xs = go xs
10:50:56 <lambdabot>     where go []     = z
10:50:56 <lambdabot>           go (y:ys) = y `k` go ys
10:52:15 <mauke> foldr _ z [] = z; foldr f z (x : xs) = f x (foldr f z xs)
10:59:03 <resiak> mauke: in what way is its mangling disappointing?
10:59:37 <mauke> | errno == eNOENT          = NoSuchThing
10:59:38 <mauke> | errno == eNXIO           = NoSuchThing
10:59:56 <mauke> that means my code can't really know why openFd failed
11:00:05 <dons> oh, interesting.
11:00:28 <mauke> also, tons of things map to ResourceExhausted
11:00:44 <mauke> even eAGAIN. wtf.
11:01:39 <dons> do your own more interesting binding, and submit it to the process?
11:03:37 <mauke> wouldn't that require changes to IOError?
11:04:16 <radix> mauke: eww. :-(
11:04:36 <radix> (wrt the ambiguous mapping)
11:04:53 <mauke> I don't really care for now because I actually need to ignore both ENOENT and ENXIO :-)
11:05:50 <pejo> mauke, is eAGAIN triggered when the syscall gets interrupted by a signal for example?
11:06:00 <mauke> yes
11:06:26 <jedbrown> So I've got the minimal FFT bits working, but I need to deal with thread safety sooner rather than later.  The library does a 2-step process: plan a transform, then execute it.  The planning phase is not thread-safe, so I need a global locking mechanism, but I want the user interface to be pure.  Any suggestions for how to go about this?
11:06:50 <mauke> how is it not thread-safe?
11:07:28 <jedbrown> The FFTW library says that only one thread may a planning functions at a time.
11:07:51 <mauke> ah, foreign binding
11:08:01 <dons> ok. so perhaps MVar wrap the foreign call
11:08:11 <dons> so that only one haskell thread can muck about at a time in that function
11:08:12 <jedbrown> (It does some heuristics and caches a result.)
11:08:30 <dons> the usual mechanism is a (hidden) top level MVar
11:08:31 <jedbrown> Yes, an MVar is natural, but how do I thread it around?
11:08:51 <dons> lock = unsafePerformIO $ newMVar ()
11:08:57 <dons> {-# NOINLINE lock #-}
11:09:14 <jedbrown> dons: Oh, cool.  Thanks.
11:09:16 <dons> then modifyMVar, make a call, and other threads will block till you're done
11:09:21 <dons> or withMVar, actually
11:09:34 <dons> its a fast, cheap powerful way to add value to the haskell side
11:09:34 <jedbrown> Yes, that'll work perfectly.
11:09:40 <dons> making the C lib safe for use.
11:09:49 <pejo> mauke, ah, that's sweet. Throwing away restarts will make SysV systems behave ..  'strange'.
11:10:01 <dons> thread safety, type safety, and purity are the best things a haskell lib can add on top of a C lib
11:11:26 <mauke> pejo: well, fdRead and fdWrite restart the C function automatically
11:11:31 <mauke> so it's not that big of a problem
11:13:06 <gwern> dons: you should seriously think about doing a hs-plugins release. gentoo's getting ready to remove it because of no upstream releases
11:13:24 <dons> i'd remove it.
11:13:34 <dons> why should it be in gentoo? it mostly unsupported.
11:13:58 <gwern> sure, but it works
11:14:04 <gwern> so why not?
11:34:06 <priester> Hi! I have a question about that prime sieve in haskell. I figured out, that it gets _really_ slow, if i look for primes over about 10.000.
11:34:17 <priester> Is there any possibility to get it faster?
11:34:40 <priester> If i want to sieve until 1.000.000, it seems to be impossible.
11:36:03 <sclv_> write a better sieve.
11:36:08 <astrolabe> priester: Which prime sieve?
11:36:50 <kosmikus> maybe http://www.haskell.org/haskellwiki/Euler_problems helps ...
11:36:51 <byorgey> priester: maybe check out http://haskell.org/haskellwiki/Prime_numbers .
11:36:51 <priester> sieve (x:s) = x : sieve [y <- s, mod x y /= 0]
11:36:51 <lambdabot> Title: Euler problems - HaskellWiki
11:37:09 * shepheb uses trial-division squaring. ie. list to 100, build to 10000 by trial division over the 100, build to 100M by trial division of the 10000
11:37:15 <sclv_> @go "basic number theory in haskell"
11:37:17 <lambdabot> http://www.polyomino.f2s.com/david/haskell/numbertheory.html
11:37:17 <lambdabot> Title: Basic Number Theory in Haskell
11:37:29 <sclv_> there's a nice wheel implementation here, airc.
11:38:24 <priester> Oh, wow. Thank you :)
11:39:07 <hpaste>  jedbrown pasted "Yikes! combinator soup" at http://hpaste.org/5186
11:39:37 <tinnus> hello again
11:39:58 <byorgey> priester: if that's not enough for you, you can also read about sieves and Haskell here: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/19699/focus=19879
11:39:59 <lambdabot> Title: Gmane Loom, http://tinyurl.com/2k2g83
11:40:00 <tinnus> i need a one-liner to compute factorials
11:40:11 <tinnus> for my lambdabot :)
11:40:33 <sclv_> @go "evolution of a haskell programmer"
11:40:35 <byorgey> hi tinnus.  is this an assignment?
11:40:36 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
11:40:36 <lambdabot> Title: The Evolution of a Haskell Programmer
11:40:38 <tinnus> @factorial 195
11:40:38 <lambdabot> Unknown command, try @list
11:40:43 <grahamhutton> priester: there is also a very nice paper in JFP about computing prime numbers by Colin Runciman
11:40:48 <grahamhutton> priester: http://citeseer.ist.psu.edu/cache/papers/cs/842/http:zSzzSzwww.cs.york.ac.ukzSz~colinzSzpaperszSzjfp97lw.pdf/runciman97lazy.pdf
11:40:49 <lambdabot> http://tinyurl.com/2p8u5d
11:41:00 <priester> ok, ok... I think, i have enough to read, yet :)
11:41:13 <sclv_> jedbrown: what is that paste supposed to be? it hurts eyes.
11:41:17 <priester> Thank you!
11:41:27 <byorgey> @quote drink
11:41:27 <lambdabot> Excedrin says: the Budweiser-Miller type inference algorithm; I'm drinking beer and inferring that it might be water
11:41:47 <tinnus> @quote mokus
11:41:48 <lambdabot> No quotes match. There are some things that I just don't know.
11:41:55 <jedbrown> sclv_: It's from the hmatrix source.  I was looking for something and its all routed through these combinators.
11:42:32 <tinnus> @help factorial
11:42:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:42:58 <sclv_> tinnus lambdabot doesn't have a default factorial command.
11:43:04 <byorgey> @quote byorgey hose
11:43:05 <lambdabot> byorgey says: sometimes asking #haskell for help can be like taking a drink from a fire hose
11:43:09 <byorgey> that's it =)
11:44:32 <tinnus> yeah, I wannaa make a > factorial command
11:44:40 <tinnus> so I can @factorial 195
11:44:49 <tinnus> then lambdabot will answer me!
11:45:11 <tinnus> i have a lambdabot-compatable on my private irc #
11:45:47 <mauke> @let factorial n = product [1 .. n]
11:45:49 <lambdabot> Defined.
11:45:52 <mauke> > factorial 195
11:45:53 <lambdabot>  2591899036156656511480987645585432937922090573952564787209169097471219681020...
11:48:03 <tinnus> thanks
11:48:04 <andyjgill> vincenz: Hi, sorry I was away from my keyboard. Yes I am the author of hpc
11:48:21 <vincenz> andyjgill: no problem
11:48:28 * tinnus gives 12v DC electricity to mauke for his help
11:48:53 <andyjgill> What might the overlay look like?
11:49:03 <dejones_> would ChanServ kick lambabot if we gave him factorial 1000?  for too large text?  ;)
11:49:07 <vincenz> andyjgill: might be interesting if, when you compile with -prof and run with +RTS -p, you get an overlay
11:49:12 <mauke> > factorial 1000
11:49:15 <lambdabot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
11:49:17 <vincenz> andyjgill: well consumption is between 0 and 100%
11:49:22 <dejones_> oh he does the ....
11:49:23 <vincenz> andyjgill: you could hot-color regions
11:49:30 <dejones_> man, this lambdabot is smart
11:49:30 <vincenz> (of code)
11:49:34 <dejones_> I'm trying to break him! ;)
11:49:35 <dejones_> lol
11:49:40 <idnar> dejones_: she, not he ;)
11:49:44 <dejones_> who wrote lambdabot?
11:49:47 <tinnus> brokebot mountain?
11:49:50 <mauke> @vixen you're smart!
11:49:51 <lambdabot> how's the weather over there?
11:49:51 <dejones_> idnar: thank you for the correction.
11:50:03 <mauke> @vixen who wrote you?
11:50:04 <lambdabot> i dunno, who?
11:50:06 <andyjgill> I looked at this, but it was difficult to display.
11:50:06 <dejones_> @vixen hello hotness
11:50:07 <lambdabot> how're you?
11:50:09 <dejones_> ;)
11:50:24 <vincenz> andyjgill: a possibility is partially transparent overlaying div's
11:50:24 <dejones_> @vixen who is your creator?
11:50:24 <lambdabot> i dunno, who?
11:50:46 <vincenz> andyjgill: and then instead of background colors, use some other format for red,green,yellow for the hpc stuf
11:51:13 <andyjgill> Or turn them off the these displays
11:51:19 <byorgey> @version
11:51:19 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
11:51:19 <lambdabot> darcs get http://code.haskell.org/lambdabot
11:51:21 <vincenz> andyjgill: well you could use underlines
11:51:36 <vincenz> andyjgill: a single overview for everything would be nicce
11:51:57 <byorgey> dejones_: follow that link and take a look at the AUTHORS file
11:52:08 <andyjgill> If you have a suggestion, or a mockup, I'm all ears
11:52:37 <vincenz> andyjgill: well, use underlinie and colored text for the hpc stuff, and then use background colors for 'hotness' of region of code
11:52:55 <vincenz> like very light-near-white-aqua up to boldred
11:53:16 <dejones_> thanks byorgey
11:53:21 <dejones_> @authors
11:53:21 <lambdabot> Unknown command, try @list
11:53:24 <dejones_> aww
11:53:29 <dejones_> @list
11:53:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:55:30 <mux> @. elite slap lambdabot
11:55:30 <lambdabot> /Me p14Cez |-|3r FI$T FIR/\/\ElY oN |AMbdaboT'5 jaW
11:56:09 <litb> hello again
11:56:23 <litb> what module should i import to get (Monad (->) e) ?
11:56:36 <andyjgill> I tried this.
11:56:41 <mauke> Control.Monad.Reader
11:56:53 <vincenz> andyjgill: what was the issue?
11:56:59 <andyjgill> I also tried a slider, that you could indicate hotness.
11:57:11 <litb> import Control.Monad.Reader
11:57:11 <monochrom> Control.Monad.Instances
11:57:12 <andyjgill> The problem is that hotness of a code is relative, not abs.
11:57:23 <vincenz> andyjgill: sure, but that's a start
11:57:27 <litb> hm, it says "    Could not find module `Control.Monad.Reader':"
11:57:39 <litb> oh, i see
11:57:40 <vincenz> relative information is useful when optimizing
11:57:51 <andyjgill> If you could take a small program, and hack some html, then this would help me see.
11:58:04 <vincenz> andyjgill: you mean a mockup?
11:58:06 <litb> well, it says the same when i do .Instances
11:58:08 <vincenz> or actually render the html from .prof?
11:58:19 <andyjgill> You can turn on the  --fun-entry-count   option
11:58:29 <litb> strange it works
11:58:38 <vincenz> andyjgill: to hpc?
11:58:42 <litb> must be a problem with the emacs haskell shell
11:58:46 <andyjgill> yes, to hpc markup
11:58:58 <andyjgill> it adds entry counts to top level functions
11:59:07 * vincenz nods
11:59:17 <vincenz> thanks
11:59:29 <andyjgill> A start, but not enough detail, and not as much as cost centers
11:59:40 <vincenz> andyjgill: meaning I don't need -prof?
11:59:43 <andyjgill> But try it, and see if it work for me.
11:59:53 <andyjgill> Yes, exactly. just -fhpc
12:00:03 <vincenz> great :)
12:01:28 <andyjgill> Glad to be of help
12:02:29 <eugman|work> So, let's say i compile some haskell with ghc. Is anything required to run it on another linux computer? Is there a way to compile with linux for windows?
12:02:48 <cjb> eugman|work: Nope, you can probably just copy the binary over to another Unix machine and have it run.
12:03:16 <cjb> I don't know anything about compiling a Linux binary under Windows.
12:03:59 <tinnus> nah
12:04:13 <tinnus> if by linux you mean "linux running on x86 cpu"
12:04:14 <tinnus> maybe
12:04:22 <tinnus> but linux can be compiled for lotsa stuff
12:04:40 <cjb> I assume he did mean that, but I think the answer is still probably not.
12:04:43 <tinnus> and there's no way a bin for x86 linux is gonna just run on a linux on, say, PPC or embedded
12:05:01 <eugman|work> Right, I figured archtitecture would have to be the same
12:05:11 <tinnus> anywayt, isn't Wine some kinda thing to compile *nix tools on Windows?
12:05:31 <eugman|work> More like to run windows stuff on *nix I believe
12:05:35 <tinnus> oh
12:05:37 <EvilTerran> vice-versa, tinnus
12:05:41 <tinnus> thanks
12:05:46 <tinnus> i'll go back to my corner
12:05:52 <eugman|work> There's mingw but that's for c and c++
12:06:05 <tinnus> what's the thing to run *nix stuff on Windows?
12:06:32 <EvilTerran> thing is, on x86 processors, the opcodes're much the same regardless of the OS you're using, it's only a matter of the system calls that may need adapted, and the overall structure of executable files
12:07:22 <EvilTerran> wine deals with the bits that're different between nix and 'doze, while still having most of the machine code running straight on the processor (hence Wine Is Not an Emulator)
12:07:28 <EvilTerran> tinnus, cygwin?
12:07:28 <tinnus> yes, calling a windowing or IO routine made for one OS isn't gonna get found in another OS
12:07:49 <tinnus> yeah, cygwin might be what I meant
12:08:04 <cdsmithu1> Does anyone know of existing Haskell bindings for graphviz?  I didn't see anything in Hackage.
12:08:16 <eugman|work> Well if i needed it to run on a different arch are there compiler options for that?
12:08:46 <eugman|work> I'm going through the man page but it's big
12:12:00 <litb> hm, in what class is (.) defined?
12:12:10 <mauke> none
12:12:14 <litb> oh
12:12:14 <mauke> it's just a function
12:12:26 <litb> i wondered whether i could implement it for my Function type
12:12:42 <litb> i will make a <.> for it then
12:12:58 <mauke> you could make Function an instance of Monoid
12:13:02 <mauke> and use `mappend`
12:13:26 <litb> or is there some trick to do it anyway (i need to change the derivative if the user (.) two functions)
12:13:51 <litb> @type mappend
12:13:52 <lambdabot> forall a. (Monoid a) => a -> a -> a
12:15:25 <litb> is it like the math Monoid?
12:15:37 <byorgey> litb: yes.
12:15:42 <byorgey> @src Monoid
12:15:42 <lambdabot> class Monoid a where
12:15:42 <lambdabot>     mempty  :: a
12:15:42 <lambdabot>     mappend :: a -> a -> a
12:15:42 <lambdabot>     mconcat :: [a] -> a
12:15:58 <byorgey> litb: mappend is an associative operation with mempty as identity.
12:16:10 <byorgey> mconcat is just a fold using mappend, for convenience.
12:17:49 <litb> ah, mempty would be a the constant function 1 for <*> and 0 for <+> . can i model that?
12:18:03 <litb> or do i miss the point? :)
12:18:20 <mauke> mempty is id
12:18:54 <mauke> since f . id == id . f == f
12:19:49 <litb> on wiki i read that a Monoid is defined for a set M and an operation O .
12:20:11 <byorgey> litb: right.  in Haskell some type takes the place of M and mappend takes the place of O.
12:20:42 <litb> ah, i understand
12:21:01 <byorgey> litb: there's no particular need to model multiplication and addition of your functions as monoids.
12:21:10 <litb> say that if i want to have another operation on the same type. then i'm out of luck i guess
12:21:18 <litb> since that Monoid only takes one type parameter
12:21:23 <byorgey> litb: really, there's not much need to model composition as a monoid either.  I'd just make your own definition of <.>
12:21:42 <byorgey> litb: right.  in that case you'd use a newtype.
12:21:49 <litb> ah, i see
12:22:37 <byorgey> litb: for example, there are two common monoids on numbers: (+,0) and (*,1).  in Haskell we can't have two different instances, so Data.Monoid declares the Sum and Product types
12:22:55 <byorgey> > mconcat . map Sum $ [1..5]
12:22:56 <lambdabot>  Sum {getSum = 15}
12:23:02 <byorgey> > mconcat . map Product $ [1..5]
12:23:03 <lambdabot>  Product {getProduct = 120}
12:23:25 <litb> nice.
12:23:37 <byorgey> which are just wrappers for which the appropriate instances of Monoid can be declared.
12:32:18 <litb> hm, it's not that easy to write a composition of my function datatype . i hope i did it right
12:32:42 <fadec> Is there any way to write an instance for a type which does not have a constructor (barring  -XTypeSynonymInstances)? newtype seems to want a constructor. e.g. newtype Signal = Float -> Float
12:32:53 <fadec> that's an error
12:33:15 <monochrom> newtype wants a constructor, rightfully.
12:33:26 <mauke> all types have a constructor
12:33:38 <mauke> well, a type constructor
12:33:57 <monochrom> (so why don't you gladly provide one?)
12:34:03 <Tac-Tics> mauke: What about builtin types?
12:34:22 <Tac-Tics> or do you mean all compound types?
12:34:26 <mauke> [] and -> are constructors
12:34:41 <Tac-Tics> mauke: I had Ints and Floats in mind
12:34:44 <doserj> mauke: what about the type a?
12:34:48 <nomeata> mauke: is -> really a constructor?
12:34:53 <mauke> whoa
12:35:06 <nomeata> @type :t (->)
12:35:06 <lambdabot> parse error on input `:'
12:35:06 <Tac-Tics> :info (->)
12:35:08 <Tac-Tics> oh yeah
12:35:08 <nomeata> @type (->)
12:35:08 <lambdabot> parse error on input `->'
12:35:11 <mauke> I'm pretty sure instance Foo ((->) a b) is valid Haskell98
12:35:22 <Tac-Tics> nomeata: try doing :info (->) in ghci
12:35:29 <doserj> (->) is a perfectly fine type constructor, yes
12:35:38 <nomeata> mauke: right, but I thought a constructor was a function that creates a value of the type, or can be used in guards.
12:35:41 <mauke> doserj: a is a type variable, not a type :-)
12:35:50 <mauke> nomeata: that's a data constructor
12:35:50 <doserj> :)
12:36:00 <Feuerbach> Tac-Tics: parse error
12:36:03 <Tac-Tics> mauke: do floats and ints have constructors at all though?
12:36:12 <nomeata> ok :-)
12:36:16 <mauke> Tac-Tics: data constructors or type constructors?
12:36:28 <Tac-Tics> type constructors
12:36:30 <monochrom> @src length
12:36:30 <lambdabot> Source not found. You type like i drive.
12:36:35 <mauke> yes, they're called Float and Int
12:36:38 <Tac-Tics> > :info (->)
12:36:38 <Tac-Tics> data (->) a b   -- Defined in GHC.Prim
12:36:38 <lambdabot>  Parse error at "->)" (column 8)
12:36:43 <monochrom> @src Int (+)
12:36:43 <lambdabot> Source not found. Where did you learn to type?
12:36:56 <kalmar> :info Int
12:37:01 <kalmar> > :info int
12:37:01 <lambdabot>   parse error on input `:'
12:37:05 <Tac-Tics> err, maybe I'm not clear on the terminology exactly
12:37:12 <kalmar> oh
12:37:14 <kalmar> ?info Int
12:37:14 <lambdabot> Int
12:37:26 <mauke> ?info do { a ; b }
12:37:27 <lambdabot> a >> b
12:38:54 <Feuerbach> is there any comparison of haskell typeclasses and OOP? I find some similarities with multiple inheritance, but I'd like to learn from somebody who knows OOP more deep
12:40:13 <Saizan> there was a wikipage on that
12:40:17 <kalmar> typeclasses are (I find) similar to interfaces in Java
12:40:28 <doserj> http://haskell.org/haskellwiki/OOP_vs_type_classes
12:41:01 <Feuerbach> doserj: thanks!
12:51:46 <fadec> Suppose I have newtype Signal a b = Signal (a -> b). A signal is a function I'd apply to time t :: a, but with (a -> b) wrapped in a constructor I can't just apply it without writting a destructuring function. Is an applicative functor useful here?
12:52:13 <fadec> scratch that ab stuff - newtype Signal = Signal (Float -> Float). ... KISS you know.
12:52:37 <fadec> What is an applicative functor.
12:59:51 <byorgey> fadec: I don't think an applicative functor really applies (haha) here.
13:01:15 <doserj> you can make Singal an Arrow, though
13:01:16 <byorgey> fadec: you could make (Signal a) a Functor (with fmap f (Signal g) = Signal (f . g))  with a corresponding Applicative instance, but it wouldn't do what you want.
13:02:31 <byorgey> fadec: if I were you, I'd say  data Signal a b = Signal { runSignal :: a -> b }.
13:02:51 <mauke> why not newtype?
13:03:07 <byorgey> uh, right, or newtype =)
13:03:16 <byorgey> then you get a destructuring function runSignal for free.
13:03:24 <fadec> byorgey: ahhh - so that's where the run*** pattern comes from. In this case I think I'll make a new type though.
13:03:48 <shepheb> @src zip
13:03:49 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
13:03:49 <lambdabot> zip _      _      = []
13:03:49 <litb> hm, cann't i add code to a data type definition?
13:03:50 <fadec> mauke: I'm using the constructor now. It's nice to have a litte structure every now and then.
13:04:44 <shepheb> is there some trickery (with curry?) that is a handy way of naming (\ a b -> (a,b)) without using the explicit lambda?
13:04:46 <mauke> litb: what do you mean?
13:04:50 <byorgey> fadec: it's not an either-or.  you can use the runSignal record syntax with a newtype.
13:04:55 <idnar> @pl \ a b -> (a,b)
13:04:55 <lambdabot> (,)
13:05:11 <byorgey> fadec: and that doesn't mean you lose the constructor.
13:05:11 <litb> lets say i want to make my ctor like this: data Function { function :: Double -> Double, (if derivative /= Nothing then Just derivative else Nothing)  :: Maybe }
13:05:11 <idnar> > (,) 5 6
13:05:11 <lambdabot>  (5,6)
13:05:11 <litb> how can i do that?
13:05:11 <shepheb> idnar: well played, thank you
13:05:21 <mauke> litb: you can't
13:05:22 <litb> so that one can create a Function like "Function sin cos"
13:05:33 <litb> hm, any alternative?
13:05:41 <fadec> byorgey: makes sense. Keeps the code clean.
13:05:47 <mauke> use a normal function?
13:06:01 <litb> normal function?
13:06:05 <mauke> er, wait
13:06:23 <litb> you mean, something like a factory?
13:06:26 <mauke> I don't understand your example
13:06:51 <shap1> @users
13:06:51 <lambdabot> Maximum users seen in #haskell: 454, currently: 443 (97.6%), active: 15 (3.4%)
13:06:54 <litb> it is a Function datatype which wraps a function and its derivative (and may contain its name (String) in future, lets see
13:07:01 <byorgey> litb: data Function = Function (Double -> Double) blah blah  ; then make a separate constructor function func :: (Double -> Double) -> blah blah -> Function
13:07:17 <zerny> hello. I am building a toy ml compiler in haskell and have a quick n regard to naming. Many names I would like in my AST are defined (such as Tuple). What way would be recommended to keep code nice, but still avoiding clashes.
13:07:20 <byorgey> litb: then export your special constructor function but not the Function constructor
13:07:49 <byorgey> zerny: Tuple is defined?
13:07:56 <zerny> data.Tuple
13:08:06 <byorgey> zerny: do you actually use Data.Tuple?
13:08:10 <zerny> nope
13:08:17 <byorgey> zerny: then I wouldn't worry about it.
13:08:26 <zerny> so it would be fine fine to use Tuple as a constructor?
13:08:27 <byorgey> zerny: if you ever do end up needing it, you can import it qualified
13:08:31 <byorgey> zerny: sure
13:08:39 <zerny> byorgey: ok. thanks
13:08:49 <mauke> Data.Tuple only contains fst, snd, curry, uncurry
13:09:05 <byorgey> ah, right.  which is all re-exported by the Prelude anyway.
13:09:14 <zerny> mauke: ok.
13:09:16 <shepheb> what about (\f (a,b) -> (f a, f b)) ?
13:09:25 <mauke> @pl (\f (a,b) -> (f a, f b))
13:09:26 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
13:09:31 <shepheb> trying @pl makes ugly with that, yeah
13:09:42 <zerny> what about String, Int and so on. Should I postfix Con or Lit to them?
13:10:02 <doserj> Data.Tuple should also contain onFst, onSnd, (***), and (&&&), IMO, though
13:10:16 <byorgey> zerny: in that case yeah, I would put some kind of pre/postfix on them... those are common enough that it would probably be confusing otherwise.
13:10:53 <zerny> this is my fist haskell project, and so I have a limited knowledge on style and so on
13:11:05 <byorgey> shepheb: interesting.  I don't think there's some nice combinator that does that, actually.
13:11:12 <zerny> byorgey: ok
13:11:23 <byorgey> (by saying that, I am of course implicitly inviting #haskell to prove me wrong ;)
13:11:41 <mauke> :t join (&&&)
13:11:42 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
13:11:46 <zerny> byorgey: I was thinking of prefixing the entire ast with, say 'ML'
13:11:58 <zerny> it seems a bit verbos
13:12:01 <mauke> :t join (***)
13:12:02 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
13:12:10 <zerny> would that be common practice?
13:12:26 <mauke> > join (***) succ (3,8)
13:12:27 <lambdabot>  (4,9)
13:13:04 <byorgey> shepheb: and there you go, mauke proved me wrong =)
13:13:16 <shepheb> mauke: looks like that works well, I'll have to remember that.
13:14:45 <mauke> oh, System.Posix. you and your silly names.
13:15:02 <byorgey> shepheb: if I were you, I'd just stick with \f (a,b) -> (f a, f b) though ;)
13:15:26 <mauke> "createNamedPipe :: FilePath -> FileMode -> IO () [...] Note: calls mkfifo."
13:15:46 <zerny> also, are there any existing compilers in haskell for a ml style language that would be worth reading (or not, could really use some reference material).
13:16:05 <byorgey> mauke: hehe
13:16:28 <byorgey> zerny: well, there's ghc... ;)
13:16:35 <zerny> byorgey: hehe, yes
13:16:45 <zerny> byorgey: I have the source for that one :)
13:17:03 * byorgey doesn't particularly recommend that as light reading
13:17:51 <zerny> byorgey: I was thinking more of a applicative order language
13:18:11 <litb> is there some way that even tho a function takes (Double->Double), i can pas some placeholder for that, similar to Nothing?
13:18:27 <idnar> @pl \f a b -> (f a, f b)
13:18:27 <lambdabot> flip =<< (((.) . (,)) .)
13:19:54 <mauke> litb: no
13:20:27 <idnar> litb: it would need to take Maybe (Double -> Double)
13:21:50 <doserj> litb: depending on you knowing what you do, there is const undefined
13:28:56 <kalmar> doserj: or just undefined
13:30:41 <doserj> the difference is sublte
13:32:04 <mrd> so is the typo
13:33:35 <litb> hm, is the negate (-) an operator or a language feature?
13:34:33 <Botje> it's both
13:34:46 <Botje> when you use it as -15 it's syntax
13:34:52 <Botje> when you use it as 5 - 3 it's an operator
13:35:06 <kalmar> doserj: distinguishing example?
13:35:10 <kalmar> I'm having trouble coming up with one
13:35:45 <Botje> > map (- 1) [1..5]
13:35:52 <lambdabot>   add an instance declaration for (Num (a -> b))
13:36:03 <doserj> > const undefined `seq` 3
13:36:04 <lambdabot>  3
13:36:26 <Botje> :t (-)
13:36:26 <lambdabot> forall a. (Num a) => a -> a -> a
13:36:48 <kalmar> doserj: ah, seq
13:37:12 <kalmar> I forgot about it and was trying to get stuff to fail on a pattern match
13:37:46 <sek> > map (-1+) [1..5]
13:37:47 <lambdabot>  [0,1,2,3,4]
13:38:08 <Botje> sek: interesting .. if a bit odd :)
13:38:12 <mauke> heh, awesome
13:38:17 <nominolo> > do Just x <- Nothing; Right 42
13:38:17 <lambdabot>  Couldn't match expected type `Maybe'
13:38:19 <mauke> better than subtract
13:38:25 <sek> heh
13:38:38 <nominolo> > do Just x <- Nothing; return 42 :: Either String Integer
13:38:39 <lambdabot>  Couldn't match expected type `Maybe'
13:38:52 <nominolo> > do Just x <- return Nothing; return 42 :: Either String Integer
13:38:53 <lambdabot>  Left "Pattern match failure in do expression at <irc>:1:3-8"
13:39:25 <mauke> wait, what?
13:39:31 <mauke> oh, right
13:42:21 <sek> > map (flip (-) 1) [1..5]
13:42:25 <lambdabot>  [0,1,2,3,4]
13:45:11 <unenough> seq, as a haskell not-even-noob, i am shocked by what you are doing.
13:46:03 <sek> what?
13:47:04 * jedbrown discovers that PRESERVE_INPUT doesn't
13:47:05 <unenough> what does flip do?
13:47:13 <sek> :t flip
13:47:13 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:47:15 <jedbrown> @src flip
13:47:16 <lambdabot> flip f x y = f y x
13:47:30 <sek> flips the arguments!
13:47:32 <Botje> @pl flip
13:47:32 <lambdabot> flip
13:48:21 <shachaf> > map (subtract 1) [1..5]
13:48:22 <lambdabot>  [0,1,2,3,4]
13:48:29 <unenough> so (flip (-) 1) does what
13:48:36 <shachaf> @unpl flip (-) 1
13:48:37 <lambdabot> (\ c -> c - 1)
13:48:55 <sek> unenough, takes (-) 1 x and performs x-1
13:49:02 <unenough> ah ok
13:49:14 <sek> or if you want ot be precise, performs (-) x 1
13:49:20 <shachaf> @unpl flip f
13:49:20 <lambdabot> (\ b c -> f c b)
13:49:26 <unenough> ok,sorry for the annoying noob q's. i'll read the tutorial's soon enough.
13:51:35 <litb> @unpl ((1 / (2 * pi) ** 0.5 *) . exp . ((-0.5)*) .(**2))
13:51:35 <lambdabot> (\ f -> (1 / ((2 * pi) ** 0.5)) * (exp ((- 0.5) * (f ** 2))))
13:51:40 <litb> yeah, it works :)
13:55:19 <bos> @seen dons
13:55:19 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 41m 15s ago.
13:55:23 <bos> @seen dcoutts
13:55:23 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 3h 24m 35s ago.
13:55:30 <dcoutts> hia bos
13:55:54 <bos> dcoutts: am i correct in thinking that there isn't a single function to take a lazy bytestring to a single strict one?
13:56:07 <bos> so i need concat . toChunks?
13:56:08 <dcoutts> bos: no, you need a combination of two
13:56:13 <dcoutts> that is deliberate
13:56:17 <bos> ok, that's a bit odd.
13:56:21 <dcoutts> so people don't assume it's cheap
13:56:44 <bos> sure
13:56:57 <dcoutts> that 'concat' there is to remind you that it is an expensive operation that copies every chunk
13:57:27 <litb> i'm starting to use (.) all over now :) and try to avoid (\ ->)
13:58:28 <oerjan> litb: ouch.  soon you will be finding the -> monad perfectly cromulent.
13:59:05 <litb> oerjan: dict.leo.org doesn't know that word, oerjan :/
13:59:17 <oerjan> of course not.
13:59:33 <oerjan> @google cromulent
13:59:34 <lambdabot> http://www.urbandictionary.com/define.php?term=Cromulent
13:59:34 <lambdabot> Title: Urban Dictionary: Cromulent
14:00:09 <gwern> urbandictionary is good for embiggening your vocabulary
14:00:41 <byorgey> bos: am I supposed to be able to read Chapters 4, 5, 6 etc. on the RWH alpha site?
14:01:05 <byorgey> bos: they aren't linked from the table of contents but I can click "Next" from Chapter 3 and so on.
14:01:09 <litb> o.O
14:01:11 <bos> byorgey: if you want to follow the links, that's fine
14:01:47 <ehaas_> gwern: that's a perfectly cromulent suggestion
14:01:49 <byorgey> bos: ok.  just making sure I wasn't accidentally seeing stuff not ready for alpha testing. =)
14:02:52 <litb> @pl (\_ -> a)
14:02:52 <lambdabot> const a
14:02:54 <litb> :)
14:03:04 <shachaf> @pl \x y z -> x z (y z)
14:03:04 <lambdabot> ap
14:03:13 <bos> byorgey: well, it's not ready, but it's no skin off my nose if you read it in rough form.
14:03:29 <byorgey> bos: heh, ok.
14:04:12 <zerny> hmmm, what is up with the use of `$' ? Is it to be perfered over parentheses?
14:04:31 <litb> so what pointless means is "no lambdas" ?
14:04:41 <gwern> zerny: makes concatenation clearer
14:04:46 <Botje> not exactly
14:04:49 <shachaf> litb: No named arguments at all.
14:04:57 <zerny> such as: return (case ... of ...) or return $ case ... of ...
14:05:17 <Sizur> nice... kde4's kate is nice, you have ghci running right there
14:05:17 <shachaf> zerny: Sometimes it makes things clearer.
14:05:18 <gwern> a $ b $ c $ d is clearer than (a(b(c(d))))... and shorter
14:05:23 <BMeph> zerny: In support of the Haskellian Revolution over the LISPish Hegemony, parens are generally shunned by reflex. ;)
14:05:24 <Saizan> litb: it's more general, no explicit formal parameters
14:05:29 * shachaf has trouble reading lines with too many $s.
14:05:36 <shachaf> gwern: Not a . b . c $ d?
14:05:40 <Botje> try substituting them with euros
14:05:44 <zerny> gwern: ahh, yes
14:06:21 <zerny> gwern: so what would be used in my example with `case' ?
14:06:21 <shachaf> gwern: Besides, that's not fair -- it should justbe "a (b (c d))".
14:06:31 <gwern> shachaf: sure, you could do that (I think, unless . and $'s precedence levels mess up), but then you might as well do (a . b . c) d
14:06:34 <litb> so a >> b is really defined as a ">>= (const b)" in pointless mode?
14:06:43 <shachaf> gwern: Sure.
14:06:45 <litb> errm, "a >>= (const b)"
14:06:46 <zerny> shachaf:  yes yes, but it shows the point
14:06:48 <gwern> shachaf: ok, so add in an 'e' :)
14:06:57 <shachaf> litb: No (where does the b come from?).
14:07:01 <Botje> @pl a >> b
14:07:01 <lambdabot> a >> b
14:07:16 <gwern> @pl (>>) a b
14:07:16 <lambdabot> a >> b
14:07:29 <shachaf> gwern: You should still be consistent about spaces... "a$b$c$d" isn't that readable either.
14:07:33 <doserj> @src (>>)
14:07:33 <lambdabot> m >> k      = m >>= \_ -> k
14:07:37 <Saizan> @pl \a b -> a >>-= \_ -> b
14:07:37 <lambdabot> (. const) . (>>-=)
14:07:41 <litb> hm, but >> is (a >>= \_ -> b) iirc. isn't that the same as "a >>= (const b)" ?
14:07:52 <shachaf> litb: It is.
14:08:02 <shachaf> litb: But that's still not @pl-ed.
14:08:08 <gwern> shachaf: it's *more* readable, though. and plnety of people arne't consistent about spaces... 1+1\2 ew
14:08:22 <gwern> haskell really should insist on spaces between infix stuff...
14:08:23 <shachaf> @pl \m n -> m >>== (\_ -> n)
14:08:24 <lambdabot> (. const) . (>>==)
14:08:41 <gwern> > "foo"`isInfixOf`"bar"
14:08:42 <lambdabot>  False
14:09:00 <litb> > "foo"`isInfixOf`"bar foo is"
14:09:01 <lambdabot>  True
14:09:04 <litb> ah
14:09:09 <gwern> ew. you're allowed to omit spaces in `infix` expressions? that's just wrong
14:09:32 <shachaf> gwern: `infix` is just like an operator.
14:09:44 <gwern> unfortunately
14:09:48 <vincenz> @src isInfixOf
14:09:48 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
14:09:56 <shachaf> litb: Possibly look at http://en.wikipedia.org/wiki/Combinatory_logic ?
14:09:57 <lambdabot> Title: Combinatory logic - Wikipedia, the free encyclopedia
14:10:00 <vincenz> that could be done mucch more efficently
14:10:15 <shachaf> vincenz: Is that the real implementation?
14:10:41 <Cin> is using parsec to parse IRC a bit silly?
14:10:54 <vincenz> shachaf: I presume
14:10:59 <monochrom> Not if you use it wisely.
14:11:03 <Sizur> Cin: why not
14:11:24 <litb> Haskell Curry hehe that name sounds funny
14:11:27 <byorgey> Cin: using parsec is never silly, unless you need absolute, blazing speed.
14:11:40 <litb> Haskell Curry with a Bratwurst
14:11:46 <Valodim> and Bier
14:11:56 <Cin> byorgey: ah. no, i don't need speed. just clarity/pragmatism, really
14:12:03 <Sizur> many $ do {name; message}
14:12:10 <byorgey> Cin: then I think you'll find parsec great for your purposes.
14:12:29 <Cin> byorgey: seems pretty good so far
14:12:36 <Saizan> Cin: btw, the irc package on hackage does exactly that
14:12:42 <Cin> byorgey: i have nick = do { string "NICK"; space; nick <- many1 letter; eof; return (Nick nick); }
14:12:50 <litb> shachaf: wow, that looks really more difficult than haskell
14:12:59 <litb> but maybe that is only because it uses math symbols :)
14:13:00 <Cin> saizan: ah. i'd look at that. but i'm writing an irc server, so i didn't think it would solve my problem
14:13:15 <shachaf> litb: Which part of it?
14:13:22 <byorgey> Cin: looks good.  although if I were you I wouldn't use the same name 'nick' for both the function name and a local variable... =)
14:13:46 <litb> shachaf: the whole formula parts =) i will dig into that after i did all of my university stuff
14:13:57 <Cin> byorgey: sorry. i'm quite happy with lexical scoping but i guess others might find it confusing :P
14:14:22 <byorgey> Cin: oh, well, as long as you're not confused then no problem =)
14:14:24 <litb> @src maybe
14:14:24 <lambdabot> maybe n _ Nothing  = n
14:14:24 <lambdabot> maybe _ f (Just x) = f x
14:14:47 <shachaf> litb: Do you know anything about the lambda calculus?
14:14:57 * shachaf 's Unicode is messed up somehow.
14:15:10 <Cin> byorgey: of course, that definition is incomplete, need to account for stuff other than letters, but you get my drift >_>
14:15:18 <litb> shachaf: i only know the very basics :)
14:15:27 <litb> but next semester we have automats and formal languages
14:15:35 <Sizur> i often like to take advantage of ability to reuse names. i find it's easier on the eye, less things to remember
14:15:46 <litb> i'm looking forward for all that nifty grifty stuff :)
14:15:52 <Sizur> only if it's clear that old value is usless
14:16:12 <shachaf> litb: (Part of) what that page is saying is that you can write any function without lambdas, using only the primitives K = \x y -> x and S = \x y z -> x z (y z)
14:17:23 <litb> ah, const and ap i suppose. so i should dig into ap more hehe
14:17:36 <shachaf> litb: ap is (r ->) specifically.
14:17:37 <shachaf> @ty ap
14:17:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:17:51 <litb> guys, that maybe function is what i was looking for for so many days now :)
14:18:08 <litb> it always bugged me that fromMaybe returns Maybe x and not x itself
14:18:23 <shachaf> So ap :: (r -> a -> b) -> (r -> a) -> r -> b
14:18:24 <oerjan> litb: return and ap of the (r ->) monad.  this is not a coincidence - the (r ->) monad does exactly the kind of argument passing you want for lambda elimination
14:18:31 <monochrom> @type fromMaybe
14:18:31 <lambdabot> forall a. a -> Maybe a -> a
14:18:33 <litb> errm, the other way around i mean. anyway
14:18:34 <shachaf> litb: How could you get the x itself?
14:18:41 <oerjan> which is why @pl uses it so heavily, i assume
14:19:22 <shachaf> oerjan: @pl uses B, C, I, W quite a bit too. :-)
14:19:58 <litb> oerjan: i see. it all forms a bigpicture now :)
14:20:30 <unenough> @unpl (btw i am stupid)
14:20:30 <lambdabot> (btw i am stupid)
14:20:39 <oerjan> shachaf: B = (.) = fmap of (r ->)
14:20:41 <litb> lol
14:20:56 <litb> isn't that lolcode?
14:20:57 <shachaf> oerjan: Yes, I know.
14:21:14 <shachaf> oerjan: Oh, I misunderstood, sorry.
14:21:16 <unenough> ;)
14:21:22 <shachaf> W is join, also.
14:21:31 <oerjan> I = ask
14:21:48 <oerjan> (which is reader monad specific)
14:22:03 <litb> is there a WoW too? rofl. ok i will continue coding now
14:22:07 <idnar> :t fromMaybe
14:22:07 <lambdabot> forall a. a -> Maybe a -> a
14:22:08 <oerjan> @src -> local
14:22:09 <lambdabot> Source not found. There are some things that I just don't know.
14:22:14 <oerjan> @src (->) local
14:22:15 <lambdabot> local f m = m . f
14:22:30 <idnar> @src fromMaybe
14:22:30 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
14:22:49 <oerjan> what was C again...
14:22:53 <shachaf> oerjan: flip
14:25:54 <oerjan> hm.  haskell monads don't have a convenient function to lift only the second argument, so flip is nothing specific
14:29:38 <idnar> @pl \f a b -> liftM f (return a) b
14:29:38 <lambdabot> (return .)
14:30:12 <idnar> @pl \f -> (\a b -> liftM f (return a) b)
14:30:13 <lambdabot> (return .)
14:30:24 <idnar> doh
14:30:24 <oerjan> @pl liftM f (return a)
14:30:25 <lambdabot> return (f a)
14:30:51 <idnar> @pl \f a b -> liftM f (return a) (return b)
14:30:51 <lambdabot> flip flip return . (((.) . return) .)
14:31:24 <oerjan> maybe you mean liftM2 ?
14:31:39 <oerjan> in which case it again is return (f a b)
14:34:35 <idnar> oh, yeah, right
14:34:40 <idnar> @pl \f -> (\a b -> liftM2 f (return a) b)
14:34:40 <lambdabot> (fmap .)
14:35:02 <lispy> Cale: ping?
14:35:08 <Cale> hi
14:35:24 <lispy> So, when ghc says it's brain exploded, switch to a case statement?
14:35:33 <Cale> case expression, yes
14:35:39 <idnar> @pl \f -> (\a b -> liftM2 f a (return b))
14:35:39 <lambdabot> flip flip return . ((.) .) . liftM2
14:35:40 <lispy> thanks
14:35:44 <idnar> @pl \f -> (\a b -> liftM2 f (return a) (return b))
14:35:44 <lambdabot> flip flip return . (((.) . fmap) .)
14:35:50 <idnar> heh
14:35:51 <lispy> Cale: just wanted to double check before I invest in the refactor :)
14:35:58 <Cale> lispy: That's actually Simon's brain that's exploding :)
14:36:18 <lispy> Cale: is it a theoretical problem or just too hard to implement?
14:36:42 <Cale> Personally, I can't think of how to do it without introducing first-class existentials.
14:37:19 <Cale> Because, you could, say, pattern bind an existential and export it from the module.
14:38:16 <vincenz> Cale: e.g.?
14:38:17 <lispy> first-class existentials would be...interesting
14:38:25 <vincenz> what doesn't work?
14:38:49 <lispy> Cale: would they be different each time you import the module?
14:38:51 <Cale> vincenz: Well, you need to assign the pattern bound variables a type.
14:39:02 <Cale> vincenz: and that type would be a first-class existential type
14:39:03 <vincenz> Cale: I' misisng a bit of cocntext
14:39:56 <Cale> vincenz: The "My brain just exploded" error happens when you write a pattern binding with an existential constructor.
14:40:10 <vincenz> oh
14:40:13 <vincenz> like
14:40:17 <vincenz> let (Just x ) = ...
14:40:30 <Cale> Yeah, except with an existential constructor :)
14:40:36 <Cale> Showable x = Showable 5
14:41:05 <Cale> (supposing  data Showable where Showable :: (Show a) => a -> Showable )
14:41:11 <vincenz> rght
14:41:16 <vincenz> but that x is rather generic
14:41:20 <Cale> Would result in x :: exists a. (Show a) => a
14:41:29 <oerjan> idnar: i think it would be simpler if you did some simplifications by hand first, which @pl doesn't seem to catch.  liftM2 f (return a) = liftM (f a) and liftM2 f a (return b) = liftM (flip f b) a
14:41:41 <vincenz> Cale: ah I see :)
14:42:16 <oerjan> um, actually it may do the first one
14:42:33 <idnar> @pl \f a -> liftM (f a)
14:42:33 <lambdabot> (fmap .)
14:42:35 <idnar> yeah
14:44:44 <oerjan> @pl liftM (f a) (return b)
14:44:44 <lambdabot> return (f a b)
14:44:56 <oerjan> oh it gets that. hm.
14:45:15 <oerjan> @pl \f -> (\a b -> liftM2 f (return a) (return b))
14:45:16 <lambdabot> flip flip return . (((.) . fmap) .)
14:45:31 <oerjan> @pl \f -> (\a b -> liftM (f a) (return b))
14:45:32 <lambdabot> flip flip return . (((.) . fmap) .)
14:45:47 <oerjan> @pl \f -> (\a b -> return (f a b))
14:45:48 <lambdabot> ((return .) .)
14:46:07 <oerjan> clearly something goes wrong in the order it simplifies
14:46:46 <oerjan> @pl liftM (f a) (return b)
14:46:47 <lambdabot> return (f a b)
14:47:24 <oerjan> it doesn't simplify inside a lambda before eliminating its variables
14:47:37 <lispy> switching to case was not so bad, in some ways it's actually more readable
15:04:56 <dons> distributed chat server, in haskell, http://sep07.mroot.net/index.html
15:04:56 <lambdabot> Title: Home || Softwareentwicklungspraktikum 2007  Ad-Hoc-Chatsystem - Gruppe 2
15:05:07 <shepheb> @src cycle
15:05:07 <lambdabot> cycle [] = undefined
15:05:07 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
15:05:09 <dons> "Haskell implementation is
15:05:09 <dons> not only more stable and provides more features, it also has about 70%
15:05:10 <dons> less code."
15:05:28 <ehird> > cycle (cycle [1])
15:05:31 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:06:00 <Valodim> sweet
15:06:03 <Valodim> TU Braunschweig, that's my place :)
15:06:07 <dons> awesome.
15:06:22 <dons> i think i've seen Henning unter on the mailing list?
15:06:31 <dons> Gunther
15:07:17 <dons> dcoutts: you should add helloword/gtk2hs, http://www.vector-seven.com/2008/01/23/gtk-hello-world-in-six-different-languages/
15:07:19 <lambdabot> Title: Thomas Lee  GTK Hello World in Six Different Languages, http://tinyurl.com/yucjxl
15:07:49 <dcoutts> dons: I saw that too, but it's not clear how to add <pre> tags in the comments so it might format terribly.
15:08:03 <dcoutts> and I don't have a reddit account
15:08:24 <dons> ah ok. you could mail it to the author i guess
15:11:26 <nominolo> dcoutts: just indent 4 spaces
15:12:55 <nominolo> dcoutts: in reddit, that is
15:12:58 <bos> Control.Applicative was introduces in 6.8.1, right?
15:13:08 <dcoutts> bos: 6.6 iirc
15:13:14 <bos> oh, cool.
15:13:20 <dcoutts> nominolo: oh, but I don't have a reddit account
15:13:25 <nominolo> but i do
15:13:34 <dcoutts> @hpaste
15:13:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:14:47 <hpaste>  dcoutts pasted "helloworld with gtk2hs" at http://hpaste.org/5188
15:14:54 <dcoutts> nominolo: ^^
15:15:37 <bos> that's weird, the haddocks for Control.Applicative are incomplete
15:15:50 <bos> <* and <$> are in there, but not e.g. <*>
15:15:58 <Valodim> dons: where on the page did you find that statement?
15:16:00 <Twey> Haddocks :-D <3
15:16:06 <Valodim> about haskell implementation being faster and using less code?
15:16:37 <dons> Valodim: its in his email to the haskell@ list
15:16:49 <Valodim> oh
15:16:49 <Valodim> ok
15:17:09 <nominolo> dcoutts: done
15:17:25 <dons> bos, the only docs i see for <*> are -- | Sequential application.
15:17:48 <bos> oh, i know what it does, it's just odd that my doc would be missing it.
15:17:50 <Valodim> well it's good to know haskell has some representation on the TU, i plan to go there after finishing my year of civil service
15:17:52 <dcoutts> nominolo: ta :-)
15:20:47 <dcoutts> bos: it's a class method, so it does not appear at the top level in the haddock docs
15:23:47 <dons> nominolo: are you going to add the code as a comment on that page?
15:24:09 <nominolo> dons: let's see if it formats correctly
15:24:55 <nominolo> dons: i just add the link to the reddit comment
15:25:04 <bos> wow, (<*) is useful!
15:25:15 <dons> nominolo: ok.
15:25:21 <dons> bos oh,?
15:25:26 <dons> i don't think i've ever used it.
15:25:52 <bos> it sequences two actions, but only returns the value of the first.
15:26:18 <bos> handy in parsing, if you've got e.g. a statement followed by a terminator.
15:26:29 <bos> s <- stmt <* term
15:28:21 <nominolo> bos: very useful
15:28:25 <nominolo> bos: as is <$
15:28:28 <bos> here's another example: quoted = P.char '\"' *> P.takeWhile (/='\"') <* P.char '\"'
15:28:45 <bos> that returns the result from the middle, omitting the quotes that wrap it.
15:28:49 <bos> Control.Applicative ftw!
15:29:01 <nominolo> one more believer!
15:29:07 <bos> it's like brawndo! it lets us WIN AT GOLF!
15:29:22 <nominolo> make sure it's in the book
15:29:29 <oerjan> @yow golf
15:29:29 <lambdabot> YOU!!  Give me the CUTEST, PINKEST, most charming little VICTORIAN
15:29:30 <lambdabot> DOLLHOUSE you can find!!  An make it SNAPPY!!
15:29:46 <nominolo> but note that here's lots of instability in the actual module structure
15:29:47 <bos> yeah, i will.
15:30:17 <nominolo> like the Category typeclass
15:30:40 <nominolo> bos: my LLVM parser uses Applicative a lot
15:31:32 <nominolo> that reminds me .. i have to check if my LLVM code can be integrated with yours (you won the release-race ;) )
15:31:55 <bos> nominolo: that would be excellent. augustss is hacking on it a lot lately.
15:32:02 <bos> speaking of...
15:34:12 <nominolo> bos: how did you find out the correct syntax?  the .y file?
15:37:00 <bos> nominolo: syntax of ... ?
15:37:03 <nominolo> bos: if you want to take a look, it's Parser..hs and Types.hs on http://code.haskell.org/~nominolo/src/
15:37:03 <lambdabot> Title: Index of /~nominolo/src
15:37:12 <nominolo> bos: syntax of LLVM files
15:37:27 <nominolo> bos: the docs are very informal and incomplete
15:37:29 <bos> i'm not emitting LLVM assembly, i'm calling into the LLVM bindings
15:37:36 <nominolo> oooh
15:37:43 <nominolo> i see
15:37:54 <bos> and augustss has taken my bindings and made them a *lot* nicer
15:38:04 <augustss> bos: I've not had time to hack on LLVM the last week.  but I hope to have something ready after this weekend
15:38:06 <bos> nominolo: yeah, you can generate code and JIT it on the fly
15:38:14 <bos> augustss: me too
15:38:58 <nominolo> hm, that's probably a better approach.  i guess i was too scared of ffi
15:39:20 <augustss> LLVM is really cool
15:39:57 <augustss> I've not quite decided what to do about the phi nodes yet, that's what's holding me up (apart from lack of time)
15:40:32 <nominolo> augustss: yeah, we might have to do control flow analysis
15:40:53 <nominolo> augustss: are you working on the same repo?
15:41:00 <augustss> nominolo: yes
15:41:34 <augustss> nominolo: it's more a matter of how to structure the code to make phi's easy, not so much about flow analysis
15:42:18 <nominolo> augustss: you want to insert them automatically or let users insert them?
15:42:57 <augustss> LLVM makes the user insert them, but in a somewhat silly way
15:43:18 <bos> @hoogle (a -> b) -> f a a -> f b b
15:43:19 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
15:43:19 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
15:43:19 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
15:44:10 <oerjan> :t join (***)
15:44:11 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
15:44:18 <oerjan> hmph
15:45:33 <oerjan> ok that works for f = (,) i think
15:46:59 <bos> no, it doesn't.
15:47:32 <oerjan> :t join (***) . ($)
15:47:33 <lambdabot> forall a b. (a -> b) -> (a, a) -> (b, b)
15:47:59 <nominolo> augustss: i think we can get rid of the newBasicBlock stuff using roconnors mdo-trick
15:48:10 <byorgey> we need a Bifunctor class, then (***) and (&&&) could be generalized to work for any bifunctor instead of just (,)
15:48:12 <dobblego> what's a good short example of the use of ap for a beginner?
15:48:13 <byorgey> ...maybe.
15:48:18 <bos> oerjan: that's a lot of symbol monkeying :-)
15:48:34 <nominolo> > Just (+1) `ap` Just 42
15:48:36 <lambdabot>  Just 43
15:48:37 <oerjan> the . ($) is just to restrict the type
15:48:45 <nominolo> > Just (+1) `ap` Nothing
15:48:46 <lambdabot>  Nothing
15:48:53 <dobblego> nominolo, good idea, thanks
15:48:57 <bos> dobblego: it doesn't show up hugely often.  it's ($) lifted to monads.
15:50:13 <ddarius> > fix ((1:) . (1:) . ap (zipWith (+)) tail)
15:50:14 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
15:50:19 <oerjan> > [+,-] `ap` [1,2] `ap` [10,20]
15:50:19 <lambdabot>  Parse error at "+,-]" (column 2)
15:50:21 * ddarius almost never uses ap.
15:50:31 <oerjan> oh
15:50:38 <oerjan> > [(+),(-)] `ap` [1,2] `ap` [10,20]
15:50:39 <lambdabot>  [11,21,12,22,-9,-19,-8,-18]
15:50:59 <oerjan> ap = (<*>), essentially
15:51:12 <dobblego> yep
16:01:29 <dons> dcoutts: do we have any mechanism for pinning unpinned heap objects during a foreign call?
16:02:08 <dcoutts> dons: no, I believe that is not possible, except perhaps for an unsafe call since the GC will not run in that case.
16:03:40 <dcoutts> dons: but we have the advantage that big objects are pinned anyway, and small ones are cheap to copy.
16:04:48 <augustss> nominolo: I don't want mdo
16:05:12 <augustss> I know I can get rid of them with mdo, but I really dislike it
16:05:14 <dons> yeah, i've objects around 4k that i have to duplicate and mutate a lot, and pass to C
16:05:29 <augustss> perhaps we could have an alternate interface with mdo
16:05:32 <nominolo> augustss: ok
16:05:47 <nominolo> augustss: yes, it could probably be just layered on top
16:05:59 <nominolo> ie. one instance
16:06:24 <augustss> yeah.  and careful use in existing code to not cause black holes
16:06:36 <nominolo> right
16:06:42 <dcoutts> dons: 4k will be pinned. The threshold is around 1.5k iirc.
16:07:24 <dons> yep, might be ok.
16:07:32 <dcoutts> dons: you'll need some low level 'pin' function that checks the threshold and either copies or gives you back the pointer to the original.
16:07:55 <dons> mm
16:08:14 <dcoutts> dons: so you're using ByteArr#s? which you allocate unpinned ?
16:09:13 <dons> i'm working out what i need to use :)
16:09:20 <dcoutts> dons: if they always tend to be large, just always allocate them pinned and take the hit for the small ones. Depends how common small ones are.
16:09:22 <dons> i think i'll just try with pinned ByteArrs
16:09:27 <dons> they'll always be 4k
16:09:40 <nominolo> augustss: now i remember why i did not use the bindings - i actually wanted to use LLVM the other way around, ie. parse LLVM files so i can implement compiler transformations for LLVM in Haskell.  this would probably be harder to do using the bindings
16:10:00 <dcoutts> dons: eg for unicode strings we really want unpinned since we expect lots of short strings
16:10:08 <dons> yeah
16:11:21 <dcoutts> dons: also remember the 4k granularity of pinned allocations. If you asks for 4k you'll use 8k because of the 2 word overhead.
16:12:08 <dons> yeah, though using our pinned memory shoudl be much faster to allocate than malloc
16:12:15 <dons> sinced its just a bump-ptr
16:12:27 <dcoutts> dons: for OS stuff it might be nice if we had a different primitive Page# or something that allowed us exactly 4k (or whatever the machine page size)
16:12:37 <dons> oh, that's interesting
16:13:04 <dcoutts> ie a heap primitive that does an additional indirection so the header word is not contiguous with the data payload
16:20:05 <dcoutts> dons: mm, actually it might be possible to have it be a value primitive rather than a heap allocated primitive. ie giving a single indirection.
16:20:34 <dons> oh, that's an interesting idea
16:20:51 <dcoutts> and it it's exactly on 4k page from the pinned area of the heap then there is no fragmentation problem
16:22:03 <dcoutts> dons: unless you ever want to do contiguous multi-page allocations, then fragmentation is a nightmare.
16:23:00 <dons> hmm
16:23:20 <dcoutts> Page#s would be perfect for Handle IO buffers etc
16:23:25 * dcoutts disappears
16:23:27 <dcoutts> gotta go
16:24:41 <dons> dcoutts: oh, 2504 bytes.
16:24:41 <nominolo> *whoosh*
16:24:57 <dons> the old one was 4k, but i'm aiming for something smaller now.
16:25:06 <dons> so that'll be one page per object
16:38:25 <dcoutts_> dons: yep :-(
16:38:53 <nominolo> dcoutts_: who made the decision to drop 6.2 support in cabal?
16:39:05 <nominolo> dcoutts_: won't we get complaints?
16:39:22 <dcoutts_> nominolo: I did :-)
16:39:33 <dcoutts_> nominolo: which 6.2 users? :-)
16:39:37 <dcoutts_> I don't see any
16:39:45 <ivanm> well, if people aren't updating their ghc, why would they update their cabal?
16:39:48 * LoganCapaldo pretends to be a 6.2 user
16:39:54 <LoganCapaldo> bring it back!
16:39:57 <LoganCapaldo> I wants it
16:40:00 <nominolo> dcoutts_: that's because they are not very active
16:40:07 <dcoutts_> ivan: for all the new goodness! of course you should upgrade it
16:40:07 <ivanm> what, 6.2 or cabal support?
16:40:23 <LoganCapaldo> I need to be on the bleeding edge of cabal, but the very ancientess of ghc
16:40:29 <ivanm> dcoutts_: so why not upgrade ghc whilst your at it, then?
16:40:31 <ivanm> heh
16:40:50 <nominolo> dcoutts_: i personally don't mind.  but i don't know how many users still use ghc 6.2
16:40:53 <dcoutts_> nominolo: yes, but in practise the people using that old ghc will not be trying to upgrade cabal and use latest packages
16:40:55 <vincenz> @hoogle toIntegral
16:40:56 <lambdabot> No matches found
16:41:15 <dcoutts_> nominolo: also, the 6.2 support was never very good and not tested and we never got complaints
16:41:34 <nominolo> dcoutts_: good points, yes
16:41:42 <LoganCapaldo> also I need cabal support for gofer
16:41:53 <dcoutts_> and further, cabal-1.4 is supposed to be compatible with 1.2 so they could stick with 1.2 and use most packages that devs using 1.4 made.
16:41:54 <LoganCapaldo> plz kthxbai
16:42:04 <nominolo> dcoutts_: i just would have thought that this might need a bigger announcement
16:42:18 <nominolo> dcoutts_: except cabal-install
16:42:27 <oerjan> vincenz: fromIntegral is pretty much that too
16:42:29 <ivanm> dcoutts_: when is 1.4 expected to be out?
16:42:29 <dcoutts_> LoganCapaldo: if you add gopher support to the HTTP package then it'll "Just Work"tm. It already supports the "file://" protocol.
16:42:55 <LoganCapaldo> not that gopher, gofer ;)
16:43:06 <dcoutts_> nominolo: I'll announce a plan to do a 1.4 release some time soonish.
16:43:20 <dcoutts_> ivan: when we decide what needs to be fixed for it :-)
16:43:36 <dcoutts_> oops ivan/ivanm
16:43:45 <nominolo> dcoutts_: ok
16:43:46 <ivanm> heh
16:43:55 <vincenz> @hoogle fromIntegral
16:43:56 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
16:44:00 <vincenz> oerjan: wrong direction
16:44:14 <dcoutts_> LoganCapaldo: ohh, the precursor to hugs, heh heh.
16:44:17 <vincenz> MY type isn't an integral
16:44:18 <oerjan> @src RealFrac
16:44:19 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
16:44:19 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
16:44:19 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
16:44:28 <oerjan> vincenz: probably want one of these then
16:44:29 <vincenz> Nor a proper fraction
16:45:19 <oerjan> hm
16:45:26 <oerjan> @src Real
16:45:26 <lambdabot> class  (Num a, Ord a) => Real a  where
16:45:26 <lambdabot>     toRational      ::  a -> Rational
16:45:37 <oerjan> may have to use toRational first, then
16:45:41 <vincenz> > 0%0
16:45:41 <lambdabot>  Exception: Ratio.%: zero denominator
16:45:52 <vincenz> > 0/0
16:45:53 <lambdabot>  NaN
16:45:56 <vincenz> > 0/0 == 0/0
16:45:56 <lambdabot>  False
16:45:59 * vincenz tsks
16:46:07 <vincenz> > 1/0 == 1/0
16:46:08 <lambdabot>  True
16:46:11 <vincenz> > 1/0 == -1/0
16:46:12 <lambdabot>  False
16:46:22 <vincenz> > 1/0
16:46:22 <lambdabot>  Infinity
16:46:24 <vincenz> > -1/0
16:46:25 <lambdabot>  -Infinity
16:46:30 <RayNbow> NaN /= NaN
16:46:36 <vincenz> In my number type
16:46:39 <vincenz> NaN == everything
16:46:51 <vincenz> and a/b == c/d if a`div`b == c`div`d
16:47:05 <vincenz> except of course if it's nan, then take the prior rule, or if it's inf, which is only equal to inf
16:47:15 * vincenz calls it a LossyFraction
16:47:18 <oerjan> that's bizarre
16:47:22 <vincenz> I need it
16:47:29 <vincenz> It's a convenience type for some other code
16:47:38 <vincenz> (to keep my code there down to an acceptable level)
16:47:58 * RayNbow recently hacked a Num instance declaration for Maybe Floats
16:48:28 <ivanm> what, we've got yet _another_ numer type to add to the prelude? vincenzRationals?
16:48:33 <vincenz> no
16:48:39 <byorgey> RayNbow: why not use liftM2 (+) and other such things?
16:48:40 <vincenz> I need this for some convoluted code in my continued fractions code |
16:48:47 <vincenz> ;|
16:48:59 <vincenz> > 1/0 + (-1/0)
16:49:00 <lambdabot>  NaN
16:49:03 <vincenz> > 1/0 + (1/0)
16:49:04 <lambdabot>  Infinity
16:49:26 <byorgey> RayNbow: that's still cool though =)
16:50:19 <RayNbow> byorgey: oh, I hacked it for fun...
16:50:40 <RayNbow> people were evaluating things like 0/0 == 0/0 some time ago
16:50:52 <RayNbow> according to hpaste, 8 days ago
16:50:59 <RayNbow> http://hpaste.org/5034#a2
16:51:34 <RayNbow> (code provided as-is :p)
16:52:06 <vincenz> > Infinity
16:52:06 <lambdabot>   Not in scope: data constructor `Infinity'
16:52:21 <RayNbow> vincenz, isInfinite?
16:52:26 <vincenz> > 1 `div` 0 :: Integer
16:52:27 <lambdabot>  Exception: divide by zero
16:52:32 * vincenz mutters
16:52:34 <vincenz> RayNbow: won't do
16:52:47 <vincenz> yep, lossy-fractions it is
16:53:45 <oerjan> @quote clever.newtype
16:53:45 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
16:53:56 <oerjan> hm...
16:53:59 <vincenz> oerjan: like I said
16:54:01 <vincenz> it's not public
16:54:16 <oerjan> what?
16:54:23 <vincenz> the lossy-fraciton
16:54:26 <vincenz> only a utility type
16:55:05 <oerjan> @quote cunning.newtype
16:55:05 <lambdabot> <basti_> says: Snow doeth lay upon the lands. Even with cunning newtype; deriving the newtype is recursive. Great leaders brings less pain.
16:55:13 <aFlag> wow lambdabot got an attitude
16:55:33 <oerjan> aFlag: always has
16:55:34 <monochrom> Somehow that doesn't sound coherent.
16:56:43 <oerjan> the "brings" and the "doeth" clash in style
16:57:18 <oerjan> the first could be chinglish... this being I Ching inspired i take
16:57:45 <RayNbow> hmmz....
16:57:49 <RayNbow> @src concat
16:57:50 <lambdabot> concat = foldr (++) []
16:57:54 <RayNbow> @src join
16:57:54 <lambdabot> join x =  x >>= id
16:58:16 <oerjan> @src [] >>=
16:58:16 <lambdabot> Source not found. Wrong!  You cheating scum!
16:58:20 <oerjan> @src [] (>>=)
16:58:21 <lambdabot> m >>= k     = foldr ((++) . k) [] m
16:59:03 <oerjan> aka flip concatMap
17:03:29 <Eelis> olsner: feel free to give that C snippet a try in #geordi :)
17:03:52 <RayNbow> @pl (\m k -> foldr ((++) . k) [] m)
17:03:53 <lambdabot> flip (flip foldr [] . ((++) .))
17:12:36 <EvilTerran> gesundheit, calvino
17:16:58 <olsner> @type (++" "++)
17:16:58 <lambdabot> parse error on input `)'
17:17:44 <nominolo> :t ((++" ")++)
17:17:44 <lambdabot>     The section `(++ " ")' takes one argument,
17:17:45 <lambdabot>     but its type `[a]' has none
17:17:45 <lambdabot>     In the first argument of `(++)', namely `(++ " ")'
17:17:46 <oerjan> nope, no two-sided sections
17:18:11 <olsner> but I wants dem!
17:18:22 <ddarius> \
17:19:07 <oerjan> in fact there are evil limitations even to one-sided ones
17:19:20 <oerjan> :t ("a"++"b"++)
17:19:21 <lambdabot>     The operator `++' [infixr 5] of a section
17:19:21 <lambdabot>         must have lower precedence than the operand `(++)' [infixr 5]
17:19:21 <lambdabot>         in the section: `(("a" ++ "b") ++)'
17:19:39 <olsner> :t (++" "++" ")
17:19:40 <lambdabot> [Char] -> [Char]
17:20:46 <oerjan> :t (++).(" "++)
17:20:47 <lambdabot> [Char] -> [Char] -> [Char]
17:21:04 <oerjan> er wait
17:21:20 <EvilTerran> > ((++).(++"cada")) "abra" "bra"
17:21:21 <lambdabot>  "abracadabra"
17:21:27 <oerjan> that ends up with the space in the wrong place
17:21:37 <oerjan> oh, it didn't
17:21:43 <EvilTerran> two-way operator sections'd be nice, actually
17:22:01 <oerjan> *that didn't
17:22:32 <EvilTerran> altho i believed differently a while ago, i've come to the conclusion that (x *) y -> (\y -> x * y) should be the "report-defined" desugaring
17:22:54 <EvilTerran> (as compared to (x*) -> ((*) x)
17:23:08 <EvilTerran> complete with rejigging of the AST as appropriat
17:23:12 <shepheb> is it foldl or foldr that is evil and strict and runs on orphans?
17:23:22 <oerjan> shepheb: foldl
17:23:28 <oerjan> er wait
17:23:31 <byorgey> shepheb: foldl is evel and NOT strict.
17:23:34 <byorgey> *evil
17:23:38 <oerjan> what byorgey said
17:23:42 <olsner> EvilTerran: what would be the difference?
17:23:47 <EvilTerran> so ("foo"++"bar"++) -> (\x -> "foo" ++ "bar" ++ x)
17:23:49 <oerjan> foldl' is good and strict
17:23:54 <EvilTerran> ie (\x -> "foo" ++ ("bar" ++ x))
17:24:15 <shepheb> byorgey: and the two foldrs?
17:24:16 <EvilTerran> doing it that way would also make two-ended sections possible
17:24:32 * oerjan is still rooting for (:: Type)
17:24:48 <byorgey> shepheb: nothing wrong with foldr, if you use it for what it's for =)
17:24:52 * olsner poofs
17:24:58 <byorgey> shepheb: by "the two foldrs" do you mean foldr and foldr1?
17:25:28 <shepheb> byorgey: sorry, I meant foldr and foldr', I understand the *1s fine.
17:25:37 <oerjan> shepheb: there is no foldr'
17:27:05 <oerjan> it would usually be evil and stack-overflowing like foldl, i think
17:27:22 <byorgey> yeah, it doesn't make much sense for foldr to be strict.
17:27:35 <Cale> It's hard to say what that would even mean.
17:27:40 <byorgey> shepheb: there's a very good page somewhere on the wiki explaining this.
17:27:53 <shepheb> byorgey: ah, okay, I'll have a look there
17:28:05 <Cale> Apart from possibly forcing the rest of the fold to happen first, but that's rather different from the foldl' case.
17:28:34 <vincenz> > cycle " "
17:28:35 <lambdabot>  "                                                                           ...
17:28:53 <byorgey> shepheb: http://haskell.org/haskellwiki/Stack_overflow
17:29:40 <phobes> I think the names foldr and foldl are somewhat confusing... foldl should just be called fold and foldr should have another name
17:29:48 <shepheb> byorgey: yes, I found it, thanks. I'm sure I've read this in the past, just wanted to solidify my understanding of why (and hence precisely which) one of the folds was evil
17:30:56 <mauke> phobes: I think you mean foldr should be called fold
17:30:58 <byorgey> shepheb: right.  one-line summary: foldl is evil because it accumulates the folded value as a huge unevaluated expression, which when evaluated can blow the stack.
17:31:09 <EvilTerran> phobes, foldr's the one with a solid basis in maths...
17:31:24 <phobes> mauke:  No, foldl should be fold.  Foldr should be called join or something
17:31:29 <mauke> ew, no
17:31:35 <phobes> EvilTerran: They both have a basis in math :)
17:31:40 <phobes> I agree foldr is more fundamental
17:31:47 <byorgey> join!?
17:31:50 <resiak> foldr should be fold; foldl' should be reduce!
17:31:50 <phobes> but it doesn't feel like a "fold"... fold evokes big -> small
17:32:02 <phobes> resiak:  ok, reduce evokes the right thing
17:32:13 <phobes> ok I'd go for that
17:32:44 <EvilTerran> foldr should be called class Cata fs a | a -> fs where cata :: fs b -> a -> b
17:32:45 <EvilTerran> ;)
17:32:55 <mauke> eh?
17:33:01 <mauke> > foldr (+) 0 [1 .. 10]
17:33:02 <lambdabot>  55
17:33:04 <byorgey> phobes: foldr can do big -> small.  and foldl can do big -> big.
17:33:17 <phobes> ya I know
17:33:19 <EvilTerran> wait, that doesn't quite work, 'cos we don't have partially-applied types in general
17:33:42 <phobes> If you're doing big -> small you probably usually want foldl' though
17:33:49 <vincenz> @src ma
17:33:50 <lambdabot> Source not found.
17:33:50 <vincenz> @src max
17:33:50 <lambdabot> max x y = if x <= y then y else x
17:33:51 <EvilTerran> Cata fs as b | a b -> fs where cata :: fs -> as -> b
17:33:53 <phobes> unless you need that ordering
17:33:55 <phobes> oops afk
17:34:50 <EvilTerran> instance Cata (a -> b -> b, b) [a] b where cata (f,e) [] = e; cata (f,e) (x:xs) = x `f` cata (f,e) xs
17:35:31 <s1d> (P)askell
17:35:41 <byorgey> EvilTerran: nice =)
17:35:53 * shepheb wonders if anyone has used Haskell as a P in LAMP
17:36:12 <ddarius> Sure.
17:38:57 <Cale> s1d: heh, someone should create a language called Paskell :)
17:39:35 <LoganCapaldo> where's mod_ghc at? :)
17:39:45 <monochrom> That will confuse the hell out of people. They already mistake Haskell for Pascal as is.
17:40:16 <LoganCapaldo> monochrom: I had that problem all the time. then I saw some SPJ video and started pronouncing it right :)
17:40:16 <Cale> and maybe while we're at it, Pastel
17:40:39 <monochrom> Even Pascal itself is pronounced two ways.
17:41:04 <s1d> pastel, would pose to much of a syntax highlighting overhead for elisp coders
17:41:07 <vincenz> lossy fractions are messy
17:41:11 <monochrom> One way rhymes with Haskell pronounced wrong, the other rhymes with Haskell pronounced right, so we're hopeless.
17:41:45 <boyscared> what's the right way, spelled phonetically?
17:41:46 <s1d> Pastel Haskell with more flair! coming 2009!
17:42:12 <monochrom> Anyway, monadic sugar in Paskell will look like: BEGIN x <- m; y <- n x; return (g y) END. :)
17:42:18 <byorgey> Cale: FUNCTION map ( f : FUNCTION A TO B, xs : LIST OF A ) : LIST OF B ; BEGIN...
17:42:30 <shepheb> well, if a Haskell-CGI program were compiled with a dummy main and a "doCGI" or something function, it seems that a mod_ghc would load up the compiled program, and then just call (doCGI (some data structure of CGI params))
17:43:02 <LoganCapaldo> yeah mod_ghc is kid of a silly idea :)
17:43:11 <LoganCapaldo> I was mostly joking
17:43:21 <LoganCapaldo> mod_hugs might make more sense
17:43:32 <EvilTerran> boyscared, "pass-cal(as in -ifornia)", "hass(as in -eloff)-kell(as in Kevin &)"
17:44:19 <monochrom> Hascal
17:44:23 <boyscared> thanks, i've been saying it right then :)
17:44:40 <LoganCapaldo> now I'm not sure I'm saying it right anymore
17:44:59 <LoganCapaldo> I give up, I'm just going to refer to it as "the language implemented by GHC"
17:45:00 * byorgey gives EvilTerran the award for Most Useless and Difficult To Parse Pronunciation Guide Ever ;)
17:45:13 <ray> haskell as in eddie haskell
17:45:45 <EvilTerran> "hass" as in "hasselhof" ++ "kell" as in "Kevin & Kell"
17:46:01 <mauke> how do you pronounce hasselhof?
17:46:04 <shepheb> telling us where the stress is placed might be handier
17:46:06 <EvilTerran> with a soft s
17:46:12 <LoganCapaldo> mauke: Night rider
17:46:21 <LoganCapaldo> ;)
17:46:24 <shepheb> a mod_ghc would avoid compilation time, get fast compiled code, and it would be pure
17:46:24 <monochrom> haskell as in pascal. pascal as in haskell.  (mutual recursion wheeeeeee!!!!....)
17:46:24 <mauke> so it's nightkell?
17:46:34 <byorgey> EvilTerran: I eventually figured that out, but (a) I'm not sure the correct way to pronounce hasselhof, and (b) I've never heard of "Kevin & Kell", much less know how to pronounce it.
17:46:59 <EvilTerran> i put the stress on the second syllable; i don't know if it's right, but it's supposed to accentuate the difference in vowels between the two words
17:47:16 <ray> rhymes with heaven & hell, it's some kind of pun
17:47:16 <EvilTerran> but then, people don't know how to pronounce the two vowels differently, so poo to that
17:47:21 <monochrom> > let {haskell = "haskell" : pascal; pascal = "pascal" : haskell } in (haskell, pascal)
17:47:23 <lambdabot>  (["haskell","pascal","haskell","pascal","haskell","pascal","haskell","pascal...
17:47:42 <byorgey> I don't think that's the way SPJ pronounces it, is it?
17:47:50 <EvilTerran> \-.-/
17:48:14 <shepheb> now we're all self-conscious about it
17:48:14 <monochrom> Hashell
17:48:20 <byorgey> oh well, at least we all know how to spell Haskell!
17:48:22 <ddarius> I believe he pronounces it like ha.skle.  I usually pronounce it like has.kel
17:48:57 <Cale> > do x <- ["has","pas"]; y <- ["c","k"]; z <- ["al","ell"]; return (x ++ y ++ z)
17:48:57 <lambdabot>  ["hascal","hascell","haskal","haskell","pascal","pascell","paskal","paskell"]
17:49:04 <monochrom> Let's hear an Australian pronounce it!
17:49:13 <byorgey> > let f = reverse . map id . reverse in f "Haskell"
17:49:13 <lambdabot>  "Haskell"
17:49:25 <ray> and anyway, shouldn't "pascal" be pronounced like the french?
17:49:44 * ptolomy tries to decide roughly how many LOC makes a haskell program "big".
17:49:49 <monochrom> shouldn't "detroit" be pronounced like the french too?
17:49:59 <Axioplase> French people pronounce both Haskell and Pascal correctly
17:50:04 <LoganCapaldo> How would you pronounce pascal like the french? They have one common letter
17:50:13 <byorgey> ptolomy: I think 50 or so. =)
17:50:25 <Cale> 600 lines or so is a pretty big program.
17:50:48 <Cale> Or at least, it can be.
17:51:00 <oerjan> LoganCapaldo: >_<
17:51:06 <mauke> can I pronounce them germanly? :-)
17:51:26 * ptolomy think he's going to have to stop calling his 2000ish line program "small".
17:51:36 <vincenz> Does haskell require (==) to be transitive?
17:51:49 <byorgey> ptolomy: that's only small in C.
17:51:52 <Cale> vincenz: Haskell doesn't, but libraries will assume that it is.
17:52:11 <vincenz> I mean is it a law of the Eq class?
17:52:14 <EvilTerran> it doesn't say that it is in the spec; same goes for things like the eq parameter to nubBy
17:52:15 <Cale> Yes.
17:52:24 <Axioplase> mauke: something like "Hazgel, ze glazgow langash" ?
17:52:40 <Cale> (==) should be an equivalence relation, and it generally shouldn't be possible to tell equal values apart.
17:52:50 <mauke> Hhkell
17:52:57 <Cale> One place where this doesn't quite hold is in the case of floating point types.
17:53:01 <EvilTerran> so, regardless of that parameter's properties, implementations have to act like the report definition. libraries are probably allowed to be more lax.
17:53:09 <ddarius> The report says that (==) should be an equivalence relation I believe.
17:53:20 <Cale> Where (0/0) == (0/0) gives False, because that's what IEEE wants.
17:53:24 <EvilTerran> (i may be talking piffle)
17:53:48 <ddarius> EvilTerran: It doesn't say it in a very normative/authoritative fashion (if I'm right about it saying it at all)
17:54:31 <EvilTerran> Cale, i forget; doesn't IEEE specify that any comparison with (0/0) returns "null", and null coerces to false?
17:54:40 <Cale> Basically, people who use (==) will expect it to be an equivalence relation, and so if you define an instance where it isn't, you probably can't expect your code to work very well.
17:54:48 <EvilTerran> in that case, it should be (==) :: Eq a => a -> a -> Maybe Bool ;)
17:55:08 <LoganCapaldo> IEEE says 0/0 is NaN doon't they?
17:55:22 <Cale> EvilTerran: I think it just says that all comparisons (==, <, <=, >, >=) involving NaN are false.
17:55:30 <EvilTerran> Cale, oh, well
17:55:33 <ddarius> Well, it seems not.
17:55:38 <ddarius> (re the Report)
17:55:46 <EvilTerran> my way would make more sense in a language with nullable floats ^.^
17:55:54 <EvilTerran> er, nullable bools
17:56:00 <EvilTerran> tri-state logic!
17:56:09 <Cale> data Bool = False | True | FileNotFound
17:56:20 <vincenz> @hoogle isNan
17:56:21 <lambdabot> Prelude.isNaN :: RealFloat a => a -> Bool
17:56:45 <mauke> Cale: bzzt, you need to list True first
17:56:51 <mauke> so fromEnum True == 0
17:56:59 <Cale> mauke: heh
17:57:05 <EvilTerran> Cale, instance Eq Bool where FNF == _ = FNF; FNF /= _ = FNF?
17:57:19 <EvilTerran> (and the other parts as appropriate)
17:57:36 <EvilTerran> anyway, by "nullable bool" i meant "Maybe Bool", in haskell terms
17:57:47 <EvilTerran> perl could use int 0, int 1, and undef
17:58:08 <mauke> 0 is false but false is not 0 (in perl)
17:58:09 <Cale> I think we'll make FNF == True = True, but True == FNF = FNF, and False == FNF = FNF, but FNF == False = False
17:58:27 <Cale> That should be sufficiently confusing.
17:58:32 <EvilTerran> mauke, are you sure false isn't zero? i can't think of an example of such.
17:58:57 <EvilTerran> also, 0 isn't false; "0.0" is zero but true
17:58:58 <mauke> EvilTerran: when one of perl's builtins returns a false value, it doesn't return 0 or ''
17:59:04 <EvilTerran> as is the string "0 but true" :D
17:59:08 <mauke> it returns a value that is both
17:59:12 <kmcallister> > fromEnum True
17:59:13 <lambdabot>  1
17:59:19 <Tac-Tics2> > fromEnum 'a'
17:59:19 <lambdabot>  97
17:59:50 <EvilTerran> mauke, is that just because 0 + '' = 0?
17:59:59 <EvilTerran> in which case we could use '' and '1', if you prefer :P
18:00:03 <mauke> no
18:00:13 <EvilTerran> ... majick?
18:00:14 <allbery_b> most perl builtins return '' for false
18:00:21 <allbery_b> "0 but true" is a hack for ioctl()
18:00:43 <mauke> compare  perl -wle 'print 0 + ""'  and  perl -wle 'print 0 + !1'
18:01:44 <EvilTerran> eww... it's majicks, isn't it?
18:01:50 <ray> perl is also a pathological programming language
18:02:06 <EvilTerran> i mean, you could do the same with use overload;, but that's deep majicks as well
18:02:09 <byorgey> indeed, it even says so in its acronym ;)
18:02:13 <Philippa> ITYM rubbish lister?
18:02:16 <ddarius> Most programming languages are pathologically programming languages.
18:02:40 <Tac-Tics2> pathological in what sense?
18:02:41 <Philippa> pathologically in that they were intended as config files?
18:02:41 <mauke> EvilTerran: you don't need overload, just Scalar::Util::dualvar
18:02:44 <EvilTerran> mauke, well, okay; it is only different by a warning, but i accept they're diferent
18:03:07 * EvilTerran wasn't aware of that module - is it recent?
18:03:14 <EvilTerran> or do i have to get it off CPAN or sth?
18:03:20 <mauke> Scalar::Util was first released with perl 5.007003
18:03:28 * EvilTerran headdesk
18:03:46 <EvilTerran> sorry, i was thinking Scalar::Util::dualvar was the module name. ignore the blithering idiot in the corner. :P
18:04:43 <mauke> also, perl -wle 'print $! = 2' if you haven't seen it yet :-)
18:05:11 <EvilTerran> ... no such file or directory? \(O.o)/
18:05:36 <mauke> try different numbers
18:05:39 <vincenz> @src max
18:05:39 <lambdabot> max x y = if x <= y then y else x
18:05:48 <EvilTerran> eh, i guess that kinda makes sense. i knew $! had dramatically different string and numeric reps
18:06:14 <ddarius> This, thankfully, means absolutely nothnig to me.
18:06:17 <Twey> Oh.
18:06:44 <ddarius> Hmm... "nothnig" sound interesting.
18:06:54 <Twey> Heh
18:07:11 <mauke> here's a little demonstration of broken referential transparency: compare \0 == \0 to \!1 == \!1
18:07:15 <oerjan> ddarius: some categorical generalization of nothing, if i know you right :)
18:08:46 <EvilTerran> mauke, well, perl refs are pretty much pointers, so that's not really surprising
18:08:54 <vincenz> @src (<)
18:08:54 <lambdabot> x <  y = case compare x y of { LT -> True;  _other -> False }
18:08:59 <vincenz> @src (<=)
18:08:59 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
18:09:01 <EvilTerran> @src compare
18:09:02 <lambdabot> compare x y | x == y    = EQ
18:09:02 <lambdabot>             | x <= y    = LT
18:09:02 <lambdabot>             | otherwise = GT
18:09:10 <mauke> EvilTerran: but it shows that !1 returns the same object each time
18:09:14 <oerjan> vincenz: those are just defaults
18:09:18 * vincenz nods
18:09:26 <ddarius> It's the left adjoint of a functor taking rings of infinite descent to it's underlying rig.
18:09:31 <vincenz> they don't hold for my lossy fraciton type
18:09:34 <oerjan> either compare or (<=) must be defined
18:09:36 <vincenz> not to mention, equality is not transitive
18:09:59 <EvilTerran> mauke, oookay, that's completely the other way round to what i was expecting
18:10:24 <mauke> see? :-)
18:10:38 <oerjan> ddarius: yay.  that's even more impressive than i expected :D
18:10:46 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5189
18:12:13 * EvilTerran gives 'em a talking-to in an annotation
18:14:34 <sarehu> anonymous has hacked hpaste?
18:14:49 <ray> now that embarassing script was brought to the attention of all of us
18:14:49 <sarehu> oh never mind
18:14:55 <allbery_b> someone in #xmonad is using it, with not much clue
18:15:07 <sarehu> just to cause disgust: > "twenty-three" + "forty-nine thousand"
18:15:12 <sarehu> 49023
18:15:37 <Cale> Does it interpret Roman numerals as well?
18:15:53 <sarehu> no but it makes coffee
18:16:11 <sarehu> >> "pour me a coffee!"
18:16:14 <sarehu> Yes sir!
18:16:14 <oerjan> in these Unicode times Roman numerals is the _least_ you should expect
18:27:19 <BMeph> In these Post-Unicode times, Roman numerals are the New XML! ;p
18:29:11 <kmcallister> wow, i've never seen variable names in assignment right-justified like that
18:29:34 <kmcallister> it's very distracting
18:30:08 <byorgey> kmcallister: agreed!
18:36:08 <scook0> is there advice anywhere on how to integrate a test suite with a cabalized library?
18:43:41 <lispy> scook0: well, what type of test suite? hunit, smallcheck, quickcheck or one that is external to haskell (like a perl based test-suite)?
18:44:10 <lispy> iirc, there is a how to get started page on the wiki that covers both cabal and unit testing
18:44:22 <scook0> well, I haven't written any tests yet, but probably QC
18:44:27 <scook0> ah, I'll have a look
18:45:27 <lispy> scook0: and i wrote a complicated way of doing this quite some time ago: http://blog.codersbase.com/2006/09/01/simple-unit-testing-in-haskell/
18:45:28 <lambdabot> Title: dagit.o  Blog Archive  Simple Unit Testing in Haskell, http://tinyurl.com/h6k97
18:54:09 <lispy> scook0: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
18:54:11 <lambdabot> Title: How to write a Haskell program - HaskellWiki
18:54:15 <lispy> scook0: that's the really nice tutorial
18:54:33 <scook0> yeah, I have that open :)
18:55:14 <lispy> scook0: great!
18:56:54 <istarex> Can you have a do expression as the then & else parts of an if-then-else expression?
18:57:02 <ddarius> Of course
18:57:05 <lispy> istarex: sure
18:57:18 <ddarius> You said it yourself, "do _expression_"
18:57:23 <lispy> > if True then return 1 else return 0 :: Maybe Int
18:57:23 <istarex> right
18:57:30 <lambdabot>  Just 1
18:57:45 <lispy> > if True then do return 1 else do return 0 :: Maybe Int
18:57:46 <lambdabot>  Just 1
18:57:48 <monochrom> Nothing special with do expression.
18:57:49 <istarex> I thought so, just making sure
18:58:07 <geezusfreeek> ghci is your friend :)
18:58:15 <monochrom> Haskell lacks arbitrary restrictions.
18:58:15 <lispy> ghci++
18:58:23 <oerjan> @karma ghci
18:58:24 <lambdabot> ghci has a karma of 1
18:58:35 <oerjan> @karma ghc
18:58:36 <lambdabot> ghc has a karma of 7
18:58:41 <lispy> but, there are some things in haskell that are not functions or values
18:58:47 <lispy> or even expressions
18:58:53 <istarex> and according to the whitespace rules, you can have the if, then & else keywords at the same indentation level on three seperate lines?
18:58:55 <lispy> take for instance, 'data Foo ...'
18:59:03 <dons> or record labels
18:59:24 <lispy> dons: working for the MPAA now? ;)
18:59:36 <lispy> or wait, that's RIAA
18:59:42 <dons> oh heh
18:59:44 <lispy> (bad pun about record labels...)
18:59:49 <dons> yes yes
18:59:54 <dons> it was bad, i agree
19:00:03 * lispy bows
19:00:13 <monochrom> haha
19:00:16 <ddarius> @users
19:00:16 <lambdabot> Maximum users seen in #haskell: 454, currently: 406 (89.4%), active: 13 (3.2%)
19:00:22 <pjd> record labels lack function, and values?
19:00:32 <monochrom> hahaha
19:00:48 <dons> and they're second class citizens
19:01:15 <dons> also, everyone wants to replace them, but no one seems to be able to do it
19:01:16 <lispy> tomorrow's headlines, "Haskell Community defeats Music Industry"
19:02:03 <lispy> well, my only real gripe with the status quo record labels is the lack of namespaces
19:02:10 <lispy> You have to force it with modules.
19:02:44 <lispy> If we had something like a C++ namespace, I wouldn't have anything left to complain about.
19:04:19 <oerjan> istarex: it is best to indent then & else more than if.  it actually rarely matters, mostly in the top level of a do expression
19:08:28 <oerjan> probably only there.  this is because do expressions are the only indented blocks in which the indented lines themselves can be expressions
19:09:01 <oerjan> *indentation-sensitive blocks
19:12:53 <istarex> http://hpaste.org/5190
19:13:08 <istarex> Would this be an example of such a top level do block with an example?
19:13:20 <oerjan> yep, that would not parse
19:13:21 <istarex> *with a problem
19:13:28 <istarex> indeed, it doesn't parse :-)
19:14:33 <oerjan> now by top level i mean that the if is top level _in_ a do block, not that the do block itself is anywhere in particular
19:15:47 <istarex> The problem is that the parser reads each of the "if ...", "then ...", "else ..." as individual expressions?
19:16:43 <oerjan> as individual statements in a do expression, yes
19:16:59 <oerjan> technically the layout rule inserts semicolons between them
19:17:03 <lispy> istarex: I'm not sure about that, but usually just put the if on one line, then on the next line indent 2 spaces and start with 'then', go to the next line, indent to the 'then' and put your 'else'
19:18:00 <hpaste>  (anonymous) annotated "So would this be an example of a top level do block?" with "(no title)" at http://hpaste.org/5190#a1
19:18:03 <oerjan> there is a proposal to allow semicolons in that position, which would make that syntax legal in the future
19:18:32 <oerjan> (with if then and else lined up)
19:26:22 <Twey> Is GHC written in Haskell?
19:26:55 <shepheb> I ask the wisdom of the group: If I had two Chars I wanted to XOR by their ASCII values, what would be the best way?
19:27:13 <oerjan> > on
19:27:14 <lambdabot>   Not in scope: `on'
19:27:22 <sarehu> > 'a' .|. 'b'
19:27:22 <byorgey> Twey: it sure is! =)
19:27:22 <lambdabot>   add an instance declaration for (Bits Char)
19:27:22 <lambdabot>     In the expression: 'a' .|. ...
19:27:26 <sarehu> sigh
19:27:48 <sarehu> > chr (ord 'a' .|. ord ' ')
19:27:48 <lambdabot>  'a'
19:27:51 <oerjan> @let on (+) f x y = f x + f y
19:27:53 <lambdabot> Defined.
19:28:14 <davidL> :t xor
19:28:15 <sarehu> <sarehu> > chr (ord 'a' `xor` ord ' ')
19:28:15 <lambdabot> forall a. (Bits a) => a -> a -> a
19:28:22 <sarehu> > chr (ord 'a' .|. ord ' ')
19:28:23 <lambdabot>  'a'
19:28:32 <sarehu> > chr (ord 'a' `xor` ord ' ')
19:28:32 <lambdabot>  'A'
19:28:35 <sarehu> gah!  I accuse Emacs.
19:28:39 <oerjan> > chr $ ((.|.) `on` ord) 'a' ' '
19:28:41 <lambdabot>  'a'
19:29:14 <oerjan> > chr $ (xor `on` ord) 'a' ' '
19:29:15 <lambdabot>  'A'
19:29:47 <shepheb> that 'on' function has to already have a name
19:29:56 <oerjan> yep, "on"
19:29:57 <shepheb> and I want to know it, that would be very handy
19:30:01 <oerjan> but it's new in 6.8
19:30:04 <Twey> byorgey, hm, I was looking for an example of a compiler written in Haskell.  I suppose GHC will do at a stretch, but do you know of a simpler example?
19:30:09 <shepheb> oh, is bot 6.6?
19:30:12 <dons> > ord 'a' `xor` ord 'b'
19:30:12 <lambdabot>  3
19:30:15 <oerjan> @version
19:30:15 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
19:30:15 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:30:18 <dons> > chr $ ord 'a' `xor` ord 'b'
19:30:18 <lambdabot>  '\ETX'
19:30:48 <shepheb> anyway, thanks. 'on' is worth its weight in gold, how many times have I wanted that
19:31:27 <oerjan> it fits in nicely with &&& and ***
19:31:33 <sarehu> Where is 'on' in 6.8?
19:31:40 <oerjan> Data.Function
19:32:34 <Korollary> Twey: Would Write yourself a scheme in 48 hours count?
19:32:56 <shepheb> minor gaff with on, for those to whom it's new: it's [infixl 0], meaning it will clash with ($)
19:33:03 <Twey> Korollary: IIRC, that was interpreted
19:33:33 <oerjan> shepheb: sheesh, they gave it that fixity explicitly? :(
19:33:57 <shepheb> yeah, I just wrote chr $ xor `on` ord and it choked
19:35:00 <byorgey> Twey: I don't know of any others, sorry
19:35:10 <Twey> Say... since Haskell has no side-effects, wouldn't it be possible to reverse a function programmatically?
19:35:20 <Twey> byorgey, oh, thanks anyway
19:35:25 <Twey> byorgey: Hard way it is then :-)
19:35:48 <byorgey> Twey: reverse? you mean find the inverse?
19:35:51 * Twey ponders.
19:36:00 <Twey> That's a flawed assumption actually, isn't it
19:36:01 <byorgey> Twey: not all functions have inverses, whether or not there are side effects.
19:36:02 <Twey> Ignore that
19:36:05 <Twey> Yes
19:36:11 <Twey> I realised after asking :-P
19:36:22 <Twey> MD5 sprang to mind
19:36:24 <oerjan> Twey: for finite domains perhaps
19:36:36 <oerjan> but it will not be efficient
19:36:41 <byorgey> Twey: it's not a completely ridiculous thought though. for example, J can automatically derive inverses for certain classes of functions.
19:36:45 <shepheb> or pull a Turing-machine-on-halting-problem and find the inverse of the inverting function. what about the inverse of ($)?
19:37:13 <byorgey> Twey: in fact, I was just thinking about that, since J has an 'under' operator which is like 'on' except that it applies the inverse at the end =)
19:37:19 <Twey> Heh :-)
19:37:28 <Twey> That's what got me to thinking about it too
19:37:43 <Twey> Although I didn't know about J
19:37:46 <oerjan> shepheb: what's worse is infixl is useless for on, because (op `on` f) `on` g = op `on` (f . g)
19:39:20 * byorgey ponders an 'Invertible' class for reified function values...
19:40:03 <oerjan> although op1 `on` (op2 `on` f) might not be very frequent...
19:43:13 <oerjan> @pl let on op f x y = f x `op` f y in op1 `on` (op2 `on` f)
19:43:14 <lambdabot> (. ((. f) . op2 . f)) . op1 . (. f) . op2 . f
19:43:33 <oerjan> @pl let on op f x y = f x `op` f y in (op1 `on` (op2 `on` f)) a b
19:43:34 <lambdabot> op1 (op2 (f a) . f) (op2 (f b) . f)
19:43:49 <oerjan> @pl let on op f x y = f x `op` f y in (op1 `on` (op2 `on` f)) a b c
19:43:50 <lambdabot> op1 (op2 (f a) . f) (op2 (f b) . f) c
19:44:22 <oerjan> @. unpl pl let on op f x y = f x `op` f y in op1 `on` (op2 `on` f)
19:44:23 <lambdabot> (\ g y -> op1 (\ ae -> op2 (f g) (f ae)) (\ ab -> op2 (f y) (f ab)))
20:00:10 <glguy> > lcm 16 23
20:00:10 <lambdabot>  368
20:06:26 <dobblego> ?hoogle (MonadZero m) => m a -> b -> b
20:06:27 <lambdabot> Prelude.const :: a -> b -> a
20:06:27 <lambdabot> Prelude.asTypeOf :: a -> a -> a
20:06:27 <lambdabot> Prelude.seq :: a -> b -> b
20:06:37 <ddarius> As far as I know, Hugs is the only Haskell implementation not written in Haskell.
20:07:02 <kmcallister> what's it written in?
20:07:08 <gwern> how foolish of them?
20:07:25 <ddarius> C
20:07:28 <kmcallister> and i'm pretty sure there are others, but they might all be obsolete
20:07:32 <kmcallister> ouch, that sounds very painful
20:07:40 <ddarius> Well hbc was originally LML
20:08:11 <oerjan> dobblego: that type does not make sense, you are escaping the monad
20:08:43 <oerjan> also, hoogle doesn't do generic monad types
20:08:44 <dobblego> oerjan, I just want a function like "if zero then this else that
20:09:44 <oerjan> dobblego: the zero of a MonadZero is not necessarily comparable to anything
20:09:57 <dobblego> oerjan, I know; I was just guessing very loosely
20:10:01 <oerjan> it's something to pass out
20:12:16 <oerjan> a Foldable might give enough power to do that
20:12:38 <dobblego> with Eq over the type argument you mean?
20:12:45 <dobblego> ?instances Foldable
20:12:46 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
20:12:51 <dobblego> ?instances Data.Foldable
20:12:52 <lambdabot> Couldn't find class `Data.Foldable'. Try @instances-importing
20:13:13 <oerjan> i think you can test a Foldable for emptiness
20:13:30 <dobblego> well, you can convert it to a [] at least
20:13:35 <oerjan> in fact, any (const True)
20:13:43 <oerjan> (Data.Foldable.any)
20:13:52 <geezusfreeek> comonad ftw!
20:13:53 <dobblego> ah yes, cheers
20:14:23 <EvilRanter> ?instances-importing Data.Foldable Foldable
20:14:24 <lambdabot> Maybe, []
20:15:03 <oerjan> EvilRanter: i think most instances are defined with the type
20:15:21 <EvilRanter> ?instances-importing Data.Foldable Data.Set Foldable
20:15:21 <lambdabot> Maybe, Set, []
20:15:26 <EvilRanter> huh.
20:17:16 <oerjan> Set is Foldable?  the Ord constraint doesn't get in the way?
20:18:04 <EvilTerran> the type itself doesn't have an Ord constraint, only some of the functions on it
20:18:08 <sjanssen> @keal
20:18:08 <lambdabot> what the hell does Prelude > mean?
20:18:09 <EvilTerran> ?type Data.Set.empty
20:18:10 <lambdabot> forall a. Data.Set.Set a
20:18:10 <oerjan> ah
20:18:16 <EvilTerran> ?type Data.Set.singleton
20:18:16 <lambdabot> forall a. a -> Data.Set.Set a
20:18:31 <EvilTerran> ?type {- but -} Data.Set.union
20:18:32 <lambdabot> forall a. (Ord a) => Data.Set.Set a -> Data.Set.Set a -> Data.Set.Set a
20:19:23 <EvilTerran> the problem with defining a Monad instance for Set is that >>= would need the Ord constraint
20:19:29 <oerjan> right
20:19:41 <oerjan> Traversable too, i think
20:19:50 <EvilTerran> ?
20:20:00 <EvilTerran> what about Traversable?
20:20:05 <oerjan> hm wait
20:20:16 <oerjan> it may not make sense in any case
20:20:39 <EvilTerran> i have no idea what you're talking about
20:20:44 <oerjan> actually just Functor breaks it
20:20:52 <EvilTerran> breaks what?
20:20:55 <oerjan> Set
20:21:05 <EvilTerran> ah
20:21:30 <EvilTerran> yeah, you'd need some MPTC-laden hack or something
20:23:16 <EvilTerran> class FunctorOf a b f | a f -> b, b f -> a where fomap :: (a -> b) -> f a -> f b; instance (Ord a, Ord b) => FunctorOf a b Set where fomap = S.map -- kinda thing
20:24:39 <oerjan> those fundeps look painful
20:24:47 <EvilTerran> altho, even with that, it wouldn't be a proper functor; it fails fmap (f.g) = fmap f.fmap g
20:24:54 <EvilTerran> ...i think
20:25:12 <EvilTerran> actually, those fundeps're wrong; delete 'em :P
20:26:16 <EvilTerran> actually, i think it does pass that, even with equal results being merged
20:27:16 <oerjan> assuming Eq is indistinguishable equality
20:27:39 <EvilTerran> which i think is assumed when you use a Set anyway
20:28:13 <EvilTerran> it does seem odd that it'd be a functor, tho, as it doesn't seem structure-preserving
20:28:36 <EvilTerran> fmap (const 1) would reduce any set to a singleton set
20:30:35 <oerjan> it preserves the structure of taking unions
20:31:28 <EvilTerran> i guess so; doing most set operations either before or after fmap'ing would have the same result, i think
20:31:43 <oerjan> um no, only union
20:31:51 <EvilTerran> intersect wouldn't work?
20:32:01 <oerjan> of course not
20:32:11 <EvilTerran> i don't see it, sorry
20:32:24 <ddarius> You'd "commute" the fmap not compare applying fmap to not applying fmap
20:32:29 <oerjan> just try your const 1 with two non-intersecting sets
20:32:39 <EvilTerran> eh, true
20:32:55 <EvilTerran> oh well. it's late, my brain's gone AWOL for the night.
20:32:59 <EvilTerran> i'm going to bed now.
20:33:16 <oerjan> the other boolean set operations are only preserved under _inverse_ mapping
20:34:53 <wy> I found O'Haskell. Anyone tried that?
20:40:34 <chessguy> sounds hideous
20:41:34 <wagle> also see o'hugs and timber..  i find activity for timber february 2007, but i didn't look hard
20:41:53 <shepheb> @pl (\x -> if x == ',' then ' ' else x)
20:41:53 <lambdabot> flip if' ' ' =<< ((',') ==)
20:42:14 <shepheb> @type if'
20:42:19 <lambdabot> Not in scope: `if''
20:42:30 <wagle> sed 's/@pl./@obfuscate/g'
20:42:52 <shepheb> can anyone explain that? I was hoping it might hint at a way to do a pointfree conditional
20:43:17 <ddarius> if' is a function that does the same thing as if that @pl makes up and uses
20:44:14 <wagle> if' x y z = if x y z
20:44:15 <wagle> ?
20:44:17 <chessguy> ddarius, it's also commonly defined by many people
20:44:31 <chessguy> if' x y z = if x then y else z
20:44:39 <wagle> duh yeah
20:45:33 <wagle> -ETOOMANYPROGRAMMINGLANGUAGES
20:45:33 <chessguy> @type \x y z -> if x then y else z
20:45:35 <lambdabot> forall t. Bool -> t -> t -> t
20:49:11 <oerjan> @pl \i t e -> [e,t] !! fromEnum i
20:49:12 <lambdabot> flip (flip . ((!!) .) . flip (:) . return) . fromEnum
20:49:34 * oerjan cackles evilly
20:52:04 <oerjan> @pl \i t e -> fromJust ((guard i >> Just t) `mplus` Just e)
20:52:05 <lambdabot> ((fromJust .) .) . flip flip Just . (((.) . mplus) .) . (. Just) . (>>) . guard
20:52:43 <oerjan> this is not precisely improving
21:31:06 <Korollary> pgavin: I read I, Claudius.
21:43:05 <vincenz> @join #oasis
21:58:08 <Tac-Tics> @src forM
21:58:08 <lambdabot> forM = flip mapM
21:58:14 <Tac-Tics> @src mapM
21:58:14 <lambdabot> mapM f as = sequence (map f as)
22:03:17 <hpaste>  vincenz pasted "arithmetic" at http://hpaste.org/5191
22:03:47 <hpaste>  vincenz annotated "arithmetic" with "end part" at http://hpaste.org/5191#a1
22:04:25 <faxathisia> hey
22:05:28 <OceanSpray> ho
22:05:51 <dons> ?users
22:05:51 <lambdabot> Maximum users seen in #haskell: 454, currently: 396 (87.2%), active: 10 (2.5%)
22:06:23 <faxathisia> Anyone know what this is about http://cs.ioc.ee/efftt/mcbride-slides.pdf ? :p
22:06:29 <faxathisia> I don't get it
22:06:32 <davidL> is there a neat way people collaborate on papers over the internet? darcs seems like it would be the way to go but not everyone has darcs
22:07:21 <gwern> davidL: wikis?
22:07:39 <scook0> I guess your options are: wiki, (D)VCS, and collaborative editors
22:08:05 * gwern ruminates. a productive day! one of the good and bad things about yi is that so much of the infrastructure is there but it isn't really all pulled together. so you can add some nice functionality with relatively little work
22:09:08 <davidL> thanks, I guess I'll have to use some php or ruby wiki, thing :(
22:09:38 <cjb> gwern: I would like to hack on Yi!
22:09:57 <cjb> gwern: But first I need build instructions that work.  :)  Are there good ones somewhere?
22:10:01 <gwern> davidL: a wiki in HAppS backed by darcs would probably be an excellent project
22:10:06 <Tac-Tics> hey guys, I'm simultaneously trying to get my new hosting set up and write a haskell tutorial on the list monads. If anyone wants to give it a good critique, I'd be thrilled to hear from you
22:10:09 <Tac-Tics> http://www.tac-tics.net/
22:10:10 <lambdabot> Title: Tac-Tics.net
22:10:18 <davidL> gwern: you can read minds?
22:10:33 <cjb> I don't really understand why the List monad is called the Non-determinism monad.
22:10:45 * gwern whistles and examines fingernails
22:10:47 <cjb> I think that's probably a misleading term to use to explain it to non pure-CS people.
22:10:57 <gwern> cjb: the usual cabal trio of commands works not?
22:11:51 <dons> woot, got a purely functional mersenne twister working :)
22:11:53 <cjb> gwern: Is there a way to have cabal satisfy dependencies for me?
22:11:58 <dons> side effect free randoms for all
22:11:59 <cjb> (Sorry, newbie question.)
22:12:06 <Tac-Tics> cjb: maybe, but it perfectly models nondeterministic computations. I was originally going to go a lot heavier on the meaning of the term "nondeterminism", but I removed that section because it made it longer and boring..er
22:12:07 <scook0> dons: how quick is it?
22:12:15 <gwern> davidL: but srsly, a wiki in haskell using darcs would be a great idea, if only for haskell.org. it'd make backups a lot easier, I think people would participate more, it would be eating our own dogfood, and it's not like haskell.org uses advacned mediawiki features!
22:12:20 <dons> not known yet. should be faster than System.Random. number soon, scook0 :)
22:12:28 <dons> at least it returns the same 64 bits as the impure version
22:12:46 <dons> davidL: btw, i use darcs for papers i work on (with people all over)
22:12:51 <davidL> gwern: that was the original project actually, but I figured I should thoroughly plan it out first, thus my needing a collaborative thing
22:12:53 <scook0> cjb: check out cabal-install
22:12:54 <sjanssen> dons: jawesome
22:13:03 <cjb> scook0: that also has many unmet dependencies :)
22:13:04 <gwern> cjb: well, there's cabal install for easy installation, but iirc, it won't track down and install depedencides automatically when you try to install something from outside of hackage
22:13:05 <sjanssen> dons: how does it work?
22:13:14 <cjb> scook0: I guess I have to satisfy those by hand?
22:13:20 <dons> sjanssen: the impl. is quite cool. allocate on the haskell heap. pass that to a modifed C mersenne twister that's pure.
22:13:23 <gwern> cjb: and I would avoid the hackage release of yi. it's severely outdated
22:13:30 <dons> the C code then permutes the bits in the haskell heap.
22:13:30 <scook0> cjb: as far as I know, yeah :(
22:13:36 <cjb> gwern: ah.  what should I do?
22:13:37 <dons> before a next_rand call, copy the state
22:13:40 <scook0> it's not *that* bad, is it?
22:13:42 * scook0 checks
22:13:43 <adu> random numbers in Haskell?
22:14:00 * adu goes insane
22:14:05 <gwern> cjb: well, iirc, yi doesn't have too many dependencies. 'cabal install vty', install gtk2hs however, and you are pretty good to go
22:14:22 <dons> sjanssen: so i had to modify the C code to be truly:  new :: seed -> g; next :: g -> (int64, g')
22:14:24 <sjanssen> dons: it would be really cool if you supported the RandomGen class too
22:14:26 <dons> from there its easy :)
22:14:30 <dons> yeah, that's easy now. even split.
22:14:35 <gwern> cjb: oh, and 'cabal install fingertree' too. yi recently moved to a fingerstring datastructure
22:14:42 <cjb> Tac-Tics: I'm new to this, but when I think of the List monad I think of things like:  do{x<- ["a","b","c"];y<-[1,2,3];return (x,y)}
22:14:49 <cjb> gwern: I don't have cabal-install installed.
22:14:56 <sjanssen> gwern: oh, it did? /me is now tempted to check yi out
22:15:07 * gwern muses. and aren't regex-base, regex-posix, and regex-compat now separate packages?
22:15:15 <scook0> just grit your teeth and resolve cabal-install yourself -- it's worth it
22:15:15 <cjb> Tac-Tics: Which isn't non-deterministic, but still uses an important property of the monad.
22:15:17 <sjanssen> is yi usable-ish for a vim user yet?
22:15:18 <levi> Hmm, I'm getting weird link errors when I try to compile my program with ghc.
22:15:19 <lambdabot> levi: You have 1 new message. '/msg lambdabot @messages' to read it.
22:15:22 <cjb> scook0: okay, will do
22:15:33 <gwern> cjb: you can download from hackage by hand. cabal install just makes it much quicker
22:15:35 <scook0> cjb: you only have to do it once
22:15:44 <cjb> should I use darcs HEAD cabal-install?
22:15:55 <dons> cjb: yeah, probably. its pretty stable
22:16:03 <gwern> sjanssen: dunno. there were a few largish looking patches to the vi keymap recently, so I guess there are vi users working on yi
22:16:07 <scook0> gwern: c-i handles dependencies
22:16:23 <gwern> dons: wouldn't he run into problems with the cabal version being too recent?
22:16:26 <sjanssen> gwern: you're an emacser, right?  Is it usable for you?
22:16:32 <levi> Lots of undefined references to mtlzm1zi0zi1_... symbols
22:16:40 <Tac-Tics> cjb: the idea of List (when thinking about it as being "nondeterministic") is that you have functions which take an input but do not decide what the exact outcome is. Instead, you have the function return a whole list of _possible_ outcomes
22:16:48 <sjanssen> levi: use ghc --make or -package mtl
22:16:50 <levi> Do I have to manually tell it to link with the mtl library?
22:16:53 <levi> Ahh, thanks.
22:16:55 <gwern> sjanssen: I have been working on making it usable... as an emacser, it is much more useable than nano, but I wouldn't call it up to emacs level yet
22:17:08 <Tac-Tics> And List being a monad lets you compose functions together in a meaningful way
22:17:53 <gwern> scook0: right, but I was saying if he downloaded from darcs (as the hackage release is too ancient) and did 'runhaskell Setup configure...', cabal wouldn't satisfy dependencies from hackage by itself - at least in the version I have installed
22:18:02 <cjb> ah, cabal-install HEAD would require cabal HEAD, too.  Any ideas where I could get a cabal-install for cabal 1.2.3.0?
22:18:32 <cjb> Tac-Tics: I like your examples of the monad, whatever it's called :)
22:18:37 <gwern> scook0: if he did 'cabal install yi' (let's pretend it was updated so it'd actually compiled) then it'd pull in *some* of the dependcies, but not gtk2hs
22:18:44 <cjb> they're imperative-like, will make non-functional programmers feel at home.
22:18:54 <Tac-Tics> thanks :-)
22:19:14 <Tac-Tics> If there's anything that could be made clearer, or that you think would be interesting to expand upon, please let me know
22:19:30 <scook0> gwern: because it's not on hackage, you mean?
22:19:47 <gwern> sjanssen: btw, if you do work on yi, optimizations would be particularly welcome. it apparently took a performance hit in the transition (better big O, but larger constants)
22:20:21 <Tac-Tics> gwern: what is a fingerstring exactly? It looked briefly at the implementation, but I missed when it was added to yi
22:20:25 <cjb> Tac-Tics: hey, this is really cool.  thanks!
22:20:29 <gwern> (and there's one user who was particularly hit)
22:20:50 <gwern> scook0: right. it has a complex build process, dunno when it will be cabalized and hackagized
22:20:52 <Tac-Tics> I noticed Yi was super laggy in Vty too, so it wasn't just him
22:20:55 <sjanssen> @google fingertree haskell
22:21:01 <lambdabot> Plugin `search' failed with: Prelude.(!!): index too large
22:21:09 <sjanssen> huh?
22:21:11 <sjanssen> @google fingertree haskell
22:21:13 <lambdabot> Plugin `search' failed with: Prelude.(!!): index too large
22:21:16 <Twey> Takes another argument I guess
22:21:16 <gwern> Tac-Tics: it's a specialization of fingertree using bytestrings (lazy iirc)
22:21:17 <Tac-Tics> @fail
22:21:17 <lambdabot> Maybe you meant: fact faq
22:21:20 <faxathisia> Did no one understand what that Frank language is?
22:21:28 <Twey> @google "fingertree haskell"
22:21:29 <lambdabot> No Result Found.
22:21:38 <gwern> Twey: try wikipedia
22:21:39 <sjanssen> Tac-Tics: look for a paper on fingertrees by Paterson and Hinze
22:21:44 <Twey> Or... not.  What?
22:21:51 <Tac-Tics> sjanssen: gotcha
22:21:58 <Twey> gwern, I wasn't trying to find it, just work out the bot :-P
22:22:28 * gwern frowns. why won't people read and edit my [[finger tree]]?
22:23:29 <Twey> Heh
22:24:11 <sjanssen> gwern: the article says Yi "specializes" them.  Do you mean a copy-n-modify situation like Data.Sequence, or does it actually use the fingertree library?
22:25:36 <gwern> sjanssen: no no, there's an actual dependency there
22:25:52 <gwern> 'build-depends: fingertree'
22:27:28 <cjb> Tac-Tics: I'm gonna share that link with some friends who are also learning Haskell.  Thanks again!
22:27:46 <Tac-Tics> Cool. I'm glad you enjoyed it
22:29:36 <gwern> Tac-Tics: at least your post has chicken
22:29:52 <Tac-Tics> chicken?
22:30:00 <sjanssen> gwern: there is a free PDF of the Hinze/Paterson paper on the internet
22:30:16 <gwern> leeroy jenkins?
22:30:21 <Tac-Tics> ah
22:30:22 <Tac-Tics> heh
22:30:28 <gwern> sjanssen: I believe I linked that in my WP article didn't I?
22:30:59 <sjanssen> gwern: oh, didn't see it at first
22:31:49 <gwern> personally, I dunno what's so great about their 2-3 fingertrees, but I haven't really dug into the code and played with it
22:35:30 <sjanssen> gwern: the best part of that paper is the interface to the structure
22:36:46 <sjanssen> it measure/monoid stuff is outrageously flexible -- you can use the library to write random access sequences, maps, priority queues, range sets, and chunked sequences (as I imagine yi does)
22:37:39 <hpaste>  vincenz annotated "arithmetic" with "proper vanishing" at http://hpaste.org/5191#a2
22:37:57 <jsnx> @ let { f x = case x of ; (+) -> "plus" ; (-) -> "minus" } in f (-)
22:38:08 <jsnx> @let { f x = case x of ; (+) -> "plus" ; (-) -> "minus" } in f (-)
22:38:09 <lambdabot>  Parse error
22:38:11 <gwern> sjanssen: is there anything a finger tree can't do? :)
22:38:14 <jsnx> @let { f x = case x of ; (+) -> "plus" ; (-) -> "minus" }
22:38:16 <lambdabot> <local>:6:0: parse error on input `{'
22:38:38 <jsnx> >let { f x = case x of ; (+) -> "plus" ; (-) -> "minus" } in f (-)
22:38:47 <jsnx> > let { f x = case x of ; (+) -> "plus" ; (-) -> "minus" } in f (-)
22:38:48 <lambdabot>      Warning: Pattern match(es) are overlapped
22:38:48 <lambdabot>              In a case alterna...
22:39:00 <sjanssen> jsnx: @let inserts top level declarations, not let bindings (a bit of a misnomer, I know)
22:39:10 <jsnx> sjanssen: oic
22:39:11 <shachaf> jsnx: It won't work no matter how you phrase it. :-)
22:39:17 <jsnx> shachaf: i know
22:39:19 <jsnx> why not?
22:39:28 <jsnx> aren't functions values?
22:39:32 <jsnx> or are they?
22:39:36 <shachaf> jsnx: Well, what this does is bind the name (+) to x.
22:39:45 <shachaf> jsnx: Yes, but that doesn't mean they can be compared.
22:39:46 <sjanssen> jsnx: 1.  matching against a name doesn't implicitly match for equality 2.  functions don't have equality
22:39:54 <scook0> I used fingertrees for random selection-without-replacement, once
22:39:58 <jsnx> !!
22:39:59 <scook0> worked out quite nicely, actually
22:40:08 <shachaf> jsnx: How would you compare two functions?
22:40:28 <jsnx> shachaf: that's not my problem
22:40:33 <jsnx> there's probably a way
22:40:43 <shachaf> jsnx: Not in general.
22:40:57 <faxathisia> jsnk, You're being asked the question to make you think
22:40:59 <jsnx> shachaf: well, that's a question for mathematicians
22:41:02 <shachaf> jsnx: What makes two functions equal?
22:41:15 <sjanssen> gwern: are you familiar with the algorithm strategy of using "decorated" binary trees?
22:41:23 <Tac-Tics> shachaf: pointer equality! f(x) = g(x) for a couple small values x!
22:41:37 <jsnx> shachaf: for one argument functions, i don't know
22:42:10 <jsnx> but for multiple argument functions, we define them to be equal if applying the same arguments results in equal single argument functions :)
22:42:20 <gwern> sjanssen: not at all
22:42:29 <shachaf> jsnx: You could do the same with values.
22:42:40 <jsnx> shachaf: i do not understand
22:43:00 <shachaf> jsnx: Applying the same arguments results in equal return values. :-)
22:43:15 <sjanssen> gwern: well, Data.FingerTree essentially subsumes all of those in a very convenient fashion
22:43:20 <shachaf> jsnx: Are (\x -> x + 1) and (\x -> if x == 1000 then 0 else x + 1) equal?
22:43:20 <jsnx> shachaf: yes, but you'll notice i've basically punted on the one argument case
22:43:22 <Tac-Tics> Oh, if the indefinite integrals of two functions over the reals are equal!
22:43:34 <shachaf> jsnx: Haskell doesn't have multiple-argument functions.
22:43:42 <jsnx> shachaf: not directly
22:43:57 <shachaf> jsnx: So defining equality on them is pointless. :-)
22:44:55 <jsnx> shachaf: no it isn't
22:45:08 <shachaf> jsnx: Why not?
22:45:14 <jsnx> shachaf: one argument functions in haskell are those special functions that do not return functions
22:45:27 <faxathisia> > id 5
22:45:28 <lambdabot>  5
22:45:29 <faxathisia> > id id
22:45:30 <lambdabot>  Add a type signature
22:45:41 <shachaf> jsnx: (+) is a one-argument function.
22:45:45 <faxathisia> Is id a 1 arg function?
22:45:59 <jsnx> faxathisia: sure
22:46:16 <shachaf> faxathisia: I think jsnx meant "do not always return functions".
22:46:20 <faxathisia> Not by your definition
22:46:21 <shachaf> (What about printf?)
22:46:29 <shachaf> > printf "abc"
22:46:29 <lambdabot>  Add a type signature
22:46:34 <shachaf> > printf "abc" :: String
22:46:35 <lambdabot>  "abc"
22:46:41 <shachaf> > printf "a%dc" 8 :: String
22:46:42 <lambdabot>  "a8c"
22:47:00 <jsnx> it has to depend on the type signature, sure
22:47:21 <jsnx> obviously, the same lexeme, attached to a different type signature, is different
22:47:48 <jsnx> anyways, it's too bad i can't pattern match on functions
22:47:55 <jsnx> it would have been cool
22:48:04 <shachaf> jsnx: Absolutely. :-)
22:48:19 <shachaf> @go halting problem
22:48:20 <lambdabot> http://en.wikipedia.org/wiki/Halting_problem
22:48:20 <lambdabot> Title: Halting problem - Wikipedia, the free encyclopedia
22:48:30 <jsnx> shachaf: i do appreciate the practical difficulties
22:48:32 <Tac-Tics> Things would be much cooler if certain mathematical problems weren't so intractable =-(
22:48:43 <shachaf> jsnx: s/practical/theoretical/
22:48:47 <faxathisia> If 6 was 9
22:48:56 <jsnx> i don't see why pointer equality is not good enough
22:49:09 <sjanssen> jsnx: pointer equality breaks referential transparency
22:49:09 <Tac-Tics> pointers in Haskell don't make sense
22:49:16 <ray> yeah things would be cooler if you could have perpetual motion machines too
22:49:19 <shachaf> let g = f in f == g?
22:49:38 <jsnx> sjanssen: it doesn't matter -- you don't have to expose the pointers
22:49:58 <shachaf> jsnx: Should that be True or False?
22:49:59 <Tac-Tics> jsnx: If you want something like that, you can use IORefs. I'm pretty sure they're Eq
22:50:06 <jsnx> oic
22:50:15 <Tac-Tics> yep
22:50:22 <sjanssen> jsnx: the pointers per se aren't the only problems, pointer equality is enough to break it
22:50:25 <jsnx> so you guys think function equality has to do with the halting problem?
22:50:30 <Tac-Tics> IORefs and *Refs in general are the points of haskell
22:50:39 <jsnx> sjanssen: why is that?
22:50:45 <faxathisia> extensional equality
22:51:02 <jsnx> faxathisia: oic
22:51:13 <gwern> jsnx: yes. heck, I have been given to understand that arithmetic equality has a halting problem
22:51:41 <sjanssen> jsnx: referential transparency says that the expression "let f x = x in f == f" and "(\x -> x) == (\x -> x)" must be the same
22:51:52 <Tac-Tics> jsnx: the problem is with functions which are total but not computable for all values x
22:52:20 <sjanssen> jsnx: but how can we guarantee this with pointer equality?
22:52:33 <Tac-Tics> but on a more practical note, equal functions have proofs that they are equal. And finding general-form proofs is exponential in time
22:53:33 <shachaf> jsnx: halts f x = let { g y | y == x = undefined | otherwise -> f y } in f /= g
22:53:45 <levi> Tac-Tics: Your List monad tutorial is pretty nifty.  The only comment I have to make is regarding 'all intensive purposes', which is an eggcorn of 'all intents and purposes'
22:53:47 <sjanssen> jsnx: or, put more simply "let x = 5 in x === x" and "5 === 5" (where === is the pointer equality function)
22:54:16 <funktio> @pl \f x y -> f x == f y
22:54:16 <lambdabot> flip =<< (((.) . (==)) .)
22:54:30 <shachaf> (==) `on` f
22:54:31 <Tac-Tics> levi: hah. Yeah, I only learned about that distinction earlier this year
22:54:36 <Tac-Tics> I'll fix that, thanks for the read
22:54:39 <jsnx> sjanssen: i'm not sure about your last example, but the first one was pretty clear
22:54:41 <faxathisia> @src on
22:54:41 <shachaf> @let on (*) f x y = f x * f y
22:54:41 <lambdabot> (*) `on` f = \x y -> f x * f y
22:54:42 <lambdabot> <local>:6:0:     Multiple declarations of `L.on'     Declared at: <local>:2:0...
22:55:15 <sjanssen> jsnx: so you agree?
22:55:32 <jsnx> sjanssen: with a heavy heart
22:55:45 <jsnx> sjanssen: pointer equality is no good
22:55:49 <faxathisia> Tac-Tics, What does "general-form proofs is exponential in time" mean?
22:56:21 <jsnx> sjanssen: we would have to guarantee that all the functions that reduce to f are assigned the same pointer
22:56:30 <jsnx> sjanssen: which is not reasonable
22:56:32 <shachaf> jsnx: Functions are equal if they give the same result for each argument.
22:56:36 <shachaf> jsnx: Or possible.
22:56:39 <Tac-Tics> it means if you want to find a proof for some mathematical theorem, unless it's a special kind of theorem where we know how to do it really fast (like type checking), it's takes a long time to do it
22:56:50 <faxathisia> :S
22:56:59 <shachaf> jsnx: How do you tell (\x -> x) apart from (ap const undefined)?
22:57:09 <sjanssen> jsnx: :).  One of the mottos of Haskell is "No deals with the devil!" so we occasionally lose convenience to maintain purity
22:57:12 <faxathisia> I don't think that's true?
22:57:34 <jsnx> shachaf: well, i was sort of thinking, that these functions are refer to symbols in some table somewhere...
22:57:56 <jsnx> but truth be told, `1.0 +` is a different thing from `1 +`
22:57:59 <faxathisia> You can't really write a program that could prove any theorem in exp time.. can you?
22:58:00 <shachaf> jsnx: It goes back to comparing functions, though.
22:58:12 <shachaf> jsnx: Those even have different types, that's not really relevant.
22:58:19 <ray> you just generate and verify every possible statement
22:58:25 <shachaf> jsnx: But (\x -> x) and (ap const 8) *are* equal.
22:58:38 <jsnx> shachaf: well, the (+) in that case also refers to different things
22:58:47 <faxathisia> ray, There is often infinite
22:58:50 <gwern> faxathisia: sounds plausible to me. I know schmidhuber and his godel design can do that in a reasonable bound (with an absurdly huge constant of course)
22:58:58 <Tac-Tics> faxathisia: I'm not that good with complexity theory. All I know is that it can be solved much easier with a List monad and a nondeterministic computer
22:59:05 <jsnx> so (+) need not refer to anything in particular
22:59:08 <glguy> :t ap const 8
22:59:09 <lambdabot> forall a. (Num (a -> b)) => a -> a
22:59:10 <shachaf> jsnx: This limitation is much more general than (+). :-)
22:59:17 <sjanssen> shachaf: that case seems entirely possible.  I think you'll have to introduce the halting problem again to be convincing
22:59:23 <shachaf> Hmm, sorry.
22:59:27 * shachaf didn't mean 8.
23:00:01 <shachaf> jsnx: You agree that you can't decide if (f x) halts forall f and x?
23:00:10 <faxathisia> so does there exist an implementation of this universal theorem prover?
23:00:18 <jsnx> shachaf: okay, sure
23:00:20 <shachaf> sjanssen: I was saying that it goes back to the other equality.
23:00:26 <jsnx> shachaf: for the same of argument
23:00:31 <shachaf> jsnx: halts f x = let { g y | y == x = undefined | otherwise -> f y } in f /= g
23:00:56 <jsnx> shachaf: okay, but isn't there a difference between functions and procedures?
23:01:08 <shachaf> jsnx: Haskell doesn't have procedures.
23:01:14 <shachaf> jsnx: (What's the difference?)
23:01:25 <jsnx> shachaf: functions don't terminate
23:01:26 <shachaf> (That you meant, I mean?)
23:01:30 <Tac-Tics> jsnx: It depends what context. Like "weak typing", the meaning is only vague unless you're talking about a particular language
23:01:35 <jsnx> they don't have operational semantics
23:01:47 <jsnx> Tac-Tics: granted
23:02:05 <shachaf> jsnx: Functions return values.
23:02:06 <Tac-Tics> A lambda expression in Scheme is technically called a "Procedure", but in Pascal, a procedure is (I believe) a non-recursive function
23:02:08 <shachaf> jsnx: Or they don't.
23:02:19 <jsnx> shachaf: oic
23:02:29 <shachaf> jsnx: Right?
23:02:34 <Tac-Tics> In my own terms, I like to think that procedures are side-effectful and functions as pure
23:02:44 <Tac-Tics> like execState vs evalState
23:02:49 <jsnx> Tac-Tics: i follow the same convention
23:02:56 <shachaf> Tac-Tics: Those are the terms I like.
23:03:02 <jsnx> shachaf: *programs*
23:03:05 <levi> A Pascal procedure does not return a value, while a Pascal function does (IIRC, at least)
23:03:11 <Tac-Tics> scheme's terminology bugs me :)
23:03:13 <jsnx> shachaf: we're talking about programs, not functions
23:03:19 <dons> sjanssen: ah well. needs some improvment. old System.Random, 12.760. new pure MT, 3.180, impure MT, 0.080, simd MT 0.060
23:03:23 <JanglerNPL> Consider two functions from Integer -> Integer; one, f, is (\x -> 0). The other g, takes any integer n, and outputs 0 if |2(n+2)| is expressible as the sum of two primes, and 1 otherwise.
23:03:27 <JanglerNPL> Is f = g?
23:03:32 <dons> sjanssen: so all that state copying to make it pure (without uniquness) costs a little.
23:03:46 <sjanssen> dons: the new one isn't SIMD?
23:04:02 <jsnx> JanglerNPL: the compiler may not be able to sort that out
23:04:06 <dons> no, that's got too large and complex a state.
23:04:13 <sjanssen> dons: so when is the state copied?
23:04:13 <dons> its the 'classic' mersenne twister, from 97.
23:04:17 <ray> would have to be a *very* clever compiler
23:04:18 <dons> each call to 'next'
23:04:25 <dons> next :: g -> (a,g')
23:04:46 <jsnx> shachaf: i guess comaring functions in a functional programming language amounts to comparing programs -- and one can not do that in general
23:04:50 <sjanssen> dons: isn't it possible to copy significantly less often?
23:04:59 <dons> only by giving up purity in one way or another.
23:05:09 <dons> we could allow impure 'next', but allow multiple generators
23:05:10 <shachaf> jsnx: What do you mean? What other types of functions are there?
23:05:29 <jsnx> shachaf: the word has usage outside of functional programming
23:05:29 <sjanssen> dons: AIUI, the algorithm generates a big hunk of random data, then keeps a finger at the current position.  When the current position reaches the end a new hunk is generated
23:05:31 <shachaf> jsnx: (We're talking about the -calculus, right?)
23:05:33 <sjanssen> dons: is that accurate?
23:05:55 <dons> roughly
23:06:04 <jsnx> shachaf: i've also never heard any one talk about whether or not 'functions' terminate
23:06:22 <dons> ah, so maybe we copy too much. the algorithm might be tuned to diff (sounds a bit scary)
23:06:30 <sjanssen> dons: so couldn't the Haskell defn. look something like: data Gen = Gen Int HunkO'Bytes ?
23:06:48 <shachaf> jsnx: Functions return values, right?
23:07:01 <sjanssen> then 'next (Gen n bs) | n < length bs = (peek n bs, Gen (n+1) bs)'
23:07:20 <dons> ah, you have to mess with the value at 'n'
23:07:38 <jsnx> shachaf: they reduce to values
23:07:38 <sjanssen> and then a second case where a new HunkO'Bytes is created (however you do that)
23:07:47 <jsnx> shachaf: is that the same thing?
23:07:59 <dons> we could do chunks at a time though. i see what you're getting at.
23:08:01 <jsnx> shachaf: you see, i don't know for a fact that it is
23:08:29 <shachaf> jsnx: What does (\x -> x x) (\x -> x x) reduce to?
23:08:38 <dons> so eagerly generate say, 1000 results, then use those, instead of copying.
23:08:40 <sjanssen> dons: so you'd only have to do a new copy/allocation every 'N' bytes read
23:08:42 <jsnx> so i felt it was clearer -- it was at least clearer to me -- if i thought in terms of programs instead
23:08:43 <dons> yeah
23:08:49 <jsnx> shachaf: just a second
23:09:09 <shachaf> jsnx: (Note that that's not valid Haskell.)
23:09:10 <jsnx> shachaf: i think that's Omega?
23:09:30 <sjanssen> dons: AIUI, this is how the internal algorithm works, so hopefully you could just abstract out the 'finger'
23:09:41 <jsnx> shachaf: anyways, some of them may not reduce
23:09:49 <jsnx> for example, 6
23:09:57 <jsnx> it does no go anywhere from there
23:10:03 <jsnx> s/no/not/
23:10:06 <dons> internally its a bit more complex. there's a finger, but a bunch of other things get mutated when you extract a value.
23:10:17 <dons>         for (i=0;i<NN-MM;i++) {
23:10:17 <dons>             x = (st->mt[i]&UM)|(st->mt[i+1]&LM);
23:10:17 <dons>             st->mt[i] = st->mt[i+MM] ^ (x>>1) ^ mag01[(int)(x&1ULL)];
23:10:17 <dons>         }
23:10:26 <jsnx> !!
23:10:35 <dons> a big chunk of the array gets flipped around
23:10:37 <sjanssen> dons: damned C code :(
23:10:53 <dons> but .. we can eagerly produce many results, and cache them
23:10:59 <sjanssen> yeah
23:10:59 <shachaf> jsnx: Does (\x -> x x) (\x -> x x) go anywhere?
23:11:11 <dons> though then we'd hide the intermediate states. weird
23:11:28 <jsnx> shachaf: we need some kind of rule about me answering your questions
23:11:40 <jsnx> shachaf: namely, that you respond to my answer
23:11:55 <shachaf> jsnx: What was your answer?
23:12:13 <jsnx> shachaf: it's whatever goes in between your questions
23:12:19 <shachaf> jsnx: There is clearly a difference between trying to reduce 6 and trying to reduce (\x -> x x) (\x -> x x), right?
23:12:32 <jsnx> shachaf: sure
23:13:06 <jsnx> shachaf: however, you aren't being at all specific about the difference
23:13:18 <jsnx> shachaf: so i'm not sure what you were trying to impart with that
23:13:33 <Tac-Tic1> stupid comcast @ grr
23:13:35 <dmwit> You can keep "reducing" shachaf's expression forever and never get anywhere.
23:13:40 <dmwit> That's the point.
23:14:06 <dmwit> The difference between that and, say, 6 is that you can evaluate it (but not reduce it).
23:14:07 <jsnx> dmwit: when you say, never get anywhere, you mean, it keeps growing and growing?
23:14:16 <shachaf> jsnx: No.
23:14:21 <dmwit> jsnx: No, it stays exactly the same.  Try it. =)
23:14:21 <jsnx> shachaf: o
23:14:21 <shachaf> jsnx: It stays the same size.
23:14:28 <jsnx> shachaf: oic
23:14:31 <ray> no, that would be (\x -> x x x) (\x -> x x x) :)
23:14:32 <shachaf> (\x -> x x) y = y y
23:14:33 <jsnx> well, that's like 6
23:14:48 <shachaf> jsnx: What's 6?
23:14:53 <ray> but you can't apply the beta-whatsis to 6
23:14:54 <shachaf> There are only functions. :-)
23:15:00 <jsnx> shachaf: aye
23:15:04 <dmwit> It's not like 6.  We can recognize 6 as a primitive.  But this is not a primitive.
23:15:11 <jsnx> dmwit: oic
23:15:16 <jsnx> dmwit: why not?
23:15:20 <dmwit> ...oh, we're in lambda calculus?
23:15:29 <shachaf> dmwit: Why not?
23:15:29 <dmwit> Never mind, I thought we were in Haskell.
23:15:36 <jsnx> dmwit: oic
23:15:40 <shachaf> dmwit: (\x -> x x) isn't valid Haskell. :-)
23:15:45 <ray> in haskell that's a type error
23:15:47 <quicksilver> it's not a primitive because there is a rule that applies
23:15:51 <quicksilver> the application rule
23:15:55 <dmwit> No, but it's a reasonable thing to think about anyway.
23:15:58 <jsnx> quicksilver: oic
23:16:04 <quicksilver> if you have 6 in lambda calculus as, e.g., church encoding
23:16:09 <quicksilver> there is no rule that applies
23:16:13 <quicksilver> so you can't reduce it.
23:16:19 <jsnx> so, i see where this is going
23:16:24 <shachaf> Sure, just like you can't reduce (\x -> x).
23:16:43 <jsnx> the church-turing whatsit
23:16:44 <quicksilver> some reduction sequences stop, because there are no rules that apply.
23:16:44 <dmwit> tamazon.com
23:16:54 <quicksilver> some reduction sequences continue for ever
23:16:58 <jsnx> so, functions and programs, same difference
23:17:02 <Tac-Tic1> jsnx: Two lambda expressions are equal if and only if their normal forms (if you fully beta-reduce them) are equal up to alpha conversion (so the only difference between them are their variable names)
23:17:03 <quicksilver> some reduction sequences, we can't even tell if they stop, or not!
23:17:21 <shachaf> jsnx: What's a program?
23:18:08 <jsnx> shachaf: well, a program is a sequence of instructions
23:18:22 <shachaf> jsnx: "sequence" as in "do this, then do that"?
23:18:42 <jsnx> shachaf: well, no, you need NOR in there
23:18:59 <jsnx> shachaf: so it's a sequence of NORs
23:19:25 <jsnx> shachaf: is that good enough?
23:19:37 <jsnx> shachaf: however, that is not really honest of me
23:19:45 <jsnx> shachaf: a program runs on computers
23:19:56 <shachaf> jsnx: In that case, we're not talking about programs. :-)
23:20:10 <jsnx> shachaf: with haskell functions, we are ;)
23:20:20 * shachaf wasn't talking about Haskell.
23:20:39 <hpaste>  ramza3 pasted "python formula in haskell" at http://hpaste.org/5192
23:20:52 <shachaf> Functions can be applied to values, right?
23:20:56 <shachaf> To return other values.
23:21:12 <ramza3> I was trying to convert the py code to haskell, but I dont know how to save the previous value of "trm"
23:21:30 <jsnx> shachaf: i bet that if you simply stated it, it would take less time
23:21:44 <shachaf> jsnx: Stated what?
23:22:00 <jsnx> shachaf: your argument
23:22:05 <Tac-Tic1> ramza3: you probably want to use a state monad or rewrite the whole thing recursively
23:22:18 <Tac-Tic1> actually, if it's just a straight for loop, you can use map
23:22:23 <shachaf> jsnx: I did.
23:22:44 <jsnx> oh
23:23:00 <shachaf> I'm not sure what we're talking about anymore... :-)
23:23:07 <shachaf> jsnx: Can functions be compared?
23:23:08 <Korollary> orange lamborghinis
23:23:12 * quicksilver very much doubts that ramza3 wants the state monad.
23:23:19 <Tac-Tic1> quicksilver: yeah
23:23:26 <jsnx> shachaf: in some cases
23:23:30 <quicksilver> looks like a fold to me
23:23:33 <Tac-Tic1> ramza3: what is this little bit of code for?
23:24:25 <quicksilver> foldl (\(term,sum) i -> (term * (m/i) , sum+term)) (exp -m) [1..(df`div`2)]
23:24:27 <shachaf> jsnx: Can you write instance Eq (a -> b)?
23:24:30 <jsnx> shachaf: i worry that the axiom of choice comes into play here
23:24:34 <shachaf> (Can anyone write it?)
23:24:38 <quicksilver> ah yeah, that's what he wrote
23:24:39 <quicksilver> duh
23:24:40 <glguy> no, functions can not be compared
23:24:45 <Tac-Tic1> shachaf: easily
23:24:51 <shachaf> glguy: That's what I've been saying. :-)
23:24:53 <Tac-Tic1> shachaf: but not obeying the usual rules for Eq
23:24:56 <shachaf> Tac-Tic1: Not you again...
23:25:03 <Tac-Tic1> heh, sorry
23:25:08 <Tac-Tic1> Functions are never Eq
23:25:20 <ramza3> Tac-tic1: http://ieeexplore.ieee.org/Xplore/login.jsp?url=/iel5/10752/33895/01614941.pdf?arnumber=1614941
23:25:30 <ramza3> fisher bayesian classifier
23:26:17 <jsnx> say we have a set of functions
23:26:22 <Tac-Tic1> ramza3: do you really need to print out the intermediate terms? (the prints inside the loop?)
23:26:36 <jsnx> than, the functions are not equal, because then it would not be a set...
23:26:43 <jsnx> s/than/then/
23:27:02 <jsnx> so, i hestitate to say
23:27:08 <ramza3> Tac-Tic1, in the python code?  no, just testing
23:27:37 <jsnx> do non-constructive have any bearing on this matter? honestly, i'm not sure...
23:27:50 <jsnx> s/have/arguments have/
23:27:50 <Tac-Tic1> ah, but their floating point numbers you're ranging over
23:28:01 <Tac-Tic1> err
23:28:04 <Tac-Tic1> wait no they're not
23:28:13 <ramza3> Tac-Tic1, I think I can just create another function and still keep the foldl call
23:28:15 <shachaf> jsnx: Do you agree with halts f x = let { g y | y == x = undefined | otherwise -> f y } in f /= g
23:29:22 <jsnx> shachaf: honestly, i can't parse that
23:29:24 <ramza3> Tac-Tic1, that only does this calculation first; term *= (m / i)
23:29:30 <jsnx> what are you using the '|' for
23:29:31 <jsnx> ?
23:30:39 <shachaf> halts f x = let { g y = if y == x then undefined else f y } in f /= g
23:31:42 <jsnx> shachaf: so, why does that have any bearing on the matter at all?
23:32:11 <shachaf> jsnx: Well, you can use function equality to check if a function halts.
23:32:27 <jsnx> shachaf: how?
23:32:42 <jsnx> shachaf: i don't understand how that function actually checks for halting...
23:32:50 <jsnx> i mean, it's called `halts`, but...
23:33:12 <shachaf> jsnx: It defines a function g that is equal to f for every argument other than x.
23:33:30 <jsnx> shachaf: okay
23:33:33 <jsnx> and?
23:33:35 <shachaf> jsnx: g x doesn't terminate (is undefined).
23:34:27 <jsnx> shachaf: i still don't see it -- this is a weakness in my perception, i'm sure, not in your presentation
23:34:37 <shachaf> Since you can't tell non-terminations apart, the functions must not be equal if g terminates and f does, at x.
23:35:21 <jsnx> ?
23:35:26 <Cale> uh
23:35:52 <Cale> jsnx: Suppose that f halts on input x. Then g is not equal to it, since g doesn't halt at x.
23:35:57 <Tac-Tic1> @hoogle Float -> Int
23:35:57 <lambdabot> No matches, try a more general search
23:36:12 <jsnx> aye
23:36:16 <Tac-Tic1> what's the float -> int conversion function again?
23:36:22 <shachaf> @src RealFrac
23:36:22 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
23:36:22 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
23:36:22 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
23:36:28 <Tac-Tic1> thanks
23:36:32 <Cale> jsnx: On the other hand, suppose that f fails to halt on input x, then g is equal to it, since g fails to halt on x as well, and is defined as f y for every other y
23:36:46 <jsnx> okay
23:37:22 <jsnx> so, if this function equality function is total, than we have a problem
23:37:32 <jsnx> okay, i understand now
23:37:38 <olsner> http://www.haskell.org/pipermail/cvs-ghc/2007-March/034322.html <-- anyone know what happened with this error? I'm getting it when installing ghc-6.8.2
23:37:40 <lambdabot> Title: [nightly] 02-Mar-2007 build of HEAD on i386-unknown-linux (cam-02-unx.europe.cor ...
23:37:42 <dons> pure mt random generator here, if anyone's curious about the implementation,   darcs get http://code.haskell.org/~dons/code/mt1997-random
23:37:43 <lambdabot> Title: Index of /~dons/code/mt1997-random
23:37:47 * shachaf shouldn't try to explain things at this hour. :-)
23:37:52 <jsnx> okay, so
23:38:03 <jsnx> consider
23:38:07 <Cale> jsnx: Surprisingly enough, it's possible to compare equality of *total* functions, even on some infinite domains.
23:38:19 <jsnx> Cale: how is that?
23:38:47 <jsnx> > let { a = [1..] ; b = [1..] } in a == b
23:38:53 <lambdabot> Terminated
23:38:57 <Cale> Well, it all depends on the particulars of the domain. The naturals don't work at all.
23:39:00 <Tac-Tic1> ramza3: I almost got it. I just suck with haskell's number types
23:39:07 <shachaf> jsnx: That's not total.
23:39:15 <jsnx> shachaf: right!
23:39:16 <Cale> However, if the domain is (functions from the naturals to booleans)
23:39:20 <olsner> and ghc-6.6.* gives me ghc7612_0.hc:(.text+0x4): undefined reference to `__DISCARD__'
23:39:22 <glguy> Cale: depends if you are talking about observational equality though, right?
23:39:34 <jsnx> Cale: oic
23:39:40 <jsnx> Cale: no, wait
23:40:20 <jsnx> if we have some functions foo : (Nat -> Bool) -> Something
23:40:21 <Cale> that is, if the domain is infinite sequences of booleans
23:40:47 <Cale> any total function which takes such functions in can only be evaluating them at finitely many points
23:42:05 <Cale> (that is, if xs :: Nat -> Bool, then f xs can only be evaluating xs at finitely many naturals)
23:42:48 <jsnx> Cale: why is that?
23:43:02 <Cale> because it can't fail to terminate
23:43:14 <Cale> (since it's total)
23:43:26 <shachaf> jsnx: If it ever has to look at the entire list, it's certain not to terminate.
23:43:30 <jsnx> Cale: why can't if fail to terminate? i seemed to miss that part
23:43:41 <shachaf> jsnx: Right?
23:43:42 <jsnx> shachaf: okay, but why can't it just not work then?
23:43:43 <Cale> jsnx: Because we're assuming that it's a total function.
23:43:47 <jsnx> oic
23:43:52 <glguy> then it isn't total?
23:44:24 <jsnx> so, if it's a total function, then, it has to be evaluating the argument functions at only finitely many points
23:44:44 <jsnx> and then we can of course compare these functions
23:44:49 <Cale> Let's restrict our attention to total functions (Nat -> Bool) -> Bool for a moment, and ask ourselves if there's a way to take such a function and determine if there's a sequence on which it returns True
23:45:06 <jsnx> oaky
23:45:15 <Cale> It's still not obvious how to compare them.
23:45:23 <Cale> But if we can do this
23:45:55 <Cale> then we can take two functions (Eq a) => (Nat -> Bool) -> a, and decide if they're equal
23:46:14 <Cale> (supposing that Eq a defines a total equality on a)
23:46:16 <Tac-Tic1> oh my god, stupid haskell number types!
23:46:18 <vincenz> <3 qc
23:46:19 <Tac-Tic1> baaaaah
23:46:37 <jsnx> Cale: if we can do it
23:46:42 <Cale> right
23:47:00 <jsnx> Cale: so, you were going to explain, if i remember right, how it is that  we can do it...
23:47:11 <Cale> right :)
23:47:21 <shachaf> jsnx: Do you see *that* we can do it?
23:47:46 <jsnx> shachaf: eh?
23:47:52 <Cale> We're going to first define a function  exists :: ((Nat -> Bool) -> Bool) -> Bool
23:48:03 <Tac-Tic1> ramza3: are you still here?
23:48:33 <Cale> Such that for any total function f,  exists f  is true exactly when there is some (Nat -> Bool) such that it returns True, and False otherwise.
23:48:50 <jsnx> okay
23:48:53 <Cale> make sense?
23:48:54 <Cale> Okay
23:48:55 <jsnx> aye
23:49:09 <vincenz> Cale: Arithmetic non-infinity invariant: OK, 100000 tests.
23:49:13 <Cale> vincenz: :)
23:49:14 <vincenz> want me to stress test more?
23:49:32 <jsnx> vincenz: that would only prove it was true on a certain computer
23:49:36 * vincenz wishes he could arbitrarily generate irrational numbers
23:49:36 <Cale> vincenz: go for it... might also want some white-box tests -- there are some corner cases it may never hit
23:49:48 <Cale> jsnx: okay
23:49:54 * vincenz stabs jsnx in the heart
23:49:56 <jsnx> aye
23:49:58 <Tac-Tic1> heh
23:50:18 <Cale> Define  (#) :: Bool -> (Nat -> Bool) -> (Nat -> Bool)
23:50:35 <Cale> (x # f) 0 = x
23:50:41 <Cale> (x # f) (n+1) = f n
23:50:52 <Cale> This is just a cons operation for Nat -> Bool
23:51:16 * vincenz wishes his computer was faster
23:51:17 <Cale> Now, exists :)
23:51:49 <jsnx> aye
23:52:32 <Cale> exists f = f (find f)
23:52:57 <Tac-Tic1> :t find
23:52:59 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
23:53:03 <Cale> not that find
23:53:07 <Tac-Tic1> k
23:53:09 <Cale> I'm about to define it :)
23:53:18 <Cale> (it's mutually recursive with exists)
23:53:40 <Cale> find f = if exists f (\xs -> f (False # xs))
23:54:07 <doobeydoo> what does Kaleidoscope mean in the context Object-Oriented Programming in C++ (4th Edition) (Kaleidoscope) (Paperback)
23:54:10 <Cale>             then False # find (\xs -> f (False # xs))
23:54:18 <vincenz> doobeydoo: wrong channel?
23:54:22 <kmcallister> dobblego, publisher, probably
23:54:23 <Cale>             else True # find (\xs -> f (True # xs))
23:54:27 <kmcallister> err, doobeydoo
23:55:00 <Cale> Let's see that again, since I was slow :)
23:55:05 <doobeydoo> no its a amazon.com speicific term
23:55:07 <Cale> exists f = f (find f)
23:55:10 <Cale> find f = if exists f (\xs -> f (False # xs))
23:55:13 <Cale>             then False # find (\xs -> f (False # xs))
23:55:15 <Cale>             else True # find (\xs -> f (True # xs))
23:55:27 <Cale> So, what does this say :)
23:55:38 <vincenz> recursion is fun?
23:55:55 <Cale> It says that exists f is True if f gives True when applied to the result of find f
23:56:14 <Cale> So it's up to find f to find a sequence which f is going to return True on, if it exists at all.
23:56:15 <shachaf> Mutual recursion doubly so. :-)
23:56:43 <jsnx> Cale: so, how does find do this?
23:57:02 <Cale> Now, find f, what it does is to check if there exists some sequence xs, *starting with False*
23:57:09 <Cale> for which f returns True
23:57:09 <vincenz> heh
23:57:13 <vincenz> 10 seconds for 10K tests
23:57:17 <vincenz> 1M tests is gonna take a bit
23:58:01 <jsnx> oic
23:58:04 <Cale> If so, then it returns a sequence starting with False, and proceeding with the results of looking for a sequence xs which makes f (False # xs) true
23:58:39 <Cale> Otherwise, it returns a sequence starting with True, and proceeding with the results of looking for a sequence xs which makes f (True # xs) true
23:59:04 <int-e> Cale: shouldn't that be  exists (\xs -> f (False # xs))
23:59:26 <Cale> er, yes indeed it should
23:59:44 <Cale> A spurious f got in somehow :)
