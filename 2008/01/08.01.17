00:06:38 <Cale> Hmm, according to Brzozowski, it's actually possible to explicitly compare regular expressions after differentiating, if you take the time to normalise the sums occurring in them in some way to account for idempotence, commutativity and associativity of +
00:06:53 <Cale> I don't yet understand why that is though :)
00:07:21 <Cale> (that is, apparently any regular expression will have only finitely many derivatives up to that kind of similarity)
00:17:21 <Cale> (but it seems that's still going to be really expensive compared to using DFAs, because the resulting derivatives can get extremely large)
01:01:48 <quicksilver> Cale: did you see the pretty openlaslzo based RE visualiser?
01:04:39 <Cale> quicksilver: I'm not sure.
01:05:27 <Cale> By the way, I've realised that what I described above is essentially the same as running the NFAs/DFAs on longer and longer prefixes, and stopping when you've seen the same pair of states.
01:06:02 <Cale> Eventually you'll run out of prefixes, and if the two NFAs/DFAs would accept at exactly the same points, then they're equivalent.
01:10:42 <quicksilver> cale: http://osteele.com/tools/reanimator/
01:10:42 <lambdabot> Title: reAnimator: Regular Expression FSA Visualizer
01:10:59 <quicksilver> Cale: this is a tool I wish I'd had when teaching automate theory to undergrads ;)
01:11:51 <Cale> Ah, yeah, I've seen that. It had funny bugs in it though.
01:11:58 <Cale> (but the idea is great)
01:25:42 <sizur> @pl \a b c-> a*65536+b*256+c
01:25:42 <lambdabot> ((+) .) . (. (256 *)) . (+) . (65536 *)
01:26:14 <sizur> @pl \(a,b,c)->a*65536+b*256+c
01:26:14 <lambdabot> (line 1, column 6):
01:26:14 <lambdabot> unexpected ","
01:26:14 <lambdabot> expecting letter or digit, operator or ")"
01:26:14 <lambdabot> ambiguous use of a non associative operator
01:26:52 <johnnowak> 65536 * swap 256 * + +
01:27:25 <koeien> @pl \(a,(b,c))->a*65536+b*256+c
01:27:25 <lambdabot> uncurry ((`ap` snd) . (. fst) . ((+) .) . (. (256 *)) . (+) . (65536 *))
01:28:57 <pastorn> @hoogle (a -> b -> c -> d) -> (a,b.c) - > d
01:28:58 <lambdabot> Hoogle Error: Parse Error: Unexpected character '- > d'
01:29:22 <pastorn> @hoogle (a,b,c) -> (a -> b -> c -> d) -> d
01:29:23 <lambdabot> No matches, try a more general search
01:29:35 <meijer> > map (++ "!") (repeat "rant")
01:29:37 <lambdabot>  ["rant!","rant!","rant!","rant!","rant!","rant!","rant!","rant!","rant!","ra...
01:33:26 <sizur> @pl \a b c -> floor(a*256.0)*65536+floor(b*256.0)*256+floor(c*256.0)
01:33:27 <lambdabot> flip flip (floor . (256 . 0 *)) . (((.) . (+)) .) . (. ((256 *) . floor . (256 . 0 *))) . (+) . (65536 *) . floor . (256 . 0 *)
01:36:25 <roconnor> @unpl flip flip (floor . (256 . 0 *)) . (((.) . (+)) .) . (. ((256 *) . floor . (256 . 0 *))) . (+) . (65536 *) . floor . (256 . 0 *)
01:36:25 <lambdabot> (\ s f j -> ((65536 * (floor ((\ bd -> 256 (0 bd)) * s))) + (256 * (floor ((\ ar -> 256 (0 ar)) * f)))) + (floor ((\ y -> 256 (0 y)) * j)))
01:36:27 <sizur> @pl \a b c -> f a * c2 + f b * c1 + f c
01:36:27 <lambdabot> flip flip f . (((.) . (+)) .) . (. ((c1 *) . f)) . (+) . (c2 *) . f
01:37:05 <roconnor> @pl \f a b -> f a * c2 + f b * c1 + f c
01:37:05 <lambdabot> ap (flip . ((flip . ((+) .)) .) . ap (flip . (((.) . (+)) .) . flip flip c2 . ((*) .)) (flip flip c1 . ((*) .))) ($ c)
01:37:18 <pastorn> sizur: it's not getting any better, just so you know
01:37:59 <johnnowak> it's nicer in joy.
01:38:07 <johnnowak> [256.0 * floor] i3
01:38:41 <johnnowak> roughly...
01:42:21 <EvilTerran> ?type (,) . (,)
01:42:25 <lambdabot> forall b a b1. a -> b -> (b1 -> (a, b1), b)
01:42:39 <EvilTerran> ?type ((,).) . (,)
01:42:40 <lambdabot> forall b a a1. a1 -> a -> b -> ((a1, a), b)
01:44:14 <koeien> > let f = (,).(,) in f 37 42 666
01:44:15 <lambdabot>  Couldn't match expected type `t1 -> t'
01:44:15 <sizur> how do you open ghci session in haskell-mode again?
01:44:42 <koeien> > let f = ((,).).(,) in f 37 42 666
01:44:43 <lambdabot>  ((37,42),666)
01:44:44 <EvilTerran> ?type (((*256) *** (*256)) *** (*256))
01:44:44 <lambdabot> forall b b' b'1. (Num b, Num b', Num b'1) => ((b, b'), b'1) -> ((b, b'), b'1)
01:44:50 <EvilTerran> now we're getting someplace
01:45:59 <EvilTerran> > let f = ((((*256).).(,).(*256)).).(,).(*256) in f 1 2 3
01:46:00 <lambdabot>   add an instance declaration for (Num (a, b))
01:46:07 <EvilTerran> > let f = (((.(*256)).(,).(*256)).).(,).(*256) in f 1 2 3
01:46:08 <lambdabot>   add an instance declaration for (Num (a, b))
01:46:11 <EvilTerran> pah.
01:46:20 * EvilTerran gives up for now
01:53:49 <sizur> @pl \a b c-> g (f a * c2 + f b * c1 + f c)
01:53:49 <lambdabot> ((g .) .) . flip flip f . (((.) . (+)) .) . (. ((c1 *) . f)) . (+) . (c2 *) . f
01:55:15 <EvilTerran> ?type (((* ?c2). ?f) *** ((* ?c1). ?f)) *** f
01:55:17 <lambdabot> Not in scope: `f'
01:55:20 <EvilTerran> ?type (((* ?c2). ?f) *** ((* ?c1). ?f)) *** ?f
01:55:20 <lambdabot> forall b a. (?c1::b, ?f::a -> b, Num b, ?c2::b) => ((a, a), a) -> ((b, b), b)
01:56:46 <mux> dons: I like the links you posted to programming.reddit.com about monads
01:57:49 <EvilTerran> ?type curry . curry $ uncurry (+) . ((uncurry (+) . (((* ?c2). ?f) *** ((* ?c1). ?f))) *** ?f)
01:57:49 <lambdabot> forall b c'. (Num c', ?c1::c', ?f::b -> c', ?c2::c') => b -> b -> b -> c'
01:58:08 <EvilTerran> *little* better :)
01:59:04 <sizur> that's nice. it should be made easier to work with tuples in haskell
01:59:25 <EvilTerran> it is, if you aren't trying to shoehorn pointlessness in
01:59:27 <sizur> maybe in haskell'''
01:59:40 <koeien> actually i think it's quite nice
01:59:58 <koeien> but it would be cool to have #1 and #2 like ML
02:02:24 <sizur> well if you will make your own arrow instance, sure. it's hard to compose pointful functions.
02:27:34 <Eidolos> let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
02:27:35 <Eidolos> is beautiful
02:28:29 <Cale> > fix ((0:) . scanl (+) 1)
02:28:31 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:28:40 <ac> say you define a type "data Thing = Int | String". Could someone write a function of type "Thing -> Thing"?
02:29:01 <ac> I mean other than the trivial case of the identity function
02:29:06 <Cale> ac: The only two (defined) values of type Thing would be, literally, Int and String
02:29:26 <Cale> You could write:
02:29:27 <ac> oh, so it's an enum
02:29:29 <Cale> f Int = String
02:29:32 <Cale> f String = Int
02:29:45 <Cale> Yeah, it's essentially the same thing as Bool
02:29:59 <sebaseba> could you have "data Thing = Int a | String b" ?
02:30:08 <ac> the way to make the type I'm thinking of would be "data Thing = SThing String | SInt Int"
02:30:14 <Cale> ac: right
02:30:25 <Cale> sebaseba: If you make a and b type parameters to Thing
02:30:29 <Eidolos> in PErl that would be use Memoize; memoize 'fibs'; sub fibs { my $n = shift; return 1 if $n < 2; retun fibs($n-1) + fibs($n-2) }
02:30:33 <Cale> data Thing a b = Int a | String b
02:30:33 <Eidolos> heheh
02:30:44 <doserj> which is the same as Either
02:30:48 <Cale> right
02:31:01 <ac> with really bad names
02:31:14 <Cale> agreed :)
02:31:34 <Cale> data Either a b = Left a | Right b
02:32:19 <Cale> Interestingly enough, Left is quite often used to mean Wrong :)
02:32:49 <Cale> (and additional features of the type system ensure that it would be inconvenient to do it the other way around, without changing the type)
02:32:51 <sizur> wow, that's the shortest fibs i have ever seen: fix $ (0:).scanl(+)1 -- except it does not take the two seeds as an argument
02:33:22 <ac> so I could also say, "type Thing = Either String Int"?
02:33:29 <sizur> @pl \a b-> fix ((a:).scanl (+) b)
02:33:30 <lambdabot> (fix .) . (. scanl (+)) . (.) . (:)
02:34:54 <Cale> hehe
02:35:08 <Cale> > (fix.).(.scanl (+)).(.).(:) 0 1
02:35:09 <lambdabot>  Couldn't match expected type `a -> b -> c'
02:35:36 <sebaseba> what is the difference between type and data?
02:35:41 <Cale> > ((fix.).(.scanl (+)).(.).(:)) 0 1
02:35:42 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:36:05 <Cale> sebaseba: type is used to give an existing type a new name
02:36:15 <sebaseba> like an alias then
02:36:17 <Cale> sebaseba: data is used to create entirely new types
02:36:19 <Cale> yeah
02:36:36 <Cale> newtype is somewhere in between the two
02:36:37 <sizur> > let fibs = (fix.).(.scanl(+)).(.).(:) in take 5 $ fibs (-10) 5
02:36:37 <lambdabot>  [-10,5,-5,0,-5]
02:36:56 <sebaseba> newtype? how does it work?
02:36:57 <Cale> It creates a new type which is implemented at runtime with the exact same representation as an existing type.
02:37:13 <Cale> But is treated as different at compile time by the type system.
02:37:35 <sebaseba> in what kind of situation would I want to use newtype then?
02:38:10 <Cale> Apart from some small semantic differences between newtype and data types with a single constructor with a single field, this has the advantage that (with an extension) deriving becomes more powerful
02:38:13 <sizur> > let fibs = (fix.).(.scanl(+)).(.).(:) in take 20 $ fibs (-10) 5
02:38:13 <lambdabot>  [-10,5,-5,0,-5,-5,-10,-15,-25,-40,-65,-105,-170,-275,-445,-720,-1165,-1885,-...
02:38:23 <Cale> You can use deriving to derive any class implemented on the original type
02:38:28 <Cale> So, for instance:
02:38:46 <Cale> newtype Dollars = D Integer deriving (Eq, Ord, Num)
02:39:12 <Cale> Normally, Num can't be derived, but since this is a newtype, and Integer implements Num, it's okay.
02:40:10 <koeien> didn't know that, might come in handy
02:40:25 <sizur> why is newtype not implied by a single constructor and single field of a data declaration? atleast in some extension
02:40:27 <sebaseba> in your example, Dollars and Integers cannot be used interchangeably, right?
02:40:28 <Cale> That means that the type system can be conveniently used to keep track of which integers are representing money, and which are representing, say, quantities of items, and not let you get them mixed up.
02:40:39 <sebaseba> ah, that's what I thought
02:40:40 <sebaseba> wow
02:41:14 <sebaseba> I remember seeing something similar in the language D
02:42:05 <sebaseba> typedef, I believe (the typedef in C is called "alias" in D)
02:42:16 <sebaseba> (not that I know much D, though)
02:42:38 <resiak> sizur: because if you have data Foo = F Int, F _|_ is distinguishable from _|_; but with newtype Foo = F Int, they are not.  (IIRC)
02:42:43 <malcolmw> I'm looking for a (small-ish) program for benchmarking purposes, that does a reasonable amount of I/O, on several files, in an interleaved fashion.  Anyone know of something I could use with those characteristics?
02:43:49 <ac> what is a reasonable use of Either?
02:45:02 <doserj> for example, wherever you would use Maybe, but want additional information in the "failure" case
02:45:14 <koeien> ac: example, Either ErrorReport Result
02:46:21 <ac> why can't I say: type Thing = Either Int String; foo :: Thing -> Thing; foo (Left a) = a + 1; -- ?
02:46:37 <koeien> ac: what is the type of a + 1 ?
02:46:47 <ac> oh, duh
02:46:54 <ac> I have to say Left a + 1
02:46:59 <koeien> with parentheses
02:47:02 <Cale> Left (a + 1)
02:47:03 <koeien> Left (a+1)
02:47:13 <doserj> Left $ a+1 -- :)
02:47:18 <Cale> since  Left a + 1 parses as  (Left a) + 1
02:47:48 <ac> yeah yeah I was aware of that when I wrote it. I've been bit enough by the precedence " "
02:48:00 <koeien> :)
02:48:08 <sizur> > (+1) <$> (Left 2)
02:48:10 <lambdabot>  Left 2
02:48:24 <koeien> that's not correct
02:48:30 <sizur> > (+1) <$> (Right 2)
02:48:31 <lambdabot>  Right 3
02:48:35 <koeien> with Right it works
02:48:52 <sizur> Left holds error
02:49:07 <koeien> yes, sounds illogical till you realize that "Right" means two things in English :)
02:49:33 <sizur> yeah, using Either monad is really bad in some cases
02:49:33 <Cale> The reason is more than that
02:49:54 <Cale> Instances of Functor can only be functors in their last parameter
02:50:04 <Cale> because we don't have type lambdas
02:50:06 <koeien> yes, i thought of that
02:50:15 <sebaseba> what is the <$> above?
02:50:16 <koeien> type-level programming ftw
02:50:28 <koeien> sebaseba: look up Functor and Applicative
02:50:29 <Cale> sebaseba: It's an operator from Control.Applicative
02:50:35 <Eidolos> wow
02:51:19 <Cale> It's a generalisation of map
02:51:27 <Cale> > (+1) <$> [1,2,3,4,5]
02:51:29 <lambdabot>  [2,3,4,5,6]
02:51:36 <Cale> > (+1) <$> (Right 6)
02:51:37 <lambdabot>  Right 7
02:51:46 <Cale> It's equivalent to fmap
02:51:47 <koeien> (+37) <$> (Just 42)
02:51:55 <koeien> > (+37) <$> (Just 42)
02:51:56 <lambdabot>  Just 79
02:52:31 <Cale> Personally, I'd like to see (.) for fmap :)
02:52:42 <Cale> This would perhaps confuse beginners, but it's rather nice.
02:52:45 <koeien> Cale: instead of <$> ?
02:53:03 <Cale> koeien: well, <$> goes nicely with the other Applicative operators I suppose.
02:53:21 <thargon> haskellÂ¨
02:53:24 <koeien> and what would be your composition then?
02:53:28 <Cale> (.)
02:53:29 <Cale> :)
02:53:29 <thargon> why?
02:53:30 <koeien> o
02:53:30 <sizur> Cale: why? fmap is not a composition?
02:53:36 <thargon> poor sizur
02:54:02 <Cale> > map toUpper `fmap` reverse `fmap` ["hello", "there", "world"]
02:54:02 <lambdabot>  ["OLLEH","EREHT","DLROW"]
02:54:11 <thargon> pooor lambdabot
02:54:12 <Cale> > (map toUpper `fmap` reverse) `fmap` ["hello", "there", "world"]
02:54:12 <lambdabot>  ["OLLEH","EREHT","DLROW"]
02:54:18 <koeien> yeah i didn't think for that earlier
02:54:21 <Cale> oh, one of those
02:54:21 <koeien> of*
02:54:24 <thargon> poor koeien
02:54:26 --- mode: ChanServ set +o Cale
02:54:34 --- mode: Cale set +b *!*@77-56-70-119.dclient.hispeed.ch
02:54:44 <Cale> someone removed my WP-Gast ban
02:55:02 <opqdonut> yep, replacing a.b.c.d$x with a.b.c.d.x would be so much nicer
02:55:10 --- mode: Cale set +b *!*WP-Gast@*
02:55:22 --- mode: Cale set -o Cale
02:55:32 <sizur> let's just code everything in arrows
02:55:56 <sizur> that'll be consistent ;)
02:56:04 <Cale> opqdonut: of course, it wouldn't work for the identity functor, but for others, at least :)
02:57:26 <opqdonut> yeah, and implicit identity functor wouldn't really be in the spirit
02:58:07 <Cale> The awesome thing about this definition is that the main functor law is exactly what's needed to make it associative
02:58:44 <Cale> That is, normally we want  fmap (f . g) x = fmap f (fmap g x)
02:58:46 <opqdonut> main functor law? fmap f . fmap g == fmap (f.g) ?
02:58:56 <Cale> translating that using (.) = fmap
02:58:59 <opqdonut> yep
02:59:16 <Cale> (f . g) . x = f . (g . x)
03:00:08 <Cale> I was skeptical about the idea until I saw that.
03:01:27 <Cale> http://img209.imageshack.us/img209/5781/deadlocknajkcomafarialibh3.jpg -- this would make a great cover for a concurrency textbook
03:01:28 <lambdabot> http://tinyurl.com/2k433j
03:03:10 <Cale> anyway, yeah, it's nice how what are probably the two most important operations in functional programming: map and function composition can be seen as the same thing.
03:03:14 <opqdonut> Cale: same was discussed on my uni's compsci channel :)
03:03:26 <opqdonut> (the image)
03:05:02 <matthew-_> that's an awesome image
03:05:24 <matthew-_> it should be the caption competition for some geek version of HIGNFY
03:05:35 <opqdonut> HIGNFY?
03:05:38 <roconnor> Cale: where did the cars leaving on the right come from?
03:05:42 <matthew-_> Have I Got News For You
03:05:47 <opqdonut> ah
03:05:53 <matthew-_> it's a very famous topical news quiz thing in the UK
03:06:15 <opqdonut> roconnor: from the bottom left?
03:06:22 <Cale> roconnor: I have no idea, it's not my picture :)
03:06:39 <opqdonut> there's a way to bypass the junction
03:06:55 <opqdonut> going from bottom left to top left
03:06:56 <matthew-_> "a ramp"
03:07:33 <opqdonut> oh, yes
03:07:53 <matthew-_> "Bug discovered in STM runtime"
03:09:29 <matthew-_> "...and this is the reason why 'unsafePerformIO . atomically' is prohibited!"
03:09:47 <opqdonut> heh
03:10:29 <matthew-_> "developer forgets random component of binary exponential backoff"
03:12:12 <matthew-_> "Town planners outsource traffic light programming"
03:13:43 <matthew-_> "Philosophers learn of special offers on spaghetti"
03:13:49 <matthew-_> that one wins
03:15:22 <sizur> > (+1) <$> (2,3)
03:15:25 <lambdabot>  (2,4)
03:15:40 <roconnor> opqdonut: in the middle left, some cars are leaving
03:15:40 <sizur> > (+1) <$> (2,3,4)
03:15:42 <lambdabot>   add an instance declaration for (Functor ((,,) t t1))
03:15:42 <lambdabot>     In the expression...
03:15:43 <roconnor> er
03:15:49 <roconnor> opqdonut: in the middle right
03:15:57 <opqdonut> yes
03:16:09 <roconnor> opqdonut: specifically that grey SUV
03:16:36 <sizur> > (+1) <$> 2
03:16:37 <lambdabot>   add an instance declaration for (Num (f a))
03:16:50 <opqdonut> and the ramp (or whatever) right in the middle of the right edge of the picture explains everything
03:16:53 <opqdonut> imo
03:19:04 <sizur> why is tuple functor operating only on the second value?
03:19:54 <koeien> sizur: same reason as for Either ?
03:20:38 <sizur> yes, but then why the redundancy?
03:20:40 <koeien> and what would (+1) <$> ("hello", 37) be ?
03:21:07 <sizur> > ((+1) *** (+1)) (2,3)
03:21:09 <lambdabot>  (3,4)
03:21:36 <sizur> > (+1) <$> (2,"a")
03:21:36 <lambdabot>   add an instance declaration for (Num [Char])
03:23:09 <sizur> it's mimiking a read monad. or second arrow
03:25:42 <sizur> i think tuple functors have to be resolved based on the maximum number of mathcing element types and operate on each of them
03:25:53 <sizur> but that needs metaprogramming again
03:25:53 <koeien> evil
03:27:18 <sizur> hmm, that implies overlapping instances, or even incoherent ones
03:27:20 <Philippa> sizur: there are many possible functors on tuples
03:27:33 <Philippa> several just on 2-tuples alone, even
03:27:39 <sizur> yeah :(
03:28:17 <Philippa> so which one gets to be assigned to 2-tuples rather than a newtype of them is pretty much a sociopolitical issue. Other than that, use newtypes to resolve which you meant
03:28:22 <sizur> a superFmap that considers the type of the function?
03:29:32 <pjd> the tuple instance makes sense when you think of currying
03:29:33 <sizur> class TupleFunctor?
03:30:30 <opqdonut> > return 1 :: State Int Int
03:30:32 <lambdabot>        add an instance declaration for (Show (State Int Int))
03:30:36 <opqdonut> bah
03:32:58 <ketil> Hi, everybody.  I'm still having problems with my Map, and now my heap profile finally finished.
03:34:11 <ketil> Question: I store ~700K keys, and values of UArray Int Word16.  The grand total of Word16s should definitely be less than 20M.  Heap profile tells me that I have 1100Mbytes of ARR_WORDS.
03:34:47 <ketil> My calculations indicate that's a factor of 25 off the expected, two bytes per Word16.
03:35:09 <ketil> Just checking, but there isn't something horribly wrong with UArrays in ghc 6.8.0.something?
03:35:34 <Lemmih> You have a map with 700k keys and an array with 700k elements?
03:36:38 <hpaste>  ketil pasted "Spot the memory leak?" at http://hpaste.org/5055
03:37:19 <ketil> Lemmih, map of 700K keys, each having an array with some Word16 elements, the total of elements should be less than 20M
03:38:35 <ketil> If you check the hpaste, UniProtAcc is a ByteString, the [Annotation] list is 20M long.
03:38:56 <ketil> I've stared and stared at this, but fail to see the error.  I'm sure it will be embarrassing.
03:40:47 <dcoutts_> ketil: well, lets try and be more accurate with overheads etc...
03:41:02 <dcoutts_> there is an overhead for each UArray, it's not just the data content
03:41:27 <dcoutts_> if some are rather large >1.5k then they get pinned and take a whole 4k block
03:41:50 <dcoutts_> @src Data.Map.Map
03:41:50 <lambdabot> Source not found. Wrong!  You cheating scum!
03:42:48 <dcoutts_> a Data.Map takes 6 words per node
03:42:52 <ketil> dcoutts, well - I don't think any will be that size, but I haven't really measured.
03:43:30 <dcoutts_> ketil: and you're looking at total use at any one time, not the total memory the GC churned through?
03:43:46 <ketil> dcoutts_, yes, but the Map is isomorphic to a Set, which hardly shows up on the heap profile graph (and Map is only an additional pointer, no?)
03:44:13 <ketil> Yes.  I mean, the program blows the heap at some point, just after finishing building the Map.
03:45:19 <dcoutts_> an UArray has 13 words overhead
03:45:57 <dcoutts_> > (13 + 6) * 8 * 700000
03:45:59 <lambdabot>  106400000
03:46:37 <dcoutts_> so we'd expect >100 Mb (on a 64bit machine)
03:46:55 <dcoutts_> + the 20Mb of actual data + fragmentation
03:47:12 <dcoutts_> still, that's about x10 out
03:47:33 <ketil> Yes.
03:48:06 <ketil> Note that it's 1.1GB of ARR_WORDS, the +6 is put somewhere else.
03:48:22 <ketil> Bin, I guess?
03:48:37 <ketil> It's not discernible on the graph :-)
03:48:50 <dcoutts_> yes, Bin is the data constructor for Map
03:49:30 <ketil> I guess I could check the cardinality of the Map, just in case.  I thought perhaps I made a mistake when allocating the arrays, but if I did, I can't spot it.
03:49:42 <ketil> I could also sum the number of elements.
03:53:02 <dcoutts_> ketil: from the code it does look like the arrays are being forced before begin put into the map
03:53:21 <ketil> dcoutts, yes?
03:53:38 <dcoutts_> which is good, so I don't see any obvious suspensions in the result
03:53:52 <ketil> (seemed like a good idea to avoid unevaluated listArray (..) [...] hanging around)
03:54:05 <dcoutts_> right
03:54:26 <dcoutts_> unless perhaps the [Annotation] is very large and we've now partially forced that into memory
03:54:39 <dcoutts_> but that would not explain the ARR_WORDS I think
03:54:43 <ketil> and UArrays is (used to be?) and all-or-nothing thing, and besides, there's no (:)s to speak of in the heap.
03:55:01 <ketil> [Annotation] is about 20M, but I'm fairly sure it's read lazily.
03:55:13 <ketil> ByteString.Lazy doesn't show up as ARR_WORDS by any chance?
03:55:21 <dcoutts_> ketil: yes
03:55:27 <ketil> yes it does?
03:55:36 <dcoutts_> since a heap allocated ByteString is a ByteArr#
03:55:49 <litb> hello all
03:55:50 <ketil> that might just be it, mightn't it?
03:55:55 <litb> i changed a part of my program
03:55:56 <dcoutts_> ketil: sure
03:56:07 <litb> the mapping from natural numbers to integral values no look like this:
03:56:09 <ketil> Oh crap.  Well, I'll be back later.
03:56:18 <litb> sum $ map ((h *) . methode fnct . part_ivl) [1 .. fromIntegral anzahlIvl]
03:56:18 <dcoutts_> ketil: if you had a big input and are retaining it
03:56:21 <ketil> Uh, I mean: "thanks, man"
03:56:37 <litb> where part_ivl creates the pair part_ivl i = ((a+(i-1.0)*h), (a+i*h))
03:56:40 <dcoutts_> ketil: remember that any bytestring substring retains the whole block, and the lazy io usually reads in 64k blocks
03:56:46 <litb> i think that looks better
03:57:15 <koeien> litb: it is pretty clear, except for the german (is it?) :)
03:57:24 <ketil> dcoutts, see, I'm storing "up" as the key, which probably keeps around a huge chunk of input file.
03:57:34 <dcoutts_> ketil: ahh
03:57:40 <ketil> dcoutts, I should be storing the string from the Set instead.
03:57:48 <litb> koeien: i don't understand your statement
03:57:54 <litb> why shouldn't it clear for the german?
03:57:56 <ketil> dcoutts, which is severed from its origin - or at least already stored.
03:58:03 <litb> s/it /it be /
03:58:13 <dcoutts_> ketil: if you need to keep a small substring and release the parent block you can use copy
03:58:20 <matthew-_> dcoutts_: lwn seems to be suggesting that gentoo is in trouble. Please elaborate. ;)
03:58:22 <koeien> litb: "except for", i.e. there are english and german identifiers in the same line
03:58:47 <koeien> litb: which i find confusing :)
03:59:00 <litb> koeien: oh, yeah :D because haskell is english , but i am german
03:59:01 <litb> lolz
03:59:13 <litb> oh, wait
03:59:17 <litb> you mean the part_ivl :)
03:59:20 <dcoutts_> matthew-_: I don't follow the politics that closely, it's just that the trustees were not doing any work. They don't do anything technical anyway, just look after the legal status and they failed at that. So we lost the non-profit status.
03:59:33 <koeien> litb: i am dutch but still use english identifiers
03:59:51 <litb> koeien: well, yeah. i usually hate that, but well, i'm too lazy to search for good english identifies
03:59:55 <litb> *identifiers
04:00:01 <litb> or whatever it is called
04:00:03 <koeien> litb: :)
04:00:34 <matthew-_> dcoutts_: I see. That would be a bit of a cock-up really.
04:01:19 <dcoutts_> matthew-_: aye, but it doesn't affect much in the short term, it just means we cannot receive donations tax free for a bit
04:01:44 <litb> hm, is it common to have more than one identifier on one where clause?
04:01:55 <litb> i know it is common for let, but is that the case for where too?
04:04:56 <dcoutts_> litb: yes, very common to have a whole column of things defined in a where clause
04:05:07 <matthew-_> right, what Haskell OSes are there? There's House, there's the L4 one (what's that called) and what's the other one that appeared last summer?
04:05:19 <matthew-_> s/OSes/kernels/
04:05:37 <blarz> there are Haskell kernels?!
04:05:52 <koeien> litb: yes it is common
04:05:55 <matthew-_> oh yes, in various states of (dis)repair
04:05:59 <koeien> litb: meaning, i use it all the time :)
04:06:08 <koeien> i never use it in lets though
04:06:22 <blarz> matthew-_: wow, I didn't know that
04:06:27 <koeien> i think haskell is an excellent choice for a kernel
04:06:40 <koeien> you need some assembly but that's it
04:06:51 <koeien> performance could be a problem though
04:07:01 <matthew-_> yeah, a bit of C where necessary. but other than than and 100,000 man years, should be no problem
04:07:20 <matthew-_> I think it's better to write the kernel in Haskell and then invest endless time in making the compiler soddingly amazing
04:07:41 <matthew-_> let's face it, linux kernel is written with cache-line-tuning in mind
04:09:12 <earthy> koeien: you do know about hOp/House?
04:09:23 <koeien> earthy: only of its existence
04:09:53 <earthy> 'ah'
04:10:08 <matthew-_> ahh, kinetic is the new one. So there's House, seL4 and Kinetic
04:10:24 <earthy> performance shouldn't really be any problem
04:10:32 <earthy> the indirections are pretty clear in Haskell code
04:10:48 <earthy> you just want to make sure not to gobble up memory...
04:11:09 <ketil> I just got: "haddock: Internal Happy error" - I guess the compiler is secretly amused by my ineptitude?
04:11:20 <litb> what is the speed of haskell kernels?
04:11:25 <earthy> litb: reasonable.
04:11:35 <litb> do they make use of SMP more than the C kernels?
04:11:42 <litb> i mean, because it is functional?
04:12:00 <koeien> earthy: that's more or less what i meant by performance as well
04:12:12 <litb> anyway, i'm leaving now. have a nice day (tm)
04:14:04 <earthy> koeien: basically, there's no reason to assume it can't be as fast as linux
04:14:09 <earthy> (e.g.)
04:14:51 <earthy> and, given the opportunity to load statically-typed code into ring0 (but that's hackish), it might even be faster
04:15:23 <daf> how is ring 0 faster?
04:18:28 <ketil> dcoutts_: is pack . unpack the canonical way of breaking out a substring?
04:18:42 <dcoutts_> ketil: no, copy
04:18:57 <koeien> kinetic sounds interesting
04:19:06 <ketil> Hokay.  Better performance, I take it?
04:19:08 <dcoutts_> @type Data.ByteString.copy
04:19:11 <lambdabot> Data.ByteString.Base.ByteString -> Data.ByteString.Base.ByteString
04:19:24 <dcoutts_> ketil: yes, it's a memcpy
04:19:38 <dcoutts_> and it makes the intent clearer
04:19:54 <dcoutts_> since that's the only purpose of copy, to unshare
04:20:02 <koeien> i don't see source for kinetic though
04:21:01 <koeien> but it's an interesting idea
04:27:55 <roconnor> atomically do { x <- readTVar shared; y <- readTVar shared; if x==y then return () else return (fix id)}
04:28:07 <roconnor> does the above always terminate?
04:28:18 <roconnor> (in the presence of other threads)
04:28:34 <matthew-_> no
04:28:44 <roconnor> really!
04:28:49 <roconnor> that's terrible
04:28:58 <matthew-_> I'm not certain
04:29:25 <matthew-_> but STM is optimistic - if there's an interleaved write to shared then it's not required that the above would be immediately restarted
04:29:51 <roconnor> matthew-_: I thought the trasaction log is only checked at the end.
04:29:59 <roconnor> ... actually I think I need to rewrite my example a bit
04:30:09 <roconnor> atomically do { x <- readTVar shared; y <- readTVar shared; if x==y then return () else (fix id)}
04:30:19 <roconnor> that may be better
04:30:20 <Japsu> hm?
04:30:24 <Japsu> @type fix id
04:30:26 <lambdabot> forall a. a
04:30:30 <Japsu> ah, okay
04:30:39 <Japsu> (wondered if that even typechecks)
04:30:45 <roconnor> ;)
04:31:22 <matthew-_> roconnor: yeah, ok so it depends whether the transaction log is verified before or after the return
04:31:55 <matthew-_> that block would be restarted if the runtime detects that x and y have different values
04:31:57 <roconnor> matthew-_: right, I want to try and force the view of the transaction log after the fix id
04:32:26 <matthew-_> well, try it.
04:32:29 <roconnor> matthew-_: another possibility is that the read tries to read from the transaction log before heading to main memory
04:32:54 <matthew-_> ahh, I see what you're driving at
04:33:07 <Louis> just a silly req... does anybody have pdf/ps/docbook version of Jeff Newbern's All About Monads
04:33:10 <roconnor> matthew-_: that would be slower, but prevent this problem.
04:33:21 <matthew-_> it'll use the locally cached version in the short term before eventually checking that it's the same as the global version
04:33:28 <matthew-_> yeah, that's an idea.
04:33:39 <roconnor> that's how I would do it
04:33:44 <matthew-_> I don't know enough about how GHC actually implements it
04:33:48 <roconnor> but my name isn't Simon.
04:33:56 <roconnor> maybe I should ask on #ghc
04:33:58 <matthew-_> but I don't think they tend to use the local cache idea
04:34:09 <matthew-_> quicksilver or JaffaCake might know
04:34:15 <matthew-_> I certainly don't.
04:34:16 <matthew-_> sorry.
04:34:39 <roconnor> np
04:36:11 <koeien> roconnor: your talk at FPDag was interesting and i didn't have problems to understand it
04:36:18 <koeien> thanks for your dependent types clarification :)
04:36:23 <roconnor> koeien: :)
04:36:44 <roconnor> koeien: the talk leads to lots of other question, but I think the basics were there.
04:36:45 <koeien> the Epigram talk was also quite impressing for me
04:36:52 <roconnor> :)
04:37:06 <koeien> constructive mathematics ftw
04:38:01 <LoganCapaldo> deconstructive comathematics ftl
04:38:11 <koeien> not necessarily
04:38:19 <koeien> destruction is cool sometimes :)
04:39:32 <LoganCapaldo> creation is uncool all the time :(
04:39:40 <LoganCapaldo> i should delegate this to a bot
04:40:04 <Cale> I really like existence proofs which give you no idea whatsoever of how to actually construct an example :)
04:40:20 <byorgey> yeah, those are fun =)
04:40:23 <LoganCapaldo> I can't keep coming up with these clever nonsense opposites
04:40:38 <koeien> Cale: yeah if they're short it's ok
04:40:45 <byorgey> I can keep coming down with these trite sensible synonyms?
04:41:12 <LoganCapaldo> te he
04:41:53 <roconnor> Cale: or axiom of choices which give you no idea whatsoever of what was chosen.
04:42:03 <Cale> yeah :)
04:42:21 <Cale> Those tend to lead to really interesting and fun objects
04:42:29 <roconnor> not really.
04:42:37 <Cale> Like functions f: R -> R such that the image of any open set is dense in R.
04:42:49 <koeien> aargh
04:42:54 <sizur> LoganCapaldo: delegate creation to a bot? no thanks, i will do it myself with my wifey ;)
04:42:59 <roconnor> that doesn't sound continuous.
04:42:59 <roconnor> :P
04:43:39 <Cale> Or everywhere differentiable functions f such that the sets of points x on which f'(x) is positive, negative, and zero are all dense in R.
04:44:10 * byorgey head explodes
04:44:19 <Cale> (thus totally screwing with your sense of what differentiable functions look like :)
04:44:53 <byorgey> but, but, differentiable functions are all supposed to be, like, trig functions and polynomials and stuff! ;)
04:45:01 <roconnor> Cale: that doesn't sound like it has a continuous derivative.
04:45:08 <Cale> No, it doesn't :)
04:45:24 <koeien> how do you see such things that fast
04:45:30 * koeien is impressed :)
04:46:00 * byorgey guesses it's just like anything else: lots of practice =)
04:46:00 <roconnor> Cale: but all functions that I've met in real life are continuous.
04:46:13 <koeien> "real life"
04:46:20 <Cale> Continuous functions have the property that if they are positive at some point x, then they are positive on some interval containing x.
04:46:31 <koeien> yes
04:46:38 <roconnor> koeien: koeien real life, like haskell functions.
04:46:41 <roconnor> :)
04:46:44 <koeien> :)
04:47:30 <Japsu> @unpl (0:) . scanl (+) 1
04:47:30 <lambdabot> (\ d -> 0 : (scanl (+) 1 d))
04:47:49 <Japsu> @src fix
04:47:49 <lambdabot> fix f = let x = f x in x
04:48:01 <Japsu> @src scanl
04:48:02 <lambdabot> scanl f q ls = q : case ls of
04:48:02 <lambdabot>     []   -> []
04:48:02 <lambdabot>     x:xs -> scanl f (f q x) xs
04:48:15 <koeien> is there are ghci+lambdabot combo?
04:48:25 <Japsu> koeien: yes, it's called lambdabot
04:48:26 <Japsu> ;)
04:48:40 <koeien> so lambdabot superset ghci
04:49:14 <byorgey> no
04:49:37 <roconnor> > format don's harddisk
04:49:39 <lambdabot>   Not in scope: `harddisk'
04:49:41 <byorgey> koeien: there used to be such a ghci+lambdabot, called GHCi On Acid, but it hasn't been maintained since the end of 2006.
04:49:48 <byorgey> I don't think it even builds anymore.
04:49:54 <Cale> Another crazy thing which I'm fairly sure hasn't been explicitly constructed (but I haven't really read the paper yet), is that there's an analytic function U such that for any other analytic function f, and compact subset of C, there is some sequence of translates of U, that is g_n(z) = U(z+w_n) for some w_n in C, such that the sequence g_n converges uniformly to f
04:50:20 <Cale> (on that compact subset)
04:50:33 <koeien> sick
04:50:50 <Cale> So just by sliding the function U around, you can approximate any analytic function arbitrarily well.
04:51:09 <koeien> a pretty strong statement
04:51:25 <Cale> yeah
04:51:31 <roconnor> sounds like the X combinator.
04:51:39 <roconnor> in a very vague sort of way
04:51:49 <roconnor> one function to rule them all
04:52:22 <Feuerbach> Cale: by analytic, do you mean infinite-differentiable complex function?
04:53:06 <Cale> yeah, complex-differentiable
04:53:26 <quicksilver> roconnor: that always terminates.
04:53:28 <Cale> Defined the same way as real-differentiable, but the limit ranges over complex numbers.
04:53:35 <quicksilver> roconnor: STM never reads inconsistent values.
04:53:55 <quicksilver> ah. JaffaCake answered you in #ghc.
04:53:56 <koeien> being complex-differentiable is very strong
04:53:57 <quicksilver> well ;)
04:54:10 <roconnor> quicksilver: yep, I'm all good now
04:54:27 <Cale> It turns out that simple change implies that the function is infinitely differentiable and equal to its Taylor series expansion (on some open ball containing the point at which the function is differentiable)
04:54:31 <roconnor> JakkaCake pointed out that the reads must read from the log because that is where the writes went
04:54:40 <quicksilver> exactly
04:54:49 <quicksilver> analytic is an extraordinarly strong property
04:54:50 <matthew-_> ahh, of course
04:55:04 <quicksilver> analytic functons are determined by their values on a set of measure zero
04:55:27 <koeien> also, all bounded analytic functions are constant
04:55:28 <matthew-_> but, roconnor: you may not know that you're reading from the same var
04:55:33 <matthew-_> it might be aliased
04:55:44 <Cale> koeien: yeah, I like that one :)
04:55:46 <matthew-_> ahh, but of course at runtime it'll be a pointer comparison so you're still ok
04:56:14 <shag> @pl (\h2 r2 -> size h2 + r2)
04:56:15 <lambdabot> (+) . size
04:56:56 <Cale> (well, entire rather than just analytic at a point, but yeah :)
05:23:01 <Valodim_> is there a library for UDP sockets?
05:23:15 <Valodim_> the Network hackage doesn't seem to include that, or maybe I'm just not seeing it
05:25:20 <quicksilver> Valodim_: Network.Socket handles UDP, which is in the "standard" extralibs.
05:25:36 <quicksilver> it's not desperately friendly but the basic send/recv stuff is there
05:25:40 <Valodim_> yeah just found a paper on that on google. thank you  =)
05:25:55 <Valodim_> well udp is rather basic, "send this packet to ip plzkthx" anyways
05:26:06 <quicksilver> in fact, Network is better
05:26:11 <quicksilver> Network.Socket is lowlevel
05:26:18 <quicksilver> network is good enough for standard stuff
05:26:23 <quicksilver> :t Network.sendTo
05:26:26 <lambdabot> Network.BSD.HostName -> Network.PortID -> String -> IO ()
05:38:59 <ac> What's the difference between Int8 and Word8?
05:39:39 <ac> Specifically, which should I use for indexing an array?
05:39:51 <sizur> if i add a faint light source to a bright one, the composed light will be brighter. how can do same with RBG value?
05:39:58 <doserj> Int is signed, Word is unsigned
05:40:15 <ac> So I want Word8 then. Can't have negative indexes
05:40:40 <ac> Well you can in Haskell, but I'm not actually using an Array type
05:41:18 <sizur> type RGB = (Double,Double,Double)
05:41:35 <ac> sizur: what are you working on?
05:42:26 <sizur> ac: right now, playing around with an idea to write a rewriter for MQL4
05:42:57 <quicksilver> ac: use Ints to index arrays.
05:43:03 <quicksilver> ac: never use Foo8s
05:43:24 <sizur> but specifically to the color, how can i add a Red to Red (each is between 0 and 1) so as to simulate real world brightness manipulation
05:43:24 <ac> quicksilver: I'm defining the data type for an indexed color image
05:43:39 <quicksilver> ah well, fair enough.
05:43:53 <quicksilver> Word8 for 256 colour images, sure
05:43:58 <mux> > maxBound :: Word8
05:44:08 <lambdabot>  255
05:44:27 <ac> > maxBound :: Data.Int8
05:44:27 <lambdabot>   Not in scope: type constructor or class `Data.Int8'
05:44:32 <mux> I don't know if you're indexing by colour or pixel coordinates, but it ain't enough anyways
05:44:36 <ac> > maxBound :: Data.Int.Int8
05:44:36 <lambdabot>  127
05:44:41 <mux> > maxBound :: Word32
05:44:42 <lambdabot>  4294967295
05:44:54 <sizur> assume i have red1=0.4 and red2=0.6, when i add the two, what should i endup with?
05:45:09 <ac> mux: it's for indexed color images in PNG. The PNG spec limits these to 255 indexed colors
05:45:14 <ac> er, 256
05:45:26 <mux> ac: ah, cool then
05:45:40 <ac> mux: if you want more than 256 colors in PNG, you have to use non indexed colors
05:46:01 <sizur> > let add a b = a*a*b in add 0.4 0.6
05:46:02 <lambdabot>  9.6e-2
05:46:06 <ac> you can still define a palette for the benifit of the displaying software if you want to though
05:46:26 <sizur> > let add a b = a + a*b in add 0.4 0.6
05:46:32 <lambdabot>  0.64
05:47:06 <jaj> Hi! I would like to generate simple sine waves and output them through the sound card. If I understood correctly haskore is not the right tool to do this. could you recommend me an easy way to do this?
05:47:16 <ac> sizur: there is lots of info about that on the Internet
05:47:30 <Beelsebob> > let (+) a b = a + a * b in 0.4 + 0.6 -- time to asplodey
05:47:30 <sizur> ac: yeah, and googling did not help me
05:47:32 <ac> sizur: AFAIU, the display hardware and software already takes that in to account, so just add them
05:47:38 <lambdabot> Terminated
05:47:52 <ac> sizur: the dynamic range of computer displays is a small fraction of paper, which in turn is a small fraction of what the eye can see
05:48:20 <sizur> ac: thanks. i'm just curous as to what's the formula
05:48:30 <blarz> > (+) 1 1
05:48:31 <lambdabot>  2
05:48:32 <ac> sizur: it's logorithmic I believe
05:50:04 <Taejo> @type (<$>)
05:50:05 <ac> sizur: if a computer display is calibrated correctly, a series of blocks of color from [(x,0,0) | x <- [0..255]] should look like a linear gradient
05:50:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:50:43 <sizur> ac: that part is clear. how is Red added to Red?
05:52:08 <ac> sizur: uhm... "min (r1 + r2) 1" ?
05:52:45 <jedbrown> @pl \x y -> f x y `g` f y x
05:52:45 <lambdabot> ap (ap . (g .) . f) (flip f)
05:53:30 <ac> sizur: MQL4, as in the trading software? What does that have to do with colors?
05:53:36 <sizur> if we will comply with the monitor brightness limit, ok.
05:54:34 <sizur> ac: but since a Double encoding theoretically should mean absolute brightness...
05:55:12 <ac> what do you mean Double encoding?
05:55:26 <sizur> ac: yeah MetaTrader. it has a 'color' type which simply brought an old question i had back to memory
05:56:01 <sizur> ac: type Color = (Double,Double,Double) -- where each element lies between 0 and 1
05:56:31 <ac> heh. Also, a given RGB value is never going to look the same on different displays. For example, on my laptop, everything has a higher gamma than on pretty much every other display I've seen
05:56:59 <ac> and it's not just a matter of gamma. Some might have a skewed green, or something even more complicated
05:57:09 <sizur> ac: that's why i like to think of a monitor as absolute color range simulator
05:57:58 <ac> I think I'm totally missing your question
05:59:12 <sizur> i think about the standard brightness range of 0-255 as a very 'pixelated' version of a 0-1 absolute range
05:59:57 <sizur> where 1 then would mean all the light in the universe i guess heh
06:00:35 <ac> a value of red so great that you're vaporized on perceiving it
06:01:24 <sizur> heh yeah
06:01:45 <quicksilver> not really sure why you think (0,1) is supposed to go up to 'absolute brightness'
06:01:52 <sizur> but 0.999 is good enough for sunbathing
06:01:56 <quicksilver> it just goes up to some convenient fixed brightness
06:02:06 <quicksilver> such that it makes a decent looking white
06:02:29 <sizur> quicksilver: yeah that's reasonable
06:02:52 <sizur> absolute to the relative human brightness perception
06:03:18 <hpaste>  Taejo pasted ""do" syntax error" at http://hpaste.org/5057
06:03:56 <Taejo> GHC says:
06:03:58 <Taejo> .xmonad/xmonad.hs:20:24:
06:03:59 <Taejo>     The last statement in a 'do' construct must be an expression
06:04:03 <sizur> or just a little higher to fix it, whatever.
06:04:19 <Taejo> but the do construct doesn't end at line 20 at all
06:04:27 <Taejo> and where it does end, there is an expression
06:04:34 <sizur> so i guess adding colors is a simple addition then with a cap
06:04:54 <doserj> Taejo: change "class" to something different?
06:05:22 <Taejo> ah yes... forgot class is a reserved word
06:09:55 <sizur> makes perfect sense as it's the ammount of photons that the eye recieves that determines the percieved brightness. or rather some logarithmic function of it.
06:15:20 <pjd> sizur: gamma, linear vs. log scale, and so on is actually only scratching the surface of colors
06:15:55 <sizur> let add a b = log((a+1)*(b+1)) where add 0.4 0.6 -- this one looks good
06:17:19 <ac> So I have a class for four different types of color: ColorRGBA, ColorRGB, ColorGrey, and ColorIndex. Each of them have methods (if that's what you call them in Haskell) for retrieving red, green, blue, alpha, grey, or the index value. I want another class (I think) for an image, which has a method of type "Image -> Int -> Int -> a" where "a" is one of my color types. I also want one or two functions that take an image and "encode" them s
06:23:03 <koeien> if i execute "length [1..]" in ghci, and interrupt it, it seems to "hang on" to that memory
06:23:10 <koeien> will it ever be garbage collected?
06:23:36 <dcoutts> dunno, try it
06:23:44 <koeien> yeah i am...
06:23:45 <ac> so the Image class might be "class Image a b where getPixel :: a -> Int -> Int -> b". How do I indicate b is one of the four color type classes?
06:23:48 <koeien> it has 300MB now
06:24:11 <dcoutts> koeien: remember that ghc's storage manager never release memory back to the OS
06:24:13 <quicksilver> ac: you don't, really.
06:24:30 <ac> quicksilver: that's what I figured. I'm probably not thinking about this in the right way
06:24:33 <quicksilver> ac: you indicate that in the types of other functions
06:24:48 <quicksilver> ac: which take the form (Pixel b, Image a b) -> .....
06:24:52 <quicksilver> => rather
06:25:16 <quicksilver> as long as all your functions which actually operate on Images mention in their context that a Pixel b constraint is required
06:25:20 <dcoutts> koeien: anyway, length [1..] should not use any memory anyway
06:25:31 <koeien> dcoutts: never? hmm strange, does that hold as well for executables generated by ghc?
06:25:46 <quicksilver> dcoutts: interpreted I expect it does?
06:25:57 <quicksilver> dcoutts: it's actually generating and destroing cons cells..
06:26:17 <koeien> (it is in ghci indeed)
06:26:32 <dcoutts> quicksilver: it should churn through GC'd memory but never grow the usage beyond a single generation
06:26:53 <quicksilver> yeah
06:26:56 <dcoutts> koeien: ghc uses the same rts and GC as ghc-compiled programs (since ghc is compiled by ghc)
06:27:18 <Saizan> quicksilver: what's wrong with class Pixel b => Image a b where ..?
06:27:19 <koeien> dcoutts: yes but ghci could do evil memory hacks
06:27:34 <quicksilver> Saizan: Hmm. Nothing actually.
06:27:37 <dcoutts> koeien: that's true, the bytecode stuff is slightly different in places
06:27:41 <koeien> for appropriate definitions of "evil"
06:27:53 <quicksilver> Saizan: I'd never thought of superclasses for MPTCs before ;)
06:28:07 <quicksilver> Saizan: superclasses only mentioning some of the parameters. Interesting.
06:28:15 <dcoutts> koeien: in particular it does no optimisations that can sometimes improve space usage
06:28:47 <koeien> indeed less important in the interpreted case
06:29:49 <ac> the only way to have separate implementations of a function with the same name is with multiple instances of a class, right?
06:30:16 <koeien> ac: in the same module
06:33:35 <sizur> @pl \f a b -> f <$> a <*> b
06:33:35 <lambdabot> ((<*>) .) . (<$>)
06:37:32 <Saizan> sizur: liftA2
06:38:31 <koeien> well, the program `main = print $ length [1..]` eats my memory as well :/
06:39:30 <doserj> compiled with -O2?
06:39:38 <koeien> doserj: hmm, duh
06:40:28 <koeien> doserj: even compiled with -O2
06:40:35 <koeien> ghc 6.6.1
06:41:23 <roconnor> > 9216/1024
06:41:25 <lambdabot>  9.0
06:41:48 <roconnor> > 9216/1024/12
06:41:49 <lambdabot>  0.75
06:42:30 <quicksilver> roconnor: I never trust / to be left-associative
06:42:43 <quicksilver> roconnor: it's just so unintuitive I always bracket it just in case :)
06:42:49 <roconnor> quicksilver: and minus?
06:44:07 <Saizan> minus is the work of the devil
06:44:38 <quicksilver> roconnor: I'm more used to minus, because it's used in infinite series relatively often
06:44:39 <roconnor> Saizan: oh.  I don't associate with the devil.
06:44:46 <quicksilver> 1-(1/2)+(1/3)-(1/4) etc
06:55:44 <_piranha_> hi, guys. Can anyone tell me in which package in debian resides 'regex-posix'? I have ubuntu and can't find it
06:56:51 <_piranha_> ah, libghc6-regex, right? :-)
06:58:22 <_piranha_> hmmm... looks like this is virtual package. But why then yi says that I don't have them?
06:59:01 <Tac-Tics> How can I catch a stack overflow exception?
06:59:31 <CosmicRay> I don't think you could
06:59:35 <koeien> can you?
06:59:48 <CosmicRay> libghc6-regex-dev or some such
06:59:52 <CosmicRay> apt-cache search libghc6-regex
06:59:54 <koeien> if you can, Control.Exception.catch ?
07:00:08 <Tac-Tics> I want to write a wrapper for user-supplied code
07:00:14 <_piranha_> CosmicRay: yep, but debian says they are virtual
07:00:28 <Tac-Tics> but even in pure code, you can cause the thread to bottom out or eat unbounded memory
07:00:33 <Tac-Tics> I want to just kill it if it does that
07:00:33 <_piranha_> I have ghc6.8 installed and yi still says that they are needed :-(
07:00:54 <Tac-Tics> Similar to lambda bot
07:00:56 <koeien> Tac-Tics: try it and you'll see
07:01:04 <Tac-Tics> I did try control.except.catch
07:01:05 <ac> _piranha_: ghc6.8 is not in an ubuntu package
07:01:09 <quicksilver> Tac-Tics: to be reliable you'll have to do it like lambdabot does it
07:01:25 <quicksilver> Tac-Tics: the GHC RTS doesn't really have enough hooks for this kind of thing.
07:01:28 <koeien> Tac-Tics: there is a lambdabot page explaining security measures
07:01:34 <quicksilver> would be nice to have, definitely.
07:01:39 <Tac-Tics> yeah
07:01:53 <ac> _piranha_: only 6.6 is. You'll have to install the regex package with cabal
07:02:08 <_piranha_> ac: I've compiled it
07:02:13 <Tac-Tics> That seems to me one of the greatest benefits of the flexibility of the type system is to make it really easy to allow for untrusted code to be run
07:02:13 <_piranha_> backported from hardy
07:02:46 <koeien> Tac-Tics: you always have the problem of infinite memory / cpu time
07:02:48 <koeien> i.e. halting problem
07:03:11 <koeien> (if you want a turing-complete language, that is)
07:03:17 <Tac-Tics> Koeien, yes, but that doesn't mean I can't kill it when it's memory or time usage is too great
07:03:23 <koeien> sure, yes
07:03:31 <Tac-Tics> Even computers aren't turing complete, because their memory is bounded
07:03:55 <Tac-Tics> (discounting the internet, which I'm sure finds a way to give them turing completeness.... blogspace is unbounded)
07:03:57 <koeien> true but then your OS will kill your process or fail to allocate memory
07:04:10 <koeien> and then your wrapper for untrusted code crashes as well
07:04:18 <byorgey> Tac-Tics: I don't think lambdabot does it with Haskell code, though
07:04:29 <byorgey> it uses OS-based resource limits and things like that
07:04:44 <Tac-Tics> that's no fun!
07:04:58 <quicksilver> lambdabot does a true fork()
07:05:00 <byorgey> anyway, yes, you should read the wiki page about how lambdabot does it, it explains it well
07:05:00 <quicksilver> which is the only way to do it
07:05:09 <Tac-Tics> I will read it, thanks
07:05:11 <quicksilver> since the GHC RTS doesn't ahve per-thread resource limiting
07:05:18 <quicksilver> I'm not really sure what koeien is trying to say
07:05:28 <quicksilver> it is obviously possible to limit resource usage of user code
07:05:36 <quicksilver> and much nicer than waiting for the OS to kill you :P
07:06:07 <koeien> quicksilver: is it possible to limit another thread's cpu from within haskell?
07:06:23 <koeien> quicksilver: that's what i meant to say, you probably have to spawn another process
07:06:30 <Tac-Tics> If we're talking about untrusted code, from haskell's point of view, the OS itself is suspect code!
07:06:40 <koeien> quicksilver: instead of doing it within the process itself
07:07:05 <byorgey> Tac-Tics: true.  so I guess you'll first just need to implement an OS in haskell =)
07:07:09 <koeien> Tac-Tics: so code a Haskell OS :)
07:07:12 <Tac-Tics> All OS functions need to carry their IO badges at all time.
07:07:49 <quicksilver> koeien: no, but it ought to be.
07:07:57 <Tac-Tics> That's a bit extreme for what I wanted to do (a system for people to upload arbitrary AI plugins into a game)
07:08:17 <quicksilver> koeien: I'm suggesting it's a deficiency in the GHC RTS that it doesn't.
07:08:25 <ac> _piranha_: yeah I just did an apt update and 6.8.2 is in there
07:08:34 <Tac-Tics> Having something like runAI:: Int -> State s a -> s -> IO (Maybe (a, s)) would be very nice
07:08:36 <ac> (finally)
07:08:36 <_piranha_> ac: you're using debian?
07:08:41 <ac> _piranha_: ubuntu
07:08:43 <_piranha_> ac: or hardy?
07:08:47 <_piranha_> :-) cool
07:09:02 <koeien> according to the lambdabot wiki, another process is spawned
07:09:14 <Tac-Tics> (where runAI time ai gameState returns the maybe result of the AI)
07:09:17 <_piranha_> ac: I just don't want to upgrade, so I rebuilded package (along with hscolour, haskell-utils and mtl from debian sid)
07:09:25 <koeien> the cpu/mem limits are enforced by the OS
07:09:32 <quicksilver> koeien: "15:04 < quicksilver> lambdabot does a true fork()"
07:09:41 <_piranha_> ac: but can't understand what's with yi :-(
07:09:44 <koeien> quicksilver: ok missed that
07:09:50 <Tac-Tics> There is no fork!
07:10:07 <Tac-Tics> _piranha_: getting Yi to compile is the biggest pain ever
07:10:19 <_piranha_> Tac-Tics: :D any docs for that? :-)
07:10:28 <koeien> Tac-Tics: yes i have problems with that as well
07:10:28 <quicksilver> Taejo: if there is no fork, lambdabot does a true spoon()
07:10:33 <quicksilver> oops
07:10:35 <Tac-Tics> no good ones, sadly
07:10:36 <quicksilver> that was for Tac-Tics
07:10:36 <quicksilver> ;)
07:10:40 <ac> _piranha_: I just started a 400MB upgrade from gutsy to hardy
07:10:48 <koeien> hardy is beta right?
07:10:56 <_piranha_> ac: it is 1900 mb for me :D
07:10:57 <koeien> i have gutsy on my temp laptop
07:11:19 <Taejo> quicksilver: what?
07:11:21 <Tac-Tics> The way I got it to work was to install a fresh copy of GHC 6.8 by source, install vty, and fingertree, and only then will yi work
07:11:54 <Tac-Tics> I'm on ubuntu too, and using the package managed GHC 6.6 just never worked for me
07:12:34 <Tac-Tics> but I have to do some work now I think. Thanks all for your input on my bounded resource problem
07:13:00 <_piranha_> koeien: yeah, hardy is beta
07:13:50 <koeien> Tac-Tics: ok i'll try that once i get my debian laptop back
07:15:13 <quicksilver> Taejo: tab completion error :P
07:15:26 <HairyDude> anyone happen to know if the alioth repository (with debian stable versions of recent ghc) is suitable for ubuntu?
07:19:42 <CosmicRay> what alioth repo is this?  debian-unsafe?
07:19:52 <CosmicRay> err haskell-unsafe
07:22:03 <_piranha_> Tac-Tics: there was libraries/regex-* folder in your ghc sources?
07:22:06 <czakey> > let addtolist l = map (+1) l; addtolist [1,2,3]
07:22:07 <lambdabot>  Parse error at end of input
07:22:14 <czakey> > let addtolist l = map (x+1) l; addtolist [1,2,3]
07:22:15 <HairyDude> CosmicRay: yup
07:22:15 <lambdabot>  Parse error at end of input
07:22:21 <czakey> meh
07:23:00 <czakey> > let addtolist (x:xs) = (x+1):(addtolist xs); addtolist [1,2,3]
07:23:00 <lambdabot>  Parse error at end of input
07:23:04 <czakey> > let addtolist (x:xs) = (x+1):(addtolist xs)
07:23:05 <lambdabot>  Parse error at end of input
07:23:29 <quicksilver> czakey: lambdaot evaluates expressions
07:23:35 <koeien> > let addtolist (x:xs) = (x+1):addtolist xs in addtolist [1,2,3]
07:23:39 <quicksilver> czakey: not declarations
07:23:42 <lambdabot>   Non-exhaustive patterns in function addtolist
07:23:42 <koeien> but that doesn't work (you forgot the base case)
07:23:51 <quicksilver> czakey: you have to "do something" with the let, i.e. add an 'in'
07:23:52 <czakey> thx
07:23:55 <CosmicRay> HairyDude: you're not going to find recent ghc for stable in there
07:24:06 <koeien> debian sid has ghc 6.8.2 ?
07:24:18 <czakey> I'll beter write it in GHC for myself ;d
07:24:23 <_piranha_> koeien: yes, and ubuntu hardy
07:24:27 <czakey> but thanks
07:24:28 <CosmicRay> HairyDude: the only recent ghc's there are for unstable, and will be linked against the same libs as the ghc in debian sid, but less current
07:24:32 <HairyDude> oh, is it out of date?
07:24:51 <HairyDude> hah, 6.4, even stable is more up to date than that
07:25:09 <HairyDude> bugger that then
07:27:32 <HairyDude> I'd install the hardy package but the dependencies are too recent.
07:27:51 <czakey> let addtolist (x:xs) = x+1:(addtolist xs)
07:28:01 <czakey> why that doesn't work?
07:28:06 <koeien> czakey: it is not a value
07:28:19 <czakey> 2,3,4*** Exception: <interactive>:1:4-40: Non-exhaustive patterns in function addtolist
07:28:27 <HairyDude> addtolist xs = map (+1) xs
07:28:34 <koeien> czakey: yes, it does not work
07:28:44 <czakey> byt I dont want to do that with map...
07:28:47 <koeien> czakey:a list can be two things
07:28:56 <czakey> but*
07:29:01 <koeien> czakey: either the empty list, or a value plus another list
07:29:22 <HairyDude> what's wrong with map?
07:29:27 <koeien> czakey: (x:xs) is the second case, but you haven't defined what would happen with the empty list
07:29:34 <koeien> czakey: i.e. addtolist [] is not defined
07:29:39 <czakey> yup
07:29:41 <czakey> i got it
07:29:44 <czakey> thanks
07:29:49 <czakey> stupid mistake
07:29:49 <czakey> :)
07:30:04 <koeien> czakey: but using map is a lot clearer
07:30:19 <koeien> like HariyDude said, or even addtolist = map (+1)
07:30:43 <czakey> I know
07:31:07 <czakey> but I have to do something with list elements in that function too
07:31:20 <czakey> that's was only for debug
07:31:25 <HairyDude> so a fold?
07:31:54 <koeien> czakey: if you use ghc, you can compile with -Wall
07:32:00 <koeien> czakey: that'll catch these things at compile time
07:32:05 <czakey> hm
07:32:14 <czakey> I'm using interpreter
07:32:27 <czakey> can I gain verbosity there?
07:33:09 <koeien> czakey: yes
07:33:22 <koeien> czakey: at least with ghci
07:33:27 <koeien> (don't know about hugs)
07:33:54 <czakey> yup, I have both
07:34:08 <czakey> but I writing in GHC
07:39:03 <nominolo> @seen bringert
07:39:04 <lambdabot> I haven't seen bringert.
07:39:59 <quicksilver> lais!
07:40:03 <quicksilver> I saw you see him...
07:41:46 <dcoutts> nominolo: he's away for a few days
07:42:04 <moonlite> nominolo: you know anything about dates for hac'08?
07:42:29 <jedbrown> Oleg has a paper on generating FFT code <http://okmij.org/ftp/NumMath.html#FFT-generation> which exactly matched FFTW.  Is this practically useful for the Haskell community, or would bindings to FFTW be better?
07:42:55 <nominolo> moonlite: no, but i guess we'll decide on one soon
07:43:17 <moonlite> nominolo: neat
07:43:57 <nominolo> moonlite: so far, there's one bad for each, so i guess we'll roll dice or something
07:44:00 <nominolo> :)
07:44:05 <moonlite> :)
07:45:56 <HairyDude> so anyway, are there packages for recent ghc (i.e. 6.8) that will work on gutsy? or will I have to roll my own?
07:46:14 <jaj> Hi! I wanted to know if there is an easy way to actually render music in haskell
07:46:17 <nominolo> HairyDude: unlikely
07:46:31 * nominolo didn't manage to update to gutsy, though
07:46:36 <jaj> sending sine waves to the sound card is all I actually need
07:47:29 <nominolo> jaj: the yampa guys used mplayer.  maybe they got something better now. (unlikely, though)
07:48:02 <jaj> nominolo, thanks
07:48:04 <dcoutts> jaj: have you checked hackage? otherwise probably just generate pcm data and pipe it to a program that can play it
07:48:17 <quicksilver> jaj: on unix you can just open the sound card like a file.
07:48:26 <quicksilver> jaj: on other OSes it may be harder :)
07:49:37 <ac> @users
07:49:38 <lambdabot> Maximum users seen in #haskell: 454, currently: 408 (89.9%), active: 18 (4.4%)
07:49:46 <CosmicRay> quicksilver: it is not quite that easy even on unix.  you need ioctls to set the sampling rates and stuff
07:50:11 <jaj> quicksilver, yeah I'm on bsd. I just have to figure out what kind of data the sound device actually wants
07:50:30 <jaj> I just get garbage noise when I try to write to it
07:54:03 <byorgey> jaj: maybe this is useful: http://slavepianos.org/rd/r/darcsweb.cgi?r=hsc3;a=plainblob;f=/Help/Tutorial/Tutorial.lhs ?
07:54:05 <lambdabot> http://tinyurl.com/2nghp6
07:54:07 <quicksilver> CosmicRay: or you can fiddle with the sampling rate until it goes alright :P)
07:54:21 <quicksilver> jaj: typically 44khz 16bit, I think?
07:54:24 <byorgey> jaj: SuperCollider + Haskell bindings
07:54:27 <quicksilver> or 40khz or 8bit
07:54:29 <quicksilver> who knows :)
07:54:44 <byorgey> jaj: possibly overkill for what you want, I haven't used it =)
07:54:56 <jaj> quicksilver, thanks I'll try with those values
07:55:56 <jaj> byorgey, yeah I saw that this guy: http://www.youtube.com/watch?v=eLS6GHXWMpA also uses soundcollider bindings
07:55:56 <lambdabot> Title: YouTube - hacking haskell music
07:56:15 <jaj> but I think it's really overkill for me
07:58:05 <czakey> hm
07:58:10 <czakey> how to import module
07:58:16 <czakey> in file?
07:58:24 <czakey> coz with interpreter
07:58:30 <czakey> i can use "import List"
07:58:35 <koeien> :m +Data.List
07:58:36 <koeien> ex
07:58:47 <quicksilver> it's the other way around, surely?
07:58:50 <czakey> but in file that does'nt work
07:58:52 <quicksilver> import Data.List in a file
07:59:00 <quicksilver> :m +Data.List in an interpreter
07:59:03 <Saizan> quicksilver: in hugs it's import
07:59:05 <quicksilver> ah
07:59:06 <Saizan> iirc
07:59:11 <quicksilver> czakey: has to be at the top of the file though
07:59:28 <czakey> quicksilver: that was the problem probably
07:59:30 <czakey> thx
07:59:37 <doserj> import also works in ghci
08:00:45 <byorgey> in the latest version of ghci, you can use import or :m +
08:01:27 <quicksilver> interesting
08:01:31 <quicksilver> live and learn!
08:01:36 <quicksilver> or, irc and learn!
08:04:33 <jedbrown> Do other people use this hack: put `:l "/home/jed/.ghci.hs"' in ~/.ghci which then imports a bunch of common modules so that the prompt isn't out of control, but it still adapts as you import others.
08:05:02 <koeien> jedbrown: interesting
08:05:39 <quicksilver> I must admit I don't
08:05:44 <quicksilver> the prompt seldom bothers me
08:05:59 <jedbrown> Even when it's multiline?
08:06:10 <quicksilver> when I'm working at a bare prompt I find it fairly helpful to rememebr which modules I need
08:06:15 <quicksilver> much more often, I"m working on a program
08:06:24 <quicksilver> and when I load a file, I get all the modules it needs automatically
08:06:34 <quicksilver> then I only get added to my prompt anything which was 'missing'
08:06:44 <quicksilver> which serves as a reminder to me to add an import statement to the file
08:06:54 <quicksilver> if I decide to add the funciton I've been playing with permanently
08:07:21 <jedbrown> Of course, my solution doesn't change anything if you are loading your own file.
08:07:47 <jedbrown> It just gives you a sensible environment when playing with the repl.
08:08:14 * quicksilver nods
08:08:24 <quicksilver> I guess I seldom play with the repl fo rall that long without loading a file
08:10:06 <czakey> @src minimum
08:10:06 <lambdabot> minimum [] = undefined
08:10:06 <lambdabot> minimum xs = foldl1 min xs
08:10:23 <czakey> @src min
08:10:23 <lambdabot> min x y = if x <= y then x else y
08:10:40 <czakey> @src foldl1
08:10:41 <lambdabot> foldl1 f (x:xs) = foldl f x xs
08:10:41 <lambdabot> foldl1 _ []     = undefined
08:10:52 <czakey> ha
08:11:02 <dons> ?users
08:11:02 <lambdabot> Maximum users seen in #haskell: 454, currently: 409 (90.1%), active: 21 (5.1%)
08:11:02 <czakey> that was my problem
08:11:33 <czakey> sort l = (minimum l):sort (delete (minimum l) l)
08:11:35 <koeien> why is foldl1 _ [] not error "foldl1: ... "
08:11:52 <koeien> @src head
08:11:53 <lambdabot> head (x:_) = x
08:11:53 <lambdabot> head []    = undefined
08:11:57 <czakey> but minimum for [] is undefined
08:12:17 <mux> I guess that's for having a better error message
08:12:25 <koeien> mux: yes
08:12:42 <koeien> mux: but the ghci gets is correct
08:12:56 <czakey> is there other "minimum" defined for []?
08:13:06 <czakey> or I must write one for myself? :P
08:13:38 <koeien> czakey: what would it be ?
08:13:57 <czakey> selection-sort
08:13:58 <koeien> czakey: and by the way, what would be the sort of [] then?
08:14:07 <koeien> czakey: it would recurse infinitely often
08:14:22 <czakey> sort [] = []
08:14:22 <czakey> i have it
08:14:38 <koeien> czakey: there is no sensible definition for minimum [] in your usage of it
08:15:41 <HairyDude> > minimum []
08:15:44 <lambdabot>  Exception: Prelude.minimum: empty list
08:16:14 <nominolo> @pl \x y z -> f $ g x y z
08:16:14 <lambdabot> ((f .) .) . g
08:16:27 <nominolo> @pl \y z -> f $ g y z
08:16:28 <lambdabot> (f .) . g
08:16:44 * HairyDude dislikes sections of (.)
08:17:15 <HairyDude> lambdas are much easier to understand
08:18:10 <quicksilver> yes, I agree mostly
08:18:16 <quicksilver> but it's a question of what you get used to
08:18:30 <mightybyte> @pl \a b -> a ++ " " ++ b
08:18:31 <lambdabot> (. (' ' :)) . (++)
08:18:54 <czakey> > cycle "o_O "
08:18:56 <lambdabot>  "o_O o_O o_O o_O o_O o_O o_O o_O o_O o_O o_O o_O o_O o_O o_O o_O o_O o_O o_O...
08:19:07 <Vq^> and of course which expression
08:21:06 <quicksilver> I did use a section of <$> the other day
08:21:11 <quicksilver> (foo <$>) . bar
08:21:29 <Vq^> @type (<$>)
08:21:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:22:36 <quicksilver> for checking the type of something I was doing
08:22:58 <osfameron> using (f .). g is just horrible, at least define a (.:) combinator or something
08:23:44 <nominolo> zipWith ($) (scanl (.) id (repeat reverse)) (replicate 5 " O_o ")
08:23:47 <nominolo> > zipWith ($) (scanl (.) id (repeat reverse)) (replicate 5 " O_o ")
08:23:49 <lambdabot>  [" O_o "," o_O "," O_o "," o_O "," O_o "]
08:23:56 <quicksilver> does anyone know about external sort algorithms? Apparently knuth has something they call a replacement-selection sort?
08:24:06 <quicksilver> but that seems surprisingy hard to google
08:24:09 <Jaak> @pl \f g -> (. f) . g
08:24:10 <lambdabot> (.) . flip (.)
08:24:34 <nominolo> quicksilver: you don't have the books?? ;)
08:25:21 <quicksilver> only volume 1
08:25:57 <quicksilver> hmm
08:26:01 <nominolo> well, it's in the volume titled "sorting and searching" ...
08:26:12 <quicksilver> so it's basically a merge sort with some attempt to locate initially sorted segments?
08:26:20 <quicksilver> and so not perform too badly on partly sorted data?
08:51:50 <ac> haskell98 only allows one parameter classes?
08:51:59 <sarehu> yep
08:52:02 <ac> shocking
08:52:15 <quicksilver> MPTCs are a bit of a can of worms
08:52:26 <quicksilver> most interesting examples of them require fundeps or some other technique
08:52:41 <daf> what's a fundep?
08:52:46 <quicksilver> I imagine that's why haskell98 is conservative in that regard
08:52:51 <sarehu> functional dependency
08:54:52 <sizur> @desugar do { b <- return a; return b }
08:54:53 <lambdabot> Unknown command, try @list
08:55:07 <quicksilver> @undo  do { b <- return a; return b }
08:55:08 <lambdabot> return a >>= \ b -> return b
08:55:40 <Tobsan> @src concat
08:55:40 <lambdabot> concat = foldr (++) []
08:56:02 <sizur> quicksilver: thanks
09:10:41 <dons> dcoutts: we get sentiment like this quite a bit from the elite tiling wm users, "" <oht> some recommend xmonad but i dont want to install the 50+ megs worth of
09:10:44 <dons>              libs/compilers libs/compilers to compile haskell shit""
09:10:51 <ac> if I have a type class "Foo a b" and another class "Bar a" can I make an istance of Bar where the parameter "a" is restricted to "Foo a Int"?
09:10:55 <dons> dcoutts: i suggest: a lambda-linux distro that has ghc preinstalled :)
09:11:01 <dcoutts> dons: :-)
09:11:03 <dons> as a solution to our toolchain issues
09:11:23 <taruti> debian + recent ghc + packages tends to be painful
09:11:33 <dons> yeah, debian is being a bit painful atm
09:11:41 <dons> but joachim and igloo are getting there.
09:11:42 <dcoutts> dons: use gentoo instead then :-)
09:11:54 <taruti> there wouldn't be i386 xmonad 0.5 deb somewhere? :)
09:12:07 <dons> this is the number one issue in haskell open source adoption -- the toolchain
09:12:25 <dcoutts> dons: yes
09:12:27 <dons> there is no greater barrier to getting haskell code into wide use than the ease/difficulty of a working ghc + extralibs
09:12:39 <dons> taruti: indeed there is.
09:13:22 <dcoutts> dons: I've gone on before about platform management
09:13:47 <wolverian> the local admin is bitching about ghc needing huge separate runtimes for each point release
09:13:53 <taruti> dons: where? xmonad.org links to http://packages.debian.org/sid/xmonad which has 0.4-6
09:13:55 <lambdabot> Title: Debian -- Details of package xmonad in sid
09:14:04 <wolverian> so he's dropping 6.6 support altogether when upgrading to 6.8, probably
09:14:10 <dons> i'm almost certain "ghc pain" is the reason we see slower adoption than less featureful/stable competitors written in C, on debian
09:14:13 <dons> taruti: http://people.debian.org/~nomeata/xmonad/
09:14:13 <lambdabot> Title: Index of /~nomeata/xmonad
09:14:22 <wolverian> which isn't very friendly in the environment he's used to, where languages are abi compatible for years
09:14:27 <taruti> thanks
09:14:35 <dons> they'll be in debian "soon"
09:15:01 <dons> dcoutts: though it seems ghc is easier than getting a working lisp system.
09:15:03 <dons> poor stumpwm
09:15:10 <dcoutts> :-)
09:15:19 <taruti> clisp is not that hard to install.
09:15:41 <dons> we could really do with some high level advocacy -- who decides that python gets in the base system on a distro?
09:16:07 <dons> ghc in a base system -- even just a minimal install - would change the open source environment
09:16:22 <dons> you could throw haskell at any problem without worrying about users complaining
09:16:27 <Igloo> python tends to get in because system scripts etc are written in it, and it's an interpreter
09:16:37 <Tac-Tics> Python is stupid easy to learn too
09:16:44 <dons> bah
09:16:52 <Tac-Tics> Haskell is awesome because there's so much to learn
09:17:01 <gwern> dons: NixOS uses a lazy fp language heavily inspiried by haskell for its package management; maybe we could convert them to just go with straight haskell, and thus include ghcby default :)
09:17:02 <Tac-Tics> but most people just want things done without worrying about monads or types
09:17:10 <dons> gwern: oh, that's a point.
09:17:10 <resiak> if debian would adopt the linspire people's dpkg toolsâ¦ :D
09:17:17 * dons slaps Tac-Tics 
09:17:24 <dons> this is why system scripts break, Tac-Tics
09:17:30 <dons> system-critical code, written without tests or types
09:17:53 <Igloo> Debian's definition of standard priority is "These packages provide a reasonably small but not too limited character-mode system.  This is what will be installed by default if the user doesn't select anything else.  It doesn't include many large applications.". ghc6 is 200M on amd64
09:17:59 <quicksilver> Tac-Tics: haskell is awesome because it has so much to teach you
09:18:23 <dons> Igloo: that's too big. that's dangerously big.
09:18:31 <dons> a ghc bootstrap binary should be about 6M or so. :(
09:18:44 <Taejo> @src Monoid
09:18:44 <lambdabot> class Monoid a where
09:18:44 <lambdabot>     mempty  :: a
09:18:44 <lambdabot>     mappend :: a -> a -> a
09:18:44 <lambdabot>     mconcat :: [a] -> a
09:18:50 <dons> a 200M ghc6 would really really hurt xmonad
09:18:53 <dcoutts> Igloo: why is it so big? that includes all the core libs I suppose and there's duplication between ghci .o, profiling and standard libs
09:19:09 <dons> ghc6 / ghc6-dev (for basic/ full ghc?)
09:19:13 <wolverian> static libraries.
09:19:50 <ac> my installation of ghc6.8.2 is 299M
09:19:53 <Igloo> Well, /usr/lib/ghc-6.8.2/lib/base-3.0.1.0 is 68M (although that includes the files from ghc6-prof too)
09:20:03 <dons> we need to do something about this. it really is hurting our ability to break into the mainstream
09:20:15 <resiak> Bah, the FAQ entry for why shared libraries only work on the Mac, but doesn't say what stops them working on other platforms
09:20:20 <dons> while lua got widely adopted due to being *small*
09:20:27 <Igloo> libHSbase-3.0.1.0.a is 20M, and 30M for the profiling version
09:21:21 <dcoutts> Igloo: using shared libs should help there a bit, they'd be smaller than the .a files due to less split-objs padding
09:21:28 <dcoutts> and it'd eliminate the ghci .o versions
09:21:38 <wolverian> Cabal-1.2.3.0 alone is 14mb
09:21:53 <daf> /usr/lib/ghc-6.6.1/libHSghc.a is 23M
09:21:56 <dcoutts> and I think the .hi files should be combined into one big .hi package file
09:22:36 <daf> the GHC executable is 9.8M
09:22:44 <Igloo> More base splitting might help too. I'm not how much can be made non-boot, though
09:22:44 <wolverian> now I understand why the admin is sad about this :)
09:22:50 <wolverian> I didn't think the situation was this bad
09:23:16 <daf> Igloo: the static stuff accounts for a lot of it
09:23:48 <wolverian> heh, xmonad-contrib is 6mb
09:23:57 <Igloo> If we can disentangle haskell98 then that would help a bit too
09:24:15 <funktio> @pl (\f g h -> f (g . h))
09:24:15 <lambdabot> (. (.)) . (.)
09:24:50 <funktio> cute
09:24:58 <wolverian> so, does anyone know why shared libs don't work?
09:25:00 <jedbrown> I'd think shared libraries would simplify licensing w.r.t LGPL?
09:25:09 <dcoutts> wolverian: they do, it's in development
09:25:19 <wolverian> ah. great.
09:25:21 <wolverian> thanks
09:25:24 <dcoutts> wolverian: therp has been hacking on that for a while now
09:25:31 <wolverian> any idea if we'll get that in 6.10?
09:25:35 <Igloo> jedbrown: It's still murky if you cross-module-inline
09:25:37 <wolverian> (or before?)
09:26:02 <dcoutts> wolverian: 6.10 I expect
09:26:19 <wolverian> hooray
09:26:25 <hexpuem> how big is hello world on x86 supposed to be with split objs?
09:26:25 * jedbrown hates when software licenses won't play nicely together.
09:27:01 <ac> :t (.) (.)
09:27:02 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
09:27:31 <quicksilver> @pl \f g h -> f.g.h
09:27:31 <lambdabot> (. (.)) . (.) . (.)
09:27:38 <gwern> *does* Linspire still use haskell? I never saw anything released or mentioned after the initial email and slides, and I heard on ltu (I think) that their chief haskell guy left
09:27:41 <quicksilver> @pl \f g h -> f.(g.h)
09:27:41 <lambdabot> (. (.)) . (.) . (.)
09:27:45 <dons> hexpuem: about 200k
09:27:47 <quicksilver> @pl \f g h -> (f.g).h
09:27:47 <lambdabot> ((.) .) . (.)
09:28:01 <hexpuem> thats pretty good
09:28:02 <dons> gwern: they do. we should try and extract their haskell code
09:28:05 <hexpuem> what ver of GHC you using?
09:28:21 <hexpuem> SPLITOBJS options in 6.8.0 doesnt seem to be working in the build
09:28:23 <desegnis> I think the problem about advocating ghc to be installed on everyone's system is that it is a compiler, not an interpreter. Distros want to provide binary packages for applications; static libraries are of not much use to the end user anymore; gcc isn't installed on every system either; ghc is not the only Haskell implementation; ...
09:28:36 <CosmicRay> gwern: look up Jeremy Shaw
09:28:41 <hexpuem> still getting a 1.5 MB PT_LOAD segment in the binary
09:28:45 <CosmicRay> gwern: I've even received patches from them before
09:28:53 <Deewiant> @pl \f g x y -> f $ g x y
09:28:53 <lambdabot> (.) . (.)
09:29:31 <dons> desegnis: it is the only haskell implementation for the *vast* majority of uses. same story as gcc, but even more so
09:29:37 <dcoutts> desegnis: ghci / runghc are interpreters
09:30:19 <desegnis> dons, yeah right, the not-the-only-one argument is a rather theoretical one
09:30:54 <wolverian> dons, ubuntu doesn't ship gcc either..
09:31:58 <ac> would it be possible to package up ghci without ghc and have it be smaller?
09:32:13 <dons> we're not lisp. we will not divide and fragment our efforts. we will not be conquered!
09:32:17 <byorgey> I think part of the problem is that at this current moment, we're in a weird sort of limbo where ghc 6.8 is needed to build various things, but it isn't easily available in some distro's package systems
09:32:19 <desegnis> dcoutts, the sysadmin will still have an acute look onto the size of ghc/lib
09:32:32 <gwern> CosmicRay: recently you mean?
09:32:35 <desegnis> dcoutts, what I mean:
09:33:01 <ac> if ghci could be significantly smaller, I think that would be a good trade off
09:33:23 <desegnis> It's probably easier to have an admin install an interpreter for yet another scripting language than an entire build system (even if the latter is of more use to us)
09:33:28 <dons> it would be more useful to me to have ghc without ghci. but only if the size was significantly less (which i don't think it would be)
09:33:34 <dcoutts> ac: no, ghci cannot be significantly smaller than ghc, at least not without removing libs etc
09:33:37 <quicksilver> desegnis: I'm not sure that the static library argument is as important as you suggest
09:33:49 <quicksilver> desegnis: actually windows and macos don't use dynamic linking all that much
09:33:54 <quicksilver> (just for standard system libs, mostly)
09:34:06 <dcoutts> dons: indeed, unless you pulled the bytecode interpreter out of the rts and ghc backend
09:34:09 <gwern> if we're discussing performance and size, I;ve noticeda loot of noobs complaining here about the size of simple programs like helloworld. maybe the -O options should turn on stripping as well
09:34:22 <dcoutts> gwern: cabal will do that soon
09:34:24 <quicksilver> because ordinary "applications" don't know what libraries you'll have installed, they tend to bundle everything.
09:34:35 <wolverian> quicksilver, who cares about broken platforms?
09:34:41 <quicksilver> Of course, linux/bsd users are much more clued up and expect nice shared libs for everything
09:34:42 <gwern> dcoutts: it will? ok nm then
09:34:48 <desegnis> quicksilver, in re dynamic linking: which is why I use Linux. ;)
09:34:53 <hexpuem> even when stripping a 1.5mb hello world screams bloat
09:35:01 <quicksilver> desegnis: I'd be surprised if that was the main reason :P
09:35:01 <hexpuem> and gzexe just papers over it
09:35:10 <quicksilver> desegnis: or even on of the five most important.
09:35:20 <dcoutts> hexpuem: it's just down to using static libs and we can move to using dynamic libs
09:35:22 <quicksilver> wolverian: I offer them as examples to suggest "it's not that important"
09:35:23 <desegnis> quicksilver, ye :-P
09:35:37 <hexpuem> he just said you can produce 200k executables with split objs enabled
09:35:44 <gwern> hexpuem: well past that you need to stop static linking, and also work on getting the size of the GHC RTS down
09:35:52 <hexpuem> for example the D language has its stdlib statically linked and its usually 300kish
09:36:25 <wolverian> quicksilver, it's important when ghc is 200mb...
09:37:00 <quicksilver> wolverian: well, yes ;)
09:37:11 <quicksilver> wolverian: ghc-compiled apps are not 200m though
09:37:15 <quicksilver> even under the static system
09:37:49 <wolverian> well, xmonad-contrib is 6.7mb, which is slightly large
09:37:57 <wolverian> but not quite as screamingly bloated, I agree
09:38:46 <therp> Hello world linked dynamically has 17kb for me btw (with the ghc HEAD)
09:38:58 <quicksilver> nice
09:39:04 <quicksilver> what is C hello world from gcc?
09:39:07 <hexpuem> how big is the stdlib.so though
09:39:24 <desegnis> quicksilver, so users who look at the numbers may say, Â»I don't care about installing applications compiled with ghc since I'm not a programmer, but I don't see why I should install a build system of >200M size.Â«
09:39:32 <wolverian> therp, nice
09:39:42 <gwern> therp: now that's much more reasonable. was that on linux?
09:39:52 <therp> gwern: yes
09:40:01 <wolverian> therp, how big is ghc when compiled like that? :)
09:40:24 <therp> -rwxr-xr-x 1 clemens clemens 171702 2008-01-17 15:30 compiler/stage2/ghc_dyn-6.9.20080116_real
09:40:30 <quicksilver> for me, gcc hello world is 13k
09:40:34 <quicksilver> just for comparison :)
09:40:49 <Tac-Tics> for me, hello world is 4K
09:40:55 <quicksilver> desegnis: Yes, I agree. 200M is a lot.
09:40:59 <therp> wolverian: but GHC uses a package, so most of the code isn't in that executable
09:41:14 <Tac-Tics> wait whoops
09:41:27 <hexpuem> C hello world statically linked is like 400k on this machine heh
09:41:30 <quicksilver> Tac-Tics: really?
09:41:36 <wolverian> therp, right, I meant compiling it all like that
09:41:45 <quicksilver> I get 13k on OSX/x86 and 11k on linux/x86
09:41:46 <therp> wolverian: compiler/libHSghc-ghc6.9.20080116.so=31mb
09:41:47 <Tac-Tics> no, I'm just dumb
09:41:49 <quicksilver> using gcc to compile
09:42:11 <Tac-Tics> 8K
09:42:19 <Tac-Tics> (the first time, I ran it on the src X-D)
09:42:29 <therp> wolverian: about 64mb just for the shared object libs
09:42:45 <gwern> gah. and how long until GHC HEAD becomes a release? >,<
09:42:46 <wolverian> therp, my 6.8.2 one is 27mb
09:42:50 <therp> hmm that seems too big.. maybe there are some unstripped symbols in there
09:43:35 <Tac-Tics> and I'm getting 364 on ghc 6.8 for the same program
09:43:37 <gwern> my ghc 6.8.2 is 17MB on gentoo
09:44:42 <therp> stripping the libs seems to help a bit, down to 55mb
09:45:34 <jedbrown> My 6.8.2 is 129 bytes :)
09:46:07 <desegnis> er, are we talking about Hello-worlds or libHSghcs here?
09:46:07 <hexpuem> so is there anything else you have to add to mk/build.mk besides SplitObjs = YES?
09:46:16 <wolverian> desegnis, I was talking about libHSghc
09:46:58 <desegnis> now I only hope jedbrown wasn't :)
09:47:49 <gwern> oh nm, my libHSghcs.a is 43M; I thought we were talking about the ghc binary itself
09:47:57 <jedbrown> desegnis: Of course, that was the shell script.  The executable is 20 MiB and libHSghc is 28 MiB.
09:48:28 <wolverian> ubuntu seems to be compiling ghc with Bloat = Yes enabled :)
09:48:36 <wolverian> s/enabled//
09:48:38 <hexpuem> no kidding haha
09:48:57 <wolverian> oh, wait, no it isn't
09:49:00 <wolverian> gwern's is larger
09:49:18 <byorgey> Taejo: no.
09:49:26 <byorgey> mischan
09:50:03 <dcoutts> wolverian: split-objs makes the .a files bigger, but the final binaries smaller
09:50:12 <dcoutts> with dynlibs it's all unnecessary
09:50:17 <hexpuem> whys that
09:50:27 <hexpuem> you still have to package dependency objects wth the distro
09:50:54 <desegnis> jedbrown, ah ok
09:50:59 <dcoutts> hexpuem: with dynlibs you'd get small binaries and not get the extra padding that split-objs adds to the .a files
09:51:19 <dcoutts> hexpuem: of course you have to distribute the .so files, but they should be smaller than equivalent split-objs .a files
09:51:32 <hexpuem> but you dont need to distro the .a files
09:51:49 <hexpuem> for single applications not a build environment i mean
09:52:09 <dcoutts> well, then you're statically linking most of the libs into your binary
09:52:17 <hexpuem> obviously theres a time and place for both but the default static linking without splitobj seems broken
09:52:47 <dcoutts> the default on supported platforms is indeed to use split-objs for ghc and core libs
09:53:06 <dcoutts> if it's not on your distro it's because the distro turned it off
09:53:08 <hexpuem> dunno how people are getting 200kb test app builds then
09:53:52 <hexpuem> yea its likely, but i also built from src with split objs enabled and it diddnt seem to do anything
09:53:54 <dcoutts> cabal can build libs using split-objs too, though it does not do so by default
09:54:02 <hexpuem> could be the default ghc had it on or that i screwed the build up
09:54:38 <ac> what does -fallow-undecidable-instances do?
09:55:01 <dcoutts> ac: see the ghc user manual section on language extensions
09:56:54 <EvilTerran> ac, it lifts the coverage condition. ;)
09:57:17 <Saizan> ac: it turns off some checks that guarantee termination of the type checker
09:57:49 <EvilTerran> also, i believe the done thing is to write it as -XUndecidableInstances, these days
09:58:12 <EvilTerran> or drop the -X and put it in a {-#LANGUAGE#-}
09:58:18 <dcoutts> ac: it's for writing crazy logic programs using multi-parameter type classes as if they were prolog predicates
10:01:24 <kosmikus> ?seen bringert
10:01:27 <lambdabot> I haven't seen bringert.
10:02:16 <ac> I probably don't need it, I'm just making a mistake
10:03:26 <u_quark> how can i debug my code with ghc 6.6.1 ?
10:04:30 <Saizan> dcoutts: aren't they?:)
10:05:01 <dcoutts> Saizan: crazy? yes they are crazy :-)
10:05:24 <dcoutts> kosmikus: he's away for a few days
10:05:43 <dcoutts> u_quark: ghci, divide and conquer
10:06:19 <kosmikus> dcoutts: ta
10:07:54 <u_quark> Prelude> :break 1
10:07:54 <u_quark> unknown command ':break'
10:07:54 <u_quark> use :? for help.
10:07:54 <eyeris> How can I tell which types are instances of a given class in GHCI?
10:08:23 <ac> eyeris: :info
10:09:17 <eyeris> ac: ok, that's what I though, but now I am more confused :)
10:09:57 <eyeris> ac: Why does my custom type have to be an instance of MonadState to be the type of the state container in a StateT, but a list does not?
10:10:25 <eyeris> e.g. using StateT String IO () is fine but using StateT World IO () is not
10:10:34 <eyeris> where World was declared using data
10:11:44 <ac> eyeris: I don't know. I've never used the state monad
10:11:55 <eyeris> Oh, :)
10:15:33 <ac> eyeris: [] is a monad, as you probably know
10:15:54 <adu> [] is my favorite monad
10:16:03 <dons> ?users
10:16:03 <lambdabot> Maximum users seen in #haskell: 454, currently: 412 (90.7%), active: 20 (4.9%)
10:16:09 <glguy> ?yow
10:16:09 <lambdabot> UH-OH!!  I think KEN is OVER-DUE on his R.V. PAYMENTS and HE'S having a
10:16:09 <lambdabot> NERVOUS BREAKDOWN too!!  Ha ha.
10:16:13 <ac> eyeris: as well as a MonadPlus and MonadFix (whatever that is)
10:16:28 <kpreid> eyeris: there is no such restriction inherent in StateT; sounds like you're misusing it somewhere
10:16:36 <kpreid> @src StateT
10:16:36 <lambdabot> Source not found. Take a stress pill and think things over.
10:17:07 <adu> What does "?yow" do?
10:17:10 <kpreid> eyeris: e.g. if you did something equivalent to "join get"
10:17:18 <kpreid> ?help yow
10:17:18 <lambdabot> yow. The zippy man.
10:17:34 <adu> ?yow
10:17:34 <lambdabot> ... I have read the INSTRUCTIONS ...
10:18:13 <hpaste>  eyeris pasted "  60 walk_direction :: String -> World -> StateT World IO ()" at http://hpaste.org/5060
10:18:41 <eyeris> kpreid that paste is the error that I am getting
10:18:47 <eyeris> along with the function it is concerned with
10:20:07 <kpreid> eyeris: okay, that's telling you that (->) World isn't a state monad...
10:20:09 <sjanssen> eyeris: the type signature is wrong
10:20:27 <eyeris> OH!
10:20:28 <kpreid> ah.
10:20:42 <eyeris> Because `world { location = dest' }` has the type (->) World?
10:20:45 <kpreid> No.
10:21:18 <sjanssen> eyeris: the type has a 'World' parameter to that function, but the body of the function doesn't
10:21:18 <kpreid> Your written type signature has a "World -> " which doesn't match the definition.
10:22:58 <eyeris> oh
10:23:02 <kpreid> eyeris: also, I'd rewrite the last do block as do { put world { location = dest' }; world' <- get; liftIO (look world') }
10:23:08 <eyeris> I see
10:23:15 <eyeris> I just forgot to remove that when I refactored this
10:23:28 <kpreid> and I'm pretty sure those "return" shouldn't be there and will be type errors themselves
10:24:09 <eyeris> Yeah, the returns were there to resolve type errors, but I bet they will cause new ones now that the type signature is correct
10:24:14 <kpreid> they would be correct if your monad was StateT World m (IO ()), for some monad m, but they aren't
10:24:21 <hpaste>  aaim pasted "Fast powerset" at http://hpaste.org/5061
10:25:42 <eyeris> kpreid how is that do block different from mine, other than syntactically?
10:25:53 <eyeris> I actually wrote it the way you did at first
10:26:10 <eyeris> then I thought that the get after the put looked unnatural
10:26:13 <kpreid> eyeris: not saving the new world state
10:26:23 <kpreid> it looks unnatural to me to put it and then use it
10:26:36 <eyeris> kpreid ok
10:26:40 <kpreid> actually...
10:26:50 <kpreid> I would rewrite "look" to not take a world parameter
10:26:57 <kpreid> look :: StateT World IO ()
10:27:42 <HairyDude> that looks redundant to me... given that IO is already a "state of the world" monad :)
10:28:16 <eyeris> HairyDude IO = state of the real world, World = state of my game world
10:28:27 <HairyDude> ah I see
10:28:54 <eyeris> kpreid Yeah, I intend to rewrite it that way but I originally wrote look before StateT was used anywhere
10:28:59 * EvilTerran would be tempted to wave around an IORef World, but I guess using StateT World is cleaner from a theoretical standpoint
10:29:04 <eyeris> I'm writing this as a learning exercise
10:29:20 <kpreid> EvilTerran: practically, you'd then have to pass around the IORef
10:29:25 <kpreid> (or use a reader monad)
10:29:31 <kpreid> at which point you don't really gain anything
10:29:44 <EvilTerran> or world = unsafePerformIO newIORef  at toplevel ;)
10:29:54 * kpreid does not admit the existence of that horror.
10:30:33 <EvilTerran> it'd be bad for thread safety, for starters
10:30:45 <EvilTerran> global variables! boo! hiss!
10:31:18 <HairyDude> there's a reason for the 'unsafe' in 'unsafePerformIO' :)
10:31:37 <eyeris> What I really want is a haskell editor with an Intellisense-style feature that illustrates your source code with comic dialog style bubbles showing the types of the functions around the cursor
10:32:02 <eyeris> or at least a cursor hover box that showed the type of the function under the mouse cursor
10:32:31 <eyeris> Maybe that will be my first real haskell program
10:33:33 <Taejo> eyeris: making a text-editor is not easy
10:33:40 <dons> eyeris: that would be a small patch to yi, i think
10:33:41 <EvilTerran> yi!
10:33:47 <EvilTerran> drat, beaten
10:33:58 <dons> and yeah, from experience i can tell you that writing an editor from scratch is a significant investment :)
10:34:02 <desegnis> eyeris, there are such facilites for emacs and perhaps vim, but getting them to work or writing it yourself - choose the easier one :)
10:34:24 <Taejo> does readFile open a file exclusively? (so it can't be read by other threads?)
10:35:15 <dcoutts> Taejo: no, it does many reader one writer locking
10:35:27 <Taejo> ok
10:39:25 <dcoutts> dons: did you see this on reddit, classic:
10:39:26 <dcoutts> http://www.herrmann.eti.br/deadlock.jpg
10:39:39 <dons> :)
10:41:55 <EvilTerran> > 1/0
10:41:58 <lambdabot>  Infinity
10:42:03 <EvilTerran> > -1/0
10:42:04 <lambdabot>  -Infinity
10:42:07 <EvilTerran> hm...
10:42:09 <EvilTerran> > 1/-0
10:42:10 <lambdabot>   Not in scope: `/-'
10:42:11 <EvilTerran> > 1/ -0
10:42:12 <lambdabot>      precedence parsing error
10:42:12 <lambdabot>         cannot mix `(/)' [infixl 7] and prefix ...
10:42:15 <EvilTerran> > 1/(-0)
10:42:15 <lambdabot>  -Infinity
10:42:17 <EvilTerran> hehe.
10:50:31 <BMeph> > 1/(-(-0))
10:50:34 <lambdabot>  Infinity
10:51:12 <Lemmih> > 1/-0
10:51:13 <lambdabot>  -Infinity
10:51:14 <dons> heh, changing the haskell slogan pays off, http://blog.safira.com/2008/01/haskell-impressions-part-i.html
10:51:15 <lambdabot> Title: safira blog: Haskell Impressions, Part I
10:52:37 <Botje> "encourage and enforce" ?
10:52:48 <Botje> sounds like a nice tag for a BDSM movie :)
10:53:21 <dons> we like rigour
10:53:51 <BMeph> "We like the Strong, Static Type" ;)
10:54:23 <lucca> > 0/0
10:54:24 <lambdabot>  NaN
10:54:45 <lucca> but is it a garlic nan?
10:55:15 <lucca> either way, goes well with... curry
10:56:24 <dons> its a cheese NaN
10:57:09 <Vq^> almost everything goes well with curry :)
10:57:09 <hpaste>  glguy pasted "Reversed state" at http://hpaste.org/5063
10:57:14 <mightybyte> dons: Hmmm, slogans are just like politics.  Facts aren't nearly as well received as wonderful-sounding, less substantiated claims. :)
10:57:32 <dons> slogans are first impressions
10:57:39 <dons> and first impressions matter
10:57:56 <mightybyte> Definitely
11:00:27 <mightybyte> dons: But then...when you're right, it doesn't matter if you're slightly less substantiated. ;)
11:01:32 <dons> slogans usually don't include footnotes or citations
11:02:06 <mightybyte> Which linux distro's package system is best integrated with Haskell and keeping up with Cabal and Haskell pacakges?
11:02:34 <wolverian> none, afaik, but maybe gentoo
11:02:36 <dons> hmm, Gentoo or Arch
11:02:43 <dons> both seem to move very quickly.
11:02:51 <dons> Gentoo has the most haskell packages, iirc
11:02:52 <mightybyte> ...the source distros I guess.
11:03:01 <wolverian> right. :)
11:03:14 <wolverian> though that doesn't really imply anything
11:05:17 <Big_Red> what's the null statement called in haskell?
11:05:26 <Big_Red> empty string
11:05:27 <Big_Red> thingy
11:05:49 <byorgey> Big_Red: what do you mean?
11:05:53 <Dybber> []? ""? Nothing?
11:06:07 <Dybber> nil?
11:06:14 <kpreid> Big_Red: you'll have to be more specific about the context.
11:06:19 <Big_Red> well hugs didn't recognise nil...
11:06:24 <kpreid> perhaps you'd like "return ()", but who knows
11:06:33 <Big_Red> i'm reading through a paper on functional programming in pseudocode
11:06:39 <dons> return () is the "null" action
11:06:39 <kpreid> we need to know what kind of hole you need to fill
11:06:45 <byorgey> Big_Red: what paper?
11:06:48 <Big_Red> and in it the examples have nil
11:06:53 <Big_Red> why functional programming
11:06:59 <byorgey> Big_Red: hm, is it talking about lists?
11:07:07 <byorgey> in that case it would be []
11:07:40 <Big_Red> eg: (reduce f x) nil = x
11:08:07 <byorgey> Big_Red: what page?
11:08:07 <Dybber> nil is the empty list in haskell that is []
11:08:14 <Big_Red> 5
11:08:40 <byorgey> ah, ok.  In haskell that would be:
11:08:42 <dons> > null []
11:08:44 <lambdabot>  True
11:08:52 <byorgey> reduce f x [] = x
11:09:13 <byorgey> reduce f x (a:l) = f a ((reduce f x) l)
11:09:31 <Big_Red> byorgey: thanks
11:09:56 <byorgey> Big_Red: in the haskell standard libraries, this function is called foldr
11:10:43 <Big_Red> foldr? hmmm I remembered that cons was essentially (:) - and foldr applies a function to every part of a list?
11:11:24 <byorgey> Big_Red: (foldr f z) essentially replaces every cons with f, and the empty list at the end with z
11:11:44 <byorgey> so foldr f z (a:b:c:[]) is f a (f b (f c z))
11:12:15 <monochrom> @src foldr
11:12:16 <lambdabot> foldr k z xs = go xs
11:12:16 <lambdabot>     where go []     = z
11:12:16 <lambdabot>           go (y:ys) = y `k` go ys
11:12:26 <Big_Red> would that mean that foldr takes three arguments: f, z and the list?
11:12:36 <mauke> yes
11:12:37 <idnar> @type foldr
11:12:39 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:12:45 <monochrom> foldr = reduce
11:12:54 <Big_Red> :)
11:13:06 * Big_Red adds to mental list of commands
11:15:46 * byorgey wonders if it would be worthwhile to make a "translation" of Why FP into Haskell
11:16:29 <Tac-Tics> @where why fp
11:16:29 <lambdabot> I know nothing about why.
11:16:37 <cjb> byorgey: I was thinking about that recently; yes, absolutely.
11:16:44 <cjb> and to LaTeX-ise the ascii art.
11:16:50 * HairyDude learns some more things about monad transformers.
11:17:18 <HairyDude> it seems there are a lot of instances that can in principle be defined for any monad transformer, but that have to be done in a different way for each. Which is annoying.
11:17:23 <byorgey> cjb: indeed.
11:19:19 <MyCatVerbs> @where whyfp
11:19:19 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
11:20:13 <MyCatVerbs> @quote dons
11:20:13 <lambdabot> dons says: disable the type checker in ghc for 6 months and we'd have 5 debuggers at the end of it :)
11:20:27 <MyCatVerbs> Heheheheh.
11:20:32 <MyCatVerbs> @quota lambdabot
11:20:32 <lambdabot> lambdabot says: Done.
11:20:39 <Tac-Tics> heh
11:20:42 <Tac-Tics> @quote lambdabot
11:20:43 <lambdabot> lambdabot says: Done.
11:20:45 <mauke> @quote
11:20:47 <lambdabot> spiffy says: [spiffy] ?quote spiffy [lambdabot] spiffy hasn't said anything memorable [spiffy] excellent
11:20:47 <Tac-Tics> aw
11:20:58 <MyCatVerbs> @quote
11:20:59 <lambdabot> bootslack says: Once, around the time of the discovery of fire, there was a large population of people that thought mastering fire would be too difficult so they didn't. The rest of us killed them,
11:20:59 <lambdabot> cooked them and ate them.
11:21:07 * MyCatVerbs is abusing this and will now stop.
11:21:33 <byorgey> @quote MyCatVerbs
11:21:35 <lambdabot> MyCatVerbs says: [talking about #haskell] seriously, it's like the entire planet got mutant powers and many all the people here just happened to get Psychic MegaHelpFulness.
11:21:41 <resiak> @quote abusing
11:21:42 <lambdabot> audreyt says: yes, I'm aware that I'm abusing GHC beyond its designed purpose
11:22:15 * HairyDude finds himself writing a class with a method that is almost, but not quite like (>>=)
11:22:17 <Big> if i'm defining a function with 3 arguments do i always have to specify the 3 arguments
11:22:21 <Big> for example
11:22:50 <Tac-Tics> Big: if you don't apply all 3, you get back a function looking for the remaining arguments
11:22:55 <MyCatVerbs> That's not fair. GHC's designed purpose is *everything*.
11:23:12 <HairyDude> MyCatVerbs: I'll bet you can't do your washing up in GHC.
11:23:13 <Big> func1 = func2 func3  when func1 a b c = blah
11:23:23 <Big> #nick Big_Red
11:23:33 <gwern> where are the haskell channel logs?
11:23:35 <Big> and i've forgotten how to change my nickname :'(
11:23:39 <HairyDude> Big: /nick
11:23:41 <mauke> @where logs
11:23:42 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
11:23:53 <gwern> thanx
11:24:07 <Tac-Tics> Big, if you have some code you need help with, you could toss it on hpaste
11:24:12 <Tac-Tics> @paste
11:24:13 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:24:25 <byorgey> Big: you can't mix the number of arguments.  all definitions for a particular function must have the same number of arguments.
11:24:43 <byorgey> e.g. you can't have f 0 1 = foo ; f n = blah
11:25:29 <Big> hmmm thanks
11:25:33 <byorgey> but the arguments don't all have to be specified.  for example, sum = foldr (+) 0  is the same as sum xs = foldr (+) 0 xs
11:25:56 <Tac-Tics> > foldr (+) 0
11:26:01 <lambdabot>  <[Integer] -> Integer>
11:26:02 <Big_Red> ahh
11:26:02 <Tac-Tics> > foldr (+)
11:26:04 <lambdabot>  <Integer -> [Integer] -> Integer>
11:26:06 <Tac-Tics> > foldr
11:26:07 <lambdabot>  Add a type signature
11:26:19 <Tac-Tics> @t foldr
11:26:19 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:26:28 <Tac-Tics> er
11:26:29 <Tac-Tics> @type foldr
11:26:29 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:26:38 <Tac-Tics> @type foldr (+)
11:26:39 <lambdabot> forall a. (Num a) => a -> [a] -> a
11:26:47 <Tac-Tics> @type foldr (+) 0
11:26:48 <lambdabot> forall a. (Num a) => [a] -> a
11:26:54 <HairyDude> aha
11:27:00 <nomeata> liyang: hi. do you feel like doing the gtk2hs upload, or do you want me to do it?
11:27:02 <Tac-Tics> (every time you apply an argument, the result is something with a simpler type
11:27:04 <Big_Red> so i don't have to specify the arguments
11:27:06 * HairyDude figures out how to do it for arbitrary monad transformers.
11:27:19 <Tac-Tics> @type foldr (+) 0 [1,2,3]
11:27:20 <lambdabot> forall a. (Num a) => a
11:27:30 <Tac-Tics> (once you apply all the arguments, you're left with a non-function value)
11:27:31 <byorgey> Big_Red: right.
11:28:01 <HairyDude> actually... hmm
11:28:08 <HairyDude> instance (MonadTrans t, MonadNondet m, Monad (t m)) =>
11:28:08 <HairyDude>         MonadNondet (t m) where
11:28:08 <HairyDude>     choose = choose
11:28:22 <HairyDude> will that do what I expect, or does choose = _|_ ?
11:28:46 <Big_Red> when SHOULD i specify type
11:28:52 <Tac-Tics> What are you expecting it to do? (it looks like it should bottom)
11:28:52 <HairyDude> wait... no, that's rubbish
11:29:13 <HairyDude> yes, it is _|_
11:29:14 <Big_Red> since i can write a set of functions without specifying type at all and it seems to do it automatically
11:29:22 <byorgey> HairyDude: you can use choose on the RHS and depending on the type, it will pick the right one.  but choose = choose doesn't make sense =)
11:29:27 <Tac-Tics> Big_Red: You should specify types at the top level when you're writing public code, but if you're just dinking around, you don't need to add them unless it helps you understand better
11:29:59 <Big_Red> so its good practice but not necessary
11:30:05 <byorgey> Big_Red: my recommendation is to ALWAYS write them. =)
11:30:17 <Tac-Tics> yeah, it's just there so when you go back to it after a month, you know what to pass to it
11:30:22 <byorgey> Big_Red: that's right. there are some cases where it is necessary, but those are more advanced
11:30:32 <Big_Red> at what point will the compiler start complaining that i haven't specified it or will it always take implied type
11:30:40 <Tac-Tics> Adding the type is like documentation that isn't allowed to lie to you
11:31:05 <byorgey> @remember Tac-Tics Adding the type is like documentation that isn't allowed to lie to you
11:31:05 <lambdabot> Good to know.
11:31:10 <Big_Red> having grown up with c where you ALWAYS type EVERYTHING
11:31:12 <Tac-Tics> The only time you need to specify it is, I believe, when you run into this silly thing called the Monomorphism Restriction
11:31:23 <mauke> Big_Red: type declarations are (almost) completely optional
11:31:39 <byorgey> Tac-Tics: there are other situations, but that's the one you're most likely to run into first.
11:32:11 <Big_Red> does monomorphism fall into the catagory of "if you've not heard of it you're not using it" or "its a fancy name we came up with for what you're doing right now"
11:32:16 <Tac-Tics> byorgey, what other ones are there? that's the only situation I know
11:32:38 <byorgey> Big_Red: the reason I recommend always writing type signatures (*before* you write the actual code) is that writing down the type is actually very helpful in figuring out how to write the code itself.
11:32:56 <Big_Red> byorgey: aye i've found that too
11:33:01 <byorgey> Big_Red: if you don't know what the type is supposed to be, it's very unlikely that you'll be able to write the code.
11:33:45 <mauke> :t 42
11:33:45 <Tac-Tics> Big_Red: The latter. It has to do with when type variables get filled in... for example, for length :: [a] -> Int.... when does length turn into [String] -> Int or [Int] -> Int?
11:33:46 <byorgey> Big_Red: another reason is that if you make a mistake, if there are type signatures you get much better/helpful error messages.
11:33:50 <lambdabot> forall t. (Num t) => t
11:34:08 <Tac-Tics> :t length
11:34:09 <lambdabot> forall a. [a] -> Int
11:34:12 <mauke> 42 has a polymorphic type. but if you write 'foo = 42' in a program, you'll find that it has the type Integer
11:34:15 <Tac-Tics> :t length :: [Int] -> Int
11:34:16 <lambdabot> [Int] -> Int
11:34:39 <byorgey> Tac-Tics: off the top of my head I'm not sure, but there are various language extensions which can make type inference undecidable
11:34:47 <Tac-Tics> ah, ok
11:34:51 <byorgey> Tac-Tics: so in those cases the compiler needs annotations to help it out
11:35:02 <Tac-Tics> yeah
11:35:04 <mauke> polymorphic recursion needs explicit types IIRC
11:35:16 <byorgey> ah, yes, that's one
11:35:18 <mauke> and that's not even an extension
11:35:24 <byorgey> good point =)
11:35:40 <Big_Red> IIRC?
11:35:42 <Tac-Tics> so like, data Tree a = Leaf a | Branch (Tree a) (Tree a)
11:35:47 <Tac-Tics> If I recall correctly
11:35:51 <Tac-Tics> = IIRC
11:35:57 <Big_Red> ah
11:36:27 <byorgey> Big_Red: the monomorphism restriction can apply sometimes when you define a function without specifying any of its arguments
11:36:35 <byorgey> like sum = foldr (+) 0
11:37:03 <mauke> > let foo n x | n <= 0 = show x | otherwise = foo (n - 1) (x, x) in  [foo 2 'x', foo 5 'x']
11:37:05 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, a)
11:37:06 <lambdabot>       Expec...
11:37:15 <Tac-Tics> The monomorphism restriction's motto is "Add the Types and there won't be gripes."
11:37:24 <mauke> > let foo :: (Show a) => Int -> a -> String; foo n x | n <= 0 = show x | otherwise = foo (n - 1) (x, x) in  [foo 2 'x', foo 5 'x']
11:37:25 <byorgey> the monomorphism restriction says such things are not allowed to be polymorphic (for possible performance reasons), which sometimes isn't what you want
11:37:26 <lambdabot>  ["(('x','x'),('x','x'))","((((('x','x'),('x','x')),(('x','x'),('x','x'))),((...
11:37:54 <byorgey> so you can either add a parameter -- sum xs = foldr (+) 0 xs -- or give an explicit type annotation for sum :: (Num a) => [a] -> a
11:38:12 <byorgey> Big_Red: if you're using type annotations you don't have to worry about the monomorphism restriction at all.
11:38:14 <ehird> "Indeed, it is possible to write coerce :: a -> b with the help of unsafePerformIO. So be careful!" i must see how!
11:38:18 <ehird> source code anywhere? :D
11:38:53 <taruti> use a polymorphic IORef.
11:39:00 <ehird> yep
11:39:01 <Tac-Tics> http://haskell.org/ghc/docs/latest/html/libraries/base/Unsafe-Coerce.html#v%3AunsafeCoerce
11:39:05 <lambdabot> http://tinyurl.com/ywc6yv
11:39:09 <ehird> but i'm just getting segfaults, in my ridiculous attempts
11:39:22 <Tac-Tics> What are you trying to do with it?
11:39:24 <mauke> ehird: yes, that's what unsafeCoerce does
11:39:26 <Big_Red> so polymorphism is when it could be from lots of types to one type
11:39:37 <Big_Red> and monomorphism is where you specify which type it starts from?
11:40:11 <Philippa> when you're talking about parametric polymorphism that's a good model, yeah
11:40:22 <Big_Red> parametric?
11:40:54 <Tac-Tics> You don't really need to know the exact details of the monomorphism restriction, but when you see the words, you should know how to fix it (with a type annotation)
11:40:59 <Philippa> the canonical explicitly-typed language for parametric polymorphism actually has type lambdas and you apply types to expressions with polytypes to get monotypes (or at least less polymorphic types, as you can nest polymorphism rather more than in haskell)
11:41:14 <ehird> @src unsafeCoerce
11:41:14 <lambdabot> Source not found. You speak an infinite deal of nothing
11:41:16 <Philippa> parametric polymorphism ~= "the type variables are parameters"
11:41:17 <ehird> :(
11:41:29 <ehird> they're all done in core stuff
11:41:32 <Philippa> as opposed to the kind of polymorphism you see in OO programming (usually "subtype polymorphism") for example
11:41:35 <ehird> no actual sourcecode using unsafePerformIO
11:41:45 <Philippa> or ad hoc polymorphism which is more or less uncontrolled overloading
11:42:16 <Big_Red> :|
11:42:32 <Big_Red> lets start with overloading
11:42:41 <Philippa> overloading is when an identifier can mean more than one thing
11:42:46 <Big_Red> and what's "canonical"
11:42:47 <Philippa> + in maths is highly overloaded, for example
11:43:10 <CosmicRay> Gwern-away: so have I finally uploaded everything you want me to? ;-)
11:43:13 <Big_Red> and when does + mean anything other than +?
11:43:23 <Philippa> "canonical" ~= "the standard"
11:43:35 <Philippa> would that be integer, float, real, vector or matrix addition?
11:43:41 <Big_Red> ah :)
11:43:51 <Philippa> or, for that matter, string concatenation?
11:43:59 <mauke> I'd like to do addition in an abelian group
11:44:05 <mauke> Big_Red: http://www.catb.org/~esr/jargon/html/C/canonical.html
11:44:07 <Big_Red> brb
11:44:09 <lambdabot> Title: canonical
11:44:35 <ehird> Philippa: + as string concatentation is wrong
11:44:38 <Philippa> historically it came from the religious notion of "canon", which has since slid into somewhat generalised popular usage
11:44:41 <ehird> since + should always be associative and precedence-ignoring
11:44:58 <Philippa> ehird: don't look at me, it's still something that happens in many languages and feels "natural" to many people
11:45:03 <mauke> yes, clearly * should be used for concatenation
11:45:12 <ehird> mauke: har de har
11:45:21 <ehird> actually i don't even like ++
11:45:21 <ehird> :-)
11:45:27 <mauke> Perl uses .
11:45:39 <Gwern-away> CosmicRay: I think so. I still need to find why some packages break on cabal install, but they at least seem uploaded
11:45:47 <ehird> mauke: function composition isn't that far off concentation i guess ;)
11:45:50 <ehird> ... if this is Forth ...
11:45:51 <Philippa> (+) (read the parens as a circle) is usually used for monoidal operations, isn't it?
11:45:57 <ehird> Philippa: exactly
11:46:16 <Philippa> anyway, I think we may be confusing Big_Red
11:46:29 * Philippa does the /whois
11:46:32 <Philippa> ah, thought so
11:46:37 <Philippa> yeah, I shouldn't expect you to get all that jargon
11:46:50 <Philippa> OTOH, if you PM me a house number I can explain stuff in person for a while - got nothing better to do tonight
11:47:13 <Big_Red> OTOH?
11:47:19 <Tac-Tics> on the other hand
11:47:29 <Big_Red> ah :)
11:47:44 <Tac-Tics> (didn't someone mention an Urban Dictionary plugin for lambdabot a few days ago?)
11:48:01 <Big_Red> well my housemate dosed me up with a vast amount of coffee and i remembered that i needed to get up to "basically competent" with haskell for tuesday :Z
11:48:40 <Tac-Tics> Big_Red: What are you going to be using Haskell for?
11:48:50 <Big_Red> hehe
11:48:52 <Big_Red> learning haskell
11:49:07 <mauke> ELOOP
11:49:07 <Big_Red> i enrolled in "advanced functional programming" without doing "functional programming"
11:49:10 <Tac-Tics> Bootstrapped learning
11:49:30 <Philippa> Big_Red: oops? :-)
11:49:43 <mauke> in my experience, "functional programming" is a lot easier if you already know "advanced function programming"
11:49:46 <shachaf> "+" is also sometimes used for adding functions (as in liftM2 (+)).
11:50:23 <Big_Red> well i spoke to Prof Hutton and he said "read my book, try doing this, then you'll pretty much know all you need to know to start off with"
11:50:25 <dons> mauke: that's interesting. i'd agree :)
11:51:05 <Big_Red> and i swear the more caffine i have/xkcd i read the more i think i should have done comp sci instead of engineering but meh
11:51:18 <Lemmih> Is it just me or is there too much chatter on haskell@ ?
11:52:18 <monochrom> It's dying down now.
11:52:44 <dons> Lemmih: there was one noisy thread, iirc
11:53:01 <Big_Red> what would "." be in haskell where (f . a) b = f (a b)
11:53:11 <sjanssen> Big_Red: .
11:53:11 <EvilTerran> ?src (.)
11:53:12 <lambdabot> (.) f g x = f (g x)
11:53:21 <Big_Red> ah excellent!
11:53:26 <Tac-Tics> (f . g) x = f (g x)
11:53:26 <EvilTerran> ?docs Prelude
11:53:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
11:53:40 <EvilTerran> ah, good, ?docs has been fixed
11:54:25 <monochrom> I did compsci and math and some engineering. I enjoyed all of them. I enjoyed compsci most, but I appreciate I had some engineering too.
11:58:37 <Big_Red> is there a haskell function for map where map f = foldr ((:) . f) []
11:58:59 <mauke> :t map
11:59:00 <monochrom> Yes. It's called map.
11:59:00 <dons> look like concatMap
11:59:02 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
11:59:26 <dcoutts> @type \f -> foldr ((:) . f) []
11:59:26 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
11:59:27 <dons> ah, sorry, wrong constructor
11:59:28 <dons> concatMap f             =  foldr ((++) . f) []
11:59:57 <dcoutts> that is just map
12:00:05 <dcoutts> id = foldr (:) []
12:00:18 <dcoutts> map = foldr ((:) . f) []
12:00:28 <sjanssen> foldr++
12:00:29 <monochrom> Big_Red is now asking questions in point-free form. This is way ahead of most people! :)
12:00:40 <dons> Big_Red: good sign :)
12:01:28 <sjanssen> I like the similarity between "foldr ((:) . f)" and "foldr ((++) . f)" it nicely demonstrates how they're similar
12:01:53 <dons> yeah, and foldr (:) []
12:01:56 <dons> all rather lovely
12:02:04 <sjanssen> @karma foldr
12:02:05 <lambdabot> foldr has a karma of 1
12:02:17 <Tac-Tics> foldr++
12:02:19 <monochrom> @quote catamorphism
12:02:19 <lambdabot> syntaxfree says: <Bourbaki> the best thing i have ever read in economy is a statement of some guy "i have never met the homo oeconomicus" <syntaxfree> I have never met a catamorphism, either.
12:02:40 <monochrom> @quote ratamorphism
12:02:40 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
12:02:50 <EvilTerran> Big_Red, did you see that docs link i posted?
12:03:06 <EvilTerran> i found it very useful when starting out to have the prelude docs handy at all times
12:03:29 <EvilTerran> "this looks like a pretty common want -- i'll go see if it's in the prelude <alt-tab> hey, look, it is!"
12:05:07 <EvilTerran> hm... is (mempty,mappend) = (return (), (>=>)) a monoid?
12:05:27 <dons> hey guys, the oscon call for tutorials has gone out. anyone interested in seeing/doing a tutorial?
12:05:44 <EvilTerran> er, I mean (return (), (>>)).
12:05:59 <dons> maybe i could do one. we could get alexj to do one on happs. what else?
12:06:40 <dons> dcoutts: btw, there's going to be "developer tutorials" at icfp this year.
12:06:43 * EvilTerran vaguely remembers someone defining "monad" as "monoidal applicative functor" - i get the last two, but i'm not sure if that's what they meant by "monoidal"
12:06:48 <Tac-Tics> > [1,2,3] >> [4,5,6]
12:06:49 <lambdabot>  [4,5,6,4,5,6,4,5,6]
12:06:56 <dcoutts> dons: interesting
12:06:56 <litb> hello all
12:07:02 <hpaste>  litb pasted "what's wrong?" at http://hpaste.org/5064
12:07:07 <litb> can anyone help me?
12:07:15 <litb> it says:
12:07:27 <litb> "/home/js/haskell/wnm.hs:31:6: parse error on input `Loesung'"
12:07:34 <dons> dcoutts: i'm helping organise, being a "local". we should have something like 5 tut slots. might be good to think about what haskell devs want to see.
12:07:34 <Tac-Tics> Loesung needs to be lower case
12:07:39 <EvilTerran> litb, record fields start lowercase
12:07:39 <Tac-Tics> as does Schritte
12:07:41 <litb> ah, damn
12:07:50 <litb> i've just seen it
12:07:55 <dcoutts> dons: icfp will be in Portland will it?
12:07:56 <EvilTerran> as they involve a function of the same name
12:07:58 <moonlite> > [1..3] >>= [4..6]
12:07:58 <lambdabot>  Couldn't match expected type `t -> [b]' against inferred type `[a]'
12:08:05 <moonlite> :)
12:08:10 <idnar> nothing like asking for help on IRC to make you solve your own problem ;)
12:08:14 <dons> dcoutts: well, vancouver, bc, in canada. close enough :)
12:08:27 <dons> oscon is in portland before then, also.
12:08:35 <dons> and they have dev tutorials. we should do some haskell ones.
12:08:40 <Tac-Tics> > [1..3] >>= const "banana"
12:08:41 <lambdabot>  "bananabananabanana"
12:08:42 <byorgey> EvilTerran: yes, monad laws === (return (), (>>)) is a monoid
12:08:43 <dcoutts> dons: right. Yes, a couple haskell tutorials perhaps. No immediate ideas spring to mind.
12:08:46 <dons> i see no reason why python, perl and ruby get all the open source fun
12:09:03 <dons> happs, parallel programming, type safe programming, ...
12:09:13 <EvilTerran> byorgey, or even (return mempty, (>>))?
12:09:34 <EvilTerran> (trying to generalise a bit more here =])
12:09:37 <dons> building gui apps with gtk2hs :)
12:09:45 <dons> parsing with parser combinators
12:10:29 <dons> there's lots of cool things we can do better than the competition. we should talk about it to more than just icfp attendees. oscon is an obvious venue. and o'reilly supports haskell these days :)
12:10:59 <dons> bos: any thoughts on whether/what/how many oscon haskell tuts we should try to do? :)
12:11:05 <dcoutts> dons: oscon is too far for me, the european one is ok though :-)
12:11:18 <EvilTerran> dons, yeah, but if you can write a syntactically correct program in some scripting language, it tends to (seem to) work
12:11:22 <dons> yeah. that's fair enough. the us developer communmity is so huge though, we need to get a foot in.
12:11:25 <dcoutts> dons: and as you know, I'm a bit short on time to prepare any gtk2hs stuff
12:11:26 <EvilTerran> i guess people like that ;)
12:11:35 <byorgey> EvilTerran: well, sure, but the mempty has no import.  it could be anything at all if you're using >>.
12:11:42 <dons> EvilTerran: seems to work /= does work
12:11:54 <EvilTerran> dons, i know that very well ;)
12:12:04 <dons> EvilTerran: but yes, that's the "dynamic typing fallacy"
12:12:09 <dons> "it seems to work"
12:12:23 <dons> since i never executed that code path that is all wrong
12:12:35 <monochrom> "syntactically correct program seems to work" is a property of all high-level-enough languages. All of them.
12:12:52 <EvilTerran> given that it's a fallacy with a proper name and everything, i guess it's one many people subscribe to, then, dons
12:13:07 <dons> monochrom: what do you think? should we do some oscon tuts?
12:13:08 <CosmicRay> bos: sweet news on the llvm stuff.  I was at the llvm talk at OSCon last year and was hoping someone would do this.  are you using ghc at all with it?
12:13:13 <Tac-Tics> monochrom: %s/high-level-enough/strongly-typed-enough/g
12:13:16 <EvilTerran> i don't support this position myself, you understand, merely trying to explain how other people think
12:13:27 <dons> CosmicRay: what do you think, btw, more haskell tuts at oscon this year?
12:13:30 <nomeata> Hi. I have a problem building gtk2hs-0.9.12.1:
12:13:37 <nomeata> <no location info>: can't find file: glib/System/Glib/Types.hs
12:13:48 <nomeata> glib/System/Glib.hs:12:0:
12:13:48 <nomeata>     Failed to load interface for `System.Glib.UTFString':
12:13:52 <nomeata> Any ideas?
12:13:55 <dcoutts> nomeata: it gets generated, so it must have failed to build
12:13:58 <EvilTerran> monochrom, "all my syntax is right, but there's this horrible type error I don't understand! sod this, i'm going back to perl"
12:14:07 <dcoutts> nomeata: try to make that file and see what the error is
12:14:10 <CosmicRay> dons: that would be great.  especially if spj did one.  he is an awesome public speaker
12:14:32 <nomeata> thx. but why does the build then not faile at that point? I get: cc1: error: unrecognized command line option "-fno-toplevel-reorder"
12:14:35 <dons> i'd like to see some practical stuff. not just 'here's some new language features'.
12:14:50 <dons> i.e. building web apps in haskell, or writing parallel multicore code in haskell
12:14:51 <dcoutts> nomeata: oh, that's bad, your ghc and gcc are incompatible
12:15:14 <CosmicRay> yeah.  he did a talk last year around xmonad, which was more along those lines
12:15:22 <byorgey> ewwww
12:15:25 <dcoutts> nomeata: your ghc was configured for gcc-4.1 or later but you're probably using an earlier version, what gcc version are you using?
12:15:32 <nomeata> dcoutts: gcc version 4.2.3 20080114 (prerelease) (Debian 4.2.2-7)
12:15:33 <byorgey> mischan, sorry =P
12:15:36 <dons> yeah. it was more an intro to haskell, though. we can build on that now.
12:15:40 <CosmicRay> true
12:15:46 <dcoutts> nomeata: oh, then perhaps they've removed that flag now
12:16:14 <dons> the haskell community doesn't have to be the funny outsider of the open source community
12:16:25 <dcoutts> nomeata: check your $ghclibdir/extra-gcc-opts file
12:16:26 <nomeata> dcoutts: so its actually a ghc bug?
12:16:37 <CosmicRay> dons: I'd volunteer but I'm not a good enough public speaker for oscon, I don't believe
12:16:48 <middayc> CosmicRay -- can I ask..are you S.P.J?
12:16:57 <monochrom> Do a QuickCheck, SmallCheck, ... tutorial.
12:16:58 <nomeata> dcoutts:  -fwrapv -mno-omit-leaf-frame-pointer -fno-toplevel-reorder
12:17:02 <CosmicRay> middayc: no, I'm John Goerzen, but thanks ;-)
12:17:05 <dons> :)
12:17:06 <mattam> roconnor: ping
12:17:10 <dcoutts> nomeata: ok, edit it and try again.
12:17:29 <dons> 'agile development in haskell' :)
12:17:58 <dcoutts> nomeata: so do file a ghc bug. I expect it's because the option has been removed in gcc and ghc has not caught up yet, since ghc devs generally only test with released gcc.
12:17:59 <dons> (i gave a talk along those lines at pdxfunc last month, showing how to rapidly build software from smaller pieces using types, ghci, and composition)
12:18:54 <_piranha_> Hi all. Guys, is there any way to determine where is my problem - I have compiled ghc 6.8 from package in ubuntu 7.10 (package was taken from ubuntu 8.04 beta - where it was taken from debian testing), installed it and when I'm trying to compile yi, it says that I need regex-{base,compat,posix}. In debian this is virtual packages, provided by ghc6. What I can do? I looked in ghc6 source directory and found that there are no regex-* directory in librarie
12:18:55 <_piranha_> s/. Is this the problem or what?
12:19:19 <middayc> ((I thought because you said you talked about xmonad.. and I just watched video yesterday (from OSCON)))
12:19:32 <CosmicRay> _piranha_: apt-cache search libghc6-regex  it will be something like libghc6-regex-dev
12:19:37 <zeloran> i need soem help with record types
12:19:39 <CosmicRay> middayc: nono, I said that Simon talked about xmonad
12:19:43 <CosmicRay> or at least meant to
12:19:43 <_piranha_> CosmicRay: aha, and this is virtual package
12:19:49 <RayNbow> hmm
12:19:53 <RayNbow> @src foldl'
12:19:54 <lambdabot> foldl' f a []     = a
12:19:54 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:20:02 <zeloran> how to extract an element of an record type?
12:20:22 <CosmicRay> middayc: I loved the "oh look, a whiteboard has appeared, as if by magic!" moment ;-)
12:20:23 <EvilTerran> zeloran, your field names are also functions
12:20:55 <CosmicRay> middayc: I actually didn't attend that tutorial, thinking "hey, I already know Haskell."  I had no idea how interesting SPJ was and would have gone had I known.
12:21:01 <CosmicRay> middayc: but I did watch it on video later
12:21:10 <CosmicRay> it was funny watching the irc channel from the guys that were in there
12:21:35 <CosmicRay> one would be saying something like "so that list is infinite but it's fine because it never has to be evaluated!  this is great!"  and the next one would be "my brain hurts"
12:21:46 <monochrom> unsafeWhiteBoardMagic
12:21:46 <dons> heh
12:21:47 <nomeata> dcoutts: ok, editing this file helps
12:22:17 <middayc> can I ask one question while I started typing.. if I would like to learn haskell by doing a practical example .. what would you suggest I start .. I have 3 options .. using HopenGL and making small game, wxWindows and making a simple desktop app or XY and making a web-app? Or is haskell better to start with theory first?
12:22:38 <CosmicRay> how about starting with a console app or a filter?
12:22:39 <dons> no, practice is always best.
12:22:50 <dons> a console app is usually a better start, than a gui app.
12:22:51 <CosmicRay> get some real I/O going but leave out the big GUI or CGI toolkits while you learn
12:22:51 <_piranha_> start with yi compilation :D
12:22:55 <middayc> aha ... which case would be most suited for haskell?
12:22:55 <dons> since gui stuff involves learning some gui library first
12:23:09 <dons> middayc: maybe implement some unix tools ? or an irc bot?
12:23:16 <Tac-Tics> _piranha_: I totally know your pain there. I fought with Yi for days without any luck
12:23:19 <CosmicRay> middayc: write a grep in haskell
12:23:29 <_piranha_> Tac-Tics: ;-)
12:23:38 <daf> CosmicRay: mm, that's a nice size
12:23:38 <dons> middayc: http://haskell.org/haskellwiki/Simple_Unix_tools
12:23:39 <Tac-Tics> I would think that out of those three, Graphics are the best option. Haskell is fast and graphics are founded on rigidly defined mathematics
12:23:42 <EvilTerran> middayc, i find project euler to be a good source of problems to familiarise yourself with haskell on
12:23:59 <dons> http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
12:24:01 <_piranha_> +1 for project euler
12:24:05 <dons> project euler is a good one too
12:24:05 <middayc> I have used openGL and wxPythong and wxLua so that would not be a problem ,, and am a web dev so third would also not be.. but I have used imperatives until now
12:24:15 <dons> middayc: ah ok. that's interesting.
12:24:31 <Tac-Tics> I couldn't bear to think about NOT doing Project Euler in Haskell
12:24:34 <nomeata> dcoutts: but still, shoudnât your makefile abort on such an error?
12:24:39 <dons> web dev is easy enough. use xhtml to generate static pages, then try something like fastcgi
12:24:56 <dons> middayc: there's a few nice opengl games in haskell,
12:25:00 <dcoutts> nomeata: yeah, I don't know why it doesn't :-(
12:25:09 * dcoutts hates makefiles
12:25:23 <dons> middayc: some opengl games, http://haskell.org/haskellwiki/Applications_and_libraries/Games
12:25:25 <middayc> I played 2 monadious and shu-thing until now
12:26:23 <middayc> yes the haskell + opengl seems maybe the most interesting option ... but other two would be more practical
12:26:34 * byorgey is waiting for someone to make a nice make-like dependency DSL in Haskell
12:26:44 <middayc> aha thanks for the link
12:27:20 <BMeph> Yeah, unless you dream in J or Maple, Haskell is "FTW" for doing Project Euler problems.
12:27:37 <EvilTerran> hey, dcoutts -- I was talking to Oege yesterday about projects and research and whatnot
12:27:47 <middayc> Project Euler.. that is that thing about math rright?
12:27:54 <byorgey> middayc: yup
12:27:59 <zeloran> when i have an object of this type       newtype MParser sym a = P {apply :: Parser sym a}...how do it the the "inner" "type" Parser?
12:28:00 <byorgey> @where project euler
12:28:00 <lambdabot> I know nothing about project.
12:28:02 <EvilTerran> he mentioned this thing called "Just Add" or something - know anything about that?
12:28:07 <byorgey> @where projecteuler
12:28:07 <EvilTerran> @go project euler
12:28:07 <lambdabot> http://projecteuler.net/
12:28:08 <lambdabot> http://projecteuler.net/
12:28:08 <lambdabot> Title: Project Euler
12:28:22 <middayc> wow, you have a nice bot
12:28:28 <EvilTerran> @thanks
12:28:28 <lambdabot> you are welcome
12:28:31 <dcoutts> EvilTerran: yes?
12:28:37 <byorgey> EvilTerran: that is a value of type Maybe Operation, of course ;)
12:28:37 <middayc> :)
12:28:47 <dcoutts> EvilTerran: Just Add. Hmm, no never heard of it.
12:30:00 <monochrom> I started with "theory" first, i.e., toy examples, "irrelevant" functions. It was crucial in unlearning imperative thinking. To unlearn a thinking mode, you need replace it by another thinking mode, aka "theory".
12:30:02 <phlpp> byorgey: off topic: how's your go club doing?
12:30:03 <nomeata> Igloo: I
12:30:03 <EvilTerran> he said it was to do with building a development environment from a formal specification of the language you were working on
12:30:15 <EvilTerran> thought you might have a link for it or whatever
12:30:17 <nomeata> Igloo: Iâm currently working on some new gtk2hs packages, if you donât mind :-)
12:30:19 <nomeata> eh, sorry
12:30:46 <dcoutts> EvilTerran: nope, sorry
12:30:47 <dons> middayc: a gtk-based go gui would be nice
12:31:04 <nomeata> that should have gone to Liyang
12:31:09 <middayc> I have done a little unlearning of imperators via ocaml
12:31:09 <dcoutts> dons: JaffaCake already wrote one
12:31:17 <EvilTerran> dcoutts, oh, okay. sorry to bother you.
12:31:26 <dons> so i hear. i've not seen it on hackage, though, so it doesn't exist
12:31:27 <middayc> ok ... thanks for replies .. I will look around some more and decide
12:31:33 <byorgey> phlpp: which go club is that?
12:31:39 <dcoutts> EvilTerran: np :-) I've got other project suggestions if you're interested :-)
12:32:15 <phlpp> byorgey: hmm, i remeber that i read sth. about a go club in your go blog, eh?
12:32:18 <monochrom> There is more unlearning because haskell is the first lazy language you meet.
12:32:27 <EvilTerran> sure =] i was thinking of trying to get work hacking on something at the lab over the summer
12:32:45 <phlpp> byorgey: but there seem's to be no year in the dates, thus i don't know if this is kinda old stuff i'm talking about :D
12:32:47 <byorgey> phlpp: oh! yes, that's from when I was teaching high school, a couple of years ago now
12:32:55 <phlpp> oh :D
12:33:13 <monochrom> ocaml tells you "map f xs is bad because it takes O(n) space". haskell tells you "map f xs is good because it takes O(1) space".
12:33:25 <byorgey> phlpp: I haven't written anything on that blog in a while ... mostly because I haven't been playing much go recently
12:33:30 <middayc> hmm.. that IRCbot tutorial also seems very interersting .. cool
12:33:40 <dcoutts> EvilTerran: I proposed one project about making a Unicode ByteString
12:33:56 <phlpp> byorgey: oh, that's a pitty
12:33:57 <dons> monochrom: :)
12:34:05 <phlpp> *pity* i think
12:34:18 <byorgey> phlpp: yes, it is a pity. =)
12:34:23 <phlpp> hehe
12:34:50 <EvilTerran> dcoutts, okay... that sounds like it might be within my competence level :)
12:35:05 <byorgey> phlpp: I don't really have anyone to play with IRL at the moment, and I've just been doing other things
12:35:15 <byorgey> phlpp: I plan to get back into it at some point
12:35:20 <EvilTerran> (Oege's IDE thingamawhat sounded a bit scary, actually - especially as he said it's written "in a lazy functional style, but in java")
12:35:24 <gwern> hm. what's the ghc -w option do?
12:35:33 <dcoutts> EvilTerran: heh heh
12:36:22 <dons> heh. like Appel's Java compiler book, that looks *exactly* like ML in Java.
12:36:35 <Deewiant> gwern: GHC user's guide tells me "disable all warnings"
12:36:47 <phlpp> byorgey: hehe. i'm looking forward to join a go club near at where i live. at least to join one of there evenings, when they play, you know.. i just know the really basic rules by heart, played some games vs. gnu go.. but i think i need some real life experience, just to make sure that this is the right thing for me, you know
12:36:52 <dcoutts> dons: though that's not lazy
12:37:22 <dcoutts> dons: apparently the Java folks' term for lazy is "demand driven". It's ok for them to be demand driven, but not lazy.
12:37:23 <byorgey> phlpp: careful, you might become addicted =)
12:37:29 <phlpp> byorgey: hehe
12:37:35 <gwern> Deewiant: ew. warnings should be fixed, or bugs filed on ghc when there's nothing bad about it
12:37:37 <dons> ah dcoutts, hehe, its more enterprisey to be demand drive
12:37:41 <dcoutts> dons: indeed apparently it's positively a buzzword
12:37:44 <dons> "haskell is demand driven!"
12:38:05 <dcoutts> dons: and most importantly doesn't make it sound like they're crediting anyone else with the idea
12:38:14 <BMeph> Better, "Haskell is Just-In-Time Demand-driven processing!" ;p
12:38:19 <EvilTerran> i'm sure there's at least a couple of design patterns involved in faking laziness in java ;)
12:38:22 <dons> dcoutts: that's very important
12:38:24 <byorgey> demand-driven service-oriented architecture!
12:38:25 --- mode: ChanServ set +o dons
12:38:35 <mauke> don't forget abstraction-oriented!
12:38:35 <dcoutts> EvilTerran: oh undoubtedly
12:38:45 --- topic: set to '["The Haskell programming language: 100% demand driven and abstraction oriented!","http://haskell.org ","http://www.jobs-in-fp.org/","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
12:38:52 --- mode: ChanServ set -o dons
12:38:55 <byorgey> hehe
12:38:56 <EvilTerran> hehe
12:38:59 <EvilTerran> ...
12:39:32 <monochrom> Great characterization.
12:39:33 <BMeph> ROFLMAO!
12:39:49 <dcoutts> demand driven is not bad as a term, it's fairly descriptive
12:39:55 <BMeph> Quick, let's change the haskell.org slogan, too! ROFL!
12:40:12 <monochrom> I'm serious. And yes, the haskell.org slogan too.
12:40:35 <monochrom> But not 100%. sequence and mapM are not demand-driven enough.
12:41:00 <BMeph> Then, drop a comment on that guy's blog, so he can tell us what his "first impression" of this slogan is.
12:41:15 <_piranha_> guys... does anyone here compiled ghc6.8 from sources?
12:41:31 <_piranha_> do you have 'regex-*' dirs in your libraries/ directory?
12:41:35 <Valodim_> can someone tell me, in a nutshell, what the point of literate style is?
12:41:40 <monochrom> I do. But I take the tarball from haskell.org/ghc, not from debian whatever.
12:42:01 <_piranha_> monochrom: yes, so do you have this dirs?
12:42:05 <monochrom> I make sure I also take the extralibs tarball.
12:42:10 <_piranha_> ahh
12:42:11 <dcoutts> _piranha_: the regexp-* libs are not core libs, you can install them separately
12:42:13 <monochrom> This is well-known and well-documented.
12:42:21 <_piranha_> I'm new to haskell :-(
12:42:23 <byorgey> Valodim: to emphasize documentation.
12:42:27 <_piranha_> dcoutts: thanks
12:42:37 <_piranha_> so I just need to recompile it...
12:42:38 <monochrom> I'm new to building ghc myself.
12:42:45 <_piranha_> :-)
12:42:59 <monochrom> I don't think there is any excuse.
12:43:09 <_piranha_> I just thought that maintainer in debian is smarter (or at least he is experienced) than me
12:43:09 <dcoutts> _piranha_: you do not need to recompile ghc, you just need to build those extra packages
12:43:18 <BMeph> Valodim_: Check out http://www.literateprogramming.com/ - I think that's a fair synopsis of it.
12:43:18 <_piranha_> monochrom: please don't kill me >_<
12:43:18 <lambdabot> Title: Literate Programming
12:43:21 <_piranha_> dcoutts: I see :-)
12:43:23 <monochrom> Only valid excuse is "My personality is such that I'm a doer not a reader."
12:43:24 <_piranha_> thanks
12:43:30 <Valodim> ah, great. thanks for the link.
12:43:42 <monochrom> I'm a reading not a doer.
12:43:50 <monochrom> err, I'm a reader not a doer.
12:44:03 <dons> mm, "a graph-based demand-driven programming language"
12:44:05 <_piranha_> monochrom: you are killing me... I'm usually reading docs, but looks like not in this case... :\
12:44:07 <_piranha_> %)
12:44:25 <EvilTerran> dcoutts, what would a unicode bytestring lib entail? bytestring-esque packedness and fast IO, but as linear collections of unicode characters rather than bytes/8-bit ascii chars?
12:44:43 <dcoutts> EvilTerran: right
12:44:55 <bos> dons: i've already got a proposal in for a software transactional memory tutorial.
12:45:07 <bos> dons: the more, the merrier
12:45:36 <bos> CosmicRay: thanks! what do you mean by "are you using ghc with it?"
12:45:38 <dons> bos, maybe we should coordinate. i'd like to see a few tuts. also, i'm helping organise the icfp dev tutorials, so if you've suggestions, i'm interested.
12:45:51 <EvilTerran> dcoutts, i'll put it on my list to think about. Oege had a few other suggestions that i'll want to look into, too :)
12:45:56 <dcoutts> EvilTerran: internally it'd use utf-8. To make it simpler to implement it could use a lot of the stream fusion stuff, so initially only a couple conversion functions would be needed and it could re-use the stream functions
12:46:04 <dcoutts> EvilTerran: sure, ask if you want more details
12:46:06 <dons> stm would be good. i'd like to see Control.Parallel get a run. maybe "high assurance development" of some kind
12:46:35 <taruti> is there a way to interface stm nicely with real-world stuff?
12:46:55 <dons> call the stm code?
12:46:56 <taruti> something like howto combine stm and io or network?
12:46:57 <bos> dons: agree on coordination, yeah.
12:47:07 <dons> taruti: yeah, certainly, that's the whole point of stm.
12:47:13 <CosmicRay> bos: did you write your own parser and type system, or are you using ghc-as-a-library for that piece?
12:47:15 <bos> EvilTerran: do you talk to oege often?
12:47:24 <sjanssen> taruti: I don't see where you'd have difficulty
12:47:43 <bos> CosmicRay: it's just an interface to LLVM's code generation and execution facilities, so there's no parsing involved.
12:47:57 <bos> CosmicRay: it mirror's LLVM's type system in haskell
12:48:07 <taruti> sjanssen: doing things from inside stm + handling failed transactions and retries gracefully.
12:48:11 * CosmicRay ponders for a sec
12:48:20 <CosmicRay> so that means that the standard Prelude wouldn't be available?
12:48:34 <CosmicRay> oh.
12:48:36 <EvilTerran> bos, i was in his "programming languages" class last term
12:48:42 <CosmicRay> I think I grok it now.
12:48:44 <sjanssen> taruti: well, the point of STM is that you *don't* do IO inside transactions
12:48:50 <CosmicRay> you wrote something aking to an FFI binding to llvm?
12:48:51 <bos> CosmicRay: it sure is - the whole thing is just a monadic wrapper around some foreign code
12:48:58 <bos> CosmicRay: right!
12:49:03 <dons> you can't retry the 'launch nuclear missles :: IO Boom" action
12:49:06 <dons> nor should you..
12:49:12 <CosmicRay> hah
12:49:23 <CosmicRay> dons: that had better be marked unsafe in the haddock
12:49:24 <bos> dons: what kinds of tutorials do you have in mind for ICFP?
12:49:52 <taruti> dons: true. but when one tries to do things in a distributed way or to coordinate committing things with a sql-database.
12:50:06 <dons> bos, so i wanted to first do a survey of what have been popular in the past, then do say, 3-4 haskell ones for similar thing. it depends on how much we need to 'bootstrap' the audience though
12:50:15 <EvilTerran> bos, and various people who've worked with him, when we're talking about what bits of compsci i particularly like, have said "oh, that's just the sort of thing Oege does! you should try to do a project under him at some point!" :)
12:50:16 <dons> bos, but, parallel programming, web dev, and high assurance programming
12:50:22 <bos> the last FP conference i went to was in 1994, so i'm a bit out of touch with what the kids want these days.
12:50:28 <dons> play to our obvious strengths.
12:50:57 <bos> dons: actually, the llvm bindings would make a good tutorial, because we've done a lot of work on making them safer in terms of types than even the native C++ code is.
12:51:10 <EvilTerran> (or words to that effect) ... so i set up a meeting with him. i'll organise another when I've had time to do a bit more background reading, but that'll be a few weeks off, at least
12:51:10 <bos> "how to write safe wrappers around foreign code, in the large"
12:51:20 <dons> yeah. that kind of thing.
12:51:21 <EvilTerran> bos, so, to answer your actual question, no, not really :P
12:51:36 <bos> EvilTerran: i've  been bugging him to release "algebra of programming", but he's gone quiet on me
12:51:37 <dons> a general theme of doing what people do, but better, using our secret weapons :)
12:51:51 <bos> i need to get dcoutts to visit his office with a baseball bat or something
12:51:54 <litb> what is the easiest way to test whether two numbers have the same sign?
12:52:06 <litb> i used signum x == signum y .
12:52:12 <EvilTerran> litb, multiply 'em, and see if the result's positive?
12:52:19 <byorgey> litb: what you have is fine.
12:52:24 <litb> EvilTerran: i fear that it could overflow
12:52:31 <EvilTerran> x <|(==) `on` signum|> y
12:52:35 <sclv_> obv you should show them both and then scan the strings for a '-'
12:52:37 <dons> abs x * signum x == x -- is the law for signum
12:52:46 <EvilTerran> :D
12:52:49 * dons slaps sclv_ 
12:53:01 <litb> sclv_: lolz
12:53:03 <dons> that's the dynamic way, i give you that, sclv_
12:53:09 * sclv_ has been reading too much daily wtf.
12:53:09 <dons> or the most agile?
12:53:25 <clanehin> sclv_ would get hit by negative zero
12:53:38 <litb> EvilTerran: i'm not sure i understand that
12:53:43 <sclv_> hmm yep, that's the only problem with that solution alright!
12:53:46 <dons> > signum 0 == signum (-0)
12:53:48 <lambdabot>  True
12:53:59 <byorgey> write them both to a file, then read them in and use them to index an array of sufficient size, and see which ones throw an exception
12:53:59 <litb> i also tried "compare y 0 == compare x 0"
12:54:04 <monochrom> You need Double there.
12:54:08 <EvilTerran> litb, that's not surprising. (<|) and (|>) are a little invention of mine that i've used a few times
12:54:19 <litb> EvilTerran: oh i see
12:54:21 <idnar> > -0
12:54:22 <dons> monochrom: nothing holds for double:)
12:54:22 <lambdabot>  0
12:54:24 <EvilTerran> x <| f = f x; f |> x = f x
12:54:28 <monochrom> OK!
12:54:29 <idnar> > -0
12:54:30 <lambdabot>  0
12:54:30 <idnar> err
12:54:31 <EvilTerran> infixl 1 <|, |>
12:54:36 <clanehin> to get negative zero, you have to do something like (-1/0)
12:54:37 <idnar> > -0 :: Double
12:54:37 <lambdabot>  -0.0
12:54:43 <clanehin> or not . . .
12:54:46 <litb> or is there negative and positive infinity and i shouldn't care about overflow?
12:54:48 <bos> dons: oscon tends to have much fluffier presentations than would be the norm at icfp, which makes it a bit hard to get motivated.  why work hard on a presentation to a bunch of people who aren't going to understand it?
12:54:49 <idnar> > signum (-0 :: Double)
12:54:49 <lambdabot>  0.0
12:54:51 <EvilTerran> litb, so x <| f |> y = f x y
12:55:00 <litb> > (inf, -inf)
12:55:00 <lambdabot>   Not in scope: `inf'
12:55:01 <EvilTerran> litb, it's to get around not being able to use expressions in ``s
12:55:09 <dons> bos, right. i'd think its much more like user group talks
12:55:13 <bos> yeah.
12:55:18 <clanehin> in fact that was quickly typed and completely wrong, so I'll go back to work . . .
12:55:20 <dons> or icfp's proposed "developer tutorials" for 08
12:55:31 <dons> i.e build stuff, now, with this cool stuff
12:55:44 <EvilTerran> > [1/0, -1/0, -0, 0.0]
12:55:45 <lambdabot>  [Infinity,-Infinity,-0.0,0.0]
12:55:46 <dons> also, we need to "represent" at oscon. :)
12:55:48 <bos> oscon presentation: "using the gack web framework to solve some modest problem."
12:55:53 <EvilTerran> > 0/0
12:55:54 <lambdabot>  NaN
12:56:21 <sclv_> > signum (-1/0)
12:56:22 <lambdabot>  -1.0
12:56:25 <dons> bos, so, using "teh awesome haskell" to solve non-trivial problems could be a good rule of thumb :)
12:56:25 <EvilTerran> @let infixl 1 <|, |>; x <| f = f x; f |> x = f x
12:56:27 <lambdabot> Defined.
12:56:32 <sclv_> > signum (0/0)
12:56:33 <lambdabot>  -1.0
12:56:40 <dons> the exposure is invaluable.
12:56:45 <sclv_> > signum (12/0)
12:56:46 <lambdabot>  1.0
12:56:54 <idnar> > 0 / 0
12:56:54 <lambdabot>  NaN
12:57:01 <sclv_> > signum ((-12)/0)
12:57:02 <lambdabot>  -1.0
12:57:03 <EvilTerran> > [1..] <| zipWith (/) |> [2..]
12:57:03 <lambdabot>  [0.5,0.6666666666666666,0.75,0.8,0.8333333333333334,0.8571428571428571,0.875...
12:57:05 <idnar> why the heck is NaN negative?
12:57:18 <dons> > signum NaN
12:57:18 <lambdabot>   Not in scope: data constructor `NaN'
12:57:24 <sclv_> idnar: not always ^^
12:57:31 <EvilTerran> > (0/0) == 0
12:57:32 <lambdabot>  False
12:57:34 <EvilTerran> > (0/0) > 0
12:57:35 <lambdabot>  False
12:57:41 <EvilTerran> @src signum
12:57:41 <lambdabot> Source not found. I am sorry.
12:57:49 <sclv_> > (12/0) > 0
12:57:50 <lambdabot>  True
12:57:53 <sclv_> > 12/0
12:57:54 <lambdabot>  Infinity
12:58:04 <sclv_> ah I take it back.
12:58:12 <EvilTerran> idnar, maybe it's defined as signum x | x > 0 = 1 | x == 0 = 0 | otherwise = -1
12:58:30 <idnar> EvilTerran: heh
12:58:30 <EvilTerran> or an equivalent involving compare
12:58:36 <sclv_> @src Double signum
12:58:37 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:58:42 <monochrom> Yikes
12:59:09 <nomeata> dcoutts: I get warnings like these: WARNING: unversioned dependencies are deprecated, and will NOT be accepted by GHC 6.10: base. I assume you are aware of these?
12:59:42 <byorgey> playing with floating-point is like staring at a bad car accident.
13:00:19 <monochrom> @remember byorgey playing with floating-point is like staring at a bad car accident.
13:00:20 <lambdabot> I will remember.
13:04:14 <Dybber_> > gcd 0 0
13:04:16 <lambdabot>  Exception: GHC.Base.gcdInt: gcd 0 0 is undefined
13:04:23 <Tac-Tics> @src gcd
13:04:24 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
13:04:24 <lambdabot> gcd x y = gcd' (abs x) (abs y)
13:04:24 <lambdabot>    where gcd' a 0  =  a
13:04:24 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
13:04:33 <Tac-Tics> > 0 `rem` 0
13:04:34 <lambdabot>  Exception: divide by zero
13:05:16 <byorgey> @oeis 1 3 5 8 10 14 16
13:05:16 <lambdabot> Sum_{k=1..n} floor(n/k); also sum_{k=1..n} d(k), where d = number of divisors...
13:05:16 <lambdabot> [0,1,3,5,8,10,14,16,20,23,27,29,35,37,41,45,50,52,58,60,66,70,74,76,84,87,91,...
13:05:27 <litb> hm, what is infinity?
13:05:34 <litb> i mean, how can i reference it?
13:05:55 <litb> i tried Infinity, inf INF infinity and all i can think of  o.O
13:06:07 <litb> i need the integer infinity
13:06:10 <monochrom> Have you thought of 1/0?
13:07:04 <jsnx> litb: if you are okay with cardinal numbers, infinity is the set [1...]
13:07:09 <litb> ah. but is there no nicer way?
13:07:16 <monochrom> No.
13:07:25 <litb> jsnx: i want to use it to make a upper limit disappear
13:07:33 <jsnx> litb: make upper limit of what?
13:07:51 <jsnx> if you have a relation, you may be able to define a special value
13:07:51 <litb> i have a upper limit to limit an iteration (numeric math).
13:07:54 <monochrom> maxbound
13:07:58 <litb> and now i want that iteration to not stop
13:08:01 <EvilTerran> > maxbound :: Double
13:08:01 <lambdabot>   Not in scope: `maxbound'
13:08:05 <EvilTerran> > maxBound :: Double
13:08:05 <lambdabot>   add an instance declaration for (Bounded Double)
13:08:05 <lambdabot>     In the expression: max...
13:08:10 <jsnx> > maxBound :: Integer
13:08:11 <lambdabot>   add an instance declaration for (Bounded Integer)
13:08:11 <lambdabot>     In the expression: ma...
13:08:24 <jsnx> EvilTerran: doubles are not bounded, strangely
13:08:28 <jsnx> > maxBound :: Double
13:08:28 <lambdabot>   add an instance declaration for (Bounded Double)
13:08:28 <lambdabot>     In the expression: max...
13:08:33 <jsnx> > maxBound :: Int
13:08:33 <litb> jsnx: ok, i will make it a Maybe
13:08:33 <lambdabot>  2147483647
13:08:41 <olsner_> > 1 /= 0
13:08:42 <lambdabot>  True
13:08:49 <EvilTerran> data InfinityOr a = NegInf | Finite a | PosInf deriving Ord
13:08:49 <olsner_> > 1 != 0
13:08:50 <lambdabot>  True
13:08:50 <jsnx> litb: well, you could also define a new type of number
13:08:51 <EvilTerran> :)
13:08:58 <litb> and i thought Int is without any bound
13:09:06 <litb> maybe i just mixxed it o.O
13:09:07 <EvilTerran> litb, that's Integer
13:09:08 <jsnx> litb: no, Int is the machine integer
13:09:12 <litb> oh
13:09:16 <litb> i see
13:09:22 <jsnx> it's too bad Integer is not bounded by Infinity
13:09:30 <EvilTerran> you can tell 'cos "Int" fits inside "Integer" :)
13:09:41 <jsnx> we should complain to Cale
13:09:54 <litb> jsnx: you mean, newtype Limit = Limit Int | WithoutLimit ?
13:10:02 <jsnx> litb: well, no, i mean
13:10:27 <jsnx> data Z = Z NegInf | Z Int | Z PosInf
13:10:45 <Dybber_> litb: see what EvilTerran did
13:10:45 <jsnx> then you use integers in Z (the positive and negative integers)
13:11:05 <litb> oh i missed that, sorry EvilTerran
13:11:16 <jsnx> EvilTerran: yeah, what EvilTerran did is better, I think
13:11:58 <olsner_> @quote
13:11:59 <lambdabot> Toxaris says: class OneOperatorToRuleThemAll a b c where $!§? :: a -> b -> c
13:12:09 <byorgey> jsnx: I think you mean data Z = NegInf | Z Int | PosInf
13:12:21 <jsnx> byorgey: yes
13:12:37 <jsnx> but actually, using `a` instead of `Int` is better
13:12:47 <byorgey> true
13:13:05 <jsnx> byorgey: i don't understand type/data/newtype declarations very well
13:13:12 <byorgey> then you can define instance (Ord a) => Ord (Z a) and so on
13:13:17 <byorgey> jsnx: that's ok =)
13:13:40 <jsnx> i seem to get by with partial evaluation and basic types -- lists and ints -- for everything i've done so far
13:13:48 <jfredett> wouldn't the $!?? be impossible? since its equivalent to a -> (b -> c), and a function of type (b -> c) is impossible? (I think I heard that somewhere)
13:13:54 <litb> is there some function which calls the function that it was called with?
13:14:09 <Tac-Tics> @let interlace [] xs = xs; interlace (x:xs) (y:ys) = x : y : interlace xs ys
13:14:10 <jsnx> litb: well, const
13:14:11 <lambdabot> Defined.
13:14:16 <byorgey> jfredett: it is, but that's a type class, it's a bit different
13:14:20 <jfredett> ah, okay
13:14:22 <Tac-Tics> > iterlace [0..] [-1,-2,..]
13:14:23 <lambdabot>  Parse error at "..]" (column 23)
13:14:28 <dons> litb: fix? what's the type?
13:14:33 <byorgey> jfredett: a function of type (b -> c) for *any* b and c, is impossible.
13:14:35 <dons> you want a call back?
13:14:37 <Tac-Tics> > interlace [0..] [-1, -2..]
13:14:37 <jfredett> cause you're providing a concrete instance.
13:14:39 <dons> or some funny recursion?
13:14:39 <lambdabot>  [0,-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7,-8,8,-9,9,-10,10,-11,11,-12,12,-13,13,...
13:14:42 <byorgey> jfredett: but it may be possible for certain values of b and c.
13:14:43 <idnar> @type \x -> 5
13:14:43 <EvilTerran> ?src interlace
13:14:44 <RayNbow> is there a way to evaluate every element of a list without printing it?
13:14:44 <lambdabot> forall t t1. (Num t1) => t -> t1
13:14:44 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:14:44 <jfredett> right, I understand now
13:14:46 <dons> ?users
13:14:46 <jsnx> litb: what do you mean? like a continuation?
13:14:46 <lambdabot> Maximum users seen in #haskell: 454, currently: 432 (95.2%), active: 24 (5.6%)
13:14:52 <EvilTerran> Tac-Tics, interlace?
13:14:57 <Tac-Tics> EvilTerran, I just defined it with @let
13:15:15 <litb> jsnx: i mean, q f = f
13:15:19 <EvilTerran> interlace xs ys = concat (transpose [xs,ys]) --?
13:15:22 <litb> jsnx: with f being some arbitrary function
13:15:29 <monochrom> "q f = f" is id.
13:15:38 <litb> oh
13:15:42 <monochrom> @src id
13:15:43 <lambdabot> id x = x
13:15:43 <byorgey> RayNbow: you mean, to force evaluation?
13:15:50 <litb> finally i know what id is, hehe
13:16:04 <RayNbow> byorgey: yeah
13:16:18 <Tac-Tics> > concat (transpose [0..] [-1,-2..])
13:16:20 <lambdabot>  Couldn't match expected type `[t] -> [[a]]'
13:16:25 <Tac-Tics> err
13:16:26 <_piranha_> thanks ubuntu/debian packaging, my battle with yi is prolonged for unknown term :-(
13:16:26 <Tac-Tics> heh
13:16:40 <Tac-Tics> > concat $ transpose $ return $ [0..] [-1,-2..]
13:16:40 <lambdabot>  Couldn't match expected type `t -> a' against inferred type `[a1]'
13:16:46 <Tac-Tics> bah
13:17:00 <Tac-Tics> > concat $ transpose [[0..], [-1, -2..]]
13:17:01 <lambdabot>  [0,-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7,-8,8,-9,9,-10,10,-11,11,-12,12,-13,13,...
13:17:08 <Tac-Tics> =-D
13:18:07 <Tac-Tics> good, except more naturally, it should go like this
13:18:07 <Tac-Tics> > interlace [0, -1..] [1..]
13:18:08 <lambdabot>  [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,...
13:18:57 <gwern> :t listToMaybe
13:18:58 <lambdabot> forall a. [a] -> Maybe a
13:19:11 <gwern> @src listToMaybe
13:19:11 <lambdabot> listToMaybe []        =  Nothing
13:19:11 <lambdabot> listToMaybe (a:_)     =  Just a
13:19:12 <Tac-Tics> > listToMaybe [1,2]
13:19:13 <lambdabot>  Just 1
13:19:21 <gwern> ah, it takes the head.
13:19:25 <gwern> that's the problem
13:19:31 <Tac-Tics> listToMaybe should be called "maybeHead" instead
13:20:09 <gwern> definitely
13:20:20 <Tac-Tics> but then, we'd need a maybeTail
13:20:29 <Tac-Tics> and maybe a maybeNull
13:20:50 <olsner_> maybeNull?
13:21:05 <EvilTerran> > ($[]) . foldr (.) id $ zipWith ((.)`on`(:)) ['a'..'z'] ['A'..'Z']
13:21:05 <lambdabot>  "aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ"
13:21:09 <monochrom> maybeNth ?
13:21:10 <olsner_> maybeNull :: [a] -> Maybe Bool
13:21:21 <EvilTerran> > foldr ($) [] $ zipWith ((.)`on`(:)) ['a'..'z'] ['A'..'Z'] -- even
13:21:22 <lambdabot>  "aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ"
13:22:32 <EvilTerran> (note that truncates if the lists are different lengths, rather than tacking the tail of the longer one on the end as in the concat.transpose one)
13:22:40 <olsner_> > ((++)`on`(:[])) 1 2
13:22:40 <lambdabot>  [1,2]
13:22:51 <Tac-Tics> @let (!!?) l n = if 0 <= n && n < length l then Just $ l !! n else Nothing
13:22:53 <lambdabot> Defined.
13:22:54 <Sizur> i need to construct a showable DateTime value. there is fromGregorian, but it has no Time part, what should i be using?
13:23:00 <Tac-Tics> > [1,2,3,4,5] !!? 6
13:23:01 <lambdabot>  Nothing
13:23:08 <Tac-Tics> > [1..5] !!? 4
13:23:10 <lambdabot>  Just 5
13:23:31 <gwern> :t last
13:23:32 <lambdabot> forall a. [a] -> a
13:23:33 <Sizur> :t (!!?)
13:23:34 <lambdabot> Not in scope: `!!?'
13:23:45 <hpaste>  litb pasted "what's wrong?" at http://hpaste.org/5066
13:23:49 <Sizur> > 0 /? 0
13:23:50 <lambdabot>   Not in scope: `/?'
13:23:50 <litb> and it happened again :)
13:23:53 <Tac-Tics> Sizur: it's [a] -> Int -> Maybe a
13:23:59 <EvilTerran> xs !!? n = listToMaybe (drop n xs)
13:24:12 <litb> bisektionmethode and sekantenMethode both are of the same size
13:24:19 <Sizur> ah, you just defined it
13:24:23 <Tac-Tics> yeah
13:24:32 <EvilTerran> litb, what's happening that's not right?
13:25:07 <EvilTerran> litb, remember that function application binds tighter than any operator
13:25:26 <EvilTerran> and (**) and (^) are operators
13:25:34 <litb> No instance for (Floating (Int -> (Double, Double) -> Naeherung)) arising from a use of `**' at /home/js/haskell/wnm.hs:68:32-72
13:25:53 <monochrom> parentheses
13:26:12 <monochrom> which is what EvilTerran means
13:26:35 <gwern> > last []
13:26:36 <hpaste>  Valodim pasted " >>= application?" at http://hpaste.org/5067
13:26:37 <ehird> anyone have a haskell-only definition for coerce :: a -> b? :-) using unsafePerformIO
13:26:37 <EvilTerran> litb, " ... ^3 (0, 2)" parses as "... ^ (3 (0,2))"
13:26:37 <lambdabot>  Exception: Prelude.last: empty list
13:26:46 * Valodim points to paste
13:26:56 <EvilTerran> ehird, unsafePerformIO isn't haskell :P
13:27:02 <ehird> EvilTerran: hehe :)
13:27:22 <mauke> ehird: omg = unsafePerformIO (newIORef undefined)
13:27:37 <litb> EvilTerran: oh
13:27:45 <ehird> mauke: that doesn't exactly give me 'coerce' though
13:27:54 <mauke> unafePermformIO (writeIORef omg a >> readIORef omg)
13:28:15 <RayNbow> byorgey, would the following evaluate all elements of the list of lists? foldr seq 0 (replicate 300000 (mergesort numbers))
13:28:19 <gwern> Valodim: did you try 'localNaAddress = return (inet_addr "localhost" >>= SockAddrInet 12002)'?
13:28:45 <Valodim> yes
13:28:49 <Valodim> same error as with $
13:29:00 <EvilTerran> Valodim, and what error is that?
13:29:02 <Valodim>     Couldn't match expected type `IO b'
13:29:02 <Valodim>            against inferred type `SockAddr'
13:29:02 <Valodim>     In the second argument of `(>>=)', namely `SockAddrInet 12002'
13:29:07 <ehird> mauke: doesn't evaluate.
13:29:12 <EvilTerran> Valodim, ah, i see the problem
13:29:15 <EvilTerran> ?type (>>=)
13:29:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:29:17 <mauke> ehird: what why
13:29:27 <EvilTerran> Valodim, the second parameter to >>= has to return a monadic value
13:29:42 <monochrom> Valodim: I don't know how to say it, but you're mistaken.  do { x <- m; n x } is the same as "m >>= n".  Note I have "n x", not "return (n x)".
13:29:43 <czakey> ?type (=<<)
13:29:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
13:29:44 <Dybber_> shouldnt it be localNaAddress = inet_addr "localhost" >>= \addr -> return $ SockAddrInet 12002
13:29:53 <EvilTerran> localNaAddress = return . SockAddrInet 12002 =<< inet_addr "localhost"
13:30:03 <ehird> mauke: try it
13:30:18 <EvilTerran> or localNaAddress = SockAddrInet 12002 `liftM` inet_addr "localhost"
13:30:25 <monochrom> do { x <- m; return (f x) } is, however, liftM f m, aka fmap f m.
13:30:29 <conal> or <*>
13:30:35 <EvilTerran> (replace liftM with liftA or fmap or <$> or whatever if you'd rather)
13:30:51 <EvilTerran> we really need to do something about all those names
13:30:58 <conal> ye
13:31:13 <Valodim> aah
13:31:51 <EvilTerran> ?type fmap
13:31:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:31:53 <EvilTerran> ?type ap
13:31:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:31:59 <Dybber_> @src <*>
13:31:59 <lambdabot> Source not found. Take a stress pill and think things over.
13:32:06 <Dybber_> @src (<*>)
13:32:07 <lambdabot> Source not found. stty: unknown mode: doofus
13:32:13 <EvilTerran> Dybber_, it's a method of Control.Applicative.Applicative
13:32:13 <Valodim> that one with =<< works, sweet
13:32:14 <mauke> *Main> coerce (65 :: Int) :: Char
13:32:14 <mauke> 'A'
13:32:25 <EvilTerran> mauke, what?!
13:32:30 <ehird> mauke: yeah i had it wrong
13:32:31 <ehird> it works
13:32:32 <ehird> :D
13:32:36 <mauke> http://hpaste.org/5068
13:32:36 <blarz> are those " stty: unknown mode: doofus" messages taken from sudo?
13:33:02 <ehird> i like how it segfaults :D
13:33:24 <ehird> *Main> coerce ("hello" :: [Char]) :: [Int] [104,101,108,108,111]
13:33:25 <ehird> fun
13:33:27 <Valodim> I thought SockAddrInet returned an IO thing, like inet_addr does... but I see why it doesn't, it all makes sense now :)
13:33:47 <idnar> evil
13:33:55 <ehird> idnar: of course
13:33:55 <mauke> I can't make it segfault :(
13:33:56 <ehird> but brilliant
13:33:58 <gio123> is here somebody who was working on subtyping?
13:34:02 <ehird> mauke: coerce without types
13:34:03 <ehird> try:
13:34:04 <ehird> coerce 4
13:34:12 <mauke> nothing happens
13:34:19 <ehird> define nothing
13:34:25 <mauke>  
13:34:30 <ehird> segfaults here
13:34:41 <ehird> wow
13:34:43 <ehird> illegal instruction
13:34:44 <EvilTerran> mauke, coerce to a list or something?
13:34:44 <ehird> *Main> coerce ("hello" :: String) :: IO () Process haskell illegal instruction
13:34:50 <mauke> *Main> coerce [1,2,3] :: IO String
13:34:50 <mauke> <interactive>: internal error: stg_ap_v_ret
13:34:53 <RayNbow> hmm...
13:34:54 <dons> totally not a good  idea, guys
13:34:57 <ehird> severe ghc craziness
13:35:02 <mauke> *Main> coerce 42 :: String
13:35:02 <mauke> ""
13:35:02 <ehird> dons: yes but it's fun.
13:35:21 <ehird> mauke: debug-compiled ghc, or something?
13:35:23 <dons> you need a side condition that runtime representations are equivalent, after the optimiser's had its way
13:35:29 <gio123> i need expect !!!
13:35:31 <gio123> is here somebody who was working on subtyping?
13:35:33 <mauke> ehird: I don't think so
13:35:44 <mauke> using 6.8.2, btw
13:35:51 <ehird> 6.6, i cba to update
13:35:52 <ehird> :-)
13:36:23 <byorgey> RayNbow: yes, I think that should work
13:36:41 <ehird> *Main> let toString = coerce (coerce :: a -> b) :: a -> String
13:37:14 <mauke> haha
13:37:21 <ehird> unfortunately it just converts nonsense into ""
13:37:25 * byorgey stabs coerce with a pointer
13:37:28 <ehird> however:
13:37:29 <ehird> *Main> toString [4] " Process haskell segmentation fault
13:37:33 <ehird> it gets one quote out.
13:37:33 <mauke> *Main> coerce coerce
13:37:34 <mauke> zsh: segmentation fault
13:37:36 <EvilTerran> hm... are liftM/ap/join enough to define a monad?
13:37:38 <RayNbow> byorgey: hmm, but does it evaluate "mergesort numbers" once or 300000 times? :p
13:37:43 <ehird> mauke: zsh! i use zsh too!
13:37:44 <ehird> :P
13:37:57 <mauke> EvilTerran: you need return
13:38:08 <byorgey> RayNbow: oh, wait, no, that's not what you want to do!
13:38:12 <mauke> m >>= f = join (liftM f m)
13:38:18 <EvilTerran> but liftM/ap/return aren't enough, either, right?
13:38:24 <dons> gio123: subtyping??
13:38:38 <conal> EvilTerran: right.  that Applicative.
13:38:39 <byorgey> RayNbow: something like let n = mergesort numbers in (foldr seq 0 n) `seq` n
13:38:41 <EvilTerran> is there any one function you could take with liftM and ap to define a monad?
13:38:52 <conal> Applicative = return + ap (pure + <*>)
13:38:55 <byorgey> RayNbow: erm... maybe
13:38:56 <EvilTerran> oh, wait, never mind. Applicative has pure...
13:39:00 <EvilTerran> cool
13:39:41 <conal> liftM = ap . return (i think)
13:39:45 <conal> @ty ap . return
13:39:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m a -> m b
13:39:57 <EvilTerran> so, if we were to rig everything into a heirarchy, it could be Functor where fmap => Applicative where { pure; (<*>) } => Monad where join, say?
13:40:20 <EvilTerran> (or Monad where (>>=) or whateveR)
13:40:28 <olsner_> @ty liftM
13:40:29 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
13:40:37 <conal> yes.  and i'd go for join & (>>=) defaulted in terms of each other
13:40:38 <byorgey> EvilTerran: that ought to work
13:41:11 <RayNbow> byorgey: perhaps I'll just write a simple loop in Haskell and print the maximum value of "mergesort numbers" a few times :p
13:41:44 <EvilTerran> and then Applicative => Alternative, and we don't need MonadPlus :)
13:42:00 <RayNbow> (although I'm not sure if it still evaluates "mergesort numbers" n times...)
13:42:18 <EvilTerran> RayNbow, don't worry, it won't
13:43:09 <RayNbow> EvilTerran: will it only be evaluated once then?
13:43:12 <dons> Cale: just for you edification, more insights into the 'mathematics is a conspiracy against programming' movement, http://programming.reddit.com/info/65rs8/comments/c02x8su
13:43:17 <EvilTerran> yes
13:43:23 <RayNbow> EvilTerran: that's not what I want :p
13:43:43 <EvilTerran> passing something as a parameter to a function counts as "giving it a name" in evaluation terms
13:43:45 <Valodim> is there any color associated with haskell
13:43:59 <Valodim> (yay superficial question)
13:44:03 <EvilTerran> in that that binding will only evaluate it once while it remains in scope
13:44:12 <EvilTerran> RayNbow, what are you trying to do?
13:44:13 <ehird> Valodim: green and purple
13:44:27 <ehird> http://upload.wikimedia.org/wikipedia/en/0/0f/Haskell_Logo.jpg
13:44:43 <EvilTerran> RayNbow, be aware that the haskell official standard does not define evaluation style anywhere. i'm just saying how ghc does it.
13:45:05 <dons> Valodim: a kind of purple/blue?
13:45:11 <Valodim> purple sounds good
13:45:12 <RayNbow> EvilTerran: evaluating "mergesort numbers" several times, so I can time it... (it is to be compared with a few other programs someone else wrote)
13:45:15 <dons> (the colour of "Craft in FP")
13:45:31 * ehird has been infected by the logo
13:45:32 <ehird> and seen above
13:45:42 <ehird> EvilTerran: it defines 'lazy' surely ;)
13:45:46 <litb> i just wonder, can a function  be a class instance too?
13:45:49 <EvilTerran> ehird, nope!
13:45:55 <EvilTerran> only "non-strict semantics" :D
13:45:57 * RayNbow doesn't see the point in evaluating 3000 times the same expression though :p
13:46:15 <ehird> EvilTerran: call-by-name haskell!
13:46:17 <RayNbow> but alas, that's what the other programs are doing... :p
13:46:21 <ehird> ... aieee.
13:46:47 <EvilTerran> ehird, or evaluating terms being matched against in parallel?
13:46:50 <Tac-Tics> Other than Vty, is there any generic Console API for Haskell?
13:46:58 * RayNbow has an idea...
13:47:02 <dons> does anyone know where that web interface to the python lib that shows the google-found colour associated with a keyword is?
13:47:13 <dons> i'd like to see what colours it says are typical of haskell
13:47:16 <ehird> EvilTerran: that would be kinda cool actually.
13:47:26 <ehird> EvilTerran: apart from the whole IO/State thign :P
13:47:39 <EvilTerran> ehird, State's purely functional; it wouldn't be a problem
13:47:47 <Tac-Tics> dons: it's probably purple and blue
13:47:49 <ehird> good point
13:47:54 <ehird> but.... IO :P
13:47:57 <Tac-Tics> at least, those are the colors I think of when I see haskell code
13:47:58 <EvilTerran> neither would IO be; the ordering of effects enforced by monads would get around that
13:48:00 <ehird> Tac-Tics: has everyone seen the logo or...?
13:48:02 <dons> there's a great site for this, but i can't find it...
13:48:06 <byorgey> litb: no, only types.
13:48:35 <gio123> <dons> yes, subtyping
13:48:36 <litb> ok, i think i need a data type then, containing a function
13:48:46 <olsner_> 'Refuting "Considering 'Why "Why 'Why Category Theory Matters' Matters" Doesn't Matter' Harmful Considered Harmful: A Refutation" '
13:48:58 <Tac-Tics> ehird: Hey, those are the logo colors. We need to put the logo on more stuff
13:49:24 <EvilTerran> ehird, i think it's not been done 'cos it's only of limited use; no sense wasting processor cycles evaluating a term when you don't know if one earlier in the pattern's matched yet
13:49:26 <Tac-Tics> Python's got that damn snake. Ruby has the ruby logo. Perl has a freaking camel
13:49:33 <hpaste>  zeloran pasted "Monad Parser" at http://hpaste.org/5069
13:49:41 <Tac-Tics> We need to spread our lambda logo around the net
13:49:43 <ehird> "Olsner mentioning the title 'Refuting "Considering 'Why "Why 'Why Category Theory Matters' Matters" Doesn't Matter' Harmful Considered Harmful: A Refutation"' considered harmful"
13:49:45 <zeloran> need some help :)
13:49:52 <ehird> Tac-Tics: it's not really as striking :P
13:49:56 <EvilTerran> seeing as the end result behaviour *is* defined by the Report; just not what gets evaluated in the process of behaving that way
13:49:59 <gio123> somebody has used antimirov regular inequality?
13:50:11 <Tac-Tics> ehird: then we need a logo with a lambdacat on it
13:50:16 <EvilTerran> ehird, clear as mud?
13:50:22 <EvilTerran> :D
13:50:25 <zeloran> does somebody know why i always get "ccc" in the pastet code for test2 [Station "xyz"]
13:50:36 <ehird> Tac-Tics: YES
13:50:38 <ehird> LAMBDACAT
13:50:54 <litb> hm, isn't a string just [Char] ?
13:50:56 <zeloran> someone from germany here?
13:50:59 <RayNbow> byorgey, EvilTerran: I'll just do something like this: minimum $ map (minimum . mergesort) $ zipWith (:) [1..] (replicate n numbers) -- this should forcefully evaluate everything :p
13:51:01 <EvilTerran> @src String
13:51:01 <lambdabot> type String = [Char]
13:51:10 <ehird> stylized, of course
13:51:48 <Tac-Tics> We need an artist! We can get a cartoon cat playing with an oversized lambda like a ball of yarn
13:52:03 <eyeris> What is the customary qualified name for ByteString? BS?
13:52:32 <dons> eyeris: i use S.* and L.*
13:53:02 <eyeris> S = ByteString L = List?
13:53:40 <dons> strict and lazy bytestrings
13:53:55 <eyeris> ahh
13:53:58 <zeloran> someone arround who is familiar with wirtting monad parsers?
13:54:13 <igel> zeloran: such as parsec?
13:54:27 <matthew-_> dons: in hindsight, do you regret calling them ByteStrings given the obvious issue with the abbrieviation?
13:54:32 <zeloran> written without parsec..
13:54:37 <matthew-_> dons: or was it entirely deliberate?
13:54:48 <olsner_> wonder what's up in #haskell-blah
13:54:52 <eyeris> dons wrote the ByteString library?
13:54:56 <dons> matthew-_: not really. what's the alternative?
13:55:05 <dons> oh, BS?
13:55:06 <dons> heh
13:55:17 <dons> they'll kick your butt, so i don't worry
13:55:23 <moonlite> :)
13:55:50 <gio123> <dons> do u know antimirovs algorithm
13:55:56 <gio123> ?
13:55:57 <dons> nope
13:56:00 <gio123> ok
13:56:01 <byorgey> zeloran: I get "aaa"
13:56:10 <gio123> it is to compare two regular expressions
13:56:39 <dons> oh, that's interesting
13:57:17 <zeloran> for which input @ byorgey
13:57:28 <byorgey> zeloran: test2 [Station "xyz"]
13:57:48 <gio123> <dons> did u told me? taht is interesting
13:57:49 <gio123> ?
13:58:15 <olsner_> @quote type-checked
13:58:15 <lambdabot> scsibug says: i could have sworn it was incorrect until it type-checked
13:58:49 <dcoutts_> nomeata: yes, I asked for that warning to be added after discovering that gtk2hs was using unversioned package deps and ghc-pkg was not complaining
13:59:03 <zeloran> strange i got "ccc" -.-
13:59:07 <zeloran> (using winhugs)
14:00:23 <byorgey> zeloran: it should not be possible to reach the _ -> case
14:00:32 <byorgey> zeloran: what happens if you remove that case?
14:00:43 <byorgey> the _ -> "ccc" case I mean
14:00:45 <zeloran> i get an error
14:00:47 <zeloran> wait
14:00:48 <hpaste>  sjanssen pasted "a small mail notification script using hinotify" at http://hpaste.org/5070
14:01:16 <zeloran> Main> test2 [Station "xyz"]
14:01:16 <zeloran> "
14:01:16 <zeloran> Program error: pattern match failure: test2_v1689 (P monBahnhof_v1686 [Station "xyz"])
14:01:27 <sjanssen> @seen kolmodin
14:01:27 <lambdabot> kolmodin is in #friendly-coders, #gentoo-haskell, #xmonad, #haskell, #ghc and #darcs. I last heard kolmodin speak 11m 15s ago.
14:01:54 <sjanssen> kolmodin: http://hpaste.org/5070 here's a cute use of your hinotify library
14:02:42 <dons> nice.
14:02:55 <litb> hm, but then, why isn't (\x -> 1 / (2 * pi) ** 0.5 * exp (-0.5 * x^2))
14:03:07 <sjanssen> dons: are you familiar with offlineimap?
14:03:09 <litb> parsed as (\x -> 1 / (2 * pi) ** (0.5 * exp (-0.5 * x^2))) ?
14:03:13 <dons> nope
14:03:26 <byorgey> zeloran: hmm... you know, using the same name "syms" several places in monBahnhof looks shady to me
14:03:34 <zeloran> yes
14:03:44 <zeloran> but normaly this doesnot make problems
14:03:48 <conal> sjanssen, kolmodin: hinotify + Reactivity would be a nifty combo.  it'd b easy to wrap a notifier up as a functional event.
14:03:52 <byorgey> zeloran: maybe it should be something like case syns of (Station x):syms' -> Result (Bahnhof x) syms'
14:04:01 <byorgey> erm, case syms* of
14:04:08 <sjanssen> dons: it's a program (written in Python by CosmicRay) that syncs a local maildir and a remote IMAP account
14:04:22 <sjanssen> dons: I've been pondering cloning it in Haskell
14:04:29 <dons> ah right.
14:04:39 <dons> i like this stm/inotify interplay
14:04:41 <dons> very nice.
14:04:59 <dons> stm's got some great applications for file system hackin<g
14:05:05 <sjanssen> leveraging STM, hinotify, and IMAP idle to do it much better
14:05:07 <conal> sjanssen: if you're interested, i'd collaborate on a more functional-style version using functional reactivity.
14:05:16 <zeloran> seems it' an problem of winhugs @ byorgey
14:05:50 <sjanssen> offlineimap runs in batch/polling mode, so the view of your mail might be stale by a few minutes
14:05:51 <byorgey> zeloran: yes, it seems so
14:05:56 <byorgey> zeloran: that's a very strange error message
14:06:04 <sjanssen> I'm slightly OC with my mail, so this is no good :)
14:06:09 <bos> exploring the unknown aspects of haskell in http://programming.reddit.com/info/65rxw/comments/
14:06:14 <BMeph> litb: ** has higher precedence than * does.
14:06:27 <sjanssen> conal: a reactive version of this script, or the larger scale program I was describing?
14:06:32 <eyeris> Was Data.Is there any syntax in haskell to let me declare for a function take = StrL.take?
14:06:44 <eyeris> s/Was Data.//
14:07:06 <conal> sjanssen: either/both
14:07:32 <conal> bos: consciousness & canfield?  now i really want to read your book.
14:07:35 <sclv_> bos: lolz
14:08:35 <dons> kierkegaard? pilates? how did it *know* ??
14:10:15 <hpaste>  Sewcardsasq pasted "Nice free porno movie and pictures" at http://hpaste.org/5071
14:10:23 <conal> sjanssen: i'm interested in seeing how far we can push functional (non-IO) programming in traditionally imperative applications.  and exploring how to keep the imperative bits separable so the can be removed during composition.
14:11:05 <conal> who's Sewcardsasq think s/he's kidding.  probably wants help with a haskell type error message.
14:11:16 <kolmodin> sjanssen: sweet :)
14:12:01 <zeloran> @karma++ igel
14:12:02 <lambdabot> igel's karma raised to 1.
14:12:13 <kolmodin> sjanssen: hinotify should be prerformance tested with bos' ideas
14:12:17 <kolmodin> *performance
14:12:42 <dons> bos, haskell slogan gets tagged as "agile" :)
14:12:46 <sjanssen> kolmodin: should hinotify require -threaded?
14:12:52 <bos> kolmodin: i had an idea?
14:12:56 <RayNbow> @src length
14:12:56 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:13:04 <bos> dons: nice :)
14:13:20 <kolmodin> bos: didn't you? about pyinotify
14:13:31 <bos> ah, that.
14:13:32 <RayNbow> what's the implementation of length in the Prelude? Does it use foldl'?
14:13:35 <sjanssen> kolmodin: erm, nevermind.  User error
14:13:44 <sjanssen> @src length
14:13:46 <kolmodin> sjanssen: ok :)
14:13:46 <lambdabot> Source not found. You untyped fool!
14:14:09 <yav> @paste
14:14:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:14:40 <blarz> @beer
14:15:19 <blarz> huh? lambdabot queried me telling me some nicknames
14:15:44 <igel> has anyone tried to compile ndp ( [nested] data parallel haskell ) ?
14:15:51 <doserj> beer gets spell-corrected to seen
14:16:01 <czakey> :d
14:16:03 <igel> (the fast version)
14:16:05 <blarz> doserj: ah
14:16:12 <dons> igel, it needs ghc head.
14:16:26 <igel> what's that?
14:16:52 <dons> the head branch of ghc, not ghc 6.8.x
14:16:53 <bos> i've been meaning to take a look at hinotify.
14:17:04 <igel> dons: i tried 6.6.1
14:17:14 <igel> i get ghc compiled
14:17:41 <igel> but when i insert the ndp directory in libraries/, and 'make make.library.ndp'
14:17:57 <igel> make complains that the target is unknown
14:18:00 <dons> igel, oh, it definitely won't work with 6.6
14:18:14 <dons> it needs type system extensions only available in the ghc head branch
14:19:27 <RayNbow> hmm...
14:19:29 <igel> dons: by "head version" do you mean the latest version available? http://darcs.haskell.org/ghc/
14:19:30 <lambdabot> Title: Index of /ghc
14:21:00 * RayNbow hopes that GHC is not smart enough to see that "minimum $ (1 : mergesort list) == minimum (1 : list)"
14:21:21 <dons> igel: the darcs version, yep
14:21:34 <EvilTerran> ?index Ptr
14:21:34 <lambdabot> Foreign.Ptr, Foreign, GHC.Exts, GHC.Exts
14:21:38 <dons> you'll want to check the DPH web page (data parallel haskell)
14:21:48 <dons> whcih summarises how to build and use the ndp library
14:21:57 <igel> ok thank you very much
14:22:35 <EvilTerran> er...
14:22:49 <EvilTerran> it seems System.IO import-exports Ptr
14:23:10 <EvilTerran> why, then, when I import qualified System.IO as IO, does IO.Ptr not work?
14:23:14 <BMeph> Later, all...
14:23:42 <sjanssen> EvilTerran: I don't think System.IO exports Ptr
14:23:54 <EvilTerran> ?hoogle hPutBuf
14:23:55 <lambdabot> System.IO.hPutBuf :: Handle -> Ptr a -> Int -> IO ()
14:23:55 <lambdabot> System.IO.hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
14:25:00 <EvilTerran> so it exports functions that use it, but not the type itself?
14:25:04 <sjanssen> yes
14:25:14 <EvilTerran> that's *weird*
14:25:32 <sjanssen> you'll have to import something from Foreign.* to create the Ptr anyway
14:33:21 <gwern> @src listFromMaybe
14:33:21 <lambdabot> Source not found. My pet ferret can type better than you!
14:33:38 <gwern> @src listToMaybe
14:33:38 <lambdabot> listToMaybe []        =  Nothing
14:33:38 <lambdabot> listToMaybe (a:_)     =  Just a
14:34:04 <gwern> anyway, is there any listToMaybe-alike which takes the last entyr in the list?
14:34:57 <doserj> like listToMaybe.reverse?
14:36:01 <gwern> doserj: I could roll me own, sure
14:36:22 <gwern> and I have
14:36:26 <gwern> I was just wondering if there was already a defined function
14:38:39 <sclv_> gwern: do what's the use case?
14:38:44 <sclv_> s/do//
14:38:59 <litb> i guess this all are trivial questions ..
14:39:01 <litb> data Funktion = Funktion { funktion :: Double -> Double, name :: String }
14:39:02 <litb> data DiffbareFunktion = DiffbareFunktion { ableitung :: Double -> Double } deriving Funktion
14:39:05 <litb> this doesn't work
14:39:08 <sclv_> if you don't need the list as a list elsewhere, then you can use the Last monoid!
14:39:13 <litb> because Funktion is not a class
14:39:19 <litb> however, how can i make it work?
14:39:59 <sclv_> litb: work to do what, exactly?
14:41:29 <davidL> automagically deriving classes only works for a few classes in prelude iirc
14:41:30 <litb> like, to do DiffbareFunktion { funktion = (\x -> 2*x), name = "2*x", ableitung = (\x -> 4*x^2) }
14:41:52 <litb> so that DiffbareFunktion has all the data that Funktion has
14:42:00 <sclv_> (for the nongermanspeakers, a quick google reveals ableitung = derivative)
14:42:04 <gwern> sclv_: in yi; I am doing a backwards search of the text buffer, and searchSubstrings returns [Int] (indexes of matching substrings), which could obviosly be []; searching forward could just use listToMaybe since the head of the [Int] corresponds to the *next*; but going backwards, I need the last instead of the head, and so I had to set up two guards to handle the Maybe the reversesearch generates
14:42:20 <litb> oh yeah, sorry for the confusion about this german nonsense
14:42:24 <nomeata> litb: you could do data Ableitung = Ableitung { abgeleitetes :: Funktion, ableitung :: Double -> Double }
14:42:37 <gwern> @src last
14:42:37 <lambdabot> last [x]    = x
14:42:37 <lambdabot> last (_:xs) = last xs
14:42:37 <lambdabot> last []     = undefined
14:42:40 <gwern> @src reverse
14:42:40 <lambdabot> reverse = foldl (flip (:)) []
14:43:07 * gwern wonders how their complexitites differ. I'm not really familiar with foldl
14:43:25 <nomeata> gwern: I wouldnât be surprised if listToMaybe.reverse is actually a good choice, due to lazyness
14:43:41 <nomeata> but itâs just a rough guess
14:44:20 <gwern> how could taking the last entry in a list could be lazy? don't you need to see all the previous ones?
14:44:39 <dobblego> last is O(n)
14:44:55 <Tac-Tics> gwern, foldl, I believe, has to take apart the entire list and put it back together
14:45:12 <Tac-Tics> foldr just operates on the pieces as it goes
14:45:26 <litb> i can i do "class Ableitbar where ableiten :: Funktion -> Funktion" ?
14:45:30 <litb> -i
14:45:43 <litb> maybe that is better
14:47:03 <doserj> litb: class Ableitbar a where ableiten :: a -> a
14:47:03 <litb> hm, no that wouldn't work since i don't know what the function is when i'm defining that class
14:47:41 <doserj> instance Ableitbar Funktion where ableiten = ...
14:48:06 <doserj> the challenge is then to define ableiten :)
14:48:11 <litb> yeah, true
14:48:21 <litb> since i don't know the concrete function at that time :/
14:49:05 <gwern> hm. findSubstrings uses the KnuthâMorrisâPratt algorithm, which is... O(n+k), so I guess it doesn't really matter if I use last or reverse. hm. better rewrite that patch - listToMaybe . reverse is fine then
14:49:25 <gwern> what would reverse's complexity be anyway?
14:49:36 <dobblego> O(n)
14:50:29 <gwern> oh. so both last and reverse are O(n)
14:50:41 <gwern> dobblego: where are you getting the bigohs from anyway?
14:50:56 <litb> however, i don't understand why you can't derive one datatype from another datatype. seems to be a quite reasonable operation
14:52:12 <sclv_> litb: not sure if it even makes sense for what you want?
14:52:48 <sclv_> i.e. if you want a function with a name and then the possibly to add a derivative later, then can't you just have a field derivative :: Maybe (Double->Double) ?
14:53:05 * RayNbow wonders why he actually wrote a (naive) Haskell implementation of mergesort as a reply to some benchmark blog post...
14:53:47 <RayNbow> I have the feeling the CPU is twiddling its thumbs during such a benchmark... waiting for memory I/O to complete :p
14:53:47 <litb> sclv_: ok, that makes sense
14:55:36 <litb> i'm not too experienced yet, so another n00b question follows...
14:56:04 <litb> how can i add "automatic" conversion from a lambda expression to a Funktion, where the lambda expression becomes the funktion field ?
14:56:28 <Valodim> do you mean function?
14:56:51 <litb> like, i have a "derive a = deriverative a"
14:57:05 <litb> now i want to call it with "derive (\x -> 2*x)"
14:57:17 <litb> Valodim: i use german names here sometimes o.O
14:57:20 <Valodim> native german speaker?
14:57:27 <litb> Valodim: but yeah, it means function
14:57:30 <litb> Valodim: yeah o.O
14:57:47 <Valodim> people should use more german wÃ¶rter, anyways :P
14:57:53 <litb> =)
14:58:19 <RayNbow> no they should not :p
14:58:25 <Cale> derivative, not deriverative
14:58:33 <Valodim> but it's more cute that way
14:58:46 <Valodim> a lambda expression is a way of expressing a function... I don't really see what you want to do there
14:59:01 <sclv_> litb: are you using numeric or symbolic integration?
14:59:12 <RayNbow> today in the train, I heard two students talking about some "Excel exam" and they were using words like "SOM", "GEMIDDELDE" and "ALS"...
14:59:26 <RayNbow> I was like... wtf... Dutch versions of Excel!
14:59:27 <Cale> "derive" has been pretty much phased out in English in favour of "differentiate" for the verb of taking the derivative
14:59:27 <RayNbow> :p
15:00:20 <Valodim> yeah using the words of you own language in place of technical terms used by the rest of the world is pretty stupid, especially in computer science
15:01:38 <Valodim> (not that an ableitung would be a bad thing, but duh)
15:01:49 <litb> sclv_: numeric
15:02:07 <RayNbow> Ableitung = derivative?
15:02:11 <Valodim> aye
15:02:14 <RayNbow> my German is rusty :p
15:02:42 * RayNbow just associated that random character string with the Dutch word "afgeleide" :p
15:02:48 <olsner_> ableitung = off-leading?
15:02:52 <sclv_> litb: in that case, then you don't need a derivative packed up with a function anyway?
15:03:35 <sclv_> or.. you can have a "smart constructor" that packages up your derivative first.
15:03:51 <mauke> http://dict.leo.org/?search=ableiten
15:03:52 <lambdabot> Title: LEO D-E Ergebnisse für "ableiten"
15:04:15 <Valodim> fr?
15:04:21 <sclv_> best to start with defining a function of type (Double -> Double) -> (Double -> Double) and build data structures from there rather than the other way round.
15:04:25 <Valodim> \bot can't do umlauts?
15:04:46 <olsner_> Valodim: you didn't see the ü?
15:04:55 <Valodim> nope
15:05:00 <RayNbow> Valodim: I wouldn't really mind having own, native words to denote certain concepts... the problem often is that you can't find a decent dictionary for the technical terms :p
15:05:01 <Valodim> Ã¼ <- I do see that one though, I think
15:05:07 <Valodim> yep it's there
15:05:50 <RayNbow> allutf8; jp text: ãããããè³¢ã; russian text: ÐÐÐÐÒÐ; chinese text: è­èæ¥è³è¤ï¼ æ¡è¯ç§çæ½; korean text: íë¯¼ì ì; various eu accents: Ã©Ã¨Ã Ã¹ÃªÃ¢Ã®Ã´Ã»Ã§Ã«Ã¯Ã¼Ã¿ÄÅ¡Å¾Ã¤Ã¶Ã¡Ã­Ã±
15:05:55 <RayNbow> ^ can you read this? :p
15:06:07 <Tac-Tics> I can
15:06:11 <Tac-Tics> aiueo
15:06:15 <Valodim> accents and russian, yes, everything else are squares
15:06:19 <Valodim> though that's likely a font problem
15:06:52 * RayNbow wishes that all unicode font problems would just go away :p
15:07:04 <monochrom> RayNbow: nice Chinese verse there. Now, if only you could write the same verse in all the other languages... :)
15:07:29 <RayNbow> monochrom: I can't read Chinese ;)
15:08:02 <oskarM> Ð½ÐµÑ Ð¿ÑÐ¾Ð±Ð»ÐµÐ¼Ñ
15:08:08 <litb> sclv_: i have to code multiple things
15:08:20 * RayNbow is limited to Dutch (native) and English...
15:08:22 <litb> sclv_: i need that for the newton thingy
15:08:31 <Valodim> Krossgebratene Fernbedienungen streiken um die Wette bis der Zaun knallt.
15:08:38 <monochrom> \bot can do utf8 in some plugins and not some others. It depends.
15:08:51 <lament> RayNbow: that was actually ukrainian, not russian :)
15:08:57 <hpaste>  litb pasted "solution?" at http://hpaste.org/5072
15:09:06 * Valodim click
15:09:10 <litb> it's like that now
15:09:13 <olsner_> oskarM: "a problem"?
15:09:21 <RayNbow> lament: is it?
15:09:28 <monochrom> Some plugins butcher the characters. Some don't. And yet some butcher twice and get a two-wrong-makes-a-right effect.
15:09:30 <olsner_> hmm, "*no problem", probably
15:09:54 <oskarM> yes, no problem, at least with fonts
15:10:20 <lament> RayNbow: yes, one of the letters is not in the russian alphabet.
15:10:44 <olsner_> it's funny how there's a letter looking like 'bl' (Ñ)
15:10:48 <RayNbow> lament: I will inform the person that I received the script from :)
15:10:56 <RayNbow> thx :)
15:12:02 <lament> olsner_: i think it's more funny that there're two letters in english looking like 'Ñ' (bl)
15:12:32 <lament> RayNbow: it's probably the same unicode codepage
15:12:42 <olsner_> lament: you seem to be thinking backwards
15:13:00 <sclv_> litb: if you want a cool trick, change the type of ableitung to Maybe Function and you can write a pointwise auto-derivation transformation wrapped up in some sort of smart constructor that, say, appends ' to the name as well...
15:13:08 <sclv_> anyway, gotta run.
15:13:10 <sclv_> cheers.
15:13:51 <lament> olsner_: no, you seem to be thinking backwards :)
15:14:05 <jsnx> i have a function that looks up a value v::V in a Map V V. if v is a key in the map, i get something out of the map, but if i get nothing, then i just return v
15:14:05 <olsner_> no u :P
15:14:13 <jsnx> is this some kind of monad?
15:14:23 <jsnx> it's like a cross between Maybe and Identity
15:14:52 <kpreid> @type Data.Map.lookup
15:14:54 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
15:15:06 <jsnx> right, that's what i'm using now
15:15:08 <olsner_> @type maybe
15:15:09 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:15:16 <jsnx> but that's not the same, really
15:15:24 <litb> sclv: ah, nice
15:15:35 <litb> can't i change the name and so on on cunstruction time?
15:15:36 <kpreid> jsnx: \k -> fromMaybe k $ lookup k m
15:15:45 <kpreid> @pl \k -> fromMaybe k $ lookup k m
15:15:46 <lambdabot> ap fromMaybe (flip lookup m)
15:15:53 <kpreid> (eh)
15:15:58 <litb> say, if o do "Function (\x -> x) Nothing "foo"" , that it in reality will contain "foo'" as name?
15:16:33 <olsner_> @ty fromMaybe
15:16:34 <lambdabot> forall a. a -> Maybe a -> a
15:16:45 <kpreid> jsnx: I think it's just Maybe
15:16:57 <olsner_> oh, I thought fromMaybe was fromJust for a minute there
15:17:03 <kpreid> if you look at fromMaybe as the 'runMaybe' where you supply the default value context
15:17:10 <jsnx> kpreid: oic
15:19:59 <litb> that way i could have a ctor Funktion' which will append such a "'" to the name. but i guess that is not possible
15:20:11 <jsnx> kpreid: thanks
15:30:36 <TomMD> Does anyone know of any work progressing to 1) Make record names work with existentials  2) Make nested STM transactions a reality?
15:33:43 <LoganCapaldo> re 2) I thought nested transactions working were one of the big selling points for stm
15:34:26 <LoganCapaldo> unless you are using "nested" differently than I'm thinking of
15:34:57 <bos> indeed.
15:37:09 <litb> ah, i could do it like "data Funktion = NonDeriverable { ...} | Deriverable { ... }" , or?
15:37:26 <litb> then i don't need that maybe stuff
15:37:31 <TomMD> LoganCapaldo, bos: atomically ( atomically ( ... ) ... )
15:37:37 <TomMD> that is what I mean by nested
15:37:42 <LoganCapaldo> right
15:37:49 <LoganCapaldo> that works
15:37:52 <LoganCapaldo> doesn't it?
15:37:55 <TomMD> That certainly is not something that works.
15:37:55 <TomMD> nope
15:38:09 <TomMD> ... I'll run off and preform a trivial test
15:38:18 <LoganCapaldo> like when stm came out everyone was all like zomg! composable transactions!
15:38:35 <liyang> nomeata: sorry, have been extremely lazy wrt gtk2hs. Got a deadline next week; will look into it soon...
15:38:57 <Saizan> TomMD: what's the point of that?
15:39:06 <nomeata> liyang: I felt active, so I just created a package and uploaded it to the 5-day-delayed queue. I hope that was ok :-)
15:40:06 <TomMD> Saizan: Its all about flexibility of the underlying system
15:40:14 <liyang> nomeata: oh wonderful. :)
15:40:18 <Saizan> LoganCapaldo: yes transactions are composable, but atomically is what closes the transaction and transform it in a IO action
15:40:37 <nomeata> liyang: if you want, I can upload it to unstable right away
15:40:41 <sjanssen> TomMD: what would nested transactions mean?
15:41:22 <BMeph> Hello, again.
15:41:33 <liyang> nomeata: by no means am I laying any claim to the gtk2hs package. I needed it a while back but not in recent months and have had too many other things to worry about.
15:41:47 <liyang> TomMD: such as nested transactions for example.
15:41:58 <TomMD> sjanssen: Ah, I see.  I'll work on writting up a formal definition then and see if I can answer that in a consistant and sensible manner.
15:42:09 <liyang> But, can't really talk now. Paper deadline looming. :(
15:42:27 <sjanssen> TomMD: I'm just curious.  What sort of semantics do you have in mind?
15:42:41 <sjanssen> erm, I mean what sort of use case you have in mind :)
15:42:58 <nomeata> liyang: ok, Iâll upload it directly, but Iâm also not really feeling like the proper maintainer ;-)
15:43:18 <liyang> sjanssen: nested transactions could be useful if you allow more than just mutable state within transactions. Forking, for example.
15:43:27 <BMeph> Just curious, but - is there any performance hit one way or the other for testing a list parameter for "nullity" by pattern-matching, versusguards?
15:43:34 <liyang> (I could say more but now is really a bad time.)
15:43:48 <liyang> nomeata: does it matter? As long as someone gets it done. :)
15:44:15 <nomeata> right :-)
15:44:31 <nomeata> ok, then donât letme hold you back from work
15:44:53 <TomMD> For example: I have a record update that has extremely expensive computations based on a transaction number.  This number increments with every transaction.  It would be trivially easy if I could 1) Read off my state 2) Atomically read and update the transaction, so no one else reuses my transaction number 3) preform my computation of f :: State -> TransactionNumber -> Result 4) Return with the 'State' being atomically updated (which is d
15:44:58 <TomMD> sjanssen ^
15:45:13 <TomMD> It doesn't come across clean when it isn't in 1000 lines of Haskell :-(
15:45:15 <sjanssen> BMeph: you mean the difference between "null xs" and "case xs of []"?  Probably none with ghc -O
15:45:32 <liyang> TomMD: your line was cut off after ``(which is d...''
15:45:50 <gio123> http://www.springerlink.com/content/f822541107032012/
15:45:51 <lambdabot> Title: SpringerLink - Book Chapter
15:46:11 <TomMD> liyang: is different from where the TransactionNumber is stored).
15:46:51 <BMeph> sjanssen: Technically, I meant more on the lines of "dumbFunc _ []" vs. "dumbFunc a b | null b"... hmm, I think I answered my own question. Thanks! :)
15:47:03 * liyang is working on a forthcoming paper on what exactly a transaction means. Sort of.
15:48:07 <LoganCapaldo> clearly the solution is atomically ( unsafeSTMtoIO $ atomically ( ... ) ... )
15:48:14 <TomMD> liyang: What exactly do you mean?  Are you saying you are working on nesting transactions?
15:48:44 <sjanssen> LoganCapaldo: that will raise an exception
15:48:48 <TomMD> LoganCapaldo: I imagine a system that is SAFE.  Specifically, nested atomically calls can not refer to TVars that are part of the transaction log for transactions above them.
15:49:00 <LoganCapaldo> good thing I was kidding then
15:49:01 <sjanssen> (GHC has an exception for specifically this issue)
15:49:13 <liyang> TomMD: building up to it. I had the idea for some time but haven't had time to write up the details.
15:50:02 <jsnx> so, if i want to build a list from a string, walking down the string two by two -- what's the idiomatic way to do that?
15:50:04 <TomMD> liyang: What name will the paper be under?  Li Yang?  Sorry if I butcher your name there.
15:50:11 <liyang> TomMD: I think you can be more liberal than that. :)
15:50:14 <jsnx> oh, duh, take 2
15:50:15 <liyang> TomMD: Liyang HU
15:50:44 <liyang> You can figure the rest out from my hostmask. :)
15:51:01 <BMeph> Hmm, I had the impression that part of the point of STM, was not to do long, complicated computations in an "atomically" -marked section.
15:52:02 <liyang> BMeph: well, what if you had to? I mean, it's about making concurrent programs easier to write. What if it was easier just to write (or read, or reason about) such a program?
15:52:03 <TomMD> BMeph: That is an assuption which should be avoided when one makes a general purpose language/tool.  I try to avoid it, but some situations are... tricky.
15:52:27 <liyang> TomMD: are you working on STM too? :)
15:53:13 <TomMD> liyang: Looking at getting into a PhD program - where are you studying? (I assume you are a student)
15:53:35 <liyang> TomMD: Nottingham
15:54:02 <BMeph> Not an assumption, just trying to get all the pieces together.
15:55:26 <TomMD> BMeph: It was a good point and generally I try to make sure that if the computation is expensive then atleast the closure will not need recalculated (all the inputs won't change), but with this transaction number that is CERTAIN to change I am CERTAIN to have to recompute for EVERY failed transaction... ugh.
16:07:27 <dons> Cale: did you ever do anything for instance Arbitrary Regex?
16:09:37 <Cale> dons: Oh, I'll do that now. I was kind of tied up reading papers about how to compare regular languages for equality and containment. :)
16:09:45 <dons> heh
16:09:57 <dons> i want to drop it straight into my pcre testsuite
16:10:21 <Cale> I have code for NFAs now as well.
16:10:33 <Pseudonym> Woohoo, NFAs.
16:10:48 <ddarius> Everyone loves NFAs
16:11:44 <Cale> I still haven't actually written the equality test, but I have a good idea how to do it. I think I may also know how to compare for language containment, but I'm not sure if the algorithm I'm thinking of actually works or not.
16:14:32 <TomMD> @where NFA
16:14:32 <lambdabot> I know nothing about nfa.
16:15:29 <Pseudonym> Cale: Testing for language containment is easy.  It's regular tree unification.
16:15:32 <kmcallister> Cale, ever do any automata-theoretic model checking?
16:15:58 <Cale> kmcallister: nope, I actually only do CS as a hobby :)
16:16:07 <kmcallister> haha
16:16:09 <monochrom> Northern Functional Agreement. :)  I'm kidding.  Non-deterministic Finite (State) Automaton.
16:16:35 <kmcallister> it's a good hobby
16:16:41 <monochrom> regular tree....
16:16:47 <TomMD> But is it a good study?
16:17:01 <TomMD> Oh, oops, got my conversations crossed.
16:17:04 <monochrom> It is a bit nerdy for a hobby or study.
16:17:07 <Cale> Pseudonym: Is it the same as equality testing, but where you change the condition such that instead of identical results on prefixes, where they differ, one always accepts where the other doesn't?
16:18:50 <Pseudonym> Probably.
16:19:08 <Pseudonym> The tricky bit is that, IIRC, there is no known polynomial algorithm for regular language equality testing.
16:19:31 <Pseudonym> I can think of a few worst-case exponential ones.
16:19:48 <kmcallister> Pseudonym, at least it's decidable ;)
16:20:25 <Cale> A page on wikipedia claims that there's no algorithm whatsoever for normalising regular expressions, which I think is bullshit. At the very least there are horrible algorithms for doing it.
16:21:01 <kmcallister> normalising such that two expressions which produce the same language will become the same normalized expression?
16:21:09 <Cale> yes
16:21:14 <kmcallister> yeah, that has to be bullshit
16:21:16 <jsnx> is there a language extension that will allow me to import Data.Map
16:21:16 <jsnx>          and use `lookup` and have the compliler figure out which `lookup`
16:21:17 <jsnx>          (Prelude or Data.Map) i mean?
16:21:21 <jsnx> ack
16:21:37 <kmcallister> jsnx, you could maybe do it with typeclass hackery
16:21:39 <Cale> Because equality testing is decidable, and it's pretty easy to come up with a well-ordering on regular expressions.
16:21:47 <moonlite> regular expressions are compiled at runtime in haskell right?
16:21:48 <kmcallister> ?t Prelude.lookup
16:21:49 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
16:21:53 <kmcallister> :t Prelude.lookup
16:21:55 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
16:21:56 <kmcallister> :t Data.Map.lookup
16:21:57 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
16:22:10 <Cale> So you could just write the brute force algorithm to pick the least regular expression that equals your given one.
16:22:18 <jsnx> kmcallister: is lookup even owned by a type class?
16:22:21 <moonlite> (the current implementations i mean)
16:22:35 <kmcallister> jsnx, you could define your own
16:22:56 <jsnx> so, the short answer is, no, there is no compiler option to get around it?
16:23:18 <kmcallister> jsnx, no, each expression in Haskell has a fixed (possibly polymorphic) type before typechecking
16:23:24 <dons> jsnx: no. unless you defined your own typeclass, and import that instead
16:23:49 <jsnx> kmcallister: so, maybe i could just define the type of 'lookup' ?
16:24:10 <jsnx> kmcallister: i tried typing the enclosing expression, that seemed not to work
16:24:12 <kmcallister> jsnx, no, as soon as you mention "lookup" it will complain that it's ambiguous
16:24:17 <jsnx> oic
16:24:21 <kmcallister> what you probably want is just to import Data.Map qualified
16:24:25 <jsnx> aye
16:24:31 <kmcallister> import qualified Data.Map as Map
16:24:38 <jsnx> but then i have to explicitly import (!)
16:24:42 <jsnx> and on and on...
16:24:55 <kmcallister> import Data.Map hiding(lookup)
16:24:57 <kmcallister> import qualified Data.Map as Map
16:25:06 <jsnx> aye
16:25:16 <kmcallister> probably you'll want to hide more of them
16:25:27 <jsnx> import Prelude hiding (lookup)
16:25:29 <jsnx> &c.
16:25:39 <jsnx> i guess that's why we have type classes
16:25:47 <kmcallister> or just have Prelude.lookup be lookup and refer to Map.lookup qualified
16:25:48 <jsnx> because they help protect us from that stuff
16:25:58 <jsnx> how i hate it, though
16:26:08 <kmcallister> type classes are a principled approach to overloading, yeah
16:26:38 <Cale> Weird, I'm going to have to figure out how to write a smarter instance of arbitrary. This one sucks.
16:26:53 <ddarius> Type classes weren't made to deal with namespace issues at all though.
16:27:02 <jsnx> ddarius: well, that's true
16:27:07 <Cale> It seems to either generate trivial regular expressions, or ones which are ridiculously large.
16:27:30 <jsnx> ddarius: but in this case, it could be disambiguated with the type
16:27:35 <liyang> I'd prefer if you could do my usual import qualified Data.Map as Map ; import Data.Map ( (!) ) as a single line, but it's a minor annoyance I'm willing to live with for now.
16:27:53 <kmcallister> typeclasses shouldn't be used to disambiguate completely unrelated things that happen to have the same name, though
16:28:05 <jsnx> in this case, the concepts are closely related
16:28:08 <kmcallister> yeah
16:28:13 <jsnx> and unrelated things should not have the same name
16:28:15 <kmcallister> we could have a Maplike typeclass
16:28:20 <jsnx> aye
16:28:29 <kmcallister> but it's an unavoidable fact of human language that they often do ;)
16:28:35 <LoganCapaldo> you'd need it to a mptc would you not?
16:28:39 <jsnx> class Dictionary
16:28:44 <liyang> I typically just type out Map.lookup, and use lhs2TeX to make it look prettier. :3
16:28:53 <jsnx> liyang: lolz
16:30:09 <jsnx> we should just ban importing two things with the same name that are not differentiated by type class
16:30:17 <jsnx> it would break a bunch of libraries and old code
16:30:20 <jsnx> but so what?
16:30:38 <jsnx> it's not like any one is running Google on Haskell
16:31:00 <kmcallister> jsnx, if they're differentiated by typeclass they're not two things
16:31:07 <liyang> (APL had a point. You do need more than just ASCII to make things read nicely.)
16:31:13 <jsnx> kmcallister: right
16:31:15 <kmcallister> and anyway that's not much different from what we have now (you can import them, but you can't use them)
16:31:20 * Botje sharpens liyang to a point
16:31:42 <kmcallister> it would get annoying if every time you imported two large libraries you had to either qualify all of one of them, or explicitly hide all conflicting names
16:32:03 <jsnx> kmcallister: well, what if it forced everyone to make compatible type classes?
16:32:11 <jsnx> that is the goal, anyway
16:33:40 <jsnx> now, if we actually want to make a type class like this -- it needs to have a function called 'lookUp'
16:33:51 <jsnx> since we can't use 'lookup'
16:34:05 <jsnx> because it's in the Prelude and there will be chaos
16:34:31 <kmcallister> oh, speaking of typeclasses i have a question
16:34:46 <jsnx> i assume that `!!` and `!` come from 'the time before type classe'
16:35:20 <kpreid> @type (!)
16:35:22 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
16:35:23 <kpreid> @type (!!)
16:35:24 <lambdabot> forall a. [a] -> Int -> a
16:35:38 <kpreid> huh, I suppose those could be unified
16:36:02 <kmcallister> i have a type Expr, but i want to be able to use anything generating Expr as a monad action as well, without wrapping it in another function
16:36:05 <jsnx> yeah, serously
16:36:20 <kmcallister> so the combinators have type e.g. (=:) :: (IsExpr a) => Expr -> Expr -> a
16:36:21 <kpreid> kmcallister: not feasible
16:36:37 <kmcallister> it works, when I write the monad action as () <- a =: b
16:36:46 <kmcallister> but without telling it that it should have type (), i can't write the instance
16:37:19 <kmcallister> is there any workaround for this?
16:37:46 <kmcallister> (basically i want to locally restrict the type of (>>))
16:37:51 <kmcallister> ...actually, i could probably do exactly that :D
16:38:05 <Cale> kmcallister: Well, there's the cheesy way :) Include an ignored parameter of the required type.
16:38:32 <Cale> Often functional dependencies can help
16:38:39 <kmcallister> well this is a SPTC
16:38:39 <Cale> I'm not sure if this case applies though
16:39:17 <Cale> You'd want the result type to be in the monad, and the monad type to determine the result type.
16:39:58 <Cale> That would give you another type parameter (the monad), and a fundep to disambiguate.
16:40:07 <Cale> But I don't know if that works well with your application.
16:41:00 <Cale> oh, this does work, I was just misinterpreting the size parameter to generate :)
16:41:41 <kmcallister> so the "types" i want for (=:) are Expr -> Expr -> Expr and Expr -> Expr -> M ()
16:41:46 <kmcallister> where M is a monad
16:42:26 <Saizan> instance IsExpr (M ()) where ..?
16:42:44 <Cale> hmm
16:42:50 <kmcallister> the problem then is that in "do a =: b; foo", a =: b has type M t
16:42:51 <kmcallister> not M ()
16:42:55 <kmcallister> so i have to write () <- a =: b
16:43:01 <Saizan> right
16:43:10 <Cale> does the () really matter?
16:43:25 <Cale> Couldn't you write a polymorphic instance?
16:43:29 <Cale> Expr -> Expr -> M t
16:43:32 <kmcallister> (this is a problem because it's an embedded syntax for C and i want it to be nice to work with)
16:43:43 <kmcallister> Cale, then i'd need to generate a return value of type t, yes?
16:43:53 <Saizan> undefined
16:43:55 <Cale> Just return undefined.
16:44:02 <kmcallister> i tried this and it evaluated the undefined
16:44:04 <Cale> It's the only value you can choose, in fact.
16:44:08 <kmcallister> even though it was being sequenced with (>>)
16:44:25 <Cale> It'll only evaluate the undefined if you force it to by pattern matching.
16:44:59 <Saizan> or your monad uses seq
16:45:07 <LoganCapaldo> or both
16:45:10 <LoganCapaldo> 'weee
16:45:19 <Cale> !paste
16:45:20 <hpaste> Haskell paste bin: http://hpaste.org/
16:46:14 <hpaste>  Cale pasted "Regular code for dons" at http://hpaste.org/5074
16:46:42 <hpaste>  Cale annotated "Regular code for dons" with "part II" at http://hpaste.org/5074#a1
16:46:51 <dons> thanks Cale!
16:47:23 <kmcallister> yeah it's being forced for some reason
16:47:29 <kmcallister> i'm using the State monad
16:47:33 <kmcallister> which should be lazy
16:47:42 <kmcallister> (it does the same thing even if i import Control.Monad.State.Lazy)
16:47:51 <twanvl> are you using 'return undefined' or just 'undefined'?
16:47:57 <Cale> kmcallister: How are you calling it?
16:48:01 <kmcallister> twanvl, the former
16:48:10 <Cale> () <- c
16:48:12 <Cale> won't work
16:48:21 <Cale> but c on its own should
16:48:27 <kmcallister> right, it's just the expression
16:48:31 <Cale> hm
16:51:01 <kpreid> I'm not certain it's relevant, but have you seen http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html ?
16:51:02 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2948p6
16:52:32 <kmcallister> kpreid, thanks, this looks useful
16:52:49 <kmcallister> although i'm extracting the C AST rather than actually doing stuff
16:53:38 <BMeph> I know I'm missing something, but does the way printf works have any relevance to this issue?
16:53:57 <kmcallister> BMeph, you mean the variadic args trick?
16:55:02 <BMeph> kmcallister: No, the PrintfType class trick.
16:55:39 <kmcallister> i think that is the variadic args trick
16:55:41 <kmcallister> (PrintfArg a, PrintfType r) => PrintfType (a -> r)
16:55:54 <BMeph> Well, the part where it's printable things, and the IO action of printing things.
16:56:21 <kmcallister> yeah, that is like what i'm trying to do
16:56:44 <BMeph> Yes, there's the caradic args trick thrown in there for S&G's (well, not really, but it feels like that sometimes). ;)
16:56:53 <BMeph> s/caradic/varadic/
16:57:29 <monochrom> cardiac :)
16:58:26 <hexpuem> whats the difference between "newtype X b a = X (b -> (b, a))" and "newtype X b a = X (b, a)"?
16:58:53 <kpreid> hexpuem: a function.
16:58:54 <ddarius> hexpuem: Why would you think they are the same?
16:58:57 <kmcallister> hexpuem, the type of the field to the constructor X
16:59:04 <kmcallister> in the first case X :: b -> (b, a) -> X b a
16:59:09 <kmcallister> in the second X :: (b, a) -> X b a
16:59:20 <hexpuem> thanks
16:59:22 <kpreid> the first is like the state monad; the second is just a renaming of tuples
16:59:41 <Tac-Tics> It's also probably more useful to define the latter as
16:59:42 <Tac-Tics> newtype X b a = X b a (without the tuple syntax)
16:59:58 <kpreid> Tac-Tics: you can't do that with newtype.
16:59:59 * BMeph would love to apply the varadic args tric to renamed tuples
17:00:21 <Tac-Tics> kpreid: really?
17:00:25 <Heffalump> "renamed" tuples?
17:00:31 <monochrom> Eh? You can't newtype X b a = X b a.
17:01:01 <kmcallister> Tac-Tics, newtype must have a single constructor with a single field
17:01:09 <kmcallister> (at most one field?)
17:01:24 <monochrom> I haven't seen newtype with no field. :)
17:01:31 <kmcallister> the reason being that newtype uses the implementation of the underlying type, so unlike data there's no runtime wrapping/unwrapping
17:01:43 * Tac-Tics learns
17:01:45 <kmcallister> (this is an awesome feature btw)
17:02:06 <Tac-Tics> Newtype is just a distinct aliasing, I remember now
17:02:20 <kmcallister> lets you introduce new types for the typechecker without changing the runtime implementation
17:02:21 <LoganCapaldo> newtype with no field would be a "clearer" way to do data Void perhaps?
17:02:43 <kmcallister> newtype Void = Void
17:02:44 <kmcallister> is not the same
17:03:04 <LoganCapaldo> I was thinking netwype with no field would look like newtype Void
17:03:04 <kmcallister> it has one non-_|_ value
17:03:14 <kmcallister> then you've just changed the word "data" to "newtype"
17:03:20 <LoganCapaldo> yes
17:03:21 <kmcallister> i guess it's a bit clearer, given that no "data" is being declared
17:04:09 <LoganCapaldo> that's what I was thinking
17:04:18 <LoganCapaldo> otherwise it's pretty useless <g>
17:06:17 <Heffalump> newtype has a very specific form, and empty ones don't fit into that form
17:06:35 <kmcallister> okay, i fixed my IsExpr problem
17:06:37 <Heffalump> or the semantics of newtype; they don't have a bottom
17:06:50 <kmcallister> it was a stupid bug elsewhere
17:06:55 <kmcallister> that for some reason typechecked
17:07:03 <kmcallister> possibly because of the (->) r monad ;0
17:07:04 <radetsky> can ghci be made to look for modules in .hsc files?
17:07:08 <LoganCapaldo> all the more reason to have it then, then your Void really is Void :)
17:07:47 <Heffalump> LoganCapaldo: but let x :: Void ; x = x in ... defines x to be bottom
17:08:39 <LoganCapaldo> well if you extend the syntax you can presumably extend the type checker too
17:08:59 <Heffalump> it'd have to be with a nasty ad-hoc rule
17:09:01 <LoganCapaldo> tbh I do't really think this is all that great of an idea, but it's fun being stubborn :)
17:09:38 <Heffalump> :-)
17:09:41 * Heffalump wanders off
17:11:12 <Botje> is there a list of "recommended papers" somewhere?
17:11:22 <Botje> I'm reading up on phantom types now, but some other stuff would ben eat
17:11:28 <Botje> *be neat
17:12:03 <dons> http://haskell.org/haskellwiki/Research_papers
17:12:21 <Botje> doh. thanks!
17:12:40 <radetsky> nobody knows
17:12:41 <radetsky> crap
17:16:04 <monochrom> Who is ben and why does he eat papers? :)
17:16:18 <Cale> heh, I can now test if regular expressions match a string by simply constructing the regular expression matching only that string, and then using language containment
17:16:26 <Cale> dons: let me give you some extra code :)
17:16:35 <monochrom> You are sick. :)
17:17:09 <dons> oh, that's awesome.
17:17:22 <hpaste>  Cale annotated "Regular code for dons" with "containment and equality checking" at http://hpaste.org/5074#a2
17:17:24 <dons> Cale, so does that mean i have a model against which i can check pcre functions?
17:17:46 <Cale> Well, quite possibly :)
17:17:55 <dons> i give QC a string, you give me a regex to match it, i treat that as a pcre regex, and check both the model and the pcre one, match the same string?
17:18:42 <Cale> That seems like it should work.
17:18:57 <dons> this looks very cool
17:19:37 <Cale> Er, actually, Data.Maybe isn't needed.
17:19:45 <Cale> I ended up using a singleton list for that
17:20:24 <ddarius> Cale: Is this regular expression minimal or something, otherwise isn't it kind of boring...?
17:20:39 <Cale> which regular expression?
17:20:57 <Cale> I'm only building NFAs from regular expressions, not the other way around.
17:21:35 <Cale> Those NFAs are nowhere close to minimal, but it doesn't matter. I'm only using them because it's easy to check that they're in the same state.
17:22:03 <ddarius> [18:15] <Cale> heh, I can now test if regular expressions match a string by simply constructing the regular expression matching only that string, and then using language containment
17:22:31 <Cale> well, that regular expression is likely minimal, it's just  Prod (map Sym string)
17:23:02 <BMeph> Cale: Code pusher! ;p
17:23:11 <Cale> (yes, this is a dumb application of language containment :)
17:23:40 <ddarius> Cale: This wouldn't be too useful for dons QCing pcre then.
17:24:58 <radetsky> anybody know how to make ghci look for modules is .hsc files, or if this is possible?
17:26:03 <dons> radetsky: using a .cabal file is easiest
17:26:09 <dons> since it will run the preprocessor for you
17:26:41 <radetsky> dons: how do you mean? "ghci file.cabal"?
17:26:41 <hpaste>  Cale annotated "Regular code for dons" with "example of equivalent regular expressions" at http://hpaste.org/5074#a3
17:27:27 <dons> radetsky: no. to do that, you'll need to run hsc2hs by hand first
17:27:45 <radetsky> ahh
17:27:54 <radetsky> thanks
17:28:18 <radetsky> (I'm trying to step through hmp3)
17:29:00 <scook0> mm, cabal-install is nice :)
17:29:04 <scook0> pain to set up though
17:31:30 <dons> Cale: i'll integrate this into my lib when i get home. thanks!
17:32:17 <dons> man, tooooob is such a fun math/fp troll
17:32:20 <dons> "In a purely functional world we'd have an infinite number of web pages, but every time you retrieved a given URL it would be exactly the same. Completely unrealistic."
17:33:50 <EvilTerran> the latter is already possible, in p2p and suchlike situations where things are identified by a UID or checksum or whatever
17:35:57 <monochrom> Let the trolls lead the trolls.
17:36:02 <hpaste>  kmcallister pasted "possible embedded C syntax" at http://hpaste.org/5075
17:36:28 <kmcallister> is this lightweight enough to be usable for procedurally generating snippits of C?
17:37:33 <kpreid> kmcallister: looks great to me
17:38:27 <hpaste>  kmcallister pasted "renders to (approximately)" at http://hpaste.org/5076
17:38:36 <eugman> How good would haskell be for making a text adventure?
17:38:58 <Botje> how well do you know it?
17:39:30 <eugman> Not at all. I'd have some time to learn it beforehand however.
17:40:01 <kmcallister> i imagine it would work out all right
17:40:11 <kmcallister> if you're looking for a haskell exercise you should probably do something else
17:40:16 <Botje> if you do, you might want to look at parsec for the frontend
17:40:24 <kmcallister> and if you just want to write a text adventure in any language, haskell is not the easiest
17:40:27 <Botje> and some kind of zipper over rooms to handle state transitions
17:40:34 <Botje> or just use IO all over the place :)
17:40:40 <kpreid> my personal experience says that doing such things in haskell requires careful thought about your points of mutability
17:40:55 <eugman> Well I have a programming language class and will have a final in a few month. I want to do it in a mind blowing langauge like lisp, haskell or prolog
17:40:57 <kpreid> on the other hand, maybe zippers solve that problem; I didn't know about the concept then
17:41:19 <ddarius_> kmcallister: What is the easiest?
17:41:30 <Botje> "whichever you know best"
17:41:32 <Botje> obviously.
17:41:49 <kmcallister> ddarius_, i would say python, all other things being equal
17:42:00 <ddarius_> kmcallister: Why?
17:42:24 <kmcallister> well, i don't want to be accused of language trolling ;)
17:42:38 <eugman> python is such a nice language of the few I ahve experience with.
17:42:47 <kmcallister> it's very pragmatic
17:43:03 <kmcallister> it's also good for manipulating text (not parsing CFGs particularly, but lower level stuff)
17:43:03 <moonlite> i don't see it
17:43:08 <kmcallister> which i imagine would be useful in a text adventure
17:43:18 <Botje> well, so is perl
17:43:27 <ddarius_> kmcallister: There are many languages that meet those criteria.
17:43:27 <kmcallister> perl has way too much magic, and awful syntax
17:43:40 <kmcallister> i used to be a perl zealot but after learning python there was really no reason to use perl ever
17:43:42 <Botje> i don't find it too bad
17:43:52 <kmcallister> i use python or haskell for 95% of the programming i do, and i'm very happy with that :)
17:43:53 <radetsky> python cannot execute line noise
17:44:02 <kmcallister> Botje, it's not so much that it's bad as that python is strictly better in almost every way
17:44:06 <radetsky> perl can
17:44:06 <dons> kmcallister: s/haskell/python/ and i feel exactly the same :)
17:44:20 <eugman> Well I basically have two goaals and I'd like to meet one. Do something interesting ( a text adventure would qualify) and learn an unusual language.
17:44:25 <dons> i have zero need for perl now. all my little scritps are haskell
17:44:34 <kmcallister> eugman, i would suggest doing something more interesting in Haskell ;)
17:44:36 <Botje> I use perl for the odd data munging job nowadays
17:44:42 <kmcallister> write a scheme interpreter in haskell
17:44:54 <Botje> other than that, i'm using haskell for project euler
17:45:04 <eugman> Kmcallister, a reasonable suggestion. I'd have to think of something quite suitable to haskell's strengths
17:45:06 <dons> Botje: so that's what i use haskell for now. its surprising how useful: main = interact (unlines. map f . lines) is for this
17:45:11 <monochrom> I use Haskell to factor primes.
17:45:12 <Botje> and i'm thinking of writing my compiler in haskell
17:45:19 * ddarius_ would find a text adventure far more interesting than a Scheme interpreter.
17:45:23 <Botje> dons: true, but not as handy as perl -lape '.....'
17:45:28 <eugman> And more personally useful
17:45:32 <sjanssen> @seen dcoutts
17:45:32 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 4h 56m 53s ago.
17:45:38 <dons> right, but the body of 'f' is giong to be more robust
17:45:44 <Botje> perhaps my haskell-fu isn't as strong as my perl-fu yet
17:45:51 <dons> since you get to use real data structures and functions :)
17:46:07 <Botje> well, by "data munging job" I mean "80 characters of perl or less"
17:46:09 <sjanssen> @seen dcoutts_
17:46:10 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts_ speak 2h 2m 13s ago.
17:46:26 <dons> Botje: ah,i was more in the 800 chars range
17:46:27 <ddarius_> Not those paper mache ones of Perl
17:46:35 <dons> 20 lines or so.
17:47:13 <Botje> haven't tried haskell for such big things yet
17:47:17 <dons> scripts beyond about 5 lines i exclusively do in haskell now -- you get to compile them to C-like string processing speed, and they just don't seem to break
17:47:32 <eugman> So any ideas of something that would fit very well with haskell's strengths and could be programmed without ahving programmed something similar before?
17:47:34 <Botje> ddarius_: that's exactly what they are, throw-away oneliners. so why not use perl :)
17:47:35 <dons> + most scripting jobs are usually parsing and pretty printing tasks, or light math
17:47:49 <ddarius_> Botje: Because I hate perl with a burning passion
17:47:50 <dons> all of which are seriously well done in haskell
17:48:09 <dons> eugman: parsers are a great task.
17:48:10 <Botje> ddarius_: it's not too bad :)
17:48:20 <Botje> not as hateful as, say, latex
17:48:30 <ddarius_> Botje: I didn't say anything about the language, just about my feelings for it.
17:48:34 <dons> translate some common format into a haskell data structure, using parsec, then pretty print it out.
17:48:40 <monochrom> I don't hate any language.
17:48:43 <eugman> dons, certainly interesting. It doesn't seem very approachable but I've never tried
17:49:56 <dons> eugman: what kind of programs do you like to write?
17:50:03 <Botje> language preferences aside, i'm thinking of making a trading game in haskell
17:50:04 <dons> i'd suggesting something that involved data structures
17:50:15 <dons> i.e. building ASTs and traversing them, or something like that.
17:50:22 <Botje> kind of like Ports of Call or Zapitalism
17:50:38 <eugman> Dons, honestly not that much experience. I've made some decent games in python and done all the plain stuff one does in a c++ class.
17:50:55 <dons> you could write a game
17:51:13 <dons> people seem to enjoy doing opengl games as haskell intros
17:51:25 <kmcallister> eugman, you could write a game in haskell, it's just that if the goal is to bend your mind and learn a new language, you will probably be disappointed writing a game
17:51:30 <dons> see http://haskell.org/haskellwiki/Applications_and_libraries/Games
17:51:39 <kmcallister> you won't get to use as many of the cool Haskell features, and you'll have to do a lot of tedious stuff
17:51:51 <kmcallister> eugman, are you learning haskell on your own?
17:52:00 <dons> an implementation of blokus in gtk/cairo would be awesome :)
17:52:00 <ddarius> People have written most or all of the "usual" intro programs in Haskell.
17:52:22 <Tac-Tics> I think someone needs to rewrite something like Megazeux in Haskell
17:52:32 <ddarius> kmcallister: Why wouldn't you get to use as many of the cool Haskell features?
17:52:33 <Tac-Tics> Using Haskell for the bot scripting language
17:53:06 <kmcallister> ddarius, i guess you could learn FRP as you learn the language, but it's not something i would want to do :)
17:53:07 <eugman> kmcallister, quite so. That's why the thought of text adventure. It's more text based than the normal 2d stuff. I don't think blokus would have any predisposition to haskell. Ooooh a irc bot would be sweet.
17:53:21 <clanehin> what cool features does one not get to use writing games in haskell?
17:53:31 <dons> well, blokus would be a bit of a constraint solving problem -- if you did the ai
17:53:46 <dons> some basic data structure stuff
17:54:15 <kmcallister> actually
17:54:15 <eugman> I wonder how big the option tree for blokus is.
17:54:21 <kmcallister> a cool game would be some kind of programming puzzle game
17:54:26 <kmcallister> where you code robots that move around, or whatever
17:54:31 <dons> i'm not sure if blokus has been studied yet
17:54:42 <kmcallister> you'd get to use some of the coolest parts of haskell (the ease of implementing other languages with/in it)
17:54:51 <dons> there's some interesting tactics, and its a tiling puzzle, so you can reuse some traditional algos
17:54:53 <eugman> checkout droidbattles it's bots running some form of assembly
17:55:06 <kmcallister> eugman, in haskell i would use a FP language for the bots
17:55:08 <kmcallister> for solidarity ;)
17:55:23 <EvilTerran> use haskell!
17:55:32 <clanehin> dons: basic data structure stuff, like zippers?
17:55:36 * clanehin senses a challenge
17:55:51 <dons> oh hmm...
17:56:20 <dons> you could represent the game state as a zipper, yeah
17:56:34 <eugman> Ok so the two idea's I'm definitely thinking I'd like would be text adventure or irc bot. Any other suggestions of things that might work in Lisp, haskell or prolog?
17:56:41 <nelhage> ?hoogle (a -> b -> c) -> m a -> m b -> m c
17:56:42 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
17:56:42 <lambdabot> Data.Function.flip :: (a -> b -> c) -> b -> a -> c
17:56:42 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
17:56:42 <dons> -- you'd get a natural 'undo' ability :)
17:56:53 <eugman> although some of these other suggestios are interesting
17:57:05 <nelhage> Hmm. It seems like that should find liftM2, no?
17:57:11 <dons> irc bot is interesting, you quickly get into monads (for interactive state), and concurrency
17:57:15 <dons> a bit of parsing
17:58:03 <nelhage> So where can I read about these `zipper' things people keep mentioning in here?
17:58:09 <dons> also, i don't know of an open source "free blokus"...
17:58:19 <dons> so you could be quite successful, assuming you avoided copyright/patent issues
17:58:28 <ddarius> @where zipper
17:58:28 <lambdabot> I know nothing about zipper.
17:58:37 <eugman> yeah, it certainly feels within my range. A turing test bot would be interesting but seems too hard to make a good one.
17:58:53 <dons> something that people will want to use is always more motivating
17:59:02 <eugman> That's true
17:59:05 <monochrom> the haskell wiki has an entry on zipper. may be a good start.
17:59:08 <ddarius> dons: Only once they start using it.
17:59:09 <dons> you could implement a ruby that supported transactional memoyr
17:59:22 <ddarius> Be the Audrey Tang of the Ruby world.
17:59:25 <dons> i've a theory that a ruby compiler can't be too hard.
17:59:30 <dons> and you'd get ridiculously famous
17:59:31 <eugman> But I doubt my first something in a new language will be good enough code to garner interest
17:59:45 <eugman> gah. I know nothing of compiler
17:59:50 <eugman> s
18:00:00 <dons> neither do the ruby guys!
18:00:07 <dons> but that didn't stop them. :)
18:00:10 <ddarius> dons: It's not hard to make something that would be far more performant than the current implementations, but probably hard to make something -fast-.
18:00:24 <ddarius> dons: Yes it did.
18:00:35 <kmcallister> dons, did you see the embedded C syntax example i hpasted above?
18:00:38 <dons> ddarius: isn't compiled smalltalk well documented?
18:00:44 <dons> kmcallister: oh....
18:00:56 <kmcallister> http://hpaste.org/5075 http://hpaste.org/5076
18:01:16 <dons> kmcallister: very nice.
18:01:16 <ddarius> dons: And most Smalltalks aren't fast.
18:01:27 <kmcallister> dons, thanks, do you think it's lightweight enough for actual use?
18:01:41 <dons> kmcallister: well, there's probably some more things you can do there.
18:02:01 <kmcallister> (that particular syntax is about 90% implemented at the moment, although i'm probably going to start over soon)
18:02:04 <dons> like  =: for assignment? check augustss' posts on embedded asm dsls.
18:02:20 <kmcallister> i have =# for assignment right now
18:02:32 <dons> http://haskell.org/haskellwiki/Blog_articles/EDSLs
18:02:47 <dons> this is a good one, http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html
18:02:48 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2948p6
18:02:56 <dons> fac n = do {
18:02:56 <dons>     a <- auto 1;
18:02:56 <dons>     i <- auto n;
18:02:56 <dons>     while (i >. 0) $ do {
18:02:56 <dons>         a *= i;
18:02:59 <dons>         i -= 1;
18:03:03 <dons> tha'ts the haskell edsl
18:03:10 <kmcallister> dons, i read that and it looks cool
18:03:23 <kmcallister> but i'm not sure how well it could be used to construct an AST versus execute on the spot
18:03:30 <dons> that's true.
18:04:09 <dons> ddarius: i guess we don't really want to encourage the kind of ad hoc monkey patching approach to coding ruby promotes
18:04:36 <dons> but then again, pugs did about as much for haskell as it did for perl6.
18:04:55 <ddarius> dons: Why not?  If it's a good idea then it's a good idea, if it isn't people will get burned and come here.
18:05:26 <ddarius> By getting the main implementation of all such languages in Haskell, Haskell would win either way!
18:05:38 <jsnx> yeah
18:05:41 <jsnx> haskellvm
18:06:00 <eugman> Obviously the best language for writing a compiler would be brainfuck ;)
18:06:12 <jsnx> eugman: lolz -- only if it's J
18:06:23 * BMeph contemplates a Factor interpreter in Haskell
18:06:35 <ddarius> BMeph: Should be pretty easy.
18:06:48 <eugman> Nah, make a haskell interpreter in brainfuck!
18:06:59 <sarehu> Nah, make a Haskell->Brainfuck compiler
18:07:29 <kmcallister> wow, harpy looks very cool
18:07:51 <BMeph> ddarius: Well, yes. However, you'd have to think a lot about Factor. I liked FORTH, but I'm not to sure about the "next generation" version.
18:08:02 <BMeph> s/to/too/
18:08:42 <ddarius> You overestimate "a lot"
18:11:49 <kmcallister> hmm
18:12:00 <kmcallister> so really, for the purposes i have in mind, i don't need to provide C syntax exactly
18:12:18 <kmcallister> but rather any embedded language that can easily be compiled to and subsequently linked with C
18:13:38 <ddarius> kmcallister: Why not use Haskell as that embedded language?
18:14:54 <kmcallister> because i want to use this for implementing JIT VMs efficiently
18:15:13 <kmcallister> besides all the pieces of that already exist
18:15:23 <kmcallister> (Template Haskell, hsplugins, GHC as a library)
18:18:06 <kmcallister> food, bbl
18:47:16 <bparkis> in lambda calculus there is a lot of complexity spent on scoping rules
18:47:34 <bparkis> but wouldn't it be simpler to decree that all variable names must be unique
18:47:53 <bparkis> ie give every variable global scope
18:47:57 <EvilTerran> bparkis, what about recursion?
18:48:49 <EvilTerran> however, there's something called de Brujin notation, which does something similar to that
18:49:18 <Tac-Tics> bparkis: That just shifts where the complexity goes
18:49:39 <Tac-Tics> In regular, shadowable variable LC, the responsibility is on the compiler/interpreter
18:49:46 * ddarius plays with HPC.
18:49:54 <Tac-Tics> if you require global names, you require the programmer to keep track of everything him or herself
18:50:13 <EvilTerran> id = \.0; const = \.\.1; s = \.\.\.2 0 (1 0)
18:50:42 <ddarius> EvilTerran: But you still need to "shift" the indices.
18:50:51 <EvilTerran> etc
18:51:17 <EvilTerran> hm, that's true... i can't quite remember how fiddly that is, but i imagine it's easier than scoping named variables
18:52:07 <Tac-Tics> of course, it's really easy to write a program to make unique ids out of all your variable names
18:53:03 <Tac-Tics> Walk down the expression tree, and whenever you come to a bottom-level lambda form, you replace the body's instances of the bound variable with a gensym'd variable unique to the tree
18:53:19 <EvilTerran> but then you meet recursion
18:53:52 <bparkis> well, you can always translate the program into combinatory logic in order to evaluate it
18:53:59 <Tac-Tics> If you use the Y comb, it won't matter, but I dunno about if you use letrecs
18:54:02 <ddarius> EvilTerran: Also as a side not usually the . is dropped when using de Bruijn notation.  \\1
18:55:06 <ben> hey guys what does .
18:55:10 <bparkis> i'm trying to get at the idea of what a variable is, and i'm guessing that the issue of scope is beside the point... that a variable is a unique identifier
18:55:26 <ben> what does the . dot mean in haskell
18:55:31 <EvilTerran> ?src .
18:55:32 <lambdabot> (.) f g x = f (g x)
18:55:42 <EvilTerran> (f . g) x = f (g x)
18:55:57 <EvilTerran> it composes two functions together
18:56:01 <EvilTerran> ?where tutorial
18:56:01 <lambdabot> http://www.haskell.org/tutorial/
18:56:09 <EvilTerran> is a good start for picking up the basics like that
18:56:31 <bparkis> in c a variable corresponds to a unique memory location
18:57:25 <ben> what is the name of it
18:57:28 <monochrom> in haskell a variable refers to an expression
18:57:40 <monochrom> . is "composition", "compose"
18:57:58 <monochrom> also "dot"
18:58:08 <Tac-Tics> > ( (+2) . (+1) ) 0
18:58:08 <zeloran> is there any substring function in haskell?
18:58:12 <lambdabot>  3
18:58:25 <bparkis> a variable isn't exactly an expression because a variable x could equal the expression 3 + 4 and it could also equal the expression 7
18:58:30 <bparkis> depending on the order of evaluation
18:58:53 <Tac-Tics> @hoogle [a] -> [a] -> Bool
18:58:53 <monochrom> Right, but I said "refer", not "equal".
18:58:54 <lambdabot> Data.List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
18:58:54 <lambdabot> Data.List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
18:58:54 <lambdabot> Data.List.isInfixOf :: Eq a => [a] -> [a] -> Bool
18:58:57 <dons> ?users
18:58:57 <lambdabot> Maximum users seen in #haskell: 454, currently: 393 (86.6%), active: 10 (2.5%)
18:59:05 <Tac-Tics> @src isInfixOf
18:59:05 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
18:59:19 <Tac-Tics> > isInfixOf "ban" "banana"
18:59:20 <lambdabot>  True
18:59:27 <Tac-Tics> > isInfixOf "apple" "banana"
18:59:27 <lambdabot>  False
18:59:52 <Tac-Tics> zeloran: apparently, isInfixOf =-)
19:01:06 <dons> stm in F#, http://cs.hubfs.net/blogs/hell_is_other_languages/archive/2008/01/16/4565.aspx
19:01:10 <lambdabot> Title: Hell Is Other Languages : Software Transactional Memory for F#, http://tinyurl.com/2sfhot
19:01:29 <bparkis> in c a variable always refers to the normal form of an expression, which is stored in memory
19:01:30 <zeloran> hmm i need a function that takes a list and returns all elements starting from an index to an index
19:01:46 <zeloran> example: substring "abcdef" 2 3 = bcd
19:02:10 <bparkis> and the variable is as simple as a pointer to the start of the reduced expression in memory
19:03:15 <jfredett> zeloran, you could just do a drop-take approach
19:03:16 <bparkis> so you could think of memory as a function from numbers to expressions in normal form
19:03:31 <jfredett> let substr x y s = take y $ drop x s
19:03:49 <BMeph> What was that, ((take.).drop? :)
19:03:50 <jfredett> > let substr x y s = take y $ drop x s in substr 2 3 "abcdef"
19:03:52 <lambdabot>  "cde"
19:04:09 <ramza3> is it possible to have two cabal files in the same directory
19:04:17 <jfredett> well, up to some indexing, it works
19:04:19 <allbery_b> @pl \x y s -> take y $ drop x s
19:04:19 <lambdabot> flip ((.) . take) . drop
19:04:21 <ramza3> and execute one or the other
19:04:43 <zeloran> thx
19:05:11 <jfredett> > (\x y s -> ((take x) . (drop y)) s) 2 3 "abcdef"
19:05:12 <lambdabot>  "de"
19:05:28 <jfredett> > (\x y s -> ((take y) . (drop x)) s) 2 3 "abcdef"
19:05:29 <lambdabot>  "cde"
19:05:39 <jfredett> that looks better than the @pl version, methinks
19:05:46 <jfredett> even if it has bound variables
19:06:09 <jfredett> whats the benefit of point-free style, anyway? besides cool factor?
19:06:28 <ddarius> jfredett: @pl is not point-free style.
19:06:39 <EvilTerran> i'd be tempted to drop the s from both sides of that lambda, tbh
19:06:48 <jfredett> ddarius: regardless, whats the benefit of @pl?
19:07:02 <sjanssen> jfredett: it can make code more clear
19:07:07 <ddarius> jfredett: Entertainment primarily.
19:07:22 <EvilTerran> altho @pl is more of a technical curiosity than anything else in most cases
19:07:22 <jfredett> flip ((.) . take) drop =/=> clarity. :P
19:07:35 <sjanssen> @pl map f (filter p (map g (nub xs)))
19:07:35 <lambdabot> map f (filter p (map g (nub xs)))
19:07:40 <monochrom> But (drop x) . (take y) is.
19:07:44 <EvilTerran> pointsfree code does sometimes make certain patterns clearer, tho
19:07:45 <sjanssen> @pl \xs -> map f (filter p (map g (nub xs)))
19:07:46 <lambdabot> map f . filter p . map g . nub
19:08:03 <jfredett> i suppose its a bit nicer, sjanssen
19:08:09 <sjanssen> jfredett: see how it is more obvious that we've got a pipe-line of functions there?
19:08:14 <jfredett> yah
19:08:30 <jfredett> whats the difference between @pl and point-free, then?
19:08:40 <dons> this is why function composition should be a short, infix op in an FP language
19:08:43 <sjanssen> we can also avoid giving names to things that don't deserve them
19:08:55 <EvilTerran> not all point-free code can be generated as output from @pl
19:09:06 <jfredett> EvilTerran: do you know any examples?
19:09:09 <monochrom> Sometimes @pl gives bad code.
19:09:13 <Pseudonym> http://osteele.com/archives/2008/01/what-every-programmer-needs-to-know-about-category-theory
19:09:14 <lambdabot> Title: What Every Programmer Needs to Know About Category Theory at Oliver Steele, http://tinyurl.com/2ljvcu
19:09:15 <EvilTerran> it doesn't find the simplest version, only the most pointsfree
19:09:21 <Pseudonym> My comment isn't moderated yet.
19:09:22 <jfredett> ahh
19:09:28 <jfredett> okay
19:09:40 <jfredett> that makes sense.
19:09:42 <sjanssen> EvilTerran: it is true that all successful output from @pl is pointfree
19:09:58 <ddarius> point-free is a style, @pl is a tool
19:10:01 <EvilTerran> yes, but not all pointfree code is a successful output from @pl
19:10:19 <EvilTerran> it doesn't use (&&&) and (***), for instance
19:10:21 <EvilTerran> (iirc)
19:10:28 <ddarius> The difference between the output of @pl and something in "point-free style" is like the difference between the C code produced by GHC and hand-written C code.
19:10:38 <monochrom> Hahaha
19:10:54 <jfredett> ddarius: ah. makes perfect sense now
19:11:09 <sjanssen> ddarius: I think this is a false comparison
19:11:23 <sjanssen> ddarius: just because the output of @pl might be ugly, doesn't mean that it isn't pointfree
19:11:25 <dons> well, its an extreme characterisation
19:11:27 <jfredett> although, I've seen some nasty handwritten C code
19:11:40 <ddarius> sjanssen: When did I say it wasn't point free?
19:11:58 <ddarius> Point-free style is usually not "strictly" point-free.
19:11:59 <dons>  @pl enabled us to explore pointfree -- we hardly ever saw it to the extent it exists now.
19:12:05 <dons> it has a strange, addictive quality
19:12:13 <BMeph> Oh, great - "In his spare time he teaches category theory to fourth graders."
19:13:07 <ddarius> Typical code in a "point-free" style looks like, foldr c n . filter p . map f not like
19:13:17 <ddarius> @pl \c n p f -> foldr c n . filter p . map f
19:13:18 <lambdabot> flip flip ((. map) . (.) . filter) . (((.) . (.) . (.)) .) . foldr
19:13:31 <EvilTerran> (((.) . (.) . (.)) .) - wow, that's quite something
19:14:09 <nelhage> :t ((.) . (.) . (.))
19:14:11 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
19:14:23 <ddarius> (.) . (.) . (.) is well understood by now.
19:14:30 <monochrom> Is Oliver Steele trying to say there are programmers who don't need to know any category theory? :)
19:14:49 <Pseudonym> The comment that I left is that only good programmers need to know it.
19:15:16 <Pseudonym> True, a Visual Basic macro-hacking script kiddie probably doesn't need any category theory.
19:15:49 <ddarius> That's one of the truest blog posts ever.
19:15:51 <Pseudonym> Nor does a system programmer, probably.
19:16:11 <Pseudonym> The thing is:
19:16:15 * shapr yawns
19:16:17 <shapr> yarr!
19:16:20 <Pseudonym> As we've discovered many times on #haskell...
19:16:32 <Pseudonym> Those who reinvent monads are doomed to learn them.
19:16:53 <Pseudonym> (Hell, we won't let them avoid it.)
19:17:27 <monochrom> Those who know monads are doomed to repeat teaching them. :)
19:17:36 <EvilTerran> ?type flip flip (fmap (`fmap` fmap) fmap `fmap` filter) `fmap` (fmap $ fmap fmap fmap fmap fmap $ fmap $ fmap fmap fmap) foldr
19:17:36 * monochrom has Cales in mind :)
19:17:36 <lambdabot> forall a a1 (f :: * -> *) a2 b (f1 :: * -> *) a3. (Functor f, Functor f1) => (a3 -> (a2 -> b) -> a2 -> b) -> (((a1 -> Bool) -> (a -> a1) -> [a] -> [a1]) -> a2 -> b) -> [a3] -> f (f1 a2) -> f (f1 b)
19:17:50 <geezusfreeek> !!!
19:17:53 * EvilTerran ponders writing an @fmap for \botr
19:18:30 <sclv> haha grr I just spent a good 3 minutes trying to mess with flash/javascript protection on my browser to see the osteele post until i "got" it...
19:19:02 <geezusfreeek> i just gave up and then came back here and read the commentary on it
19:22:12 <EvilTerran> hm... how does one get the syntax tree of a haskell expression? Language.Haskell.Parser seems to only do whole modules (ghc 6.8.2)
19:22:43 <dons> there's a hook to parse just an expression
19:22:50 <dons> or you can wrap it in  a "module M where"
19:22:54 <dons> look in lambdabot for an example
19:25:38 <EvilTerran> where's this hook?
19:38:19 <ddarius> Is the account registration thing for community.haskell.org supposed to email me anything acknowledging creation of the account?
19:39:12 * shapr has just about hit _|_
19:39:15 <shapr> I'm too sleepy.
19:39:29 <ddarius> Then sleep shapr.
19:41:15 <sjanssen> ddarius: account creation requires manual intervention from one of the admins
19:41:23 <BMeph> Wow, so this is the guy behind Laszlo? Awesome! :)
19:41:31 <sjanssen> IIRC, you should get an email once your account is created
19:42:55 <ddarius> sjanssen: I was pretty sure that was the case.  I just don't know what the turn-around time is.
19:43:23 <dons> its malcolmw or igloo, if you want to put the hussle on
19:43:47 <ddarius> It doesn't need to be hurried.
19:44:21 <glen_quagmire> is it for darcs repo?
19:44:31 <dons> repos of any type
19:44:38 <dons> but currently all darcs :)
19:46:49 <glen_quagmire> haskell has very nice community. I wonder when it'll be large enough and people start to rant about Perils of HaskellSchools
19:47:55 <glen_quagmire> sorry that's -blah
20:20:46 <dons> here's a haskell api design question.
20:20:54 <ddarius> You need an invalid hexadecimal escape in your HUnit test suite.
20:21:06 <dons> ddarius: oh?
20:21:38 <dons> well, back to my api question. i'm writing a binding to the very fast SIMD mersenne twister random generator
20:22:02 <araujo> hi dons
20:22:03 <dons> only one generator can be used at a time, in a haskell program -- that is, separate instances will clobber each other, due to mutable state in the library
20:22:15 <ddarius> That's the only part of my parsing code that isn't exercised by it (though of course this doesn't make it right)
20:22:18 <dons> so what's a good way to enforce the uniqueness :)
20:22:37 <dons> ddarius: ah. nice. i noticed today its only about 80% covered.
20:22:42 <dons> there's a few other things as well.
20:22:47 <kpreid> dons: takeRNG :: IO (Maybe RNG)
20:22:49 <dons> oh, did you combine the QC.hs and the Hunit runs?
20:22:58 <dons> ddarius: if you combine the two runs, you'll get a better result
20:23:02 <ddarius> dons: It got a good chunk of the Parsec code itself.  67% expressions.
20:23:11 <dons> cool.
20:23:28 <dons> ddarius: hpc combine hunit.tix qc.tix > foo.tix
20:23:43 <dons> kpreid: nice. so fail if they attempt to intialise it again
20:23:51 <dons> without 'deallocating' first
20:23:56 <monochrom> IO is my first thought too.
20:23:57 <kpreid> dons: yeah.
20:23:58 <dons> and do the tracking in the library
20:24:10 <kpreid> allowing deallocating means you have 'dead RNGs' though
20:24:27 <dons> well, it could be like runST, you can't leak RNGs out of scope
20:24:28 * araujo wonders if he has to send email to dons to post items on the HWN
20:24:36 <dons> araujo: that's the easiest way
20:24:58 <ddarius> araujo: That's probably the safest way.
20:25:00 <monochrom> Second thought is why the generator has to be unique.
20:25:02 <dons> this is the api at the bottom, fwiw,
20:25:03 <dons> foreign import ccall unsafe "SFMT.h init_gen_rand" c_init_gen_rand         :: UInt32 -> IO ()
20:25:07 <dons> foreign import ccall unsafe "SFMT.h gen_rand32" c_gen_rand32            :: IO UInt32
20:25:16 <dons> so a), it has to be initialised before use.
20:25:26 <araujo> dons, address?
20:25:37 <dons> dons (a) galois.com
20:26:04 <dons> so i'd like to enforce that init has been run (so return a non-forgable token)
20:26:21 <dons> and then somehow enforce that you can't rerun the init, until you're done with the current token
20:26:24 <dons> silly C :)
20:26:49 <monochrom> Well, not silly C. Silly programmer.
20:26:55 <gio123> Cale: does it works>
20:27:12 <sjanssen> dons: is it necessary for the C generator to use global state?
20:27:21 <Cale> gio123: does what work?
20:27:38 <dons>   FILE GLOBAL VARIABLES
20:27:38 <dons>   internal state, index counter and flag
20:27:45 <dons> well, there's a bunch of internal structures
20:27:47 <gio123> Cale: code pasted u
20:27:52 <sjanssen> oh, this is a binding to an existing C lib?
20:27:55 <Cale> gio123: Yeah, it works.
20:27:58 <dons> static w128_t sfmt[N];
20:28:10 <gio123> Cale: do u have some time?
20:28:10 <dons> sjanssen: yeah, the high performance magic random generator
20:28:28 <dons> so you should be able to give it your own state
20:28:35 <monochrom> My third thought is let's port the code to Haskell.
20:28:40 <monochrom> Err the algorithm.
20:28:42 <Cale> gio123: time for what?
20:28:53 <dons> monochrom: it relies on very low level compiler details
20:29:01 <dons> simd instructions.. you can't get those from ghc
20:29:09 <dons> http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/index.html
20:29:11 <lambdabot> Title: SIMD-oriented Fast Mersenne Twister (SFMT)
20:29:11 <dons> is the lib
20:29:26 <dons> i've used it -- its stunningly faster than C's std randoms , and ours
20:29:29 <gio123> Cale: in the paper he makes <_0 old, and keeps it i didnt undestand point why he does it
20:29:51 <gio123> Cale: can u pm me?
20:29:52 <monochrom> My fourth thought is let's modify the C code to be non-unique.
20:29:59 <Cale> gio123: because otherwise you'll end up unfolding the same term over and over again
20:29:59 <dons> but, it doesn't mesh nicely with System.Random, unless we can think of a way to make it work with StdGen
20:30:06 <dons> monochrom: yeah, perhaps feed in the arrays
20:30:11 <dons> and pass them around in the StdGen
20:30:14 <dons> then we'd be fine.
20:30:22 <sjanssen> isn't it possible that this will kill performance?
20:30:38 <dons> i think the core is in the heavy math stuff
20:30:57 <gio123> Cale: can u show example?
20:30:58 <dons> though it does add indirectoins, yeah
20:31:03 <monochrom> I see one possible loss of performance due to non-uniqueness, and I see the solution to that.
20:31:04 <Cale> gio123: example of what?
20:31:11 <sjanssen> so, newtype RandHandle = RH (Ptr ())
20:31:19 <dons> one cool thing is that we can remove a test for initialisation
20:31:22 <dons> if we control the library
20:31:37 <dons> since the type can ensure you can't call it without having initialised it
20:31:55 <gio123> Cale: usfulness of <_0
20:32:18 <gio123> Cale: can u pm please?
20:34:27 <monochrom> The possible slowness due to non-uniqueness is, e.g., you have a tight loop to ask for many numbers - it seems you want to minimize passing parameters inside the loop. The solution is providing a "withGenerator" combinator.
20:34:49 <dons> yep you can ask this library to fill an array, anyway
20:35:03 <dons> which would provide that -- since we'd want to avoid the ffi calls in a loop as well
20:35:36 <dons> here, you can have a play with it.
20:35:37 <dons>  $ darcs get http://code.haskell.org/~dons/code/random-mersenne
20:35:37 <lambdabot> Title: Index of /~dons/code/random-mersenne
20:35:57 <dons> thanks for the advice guys - it clarifies the intent . it *has* to implement RandomGen to be useful
20:36:09 <dons> and to do that, i'll have to make it "threadsafe", but that's probably not too hard
20:36:19 <dons> and the result will be a kick butt random generator
20:36:29 <shachaf> dons: You put darcs repositories inside darcs repositories?
20:36:36 <dons> no?
20:36:58 <monochrom> Haha great. darcs repo inside darcs repo.
20:37:01 <shachaf> dons: (~dons has an _darcs.)
20:37:18 <dons> oh, that's weird.
20:37:41 <dons> fixed.
20:38:18 <dons> anyway, further feedback/investingation would be welcome :)
20:38:31 <dons> cbits/SFMT.c is also fun to look at
20:39:43 <dons> the internal state looks easy enough to pass in and out.
20:51:55 <moonlite> gah i've got a deadline for work. been working for 18h straight in an untyped homebrew language
20:52:07 <moonlite> i need my types :(
20:53:05 * shachaf gives moonlite a ().
20:53:18 <moonlite> :)
20:58:37 <tracey> spam irc.rizon.net with server address irc.hydroblunt.net
20:59:22 <Cale> tracey: huh?
21:00:47 <Nafai> moonlite: What's this language you are using?
21:00:59 <monochrom> moonlite: I'm interested too :)
21:01:23 <moonlite> "language"
21:01:39 <moonlite> it is a sort of xml to javaclasses mapping
21:02:10 <monochrom> Someone made a domain-specific language for this? At work? At school?
21:02:48 <moonlite> a crappy parser reads in tags and instantiates classes accordingly. The xml language is intended for laying out objects on a screen (more i cannot say im afraid :))
21:03:38 <moonlite> the idea is that the xml standard will make uis easy and fast to create. But it's just really really messy
21:03:41 <monochrom> OK I see, the untyped homebrew language is a subset of XML.
21:03:49 <moonlite> yep
21:03:56 <moonlite> at work btw
21:05:47 <BMeph> Sounds like you ought to give Oliver Steele a call, heh-heh. ;)
21:06:20 <radetsky> does ghci support the ffi?
21:06:25 <monochrom> Yes.
21:06:51 <radetsky> ok, it's barfing on "import"
21:06:58 <radetsky> am I doing something wrong?
21:07:04 <sjanssen> radetsky: -fffi
21:07:08 <scook0> :set -fffi
21:07:28 <scook0> (or any of the equivalent incantations)
21:07:30 <monochrom> You can use -ffi or -fffi
21:07:31 <Cale> Or is there a LANGUAGE pragma for that now?
21:07:37 <scook0> Cale: yup
21:07:37 <monochrom> That too.
21:07:41 <scook0> ForeignFunctionInterface
21:07:50 <scook0> works fine in 6.6
21:07:55 <monochrom> Just spell out the full name in CamelCase :)
21:08:13 <scook0> monochrom: that doesn't hold for LANGUAGE pragmas in general, sadly
21:08:26 <scook0> c.f. EmptyDataDecls, for example
21:08:32 <monochrom> It has to be the magically right name.
21:08:44 <monochrom> Oh! That is sinful!
21:08:50 <scook0> there are a couple of others I always get wrong, too
21:09:01 <monochrom> Should be EmptyDataDeclarationalism!
21:09:57 <scook0> a similar one is MultiParamTypeClasses
21:10:04 <scook0> eww
21:10:20 <monochrom> OK that one is in the grey area.
21:10:56 <scook0> and I tend to write "RankTwoTypes" instead of "Rank2Types", but that's another grey one
21:11:46 <gabrielmc> pardon my ignorance... There is an operator '|>' in F# so that you can pass arguments to functions as if in a pipeline, from left to right -- eg. alist |> sort |> uniq |> reverse -- whereas the layout would be reversed in Haskell -- is there an operator like that (or can I construct one -- I've tried and failed to do so)?
21:12:12 <jfredett> (.) is your op
21:12:23 <monochrom> You can import Control.Arrow and try >>>
21:12:25 <jfredett> or maybe flip (.)
21:12:32 <thoughtpolice> you can use >>> from Control.Arrow
21:12:37 <thoughtpolice> @type (>>>)
21:12:39 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
21:12:46 <monochrom> You can define |> too.
21:12:50 <jfredett> @type (flip (.))
21:12:50 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
21:13:24 <thoughtpolice> > (words >>> head >>> unwords) "hello"
21:13:25 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
21:13:38 <thoughtpolice> > (unwords >>> head >>> words) "hello"
21:13:39 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
21:14:21 <monochrom> > let f |> g = g . f in (sin |> sqrt) 0.9
21:14:22 <lambdabot>  0.885057574187964
21:15:13 <monochrom> unwords wants list of strings. try ["hello", "hullo"]
21:16:20 <nelhage> > (words >>> map (++", World") >>> unwords) "Hello Bonjour"
21:16:21 <lambdabot>  "Hello, World Bonjour, World"
21:17:19 <dons> haskell libraries comment of the day,
21:17:20 <dons>   -- hah, so you thought you were saving cycles by using Float?
21:17:20 <dons> instance Random Float where random g        = randomIvalDouble (0::Double,1) realToFrac g
21:17:38 <monochrom> Yeah :)
21:19:09 <monochrom> Ever since Intel dominated floating point arithmetic, Float ceased to be significantly more efficient than Double. Only saving is memory and memory-processor transfers.
21:19:34 <monochrom> The Intel FPU deliberately do all arithmetic at 80-bit precisions internally.
21:20:03 <monochrom> My singular-plural thingies are totally swapped in that sentence.
21:20:14 <monochrom> Damn this English language. :)
21:20:30 <monochrom> Oh, but it started from the Greeks.
21:20:52 <monochrom> Damn this whole European culture. See we Asians are better! Or were better!
21:21:23 <Tac-DDR> English would be better if they would just add closures in the next version
21:21:31 <monochrom> Hahaha
21:22:11 <nburlett> would anyone like to give me a hand and check that they can build my darcs repository?
21:23:21 <monochrom> Sparcs go further and do 128-bit precision.
21:38:32 <BMeph> BBL, need to reboot
21:41:25 <bos> monochrom: only x87 mode does excess precision, and that's now deprecated in modern chips.
21:41:44 <bos> monochrom: if you're using SSE, you get packed 32- or 64-bit arithmetic.
21:42:05 <bos> @seen dons
21:42:05 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 24m 45s ago.
21:42:41 <monochrom> I forgot SSE.
21:43:06 <monochrom> Then again System.Random doesn't use SSE yet. :)
21:43:17 <dons> bos?
21:43:21 <bos> yeah, we're a bit behind the times.
21:50:37 <dons> monochrom: that's right :)
21:50:54 <dons> but we'll have SSE2 randomGen's in short order.
21:51:40 <bos> oh?
21:51:55 <dons> i'm just finishing a binding to SIMD mersenne twister
21:52:01 <bos> nice.
21:52:13 <celske> i have installed ghc 8.6 and 6.6.2 or something.. is there anyway to choose what ghc version you want to use?
21:52:31 <shachaf> celske: ghc-$version?
21:53:29 <bos> boy, if we get good loop fusion and register allocation in a few years, we might be able to issue packed SSE FP ops natively.
21:55:11 <bos> such a thing would be a nice win over gcc, where you still have to explicitly say "i want a 4-element packed vector" when restuffing your loop by hand.
21:55:39 <celske> shachaf, bash: ghc-: command not found
21:55:54 <bos> __attribute__ ((mode(V4DF))) :: FAIL
21:56:07 <shachaf> celske: I mean, something like ghc-6.8.2.
21:56:23 <bos> celske: what OS/distro/...?
21:56:49 <celske> ubuntu, i downloaded the binaries then yeah.. just awhile ago i installed the ubuntu package for ghc
21:57:07 <celske> and when i try to do somethign with ghc it uses the 6.8.2 version which i don't want
21:57:32 <shachaf> celske: Use something like ghc-6.6.1, then.
21:57:39 <shachaf> celske: (Why don't you want to use 6.8.2?)
21:58:02 <celske> i have 6.6.2 installed also
21:58:54 <Tac-Tics> What the standard terminology to evaluate something strictly to head NF?
21:58:57 <shachaf> celske: So using `ghc-6.6.2` doesn't work?
21:59:36 <Tac-Tics> I imagine the verb would be like to "flatten" a value or dethunk or something.
21:59:37 <ac> ack. I have 5 pages of warning now that I turned on -Wall
21:59:42 <bos> Tac-Tics: deepSeq
21:59:50 <celske> what?
21:59:55 <Cale> shachaf: well, weak head normal form is available through seq
22:00:07 <Tac-Tics> err yeah
22:00:18 <Cale> normal form is provided by rnf in Control.Parallel.Strategies
22:00:32 <Cale> (which is intended to be used along with seq)
22:00:53 <Tac-Tics> When I think of evaluating down to WHNF, I think of squeezing tooshpaste out of a tube.
22:00:57 <Cale> You can also just use case
22:01:25 <Cale> (which is effectively the same thing as seq, but for one type at a time)
22:01:28 <Tac-Tics> What does the strict ! annotation do then? WHNF or HNF?
22:01:39 <Cale> I don't think you can do HNF
22:02:02 <bos> you can't, correct.
22:02:11 <bos> seq and ! both get you WHNF.
22:02:26 <Cale> Since that involves evaluating under lambdas doesn't it?
22:02:29 <bos> you can write your own deepSeq function that can perform case analysis of your types.
22:02:40 <bos> right.
22:02:56 <Cale> Like \x -> (\y -> x + y) 5
22:03:06 <Cale> Is in WHNF but not HNF
22:03:10 <bos> Tac-Tics: usually, a deepSeq is a lose because of the extra work it incurs for forcing stuff that's already forced.
22:03:30 <Tac-Tics> Does it reevaluate it or something?
22:03:33 <bos> not to mention the keyboarding overhead.
22:03:47 <bos> no, it doesn't reevaluate, but it has to check to see if it needs to force each value.
22:04:03 <ddarius> It also has to traverse the value.
22:04:04 <bos> where "it" is the runtime machinery.
22:04:35 <bos> right. so if you call deepSeq on a million-element tree ten times, it's doing ten million bits of unnecessary work.
22:04:48 <clanehin> I believe haskell' should specify a more performant strict.
22:05:03 <Cale> clanehin: what's wrong with seq?
22:05:06 <ddarius> bos: Well -up to- 10 million, at least 9 million.
22:05:11 <Tac-Tics> I don't quite understand the ramifications of marking a field as strict
22:05:29 <Tac-Tics> it forces the value, so it takes up less memory, and it will hang on _|_
22:05:30 <ddarius> Tac-Tics: All it means is that the constructor is strict in that field just like any other function.
22:05:32 <Tac-Tics> is there anything else?
22:05:36 <clanehin> Cale: I mean deeply, what their talking about
22:05:45 <ddarius> clanehin: deepSeq is a library function.
22:05:59 <Cale> clanehin: I don't see how it could possibly do it any more efficiently than deepSeq already does.
22:06:02 <ddarius> (and a 3rd party one at that)
22:06:15 <lispy> anyone familiar with 'Sealed' types?
22:06:19 <clanehin> put a flag in each thunk indicating that it's deepSeqed?
22:06:22 <ddarius> Cale: They could make the language strict, that'd do it.
22:06:33 <Cale> Well, yes, but that would be screwed up.
22:06:36 <clanehin> and compile-time strictness
22:06:57 <bos> lispy: you must be wanting #scala
22:06:58 <lispy> data Sealed a where Sealed :: a x -> Sealed a
22:06:59 <Cale> At that point, I would personally start a fork of GHC.
22:07:17 <Cale> Regardless of the fact that I know next to nothing about the source of GHC :)
22:07:21 <ddarius> clanehin: There is no way to achieve what deepSeq does (asymptotically) faster (except by making it trivial).
22:07:22 <lispy> that sealed type seals off the x
22:07:33 <celske> how would i go about removing ghc 6.8.2?
22:07:40 <lispy> bos: perhaps, but this is very definitely haskell i'm knee deep in
22:07:42 <Cale> celske: How did you install it?
22:07:48 <ddarius> clanehin: Also this isn't an issue.  People don't use deepSeq all that much.  As I said, it's not even a standard library function.
22:07:53 <lispy> bos: are sealed types something scala works with?
22:07:56 <gwern> hee hee. I'm trying to see how big a patch I can make to darcs send to dons for Frag; so far I'm up to 200k and I haven't even included the textures or anything :)
22:07:57 <Cale> celske: Typically, remove its files from /usr/local/
22:08:34 <celske> /usr/local/bin?
22:09:34 <clanehin> It's mentioned in the haskell' wiki.  Argue with the wiki if you want to argue.
22:09:37 <bos> lispy: http://www.scala-lang.org/intro/sealedclasses.html
22:09:38 <lambdabot> Title: The Scala Programming Language: Sealed Classes
22:10:09 <lispy> bos: oh, that's different
22:10:32 <lispy> bos: in my case, the type 'Sealed' is a wrapper for an existential type witness
22:10:39 <bos> lispy: yeah. you're doing something with GADTs
22:10:46 <lispy> bos: right
22:10:46 <ddarius> clanehin: The Haskell' wiki doesn't specify your beliefs.
22:10:50 <dons> wow, ok, mersenne twister, naively bound (i.e too many ffi calls).. generating 100000 Ints...
22:10:56 <dons> how long do you think StdGen takes? :)
22:11:03 <dons> to generate 100k Ints?
22:11:09 <bos> a few seconds?
22:11:15 <dons> 1.69s
22:11:22 <dons> and mersenne, 0.06
22:11:28 <lispy> ouch
22:11:35 <bos> yeah, that was about my guess.
22:11:36 <dons> and that's making one ffi call per Int.
22:11:44 <dons> the lib lets us generate a chunk at a time.
22:11:47 * dons adds that..
22:11:51 <gwern> StdGen is not optimised I guess
22:11:53 <monochrom> Nice nice nice!
22:12:04 <clanehin> ddarius: I wouldn't expect it to.  My beliefs are substantial, and the haskell' committee, in all it's wisdom, can not read my mind
22:12:07 <monochrom> StdGen is not unoptimised either. :)
22:12:32 <monochrom> Mersenne twister is algorithmically more sophisticated than StdGen.
22:12:35 <gwern> (nice. the old-time dependency in Frag wasn't actually needed)
22:12:53 <Tac-Tics> Is the Haskell' committee on a schedule for anything?
22:12:58 <bos> StdGen is fairly awful.
22:13:10 <ddarius> Tac-Tics: Yes.  Haskell 2 will be done November 2006.
22:13:17 <Tac-Tics> heh
22:13:27 <monochrom> Then again, StdGen is linear congruential, lots of divisions. Mersenne twister is just bits, very easy to get fast.
22:14:14 <gwern> ddarius: an aggressive schedule. do you think they can meet it?
22:14:23 <ddarius> gwern: I have faith.
22:14:34 <dons> faith in time travel monad transformers
22:14:41 <gwern> (as a mustard seed...)
22:14:51 <monochrom> Is the past deterministic? :)
22:15:09 <sclv> I think I was reading about a sealed in one of the MLs too.
22:15:11 <Pseudonym> How many alps of faith?
22:15:18 <gwern> backtrack and find out
22:15:45 <monochrom> There was a plan for SML-2000. :)
22:15:47 * bos packs dons into an existential and sends him back to 2004 as a type witness
22:16:10 <Tac-Tics> I'm determined to compute nondeterministically
22:18:39 <jfredett> dons, that Mersenne twister thing, thats not written in Haskell, right?
22:19:03 <monochrom> FFI-binding to someone else's SSE2 code.
22:19:08 <dons> yep
22:19:10 <jfredett> right
22:19:16 <dons> though Random is post-processing the raw results
22:19:30 <dons> (and inefficiently!)
22:19:34 <jfredett> you think a pure haskell implementation might be faster? (i ask because it might be a fun project for me.)
22:19:39 <dons> nope.
22:19:47 <jfredett> would it be worth doing?
22:19:48 <jfredett> :P
22:20:02 <dons> unless your pure haskell generates specialised, with constants folded, compiles it with harpy, and returns that? :
22:20:15 <dons> in which case you've got an icfp paper too
22:20:24 <jfredett> dons: well, I haven't written it yet.
22:20:30 <monochrom> http://www.augustsson.net/Darcs/MT/ already has a pure Haskell implementation. I found it through wikipedia :)
22:20:31 <lambdabot> Title: Index of /Darcs/MT
22:20:43 <bos> it's not a general purpose PRNG, in any case.
22:21:28 <monochrom> Why is it not general purpose?
22:21:46 <monochrom> (I think if it's good for simulations, it's general purpose enough.)
22:21:51 <bos> it has a long period, but it's easy to observe its internal state.
22:22:02 <jfredett> its not cryptography-grade randomness
22:22:03 <bos> you can predict all future output with just a few hundred observations.
22:22:17 <jfredett> 647, accoring to wikipedia, IIRC
22:22:28 <monochrom> Is linear congruential even easier to predict?
22:22:29 <bos> it's around 620, yes.
22:22:37 <bos> yes.
22:22:39 <dons> yeah, good for monte carlo, where you need lots with a good distribution, quickly
22:23:02 <bos> haskell's linear congruential generator has just 64 bits of effective state.
22:23:19 <monochrom> I personally equate monte-carlo with general-purpose. crytography is not general purpose.
22:24:16 <geezusfreeek> interesting that i stumble in here and see this conversation as i am toying with genetic programming in haskell at the moment
22:24:17 <ddarius> I'm roughly in the same area as monochrom.  Any cryptographic random number generator is not general purpose and thus there are no "general purpose" random number generators.
22:25:27 <bos> that's a reasonable perspective.  i use cryptographic PRNGs to generate unforgeable capabilities, so that colours my perception of "general purpose".
22:26:26 <Pseudonym> Well, the important thing is that crypto PRNGs must be not reverse-engineerable.
22:26:26 <lispy> http://www.haskell.org/haskellwiki/Type_witness
22:26:28 <lambdabot> Title: Type witness - HaskellWiki
22:26:38 <lispy> I don't think that wikipage helps much :)
22:26:41 <Pseudonym> Most random number clients don't care about that feature.
22:26:46 <lispy> (but I'm not sure how to make it better...)
22:26:55 <gwern> bos: capabilities? as in capability security?
22:27:00 <bos> gwern: yes
22:27:02 <geezusfreeek> anybody know of any good links detailing the algorithm behind StdGen?
22:27:37 <ddarius> Pseudonym: We know.
22:27:37 <bos> geezusfreeek: it's the Portable Combined Generator of L'Ecuyer
22:27:43 <Tac-Tics> Does anyone want to help me understand Control.Applicative tonight?
22:27:48 <geezusfreeek> that works, thanks
22:27:59 <Pseudonym> I know you know.  I'm just sayin'.
22:28:23 <dons> using the sse2 support makes it 3-4x faster again. very nice
22:28:38 <sclv> Tic-Tacs: have you read the paper the haddocks link?
22:29:01 <ddarius> GHC 6.10 with two orders of magnitude faster random number generation!
22:29:06 <bos> Tac-Tics: <$> is fmap. <*> is kind of like >>=. the rest is just gravy.
22:29:27 <Tac-Tics> sclv: Yes, I read the paper, but it was a little over me
22:29:48 <ddarius> <*> is even more kind of like ap
22:29:54 <Tac-Tics> I know the laws alone define what an applicative functor is, but it doesn't really help me understand them conceptually
22:30:01 <sclv> and even more kind of like `ap` !
22:30:03 <bos> ddarius: better, yes.
22:30:06 <Tac-Tics> I know pure = return and <*> = ap if it's also a monad
22:30:24 <Tac-Tics> but what *is* an applicative functor?
22:31:19 <ddarius> Tac-Tics: You already said.  The question you are asking now is ill-defined (or already answered) by your own admitting.
22:31:42 <Tac-Tics> buh?
22:32:03 <ddarius> [23:29] <Tac-Tics> I know the laws alone define what an applicative functor is [...]
22:32:22 <Pseudonym> I suspect that Tac-Tics wants some intuition, and examples that distinguish it from a monad.
22:32:36 <ddarius> Pseudonym: I do too, but he should learn to ask that.
22:32:39 <Tac-Tics> Pseudonym: yes, thank you, that is what I'm asking for
22:32:56 <Pseudonym> That's why I'm posing a correct question instead of answering the question not asked.
22:33:06 * Pseudonym was sick of the dancing around
22:33:46 <ddarius> Pseudonym: I considered telling him what he meant, but I decided not to.
22:34:05 <ddarius> Tac-Tics: Examples were given in the paper and there are others around.
22:34:35 <ddarius> Giving an intuitive idea that is still completely general is harder.
22:35:01 <Pseudonym> ddarius: While that's true, it's possible to give some intuition that covers most cases.
22:35:04 <Pseudonym> Take monads, for example.
22:35:09 <ddarius> Pseudonym: Of course.
22:35:11 <Pseudonym> "Monad as abstracted control" is not bad.
22:35:18 <Pseudonym> Add to that "monad as container".
22:35:26 <Pseudonym> And "monad as variable substitution".
22:35:27 <clanehin> Tac-Tics: in many (all?) cases it's like "genericZipWithN"
22:35:28 * ddarius poos on "monad as container"
22:35:32 <Pseudonym> And you've coverd 99.9% of cases.
22:35:39 <ddarius> "monad as variable substitution" is rather general
22:35:41 <Pseudonym> OK, "monad as comprehension".
22:36:41 <Tac-Tics> @src zipWith
22:36:42 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
22:36:42 <lambdabot> zipWith _ _      _      = []
22:36:47 <Tac-Tics> @src zipWith2
22:36:47 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
22:36:59 <clanehin> zipWith is zipWith2
22:37:13 <clanehin> fmap is zipWith1
22:37:14 <Tac-Tics> heh
22:37:25 <Pseudonym> ddarius: It is general, but it's a great way of looking at things.
22:37:55 <Tac-Tics> clanehin: ah, that's really cool
22:38:03 <Pseudonym> > [0,1,0,1,0] >>= (\x -> if x == 0 then [1,1] else [0])
22:38:04 <lambdabot>  [1,1,0,1,1,0,1,1]
22:38:08 <Pseudonym> That sort of thing.
22:38:17 <clanehin> like how return is liftM0
22:38:47 <ddarius> Pseudonym: "but" ?  I was saying that that intuitive idea comes close to completely generally capturing the idea behind monads.
22:39:13 <Tac-Tics> Someone should make a chart of those things
22:39:18 <Pseudonym> The thing is, those three examples cover 99.9% of uses of monads, and probably 100% of the ones that I've used.
22:39:45 <Pseudonym> Monads are _not_ an overloaded semicolon.
22:39:50 <Pseudonym> But that's a good piece of intuition.
22:39:53 <Tac-Tics> It may be obvious to math majors specializing in Category Theory, but not to us lowly CS guys. Seeing the symmetry between all those functions (with unrelated names) is really neat
22:40:22 <BMeph> clanehin: I like to think of repeat as zipWith0 - that's why it's "pure" for ZipLists.
22:40:22 <monochrom> Intuition cannot be communicated. (By definition of intuition.) But tons of examples can be communicated, and that is the ingredient of intuition.
22:40:26 <Cale> Tac-Tics: Do you know about map = (.) ?
22:40:26 <Tac-Tics> Monads, in my mind, is state + misc. crazy shit (list and cont)
22:40:27 <Cale> :)
22:40:50 <ddarius> Pseudonym: "monads as abstracted control" doesn't mean anything to me.  "monads as containers" only captures a rather special case and then it's more freeness rather than monadicness that's important.  "monads as variable substitution" as I said, is pretty general.
22:41:13 <bos> we need monad superheroes.  State s a helps little old programmer ladies cross the functional street!  List can't decide what she wants to do, so she does everything!  Identity has the power of disguise!  Cont can travel through time!
22:41:19 <ddarius> Tac-Tics: Monads aren't tied to state.
22:41:23 <Pseudonym> Obviously "abstracted control" needs some examples.  "Overloaded semicolon" is probably a more spiffy slogan.
22:41:25 <sclv> Tac-Tics: I just started programming with applicative combinators wherever possible and a strong intuition about how they work began to creep up on me.
22:42:11 <Tac-Tics> ddarious: but it's one of their most important uses in Haskell, and is a good way to fall back when those three laws stare you down saying "You're not smart enough to do Haskell"
22:42:14 <Japsu> @remember bos we need monad superheroes.  State s a helps little old programmer ladies cross the functional street!  List can't decide what she wants to do, so she does everything!  Identity has the power of disguise!  Cont can travel through time!
22:42:14 <geezusfreeek> i always just think of monads like this: if i have a type constructor m and functions like a -> ma and m (m a) -> m a, then i probably have a monad and can probably do cool things with it
22:42:14 <lambdabot> Okay.
22:42:24 <monochrom> Japsu beats me to it. :)
22:42:29 <Japsu> ^________^
22:42:40 <BMeph> I think of Applicatives as Monad, but w/o the bind, just the >> operation.
22:43:33 <Tac-Tics> BMeph, is that exactly how they work? or just a way to think about it?
22:43:48 <Cale> Uh, it's more like with just ap and return
22:43:57 <Cale> I don't think just >> will do.
22:43:59 <sclv> maybe as "monads that can't model state" as a metaphor?
22:44:03 <Tac-Tics> k
22:44:11 <sclv> s/state/mutable state/
22:44:11 <Cale> (kind of hard to define ap with just >>)
22:44:27 <ddarius> Tac-Tics: You could say Applicative Functors are just Monads without (>>=) only ap (and return), but then you are just restating the definition.
22:45:20 <geezusfreeek> Tac-Tics: as you are probably catching on, you're not really gonna get much of a straight metaphor without it limiting your perceptions of what Applicative actually is
22:45:24 <ddarius> Tac-Tics: But that does bring up one facet.  Applicative functors don't make ordering explicit.
22:45:29 <Cale> I think the specific monad that made the whole idea click for me was Parsec.
22:45:54 <Cale> It's just general enough -- not quite state, not quite plain nondeterminism.
22:46:25 <Tac-Tics> Parsers are a StateT List, right?
22:46:40 <Cale> Tac-Tics: they can be, but usually aren't
22:46:54 <Tac-Tics> *usually* aren't?
22:46:57 <Cale> right
22:47:26 <Cale> Because due to the specific way that you're managing that state, for performance reasons, you want to so something which is more breadth-first than depth-first.
22:47:30 <Cale> do*
22:47:43 <geezusfreeek> i actually don't think i really understood monads until i skipped to monad transformers
22:47:49 <Pseudonym> StateT List is one possible implementation, though.
22:47:50 <Cale> So that the garbage collector can collect the start of the string.
22:47:53 <monochrom> It took you several years to learn "numbers". (And some other people, never.) Don't expect instant enligtenment on the next level of abstraction that is Applicative.
22:47:59 <geezusfreeek> but i would never recommend that for somebody else ;)
22:48:01 <ddarius> Pseudonym: For some parsers...
22:48:05 <Pseudonym> Sure.
22:48:27 <Pseudonym> Not necessarily for Parsec.
22:48:32 <Cale> A lot of people really still don't understand numbers. You don't really understand numbers until the difference between "5" and "5 apples" is perfectly clear.
22:48:51 <ddarius> monochrom: How is Applicative a "next level of abstraction"? Functor is more general and Monad more specific.
22:49:01 <Tac-Tics> apples is the linear operator, 5 is the scalar
22:49:05 <sclv> the difference is apples? apples are tasty.
22:49:07 <monochrom> "next" is very, very loose.
22:49:18 <Korollary> It's apples and oranges.
22:49:41 <Pseudonym> Which are perfectly comparable.
22:49:57 <geezusfreeek> Verizon doesn't understand numbers
22:49:59 <ddarius> Depends on the poset.
22:50:02 <bos> i couldn't resist: http://programming.reddit.com/info/65u74/comments/
22:50:10 <ddarius> For shame bos.
22:50:10 <Tac-Tics> Most of my mathematical intuition, I feel, comes from programming. So getting enough background and intuition will get me sailing
22:50:10 <Cale> The thing is that numbers don't really exist in the same sense as physical objects. The natural numbers are a man-made abstraction.
22:50:24 <ddarius> Tac-Tics: So look at examples.
22:50:47 <Tac-Tics> Man is clearly a numerical abstraction
22:50:50 <Cale> I'd also include *really* understanding what the distributive law means as another big step in that direction.
22:51:19 <Cale> Though, in some sense, nobody does.
22:51:29 <Tac-Tics> ddarius: I will take another look and take into consideration what people have said here
22:52:33 <gwern> (got my Frag patches up to 424K now.)
22:53:09 * gwern is shooting for a cumulative, excluding binaries, darcs send -o size equivalent to a hello world binary
22:54:16 <Tac-Tics> I always fought with my math teachers about notation.
22:54:31 <Tac-Tics> I remember, especially in calculus, I was always looking for more expressive ways of notating my work
22:54:48 <Tac-Tics> and I was frustrated no one could explain what the "dx" and "dy"'s were for
22:55:14 <gwern> Tac-Tics: you should've gone back in time and talked to leibniz
22:55:19 <Tac-Tics> I know they were quantities that "approached zero", but what does that even mean? That's not rigorous!
22:55:19 <monochrom> If you continued into differential geometry, you might see an explanation.
22:55:40 <ddarius> Tac-Tics: That can be made rigorous (albeit not with the real-number line)
22:55:53 <jfredett> dx and dy, as I remember, come from the concept of infintessimals
22:56:00 <glguy> ?seen dons
22:56:00 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 27m 37s ago.
22:56:07 <Tac-Tics> ddarius: I know that now
22:56:10 <glguy> dons: come back :)
22:56:32 <ddarius> d/dx is just a binder.  You can have a differential operator D, so dE/dx = D(\x.E)
22:57:04 <Tac-Tics> d/dx is just a higher order function
22:57:13 <Tac-Tics> but they make it hard in high school calc =-X
22:57:16 <monochrom> To explain anything used in an introductory course, you always need an advanced course.
22:57:21 <jfredett> ddarius: that is the coolest thing I've ever seen...
22:57:22 <ddarius> D is a HOF, d/dx is a binder.
22:57:33 <monochrom> Take Haskell for example.
22:57:35 <Korollary> monochrom: heh
22:58:00 <monochrom> "map f (infinite list here)" works. you even do it all the time in an introductory course.
22:58:58 <monochrom> But how could it possibly work for infinite list? Sometimes people tell you "lazy evaluation", but that is just like saying "how does dx work? that's approaching to 0".  A very rough handwaving answer.
22:59:14 <Cale> I wonder if there's a name for monads such that join is an isomorphism
22:59:33 <jfredett> monochrom: well, monochrom, the answer is it doesn't work on an infinite list, it only works on the parts of the infinite list you ask for
22:59:42 <ddarius> monochrom: lazy evaluation is just an undefined term, "approaching 0" is intuitive but non-rigorous.
22:59:48 <monochrom> To find out what "lazy evaluation" encompasses, you have to take an advanced course on some operational semantics of haskell.
23:00:07 <monochrom> well "lazy" is intuitive too.
23:00:09 <Cale> It doesn't have to be that advanced a course.
23:00:11 <monochrom> or "intuitive".
23:00:24 <Cale> Lazy evaluation is just evaluating things outermost first + sharing.
23:00:29 <Tac-Tics> I think the idea of "approaching zero" in a mathematical notation adds much more complexity than "lazy evaluation" though. Approaching zero is harder to implement
23:01:17 <Tac-Tics> Implement in the Mind OS
23:01:23 <Cale> That's not how I think of dx working, myself
23:01:27 <Riastradh> The fuzzy notion of `a quantity approaching zero' is both bogus and confusing.  The derivative of a function at a point is a linear approximation to that function around that point.
23:01:54 <Riastradh> *Function* is the critical word here, and I don't think it takes an advanced course to talk meaningfully about functions.
23:02:18 <ddarius> The derivative of a function is that thing that makes the fundamental theorem of calculus true.
23:02:19 <Tac-Tics> I like my values to stand still. I ask them kindly not to approach anything other than what they already are.
23:02:47 <quicksilver> "you might want to take a close look at your public persona as exposed on this list"++
23:03:26 <Tac-Tics> There are too many "things" in introductory math classes
23:03:54 <Cale> I wish the mathematics courses they gave to everyone else were more like those which they give to pure mathematics students.
23:04:03 <Tac-Tics> Cale: agreed
23:04:07 <allbery_b> quicksilver: wait until you see his response
23:04:21 <hpaste>  glguy pasted "type safe multiple reader single writer" at http://hpaste.org/5077
23:04:27 <Tac-Tics> it's those quirky scientists! with their abuse of notation and their matricies filled with floating point numbers!
23:04:33 <bos> allbery_b: oh?
23:04:52 <Tac-Tics> or numbers at all! real mathematicians don't need those things, do they?
23:05:04 <allbery_b> roughly, he's justified because he's on a crusade to Correct Errors.  (I thought that went to the list)
23:05:09 <Cale> You need to see examples like f(x) = x^2 when x is rational, f(x) = - x^2 when x is irrational, if you want to really understand the derivative.
23:05:14 <bos> allbery_b: haven't seen it.
23:05:17 <allbery_b> hm
23:05:20 <ddarius> quicksilver: He's quite aware of his public persona.
23:05:22 <glguy> that code ensures that the Handle is protected for reading and writing
23:05:27 <glguy> and that the handle can never escape
23:05:41 <bos> i'm all for correcting errors, though perhaps a bozoticism diet would be justified in his case.
23:05:42 <glguy> and that the resource can be used by multiple readers or a single writer
23:05:45 <allbery_b> probably for the best.  smother the fire, don't feed it
23:05:50 <glguy> feedback?
23:06:08 <Cale> Most of the courses for nonmathematicians don't touch the "strange" examples that are crucial in tempering one's understanding of the concepts.
23:06:09 <glguy> suggestions..
23:06:12 <monochrom> Anyway I want to say that, in the seeking of truth, it is the case that introductory material is based on advanced material, not the more expected opposite. On the road to truth, each answer leads to a harder question, not an easier question.
23:06:27 <quicksilver> ddarius: I daresay.
23:06:47 <Cale> Calculus is a boring subject if all your functions are infinitely differentiable.
23:07:18 <Cale> It's the screwed up boundary cases which make it really interesting and fun :)
23:07:41 <bos> glguy: i can read the code, and yet i can't tell what you're trying to do
23:07:47 <glguy> :(
23:07:54 <Cale> (well, okay, I can think of one example of an infinitely differentiable function which behaves poorly :)
23:07:57 * ddarius prefers the screwed up interior cases.
23:07:57 <monochrom> glguy: standard trick. nice. :)
23:08:16 <glguy> I want to ensure that a given handle, while in scope for reading, can't be in scope for writing
23:08:20 <Cale> f(0) = 0, f(x) = e^(-1/x^2)
23:08:28 <glguy> and that a handle in scope for writing can't be in scope for reading
23:08:31 <glguy> ever
23:08:36 <Tac-Tics> monochrom: The seeking of satisfaction as a coder is just the opposite. Get the hard details out of the way, then dink the rest of your life away with what you can visualize in an instant, but which takes forever to get the details quite right
23:08:41 <glguy> (while multiple read blocks can run in parallel)
23:08:43 <ddarius> Cale: That's a standard one.
23:08:48 <Cale> ddarius: yeah
23:09:29 <Cale> all its derivatives at 0 are 0, and yet it's not the zero function.
23:09:30 <gwern> (and with the first set of binary patches included in the set of 56 patches, my darcs send -o jumps to 36M!)
23:09:32 <bos> glguy: so this is a reader/writer lock?
23:09:42 <monochrom> I don't understand what is "satisfaction as a coder".
23:09:57 <glguy> bos: yeah, implementation of multiple readers single writer  with type-system enforcement
23:10:27 <glguy> runRead h (\ the_handle -> return the_handle) fails
23:10:28 <Cale> another nice example when working with limits and integrals is the function f(x) = 0 when x is irrational, and f(p/q) = 1/q when p/q is a rational number with gcd(p,q) = 1.
23:10:35 <glguy> because it wouldn't be polymorphic enough
23:10:35 <Tac-Tics> Weird choice of words, sorry. I meant that I finished seeking truth a while ago, and now I'm just here to learn and have fun programming in a crazy language like Haskell
23:10:39 <glguy> like ST, it keeps the Handle inside
23:10:49 <bos> glguy: oh, i see, each annotation is a different module.
23:10:52 <monochrom> I also think that "can visualize in an instant" is a severe restriction.
23:10:57 <glguy> bos: oh, yeah!
23:11:00 <bos> glguy: i was just looking at the last one, assuming it was all there was.
23:11:01 <Cale> That's a function I think everyone who's seeing limits for the first time should see.
23:11:02 * ddarius tends not to care too much about pathological examples as he tends to be interested in what you can actually -do- with math.
23:11:13 <bos> glguy: so i couldn't see where your type safety was coming from :-)
23:11:16 <glguy> one example, one readers/writer lock, and one wrapper for handles
23:11:29 <Cale> ddarius: That's the point -- pathological examples show you where the edges of what you can do are.
23:11:45 <lispy> so, once i seal a type (and hide the witness) I can't unseal the type and regain the same witness, it becomes a new witness.  Thus, if I have some other type hanging around with the same original witness, I can't put them back together.
23:12:02 <Cale> Like, with that function, the limit as x -> a for every a is defined.
23:12:04 <ddarius> Cale: I agree.  Especially when you said "in tempering one's understanding of the concepts"
23:12:14 <lispy> (this is with existential witnesses, bTW)
23:12:32 <Cale> Even though the function is discontinuous at infinitely many points. :)
23:12:34 <bos> glguy: so that defends statically against me trying to read and write the same file simultaneously.
23:12:44 <glguy> yeah
23:12:51 <ddarius> But, I am not with you in having a desire to explore pathological examples much beyond that, but more interested in taming the useful non-functions.
23:13:05 <glguy> bos: well.. the same handle
23:13:05 <bos> glguy: but if i'm holding the read lock, i can't promote it?
23:13:10 <bos> glguy: yes
23:13:18 <Cale> ddarius: non-functions?
23:13:37 <glguy> bos: multiple readers
23:13:40 <bos> glguy: it's cute, but doesn't look like it's solving a problem i can recall having.
23:13:56 <monochrom> My foregoing argument is trying to show that it takes years to learn anything significant. It is impossible to visualize at an instant. You can only expect visualize over the years.
23:13:59 <ddarius> Cale: Things that aren't functions in the pre-Cantor conception of functions.  Things which lead to terms like "generalized function".
23:14:00 <glguy> bos: it's directly related to a problem we were solving at work
23:14:10 <glguy> I'm just sharing the common case
23:14:17 <bos> ah.
23:14:19 <Cale> ddarius: are you talking about things like the Dirac delta?
23:14:20 <glguy> bos: holding the read lock doesn't tell you other people aren't reading
23:14:26 <ddarius> Cale: Primarily, yes.
23:14:27 <glguy> so you can't promote it directly
23:14:34 <Cale> ddarius: I'd prefer to save things like that for after a course in measure theory.
23:14:35 <Tac-Tics> Sometimes I feel like I flip between thinking math is deep and fun to learn, and that it's pointless and difficult. It says so much, and so much of it is totally useless. It says it like it is, and all other areas of study are just approximating what it has to say.
23:14:52 <bos> glguy: also, it doesn't handle aliasing by reopening the same file, or access by multiple processes.
23:15:00 <ddarius> In general, I tend to take an axiomatic view of things.  I define things as the things that make what I want true true.
23:15:16 <Cale> Tac-Tics: mathematics is a game which is played not for its useful consequences, even though it happens to have many. :)
23:15:18 <bos> the latter is the one that bugs me about Handles.  give me my unix file semantics, not that windows retardage!
23:15:25 <glguy> bos: by ensuring that we only create the resource once
23:15:31 <glguy> bos: we can be more liberal about how we use it later
23:15:59 <glguy> but sure, if you kne wthe file name, for example, you could rreate more handles
23:16:01 <balodja> Cale: And what's the limit of function, mentioned above? For example, at 0.5 or at sqrt(2). Is it +inf?
23:16:03 <bos> glguy: so you have a memoising open function that hands out the same handle repeatedly to concurrent accessors?
23:16:15 <Cale> balodja: the limit is 0 at every point
23:16:23 <balodja> Why?
23:16:25 <monochrom> All the craze over NHL, MBA, NFL, ... people think they are fun. Players think they are deep. I think they are pointless and difficult.
23:16:27 <glguy> bos: well, the handle is easy for all the threads to find
23:16:44 <Riastradh> Cale, with that perspective, any practically useful insight that you might have to suggest is unlikely to be taken seriously by people for whom mathematics is a language for communicating ideas precisely, and not a way of life.
23:16:46 <glguy> bos: in the particular application of this technique
23:16:47 <monochrom> Anyway, just want to say some fun things are necessarily pointless.
23:16:47 <Cale> balodja: because for any e > 0, there is some d > 0 such that whenever 0 < |x - a| < d, we have |f(x)| < e
23:17:02 <bos> glguy: fair enough. it's a perfectly sensible thing to do.
23:17:14 <Tac-Tics> We should come up with an axiomatic model of pointlessness
23:17:34 <Cale> Tac-Tics: my friend was working on the same thing :)
23:17:42 <Cale> "Useless theory"
23:17:45 <Cale> heh
23:17:48 <Tac-Tics> lols
23:17:53 <Cale> Was a running joke :)
23:18:01 <Tac-Tics> Actually, I always wondered about a semi-formal Blame Theory
23:18:08 <glguy> bos: mind if I /msg you?
23:18:19 <Tac-Tics> When an even of some sort occurs, what actors in the event were "to blame" for it
23:18:27 <Riastradh> Cale, however, most of those who try to use mathematics not as a way of life but as a language for communicating ideas precisely are the worst offenders of imprecision in mathematical communication.
23:18:31 <lispy> who is writing pragmatic haskell, is that bos?
23:18:32 <bos> glguy: no prob
23:18:52 <Riastradh> (...are *often* the worst offenders, I mean.)
23:18:56 <sfultong> what's the name of the offtopic version of this channel again?
23:18:59 <bos> lispy: no, some random blogger
23:19:00 <monochrom> Software engineering researchers are actually working on "blame analysis".
23:19:04 <ddarius> bos, with dons and CosmicRay, are writing Real World Haskell
23:19:16 <lispy> oh, real world haskell
23:19:17 <ddarius> The other book is being written by Eric Kidd.
23:19:20 <bos> there are three haskell books in the pipeline at the moment.
23:19:20 <lispy> I had the wrong title
23:19:26 <bos> ddarius: no, it's eric something-else.
23:19:29 <Cale> Riastradh: I wonder how many million dollar prizes for digging people out of such quagmires will have to be offered before such people start to understand why a bit of rigour won't hurt :)
23:19:32 <Tac-Tics> monochrom: any sources on that? or was that a joke about the software industry?
23:19:41 <ddarius> bos: Yeah, I thought I got it wrong.
23:19:45 <lispy> bos: will you include some of this existential type witness, GADT wizardry?
23:19:48 <monochrom> No joke. Serious. But I don't have references.
23:20:06 <allbery_b> sfultong: #haskell-blah
23:20:10 <monochrom> I do think your idea is similar to theirs.
23:20:11 <bos> lispy: that's the plan. existentials i have no problem with. haven't played with GADTs yet.
23:20:14 <ddarius> @google Phil Wadler Google Tech Talk blame
23:20:15 <lambdabot> http://dotat.at/log.html
23:20:15 <lambdabot> Title: Tony Finch's URL log
23:20:16 <allbery_b> ubless you're sniding :)
23:20:25 <Tac-Tics> Blame has that sort of diminishing cause and effect, and it would be like a probabilistic graph theory
23:20:27 <sfultong> allbery_b: thanks, silly that I forgot it
23:20:28 <quicksilver> Tac-Tics: can't you be all four?
23:20:31 <lispy> bos: when is the deadline for that part of the book?
23:20:49 <bos> lispy: ask dons :-)
23:20:53 <quicksilver> Tac-Tics: deep,fun to learn, pointless and difficult?
23:21:00 <Riastradh> Cale, I don't think million-dollar prizes will do anything for them, and I think that many of them would argue that rigour can impede their work.  On the other hand, there are still many ways in which their ideas can be communicated much, much more clearly, even without worrying about, say, the convergence of series.
23:21:05 <bos> i think he's the one who ones the type hackery chapter
23:21:05 <ddarius> Cale: A little rigour is helpful.  Too much can be just as harmful as too littel.
23:21:10 <Tac-Tics> quicksilver: Yeah, that's my experience learning haskell thus far
23:21:13 <lispy> bos: i ask because the uses specific to darcs will be covered in some detail my thesis, set to appear in the next 3 to 6 months...might be useful for ya'll
23:21:30 <bos> oh, cool
23:21:39 <Cale> Riastradh: I'm referring mostly to the prize regarding Yang-Mills theory :)
23:21:40 * lispy has to learn it better in that time of course
23:22:22 <Cale> ddarius: Yeah, but the important thing is to always have the sense of rigourisability. That if at any point, you wanted to write things down such that a computer could check them, you could.
23:22:46 <Cale> Even if you never actually do this :)
23:23:24 * lispy &
23:23:36 <Korollary> Is that even a word?
23:23:43 <Cale> Korollary: it is now :)
23:24:19 <monochrom> You get two for one. rigourisability, rigourizability
23:24:55 <Cale> monochrom: ssh! The americans might hear and start spelling it the second way.
23:25:13 <glguy> That's "Americans" to you!
23:25:18 <monochrom> They also love pizza shops that offer "2 for 1" deals.
23:25:19 <sarehu> we have so many time zones that you're never safe on IRC
23:26:13 <Cale> glguy: You don't get to be capitalised until you kick your president out of office!
23:26:41 <glguy> You forgot a "zee" ;-)
23:26:48 <Tac-Tics> If you're working in the identity monad, return = id and >>= is flip ($), right?
23:26:57 <ddarius> Tac-Tics: Yes.
23:27:05 <Tac-Tics> (I'd like math more if it was easier to check you work like it is in computer science)
23:27:16 <ddarius> Tac-Tics: Apply it.
23:27:29 <Tac-Tics> especially with those super terse books. You never quite know if you have it right
23:27:35 <balodja> Cale: Why is that function so complicated? Why do not just take something like f(x) = 1 when x is natural and f(x) = 0 otherwise? This one also has limit at every point and also has infinite number of discontinuities.
23:27:53 <ac> is this: inBounds a i = let b = bounds a in i >= fst b && i <= snd b -- defined anywhere?
23:28:24 <quicksilver> balodja: the other one has a densely infinite number of discontinuities
23:28:31 <Cale> balodja: Well, okay, it's not just that there are infinitely many discontinuities that's interesting, it's that there are infinitely many in every interval.
23:28:34 <quicksilver> balodja: that's a bit more pathalogical
23:29:11 <quicksilver> you can do weird stuff with cantor sets too
23:29:22 <Cale> The function you propose is not so much more interesting than the function with one discontinuity, since the discontinuities are all far apart, and limits are local phenomena.
23:29:49 <monochrom> ac: Ix has method inRange.
23:30:00 <balodja> Yep, I see.
23:30:12 <Cale> yeah, like constructing continuous functions which are differentiable almost everywhere, with derivative 0 that are not the zero function :)
23:30:29 <sarehu> yeah, f(x) = 1 :P
23:30:40 <Tac-Tics> pwned
23:30:45 <Cale> Heh, or a vertical translation :)
23:31:08 <Cale> To be concrete, let's pin f(0) = 0, f(1) = 1 :)
23:31:29 <ac> monochrom: thanks. Looks like I want: flip inRange
23:32:20 <Cale> http://en.wikipedia.org/wiki/Cantor_function
23:32:21 <lambdabot> Title: Cantor function - Wikipedia, the free encyclopedia
23:33:10 * ddarius feels the urge to mention Lakatos' "Proofs and Refutations"
23:33:26 <monochrom> What does it do?
23:37:51 <Tac-Tics> bah, for the Identity monad, what is the type? Using Monad ((->) x) is giving me occurs checks
23:38:11 <ddarius> type Identity a = a
23:38:24 <ddarius> However, you can't make a monad instance of that.
23:38:25 <bos> newtype Identity a = Identity a
23:38:47 <Tac-Tics> I thought about using Monad a, but that wouldn't work. Is creating a polymorphic wrapper type the only way to do that then?
23:39:02 <ddarius> Tac-Tics: Yes.
23:39:12 <Tac-Tics> ah, yeah, because monads need to be * -> *
23:39:13 <bos> you have to have a type constructor.
23:40:14 <Tac-Tics> I really skimmed the type section of the wikibook when I began learning this language =-X But given enough time, I generally remember what basic principle I'm screwing up when I do stuff like this
23:45:31 <Tac-Tics> @src ap
23:45:31 <lambdabot> ap = liftM2 id
23:45:53 <Tac-Tics> @src liftM2
23:45:53 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
23:49:22 <ac> why doesn't this work: (,2) 1 -- ?
23:49:58 <ac> > (flip (,) 2) 1
23:50:01 <lambdabot>  (1,2)
23:51:21 <Korollary> @pl \x -> (x,2)
23:51:21 <lambdabot> flip (,) 2
23:55:18 <jedbrown> ac: You can't section the (,) function.  I think it's unfortunate, but perhaps there is a compelling reason.
23:55:58 <araujo> Because it is an ADT?
23:56:44 <olsner_> (,) isn't an operator, so (a,b) and (a,b,c) etc are special syntaxes for tuple constructions
23:58:59 <jedbrown> Right.  So it would need to be an explicit exception, thus complicating parsing.  It would still be nice sugar.
23:59:11 <ac> it might be cool if you could section larger tuples, like: zipWith (,c,) ....
